<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="openjdk">
    <body>
      <group id="openjdk">
        <trans-unit id="55e80b82ba0e613e2bb9e96436b7f7884b762e6f" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;obj&lt;/var&gt; is an instance of &lt;code&gt;javax.management.openmbean.CompositeData&lt;/code&gt;, then let &lt;code&gt;ct&lt;/code&gt; be its &lt;code&gt;CompositeType&lt;/code&gt; as returned by &lt;a href=&quot;compositedata#getCompositeType--&quot;&gt;&lt;code&gt;CompositeData.getCompositeType()&lt;/code&gt;&lt;/a&gt;. The result is true if &lt;code&gt;this&lt;/code&gt; is &lt;em&gt;assignable from&lt;/em&gt;&lt;code&gt;ct&lt;/code&gt;. This means that:</source>
          <target state="translated">如果 &lt;var&gt;obj&lt;/var&gt; 是实例 &lt;code&gt;javax.management.openmbean.CompositeData&lt;/code&gt; 中，然后让 &lt;code&gt;ct&lt;/code&gt; 是它 &lt;code&gt;CompositeType&lt;/code&gt; 通过返回的&lt;a href=&quot;compositedata#getCompositeType--&quot;&gt; &lt;code&gt;CompositeData.getCompositeType()&lt;/code&gt; &lt;/a&gt;。如果结果为真 &lt;code&gt;this&lt;/code&gt; 是&lt;em&gt;从分配&lt;/em&gt; &lt;code&gt;ct&lt;/code&gt; 。这意味着：</target>
        </trans-unit>
        <trans-unit id="c5b21be35113bc2c3c5695016e41e7a8961aa607" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;obj&lt;/var&gt; is an instance of &lt;code&gt;javax.management.openmbean.TabularData&lt;/code&gt;, say &lt;code&gt;td&lt;/code&gt;, the result is true if this &lt;code&gt;TabularType&lt;/code&gt; is &lt;em&gt;assignable from&lt;/em&gt;&lt;a href=&quot;tabulardata#getTabularType--&quot;&gt;&lt;code&gt;td.getTabularType()&lt;/code&gt;&lt;/a&gt;, as defined in &lt;a href=&quot;compositetype#isValue-java.lang.Object-&quot;&gt;&lt;code&gt;CompositeType.isValue&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;var&gt;obj&lt;/var&gt; 是实例 &lt;code&gt;javax.management.openmbean.TabularData&lt;/code&gt; 中，说 &lt;code&gt;td&lt;/code&gt; ，如果这样做的结果是真实的 &lt;code&gt;TabularType&lt;/code&gt; 是&lt;em&gt;分配从&lt;/em&gt;&lt;a href=&quot;tabulardata#getTabularType--&quot;&gt; &lt;code&gt;td.getTabularType()&lt;/code&gt; &lt;/a&gt;，中定义&lt;a href=&quot;compositetype#isValue-java.lang.Object-&quot;&gt; &lt;code&gt;CompositeType.isValue&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f2bc555f2367ab62f427bf89fb970ff34e2a7eac" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;obj&lt;/var&gt; is null or is not an instance of &lt;code&gt;javax.management.openmbean.CompositeData&lt;/code&gt;, &lt;code&gt;isValue&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;var&gt;obj&lt;/var&gt; 为null或不是 &lt;code&gt;javax.management.openmbean.CompositeData&lt;/code&gt; 的实例，则 &lt;code&gt;isValue&lt;/code&gt; 返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f7fca7400d753ab2ac94fb4572ae69584ddad617" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;obj&lt;/var&gt; is null or is not an instance of &lt;code&gt;javax.management.openmbean.TabularData&lt;/code&gt;, &lt;code&gt;isValue&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;var&gt;obj&lt;/var&gt; 为null或不是 &lt;code&gt;javax.management.openmbean.TabularData&lt;/code&gt; 的实例，则 &lt;code&gt;isValue&lt;/code&gt; 返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f6eb29fd93b0c765afc3bd3b512f90a195dcbb2f" translate="yes" xml:space="preserve">
          <source>If BeanContext parameter is null, then it shall associate the Applet with its appropriate Container by adding that Applet to its Container via an invocation of add(). If the BeanContext parameter is non-null, then it is the responsibility of the BeanContext to associate the Applet with its Container during the subsequent invocation of its addChildren() method.</source>
          <target state="translated">如果BeanContext参数为空,那么它应通过调用add()将Applet添加到它的Container中,从而将Applet与相应的Container关联起来。如果BeanContext参数为非空,那么BeanContext有责任在随后调用addChildren()方法时将Applet与它的Container关联起来。</target>
        </trans-unit>
        <trans-unit id="b3801f11fd37bcce7f8fba639fe8d4ee887aad7e" translate="yes" xml:space="preserve">
          <source>If C declares a public field with the name specified, that is the field to be reflected.</source>
          <target state="translated">如果C声明了一个指定名称的公共字段,那就是要反映的字段。</target>
        </trans-unit>
        <trans-unit id="ca26ee5702ced758c636159001396b48df22d8a6" translate="yes" xml:space="preserve">
          <source>If C is a class other than &lt;code&gt;Object&lt;/code&gt;, then this algorithm is invoked recursively on the superclass of C.</source>
          <target state="translated">如果C是 &lt;code&gt;Object&lt;/code&gt; 以外的其他类，则在C的超类上递归调用此算法。</target>
        </trans-unit>
        <trans-unit id="5e9b9649ab976d62198d1ec3dfed66527d11d467" translate="yes" xml:space="preserve">
          <source>If C is the class &lt;code&gt;Object&lt;/code&gt;, or if C is an interface, then the superinterfaces of C (if any) are searched for a matching method. If any such method is found, it is reflected.</source>
          <target state="translated">如果C是 &lt;code&gt;Object&lt;/code&gt; 类，或者C是接口，则在C的超接口（如果有）中搜索匹配方法。如果找到任何这样的方法，则将其反映出来。</target>
        </trans-unit>
        <trans-unit id="2d85abeeeb1aa21f2267ac0f2f921e008ecb6b5d" translate="yes" xml:space="preserve">
          <source>If CPU time measurement is enabled after the thread has started, the Java virtual machine implementation may choose any time up to and including the time that the capability is enabled as the point where CPU time measurement starts.</source>
          <target state="translated">如果在线程启动后启用了CPU时间测量,Java虚拟机实现可以选择任何时间(包括启用该功能的时间)作为CPU时间测量的起始点。</target>
        </trans-unit>
        <trans-unit id="96b2e184e73a9f507b63cab71f6b6a0fc51255aa" translate="yes" xml:space="preserve">
          <source>If CredentialClass is &quot;*&quot;, then access is granted to all private Credentials belonging to the specified &lt;code&gt;Subject&lt;/code&gt;. If &quot;PrincipalName&quot; is &quot;*&quot;, then access is granted to the specified Credential owned by any &lt;code&gt;Subject&lt;/code&gt; that has the specified &lt;code&gt;Principal&lt;/code&gt; (the actual PrincipalName doesn't matter). For example, the following grants access to the a.b.Credential owned by any &lt;code&gt;Subject&lt;/code&gt; that has an a.b.Principal.</source>
          <target state="translated">如果CredentialClass为&amp;ldquo; *&amp;rdquo;，那么将授予对属于指定 &lt;code&gt;Subject&lt;/code&gt; 的所有私有Credential的访问权限。如果&amp;ldquo; PrincipalName&amp;rdquo;为&amp;ldquo; *&amp;rdquo;，则将授予具有指定 &lt;code&gt;Principal&lt;/code&gt; 的任何 &lt;code&gt;Subject&lt;/code&gt; 拥有的指定凭据的访问权限（实际PrincipalName无关紧要）。例如，以下内容授予对具有abPrincipal的任何 &lt;code&gt;Subject&lt;/code&gt; 所拥有的abCredential的访问权限。</target>
        </trans-unit>
        <trans-unit id="6a39eb1a01812d32c33a1ca34fe7c0a3f9fe824c" translate="yes" xml:space="preserve">
          <source>If January 1st is Friday then week 1 starts on January 4th</source>
          <target state="translated">如果1月1日是星期五,那么第一周就从1月4日开始。</target>
        </trans-unit>
        <trans-unit id="8212bef3cde7fd918667a428a4beb2926b2aaf30" translate="yes" xml:space="preserve">
          <source>If January 1st is Monday then week 1 starts on January 1st</source>
          <target state="translated">如果1月1日是星期一,那么第一周就从1月1日开始。</target>
        </trans-unit>
        <trans-unit id="4e1d8c7e06d2ed477961cc6b9bf02767f72d2e8e" translate="yes" xml:space="preserve">
          <source>If January 1st is Saturday then week 1 starts on January 3rd</source>
          <target state="translated">如果1月1日是星期六,那么第一周从1月3日开始。</target>
        </trans-unit>
        <trans-unit id="93384845075a732cc09f28c1fdb3a1493434370f" translate="yes" xml:space="preserve">
          <source>If January 1st is Sunday then week 1 starts on January 2nd</source>
          <target state="translated">如果1月1日是周日,那么第一周从1月2日开始。</target>
        </trans-unit>
        <trans-unit id="d773a45b8b76332ac1c9cf30d6d26cbed25b1ef6" translate="yes" xml:space="preserve">
          <source>If January 1st is Thursday then week 1 starts on December 29th of the previous standard year</source>
          <target state="translated">如果1月1日是星期四,那么第一周就从上一个标准年的12月29日开始。</target>
        </trans-unit>
        <trans-unit id="dff679f893694acfcb5844ad440b7fd91f379885" translate="yes" xml:space="preserve">
          <source>If January 1st is Tuesday then week 1 starts on December 31st of the previous standard year</source>
          <target state="translated">如果1月1日是星期二,那么第一周就从上一个标准年的12月31日开始。</target>
        </trans-unit>
        <trans-unit id="3b4487b7e39c0d7129e69d67e0df2749862989ef" translate="yes" xml:space="preserve">
          <source>If January 1st is Wednesday then week 1 starts on December 30th of the previous standard year</source>
          <target state="translated">如果1月1日是周三,那么第一周就从上一个标准年的12月30日开始。</target>
        </trans-unit>
        <trans-unit id="f38e0c7c32dd408bc04c87c04c2100fa3feb4c90" translate="yes" xml:space="preserve">
          <source>If N equals &lt;code&gt;className&lt;/code&gt;, the result is true.</source>
          <target state="translated">如果N等于 &lt;code&gt;className&lt;/code&gt; ，则结果为true。</target>
        </trans-unit>
        <trans-unit id="0ba990b0a52d90609129011e460cfce22958559a" translate="yes" xml:space="preserve">
          <source>If Q is not a primitive wrapper, cast Q to the base Wrapper(S); for example Number for numeric types</source>
          <target state="translated">如果 Q 不是基元包装器,则将 Q 投放到基元 Wrapper(S)上;例如数字类型的 Number</target>
        </trans-unit>
        <trans-unit id="d4e43d0787d6a1f0ea103acb6274a424055f2393" translate="yes" xml:space="preserve">
          <source>If UDP socket is used, TCP/IP related socket options will not apply.</source>
          <target state="translated">如果使用UDP套接字,TCP/IP相关套接字选项将不适用。</target>
        </trans-unit>
        <trans-unit id="0e9892804baed9af42e82a13b8ef76149b94c399" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;../../lang/securitymanager&quot;&gt;&lt;code&gt;SecurityManager&lt;/code&gt;&lt;/a&gt; is present and no factory is specified, then the default pool uses a factory supplying threads that have no &lt;a href=&quot;../../security/permissions&quot;&gt;&lt;code&gt;Permissions&lt;/code&gt;&lt;/a&gt; enabled. The system class loader is used to load these classes. Upon any error in establishing these settings, default parameters are used. It is possible to disable or limit the use of threads in the common pool by setting the parallelism property to zero, and/or using a factory that may return &lt;code&gt;null&lt;/code&gt;. However doing so may cause unjoined tasks to never be executed.</source>
          <target state="translated">如果存在&lt;a href=&quot;../../lang/securitymanager&quot;&gt; &lt;code&gt;SecurityManager&lt;/code&gt; &lt;/a&gt;且未指定工厂，则默认池将使用工厂提供未启用&lt;a href=&quot;../../security/permissions&quot;&gt; &lt;code&gt;Permissions&lt;/code&gt; &lt;/a&gt;线程。系统类加载器用于加载这些类。在建立这些设置时发生任何错误时，将使用默认参数。通过将parallelism属性设置为零和/或使用可能返回 &lt;code&gt;null&lt;/code&gt; 的工厂，可以禁用或限制公共池中线程的使用。但是，这样做可能导致未执行的任务永远不会执行。</target>
        </trans-unit>
        <trans-unit id="f56cfbf9c11a3bf93497432039e845c2caa01626" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;&quot;..&quot;&lt;/code&gt; segment is preceded by a non-&lt;code&gt;&quot;..&quot;&lt;/code&gt; segment then both of these segments are removed. This step is repeated until it is no longer applicable.</source>
          <target state="translated">如果 &lt;code&gt;&quot;..&quot;&lt;/code&gt; 段之前是非 &lt;code&gt;&quot;..&quot;&lt;/code&gt; 段，则将这两个段都删除。重复此步骤，直到不再适用。</target>
        </trans-unit>
        <trans-unit id="f4a595fa88f9f83de3f8fcc49ca39b0b97a48f5f" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;CONCURRENT&lt;/code&gt; collector is not also &lt;code&gt;UNORDERED&lt;/code&gt;, then it should only be evaluated concurrently if applied to an unordered data source.</source>
          <target state="translated">如果 &lt;code&gt;CONCURRENT&lt;/code&gt; 收集器也不是 &lt;code&gt;UNORDERED&lt;/code&gt; ，则仅当将其应用于无序数据源时，才应同时评估它。</target>
        </trans-unit>
        <trans-unit id="87a0262c290ea66e1e4a3ee02285d9a618034184" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;DataLine&lt;/code&gt; is requested, and &lt;code&gt;info&lt;/code&gt; is an instance of &lt;code&gt;DataLine.Info&lt;/code&gt; specifying at least one fully qualified audio format, the last one will be used as the default format of the returned &lt;code&gt;DataLine&lt;/code&gt;.</source>
          <target state="translated">如果请求了 &lt;code&gt;DataLine&lt;/code&gt; ，并且 &lt;code&gt;info&lt;/code&gt; 是 &lt;code&gt;DataLine.Info&lt;/code&gt; 的实例，它指定至少一种完全限定的音频格式，则最后一种将用作返回的 &lt;code&gt;DataLine&lt;/code&gt; 的默认格式。</target>
        </trans-unit>
        <trans-unit id="96e5812f9668e1871b3f46e04c3c43773aa3cf41" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;KeyTab&lt;/code&gt; object is obtained from &lt;a href=&quot;keytab#getUnboundInstance--&quot;&gt;&lt;code&gt;getUnboundInstance()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;keytab#getUnboundInstance-java.io.File-&quot;&gt;&lt;code&gt;getUnboundInstance(java.io.File)&lt;/code&gt;&lt;/a&gt;, it is unbound and thus can be used by any service principal. Otherwise, if it's obtained from &lt;a href=&quot;keytab#getInstance-javax.security.auth.kerberos.KerberosPrincipal-&quot;&gt;&lt;code&gt;getInstance(KerberosPrincipal)&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;keytab#getInstance-javax.security.auth.kerberos.KerberosPrincipal-java.io.File-&quot;&gt;&lt;code&gt;getInstance(KerberosPrincipal, java.io.File)&lt;/code&gt;&lt;/a&gt;, it is bound to the specific service principal and can only be used by it.</source>
          <target state="translated">如果从&lt;a href=&quot;keytab#getUnboundInstance--&quot;&gt; &lt;code&gt;getUnboundInstance()&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;keytab#getUnboundInstance-java.io.File-&quot;&gt; &lt;code&gt;getUnboundInstance(java.io.File)&lt;/code&gt; &lt;/a&gt;获得 &lt;code&gt;KeyTab&lt;/code&gt; 对象，则该对象是未绑定的，因此可以由任何服务主体使用。否则，如果它是从&lt;a href=&quot;keytab#getInstance-javax.security.auth.kerberos.KerberosPrincipal-&quot;&gt; &lt;code&gt;getInstance(KerberosPrincipal)&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;keytab#getInstance-javax.security.auth.kerberos.KerberosPrincipal-java.io.File-&quot;&gt; &lt;code&gt;getInstance(KerberosPrincipal, java.io.File)&lt;/code&gt; &lt;/a&gt;，则它将绑定到特定的服务主体，并且只能由它使用。</target>
        </trans-unit>
        <trans-unit id="d851531cc7c0ba18b4dbffa855d090b319da4df2" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;PreferencesFactory&lt;/code&gt; implementation class file has been installed in a jar file that is visible to the &lt;a href=&quot;../../lang/classloader#getSystemClassLoader--&quot;&gt;&lt;code&gt;system class loader&lt;/code&gt;&lt;/a&gt;, and that jar file contains a provider-configuration file named &lt;code&gt;java.util.prefs.PreferencesFactory&lt;/code&gt; in the resource directory &lt;code&gt;META-INF/services&lt;/code&gt;, then the first class name specified in that file is taken. If more than one such jar file is provided, the first one found will be used. The class is loaded and instantiated; if this process fails then an unspecified error is thrown.</source>
          <target state="translated">如果 &lt;code&gt;PreferencesFactory&lt;/code&gt; 实现类文件已安装在&lt;a href=&quot;../../lang/classloader#getSystemClassLoader--&quot;&gt; &lt;code&gt;system class loader&lt;/code&gt; &lt;/a&gt;可见的jar文件中，并且该jar文件在资源目录 &lt;code&gt;META-INF/services&lt;/code&gt; 中包含名为 &lt;code&gt;java.util.prefs.PreferencesFactory&lt;/code&gt; 的提供程序配置文件，然后使用该文件中指定的第一个类名称。如果提供了多个这样的jar文件，则将使用找到的第一个。该类已加载并实例化；如果此过程失败，则会引发未指定的错误。</target>
        </trans-unit>
        <trans-unit id="99e2b5ed00fcac649fe3f3623264074d666a2942" translate="yes" xml:space="preserve">
          <source>If a JobPriority attribute is specified for a Print Job, it specifies a priority for scheduling the job. A higher value specifies a higher priority. The value 1 indicates the lowest possible priority. The value 100 indicates the highest possible priority. Among those jobs that are ready to print, a printer must print all jobs with a priority value of</source>
          <target state="translated">如果为打印作业指定了 JobPriority 属性,则指定了调度作业的优先级。值越高,说明优先级越高。值1表示可能的最低优先级,值100表示可能的最高优先级。值100表示可能的最高优先级。在准备打印的作业中,打印机必须打印所有优先级为</target>
        </trans-unit>
        <trans-unit id="efa62e398135fa151e6296eb9565e2ee0a846e6d" translate="yes" xml:space="preserve">
          <source>If a PageRanges attribute is not specified for a print job, all pages of the document will be printed. In other words, the default value for the PageRanges attribute is always &lt;code&gt;{{1, Integer.MAX_VALUE}}&lt;/code&gt;.</source>
          <target state="translated">如果未为打印作业指定PageRanges属性，则将打印文档的所有页面。换句话说，PageRanges属性的默认值始终为 &lt;code&gt;{{1, Integer.MAX_VALUE}}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="54875f0ae002ae009f6261e6ee89713bac0fc513" translate="yes" xml:space="preserve">
          <source>If a Spliterator reports an inconsistent set of characteristics (either those returned from a single invocation or across multiple invocations), no guarantees can be made about any computation using this Spliterator.</source>
          <target state="translated">如果一个Spliterator报告了一组不一致的特征(无论是单次调用返回的特征还是多次调用返回的特征),就不能保证使用这个Spliterator进行的任何计算。</target>
        </trans-unit>
        <trans-unit id="a91c9f9234bda5620ef4d3e6ac923de910e62499" translate="yes" xml:space="preserve">
          <source>If a UDP socket is used, TCP/IP related socket options will not apply.</source>
          <target state="translated">如果使用UDP套接字,TCP/IP相关套接字选项将不适用。</target>
        </trans-unit>
        <trans-unit id="27875d35d17c64c41e9933d166925700a1b171f4" translate="yes" xml:space="preserve">
          <source>If a binding is added to or removed from this context, its effect on an enumeration previously returned is undefined.</source>
          <target state="translated">如果在此上下文中添加或删除了一个绑定,那么它对之前返回的枚举的影响是未定义的。</target>
        </trans-unit>
        <trans-unit id="2b8644225e60775049f73144977a4d20b30637be" translate="yes" xml:space="preserve">
          <source>If a call to &lt;code&gt;engineSetSeed&lt;/code&gt; had not occurred previously, the first call to this method forces this SecureRandom implementation to seed itself. This self-seeding will not occur if &lt;code&gt;engineSetSeed&lt;/code&gt; was previously called.</source>
          <target state="translated">如果以前未发生过对 &lt;code&gt;engineSetSeed&lt;/code&gt; 的调用，则对此方法的第一次调用将强制此SecureRandom实现自身进行播种。如果先前已调用 &lt;code&gt;engineSetSeed&lt;/code&gt; ,则不会发生这种自我播种。</target>
        </trans-unit>
        <trans-unit id="911ec002bf686d39657f3069553cf1c3b5b5def4" translate="yes" xml:space="preserve">
          <source>If a call to &lt;code&gt;setSeed&lt;/code&gt; had not occurred previously, the first call to this method forces this SecureRandom object to seed itself. This self-seeding will not occur if &lt;code&gt;setSeed&lt;/code&gt; was previously called.</source>
          <target state="translated">如果之前未发生过对 &lt;code&gt;setSeed&lt;/code&gt; 的调用，则对此方法的第一次调用将强制此SecureRandom对象播种自身。如果先前调用过 &lt;code&gt;setSeed&lt;/code&gt; ,则不会发生这种自我播种。</target>
        </trans-unit>
        <trans-unit id="05d89b94bbc85cf7d77886e27828d6c62151d272" translate="yes" xml:space="preserve">
          <source>If a character &lt;code&gt;c&lt;/code&gt; is &lt;code&gt;\u0000&lt;/code&gt; or is in the range &lt;code&gt;\u0080&lt;/code&gt; through &lt;code&gt;\u07ff&lt;/code&gt;, then it is represented by two bytes, to be written in the order shown:</source>
          <target state="translated">如果字符 &lt;code&gt;c&lt;/code&gt; 是 &lt;code&gt;\u0000&lt;/code&gt; 或在 &lt;code&gt;\u0080&lt;/code&gt; 到 &lt;code&gt;\u07ff&lt;/code&gt; 范围内，则它由两个字节表示，并按所示顺序写入：</target>
        </trans-unit>
        <trans-unit id="cced7ce9329a5beb13d9d0de6d94d760dcc0c4e8" translate="yes" xml:space="preserve">
          <source>If a character &lt;code&gt;c&lt;/code&gt; is in the range &lt;code&gt;\u0001&lt;/code&gt; through &lt;code&gt;\u007f&lt;/code&gt;, it is represented by one byte:</source>
          <target state="translated">如果字符 &lt;code&gt;c&lt;/code&gt; 在 &lt;code&gt;\u0001&lt;/code&gt; 到 &lt;code&gt;\u007f&lt;/code&gt; 范围内，则用一个字节表示：</target>
        </trans-unit>
        <trans-unit id="07952f6eaca135b300da4ff28ea9b192ef542fea" translate="yes" xml:space="preserve">
          <source>If a character &lt;code&gt;c&lt;/code&gt; is in the range &lt;code&gt;\u0800&lt;/code&gt; through &lt;code&gt;uffff&lt;/code&gt;, then it is represented by three bytes, to be written in the order shown:</source>
          <target state="translated">如果字符 &lt;code&gt;c&lt;/code&gt; 在 &lt;code&gt;\u0800&lt;/code&gt; 到 &lt;code&gt;uffff&lt;/code&gt; 范围内，则用三个字节表示，并按所示顺序写入：</target>
        </trans-unit>
        <trans-unit id="0d5494a676f207ae321fc2c494aa6a96120e143c" translate="yes" xml:space="preserve">
          <source>If a character with value &lt;code&gt;ch&lt;/code&gt; occurs in the character sequence represented by this &lt;code&gt;String&lt;/code&gt; object at an index no smaller than &lt;code&gt;fromIndex&lt;/code&gt;, then the index of the first such occurrence is returned. For values of &lt;code&gt;ch&lt;/code&gt; in the range from 0 to 0xFFFF (inclusive), this is the smallest value</source>
          <target state="translated">如果在此 &lt;code&gt;String&lt;/code&gt; 对象表示的字符序列中出现的值为 &lt;code&gt;ch&lt;/code&gt; 的字符的索引不小于 &lt;code&gt;fromIndex&lt;/code&gt; ，则返回第一次出现的索引。对于 &lt;code&gt;ch&lt;/code&gt; 值，范围是0到0xFFFF（包括0），这是最小值</target>
        </trans-unit>
        <trans-unit id="88d64da6fa30bc481b1c1898ad57b4a92324448a" translate="yes" xml:space="preserve">
          <source>If a charset listed in the &lt;a href=&quot;http://www.iana.org/assignments/character-sets&quot; id=&quot;iana&quot;&gt;&lt;i&gt;IANA Charset Registry&lt;/i&gt;&lt;/a&gt; is supported by an implementation of the Java platform then its canonical name must be the name listed in the registry. Many charsets are given more than one name in the registry, in which case the registry identifies one of the names as</source>
          <target state="translated">如果Java平台的实现支持&lt;a href=&quot;http://www.iana.org/assignments/character-sets&quot; id=&quot;iana&quot;&gt;&lt;i&gt;IANA字符集注册表中&lt;/i&gt;&lt;/a&gt;列出的字符集，则其规范名称必须是注册表中列出的名称。在注册表中，给多个字符集指定了多个名称，在这种情况下，注册表将名称之一标识为</target>
        </trans-unit>
        <trans-unit id="2e1f6c2a012c9ee1480d2aea7e18a07e1c842c87" translate="yes" xml:space="preserve">
          <source>If a class provides explicit BeanInfo about itself then we add that to the BeanInfo information we obtained from analyzing any derived classes, but we regard the explicit information as being definitive for the current class and its base classes, and do not proceed any further up the superclass chain.</source>
          <target state="translated">如果一个类提供了关于它自己的显式BeanInfo,那么我们就把它添加到我们从分析任何派生类中获得的BeanInfo信息中,但我们把显式信息看作是当前类和它的基类的确定性信息,而不继续往上进行任何超类链。</target>
        </trans-unit>
        <trans-unit id="acece6c1313b9c506151182d4c10bc5adcf63087" translate="yes" xml:space="preserve">
          <source>If a client wants to locate a printer supporting a resolution greater than some required minimum, then it may be necessary to exclude this attribute from a lookup request and to directly query the set of supported resolutions, and specify the one that most closely meets the client's requirements. In some cases this may be more simply achieved by specifying a PrintQuality attribute which often controls resolution.</source>
          <target state="translated">如果客户希望找到支持大于所需最低分辨率的打印机,那么可能有必要将该属性从查找请求中排除,直接查询所支持的分辨率集,并指定最符合客户要求的分辨率。在某些情况下,通过指定通常控制分辨率的PrintQuality属性可以更简单地实现这一点。</target>
        </trans-unit>
        <trans-unit id="94ce72ead2f2b5aae2c69c76ea112e52bebf52e8" translate="yes" xml:space="preserve">
          <source>If a collection refuses to add a particular element for any reason other than that it already contains the element, it</source>
          <target state="translated">如果一个集合因为任何原因而拒绝添加一个特定的元素,而不是因为它已经包含了这个元素,那么它就会在</target>
        </trans-unit>
        <trans-unit id="c4776000b1707ea1d8288ccc9e65458bb1c58a2d" translate="yes" xml:space="preserve">
          <source>If a connection cannot be established to a proxy (PROXY or SOCKS) servers then the caller should call the proxy selector's &lt;a href=&quot;proxyselector#connectFailed-java.net.URI-java.net.SocketAddress-java.io.IOException-&quot;&gt;&lt;code&gt;connectFailed&lt;/code&gt;&lt;/a&gt; method to notify the proxy selector that the proxy server is unavailable.</source>
          <target state="translated">如果无法建立与代理服务器（PROXY或SOCKS）的连接，则调用者应调用代理选择器的&lt;a href=&quot;proxyselector#connectFailed-java.net.URI-java.net.SocketAddress-java.io.IOException-&quot;&gt; &lt;code&gt;connectFailed&lt;/code&gt; &lt;/a&gt;方法，以通知代理选择器该代理服务器不可用。</target>
        </trans-unit>
        <trans-unit id="66d389f1702f33b50016c87da612c3454fb27ac7" translate="yes" xml:space="preserve">
          <source>If a cookie corresponding to the given URI already exists, then it is replaced with the new one.</source>
          <target state="translated">如果给定URI对应的cookie已经存在,那么就用新的cookie替换。</target>
        </trans-unit>
        <trans-unit id="df8f1040f8046d584674ec649bf9175bb489aff9" translate="yes" xml:space="preserve">
          <source>If a datagram is immediately available, or if this channel is in blocking mode and one eventually becomes available, then the datagram is copied into the given byte buffer and its source address is returned. If this channel is in non-blocking mode and a datagram is not immediately available then this method immediately returns &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">如果数据报立即可用，或者此通道处于阻塞模式并且最终变为可用，则将数据报复制到给定的字节缓冲区中，并返回其源地址。如果此通道处于非阻塞模式，并且数据报不立即可用，则此方法立即返回 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1a7a080897c03d2a2dec7ade95e887516b9ac13d" translate="yes" xml:space="preserve">
          <source>If a decimal separator is present, a locale-specific &lt;a href=&quot;../text/decimalformatsymbols#getDecimalSeparator--&quot;&gt;decimal separator&lt;/a&gt; is substituted.</source>
          <target state="translated">如果存在十进制分隔符，则将替换特定于语言环境的&lt;a href=&quot;../text/decimalformatsymbols#getDecimalSeparator--&quot;&gt;十进制分隔符&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ef151b03b8bdfd0c5b1285060dc05b180bd41b5a" translate="yes" xml:space="preserve">
          <source>If a default context was set using the &lt;a href=&quot;sslcontext#setDefault-javax.net.ssl.SSLContext-&quot;&gt;&lt;code&gt;SSLContext.setDefault()&lt;/code&gt;&lt;/a&gt; method, it is returned. Otherwise, the first call of this method triggers the call &lt;code&gt;SSLContext.getInstance(&quot;Default&quot;)&lt;/code&gt;. If successful, that object is made the default SSL context and returned.</source>
          <target state="translated">如果使用&lt;a href=&quot;sslcontext#setDefault-javax.net.ssl.SSLContext-&quot;&gt; &lt;code&gt;SSLContext.setDefault()&lt;/code&gt; &lt;/a&gt;方法设置了默认上下文，则将其返回。否则，此方法的第一次调用将触发调用 &lt;code&gt;SSLContext.getInstance(&quot;Default&quot;)&lt;/code&gt; 。如果成功，该对象将成为默认的SSL上下文并返回。</target>
        </trans-unit>
        <trans-unit id="14abd8b4a751858e76b43b1c734186c7f7ef97b3" translate="yes" xml:space="preserve">
          <source>If a destination URI is specified in a PrintRequest and it is not accessible for output by the PrintService, a PrintException will be thrown. The PrintException may implement URIException to provide a more specific cause.</source>
          <target state="translated">如果在PrintRequest中指定了目标URI,但PrintService无法访问该URI并进行输出,则会抛出PrintException。PrintException可以实现URIException来提供更具体的原因。</target>
        </trans-unit>
        <trans-unit id="8bacc9e3344a41d79a4651f2c7e9da527b4943d5" translate="yes" xml:space="preserve">
          <source>If a device name is specified, the resulting list of &lt;code&gt;MidiDevice.Info&lt;/code&gt; objects is searched: the first one with a matching name, and whose &lt;code&gt;MidiDevice&lt;/code&gt; implements the respective interface, will be returned. If no matching &lt;code&gt;MidiDevice.Info&lt;/code&gt; object is found, or the device name is not specified, the first suitable device from the resulting list will be returned. For Sequencer and Synthesizer, a device is suitable if it implements the respective interface; whereas for Receiver and Transmitter, a device is suitable if it implements neither Sequencer nor Synthesizer and provides at least one Receiver or Transmitter, respectively. For example, the property &lt;code&gt;javax.sound.midi.Receiver&lt;/code&gt; with a value &lt;code&gt;&quot;com.sun.media.sound.MidiProvider#SunMIDI1&quot;&lt;/code&gt; will have the following consequences when &lt;code&gt;getReceiver&lt;/code&gt; is called: if the class &lt;code&gt;com.sun.media.sound.MidiProvider&lt;/code&gt; exists in the list of installed MIDI device providers, the first &lt;code&gt;Receiver&lt;/code&gt; device with name &lt;code&gt;&quot;SunMIDI1&quot;&lt;/code&gt; will be returned. If it cannot be found, the first &lt;code&gt;Receiver&lt;/code&gt; from that provider will be returned, regardless of name. If there is none, the first &lt;code&gt;Receiver&lt;/code&gt; with name &lt;code&gt;&quot;SunMIDI1&quot;&lt;/code&gt; in the list of all devices (as returned by &lt;code&gt;getMidiDeviceInfo&lt;/code&gt;) will be returned, or, if not found, the first &lt;code&gt;Receiver&lt;/code&gt; that can be found in the list of all devices is returned. If that fails, too, a &lt;code&gt;MidiUnavailableException&lt;/code&gt; is thrown.</source>
          <target state="translated">如果指定了设备名称，则会搜索 &lt;code&gt;MidiDevice.Info&lt;/code&gt; 对象的结果列表：将返回名称匹配的第一个对象，并且其 &lt;code&gt;MidiDevice&lt;/code&gt; 实现相应的接口。如果找不到匹配的 &lt;code&gt;MidiDevice.Info&lt;/code&gt; 对象，或者未指定设备名称，则将返回结果列表中的第一个合适的设备。对于序列发生器和合成器，如果设备实现了各自的接口，则该设备是合适的；对于接收器和发送器，如果设备既未实现音序器也未实现合成器，并且分别提供至少一个接收器或发送器，则该设备是合适的。例如，具有值的属性 &lt;code&gt;javax.sound.midi.Receiver&lt;/code&gt; &lt;code&gt;&quot;com.sun.media.sound.MidiProvider#SunMIDI1&quot;&lt;/code&gt; 将产生以下后果时 &lt;code&gt;getReceiver&lt;/code&gt; 叫做：如果类 &lt;code&gt;com.sun.media.sound.MidiProvider&lt;/code&gt; 在已安装的MIDI设备供应商的列表，则第一 &lt;code&gt;Receiver&lt;/code&gt; 与设备将返回名称 &lt;code&gt;&quot;SunMIDI1&quot;&lt;/code&gt; 。如果找不到，将返回该提供者的第一个 &lt;code&gt;Receiver&lt;/code&gt; ，而不管其名称如何。如果没有，则将返回所有设备列表中第一个名称为 &lt;code&gt;&quot;SunMIDI1&quot;&lt;/code&gt; &lt;code&gt;Receiver&lt;/code&gt; （由 &lt;code&gt;getMidiDeviceInfo&lt;/code&gt; 返回），或者，如果没有找到，则返回第一个 &lt;code&gt;Receiver&lt;/code&gt; 返回所有设备列表中可以找到的内容。如果同样失败，则会抛出 &lt;code&gt;MidiUnavailableException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1dc1d0d7d632f8adb52a90a5d33de0f5ebfd86ab" translate="yes" xml:space="preserve">
          <source>If a factory is instantiated, it is invoked with the following parameters to produce the resulting context.</source>
          <target state="translated">如果实例化了一个工厂,就会用以下参数调用它,以产生结果的上下文。</target>
        </trans-unit>
        <trans-unit id="61b02e48c383e6261e3240e4271679924e0689b0" translate="yes" xml:space="preserve">
          <source>If a fieldValue is an object then the toString() method is called on it and its returned value is used as the value for the field enclosed in parenthesis.</source>
          <target state="translated">如果fieldValue是一个对象,那么对它调用toString()方法,并将其返回的值作为括号中的字段的值。</target>
        </trans-unit>
        <trans-unit id="7fbb5e24d20d361c0ea0a62c5f3f2f90aea684d9" translate="yes" xml:space="preserve">
          <source>If a file manager is provided, it must be able to handle all locations defined in &lt;a href=&quot;documentationtool.location&quot;&gt;&lt;code&gt;DocumentationTool.Location&lt;/code&gt;&lt;/a&gt;, as well as &lt;a href=&quot;standardlocation#SOURCE_PATH&quot;&gt;&lt;code&gt;StandardLocation.SOURCE_PATH&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;standardlocation#CLASS_PATH&quot;&gt;&lt;code&gt;StandardLocation.CLASS_PATH&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;standardlocation#PLATFORM_CLASS_PATH&quot;&gt;&lt;code&gt;StandardLocation.PLATFORM_CLASS_PATH&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果提供了文件管理器，则它必须能够处理&lt;a href=&quot;documentationtool.location&quot;&gt; &lt;code&gt;DocumentationTool.Location&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;standardlocation#SOURCE_PATH&quot;&gt; &lt;code&gt;StandardLocation.SOURCE_PATH&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;standardlocation#CLASS_PATH&quot;&gt; &lt;code&gt;StandardLocation.CLASS_PATH&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;standardlocation#PLATFORM_CLASS_PATH&quot;&gt; &lt;code&gt;StandardLocation.PLATFORM_CLASS_PATH&lt;/code&gt; 中&lt;/a&gt;定义的所有位置。</target>
        </trans-unit>
        <trans-unit id="cdbf6cb18404a64f45d2b8abf710d01eb9d7f2cb" translate="yes" xml:space="preserve">
          <source>If a file manager is provided, it must be able to handle all locations defined in &lt;a href=&quot;standardlocation&quot;&gt;&lt;code&gt;StandardLocation&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果提供了文件管理器，则它必须能够处理&lt;a href=&quot;standardlocation&quot;&gt; &lt;code&gt;StandardLocation&lt;/code&gt; 中&lt;/a&gt;定义的所有位置。</target>
        </trans-unit>
        <trans-unit id="6e77610d088ca1d95b7392fcd2274aef9c2f8d21" translate="yes" xml:space="preserve">
          <source>If a filter &lt;code&gt;F&lt;/code&gt; applies to the &lt;code&gt;N&lt;/code&gt;th argument of the target, then &lt;code&gt;F&lt;/code&gt; must be a method handle which takes exactly one argument. The type of &lt;code&gt;F&lt;/code&gt;'s sole argument replaces the corresponding argument type of the target in the resulting adapted method handle. The return type of &lt;code&gt;F&lt;/code&gt; must be identical to the corresponding parameter type of the target.</source>
          <target state="translated">如果将过滤器 &lt;code&gt;F&lt;/code&gt; 应用于目标的第 &lt;code&gt;N&lt;/code&gt; 个参数，则 &lt;code&gt;F&lt;/code&gt; 必须是仅使用一个参数的方法句柄。的类型的 &lt;code&gt;F&lt;/code&gt; 的唯一的参数替换在所得到的适用方法手柄靶的相应参数类型。 &lt;code&gt;F&lt;/code&gt; 的返回类型必须与目标的相应参数类型相同。</target>
        </trans-unit>
        <trans-unit id="77fff40663a1f21028623e35281e042a8419f5f8" translate="yes" xml:space="preserve">
          <source>If a formal parameter type is a parameterized type, the &lt;code&gt;Type&lt;/code&gt; object returned for it must accurately reflect the actual type parameters used in the source code.</source>
          <target state="translated">如果形式参数类型是参数化类型，则为其返回的 &lt;code&gt;Type&lt;/code&gt; 对象必须准确反映源代码中使用的实际类型参数。</target>
        </trans-unit>
        <trans-unit id="48218943f2a8994e2b422a9456a012477f87f4f0" translate="yes" xml:space="preserve">
          <source>If a formal parameter type is a type variable or a parameterized type, it is created. Otherwise, it is resolved.</source>
          <target state="translated">如果形式参数类型是类型变量或参数化类型,则创建该类型。否则,它将被解析。</target>
        </trans-unit>
        <trans-unit id="8aa45ce5030fe67e696cd9c90f1c3d32a9e26312" translate="yes" xml:space="preserve">
          <source>If a format specifier contains a conversion character that is not applicable to the corresponding argument, then an &lt;a href=&quot;illegalformatconversionexception&quot;&gt;&lt;code&gt;IllegalFormatConversionException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">如果格式说明符包含不适用于相应参数的转换字符，则将引发&lt;a href=&quot;illegalformatconversionexception&quot;&gt; &lt;code&gt;IllegalFormatConversionException&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="47e2137fd18da09bdd7e054d7015bc33023b31e0" translate="yes" xml:space="preserve">
          <source>If a given &lt;code&gt;invokedynamic&lt;/code&gt; instruction specifies no static arguments, the instruction's bootstrap method will be invoked on three arguments, conveying the instruction's caller class, name, and method type. If the &lt;code&gt;invokedynamic&lt;/code&gt; instruction specifies one or more static arguments, those values will be passed as additional arguments to the method handle. (Note that because there is a limit of 255 arguments to any method, at most 251 extra arguments can be supplied, since the bootstrap method handle itself and its first three arguments must also be stacked.) The bootstrap method will be invoked as if by either &lt;code&gt;MethodHandle.invoke&lt;/code&gt; or &lt;code&gt;invokeWithArguments&lt;/code&gt;. (There is no way to tell the difference.)</source>
          <target state="translated">如果给定的 &lt;code&gt;invokedynamic&lt;/code&gt; 指令未指定任何静态参数，则该指令的bootstrap方法将在三个参数上调用，传达该指令的调用者类，名称和方法类型。如果 &lt;code&gt;invokedynamic&lt;/code&gt; 指令指定一个或多个静态参数，则这些值将作为其他参数传递给方法句柄。 （请注意，由于任何方法最多只能有255个参数，因此最多可以提供251个额外的参数，因为bootstrap方法本身会处理它的前三个参数。）要么 &lt;code&gt;MethodHandle.invoke&lt;/code&gt; 或 &lt;code&gt;invokeWithArguments&lt;/code&gt; 。 （无法分辨出区别。）</target>
        </trans-unit>
        <trans-unit id="1b302c4fa309e55608aa77d71aa898540e38e284" translate="yes" xml:space="preserve">
          <source>If a host is given then it is appended. If the host is a literal IPv6 address but is not enclosed in square brackets (&lt;code&gt;'['&lt;/code&gt; and &lt;code&gt;']'&lt;/code&gt;) then the square brackets are added.</source>
          <target state="translated">如果提供了主机，则将其附加。如果主机是原义的IPv6地址，但没有括在方括号（ &lt;code&gt;'['&lt;/code&gt; 和 &lt;code&gt;']'&lt;/code&gt; ）中，则会添加方括号。</target>
        </trans-unit>
        <trans-unit id="7a15cd0977f55c58d7c0850d3c01c8a63da1d40d" translate="yes" xml:space="preserve">
          <source>If a logical line is spread across several natural lines, the backslash escaping the line terminator sequence, the line terminator sequence, and any white space at the start of the following line have no affect on the key or element values. The remainder of the discussion of key and element parsing (when loading) will assume all the characters constituting the key and element appear on a single natural line after line continuation characters have been removed. Note that it is</source>
          <target state="translated">如果一个逻辑行分布在几个自然行上,则行结束符序列、行结束符序列和下一行开始处的任何空白都不会影响键或元素值。在讨论键和元素解析的剩余部分(加载时),将假设所有构成键和元素的字符在去掉行延续字符后出现在一个自然行上。请注意,它是</target>
        </trans-unit>
        <trans-unit id="3a82003bc08000c8f46219ed82ab846fd6727cbe" translate="yes" xml:space="preserve">
          <source>If a match to the specified pattern is not found at the current position, then no input is skipped and a &lt;code&gt;NoSuchElementException&lt;/code&gt; is thrown.</source>
          <target state="translated">如果在当前位置找不到与指定模式的匹配项，则不跳过任何输入，并引发 &lt;code&gt;NoSuchElementException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="03f7ab2c34aa311345e83cbc387505226e713e48" translate="yes" xml:space="preserve">
          <source>If a method handle for a caller-sensitive method is requested, the general rules for &lt;a href=&quot;methodhandles.lookup#equiv&quot;&gt;bytecode behaviors&lt;/a&gt; apply, but they take account of the lookup class in a special way. The resulting method handle behaves as if it were called from an instruction contained in the lookup class, so that the caller-sensitive method detects the lookup class. (By contrast, the invoker of the method handle is disregarded.) Thus, in the case of caller-sensitive methods, different lookup classes may give rise to differently behaving method handles.</source>
          <target state="translated">如果请求用于调用方敏感方法的方法句柄，则适用&lt;a href=&quot;methodhandles.lookup#equiv&quot;&gt;字节码行为&lt;/a&gt;的一般规则，但是它们以特殊方式考虑了lookup类。生成的方法句柄的行为就像是从查找类中包含的指令中调用的一样，因此，对调用者敏感的方法可以检测到查找类。 （通过对比，方法句柄的调用者被忽略。）因此，在调用者敏感方法的情况下，不同的查找类可能会导致行为不同的方法句柄。</target>
        </trans-unit>
        <trans-unit id="7f4e595c2df825132a51481c97b50495434dfe5e" translate="yes" xml:space="preserve">
          <source>If a mixer name is specified, the resulting list of &lt;code&gt;Mixer.Info&lt;/code&gt; objects is searched: the first one with a matching name, and whose &lt;code&gt;Mixer&lt;/code&gt; provides the respective line interface, will be returned. If no matching &lt;code&gt;Mixer.Info&lt;/code&gt; object is found, or the mixer name is not specified, the first mixer from the resulting list, which provides the respective line interface, will be returned. For example, the property &lt;code&gt;javax.sound.sampled.Clip&lt;/code&gt; with a value &lt;code&gt;&quot;com.sun.media.sound.MixerProvider#SunClip&quot;&lt;/code&gt; will have the following consequences when &lt;code&gt;getLine&lt;/code&gt; is called requesting a &lt;code&gt;Clip&lt;/code&gt; instance: if the class &lt;code&gt;com.sun.media.sound.MixerProvider&lt;/code&gt; exists in the list of installed mixer providers, the first &lt;code&gt;Clip&lt;/code&gt; from the first mixer with name &lt;code&gt;&quot;SunClip&quot;&lt;/code&gt; will be returned. If it cannot be found, the first &lt;code&gt;Clip&lt;/code&gt; from the first mixer of the specified provider will be returned, regardless of name. If there is none, the first &lt;code&gt;Clip&lt;/code&gt; from the first &lt;code&gt;Mixer&lt;/code&gt; with name &lt;code&gt;&quot;SunClip&quot;&lt;/code&gt; in the list of all mixers (as returned by &lt;code&gt;getMixerInfo&lt;/code&gt;) will be returned, or, if not found, the first &lt;code&gt;Clip&lt;/code&gt; of the first &lt;code&gt;Mixer&lt;/code&gt;that can be found in the list of all mixers is returned. If that fails, too, an &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown.</source>
          <target state="translated">如果指定了混音器名称，则会搜索 &lt;code&gt;Mixer.Info&lt;/code&gt; 对象的结果列表：将返回第一个具有匹配名称的名称，并且其 &lt;code&gt;Mixer&lt;/code&gt; 提供相应的线路接口。如果找不到匹配的 &lt;code&gt;Mixer.Info&lt;/code&gt; 对象，或者未指定混合器名称，则将返回结果列表中的第一个混合器，该列表提供相应的线路接口。例如，当调用 &lt;code&gt;getLine&lt;/code&gt; 请求 &lt;code&gt;Clip&lt;/code&gt; 实例时，值为 &lt;code&gt;&quot;com.sun.media.sound.MixerProvider#SunClip&quot;&lt;/code&gt; 的属性 &lt;code&gt;javax.sound.sampled.Clip&lt;/code&gt; 将具有以下结果：如果类 &lt;code&gt;com.sun.media.sound.MixerProvider&lt;/code&gt; 在已安装的混音器提供程序列表中，如果第一个混音器名为 &lt;code&gt;&quot;SunClip&quot;&lt;/code&gt; 则将返回第一个 &lt;code&gt;Clip&lt;/code&gt; 。如果找不到，将返回指定提供者的第一个混合器的第一个 &lt;code&gt;Clip&lt;/code&gt; ，无论名称如何。如果没有，第一个 &lt;code&gt;Clip&lt;/code&gt; 从第一 &lt;code&gt;Mixer&lt;/code&gt; 与名 &lt;code&gt;&quot;SunClip&quot;&lt;/code&gt; 在所有混频器列表（由返回 &lt;code&gt;getMixerInfo&lt;/code&gt; ）将被退回，或者，如果没有找到，第一个 &lt;code&gt;Clip&lt;/code&gt; 的第一个 &lt;code&gt;Mixer&lt;/code&gt; ，可以发现在所有混音器列表中返回。如果同样失败，则抛出 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f8a0c1b372f5ed387a77d0a8139d565c090fb292" translate="yes" xml:space="preserve">
          <source>If a mutable target is not required, an &lt;code&gt;invokedynamic&lt;/code&gt; instruction may be permanently bound by means of a &lt;a href=&quot;constantcallsite&quot;&gt;constant call site&lt;/a&gt;.</source>
          <target state="translated">如果不需要可变目标，则可以通过&lt;a href=&quot;constantcallsite&quot;&gt;恒定的调用站点&lt;/a&gt;永久绑定 &lt;code&gt;invokedynamic&lt;/code&gt; 指令。</target>
        </trans-unit>
        <trans-unit id="d153e3199dbf3a239e1e74edc668dcfac7b620a7" translate="yes" xml:space="preserve">
          <source>If a mutable target is required which has volatile variable semantics, because updates to the target must be immediately and reliably witnessed by other threads, a &lt;a href=&quot;volatilecallsite&quot;&gt;volatile call site&lt;/a&gt; may be used.</source>
          <target state="translated">如果需要具有可变变量语义的可变目标，因为必须立即由其他线程可靠地见证对目标的更新，因此可以使用&lt;a href=&quot;volatilecallsite&quot;&gt;可变调用站点&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="657a9f6756d750ee4adc0e4bbc100a654dce7128" translate="yes" xml:space="preserve">
          <source>If a name is specified as a byte array, it should contain a single DER encoded distinguished name, as defined in X.501. The ASN.1 notation for this structure is as follows.</source>
          <target state="translated">如果名称被指定为字节数组,则应包含X.501中定义的单一DER编码区分名称。该结构的ASN.1符号如下:</target>
        </trans-unit>
        <trans-unit id="82b7eb3aeab5135e75a853270d3a38d65b14ccb2" translate="yes" xml:space="preserve">
          <source>If a name is specified as a byte array, it should contain a single DER encoded distinguished name, as defined in X.501. The ASN.1 notation for this structure is given in the documentation for &lt;a href=&quot;x509crlselector#setIssuerNames-java.util.Collection-&quot;&gt;&lt;code&gt;setIssuerNames(Collection names)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果将名称指定为字节数组，则它应包含X.501中定义的单个DER编码的专有名称。&lt;a href=&quot;x509crlselector#setIssuerNames-java.util.Collection-&quot;&gt; &lt;code&gt;setIssuerNames(Collection names)&lt;/code&gt; &lt;/a&gt;的文档中给出了此结构的ASN.1表示法。</target>
        </trans-unit>
        <trans-unit id="96afaaa19f7e5c5798f8d8403e551ecc219a3743" translate="yes" xml:space="preserve">
          <source>If a native receiver provided by the default device does not implement the &lt;code&gt;MidiDeviceReceiver&lt;/code&gt; interface, it will be wrapped in a wrapper class that implements the &lt;code&gt;MidiDeviceReceiver&lt;/code&gt; interface. The corresponding &lt;code&gt;Receiver&lt;/code&gt; method calls will be forwarded to the native receiver.</source>
          <target state="translated">如果默认设备提供的本机接收器未实现 &lt;code&gt;MidiDeviceReceiver&lt;/code&gt; 接口，则它将包装在实现 &lt;code&gt;MidiDeviceReceiver&lt;/code&gt; 接口的包装器类中。相应的 &lt;code&gt;Receiver&lt;/code&gt; 方法调用将转发到本机接收器。</target>
        </trans-unit>
        <trans-unit id="f15617aacf84e28d7719762bc77a6e2a240fb2d8" translate="yes" xml:space="preserve">
          <source>If a native transmitter provided by the default device does not implement the &lt;code&gt;MidiDeviceTransmitter&lt;/code&gt; interface, it will be wrapped in a wrapper class that implements the &lt;code&gt;MidiDeviceTransmitter&lt;/code&gt; interface. The corresponding &lt;code&gt;Transmitter&lt;/code&gt; method calls will be forwarded to the native transmitter.</source>
          <target state="translated">如果默认设备提供的本机发送器未实现 &lt;code&gt;MidiDeviceTransmitter&lt;/code&gt; 接口，则它将包装在实现 &lt;code&gt;MidiDeviceTransmitter&lt;/code&gt; 接口的包装器类中。相应的 &lt;code&gt;Transmitter&lt;/code&gt; 方法调用将转发到本机发送器。</target>
        </trans-unit>
        <trans-unit id="e885f68e1bc095b374d6b1ebbe1a47153753c95e" translate="yes" xml:space="preserve">
          <source>If a new logger is created its log level will be configured based on the LogManager and it will configured to also send logging output to its parent's Handlers. It will be registered in the LogManager global namespace.</source>
          <target state="translated">如果创建了一个新的日志记录器,其日志级别将根据 LogManager 进行配置,并将配置为也将日志输出发送到其父级处理程序。它将在 LogManager 全局命名空间中注册。</target>
        </trans-unit>
        <trans-unit id="5e945b5d1146ab0148461e7bb66b4cc1b6317073" translate="yes" xml:space="preserve">
          <source>If a new logger is created its log level will be configured based on the LogManager configuration and it will configured to also send logging output to its parent's Handlers. It will be registered in the LogManager global namespace.</source>
          <target state="translated">如果创建了一个新的日志记录器,其日志级别将根据 LogManager 配置进行配置,并将配置为也将日志输出发送到其父级处理程序。它将在 LogManager 全局命名空间中注册。</target>
        </trans-unit>
        <trans-unit id="e4374be394b79479c7e1fa5bcc1e8102ae6664e5" translate="yes" xml:space="preserve">
          <source>If a non-null CodeSource is supplied a ProtectionDomain is constructed and associated with the class being defined.</source>
          <target state="translated">如果提供了一个非空的CodeSource,则会构造一个ProtectionDomain并与被定义的类相关联。</target>
        </trans-unit>
        <trans-unit id="ed948d67e59d3b1ab1a6ab69b72cf90841f818b2" translate="yes" xml:space="preserve">
          <source>If a non-null value is returned, then the PropertyEditor should be prepared to parse that string back in setAsText().</source>
          <target state="translated">如果返回一个非空值,那么PropertyEditor应该准备好在setAsText()中解析回该字符串。</target>
        </trans-unit>
        <trans-unit id="c9d7fb43a6f9ab347881ca798d47872764ac074f" translate="yes" xml:space="preserve">
          <source>If a number is preceded by &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt; and a year has already been recognized, then the number is a time-zone offset. If the number is less than 24, it is an offset measured in hours. Otherwise, it is regarded as an offset in minutes, expressed in 24-hour time format without punctuation. A preceding &lt;code&gt;-&lt;/code&gt; means a westward offset. Time zone offsets are always relative to UTC (Greenwich). Thus, for example, &lt;code&gt;-5&lt;/code&gt; occurring in the string would mean &quot;five hours west of Greenwich&quot; and &lt;code&gt;+0430&lt;/code&gt; would mean &quot;four hours and thirty minutes east of Greenwich.&quot; It is permitted for the string to specify &lt;code&gt;GMT&lt;/code&gt;, &lt;code&gt;UT&lt;/code&gt;, or &lt;code&gt;UTC&lt;/code&gt; redundantly-for example, &lt;code&gt;GMT-5&lt;/code&gt; or &lt;code&gt;utc+0430&lt;/code&gt;.</source>
          <target state="translated">如果数字前面带有 &lt;code&gt;+&lt;/code&gt; 或 &lt;code&gt;-&lt;/code&gt; 且已识别年份，则该数字为时区偏移量。如果数字小于24，则为以小时为单位的偏移量。否则，它被视为以分钟为单位的偏移量，以24小时时间格式表示，没有标点符号。前面的 &lt;code&gt;-&lt;/code&gt; 表示向西偏移。时区偏移量始终相对于UTC（格林威治标准时间）。因此，例如，字符串中出现的 &lt;code&gt;-5&lt;/code&gt; 表示&amp;ldquo;格林威治以西五个小时&amp;rdquo;，而 &lt;code&gt;+0430&lt;/code&gt; 表示&amp;ldquo;格林威治以东四个小时三十分钟&amp;rdquo;。允许该字符串冗余地指定 &lt;code&gt;GMT&lt;/code&gt; ， &lt;code&gt;UT&lt;/code&gt; 或 &lt;code&gt;UTC&lt;/code&gt; -例如， &lt;code&gt;GMT-5&lt;/code&gt; 或 &lt;code&gt;utc+0430&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a7e7b1f4d4e8c47890d4e04c211a6340b6dc972a" translate="yes" xml:space="preserve">
          <source>If a parameterized type is being returned, its type element must not be contained within a generic outer class. The parameterized type &lt;code&gt;Outer&amp;lt;String&amp;gt;.Inner&amp;lt;Number&amp;gt;&lt;/code&gt;, for example, may be constructed by first using this method to get the type &lt;code&gt;Outer&amp;lt;String&amp;gt;&lt;/code&gt;, and then invoking &lt;a href=&quot;types#getDeclaredType-javax.lang.model.type.DeclaredType-javax.lang.model.element.TypeElement-javax.lang.model.type.TypeMirror...-&quot;&gt;&lt;code&gt;getDeclaredType(DeclaredType, TypeElement, TypeMirror...)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果要返回参数化类型，则其类型元素不得包含在通用外部类中。例如，可以通过以下方法构造参数化类型 &lt;code&gt;Outer&amp;lt;String&amp;gt;.Inner&amp;lt;Number&amp;gt;&lt;/code&gt; ：首先使用此方法来获取类型 &lt;code&gt;Outer&amp;lt;String&amp;gt;&lt;/code&gt; ，然后调用&lt;a href=&quot;types#getDeclaredType-javax.lang.model.type.DeclaredType-javax.lang.model.element.TypeElement-javax.lang.model.type.TypeMirror...-&quot;&gt; &lt;code&gt;getDeclaredType(DeclaredType, TypeElement, TypeMirror...)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b860cee6c1daa1284a85c7a9b7c1c7d6c9380907" translate="yes" xml:space="preserve">
          <source>If a particular concrete charset provider class is named in more than one configuration file, or is named in the same configuration file more than once, then the duplicates will be ignored. The configuration file naming a particular provider need not be in the same jar file or other distribution unit as the provider itself. The provider must be accessible from the same class loader that was initially queried to locate the configuration file; this is not necessarily the class loader that loaded the file.</source>
          <target state="translated">如果特定的具体字符集提供程序类在多个配置文件中被命名,或者在同一个配置文件中被命名了不止一次,那么重复的内容将被忽略。命名特定提供程序的配置文件不需要与提供程序本身在同一个jar文件或其他发布单元中。提供者必须可以从最初被查询定位配置文件的同一个类加载器访问;这不一定是加载文件的类加载器。</target>
        </trans-unit>
        <trans-unit id="fbd441057e8700833c9533c87ba431e637f763c4" translate="yes" xml:space="preserve">
          <source>If a particular concrete provider class is named in more than one configuration file, or is named in the same configuration file more than once, then the duplicates are ignored. The configuration file naming a particular provider need not be in the same jar file or other distribution unit as the provider itself. The provider must be accessible from the same class loader that was initially queried to locate the configuration file; note that this is not necessarily the class loader from which the file was actually loaded.</source>
          <target state="translated">如果某个具体的提供者类在多个配置文件中被命名,或者在同一个配置文件中被命名了不止一次,那么重复的类将被忽略。命名特定提供者的配置文件不需要和提供者本身在同一个jar文件或其他发布单元中。提供者必须可以从最初被查询定位配置文件的同一个类加载器中访问;注意,这不一定是实际加载文件的那个类加载器。</target>
        </trans-unit>
        <trans-unit id="5da4bf007198af6025012fc0fecd914082583539" translate="yes" xml:space="preserve">
          <source>If a particular concrete provider class is named in more than one configuration file, or is named in the same configuration file more than once, then the duplicates will be ignored. The configuration file naming a particular provider need not be in the same jar file or other distribution unit as the provider itself. The provider must be accessible from the same class loader that was initially queried to locate the configuration file; this is not necessarily the class loader that loaded the file.</source>
          <target state="translated">如果一个特定的具体提供者类在多个配置文件中被命名,或者在同一个配置文件中被命名多次,那么重复的类将被忽略。命名特定提供者的配置文件不需要与提供者本身在同一个jar文件或其他发布单元中。提供者必须可以从最初被查询定位配置文件的同一个类加载器访问;这不一定是加载文件的类加载器。</target>
        </trans-unit>
        <trans-unit id="d5668fe10c0723c5fca50dcc78c1b35e4b358bc9" translate="yes" xml:space="preserve">
          <source>If a path is given then it is appended. Any character not in the</source>
          <target state="translated">如果给出了路径,那么就会被附加。任何不在</target>
        </trans-unit>
        <trans-unit id="0e5a965d6474edf02c5830767daff8c0d82cf26d" translate="yes" xml:space="preserve">
          <source>If a pattern is to be used multiple times, compiling it once and reusing it will be more efficient than invoking this method each time.</source>
          <target state="translated">如果一个模式要被多次使用,编译一次并重复使用会比每次调用这个方法更有效率。</target>
        </trans-unit>
        <trans-unit id="89b4c008a45797eef3268e7fe508720bf307f893" translate="yes" xml:space="preserve">
          <source>If a permit is acquired then the value &lt;code&gt;true&lt;/code&gt; is returned.</source>
          <target state="translated">如果获得许可，则返回值 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="619e1dee8db482adbcc19510b522caad9b3dd86b" translate="yes" xml:space="preserve">
          <source>If a persistence delegate is associated with the given type by using the &lt;a href=&quot;encoder#setPersistenceDelegate-java.lang.Class-java.beans.PersistenceDelegate-&quot;&gt;&lt;code&gt;setPersistenceDelegate(java.lang.Class&amp;lt;?&amp;gt;, java.beans.PersistenceDelegate)&lt;/code&gt;&lt;/a&gt; method it is returned.</source>
          <target state="translated">如果使用&lt;a href=&quot;encoder#setPersistenceDelegate-java.lang.Class-java.beans.PersistenceDelegate-&quot;&gt; &lt;code&gt;setPersistenceDelegate(java.lang.Class&amp;lt;?&amp;gt;, java.beans.PersistenceDelegate)&lt;/code&gt; &lt;/a&gt;方法将持久性委托与给定类型相关联，则将其返回。</target>
        </trans-unit>
        <trans-unit id="11d9ed1e56dc29ed992752f78c70910959ce2ab4" translate="yes" xml:space="preserve">
          <source>If a port number is given then a colon character (&lt;code&gt;':'&lt;/code&gt;) is appended, followed by the port number in decimal.</source>
          <target state="translated">如果给出了端口号，则将冒号（ &lt;code&gt;':'&lt;/code&gt; ）附加在其后，并以十进制表示端口号。</target>
        </trans-unit>
        <trans-unit id="38d056108653d02210141b2a751f0e69e31fb1fd" translate="yes" xml:space="preserve">
          <source>If a print service provides any vendor extensions these may be made accessible to the user through a vendor supplied tab panel Component. Such a vendor extension is encouraged to use Swing! and to support its accessibility APIs. The vendor extensions should return the settings as part of the AttributeSet. Applications which want to preserve the user settings should use those settings to specify the print job. Note that this class is not referenced by any other part of the Java Print Service and may not be included in profiles which cannot depend on the presence of the AWT packages.</source>
          <target state="translated">如果打印服务提供了任何供应商扩展,这些扩展可以通过供应商提供的标签面板组件让用户访问。鼓励此类供应商扩展使用Swing!并支持其可访问性API。厂商扩展应该返回设置作为AttributeSet的一部分。想要保留用户设置的应用程序应该使用这些设置来指定打印作业。请注意,该类不被 Java 打印服务的任何其他部分引用,也不能包含在不能依赖 AWT 包的配置文件中。</target>
        </trans-unit>
        <trans-unit id="f29ea7b220242b9cb8462cb83e9acfd3082297b2" translate="yes" xml:space="preserve">
          <source>If a printer does not support the SheetCollate attribute (meaning the client cannot specify any particular sheet collation), the printer must behave as though SheetCollate were always set to COLLATED.</source>
          <target state="translated">如果打印机不支持SheetCollate属性(意味着客户端不能指定任何特定的纸张整理),则打印机的行为就像SheetCollate总是被设置为COLLATED一样。</target>
        </trans-unit>
        <trans-unit id="49665e43d0c605dc9888cfc626aa1ab47db7f814" translate="yes" xml:space="preserve">
          <source>If a processor object is created and used without the above protocol being followed, then the processor's behavior is not defined by this interface specification.</source>
          <target state="translated">如果一个处理器对象的创建和使用没有遵循上述协议,那么处理器的行为就不是本接口规范所定义的。</target>
        </trans-unit>
        <trans-unit id="ca6e8c92cea494ed3f4a024c3b0fdf6756539fd3" translate="yes" xml:space="preserve">
          <source>If a processor throws an uncaught exception, the tool may cease other active annotation processors. If a processor raises an error, the current round will run to completion and the subsequent round will indicate an &lt;a href=&quot;roundenvironment#errorRaised--&quot;&gt;error was raised&lt;/a&gt;. Since annotation processors are run in a cooperative environment, a processor should throw an uncaught exception only in situations where no error recovery or reporting is feasible.</source>
          <target state="translated">如果处理器抛出未捕获的异常，则该工具可能会停止其他活动的注释处理器。如果处理器引发错误，则当前回合将运行完成，而下一回合将指示&lt;a href=&quot;roundenvironment#errorRaised--&quot;&gt;引发&lt;/a&gt;了错误。由于注释处理器在协作环境中运行，因此处理器仅应在无法进行错误恢复或报告的情况下抛出未捕获的异常。</target>
        </trans-unit>
        <trans-unit id="fe881171d1c239ccd44b6c4f0b3100103c51b330" translate="yes" xml:space="preserve">
          <source>If a property is indexed, then its entry in the result array belongs to the &lt;a href=&quot;indexedpropertydescriptor&quot;&gt;&lt;code&gt;IndexedPropertyDescriptor&lt;/code&gt;&lt;/a&gt; subclass of the &lt;a href=&quot;propertydescriptor&quot;&gt;&lt;code&gt;PropertyDescriptor&lt;/code&gt;&lt;/a&gt; class. A client of the &lt;code&gt;getPropertyDescriptors&lt;/code&gt; method can use the &lt;code&gt;instanceof&lt;/code&gt; operator to check whether a given &lt;code&gt;PropertyDescriptor&lt;/code&gt; is an &lt;code&gt;IndexedPropertyDescriptor&lt;/code&gt;.</source>
          <target state="translated">如果对属性进行索引，则其在结果数组中的条目属于&lt;a href=&quot;propertydescriptor&quot;&gt; &lt;code&gt;PropertyDescriptor&lt;/code&gt; &lt;/a&gt;类的&lt;a href=&quot;indexedpropertydescriptor&quot;&gt; &lt;code&gt;IndexedPropertyDescriptor&lt;/code&gt; &lt;/a&gt;子类。 &lt;code&gt;getPropertyDescriptors&lt;/code&gt; 方法的客户端可以使用 &lt;code&gt;instanceof&lt;/code&gt; 运算符来检查给定的 &lt;code&gt;PropertyDescriptor&lt;/code&gt; 是否为 &lt;code&gt;IndexedPropertyDescriptor&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="73b5d72f7f083f370b03d87e8286e01120577634" translate="yes" xml:space="preserve">
          <source>If a property value is a directory name, all files under that directory will be passed also.</source>
          <target state="translated">如果属性值是一个目录名,那么该目录下的所有文件也将被传递。</target>
        </trans-unit>
        <trans-unit id="9c4d961909cb1d8509dc7e80ad518ce9be7c9742" translate="yes" xml:space="preserve">
          <source>If a provider class has been installed in a jar file that is visible to the system class loader, and that jar file contains a provider-configuration file named &lt;code&gt;java.nio.channels.spi.AsynchronousChannelProvider&lt;/code&gt; in the resource directory &lt;code&gt;META-INF/services&lt;/code&gt;, then the first class name specified in that file is taken. The class is loaded and instantiated; if this process fails then an unspecified error is thrown.</source>
          <target state="translated">如果提供程序类已安装在系统类加载器可见的jar文件中，并且该jar文件在资源目录 &lt;code&gt;META-INF/services&lt;/code&gt; 中包含名为 &lt;code&gt;java.nio.channels.spi.AsynchronousChannelProvider&lt;/code&gt; 的提供程序配置文件，然后采用该文件中指定的第一个类名称。该类已加载并实例化；如果此过程失败，则会引发未指定的错误。</target>
        </trans-unit>
        <trans-unit id="fdfa29d9e3e5dd048f606f387c561e986beb3b1f" translate="yes" xml:space="preserve">
          <source>If a provider class has been installed in a jar file that is visible to the system class loader, and that jar file contains a provider-configuration file named &lt;code&gt;java.nio.channels.spi.SelectorProvider&lt;/code&gt; in the resource directory &lt;code&gt;META-INF/services&lt;/code&gt;, then the first class name specified in that file is taken. The class is loaded and instantiated; if this process fails then an unspecified error is thrown.</source>
          <target state="translated">如果提供程序类已安装在系统类加载器可见的jar文件中，并且该jar文件在资源目录 &lt;code&gt;META-INF/services&lt;/code&gt; 中包含名为 &lt;code&gt;java.nio.channels.spi.SelectorProvider&lt;/code&gt; 的提供程序配置文件，然后采用该文件中指定的第一个类名称。该类已加载并实例化；如果此过程失败，则会引发未指定的错误。</target>
        </trans-unit>
        <trans-unit id="40aff6af09d58df40b7fd9256b872b6c75872438" translate="yes" xml:space="preserve">
          <source>If a proxy class implements a non-public interface, then it will be defined in the same package as that interface. Otherwise, the package of a proxy class is also unspecified. Note that package sealing will not prevent a proxy class from being successfully defined in a particular package at runtime, and neither will classes already defined by the same class loader and the same package with particular signers.</source>
          <target state="translated">如果一个代理类实现了一个非公共接口,那么它将被定义在与该接口相同的包中。否则,代理类的包也是不指定的。需要注意的是,封包不会阻止代理类在运行时成功地定义在某个特定的包中,已经被同一个类加载器和同一个包的特定签名者定义的类也不会。</target>
        </trans-unit>
        <trans-unit id="796aaf5cfdf7fbf122008c7936a12a38e2eb7d28" translate="yes" xml:space="preserve">
          <source>If a proxy interface contains a method with the same name and parameter signature as the &lt;code&gt;hashCode&lt;/code&gt;, &lt;code&gt;equals&lt;/code&gt;, or &lt;code&gt;toString&lt;/code&gt; methods of &lt;code&gt;java.lang.Object&lt;/code&gt;, when such a method is invoked on a proxy instance, the &lt;code&gt;Method&lt;/code&gt; object passed to the invocation handler will have &lt;code&gt;java.lang.Object&lt;/code&gt; as its declaring class. In other words, the public, non-final methods of &lt;code&gt;java.lang.Object&lt;/code&gt; logically precede all of the proxy interfaces for the determination of which &lt;code&gt;Method&lt;/code&gt; object to pass to the invocation handler.</source>
          <target state="translated">如果代理接口包含与 &lt;code&gt;java.lang.Object&lt;/code&gt; 的 &lt;code&gt;hashCode&lt;/code&gt; ， &lt;code&gt;equals&lt;/code&gt; 或 &lt;code&gt;toString&lt;/code&gt; 方法具有相同名称和参数签名的方法，则在代理实例上调用该 &lt;code&gt;Method&lt;/code&gt; 传递给调用处理程序的Method对象将将 &lt;code&gt;java.lang.Object&lt;/code&gt; 作为其声明类。换句话说， &lt;code&gt;java.lang.Object&lt;/code&gt; 的公共非最终方法在逻辑上位于所有代理接口之前，以确定将哪个 &lt;code&gt;Method&lt;/code&gt; 对象传递给调用处理程序。</target>
        </trans-unit>
        <trans-unit id="da20e235784a287eb944654e195ab8c9e647b20d" translate="yes" xml:space="preserve">
          <source>If a query is given then a question-mark character (&lt;code&gt;'?'&lt;/code&gt;) is appended, followed by the query. Any character that is not a &lt;a href=&quot;#legal-chars&quot;&gt;legal URI character&lt;/a&gt; is quoted.</source>
          <target state="translated">如果给出查询，则会附加一个问号字符（ &lt;code&gt;'?'&lt;/code&gt; ），然后是查询。引用了不是&lt;a href=&quot;#legal-chars&quot;&gt;合法URI字符的&lt;/a&gt;任何字符。</target>
        </trans-unit>
        <trans-unit id="fd66988b876e62bc3940fc9fa272fb4aa056a6e8" translate="yes" xml:space="preserve">
          <source>If a redefined method has active stack frames, those active frames continue to run the bytecodes of the original method. The redefined method will be used on new invokes.</source>
          <target state="translated">如果一个重新定义的方法有活动的堆栈框架,这些活动框架将继续运行原方法的字节码。重新定义的方法将用于新的调用。</target>
        </trans-unit>
        <trans-unit id="24ef3bceba0cb2aab5212a59ddb1c10b5a5728ca" translate="yes" xml:space="preserve">
          <source>If a remaining element exists, performs the given action on it, returning &lt;code&gt;true&lt;/code&gt;; else returns &lt;code&gt;false&lt;/code&gt;. If this Spliterator is &lt;a href=&quot;spliterator#ORDERED&quot;&gt;&lt;code&gt;ORDERED&lt;/code&gt;&lt;/a&gt; the action is performed on the next element in encounter order. Exceptions thrown by the action are relayed to the caller.</source>
          <target state="translated">如果存在剩余元素，则对它执行给定的操作，返回 &lt;code&gt;true&lt;/code&gt; ；否则返回true。否则返回 &lt;code&gt;false&lt;/code&gt; 。如果此分隔符为&lt;a href=&quot;spliterator#ORDERED&quot;&gt; &lt;code&gt;ORDERED&lt;/code&gt; &lt;/a&gt;，则按遇到顺序对下一个元素执行操作。该操作引发的异常将中继到调用方。</target>
        </trans-unit>
        <trans-unit id="e159606ce958fbbed771df76f4f0eabd266798cd" translate="yes" xml:space="preserve">
          <source>If a remaining element exists, performs the given action on it, returning &lt;code&gt;true&lt;/code&gt;; else returns &lt;code&gt;false&lt;/code&gt;. If this Spliterator is &lt;a href=&quot;spliterator#ORDERED&quot;&gt;&lt;code&gt;Spliterator.ORDERED&lt;/code&gt;&lt;/a&gt; the action is performed on the next element in encounter order. Exceptions thrown by the action are relayed to the caller.</source>
          <target state="translated">如果存在剩余元素，则对它执行给定的操作，返回 &lt;code&gt;true&lt;/code&gt; ；否则返回true。否则返回 &lt;code&gt;false&lt;/code&gt; 。如果此Spliterator为&lt;a href=&quot;spliterator#ORDERED&quot;&gt; &lt;code&gt;Spliterator.ORDERED&lt;/code&gt; ,则按&lt;/a&gt;遇到顺序对下一个元素执行操作。该操作引发的异常将中继到调用方。</target>
        </trans-unit>
        <trans-unit id="1839ce02fdf0a084101d2dedb7a7ec30b1eddf93" translate="yes" xml:space="preserve">
          <source>If a request cannot be queued, a new thread is created unless this would exceed maximumPoolSize, in which case, the task will be rejected.</source>
          <target state="translated">如果请求不能排队,则会创建一个新的线程,除非这将超过maximumPoolSize,在这种情况下,任务将被拒绝。</target>
        </trans-unit>
        <trans-unit id="8dcd6f2eb2f000d41479fe75ebb34b375f18a3c4" translate="yes" xml:space="preserve">
          <source>If a requested access is allowed, &lt;code&gt;checkPermission&lt;/code&gt; returns quietly. If denied, a &lt;code&gt;SecurityException&lt;/code&gt; is thrown.</source>
          <target state="translated">如果允许请求的访问，则 &lt;code&gt;checkPermission&lt;/code&gt; 安静地返回。如果被拒绝，则抛出 &lt;code&gt;SecurityException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="887186d0f2e36f1ee7e723c9cc603e07ae277a39" translate="yes" xml:space="preserve">
          <source>If a requested access is allowed, &lt;code&gt;checkPermission&lt;/code&gt; returns quietly. If denied, an AccessControlException is thrown. AccessControlException can also be thrown if the requested permission is of an incorrect type or contains an invalid value. Such information is given whenever possible. Suppose the current thread traversed m callers, in the order of caller 1 to caller 2 to caller m. Then caller m invoked the &lt;code&gt;checkPermission&lt;/code&gt; method. The &lt;code&gt;checkPermission&lt;/code&gt; method determines whether access is granted or denied based on the following algorithm:</source>
          <target state="translated">如果允许请求的访问，则 &lt;code&gt;checkPermission&lt;/code&gt; 安静地返回。如果被拒绝，则抛出AccessControlException。如果请求的权限类型不正确或包含无效值，也可能引发AccessControlException。尽可能提供此类信息。假设当前线程遍历m个调用者，从调用者1到调用者2到调用者m的顺序。然后，调用者m调用了 &lt;code&gt;checkPermission&lt;/code&gt; 方法。所述 &lt;code&gt;checkPermission&lt;/code&gt; 方法确定是否授予访问权或者基于以下算法被拒绝：</target>
        </trans-unit>
        <trans-unit id="ef31bdb236c1be020d8ae03fbd2d0a2a44475408" translate="yes" xml:space="preserve">
          <source>If a result is passed to the combiner or finisher function, and the same object is not returned from that function, it is never used again.</source>
          <target state="translated">如果一个结果被传递给组合函数或终结函数,并且没有从该函数中返回相同的对象,那么它就再也不会被使用。</target>
        </trans-unit>
        <trans-unit id="4f6485f2810241e1f59964a0306f13fb66de588c" translate="yes" xml:space="preserve">
          <source>If a retransformed method has active stack frames, those active frames continue to run the bytecodes of the original method. The retransformed method will be used on new invokes.</source>
          <target state="translated">如果一个重构的方法有活动的堆栈帧,这些活动帧将继续运行原方法的字节码。重构后的方法将用于新的调用。</target>
        </trans-unit>
        <trans-unit id="14bfd111544b6485485ff232a946c27189f15782" translate="yes" xml:space="preserve">
          <source>If a scheme is given then it is appended to the result, followed by a colon character (&lt;code&gt;':'&lt;/code&gt;).</source>
          <target state="translated">如果给出了方案，则将其附加到结果后，然后是冒号（ &lt;code&gt;':'&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="e5292412b3ee897a572e5c7195ad6e65ff3c8f5e" translate="yes" xml:space="preserve">
          <source>If a scheme is given then the path, if also given, must either be empty or begin with a slash character (&lt;code&gt;'/'&lt;/code&gt;). Otherwise a component of the new URI may be left undefined by passing &lt;code&gt;null&lt;/code&gt; for the corresponding parameter or, in the case of the &lt;code&gt;port&lt;/code&gt; parameter, by passing &lt;code&gt;-1&lt;/code&gt;.</source>
          <target state="translated">如果给出了方案，则路径（如果也给出）必须为空或以斜杠字符（ &lt;code&gt;'/'&lt;/code&gt; ）开头。否则，新的URI的组分可以通过使可能保持未定义 &lt;code&gt;null&lt;/code&gt; 用于相应的参数，或者在所述的情况下 &lt;code&gt;port&lt;/code&gt; 参数，通过使 &lt;code&gt;-1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7eb7b84865919239961f0fcc50c50d09850970cc" translate="yes" xml:space="preserve">
          <source>If a scheme is given then the path, if also given, must either be empty or begin with a slash character (&lt;code&gt;'/'&lt;/code&gt;). Otherwise a component of the new URI may be left undefined by passing &lt;code&gt;null&lt;/code&gt; for the corresponding parameter.</source>
          <target state="translated">如果给出了方案，则路径（如果也给出）必须为空或以斜杠字符（ &lt;code&gt;'/'&lt;/code&gt; ）开头。否则，可以通过为相应的参数传递 &lt;code&gt;null&lt;/code&gt; 来使新URI的组件保持未定义状态。</target>
        </trans-unit>
        <trans-unit id="952cc358b56318941d6e6ab799e6dc4bef4fa5ce" translate="yes" xml:space="preserve">
          <source>If a scheme-specific part is given then it is appended. Any character that is not a &lt;a href=&quot;#legal-chars&quot;&gt;legal URI character&lt;/a&gt; is &lt;a href=&quot;#quote&quot;&gt;quoted&lt;/a&gt;.</source>
          <target state="translated">如果给出了特定于方案的部分，则将其追加。任何字符不是一个&lt;a href=&quot;#legal-chars&quot;&gt;合法的URI字符&lt;/a&gt;被&lt;a href=&quot;#quote&quot;&gt;引用&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="13bf2d89737ab4f9e4f3365daa8c4a8a75373b41" translate="yes" xml:space="preserve">
          <source>If a search filter with invalid variable substitutions is provided to this method, the result is undefined. When changes are made to this DirContext, the effect on enumerations returned by prior calls to this method is undefined.</source>
          <target state="translated">如果向本方法提供了一个带有无效变量替换的搜索过滤器,则结果是未定义的。当对这个DirContext进行更改时,对之前调用本方法返回的枚举的影响是未定义的。</target>
        </trans-unit>
        <trans-unit id="e97fd2ab90897223be3d44a61e5dac3ab116baef" translate="yes" xml:space="preserve">
          <source>If a security check fails, the method throws &lt;a href=&quot;../../java/lang/securityexception&quot;&gt;&lt;code&gt;SecurityException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果安全检查失败，则该方法将引发&lt;a href=&quot;../../java/lang/securityexception&quot;&gt; &lt;code&gt;SecurityException&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9dea5876966fa5396ec8f16c92b8e2f701b1ace9" translate="yes" xml:space="preserve">
          <source>If a security manager exists, its &lt;a href=&quot;securitymanager#checkExec-java.lang.String-&quot;&gt;&lt;code&gt;checkExec&lt;/code&gt;&lt;/a&gt; method is invoked with the first component of the array &lt;code&gt;cmdarray&lt;/code&gt; as its argument. This may result in a &lt;a href=&quot;securityexception&quot;&gt;&lt;code&gt;SecurityException&lt;/code&gt;&lt;/a&gt; being thrown.</source>
          <target state="translated">如果存在安全管理器，则使用数组 &lt;code&gt;cmdarray&lt;/code&gt; 的第一个组件作为其参数来调用其&lt;a href=&quot;securitymanager#checkExec-java.lang.String-&quot;&gt; &lt;code&gt;checkExec&lt;/code&gt; &lt;/a&gt;方法。这可能会导致引发&lt;a href=&quot;securityexception&quot;&gt; &lt;code&gt;SecurityException&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="53168f421aa4d312fe84c343c76a94712c016bae" translate="yes" xml:space="preserve">
          <source>If a security manager exists, its &lt;a href=&quot;securitymanager#checkPermission-java.security.Permission-&quot;&gt;&lt;code&gt;checkPermission&lt;/code&gt;&lt;/a&gt; method is called with a &lt;a href=&quot;runtimepermission&quot;&gt;&lt;code&gt;RuntimePermission&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(&quot;getenv.*&quot;)&lt;/code&gt; permission. This may result in a &lt;a href=&quot;securityexception&quot;&gt;&lt;code&gt;SecurityException&lt;/code&gt;&lt;/a&gt; being thrown.</source>
          <target state="translated">如果存在安全管理器，则使用&lt;a href=&quot;runtimepermission&quot;&gt; &lt;code&gt;RuntimePermission&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(&quot;getenv.*&quot;)&lt;/code&gt; 权限调用其&lt;a href=&quot;securitymanager#checkPermission-java.security.Permission-&quot;&gt; &lt;code&gt;checkPermission&lt;/code&gt; &lt;/a&gt;方法。这可能会导致引发&lt;a href=&quot;securityexception&quot;&gt; &lt;code&gt;SecurityException&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2be9fb106610b30c8cb7f763862c74ced2b9d9be" translate="yes" xml:space="preserve">
          <source>If a security manager exists, its &lt;a href=&quot;securitymanager#checkPermission-java.security.Permission-&quot;&gt;&lt;code&gt;checkPermission&lt;/code&gt;&lt;/a&gt; method is called with a &lt;code&gt;&lt;a href=&quot;runtimepermission&quot;&gt;&lt;code&gt;RuntimePermission&lt;/code&gt;&lt;/a&gt;(&quot;getenv.&quot;+name)&lt;/code&gt; permission. This may result in a &lt;a href=&quot;securityexception&quot;&gt;&lt;code&gt;SecurityException&lt;/code&gt;&lt;/a&gt; being thrown. If no exception is thrown the value of the variable &lt;code&gt;name&lt;/code&gt; is returned.</source>
          <target state="translated">如果存在安全管理器，则会使用 &lt;code&gt;&lt;a href=&quot;runtimepermission&quot;&gt;&lt;code&gt;RuntimePermission&lt;/code&gt;&lt;/a&gt;(&quot;getenv.&quot;+name)&lt;/code&gt; （&amp;ldquo; getenv。&amp;rdquo; +名称）权限来调用其&lt;a href=&quot;securitymanager#checkPermission-java.security.Permission-&quot;&gt; &lt;code&gt;checkPermission&lt;/code&gt; &lt;/a&gt;方法。这可能会导致引发&lt;a href=&quot;securityexception&quot;&gt; &lt;code&gt;SecurityException&lt;/code&gt; &lt;/a&gt;。如果没有抛出异常，则返回变量 &lt;code&gt;name&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="799c889390e9c989ec60d735a9738bf280d5b1a4" translate="yes" xml:space="preserve">
          <source>If a security manager exists, its &lt;a href=&quot;securitymanager#checkPermission-java.security.Permission-&quot;&gt;&lt;code&gt;checkPermission&lt;/code&gt;&lt;/a&gt; method is called with a &lt;code&gt;&lt;a href=&quot;runtimepermission&quot;&gt;&lt;code&gt;RuntimePermission&lt;/code&gt;&lt;/a&gt;(&quot;getenv.*&quot;)&lt;/code&gt; permission. This may result in a &lt;a href=&quot;securityexception&quot;&gt;&lt;code&gt;SecurityException&lt;/code&gt;&lt;/a&gt; being thrown.</source>
          <target state="translated">如果存在安全管理器，则使用 &lt;code&gt;&lt;a href=&quot;runtimepermission&quot;&gt;&lt;code&gt;RuntimePermission&lt;/code&gt;&lt;/a&gt;(&quot;getenv.*&quot;)&lt;/code&gt; （&amp;ldquo; getenv。*&amp;rdquo;）权限调用其&lt;a href=&quot;securitymanager#checkPermission-java.security.Permission-&quot;&gt; &lt;code&gt;checkPermission&lt;/code&gt; &lt;/a&gt;方法。这可能会导致引发&lt;a href=&quot;securityexception&quot;&gt; &lt;code&gt;SecurityException&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a1659595caad59762dfff687e8404d52f631d93f" translate="yes" xml:space="preserve">
          <source>If a security manager has been installed then it is invoked to check access to the remote address. Specifically, if the given &lt;code&gt;address&lt;/code&gt; is a &lt;a href=&quot;inetaddress#isMulticastAddress--&quot;&gt;&lt;code&gt;multicast address&lt;/code&gt;&lt;/a&gt;, the security manager's &lt;a href=&quot;../lang/securitymanager#checkMulticast-java.net.InetAddress-&quot;&gt;&lt;code&gt;checkMulticast&lt;/code&gt;&lt;/a&gt; method is invoked with the given &lt;code&gt;address&lt;/code&gt;. Otherwise, the security manager's &lt;a href=&quot;../lang/securitymanager#checkConnect-java.lang.String-int-&quot;&gt;&lt;code&gt;checkConnect&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../lang/securitymanager#checkAccept-java.lang.String-int-&quot;&gt;&lt;code&gt;checkAccept&lt;/code&gt;&lt;/a&gt; methods are invoked, with the given &lt;code&gt;address&lt;/code&gt; and &lt;code&gt;port&lt;/code&gt;, to verify that datagrams are permitted to be sent and received respectively.</source>
          <target state="translated">如果已安装安全管理器，则将调用它来检查对远程地址的访问。具体来说，如果给定 &lt;code&gt;address&lt;/code&gt; 是&lt;a href=&quot;inetaddress#isMulticastAddress--&quot;&gt; &lt;code&gt;multicast address&lt;/code&gt; &lt;/a&gt;，则使用给定 &lt;code&gt;address&lt;/code&gt; 调用安全管理器的&lt;a href=&quot;../lang/securitymanager#checkMulticast-java.net.InetAddress-&quot;&gt; &lt;code&gt;checkMulticast&lt;/code&gt; &lt;/a&gt;方法。否则，将使用给定的 &lt;code&gt;address&lt;/code&gt; 和 &lt;code&gt;port&lt;/code&gt; 调用安全管理器的&lt;a href=&quot;../lang/securitymanager#checkConnect-java.lang.String-int-&quot;&gt; &lt;code&gt;checkConnect&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../lang/securitymanager#checkAccept-java.lang.String-int-&quot;&gt; &lt;code&gt;checkAccept&lt;/code&gt; &lt;/a&gt;方法，以验证分别允许发送和接收数据报。</target>
        </trans-unit>
        <trans-unit id="e62ef67bcdaa9aa21e31d7d487c07bd914492ed8" translate="yes" xml:space="preserve">
          <source>If a security manager has been installed then it verifies that the address and port number of the connection's remote endpoint are permitted by the security manager's &lt;a href=&quot;../../lang/securitymanager#checkAccept-java.lang.String-int-&quot;&gt;&lt;code&gt;checkAccept&lt;/code&gt;&lt;/a&gt; method. The permission check is performed with privileges that are restricted by the calling context of this method. If the permission check fails then the connection is closed and the operation completes with a &lt;a href=&quot;../../lang/securityexception&quot;&gt;&lt;code&gt;SecurityException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果已安装安全管理器，则它将验证安全管理器的&lt;a href=&quot;../../lang/securitymanager#checkAccept-java.lang.String-int-&quot;&gt; &lt;code&gt;checkAccept&lt;/code&gt; &lt;/a&gt;方法是否允许连接的远程端点的地址和端口号。使用此方法的调用上下文限制的特权执行权限检查。如果权限检查失败，则连接将关闭，并且操作将以&lt;a href=&quot;../../lang/securityexception&quot;&gt; &lt;code&gt;SecurityException&lt;/code&gt; 结束&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="774bb30d85acccb9e7832ec0c0d531eef6b9e9b6" translate="yes" xml:space="preserve">
          <source>If a security manager is enabled, its &lt;code&gt;checkSecurityAccess&lt;/code&gt; method is called with the string &lt;code&gt;&quot;clearProviderProperties.&quot;+name&lt;/code&gt; (where &lt;code&gt;name&lt;/code&gt; is the provider name) to see if it's ok to clear this provider.</source>
          <target state="translated">如果启用了安全管理器，则使用字符串 &lt;code&gt;&quot;clearProviderProperties.&quot;+name&lt;/code&gt; （其中 &lt;code&gt;name&lt;/code&gt; 是提供程序名称）来调用其 &lt;code&gt;checkSecurityAccess&lt;/code&gt; 方法，以查看是否可以清除此提供程序。</target>
        </trans-unit>
        <trans-unit id="f35e03213aea8a9f7162a4e6061b476c733a84f5" translate="yes" xml:space="preserve">
          <source>If a security manager is enabled, its &lt;code&gt;checkSecurityAccess&lt;/code&gt; method is called with the string &lt;code&gt;&quot;putProviderProperty.&quot;+name&lt;/code&gt;, where &lt;code&gt;name&lt;/code&gt; is the provider name, to see if it's ok to set this provider's property values.</source>
          <target state="translated">如果启用了安全管理器，则使用字符串 &lt;code&gt;&quot;putProviderProperty.&quot;+name&lt;/code&gt; 调用其 &lt;code&gt;checkSecurityAccess&lt;/code&gt; 方法，其中 &lt;code&gt;name&lt;/code&gt; 是提供程序名称，以查看是否可以设置此提供程序的属性值。</target>
        </trans-unit>
        <trans-unit id="97b050d112e298b259d22c6b122aa0f103951b1a" translate="yes" xml:space="preserve">
          <source>If a security manager is enabled, its &lt;code&gt;checkSecurityAccess&lt;/code&gt; method is called with the string &lt;code&gt;&quot;removeProviderProperty.&quot;+name&lt;/code&gt;, where &lt;code&gt;name&lt;/code&gt; is the provider name, to see if it's ok to remove this provider's properties.</source>
          <target state="translated">如果启用了安全管理器，则使用字符串 &lt;code&gt;&quot;removeProviderProperty.&quot;+name&lt;/code&gt; （其中 &lt;code&gt;name&lt;/code&gt; 是提供程序名称）来调用其 &lt;code&gt;checkSecurityAccess&lt;/code&gt; 方法，以查看是否可以删除此提供程序的属性。</target>
        </trans-unit>
        <trans-unit id="ece65adbb64e89095abfe9c2349b473bbf31084f" translate="yes" xml:space="preserve">
          <source>If a security manager is enabled, its &lt;code&gt;checkSecurityAccess&lt;/code&gt; method is called with the strings &lt;code&gt;&quot;putProviderProperty.&quot;+name&lt;/code&gt; and &lt;code&gt;&quot;removeProviderProperty.&quot;+name&lt;/code&gt;, where &lt;code&gt;name&lt;/code&gt; is the provider name, to see if it's ok to set this provider's property values and remove this provider's properties.</source>
          <target state="translated">如果启用了安全管理器，则使用字符串 &lt;code&gt;&quot;putProviderProperty.&quot;+name&lt;/code&gt; 和 &lt;code&gt;&quot;removeProviderProperty.&quot;+name&lt;/code&gt; （其中 &lt;code&gt;name&lt;/code&gt; 是提供者名称）来调用其 &lt;code&gt;checkSecurityAccess&lt;/code&gt; 方法，以查看是否可以设置该提供者的属性值并将其删除提供者的属性。</target>
        </trans-unit>
        <trans-unit id="cf20f936473755f39be868cd9845f771cb103a28" translate="yes" xml:space="preserve">
          <source>If a security manager is installed and the specified &lt;code&gt;AccessControlContext&lt;/code&gt; was not created by system code and the caller's &lt;code&gt;ProtectionDomain&lt;/code&gt; has not been granted the &quot;createAccessControlContext&quot; &lt;a href=&quot;securitypermission&quot;&gt;&lt;code&gt;SecurityPermission&lt;/code&gt;&lt;/a&gt;, then the action is performed with no permissions.</source>
          <target state="translated">如果安装了安全管理器，并且系统代码未创建指定的 &lt;code&gt;AccessControlContext&lt;/code&gt; ,并且未向调用方的 &lt;code&gt;ProtectionDomain&lt;/code&gt; 授予&amp;ldquo; createAccessControlContext&amp;rdquo; &lt;a href=&quot;securitypermission&quot;&gt; &lt;code&gt;SecurityPermission&lt;/code&gt; &lt;/a&gt;，则将在没有权限的情况下执行操作。</target>
        </trans-unit>
        <trans-unit id="71505a5d56a109fcf20595110953779d866b2e80" translate="yes" xml:space="preserve">
          <source>If a security manager is installed then a provider implementation may require to check a permission before returning a reference to an existing file system. In the case of the &lt;a href=&quot;../filesystems#getDefault--&quot;&gt;&lt;code&gt;default&lt;/code&gt;&lt;/a&gt; file system, no permission check is required.</source>
          <target state="translated">如果安装了安全管理器，则提供程序实现可能需要在返回对现有文件系统的引用之前检查权限。对于&lt;a href=&quot;../filesystems#getDefault--&quot;&gt; &lt;code&gt;default&lt;/code&gt; &lt;/a&gt;文件系统，不需要权限检查。</target>
        </trans-unit>
        <trans-unit id="94817a0d003779bd7b3676c9e779ce36983364b9" translate="yes" xml:space="preserve">
          <source>If a security manager is installed then a provider implementation may require to check a permission before returning a reference to an existing file system. In the case of the &lt;a href=&quot;filesystems#getDefault--&quot;&gt;&lt;code&gt;default&lt;/code&gt;&lt;/a&gt; file system, no permission check is required.</source>
          <target state="translated">如果安装了安全管理器，则提供程序实现可能需要在返回对现有文件系统的引用之前检查权限。对于&lt;a href=&quot;filesystems#getDefault--&quot;&gt; &lt;code&gt;default&lt;/code&gt; &lt;/a&gt;文件系统，不需要权限检查。</target>
        </trans-unit>
        <trans-unit id="8d8b4d6a644688d37bf4f42e678ef49d5a579de5" translate="yes" xml:space="preserve">
          <source>If a security manager is installed then a provider implementation may require to check a permission. In the case of the &lt;a href=&quot;../filesystems#getDefault--&quot;&gt;&lt;code&gt;default&lt;/code&gt;&lt;/a&gt; file system, no permission check is required.</source>
          <target state="translated">如果安装了安全管理器，则提供程序实现可能需要检查权限。对于&lt;a href=&quot;../filesystems#getDefault--&quot;&gt; &lt;code&gt;default&lt;/code&gt; &lt;/a&gt;文件系统，不需要权限检查。</target>
        </trans-unit>
        <trans-unit id="b0d87efa51aa6969d6f0da372f01e957e877983c" translate="yes" xml:space="preserve">
          <source>If a security manager is installed, and if a method is called which results in an attempt to open a connection, the caller must possess either:-</source>
          <target state="translated">如果安装了安全管理器,并且如果调用的方法导致试图打开一个连接,调用者必须具备以下两种情况:--------。</target>
        </trans-unit>
        <trans-unit id="e951d48b2804e2b72e838d29cf84001eb9605eaa" translate="yes" xml:space="preserve">
          <source>If a security manager is installed, this constructor will check for the &quot;enableSubclassImplementation&quot; SerializablePermission when invoked directly or indirectly by the constructor of a subclass which overrides the ObjectInputStream.readFields or ObjectInputStream.readUnshared methods.</source>
          <target state="translated">如果安装了安全管理器,当子类的构造函数直接或间接调用该构造函数时,该构造函数将检查 &quot;enableSubclassImplementation &quot;SerializablePermission是否覆盖了ObjectInputStream.readFields或ObjectInputStream.readUnshared方法。</target>
        </trans-unit>
        <trans-unit id="97bae6ffb96e1d4b174839ef22d4e1aad74be094" translate="yes" xml:space="preserve">
          <source>If a security manager is installed, this constructor will check for the &quot;enableSubclassImplementation&quot; SerializablePermission when invoked directly or indirectly by the constructor of a subclass which overrides the ObjectOutputStream.putFields or ObjectOutputStream.writeUnshared methods.</source>
          <target state="translated">如果安装了安全管理器,当子类的构造函数直接或间接调用该构造函数时,该构造函数将检查 &quot;enableSubclassImplementation &quot;SerializablePermission是否覆盖了ObjectOutputStream.putFields或ObjectOutputStream.writeUnshared方法。</target>
        </trans-unit>
        <trans-unit id="d92bb3509ac791abbf0139a9c7f57cc935e83b78" translate="yes" xml:space="preserve">
          <source>If a security manager is installed, this method is caller sensitive. During any invocation of the target method handle via the returned wrapper, the original creator of the wrapper (the caller) will be visible to context checks requested by the security manager.</source>
          <target state="translated">如果安装了安全管理器,这个方法是调用者敏感的。在通过返回的包装器调用目标方法句柄的过程中,包装器的原始创建者(调用者)将在安全管理器要求的上下文检查中可见。</target>
        </trans-unit>
        <trans-unit id="d8a665c3d954d0fc47740977c830812c0a85b298" translate="yes" xml:space="preserve">
          <source>If a security manager is present, and the caller's class loader is not null and the caller's class loader is not the same as or an ancestor of the class loader for the class whose class loader is requested, then this method calls the security manager's &lt;code&gt;checkPermission&lt;/code&gt; method with a &lt;code&gt;RuntimePermission(&quot;getClassLoader&quot;)&lt;/code&gt; permission to ensure it's ok to access the class loader for the class.</source>
          <target state="translated">如果存在安全管理器，并且调用方的类加载器不为null且调用者的类加载器与请求其类加载器的类的祖先或类加载器的祖先不同，则此方法调用安全管理器的 &lt;code&gt;checkPermission&lt;/code&gt; 方法具有 &lt;code&gt;RuntimePermission(&quot;getClassLoader&quot;)&lt;/code&gt; 权限，以确保可以访问该类的类加载器。</target>
        </trans-unit>
        <trans-unit id="fae23e2153f023848b4e6ff03b38daa20b992dd7" translate="yes" xml:space="preserve">
          <source>If a security manager is present, and the invoker's class loader is not &lt;code&gt;null&lt;/code&gt; and is not an ancestor of this class loader, then this method invokes the security manager's &lt;a href=&quot;securitymanager#checkPermission-java.security.Permission-&quot;&gt;&lt;code&gt;&lt;code&gt;checkPermission&lt;/code&gt;&lt;/code&gt;&lt;/a&gt; method with a &lt;a href=&quot;runtimepermission#RuntimePermission-java.lang.String-&quot;&gt;&lt;code&gt;&lt;code&gt;RuntimePermission(&quot;getClassLoader&quot;)&lt;/code&gt;&lt;/code&gt;&lt;/a&gt; permission to verify access to the parent class loader is permitted. If not, a &lt;code&gt;SecurityException&lt;/code&gt; will be thrown.</source>
          <target state="translated">如果存在安全管理器，并且调用者的类加载器不为 &lt;code&gt;null&lt;/code&gt; 且不是该类加载器的祖先，则此方法将调用具有&lt;a href=&quot;runtimepermission#RuntimePermission-java.lang.String-&quot;&gt; &lt;code&gt;&lt;code&gt;RuntimePermission(&quot;getClassLoader&quot;)&lt;/code&gt;&lt;/code&gt; &lt;/a&gt;权限的安全管理器的&lt;a href=&quot;securitymanager#checkPermission-java.security.Permission-&quot;&gt; &lt;code&gt;&lt;code&gt;checkPermission&lt;/code&gt;&lt;/code&gt; &lt;/a&gt;方法，以验证对父类的访问允许加载程序。否则，将抛出 &lt;code&gt;SecurityException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d340f476b6c3ae11657fddd0392b049fcfa29b4e" translate="yes" xml:space="preserve">
          <source>If a security manager is present, and the invoker's class loader is not &lt;code&gt;null&lt;/code&gt; and is not the same as or an ancestor of the context class loader, then this method invokes the security manager's &lt;a href=&quot;securitymanager#checkPermission-java.security.Permission-&quot;&gt;&lt;code&gt;checkPermission&lt;/code&gt;&lt;/a&gt; method with a &lt;a href=&quot;runtimepermission&quot;&gt;&lt;code&gt;RuntimePermission&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(&quot;getClassLoader&quot;)&lt;/code&gt; permission to verify that retrieval of the context class loader is permitted.</source>
          <target state="translated">如果存在安全管理器，并且调用者的类加载器不为 &lt;code&gt;null&lt;/code&gt; 且与上下文类加载器的祖先或父类不相同，则此方法将调用具有&lt;a href=&quot;runtimepermission&quot;&gt; &lt;code&gt;RuntimePermission&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(&quot;getClassLoader&quot;)&lt;/code&gt; 权限的安全管理器的&lt;a href=&quot;securitymanager#checkPermission-java.security.Permission-&quot;&gt; &lt;code&gt;checkPermission&lt;/code&gt; &lt;/a&gt;方法以进行验证允许检索上下文类加载器。</target>
        </trans-unit>
        <trans-unit id="9a7bab9ae3bc48ceb4d26ca9f16abf87e363a12c" translate="yes" xml:space="preserve">
          <source>If a security manager is present, and the invoker's class loader is not &lt;code&gt;null&lt;/code&gt; and the invoker's class loader is not the same as or an ancestor of the system class loader, then this method invokes the security manager's &lt;a href=&quot;securitymanager#checkPermission-java.security.Permission-&quot;&gt;&lt;code&gt;&lt;code&gt;checkPermission&lt;/code&gt;&lt;/code&gt;&lt;/a&gt; method with a &lt;a href=&quot;runtimepermission#RuntimePermission-java.lang.String-&quot;&gt;&lt;code&gt;&lt;code&gt;RuntimePermission(&quot;getClassLoader&quot;)&lt;/code&gt;&lt;/code&gt;&lt;/a&gt; permission to verify access to the system class loader. If not, a &lt;code&gt;SecurityException&lt;/code&gt; will be thrown.</source>
          <target state="translated">如果存在安全管理器，并且调用者的类加载器不为 &lt;code&gt;null&lt;/code&gt; ，并且调用者的类加载器与系统类加载器不同，或者其祖先，则此方法使用&lt;a href=&quot;runtimepermission#RuntimePermission-java.lang.String-&quot;&gt; &lt;code&gt;&lt;code&gt;RuntimePermission(&quot;getClassLoader&quot;)&lt;/code&gt;&lt;/code&gt; &lt;/a&gt;调用安全管理器的&lt;a href=&quot;securitymanager#checkPermission-java.security.Permission-&quot;&gt; &lt;code&gt;&lt;code&gt;checkPermission&lt;/code&gt;&lt;/code&gt; &lt;/a&gt;方法。）的权限，以验证对系统类加载器的访问权限。否则，将引发 &lt;code&gt;SecurityException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="459bc04b32cd4cdbb41e230932994ba0a7971ad8" translate="yes" xml:space="preserve">
          <source>If a security manager is present, its &lt;a href=&quot;securitymanager#checkPermission-java.security.Permission-&quot;&gt;&lt;code&gt;checkPermission&lt;/code&gt;&lt;/a&gt; method is invoked with a &lt;a href=&quot;runtimepermission&quot;&gt;&lt;code&gt;RuntimePermission&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(&quot;setContextClassLoader&quot;)&lt;/code&gt; permission to see if setting the context ClassLoader is permitted.</source>
          <target state="translated">如果存在安全管理器，则会使用&lt;a href=&quot;runtimepermission&quot;&gt; &lt;code&gt;RuntimePermission&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(&quot;setContextClassLoader&quot;)&lt;/code&gt; 权限调用其&lt;a href=&quot;securitymanager#checkPermission-java.security.Permission-&quot;&gt; &lt;code&gt;checkPermission&lt;/code&gt; &lt;/a&gt;方法，以查看是否允许设置上下文ClassLoader。</target>
        </trans-unit>
        <trans-unit id="944477a6804441726a3b8f252f78eae83726e3a4" translate="yes" xml:space="preserve">
          <source>If a security manager is present, member lookups are subject to additional checks. From one to three calls are made to the security manager. Any of these calls can refuse access by throwing a &lt;a href=&quot;../securityexception&quot;&gt;&lt;code&gt;SecurityException&lt;/code&gt;&lt;/a&gt;. Define &lt;code&gt;smgr&lt;/code&gt; as the security manager, &lt;code&gt;lookc&lt;/code&gt; as the lookup class of the current lookup object, &lt;code&gt;refc&lt;/code&gt; as the containing class in which the member is being sought, and &lt;code&gt;defc&lt;/code&gt; as the class in which the member is actually defined. The value &lt;code&gt;lookc&lt;/code&gt; is defined as &lt;em&gt;not present&lt;/em&gt; if the current lookup object does not have &lt;a href=&quot;methodhandles.lookup#privacc&quot;&gt;private access&lt;/a&gt;. The calls are made according to the following rules:</source>
          <target state="translated">如果存在安全管理器，则对成员查找进行其他检查。会向安全管理器发出1到3个电话。这些调用中的任何一个都可以抛出&lt;a href=&quot;../securityexception&quot;&gt; &lt;code&gt;SecurityException&lt;/code&gt; &lt;/a&gt;来拒绝访问。将 &lt;code&gt;smgr&lt;/code&gt; 定义为安全管理器，将 &lt;code&gt;lookc&lt;/code&gt; 定义为当前查找对象的查找类，将 &lt;code&gt;refc&lt;/code&gt; 定义为在其中查找成员的包含类，将 &lt;code&gt;defc&lt;/code&gt; 定义为实际在其中定义成员的类。如果当前查找对象没有&lt;a href=&quot;methodhandles.lookup#privacc&quot;&gt;私有访问权限&lt;/a&gt;&lt;em&gt;，&lt;/em&gt;则值 &lt;code&gt;lookc&lt;/code&gt; 定义为&lt;em&gt;不存在&lt;/em&gt;。呼叫是根据以下规则进行的：</target>
        </trans-unit>
        <trans-unit id="401c7fd6161f35837fa11c7a250b7f821910874a" translate="yes" xml:space="preserve">
          <source>If a serializable class does not explicitly declare a serialVersionUID, then the serialization runtime will calculate a default serialVersionUID value for that class based on various aspects of the class, as described in the Java(TM) Object Serialization Specification. However, it is &lt;em&gt;strongly recommended&lt;/em&gt; that all serializable classes explicitly declare serialVersionUID values, since the default serialVersionUID computation is highly sensitive to class details that may vary depending on compiler implementations, and can thus result in unexpected &lt;code&gt;InvalidClassException&lt;/code&gt;s during deserialization. Therefore, to guarantee a consistent serialVersionUID value across different java compiler implementations, a serializable class must declare an explicit serialVersionUID value. It is also strongly advised that explicit serialVersionUID declarations use the &lt;code&gt;private&lt;/code&gt; modifier where possible, since such declarations apply only to the immediately declaring class--serialVersionUID fields are not useful as inherited members. Array classes cannot declare an explicit serialVersionUID, so they always have the default computed value, but the requirement for matching serialVersionUID values is waived for array classes.</source>
          <target state="translated">如果可序列化的类未明确声明serialVersionUID，则序列化运行时将根据该类的各个方面，为该类计算默认的serialVersionUID值，如Java&amp;trade;对象序列化规范中所述。但是，&lt;em&gt;强烈建议&lt;/em&gt;所有可序列化的类显式声明serialVersionUID值，因为默认的serialVersionUID计算对类详细信息高度敏感，类详细信息可能会因编译器的实现而有所不同，因此可能导致意外的 &lt;code&gt;InvalidClassException&lt;/code&gt; 在反序列化过程中。因此，为了保证不同Java编译器实现之间的serialVersionUID值一致，可序列化的类必须声明一个显式的serialVersionUID值。还强烈建议显式serialVersionUID声明在可能的情况下使用 &lt;code&gt;private&lt;/code&gt; 修饰符，因为此类声明仅适用于立即声明的类-serialVersionUID字段作为继承成员不起作用。数组类无法声明显式的serialVersionUID，因此它们始终具有默认的计算值，但是对于数组类，无需匹配serialVersionUID值。</target>
        </trans-unit>
        <trans-unit id="b8a284373bcb59e24e39e3dac459820aaa1124e2" translate="yes" xml:space="preserve">
          <source>If a service only supports registration for existing targets, an attempt to register for a nonexistent target results in a &lt;code&gt;NameNotFoundException&lt;/code&gt; being thrown as early as possible, preferably at the time &lt;code&gt;addNamingListener()&lt;/code&gt; is called, or if that is not possible, the listener will receive the exception through the &lt;code&gt;NamingExceptionEvent&lt;/code&gt;.</source>
          <target state="translated">如果服务仅支持对现有目标的注册，则尝试为不存在的目标注册会导致尽早抛出 &lt;code&gt;NameNotFoundException&lt;/code&gt; ，最好在调用 &lt;code&gt;addNamingListener()&lt;/code&gt; 时抛出，否则，侦听器将收到通过 &lt;code&gt;NamingExceptionEvent&lt;/code&gt; 引发的异常。</target>
        </trans-unit>
        <trans-unit id="f0a93070904cd7e6062d269f73ed4cf640917a73" translate="yes" xml:space="preserve">
          <source>If a service supports this method it cannot be concluded that job cancellation will always succeed. A job may not be able to be cancelled once it has reached and passed some point in its processing. A successful cancellation means only that the entire job was not printed, some portion may already have printed when cancel returns.</source>
          <target state="translated">如果一个服务支持这种方法,就不能断定作业取消一定会成功。作业一旦到达并通过了处理过程中的某个点,就可能无法取消。成功的取消只意味着整个作业没有被打印出来,当取消返回时,有些部分可能已经打印出来了。</target>
        </trans-unit>
        <trans-unit id="be2255c8ae3c0e253b4d1c3edfe6c7951b6b7652" translate="yes" xml:space="preserve">
          <source>If a signer, or codesource is granted this permission, then it is considered a trusted source for MBeans. Only MBeans from trusted sources may be registered in the MBeanServer.</source>
          <target state="translated">如果一个签名者或代码源被授予这个权限,那么它就被认为是MBeans的可信源。只有来自可信源的MBeans才可以在MBeanServer中注册。</target>
        </trans-unit>
        <trans-unit id="03ecf67fc16b1bbea18316b3fee73e9a01230e4e" translate="yes" xml:space="preserve">
          <source>If a single argument is parsed more than once in the string, then the later parse wins.</source>
          <target state="translated">如果一个参数在字符串中被解析超过一次,那么后面的解析就会获胜。</target>
        </trans-unit>
        <trans-unit id="31689da1ab6eb24083df20cceed8f165c2b092ae" translate="yes" xml:space="preserve">
          <source>If a socket bound to an endpoint represented by an &lt;code&gt;InetSocketAddress &lt;/code&gt; is &lt;a href=&quot;socket#close--&quot;&gt;&lt;code&gt;closed&lt;/code&gt;&lt;/a&gt;, then this method will continue to return an &lt;code&gt;InetSocketAddress&lt;/code&gt; after the socket is closed. In that case the returned &lt;code&gt;InetSocketAddress&lt;/code&gt;'s address is the &lt;a href=&quot;inetaddress#isAnyLocalAddress--&quot;&gt;&lt;code&gt;wildcard&lt;/code&gt;&lt;/a&gt; address and its port is the local port that it was bound to.</source>
          <target state="translated">如果绑定到由 &lt;code&gt;InetSocketAddress &lt;/code&gt; 表示的端点的套接字已&lt;a href=&quot;socket#close--&quot;&gt; &lt;code&gt;closed&lt;/code&gt; &lt;/a&gt;，则此方法在套接字关闭后将继续返回 &lt;code&gt;InetSocketAddress&lt;/code&gt; 。在这种情况下，返回的 &lt;code&gt;InetSocketAddress&lt;/code&gt; 的地址是&lt;a href=&quot;inetaddress#isAnyLocalAddress--&quot;&gt; &lt;code&gt;wildcard&lt;/code&gt; &lt;/a&gt;地址，并且其端口是绑定到的本地端口。</target>
        </trans-unit>
        <trans-unit id="bb0809c0cf763cd6b646a20d3b4af68f3b750ce9" translate="yes" xml:space="preserve">
          <source>If a special collation rule controlled by a &amp;lt;modifier&amp;gt; is specified it applies to the whole collator object.</source>
          <target state="translated">如果指定了由&amp;lt;modifier&amp;gt;控制的特殊整理规则，则该规则将应用于整个整理对象。</target>
        </trans-unit>
        <trans-unit id="dde854bb0f9389f51a8a547bcdbab6e693c555ad" translate="yes" xml:space="preserve">
          <source>If a spliterator covers no elements then the reporting of additional characteristic values, beyond that of &lt;code&gt;SIZED&lt;/code&gt; and &lt;code&gt;SUBSIZED&lt;/code&gt;, does not aid clients to control, specialize or simplify computation. However, this does enable shared use of an immutable and empty spliterator instance (see &lt;a href=&quot;spliterators#emptySpliterator--&quot;&gt;&lt;code&gt;Spliterators.emptySpliterator()&lt;/code&gt;&lt;/a&gt;) for empty collections, and enables clients to determine if such a spliterator covers no elements.</source>
          <target state="translated">如果分隔符不包含任何元素，则报告除 &lt;code&gt;SIZED&lt;/code&gt; 和 &lt;code&gt;SUBSIZED&lt;/code&gt; 之外的其他特征值，将无助于客户控制，专门化或简化计算。但是，这确实允许为空集合共享使用不可变且为空的spliterator实例（请参见&lt;a href=&quot;spliterators#emptySpliterator--&quot;&gt; &lt;code&gt;Spliterators.emptySpliterator()&lt;/code&gt; &lt;/a&gt;），并使客户端能够确定这样的splitter是否不包含任何元素。</target>
        </trans-unit>
        <trans-unit id="eceb3e8bdd7aa7928b72e084cf57d623f635838d" translate="yes" xml:space="preserve">
          <source>If a stream does contain tables, the tables given in a &lt;code&gt;JPEGImageReadParam&lt;/code&gt; are ignored. Furthermore, if the first image in a stream does contain tables and subsequent ones do not, then the tables given in the first image are used for all the abbreviated images. Once tables have been read from a stream, they can be overridden only by tables subsequently read from the same stream. In order to specify new tables, the &lt;a href=&quot;../../imagereader#setInput-java.lang.Object-boolean-boolean-&quot;&gt;&lt;code&gt;setInput&lt;/code&gt;&lt;/a&gt; method of the reader must be called to change the stream.</source>
          <target state="translated">如果流确实包含表，则 &lt;code&gt;JPEGImageReadParam&lt;/code&gt; 中给定的表将被忽略。此外，如果流中的第一张图像确实包含表，而后续的图像中不包含表，则将第一张图像中给定的表用于所有缩写图像。从流中读取表后，它们只能被随后从同一流中读取的表覆盖。为了指定新表，必须调用阅读器的&lt;a href=&quot;../../imagereader#setInput-java.lang.Object-boolean-boolean-&quot;&gt; &lt;code&gt;setInput&lt;/code&gt; &lt;/a&gt;方法来更改流。</target>
        </trans-unit>
        <trans-unit id="a2750feeb92c351bda0cd825237cf381d71b3604" translate="yes" xml:space="preserve">
          <source>If a stream is ordered, most operations are constrained to operate on the elements in their encounter order; if the source of a stream is a &lt;code&gt;List&lt;/code&gt; containing &lt;code&gt;[1, 2, 3]&lt;/code&gt;, then the result of executing &lt;code&gt;map(x -&amp;gt; x*2)&lt;/code&gt; must be &lt;code&gt;[2, 4, 6]&lt;/code&gt;. However, if the source has no defined encounter order, then any permutation of the values &lt;code&gt;[2, 4, 6]&lt;/code&gt; would be a valid result.</source>
          <target state="translated">如果对流进行了排序，则大多数操作将被约束为按其遇到顺序对元素进行操作；如果流的源是包含 &lt;code&gt;[1, 2, 3]&lt;/code&gt; 的 &lt;code&gt;List&lt;/code&gt; ，则执行 &lt;code&gt;map(x -&amp;gt; x*2)&lt;/code&gt; 必须为 &lt;code&gt;[2, 4, 6]&lt;/code&gt; 。但是，如果源没有定义的遇到顺序，则值 &lt;code&gt;[2, 4, 6]&lt;/code&gt; 任何排列都是有效的结果。</target>
        </trans-unit>
        <trans-unit id="ec3da9f5ed3a50caf2ebc15ff55bbd7387d78001" translate="yes" xml:space="preserve">
          <source>If a string quote character is encountered, then a string is recognized, consisting of all characters after (but not including) the string quote character, up to (but not including) the next occurrence of that same string quote character, or a line terminator, or end of file. The usual escape sequences such as &lt;code&gt;&quot;\n&quot;&lt;/code&gt; and &lt;code&gt;&quot;\t&quot;&lt;/code&gt; are recognized and converted to single characters as the string is parsed.</source>
          <target state="translated">如果遇到字符串引号字符，则将识别出一个字符串，该字符串由该字符串引号字符之后（但不包括）之后的所有字符，直至（但不包括）该相同的字符串引号字符的下一次出现或行终止符组成，或文件末尾。在解析字符串时，通常的转义序列（例如 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;\t&quot;&lt;/code&gt; 被识别并转换为单个字符。</target>
        </trans-unit>
        <trans-unit id="cee086fbf4e72f394e2cd369d7a1a31214c885ef" translate="yes" xml:space="preserve">
          <source>If a superinterface is a parameterized type, the &lt;code&gt;Type&lt;/code&gt; object returned for it must accurately reflect the actual type parameters used in the source code. The parameterized type representing each superinterface is created if it had not been created before. See the declaration of &lt;a href=&quot;reflect/parameterizedtype&quot;&gt;&lt;code&gt;ParameterizedType&lt;/code&gt;&lt;/a&gt; for the semantics of the creation process for parameterized types.</source>
          <target state="translated">如果超级接口是参数化类型，则为其返回的 &lt;code&gt;Type&lt;/code&gt; 对象必须准确反映源代码中使用的实际类型参数。如果尚未创建代表每个超级接口的参数化类型，则会创建该参数化类型。有关参数化类型的创建过程的语义，请参见&lt;a href=&quot;reflect/parameterizedtype&quot;&gt; &lt;code&gt;ParameterizedType&lt;/code&gt; &lt;/a&gt;的声明。</target>
        </trans-unit>
        <trans-unit id="1a6f96de5e57069f6d14d17aca38943e0fdc8ff7" translate="yes" xml:space="preserve">
          <source>If a thread does not lock any object monitor or &lt;code&gt;lockedMonitors&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, the returned &lt;code&gt;ThreadInfo&lt;/code&gt; object will have an empty &lt;code&gt;MonitorInfo&lt;/code&gt; array. Similarly, if a thread does not lock any synchronizer or &lt;code&gt;lockedSynchronizers&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, the returned &lt;code&gt;ThreadInfo&lt;/code&gt; object will have an empty &lt;code&gt;LockInfo&lt;/code&gt; array.</source>
          <target state="translated">如果线程没有锁定任何对象监视器，或者 &lt;code&gt;lockedMonitors&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; ，则返回的 &lt;code&gt;ThreadInfo&lt;/code&gt; 对象将具有一个空的 &lt;code&gt;MonitorInfo&lt;/code&gt; 数组。同样，如果线程不锁定任何同步器，或者 &lt;code&gt;lockedSynchronizers&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; ，则返回的 &lt;code&gt;ThreadInfo&lt;/code&gt; 对象将具有一个空的 &lt;code&gt;LockInfo&lt;/code&gt; 数组。</target>
        </trans-unit>
        <trans-unit id="423d67d62c33ea4b987acaba9861af6927d6c017" translate="yes" xml:space="preserve">
          <source>If a thread initiates the loading of the installed file system providers and another thread invokes a method that also attempts to load the providers then the method will block until the loading completes.</source>
          <target state="translated">如果一个线程发起加载已安装的文件系统提供者,而另一个线程调用的方法也试图加载提供者,那么该方法将阻塞,直到加载完成。</target>
        </trans-unit>
        <trans-unit id="c7ba95dc1b6c41c9659ab72fa979fc5c3b29d122" translate="yes" xml:space="preserve">
          <source>If a thread is &lt;a href=&quot;../../../lang/thread#interrupt--&quot;&gt;interrupted&lt;/a&gt; while waiting then the wait will terminate, an &lt;a href=&quot;../../../lang/interruptedexception&quot;&gt;&lt;code&gt;InterruptedException&lt;/code&gt;&lt;/a&gt; will be thrown, and the thread's interrupted status will be cleared.</source>
          <target state="translated">如果线程在等待时被&lt;a href=&quot;../../../lang/thread#interrupt--&quot;&gt;中断&lt;/a&gt;，则等待将终止，将抛出&lt;a href=&quot;../../../lang/interruptedexception&quot;&gt; &lt;code&gt;InterruptedException&lt;/code&gt; &lt;/a&gt;，并清除线程的中断状态。</target>
        </trans-unit>
        <trans-unit id="9af6babb2d89b7b1bcb5f61c939d4682bb0b8bf3" translate="yes" xml:space="preserve">
          <source>If a thread is blocked in an I/O operation on an interruptible channel then another thread may invoke the blocked thread's &lt;a href=&quot;../../lang/thread#interrupt--&quot;&gt;&lt;code&gt;interrupt&lt;/code&gt;&lt;/a&gt; method. This will cause the channel to be closed, the blocked thread to receive a &lt;a href=&quot;closedbyinterruptexception&quot;&gt;&lt;code&gt;ClosedByInterruptException&lt;/code&gt;&lt;/a&gt;, and the blocked thread's interrupt status to be set.</source>
          <target state="translated">如果一个线程在可中断通道的I / O操作中被阻塞，则另一个线程可以调用被阻塞线程的&lt;a href=&quot;../../lang/thread#interrupt--&quot;&gt; &lt;code&gt;interrupt&lt;/code&gt; &lt;/a&gt;方法。这将导致通道被关闭，阻塞线程将收到&lt;a href=&quot;closedbyinterruptexception&quot;&gt; &lt;code&gt;ClosedByInterruptException&lt;/code&gt; &lt;/a&gt;，并且阻塞线程的中断状态将被设置。</target>
        </trans-unit>
        <trans-unit id="fd99bc1eee5eed72f1e348ec811d11b7678f072e" translate="yes" xml:space="preserve">
          <source>If a thread is blocked in an I/O operation on an interruptible channel then another thread may invoke the channel's &lt;a href=&quot;interruptiblechannel#close--&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt; method. This will cause the blocked thread to receive an &lt;a href=&quot;asynchronouscloseexception&quot;&gt;&lt;code&gt;AsynchronousCloseException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果某个线程在可中断通道的I / O操作中被阻塞，则另一个线程可以调用该通道的&lt;a href=&quot;interruptiblechannel#close--&quot;&gt; &lt;code&gt;close&lt;/code&gt; &lt;/a&gt;方法。这将导致被阻塞的线程接收一个&lt;a href=&quot;asynchronouscloseexception&quot;&gt; &lt;code&gt;AsynchronousCloseException&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="da330aea3c98594d1083e77da98a318f71baeb0d" translate="yes" xml:space="preserve">
          <source>If a thread is currently blocked in one of this selector's selection methods then it is interrupted as if by invoking the selector's &lt;a href=&quot;selector#wakeup--&quot;&gt;&lt;code&gt;wakeup&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">如果线程当前在此选择器的选择方法之一中被阻止，则将其中断，就像调用选择器的&lt;a href=&quot;selector#wakeup--&quot;&gt; &lt;code&gt;wakeup&lt;/code&gt; &lt;/a&gt;方法一样。</target>
        </trans-unit>
        <trans-unit id="d5afbadf14eba91b88bef9af2e17ba1b04cf7b04" translate="yes" xml:space="preserve">
          <source>If a thread is currently blocked in the &lt;a href=&quot;watchservice#take--&quot;&gt;&lt;code&gt;take&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;watchservice#poll-long-java.util.concurrent.TimeUnit-&quot;&gt;&lt;code&gt;poll&lt;/code&gt;&lt;/a&gt; methods waiting for a key to be queued then it immediately receives a &lt;a href=&quot;closedwatchserviceexception&quot;&gt;&lt;code&gt;ClosedWatchServiceException&lt;/code&gt;&lt;/a&gt;. Any valid keys associated with this watch service are &lt;a href=&quot;watchkey#isValid--&quot;&gt;&lt;code&gt;invalidated&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果线程当前在&lt;a href=&quot;watchservice#take--&quot;&gt; &lt;code&gt;take&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;watchservice#poll-long-java.util.concurrent.TimeUnit-&quot;&gt; &lt;code&gt;poll&lt;/code&gt; &lt;/a&gt;方法中被阻塞，等待键排队，则它立即收到&lt;a href=&quot;closedwatchserviceexception&quot;&gt; &lt;code&gt;ClosedWatchServiceException&lt;/code&gt; &lt;/a&gt;。与该监视服务关联的所有有效密钥均&lt;a href=&quot;watchkey#isValid--&quot;&gt; &lt;code&gt;invalidated&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="79a80fec9ac0e51a906db8a969589f57b8d53771" translate="yes" xml:space="preserve">
          <source>If a thread of the given ID is not alive or does not exist, this method will return &lt;code&gt;null&lt;/code&gt;. A thread is alive if it has been started and has not yet died.</source>
          <target state="translated">如果给定ID的线程不存在或不存在，则此方法将返回 &lt;code&gt;null&lt;/code&gt; 。如果线程已经启动但尚未死亡，则该线程是活动的。</target>
        </trans-unit>
        <trans-unit id="c7367fdf45de9116c0531a4eb673c46e4df10f0d" translate="yes" xml:space="preserve">
          <source>If a thread's interrupt status is already set and it invokes a blocking I/O operation upon a channel then the channel will be closed and the thread will immediately receive a &lt;a href=&quot;closedbyinterruptexception&quot;&gt;&lt;code&gt;ClosedByInterruptException&lt;/code&gt;&lt;/a&gt;; its interrupt status will remain set.</source>
          <target state="translated">如果已经设置了线程的中断状态，并且在通道上调用了阻塞I / O操作，则该通道将关闭，线程将立即收到&lt;a href=&quot;closedbyinterruptexception&quot;&gt; &lt;code&gt;ClosedByInterruptException&lt;/code&gt; &lt;/a&gt;；其中断状态将保持不变。</target>
        </trans-unit>
        <trans-unit id="f20c8ec4cbcd889326c0ec36148d75b1de4b78c0" translate="yes" xml:space="preserve">
          <source>If a timeout is specified and the timeout elapses before the operation completes then it completes with the exception &lt;a href=&quot;interruptedbytimeoutexception&quot;&gt;&lt;code&gt;InterruptedByTimeoutException&lt;/code&gt;&lt;/a&gt;. Where a timeout occurs, and the implementation cannot guarantee that bytes have not been read, or will not be read from the channel into the given buffers, then further attempts to read from the channel will cause an unspecific runtime exception to be thrown.</source>
          <target state="translated">如果指定了超时并且在操作完成之前已经超时，则它会以&lt;a href=&quot;interruptedbytimeoutexception&quot;&gt; &lt;code&gt;InterruptedByTimeoutException&lt;/code&gt; &lt;/a&gt;异常完成。在发生超时的情况下，实现不能保证未读取字节，或无法将字节从通道读取到给定的缓冲区中，那么进一步尝试从通道读取将导致抛出不确定的运行时异常。</target>
        </trans-unit>
        <trans-unit id="085511ee4e6f8838601b8420555dabe5caf417db" translate="yes" xml:space="preserve">
          <source>If a timeout is specified and the timeout elapses before the operation completes then it completes with the exception &lt;a href=&quot;interruptedbytimeoutexception&quot;&gt;&lt;code&gt;InterruptedByTimeoutException&lt;/code&gt;&lt;/a&gt;. Where a timeout occurs, and the implementation cannot guarantee that bytes have not been written, or will not be written to the channel from the given buffer, then further attempts to write to the channel will cause an unspecific runtime exception to be thrown.</source>
          <target state="translated">如果指定了超时并且在操作完成之前已经超时，则它会以&lt;a href=&quot;interruptedbytimeoutexception&quot;&gt; &lt;code&gt;InterruptedByTimeoutException&lt;/code&gt; &lt;/a&gt;异常完成。在发生超时的情况下，实现不能保证尚未将字节写入或将不会从给定的缓冲区写入字节，则进一步尝试写入该通道将导致抛出不确定的运行时异常。</target>
        </trans-unit>
        <trans-unit id="d1e6a9ea34cc15cb7dc234bc610d3da7fd2fd1d7" translate="yes" xml:space="preserve">
          <source>If a timeout is specified and the timeout elapses before the operation completes then it completes with the exception &lt;a href=&quot;interruptedbytimeoutexception&quot;&gt;&lt;code&gt;InterruptedByTimeoutException&lt;/code&gt;&lt;/a&gt;. Where a timeout occurs, and the implementation cannot guarantee that bytes have not been written, or will not be written to the channel from the given buffers, then further attempts to write to the channel will cause an unspecific runtime exception to be thrown.</source>
          <target state="translated">如果指定了超时并且在操作完成之前已经超时，则它会以&lt;a href=&quot;interruptedbytimeoutexception&quot;&gt; &lt;code&gt;InterruptedByTimeoutException&lt;/code&gt; &lt;/a&gt;异常完成。在发生超时的情况下，实现不能保证尚未将字节写入或将不会从给定的缓冲区写入字节，则进一步尝试写入该通道将引发不确定的运行时异常。</target>
        </trans-unit>
        <trans-unit id="7aeea9b2c990269d554f71236286a06879279f31" translate="yes" xml:space="preserve">
          <source>If a timeout is specified and the timeout elapses before the operation completes then the operation completes with the exception &lt;a href=&quot;interruptedbytimeoutexception&quot;&gt;&lt;code&gt;InterruptedByTimeoutException&lt;/code&gt;&lt;/a&gt;. Where a timeout occurs, and the implementation cannot guarantee that bytes have not been read, or will not be read from the channel into the given buffer, then further attempts to read from the channel will cause an unspecific runtime exception to be thrown.</source>
          <target state="translated">如果指定了超时并且在操作完成之前已经超时，则操作将以&lt;a href=&quot;interruptedbytimeoutexception&quot;&gt; &lt;code&gt;InterruptedByTimeoutException&lt;/code&gt; &lt;/a&gt;异常完成。在发生超时的情况下，实现不能保证未读取字节，或无法将字节从通道读取到给定的缓冲区中，那么进一步尝试从通道读取将导致引发非特定的运行时异常。</target>
        </trans-unit>
        <trans-unit id="b059429e7b4fbc4030cc099662067f32b6c7ab30" translate="yes" xml:space="preserve">
          <source>If a type is annotated with this annotation type, compilers are required to generate an error message unless:</source>
          <target state="translated">如果一个类型被注解为这个注解类型,编译器就需要产生一个错误信息,除非:。</target>
        </trans-unit>
        <trans-unit id="860fe4e2923a6695add73192da6784b1d700c654" translate="yes" xml:space="preserve">
          <source>If a value is present in this &lt;code&gt;Optional&lt;/code&gt;, returns the value, otherwise throws &lt;code&gt;NoSuchElementException&lt;/code&gt;.</source>
          <target state="translated">如果此 &lt;code&gt;Optional&lt;/code&gt; 中存在值，则返回该值，否则抛出 &lt;code&gt;NoSuchElementException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ac19fb5ed0433a6a84bbf9870c3d0508394c1ec9" translate="yes" xml:space="preserve">
          <source>If a value is present in this &lt;code&gt;OptionalDouble&lt;/code&gt;, returns the value, otherwise throws &lt;code&gt;NoSuchElementException&lt;/code&gt;.</source>
          <target state="translated">如果此 &lt;code&gt;OptionalDouble&lt;/code&gt; 中存在值，则返回该值，否则抛出 &lt;code&gt;NoSuchElementException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="77f8284a88fc486cd8c49e73e5157ec4382cced0" translate="yes" xml:space="preserve">
          <source>If a value is present in this &lt;code&gt;OptionalInt&lt;/code&gt;, returns the value, otherwise throws &lt;code&gt;NoSuchElementException&lt;/code&gt;.</source>
          <target state="translated">如果此 &lt;code&gt;OptionalInt&lt;/code&gt; 中存在值，则返回该值，否则抛出 &lt;code&gt;NoSuchElementException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b442beaf0679fd03d92130f9d3a16dff8abc1a47" translate="yes" xml:space="preserve">
          <source>If a value is present in this &lt;code&gt;OptionalLong&lt;/code&gt;, returns the value, otherwise throws &lt;code&gt;NoSuchElementException&lt;/code&gt;.</source>
          <target state="translated">如果此 &lt;code&gt;OptionalLong&lt;/code&gt; 中存在值，则返回该值，否则抛出 &lt;code&gt;NoSuchElementException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d4e270a2bbe380815af7730e0b32eed7b9b310b0" translate="yes" xml:space="preserve">
          <source>If a value is present the result must include its string representation in the result. Empty and present Optionals must be unambiguously differentiable.</source>
          <target state="translated">如果一个值存在,结果中必须包括它的字符串表示。空的和存在的选项必须是可以明确区分的。</target>
        </trans-unit>
        <trans-unit id="53843db157010fe9437f6ec6848ceaa2431d68a8" translate="yes" xml:space="preserve">
          <source>If a value is present the result must include its string representation in the result. Empty and present instances must be unambiguously differentiable.</source>
          <target state="translated">如果一个值存在,结果中必须包括它的字符串表示。空和存在的实例必须是可以明确区分的。</target>
        </trans-unit>
        <trans-unit id="0706b2c7911a55318a829716b41ba2d3be31b10d" translate="yes" xml:space="preserve">
          <source>If a value is present, and the value matches the given predicate, return an &lt;code&gt;Optional&lt;/code&gt; describing the value, otherwise return an empty &lt;code&gt;Optional&lt;/code&gt;.</source>
          <target state="translated">如果存在一个值，并且该值与给定的谓词匹配，则返回描述该值的 &lt;code&gt;Optional&lt;/code&gt; ，否则返回一个空的 &lt;code&gt;Optional&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="891603f3a0de1e1f312f4666b625f9fb23d2e9c9" translate="yes" xml:space="preserve">
          <source>If a value is present, apply the provided &lt;code&gt;Optional&lt;/code&gt;-bearing mapping function to it, return that result, otherwise return an empty &lt;code&gt;Optional&lt;/code&gt;. This method is similar to &lt;a href=&quot;optional#map-java.util.function.Function-&quot;&gt;&lt;code&gt;map(Function)&lt;/code&gt;&lt;/a&gt;, but the provided mapper is one whose result is already an &lt;code&gt;Optional&lt;/code&gt;, and if invoked, &lt;code&gt;flatMap&lt;/code&gt; does not wrap it with an additional &lt;code&gt;Optional&lt;/code&gt;.</source>
          <target state="translated">如果存在一个值，则对它应用提供的 &lt;code&gt;Optional&lt;/code&gt; -bearing映射函数，返回该结果，否则返回一个空的 &lt;code&gt;Optional&lt;/code&gt; 。此方法类似于&lt;a href=&quot;optional#map-java.util.function.Function-&quot;&gt; &lt;code&gt;map(Function)&lt;/code&gt; &lt;/a&gt;，但是提供的映射器是其结果已经是 &lt;code&gt;Optional&lt;/code&gt; 的映射器，并且如果被调用， &lt;code&gt;flatMap&lt;/code&gt; 不会使用附加的 &lt;code&gt;Optional&lt;/code&gt; 对其进行包装。</target>
        </trans-unit>
        <trans-unit id="a8b5560d2bb98c2edc06f003311054df22294d95" translate="yes" xml:space="preserve">
          <source>If a value is present, apply the provided mapping function to it, and if the result is non-null, return an &lt;code&gt;Optional&lt;/code&gt; describing the result. Otherwise return an empty &lt;code&gt;Optional&lt;/code&gt;.</source>
          <target state="translated">如果存在值，则将提供的映射函数应用于该值，如果结果为非null，则返回描述结果的 &lt;code&gt;Optional&lt;/code&gt; 。否则，返回一个空的 &lt;code&gt;Optional&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fad40f63b1a2a9bdb013e89c0f84f329771e8703" translate="yes" xml:space="preserve">
          <source>If a value is present, invoke the specified consumer with the value, otherwise do nothing.</source>
          <target state="translated">如果有值,则用该值调用指定的消费者,否则什么也不做。</target>
        </trans-unit>
        <trans-unit id="92cb4d374f2fe9448ca335ac55aeaabe71a1f569" translate="yes" xml:space="preserve">
          <source>If a visitor returns a result of &lt;code&gt;null&lt;/code&gt; then &lt;code&gt;NullPointerException&lt;/code&gt; is thrown.</source>
          <target state="translated">如果访问者返回的结果为 &lt;code&gt;null&lt;/code&gt; ,则抛出 &lt;code&gt;NullPointerException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5e01b98873a0cadbbe64c47b2b726716a54e9964" translate="yes" xml:space="preserve">
          <source>If a watched file is not located on a local storage device then it is implementation specific if changes to the file can be detected. In particular, it is not required that changes to files carried out on remote systems be detected.</source>
          <target state="translated">如果一个被监视的文件不在本地存储设备上,那么是否能检测到文件的变化是具体实施的。特别是,不要求检测到对远程系统上的文件进行的更改。</target>
        </trans-unit>
        <trans-unit id="bee200d444da7e51810a8f81ba5dffe16cc316fc" translate="yes" xml:space="preserve">
          <source>If addr specifies an IPv4 address an instance of Inet4Address will be returned; otherwise, an instance of Inet6Address will be returned.</source>
          <target state="translated">如果addr指定了一个IPv4地址,将返回一个Inet4Address的实例;否则,将返回一个Inet6Address的实例。</target>
        </trans-unit>
        <trans-unit id="923186511eab92209b32f15d3fb01aaacb2e442c" translate="yes" xml:space="preserve">
          <source>If adjacent parsing is active, then parsing must match exactly the specified number of digits in both strict and lenient modes. In addition, no positive or negative sign is permitted.</source>
          <target state="translated">如果相邻解析是主动的,那么在严格和宽松模式下,解析必须完全匹配指定的数字。此外,不允许使用正号或负号。</target>
        </trans-unit>
        <trans-unit id="f8c6c1fd23bed92157c4876b59e8a94de5ba0fe9" translate="yes" xml:space="preserve">
          <source>If all of the keys in the key set at the start of this step have empty interest sets then neither the selected-key set nor any of the keys' ready-operation sets will be updated.</source>
          <target state="translated">如果本步骤开始时钥匙集中的所有钥匙都有空的兴趣集,那么选定的钥匙集和任何钥匙的准备操作集都不会被更新。</target>
        </trans-unit>
        <trans-unit id="478f44b721763a191efa4a005ca8cf8c23dac1b2" translate="yes" xml:space="preserve">
          <source>If all the date objects being compared are in the same chronology, then the additional chronology stage is not required and only the local date is used. To compare the dates of two &lt;code&gt;TemporalAccessor&lt;/code&gt; instances, including dates in two different chronologies, use &lt;a href=&quot;../temporal/chronofield#EPOCH_DAY&quot;&gt;&lt;code&gt;ChronoField.EPOCH_DAY&lt;/code&gt;&lt;/a&gt; as a comparator.</source>
          <target state="translated">如果所有要比较的日期对象都在相同的时间顺序中，则不需要附加的时间顺序阶段，而仅使用本地日期。若要比较两个 &lt;code&gt;TemporalAccessor&lt;/code&gt; 实例的日期，包括两个不同时间的日期，请使用&lt;a href=&quot;../temporal/chronofield#EPOCH_DAY&quot;&gt; &lt;code&gt;ChronoField.EPOCH_DAY&lt;/code&gt; &lt;/a&gt;作为比较器。</target>
        </trans-unit>
        <trans-unit id="920032b96bedf78cb11745b4b01ea2b9da62f86c" translate="yes" xml:space="preserve">
          <source>If all the date-time objects being compared are in the same chronology, then the additional chronology stage is not required and only the local date-time is used.</source>
          <target state="translated">如果所有被比较的日期-时间对象都在同一个年表中,那么就不需要额外的年表阶段,只使用本地的日期-时间。</target>
        </trans-unit>
        <trans-unit id="91e24b45b1050248e3d9b0f32a1bfe41649a4f37" translate="yes" xml:space="preserve">
          <source>If all the date-time objects being compared are in the same chronology, then the additional chronology stage is not required.</source>
          <target state="translated">如果所有被比较的日期-时间对象都在同一年表中,那么就不需要额外的年表阶段。</target>
        </trans-unit>
        <trans-unit id="7af80a78ccebdf694054065e68649e1c92533dff" translate="yes" xml:space="preserve">
          <source>If all the date-times being compared are instances of &lt;code&gt;LocalDateTime&lt;/code&gt;, then the comparison will be entirely based on the date-time. If some dates being compared are in different chronologies, then the chronology is also considered, see &lt;a href=&quot;chrono/chronolocaldatetime#compareTo-java.time.chrono.ChronoLocalDateTime-&quot;&gt;&lt;code&gt;ChronoLocalDateTime.compareTo(java.time.chrono.ChronoLocalDateTime&amp;lt;?&amp;gt;)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果所有要比较的日期时间都是 &lt;code&gt;LocalDateTime&lt;/code&gt; 的实例，则比较将完全基于日期时间。如果要比较的某些日期位于不同的时间顺序中，则还考虑该时间顺序，请参见&lt;a href=&quot;chrono/chronolocaldatetime#compareTo-java.time.chrono.ChronoLocalDateTime-&quot;&gt; &lt;code&gt;ChronoLocalDateTime.compareTo(java.time.chrono.ChronoLocalDateTime&amp;lt;?&amp;gt;)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c70daeec02ec422b3471ddc6193b4b37b8cb8342" translate="yes" xml:space="preserve">
          <source>If all the dates being compared are instances of &lt;code&gt;LocalDate&lt;/code&gt;, then the comparison will be entirely based on the date. If some dates being compared are in different chronologies, then the chronology is also considered, see &lt;a href=&quot;chrono/chronolocaldate#compareTo-java.time.chrono.ChronoLocalDate-&quot;&gt;&lt;code&gt;ChronoLocalDate.compareTo(java.time.chrono.ChronoLocalDate)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果所有要比较的日期都是 &lt;code&gt;LocalDate&lt;/code&gt; 的实例，则比较将完全基于日期。如果要比较的某些日期位于不同的时间顺序中，则也考虑该时间顺序，请参见&lt;a href=&quot;chrono/chronolocaldate#compareTo-java.time.chrono.ChronoLocalDate-&quot;&gt; &lt;code&gt;ChronoLocalDate.compareTo(java.time.chrono.ChronoLocalDate)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="95938a0cd815321f6453791f7f4283d94220e212" translate="yes" xml:space="preserve">
          <source>If all the docs have the same binding specified, then any value of &lt;a href=&quot;multipledocumenthandling&quot;&gt;&lt;code&gt;MultipleDocumentHandling&lt;/code&gt;&lt;/a&gt; makes sense, and the printer's processing depends on the &lt;a href=&quot;multipledocumenthandling&quot;&gt;&lt;code&gt;MultipleDocumentHandling&lt;/code&gt;&lt;/a&gt; value:</source>
          <target state="translated">如果所有文档都指定了相同的绑定，则&lt;a href=&quot;multipledocumenthandling&quot;&gt; &lt;code&gt;MultipleDocumentHandling&lt;/code&gt; 的&lt;/a&gt;任何值都有意义，并且打印机的处理取决于&lt;a href=&quot;multipledocumenthandling&quot;&gt; &lt;code&gt;MultipleDocumentHandling&lt;/code&gt; 的&lt;/a&gt;值：</target>
        </trans-unit>
        <trans-unit id="7869c5e4ed330a875f3cd70b80530f1cdf968256" translate="yes" xml:space="preserve">
          <source>If all the docs have the same number up value</source>
          <target state="translated">如果所有的文档都有相同的向上数值</target>
        </trans-unit>
        <trans-unit id="323feabb33d09245620f68d33109a728cd260051" translate="yes" xml:space="preserve">
          <source>If all the docs have the same page ranges specified, then any value of &lt;a href=&quot;multipledocumenthandling&quot;&gt;&lt;code&gt;MultipleDocumentHandling&lt;/code&gt;&lt;/a&gt; makes sense, and the printer's processing depends on the &lt;a href=&quot;multipledocumenthandling&quot;&gt;&lt;code&gt;MultipleDocumentHandling&lt;/code&gt;&lt;/a&gt; value:</source>
          <target state="translated">如果所有文档都指定了相同的页面范围，则&lt;a href=&quot;multipledocumenthandling&quot;&gt; &lt;code&gt;MultipleDocumentHandling&lt;/code&gt; 的&lt;/a&gt;任何值都有意义，并且打印机的处理取决于&lt;a href=&quot;multipledocumenthandling&quot;&gt; &lt;code&gt;MultipleDocumentHandling&lt;/code&gt; 的&lt;/a&gt;值：</target>
        </trans-unit>
        <trans-unit id="43de23ce23841ef0c6a6fa16c30e0adac32dff5f" translate="yes" xml:space="preserve">
          <source>If all the docs have the same sheet collation specified, then the following combinations of SheetCollate and &lt;a href=&quot;multipledocumenthandling&quot;&gt;&lt;code&gt;MultipleDocumentHandling&lt;/code&gt;&lt;/a&gt; are permitted, and the printer reports an error when the job is submitted if any other combination is specified:</source>
          <target state="translated">如果所有文档都指定了相同的工作表排序规则，则允许以下SheetCollat​​e和&lt;a href=&quot;multipledocumenthandling&quot;&gt; &lt;code&gt;MultipleDocumentHandling&lt;/code&gt; &lt;/a&gt;组合，并且如果指定了任何其他组合，则打印机在提交作业时报告错误：</target>
        </trans-unit>
        <trans-unit id="53f4aefa8b3b18b801db7105e517f135c3160808" translate="yes" xml:space="preserve">
          <source>If all the docs have the same sides value</source>
          <target state="translated">如果所有的文档都具有相同的边值</target>
        </trans-unit>
        <trans-unit id="4098503fbcb241fe10627044b2064dc72f141550" translate="yes" xml:space="preserve">
          <source>If an &lt;a href=&quot;../../io/ioexception&quot;&gt;&lt;code&gt;IOException&lt;/code&gt;&lt;/a&gt; is thrown when accessing the directory after returned from this method, it is wrapped in an &lt;a href=&quot;../../io/uncheckedioexception&quot;&gt;&lt;code&gt;UncheckedIOException&lt;/code&gt;&lt;/a&gt; which will be thrown from the method that caused the access to take place.</source>
          <target state="translated">从此方法返回后，如果在访问目录时抛出&lt;a href=&quot;../../io/ioexception&quot;&gt; &lt;code&gt;IOException&lt;/code&gt; &lt;/a&gt;，则它将包装在&lt;a href=&quot;../../io/uncheckedioexception&quot;&gt; &lt;code&gt;UncheckedIOException&lt;/code&gt; 中&lt;/a&gt;，该异常将由导致访问发生的方法抛出。</target>
        </trans-unit>
        <trans-unit id="088dd2d19f784625275b483d3f0f4f2ddbb175e3" translate="yes" xml:space="preserve">
          <source>If an &lt;a href=&quot;../../io/ioexception&quot;&gt;&lt;code&gt;IOException&lt;/code&gt;&lt;/a&gt; is thrown when accessing the directory after this method has returned, it is wrapped in an &lt;a href=&quot;../../io/uncheckedioexception&quot;&gt;&lt;code&gt;UncheckedIOException&lt;/code&gt;&lt;/a&gt; which will be thrown from the method that caused the access to take place.</source>
          <target state="translated">如果在返回此方法后访问目录时抛出&lt;a href=&quot;../../io/ioexception&quot;&gt; &lt;code&gt;IOException&lt;/code&gt; &lt;/a&gt;，则将其包装在&lt;a href=&quot;../../io/uncheckedioexception&quot;&gt; &lt;code&gt;UncheckedIOException&lt;/code&gt; 中&lt;/a&gt;，该异常将从导致访问发生的方法中抛出。</target>
        </trans-unit>
        <trans-unit id="448273579cd0c1573f50adb27cc551f6240ac792" translate="yes" xml:space="preserve">
          <source>If an &lt;a href=&quot;datetimeformatter#parsedExcessDays--&quot;&gt;excess number of days&lt;/a&gt; was parsed then it is added to the date if a date is available.</source>
          <target state="translated">如果解析了&lt;a href=&quot;datetimeformatter#parsedExcessDays--&quot;&gt;过多的天数，&lt;/a&gt;则在有可用日期的情况下将其添加到日期中。</target>
        </trans-unit>
        <trans-unit id="f440d6e16437287ae444b44920a0eee99c549130" translate="yes" xml:space="preserve">
          <source>If an &lt;a href=&quot;ioexception&quot;&gt;&lt;code&gt;IOException&lt;/code&gt;&lt;/a&gt; is thrown when accessing the underlying &lt;code&gt;BufferedReader&lt;/code&gt;, it is wrapped in an &lt;a href=&quot;uncheckedioexception&quot;&gt;&lt;code&gt;UncheckedIOException&lt;/code&gt;&lt;/a&gt; which will be thrown from the &lt;code&gt;Stream&lt;/code&gt; method that caused the read to take place. This method will return a Stream if invoked on a BufferedReader that is closed. Any operation on that stream that requires reading from the BufferedReader after it is closed, will cause an UncheckedIOException to be thrown.</source>
          <target state="translated">如果在访问基础 &lt;code&gt;BufferedReader&lt;/code&gt; 时抛出&lt;a href=&quot;ioexception&quot;&gt; &lt;code&gt;IOException&lt;/code&gt; &lt;/a&gt;，则它将包装在&lt;a href=&quot;uncheckedioexception&quot;&gt; &lt;code&gt;UncheckedIOException&lt;/code&gt; 中&lt;/a&gt;，该异常将从导致读取发生的 &lt;code&gt;Stream&lt;/code&gt; 方法中抛出。如果在已关闭的BufferedReader上调用，则此方法将返回Stream。该流上需要在关闭后从BufferedReader中读取的任何操作，都将引发UncheckedIOException。</target>
        </trans-unit>
        <trans-unit id="959df27348a054da287e538a4f7d1a74313d32f5" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;@Target&lt;/code&gt; meta-annotation is not present on an annotation type &lt;code&gt;T&lt;/code&gt; , then an annotation of type &lt;code&gt;T&lt;/code&gt; may be written as a modifier for any declaration except a type parameter declaration.</source>
          <target state="translated">如果在注释类型 &lt;code&gt;T&lt;/code&gt; 上不存在 &lt;code&gt;@Target&lt;/code&gt; 元注释，则可以将类型 &lt;code&gt;T&lt;/code&gt; 的注释写为除类型参数声明之外的任何声明的修饰符。</target>
        </trans-unit>
        <trans-unit id="8371b963c2b6f04360837c6404d40bc176c92b9b" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;@Target&lt;/code&gt; meta-annotation is present, the compiler will enforce the usage restrictions indicated by &lt;code&gt;ElementType&lt;/code&gt; enum constants, in line with JLS 9.7.4.</source>
          <target state="translated">如果存在 &lt;code&gt;@Target&lt;/code&gt; 元注释，则编译器将强制执行 &lt;code&gt;ElementType&lt;/code&gt; 枚举常量指示的使用限制，以符合JLS 9.7.4的要求。</target>
        </trans-unit>
        <trans-unit id="9496a4d3cf27eda519ac141e2a00e405156b6ffb" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;IOException&lt;/code&gt; is not thrown, then the stream is reset to a fixed state that depends on the particular type of the input stream and how it was created. The bytes that will be supplied to subsequent callers of the &lt;code&gt;read&lt;/code&gt; method depend on the particular type of the input stream.</source>
          <target state="translated">如果未抛出 &lt;code&gt;IOException&lt;/code&gt; ，则将流重置为固定状态，具体取决于输入流的特定类型及其创建方式。将提供给 &lt;code&gt;read&lt;/code&gt; 方法的后续调用者的字节取决于输入流的特定类型。</target>
        </trans-unit>
        <trans-unit id="6de50cf0b5b005c73f2b22f23092356cfbc265a6" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;Object&lt;/code&gt; reference was previously allowed, the previous settings are overwritten.</source>
          <target state="translated">如果以前允许 &lt;code&gt;Object&lt;/code&gt; 引用，则先前的设置将被覆盖。</target>
        </trans-unit>
        <trans-unit id="ce889769df21717dff5602aeddeab9f3a68fa96a" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;RMIServerImpl&lt;/code&gt; was supplied to the constructor, it is used.</source>
          <target state="translated">如果将 &lt;code&gt;RMIServerImpl&lt;/code&gt; 提供给构造函数，则使用它。</target>
        </trans-unit>
        <trans-unit id="c147456e60cfbfb343d2b171d44a03397a71498d" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;optionType&lt;/code&gt; was specified to this &lt;code&gt;ConfirmationCallback&lt;/code&gt;, this option may be specified as a &lt;code&gt;defaultOption&lt;/code&gt; or returned as the selected index.</source>
          <target state="translated">如果为该 &lt;code&gt;ConfirmationCallback&lt;/code&gt; 指定了 &lt;code&gt;optionType&lt;/code&gt; ，则该选项可以指定为 &lt;code&gt;defaultOption&lt;/code&gt; 或作为所选索引返回。</target>
        </trans-unit>
        <trans-unit id="bddc19f4e2a7499584504adbd2e120339e8a9d2c" translate="yes" xml:space="preserve">
          <source>If an ACL entry contains a &lt;a href=&quot;aclentry#principal--&quot;&gt;&lt;code&gt;user-principal&lt;/code&gt;&lt;/a&gt; that is not associated with the same provider as this attribute view then &lt;a href=&quot;../providermismatchexception&quot;&gt;&lt;code&gt;ProviderMismatchException&lt;/code&gt;&lt;/a&gt; is thrown. Additional validation, if any, is implementation dependent.</source>
          <target state="translated">如果ACL条目包含与该属性视图未与同一提供者关联的&lt;a href=&quot;aclentry#principal--&quot;&gt; &lt;code&gt;user-principal&lt;/code&gt; &lt;/a&gt;，则将抛出&lt;a href=&quot;../providermismatchexception&quot;&gt; &lt;code&gt;ProviderMismatchException&lt;/code&gt; &lt;/a&gt;。其他验证（如果有）取决于实现。</target>
        </trans-unit>
        <trans-unit id="6e691cd0ee7a41eeed3186a97648a8370581048b" translate="yes" xml:space="preserve">
          <source>If an I/O error is encountered when accessing the directory then it causes the &lt;code&gt;Iterator&lt;/code&gt;'s &lt;code&gt;hasNext&lt;/code&gt; or &lt;code&gt;next&lt;/code&gt; methods to throw &lt;a href=&quot;directoryiteratorexception&quot;&gt;&lt;code&gt;DirectoryIteratorException&lt;/code&gt;&lt;/a&gt; with the &lt;a href=&quot;../../io/ioexception&quot;&gt;&lt;code&gt;IOException&lt;/code&gt;&lt;/a&gt; as the cause. As stated above, the &lt;code&gt;hasNext&lt;/code&gt; method is guaranteed to read-ahead by at least one element. This means that if &lt;code&gt;hasNext&lt;/code&gt; method returns &lt;code&gt;true&lt;/code&gt;, and is followed by a call to the &lt;code&gt;next&lt;/code&gt; method, then it is guaranteed that the &lt;code&gt;next&lt;/code&gt; method will not fail with a &lt;code&gt;DirectoryIteratorException&lt;/code&gt;.</source>
          <target state="translated">如果访问目录时遇到I / O错误，那么它会导致 &lt;code&gt;Iterator&lt;/code&gt; 的 &lt;code&gt;hasNext&lt;/code&gt; 或 &lt;code&gt;next&lt;/code&gt; 方法抛出&lt;a href=&quot;directoryiteratorexception&quot;&gt; &lt;code&gt;DirectoryIteratorException&lt;/code&gt; &lt;/a&gt;与&lt;a href=&quot;../../io/ioexception&quot;&gt; &lt;code&gt;IOException&lt;/code&gt; 异常&lt;/a&gt;的原因。如上所述，保证 &lt;code&gt;hasNext&lt;/code&gt; 方法至少要预读一个元素。这意味着，如果 &lt;code&gt;hasNext&lt;/code&gt; 方法返回 &lt;code&gt;true&lt;/code&gt; ，并随后调用 &lt;code&gt;next&lt;/code&gt; 方法，则可以确保 &lt;code&gt;next&lt;/code&gt; 方法不会因 &lt;code&gt;DirectoryIteratorException&lt;/code&gt; 而失败。</target>
        </trans-unit>
        <trans-unit id="feeedb640cf4499009e04bb26412c9322b88b5ad" translate="yes" xml:space="preserve">
          <source>If an I/O error occurs reading from the file or writing to the output stream, then it may do so after some bytes have been read or written. Consequently the output stream may be in an inconsistent state. It is strongly recommended that the output stream be promptly closed if an I/O error occurs.</source>
          <target state="translated">如果从文件读取或向输出流写入发生I/O错误,那么它可能在读取或写入一些字节后才发生。因此,输出流可能处于不一致的状态。强烈建议在发生I/O错误时,立即关闭输出流。</target>
        </trans-unit>
        <trans-unit id="9c872125a1307797d25e4f9f64998713cf5ca5f3" translate="yes" xml:space="preserve">
          <source>If an I/O error occurs reading from the input stream or writing to the file, then it may do so after the target file has been created and after some bytes have been read or written. Consequently the input stream may not be at end of stream and may be in an inconsistent state. It is strongly recommended that the input stream be promptly closed if an I/O error occurs.</source>
          <target state="translated">如果从输入流读取或向文件写入时发生I/O错误,那么可能是在目标文件创建后,在一些字节被读取或写入后发生的。因此,输入流可能不在流的末端,可能处于不一致的状态。强烈建议,如果发生I/O错误,应及时关闭输入流。</target>
        </trans-unit>
        <trans-unit id="190c966c8992a3839001e7e1af1d2b89e9457c04" translate="yes" xml:space="preserve">
          <source>If an InitialContextFactoryBuilder has been installed, it is used to create the factory for creating the initial context. Otherwise, the class specified in the &lt;code&gt;Context.INITIAL_CONTEXT_FACTORY&lt;/code&gt; environment property is used. Note that an initial context factory (an object that implements the InitialContextFactory interface) must be public and must have a public constructor that accepts no arguments.</source>
          <target state="translated">如果已安装InitialContextFactoryBuilder，它将用于创建用于创建初始上下文的工厂。否则，将使用 &lt;code&gt;Context.INITIAL_CONTEXT_FACTORY&lt;/code&gt; 环境属性中指定的类。请注意，初始上下文工厂（实现InitialContextFactory接口的对象）必须是公共的，并且必须具有不接受任何参数的公共构造函数。</target>
        </trans-unit>
        <trans-unit id="98657208ee304eaeabe25e126ff14f176c167883" translate="yes" xml:space="preserve">
          <source>If an MBean implements the interface &lt;a href=&quot;privateclassloader&quot;&gt;&lt;code&gt;PrivateClassLoader&lt;/code&gt;&lt;/a&gt;, then it is not added to the class loader repository. The class &lt;a href=&quot;privatemlet&quot;&gt;&lt;code&gt;PrivateMLet&lt;/code&gt;&lt;/a&gt; is a subclass of &lt;code&gt;MLet&lt;/code&gt; that implements &lt;code&gt;PrivateClassLoader&lt;/code&gt;.</source>
          <target state="translated">如果MBean实现接口&lt;a href=&quot;privateclassloader&quot;&gt; &lt;code&gt;PrivateClassLoader&lt;/code&gt; &lt;/a&gt;，则不会将其添加到类加载器存储库中。类&lt;a href=&quot;privatemlet&quot;&gt; &lt;code&gt;PrivateMLet&lt;/code&gt; &lt;/a&gt;是实现 &lt;code&gt;PrivateClassLoader&lt;/code&gt; 的 &lt;code&gt;MLet&lt;/code&gt; 的子类。</target>
        </trans-unit>
        <trans-unit id="f7dbdf0d0215e39ffb9e056dc435071a7e3d1afd" translate="yes" xml:space="preserve">
          <source>If an ObjectName is not a pattern, it must contain at least one key with its associated value.</source>
          <target state="translated">如果一个ObjectName不是一个模式,那么它必须至少包含一个键及其相关的值。</target>
        </trans-unit>
        <trans-unit id="e0bc3775989ff9a0fa2129381bf0e75ba0c93374" translate="yes" xml:space="preserve">
          <source>If an RMI connector client or server receives from its peer an instance of a class that it does not know, and if dynamic code downloading is active for the RMI connection, then the class can be downloaded from a codebase specified by the peer. The article &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/rmi/codebase.html&quot;&gt;&lt;em&gt;Dynamic code downloading using Java RMI&lt;/em&gt;&lt;/a&gt; explains this in more detail.</source>
          <target state="translated">如果RMI连接器客户端或服务器从其对等方接收到它不知道的类的实例，并且如果RMI连接的动态代码下载处于活动状态，则可以从对等方指定的代码库中下载该类。&lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/rmi/codebase.html&quot;&gt;&lt;em&gt;使用Java RMI动态下载代码一&lt;/em&gt;&lt;/a&gt;文对此进行了详细说明。</target>
        </trans-unit>
        <trans-unit id="9c4c5268bcffbf9c0c5b98ecb4ed28911043818e" translate="yes" xml:space="preserve">
          <source>If an annotation of type</source>
          <target state="translated">如果一个类型为</target>
        </trans-unit>
        <trans-unit id="9df83510632408ed0d5232c4209c863ed75fc2b2" translate="yes" xml:space="preserve">
          <source>If an annotation returned by a method in this interface contains (directly or indirectly) a &lt;a href=&quot;../class&quot;&gt;&lt;code&gt;Class&lt;/code&gt;&lt;/a&gt;-valued member referring to a class that is not accessible in this VM, attempting to read the class by calling the relevant Class-returning method on the returned annotation will result in a &lt;a href=&quot;../typenotpresentexception&quot;&gt;&lt;code&gt;TypeNotPresentException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果此接口中方法返回的注释包含（直接或间接）引用该VM中不可访问的类的&lt;a href=&quot;../class&quot;&gt; &lt;code&gt;Class&lt;/code&gt; &lt;/a&gt;值成员，请尝试通过对返回的注释调用相关的Class-returning方法来读取该类将导致&lt;a href=&quot;../typenotpresentexception&quot;&gt; &lt;code&gt;TypeNotPresentException&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0227ca62999d931b56d6f6658a6e345f41f26f21" translate="yes" xml:space="preserve">
          <source>If an annotation type</source>
          <target state="translated">如果一个注解类型</target>
        </trans-unit>
        <trans-unit id="ed99bca3e6f592b88e87557055d253e0c0b22f1a" translate="yes" xml:space="preserve">
          <source>If an application caches method handles for broad sharing, it should use &lt;code&gt;publicLookup()&lt;/code&gt; to create them. If there is a lookup of &lt;code&gt;Class.forName&lt;/code&gt;, it will fail, and the application must take appropriate action in that case. It may be that a later lookup, perhaps during the invocation of a bootstrap method, can incorporate the specific identity of the caller, making the method accessible.</source>
          <target state="translated">如果应用程序缓存方法句柄进行广泛共享，则应使用 &lt;code&gt;publicLookup()&lt;/code&gt; 创建它们。如果查找 &lt;code&gt;Class.forName&lt;/code&gt; ，它将失败，并且在这种情况下，应用程序必须采取适当的措施。可能是以后的查找（可能在引导方法调用期间）可以包含调用者的特定身份，从而使方法可访问。</target>
        </trans-unit>
        <trans-unit id="0dbacd8fdd96aa697bee57950998d0a96108abc1" translate="yes" xml:space="preserve">
          <source>If an application or a system is internationalized and provides localized resources for multiple locales, it sometimes needs to find one or more locales (or language tags) which meet each user's specific preferences. Note that a term &quot;language tag&quot; is used interchangeably with &quot;locale&quot; in this locale matching documentation.</source>
          <target state="translated">如果一个应用程序或系统是国际化的,并为多个地区提供本地化资源,它有时需要找到一个或多个符合每个用户特定偏好的地区语言(或语言标签)。请注意,在本语言匹配文档中,术语 &quot;语言标签 &quot;与 &quot;locale &quot;可互换使用。</target>
        </trans-unit>
        <trans-unit id="f6d7860179acd56276c79c3590549cb4c6e64204" translate="yes" xml:space="preserve">
          <source>If an argument index is used for more than one format element in the pattern string, then the corresponding new format is used for all such format elements. If an argument index is not used for any format element in the pattern string, then the corresponding new format is ignored. If fewer formats are provided than needed, then only the formats for argument indices less than &lt;code&gt;newFormats.length&lt;/code&gt; are replaced.</source>
          <target state="translated">如果自变量索引用于模式字符串中的多个格式元素，则将相应的新格式用于所有此类格式元素。如果参数字符串未用于模式字符串中的任何格式元素，则将忽略相应的新格式。如果提供的格式少于需要的格式，则仅替换参数索引小于 &lt;code&gt;newFormats.length&lt;/code&gt; 的格式。</target>
        </trans-unit>
        <trans-unit id="1f72387046823cf7698e1a0b6d176b89054ec4a7" translate="yes" xml:space="preserve">
          <source>If an argument index is used for more than one format element in the pattern string, then the format used for the last such format element is returned in the array. If an argument index is not used for any format element in the pattern string, then null is returned in the array.</source>
          <target state="translated">如果一个参数索引被用于模式字符串中的一个以上的格式元素,那么数组中返回最后一个这样的格式元素所使用的格式,如果一个参数索引没有被用于模式字符串中的任何格式元素,那么数组中返回null。如果一个参数索引没有用于模式字符串中的任何格式元素,那么数组中返回null。</target>
        </trans-unit>
        <trans-unit id="bd454c7aa8c21821eb903a4d4d4438d54e9d0c75" translate="yes" xml:space="preserve">
          <source>If an attribute class extends &lt;code&gt;EnumSyntax&lt;/code&gt;, and the value of the attribute is an IPP-compatible value, the attribute's &lt;code&gt;toString&lt;/code&gt; method returns the IPP string representation of the attribute value, such as &quot;processing-stopped&quot; for the &lt;a href=&quot;jobstate&quot;&gt;JobState&lt;/a&gt; attribute. However, because the &lt;code&gt;EnumSyntax&lt;/code&gt; class is extensible, vendors can define their own attribute values. If an attribute uses the &lt;code&gt;EnumSyntax&lt;/code&gt; class and is set to one of these vendor-defined values then the &lt;code&gt;toString&lt;/code&gt; method will not return the IPP string representation of the value.</source>
          <target state="translated">如果属性类扩展了 &lt;code&gt;EnumSyntax&lt;/code&gt; ，并且该属性的值是IPP兼容的值，则该属性的 &lt;code&gt;toString&lt;/code&gt; 方法返回该属性值的IPP字符串表示形式，例如&lt;a href=&quot;jobstate&quot;&gt;JobState&lt;/a&gt;属性的&amp;ldquo; processing-stopped&amp;rdquo; 。但是，由于 &lt;code&gt;EnumSyntax&lt;/code&gt; 类是可扩展的，因此供应商可以定义自己的属性值。如果属性使用 &lt;code&gt;EnumSyntax&lt;/code&gt; 类并且设置为这些供应商定义的值之一，则 &lt;code&gt;toString&lt;/code&gt; 方法将不会返回该值的IPP字符串表示形式。</target>
        </trans-unit>
        <trans-unit id="a2271d961817d69ed166f3999b4fca55a2a3bfd1" translate="yes" xml:space="preserve">
          <source>If an attribute implements &lt;a href=&quot;docattribute&quot;&gt;&lt;code&gt;DocAttribute&lt;/code&gt;&lt;/a&gt; as well as PrintRequestAttribute, the client may include the attribute in a &lt;code&gt;Doc&lt;/code&gt;}'s attribute set to specify a job setting which pertains just to that doc.</source>
          <target state="translated">如果属性&lt;a href=&quot;docattribute&quot;&gt; &lt;code&gt;DocAttribute&lt;/code&gt; &lt;/a&gt;实现DocAttribute又实现PrintRequestAttribute，则客户端可以将该属性包括在 &lt;code&gt;Doc&lt;/code&gt; }的属性集中，以指定仅与该文档相关的作业设置。</target>
        </trans-unit>
        <trans-unit id="8553a6030a41f0e392620a86588d848a2d5646af" translate="yes" xml:space="preserve">
          <source>If an attribute of the given name already exists then its value is replaced. If the attribute does not exist then it is created. If it implementation specific if a test to check for the existence of the attribute and the creation of attribute are atomic with respect to other file system activities.</source>
          <target state="translated">如果给定名称的属性已经存在,则替换其值。如果属性不存在,则创建它。如果检查属性是否存在的测试和属性的创建相对于其他文件系统活动来说是原子的,那么它就是特定的实现。</target>
        </trans-unit>
        <trans-unit id="27440a763ede5ab8ba752691c8d7cfa12b2cc574" translate="yes" xml:space="preserve">
          <source>If an authority is given then the string &lt;code&gt;&quot;//&quot;&lt;/code&gt; is appended, followed by the authority. If the authority contains a literal IPv6 address then the address must be enclosed in square brackets (&lt;code&gt;'['&lt;/code&gt; and &lt;code&gt;']'&lt;/code&gt;). Any character not in the</source>
          <target state="translated">如果给出了授权，则字符串 &lt;code&gt;&quot;//&quot;&lt;/code&gt; 被附加，后面是授权。如果授权机构包含原义的IPv6地址，则该地址必须括在方括号（ &lt;code&gt;'['&lt;/code&gt; 和 &lt;code&gt;']'&lt;/code&gt; ）中。不在的任何字符</target>
        </trans-unit>
        <trans-unit id="30c03b38fd51437f34d169d8c1845e0f976cba81" translate="yes" xml:space="preserve">
          <source>If an element &lt;code&gt;e&lt;/code&gt; is an array of a primitive type, it is converted to a string as by invoking the appropriate overloading of &lt;code&gt;Arrays.toString(e)&lt;/code&gt;. If an element &lt;code&gt;e&lt;/code&gt; is an array of a reference type, it is converted to a string as by invoking this method recursively.</source>
          <target state="translated">如果元素 &lt;code&gt;e&lt;/code&gt; 是原始类型的数组，则通过调用 &lt;code&gt;Arrays.toString(e)&lt;/code&gt; 的适当重载将其转换为字符串。如果元素 &lt;code&gt;e&lt;/code&gt; 是引用类型的数组，则通过递归调用此方法将其转换为字符串。</target>
        </trans-unit>
        <trans-unit id="261e54ff065700a24467a3b37a05bc35f1bc1e0e" translate="yes" xml:space="preserve">
          <source>If an entry already exists for the specified alias, it is overridden.</source>
          <target state="translated">如果指定的别名已经存在一个条目,则会被覆盖。</target>
        </trans-unit>
        <trans-unit id="fd9f14cb55aec7f7c0b7e951ed92525cdc983689" translate="yes" xml:space="preserve">
          <source>If an error occurs during the initial handshake, this method returns an invalid session object which reports an invalid cipher suite of &quot;SSL_NULL_WITH_NULL_NULL&quot;.</source>
          <target state="translated">如果在初始握手过程中发生错误,该方法返回一个无效的会话对象,该对象报告一个无效的密码套件 &quot;SSL_NULL_WITH_NULL_NULL&quot;。</target>
        </trans-unit>
        <trans-unit id="1773b2b10f572a15df1a83f51dfc4260cdf90a56" translate="yes" xml:space="preserve">
          <source>If an error occurs then the SSL socket is closed and an IOException is thrown. The underlying connection remains intact.</source>
          <target state="translated">如果发生错误,那么SSL套接字就会被关闭,并抛出一个IOException。底层连接保持完整。</target>
        </trans-unit>
        <trans-unit id="0469e2eb38e10c985523abc8d2b5541786c72d7d" translate="yes" xml:space="preserve">
          <source>If an exception is thrown during an enumeration, the enumeration becomes invalid. Subsequent invocation of any method on that enumeration will yield undefined results.</source>
          <target state="translated">如果在枚举过程中抛出异常,那么这个枚举就会失效。随后对该枚举的任何方法的调用将产生未定义的结果。</target>
        </trans-unit>
        <trans-unit id="4edf72f63744ff4e52753a8efa7493d7a0576ed0" translate="yes" xml:space="preserve">
          <source>If an exception type is a type variable or a parameterized type, it is created. Otherwise, it is resolved.</source>
          <target state="translated">如果异常类型是类型变量或参数化类型,则会被创建。否则,它将被解析。</target>
        </trans-unit>
        <trans-unit id="daaa77166dccaba4fc56b68f0c67338ce9025815" translate="yes" xml:space="preserve">
          <source>If an existing &lt;code&gt;Processor&lt;/code&gt; object is not being used, to create an instance of a processor the tool calls the no-arg constructor of the processor class.</source>
          <target state="translated">如果未使用现有的 &lt;code&gt;Processor&lt;/code&gt; 对象，则该工具将调用处理器类的no-arg构造函数以创建处理器的实例。</target>
        </trans-unit>
        <trans-unit id="7d315c92816e5851e4dc9c39278030e06b4e20d6" translate="yes" xml:space="preserve">
          <source>If an implementation does not support schemas, it should throw OperationNotSupportedException. If an implementation does support schemas, it should define this method to return the appropriate information.</source>
          <target state="translated">如果一个实现不支持模式,它应该抛出OperationNotSupportedException。如果一个实现确实支持模式,它应该定义这个方法来返回相应的信息。</target>
        </trans-unit>
        <trans-unit id="c4c73fde229aaf78d628130cf2dc942c93b26494" translate="yes" xml:space="preserve">
          <source>If an implementation has not been specified with the system property, then the system-default implementation class is instantiated, and the result is returned.</source>
          <target state="translated">如果没有用system属性指定实现,则实例化系统默认的实现类,并返回结果。</target>
        </trans-unit>
        <trans-unit id="043b26dca2264b1abb0bfae84593fcda3d702603" translate="yes" xml:space="preserve">
          <source>If an implementation represents a field that can be simplified, or combined with others, then this method must be implemented.</source>
          <target state="translated">如果一个实现代表了一个可以简化的字段,或者与其他字段组合,那么这个方法必须被实现。</target>
        </trans-unit>
        <trans-unit id="3b30c559fc9c71304701a7f40146dfcf10b6d44b" translate="yes" xml:space="preserve">
          <source>If an object factory builder has been installed, it is used to create a factory for creating the object. Otherwise, the following rules are used to create the object:</source>
          <target state="translated">如果已经安装了对象工厂构建器,则使用它来创建工厂以创建对象。否则,将使用以下规则来创建对象。</target>
        </trans-unit>
        <trans-unit id="2b3be881430739dc065ccc4b9432e347d8bc309f" translate="yes" xml:space="preserve">
          <source>If an override is added, then any date that is formatted or parsed will be affected.</source>
          <target state="translated">如果添加了覆盖,那么任何被格式化或解析的日期都会受到影响。</target>
        </trans-unit>
        <trans-unit id="255c469340eb5e4421672d0f2a54c086d1b3a334" translate="yes" xml:space="preserve">
          <source>If an override is added, then any instant that is formatted or parsed will be affected.</source>
          <target state="translated">如果添加了覆盖,那么任何被格式化或解析的瞬间都会受到影响。</target>
        </trans-unit>
        <trans-unit id="0fbebb5dc8d306792468bfb85d5fadc68fc9bcac" translate="yes" xml:space="preserve">
          <source>If an underlying &lt;code&gt;TimeZone&lt;/code&gt; implementation subclass supports historical GMT offset changes, the method returns the raw offset value of the current date. In Honolulu, for example, its raw offset changed from GMT-10:30 to GMT-10:00 in 1947, and this method always returns -36000000 milliseconds (i.e., -10 hours).</source>
          <target state="translated">如果基础的 &lt;code&gt;TimeZone&lt;/code&gt; 实现子类支持历史GMT偏移量更改，则该方法返回当前日期的原始偏移量值。例如，在檀香山，其原始偏移量在1947年从GMT-10：30更改为GMT-10：00，并且此方法始终返回-36000000毫秒（即-10小时）。</target>
        </trans-unit>
        <trans-unit id="3a926ad586a71b3f84679e24d71e358a0ff83b65" translate="yes" xml:space="preserve">
          <source>If an underlying &lt;code&gt;TimeZone&lt;/code&gt; implementation subclass supports historical GMT offset changes, the specified GMT offset is set as the latest GMT offset and the difference from the known latest GMT offset value is used to adjust all historical GMT offset values.</source>
          <target state="translated">如果基础的 &lt;code&gt;TimeZone&lt;/code&gt; 实现子类支持历史GMT偏移更改，则将指定的GMT偏移设置为最新GMT偏移，并将与已知最新GMT偏移值的差用于调整所有历史GMT偏移值。</target>
        </trans-unit>
        <trans-unit id="e0ae28c236839ff6f2827de1f4455a2f8e23e12d" translate="yes" xml:space="preserve">
          <source>If an underlying &lt;code&gt;TimeZone&lt;/code&gt; implementation subclass supports historical and future Daylight Saving Time schedule changes, this method refers to the last known Daylight Saving Time rule that can be a future prediction and may not be the same as the current rule. Consider calling &lt;a href=&quot;timezone#observesDaylightTime--&quot;&gt;&lt;code&gt;observesDaylightTime()&lt;/code&gt;&lt;/a&gt; if the current rule should also be taken into account.</source>
          <target state="translated">如果基础的 &lt;code&gt;TimeZone&lt;/code&gt; 实现子类支持历史和将来的夏时制时间表更改，则此方法引用最后一个已知的夏时制规则，该规则可以作为将来的预测，并且可能与当前规则不同。如果还应考虑当前规则，请考虑调用&lt;a href=&quot;timezone#observesDaylightTime--&quot;&gt; &lt;code&gt;observesDaylightTime()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ceae883a33c038a59aa9297cd34719c700a68dfa" translate="yes" xml:space="preserve">
          <source>If an underlying &lt;code&gt;TimeZone&lt;/code&gt; implementation subclass supports historical and future Daylight Saving Time schedule changes, this method returns the amount of saving time of the last known Daylight Saving Time rule that can be a future prediction.</source>
          <target state="translated">如果基础的 &lt;code&gt;TimeZone&lt;/code&gt; 实现子类支持历史和将来的夏时制时间表更改，则此方法将返回最近的已知夏时制规则的保存时间量，该规则可以作为将来的预测。</target>
        </trans-unit>
        <trans-unit id="e6cdcb6abb3fe6a57aabba3c4945a777923f2bd3" translate="yes" xml:space="preserve">
          <source>If another thread is already waiting at the exchange point then it is resumed for thread scheduling purposes and receives the object passed in by the current thread. The current thread returns immediately, receiving the object passed to the exchange by that other thread.</source>
          <target state="translated">如果另一个线程已经在交换点等待,那么为了线程调度的目的,它将被恢复,并接收当前线程传递进来的对象。当前线程立即返回,接收该另一线程传递给交换点的对象。</target>
        </trans-unit>
        <trans-unit id="55a602e52f31c6fce149aff8e6c8a2bb72960c45" translate="yes" xml:space="preserve">
          <source>If another thread is currently blocked in an invocation of the &lt;a href=&quot;selector#select--&quot;&gt;&lt;code&gt;select()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;selector#select-long-&quot;&gt;&lt;code&gt;select(long)&lt;/code&gt;&lt;/a&gt; methods then that invocation will return immediately. If no selection operation is currently in progress then the next invocation of one of these methods will return immediately unless the &lt;a href=&quot;selector#selectNow--&quot;&gt;&lt;code&gt;selectNow()&lt;/code&gt;&lt;/a&gt; method is invoked in the meantime. In any case the value returned by that invocation may be non-zero. Subsequent invocations of the &lt;a href=&quot;selector#select--&quot;&gt;&lt;code&gt;select()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;selector#select-long-&quot;&gt;&lt;code&gt;select(long)&lt;/code&gt;&lt;/a&gt; methods will block as usual unless this method is invoked again in the meantime.</source>
          <target state="translated">如果在调用&lt;a href=&quot;selector#select--&quot;&gt; &lt;code&gt;select()&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;selector#select-long-&quot;&gt; &lt;code&gt;select(long)&lt;/code&gt; &lt;/a&gt;方法时当前阻止了另一个线程，则该调用将立即返回。如果当前没有正在进行选择操作，则除非同时调用&lt;a href=&quot;selector#selectNow--&quot;&gt; &lt;code&gt;selectNow()&lt;/code&gt; &lt;/a&gt;方法，否则将立即返回这些方法之一的下一次调用。在任何情况下，该调用返回的值都可以为非零。&lt;a href=&quot;selector#select--&quot;&gt; &lt;code&gt;select()&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;selector#select-long-&quot;&gt; &lt;code&gt;select(long)&lt;/code&gt; &lt;/a&gt;方法的后续调用将照常阻塞，除非在此期间再次调用此方法。</target>
        </trans-unit>
        <trans-unit id="8b8c2ef8a9bb952f18badf3b5ecafae0a465fefa" translate="yes" xml:space="preserve">
          <source>If any attributes are unsupported only because they are in conflict with other attributes then it is at the discretion of the service to select the attribute(s) to be identified as the cause of the conflict.</source>
          <target state="translated">如果任何属性仅仅因为与其他属性冲突而不被支持,那么服务将自行选择被确定为冲突原因的属性。</target>
        </trans-unit>
        <trans-unit id="4ebc8985caafe276614f95fc78ffd3e5249f1603" translate="yes" xml:space="preserve">
          <source>If any bits of a particular byte have never been set at the time the byte is flushed to the destination, those bits will be set to 0 automatically.</source>
          <target state="translated">如果一个特定字节的任何位在字节被刷新到目的地时从未被设置,这些位将被自动设置为0。</target>
        </trans-unit>
        <trans-unit id="702be5b9ebfbe3a5f1d1aa77356733e4327d5c79" translate="yes" xml:space="preserve">
          <source>If any keys were added to the cancelled-key set while step (2) was in progress then they are processed as in step (1).</source>
          <target state="translated">如果在步骤(2)进行时,有任何钥匙被添加到取消的钥匙组中,那么它们的处理与步骤(1)一样。</target>
        </trans-unit>
        <trans-unit id="51f61f6cbbe9d425e171c7d86f0b2ee40a25ba9f" translate="yes" xml:space="preserve">
          <source>If any of the &lt;code&gt;lastModifiedTime&lt;/code&gt;, &lt;code&gt;lastAccessTime&lt;/code&gt;, or &lt;code&gt;createTime&lt;/code&gt; parameters has the value &lt;code&gt;null&lt;/code&gt; then the corresponding timestamp is not changed. An implementation may require to read the existing values of the file attributes when only some, but not all, of the timestamp attributes are updated. Consequently, this method may not be an atomic operation with respect to other file system operations. Reading and re-writing existing values may also result in precision loss. If all of the &lt;code&gt;lastModifiedTime&lt;/code&gt;, &lt;code&gt;lastAccessTime&lt;/code&gt; and &lt;code&gt;createTime&lt;/code&gt; parameters are &lt;code&gt;null&lt;/code&gt; then this method has no effect.</source>
          <target state="translated">如果 &lt;code&gt;lastModifiedTime&lt;/code&gt; ， &lt;code&gt;lastAccessTime&lt;/code&gt; 或 &lt;code&gt;createTime&lt;/code&gt; 参数中的任何一个的值为 &lt;code&gt;null&lt;/code&gt; ,则不会更改相应的时间戳。当仅更新一些而非全部时间戳属性时，实现可能需要读取文件属性的现有值。因此，相对于其他文件系统操作，此方法可能不是原子操作。读取和重写现有值也可能导致精度损失。如果所有 &lt;code&gt;lastModifiedTime&lt;/code&gt; ， &lt;code&gt;lastAccessTime&lt;/code&gt; 和 &lt;code&gt;createTime&lt;/code&gt; 参数均为 &lt;code&gt;null&lt;/code&gt; ,则此方法无效。</target>
        </trans-unit>
        <trans-unit id="e8c0135add7c8b60bb88502e1753b104e3e7777d" translate="yes" xml:space="preserve">
          <source>If any of the CA certificates contain the &lt;code&gt;BasicConstraintsExtension&lt;/code&gt;, the value of the &lt;code&gt;pathLenConstraint&lt;/code&gt; field of the extension overrides the maximum path length parameter whenever the result is a certification path of smaller length.</source>
          <target state="translated">如果任何CA证书都包含 &lt;code&gt;BasicConstraintsExtension&lt;/code&gt; ，则扩展结果的 &lt;code&gt;pathLenConstraint&lt;/code&gt; 字段的值将覆盖最大路径长度参数，只要结果是较小长度的认证路径。</target>
        </trans-unit>
        <trans-unit id="3ec333633e17c9be083cec2c06b962a41326b457" translate="yes" xml:space="preserve">
          <source>If any of the supplied &lt;code&gt;ImageReadParam&lt;/code&gt;s contain optional setting values not supported by this reader (</source>
          <target state="translated">如果提供的 &lt;code&gt;ImageReadParam&lt;/code&gt; 中的任何一个包含此阅读器不支持的可选设置值（</target>
        </trans-unit>
        <trans-unit id="21a8f6cbf8da0180ca327e40df0d37c1951e9068" translate="yes" xml:space="preserve">
          <source>If any of these restrictions are violated, &lt;code&gt;Proxy.getProxyClass&lt;/code&gt; will throw an &lt;code&gt;IllegalArgumentException&lt;/code&gt;. If the &lt;code&gt;interfaces&lt;/code&gt; array argument or any of its elements are &lt;code&gt;null&lt;/code&gt;, a &lt;code&gt;NullPointerException&lt;/code&gt; will be thrown.</source>
          <target state="translated">如果违反任何这些限制，则 &lt;code&gt;Proxy.getProxyClass&lt;/code&gt; 将抛出 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 。如果 &lt;code&gt;interfaces&lt;/code&gt; 数组参数或其任何元素为 &lt;code&gt;null&lt;/code&gt; ，则将引发 &lt;code&gt;NullPointerException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ff3b12e4e909401d37518b8a3b2f0f268050f07d" translate="yes" xml:space="preserve">
          <source>If any one of the given (name, filter) pairs cannot be registered, then the operation fails with an exception, and no names or filters are registered.</source>
          <target state="translated">如果任何一个给定的(名称、过滤器)对不能被注册,那么这个操作就会以异常的方式失败,并且没有注册任何名称或过滤器。</target>
        </trans-unit>
        <trans-unit id="c41f89efd65d6831c5b78321674605fbf8e57d9a" translate="yes" xml:space="preserve">
          <source>If any stream element is a NaN or the sum is at any point a NaN then the sum will be NaN. The value of a floating-point sum is a function both of the input values as well as the order of addition operations. The order of addition operations of this method is intentionally not defined to allow for implementation flexibility to improve the speed and accuracy of the computed result. In particular, this method may be implemented using compensated summation or other technique to reduce the error bound in the numerical sum compared to a simple summation of &lt;code&gt;double&lt;/code&gt; values.</source>
          <target state="translated">如果任何流元素是NaN或总和在任何时候都是NaN，则总和将是NaN。浮点和的值是输入值以及加法运算顺序的函数。故意不定义此方法的加法运算顺序，以允许实现灵活性以提高计算结果的速度和准确性。特别地，与 &lt;code&gt;double&lt;/code&gt; 值的简单求和相比，可以使用补偿求和或其他技术来实现该方法，以减少数值和中的误差范围。</target>
        </trans-unit>
        <trans-unit id="0366cecb1a7ed3c3842ffb9c2ca86a1363dd9a67" translate="yes" xml:space="preserve">
          <source>If any thread is &lt;a href=&quot;../../lang/thread#interrupt--&quot;&gt;interrupted&lt;/a&gt; while waiting, then all other waiting threads will throw &lt;a href=&quot;brokenbarrierexception&quot;&gt;&lt;code&gt;BrokenBarrierException&lt;/code&gt;&lt;/a&gt; and the barrier is placed in the broken state.</source>
          <target state="translated">如果任何线程在等待时被&lt;a href=&quot;../../lang/thread#interrupt--&quot;&gt;中断&lt;/a&gt;，则所有其他等待线程将抛出&lt;a href=&quot;brokenbarrierexception&quot;&gt; &lt;code&gt;BrokenBarrierException&lt;/code&gt; &lt;/a&gt;，并且屏障处于断开状态。</target>
        </trans-unit>
        <trans-unit id="4afdb9645427c72b2b449dab0d6dc64d70f5f7ed" translate="yes" xml:space="preserve">
          <source>If any threads are waiting on this condition then one is selected for waking up. That thread must then re-acquire the lock before returning from &lt;code&gt;await&lt;/code&gt;.</source>
          <target state="translated">如果有任何线程在这种情况下等待，则选择一个线程进行唤醒。然后，该线程必须在从 &lt;code&gt;await&lt;/code&gt; 返回之前重新获取锁。</target>
        </trans-unit>
        <trans-unit id="9c78a7fa649adbc90dbb23129fc74d5e1c06006a" translate="yes" xml:space="preserve">
          <source>If any threads are waiting on this condition then they are all woken up. Each thread must re-acquire the lock before it can return from &lt;code&gt;await&lt;/code&gt;.</source>
          <target state="translated">如果有任何线程在这种情况下等待，那么它们都将被唤醒。每个线程必须重新获取锁，然后才能从 &lt;code&gt;await&lt;/code&gt; 返回。</target>
        </trans-unit>
        <trans-unit id="47fbfc22f0224fd32a90e5910c55321028c1907f" translate="yes" xml:space="preserve">
          <source>If attribute already exists, replaces all existing values with new specified values. If the attribute does not exist, creates it. If no value is specified, deletes all the values of the attribute. Removal of the last value will remove the attribute if the attribute is required to have at least one value. If attempting to add more than one value to a single-valued attribute, throws &lt;code&gt;InvalidAttributeValueException&lt;/code&gt;.</source>
          <target state="translated">如果属性已经存在，请使用新的指定值替换所有现有值。如果属性不存在，请创建它。如果未指定任何值，则删除该属性的所有值。如果要求属性至少具有一个值，则删除最后一个值将删除该属性。如果尝试向单值属性添加多个值，则抛出 &lt;code&gt;InvalidAttributeValueException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a71ec53a572d41f56b8978727aaa4319a3583553" translate="yes" xml:space="preserve">
          <source>If attribute does not exist, create the attribute. The resulting attribute has a union of the specified value set and the prior value set. Adding an attribute with no value will throw &lt;code&gt;InvalidAttributeValueException&lt;/code&gt; if the attribute must have at least one value. For a single-valued attribute where that attribute already exists, throws &lt;code&gt;AttributeInUseException&lt;/code&gt;. If attempting to add more than one value to a single-valued attribute, throws &lt;code&gt;InvalidAttributeValueException&lt;/code&gt;.</source>
          <target state="translated">如果属性不存在，请创建属性。结果属性具有指定值集和先前值集的并集。如果该属性必须至少具有一个值，则添加没有值的属性将引发 &lt;code&gt;InvalidAttributeValueException&lt;/code&gt; 。对于已经存在该属性的单值属性，抛出 &lt;code&gt;AttributeInUseException&lt;/code&gt; 。如果尝试向单值属性添加多个值，则抛出 &lt;code&gt;InvalidAttributeValueException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3989b3dfcf79c0772b368fc99263d6921c534321" translate="yes" xml:space="preserve">
          <source>If authentication is successful then an authenticated &lt;a href=&quot;../../security/auth/subject&quot;&gt;&lt;code&gt;subject&lt;/code&gt;&lt;/a&gt; filled in with its associated &lt;a href=&quot;../../../java/security/principal&quot;&gt;&lt;code&gt;principals&lt;/code&gt;&lt;/a&gt; is returned. Authorization checks will be then performed based on the given set of principals.</source>
          <target state="translated">如果身份验证成功，则返回一个已填充其相关&lt;a href=&quot;../../../java/security/principal&quot;&gt; &lt;code&gt;principals&lt;/code&gt; &lt;/a&gt;已身份验证&lt;a href=&quot;../../security/auth/subject&quot;&gt; &lt;code&gt;subject&lt;/code&gt; &lt;/a&gt;。然后将基于给定的主体集执行授权检查。</target>
        </trans-unit>
        <trans-unit id="384a750120cc655c818a55ff4a92437e6d8b5336" translate="yes" xml:space="preserve">
          <source>If automatic redirection is enabled, and this request is redirected to another destination, then the caller must also have permission to connect to the redirected host/URL.</source>
          <target state="translated">如果启用了自动重定向,并且这个请求被重定向到另一个目的地,那么呼叫者也必须有权限连接到重定向的主机/URL。</target>
        </trans-unit>
        <trans-unit id="214c67c3b5c1b48a5612e6002691988064bf0ec4" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;Path&lt;/code&gt; objects are &lt;a href=&quot;path#equals-java.lang.Object-&quot;&gt;&lt;code&gt;equal&lt;/code&gt;&lt;/a&gt; then this method returns &lt;code&gt;true&lt;/code&gt; without checking if the file exists. If the two &lt;code&gt;Path&lt;/code&gt; objects are associated with different providers then this method returns &lt;code&gt;false&lt;/code&gt;. Otherwise, this method checks if both &lt;code&gt;Path&lt;/code&gt; objects locate the same file, and depending on the implementation, may require to open or access both files.</source>
          <target state="translated">如果两个 &lt;code&gt;Path&lt;/code&gt; 对象&lt;a href=&quot;path#equals-java.lang.Object-&quot;&gt; &lt;code&gt;equal&lt;/code&gt; &lt;/a&gt;则此方法返回 &lt;code&gt;true&lt;/code&gt; ,而不检查文件是否存在。如果两个 &lt;code&gt;Path&lt;/code&gt; 对象与不同的提供程序关联，则此方法返回 &lt;code&gt;false&lt;/code&gt; 。否则，此方法将检查两个 &lt;code&gt;Path&lt;/code&gt; 对象是否都找到同一文件，并且取决于实现方式，可能需要打开或访问这两个文件。</target>
        </trans-unit>
        <trans-unit id="df4547af366065ff735c348a2ae9741324e8b7ac" translate="yes" xml:space="preserve">
          <source>If both arguments are integers, then the result is exactly equal to the mathematical result of raising the first argument to the power of the second argument if that result can in fact be represented exactly as a &lt;code&gt;double&lt;/code&gt; value.</source>
          <target state="translated">如果两个参数都是整数，则结果实际上等于将第一个参数提高为第二个参数的幂的数学结果，如果该结果实际上可以精确地表示为 &lt;code&gt;double&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="9e16fe4a0bb9164db40801221f5bd4724181b86e" translate="yes" xml:space="preserve">
          <source>If both arguments are negative infinity, then the result is the &lt;code&gt;double&lt;/code&gt; value closest to -3*</source>
          <target state="translated">如果两个参数均为负无穷大，则结果为最接近-3 * 的 &lt;code&gt;double&lt;/code&gt; 值</target>
        </trans-unit>
        <trans-unit id="bfd7882093d9bf21c1a62a7634c6a186d1b60176" translate="yes" xml:space="preserve">
          <source>If both arguments are positive infinity, then the result is the &lt;code&gt;double&lt;/code&gt; value closest to</source>
          <target state="translated">如果两个参数都是正无穷大，那么结果是 &lt;code&gt;double&lt;/code&gt; 最接近值</target>
        </trans-unit>
        <trans-unit id="fc50ec0abca10e371c02173b94982f3dab4ec295" translate="yes" xml:space="preserve">
          <source>If both arguments are signed zeros, &lt;code&gt;direction&lt;/code&gt; is returned unchanged (as implied by the requirement of returning the second argument if the arguments compare as equal).</source>
          <target state="translated">如果两个参数的符号都为零，则返回的 &lt;code&gt;direction&lt;/code&gt; 不变（这意味着如果参数比较相等，则返回第二个参数的要求）。</target>
        </trans-unit>
        <trans-unit id="1ae942765abc7210f5202cbe952dc04cbb521ee9" translate="yes" xml:space="preserve">
          <source>If both arguments are signed zeros, a value equivalent to &lt;code&gt;direction&lt;/code&gt; is returned.</source>
          <target state="translated">如果两个参数的符号都为零，则返回等于 &lt;code&gt;direction&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="70f5cab03df99b6ce504b587920dfb5e98d8aa1e" translate="yes" xml:space="preserve">
          <source>If both authority components are server-based then the URIs are ordered according to their user-information components; if these components are identical then the URIs are ordered according to the ordering of their hosts, without regard to case; if the hosts are identical then the URIs are ordered according to the ordering of their ports.</source>
          <target state="translated">如果两个权限组件都是基于服务器的,那么URI就按照它们的用户信息组件排序;如果这些组件相同,那么URI就按照它们的主机排序,不考虑大小写;如果主机相同,那么URI就按照它们的端口排序。</target>
        </trans-unit>
        <trans-unit id="35daff90f12a3fdfb2ee7aaec5156a628122493a" translate="yes" xml:space="preserve">
          <source>If both the &lt;code&gt;'+'&lt;/code&gt; and &lt;code&gt;' '&lt;/code&gt; flags are given then an &lt;a href=&quot;illegalformatflagsexception&quot;&gt;&lt;code&gt;IllegalFormatFlagsException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">如果同时给出了 &lt;code&gt;'+'&lt;/code&gt; 和 &lt;code&gt;' '&lt;/code&gt; 标志，则将抛出&lt;a href=&quot;illegalformatflagsexception&quot;&gt; &lt;code&gt;IllegalFormatFlagsException&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="86fead13194ade589a2825bc28cba12789046f04" translate="yes" xml:space="preserve">
          <source>If both the &lt;code&gt;'-'&lt;/code&gt; and &lt;code&gt;'0'&lt;/code&gt; flags are given then an &lt;a href=&quot;illegalformatflagsexception&quot;&gt;&lt;code&gt;IllegalFormatFlagsException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">如果同时给出了 &lt;code&gt;'-'&lt;/code&gt; 和 &lt;code&gt;'0'&lt;/code&gt; 标志，则将抛出&lt;a href=&quot;illegalformatflagsexception&quot;&gt; &lt;code&gt;IllegalFormatFlagsException&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="37322522f6007d5f007c17ebbe89695f06d7d158" translate="yes" xml:space="preserve">
          <source>If both the PrincipalClass and &quot;PrincipalName&quot; are &quot;*&quot;, then access is granted to the specified Credential owned by any &lt;code&gt;Subject&lt;/code&gt;.</source>
          <target state="translated">如果PrincipalClass和&amp;ldquo; PrincipalName&amp;rdquo;均为&amp;ldquo; *&amp;rdquo;，则将授予对任何 &lt;code&gt;Subject&lt;/code&gt; 所拥有的指定凭据的访问权限。</target>
        </trans-unit>
        <trans-unit id="7f1f59b1990a9778560b4bab37a8896d7e2ca6a4" translate="yes" xml:space="preserve">
          <source>If both the language and country fields are missing, this function will return the empty string, even if the variant, script, or extensions field is present (you can't have a locale with just a variant, the variant must accompany a well-formed language or country code).</source>
          <target state="translated">如果语言和国家字段都缺失,这个函数将返回空字符串,即使变体、脚本或扩展字段存在(你不能只用一个变体就有一个locale,变体必须伴随着一个完善的语言或国家代码)。</target>
        </trans-unit>
        <trans-unit id="f17a471a0efa20dccdfd9df73789528ef03ee4cd" translate="yes" xml:space="preserve">
          <source>If called by a ForkJoinTask operating in this pool, equivalent in effect to &lt;a href=&quot;forkjointask#helpQuiesce--&quot;&gt;&lt;code&gt;ForkJoinTask.helpQuiesce()&lt;/code&gt;&lt;/a&gt;. Otherwise, waits and/or attempts to assist performing tasks until this pool &lt;a href=&quot;forkjoinpool#isQuiescent--&quot;&gt;&lt;code&gt;isQuiescent()&lt;/code&gt;&lt;/a&gt; or the indicated timeout elapses.</source>
          <target state="translated">如果由在此池中运行的ForkJoinTask调用，则等效于&lt;a href=&quot;forkjointask#helpQuiesce--&quot;&gt; &lt;code&gt;ForkJoinTask.helpQuiesce()&lt;/code&gt; &lt;/a&gt;。否则，等待和/或尝试协助执行任务，直到此池为&lt;a href=&quot;forkjoinpool#isQuiescent--&quot;&gt; &lt;code&gt;isQuiescent()&lt;/code&gt; &lt;/a&gt;或指示的超时时间过去。</target>
        </trans-unit>
        <trans-unit id="5c8be13a39c3ce6b65d510654f24b14ebdee6bb3" translate="yes" xml:space="preserve">
          <source>If called on a connection that sets the same header multiple times with possibly different values, only the last value is returned.</source>
          <target state="translated">如果在一个连接上多次调用同一个头,并且可能有不同的值,那么只返回最后一个值。</target>
        </trans-unit>
        <trans-unit id="c482125ee1539de1724656d21516fd3060b7e464" translate="yes" xml:space="preserve">
          <source>If cipher suites have been set via &lt;code&gt;setEnabledCipherSuites&lt;/code&gt; then they are enabled before the TLS handshake begins.</source>
          <target state="translated">如果已通过 &lt;code&gt;setEnabledCipherSuites&lt;/code&gt; 设置了密码套件，则在TLS握手开始之前将其启用。</target>
        </trans-unit>
        <trans-unit id="aa5def33651e6193aa37639feee2e1bacd4151be" translate="yes" xml:space="preserve">
          <source>If closing a client connection produces an exception, that exception is not thrown from this method. A &lt;a href=&quot;../jmxconnectionnotification&quot;&gt;&lt;code&gt;JMXConnectionNotification&lt;/code&gt;&lt;/a&gt; is emitted from this MBean with the connection ID of the connection that could not be closed.</source>
          <target state="translated">如果关闭客户端连接会产生异常，则不会从此方法引发该异常。甲&lt;a href=&quot;../jmxconnectionnotification&quot;&gt; &lt;code&gt;JMXConnectionNotification&lt;/code&gt; 中&lt;/a&gt;从该MBean发出与该不能被关闭的连接的连接ID。</target>
        </trans-unit>
        <trans-unit id="239b3d190809a5bb14183b924e8a7fef0e270a8a" translate="yes" xml:space="preserve">
          <source>If closing a client connection produces an exception, that exception is not thrown from this method. A &lt;a href=&quot;jmxconnectionnotification&quot;&gt;&lt;code&gt;JMXConnectionNotification&lt;/code&gt;&lt;/a&gt; with type &lt;a href=&quot;jmxconnectionnotification#FAILED&quot;&gt;&lt;code&gt;JMXConnectionNotification.FAILED&lt;/code&gt;&lt;/a&gt; is emitted from this MBean with the connection ID of the connection that could not be closed.</source>
          <target state="translated">如果关闭客户端连接会产生异常，则不会从此方法引发该异常。甲&lt;a href=&quot;jmxconnectionnotification&quot;&gt; &lt;code&gt;JMXConnectionNotification&lt;/code&gt; 中&lt;/a&gt;与型&lt;a href=&quot;jmxconnectionnotification#FAILED&quot;&gt; &lt;code&gt;JMXConnectionNotification.FAILED&lt;/code&gt; &lt;/a&gt;从该MBean发出与该不能被关闭的连接的连接ID。</target>
        </trans-unit>
        <trans-unit id="6cc58710f7a52a62031b39086a811bf5c62f9be6" translate="yes" xml:space="preserve">
          <source>If corePoolSize or more threads are running, the Executor always prefers queuing a request rather than adding a new thread.</source>
          <target state="translated">如果corePoolSize或更多的线程正在运行,Executor总是倾向于排队请求,而不是增加一个新的线程。</target>
        </trans-unit>
        <trans-unit id="cb543f07d153ad84e16f6614709ff0723e83f00b" translate="yes" xml:space="preserve">
          <source>If currencyTimeLimit is &amp;gt; 0, then the new value for the attribute is cached in the attribute descriptor's 'value' field and the 'lastUpdatedTimeStamp' field is set to the current time stamp.</source>
          <target state="translated">如果currencyTimeLimit&amp;gt; 0，则将属性的新值缓存在属性描述符的&amp;ldquo;值&amp;rdquo;字段中，并将&amp;ldquo; lastUpdatedTimeStamp&amp;rdquo;字段设置为当前时间戳。</target>
        </trans-unit>
        <trans-unit id="318a070d46817b0d3e2904d4f73faabc24bf182e" translate="yes" xml:space="preserve">
          <source>If current thread is interrupted, throw InterruptedException.</source>
          <target state="translated">如果当前线程被中断,则抛出InterruptedException。</target>
        </trans-unit>
        <trans-unit id="d2831e950ddf2d38fc039e2e83359dc77d52eecc" translate="yes" xml:space="preserve">
          <source>If data has already been sent on the connection, it continues to flow during this handshake. When the handshake completes, this will be signaled with an event. This method is synchronous for the initial handshake on a connection and returns when the negotiated handshake is complete. Some protocols may not support multiple handshakes on an existing socket and may throw an IOException.</source>
          <target state="translated">如果连接上已经发送了数据,那么在这次握手过程中,数据会继续流动。当握手完成时,将用一个事件来表示。这个方法对于连接上的初始握手是同步的,并在协商的握手完成后返回。有些协议可能不支持在现有套接字上进行多次握手,并可能会抛出一个IOException。</target>
        </trans-unit>
        <trans-unit id="a23edc5313c1114129c0451e0f085c188db85181" translate="yes" xml:space="preserve">
          <source>If different docs have different bindings specified, then only two values of &lt;a href=&quot;multipledocumenthandling&quot;&gt;&lt;code&gt;MultipleDocumentHandling&lt;/code&gt;&lt;/a&gt; make sense, and the printer reports an error when the job is submitted if any other value is specified:</source>
          <target state="translated">如果不同的文档指定了不同的绑定，则只有两个&lt;a href=&quot;multipledocumenthandling&quot;&gt; &lt;code&gt;MultipleDocumentHandling&lt;/code&gt; &lt;/a&gt;值才有意义，并且如果指定了任何其他值，则在提交作业时打印机会报告错误：</target>
        </trans-unit>
        <trans-unit id="6a5c3e077d48f57da30ae30c448c6f813a923be7" translate="yes" xml:space="preserve">
          <source>If different docs have different sheet collations specified, then only one value of &lt;a href=&quot;multipledocumenthandling&quot;&gt;&lt;code&gt;MultipleDocumentHandling&lt;/code&gt;&lt;/a&gt; is permitted, and the printer reports an error when the job is submitted if any other value is specified:</source>
          <target state="translated">如果不同的文档指定了不同的工作表排序规则，则仅允许使用&lt;a href=&quot;multipledocumenthandling&quot;&gt; &lt;code&gt;MultipleDocumentHandling&lt;/code&gt; 的&lt;/a&gt;一个值，并且如果指定了其他任何值，则打印机在提交作业时将报告错误：</target>
        </trans-unit>
        <trans-unit id="4cc730ea4ab4177fe6780dd6b3762cbb0dc9f71f" translate="yes" xml:space="preserve">
          <source>If disabled, only the name and class of the object is returned. If enabled, the object will be returned.</source>
          <target state="translated">如果禁用,则只返回对象的名称和类。如果启用,则会返回对象的名称和类。</target>
        </trans-unit>
        <trans-unit id="332d8e7d0f59b9812b7d8680ca5e21ee5e3a7a49" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;sourceXSubsampling&lt;/code&gt; or &lt;code&gt;sourceYSubsampling&lt;/code&gt; is 0 or negative, an &lt;code&gt;IllegalArgumentException&lt;/code&gt; will be thrown.</source>
          <target state="translated">如果 &lt;code&gt;sourceXSubsampling&lt;/code&gt; 或 &lt;code&gt;sourceYSubsampling&lt;/code&gt; 为0或负数，则将抛出 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="10859c24a221b0a1a8f8c2d45e2dd5f29f7ffaa0" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;subsamplingXOffset&lt;/code&gt; or &lt;code&gt;subsamplingYOffset&lt;/code&gt; is negative or greater than or equal to the corresponding period, an &lt;code&gt;IllegalArgumentException&lt;/code&gt; will be thrown.</source>
          <target state="translated">如果 &lt;code&gt;subsamplingXOffset&lt;/code&gt; 或 &lt;code&gt;subsamplingYOffset&lt;/code&gt; 为负或大于或等于相应的周期，则将抛出 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f1bccf0359c9d2523582443e154621147124c9b2" translate="yes" xml:space="preserve">
          <source>If either argument is NaN and neither argument is infinite, then the result is NaN.</source>
          <target state="translated">如果其中一个论点是NaN,且两个论点都不是无限的,那么结果就是NaN。</target>
        </trans-unit>
        <trans-unit id="a87ec8779fbe2da84925808f31ac1112c6261d11" translate="yes" xml:space="preserve">
          <source>If either argument is NaN, or the first argument is infinite, or the second argument is positive zero or negative zero, then the result is NaN.</source>
          <target state="translated">如果任何一个参数是NaN,或者第一个参数是无限的,或者第二个参数是正零或负零,那么结果就是NaN。</target>
        </trans-unit>
        <trans-unit id="b78f08e2975896437871c452fd60393fe6909b91" translate="yes" xml:space="preserve">
          <source>If either argument is NaN, then the result is NaN.</source>
          <target state="translated">如果其中一个参数是NaN,那么结果就是NaN。</target>
        </trans-unit>
        <trans-unit id="34eb1a13a1d41fedad71ac94304afaf4d3b30061" translate="yes" xml:space="preserve">
          <source>If either argument is a NaN, then NaN is returned.</source>
          <target state="translated">如果任何一个参数是NaN,那么将返回NaN。</target>
        </trans-unit>
        <trans-unit id="1dead44a3b56a54e43e3eaa910e00403c25df167" translate="yes" xml:space="preserve">
          <source>If either argument is infinite, then the result is positive infinity.</source>
          <target state="translated">如果任何一个论点是无限的,那么结果就是正无限。</target>
        </trans-unit>
        <trans-unit id="e2a88d05f4fde9c492de3341283adf63bc8f2e9c" translate="yes" xml:space="preserve">
          <source>If either of the destination offsets are negative, the source region is clipped so that its top left will coincide with the top left of the destination image, taking subsampling into account. Then the result is clipped to the destination image on the right and bottom, if one is specified, taking subsampling and destination offsets into account.</source>
          <target state="translated">如果目标偏移量为负值,则考虑到子采样的因素,剪裁源区域,使其左上角与目标图像的左上角重合。然后,如果指定了目标图像的右侧和底部,则考虑到子采样和目标偏移,将结果剪裁到目标图像的右侧和底部。</target>
        </trans-unit>
        <trans-unit id="03f21ceb73c687836a6489d537281750ea1dd4dd" translate="yes" xml:space="preserve">
          <source>If either of the specified arrays contain themselves as elements either directly or indirectly through one or more levels of arrays, the behavior of this method is undefined.</source>
          <target state="translated">如果指定的数组中的任何一个数组直接或间接地通过一个或多个数组层次包含自己作为元素,则本方法的行为未被定义。</target>
        </trans-unit>
        <trans-unit id="e3db76a27295abd8950cde00cc86a08c8f4f37d6" translate="yes" xml:space="preserve">
          <source>If either the source or destination regions end up having a width or height of 0, an &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown.</source>
          <target state="translated">如果源或目标区域的宽度或高度最终为0，则抛出 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="16d93984ca72bf8d13d016fde295c0c3effdeb16" translate="yes" xml:space="preserve">
          <source>If either this URI or the given URI are opaque, or if the scheme and authority components of the two URIs are not identical, or if the path of this URI is not a prefix of the path of the given URI, then the given URI is returned.</source>
          <target state="translated">如果这个URI或给定的URI都不透明,或者两个URI的scheme和authority组件不一致,或者这个URI的路径不是给定URI路径的前缀,那么给定的URI将被返回。</target>
        </trans-unit>
        <trans-unit id="3ec3c5e0a4dd72da9a56884a1749a8ec51b24003" translate="yes" xml:space="preserve">
          <source>If end of file is encountered at any time during this entire process, then an &lt;code&gt;EOFException&lt;/code&gt; is thrown.</source>
          <target state="translated">如果在此整个过程中的任何时间遇到文件末尾，则将引发 &lt;code&gt;EOFException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e02489afb24dcd898ea786f1764d129a6f696e32" translate="yes" xml:space="preserve">
          <source>If end of file is encountered at any time during this entire process, then an &lt;code&gt;java.io.EOFException&lt;/code&gt; is thrown.</source>
          <target state="translated">如果在此整个过程中的任何时间遇到文件结尾，则将引发 &lt;code&gt;java.io.EOFException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="69e5b4feef83c14b8462d2220d828694ae4230e4" translate="yes" xml:space="preserve">
          <source>If end of file is encountered before even one byte can be read, then &lt;code&gt;null&lt;/code&gt; is returned. Otherwise, each byte that is read is converted to type &lt;code&gt;char&lt;/code&gt; by zero-extension. If the character &lt;code&gt;'\n'&lt;/code&gt; is encountered, it is discarded and reading ceases. If the character &lt;code&gt;'\r'&lt;/code&gt; is encountered, it is discarded and, if the following byte converts to the character &lt;code&gt;'\n'&lt;/code&gt;, then that is discarded also; reading then ceases. If end of file is encountered before either of the characters &lt;code&gt;'\n'&lt;/code&gt; and &lt;code&gt;'\r'&lt;/code&gt; is encountered, reading ceases. Once reading has ceased, a &lt;code&gt;String&lt;/code&gt; is returned that contains all the characters read and not discarded, taken in order. Note that every character in this string will have a value less than &lt;code&gt;\u0100&lt;/code&gt;, that is, &lt;code&gt;(char)256&lt;/code&gt;.</source>
          <target state="translated">如果在甚至无法读取一个字节之前遇到文件末尾，则返回 &lt;code&gt;null&lt;/code&gt; 。否则，每个读取的字节将通过零扩展名转换为 &lt;code&gt;char&lt;/code&gt; 类型。如果遇到字符 &lt;code&gt;'\n'&lt;/code&gt; ，则将其丢弃并停止读取。如果遇到字符 &lt;code&gt;'\r'&lt;/code&gt; ，则将其丢弃；如果随后的字节转换为字符 &lt;code&gt;'\n'&lt;/code&gt; ，则也将其丢弃；然后阅读停止。如果在遇到字符 &lt;code&gt;'\n'&lt;/code&gt; 和 &lt;code&gt;'\r'&lt;/code&gt; 之前遇到文件结尾，则读取停止。一旦阅读停止，一个 &lt;code&gt;String&lt;/code&gt; 返回包含按顺序读取的所有已读取但未被丢弃的字符。请注意，此字符串中的每个字符的值都小于 &lt;code&gt;\u0100&lt;/code&gt; ，即 &lt;code&gt;(char)256&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a3e73ecba896208f50db9710798b46a965a908cf" translate="yes" xml:space="preserve">
          <source>If fewer than corePoolSize threads are running, the Executor always prefers adding a new thread rather than queuing.</source>
          <target state="translated">如果运行的线程少于corePoolSize线程,Executor总是倾向于增加一个新的线程而不是排队。</target>
        </trans-unit>
        <trans-unit id="ca5a8548f3fbffd915bbf435ebb21f7a97c206bb" translate="yes" xml:space="preserve">
          <source>If for the URL's protocol (such as HTTP or JAR), there exists a public, specialized URLConnection subclass belonging to one of the following packages or one of their subpackages: java.lang, java.io, java.util, java.net, the connection returned will be of that subclass. For example, for HTTP an HttpURLConnection will be returned, and for JAR a JarURLConnection will be returned.</source>
          <target state="translated">如果对于URL的协议(比如HTTP或JAR),存在一个公共的、专门的URLConnection子类,属于以下包或它们的子包之一:java.lang、java.io、java.util、java.net,那么返回的连接将是那个子类的。例如,对于HTTP,将返回一个HttpURLConnection,对于JAR,将返回一个JarURLConnection。</target>
        </trans-unit>
        <trans-unit id="ecc3cf47c73dc6fc1a7d51257f1c70d39038a258" translate="yes" xml:space="preserve">
          <source>If for the handler's protocol (such as HTTP or JAR), there exists a public, specialized URLConnection subclass belonging to one of the following packages or one of their subpackages: java.lang, java.io, java.util, java.net, the connection returned will be of that subclass. For example, for HTTP an HttpURLConnection will be returned, and for JAR a JarURLConnection will be returned.</source>
          <target state="translated">如果对于处理程序的协议(如HTTP或JAR),存在一个公共的、专门的URLConnection子类,属于以下包或它们的子包之一:java.lang、java.io、java.util、java.net,那么返回的连接将是那个子类的。例如,对于HTTP,将返回一个HttpURLConnection,对于JAR,将返回一个JarURLConnection。</target>
        </trans-unit>
        <trans-unit id="a4abed1287821693f6da736875b1dd20090fd9c3" translate="yes" xml:space="preserve">
          <source>If given an &lt;a href=&quot;inetsocketaddress&quot;&gt;&lt;code&gt;InetSocketAddress&lt;/code&gt;&lt;/a&gt;, this method behaves as if invoking &lt;a href=&quot;datagramsocket#connect-java.net.InetAddress-int-&quot;&gt;&lt;code&gt;connect(InetAddress,int)&lt;/code&gt;&lt;/a&gt; with the the given socket addresses IP address and port number.</source>
          <target state="translated">如果给定了&lt;a href=&quot;inetsocketaddress&quot;&gt; &lt;code&gt;InetSocketAddress&lt;/code&gt; &lt;/a&gt;，则此方法的行为就像使用给定的套接字地址IP地址和端口号调用&lt;a href=&quot;datagramsocket#connect-java.net.InetAddress-int-&quot;&gt; &lt;code&gt;connect(InetAddress,int)&lt;/code&gt; 一样&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e516526c9c2357988df1234780c497763164fab1" translate="yes" xml:space="preserve">
          <source>If handshaking fails for any reason, the &lt;code&gt;SSLSocket&lt;/code&gt; is closed, and no further communications can be done.</source>
          <target state="translated">如果握手由于任何原因失败，则 &lt;code&gt;SSLSocket&lt;/code&gt; 将关闭，并且无法进行进一步的通信。</target>
        </trans-unit>
        <trans-unit id="9a00d8a2054c6cca37fdcf90a95f1f7f1ad5e5f0" translate="yes" xml:space="preserve">
          <source>If hook or callback methods throw exceptions, internal worker threads may in turn fail and abruptly terminate.</source>
          <target state="translated">如果钩子或回调方法抛出异常,内部工作线程可能反过来失败并突然终止。</target>
        </trans-unit>
        <trans-unit id="085d6508b165d7efeb827d901170784516d5c017" translate="yes" xml:space="preserve">
          <source>If horizon is &lt;code&gt;0&lt;/code&gt;, then the horizon is ignored and this method continues to search through the input looking for the specified pattern without bound. In this case it may buffer all of the input searching for the pattern.</source>
          <target state="translated">如果horizo​​n为 &lt;code&gt;0&lt;/code&gt; ，那么将忽略horizo​​n，该方法将继续在输入中搜索以查找指定的模式而不受限制。在这种情况下，它可以缓冲搜索模式的所有输入。</target>
        </trans-unit>
        <trans-unit id="e185e59957de1a2d9502a435e3bf5d9b3e15599e" translate="yes" xml:space="preserve">
          <source>If horizon is negative, then an IllegalArgumentException is thrown.</source>
          <target state="translated">如果horizon为负值,则会抛出IllegalArgumentException。</target>
        </trans-unit>
        <trans-unit id="c672e7792e737065f944dcb4cec0eb9d5372d1e1" translate="yes" xml:space="preserve">
          <source>If implementing JavaSound on a I3DL2-compliant device:</source>
          <target state="translated">如果在兼容I3DL2的设备上实现JavaSound。</target>
        </trans-unit>
        <trans-unit id="3fd0a906cb89e2de9c5076d850930cae34f103b9" translate="yes" xml:space="preserve">
          <source>If implementing an unusual calendar system that is not based on years, months and days, or where you want direct control, then the &lt;code&gt;ChronoPeriod&lt;/code&gt; interface must be directly implemented.</source>
          <target state="translated">如果实现的非常 &lt;code&gt;ChronoPeriod&lt;/code&gt; 日历系统不是基于年，月，日或您要直接控制的地方，则必须直接实现ChronoPeriod接口。</target>
        </trans-unit>
        <trans-unit id="07b0ad2086ad124aeb2593860505d4dc09bcafc2" translate="yes" xml:space="preserve">
          <source>If implicit and explicit opening and closing are mixed on the same &lt;code&gt;MidiDevice&lt;/code&gt; instance, the following rules apply:</source>
          <target state="translated">如果在同一 &lt;code&gt;MidiDevice&lt;/code&gt; 实例上混合了隐式和显式的打开和关闭，则适用以下规则：</target>
        </trans-unit>
        <trans-unit id="1b6c1ac0801d0f32085f65cf19851af72a8b38e1" translate="yes" xml:space="preserve">
          <source>If insufficient permits are available then the current thread becomes disabled for thread scheduling purposes and lies dormant until one of three things happens:</source>
          <target state="translated">如果没有足够的许可,那么当前线程就会因为线程调度的目的而被禁用,并处于休眠状态,直到三种情况之一发生。</target>
        </trans-unit>
        <trans-unit id="41f0c20f43c3bf64e0efed44e2fb775806ea99b7" translate="yes" xml:space="preserve">
          <source>If insufficient permits are available then the current thread becomes disabled for thread scheduling purposes and lies dormant until one of two things happens:</source>
          <target state="translated">如果没有足够的许可,那么当前线程就会因为线程调度的目的而被禁用,并处于休眠状态,直到有两种情况发生。</target>
        </trans-unit>
        <trans-unit id="6392fbf3bc8eb96daeacf7450eb84b4b39a684c9" translate="yes" xml:space="preserve">
          <source>If insufficient permits are available then the current thread becomes disabled for thread scheduling purposes and lies dormant until some other thread invokes one of the &lt;a href=&quot;semaphore#release--&quot;&gt;&lt;code&gt;release&lt;/code&gt;&lt;/a&gt; methods for this semaphore, the current thread is next to be assigned permits and the number of available permits satisfies this request.</source>
          <target state="translated">如果没有足够的许可，则当前线程将出于线程调度目的而被禁用，并且处于休眠状态，直到其他某个线程为此信号量调用一种&lt;a href=&quot;semaphore#release--&quot;&gt; &lt;code&gt;release&lt;/code&gt; &lt;/a&gt;方法为止，接下来将为当前线程分配许可，并且可用许可的数量可以满足该请求。</target>
        </trans-unit>
        <trans-unit id="2f81c133b1f0b74c30d4d20073c4db1886f54e67" translate="yes" xml:space="preserve">
          <source>If insufficient permits are available then this method will return immediately with the value &lt;code&gt;false&lt;/code&gt; and the number of available permits is unchanged.</source>
          <target state="translated">如果没有足够的许可证，则此方法将立即返回 &lt;code&gt;false&lt;/code&gt; 值，并且可用许可证的数量不变。</target>
        </trans-unit>
        <trans-unit id="3ee886087a23f0ef283d53172b5a86b2108daa86" translate="yes" xml:space="preserve">
          <source>If interrupted while blocked in step 4, throw InterruptedException.</source>
          <target state="translated">如果在步骤4中被阻止时被打断,则抛出InterruptedException。</target>
        </trans-unit>
        <trans-unit id="8d2bc19f50633c8c0c8e271655bc0f3233284658" translate="yes" xml:space="preserve">
          <source>If it is critical to obtain every active subgroup in this thread group, the caller should verify that the returned int value is strictly less than the length of &lt;code&gt;list&lt;/code&gt;.</source>
          <target state="translated">如果获取该线程组中的每个活动子组至关重要，则调用者应验证返回的int值严格小于 &lt;code&gt;list&lt;/code&gt; 的长度。</target>
        </trans-unit>
        <trans-unit id="cc469862baa4b5e3d18bc2ca8c5358c4773f7d5f" translate="yes" xml:space="preserve">
          <source>If it is critical to obtain every active thread in the current thread's thread group and its subgroups, the invoker should verify that the returned int value is strictly less than the length of &lt;code&gt;tarray&lt;/code&gt;.</source>
          <target state="translated">如果获取当前线程的线程组及其子组中的每个活动线程至关重要，则调用者应验证返回的int值严格小于 &lt;code&gt;tarray&lt;/code&gt; 的长度。</target>
        </trans-unit>
        <trans-unit id="22683bf338326eeebb95e34c255b900a9e0a2f93" translate="yes" xml:space="preserve">
          <source>If it is critical to obtain every active thread in this thread group, the caller should verify that the returned int value is strictly less than the length of &lt;code&gt;list&lt;/code&gt;.</source>
          <target state="translated">如果获取该线程组中的每个活动线程至关重要，则调用者应验证返回的int值严格小于 &lt;code&gt;list&lt;/code&gt; 的长度。</target>
        </trans-unit>
        <trans-unit id="a8a140e583fff0cfc9d06bbb68afa76210088042" translate="yes" xml:space="preserve">
          <source>If it is set to &lt;a href=&quot;pack200.packer#FALSE&quot;&gt;&lt;code&gt;FALSE&lt;/code&gt;&lt;/a&gt;, the packer may reorder elements, and also remove JAR directory entries, which carry no useful information for Java applications. (Typically this enables better compression.)</source>
          <target state="translated">如果将其设置为&lt;a href=&quot;pack200.packer#FALSE&quot;&gt; &lt;code&gt;FALSE&lt;/code&gt; &lt;/a&gt;，则打包程序可能会对元素进行重新排序，并且还会删除JAR目录条目，这些目录条目不包含Java应用程序的有用信息。（通常这可以实现更好的压缩。）</target>
        </trans-unit>
        <trans-unit id="349c3ce48f2850808153616db77878ba7dc35133" translate="yes" xml:space="preserve">
          <source>If iterables and sets containing &lt;code&gt;null&lt;/code&gt; are passed as arguments to methods in this class, a &lt;code&gt;NullPointerException&lt;/code&gt; will be thrown.</source>
          <target state="translated">如果将包含 &lt;code&gt;null&lt;/code&gt; 的可迭代对象和集合作为参数传递给此类中的方法，则将引发 &lt;code&gt;NullPointerException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9f90529506d3a0958fad7a3ecbf1c1171a153e5b" translate="yes" xml:space="preserve">
          <source>If loader is &lt;code&gt;null&lt;/code&gt;, the script engine factories that are bundled with the platform and that are in the usual extension directories (installed extensions) are loaded.</source>
          <target state="translated">如果loader为 &lt;code&gt;null&lt;/code&gt; ，则将加载与平台捆绑在一起且位于通常的扩展目录（已安装扩展）中的脚本引擎工厂。</target>
        </trans-unit>
        <trans-unit id="ee069a1e9967d9348b8218cc73e384bb53741058" translate="yes" xml:space="preserve">
          <source>If many entries are to be made into a &lt;code&gt;Hashtable&lt;/code&gt;, creating it with a sufficiently large capacity may allow the entries to be inserted more efficiently than letting it perform automatic rehashing as needed to grow the table.</source>
          <target state="translated">如果要在 &lt;code&gt;Hashtable&lt;/code&gt; 中创建许多条目，则创建一个具有足够大容量的表可能比使它根据需要增长表的自动重新哈希处理更有效地插入条目。</target>
        </trans-unit>
        <trans-unit id="6dc60d765a093b43a6239eb2d5685c05051e44ee" translate="yes" xml:space="preserve">
          <source>If many mappings are to be stored in a &lt;code&gt;HashMap&lt;/code&gt; instance, creating it with a sufficiently large capacity will allow the mappings to be stored more efficiently than letting it perform automatic rehashing as needed to grow the table. Note that using many keys with the same &lt;code&gt;hashCode()&lt;/code&gt; is a sure way to slow down performance of any hash table. To ameliorate impact, when keys are &lt;a href=&quot;../lang/comparable&quot;&gt;&lt;code&gt;Comparable&lt;/code&gt;&lt;/a&gt;, this class may use comparison order among keys to help break ties.</source>
          <target state="translated">如果将许多映射存储在 &lt;code&gt;HashMap&lt;/code&gt; 实例中，则创建具有足够大容量的映射将比让其根据需要增长表的自动重新哈希处理更有效地存储映射。请注意，使用具有相同 &lt;code&gt;hashCode()&lt;/code&gt; 的许多键是降低任何哈希表性能的肯定方法。为了改善影响，当键为&lt;a href=&quot;../lang/comparable&quot;&gt; &lt;code&gt;Comparable&lt;/code&gt; 时&lt;/a&gt;，此类可以使用键之间的比较顺序来帮助打破平局。</target>
        </trans-unit>
        <trans-unit id="403efbf3d99b9a55860af122e7ea1fa369ccd1ea" translate="yes" xml:space="preserve">
          <source>If more formats are provided than needed by the pattern string, the remaining ones are ignored. If fewer formats are provided than needed, then only the first &lt;code&gt;newFormats.length&lt;/code&gt; formats are replaced.</source>
          <target state="translated">如果提供的格式多于模式字符串所需的格式，则其余格式将被忽略。如果提供的格式少于需要的格式，则仅替换第一个 &lt;code&gt;newFormats.length&lt;/code&gt; 格式。</target>
        </trans-unit>
        <trans-unit id="d6b342590893d7d01546097e9b3ca381aee04072" translate="yes" xml:space="preserve">
          <source>If multiple language tags match as a result of the subtag &lt;code&gt;'*'&lt;/code&gt; included in a language range, the first matching language tag returned by an &lt;a href=&quot;iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; over a &lt;a href=&quot;collection&quot;&gt;&lt;code&gt;Collection&lt;/code&gt;&lt;/a&gt; of language tags is treated as the best matching one.</source>
          <target state="translated">如果由于语言范围中包含的子标签 &lt;code&gt;'*'&lt;/code&gt; 而使多个语言标签匹配，则&lt;a href=&quot;iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;在语言标签&lt;a href=&quot;collection&quot;&gt; &lt;code&gt;Collection&lt;/code&gt; &lt;/a&gt;上返回的第一个匹配的语言标签将被视为最匹配的语言标签。</target>
        </trans-unit>
        <trans-unit id="5fbfbdd8794986ee056ce3b4b224daa409c09c76" translate="yes" xml:space="preserve">
          <source>If neither of these properties is defined then the LogManager uses its default configuration. The default configuration is typically loaded from the properties file &quot;&lt;code&gt;lib/logging.properties&lt;/code&gt;&quot; in the Java installation directory.</source>
          <target state="translated">如果这两个属性均未定义，则LogManager使用其默认配置。通常从Java安装目录中的属性文件&amp;ldquo; &lt;code&gt;lib/logging.properties&lt;/code&gt; &amp;rdquo; 加载默认配置。</target>
        </trans-unit>
        <trans-unit id="a3ae7424666e0772e32faa1585ee99d03123f286" translate="yes" xml:space="preserve">
          <source>If no &quot;%g&quot; field has been specified and the file count is greater than one, then the generation number will be added to the end of the generated filename, after a dot.</source>
          <target state="translated">如果没有指定&quot;%g &quot;字段,并且文件数大于1,那么生成号将被添加到生成的文件名的末尾,在点之后。</target>
        </trans-unit>
        <trans-unit id="c49e64ec417bf53b53b9cae02beab8814230bf7f" translate="yes" xml:space="preserve">
          <source>If no 'getMethod' field is defined then the default value of the attribute is returned. If the returned value is not compatible with the declared type of the attribute, an exception will be thrown.</source>
          <target state="translated">如果没有定义'getMethod'字段,那么将返回属性的默认值。如果返回的值与属性的声明类型不兼容,将抛出一个异常。</target>
        </trans-unit>
        <trans-unit id="bf903b34c15e4e7c1e0d072f0b913417b22851de" translate="yes" xml:space="preserve">
          <source>If no &lt;a name=&quot;floatdFlags&quot;&gt;flags&lt;/a&gt; are given the default formatting is as follows:</source>
          <target state="translated">如果未给出&lt;a name=&quot;floatdFlags&quot;&gt;标志&lt;/a&gt;，则默认格式如下：</target>
        </trans-unit>
        <trans-unit id="25494f57433f4174256b8e508bd8d48cd34d752d" translate="yes" xml:space="preserve">
          <source>If no &lt;a name=&quot;intdFlags&quot;&gt;flags&lt;/a&gt; are given the default formatting is as follows:</source>
          <target state="translated">如果未给出&lt;a name=&quot;intdFlags&quot;&gt;标志&lt;/a&gt;，则默认格式如下：</target>
        </trans-unit>
        <trans-unit id="48c606520866ed3b5c7ab60dadf8ce7019bfde30" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;URLStreamHandlerFactory&lt;/code&gt; has yet been set up, or if the factory's &lt;code&gt;createURLStreamHandler&lt;/code&gt; method returns &lt;code&gt;null&lt;/code&gt;, then the constructor finds the value of the system property:</source>
          <target state="translated">如果尚未设置 &lt;code&gt;URLStreamHandlerFactory&lt;/code&gt; ，或者工厂的 &lt;code&gt;createURLStreamHandler&lt;/code&gt; 方法返回 &lt;code&gt;null&lt;/code&gt; ，则构造方法将找到系统属性的值：</target>
        </trans-unit>
        <trans-unit id="e563df7258f13a8f225773d813627e3543639a63" translate="yes" xml:space="preserve">
          <source>If no Configuration object has been installed in the runtime, a call to &lt;code&gt;getConfiguration&lt;/code&gt; installs an instance of the default Configuration implementation (a default subclass implementation of this abstract class). The default Configuration implementation can be changed by setting the value of the &lt;code&gt;login.configuration.provider&lt;/code&gt; security property to the fully qualified name of the desired Configuration subclass implementation.</source>
          <target state="translated">如果在运行时中未安装Configuration对象，则对 &lt;code&gt;getConfiguration&lt;/code&gt; 的调用将安装默认Configuration实现的实例（此抽象类的默认子类实现）。通过将 &lt;code&gt;login.configuration.provider&lt;/code&gt; 安全属性的值设置为所需Configuration子类实现的完全限定名称，可以更改默认的Configuration 实现。</target>
        </trans-unit>
        <trans-unit id="f28da2d05be1c33c6f8a1b624ec1c4eb508ea0e9" translate="yes" xml:space="preserve">
          <source>If no Policy object has been installed in the runtime, a call to &lt;code&gt;getPolicy&lt;/code&gt; installs an instance of the default Policy implementation (a default subclass implementation of this abstract class). The default Policy implementation can be changed by setting the value of the &lt;code&gt;policy.provider&lt;/code&gt; security property to the fully qualified name of the desired Policy subclass implementation.</source>
          <target state="translated">如果在运行时中未安装任何Policy对象，则对 &lt;code&gt;getPolicy&lt;/code&gt; 的调用将安装默认Policy实现的实例（此抽象类的默认子类实现）。通过将 &lt;code&gt;policy.provider&lt;/code&gt; 安全属性的值设置为所需Policy子类实现的完全限定名称，可以更改默认的Policy 实现。</target>
        </trans-unit>
        <trans-unit id="d8103a3ac14929d0ea6f76a89ffe79e5d895f4e5" translate="yes" xml:space="preserve">
          <source>If no access is allowed, the suffix is &quot;/noaccess&quot;.</source>
          <target state="translated">如果不允许访问,后缀为&quot;/noaccess&quot;。</target>
        </trans-unit>
        <trans-unit id="51d8e33d13184ce0c057a13cfc7fd7024a488d5d" translate="yes" xml:space="preserve">
          <source>If no array is specified on the constructor, but tiling is allowed, then this method returns &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">如果构造函数上未指定任何数组，但允许切片，则此方法返回 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8225a781e6aeb21876e42212e39dd339fac75791" translate="yes" xml:space="preserve">
          <source>If no attribute with this name is found, this method has no effect.</source>
          <target state="translated">如果没有找到这个名称的属性,这个方法就没有效果。</target>
        </trans-unit>
        <trans-unit id="f57aed5ec85446dac8b881e2e9691de38db155c7" translate="yes" xml:space="preserve">
          <source>If no calendar type is explicitly given by a call to the &lt;a href=&quot;calendar.builder#setCalendarType-java.lang.String-&quot;&gt;&lt;code&gt;setCalendarType&lt;/code&gt;&lt;/a&gt; method, the &lt;code&gt;Locale&lt;/code&gt; value is used to determine what type of &lt;code&gt;Calendar&lt;/code&gt; to be built.</source>
          <target state="translated">如果没有通过调用&lt;a href=&quot;calendar.builder#setCalendarType-java.lang.String-&quot;&gt; &lt;code&gt;setCalendarType&lt;/code&gt; &lt;/a&gt;方法显式指定日历类型，则 &lt;code&gt;Locale&lt;/code&gt; 值将用于确定要构建的 &lt;code&gt;Calendar&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="635db19022015f7488d5435599c4fb48937a985a" translate="yes" xml:space="preserve">
          <source>If no class can be found in this way, this method will use an implementation-specific way to locate an implementation. If none is found, a NamingException is thrown.</source>
          <target state="translated">如果用这种方式找不到类,本方法将使用特定实现的方式来定位实现。如果没有找到,就会抛出一个NamingException。</target>
        </trans-unit>
        <trans-unit id="ca30507c3453e7a86b86ecc80fdbdb06caf5ff95" translate="yes" xml:space="preserve">
          <source>If no compiler is available, these methods do nothing.</source>
          <target state="translated">如果没有编译器,这些方法什么都不做。</target>
        </trans-unit>
        <trans-unit id="243bf1d6846d6372968ae561b146475eecd8f1fd" translate="yes" xml:space="preserve">
          <source>If no content handler could be found, URLConnection will look for a content handler in a user-defineable set of places. By default it looks in sun.net.www.content, but users can define a vertical-bar delimited set of class prefixes to search through in addition by defining the java.content.handler.pkgs property. The class name must be of the form:</source>
          <target state="translated">如果找不到内容处理程序,URLConnection将在用户定义的一组地方寻找内容处理程序。默认情况下,它会在sun.net.www.content中查找,但用户可以通过定义java.content.handler.pkgs属性来定义一组以竖条分隔的类前缀,以便另外搜索。类名必须是这样的形式。</target>
        </trans-unit>
        <trans-unit id="521ced0b1e8fb5511e3ff3521639bbd2e1d892dd" translate="yes" xml:space="preserve">
          <source>If no content handler factory has yet been set up, or if the factory's &lt;code&gt;createContentHandler&lt;/code&gt; method returns &lt;code&gt;null&lt;/code&gt;, then the application loads the class named:</source>
          <target state="translated">如果尚未设置任何内容处理程序工厂，或者工厂的 &lt;code&gt;createContentHandler&lt;/code&gt; 方法返回 &lt;code&gt;null&lt;/code&gt; ，则应用程序将加载名为：</target>
        </trans-unit>
        <trans-unit id="8116296a26510935b6c10d95ea6e65ff6f455a64" translate="yes" xml:space="preserve">
          <source>If no descriptions are available, &lt;code&gt;null&lt;/code&gt; is returned. If &lt;code&gt;null&lt;/code&gt; is returned from &lt;code&gt;getCompressionQualityDescriptions&lt;/code&gt;, this method must also return &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">如果没有可用的描述，则返回 &lt;code&gt;null&lt;/code&gt; 。如果 &lt;code&gt;null&lt;/code&gt; 是从返回 &lt;code&gt;getCompressionQualityDescriptions&lt;/code&gt; ，这种方法也必须返回 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2514c39dc0080097bab43387d9c7ddb3546f473f" translate="yes" xml:space="preserve">
          <source>If no descriptions are available, &lt;code&gt;null&lt;/code&gt; is returned. If &lt;code&gt;null&lt;/code&gt; is returned from &lt;code&gt;getCompressionQualityValues&lt;/code&gt;, this method must also return &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">如果没有可用的描述，则返回 &lt;code&gt;null&lt;/code&gt; 。如果 &lt;code&gt;null&lt;/code&gt; 是从返回 &lt;code&gt;getCompressionQualityValues&lt;/code&gt; ，这种方法也必须返回 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d14c96365230fe95d4c170b5d326eb6ff39f4595" translate="yes" xml:space="preserve">
          <source>If no enough field parameters are given for determining date and/or time, calendar specific default values are used when building a &lt;code&gt;Calendar&lt;/code&gt;. For example, if the &lt;a href=&quot;calendar#YEAR&quot;&gt;&lt;code&gt;YEAR&lt;/code&gt;&lt;/a&gt; value isn't given for the Gregorian calendar, 1970 will be used. If there are any conflicts among field parameters, the &lt;a href=&quot;calendar#resolution&quot;&gt; resolution rules&lt;/a&gt; are applied. Therefore, the order of field setting matters.</source>
          <target state="translated">如果没有给出足够的字段参数来确定日期和/或时间，则在构建 &lt;code&gt;Calendar&lt;/code&gt; 时将使用日历特定的默认值。例如，如果未为公历指定&lt;a href=&quot;calendar#YEAR&quot;&gt; &lt;code&gt;YEAR&lt;/code&gt; &lt;/a&gt;值，则将使用1970。如果字段参数之间存在任何冲突，则应用&lt;a href=&quot;calendar#resolution&quot;&gt;解析规则&lt;/a&gt;。因此，字段设置的顺序很重要。</target>
        </trans-unit>
        <trans-unit id="3c3b8e9ce2ba433f5bd56b760aee79cd23850c9f" translate="yes" xml:space="preserve">
          <source>If no field was found in step 1 above, this algorithm is applied recursively to each direct superinterface of C. The direct superinterfaces are searched in the order they were declared.</source>
          <target state="translated">如果在上面的第1步中没有找到字段,则对C的每一个直接超接口递归应用该算法,直接超接口按照其声明的顺序进行搜索。</target>
        </trans-unit>
        <trans-unit id="3a478bf1473f7f2d59cb1ae1a418bd4cb78d9c7e" translate="yes" xml:space="preserve">
          <source>If no field was found in steps 1 and 2 above, and C has a superclass S, then this algorithm is invoked recursively upon S. If C has no superclass, then a &lt;code&gt;NoSuchFieldException&lt;/code&gt; is thrown.</source>
          <target state="translated">如果在上面的步骤1和2中未找到任何字段，并且C具有超类S，则在S上递归调用此算法。如果C没有超类，则抛出 &lt;code&gt;NoSuchFieldException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="85d8b2f1396493ecd88a1cad4f6f3c76ce079715" translate="yes" xml:space="preserve">
          <source>If no localization information is available, the non-localized name is returned.</source>
          <target state="translated">如果没有本地化信息,则返回非本地化名称。</target>
        </trans-unit>
        <trans-unit id="22fd3bbeb9c5dbaa32c21b11f1b89bc4bd8ecdd6" translate="yes" xml:space="preserve">
          <source>If no mapping rules exist to derive &lt;em&gt;opentype(J)&lt;/em&gt; from &lt;em&gt;J&lt;/em&gt;, then &lt;em&gt;J&lt;/em&gt; cannot be the type of a method parameter or return value in an MXBean interface.</source>
          <target state="translated">如果不存在从&lt;em&gt;J&lt;/em&gt;派生&lt;em&gt;opentype（J）的&lt;/em&gt;映射规则，则&lt;em&gt;J&lt;/em&gt;不能是方法参数的类型或MXBean接口中的返回值。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b5ddd6654d9c602c5f7f5aebb431141368be7c43" translate="yes" xml:space="preserve">
          <source>If no mark has been set, then the value of mark is the offset passed to the constructor (or 0 if the offset was not supplied).</source>
          <target state="translated">如果没有设置mark,那么mark的值就是传递给构造函数的偏移量(如果没有提供偏移量,则为0)。</target>
        </trans-unit>
        <trans-unit id="bebf4b9fd62e0e0e062741afac69f1752343555c" translate="yes" xml:space="preserve">
          <source>If no mark has been set, then the value of the mark is the offset passed to the constructor (or 0 if the offset was not supplied).</source>
          <target state="translated">如果没有设置标记,那么标记的值就是传递给构造函数的偏移量(如果没有提供偏移量,则为0)。</target>
        </trans-unit>
        <trans-unit id="04e67c9a77bba1f9d49ec8d97898bd5df73e6e1e" translate="yes" xml:space="preserve">
          <source>If no matching method is found by step 1 then:</source>
          <target state="translated">如果通过步骤1没有找到匹配方法,那么。</target>
        </trans-unit>
        <trans-unit id="bd216b7387fe2dee5dd00b4fdaab3ce4feee3b7f" translate="yes" xml:space="preserve">
          <source>If no other thread is already waiting at the exchange then the current thread is disabled for thread scheduling purposes and lies dormant until one of three things happens:</source>
          <target state="translated">如果没有其他线程已经在交换处等待,那么出于线程调度的目的,当前线程将被禁用,并处于休眠状态,直到三种情况之一发生。</target>
        </trans-unit>
        <trans-unit id="f82da2a19e504b2d12c547c6cd21c732ba85238d" translate="yes" xml:space="preserve">
          <source>If no other thread is already waiting at the exchange then the current thread is disabled for thread scheduling purposes and lies dormant until one of two things happens:</source>
          <target state="translated">如果没有其他线程已经在交换处等待,那么出于线程调度的目的,当前线程将被禁用,并处于休眠状态,直到两种情况之一发生。</target>
        </trans-unit>
        <trans-unit id="d8c99a978e37655f05ece5d09a50cf601a4c0974" translate="yes" xml:space="preserve">
          <source>If no permit is available then the current thread becomes disabled for thread scheduling purposes and lies dormant until one of three things happens:</source>
          <target state="translated">如果没有许可,那么当前线程就会因为线程调度的目的而被禁用,并处于休眠状态,直到三种情况之一发生。</target>
        </trans-unit>
        <trans-unit id="05c5dee407f95ed89e404e9d431ede44a984e5d6" translate="yes" xml:space="preserve">
          <source>If no permit is available then the current thread becomes disabled for thread scheduling purposes and lies dormant until one of two things happens:</source>
          <target state="translated">如果没有可用的许可,那么当前线程就会因为线程调度的目的而被禁用,并处于休眠状态,直到两种情况之一发生。</target>
        </trans-unit>
        <trans-unit id="1e0c61688e7523da669464298c2f1d9cfc1f08b7" translate="yes" xml:space="preserve">
          <source>If no permit is available then the current thread becomes disabled for thread scheduling purposes and lies dormant until some other thread invokes the &lt;a href=&quot;semaphore#release--&quot;&gt;&lt;code&gt;release()&lt;/code&gt;&lt;/a&gt; method for this semaphore and the current thread is next to be assigned a permit.</source>
          <target state="translated">如果没有可用的许可，则当前线程将出于线程调度目的而被禁用，并处于休眠状态，直到某个其他线程为此信号量调用&lt;a href=&quot;semaphore#release--&quot;&gt; &lt;code&gt;release()&lt;/code&gt; &lt;/a&gt;方法，然后再为当前线程分配许可。</target>
        </trans-unit>
        <trans-unit id="bd133845b033ac7223fae8a2a495d3b108c36d1d" translate="yes" xml:space="preserve">
          <source>If no permit is available then this method will return immediately with the value &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果没有可用的许可，则此方法将立即返回 &lt;code&gt;false&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="91b1ae1535d1f33ae0e732627166d15b6a2cc1cc" translate="yes" xml:space="preserve">
          <source>If no provider is found by the above steps, including the default case where there is no provider package list, then the implementation will use its own provider for &lt;code&gt;&lt;em&gt;protocol&lt;/em&gt;&lt;/code&gt;, or it will throw a &lt;code&gt;MalformedURLException&lt;/code&gt; if there is none. An implementation may choose to find providers by other means. For example, it may support the &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/jar/jar.html#Service%20Provider&quot;&gt; JAR conventions for service providers&lt;/a&gt;, where the service interface is &lt;code&gt;JMXConnectorProvider&lt;/code&gt;.</source>
          <target state="translated">如果上述步骤未找到提供程序，包括默认情况下没有提供程序包列表，则该实现将对 &lt;code&gt;&lt;em&gt;protocol&lt;/em&gt;&lt;/code&gt; 使用其自己的提供程序，如果没有，则将抛出 &lt;code&gt;MalformedURLException&lt;/code&gt; 。一个实现可以选择通过其他方式查找提供者。例如，它可能支持&lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/jar/jar.html#Service%20Provider&quot;&gt;服务提供者&lt;/a&gt;的JAR约定，其中服务接口为 &lt;code&gt;JMXConnectorProvider&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="70dda654250368e808b6b425e672a82e81efe712" translate="yes" xml:space="preserve">
          <source>If no provider is found by the above steps, including the default case where there is no provider package list, then the implementation will use its own provider for &lt;code&gt;&lt;em&gt;protocol&lt;/em&gt;&lt;/code&gt;, or it will throw a &lt;code&gt;MalformedURLException&lt;/code&gt; if there is none. An implementation may choose to find providers by other means. For example, it may support the &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/jar/jar.html#Service%20Provider&quot;&gt; JAR conventions for service providers&lt;/a&gt;, where the service interface is &lt;code&gt;JMXConnectorServerProvider&lt;/code&gt;.</source>
          <target state="translated">如果上述步骤未找到提供程序，包括默认情况下没有提供程序包列表，则该实现将对 &lt;code&gt;&lt;em&gt;protocol&lt;/em&gt;&lt;/code&gt; 使用其自己的提供程序，如果没有，则将抛出 &lt;code&gt;MalformedURLException&lt;/code&gt; 。一个实现可以选择通过其他方式查找提供者。例如，它可能支持&lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/jar/jar.html#Service%20Provider&quot;&gt;服务提供者&lt;/a&gt;的JAR约定，其中服务接口为 &lt;code&gt;JMXConnectorServerProvider&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a4f99c7ebdd694b15a7a1884c5882e8188c69e3f" translate="yes" xml:space="preserve">
          <source>If no such value of</source>
          <target state="translated">如果没有这种价值的</target>
        </trans-unit>
        <trans-unit id="8098cc1dcdc7eef18c37176303f3d539ee64942f" translate="yes" xml:space="preserve">
          <source>If no textual mapping is found then the &lt;a href=&quot;dayofweek#getValue--&quot;&gt;&lt;code&gt;numeric value&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">如果找不到文本映射，则返回&lt;a href=&quot;dayofweek#getValue--&quot;&gt; &lt;code&gt;numeric value&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="172481aa19fb2665297fe8e01e1a105abb6a4821" translate="yes" xml:space="preserve">
          <source>If no textual mapping is found then the &lt;a href=&quot;era#getValue--&quot;&gt;&lt;code&gt;numeric value&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">如果找不到文本映射，则返回&lt;a href=&quot;era#getValue--&quot;&gt; &lt;code&gt;numeric value&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="36c6de59e58640f47a0ec5a526b903e6cdb5056b" translate="yes" xml:space="preserve">
          <source>If no textual mapping is found then the &lt;a href=&quot;month#getValue--&quot;&gt;&lt;code&gt;numeric value&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">如果找不到文本映射，则返回&lt;a href=&quot;month#getValue--&quot;&gt; &lt;code&gt;numeric value&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="26dec5e0aab4853771305a15bb1f061f803aacdf" translate="yes" xml:space="preserve">
          <source>If no textual mapping is found then the &lt;a href=&quot;zoneid#getId--&quot;&gt;&lt;code&gt;full ID&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">如果未找到文本映射，则返回&lt;a href=&quot;zoneid#getId--&quot;&gt; &lt;code&gt;full ID&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2720f481dd9e3309673a042872b8da0c6951d663" translate="yes" xml:space="preserve">
          <source>If no update listeners are present, the reader may choose to perform fewer updates to the pixels of the destination images and/or thumbnails, which may result in more efficient decoding.</source>
          <target state="translated">如果不存在更新监听器,则阅读器可以选择对目标图像和/或缩略图的像素执行较少的更新,这可能导致更有效的解码。</target>
        </trans-unit>
        <trans-unit id="a2e2d9f63d3b68d988634ea3a7fd560c86f5e146" translate="yes" xml:space="preserve">
          <source>If no week definition parameters are explicitly given by a call to the &lt;a href=&quot;calendar.builder#setWeekDefinition-int-int-&quot;&gt;&lt;code&gt;setWeekDefinition&lt;/code&gt;&lt;/a&gt; method, the &lt;code&gt;Locale&lt;/code&gt;'s default values are used.</source>
          <target state="translated">如果没有通过调用&lt;a href=&quot;calendar.builder#setWeekDefinition-int-int-&quot;&gt; &lt;code&gt;setWeekDefinition&lt;/code&gt; &lt;/a&gt;方法明确给定周定义参数，则使用 &lt;code&gt;Locale&lt;/code&gt; 的默认值。</target>
        </trans-unit>
        <trans-unit id="4076d96bb4d80dea21dec4f9083af903b3282c51" translate="yes" xml:space="preserve">
          <source>If none of the above are true, &lt;code&gt;implies&lt;/code&gt; returns false.</source>
          <target state="translated">如果以上都不是，则 &lt;code&gt;implies&lt;/code&gt; 返回false。</target>
        </trans-unit>
        <trans-unit id="65b4b808e5f83fdac6e6f8fa54fe10637573639b" translate="yes" xml:space="preserve">
          <source>If none of the above cases apply, it is the case that full access (public, package, private, and protected) is allowed. In this case, no suffix is added. This is true only of an object obtained originally from &lt;a href=&quot;methodhandles#lookup--&quot;&gt;&lt;code&gt;MethodHandles.lookup&lt;/code&gt;&lt;/a&gt;. Objects created by &lt;a href=&quot;methodhandles.lookup#in-java.lang.Class-&quot;&gt;&lt;code&gt;Lookup.in&lt;/code&gt;&lt;/a&gt; always have restricted access, and will display a suffix.</source>
          <target state="translated">如果以上情况均不适用，则表示允许完全访问（公共，程序包，私有和受保护）。在这种情况下，不添加后缀。这仅适用于最初从&lt;a href=&quot;methodhandles#lookup--&quot;&gt; &lt;code&gt;MethodHandles.lookup&lt;/code&gt; &lt;/a&gt;获得的对象。由&lt;a href=&quot;methodhandles.lookup#in-java.lang.Class-&quot;&gt; &lt;code&gt;Lookup.in&lt;/code&gt; &lt;/a&gt;创建的对象始终具有受限访问权限，并将显示后缀。</target>
        </trans-unit>
        <trans-unit id="9afb92f74699e092dd43aa6f4a4f20ab8baaf008" translate="yes" xml:space="preserve">
          <source>If none of the package prefixes work, null is returned.</source>
          <target state="translated">如果没有一个包的前缀工作,则返回null。</target>
        </trans-unit>
        <trans-unit id="3aa3a39e0c5471c8e92b9112af6f11814ae21d0e" translate="yes" xml:space="preserve">
          <source>If none of the previous conditions hold then this thread's interrupt status will be set.</source>
          <target state="translated">如果前面的条件都不成立,那么这个线程的中断状态将被设置。</target>
        </trans-unit>
        <trans-unit id="346f69aa8643809549df322ad150080572449fc7" translate="yes" xml:space="preserve">
          <source>If none of these conditions is met, the MBean is invalid and the attempt to register it will generate &lt;a href=&quot;notcompliantmbeanexception&quot;&gt;&lt;code&gt;NotCompliantMBeanException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果不满足这些条件，则MBean无效，并且尝试对其进行注册将生成&lt;a href=&quot;notcompliantmbeanexception&quot;&gt; &lt;code&gt;NotCompliantMBeanException&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2c5743411e869e01038b5d76b71612dce8dfd329" translate="yes" xml:space="preserve">
          <source>If not already completed, causes invocations of &lt;a href=&quot;completablefuture#get--&quot;&gt;&lt;code&gt;get()&lt;/code&gt;&lt;/a&gt; and related methods to throw the given exception.</source>
          <target state="translated">如果尚未完成，则导致&lt;a href=&quot;completablefuture#get--&quot;&gt; &lt;code&gt;get()&lt;/code&gt; &lt;/a&gt;和相关方法的调用引发给定异常。</target>
        </trans-unit>
        <trans-unit id="716a361131a6632fa2e7d2e54111159994780e51" translate="yes" xml:space="preserve">
          <source>If not already completed, completes this CompletableFuture with a &lt;a href=&quot;cancellationexception&quot;&gt;&lt;code&gt;CancellationException&lt;/code&gt;&lt;/a&gt;. Dependent CompletableFutures that have not already completed will also complete exceptionally, with a &lt;a href=&quot;completionexception&quot;&gt;&lt;code&gt;CompletionException&lt;/code&gt;&lt;/a&gt; caused by this &lt;code&gt;CancellationException&lt;/code&gt;.</source>
          <target state="translated">如果尚未完成，请使用&lt;a href=&quot;cancellationexception&quot;&gt; &lt;code&gt;CancellationException&lt;/code&gt; &lt;/a&gt;完成此CompletableFuture 。尚未完成的从属CompletableFutures也将异常例外地完成，该&lt;a href=&quot;completionexception&quot;&gt; &lt;code&gt;CompletionException&lt;/code&gt; &lt;/a&gt;由此 &lt;code&gt;CancellationException&lt;/code&gt; 引起。</target>
        </trans-unit>
        <trans-unit id="2f1a9e000d1c1d155d951430a94c358745c05ace" translate="yes" xml:space="preserve">
          <source>If not already completed, sets the value returned by &lt;a href=&quot;completablefuture#get--&quot;&gt;&lt;code&gt;get()&lt;/code&gt;&lt;/a&gt; and related methods to the given value.</source>
          <target state="translated">如果尚未完成，请将&lt;a href=&quot;completablefuture#get--&quot;&gt; &lt;code&gt;get()&lt;/code&gt; &lt;/a&gt;和相关方法返回的值设置为给定值。</target>
        </trans-unit>
        <trans-unit id="06df59153329c54021d8f318749947771342b429" translate="yes" xml:space="preserve">
          <source>If not running in a ForkJoinPool, this method is behaviorally equivalent to</source>
          <target state="translated">如果不在ForkJoinPool中运行,这个方法在行为上等同于</target>
        </trans-unit>
        <trans-unit id="4963d6f03243f1b1eefc52d1ee78e3de46655e5a" translate="yes" xml:space="preserve">
          <source>If obj is null or not an instance of CompositeName, ClassCastException is thrown.</source>
          <target state="translated">如果obj为空或不是CompositeName的实例,则会抛出ClassCastException。</target>
        </trans-unit>
        <trans-unit id="cfed25f27277239376cbbd5795fd1f2017c24525" translate="yes" xml:space="preserve">
          <source>If obj is null or not an instance of CompoundName, ClassCastException is thrown.</source>
          <target state="translated">如果obj为空或不是CompoundName的实例,则会抛出ClassCastException。</target>
        </trans-unit>
        <trans-unit id="b1c9d5558d685db1a02cae49432f75e2eb93c619" translate="yes" xml:space="preserve">
          <source>If obj is null or not an instance of LdapName, ClassCastException is thrown.</source>
          <target state="translated">如果obj为空或者不是LdapName的实例,则会抛出ClassCastException。</target>
        </trans-unit>
        <trans-unit id="4bf13cf38688995f01fe92d7c8213b9203d51d95" translate="yes" xml:space="preserve">
          <source>If obj is null or not an instance of Rdn, ClassCastException is thrown.</source>
          <target state="translated">如果obj为空或者不是Rdn的实例,则会抛出ClassCastException。</target>
        </trans-unit>
        <trans-unit id="8b1bd38492a7c5fc97a66ea1dc538a1fb693b2c3" translate="yes" xml:space="preserve">
          <source>If obj is null or not an instance of Rdn, false is returned.</source>
          <target state="translated">如果obj为空或者不是Rdn的实例,则返回false。</target>
        </trans-unit>
        <trans-unit id="6bc0bc4fab7d5c4262f47e32108a9c0ec0a06d6f" translate="yes" xml:space="preserve">
          <source>If one is not found, it searches the set of &lt;code&gt;ScriptEngineFactory&lt;/code&gt; instances stored by the constructor for one with the specified name. If a &lt;code&gt;ScriptEngineFactory&lt;/code&gt; is found by either method, it is used to create instance of &lt;code&gt;ScriptEngine&lt;/code&gt;.</source>
          <target state="translated">如果未找到，它将搜索构造函数存储的 &lt;code&gt;ScriptEngineFactory&lt;/code&gt; 实例集，以查找具有指定名称的实例。如果通过任何一种方法找到 &lt;code&gt;ScriptEngineFactory&lt;/code&gt; ，它将用于创建 &lt;code&gt;ScriptEngine&lt;/code&gt; 的实例。</target>
        </trans-unit>
        <trans-unit id="624173e017b005ddaae7fe37b2623ee7c893a0a0" translate="yes" xml:space="preserve">
          <source>If one of the arguments does not occur in the pattern.</source>
          <target state="translated">如果模式中没有出现一个参数。</target>
        </trans-unit>
        <trans-unit id="a2cb09ff6c56a4c92e19e76c548f38b158889e4b" translate="yes" xml:space="preserve">
          <source>If one or both authority components are registry-based then the URIs are ordered according to the ordering of their authority components.</source>
          <target state="translated">如果一个或两个权限组件都是基于注册表的,那么URI将根据其权限组件的顺序进行排序。</target>
        </trans-unit>
        <trans-unit id="2fb7857e904a130ed28ddd9eed419d0b930d6e9e" translate="yes" xml:space="preserve">
          <source>If one or more attributes cannot be retrieved for some reason, they will be omitted from the returned &lt;code&gt;AttributeList&lt;/code&gt;. The caller should check that the list is the same size as the &lt;code&gt;attributes&lt;/code&gt; array. To discover what problem prevented a given attribute from being retrieved, call &lt;a href=&quot;mbeanserverconnection#getAttribute-javax.management.ObjectName-java.lang.String-&quot;&gt;&lt;code&gt;getAttribute&lt;/code&gt;&lt;/a&gt; for that attribute.</source>
          <target state="translated">如果由于某种原因无法检索一个或多个属性，将从返回的 &lt;code&gt;AttributeList&lt;/code&gt; 中将其省略。调用者应检查列表与 &lt;code&gt;attributes&lt;/code&gt; 数组的大小是否相同。要发现什么问题阻止检索给定的属性，请对该属性调用&lt;a href=&quot;mbeanserverconnection#getAttribute-javax.management.ObjectName-java.lang.String-&quot;&gt; &lt;code&gt;getAttribute&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1cb46e59026371f237c846d747b96cfab81aa6f7" translate="yes" xml:space="preserve">
          <source>If one or more attributes cannot be set for some reason, they will be omitted from the returned &lt;code&gt;AttributeList&lt;/code&gt;. The caller should check that the input &lt;code&gt;AttributeList&lt;/code&gt; is the same size as the output one. To discover what problem prevented a given attribute from being retrieved, it will usually be possible to call &lt;a href=&quot;mbeanserverconnection#setAttribute-javax.management.ObjectName-javax.management.Attribute-&quot;&gt;&lt;code&gt;setAttribute&lt;/code&gt;&lt;/a&gt; for that attribute, although this is not guaranteed to work. (For example, the values of two attributes may have been rejected because they were inconsistent with each other. Setting one of them alone might be allowed.)</source>
          <target state="translated">如果由于某种原因无法设置一个或多个属性，则将从返回的 &lt;code&gt;AttributeList&lt;/code&gt; 中将其省略。调用者应检查输入的 &lt;code&gt;AttributeList&lt;/code&gt; 与输出的相同。为了发现是什么问题阻止了给定属性的检索，通常可以为该属性调用&lt;a href=&quot;mbeanserverconnection#setAttribute-javax.management.ObjectName-javax.management.Attribute-&quot;&gt; &lt;code&gt;setAttribute&lt;/code&gt; &lt;/a&gt;，尽管不能保证此方法有效。（例如，两个属性的值可能因为彼此不一致而被拒绝。可以单独设置其中一个。）</target>
        </trans-unit>
        <trans-unit id="fea5108f8ecd0c55ef6981d1ca12427bdd2d199c" translate="yes" xml:space="preserve">
          <source>If one value is a primitive array then the other must be a primitive array of the same type with the same elements.</source>
          <target state="translated">如果一个值是一个基元数组,那么另一个值必须是具有相同元素的相同类型的基元数组。</target>
        </trans-unit>
        <trans-unit id="83b598a4bb6d8d15d44e8e6f9778b65445620655" translate="yes" xml:space="preserve">
          <source>If one value is an object array then the other must be too and &lt;a href=&quot;../../../java/util/arrays#deepEquals-java.lang.Object:A-java.lang.Object:A-&quot;&gt;&lt;code&gt;Arrays.deepEquals&lt;/code&gt;&lt;/a&gt; must return true.</source>
          <target state="translated">如果一个值是对象数组，则另一个值也必须是对象数组，并且&lt;a href=&quot;../../../java/util/arrays#deepEquals-java.lang.Object:A-java.lang.Object:A-&quot;&gt; &lt;code&gt;Arrays.deepEquals&lt;/code&gt; &lt;/a&gt;必须返回true。</target>
        </trans-unit>
        <trans-unit id="ca221d63216bb033111f2713610351d2376eca45" translate="yes" xml:space="preserve">
          <source>If one value is an object array then the other must be too and &lt;a href=&quot;../../java/util/arrays#deepEquals-java.lang.Object:A-java.lang.Object:A-&quot;&gt;&lt;code&gt;Arrays.deepEquals(Object[],Object[])&lt;/code&gt;&lt;/a&gt; must return true.</source>
          <target state="translated">如果一个值是对象数组，则另一个值也必须是&lt;a href=&quot;../../java/util/arrays#deepEquals-java.lang.Object:A-java.lang.Object:A-&quot;&gt; &lt;code&gt;Arrays.deepEquals(Object[],Object[])&lt;/code&gt; &lt;/a&gt;必须返回true。</target>
        </trans-unit>
        <trans-unit id="8317f7140fbe4d8e0a19dbbc989d6c95b4bba3de" translate="yes" xml:space="preserve">
          <source>If one value is null then the other must be too.</source>
          <target state="translated">如果一个值是空的,那么另一个值也一定是空的。</target>
        </trans-unit>
        <trans-unit id="46ccc3cea31a77de6874e4d69188651ef3350460" translate="yes" xml:space="preserve">
          <source>If only public access is allowed, the suffix is &quot;/public&quot;.</source>
          <target state="translated">如果只允许公众访问,后缀为&quot;/public&quot;。</target>
        </trans-unit>
        <trans-unit id="17e35151d3a9c5e62004f06cdd120c3d5af02427" translate="yes" xml:space="preserve">
          <source>If only public and package access are allowed, the suffix is &quot;/package&quot;.</source>
          <target state="translated">如果只允许公开和包的访问,后缀为&quot;/package&quot;。</target>
        </trans-unit>
        <trans-unit id="78a5d707938565d1ab21a382651974405944eeaa" translate="yes" xml:space="preserve">
          <source>If only public, package, and private access are allowed, the suffix is &quot;/private&quot;.</source>
          <target state="translated">如果只允许公开、包和私人访问,则后缀为&quot;/private&quot;。</target>
        </trans-unit>
        <trans-unit id="5ff5bcea26eb9f57c1f61e4d4b69139bd9e67391" translate="yes" xml:space="preserve">
          <source>If passed to the appropriate variant of java.beans.Beans.instantiate this method will be called in order to associate the newly instantiated Applet (JavaBean) with its AppletContext, AppletStub, and Container.</source>
          <target state="translated">如果传递给java.beans.Beans.instantiate的适当变体,这个方法将被调用,以便将新实例化的Applet(JavaBean)与其AppletContext、AppletStub和Container关联起来。</target>
        </trans-unit>
        <trans-unit id="63592e8ff0ed49f336b285894d4830d793307f4a" translate="yes" xml:space="preserve">
          <source>If playback is stopped during looping, the current loop status is cleared; subsequent start requests are not affected by an interrupted loop operation.</source>
          <target state="translated">如果在循环过程中停止播放,则当前的循环状态被清除;后续的启动请求不会受到中断的循环操作的影响。</target>
        </trans-unit>
        <trans-unit id="a9cbc94cbe4e5c51dea79fe6a36851f807b7c43f" translate="yes" xml:space="preserve">
          <source>If playback is stopped during looping, the current loop status is cleared; the behavior of subsequent loop and start requests is not affected by an interrupted loop operation.</source>
          <target state="translated">如果在循环过程中停止播放,则清除当前的循环状态;后续循环和启动请求的行为不受中断的循环操作的影响。</target>
        </trans-unit>
        <trans-unit id="49bbc2bd93bc284a0af94a66587e35a5d285e02f" translate="yes" xml:space="preserve">
          <source>If present, &quot;true&quot; means ignore the case when comparing name components. If its value is not &quot;true&quot;, or if the property is not present, case is considered when comparing name components.</source>
          <target state="translated">如果存在,&quot;true &quot;表示在比较名称组件时忽略大小写。如果它的值不是 &quot;true&quot;,或者如果该属性不存在,那么在比较名称组件时将考虑大小写。</target>
        </trans-unit>
        <trans-unit id="76f581deb106b2ac36d486ca5972b20b2708e882" translate="yes" xml:space="preserve">
          <source>If present, &quot;true&quot; means trim any leading and trailing whitespaces in a name component for comparison purposes. If its value is not &quot;true&quot;, or if the property is not present, blanks are significant.</source>
          <target state="translated">如果存在,&quot;true &quot;意味着修剪名称组件中的任何前导和尾部的空白,以便进行比较。如果它的值不是 &quot;true&quot;,或者如果该属性不存在,则空白是重要的。</target>
        </trans-unit>
        <trans-unit id="f71c029405d6c4413ebcbb2a962ddc2c412a1ce0" translate="yes" xml:space="preserve">
          <source>If present, specifies the escape string for overriding separator, escapes and quotes.</source>
          <target state="translated">如果存在,指定用于覆盖分隔符、转义符和引号的转义字符串。</target>
        </trans-unit>
        <trans-unit id="b3051402e5a243fd5b4ebf35b610a599bf72fd9d" translate="yes" xml:space="preserve">
          <source>If present, specifies the string delimiting start of a quoted string.</source>
          <target state="translated">如果存在,则指定引号字符串的分隔起始点。</target>
        </trans-unit>
        <trans-unit id="ac3c844cdeac2520127d85d40f83a50ed68f9c88" translate="yes" xml:space="preserve">
          <source>If present, specifies the string that separates attribute-value-assertions when specifying multiple attribute/value pairs. (e.g. &quot;,&quot; in age=65,gender=male).</source>
          <target state="translated">如果存在,指定在指定多个属性/值对时分隔属性-值-断言的字符串。(例如:age=65,gender=male中的&quot;,&quot;)。</target>
        </trans-unit>
        <trans-unit id="839f44a4939d27c69ac39a75a7ee01b1f1bbc830" translate="yes" xml:space="preserve">
          <source>If present, specifies the string that separators attribute from value (e.g. &quot;=&quot; in &quot;age=65&quot;)</source>
          <target state="translated">如果存在,指定从值中分离属性的字符串(例如 &quot;age=65 &quot;中的&quot;=&quot;)。</target>
        </trans-unit>
        <trans-unit id="a8b99e1ebf742f5bd861cd2fd56fba8c921820bf" translate="yes" xml:space="preserve">
          <source>If print data is obtained from the client as a stream, by calling Doc's &lt;code&gt;getReaderForText()&lt;/code&gt; or &lt;code&gt;getStreamForBytes()&lt;/code&gt; methods, or because the print data source is already an InputStream or Reader, then the print service should always close these streams for the client on all job completion conditions. With the following caveat. If the print data is itself a stream, the service will always close it. If the print data is otherwise something that can be requested as a stream, the service will only close the stream if it has obtained the stream before terminating. That is, just because a print service might request data as a stream does not mean that it will, with the implications that Doc implementors which rely on the service to close them should create such streams only in response to a request from the service.</source>
          <target state="translated">如果从客户端以流形式获取打印数据，则通过调用Doc的 &lt;code&gt;getReaderForText()&lt;/code&gt; 或 &lt;code&gt;getStreamForBytes()&lt;/code&gt; 方法，或者因为打印数据源已经是InputStream或Reader，则打印服务应始终在所有作业完成条件下为客户端关闭这些流。以下警告。如果打印数据本身是流，则服务将始终关闭它。如果打印数据是另外可以作为流请求的内容，则服务将仅在终止之前获得流的情况下关闭流。也就是说，仅因为打印服务可能以流的形式请求数据，并不意味着它将这样做，这意味着依赖该服务的Doc实现者应该关闭这些数据，以仅响应该服务的请求而创建此类流。</target>
        </trans-unit>
        <trans-unit id="698e747d05614178dfac851043daa01f20a613ea" translate="yes" xml:space="preserve">
          <source>If readUnshared is called to deserialize a back-reference (the stream representation of an object which has been written previously to the stream), an ObjectStreamException will be thrown.</source>
          <target state="translated">如果调用readUnshared来反序列化一个回溯引用(之前已经写入流的对象的流表示),将抛出一个ObjectStreamException。</target>
        </trans-unit>
        <trans-unit id="b4f57444325034269269b979e9040fba82af28a1" translate="yes" xml:space="preserve">
          <source>If readUnshared returns successfully, then any subsequent attempts to deserialize back-references to the stream handle deserialized by readUnshared will cause an ObjectStreamException to be thrown.</source>
          <target state="translated">如果readUnshared成功返回,那么后续任何试图反序列化被readUnshared反序列化的流句柄的回溯引用,都会导致一个ObjectStreamException被抛出。</target>
        </trans-unit>
        <trans-unit id="fa301e6f70a966a031213bd64c45f05d89ac7164" translate="yes" xml:space="preserve">
          <source>If resolution should be possible, but the data is invalid, the resolver style should be used to determine an appropriate level of leniency, which may require throwing a &lt;code&gt;DateTimeException&lt;/code&gt; or &lt;code&gt;ArithmeticException&lt;/code&gt;. If no resolution is possible, the resolve method must return null.</source>
          <target state="translated">如果可以解决，但数据无效，则应使用解析器样式来确定适当的宽大处理级别，这可能需要抛出 &lt;code&gt;DateTimeException&lt;/code&gt; 或 &lt;code&gt;ArithmeticException&lt;/code&gt; 。如果无法解决，则resolve方法必须返回null。</target>
        </trans-unit>
        <trans-unit id="3812495ff2c8cc9bdfa1044d03962dc8bf6711c5" translate="yes" xml:space="preserve">
          <source>If running in a ForkJoinPool, the pool may first be expanded to ensure sufficient parallelism available during the call to &lt;code&gt;blocker.block()&lt;/code&gt;.</source>
          <target state="translated">如果在ForkJoinPool中运行，则可以首先扩展池，以确保在调用 &lt;code&gt;blocker.block()&lt;/code&gt; 期间有足够的并行性。</target>
        </trans-unit>
        <trans-unit id="ae78817156ff952aba10e581c466f3b983c1decc" translate="yes" xml:space="preserve">
          <source>If script or extensions are present and variant is missing, no underscore is added before the &quot;#&quot;.</source>
          <target state="translated">如果存在脚本或扩展名而缺少变体,则 &quot;#&quot;前不加下划线。</target>
        </trans-unit>
        <trans-unit id="aca1859a49861db1474a56d8e3d2f23a51a9b08b" translate="yes" xml:space="preserve">
          <source>If set, the creation time will be stored into the extended timestamp fields of entry's &lt;code&gt;optional extra data&lt;/code&gt;, when output to a ZIP file or ZIP file formatted stream.</source>
          <target state="translated">如果设置，则创建时间将在输出到ZIP文件或ZIP文件格式的流时存储在条目的 &lt;code&gt;optional extra data&lt;/code&gt; 的扩展时间戳字段中。</target>
        </trans-unit>
        <trans-unit id="254aa9b5d6babc55c52a29bf015e860182b09607" translate="yes" xml:space="preserve">
          <source>If set, the data will be written out in a top-down manner, the first scanline being written first.</source>
          <target state="translated">如果设置,则数据将以自上而下的方式写出,第一条扫描线先写。</target>
        </trans-unit>
        <trans-unit id="d3fe3fca46a00d556efb3e52ff334ccc25f6d2f2" translate="yes" xml:space="preserve">
          <source>If set, the last access time will be stored into the extended timestamp fields of entry's &lt;code&gt;optional extra data&lt;/code&gt;, when output to a ZIP file or ZIP file formatted stream.</source>
          <target state="translated">如果设置，则最后一次访问时间在输出到ZIP文件或ZIP文件格式的流时，将存储到条目的 &lt;code&gt;optional extra data&lt;/code&gt; 的扩展时间戳字段中。</target>
        </trans-unit>
        <trans-unit id="8f308d30cc56ad52b3bab469509470a688175d5d" translate="yes" xml:space="preserve">
          <source>If several threads simultaneously execute a bootstrap method for a single dynamic call site, the JVM must choose one &lt;code&gt;CallSite&lt;/code&gt; object and install it visibly to all threads. Any other bootstrap method calls are allowed to complete, but their results are ignored, and their dynamic call site invocations proceed with the originally chosen target object.</source>
          <target state="translated">如果多个线程同时为一个动态调用站点执行引导程序方法，则JVM必须选择一个 &lt;code&gt;CallSite&lt;/code&gt; 对象并将其可视地安装到所有线程。任何其他引导方法调用都可以完成，但是其结果将被忽略，并且它们的动态调用站点调用将以最初选择的目标对象进行。</target>
        </trans-unit>
        <trans-unit id="3080743f4d15c8fc1f75465fc6801e428e44fe7c" translate="yes" xml:space="preserve">
          <source>If some listeners have been added with a named property, then the returned array will be a mixture of PropertyChangeListeners and &lt;code&gt;PropertyChangeListenerProxy&lt;/code&gt;s. If the calling method is interested in distinguishing the listeners then it must test each element to see if it's a &lt;code&gt;PropertyChangeListenerProxy&lt;/code&gt;, perform the cast, and examine the parameter.</source>
          <target state="translated">如果添加了带有命名属性的某些侦听器，则返回的数组将是PropertyChangeListeners和 &lt;code&gt;PropertyChangeListenerProxy&lt;/code&gt; 的混合。如果调用方法有兴趣区分侦听器，则它必须测试每个元素以查看它是否是 &lt;code&gt;PropertyChangeListenerProxy&lt;/code&gt; ，执行强制转换并检查参数。</target>
        </trans-unit>
        <trans-unit id="6cf497c1785865189fe796ed0e1d220915d011be" translate="yes" xml:space="preserve">
          <source>If some listeners have been added with a named property, then the returned array will be a mixture of VetoableChangeListeners and &lt;code&gt;VetoableChangeListenerProxy&lt;/code&gt;s. If the calling method is interested in distinguishing the listeners then it must test each element to see if it's a &lt;code&gt;VetoableChangeListenerProxy&lt;/code&gt;, perform the cast, and examine the parameter.</source>
          <target state="translated">如果添加了具有命名属性的某些侦听器，则返回的数组将是VetoableChangeListeners和 &lt;code&gt;VetoableChangeListenerProxy&lt;/code&gt; 的混合。如果调用方法有兴趣区分侦听器，则它必须测试每个元素以查看它是否是 &lt;code&gt;VetoableChangeListenerProxy&lt;/code&gt; ，执行强制转换并检查参数。</target>
        </trans-unit>
        <trans-unit id="36119d6ef751d0ba1a40bc06d8c08c0232acb626" translate="yes" xml:space="preserve">
          <source>If still no result bundle is found, the base name alone is looked up. If this still fails, a &lt;code&gt;MissingResourceException&lt;/code&gt; is thrown.</source>
          <target state="translated">如果仍未找到结果包，则仅查找基本名称。如果仍然失败，则抛出 &lt;code&gt;MissingResourceException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="49c2d956b15c160db2755278d76b95411d1638e9" translate="yes" xml:space="preserve">
          <source>If such a service has been registered with the context, or one of its nesting context's, in the case where a context delegate to its context to satisfy a service request, then the BeanContextServiceProvider associated with the service is asked to provide an instance of that service.</source>
          <target state="translated">如果这样的服务已经在上下文或它的一个嵌套上下文中注册,在上下文委托给它的上下文以满足服务请求的情况下,那么与服务相关联的BeanContextServiceProvider被要求提供该服务的实例。</target>
        </trans-unit>
        <trans-unit id="94b0570a3ef5bacc1df2844b6f6f55155f5164cd" translate="yes" xml:space="preserve">
          <source>If such an &lt;code&gt;IOException&lt;/code&gt; is not thrown, then the stream is reset to a state such that all the bytes read since the most recent call to &lt;code&gt;mark&lt;/code&gt; (or since the start of the file, if &lt;code&gt;mark&lt;/code&gt; has not been called) will be resupplied to subsequent callers of the &lt;code&gt;read&lt;/code&gt; method, followed by any bytes that otherwise would have been the next input data as of the time of the call to &lt;code&gt;reset&lt;/code&gt;.</source>
          <target state="translated">如果未抛出这样的 &lt;code&gt;IOException&lt;/code&gt; ，则将流重置为一种状态，以便将自最近一次对 &lt;code&gt;mark&lt;/code&gt; 的调用（或从文件的开始，如果尚未调用 &lt;code&gt;mark&lt;/code&gt; ）以来读取的所有字节重新提供给后续操作。调用 &lt;code&gt;read&lt;/code&gt; 方法的调用者，后跟截至 &lt;code&gt;reset&lt;/code&gt; 调用时本来应该是下一个输入数据的任何字节。</target>
        </trans-unit>
        <trans-unit id="ba67a915702ddd93a2439399e9e5620bf22a0c62" translate="yes" xml:space="preserve">
          <source>If such an error is thrown then subsequent invocations of the iterator will make a best effort to locate and instantiate the next available provider, but in general such recovery cannot be guaranteed.</source>
          <target state="translated">如果抛出这样的错误,那么后续对迭代器的调用将尽最大努力定位并实例化下一个可用的提供者,但一般情况下,这种恢复无法保证。</target>
        </trans-unit>
        <trans-unit id="483297556e0d86a729fc879bc3d6a3a654a16eca" translate="yes" xml:space="preserve">
          <source>If system exclusive data from &lt;code&gt;SysexMessages&lt;/code&gt; objects is being transmitted using MIDI wire protocol, only the initial 0xF0 status byte, the system exclusive data itself, and the final 0xF7 (EOX) byte should be propagated; any 0xF7 status bytes used to indicate that a &lt;code&gt;SysexMessage&lt;/code&gt; contains continuing system exclusive data should not be propagated via MIDI wire protocol.</source>
          <target state="translated">如果使用MIDI有线协议传输 &lt;code&gt;SysexMessages&lt;/code&gt; 对象的系统独占数据，则仅应传播初始的0xF0状态字节，系统独占数据本身和最后的0xF7（EOX）字节；用于指示 &lt;code&gt;SysexMessage&lt;/code&gt; 包含连续的系统独占数据的任何0xF7状态字节都不应通过MIDI有线协议传播。</target>
        </trans-unit>
        <trans-unit id="8a60148766d9542dcdda7613f880094d44b2ef2c" translate="yes" xml:space="preserve">
          <source>If system properties &lt;code&gt;javax.sound.sampled.Clip&lt;/code&gt;, &lt;code&gt;javax.sound.sampled.Port&lt;/code&gt;, &lt;code&gt;javax.sound.sampled.SourceDataLine&lt;/code&gt; and &lt;code&gt;javax.sound.sampled.TargetDataLine&lt;/code&gt; are defined or they are defined in the file &quot;sound.properties&quot;, they are used to retrieve default lines. For details, refer to the &lt;a href=&quot;audiosystem&quot;&gt;&lt;code&gt;class description&lt;/code&gt;&lt;/a&gt;. If the respective property is not set, or the mixer requested in the property is not installed or does not provide the requested line, all installed mixers are queried for the requested line type. A Line will be returned from the first mixer providing the requested line type.</source>
          <target state="translated">如果定义了系统属性 &lt;code&gt;javax.sound.sampled.Clip&lt;/code&gt; ， &lt;code&gt;javax.sound.sampled.Port&lt;/code&gt; ， &lt;code&gt;javax.sound.sampled.SourceDataLine&lt;/code&gt; 和 &lt;code&gt;javax.sound.sampled.TargetDataLine&lt;/code&gt; 或在文件&amp;ldquo; sound.properties&amp;rdquo;中定义了它们，用于检索默认行。有关详细信息，请参阅&lt;a href=&quot;audiosystem&quot;&gt; &lt;code&gt;class description&lt;/code&gt; &lt;/a&gt;。如果未设置相应的属性，或者未安装该属性中请求的混合器或未提供请求的行，则将查询所有已安装的混合器以获取请求的行类型。从第一台调音台返回的线路将提供所请求的线路类型。</target>
        </trans-unit>
        <trans-unit id="1f583398dc1f86dc2870e17e17525bfe7bcb7fe2" translate="yes" xml:space="preserve">
          <source>If the &quot;java.util.logging.config.class&quot; property is set, then the property value is treated as a class name. The given class will be loaded, an object will be instantiated, and that object's constructor is responsible for reading in the initial configuration. (That object may use other system properties to control its configuration.) The alternate configuration class can use &lt;code&gt;readConfiguration(InputStream)&lt;/code&gt; to define properties in the LogManager.</source>
          <target state="translated">如果设置了&amp;ldquo; java.util.logging.config.class&amp;rdquo;属性，则将该属性值视为类名。给定的类将被加载，一个对象将被实例化，并且该对象的构造函数负责读取初始配置。（该对象可以使用其他系统属性来控制其配置。）备用配置类可以使用 &lt;code&gt;readConfiguration(InputStream)&lt;/code&gt; 在LogManager中定义属性。</target>
        </trans-unit>
        <trans-unit id="2d3e35bcf72871950c117a29249ba322eaf7916a" translate="yes" xml:space="preserve">
          <source>If the 'getMethod' field contains the name of a valid operation descriptor, then the method described by the operation descriptor is executed. The response from the method is returned as the value of the attribute. If the operation fails or the returned value is not compatible with the declared type of the attribute, an exception will be thrown.</source>
          <target state="translated">如果'getMethod'字段包含一个有效的操作描述符的名称,那么操作描述符所描述的方法将被执行。该方法的响应将作为属性的值返回。如果操作失败或者返回的值与属性的声明类型不兼容,则会抛出一个异常。</target>
        </trans-unit>
        <trans-unit id="0cf976d251facbb1b28639a31b11358b94746e84" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;beaninfo&quot;&gt;&lt;code&gt;BeanInfo&lt;/code&gt;&lt;/a&gt; for this type has a &lt;a href=&quot;beandescriptor&quot;&gt;&lt;code&gt;BeanDescriptor&lt;/code&gt;&lt;/a&gt; which defined a &quot;persistenceDelegate&quot; attribute, the value of this named attribute is returned.</source>
          <target state="translated">如果此类型的&lt;a href=&quot;beaninfo&quot;&gt; &lt;code&gt;BeanInfo&lt;/code&gt; &lt;/a&gt;具有定义了&amp;ldquo; persistenceDelegate&amp;rdquo;属性的&lt;a href=&quot;beandescriptor&quot;&gt; &lt;code&gt;BeanDescriptor&lt;/code&gt; &lt;/a&gt;，则将返回此命名属性的值。</target>
        </trans-unit>
        <trans-unit id="f7796e655e99564bb42833b6c22ae781567c8b7e" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;processbuilder#redirectErrorStream&quot;&gt;&lt;code&gt;redirectErrorStream&lt;/code&gt;&lt;/a&gt; attribute has been set &lt;code&gt;true&lt;/code&gt;, then the redirection set by this method has no effect.</source>
          <target state="translated">如果&lt;a href=&quot;processbuilder#redirectErrorStream&quot;&gt; &lt;code&gt;redirectErrorStream&lt;/code&gt; &lt;/a&gt;属性设置为 &lt;code&gt;true&lt;/code&gt; ，则此方法设置的重定向无效。</target>
        </trans-unit>
        <trans-unit id="69cea4d19b20fb91d97db82c5ca57aaf842e28d6" translate="yes" xml:space="preserve">
          <source>If the &lt;a name=&quot;floatDPrec&quot;&gt;conversion&lt;/a&gt; is &lt;code&gt;'e'&lt;/code&gt;, &lt;code&gt;'E'&lt;/code&gt; or &lt;code&gt;'f'&lt;/code&gt;, then the precision is the number of digits after the decimal separator. If the precision is not specified, then it is assumed to be &lt;code&gt;6&lt;/code&gt;.</source>
          <target state="translated">如果&lt;a name=&quot;floatDPrec&quot;&gt;转换&lt;/a&gt;为 &lt;code&gt;'e'&lt;/code&gt; ， &lt;code&gt;'E'&lt;/code&gt; 或 &lt;code&gt;'f'&lt;/code&gt; ，则精度为小数点分隔符后的位数。如果未指定精度，则假定为 &lt;code&gt;6&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="244d88b2fe1f7cc3d006bcc6bed47c61fe2ec794" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&quot;zh&quot;&lt;/code&gt;-to-&lt;code&gt;&quot;zh&quot;&lt;/code&gt; mapping isn't included in the map, a simple replacement will be performed and the customized list won't include &lt;code&gt;&quot;zh&quot;&lt;/code&gt; and &lt;code&gt;&quot;zh-CN&quot;&lt;/code&gt;.</source>
          <target state="translated">如果映射中不包含 &lt;code&gt;&quot;zh&quot;&lt;/code&gt; 到 &lt;code&gt;&quot;zh&quot;&lt;/code&gt; 映射，则将执行简单替换，并且自定义列表将不包含 &lt;code&gt;&quot;zh&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;zh-CN&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="23f4d1d76d4c61640485815093054acc02ce819f" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;'#'&lt;/code&gt; flag is given &lt;a href=&quot;formatflagsconversionmismatchexception&quot;&gt;&lt;code&gt;FormatFlagsConversionMismatchException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">如果给定 &lt;code&gt;'#'&lt;/code&gt; 标志，&lt;a href=&quot;formatflagsconversionmismatchexception&quot;&gt; &lt;code&gt;FormatFlagsConversionMismatchException&lt;/code&gt; &lt;/a&gt;引发FormatFlagsConversionMismatchException。</target>
        </trans-unit>
        <trans-unit id="1c680cd1a5cd595f752bed838baa38292f42bbcd" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;'#'&lt;/code&gt; flag is given and the argument is not a &lt;a href=&quot;formattable&quot;&gt;&lt;code&gt;Formattable&lt;/code&gt;&lt;/a&gt; , then a &lt;a href=&quot;formatflagsconversionmismatchexception&quot;&gt;&lt;code&gt;FormatFlagsConversionMismatchException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">如果给出 &lt;code&gt;'#'&lt;/code&gt; 标志并且参数不是&lt;a href=&quot;formattable&quot;&gt; &lt;code&gt;Formattable&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;formatflagsconversionmismatchexception&quot;&gt; &lt;code&gt;FormatFlagsConversionMismatchException&lt;/code&gt; &lt;/a&gt;引发FormatFlagsConversionMismatchException。</target>
        </trans-unit>
        <trans-unit id="8f3ca6b4a24528a74561304ff78b46e45f7ce091" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;'#'&lt;/code&gt; flag is given then a &lt;a href=&quot;formatflagsconversionmismatchexception&quot;&gt;&lt;code&gt;FormatFlagsConversionMismatchException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">如果给出 &lt;code&gt;'#'&lt;/code&gt; 标志，&lt;a href=&quot;formatflagsconversionmismatchexception&quot;&gt; &lt;code&gt;FormatFlagsConversionMismatchException&lt;/code&gt; &lt;/a&gt;引发FormatFlagsConversionMismatchException。</target>
        </trans-unit>
        <trans-unit id="95f5e2ee606537dc80cd0c08600e71779319b292" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;'#'&lt;/code&gt; flag is given then an &lt;a href=&quot;formatflagsconversionmismatchexception&quot;&gt;&lt;code&gt;FormatFlagsConversionMismatchException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">如果给出 &lt;code&gt;'#'&lt;/code&gt; 标志，&lt;a href=&quot;formatflagsconversionmismatchexception&quot;&gt; &lt;code&gt;FormatFlagsConversionMismatchException&lt;/code&gt; &lt;/a&gt;引发FormatFlagsConversionMismatchException。</target>
        </trans-unit>
        <trans-unit id="705393d5e4190c15bb4ded3f92e669b7967af3af" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;'#'&lt;/code&gt; flag is given then the output will always begin with &lt;code&gt;'0'&lt;/code&gt; prefix.</source>
          <target state="translated">如果给出 &lt;code&gt;'#'&lt;/code&gt; 标志，则输出将始终以 &lt;code&gt;'0'&lt;/code&gt; 前缀开头。</target>
        </trans-unit>
        <trans-unit id="d94fd5d1c396bfff4fed3e4917313944fa0d8ce4" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;'#'&lt;/code&gt; flag is given then the output will always begin with the radix indicator &lt;code&gt;&quot;0x&quot;&lt;/code&gt;.</source>
          <target state="translated">如果给出 &lt;code&gt;'#'&lt;/code&gt; 标志，则输出将始终以基数指示符 &lt;code&gt;&quot;0x&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="af351499ffe1eb584449ad1db1312af2f6169806" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;'#'&lt;/code&gt; flag is given then the output will always begin with the radix indicator &lt;code&gt;'0'&lt;/code&gt;.</source>
          <target state="translated">如果给出 &lt;code&gt;'#'&lt;/code&gt; 标志，那么输出将始终以基数指示符 &lt;code&gt;'0'&lt;/code&gt; 开始。</target>
        </trans-unit>
        <trans-unit id="2e2b33eac4b29de7dc276798ef6bb121e0f191c3" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;'#'&lt;/code&gt; flag is given, then a &lt;a href=&quot;formatflagsconversionmismatchexception&quot;&gt;&lt;code&gt;FormatFlagsConversionMismatchException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">如果给出 &lt;code&gt;'#'&lt;/code&gt; 标志，&lt;a href=&quot;formatflagsconversionmismatchexception&quot;&gt; &lt;code&gt;FormatFlagsConversionMismatchException&lt;/code&gt; &lt;/a&gt;引发FormatFlagsConversionMismatchException。</target>
        </trans-unit>
        <trans-unit id="193a49527f28f69b767038d67c1984e036b12529" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;'#'&lt;/code&gt; flag is given, then the decimal separator will always be present.</source>
          <target state="translated">如果给出 &lt;code&gt;'#'&lt;/code&gt; 标志，则十进制分隔符将始终存在。</target>
        </trans-unit>
        <trans-unit id="170d2f39d6b7a451069152ef956aa45571ac5f4f" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;'('&lt;/code&gt; or &lt;code&gt;','&lt;/code&gt; flags are given, then a &lt;a href=&quot;formatflagsconversionmismatchexception&quot;&gt;&lt;code&gt;FormatFlagsConversionMismatchException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">如果给出了 &lt;code&gt;'('&lt;/code&gt; 或 &lt;code&gt;','&lt;/code&gt; 标志，&lt;a href=&quot;formatflagsconversionmismatchexception&quot;&gt; &lt;code&gt;FormatFlagsConversionMismatchException&lt;/code&gt; &lt;/a&gt;引发FormatFlagsConversionMismatchException。</target>
        </trans-unit>
        <trans-unit id="25f8f50b77134591d75e17a674bec028e9c6e997" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;'+'&lt;/code&gt; flag is given and the value is positive or zero (or floating-point positive zero), then a &lt;code&gt;'+'&lt;/code&gt; (&lt;code&gt;'\u002b'&lt;/code&gt;) will be prepended.</source>
          <target state="translated">如果给出了 &lt;code&gt;'+'&lt;/code&gt; 标志，并且该值是正数或零（或浮点数正零），则将添加 &lt;code&gt;'+'&lt;/code&gt; （ &lt;code&gt;'\u002b'&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="910241aebecc3c9182f2e0462c8f58f123333d6e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;','&lt;/code&gt; (&lt;code&gt;'\u002c'&lt;/code&gt;) &lt;a name=&quot;L10nGroup&quot;&gt;flag&lt;/a&gt; is given, then the locale-specific &lt;a href=&quot;../text/decimalformatsymbols#getGroupingSeparator--&quot;&gt;grouping separator&lt;/a&gt; is inserted by scanning the integer part of the string from least significant to most significant digits and inserting a separator at intervals defined by the locale's &lt;a href=&quot;../text/decimalformat#getGroupingSize--&quot;&gt;grouping size&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;','&lt;/code&gt; （ &lt;code&gt;'\u002c'&lt;/code&gt; ）&lt;a name=&quot;L10nGroup&quot;&gt;标志&lt;/a&gt;给出，那么语言环境的特定的&lt;a href=&quot;../text/decimalformatsymbols#getGroupingSeparator--&quot;&gt;分组分离器&lt;/a&gt;通过在由语言环境的定义的时间间隔扫描所述字符串从至少显著到最显著位数的整数部分和插入一个分离器被插入&lt;a href=&quot;../text/decimalformat#getGroupingSize--&quot;&gt;分组大小&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="44a9f549cf29b75acc2fdec3fc183e7f16568846" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;','&lt;/code&gt; flag is given then a &lt;a href=&quot;formatflagsconversionmismatchexception&quot;&gt;&lt;code&gt;FormatFlagsConversionMismatchException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">如果给定 &lt;code&gt;','&lt;/code&gt; 标志，&lt;a href=&quot;formatflagsconversionmismatchexception&quot;&gt; &lt;code&gt;FormatFlagsConversionMismatchException&lt;/code&gt; &lt;/a&gt;引发FormatFlagsConversionMismatchException。</target>
        </trans-unit>
        <trans-unit id="45726f7fab2e09c7f3869df2e50226749801e01e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;','&lt;/code&gt; flag is given, then an &lt;a href=&quot;formatflagsconversionmismatchexception&quot;&gt;&lt;code&gt;FormatFlagsConversionMismatchException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">如果给出 &lt;code&gt;','&lt;/code&gt; 标志，&lt;a href=&quot;formatflagsconversionmismatchexception&quot;&gt; &lt;code&gt;FormatFlagsConversionMismatchException&lt;/code&gt; &lt;/a&gt;引发FormatFlagsConversionMismatchException。</target>
        </trans-unit>
        <trans-unit id="970c69f921423c9cb9e926402bc01ce17c9690e0" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;'-'&lt;/code&gt; flag is not given, then the space padding will occur before the sign.</source>
          <target state="translated">如果未给出 &lt;code&gt;'-'&lt;/code&gt; 标志，则空格将在符号前出现。</target>
        </trans-unit>
        <trans-unit id="4999add0ec4ab7e8f065de52e1702ab41f20c0ce" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;'0'&lt;/code&gt; flag is given and the value is negative, then the zero padding will occur after the sign.</source>
          <target state="translated">如果给定了 &lt;code&gt;'0'&lt;/code&gt; 标志且该值为负，则零填充将在符号后发生。</target>
        </trans-unit>
        <trans-unit id="5c36904575776fe73769eda50759d8e13da3acc3" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;'0'&lt;/code&gt; flag is given then the output will be padded to the field width with leading zeros after the radix indicator or sign (if present).</source>
          <target state="translated">如果给定 &lt;code&gt;'0'&lt;/code&gt; 标志，则输出将在基数指示符或符号（如果存在）之后用前导零填充到字段宽度。</target>
        </trans-unit>
        <trans-unit id="b5e7f4a54ddb769b1293d2814dfdf865f8198b97" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;'0'&lt;/code&gt; flag is given then the output will be padded with leading zeros to the field width following any indication of sign.</source>
          <target state="translated">如果给定 &lt;code&gt;'0'&lt;/code&gt; 标志，则输出将在任何符号指示后填充前导零到字段宽度。</target>
        </trans-unit>
        <trans-unit id="ba1bcf00b5c45bf451134d21adaed5e63f1fcd56" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;'0'&lt;/code&gt; flag is given, then the locale-specific &lt;a href=&quot;../text/decimalformatsymbols#getZeroDigit--&quot;&gt;zero digits&lt;/a&gt; are inserted after the sign character, if any, and before the first non-zero digit, until the length of the string is equal to the requested field width.</source>
          <target state="translated">如果 &lt;code&gt;'0'&lt;/code&gt; 标志被给出，那么语言环境的具体的&lt;a href=&quot;../text/decimalformatsymbols#getZeroDigit--&quot;&gt;零位&lt;/a&gt;被符号字符之后插入，如果有的话，和第一非零数字之前，直到该字符串的长度等于所请求的字段宽度。</target>
        </trans-unit>
        <trans-unit id="9ecc4eb34ec8dfb382771373ad86df4d2c178e13" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Collection&lt;/code&gt; will be modified by one thread while another thread is calling a method of a Collection &lt;code&gt;CertStore&lt;/code&gt; that has been initialized with this &lt;code&gt;Collection&lt;/code&gt;, the &lt;code&gt;Collection&lt;/code&gt; must have fail-fast iterators.</source>
          <target state="translated">如果一个线程将修改 &lt;code&gt;Collection&lt;/code&gt; ，而另一个线程正在调用已使用此 &lt;code&gt;Collection&lt;/code&gt; 初始化的Collection &lt;code&gt;CertStore&lt;/code&gt; 的方法，则 &lt;code&gt;Collection&lt;/code&gt; 必须具有快速失败的迭代器。</target>
        </trans-unit>
        <trans-unit id="810e8374c563e183f8b4590c3bc968fbd81b2167" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;CompositeData&lt;/code&gt; came from an earlier version of &lt;em&gt;J&lt;/em&gt;, some items might not be present. In this case, the corresponding setters will not be called.</source>
          <target state="translated">如果 &lt;code&gt;CompositeData&lt;/code&gt; 来自&lt;em&gt;J&lt;/em&gt;的早期版本，则某些项目可能不存在。在这种情况下，将不会调用相应的二传手。</target>
        </trans-unit>
        <trans-unit id="179c5197a088bdfb3577b89615e0f80069ec54a3" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;ExecuteExistingDelayedTasksAfterShutdownPolicy&lt;/code&gt; has been set &lt;code&gt;false&lt;/code&gt;, existing delayed tasks whose delays have not yet elapsed are cancelled. And unless the &lt;code&gt;ContinueExistingPeriodicTasksAfterShutdownPolicy&lt;/code&gt; has been set &lt;code&gt;true&lt;/code&gt;, future executions of existing periodic tasks will be cancelled.</source>
          <target state="translated">如果 &lt;code&gt;ExecuteExistingDelayedTasksAfterShutdownPolicy&lt;/code&gt; 设置为 &lt;code&gt;false&lt;/code&gt; ，则将取消尚未延迟的现有延迟任务。并且，除非将 &lt;code&gt;ContinueExistingPeriodicTasksAfterShutdownPolicy&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; ，否则将取消现有定期任务的将来执行。</target>
        </trans-unit>
        <trans-unit id="4d9438386cfe32fda0c1181ccd31aab76978f092" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;InvocationHandler&lt;/code&gt; is for an MXBean, then the parameters of a method are converted from the type declared in the MXBean interface into the corresponding mapped type, and the return value is converted from the mapped type into the declared type. For example, with the method</source>
          <target state="translated">如果 &lt;code&gt;InvocationHandler&lt;/code&gt; 用于MXBean，则将方法的参数从MXBean接口中声明的类型转换为相应的映射类型，并将返回值从映射类型转换为声明的类型。例如，用</target>
        </trans-unit>
        <trans-unit id="b773147646e5d6ae4684d585a997f76f520542ef" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;JMXServiceURL&lt;/code&gt; is:</source>
          <target state="translated">如果 &lt;code&gt;JMXServiceURL&lt;/code&gt; 为：</target>
        </trans-unit>
        <trans-unit id="3f268e97c59dcc626388a2e991c9c9562516a82d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;JMXServiceURL&lt;/code&gt; uses the directory syntax, as described above under &lt;a href=&quot;#directory&quot;&gt;&quot;connector addresses based on directory entries&quot;&lt;/a&gt;, then the client may obtain it as just explained, or client and server may both know the appropriate directory entry to use. For example, if the connector server for the Whatsit agent uses the entry &lt;code&gt;whatsit-agent-connector&lt;/code&gt; in the RMI registry on host &lt;code&gt;myhost&lt;/code&gt;, then client and server can both know that the appropriate &lt;code&gt;JMXServiceURL&lt;/code&gt; is:</source>
          <target state="translated">如果 &lt;code&gt;JMXServiceURL&lt;/code&gt; 使用目录语法（如上文&lt;a href=&quot;#directory&quot;&gt;&amp;ldquo;基于目录条目的连接器地址&amp;rdquo;所述）&lt;/a&gt;，则客户端可以如刚刚解释的那样获取它，或者客户端和服务器都可以知道要使用的适当目录条目。例如，如果Whatsit代理的连接器服务器在主机 &lt;code&gt;myhost&lt;/code&gt; 的RMI注册表中使用条目 &lt;code&gt;whatsit-agent-connector&lt;/code&gt; ，则客户端和服务器都可以知道适当的 &lt;code&gt;JMXServiceURL&lt;/code&gt; 为：</target>
        </trans-unit>
        <trans-unit id="3f826af6b5dd95bfc92e77f04fdf460591da5f81" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;JMXServiceURL&lt;/code&gt; was generated by the server, as described above under &lt;a href=&quot;#servergen&quot;&gt;&quot;connector addresses generated by the server&quot;&lt;/a&gt;, then the client will need to obtain it directly or indirectly from the server. Typically, the server makes the &lt;code&gt;JMXServiceURL&lt;/code&gt; available by storing it in a file or a lookup service.</source>
          <target state="translated">如果 &lt;code&gt;JMXServiceURL&lt;/code&gt; 是由服务器生成的，如上面&lt;a href=&quot;#servergen&quot;&gt;&amp;ldquo;服务器生成的连接器地址&amp;rdquo;下所述&lt;/a&gt;，则客户端将需要直接或间接从服务器获取它。通常，服务器通过将 &lt;code&gt;JMXServiceURL&lt;/code&gt; 存储在文件或查找服务中来使其可用。</target>
        </trans-unit>
        <trans-unit id="e3f171d07666393092d63f7170ed5ec052f7118d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Level&lt;/code&gt; of the specified logger is &lt;code&gt;null&lt;/code&gt;, which means that this logger's effective level is inherited from its parent, an empty string will be returned.</source>
          <target state="translated">如果指定记录器的 &lt;code&gt;Level&lt;/code&gt; 为 &lt;code&gt;null&lt;/code&gt; ，这意味着该记录器的有效级别是从其父级继承的，则将返回一个空字符串。</target>
        </trans-unit>
        <trans-unit id="458d82c56d9fb33c66e562fe6ab97aea8cc80904" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;MBeanPermission&lt;/code&gt; check succeeds, the MBean's class is validated by checking that its &lt;a href=&quot;../../java/security/protectiondomain&quot;&gt;&lt;code&gt;ProtectionDomain&lt;/code&gt;&lt;/a&gt; implies &lt;a href=&quot;mbeantrustpermission#MBeanTrustPermission-java.lang.String-&quot;&gt;&lt;code&gt;MBeanTrustPermission(&quot;register&quot;)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;MBeanPermission&lt;/code&gt; 检查成功，则通过检查MBean的&lt;a href=&quot;../../java/security/protectiondomain&quot;&gt; &lt;code&gt;ProtectionDomain&lt;/code&gt; &lt;/a&gt;隐含&lt;a href=&quot;mbeantrustpermission#MBeanTrustPermission-java.lang.String-&quot;&gt; &lt;code&gt;MBeanTrustPermission(&quot;register&quot;)&lt;/code&gt; &lt;/a&gt;来验证MBean的类。</target>
        </trans-unit>
        <trans-unit id="021af7bb755cf93cf54c9f5f352c98d0f4ca4622" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;ObservedAttribute&lt;/code&gt; contains more than one period, for example &lt;code&gt;&quot;ConnectionPool.connectionStats.length&quot;&lt;/code&gt;, then the above rules are applied iteratively. Here,</source>
          <target state="translated">如果 &lt;code&gt;ObservedAttribute&lt;/code&gt; 包含多个句点，例如 &lt;code&gt;&quot;ConnectionPool.connectionStats.length&quot;&lt;/code&gt; ，则上述规则将迭代应用。这里，</target>
        </trans-unit>
        <trans-unit id="7cb7f5f842a73d2190c2e8a4561e728aa057bb8f" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;RMIServerImpl&lt;/code&gt; was bound to a JNDI directory by the &lt;a href=&quot;rmiconnectorserver#start--&quot;&gt;&lt;code&gt;start&lt;/code&gt;&lt;/a&gt; method, it is unbound from the directory by this method.</source>
          <target state="translated">如果 &lt;code&gt;RMIServerImpl&lt;/code&gt; 通过&lt;a href=&quot;rmiconnectorserver#start--&quot;&gt; &lt;code&gt;start&lt;/code&gt; &lt;/a&gt;方法绑定到JNDI目录，则通过此方法将其与目录解除绑定。</target>
        </trans-unit>
        <trans-unit id="5e181fd53600dcd77e327b5091e7925935330a6f" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;ResolverStyle&lt;/code&gt; is &lt;code&gt;LENIENT&lt;/code&gt; and a time is parsed without a date, then the complete result of the parse consists of a &lt;code&gt;LocalTime&lt;/code&gt; and an excess &lt;code&gt;Period&lt;/code&gt; in days.</source>
          <target state="translated">如果 &lt;code&gt;ResolverStyle&lt;/code&gt; 为 &lt;code&gt;LENIENT&lt;/code&gt; 并且解析的时间不带日期，则解析的完整结果包括 &lt;code&gt;LocalTime&lt;/code&gt; 和以天为单位的多余 &lt;code&gt;Period&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="801480d1156ab6ed42af2047f9f67f81a9ed2968" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;ResolverStyle&lt;/code&gt; is &lt;code&gt;SMART&lt;/code&gt; and a time is parsed without a date where the time is 24:00:00, then the complete result of the parse consists of a &lt;code&gt;LocalTime&lt;/code&gt; of 00:00:00 and an excess &lt;code&gt;Period&lt;/code&gt; of one day.</source>
          <target state="translated">如果 &lt;code&gt;ResolverStyle&lt;/code&gt; 是 &lt;code&gt;SMART&lt;/code&gt; 以及其中时间是24:00:00，一时间不注日期的解析，则解析的完整结果由的 &lt;code&gt;LocalTime&lt;/code&gt; 的00:00:00和过量 &lt;code&gt;Period&lt;/code&gt; 一天。</target>
        </trans-unit>
        <trans-unit id="679d594737099d64f4c8a7bd67a360d72bcf8bdd" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Type&lt;/code&gt; is a parameterized type, the &lt;code&gt;Type&lt;/code&gt; object returned must accurately reflect the actual type parameters used in the source code.</source>
          <target state="translated">如果 &lt;code&gt;Type&lt;/code&gt; 是参数化类型，则返回的 &lt;code&gt;Type&lt;/code&gt; 对象必须准确反映源代码中使用的实际类型参数。</target>
        </trans-unit>
        <trans-unit id="be1a0f77a615842bdf82ef7b9ebede6a9bce0b3f" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;ZoneId&lt;/code&gt; to be used is a &lt;code&gt;ZoneOffset&lt;/code&gt;, this method is equivalent to &lt;a href=&quot;zoneddatetime#of-java.time.LocalDateTime-java.time.ZoneId-&quot;&gt;&lt;code&gt;of(LocalDateTime, ZoneId)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;ZoneId&lt;/code&gt; 使用是 &lt;code&gt;ZoneOffset&lt;/code&gt; ，该方法等效于&lt;a href=&quot;zoneddatetime#of-java.time.LocalDateTime-java.time.ZoneId-&quot;&gt; &lt;code&gt;of(LocalDateTime, ZoneId)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9d86f839b1695227093964559a355f46055cbd60" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;abort&lt;/code&gt; phase fails for any reason, then this method propagates the original exception thrown either during the &lt;code&gt;login&lt;/code&gt; phase or the &lt;code&gt;commit&lt;/code&gt; phase. In either case, the overall authentication fails.</source>
          <target state="translated">如果 &lt;code&gt;abort&lt;/code&gt; 阶段由于任何原因而失败，则此方法将传播在 &lt;code&gt;login&lt;/code&gt; 阶段或 &lt;code&gt;commit&lt;/code&gt; 阶段抛出的原始异常。在任何一种情况下，整体身份验证都会失败。</target>
        </trans-unit>
        <trans-unit id="446c80fa5bc5f4e37afc5fc9e155b09818c5562f" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;addAll()&lt;/code&gt; operation throws an exception, the effect on this attribute set's state is implementation dependent; elements from the specified set before the point of the exception may or may not have been added to this attribute set.</source>
          <target state="translated">如果 &lt;code&gt;addAll()&lt;/code&gt; 操作引发异常，则此属性集状态的影响取决于实现；异常点之前指定集合中的元素可能已添加或可能未添加到此属性集。</target>
        </trans-unit>
        <trans-unit id="04ef5598f3ce002caa707d0e8dab5fc3e129e43c" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;addAll(AttributeSet)&lt;/code&gt; operation throws an exception, the effect on this attribute set's state is implementation dependent; elements from the specified set before the point of the exception may or may not have been added to this attribute set.</source>
          <target state="translated">如果 &lt;code&gt;addAll(AttributeSet)&lt;/code&gt; 操作引发异常，则对该属性集状态的影响取决于实现；异常点之前指定集合中的元素可能已添加或可能未添加到此属性集。</target>
        </trans-unit>
        <trans-unit id="9c0511263cbc485e9efb3be19eb199baa7484f96" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;algorithm&lt;/code&gt; parameter is non-null or non-empty, the endpoint identification/verification procedures must be handled during SSL/TLS handshaking. This is to prevent man-in-the-middle attacks.</source>
          <target state="translated">如果 &lt;code&gt;algorithm&lt;/code&gt; 参数为非null或非空，则必须在SSL / TLS握手期间处理端点标识/验证过程。这是为了防止中间人攻击。</target>
        </trans-unit>
        <trans-unit id="df2ce529fb9d0af1fa8bdee431df9ad0c85e4344" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;attributes&lt;/code&gt; parameter contains an Attribute whose category is the same as the &lt;code&gt;category&lt;/code&gt; parameter, the service must ignore this attribute in the AttributeSet.</source>
          <target state="translated">如果 &lt;code&gt;attributes&lt;/code&gt; 参数包含一个类别与 &lt;code&gt;category&lt;/code&gt; 参数相同的Attribute ，则服务必须在AttributeSet中忽略该属性。</target>
        </trans-unit>
        <trans-unit id="66b2ac942fdab810011fedc70461bf42a1dedd98" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;boolean&lt;/code&gt; argument is &lt;code&gt;false&lt;/code&gt;, this method causes the virtual machine to stop performing the detailed instruction trace it is performing.</source>
          <target state="translated">如果 &lt;code&gt;boolean&lt;/code&gt; 参数为 &lt;code&gt;false&lt;/code&gt; ，则此方法导致虚拟机停止执行其正在执行的详细指令跟踪。</target>
        </trans-unit>
        <trans-unit id="88001e51dd6c79b8369de89a8cbe2fdfe3865e70" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;char&lt;/code&gt; value at &lt;code&gt;(index - 1)&lt;/code&gt; is in the low-surrogate range, &lt;code&gt;(index - 2)&lt;/code&gt; is not negative, and the &lt;code&gt;char&lt;/code&gt; value at &lt;code&gt;(index -
 2)&lt;/code&gt; is in the high-surrogate range, then the supplementary code point value of the surrogate pair is returned. If the &lt;code&gt;char&lt;/code&gt; value at &lt;code&gt;index -
 1&lt;/code&gt; is an unpaired low-surrogate or a high-surrogate, the surrogate value is returned.</source>
          <target state="translated">如果 &lt;code&gt;(index - 1)&lt;/code&gt; 处的 &lt;code&gt;char&lt;/code&gt; 值在低代理范围内， &lt;code&gt;(index - 2)&lt;/code&gt; 不为负，并且 &lt;code&gt;(index - 2)&lt;/code&gt; 处的 &lt;code&gt;char&lt;/code&gt; 值在高代理范围内，则补充代码点返回代理对的值。如果 &lt;code&gt;index - 1&lt;/code&gt; 处的 &lt;code&gt;char&lt;/code&gt; 值是未配对的低代理或高代理，则返回代理值。</target>
        </trans-unit>
        <trans-unit id="4dc1506abc2a5f78b19fe3dd96f18038b15e4e22" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;char&lt;/code&gt; value specified at the given index is in the high-surrogate range, the following index is less than the length of this &lt;code&gt;String&lt;/code&gt;, and the &lt;code&gt;char&lt;/code&gt; value at the following index is in the low-surrogate range, then the supplementary code point corresponding to this surrogate pair is returned. Otherwise, the &lt;code&gt;char&lt;/code&gt; value at the given index is returned.</source>
          <target state="translated">如果在给定索引处指定的 &lt;code&gt;char&lt;/code&gt; 值在高代理范围内，则以下索引小于此 &lt;code&gt;String&lt;/code&gt; 的长度，并且在随后索引处的 &lt;code&gt;char&lt;/code&gt; 值在低代理范围内，则补充代码点返回与此代理对相对应。否则，将返回给定索引处的 &lt;code&gt;char&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="e0c3a606e3f3d827b22e0257098f87d4bbd176eb" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;char&lt;/code&gt; value specified at the given index is in the high-surrogate range, the following index is less than the length of this sequence, and the &lt;code&gt;char&lt;/code&gt; value at the following index is in the low-surrogate range, then the supplementary code point corresponding to this surrogate pair is returned. Otherwise, the &lt;code&gt;char&lt;/code&gt; value at the given index is returned.</source>
          <target state="translated">如果在给定索引处指定的 &lt;code&gt;char&lt;/code&gt; 值在高代理范围内，则后续索引小于此序列的长度，并且在随后索引处的 &lt;code&gt;char&lt;/code&gt; 值在低代理范围内，则补充代码点返回与此代理对相对应。否则，将返回给定索引处的 &lt;code&gt;char&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="7059bfb26c628d831ae809e02477cb1879e60f94" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;char&lt;/code&gt; value specified by the index is a &lt;a href=&quot;character#unicode&quot;&gt;surrogate&lt;/a&gt;, the surrogate value is returned.</source>
          <target state="translated">如果索引指定的 &lt;code&gt;char&lt;/code&gt; 值是&lt;a href=&quot;character#unicode&quot;&gt;代理&lt;/a&gt;，则返回代理值。</target>
        </trans-unit>
        <trans-unit id="8250d512b905f35c6a410fcb5609b7900e346a5b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;commit&lt;/code&gt; phase of the authentication process fails, then the overall authentication fails and this method invokes the &lt;code&gt;abort&lt;/code&gt; method for each configured &lt;code&gt;LoginModule&lt;/code&gt;.</source>
          <target state="translated">如果身份验证过程的 &lt;code&gt;commit&lt;/code&gt; 阶段失败，则整个身份验证将失败，并且此方法将为每个已配置的 &lt;code&gt;LoginModule&lt;/code&gt; 调用 &lt;code&gt;abort&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="84555e61977552659f8d8d7542bd52057f6a2286" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;connect&lt;/code&gt; method is called when the connection has already been opened (indicated by the &lt;code&gt;connected&lt;/code&gt; field having the value &lt;code&gt;true&lt;/code&gt;), the call is ignored.</source>
          <target state="translated">如果在已经打开连接时调用 &lt;code&gt;connect&lt;/code&gt; 方法（由 &lt;code&gt;connected&lt;/code&gt; 字段表示值为 &lt;code&gt;true&lt;/code&gt; ），则该调用将被忽略。</target>
        </trans-unit>
        <trans-unit id="671e297a3a1ea6f0c42770e029c80abaa60e1bfb" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;constraints&lt;/code&gt; parameter is non-null, every cryptographic algorithm, key and algorithm parameters used in the SSL/TLS handshake must be permitted by the constraints.</source>
          <target state="translated">如果 &lt;code&gt;constraints&lt;/code&gt; 参数为非null，则约束必须允许SSL / TLS握手中使用的每个加密算法，密钥和算法参数。</target>
        </trans-unit>
        <trans-unit id="44563c51972a22c15c4aac96132c92755f5fb940" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;directory&lt;/code&gt; argument is &lt;code&gt;null&lt;/code&gt; then the system-dependent default temporary-file directory will be used. The default temporary-file directory is specified by the system property &lt;code&gt;java.io.tmpdir&lt;/code&gt;. On UNIX systems the default value of this property is typically &lt;code&gt;&quot;/tmp&quot;&lt;/code&gt; or &lt;code&gt;&quot;/var/tmp&quot;&lt;/code&gt;; on Microsoft Windows systems it is typically &lt;code&gt;&quot;C:\\WINNT\\TEMP&quot;&lt;/code&gt;. A different value may be given to this system property when the Java virtual machine is invoked, but programmatic changes to this property are not guaranteed to have any effect upon the temporary directory used by this method.</source>
          <target state="translated">如果 &lt;code&gt;directory&lt;/code&gt; 参数为 &lt;code&gt;null&lt;/code&gt; ,则将使用系统相关的默认临时文件目录。默认临时文件目录由系统属性 &lt;code&gt;java.io.tmpdir&lt;/code&gt; 指定。在UNIX系统上，此属性的默认值通常为 &lt;code&gt;&quot;/tmp&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;/var/tmp&quot;&lt;/code&gt; ；在Microsoft Windows系统上，通常为 &lt;code&gt;&quot;C:\\WINNT\\TEMP&quot;&lt;/code&gt; 。调用Java虚拟机时，可以为此系统属性赋予不同的值，但不能保证对此属性的编程更改对此方法使用的临时目录没有任何影响。</target>
        </trans-unit>
        <trans-unit id="61b3f5e27ccdfa6299b991fa9397c7fbc31d2c50" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;emitter&lt;/code&gt; parameter to the constructor was an instance of &lt;code&gt;NotificationBroadcasterSupport&lt;/code&gt; then this method will call &lt;code&gt;emitter.&lt;/code&gt;&lt;a href=&quot;notificationbroadcastersupport#sendNotification-javax.management.Notification-&quot;&gt;&lt;code&gt;sendNotification&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果构造方法的 &lt;code&gt;emitter&lt;/code&gt; 参数是 &lt;code&gt;NotificationBroadcasterSupport&lt;/code&gt; 的实例，则此方法将调用 &lt;code&gt;emitter.&lt;/code&gt; &lt;a href=&quot;notificationbroadcastersupport#sendNotification-javax.management.Notification-&quot;&gt; &lt;code&gt;sendNotification&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9ab969fd58c84fba8fefef4d68297aff8fba763d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;engine&lt;/code&gt; parameter is available, and the algorithm constraints of the &lt;code&gt;SSLParameters&lt;/code&gt; is non-null, for every certificate in the certification path, fields such as subject public key, the signature algorithm, key usage, extended key usage, etc. need to conform to the algorithm constraints in place on this engine.</source>
          <target state="translated">如果 &lt;code&gt;engine&lt;/code&gt; 参数可用，并且 &lt;code&gt;SSLParameters&lt;/code&gt; 的算法约束为非空，则对于证书路径中的每个证书，都需要符合诸如主题公钥，签名算法，密钥用法，扩展密钥用法等字段限制在此引擎上的算法约束。</target>
        </trans-unit>
        <trans-unit id="4eab346c804a32d54771d78aef5cb1081f3a8a5a" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;engine&lt;/code&gt; parameter is available, and the endpoint identification algorithm of the &lt;code&gt;SSLParameters&lt;/code&gt; is non-empty, to prevent man-in-the-middle attacks, the address that the &lt;code&gt;engine&lt;/code&gt; connected to should be checked against the peer's identity presented in the end-entity X509 certificate, as specified in the endpoint identification algorithm.</source>
          <target state="translated">如果 &lt;code&gt;engine&lt;/code&gt; 参数可用，并且 &lt;code&gt;SSLParameters&lt;/code&gt; 的端点标识算法为非空，则为防止中间人攻击，应针对 &lt;code&gt;engine&lt;/code&gt; 连接到的地址与末尾显示的对等方身份进行检查，端点标识算法中指定的X509实体证书。</target>
        </trans-unit>
        <trans-unit id="56c06cc3e424dcdff076cdd1bf18f2a3b0d87e7a" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;environment&lt;/code&gt; parameter to &lt;a href=&quot;jmxconnectorfactory#newJMXConnector-javax.management.remote.JMXServiceURL-java.util.Map-&quot;&gt;&lt;code&gt;newJMXConnector&lt;/code&gt;&lt;/a&gt; contains the key &lt;code&gt;jmx.remote.protocol.provider.class.loader&lt;/code&gt; then the associated value is the class loader to use to load the provider. If the associated value is not an instance of &lt;a href=&quot;../../../java/lang/classloader&quot;&gt;&lt;code&gt;ClassLoader&lt;/code&gt;&lt;/a&gt;, an &lt;a href=&quot;../../../java/lang/illegalargumentexception&quot;&gt;&lt;code&gt;IllegalArgumentException&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">如果&lt;a href=&quot;jmxconnectorfactory#newJMXConnector-javax.management.remote.JMXServiceURL-java.util.Map-&quot;&gt; &lt;code&gt;newJMXConnector&lt;/code&gt; &lt;/a&gt;的 &lt;code&gt;environment&lt;/code&gt; 参数包含键 &lt;code&gt;jmx.remote.protocol.provider.class.loader&lt;/code&gt; ,则关联的值是用于加载提供程序的类加载器。如果关联的值不是一个实例&lt;a href=&quot;../../../java/lang/classloader&quot;&gt; &lt;code&gt;ClassLoader&lt;/code&gt; &lt;/a&gt;，一个&lt;a href=&quot;../../../java/lang/illegalargumentexception&quot;&gt; &lt;code&gt;IllegalArgumentException&lt;/code&gt; &lt;/a&gt;异常。</target>
        </trans-unit>
        <trans-unit id="d005cee8b528479b05c0be85b9c4205d983a4967" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;environment&lt;/code&gt; parameter to &lt;a href=&quot;jmxconnectorfactory#newJMXConnector-javax.management.remote.JMXServiceURL-java.util.Map-&quot;&gt;&lt;code&gt;newJMXConnector&lt;/code&gt;&lt;/a&gt; contains the key &lt;code&gt;jmx.remote.protocol.provider.pkgs&lt;/code&gt; then the associated value is the provider package list.</source>
          <target state="translated">如果&lt;a href=&quot;jmxconnectorfactory#newJMXConnector-javax.management.remote.JMXServiceURL-java.util.Map-&quot;&gt; &lt;code&gt;newJMXConnector&lt;/code&gt; &lt;/a&gt;的 &lt;code&gt;environment&lt;/code&gt; 参数包含键 &lt;code&gt;jmx.remote.protocol.provider.pkgs&lt;/code&gt; ,则关联的值为提供程序包列表。</target>
        </trans-unit>
        <trans-unit id="826709e7b964ff5f55e8bba64d589128adee0453" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;environment&lt;/code&gt; parameter to &lt;a href=&quot;jmxconnectorserverfactory#newJMXConnectorServer-javax.management.remote.JMXServiceURL-java.util.Map-javax.management.MBeanServer-&quot;&gt;&lt;code&gt;newJMXConnectorServer&lt;/code&gt;&lt;/a&gt; contains the key &lt;code&gt;jmx.remote.protocol.provider.class.loader&lt;/code&gt; then the associated value is the class loader to use to load the provider. If the associated value is not an instance of &lt;a href=&quot;../../../java/lang/classloader&quot;&gt;&lt;code&gt;ClassLoader&lt;/code&gt;&lt;/a&gt;, an &lt;a href=&quot;../../../java/lang/illegalargumentexception&quot;&gt;&lt;code&gt;IllegalArgumentException&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">如果&lt;a href=&quot;jmxconnectorserverfactory#newJMXConnectorServer-javax.management.remote.JMXServiceURL-java.util.Map-javax.management.MBeanServer-&quot;&gt; &lt;code&gt;newJMXConnectorServer&lt;/code&gt; &lt;/a&gt;的 &lt;code&gt;environment&lt;/code&gt; 参数包含键 &lt;code&gt;jmx.remote.protocol.provider.class.loader&lt;/code&gt; ,则关联的值是用于加载提供程序的类加载器。如果关联的值不是一个实例&lt;a href=&quot;../../../java/lang/classloader&quot;&gt; &lt;code&gt;ClassLoader&lt;/code&gt; &lt;/a&gt;，一个&lt;a href=&quot;../../../java/lang/illegalargumentexception&quot;&gt; &lt;code&gt;IllegalArgumentException&lt;/code&gt; &lt;/a&gt;异常。</target>
        </trans-unit>
        <trans-unit id="57ace146c6c02d090ae1128a0850bf8c4adb9e91" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;environment&lt;/code&gt; parameter to &lt;a href=&quot;jmxconnectorserverfactory#newJMXConnectorServer-javax.management.remote.JMXServiceURL-java.util.Map-javax.management.MBeanServer-&quot;&gt;&lt;code&gt;newJMXConnectorServer&lt;/code&gt;&lt;/a&gt; contains the key &lt;code&gt;jmx.remote.protocol.provider.pkgs&lt;/code&gt; then the associated value is the provider package list.</source>
          <target state="translated">如果&lt;a href=&quot;jmxconnectorserverfactory#newJMXConnectorServer-javax.management.remote.JMXServiceURL-java.util.Map-javax.management.MBeanServer-&quot;&gt; &lt;code&gt;newJMXConnectorServer&lt;/code&gt; &lt;/a&gt;的 &lt;code&gt;environment&lt;/code&gt; 参数包含键 &lt;code&gt;jmx.remote.protocol.provider.pkgs&lt;/code&gt; ,则关联的值为提供程序包列表。</target>
        </trans-unit>
        <trans-unit id="f6b8bda61da14baa6de0517de831488bd2ee3ae0" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;flag&lt;/code&gt; is false, end-of-line characters are treated as white space and serve only to separate tokens.</source>
          <target state="translated">如果该 &lt;code&gt;flag&lt;/code&gt; 为假，则将行尾字符视为空格，并且仅用于分隔令牌。</target>
        </trans-unit>
        <trans-unit id="f96a39d4789943d7d6902746fb2340490af74ceb" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;info&lt;/code&gt; array is not empty, then it is cloned by the constructor as if by &lt;code&gt;info.clone()&lt;/code&gt;, and each call to &lt;a href=&quot;notificationbroadcastersupport#getNotificationInfo--&quot;&gt;&lt;code&gt;getNotificationInfo()&lt;/code&gt;&lt;/a&gt; returns a new clone.</source>
          <target state="translated">如果 &lt;code&gt;info&lt;/code&gt; 数组不为空，则构造方法将其克隆为 &lt;code&gt;info.clone()&lt;/code&gt; ，并且每次调用&lt;a href=&quot;notificationbroadcastersupport#getNotificationInfo--&quot;&gt; &lt;code&gt;getNotificationInfo()&lt;/code&gt; 都会&lt;/a&gt;返回一个新克隆。</target>
        </trans-unit>
        <trans-unit id="b2eafd26f57a8ac8bfe07dee9777924ccc1ddeef" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;java.naming.corba.orb&lt;/code&gt; attribute is specified and does not point to an &lt;a href=&quot;/openjdk~8_web/org/omg/corba/orb&quot;&gt;&lt;code&gt;ORB&lt;/code&gt;&lt;/a&gt;, then an &lt;code&gt;&lt;a href=&quot;../../../../java/lang/illegalargumentexception&quot;&gt;&lt;code&gt;IllegalArgumentException&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; will be thrown.</source>
          <target state="translated">如果指定了 &lt;code&gt;java.naming.corba.orb&lt;/code&gt; 属性且未指向&lt;a href=&quot;/openjdk~8_web/org/omg/corba/orb&quot;&gt; &lt;code&gt;ORB&lt;/code&gt; &lt;/a&gt;，则将 &lt;code&gt;&lt;a href=&quot;../../../../java/lang/illegalargumentexception&quot;&gt;&lt;code&gt;IllegalArgumentException&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c4278296c23500bf6c0cea864ef00fd56ed5236d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;jmx.remote.protocol.provider.class.loader&lt;/code&gt; key is not present in the &lt;code&gt;environment&lt;/code&gt; parameter, the calling thread's context class loader is used.</source>
          <target state="translated">如果 &lt;code&gt;environment&lt;/code&gt; 参数中不存在 &lt;code&gt;jmx.remote.protocol.provider.class.loader&lt;/code&gt; 密钥，则使用调用线程的上下文类加载器。</target>
        </trans-unit>
        <trans-unit id="3056297b7728c6033d8b58edc893075abdeaf0f3" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;listenerMethodName&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;&lt;em&gt;all&lt;/em&gt; methods in the interface trigger the &lt;code&gt;action&lt;/code&gt; to be executed on the &lt;code&gt;target&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;listenerMethodName&lt;/code&gt; 为 &lt;code&gt;null&lt;/code&gt; ，则接口中的&lt;em&gt;所有&lt;/em&gt;方法都会触发要在 &lt;code&gt;target&lt;/code&gt; 上执行的 &lt;code&gt;action&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c26cc70217e4df47d29c0c2d3d16af4b3ed49f81" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;loader&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, and a security manager is present, and the caller's class loader is not null, then this method calls the security manager's &lt;code&gt;checkPermission&lt;/code&gt; method with a &lt;code&gt;RuntimePermission(&quot;getClassLoader&quot;)&lt;/code&gt; permission to ensure it's ok to access the bootstrap class loader.</source>
          <target state="translated">如果 &lt;code&gt;loader&lt;/code&gt; 为 &lt;code&gt;null&lt;/code&gt; ，并且存在安全管理器，并且调用者的类加载器不为null，则此方法使用 &lt;code&gt;RuntimePermission(&quot;getClassLoader&quot;)&lt;/code&gt; 权限调用安全管理器的 &lt;code&gt;checkPermission&lt;/code&gt; 方法，以确保可以访问引导类加载器。</target>
        </trans-unit>
        <trans-unit id="883de64909ad64380525bc73b0b1943d2957d4ad" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;login&lt;/code&gt; method returns without throwing an exception, then the overall authentication succeeded. The caller can then retrieve the newly authenticated Subject by invoking the &lt;code&gt;getSubject&lt;/code&gt; method. Principals and Credentials associated with the Subject may be retrieved by invoking the Subject's respective &lt;code&gt;getPrincipals&lt;/code&gt;, &lt;code&gt;getPublicCredentials&lt;/code&gt;, and &lt;code&gt;getPrivateCredentials&lt;/code&gt; methods.</source>
          <target state="translated">如果 &lt;code&gt;login&lt;/code&gt; 方法返回时没有引发异常，则说明整体身份验证成功。然后，调用者可以通过调用 &lt;code&gt;getSubject&lt;/code&gt; 方法来检索新认证的Subject 。可以通过调用主题各自的 &lt;code&gt;getPrincipals&lt;/code&gt; ， &lt;code&gt;getPublicCredentials&lt;/code&gt; 和 &lt;code&gt;getPrivateCredentials&lt;/code&gt; 方法来检索与主题关联的主体和凭据。</target>
        </trans-unit>
        <trans-unit id="b49049ac47e926595641db8085788c19725bedae" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;minimumCapacity&lt;/code&gt; argument is nonpositive, this method takes no action and simply returns. Note that subsequent operations on this object can reduce the actual capacity below that requested here.</source>
          <target state="translated">如果 &lt;code&gt;minimumCapacity&lt;/code&gt; 参数为非正数，则此方法不执行任何操作，仅返回。请注意，对该对象的后续操作可能会将实际容量减少到此处要求的以下。</target>
        </trans-unit>
        <trans-unit id="848f1dae842a9e3e26ccb5fe35a5a76ed09b5792" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;modes&lt;/code&gt; parameter is of length zero, then the existence of the file is checked.</source>
          <target state="translated">如果 &lt;code&gt;modes&lt;/code&gt; 参数的长度为零，则检查文件的存在。</target>
        </trans-unit>
        <trans-unit id="d2a314f2aa28a80e456c2b1019bb7151fb7190ec" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;name&lt;/code&gt; begins with a &lt;code&gt;'/'&lt;/code&gt; (&lt;code&gt;'\u002f'&lt;/code&gt;), then the absolute name of the resource is the portion of the &lt;code&gt;name&lt;/code&gt; following the &lt;code&gt;'/'&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;name&lt;/code&gt; 以 &lt;code&gt;'/'&lt;/code&gt; 开头（ &lt;code&gt;'\u002f'&lt;/code&gt; ），则资源的绝对名称是 &lt;code&gt;name&lt;/code&gt; 位于 &lt;code&gt;'/'&lt;/code&gt; 之后的部分。</target>
        </trans-unit>
        <trans-unit id="64bdc0e92c398401f342c415851da39654a29de8" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;name&lt;/code&gt; is &quot;&lt;code&gt;&amp;lt;init&amp;gt;&lt;/code&gt;&quot; or &quot;&lt;code&gt;&amp;lt;clinit&amp;gt;&lt;/code&gt;&quot; a &lt;code&gt;NoSuchMethodException&lt;/code&gt; is raised. Otherwise, the method to be reflected is determined by the algorithm that follows. Let C be the class or interface represented by this object:</source>
          <target state="translated">如果 &lt;code&gt;name&lt;/code&gt; 是&amp;ldquo; &lt;code&gt;&amp;lt;init&amp;gt;&lt;/code&gt; &amp;rdquo;或&amp;ldquo; &lt;code&gt;&amp;lt;clinit&amp;gt;&lt;/code&gt; &amp;rdquo;，则会引发 &lt;code&gt;NoSuchMethodException&lt;/code&gt; 。否则，要反映的方法由随后的算法确定。令C为该对象表示的类或接口：</target>
        </trans-unit>
        <trans-unit id="83d37bcba2e6c3af77d7d4ae04d7689d9a46d013" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;newAttr&lt;/code&gt; attribute replaces an existing attribute with the same local name and namespace URI, the replaced &lt;code&gt;Attr&lt;/code&gt; node is returned, otherwise &lt;code&gt;null&lt;/code&gt; is returned.</source>
          <target state="translated">如果 &lt;code&gt;newAttr&lt;/code&gt; 属性用相同的本地名称和名称空间URI替换现有属性，则返回被替换的 &lt;code&gt;Attr&lt;/code&gt; 节点，否则返回 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5c99c4ecff1480f789773edec7e413ca2eabcdc6" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;newAttr&lt;/code&gt; attribute replaces an existing attribute, the replaced &lt;code&gt;Attr&lt;/code&gt; node is returned, otherwise &lt;code&gt;null&lt;/code&gt; is returned.</source>
          <target state="translated">如果 &lt;code&gt;newAttr&lt;/code&gt; 属性替换了现有属性，则返回替换的 &lt;code&gt;Attr&lt;/code&gt; 节点，否则返回 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e562c3377bc531b17a3856d97697e38d3cf5595e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;newLength&lt;/code&gt; argument is greater than or equal to the current length, sufficient null characters (&lt;code&gt;'\u0000'&lt;/code&gt;) are appended so that length becomes the &lt;code&gt;newLength&lt;/code&gt; argument.</source>
          <target state="translated">如果 &lt;code&gt;newLength&lt;/code&gt; 自变量大于或等于当前长度，则将附加足够的空字符（ &lt;code&gt;'\u0000'&lt;/code&gt; ），以使长度成为 &lt;code&gt;newLength&lt;/code&gt; 自变量。</target>
        </trans-unit>
        <trans-unit id="301c55c1d2d5648b427ee3a645ab8146cd1a941a" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;options&lt;/code&gt; parameter contains the &lt;a href=&quot;filevisitoption#FOLLOW_LINKS&quot;&gt;&lt;code&gt;FOLLOW_LINKS&lt;/code&gt;&lt;/a&gt; option then the stream keeps track of directories visited so that cycles can be detected. A cycle arises when there is an entry in a directory that is an ancestor of the directory. Cycle detection is done by recording the &lt;a href=&quot;attribute/basicfileattributes#fileKey--&quot;&gt;&lt;code&gt;file-key&lt;/code&gt;&lt;/a&gt; of directories, or if file keys are not available, by invoking the &lt;a href=&quot;files#isSameFile-java.nio.file.Path-java.nio.file.Path-&quot;&gt;&lt;code&gt;isSameFile&lt;/code&gt;&lt;/a&gt; method to test if a directory is the same file as an ancestor. When a cycle is detected it is treated as an I/O error with an instance of &lt;a href=&quot;filesystemloopexception&quot;&gt;&lt;code&gt;FileSystemLoopException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;options&lt;/code&gt; 参数包含&lt;a href=&quot;filevisitoption#FOLLOW_LINKS&quot;&gt; &lt;code&gt;FOLLOW_LINKS&lt;/code&gt; &lt;/a&gt;选项，则流将跟踪已访问的目录，以便可以检测到周期。当目录中有一个条目是该目录的祖先时，就会出现一个循环。循环检测通过记录目录的&lt;a href=&quot;attribute/basicfileattributes#fileKey--&quot;&gt; &lt;code&gt;file-key&lt;/code&gt; &lt;/a&gt;来完成，或者如果文件密钥不可用，则通过调用&lt;a href=&quot;files#isSameFile-java.nio.file.Path-java.nio.file.Path-&quot;&gt; &lt;code&gt;isSameFile&lt;/code&gt; &lt;/a&gt;方法来测试目录是否与祖先文件相同。当检测到一个周期时，将其作为&lt;a href=&quot;filesystemloopexception&quot;&gt; &lt;code&gt;FileSystemLoopException&lt;/code&gt; &lt;/a&gt;实例的I / O错误。</target>
        </trans-unit>
        <trans-unit id="ecea4dec8dcb1fadb716a28cf7ec70ca81e1d565" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;options&lt;/code&gt; parameter contains the &lt;a href=&quot;filevisitoption#FOLLOW_LINKS&quot;&gt;&lt;code&gt;FOLLOW_LINKS&lt;/code&gt;&lt;/a&gt; option then this method keeps track of directories visited so that cycles can be detected. A cycle arises when there is an entry in a directory that is an ancestor of the directory. Cycle detection is done by recording the &lt;a href=&quot;attribute/basicfileattributes#fileKey--&quot;&gt;&lt;code&gt;file-key&lt;/code&gt;&lt;/a&gt; of directories, or if file keys are not available, by invoking the &lt;a href=&quot;files#isSameFile-java.nio.file.Path-java.nio.file.Path-&quot;&gt;&lt;code&gt;isSameFile&lt;/code&gt;&lt;/a&gt; method to test if a directory is the same file as an ancestor. When a cycle is detected it is treated as an I/O error, and the &lt;a href=&quot;filevisitor#visitFileFailed-T-java.io.IOException-&quot;&gt;&lt;code&gt;visitFileFailed&lt;/code&gt;&lt;/a&gt; method is invoked with an instance of &lt;a href=&quot;filesystemloopexception&quot;&gt;&lt;code&gt;FileSystemLoopException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;options&lt;/code&gt; 参数包含&lt;a href=&quot;filevisitoption#FOLLOW_LINKS&quot;&gt; &lt;code&gt;FOLLOW_LINKS&lt;/code&gt; &lt;/a&gt;选项，则此方法将跟踪访问的目录，以便可以检测到周期。当目录中有一个条目是该目录的祖先时，就会出现一个循环。循环检测通过记录目录的&lt;a href=&quot;attribute/basicfileattributes#fileKey--&quot;&gt; &lt;code&gt;file-key&lt;/code&gt; &lt;/a&gt;来完成，或者如果文件密钥不可用，则通过调用&lt;a href=&quot;files#isSameFile-java.nio.file.Path-java.nio.file.Path-&quot;&gt; &lt;code&gt;isSameFile&lt;/code&gt; &lt;/a&gt;方法来测试目录是否与祖先文件相同。当检测到周期时，将其视为I / O错误，并使用&lt;a href=&quot;filesystemloopexception&quot;&gt; &lt;code&gt;FileSystemLoopException&lt;/code&gt; &lt;/a&gt;的实例调用&lt;a href=&quot;filevisitor#visitFileFailed-T-java.io.IOException-&quot;&gt; &lt;code&gt;visitFileFailed&lt;/code&gt; &lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="88ff2d156a33a9f0f1f1ee553f98ff8909648b12" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;other&lt;/code&gt; parameter is an &lt;a href=&quot;path#isAbsolute--&quot;&gt;&lt;code&gt;absolute&lt;/code&gt;&lt;/a&gt; path then this method trivially returns &lt;code&gt;other&lt;/code&gt;. If &lt;code&gt;other&lt;/code&gt; is an</source>
          <target state="translated">如果 &lt;code&gt;other&lt;/code&gt; 参数是&lt;a href=&quot;path#isAbsolute--&quot;&gt; &lt;code&gt;absolute&lt;/code&gt; &lt;/a&gt;路径，则此方法会简单地返回 &lt;code&gt;other&lt;/code&gt; 。如果 &lt;code&gt;other&lt;/code&gt; 是</target>
        </trans-unit>
        <trans-unit id="9865b3d772f73983f404112e79623aa8e389cc36" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;output&lt;/code&gt; buffer is too small to hold the result, a &lt;code&gt;ShortBufferException&lt;/code&gt; is thrown.</source>
          <target state="translated">如果 &lt;code&gt;output&lt;/code&gt; 缓冲区太小而无法容纳结果，则抛出 &lt;code&gt;ShortBufferException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3573d5215011c7d840ccb006ba46e8ea91465ab0" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;output&lt;/code&gt; buffer is too small to hold the result, a &lt;code&gt;ShortBufferException&lt;/code&gt; is thrown. In this case, repeat this call with a larger output buffer. Use &lt;a href=&quot;cipher#getOutputSize-int-&quot;&gt;&lt;code&gt;getOutputSize&lt;/code&gt;&lt;/a&gt; to determine how big the output buffer should be.</source>
          <target state="translated">如果 &lt;code&gt;output&lt;/code&gt; 缓冲区太小而无法容纳结果，则抛出 &lt;code&gt;ShortBufferException&lt;/code&gt; 。在这种情况下，请使用更大的输出缓冲区重复此调用。使用&lt;a href=&quot;cipher#getOutputSize-int-&quot;&gt; &lt;code&gt;getOutputSize&lt;/code&gt; &lt;/a&gt;确定输出缓冲区应该有多大。</target>
        </trans-unit>
        <trans-unit id="d4e86a833a3d986a22969c431219896e2f0d39b7" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;output&lt;/code&gt; buffer is too small to hold the result, a &lt;code&gt;ShortBufferException&lt;/code&gt; is thrown. In this case, repeat this call with a larger output buffer. Use &lt;a href=&quot;exemptionmechanism#getOutputSize-int-&quot;&gt;&lt;code&gt;getOutputSize&lt;/code&gt;&lt;/a&gt; to determine how big the output buffer should be.</source>
          <target state="translated">如果 &lt;code&gt;output&lt;/code&gt; 缓冲区太小而无法容纳结果，则抛出 &lt;code&gt;ShortBufferException&lt;/code&gt; 。在这种情况下，请使用更大的输出缓冲区重复此调用。使用&lt;a href=&quot;exemptionmechanism#getOutputSize-int-&quot;&gt; &lt;code&gt;getOutputSize&lt;/code&gt; &lt;/a&gt;确定输出缓冲区应该有多大。</target>
        </trans-unit>
        <trans-unit id="04b14a126287c47f1542560e798db984f2eaa1bd" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;output&lt;/code&gt; buffer is too small to hold the result, a &lt;code&gt;ShortBufferException&lt;/code&gt; is thrown. In this case, repeat this call with a larger output buffer. Use &lt;a href=&quot;exemptionmechanismspi#engineGetOutputSize-int-&quot;&gt;&lt;code&gt;engineGetOutputSize&lt;/code&gt;&lt;/a&gt; to determine how big the output buffer should be.</source>
          <target state="translated">如果 &lt;code&gt;output&lt;/code&gt; 缓冲区太小而无法容纳结果，则抛出 &lt;code&gt;ShortBufferException&lt;/code&gt; 。在这种情况下，请使用更大的输出缓冲区重复此调用。使用&lt;a href=&quot;exemptionmechanismspi#engineGetOutputSize-int-&quot;&gt; &lt;code&gt;engineGetOutputSize&lt;/code&gt; &lt;/a&gt;确定输出缓冲区应该有多大。</target>
        </trans-unit>
        <trans-unit id="e09b11d717ca9d2b9db6e423c314021366d5f96d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;pri&lt;/code&gt; argument is less than &lt;a href=&quot;thread#MIN_PRIORITY&quot;&gt;&lt;code&gt;Thread.MIN_PRIORITY&lt;/code&gt;&lt;/a&gt; or greater than &lt;a href=&quot;thread#MAX_PRIORITY&quot;&gt;&lt;code&gt;Thread.MAX_PRIORITY&lt;/code&gt;&lt;/a&gt;, the maximum priority of the group remains unchanged.</source>
          <target state="translated">如果 &lt;code&gt;pri&lt;/code&gt; 参数小于&lt;a href=&quot;thread#MIN_PRIORITY&quot;&gt; &lt;code&gt;Thread.MIN_PRIORITY&lt;/code&gt; &lt;/a&gt;或大于&lt;a href=&quot;thread#MAX_PRIORITY&quot;&gt; &lt;code&gt;Thread.MAX_PRIORITY&lt;/code&gt; &lt;/a&gt;，则组的最大优先级保持不变。</target>
        </trans-unit>
        <trans-unit id="72da6eb0f51543265c08bfdc0d2bc08c5c28b9d9" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;reload&lt;/code&gt; flag is &lt;code&gt;true&lt;/code&gt;, it indicates that this method is being called because the previously loaded resource bundle has expired.</source>
          <target state="translated">如果 &lt;code&gt;reload&lt;/code&gt; 标志为 &lt;code&gt;true&lt;/code&gt; ，则表示正在调用此方法，因为先前加载的资源束已过期。</target>
        </trans-unit>
        <trans-unit id="9cf1a2b060b2436670293c7813d34eef4b639e76" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;returnDelims&lt;/code&gt; flag is &lt;code&gt;true&lt;/code&gt;, then the delimiter characters are also returned as tokens. Each delimiter is returned as a string of length one. If the flag is &lt;code&gt;false&lt;/code&gt;, the delimiter characters are skipped and only serve as separators between tokens.</source>
          <target state="translated">如果 &lt;code&gt;returnDelims&lt;/code&gt; 标志为 &lt;code&gt;true&lt;/code&gt; ，则分隔符也作为标记返回。每个定界符以长度为一的字符串返回。如果该标志为 &lt;code&gt;false&lt;/code&gt; ，则分隔符将被跳过，仅用作标记之间的分隔符。</target>
        </trans-unit>
        <trans-unit id="814c644fd80ff6c6cfb5225d71687f0ea854f3a6" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;serviceURL&lt;/code&gt; looks like:</source>
          <target state="translated">如果 &lt;code&gt;serviceURL&lt;/code&gt; 看起来像：</target>
        </trans-unit>
        <trans-unit id="135f589d26f864ce90f30a25047418b479d5f710" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;serviceURL&lt;/code&gt; you specify has an empty URL path (after the optional host and port), or if you do not specify a &lt;code&gt;serviceURL&lt;/code&gt;, then the connector server will fabricate a new &lt;code&gt;JMXServiceURL&lt;/code&gt; that clients can use to connect:</source>
          <target state="translated">如果您指定的 &lt;code&gt;serviceURL&lt;/code&gt; 的URL路径为空（在可选的主机和端口之后），或者您未指定 &lt;code&gt;serviceURL&lt;/code&gt; ，则连接器服务器将 &lt;code&gt;JMXServiceURL&lt;/code&gt; 一个新的JMXServiceURL，客户端可以使用该JMXServiceURL进行连接：</target>
        </trans-unit>
        <trans-unit id="a4c7fe60b96360a2fce6906e7dfb1015497d385d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;sharedSecret&lt;/code&gt; buffer is too small to hold the result, a &lt;code&gt;ShortBufferException&lt;/code&gt; is thrown. In this case, this call should be repeated with a larger output buffer.</source>
          <target state="translated">如果 &lt;code&gt;sharedSecret&lt;/code&gt; 缓冲区太小而无法容纳结果，则将引发 &lt;code&gt;ShortBufferException&lt;/code&gt; 。在这种情况下，应使用更大的输出缓冲区重复此调用。</target>
        </trans-unit>
        <trans-unit id="a59bde6bd9cfdf4f9c0e2000a8690929361fab50" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;socket&lt;/code&gt; parameter is an instance of &lt;a href=&quot;sslsocket&quot;&gt;&lt;code&gt;SSLSocket&lt;/code&gt;&lt;/a&gt;, and the algorithm constraints of the &lt;code&gt;SSLParameters&lt;/code&gt; is non-null, for every certificate in the certification path, fields such as subject public key, the signature algorithm, key usage, extended key usage, etc. need to conform to the algorithm constraints in place on this socket.</source>
          <target state="translated">如果 &lt;code&gt;socket&lt;/code&gt; 参数是&lt;a href=&quot;sslsocket&quot;&gt; &lt;code&gt;SSLSocket&lt;/code&gt; &lt;/a&gt;的实例，并且 &lt;code&gt;SSLParameters&lt;/code&gt; 的算法约束为非null，则对于证书路径中的每个证书，都将包含诸如主题公钥，签名算法，密钥用法，扩展密钥用法等字段。需要符合此套接字上的算法约束。</target>
        </trans-unit>
        <trans-unit id="e9eeaa551ce6db761bfe71fcd9d95ed24d11d58e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;socket&lt;/code&gt; parameter is an instance of &lt;a href=&quot;sslsocket&quot;&gt;&lt;code&gt;SSLSocket&lt;/code&gt;&lt;/a&gt;, and the endpoint identification algorithm of the &lt;code&gt;SSLParameters&lt;/code&gt; is non-empty, to prevent man-in-the-middle attacks, the address that the &lt;code&gt;socket&lt;/code&gt; connected to should be checked against the peer's identity presented in the end-entity X509 certificate, as specified in the endpoint identification algorithm.</source>
          <target state="translated">如果 &lt;code&gt;socket&lt;/code&gt; 参数是&lt;a href=&quot;sslsocket&quot;&gt; &lt;code&gt;SSLSocket&lt;/code&gt; &lt;/a&gt;的实例，并且 &lt;code&gt;SSLParameters&lt;/code&gt; 的端点标识算法为非空，则为防止中间人攻击，应对照在其中显示的对等方身份检查 &lt;code&gt;socket&lt;/code&gt; 连接的地址端点标识算法中指定的最终实体X509证书。</target>
        </trans-unit>
        <trans-unit id="a8ad5fb90dd67b864239c52c78d91a33b02bcd3e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;src&lt;/code&gt; and &lt;code&gt;dest&lt;/code&gt; arguments refer to the same array object, then the copying is performed as if the components at positions &lt;code&gt;srcPos&lt;/code&gt; through &lt;code&gt;srcPos+length-1&lt;/code&gt; were first copied to a temporary array with &lt;code&gt;length&lt;/code&gt; components and then the contents of the temporary array were copied into positions &lt;code&gt;destPos&lt;/code&gt; through &lt;code&gt;destPos+length-1&lt;/code&gt; of the destination array.</source>
          <target state="translated">如果 &lt;code&gt;src&lt;/code&gt; 和 &lt;code&gt;dest&lt;/code&gt; 参数引用相同的数组对象，则执行复制，就好像首先将 &lt;code&gt;srcPos&lt;/code&gt; 到 &lt;code&gt;srcPos+length-1&lt;/code&gt; 位置上的分量复制到具有 &lt;code&gt;length&lt;/code&gt; 分量的临时数组，然后将临时数组的内容通过目标数组的 &lt;code&gt;destPos+length-1&lt;/code&gt; 复制到位置 &lt;code&gt;destPos&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="384a467e1b3d5e62425baa603c92bb9909dbf0dc" translate="yes" xml:space="preserve">
          <source>If the &lt;em&gt;quoted value&lt;/em&gt; contains at least one occurrence of the characters asterisk or question mark and they are not preceded by a backslash, then they are considered as wildcard characters and the object name is a &lt;em&gt;property value pattern&lt;/em&gt;. The asterisk matches any sequence of zero or more characters, while the question mark matches any single character.</source>
          <target state="translated">如果&lt;em&gt;引用的值&lt;/em&gt;包含至少一个出现的字符星号或问号，并且前面没有反斜杠，则将它们视为通配符，并且对象名称是&lt;em&gt;属性值模式&lt;/em&gt;。星号匹配零个或多个字符的任何序列，而问号匹配任何单个字符。</target>
        </trans-unit>
        <trans-unit id="383d196bbc70848d6d2a83c15bee341a49633abd" translate="yes" xml:space="preserve">
          <source>If the &lt;em&gt;unquoted value&lt;/em&gt; contains at least one occurrence of the wildcard characters asterisk or question mark, then the object name is a &lt;em&gt;property value pattern&lt;/em&gt;. The asterisk matches any sequence of zero or more characters, while the question mark matches any single character.</source>
          <target state="translated">如果&lt;em&gt;未引用的值&lt;/em&gt;至少包含一次出现的通配符星号或问号，则对象名称为&lt;em&gt;属性值模式&lt;/em&gt;。星号匹配零个或多个字符的任何序列，而问号匹配任何单个字符。</target>
        </trans-unit>
        <trans-unit id="8fc60c08a8c50456909645784a1769d622137e78" translate="yes" xml:space="preserve">
          <source>If the ALLOW_UNASSIGNED flag is used, the domain name string to be converted can contain code points that are unassigned in Unicode 3.2, which is the Unicode version on which IDN conversion is based. If the flag is not used, the presence of such unassigned code points is treated as an error.</source>
          <target state="translated">如果使用了ALLOW_UNASSIGNED标志,要转换的域名字符串可以包含Unicode 3.2中未分配的代码点,Unicode 3.2是IDN转换的基础版本。如果不使用该标志,则这种未分配代码点的存在将被视为错误。</target>
        </trans-unit>
        <trans-unit id="2a7c711b7120183f899af59849df74982f595de0" translate="yes" xml:space="preserve">
          <source>If the BeanInfo class for a Java Bean has been previously Introspected based on the same arguments then the BeanInfo class is retrieved from the BeanInfo cache.</source>
          <target state="translated">如果一个Java Bean的BeanInfo类之前已经基于相同的参数被Introspected过,那么BeanInfo类就会从BeanInfo缓存中被检索出来。</target>
        </trans-unit>
        <trans-unit id="27052094f3a72a9f04c55988b8fcc4b55c99cb46" translate="yes" xml:space="preserve">
          <source>If the BeanInfo class for a Java Bean has been previously Introspected based on the same arguments, then the BeanInfo class is retrieved from the BeanInfo cache.</source>
          <target state="translated">如果一个Java Bean的BeanInfo类之前已经基于相同的参数被Introspected过,那么BeanInfo类就会从BeanInfo缓存中被检索出来。</target>
        </trans-unit>
        <trans-unit id="bf6802705f363000e83d105cf3b075ebc1fbcacb" translate="yes" xml:space="preserve">
          <source>If the BeanInfo class for a Java Bean has been previously Introspected then the BeanInfo class is retrieved from the BeanInfo cache.</source>
          <target state="translated">如果一个Java Bean的BeanInfo类之前已经被Introspected,那么BeanInfo类就会从BeanInfo缓存中被检索出来。</target>
        </trans-unit>
        <trans-unit id="74b13711d7aed1bc07acd1271fe358967b6f6726" translate="yes" xml:space="preserve">
          <source>If the BeanInfo class for a Java Bean has been previously introspected based on the same arguments then the BeanInfo class is retrieved from the BeanInfo cache.</source>
          <target state="translated">如果一个Java Bean的BeanInfo类之前已经基于相同的参数进行了反省,那么BeanInfo类就会从BeanInfo缓存中检索出来。</target>
        </trans-unit>
        <trans-unit id="b9320150224d23795105d0b84d8ba0219f014f46" translate="yes" xml:space="preserve">
          <source>If the LoginContext's overall authentication failed (the relevant REQUIRED, REQUISITE, SUFFICIENT and OPTIONAL LoginModules did not succeed), then the &lt;code&gt;abort&lt;/code&gt; method for each &lt;code&gt;LoginModule&lt;/code&gt; gets invoked. In this case, the &lt;code&gt;LoginModule&lt;/code&gt; removes/destroys any authentication state originally saved.</source>
          <target state="translated">如果LoginContext的整体身份验证失败（相关的REQUIRED，REQUISITE，SUFFICIENT和OPTIONAL LoginModules不成功），则将调用每个 &lt;code&gt;LoginModule&lt;/code&gt; 的 &lt;code&gt;abort&lt;/code&gt; 方法。在这种情况下， &lt;code&gt;LoginModule&lt;/code&gt; 删除/破坏最初保存的任何身份验证状态。</target>
        </trans-unit>
        <trans-unit id="8b1ca264c954dc0a754372106598096735c9ddf1" translate="yes" xml:space="preserve">
          <source>If the MXBean is a notification emitter (i.e., it implements &lt;a href=&quot;../../../javax/management/notificationemitter&quot;&gt;&lt;code&gt;NotificationEmitter&lt;/code&gt;&lt;/a&gt;), both the &lt;code&gt;mxbeanInterface&lt;/code&gt; and &lt;code&gt;NotificationEmitter&lt;/code&gt; will be implemented by this proxy.</source>
          <target state="translated">如果MXBean是通知发射器（即，它实现&lt;a href=&quot;../../../javax/management/notificationemitter&quot;&gt; &lt;code&gt;NotificationEmitter&lt;/code&gt; &lt;/a&gt;），则此代理将同时实现 &lt;code&gt;mxbeanInterface&lt;/code&gt; 和 &lt;code&gt;NotificationEmitter&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b43d6c84cc6fb1e54fa1b85884c057f4a6774967" translate="yes" xml:space="preserve">
          <source>If the ModelMBean is currently registered, this method throws a &lt;a href=&quot;../runtimeoperationsexception&quot;&gt;&lt;code&gt;RuntimeOperationsException&lt;/code&gt;&lt;/a&gt; wrapping an &lt;a href=&quot;../../../java/lang/illegalstateexception&quot;&gt;&lt;code&gt;IllegalStateException&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">如果当前已注册ModelMBean，则此方法将引发包装&lt;a href=&quot;../../../java/lang/illegalstateexception&quot;&gt; &lt;code&gt;IllegalStateException&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;../runtimeoperationsexception&quot;&gt; &lt;code&gt;RuntimeOperationsException&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e5cc0b4b6523113fb60bbdd890e2ed587190e3eb" translate="yes" xml:space="preserve">
          <source>If the PropertyEditor doesn't honor paint requests (see isPaintable) this method should be a silent noop.</source>
          <target state="translated">如果PropertyEditor不尊重绘画请求(见isPaintable),这个方法应该是一个沉默的noop。</target>
        </trans-unit>
        <trans-unit id="edc7ecb68896dc99cf3bfe6d1c68065fc233cc04" translate="yes" xml:space="preserve">
          <source>If the ProtectionDomain was constructed to a &lt;a href=&quot;protectiondomain#ProtectionDomain-java.security.CodeSource-java.security.PermissionCollection-&quot;&gt;&lt;code&gt;statically bound&lt;/code&gt;&lt;/a&gt; PermissionCollection then the permission will only be checked against the PermissionCollection supplied at construction.</source>
          <target state="translated">如果将ProtectionDomain构造为&lt;a href=&quot;protectiondomain#ProtectionDomain-java.security.CodeSource-java.security.PermissionCollection-&quot;&gt; &lt;code&gt;statically bound&lt;/code&gt; &lt;/a&gt; PermissionCollection，则将仅对照构造时提供的PermissionCollection来检查权限。</target>
        </trans-unit>
        <trans-unit id="1eb3e9bfa37e0fb36cbe25f740fc69395067b33e" translate="yes" xml:space="preserve">
          <source>If the URL path part of the &lt;code&gt;JMXServiceURL&lt;/code&gt; was empty or a single slash (&lt;code&gt;/&lt;/code&gt;), then the RMI object will not be bound to a directory. Instead, a reference to it will be encoded in the URL path of the RMIConnectorServer address (returned by &lt;a href=&quot;rmiconnectorserver#getAddress--&quot;&gt;&lt;code&gt;getAddress()&lt;/code&gt;&lt;/a&gt;). The encodings for &lt;code&gt;rmi&lt;/code&gt; and &lt;code&gt;iiop&lt;/code&gt; are described in the package documentation for &lt;a href=&quot;package-summary&quot;&gt;&lt;code&gt;javax.management.remote.rmi&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;JMXServiceURL&lt;/code&gt; 的URL路径部分为空或单个斜杠（ &lt;code&gt;/&lt;/code&gt; ），则RMI对象将不会绑定到目录。相反，对它的引用将被编码在RMIConnectorServer地址的URL路径中（由&lt;a href=&quot;rmiconnectorserver#getAddress--&quot;&gt; &lt;code&gt;getAddress()&lt;/code&gt; &lt;/a&gt;返回）。 &lt;code&gt;rmi&lt;/code&gt; 和 &lt;code&gt;iiop&lt;/code&gt; 的编码在&lt;a href=&quot;package-summary&quot;&gt; &lt;code&gt;javax.management.remote.rmi&lt;/code&gt; &lt;/a&gt;的软件包文档中描述。</target>
        </trans-unit>
        <trans-unit id="7c88147c00b169cc4a7d700bc22d47ae19dc49b7" translate="yes" xml:space="preserve">
          <source>If the URL specified is &lt;code&gt;null&lt;/code&gt; or is already in the list of URLs, or if this loader is closed, then invoking this method has no effect.</source>
          <target state="translated">如果指定的URL为 &lt;code&gt;null&lt;/code&gt; 或已经在URL列表中，或者关闭了此加载器，则调用此方法无效。</target>
        </trans-unit>
        <trans-unit id="2c0237f144da2fa8c67cb271e88ffe70a6e43f35" translate="yes" xml:space="preserve">
          <source>If the USE_STD3_ASCII_RULES flag is used, ASCII strings are checked against &lt;a href=&quot;http://www.ietf.org/rfc/rfc1122.txt&quot;&gt;RFC 1122&lt;/a&gt; and &lt;a href=&quot;http://www.ietf.org/rfc/rfc1123.txt&quot;&gt;RFC 1123&lt;/a&gt;. It is an error if they don't meet the requirements.</source>
          <target state="translated">如果使用USE_STD3_ASCII_RULES标志，则根据&lt;a href=&quot;http://www.ietf.org/rfc/rfc1122.txt&quot;&gt;RFC 1122&lt;/a&gt;和&lt;a href=&quot;http://www.ietf.org/rfc/rfc1123.txt&quot;&gt;RFC 1123&lt;/a&gt;检查ASCII字符串。如果他们不符合要求，那就是错误的。</target>
        </trans-unit>
        <trans-unit id="27b1988df75b26444a795d6673a2d8719150a662" translate="yes" xml:space="preserve">
          <source>If the Unicode Standard changes block names, both the previous and current names will be accepted.</source>
          <target state="translated">如果Unicode标准改变了块名,以前的和当前的名称都会被接受。</target>
        </trans-unit>
        <trans-unit id="4474e2c1fcf43dbf037954df628912501189beb2" translate="yes" xml:space="preserve">
          <source>If the Vector fits in the specified array with room to spare (i.e., the array has more elements than the Vector), the element in the array immediately following the end of the Vector is set to null. (This is useful in determining the length of the Vector &lt;em&gt;only&lt;/em&gt; if the caller knows that the Vector does not contain any null elements.)</source>
          <target state="translated">如果Vector符合指定数组的剩余空间（即，数组中的元素多于Vector），则将紧随Vector末尾的数组中的元素设置为null。（&lt;em&gt;仅&lt;/em&gt;当调用者知道Vector不包含任何null元素时，这才对确定Vector的长度很有用。）</target>
        </trans-unit>
        <trans-unit id="9f95877bd50006d6d00056ef2a51aa22bd21083c" translate="yes" xml:space="preserve">
          <source>If the above rules do not produce a value, and if introspection, as if by calling &lt;a href=&quot;../../../java/beans/introspector#getBeanInfo-java.lang.Class-&quot;&gt;&lt;code&gt;Introspector.getBeanInfo&lt;/code&gt;&lt;/a&gt;, for the class of</source>
          <target state="translated">如果上述规则未产生值，并且进行了自省，就好像通过调用&lt;a href=&quot;../../../java/beans/introspector#getBeanInfo-java.lang.Class-&quot;&gt; &lt;code&gt;Introspector.getBeanInfo&lt;/code&gt; &lt;/a&gt;为该类</target>
        </trans-unit>
        <trans-unit id="9b05835af2c154a7c76f77377aa6c52d404cdcb8" translate="yes" xml:space="preserve">
          <source>If the absolute value of the first argument equals 1 and the second argument is infinite, then the result is NaN.</source>
          <target state="translated">如果第一个参数的绝对值等于1,第二个参数是无限的,那么结果就是NaN。</target>
        </trans-unit>
        <trans-unit id="d6afccfd8739251584afc0914039b51c90ada53f" translate="yes" xml:space="preserve">
          <source>If the action is an instance of &lt;code&gt;DoubleConsumer&lt;/code&gt; then it is cast to &lt;code&gt;DoubleConsumer&lt;/code&gt; and passed to &lt;a href=&quot;primitiveiterator.ofdouble#forEachRemaining-java.util.function.DoubleConsumer-&quot;&gt;&lt;code&gt;forEachRemaining(java.util.function.DoubleConsumer)&lt;/code&gt;&lt;/a&gt;; otherwise the action is adapted to an instance of &lt;code&gt;DoubleConsumer&lt;/code&gt;, by boxing the argument of &lt;code&gt;DoubleConsumer&lt;/code&gt;, and then passed to &lt;a href=&quot;primitiveiterator.ofdouble#forEachRemaining-java.util.function.DoubleConsumer-&quot;&gt;&lt;code&gt;forEachRemaining(java.util.function.DoubleConsumer)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果操作是 &lt;code&gt;DoubleConsumer&lt;/code&gt; 的实例，则将其&lt;a href=&quot;primitiveiterator.ofdouble#forEachRemaining-java.util.function.DoubleConsumer-&quot;&gt; &lt;code&gt;forEachRemaining(java.util.function.DoubleConsumer)&lt;/code&gt; &lt;/a&gt; &lt;code&gt;DoubleConsumer&lt;/code&gt; 为DoubleConsumer并传递给forEachRemaining（java.util.function.DoubleConsumer）；否则，通过将 &lt;code&gt;DoubleConsumer&lt;/code&gt; 的参数装箱，将操作调整为 &lt;code&gt;DoubleConsumer&lt;/code&gt; 的实例，然后将其传递给&lt;a href=&quot;primitiveiterator.ofdouble#forEachRemaining-java.util.function.DoubleConsumer-&quot;&gt; &lt;code&gt;forEachRemaining(java.util.function.DoubleConsumer)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="66516904fde9701dc7f61bc426819fb4f146f708" translate="yes" xml:space="preserve">
          <source>If the action is an instance of &lt;code&gt;DoubleConsumer&lt;/code&gt; then it is cast to &lt;code&gt;DoubleConsumer&lt;/code&gt; and passed to &lt;a href=&quot;spliterator.ofdouble#forEachRemaining-java.util.function.DoubleConsumer-&quot;&gt;&lt;code&gt;forEachRemaining(java.util.function.DoubleConsumer)&lt;/code&gt;&lt;/a&gt;; otherwise the action is adapted to an instance of &lt;code&gt;DoubleConsumer&lt;/code&gt;, by boxing the argument of &lt;code&gt;DoubleConsumer&lt;/code&gt;, and then passed to &lt;a href=&quot;spliterator.ofdouble#forEachRemaining-java.util.function.DoubleConsumer-&quot;&gt;&lt;code&gt;forEachRemaining(java.util.function.DoubleConsumer)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果操作是 &lt;code&gt;DoubleConsumer&lt;/code&gt; 的实例，则将其&lt;a href=&quot;spliterator.ofdouble#forEachRemaining-java.util.function.DoubleConsumer-&quot;&gt; &lt;code&gt;forEachRemaining(java.util.function.DoubleConsumer)&lt;/code&gt; &lt;/a&gt; &lt;code&gt;DoubleConsumer&lt;/code&gt; 为DoubleConsumer并传递给forEachRemaining（java.util.function.DoubleConsumer）；否则，通过将 &lt;code&gt;DoubleConsumer&lt;/code&gt; 的参数装箱，将操作调整为 &lt;code&gt;DoubleConsumer&lt;/code&gt; 的实例，然后将其传递给&lt;a href=&quot;spliterator.ofdouble#forEachRemaining-java.util.function.DoubleConsumer-&quot;&gt; &lt;code&gt;forEachRemaining(java.util.function.DoubleConsumer)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6e52e55025286a627afde1b1d2b384ea2bee735b" translate="yes" xml:space="preserve">
          <source>If the action is an instance of &lt;code&gt;DoubleConsumer&lt;/code&gt; then it is cast to &lt;code&gt;DoubleConsumer&lt;/code&gt; and passed to &lt;a href=&quot;spliterator.ofdouble#tryAdvance-java.util.function.DoubleConsumer-&quot;&gt;&lt;code&gt;tryAdvance(java.util.function.DoubleConsumer)&lt;/code&gt;&lt;/a&gt;; otherwise the action is adapted to an instance of &lt;code&gt;DoubleConsumer&lt;/code&gt;, by boxing the argument of &lt;code&gt;DoubleConsumer&lt;/code&gt;, and then passed to &lt;a href=&quot;spliterator.ofdouble#tryAdvance-java.util.function.DoubleConsumer-&quot;&gt;&lt;code&gt;tryAdvance(java.util.function.DoubleConsumer)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果操作是 &lt;code&gt;DoubleConsumer&lt;/code&gt; 的实例，则将其&lt;a href=&quot;spliterator.ofdouble#tryAdvance-java.util.function.DoubleConsumer-&quot;&gt; &lt;code&gt;tryAdvance(java.util.function.DoubleConsumer)&lt;/code&gt; &lt;/a&gt; &lt;code&gt;DoubleConsumer&lt;/code&gt; 为DoubleConsumer并传递给tryAdvance（java.util.function.DoubleConsumer）；否则，通过将 &lt;code&gt;DoubleConsumer&lt;/code&gt; 的参数装箱，将操作调整为 &lt;code&gt;DoubleConsumer&lt;/code&gt; 实例，然后将其传递给&lt;a href=&quot;spliterator.ofdouble#tryAdvance-java.util.function.DoubleConsumer-&quot;&gt; &lt;code&gt;tryAdvance(java.util.function.DoubleConsumer)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6eb467bff49959d09e05c7bab75146704c0dc28d" translate="yes" xml:space="preserve">
          <source>If the action is an instance of &lt;code&gt;IntConsumer&lt;/code&gt; then it is cast to &lt;code&gt;IntConsumer&lt;/code&gt; and passed to &lt;a href=&quot;primitiveiterator.ofint#forEachRemaining-java.util.function.IntConsumer-&quot;&gt;&lt;code&gt;forEachRemaining(java.util.function.IntConsumer)&lt;/code&gt;&lt;/a&gt;; otherwise the action is adapted to an instance of &lt;code&gt;IntConsumer&lt;/code&gt;, by boxing the argument of &lt;code&gt;IntConsumer&lt;/code&gt;, and then passed to &lt;a href=&quot;primitiveiterator.ofint#forEachRemaining-java.util.function.IntConsumer-&quot;&gt;&lt;code&gt;forEachRemaining(java.util.function.IntConsumer)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果操作是 &lt;code&gt;IntConsumer&lt;/code&gt; 的实例，则将其强制转换为 &lt;code&gt;IntConsumer&lt;/code&gt; 并传递给&lt;a href=&quot;primitiveiterator.ofint#forEachRemaining-java.util.function.IntConsumer-&quot;&gt; &lt;code&gt;forEachRemaining(java.util.function.IntConsumer)&lt;/code&gt; &lt;/a&gt;；否则，通过将 &lt;code&gt;IntConsumer&lt;/code&gt; 的参数装箱，将操作调整为 &lt;code&gt;IntConsumer&lt;/code&gt; 的实例，然后将其传递给&lt;a href=&quot;primitiveiterator.ofint#forEachRemaining-java.util.function.IntConsumer-&quot;&gt; &lt;code&gt;forEachRemaining(java.util.function.IntConsumer)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2cc7b37b752547334d50d87c5179ebe5f7826e35" translate="yes" xml:space="preserve">
          <source>If the action is an instance of &lt;code&gt;IntConsumer&lt;/code&gt; then it is cast to &lt;code&gt;IntConsumer&lt;/code&gt; and passed to &lt;a href=&quot;spliterator.ofint#forEachRemaining-java.util.function.IntConsumer-&quot;&gt;&lt;code&gt;forEachRemaining(java.util.function.IntConsumer)&lt;/code&gt;&lt;/a&gt;; otherwise the action is adapted to an instance of &lt;code&gt;IntConsumer&lt;/code&gt;, by boxing the argument of &lt;code&gt;IntConsumer&lt;/code&gt;, and then passed to &lt;a href=&quot;spliterator.ofint#forEachRemaining-java.util.function.IntConsumer-&quot;&gt;&lt;code&gt;forEachRemaining(java.util.function.IntConsumer)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果操作是 &lt;code&gt;IntConsumer&lt;/code&gt; 的实例，则将其强制转换为 &lt;code&gt;IntConsumer&lt;/code&gt; 并传递给&lt;a href=&quot;spliterator.ofint#forEachRemaining-java.util.function.IntConsumer-&quot;&gt; &lt;code&gt;forEachRemaining(java.util.function.IntConsumer)&lt;/code&gt; &lt;/a&gt;；否则，通过将 &lt;code&gt;IntConsumer&lt;/code&gt; 的参数装箱，将操作调整为 &lt;code&gt;IntConsumer&lt;/code&gt; 的实例，然后将其传递给&lt;a href=&quot;spliterator.ofint#forEachRemaining-java.util.function.IntConsumer-&quot;&gt; &lt;code&gt;forEachRemaining(java.util.function.IntConsumer)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e4a7f713f21116ad3b228e0623aa03e2b62a6679" translate="yes" xml:space="preserve">
          <source>If the action is an instance of &lt;code&gt;IntConsumer&lt;/code&gt; then it is cast to &lt;code&gt;IntConsumer&lt;/code&gt; and passed to &lt;a href=&quot;spliterator.ofint#tryAdvance-java.util.function.IntConsumer-&quot;&gt;&lt;code&gt;tryAdvance(java.util.function.IntConsumer)&lt;/code&gt;&lt;/a&gt;; otherwise the action is adapted to an instance of &lt;code&gt;IntConsumer&lt;/code&gt;, by boxing the argument of &lt;code&gt;IntConsumer&lt;/code&gt;, and then passed to &lt;a href=&quot;spliterator.ofint#tryAdvance-java.util.function.IntConsumer-&quot;&gt;&lt;code&gt;tryAdvance(java.util.function.IntConsumer)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果该动作是 &lt;code&gt;IntConsumer&lt;/code&gt; 的实例，则将其强制转换为 &lt;code&gt;IntConsumer&lt;/code&gt; 并传递给&lt;a href=&quot;spliterator.ofint#tryAdvance-java.util.function.IntConsumer-&quot;&gt; &lt;code&gt;tryAdvance(java.util.function.IntConsumer)&lt;/code&gt; &lt;/a&gt;；否则，通过将 &lt;code&gt;IntConsumer&lt;/code&gt; 的参数装箱，将操作调整为 &lt;code&gt;IntConsumer&lt;/code&gt; 的实例，然后将其传递给&lt;a href=&quot;spliterator.ofint#tryAdvance-java.util.function.IntConsumer-&quot;&gt; &lt;code&gt;tryAdvance(java.util.function.IntConsumer)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="290eeb3f1f54f16b09955c88d8cfd90d14b9557d" translate="yes" xml:space="preserve">
          <source>If the action is an instance of &lt;code&gt;LongConsumer&lt;/code&gt; then it is cast to &lt;code&gt;LongConsumer&lt;/code&gt; and passed to &lt;a href=&quot;primitiveiterator.oflong#forEachRemaining-java.util.function.LongConsumer-&quot;&gt;&lt;code&gt;forEachRemaining(java.util.function.LongConsumer)&lt;/code&gt;&lt;/a&gt;; otherwise the action is adapted to an instance of &lt;code&gt;LongConsumer&lt;/code&gt;, by boxing the argument of &lt;code&gt;LongConsumer&lt;/code&gt;, and then passed to &lt;a href=&quot;primitiveiterator.oflong#forEachRemaining-java.util.function.LongConsumer-&quot;&gt;&lt;code&gt;forEachRemaining(java.util.function.LongConsumer)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果该操作是 &lt;code&gt;LongConsumer&lt;/code&gt; 的实例，则将其强制转换为 &lt;code&gt;LongConsumer&lt;/code&gt; 并传递给&lt;a href=&quot;primitiveiterator.oflong#forEachRemaining-java.util.function.LongConsumer-&quot;&gt; &lt;code&gt;forEachRemaining(java.util.function.LongConsumer)&lt;/code&gt; &lt;/a&gt;；否则，通过对 &lt;code&gt;LongConsumer&lt;/code&gt; 的参数进行装箱，将操作调整为 &lt;code&gt;LongConsumer&lt;/code&gt; 的实例，然后将其传递给&lt;a href=&quot;primitiveiterator.oflong#forEachRemaining-java.util.function.LongConsumer-&quot;&gt; &lt;code&gt;forEachRemaining(java.util.function.LongConsumer)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f0dcd5ef32e41f4bca014a916ec5e3e0e6b1fab7" translate="yes" xml:space="preserve">
          <source>If the action is an instance of &lt;code&gt;LongConsumer&lt;/code&gt; then it is cast to &lt;code&gt;LongConsumer&lt;/code&gt; and passed to &lt;a href=&quot;spliterator.oflong#forEachRemaining-java.util.function.LongConsumer-&quot;&gt;&lt;code&gt;forEachRemaining(java.util.function.LongConsumer)&lt;/code&gt;&lt;/a&gt;; otherwise the action is adapted to an instance of &lt;code&gt;LongConsumer&lt;/code&gt;, by boxing the argument of &lt;code&gt;LongConsumer&lt;/code&gt;, and then passed to &lt;a href=&quot;spliterator.oflong#forEachRemaining-java.util.function.LongConsumer-&quot;&gt;&lt;code&gt;forEachRemaining(java.util.function.LongConsumer)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果该操作是 &lt;code&gt;LongConsumer&lt;/code&gt; 的实例，则将其强制转换为 &lt;code&gt;LongConsumer&lt;/code&gt; 并传递给&lt;a href=&quot;spliterator.oflong#forEachRemaining-java.util.function.LongConsumer-&quot;&gt; &lt;code&gt;forEachRemaining(java.util.function.LongConsumer)&lt;/code&gt; &lt;/a&gt;；否则，通过对 &lt;code&gt;LongConsumer&lt;/code&gt; 的参数进行装箱，将操作调整为 &lt;code&gt;LongConsumer&lt;/code&gt; 的实例，然后将其传递给&lt;a href=&quot;spliterator.oflong#forEachRemaining-java.util.function.LongConsumer-&quot;&gt; &lt;code&gt;forEachRemaining(java.util.function.LongConsumer)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="00bbc10814534bf0219172f193911a9aeadd7e16" translate="yes" xml:space="preserve">
          <source>If the action is an instance of &lt;code&gt;LongConsumer&lt;/code&gt; then it is cast to &lt;code&gt;LongConsumer&lt;/code&gt; and passed to &lt;a href=&quot;spliterator.oflong#tryAdvance-java.util.function.LongConsumer-&quot;&gt;&lt;code&gt;tryAdvance(java.util.function.LongConsumer)&lt;/code&gt;&lt;/a&gt;; otherwise the action is adapted to an instance of &lt;code&gt;LongConsumer&lt;/code&gt;, by boxing the argument of &lt;code&gt;LongConsumer&lt;/code&gt;, and then passed to &lt;a href=&quot;spliterator.oflong#tryAdvance-java.util.function.LongConsumer-&quot;&gt;&lt;code&gt;tryAdvance(java.util.function.LongConsumer)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果该动作是 &lt;code&gt;LongConsumer&lt;/code&gt; 的实例，则将其强制转换为 &lt;code&gt;LongConsumer&lt;/code&gt; 并传递给&lt;a href=&quot;spliterator.oflong#tryAdvance-java.util.function.LongConsumer-&quot;&gt; &lt;code&gt;tryAdvance(java.util.function.LongConsumer)&lt;/code&gt; &lt;/a&gt;；否则，通过将 &lt;code&gt;LongConsumer&lt;/code&gt; 的参数装箱，将操作调整为 &lt;code&gt;LongConsumer&lt;/code&gt; 的实例，然后将其传递给&lt;a href=&quot;spliterator.oflong#tryAdvance-java.util.function.LongConsumer-&quot;&gt; &lt;code&gt;tryAdvance(java.util.function.LongConsumer)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3b5ff8c69ea26957c669b0830c3787c984d9d074" translate="yes" xml:space="preserve">
          <source>If the action performed in your &lt;code&gt;run&lt;/code&gt; method could throw a &quot;checked&quot; exception (those listed in the &lt;code&gt;throws&lt;/code&gt; clause of a method), then you need to use the &lt;code&gt;PrivilegedExceptionAction&lt;/code&gt; interface instead of the &lt;code&gt;PrivilegedAction&lt;/code&gt; interface:</source>
          <target state="translated">如果在 &lt;code&gt;run&lt;/code&gt; 方法中执行的操作可能引发&amp;ldquo;已检查&amp;rdquo;异常（方法的 &lt;code&gt;throws&lt;/code&gt; 子句中列出的异常），则需要使用 &lt;code&gt;PrivilegedExceptionAction&lt;/code&gt; 接口而不是 &lt;code&gt;PrivilegedAction&lt;/code&gt; 接口：</target>
        </trans-unit>
        <trans-unit id="f8b6f3a11b20582c114df00bdb40a1e0e0cbd27f" translate="yes" xml:space="preserve">
          <source>If the action's &lt;code&gt;run&lt;/code&gt; method throws an</source>
          <target state="translated">如果操作的 &lt;code&gt;run&lt;/code&gt; 方法抛出一个</target>
        </trans-unit>
        <trans-unit id="6baa6ffe1bf64066619e4375881dfdc0f383d936" translate="yes" xml:space="preserve">
          <source>If the action's &lt;code&gt;run&lt;/code&gt; method throws an (unchecked) exception, it will propagate through this method.</source>
          <target state="translated">如果操作的 &lt;code&gt;run&lt;/code&gt; 方法抛出（未检查的）异常，它将通过此​​方法传播。</target>
        </trans-unit>
        <trans-unit id="102269f064fade95ae910ba7bdf983251013c399" translate="yes" xml:space="preserve">
          <source>If the address is &lt;code&gt;null&lt;/code&gt;, then the system will pick up an ephemeral port and a valid local address to bind the socket.</source>
          <target state="translated">如果地址为 &lt;code&gt;null&lt;/code&gt; ，则系统将选择一个临时端口和一个有效的本地地址来绑定套接字。</target>
        </trans-unit>
        <trans-unit id="e4c80757c9e2ecb6b75dc0a37636c30cb9490032" translate="yes" xml:space="preserve">
          <source>If the algorithm is the</source>
          <target state="translated">如果算法是</target>
        </trans-unit>
        <trans-unit id="0e8d5a3e745f1450eac261edbc32910b4882938f" translate="yes" xml:space="preserve">
          <source>If the amount is a &lt;code&gt;ChronoPeriod&lt;/code&gt; then it must use the ISO chronology.</source>
          <target state="translated">如果金额是 &lt;code&gt;ChronoPeriod&lt;/code&gt; ,则必须使用ISO年代。</target>
        </trans-unit>
        <trans-unit id="4d740232e114f21d31c73ca4687c4057fb29ccd4" translate="yes" xml:space="preserve">
          <source>If the amount of saving time at any given time stamp is required, construct a &lt;a href=&quot;calendar&quot;&gt;&lt;code&gt;Calendar&lt;/code&gt;&lt;/a&gt; with this &lt;code&gt;TimeZone&lt;/code&gt; and the time stamp, and call &lt;a href=&quot;calendar#get-int-&quot;&gt;&lt;code&gt;Calendar.get&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(&lt;/code&gt;&lt;a href=&quot;calendar#DST_OFFSET&quot;&gt;&lt;code&gt;Calendar.DST_OFFSET&lt;/code&gt;&lt;/a&gt;&lt;code&gt;)&lt;/code&gt;.</source>
          <target state="translated">如果需要在任何给定的时间戳上节省时间，请使用此 &lt;code&gt;TimeZone&lt;/code&gt; 和时间戳构造一个&lt;a href=&quot;calendar&quot;&gt; &lt;code&gt;Calendar&lt;/code&gt; &lt;/a&gt;，然后调用&lt;a href=&quot;calendar#get-int-&quot;&gt; &lt;code&gt;Calendar.get&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(&lt;/code&gt; &lt;a href=&quot;calendar#DST_OFFSET&quot;&gt; &lt;code&gt;Calendar.DST_OFFSET&lt;/code&gt; &lt;/a&gt; &lt;code&gt;)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="272549f61fd737d1e73b2c36c4aa004c00079132" translate="yes" xml:space="preserve">
          <source>If the answer is NO, go to the next step.</source>
          <target state="translated">如果答案是NO,则进入下一步。</target>
        </trans-unit>
        <trans-unit id="f57b79608f2a3ff0ec11e483aaaa3a019d8c2b5b" translate="yes" xml:space="preserve">
          <source>If the answer is NO, throw a &lt;code&gt;NoSuchAlgorithmException&lt;/code&gt; exception.</source>
          <target state="translated">如果答案为否，则抛出 &lt;code&gt;NoSuchAlgorithmException&lt;/code&gt; 异常。</target>
        </trans-unit>
        <trans-unit id="434e3dee0acd3560230fa30595feca5a213bbce4" translate="yes" xml:space="preserve">
          <source>If the answer is YES, instantiate it, and call &lt;code&gt;engineSetMode(&lt;i&gt;mode&lt;/i&gt;)&lt;/code&gt; and &lt;code&gt;engineSetPadding(&lt;i&gt;padding&lt;/i&gt;)&lt;/code&gt; on the new instance.</source>
          <target state="translated">如果答案为是，请实例化它，然后在新实例上调用 &lt;code&gt;engineSetMode(&lt;i&gt;mode&lt;/i&gt;)&lt;/code&gt; 和 &lt;code&gt;engineSetPadding(&lt;i&gt;padding&lt;/i&gt;)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a1eb85cb2614bd41f0d6af38673aa7528bca07f4" translate="yes" xml:space="preserve">
          <source>If the answer is YES, instantiate it, and call &lt;code&gt;engineSetMode(&lt;i&gt;mode&lt;/i&gt;)&lt;/code&gt; on the new instance.</source>
          <target state="translated">如果答案为是，请实例化它，然后在新实例上调用 &lt;code&gt;engineSetMode(&lt;i&gt;mode&lt;/i&gt;)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="de83ee4eae564494ffc414cfaf8cc18d47b2bed1" translate="yes" xml:space="preserve">
          <source>If the answer is YES, instantiate it, and call &lt;code&gt;engineSetPadding(&lt;i&gt;padding&lt;/i&gt;)&lt;/code&gt; on the new instance.</source>
          <target state="translated">如果答案为是，请实例化它，然后在新实例上调用 &lt;code&gt;engineSetPadding(&lt;i&gt;padding&lt;/i&gt;)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="56a7594c327855897bea9f06e5423ff72ccb1d7b" translate="yes" xml:space="preserve">
          <source>If the answer is YES, instantiate it.</source>
          <target state="translated">如果答案是YES,将其实例化。</target>
        </trans-unit>
        <trans-unit id="160782cdb54c84087be65e0efddfac392e283c77" translate="yes" xml:space="preserve">
          <source>If the answer is YES, instantiate this class, for whose mode and padding scheme default values (as supplied by the provider) are used.</source>
          <target state="translated">如果答案是YES,则实例化这个类,使用其模式和填充方案的默认值(由提供者提供)。</target>
        </trans-unit>
        <trans-unit id="968a78947275cffe7a67b6a953d091962ffdb8ec" translate="yes" xml:space="preserve">
          <source>If the application has previously set up an instance of &lt;code&gt;URLStreamHandlerFactory&lt;/code&gt; as the stream handler factory, then the &lt;code&gt;createURLStreamHandler&lt;/code&gt; method of that instance is called with the protocol string as an argument to create the stream protocol handler.</source>
          <target state="translated">如果应用程序先前已将 &lt;code&gt;URLStreamHandlerFactory&lt;/code&gt; 的实例设置为流处理程序工厂，则使用协议字符串作为参数来 &lt;code&gt;createURLStreamHandler&lt;/code&gt; 该实例的createURLStreamHandler方法，以创建流协议处理程序。</target>
        </trans-unit>
        <trans-unit id="2070d70078ec2db5e6d48447de6438828f0279ed" translate="yes" xml:space="preserve">
          <source>If the application has set up a content handler factory instance using the &lt;code&gt;setContentHandlerFactory&lt;/code&gt; method, the &lt;code&gt;createContentHandler&lt;/code&gt; method of that instance is called with the content type as an argument; the result is a content handler for that content type.</source>
          <target state="translated">如果应用程序已使用 &lt;code&gt;setContentHandlerFactory&lt;/code&gt; 方法设置了内容处理程序工厂实例，则使用内容类型作为参数来调用该实例的 &lt;code&gt;createContentHandler&lt;/code&gt; 方法；否则，将使用内容类型作为参数来调用该实例。结果是该内容类型的内容处理程序。</target>
        </trans-unit>
        <trans-unit id="91fdcd973932e65f09e9bdaebd48fb198c503271" translate="yes" xml:space="preserve">
          <source>If the application has specified a server socket factory, that factory's &lt;code&gt;createSocketImpl&lt;/code&gt; method is called to create the actual socket implementation. Otherwise a &quot;plain&quot; socket is created.</source>
          <target state="translated">如果应用程序指定了服务器套接字工厂，则将调用该工厂的 &lt;code&gt;createSocketImpl&lt;/code&gt; 方法来创建实际的套接字实现。否则，将创建一个&amp;ldquo;普通&amp;rdquo;套接字。</target>
        </trans-unit>
        <trans-unit id="221a9611027772cf1f0b3bdc427ffc5e66a9af4e" translate="yes" xml:space="preserve">
          <source>If the application has specified a socket factory, that factory's &lt;code&gt;createSocketImpl&lt;/code&gt; method is called to create the actual socket implementation. Otherwise a &quot;plain&quot; socket is created.</source>
          <target state="translated">如果应用程序指定了套接字工厂，则将调用该工厂的 &lt;code&gt;createSocketImpl&lt;/code&gt; 方法来创建实际的套接字实现。否则，将创建一个&amp;ldquo;普通&amp;rdquo;套接字。</target>
        </trans-unit>
        <trans-unit id="2b8dff9cb695d7cf445c13c7a8630fbe3ce30315" translate="yes" xml:space="preserve">
          <source>If the application initiated the closing process by calling &lt;a href=&quot;sslengine#closeOutbound--&quot;&gt;&lt;code&gt;closeOutbound()&lt;/code&gt;&lt;/a&gt;, under some circumstances it is not required that the initiator wait for the peer's corresponding close message. (See section 7.2.1 of the TLS specification (&lt;a href=&quot;http://www.ietf.org/rfc/rfc2246.txt&quot;&gt;RFC 2246&lt;/a&gt;) for more information on waiting for closure alerts.) In such cases, this method need not be called.</source>
          <target state="translated">如果应用程序通过调用&lt;a href=&quot;sslengine#closeOutbound--&quot;&gt; &lt;code&gt;closeOutbound()&lt;/code&gt; &lt;/a&gt;启动关闭过程，则在某些情况下，不需要启动程序等待对等方的相应关闭消息。（有关等待关闭警报的更多信息，请参见TLS规范（&lt;a href=&quot;http://www.ietf.org/rfc/rfc2246.txt&quot;&gt;RFC 2246&lt;/a&gt;）的7.2.1节。）在这种情况下，不需要调用此方法。</target>
        </trans-unit>
        <trans-unit id="9908f3b7f0fcd38e518a64cda27a8bcf7af02eae" translate="yes" xml:space="preserve">
          <source>If the argument</source>
          <target state="translated">如果争论</target>
        </trans-unit>
        <trans-unit id="18ba07a0dacca161f919bf38b3942c5cbf0de7b4" translate="yes" xml:space="preserve">
          <source>If the argument index is used for more than one format element in the pattern string, then the new format is used for all such format elements. If the argument index is not used for any format element in the pattern string, then the new format is ignored.</source>
          <target state="translated">如果参数索引用于模式字符串中一个以上的格式元素,那么新的格式将用于所有这些格式元素。如果参数索引没有用于模式字符串中的任何格式元素,那么新格式将被忽略。</target>
        </trans-unit>
        <trans-unit id="201ffc4148225e00891b41aafa471a7bc0ae4e31" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;&lt;code&gt;Double.MAX_VALUE&lt;/code&gt;, then the result is equal to 2&lt;sup&gt;971&lt;/sup&gt;.</source>
          <target state="translated">如果参数为&amp;plusmn; &lt;code&gt;Double.MAX_VALUE&lt;/code&gt; ，则结果等于2 &lt;sup&gt;971&lt;/sup&gt;。</target>
        </trans-unit>
        <trans-unit id="0500f3687980d0c066085bfc637859d5a0f94f45" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;&lt;code&gt;Float.MAX_VALUE&lt;/code&gt;, then the result is equal to 2&lt;sup&gt;104&lt;/sup&gt;.</source>
          <target state="translated">如果参数为&amp;plusmn; &lt;code&gt;Float.MAX_VALUE&lt;/code&gt; ，则结果等于2 &lt;sup&gt;104&lt;/sup&gt;。</target>
        </trans-unit>
        <trans-unit id="e418b56eeca30ec55767a713e51154185f73b688" translate="yes" xml:space="preserve">
          <source>If the argument is &lt;code&gt;0x7f800000&lt;/code&gt;, the result is positive infinity.</source>
          <target state="translated">如果参数为 &lt;code&gt;0x7f800000&lt;/code&gt; ，则结果为正无穷大。</target>
        </trans-unit>
        <trans-unit id="cc33fb1734d8e8472093718dadfa691efa944850" translate="yes" xml:space="preserve">
          <source>If the argument is &lt;code&gt;0x7ff0000000000000L&lt;/code&gt;, the result is positive infinity.</source>
          <target state="translated">如果参数为 &lt;code&gt;0x7ff0000000000000L&lt;/code&gt; ，则结果为正无穷大。</target>
        </trans-unit>
        <trans-unit id="67ad4ce5c4db05b329a5cf076b7ace8df7e07d24" translate="yes" xml:space="preserve">
          <source>If the argument is &lt;code&gt;0xff800000&lt;/code&gt;, the result is negative infinity.</source>
          <target state="translated">如果参数为 &lt;code&gt;0xff800000&lt;/code&gt; ，则结果为负无穷大。</target>
        </trans-unit>
        <trans-unit id="44b83a1db6251fafa0226412a16d0a5aa743a573" translate="yes" xml:space="preserve">
          <source>If the argument is &lt;code&gt;0xfff0000000000000L&lt;/code&gt;, the result is negative infinity.</source>
          <target state="translated">如果参数为 &lt;code&gt;0xfff0000000000000L&lt;/code&gt; ，则结果为负无穷大。</target>
        </trans-unit>
        <trans-unit id="970f258bf10d8b6db35da86a6962bea7e6f056c5" translate="yes" xml:space="preserve">
          <source>If the argument is &lt;code&gt;null&lt;/code&gt;, then the result is &quot;&lt;code&gt;false&lt;/code&gt;&quot;. If the argument is a &lt;code&gt;boolean&lt;/code&gt; or &lt;a href=&quot;../lang/boolean&quot;&gt;&lt;code&gt;Boolean&lt;/code&gt;&lt;/a&gt;, then the result is the string returned by &lt;a href=&quot;../lang/string#valueOf-boolean-&quot;&gt;&lt;code&gt;String.valueOf()&lt;/code&gt;&lt;/a&gt;. Otherwise, the result is &quot;&lt;code&gt;true&lt;/code&gt;&quot;.</source>
          <target state="translated">如果参数为 &lt;code&gt;null&lt;/code&gt; ，则结果为&amp;ldquo; &lt;code&gt;false&lt;/code&gt; &amp;rdquo;。如果参数是 &lt;code&gt;boolean&lt;/code&gt; 或&lt;a href=&quot;../lang/boolean&quot;&gt; &lt;code&gt;Boolean&lt;/code&gt; &lt;/a&gt;，则结果是&lt;a href=&quot;../lang/string#valueOf-boolean-&quot;&gt; &lt;code&gt;String.valueOf()&lt;/code&gt; &lt;/a&gt;返回的字符串。否则，结果为&amp;ldquo; &lt;code&gt;true&lt;/code&gt; &amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="4acdffc199e6f4f9b1d96e0f15f8a4c625bb7edd" translate="yes" xml:space="preserve">
          <source>If the argument is &lt;code&gt;null&lt;/code&gt;, then the result is &quot;&lt;code&gt;null&lt;/code&gt;&quot;. If the argument implements &lt;a href=&quot;formattable&quot;&gt;&lt;code&gt;Formattable&lt;/code&gt;&lt;/a&gt;, then its &lt;a href=&quot;formattable#formatTo-java.util.Formatter-int-int-int-&quot;&gt;&lt;code&gt;formatTo&lt;/code&gt;&lt;/a&gt; method is invoked. Otherwise, the result is obtained by invoking the argument's &lt;code&gt;toString()&lt;/code&gt; method.</source>
          <target state="translated">如果参数为 &lt;code&gt;null&lt;/code&gt; ，则结果为&amp;ldquo; &lt;code&gt;null&lt;/code&gt; &amp;rdquo;。如果参数实现&lt;a href=&quot;formattable&quot;&gt; &lt;code&gt;Formattable&lt;/code&gt; &lt;/a&gt;，则调用其&lt;a href=&quot;formattable#formatTo-java.util.Formatter-int-int-int-&quot;&gt; &lt;code&gt;formatTo&lt;/code&gt; &lt;/a&gt;方法。否则，通过调用参数的 &lt;code&gt;toString()&lt;/code&gt; 方法获得结果。</target>
        </trans-unit>
        <trans-unit id="fe94a89675405323875ef4ec6ff361112380225e" translate="yes" xml:space="preserve">
          <source>If the argument is NaN or an infinity or positive zero or negative zero, then the result is the same as the argument.</source>
          <target state="translated">如果参数是NaN或无穷大或正零或负零,那么结果与参数相同。</target>
        </trans-unit>
        <trans-unit id="0f1490c0a73a4bdc7beee59aa0b2e8886fa1ac76" translate="yes" xml:space="preserve">
          <source>If the argument is NaN or an infinity, then the result is NaN.</source>
          <target state="translated">如果参数是NaN或无穷大,那么结果就是NaN。</target>
        </trans-unit>
        <trans-unit id="e8d658cc42466718800cf906b23004b8262a330a" translate="yes" xml:space="preserve">
          <source>If the argument is NaN or infinite, then the result is &lt;a href=&quot;double#MAX_EXPONENT&quot;&gt;&lt;code&gt;Double.MAX_EXPONENT&lt;/code&gt;&lt;/a&gt; + 1.</source>
          <target state="translated">如果参数为NaN或无限，则结果为&lt;a href=&quot;double#MAX_EXPONENT&quot;&gt; &lt;code&gt;Double.MAX_EXPONENT&lt;/code&gt; &lt;/a&gt; + 1。</target>
        </trans-unit>
        <trans-unit id="cc7b80c9b72e91dff938c54c51871d14f95c81ca" translate="yes" xml:space="preserve">
          <source>If the argument is NaN or infinite, then the result is &lt;a href=&quot;float#MAX_EXPONENT&quot;&gt;&lt;code&gt;Float.MAX_EXPONENT&lt;/code&gt;&lt;/a&gt; + 1.</source>
          <target state="translated">如果参数为NaN或无限，则结果为&lt;a href=&quot;float#MAX_EXPONENT&quot;&gt; &lt;code&gt;Float.MAX_EXPONENT&lt;/code&gt; &lt;/a&gt; + 1。</target>
        </trans-unit>
        <trans-unit id="745e5106ba9365f2bce0539ab810d8720f71215b" translate="yes" xml:space="preserve">
          <source>If the argument is NaN or its absolute value is greater than 1, then the result is NaN.</source>
          <target state="translated">如果参数为NaN或其绝对值大于1,则结果为NaN。</target>
        </trans-unit>
        <trans-unit id="07291af92544374b52ef8f433433f39f1dbb80d9" translate="yes" xml:space="preserve">
          <source>If the argument is NaN or less than -1, then the result is NaN.</source>
          <target state="translated">如果参数是NaN或小于-1,那么结果就是NaN。</target>
        </trans-unit>
        <trans-unit id="13a256cb6eee91493a6f005cfe5cd4ae37f9697f" translate="yes" xml:space="preserve">
          <source>If the argument is NaN or less than zero, then the result is NaN.</source>
          <target state="translated">如果参数是NaN或小于零,那么结果就是NaN。</target>
        </trans-unit>
        <trans-unit id="31b76fec8c3bc86ab1662b04d7bb45867ec9f9d7" translate="yes" xml:space="preserve">
          <source>If the argument is NaN, the result is 0.</source>
          <target state="translated">如果参数是NaN,结果为0。</target>
        </trans-unit>
        <trans-unit id="3aa89491f3556c271cee0931546f3e5660ec7ac7" translate="yes" xml:space="preserve">
          <source>If the argument is NaN, the result is &lt;code&gt;0x7fc00000&lt;/code&gt;.</source>
          <target state="translated">如果参数为NaN，则结果为 &lt;code&gt;0x7fc00000&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a83c5a6baaa1bd2366e8865b925beaeea4e26b42" translate="yes" xml:space="preserve">
          <source>If the argument is NaN, the result is &lt;code&gt;0x7ff8000000000000L&lt;/code&gt;.</source>
          <target state="translated">如果参数为NaN，则结果为 &lt;code&gt;0x7ff8000000000000L&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="118d734407198a907583b63ea2fc64d7c89b2c28" translate="yes" xml:space="preserve">
          <source>If the argument is NaN, the result is NaN.</source>
          <target state="translated">如果参数是NaN,结果就是NaN。</target>
        </trans-unit>
        <trans-unit id="e064879a9427f94b4430bb8b2822c39d482f8755" translate="yes" xml:space="preserve">
          <source>If the argument is NaN, the result is the &lt;code&gt;long&lt;/code&gt; integer representing the actual NaN value. Unlike the &lt;code&gt;doubleToLongBits&lt;/code&gt; method, &lt;code&gt;doubleToRawLongBits&lt;/code&gt; does not collapse all the bit patterns encoding a NaN to a single &quot;canonical&quot; NaN value.</source>
          <target state="translated">如果参数为NaN，则结果为代表实际NaN值的 &lt;code&gt;long&lt;/code&gt; 整数。与 &lt;code&gt;doubleToLongBits&lt;/code&gt; 方法不同， &lt;code&gt;doubleToRawLongBits&lt;/code&gt; 不会将编码NaN的所有位模式折叠为单个&amp;ldquo;规范&amp;rdquo; NaN值。</target>
        </trans-unit>
        <trans-unit id="bca2d981cbc0638a09fdc8f8c3691bf1f893da00" translate="yes" xml:space="preserve">
          <source>If the argument is NaN, the result is the integer representing the actual NaN value. Unlike the &lt;code&gt;floatToIntBits&lt;/code&gt; method, &lt;code&gt;floatToRawIntBits&lt;/code&gt; does not collapse all the bit patterns encoding a NaN to a single &quot;canonical&quot; NaN value.</source>
          <target state="translated">如果参数为NaN，则结果为代表实际NaN值的整数。与 &lt;code&gt;floatToIntBits&lt;/code&gt; 方法不同， &lt;code&gt;floatToRawIntBits&lt;/code&gt; 不会将编码NaN的所有位模式折叠为单个&amp;ldquo;规范&amp;rdquo; NaN值。</target>
        </trans-unit>
        <trans-unit id="db8eab43bb6026b1e9b4780ecae1f1526f2beff3" translate="yes" xml:space="preserve">
          <source>If the argument is NaN, the result is the string &quot;&lt;code&gt;NaN&lt;/code&gt;&quot;.</source>
          <target state="translated">如果参数为NaN，则结果为字符串&amp;ldquo; &lt;code&gt;NaN&lt;/code&gt; &amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="c12f1031f1e9c83194d8ac6506dee76af527571a" translate="yes" xml:space="preserve">
          <source>If the argument is NaN, then the result is NaN.</source>
          <target state="translated">如果参数是NaN,那么结果就是NaN。</target>
        </trans-unit>
        <trans-unit id="5a923aa0ff948589bbbea2c5c98edba0c8041581" translate="yes" xml:space="preserve">
          <source>If the argument is already a localized stream, it may be returned as the result.</source>
          <target state="translated">如果参数已经是一个本地化的流,它可能作为结果返回。</target>
        </trans-unit>
        <trans-unit id="e9264d5fd055500aa5c8726a54e413523844cbaf" translate="yes" xml:space="preserve">
          <source>If the argument is any value in the range &lt;code&gt;0x7f800001&lt;/code&gt; through &lt;code&gt;0x7fffffff&lt;/code&gt; or in the range &lt;code&gt;0xff800001&lt;/code&gt; through &lt;code&gt;0xffffffff&lt;/code&gt;, the result is a NaN. No IEEE 754 floating-point operation provided by Java can distinguish between two NaN values of the same type with different bit patterns. Distinct values of NaN are only distinguishable by use of the &lt;code&gt;Float.floatToRawIntBits&lt;/code&gt; method.</source>
          <target state="translated">如果参数是 &lt;code&gt;0x7f800001&lt;/code&gt; 到 &lt;code&gt;0x7fffffff&lt;/code&gt; 范围内的任何值，或者 &lt;code&gt;0xff800001&lt;/code&gt; 到 &lt;code&gt;0xffffffff&lt;/code&gt; 范围内的值，则结果为NaN。 Java提供的IEEE 754浮点运算无法区分具有不同位模式的相同类型的两个NaN值。 NaN的不同值只能通过使用 &lt;code&gt;Float.floatToRawIntBits&lt;/code&gt; 方法来区分。</target>
        </trans-unit>
        <trans-unit id="e09c36577e890868103778c6cad080360d9fef25" translate="yes" xml:space="preserve">
          <source>If the argument is any value in the range &lt;code&gt;0x7ff0000000000001L&lt;/code&gt; through &lt;code&gt;0x7fffffffffffffffL&lt;/code&gt; or in the range &lt;code&gt;0xfff0000000000001L&lt;/code&gt; through &lt;code&gt;0xffffffffffffffffL&lt;/code&gt;, the result is a NaN. No IEEE 754 floating-point operation provided by Java can distinguish between two NaN values of the same type with different bit patterns. Distinct values of NaN are only distinguishable by use of the &lt;code&gt;Double.doubleToRawLongBits&lt;/code&gt; method.</source>
          <target state="translated">如果参数是介于 &lt;code&gt;0x7ff0000000000001L&lt;/code&gt; 到 &lt;code&gt;0x7fffffffffffffffL&lt;/code&gt; 或介于 &lt;code&gt;0xfff0000000000001L&lt;/code&gt; 到 &lt;code&gt;0xffffffffffffffffL&lt;/code&gt; 范围内的任何值，则结果为NaN。Java提供的IEEE 754浮点运算无法区分具有不同位模式的相同类型的两个NaN值。NaN的不同值只能通过使用 &lt;code&gt;Double.doubleToRawLongBits&lt;/code&gt; 方法来区分。</target>
        </trans-unit>
        <trans-unit id="108d000cc41c657851b0d27f0a1ac78cf5e4ee70" translate="yes" xml:space="preserve">
          <source>If the argument is equal to 10&lt;sup&gt;&lt;i&gt;n&lt;/i&gt;&lt;/sup&gt; for integer</source>
          <target state="translated">如果参数等于10 &lt;sup&gt;&lt;i&gt;n&lt;/i&gt;&lt;/sup&gt;（整数）</target>
        </trans-unit>
        <trans-unit id="65efe2e81fa8d1ba670e4b1992ae1775f4b62a76" translate="yes" xml:space="preserve">
          <source>If the argument is infinite, the result is positive infinity.</source>
          <target state="translated">如果论点是无穷大,结果就是正无穷大。</target>
        </trans-unit>
        <trans-unit id="336889ed81a3144be451220af338acfcbb6c9ba3" translate="yes" xml:space="preserve">
          <source>If the argument is infinite, then the result is an infinity with the same sign as the argument.</source>
          <target state="translated">如果参数是无限的,那么结果就是与参数同号的无限。</target>
        </trans-unit>
        <trans-unit id="4691c35189f88af211fb42ae9607c8ae123c02d6" translate="yes" xml:space="preserve">
          <source>If the argument is infinite, then the result is positive infinity.</source>
          <target state="translated">如果论点是无穷大,那么结果就是正无穷大。</target>
        </trans-unit>
        <trans-unit id="ec376818cb2e255655d1881f54f64a5f81a51e7b" translate="yes" xml:space="preserve">
          <source>If the argument is negative infinity or any value less than or equal to the value of &lt;code&gt;Integer.MIN_VALUE&lt;/code&gt;, the result is equal to the value of &lt;code&gt;Integer.MIN_VALUE&lt;/code&gt;.</source>
          <target state="translated">如果参数为负无穷大或任何小于或等于 &lt;code&gt;Integer.MIN_VALUE&lt;/code&gt; 的值，则结果等于 &lt;code&gt;Integer.MIN_VALUE&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="5a08fe9d371940e4f9d92ad57a75f846bb063ec2" translate="yes" xml:space="preserve">
          <source>If the argument is negative infinity or any value less than or equal to the value of &lt;code&gt;Long.MIN_VALUE&lt;/code&gt;, the result is equal to the value of &lt;code&gt;Long.MIN_VALUE&lt;/code&gt;.</source>
          <target state="translated">如果参数为负无穷大或任何小于或等于 &lt;code&gt;Long.MIN_VALUE&lt;/code&gt; 的值，则结果等于 &lt;code&gt;Long.MIN_VALUE&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="f1c38692773d898bd9643813b94e0ae1993eb556" translate="yes" xml:space="preserve">
          <source>If the argument is negative infinity, the result is &lt;code&gt;0xff800000&lt;/code&gt;.</source>
          <target state="translated">如果参数为负无穷大，则结果为 &lt;code&gt;0xff800000&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3bb987ea3c954538087573e2f402d9fdf305369d" translate="yes" xml:space="preserve">
          <source>If the argument is negative infinity, the result is &lt;code&gt;0xfff0000000000000L&lt;/code&gt;.</source>
          <target state="translated">如果参数为负无穷大，则结果为 &lt;code&gt;0xfff0000000000000L&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a6a939ea1df7c37cb72e17d44d1754a7325b1cce" translate="yes" xml:space="preserve">
          <source>If the argument is negative infinity, the result is negative infinity.</source>
          <target state="translated">如果论点是负无穷大,结果就是负无穷大。</target>
        </trans-unit>
        <trans-unit id="ba927f3f79a46354d9209dcd811d86b8a661221b" translate="yes" xml:space="preserve">
          <source>If the argument is negative infinity, then the result is -1.0.</source>
          <target state="translated">如果参数是负无穷大,那么结果就是-1.0。</target>
        </trans-unit>
        <trans-unit id="20f8e0486c54aeb853e7804b4611ce1c56a73d1b" translate="yes" xml:space="preserve">
          <source>If the argument is negative infinity, then the result is &lt;code&gt;-1.0&lt;/code&gt;.</source>
          <target state="translated">如果参数为负无穷大，则结果为 &lt;code&gt;-1.0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d9e3b1cc495f1cc8092755d393fd54a8be9e0bff" translate="yes" xml:space="preserve">
          <source>If the argument is negative infinity, then the result is positive zero.</source>
          <target state="translated">如果参数是负无穷大,那么结果就是正零。</target>
        </trans-unit>
        <trans-unit id="d08b29e2ea8c8a74d04b752def011f9cda30c497" translate="yes" xml:space="preserve">
          <source>If the argument is negative one, then the result is negative infinity.</source>
          <target state="translated">如果论点是负一,那么结果就是负无穷。</target>
        </trans-unit>
        <trans-unit id="ad3d4a3e9566e2c0df155d95c37161c79599330f" translate="yes" xml:space="preserve">
          <source>If the argument is positive infinity or any value greater than or equal to the value of &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;, the result is equal to the value of &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;.</source>
          <target state="translated">如果参数为正无穷大或任何大于或等于 &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt; 的值，则结果等于 &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="eff50c12018038db62b68855eb707df57d7cd5ae" translate="yes" xml:space="preserve">
          <source>If the argument is positive infinity or any value greater than or equal to the value of &lt;code&gt;Long.MAX_VALUE&lt;/code&gt;, the result is equal to the value of &lt;code&gt;Long.MAX_VALUE&lt;/code&gt;.</source>
          <target state="translated">如果参数为正无穷大或任何大于或等于 &lt;code&gt;Long.MAX_VALUE&lt;/code&gt; 的值，则结果等于 &lt;code&gt;Long.MAX_VALUE&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="6a13758d0f976c89623e38e841da2cbc62912670" translate="yes" xml:space="preserve">
          <source>If the argument is positive infinity, the result is &lt;code&gt;0x7f800000&lt;/code&gt;.</source>
          <target state="translated">如果参数为正无穷大，则结果为 &lt;code&gt;0x7f800000&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8c05eefbf6b8959edbbea1c8b9a02322d8935ca7" translate="yes" xml:space="preserve">
          <source>If the argument is positive infinity, the result is &lt;code&gt;0x7ff0000000000000L&lt;/code&gt;.</source>
          <target state="translated">如果参数为正无穷大，则结果为 &lt;code&gt;0x7ff0000000000000L&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cf429a21c2dc34b66e4269078332483b3641ead6" translate="yes" xml:space="preserve">
          <source>If the argument is positive infinity, the result is positive infinity.</source>
          <target state="translated">如果论点是正无穷大,结果就是正无穷大。</target>
        </trans-unit>
        <trans-unit id="31b9de6b24ff8d5ffbebf56f3f1cecc792456081" translate="yes" xml:space="preserve">
          <source>If the argument is positive infinity, then the result is &lt;code&gt;+1.0&lt;/code&gt;.</source>
          <target state="translated">如果参数为正无穷大，则结果为 &lt;code&gt;+1.0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f87ee2c0e3d173098373d3990b3903acb3bfadf9" translate="yes" xml:space="preserve">
          <source>If the argument is positive infinity, then the result is positive infinity.</source>
          <target state="translated">如果论点是正无穷大,那么结果就是正无穷大。</target>
        </trans-unit>
        <trans-unit id="96dab47247ae7e1056e56799ef0665e4ab651c26" translate="yes" xml:space="preserve">
          <source>If the argument is positive or negative infinity, then the result is positive infinity.</source>
          <target state="translated">如果参数是正无穷或负无穷,那么结果就是正无穷。</target>
        </trans-unit>
        <trans-unit id="78148cd34a5b7680af0ed6412b4903e44701b46c" translate="yes" xml:space="preserve">
          <source>If the argument is positive or negative zero, then the result is &lt;code&gt;Double.MIN_VALUE&lt;/code&gt;.</source>
          <target state="translated">如果参数为正零或负零，则结果为 &lt;code&gt;Double.MIN_VALUE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0c4032eb755d363cebfbea8af5b3c0b4a94596cf" translate="yes" xml:space="preserve">
          <source>If the argument is positive or negative zero, then the result is &lt;code&gt;Float.MIN_VALUE&lt;/code&gt;.</source>
          <target state="translated">如果参数为正零或负零，则结果为 &lt;code&gt;Float.MIN_VALUE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f15f3f96dc5106b38775f4ba76d739b00aa110dd" translate="yes" xml:space="preserve">
          <source>If the argument is positive zero or negative zero, the result is positive zero.</source>
          <target state="translated">如果参数是正零或负零,结果就是正零。</target>
        </trans-unit>
        <trans-unit id="0553928b250b89074ae0163da0309f356dd0aea5" translate="yes" xml:space="preserve">
          <source>If the argument is positive zero or negative zero, then the result is negative infinity.</source>
          <target state="translated">如果参数是正零或负零,那么结果就是负无穷。</target>
        </trans-unit>
        <trans-unit id="f8ad8830694a6f7c940aad7bd91216f8c775287b" translate="yes" xml:space="preserve">
          <source>If the argument is positive zero or negative zero, then the result is the same as the argument.</source>
          <target state="translated">如果参数是正零或负零,那么结果与参数相同。</target>
        </trans-unit>
        <trans-unit id="11b6940276c4e767ac8a361ca5f19636e270c2d9" translate="yes" xml:space="preserve">
          <source>If the argument is zero or subnormal, then the result is &lt;a href=&quot;double#MIN_EXPONENT&quot;&gt;&lt;code&gt;Double.MIN_EXPONENT&lt;/code&gt;&lt;/a&gt; -1.</source>
          <target state="translated">如果参数为零或次正规，则结果为&lt;a href=&quot;double#MIN_EXPONENT&quot;&gt; &lt;code&gt;Double.MIN_EXPONENT&lt;/code&gt; &lt;/a&gt; -1。</target>
        </trans-unit>
        <trans-unit id="3905704a484368c3992190c17ec803f5c9734872" translate="yes" xml:space="preserve">
          <source>If the argument is zero or subnormal, then the result is &lt;a href=&quot;float#MIN_EXPONENT&quot;&gt;&lt;code&gt;Float.MIN_EXPONENT&lt;/code&gt;&lt;/a&gt; -1.</source>
          <target state="translated">如果参数为零或次正规，则结果为&lt;a href=&quot;float#MIN_EXPONENT&quot;&gt; &lt;code&gt;Float.MIN_EXPONENT&lt;/code&gt; &lt;/a&gt; -1。</target>
        </trans-unit>
        <trans-unit id="65b605eea787dfcd26a427a347ea4ad7abd516d5" translate="yes" xml:space="preserve">
          <source>If the argument is zero, the result is &lt;a href=&quot;double#MIN_VALUE&quot;&gt;&lt;code&gt;Double.MIN_VALUE&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">如果参数为零，则结果为&lt;a href=&quot;double#MIN_VALUE&quot;&gt; &lt;code&gt;Double.MIN_VALUE&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="82de080d3a1d56fdbaf695d271e223d79695fa9d" translate="yes" xml:space="preserve">
          <source>If the argument is zero, the result is &lt;a href=&quot;float#MIN_VALUE&quot;&gt;&lt;code&gt;Float.MIN_VALUE&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">如果参数为零，则结果为&lt;a href=&quot;float#MIN_VALUE&quot;&gt; &lt;code&gt;Float.MIN_VALUE&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="368d7952fccceed4084cffb62407a857e1140ff5" translate="yes" xml:space="preserve">
          <source>If the argument is zero, the result is &lt;code&gt;-Double.MIN_VALUE&lt;/code&gt;</source>
          <target state="translated">如果参数为零，则结果为 &lt;code&gt;-Double.MIN_VALUE&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e43dae92e6e1f445b98367ed57735c6219a0d0f9" translate="yes" xml:space="preserve">
          <source>If the argument is zero, the result is &lt;code&gt;-Float.MIN_VALUE&lt;/code&gt;</source>
          <target state="translated">如果参数为零，则结果为 &lt;code&gt;-Float.MIN_VALUE&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5db3ba052bf056b3adf9c2be7e6188d33a4e952e" translate="yes" xml:space="preserve">
          <source>If the argument is zero, then the result is &lt;code&gt;1.0&lt;/code&gt;.</source>
          <target state="translated">如果参数为零，则结果为 &lt;code&gt;1.0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b8d665f9570f8b5f180ad4bdb572f1e1aab98bad" translate="yes" xml:space="preserve">
          <source>If the argument is zero, then the result is a zero with the same sign as the argument.</source>
          <target state="translated">如果参数为零,那么结果就是与参数同号的零。</target>
        </trans-unit>
        <trans-unit id="d1f82cc652138d856ee89a85be827d630ca9f31c" translate="yes" xml:space="preserve">
          <source>If the argument value is already equal to a mathematical integer, then the result is the same as the argument.</source>
          <target state="translated">如果参数值已经等于一个数学整数,那么结果与参数相同。</target>
        </trans-unit>
        <trans-unit id="38b3adaab247759b54b2aa2e88f5b5ce2609340f" translate="yes" xml:space="preserve">
          <source>If the argument value is less than zero but greater than -1.0, then the result is negative zero.</source>
          <target state="translated">如果参数值小于零但大于-1.0,则结果为负零。</target>
        </trans-unit>
        <trans-unit id="acfd94f24240c24943c8ec432b5700b6212aa09a" translate="yes" xml:space="preserve">
          <source>If the argument,</source>
          <target state="translated">如果争论。</target>
        </trans-unit>
        <trans-unit id="7b613ad1d7b1ad953ca4724e10cf0c2ca14a21e9" translate="yes" xml:space="preserve">
          <source>If the array element type differs from any of the corresponding argument types on the original target, the original target is adapted to take the array elements directly, as if by a call to &lt;a href=&quot;methodhandle#asType-java.lang.invoke.MethodType-&quot;&gt;&lt;code&gt;asType&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果数组元素类型与原始目标上的任何对应参数类型不同，则原始目标适合直接采用数组元素，就像通过调用&lt;a href=&quot;methodhandle#asType-java.lang.invoke.MethodType-&quot;&gt; &lt;code&gt;asType&lt;/code&gt; 一样&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8c623454e44ca641a6c552859181a701097e3dda" translate="yes" xml:space="preserve">
          <source>If the array type differs from the final argument type on the original target, the original target is adapted to take the array type directly, as if by a call to &lt;a href=&quot;methodhandle#asType-java.lang.invoke.MethodType-&quot;&gt;&lt;code&gt;asType&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果数组类型与原始目标上的最终参数类型不同，则原始目标将被适配为直接采用数组类型，就像通过调用&lt;a href=&quot;methodhandle#asType-java.lang.invoke.MethodType-&quot;&gt; &lt;code&gt;asType&lt;/code&gt; 一样&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4389eb5f009bdfaeb30b67c701fdcfe35730fb30" translate="yes" xml:space="preserve">
          <source>If the attempt to load this class produces a &lt;a href=&quot;../../../java/lang/classnotfoundexception&quot;&gt;&lt;code&gt;ClassNotFoundException&lt;/code&gt;&lt;/a&gt;, the search for a handler continues with the next element of the list.</source>
          <target state="translated">如果尝试加载此类会产生&lt;a href=&quot;../../../java/lang/classnotfoundexception&quot;&gt; &lt;code&gt;ClassNotFoundException&lt;/code&gt; &lt;/a&gt;，则将继续搜索列表中的下一个元素，以查找处理程序。</target>
        </trans-unit>
        <trans-unit id="3de2839318027a87b01d1160931d4ec1a7e54992" translate="yes" xml:space="preserve">
          <source>If the authority component is present in the spec then the spec is treated as absolute and the spec authority and path will replace the context authority and path. If the authority component is absent in the spec then the authority of the new URL will be inherited from the context.</source>
          <target state="translated">如果规范中存在权限组件,那么规范将被视为绝对的,规范的权限和路径将取代上下文的权限和路径。如果规范中没有权限组件,那么新URL的权限将从上下文中继承。</target>
        </trans-unit>
        <trans-unit id="bf5687cbde3be28238012b6e16935454ba496a38" translate="yes" xml:space="preserve">
          <source>If the barrier action does not rely on the parties being suspended when it is executed, then any of the threads in the party could execute that action when it is released. To facilitate this, each invocation of &lt;a href=&quot;cyclicbarrier#await--&quot;&gt;&lt;code&gt;await()&lt;/code&gt;&lt;/a&gt; returns the arrival index of that thread at the barrier. You can then choose which thread should execute the barrier action, for example:</source>
          <target state="translated">如果屏障操作不依赖于执行时暂停的各方，则该方中的任何线程在释放时都可以执行该操作。为方便起见，每次调用&lt;a href=&quot;cyclicbarrier#await--&quot;&gt; &lt;code&gt;await()&lt;/code&gt; 都会&lt;/a&gt;返回该线程在屏障处的到达索引。然后，您可以选择哪个线程应执行屏障操作，例如：</target>
        </trans-unit>
        <trans-unit id="dac9df73081697b7b7531c1d6a0b9c3e69c870d7" translate="yes" xml:space="preserve">
          <source>If the barrier is &lt;a href=&quot;cyclicbarrier#reset--&quot;&gt;&lt;code&gt;reset()&lt;/code&gt;&lt;/a&gt; while any thread is waiting, or if the barrier &lt;a href=&quot;cyclicbarrier#isBroken--&quot;&gt;is broken&lt;/a&gt; when &lt;code&gt;await&lt;/code&gt; is invoked, or while any thread is waiting, then &lt;a href=&quot;brokenbarrierexception&quot;&gt;&lt;code&gt;BrokenBarrierException&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">如果在任何线程正在等待时屏障被&lt;a href=&quot;cyclicbarrier#reset--&quot;&gt; &lt;code&gt;reset()&lt;/code&gt; &lt;/a&gt;，或者在调用 &lt;code&gt;await&lt;/code&gt; 时或在任何线程正在等待时屏障&lt;a href=&quot;cyclicbarrier#isBroken--&quot;&gt;被打破&lt;/a&gt;，则将抛出&lt;a href=&quot;brokenbarrierexception&quot;&gt; &lt;code&gt;BrokenBarrierException&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="575a83a87991707c167ff499c572b2c82c888c2d" translate="yes" xml:space="preserve">
          <source>If the bean also implemented the zero argument get listener method:</source>
          <target state="translated">如果bean也实现了零参数get监听器方法。</target>
        </trans-unit>
        <trans-unit id="2c223aaa7bd3533fb82949d6d90648ac9350bba7" translate="yes" xml:space="preserve">
          <source>If the bean is a subtype of java.applet.Applet, then it is given some special initialization. First, it is supplied with a default AppletStub and AppletContext. Second, if it was instantiated from a classname the applet's &quot;init&quot; method is called. (If the bean was deserialized this step is skipped.)</source>
          <target state="translated">如果bean是java.applet.Applet的一个子类型,那么就会给它一些特殊的初始化。首先,它被提供了一个默认的AppletStub和AppletContext。其次,如果它是从一个类名实例化而来的,那么applet的 &quot;init &quot;方法就会被调用。(如果bean是被反序列化的,则跳过这一步。)</target>
        </trans-unit>
        <trans-unit id="80874718dd7a5a6c0f974bdb517de9b9cdeaa788" translate="yes" xml:space="preserve">
          <source>If the behavioral parameters do have side-effects, unless explicitly stated, there are no guarantees as to the &lt;a href=&quot;../concurrent/package-summary#MemoryVisibility&quot;&gt;&lt;i&gt;visibility&lt;/i&gt;&lt;/a&gt; of those side-effects to other threads, nor are there any guarantees that different operations on the &quot;same&quot; element within the same stream pipeline are executed in the same thread. Further, the ordering of those effects may be surprising. Even when a pipeline is constrained to produce a &lt;em&gt;result&lt;/em&gt; that is consistent with the encounter order of the stream source (for example, &lt;code&gt;IntStream.range(0,5).parallel().map(x -&amp;gt; x*2).toArray()&lt;/code&gt; must produce &lt;code&gt;[0, 2, 4, 6, 8]&lt;/code&gt;), no guarantees are made as to the order in which the mapper function is applied to individual elements, or in what thread any behavioral parameter is executed for a given element.</source>
          <target state="translated">如果行为参数确实具有副作用，除非明确说明，否则不能保证这些副作用对其他线程的&lt;a href=&quot;../concurrent/package-summary#MemoryVisibility&quot;&gt;&lt;i&gt;可见性&lt;/i&gt;&lt;/a&gt;，也不能保证在同一流管道中对&amp;ldquo;相同&amp;rdquo;元素进行不同的操作在同一线程中执行。此外，这些效果的排序可能令人惊讶。即使当管道被约束以产生与流源的遇到顺序一致的&lt;em&gt;结果时&lt;/em&gt;（例如， &lt;code&gt;IntStream.range(0,5).parallel().map(x -&amp;gt; x*2).toArray()&lt;/code&gt; 必须产生 &lt;code&gt;[0, 2, 4, 6, 8]&lt;/code&gt; ），则无法保证将映射器函数应用于单个元素的顺序，或对给定元素执行任何行为参数的线程。</target>
        </trans-unit>
        <trans-unit id="f00562687194200d7d3d4e8dbcd71f247eefddae" translate="yes" xml:space="preserve">
          <source>If the bit offset is non-zero, forces the remaining bits in the current byte to 0 and advances the stream position by one. This method should be called by subclasses at the beginning of the &lt;code&gt;write(int)&lt;/code&gt; and &lt;code&gt;write(byte[], int, int)&lt;/code&gt; methods.</source>
          <target state="translated">如果位偏移量不为零，则将当前字节中的其余位强制为0，并将流位置前进1。子类应在 &lt;code&gt;write(int)&lt;/code&gt; 和 &lt;code&gt;write(byte[], int, int)&lt;/code&gt; 方法的开头调用此方法。</target>
        </trans-unit>
        <trans-unit id="92b946e43c30c152e86047538b9789992732b7fc" translate="yes" xml:space="preserve">
          <source>If the bit offset within the stream is non-zero, the remainder of the current byte is padded with 0s and written out first. The bit offset will be 0 after the write.</source>
          <target state="translated">如果流内的位偏移量为非零,则当前字节的剩余部分用0填充,并先写出。写出后,位偏移量将为0。</target>
        </trans-unit>
        <trans-unit id="a17bf4b09c9d50c7630d0558298715e241010710" translate="yes" xml:space="preserve">
          <source>If the bit offset within the stream is non-zero, the remainder of the current byte is padded with 0s and written out first. The bit offset will be 0 after the write. Implementers can use the &lt;a href=&quot;imageoutputstreamimpl#flushBits--&quot;&gt;&lt;code&gt;flushBits&lt;/code&gt;&lt;/a&gt; method of &lt;a href=&quot;imageoutputstreamimpl&quot;&gt;&lt;code&gt;ImageOutputStreamImpl&lt;/code&gt;&lt;/a&gt; to guarantee this.</source>
          <target state="translated">如果流中的位偏移量不为零，则将当前字节的其余部分填充为0，然后首先写出。写入后位偏移量将为0。实现者可以使用&lt;a href=&quot;imageoutputstreamimpl&quot;&gt; &lt;code&gt;ImageOutputStreamImpl&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;imageoutputstreamimpl#flushBits--&quot;&gt; &lt;code&gt;flushBits&lt;/code&gt; &lt;/a&gt;方法来保证这一点。</target>
        </trans-unit>
        <trans-unit id="7c99084a7828ec1a975c99c15549a5685147fb7b" translate="yes" xml:space="preserve">
          <source>If the boolean system property &lt;code&gt;org.openjdk.java.util.stream.tripwire&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt; then diagnostic warnings are reported if boxing of primitive values occur when operating on primitive subtype specializations.</source>
          <target state="translated">如果布尔系统属性 &lt;code&gt;org.openjdk.java.util.stream.tripwire&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; ,则在对原始子类型专门化进行操作时如果发生原始值的装箱，则会报告诊断警告。</target>
        </trans-unit>
        <trans-unit id="486a42feea23b408f730eefa4db49a5a9bbd4a21" translate="yes" xml:space="preserve">
          <source>If the calendar type is &lt;code&gt;&quot;iso8601&quot;&lt;/code&gt;, the &lt;a href=&quot;gregoriancalendar#setGregorianChange-java.util.Date-&quot;&gt;Gregorian change date&lt;/a&gt; of a &lt;a href=&quot;gregoriancalendar&quot;&gt;&lt;code&gt;GregorianCalendar&lt;/code&gt;&lt;/a&gt; is set to &lt;code&gt;Date(Long.MIN_VALUE)&lt;/code&gt; to be the &lt;em&gt;proleptic&lt;/em&gt; Gregorian calendar. Its week definition parameters are also set to be &lt;a href=&quot;gregoriancalendar#iso8601_compatible_setting&quot;&gt;compatible with the ISO 8601 standard&lt;/a&gt;. Note that the &lt;a href=&quot;gregoriancalendar#getCalendarType--&quot;&gt;&lt;code&gt;getCalendarType&lt;/code&gt;&lt;/a&gt; method of a &lt;code&gt;GregorianCalendar&lt;/code&gt; created with &lt;code&gt;&quot;iso8601&quot;&lt;/code&gt; returns &lt;code&gt;&quot;gregory&quot;&lt;/code&gt;.</source>
          <target state="translated">如果日历类型是 &lt;code&gt;&quot;iso8601&quot;&lt;/code&gt; ，在&lt;a href=&quot;gregoriancalendar#setGregorianChange-java.util.Date-&quot;&gt;公历更改日期&lt;/a&gt;一的&lt;a href=&quot;gregoriancalendar&quot;&gt; &lt;code&gt;GregorianCalendar&lt;/code&gt; 的&lt;/a&gt;设置为 &lt;code&gt;Date(Long.MIN_VALUE)&lt;/code&gt; 是&lt;em&gt;proleptic&lt;/em&gt;公历。其周定义参数也设置为&lt;a href=&quot;gregoriancalendar#iso8601_compatible_setting&quot;&gt;与ISO 8601标准兼容&lt;/a&gt;。注意，&lt;a href=&quot;gregoriancalendar#getCalendarType--&quot;&gt; &lt;code&gt;getCalendarType&lt;/code&gt; &lt;/a&gt;一个方法 &lt;code&gt;GregorianCalendar&lt;/code&gt; 与创建 &lt;code&gt;&quot;iso8601&quot;&lt;/code&gt; 回报 &lt;code&gt;&quot;gregory&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aa913ecbed54558eb291f0922076e469c78e1e5a" translate="yes" xml:space="preserve">
          <source>If the call site's symbolic type descriptor exactly matches this method handle's &lt;a href=&quot;methodhandle#type&quot;&gt;&lt;code&gt;type&lt;/code&gt;&lt;/a&gt;, the call proceeds as if by &lt;a href=&quot;methodhandle#invokeExact-java.lang.Object...-&quot;&gt;&lt;code&gt;invokeExact&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果调用站点的符号类型描述符与该方法句柄的&lt;a href=&quot;methodhandle#type&quot;&gt; &lt;code&gt;type&lt;/code&gt; &lt;/a&gt;完全匹配，则调用将像通过&lt;a href=&quot;methodhandle#invokeExact-java.lang.Object...-&quot;&gt; &lt;code&gt;invokeExact&lt;/code&gt; 一样进行&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8da6d1bbefc65f4e59f9e3250b8dcf1e6a450b67" translate="yes" xml:space="preserve">
          <source>If the call was executed on Windows, with SOURCE_PATH set to &lt;code&gt;&quot;C:\Documents&amp;nbsp;and&amp;nbsp;Settings\UncleBob\src\share\classes&quot;&lt;/code&gt;, a valid result would be a file object representing the file &lt;code&gt;&quot;C:\Documents&amp;nbsp;and&amp;nbsp;Settings\UncleBob\src\share\classes\com\sun\tools\javac\resources\compiler.properties&quot;&lt;/code&gt;.</source>
          <target state="translated">如果调用是在Windows上执行的，并且SOURCE_PATH设置为 &lt;code&gt;&quot;C:\Documents&amp;nbsp;and&amp;nbsp;Settings\UncleBob\src\share\classes&quot;&lt;/code&gt; ，则有效结果将是代表文件 &lt;code&gt;&quot;C:\Documents&amp;nbsp;and&amp;nbsp;Settings\UncleBob\src\share\classes\com\sun\tools\javac\resources\compiler.properties&quot;&lt;/code&gt; 的文件对象。 src \ share \ classes \ com \ sun \ tools \ javac \ resources \ compiler.properties&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="9bab532ba6bbba009ffbae752606d6da2e48286a" translate="yes" xml:space="preserve">
          <source>If the caller specifies a &lt;code&gt;null&lt;/code&gt; Subject and a &lt;code&gt;null&lt;/code&gt; value is permitted, the LoginContext instantiates a new Subject.</source>
          <target state="translated">如果调用方指定一个 &lt;code&gt;null&lt;/code&gt; Subject，并且允许使用 &lt;code&gt;null&lt;/code&gt; 值，则LoginContext实例化一个新的Subject。</target>
        </trans-unit>
        <trans-unit id="269b3f0fe8fb44df4ce0a6fe047dfebd11282f41" translate="yes" xml:space="preserve">
          <source>If the calling method is interested in retrieving the named property then it would have to test the element to see if it is a proxy class.</source>
          <target state="translated">如果调用方法对检索命名的属性感兴趣,那么它就必须测试该元素是否是一个代理类。</target>
        </trans-unit>
        <trans-unit id="9253130a27a78e3a08350cf89cd42b9d30c402d8" translate="yes" xml:space="preserve">
          <source>If the certificate is of type X.509 and has a</source>
          <target state="translated">如果证书的类型为X.509,并且有一个</target>
        </trans-unit>
        <trans-unit id="b697d0518cb0986befd095c4c07f371b7bc19eb6" translate="yes" xml:space="preserve">
          <source>If the channel has already been closed then this method returns immediately. Otherwise it marks the channel as closed and then invokes the &lt;a href=&quot;abstractinterruptiblechannel#implCloseChannel--&quot;&gt;&lt;code&gt;implCloseChannel&lt;/code&gt;&lt;/a&gt; method in order to complete the close operation.</source>
          <target state="translated">如果通道已经关闭，则此方法立即返回。否则，它将通道标记为已关闭，然后调用&lt;a href=&quot;abstractinterruptiblechannel#implCloseChannel--&quot;&gt; &lt;code&gt;implCloseChannel&lt;/code&gt; &lt;/a&gt;方法以完成关闭操作。</target>
        </trans-unit>
        <trans-unit id="258471a2858a2bd50b28d36eb9c0232d73db11d8" translate="yes" xml:space="preserve">
          <source>If the channel is a member of a multicast group then the membership is &lt;a href=&quot;membershipkey#drop--&quot;&gt;&lt;code&gt;dropped&lt;/code&gt;&lt;/a&gt;. Upon return, the &lt;a href=&quot;membershipkey&quot;&gt;&lt;code&gt;membership-key&lt;/code&gt;&lt;/a&gt; will be &lt;a href=&quot;membershipkey#isValid--&quot;&gt;&lt;code&gt;invalid&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果通道是多播组的成员，则成员资格将被&lt;a href=&quot;membershipkey#drop--&quot;&gt; &lt;code&gt;dropped&lt;/code&gt; &lt;/a&gt;。返回时，&lt;a href=&quot;membershipkey&quot;&gt; &lt;code&gt;membership-key&lt;/code&gt; &lt;/a&gt;将&lt;a href=&quot;membershipkey#isValid--&quot;&gt; &lt;code&gt;invalid&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fca12487d5034313786755dfdbb1487ee9174606" translate="yes" xml:space="preserve">
          <source>If the channel's key is not already in the selected-key set then it is added to that set and its ready-operation set is modified to identify exactly those operations for which the channel is now reported to be ready. Any readiness information previously recorded in the ready set is discarded.</source>
          <target state="translated">如果通道的密钥还没有在选定的密钥集中,那么它被添加到该集中,它的就绪操作集被修改,以准确地识别那些通道现在被报告为就绪的操作。任何先前记录在就绪集的就绪信息被丢弃。</target>
        </trans-unit>
        <trans-unit id="a74fcb99fe153ea5c299a617e13d7e98b79feb03" translate="yes" xml:space="preserve">
          <source>If the character &lt;code&gt;oldChar&lt;/code&gt; does not occur in the character sequence represented by this &lt;code&gt;String&lt;/code&gt; object, then a reference to this &lt;code&gt;String&lt;/code&gt; object is returned. Otherwise, a &lt;code&gt;String&lt;/code&gt; object is returned that represents a character sequence identical to the character sequence represented by this &lt;code&gt;String&lt;/code&gt; object, except that every occurrence of &lt;code&gt;oldChar&lt;/code&gt; is replaced by an occurrence of &lt;code&gt;newChar&lt;/code&gt;.</source>
          <target state="translated">如果在此 &lt;code&gt;String&lt;/code&gt; 对象表示的字符序列中未出现字符 &lt;code&gt;oldChar&lt;/code&gt; ，则返回对此 &lt;code&gt;String&lt;/code&gt; 对象的引用。否则，将返回一个 &lt;code&gt;String&lt;/code&gt; 对象，该对象表示一个与此 &lt;code&gt;String&lt;/code&gt; 对象表示的字符序列相同的字符序列，只是每次出现的 &lt;code&gt;oldChar&lt;/code&gt; 都会替换为出现的 &lt;code&gt;newChar&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7e2733b75e92ebe16a2ce70438529de312b56641" translate="yes" xml:space="preserve">
          <source>If the character does not have a numeric value, then -1 is returned. If the character has a numeric value that cannot be represented as a nonnegative integer (for example, a fractional value), then -2 is returned.</source>
          <target state="translated">如果该字符没有数值,则返回-1.如果该字符的数值不能用非负整数表示,则返回-2。如果字符的数值不能用非负整数表示(例如,分数值),则返回-2。</target>
        </trans-unit>
        <trans-unit id="1ef817a66adab96584398608e88fbe1d608af344" translate="yes" xml:space="preserve">
          <source>If the characteristic &lt;code&gt;IDENTITY_TRANSFORM&lt;/code&gt; is set, this function may be presumed to be an identity transform with an unchecked cast from &lt;code&gt;A&lt;/code&gt; to &lt;code&gt;R&lt;/code&gt;.</source>
          <target state="translated">如果设置了特征 &lt;code&gt;IDENTITY_TRANSFORM&lt;/code&gt; ，则可以假定此函数为从 &lt;code&gt;A&lt;/code&gt; 到 &lt;code&gt;R&lt;/code&gt; 的未经检查的强制转换的身份转换。</target>
        </trans-unit>
        <trans-unit id="497068c1a55f2d965c9c1d485ba0e4ac4c0bfb03" translate="yes" xml:space="preserve">
          <source>If the check fails we throw a SecurityException, otherwise we return normally.</source>
          <target state="translated">如果检查失败,我们会抛出一个SecurityException,否则我们正常返回。</target>
        </trans-unit>
        <trans-unit id="f0f200f54b8913d720a0fc8f80cb58e7fb832b09" translate="yes" xml:space="preserve">
          <source>If the chronology makes active use of eras, such as &lt;code&gt;JapaneseChronology&lt;/code&gt; then the year-of-era will be validated against the era. For other chronologies, validation is optional.</source>
          <target state="translated">如果时间顺序积极使用了诸如 &lt;code&gt;JapaneseChronology&lt;/code&gt; 时间顺序之类的时代，那么将根据该时代对年份进行验证。对于其他年代，验证是可选的。</target>
        </trans-unit>
        <trans-unit id="0c7a6047da53758486c24b6ceb6b4575875d974a" translate="yes" xml:space="preserve">
          <source>If the class implements the interface &lt;a href=&quot;dynamicmbean&quot;&gt;&lt;code&gt;DynamicMBean&lt;/code&gt;&lt;/a&gt; then the MBean is a Dynamic MBean. Note that the class &lt;code&gt;StandardMBean&lt;/code&gt; implements this interface, so this case applies to a Standard MBean or MXBean created using the class &lt;code&gt;StandardMBean&lt;/code&gt;.</source>
          <target state="translated">如果该类实现了&lt;a href=&quot;dynamicmbean&quot;&gt; &lt;code&gt;DynamicMBean&lt;/code&gt; &lt;/a&gt;接口，则MBean是动态MBean。请注意，类 &lt;code&gt;StandardMBean&lt;/code&gt; 实现了此接口，因此，这种情况适用于使用类 &lt;code&gt;StandardMBean&lt;/code&gt; 创建的Standard MBean或MXBean 。</target>
        </trans-unit>
        <trans-unit id="952c977645377144d1e9387499dba9c6a0e6f790" translate="yes" xml:space="preserve">
          <source>If the class or interface represented by this &lt;code&gt;Class&lt;/code&gt; object is a member of another class, returns the &lt;code&gt;Class&lt;/code&gt; object representing the class in which it was declared. This method returns null if this class or interface is not a member of any other class. If this &lt;code&gt;Class&lt;/code&gt; object represents an array class, a primitive type, or void,then this method returns null.</source>
          <target state="translated">如果此 &lt;code&gt;Class&lt;/code&gt; 对象表示的类或接口是另一个类的成员，则返回表示在其中声明该类的类的 &lt;code&gt;Class&lt;/code&gt; 对象。如果此类或接口不是任何其他类的成员，则此方法返回null。如果此 &lt;code&gt;Class&lt;/code&gt; 对象表示数组类，原始类型或void，则此方法返回null。</target>
        </trans-unit>
        <trans-unit id="5149c7a2ea949082634b5eade9a189fb43ba3574" translate="yes" xml:space="preserve">
          <source>If the class pointed to by the property cannot be loaded, or does not correspond to a valid subclass of MBeanServerBuilder then an exception is propagated, and no MBeanServer can be created until the &lt;b&gt;javax.management.builder.initial&lt;/b&gt; system property is reset to valid value.</source>
          <target state="translated">如果无法加载由该属性指向的类，或者该类不对应于MBeanServerBuilder的有效子类，则将传播异常，并且在将&lt;b&gt;javax.management.builder.initial&lt;/b&gt;系统属性重置为有效值之前，无法创建MBeanServer。。</target>
        </trans-unit>
        <trans-unit id="a48f463646ddc67b0927be2d8f5a0d7e6779ec57" translate="yes" xml:space="preserve">
          <source>If the class was found using the above steps, and the &lt;code&gt;resolve&lt;/code&gt; flag is true, this method will then invoke the &lt;a href=&quot;classloader#resolveClass-java.lang.Class-&quot;&gt;&lt;code&gt;resolveClass(Class)&lt;/code&gt;&lt;/a&gt; method on the resulting &lt;code&gt;Class&lt;/code&gt; object.</source>
          <target state="translated">如果使用上述步骤找到了该类，并且 &lt;code&gt;resolve&lt;/code&gt; 标志为true，则此方法将在所得的 &lt;code&gt;Class&lt;/code&gt; 对象上调用&lt;a href=&quot;classloader#resolveClass-java.lang.Class-&quot;&gt; &lt;code&gt;resolveClass(Class)&lt;/code&gt; &lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="0cb1171375f133959d5fe66bf3b2a054030b8896" translate="yes" xml:space="preserve">
          <source>If the client does not specify a JobPriority attribute for a Print Job and the printer does support the JobPriority attribute, the printer must use an implementation-defined default JobPriority value.</source>
          <target state="translated">如果客户端没有为打印任务指定JobPriority属性,而打印机支持JobPriority属性,则打印机必须使用执行中定义的默认JobPriority值。</target>
        </trans-unit>
        <trans-unit id="8819695d5b9293144506d78213d046dbf29c7943" translate="yes" xml:space="preserve">
          <source>If the client does not supply this attribute in a Print Request and the printer supports this attribute, the printer must use its (implementation-dependent) default JobHoldUntil value at job submission time (unlike most job template attributes that are used if necessary at job processing time).</source>
          <target state="translated">如果客户端没有在打印请求中提供该属性,而打印机支持该属性,则打印机必须在作业提交时使用其(依赖于实施的)默认JobHoldUntil值(与大多数作业模板属性不同,这些属性在作业处理时需要使用)。</target>
        </trans-unit>
        <trans-unit id="6f068094c0b9101658e1bd4638d11b46b0682d00" translate="yes" xml:space="preserve">
          <source>If the combiner has a void return, no result will be inserted, and the first &lt;code&gt;N&lt;/code&gt; parameter types of the target must exactly match the parameters of the combiner.</source>
          <target state="translated">如果组合器的返回值无效，则不会插入任何结果，并且目标的前 &lt;code&gt;N&lt;/code&gt; 个参数类型必须与组合器的参数完全匹配。</target>
        </trans-unit>
        <trans-unit id="7bd33812eb44d59d69e1fa86993dc6c1b417f658" translate="yes" xml:space="preserve">
          <source>If the combiner returns a value, the first parameter type of the target must be identical with the return type of the combiner, and the next &lt;code&gt;N&lt;/code&gt; parameter types of the target must exactly match the parameters of the combiner.</source>
          <target state="translated">如果组合器返回一个值，则目标的第一个参数类型必须与组合器的返回类型相同，并且目标的后 &lt;code&gt;N&lt;/code&gt; 个参数类型必须与组合器的参数完全匹配。</target>
        </trans-unit>
        <trans-unit id="700d0c6d66bdf7dd366a71fc298f1463af466dfa" translate="yes" xml:space="preserve">
          <source>If the comments argument is not null, then an ASCII &lt;code&gt;#&lt;/code&gt; character, the comments string, and a line separator are first written to the output stream. Thus, the &lt;code&gt;comments&lt;/code&gt; can serve as an identifying comment. Any one of a line feed ('\n'), a carriage return ('\r'), or a carriage return followed immediately by a line feed in comments is replaced by a line separator generated by the &lt;code&gt;Writer&lt;/code&gt; and if the next character in comments is not character &lt;code&gt;#&lt;/code&gt; or character &lt;code&gt;!&lt;/code&gt; then an ASCII &lt;code&gt;#&lt;/code&gt; is written out after that line separator.</source>
          <target state="translated">如果comment参数不为null，则首先将ASCII &lt;code&gt;#&lt;/code&gt; 字符，注释字符串和行分隔符写入输出流。因此， &lt;code&gt;comments&lt;/code&gt; 可以用作识别评论。换行符（'\ n'），回车符（'\ r'）或回车符后紧接着注释中的换行符中的任何一个均由 &lt;code&gt;Writer&lt;/code&gt; 生成的换行符替换，如果下一个字符在注释中不是字符 &lt;code&gt;#&lt;/code&gt; 或字符 &lt;code&gt;!&lt;/code&gt; 然后在该行分隔符之后写出ASCII &lt;code&gt;#&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2c31ff2ad53aa80158077167d3c0952e042633e3" translate="yes" xml:space="preserve">
          <source>If the compression level is changed, the next invocation of &lt;code&gt;deflate&lt;/code&gt; will compress the input available so far with the old level (and may be flushed); the new level will take effect only after that invocation.</source>
          <target state="translated">如果更改了压缩级别，则 &lt;code&gt;deflate&lt;/code&gt; 的下一次调用将使用旧级别压缩到目前为止可用的输入（并且可能会被刷新）；新级别仅在该调用之后生效。</target>
        </trans-unit>
        <trans-unit id="392c53482c9474c39ea6e8d51c4ff85e2db64e08" translate="yes" xml:space="preserve">
          <source>If the compression strategy is changed, the next invocation of &lt;code&gt;deflate&lt;/code&gt; will compress the input available so far with the old strategy (and may be flushed); the new strategy will take effect only after that invocation.</source>
          <target state="translated">如果更改了压缩策略，则 &lt;code&gt;deflate&lt;/code&gt; 的下一次调用将使用旧的策略压缩到目前为止可用的输入（并且可能被刷新）；新策略仅在该调用之后才生效。</target>
        </trans-unit>
        <trans-unit id="f881d8d4f5f09d46f8c2856b6d2d804f3ec96cc6" translate="yes" xml:space="preserve">
          <source>If the constructor completes normally, returns the newly created and initialized instance.</source>
          <target state="translated">如果构造函数正常完成,返回新创建并初始化的实例。</target>
        </trans-unit>
        <trans-unit id="2aeb09eb6e0fcfe242a17792207492aa120605ac" translate="yes" xml:space="preserve">
          <source>If the constructor does &lt;b&gt;not&lt;/b&gt; have a CallbackHandler input parameter, or if the caller specifies a &lt;code&gt;null&lt;/code&gt; CallbackHandler object (and a &lt;code&gt;null&lt;/code&gt; value is permitted), the LoginContext queries the &lt;code&gt;auth.login.defaultCallbackHandler&lt;/code&gt; security property for the fully qualified class name of a default handler implementation. If the security property is not set, then the underlying modules will not have a CallbackHandler for use in communicating with users. The caller thus assumes that the configured modules have alternative means for authenticating the user.</source>
          <target state="translated">如果构造确实&lt;b&gt;不&lt;/b&gt;具备给CallbackHandler输入参数，或者调用者指定一个 &lt;code&gt;null&lt;/code&gt; CallbackHandler对象（并且 &lt;code&gt;null&lt;/code&gt; 值是允许的），则LoginContext查询 &lt;code&gt;auth.login.defaultCallbackHandler&lt;/code&gt; 安全属性的默认处理程序的完全限定类名实施。如果未设置security属性，则基础模块将没有用于与用户通信的CallbackHandler。因此，调用者假定已配置的模块具有用于验证用户身份的替代方法。</target>
        </trans-unit>
        <trans-unit id="96edcc96b78112d3bb9f9d209b5477cb96759906" translate="yes" xml:space="preserve">
          <source>If the constructor does &lt;b&gt;not&lt;/b&gt; have a Configuration input parameter, or if the caller specifies a &lt;code&gt;null&lt;/code&gt; Configuration object, the constructor uses the following call to get the installed Configuration:</source>
          <target state="translated">如果构造确实&lt;b&gt;不&lt;/b&gt;存在Configuration输入参数，或者调用者指定了一个 &lt;code&gt;null&lt;/code&gt; 的配置对象，构造函数使用以下调用来获取安装配置：</target>
        </trans-unit>
        <trans-unit id="56ea3a3517b6a27cca0834c9f4eb544d3dc38d39" translate="yes" xml:space="preserve">
          <source>If the constructor does &lt;b&gt;not&lt;/b&gt; have a Subject input parameter, the LoginContext instantiates a new Subject.</source>
          <target state="translated">如果构造并&lt;b&gt;没有&lt;/b&gt;有对象的输入参数，则LoginContext实例化一个新的主题。</target>
        </trans-unit>
        <trans-unit id="51d999e9fc75b0313b56adf5745b9fffcd061b50" translate="yes" xml:space="preserve">
          <source>If the constructor has a CallbackHandler input parameter, the LoginContext uses the caller-specified CallbackHandler object.</source>
          <target state="translated">如果构造函数有CallbackHandler输入参数,LoginContext会使用调用者指定的CallbackHandler对象。</target>
        </trans-unit>
        <trans-unit id="e1e00d077c5cc21a366671e33a8a738802bc618a" translate="yes" xml:space="preserve">
          <source>If the constructor has a Configuration input parameter and the caller specifies a non-null Configuration, the LoginContext uses the caller-specified Configuration.</source>
          <target state="translated">如果构造函数有一个Configuration输入参数,并且调用者指定了一个非空的Configuration,那么LoginContext会使用调用者指定的Configuration。</target>
        </trans-unit>
        <trans-unit id="3de799a960e7be55aab3ca032d285e2179f3390f" translate="yes" xml:space="preserve">
          <source>If the constructor has a Subject input parameter, the LoginContext uses the caller-specified Subject object.</source>
          <target state="translated">如果构造函数有Subject输入参数,LoginContext使用调用者指定的Subject对象。</target>
        </trans-unit>
        <trans-unit id="8c9ed368492503e51fcc4ae43d3e8d4462771fd7" translate="yes" xml:space="preserve">
          <source>If the constructor's &lt;code&gt;accessible&lt;/code&gt; flag is not set, access checking is performed immediately on behalf of the lookup class.</source>
          <target state="translated">如果未设置构造函数的 &lt;code&gt;accessible&lt;/code&gt; 标志，则代表查找类立即执行访问检查。</target>
        </trans-unit>
        <trans-unit id="2473d04d22b81fa38fb3fac97ebfc248b300280e" translate="yes" xml:space="preserve">
          <source>If the constructor's declaring class is an inner class in a non-static context, the first argument to the constructor needs to be the enclosing instance; see section 15.9.3 of</source>
          <target state="translated">如果构造函数的声明类是非静态上下文中的内类,那么构造函数的第一个参数需要是包围实例;请参见</target>
        </trans-unit>
        <trans-unit id="12ab1266a164c0f6072aaf95e501de64c7ac066d" translate="yes" xml:space="preserve">
          <source>If the containing type is a parameterized type, the number of type arguments must equal the number of &lt;code&gt;typeElem&lt;/code&gt;'s formal type parameters. If it is not parameterized or if it is &lt;code&gt;null&lt;/code&gt;, this method is equivalent to &lt;code&gt;getDeclaredType(typeElem, typeArgs)&lt;/code&gt;.</source>
          <target state="translated">如果包含的类型是参数化类型，则类型实参的数量必须等于 &lt;code&gt;typeElem&lt;/code&gt; 的形式类型参数的数量。如果未参数化或为 &lt;code&gt;null&lt;/code&gt; ，则此方法等效于 &lt;code&gt;getDeclaredType(typeElem, typeArgs)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="54595108c68c9e1528174df34d61161ee7d1002c" translate="yes" xml:space="preserve">
          <source>If the context is available and there is a security manager installed, the caller may require permission to access it or a security exception may be thrown. In a Java environment, the security manager's &lt;code&gt;checkPermission&lt;/code&gt; method is called with a &lt;code&gt;SSLPermission(&quot;getSSLSessionContext&quot;)&lt;/code&gt; permission.</source>
          <target state="translated">如果上下文可用，并且安装了安全管理器，则调用者可能需要访问权限才能访问它，否则可能引发安全异常。在Java环境中，使用 &lt;code&gt;SSLPermission(&quot;getSSLSessionContext&quot;)&lt;/code&gt; 权限调用安全管理器的 &lt;code&gt;checkPermission&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="6d873373059873c2f9dda2243106e00e462486c8" translate="yes" xml:space="preserve">
          <source>If the conversion is &lt;code&gt;'a'&lt;/code&gt; or &lt;code&gt;'A'&lt;/code&gt;, then the precision is the number of hexadecimal digits after the radix point. If the precision is not provided, then all of the digits as returned by &lt;a href=&quot;../lang/double#toHexString-double-&quot;&gt;&lt;code&gt;Double.toHexString(double)&lt;/code&gt;&lt;/a&gt; will be output.</source>
          <target state="translated">如果转换为 &lt;code&gt;'a'&lt;/code&gt; 或 &lt;code&gt;'A'&lt;/code&gt; ，则精度为小数点后的十六进制数字。如果未提供精度，则将输出&lt;a href=&quot;../lang/double#toHexString-double-&quot;&gt; &lt;code&gt;Double.toHexString(double)&lt;/code&gt; &lt;/a&gt;返回的所有数字。</target>
        </trans-unit>
        <trans-unit id="4920cb3a35e9ffdd181f2cc1c02598946a361975" translate="yes" xml:space="preserve">
          <source>If the conversion is &lt;code&gt;'g'&lt;/code&gt; or &lt;code&gt;'G'&lt;/code&gt;, then the precision is the total number of significant digits in the resulting magnitude after rounding. If the precision is not specified, then the default value is &lt;code&gt;6&lt;/code&gt;. If the precision is &lt;code&gt;0&lt;/code&gt;, then it is taken to be &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">如果转换是 &lt;code&gt;'g'&lt;/code&gt; 或 &lt;code&gt;'G'&lt;/code&gt; ，则精度是四舍五入后得到的幅度中有效位数的总数。如果未指定精度，则默认值为 &lt;code&gt;6&lt;/code&gt; 。如果精度为 &lt;code&gt;0&lt;/code&gt; ，则将其视为 &lt;code&gt;1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5b740696da8433363284a2a09b00def3e5dd32a1" translate="yes" xml:space="preserve">
          <source>If the conversion is &lt;code&gt;'o'&lt;/code&gt;, &lt;code&gt;'x'&lt;/code&gt;, or &lt;code&gt;'X'&lt;/code&gt; and both the &lt;code&gt;'#'&lt;/code&gt; and the &lt;code&gt;'0'&lt;/code&gt; flags are given, then result will contain the base indicator (&lt;code&gt;'0'&lt;/code&gt; for octal and &lt;code&gt;&quot;0x&quot;&lt;/code&gt; or &lt;code&gt;&quot;0X&quot;&lt;/code&gt; for hexadecimal), some number of zeros (based on the width), and the value.</source>
          <target state="translated">如果转换是 &lt;code&gt;'o'&lt;/code&gt; ， &lt;code&gt;'x'&lt;/code&gt; 或 &lt;code&gt;'X'&lt;/code&gt; 并且给出了 &lt;code&gt;'#'&lt;/code&gt; 和 &lt;code&gt;'0'&lt;/code&gt; 标志，则结果将包含基本指示符（八进制为 &lt;code&gt;'0'&lt;/code&gt; ， &lt;code&gt;&quot;0x&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;0X&quot;&lt;/code&gt; （十六进制），一些零（基于宽度）和值。</target>
        </trans-unit>
        <trans-unit id="8d9565e696ad547e1a513117ec394adf4606346c" translate="yes" xml:space="preserve">
          <source>If the conversion is &lt;code&gt;'o'&lt;/code&gt;, &lt;code&gt;'x'&lt;/code&gt;, or &lt;code&gt;'X'&lt;/code&gt; and both the &lt;code&gt;'#'&lt;/code&gt; and the &lt;code&gt;'0'&lt;/code&gt; flags are given, then result will contain the radix indicator (&lt;code&gt;'0'&lt;/code&gt; for octal and &lt;code&gt;&quot;0x&quot;&lt;/code&gt; or &lt;code&gt;&quot;0X&quot;&lt;/code&gt; for hexadecimal), some number of zeros (based on the width), and the value.</source>
          <target state="translated">如果转换为 &lt;code&gt;'o'&lt;/code&gt; ， &lt;code&gt;'x'&lt;/code&gt; 或 &lt;code&gt;'X'&lt;/code&gt; 并且给出了 &lt;code&gt;'#'&lt;/code&gt; 和 &lt;code&gt;'0'&lt;/code&gt; 标志，则结果将包含基数指示符（八进制为 &lt;code&gt;'0'&lt;/code&gt; ， &lt;code&gt;&quot;0x&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;0X&quot;&lt;/code&gt; （十六进制），一些零（基于宽度）和值。</target>
        </trans-unit>
        <trans-unit id="f92ee64ab913667741eadac9533a1057cb848b90" translate="yes" xml:space="preserve">
          <source>If the count reaches zero then the method returns with the value &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">如果计数达到零，则该方法返回值 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ebf6135f725f6abcb2f61e9b10a4d1d32a5ee738" translate="yes" xml:space="preserve">
          <source>If the counter can wrap around its maximum value, the modulus needs to be specified. The modulus is the value at which the counter is reset to zero.</source>
          <target state="translated">如果计数器可以环绕其最大值,则需要指定模数。模数是将计数器重置为零的值。</target>
        </trans-unit>
        <trans-unit id="7b2012ddc4ebb24e7045b7a055ac3ae1d060dc81" translate="yes" xml:space="preserve">
          <source>If the counter difference mode is used, the value of the derived gauge is calculated as the difference between the observed counter values for two successive observations. If this difference is negative, the value of the derived gauge is incremented by the value of the modulus. The derived gauge value (V[t]) is calculated using the following method:</source>
          <target state="translated">如果使用计数器差值模式,推导出的量规值是以连续两次观测的计数器值之差计算的。如果这个差值是负数,则导出的轨距值将以模数的值递增。得出的轨距值(V[t])用以下方法计算:</target>
        </trans-unit>
        <trans-unit id="0f1b34ff7dc9bdfbc17c9da13d95b1516d17ebbc" translate="yes" xml:space="preserve">
          <source>If the creation of this &lt;code&gt;Receiver&lt;/code&gt; resulted in implicitly opening the underlying device, the device is implicitly closed by this method. This is true unless the device is kept open by other &lt;code&gt;Receiver&lt;/code&gt; or &lt;code&gt;Transmitter&lt;/code&gt; instances that opened the device implicitly, and unless the device has been opened explicitly. If the device this &lt;code&gt;Receiver&lt;/code&gt; is retrieved from is closed explicitly by calling &lt;a href=&quot;mididevice#close--&quot;&gt;&lt;code&gt;MidiDevice.close&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;Receiver&lt;/code&gt; is closed, too. For a detailed description of open/close behaviour see the class description of &lt;a href=&quot;mididevice&quot;&gt;&lt;code&gt;MidiDevice&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果创建此 &lt;code&gt;Receiver&lt;/code&gt; 导致隐式打开底层设备，则此方法将隐式关闭该设备。这是正确的，除非该设备被其他隐式打开该设备的 &lt;code&gt;Receiver&lt;/code&gt; 或 &lt;code&gt;Transmitter&lt;/code&gt; 实例保持打开状态，并且除非该设备已显式打开。如果通过调用&lt;a href=&quot;mididevice#close--&quot;&gt; &lt;code&gt;MidiDevice.close&lt;/code&gt; &lt;/a&gt;显式关闭了从此 &lt;code&gt;Receiver&lt;/code&gt; 检索到的设备，则 &lt;code&gt;Receiver&lt;/code&gt; 也将关闭。有关打开/关闭行为的详细说明，请参见&lt;a href=&quot;mididevice&quot;&gt; &lt;code&gt;MidiDevice&lt;/code&gt; &lt;/a&gt;的类说明。</target>
        </trans-unit>
        <trans-unit id="9ae995006fbd46da8baab1bfa646c3f1a74c6123" translate="yes" xml:space="preserve">
          <source>If the creation of this &lt;code&gt;Transmitter&lt;/code&gt; resulted in implicitly opening the underlying device, the device is implicitly closed by this method. This is true unless the device is kept open by other &lt;code&gt;Receiver&lt;/code&gt; or &lt;code&gt;Transmitter&lt;/code&gt; instances that opened the device implicitly, and unless the device has been opened explicitly. If the device this &lt;code&gt;Transmitter&lt;/code&gt; is retrieved from is closed explicitly by calling &lt;a href=&quot;mididevice#close--&quot;&gt;&lt;code&gt;MidiDevice.close&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;Transmitter&lt;/code&gt; is closed, too. For a detailed description of open/close behaviour see the class description of &lt;a href=&quot;mididevice&quot;&gt;&lt;code&gt;MidiDevice&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果创建此 &lt;code&gt;Transmitter&lt;/code&gt; 导致隐式打开底层设备，则该方法将隐式关闭该设备。这是正确的，除非该设备被其他隐式打开该设备的 &lt;code&gt;Receiver&lt;/code&gt; 或 &lt;code&gt;Transmitter&lt;/code&gt; 实例保持打开状态，并且除非该设备已显式打开。如果通过调用&lt;a href=&quot;mididevice#close--&quot;&gt; &lt;code&gt;MidiDevice.close&lt;/code&gt; &lt;/a&gt;显式关闭了要从中检索此 &lt;code&gt;Transmitter&lt;/code&gt; 的设备，则 &lt;code&gt;Transmitter&lt;/code&gt; 也将关闭。有关打开/关闭行为的详细说明，请参见&lt;a href=&quot;mididevice&quot;&gt; &lt;code&gt;MidiDevice&lt;/code&gt; &lt;/a&gt;的类说明。</target>
        </trans-unit>
        <trans-unit id="6c179704df7cb8ed1b3ce0d3934ef2876dfdab64" translate="yes" xml:space="preserve">
          <source>If the current capacity of this vector is less than &lt;code&gt;minCapacity&lt;/code&gt;, then its capacity is increased by replacing its internal data array, kept in the field &lt;code&gt;elementData&lt;/code&gt;, with a larger one. The size of the new data array will be the old size plus &lt;code&gt;capacityIncrement&lt;/code&gt;, unless the value of &lt;code&gt;capacityIncrement&lt;/code&gt; is less than or equal to zero, in which case the new capacity will be twice the old capacity; but if this new size is still smaller than &lt;code&gt;minCapacity&lt;/code&gt;, then the new capacity will be &lt;code&gt;minCapacity&lt;/code&gt;.</source>
          <target state="translated">如果此向量的当前容量小于 &lt;code&gt;minCapacity&lt;/code&gt; ，则可以通过使用更大的内部数组替换保留在字段 &lt;code&gt;elementData&lt;/code&gt; 中的内部数据数组来增加其容量。新的数据阵列的大小将是原来的大小加上 &lt;code&gt;capacityIncrement&lt;/code&gt; ，除非的值 &lt;code&gt;capacityIncrement&lt;/code&gt; 小于或等于零，在这种情况下，新的容量将是原来容量的两倍; 但是如果此新大小仍小于 &lt;code&gt;minCapacity&lt;/code&gt; ，则新容量将为 &lt;code&gt;minCapacity&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="15aa95f18520c9768c5e75e2d00df5cd87e5c814" translate="yes" xml:space="preserve">
          <source>If the current count equals zero then nothing happens.</source>
          <target state="translated">如果当前的计数等于零,那么什么都不会发生。</target>
        </trans-unit>
        <trans-unit id="f94ee3549183c062116cda5b26a97df611673964" translate="yes" xml:space="preserve">
          <source>If the current count is greater than zero then it is decremented. If the new count is zero then all waiting threads are re-enabled for thread scheduling purposes.</source>
          <target state="translated">如果当前的计数大于零,那么它将被递减。如果新的计数为零,那么所有等待的线程将被重新启用,以达到线程调度的目的。</target>
        </trans-unit>
        <trans-unit id="3a7db62e9957e4a583a5bb47860c808eb80b034b" translate="yes" xml:space="preserve">
          <source>If the current count is greater than zero then the current thread becomes disabled for thread scheduling purposes and lies dormant until one of three things happen:</source>
          <target state="translated">如果当前计数大于零,那么当前线程就会因为线程调度的目的而被禁用,并处于休眠状态,直到三种情况之一发生。</target>
        </trans-unit>
        <trans-unit id="d7ac4173a35be7aa72f90b5ce9f676b82ef7108f" translate="yes" xml:space="preserve">
          <source>If the current count is greater than zero then the current thread becomes disabled for thread scheduling purposes and lies dormant until one of two things happen:</source>
          <target state="translated">如果当前计数大于零,那么当前线程就会因为线程调度的目的而被禁用,并处于休眠状态,直到两种情况之一发生。</target>
        </trans-unit>
        <trans-unit id="0e615f8a82085afa953ed38e8e8581f0bc679866" translate="yes" xml:space="preserve">
          <source>If the current count is zero then this method returns immediately with the value &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">如果当前计数为零，则此方法立即返回 &lt;code&gt;true&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="bf13f63814d624078b38288a8fd1cdef5534f01f" translate="yes" xml:space="preserve">
          <source>If the current count is zero then this method returns immediately.</source>
          <target state="translated">如果当前计数为零,那么这个方法立即返回。</target>
        </trans-unit>
        <trans-unit id="a37f29b7a24ab724ec62dade14ae458a9a6defe6" translate="yes" xml:space="preserve">
          <source>If the current method handle is not of &lt;a href=&quot;methodhandle#asVarargsCollector-java.lang.Class-&quot;&gt;variable arity&lt;/a&gt;, the current method handle is returned. This is true even if the current method handle could not be a valid input to &lt;code&gt;asVarargsCollector&lt;/code&gt;.</source>
          <target state="translated">如果当前方法句柄不是&lt;a href=&quot;methodhandle#asVarargsCollector-java.lang.Class-&quot;&gt;可变变量&lt;/a&gt;，则返回当前方法句柄。即使当前方法句柄不能作为 &lt;code&gt;asVarargsCollector&lt;/code&gt; 的有效输入，也是如此。</target>
        </trans-unit>
        <trans-unit id="c10541f1b7a87a46fca0e82cb887f1f5cdfbfc64" translate="yes" xml:space="preserve">
          <source>If the current method is a variable arity method handle argument list conversion may involve the conversion and collection of several arguments into an array, as &lt;a href=&quot;methodhandle#asVarargsCollector-java.lang.Class-&quot;&gt;described elsewhere&lt;/a&gt;. In every other case, all conversions are applied &lt;em&gt;pairwise&lt;/em&gt;, which means that each argument or return value is converted to exactly one argument or return value (or no return value). The applied conversions are defined by consulting the the corresponding component types of the old and new method handle types.</source>
          <target state="translated">如果当前方法是可变Arity方法，则处理参数列表的转换可能涉及将多个参数转换和收集到数组中，如&lt;a href=&quot;methodhandle#asVarargsCollector-java.lang.Class-&quot;&gt;其他地方所述&lt;/a&gt;。在所有其他情况下，所有转换都是&lt;em&gt;成对&lt;/em&gt;应用的，这意味着每个参数或返回值都将精确地转换为一个参数或返回值（或没有返回值）。通过咨询旧方法和新方法句柄类型的相应组件类型来定义应用的转换。</target>
        </trans-unit>
        <trans-unit id="3234b563a8a8287e5245f9226141091af776f5ee" translate="yes" xml:space="preserve">
          <source>If the current position when this method is invoked is greater than the loop end point, playback continues to the end of the sequence without looping, unless the loop end point is changed subsequently.</source>
          <target state="translated">如果调用本方法时的当前位置大于循环结束点,除非循环结束点随后被改变,否则回放将继续到序列的末端,而不会循环。</target>
        </trans-unit>
        <trans-unit id="7e2a55a1a8bd4ad8685ae28cb47b45b0f898fa44" translate="yes" xml:space="preserve">
          <source>If the current position when this method is invoked is greater than the loop end point, playback simply continues to the end of the clip without looping.</source>
          <target state="translated">如果调用本方法时的当前位置大于循环结束点,则回放只需继续到剪辑结束,不进行循环。</target>
        </trans-unit>
        <trans-unit id="53f9e2fbf2a84ba1f43f8095838a4643dc8b642a" translate="yes" xml:space="preserve">
          <source>If the current thread already holds the lock then the hold count is incremented by one and the method returns immediately.</source>
          <target state="translated">如果当前线程已经持有锁,那么持有数就会递增1,然后该方法立即返回。</target>
        </trans-unit>
        <trans-unit id="bea401fb42f3ffdcd05852cff501d885235ba3f7" translate="yes" xml:space="preserve">
          <source>If the current thread already holds the write lock then the hold count is incremented by one and the method returns immediately.</source>
          <target state="translated">如果当前线程已经持有写锁,那么持有数就会递增1,然后该方法立即返回。</target>
        </trans-unit>
        <trans-unit id="b5d5c6242f9711c787eadd91061f9abc9aef5a8f" translate="yes" xml:space="preserve">
          <source>If the current thread already holds this lock then the hold count is incremented by one and the method returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">如果当前线程已经持有此锁，则持有计数将增加一，并且该方法返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e1db59e340b43fddf7a6d53a8527759fc071b7e9" translate="yes" xml:space="preserve">
          <source>If the current thread already holds this lock then the hold count is incremented by one and the method returns immediately.</source>
          <target state="translated">如果当前线程已经持有这个锁,那么持有数就会递增1,并且该方法立即返回。</target>
        </trans-unit>
        <trans-unit id="c86b44509cfe15cabcfd2d4aab1300bc1d4ef97f" translate="yes" xml:space="preserve">
          <source>If the current thread is &lt;a href=&quot;../../lang/thread#interrupt--&quot;&gt;interrupted&lt;/a&gt; while waiting for a permit then it will continue to wait, but the time at which the thread is assigned a permit may change compared to the time it would have received the permit had no interruption occurred. When the thread does return from this method its interrupt status will be set.</source>
          <target state="translated">如果当前线程在等待许可时被&lt;a href=&quot;../../lang/thread#interrupt--&quot;&gt;中断&lt;/a&gt;，则它将继续等待，但是与没有发生中断的情况下获得许可的时间相比，分配线程许可的时间可能会有所变化。当线程确实从该方法返回时，将设置其中断状态。</target>
        </trans-unit>
        <trans-unit id="40fca319282952e93dfb024ecdef67ea1fa9292a" translate="yes" xml:space="preserve">
          <source>If the current thread is &lt;a href=&quot;../../lang/thread#interrupt--&quot;&gt;interrupted&lt;/a&gt; while waiting for permits then it will continue to wait and its position in the queue is not affected. When the thread does return from this method its interrupt status will be set.</source>
          <target state="translated">如果当前线程在等待许可时&lt;a href=&quot;../../lang/thread#interrupt--&quot;&gt;中断&lt;/a&gt;，则它将继续等待，并且其在队列中的位置不受影响。当线程确实从该方法返回时，将设置其中断状态。</target>
        </trans-unit>
        <trans-unit id="b1885c7979cce95514869fcb5fe52518650ad751" translate="yes" xml:space="preserve">
          <source>If the current thread is &lt;a href=&quot;thread#interrupt--&quot;&gt;interrupted&lt;/a&gt; by any thread before or while it is waiting, then an &lt;code&gt;InterruptedException&lt;/code&gt; is thrown. This exception is not thrown until the lock status of this object has been restored as described above.</source>
          <target state="translated">如果当前线程被&lt;a href=&quot;thread#interrupt--&quot;&gt;中断&lt;/a&gt;任何线程之前或在等待时，那么 &lt;code&gt;InterruptedException&lt;/code&gt; 异常被抛出。如上所述，直到该对象的锁定状态恢复之前，不会引发此异常。</target>
        </trans-unit>
        <trans-unit id="24ed769eb7f1d50760a5de23563feab0d013a7eb" translate="yes" xml:space="preserve">
          <source>If the current thread is not the last to arrive then it is disabled for thread scheduling purposes and lies dormant until one of the following things happens:</source>
          <target state="translated">如果当前线程不是最后一个到达的,那么为了线程调度的目的,它将被禁用,并处于休眠状态,直到发生以下情况之一。</target>
        </trans-unit>
        <trans-unit id="644fbda54838e93f9bd7f153a0b223117b46c3c3" translate="yes" xml:space="preserve">
          <source>If the current thread is operating in a ForkJoinPool, unschedules and returns, without executing, the next task queued by the current thread but not yet executed, if one is available, or if not available, a task that was forked by some other thread, if available. Availability may be transient, so a &lt;code&gt;null&lt;/code&gt; result does not necessarily imply quiescence of the pool this task is operating in. This method is designed primarily to support extensions, and is unlikely to be useful otherwise.</source>
          <target state="translated">如果当前线程在ForkJoinPool中运行，则对当前线程排队但尚未执行的下一个任务进行调度并返回而不执行，如果一个任务可用，或者如果不可用，则是由其他线程分叉的任务，如果可供使用的话。可用性可能是暂时的，因此， &lt;code&gt;null&lt;/code&gt; 结果不一定表示该任务正在运行的池处于静止状态。此方法主要是为了支持扩展而设计的，否则不太可能有用。</target>
        </trans-unit>
        <trans-unit id="9d049c03bd38570f1b5a5d1aad9ff5cbfe4db5f0" translate="yes" xml:space="preserve">
          <source>If the current thread is the holder of this lock then the hold count is decremented. If the hold count is now zero then the lock is released. If the current thread is not the holder of this lock then &lt;a href=&quot;../../../lang/illegalmonitorstateexception&quot;&gt;&lt;code&gt;IllegalMonitorStateException&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">如果当前线程是此锁的持有者，则保留计数将减少。如果保持计数现在为零，则释放锁定。如果当前线程不是此锁的持有者，则抛出&lt;a href=&quot;../../../lang/illegalmonitorstateexception&quot;&gt; &lt;code&gt;IllegalMonitorStateException&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2cbfc6598ed6d1e50de22bbc3b671f7d2bef7cad" translate="yes" xml:space="preserve">
          <source>If the current thread is the last thread to arrive, and a non-null barrier action was supplied in the constructor, then the current thread runs the action before allowing the other threads to continue. If an exception occurs during the barrier action then that exception will be propagated in the current thread and the barrier is placed in the broken state.</source>
          <target state="translated">如果当前线程是最后到达的线程,并且在构造函数中提供了一个非空的屏障动作,那么当前线程在允许其他线程继续之前运行该动作。如果在屏障动作过程中发生了异常,那么该异常将在当前线程中传播,屏障将被置于破损状态。</target>
        </trans-unit>
        <trans-unit id="480b46196b0983b7baf6bc149cb22ece25ccb0df" translate="yes" xml:space="preserve">
          <source>If the current thread's interrupted status is set when it enters this method, or it is &lt;a href=&quot;../../../lang/thread#interrupt--&quot;&gt;interrupted&lt;/a&gt; while waiting, it will continue to wait until signalled. When it finally returns from this method its interrupted status will still be set.</source>
          <target state="translated">如果当前线程进入此方法时设置了中断状态，或者在等待时被&lt;a href=&quot;../../../lang/thread#interrupt--&quot;&gt;中断&lt;/a&gt;，它将继续等待直到发出信号。当它最终从该方法返回时，其中断状态仍将被设置。</target>
        </trans-unit>
        <trans-unit id="b9ceafb860d280bdbbb95ef180a5ebfa010ab70b" translate="yes" xml:space="preserve">
          <source>If the current thread:</source>
          <target state="translated">如果当前线。</target>
        </trans-unit>
        <trans-unit id="a766629228a237157e338578f73608fe87ee3533" translate="yes" xml:space="preserve">
          <source>If the current token is a number, this field contains the value of that number. The current token is a number when the value of the &lt;code&gt;ttype&lt;/code&gt; field is &lt;code&gt;TT_NUMBER&lt;/code&gt;.</source>
          <target state="translated">如果当前令牌是数字，则此字段包含该数字的值。当 &lt;code&gt;ttype&lt;/code&gt; 字段的值为 &lt;code&gt;TT_NUMBER&lt;/code&gt; 时，当前令牌是一个数字。</target>
        </trans-unit>
        <trans-unit id="6e1d9b63def477efdc3e54487d9fe89e9c35bd3c" translate="yes" xml:space="preserve">
          <source>If the current token is a word token, this field contains a string giving the characters of the word token. When the current token is a quoted string token, this field contains the body of the string.</source>
          <target state="translated">如果当前标记是单词标记,则此字段包含单词标记的字符串。当当前标记为引号标记时,该字段包含字符串的主体。</target>
        </trans-unit>
        <trans-unit id="a247e695dc806480de65475cdb7e49df5eec14fe" translate="yes" xml:space="preserve">
          <source>If the day-of-month is invalid for the year, it will be changed to the last valid day of the month.</source>
          <target state="translated">如果该年的月份无效,将改为该月的最后一天有效。</target>
        </trans-unit>
        <trans-unit id="5735c07ca103e22b6407b4ed7457c3834e66f98c" translate="yes" xml:space="preserve">
          <source>If the day-of-week is not available to format or parse then jump to day-of-month.</source>
          <target state="translated">如果没有星期的格式或解析,则跳转到月份的日期。</target>
        </trans-unit>
        <trans-unit id="dfa93f2a463d291904aa277d4928f5e5cc774981" translate="yes" xml:space="preserve">
          <source>If the default behavior is not desired, then a Java security property can be set to a different Time-to-live (TTL) value for positive caching. Likewise, a system admin can configure a different negative caching TTL value when needed.</source>
          <target state="translated">如果不需要默认的行为,那么可以将Java安全属性设置为不同的正向缓存的上线时间(TTL)值。同样,系统管理员也可以在需要时配置不同的负缓存TTL值。</target>
        </trans-unit>
        <trans-unit id="b2cac5e3a466b13ae80c01fca973dcf37b93b686" translate="yes" xml:space="preserve">
          <source>If the descriptor is empty the following String is returned: &amp;lt;Descriptor&amp;gt;&amp;lt;/Descriptor&amp;gt;</source>
          <target state="translated">如果描述符为空，则返回以下字符串：&amp;lt;Descriptor&amp;gt; &amp;lt;/ Descriptor&amp;gt;</target>
        </trans-unit>
        <trans-unit id="3e04d7b4037ef0253d1eb9639910efd968b0cd89" translate="yes" xml:space="preserve">
          <source>If the desired member is &lt;code&gt;protected&lt;/code&gt;, the usual JVM rules apply, including the requirement that the lookup class must be either be in the same package as the desired member, or must inherit that member. (See the Java Virtual Machine Specification, sections 4.9.2, 5.4.3.5, and 6.4.) In addition, if the desired member is a non-static field or method in a different package, the resulting method handle may only be applied to objects of the lookup class or one of its subclasses. This requirement is enforced by narrowing the type of the leading &lt;code&gt;this&lt;/code&gt; parameter from &lt;code&gt;C&lt;/code&gt; (which will necessarily be a superclass of the lookup class) to the lookup class itself.</source>
          <target state="translated">如果所需的成员 &lt;code&gt;protected&lt;/code&gt; ，则适用常规JVM规则，包括要求查找类必须与所需的成员位于同一程序包中，或者必须继承该成员。 （请参阅Java虚拟机规范，第4.9.2、5.4.3.5和6.4节。）此外，如果所需成员是非静态字段或其他程序包中的方法，则结果方法句柄可能仅应用于查找类或其子类之一的对象。通过 &lt;code&gt;this&lt;/code&gt; 参数的类型从 &lt;code&gt;C&lt;/code&gt; （必然是查找类的超类）缩小到查找类本身，可以强制实施此要求。</target>
        </trans-unit>
        <trans-unit id="2f1759b66bcf0473ca1f75eb77e287f807f0be61" translate="yes" xml:space="preserve">
          <source>If the destination is &lt;a href=&quot;processbuilder.redirect#PIPE&quot;&gt;&lt;code&gt;Redirect.PIPE&lt;/code&gt;&lt;/a&gt; (the initial value), then the error output of a subprocess can be read using the input stream returned by &lt;a href=&quot;process#getErrorStream--&quot;&gt;&lt;code&gt;Process.getErrorStream()&lt;/code&gt;&lt;/a&gt;. If the destination is set to any other value, then &lt;a href=&quot;process#getErrorStream--&quot;&gt;&lt;code&gt;Process.getErrorStream()&lt;/code&gt;&lt;/a&gt; will return a &lt;a href=&quot;#redirect-output&quot;&gt;null input stream&lt;/a&gt;.</source>
          <target state="translated">如果目的地是&lt;a href=&quot;processbuilder.redirect#PIPE&quot;&gt; &lt;code&gt;Redirect.PIPE&lt;/code&gt; &lt;/a&gt;（初始值），则可以使用&lt;a href=&quot;process#getErrorStream--&quot;&gt; &lt;code&gt;Process.getErrorStream()&lt;/code&gt; &lt;/a&gt;返回的输入流读取子流程的错误输出。如果目标设置为任何其他值，则&lt;a href=&quot;process#getErrorStream--&quot;&gt; &lt;code&gt;Process.getErrorStream()&lt;/code&gt; &lt;/a&gt;将返回&lt;a href=&quot;#redirect-output&quot;&gt;空输入流&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b68154bc9bb15cf5c833579d040cf02c8940944f" translate="yes" xml:space="preserve">
          <source>If the destination is &lt;a href=&quot;processbuilder.redirect#PIPE&quot;&gt;&lt;code&gt;Redirect.PIPE&lt;/code&gt;&lt;/a&gt; (the initial value), then the standard output of a subprocess can be read using the input stream returned by &lt;a href=&quot;process#getInputStream--&quot;&gt;&lt;code&gt;Process.getInputStream()&lt;/code&gt;&lt;/a&gt;. If the destination is set to any other value, then &lt;a href=&quot;process#getInputStream--&quot;&gt;&lt;code&gt;Process.getInputStream()&lt;/code&gt;&lt;/a&gt; will return a &lt;a href=&quot;#redirect-output&quot;&gt;null input stream&lt;/a&gt;.</source>
          <target state="translated">如果目的地是&lt;a href=&quot;processbuilder.redirect#PIPE&quot;&gt; &lt;code&gt;Redirect.PIPE&lt;/code&gt; &lt;/a&gt;（初始值），则可以使用&lt;a href=&quot;process#getInputStream--&quot;&gt; &lt;code&gt;Process.getInputStream()&lt;/code&gt; &lt;/a&gt;返回的输入流读取子流程的标准输出。如果目的地设置为任何其他值，则&lt;a href=&quot;process#getInputStream--&quot;&gt; &lt;code&gt;Process.getInputStream()&lt;/code&gt; &lt;/a&gt;将返回&lt;a href=&quot;#redirect-output&quot;&gt;空输入流&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5814c260a49a2bf524faa7ed1d2bd24188a54959" translate="yes" xml:space="preserve">
          <source>If the destination's &lt;code&gt;append()&lt;/code&gt; method never throws &lt;code&gt;IOException&lt;/code&gt;, then this method will always return &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">如果目标的 &lt;code&gt;append()&lt;/code&gt; 方法从不抛出 &lt;code&gt;IOException&lt;/code&gt; ，则此方法将始终返回 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ec907f76145e8ddd032cdc8267ff559cc1c48182" translate="yes" xml:space="preserve">
          <source>If the digit is less than 10, then &lt;code&gt;'0' + digit&lt;/code&gt; is returned. Otherwise, the value &lt;code&gt;'a' + digit - 10&lt;/code&gt; is returned.</source>
          <target state="translated">如果数字小于10，则返回 &lt;code&gt;'0' + digit&lt;/code&gt; 。否则，返回值 &lt;code&gt;'a' + digit - 10&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d397471c9fa609642a9cc71822d0d3db3f61ef8d" translate="yes" xml:space="preserve">
          <source>If the directory does not support a string representation of some or all of its attributes, the form of &lt;code&gt;search&lt;/code&gt; that accepts filter arguments in the form of Objects can be used instead. The service provider for such a directory would then translate the filter arguments to its service-specific representation for filter evaluation. See &lt;code&gt;search(Name, String, Object[], SearchControls)&lt;/code&gt;.</source>
          <target state="translated">如果目录不支持部分或全部属性的字符串表示形式，则可以使用接受对象形式的过滤器参数的 &lt;code&gt;search&lt;/code&gt; 形式。然后，此类目录的服务提供者会将过滤器参数转换为其特定于服务的表示形式，以进行过滤器评估。参见 &lt;code&gt;search(Name, String, Object[], SearchControls)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="762fcdd3511f74261ffaaa36150e2a54b62d2512" translate="yes" xml:space="preserve">
          <source>If the domain includes at least one occurrence of the wildcard characters asterisk (&lt;code&gt;*&lt;/code&gt;) or question mark (&lt;code&gt;?&lt;/code&gt;), then the object name is a pattern. The asterisk matches any sequence of zero or more characters, while the question mark matches any single character.</source>
          <target state="translated">如果域中至少包含一次出现的通配符星号（ &lt;code&gt;*&lt;/code&gt; ）或问号（ &lt;code&gt;?&lt;/code&gt; ），则对象名称为模式。星号匹配零个或多个字符的任何序列，而问号匹配任何单个字符。</target>
        </trans-unit>
        <trans-unit id="b1cec24c27c8efb590156606b357f3a860a3a802" translate="yes" xml:space="preserve">
          <source>If the domain is empty, it will be replaced in certain contexts by the &lt;em&gt;default domain&lt;/em&gt; of the MBean server in which the ObjectName is used.</source>
          <target state="translated">如果该域为空，则在某些上下文中，它将被使用ObjectName的MBean服务器的&lt;em&gt;默认域&lt;/em&gt;替换。</target>
        </trans-unit>
        <trans-unit id="166569c27e8b2a7656f585d48975b7df17589d30" translate="yes" xml:space="preserve">
          <source>If the encoding has an historical name then that name is returned; otherwise the encoding's canonical name is returned.</source>
          <target state="translated">如果编码有历史名称,那么将返回该名称;否则将返回编码的规范名称。</target>
        </trans-unit>
        <trans-unit id="48c3f477e37a6d7f2bde864091bbef88c4c21567" translate="yes" xml:space="preserve">
          <source>If the end of the stream is encountered before all the bits have been read, an &lt;code&gt;java.io.EOFException&lt;/code&gt; is thrown.</source>
          <target state="translated">如果在读取所有位之前遇到流的末尾，则将抛出 &lt;code&gt;java.io.EOFException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2217350c5c68b3e5ab4a98715b4b5c48f6366d39" translate="yes" xml:space="preserve">
          <source>If the entire string has been read or skipped, then this method has no effect and always returns 0.</source>
          <target state="translated">如果整个字符串已经被读取或跳过,那么这个方法没有任何效果,总是返回0。</target>
        </trans-unit>
        <trans-unit id="8ece76de2aa9cb829e9b2c9714827801ca68dc1f" translate="yes" xml:space="preserve">
          <source>If the entry being considered was created by a call to &lt;code&gt;setKeyEntry&lt;/code&gt;, or created by a call to &lt;code&gt;setEntry&lt;/code&gt; with a &lt;code&gt;PrivateKeyEntry&lt;/code&gt;, then the given certificate is compared to the first element of that entry's certificate chain.</source>
          <target state="translated">如果考虑的条目是通过调用 &lt;code&gt;setKeyEntry&lt;/code&gt; 创建的，或者是通过调用带有 &lt;code&gt;PrivateKeyEntry&lt;/code&gt; 的 &lt;code&gt;setEntry&lt;/code&gt; 创建的，则将给定的证书与该条目的证书链的第一个元素进行比较。</target>
        </trans-unit>
        <trans-unit id="0a00a113b23cd107c1f980e1846beabb40469342" translate="yes" xml:space="preserve">
          <source>If the entry is output to a ZIP file or ZIP file formatted output stream the last modification time set by this method will be stored into the &lt;code&gt;date and time fields&lt;/code&gt; of the zip file entry and encoded in standard &lt;code&gt;MS-DOS date and time format&lt;/code&gt;. The &lt;a href=&quot;../timezone#getDefault--&quot;&gt;&lt;code&gt;default TimeZone&lt;/code&gt;&lt;/a&gt; is used to convert the epoch time to the MS-DOS data and time.</source>
          <target state="translated">如果将条目输出到ZIP文件或ZIP文件格式的输出流，则通过此方法设置的最后修改时间将存储在zip文件条目的 &lt;code&gt;date and time fields&lt;/code&gt; 中，并以标准 &lt;code&gt;MS-DOS date and time format&lt;/code&gt; 编码。的&lt;a href=&quot;../timezone#getDefault--&quot;&gt; &lt;code&gt;default TimeZone&lt;/code&gt; &lt;/a&gt;被用于历元时间转换为MS-DOS数据和时间。</target>
        </trans-unit>
        <trans-unit id="a5ccafee62ee3362796ffa2f54139e7599780958" translate="yes" xml:space="preserve">
          <source>If the entry is read from a ZIP file or ZIP file formatted input stream, this is the last modification time from the &lt;code&gt;date and time fields&lt;/code&gt; of the zip file entry. The &lt;a href=&quot;../timezone#getDefault--&quot;&gt;&lt;code&gt;default TimeZone&lt;/code&gt;&lt;/a&gt; is used to convert the standard MS-DOS formatted date and time to the epoch time.</source>
          <target state="translated">如果从ZIP文件或ZIP文件格式的输入流中读取条目，则这是zip文件条目的 &lt;code&gt;date and time fields&lt;/code&gt; 中的最后修改时间。的&lt;a href=&quot;../timezone#getDefault--&quot;&gt; &lt;code&gt;default TimeZone&lt;/code&gt; &lt;/a&gt;被用于标准的MS-DOS格式的日期和时间转换为信号出现时间。</target>
        </trans-unit>
        <trans-unit id="4b289b42cb002e533856d62e0fbbde21b7d11a5b" translate="yes" xml:space="preserve">
          <source>If the entry is read from a ZIP file or ZIP file formatted input stream, this is the last modification time from the zip file entry's &lt;code&gt;optional extra data&lt;/code&gt; if the extended timestamp fields are present. Otherwise the last modification time is read from the entry's &lt;code&gt;date and time fields&lt;/code&gt;, the &lt;a href=&quot;../timezone#getDefault--&quot;&gt;&lt;code&gt;default TimeZone&lt;/code&gt;&lt;/a&gt; is used to convert the standard MS-DOS formatted date and time to the epoch time.</source>
          <target state="translated">如果从ZIP文件或ZIP文件格式的输入流中读取条目，则这是存在扩展时间戳字段的情况下来自zip文件条目的 &lt;code&gt;optional extra data&lt;/code&gt; 的最后修改时间。否则，将从条目的 &lt;code&gt;date and time fields&lt;/code&gt; 读取最后的修改时间，&lt;a href=&quot;../timezone#getDefault--&quot;&gt; &lt;code&gt;default TimeZone&lt;/code&gt; &lt;/a&gt;用于将标准MS-DOS格式的日期和时间转换为纪元时间。</target>
        </trans-unit>
        <trans-unit id="44db14d1e9cdb3209ffe191f5a2a3430583832df" translate="yes" xml:space="preserve">
          <source>If the event involved an exception, this will be the exception object. Otherwise null.</source>
          <target state="translated">如果事件涉及到异常,这将是异常对象,否则为空。否则为空。</target>
        </trans-unit>
        <trans-unit id="e0292adc0114844d25fb79e16b7258d6d3885abd" translate="yes" xml:space="preserve">
          <source>If the extension class loader cannot be found then the system class loader is used; if there is no system class loader then the bootstrap class loader is used.</source>
          <target state="translated">如果找不到扩展类加载器,则使用系统类加载器;如果没有系统类加载器,则使用引导类加载器。</target>
        </trans-unit>
        <trans-unit id="2f6968b385e002c9508a424a478292c0f3a7af81" translate="yes" xml:space="preserve">
          <source>If the field is &lt;a href=&quot;temporal/chronofield#DAY_OF_WEEK&quot;&gt;&lt;code&gt;DAY_OF_WEEK&lt;/code&gt;&lt;/a&gt; then the range of the day-of-week, from 1 to 7, will be returned. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronofield#DAY_OF_WEEK&quot;&gt; &lt;code&gt;DAY_OF_WEEK&lt;/code&gt; &lt;/a&gt;，则将返回星期几的范围，从1到7。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将抛出 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5c19fc73e0fc2d097b24a11cffd6f4ae4696359b" translate="yes" xml:space="preserve">
          <source>If the field is &lt;a href=&quot;temporal/chronofield#DAY_OF_WEEK&quot;&gt;&lt;code&gt;DAY_OF_WEEK&lt;/code&gt;&lt;/a&gt; then the value of the day-of-week, from 1 to 7, will be returned. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">如果该字段为&lt;a href=&quot;temporal/chronofield#DAY_OF_WEEK&quot;&gt; &lt;code&gt;DAY_OF_WEEK&lt;/code&gt; &lt;/a&gt;，则将返回星期几，从1到7。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将抛出 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="30d9439a6bb009c979b0800716929ef61f2bbd69" translate="yes" xml:space="preserve">
          <source>If the field is &lt;a href=&quot;temporal/chronofield#DAY_OF_WEEK&quot;&gt;&lt;code&gt;DAY_OF_WEEK&lt;/code&gt;&lt;/a&gt; then this method returns true. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will return false.</source>
          <target state="translated">如果该字段为&lt;a href=&quot;temporal/chronofield#DAY_OF_WEEK&quot;&gt; &lt;code&gt;DAY_OF_WEEK&lt;/code&gt; ,&lt;/a&gt;则此方法返回true。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将返回false。</target>
        </trans-unit>
        <trans-unit id="326c5765ea79518cbefcc0303c7d41108e792d2b" translate="yes" xml:space="preserve">
          <source>If the field is &lt;a href=&quot;temporal/chronofield#MONTH_OF_YEAR&quot;&gt;&lt;code&gt;MONTH_OF_YEAR&lt;/code&gt;&lt;/a&gt; then the range of the month-of-year, from 1 to 12, will be returned. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">如果该字段为&lt;a href=&quot;temporal/chronofield#MONTH_OF_YEAR&quot;&gt; &lt;code&gt;MONTH_OF_YEAR&lt;/code&gt; &lt;/a&gt;，则将返回年份的范围（从1到12）。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将抛出 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="af240bad736f05e53adae955dd58de67cb50462f" translate="yes" xml:space="preserve">
          <source>If the field is &lt;a href=&quot;temporal/chronofield#MONTH_OF_YEAR&quot;&gt;&lt;code&gt;MONTH_OF_YEAR&lt;/code&gt;&lt;/a&gt; then the value of the month-of-year, from 1 to 12, will be returned. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">如果该字段为&lt;a href=&quot;temporal/chronofield#MONTH_OF_YEAR&quot;&gt; &lt;code&gt;MONTH_OF_YEAR&lt;/code&gt; &lt;/a&gt;，则将返回年份的值（从1到12）。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将抛出 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4fe971066ffd7c4b8626dd60c34bb8f8261cfed9" translate="yes" xml:space="preserve">
          <source>If the field is &lt;a href=&quot;temporal/chronofield#MONTH_OF_YEAR&quot;&gt;&lt;code&gt;MONTH_OF_YEAR&lt;/code&gt;&lt;/a&gt; then this method returns true. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will return false.</source>
          <target state="translated">如果该字段为&lt;a href=&quot;temporal/chronofield#MONTH_OF_YEAR&quot;&gt; &lt;code&gt;MONTH_OF_YEAR&lt;/code&gt; ,&lt;/a&gt;则此方法返回true。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将返回false。</target>
        </trans-unit>
        <trans-unit id="3cbe7e72fb8b0010865d68d0c08c6481722f84e6" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;../temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;code&gt;ERA&lt;/code&gt; field returns the range. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;../temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; ,&lt;/a&gt;则在此处实现查询。在 &lt;code&gt;ERA&lt;/code&gt; 字段返回的范围内。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将抛出 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="184058e0a14902aa21c927d78bf2821afd7ffb8f" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;../temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;code&gt;ERA&lt;/code&gt; field returns the value of the era. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;../temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; ,&lt;/a&gt;则在此处实现查询。在 &lt;code&gt;ERA&lt;/code&gt; 字段返回的时代价值。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将抛出 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1953db0f99dd40e5aaa224b3ed2d92f821f4fad2" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;../temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;code&gt;ERA&lt;/code&gt; field returns true. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will return false.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;../temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; ,&lt;/a&gt;则在此处实现查询。在 &lt;code&gt;ERA&lt;/code&gt; 场返回true。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将返回false。</target>
        </trans-unit>
        <trans-unit id="5df5ba306c3a00473938e546303760434732261a" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;../temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The supported fields are:</source>
          <target state="translated">如果该字段是&lt;a href=&quot;../temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; ,&lt;/a&gt;则在此处实现查询。支持的字段是：</target>
        </trans-unit>
        <trans-unit id="9ddb65541050763763b556e80a29c16db72c7248" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the adjustment is implemented here.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; ,&lt;/a&gt;则在此处执行调整。</target>
        </trans-unit>
        <trans-unit id="cc3692f941d5abe057e214a3bd9f234905a09651" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the adjustment is implemented here. The &lt;a href=&quot;localdatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will behave as per the matching method on &lt;a href=&quot;localdate#with-java.time.temporal.TemporalField-long-&quot;&gt;&lt;code&gt;LocalDate&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;localtime#with-java.time.temporal.TemporalField-long-&quot;&gt;&lt;code&gt;LocalTime&lt;/code&gt;&lt;/a&gt;. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; ,&lt;/a&gt;则在此处执行调整。的&lt;a href=&quot;localdatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt;将表现为每对匹配方法&lt;a href=&quot;localdate#with-java.time.temporal.TemporalField-long-&quot;&gt; &lt;code&gt;LocalDate&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;localtime#with-java.time.temporal.TemporalField-long-&quot;&gt; &lt;code&gt;LocalTime&lt;/code&gt; &lt;/a&gt;。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将抛出 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1d4babbf0823e08d2dba83490653149a8a5cf2ed" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the adjustment is implemented here. The supported fields behave as follows:</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; ,&lt;/a&gt;则在此处执行调整。支持的字段的行为如下：</target>
        </trans-unit>
        <trans-unit id="b3a122466042d935dfadf2919be12e5c6bf577cb" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;instant#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return appropriate range instances. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; ,&lt;/a&gt;则在此处实现查询。该&lt;a href=&quot;instant#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt;将返回适当的范围内的情况。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将抛出 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b2fae4d33d968604493905d86ff128c82e5db2f2" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;instant#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this date-time, except &lt;code&gt;INSTANT_SECONDS&lt;/code&gt; which is too large to fit in an &lt;code&gt;int&lt;/code&gt; and throws a &lt;code&gt;DateTimeException&lt;/code&gt;. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; ,&lt;/a&gt;则在此处实现查询。该&lt;a href=&quot;instant#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt;将返回基于此日期时间有效值，除了 &lt;code&gt;INSTANT_SECONDS&lt;/code&gt; 这是太大，无法在 &lt;code&gt;int&lt;/code&gt; 和抛出一个 &lt;code&gt;DateTimeException&lt;/code&gt; 。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将抛出 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="552594823755dd323e34fbb36aa82bd02dc7ccec" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;instant#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this date-time. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; ,&lt;/a&gt;则在此处实现查询。该&lt;a href=&quot;instant#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt;将返回基于此日期时间有效值。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将抛出 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="64682870ad58c05c116e810cd345d87fe71b6bca" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;localdate#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return appropriate range instances. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; ,&lt;/a&gt;则在此处实现查询。该&lt;a href=&quot;localdate#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt;将返回适当的范围内的情况。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将抛出 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e53df72b9538f5704d56c85109a2837d5a0400cf" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;localdate#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this date, except &lt;code&gt;EPOCH_DAY&lt;/code&gt; and &lt;code&gt;PROLEPTIC_MONTH&lt;/code&gt; which are too large to fit in an &lt;code&gt;int&lt;/code&gt; and throw a &lt;code&gt;DateTimeException&lt;/code&gt;. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; ,&lt;/a&gt;则在此处实现查询。该&lt;a href=&quot;localdate#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt;将返回除了基于此日期有效值， &lt;code&gt;EPOCH_DAY&lt;/code&gt; 和 &lt;code&gt;PROLEPTIC_MONTH&lt;/code&gt; 这是太大，无法在 &lt;code&gt;int&lt;/code&gt; 和抛出 &lt;code&gt;DateTimeException&lt;/code&gt; 。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将抛出 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="32c54db3dedc37f0421eb1580db3b740ec121cad" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;localdate#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this date. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; ,&lt;/a&gt;则在此处实现查询。该&lt;a href=&quot;localdate#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt;将返回基于此日期有效值。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将抛出 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="11ea794a31defe3e3eefa9ea5db21eca50570400" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;localdatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return appropriate range instances. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; ,&lt;/a&gt;则在此处实现查询。该&lt;a href=&quot;localdatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt;将返回适当的范围内的情况。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将抛出 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a90c6eb29cbac028e8449f9cf54d00261c219feb" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;localdatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this date-time, except &lt;code&gt;NANO_OF_DAY&lt;/code&gt;, &lt;code&gt;MICRO_OF_DAY&lt;/code&gt;, &lt;code&gt;EPOCH_DAY&lt;/code&gt; and &lt;code&gt;PROLEPTIC_MONTH&lt;/code&gt; which are too large to fit in an &lt;code&gt;int&lt;/code&gt; and throw a &lt;code&gt;DateTimeException&lt;/code&gt;. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; ,&lt;/a&gt;则在此处实现查询。该&lt;a href=&quot;localdatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt;将返回除了基于此日期时间有效值， &lt;code&gt;NANO_OF_DAY&lt;/code&gt; ， &lt;code&gt;MICRO_OF_DAY&lt;/code&gt; ， &lt;code&gt;EPOCH_DAY&lt;/code&gt; 和 &lt;code&gt;PROLEPTIC_MONTH&lt;/code&gt; 这是太大，无法在 &lt;code&gt;int&lt;/code&gt; 和抛出 &lt;code&gt;DateTimeException&lt;/code&gt; 。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将抛出 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5b5f3e15dbf7f02cadaff2b1f715b8a83fed50ca" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;localdatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this date-time. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; ,&lt;/a&gt;则在此处实现查询。该&lt;a href=&quot;localdatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt;将返回基于此日期时间有效值。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将抛出 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2d7280f2ef05621f8965764c134012686323f8c9" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;localtime#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return appropriate range instances. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; ,&lt;/a&gt;则在此处实现查询。该&lt;a href=&quot;localtime#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt;将返回适当的范围内的情况。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将抛出 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a08bb7dfd7f2733af861740d800b7ce9f70eb5cf" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;localtime#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this time, except &lt;code&gt;NANO_OF_DAY&lt;/code&gt; and &lt;code&gt;MICRO_OF_DAY&lt;/code&gt; which are too large to fit in an &lt;code&gt;int&lt;/code&gt; and throw a &lt;code&gt;DateTimeException&lt;/code&gt;. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; ,&lt;/a&gt;则在此处实现查询。该&lt;a href=&quot;localtime#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt;将返回除了基于这个时候有效值， &lt;code&gt;NANO_OF_DAY&lt;/code&gt; 和 &lt;code&gt;MICRO_OF_DAY&lt;/code&gt; 这是太大，无法在 &lt;code&gt;int&lt;/code&gt; 和抛出 &lt;code&gt;DateTimeException&lt;/code&gt; 。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将抛出 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f2ea46b126ff3b5bdbf666ca3c46b71e50576dc7" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;localtime#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this time. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; ,&lt;/a&gt;则在此处实现查询。该&lt;a href=&quot;localtime#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt;将返回基于这个时候有效值。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将抛出 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3f81a778997a088523214d2edc7a7aab7a300ca4" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;monthday#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return appropriate range instances. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; ,&lt;/a&gt;则在此处实现查询。该&lt;a href=&quot;monthday#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt;将返回适当的范围内的情况。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将抛出 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ce1690eace7e2c6d89cc928ca7a7a051f9a8d0f2" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;monthday#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this month-day. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; ,&lt;/a&gt;则在此处实现查询。该&lt;a href=&quot;monthday#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt;将返回基于本月天有效值。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将抛出 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="54c277810f3ed7c547f4b1ad6fd3fb8f9a746292" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;offsetdatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return appropriate range instances. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; ,&lt;/a&gt;则在此处实现查询。该&lt;a href=&quot;offsetdatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt;将返回适当的范围内的情况。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将抛出 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="20e764af5b165d57d63cb3a6753fd7d4d9d38420" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;offsetdatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this date-time, except &lt;code&gt;NANO_OF_DAY&lt;/code&gt;, &lt;code&gt;MICRO_OF_DAY&lt;/code&gt;, &lt;code&gt;EPOCH_DAY&lt;/code&gt;, &lt;code&gt;PROLEPTIC_MONTH&lt;/code&gt; and &lt;code&gt;INSTANT_SECONDS&lt;/code&gt; which are too large to fit in an &lt;code&gt;int&lt;/code&gt; and throw a &lt;code&gt;DateTimeException&lt;/code&gt;. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; ,&lt;/a&gt;则在此处实现查询。该&lt;a href=&quot;offsetdatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt;将返回基于此日期时间，除了有效值 &lt;code&gt;NANO_OF_DAY&lt;/code&gt; ， &lt;code&gt;MICRO_OF_DAY&lt;/code&gt; ， &lt;code&gt;EPOCH_DAY&lt;/code&gt; ， &lt;code&gt;PROLEPTIC_MONTH&lt;/code&gt; 和 &lt;code&gt;INSTANT_SECONDS&lt;/code&gt; 这是太大，无法在 &lt;code&gt;int&lt;/code&gt; 和抛出 &lt;code&gt;DateTimeException&lt;/code&gt; 。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将抛出 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bbfa08249a8a681a77ac31ded9b0970961cb7e45" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;offsetdatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this date-time. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; ,&lt;/a&gt;则在此处实现查询。该&lt;a href=&quot;offsetdatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt;将返回基于此日期时间有效值。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将抛出 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="216d1b40d29dcd13ae455e39ff25a34173b680bc" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;offsettime#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return appropriate range instances. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; ,&lt;/a&gt;则在此处实现查询。该&lt;a href=&quot;offsettime#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt;将返回适当的范围内的情况。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将抛出 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="89af7f61649fef38a7f170c1bd0ab908cfde7464" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;offsettime#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this time, except &lt;code&gt;NANO_OF_DAY&lt;/code&gt; and &lt;code&gt;MICRO_OF_DAY&lt;/code&gt; which are too large to fit in an &lt;code&gt;int&lt;/code&gt; and throw a &lt;code&gt;DateTimeException&lt;/code&gt;. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; ,&lt;/a&gt;则在此处实现查询。该&lt;a href=&quot;offsettime#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt;将返回除了基于这个时候有效值， &lt;code&gt;NANO_OF_DAY&lt;/code&gt; 和 &lt;code&gt;MICRO_OF_DAY&lt;/code&gt; 这是太大，无法在 &lt;code&gt;int&lt;/code&gt; 和抛出 &lt;code&gt;DateTimeException&lt;/code&gt; 。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将抛出 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f135da292374c58a63e9a7dd6bf4f22cdbf128fc" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;offsettime#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this time. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; ,&lt;/a&gt;则在此处实现查询。该&lt;a href=&quot;offsettime#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt;将返回基于这个时候有效值。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将抛出 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="66a31e186370c87394aabeac098a9be857ade9fd" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;year#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return appropriate range instances. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; ,&lt;/a&gt;则在此处实现查询。该&lt;a href=&quot;year#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt;将返回适当的范围内的情况。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将抛出 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1a78917caede284548be462696171d8a8df88818" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;year#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this year. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; ,&lt;/a&gt;则在此处实现查询。该&lt;a href=&quot;year#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt;将返回基于今年有效值。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将抛出 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="638fba149e2f9605d4c8dd06cfefd8163837f176" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;yearmonth#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return appropriate range instances. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; ,&lt;/a&gt;则在此处实现查询。该&lt;a href=&quot;yearmonth#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt;将返回适当的范围内的情况。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将抛出 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bc96611b6dd2d22d3132d6d3df53e51b38124d7a" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;yearmonth#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this year-month, except &lt;code&gt;PROLEPTIC_MONTH&lt;/code&gt; which is too large to fit in an &lt;code&gt;int&lt;/code&gt; and throw a &lt;code&gt;DateTimeException&lt;/code&gt;. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; ,&lt;/a&gt;则在此处实现查询。该&lt;a href=&quot;yearmonth#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt;将返回基础上，今年个月的有效值，除了 &lt;code&gt;PROLEPTIC_MONTH&lt;/code&gt; 这是太大，无法在 &lt;code&gt;int&lt;/code&gt; 和抛出 &lt;code&gt;DateTimeException&lt;/code&gt; 。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将抛出 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5f2e16d3207b8a1b377b13995b5829979baa3c06" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;yearmonth#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this year-month. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; ,&lt;/a&gt;则在此处实现查询。该&lt;a href=&quot;yearmonth#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt;将返回基础上，今年个月的有效值。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将抛出 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5fda7020a7bae43a5df2b5286206bb91d72d039d" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;zoneddatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return appropriate range instances. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; ,&lt;/a&gt;则在此处实现查询。该&lt;a href=&quot;zoneddatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt;将返回适当的范围内的情况。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将抛出 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="88d03525f1042dd0011a22419c6df4c5121eba14" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;zoneddatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this date-time, except &lt;code&gt;NANO_OF_DAY&lt;/code&gt;, &lt;code&gt;MICRO_OF_DAY&lt;/code&gt;, &lt;code&gt;EPOCH_DAY&lt;/code&gt;, &lt;code&gt;PROLEPTIC_MONTH&lt;/code&gt; and &lt;code&gt;INSTANT_SECONDS&lt;/code&gt; which are too large to fit in an &lt;code&gt;int&lt;/code&gt; and throw a &lt;code&gt;DateTimeException&lt;/code&gt;. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; ,&lt;/a&gt;则在此处实现查询。该&lt;a href=&quot;zoneddatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt;将返回基于此日期时间，除了有效值 &lt;code&gt;NANO_OF_DAY&lt;/code&gt; ， &lt;code&gt;MICRO_OF_DAY&lt;/code&gt; ， &lt;code&gt;EPOCH_DAY&lt;/code&gt; ， &lt;code&gt;PROLEPTIC_MONTH&lt;/code&gt; 和 &lt;code&gt;INSTANT_SECONDS&lt;/code&gt; 这是太大，无法在 &lt;code&gt;int&lt;/code&gt; 和抛出 &lt;code&gt;DateTimeException&lt;/code&gt; 。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将抛出 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a0124fd3059f644ca04188c31653732caf32a08f" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;zoneddatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this date-time. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; ,&lt;/a&gt;则在此处实现查询。该&lt;a href=&quot;zoneddatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt;将返回基于此日期时间有效值。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将抛出 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0337a2eda7a472dc0aa83a7e1eef644d5a370e32" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;zoneoffset#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return appropriate range instances. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; ,&lt;/a&gt;则在此处实现查询。该&lt;a href=&quot;zoneoffset#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt;将返回适当的范围内的情况。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将抛出 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4046ccaca6ad2d1bf0b7e5c2e124396f1812f96d" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;code&gt;OFFSET_SECONDS&lt;/code&gt; field returns the value of the offset. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; ,&lt;/a&gt;则在此处实现查询。该 &lt;code&gt;OFFSET_SECONDS&lt;/code&gt; 场返回的偏移值。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将抛出 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="09800c7a5d51ab3ac1ecbfa59a39761992b8d783" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;code&gt;OFFSET_SECONDS&lt;/code&gt; field returns true. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will return false.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; ,&lt;/a&gt;则在此处实现查询。该 &lt;code&gt;OFFSET_SECONDS&lt;/code&gt; 场返回true。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将返回false。</target>
        </trans-unit>
        <trans-unit id="bcdaaec98194652eaec2e755f354592d8a5f1fa2" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The supported fields are:</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; ,&lt;/a&gt;则在此处实现查询。支持的字段是：</target>
        </trans-unit>
        <trans-unit id="3d8816d4bddc205a3c0266b4706842519edca858" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronounit&quot;&gt;&lt;code&gt;ChronoUnit&lt;/code&gt;&lt;/a&gt; then the addition is implemented by &lt;a href=&quot;localdatetime#plus-long-java.time.temporal.TemporalUnit-&quot;&gt;&lt;code&gt;LocalDateTime.plus(long, TemporalUnit)&lt;/code&gt;&lt;/a&gt;. The offset is not part of the calculation and will be unchanged in the result.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronounit&quot;&gt; &lt;code&gt;ChronoUnit&lt;/code&gt; ,&lt;/a&gt;则添加由&lt;a href=&quot;localdatetime#plus-long-java.time.temporal.TemporalUnit-&quot;&gt; &lt;code&gt;LocalDateTime.plus(long, TemporalUnit)&lt;/code&gt; &lt;/a&gt;。偏移量不是计算的一部分，其结果将保持不变。</target>
        </trans-unit>
        <trans-unit id="5a927c94cc558aa44e673d3c09b5dede6b4bbec9" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronounit&quot;&gt;&lt;code&gt;ChronoUnit&lt;/code&gt;&lt;/a&gt; then the addition is implemented by &lt;a href=&quot;localtime#plus-long-java.time.temporal.TemporalUnit-&quot;&gt;&lt;code&gt;LocalTime.plus(long, TemporalUnit)&lt;/code&gt;&lt;/a&gt;. The offset is not part of the calculation and will be unchanged in the result.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronounit&quot;&gt; &lt;code&gt;ChronoUnit&lt;/code&gt; ,&lt;/a&gt;则添加由&lt;a href=&quot;localtime#plus-long-java.time.temporal.TemporalUnit-&quot;&gt; &lt;code&gt;LocalTime.plus(long, TemporalUnit)&lt;/code&gt; &lt;/a&gt;。偏移量不是计算的一部分，其结果将保持不变。</target>
        </trans-unit>
        <trans-unit id="f5cba436d7af3b0ad553fc0358e491b4ffeb23a3" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronounit&quot;&gt;&lt;code&gt;ChronoUnit&lt;/code&gt;&lt;/a&gt; then the addition is implemented here. Date units are added as per &lt;a href=&quot;localdate#plus-long-java.time.temporal.TemporalUnit-&quot;&gt;&lt;code&gt;LocalDate.plus(long, TemporalUnit)&lt;/code&gt;&lt;/a&gt;. Time units are added as per &lt;a href=&quot;localtime#plus-long-java.time.temporal.TemporalUnit-&quot;&gt;&lt;code&gt;LocalTime.plus(long, TemporalUnit)&lt;/code&gt;&lt;/a&gt; with any overflow in days added equivalent to using &lt;a href=&quot;localdatetime#plusDays-long-&quot;&gt;&lt;code&gt;plusDays(long)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronounit&quot;&gt; &lt;code&gt;ChronoUnit&lt;/code&gt; ,&lt;/a&gt;则在此处实现添加。按照&lt;a href=&quot;localdate#plus-long-java.time.temporal.TemporalUnit-&quot;&gt; &lt;code&gt;LocalDate.plus(long, TemporalUnit)&lt;/code&gt; &lt;/a&gt;添加日期单位。时间单位是根据&lt;a href=&quot;localtime#plus-long-java.time.temporal.TemporalUnit-&quot;&gt; &lt;code&gt;LocalTime.plus(long, TemporalUnit)&lt;/code&gt; &lt;/a&gt;添加的，以天为单位的任何溢出都等于使用&lt;a href=&quot;localdatetime#plusDays-long-&quot;&gt; &lt;code&gt;plusDays(long)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="87edabfd23bcd4b5580257d424970351a200d0e6" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronounit&quot;&gt;&lt;code&gt;ChronoUnit&lt;/code&gt;&lt;/a&gt; then the addition is implemented here. The supported fields behave as follows:</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronounit&quot;&gt; &lt;code&gt;ChronoUnit&lt;/code&gt; ,&lt;/a&gt;则在此处实现添加。支持的字段的行为如下：</target>
        </trans-unit>
        <trans-unit id="7d28f15788411edaf2c4769963134a70f9a51014" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronounit&quot;&gt;&lt;code&gt;ChronoUnit&lt;/code&gt;&lt;/a&gt; then the addition is implemented here. The zone is not part of the calculation and will be unchanged in the result. The calculation for date and time units differ.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronounit&quot;&gt; &lt;code&gt;ChronoUnit&lt;/code&gt; ,&lt;/a&gt;则在此处实现添加。该区域不是计算的一部分，其结果将保持不变。日期和时间单位的计算方式不同。</target>
        </trans-unit>
        <trans-unit id="df5997d9cb9eb98daf0677e44c78da78084843dc" translate="yes" xml:space="preserve">
          <source>If the field is hidden in the type of &lt;code&gt;obj&lt;/code&gt;, the field's value is obtained according to the preceding rules.</source>
          <target state="translated">如果该字段以 &lt;code&gt;obj&lt;/code&gt; 类型隐藏，则根据前面的规则获得该字段的值。</target>
        </trans-unit>
        <trans-unit id="3cd0fa2a6c549544bf0fa17d3fe9a0bbdad3a534" translate="yes" xml:space="preserve">
          <source>If the field is hidden in the type of &lt;code&gt;obj&lt;/code&gt;, the field's value is set according to the preceding rules.</source>
          <target state="translated">如果该字段以 &lt;code&gt;obj&lt;/code&gt; 类型隐藏，则根据前面的规则设置该字段的值。</target>
        </trans-unit>
        <trans-unit id="c8f06458338d0982fde844f74e3eac7907ffd72d" translate="yes" xml:space="preserve">
          <source>If the field is not a &lt;code&gt;ChronoField&lt;/code&gt;, then the result of this method is obtained by invoking &lt;code&gt;TemporalField.adjustInto(Temporal, long)&lt;/code&gt; passing &lt;code&gt;this&lt;/code&gt; as the argument. In this case, the field determines whether and how to adjust the instant.</source>
          <target state="translated">如果该字段不是 &lt;code&gt;ChronoField&lt;/code&gt; ，则通过调用 &lt;code&gt;TemporalField.adjustInto(Temporal, long)&lt;/code&gt; 并将 &lt;code&gt;this&lt;/code&gt; 作为参数来获取此方法的结果。在这种情况下，该字段确定是否以及如何调整瞬时。</target>
        </trans-unit>
        <trans-unit id="bc13b792f3c5838d3770d636dc87567d506bc218" translate="yes" xml:space="preserve">
          <source>If the field is not a &lt;code&gt;ChronoField&lt;/code&gt;, then the result of this method is obtained by invoking &lt;code&gt;TemporalField.adjustInto(Temporal, long)&lt;/code&gt; passing &lt;code&gt;this&lt;/code&gt; as the first argument.</source>
          <target state="translated">如果该字段不是 &lt;code&gt;ChronoField&lt;/code&gt; ，则通过调用 &lt;code&gt;TemporalField.adjustInto(Temporal, long)&lt;/code&gt; 并将 &lt;code&gt;this&lt;/code&gt; 作为第一个参数来获取此方法的结果。</target>
        </trans-unit>
        <trans-unit id="593408760a93df2aae450a2a246b1f8f655869de" translate="yes" xml:space="preserve">
          <source>If the field is not a &lt;code&gt;ChronoField&lt;/code&gt;, then the result of this method is obtained by invoking &lt;code&gt;TemporalField.getFrom(TemporalAccessor)&lt;/code&gt; passing &lt;code&gt;this&lt;/code&gt; as the argument.</source>
          <target state="translated">如果该字段不是 &lt;code&gt;ChronoField&lt;/code&gt; ，则通过调用 &lt;code&gt;TemporalField.getFrom(TemporalAccessor)&lt;/code&gt; 并将 &lt;code&gt;this&lt;/code&gt; 作为参数来获取此方法的结果。</target>
        </trans-unit>
        <trans-unit id="84111e9c7052aea445fc84ff88640c7d9d47a3e1" translate="yes" xml:space="preserve">
          <source>If the field is not a &lt;code&gt;ChronoField&lt;/code&gt;, then the result of this method is obtained by invoking &lt;code&gt;TemporalField.getFrom(TemporalAccessor)&lt;/code&gt; passing &lt;code&gt;this&lt;/code&gt; as the argument. Whether the value can be obtained, and what the value represents, is determined by the field.</source>
          <target state="translated">如果该字段不是 &lt;code&gt;ChronoField&lt;/code&gt; ，则通过调用 &lt;code&gt;TemporalField.getFrom(TemporalAccessor)&lt;/code&gt; 并将 &lt;code&gt;this&lt;/code&gt; 作为参数来获取此方法的结果。该字段是否可以获取该值以及该值代表什么。</target>
        </trans-unit>
        <trans-unit id="8c0976d6ec775eae314c44e1cc501085eba97650" translate="yes" xml:space="preserve">
          <source>If the field is not a &lt;code&gt;ChronoField&lt;/code&gt;, then the result of this method is obtained by invoking &lt;code&gt;TemporalField.isSupportedBy(TemporalAccessor)&lt;/code&gt; passing &lt;code&gt;this&lt;/code&gt; as the argument.</source>
          <target state="translated">如果该字段不是 &lt;code&gt;ChronoField&lt;/code&gt; ，则通过调用 &lt;code&gt;TemporalField.isSupportedBy(TemporalAccessor)&lt;/code&gt; 并将 &lt;code&gt;this&lt;/code&gt; 作为参数来获取此方法的结果。</target>
        </trans-unit>
        <trans-unit id="8bfc158b937ea3897727206425819d75e46f302c" translate="yes" xml:space="preserve">
          <source>If the field is not a &lt;code&gt;ChronoField&lt;/code&gt;, then the result of this method is obtained by invoking &lt;code&gt;TemporalField.isSupportedBy(TemporalAccessor)&lt;/code&gt; passing &lt;code&gt;this&lt;/code&gt; as the argument. Whether the field is supported is determined by the field.</source>
          <target state="translated">如果该字段不是 &lt;code&gt;ChronoField&lt;/code&gt; ，则通过调用 &lt;code&gt;TemporalField.isSupportedBy(TemporalAccessor)&lt;/code&gt; 并将 &lt;code&gt;this&lt;/code&gt; 作为参数来获取此方法的结果。该字段是否受支持由该字段确定。</target>
        </trans-unit>
        <trans-unit id="7688528113c7572e4ebfde7d3d5c748187dbd155" translate="yes" xml:space="preserve">
          <source>If the field is not a &lt;code&gt;ChronoField&lt;/code&gt;, then the result of this method is obtained by invoking &lt;code&gt;TemporalField.rangeRefinedBy(TemporalAccessor)&lt;/code&gt; passing &lt;code&gt;this&lt;/code&gt; as the argument. Whether the range can be obtained is determined by the field.</source>
          <target state="translated">如果该字段不是 &lt;code&gt;ChronoField&lt;/code&gt; ，则通过调用 &lt;code&gt;TemporalField.rangeRefinedBy(TemporalAccessor)&lt;/code&gt; 并将 &lt;code&gt;this&lt;/code&gt; 作为参数来获取此方法的结果。是否可以获取范围由现场确定。</target>
        </trans-unit>
        <trans-unit id="9dc945edaeb99a9dd905b6958af0da2b698eb2ff" translate="yes" xml:space="preserve">
          <source>If the field is not a &lt;code&gt;ChronoField&lt;/code&gt;, then the result of this method is obtained by invoking &lt;code&gt;TemporalField.rangeRefinedBy(TemporalAccessorl)&lt;/code&gt; passing &lt;code&gt;this&lt;/code&gt; as the argument.</source>
          <target state="translated">如果该字段不是 &lt;code&gt;ChronoField&lt;/code&gt; ，则通过调用 &lt;code&gt;TemporalField.rangeRefinedBy(TemporalAccessorl)&lt;/code&gt; 并将 &lt;code&gt;this&lt;/code&gt; 作为参数来获取此方法的结果。</target>
        </trans-unit>
        <trans-unit id="1bc2facd61e2bb2d253a7e2d751714a8d91fd304" translate="yes" xml:space="preserve">
          <source>If the field is not a &lt;code&gt;ChronoUnit&lt;/code&gt;, then the result of this method is obtained by invoking &lt;code&gt;TemporalUnit.addTo(Temporal, long)&lt;/code&gt; passing &lt;code&gt;this&lt;/code&gt; as the argument. In this case, the unit determines whether and how to perform the addition.</source>
          <target state="translated">如果该字段不是 &lt;code&gt;ChronoUnit&lt;/code&gt; ，则通过调用 &lt;code&gt;TemporalUnit.addTo(Temporal, long)&lt;/code&gt; 并将 &lt;code&gt;this&lt;/code&gt; 作为参数来获取此方法的结果。在这种情况下，该单元确定是否以及如何执行加法。</target>
        </trans-unit>
        <trans-unit id="3745b108d29fe526d4efe7b06863f59e4b41c30c" translate="yes" xml:space="preserve">
          <source>If the field is not a &lt;code&gt;ChronoUnit&lt;/code&gt;, then the result of this method is obtained by invoking &lt;code&gt;TemporalUnit.isSupportedBy(Temporal)&lt;/code&gt; passing &lt;code&gt;this&lt;/code&gt; as the argument.</source>
          <target state="translated">如果该字段不是 &lt;code&gt;ChronoUnit&lt;/code&gt; ，则通过调用 &lt;code&gt;TemporalUnit.isSupportedBy(Temporal)&lt;/code&gt; 并将 &lt;code&gt;this&lt;/code&gt; 作为参数来获取此方法的结果。</target>
        </trans-unit>
        <trans-unit id="73f48c353a2b4ef722c15d4cc5583b25df30a788" translate="yes" xml:space="preserve">
          <source>If the field is static, and if the returned method handle is invoked, the field's class will be initialized, if it has not already been initialized.</source>
          <target state="translated">如果字段是静态的,并且如果返回的方法句柄被调用,字段的类将被初始化,如果它还没有被初始化。</target>
        </trans-unit>
        <trans-unit id="99de1988747f1a4d19117e077c897d899a759367" translate="yes" xml:space="preserve">
          <source>If the file already exists and it is opened for &lt;a href=&quot;standardopenoption#WRITE&quot;&gt;&lt;code&gt;WRITE&lt;/code&gt;&lt;/a&gt; access, then its length is truncated to 0. This option is ignored if the file is opened only for &lt;a href=&quot;standardopenoption#READ&quot;&gt;&lt;code&gt;READ&lt;/code&gt;&lt;/a&gt; access.</source>
          <target state="translated">如果文件已存在并且已打开以进行&lt;a href=&quot;standardopenoption#WRITE&quot;&gt; &lt;code&gt;WRITE&lt;/code&gt; &lt;/a&gt;访问，则其长度将被截断为0。如果仅为&lt;a href=&quot;standardopenoption#READ&quot;&gt; &lt;code&gt;READ&lt;/code&gt; &lt;/a&gt;访问而打开了文件，则忽略此选项。</target>
        </trans-unit>
        <trans-unit id="717bfba6c0a90a03523ab0b13a3750e80f9e6288" translate="yes" xml:space="preserve">
          <source>If the file does not reside on a local device then no such guarantee is made.</source>
          <target state="translated">如果文件不在本地设备上,那么就没有这样的保证。</target>
        </trans-unit>
        <trans-unit id="0c9b9ed3b31f95435fd26b9b50e781fb7b10f8ba" translate="yes" xml:space="preserve">
          <source>If the file exists but is a directory rather than a regular file, does not exist but cannot be created, or cannot be opened for any other reason then a &lt;code&gt;FileNotFoundException&lt;/code&gt; is thrown.</source>
          <target state="translated">如果文件存在但是目录而不是常规文件，则不存在但无法创建，或者由于任何其他原因而无法打开文件，则抛出 &lt;code&gt;FileNotFoundException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f72ad9bda52a7b14dd7371372743b4037fafc486" translate="yes" xml:space="preserve">
          <source>If the file is a directory then the directory must be empty. In some implementations a directory has entries for special files or links that are created when the directory is created. In such implementations a directory is considered empty when only the special entries exist.</source>
          <target state="translated">如果文件是一个目录,那么该目录必须是空的。在某些实现中,一个目录有特殊文件或链接的条目,这些条目是在创建目录时创建的。在这种实现中,当只有特殊条目存在时,一个目录被认为是空的。</target>
        </trans-unit>
        <trans-unit id="d0c1117a6df1c8b656d3b8ee4f35129ed11c6504" translate="yes" xml:space="preserve">
          <source>If the file is a directory then the directory must be empty. In some implementations a directory has entries for special files or links that are created when the directory is created. In such implementations a directory is considered empty when only the special entries exist. This method can be used with the &lt;a href=&quot;files#walkFileTree-java.nio.file.Path-java.util.Set-int-java.nio.file.FileVisitor-&quot;&gt;&lt;code&gt;walkFileTree&lt;/code&gt;&lt;/a&gt; method to delete a directory and all entries in the directory, or an entire</source>
          <target state="translated">如果文件是目录，则目录必须为空。在某些实现中，目录具有创建目录时创建的特殊文件或链接的条目。在这样的实现中，当仅存在特殊条目时，目录被认为是空的。此方法可以与&lt;a href=&quot;files#walkFileTree-java.nio.file.Path-java.util.Set-int-java.nio.file.FileVisitor-&quot;&gt; &lt;code&gt;walkFileTree&lt;/code&gt; &lt;/a&gt;方法一起使用，以删除目录和目录中的所有条目，或者删除整个目录</target>
        </trans-unit>
        <trans-unit id="7dbd0c6e9ab04a8789ef0e83e00003ffa2ee9662" translate="yes" xml:space="preserve">
          <source>If the file is opened for &lt;a href=&quot;standardopenoption#WRITE&quot;&gt;&lt;code&gt;WRITE&lt;/code&gt;&lt;/a&gt; access then bytes will be written to the end of the file rather than the beginning.</source>
          <target state="translated">如果打开该文件以进行&lt;a href=&quot;standardopenoption#WRITE&quot;&gt; &lt;code&gt;WRITE&lt;/code&gt; &lt;/a&gt;访问，则字节将被写入文件的末尾而不是开头。</target>
        </trans-unit>
        <trans-unit id="f9d2a8154b6e04db066d371ce68d85675117b48d" translate="yes" xml:space="preserve">
          <source>If the file is opened for write access by other programs, then it is file system specific if writing to the end of the file is atomic.</source>
          <target state="translated">如果文件被其他程序打开写访问,那么如果对文件末尾的写是原子性的,则是文件系统特有的。</target>
        </trans-unit>
        <trans-unit id="363aa2bf9bc4403e90b3304537b4850955de2d6f" translate="yes" xml:space="preserve">
          <source>If the file mapped into this buffer resides on a local storage device then when this method returns it is guaranteed that all changes made to the buffer since it was created, or since this method was last invoked, will have been written to that device.</source>
          <target state="translated">如果映射到这个缓冲区的文件位于本地存储设备上,那么当本方法返回时,保证自创建缓冲区以来或自本方法最后一次被调用以来对缓冲区所做的所有更改都将被写入该设备。</target>
        </trans-unit>
        <trans-unit id="5d3f80a7c47e0dee8ff25771e1984095801d55de" translate="yes" xml:space="preserve">
          <source>If the file system and files remain static, then this method implements an equivalence relation for non-null &lt;code&gt;Paths&lt;/code&gt;.</source>
          <target state="translated">如果文件系统和文件保持静态，则此方法将对非null &lt;code&gt;Paths&lt;/code&gt; 实现等效关系。</target>
        </trans-unit>
        <trans-unit id="1cc09fc7cf4f903c9ad57909dbe23e700dcd6cfb" translate="yes" xml:space="preserve">
          <source>If the file system implementation does not support a time stamp to indicate the time of last access then this method returns an implementation specific default value, typically the &lt;a href=&quot;basicfileattributes#lastModifiedTime--&quot;&gt;&lt;code&gt;last-modified-time&lt;/code&gt;&lt;/a&gt; or a &lt;code&gt;FileTime&lt;/code&gt; representing the epoch (1970-01-01T00:00:00Z).</source>
          <target state="translated">如果文件系统实现不支持时间戳来指示上次访问的时间，则此方法返回特定于实现的默认值，通常是&lt;a href=&quot;basicfileattributes#lastModifiedTime--&quot;&gt; &lt;code&gt;last-modified-time&lt;/code&gt; &lt;/a&gt;或代表纪元（1970-01-01T00：00 的 &lt;code&gt;FileTime&lt;/code&gt; ： 00Z）。</target>
        </trans-unit>
        <trans-unit id="fa544bd520d9dcec26b2ece7f7dc9e779d24b413" translate="yes" xml:space="preserve">
          <source>If the file system implementation does not support a time stamp to indicate the time of last modification then this method returns an implementation specific default value, typically a &lt;code&gt;FileTime&lt;/code&gt; representing the epoch (1970-01-01T00:00:00Z).</source>
          <target state="translated">如果文件系统实现不支持时间戳来指示上次修改的时间，则此方法将返回实现特定的默认值，通常是代表纪元（1970-01-01T00：00：00Z）的 &lt;code&gt;FileTime&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="823bb3918b8c7dfd2716375b3397ec3520a2d6b4" translate="yes" xml:space="preserve">
          <source>If the file system implementation does not support a time stamp to indicate the time when the file was created then this method returns an implementation specific default value, typically the &lt;a href=&quot;basicfileattributes#lastModifiedTime--&quot;&gt;&lt;code&gt;last-modified-time&lt;/code&gt;&lt;/a&gt; or a &lt;code&gt;FileTime&lt;/code&gt; representing the epoch (1970-01-01T00:00:00Z).</source>
          <target state="translated">如果文件系统实现不支持的时间戳，以指示何时创建文件，则此方法返回一个特定于实现的默认值，典型地，时间&lt;a href=&quot;basicfileattributes#lastModifiedTime--&quot;&gt; &lt;code&gt;last-modified-time&lt;/code&gt; &lt;/a&gt;或 &lt;code&gt;FileTime&lt;/code&gt; 表示纪元（1970-01-01T00： 00：00Z）。</target>
        </trans-unit>
        <trans-unit id="cbaa60988de0c25a04ce29dd95934e886dae24fd" translate="yes" xml:space="preserve">
          <source>If the file system object identified by this object is currently registered with the watch service then the watch key, representing that registration, is returned after changing the event set or modifiers to those specified by the &lt;code&gt;events&lt;/code&gt; and &lt;code&gt;modifiers&lt;/code&gt; parameters. Changing the event set does not cause pending events for the object to be discarded. Objects are automatically registered for the &lt;a href=&quot;standardwatcheventkinds#OVERFLOW&quot;&gt;&lt;code&gt;OVERFLOW&lt;/code&gt;&lt;/a&gt; event. This event is not required to be present in the array of events.</source>
          <target state="translated">如果此对象标识的文件系统对象当前已在监视服务中注册，则在将事件集或修饰符更改为 &lt;code&gt;events&lt;/code&gt; 和 &lt;code&gt;modifiers&lt;/code&gt; 参数指定的键之后，将返回表示该注册的监视键。更改事件集不会导致对象的挂起事件被丢弃。将自动为&lt;a href=&quot;standardwatcheventkinds#OVERFLOW&quot;&gt; &lt;code&gt;OVERFLOW&lt;/code&gt; &lt;/a&gt;事件注册对象。该事件不需要出现在事件数组中。</target>
        </trans-unit>
        <trans-unit id="459754495e8f2fc830a24baaf3d7fd1c98e3b5d4" translate="yes" xml:space="preserve">
          <source>If the file system supports &lt;a href=&quot;package-summary#links&quot;&gt;symbolic links&lt;/a&gt; then this method is used to read the target of the link, failing if the file is not a symbolic link. The target of the link need not exist. The returned &lt;code&gt;Path&lt;/code&gt; object will be associated with the same file system as &lt;code&gt;link&lt;/code&gt;.</source>
          <target state="translated">如果文件系统支持&lt;a href=&quot;package-summary#links&quot;&gt;符号链接，&lt;/a&gt;则使用此方法读取链接的目标，如果文件不是符号链接，则失败。链接的目标不需要存在。返回的 &lt;code&gt;Path&lt;/code&gt; 对象将与 &lt;code&gt;link&lt;/code&gt; 相同的文件系统关联。</target>
        </trans-unit>
        <trans-unit id="d7347290370c35baf47e41039a48176f518ba6b9" translate="yes" xml:space="preserve">
          <source>If the file system supports other security related file attributes (such as a file &lt;a href=&quot;posixfileattributes#permissions--&quot;&gt;&lt;code&gt;access-permissions&lt;/code&gt;&lt;/a&gt; for example), the updating the access control list may also cause these security related attributes to be updated.</source>
          <target state="translated">如果文件系统支持其他与安全相关的文件属性（例如，文件&lt;a href=&quot;posixfileattributes#permissions--&quot;&gt; &lt;code&gt;access-permissions&lt;/code&gt; &lt;/a&gt;），则更新访问控制列表还可能导致这些与安全相关的属性被更新。</target>
        </trans-unit>
        <trans-unit id="9f05868501904493829d0907142a7754fe1122ce" translate="yes" xml:space="preserve">
          <source>If the filter returns a value, the target must accept that value as its argument in position &lt;code&gt;pos&lt;/code&gt;, preceded and/or followed by any arguments not passed to the filter. If the filter returns void, the target must accept all arguments not passed to the filter. No arguments are reordered, and a result returned from the filter replaces (in order) the whole subsequence of arguments originally passed to the adapter.</source>
          <target state="translated">如果过滤器返回一个值，则目标必须在位置 &lt;code&gt;pos&lt;/code&gt; 接受该值作为其参数，在此之前和/或之后是未传递给过滤器的任何参数。如果过滤器返回void，则目标必须接受未传递给过滤器的所有参数。没有对参数进行重新排序，并且从过滤器返回的结果将替换（按顺序）最初传递给适配器的参数的整个子序列。</target>
        </trans-unit>
        <trans-unit id="4842b7ba908041edda9019cd8af48573f8706e76" translate="yes" xml:space="preserve">
          <source>If the first &lt;code&gt;read&lt;/code&gt; on the underlying stream returns &lt;code&gt;-1&lt;/code&gt; to indicate end-of-file then this method returns &lt;code&gt;-1&lt;/code&gt;. Otherwise this method returns the number of bytes actually read.</source>
          <target state="translated">如果对基础流的第一次 &lt;code&gt;read&lt;/code&gt; 返回 &lt;code&gt;-1&lt;/code&gt; 以指示文件结束，则此方法返回 &lt;code&gt;-1&lt;/code&gt; 。否则，此方法返回实际读取的字节数。</target>
        </trans-unit>
        <trans-unit id="33b359247ef4ee2d114342c7c506f4ed4d411b51" translate="yes" xml:space="preserve">
          <source>If the first &lt;code&gt;read&lt;/code&gt; on the underlying stream returns &lt;code&gt;-1&lt;/code&gt; to indicate end-of-file then this method returns &lt;code&gt;-1&lt;/code&gt;. Otherwise this method returns the number of characters actually read.</source>
          <target state="translated">如果对基础流的第一次 &lt;code&gt;read&lt;/code&gt; 返回 &lt;code&gt;-1&lt;/code&gt; 以指示文件结束，则此方法返回 &lt;code&gt;-1&lt;/code&gt; 。否则，此方法返回实际读取的字符数。</target>
        </trans-unit>
        <trans-unit id="ce60218f2510c7e7fddf8a7ccb70e4c23d7ed409" translate="yes" xml:space="preserve">
          <source>If the first argument is NaN and the second argument is nonzero, then the result is NaN.</source>
          <target state="translated">如果第一个参数是NaN,第二个参数是非零,那么结果就是NaN。</target>
        </trans-unit>
        <trans-unit id="8870d606c771442922f1503139366f1c5f6ffb42" translate="yes" xml:space="preserve">
          <source>If the first argument is NaN, NaN is returned.</source>
          <target state="translated">如果第一个参数是NaN,则返回NaN。</target>
        </trans-unit>
        <trans-unit id="9089269bb48d32b9328e7c9f2b5e776cab13b138" translate="yes" xml:space="preserve">
          <source>If the first argument is finite and less than zero</source>
          <target state="translated">如果第一个参数是有限的,且小于零。</target>
        </trans-unit>
        <trans-unit id="40390f7aa327fdf0e7159e3c2ee52c76dda4cc5d" translate="yes" xml:space="preserve">
          <source>If the first argument is finite and the second argument is infinite, then the result is the same as the first argument.</source>
          <target state="translated">如果第一个论点是有限的,第二个论点是无限的,那么结果与第一个论点相同。</target>
        </trans-unit>
        <trans-unit id="c79e66b15f81ddc9a951871c47a016d3318d1439" translate="yes" xml:space="preserve">
          <source>If the first argument is infinite, then an infinity of the same sign is returned.</source>
          <target state="translated">如果第一个参数是无穷大,那么将返回一个相同符号的无穷大。</target>
        </trans-unit>
        <trans-unit id="ac7d4927f7484d5a09a609cfa4c9572e1d2c7f45" translate="yes" xml:space="preserve">
          <source>If the first argument is negative and the second argument is positive zero or negative zero, or the first argument is negative infinity and the second argument is finite, then the result is the &lt;code&gt;double&lt;/code&gt; value closest to -</source>
          <target state="translated">如果第一个参数为负，第二个参数为正零或负零，或者第一个参数为负无穷大，第二个参数为有限，那么结果是最接近- 的 &lt;code&gt;double&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="c8e4a59b27a1fe3d520aae3637f149a7db9573ea" translate="yes" xml:space="preserve">
          <source>If the first argument is negative infinity and the second argument is positive infinity, then the result is the &lt;code&gt;double&lt;/code&gt; value closest to -</source>
          <target state="translated">如果第一个参数为负无穷大，第二个参数为正无穷大，则结果是最接近- 的 &lt;code&gt;double&lt;/code&gt; 值</target>
        </trans-unit>
        <trans-unit id="82b10d31a7012b44b539ae72f08e4e4c13a206b9" translate="yes" xml:space="preserve">
          <source>If the first argument is negative zero and the second argument is negative, or the first argument is negative and finite and the second argument is negative infinity, then the result is the &lt;code&gt;double&lt;/code&gt; value closest to -</source>
          <target state="translated">如果第一个参数为负零，第二个参数为负，或者第一个参数为负且有限，第二个参数为负无穷大，则结果是最接近- 的 &lt;code&gt;double&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="8e475337333e7011c577f6dfd579b80f0f2ae245" translate="yes" xml:space="preserve">
          <source>If the first argument is negative zero and the second argument is positive, or the first argument is negative and finite and the second argument is positive infinity, then the result is negative zero.</source>
          <target state="translated">如果第一个论点是负零,第二个论点是正数,或者第一个论点是负有限,第二个论点是正无限,那么结果就是负零。</target>
        </trans-unit>
        <trans-unit id="e71c64d3bcd633902a2d641246fcfc98d2800c74" translate="yes" xml:space="preserve">
          <source>If the first argument is negative, the first element of the result is the ASCII minus character &lt;code&gt;'-'&lt;/code&gt; (&lt;code&gt;'\u002D'&lt;/code&gt;). If the first argument is not negative, no sign character appears in the result.</source>
          <target state="translated">如果第一个参数为负，则结果的第一个元素为ASCII减号 &lt;code&gt;'-'&lt;/code&gt; （ &lt;code&gt;'\u002D'&lt;/code&gt; ）。如果第一个参数不为负，则结果中不会出现符号字符。</target>
        </trans-unit>
        <trans-unit id="f757bab2a5b1e8678119d7c70a633d7f48cfbb1b" translate="yes" xml:space="preserve">
          <source>If the first argument is negative, the first element of the result is the ASCII minus sign &lt;code&gt;'-'&lt;/code&gt; (&lt;code&gt;'\u002d'&lt;/code&gt;). If the first argument is not negative, no sign character appears in the result.</source>
          <target state="translated">如果第一个参数为负，则结果的第一个元素为ASCII减号 &lt;code&gt;'-'&lt;/code&gt; （ &lt;code&gt;'\u002d'&lt;/code&gt; ）。如果第一个参数不为负，则结果中不会出现符号字符。</target>
        </trans-unit>
        <trans-unit id="be73a6c34da2b109aed6beaf3902ff7b8fa1d76b" translate="yes" xml:space="preserve">
          <source>If the first argument is positive and the second argument is positive zero or negative zero, or the first argument is positive infinity and the second argument is finite, then the result is the &lt;code&gt;double&lt;/code&gt; value closest to</source>
          <target state="translated">如果第一个参数为正，第二个参数为正零或负零，或者第一个参数为正无穷大，而第二个参数为有限，那么结果是最接近的 &lt;code&gt;double&lt;/code&gt; 值</target>
        </trans-unit>
        <trans-unit id="ebb6e09520d0766b54210b09e064a33ea2e4b570" translate="yes" xml:space="preserve">
          <source>If the first argument is positive infinity and the second argument is negative infinity, then the result is the &lt;code&gt;double&lt;/code&gt; value closest to 3*</source>
          <target state="translated">如果第一个参数为正无穷大，第二个参数为负无穷大，则结果是最接近3 * 的 &lt;code&gt;double&lt;/code&gt; 值</target>
        </trans-unit>
        <trans-unit id="a545d4a869ce0070ee3a2c5a7bd5c19feeb5e959" translate="yes" xml:space="preserve">
          <source>If the first argument is positive zero and the second argument is negative, or the first argument is positive and finite and the second argument is negative infinity, then the result is the &lt;code&gt;double&lt;/code&gt; value closest to</source>
          <target state="translated">如果第一个参数是正零，第二个参数是负的，或者第一参数是正的有限值，第二个参数是负无穷大，那么结果是 &lt;code&gt;double&lt;/code&gt; 最接近值</target>
        </trans-unit>
        <trans-unit id="2b99cd366559b0aa882f76d5433c550ae23a29d2" translate="yes" xml:space="preserve">
          <source>If the first argument is positive zero and the second argument is positive, or the first argument is positive and finite and the second argument is positive infinity, then the result is positive zero.</source>
          <target state="translated">如果第一个论点是正零,第二个论点是正数,或者第一个论点是正有限,第二个论点是正无穷,那么结果就是正零。</target>
        </trans-unit>
        <trans-unit id="90dbabf1b114fed471b1a3cd65fc77c1740f1756" translate="yes" xml:space="preserve">
          <source>If the first argument is zero, then a zero of the same sign is returned.</source>
          <target state="translated">如果第一个参数为零,则返回相同符号的零。</target>
        </trans-unit>
        <trans-unit id="a1663731875dc28dccca70ad4bb3ad9c2ee28bff" translate="yes" xml:space="preserve">
          <source>If the first byte of a group matches the bit pattern &lt;code&gt;0xxxxxxx&lt;/code&gt; (where &lt;code&gt;x&lt;/code&gt; means &quot;may be &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt;&quot;), then the group consists of just that byte. The byte is zero-extended to form a character.</source>
          <target state="translated">如果组的第一个字节与位模式 &lt;code&gt;0xxxxxxx&lt;/code&gt; 相匹配（其中 &lt;code&gt;x&lt;/code&gt; 表示&amp;ldquo;可能是 &lt;code&gt;0&lt;/code&gt; 或 &lt;code&gt;1&lt;/code&gt; &amp;rdquo;），则该组仅由该字节组成。字节零扩展以形成一个字符。</target>
        </trans-unit>
        <trans-unit id="43977f5f9b49b5f068ba277caf7c1c9b82cc82fa" translate="yes" xml:space="preserve">
          <source>If the first byte of a group matches the bit pattern &lt;code&gt;110xxxxx&lt;/code&gt;, then the group consists of that byte &lt;code&gt;a&lt;/code&gt; and a second byte &lt;code&gt;b&lt;/code&gt;. If there is no byte &lt;code&gt;b&lt;/code&gt; (because byte &lt;code&gt;a&lt;/code&gt; was the last of the bytes to be read), or if byte &lt;code&gt;b&lt;/code&gt; does not match the bit pattern &lt;code&gt;10xxxxxx&lt;/code&gt;, then a &lt;code&gt;UTFDataFormatException&lt;/code&gt; is thrown. Otherwise, the group is converted to the character:</source>
          <target state="translated">如果组的第一个字节与位模式 &lt;code&gt;110xxxxx&lt;/code&gt; 相匹配，则该组由该字节 &lt;code&gt;a&lt;/code&gt; 和第二个字节 &lt;code&gt;b&lt;/code&gt; 组成。如果没有字节 &lt;code&gt;b&lt;/code&gt; （因为字节 &lt;code&gt;a&lt;/code&gt; 是要读取的最后一个字节），或者如果字节 &lt;code&gt;b&lt;/code&gt; 与位模式 &lt;code&gt;10xxxxxx&lt;/code&gt; 不匹配，则抛出 &lt;code&gt;UTFDataFormatException&lt;/code&gt; 。否则，该组将转换为字符：</target>
        </trans-unit>
        <trans-unit id="d0e5e1a187c24e47368e1814e48c4f2e5999e848" translate="yes" xml:space="preserve">
          <source>If the first byte of a group matches the bit pattern &lt;code&gt;1110xxxx&lt;/code&gt;, then the group consists of that byte &lt;code&gt;a&lt;/code&gt; and two more bytes &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt;. If there is no byte &lt;code&gt;c&lt;/code&gt; (because byte &lt;code&gt;a&lt;/code&gt; was one of the last two of the bytes to be read), or either byte &lt;code&gt;b&lt;/code&gt; or byte &lt;code&gt;c&lt;/code&gt; does not match the bit pattern &lt;code&gt;10xxxxxx&lt;/code&gt;, then a &lt;code&gt;UTFDataFormatException&lt;/code&gt; is thrown. Otherwise, the group is converted to the character:</source>
          <target state="translated">如果组的第一个字节与位模式 &lt;code&gt;1110xxxx&lt;/code&gt; 相匹配，则该组由该字节 &lt;code&gt;a&lt;/code&gt; 和另外两个字节 &lt;code&gt;b&lt;/code&gt; 和 &lt;code&gt;c&lt;/code&gt; 组成。如果没有字节 &lt;code&gt;c&lt;/code&gt; （因为字节 &lt;code&gt;a&lt;/code&gt; 是要读取的最后两个字节之一），或者字节 &lt;code&gt;b&lt;/code&gt; 或字节 &lt;code&gt;c&lt;/code&gt; 与位模式 &lt;code&gt;10xxxxxx&lt;/code&gt; 不匹配，则抛出 &lt;code&gt;UTFDataFormatException&lt;/code&gt; 。否则，该组将转换为字符：</target>
        </trans-unit>
        <trans-unit id="4b4205a0b70ecc18a1f7d17bb4cefe1ef7847e2c" translate="yes" xml:space="preserve">
          <source>If the first byte of a group matches the pattern &lt;code&gt;1111xxxx&lt;/code&gt; or the pattern &lt;code&gt;10xxxxxx&lt;/code&gt;, then a &lt;code&gt;UTFDataFormatException&lt;/code&gt; is thrown.</source>
          <target state="translated">如果组的第一个字节与模式 &lt;code&gt;1111xxxx&lt;/code&gt; 或模式 &lt;code&gt;10xxxxxx&lt;/code&gt; 相匹配，则将引发 &lt;code&gt;UTFDataFormatException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fe4bd2bc924f289ce5e3e243830c506290c8bfa3" translate="yes" xml:space="preserve">
          <source>If the first character of &lt;code&gt;path&lt;/code&gt; is &lt;code&gt;'/'&lt;/code&gt; (indicating an absolute path name) this preference node's lock is dropped prior to breaking &lt;code&gt;path&lt;/code&gt; into tokens, and this method recursively traverses the path starting from the root (rather than starting from this node). The traversal is otherwise identical to the one described for relative path names. Dropping the lock on this node prior to commencing the traversal at the root node is essential to avoid the possibility of deadlock, as per the &lt;a href=&quot;abstractpreferences#lock&quot;&gt;&lt;code&gt;locking invariant&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;path&lt;/code&gt; 的第一个字符为 &lt;code&gt;'/'&lt;/code&gt; （表示绝对路径名），则在将 &lt;code&gt;path&lt;/code&gt; 分成令牌之前，将删除此首选项节点的锁，并且此方法以从根（而不是从该节点开始）的方式递归遍历该路径。遍历在其他方面与针对相对路径名描述的遍历相同。根据&lt;a href=&quot;abstractpreferences#lock&quot;&gt; &lt;code&gt;locking invariant&lt;/code&gt; &lt;/a&gt;，在根节点上开始遍历之前，在此节点上放下锁对于避免死锁的可能性至关重要。</target>
        </trans-unit>
        <trans-unit id="de6a756f5a999d243dc3d549609d91cce131f2d6" translate="yes" xml:space="preserve">
          <source>If the first letter of the property defined by a getter is a capital, then this handler will look first for an item in the &lt;code&gt;CompositeData&lt;/code&gt; beginning with a capital, then, if that is not found, for an item beginning with the corresponding lowercase letter or code point. For a getter called &lt;code&gt;getNumber()&lt;/code&gt;, the handler will first look for an item called &lt;code&gt;Number&lt;/code&gt;, then for &lt;code&gt;number&lt;/code&gt;. If the getter is called &lt;code&gt;getnumber()&lt;/code&gt;, then the item must be called &lt;code&gt;number&lt;/code&gt;.</source>
          <target state="translated">如果由吸气剂定义的属性的第一个字母为大写字母，则此处理程序将首先在 &lt;code&gt;CompositeData&lt;/code&gt; 中查找以大写字母开头的项，然后，如果找不到，则查找以相应的小写字母开头的项或代码点。对于名为 &lt;code&gt;getNumber()&lt;/code&gt; 的吸气剂，处理程序将首先查找名为 &lt;code&gt;Number&lt;/code&gt; 的项目，然后查找 &lt;code&gt;number&lt;/code&gt; 。如果将getter称为 &lt;code&gt;getnumber()&lt;/code&gt; ，则该项目必须称为 &lt;code&gt;number&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c5b9fdddf990174b0c1bb31fd056338ffdb9f842" translate="yes" xml:space="preserve">
          <source>If the flag argument is &lt;code&gt;false&lt;/code&gt;, then C++-style comments are not treated specially.</source>
          <target state="translated">如果flag参数为 &lt;code&gt;false&lt;/code&gt; ，则不特别对待C ++样式的注释。</target>
        </trans-unit>
        <trans-unit id="6b755352a37aefb0ddd22fcf4ddac56889ee380f" translate="yes" xml:space="preserve">
          <source>If the flag argument is &lt;code&gt;false&lt;/code&gt;, then C-style comments are not treated specially.</source>
          <target state="translated">如果flag参数为 &lt;code&gt;false&lt;/code&gt; ，则不对C样式的注释进行特殊处理。</target>
        </trans-unit>
        <trans-unit id="ed5b11ba23b450c90177463610accda7b5ef8311" translate="yes" xml:space="preserve">
          <source>If the flag argument is &lt;code&gt;false&lt;/code&gt;, then the &lt;code&gt;sval&lt;/code&gt; field is not modified.</source>
          <target state="translated">如果flag参数为 &lt;code&gt;false&lt;/code&gt; ，则不会修改 &lt;code&gt;sval&lt;/code&gt; 字段。</target>
        </trans-unit>
        <trans-unit id="a51b936e9c60259867a0c6a0a1415a7006e73bc6" translate="yes" xml:space="preserve">
          <source>If the flag is &lt;code&gt;false&lt;/code&gt;, delimiter characters serve to separate tokens. A token is a maximal sequence of consecutive characters that are not delimiters.</source>
          <target state="translated">如果该标志为 &lt;code&gt;false&lt;/code&gt; ，则分隔符用于分隔标记。令牌是不是定界符的连续字符的最大序列。</target>
        </trans-unit>
        <trans-unit id="243de70bc00db3702139f3dd218555f6b229e223" translate="yes" xml:space="preserve">
          <source>If the flag is &lt;code&gt;true&lt;/code&gt;, delimiter characters are themselves considered to be tokens. A token is thus either one delimiter character, or a maximal sequence of consecutive characters that are not delimiters.</source>
          <target state="translated">如果该标志为 &lt;code&gt;true&lt;/code&gt; ，则分隔符本身被视为标记。因此，令牌可以是一个分隔符，也可以是不是分隔符的最大连续字符序列。</target>
        </trans-unit>
        <trans-unit id="f77a5cbbfc5e7d2a5c0ad6a18e49115f1c49efaa" translate="yes" xml:space="preserve">
          <source>If the format of an argument loses information, such as with a choice format where a large number formats to &quot;many&quot;.</source>
          <target state="translated">如果一个论点的格式丢失了信息,比如选择格式,大数格式为 &quot;多&quot;。</target>
        </trans-unit>
        <trans-unit id="0dcd3261c6e6bc40c628cfcd3ed02c38b9a8ba09" translate="yes" xml:space="preserve">
          <source>If the format specifier contains a width or precision with an invalid value or which is otherwise unsupported, then a &lt;a href=&quot;illegalformatwidthexception&quot;&gt;&lt;code&gt;IllegalFormatWidthException&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;illegalformatprecisionexception&quot;&gt;&lt;code&gt;IllegalFormatPrecisionException&lt;/code&gt;&lt;/a&gt; respectively will be thrown.</source>
          <target state="translated">如果格式说明符包含具有无效值的宽度或精度，或者否则不支持该宽度或精度，&lt;a href=&quot;illegalformatprecisionexception&quot;&gt; &lt;code&gt;IllegalFormatPrecisionException&lt;/code&gt; &lt;/a&gt;分别抛出&lt;a href=&quot;illegalformatwidthexception&quot;&gt; &lt;code&gt;IllegalFormatWidthException&lt;/code&gt; &lt;/a&gt;或IllegalFormatPrecisionException。</target>
        </trans-unit>
        <trans-unit id="23d86bd64d57a83827a905eb3f62752e01b0a38e" translate="yes" xml:space="preserve">
          <source>If the formatter parses the same field more than once with different values, the result will be an error.</source>
          <target state="translated">如果格式化器多次用不同的值解析同一个字段,结果将是一个错误。</target>
        </trans-unit>
        <trans-unit id="db3731fc2aa4a3e087228df78b6ed03888b9aa5c" translate="yes" xml:space="preserve">
          <source>If the function returns &lt;code&gt;null&lt;/code&gt; no mapping is recorded. If the function itself throws an (unchecked) exception, the exception is rethrown, and no mapping is recorded. The most common usage is to construct a new object serving as an initial mapped value or memoized result, as in:</source>
          <target state="translated">如果函数返回 &lt;code&gt;null&lt;/code&gt; ,则不会记录任何映射。如果函数本身引发（未经检查的）异常，则重新引发该异常，并且不记录任何映射。最常见的用法是构造一个新对象，用作初始映射值或备注结果，如下所示：</target>
        </trans-unit>
        <trans-unit id="144af7e618eb46c9529d1d33c26d53810f2167da" translate="yes" xml:space="preserve">
          <source>If the function returns &lt;code&gt;null&lt;/code&gt; the mapping is removed. If the function itself throws an (unchecked) exception, the exception is rethrown, and the current mapping is left unchanged.</source>
          <target state="translated">如果函数返回 &lt;code&gt;null&lt;/code&gt; ，则删除映射。如果函数本身抛出（未经检查的）异常，则重新引发该异常，并且当前映射保持不变。</target>
        </trans-unit>
        <trans-unit id="26f473bb6caf3da04b1285866c6a28b1b984ef5f" translate="yes" xml:space="preserve">
          <source>If the function returns &lt;code&gt;null&lt;/code&gt;, the mapping is removed (or remains absent if initially absent). If the function itself throws an (unchecked) exception, the exception is rethrown, and the current mapping is left unchanged.</source>
          <target state="translated">如果函数返回 &lt;code&gt;null&lt;/code&gt; ，则删除映射（如果最初不存在，则保持不存在）。如果函数本身抛出（未经检查的）异常，则重新引发该异常，并且当前映射保持不变。</target>
        </trans-unit>
        <trans-unit id="91e50d7000baf56cbe84741a636dedc280c25287" translate="yes" xml:space="preserve">
          <source>If the function returns &lt;code&gt;null&lt;/code&gt;, the mapping is removed. If the function itself throws an (unchecked) exception, the exception is rethrown, and the current mapping is left unchanged.</source>
          <target state="translated">如果函数返回 &lt;code&gt;null&lt;/code&gt; ，则删除映射。如果函数本身抛出（未经检查的）异常，则重新引发该异常，并且当前映射保持不变。</target>
        </trans-unit>
        <trans-unit id="926782c512e4f063b419e0421193c8c7a7433138" translate="yes" xml:space="preserve">
          <source>If the function succeeds, instrument &lt;code&gt;from&lt;/code&gt; is unloaded.</source>
          <target state="translated">如果功能成功，仪器 &lt;code&gt;from&lt;/code&gt; 被卸载。</target>
        </trans-unit>
        <trans-unit id="32a91e07ee88bec0b9954a59c4de099b9aa8f328" translate="yes" xml:space="preserve">
          <source>If the garbage collector determines at a certain point in time that the referent of a phantom reference is &lt;a href=&quot;package-summary#reachability&quot;&gt;phantom reachable&lt;/a&gt;, then at that time or at some later time it will enqueue the reference.</source>
          <target state="translated">如果垃圾收集器在某个时间点确定幻像引用的参照对象是&lt;a href=&quot;package-summary#reachability&quot;&gt;幻像可到达的&lt;/a&gt;，则在那个时候或以后的某个时间，它将使该引用入队。</target>
        </trans-unit>
        <trans-unit id="53adf0e26e84566de9caa7cabb62afdabd38f865" translate="yes" xml:space="preserve">
          <source>If the gauge difference mode is used, the value of the derived gauge is calculated as the difference between the observed gauge values for two successive observations.</source>
          <target state="translated">如果采用轨距差模式,则推导的轨距值按连续两次观测的轨距值之差计算。</target>
        </trans-unit>
        <trans-unit id="f36edc06d9e8ab3918e6499129015f8c141e7e54" translate="yes" xml:space="preserve">
          <source>If the generator function throws an exception, an unchecked exception is thrown from &lt;code&gt;parallelSetAll&lt;/code&gt; and the array is left in an indeterminate state.</source>
          <target state="translated">如果生成器函数引发异常，则会从 &lt;code&gt;parallelSetAll&lt;/code&gt; 引发未经检查的异常，并且数组将处于不确定状态。</target>
        </trans-unit>
        <trans-unit id="9d8173ed15e9b7709fd7094f05762f38b139637d" translate="yes" xml:space="preserve">
          <source>If the generator function throws an exception, it is relayed to the caller and the array is left in an indeterminate state.</source>
          <target state="translated">如果生成函数抛出异常,就会被转达给调用者,数组就会处于不确定的状态。</target>
        </trans-unit>
        <trans-unit id="0e16e73e1c388c5bcfaf11ed9189d8791a0ccfd7" translate="yes" xml:space="preserve">
          <source>If the given &lt;var&gt;inModelMBeanInfo&lt;/var&gt; does not contain any &lt;a href=&quot;modelmbeannotificationinfo&quot;&gt;&lt;code&gt;ModelMBeanNotificationInfo&lt;/code&gt;&lt;/a&gt; for the &lt;code&gt;GENERIC&lt;/code&gt; or &lt;code&gt;ATTRIBUTE_CHANGE&lt;/code&gt; notifications, then the RequiredModelMBean will supply its own default &lt;a href=&quot;modelmbeannotificationinfo&quot;&gt;&lt;code&gt;ModelMBeanNotificationInfo&lt;/code&gt;&lt;/a&gt;s for those missing notifications.</source>
          <target state="translated">如果给定的 &lt;var&gt;inModelMBeanInfo&lt;/var&gt; 不包含用于 &lt;code&gt;GENERIC&lt;/code&gt; 或 &lt;code&gt;ATTRIBUTE_CHANGE&lt;/code&gt; 通知的任何&lt;a href=&quot;modelmbeannotificationinfo&quot;&gt; &lt;code&gt;ModelMBeanNotificationInfo&lt;/code&gt; &lt;/a&gt;，则RequiredModelMBean将为那些缺少的通知提供其自己的默认&lt;a href=&quot;modelmbeannotificationinfo&quot;&gt; &lt;code&gt;ModelMBeanNotificationInfo&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="871cb4309703aec2bc0023c758d9cf428cebc74f" translate="yes" xml:space="preserve">
          <source>If the given URI has an authority component then the new URI's authority and path are taken from the given URI.</source>
          <target state="translated">如果给定的URI有一个权限组件,那么新的URI的权限和路径就会从给定的URI中获取。</target>
        </trans-unit>
        <trans-unit id="e06d94bd934ab4eadeb7ce0dca1e7e7222d58665" translate="yes" xml:space="preserve">
          <source>If the given URI is already absolute, or if this URI is opaque, then the given URI is returned.</source>
          <target state="translated">如果给定的URI已经是绝对的,或者这个URI是不透明的,那么将返回给定的URI。</target>
        </trans-unit>
        <trans-unit id="2430c525f00d8a5ecee224a7a5b81e9aae39e412" translate="yes" xml:space="preserve">
          <source>If the given URI's fragment component is defined, its path component is empty, and its scheme, authority, and query components are undefined, then a URI with the given fragment but with all other components equal to those of this URI is returned. This allows a URI representing a standalone fragment reference, such as &lt;code id=&quot;resolve-frag&quot;&gt;&quot;#foo&quot;&lt;/code&gt;, to be usefully resolved against a base URI.</source>
          <target state="translated">如果定义了给定URI的片段组件，其路径组件为空，并且其方案，权限和查询组件未定义，则返回具有给定片段但所有其他组件与此URI相等的URI。这使代表独立片段引用的URI（例如 &lt;code id=&quot;resolve-frag&quot;&gt;&quot;#foo&quot;&lt;/code&gt; ）可以有效地针对基本URI进行解析。</target>
        </trans-unit>
        <trans-unit id="c849fb5cce341a58fea462c01a105441e0cc9602" translate="yes" xml:space="preserve">
          <source>If the given URI's path is absolute then the new URI's path is taken from the given URI.</source>
          <target state="translated">如果给定的URI的路径是绝对的,那么新的URI的路径就取自给定的URI。</target>
        </trans-unit>
        <trans-unit id="14f7899ffb21b582de61406576d434576cfac581" translate="yes" xml:space="preserve">
          <source>If the given address includes a JNDI directory URL as specified in the package documentation for &lt;a href=&quot;package-summary&quot;&gt;&lt;code&gt;javax.management.remote.rmi&lt;/code&gt;&lt;/a&gt;, then this &lt;code&gt;RMIConnectorServer&lt;/code&gt; will bootstrap by binding the &lt;code&gt;RMIServerImpl&lt;/code&gt; to the given address.</source>
          <target state="translated">如果给定地址包括&lt;a href=&quot;package-summary&quot;&gt; &lt;code&gt;javax.management.remote.rmi&lt;/code&gt; &lt;/a&gt;软件包文档中指定的JNDI目录URL ，则此 &lt;code&gt;RMIConnectorServer&lt;/code&gt; 将通过将 &lt;code&gt;RMIServerImpl&lt;/code&gt; 绑定到给定地址来进行引导。</target>
        </trans-unit>
        <trans-unit id="ca814afbdb188e0d8eb604c68dacd59c7bf69539" translate="yes" xml:space="preserve">
          <source>If the given alias already exists, the keystore information associated with it is overridden by the given key (and possibly certificate chain).</source>
          <target state="translated">如果给定的别名已经存在,那么与之相关的密钥存储信息就会被给定的密钥(可能还有证书链)覆盖。</target>
        </trans-unit>
        <trans-unit id="3a595a56aadbb88b4114693edc5c1ee01ec9f96d" translate="yes" xml:space="preserve">
          <source>If the given alias identifies an existing entry created by a call to &lt;code&gt;setCertificateEntry&lt;/code&gt;, or created by a call to &lt;code&gt;setEntry&lt;/code&gt; with a &lt;code&gt;TrustedCertificateEntry&lt;/code&gt;, the trusted certificate in the existing entry is overridden by the given certificate.</source>
          <target state="translated">如果给定的别名标识通过调用创建现有条目 &lt;code&gt;setCertificateEntry&lt;/code&gt; ，或通过向调用创建 &lt;code&gt;setEntry&lt;/code&gt; 与 &lt;code&gt;TrustedCertificateEntry&lt;/code&gt; ，在现有条目中的可信证书被给定证书重写。</target>
        </trans-unit>
        <trans-unit id="5db25da879a6c8a2469a9ffa221b439cce428d7c" translate="yes" xml:space="preserve">
          <source>If the given alias name identifies an entry created by a call to &lt;code&gt;setCertificateEntry&lt;/code&gt;, or created by a call to &lt;code&gt;setEntry&lt;/code&gt; with a &lt;code&gt;TrustedCertificateEntry&lt;/code&gt;, then the trusted certificate contained in that entry is returned.</source>
          <target state="translated">如果给定的别名标识通过调用创建一个条目 &lt;code&gt;setCertificateEntry&lt;/code&gt; ，或通过向调用创建 &lt;code&gt;setEntry&lt;/code&gt; 与 &lt;code&gt;TrustedCertificateEntry&lt;/code&gt; ，则受信任的证书中包含的条目返回。</target>
        </trans-unit>
        <trans-unit id="4d4d7d88c3b4df9575339dccffaf79058f1c8930" translate="yes" xml:space="preserve">
          <source>If the given alias name identifies an entry created by a call to &lt;code&gt;setKeyEntry&lt;/code&gt;, or created by a call to &lt;code&gt;setEntry&lt;/code&gt; with a &lt;code&gt;PrivateKeyEntry&lt;/code&gt;, then the first element of the certificate chain in that entry (if a chain exists) is returned.</source>
          <target state="translated">如果给定别名标识了通过调用 &lt;code&gt;setKeyEntry&lt;/code&gt; 创建的条目，或通过调用带有 &lt;code&gt;PrivateKeyEntry&lt;/code&gt; 的 &lt;code&gt;setEntry&lt;/code&gt; 创建的条目，则将返回该条目中证书链的第一个元素（如果存在链）。</target>
        </trans-unit>
        <trans-unit id="c2ed3e7db9906e449ddb9d356b3252474de4e64c" translate="yes" xml:space="preserve">
          <source>If the given alias name identifies an entry created by a call to &lt;code&gt;setKeyEntry&lt;/code&gt;, or created by a call to &lt;code&gt;setEntry&lt;/code&gt; with a &lt;code&gt;PrivateKeyEntry&lt;/code&gt;, then the first element of the certificate chain in that entry is returned.</source>
          <target state="translated">如果给定的别名标识了通过调用 &lt;code&gt;setKeyEntry&lt;/code&gt; 创建的条目，或通过调用带有 &lt;code&gt;PrivateKeyEntry&lt;/code&gt; 的 &lt;code&gt;setEntry&lt;/code&gt; 创建的条目，则返回该条目中证书链的第一个元素。</target>
        </trans-unit>
        <trans-unit id="a7044af5535fc0b80bc9e6eb2af416837a93528e" translate="yes" xml:space="preserve">
          <source>If the given blocking mode is different from the current blocking mode then this method invokes the &lt;a href=&quot;abstractselectablechannel#implConfigureBlocking-boolean-&quot;&gt;&lt;code&gt;implConfigureBlocking&lt;/code&gt;&lt;/a&gt; method, while holding the appropriate locks, in order to change the mode.</source>
          <target state="translated">如果给定的阻止模式不同于当前的阻止模式，则此方法在保持适当的锁的同时调用&lt;a href=&quot;abstractselectablechannel#implConfigureBlocking-boolean-&quot;&gt; &lt;code&gt;implConfigureBlocking&lt;/code&gt; &lt;/a&gt;方法，以更改模式。</target>
        </trans-unit>
        <trans-unit id="ef47fccc5a72a56e061d58ffbc98135bb15f0e3b" translate="yes" xml:space="preserve">
          <source>If the given key is of type &lt;code&gt;java.security.PrivateKey&lt;/code&gt;, it must be accompanied by a certificate chain certifying the corresponding public key.</source>
          <target state="translated">如果给定密钥的类型为 &lt;code&gt;java.security.PrivateKey&lt;/code&gt; ，则必须随附一个证书链，以证明相应的公共密钥。</target>
        </trans-unit>
        <trans-unit id="fd6f94d655e9cba018e02791b4d2bafeaf0cd16b" translate="yes" xml:space="preserve">
          <source>If the given locale is equal to &lt;code&gt;Locale.ROOT&lt;/code&gt; (the root locale), a &lt;code&gt;List&lt;/code&gt; containing only the root &lt;code&gt;Locale&lt;/code&gt; must be returned. In this case, the &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; factory method loads only the base bundle as the resulting resource bundle.</source>
          <target state="translated">如果给定的区域设置为等于 &lt;code&gt;Locale.ROOT&lt;/code&gt; （根区域），一个 &lt;code&gt;List&lt;/code&gt; 仅包含根 &lt;code&gt;Locale&lt;/code&gt; 必须返回。在这种情况下， &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; 工厂方法仅加载基本捆绑包作为结果资源捆绑包。</target>
        </trans-unit>
        <trans-unit id="a722054d6a8a85985b6af9a7f074ff6c9d6c5114" translate="yes" xml:space="preserve">
          <source>If the given method to be invoked, together with the provided signature, matches one of RequiredModelMbean accessible methods, this one will be call. Otherwise the call to the given method will be tried on the managed resource.</source>
          <target state="translated">如果要调用的方法以及提供的签名与所需ModelMbean可访问的方法之一相匹配,那么这个方法将被调用。否则,对给定方法的调用将在被管理资源上进行尝试。</target>
        </trans-unit>
        <trans-unit id="a79eac791e4b86cfc10aabf01a42570af6907767" translate="yes" xml:space="preserve">
          <source>If the given object is not a Path, or is a Path associated with a different &lt;code&gt;FileSystem&lt;/code&gt;, then this method returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果给定的对象不是Path或与另一个 &lt;code&gt;FileSystem&lt;/code&gt; 关联的Path ，则此方法返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ab44b435bce5e6d0dd0d4400904c04dd1b50093c" translate="yes" xml:space="preserve">
          <source>If the given object is not a URI then this method immediately returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果给定的对象不是URI，则此方法立即返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dab849a2dfb627f012f49b202b71d39af39c2224" translate="yes" xml:space="preserve">
          <source>If the given object is not a URL then this method immediately returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果给定的对象不是URL，则此方法立即返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="51317f50e868ccac84e6251d8aade86da12219ac" translate="yes" xml:space="preserve">
          <source>If the given object is not an &lt;code&gt;AclEntry&lt;/code&gt; then this method immediately returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果给定的对象不是 &lt;code&gt;AclEntry&lt;/code&gt; ,则此方法立即返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5067d1933a7fb6de041c489427ed9f038cbf2e5d" translate="yes" xml:space="preserve">
          <source>If the given path has &lt;em&gt;N&lt;/em&gt; elements, and no root component, and this path has &lt;em&gt;N&lt;/em&gt; or more elements, then this path ends with the given path if the last &lt;em&gt;N&lt;/em&gt; elements of each path, starting at the element farthest from the root, are equal.</source>
          <target state="translated">如果给定路径具有&lt;em&gt;N个&lt;/em&gt;元素，并且没有根成分，并且此路径具有&lt;em&gt;N个&lt;/em&gt;或多个元素，则如果每个路径的最后&lt;em&gt;N个&lt;/em&gt;元素（从距离根最远的元素开始）相等，则此路径以给定路径结尾。</target>
        </trans-unit>
        <trans-unit id="fe7eaf75c5ca09e9dc37afa7038d8c228c398461" translate="yes" xml:space="preserve">
          <source>If the given path has a root component then this path ends with the given path if the root component of this path &lt;em&gt;ends with&lt;/em&gt; the root component of the given path, and the corresponding elements of both paths are equal. Whether or not the root component of this path ends with the root component of the given path is file system specific. If this path does not have a root component and the given path has a root component then this path does not end with the given path.</source>
          <target state="translated">如果给定路径具有根成分，则此路径以给定路径结束，如果该路径的根成分以给定路径的根成分&lt;em&gt;结束&lt;/em&gt;，并且两个路径的相应元素相等。此路径的根组件是否以给定路径的根组件结尾是特定于文件系统的。如果此路径没有根组件，并且给定路径具有根组件，则该路径不会以给定路径结尾。</target>
        </trans-unit>
        <trans-unit id="6fdc1f0bd8bdd66110dc3f031d4817dcf3caed63" translate="yes" xml:space="preserve">
          <source>If the given path is associated with a different &lt;code&gt;FileSystem&lt;/code&gt; to this path then &lt;code&gt;false&lt;/code&gt; is returned.</source>
          <target state="translated">如果给定路径与与此路径不同的 &lt;code&gt;FileSystem&lt;/code&gt; 关联，则返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4b2bf60e5452de4ddf9870cafed442c49431cf97" translate="yes" xml:space="preserve">
          <source>If the given provider is installed at the requested position, the provider that used to be at that position, and all providers with a position greater than &lt;code&gt;position&lt;/code&gt;, are shifted up one position (towards the end of the list of installed providers).</source>
          <target state="translated">如果给定提供程序安装在请求的位置，则以前位于该位置的提供程序以及位置大于 &lt;code&gt;position&lt;/code&gt; 的所有提供程序都将上移一个位置（朝已安装的提供程序列表的末尾移动）。</target>
        </trans-unit>
        <trans-unit id="be7b3561a355e78f18cdeae419abf0ee5e2ea933" translate="yes" xml:space="preserve">
          <source>If the given size is less than the current size then the entity is truncated, discarding any bytes beyond the new end. If the given size is greater than or equal to the current size then the entity is not modified. In either case, if the current position is greater than the given size then it is set to that size.</source>
          <target state="translated">如果给定的大小小于当前大小,那么实体将被截断,丢弃超出新末端的任何字节。如果给定的大小大于或等于当前的大小,那么实体不会被修改。在这两种情况下,如果当前位置大于给定的大小,则将其设置为该大小。</target>
        </trans-unit>
        <trans-unit id="aaefbc3d9c612129c52e3733260c322198b61ac6" translate="yes" xml:space="preserve">
          <source>If the given size is less than the file's current size then the file is truncated, discarding any bytes beyond the new end of the file. If the given size is greater than or equal to the file's current size then the file is not modified.</source>
          <target state="translated">如果给定的大小小于文件的当前大小,那么文件将被截断,丢弃超出文件新末端的任何字节。如果给定的大小大于或等于文件的当前大小,那么文件将不被修改。</target>
        </trans-unit>
        <trans-unit id="87ded65bf156680a79571d8a9d909a68f908630c" translate="yes" xml:space="preserve">
          <source>If the given size is less than the file's current size then the file is truncated, discarding any bytes beyond the new end of the file. If the given size is greater than or equal to the file's current size then the file is not modified. In either case, if this channel's file position is greater than the given size then it is set to that size.</source>
          <target state="translated">如果给定的大小小于文件的当前大小,那么文件将被截断,丢弃超出文件新末端的任何字节。如果给定的大小大于或等于文件的当前大小,那么文件不会被修改。在这两种情况下,如果这个通道的文件位置大于给定的大小,那么它就被设置为该大小。</target>
        </trans-unit>
        <trans-unit id="f0b0bf2a45ec36e583f47ca33513286c575ec604" translate="yes" xml:space="preserve">
          <source>If the handler is not null and there is a security manager, the security manager's &lt;code&gt;checkPermission&lt;/code&gt; method is called with a &lt;code&gt;NetPermission(&quot;specifyStreamHandler&quot;)&lt;/code&gt; permission. This may result in a SecurityException. No validation of the inputs is performed by this constructor.</source>
          <target state="translated">如果处理程序不为null且存在安全管理器，则使用 &lt;code&gt;NetPermission(&quot;specifyStreamHandler&quot;)&lt;/code&gt; 权限调用安全管理器的 &lt;code&gt;checkPermission&lt;/code&gt; 方法。这可能会导致SecurityException。此构造函数不执行输入验证。</target>
        </trans-unit>
        <trans-unit id="82294cea404b457d7895b5f7849b8f8cdabef00b" translate="yes" xml:space="preserve">
          <source>If the host is &lt;code&gt;null&lt;/code&gt; then an &lt;code&gt;InetAddress&lt;/code&gt; representing an address of the loopback interface is returned. See &lt;a href=&quot;http://www.ietf.org/rfc/rfc3330.txt&quot;&gt;RFC 3330&lt;/a&gt; section 2 and &lt;a href=&quot;http://www.ietf.org/rfc/rfc2373.txt&quot;&gt;RFC 2373&lt;/a&gt; section 2.5.3.</source>
          <target state="translated">如果主机为 &lt;code&gt;null&lt;/code&gt; ,则返回代表Loopback接口地址的 &lt;code&gt;InetAddress&lt;/code&gt; 。请参阅&lt;a href=&quot;http://www.ietf.org/rfc/rfc3330.txt&quot;&gt;RFC 3330&lt;/a&gt;第2节和&lt;a href=&quot;http://www.ietf.org/rfc/rfc2373.txt&quot;&gt;RFC 2373&lt;/a&gt;第2.5.3节。</target>
        </trans-unit>
        <trans-unit id="9c743eca5b6b4b9d617040308e1ee27a4b7c6393" translate="yes" xml:space="preserve">
          <source>If the identity is marked as &quot;trusted&quot;, this allows an attacker to introduce a different public key (e.g., its own) that is not trusted by the system's identity scope, thereby granting applet or application code signed with that public key privileges that would have been denied otherwise.</source>
          <target state="translated">如果身份被标记为 &quot;受信任&quot;,这就允许攻击者引入不同的公钥(如自己的公钥),该公钥不受系统身份范围的信任,从而给予用该公钥签名的小程序或应用程序代码以特权,否则就会被拒绝。</target>
        </trans-unit>
        <trans-unit id="75b8821b16ad8c4bce7f71ae9f2499e34e968953" translate="yes" xml:space="preserve">
          <source>If the image can be rendered to a user-specified size, then this method returns the default height.</source>
          <target state="translated">如果图像可以渲染成用户指定的大小,那么本方法返回默认高度。</target>
        </trans-unit>
        <trans-unit id="d4a58cc703a9db33b11b3faf9dca4d8e83b20a1f" translate="yes" xml:space="preserve">
          <source>If the image can be rendered to a user-specified size, then this method returns the default width.</source>
          <target state="translated">如果图像可以渲染成用户指定的大小,那么本方法返回默认宽度。</target>
        </trans-unit>
        <trans-unit id="1e4e52ec311e9e75dd4cc081567f1eae9e6bf20f" translate="yes" xml:space="preserve">
          <source>If the image is able to be rendered at an arbitrary size, sets the source width and height to the supplied values. Note that the values returned from the &lt;code&gt;getWidth&lt;/code&gt; and &lt;code&gt;getHeight&lt;/code&gt; methods on &lt;code&gt;ImageReader&lt;/code&gt; are not affected by this method; they will continue to return the default size for the image. Similarly, if the image is also tiled the tile width and height are given in terms of the default size.</source>
          <target state="translated">如果能够以任意大小渲染图像，请将源的宽度和高度设置为提供的值。请注意，从 &lt;code&gt;ImageReader&lt;/code&gt; 的 &lt;code&gt;getWidth&lt;/code&gt; 和 &lt;code&gt;getHeight&lt;/code&gt; 方法返回的值不受此方法的影响；他们将继续返回图像的默认尺寸。类似地，如果图像也被平铺，则以默认大小给出平铺的宽度和高度。</target>
        </trans-unit>
        <trans-unit id="d7ce886e7cf517b9dd1b8e4bf3972fb87acfaf11" translate="yes" xml:space="preserve">
          <source>If the implementation can supply a value for one of the queries listed in the if statement of the default implementation, then it must do so. For example, an application-defined &lt;code&gt;HourMin&lt;/code&gt; class storing the hour and minute must override this method as follows:</source>
          <target state="translated">如果实现可以为默认实现的if语句中列出的查询之一提供值，则必须这样做。例如，应用程序定义的存储小时和分钟的 &lt;code&gt;HourMin&lt;/code&gt; 类必须重写此方法，如下所示：</target>
        </trans-unit>
        <trans-unit id="8ab19508e52ba992a5a553d39a65472031820996" translate="yes" xml:space="preserve">
          <source>If the implementation of this class does not support persistence, an &lt;a href=&quot;../mbeanexception&quot;&gt;&lt;code&gt;MBeanException&lt;/code&gt;&lt;/a&gt; wrapping a &lt;a href=&quot;../servicenotfoundexception&quot;&gt;&lt;code&gt;ServiceNotFoundException&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">如果此类的实现不支持持久性，&lt;a href=&quot;../mbeanexception&quot;&gt; &lt;code&gt;MBeanException&lt;/code&gt; &lt;/a&gt;包装&lt;a href=&quot;../servicenotfoundexception&quot;&gt; &lt;code&gt;ServiceNotFoundException&lt;/code&gt; &lt;/a&gt;的MBeanException。</target>
        </trans-unit>
        <trans-unit id="61497ea0a67eb203673d203a0f2b5369b019bf33" translate="yes" xml:space="preserve">
          <source>If the implementation of this method throws a &lt;a href=&quot;../../../java/lang/runtimeexception&quot;&gt;&lt;code&gt;RuntimeException&lt;/code&gt;&lt;/a&gt; or an &lt;a href=&quot;../../../java/lang/error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt;, the MBean Server will rethrow those inside a &lt;a href=&quot;../runtimembeanexception&quot;&gt;&lt;code&gt;RuntimeMBeanException&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../runtimeerrorexception&quot;&gt;&lt;code&gt;RuntimeErrorException&lt;/code&gt;&lt;/a&gt;, respectively. However, throwing an exception in &lt;code&gt;postDeregister&lt;/code&gt; will not change the state of the MBean: the MBean was already successfully deregistered and will remain so.</source>
          <target state="translated">如果此方法的实现引发&lt;a href=&quot;../../../java/lang/runtimeexception&quot;&gt; &lt;code&gt;RuntimeException&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../../../java/lang/error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt;，则MBean服务器将分别将它们分别抛出&lt;a href=&quot;../runtimembeanexception&quot;&gt; &lt;code&gt;RuntimeMBeanException&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../runtimeerrorexception&quot;&gt; &lt;code&gt;RuntimeErrorException&lt;/code&gt; &lt;/a&gt;。但是，在 &lt;code&gt;postDeregister&lt;/code&gt; 中引发异常不会更改MBean的状态：MBean已成功注销，并将保持这种状态。</target>
        </trans-unit>
        <trans-unit id="b96b5c5ec491812d30a354e2cb6f11721b2e2b1d" translate="yes" xml:space="preserve">
          <source>If the implementation of this method throws a &lt;a href=&quot;../../../java/lang/runtimeexception&quot;&gt;&lt;code&gt;RuntimeException&lt;/code&gt;&lt;/a&gt; or an &lt;a href=&quot;../../../java/lang/error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt;, the MBean Server will rethrow those inside a &lt;a href=&quot;../runtimembeanexception&quot;&gt;&lt;code&gt;RuntimeMBeanException&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../runtimeerrorexception&quot;&gt;&lt;code&gt;RuntimeErrorException&lt;/code&gt;&lt;/a&gt;, respectively. However, throwing an exception in &lt;code&gt;postRegister&lt;/code&gt; will not change the state of the MBean: if the MBean was already registered (&lt;code&gt;registrationDone&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;), the MBean will remain registered.</source>
          <target state="translated">如果此方法的实现引发&lt;a href=&quot;../../../java/lang/runtimeexception&quot;&gt; &lt;code&gt;RuntimeException&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../../../java/lang/error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt;，则MBean服务器将分别将它们分别抛出&lt;a href=&quot;../runtimembeanexception&quot;&gt; &lt;code&gt;RuntimeMBeanException&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../runtimeerrorexception&quot;&gt; &lt;code&gt;RuntimeErrorException&lt;/code&gt; &lt;/a&gt;。但是，在 &lt;code&gt;postRegister&lt;/code&gt; 中引发异常不会更改MBean的状态：如果已经注册了MBean（ &lt;code&gt;registrationDone&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ），则MBean将保持注册状态。</target>
        </trans-unit>
        <trans-unit id="4535342913d52819782cb269ae901b36379460f0" translate="yes" xml:space="preserve">
          <source>If the implementation of this method throws a &lt;a href=&quot;../../java/lang/runtimeexception&quot;&gt;&lt;code&gt;RuntimeException&lt;/code&gt;&lt;/a&gt; or an &lt;a href=&quot;../../java/lang/error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt;, the MBean Server will rethrow those inside a &lt;a href=&quot;runtimembeanexception&quot;&gt;&lt;code&gt;RuntimeMBeanException&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;runtimeerrorexception&quot;&gt;&lt;code&gt;RuntimeErrorException&lt;/code&gt;&lt;/a&gt;, respectively. However, throwing an exception in &lt;code&gt;postDeregister&lt;/code&gt; will not change the state of the MBean: the MBean was already successfully deregistered and will remain so.</source>
          <target state="translated">如果此方法的实现引发&lt;a href=&quot;../../java/lang/runtimeexception&quot;&gt; &lt;code&gt;RuntimeException&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../../java/lang/error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt;，则MBean服务器将分别将它们分别抛出&lt;a href=&quot;runtimembeanexception&quot;&gt; &lt;code&gt;RuntimeMBeanException&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;runtimeerrorexception&quot;&gt; &lt;code&gt;RuntimeErrorException&lt;/code&gt; &lt;/a&gt;。但是，在 &lt;code&gt;postDeregister&lt;/code&gt; 中引发异常不会更改MBean的状态：MBean已成功注销，并将保持这种状态。</target>
        </trans-unit>
        <trans-unit id="76763841aca1fa1b12ea5b878cc85e9f7cde9edb" translate="yes" xml:space="preserve">
          <source>If the implementation of this method throws a &lt;a href=&quot;../../java/lang/runtimeexception&quot;&gt;&lt;code&gt;RuntimeException&lt;/code&gt;&lt;/a&gt; or an &lt;a href=&quot;../../java/lang/error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt;, the MBean Server will rethrow those inside a &lt;a href=&quot;runtimembeanexception&quot;&gt;&lt;code&gt;RuntimeMBeanException&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;runtimeerrorexception&quot;&gt;&lt;code&gt;RuntimeErrorException&lt;/code&gt;&lt;/a&gt;, respectively. However, throwing an exception in &lt;code&gt;postRegister&lt;/code&gt; will not change the state of the MBean: if the MBean was already registered (&lt;code&gt;registrationDone&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;), the MBean will remain registered.</source>
          <target state="translated">如果此方法的实现引发&lt;a href=&quot;../../java/lang/runtimeexception&quot;&gt; &lt;code&gt;RuntimeException&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../../java/lang/error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt;，则MBean服务器将分别将它们分别抛出&lt;a href=&quot;runtimembeanexception&quot;&gt; &lt;code&gt;RuntimeMBeanException&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;runtimeerrorexception&quot;&gt; &lt;code&gt;RuntimeErrorException&lt;/code&gt; &lt;/a&gt;。但是，在 &lt;code&gt;postRegister&lt;/code&gt; 中引发异常不会更改MBean的状态：如果已经注册了MBean（ &lt;code&gt;registrationDone&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ），则MBean将保持注册状态。</target>
        </trans-unit>
        <trans-unit id="e5a527012aa1181404e26ff9eba79c5215c6617c" translate="yes" xml:space="preserve">
          <source>If the implementation requires some measurable time to cancel the job in the PROCESSING or PROCESSING_STOPPED job states, the printer must use this reason to indicate that the printer is still performing some actions on the job while the job remains in the PROCESSING or PROCESSING_STOPPED state. After all the job's job description attributes have stopped incrementing, the printer moves the job from the PROCESSING state to the CANCELED or ABORTED job states.</source>
          <target state="translated">如果执行需要一些可衡量的时间来取消处于PROCESSING或PROCESSING_STOPPED作业状态下的作业,打印机必须使用这个理由来表明,当作业处于PROCESSING或PROCESSING_STOPPED状态时,打印机仍在对作业执行一些操作。当作业的所有作业描述属性停止递增后,打印机将作业从PROCESSING状态移至CANCELED或ABORTED作业状态。</target>
        </trans-unit>
        <trans-unit id="21a96789298a278046ce067991e2d31d04c7cbd4" translate="yes" xml:space="preserve">
          <source>If the implementation supports</source>
          <target state="translated">如果实施支持</target>
        </trans-unit>
        <trans-unit id="35f873dd7c2035b38202cda19f7fef9dd8dbdb3b" translate="yes" xml:space="preserve">
          <source>If the implementing method determines that no transformations are needed, it should return &lt;code&gt;null&lt;/code&gt;. Otherwise, it should create a new &lt;code&gt;byte[]&lt;/code&gt; array, copy the input &lt;code&gt;classfileBuffer&lt;/code&gt; into it, along with all desired transformations, and return the new array. The input &lt;code&gt;classfileBuffer&lt;/code&gt; must not be modified.</source>
          <target state="translated">如果实现方法确定不需要任何转换，则应返回 &lt;code&gt;null&lt;/code&gt; 。否则，它应该创建一个新的 &lt;code&gt;byte[]&lt;/code&gt; 数组，将输入的 &lt;code&gt;classfileBuffer&lt;/code&gt; 连同所有所需的转换一起复制到其中，然后返回该新数组。输入的 &lt;code&gt;classfileBuffer&lt;/code&gt; 不得修改。</target>
        </trans-unit>
        <trans-unit id="81ca206f6782401fcc1f26d127affa8acd0e136d" translate="yes" xml:space="preserve">
          <source>If the implementing object is an instance of java.beans.beancontext.BeanContext, or a subinterface thereof, then that BeanContext should fire a PropertyChangeEvent, to its registered BeanContextMembershipListeners, with parameters:</source>
          <target state="translated">如果实现对象是java.beans.beancontext.BeanContext的实例,或者是其子接口,那么该BeanContext应该向其注册的BeanContextMembershipListeners发射一个PropertyChangeEvent,参数。</target>
        </trans-unit>
        <trans-unit id="36b6757dd0b7b9698143f2e5d681dfa198ff7d6d" translate="yes" xml:space="preserve">
          <source>If the incoming object does not implement any additional interfaces known to the writer, the writer has no choice but to access it via the standard &lt;code&gt;IIOMetadata&lt;/code&gt; interfaces such as the tree view provided by &lt;code&gt;IIOMetadata.getAsTree&lt;/code&gt;. In this case, there is likely to be significant loss of information.</source>
          <target state="translated">如果传入对象未实现编写者已知的任何其他接口，则编写者别无选择，只能通过标准 &lt;code&gt;IIOMetadata&lt;/code&gt; 接口（例如 &lt;code&gt;IIOMetadata.getAsTree&lt;/code&gt; 提供的树视图）访问它。在这种情况下，很可能会丢失大量信息。</target>
        </trans-unit>
        <trans-unit id="e436d84bd4232b4579b6124cd808ff4918e211d5" translate="yes" xml:space="preserve">
          <source>If the inherited channel is a datagram-oriented socket then a &lt;a href=&quot;../datagramchannel&quot;&gt;&lt;code&gt;DatagramChannel&lt;/code&gt;&lt;/a&gt; is returned. The datagram channel is, at least initially, in blocking mode, and bound to a socket address.</source>
          <target state="translated">如果继承的通道是面向数据报的套接字，则返回&lt;a href=&quot;../datagramchannel&quot;&gt; &lt;code&gt;DatagramChannel&lt;/code&gt; &lt;/a&gt;。数据报通道至少在最初处于阻塞模式，并绑定到套接字地址。</target>
        </trans-unit>
        <trans-unit id="3073a336a578c76af3c2fae533b0dcd45d01e490" translate="yes" xml:space="preserve">
          <source>If the inherited channel represents a stream-oriented connected socket then a &lt;a href=&quot;../socketchannel&quot;&gt;&lt;code&gt;SocketChannel&lt;/code&gt;&lt;/a&gt; is returned. The socket channel is, at least initially, in blocking mode, bound to a socket address, and connected to a peer.</source>
          <target state="translated">如果继承的通道表示面向流的连接套接字，则返回&lt;a href=&quot;../socketchannel&quot;&gt; &lt;code&gt;SocketChannel&lt;/code&gt; &lt;/a&gt;。套接字通道至少在最初处于阻塞模式，绑定到套接字地址，并连接到对等方。</target>
        </trans-unit>
        <trans-unit id="875d948792bb0df4386ddee7ed26751e7f15e361" translate="yes" xml:space="preserve">
          <source>If the inherited channel represents a stream-oriented listening socket then a &lt;a href=&quot;../serversocketchannel&quot;&gt;&lt;code&gt;ServerSocketChannel&lt;/code&gt;&lt;/a&gt; is returned. The server-socket channel is, at least initially, in blocking mode, and bound to a socket address.</source>
          <target state="translated">如果继承的通道表示面向流的侦听套接字，则返回&lt;a href=&quot;../serversocketchannel&quot;&gt; &lt;code&gt;ServerSocketChannel&lt;/code&gt; &lt;/a&gt;。服务器套接字通道至少在最初处于阻塞模式，并且绑定到套接字地址。</target>
        </trans-unit>
        <trans-unit id="046cd8116ea31a7deaa92b344ddffcaddc10e57f" translate="yes" xml:space="preserve">
          <source>If the input byte array is not in valid Base64 encoding scheme then some bytes may have been written to the output byte array before IllegalargumentException is thrown.</source>
          <target state="translated">如果输入字节数组不在有效的Base64编码方案中,那么在IllegalargumentException被抛出之前,一些字节可能已经被写入输出字节数组。</target>
        </trans-unit>
        <trans-unit id="44c010f5bf051b0a98a728de40056665c0f4201b" translate="yes" xml:space="preserve">
          <source>If the input name does not contain a realm, the default realm is used. The default realm can be specified either in a Kerberos configuration file or via the java.security.krb5.realm system property. For more information,  Kerberos Requirements</source>
          <target state="translated">如果输入的名字不包含 realm,则会使用默认的 realm。默认的领域可以在 Kerberos 配置文件中或通过 java.security.krb5.realm 系统属性来指定。更多信息,请参阅 Kerberos 需求</target>
        </trans-unit>
        <trans-unit id="e2258789d44cebf2e677dac1a6ecd85ab5667fdc" translate="yes" xml:space="preserve">
          <source>If the input name does not contain a realm, the default realm is used. The default realm can be specified either in a Kerberos configuration file or via the java.security.krb5.realm system property. For more information, see  Kerberos Requirements.</source>
          <target state="translated">如果输入的名字不包含 realm,则会使用默认的 realm。默认的 realm 可以在 Kerberos 配置文件中指定,也可以通过 java.security.krb5.realm 系统属性来指定。更多信息请参见 Kerberos 要求。</target>
        </trans-unit>
        <trans-unit id="72db9a55602aeaacd8d06804f6747b4e1ec98ac6" translate="yes" xml:space="preserve">
          <source>If the input sequence is mutable, it must remain constant during the execution of the terminal stream operation. Otherwise, the result of the terminal stream operation is undefined.</source>
          <target state="translated">如果输入序列是可变的,那么在执行终端流操作的过程中必须保持不变。否则,终端流操作的结果是未定义的。</target>
        </trans-unit>
        <trans-unit id="bdcd5cc0d6714ef6dfe7ad5151f92554586e46cb" translate="yes" xml:space="preserve">
          <source>If the intended destination of this stream is an abstraction provided by the underlying operating system, for example a file, then flushing the stream guarantees only that bytes previously written to the stream are passed to the operating system for writing; it does not guarantee that they are actually written to a physical device such as a disk drive.</source>
          <target state="translated">如果这个流的预期目标是底层操作系统提供的一个抽象,例如一个文件,那么刷新流只能保证之前写入流的字节被传递给操作系统进行写入,并不能保证这些字节真的被写入磁盘驱动器等物理设备。</target>
        </trans-unit>
        <trans-unit id="881b9ec107691ccb0574603b5fa37effa233e5be" translate="yes" xml:space="preserve">
          <source>If the invoked method completes normally, the value it returns is copied in the &lt;code&gt;value&lt;/code&gt; property. Note that the &lt;code&gt;value&lt;/code&gt; property is set to &lt;code&gt;null&lt;/code&gt;, if the return type of the underlying method is &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">如果调用的方法正常完成，则将其返回的 &lt;code&gt;value&lt;/code&gt; 复制到value属性中。请注意，如果基础方法的返回类型为 &lt;code&gt;void&lt;/code&gt; ，则 &lt;code&gt;value&lt;/code&gt; 属性设置为 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="55fa409a4b17ed3350505c8e7edb658e38fe64b1" translate="yes" xml:space="preserve">
          <source>If the invoking thread is interrupted while waiting to acquire the lock then its interrupt status will be set and a &lt;a href=&quot;filelockinterruptionexception&quot;&gt;&lt;code&gt;FileLockInterruptionException&lt;/code&gt;&lt;/a&gt; will be thrown. If the invoker's interrupt status is set when this method is invoked then that exception will be thrown immediately; the thread's interrupt status will not be changed.</source>
          <target state="translated">如果在等待获取锁的过程中调用线程被中断，则将设置其中断状态，并抛出&lt;a href=&quot;filelockinterruptionexception&quot;&gt; &lt;code&gt;FileLockInterruptionException&lt;/code&gt; &lt;/a&gt;。如果在调用此方法时设置了调用者的中断状态，则将立即引发该异常；否则，将立即抛出该异常。线程的中断状态将不会更改。</target>
        </trans-unit>
        <trans-unit id="ace7c9d0c03c5a8591ce4f875b6cfb21a9fe43d8" translate="yes" xml:space="preserve">
          <source>If the jar file is on the class path, VendorJavaCompiler can be located using code like this:</source>
          <target state="translated">如果jar文件在类路径上,VendorJavaCompiler可以使用这样的代码来定位。</target>
        </trans-unit>
        <trans-unit id="05798c7b9d831dc45d92f33b15f7f3c7a9524b15" translate="yes" xml:space="preserve">
          <source>If the key agreement algorithm requires random bytes, it gets them from the given source of randomness, &lt;code&gt;random&lt;/code&gt;. However, if the underlying algorithm implementation does not require any random bytes, &lt;code&gt;random&lt;/code&gt; is ignored.</source>
          <target state="translated">如果密钥协商算法需要随机字节，则从给定的随机性源 &lt;code&gt;random&lt;/code&gt; 中获取它们。但是，如果基础算法实现不需要任何随机字节，则将忽略 &lt;code&gt;random&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b9ba2d545a01554992fedf0cb983cad56e6a2aca" translate="yes" xml:space="preserve">
          <source>If the key is stored on a hardware device, its specification may contain information that helps identify the key on the device.</source>
          <target state="translated">如果密钥存储在硬件设备上,其规格可能包含有助于识别设备上密钥的信息。</target>
        </trans-unit>
        <trans-unit id="c9af549a3a519458df47c4c31dbda4adcd0e3257" translate="yes" xml:space="preserve">
          <source>If the language requires different forms for formatting and stand-alone usages, This method returns short month names in the formatting form. For example, the preferred abbreviation for January in the Catalan language is &lt;em&gt;de gen.&lt;/em&gt; in the formatting form, while it is &lt;em&gt;gen.&lt;/em&gt; in the stand-alone form. This method returns &lt;code&gt;&quot;de gen.&quot;&lt;/code&gt; in this case. Refer to the &lt;a href=&quot;http://unicode.org/reports/tr35/#Calendar_Elements&quot;&gt; Calendar Elements in the Unicode Locale Data Markup Language (LDML) specification&lt;/a&gt; for more details.</source>
          <target state="translated">如果语言要求不同的格式格式和独立使用，则此方法以格式格式返回短月份名称。例如，加泰罗尼亚语中January的首选缩写是&lt;em&gt;de gen。&lt;/em&gt;在格式表格中，虽然它是&lt;em&gt;gen。&lt;/em&gt;以独立形式。此方法返回 &lt;code&gt;&quot;de gen.&quot;&lt;/code&gt; 在这种情况下。有关更多详细信息，请参考&lt;a href=&quot;http://unicode.org/reports/tr35/#Calendar_Elements&quot;&gt;Unicode区域设置数据标记语言（LDML）规范中&lt;/a&gt;的日历元素。</target>
        </trans-unit>
        <trans-unit id="93f027224547b6049ea9e0bfa7e65c576dd00372" translate="yes" xml:space="preserve">
          <source>If the language requires different forms for formatting and stand-alone usages, this method returns month names in the formatting form. For example, the preferred month name for January in the Czech language is &lt;em&gt;ledna&lt;/em&gt; in the formatting form, while it is &lt;em&gt;leden&lt;/em&gt; in the stand-alone form. This method returns &lt;code&gt;&quot;ledna&quot;&lt;/code&gt; in this case. Refer to the &lt;a href=&quot;http://unicode.org/reports/tr35/#Calendar_Elements&quot;&gt; Calendar Elements in the Unicode Locale Data Markup Language (LDML) specification&lt;/a&gt; for more details.</source>
          <target state="translated">如果语言要求不同的格式格式和独立用法，则此方法以格式格式返回月份名称。例如，对于1月在捷克语最佳月份名称是&lt;em&gt;ledna&lt;/em&gt;在格式化的形式，而它&lt;em&gt;LEDEN&lt;/em&gt;在单机形式。在这种情况下，此方法返回 &lt;code&gt;&quot;ledna&quot;&lt;/code&gt; 。有关更多详细信息，请参考&lt;a href=&quot;http://unicode.org/reports/tr35/#Calendar_Elements&quot;&gt;Unicode区域设置数据标记语言（LDML）规范中&lt;/a&gt;的日历元素。</target>
        </trans-unit>
        <trans-unit id="721e40fbee0b627fcc6ccf4dd39ef80c9c24cc65" translate="yes" xml:space="preserve">
          <source>If the length of &lt;code&gt;b&lt;/code&gt; is zero, then no bytes are read and &lt;code&gt;0&lt;/code&gt; is returned; otherwise, there is an attempt to read at least one byte. If no byte is available because the stream is at the end of the file, the value &lt;code&gt;-1&lt;/code&gt; is returned; otherwise, at least one byte is read and stored into &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;b&lt;/code&gt; 的长度为零，则不读取任何字节，并返回 &lt;code&gt;0&lt;/code&gt; ；否则，返回0。否则，尝试读取至少一个字节。如果由于流位于文件末尾而没有字节可用，则返回值 &lt;code&gt;-1&lt;/code&gt; ；否则返回值-1。否则，读取至少一个字节并将其存储到 &lt;code&gt;b&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="945b37877bd5c51ba536e667136d3b4286b64c37" translate="yes" xml:space="preserve">
          <source>If the length of the argument string is &lt;code&gt;0&lt;/code&gt;, then this &lt;code&gt;String&lt;/code&gt; object is returned. Otherwise, a &lt;code&gt;String&lt;/code&gt; object is returned that represents a character sequence that is the concatenation of the character sequence represented by this &lt;code&gt;String&lt;/code&gt; object and the character sequence represented by the argument string.</source>
          <target state="translated">如果参数字符串的长度为 &lt;code&gt;0&lt;/code&gt; ，则返回此 &lt;code&gt;String&lt;/code&gt; 对象。否则，将返回一个 &lt;code&gt;String&lt;/code&gt; 对象，该对象表示一个字符序列，该字符序列是此 &lt;code&gt;String&lt;/code&gt; 对象表示的字符序列与参数字符串表示的字符序列的串联。</target>
        </trans-unit>
        <trans-unit id="0940fb46aa425a706a545b01258cef980fd6db8a" translate="yes" xml:space="preserve">
          <source>If the length of the specified &lt;code&gt;CharSequence&lt;/code&gt; is less than or equal to zero, then an empty buffer of capacity &lt;code&gt;16&lt;/code&gt; is returned.</source>
          <target state="translated">如果指定的 &lt;code&gt;CharSequence&lt;/code&gt; 的长度小于或等于零，则返回容量为 &lt;code&gt;16&lt;/code&gt; 的空缓冲区。</target>
        </trans-unit>
        <trans-unit id="009a7b082a7f277c626ca216eb6dd0590efc9900" translate="yes" xml:space="preserve">
          <source>If the line is not open and has never been opened, it returns the default format. The default format is an implementation specific audio format, or, if the &lt;code&gt;DataLine.Info&lt;/code&gt; object, which was used to retrieve this &lt;code&gt;DataLine&lt;/code&gt;, specifies at least one fully qualified audio format, the last one will be used as the default format. Opening the line with a specific audio format (e.g. &lt;a href=&quot;sourcedataline#open-javax.sound.sampled.AudioFormat-&quot;&gt;&lt;code&gt;SourceDataLine.open(AudioFormat)&lt;/code&gt;&lt;/a&gt;) will override the default format.</source>
          <target state="translated">如果该行未打开且从未打开过，则返回默认格式。默认格式是特定于实现的音频格式，或者，如果用于检索此 &lt;code&gt;DataLine&lt;/code&gt; 的 &lt;code&gt;DataLine.Info&lt;/code&gt; 对象指定了至少一种完全限定的音频格式，则最后一种将用作默认格式。用特定的音频格式（例如&lt;a href=&quot;sourcedataline#open-javax.sound.sampled.AudioFormat-&quot;&gt; &lt;code&gt;SourceDataLine.open(AudioFormat)&lt;/code&gt; &lt;/a&gt;）打开行将覆盖默认格式。</target>
        </trans-unit>
        <trans-unit id="7863f26128f8bba0e665024d8f8516c082ac4867" translate="yes" xml:space="preserve">
          <source>If the list fits in the specified array with room to spare (i.e., the array has more elements than the list), the element in the array immediately following the end of the collection is set to &lt;code&gt;null&lt;/code&gt;. (This is useful in determining the length of the list</source>
          <target state="translated">如果列表适合指定的数组并有剩余空间（即，数组中的元素多于列表），则紧接集合结束后的数组中的元素设置为 &lt;code&gt;null&lt;/code&gt; 。（这对于确定列表的长度很有用</target>
        </trans-unit>
        <trans-unit id="9d2a9e6acfe01f48880cc127c76590e8af39df2a" translate="yes" xml:space="preserve">
          <source>If the list fits in the specified array with room to spare (i.e., the array has more elements than the list), the element in the array immediately following the end of the list is set to &lt;code&gt;null&lt;/code&gt;. (This is useful in determining the length of the list</source>
          <target state="translated">如果列表适合指定的数组并有剩余空间（即，数组中的元素多于列表），则紧接列表结尾的数组中的元素将设置为 &lt;code&gt;null&lt;/code&gt; 。（这对于确定列表的长度很有用</target>
        </trans-unit>
        <trans-unit id="1566f18ef0180d3aac88323daa9341914ba885e6" translate="yes" xml:space="preserve">
          <source>If the list's list-iterator does not support the &lt;code&gt;set&lt;/code&gt; operation then an &lt;code&gt;UnsupportedOperationException&lt;/code&gt; will be thrown when replacing the first element.</source>
          <target state="translated">如果列表的列表迭代器不支持 &lt;code&gt;set&lt;/code&gt; 操作，则替换第一个元素时将引发 &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4ae175c3216a75f24ee407fdf582572db3c498ef" translate="yes" xml:space="preserve">
          <source>If the listener is registered more than once, perhaps with different filters or callbacks, this method will remove all those registrations.</source>
          <target state="translated">如果监听器注册了不止一次,也许是用不同的过滤器或回调,这个方法将删除所有这些注册。</target>
        </trans-unit>
        <trans-unit id="54b665bbf8eb506dbbe12fdda9847f03e69a163c" translate="yes" xml:space="preserve">
          <source>If the literal is empty, nothing is added to the formatter.</source>
          <target state="translated">如果字面意思为空,则不会向格式器添加任何内容。</target>
        </trans-unit>
        <trans-unit id="5586e5fb737ecf0129eedcffc9670c2876a5d020" translate="yes" xml:space="preserve">
          <source>If the load average is not available, a negative value is returned.</source>
          <target state="translated">如果没有负载平均值,则返回负值。</target>
        </trans-unit>
        <trans-unit id="612e3af41a7467295225df330e80d3aa55f31393" translate="yes" xml:space="preserve">
          <source>If the loading of the content handler class would be performed by a classloader that is outside of the delegation chain of the caller, the JVM will need the RuntimePermission &quot;getClassLoader&quot;.</source>
          <target state="translated">如果内容处理程序类的加载将由调用者的委托链之外的classloader执行,JVM将需要RuntimePermission &quot;getClassLoader&quot;。</target>
        </trans-unit>
        <trans-unit id="fb7426e4160f2b1fe5d7220ffa07b99d6ba7024b" translate="yes" xml:space="preserve">
          <source>If the locale is exactly &lt;code&gt;Locale(&quot;no&quot;, &quot;NO&quot;, &quot;NY&quot;)&lt;/code&gt;, it is first converted to &lt;code&gt;Locale(&quot;nn&quot;, &quot;NO&quot;)&lt;/code&gt; and then the above procedure is followed.</source>
          <target state="translated">如果语言环境恰好是 &lt;code&gt;Locale(&quot;no&quot;, &quot;NO&quot;, &quot;NY&quot;)&lt;/code&gt; ，则首先将其转换为 &lt;code&gt;Locale(&quot;nn&quot;, &quot;NO&quot;)&lt;/code&gt; ，然后按照上述过程进行操作。</target>
        </trans-unit>
        <trans-unit id="c64c3966e3d4abb3a14f499628ce198c1164f906" translate="yes" xml:space="preserve">
          <source>If the lock is acquired by the current thread then the lock hold count is set to one.</source>
          <target state="translated">如果锁被当前线程获取,那么锁的持有数就会被设置为1。</target>
        </trans-unit>
        <trans-unit id="822233d82712d166731e9dcca011715ab8bbe1d8" translate="yes" xml:space="preserve">
          <source>If the lock is acquired then the value &lt;code&gt;true&lt;/code&gt; is returned and the lock hold count is set to one.</source>
          <target state="translated">如果获取了锁，则返回 &lt;code&gt;true&lt;/code&gt; 值，并将锁保持计数设置为1。</target>
        </trans-unit>
        <trans-unit id="243ddf2fd70f54733945fc92a2c6210895bc2219" translate="yes" xml:space="preserve">
          <source>If the lock is acquired then the value &lt;code&gt;true&lt;/code&gt; is returned.</source>
          <target state="translated">如果获取了锁，则返回值 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e267ec383786f22b490efc4cbeb5a239987b49eb" translate="yes" xml:space="preserve">
          <source>If the lock is available this method returns immediately with the value &lt;code&gt;true&lt;/code&gt;. If the lock is not available then the current thread becomes disabled for thread scheduling purposes and lies dormant until one of three things happens:</source>
          <target state="translated">如果锁可用，则此方法立即返回 &lt;code&gt;true&lt;/code&gt; 值。如果该锁不可用，则出于线程调度目的，当前线程将被禁用，并在发生以下三种情况之一之前处于休眠状态：</target>
        </trans-unit>
        <trans-unit id="3b3629e1c7a434db3fa94e4624595c63c91c3763" translate="yes" xml:space="preserve">
          <source>If the lock is held by another thread then the current thread becomes disabled for thread scheduling purposes and lies dormant until one of three things happens:</source>
          <target state="translated">如果锁被另一个线程持有,那么当前线程就会因为线程调度的目的而被禁用,并处于休眠状态,直到三种情况之一发生。</target>
        </trans-unit>
        <trans-unit id="bc3fb57c41848bc377b297ddabc5e3ff9216fa1a" translate="yes" xml:space="preserve">
          <source>If the lock is held by another thread then the current thread becomes disabled for thread scheduling purposes and lies dormant until one of two things happens:</source>
          <target state="translated">如果锁被另一个线程持有,那么当前线程就会因为线程调度的目的而被禁用,并处于休眠状态,直到两种情况之一发生。</target>
        </trans-unit>
        <trans-unit id="9a8c566c06708381b95a076b6d0a7ff9c3dd5f9a" translate="yes" xml:space="preserve">
          <source>If the lock is held by another thread then the current thread becomes disabled for thread scheduling purposes and lies dormant until the lock has been acquired, at which time the lock hold count is set to one.</source>
          <target state="translated">如果锁被另一个线程持有,那么当前线程就会因为线程调度的目的而被禁用,并处于休眠状态,直到锁被获取,这时锁的持有数被设置为1。</target>
        </trans-unit>
        <trans-unit id="d853278a5b45d2ebee3420faecb6ce65095ece12" translate="yes" xml:space="preserve">
          <source>If the lock is held by another thread then the current thread becomes disabled for thread scheduling purposes and lies dormant until the write lock has been acquired, at which time the write lock hold count is set to one.</source>
          <target state="translated">如果锁被其他线程持有,那么出于线程调度的目的,当前线程就会被禁用,并处于休眠状态,直到获得写锁为止,此时写锁持有数被设置为1。</target>
        </trans-unit>
        <trans-unit id="918d784e15001f2097233989116a220695ba3605" translate="yes" xml:space="preserve">
          <source>If the lock is held by another thread then this method will return immediately with the value &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果锁由另一个线程持有，则此方法将立即返回 &lt;code&gt;false&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="85233bd93c41bf81d5bd16d44009dd4101f01d92" translate="yes" xml:space="preserve">
          <source>If the lock is not available then the current thread becomes disabled for thread scheduling purposes and lies dormant until one of two things happens:</source>
          <target state="translated">如果锁不可用,那么当前线程就会因为线程调度的目的而被禁用,并处于休眠状态,直到两种情况之一发生。</target>
        </trans-unit>
        <trans-unit id="2fcde55af63c37dc1d170326de90648dbad927ec" translate="yes" xml:space="preserve">
          <source>If the lock is not available then the current thread becomes disabled for thread scheduling purposes and lies dormant until the lock has been acquired.</source>
          <target state="translated">如果锁不可用,那么当前线程就会因为线程调度的目的而被禁用,并处于休眠状态,直到锁被获取。</target>
        </trans-unit>
        <trans-unit id="a09e194cce7b274be7295eeba5f7cce4ea171773" translate="yes" xml:space="preserve">
          <source>If the lock state matches the given stamp then, if the stamp represents holding a lock, releases it and returns an observation stamp. Or, if an optimistic read, returns it if validated. This method returns zero in all other cases, and so may be useful as a form of &quot;tryUnlock&quot;.</source>
          <target state="translated">如果锁状态与给定的戳记相匹配,那么,如果戳记代表持有锁,则释放它,并返回观察戳记。或者,如果是乐观的读取,如果验证了就返回。在所有其他情况下,该方法返回零,因此可能作为 &quot;tryUnlock &quot;的一种形式。</target>
        </trans-unit>
        <trans-unit id="eefa68914d354c4eea9a7f9d2e87edb5b5d3616c" translate="yes" xml:space="preserve">
          <source>If the lock state matches the given stamp, performs one of the following actions. If the stamp represents holding a write lock, releases it and obtains a read lock. Or, if a read lock, returns it. Or, if an optimistic read, acquires a read lock and returns a read stamp only if immediately available. This method returns zero in all other cases.</source>
          <target state="translated">如果锁的状态与给定的印记相匹配,则执行以下操作之一:如果印记代表持有一个写锁,则释放它并获得读锁。如果印记代表持有一个写锁,则释放它并获得一个读锁。或者,如果是读锁,则返回它。或者,如果是乐观的读,则获取一个读锁,只有在立即可用的情况下才返回一个读印章。其他情况下,本方法返回零。</target>
        </trans-unit>
        <trans-unit id="3fe6cd5b7f1314dfe53912057e75419a458d6c46" translate="yes" xml:space="preserve">
          <source>If the lock state matches the given stamp, performs one of the following actions. If the stamp represents holding a write lock, returns it. Or, if a read lock, if the write lock is available, releases the read lock and returns a write stamp. Or, if an optimistic read, returns a write stamp only if immediately available. This method returns zero in all other cases.</source>
          <target state="translated">如果锁的状态与给定的印章相匹配,则执行以下操作之一。如果印章代表持有一个写锁,则返回它。或者,如果是读锁,如果写锁可用,则释放读锁并返回写戳。或者,如果是乐观读,只有在立即可用的情况下才返回一个写戳。其他情况下,本方法返回零。</target>
        </trans-unit>
        <trans-unit id="14a53c83eff403dc5c623bd9e147872ed3ff94fc" translate="yes" xml:space="preserve">
          <source>If the lock state matches the given stamp, releases the corresponding mode of the lock.</source>
          <target state="translated">如果锁的状态符合给定的印章,则释放锁的相应模式。</target>
        </trans-unit>
        <trans-unit id="3114f1897355cfbc96b7a2b2a9909376a9675347" translate="yes" xml:space="preserve">
          <source>If the lock state matches the given stamp, releases the exclusive lock.</source>
          <target state="translated">如果锁的状态符合给定的印记,则释放专属锁。</target>
        </trans-unit>
        <trans-unit id="4a3ebac76180e9eaa8e069fe7a9c0cce392315b8" translate="yes" xml:space="preserve">
          <source>If the lock state matches the given stamp, releases the non-exclusive lock.</source>
          <target state="translated">如果锁的状态符合给定的印章,则释放非独占锁。</target>
        </trans-unit>
        <trans-unit id="e004c7523986b5ecc4e1749a86febcd1a6784511" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the CONFIG message level then the given message is forwarded to all the registered output Handler objects.</source>
          <target state="translated">如果记录仪当前启用了 CONFIG 消息级别,那么给定的消息将转发到所有注册的输出处理程序对象。</target>
        </trans-unit>
        <trans-unit id="2480ae012f96dc55272b45f972094f52d29f7772" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the CONFIG message level then the message is constructed by invoking the provided supplier function and forwarded to all the registered output Handler objects.</source>
          <target state="translated">如果记录仪当前启用了 CONFIG 消息级别,那么将通过调用提供的供应商函数来构建消息,并将其转发给所有注册的输出处理程序对象。</target>
        </trans-unit>
        <trans-unit id="f74f4184b1114d21694c20083bffeca6773ddbdc" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the FINE message level then the given message is forwarded to all the registered output Handler objects.</source>
          <target state="translated">如果记录仪当前启用了 FINE 消息级别,那么给定的消息将被转发给所有注册的输出处理程序对象。</target>
        </trans-unit>
        <trans-unit id="ef129fafed8fea9b1b19398062aeaf0403caccda" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the FINE message level then the message is constructed by invoking the provided supplier function and forwarded to all the registered output Handler objects.</source>
          <target state="translated">如果记录仪当前启用了FINE消息级别,那么消息将通过调用提供的供应商函数来构建,并转发给所有注册的输出处理程序对象。</target>
        </trans-unit>
        <trans-unit id="5c488b5e8261b0b9f6a94d2c335e06b774d3e4c2" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the FINER message level then the given message is forwarded to all the registered output Handler objects.</source>
          <target state="translated">如果记录仪当前启用了FINER消息级别,那么给定的消息将转发到所有注册的输出处理程序对象。</target>
        </trans-unit>
        <trans-unit id="400e0c53967d73d6073541aa2955ecfaedacc619" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the FINER message level then the message is constructed by invoking the provided supplier function and forwarded to all the registered output Handler objects.</source>
          <target state="translated">如果记录器当前启用了FINER消息级别,那么消息将通过调用提供的供应商函数来构建,并转发给所有注册的输出处理程序对象。</target>
        </trans-unit>
        <trans-unit id="c08c72ddfcb02350456ab868e8db332930e255e4" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the FINEST message level then the given message is forwarded to all the registered output Handler objects.</source>
          <target state="translated">如果记录仪当前启用了FINEST消息级别,那么给定的消息将被转发给所有注册的输出处理程序对象。</target>
        </trans-unit>
        <trans-unit id="776e22483061c922dbf981169c45b199faadcb6b" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the FINEST message level then the message is constructed by invoking the provided supplier function and forwarded to all the registered output Handler objects.</source>
          <target state="translated">如果记录仪当前启用了FINEST消息级别,那么将通过调用提供的供应商函数来构建消息,并将其转发给所有注册的输出处理程序对象。</target>
        </trans-unit>
        <trans-unit id="0c3de4bfb7369cf5faf7dd1122bdabc955fddf2e" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the INFO message level then the given message is forwarded to all the registered output Handler objects.</source>
          <target state="translated">如果记录仪当前启用了 INFO 消息级别,那么给定的消息将转发到所有注册的输出处理程序对象。</target>
        </trans-unit>
        <trans-unit id="b7c2334c2c90239d4c59ec8c7a0e4b1e0b78f35b" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the INFO message level then the message is constructed by invoking the provided supplier function and forwarded to all the registered output Handler objects.</source>
          <target state="translated">如果记录仪当前启用了 INFO 消息级别,那么将通过调用提供的供应商函数来构建消息,并将其转发给所有注册的输出处理程序对象。</target>
        </trans-unit>
        <trans-unit id="ab7e0ed2e38d83c57cfc908b346ba953ba01ea6e" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the SEVERE message level then the given message is forwarded to all the registered output Handler objects.</source>
          <target state="translated">如果记录仪当前启用了SEVERE消息级别,则给定消息将转发到所有注册的输出处理程序对象。</target>
        </trans-unit>
        <trans-unit id="8e167659c676fd6a76d1a8ff361acf900cf2dee4" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the SEVERE message level then the message is constructed by invoking the provided supplier function and forwarded to all the registered output Handler objects.</source>
          <target state="translated">如果记录仪当前启用了SEVERE消息级别,那么将通过调用提供的供应商函数来构建消息,并将其转发给所有注册的输出处理程序对象。</target>
        </trans-unit>
        <trans-unit id="700de6b174ae4293a822d7062908049e15243b9c" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the WARNING message level then the given message is forwarded to all the registered output Handler objects.</source>
          <target state="translated">如果记录仪当前启用了警告消息级别,那么给定的消息将转发给所有注册的输出处理程序对象。</target>
        </trans-unit>
        <trans-unit id="8548b61ec8126b5ee81ca57df60b3e51531c5a8a" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the WARNING message level then the message is constructed by invoking the provided supplier function and forwarded to all the registered output Handler objects.</source>
          <target state="translated">如果记录仪当前启用了警告消息级别,那么将通过调用提供的供应商函数来构建消息,并将其转发给所有注册的输出处理程序对象。</target>
        </trans-unit>
        <trans-unit id="2998fe288d20db38f6f02724d9a3e1e03f44693c" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the given message level then a corresponding LogRecord is created and forwarded to all the registered output Handler objects.</source>
          <target state="translated">如果当前为给定的消息级别启用了日志记录器,那么就会创建一个相应的日志记录,并转发给所有注册的输出处理对象。</target>
        </trans-unit>
        <trans-unit id="5672874e662c52b70bec899dedf5a6f7d4107f79" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the given message level then the given arguments are stored in a LogRecord which is forwarded to all registered output handlers.</source>
          <target state="translated">如果当前给定消息级别的日志记录器处于启用状态,那么给定参数将存储在日志记录中,该记录将转发给所有注册的输出处理程序。</target>
        </trans-unit>
        <trans-unit id="0a20e1ab3ef4c4dda5575d5b6fbf96f00af911a8" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the given message level then the given arguments are stored in a LogRecord which is forwarded to all registered output handlers. The LogRecord's message is set to &quot;THROW&quot;.</source>
          <target state="translated">如果记录仪当前已为给定的消息级别启用,那么给定的参数将存储在日志记录中,该记录将转发给所有注册的输出处理程序。日志记录的消息被设置为 &quot;THROW&quot;。</target>
        </trans-unit>
        <trans-unit id="325dfec7a72934c84f66843540d89c8f3769035b" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the given message level then the given message is forwarded to all the registered output Handler objects.</source>
          <target state="translated">如果当前给定消息级别的记录器处于启用状态,那么给定消息将转发到所有注册的输出处理程序对象。</target>
        </trans-unit>
        <trans-unit id="09b15fa7220dfe741c8baffb5087e302fb89c908" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the given message level then the message is constructed by invoking the provided supplier function and forwarded to all the registered output Handler objects.</source>
          <target state="translated">如果当前给定消息级别的记录器已启用,则通过调用提供的供应商函数来构造消息,并将其转发给所有注册的输出处理程序对象。</target>
        </trans-unit>
        <trans-unit id="72eff8884364ee54a875323cb549fca604cb4b7b" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the given message level then the message is constructed by invoking the provided supplier function. The message and the given &lt;a href=&quot;../../lang/throwable&quot;&gt;&lt;code&gt;Throwable&lt;/code&gt;&lt;/a&gt; are then stored in a &lt;a href=&quot;logrecord&quot;&gt;&lt;code&gt;LogRecord&lt;/code&gt;&lt;/a&gt; which is forwarded to all registered output handlers.</source>
          <target state="translated">如果当前为给定消息级别启用了记录器，则可以通过调用提供的供应商功能来构造消息。消息和给定的&lt;a href=&quot;../../lang/throwable&quot;&gt; &lt;code&gt;Throwable&lt;/code&gt; &lt;/a&gt;然后存储在&lt;a href=&quot;logrecord&quot;&gt; &lt;code&gt;LogRecord&lt;/code&gt; 中&lt;/a&gt;，该记录转发到所有注册的输出处理程序。</target>
        </trans-unit>
        <trans-unit id="df68511496b32d8949f42994423a12d97c5a37a3" translate="yes" xml:space="preserve">
          <source>If the looked-up method has a &lt;a href=&quot;methodhandle#maxarity&quot;&gt;very large arity&lt;/a&gt;, the method handle creation may fail, due to the method handle type having too many parameters.</source>
          <target state="translated">如果查找的方法具有&lt;a href=&quot;methodhandle#maxarity&quot;&gt;很大的Arity&lt;/a&gt;，则由于方法句柄类型的参数过多，因此可能无法创建方法句柄。</target>
        </trans-unit>
        <trans-unit id="d5a1d5c49aae5cb26d9965efa2b543eb65306a01" translate="yes" xml:space="preserve">
          <source>If the magnitude is zero, it is represented by a single zero character &lt;code&gt;'0'&lt;/code&gt; (&lt;code&gt;'\u0030'&lt;/code&gt;); otherwise, the first character of the representation of the magnitude will not be the zero character.</source>
          <target state="translated">如果大小为零，则用单个零字符 &lt;code&gt;'0'&lt;/code&gt; （ &lt;code&gt;'\u0030'&lt;/code&gt; ）表示；否则，表示幅度的第一个字符将不是零字符。</target>
        </trans-unit>
        <trans-unit id="e2b282ebf7062ed0ca134866fb50f5fe7dd48ced" translate="yes" xml:space="preserve">
          <source>If the main task must later await termination, it may re-register and then execute a similar loop:</source>
          <target state="translated">如果主任务以后必须等待终止,它可以重新注册,然后执行一个类似的循环。</target>
        </trans-unit>
        <trans-unit id="91601953e386bbcbf0a6b2f49eca2d05544c99f8" translate="yes" xml:space="preserve">
          <source>If the mapped keys contains duplicates (according to &lt;a href=&quot;../../lang/object#equals-java.lang.Object-&quot;&gt;&lt;code&gt;Object.equals(Object)&lt;/code&gt;&lt;/a&gt;), an &lt;code&gt;IllegalStateException&lt;/code&gt; is thrown when the collection operation is performed. If the mapped keys may have duplicates, use &lt;a href=&quot;collectors#toConcurrentMap-java.util.function.Function-java.util.function.Function-java.util.function.BinaryOperator-&quot;&gt;&lt;code&gt;toConcurrentMap(Function, Function, BinaryOperator)&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">如果映射的键包含重复项（根据&lt;a href=&quot;../../lang/object#equals-java.lang.Object-&quot;&gt; &lt;code&gt;Object.equals(Object)&lt;/code&gt; &lt;/a&gt;），则在执行收集操作时将抛出 &lt;code&gt;IllegalStateException&lt;/code&gt; 。如果映射的键可能有重复，请改用&lt;a href=&quot;collectors#toConcurrentMap-java.util.function.Function-java.util.function.Function-java.util.function.BinaryOperator-&quot;&gt; &lt;code&gt;toConcurrentMap(Function, Function, BinaryOperator)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="42bc70fbf81ca2e8ef91fd72811c9886f9c29e43" translate="yes" xml:space="preserve">
          <source>If the mapped keys contains duplicates (according to &lt;a href=&quot;../../lang/object#equals-java.lang.Object-&quot;&gt;&lt;code&gt;Object.equals(Object)&lt;/code&gt;&lt;/a&gt;), an &lt;code&gt;IllegalStateException&lt;/code&gt; is thrown when the collection operation is performed. If the mapped keys may have duplicates, use &lt;a href=&quot;collectors#toMap-java.util.function.Function-java.util.function.Function-java.util.function.BinaryOperator-&quot;&gt;&lt;code&gt;toMap(Function, Function, BinaryOperator)&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">如果映射的键包含重复项（根据&lt;a href=&quot;../../lang/object#equals-java.lang.Object-&quot;&gt; &lt;code&gt;Object.equals(Object)&lt;/code&gt; &lt;/a&gt;），则在执行收集操作时将抛出 &lt;code&gt;IllegalStateException&lt;/code&gt; 。如果映射的键可能有重复，请改用&lt;a href=&quot;collectors#toMap-java.util.function.Function-java.util.function.Function-java.util.function.BinaryOperator-&quot;&gt; &lt;code&gt;toMap(Function, Function, BinaryOperator)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ebd1a935a059b20128bc5042763d4c45de22fb0b" translate="yes" xml:space="preserve">
          <source>If the mapped keys contains duplicates (according to &lt;a href=&quot;../../lang/object#equals-java.lang.Object-&quot;&gt;&lt;code&gt;Object.equals(Object)&lt;/code&gt;&lt;/a&gt;), the value mapping function is applied to each equal element, and the results are merged using the provided merging function.</source>
          <target state="translated">如果映射的键包含重复项（根据&lt;a href=&quot;../../lang/object#equals-java.lang.Object-&quot;&gt; &lt;code&gt;Object.equals(Object)&lt;/code&gt; &lt;/a&gt;），则将值映射函数应用于每个equal元素，然后使用提供的合并函数合并结果。</target>
        </trans-unit>
        <trans-unit id="0ab1f12a020b33fa5cdaa6c8e92a327756ecc141" translate="yes" xml:space="preserve">
          <source>If the mapped keys contains duplicates (according to &lt;a href=&quot;../../lang/object#equals-java.lang.Object-&quot;&gt;&lt;code&gt;Object.equals(Object)&lt;/code&gt;&lt;/a&gt;), the value mapping function is applied to each equal element, and the results are merged using the provided merging function. The &lt;code&gt;ConcurrentMap&lt;/code&gt; is created by a provided supplier function.</source>
          <target state="translated">如果映射的键包含重复项（根据&lt;a href=&quot;../../lang/object#equals-java.lang.Object-&quot;&gt; &lt;code&gt;Object.equals(Object)&lt;/code&gt; &lt;/a&gt;），则将值映射函数应用于每个equal元素，然后使用提供的合并函数合并结果。该 &lt;code&gt;ConcurrentMap&lt;/code&gt; 是由供应商提供的函数创建。</target>
        </trans-unit>
        <trans-unit id="5d55abd598d0098b46d878c1a82407a1edf09085" translate="yes" xml:space="preserve">
          <source>If the mapped keys contains duplicates (according to &lt;a href=&quot;../../lang/object#equals-java.lang.Object-&quot;&gt;&lt;code&gt;Object.equals(Object)&lt;/code&gt;&lt;/a&gt;), the value mapping function is applied to each equal element, and the results are merged using the provided merging function. The &lt;code&gt;Map&lt;/code&gt; is created by a provided supplier function.</source>
          <target state="translated">如果映射的键包含重复项（根据&lt;a href=&quot;../../lang/object#equals-java.lang.Object-&quot;&gt; &lt;code&gt;Object.equals(Object)&lt;/code&gt; &lt;/a&gt;），则将值映射函数应用于每个equal元素，然后使用提供的合并函数合并结果。该 &lt;code&gt;Map&lt;/code&gt; 由提供的供应商功能创建。</target>
        </trans-unit>
        <trans-unit id="38fcc3a9324656c7f62d52adcd0bcdf26f23941f" translate="yes" xml:space="preserve">
          <source>If the match succeeds then more information can be obtained via the &lt;code&gt;start&lt;/code&gt;, &lt;code&gt;end&lt;/code&gt;, and &lt;code&gt;group&lt;/code&gt; methods, and subsequent invocations of the &lt;a href=&quot;matcher#find--&quot;&gt;&lt;code&gt;find()&lt;/code&gt;&lt;/a&gt; method will start at the first character not matched by this match.</source>
          <target state="translated">如果匹配成功，则可以通过 &lt;code&gt;start&lt;/code&gt; ， &lt;code&gt;end&lt;/code&gt; 和 &lt;code&gt;group&lt;/code&gt; 方法获取更多信息，并且&lt;a href=&quot;matcher#find--&quot;&gt; &lt;code&gt;find()&lt;/code&gt; &lt;/a&gt;方法的后续调用将从与该匹配不匹配的第一个字符开始。</target>
        </trans-unit>
        <trans-unit id="e45d30a935b4cf0dbcaf8698457f96e2ee71e0db" translate="yes" xml:space="preserve">
          <source>If the match succeeds then more information can be obtained via the &lt;code&gt;start&lt;/code&gt;, &lt;code&gt;end&lt;/code&gt;, and &lt;code&gt;group&lt;/code&gt; methods.</source>
          <target state="translated">如果匹配成功，则可以通过 &lt;code&gt;start&lt;/code&gt; ， &lt;code&gt;end&lt;/code&gt; 和 &lt;code&gt;group&lt;/code&gt; 方法获取更多信息。</target>
        </trans-unit>
        <trans-unit id="4646f11996bf69cea5464367c1335e753c401c2e" translate="yes" xml:space="preserve">
          <source>If the match was successful but the group specified failed to match any part of the input sequence, then &lt;code&gt;null&lt;/code&gt; is returned. Note that some groups, for example &lt;code&gt;(a*)&lt;/code&gt;, match the empty string. This method will return the empty string when such a group successfully matches the empty string in the input.</source>
          <target state="translated">如果匹配成功，但是指定的组与输入序列的任何部分都不匹配，则返回 &lt;code&gt;null&lt;/code&gt; 。请注意，某些组（例如 &lt;code&gt;(a*)&lt;/code&gt; 匹配空字符串。当这样的组成功匹配输入中的空字符串时，此方法将返回空字符串。</target>
        </trans-unit>
        <trans-unit id="e27c63987af47673a3557d130f21afb577235397" translate="yes" xml:space="preserve">
          <source>If the maximum number of integer digits is greater than their minimum number and greater than 1, it forces the exponent to be a multiple of the maximum number of integer digits, and the minimum number of integer digits to be interpreted as 1. The most common use of this is to generate &lt;em&gt;engineering notation&lt;/em&gt;, in which the exponent is a multiple of three, e.g., &lt;code&gt;&quot;##0.#####E0&quot;&lt;/code&gt;. Using this pattern, the number 12345 formats to &lt;code&gt;&quot;12.345E3&quot;&lt;/code&gt;, and 123456 formats to &lt;code&gt;&quot;123.456E3&quot;&lt;/code&gt;.</source>
          <target state="translated">如果最大整数位数大于最小位数且大于1，则将指数强制为最大整数位数的倍数，并将最小整数位数解释为1。最常见使用它是为了生成&lt;em&gt;工程符号&lt;/em&gt;，其中指数是3的倍数，例如 &lt;code&gt;&quot;##0.#####E0&quot;&lt;/code&gt; 。使用此模式，数字12345格式化为 &lt;code&gt;&quot;12.345E3&quot;&lt;/code&gt; ，数字123456格式化为 &lt;code&gt;&quot;123.456E3&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="838dcf4d5b32bbaaf6507ff34ec3b9a39315ea1c" translate="yes" xml:space="preserve">
          <source>If the mechanism has an initial response, the library invokes &lt;code&gt;evaluateChallenge()&lt;/code&gt; with an empty challenge and to get initial response. Protocols such as IMAP4, which do not include an initial response with their first authentication command to the server, initiates the authentication without first calling &lt;code&gt;hasInitialResponse()&lt;/code&gt; or &lt;code&gt;evaluateChallenge()&lt;/code&gt;. When the server responds to the command, it sends an initial challenge. For a SASL mechanism in which the client sends data first, the server should have issued a challenge with no data. This will then result in a call (on the client) to &lt;code&gt;evaluateChallenge()&lt;/code&gt; with an empty challenge.</source>
          <target state="translated">如果该机制具有初始响应，则库将使用空质询来调用 &lt;code&gt;evaluateChallenge()&lt;/code&gt; 并获取初始响应。协议，如IMAP4，其不包括在其第一认证命令到服务器的初始响应，发起前未调用认证 &lt;code&gt;hasInitialResponse()&lt;/code&gt; 或 &lt;code&gt;evaluateChallenge()&lt;/code&gt; 。当服务器响应该命令时，它将发送初始质询。对于客户端首先发送数据的SASL机制，服务器应该发出没有数据的质询。然后，这将导致（在客户端上）调用带有空质询的 &lt;code&gt;evaluateChallenge()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4583d5e7e45e0fa2e945cb9ac4db80337ed6eff8" translate="yes" xml:space="preserve">
          <source>If the membership key represents a membership to receive all datagrams then the membership is dropped and the channel will no longer receive any datagrams sent to the group. If the membership key is source-specific then the channel will no longer receive datagrams sent to the group from that source address.</source>
          <target state="translated">如果成员密钥代表了接收所有数据报的成员资格,那么成员资格就会被放弃,信道将不再接收发送到该组的任何数据报。如果成员资格密钥是特定于源的,那么信道将不再接收从该源地址发送到组的数据报。</target>
        </trans-unit>
        <trans-unit id="578b6c8818072cd3e8eeb57e000ffbfdfb02eb42" translate="yes" xml:space="preserve">
          <source>If the metadata does contain tables, the tables given in a &lt;code&gt;JPEGImageWriteParam&lt;/code&gt; are ignored. Furthermore, once a set of tables has been written, only tables in the metadata can override them for subsequent writes, whether to the same stream or a different one. In order to specify new tables using this class, the &lt;a href=&quot;../../imagewriter#reset--&quot;&gt;&lt;code&gt;reset&lt;/code&gt;&lt;/a&gt; method of the writer must be called.</source>
          <target state="translated">如果元数据中确实包含表，则 &lt;code&gt;JPEGImageWriteParam&lt;/code&gt; 中给定的表将被忽略。此外，一旦写入了一组表，元数据中的表就可以覆盖它们以进行后续写入，无论是写入相同的流还是写入不同的流。为了使用此类指定新表，必须调用writer 的&lt;a href=&quot;../../imagewriter#reset--&quot;&gt; &lt;code&gt;reset&lt;/code&gt; &lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="ad0276650305bd3de8e01175bff74048c2dfe026" translate="yes" xml:space="preserve">
          <source>If the method &lt;code&gt;mark&lt;/code&gt; has not been called since the stream was created, or the number of bytes read from the stream since &lt;code&gt;mark&lt;/code&gt; was last called is larger than the argument to &lt;code&gt;mark&lt;/code&gt; at that last call, then an &lt;code&gt;IOException&lt;/code&gt; might be thrown.</source>
          <target state="translated">如果自创建流以来尚未调用方法 &lt;code&gt;mark&lt;/code&gt; ，或者自上次调用 &lt;code&gt;mark&lt;/code&gt; 以来从流读取的字节数大于上一次调用 &lt;code&gt;mark&lt;/code&gt; 的参数，则可能引发 &lt;code&gt;IOException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2cd81035982e12d53ca7e2f58a6ad2d674721fd8" translate="yes" xml:space="preserve">
          <source>If the method &lt;code&gt;markSupported&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;, then:</source>
          <target state="translated">如果方法 &lt;code&gt;markSupported&lt;/code&gt; 返回 &lt;code&gt;false&lt;/code&gt; ，则：</target>
        </trans-unit>
        <trans-unit id="864c00c6cb70175672417e9637771a48ccc4d334" translate="yes" xml:space="preserve">
          <source>If the method &lt;code&gt;markSupported&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, then:</source>
          <target state="translated">如果方法 &lt;code&gt;markSupported&lt;/code&gt; 返回 &lt;code&gt;true&lt;/code&gt; ，则：</target>
        </trans-unit>
        <trans-unit id="eaea82c9a23067ef7f772f7e498b434c683c927b" translate="yes" xml:space="preserve">
          <source>If the method call of a filter or listener throws an &lt;a href=&quot;../../java/lang/exception&quot;&gt;&lt;code&gt;Exception&lt;/code&gt;&lt;/a&gt;, then that exception does not prevent other listeners from being invoked. However, if the method call of a filter or of &lt;code&gt;Executor.execute&lt;/code&gt; or of &lt;code&gt;handleNotification&lt;/code&gt; (when no &lt;code&gt;Excecutor&lt;/code&gt; is specified) throws an &lt;a href=&quot;../../java/lang/error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt;, then that &lt;code&gt;Error&lt;/code&gt; is propagated to the caller of &lt;a href=&quot;notificationbroadcastersupport#sendNotification-javax.management.Notification-&quot;&gt;&lt;code&gt;sendNotification&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果过滤器或侦听器的方法调用抛出&lt;a href=&quot;../../java/lang/exception&quot;&gt; &lt;code&gt;Exception&lt;/code&gt; &lt;/a&gt;，则该异常不会阻止其他侦听器被调用。然而，如果或过滤器的方法调用 &lt;code&gt;Executor.execute&lt;/code&gt; 或 &lt;code&gt;handleNotification&lt;/code&gt; （当没有 &lt;code&gt;Excecutor&lt;/code&gt; 指定）时会引发&lt;a href=&quot;../../java/lang/error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt;，则该 &lt;code&gt;Error&lt;/code&gt; 被传播到的呼叫者&lt;a href=&quot;notificationbroadcastersupport#sendNotification-javax.management.Notification-&quot;&gt; &lt;code&gt;sendNotification&lt;/code&gt; 的&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="267719667d5da83b9f20baec6b480b3574e95dc7" translate="yes" xml:space="preserve">
          <source>If the method call of a filter or listener throws an &lt;a href=&quot;../../java/lang/exception&quot;&gt;&lt;code&gt;Exception&lt;/code&gt;&lt;/a&gt;, then that exception should not prevent other listeners from being invoked. However, if the method call throws an &lt;a href=&quot;../../java/lang/error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt;, then it is recommended that processing of the notification stop at that point, and if it is possible to propagate the &lt;code&gt;Error&lt;/code&gt; to the sender of the notification, this should be done.</source>
          <target state="translated">如果过滤器或侦听器的方法调用抛出&lt;a href=&quot;../../java/lang/exception&quot;&gt; &lt;code&gt;Exception&lt;/code&gt; &lt;/a&gt;，则该异常不应阻止其他侦听器的调用。但是，如果方法调用引发&lt;a href=&quot;../../java/lang/error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt;，则建议在该点停止通知的处理，并且如果有可能将 &lt;code&gt;Error&lt;/code&gt; 传播给通知的发送者，则应这样做。</target>
        </trans-unit>
        <trans-unit id="9f5c827066a55f3bfdaa44e5351bcaf2001cab9a" translate="yes" xml:space="preserve">
          <source>If the method completes normally, the value it returns is returned to the caller of invoke; if the value has a primitive type, it is first appropriately wrapped in an object. However, if the value has the type of an array of a primitive type, the elements of the array are</source>
          <target state="translated">如果方法正常完成,则将返回的值返回给调用invoke的调用者;如果值的类型为基元类型,则首先将其适当地封装在一个对象中。但是,如果值的类型为基元类型的数组,则数组中的元素会被</target>
        </trans-unit>
        <trans-unit id="16a48723a8d9e2801b89e415c711042c7335165b" translate="yes" xml:space="preserve">
          <source>If the method given to &lt;a href=&quot;compositedatainvocationhandler#invoke-java.lang.Object-java.lang.reflect.Method-java.lang.Object:A-&quot;&gt;&lt;code&gt;invoke&lt;/code&gt;&lt;/a&gt; is the method &lt;code&gt;boolean equals(Object)&lt;/code&gt; inherited from &lt;code&gt;Object&lt;/code&gt;, then it will return true if and only if the argument is a &lt;code&gt;Proxy&lt;/code&gt; whose &lt;code&gt;InvocationHandler&lt;/code&gt; is also a &lt;code&gt;CompositeDataInvocationHandler&lt;/code&gt; and whose backing &lt;code&gt;CompositeData&lt;/code&gt; is equal (not necessarily identical) to this object's. If the method given to &lt;code&gt;invoke&lt;/code&gt; is the method &lt;code&gt;int hashCode()&lt;/code&gt; inherited from &lt;code&gt;Object&lt;/code&gt;, then it will return a value that is consistent with this definition of &lt;code&gt;equals&lt;/code&gt;: if two objects are equal according to &lt;code&gt;equals&lt;/code&gt;, then they will have the same &lt;code&gt;hashCode&lt;/code&gt;.</source>
          <target state="translated">如果提供给&lt;a href=&quot;compositedatainvocationhandler#invoke-java.lang.Object-java.lang.reflect.Method-java.lang.Object:A-&quot;&gt; &lt;code&gt;invoke&lt;/code&gt; &lt;/a&gt;的方法是从 &lt;code&gt;Object&lt;/code&gt; 继承的方法 &lt;code&gt;boolean equals(Object)&lt;/code&gt; ，则仅当参数是 &lt;code&gt;InvocationHandler&lt;/code&gt; 也是 &lt;code&gt;CompositeDataInvocationHandler&lt;/code&gt; 且其后背 &lt;code&gt;CompositeData&lt;/code&gt; 等于（不一定相同）的 &lt;code&gt;Proxy&lt;/code&gt; 时，它将返回true。这个对象的。如果提供给 &lt;code&gt;invoke&lt;/code&gt; 的方法是从 &lt;code&gt;Object&lt;/code&gt; 继承的方法 &lt;code&gt;int hashCode()&lt;/code&gt; ，则它将返回与以下 &lt;code&gt;equals&lt;/code&gt; 定义一致的值：如果两个对象根据 &lt;code&gt;equals&lt;/code&gt; 相等，则它们将具有相同的 &lt;code&gt;hashCode&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2b6f07a7fdaf466e246e416a6d8be9d141006087" translate="yes" xml:space="preserve">
          <source>If the method throws an unchecked exception it is ignored except in the case of EJBs where the EJB can handle exceptions.</source>
          <target state="translated">如果方法抛出一个未被选中的异常,它将被忽略,除非在EJB的情况下,EJB可以处理异常。</target>
        </trans-unit>
        <trans-unit id="dd7f5b04deb2b9061789f4f81f1da0be43e66b30" translate="yes" xml:space="preserve">
          <source>If the method throws an unchecked exception the class MUST NOT be put into service except in the case of EJBs where the EJB can handle exceptions and even recover from them.</source>
          <target state="translated">如果方法抛出了一个未被选中的异常,那么这个类必须不被投入服务,除非在EJB的情况下,EJB可以处理异常,甚至从异常中恢复。</target>
        </trans-unit>
        <trans-unit id="71fad1ecc8a08eac94d160de9bd1bcb1628402e9" translate="yes" xml:space="preserve">
          <source>If the methods that return configuration information about the annotation processor return &lt;code&gt;null&lt;/code&gt;, return other invalid input, or throw an exception, the tool infrastructure must treat this as an error condition.</source>
          <target state="translated">如果返回有关注释处理器的配置信息的方法返回 &lt;code&gt;null&lt;/code&gt; ，返回其他无效输入或引发异常，则工具基础结构必须将此视为错误条件。</target>
        </trans-unit>
        <trans-unit id="2c345ae50909ad753edc18ff3d914c0995558637" translate="yes" xml:space="preserve">
          <source>If the named Logger already exists and does not yet have a localization resource bundle then the given resource bundle name is used. If the named Logger already exists and has a different resource bundle name then an IllegalArgumentException is thrown.</source>
          <target state="translated">如果命名的记录仪已经存在,并且尚未有本地化资源捆绑,那么将使用给定的资源捆绑名称。如果命名的记录仪已经存在,并且具有不同的资源捆绑名称,则会抛出一个 IllegalArgumentException。</target>
        </trans-unit>
        <trans-unit id="68506597c2f99be04b0f47ace8cfa88608b7a8be" translate="yes" xml:space="preserve">
          <source>If the named class is not a top-level class, this invocation will have no effect on the actual assertion status of any class.</source>
          <target state="translated">如果命名的类不是顶层类,那么这个调用将不会对任何类的实际断言状态产生影响。</target>
        </trans-unit>
        <trans-unit id="482df42008c5e582c9e2d80de4a8c2c7a964f035" translate="yes" xml:space="preserve">
          <source>If the named file does not exist, is a directory rather than a regular file, or for some other reason cannot be opened for reading then a &lt;code&gt;FileNotFoundException&lt;/code&gt; is thrown.</source>
          <target state="translated">如果命名文件不存在，是目录而不是常规文件，或者由于某些其他原因而无法打开文件进行读取，则抛出 &lt;code&gt;FileNotFoundException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="95905c4bd2793861fb30aaa68b18d361d2c40205" translate="yes" xml:space="preserve">
          <source>If the named object is not a DirContext, search only the object. If the named object is a DirContext, search the subtree rooted at the named object, including the named object itself.</source>
          <target state="translated">如果命名的对象不是DirContext,则只搜索该对象。如果命名对象是DirContext,则搜索以命名对象为根的子树,包括命名对象本身。</target>
        </trans-unit>
        <trans-unit id="a797ab321ba29b078906111b6a9d36444e539b67" translate="yes" xml:space="preserve">
          <source>If the nano-of-second is zero or not available then the format is complete.</source>
          <target state="translated">如果nano-of-second为0或不可用,则格式完整。</target>
        </trans-unit>
        <trans-unit id="18bffcd626a18ef77083ada33a312e98a304ff4c" translate="yes" xml:space="preserve">
          <source>If the new level is null, it means that this node should inherit its level from its nearest ancestor with a specific (non-null) level value.</source>
          <target state="translated">如果新的级别为空,则意味着这个节点应该从它最近的祖先那里继承它的级别,并有一个特定的(非空)级别值。</target>
        </trans-unit>
        <trans-unit id="bc536a2662e091e215ec8f641a7473d3709fe706" translate="yes" xml:space="preserve">
          <source>If the new lookup class differs from the old one, protected members will not be accessible by virtue of inheritance. (Protected members may continue to be accessible because of package sharing.)</source>
          <target state="translated">如果新的查找类与旧的查找类不同,受保护的成员将不能通过继承来访问。(由于包的共享,受保护的成员可以继续被访问。)</target>
        </trans-unit>
        <trans-unit id="60f2db2d23a3b70ce0836cac49cb47c5b9f6353f" translate="yes" xml:space="preserve">
          <source>If the new lookup class is in a different package than the old one, protected and default (package) members will not be accessible.</source>
          <target state="translated">如果新的查找类与旧的查找类在不同的包中,那么受保护的和默认的(包)成员将无法访问。</target>
        </trans-unit>
        <trans-unit id="ca96aa918a0139c5241a9be60ea7a47fde358969" translate="yes" xml:space="preserve">
          <source>If the new lookup class is not accessible to the old lookup class, then no members, not even public members, will be accessible. (In all other cases, public members will continue to be accessible.)</source>
          <target state="translated">如果新的查找类不能被旧的查找类访问,那么任何成员,甚至公共成员都不会被访问。在所有其他情况下,公共成员将继续被访问)。</target>
        </trans-unit>
        <trans-unit id="1a7e98a2066ab4c0cf93405953a8d0cbcca7cb64" translate="yes" xml:space="preserve">
          <source>If the new lookup class is not within the same package member as the old one, private members will not be accessible.</source>
          <target state="translated">如果新的查找类与旧的查找类不在同一个包成员内,私有成员将无法访问。</target>
        </trans-unit>
        <trans-unit id="070950b6983687a52f5c8a4982aa2eebcfd77d61" translate="yes" xml:space="preserve">
          <source>If the next token matches the &lt;a href=&quot;#Decimal-regex&quot;&gt;&lt;i&gt;Decimal&lt;/i&gt;&lt;/a&gt; regular expression defined above then the token is converted into a &lt;code&gt;BigDecimal&lt;/code&gt; value as if by removing all group separators, mapping non-ASCII digits into ASCII digits via the &lt;a href=&quot;../lang/character#digit-char-int-&quot;&gt;&lt;code&gt;Character.digit&lt;/code&gt;&lt;/a&gt;, and passing the resulting string to the &lt;a href=&quot;../math/bigdecimal#BigDecimal-java.lang.String-&quot;&gt;&lt;code&gt;BigDecimal(String)&lt;/code&gt;&lt;/a&gt; constructor.</source>
          <target state="translated">如果下一个标记与上面定义的&lt;a href=&quot;#Decimal-regex&quot;&gt;&lt;i&gt;Decimal&lt;/i&gt;&lt;/a&gt;正则表达式匹配，则将该标记转换为 &lt;code&gt;BigDecimal&lt;/code&gt; 值，就像通过删除所有组分隔符，通过&lt;a href=&quot;../lang/character#digit-char-int-&quot;&gt; &lt;code&gt;Character.digit&lt;/code&gt; &lt;/a&gt;将非ASCII数字映射为ASCII数字并将结果字符串传递给&lt;a href=&quot;../math/bigdecimal#BigDecimal-java.lang.String-&quot;&gt; &lt;code&gt;BigDecimal(String)&lt;/code&gt; &lt;/a&gt;构造函数。</target>
        </trans-unit>
        <trans-unit id="e2b55b595ce54b4c7a0ff65ce30ecb0da6b4383c" translate="yes" xml:space="preserve">
          <source>If the next token matches the &lt;a href=&quot;#Float-regex&quot;&gt;&lt;i&gt;Float&lt;/i&gt;&lt;/a&gt; regular expression defined above then the token is converted into a &lt;code&gt;double&lt;/code&gt; value as if by removing all locale specific prefixes, group separators, and locale specific suffixes, then mapping non-ASCII digits into ASCII digits via &lt;a href=&quot;../lang/character#digit-char-int-&quot;&gt;&lt;code&gt;Character.digit&lt;/code&gt;&lt;/a&gt;, prepending a negative sign (-) if the locale specific negative prefixes and suffixes were present, and passing the resulting string to &lt;a href=&quot;../lang/double#parseDouble-java.lang.String-&quot;&gt;&lt;code&gt;Double.parseDouble&lt;/code&gt;&lt;/a&gt;. If the token matches the localized NaN or infinity strings, then either &quot;Nan&quot; or &quot;Infinity&quot; is passed to &lt;a href=&quot;../lang/double#parseDouble-java.lang.String-&quot;&gt;&lt;code&gt;Double.parseDouble&lt;/code&gt;&lt;/a&gt; as appropriate.</source>
          <target state="translated">如果下一个标记与上面定义的&lt;a href=&quot;#Float-regex&quot;&gt;&lt;i&gt;Float&lt;/i&gt;&lt;/a&gt;正则表达式匹配，则该标记将转换为 &lt;code&gt;double&lt;/code&gt; 值，就像通过删除所有特定于语言环境的前缀，组分隔符和特定于语言环境的后缀，然后通过&lt;a href=&quot;../lang/character#digit-char-int-&quot;&gt; &lt;code&gt;Character.digit&lt;/code&gt; &lt;/a&gt;将非ASCII数字映射为ASCII数字一样。，如果存在特定于语言环境的否定前缀和后缀，则在其前面加上一个负号（-），并将结果字符串传递给&lt;a href=&quot;../lang/double#parseDouble-java.lang.String-&quot;&gt; &lt;code&gt;Double.parseDouble&lt;/code&gt; &lt;/a&gt;。如果令牌与本地化的NaN或无穷大字符串匹配，则将&amp;ldquo; Nan&amp;rdquo;或&amp;ldquo; Infinity&amp;rdquo; 适当地传递给&lt;a href=&quot;../lang/double#parseDouble-java.lang.String-&quot;&gt; &lt;code&gt;Double.parseDouble&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6a79c16b442949a70d19c9e0f0f3c3e6d85edf9f" translate="yes" xml:space="preserve">
          <source>If the next token matches the &lt;a href=&quot;#Float-regex&quot;&gt;&lt;i&gt;Float&lt;/i&gt;&lt;/a&gt; regular expression defined above then the token is converted into a &lt;code&gt;float&lt;/code&gt; value as if by removing all locale specific prefixes, group separators, and locale specific suffixes, then mapping non-ASCII digits into ASCII digits via &lt;a href=&quot;../lang/character#digit-char-int-&quot;&gt;&lt;code&gt;Character.digit&lt;/code&gt;&lt;/a&gt;, prepending a negative sign (-) if the locale specific negative prefixes and suffixes were present, and passing the resulting string to &lt;a href=&quot;../lang/float#parseFloat-java.lang.String-&quot;&gt;&lt;code&gt;Float.parseFloat&lt;/code&gt;&lt;/a&gt;. If the token matches the localized NaN or infinity strings, then either &quot;Nan&quot; or &quot;Infinity&quot; is passed to &lt;a href=&quot;../lang/float#parseFloat-java.lang.String-&quot;&gt;&lt;code&gt;Float.parseFloat&lt;/code&gt;&lt;/a&gt; as appropriate.</source>
          <target state="translated">如果下一个标记与上面定义的&lt;a href=&quot;#Float-regex&quot;&gt;&lt;i&gt;Float&lt;/i&gt;&lt;/a&gt;正则表达式匹配，则该标记将转换为 &lt;code&gt;float&lt;/code&gt; 值，就像通过删除所有特定于语言环境的前缀，组分隔符和特定于语言环境的后缀，然后通过&lt;a href=&quot;../lang/character#digit-char-int-&quot;&gt; &lt;code&gt;Character.digit&lt;/code&gt; &lt;/a&gt;将非ASCII数字映射为ASCII数字一样。，如果存在特定于语言环境的否定前缀和后缀，则在其前面加上一个负号（-），并将结果字符串传递给&lt;a href=&quot;../lang/float#parseFloat-java.lang.String-&quot;&gt; &lt;code&gt;Float.parseFloat&lt;/code&gt; &lt;/a&gt;。如果令牌与本地化的NaN或无穷大字符串匹配，则将&amp;ldquo; Nan&amp;rdquo;或&amp;ldquo; Infinity&amp;rdquo; 适当地传递给&lt;a href=&quot;../lang/float#parseFloat-java.lang.String-&quot;&gt; &lt;code&gt;Float.parseFloat&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1a4727cf6304247402307e6eaca3eff6d0258644" translate="yes" xml:space="preserve">
          <source>If the next token matches the &lt;a href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;Integer&lt;/i&gt;&lt;/a&gt; regular expression defined above then the token is converted into a &lt;code&gt;BigInteger&lt;/code&gt; value as if by removing all group separators, mapping non-ASCII digits into ASCII digits via the &lt;a href=&quot;../lang/character#digit-char-int-&quot;&gt;&lt;code&gt;Character.digit&lt;/code&gt;&lt;/a&gt;, and passing the resulting string to the &lt;a href=&quot;../math/biginteger#BigInteger-java.lang.String-&quot;&gt;&lt;code&gt;BigInteger(String, int)&lt;/code&gt;&lt;/a&gt; constructor with the specified radix.</source>
          <target state="translated">如果下一个标记与上面定义的&lt;a href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;Integer&lt;/i&gt;&lt;/a&gt;正则表达式匹配，则将该标记转换为 &lt;code&gt;BigInteger&lt;/code&gt; 值，就像通过删除所有组分隔符，通过&lt;a href=&quot;../lang/character#digit-char-int-&quot;&gt; &lt;code&gt;Character.digit&lt;/code&gt; &lt;/a&gt;将非ASCII数字映射为ASCII数字并将结果字符串传递给&lt;a href=&quot;../math/biginteger#BigInteger-java.lang.String-&quot;&gt; &lt;code&gt;BigInteger(String, int)&lt;/code&gt; &lt;/a&gt;具有指定基数的构造函数。</target>
        </trans-unit>
        <trans-unit id="12b289473a0cfbe9016bed30eea7221cdd374181" translate="yes" xml:space="preserve">
          <source>If the next token matches the &lt;a href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;Integer&lt;/i&gt;&lt;/a&gt; regular expression defined above then the token is converted into a &lt;code&gt;byte&lt;/code&gt; value as if by removing all locale specific prefixes, group separators, and locale specific suffixes, then mapping non-ASCII digits into ASCII digits via &lt;a href=&quot;../lang/character#digit-char-int-&quot;&gt;&lt;code&gt;Character.digit&lt;/code&gt;&lt;/a&gt;, prepending a negative sign (-) if the locale specific negative prefixes and suffixes were present, and passing the resulting string to &lt;a href=&quot;../lang/byte#parseByte-java.lang.String-int-&quot;&gt;&lt;code&gt;Byte.parseByte&lt;/code&gt;&lt;/a&gt; with the specified radix.</source>
          <target state="translated">如果下一个标记与上面定义的&lt;a href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;Integer&lt;/i&gt;&lt;/a&gt;正则表达式匹配，则该标记将转换为 &lt;code&gt;byte&lt;/code&gt; 值，就像通过删除所有特定于语言环境的前缀，组分隔符和特定于语言环境的后缀，然后通过&lt;a href=&quot;../lang/character#digit-char-int-&quot;&gt; &lt;code&gt;Character.digit&lt;/code&gt; &lt;/a&gt;将非ASCII数字映射为ASCII数字一样。，如果存在特定于语言环境的否定前缀和后缀，则在其前面加上一个负号（-），并将结果字符串传递给具有指定基数的&lt;a href=&quot;../lang/byte#parseByte-java.lang.String-int-&quot;&gt; &lt;code&gt;Byte.parseByte&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b349deb1d290eaa1752d8feff84d8af8caefc093" translate="yes" xml:space="preserve">
          <source>If the next token matches the &lt;a href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;Integer&lt;/i&gt;&lt;/a&gt; regular expression defined above then the token is converted into a &lt;code&gt;long&lt;/code&gt; value as if by removing all locale specific prefixes, group separators, and locale specific suffixes, then mapping non-ASCII digits into ASCII digits via &lt;a href=&quot;../lang/character#digit-char-int-&quot;&gt;&lt;code&gt;Character.digit&lt;/code&gt;&lt;/a&gt;, prepending a negative sign (-) if the locale specific negative prefixes and suffixes were present, and passing the resulting string to &lt;a href=&quot;../lang/long#parseLong-java.lang.String-int-&quot;&gt;&lt;code&gt;Long.parseLong&lt;/code&gt;&lt;/a&gt; with the specified radix.</source>
          <target state="translated">如果下一个标记与上面定义的&lt;a href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;Integer&lt;/i&gt;&lt;/a&gt;正则表达式匹配，则该标记将转换为 &lt;code&gt;long&lt;/code&gt; 值，就像通过删除所有特定于语言环境的前缀，组分隔符和特定于语言环境的后缀，然后通过&lt;a href=&quot;../lang/character#digit-char-int-&quot;&gt; &lt;code&gt;Character.digit&lt;/code&gt; &lt;/a&gt;将非ASCII数字映射为ASCII数字一样。，如果存在特定于语言环境的否定前缀和后缀，则在其前面加上一个负号（-），并将结果字符串传递给具有指定基数的&lt;a href=&quot;../lang/long#parseLong-java.lang.String-int-&quot;&gt; &lt;code&gt;Long.parseLong&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cde2372e3435e6554a5b5741f761096f7eea5fcf" translate="yes" xml:space="preserve">
          <source>If the next token matches the &lt;a href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;Integer&lt;/i&gt;&lt;/a&gt; regular expression defined above then the token is converted into a &lt;code&gt;short&lt;/code&gt; value as if by removing all locale specific prefixes, group separators, and locale specific suffixes, then mapping non-ASCII digits into ASCII digits via &lt;a href=&quot;../lang/character#digit-char-int-&quot;&gt;&lt;code&gt;Character.digit&lt;/code&gt;&lt;/a&gt;, prepending a negative sign (-) if the locale specific negative prefixes and suffixes were present, and passing the resulting string to &lt;a href=&quot;../lang/short#parseShort-java.lang.String-int-&quot;&gt;&lt;code&gt;Short.parseShort&lt;/code&gt;&lt;/a&gt; with the specified radix.</source>
          <target state="translated">如果下一个标记与上面定义的&lt;a href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;Integer&lt;/i&gt;&lt;/a&gt;正则表达式匹配，则该标记将转换为 &lt;code&gt;short&lt;/code&gt; 值，就像通过删除所有特定于语言环境的前缀，组分隔符和特定于语言环境的后缀，然后通过&lt;a href=&quot;../lang/character#digit-char-int-&quot;&gt; &lt;code&gt;Character.digit&lt;/code&gt; &lt;/a&gt;将非ASCII数字映射为ASCII数字一样。，如果存在特定于语言环境的负前缀和后缀，则在前面加上一个负号（-），然后将结果字符串传递给具有指定基数的&lt;a href=&quot;../lang/short#parseShort-java.lang.String-int-&quot;&gt; &lt;code&gt;Short.parseShort&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e2e6b9af16a7a0f10ca898c5788d2527ee4c8561" translate="yes" xml:space="preserve">
          <source>If the next token matches the &lt;a href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;Integer&lt;/i&gt;&lt;/a&gt; regular expression defined above then the token is converted into an &lt;code&gt;int&lt;/code&gt; value as if by removing all locale specific prefixes, group separators, and locale specific suffixes, then mapping non-ASCII digits into ASCII digits via &lt;a href=&quot;../lang/character#digit-char-int-&quot;&gt;&lt;code&gt;Character.digit&lt;/code&gt;&lt;/a&gt;, prepending a negative sign (-) if the locale specific negative prefixes and suffixes were present, and passing the resulting string to &lt;a href=&quot;../lang/integer#parseInt-java.lang.String-int-&quot;&gt;&lt;code&gt;Integer.parseInt&lt;/code&gt;&lt;/a&gt; with the specified radix.</source>
          <target state="translated">如果下一个标记与上面定义的&lt;a href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;Integer&lt;/i&gt;&lt;/a&gt;正则表达式匹配，则将该标记转换为 &lt;code&gt;int&lt;/code&gt; 值，就像通过删除所有特定于语言环境的前缀，组分隔符和特定于语言环境的后缀，然后通过&lt;a href=&quot;../lang/character#digit-char-int-&quot;&gt; &lt;code&gt;Character.digit&lt;/code&gt; &lt;/a&gt;将非ASCII数字映射为ASCII数字一样。，如果存在特定于语言环境的负前缀和后缀，则在其前加上一个负号（-），然后将结果字符串以指定的基数传递给&lt;a href=&quot;../lang/integer#parseInt-java.lang.String-int-&quot;&gt; &lt;code&gt;Integer.parseInt&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="50647ef6cfa173ffb331678172077c93b906dc08" translate="yes" xml:space="preserve">
          <source>If the number is followed by a colon, it is regarded as an hour, unless an hour has already been recognized, in which case it is regarded as a minute.</source>
          <target state="translated">如果数字后面有冒号,则视为小时,除非已经承认了小时,在这种情况下,则视为分钟。</target>
        </trans-unit>
        <trans-unit id="2185b02dab1b8be5d039095147b6a86e141a45f4" translate="yes" xml:space="preserve">
          <source>If the number is followed by a slash, it is regarded as a month (it is decreased by 1 to produce a number in the range &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;11&lt;/code&gt;), unless a month has already been recognized, in which case it is regarded as a day of the month.</source>
          <target state="translated">如果数字后跟斜杠，则将其视为月份（将数字减1以产生介于 &lt;code&gt;0&lt;/code&gt; 到 &lt;code&gt;11&lt;/code&gt; 之间的数字），除非已经识别出月份，则将其视为一天。这个月。</target>
        </trans-unit>
        <trans-unit id="24c204655d0c4e49fdb27ee92ac3fcb02b0bfac3" translate="yes" xml:space="preserve">
          <source>If the number is followed by whitespace, a comma, a hyphen, or end of string, then if an hour has been recognized but not a minute, it is regarded as a minute; otherwise, if a minute has been recognized but not a second, it is regarded as a second; otherwise, it is regarded as a day of the month.</source>
          <target state="translated">如果数字后面有空格、逗号、连字符或字符串末尾,则认准了小时而没有认准分钟,则视为分钟;否则认准了分钟而没有认准秒,则视为秒;否则视为月日。</target>
        </trans-unit>
        <trans-unit id="28b1d7370c2a1b58a891d34fad7ee082b38756d3" translate="yes" xml:space="preserve">
          <source>If the number of arguments in the specified constructor is non-zero and the class of &lt;code&gt;oldInstance&lt;/code&gt; explicitly declares an &quot;equals&quot; method this method returns the value of &lt;code&gt;oldInstance.equals(newInstance)&lt;/code&gt;. Otherwise, this method uses the superclass's definition which returns true if the classes of the two instances are equal.</source>
          <target state="translated">如果指定构造函数中的参数数量为非零，并且 &lt;code&gt;oldInstance&lt;/code&gt; 类显式声明了一个&amp;ldquo;等于&amp;rdquo;方法，则此方法返回 &lt;code&gt;oldInstance.equals(newInstance)&lt;/code&gt; 的值。否则，此方法使用超类的定义，如果两个实例的类相等，则返回true。</target>
        </trans-unit>
        <trans-unit id="d4af9d2d4726a8f3ade67f849e06bc1d1ab1564a" translate="yes" xml:space="preserve">
          <source>If the number of formal parameters required by the underlying constructor is 0, the supplied &lt;code&gt;initargs&lt;/code&gt; array may be of length 0 or null.</source>
          <target state="translated">如果基础构造函数所需的形式参数数量为0，则提供的 &lt;code&gt;initargs&lt;/code&gt; 数组的长度可以为0或为null。</target>
        </trans-unit>
        <trans-unit id="1a45750d8cf5475f9813ae9cb718f088a466add3" translate="yes" xml:space="preserve">
          <source>If the number of formal parameters required by the underlying method is 0, the supplied &lt;code&gt;args&lt;/code&gt; array may be of length 0 or null.</source>
          <target state="translated">如果基础方法所需的形式参数数量为0，则提供的 &lt;code&gt;args&lt;/code&gt; 数组的长度可以为0或为null。</target>
        </trans-unit>
        <trans-unit id="aecea4a5924a64f71d7845e41d1c3b018c067a01" translate="yes" xml:space="preserve">
          <source>If the number of pattern letters is 4 or more, &lt;a href=&quot;../lang/illegalargumentexception&quot;&gt;&lt;code&gt;IllegalArgumentException&lt;/code&gt;&lt;/a&gt; is thrown when constructing a &lt;code&gt;SimpleDateFormat&lt;/code&gt; or &lt;a href=&quot;simpledateformat#applyPattern-java.lang.String-&quot;&gt;applying a pattern&lt;/a&gt;.</source>
          <target state="translated">如果模式字母的数量为4个或更多，则在构造 &lt;code&gt;SimpleDateFormat&lt;/code&gt; 或&lt;a href=&quot;simpledateformat#applyPattern-java.lang.String-&quot;&gt;应用pattern&lt;/a&gt;时将抛出&lt;a href=&quot;../lang/illegalargumentexception&quot;&gt; &lt;code&gt;IllegalArgumentException&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="40ebc6195d83e88d053f6b7f4d083dcca34d15e6" translate="yes" xml:space="preserve">
          <source>If the number of readers is now zero then the lock is made available for write lock attempts.</source>
          <target state="translated">如果现在读者的数量为零,那么该锁就可以用于写锁的尝试。</target>
        </trans-unit>
        <trans-unit id="9539dfa1e1c4ed8a395e2b48d8e6f0bcbf6c71d0" translate="yes" xml:space="preserve">
          <source>If the object does not have a requested attribute, that nonexistent attribute will be ignored. Those requested attributes that the object does have will be returned.</source>
          <target state="translated">如果对象没有请求的属性,那么不存在的属性将被忽略。那些对象有的请求属性将被返回。</target>
        </trans-unit>
        <trans-unit id="ba188f9b3d08b409858ffc14dad0538d6c066ad5" translate="yes" xml:space="preserve">
          <source>If the object does not have an attribute specified, the directory will ignore the nonexistent attribute and return those requested attributes that the object does have.</source>
          <target state="translated">如果对象没有指定属性,目录将忽略不存在的属性,并返回对象有的请求属性。</target>
        </trans-unit>
        <trans-unit id="1d2b3a1e7cd5b23b39d1f5133dc5c01a091b5bb9" translate="yes" xml:space="preserve">
          <source>If the object does not have the attribute specified, the directory will ignore the nonexistent attribute and return the requested attributes that the object does have.</source>
          <target state="translated">如果对象没有指定的属性,目录将忽略不存在的属性,并返回对象确实存在的请求属性。</target>
        </trans-unit>
        <trans-unit id="f7640b018347f47539ec443ff012615b370426e4" translate="yes" xml:space="preserve">
          <source>If the object has a &lt;code&gt;getPropertyChangeListeners&lt;/code&gt; method then the array returned could be a mixture of &lt;code&gt;PropertyChangeListener&lt;/code&gt; and &lt;code&gt;PropertyChangeListenerProxy&lt;/code&gt; objects.</source>
          <target state="translated">如果对象具有 &lt;code&gt;getPropertyChangeListeners&lt;/code&gt; 方法，则返回的数组可能是 &lt;code&gt;PropertyChangeListener&lt;/code&gt; 和 &lt;code&gt;PropertyChangeListenerProxy&lt;/code&gt; 对象的混合。</target>
        </trans-unit>
        <trans-unit id="3efaaa6db916f5e8dd0c50701e6e2af84aea78e5" translate="yes" xml:space="preserve">
          <source>If the object has a &lt;code&gt;getVetoableChangeListeners&lt;/code&gt; method then the array returned could be a mixture of &lt;code&gt;VetoableChangeListener&lt;/code&gt; and &lt;code&gt;VetoableChangeListenerProxy&lt;/code&gt; objects.</source>
          <target state="translated">如果对象具有 &lt;code&gt;getVetoableChangeListeners&lt;/code&gt; 方法，则返回的数组可能是 &lt;code&gt;VetoableChangeListener&lt;/code&gt; 和 &lt;code&gt;VetoableChangeListenerProxy&lt;/code&gt; 对象的混合。</target>
        </trans-unit>
        <trans-unit id="c633f6da7ab2fee69bd882fac3b3abc472fa5a8a" translate="yes" xml:space="preserve">
          <source>If the object is a &lt;code&gt;DirContext&lt;/code&gt;, any existing attributes associated with the name are replaced with those of the object. Otherwise, any existing attributes associated with the name remain unchanged.</source>
          <target state="translated">如果对象是 &lt;code&gt;DirContext&lt;/code&gt; ，则与该名称关联的所有现有属性都将替换为该对象的那些属性。否则，与该名称关联的任何现有属性均保持不变。</target>
        </trans-unit>
        <trans-unit id="4f5b3142d8650d58dfbe46a9e556320ac2bd2e7d" translate="yes" xml:space="preserve">
          <source>If the offset is not available then the format is complete.</source>
          <target state="translated">如果没有偏移量,则格式完整。</target>
        </trans-unit>
        <trans-unit id="2519e323e000b11bce96906bcfd196efd2dc89f9" translate="yes" xml:space="preserve">
          <source>If the offset is not available to format or parse then the format is complete.</source>
          <target state="translated">如果偏移量不可用于格式化或解析,则格式化完成。</target>
        </trans-unit>
        <trans-unit id="4c280c860cb9f7effbb5d1573c9db972ff6dade1" translate="yes" xml:space="preserve">
          <source>If the opaque representation of a key (see &lt;a href=&quot;../key&quot;&gt;&lt;code&gt;Key&lt;/code&gt;&lt;/a&gt;) can be transformed (see &lt;a href=&quot;../keyfactory&quot;&gt;&lt;code&gt;KeyFactory&lt;/code&gt;&lt;/a&gt;) into this key specification (or a subclass of it), &lt;code&gt;getFormat&lt;/code&gt; called on the opaque key returns the same value as the &lt;code&gt;getFormat&lt;/code&gt; method of this key specification.</source>
          <target state="translated">如果可以将键的不透明表示形式（请参见&lt;a href=&quot;../key&quot;&gt; &lt;code&gt;Key&lt;/code&gt; &lt;/a&gt;）转换（请参见&lt;a href=&quot;../keyfactory&quot;&gt; &lt;code&gt;KeyFactory&lt;/code&gt; &lt;/a&gt;）到此键规范（或其子类）中，则在不透明键上调用的 &lt;code&gt;getFormat&lt;/code&gt; 返回的值与此键规范的 &lt;code&gt;getFormat&lt;/code&gt; 方法相同。</target>
        </trans-unit>
        <trans-unit id="a3a6f1065b50c79f203f06252e6050cc498ea0ba" translate="yes" xml:space="preserve">
          <source>If the original type and new type are equal, returns &lt;code&gt;this&lt;/code&gt;.</source>
          <target state="translated">如果原始类型和新类型相等，则返回 &lt;code&gt;this&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="15d571df526b560a24fbbc6f542b12d585fc4182" translate="yes" xml:space="preserve">
          <source>If the original type and new type are equal, returns target.</source>
          <target state="translated">如果原始类型和新类型相同,返回target。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
