<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="openjdk">
    <body>
      <group id="openjdk">
        <trans-unit id="4679bfab8bdf1a02bfe30406e4c9f7a2085873a2" translate="yes" xml:space="preserve">
          <source>The ISO 3166-1 codes can be found on-line.</source>
          <target state="translated">ISO 3166-1代码可以在网上找到。</target>
        </trans-unit>
        <trans-unit id="611dd8f9d48699c9411b9432a1cb2dc63863602c" translate="yes" xml:space="preserve">
          <source>The ISO calendar system behaves as follows:</source>
          <target state="translated">国际标准化组织日历系统的运作方式如下:</target>
        </trans-unit>
        <trans-unit id="6082f991bd981467ab45e2ffde3309b5e82f6280" translate="yes" xml:space="preserve">
          <source>The ISO calendar system defines an additional week-based division of years. This defines a year based on whole Monday to Monday weeks. This is modeled in &lt;a href=&quot;isofields&quot;&gt;&lt;code&gt;IsoFields&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ISO日历系统定义了一个额外的基于周的年划分。这定义了基于整个星期一到星期一的一年。这是在&lt;a href=&quot;isofields&quot;&gt; &lt;code&gt;IsoFields&lt;/code&gt; 中&lt;/a&gt;建模的。</target>
        </trans-unit>
        <trans-unit id="4d077fd16854767d357096f809fb7b81bacb82c7" translate="yes" xml:space="preserve">
          <source>The ISO calendar system.</source>
          <target state="translated">国际标准化组织的日历系统;</target>
        </trans-unit>
        <trans-unit id="58e26e3bf55479a8a5120fe45b369953d4715df2" translate="yes" xml:space="preserve">
          <source>The ISO date formatter that formats or parses a date with an offset, such as '2011-12-03+01:00'.</source>
          <target state="translated">ISO日期格式化器,用于格式化或解析带有偏移量的日期,如'2011-12-03+01:00'。</target>
        </trans-unit>
        <trans-unit id="6de9417addd60d61c439ecd60520ce653b7ff208" translate="yes" xml:space="preserve">
          <source>The ISO date formatter that formats or parses a date with the offset if available, such as '2011-12-03' or '2011-12-03+01:00'.</source>
          <target state="translated">ISO日期格式化器,格式化或解析带有偏移量的日期,如'2011-12-03'或'2011-12-03+01:00'。</target>
        </trans-unit>
        <trans-unit id="2bed7eaa4131a3fd0eed3c41b0dc86a015ca96db" translate="yes" xml:space="preserve">
          <source>The ISO date formatter that formats or parses a date without an offset, such as '2011-12-03'.</source>
          <target state="translated">ISO日期格式化器,可以格式化或解析没有偏移量的日期,如'2011-12-03'。</target>
        </trans-unit>
        <trans-unit id="21efec4c9a9cd99bd7c37c45effa030d9f01c4ca" translate="yes" xml:space="preserve">
          <source>The ISO date formatter that formats or parses a date without an offset, such as '20111203'.</source>
          <target state="translated">ISO日期格式化器,可以格式化或解析一个没有偏移量的日期,如'20111203'。</target>
        </trans-unit>
        <trans-unit id="5e79ab154ec99d657cac16998df6c24432d36bfb" translate="yes" xml:space="preserve">
          <source>The ISO date formatter that formats or parses the ordinal date without an offset, such as '2012-337'.</source>
          <target state="translated">ISO日期格式化器,它可以格式化或解析没有偏移量的顺序日期,如'2012-337'。</target>
        </trans-unit>
        <trans-unit id="8947499950b72303579b6072a1f0f70410f938f9" translate="yes" xml:space="preserve">
          <source>The ISO date formatter that formats or parses the week-based date without an offset, such as '2012-W48-6'.</source>
          <target state="translated">ISO日期格式化器,它可以格式化或解析以星期为基础的日期,而不需要偏移量,例如'2012-W48-6'。</target>
        </trans-unit>
        <trans-unit id="ad4a4f923ef1dd96afdbb263d3503d29224e8ce9" translate="yes" xml:space="preserve">
          <source>The ISO date of the first day of the minimum Hijrah year.</source>
          <target state="translated">最低希吉拉年第一天的ISO日期;</target>
        </trans-unit>
        <trans-unit id="ab2094bfe0e934a818f591f8e39df5d0c0f5b428" translate="yes" xml:space="preserve">
          <source>The ISO date-time formatter that formats or parses a date-time with an offset, such as '2011-12-03T10:15:30+01:00'.</source>
          <target state="translated">ISO日期-时间格式化器,用于格式化或解析带有偏移量的日期-时间,如'2011-12-03T10:15:30+01:00'。</target>
        </trans-unit>
        <trans-unit id="b7f380848807763c304877a683626ef209b2dd72" translate="yes" xml:space="preserve">
          <source>The ISO date-time formatter that formats or parses a date-time without an offset, such as '2011-12-03T10:15:30'.</source>
          <target state="translated">ISO日期-时间格式化器,可以格式化或解析没有偏移量的日期-时间,如'2011-12-03T10:15:30'。</target>
        </trans-unit>
        <trans-unit id="bd2f9f3c47232e93e12ebe7e08b1617ed46664af" translate="yes" xml:space="preserve">
          <source>The ISO instant formatter that formats or parses an instant in UTC, such as '2011-12-03T10:15:30Z'.</source>
          <target state="translated">ISO即时格式化器,以UTC格式化或解析即时,如'2011-12-03T10:15:30Z'。</target>
        </trans-unit>
        <trans-unit id="95a52b961a46e25216875fca80e6d411d7ab598a" translate="yes" xml:space="preserve">
          <source>The ISO time formatter that formats or parses a time with an offset, such as '10:15+01:00' or '10:15:30+01:00'.</source>
          <target state="translated">ISO时间格式化器,可格式化或解析带有偏移量的时间,如'10:15+01:00'或'10:15:30+01:00'。</target>
        </trans-unit>
        <trans-unit id="df2987c695a53ce54ed87dd02ab3fbad12667817" translate="yes" xml:space="preserve">
          <source>The ISO time formatter that formats or parses a time without an offset, such as '10:15' or '10:15:30'.</source>
          <target state="translated">ISO时间格式化器,可以格式化或解析没有偏移的时间,如'10:15'或'10:15:30'。</target>
        </trans-unit>
        <trans-unit id="d335e1639bd2cf2c6fa963a589bd508ea6cff667" translate="yes" xml:space="preserve">
          <source>The ISO time formatter that formats or parses a time, with the offset if available, such as '10:15', '10:15:30' or '10:15:30+01:00'.</source>
          <target state="translated">ISO时间格式化,格式化或解析时间,如果有偏移量,如'10:15'、'10:15:30'或'10:15:30+01:00'。</target>
        </trans-unit>
        <trans-unit id="0a3f5206473b8e9b0e863ce6a87c607ec16d4baa" translate="yes" xml:space="preserve">
          <source>The ISO-8601 calendar system is the modern civil calendar system used today in most of the world. It is equivalent to the proleptic Gregorian calendar system, in which today's rules for leap years are applied for all time.</source>
          <target state="translated">ISO-8601日历系统是当今世界大多数国家使用的现代民用日历系统。它相当于近似格里高利历法,在这个历法中,今天的闰年规则适用于所有时间。</target>
        </trans-unit>
        <trans-unit id="6b0753a83aa00ab66715a1d0bce536d311b35dee" translate="yes" xml:space="preserve">
          <source>The ISO-8601 calendar system is the modern civil calendar system used today in most of the world. It is equivalent to the proleptic Gregorian calendar system, in which today's rules for leap years are applied for all time. For most applications written today, the ISO-8601 rules are entirely suitable. However, any application that makes use of historical dates, and requires them to be accurate will find the ISO-8601 approach unsuitable.</source>
          <target state="translated">ISO-8601日历系统是当今世界大多数国家使用的现代民用日历系统。它相当于无序的格里高利历系统,在这个系统中,今天的闰年规则适用于所有时间。对于今天编写的大多数应用程序,ISO-8601规则是完全合适的。然而,任何使用历史日期并要求它们准确的应用程序都会发现ISO-8601方法不合适。</target>
        </trans-unit>
        <trans-unit id="2b87b0b3d3f02384c82a8cdf0d2d60d19047ef46" translate="yes" xml:space="preserve">
          <source>The ISO-8601 calendar system is the modern civil calendar system used today in most of the world. This API assumes that all calendar systems use the same representation, this class, for time-of-day.</source>
          <target state="translated">ISO-8601日历系统是当今世界上大多数国家使用的现代民用日历系统。这个API假定所有的日历系统都使用相同的表示方法,即这个类,来表示时间-日期。</target>
        </trans-unit>
        <trans-unit id="24cf4f50b66f15436634e4e63889e0eeb0811579" translate="yes" xml:space="preserve">
          <source>The ISO-8601 definition, where a week starts on Monday and the first week has a minimum of 4 days.</source>
          <target state="translated">ISO-8601定义,一周从周一开始,第一周至少有4天。</target>
        </trans-unit>
        <trans-unit id="ea56e5764492774cbd5793c14b636ad2fff88f1f" translate="yes" xml:space="preserve">
          <source>The ISO-8601 standard defines a calendar system based on weeks. It uses the week-based-year and week-of-week-based-year concepts to split up the passage of days instead of the standard year/month/day.</source>
          <target state="translated">ISO-8601标准定义了一个以周为基础的日历系统。它使用以周为基础的年和以周为基础的年的概念来划分天数,而不是标准的年/月/日。</target>
        </trans-unit>
        <trans-unit id="cd8f2e4ef07a7ae4561e3a206df7d9c3194cc3bf" translate="yes" xml:space="preserve">
          <source>The ISO-8601 standard does not define eras. A definition has therefore been created with two eras - 'Current era' (CE) for years on or after 0001-01-01 (ISO), and 'Before current era' (BCE) for years before that.</source>
          <target state="translated">ISO-8601标准没有定义时代。因此创建了两个时代的定义--0001-01-01(ISO)上或之后的年份为 &quot;当前时代&quot;(CE),之前的年份为 &quot;当前时代之前&quot;(BCE)。</target>
        </trans-unit>
        <trans-unit id="15f2960aca862d8387dbd45828c14f2ee1a23360" translate="yes" xml:space="preserve">
          <source>The ISO-8601 standard is based on the standard civic 12 month year. This is commonly divided into four quarters, often abbreviated as Q1, Q2, Q3 and Q4.</source>
          <target state="translated">ISO-8601标准是以标准的公民年12个月为基础的。通常分为四个季度,通常简称为Q1、Q2、Q3、Q4。</target>
        </trans-unit>
        <trans-unit id="6e18900e4d1930d96696f4d4906e19682a06d587" translate="yes" xml:space="preserve">
          <source>The ISO-8601 standard was originally intended as a data interchange format, defining a string format for dates and times. However, it also defines an alternate way of expressing the date, based on the concept of week-based-year.</source>
          <target state="translated">ISO-8601标准最初的目的是作为一种数据交换格式,为日期和时间定义了一种字符串格式。然而,它还根据以周为单位的年份的概念,定义了另一种表达日期的方式。</target>
        </trans-unit>
        <trans-unit id="12da9e8bfa2848ec37f88ea0629d59e6306e0906" translate="yes" xml:space="preserve">
          <source>The ISO-like date-time formatter that formats or parses a date-time with offset and zone, such as '2011-12-03T10:15:30+01:00[Europe/Paris]'.</source>
          <target state="translated">类似ISO的日期-时间格式化器,可以格式化或解析带有偏移量和区域的日期-时间,例如'2011-12-03T10:15:30+01:00[Europe/Paris]'。</target>
        </trans-unit>
        <trans-unit id="86afa3124f1aed75c36e4dd56bfce8c49977f732" translate="yes" xml:space="preserve">
          <source>The ISO-like date-time formatter that formats or parses a date-time with the offset and zone if available, such as '2011-12-03T10:15:30', '2011-12-03T10:15:30+01:00' or '2011-12-03T10:15:30+01:00[Europe/Paris]'.</source>
          <target state="translated">类似ISO的日期-时间格式化器,可以格式化或解析带有偏移量和区域的日期-时间(如果有的话),例如'2011-12-03T10:15:30'、'2011-12-03T10:15:30+01:00'或'2011-12-03T10:15:30+01:00[Europe/Paris]'。</target>
        </trans-unit>
        <trans-unit id="1770c1e43e10767defa4c018f5743b7b2d0ab296" translate="yes" xml:space="preserve">
          <source>The IV is taken from &lt;code&gt;iv&lt;/code&gt;, starting at &lt;code&gt;offset&lt;/code&gt; inclusive. Note that the size of the IV (block size), starting at &lt;code&gt;offset&lt;/code&gt; inclusive, must be twice the word size. The bytes that constitute the IV are those between &lt;code&gt;iv[offset]&lt;/code&gt; and &lt;code&gt;iv[offset+2*(wordSize/8)-1]&lt;/code&gt; inclusive.</source>
          <target state="translated">IV从 &lt;code&gt;iv&lt;/code&gt; 处获取，从包含 &lt;code&gt;offset&lt;/code&gt; 开始。请注意，IV的大小（块大小）（包括 &lt;code&gt;offset&lt;/code&gt; 在内）必须是字长的两倍。构成IV的字节是 &lt;code&gt;iv[offset]&lt;/code&gt; 和 &lt;code&gt;iv[offset+2*(wordSize/8)-1]&lt;/code&gt; 之间的字节。</target>
        </trans-unit>
        <trans-unit id="47f00745675042f6a724b595797a24a07101fd7a" translate="yes" xml:space="preserve">
          <source>The IV is taken from &lt;code&gt;iv&lt;/code&gt;, starting at &lt;code&gt;offset&lt;/code&gt; inclusive. The bytes that constitute the IV are those between &lt;code&gt;iv[offset]&lt;/code&gt; and &lt;code&gt;iv[offset+7]&lt;/code&gt; inclusive.</source>
          <target state="translated">IV从 &lt;code&gt;iv&lt;/code&gt; 处获取，从包含 &lt;code&gt;offset&lt;/code&gt; 开始。构成IV的字节是 &lt;code&gt;iv[offset]&lt;/code&gt; 和 &lt;code&gt;iv[offset+7]&lt;/code&gt; 含端点）。</target>
        </trans-unit>
        <trans-unit id="dd985ba4ac843c2aa13ce1073a3079fccc30b81d" translate="yes" xml:space="preserve">
          <source>The Id of the calendar in common usage</source>
          <target state="translated">常用的日历ID</target>
        </trans-unit>
        <trans-unit id="faa9a0061bb28bf6c97cd39acf5b5a828ccf93f4" translate="yes" xml:space="preserve">
          <source>The InetAddress class has a cache to store successful as well as unsuccessful host name resolutions.</source>
          <target state="translated">InetAddress类有一个缓存,用于存储成功和不成功的主机名解析。</target>
        </trans-unit>
        <trans-unit id="b6bf2f6528348c5b02c604ad3248d294717b2a1b" translate="yes" xml:space="preserve">
          <source>The InetAddress class provides methods to resolve host names to their IP addresses and vice versa.</source>
          <target state="translated">InetAddress类提供了将主机名解析为IP地址的方法,反之亦然。</target>
        </trans-unit>
        <trans-unit id="65b8748cc6268fcd7ebec74a58229406dde9da72" translate="yes" xml:space="preserve">
          <source>The InetAddress returned will represent the IPv4 loopback address, 127.0.0.1, or the IPv6 loopback address, ::1. The IPv4 loopback address returned is only one of many in the form 127.*.*.*</source>
          <target state="translated">返回的InetAddress将代表IPv4环回地址127.0.0.1或IPv6环回地址::1。返回的IPv4环回地址只是127.*.*.*形式中的一个。</target>
        </trans-unit>
        <trans-unit id="2152fa5309ac167073dd45954409ff4768fda7a1" translate="yes" xml:space="preserve">
          <source>The Initial Context</source>
          <target state="translated">最初的背景</target>
        </trans-unit>
        <trans-unit id="9ff6f766ad82286cf3b4ec81ad2977fb2af744de" translate="yes" xml:space="preserve">
          <source>The Internet Assigned Numbers Authority maintains the &lt;a href=&quot;http://www.iana.org/assignments/uri-schemes.html&quot;&gt;official list of URI schemes&lt;/a&gt;.</source>
          <target state="translated">Internet号码分配机构维护&lt;a href=&quot;http://www.iana.org/assignments/uri-schemes.html&quot;&gt;URI方案&lt;/a&gt;的正式列表。</target>
        </trans-unit>
        <trans-unit id="d6529cb88cc0262a6e384c19547d019dbb6bed8b" translate="yes" xml:space="preserve">
          <source>The Introspector class provides a standard way for tools to learn about the properties, events, and methods supported by a target Java Bean.</source>
          <target state="translated">Introspector类为工具提供了一种标准的方式来了解目标Java Bean所支持的属性、事件和方法。</target>
        </trans-unit>
        <trans-unit id="bb84f09030f91494fb9beb5357d12365eccba462" translate="yes" xml:space="preserve">
          <source>The JAR manifest file name.</source>
          <target state="translated">JAR清单文件名。</target>
        </trans-unit>
        <trans-unit id="7977a89a83ddfc3d655c3423c1d5cef0ff1b4d9d" translate="yes" xml:space="preserve">
          <source>The JDK includes &lt;code&gt;PrintServiceLookup&lt;/code&gt; implementations that can locate the standard platform printers. To locate other types of printers, such as IPP printers or JINI printers, a print-service provider can write implementations of &lt;code&gt;PrintServiceLookup&lt;/code&gt;. The print-service provider can dynamically install these &lt;code&gt;PrintServiceLookup&lt;/code&gt; implementations using the  SPI JAR file specification.</source>
          <target state="translated">JDK包含可以定位标准平台打印机的 &lt;code&gt;PrintServiceLookup&lt;/code&gt; 实现。要查找其他类型的打印机，例如IPP打印机或JINI打印机，打印服务提供者可以编写 &lt;code&gt;PrintServiceLookup&lt;/code&gt; 的实现。打印服务提供者可以使用SPI JAR文件规范动态安装这些 &lt;code&gt;PrintServiceLookup&lt;/code&gt; 实现。</target>
        </trans-unit>
        <trans-unit id="adacbc5dc9ca937440df58f189dfa0a26e578715" translate="yes" xml:space="preserve">
          <source>The JMM specifically allows optimizing compilers to elide reads or writes of variables that are known to be useless. Such elided reads and writes have no effect on the happens-before relation. Regardless of this fact, the volatile &lt;code&gt;V&lt;/code&gt; will not be elided, even though its written value is indeterminate and its read value is not used.</source>
          <target state="translated">JMM特别允许优化编译器以消除对已知无用的变量的读取或写入。这种省略的读取和写入对事前发生关系没有影响。不管这个事实如何，即使其写入值不确定并且不使用其读取值，也不会忽略掉挥发性 &lt;code&gt;V&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="245a29e6968c20703520c2a92906f5e9e0f071ea" translate="yes" xml:space="preserve">
          <source>The JMX API can also be used as part of a solution for managing systems, networks, and so on.</source>
          <target state="translated">JMX API也可以作为管理系统、网络等解决方案的一部分。</target>
        </trans-unit>
        <trans-unit id="44195781584f2d466ba7e2c1a615da361d712792" translate="yes" xml:space="preserve">
          <source>The JMX Remote API also defines an optional connector called &lt;b&gt;JMXMP Connector&lt;/b&gt; implementing the JMX Message Protocol (JMXMP). As it is optional, it is not part of this bundle (see note below).</source>
          <target state="translated">JMX远程API还定义了一个称为&lt;b&gt;JMXMP Connector&lt;/b&gt;的可选连接&lt;b&gt;器，用于&lt;/b&gt;实现JMX消息协议（JMXMP）。由于它是可选的，因此它不是此捆绑包的一部分（请参阅下面的注释）。</target>
        </trans-unit>
        <trans-unit id="49ce3ebe998d499efd4c77a77394ab17b1f03636" translate="yes" xml:space="preserve">
          <source>The JMX Remote API defines a standard connector, the &lt;b&gt;RMI Connector&lt;/b&gt;, which provides remote access to an MBeanServer through RMI.</source>
          <target state="translated">JMX远程API定义了一个标准连接器&lt;b&gt;RMI连接&lt;/b&gt;器，该&lt;b&gt;连接器&lt;/b&gt;通过RMI提供对MBeanServer的远程访问。</target>
        </trans-unit>
        <trans-unit id="fd57cf73dfe60c2aa55ec8129a23ade5a302d5fa" translate="yes" xml:space="preserve">
          <source>The JMX specification also defines the notion of an &lt;em&gt;adaptor&lt;/em&gt;. An adaptor translates between requests in a protocol such as SNMP or HTML and accesses to an MBean Server. So for example an SNMP GET operation might result in a &lt;code&gt;getAttribute&lt;/code&gt; on the MBean Server.</source>
          <target state="translated">JMX规范还定义了&lt;em&gt;适配器&lt;/em&gt;的概念。适配器在协议（例如SNMP或HTML）中的请求之间进行转换，并访问MBean服务器。因此，例如，SNMP GET操作可能会在MBean服务器上导致 &lt;code&gt;getAttribute&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ad7600c1b4c4869f0bb7b9d742500b17e728fe9b" translate="yes" xml:space="preserve">
          <source>The JMX specification defines the notion of &lt;b&gt;connectors&lt;/b&gt;. A connector is attached to a JMX API MBean server and makes it accessible to remote Java clients. The client end of a connector exports essentially the same interface as the MBean server, specifically the &lt;a href=&quot;../mbeanserverconnection&quot;&gt;&lt;code&gt;MBeanServerConnection&lt;/code&gt;&lt;/a&gt; interface.</source>
          <target state="translated">JMX规范定义了&lt;b&gt;连接器&lt;/b&gt;的概念。连接器连接到JMX API MBean服务器，并使远程Java客户端可以访问它。连接器的客户端输出与MBean服务器基本相同的接口，尤其是&lt;a href=&quot;../mbeanserverconnection&quot;&gt; &lt;code&gt;MBeanServerConnection&lt;/code&gt; &lt;/a&gt;接口。</target>
        </trans-unit>
        <trans-unit id="33732f94d8d93f615200108becd1fb08f06a0bea" translate="yes" xml:space="preserve">
          <source>The JNDI class library reads the resource files and makes the property values freely available. Thus JNDI resource files should be considered to be &quot;world readable&quot;, and sensitive information such as clear-text passwords should not be stored there.</source>
          <target state="translated">JNDI类库会读取资源文件,并使属性值可以自由使用。因此,JNDI资源文件应被认为是 &quot;世界可读 &quot;的,诸如明文密码等敏感信息不应存储在那里。</target>
        </trans-unit>
        <trans-unit id="088d7c9d898f7a840b1256be8ddef986f15194cb" translate="yes" xml:space="preserve">
          <source>The JNDI framework allows for different initial context implementations to be specified at runtime. An initial context is created using an initial context factory. A program can install its own builder that creates initial context factories, thereby overriding the default policies used by the framework, by calling NamingManager.setInitialContextFactoryBuilder(). The InitialContextFactoryBuilder interface must be implemented by such a builder.</source>
          <target state="translated">JNDI框架允许在运行时指定不同的初始上下文实现。一个初始上下文是使用初始上下文工厂创建的。程序可以通过调用NamingManager.setInitialContextFactoryBuilder()来安装自己的构建器,以创建初始上下文工厂,从而覆盖框架使用的默认策略。InitialContextFactoryBuilder接口必须由这样的构建器实现。</target>
        </trans-unit>
        <trans-unit id="d098149f3977423197730ce483608b5d9c5ba323" translate="yes" xml:space="preserve">
          <source>The JNDI framework allows for different initial context implementations to be specified at runtime. The initial context is created using an &lt;em&gt;initial context factory&lt;/em&gt;. An initial context factory must implement the InitialContextFactory interface, which provides a method for creating instances of initial context that implement the Context interface. In addition, the factory class must be public and must have a public constructor that accepts no arguments.</source>
          <target state="translated">JNDI框架允许在运行时指定不同的初始上下文实现。初始上下文是使用&lt;em&gt;初始上下文工厂&lt;/em&gt;创建的。初始上下文工厂必须实现InitialContextFactory接口，该接口提供了一种用于创建实现Context接口的初始上下文实例的方法。此外，工厂类必须是公共的，并且必须具有不接受任何参数的公共构造函数。</target>
        </trans-unit>
        <trans-unit id="b9064bba67a68203f58a597fa1fa3afbedec89f6" translate="yes" xml:space="preserve">
          <source>The JNDI framework allows for object implementations to be loaded in dynamically via &lt;code&gt;object factories&lt;/code&gt;.</source>
          <target state="translated">JNDI框架允许通过 &lt;code&gt;object factories&lt;/code&gt; 动态加载对象实现。</target>
        </trans-unit>
        <trans-unit id="134c5f63e690609e9c6a657638ccd21e3550dca4" translate="yes" xml:space="preserve">
          <source>The JNDI framework allows for object implementations to be loaded in dynamically via &lt;em&gt;object factories&lt;/em&gt;. For example, when looking up a printer bound in the name space, if the print service binds printer names to &lt;code&gt;Reference&lt;/code&gt;s, the printer &lt;code&gt;Reference&lt;/code&gt; could be used to create a printer object, so that the caller of lookup can directly operate on the printer object after the lookup.</source>
          <target state="translated">JNDI框架允许通过&lt;em&gt;对象工厂&lt;/em&gt;动态加载对象实现。例如，当查找在名称空间中绑定的打印机时，如果打印服务将打印机名称绑定到 &lt;code&gt;Reference&lt;/code&gt; ，则可以使用打印机 &lt;code&gt;Reference&lt;/code&gt; 创建打印机对象，以便查找的调用者可以直接在打印机对象上进行操作查找后。</target>
        </trans-unit>
        <trans-unit id="f3b7acec5238c7d2dd7fa0082fb8db71d5d2e9ed" translate="yes" xml:space="preserve">
          <source>The JNDI framework allows for object implementations to be loaded in dynamically via &lt;em&gt;object factories&lt;/em&gt;. For example, when looking up a printer bound in the name space, if the print service binds printer names to References, the printer Reference could be used to create a printer object, so that the caller of lookup can directly operate on the printer object after the lookup.</source>
          <target state="translated">JNDI框架允许通过&lt;em&gt;对象工厂&lt;/em&gt;动态加载对象实现。例如，当查找在名称空间中绑定的打印机时，如果打印服务将打印机名称绑定到引用，则可以使用打印机引用来创建打印机对象，以便查找的调用者可以在操作之后直接对打印机对象进行操作。查找。</target>
        </trans-unit>
        <trans-unit id="0f159102714c8eb7af6cff7ee4872dd30ee0cf55" translate="yes" xml:space="preserve">
          <source>The JNDI framework allows for object implementations to be loaded in dynamically via &lt;em&gt;object factories&lt;/em&gt;. For example, when looking up a printer bound in the name space, if the print service binds printer names to References, the printer Reference could be used to create a printer object, so that the caller of lookup can directly operate on the printer object after the lookup. An ObjectFactory is responsible for creating objects of a specific type. JNDI uses a default policy for using and loading object factories. You can override this default policy by calling &lt;code&gt;NamingManager.setObjectFactoryBuilder()&lt;/code&gt; with an ObjectFactoryBuilder, which contains the program-defined way of creating/loading object factories. Any &lt;code&gt;ObjectFactoryBuilder&lt;/code&gt; implementation must implement this interface that for creating object factories.</source>
          <target state="translated">JNDI框架允许通过&lt;em&gt;对象工厂&lt;/em&gt;动态加载对象实现。例如，当查找在名称空间中绑定的打印机时，如果打印服务将打印机名称绑定到引用，则可以使用打印机引用来创建打印机对象，以便查找的调用者可以在操作之后直接对打印机对象进行操作。查找。 ObjectFactory负责创建特定类型的对象。 JNDI使用默认策略来使用和加载对象工厂。您可以通过使用ObjectFactoryBuilder 调用 &lt;code&gt;NamingManager.setObjectFactoryBuilder()&lt;/code&gt; 来覆盖此默认策略，该对象包含程序定义的创建/加载对象工厂的方式。任何 &lt;code&gt;ObjectFactoryBuilder&lt;/code&gt; 实现必须实现用于创建对象工厂的该接口。</target>
        </trans-unit>
        <trans-unit id="88db5d84ce039b71278336e8b1b44b578aa0d61d" translate="yes" xml:space="preserve">
          <source>The JNDI framework allows for object implementations to be loaded in dynamically via &lt;em&gt;object factories&lt;/em&gt;. See &lt;code&gt;ObjectFactory&lt;/code&gt; for details.</source>
          <target state="translated">JNDI框架允许通过&lt;em&gt;对象工厂&lt;/em&gt;动态加载对象实现。有关详细信息，请参见 &lt;code&gt;ObjectFactory&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5669f05609b02ee4c44fdaa5adbcabc508864f50" translate="yes" xml:space="preserve">
          <source>The JNDI library will consult the provider resource file when determining the values of these properties. Properties other than these may be set in the provider resource file at the discretion of the service provider. The service provider's documentation should clearly state which properties are allowed; other properties in the file will be ignored.</source>
          <target state="translated">JNDI 库在确定这些属性的值时将参考提供者资源文件。除这些属性外,其他属性可由服务提供者酌情在提供者资源文件中设置。服务提供者的文件应该明确说明哪些属性是允许的;文件中的其他属性将被忽略。</target>
        </trans-unit>
        <trans-unit id="bec69931581644a1ef0084216dc02cc47be425fa" translate="yes" xml:space="preserve">
          <source>The JNDI name of the resource. For field annotations, the default is the field name. For method annotations, the default is the JavaBeans property name corresponding to the method. For class annotations, there is no default and this must be specified.</source>
          <target state="translated">资源的JNDI名称。对于字段注解,默认为字段名。对于方法注解,默认是与方法相对应的 JavaBeans 属性名称。对于类注解,没有默认值,必须指定。</target>
        </trans-unit>
        <trans-unit id="edc24d0f37d47900732cfdcdc56bc8ec2f6044ca" translate="yes" xml:space="preserve">
          <source>The JPS API is designed to be used in Java profiles which do not support AWT.</source>
          <target state="translated">JPS API被设计用于不支持AWT的Java配置文件中。</target>
        </trans-unit>
        <trans-unit id="8578472fe170c11efcaca36252367b026245c2be" translate="yes" xml:space="preserve">
          <source>The JVM bytecode format supports immediate constants of the classes &lt;a href=&quot;methodhandle&quot;&gt;&lt;code&gt;MethodHandle&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;methodtype&quot;&gt;&lt;code&gt;MethodType&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">JVM字节码格式支持类&lt;a href=&quot;methodhandle&quot;&gt; &lt;code&gt;MethodHandle&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;methodtype&quot;&gt; &lt;code&gt;MethodType&lt;/code&gt; 的&lt;/a&gt;立即常量。</target>
        </trans-unit>
        <trans-unit id="423700bf3f40eb8f7ae2196876409f2568dcd9ca" translate="yes" xml:space="preserve">
          <source>The JVM imposes a similar requirement on &lt;code&gt;invokespecial&lt;/code&gt; instruction, that the receiver argument must match both the resolved method &lt;em&gt;and&lt;/em&gt; the current class. Again, this requirement is enforced by narrowing the type of the leading parameter to the resulting method handle. (See the Java Virtual Machine Specification, section 4.10.1.9.)</source>
          <target state="translated">JVM对 &lt;code&gt;invokespecial&lt;/code&gt; 指令施加了类似的要求，即接收器参数必须与解析的方法&lt;em&gt;和&lt;/em&gt;当前类都匹配。同样，通过将前导参数的类型缩小到结果方法句柄来强制执行此要求。（请参阅《 Java虚拟机规范》第4.10.1.9节。）</target>
        </trans-unit>
        <trans-unit id="f6a937822298d3770df670d2d33f12a835018bdf" translate="yes" xml:space="preserve">
          <source>The JVM imposes on all methods and constructors of any kind an absolute limit of 255 stacked arguments. This limit can appear more restrictive in certain cases:</source>
          <target state="translated">JVM对所有方法和任何类型的构造函数规定了255个堆叠参数的绝对限制。在某些情况下,这个限制会显得更加严格。</target>
        </trans-unit>
        <trans-unit id="dc6a5c598e3c5bccd4ab59217eeb5725b65103d3" translate="yes" xml:space="preserve">
          <source>The JVM represents constructors and static initializer blocks as internal methods with special names (&lt;code&gt;&quot;&amp;lt;init&amp;gt;&quot;&lt;/code&gt; and &lt;code&gt;&quot;&amp;lt;clinit&amp;gt;&quot;&lt;/code&gt;). The internal syntax of invocation instructions allows them to refer to such internal methods as if they were normal methods, but the JVM bytecode verifier rejects them. A lookup of such an internal method will produce a &lt;code&gt;NoSuchMethodException&lt;/code&gt;.</source>
          <target state="translated">JVM将构造函数和静态初始化程序块表示为具有特殊名称（ &lt;code&gt;&quot;&amp;lt;init&amp;gt;&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;&amp;lt;clinit&amp;gt;&quot;&lt;/code&gt; ）的内部方法。调用指令的内部语法允许它们像使用普通方法一样引用此类内部方法，但是JVM字节码验证程序拒绝它们。查找此类内部方法将产生 &lt;code&gt;NoSuchMethodException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4bed2dbd7bc1a0a64894245adfbe5487e3761dab" translate="yes" xml:space="preserve">
          <source>The Japanese Imperial calendar system is the same as the ISO calendar system apart from the era-based year numbering. The proleptic-year is defined to be equal to the ISO proleptic-year.</source>
          <target state="translated">日本皇室历法与国际标准化组织的历法相同,只是年号以年代为基础。闰年被定义为等于国际标准化组织的闰年。</target>
        </trans-unit>
        <trans-unit id="1377cea6a56d5ed563cbb1106ccb49deee8306eb" translate="yes" xml:space="preserve">
          <source>The Japanese Imperial calendar system.</source>
          <target state="translated">日本皇室的历法制度。</target>
        </trans-unit>
        <trans-unit id="7564ca9cd9ffac61a50b36479cc4d2f52a3b5c1f" translate="yes" xml:space="preserve">
          <source>The Japanese calendar system has multiple eras defined by &lt;a href=&quot;japaneseera&quot;&gt;&lt;code&gt;JapaneseEra&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">日本日历系统具有&lt;a href=&quot;japaneseera&quot;&gt; &lt;code&gt;JapaneseEra&lt;/code&gt; &lt;/a&gt;定义的多个时代。</target>
        </trans-unit>
        <trans-unit id="265e051cf5be43bb91edb907b6aaa5aa90a2b761" translate="yes" xml:space="preserve">
          <source>The Japanese month and day-of-month are the same as those in the ISO calendar system. They are not reset when the era changes. For example:</source>
          <target state="translated">日本的月份和月份日与ISO日历系统中的月份和月份日相同。当时代发生变化时,它们不会被重置。例如:</target>
        </trans-unit>
        <trans-unit id="9a132e736768e81687dffdd4d971dcc6de9796ad" translate="yes" xml:space="preserve">
          <source>The Japanese proleptic year, month and day-of-month are the same as those in the ISO calendar system. They are not reset when the era changes.</source>
          <target state="translated">日本的年、月、日与ISO历法中的年、月、日相同。当时代发生变化时,它们不会被重置。</target>
        </trans-unit>
        <trans-unit id="61602e7596e12b632597fd4f988db4b318fd0d87" translate="yes" xml:space="preserve">
          <source>The Java Language Specification</source>
          <target state="translated">Java语言规范</target>
        </trans-unit>
        <trans-unit id="37d13fecff6728378da832d10b9051c944390c97" translate="yes" xml:space="preserve">
          <source>The Java Management Extensions (JMX&lt;sup&gt;TM&lt;/sup&gt;) API is a standard API for management and monitoring. Typical uses include:</source>
          <target state="translated">Java管理扩展（JMX &lt;sup&gt;TM&lt;/sup&gt;）API是用于管理和监视的标准API。典型用途包括：</target>
        </trans-unit>
        <trans-unit id="8bef35235f701eb6de58ba31cfe59d2bb33aa8ff" translate="yes" xml:space="preserve">
          <source>The Java Platform provides a number of classes that perform locale-sensitive operations. For example, the &lt;code&gt;NumberFormat&lt;/code&gt; class formats numbers, currency, and percentages in a locale-sensitive manner. Classes such as &lt;code&gt;NumberFormat&lt;/code&gt; have several convenience methods for creating a default object of that type. For example, the &lt;code&gt;NumberFormat&lt;/code&gt; class provides these three convenience methods for creating a default &lt;code&gt;NumberFormat&lt;/code&gt; object:</source>
          <target state="translated">Java平台提供了许多执行对语言环境敏感的操作的类。例如， &lt;code&gt;NumberFormat&lt;/code&gt; 类以对语言环境敏感的方式格式化数字，货币和百分比。诸如 &lt;code&gt;NumberFormat&lt;/code&gt; 之类的类具有几种方便的方法来创建该类型的默认对象。例如， &lt;code&gt;NumberFormat&lt;/code&gt; 类提供了以下三种方便的方法来创建默认的 &lt;code&gt;NumberFormat&lt;/code&gt; 对象：</target>
        </trans-unit>
        <trans-unit id="3b60f629f49f10f4985e6a720af54abf514bac30" translate="yes" xml:space="preserve">
          <source>The Java Platform provides three specialized subclasses of &lt;code&gt;Format&lt;/code&gt;-- &lt;code&gt;DateFormat&lt;/code&gt;, &lt;code&gt;MessageFormat&lt;/code&gt;, and &lt;code&gt;NumberFormat&lt;/code&gt;--for formatting dates, messages, and numbers, respectively.</source>
          <target state="translated">Java平台提供的三个专业小类 &lt;code&gt;Format&lt;/code&gt; - &lt;code&gt;DateFormat&lt;/code&gt; ， &lt;code&gt;MessageFormat&lt;/code&gt; 和 &lt;code&gt;NumberFormat&lt;/code&gt; 的分别-用于格式化日期，消息和数字，。</target>
        </trans-unit>
        <trans-unit id="03ea0cad9aef11b637a3137ff4122043f3493aef" translate="yes" xml:space="preserve">
          <source>The Java Platform provides two subclasses of &lt;code&gt;ResourceBundle&lt;/code&gt;, &lt;code&gt;ListResourceBundle&lt;/code&gt; and &lt;code&gt;PropertyResourceBundle&lt;/code&gt;, that provide a fairly simple way to create resources. As you saw briefly in a previous example, &lt;code&gt;ListResourceBundle&lt;/code&gt; manages its resource as a list of key/value pairs. &lt;code&gt;PropertyResourceBundle&lt;/code&gt; uses a properties file to manage its resources.</source>
          <target state="translated">Java平台提供的两个子类 &lt;code&gt;ResourceBundle&lt;/code&gt; ， &lt;code&gt;ListResourceBundle&lt;/code&gt; 的和 &lt;code&gt;PropertyResourceBundle&lt;/code&gt; 的，这提供了一个相当简单的方法来创建资源。正如您在前面的示例中简要看到的那样， &lt;code&gt;ListResourceBundle&lt;/code&gt; 将其资源作为键/值对的列表进行管理。 &lt;code&gt;PropertyResourceBundle&lt;/code&gt; 使用属性文件来管理其资源。</target>
        </trans-unit>
        <trans-unit id="94f66170e9f1f394a5254a9fe89af973c28cd26f" translate="yes" xml:space="preserve">
          <source>The Java Print Service API defines a group of standard attribute classes modeled upon the attributes in the Internet Printing Protocol (IPP) version 1.1. The standard attribute classes are in the subpackage javax.print.attribute.standard to keep the actual attribute classes conceptually separate from the generic apparatus defined in package javax.print.attribute.</source>
          <target state="translated">Java打印服务API定义了一组标准属性类,它们以Internet打印协议(IPP)1.1版中的属性为模型。标准属性类位于子包javax.print.attribute.standard中,以保持实际属性类与包javax.print.attribute中定义的通用设备在概念上的分离。</target>
        </trans-unit>
        <trans-unit id="a818f0937d6870054c9657fd1853dbbf7260285b" translate="yes" xml:space="preserve">
          <source>The Java Print Service API defines these different kinds of attributes with five subinterfaces of &lt;code&gt;Attribute&lt;/code&gt;:</source>
          <target state="translated">Java Print Service API通过 &lt;code&gt;Attribute&lt;/code&gt; 的五个子接口定义了这些不同种类的属性：</target>
        </trans-unit>
        <trans-unit id="fe3bd743981c387b2400e5d9b97f685293d95022" translate="yes" xml:space="preserve">
          <source>The Java Print Service API does not define any mandatorily supported DocFlavors. However, here are some examples of MIME types that a Java Print Service instance might support for client formatted print data. Nested classes inside class DocFlavor declare predefined static constant DocFlavor objects for these example doc flavors; class DocFlavor's constructor can be used to create an arbitrary doc flavor.</source>
          <target state="translated">Java打印服务API没有定义任何强制支持的DocFlavors,但以下是Java打印服务实例可能支持的一些MIME类型,用于客户端格式化打印数据。然而,以下是Java打印服务实例可能为客户端格式化打印数据支持的MIME类型的一些示例。在类DocFlavor中的嵌套类为这些示例的DocFlavor对象声明了预定义的静态常量DocFlavor对象;类DocFlavor的构造函数可用于创建任意的Doc风味。</target>
        </trans-unit>
        <trans-unit id="65c3c2c1fe707b0a8b3bdeea8d3461a62fcf7c49" translate="yes" xml:space="preserve">
          <source>The Java Print Service API is designed so that vendors can:</source>
          <target state="translated">Java打印服务API的设计是为了让厂商可以。</target>
        </trans-unit>
        <trans-unit id="3f34c755601f30797b5c5b7d5b48474498065dd9" translate="yes" xml:space="preserve">
          <source>The Java Print Service API provides four specializations of an attribute set that are restricted to contain just one of the four kinds of attributes, as discussed in the &lt;a href=&quot;#role&quot;&gt;Attribute Roles&lt;/a&gt; section:</source>
          <target state="translated">Java Print Service API提供了属性集的四个专业化，这些属性集被限制为仅包含四种属性之一，如&amp;ldquo; &lt;a href=&quot;#role&quot;&gt;属性角色&amp;rdquo;&lt;/a&gt;部分所述：</target>
        </trans-unit>
        <trans-unit id="c2715c77dd34c70665dfad2f1923e173e786e209" translate="yes" xml:space="preserve">
          <source>The Java Time-Scale divides each calendar day into exactly 86400 subdivisions, known as seconds. These seconds may differ from the SI second. It closely matches the de facto international civil time scale, the definition of which changes from time to time.</source>
          <target state="translated">Java 时标将每个日历日精确地划分为 86400 个小节,称为秒。这些秒可能与SI秒不同。它与事实上的国际民用时标非常吻合,而国际民用时标的定义会不时变化。</target>
        </trans-unit>
        <trans-unit id="4bde9066215b58dffb03e10c8882b75db84e87a4" translate="yes" xml:space="preserve">
          <source>The Java Time-Scale has slightly different definitions for different segments of the time-line, each based on the consensus international time scale that is used as the basis for civil time. Whenever the internationally-agreed time scale is modified or replaced, a new segment of the Java Time-Scale must be defined for it. Each segment must meet these requirements:</source>
          <target state="translated">Java时标对时间线的不同部分有略微不同的定义,每个定义都以作为民用时间基础的协商一致的国际时标为基础。每当国际商定的时间尺度被修改或替换时,必须为其定义一个新的Java时间尺度段。每一段必须符合这些要求。</target>
        </trans-unit>
        <trans-unit id="4600970ab5dcc28d471a34b69880d44724af7c9c" translate="yes" xml:space="preserve">
          <source>The Java Virtual Machine Specification</source>
          <target state="translated">Java虚拟机规范</target>
        </trans-unit>
        <trans-unit id="e3cf148b298a0b996efd7f97bd7f2e6174fda315" translate="yes" xml:space="preserve">
          <source>The Java Virtual Machine sets the default locale during startup based on the host environment. It is used by many locale-sensitive methods if no locale is explicitly specified.</source>
          <target state="translated">Java虚拟机在启动时根据主机环境设置默认的locale,如果没有明确指定locale,它被许多本地敏感的方法使用。如果没有明确指定locale,它被许多本地敏感的方法使用。</target>
        </trans-unit>
        <trans-unit id="d9d7a4ea102a2331058fd720ef77be5d28603b6b" translate="yes" xml:space="preserve">
          <source>The Java Virtual Machine sets the default locale during startup based on the host environment. It is used by many locale-sensitive methods if no locale is explicitly specified. It can be changed using the &lt;a href=&quot;locale#setDefault-java.util.Locale-&quot;&gt;&lt;code&gt;setDefault&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">Java虚拟机将在启动期间根据主机环境设置默认语言环境。如果未明确指定语言环境，则许多语言环境敏感方法都会使用它。可以使用&lt;a href=&quot;locale#setDefault-java.util.Locale-&quot;&gt; &lt;code&gt;setDefault&lt;/code&gt; &lt;/a&gt;方法更改它。</target>
        </trans-unit>
        <trans-unit id="935b4a63d6ee5db34b9d75a511cfdfab0947e278" translate="yes" xml:space="preserve">
          <source>The Java Virtual Machine sets the default locale during startup based on the host environment. It is used by many locale-sensitive methods if no locale is explicitly specified. It can be changed using the setDefault(Locale.Category, Locale) method.</source>
          <target state="translated">Java虚拟机在启动时根据主机环境设置默认的locale,如果没有明确指定locale,它被许多本地敏感的方法使用。如果没有明确指定locale,许多本地敏感的方法都会使用它。可以使用setDefault(Locale.Category,Locale)方法更改它。</target>
        </trans-unit>
        <trans-unit id="0bf9c7a5833d85446736a0e1c4523720b0baa70e" translate="yes" xml:space="preserve">
          <source>The Java class name of composite data values this composite type represents (ie the class name returned by the &lt;a href=&quot;opentype#getClassName--&quot;&gt;&lt;code&gt;getClassName&lt;/code&gt;&lt;/a&gt; method) is set to the string value returned by &lt;code&gt;CompositeData.class.getName()&lt;/code&gt;.</source>
          <target state="translated">此复合类型表示的复合数据值的Ja​​va类名称（即&lt;a href=&quot;opentype#getClassName--&quot;&gt; &lt;code&gt;getClassName&lt;/code&gt; &lt;/a&gt;方法返回的类名称）设置为 &lt;code&gt;CompositeData.class.getName()&lt;/code&gt; 返回的字符串值。</target>
        </trans-unit>
        <trans-unit id="bda12988aff6c0c6b0da57eda918cd7f7e41f2f4" translate="yes" xml:space="preserve">
          <source>The Java class name of tabular data values this tabular type represents (ie the class name returned by the &lt;a href=&quot;opentype#getClassName--&quot;&gt;&lt;code&gt;getClassName&lt;/code&gt;&lt;/a&gt; method) is set to the string value returned by &lt;code&gt;TabularData.class.getName()&lt;/code&gt;.</source>
          <target state="translated">该表格类型表示的表格数据值的Ja​​va类名称（即&lt;a href=&quot;opentype#getClassName--&quot;&gt; &lt;code&gt;getClassName&lt;/code&gt; &lt;/a&gt;方法返回的类名称）被设置为 &lt;code&gt;TabularData.class.getName()&lt;/code&gt; 返回的字符串值。</target>
        </trans-unit>
        <trans-unit id="51863c4a757aa5599aa4ec4ebb6fdc59f85b517e" translate="yes" xml:space="preserve">
          <source>The Java interface name for a Standard MBean or MXBean, as returned by &lt;a href=&quot;../../java/lang/class#getName--&quot;&gt;&lt;code&gt;Class.getName()&lt;/code&gt;&lt;/a&gt;. A Standard MBean or MXBean registered directly in the MBean Server or created using the &lt;a href=&quot;standardmbean&quot;&gt;&lt;code&gt;StandardMBean&lt;/code&gt;&lt;/a&gt; class will have this field in its MBeanInfo Descriptor.</source>
          <target state="translated">Standard MBean或MXBean的Java接口名称，由&lt;a href=&quot;../../java/lang/class#getName--&quot;&gt; &lt;code&gt;Class.getName()&lt;/code&gt; &lt;/a&gt;返回。直接在MBean服务器中注册或使用&lt;a href=&quot;standardmbean&quot;&gt; &lt;code&gt;StandardMBean&lt;/code&gt; &lt;/a&gt;类创建的Standard MBean或MXBean 将在其MBeanInfo描述符中具有此字段。</target>
        </trans-unit>
        <trans-unit id="1aedb6f153f14e307ee0a63ee1143e333aca4608" translate="yes" xml:space="preserve">
          <source>The Java language provides special support for the string concatenation operator ( + ), and for conversion of other objects to strings. String concatenation is implemented through the &lt;code&gt;StringBuilder&lt;/code&gt;(or &lt;code&gt;StringBuffer&lt;/code&gt;) class and its &lt;code&gt;append&lt;/code&gt; method. String conversions are implemented through the method &lt;code&gt;toString&lt;/code&gt;, defined by &lt;code&gt;Object&lt;/code&gt; and inherited by all classes in Java. For additional information on string concatenation and conversion, see Gosling, Joy, and Steele,</source>
          <target state="translated">Java语言为字符串连接运算符（+）以及将其他对象转换为字符串提供了特殊支持。字符串连接是通过 &lt;code&gt;StringBuilder&lt;/code&gt; （或 &lt;code&gt;StringBuffer&lt;/code&gt; ）类及其 &lt;code&gt;append&lt;/code&gt; 方法实现的。字符串转换是通过 &lt;code&gt;toString&lt;/code&gt; 方法实现的，该方法由 &lt;code&gt;Object&lt;/code&gt; 定义并由Java中的所有类继承。有关字符串连接和转换的其他信息，请参见Gosling，Joy和Steele，</target>
        </trans-unit>
        <trans-unit id="e0998193a86cfe456d402b1f0c70a66b6cd6c11c" translate="yes" xml:space="preserve">
          <source>The Java math library is defined with respect to &lt;code&gt;fdlibm&lt;/code&gt; version 5.3. Where &lt;code&gt;fdlibm&lt;/code&gt; provides more than one definition for a function (such as &lt;code&gt;acos&lt;/code&gt;), use the &quot;IEEE 754 core function&quot; version (residing in a file whose name begins with the letter &lt;code&gt;e&lt;/code&gt;). The methods which require &lt;code&gt;fdlibm&lt;/code&gt; semantics are &lt;code&gt;sin&lt;/code&gt;, &lt;code&gt;cos&lt;/code&gt;, &lt;code&gt;tan&lt;/code&gt;, &lt;code&gt;asin&lt;/code&gt;, &lt;code&gt;acos&lt;/code&gt;, &lt;code&gt;atan&lt;/code&gt;, &lt;code&gt;exp&lt;/code&gt;, &lt;code&gt;log&lt;/code&gt;, &lt;code&gt;log10&lt;/code&gt;, &lt;code&gt;cbrt&lt;/code&gt;, &lt;code&gt;atan2&lt;/code&gt;, &lt;code&gt;pow&lt;/code&gt;, &lt;code&gt;sinh&lt;/code&gt;, &lt;code&gt;cosh&lt;/code&gt;, &lt;code&gt;tanh&lt;/code&gt;, &lt;code&gt;hypot&lt;/code&gt;, &lt;code&gt;expm1&lt;/code&gt;, and &lt;code&gt;log1p&lt;/code&gt;.</source>
          <target state="translated">Java数学库是针对 &lt;code&gt;fdlibm&lt;/code&gt; 版本5.3 定义的。如果 &lt;code&gt;fdlibm&lt;/code&gt; 为一个函数（例如 &lt;code&gt;acos&lt;/code&gt; ）提供了多个定义，请使用&amp;ldquo; IEEE 754核心函数&amp;rdquo;版本（位于名称以字母 &lt;code&gt;e&lt;/code&gt; 开头的文件中）。需要 &lt;code&gt;fdlibm&lt;/code&gt; 语义的方法是 &lt;code&gt;sin&lt;/code&gt; ， &lt;code&gt;cos&lt;/code&gt; ， &lt;code&gt;tan&lt;/code&gt; ， &lt;code&gt;asin&lt;/code&gt; ， &lt;code&gt;acos&lt;/code&gt; ， &lt;code&gt;atan&lt;/code&gt; ， &lt;code&gt;exp&lt;/code&gt; ， &lt;code&gt;log&lt;/code&gt; ， &lt;code&gt;log10&lt;/code&gt; ， &lt;code&gt;cbrt&lt;/code&gt; ， &lt;code&gt;atan2&lt;/code&gt; ， &lt;code&gt;pow&lt;/code&gt; ， &lt;code&gt;sinh&lt;/code&gt; ， &lt;code&gt;cosh&lt;/code&gt; ， &lt;code&gt;tanh&lt;/code&gt; ， &lt;code&gt;hypot&lt;/code&gt; 将， &lt;code&gt;expm1&lt;/code&gt; 和 &lt;code&gt;log1p&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="75bc96f1b0cc70e1672a7ea3f62bf4ee8f43d325" translate="yes" xml:space="preserve">
          <source>The Java programming language does not guarantee which thread will invoke the &lt;code&gt;finalize&lt;/code&gt; method for any given object. It is guaranteed, however, that the thread that invokes finalize will not be holding any user-visible synchronization locks when finalize is invoked. If an uncaught exception is thrown by the finalize method, the exception is ignored and finalization of that object terminates.</source>
          <target state="translated">Java编程语言不能保证哪个线程将为任何给定对象调用 &lt;code&gt;finalize&lt;/code&gt; 方法。但是，可以保证，调用finalize的线程在调用finalize时不会持有任何用户可见的同步锁。如果finalize方法抛出未捕获的异常，则该异常将被忽略，并且该对象的终结将终止。</target>
        </trans-unit>
        <trans-unit id="af13f60de6a564a40dc8e97ebaf3a0143c84236a" translate="yes" xml:space="preserve">
          <source>The Java time-scale is used for all date-time classes. This includes &lt;code&gt;Instant&lt;/code&gt;, &lt;code&gt;LocalDate&lt;/code&gt;, &lt;code&gt;LocalTime&lt;/code&gt;, &lt;code&gt;OffsetDateTime&lt;/code&gt;, &lt;code&gt;ZonedDateTime&lt;/code&gt; and &lt;code&gt;Duration&lt;/code&gt;.</source>
          <target state="translated">Java时间刻度用于所有日期时间类。这包括 &lt;code&gt;Instant&lt;/code&gt; ， &lt;code&gt;LocalDate&lt;/code&gt; ， &lt;code&gt;LocalTime&lt;/code&gt; ， &lt;code&gt;OffsetDateTime&lt;/code&gt; ， &lt;code&gt;ZonedDateTime&lt;/code&gt; 和 &lt;code&gt;Duration&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b2da8a881d3a54f6e4f6b884054ec854ec43a1d9" translate="yes" xml:space="preserve">
          <source>The Java type of the resource. For field annotations, the default is the type of the field. For method annotations, the default is the type of the JavaBeans property. For class annotations, there is no default and this must be specified.</source>
          <target state="translated">资源的Java类型。对于字段注解,默认为字段的类型。对于方法注解,默认为JavaBeans属性的类型。对于类注解,没有默认值,必须指定。</target>
        </trans-unit>
        <trans-unit id="43d20fd86e33d070ee07b30fb6fd2637b8965aa6" translate="yes" xml:space="preserve">
          <source>The Java virtual machine</source>
          <target state="translated">Java虚拟机</target>
        </trans-unit>
        <trans-unit id="9b5c7ce28420ae67114f39b12a0543341609a160" translate="yes" xml:space="preserve">
          <source>The Java virtual machine has a</source>
          <target state="translated">Java虚拟机有一个</target>
        </trans-unit>
        <trans-unit id="8516f820bb05657121a79dd1bd0a5cddcc1f2f53" translate="yes" xml:space="preserve">
          <source>The Java virtual machine has a default provider that provides zone rules for the time-zones defined by IANA Time Zone Database (TZDB). If the system property &lt;code&gt;java.time.zone.DefaultZoneRulesProvider&lt;/code&gt; is defined then it is taken to be the fully-qualified name of a concrete ZoneRulesProvider class to be loaded as the default provider, using the system class loader. If this system property is not defined, a system-default provider will be loaded to serve as the default provider.</source>
          <target state="translated">Java虚拟机具有默认提供程序，该提供程序为IANA时区数据库（TZDB）定义的时区提供时区规则。如果定义了系统属性 &lt;code&gt;java.time.zone.DefaultZoneRulesProvider&lt;/code&gt; ，则使用系统类加载器将其视为要作为默认提供者加载的具体ZoneRulesProvider类的完全限定名称。如果未定义此系统属性，则将加载系统默认提供程序以用作默认提供程序。</target>
        </trans-unit>
        <trans-unit id="01e66a7f2f90bc990318958109b0d41e725d670b" translate="yes" xml:space="preserve">
          <source>The Java virtual machine has a heap for object allocation and also maintains non-heap memory for the method area and the Java virtual machine execution. The Java virtual machine can have one or more memory pools. Each memory pool represents a memory area of one of the following types:</source>
          <target state="translated">Java虚拟机有一个用于对象分配的堆,也为方法区和Java虚拟机执行维护非堆内存。Java虚拟机可以有一个或多个内存池。每个内存池代表以下类型之一的内存区域。</target>
        </trans-unit>
        <trans-unit id="20591611464f80238a71287e9fce3d26d00ecfac" translate="yes" xml:space="preserve">
          <source>The Java virtual machine implementation may use a high resolution timer to measure the elapsed time. This method may return the same value even if the collection count has been incremented if the collection elapsed time is very short.</source>
          <target state="translated">Java虚拟机的实现可以使用高分辨率计时器来测量经过的时间。如果收集经过的时间很短,即使收集计数已经增加,该方法也可能返回相同的值。</target>
        </trans-unit>
        <trans-unit id="21c32d462e38386cb39051b42822e7568e72eaed" translate="yes" xml:space="preserve">
          <source>The Java virtual machine maintains the peak memory usage of a memory pool since the virtual machine was started or the peak was reset. The peak memory usage is returned by the &lt;a href=&quot;memorypoolmxbean#getPeakUsage--&quot;&gt;&lt;code&gt;getPeakUsage()&lt;/code&gt;&lt;/a&gt; method and reset by calling the &lt;a href=&quot;memorypoolmxbean#resetPeakUsage--&quot;&gt;&lt;code&gt;resetPeakUsage()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">自从启动虚拟机或重置峰值以来，Java虚拟机便保持了内存池的峰值内存使用率。峰值内存使用量由&lt;a href=&quot;memorypoolmxbean#getPeakUsage--&quot;&gt; &lt;code&gt;getPeakUsage()&lt;/code&gt; &lt;/a&gt;方法返回，并通过调用&lt;a href=&quot;memorypoolmxbean#resetPeakUsage--&quot;&gt; &lt;code&gt;resetPeakUsage()&lt;/code&gt; &lt;/a&gt;方法进行重置。</target>
        </trans-unit>
        <trans-unit id="1dd3f55b5efbf2036c2fe1ec00c3c49d3ddb4916" translate="yes" xml:space="preserve">
          <source>The Java virtual machine manages memory other than the heap (referred as</source>
          <target state="translated">Java虚拟机管理的是堆以外的内存(称为</target>
        </trans-unit>
        <trans-unit id="472437aa219a5ab5c682981b0f53bbaf388053c7" translate="yes" xml:space="preserve">
          <source>The Java virtual machine may measure the time with a high resolution timer. This statistic is reset when the thread contention monitoring is reenabled.</source>
          <target state="translated">Java虚拟机可能会用一个高分辨率的计时器来测量时间。当重新启用线程争用监控时,会重置该统计。</target>
        </trans-unit>
        <trans-unit id="7d5cc1c9e97c8fd121944655161d88c67a4b91ea" translate="yes" xml:space="preserve">
          <source>The Java&amp;trade; Language Specification</source>
          <target state="translated">Java&amp;trade;语言规范</target>
        </trans-unit>
        <trans-unit id="fff53af6e46bb1a4be8a5ab0a06369d5f80e1391" translate="yes" xml:space="preserve">
          <source>The Java&amp;trade; Language Specification, First Edition</source>
          <target state="translated">Java&amp;trade;语言规范，第一版</target>
        </trans-unit>
        <trans-unit id="417681d10c199b472becfb181846b8f2351a0cd7" translate="yes" xml:space="preserve">
          <source>The Java&amp;trade; Language Specification, Second Edition</source>
          <target state="translated">Java&amp;trade;语言规范，第二版</target>
        </trans-unit>
        <trans-unit id="a4154fea8bd8d5b8ca35ca7f9f31b5ca95523b77" translate="yes" xml:space="preserve">
          <source>The Java&amp;trade; Language Specification, Third Edition</source>
          <target state="translated">Java&amp;trade;语言规范，第三版</target>
        </trans-unit>
        <trans-unit id="b01e874645c4aa3cc169adba9f26395f941d4bfb" translate="yes" xml:space="preserve">
          <source>The Java&amp;trade; Virtual Machine Specification</source>
          <target state="translated">Java&amp;trade;虚拟机规范</target>
        </trans-unit>
        <trans-unit id="4cadba2d15fbb9804bf151281d2e05044e9bc484" translate="yes" xml:space="preserve">
          <source>The JavaBeans&amp;trade; specification defines the notion of design time as is a mode in which JavaBeans instances should function during their composition and customization in a interactive design, composition or construction tool, as opposed to runtime when the JavaBean is part of an applet, application, or other live Java executable abstraction.</source>
          <target state="translated">JavaBeans&amp;trade;规范将设计时间的概念定义为一种模式，在这种模式下，JavaBeans实例应在其构成和自定义期间在交互式设计，构成或构造工具中发挥作用，而JavaBean是applet，应用程序，或其他实时Java可执行文件抽象。</target>
        </trans-unit>
        <trans-unit id="46152631e4488fac6b1cad7442ef7feac4ea4d12" translate="yes" xml:space="preserve">
          <source>The JobImpressions attribute describes the size of the job. This attribute is not intended to be a counter; it is intended to be useful routing and scheduling information if known. The printer may try to compute the JobImpressions attribute's value if it is not supplied in the Print Request. Even if the client does supply a value for the JobImpressions attribute in the Print Request, the printer may choose to change the value if the printer is able to compute a value which is more accurate than the client supplied value. The printer may be able to determine the correct value for the JobImpressions attribute either right at job submission time or at any later point in time.</source>
          <target state="translated">JobImpressions 属性描述了作业的大小。该属性并不是一个计数器,而是在已知的情况下作为有用的路由和调度信息。如果打印请求中没有提供JobImpressions属性的值,打印机可能会尝试计算它。即使客户在打印请求中提供了JobImpressions属性的值,如果打印机能够计算出比客户提供的值更准确的值,打印机也可以选择更改该值。打印机可以在作业提交时或在以后的任何时间确定JobImpressions属性的正确值。</target>
        </trans-unit>
        <trans-unit id="2eda45bce719c55226f8cb11330a3730a179a164" translate="yes" xml:space="preserve">
          <source>The JobImpressionsCompleted attribute describes the progress of the job. This attribute is intended to be a counter. That is, the JobImpressionsCompleted value for a job that has not started processing must be 0. When the job's &lt;a href=&quot;jobstate&quot;&gt;&lt;code&gt;JobState&lt;/code&gt;&lt;/a&gt; is PROCESSING or PROCESSING_STOPPED, the JobImpressionsCompleted value is intended to increase as the job is processed; it indicates the amount of the job that has been processed at the time the Print Job's attribute set is queried or at the time a print job event is reported. When the job enters the COMPLETED, CANCELED, or ABORTED states, the JobImpressionsCompleted value is the final value for the job.</source>
          <target state="translated">JobImpressionsCompleted属性描述作业的进度。此属性旨在作为计数器。也就是说，尚未开始处理的作业的JobImpressionsCompleted值必须为0。当作业的&lt;a href=&quot;jobstate&quot;&gt; &lt;code&gt;JobState&lt;/code&gt; &lt;/a&gt;为PROCESSING或PROCESSING_STOPPED时，JobImpressionsCompleted值将在处理作业时增加；它指示查询打印作业的属性集时或报告打印作业事件时已处理的作业量。当作业进入COMPLETED，CANCELED或ABORTED状态时，JobImpressionsCompleted值为作业的最终值。</target>
        </trans-unit>
        <trans-unit id="23b552cbebfc9eeb6f00f5f7f1d577e52be27c5e" translate="yes" xml:space="preserve">
          <source>The JobKOctets attribute describes the size of the job. This attribute is not intended to be a counter; it is intended to be useful routing and scheduling information if known. The printer may try to compute the JobKOctets attribute's value if it is not supplied in the Print Request. Even if the client does supply a value for the JobKOctets attribute in the Print Request, the printer may choose to change the value if the printer is able to compute a value which is more accurate than the client supplied value. The printer may be able to determine the correct value for the JobKOctets attribute either right at job submission time or at any later point in time.</source>
          <target state="translated">JobKOctets 属性描述了作业的大小。该属性并不是一个计数器,而是在已知的情况下作为有用的路由和调度信息。如果打印请求中没有提供JobKOctets属性的值,打印机可能会尝试计算该值。即使客户在打印请求中提供了JobKOctets属性的值,如果打印机能够计算出比客户提供的值更准确的值,打印机也可以选择更改该值。打印机可以在作业提交时或在以后的任何时间确定JobKOctets属性的正确值。</target>
        </trans-unit>
        <trans-unit id="10778b515020fa74e3922d67e4e4cfb07a6b5d4d" translate="yes" xml:space="preserve">
          <source>The JobKOctets value must also not include the multiplicative factor due to a copies instruction embedded in the document data. If the document data actually includes replications of the document data, this value will include such replication. In other words, this value is always the size of the source document data, rather than a measure of the hardcopy output to be produced.</source>
          <target state="translated">JobKOctets值还必须不包括由于文档数据中嵌入的复制指令而产生的乘法因子。如果文档数据实际上包含了文档数据的复制,那么这个值将包含这种复制。换句话说,这个值始终是源文档数据的大小,而不是对要产生的硬拷贝输出的衡量。</target>
        </trans-unit>
        <trans-unit id="4f8e193f841acdf58db4b152692036053ed12078" translate="yes" xml:space="preserve">
          <source>The JobKOctets value must not include the multiplicative factors contributed by the number of copies specified by the &lt;a href=&quot;copies&quot;&gt;&lt;code&gt;Copies&lt;/code&gt;&lt;/a&gt; attribute, independent of whether the device can process multiple copies without making multiple passes over the job or document data and independent of whether the output is collated or not. Thus the value is independent of the implementation and indicates the size of the document(s) measured in K octets independent of the number of copies.</source>
          <target state="translated">JobKOctets值不得包含由&amp;ldquo; &lt;a href=&quot;copies&quot;&gt; &lt;code&gt;Copies&lt;/code&gt; &lt;/a&gt;属性指定的副本数所贡献的乘法因子，而与设备是否可以在不对作业或文档数据进行多次遍历的情况下处理多个副本无关，并且与输出是否经过整理无关。因此，该值与实现方式无关，并且指示以K个八位字节为单位测量的文档大小，与副本数量无关。</target>
        </trans-unit>
        <trans-unit id="860b972389f862538b6b997fd07b4c1c60636261" translate="yes" xml:space="preserve">
          <source>The JobKOctetsProcessed attribute describes the progress of the job. This attribute is intended to be a counter. That is, the JobKOctetsProcessed value for a job that has not started processing must be 0. When the job's &lt;a href=&quot;jobstate&quot;&gt;&lt;code&gt;JobState&lt;/code&gt;&lt;/a&gt; is PROCESSING or PROCESSING_STOPPED, the JobKOctetsProcessed value is intended to increase as the job is processed; it indicates the amount of the job that has been processed at the time the Print Job's attribute set is queried or at the time a print job event is reported. When the job enters the COMPLETED, CANCELED, or ABORTED states, the JobKOctetsProcessed value is the final value for the job.</source>
          <target state="translated">JobKOctetsProcessed属性描述作业的进度。此属性旨在作为计数器。也就是说，尚未开始处理的作业的JobKOctetsProcessed值必须为0。当作业的&lt;a href=&quot;jobstate&quot;&gt; &lt;code&gt;JobState&lt;/code&gt; &lt;/a&gt;为PROCESSING或PROCESSING_STOPPED时，JobKOctetsProcessed值将在处理作业时增加；它指示查询打印作业的属性集时或报告打印作业事件时已处理的作业量。当作业进入COMPLETED，CANCELED或ABORTED状态时，JobKOctetsProcessed值为作业的最终值。</target>
        </trans-unit>
        <trans-unit id="67c4f689dd8dce6456481d0861afa2eb83cc72f8" translate="yes" xml:space="preserve">
          <source>The JobMediaSheets attribute describes the size of the job. This attribute is not intended to be a counter; it is intended to be useful routing and scheduling information if known. The printer may try to compute the JobMediaSheets attribute's value if it is not supplied in the Print Request. Even if the client does supply a value for the JobMediaSheets attribute in the Print Request, the printer may choose to change the value if the printer is able to compute a value which is more accurate than the client supplied value. The printer may be able to determine the correct value for the JobMediaSheets attribute either right at job submission time or at any later point in time.</source>
          <target state="translated">JobMediaSheets 属性描述了作业的大小。该属性并不是一个计数器,而是在已知的情况下作为有用的路由和调度信息。如果打印请求中没有提供JobMediaSheets属性的值,打印机可能会尝试计算该值。即使客户在打印请求中提供了JobMediaSheets属性的值,如果打印机能够计算出比客户提供的值更准确的值,打印机也可以选择更改该值。打印机可以在作业提交时或在以后的任何时间点确定JobMediaSheets属性的正确值。</target>
        </trans-unit>
        <trans-unit id="27e40040d6353841f04365a16d249f070597a18a" translate="yes" xml:space="preserve">
          <source>The JobMediaSheetsCompleted attribute describes the progress of the job. This attribute is intended to be a counter. That is, the JobMediaSheetsCompleted value for a job that has not started processing must be 0. When the job's &lt;a href=&quot;jobstate&quot;&gt;&lt;code&gt;JobState&lt;/code&gt;&lt;/a&gt; is PROCESSING or PROCESSING_STOPPED, the JobMediaSheetsCompleted value is intended to increase as the job is processed; it indicates the amount of the job that has been processed at the time the Print Job's attribute set is queried or at the time a print job event is reported. When the job enters the COMPLETED, CANCELED, or ABORTED states, the JobMediaSheetsCompleted value is the final value for the job.</source>
          <target state="translated">JobMediaSheetsCompleted属性描述作业的进度。此属性旨在作为计数器。也就是说，尚未开始处理的作业的&lt;a href=&quot;jobstate&quot;&gt; &lt;code&gt;JobState&lt;/code&gt; &lt;/a&gt;值必须为0。当作业的JobState为PROCESSING或PROCESSING_STOPPED时，JobMediaSheetsCompleted值将在处理作业时增加；它指示查询打印作业的属性集时或报告打印作业事件时已处理的作业量。当作业进入COMPLETED，CANCELED或ABORTED状态时，JobMediaSheetsCompleted值为作业的最终值。</target>
        </trans-unit>
        <trans-unit id="bc898aeb76a9f867124df93fc92a814fb7980188" translate="yes" xml:space="preserve">
          <source>The Julian Day is a standard way of expressing date and time commonly used in the scientific community. It is expressed as a decimal number of whole days where days start at midday. This class represents variations on Julian Days that count whole days from midnight.</source>
          <target state="translated">儒略日是科学界常用的一种标准日期和时间表达方式。它用整日的小数来表示,其中一天是从正午开始的。这一类代表了从午夜开始计算整日的朱利安日的变化。</target>
        </trans-unit>
        <trans-unit id="b31c8a2b1469694c5596d8e7d24f8ca4168d3814" translate="yes" xml:space="preserve">
          <source>The Kerberos network authentication protocol is defined in &lt;a href=&quot;http://www.ietf.org/rfc/rfc4120.txt&quot;&gt;RFC 4120&lt;/a&gt;. The Java platform contains support for the client side of Kerberos via the &lt;a href=&quot;/openjdk~8_web/org/ietf/jgss/package-summary&quot;&gt;&lt;code&gt;org.ietf.jgss&lt;/code&gt;&lt;/a&gt; package. There might also be a login module that implements &lt;a href=&quot;../spi/loginmodule&quot;&gt;&lt;code&gt;LoginModule&lt;/code&gt;&lt;/a&gt; to authenticate Kerberos principals.</source>
          <target state="translated">Kerberos网络认证协议在&lt;a href=&quot;http://www.ietf.org/rfc/rfc4120.txt&quot;&gt;RFC 4120中&lt;/a&gt;定义。Java平台通过&lt;a href=&quot;/openjdk~8_web/org/ietf/jgss/package-summary&quot;&gt; &lt;code&gt;org.ietf.jgss&lt;/code&gt; &lt;/a&gt;包包含对Kerberos客户端的支持。可能还会有一个登录模块，该模块实现&lt;a href=&quot;../spi/loginmodule&quot;&gt; &lt;code&gt;LoginModule&lt;/code&gt; &lt;/a&gt;来认证Kerberos主体。</target>
        </trans-unit>
        <trans-unit id="1544cf9c5107663734ae872cc327b8154b4bc517" translate="yes" xml:space="preserve">
          <source>The Key interface is the top-level interface for all keys.</source>
          <target state="translated">钥匙界面是所有钥匙的顶层界面。</target>
        </trans-unit>
        <trans-unit id="0f7ba838a05da49357b31ae6823009d4f10f3dbe" translate="yes" xml:space="preserve">
          <source>The Key interface is the top-level interface for all keys. It defines the functionality shared by all key objects. All keys have three characteristics:</source>
          <target state="translated">密钥接口是所有密钥的顶层接口。它定义了所有键对象共享的功能。所有键都有三个特征:</target>
        </trans-unit>
        <trans-unit id="cf548aaac46d4e0f0b562c298e02a26e9e223aa6" translate="yes" xml:space="preserve">
          <source>The KeyPairGenerator class is used to generate pairs of public and private keys.</source>
          <target state="translated">KeyPairGenerator类用于生成公钥和私钥的对。</target>
        </trans-unit>
        <trans-unit id="84ce39b134b25304a741de41814f7513944cfe5b" translate="yes" xml:space="preserve">
          <source>The KeyPairGenerator class is used to generate pairs of public and private keys. Key pair generators are constructed using the &lt;code&gt;getInstance&lt;/code&gt; factory methods (static methods that return instances of a given class).</source>
          <target state="translated">KeyPairGenerator类用于生成公钥和私钥对。密钥对生成器使用 &lt;code&gt;getInstance&lt;/code&gt; 工厂方法（返回给定类实例的静态方法）构造。</target>
        </trans-unit>
        <trans-unit id="15b0ebadd884d0b51462c94b77021fc226c8b293" translate="yes" xml:space="preserve">
          <source>The KeyStore is instantiated from &lt;code&gt;provider&lt;/code&gt; if non-null. Otherwise, all installed providers are searched.</source>
          <target state="translated">如果 &lt;code&gt;provider&lt;/code&gt; 为null，则从提供者实例化KeyStore 。否则，将搜索所有已安装的提供程序。</target>
        </trans-unit>
        <trans-unit id="ba0192d9ab92e21e9c2744dd9f7ef43296184075" translate="yes" xml:space="preserve">
          <source>The LDAPv3 protocol uses controls to send and receive additional data to affect the behavior of predefined operations. Controls can be sent along with any LDAP operation to the server. These are referred to as &lt;em&gt;request controls&lt;/em&gt;. For example, a &quot;sort&quot; control can be sent with an LDAP search operation to request that the results be returned in a particular order. Solicited and unsolicited controls can also be returned with responses from the server. Such controls are referred to as &lt;em&gt;response controls&lt;/em&gt;. For example, an LDAP server might define a special control to return change notifications.</source>
          <target state="translated">LDAPv3协议使用控件来发送和接收其他数据，以影响预定义操作的行为。控件可以与任何LDAP操作一起发送到服务器。这些被称为&lt;em&gt;请求控件&lt;/em&gt;。例如，可以通过LDAP搜索操作发送&amp;ldquo;排序&amp;rdquo;控件，以请求以特定顺序返回结果。还可以将请求的和未经请求的控件与服务器的响应一起返回。这种控制称为&lt;em&gt;响应控制&lt;/em&gt;。例如，LDAP服务器可能定义一个特殊的控件来返回更改通知。</target>
        </trans-unit>
        <trans-unit id="e247331a2fdfcd1f002adc01fbf899e2a1591f78" translate="yes" xml:space="preserve">
          <source>The Level class defines a set of standard logging levels that can be used to control logging output.</source>
          <target state="translated">等级类定义了一组可用于控制日志输出的标准日志等级。</target>
        </trans-unit>
        <trans-unit id="5e0b0c714c17843fb551c38291dba43f83549e84" translate="yes" xml:space="preserve">
          <source>The Level class defines a set of standard logging levels that can be used to control logging output. The logging Level objects are ordered and are specified by ordered integers. Enabling logging at a given level also enables logging at all higher levels.</source>
          <target state="translated">等级类定义了一组标准的日志记录等级,可用于控制日志记录输出。日志等级对象是有序的,由有序的整数指定。启用某个级别的日志记录也会启用所有更高一级的日志记录。</target>
        </trans-unit>
        <trans-unit id="23341604b8e30c5db6f5082ffe273ce643ebf866" translate="yes" xml:space="preserve">
          <source>The LineEvent.Type inner class identifies what kind of event occurred on a line.</source>
          <target state="translated">LineEvent.Type内类标识了线上发生了什么样的事件。</target>
        </trans-unit>
        <trans-unit id="f4515bae178db99e414cd4419e58ab70e3a4ab78" translate="yes" xml:space="preserve">
          <source>The LineEvent.Type inner class identifies what kind of event occurred on a line. Static instances are provided for the common types (OPEN, CLOSE, START, and STOP).</source>
          <target state="translated">LineEvent.Type内类标识了行上发生的事件类型。为常见类型(OPEN、CLOSE、START和STOP)提供了静态实例。</target>
        </trans-unit>
        <trans-unit id="15a370cb868586ab99d868f607377364eaa66939" translate="yes" xml:space="preserve">
          <source>The Locale constructors have always specified that the language and the country param be two characters in length, although in practice they have accepted any length. The specification has now been relaxed to allow language codes of two to eight characters and country (region) codes of two to three characters, and in particular, three-letter language codes and three-digit region codes as specified in the IANA Language Subtag Registry. For compatibility, the implementation still does not impose a length constraint.</source>
          <target state="translated">Locale 构造者总是规定语言和国家参数的长度为两个字符,尽管在实践中它们接受任何长度。现在,该规范已被放宽,允许使用2至8个字符的语言代码和2至3个字符的国家(地区)代码,特别是IANA语言子标签注册表中规定的3个字母的语言代码和3位数的地区代码。为兼容起见,执行时仍不施加长度限制。</target>
        </trans-unit>
        <trans-unit id="3bb20e6e58795891b26d0418b98b5c49029c3c3e" translate="yes" xml:space="preserve">
          <source>The LogManager defines two optional system properties that allow control over the initial configuration:</source>
          <target state="translated">日志管理器定义了两个可选的系统属性,允许对初始配置进行控制。</target>
        </trans-unit>
        <trans-unit id="3cca1e6f62e92b82a24f09973b67d35f6162ed74" translate="yes" xml:space="preserve">
          <source>The LogRecord class is serializable.</source>
          <target state="translated">LogRecord类是可序列化的。</target>
        </trans-unit>
        <trans-unit id="37b5ec8719483e5837405faf74d2042c53b0e061" translate="yes" xml:space="preserve">
          <source>The Logger factory methods call this method to register each newly created Logger.</source>
          <target state="translated">记录仪工厂方法调用此方法来注册每个新创建的记录仪。</target>
        </trans-unit>
        <trans-unit id="16fa852d45e166564cfd7fb514ab7d4a6acfffbe" translate="yes" xml:space="preserve">
          <source>The Logging APIs offer both static and dynamic configuration control. Static control enables field service staff to set up a particular configuration and then re-launch the application with the new logging settings. Dynamic control allows for updates to the logging configuration within a currently running program. The APIs also allow for logging to be enabled or disabled for different functional areas of the system. For example, a field service engineer might be interested in tracing all AWT events, but might have no interest in socket events or memory management.</source>
          <target state="translated">日志 API 提供静态和动态配置控制。静态控制使现场服务人员能够设置特定的配置,然后使用新的日志设置重新启动应用程序。动态控制允许在当前运行的程序中更新日志记录配置。API还允许为系统的不同功能区域启用或禁用日志记录。例如,现场服务工程师可能对跟踪所有AWT事件感兴趣,但可能对套接字事件或内存管理不感兴趣。</target>
        </trans-unit>
        <trans-unit id="8d2c9dc56a0259f0e6bad38df059f2ef62f5a015" translate="yes" xml:space="preserve">
          <source>The LoginModule-specific options represent the options configured for this &lt;code&gt;LoginModule&lt;/code&gt; by an administrator or user in the login &lt;code&gt;Configuration&lt;/code&gt;. The options are defined by the &lt;code&gt;LoginModule&lt;/code&gt; itself and control the behavior within it. For example, a &lt;code&gt;LoginModule&lt;/code&gt; may define options to support debugging/testing capabilities. Options are defined using a key-value syntax, such as</source>
          <target state="translated">特定于LoginModule的选项表示管理员或用户在登录 &lt;code&gt;Configuration&lt;/code&gt; 中为此 &lt;code&gt;LoginModule&lt;/code&gt; 配置的选项。这些选项由 &lt;code&gt;LoginModule&lt;/code&gt; 本身定义，并控制其中的行为。例如， &lt;code&gt;LoginModule&lt;/code&gt; 可以定义选项以支持调试/测试功能。使用键值语法定义选项，例如</target>
        </trans-unit>
        <trans-unit id="873df94afa4e7ad82e48e9073fb806c35bb167b5" translate="yes" xml:space="preserve">
          <source>The MAC result is stored in &lt;code&gt;output&lt;/code&gt;, starting at &lt;code&gt;outOffset&lt;/code&gt; inclusive.</source>
          <target state="translated">MAC结果存储在 &lt;code&gt;output&lt;/code&gt; 中，从 &lt;code&gt;outOffset&lt;/code&gt; (含）开始。</target>
        </trans-unit>
        <trans-unit id="8e20974e279464971ac54f4c492ac718451f3fb7" translate="yes" xml:space="preserve">
          <source>The MBean Server can be queried for MBeans that meet a particular condition, using its &lt;a href=&quot;mbeanserver#queryNames-javax.management.ObjectName-javax.management.QueryExp-&quot;&gt;&lt;code&gt;queryNames&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;mbeanserver#queryMBeans-javax.management.ObjectName-javax.management.QueryExp-&quot;&gt;&lt;code&gt;queryMBeans&lt;/code&gt;&lt;/a&gt; method. The &lt;a href=&quot;queryexp&quot;&gt;&lt;code&gt;QueryExp&lt;/code&gt;&lt;/a&gt; parameter to the method can be any implementation of the interface &lt;code&gt;QueryExp&lt;/code&gt;, but it is usually best to obtain the &lt;code&gt;QueryExp&lt;/code&gt; value by calling the static methods in this class. This is particularly true when querying a remote MBean Server: a custom implementation of the &lt;code&gt;QueryExp&lt;/code&gt; interface might not be present in the remote MBean Server, but the methods in this class return only standard classes that are part of the JMX implementation.</source>
          <target state="translated">可以使用&lt;a href=&quot;mbeanserver#queryMBeans-javax.management.ObjectName-javax.management.QueryExp-&quot;&gt; &lt;code&gt;queryMBeans&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;mbeanserver#queryNames-javax.management.ObjectName-javax.management.QueryExp-&quot;&gt; &lt;code&gt;queryNames&lt;/code&gt; &lt;/a&gt;或queryMBeans方法向MBean Server查询满足特定条件的MBean 。该方法的&lt;a href=&quot;queryexp&quot;&gt; &lt;code&gt;QueryExp&lt;/code&gt; &lt;/a&gt;参数可以是 &lt;code&gt;QueryExp&lt;/code&gt; 接口的任何实现，但是通常最好是通过调用此类中的静态方法来获取 &lt;code&gt;QueryExp&lt;/code&gt; 值。当查询远程MBean Server时尤其如此：远程MBean Server中可能不存在 &lt;code&gt;QueryExp&lt;/code&gt; 接口的自定义实现，但是此类中的方法仅返回JMX实现中的标准类。</target>
        </trans-unit>
        <trans-unit id="72d1d3a5c29db56a086580b10e87cee9417c2769" translate="yes" xml:space="preserve">
          <source>The MBean Server used is the one returned by &lt;a href=&quot;queryeval#getMBeanServer--&quot;&gt;&lt;code&gt;QueryEval.getMBeanServer()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">使用的MBean服务器是&lt;a href=&quot;queryeval#getMBeanServer--&quot;&gt; &lt;code&gt;QueryEval.getMBeanServer()&lt;/code&gt; &lt;/a&gt;返回的服务器。</target>
        </trans-unit>
        <trans-unit id="21324a38f03c31ace3a1e422ca3454c83ac8dbb8" translate="yes" xml:space="preserve">
          <source>The MBean is already registered in the repository.</source>
          <target state="translated">MBean已经在版本库中注册。</target>
        </trans-unit>
        <trans-unit id="43753879ff4a9ab9e94f41c105bc04ec605906f3" translate="yes" xml:space="preserve">
          <source>The MBean must have a listener that exactly matches the given &lt;code&gt;listener&lt;/code&gt;, &lt;code&gt;filter&lt;/code&gt;, and &lt;code&gt;handback&lt;/code&gt; parameters. If there is more than one such listener, only one is removed.</source>
          <target state="translated">MBean必须具有与给定的 &lt;code&gt;listener&lt;/code&gt; ， &lt;code&gt;filter&lt;/code&gt; 和 &lt;code&gt;handback&lt;/code&gt; 参数完全匹配的侦听器。如果此类侦听器不止一个，则仅删除一个。</target>
        </trans-unit>
        <trans-unit id="30152426051a3aa7c2787f9bb448c65fd9d96573" translate="yes" xml:space="preserve">
          <source>The MBean server connection through which the methods of a proxy using this handler are forwarded.</source>
          <target state="translated">转发使用该处理程序的代理方法的MBean服务器连接。</target>
        </trans-unit>
        <trans-unit id="5a6b667365181658d557141a79bdcd9ae1d79d48" translate="yes" xml:space="preserve">
          <source>The MBeanServer reference is internally kept. This will allow &lt;code&gt;findMBeanServer&lt;/code&gt; to return a reference to this MBeanServer object.</source>
          <target state="translated">MBeanServer引用在内部保留。这将使 &lt;code&gt;findMBeanServer&lt;/code&gt; 返回对该MBeanServer对象的引用。</target>
        </trans-unit>
        <trans-unit id="fce98176f741b29841e04388f314ecc341556fb9" translate="yes" xml:space="preserve">
          <source>The MBeanServerBuilder makes it possible to wrap the MBeanServers returned by the default MBeanServerBuilder implementation, for the purpose of e.g. adding an additional security layer.</source>
          <target state="translated">MBeanServerBuilder可以将默认的MBeanServerBuilder实现所返回的MBeanServers进行封装,以便增加额外的安全层。</target>
        </trans-unit>
        <trans-unit id="c43e787474141d0bb72e21314b04491164ecd29c" translate="yes" xml:space="preserve">
          <source>The MGF1ParameterSpec which uses &quot;SHA-1&quot; message digest.</source>
          <target state="translated">使用 &quot;SHA-1 &quot;消息摘要的MGF1ParameterSpec。</target>
        </trans-unit>
        <trans-unit id="ded68968556406a67098d9312cb325eb7740b1a7" translate="yes" xml:space="preserve">
          <source>The MGF1ParameterSpec which uses &quot;SHA-224&quot; message digest.</source>
          <target state="translated">使用 &quot;SHA-224 &quot;消息摘要的MGF1ParameterSpec。</target>
        </trans-unit>
        <trans-unit id="30567a972c0ebfa4faa9759c8c4f5615d0736a78" translate="yes" xml:space="preserve">
          <source>The MGF1ParameterSpec which uses &quot;SHA-256&quot; message digest.</source>
          <target state="translated">使用 &quot;SHA-256 &quot;消息摘要的MGF1ParameterSpec。</target>
        </trans-unit>
        <trans-unit id="8f743fd5434a0de8774dcd2c54b80badfe4a3dec" translate="yes" xml:space="preserve">
          <source>The MGF1ParameterSpec which uses &quot;SHA-384&quot; message digest.</source>
          <target state="translated">使用 &quot;SHA-384 &quot;消息摘要的MGF1ParameterSpec。</target>
        </trans-unit>
        <trans-unit id="773fa0838097295208f32770a4edbdf66bd50a46" translate="yes" xml:space="preserve">
          <source>The MGF1ParameterSpec which uses SHA-512 message digest.</source>
          <target state="translated">使用SHA-512消息摘要的MGF1ParameterSpec。</target>
        </trans-unit>
        <trans-unit id="516e21a61c986db4b650efb7f3b9edffb19e1c28" translate="yes" xml:space="preserve">
          <source>The MIDI 1.0 Specification defines both 7-bit controllers and 14-bit controllers. Continuous controllers, such as wheels and sliders, typically have 14 bits (two MIDI bytes), while discrete controllers, such as switches, typically have 7 bits (one MIDI byte). Refer to the specification to see the expected resolution for each type of control.</source>
          <target state="translated">MIDI 1.0规范定义了7位控制器和14位控制器,连续控制器,如轮子和滑块,通常有14位(两个MIDI字节),而离散控制器,如开关,通常有7位(一个MIDI字节)。连续控制器,如滚轮和滑块,通常有14位(两个MIDI字节),而离散控制器,如开关,通常有7位(一个MIDI字节)。请参阅规格书,了解每种类型控制器的预期分辨率。</target>
        </trans-unit>
        <trans-unit id="3b90ca10823dacdb7ec1aff6e9c338eb2858be24" translate="yes" xml:space="preserve">
          <source>The MIDI 1.0 specification provides for 16 channels, so this method returns an array of at least 16 elements. However, if this synthesizer doesn't make use of all 16 channels, some of the elements of the array might be &lt;code&gt;null&lt;/code&gt;, so you should check each element before using it.</source>
          <target state="translated">MIDI 1.0规范提供了16个通道，因此此方法返回至少包含16个元素的数组。但是，如果此合成器未使用全部16个通道，则数组中的某些元素可能为 &lt;code&gt;null&lt;/code&gt; ，因此应在使用每个元素之前对其进行检查。</target>
        </trans-unit>
        <trans-unit id="b52e6c1511e484eaf10f9c3556aee2243b42e67c" translate="yes" xml:space="preserve">
          <source>The MIDI channel on which this voice is playing. The value is a zero-based channel number if the voice is active, or unspecified if the voice is inactive.</source>
          <target state="translated">该声音正在播放的MIDI通道。如果声音处于活动状态,该值是一个基于零的通道号,如果声音处于非活动状态,则未指定。</target>
        </trans-unit>
        <trans-unit id="72e471be8e18253cd2fa90755b2430be47a7c9c7" translate="yes" xml:space="preserve">
          <source>The MIDI message data. The first byte is the status byte for the message; subsequent bytes up to the length of the message are data bytes for this message.</source>
          <target state="translated">MIDI信息数据。第一个字节是信息的状态字节,随后的字节直到信息的长度都是该信息的数据字节。</target>
        </trans-unit>
        <trans-unit id="09d0f1e1fda22537e5c3106cad4d736b151fe66f" translate="yes" xml:space="preserve">
          <source>The MIDI note that this voice is playing. The range for an active voice is from 0 to 127 in semitones, with 60 referring to Middle C. The value is unspecified if the voice is inactive.</source>
          <target state="translated">该音符正在演奏的MIDI音符。活动音的范围是0到127,以半音为单位,60指的是中音C。</target>
        </trans-unit>
        <trans-unit id="9f275ac1e77302fd1f9c984942071af0000235dd" translate="yes" xml:space="preserve">
          <source>The MIDI specification does not dictate whether notes that are already sounding should switch to the new instrument (timbre) or continue with their original timbre until terminated by a note-off.</source>
          <target state="translated">MIDI规范并没有规定已经发出声音的音符应该切换到新的乐器(音色)上,还是继续保持原来的音色,直到被一个音符终止。</target>
        </trans-unit>
        <trans-unit id="635898bd1d6ec018c38dd8a4feda9d061e0d6d2b" translate="yes" xml:space="preserve">
          <source>The MIDI specification stipulates that pitch bend be a 14-bit value, where zero is maximum downward bend, 16383 is maximum upward bend, and 8192 is the center (no pitch bend). The actual amount of pitch change is not specified; it can be changed by a pitch-bend sensitivity setting. However, the General MIDI specification says that the default range should be two semitones up and down from center. It is possible that the underlying synthesizer does not support this MIDI message. In order to verify that &lt;code&gt;setPitchBend&lt;/code&gt; was successful, use &lt;code&gt;getPitchBend&lt;/code&gt;.</source>
          <target state="translated">MIDI规范规定，音高弯曲为14位值，其中零是最大向下弯曲，16383是最大向上弯曲，8192是中心（无音高弯曲）。没有指定实际的音高变化量。可以通过弯音灵敏度设置进行更改。但是，通用MIDI规范说默认范围应该是从中心上下两个半音。底层的合成器可能不支持此MIDI消息。为了验证 &lt;code&gt;setPitchBend&lt;/code&gt; 是否成功，请使用 &lt;code&gt;getPitchBend&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c526e09fb95606778bb5e764a54a0e9f208fc206" translate="yes" xml:space="preserve">
          <source>The MIDI standard expresses MIDI data in bytes. However, because Java&lt;sup id=&quot;integersVsBytes&quot;&gt;TM&lt;/sup&gt; uses signed bytes, the Java Sound API uses integers instead of bytes when expressing MIDI data. For example, the &lt;a href=&quot;midimessage#getStatus--&quot;&gt;&lt;code&gt;getStatus()&lt;/code&gt;&lt;/a&gt; method of &lt;code&gt;MidiMessage&lt;/code&gt; returns MIDI status bytes as integers. If you are processing MIDI data that originated outside Java Sound and now is encoded as signed bytes, the bytes can can be converted to integers using this conversion:</source>
          <target state="translated">MIDI标准以字节表示MIDI数据。但是，由于Java &lt;sup id=&quot;integersVsBytes&quot;&gt;TM&lt;/sup&gt;使用带符号的字节，因此Java Sound API在表示MIDI数据时使用整数而不是字节。例如， &lt;code&gt;MidiMessage&lt;/code&gt; 的&lt;a href=&quot;midimessage#getStatus--&quot;&gt; &lt;code&gt;getStatus()&lt;/code&gt; &lt;/a&gt;方法以整数形式返回MIDI状态字节。如果您正在处理源自Java Sound之外的MIDI数据，现在将它们编码为带符号字节，则可以使用以下转换将字节转换为整数：</target>
        </trans-unit>
        <trans-unit id="0c8a2781b35fa31817c29abe30b50e8043af665c" translate="yes" xml:space="preserve">
          <source>The MIDI tracks in this sequence.</source>
          <target state="translated">这个序列中的MIDI轨道。</target>
        </trans-unit>
        <trans-unit id="23a350af8445001f598c4651a4f45324e9f33c23" translate="yes" xml:space="preserve">
          <source>The MLet text file's base URL.</source>
          <target state="translated">MLet文本文件的基本URL。</target>
        </trans-unit>
        <trans-unit id="db0ce9ae1e5d2f89a8f312663fdfbed2b32ba495" translate="yes" xml:space="preserve">
          <source>The MXBean concept provides a simple way to code an MBean that only references a predefined set of types, the ones defined by &lt;a href=&quot;openmbean/package-summary&quot;&gt;&lt;code&gt;javax.management.openmbean&lt;/code&gt;&lt;/a&gt;. In this way, you can be sure that your MBean will be usable by any client, including remote clients, without any requirement that the client have access to &lt;em&gt;model-specific classes&lt;/em&gt; representing the types of your MBeans.</source>
          <target state="translated">MXBean概念提供了一种简单的方法来编写仅引用预定义类型集（由&lt;a href=&quot;openmbean/package-summary&quot;&gt; &lt;code&gt;javax.management.openmbean&lt;/code&gt; &lt;/a&gt;定义的类型）的MBean 。这样，您可以确保您的MBean可被任何客户端（包括远程客户端）使用，而无需客户端有权访问代表MBean类型的&lt;em&gt;特定&lt;/em&gt;于&lt;em&gt;模型的类&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="d4a3d1afcec2a7b84cb429f3bcbbf430180a0aa8" translate="yes" xml:space="preserve">
          <source>The ManageReferral control's assigned object identifier is 2.16.840.1.113730.3.4.2.</source>
          <target state="translated">ManageReferral控件的指定对象标识符为2.16.840.1.113730.3.4.2。</target>
        </trans-unit>
        <trans-unit id="f0c9875b8d07e007e2745fc0af6fe732b94df483" translate="yes" xml:space="preserve">
          <source>The Manifest class is used to maintain Manifest entry names and their associated Attributes.</source>
          <target state="translated">Manifest类用于维护Manifest条目名称及其相关的Attributes。</target>
        </trans-unit>
        <trans-unit id="0f91edbc800e6ebe0a97d46777ffeab5dd79019f" translate="yes" xml:space="preserve">
          <source>The Manifest class is used to maintain Manifest entry names and their associated Attributes. There are main Manifest Attributes as well as per-entry Attributes. For information on the Manifest format, please see the  Manifest format specification.</source>
          <target state="translated">Manifest类用于维护Manifest条目名称及其相关的属性。有主要的Manifest属性和每个条目的属性。有关Manifest格式的信息,请参见Manifest格式规范。</target>
        </trans-unit>
        <trans-unit id="a14dcb9ffe833bd8ff0c3971c624e1ee8fa1ea44" translate="yes" xml:space="preserve">
          <source>The MediaSize is in turn used to locate the MediaSizeName object. This method may return null if the closest matching MediaSize has no corresponding Media instance.</source>
          <target state="translated">MediaSize 又用于定位 MediaSizeName 对象。如果最接近的匹配 MediaSize 没有对应的 Media 实例,则此方法可能返回 null。</target>
        </trans-unit>
        <trans-unit id="875260bee7cb4b86188f6d5c14bdd4b99434b19c" translate="yes" xml:space="preserve">
          <source>The Minguo calendar system has two eras, 'ROC' and 'BEFORE_ROC', defined by &lt;a href=&quot;minguoera&quot;&gt;&lt;code&gt;MinguoEra&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">民国日历系统具有两个时代，&amp;ldquo;中华民国&amp;rdquo;和&amp;ldquo;BEFORE_ROC&amp;rdquo;，通过定义&lt;a href=&quot;minguoera&quot;&gt; &lt;code&gt;MinguoEra&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8488e49133ae34f00360eaccd8da765934bd62e6" translate="yes" xml:space="preserve">
          <source>The Minguo calendar system has two eras. The current era, for years from 1 onwards, is known as the 'Republic of China' era. All previous years, zero or earlier in the proleptic count or one and greater in the year-of-era count, are part of the 'Before Republic of China' era.</source>
          <target state="translated">民国历法体系有两个时代。当前时代,从1开始的年份,称为'中华民国'时代。凡是以前的年份,亲数为0或更早的年份,或年代数为1及以上的年份,都属于'民国前'时代。</target>
        </trans-unit>
        <trans-unit id="82fefb5d3040f57efd3b63bb98ca09fc3ccfc0a0" translate="yes" xml:space="preserve">
          <source>The Minguo calendar system.</source>
          <target state="translated">民国历制。</target>
        </trans-unit>
        <trans-unit id="a545218db7a03aed04c1ac511afdb4cfed76973c" translate="yes" xml:space="preserve">
          <source>The ModelMBeanAttributeInfo isReadable method returns 'false'.</source>
          <target state="translated">ModelMBeanAttributeInfo isReadable方法返回'false'。</target>
        </trans-unit>
        <trans-unit id="622c5c9f064611bbc382eb21caab00da9baf69e6" translate="yes" xml:space="preserve">
          <source>The ModelMBeanAttributeInfo object describes an attribute of the ModelMBean.</source>
          <target state="translated">ModelMBeanAttributeInfo对象描述了ModelMBean的一个属性。</target>
        </trans-unit>
        <trans-unit id="7515b956ff4baf3913874b737697b14e24efd566" translate="yes" xml:space="preserve">
          <source>The ModelMBeanAttributeInfo object describes an attribute of the ModelMBean. It is a subclass of MBeanAttributeInfo with the addition of an associated Descriptor and an implementation of the DescriptorAccess interface.</source>
          <target state="translated">ModelMBeanAttributeInfo对象描述了ModelMBean的一个属性,它是MBeanAttributeInfo的子类,增加了一个相关的Descriptor和DescriptorAccess接口的实现。它是MBeanAttributeInfo的一个子类,增加了一个关联的Descriptor和DescriptorAccess接口的实现。</target>
        </trans-unit>
        <trans-unit id="0c7970e27c195e599aad6a1440a8c2fd34d10c3b" translate="yes" xml:space="preserve">
          <source>The ModelMBeanAttributeInfo's isWritable method returns 'false'.</source>
          <target state="translated">ModelMBeanAttributeInfo的isWritable方法返回'false'。</target>
        </trans-unit>
        <trans-unit id="ee6068579dec79a74358815593f8fb0ae992ddc8" translate="yes" xml:space="preserve">
          <source>The ModelMBeanConstructorInfo object describes a constructor of the ModelMBean.</source>
          <target state="translated">ModelMBeanConstructorInfo对象描述了一个ModelMBean的构造函数。</target>
        </trans-unit>
        <trans-unit id="d6d0e1ffbdbc4b382742186b6969198f0e473566" translate="yes" xml:space="preserve">
          <source>The ModelMBeanConstructorInfo object describes a constructor of the ModelMBean. It is a subclass of MBeanConstructorInfo with the addition of an associated Descriptor and an implementation of the DescriptorAccess interface.</source>
          <target state="translated">ModelMBeanConstructorInfo对象描述了一个ModelMBean的构造函数,它是MBeanConstructorInfo的一个子类,增加了相关的Descriptor和DescriptorAccess接口的实现。它是MBeanConstructorInfo的一个子类,增加了一个关联的Descriptor和DescriptorAccess接口的实现。</target>
        </trans-unit>
        <trans-unit id="9ea1fe7432118222c8edb7be56bce005b9d32202" translate="yes" xml:space="preserve">
          <source>The ModelMBeanInfo of the Model MBean is stored in a file.</source>
          <target state="translated">模型MBean的ModelMBeanInfo存储在一个文件中。</target>
        </trans-unit>
        <trans-unit id="be717043f5a4f39bd2bd5c39bd928fa423eadd62" translate="yes" xml:space="preserve">
          <source>The ModelMBeanNotificationInfo object describes a notification emitted by a ModelMBean.</source>
          <target state="translated">ModelMBeanNotificationInfo对象描述一个ModelMBean发出的通知。</target>
        </trans-unit>
        <trans-unit id="0e87a04c7fd637b21db2de3d9c9f1aa8fb0a7e77" translate="yes" xml:space="preserve">
          <source>The ModelMBeanNotificationInfo object describes a notification emitted by a ModelMBean. It is a subclass of MBeanNotificationInfo with the addition of an associated Descriptor and an implementation of the Descriptor interface.</source>
          <target state="translated">ModelMBeanNotificationInfo对象描述了由ModelMBean发出的通知,它是MBeanNotificationInfo的一个子类,增加了相关的Descriptor和Descriptor接口的实现。它是MBeanNotificationInfo的一个子类,增加了一个关联的Descriptor和Descriptor接口的实现。</target>
        </trans-unit>
        <trans-unit id="fe7d736d21ad24599ca368ba9eda956e4fa29c39" translate="yes" xml:space="preserve">
          <source>The ModelMBeanOperationInfo object describes a management operation of the ModelMBean.</source>
          <target state="translated">ModelMBeanOperationInfo对象描述了ModelMBean的管理操作。</target>
        </trans-unit>
        <trans-unit id="f0a2617a3fc98a6c5d488b0a6049a4f3b639a203" translate="yes" xml:space="preserve">
          <source>The ModelMBeanOperationInfo object describes a management operation of the ModelMBean. It is a subclass of MBeanOperationInfo with the addition of an associated Descriptor and an implementation of the DescriptorAccess interface.</source>
          <target state="translated">ModelMBeanOperationInfo对象描述了ModelMBean的管理操作。它是MBeanOperationInfo的一个子类,增加了一个关联的Descriptor和DescriptorAccess接口的实现。</target>
        </trans-unit>
        <trans-unit id="513ceb059a7b6fcddfe05011f87eba04b0d4e534" translate="yes" xml:space="preserve">
          <source>The Modifier class provides &lt;code&gt;static&lt;/code&gt; methods and constants to decode class and member access modifiers.</source>
          <target state="translated">Modifier类提供了 &lt;code&gt;static&lt;/code&gt; 方法和常量来解码类和成员访问修饰符。</target>
        </trans-unit>
        <trans-unit id="01b236d448fafe1eecbecf699e0dbd1752899ea4" translate="yes" xml:space="preserve">
          <source>The Modifier class provides &lt;code&gt;static&lt;/code&gt; methods and constants to decode class and member access modifiers. The sets of modifiers are represented as integers with distinct bit positions representing different modifiers. The values for the constants representing the modifiers are taken from the tables in sections 4.1, 4.4, 4.5, and 4.7 of</source>
          <target state="translated">Modifier类提供了 &lt;code&gt;static&lt;/code&gt; 方法和常量来解码类和成员访问修饰符。修饰符集用整数表示，整数位代表不同的修饰符。表示修饰符的常量的值取自第4.1、4.4、4.5和4.7节中的表。</target>
        </trans-unit>
        <trans-unit id="2333e86e53a0d2dc1db2ea3db8dcf5c9ff0df51f" translate="yes" xml:space="preserve">
          <source>The NUMERIC_SHAPING attribute in the text, if present, converts European digits to other decimal digits before running the bidi algorithm. This attribute, if present, must be applied to all the text in the paragraph.</source>
          <target state="translated">文本中的NUMERIC_SHAPING属性,如果存在,则在运行bidi算法之前,将欧式数字转换为其他十进制数字。这个属性如果存在,必须应用于该段的所有文本。</target>
        </trans-unit>
        <trans-unit id="463ad161e211102811e3b4f729e92c59017920f0" translate="yes" xml:space="preserve">
          <source>The NamingEnumeration that results from search() using OBJECT_SCOPE will contain one or zero element. The enumeration contains one element if the named object satisfies the search filter specified in search(). The element will have as its name the empty string because the names of elements in the NamingEnumeration are relative to the target context--in this case, the target context is the named object. It contains zero element if the named object does not satisfy the search filter specified in search().</source>
          <target state="translated">使用OBJECT_SCOPE的search()产生的NamingEnumeration将包含一个或零个元素。如果命名的对象满足search()中指定的搜索过滤器,那么这个枚举就包含一个元素。这个元素的名称是空字符串,因为NamingEnumeration中的元素名称是相对于目标上下文的,在这种情况下,目标上下文是被命名的对象。如果命名对象不满足search()中指定的搜索过滤器,则该元素的名称为零。</target>
        </trans-unit>
        <trans-unit id="f597fd36413579878114afaa6d6023419e477bcb" translate="yes" xml:space="preserve">
          <source>The NamingEnumeration that results from search() using ONELEVEL_SCOPE contains elements with objects in the named context that satisfy the search filter specified in search(). The names of elements in the NamingEnumeration are atomic names relative to the named context.</source>
          <target state="translated">使用 ONELEVEL_SCOPE 的 search()所产生的 NamingEnumeration 包含在命名上下文中满足 search()所指定的搜索过滤器的对象的元素。NamingEnumeration中的元素名称是相对于命名上下文的原子名。</target>
        </trans-unit>
        <trans-unit id="da9e1b040a45d5ff3225e516ec2f10b9b87c4fde" translate="yes" xml:space="preserve">
          <source>The NamingEnumeration that results from search() using SUBTREE_SCOPE contains elements of objects from the subtree (including the named context) that satisfy the search filter specified in search(). The names of elements in the NamingEnumeration are either relative to the named context or is a URL string. If the named context satisfies the search filter, it is included in the enumeration with the empty string as its name.</source>
          <target state="translated">使用SUBTREE_SCOPE的search()搜索结果的NamingEnumeration包含了满足search()指定的搜索过滤器的子树(包括命名上下文)对象的元素。NamingEnumeration中元素的名字要么是相对于命名上下文的,要么是一个URL字符串。如果命名的上下文满足搜索过滤器的要求,那么它就会被包含在枚举中,并以空字符串作为它的名字。</target>
        </trans-unit>
        <trans-unit id="339f160048f54fde5fb16ed0dd770edbfb611d30" translate="yes" xml:space="preserve">
          <source>The Notification class represents a notification emitted by an MBean.</source>
          <target state="translated">Notification类表示一个MBean发出的通知。</target>
        </trans-unit>
        <trans-unit id="cf39ffb21a4256234c05b38d7bda0371c83db12a" translate="yes" xml:space="preserve">
          <source>The Notification class represents a notification emitted by an MBean. It contains a reference to the source MBean: if the notification has been forwarded through the MBean server, and the original source of the notification was a reference to the emitting MBean object, then the MBean server replaces it by the MBean's ObjectName. If the listener has registered directly with the MBean, this is either the object name or a direct reference to the MBean.</source>
          <target state="translated">Notification类表示一个MBean发出的通知。它包含对源MBean的引用:如果通知是通过MBean服务器转发的,并且通知的原始来源是对发出的MBean对象的引用,那么MBean服务器就会用MBean的ObjectName来代替它。如果监听器已经直接向MBean注册,那么这就是对象名或对MBean的直接引用。</target>
        </trans-unit>
        <trans-unit id="21674881f205ff2b1ebde10ad56146b65e883a73" translate="yes" xml:space="preserve">
          <source>The NullCipher class is a class that provides an &quot;identity cipher&quot; -- one that does not transform the plain text.</source>
          <target state="translated">NullCipher类是一个提供 &quot;身份密码 &quot;的类--一个不转换纯文本的类。</target>
        </trans-unit>
        <trans-unit id="4eba459ac1063b013ecb05450cfc942330983956" translate="yes" xml:space="preserve">
          <source>The NullCipher class is a class that provides an &quot;identity cipher&quot; -- one that does not transform the plain text. As a consequence, the ciphertext is identical to the plaintext. All initialization methods do nothing, while the blocksize is set to 1 byte.</source>
          <target state="translated">NullCipher类是一个提供 &quot;身份密码 &quot;的类 ----一个不转换明文的密码。因此,密文与明文是相同的。所有的初始化方法都不做任何事情,而块大小被设置为1字节。</target>
        </trans-unit>
        <trans-unit id="af7f35dd7e76fe866932423b2aed6d1fb8aee4d0" translate="yes" xml:space="preserve">
          <source>The OAEP parameter set with all default values.</source>
          <target state="translated">OAEP参数设置为所有默认值。</target>
        </trans-unit>
        <trans-unit id="d3c91484eda423d34310b6f683e8f9c4d38353ad" translate="yes" xml:space="preserve">
          <source>The OCSP responder returns one of the following errors specified in section 2.3 of RFC 2560: internalError or tryLater.</source>
          <target state="translated">OCSP响应者返回RFC 2560的2.3节中指定的以下错误之一:internalError或tryLater。</target>
        </trans-unit>
        <trans-unit id="590e9f81926a84b9e3f08b8204debee01bf90568" translate="yes" xml:space="preserve">
          <source>The Object to which resolution was successful. Cannot be null.</source>
          <target state="translated">解析成功的对象。不能为空。</target>
        </trans-unit>
        <trans-unit id="2d9af7dd4afe4b3827fea167ae916792006d5495" translate="yes" xml:space="preserve">
          <source>The ObjectFactoryBuilder determines the policy used when trying to load object factories. See getObjectInstance() and class ObjectFactory for a description of the default policy. setObjectFactoryBuilder() overrides this default policy by installing an ObjectFactoryBuilder. Subsequent object factories will be loaded and created using the installed builder.</source>
          <target state="translated">ObjectFactoryBuilder决定了尝试加载对象工厂时使用的策略。请参阅getObjectInstance()和类ObjectFactory了解默认策略的描述。setObjectFactoryBuilder()通过安装一个ObjectFactoryBuilder来覆盖这个默认策略。随后的对象工厂将使用安装的构建器进行加载和创建。</target>
        </trans-unit>
        <trans-unit id="5419cd5a84f61ee5075bb1b79dcc22de8c464f19" translate="yes" xml:space="preserve">
          <source>The ObjectOutputStream.writeObject method takes a parameter of type Object (as opposed to type Serializable) to allow for cases where non-serializable objects are replaced by serializable ones.</source>
          <target state="translated">ObjectOutputStream.writeObject方法的参数是Object类型(相对于Serializable类型),以允许非可序列化对象被可序列化对象替换的情况。</target>
        </trans-unit>
        <trans-unit id="d1e3e58b05fa221f0f71b1840e5fa4b72d867a75" translate="yes" xml:space="preserve">
          <source>The ObjectStreamField object of the named field or null if there is no such named field.</source>
          <target state="translated">命名字段的ObjectStreamField对象,如果没有命名字段,则为空。</target>
        </trans-unit>
        <trans-unit id="14746a7869df9344bf3add89eda86eda0f27df41" translate="yes" xml:space="preserve">
          <source>The Open Type of this element. In the case of &lt;code&gt;MBeanAttributeInfo&lt;/code&gt; and &lt;code&gt;MBeanParameterInfo&lt;/code&gt;, this is the Open Type of the attribute or parameter. In the case of &lt;code&gt;MBeanOperationInfo&lt;/code&gt;, it is the Open Type of the return value. This field is set in the Descriptor for all instances of &lt;a href=&quot;openmbean/openmbeanattributeinfosupport&quot;&gt;&lt;code&gt;OpenMBeanAttributeInfoSupport&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;openmbean/openmbeanoperationinfosupport&quot;&gt;&lt;code&gt;OpenMBeanOperationInfoSupport&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;openmbean/openmbeanparameterinfosupport&quot;&gt;&lt;code&gt;OpenMBeanParameterInfoSupport&lt;/code&gt;&lt;/a&gt;. It is also set for attributes, operations, and parameters of MXBeans.</source>
          <target state="translated">此元素的打开类型。对于 &lt;code&gt;MBeanAttributeInfo&lt;/code&gt; 和 &lt;code&gt;MBeanParameterInfo&lt;/code&gt; ，这是属性或参数的开放类型。对于 &lt;code&gt;MBeanOperationInfo&lt;/code&gt; ，它是返回值的Open Type。在Descriptor中为&lt;a href=&quot;openmbean/openmbeanattributeinfosupport&quot;&gt; &lt;code&gt;OpenMBeanAttributeInfoSupport&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;openmbean/openmbeanoperationinfosupport&quot;&gt; &lt;code&gt;OpenMBeanOperationInfoSupport&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;openmbean/openmbeanparameterinfosupport&quot;&gt; &lt;code&gt;OpenMBeanParameterInfoSupport&lt;/code&gt; 的&lt;/a&gt;所有实例设置此字段。还为MXBean的属性，操作和参数设置了它。</target>
        </trans-unit>
        <trans-unit id="3d8ca0b1298715049081cc8a7ee921c31ef00c4d" translate="yes" xml:space="preserve">
          <source>The Open Type, &lt;em&gt;opentype(&lt;/em&gt;&lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt;&lt;em&gt;)&lt;/em&gt;, is &lt;a href=&quot;openmbean/arraytype&quot;&gt;&lt;code&gt;ArrayType&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(1, &lt;/code&gt;&lt;a href=&quot;openmbean/simpletype#STRING&quot;&gt;&lt;code&gt;SimpleType.STRING&lt;/code&gt;&lt;/a&gt;&lt;code&gt;)&lt;/code&gt;, representing a 1-dimensional array of &lt;code&gt;String&lt;/code&gt;s.</source>
          <target state="translated">打开类型&lt;em&gt;opentype（&lt;/em&gt; &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt; &lt;em&gt;）&lt;/em&gt;是&lt;a href=&quot;openmbean/arraytype&quot;&gt; &lt;code&gt;ArrayType&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(1, &lt;/code&gt; &lt;a href=&quot;openmbean/simpletype#STRING&quot;&gt; &lt;code&gt;SimpleType.STRING&lt;/code&gt; &lt;/a&gt; &lt;code&gt;)&lt;/code&gt; ，表示 &lt;code&gt;String&lt;/code&gt; 的一维数组。</target>
        </trans-unit>
        <trans-unit id="c8d2a39da861a7048f3bf16ac55acc32a5404839" translate="yes" xml:space="preserve">
          <source>The POSIX attributes of a file are retrieved using a &lt;a href=&quot;posixfileattributeview&quot;&gt;&lt;code&gt;PosixFileAttributeView&lt;/code&gt;&lt;/a&gt; by invoking its &lt;a href=&quot;posixfileattributeview#readAttributes--&quot;&gt;&lt;code&gt;readAttributes&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">通过使用&lt;a href=&quot;posixfileattributeview&quot;&gt; &lt;code&gt;PosixFileAttributeView&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;posixfileattributeview#readAttributes--&quot;&gt; &lt;code&gt;readAttributes&lt;/code&gt; &lt;/a&gt;方法来检索文件的POSIX属性。</target>
        </trans-unit>
        <trans-unit id="b3ab28242caa847b286fc90013d2b0491ec3901c" translate="yes" xml:space="preserve">
          <source>The PSS parameter set with all default values.</source>
          <target state="translated">PSS参数设置为所有默认值。</target>
        </trans-unit>
        <trans-unit id="3d027f6c803d6758ba706e29a00afc1193bf2442" translate="yes" xml:space="preserve">
          <source>The ParameterDescriptor class allows bean implementors to provide additional information on each of their parameters, beyond the low level type information provided by the java.lang.reflect.Method class.</source>
          <target state="translated">ParameterDescriptor类允许bean实现者在java.lang.reflect.Method类提供的低级类型信息之外,为其每个参数提供附加信息。</target>
        </trans-unit>
        <trans-unit id="b49db7c6419de0ed107d7d806648cd410319d193" translate="yes" xml:space="preserve">
          <source>The PasswordAuthentication collected from the user, or null if none is provided.</source>
          <target state="translated">从用户那里收集到的PasswordAuthentication,如果没有提供,则为空。</target>
        </trans-unit>
        <trans-unit id="47162c3848702f346f4c344da14d624a5c12818f" translate="yes" xml:space="preserve">
          <source>The Permission class for reflective operations.</source>
          <target state="translated">反射操作的权限类。</target>
        </trans-unit>
        <trans-unit id="2fe6df3634a9b58d388e16b81f2a5767b8a67a98" translate="yes" xml:space="preserve">
          <source>The PermissionCollection returned by the &lt;code&gt;Permission.newPermissionCollection&lt;/code&gt; method is a homogeneous collection, which stores only Permission objects for a given Permission type. A PermissionCollection may also be heterogeneous. For example, Permissions is a PermissionCollection subclass that represents a collection of PermissionCollections. That is, its members are each a homogeneous PermissionCollection. For example, a Permissions object might have a FilePermissionCollection for all the FilePermission objects, a SocketPermissionCollection for all the SocketPermission objects, and so on. Its &lt;code&gt;add&lt;/code&gt; method adds a permission to the appropriate collection.</source>
          <target state="translated">&lt;code&gt;Permission.newPermissionCollection&lt;/code&gt; 方法返回的PermissionCollection是同质集合，它仅存储给定Permission类型的Permission对象。 PermissionCollection也可能是异构的。例如，Permissions是一个PermissionCollection子类，它表示PermissionCollections的集合。也就是说，其成员都是同质的PermissionCollection。例如，一个Permissions对象可能对所有FilePermission对象都有一个FilePermissionCollection，对所有SocketPermission对象都有一个SocketPermissionCollection，依此类推。它的 &lt;code&gt;add&lt;/code&gt; 方法向适当的集合添加权限。</target>
        </trans-unit>
        <trans-unit id="5b44fa11f797cda619a6aef640c6e5f1150da36c" translate="yes" xml:space="preserve">
          <source>The PersistenceDelegate class takes the responsibility for expressing the state of an instance of a given class in terms of the methods in the class's public API.</source>
          <target state="translated">PersistenceDelegate类承担了用类的公共API中的方法来表达一个给定类的实例的状态的责任。</target>
        </trans-unit>
        <trans-unit id="fe7a2d34b2335b92e9d706d17e53c3f47d5a8dbf" translate="yes" xml:space="preserve">
          <source>The PersistenceDelegate class takes the responsibility for expressing the state of an instance of a given class in terms of the methods in the class's public API. Instead of associating the responsibility of persistence with the class itself as is done, for example, by the &lt;code&gt;readObject&lt;/code&gt; and &lt;code&gt;writeObject&lt;/code&gt; methods used by the &lt;code&gt;ObjectOutputStream&lt;/code&gt;, streams like the &lt;code&gt;XMLEncoder&lt;/code&gt; which use this delegation model can have their behavior controlled independently of the classes themselves. Normally, the class is the best place to put such information and conventions can easily be expressed in this delegation scheme to do just that. Sometimes however, it is the case that a minor problem in a single class prevents an entire object graph from being written and this can leave the application developer with no recourse but to attempt to shadow the problematic classes locally or use alternative persistence techniques. In situations like these, the delegation model gives a relatively clean mechanism for the application developer to intervene in all parts of the serialization process without requiring that modifications be made to the implementation of classes which are not part of the application itself.</source>
          <target state="translated">PersistenceDelegate类负责根据类的公共API中的方法来表达给定类的实例的状态。像 &lt;code&gt;XMLEncoder&lt;/code&gt; 这样的流，不是像例如通过 &lt;code&gt;ObjectOutputStream&lt;/code&gt; 所使用的 &lt;code&gt;readObject&lt;/code&gt; 和 &lt;code&gt;writeObject&lt;/code&gt; 方法那样将持久性的责任与类本身相关联，使用此委托模型的控件可以独立于类本身来控制其行为。通常，类是放置此类信息的最佳位置，并且可以轻松地在此委派方案中表达约定来做到这一点。但是，有时候，单个类中的一个小问题会阻止整个对象图的编写，并且这可能会导致应用程序开发人员无处可寻，只能尝试在本地隐藏有问题的类或使用替代的持久性技术。在这样的情况下，委托模型为应用程序开发人员提供了一种相对干净的机制，使它可以介入序列化过程的所有部分，而无需修改不属于应用程序本身的类的实现。</target>
        </trans-unit>
        <trans-unit id="0f579bdcf97e6eb9cb7574a266fa66a89a905516" translate="yes" xml:space="preserve">
          <source>The PostConstruct annotation is used on a method that needs to be executed after dependency injection is done to perform any initialization.</source>
          <target state="translated">PostConstruct注解用于在依赖注入完成后需要执行的方法上,以执行任何初始化。</target>
        </trans-unit>
        <trans-unit id="663424111809ef7a25cf879a877b2f4c747a5c6b" translate="yes" xml:space="preserve">
          <source>The PostConstruct annotation is used on a method that needs to be executed after dependency injection is done to perform any initialization. This method MUST be invoked before the class is put into service. This annotation MUST be supported on all classes that support dependency injection. The method annotated with PostConstruct MUST be invoked even if the class does not request any resources to be injected. Only one method can be annotated with this annotation. The method on which the PostConstruct annotation is applied MUST fulfill all of the following criteria:</source>
          <target state="translated">PostConstruct 注解用于在依赖注入完成后需要执行的方法,以执行任何初始化。该方法必须在类被投入服务之前被调用。所有支持依赖注入的类都必须支持这个注解。即使类没有请求注入任何资源,也必须调用用PostConstruct注解的方法。只有一个方法可以被注解为这个注解。应用 PostConstruct 注解的方法必须满足以下所有标准。</target>
        </trans-unit>
        <trans-unit id="474d2291101f131bfdaaf8be9f4fb6c2d55ed0cb" translate="yes" xml:space="preserve">
          <source>The PreDestroy annotation is used on methods as a callback notification to signal that the instance is in the process of being removed by the container.</source>
          <target state="translated">PreDestroy 注解在方法上用作回调通知,以表明实例正处于被容器删除的过程中。</target>
        </trans-unit>
        <trans-unit id="3f4e141fe06f04a529a2ebb0a5d0f52a343eafc5" translate="yes" xml:space="preserve">
          <source>The PreDestroy annotation is used on methods as a callback notification to signal that the instance is in the process of being removed by the container. The method annotated with PreDestroy is typically used to release resources that it has been holding. This annotation MUST be supported by all container managed objects that support PostConstruct except the application client container in Java EE 5. The method on which the PreDestroy annotation is applied MUST fulfill all of the following criteria:</source>
          <target state="translated">PreDestroy 注解在方法上用作回调通知,以表明实例正处于被容器删除的过程中。使用 PreDestroy 注解的方法通常用于释放它一直持有的资源。除了 Java EE 5 中的应用程序客户机容器外,所有支持 PostConstruct 的容器管理对象都必须支持这个注解。应用 PreDestroy 注解的方法必须满足以下所有标准。</target>
        </trans-unit>
        <trans-unit id="d1757e1a54444fb1f78c30c52a38118eeb762c87" translate="yes" xml:space="preserve">
          <source>The Principals and credentials from the specified Sets are copied into newly constructed Sets. These newly created Sets check whether this &lt;code&gt;Subject&lt;/code&gt; has been set read-only before permitting subsequent modifications. The newly created Sets also prevent illegal modifications by ensuring that callers have sufficient permissions.</source>
          <target state="translated">指定集中的主体和凭据将被复制到新构建的集中。这些新创建的集合会在允许后续修改之前检查是否将此 &lt;code&gt;Subject&lt;/code&gt; 设置为只读。通过确保呼叫者具有足够的权限，新创建的集合还可以防止非法修改。</target>
        </trans-unit>
        <trans-unit id="5023e9c16aece2d432f4a46ffaa75c4a32d41d7b" translate="yes" xml:space="preserve">
          <source>The Print Service API provides one implementation of interface AttributeSet, class &lt;a href=&quot;hashattributeset&quot;&gt;&lt;code&gt;HashAttributeSet&lt;/code&gt;&lt;/a&gt;. A client can use class &lt;a href=&quot;hashattributeset&quot;&gt;&lt;code&gt;HashAttributeSet&lt;/code&gt;&lt;/a&gt; or provide its own implementation of interface AttributeSet. The Print Service API also provides implementations of interface AttributeSet's subinterfaces -- classes &lt;a href=&quot;hashdocattributeset&quot;&gt;&lt;code&gt;HashDocAttributeSet&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;hashprintrequestattributeset&quot;&gt;&lt;code&gt;HashPrintRequestAttributeSet&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;hashprintjobattributeset&quot;&gt;&lt;code&gt;HashPrintJobAttributeSet&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;hashprintserviceattributeset&quot;&gt;&lt;code&gt;HashPrintServiceAttributeSet&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">打印服务API提供了接口AttributeSet的一种实现，类&lt;a href=&quot;hashattributeset&quot;&gt; &lt;code&gt;HashAttributeSet&lt;/code&gt; &lt;/a&gt;。客户端可以使用类&lt;a href=&quot;hashattributeset&quot;&gt; &lt;code&gt;HashAttributeSet&lt;/code&gt; &lt;/a&gt;或提供其自己的接口AttributeSet实现。 Print Service API还提供了接口AttributeSet的子接口的实现-类&lt;a href=&quot;hashdocattributeset&quot;&gt; &lt;code&gt;HashDocAttributeSet&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;hashprintrequestattributeset&quot;&gt; &lt;code&gt;HashPrintRequestAttributeSet&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;hashprintjobattributeset&quot;&gt; &lt;code&gt;HashPrintJobAttributeSet&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;hashprintserviceattributeset&quot;&gt; &lt;code&gt;HashPrintServiceAttributeSet&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="113ca29dc8899124bef3d1bfa5bd50040ad1d06f" translate="yes" xml:space="preserve">
          <source>The Printer could not access one or more documents passed by reference (i.e., the print data representation object is a URL). This reason is intended to cover any file access problem,including file does not exist and access denied because of an access control problem. Whether the printer aborts the job and moves the job to the ABORTED job state or prints all documents that are accessible and moves the job to the COMPLETED job state and adds the COMPLETED_WITH_ERRORS reason to the job's &lt;a href=&quot;jobstatereasons&quot;&gt;&lt;code&gt;JobStateReasons&lt;/code&gt;&lt;/a&gt; attribute depends on implementation and/or site policy. This value should be supported if the printer supports doc flavors with URL print data representation objects.</source>
          <target state="translated">打印机无法访问通过引用传递的一个或多个文档（即，打印数据表示对象是URL）。此原因旨在解决所有文件访问问题，包括文件不存在以及由于访问控制问题而拒绝访问。打印机是中止该作业并将其移至ABORTED作业状态，还是打印所有可访问的文档并将该作业移至COMPLETED作业状态并将COMPLETED_WITH_ERRORS原因添加到作业的&lt;a href=&quot;jobstatereasons&quot;&gt; &lt;code&gt;JobStateReasons&lt;/code&gt; &lt;/a&gt;属性取决于实现和/或站点策略。如果打印机支持带有URL打印数据表示对象的DocFlavor，则应支持此值。</target>
        </trans-unit>
        <trans-unit id="fce18036495868d9659f03df3d44dfcec351c534" translate="yes" xml:space="preserve">
          <source>The Program</source>
          <target state="translated">该计划</target>
        </trans-unit>
        <trans-unit id="79c5bed2e16f2a36efdbb26417f5d432d107c87f" translate="yes" xml:space="preserve">
          <source>The PropertyEditorManager can be used to locate a property editor for any given type name.</source>
          <target state="translated">PropertyEditorManager可以用来定位任何给定类型名称的属性编辑器。</target>
        </trans-unit>
        <trans-unit id="03f186ff2c81c37adab709c0e89d137a465a74c1" translate="yes" xml:space="preserve">
          <source>The PropertyEditorManager can be used to locate a property editor for any given type name. This property editor must support the java.beans.PropertyEditor interface for editing a given object.</source>
          <target state="translated">PropertyEditorManager可以用来定位任何给定类型名称的属性编辑器。这个属性编辑器必须支持java.beans.PropertyEditor接口来编辑给定对象。</target>
        </trans-unit>
        <trans-unit id="a2d11ff6fce664d384fd5b4cb99275a3053adfd8" translate="yes" xml:space="preserve">
          <source>The PropertyEditorManager uses three techniques for locating an editor for a given type. First, it provides a registerEditor method to allow an editor to be specifically registered for a given type. Second it tries to locate a suitable class by adding &quot;Editor&quot; to the full qualified classname of the given type (e.g. &quot;foo.bah.FozEditor&quot;). Finally it takes the simple classname (without the package name) adds &quot;Editor&quot; to it and looks in a search-path of packages for a matching class.</source>
          <target state="translated">PropertyEditorManager使用三种技术来定位给定类型的编辑器。首先,它提供了一个 registerEditor 方法,允许编辑器为给定类型专门注册。其次,它试图通过在给定类型的完整限定类名中添加 &quot;Editor &quot;来定位一个合适的类(例如 &quot;foo.bah.FozEditor&quot;)。最后,它将简单的类名(没有包名)加上 &quot;Editor&quot;,然后在包的搜索路径中寻找匹配的类。</target>
        </trans-unit>
        <trans-unit id="dc1a13b023d0705e0b7b2456d0489a32905a21a8" translate="yes" xml:space="preserve">
          <source>The REVERSE_LANDSCAPE value was added because some applications rotate landscape -90 degrees from portrait, rather than +90 degrees.</source>
          <target state="translated">增加REVERSE_LANDSCAPE值的原因是有些应用程序将横向与纵向旋转了-90度,而不是+90度。</target>
        </trans-unit>
        <trans-unit id="6db7050862750f47a0efb63666d6d145e9e68f0e" translate="yes" xml:space="preserve">
          <source>The REVERSE_PORTRAIT value was added for use with the &lt;a href=&quot;finishings&quot;&gt;&lt;code&gt;Finishings&lt;/code&gt;&lt;/a&gt; attribute in cases where the opposite edge is desired for finishing a portrait document on simple finishing devices that have only one finishing position. Thus a &lt;code&gt;&quot;text/plain&quot;&lt;/code&gt; portrait document can be stapled &quot;on the right&quot; by a simple finishing device as is common use with some Middle Eastern languages such as Hebrew.</source>
          <target state="translated">REVERSE_PORTRAIT值被添加以与&lt;a href=&quot;finishings&quot;&gt; &lt;code&gt;Finishings&lt;/code&gt; &lt;/a&gt;属性一起使用，如果需要相对的边缘在仅具有一个精加工位置的简单精加工设备上精加工人像文档，则使用REVERSE_PORTRAIT值。因此，可以像一些中东语言（例如希伯来语）常用的那样，通过简单的装订设备将 &lt;code&gt;&quot;text/plain&quot;&lt;/code&gt; 肖像文档装订在&amp;ldquo;右侧&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="91344e6cf60e370413b5e41435a7570bf1602389" translate="yes" xml:space="preserve">
          <source>The RFC-1123 date-time formatter, such as 'Tue, 3 Jun 2008 11:05:30 GMT'.</source>
          <target state="translated">RFC-1123日期-时间格式,如'Tues,3 Jun 2008 11:05:30 GMT'。</target>
        </trans-unit>
        <trans-unit id="7bd6b6f1f0aee47728916c5bade09680616f86e1" translate="yes" xml:space="preserve">
          <source>The RMI connector is a connector for the JMX Remote API that uses RMI to transmit client requests to a remote MBean server.</source>
          <target state="translated">RMI连接器是JMX远程API的连接器,它使用RMI向远程MBean服务器传输客户端请求。</target>
        </trans-unit>
        <trans-unit id="82677ad477cb29bbe50c6cb2ef69c1f5f53feed1" translate="yes" xml:space="preserve">
          <source>The RMI connector is a connector for the JMX Remote API that uses RMI to transmit client requests to a remote MBean server. This package defines the classes that the user of an RMI connector needs to reference directly, for both the client and server sides. It also defines certain classes that the user will not usually reference directly, but that must be defined so that different implementations of the RMI connector can interoperate.</source>
          <target state="translated">RMI连接器是JMX远程API的连接器,它使用RMI将客户端请求传输到远程MBean服务器。该包定义了RMI连接器的用户需要直接引用的类,包括客户端和服务器端。它还定义了某些用户通常不会直接引用的类,但必须定义这些类,以便RMI连接器的不同实现能够互操作。</target>
        </trans-unit>
        <trans-unit id="60f37692d373183aabc13cdc8073b22c431d845f" translate="yes" xml:space="preserve">
          <source>The RMI connector supports the JRMP transport for RMI, and optionally the IIOP transport.</source>
          <target state="translated">RMI连接器支持RMI的JRMP传输,以及可选的IIOP传输。</target>
        </trans-unit>
        <trans-unit id="41b3ef650c3626ba1e54f00218353c90a916a9f7" translate="yes" xml:space="preserve">
          <source>The RUN_DIRECTION attribute in the text, if present, determines the base direction (left-to-right or right-to-left). If not present, the base direction is computes using the Unicode Bidirectional Algorithm, defaulting to left-to-right if there are no strong directional characters in the text. This attribute, if present, must be applied to all the text in the paragraph.</source>
          <target state="translated">文本中的RUN_DIRECTION属性,如果存在,则决定基本方向(从左到右或从右到左)。如果不存在,则使用Unicode双向算法计算基本方向,如果文本中没有强方向性字符,则默认为从左到右。该属性如果存在,必须应用于段落中的所有文本。</target>
        </trans-unit>
        <trans-unit id="f60c0ed8c51e78726f1dd29af9cd9a1b5c043ca4" translate="yes" xml:space="preserve">
          <source>The Rdn class represents an RDN as attribute type/value mappings, which can be viewed using &lt;a href=&quot;../directory/attributes&quot;&gt;&lt;code&gt;Attributes&lt;/code&gt;&lt;/a&gt;. In addition, it contains convenience methods that allow easy retrieval of type and value when the Rdn consist of a single type/value pair, which is how it appears in a typical usage. It also contains helper methods that allow escaping of the unformatted attribute value and unescaping of the value formatted according to the escaping syntax defined in RFC2253. For methods that take or return attribute value as an Object, the value is either a String (in unescaped form) or a byte array.</source>
          <target state="translated">Rdn类将RDN表示为属性类型/值映射，可以使用&lt;a href=&quot;../directory/attributes&quot;&gt; &lt;code&gt;Attributes&lt;/code&gt; &lt;/a&gt;进行查看。此外，它包含便利的方法，当Rdn由单个类型/值对组成时，可以轻松检索类型和值，这在典型用法中是这样显示的。它还包含帮助程序方法，这些方法允许转义未格式化的属性值和根据RFC2253中定义的转义语法对已格式化的值进行转义。对于采用或返回属性值作为对象的方法，该值可以是字符串（不转义形式）或字节数组。</target>
        </trans-unit>
        <trans-unit id="ef154a572a8dd8cfa5c8cd77b99196da2d668b74" translate="yes" xml:space="preserve">
          <source>The Relation Service is in charge of creating and deleting relation types and relations, of handling the consistency and of providing query mechanisms.</source>
          <target state="translated">关系服务负责创建和删除关系类型和关系,处理一致性和提供查询机制。</target>
        </trans-unit>
        <trans-unit id="9b94248d10d22c5d522221db774ab1a81ba0ecb4" translate="yes" xml:space="preserve">
          <source>The Relation Service keeps track of the changes to keep the consistency of relations by handling referenced MBean deregistrations.</source>
          <target state="translated">关系服务通过处理被引用的MBean取消注册来跟踪变化,以保持关系的一致性。</target>
        </trans-unit>
        <trans-unit id="c58fe2a5c62a124e8b18b80e2e230da01543a005" translate="yes" xml:space="preserve">
          <source>The Relation Service will call this method to let the relation take action to reflect the impact of such unregistration.</source>
          <target state="translated">关系处会调用这个方法,让关系处采取行动,反映这种取消注册的影响。</target>
        </trans-unit>
        <trans-unit id="674d8706acecd74bfff3ea199d92ca522dde4abd" translate="yes" xml:space="preserve">
          <source>The Relation Service will keep track of the change to keep the consistency of relations by handling referenced MBean deregistrations.</source>
          <target state="translated">关系服务将跟踪变化,通过处理引用的MBean取消注册来保持关系的一致性。</target>
        </trans-unit>
        <trans-unit id="7430d227a34803554e11c267caf31a7db4f67140" translate="yes" xml:space="preserve">
          <source>The RelationType interface has to be implemented by any class expected to represent a relation type.</source>
          <target state="translated">RelationType接口必须由任何期望代表关系类型的类来实现。</target>
        </trans-unit>
        <trans-unit id="223356c4d1a561d92448c2d007a52122fdfdc7b7" translate="yes" xml:space="preserve">
          <source>The RequiredModelMBean's MBeanInfo and Descriptors can be customized using the &lt;a href=&quot;requiredmodelmbean#setModelMBeanInfo-javax.management.modelmbean.ModelMBeanInfo-&quot;&gt;&lt;code&gt;setModelMBeanInfo(javax.management.modelmbean.ModelMBeanInfo)&lt;/code&gt;&lt;/a&gt; method. After the RequiredModelMBean's MBeanInfo and Descriptors are customized, the RequiredModelMBean can be registered with the MBeanServer.</source>
          <target state="translated">可以使用&lt;a href=&quot;requiredmodelmbean#setModelMBeanInfo-javax.management.modelmbean.ModelMBeanInfo-&quot;&gt; &lt;code&gt;setModelMBeanInfo(javax.management.modelmbean.ModelMBeanInfo)&lt;/code&gt; &lt;/a&gt;方法自定义RequiredModelMBean的MBeanInfo和描述符。自定义RequiredModelMBean的MBeanInfo和描述符之后，可以向MBeanServer注册RequiredModelMBean。</target>
        </trans-unit>
        <trans-unit id="d0e463000d15f695be884764e6e32e805dc3c334" translate="yes" xml:space="preserve">
          <source>The Resolver interface contains methods that are implemented by contexts that do not support subtypes of Context, but which can act as intermediate contexts for resolution purposes.</source>
          <target state="translated">Resolver接口包含了由不支持Context子类型的上下文实现的方法,但这些方法可以作为中间上下文来进行解析。</target>
        </trans-unit>
        <trans-unit id="99887f811b190671c4ccc42930750f2de5fbdd99" translate="yes" xml:space="preserve">
          <source>The Resource annotation marks a resource that is needed by the application.</source>
          <target state="translated">资源注解标记了应用程序需要的资源。</target>
        </trans-unit>
        <trans-unit id="30acb209089a83083042aff0a92fb6de49bfdcc2" translate="yes" xml:space="preserve">
          <source>The Resource annotation marks a resource that is needed by the application. This annotation may be applied to an application component class, or to fields or methods of the component class. When the annotation is applied to a field or method, the container will inject an instance of the requested resource into the application component when the component is initialized. If the annotation is applied to the component class, the annotation declares a resource that the application will look up at runtime.</source>
          <target state="translated">资源注解标记了应用程序需要的资源。这个注解可以应用于应用程序组件类,也可以应用于组件类的字段或方法。当注解应用于字段或方法时,容器将在组件初始化时把请求的资源的实例注入到应用程序组件中。如果将注解应用于组件类,则注解声明了应用程序将在运行时查找的资源。</target>
        </trans-unit>
        <trans-unit id="f23f9e9a62bb221b645f78eb5486063e2b452cdf" translate="yes" xml:space="preserve">
          <source>The ResourceBundle is not transmitted as part of the serialized form, but the resource bundle name is, and the recipient object's readObject method will attempt to locate a suitable resource bundle.</source>
          <target state="translated">ResourceBundle不作为序列化形式的一部分进行传输,但资源束名称是,接收对象的readObject方法将尝试定位一个合适的资源束。</target>
        </trans-unit>
        <trans-unit id="614f4429ada7f2ea49d4dd70089a45d01bafee6b" translate="yes" xml:space="preserve">
          <source>The ResponseCache implementation decides which resources should be cached, and for how long they should be cached. If a request resource cannot be retrieved from the cache, then the protocol handlers will fetch the resource from its original location. The settings for URLConnection#useCaches controls whether the protocol is allowed to use a cached response. For more information on HTTP caching, see &lt;a href=&quot;http://www.ietf.org/rfc/rfc2616.txt&quot;&gt;&lt;i&gt;RFC 2616: Hypertext Transfer Protocol -- HTTP/1.1&lt;/i&gt;&lt;/a&gt;</source>
          <target state="translated">ResponseCache实现决定应缓存哪些资源以及应缓存多长时间。如果无法从缓存中检索请求资源，则协议处理程序将从其原始位置获取资源。URLConnection＃useCaches的设置控制是否允许协议使用缓存的响应。有关HTTP缓存的详细信息，请参阅&lt;a href=&quot;http://www.ietf.org/rfc/rfc2616.txt&quot;&gt;&lt;i&gt;RFC 2616：超文本传输​​协议-HTTP / 1.1。&lt;/i&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8be8119ae420632d994ffa43dca6763be5bf54df" translate="yes" xml:space="preserve">
          <source>The SMPTE-based timing type with 24 frames per second (resolution is expressed in ticks per frame).</source>
          <target state="translated">基于SMPTE的定时类型,每秒24帧(分辨率以每帧ticks表示)。</target>
        </trans-unit>
        <trans-unit id="a87aead941ca1f4be07e3fb05a0f9f240ce25f4b" translate="yes" xml:space="preserve">
          <source>The SMPTE-based timing type with 25 frames per second (resolution is expressed in ticks per frame).</source>
          <target state="translated">基于SMPTE的定时类型,每秒25帧(分辨率以每帧ticks表示)。</target>
        </trans-unit>
        <trans-unit id="66c45c4346ca292d94c0c47d075fff0695e0d64c" translate="yes" xml:space="preserve">
          <source>The SMPTE-based timing type with 29.97 frames per second (resolution is expressed in ticks per frame).</source>
          <target state="translated">基于SMPTE的定时类型,每秒29.97帧(分辨率以每帧ticks表示)。</target>
        </trans-unit>
        <trans-unit id="711626f5460469b9d83bfa23335e9135ed9a25b4" translate="yes" xml:space="preserve">
          <source>The SMPTE-based timing type with 30 frames per second (resolution is expressed in ticks per frame).</source>
          <target state="translated">基于SMPTE的定时类型,每秒30帧(分辨率以每帧ticks表示)。</target>
        </trans-unit>
        <trans-unit id="2df02aa64906f5064858d7196a521480f396ca2b" translate="yes" xml:space="preserve">
          <source>The SNI extension is a feature that extends the SSL/TLS protocols to indicate what server name the client is attempting to connect to during handshaking. See section 3, &quot;Server Name Indication&quot;, of &lt;a href=&quot;http://www.ietf.org/rfc/rfc6066.txt&quot;&gt;TLS Extensions (RFC 6066)&lt;/a&gt;.</source>
          <target state="translated">SNI扩展是一项功能，它扩展了SSL / TLS协议，以指示客户端在握手过程中尝试连接的服务器名称。请参阅&lt;a href=&quot;http://www.ietf.org/rfc/rfc6066.txt&quot;&gt;TLS扩展（RFC 6066）的&lt;/a&gt;第3节&amp;ldquo;服务器名称指示&amp;rdquo; 。</target>
        </trans-unit>
        <trans-unit id="e72c29b257096b441d7a94ae631930942e7eed15" translate="yes" xml:space="preserve">
          <source>The SPI methods fall into three groups concerning exception behavior. The &lt;code&gt;getSpi&lt;/code&gt; method should never throw exceptions, but it doesn't really matter, as any exception thrown by this method will be intercepted by &lt;a href=&quot;abstractpreferences#get-java.lang.String-java.lang.String-&quot;&gt;&lt;code&gt;get(String,String)&lt;/code&gt;&lt;/a&gt;, which will return the specified default value to the caller. The &lt;code&gt;removeNodeSpi, keysSpi, childrenNamesSpi, syncSpi&lt;/code&gt; and &lt;code&gt;flushSpi&lt;/code&gt; methods are specified to throw &lt;a href=&quot;backingstoreexception&quot;&gt;&lt;code&gt;BackingStoreException&lt;/code&gt;&lt;/a&gt;, and the implementation is required to throw this checked exception if it is unable to perform the operation. The exception propagates outward, causing the corresponding API method to fail.</source>
          <target state="translated">SPI方法分为三类，涉及异常行为。该 &lt;code&gt;getSpi&lt;/code&gt; 方法不应该抛出异常，但它其实并不重要，因为通过这种方法抛出的任何异常将被拦截&lt;a href=&quot;abstractpreferences#get-java.lang.String-java.lang.String-&quot;&gt; &lt;code&gt;get(String,String)&lt;/code&gt; &lt;/a&gt;，将指定的默认值返回给调用者。指定 &lt;code&gt;removeNodeSpi, keysSpi, childrenNamesSpi, syncSpi&lt;/code&gt; 和 &lt;code&gt;flushSpi&lt;/code&gt; 方法以引发&lt;a href=&quot;backingstoreexception&quot;&gt; &lt;code&gt;BackingStoreException&lt;/code&gt; &lt;/a&gt;，如果无法执行该操作，则需要实现以引发此检查的异常。异常向外传播，导致相应的API方法失败。</target>
        </trans-unit>
        <trans-unit id="b6cde8fa0c00b8ce15c90873f656db7588e3214e" translate="yes" xml:space="preserve">
          <source>The SSL/TLS protocols employ ordered packets. Applications must take care to ensure that generated packets are delivered in sequence. If packets arrive out-of-order, unexpected or fatal results may occur.</source>
          <target state="translated">SSL/TLS协议采用有序的数据包。应用程序必须注意确保生成的数据包按顺序传送。如果数据包到达时不按顺序,可能会出现意外或致命的结果。</target>
        </trans-unit>
        <trans-unit id="6a5cbc0fa7d23029290836f25878e9b66351852c" translate="yes" xml:space="preserve">
          <source>The STAPLE_</source>
          <target state="translated">STAPLE_</target>
        </trans-unit>
        <trans-unit id="eb7e3d36792b3be33972f8e4b880e172f779b82d" translate="yes" xml:space="preserve">
          <source>The Scope of a Multicast Address</source>
          <target state="translated">多播地址的范围</target>
        </trans-unit>
        <trans-unit id="6fe02d845f0c88f5c76dd6ee524b87fdcbd0bcff" translate="yes" xml:space="preserve">
          <source>The ServcieProvider may always return the same instance, or it may construct a new instance for each request.</source>
          <target state="translated">ServcieProvider可以始终返回相同的实例,也可以为每个请求构造一个新的实例。</target>
        </trans-unit>
        <trans-unit id="28b7987465eb7e220fbabc8609ba006f994d2083" translate="yes" xml:space="preserve">
          <source>The SetOfIntegerSyntax object's value is actually stored in &quot;</source>
          <target state="translated">SetOfIntegerSyntax对象的值实际上存储在&quot;</target>
        </trans-unit>
        <trans-unit id="6c5041dd8df9ea9caf67044040d1ba01f76f902a" translate="yes" xml:space="preserve">
          <source>The SheetCollate attribute interacts with the &lt;a href=&quot;multipledocumenthandling&quot;&gt;&lt;code&gt;MultipleDocumentHandling&lt;/code&gt;&lt;/a&gt; attribute. The &lt;a href=&quot;multipledocumenthandling&quot;&gt;&lt;code&gt;MultipleDocumentHandling&lt;/code&gt;&lt;/a&gt; attribute describes the collation of entire documents, and the SheetCollate attribute describes the semantics of collating individual pages within a document.</source>
          <target state="translated">SheetCollat​​e属性与&lt;a href=&quot;multipledocumenthandling&quot;&gt; &lt;code&gt;MultipleDocumentHandling&lt;/code&gt; &lt;/a&gt;属性进行交互。该&lt;a href=&quot;multipledocumenthandling&quot;&gt; &lt;code&gt;MultipleDocumentHandling&lt;/code&gt; &lt;/a&gt;属性描述整个文件的整理和SheetCollat​​e属性描述整理文档中的单个页面的语义。</target>
        </trans-unit>
        <trans-unit id="bbab176333078e20d34f38e545765b360e204697" translate="yes" xml:space="preserve">
          <source>The Signature class is used to provide applications the functionality of a digital signature algorithm.</source>
          <target state="translated">Signature类用于为应用程序提供数字签名算法的功能。</target>
        </trans-unit>
        <trans-unit id="80aa8cc11bad31a562a0297268322354d94eb7e4" translate="yes" xml:space="preserve">
          <source>The Signature class is used to provide applications the functionality of a digital signature algorithm. Digital signatures are used for authentication and integrity assurance of digital data.</source>
          <target state="translated">签名类用于为应用程序提供数字签名算法的功能。数字签名用于数字数据的认证和完整性保证。</target>
        </trans-unit>
        <trans-unit id="aebb54655e0e730d9559b9dd9eb5dc0745cb12ec" translate="yes" xml:space="preserve">
          <source>The Start TLS extended request and response are used to establish a TLS connection over the existing LDAP connection associated with the JNDI context on which &lt;code&gt;extendedOperation()&lt;/code&gt; is invoked. Typically, a JNDI program uses the StartTLS extended request and response classes as follows.</source>
          <target state="translated">启动TLS扩展请求和响应用于在与JNDI上下文相关联的现有LDAP连接上建立TLS连接，在该LDAP连接上调用 &lt;code&gt;extendedOperation()&lt;/code&gt; 。通常，JNDI程序使用StartTLS扩展请求和响应类，如下所示。</target>
        </trans-unit>
        <trans-unit id="35ff6607428d35279a8e24fbc8d925b3e95c9fcb" translate="yes" xml:space="preserve">
          <source>The StartTLS extended request's assigned object identifier is 1.3.6.1.4.1.1466.20037.</source>
          <target state="translated">StartTLS扩展请求的分配对象标识符是1.3.6.1.4.1.1466.20037。</target>
        </trans-unit>
        <trans-unit id="f63533d528c41767afbaa8d3a271f97753da5dd2" translate="yes" xml:space="preserve">
          <source>The StartTLS extended response object.</source>
          <target state="translated">StartTLS扩展响应对象。</target>
        </trans-unit>
        <trans-unit id="23f3a42343c6b0cebaecc8d191002f4fb77f9cf4" translate="yes" xml:space="preserve">
          <source>The StartTLS extended response's assigned object identifier is 1.3.6.1.4.1.1466.20037.</source>
          <target state="translated">StartTLS扩展响应的分配对象标识符是1.3.6.1.4.1.1466.20037。</target>
        </trans-unit>
        <trans-unit id="ac5f7218b83207bb23413d3351defe6e6d2953f5" translate="yes" xml:space="preserve">
          <source>The String &lt;code&gt;&quot;[George:Sally:Fred]&quot;&lt;/code&gt; may be constructed as follows:</source>
          <target state="translated">字符串 &lt;code&gt;&quot;[George:Sally:Fred]&quot;&lt;/code&gt; 构造如下：</target>
        </trans-unit>
        <trans-unit id="4277b18bac7bf3deb5ddf1d71e76efde20397d80" translate="yes" xml:space="preserve">
          <source>The String has the format, &quot;LoginModuleControlFlag:</source>
          <target state="translated">该字符串的格式为:&quot;LoginModuleControlFlag。</target>
        </trans-unit>
        <trans-unit id="d633506a68191ed3a5c157daa149f9cc24706511" translate="yes" xml:space="preserve">
          <source>The String used to invoke the method in the syntax of the scripting language.</source>
          <target state="translated">用脚本语言的语法来调用方法的字符串。</target>
        </trans-unit>
        <trans-unit id="0d6515747116f06f0b4ebe8765048b16a027c64c" translate="yes" xml:space="preserve">
          <source>The TSA's certificate path.</source>
          <target state="translated">TSA的证书路径。</target>
        </trans-unit>
        <trans-unit id="0cf59134294aaac83b765e65055974c0b11987dd" translate="yes" xml:space="preserve">
          <source>The Thai Buddhist calendar system has two eras, 'BE' and 'BEFORE_BE', defined by &lt;a href=&quot;thaibuddhistera&quot;&gt;&lt;code&gt;ThaiBuddhistEra&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">泰国佛历系统有两个时代，&amp;ldquo;是&amp;rdquo;和&amp;ldquo;BEFORE_BE&amp;rdquo;，通过定义&lt;a href=&quot;thaibuddhistera&quot;&gt; &lt;code&gt;ThaiBuddhistEra&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0ecc0e2cb52a9d0ca6c0b7fe7e98e97c74af1351" translate="yes" xml:space="preserve">
          <source>The Thai Buddhist calendar system has two eras. The current era, for years from 1 onwards, is known as the 'Buddhist' era. All previous years, zero or earlier in the proleptic count or one and greater in the year-of-era count, are part of the 'Before Buddhist' era.</source>
          <target state="translated">泰国佛教历法系统有两个时代。当前时代,从1开始的年份,称为'佛教'时代。所有以前的年份,在临界数中为0或更早,或在年代数中为1或更早,都属于 &quot;佛教前 &quot;时代。</target>
        </trans-unit>
        <trans-unit id="110e78cab6d0a551308dd194cfdb9cad42b2df2d" translate="yes" xml:space="preserve">
          <source>The Thai Buddhist calendar system.</source>
          <target state="translated">泰国佛教的历法体系。</target>
        </trans-unit>
        <trans-unit id="0b298fd2191bf011e3f43ce2df9992fad3a92ca5" translate="yes" xml:space="preserve">
          <source>The Type of Service (ToS) octet in the Internet Protocol (IP) header</source>
          <target state="translated">互联网协议(IP)报头中的服务类型(ToS)八位组。</target>
        </trans-unit>
        <trans-unit id="f71c6d9015d5bc5b86df61acaea348d89e3cf6a7" translate="yes" xml:space="preserve">
          <source>The Type of Service (ToS) octet in the Internet Protocol (IP) header.</source>
          <target state="translated">互联网协议(IP)报头中的服务类型(ToS)字节。</target>
        </trans-unit>
        <trans-unit id="cf6d22f3428bd802d71f25d5491e0567edb2b4a1" translate="yes" xml:space="preserve">
          <source>The UNICODE_CHARACTER_CLASS mode can also be enabled via the embedded flag expression &lt;code&gt;(?U)&lt;/code&gt;.</source>
          <target state="translated">还可以通过嵌入式标志表达式 &lt;code&gt;(?U)&lt;/code&gt; 启用UNICODE_CHARACTER_CLASS模式。</target>
        </trans-unit>
        <trans-unit id="2eaff71d0d443b89396e5dd66fa648f0b90bc362" translate="yes" xml:space="preserve">
          <source>The URI scheme</source>
          <target state="translated">URI方案</target>
        </trans-unit>
        <trans-unit id="4ec678dde97f73fd23031533e67d7bb41d25cf06" translate="yes" xml:space="preserve">
          <source>The URL Path part of the Service URL. This is an empty string, or a string beginning with a slash (&lt;code&gt;/&lt;/code&gt;), or a string beginning with a semicolon (&lt;code&gt;;&lt;/code&gt;).</source>
          <target state="translated">服务URL的URL路径部分。这是一个空字符串，或者是一个以斜杠（ &lt;code&gt;/&lt;/code&gt; ）开头的字符串，或者是一个以分号（ &lt;code&gt;;&lt;/code&gt; ）开头的字符串。</target>
        </trans-unit>
        <trans-unit id="39cdd25064bd89d0ba41d92df7b08df17d225061" translate="yes" xml:space="preserve">
          <source>The URL above indicates that the protocol to use is &lt;code&gt;http&lt;/code&gt; (HyperText Transfer Protocol) and that the information resides on a host machine named &lt;code&gt;www.example.com&lt;/code&gt;. The information on that host machine is named &lt;code&gt;/docs/resource1.html&lt;/code&gt;. The exact meaning of this name on the host machine is both protocol dependent and host dependent. The information normally resides in a file, but it could be generated on the fly. This component of the URL is called the</source>
          <target state="translated">上面的URL表示要使用的协议为 &lt;code&gt;http&lt;/code&gt; （超文本传输​​协议），并且该信息位于名为 &lt;code&gt;www.example.com&lt;/code&gt; 的主机上。该主机上的信息名为 &lt;code&gt;/docs/resource1.html&lt;/code&gt; 。该名称在主机上的确切含义既取决于协议，也取决于主机。该信息通常驻留在文件中，但是可以即时生成。URL的这一部分称为</target>
        </trans-unit>
        <trans-unit id="5dda6bed3bc097d11c3c752b8ec21e906c5b5c6b" translate="yes" xml:space="preserve">
          <source>The URL class does not itself encode or decode any URL components according to the escaping mechanism defined in RFC2396. It is the responsibility of the caller to encode any fields, which need to be escaped prior to calling URL, and also to decode any escaped fields, that are returned from URL. Furthermore, because URL has no knowledge of URL escaping, it does not recognise equivalence between the encoded or decoded form of the same URL. For example, the two URLs:</source>
          <target state="translated">URL类本身不会根据RFC2396中定义的转义机制对任何URL组件进行编码或解码。调用者有责任在调用URL之前对任何需要转义的字段进行编码,并对URL返回的任何转义字段进行解码。此外,由于URL不知道URL转义,所以它不承认同一URL的编码或解码形式之间的等价性。例如,这两个URL。</target>
        </trans-unit>
        <trans-unit id="f1a13564394debd029b9191db3b513542cc43cd6" translate="yes" xml:space="preserve">
          <source>The URL represents the remote object on the World Wide Web to which this connection is opened.</source>
          <target state="translated">URL代表万维网上的远程对象,这个连接是打开的。</target>
        </trans-unit>
        <trans-unit id="2512db9d0f42c72fcc0e7d06aea9f96b3260a8c8" translate="yes" xml:space="preserve">
          <source>The US-ASCII alphabetic characters, &lt;code&gt;'A'&lt;/code&gt; through &lt;code&gt;'Z'&lt;/code&gt; and &lt;code&gt;'a'&lt;/code&gt; through &lt;code&gt;'z'&lt;/code&gt;</source>
          <target state="translated">US-ASCII字母字符， &lt;code&gt;'A'&lt;/code&gt; 至 &lt;code&gt;'Z'&lt;/code&gt; 和 &lt;code&gt;'a'&lt;/code&gt; 至 &lt;code&gt;'z'&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4ddab5d100cab95e4d1bbb59f061bb561cce4653" translate="yes" xml:space="preserve">
          <source>The US-ASCII decimal digit characters, &lt;code&gt;'0'&lt;/code&gt; through &lt;code&gt;'9'&lt;/code&gt;</source>
          <target state="translated">US-ASCII十进制数字字符， &lt;code&gt;'0'&lt;/code&gt; 到 &lt;code&gt;'9'&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="12e3bf91f40d535acdcd4f7b782ae2318ee3eb7e" translate="yes" xml:space="preserve">
          <source>The UTC time-scale is a standard approach to bundle up all the additional fractions of a second from UT1 into whole seconds, known as</source>
          <target state="translated">UTC时标是一种标准的方法,它将UT1的所有附加零碎秒数捆绑成整数秒,即所谓的------。</target>
        </trans-unit>
        <trans-unit id="2bad15b1f327afb2fe620089520eb64352143c23" translate="yes" xml:space="preserve">
          <source>The UTC type uses the UTC offset. The STANDARD type uses the standard offset. The WALL type returns the input date-time. The result is intended for use with the wall-offset.</source>
          <target state="translated">UTC类型使用UTC偏移。STANDARD类型使用标准偏移量。WALL类型返回输入的日期-时间。结果用于墙面偏移。</target>
        </trans-unit>
        <trans-unit id="30f27ccfa5d0569e8811312c5e589ba65ce5e892" translate="yes" xml:space="preserve">
          <source>The UTF-8 &lt;a href=&quot;../../nio/charset/charset&quot;&gt;&lt;code&gt;charset&lt;/code&gt;&lt;/a&gt; is used to decode the entry names and comments</source>
          <target state="translated">UTF-8 &lt;a href=&quot;../../nio/charset/charset&quot;&gt; &lt;code&gt;charset&lt;/code&gt; &lt;/a&gt;用于解码条目名称和注释</target>
        </trans-unit>
        <trans-unit id="dc1d3d9d30059176fa63317d871ad36c396c8256" translate="yes" xml:space="preserve">
          <source>The UTF-8 &lt;a href=&quot;../../nio/charset/charset&quot;&gt;&lt;code&gt;charset&lt;/code&gt;&lt;/a&gt; is used to decode the entry names and comments.</source>
          <target state="translated">UTF-8 &lt;a href=&quot;../../nio/charset/charset&quot;&gt; &lt;code&gt;charset&lt;/code&gt; &lt;/a&gt;用于解码条目名称和注释。</target>
        </trans-unit>
        <trans-unit id="1a6dcf3103182b65318ead8734e909a9308659e2" translate="yes" xml:space="preserve">
          <source>The UTF-8 &lt;a href=&quot;../../nio/charset/charset&quot;&gt;&lt;code&gt;charset&lt;/code&gt;&lt;/a&gt; is used to decode the entry names.</source>
          <target state="translated">UTF-8 &lt;a href=&quot;../../nio/charset/charset&quot;&gt; &lt;code&gt;charset&lt;/code&gt; &lt;/a&gt;用于解码条目名称。</target>
        </trans-unit>
        <trans-unit id="35058fd7e1cae4d49e6ba8bb36a8e490aefa08a7" translate="yes" xml:space="preserve">
          <source>The UTF-8 &lt;a href=&quot;../../nio/charset/charset&quot;&gt;&lt;code&gt;charset&lt;/code&gt;&lt;/a&gt; is used to encode the entry names and comments.</source>
          <target state="translated">UTF-8 &lt;a href=&quot;../../nio/charset/charset&quot;&gt; &lt;code&gt;charset&lt;/code&gt; &lt;/a&gt;用于编码条目名称和注释。</target>
        </trans-unit>
        <trans-unit id="97b660089cda0a866df93a5f2e1fb2461fc59e7d" translate="yes" xml:space="preserve">
          <source>The UTF-8 character encoding will be used.</source>
          <target state="translated">将使用UTF-8字符编码。</target>
        </trans-unit>
        <trans-unit id="ba90dc4402c6ec2d6a6525f2ffe4acf21c1feb8f" translate="yes" xml:space="preserve">
          <source>The UUID string representation is as described by this BNF:</source>
          <target state="translated">UUID字符串的表示方法如本BNF所述。</target>
        </trans-unit>
        <trans-unit id="e675ff6fc3d5c45e1c9594760191e675eb31248d" translate="yes" xml:space="preserve">
          <source>The Unicode Standard, Version 4.0</source>
          <target state="translated">統一碼標準,4.0版</target>
        </trans-unit>
        <trans-unit id="855f6f6b04fe01a58122fa0578b047dec0b2396f" translate="yes" xml:space="preserve">
          <source>The Unicode characters that are not in the US-ASCII character set, are not control characters (according to the &lt;a href=&quot;../lang/character#isISOControl-char-&quot;&gt;&lt;code&gt;Character.isISOControl&lt;/code&gt;&lt;/a&gt; method), and are not space characters (according to the &lt;a href=&quot;../lang/character#isSpaceChar-char-&quot;&gt;&lt;code&gt;Character.isSpaceChar&lt;/code&gt;&lt;/a&gt; method)</source>
          <target state="translated">不在US-ASCII字符集中的Unicode字符不是控制字符（根据&lt;a href=&quot;../lang/character#isISOControl-char-&quot;&gt; &lt;code&gt;Character.isISOControl&lt;/code&gt; &lt;/a&gt;方法），也不是空格字符（根据&lt;a href=&quot;../lang/character#isSpaceChar-char-&quot;&gt; &lt;code&gt;Character.isSpaceChar&lt;/code&gt; &lt;/a&gt;方法）</target>
        </trans-unit>
        <trans-unit id="f3dfcb36136372d42f03d3313790b203a822b063" translate="yes" xml:space="preserve">
          <source>The Unicode locale extension specifies optional behavior in locale-sensitive services. Although the LDML specification defines various keys and values, actual locale-sensitive service implementations in a Java Runtime Environment might not support any particular Unicode locale attributes or key/type pairs.</source>
          <target state="translated">Unicode locale 扩展指定了本地敏感服务中的可选行为。虽然LDML规范定义了各种键和值,但Java运行时环境中的实际本地敏感服务实现可能不支持任何特定的Unicode locale属性或键/类型对。</target>
        </trans-unit>
        <trans-unit id="86012cec961e3da55accb740a355d0cd5b30a87a" translate="yes" xml:space="preserve">
          <source>The Unicode locale type associated with the key, or null if the locale does not define the key.</source>
          <target state="translated">与键相关联的Unicode语言类型,如果语言类型没有定义键,则为空。</target>
        </trans-unit>
        <trans-unit id="d327177e0e897e771e7bf07ac35916baa4874517" translate="yes" xml:space="preserve">
          <source>The UnresolvedPermission class is used to hold Permissions that were &quot;unresolved&quot; when the Policy was initialized.</source>
          <target state="translated">UnresolvedPermission类用于保存策略初始化时 &quot;未解决 &quot;的权限。</target>
        </trans-unit>
        <trans-unit id="106451eadba0a3f499c5e0507a145120909609cc" translate="yes" xml:space="preserve">
          <source>The UnresolvedPermission class is used to hold Permissions that were &quot;unresolved&quot; when the Policy was initialized. An unresolved permission is one whose actual Permission class does not yet exist at the time the Policy is initialized (see below).</source>
          <target state="translated">UnresolvedPermission类用于保存策略初始化时 &quot;未解决 &quot;的权限。未解决的权限是指在初始化策略时实际的权限类还不存在的权限(见下文)。</target>
        </trans-unit>
        <trans-unit id="2df5d6a200c9fc79968c79ca58277554b4e41cb6" translate="yes" xml:space="preserve">
          <source>The Unspecified Address -- Also called anylocal or wildcard address. It must never be assigned to any node. It indicates the absence of an address. One example of its use is as the target of bind, which allows a server to accept a client connection on any interface, in case the server host has multiple interfaces.</source>
          <target state="translated">未指定地址 --也称为anylocal或通配符地址。它决不能分配给任何节点。它表示没有地址。其使用的一个例子是作为bind的目标,在服务器主机有多个接口的情况下,允许服务器在任何接口上接受客户端连接。</target>
        </trans-unit>
        <trans-unit id="fddbcce63ee0a84bbd29b9306e28dc855a2a0ee4" translate="yes" xml:space="preserve">
          <source>The W3C generally recommends to exchange texts in NFC. Note also that most legacy character encodings use only precomposed forms and often do not encode any combining marks by themselves. For conversion to such character encodings the Unicode text needs to be normalized to NFC. For more usage examples, see the Unicode Standard Annex.</source>
          <target state="translated">W3C一般建议用NFC交换文本。还需要注意的是,大多数传统的字符编码只使用预组合形式,而且往往不对任何组合标记本身进行编码。要转换到这种字符编码,Unicode文本需要规范化为NFC。更多的使用实例,请参见Unicode标准附件。</target>
        </trans-unit>
        <trans-unit id="18ef77b0858f46134ac7b482ee49bb629a564dee" translate="yes" xml:space="preserve">
          <source>The X.509 v2 CRL format is described below in ASN.1:</source>
          <target state="translated">X.509 v2 CRL格式在ASN.1中描述如下。</target>
        </trans-unit>
        <trans-unit id="b9fcd80872a7ab82bc8eeea007d48c23637dc911" translate="yes" xml:space="preserve">
          <source>The X3.274-1996 algorithm is:</source>
          <target state="translated">X3.274-1996算法是:</target>
        </trans-unit>
        <trans-unit id="cc613ef20555d504cf2e4f94f40c5f23bc8ce169" translate="yes" xml:space="preserve">
          <source>The XML document has the following DOCTYPE declaration:</source>
          <target state="translated">XML文档的DOCTYPE声明如下。</target>
        </trans-unit>
        <trans-unit id="d9e5faa87bff8499273f37dda3b048324b3c5c25" translate="yes" xml:space="preserve">
          <source>The XML document must have the following DOCTYPE declaration:</source>
          <target state="translated">XML文档必须有以下DOCTYPE声明。</target>
        </trans-unit>
        <trans-unit id="2ed02856deeab148266a90a042c02b0613dd709e" translate="yes" xml:space="preserve">
          <source>The XML document will have the following DOCTYPE declaration:</source>
          <target state="translated">XML文档将有以下DOCTYPE声明。</target>
        </trans-unit>
        <trans-unit id="6b9f663ea5bf11d78ff348081d07ce6ea4fbf89a" translate="yes" xml:space="preserve">
          <source>The XML syntax uses the following conventions:</source>
          <target state="translated">XML语法使用以下约定。</target>
        </trans-unit>
        <trans-unit id="8446a8dce024b6c36553b2bd7e95801c55dc721f" translate="yes" xml:space="preserve">
          <source>The XMLFormatter can be used with arbitrary character encodings, but it is recommended that it normally be used with UTF-8. The character encoding can be set on the output Handler.</source>
          <target state="translated">XMLFormatter可以使用任意的字符编码,但建议通常使用UTF-8。字符编码可以在输出处理程序上设置。</target>
        </trans-unit>
        <trans-unit id="94ac00d5f8bad09d25d989c532f0827c6c5a442b" translate="yes" xml:space="preserve">
          <source>The ability to ask the authenticator registered with the system for a password</source>
          <target state="translated">能够要求在系统中注册的验证者提供密码。</target>
        </trans-unit>
        <trans-unit id="4f6c85667f40550ed984e7d465e987fb50b1cee5" translate="yes" xml:space="preserve">
          <source>The ability to get the SSLSessionContext of an SSLSession.</source>
          <target state="translated">能够获取一个SSLSession的SSLSessionContext。</target>
        </trans-unit>
        <trans-unit id="c08cb64a173c4838bf0ab57b143814354d1d878a" translate="yes" xml:space="preserve">
          <source>The ability to get the cookie handler that processes highly security sensitive cookie information for an Http session.</source>
          <target state="translated">能够获得处理一个Http会话高度安全敏感的cookie信息的cookie处理程序。</target>
        </trans-unit>
        <trans-unit id="747dfd09cac650048472c89cdbbbf59e4084fb21" translate="yes" xml:space="preserve">
          <source>The ability to get the proxy selector used to make decisions on which proxies to use when making network connections.</source>
          <target state="translated">能够获得代理选择器,用于在进行网络连接时决定使用哪些代理。</target>
        </trans-unit>
        <trans-unit id="eb846b7dea720d16a96e23598e4c9f77568665c4" translate="yes" xml:space="preserve">
          <source>The ability to get the response cache that provides access to a local response cache.</source>
          <target state="translated">能够获得提供访问本地响应缓存的响应缓存。</target>
        </trans-unit>
        <trans-unit id="0101c8dcdd9124ae9e9dc071a563cf4befcd5dc2" translate="yes" xml:space="preserve">
          <source>The ability to interrupt a lock acquisition in some implementations may not be possible, and if possible may be an expensive operation. The programmer should be aware that this may be the case. An implementation should document when this is the case.</source>
          <target state="translated">在某些实现中,中断锁获取的能力可能是不可能的,如果可能的话,可能是一个昂贵的操作。程序员应该意识到可能会出现这种情况。在这种情况下,一个实现应该记录下来。</target>
        </trans-unit>
        <trans-unit id="e6fad9c27e4f8a6493f7feabf035fe54852835fe" translate="yes" xml:space="preserve">
          <source>The ability to read (non-acl) file attributes.</source>
          <target state="translated">能够读取(非acl)文件属性。</target>
        </trans-unit>
        <trans-unit id="4dc25dabb4df1918d4e24db4d9c3ddb2ce955dbc" translate="yes" xml:space="preserve">
          <source>The ability to retrieve all information about local network interfaces.</source>
          <target state="translated">能够检索本地网络接口的所有信息。</target>
        </trans-unit>
        <trans-unit id="8d62361f7d663bbcd4ccf2897e33eedf52e2f92b" translate="yes" xml:space="preserve">
          <source>The ability to set a callback which can decide whether to allow a mismatch between the host being connected to by an HttpsURLConnection and the common name field in server certificate.</source>
          <target state="translated">能够设置一个回调,该回调能够决定是否允许HttpsURLConnection连接的主机与服务器证书中的通用名字段不匹配。</target>
        </trans-unit>
        <trans-unit id="c8fd9ad3f015a0c63d2df8d095236f1dc4f764c2" translate="yes" xml:space="preserve">
          <source>The ability to set the cookie handler that processes highly security sensitive cookie information for an Http session.</source>
          <target state="translated">能够设置cookie处理程序,为一个Http会话处理高度安全敏感的cookie信息。</target>
        </trans-unit>
        <trans-unit id="728c49b4a4c3274c673e299fc6abf84bf96e38a8" translate="yes" xml:space="preserve">
          <source>The ability to set the default SSL context</source>
          <target state="translated">能够设置默认的SSL上下文</target>
        </trans-unit>
        <trans-unit id="523d52b8be5bc53ba69bacce4312e572cfbcee19" translate="yes" xml:space="preserve">
          <source>The ability to set the proxy selector used to make decisions on which proxies to use when making network connections.</source>
          <target state="translated">能够设置代理选择器,用于在进行网络连接时决定使用哪些代理。</target>
        </trans-unit>
        <trans-unit id="6a66a567e4af10bb233d87868b18a39623d36448" translate="yes" xml:space="preserve">
          <source>The ability to set the response cache that provides access to a local response cache.</source>
          <target state="translated">能够设置提供访问本地响应缓存的响应缓存。</target>
        </trans-unit>
        <trans-unit id="ea953d76621b3799d35d695029de5de0d988b3b4" translate="yes" xml:space="preserve">
          <source>The ability to set the subsampling grid to start somewhere other than the source region origin is useful if the region is being used to create subsampled tiles of a large image, where the tile width and height are not multiples of the subsampling periods. If the subsampling grid does not remain consistent from tile to tile, there will be artifacts at the tile boundaries. By adjusting the subsampling grid offset for each tile to compensate, these artifacts can be avoided. The tradeoff is that in order to avoid these artifacts, the tiles are not all the same size. The grid offset to use in this case is given by:</source>
          <target state="translated">如果该区域被用于创建大图像的子采样磁片,而磁片的宽度和高度不是子采样周期的倍数,那么将子采样网格设置为从源区域原点以外的其他地方开始的功能就很有用。如果子采样网格在瓦片与瓦片之间不能保持一致,瓦片边界处就会出现伪影。通过调整每个瓦片的子采样网格偏移来补偿,可以避免这些伪影。权衡的结果是,为了避免这些伪影,瓷砖的尺寸并不都是一样的。在这种情况下,要使用的网格偏移量由以下公式给出。</target>
        </trans-unit>
        <trans-unit id="d302e4f1c649bfc96b09fc919581ac270437619a" translate="yes" xml:space="preserve">
          <source>The ability to set the way authentication information is retrieved when a proxy or HTTP server asks for authentication</source>
          <target state="translated">当代理或HTTP服务器要求认证时,能够设置认证信息的检索方式。</target>
        </trans-unit>
        <trans-unit id="89f72a0701e76fa12481a67aeda6de0afe701332" translate="yes" xml:space="preserve">
          <source>The ability to specify a stream handler when constructing a URL</source>
          <target state="translated">能够在构建URL时指定流处理程序。</target>
        </trans-unit>
        <trans-unit id="3b52910e750a521c4270f9ad1e92d1182fab62a3" translate="yes" xml:space="preserve">
          <source>The ability to use the HTTP TRACE method in HttpURLConnection.</source>
          <target state="translated">能够在HttpURLConnection中使用HTTP TRACE方法。</target>
        </trans-unit>
        <trans-unit id="6af3beb90f71de8d44827b35e1c4fa464ca9ab63" translate="yes" xml:space="preserve">
          <source>The ability to write (non-acl) file attributes.</source>
          <target state="translated">能够写入(非acl)文件属性。</target>
        </trans-unit>
        <trans-unit id="75a1e459161bc40b650d129db959cfadba7b7567" translate="yes" xml:space="preserve">
          <source>The above example does not differentiate the case where the memory usage has temporarily dropped below the usage threshold from the case where the memory usage remains above the threshold between two iterations. The usage threshold count returned by the &lt;a href=&quot;memorypoolmxbean#getUsageThresholdCount--&quot;&gt;&lt;code&gt;getUsageThresholdCount()&lt;/code&gt;&lt;/a&gt; method can be used to determine if the memory usage has returned below the threshold between two polls.</source>
          <target state="translated">上面的示例没有将内存使用量暂时下降到使用量阈值以下的情况与两次迭代之间内存使用量保持在阈值以上的情况进行区分。由&lt;a href=&quot;memorypoolmxbean#getUsageThresholdCount--&quot;&gt; &lt;code&gt;getUsageThresholdCount()&lt;/code&gt; &lt;/a&gt;方法返回的使用率阈值计数可用于确定内存使用率是否已返回两次轮询之间的阈值以下。</target>
        </trans-unit>
        <trans-unit id="11a11e7a079a4b4c5ac0f002d2763bf2a39aa9e4" translate="yes" xml:space="preserve">
          <source>The above grants access to the private Credential, &quot;a.b.Credential&quot;, belonging to a &lt;code&gt;Subject&lt;/code&gt; with at least two associated Principals: &quot;a.b.Principal&quot; with the name, &quot;duke&quot;, and &quot;c.d.Principal&quot;, with the name, &quot;dukette&quot;.</source>
          <target state="translated">上面的方法授予对私有凭证&amp;ldquo; abCredential&amp;rdquo;的访问权限，该凭证属于一个 &lt;code&gt;Subject&lt;/code&gt; ，主体具有至少两个关联的主体：名称为&amp;ldquo; duke&amp;rdquo;的&amp;ldquo; abPrincipal&amp;rdquo;和名称为&amp;ldquo; dukette&amp;rdquo;的&amp;ldquo; cdPrincipal&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="edbd434347b519de487f2abd90d51adf485fdec2" translate="yes" xml:space="preserve">
          <source>The absolute abstract pathname denoting the same file or directory as this abstract pathname</source>
          <target state="translated">表示与该抽象路径名相同的文件或目录的绝对抽象路径名。</target>
        </trans-unit>
        <trans-unit id="ec2d2417f86515cab10b6adbdf408e19019363aa" translate="yes" xml:space="preserve">
          <source>The absolute path of the native library</source>
          <target state="translated">本地库的绝对路径</target>
        </trans-unit>
        <trans-unit id="e572ffca3dbcbc1dee7ecbdd936a165e89cf3f71" translate="yes" xml:space="preserve">
          <source>The absolute path of the native library.</source>
          <target state="translated">本机库的绝对路径。</target>
        </trans-unit>
        <trans-unit id="96304c31818a11d31d7bb72121ee4dcd82da0c5c" translate="yes" xml:space="preserve">
          <source>The absolute pathname string denoting the same file or directory as this abstract pathname</source>
          <target state="translated">表示与该抽象路径名相同的文件或目录的绝对路径名。</target>
        </trans-unit>
        <trans-unit id="26ceb41a43a33e3dffbfc97a7a937681a96cef0a" translate="yes" xml:space="preserve">
          <source>The abstract class &lt;code&gt;ContentHandler&lt;/code&gt; is the superclass of all classes that read an &lt;code&gt;Object&lt;/code&gt; from a &lt;code&gt;URLConnection&lt;/code&gt;.</source>
          <target state="translated">抽象类 &lt;code&gt;ContentHandler&lt;/code&gt; 是所有从 &lt;code&gt;URLConnection&lt;/code&gt; 读取 &lt;code&gt;Object&lt;/code&gt; 的类的超类。</target>
        </trans-unit>
        <trans-unit id="ef4fe4e3d9f2f3d537889773b4af854337477934" translate="yes" xml:space="preserve">
          <source>The abstract class &lt;code&gt;Number&lt;/code&gt; is the superclass of platform classes representing numeric values that are convertible to the primitive types &lt;code&gt;byte&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, and &lt;code&gt;short&lt;/code&gt;.</source>
          <target state="translated">抽象类 &lt;code&gt;Number&lt;/code&gt; 是平台类的超类，代表可转换为原始类型 &lt;code&gt;byte&lt;/code&gt; ， &lt;code&gt;double&lt;/code&gt; ， &lt;code&gt;float&lt;/code&gt; ， &lt;code&gt;int&lt;/code&gt; ， &lt;code&gt;long&lt;/code&gt; 和 &lt;code&gt;short&lt;/code&gt; 的数值的平台类。</target>
        </trans-unit>
        <trans-unit id="3cef21ebdb6ade078e43294abd142a0407b82a51" translate="yes" xml:space="preserve">
          <source>The abstract class &lt;code&gt;Number&lt;/code&gt; is the superclass of platform classes representing numeric values that are convertible to the primitive types &lt;code&gt;byte&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, and &lt;code&gt;short&lt;/code&gt;. The specific semantics of the conversion from the numeric value of a particular &lt;code&gt;Number&lt;/code&gt; implementation to a given primitive type is defined by the &lt;code&gt;Number&lt;/code&gt; implementation in question. For platform classes, the conversion is often analogous to a narrowing primitive conversion or a widening primitive conversion as defining in</source>
          <target state="translated">抽象类 &lt;code&gt;Number&lt;/code&gt; 是平台类的超类，表示可转换为原始类型 &lt;code&gt;byte&lt;/code&gt; ， &lt;code&gt;double&lt;/code&gt; ， &lt;code&gt;float&lt;/code&gt; ， &lt;code&gt;int&lt;/code&gt; ， &lt;code&gt;long&lt;/code&gt; 和 &lt;code&gt;short&lt;/code&gt; 的数值的平台类。从特定 &lt;code&gt;Number&lt;/code&gt; 实现的数值到给定原始类型的转换的特定语义由所讨论的 &lt;code&gt;Number&lt;/code&gt; 实现定义。对于平台类，该转换通常类似于缩小原语转换或扩大原语转换，如</target>
        </trans-unit>
        <trans-unit id="7471b19f604dcfd018473768425dd3d88567b855" translate="yes" xml:space="preserve">
          <source>The abstract class &lt;code&gt;SocketImpl&lt;/code&gt; is a common superclass of all classes that actually implement sockets.</source>
          <target state="translated">抽象类 &lt;code&gt;SocketImpl&lt;/code&gt; 是所有实际实现套接字的类的通用超类。</target>
        </trans-unit>
        <trans-unit id="61d7aa3ed568898a90d798649c3d36186093daf9" translate="yes" xml:space="preserve">
          <source>The abstract class &lt;code&gt;SocketImpl&lt;/code&gt; is a common superclass of all classes that actually implement sockets. It is used to create both client and server sockets.</source>
          <target state="translated">抽象类 &lt;code&gt;SocketImpl&lt;/code&gt; 是所有实际实现套接字的类的通用超类。它用于创建客户端和服务器套接字。</target>
        </trans-unit>
        <trans-unit id="456bb9271567243e4cd050a468dafa3e449e2d3b" translate="yes" xml:space="preserve">
          <source>The abstract class &lt;code&gt;URLConnection&lt;/code&gt; is the superclass of all classes that represent a communications link between the application and a URL.</source>
          <target state="translated">抽象类 &lt;code&gt;URLConnection&lt;/code&gt; 是所有类的超类，这些类表示应用程序和URL之间的通信链接。</target>
        </trans-unit>
        <trans-unit id="76cea7d35ffe4da75cc712cb986a9f4a981aee90" translate="yes" xml:space="preserve">
          <source>The abstract class &lt;code&gt;URLConnection&lt;/code&gt; is the superclass of all classes that represent a communications link between the application and a URL. Instances of this class can be used both to read from and to write to the resource referenced by the URL. In general, creating a connection to a URL is a multistep process:</source>
          <target state="translated">抽象类 &lt;code&gt;URLConnection&lt;/code&gt; 是所有类的超类，这些类表示应用程序和URL之间的通信链接。此类的实例可用于读取和写入URL引用的资源。通常，创建到URL的连接是一个多步骤过程：</target>
        </trans-unit>
        <trans-unit id="30ca6e222c37a7c8793230b3a0c7767b66c517e7" translate="yes" xml:space="preserve">
          <source>The abstract class &lt;code&gt;URLStreamHandler&lt;/code&gt; is the common superclass for all stream protocol handlers.</source>
          <target state="translated">&lt;code&gt;URLStreamHandler&lt;/code&gt; 抽象类是所有流协议处理程序的公共超类。</target>
        </trans-unit>
        <trans-unit id="d07377ac8882b20ce73ef6e587a0c0d99b110d29" translate="yes" xml:space="preserve">
          <source>The abstract class &lt;code&gt;URLStreamHandler&lt;/code&gt; is the common superclass for all stream protocol handlers. A stream protocol handler knows how to make a connection for a particular protocol type, such as &lt;code&gt;http&lt;/code&gt; or &lt;code&gt;https&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;URLStreamHandler&lt;/code&gt; 抽象类是所有流协议处理程序的公共超类。流协议处理程序知道如何为特定协议类型（例如 &lt;code&gt;http&lt;/code&gt; 或 &lt;code&gt;https&lt;/code&gt; )建立连接。</target>
        </trans-unit>
        <trans-unit id="4cc8e5427b10107c4b13456b30226c7cd3468de3" translate="yes" xml:space="preserve">
          <source>The abstract class from which all persistence delegates descend. Your subclass should use its knowledge of the bean's type to provide whatever &lt;code&gt;Statement&lt;/code&gt;s and &lt;code&gt;Expression&lt;/code&gt;s are necessary to create the bean and restore its state.</source>
          <target state="translated">所有持久性委托从其派生的抽象类。您的子类应使用其对Bean类型的了解来提供创建Bean和恢复其状态所需的任何 &lt;code&gt;Statement&lt;/code&gt; 和 &lt;code&gt;Expression&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e33bef79f2b898deb8cd8c8cf089745eb2108b2c" translate="yes" xml:space="preserve">
          <source>The abstract pathname of the parent directory named by this abstract pathname, or &lt;code&gt;null&lt;/code&gt; if this pathname does not name a parent</source>
          <target state="translated">由该抽象路径名命名的父目录的抽象路径名；如果此路径名未命名父目录，则为 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="80237c2613dc82633718c694ff63ccd5e8f49761" translate="yes" xml:space="preserve">
          <source>The abstract syntax classes are independent of the attributes that use them. In fact, applications that have nothing to do with printing can use the abstract syntax classes. Although most of the standard attribute classes extend one of the abstract syntax classes, no attribute class is required to extend one of these classes. The abstract syntax classes merely provide a convenient implementation that can be shared by many attribute classes.</source>
          <target state="translated">抽象语法类与使用它们的属性无关。事实上,与打印无关的应用程序可以使用抽象语法类。虽然大多数标准属性类都扩展了其中一个抽象语法类,但没有任何属性类需要扩展这些类。抽象语法类只是提供了一个方便的实现,可以被许多属性类共享。</target>
        </trans-unit>
        <trans-unit id="98f9919547d9e7324fbeace7ddfba4ce592d0afd" translate="yes" xml:space="preserve">
          <source>The access modifiers are placed in canonical order as specified by &quot;The Java Language Specification&quot;. This is &lt;code&gt;public&lt;/code&gt;, &lt;code&gt;protected&lt;/code&gt; or &lt;code&gt;private&lt;/code&gt; first, and then other modifiers in the following order: &lt;code&gt;abstract&lt;/code&gt;, &lt;code&gt;default&lt;/code&gt;, &lt;code&gt;static&lt;/code&gt;, &lt;code&gt;final&lt;/code&gt;, &lt;code&gt;synchronized&lt;/code&gt;, &lt;code&gt;native&lt;/code&gt;, &lt;code&gt;strictfp&lt;/code&gt;.</source>
          <target state="translated">访问修饰符按照&amp;ldquo; Java语言规范&amp;rdquo;所指定的规范顺序放置。首先是 &lt;code&gt;public&lt;/code&gt; ， &lt;code&gt;protected&lt;/code&gt; 或 &lt;code&gt;private&lt;/code&gt; ，然后是其他修饰符，其顺序如下： &lt;code&gt;abstract&lt;/code&gt; ， &lt;code&gt;default&lt;/code&gt; ， &lt;code&gt;static&lt;/code&gt; ， &lt;code&gt;final&lt;/code&gt; ， &lt;code&gt;synchronized&lt;/code&gt; ， &lt;code&gt;native&lt;/code&gt; ， &lt;code&gt;strictfp&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="df151d45df66db7ce016a4b7c1366a40643ea380" translate="yes" xml:space="preserve">
          <source>The accesses permitted to a given lookup object may be limited, according to its set of &lt;a href=&quot;methodhandles.lookup#lookupModes--&quot;&gt;&lt;code&gt;lookupModes&lt;/code&gt;&lt;/a&gt;, to a subset of members normally accessible to the lookup class. For example, the &lt;a href=&quot;methodhandles#publicLookup--&quot;&gt;&lt;code&gt;publicLookup&lt;/code&gt;&lt;/a&gt; method produces a lookup object which is only allowed to access public members in public classes. The caller sensitive method &lt;a href=&quot;methodhandles#lookup--&quot;&gt;&lt;code&gt;lookup&lt;/code&gt;&lt;/a&gt; produces a lookup object with full capabilities relative to its caller class, to emulate all supported bytecode behaviors. Also, the &lt;a href=&quot;methodhandles.lookup#in-java.lang.Class-&quot;&gt;&lt;code&gt;Lookup.in&lt;/code&gt;&lt;/a&gt; method may produce a lookup object with fewer access modes than the original lookup object.</source>
          <target state="translated">根据其&lt;a href=&quot;methodhandles.lookup#lookupModes--&quot;&gt; &lt;code&gt;lookupModes&lt;/code&gt; &lt;/a&gt;集合，可以将对给定查找对象的允许访问限制为通常可用于该查找类的成员子集。例如，&lt;a href=&quot;methodhandles#publicLookup--&quot;&gt; &lt;code&gt;publicLookup&lt;/code&gt; &lt;/a&gt;方法产生一个查找对象，该对象仅被允许访问公共类中的公共成员。调用方敏感方法&lt;a href=&quot;methodhandles#lookup--&quot;&gt; &lt;code&gt;lookup&lt;/code&gt; &lt;/a&gt;会生成一个具有相对于其调用方类完整功能的查找对象，以模拟所有受支持的字节码行为。此外，&lt;a href=&quot;methodhandles.lookup#in-java.lang.Class-&quot;&gt; &lt;code&gt;Lookup.in&lt;/code&gt; &lt;/a&gt;方法可能会产生一个访问对象比原始查询对象少的查询对象。</target>
        </trans-unit>
        <trans-unit id="336019016c9cfc89449e3197f835520dcb785799" translate="yes" xml:space="preserve">
          <source>The accumulated elapsed time that the thread has blocked for synchronization or waited for notification since &lt;a href=&quot;threadmxbean#setThreadContentionMonitoringEnabled-boolean-&quot;&gt;&lt;code&gt;thread contention monitoring&lt;/code&gt;&lt;/a&gt; was enabled. Some Java virtual machine implementation may not support this. The &lt;a href=&quot;threadmxbean#isThreadContentionMonitoringSupported--&quot;&gt;&lt;code&gt;ThreadMXBean.isThreadContentionMonitoringSupported()&lt;/code&gt;&lt;/a&gt; method can be used to determine if a Java virtual machine supports this.</source>
          <target state="translated">自启用&lt;a href=&quot;threadmxbean#setThreadContentionMonitoringEnabled-boolean-&quot;&gt; &lt;code&gt;thread contention monitoring&lt;/code&gt; &lt;/a&gt;以来，线程已阻止进行同步或等待通知的累积经过时间。某些Java虚拟机实现可能不支持此功能。所述&lt;a href=&quot;threadmxbean#isThreadContentionMonitoringSupported--&quot;&gt; &lt;code&gt;ThreadMXBean.isThreadContentionMonitoringSupported()&lt;/code&gt; &lt;/a&gt;方法可用于确定是否一个Java虚拟机支持这一点。</target>
        </trans-unit>
        <trans-unit id="6c3240d64320b1f694103cbb6fbd69517a656609" translate="yes" xml:space="preserve">
          <source>The action is returned by &lt;a href=&quot;mbeanpermission#getActions--&quot;&gt;&lt;code&gt;getActions()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该动作由&lt;a href=&quot;mbeanpermission#getActions--&quot;&gt; &lt;code&gt;getActions()&lt;/code&gt; &lt;/a&gt;返回。</target>
        </trans-unit>
        <trans-unit id="fa53698de684065668ab67c1cd5cf7f587771eef" translate="yes" xml:space="preserve">
          <source>The action string (inherited from Permission) is unused. Thus, BasicPermission is commonly used as the base class for &quot;named&quot; permissions (ones that contain a name but no actions list; you either have the named permission or you don't.) Subclasses may implement actions on top of BasicPermission, if desired.</source>
          <target state="translated">动作字符串(继承自Permission)未被使用。因此,BasicPermission通常被用作 &quot;命名 &quot;权限的基类(那些包含名称但没有动作列表的权限;你要么拥有命名权限,要么没有。如果需要的话,子类可以在BasicPermission的基础上实现动作。</target>
        </trans-unit>
        <trans-unit id="a391d8169ef81029e091e136d4c09fc86d81e0fb" translate="yes" xml:space="preserve">
          <source>The action to be performed by this timer task.</source>
          <target state="translated">该定时器任务所要执行的动作。</target>
        </trans-unit>
        <trans-unit id="f7096d2bffa5dec03522218205f50ac60f72bdfe" translate="yes" xml:space="preserve">
          <source>The actions parameter contains a comma-separated list of the desired actions granted on the target name. It must not be empty or null.</source>
          <target state="translated">actions参数包含一个以逗号分隔的目标名称所需的行动列表。它不得为空或空。</target>
        </trans-unit>
        <trans-unit id="c8cca4f8acc451307827a22daeee56bcf88f5e0c" translate="yes" xml:space="preserve">
          <source>The actions string is converted to lowercase before processing.</source>
          <target state="translated">在处理之前,动作字符串会被转换为小写。</target>
        </trans-unit>
        <trans-unit id="0a4a303a8ca535a1283105909db26fc04234c9e3" translate="yes" xml:space="preserve">
          <source>The actions string of a URLPermission is a concatenation of the</source>
          <target state="translated">URLPermission的动作字符串是由以下几个参数串联而成的</target>
        </trans-unit>
        <trans-unit id="b3c62e9495ee4ac46ead6ccca9eb89cb863dc5fd" translate="yes" xml:space="preserve">
          <source>The actions to be granted are passed to the constructor in a string containing a list of one or more comma-separated keywords. The possible keywords are &quot;read&quot; and &quot;write&quot;. Their meaning is defined as follows:</source>
          <target state="translated">授予的操作以一个包含一个或多个逗号分隔的关键字列表的字符串传递给构造函数。可能的关键字是 &quot;读 &quot;和 &quot;写&quot;。它们的含义定义如下。</target>
        </trans-unit>
        <trans-unit id="d1b568cd9af613226967c935a47a44c2811969df" translate="yes" xml:space="preserve">
          <source>The actions to be granted are passed to the constructor in a string containing a list of one or more comma-separated keywords. The possible keywords are &quot;read&quot;, &quot;write&quot;, &quot;execute&quot;, &quot;delete&quot;, and &quot;readlink&quot;. Their meaning is defined as follows:</source>
          <target state="translated">授予的操作以一个包含一个或多个逗号分隔的关键字列表的字符串传递给构造函数。可能的关键字有 &quot;读&quot;、&quot;写&quot;、&quot;执行&quot;、&quot;删除 &quot;和 &quot;读链接&quot;。它们的含义定义如下。</target>
        </trans-unit>
        <trans-unit id="bc14d6c59502ef37434f04213e34e85f51e0fdc8" translate="yes" xml:space="preserve">
          <source>The actual &lt;code&gt;BufferedImage&lt;/code&gt; referenced by the returned &lt;code&gt;IIOImage&lt;/code&gt; will be chosen using the algorithm defined by the &lt;code&gt;getDestination&lt;/code&gt; method.</source>
          <target state="translated">返回的 &lt;code&gt;IIOImage&lt;/code&gt; 引用的实际 &lt;code&gt;BufferedImage&lt;/code&gt; 将使用 &lt;code&gt;getDestination&lt;/code&gt; 方法定义的算法进行选择。</target>
        </trans-unit>
        <trans-unit id="aee4a0d5a3aed8d41f92b1bdfebee288637b4d1b" translate="yes" xml:space="preserve">
          <source>The actual &lt;code&gt;BufferedImage&lt;/code&gt; returned will be chosen using the algorithm defined by the &lt;code&gt;getDestination&lt;/code&gt; method.</source>
          <target state="translated">返回的实际 &lt;code&gt;BufferedImage&lt;/code&gt; 将使用 &lt;code&gt;getDestination&lt;/code&gt; 方法定义的算法进行选择。</target>
        </trans-unit>
        <trans-unit id="6ed82671a5099d02bc4ad95bcdef0c774f23476b" translate="yes" xml:space="preserve">
          <source>The actual connection to the remote object is made, using the &lt;code&gt;connect&lt;/code&gt; method.</source>
          <target state="translated">使用 &lt;code&gt;connect&lt;/code&gt; 方法建立到远程对象的实际连接。</target>
        </trans-unit>
        <trans-unit id="02600ea475ec423c00be1655967502d1587e439e" translate="yes" xml:space="preserve">
          <source>The actual installation of the value on the class is performed atomically. At that point, if several racing threads have computed values, one is chosen, and returned to all the racing threads.</source>
          <target state="translated">实际安装在类上的值是以原子方式进行的。这时,如果几个赛车线程都计算了值,就选择一个,并返回给所有赛车线程。</target>
        </trans-unit>
        <trans-unit id="af13a097906e4621821341553b5dbc08b523da1a" translate="yes" xml:space="preserve">
          <source>The actual number of bytes skipped is returned.</source>
          <target state="translated">返回实际跳过的字节数。</target>
        </trans-unit>
        <trans-unit id="671467fba02c14caa04b6f11f619a6c32257e26e" translate="yes" xml:space="preserve">
          <source>The actual number of characters read, or -1 if the end of the stream has been reached</source>
          <target state="translated">实际读取的字符数,如果已经到达流的终点,则为-1。</target>
        </trans-unit>
        <trans-unit id="059f9bec40ef8abe09f7c4c1f2b0e3a447ff1b0c" translate="yes" xml:space="preserve">
          <source>The actual number of passes to be decoded is determined during decoding, based on the number of actual passes available in the stream. Thus if &lt;code&gt;minPass + numPasses - 1&lt;/code&gt; is larger than the index of the last available passes, decoding will end with that pass.</source>
          <target state="translated">根据流中可用的实际通过次数，在解码期间确定要解码的实际通过次数。因此，如果 &lt;code&gt;minPass + numPasses - 1&lt;/code&gt; 大于最后一个可用遍的索引，则解码将以该遍结束。</target>
        </trans-unit>
        <trans-unit id="c82700f258fcadc84f9879bec102ae1591cfaca9" translate="yes" xml:space="preserve">
          <source>The actual output length of the next &lt;a href=&quot;exemptionmechanism#genExemptionBlob-byte:A-&quot;&gt;&lt;code&gt;genExemptionBlob&lt;/code&gt;&lt;/a&gt; call may be smaller than the length returned by this method.</source>
          <target state="translated">下一个&lt;a href=&quot;exemptionmechanism#genExemptionBlob-byte:A-&quot;&gt; &lt;code&gt;genExemptionBlob&lt;/code&gt; &lt;/a&gt;调用的实际输出长度可能小于此方法返回的长度。</target>
        </trans-unit>
        <trans-unit id="905d6033fae48670e75b261f56eb861a8b025e25" translate="yes" xml:space="preserve">
          <source>The actual output length of the next &lt;a href=&quot;exemptionmechanismspi#engineGenExemptionBlob-byte:A-int-&quot;&gt;&lt;code&gt;engineGenExemptionBlob&lt;/code&gt;&lt;/a&gt; call may be smaller than the length returned by this method.</source>
          <target state="translated">下一个&lt;a href=&quot;exemptionmechanismspi#engineGenExemptionBlob-byte:A-int-&quot;&gt; &lt;code&gt;engineGenExemptionBlob&lt;/code&gt; &lt;/a&gt;调用的实际输出长度可能小于此方法返回的长度。</target>
        </trans-unit>
        <trans-unit id="f0b999dc9952fdc4bc163efd809eb4b540035151" translate="yes" xml:space="preserve">
          <source>The actual output length of the next &lt;code&gt;update&lt;/code&gt; or &lt;code&gt;doFinal&lt;/code&gt; call may be smaller than the length returned by this method.</source>
          <target state="translated">下次 &lt;code&gt;update&lt;/code&gt; 或 &lt;code&gt;doFinal&lt;/code&gt; 调用的实际输出长度可能小于此方法返回的长度。</target>
        </trans-unit>
        <trans-unit id="5c672f3632d6634aa05d5efd1e829e67334a8823" translate="yes" xml:space="preserve">
          <source>The actual rules, describing when and how the offset changes, are defined by &lt;a href=&quot;zone/zonerules&quot;&gt;&lt;code&gt;ZoneRules&lt;/code&gt;&lt;/a&gt;. This class is simply an ID used to obtain the underlying rules. This approach is taken because rules are defined by governments and change frequently, whereas the ID is stable.</source>
          <target state="translated">&lt;a href=&quot;zone/zonerules&quot;&gt; &lt;code&gt;ZoneRules&lt;/code&gt; &lt;/a&gt;定义了描述偏移量何时以及如何变化的实际规则。此类只是用于获取基础规则的ID。之所以采用这种方法，是因为规则是由政府定义的，并且经常更改，而ID是稳定的。</target>
        </trans-unit>
        <trans-unit id="8a8a6705f91238a61dfbbb0d224ce49b1650a684" translate="yes" xml:space="preserve">
          <source>The actual work of the server socket is performed by an instance of the &lt;code&gt;SocketImpl&lt;/code&gt; class. An application can change the socket factory that creates the socket implementation to configure itself to create sockets appropriate to the local firewall.</source>
          <target state="translated">服务器套接字的实际工作是由 &lt;code&gt;SocketImpl&lt;/code&gt; 类的实例执行的。应用程序可以更改创建套接字实现的套接字工厂，以将其自身配置为创建适合于本地防火墙的套接字。</target>
        </trans-unit>
        <trans-unit id="8b2d531952326e9ae5acc2e183a81fbf168e4f22" translate="yes" xml:space="preserve">
          <source>The actual work of the socket is performed by an instance of the &lt;code&gt;SocketImpl&lt;/code&gt; class. An application, by changing the socket factory that creates the socket implementation, can configure itself to create sockets appropriate to the local firewall.</source>
          <target state="translated">套接字的实际工作由 &lt;code&gt;SocketImpl&lt;/code&gt; 类的实例执行。通过更改用于创建套接字实现的套接字工厂，应用程序可以配置自身以创建适合于本地防火墙的套接字。</target>
        </trans-unit>
        <trans-unit id="c52fcad8240289893d4eaf9e9bd3a09a6e65683c" translate="yes" xml:space="preserve">
          <source>The addition of the annotations of type</source>
          <target state="translated">增加的类型注释</target>
        </trans-unit>
        <trans-unit id="7d1225e18c065ce8b5b65c6424eb1bdb34bfbf23" translate="yes" xml:space="preserve">
          <source>The additional stipulation on constructors is, not surprisingly, that all constructors must create a set that contains no duplicate elements (as defined above).</source>
          <target state="translated">关于构造函数的额外规定是,毫不奇怪,所有构造函数必须创建一个不包含重复元素的集合(如上定义)。</target>
        </trans-unit>
        <trans-unit id="6d4d7fd7de63074cc28843a0d9ac3ddd2b5ab0c4" translate="yes" xml:space="preserve">
          <source>The address at the 0-based index posn. It must be in the range [0,getAddressCount()).</source>
          <target state="translated">基于0的索引posn的地址。它必须在[0,getAddressCount()]范围内。</target>
        </trans-unit>
        <trans-unit id="acf519d18f988e1d4f17bff6c076ffba8b178197" translate="yes" xml:space="preserve">
          <source>The address can instead indicate where to find an RMI stub through JNDI, using one of the following syntaxes:</source>
          <target state="translated">该地址可以通过JNDI指示在哪里找到RMI存根,使用以下语法之一。</target>
        </trans-unit>
        <trans-unit id="8c5756a8e726f896e4ca08c8947bb793ca198bf8" translate="yes" xml:space="preserve">
          <source>The address can refer directly to the connector server, using one of the following syntaxes:</source>
          <target state="translated">该地址可以直接引用连接器服务器,使用以下语法之一。</target>
        </trans-unit>
        <trans-unit id="73a61fe4e9ac93744841f28ec8ac19091292e962" translate="yes" xml:space="preserve">
          <source>The address in this reference with address type 'addrType; null if no such address exist.</source>
          <target state="translated">此引用中的地址类型为'addrType';如果没有这样的地址,则为空。</target>
        </trans-unit>
        <trans-unit id="1ae2b9a5a8bb1f512366590bc69983d2d8d4b80c" translate="yes" xml:space="preserve">
          <source>The address is an &lt;em&gt;Abstract Service URL&lt;/em&gt; for SLP, as defined in RFC 2609 and amended by RFC 3111. It must look like this:</source>
          <target state="translated">该地址是RFC 2609中定义并由RFC 3111修改的SLP &lt;em&gt;抽象服务URL&lt;/em&gt;。它必须看起来像这样：</target>
        </trans-unit>
        <trans-unit id="b2d8cc9e90317711c8a0f41b88e1676a7ca465b5" translate="yes" xml:space="preserve">
          <source>The address of a JMX API connector server.</source>
          <target state="translated">JMX API连接器服务器的地址。</target>
        </trans-unit>
        <trans-unit id="a4d7eacf72ff3ed3d8e0d07482c00d672118ff08" translate="yes" xml:space="preserve">
          <source>The address of a JMX API connector server. Instances of this class are immutable.</source>
          <target state="translated">JMX API连接器服务器的地址。该类的实例是不可更改的。</target>
        </trans-unit>
        <trans-unit id="ba3c7b74f23c4583d4b444f591e20adf3f4aa41b" translate="yes" xml:space="preserve">
          <source>The address of this connector server.</source>
          <target state="translated">该连接器服务器的地址。</target>
        </trans-unit>
        <trans-unit id="e06cc9043fd1b212e6c9273048ab4a11862abe21" translate="yes" xml:space="preserve">
          <source>The address of this connector.</source>
          <target state="translated">该连接器的地址。</target>
        </trans-unit>
        <trans-unit id="bab9a87aaeb2101b2a58a43fae60b598d81efc1f" translate="yes" xml:space="preserve">
          <source>The address of this object.</source>
          <target state="translated">该对象的地址。</target>
        </trans-unit>
        <trans-unit id="2d5c9fe06015caa29475e0490fe944507228cefb" translate="yes" xml:space="preserve">
          <source>The address removed.</source>
          <target state="translated">地址被删除。</target>
        </trans-unit>
        <trans-unit id="220e4c6a5e8db780a03f0ab0f7e8134a6d8babd4" translate="yes" xml:space="preserve">
          <source>The address returned may not be the exact original &lt;a href=&quot;../jmxserviceurl&quot;&gt;&lt;code&gt;JMXServiceURL&lt;/code&gt;&lt;/a&gt; that was supplied when creating the connector server, since the original address may not always be complete. For example the port number may be dynamically allocated when starting the connector server. Instead the address returned is the actual &lt;a href=&quot;../jmxserviceurl&quot;&gt;&lt;code&gt;JMXServiceURL&lt;/code&gt;&lt;/a&gt; of the &lt;a href=&quot;../jmxconnectorserver&quot;&gt;&lt;code&gt;JMXConnectorServer&lt;/code&gt;&lt;/a&gt;. This is the address that clients supply to &lt;a href=&quot;../jmxconnectorfactory#connect-javax.management.remote.JMXServiceURL-&quot;&gt;&lt;code&gt;JMXConnectorFactory.connect(JMXServiceURL)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">返回的地址可能不是创建连接器服务器时提供的确切原始&lt;a href=&quot;../jmxserviceurl&quot;&gt; &lt;code&gt;JMXServiceURL&lt;/code&gt; &lt;/a&gt;，因为原始地址可能并不总是完整的。例如，启动连接器服务器时可以动态分配端口号。相反，返回的地址是实际&lt;a href=&quot;../jmxserviceurl&quot;&gt; &lt;code&gt;JMXServiceURL&lt;/code&gt; &lt;/a&gt;中的&lt;a href=&quot;../jmxconnectorserver&quot;&gt; &lt;code&gt;JMXConnectorServer&lt;/code&gt; &lt;/a&gt;。这是客户端提供给&lt;a href=&quot;../jmxconnectorfactory#connect-javax.management.remote.JMXServiceURL-&quot;&gt; &lt;code&gt;JMXConnectorFactory.connect(JMXServiceURL)&lt;/code&gt; &lt;/a&gt;的地址。</target>
        </trans-unit>
        <trans-unit id="64e70a0a071f31f810c944e102a872232bd00f6d" translate="yes" xml:space="preserve">
          <source>The address returned may not be the exact original &lt;a href=&quot;jmxserviceurl&quot;&gt;&lt;code&gt;JMXServiceURL&lt;/code&gt;&lt;/a&gt; that was supplied when creating the connector server, since the original address may not always be complete. For example the port number may be dynamically allocated when starting the connector server. Instead the address returned is the actual &lt;a href=&quot;jmxserviceurl&quot;&gt;&lt;code&gt;JMXServiceURL&lt;/code&gt;&lt;/a&gt; of the &lt;a href=&quot;jmxconnectorserver&quot;&gt;&lt;code&gt;JMXConnectorServer&lt;/code&gt;&lt;/a&gt;. This is the address that clients supply to &lt;a href=&quot;jmxconnectorfactory#connect-javax.management.remote.JMXServiceURL-&quot;&gt;&lt;code&gt;JMXConnectorFactory.connect(JMXServiceURL)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">返回的地址可能不是创建连接器服务器时提供的确切原始&lt;a href=&quot;jmxserviceurl&quot;&gt; &lt;code&gt;JMXServiceURL&lt;/code&gt; &lt;/a&gt;，因为原始地址可能并不总是完整的。例如，启动连接器服务器时可以动态分配端口号。相反，返回的地址是实际&lt;a href=&quot;jmxserviceurl&quot;&gt; &lt;code&gt;JMXServiceURL&lt;/code&gt; &lt;/a&gt;中的&lt;a href=&quot;jmxconnectorserver&quot;&gt; &lt;code&gt;JMXConnectorServer&lt;/code&gt; &lt;/a&gt;。这是客户端提供给&lt;a href=&quot;jmxconnectorfactory#connect-javax.management.remote.JMXServiceURL-&quot;&gt; &lt;code&gt;JMXConnectorFactory.connect(JMXServiceURL)&lt;/code&gt; &lt;/a&gt;的地址。</target>
        </trans-unit>
        <trans-unit id="6241bef1e5fade87c6fb4134f49cb46aed6feb8c" translate="yes" xml:space="preserve">
          <source>The adjacent floating-point value closer to negative infinity.</source>
          <target state="translated">相邻的浮点数接近负无穷大。</target>
        </trans-unit>
        <trans-unit id="d7287ef5a420daf086005caedeba3f1999cd4f1b" translate="yes" xml:space="preserve">
          <source>The adjacent floating-point value closer to positive infinity.</source>
          <target state="translated">相邻的浮点数接近正无穷大。</target>
        </trans-unit>
        <trans-unit id="9660f4df915ae438aaa1ca69a926277eb5e438e2" translate="yes" xml:space="preserve">
          <source>The adjustment is equivalent to using &lt;a href=&quot;../temporal/temporal#with-java.time.temporal.TemporalField-long-&quot;&gt;&lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt;&lt;/a&gt; passing &lt;a href=&quot;../temporal/chronofield#EPOCH_DAY&quot;&gt;&lt;code&gt;ChronoField.EPOCH_DAY&lt;/code&gt;&lt;/a&gt; as the field.</source>
          <target state="translated">该调整等效于使用&lt;a href=&quot;../temporal/temporal#with-java.time.temporal.TemporalField-long-&quot;&gt; &lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt; &lt;/a&gt;传递&lt;a href=&quot;../temporal/chronofield#EPOCH_DAY&quot;&gt; &lt;code&gt;ChronoField.EPOCH_DAY&lt;/code&gt; &lt;/a&gt;作为字段。</target>
        </trans-unit>
        <trans-unit id="1af39ea9e620defde8decc9abf70f8893f08effe" translate="yes" xml:space="preserve">
          <source>The adjustment is equivalent to using &lt;a href=&quot;../temporal/temporal#with-java.time.temporal.TemporalField-long-&quot;&gt;&lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt;&lt;/a&gt; passing &lt;a href=&quot;../temporal/chronofield#ERA&quot;&gt;&lt;code&gt;ChronoField.ERA&lt;/code&gt;&lt;/a&gt; as the field.</source>
          <target state="translated">该调整等效于使用&lt;a href=&quot;../temporal/temporal#with-java.time.temporal.TemporalField-long-&quot;&gt; &lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt; &lt;/a&gt;传递&lt;a href=&quot;../temporal/chronofield#ERA&quot;&gt; &lt;code&gt;ChronoField.ERA&lt;/code&gt; &lt;/a&gt;作为字段。</target>
        </trans-unit>
        <trans-unit id="fda27fe7600ef055a1fc731d1cae77fdc5cf2c6d" translate="yes" xml:space="preserve">
          <source>The adjustment is equivalent to using &lt;a href=&quot;../temporal/temporal#with-java.time.temporal.TemporalField-long-&quot;&gt;&lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt;&lt;/a&gt; twice, passing &lt;a href=&quot;../temporal/chronofield#EPOCH_DAY&quot;&gt;&lt;code&gt;ChronoField.EPOCH_DAY&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../temporal/chronofield#NANO_OF_DAY&quot;&gt;&lt;code&gt;ChronoField.NANO_OF_DAY&lt;/code&gt;&lt;/a&gt; as the fields.</source>
          <target state="translated">该调整等效于两次使用&lt;a href=&quot;../temporal/temporal#with-java.time.temporal.TemporalField-long-&quot;&gt; &lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt; &lt;/a&gt;，并将&lt;a href=&quot;../temporal/chronofield#EPOCH_DAY&quot;&gt; &lt;code&gt;ChronoField.EPOCH_DAY&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../temporal/chronofield#NANO_OF_DAY&quot;&gt; &lt;code&gt;ChronoField.NANO_OF_DAY&lt;/code&gt; &lt;/a&gt;传递为字段。</target>
        </trans-unit>
        <trans-unit id="e44cad48b9827c5f480b34333f1a973611fd9388" translate="yes" xml:space="preserve">
          <source>The adjustment is equivalent to using &lt;a href=&quot;temporal/temporal#with-java.time.temporal.TemporalField-long-&quot;&gt;&lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt;&lt;/a&gt; passing &lt;a href=&quot;temporal/chronofield#DAY_OF_WEEK&quot;&gt;&lt;code&gt;ChronoField.DAY_OF_WEEK&lt;/code&gt;&lt;/a&gt; as the field. Note that this adjusts forwards or backwards within a Monday to Sunday week. See &lt;a href=&quot;temporal/weekfields#dayOfWeek--&quot;&gt;&lt;code&gt;WeekFields.dayOfWeek()&lt;/code&gt;&lt;/a&gt; for localized week start days. See &lt;code&gt;TemporalAdjuster&lt;/code&gt; for other adjusters with more control, such as &lt;code&gt;next(MONDAY)&lt;/code&gt;.</source>
          <target state="translated">该调整等效于使用&lt;a href=&quot;temporal/temporal#with-java.time.temporal.TemporalField-long-&quot;&gt; &lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt; &lt;/a&gt;传递&lt;a href=&quot;temporal/chronofield#DAY_OF_WEEK&quot;&gt; &lt;code&gt;ChronoField.DAY_OF_WEEK&lt;/code&gt; &lt;/a&gt;作为字段。请注意，这会在星期一至星期日的一周内向前或向后调整。有关本地化的周开始日期，请参见&lt;a href=&quot;temporal/weekfields#dayOfWeek--&quot;&gt; &lt;code&gt;WeekFields.dayOfWeek()&lt;/code&gt; &lt;/a&gt;。有关其他具有更多控制权的调节器，请参见 &lt;code&gt;TemporalAdjuster&lt;/code&gt; ，例如 &lt;code&gt;next(MONDAY)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5b611d529bc1f3d60bbf9c910262c56861a5e1e8" translate="yes" xml:space="preserve">
          <source>The adjustment is equivalent to using &lt;a href=&quot;temporal/temporal#with-java.time.temporal.TemporalField-long-&quot;&gt;&lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt;&lt;/a&gt; passing &lt;a href=&quot;temporal/chronofield#EPOCH_DAY&quot;&gt;&lt;code&gt;ChronoField.EPOCH_DAY&lt;/code&gt;&lt;/a&gt; as the field.</source>
          <target state="translated">该调整等效于使用&lt;a href=&quot;temporal/temporal#with-java.time.temporal.TemporalField-long-&quot;&gt; &lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt; &lt;/a&gt;传递&lt;a href=&quot;temporal/chronofield#EPOCH_DAY&quot;&gt; &lt;code&gt;ChronoField.EPOCH_DAY&lt;/code&gt; &lt;/a&gt;作为字段。</target>
        </trans-unit>
        <trans-unit id="257599f217c60f1b286ca03e73c123884296cb3b" translate="yes" xml:space="preserve">
          <source>The adjustment is equivalent to using &lt;a href=&quot;temporal/temporal#with-java.time.temporal.TemporalField-long-&quot;&gt;&lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt;&lt;/a&gt; passing &lt;a href=&quot;temporal/chronofield#MONTH_OF_YEAR&quot;&gt;&lt;code&gt;ChronoField.MONTH_OF_YEAR&lt;/code&gt;&lt;/a&gt; as the field. If the specified temporal object does not use the ISO calendar system then a &lt;code&gt;DateTimeException&lt;/code&gt; is thrown.</source>
          <target state="translated">该调整等效于使用&lt;a href=&quot;temporal/temporal#with-java.time.temporal.TemporalField-long-&quot;&gt; &lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt; &lt;/a&gt;传递&lt;a href=&quot;temporal/chronofield#MONTH_OF_YEAR&quot;&gt; &lt;code&gt;ChronoField.MONTH_OF_YEAR&lt;/code&gt; &lt;/a&gt;作为字段。如果指定的时态对象不使用ISO日历系统，则将引发 &lt;code&gt;DateTimeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5802986909900e31119ae14ea5be02213c50d0be" translate="yes" xml:space="preserve">
          <source>The adjustment is equivalent to using &lt;a href=&quot;temporal/temporal#with-java.time.temporal.TemporalField-long-&quot;&gt;&lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt;&lt;/a&gt; passing &lt;a href=&quot;temporal/chronofield#NANO_OF_DAY&quot;&gt;&lt;code&gt;ChronoField.NANO_OF_DAY&lt;/code&gt;&lt;/a&gt; as the field.</source>
          <target state="translated">该调整等效于使用&lt;a href=&quot;temporal/temporal#with-java.time.temporal.TemporalField-long-&quot;&gt; &lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt; &lt;/a&gt;传递&lt;a href=&quot;temporal/chronofield#NANO_OF_DAY&quot;&gt; &lt;code&gt;ChronoField.NANO_OF_DAY&lt;/code&gt; &lt;/a&gt;作为字段。</target>
        </trans-unit>
        <trans-unit id="88987ee5b08a8d2a074850d0b9773a025b06b4d1" translate="yes" xml:space="preserve">
          <source>The adjustment is equivalent to using &lt;a href=&quot;temporal/temporal#with-java.time.temporal.TemporalField-long-&quot;&gt;&lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt;&lt;/a&gt; passing &lt;a href=&quot;temporal/chronofield#OFFSET_SECONDS&quot;&gt;&lt;code&gt;ChronoField.OFFSET_SECONDS&lt;/code&gt;&lt;/a&gt; as the field.</source>
          <target state="translated">该调整等效于使用&lt;a href=&quot;temporal/temporal#with-java.time.temporal.TemporalField-long-&quot;&gt; &lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt; &lt;/a&gt;传递&lt;a href=&quot;temporal/chronofield#OFFSET_SECONDS&quot;&gt; &lt;code&gt;ChronoField.OFFSET_SECONDS&lt;/code&gt; &lt;/a&gt;作为字段。</target>
        </trans-unit>
        <trans-unit id="98164a2c75da7f81c3334e95803d9d828422a751" translate="yes" xml:space="preserve">
          <source>The adjustment is equivalent to using &lt;a href=&quot;temporal/temporal#with-java.time.temporal.TemporalField-long-&quot;&gt;&lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt;&lt;/a&gt; passing &lt;a href=&quot;temporal/chronofield#PROLEPTIC_MONTH&quot;&gt;&lt;code&gt;ChronoField.PROLEPTIC_MONTH&lt;/code&gt;&lt;/a&gt; as the field. If the specified temporal object does not use the ISO calendar system then a &lt;code&gt;DateTimeException&lt;/code&gt; is thrown.</source>
          <target state="translated">该调整等效于使用&lt;a href=&quot;temporal/temporal#with-java.time.temporal.TemporalField-long-&quot;&gt; &lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt; &lt;/a&gt;传递&lt;a href=&quot;temporal/chronofield#PROLEPTIC_MONTH&quot;&gt; &lt;code&gt;ChronoField.PROLEPTIC_MONTH&lt;/code&gt; &lt;/a&gt;作为字段。如果指定的时态对象不使用ISO日历系统，则将引发 &lt;code&gt;DateTimeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a5129d3f5b2d1ff47e62137527b8ffc36da581cf" translate="yes" xml:space="preserve">
          <source>The adjustment is equivalent to using &lt;a href=&quot;temporal/temporal#with-java.time.temporal.TemporalField-long-&quot;&gt;&lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt;&lt;/a&gt; passing &lt;a href=&quot;temporal/chronofield#YEAR&quot;&gt;&lt;code&gt;ChronoField.YEAR&lt;/code&gt;&lt;/a&gt; as the field. If the specified temporal object does not use the ISO calendar system then a &lt;code&gt;DateTimeException&lt;/code&gt; is thrown.</source>
          <target state="translated">该调整等效于使用&lt;a href=&quot;temporal/temporal#with-java.time.temporal.TemporalField-long-&quot;&gt; &lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt; &lt;/a&gt;传递&lt;a href=&quot;temporal/chronofield#YEAR&quot;&gt; &lt;code&gt;ChronoField.YEAR&lt;/code&gt; &lt;/a&gt;作为字段。如果指定的时态对象不使用ISO日历系统，则将引发 &lt;code&gt;DateTimeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f2a30a7c22625abb73e11626e5ddcf7795b8d68d" translate="yes" xml:space="preserve">
          <source>The adjustment is equivalent to using &lt;a href=&quot;temporal/temporal#with-java.time.temporal.TemporalField-long-&quot;&gt;&lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt;&lt;/a&gt; three times, passing &lt;a href=&quot;temporal/chronofield#EPOCH_DAY&quot;&gt;&lt;code&gt;ChronoField.EPOCH_DAY&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;temporal/chronofield#NANO_OF_DAY&quot;&gt;&lt;code&gt;ChronoField.NANO_OF_DAY&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;temporal/chronofield#OFFSET_SECONDS&quot;&gt;&lt;code&gt;ChronoField.OFFSET_SECONDS&lt;/code&gt;&lt;/a&gt; as the fields.</source>
          <target state="translated">该调整等效于使用&lt;a href=&quot;temporal/temporal#with-java.time.temporal.TemporalField-long-&quot;&gt; &lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt; &lt;/a&gt;三次，将&lt;a href=&quot;temporal/chronofield#EPOCH_DAY&quot;&gt; &lt;code&gt;ChronoField.EPOCH_DAY&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;temporal/chronofield#NANO_OF_DAY&quot;&gt; &lt;code&gt;ChronoField.NANO_OF_DAY&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;temporal/chronofield#OFFSET_SECONDS&quot;&gt; &lt;code&gt;ChronoField.OFFSET_SECONDS&lt;/code&gt; &lt;/a&gt;用作字段。</target>
        </trans-unit>
        <trans-unit id="e7da8868c418c745ff4cc22056878587f0c5e004" translate="yes" xml:space="preserve">
          <source>The adjustment is equivalent to using &lt;a href=&quot;temporal/temporal#with-java.time.temporal.TemporalField-long-&quot;&gt;&lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt;&lt;/a&gt; twice, passing &lt;a href=&quot;temporal/chronofield#EPOCH_DAY&quot;&gt;&lt;code&gt;ChronoField.EPOCH_DAY&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;temporal/chronofield#NANO_OF_DAY&quot;&gt;&lt;code&gt;ChronoField.NANO_OF_DAY&lt;/code&gt;&lt;/a&gt; as the fields.</source>
          <target state="translated">该调整等效于两次使用&lt;a href=&quot;temporal/temporal#with-java.time.temporal.TemporalField-long-&quot;&gt; &lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt; &lt;/a&gt;，并将&lt;a href=&quot;temporal/chronofield#EPOCH_DAY&quot;&gt; &lt;code&gt;ChronoField.EPOCH_DAY&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;temporal/chronofield#NANO_OF_DAY&quot;&gt; &lt;code&gt;ChronoField.NANO_OF_DAY&lt;/code&gt; &lt;/a&gt;传递为字段。</target>
        </trans-unit>
        <trans-unit id="fbe1b4b3b564d51f43b80e201aaa4bed1b896b23" translate="yes" xml:space="preserve">
          <source>The adjustment is equivalent to using &lt;a href=&quot;temporal/temporal#with-java.time.temporal.TemporalField-long-&quot;&gt;&lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt;&lt;/a&gt; twice, passing &lt;a href=&quot;temporal/chronofield#INSTANT_SECONDS&quot;&gt;&lt;code&gt;ChronoField.INSTANT_SECONDS&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;temporal/chronofield#NANO_OF_SECOND&quot;&gt;&lt;code&gt;ChronoField.NANO_OF_SECOND&lt;/code&gt;&lt;/a&gt; as the fields.</source>
          <target state="translated">该调整等效于两次使用&lt;a href=&quot;temporal/temporal#with-java.time.temporal.TemporalField-long-&quot;&gt; &lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt; &lt;/a&gt;，并将&lt;a href=&quot;temporal/chronofield#INSTANT_SECONDS&quot;&gt; &lt;code&gt;ChronoField.INSTANT_SECONDS&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;temporal/chronofield#NANO_OF_SECOND&quot;&gt; &lt;code&gt;ChronoField.NANO_OF_SECOND&lt;/code&gt; &lt;/a&gt;作为字段。</target>
        </trans-unit>
        <trans-unit id="5eb1c9d6c698514069a9fa5a2aefedfa05f03d19" translate="yes" xml:space="preserve">
          <source>The adjustment is equivalent to using &lt;a href=&quot;temporal/temporal#with-java.time.temporal.TemporalField-long-&quot;&gt;&lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt;&lt;/a&gt; twice, passing &lt;a href=&quot;temporal/chronofield#MONTH_OF_YEAR&quot;&gt;&lt;code&gt;ChronoField.MONTH_OF_YEAR&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;temporal/chronofield#DAY_OF_MONTH&quot;&gt;&lt;code&gt;ChronoField.DAY_OF_MONTH&lt;/code&gt;&lt;/a&gt; as the fields. If the specified temporal object does not use the ISO calendar system then a &lt;code&gt;DateTimeException&lt;/code&gt; is thrown.</source>
          <target state="translated">该调整等效于两次使用&lt;a href=&quot;temporal/temporal#with-java.time.temporal.TemporalField-long-&quot;&gt; &lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt; &lt;/a&gt;，并将&lt;a href=&quot;temporal/chronofield#MONTH_OF_YEAR&quot;&gt; &lt;code&gt;ChronoField.MONTH_OF_YEAR&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;temporal/chronofield#DAY_OF_MONTH&quot;&gt; &lt;code&gt;ChronoField.DAY_OF_MONTH&lt;/code&gt; &lt;/a&gt;用作字段。如果指定的时态对象不使用ISO日历系统，则将引发 &lt;code&gt;DateTimeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="92d2244665cb53572ff5bdf04962e104a4097d36" translate="yes" xml:space="preserve">
          <source>The adjustment is equivalent to using &lt;a href=&quot;temporal/temporal#with-java.time.temporal.TemporalField-long-&quot;&gt;&lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt;&lt;/a&gt; twice, passing &lt;a href=&quot;temporal/chronofield#NANO_OF_DAY&quot;&gt;&lt;code&gt;ChronoField.NANO_OF_DAY&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;temporal/chronofield#OFFSET_SECONDS&quot;&gt;&lt;code&gt;ChronoField.OFFSET_SECONDS&lt;/code&gt;&lt;/a&gt; as the fields.</source>
          <target state="translated">该调整等效于两次使用&lt;a href=&quot;temporal/temporal#with-java.time.temporal.TemporalField-long-&quot;&gt; &lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt; &lt;/a&gt;，并将&lt;a href=&quot;temporal/chronofield#NANO_OF_DAY&quot;&gt; &lt;code&gt;ChronoField.NANO_OF_DAY&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;temporal/chronofield#OFFSET_SECONDS&quot;&gt; &lt;code&gt;ChronoField.OFFSET_SECONDS&lt;/code&gt; &lt;/a&gt;用作字段。</target>
        </trans-unit>
        <trans-unit id="c765c5d385607a3d8763df3c64f7ac4e847c83f3" translate="yes" xml:space="preserve">
          <source>The agent should take care to ensure that the JAR does not contain any classes or resources other than those to be defined by the bootstrap class loader for the purpose of instrumentation. Failure to observe this warning could result in unexpected behavior that is difficult to diagnose. For example, suppose there is a loader L, and L's parent for delegation is the bootstrap class loader. Furthermore, a method in class C, a class defined by L, makes reference to a non-public accessor class C$1. If the JAR file contains a class C$1 then the delegation to the bootstrap class loader will cause C$1 to be defined by the bootstrap class loader. In this example an &lt;code&gt;IllegalAccessError&lt;/code&gt; will be thrown that may cause the application to fail. One approach to avoiding these types of issues, is to use a unique package name for the instrumentation classes.</source>
          <target state="translated">代理应注意确保JAR不包含除出于引导目的由引导类加载器定义的类或资源之外的任何类或资源。不遵守此警告可能会导致难以诊断的意外行为。例如，假设有一个加载程序L，并且L的委派父级是引导程序类加载程序。此外，类C（由L定义的类）中的方法引用了非公共访问器类C $ 1。如果JAR文件包含类C $ 1，则对引导类加载器的委派将导致C $ 1由引导类加载器定义。在此示例中，一个 &lt;code&gt;IllegalAccessError&lt;/code&gt; 将被抛出，可能导致应用程序失败。避免出现此类问题的一种方法是对工具类使用唯一的包名称。</target>
        </trans-unit>
        <trans-unit id="678b2dbe34d546f1b97104a1122aecca882d6d38" translate="yes" xml:space="preserve">
          <source>The agent should take care to ensure that the JAR does not contain any classes or resources other than those to be defined by the system class loader for the purpose of instrumentation. Failure to observe this warning could result in unexpected behavior that is difficult to diagnose (see &lt;a href=&quot;instrumentation#appendToBootstrapClassLoaderSearch-java.util.jar.JarFile-&quot;&gt;&lt;code&gt;appendToBootstrapClassLoaderSearch&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">代理应注意确保JAR不包含任何类或资源，而不是出于检测目的而由系统类加载器定义的类或资源。不遵守此警告可能会导致难以诊断的意外行为（请参阅&lt;a href=&quot;instrumentation#appendToBootstrapClassLoaderSearch-java.util.jar.JarFile-&quot;&gt; &lt;code&gt;appendToBootstrapClassLoaderSearch&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="546cbc1f7664aeb26e996479ae09bc8d8a9e3a69" translate="yes" xml:space="preserve">
          <source>The alert (bell) character (&lt;code&gt;'\u0007'&lt;/code&gt;)</source>
          <target state="translated">警报字符（ &lt;code&gt;'\u0007'&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="5626138a26257368698eb4794c202820b5b71ee2" translate="yes" xml:space="preserve">
          <source>The algorithm is slightly tricky. It rejects values that would result in an uneven distribution (due to the fact that 2^31 is not divisible by n). The probability of a value being rejected depends on n. The worst case is n=2^30+1, for which the probability of a reject is 1/2, and the expected number of iterations before the loop terminates is 2.</source>
          <target state="translated">该算法略显棘手。它拒绝那些会导致不均匀分布的值(由于2^31不能被n整除)。最坏的情况是n=2^30+1,拒绝的概率是1/2,循环结束前的预期迭代次数是2。</target>
        </trans-unit>
        <trans-unit id="93921a1e862ec851c3cf638cc9b61cb2cd976324" translate="yes" xml:space="preserve">
          <source>The algorithm name is determined from the &lt;code&gt;algorithm&lt;/code&gt; OID string.</source>
          <target state="translated">算法名称由 &lt;code&gt;algorithm&lt;/code&gt; OID字符串确定。</target>
        </trans-unit>
        <trans-unit id="a01ab90b6863321fb8006c5a10111bddcd7ece11" translate="yes" xml:space="preserve">
          <source>The algorithm to compute the SerialVersionUID is described in Object Serialization Specification, Section 4.6, Stream Unique Identifiers.</source>
          <target state="translated">计算SerialVersionUID的算法在《对象序列化规范》第4.6节《流唯一标识符》中描述。</target>
        </trans-unit>
        <trans-unit id="9f567977a50b87c4c64f739289bf0274a0cee555" translate="yes" xml:space="preserve">
          <source>The algorithm treats the case where n is a power of two specially: it returns the correct number of high-order bits from the underlying pseudo-random number generator. In the absence of special treatment, the correct number of</source>
          <target state="translated">该算法对n是2的幂的情况进行了特殊处理:它从底层伪随机数发生器中返回正确的高阶位数。在没有特殊处理的情况下,正确的数量为</target>
        </trans-unit>
        <trans-unit id="cfaae3f12961bc0e6e9294755ef603cdce9972b1" translate="yes" xml:space="preserve">
          <source>The algorithm used herein tests the BeanContextPeer, and its current children to determine if they are either Containers, Components, or if they implement Visibility and return needsGui() == true.</source>
          <target state="translated">这里使用的算法测试BeanContextPeer,以及它当前的子代,以确定它们是否是容器、组件,或者它们是否实现了可见性,并返回 needsGui()==true。</target>
        </trans-unit>
        <trans-unit id="6cb3e1bfb6ce2cfa6d3a5700e0fc1aa8f7b1471d" translate="yes" xml:space="preserve">
          <source>The algorithm-independent approach uses the fact that all parameter generators share the concept of a &quot;size&quot; and a source of randomness. The measure of size is universally shared by all algorithm parameters, though it is interpreted differently for different algorithms. For example, in the case of parameters for the</source>
          <target state="translated">与算法无关的方法利用了这样一个事实,即所有参数生成器都共享 &quot;大小 &quot;的概念和随机性的来源。大小的度量是所有算法参数普遍共享的,尽管对于不同的算法有不同的解释。例如,在参数生成器的情况下。</target>
        </trans-unit>
        <trans-unit id="cf8486342f66f70d87128cfd826de9b0ef988360" translate="yes" xml:space="preserve">
          <source>The algorithms implemented by class &lt;code&gt;Random&lt;/code&gt; use a &lt;code&gt;protected&lt;/code&gt; utility method that on each invocation can supply up to 32 pseudorandomly generated bits.</source>
          <target state="translated">由 &lt;code&gt;Random&lt;/code&gt; 类实现的算法使用一种 &lt;code&gt;protected&lt;/code&gt; 实用程序方法，该方法在每次调用时最多可以提供32个伪随机生成的位。</target>
        </trans-unit>
        <trans-unit id="f935ac023e4757a422d3c1d9477a8b333c5e7e8b" translate="yes" xml:space="preserve">
          <source>The aligned day-of-week within a month.</source>
          <target state="translated">一个月内对齐的周天。</target>
        </trans-unit>
        <trans-unit id="5b65ab21d464a2cd9f17e050364212fad42369dd" translate="yes" xml:space="preserve">
          <source>The aligned day-of-week within a year.</source>
          <target state="translated">一年内对齐的周天。</target>
        </trans-unit>
        <trans-unit id="8a31b06194c7afca8df2f57e58bdedb9af17f0a1" translate="yes" xml:space="preserve">
          <source>The aligned week within a month.</source>
          <target state="translated">一个月内的对齐周。</target>
        </trans-unit>
        <trans-unit id="36cc382669e126a3d83f765fd4596aa08b57e640" translate="yes" xml:space="preserve">
          <source>The aligned week within a year.</source>
          <target state="translated">一年内的对准周。</target>
        </trans-unit>
        <trans-unit id="e05b8cc0941345bc1cb1c86f03f948c5b63217be" translate="yes" xml:space="preserve">
          <source>The alphanumeric characters &quot;&lt;code&gt;a&lt;/code&gt;&quot; through &quot;&lt;code&gt;z&lt;/code&gt;&quot;, &quot;&lt;code&gt;A&lt;/code&gt;&quot; through &quot;&lt;code&gt;Z&lt;/code&gt;&quot; and &quot;&lt;code&gt;0&lt;/code&gt;&quot; through &quot;&lt;code&gt;9&lt;/code&gt;&quot; remain the same.</source>
          <target state="translated">字母数字字符&amp;ldquo; &lt;code&gt;a&lt;/code&gt; &amp;rdquo;至&amp;ldquo; &lt;code&gt;z&lt;/code&gt; &amp;rdquo;，&amp;ldquo; &lt;code&gt;A&lt;/code&gt; &amp;rdquo;至&amp;ldquo; &lt;code&gt;Z&lt;/code&gt; &amp;rdquo;以及&amp;ldquo; &lt;code&gt;0&lt;/code&gt; &amp;rdquo;至&amp;ldquo; &lt;code&gt;9&lt;/code&gt; &amp;rdquo;保持不变。</target>
        </trans-unit>
        <trans-unit id="7c0572c1c7ca3bf68a193c2c809c446abfe2afa3" translate="yes" xml:space="preserve">
          <source>The am-pm-of-day.</source>
          <target state="translated">当天的am-pm-of-day。</target>
        </trans-unit>
        <trans-unit id="74edaecf476996f8978f77b9b1cf0182dc658e02" translate="yes" xml:space="preserve">
          <source>The amount by which the capacity of the monitor arrays are automatically incremented when their size becomes greater than their capacity.</source>
          <target state="translated">当显示器阵列的大小大于其容量时,其容量自动增加的数量。</target>
        </trans-unit>
        <trans-unit id="9076e761c5f29e8f67b1371daf80d922283c4c18" translate="yes" xml:space="preserve">
          <source>The amount by which the capacity of the vector is automatically incremented when its size becomes greater than its capacity. If the capacity increment is less than or equal to zero, the capacity of the vector is doubled each time it needs to grow.</source>
          <target state="translated">当向量的大小大于其容量时,向量的容量自动增加的数量。如果容量增量小于或等于零,则每次需要增长时,矢量的容量都会增加一倍。</target>
        </trans-unit>
        <trans-unit id="f126ed1fd82891599e13c33def786ee88595c928" translate="yes" xml:space="preserve">
          <source>The amount by which the tile grid origin should be offset horizontally from the image origin if tiling has been set, or 0 otherwise. The initial value is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">如果已设置平铺，则平铺网格原点应与图像原点水平偏移的量，否则为0。初始值为 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="90dc34eb07729c8e77187523b54e04f1056c08b6" translate="yes" xml:space="preserve">
          <source>The amount by which the tile grid origin should be offset vertically from the image origin if tiling has been set, or 0 otherwise. The initial value is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">如果已设置平铺，则平铺网格原点应与图像原点垂直偏移的量，否则为0。初始值为 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f834737d8ddeb7615f0e64cb1071bcd66b90fc0e" translate="yes" xml:space="preserve">
          <source>The amount can be thought of as a &lt;code&gt;Map&lt;/code&gt; of &lt;a href=&quot;temporalunit&quot;&gt;&lt;code&gt;TemporalUnit&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;long&lt;/code&gt;, exposed via &lt;a href=&quot;temporalamount#getUnits--&quot;&gt;&lt;code&gt;getUnits()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;temporalamount#get-java.time.temporal.TemporalUnit-&quot;&gt;&lt;code&gt;get(TemporalUnit)&lt;/code&gt;&lt;/a&gt;. A simple case might have a single unit-value pair, such as &quot;6 hours&quot;. A more complex case may have multiple unit-value pairs, such as &quot;7 years, 3 months and 5 days&quot;.</source>
          <target state="translated">可以将其视为通过&lt;a href=&quot;temporalamount#getUnits--&quot;&gt; &lt;code&gt;getUnits()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;temporalamount#get-java.time.temporal.TemporalUnit-&quot;&gt; &lt;code&gt;get(TemporalUnit)&lt;/code&gt; &lt;/a&gt;公开的&lt;a href=&quot;temporalunit&quot;&gt; &lt;code&gt;TemporalUnit&lt;/code&gt; &lt;/a&gt;到 &lt;code&gt;long&lt;/code&gt; 的 &lt;code&gt;Map&lt;/code&gt; 。一个简单的案例可能只有一个单位值对，例如&amp;ldquo; 6小时&amp;rdquo;。一个更复杂的案例可能具有多个单位值对，例如&amp;ldquo; 7年，3个月和5天&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="33d418714a49c19fb47687fd2e9fa81de86a9809" translate="yes" xml:space="preserve">
          <source>The amount of used memory in the returned memory usage is the amount of memory occupied by both live objects and garbage objects that have not been collected, if any.</source>
          <target state="translated">在返回的内存使用量中,使用过的内存量是指未被收集的活对象和垃圾对象所占用的内存量,如果有的话。</target>
        </trans-unit>
        <trans-unit id="57200acee95554fe9255e1ef5f8c2757f96f708f" translate="yes" xml:space="preserve">
          <source>The angle (vertical, horizontal, angled) of each staple with respect to the document depends on the implementation which may in turn depend on the value of the attribute.</source>
          <target state="translated">每个钉书钉相对于文档的角度(垂直、水平、倾斜)取决于执行情况,而执行情况又可能取决于属性的值。</target>
        </trans-unit>
        <trans-unit id="56ebb191a856df2f8f893c582ce5c05707593b3e" translate="yes" xml:space="preserve">
          <source>The annotated type satisfies the requirements of a functional interface.</source>
          <target state="translated">注释的类型满足功能接口的要求。</target>
        </trans-unit>
        <trans-unit id="30fd00f24b91bf4b27ca9bbed8fa14682d926579" translate="yes" xml:space="preserve">
          <source>The annotation returned by this method could contain an element whose value is of type &lt;code&gt;Class&lt;/code&gt;. This value cannot be returned directly: information necessary to locate and load a class (such as the class loader to use) is not available, and the class might not be loadable at all. Attempting to read a &lt;code&gt;Class&lt;/code&gt; object by invoking the relevant method on the returned annotation will result in a &lt;a href=&quot;../type/mirroredtypeexception&quot;&gt;&lt;code&gt;MirroredTypeException&lt;/code&gt;&lt;/a&gt;, from which the corresponding &lt;a href=&quot;../type/typemirror&quot;&gt;&lt;code&gt;TypeMirror&lt;/code&gt;&lt;/a&gt; may be extracted. Similarly, attempting to read a &lt;code&gt;Class[]&lt;/code&gt;-valued element will result in a &lt;a href=&quot;../type/mirroredtypesexception&quot;&gt;&lt;code&gt;MirroredTypesException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此方法返回的注释可以包含一个值类型为 &lt;code&gt;Class&lt;/code&gt; 的元素。该值不能直接返回：定位和加载类所需的信息（例如要使用的类加载器）不可用，并且该类可能根本无法加载。尝试通过在返回的注释上调用相关方法来读取 &lt;code&gt;Class&lt;/code&gt; 对象，将导致&lt;a href=&quot;../type/mirroredtypeexception&quot;&gt; &lt;code&gt;MirroredTypeException&lt;/code&gt; &lt;/a&gt;，从中可以提取相应的&lt;a href=&quot;../type/typemirror&quot;&gt; &lt;code&gt;TypeMirror&lt;/code&gt; &lt;/a&gt;。类似地，尝试读取 &lt;code&gt;Class[]&lt;/code&gt; 值的元素将导致&lt;a href=&quot;../type/mirroredtypesexception&quot;&gt; &lt;code&gt;MirroredTypesException&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b0a49070278463b21887a752144f83b535b48961" translate="yes" xml:space="preserve">
          <source>The annotation returned by this method could contain an element whose value is of type &lt;code&gt;Class&lt;/code&gt;. This value cannot be returned directly: information necessary to locate and load a class (such as the class loader to use) is not available, and the class might not be loadable at all. Attempting to read a &lt;code&gt;Class&lt;/code&gt; object by invoking the relevant method on the returned annotation will result in a &lt;a href=&quot;type/mirroredtypeexception&quot;&gt;&lt;code&gt;MirroredTypeException&lt;/code&gt;&lt;/a&gt;, from which the corresponding &lt;a href=&quot;type/typemirror&quot;&gt;&lt;code&gt;TypeMirror&lt;/code&gt;&lt;/a&gt; may be extracted. Similarly, attempting to read a &lt;code&gt;Class[]&lt;/code&gt;-valued element will result in a &lt;a href=&quot;type/mirroredtypesexception&quot;&gt;&lt;code&gt;MirroredTypesException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此方法返回的注释可以包含一个值类型为 &lt;code&gt;Class&lt;/code&gt; 的元素。该值不能直接返回：定位和加载类所需的信息（例如要使用的类加载器）不可用，并且该类可能根本无法加载。尝试通过在返回的注释上调用相关方法来读取 &lt;code&gt;Class&lt;/code&gt; 对象，将导致&lt;a href=&quot;type/mirroredtypeexception&quot;&gt; &lt;code&gt;MirroredTypeException&lt;/code&gt; &lt;/a&gt;，从中可以提取相应的&lt;a href=&quot;type/typemirror&quot;&gt; &lt;code&gt;TypeMirror&lt;/code&gt; &lt;/a&gt;。类似地，尝试读取 &lt;code&gt;Class[]&lt;/code&gt; 值的元素将导致&lt;a href=&quot;type/mirroredtypesexception&quot;&gt; &lt;code&gt;MirroredTypesException&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1be4894a9e8c13443a271ac0ee4a590cf0278b93" translate="yes" xml:space="preserve">
          <source>The annotation shows that the first parameter of the constructor can be retrieved with the &lt;code&gt;getX()&lt;/code&gt; method and the second with the &lt;code&gt;getY()&lt;/code&gt; method. Since parameter names are not in general available at runtime, without the annotation there would be no way to know whether the parameters correspond to &lt;code&gt;getX()&lt;/code&gt; and &lt;code&gt;getY()&lt;/code&gt; or the other way around.</source>
          <target state="translated">注释显示可以使用 &lt;code&gt;getX()&lt;/code&gt; 方法检索构造函数的第一个参数，而使用 &lt;code&gt;getY()&lt;/code&gt; 方法检索第二个参数。由于参数名称通常在运行时不可用，因此如果没有注释，就无法知道参数是否对应于 &lt;code&gt;getX()&lt;/code&gt; 和 &lt;code&gt;getY()&lt;/code&gt; 或相反。</target>
        </trans-unit>
        <trans-unit id="c3e7f1b2fb83a88edaed871cf9cb4d36156ccd28" translate="yes" xml:space="preserve">
          <source>The annotation type &lt;code&gt;java.lang.annotation.Repeatable&lt;/code&gt; is used to indicate that the annotation type whose declaration it (meta-)annotates is &lt;em&gt;repeatable&lt;/em&gt;.</source>
          <target state="translated">注释类型 &lt;code&gt;java.lang.annotation.Repeatable&lt;/code&gt; 用于指示其声明（元）注释的注释类型&lt;em&gt;可重复&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="3c8eb831e645e1ed4e3178ca8da9b0533b5263c4" translate="yes" xml:space="preserve">
          <source>The annotation type &lt;code&gt;java.lang.annotation.Repeatable&lt;/code&gt; is used to indicate that the annotation type whose declaration it (meta-)annotates is &lt;em&gt;repeatable&lt;/em&gt;. The value of &lt;code&gt;@Repeatable&lt;/code&gt; indicates the &lt;em&gt;containing annotation type&lt;/em&gt; for the repeatable annotation type.</source>
          <target state="translated">注释类型 &lt;code&gt;java.lang.annotation.Repeatable&lt;/code&gt; 用于指示其声明（元）注释的注释类型&lt;em&gt;可重复&lt;/em&gt;。 &lt;code&gt;@Repeatable&lt;/code&gt; 的值表示可重复注释类型的&lt;em&gt;包含&lt;/em&gt;注释类型。</target>
        </trans-unit>
        <trans-unit id="124cefaf63ca067dbef195779acbe222323d7001" translate="yes" xml:space="preserve">
          <source>The annotations returned by this method could contain an element whose value is of type &lt;code&gt;Class&lt;/code&gt;. This value cannot be returned directly: information necessary to locate and load a class (such as the class loader to use) is not available, and the class might not be loadable at all. Attempting to read a &lt;code&gt;Class&lt;/code&gt; object by invoking the relevant method on the returned annotation will result in a &lt;a href=&quot;type/mirroredtypeexception&quot;&gt;&lt;code&gt;MirroredTypeException&lt;/code&gt;&lt;/a&gt;, from which the corresponding &lt;a href=&quot;type/typemirror&quot;&gt;&lt;code&gt;TypeMirror&lt;/code&gt;&lt;/a&gt; may be extracted. Similarly, attempting to read a &lt;code&gt;Class[]&lt;/code&gt;-valued element will result in a &lt;a href=&quot;type/mirroredtypesexception&quot;&gt;&lt;code&gt;MirroredTypesException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此方法返回的注释可以包含一个值类型为 &lt;code&gt;Class&lt;/code&gt; 的元素。该值不能直接返回：定位和加载类所需的信息（例如要使用的类加载器）不可用，并且该类可能根本无法加载。尝试通过在返回的注释上调用相关方法来读取 &lt;code&gt;Class&lt;/code&gt; 对象，将导致&lt;a href=&quot;type/mirroredtypeexception&quot;&gt; &lt;code&gt;MirroredTypeException&lt;/code&gt; &lt;/a&gt;，从中可以提取相应的&lt;a href=&quot;type/typemirror&quot;&gt; &lt;code&gt;TypeMirror&lt;/code&gt; &lt;/a&gt;。类似地，尝试读取 &lt;code&gt;Class[]&lt;/code&gt; 值的元素将导致&lt;a href=&quot;type/mirroredtypesexception&quot;&gt; &lt;code&gt;MirroredTypesException&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d0e7f0049df502b987281c3346589bd6cffbab2b" translate="yes" xml:space="preserve">
          <source>The application is responsible for reliably obtaining the network data from the peer, and for invoking unwrap() on the data in the order it was received. The application must properly synchronize multiple calls to this method.</source>
          <target state="translated">应用程序负责从对等体可靠地获取网络数据,并按照收到数据的顺序对数据调用unwrap()。应用程序必须正确地同步对该方法的多次调用。</target>
        </trans-unit>
        <trans-unit id="9a9de3f971900bc689d7e04c1be8704459fc234c" translate="yes" xml:space="preserve">
          <source>The application is responsible for reliably transporting the network data to the peer, and for ensuring that data created by multiple calls to wrap() is transported in the same order in which it was generated. The application must properly synchronize multiple calls to this method.</source>
          <target state="translated">应用程序负责将网络数据可靠地传输到对等体,并确保多次调用wrap()所创建的数据以其生成的相同顺序进行传输。应用程序必须正确同步对该方法的多次调用。</target>
        </trans-unit>
        <trans-unit id="430098f5fdc52060873446cbe704ed4ec2f907a5" translate="yes" xml:space="preserve">
          <source>The application resource files (&lt;code&gt;jndi.properties&lt;/code&gt;).</source>
          <target state="translated">应用程序资源文件（ &lt;code&gt;jndi.properties&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="e17b5b526cb20504035514498f620be9bcb8a571" translate="yes" xml:space="preserve">
          <source>The application should retain its own reference to the Logger object to avoid it being garbage collected. The LogManager may only retain a weak reference.</source>
          <target state="translated">应用程序应该保留自己对Logger对象的引用,以避免其被垃圾回收。日志管理器只能保留一个弱引用。</target>
        </trans-unit>
        <trans-unit id="3fcee94e7e9528705654f860965116639d53c580" translate="yes" xml:space="preserve">
          <source>The approximate index in the pattern of the error, or &lt;code&gt;-1&lt;/code&gt; if the index is not known</source>
          <target state="translated">错误模式中的近似索引；如果索引未知，则为 &lt;code&gt;-1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d18258b8a09318c0fe716980f2513c6b7d689eb8" translate="yes" xml:space="preserve">
          <source>The argument becomes the current set of system properties for use by the &lt;a href=&quot;system#getProperty-java.lang.String-&quot;&gt;&lt;code&gt;getProperty(String)&lt;/code&gt;&lt;/a&gt; method. If the argument is &lt;code&gt;null&lt;/code&gt;, then the current set of system properties is forgotten.</source>
          <target state="translated">该参数成为&lt;a href=&quot;system#getProperty-java.lang.String-&quot;&gt; &lt;code&gt;getProperty(String)&lt;/code&gt; &lt;/a&gt;方法使用的当前系统属性集。如果参数为 &lt;code&gt;null&lt;/code&gt; ，则将忘记当前的系统属性集。</target>
        </trans-unit>
        <trans-unit id="3eda6b061d52f9633b11dd4adf55839255cf403b" translate="yes" xml:space="preserve">
          <source>The argument index is a decimal integer indicating the position of the argument in the argument list. The first argument is referenced by &quot;&lt;code&gt;1$&lt;/code&gt;&quot;, the second by &quot;&lt;code&gt;2$&lt;/code&gt;&quot;, etc.</source>
          <target state="translated">参数索引是一个十进制整数，指示参数在参数列表中的位置。第一个参数由&amp;ldquo; &lt;code&gt;1$&lt;/code&gt; &amp;rdquo; 引用，第二个参数由&amp;ldquo; &lt;code&gt;2$&lt;/code&gt; &amp;rdquo; 引用，依此类推。</target>
        </trans-unit>
        <trans-unit id="99ae0b95c82d7e5d456a4b05f7772782c73566c3" translate="yes" xml:space="preserve">
          <source>The argument is appended to the contents of this sequence. The length of this sequence increases by &lt;a href=&quot;character#charCount-int-&quot;&gt;&lt;code&gt;Character.charCount(codePoint)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">参数将附加到此序列的内容中。此序列的长度增加&lt;a href=&quot;character#charCount-int-&quot;&gt; &lt;code&gt;Character.charCount(codePoint)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="530578e360d335fe358bf50135b12bdaa9833c94" translate="yes" xml:space="preserve">
          <source>The argument is appended to the contents of this sequence. The length of this sequence increases by &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">参数将附加到此序列的内容中。该序列的长度增加 &lt;code&gt;1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2f6d8165e4787ec54c7633c17f8460e647d868e0" translate="yes" xml:space="preserve">
          <source>The argument list for this method includes three fixed parameters, corresponding to the parameters automatically stacked by the VM for the bootstrap method in an &lt;code&gt;invokedynamic&lt;/code&gt; invocation, and an &lt;code&gt;Object[]&lt;/code&gt; parameter that contains additional parameters. The declared argument list for this method is:</source>
          <target state="translated">该方法的参数列表包括三个固定参数，对应于由VM自举方法在一个自动堆叠在参数 &lt;code&gt;invokedynamic&lt;/code&gt; 调用，和一个 &lt;code&gt;Object[]&lt;/code&gt; 包含额外参数的参数。此方法的声明参数列表为：</target>
        </trans-unit>
        <trans-unit id="5fb9985f7d13d4b1f9cd222839ca8db9be97981a" translate="yes" xml:space="preserve">
          <source>The argument list of the implementation method and the argument list of the interface method(s) may differ in several ways. The implementation methods may have additional arguments to accommodate arguments captured by the lambda expression; there may also be differences resulting from permitted adaptations of arguments, such as casting, boxing, unboxing, and primitive widening. (Varargs adaptations are not handled by the metafactories; these are expected to be handled by the caller.)</source>
          <target state="translated">实现方法的参数列表和接口方法的参数列表可能在几个方面有所不同。实现方法可能会有额外的参数来容纳lambda表达式所捕获的参数;也可能会因为允许的参数适配而产生差异,比如铸造、装箱、拆箱和基元扩容。(Varargs的适配不由元工厂处理;这些应该由调用者处理。)</target>
        </trans-unit>
        <trans-unit id="dba085c7b50d6043549c3ebae9230f8d1dc02715" translate="yes" xml:space="preserve">
          <source>The argument string may consist of either a level name or an integer value.</source>
          <target state="translated">参数字符串可以由级别名称或整数值组成。</target>
        </trans-unit>
        <trans-unit id="a409707495e7aa4d57fd8347009cb66d93f0721f" translate="yes" xml:space="preserve">
          <source>The argument types (if any) of the filter replace zero or one argument types of the target, at position &lt;code&gt;pos&lt;/code&gt;, in the resulting adapted method handle. The return type of the filter (if any) must be identical to the argument type of the target at position &lt;code&gt;pos&lt;/code&gt;, and that target argument is supplied by the return value of the filter.</source>
          <target state="translated">过滤器的参数类型（如果有）在目标 &lt;code&gt;pos&lt;/code&gt; 处替换目标对象的零个或一个参数类型，以适应结果的方法句柄。过滤器的返回类型（如果有）必须与位置 &lt;code&gt;pos&lt;/code&gt; 上目标的参数类型相同，并且该目标参数由过滤器的返回值提供。</target>
        </trans-unit>
        <trans-unit id="c7a1affcb922dffb08b9bc26f38f2fcd2ff544f2" translate="yes" xml:space="preserve">
          <source>The arguments to this method provide the state of the phaser prevailing for the current transition. The effects of invoking arrival, registration, and waiting methods on this phaser from within &lt;code&gt;onAdvance&lt;/code&gt; are unspecified and should not be relied on.</source>
          <target state="translated">此方法的参数提供了当前过渡中普遍使用的移相器状态。未指定从 &lt;code&gt;onAdvance&lt;/code&gt; 调用此相位器的到达，注册和等待方法的效果，因此不应依赖此效果。</target>
        </trans-unit>
        <trans-unit id="6a5780e32ca901cbb32b194668ffd8aed9709eb9" translate="yes" xml:space="preserve">
          <source>The arguments' type in the argument list should be a Java primitive type or a Java basic type (&lt;code&gt;java.lang.Boolean, java.lang.Byte, java.lang.Short, java.lang.Long, java.lang.Integer, java.lang.Float, java.lang.Double, java.lang.String&lt;/code&gt;).</source>
          <target state="translated">参数列表中的参数类型应为Java基本类型或Java基本类型（ &lt;code&gt;java.lang.Boolean, java.lang.Byte, java.lang.Short, java.lang.Long, java.lang.Integer, java.lang.Float, java.lang.Double, java.lang.String&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="e3eff702de68d57af015cf4b99e531b32b5ea13c" translate="yes" xml:space="preserve">
          <source>The arithmetic mean of values, or zero if none</source>
          <target state="translated">数值的算术平均值,如果没有,则为零。</target>
        </trans-unit>
        <trans-unit id="e46894470d324ef2c838dfa52d4db4c7490f2a91" translate="yes" xml:space="preserve">
          <source>The array buffer into which the components of the vector are stored. The capacity of the vector is the length of this array buffer, and is at least large enough to contain all the vector's elements.</source>
          <target state="translated">存储向量元素的数组缓冲区。向量的容量是这个数组缓冲区的长度,至少要大到足以容纳向量的所有元素。</target>
        </trans-unit>
        <trans-unit id="df96b8a4607fb626cc5f918559d4d97edf1931c5" translate="yes" xml:space="preserve">
          <source>The array of &lt;code&gt;Package&lt;/code&gt; objects defined by this &lt;code&gt;ClassLoader&lt;/code&gt;</source>
          <target state="translated">此 &lt;code&gt;ClassLoader&lt;/code&gt; 定义的 &lt;code&gt;Package&lt;/code&gt; 对象的数组</target>
        </trans-unit>
        <trans-unit id="705218ba2f4229324522ac940a920cb455e867d6" translate="yes" xml:space="preserve">
          <source>The array of attributes that were set, with their new values in Attribute instances.</source>
          <target state="translated">被设置的属性数组,其在属性实例中的新值。</target>
        </trans-unit>
        <trans-unit id="ece62f0c726122c250dc236e28fb201902c1b37c" translate="yes" xml:space="preserve">
          <source>The array of notification types returned by &lt;a href=&quot;mbeaninfo#getNotifications--&quot;&gt;&lt;code&gt;MBeanInfo.getNotifications()&lt;/code&gt;&lt;/a&gt; for an MXBean that is directly registered in the MBean Server will be empty if the MXBean does not implement the &lt;a href=&quot;notificationbroadcaster&quot;&gt;&lt;code&gt;NotificationBroadcaster&lt;/code&gt;&lt;/a&gt; interface. Otherwise, it will be the result of calling &lt;a href=&quot;notificationbroadcaster#getNotificationInfo--&quot;&gt;&lt;code&gt;NotificationBroadcaster.getNotificationInfo()&lt;/code&gt;&lt;/a&gt; at the time the MXBean was registered. Even if the result of this method changes subsequently, the result of &lt;code&gt;MBeanInfo.getNotifications()&lt;/code&gt; will not. The list returned for an MXBean that is constructed using the &lt;a href=&quot;standardmbean&quot;&gt;&lt;code&gt;StandardMBean&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;standardemittermbean&quot;&gt;&lt;code&gt;StandardEmitterMBean&lt;/code&gt;&lt;/a&gt; class is derived in the same way as for Standard MBeans.</source>
          <target state="translated">如果MXBean未实现&lt;a href=&quot;notificationbroadcaster&quot;&gt; &lt;code&gt;NotificationBroadcaster&lt;/code&gt; &lt;/a&gt;接口，则&lt;a href=&quot;mbeaninfo#getNotifications--&quot;&gt; &lt;code&gt;MBeanInfo.getNotifications()&lt;/code&gt; &lt;/a&gt;返回的，直接在MBean服务器中注册的MXBean 的通知类型数组将为空。否则，将是在注册MXBean时调用&lt;a href=&quot;notificationbroadcaster#getNotificationInfo--&quot;&gt; &lt;code&gt;NotificationBroadcaster.getNotificationInfo()&lt;/code&gt; &lt;/a&gt;的结果。即使此方法的结果随后更改， &lt;code&gt;MBeanInfo.getNotifications()&lt;/code&gt; 的结果也不会改变。使用&lt;a href=&quot;standardmbean&quot;&gt; &lt;code&gt;StandardMBean&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;standardemittermbean&quot;&gt; &lt;code&gt;StandardEmitterMBean&lt;/code&gt; &lt;/a&gt;类构造的MXBean返回的列表以与标准MBean相同的方式派生。</target>
        </trans-unit>
        <trans-unit id="8033f974991351ace5422d567e6168d796751594" translate="yes" xml:space="preserve">
          <source>The array of package names that will be searched in order to find BeanInfo classes. The default value for this array is implementation-dependent; e.g. Sun implementation initially sets to {&quot;sun.beans.infos&quot;}.</source>
          <target state="translated">为了查找BeanInfo类而要搜索的包名数组。这个数组的默认值取决于实现,例如,Sun的实现最初设置为{&quot;sun.beans.infos&quot;}。</target>
        </trans-unit>
        <trans-unit id="ea0e9468c9d76c117ad93cb29d44a9ac61c3edbb" translate="yes" xml:space="preserve">
          <source>The array of package names that will be searched in order to find property editors.</source>
          <target state="translated">为了寻找属性编辑器而搜索的包名数组。</target>
        </trans-unit>
        <trans-unit id="928ffa64af02531e697e049765f39cfb4189454d" translate="yes" xml:space="preserve">
          <source>The array of public constructors returned by &lt;a href=&quot;mbeaninfo#getConstructors--&quot;&gt;&lt;code&gt;MBeanInfo.getConstructors()&lt;/code&gt;&lt;/a&gt; for an MXBean that is directly registered in the MBean Server will contain all of the public constructors of that MXBean. If the class of the MXBean is not public then its constructors are not considered public either. The list returned for an MXBean that is constructed using the &lt;a href=&quot;standardmbean&quot;&gt;&lt;code&gt;StandardMBean&lt;/code&gt;&lt;/a&gt; class is derived in the same way as for Standard MBeans. Regardless of how the MXBean was constructed, its constructor parameters are not subject to MXBean mapping rules and do not have a corresponding &lt;code&gt;OpenType&lt;/code&gt;.</source>
          <target state="translated">由&lt;a href=&quot;mbeaninfo#getConstructors--&quot;&gt; &lt;code&gt;MBeanInfo.getConstructors()&lt;/code&gt; &lt;/a&gt;返回的，直接在MBean服务器中注册的MXBean 的公共构造函数的数组将包含该MXBean的所有公共构造函数。如果MXBean的类不是公共的，则其构造函数也不被视为公共的。使用&lt;a href=&quot;standardmbean&quot;&gt; &lt;code&gt;StandardMBean&lt;/code&gt; &lt;/a&gt;类构造的MXBean返回的列表的导出方式与标准MBean相同。无论MXBean的构造方式如何，其构造函数参数均不受MXBean映射规则的约束，并且没有相应的 &lt;code&gt;OpenType&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="db434f017939a212924ae8b2ae76ae4c1e7e5572" translate="yes" xml:space="preserve">
          <source>The array of strings computed by splitting the input around matches of this pattern</source>
          <target state="translated">通过将输入的字符串分割成与此模式匹配的字符串数组来计算。</target>
        </trans-unit>
        <trans-unit id="21e99c99c3f91ab24ab86736735d1d0c34a806e4" translate="yes" xml:space="preserve">
          <source>The array of the retrieved attributes.</source>
          <target state="translated">检索到的属性数组。</target>
        </trans-unit>
        <trans-unit id="d4bac7b4df1de55c6f27580125aa0401038db85c" translate="yes" xml:space="preserve">
          <source>The array returned by &lt;a href=&quot;standardemittermbean#getNotificationInfo--&quot;&gt;&lt;code&gt;getNotificationInfo()&lt;/code&gt;&lt;/a&gt; on the new MBean is a copy of the array returned by &lt;code&gt;emitter.&lt;/code&gt;&lt;a href=&quot;notificationbroadcaster#getNotificationInfo--&quot;&gt;&lt;code&gt;getNotificationInfo()&lt;/code&gt;&lt;/a&gt; at the time of construction. If the array returned by &lt;code&gt;emitter.getNotificationInfo()&lt;/code&gt; later changes, that will have no effect on this object's &lt;code&gt;getNotificationInfo()&lt;/code&gt;.</source>
          <target state="translated">由返回的数组&lt;a href=&quot;standardemittermbean#getNotificationInfo--&quot;&gt; &lt;code&gt;getNotificationInfo()&lt;/code&gt; &lt;/a&gt;上的新MBean是由返回的数组的一个副本 &lt;code&gt;emitter.&lt;/code&gt; 构造时的&lt;a href=&quot;notificationbroadcaster#getNotificationInfo--&quot;&gt; &lt;code&gt;getNotificationInfo()&lt;/code&gt; &lt;/a&gt;。如果以后由 &lt;code&gt;emitter.getNotificationInfo()&lt;/code&gt; 返回的数组发生更改，则对此对象的 &lt;code&gt;getNotificationInfo()&lt;/code&gt; 无效。</target>
        </trans-unit>
        <trans-unit id="e92705f378bd923a26c73b7355c18555646036fe" translate="yes" xml:space="preserve">
          <source>The array returned by this method contains each substring of the input sequence that is terminated by another subsequence that matches this pattern or is terminated by the end of the input sequence. The substrings in the array are in the order in which they occur in the input. If this pattern does not match any subsequence of the input then the resulting array has just one element, namely the input sequence in string form.</source>
          <target state="translated">本方法返回的数组包含输入序列的每个子串,这些子串被另一个与此模式相匹配的子序列终止,或者被输入序列的末端终止。数组中的子串按照它们在输入中出现的顺序排列。如果这个模式不匹配输入的任何子序列,那么得到的数组只有一个元素,即字符串形式的输入序列。</target>
        </trans-unit>
        <trans-unit id="f71572fbf727c562642b1ff0c2f9fbfecd555f50" translate="yes" xml:space="preserve">
          <source>The array returned by this method contains each substring of this string that is terminated by another substring that matches the given expression or is terminated by the end of the string. The substrings in the array are in the order in which they occur in this string. If the expression does not match any part of the input then the resulting array has just one element, namely this string.</source>
          <target state="translated">本方法返回的数组包含了这个字符串的每个子串,这些子串被另一个与给定表达式相匹配的子串终止,或者被字符串的结尾终止。数组中的子串按照它们在这个字符串中出现的顺序排列。如果表达式不匹配输入的任何部分,那么产生的数组只有一个元素,即这个字符串。</target>
        </trans-unit>
        <trans-unit id="fd8e2a59c6f597467816fcfb0a55337513d7ca3b" translate="yes" xml:space="preserve">
          <source>The array returned by this method should not include two or more &lt;code&gt;Locale&lt;/code&gt; objects only differing in their extensions.</source>
          <target state="translated">此方法返回的数组不应包括两个或多个仅在扩展方面有所不同的 &lt;code&gt;Locale&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="127b2b126ce707a25ed2dfc831df19ca1f0f57ef" translate="yes" xml:space="preserve">
          <source>The array that backs this buffer</source>
          <target state="translated">支持这个缓冲区的数组</target>
        </trans-unit>
        <trans-unit id="55ad773221907d42c4b5de9996c45dad816d6669" translate="yes" xml:space="preserve">
          <source>The associated &lt;code&gt;Bindings&lt;/code&gt;. Returns &lt;code&gt;null&lt;/code&gt; if it has not been set.</source>
          <target state="translated">关联的 &lt;code&gt;Bindings&lt;/code&gt; 。如果尚未设置，则返回 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="17debbc5f42393fd96f9ca2904b4a3088a73d0b0" translate="yes" xml:space="preserve">
          <source>The associativity constraint says that splitting the computation must produce an equivalent result. That is, for any input elements &lt;code&gt;t1&lt;/code&gt; and &lt;code&gt;t2&lt;/code&gt;, the results &lt;code&gt;r1&lt;/code&gt; and &lt;code&gt;r2&lt;/code&gt; in the computation below must be equivalent:</source>
          <target state="translated">关联性约束表明，拆分计算必须产生等效的结果。也就是说，对于任何输入元素 &lt;code&gt;t1&lt;/code&gt; 和 &lt;code&gt;t2&lt;/code&gt; ，以下计算中的结果 &lt;code&gt;r1&lt;/code&gt; 和 &lt;code&gt;r2&lt;/code&gt; 必须相等：</target>
        </trans-unit>
        <trans-unit id="67ec3ad0e3e68650ab013d136deb39b2f3be1878" translate="yes" xml:space="preserve">
          <source>The asynchronous channels defined in this package allow a completion handler to be specified to consume the result of an asynchronous operation. The &lt;a href=&quot;completionhandler#completed-V-A-&quot;&gt;&lt;code&gt;completed&lt;/code&gt;&lt;/a&gt; method is invoked when the I/O operation completes successfully. The &lt;a href=&quot;completionhandler#failed-java.lang.Throwable-A-&quot;&gt;&lt;code&gt;failed&lt;/code&gt;&lt;/a&gt; method is invoked if the I/O operations fails. The implementations of these methods should complete in a timely manner so as to avoid keeping the invoking thread from dispatching to other completion handlers.</source>
          <target state="translated">此程序包中定义的异步通道允许指定完成处理程序以使用异步操作的结果。在&lt;a href=&quot;completionhandler#completed-V-A-&quot;&gt; &lt;code&gt;completed&lt;/code&gt; &lt;/a&gt;时，I / O操作成功完成方法被调用。的&lt;a href=&quot;completionhandler#failed-java.lang.Throwable-A-&quot;&gt; &lt;code&gt;failed&lt;/code&gt; &lt;/a&gt;，如果I / O操作失败的方法被调用。这些方法的实现应及时完成，以避免避免将调用线程分派到其他完成处理程序。</target>
        </trans-unit>
        <trans-unit id="c2643efcacf971e061ea507c97d7776dc8feca47" translate="yes" xml:space="preserve">
          <source>The atomic classes also support method &lt;code&gt;weakCompareAndSet&lt;/code&gt;, which has limited applicability. On some platforms, the weak version may be more efficient than &lt;code&gt;compareAndSet&lt;/code&gt; in the normal case, but differs in that any given invocation of the &lt;code&gt;weakCompareAndSet&lt;/code&gt; method may return &lt;code&gt;false&lt;/code&gt;&lt;em&gt;spuriously&lt;/em&gt; (that is, for no apparent reason). A &lt;code&gt;false&lt;/code&gt; return means only that the operation may be retried if desired, relying on the guarantee that repeated invocation when the variable holds &lt;code&gt;expectedValue&lt;/code&gt; and no other thread is also attempting to set the variable will eventually succeed. (Such spurious failures may for example be due to memory contention effects that are unrelated to whether the expected and current values are equal.) Additionally &lt;code&gt;weakCompareAndSet&lt;/code&gt; does not provide ordering guarantees that are usually needed for synchronization control. However, the method may be useful for updating counters and statistics when such updates are unrelated to the other happens-before orderings of a program. When a thread sees an update to an atomic variable caused by a &lt;code&gt;weakCompareAndSet&lt;/code&gt;, it does not necessarily see updates to any &lt;em&gt;other&lt;/em&gt; variables that occurred before the &lt;code&gt;weakCompareAndSet&lt;/code&gt;. This may be acceptable when, for example, updating performance statistics, but rarely otherwise.</source>
          <target state="translated">原子类还支持方法 &lt;code&gt;weakCompareAndSet&lt;/code&gt; ，该方法的适用性有限。在某些平台上，所述弱版本可以比更有效 &lt;code&gt;compareAndSet&lt;/code&gt; 在正常情况下，但在该任何给定调用不同 &lt;code&gt;weakCompareAndSet&lt;/code&gt; 方法可返回 &lt;code&gt;false&lt;/code&gt; &lt;em&gt;虚假&lt;/em&gt;（即，没有明显的原因）。甲 &lt;code&gt;false&lt;/code&gt; 返回装置只有，如果需要，操作可以被重试，依靠的是重复调用当变量保持保证 &lt;code&gt;expectedValue&lt;/code&gt; 并且没有其他线程也在尝试设置该变量，最终将成功。 （例如，此类虚假故障可能是由于与预期值和当前值是否相等无关的内存争用效应引起的。）此外， &lt;code&gt;weakCompareAndSet&lt;/code&gt; 不提供同步控制通常需要的排序保证。但是，当此类更新与程序的其他发生之前无关时，该方法对于更新计数器和统计信息可能有用。当线程看到由 &lt;code&gt;weakCompareAndSet&lt;/code&gt; 引起的对原子变量的更新时，它不一定会看到对 &lt;code&gt;weakCompareAndSet&lt;/code&gt; 之前发生的任何&lt;em&gt;其他&lt;/em&gt;变量的更新。。例如，在更新性能统计信息时，这可能是可以接受的，但是很少。</target>
        </trans-unit>
        <trans-unit id="ac4d2ba6afc8f8ee440138a683ef1064620a944b" translate="yes" xml:space="preserve">
          <source>The attribute being observed.</source>
          <target state="translated">被观察的属性。</target>
        </trans-unit>
        <trans-unit id="ae483aeff395b3de4d450d6d9ace753544821cfa" translate="yes" xml:space="preserve">
          <source>The attribute classes in package javax.print.attribute.standard are based on the Internet Printing Protocol (IPP) attributes as defined in the Internet RFC document,</source>
          <target state="translated">包javax.print.attribute.standard中的属性类是基于Internet RFC文档中定义的Internet打印协议(IPP)属性。</target>
        </trans-unit>
        <trans-unit id="e05558897f0a001d5208b09a07d6aa1c98e2cd44" translate="yes" xml:space="preserve">
          <source>The attribute identified by attrID; null if not found.</source>
          <target state="translated">attrID标识的属性;如果没有找到,则为空。</target>
        </trans-unit>
        <trans-unit id="14f0f29c3610d7bdbde3a9395cb830c538b88095" translate="yes" xml:space="preserve">
          <source>The attribute information returned by &lt;a href=&quot;../mbeaninfo#getAttributes--&quot;&gt;&lt;code&gt;MBeanInfo.getAttributes&lt;/code&gt;&lt;/a&gt; for an Open MBean is an array of objects implementing &lt;a href=&quot;openmbeanattributeinfo&quot;&gt;&lt;code&gt;OpenMBeanAttributeInfo&lt;/code&gt;&lt;/a&gt;, usually instances of &lt;a href=&quot;openmbeanattributeinfosupport&quot;&gt;&lt;code&gt;OpenMBeanAttributeInfoSupport&lt;/code&gt;&lt;/a&gt;. In addition to the usual information about attributes, an &lt;code&gt;OpenMBeanAttributeInfo&lt;/code&gt; specifies the &lt;a href=&quot;opentype&quot;&gt;&lt;code&gt;OpenType&lt;/code&gt;&lt;/a&gt; of the attribute. The possible &lt;code&gt;OpenType&lt;/code&gt; values are predefined, which is what ensures that remote managers will understand them.</source>
          <target state="translated">由&lt;a href=&quot;../mbeaninfo#getAttributes--&quot;&gt; &lt;code&gt;MBeanInfo.getAttributes&lt;/code&gt; &lt;/a&gt;返回的Open MBean 的属性信息是实现&lt;a href=&quot;openmbeanattributeinfo&quot;&gt; &lt;code&gt;OpenMBeanAttributeInfo&lt;/code&gt; &lt;/a&gt;的对象数组，通常是&lt;a href=&quot;openmbeanattributeinfosupport&quot;&gt; &lt;code&gt;OpenMBeanAttributeInfoSupport&lt;/code&gt; 的&lt;/a&gt;实例。除了有关属性的常规信息之外， &lt;code&gt;OpenMBeanAttributeInfo&lt;/code&gt; 还指定属性的&lt;a href=&quot;opentype&quot;&gt; &lt;code&gt;OpenType&lt;/code&gt; &lt;/a&gt;。可能的 &lt;code&gt;OpenType&lt;/code&gt; 值是预定义的，这可以确保远程管理器能够理解它们。</target>
        </trans-unit>
        <trans-unit id="1a34ae87a4441eaa7165be74012804b6e6e4684c" translate="yes" xml:space="preserve">
          <source>The attribute is not described in terms of the distance from the edge of the paper, in part to emphasise that this attribute is not independent of a particular media, but must be described within the context of a choice of other attributes. Additionally it is usually more convenient for a client to use the printable area.</source>
          <target state="translated">该属性不以距离纸张边缘的距离来描述,部分原因是为了强调该属性并不独立于某一特定介质,而是必须在选择其他属性的情况下进行描述。此外,客户使用可打印区域通常更方便。</target>
        </trans-unit>
        <trans-unit id="9468efb616ab2d3e6fc89d10bca6b8e41e4686d0" translate="yes" xml:space="preserve">
          <source>The attribute name</source>
          <target state="translated">属性名称</target>
        </trans-unit>
        <trans-unit id="982ed456989e65fdd484ae4e5cc16efdb533dab0" translate="yes" xml:space="preserve">
          <source>The attribute name-value mappings.</source>
          <target state="translated">属性名-值的映射。</target>
        </trans-unit>
        <trans-unit id="0e520d7f76b80d19d6afab265e6113914f902be7" translate="yes" xml:space="preserve">
          <source>The attribute or its value usually do no longer apply if the underlying text is changed.</source>
          <target state="translated">如果基础文本发生变化,该属性或其值通常不再适用。</target>
        </trans-unit>
        <trans-unit id="6f0189c1a4a9f3d326e775b5da3b0b10bb82b286" translate="yes" xml:space="preserve">
          <source>The attribute type and value pairs of the RDNs are lined up against each other and compared lexicographically. The order of components in multi-valued Rdns (such as &quot;ou=Sales+cn=Bob&quot;) is not significant.</source>
          <target state="translated">RDNs的属性类型和值对相互排队,并进行词法上的比较。多值Rdns中成分的顺序(如 &quot;ou=Sales+cn=Bob&quot;)并不重要。</target>
        </trans-unit>
        <trans-unit id="6d2a41c58f84b983c4307e184fcf2882ccbdc7cf" translate="yes" xml:space="preserve">
          <source>The attribute value</source>
          <target state="translated">属性值</target>
        </trans-unit>
        <trans-unit id="1dd4ad63a087a507070b2c6d348bcb8ed887c556" translate="yes" xml:space="preserve">
          <source>The attribute value in the given attribute category contained in this attribute set, or &lt;code&gt;null&lt;/code&gt; if this attribute set does not contain any attribute value in the given attribute category.</source>
          <target state="translated">在给定的属性类别中的属性值包含在此属性集，或者 &lt;code&gt;null&lt;/code&gt; ，如果此属性集不包含给定的属性类别中的任何属性值。</target>
        </trans-unit>
        <trans-unit id="bd99275c284235d7cf7a419987d70ea2029d7722" translate="yes" xml:space="preserve">
          <source>The attribute's syntax definition. Null if the implementation supports schemas but this particular attribute does not have any schema information.</source>
          <target state="translated">属性的语法定义。如果实现支持模式,但这个特定属性没有任何模式信息,则为空。</target>
        </trans-unit>
        <trans-unit id="3b4fb6a472a0a1c0664b9c45a0e5bd747e2f2099" translate="yes" xml:space="preserve">
          <source>The attributes for this connector server.</source>
          <target state="translated">该连接器服务器的属性。</target>
        </trans-unit>
        <trans-unit id="96a7dc35d5c6ff09c07ad1bfd51ce24fab766779" translate="yes" xml:space="preserve">
          <source>The attributes/value from the underlying &lt;code&gt;Format&lt;/code&gt; instances that &lt;code&gt;MessageFormat&lt;/code&gt; uses will also be placed in the resulting &lt;code&gt;AttributedCharacterIterator&lt;/code&gt;. This allows you to not only find where an argument is placed in the resulting String, but also which fields it contains in turn.</source>
          <target state="translated">&lt;code&gt;MessageFormat&lt;/code&gt; 使用的基础 &lt;code&gt;Format&lt;/code&gt; 实例的属性/值也将放置在结果 &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; 中。这样，您不仅可以找到参数在结果String中的放置位置，还可以依次找到参数中包含的字段。</target>
        </trans-unit>
        <trans-unit id="c6c9bdf9ddd1d7bebd18e501edcfe1c5e07915f2" translate="yes" xml:space="preserve">
          <source>The audio encoding technique used by this format.</source>
          <target state="translated">这种格式使用的音频编码技术。</target>
        </trans-unit>
        <trans-unit id="3ee0fa3c0794117f8475306ae21eb1f01db34317" translate="yes" xml:space="preserve">
          <source>The authentication id to check.</source>
          <target state="translated">要检查的认证ID。</target>
        </trans-unit>
        <trans-unit id="b4dbd2e0b17a4fa9c9109e46037e682fe9637ca2" translate="yes" xml:space="preserve">
          <source>The authentication type is determined by the actual certificate used. For instance, if RSAPublicKey is used, the authType should be &quot;RSA&quot;. Checking is case-sensitive.</source>
          <target state="translated">认证类型由实际使用的证书决定。例如,如果使用的是RSAPublicKey,那么authType应该是 &quot;RSA&quot;。校验是区分大小写的。</target>
        </trans-unit>
        <trans-unit id="40ca0bf39b10369e774c84090c9b0218a501eccc" translate="yes" xml:space="preserve">
          <source>The authentication type is the key exchange algorithm portion of the cipher suites represented as a String, such as &quot;RSA&quot;, &quot;DHE_DSS&quot;. Note: for some exportable cipher suites, the key exchange algorithm is determined at run time during the handshake. For instance, for TLS_RSA_EXPORT_WITH_RC4_40_MD5, the authType should be RSA_EXPORT when an ephemeral RSA key is used for the key exchange, and RSA when the key from the server certificate is used. Checking is case-sensitive.</source>
          <target state="translated">认证类型是用字符串表示的密码套件的密钥交换算法部分,如 &quot;RSA&quot;、&quot;DHE_DSS&quot;。注意:对于一些可导出的密码套件,密钥交换算法是在运行时握手时确定的。例如,对于 TLS_RSA_EXPORT_WITH_RC4_40_MD5,当密钥交换使用了短暂的 RSA 密钥时,authType 应该是 RSA_EXPORT,当使用服务器证书中的密钥时,authType 应该是 RSA。检查是区分大小写的。</target>
        </trans-unit>
        <trans-unit id="da52d0384721ee0710abc385996af9e46a62ac13" translate="yes" xml:space="preserve">
          <source>The authentication type to use for this resource. This may be specified for resources representing a connection factory of any supported type, and must not be specified for resources of other types.</source>
          <target state="translated">此资源要使用的认证类型。可以为代表任何支持类型的连接工厂的资源指定,不得为其他类型的资源指定。</target>
        </trans-unit>
        <trans-unit id="2a4a45fa984ec8bf14546e0f53e88faedba04946" translate="yes" xml:space="preserve">
          <source>The authority component of a URI, if defined, only contains the commercial-at character (&lt;code&gt;'@'&lt;/code&gt;) and characters in the</source>
          <target state="translated">URI的授权组成部分（如果已定义）仅包含商业字符（ &lt;code&gt;'@'&lt;/code&gt; ）和</target>
        </trans-unit>
        <trans-unit id="a6af6b54b90269c0178a9319b6ac6d1d5547a316" translate="yes" xml:space="preserve">
          <source>The authority component of a hierarchical URI is, if specified, either</source>
          <target state="translated">分层URI的权限成分,如果指定了,可以是</target>
        </trans-unit>
        <trans-unit id="ee24e9771cc2c195ad59121d1a3d3bba72a163ad" translate="yes" xml:space="preserve">
          <source>The authorization ID of the client.</source>
          <target state="translated">客户的授权ID。</target>
        </trans-unit>
        <trans-unit id="384af224756a5ae102067cba3f04e5f5aec1f4e8" translate="yes" xml:space="preserve">
          <source>The average is a special case of a &lt;a href=&quot;package-summary#Reduction&quot;&gt;reduction&lt;/a&gt;.</source>
          <target state="translated">平均值是&lt;a href=&quot;package-summary#Reduction&quot;&gt;减少的&lt;/a&gt;一种特殊情况。</target>
        </trans-unit>
        <trans-unit id="bb72a1ed708709d8af323cafd1c14f03fc2702fe" translate="yes" xml:space="preserve">
          <source>The average number of bytes produced per character of input</source>
          <target state="translated">每个输入字符的平均字节数。</target>
        </trans-unit>
        <trans-unit id="61e1e4d7a028374e193be9a8bb07584ca34ed0c2" translate="yes" xml:space="preserve">
          <source>The average number of characters produced per byte of input</source>
          <target state="translated">每字节输入的平均字符数。</target>
        </trans-unit>
        <trans-unit id="63d8732752ab98346e8809a4b5543eeb11a12175" translate="yes" xml:space="preserve">
          <source>The average returned can vary depending upon the order in which values are recorded, due to accumulated rounding error in addition of values of differing magnitudes. Values sorted by increasing absolute magnitude tend to yield more accurate results. If any recorded value is a &lt;code&gt;NaN&lt;/code&gt; or the sum is at any point a &lt;code&gt;NaN&lt;/code&gt; then the average will be &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">由于累积的舍入误差以及大小不同的值，返回的平均值可能会根据记录值的顺序而有所不同。通过增加绝对值排序的值往往会产生更准确的结果。如果任何记录的值是 &lt;code&gt;NaN&lt;/code&gt; 或总和在任何时候都是 &lt;code&gt;NaN&lt;/code&gt; ,则平均值将是 &lt;code&gt;NaN&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0994cf127413fed7f22b3a2b60b751f5b71c9f67" translate="yes" xml:space="preserve">
          <source>The average returned can vary depending upon the order in which values are recorded. This method may be implemented using compensated summation or other technique to reduce the error bound in the &lt;a href=&quot;doublestream#sum--&quot;&gt;&lt;code&gt;numerical sum&lt;/code&gt;&lt;/a&gt; used to compute the average.</source>
          <target state="translated">返回的平均值可能会有所不同，具体取决于记录值的顺序。可以使用补偿求和或其他技术来实现该方法，以减少用于计算平均值的&lt;a href=&quot;doublestream#sum--&quot;&gt; &lt;code&gt;numerical sum&lt;/code&gt; &lt;/a&gt;的误差范围。</target>
        </trans-unit>
        <trans-unit id="1c0a64799c5be05a53a7a6b2d455ab60be8b27d5" translate="yes" xml:space="preserve">
          <source>The average returned can vary depending upon the order in which values are recorded. This method may be implemented using compensated summation or other technique to reduce the error bound in the &lt;a href=&quot;doublesummarystatistics#getSum--&quot;&gt;&lt;code&gt;numerical sum&lt;/code&gt;&lt;/a&gt; used to compute the average.</source>
          <target state="translated">返回的平均值可能会有所不同，具体取决于记录值的顺序。可以使用补偿求和或其他技术来实现该方法，以减少用于计算平均值的&lt;a href=&quot;doublesummarystatistics#getSum--&quot;&gt; &lt;code&gt;numerical sum&lt;/code&gt; &lt;/a&gt;的误差范围。</target>
        </trans-unit>
        <trans-unit id="df4fb0a2f2eee660620ab243296b5b926ea78b61" translate="yes" xml:space="preserve">
          <source>The awakened thread will not be able to proceed until the current thread relinquishes the lock on this object. The awakened thread will compete in the usual manner with any other threads that might be actively competing to synchronize on this object; for example, the awakened thread enjoys no reliable privilege or disadvantage in being the next thread to lock this object.</source>
          <target state="translated">在当前线程放弃对这个对象的锁定之前,被唤醒的线程将无法继续前进。被唤醒的线程将以通常的方式与任何其他可能积极竞争在此对象上同步的线程竞争;例如,被唤醒的线程在成为下一个锁定此对象的线程时不享有可靠的特权或劣势。</target>
        </trans-unit>
        <trans-unit id="b5974bbfcd5ae065e5d3709711a9478f3485161b" translate="yes" xml:space="preserve">
          <source>The awakened threads will not be able to proceed until the current thread relinquishes the lock on this object. The awakened threads will compete in the usual manner with any other threads that might be actively competing to synchronize on this object; for example, the awakened threads enjoy no reliable privilege or disadvantage in being the next thread to lock this object.</source>
          <target state="translated">在当前线程放弃对这个对象的锁定之前,被唤醒的线程将无法继续进行。被唤醒的线程将以通常的方式与任何其他可能积极竞争在此对象上同步的线程竞争;例如,被唤醒的线程在成为下一个锁定此对象的线程时不享有可靠的特权或劣势。</target>
        </trans-unit>
        <trans-unit id="ffe3bc3630669ac9a0d1cced2c0acfc7fe9a5bcc" translate="yes" xml:space="preserve">
          <source>The backreference constructs, &lt;code&gt;\g{&lt;/code&gt;</source>
          <target state="translated">反向引用结构 &lt;code&gt;\g{&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ba7183c765033aa363e3f66588a84ad98b740066" translate="yes" xml:space="preserve">
          <source>The backslash character</source>
          <target state="translated">反斜杠字符</target>
        </trans-unit>
        <trans-unit id="c54d456d477cda60e00f39118969acd00278ac3c" translate="yes" xml:space="preserve">
          <source>The backslash character (&lt;code&gt;'\'&lt;/code&gt;) serves to introduce escaped constructs, as defined in the table above, as well as to quote characters that otherwise would be interpreted as unescaped constructs. Thus the expression &lt;code&gt;\\&lt;/code&gt; matches a single backslash and &lt;code&gt;\{&lt;/code&gt; matches a left brace.</source>
          <target state="translated">反斜杠字符（ &lt;code&gt;'\'&lt;/code&gt; ）用来引入上表中定义的转义构造，并引用否则将被解释为非转义构造的字符。因此，表达式 &lt;code&gt;\\&lt;/code&gt; 匹配单个反斜杠，而 &lt;code&gt;\{&lt;/code&gt; 匹配左括号。</target>
        </trans-unit>
        <trans-unit id="23aae77df11f01ad715953290d7bfdadcde657dc" translate="yes" xml:space="preserve">
          <source>The backslash character (&lt;code&gt;\&lt;/code&gt;) is used to escape characters that would otherwise be interpreted as special characters. The expression &lt;code&gt;\\&lt;/code&gt; matches a single backslash and &quot;\{&quot; matches a left brace for example.</source>
          <target state="translated">反斜杠字符（ &lt;code&gt;\&lt;/code&gt; ）用于转义否则将被解释为特殊字符的字符。例如，表达式 &lt;code&gt;\\&lt;/code&gt; 匹配一个反斜杠，而&amp;ldquo; \ {&amp;rdquo;匹配一个左括号。</target>
        </trans-unit>
        <trans-unit id="173f1752d2ba0fc408c016b82a7acf729f9be4f0" translate="yes" xml:space="preserve">
          <source>The backtrace for a throwable with an initialized, non-null cause should generally include the backtrace for the cause. The format of this information depends on the implementation, but the following example may be regarded as typical:</source>
          <target state="translated">对于具有初始化的非空原因的可抛物,其回溯一般应包括原因的回溯。这种信息的格式取决于实现,但下面的例子可以被认为是典型的。</target>
        </trans-unit>
        <trans-unit id="f7a908d77eceb25de71b84720c94aed1fee43c91" translate="yes" xml:space="preserve">
          <source>The bank number of the instrument that this voice is currently using. This is a number dictated by the MIDI bank-select message; it does not refer to a &lt;code&gt;SoundBank&lt;/code&gt; object. The value ranges from 0 to 16383 if the voice is active, and is unspecified if the voice is inactive.</source>
          <target state="translated">该声音当前正在使用的乐器的银行编号。这是一个由MIDI库选择消息指示的数字。它没有引用 &lt;code&gt;SoundBank&lt;/code&gt; 对象。如果语音处于活动状态，则该值的范围为0到16383，如果语音处于非活动状态，则该值未指定。</target>
        </trans-unit>
        <trans-unit id="3ab8a2ea7c84500b3dbb48c10ba75066f2c5af4f" translate="yes" xml:space="preserve">
          <source>The base &lt;code&gt;MidiMessage&lt;/code&gt; class provides access to three types of information about a MIDI message:</source>
          <target state="translated">&lt;code&gt;MidiMessage&lt;/code&gt; 基类提供对MIDI消息的三种类型的信息的访问：</target>
        </trans-unit>
        <trans-unit id="2d8ea37b9287753a5e0ba2a565a7f46956883b1c" translate="yes" xml:space="preserve">
          <source>The base date is used to calculate the full value during parsing. For example, if the base date is 1950-01-01 then parsed values for a two digit year parse will be in the range 1950-01-01 to 2049-12-31. Only the year would be extracted from the date, thus a base date of 1950-08-25 would also parse to the range 1950-01-01 to 2049-12-31. This behavior is necessary to support fields such as week-based-year or other calendar systems where the parsed value does not align with standard ISO years.</source>
          <target state="translated">基准日期在解析过程中用于计算完整的值。例如,如果基准日期是1950-01-01,那么两位数年份的解析值将在1950-01-01到2049-12-31的范围内。只有年份才会被从日期中提取出来,因此1950-08-25的基准日期也会被解析为1950-01-01到2049-12-31的范围。这种行为对于支持诸如以周为单位的年份或其他日历系统的字段是必要的,因为在这些字段中,解析的值与标准的ISO年份不一致。</target>
        </trans-unit>
        <trans-unit id="db101bc81e018a709756e424cfa5aecef7b94b31" translate="yes" xml:space="preserve">
          <source>The base name for the &lt;a href=&quot;../../java/util/resourcebundle&quot;&gt;&lt;code&gt;ResourceBundle&lt;/code&gt;&lt;/a&gt; in which the key given in the &lt;code&gt;descriptionResourceKey&lt;/code&gt; field can be found, for example &lt;code&gt;&quot;com.example.myapp.MBeanResources&quot;&lt;/code&gt;. The meaning of this field is defined by this specification but the field is not set or used by the JMX API itself.</source>
          <target state="translated">&lt;a href=&quot;../../java/util/resourcebundle&quot;&gt; &lt;code&gt;ResourceBundle&lt;/code&gt; &lt;/a&gt;的基本名称，可以在 &lt;code&gt;descriptionResourceKey&lt;/code&gt; 字段中找到键，例如 &lt;code&gt;&quot;com.example.myapp.MBeanResources&quot;&lt;/code&gt; 。该字段的含义由本规范定义，但JMX API本身未设置或使用该字段。</target>
        </trans-unit>
        <trans-unit id="0f3860eb6983917dd41e74b2471fbc7e734a2839" translate="yes" xml:space="preserve">
          <source>The base name of the resource bundle, as provided to and expected by the &lt;code&gt;ResourceBundle.getBundle(...)&lt;/code&gt; methods.</source>
          <target state="translated">资源包的基本名称，由 &lt;code&gt;ResourceBundle.getBundle(...)&lt;/code&gt; 方法提供并期望。</target>
        </trans-unit>
        <trans-unit id="9b8c08a8db8d8c053315eb0ddb9eabf15da05825" translate="yes" xml:space="preserve">
          <source>The base-independent settings are:</source>
          <target state="translated">与基地无关的设置是:</target>
        </trans-unit>
        <trans-unit id="22c030ed5821c260423b1c4753dbb8e2a6a8f1d5" translate="yes" xml:space="preserve">
          <source>The basic X.509 format was defined by ISO/IEC and ANSI X9 and is described below in ASN.1:</source>
          <target state="translated">基本的X.509格式是由ISO/IEC和ANSI X9定义的,在ASN.1中描述如下。</target>
        </trans-unit>
        <trans-unit id="0785d4b501d4138551df284c612b88d563d171dd" translate="yes" xml:space="preserve">
          <source>The basic constraints extension identifies whether the subject of the certificate is a Certificate Authority (CA) and how deep a certification path may exist through that CA. The &lt;code&gt;pathLenConstraint&lt;/code&gt; field (see below) is meaningful only if &lt;code&gt;cA&lt;/code&gt; is set to TRUE. In this case, it gives the maximum number of CA certificates that may follow this certificate in a certification path. A value of zero indicates that only an end-entity certificate may follow in the path.</source>
          <target state="translated">基本约束扩展标识证书的主题是否为证书颁发机构（CA），以及通过该CA可能存在的证书路径的深度。仅当将 &lt;code&gt;cA&lt;/code&gt; 设置为TRUE时， &lt;code&gt;pathLenConstraint&lt;/code&gt; 字段才有意义。在这种情况下，它给出了证书路径中可以跟随该证书的CA证书的最大数量。零值表示该路径中只能遵循最终实体证书。</target>
        </trans-unit>
        <trans-unit id="9d3e4470fb6fef2183cdb8feb8f069433d3267c8" translate="yes" xml:space="preserve">
          <source>The basic design intent is to allow applications to lazily locate and initialize services only when needed without any API dependencies except in an environment in which they are used.</source>
          <target state="translated">基本的设计意图是允许应用程序只在需要的时候才懒惰地定位和初始化服务,而不需要任何API依赖,除非在使用环境中。</target>
        </trans-unit>
        <trans-unit id="d9903103f8e3fb722ce3e381557a9ebadabbb1b5" translate="yes" xml:space="preserve">
          <source>The basic elements of date-time can all be added:</source>
          <target state="translated">日期-时间的基本要素都可以添加。</target>
        </trans-unit>
        <trans-unit id="df730da662879ba7ad947e6e095591e4eb5f371c" translate="yes" xml:space="preserve">
          <source>The bean context.</source>
          <target state="translated">豆的背景。</target>
        </trans-unit>
        <trans-unit id="a7c9bd47e337bf8f0e24f3fd1a3997732c06fa62" translate="yes" xml:space="preserve">
          <source>The bean is created based on a name relative to a class-loader. This name should be a dot-separated name such as &quot;a.b.c&quot;.</source>
          <target state="translated">bean是基于相对于类加载器的名称创建的。这个名字应该是一个点分隔的名字,比如 &quot;a.b.c&quot;。</target>
        </trans-unit>
        <trans-unit id="01fa9a9232e07d2331f9abf70122c26f44cb6dc7" translate="yes" xml:space="preserve">
          <source>The beginning of a line</source>
          <target state="translated">句子的开头</target>
        </trans-unit>
        <trans-unit id="84c05d7f91bdedeed5670ac539f8d7123633e4bf" translate="yes" xml:space="preserve">
          <source>The beginning of the input</source>
          <target state="translated">输入的开始</target>
        </trans-unit>
        <trans-unit id="4bf4be7cd283b65eee1ee51c2ca2edc17597e0a0" translate="yes" xml:space="preserve">
          <source>The behavior depends on the cardinality of the role where the unregistered MBean is referenced:</source>
          <target state="translated">这种行为取决于未注册的MBean被引用的角色的cardinality。</target>
        </trans-unit>
        <trans-unit id="5aab83b129a0c7ffdae67ec9a21f46443c7f36f5" translate="yes" xml:space="preserve">
          <source>The behavior is suitable for use with most calendar systems. It is equivalent to:</source>
          <target state="translated">该行为适合与大多数日历系统一起使用。它相当于:</target>
        </trans-unit>
        <trans-unit id="3fd6de2d8c10eb73ee592774720bf1e065b01d9b" translate="yes" xml:space="preserve">
          <source>The behavior is suitable for use with most calendar systems. It uses the &lt;code&gt;DAY_OF_WEEK&lt;/code&gt; and &lt;code&gt;DAY_OF_MONTH&lt;/code&gt; fields and the &lt;code&gt;DAYS&lt;/code&gt; unit, and assumes a seven day week.</source>
          <target state="translated">该行为适用于大多数日历系统。它使用 &lt;code&gt;DAY_OF_WEEK&lt;/code&gt; 和 &lt;code&gt;DAY_OF_MONTH&lt;/code&gt; 字段以及 &lt;code&gt;DAYS&lt;/code&gt; 单位，并假设一周工作7天。</target>
        </trans-unit>
        <trans-unit id="bdd6f3ee23355515e15e9110422cea8654165976" translate="yes" xml:space="preserve">
          <source>The behavior is suitable for use with most calendar systems. It uses the &lt;code&gt;DAY_OF_WEEK&lt;/code&gt; field and the &lt;code&gt;DAYS&lt;/code&gt; unit, and assumes a seven day week.</source>
          <target state="translated">该行为适用于大多数日历系统。它使用 &lt;code&gt;DAY_OF_WEEK&lt;/code&gt; 字段和 &lt;code&gt;DAYS&lt;/code&gt; 单位，并假设一周工作7天。</target>
        </trans-unit>
        <trans-unit id="c78a1d17ae0c3c3a48da69bd93f5bf924cfc22fc" translate="yes" xml:space="preserve">
          <source>The behavior of &lt;a href=&quot;methodhandle#asType-java.lang.invoke.MethodType-&quot;&gt;&lt;code&gt;asType&lt;/code&gt;&lt;/a&gt; is also specialized for variable arity adapters, to maintain the invariant that plain, inexact &lt;code&gt;invoke&lt;/code&gt; is always equivalent to an &lt;code&gt;asType&lt;/code&gt; call to adjust the target type, followed by &lt;code&gt;invokeExact&lt;/code&gt;. Therefore, a variable arity adapter responds to an &lt;code&gt;asType&lt;/code&gt; request by building a fixed arity collector, if and only if the adapter and requested type differ either in arity or trailing argument type. The resulting fixed arity collector has its type further adjusted (if necessary) to the requested type by pairwise conversion, as if by another application of &lt;code&gt;asType&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;methodhandle#asType-java.lang.invoke.MethodType-&quot;&gt; &lt;code&gt;asType&lt;/code&gt; &lt;/a&gt;的行为还专门用于变量arity适配器，以保持不变，即简单，不精确的 &lt;code&gt;invoke&lt;/code&gt; 始终等同于 &lt;code&gt;asType&lt;/code&gt; 调用，以调整目标类型，然后是 &lt;code&gt;invokeExact&lt;/code&gt; 。因此，当且仅当适配器和请求的类型在Arity或尾随参数类型上不同时，可变 &lt;code&gt;asType&lt;/code&gt; 适配器才通过构建固定的Arity收集器来响应asType请求。通过成对转换，可以将生成的固定arity收集器的类型进一步调整（如果需要）为请求的类型，就像使用 &lt;code&gt;asType&lt;/code&gt; 的另一个应用程序一样。</target>
        </trans-unit>
        <trans-unit id="9928e84708937d65d173868df25d6628e2c4c51b" translate="yes" xml:space="preserve">
          <source>The behavior of aforementioned conversion process can be adjusted by various flags:</source>
          <target state="translated">上述转换过程的行为可以通过各种标志进行调整。</target>
        </trans-unit>
        <trans-unit id="09786826b0bc4001e9b5554b263b6d5f4bb895ae" translate="yes" xml:space="preserve">
          <source>The behavior of radixes and the characters used as digits are the same as &lt;a href=&quot;integer#toString-int-int-&quot;&gt;&lt;code&gt;toString&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">基数的行为和用作数字的字符与&lt;a href=&quot;integer#toString-int-int-&quot;&gt; &lt;code&gt;toString&lt;/code&gt; &lt;/a&gt;相同。</target>
        </trans-unit>
        <trans-unit id="2327f433d1a38b7e2e39780763df7142425c0d7a" translate="yes" xml:space="preserve">
          <source>The behavior of radixes and the characters used as digits are the same as &lt;a href=&quot;long#toString-long-int-&quot;&gt;&lt;code&gt;toString&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">基数的行为和用作数字的字符与&lt;a href=&quot;long#toString-long-int-&quot;&gt; &lt;code&gt;toString&lt;/code&gt; &lt;/a&gt;相同。</target>
        </trans-unit>
        <trans-unit id="bc46c31b73f5a4c03e122bdac42a6357c999abe4" translate="yes" xml:space="preserve">
          <source>The behavior of the &lt;code&gt;WeakHashMap&lt;/code&gt; class depends in part upon the actions of the garbage collector, so several familiar (though not required) &lt;code&gt;Map&lt;/code&gt; invariants do not hold for this class. Because the garbage collector may discard keys at any time, a &lt;code&gt;WeakHashMap&lt;/code&gt; may behave as though an unknown thread is silently removing entries. In particular, even if you synchronize on a &lt;code&gt;WeakHashMap&lt;/code&gt; instance and invoke none of its mutator methods, it is possible for the &lt;code&gt;size&lt;/code&gt; method to return smaller values over time, for the &lt;code&gt;isEmpty&lt;/code&gt; method to return &lt;code&gt;false&lt;/code&gt; and then &lt;code&gt;true&lt;/code&gt;, for the &lt;code&gt;containsKey&lt;/code&gt; method to return &lt;code&gt;true&lt;/code&gt; and later &lt;code&gt;false&lt;/code&gt; for a given key, for the &lt;code&gt;get&lt;/code&gt; method to return a value for a given key but later return &lt;code&gt;null&lt;/code&gt;, for the &lt;code&gt;put&lt;/code&gt; method to return &lt;code&gt;null&lt;/code&gt; and the &lt;code&gt;remove&lt;/code&gt; method to return &lt;code&gt;false&lt;/code&gt; for a key that previously appeared to be in the map, and for successive examinations of the key set, the value collection, and the entry set to yield successively smaller numbers of elements.</source>
          <target state="translated">&lt;code&gt;WeakHashMap&lt;/code&gt; 类的行为部分取决于垃圾回收器的操作，因此，一些熟悉的（尽管不是必需的） &lt;code&gt;Map&lt;/code&gt; 不变量对此类不成立。因为垃圾回收器可以随时丢弃键，所以 &lt;code&gt;WeakHashMap&lt;/code&gt; 的行为就像未知线程正在静默删除条目一样。特别是，即使您在 &lt;code&gt;WeakHashMap&lt;/code&gt; 实例上进行同步并且不调用其任何mutator方法， &lt;code&gt;size&lt;/code&gt; 方法也可能会随时间返回较小的值， &lt;code&gt;isEmpty&lt;/code&gt; 方法可能会返回 &lt;code&gt;false&lt;/code&gt; ，然后返回 &lt;code&gt;true&lt;/code&gt; ，而 &lt;code&gt;containsKey&lt;/code&gt; 方法则会返回 &lt;code&gt;true&lt;/code&gt; 对于给定的键，其后为 &lt;code&gt;false&lt;/code&gt; ;对于给定的键， &lt;code&gt;get&lt;/code&gt; 方法返回一个值；但对于先前出现在映射中的键，则为 &lt;code&gt;null&lt;/code&gt; ；对于 &lt;code&gt;put&lt;/code&gt; 方法，则返回 &lt;code&gt;null&lt;/code&gt; ；对于 &lt;code&gt;remove&lt;/code&gt; 方法，为给定的键返回 &lt;code&gt;false&lt;/code&gt; 。 ，以及对键集，值集合和条目集的连续检查，以依次产生较小数量的元素。</target>
        </trans-unit>
        <trans-unit id="3e02ad5d427f7e98147ba48075552194761f98de" translate="yes" xml:space="preserve">
          <source>The behavior of the &lt;code&gt;addAll()&lt;/code&gt; operation is unspecified if the specified set is modified while the operation is in progress.</source>
          <target state="translated">如果在操作进行过程中修改了指定的集合，则不确定 &lt;code&gt;addAll()&lt;/code&gt; 操作的行为。</target>
        </trans-unit>
        <trans-unit id="dd3a0b270d27c03418b33e302ccbdd164f36924b" translate="yes" xml:space="preserve">
          <source>The behavior of the returned map is system-dependent. A system may not allow modifications to environment variables or may forbid certain variable names or values. For this reason, attempts to modify the map may fail with &lt;a href=&quot;unsupportedoperationexception&quot;&gt;&lt;code&gt;UnsupportedOperationException&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;illegalargumentexception&quot;&gt;&lt;code&gt;IllegalArgumentException&lt;/code&gt;&lt;/a&gt; if the modification is not permitted by the operating system.</source>
          <target state="translated">返回的映射的行为取决于系统。系统可能不允许修改环境变量，也可能禁止某些变量名称或值。因此，如果操作系统不允许修改，则尝试修改映射可能会失败，并显示&lt;a href=&quot;unsupportedoperationexception&quot;&gt; &lt;code&gt;UnsupportedOperationException&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;illegalargumentexception&quot;&gt; &lt;code&gt;IllegalArgumentException&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1fe6e71635b80bfba7b21f293fdc2c363d272846" translate="yes" xml:space="preserve">
          <source>The behavior of this constructor when the given bytes are not valid in the default charset is unspecified. The &lt;a href=&quot;../nio/charset/charsetdecoder&quot;&gt;&lt;code&gt;CharsetDecoder&lt;/code&gt;&lt;/a&gt; class should be used when more control over the decoding process is required.</source>
          <target state="translated">未指定默认字符集中给定字节无效时此构造函数的行为。所述&lt;a href=&quot;../nio/charset/charsetdecoder&quot;&gt; &lt;code&gt;CharsetDecoder&lt;/code&gt; &lt;/a&gt;当需要在解码处理更多的控制类应当被使用。</target>
        </trans-unit>
        <trans-unit id="ef46977efa30131184db5ba7badc7bce2b48869e" translate="yes" xml:space="preserve">
          <source>The behavior of this constructor when the given bytes are not valid in the given charset is unspecified. The &lt;a href=&quot;../nio/charset/charsetdecoder&quot;&gt;&lt;code&gt;CharsetDecoder&lt;/code&gt;&lt;/a&gt; class should be used when more control over the decoding process is required.</source>
          <target state="translated">未指定给定字符集中给定字节无效时此构造函数的行为。所述&lt;a href=&quot;../nio/charset/charsetdecoder&quot;&gt; &lt;code&gt;CharsetDecoder&lt;/code&gt; &lt;/a&gt;当需要在解码处理更多的控制类应当被使用。</target>
        </trans-unit>
        <trans-unit id="c3d627d59df90697e2b554f3a55de8ccd2ce8753" translate="yes" xml:space="preserve">
          <source>The behavior of this method when called for the first time depends on the parameters that were supplied at construction, as described below.</source>
          <target state="translated">该方法第一次调用时的行为取决于在构造时提供的参数,如下所述。</target>
        </trans-unit>
        <trans-unit id="4f973622f5301926870bc25f4502c72fb450009b" translate="yes" xml:space="preserve">
          <source>The behavior of this method when this string cannot be encoded in the default charset is unspecified. The &lt;a href=&quot;../nio/charset/charsetencoder&quot;&gt;&lt;code&gt;CharsetEncoder&lt;/code&gt;&lt;/a&gt; class should be used when more control over the encoding process is required.</source>
          <target state="translated">未指定无法在默认字符集中编码此字符串时此方法的行为。所述&lt;a href=&quot;../nio/charset/charsetencoder&quot;&gt; &lt;code&gt;CharsetEncoder&lt;/code&gt; &lt;/a&gt;当需要在编码处理更多的控制类应当被使用。</target>
        </trans-unit>
        <trans-unit id="6473ebdc9f7cacf7ddaf2b7432bd6ab177ee9d47" translate="yes" xml:space="preserve">
          <source>The behavior of this method when this string cannot be encoded in the given charset is unspecified. The &lt;a href=&quot;../nio/charset/charsetencoder&quot;&gt;&lt;code&gt;CharsetEncoder&lt;/code&gt;&lt;/a&gt; class should be used when more control over the encoding process is required.</source>
          <target state="translated">当无法在给定字符集中编码此字符串时，此方法的行为未指定。所述&lt;a href=&quot;../nio/charset/charsetencoder&quot;&gt; &lt;code&gt;CharsetEncoder&lt;/code&gt; &lt;/a&gt;当需要在编码处理更多的控制类应当被使用。</target>
        </trans-unit>
        <trans-unit id="2ae57d2eaaf4445efb0e51f92a31f9d7f1d65948" translate="yes" xml:space="preserve">
          <source>The behavior of this operation is explicitly nondeterministic. For parallel stream pipelines, this operation does &lt;em&gt;not&lt;/em&gt; guarantee to respect the encounter order of the stream, as doing so would sacrifice the benefit of parallelism. For any given element, the action may be performed at whatever time and in whatever thread the library chooses. If the action accesses shared state, it is responsible for providing the required synchronization.</source>
          <target state="translated">该操作的行为明确地是不确定的。对于并行流管道，此操作&lt;em&gt;不能&lt;/em&gt;保证尊重流的遇到顺序，因为这样做会牺牲并行性的好处。对于任何给定的元素，可以在库选择的任何时间和线程中执行操作。如果操作访问共享状态，则它负责提供所需的同步。</target>
        </trans-unit>
        <trans-unit id="7523e5e5c512c923c9b5e8efbcae139dd68a3aac" translate="yes" xml:space="preserve">
          <source>The behavior of this operation is explicitly nondeterministic; it is free to select any element in the stream. This is to allow for maximal performance in parallel operations; the cost is that multiple invocations on the same source may not return the same result. (If a stable result is desired, use &lt;a href=&quot;doublestream#findFirst--&quot;&gt;&lt;code&gt;findFirst()&lt;/code&gt;&lt;/a&gt; instead.)</source>
          <target state="translated">该操作的行为明确地是不确定的。可以自由选择流中的任何元素。这是为了在并行操作中获得最佳性能。代价是对同一源的多次调用可能不会返回相同的结果。（如果需要稳定的结果，请改用&lt;a href=&quot;doublestream#findFirst--&quot;&gt; &lt;code&gt;findFirst()&lt;/code&gt; &lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="c3ed65b77c994c2fc97e72428779c268f50ba7b6" translate="yes" xml:space="preserve">
          <source>The behavior of this operation is explicitly nondeterministic; it is free to select any element in the stream. This is to allow for maximal performance in parallel operations; the cost is that multiple invocations on the same source may not return the same result. (If a stable result is desired, use &lt;a href=&quot;intstream#findFirst--&quot;&gt;&lt;code&gt;findFirst()&lt;/code&gt;&lt;/a&gt; instead.)</source>
          <target state="translated">该操作的行为明确地是不确定的。可以自由选择流中的任何元素。这是为了在并行操作中获得最佳性能。代价是对同一源的多次调用可能不会返回相同的结果。（如果需要稳定的结果，请改用&lt;a href=&quot;intstream#findFirst--&quot;&gt; &lt;code&gt;findFirst()&lt;/code&gt; &lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="91343b7a97cce9e49bf7bfd43ef77ddc9e9de3c1" translate="yes" xml:space="preserve">
          <source>The behavior of this operation is explicitly nondeterministic; it is free to select any element in the stream. This is to allow for maximal performance in parallel operations; the cost is that multiple invocations on the same source may not return the same result. (If a stable result is desired, use &lt;a href=&quot;longstream#findFirst--&quot;&gt;&lt;code&gt;findFirst()&lt;/code&gt;&lt;/a&gt; instead.)</source>
          <target state="translated">该操作的行为明确地是不确定的。可以自由选择流中的任何元素。这是为了在并行操作中获得最佳性能。代价是对同一源的多次调用可能不会返回相同的结果。（如果需要稳定的结果，请改用&lt;a href=&quot;longstream#findFirst--&quot;&gt; &lt;code&gt;findFirst()&lt;/code&gt; &lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="ac4f8664629b9c54913b4e09c46aa5ed184dae26" translate="yes" xml:space="preserve">
          <source>The behavior of this operation is explicitly nondeterministic; it is free to select any element in the stream. This is to allow for maximal performance in parallel operations; the cost is that multiple invocations on the same source may not return the same result. (If a stable result is desired, use &lt;a href=&quot;stream#findFirst--&quot;&gt;&lt;code&gt;findFirst()&lt;/code&gt;&lt;/a&gt; instead.)</source>
          <target state="translated">该操作的行为明确地是不确定的。可以自由选择流中的任何元素。这是为了在并行操作中获得最佳性能。代价是对同一源的多次调用可能不会返回相同的结果。（如果需要稳定的结果，请改用&lt;a href=&quot;stream#findFirst--&quot;&gt; &lt;code&gt;findFirst()&lt;/code&gt; &lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="de5bd53441d47c5af575e182bec3b83289b02191" translate="yes" xml:space="preserve">
          <source>The behavior of this socket option on a stream-oriented socket, or an &lt;a href=&quot;standardprotocolfamily#INET6&quot;&gt;&lt;code&gt;IPv6&lt;/code&gt;&lt;/a&gt; socket, is not defined in this release.</source>
          <target state="translated">此发行版中未定义此套接字选项在面向流的套接字或&lt;a href=&quot;standardprotocolfamily#INET6&quot;&gt; &lt;code&gt;IPv6&lt;/code&gt; &lt;/a&gt;套接字上的行为。</target>
        </trans-unit>
        <trans-unit id="1948fdb6e5f0e37d4d3127a1dee0880f5b26239c" translate="yes" xml:space="preserve">
          <source>The behavior when the URL path is neither empty nor a JNDI directory URL, or when the protocol is neither &lt;code&gt;rmi&lt;/code&gt; nor &lt;code&gt;iiop&lt;/code&gt;, is implementation defined, and may include throwing &lt;a href=&quot;../../../../java/net/malformedurlexception&quot;&gt;&lt;code&gt;MalformedURLException&lt;/code&gt;&lt;/a&gt; when the connector server is created or when it is started.</source>
          <target state="translated">URL路径既不是空也不是JNDI目录URL，或者协议既不是 &lt;code&gt;rmi&lt;/code&gt; 也不是 &lt;code&gt;iiop&lt;/code&gt; 时的行为是实现定义的，并且可能包括在创建连接器服务器或启动连接器服务器时&lt;a href=&quot;../../../../java/net/malformedurlexception&quot;&gt; &lt;code&gt;MalformedURLException&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="52bb3f58a08177a0b2dccbcfe8b7621c236f7348" translate="yes" xml:space="preserve">
          <source>The behavior when this method is called more than once is unspecified.</source>
          <target state="translated">本方法被调用一次以上时的行为是未指定的。</target>
        </trans-unit>
        <trans-unit id="cc00fc99ac6d19fed1822d5b36037c02e19215d2" translate="yes" xml:space="preserve">
          <source>The behaviour when &lt;a href=&quot;socketoptions#SO_REUSEADDR&quot;&gt;&lt;code&gt;SO_REUSEADDR&lt;/code&gt;&lt;/a&gt; is enabled or disabled after a socket is bound (See &lt;a href=&quot;serversocket#isBound--&quot;&gt;&lt;code&gt;isBound()&lt;/code&gt;&lt;/a&gt;) is not defined.</source>
          <target state="translated">未定义绑定套接字后启用或禁用&lt;a href=&quot;socketoptions#SO_REUSEADDR&quot;&gt; &lt;code&gt;SO_REUSEADDR&lt;/code&gt; &lt;/a&gt;的行为（请参见&lt;a href=&quot;serversocket#isBound--&quot;&gt; &lt;code&gt;isBound()&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="813b8a785ddc662d03b34c45ccd8c027a04fb706" translate="yes" xml:space="preserve">
          <source>The behaviour when &lt;a href=&quot;socketoptions#SO_REUSEADDR&quot;&gt;&lt;code&gt;SO_REUSEADDR&lt;/code&gt;&lt;/a&gt; is enabled or disabled after a socket is bound (See &lt;a href=&quot;socket#isBound--&quot;&gt;&lt;code&gt;isBound()&lt;/code&gt;&lt;/a&gt;) is not defined.</source>
          <target state="translated">未定义绑定套接字后启用或禁用&lt;a href=&quot;socketoptions#SO_REUSEADDR&quot;&gt; &lt;code&gt;SO_REUSEADDR&lt;/code&gt; &lt;/a&gt;的行为（请参见&lt;a href=&quot;socket#isBound--&quot;&gt; &lt;code&gt;isBound()&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="c3662286b844f4d43a48e82d7a61531172d3a7f6" translate="yes" xml:space="preserve">
          <source>The behaviour when &lt;code&gt;SO_REUSEADDR&lt;/code&gt; is enabled or disabled after a socket is bound (See &lt;a href=&quot;datagramsocket#isBound--&quot;&gt;&lt;code&gt;isBound()&lt;/code&gt;&lt;/a&gt;) is not defined.</source>
          <target state="translated">未定义绑定套接字后启用或禁用 &lt;code&gt;SO_REUSEADDR&lt;/code&gt; 的行为（请参见&lt;a href=&quot;datagramsocket#isBound--&quot;&gt; &lt;code&gt;isBound()&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="ec8605f5932b60aa18480347bbe8295238cc8d8d" translate="yes" xml:space="preserve">
          <source>The best algorithms for manipulating random access lists (such as &lt;code&gt;ArrayList&lt;/code&gt;) can produce quadratic behavior when applied to sequential access lists (such as &lt;code&gt;LinkedList&lt;/code&gt;). Generic list algorithms are encouraged to check whether the given list is an &lt;code&gt;instanceof&lt;/code&gt; this interface before applying an algorithm that would provide poor performance if it were applied to a sequential access list, and to alter their behavior if necessary to guarantee acceptable performance.</source>
          <target state="translated">应用于随机访问列表（例如 &lt;code&gt;ArrayList&lt;/code&gt; ）的最佳算法在应用于顺序访问列表（例如 &lt;code&gt;LinkedList&lt;/code&gt; ）时会产生二次行为。鼓励泛型列表算法在应用给定顺序访问列表（如果将其应用到性能较差）之前检查给定列表是否为该接口的 &lt;code&gt;instanceof&lt;/code&gt; ，并在必要时更改其行为以保证可接受的性能。</target>
        </trans-unit>
        <trans-unit id="aa63c846ce6c63983851d6cc1315cae60e071eef" translate="yes" xml:space="preserve">
          <source>The best value of &lt;code&gt;TASKS_PER_PHASER&lt;/code&gt; depends mainly on expected synchronization rates. A value as low as four may be appropriate for extremely small per-phase task bodies (thus high rates), or up to hundreds for extremely large ones.</source>
          <target state="translated">&lt;code&gt;TASKS_PER_PHASER&lt;/code&gt; 的最佳值主要取决于预期的同步速率。对于极小的每阶段任务主体（因此是高比率），低至4的值可能合适，而对于极大型的任务阶段，则最高可能为数百。</target>
        </trans-unit>
        <trans-unit id="e04209ad3d05621b8a42c0de27ff8910369553f0" translate="yes" xml:space="preserve">
          <source>The binding must be nonnull if the object existed after the change relative to the source context (&lt;code&gt;getEventContext()&lt;/code&gt;). That is, it must be nonnull for &lt;code&gt;OBJECT_ADDED&lt;/code&gt; and &lt;code&gt;OBJECT_CHANGED&lt;/code&gt;. For &lt;code&gt;OBJECT_RENAMED&lt;/code&gt;, it is null if the object after the rename is outside the scope for which the listener registered interest; it is nonnull if the object is inside the scope after the rename.</source>
          <target state="translated">如果对象相对于源上下文（ &lt;code&gt;getEventContext()&lt;/code&gt; ）更改之后存在，则绑定必须为非null 。也就是说，对于 &lt;code&gt;OBJECT_ADDED&lt;/code&gt; 和 &lt;code&gt;OBJECT_CHANGED&lt;/code&gt; ，它必须为非null 。对于 &lt;code&gt;OBJECT_RENAMED&lt;/code&gt; ，如果重命名后的对象超出了侦听器所关注的范围，则为null；否则为null。如果对象在重命名之后位于范围内，则它为非null。</target>
        </trans-unit>
        <trans-unit id="47fe787308677096c8310117b4783e3ddb5d20ff" translate="yes" xml:space="preserve">
          <source>The binding must be nonnull if the object existed before the change relative to the source context (&lt;code&gt;getEventContext()&lt;/code&gt;). That is, it must be nonnull for &lt;code&gt;OBJECT_REMOVED&lt;/code&gt; and &lt;code&gt;OBJECT_CHANGED&lt;/code&gt;. For &lt;code&gt;OBJECT_RENAMED&lt;/code&gt;, it is null if the object before the rename is outside of the scope for which the listener has registered interest; it is nonnull if the object is inside the scope before the rename.</source>
          <target state="translated">如果对象在相对于源上下文（ &lt;code&gt;getEventContext()&lt;/code&gt; ）更改之前就存在，则绑定必须为非null 。也就是说，对于 &lt;code&gt;OBJECT_REMOVED&lt;/code&gt; 和 &lt;code&gt;OBJECT_CHANGED&lt;/code&gt; ，它必须为非 null 。对于 &lt;code&gt;OBJECT_RENAMED&lt;/code&gt; ，如果重命名之前的对象在侦听器已注册的范围之外，则为null；否则为null。如果对象在重命名之前位于范围内，则它为非null。</target>
        </trans-unit>
        <trans-unit id="a540813c3623088162eddf8021387f816ab7189e" translate="yes" xml:space="preserve">
          <source>The binding of the changed object can be obtained using &lt;code&gt;evt.getNewBinding()&lt;/code&gt;. Its old binding (before the change) can be obtained using &lt;code&gt;evt.getOldBinding()&lt;/code&gt;.</source>
          <target state="translated">可以使用 &lt;code&gt;evt.getNewBinding()&lt;/code&gt; 获得更改对象的绑定。可以使用 &lt;code&gt;evt.getOldBinding()&lt;/code&gt; 获得其旧的绑定（在更改之前）。</target>
        </trans-unit>
        <trans-unit id="00b0bb606f5c3ecd51111e3a9af417eb62109163" translate="yes" xml:space="preserve">
          <source>The binding of the newly added object can be obtained using &lt;code&gt;evt.getNewBinding()&lt;/code&gt;.</source>
          <target state="translated">可以使用 &lt;code&gt;evt.getNewBinding()&lt;/code&gt; 获得新添加的对象的绑定。</target>
        </trans-unit>
        <trans-unit id="97025602c1b0354a00b10c74a226ea38edab7a3f" translate="yes" xml:space="preserve">
          <source>The binding of the newly removed object can be obtained using &lt;code&gt;evt.getOldBinding()&lt;/code&gt;.</source>
          <target state="translated">可以使用 &lt;code&gt;evt.getOldBinding()&lt;/code&gt; 获得新删除的对象的绑定。</target>
        </trans-unit>
        <trans-unit id="db5d5c2755a2f75964c67f244f9ab71ecafaefa5" translate="yes" xml:space="preserve">
          <source>The binding of the renamed object can be obtained using &lt;code&gt;evt.getNewBinding()&lt;/code&gt;. Its old binding (before the rename) can be obtained using &lt;code&gt;evt.getOldBinding()&lt;/code&gt;. One of these may be null if the old/new binding was outside the scope in which the listener has registered interest.</source>
          <target state="translated">可以使用 &lt;code&gt;evt.getNewBinding()&lt;/code&gt; 获得重命名对象的绑定。可以使用 &lt;code&gt;evt.getOldBinding()&lt;/code&gt; 获得其旧的绑定（重命名之前）。如果旧/新绑定超出了侦听器已注册兴趣的范围，则其中之一可能为null。</target>
        </trans-unit>
        <trans-unit id="079c4a4960105f0bcb70c588ac7cf3a47369d2d9" translate="yes" xml:space="preserve">
          <source>The bit initially has the value &lt;code&gt;false&lt;/code&gt;, and the corresponding bit in the argument has the value &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">该位最初的值为 &lt;code&gt;false&lt;/code&gt; ，而参数中的相应位的值为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e4610a19fe62a2028d5853d8b6146bdb1583011d" translate="yes" xml:space="preserve">
          <source>The bit initially has the value &lt;code&gt;true&lt;/code&gt;, and the corresponding bit in the argument has the value &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">该位最初的值为 &lt;code&gt;true&lt;/code&gt; ，而参数中的相应位的值为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ff50d0696df1c1a5ec402d78f6f92cd39d7bbb84" translate="yes" xml:space="preserve">
          <source>The bit offset is reset to zero.</source>
          <target state="translated">位偏移量被重置为零。</target>
        </trans-unit>
        <trans-unit id="a4f3cc1d878069548160bce5242336d5060d3770" translate="yes" xml:space="preserve">
          <source>The bit offset is set to 0 when a stream is first opened, and is reset to 0 by calls to &lt;code&gt;seek&lt;/code&gt;, &lt;code&gt;skipBytes&lt;/code&gt;, or any &lt;code&gt;read&lt;/code&gt; or &lt;code&gt;readFully&lt;/code&gt; method.</source>
          <target state="translated">首次打开流时，位偏移设置为0，并通过调用 &lt;code&gt;seek&lt;/code&gt; ， &lt;code&gt;skipBytes&lt;/code&gt; 或任何 &lt;code&gt;read&lt;/code&gt; 或 &lt;code&gt;readFully&lt;/code&gt; 方法将其重置为0 。</target>
        </trans-unit>
        <trans-unit id="8c6a80445d0b4a5f294f45e1bc9db4bc04950ba0" translate="yes" xml:space="preserve">
          <source>The bit offset within the stream is ignored and treated as though it were zero.</source>
          <target state="translated">忽略流中的位偏移,并将其视为零。</target>
        </trans-unit>
        <trans-unit id="60ed439e4fa50c248e920b1ada61a8fb85641cf5" translate="yes" xml:space="preserve">
          <source>The bit offset within the stream is reset to zero before the read occurs.</source>
          <target state="translated">在读取发生之前,流内的位偏移被重置为零。</target>
        </trans-unit>
        <trans-unit id="d25884e217e3d3f03765741523ec4f8df4d1e73e" translate="yes" xml:space="preserve">
          <source>The bit offset within the stream must be reset to zero before the read occurs.</source>
          <target state="translated">在读取之前,流内的位偏移必须被重置为零。</target>
        </trans-unit>
        <trans-unit id="392be8ef692e481c422de130596efeb38786c416" translate="yes" xml:space="preserve">
          <source>The bit position used by the &lt;code&gt;readBits&lt;/code&gt; method is saved and restored by each pair of calls to &lt;code&gt;mark&lt;/code&gt; and &lt;code&gt;reset&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;readBits&lt;/code&gt; 方法使用的位位置通过每对 &lt;code&gt;mark&lt;/code&gt; 和 &lt;code&gt;reset&lt;/code&gt; 的调用来保存和恢复。</target>
        </trans-unit>
        <trans-unit id="e616b2a044370cc64835bc4bb4e31fc5edbf070f" translate="yes" xml:space="preserve">
          <source>The bit set must remain constant during the execution of the terminal stream operation. Otherwise, the result of the terminal stream operation is undefined.</source>
          <target state="translated">在执行终端流操作的过程中,所设置的位必须保持不变。否则,终端流操作的结果是不确定的。</target>
        </trans-unit>
        <trans-unit id="5cb03212f5537c4a0b8ecd683f1339aea4a69290" translate="yes" xml:space="preserve">
          <source>The block names supported by &lt;code&gt;Pattern&lt;/code&gt; are the valid block names accepted and defined by &lt;a href=&quot;../../lang/character.unicodeblock#forName-java.lang.String-&quot;&gt;&lt;code&gt;UnicodeBlock.forName&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Pattern&lt;/code&gt; 支持的块名称是&lt;a href=&quot;../../lang/character.unicodeblock#forName-java.lang.String-&quot;&gt; &lt;code&gt;UnicodeBlock.forName&lt;/code&gt; &lt;/a&gt;接受并定义的有效块名称。</target>
        </trans-unit>
        <trans-unit id="c9151392927171f66644b3edff8dd9467431d179" translate="yes" xml:space="preserve">
          <source>The blocking-mode lock object</source>
          <target state="translated">封锁模式的锁定对象</target>
        </trans-unit>
        <trans-unit id="c424f9ac5bce10e99f2c2880b959e00aa4b64679" translate="yes" xml:space="preserve">
          <source>The body of the default method is specified to be the code above.</source>
          <target state="translated">默认方法的主体被指定为上述代码。</target>
        </trans-unit>
        <trans-unit id="11a6748648cf5b00019dda6cf54e2eb8f3bf8d61" translate="yes" xml:space="preserve">
          <source>The body of the method or constructor declaration performs potentially unsafe operations, such as an assignment to an element of the variable arity parameter's array that generates an unchecked warning. Some unsafe operations do not trigger an unchecked warning. For example, the aliasing in</source>
          <target state="translated">方法或构造函数声明的主体执行了潜在的不安全操作,比如对变量arity参数的数组元素进行赋值,会产生一个未选中的警告。有些不安全的操作不会触发未选中的警告。例如,在</target>
        </trans-unit>
        <trans-unit id="b4e40444f8fc152eb16ab3eaf704c842ce4a6de9" translate="yes" xml:space="preserve">
          <source>The bootstrap method is invoked on at least three values:</source>
          <target state="translated">引导法至少在三个值上调用。</target>
        </trans-unit>
        <trans-unit id="cfae179ea42664d99bcc9a1d13b597aac8360806" translate="yes" xml:space="preserve">
          <source>The bottom input tray in the printer.</source>
          <target state="translated">打印机底部的输入托盘。</target>
        </trans-unit>
        <trans-unit id="1f35df29ba4c1a160c83b07bf44b764120a88cd3" translate="yes" xml:space="preserve">
          <source>The buffer is then cleared.</source>
          <target state="translated">然后清空缓冲区。</target>
        </trans-unit>
        <trans-unit id="4670c8f1cdd40c40a543b1304e16c713499f0559" translate="yes" xml:space="preserve">
          <source>The buffer size is specified in bytes, but must represent an integral number of sample frames. Invoking this method with a requested buffer size that does not meet this requirement may result in an IllegalArgumentException. The actual buffer size for the open line may differ from the requested buffer size. The value actually set may be queried by subsequently calling &lt;code&gt;&lt;a href=&quot;dataline#getBufferSize--&quot;&gt;&lt;code&gt;DataLine.getBufferSize()&lt;/code&gt;&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">缓冲区大小以字节为单位指定，但必须表示整数个样本帧。使用请求的不符合此要求的缓冲区大小调用此方法可能会导致IllegalArgumentException。空行的实际缓冲区大小可能与请求的缓冲区大小不同。可以通过随后调用 &lt;code&gt;&lt;a href=&quot;dataline#getBufferSize--&quot;&gt;&lt;code&gt;DataLine.getBufferSize()&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; 来查询实际设置的值。</target>
        </trans-unit>
        <trans-unit id="e3a95695f406bd68814b7b0423d52d5848fcda1f" translate="yes" xml:space="preserve">
          <source>The buffer size is specified in bytes, but must represent an integral number of sample frames. Invoking this method with a requested buffer size that does not meet this requirement may result in an IllegalArgumentException. The actual buffer size for the open line may differ from the requested buffer size. The value actually set may be queried by subsequently calling &lt;code&gt;&lt;a href=&quot;dataline#getBufferSize--&quot;&gt;&lt;code&gt;DataLine.getBufferSize()&lt;/code&gt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">缓冲区大小以字节为单位指定，但必须表示整数个样本帧。使用请求的不符合此要求的缓冲区大小调用此方法可能会导致IllegalArgumentException。空行的实际缓冲区大小可能与请求的缓冲区大小不同。可以通过随后调用 &lt;code&gt;&lt;a href=&quot;dataline#getBufferSize--&quot;&gt;&lt;code&gt;DataLine.getBufferSize()&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; 来查询实际设置的值。</target>
        </trans-unit>
        <trans-unit id="42d1dfe3731b63adb6323291fca8d27b9b77331b" translate="yes" xml:space="preserve">
          <source>The buffer size may be specified, or the default size may be accepted. The default is large enough for most purposes.</source>
          <target state="translated">可以指定缓冲区的大小,也可以接受默认大小。默认值足够大,可以满足大多数目的。</target>
        </trans-unit>
        <trans-unit id="8a55978bf856d3f06d55763ba0704c1f8c5f25a9" translate="yes" xml:space="preserve">
          <source>The buffer size may be specified, or the default size may be used. The default is large enough for most purposes.</source>
          <target state="translated">可以指定缓冲区的大小,也可以使用默认大小。默认大小足以满足大多数目的。</target>
        </trans-unit>
        <trans-unit id="1c56115fb03b357a45a3b5437c42a2575ecdf670" translate="yes" xml:space="preserve">
          <source>The buffer where data is stored.</source>
          <target state="translated">存储数据的缓冲区。</target>
        </trans-unit>
        <trans-unit id="054e837f56115320c3003e3d454659e29001c412" translate="yes" xml:space="preserve">
          <source>The buffer's position is set to the number of bytes copied, rather than to zero, so that an invocation of this method can be followed immediately by an invocation of another relative</source>
          <target state="translated">缓冲区的位置被设置为复制的字节数,而不是零,这样,在调用本方法之后,可以立即调用另一个相对的方法</target>
        </trans-unit>
        <trans-unit id="188fa3815ba94bd3d52f1e5d7a2b576e266716ff" translate="yes" xml:space="preserve">
          <source>The buffer's position is set to the number of chars copied, rather than to zero, so that an invocation of this method can be followed immediately by an invocation of another relative</source>
          <target state="translated">缓冲区的位置被设置为复制的字符数,而不是零,因此,在调用本方法后,可以立即调用另一个相对方法。</target>
        </trans-unit>
        <trans-unit id="268283661585dc5a43f5d101b5eb0cb7c4bd1ba0" translate="yes" xml:space="preserve">
          <source>The buffer's position is set to the number of doubles copied, rather than to zero, so that an invocation of this method can be followed immediately by an invocation of another relative</source>
          <target state="translated">缓冲区的位置被设置为复制的双倍数,而不是零,因此,在调用本方法之后,可以立即调用另一个相对方法</target>
        </trans-unit>
        <trans-unit id="a818e9c80711ad62073fa38012777538062ecb70" translate="yes" xml:space="preserve">
          <source>The buffer's position is set to the number of floats copied, rather than to zero, so that an invocation of this method can be followed immediately by an invocation of another relative</source>
          <target state="translated">缓冲区的位置被设置为复制的浮动数,而不是零,这样在调用本方法后可以立即调用另一个相对的方法。</target>
        </trans-unit>
        <trans-unit id="9b9ac4899062f4a8080e7bb42619ee1993a91107" translate="yes" xml:space="preserve">
          <source>The buffer's position is set to the number of ints copied, rather than to zero, so that an invocation of this method can be followed immediately by an invocation of another relative</source>
          <target state="translated">缓冲区的位置被设置为被复制的ints数,而不是零,所以在调用本方法后,可以立即调用另一个相对方法。</target>
        </trans-unit>
        <trans-unit id="74b0cc21acda56fdd53c62463623d224a17371a3" translate="yes" xml:space="preserve">
          <source>The buffer's position is set to the number of longs copied, rather than to zero, so that an invocation of this method can be followed immediately by an invocation of another relative</source>
          <target state="translated">缓冲区的位置被设置为被复制的长数,而不是零,这样在调用本方法后,可以立即调用另一个相对方法</target>
        </trans-unit>
        <trans-unit id="750514a6ac223b844a07865b20d67f5ea7c24baf" translate="yes" xml:space="preserve">
          <source>The buffer's position is set to the number of shorts copied, rather than to zero, so that an invocation of this method can be followed immediately by an invocation of another relative</source>
          <target state="translated">缓冲区的位置被设置为被复制的短线数量,而不是零,因此,在调用本方法之后,可以立即调用另一个相对的方法</target>
        </trans-unit>
        <trans-unit id="293bbf9dbaac98ff56c4b3e964c2a85c882bdba5" translate="yes" xml:space="preserve">
          <source>The buffers are read from, and written to, starting at their current positions. At most &lt;a href=&quot;../buffer#remaining--&quot;&gt;&lt;code&gt;in.remaining()&lt;/code&gt;&lt;/a&gt; bytes will be read and at most &lt;a href=&quot;../buffer#remaining--&quot;&gt;&lt;code&gt;out.remaining()&lt;/code&gt;&lt;/a&gt; characters will be written. The buffers' positions will be advanced to reflect the bytes read and the characters written, but their marks and limits will not be modified.</source>
          <target state="translated">从缓冲区的当前位置开始读取和写入缓冲区。最多&lt;a href=&quot;../buffer#remaining--&quot;&gt; &lt;code&gt;in.remaining()&lt;/code&gt; &lt;/a&gt;个字节，最多&lt;a href=&quot;../buffer#remaining--&quot;&gt; &lt;code&gt;out.remaining()&lt;/code&gt; &lt;/a&gt;字符。缓冲区的位置将提高，以反映读取的字节和写入的字符，但不会更改其标记和限​​制。</target>
        </trans-unit>
        <trans-unit id="63913af10c4a2a952523c8a79b63028c30d3d4bb" translate="yes" xml:space="preserve">
          <source>The buffers are read from, and written to, starting at their current positions. At most &lt;a href=&quot;../buffer#remaining--&quot;&gt;&lt;code&gt;in.remaining()&lt;/code&gt;&lt;/a&gt; bytes will be read, and at most &lt;a href=&quot;../buffer#remaining--&quot;&gt;&lt;code&gt;out.remaining()&lt;/code&gt;&lt;/a&gt; characters will be written. The buffers' positions will be advanced to reflect the bytes read and the characters written, but their marks and limits will not be modified.</source>
          <target state="translated">从缓冲区的当前位置开始读取和写入缓冲区。最多将读取&lt;a href=&quot;../buffer#remaining--&quot;&gt; &lt;code&gt;in.remaining()&lt;/code&gt; &lt;/a&gt;个字节，最多将写入&lt;a href=&quot;../buffer#remaining--&quot;&gt; &lt;code&gt;out.remaining()&lt;/code&gt; 个&lt;/a&gt;字符。缓冲区的位置将提高，以反映读取的字节和写入的字符，但不会更改其标记和限​​制。</target>
        </trans-unit>
        <trans-unit id="7ea75e8b0576a0fab591f0e6c8cfa51a7d1af8b0" translate="yes" xml:space="preserve">
          <source>The buffers are read from, and written to, starting at their current positions. At most &lt;a href=&quot;../buffer#remaining--&quot;&gt;&lt;code&gt;in.remaining()&lt;/code&gt;&lt;/a&gt; characters will be read and at most &lt;a href=&quot;../buffer#remaining--&quot;&gt;&lt;code&gt;out.remaining()&lt;/code&gt;&lt;/a&gt; bytes will be written. The buffers' positions will be advanced to reflect the characters read and the bytes written, but their marks and limits will not be modified.</source>
          <target state="translated">从缓冲区的当前位置开始读取和写入缓冲区。最多将读取&lt;a href=&quot;../buffer#remaining--&quot;&gt; &lt;code&gt;in.remaining()&lt;/code&gt; 个&lt;/a&gt;字符，最多将写入&lt;a href=&quot;../buffer#remaining--&quot;&gt; &lt;code&gt;out.remaining()&lt;/code&gt; &lt;/a&gt;个字节。缓冲区的位置将提高，以反映读取的字符和写入的字节，但不会更改其标记和限​​制。</target>
        </trans-unit>
        <trans-unit id="7363ecd6d3a0468acc64ed1a76fb03af75bdb558" translate="yes" xml:space="preserve">
          <source>The buffers are read from, and written to, starting at their current positions. At most &lt;a href=&quot;../buffer#remaining--&quot;&gt;&lt;code&gt;in.remaining()&lt;/code&gt;&lt;/a&gt; characters will be read, and at most &lt;a href=&quot;../buffer#remaining--&quot;&gt;&lt;code&gt;out.remaining()&lt;/code&gt;&lt;/a&gt; bytes will be written. The buffers' positions will be advanced to reflect the characters read and the bytes written, but their marks and limits will not be modified.</source>
          <target state="translated">从缓冲区的当前位置开始读取和写入缓冲区。最多将读取&lt;a href=&quot;../buffer#remaining--&quot;&gt; &lt;code&gt;in.remaining()&lt;/code&gt; 个&lt;/a&gt;字符，最多将写入&lt;a href=&quot;../buffer#remaining--&quot;&gt; &lt;code&gt;out.remaining()&lt;/code&gt; &lt;/a&gt;个字节。缓冲区的位置将提高，以反映读取的字符和写入的字节，但不会更改其标记和限​​制。</target>
        </trans-unit>
        <trans-unit id="0d6d45090b38927980128fdfc30c28845132395a" translate="yes" xml:space="preserve">
          <source>The builder can only be installed if the executing thread is allowed (by the security manager's checkSetFactory() method) to do so. Once installed, the builder cannot be replaced.</source>
          <target state="translated">只有当执行线程被允许(由安全管理器的checkSetFactory()方法)安装时,才能安装构建器。一旦安装,构建器就不能被替换。</target>
        </trans-unit>
        <trans-unit id="94162d4cf2c341f565021f495ec547084eb7ab50" translate="yes" xml:space="preserve">
          <source>The builder can only be installed if the executing thread is allowed by the security manager to do so. Once installed, the builder cannot be replaced.</source>
          <target state="translated">只有当安全管理器允许执行线程安装时,才能安装构建器。一旦安装,构建器就不能被替换。</target>
        </trans-unit>
        <trans-unit id="57bc2cca5ed13a9fc84b6171112f0807ef63a7e4" translate="yes" xml:space="preserve">
          <source>The bulk read operations &lt;a href=&quot;reader#read-char:A-&quot;&gt;&lt;code&gt;read(char[]) &lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;reader#read-char:A-int-int-&quot;&gt;&lt;code&gt;read(char[], int, int) &lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;reader#read-java.nio.CharBuffer-&quot;&gt;&lt;code&gt;read(java.nio.CharBuffer)&lt;/code&gt;&lt;/a&gt; on the returned object will not read in characters beyond the line bound for each invocation, even if the destination buffer has space for more characters. The &lt;code&gt;Reader&lt;/code&gt;'s &lt;code&gt;read&lt;/code&gt; methods may block if a line bound has not been entered or reached on the console's input device. A line bound is considered to be any one of a line feed (&lt;code&gt;'\n'&lt;/code&gt;), a carriage return (&lt;code&gt;'\r'&lt;/code&gt;), a carriage return followed immediately by a linefeed, or an end of stream.</source>
          <target state="translated">返回的对象上的批量读取操作&lt;a href=&quot;reader#read-char:A-&quot;&gt; &lt;code&gt;read(char[]) &lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;reader#read-char:A-int-int-&quot;&gt; &lt;code&gt;read(char[], int, int) &lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;reader#read-java.nio.CharBuffer-&quot;&gt; &lt;code&gt;read(java.nio.CharBuffer)&lt;/code&gt; &lt;/a&gt;不会读取超出每次调用限制的字符，即使目标缓冲区有更多字符可用空间。该 &lt;code&gt;Reader&lt;/code&gt; 的 &lt;code&gt;read&lt;/code&gt; ，如果结合线尚未进入或控制台输入设备上达到的方法可以阻止。换行符被认为是换行符（ &lt;code&gt;'\n'&lt;/code&gt; ），回车符（ &lt;code&gt;'\r'&lt;/code&gt; ），回车符后紧跟换行符或流末尾中的任何一个。</target>
        </trans-unit>
        <trans-unit id="4906528df4e968c4a2fd97b5d59c3f8587333b5e" translate="yes" xml:space="preserve">
          <source>The bundle name is obtained by calling &lt;a href=&quot;resourcebundle.control#toBundleName-java.lang.String-java.util.Locale-&quot;&gt;&lt;code&gt;toBundleName(baseName,
 locale)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通过调用&lt;a href=&quot;resourcebundle.control#toBundleName-java.lang.String-java.util.Locale-&quot;&gt; &lt;code&gt;toBundleName(baseName, locale)&lt;/code&gt; &lt;/a&gt;获得捆绑软件名称。</target>
        </trans-unit>
        <trans-unit id="a4a52b4593f9a8a8dd2e70ebe00138c0d2b17c41" translate="yes" xml:space="preserve">
          <source>The byte array referenced by an &lt;code&gt;IIOByteBuffer&lt;/code&gt; will generally be part of an internal data structure belonging to an &lt;code&gt;ImageReader&lt;/code&gt; implementation; its contents should be considered read-only and must not be modified.</source>
          <target state="translated">&lt;code&gt;IIOByteBuffer&lt;/code&gt; 引用的字节数组通常是属于 &lt;code&gt;ImageReader&lt;/code&gt; 实现的内部数据结构的一部分；其内容应被视为只读，并且不得修改。</target>
        </trans-unit>
        <trans-unit id="1355d05c2748f9dfcf75dbdc8ead75958008b92d" translate="yes" xml:space="preserve">
          <source>The byte at the buffer's current position</source>
          <target state="translated">缓冲区当前位置的字节。</target>
        </trans-unit>
        <trans-unit id="47ca471c96d31b5f0031a2837a68bf4083a1dc36" translate="yes" xml:space="preserve">
          <source>The byte at the given index</source>
          <target state="translated">给定索引的字节</target>
        </trans-unit>
        <trans-unit id="deb4c87efe1222286df56bf2a615595a08fdcbc1" translate="yes" xml:space="preserve">
          <source>The byte buffer is not modified by this method, and no reference to the buffer is retained by the bit set.</source>
          <target state="translated">该方法不会修改字节缓冲区,也不会通过设置位保留对缓冲区的引用。</target>
        </trans-unit>
        <trans-unit id="1ccd18330dd5450f1b6655054edb6878c9c12957" translate="yes" xml:space="preserve">
          <source>The byte order has no effect on the results returned from the &lt;code&gt;readBits&lt;/code&gt; method (or the value written by &lt;code&gt;ImageOutputStream.writeBits&lt;/code&gt;).</source>
          <target state="translated">字节顺序对从 &lt;code&gt;readBits&lt;/code&gt; 方法返回的结果（或 &lt;code&gt;ImageOutputStream.writeBits&lt;/code&gt; 写入的值）没有影响。</target>
        </trans-unit>
        <trans-unit id="14aafe7666eb5797f1333016b720d9c302895a7b" translate="yes" xml:space="preserve">
          <source>The byte order is used when reading or writing multibyte values, and when creating buffers that are views of this byte buffer. The order of a newly-created byte buffer is always &lt;a href=&quot;byteorder#BIG_ENDIAN&quot;&gt;&lt;code&gt;BIG_ENDIAN&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在读取或写入多字节值以及创建作为此字节缓冲区视图的缓冲区时，将使用字节顺序。新创建的字节缓冲区的顺序始终为&lt;a href=&quot;byteorder#BIG_ENDIAN&quot;&gt; &lt;code&gt;BIG_ENDIAN&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9cc687ee55e65629bf7cb07b117a3609d5c3c138" translate="yes" xml:space="preserve">
          <source>The byte order of a char buffer created by allocation or by wrapping an existing &lt;code&gt;char&lt;/code&gt; array is the &lt;a href=&quot;byteorder#nativeOrder--&quot;&gt;&lt;code&gt;native order&lt;/code&gt;&lt;/a&gt; of the underlying hardware. The byte order of a char buffer created as a &lt;a href=&quot;bytebuffer#views&quot;&gt;view&lt;/a&gt; of a byte buffer is that of the byte buffer at the moment that the view is created.</source>
          <target state="translated">通过分配或包装现有 &lt;code&gt;char&lt;/code&gt; 数组创建的char缓冲区的字节顺序是基础硬件的&lt;a href=&quot;byteorder#nativeOrder--&quot;&gt; &lt;code&gt;native order&lt;/code&gt; &lt;/a&gt;。创建为字节缓冲区&lt;a href=&quot;bytebuffer#views&quot;&gt;视图&lt;/a&gt;的char缓冲区的字节顺序是创建视图时字节缓冲区的字节顺序。</target>
        </trans-unit>
        <trans-unit id="0b6816216a3e49126f17437c6afe4b84167bb241" translate="yes" xml:space="preserve">
          <source>The byte order of a double buffer created by allocation or by wrapping an existing &lt;code&gt;double&lt;/code&gt; array is the &lt;a href=&quot;byteorder#nativeOrder--&quot;&gt;&lt;code&gt;native order&lt;/code&gt;&lt;/a&gt; of the underlying hardware. The byte order of a double buffer created as a &lt;a href=&quot;bytebuffer#views&quot;&gt;view&lt;/a&gt; of a byte buffer is that of the byte buffer at the moment that the view is created.</source>
          <target state="translated">通过分配或包装现有的 &lt;code&gt;double&lt;/code&gt; 数组创建的double缓冲区的字节顺序是基础硬件的&lt;a href=&quot;byteorder#nativeOrder--&quot;&gt; &lt;code&gt;native order&lt;/code&gt; &lt;/a&gt;。创建为字节缓冲区&lt;a href=&quot;bytebuffer#views&quot;&gt;视图&lt;/a&gt;的双缓冲区的字节顺序是创建视图时字节缓冲区的字节顺序。</target>
        </trans-unit>
        <trans-unit id="44939b5e6d7ee751fc60184ae79f1bdd2b79b9e1" translate="yes" xml:space="preserve">
          <source>The byte order of a float buffer created by allocation or by wrapping an existing &lt;code&gt;float&lt;/code&gt; array is the &lt;a href=&quot;byteorder#nativeOrder--&quot;&gt;&lt;code&gt;native order&lt;/code&gt;&lt;/a&gt; of the underlying hardware. The byte order of a float buffer created as a &lt;a href=&quot;bytebuffer#views&quot;&gt;view&lt;/a&gt; of a byte buffer is that of the byte buffer at the moment that the view is created.</source>
          <target state="translated">通过分配或包装现有的 &lt;code&gt;float&lt;/code&gt; 数组创建的float缓冲区的字节顺序是基础硬件的&lt;a href=&quot;byteorder#nativeOrder--&quot;&gt; &lt;code&gt;native order&lt;/code&gt; &lt;/a&gt;。创建为字节缓冲区&lt;a href=&quot;bytebuffer#views&quot;&gt;视图&lt;/a&gt;的浮点缓冲区的字节顺序是创建视图时字节缓冲区的字节顺序。</target>
        </trans-unit>
        <trans-unit id="e097a7b495f686009fc938ec60647ad742832ccc" translate="yes" xml:space="preserve">
          <source>The byte order of a long buffer created by allocation or by wrapping an existing &lt;code&gt;long&lt;/code&gt; array is the &lt;a href=&quot;byteorder#nativeOrder--&quot;&gt;&lt;code&gt;native order&lt;/code&gt;&lt;/a&gt; of the underlying hardware. The byte order of a long buffer created as a &lt;a href=&quot;bytebuffer#views&quot;&gt;view&lt;/a&gt; of a byte buffer is that of the byte buffer at the moment that the view is created.</source>
          <target state="translated">通过分配或包装现有的 &lt;code&gt;long&lt;/code&gt; 数组创建的long缓冲区的字节顺序是基础硬件的&lt;a href=&quot;byteorder#nativeOrder--&quot;&gt; &lt;code&gt;native order&lt;/code&gt; &lt;/a&gt;。创建为字节缓冲区&lt;a href=&quot;bytebuffer#views&quot;&gt;视图&lt;/a&gt;的长缓冲区的字节顺序是创建视图时字节缓冲区的字节顺序。</target>
        </trans-unit>
        <trans-unit id="cfc5f284c55f0850787d4daf099cb8d1f252d53e" translate="yes" xml:space="preserve">
          <source>The byte order of a short buffer created by allocation or by wrapping an existing &lt;code&gt;short&lt;/code&gt; array is the &lt;a href=&quot;byteorder#nativeOrder--&quot;&gt;&lt;code&gt;native order&lt;/code&gt;&lt;/a&gt; of the underlying hardware. The byte order of a short buffer created as a &lt;a href=&quot;bytebuffer#views&quot;&gt;view&lt;/a&gt; of a byte buffer is that of the byte buffer at the moment that the view is created.</source>
          <target state="translated">通过分配或包装现有的 &lt;code&gt;short&lt;/code&gt; 数组创建的short缓冲区的字节顺序是基础硬件的&lt;a href=&quot;byteorder#nativeOrder--&quot;&gt; &lt;code&gt;native order&lt;/code&gt; &lt;/a&gt;。创建为字节缓冲区&lt;a href=&quot;bytebuffer#views&quot;&gt;视图&lt;/a&gt;的短缓冲区的字节顺序是创建视图时字节缓冲区的字节顺序。</target>
        </trans-unit>
        <trans-unit id="d329e5f47c9a84dc8e2b980d1c0c0a36a749cba2" translate="yes" xml:space="preserve">
          <source>The byte order of a view buffer is fixed to be that of its byte buffer at the time that the view is created.</source>
          <target state="translated">视图缓冲区的字节顺序固定为创建视图时其字节缓冲区的顺序。</target>
        </trans-unit>
        <trans-unit id="7e6b38e4e4aefc9d62ff65054f43aab5864326e1" translate="yes" xml:space="preserve">
          <source>The byte order of an int buffer created by allocation or by wrapping an existing &lt;code&gt;int&lt;/code&gt; array is the &lt;a href=&quot;byteorder#nativeOrder--&quot;&gt;&lt;code&gt;native order&lt;/code&gt;&lt;/a&gt; of the underlying hardware. The byte order of an int buffer created as a &lt;a href=&quot;bytebuffer#views&quot;&gt;view&lt;/a&gt; of a byte buffer is that of the byte buffer at the moment that the view is created.</source>
          <target state="translated">通过分配或包装现有 &lt;code&gt;int&lt;/code&gt; 数组创建的int缓冲区的字节顺序是基础硬件的&lt;a href=&quot;byteorder#nativeOrder--&quot;&gt; &lt;code&gt;native order&lt;/code&gt; &lt;/a&gt;。创建为字节缓冲区&lt;a href=&quot;bytebuffer#views&quot;&gt;视图&lt;/a&gt;的int缓冲区的字节顺序是创建视图时字节缓冲区的字节顺序。</target>
        </trans-unit>
        <trans-unit id="922b6475bb7c93120f18c536157006a342e40842" translate="yes" xml:space="preserve">
          <source>The byte order of the stream as an instance of the enumeration class &lt;code&gt;java.nio.ByteOrder&lt;/code&gt;, where &lt;code&gt;ByteOrder.BIG_ENDIAN&lt;/code&gt; indicates network byte order and &lt;code&gt;ByteOrder.LITTLE_ENDIAN&lt;/code&gt; indicates the reverse order. By default, the value is &lt;code&gt;ByteOrder.BIG_ENDIAN&lt;/code&gt;.</source>
          <target state="translated">作为枚举类 &lt;code&gt;java.nio.ByteOrder&lt;/code&gt; 的实例的流的字节顺序，其中 &lt;code&gt;ByteOrder.BIG_ENDIAN&lt;/code&gt; 指示网络字节顺序，而 &lt;code&gt;ByteOrder.LITTLE_ENDIAN&lt;/code&gt; 指示相反的顺序。默认情况下，值为 &lt;code&gt;ByteOrder.BIG_ENDIAN&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3ac99f08420b0a24dc629e953b4fd8055fd1229b" translate="yes" xml:space="preserve">
          <source>The byte order of the stream has no effect on this method. The return value of this method is constructed as though the bits were read one at a time, and shifted into the right side of the return value, as shown by the following pseudo-code:</source>
          <target state="translated">流的字节顺序对这个方法没有影响。本方法的返回值的构造就像一次读取一个比特,并将其移到返回值的右侧,如下面的伪代码所示。</target>
        </trans-unit>
        <trans-unit id="e98750b98cb578117e4a7b03d9689b363791d254" translate="yes" xml:space="preserve">
          <source>The bytes between the buffer's current position and its limit, if any, are copied to the beginning of the buffer. That is, the byte at index</source>
          <target state="translated">缓冲区当前位置和极限之间的字节(如果有的话)被复制到缓冲区的开头。也就是说,位于索引</target>
        </trans-unit>
        <trans-unit id="fdb617b55c781ce6016c87e15df5a36aff81d4fc" translate="yes" xml:space="preserve">
          <source>The bytes in the &lt;code&gt;input&lt;/code&gt; buffer are processed, and the result is stored in a new buffer.</source>
          <target state="translated">处理 &lt;code&gt;input&lt;/code&gt; 缓冲区中的字节，并将结果存储在新缓冲区中。</target>
        </trans-unit>
        <trans-unit id="c3be3ee4e2ba1705b0819316619d526cd4ca38d3" translate="yes" xml:space="preserve">
          <source>The bytes in the &lt;code&gt;input&lt;/code&gt; buffer, and any input bytes that may have been buffered during a previous &lt;code&gt;update&lt;/code&gt; operation, are processed, with padding (if requested) being applied. If an AEAD mode such as GCM/CCM is being used, the authentication tag is appended in the case of encryption, or verified in the case of decryption. The result is stored in a new buffer.</source>
          <target state="translated">处理 &lt;code&gt;input&lt;/code&gt; 缓冲区中的字节，以及在先前的 &lt;code&gt;update&lt;/code&gt; 操作期间可能已缓冲的所有输入字节，并使用填充（如果请求）。如果使用的是AEAD模式（例如GCM / CCM），则在加密的情况下会附加身份验证标签，而在解密的情况下会验证身份标签。结果存储在新缓冲区中。</target>
        </trans-unit>
        <trans-unit id="e8477b1431e21fbd46bb1ccf3bf62d71fd8b63b6" translate="yes" xml:space="preserve">
          <source>The bytes that constitute the DES key are those between &lt;code&gt;key[0]&lt;/code&gt; and &lt;code&gt;key[7]&lt;/code&gt; inclusive.</source>
          <target state="translated">构成DES密钥的字节是 &lt;code&gt;key[0]&lt;/code&gt; 和 &lt;code&gt;key[7]&lt;/code&gt; 之间的字节。</target>
        </trans-unit>
        <trans-unit id="a3f2da7875cad1eeed18f83a8d95ae13c715aa4e" translate="yes" xml:space="preserve">
          <source>The bytes that constitute the DES key are those between &lt;code&gt;key[offset]&lt;/code&gt; and &lt;code&gt;key[offset+7]&lt;/code&gt; inclusive.</source>
          <target state="translated">组成DES密钥的字节是 &lt;code&gt;key[offset]&lt;/code&gt; 和 &lt;code&gt;key[offset+7]&lt;/code&gt; 之间的字节。</target>
        </trans-unit>
        <trans-unit id="f4fa0678e8609555f8143e63e8b2f158ff878621" translate="yes" xml:space="preserve">
          <source>The bytes that constitute the DES-EDE key are those between &lt;code&gt;key[0]&lt;/code&gt; and &lt;code&gt;key[23]&lt;/code&gt; inclusive</source>
          <target state="translated">组成DES-EDE密钥的字节在之间 &lt;code&gt;key[0]&lt;/code&gt; 和 &lt;code&gt;key[23]&lt;/code&gt; 含</target>
        </trans-unit>
        <trans-unit id="13305bd13aac1472ef1037068afe772ad0fb4273" translate="yes" xml:space="preserve">
          <source>The bytes that constitute the DES-EDE key are those between &lt;code&gt;key[offset]&lt;/code&gt; and &lt;code&gt;key[offset+23]&lt;/code&gt; inclusive.</source>
          <target state="translated">组成DES-EDE密钥的字节是 &lt;code&gt;key[offset]&lt;/code&gt; 和 &lt;code&gt;key[offset+23]&lt;/code&gt; 之间的字节。</target>
        </trans-unit>
        <trans-unit id="3067e974cc7fdd3a9dfe76018048100635f25890" translate="yes" xml:space="preserve">
          <source>The bytes that constitute the IV are those between &lt;code&gt;iv[0]&lt;/code&gt; and &lt;code&gt;iv[7]&lt;/code&gt; inclusive.</source>
          <target state="translated">构成IV的字节是 &lt;code&gt;iv[0]&lt;/code&gt; 和 &lt;code&gt;iv[7]&lt;/code&gt; 之间的字节。</target>
        </trans-unit>
        <trans-unit id="e88aa68f8ceb389a17299b0b745903e72581ad9c" translate="yes" xml:space="preserve">
          <source>The bytes that constitute the IV are those between &lt;code&gt;iv[offset]&lt;/code&gt; and &lt;code&gt;iv[offset+len-1]&lt;/code&gt; inclusive.</source>
          <target state="translated">构成IV的字节在 &lt;code&gt;iv[offset]&lt;/code&gt; 和 &lt;code&gt;iv[offset+len-1]&lt;/code&gt; 含端点）。</target>
        </trans-unit>
        <trans-unit id="c171e0871451b5bcb88b7ecb2eba3ec410b4a9a1" translate="yes" xml:space="preserve">
          <source>The bytes that constitute the secret key are those between &lt;code&gt;key[offset]&lt;/code&gt; and &lt;code&gt;key[offset+len-1]&lt;/code&gt; inclusive.</source>
          <target state="translated">构成密钥的字节是 &lt;code&gt;key[offset]&lt;/code&gt; 和 &lt;code&gt;key[offset+len-1]&lt;/code&gt; 之间的字节（包括两个字节）。</target>
        </trans-unit>
        <trans-unit id="a5b7d43b7dabc9df1454a8ff820a35700bfc1b23" translate="yes" xml:space="preserve">
          <source>The bytes written by this method may be read by the &lt;code&gt;readChar&lt;/code&gt; method of interface &lt;code&gt;DataInput&lt;/code&gt; , which will then return a &lt;code&gt;char&lt;/code&gt; equal to &lt;code&gt;(char)v&lt;/code&gt;.</source>
          <target state="translated">字节此方法写入可以由读取 &lt;code&gt;readChar&lt;/code&gt; 接口的方法 &lt;code&gt;DataInput&lt;/code&gt; ，然后将返回一个 &lt;code&gt;char&lt;/code&gt; 等于 &lt;code&gt;(char)v&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0b95387b94a86af5779949aa0a20e886731ea4d4" translate="yes" xml:space="preserve">
          <source>The bytes written by this method may be read by the &lt;code&gt;readInt&lt;/code&gt; method of interface &lt;code&gt;DataInput&lt;/code&gt; , which will then return an &lt;code&gt;int&lt;/code&gt; equal to &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">可以通过 &lt;code&gt;DataInput&lt;/code&gt; 接口的 &lt;code&gt;readInt&lt;/code&gt; 方法读取此方法写入的字节，该方法然后将返回一个等于 &lt;code&gt;v&lt;/code&gt; 的 &lt;code&gt;int&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b00736a5ccdb8c5c715cbbbfdd29b8aa3e9af1ac" translate="yes" xml:space="preserve">
          <source>The bytes written by this method may be read by the &lt;code&gt;readLong&lt;/code&gt; method of interface &lt;code&gt;DataInput&lt;/code&gt; , which will then return a &lt;code&gt;long&lt;/code&gt; equal to &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">可以通过 &lt;code&gt;DataInput&lt;/code&gt; 接口的 &lt;code&gt;readLong&lt;/code&gt; 方法读取此方法写入的字节，该方法将返回一个等于 &lt;code&gt;v&lt;/code&gt; 的 &lt;code&gt;long&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3565a4ba0097da0e53b33f2f269c8a9843ebdfdd" translate="yes" xml:space="preserve">
          <source>The bytes written by this method may be read by the &lt;code&gt;readShort&lt;/code&gt; method of interface &lt;code&gt;DataInput&lt;/code&gt; , which will then return a &lt;code&gt;short&lt;/code&gt; equal to &lt;code&gt;(short)v&lt;/code&gt;.</source>
          <target state="translated">字节此方法写入可以由读取 &lt;code&gt;readShort&lt;/code&gt; 的接口方法 &lt;code&gt;DataInput&lt;/code&gt; ，然后将返回一个 &lt;code&gt;short&lt;/code&gt; 等于 &lt;code&gt;(short)v&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="594b8e0f4367854f5fec1f1e47e81634970cee0b" translate="yes" xml:space="preserve">
          <source>The bytes written by this method may be read by the &lt;code&gt;readUTF&lt;/code&gt; method of interface &lt;code&gt;DataInput&lt;/code&gt; , which will then return a &lt;code&gt;String&lt;/code&gt; equal to &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">可以通过 &lt;code&gt;DataInput&lt;/code&gt; 接口的 &lt;code&gt;readUTF&lt;/code&gt; 方法读取此方法写入的字节，然后该方法将返回一个等于 &lt;code&gt;s&lt;/code&gt; 的 &lt;code&gt;String&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="31fa5f9fc9eed95eef4be0210ae43d26c7263f6c" translate="yes" xml:space="preserve">
          <source>The cache may reside in main memory or on disk. Setting this flag to &lt;code&gt;false&lt;/code&gt; disallows the use of disk for future streams, which may be advantageous when working with small images, as the overhead of creating and destroying files is removed.</source>
          <target state="translated">缓存可以驻留在主内存中或磁盘上。将此标志设置为 &lt;code&gt;false&lt;/code&gt; 禁止将磁盘用于将来的流，这在处理小映像时可能是有利的，因为消除了创建和销毁文件的开销。</target>
        </trans-unit>
        <trans-unit id="2bc9e50f825b3431afd7e5a709accec3607181e7" translate="yes" xml:space="preserve">
          <source>The cached MBeanInfo for that MBean, if not null, or a newly built MBeanInfo if none was cached.</source>
          <target state="translated">该MBean的缓存MBeanInfo,如果不是空的,或者新建的MBeanInfo,如果没有缓存。</target>
        </trans-unit>
        <trans-unit id="0ab46aaa358cbc9d48861d7c404420fc26ce55fe" translate="yes" xml:space="preserve">
          <source>The cached MBeanInfo, or null if no MBeanInfo is cached.</source>
          <target state="translated">缓存的MBeanInfo,如果没有缓存MBeanInfo则为空。</target>
        </trans-unit>
        <trans-unit id="b831b6b8d71a342113c94aa040943ab0817aea9b" translate="yes" xml:space="preserve">
          <source>The caching flag is designed to allow provider implementations to prevent the rules being cached in &lt;code&gt;ZoneId&lt;/code&gt;. Under normal circumstances, the caching of zone rules is highly desirable as it will provide greater performance. However, there is a use case where the caching would not be desirable, see &lt;a href=&quot;zonerulesprovider#provideRules-java.lang.String-boolean-&quot;&gt;&lt;code&gt;provideRules(java.lang.String, boolean)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">缓存标志旨在允许提供程序实现防止将规则缓存在 &lt;code&gt;ZoneId&lt;/code&gt; 中。在正常情况下，非常需要缓存区域规则，因为它会提供更高的性能。但是，在&lt;a href=&quot;zonerulesprovider#provideRules-java.lang.String-boolean-&quot;&gt; &lt;code&gt;provideRules(java.lang.String, boolean)&lt;/code&gt; &lt;/a&gt;用例中，缓存是不理想的，请参见ProvideRules（java.lang.String，boolean）。</target>
        </trans-unit>
        <trans-unit id="b0e896df123d4b65bbbe5a4dafe244dbddcdea17" translate="yes" xml:space="preserve">
          <source>The calculation for date and time units differ.</source>
          <target state="translated">日期和时间单位的计算方法不同。</target>
        </trans-unit>
        <trans-unit id="3f9bfb97f566a996492a90ed855eda8eef86861b" translate="yes" xml:space="preserve">
          <source>The calculation is delegated to the amount object by calling &lt;a href=&quot;temporal/temporalamount#addTo-java.time.temporal.Temporal-&quot;&gt;&lt;code&gt;TemporalAmount.addTo(Temporal)&lt;/code&gt;&lt;/a&gt;. The amount implementation is free to implement the addition in any way it wishes, however it typically calls back to &lt;a href=&quot;instant#plus-long-java.time.temporal.TemporalUnit-&quot;&gt;&lt;code&gt;plus(long, TemporalUnit)&lt;/code&gt;&lt;/a&gt;. Consult the documentation of the amount implementation to determine if it can be successfully added.</source>
          <target state="translated">通过调用&lt;a href=&quot;temporal/temporalamount#addTo-java.time.temporal.Temporal-&quot;&gt; &lt;code&gt;TemporalAmount.addTo(Temporal)&lt;/code&gt; &lt;/a&gt;将计算委托给金额对象。数量实现可以自由地以其希望的任何方式实现加法，但是通常会回调到&lt;a href=&quot;instant#plus-long-java.time.temporal.TemporalUnit-&quot;&gt; &lt;code&gt;plus(long, TemporalUnit)&lt;/code&gt; &lt;/a&gt;。请查阅金额实现的文档，以确定是否可以成功添加。</target>
        </trans-unit>
        <trans-unit id="d36a13c282a1a0db204d6e433edc37043d6d0a0c" translate="yes" xml:space="preserve">
          <source>The calculation is delegated to the amount object by calling &lt;a href=&quot;temporal/temporalamount#addTo-java.time.temporal.Temporal-&quot;&gt;&lt;code&gt;TemporalAmount.addTo(Temporal)&lt;/code&gt;&lt;/a&gt;. The amount implementation is free to implement the addition in any way it wishes, however it typically calls back to &lt;a href=&quot;localdate#plus-long-java.time.temporal.TemporalUnit-&quot;&gt;&lt;code&gt;plus(long, TemporalUnit)&lt;/code&gt;&lt;/a&gt;. Consult the documentation of the amount implementation to determine if it can be successfully added.</source>
          <target state="translated">通过调用&lt;a href=&quot;temporal/temporalamount#addTo-java.time.temporal.Temporal-&quot;&gt; &lt;code&gt;TemporalAmount.addTo(Temporal)&lt;/code&gt; &lt;/a&gt;将计算委托给金额对象。数量实现可以自由地以其希望的任何方式实现加法，但是通常会回调到&lt;a href=&quot;localdate#plus-long-java.time.temporal.TemporalUnit-&quot;&gt; &lt;code&gt;plus(long, TemporalUnit)&lt;/code&gt; &lt;/a&gt;。请查阅金额实现的文档，以确定是否可以成功添加。</target>
        </trans-unit>
        <trans-unit id="405fd7a334255c2eb1f7b060d385c4b26c0c094f" translate="yes" xml:space="preserve">
          <source>The calculation is delegated to the amount object by calling &lt;a href=&quot;temporal/temporalamount#addTo-java.time.temporal.Temporal-&quot;&gt;&lt;code&gt;TemporalAmount.addTo(Temporal)&lt;/code&gt;&lt;/a&gt;. The amount implementation is free to implement the addition in any way it wishes, however it typically calls back to &lt;a href=&quot;localdatetime#plus-long-java.time.temporal.TemporalUnit-&quot;&gt;&lt;code&gt;plus(long, TemporalUnit)&lt;/code&gt;&lt;/a&gt;. Consult the documentation of the amount implementation to determine if it can be successfully added.</source>
          <target state="translated">通过调用&lt;a href=&quot;temporal/temporalamount#addTo-java.time.temporal.Temporal-&quot;&gt; &lt;code&gt;TemporalAmount.addTo(Temporal)&lt;/code&gt; &lt;/a&gt;将计算委托给金额对象。数量实现可以自由地以其希望的任何方式实现加法，但是通常会回调到&lt;a href=&quot;localdatetime#plus-long-java.time.temporal.TemporalUnit-&quot;&gt; &lt;code&gt;plus(long, TemporalUnit)&lt;/code&gt; &lt;/a&gt;。请查阅金额实现的文档，以确定是否可以成功添加。</target>
        </trans-unit>
        <trans-unit id="337784a3c16463d8f2a1d05d69b5de99101c53f9" translate="yes" xml:space="preserve">
          <source>The calculation is delegated to the amount object by calling &lt;a href=&quot;temporal/temporalamount#addTo-java.time.temporal.Temporal-&quot;&gt;&lt;code&gt;TemporalAmount.addTo(Temporal)&lt;/code&gt;&lt;/a&gt;. The amount implementation is free to implement the addition in any way it wishes, however it typically calls back to &lt;a href=&quot;localtime#plus-long-java.time.temporal.TemporalUnit-&quot;&gt;&lt;code&gt;plus(long, TemporalUnit)&lt;/code&gt;&lt;/a&gt;. Consult the documentation of the amount implementation to determine if it can be successfully added.</source>
          <target state="translated">通过调用&lt;a href=&quot;temporal/temporalamount#addTo-java.time.temporal.Temporal-&quot;&gt; &lt;code&gt;TemporalAmount.addTo(Temporal)&lt;/code&gt; &lt;/a&gt;将计算委托给金额对象。数量实现可以自由地以其希望的任何方式实现加法，但是通常会回调到&lt;a href=&quot;localtime#plus-long-java.time.temporal.TemporalUnit-&quot;&gt; &lt;code&gt;plus(long, TemporalUnit)&lt;/code&gt; &lt;/a&gt;。请查阅金额实现的文档，以确定是否可以成功添加。</target>
        </trans-unit>
        <trans-unit id="8944e4ffa7476e40cdbb6ed5d28a69895c14f3d9" translate="yes" xml:space="preserve">
          <source>The calculation is delegated to the amount object by calling &lt;a href=&quot;temporal/temporalamount#addTo-java.time.temporal.Temporal-&quot;&gt;&lt;code&gt;TemporalAmount.addTo(Temporal)&lt;/code&gt;&lt;/a&gt;. The amount implementation is free to implement the addition in any way it wishes, however it typically calls back to &lt;a href=&quot;offsetdatetime#plus-long-java.time.temporal.TemporalUnit-&quot;&gt;&lt;code&gt;plus(long, TemporalUnit)&lt;/code&gt;&lt;/a&gt;. Consult the documentation of the amount implementation to determine if it can be successfully added.</source>
          <target state="translated">通过调用&lt;a href=&quot;temporal/temporalamount#addTo-java.time.temporal.Temporal-&quot;&gt; &lt;code&gt;TemporalAmount.addTo(Temporal)&lt;/code&gt; &lt;/a&gt;将计算委托给金额对象。数量实现可以自由地以其希望的任何方式实现加法，但是通常会回调到&lt;a href=&quot;offsetdatetime#plus-long-java.time.temporal.TemporalUnit-&quot;&gt; &lt;code&gt;plus(long, TemporalUnit)&lt;/code&gt; &lt;/a&gt;。请查阅金额实现的文档，以确定是否可以成功添加。</target>
        </trans-unit>
        <trans-unit id="5fc94b4fc685ed04a2ebd12ecf82c33d700c679e" translate="yes" xml:space="preserve">
          <source>The calculation is delegated to the amount object by calling &lt;a href=&quot;temporal/temporalamount#addTo-java.time.temporal.Temporal-&quot;&gt;&lt;code&gt;TemporalAmount.addTo(Temporal)&lt;/code&gt;&lt;/a&gt;. The amount implementation is free to implement the addition in any way it wishes, however it typically calls back to &lt;a href=&quot;offsettime#plus-long-java.time.temporal.TemporalUnit-&quot;&gt;&lt;code&gt;plus(long, TemporalUnit)&lt;/code&gt;&lt;/a&gt;. Consult the documentation of the amount implementation to determine if it can be successfully added.</source>
          <target state="translated">通过调用&lt;a href=&quot;temporal/temporalamount#addTo-java.time.temporal.Temporal-&quot;&gt; &lt;code&gt;TemporalAmount.addTo(Temporal)&lt;/code&gt; &lt;/a&gt;将计算委托给金额对象。数量实现可以自由地以其希望的任何方式实现加法，但是通常会回调到&lt;a href=&quot;offsettime#plus-long-java.time.temporal.TemporalUnit-&quot;&gt; &lt;code&gt;plus(long, TemporalUnit)&lt;/code&gt; &lt;/a&gt;。请查阅金额实现的文档，以确定是否可以成功添加。</target>
        </trans-unit>
        <trans-unit id="1cfef65ed1bb6a95bbe63ebf74cdcb10c5ecd139" translate="yes" xml:space="preserve">
          <source>The calculation is delegated to the amount object by calling &lt;a href=&quot;temporal/temporalamount#addTo-java.time.temporal.Temporal-&quot;&gt;&lt;code&gt;TemporalAmount.addTo(Temporal)&lt;/code&gt;&lt;/a&gt;. The amount implementation is free to implement the addition in any way it wishes, however it typically calls back to &lt;a href=&quot;year#plus-long-java.time.temporal.TemporalUnit-&quot;&gt;&lt;code&gt;plus(long, TemporalUnit)&lt;/code&gt;&lt;/a&gt;. Consult the documentation of the amount implementation to determine if it can be successfully added.</source>
          <target state="translated">通过调用&lt;a href=&quot;temporal/temporalamount#addTo-java.time.temporal.Temporal-&quot;&gt; &lt;code&gt;TemporalAmount.addTo(Temporal)&lt;/code&gt; &lt;/a&gt;将计算委托给金额对象。数量实现可以自由地以其希望的任何方式实现加法，但是通常会回调到&lt;a href=&quot;year#plus-long-java.time.temporal.TemporalUnit-&quot;&gt; &lt;code&gt;plus(long, TemporalUnit)&lt;/code&gt; &lt;/a&gt;。请查阅金额实现的文档，以确定是否可以成功添加。</target>
        </trans-unit>
        <trans-unit id="7e99f6027203570f1c45a91326691927a052b5f7" translate="yes" xml:space="preserve">
          <source>The calculation is delegated to the amount object by calling &lt;a href=&quot;temporal/temporalamount#addTo-java.time.temporal.Temporal-&quot;&gt;&lt;code&gt;TemporalAmount.addTo(Temporal)&lt;/code&gt;&lt;/a&gt;. The amount implementation is free to implement the addition in any way it wishes, however it typically calls back to &lt;a href=&quot;yearmonth#plus-long-java.time.temporal.TemporalUnit-&quot;&gt;&lt;code&gt;plus(long, TemporalUnit)&lt;/code&gt;&lt;/a&gt;. Consult the documentation of the amount implementation to determine if it can be successfully added.</source>
          <target state="translated">通过调用&lt;a href=&quot;temporal/temporalamount#addTo-java.time.temporal.Temporal-&quot;&gt; &lt;code&gt;TemporalAmount.addTo(Temporal)&lt;/code&gt; &lt;/a&gt;将计算委托给金额对象。数量实现可以自由地以其希望的任何方式实现加法，但是通常会回调到&lt;a href=&quot;yearmonth#plus-long-java.time.temporal.TemporalUnit-&quot;&gt; &lt;code&gt;plus(long, TemporalUnit)&lt;/code&gt; &lt;/a&gt;。请查阅金额实现的文档，以确定是否可以成功添加。</target>
        </trans-unit>
        <trans-unit id="994428485f2ea149263e9c2fb513da76194ad0b8" translate="yes" xml:space="preserve">
          <source>The calculation is delegated to the amount object by calling &lt;a href=&quot;temporal/temporalamount#addTo-java.time.temporal.Temporal-&quot;&gt;&lt;code&gt;TemporalAmount.addTo(Temporal)&lt;/code&gt;&lt;/a&gt;. The amount implementation is free to implement the addition in any way it wishes, however it typically calls back to &lt;a href=&quot;zoneddatetime#plus-long-java.time.temporal.TemporalUnit-&quot;&gt;&lt;code&gt;plus(long, TemporalUnit)&lt;/code&gt;&lt;/a&gt;. Consult the documentation of the amount implementation to determine if it can be successfully added.</source>
          <target state="translated">通过调用&lt;a href=&quot;temporal/temporalamount#addTo-java.time.temporal.Temporal-&quot;&gt; &lt;code&gt;TemporalAmount.addTo(Temporal)&lt;/code&gt; &lt;/a&gt;将计算委托给金额对象。数量实现可以自由地以其希望的任何方式实现加法，但是通常会回调到&lt;a href=&quot;zoneddatetime#plus-long-java.time.temporal.TemporalUnit-&quot;&gt; &lt;code&gt;plus(long, TemporalUnit)&lt;/code&gt; &lt;/a&gt;。请查阅金额实现的文档，以确定是否可以成功添加。</target>
        </trans-unit>
        <trans-unit id="72beecfb4b4380d1395896cd556f2fd5f887329f" translate="yes" xml:space="preserve">
          <source>The calculation is delegated to the amount object by calling &lt;a href=&quot;temporal/temporalamount#subtractFrom-java.time.temporal.Temporal-&quot;&gt;&lt;code&gt;TemporalAmount.subtractFrom(Temporal)&lt;/code&gt;&lt;/a&gt;. The amount implementation is free to implement the subtraction in any way it wishes, however it typically calls back to &lt;a href=&quot;instant#minus-long-java.time.temporal.TemporalUnit-&quot;&gt;&lt;code&gt;minus(long, TemporalUnit)&lt;/code&gt;&lt;/a&gt;. Consult the documentation of the amount implementation to determine if it can be successfully subtracted.</source>
          <target state="translated">通过调用&lt;a href=&quot;temporal/temporalamount#subtractFrom-java.time.temporal.Temporal-&quot;&gt; &lt;code&gt;TemporalAmount.subtractFrom(Temporal)&lt;/code&gt; &lt;/a&gt;将计算委托给金额对象。数量实现可以自由地以其希望的任何方式执行减法，但是通常会回调到&lt;a href=&quot;instant#minus-long-java.time.temporal.TemporalUnit-&quot;&gt; &lt;code&gt;minus(long, TemporalUnit)&lt;/code&gt; &lt;/a&gt;。请查阅金额实现的文档以确定是否可以成功减去。</target>
        </trans-unit>
        <trans-unit id="63d8dfd01dd14bee40f150a8512f195b82961be7" translate="yes" xml:space="preserve">
          <source>The calculation is delegated to the amount object by calling &lt;a href=&quot;temporal/temporalamount#subtractFrom-java.time.temporal.Temporal-&quot;&gt;&lt;code&gt;TemporalAmount.subtractFrom(Temporal)&lt;/code&gt;&lt;/a&gt;. The amount implementation is free to implement the subtraction in any way it wishes, however it typically calls back to &lt;a href=&quot;localdate#minus-long-java.time.temporal.TemporalUnit-&quot;&gt;&lt;code&gt;minus(long, TemporalUnit)&lt;/code&gt;&lt;/a&gt;. Consult the documentation of the amount implementation to determine if it can be successfully subtracted.</source>
          <target state="translated">通过调用&lt;a href=&quot;temporal/temporalamount#subtractFrom-java.time.temporal.Temporal-&quot;&gt; &lt;code&gt;TemporalAmount.subtractFrom(Temporal)&lt;/code&gt; &lt;/a&gt;将计算委托给金额对象。数量实现可以自由地以其希望的任何方式执行减法，但是通常会回调到&lt;a href=&quot;localdate#minus-long-java.time.temporal.TemporalUnit-&quot;&gt; &lt;code&gt;minus(long, TemporalUnit)&lt;/code&gt; &lt;/a&gt;。请查阅金额实现的文档以确定是否可以成功减去。</target>
        </trans-unit>
        <trans-unit id="ef7bf705802a1c00c21142d8479c79f5ad4f4ad9" translate="yes" xml:space="preserve">
          <source>The calculation is delegated to the amount object by calling &lt;a href=&quot;temporal/temporalamount#subtractFrom-java.time.temporal.Temporal-&quot;&gt;&lt;code&gt;TemporalAmount.subtractFrom(Temporal)&lt;/code&gt;&lt;/a&gt;. The amount implementation is free to implement the subtraction in any way it wishes, however it typically calls back to &lt;a href=&quot;localdatetime#minus-long-java.time.temporal.TemporalUnit-&quot;&gt;&lt;code&gt;minus(long, TemporalUnit)&lt;/code&gt;&lt;/a&gt;. Consult the documentation of the amount implementation to determine if it can be successfully subtracted.</source>
          <target state="translated">通过调用&lt;a href=&quot;temporal/temporalamount#subtractFrom-java.time.temporal.Temporal-&quot;&gt; &lt;code&gt;TemporalAmount.subtractFrom(Temporal)&lt;/code&gt; &lt;/a&gt;将计算委托给金额对象。数量实现可以自由地以其希望的任何方式执行减法，但是通常会回调到&lt;a href=&quot;localdatetime#minus-long-java.time.temporal.TemporalUnit-&quot;&gt; &lt;code&gt;minus(long, TemporalUnit)&lt;/code&gt; &lt;/a&gt;。请查阅金额实现的文档以确定是否可以成功减去。</target>
        </trans-unit>
        <trans-unit id="9f83917a4b3043dc83a8a121229cd2c84588523d" translate="yes" xml:space="preserve">
          <source>The calculation is delegated to the amount object by calling &lt;a href=&quot;temporal/temporalamount#subtractFrom-java.time.temporal.Temporal-&quot;&gt;&lt;code&gt;TemporalAmount.subtractFrom(Temporal)&lt;/code&gt;&lt;/a&gt;. The amount implementation is free to implement the subtraction in any way it wishes, however it typically calls back to &lt;a href=&quot;localtime#minus-long-java.time.temporal.TemporalUnit-&quot;&gt;&lt;code&gt;minus(long, TemporalUnit)&lt;/code&gt;&lt;/a&gt;. Consult the documentation of the amount implementation to determine if it can be successfully subtracted.</source>
          <target state="translated">通过调用&lt;a href=&quot;temporal/temporalamount#subtractFrom-java.time.temporal.Temporal-&quot;&gt; &lt;code&gt;TemporalAmount.subtractFrom(Temporal)&lt;/code&gt; &lt;/a&gt;将计算委托给金额对象。数量实现可以自由地以其希望的任何方式执行减法，但是通常会回调到&lt;a href=&quot;localtime#minus-long-java.time.temporal.TemporalUnit-&quot;&gt; &lt;code&gt;minus(long, TemporalUnit)&lt;/code&gt; &lt;/a&gt;。请查阅金额实现的文档以确定是否可以成功减去。</target>
        </trans-unit>
        <trans-unit id="9735318a5ee7c236f2a3824643d883272d024629" translate="yes" xml:space="preserve">
          <source>The calculation is delegated to the amount object by calling &lt;a href=&quot;temporal/temporalamount#subtractFrom-java.time.temporal.Temporal-&quot;&gt;&lt;code&gt;TemporalAmount.subtractFrom(Temporal)&lt;/code&gt;&lt;/a&gt;. The amount implementation is free to implement the subtraction in any way it wishes, however it typically calls back to &lt;a href=&quot;offsetdatetime#minus-long-java.time.temporal.TemporalUnit-&quot;&gt;&lt;code&gt;minus(long, TemporalUnit)&lt;/code&gt;&lt;/a&gt;. Consult the documentation of the amount implementation to determine if it can be successfully subtracted.</source>
          <target state="translated">通过调用&lt;a href=&quot;temporal/temporalamount#subtractFrom-java.time.temporal.Temporal-&quot;&gt; &lt;code&gt;TemporalAmount.subtractFrom(Temporal)&lt;/code&gt; &lt;/a&gt;将计算委托给金额对象。数量实现可以自由地以其希望的任何方式执行减法，但是通常会回调到&lt;a href=&quot;offsetdatetime#minus-long-java.time.temporal.TemporalUnit-&quot;&gt; &lt;code&gt;minus(long, TemporalUnit)&lt;/code&gt; &lt;/a&gt;。请查阅金额实现的文档以确定是否可以成功减去。</target>
        </trans-unit>
        <trans-unit id="4678787b4640ffb19d6e0e843874079614a6c590" translate="yes" xml:space="preserve">
          <source>The calculation is delegated to the amount object by calling &lt;a href=&quot;temporal/temporalamount#subtractFrom-java.time.temporal.Temporal-&quot;&gt;&lt;code&gt;TemporalAmount.subtractFrom(Temporal)&lt;/code&gt;&lt;/a&gt;. The amount implementation is free to implement the subtraction in any way it wishes, however it typically calls back to &lt;a href=&quot;offsettime#minus-long-java.time.temporal.TemporalUnit-&quot;&gt;&lt;code&gt;minus(long, TemporalUnit)&lt;/code&gt;&lt;/a&gt;. Consult the documentation of the amount implementation to determine if it can be successfully subtracted.</source>
          <target state="translated">通过调用&lt;a href=&quot;temporal/temporalamount#subtractFrom-java.time.temporal.Temporal-&quot;&gt; &lt;code&gt;TemporalAmount.subtractFrom(Temporal)&lt;/code&gt; &lt;/a&gt;将计算委托给金额对象。数量实现可以自由地以其希望的任何方式执行减法，但是通常会回调到&lt;a href=&quot;offsettime#minus-long-java.time.temporal.TemporalUnit-&quot;&gt; &lt;code&gt;minus(long, TemporalUnit)&lt;/code&gt; &lt;/a&gt;。请查阅金额实现的文档以确定是否可以成功减去。</target>
        </trans-unit>
        <trans-unit id="76574227f521761bf4b8e3a70c0d6e0fd5a48f77" translate="yes" xml:space="preserve">
          <source>The calculation is delegated to the amount object by calling &lt;a href=&quot;temporal/temporalamount#subtractFrom-java.time.temporal.Temporal-&quot;&gt;&lt;code&gt;TemporalAmount.subtractFrom(Temporal)&lt;/code&gt;&lt;/a&gt;. The amount implementation is free to implement the subtraction in any way it wishes, however it typically calls back to &lt;a href=&quot;year#minus-long-java.time.temporal.TemporalUnit-&quot;&gt;&lt;code&gt;minus(long, TemporalUnit)&lt;/code&gt;&lt;/a&gt;. Consult the documentation of the amount implementation to determine if it can be successfully subtracted.</source>
          <target state="translated">通过调用&lt;a href=&quot;temporal/temporalamount#subtractFrom-java.time.temporal.Temporal-&quot;&gt; &lt;code&gt;TemporalAmount.subtractFrom(Temporal)&lt;/code&gt; &lt;/a&gt;将计算委托给金额对象。数量实现可以自由地以其希望的任何方式执行减法，但是通常会回调到&lt;a href=&quot;year#minus-long-java.time.temporal.TemporalUnit-&quot;&gt; &lt;code&gt;minus(long, TemporalUnit)&lt;/code&gt; &lt;/a&gt;。请查阅金额实现的文档以确定是否可以成功减去。</target>
        </trans-unit>
        <trans-unit id="6a606f8f745f376a82afb4bf3b9cfaaf4b5e04e7" translate="yes" xml:space="preserve">
          <source>The calculation is delegated to the amount object by calling &lt;a href=&quot;temporal/temporalamount#subtractFrom-java.time.temporal.Temporal-&quot;&gt;&lt;code&gt;TemporalAmount.subtractFrom(Temporal)&lt;/code&gt;&lt;/a&gt;. The amount implementation is free to implement the subtraction in any way it wishes, however it typically calls back to &lt;a href=&quot;yearmonth#minus-long-java.time.temporal.TemporalUnit-&quot;&gt;&lt;code&gt;minus(long, TemporalUnit)&lt;/code&gt;&lt;/a&gt;. Consult the documentation of the amount implementation to determine if it can be successfully subtracted.</source>
          <target state="translated">通过调用&lt;a href=&quot;temporal/temporalamount#subtractFrom-java.time.temporal.Temporal-&quot;&gt; &lt;code&gt;TemporalAmount.subtractFrom(Temporal)&lt;/code&gt; &lt;/a&gt;将计算委托给金额对象。数量实现可以自由地以其希望的任何方式执行减法，但是通常会回调到&lt;a href=&quot;yearmonth#minus-long-java.time.temporal.TemporalUnit-&quot;&gt; &lt;code&gt;minus(long, TemporalUnit)&lt;/code&gt; &lt;/a&gt;。请查阅金额实现的文档以确定是否可以成功减去。</target>
        </trans-unit>
        <trans-unit id="fb583766018df0a002e06f9ff6b85c52184760b5" translate="yes" xml:space="preserve">
          <source>The calculation is delegated to the amount object by calling &lt;a href=&quot;temporal/temporalamount#subtractFrom-java.time.temporal.Temporal-&quot;&gt;&lt;code&gt;TemporalAmount.subtractFrom(Temporal)&lt;/code&gt;&lt;/a&gt;. The amount implementation is free to implement the subtraction in any way it wishes, however it typically calls back to &lt;a href=&quot;zoneddatetime#minus-long-java.time.temporal.TemporalUnit-&quot;&gt;&lt;code&gt;minus(long, TemporalUnit)&lt;/code&gt;&lt;/a&gt;. Consult the documentation of the amount implementation to determine if it can be successfully subtracted.</source>
          <target state="translated">通过调用&lt;a href=&quot;temporal/temporalamount#subtractFrom-java.time.temporal.Temporal-&quot;&gt; &lt;code&gt;TemporalAmount.subtractFrom(Temporal)&lt;/code&gt; &lt;/a&gt;将计算委托给金额对象。数量实现可以自由地以其希望的任何方式执行减法，但是通常会回调到&lt;a href=&quot;zoneddatetime#minus-long-java.time.temporal.TemporalUnit-&quot;&gt; &lt;code&gt;minus(long, TemporalUnit)&lt;/code&gt; &lt;/a&gt;。请查阅金额实现的文档以确定是否可以成功减去。</target>
        </trans-unit>
        <trans-unit id="1cd315c0454258ad07a59eebbecac5190d877bf3" translate="yes" xml:space="preserve">
          <source>The calculation is implemented in this method for &lt;a href=&quot;../temporal/chronounit&quot;&gt;&lt;code&gt;ChronoUnit&lt;/code&gt;&lt;/a&gt;. The units &lt;code&gt;DAYS&lt;/code&gt;, &lt;code&gt;WEEKS&lt;/code&gt;, &lt;code&gt;MONTHS&lt;/code&gt;, &lt;code&gt;YEARS&lt;/code&gt;, &lt;code&gt;DECADES&lt;/code&gt;, &lt;code&gt;CENTURIES&lt;/code&gt;, &lt;code&gt;MILLENNIA&lt;/code&gt; and &lt;code&gt;ERAS&lt;/code&gt; should be supported by all implementations. Other &lt;code&gt;ChronoUnit&lt;/code&gt; values will throw an exception.</source>
          <target state="translated">在&lt;a href=&quot;../temporal/chronounit&quot;&gt; &lt;code&gt;ChronoUnit&lt;/code&gt; 的&lt;/a&gt;此方法中实现了计算。所有实现均应支持单位 &lt;code&gt;DAYS&lt;/code&gt; ， &lt;code&gt;WEEKS&lt;/code&gt; ， &lt;code&gt;MONTHS&lt;/code&gt; ， &lt;code&gt;YEARS&lt;/code&gt; ， &lt;code&gt;DECADES&lt;/code&gt; ， &lt;code&gt;CENTURIES&lt;/code&gt; ， &lt;code&gt;MILLENNIA&lt;/code&gt; 和 &lt;code&gt;ERAS&lt;/code&gt; 。其他 &lt;code&gt;ChronoUnit&lt;/code&gt; 值将引发异常。</target>
        </trans-unit>
        <trans-unit id="2c40729f65e17fa53bc32e56e2b68deecbce35f4" translate="yes" xml:space="preserve">
          <source>The calculation is implemented in this method for &lt;a href=&quot;temporal/chronounit&quot;&gt;&lt;code&gt;ChronoUnit&lt;/code&gt;&lt;/a&gt;. The units &lt;code&gt;DAYS&lt;/code&gt;, &lt;code&gt;WEEKS&lt;/code&gt;, &lt;code&gt;MONTHS&lt;/code&gt;, &lt;code&gt;YEARS&lt;/code&gt;, &lt;code&gt;DECADES&lt;/code&gt;, &lt;code&gt;CENTURIES&lt;/code&gt;, &lt;code&gt;MILLENNIA&lt;/code&gt; and &lt;code&gt;ERAS&lt;/code&gt; are supported. Other &lt;code&gt;ChronoUnit&lt;/code&gt; values will throw an exception.</source>
          <target state="translated">在&lt;a href=&quot;temporal/chronounit&quot;&gt; &lt;code&gt;ChronoUnit&lt;/code&gt; 的&lt;/a&gt;此方法中实现了计算。支持单位 &lt;code&gt;DAYS&lt;/code&gt; ， &lt;code&gt;WEEKS&lt;/code&gt; ， &lt;code&gt;MONTHS&lt;/code&gt; ， &lt;code&gt;YEARS&lt;/code&gt; ， &lt;code&gt;DECADES&lt;/code&gt; ， &lt;code&gt;CENTURIES&lt;/code&gt; ， &lt;code&gt;MILLENNIA&lt;/code&gt; 和 &lt;code&gt;ERAS&lt;/code&gt; 。其他 &lt;code&gt;ChronoUnit&lt;/code&gt; 值将引发异常。</target>
        </trans-unit>
        <trans-unit id="19b9a5d378177e9c9b3a71840adcb16f0f886bde" translate="yes" xml:space="preserve">
          <source>The calculation is implemented in this method for &lt;a href=&quot;temporal/chronounit&quot;&gt;&lt;code&gt;ChronoUnit&lt;/code&gt;&lt;/a&gt;. The units &lt;code&gt;MONTHS&lt;/code&gt;, &lt;code&gt;YEARS&lt;/code&gt;, &lt;code&gt;DECADES&lt;/code&gt;, &lt;code&gt;CENTURIES&lt;/code&gt;, &lt;code&gt;MILLENNIA&lt;/code&gt; and &lt;code&gt;ERAS&lt;/code&gt; are supported. Other &lt;code&gt;ChronoUnit&lt;/code&gt; values will throw an exception.</source>
          <target state="translated">在&lt;a href=&quot;temporal/chronounit&quot;&gt; &lt;code&gt;ChronoUnit&lt;/code&gt; 的&lt;/a&gt;此方法中实现了计算。支持单位 &lt;code&gt;MONTHS&lt;/code&gt; ， &lt;code&gt;YEARS&lt;/code&gt; ， &lt;code&gt;DECADES&lt;/code&gt; ， &lt;code&gt;CENTURIES&lt;/code&gt; ， &lt;code&gt;MILLENNIA&lt;/code&gt; 和 &lt;code&gt;ERAS&lt;/code&gt; 。其他 &lt;code&gt;ChronoUnit&lt;/code&gt; 值将引发异常。</target>
        </trans-unit>
        <trans-unit id="e230aa95d014e34ceda792a8275bb6a6a1650561" translate="yes" xml:space="preserve">
          <source>The calculation is implemented in this method for &lt;a href=&quot;temporal/chronounit&quot;&gt;&lt;code&gt;ChronoUnit&lt;/code&gt;&lt;/a&gt;. The units &lt;code&gt;NANOS&lt;/code&gt;, &lt;code&gt;MICROS&lt;/code&gt;, &lt;code&gt;MILLIS&lt;/code&gt;, &lt;code&gt;SECONDS&lt;/code&gt;, &lt;code&gt;MINUTES&lt;/code&gt;, &lt;code&gt;HOURS&lt;/code&gt; and &lt;code&gt;HALF_DAYS&lt;/code&gt; are supported. Other &lt;code&gt;ChronoUnit&lt;/code&gt; values will throw an exception.</source>
          <target state="translated">在&lt;a href=&quot;temporal/chronounit&quot;&gt; &lt;code&gt;ChronoUnit&lt;/code&gt; 的&lt;/a&gt;此方法中实现了计算。支持单位 &lt;code&gt;NANOS&lt;/code&gt; ， &lt;code&gt;MICROS&lt;/code&gt; ， &lt;code&gt;MILLIS&lt;/code&gt; ， &lt;code&gt;SECONDS&lt;/code&gt; ， &lt;code&gt;MINUTES&lt;/code&gt; ， &lt;code&gt;HOURS&lt;/code&gt; 和 &lt;code&gt;HALF_DAYS&lt;/code&gt; 。其他 &lt;code&gt;ChronoUnit&lt;/code&gt; 值将引发异常。</target>
        </trans-unit>
        <trans-unit id="1507d23c8a6f8c72a31bd26e1e7810e4719336ab" translate="yes" xml:space="preserve">
          <source>The calculation is implemented in this method for &lt;a href=&quot;temporal/chronounit&quot;&gt;&lt;code&gt;ChronoUnit&lt;/code&gt;&lt;/a&gt;. The units &lt;code&gt;NANOS&lt;/code&gt;, &lt;code&gt;MICROS&lt;/code&gt;, &lt;code&gt;MILLIS&lt;/code&gt;, &lt;code&gt;SECONDS&lt;/code&gt;, &lt;code&gt;MINUTES&lt;/code&gt;, &lt;code&gt;HOURS&lt;/code&gt; and &lt;code&gt;HALF_DAYS&lt;/code&gt;, &lt;code&gt;DAYS&lt;/code&gt;, &lt;code&gt;WEEKS&lt;/code&gt;, &lt;code&gt;MONTHS&lt;/code&gt;, &lt;code&gt;YEARS&lt;/code&gt;, &lt;code&gt;DECADES&lt;/code&gt;, &lt;code&gt;CENTURIES&lt;/code&gt;, &lt;code&gt;MILLENNIA&lt;/code&gt; and &lt;code&gt;ERAS&lt;/code&gt; are supported. Other &lt;code&gt;ChronoUnit&lt;/code&gt; values will throw an exception.</source>
          <target state="translated">在&lt;a href=&quot;temporal/chronounit&quot;&gt; &lt;code&gt;ChronoUnit&lt;/code&gt; 的&lt;/a&gt;此方法中实现了计算。单位 &lt;code&gt;NANOS&lt;/code&gt; ， &lt;code&gt;MICROS&lt;/code&gt; ， &lt;code&gt;MILLIS&lt;/code&gt; ， &lt;code&gt;SECONDS&lt;/code&gt; ， &lt;code&gt;MINUTES&lt;/code&gt; ， &lt;code&gt;HOURS&lt;/code&gt; 和 &lt;code&gt;HALF_DAYS&lt;/code&gt; ， &lt;code&gt;DAYS&lt;/code&gt; ， &lt;code&gt;WEEKS&lt;/code&gt; ， &lt;code&gt;MONTHS&lt;/code&gt; ， &lt;code&gt;YEARS&lt;/code&gt; ， &lt;code&gt;DECADES&lt;/code&gt; ， &lt;code&gt;CENTURIES&lt;/code&gt; ， &lt;code&gt;MILLENNIA&lt;/code&gt; 和 &lt;code&gt;ERAS&lt;/code&gt; 的支持。其他 &lt;code&gt;ChronoUnit&lt;/code&gt; 值将引发异常。</target>
        </trans-unit>
        <trans-unit id="a944bb9e5a6fb6bb71bb5754d803740edba2e7e6" translate="yes" xml:space="preserve">
          <source>The calculation is implemented in this method for &lt;a href=&quot;temporal/chronounit&quot;&gt;&lt;code&gt;ChronoUnit&lt;/code&gt;&lt;/a&gt;. The units &lt;code&gt;NANOS&lt;/code&gt;, &lt;code&gt;MICROS&lt;/code&gt;, &lt;code&gt;MILLIS&lt;/code&gt;, &lt;code&gt;SECONDS&lt;/code&gt;, &lt;code&gt;MINUTES&lt;/code&gt;, &lt;code&gt;HOURS&lt;/code&gt;, &lt;code&gt;HALF_DAYS&lt;/code&gt; and &lt;code&gt;DAYS&lt;/code&gt; are supported. Other &lt;code&gt;ChronoUnit&lt;/code&gt; values will throw an exception.</source>
          <target state="translated">在&lt;a href=&quot;temporal/chronounit&quot;&gt; &lt;code&gt;ChronoUnit&lt;/code&gt; 的&lt;/a&gt;此方法中实现了计算。支持单位 &lt;code&gt;NANOS&lt;/code&gt; ， &lt;code&gt;MICROS&lt;/code&gt; ， &lt;code&gt;MILLIS&lt;/code&gt; ， &lt;code&gt;SECONDS&lt;/code&gt; ， &lt;code&gt;MINUTES&lt;/code&gt; ， &lt;code&gt;HOURS&lt;/code&gt; ， &lt;code&gt;HALF_DAYS&lt;/code&gt; 和 &lt;code&gt;DAYS&lt;/code&gt; 。其他 &lt;code&gt;ChronoUnit&lt;/code&gt; 值将引发异常。</target>
        </trans-unit>
        <trans-unit id="1d36fea63293e397176d95e77b5737ce1cf421eb" translate="yes" xml:space="preserve">
          <source>The calculation is implemented in this method for &lt;a href=&quot;temporal/chronounit&quot;&gt;&lt;code&gt;ChronoUnit&lt;/code&gt;&lt;/a&gt;. The units &lt;code&gt;YEARS&lt;/code&gt;, &lt;code&gt;DECADES&lt;/code&gt;, &lt;code&gt;CENTURIES&lt;/code&gt;, &lt;code&gt;MILLENNIA&lt;/code&gt; and &lt;code&gt;ERAS&lt;/code&gt; are supported. Other &lt;code&gt;ChronoUnit&lt;/code&gt; values will throw an exception.</source>
          <target state="translated">在&lt;a href=&quot;temporal/chronounit&quot;&gt; &lt;code&gt;ChronoUnit&lt;/code&gt; 的&lt;/a&gt;此方法中实现了计算。支持单位 &lt;code&gt;YEARS&lt;/code&gt; ， &lt;code&gt;DECADES&lt;/code&gt; ， &lt;code&gt;CENTURIES&lt;/code&gt; ， &lt;code&gt;MILLENNIA&lt;/code&gt; 和 &lt;code&gt;ERAS&lt;/code&gt; 。其他 &lt;code&gt;ChronoUnit&lt;/code&gt; 值将引发异常。</target>
        </trans-unit>
        <trans-unit id="de396f35f1beb4dec84fd96c5c0bc128000c53b5" translate="yes" xml:space="preserve">
          <source>The calculation is performed using the ISO calendar system. If necessary, the input date will be converted to ISO.</source>
          <target state="translated">计算使用ISO日历系统进行。如有必要,输入的日期将被转换为ISO。</target>
        </trans-unit>
        <trans-unit id="5c8b7a9e75b18aac11374fa27a65860ce2cba5ee" translate="yes" xml:space="preserve">
          <source>The calculation is performed using the chronology of this date. If necessary, the input date will be converted to match.</source>
          <target state="translated">计算时使用该日期的时间顺序。如有必要,将对输入的日期进行转换,使之与之相匹配。</target>
        </trans-unit>
        <trans-unit id="a18a3925fc70243cd9c7e703ff805ee959f8b1b2" translate="yes" xml:space="preserve">
          <source>The calculation is proleptic - applying the same rules into the far future and far past. This is historically inaccurate, but is correct for the ISO-8601 standard.</source>
          <target state="translated">计算是无序的--将同样的规则应用到遥远的未来和遥远的过去。这在历史上是不准确的,但对ISO-8601标准来说是正确的。</target>
        </trans-unit>
        <trans-unit id="a77397163b78a04fe04dd941420d69ad173ac41a" translate="yes" xml:space="preserve">
          <source>The calculation operates as follows. First, the chronology of the temporal is checked to ensure it is ISO chronology or null. Second, if the months are zero, the years are added if non-zero, otherwise the combination of years and months is added if non-zero. Finally, any days are added.</source>
          <target state="translated">计算操作如下。首先,检查时序,确保其为ISO时序或空。其次,如果月份为零,如果非零,则添加年份,否则,如果非零,则添加年份和月份的组合。最后,添加任何天数。</target>
        </trans-unit>
        <trans-unit id="c263030716ce91a128cf8f90575be9c8fd437b13" translate="yes" xml:space="preserve">
          <source>The calculation operates as follows. First, the chronology of the temporal is checked to ensure it is ISO chronology or null. Second, if the months are zero, the years are subtracted if non-zero, otherwise the combination of years and months is subtracted if non-zero. Finally, any days are subtracted.</source>
          <target state="translated">计算操作如下。首先,检查时序,确保其为ISO时序或空。其次,如果月份为零,则减去非零的年份,否则减去非零的年份和月份的组合。最后,任何天数都会被减去。</target>
        </trans-unit>
        <trans-unit id="fdb1636ed39215073f821c5aa121f59d7ee4d527" translate="yes" xml:space="preserve">
          <source>The calculation returns a whole number, representing the number of complete units between the two date-times. For example, the amount in months between 2012-06-15T00:00 and 2012-08-14T23:59 will only be one month as it is one minute short of two months.</source>
          <target state="translated">计算返回一个整数,代表两个日期时间之间的完整单位数。例如,2012-06-15T00:00和2012-08-14T23:59之间的月数只有一个月,因为它比两个月少一分钟。</target>
        </trans-unit>
        <trans-unit id="ec9af07e807db86ba031ee502751cd0c38c69a71" translate="yes" xml:space="preserve">
          <source>The calculation returns a whole number, representing the number of complete units between the two date-times. For example, the amount in months between 2012-06-15T00:00Z and 2012-08-14T23:59Z will only be one month as it is one minute short of two months.</source>
          <target state="translated">计算返回一个整数,代表两个日期时间之间的完整单位数。例如,2012-06-15T00:00Z和2012-08-14T23:59Z之间的月数只有一个月,因为它比两个月少一分钟。</target>
        </trans-unit>
        <trans-unit id="2a40c5deaf847238353378cb61b47570a274c9ac" translate="yes" xml:space="preserve">
          <source>The calculation returns a whole number, representing the number of complete units between the two dates. For example, the amount in months between 2012-06-15 and 2012-08-14 will only be one month as it is one day short of two months.</source>
          <target state="translated">计算返回一个整数,代表两个日期之间的完整单位数。例如,2012-06-15和2012-08-14之间的月数只有一个月,因为它比两个月少一天。</target>
        </trans-unit>
        <trans-unit id="4e4af59e77647dd6907c8a296e775e0a0d836e8c" translate="yes" xml:space="preserve">
          <source>The calculation returns a whole number, representing the number of complete units between the two temporals. For example, the amount in hours between the times 11:30 and 13:29 will only be one hour as it is one minute short of two hours.</source>
          <target state="translated">计算返回一个整数,代表两个时间之间的完整单位数。例如,11:30和13:29之间的小时数只有一个小时,因为它比两个小时少一分钟。</target>
        </trans-unit>
        <trans-unit id="e6909d5ca1c4c3ff219ad8a02bf77193f0655754" translate="yes" xml:space="preserve">
          <source>The calculation returns a whole number, representing the number of complete units between the two times. For example, the amount in hours between 11:30 and 13:29 will only be one hour as it is one minute short of two hours.</source>
          <target state="translated">计算返回一个整数,代表两个时间之间的完整单位数。例如,11:30和13:29之间的小时数只有1小时,因为它比2小时少1分钟。</target>
        </trans-unit>
        <trans-unit id="c9e0270c645839bc297b8d8461abd213cdea0773" translate="yes" xml:space="preserve">
          <source>The calculation returns a whole number, representing the number of complete units between the two times. For example, the amount in hours between 11:30Z and 13:29Z will only be one hour as it is one minute short of two hours.</source>
          <target state="translated">计算返回一个整数,代表两个时间之间的完整单位数。例如,11:30Z和13:29Z之间的小时数只有一个小时,因为它比两个小时少一分钟。</target>
        </trans-unit>
        <trans-unit id="b40e1be73246aecc1325d0ab24225f79366c3cea" translate="yes" xml:space="preserve">
          <source>The calculation returns a whole number, representing the number of complete units between the two year-months. For example, the amount in decades between 2012-06 and 2032-05 will only be one decade as it is one month short of two decades.</source>
          <target state="translated">计算返回一个整数,代表两个年月之间的完整单位数。例如,在2012-06和2032-05之间,由于距离20年还差一个月,所以只有一个十年。</target>
        </trans-unit>
        <trans-unit id="ccc4ff471f21d9f7ba0907b139abcc2e7896bd76" translate="yes" xml:space="preserve">
          <source>The calculation returns a whole number, representing the number of complete units between the two years. For example, the amount in decades between 2012 and 2031 will only be one decade as it is one year short of two decades.</source>
          <target state="translated">计算返回一个整数,代表两年之间的完整单位数。例如,2012年至2031年之间的十年数量将只有一个十年,因为它比二十年少一年。</target>
        </trans-unit>
        <trans-unit id="58e5423c597dc35b389e5d938496ce0de4d9778f" translate="yes" xml:space="preserve">
          <source>The calculation rolls around the end of the week from Sunday to Monday. The specified period may be negative.</source>
          <target state="translated">计算从周日到周一的周末滚动进行。指定的期间可以是负数。</target>
        </trans-unit>
        <trans-unit id="668d9a3e3fa4c9967805f1a3678a36f85651608a" translate="yes" xml:space="preserve">
          <source>The calculation rolls around the end of the year from December to January. The specified period may be negative.</source>
          <target state="translated">从12月到1月的年底滚动计算。指定的期间可以是负数。</target>
        </trans-unit>
        <trans-unit id="c563b5a653779db71d45290b934e9ad07e26260f" translate="yes" xml:space="preserve">
          <source>The calculation rolls around the start of the year from January to December. The specified period may be negative.</source>
          <target state="translated">计算从1月到12月的年初滚动进行。指定的期间可以是负数。</target>
        </trans-unit>
        <trans-unit id="e7212e045d02e1d66ae352530c884f838bcd75d4" translate="yes" xml:space="preserve">
          <source>The calculation rolls around the start of the year from Monday to Sunday. The specified period may be negative.</source>
          <target state="translated">计算从周一到周日围绕年初滚动进行。指定的期间可以是负数。</target>
        </trans-unit>
        <trans-unit id="ec7c17cc8ccefb501b5beef5a7c7ae8a3150c74f" translate="yes" xml:space="preserve">
          <source>The calculation will add the seconds, then nanos. Only non-zero amounts will be added.</source>
          <target state="translated">计算将添加秒,然后是纳秒。只有非零的数量才会被添加。</target>
        </trans-unit>
        <trans-unit id="16e7549a22a253997bf53ac9cf0c75a51b0bbc3b" translate="yes" xml:space="preserve">
          <source>The calculation will subtract the seconds, then nanos. Only non-zero amounts will be added.</source>
          <target state="translated">计算将减去秒,然后是纳秒。只有非零的数量才会被加上。</target>
        </trans-unit>
        <trans-unit id="82a4f3f7a39babbf366ad326d064056956101ac1" translate="yes" xml:space="preserve">
          <source>The calendar field values can be set by calling the &lt;code&gt;set&lt;/code&gt; methods. Any field values set in a &lt;code&gt;Calendar&lt;/code&gt; will not be interpreted until it needs to calculate its time value (milliseconds from the Epoch) or values of the calendar fields. Calling the &lt;code&gt;get&lt;/code&gt;, &lt;code&gt;getTimeInMillis&lt;/code&gt;, &lt;code&gt;getTime&lt;/code&gt;, &lt;code&gt;add&lt;/code&gt; and &lt;code&gt;roll&lt;/code&gt; involves such calculation.</source>
          <target state="translated">可以通过调用 &lt;code&gt;set&lt;/code&gt; 方法来设置日历字段的值。 &lt;code&gt;Calendar&lt;/code&gt; 设置的任何字段值都将不被解释，直到需要计算其时间值（距纪元为毫秒）或日历字段的值。调用 &lt;code&gt;get&lt;/code&gt; ， &lt;code&gt;getTimeInMillis&lt;/code&gt; ， &lt;code&gt;getTime&lt;/code&gt; ， &lt;code&gt;add&lt;/code&gt; 和 &lt;code&gt;roll&lt;/code&gt; 涉及这种计算。</target>
        </trans-unit>
        <trans-unit id="865d4b04e7b37220faeadf26dcf5654c73ef78a9" translate="yes" xml:space="preserve">
          <source>The calendar field values for the currently set time for this calendar. This is an array of &lt;code&gt;FIELD_COUNT&lt;/code&gt; integers, with index values &lt;code&gt;ERA&lt;/code&gt; through &lt;code&gt;DST_OFFSET&lt;/code&gt;.</source>
          <target state="translated">此日历当前设置时间的日历字段值。这是 &lt;code&gt;FIELD_COUNT&lt;/code&gt; 个整数的数组，其索引值为 &lt;code&gt;ERA&lt;/code&gt; 到 &lt;code&gt;DST_OFFSET&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="77dba84a172780be492cbe77a232ee1219c79321" translate="yes" xml:space="preserve">
          <source>The calendar fields can be changed using three methods: &lt;code&gt;set()&lt;/code&gt;, &lt;code&gt;add()&lt;/code&gt;, and &lt;code&gt;roll()&lt;/code&gt;.</source>
          <target state="translated">可以使用以下三种方法更改日历字段： &lt;code&gt;set()&lt;/code&gt; ， &lt;code&gt;add()&lt;/code&gt; 和 &lt;code&gt;roll()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="93ce9ec5e026f012a845bb7044250795eb5e3784" translate="yes" xml:space="preserve">
          <source>The calendar system name will be output during a format. If the chronology cannot be obtained then an exception will be thrown.</source>
          <target state="translated">在格式化过程中,日历系统名称将被输出。如果无法获得年表,则会抛出一个异常。</target>
        </trans-unit>
        <trans-unit id="962278d560a441566052e9e275cc29395fdebae6" translate="yes" xml:space="preserve">
          <source>The calendar type</source>
          <target state="translated">日历类型</target>
        </trans-unit>
        <trans-unit id="4446eadd3978a37be2e9479e866319a200f662b6" translate="yes" xml:space="preserve">
          <source>The calendar type is an identifier defined by the &lt;em&gt;Unicode Locale Data Markup Language (LDML)&lt;/em&gt; specification. It can be used to lookup the &lt;code&gt;Chronology&lt;/code&gt; using &lt;a href=&quot;chronology#of-java.lang.String-&quot;&gt;&lt;code&gt;Chronology.of(String)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">日历类型是&lt;em&gt;Unicode区域设置数据标记语言（LDML）&lt;/em&gt;规范定义的标识符。它可以用于使用&lt;a href=&quot;chronology#of-java.lang.String-&quot;&gt; &lt;code&gt;Chronology.of(String)&lt;/code&gt; &lt;/a&gt;查找 &lt;code&gt;Chronology&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e9ed929db1a5de6f998e10698419063ed967ca06" translate="yes" xml:space="preserve">
          <source>The calendar type is an identifier defined by the &lt;em&gt;Unicode Locale Data Markup Language (LDML)&lt;/em&gt; specification. It can be used to lookup the &lt;code&gt;Chronology&lt;/code&gt; using &lt;a href=&quot;chronology#of-java.lang.String-&quot;&gt;&lt;code&gt;Chronology.of(String)&lt;/code&gt;&lt;/a&gt;. It can also be used as part of a locale, accessible via &lt;a href=&quot;../../util/locale#getUnicodeLocaleType-java.lang.String-&quot;&gt;&lt;code&gt;Locale.getUnicodeLocaleType(String)&lt;/code&gt;&lt;/a&gt; with the key 'ca'.</source>
          <target state="translated">日历类型是由&lt;em&gt;Unicode区域设置数据标记语言（LDML）&lt;/em&gt;规范定义的标识符。它可以用于使用&lt;a href=&quot;chronology#of-java.lang.String-&quot;&gt; &lt;code&gt;Chronology.of(String)&lt;/code&gt; &lt;/a&gt;查找 &lt;code&gt;Chronology&lt;/code&gt; 。它也可以用作语言环境的一部分，可通过&lt;a href=&quot;../../util/locale#getUnicodeLocaleType-java.lang.String-&quot;&gt; &lt;code&gt;Locale.getUnicodeLocaleType(String)&lt;/code&gt; &lt;/a&gt;使用键&amp;ldquo; ca&amp;rdquo;进行访问。</target>
        </trans-unit>
        <trans-unit id="5fc183cf3291b70fe7d13ce84678bde8c535e01b" translate="yes" xml:space="preserve">
          <source>The calendar type is an identifier defined by the CLDR and &lt;em&gt;Unicode Locale Data Markup Language (LDML)&lt;/em&gt; specifications to uniquely identification a calendar. The &lt;code&gt;getCalendarType&lt;/code&gt; is the concatenation of the CLDR calendar type and the variant, if applicable, is appended separated by &quot;-&quot;. The calendar type is used to lookup the &lt;code&gt;Chronology&lt;/code&gt; using &lt;a href=&quot;chronology#of-java.lang.String-&quot;&gt;&lt;code&gt;of(String)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">日历类型是由CLDR和&lt;em&gt;Unicode区域设置数据标记语言（LDML）&lt;/em&gt;规范定义的标识符，用于唯一地标识日历。该 &lt;code&gt;getCalendarType&lt;/code&gt; 是CLDR日历类型和变体，如果适用的话，附加由分离的级联&amp;ldquo; - &amp;rdquo;。日历类型用于使用&lt;a href=&quot;chronology#of-java.lang.String-&quot;&gt; &lt;code&gt;of(String)&lt;/code&gt; &lt;/a&gt;查找 &lt;code&gt;Chronology&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bfa957c4639eb6b0b522562bf5068bd4ec5c04a3" translate="yes" xml:space="preserve">
          <source>The call &lt;code&gt;System.exit(n)&lt;/code&gt; is effectively equivalent to the call:</source>
          <target state="translated">调用 &lt;code&gt;System.exit(n)&lt;/code&gt; 实际上等效于该调用：</target>
        </trans-unit>
        <trans-unit id="76511f462f4300cf033c5338feb8d0cddaa72576" translate="yes" xml:space="preserve">
          <source>The call &lt;code&gt;System.gc()&lt;/code&gt; is effectively equivalent to the call:</source>
          <target state="translated">调用 &lt;code&gt;System.gc()&lt;/code&gt; 实际上等效于调用：</target>
        </trans-unit>
        <trans-unit id="b690e13d2eb683913812a8e26357b9092be90125" translate="yes" xml:space="preserve">
          <source>The call &lt;code&gt;System.load(name)&lt;/code&gt; is effectively equivalent to the call:</source>
          <target state="translated">调用 &lt;code&gt;System.load(name)&lt;/code&gt; 实际上等效于该调用：</target>
        </trans-unit>
        <trans-unit id="1eb7ec99c5609280be9a3083224b7fba9909e0ca" translate="yes" xml:space="preserve">
          <source>The call &lt;code&gt;System.loadLibrary(name)&lt;/code&gt; is effectively equivalent to the call</source>
          <target state="translated">调用 &lt;code&gt;System.loadLibrary(name)&lt;/code&gt; 实际上等效于调用</target>
        </trans-unit>
        <trans-unit id="44ca22e66f70469f3b06955ad110de6c45f398d4" translate="yes" xml:space="preserve">
          <source>The call &lt;code&gt;System.runFinalization()&lt;/code&gt; is effectively equivalent to the call:</source>
          <target state="translated">调用 &lt;code&gt;System.runFinalization()&lt;/code&gt; 实际上等效于调用：</target>
        </trans-unit>
        <trans-unit id="e36a0559239de87755b7f3e15a71516f5fc282f3" translate="yes" xml:space="preserve">
          <source>The call spuriously (that is, for no reason) returns.</source>
          <target state="translated">调用虚假地(即无缘无故)返回。</target>
        </trans-unit>
        <trans-unit id="d4d15ed9ec3b7821f87167a2d4c1dc15a7458567" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;reset&lt;/code&gt; may throw an &lt;code&gt;IOException&lt;/code&gt;.</source>
          <target state="translated">调用 &lt;code&gt;reset&lt;/code&gt; 可能会抛出 &lt;code&gt;IOException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="768c012ad804fb9a864a4db4525b259baaf8487d" translate="yes" xml:space="preserve">
          <source>The caller can use the result to determine if it should fallback to another mechanism to read the keys.</source>
          <target state="translated">调用者可以用这个结果来决定是否应该回退到另一个机制来读取密钥。</target>
        </trans-unit>
        <trans-unit id="d04140412c1fb225a44054ba343d90b9017cec04" translate="yes" xml:space="preserve">
          <source>The caller must have permission to access all of the requested Credentials, or a &lt;code&gt;SecurityException&lt;/code&gt; will be thrown.</source>
          <target state="translated">调用者必须具有访问所有请求的凭据的权限，否则将引发 &lt;code&gt;SecurityException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aa92adff6514811ab419f1227d3ed5e4ce614299" translate="yes" xml:space="preserve">
          <source>The caller principal must be an owner of the ACL in order to invoke this method.</source>
          <target state="translated">调用者委托人必须是ACL的所有者才能调用本方法。</target>
        </trans-unit>
        <trans-unit id="9af10b071d26e95fd329201957fb34bf923bd4a9" translate="yes" xml:space="preserve">
          <source>The caller should not make any changes to the object returned: their effect on the context is undefined. The environment of this context may be changed using &lt;code&gt;addToEnvironment()&lt;/code&gt; and &lt;code&gt;removeFromEnvironment()&lt;/code&gt;.</source>
          <target state="translated">调用者不应对返回的对象进行任何更改：它们对上下文的影响是不确定的。可以使用 &lt;code&gt;addToEnvironment()&lt;/code&gt; 和 &lt;code&gt;removeFromEnvironment()&lt;/code&gt; 更改此上下文的环境。</target>
        </trans-unit>
        <trans-unit id="8cd6ba60b3eac7216be485ec7f97649dd91f55ac" translate="yes" xml:space="preserve">
          <source>The caller type must provides as least enough arguments, and of the correct type, to satisfy the target's requirement for positional arguments before the trailing array argument. Thus, the caller must supply, at a minimum, &lt;code&gt;N-1&lt;/code&gt; arguments, where &lt;code&gt;N&lt;/code&gt; is the arity of the target. Also, there must exist conversions from the incoming arguments to the target's arguments. As with other uses of plain &lt;code&gt;invoke&lt;/code&gt;, if these basic requirements are not fulfilled, a &lt;code&gt;WrongMethodTypeException&lt;/code&gt; may be thrown.</source>
          <target state="translated">调用方类型必须至少提供足够数量的参数，并且类型正确，才能满足目标在尾随数组参数之前对位置参数的要求。因此，调用者必须至少提供 &lt;code&gt;N-1&lt;/code&gt; 个参数，其中 &lt;code&gt;N&lt;/code&gt; 是目标的Arity。而且，必须存在从传入参数到目标参数的转换。与普通 &lt;code&gt;invoke&lt;/code&gt; 其他用法一样，如果不满足这些基本要求， &lt;code&gt;WrongMethodTypeException&lt;/code&gt; 可能引发WrongMethodTypeException。</target>
        </trans-unit>
        <trans-unit id="295d4fb4a3cfad392bf258af4796a9b85656d164" translate="yes" xml:space="preserve">
          <source>The calling application sees the authentication process as a single operation. However, the authentication process within the &lt;code&gt;LoginModule&lt;/code&gt; proceeds in two distinct phases. In the first phase, the LoginModule's &lt;code&gt;login&lt;/code&gt; method gets invoked by the LoginContext's &lt;code&gt;login&lt;/code&gt; method. The &lt;code&gt;login&lt;/code&gt; method for the &lt;code&gt;LoginModule&lt;/code&gt; then performs the actual authentication (prompt for and verify a password for example) and saves its authentication status as private state information. Once finished, the LoginModule's &lt;code&gt;login&lt;/code&gt; method either returns &lt;code&gt;true&lt;/code&gt; (if it succeeded) or &lt;code&gt;false&lt;/code&gt; (if it should be ignored), or throws a &lt;code&gt;LoginException&lt;/code&gt; to specify a failure. In the failure case, the &lt;code&gt;LoginModule&lt;/code&gt; must not retry the authentication or introduce delays. The responsibility of such tasks belongs to the application. If the application attempts to retry the authentication, the LoginModule's &lt;code&gt;login&lt;/code&gt; method will be called again.</source>
          <target state="translated">调用应用程序将身份验证过程视为单个操作。但是， &lt;code&gt;LoginModule&lt;/code&gt; 中的身份验证过程分两个不同的阶段进行。在第一个阶段，LoginModule的 &lt;code&gt;login&lt;/code&gt; 方法得到由LoginContext的调用 &lt;code&gt;login&lt;/code&gt; 方法。然后， &lt;code&gt;LoginModule&lt;/code&gt; 的 &lt;code&gt;login&lt;/code&gt; 方法执行实际的身份验证（例如，提示和验证密码），并将其身份验证状态保存为私有状态信息。完成后，LoginModule的 &lt;code&gt;login&lt;/code&gt; 方法将返回 &lt;code&gt;true&lt;/code&gt; （如果成功）或 &lt;code&gt;false&lt;/code&gt; （如果应该忽略），或者抛出 &lt;code&gt;LoginException&lt;/code&gt; 指定失败。在失败的情况下， &lt;code&gt;LoginModule&lt;/code&gt; 不得重试身份验证或引入延迟。此类任务的责任属于应用程序。如果应用程序尝试重试身份验证，将再次调用LoginModule的 &lt;code&gt;login&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="1c3fe9fba10b534da227fa8d485a94dde30e127c" translate="yes" xml:space="preserve">
          <source>The cancelled-key set</source>
          <target state="translated">取消的钥匙组</target>
        </trans-unit>
        <trans-unit id="7705f65a7bdd439c114a9df9b4c5a1d7648e03b2" translate="yes" xml:space="preserve">
          <source>The canonical form of the name.</source>
          <target state="translated">名的规范形式。</target>
        </trans-unit>
        <trans-unit id="a1104158561eadc7967dd83f5b89d12e9b6c57d4" translate="yes" xml:space="preserve">
          <source>The canonical key property list string. This string is independent of whether the ObjectName is a pattern.</source>
          <target state="translated">规范的键属性列表字符串。该字符串与ObjectName是否为模式无关。</target>
        </trans-unit>
        <trans-unit id="791454749861f9eb0692973f9cadb5f0f1a53c91" translate="yes" xml:space="preserve">
          <source>The canonical name of this charset</source>
          <target state="translated">该字符集的规范名称为</target>
        </trans-unit>
        <trans-unit id="210de0ba154cb7e2b8b0b68265e90339f4d9d26d" translate="yes" xml:space="preserve">
          <source>The canonical pathname of a file that resides on some other machine and is accessed via a remote-filesystem protocol such as SMB or NFS may or may not begin with one of the roots returned by this method. If the pathname of a remote file is syntactically indistinguishable from the pathname of a local file then it will begin with one of the roots returned by this method. Thus, for example, &lt;code&gt;File&lt;/code&gt; objects denoting the root directories of the mapped network drives of a Windows platform will be returned by this method, while &lt;code&gt;File&lt;/code&gt; objects containing UNC pathnames will not be returned by this method.</source>
          <target state="translated">驻留在其他计算机上并通过远程文件系统协议（例如SMB或NFS）访问的文件的规范路径名可能以也可能不是以此方法返回的根目录之一开头。如果远程文件的路径名在语法上与本地文件的路径名没有区别，则它将以此方法返回的根目录之一开始。因此，例如， &lt;code&gt;File&lt;/code&gt; 对象表示在Windows平台的映射的网络驱动器的根目录下将通过该方法返回，而 &lt;code&gt;File&lt;/code&gt; 对象含有UNC路径名不会通过该方法返回。</target>
        </trans-unit>
        <trans-unit id="de6a0ba5b090b016962ea6aeaab45878b7d009d1" translate="yes" xml:space="preserve">
          <source>The canonical pathname string denoting the same file or directory as this abstract pathname</source>
          <target state="translated">表示与该抽象路径名相同的文件或目录的规范路径名字符串。</target>
        </trans-unit>
        <trans-unit id="2dd69bbf6aa755d82287b8178393cdb4e9dc5d14" translate="yes" xml:space="preserve">
          <source>The capacity of this buffer</source>
          <target state="translated">该缓冲区的容量</target>
        </trans-unit>
        <trans-unit id="5f754be5b922ce10c49466dd844dfc855b60ce26" translate="yes" xml:space="preserve">
          <source>The captured input associated with a group is always the subsequence that the group most recently matched. If a group is evaluated a second time because of quantification then its previously-captured value, if any, will be retained if the second evaluation fails. Matching the string &lt;code&gt;&quot;aba&quot;&lt;/code&gt; against the expression &lt;code&gt;(a(b)?)+&lt;/code&gt;, for example, leaves group two set to &lt;code&gt;&quot;b&quot;&lt;/code&gt;. All captured input is discarded at the beginning of each match.</source>
          <target state="translated">与组关联的捕获输入始终是该组最近匹配的子序列。如果由于量化而对组进行第二次评估，则如果第二次评估失败，则将保留先前捕获的值（如果有）。例如，将字符串 &lt;code&gt;&quot;aba&quot;&lt;/code&gt; 与表达式 &lt;code&gt;(a(b)?)+&lt;/code&gt; 匹配，则将第二组设置为 &lt;code&gt;&quot;b&quot;&lt;/code&gt; 。在每次比赛开始时，所有捕获的输入都将被丢弃。</target>
        </trans-unit>
        <trans-unit id="454d106b2ed5373abf97288cbbf46f7fa9aede72" translate="yes" xml:space="preserve">
          <source>The carriage-return character (&lt;code&gt;'\u000D'&lt;/code&gt;)</source>
          <target state="translated">回车符（ &lt;code&gt;'\u000D'&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="a336e54edba2db7b0d45359eec9f772478b631f0" translate="yes" xml:space="preserve">
          <source>The case of names is significant. All names should be treated as case-sensitive. For example, some file systems have case-insensitive, case-aware file names. File objects representing such files should take care to preserve case by using &lt;a href=&quot;../../java/io/file#getCanonicalFile--&quot;&gt;&lt;code&gt;File.getCanonicalFile()&lt;/code&gt;&lt;/a&gt; or similar means. If the system is not case-aware, file objects must use other means to preserve case.</source>
          <target state="translated">名称的大小写很重要。所有名称都应区分大小写。例如，某些文件系统具有不区分大小写，可区分大小写的文件名。表示此类文件的文件对象应注意通过使用&lt;a href=&quot;../../java/io/file#getCanonicalFile--&quot;&gt; &lt;code&gt;File.getCanonicalFile()&lt;/code&gt; &lt;/a&gt;或类似方式来保留大小写。如果系统不区分大小写，则文件对象必须使用其他方式来保留大小写。</target>
        </trans-unit>
        <trans-unit id="a18ae82107d7074e97f5e1bfd9b5c68cb340a111" translate="yes" xml:space="preserve">
          <source>The central abstractions of the NIO APIs are:</source>
          <target state="translated">NIO APIs的核心抽象是:</target>
        </trans-unit>
        <trans-unit id="eea9d66af2319420cb90b9153a7f48fc60a2109b" translate="yes" xml:space="preserve">
          <source>The central authority, after computing the parameters, must send this information to the parties looking to agree on a secret key.</source>
          <target state="translated">中央主管部门在计算完参数后,必须将这些信息发送给希望商定秘密密钥的各方。</target>
        </trans-unit>
        <trans-unit id="c22f0301e2c96e02c998d11f05a81bda7ec13023" translate="yes" xml:space="preserve">
          <source>The certificate contains one or more unrecognized critical extensions.</source>
          <target state="translated">证书包含一个或多个未识别的关键扩展。</target>
        </trans-unit>
        <trans-unit id="b3f88fc74a60569eaa011ebfe60b8bb781fd8d80" translate="yes" xml:space="preserve">
          <source>The certificate does not chain correctly.</source>
          <target state="translated">证书不能正确连锁。</target>
        </trans-unit>
        <trans-unit id="b25d26b01801270f07001113d7e2c75485deab07" translate="yes" xml:space="preserve">
          <source>The certificate is expired.</source>
          <target state="translated">证书已过期。</target>
        </trans-unit>
        <trans-unit id="6e2ff8ce341f5930215309008c9e9de70d1648b6" translate="yes" xml:space="preserve">
          <source>The certificate is not a CA certificate.</source>
          <target state="translated">该证书不是CA证书。</target>
        </trans-unit>
        <trans-unit id="8b796401164cf6fe5dbe9be3e622da059437350d" translate="yes" xml:space="preserve">
          <source>The certificate is not yet valid.</source>
          <target state="translated">该证书尚未生效。</target>
        </trans-unit>
        <trans-unit id="ee1a1d0d8304f8fa5e5065bbc09eefcc09be7d06" translate="yes" xml:space="preserve">
          <source>The certificate is revoked.</source>
          <target state="translated">证书被撤销。</target>
        </trans-unit>
        <trans-unit id="e3899819dea82e37e000988814aa79fa88a75e2d" translate="yes" xml:space="preserve">
          <source>The certificate's key usage is invalid.</source>
          <target state="translated">证书的密钥用途无效。</target>
        </trans-unit>
        <trans-unit id="b384fb743347a5a12dacd02a3d76e6f93ee0b1f3" translate="yes" xml:space="preserve">
          <source>The certificates supplied must be of a type supported by the &lt;code&gt;CertificateFactory&lt;/code&gt;. They will be copied out of the supplied &lt;code&gt;List&lt;/code&gt; object.</source>
          <target state="translated">提供的证书必须是 &lt;code&gt;CertificateFactory&lt;/code&gt; 支持的类型。它们将从提供的 &lt;code&gt;List&lt;/code&gt; 对象中复制出来。</target>
        </trans-unit>
        <trans-unit id="7b98e8e58f22b3caa2eb436eb57fa4ba86980758" translate="yes" xml:space="preserve">
          <source>The change to</source>
          <target state="translated">改为</target>
        </trans-unit>
        <trans-unit id="3ef63324777b7b14fe754d2696b2ef9060c9840d" translate="yes" xml:space="preserve">
          <source>The channel</source>
          <target state="translated">渠道</target>
        </trans-unit>
        <trans-unit id="273f3a154b1e12746a05f884c9cef9ece2560ed9" translate="yes" xml:space="preserve">
          <source>The channel upon whose file this lock was acquired.</source>
          <target state="translated">这个锁是在谁的文件上获得的。</target>
        </trans-unit>
        <trans-unit id="1e0652fa3fbb3d765369e9f411541094bc17eda1" translate="yes" xml:space="preserve">
          <source>The channel's socket is configured so that it can receive datagrams from, and sends datagrams to, any remote address so long as the security manager, if installed, permits it.</source>
          <target state="translated">通道的套接字被配置为可以从任何远程地址接收数据报,并向任何远程地址发送数据报,只要安全管理器(如果安装)允许。</target>
        </trans-unit>
        <trans-unit id="118fc18fddf3f99946425aa7c2e5b6561b28a981" translate="yes" xml:space="preserve">
          <source>The channel's socket is configured so that it only receives datagrams from, and sends datagrams to, the given remote</source>
          <target state="translated">通道的套接字被配置为只从给定的远程接收数据报,并向其发送数据报。</target>
        </trans-unit>
        <trans-unit id="4c3b4f4f803181b3afa3181177892230a023a909" translate="yes" xml:space="preserve">
          <source>The channel's socket should be bound to the &lt;a href=&quot;../../net/inetaddress#isAnyLocalAddress--&quot;&gt;&lt;code&gt;wildcard&lt;/code&gt;&lt;/a&gt; address. If the socket is bound to a specific address, rather than the wildcard address then it is implementation specific if multicast datagrams are received by the socket.</source>
          <target state="translated">通道的套接字应绑定到&lt;a href=&quot;../../net/inetaddress#isAnyLocalAddress--&quot;&gt; &lt;code&gt;wildcard&lt;/code&gt; &lt;/a&gt;地址。如果套接字绑定到特定地址而不是通配符地址，则套接字是否接收到多播数据报是特定于实现的。</target>
        </trans-unit>
        <trans-unit id="a699f56014d87844a8ee4bb207efd8389c233bcd" translate="yes" xml:space="preserve">
          <source>The channel, once created, is not dependent upon the directory stream used to create it. Closing this directory stream has no effect upon the channel.</source>
          <target state="translated">通道一旦创建,就不依赖于用于创建它的目录流。关闭这个目录流对通道没有影响。</target>
        </trans-unit>
        <trans-unit id="7290d5e1f93c0657c60681207491c9d4282f5969" translate="yes" xml:space="preserve">
          <source>The char at the buffer's current position</source>
          <target state="translated">缓冲区当前位置的字符。</target>
        </trans-unit>
        <trans-unit id="54b64de4dceefa74c52963cd7e8709b225830d3a" translate="yes" xml:space="preserve">
          <source>The char at the given index</source>
          <target state="translated">在给定的索引上的字符</target>
        </trans-unit>
        <trans-unit id="0fb8540e46e037f0a55ee7cdb05c6a02e8b3244a" translate="yes" xml:space="preserve">
          <source>The char value at the buffer's current position</source>
          <target state="translated">缓冲区当前位置的字符值。</target>
        </trans-unit>
        <trans-unit id="38f5117adec7b8930b5b6167a3b737d62ce6af18" translate="yes" xml:space="preserve">
          <source>The char value at the given index</source>
          <target state="translated">给定索引的char值</target>
        </trans-unit>
        <trans-unit id="861556c9f709a544627b4ec57f4cad7a37448510" translate="yes" xml:space="preserve">
          <source>The character</source>
          <target state="translated">角色</target>
        </trans-unit>
        <trans-unit id="a31e6336561cb067818ee6d07b56859cf4a07e52" translate="yes" xml:space="preserve">
          <source>The character 'n'. The two characters represent a newline ('\n' in Java).</source>
          <target state="translated">字符'n'。这两个字符代表一个换行符(Java中的'/n')。</target>
        </trans-unit>
        <trans-unit id="99fe90d5b42df4311043f886ab6c19c1e8b75bb8" translate="yes" xml:space="preserve">
          <source>The character at index</source>
          <target state="translated">索引处的字符</target>
        </trans-unit>
        <trans-unit id="add7c9db1597ce73e7b64c0b4d75b5e5f46580e5" translate="yes" xml:space="preserve">
          <source>The character at index &lt;code&gt;position() + index&lt;/code&gt;</source>
          <target state="translated">索引 &lt;code&gt;position() + index&lt;/code&gt; 处的字符</target>
        </trans-unit>
        <trans-unit id="05cb1c2e1ff664b4468546f04c60b5ac72c5839e" translate="yes" xml:space="preserve">
          <source>The character at the specified index is set to &lt;code&gt;ch&lt;/code&gt;. This sequence is altered to represent a new character sequence that is identical to the old character sequence, except that it contains the character &lt;code&gt;ch&lt;/code&gt; at position &lt;code&gt;index&lt;/code&gt;.</source>
          <target state="translated">指定索引处的字符设置为 &lt;code&gt;ch&lt;/code&gt; 。更改此序列以表示一个与旧字符序列相同的新字符序列，不同之处在于它在位置 &lt;code&gt;index&lt;/code&gt; 处包含字符 &lt;code&gt;ch&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="60ad5395dc1ff483a8ff68c1464584af5830cab2" translate="yes" xml:space="preserve">
          <source>The character buffer.</source>
          <target state="translated">字符缓冲区。</target>
        </trans-unit>
        <trans-unit id="f53810bc7c23ad757010d0dee9a2d3f2d0f88c86" translate="yes" xml:space="preserve">
          <source>The character index of the first text boundary.</source>
          <target state="translated">第一个文本边界的字符索引。</target>
        </trans-unit>
        <trans-unit id="bf1cc285cf8f3350802731f918ab3a751880522f" translate="yes" xml:space="preserve">
          <source>The character index of the last text boundary.</source>
          <target state="translated">最后一个文本边界的字符索引。</target>
        </trans-unit>
        <trans-unit id="fbb25d884c4b95970cd226381775257633d22616" translate="yes" xml:space="preserve">
          <source>The character index of the next text boundary or &lt;code&gt;BreakIterator.DONE&lt;/code&gt; if the current boundary is the last text boundary. Equivalent to next(1).</source>
          <target state="translated">下一个文本边界的字符索引；如果当前边界是最后一个文本边界，则输入 &lt;code&gt;BreakIterator.DONE&lt;/code&gt; 。等效于next（1）。</target>
        </trans-unit>
        <trans-unit id="8f936cd2ad0aa613f11cba5c34739fa3c3541469" translate="yes" xml:space="preserve">
          <source>The character index of the nth boundary from the current position or &lt;code&gt;BreakIterator.DONE&lt;/code&gt; if either first or last text boundary has been reached.</source>
          <target state="translated">如果已到达第一个或最后一个文本边界，则从当前位置起第n个边界的字符索引或 &lt;code&gt;BreakIterator.DONE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2e9038b2d54c15a81fe437312a391d350ec427b8" translate="yes" xml:space="preserve">
          <source>The character index of the previous text boundary or &lt;code&gt;BreakIterator.DONE&lt;/code&gt; if the current boundary is the first text boundary.</source>
          <target state="translated">前一个文本边界的字符索引；如果当前边界是第一个文本边界，则为 &lt;code&gt;BreakIterator.DONE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="85a238174f4550c34f72f6ae6bc1bc6a516a69c0" translate="yes" xml:space="preserve">
          <source>The character is one of the fullwidth lowercase Latin letters a (&lt;code&gt;'\uFF41'&lt;/code&gt;) through z (&lt;code&gt;'\uFF5A'&lt;/code&gt;) and its code is less than &lt;code&gt;radix + '\uFF41' - 10&lt;/code&gt;. In this case, &lt;code&gt;ch - '\uFF41' + 10&lt;/code&gt; is returned.</source>
          <target state="translated">字符是全角小写拉丁字母a（ &lt;code&gt;'\uFF41'&lt;/code&gt; ）到z（ &lt;code&gt;'\uFF5A'&lt;/code&gt; ）之一，其代码小于 &lt;code&gt;radix + '\uFF41' - 10&lt;/code&gt; 。在这种情况下，将返回 &lt;code&gt;ch - '\uFF41' + 10&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="393a621e1493451e2055126ad0ce9ab6f642949f" translate="yes" xml:space="preserve">
          <source>The character is one of the fullwidth lowercase Latin letters a (&lt;code&gt;'\uFF41'&lt;/code&gt;) through z (&lt;code&gt;'\uFF5A'&lt;/code&gt;) and its code is less than &lt;code&gt;radix + '\uFF41'- 10&lt;/code&gt;. In this case, &lt;code&gt;codePoint - '\uFF41' + 10&lt;/code&gt; is returned.</source>
          <target state="translated">该字符是全角小写拉丁字母a（ &lt;code&gt;'\uFF41'&lt;/code&gt; ）到z（ &lt;code&gt;'\uFF5A'&lt;/code&gt; ）之一，其代码小于 &lt;code&gt;radix + '\uFF41'- 10&lt;/code&gt; 。在这种情况下，将返回 &lt;code&gt;codePoint - '\uFF41' + 10&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="57d9c7164d71a3374ba8edd927a1bf0f75b1189e" translate="yes" xml:space="preserve">
          <source>The character is one of the fullwidth uppercase Latin letters A (&lt;code&gt;'\uFF21'&lt;/code&gt;) through Z (&lt;code&gt;'\uFF3A'&lt;/code&gt;) and its code is less than &lt;code&gt;radix + '\uFF21' - 10&lt;/code&gt;. In this case, &lt;code&gt;ch - '\uFF21' + 10&lt;/code&gt; is returned.</source>
          <target state="translated">字符是全角大写拉丁字母A（ &lt;code&gt;'\uFF21'&lt;/code&gt; ）到Z（ &lt;code&gt;'\uFF3A'&lt;/code&gt; ）之一，其代码小于 &lt;code&gt;radix + '\uFF21' - 10&lt;/code&gt; 。在这种情况下，将返回 &lt;code&gt;ch - '\uFF21' + 10&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="732e1fdb20043b7a30607a5f809fab9e87fcf502" translate="yes" xml:space="preserve">
          <source>The character is one of the fullwidth uppercase Latin letters A (&lt;code&gt;'\uFF21'&lt;/code&gt;) through Z (&lt;code&gt;'\uFF3A'&lt;/code&gt;) and its code is less than &lt;code&gt;radix + '\uFF21' - 10&lt;/code&gt;. In this case, &lt;code&gt;codePoint - '\uFF21' + 10&lt;/code&gt; is returned.</source>
          <target state="translated">字符是全角大写拉丁字母A（ &lt;code&gt;'\uFF21'&lt;/code&gt; ）到Z（ &lt;code&gt;'\uFF3A'&lt;/code&gt; ）之一，其代码小于 &lt;code&gt;radix + '\uFF21' - 10&lt;/code&gt; 。在这种情况下，将返回 &lt;code&gt;codePoint - '\uFF21' + 10&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1eb711d346697b7b7850b866e9e676aabf15ad34" translate="yes" xml:space="preserve">
          <source>The character is one of the lowercase Latin letters &lt;code&gt;'a'&lt;/code&gt; through &lt;code&gt;'z'&lt;/code&gt; and its code is less than &lt;code&gt;radix + 'a' - 10&lt;/code&gt;. In this case, &lt;code&gt;ch - 'a' + 10&lt;/code&gt; is returned.</source>
          <target state="translated">该字符是小写拉丁字母 &lt;code&gt;'a'&lt;/code&gt; 到 &lt;code&gt;'z'&lt;/code&gt; 之一,并且其代码小于 &lt;code&gt;radix + 'a' - 10&lt;/code&gt; 。在这种情况下，将返回 &lt;code&gt;ch - 'a' + 10&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d4985c1ad0a3e0ebca4f21ca205a752bc0f9e0b1" translate="yes" xml:space="preserve">
          <source>The character is one of the lowercase Latin letters &lt;code&gt;'a'&lt;/code&gt; through &lt;code&gt;'z'&lt;/code&gt; and its code is less than &lt;code&gt;radix + 'a' - 10&lt;/code&gt;. In this case, &lt;code&gt;codePoint - 'a' + 10&lt;/code&gt; is returned.</source>
          <target state="translated">该字符是小写拉丁字母 &lt;code&gt;'a'&lt;/code&gt; 到 &lt;code&gt;'z'&lt;/code&gt; 之一,并且其代码小于 &lt;code&gt;radix + 'a' - 10&lt;/code&gt; 。在这种情况下，将返回 &lt;code&gt;codePoint - 'a' + 10&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="68f10c8de5bc4401e5a790943a291b720bd020f5" translate="yes" xml:space="preserve">
          <source>The character is one of the uppercase Latin letters &lt;code&gt;'A'&lt;/code&gt; through &lt;code&gt;'Z'&lt;/code&gt; and its code is less than &lt;code&gt;radix + 'A' - 10&lt;/code&gt;. In this case, &lt;code&gt;ch - 'A' + 10&lt;/code&gt; is returned.</source>
          <target state="translated">该字符是大写拉丁字母 &lt;code&gt;'A'&lt;/code&gt; 到 &lt;code&gt;'Z'&lt;/code&gt; 之一,并且其代码小于 &lt;code&gt;radix + 'A' - 10&lt;/code&gt; 。在这种情况下，将返回 &lt;code&gt;ch - 'A' + 10&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6fe9401de4bc97d32c2a8728ad43d7b3a78b4e99" translate="yes" xml:space="preserve">
          <source>The character is one of the uppercase Latin letters &lt;code&gt;'A'&lt;/code&gt; through &lt;code&gt;'Z'&lt;/code&gt; and its code is less than &lt;code&gt;radix + 'A' - 10&lt;/code&gt;. In this case, &lt;code&gt;codePoint - 'A' + 10&lt;/code&gt; is returned.</source>
          <target state="translated">该字符是大写拉丁字母 &lt;code&gt;'A'&lt;/code&gt; 到 &lt;code&gt;'Z'&lt;/code&gt; 之一,并且其代码小于 &lt;code&gt;radix + 'A' - 10&lt;/code&gt; 。在这种情况下，将返回 &lt;code&gt;codePoint - 'A' + 10&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e076b3a7eea32ed0dc7dc561e359383aa33f70c6" translate="yes" xml:space="preserve">
          <source>The character offset in the original text corresponding to the collation element that will be returned by the next call to next().</source>
          <target state="translated">原文中对应于整理元素的字符偏移量,将由下一次调用 next()返回。</target>
        </trans-unit>
        <trans-unit id="3a9b42a0d833d89c7e1ee55beda05f13b1e9a664" translate="yes" xml:space="preserve">
          <source>The character pair carriage return-line feed (CR-LF) means &quot;go to column 1 of the next line.&quot;</source>
          <target state="translated">字符对回车换行(CR-LF)的意思是 &quot;转到下一行的第1列&quot;。</target>
        </trans-unit>
        <trans-unit id="b579f6aaeea5b3484a7d5e231a38a6bf7bee9f9b" translate="yes" xml:space="preserve">
          <source>The character read, as an integer in the range 0 to 65535 (&lt;code&gt;0x00-0xffff&lt;/code&gt;), or -1 if the end of the stream has been reached</source>
          <target state="translated">读取的字符，范围为​​0到65535（ &lt;code&gt;0x00-0xffff&lt;/code&gt; ）之间的整数，如果已到达流的末尾，则为 -1</target>
        </trans-unit>
        <trans-unit id="b93b563951bc4c436a534356e0d109368effc806" translate="yes" xml:space="preserve">
          <source>The character read, or -1 if the end of the stream has been reached</source>
          <target state="translated">读取的字符,如果已经到达流的终点,则为-1。</target>
        </trans-unit>
        <trans-unit id="062f61a88c5bf0196c78c2d594f19eddc5f72256" translate="yes" xml:space="preserve">
          <source>The character sequence &lt;code&gt;\b&lt;/code&gt; does</source>
          <target state="translated">字符序列 &lt;code&gt;\b&lt;/code&gt; 可以</target>
        </trans-unit>
        <trans-unit id="11959f2e3bfff894e61388267b4d1d1ae5d3c0ba" translate="yes" xml:space="preserve">
          <source>The character used for the decimal point,</source>
          <target state="translated">用于小数点的字符。</target>
        </trans-unit>
        <trans-unit id="54a8a31a27f0561fd4d1442ec2d72b795702bba8" translate="yes" xml:space="preserve">
          <source>The character used to represent a decimal point may vary by culture. This method specifies the character to use.</source>
          <target state="translated">用来表示小数点的字符可能因文化而异。本方法指定了要使用的字符。</target>
        </trans-unit>
        <trans-unit id="b22f85c7da2590e363e7946610cf7ddeef47bdd8" translate="yes" xml:space="preserve">
          <source>The character used to represent a negative number may vary by culture. This method specifies the character to use.</source>
          <target state="translated">用来表示负数的字符可能因文化而异。本方法指定了要使用的字符。</target>
        </trans-unit>
        <trans-unit id="c3ef2b6ccf9ecfa410067e8549aece2c7416b126" translate="yes" xml:space="preserve">
          <source>The character used to represent a positive number may vary by culture. This method specifies the character to use.</source>
          <target state="translated">用来表示正数的字符可能因文化而异。本方法指定了要使用的字符。</target>
        </trans-unit>
        <trans-unit id="26f9cc43b601122c17d2fd77c4849184eb0350df" translate="yes" xml:space="preserve">
          <source>The character used to represent digits may vary by culture. This method specifies the zero character to use, which implies the characters for one to nine.</source>
          <target state="translated">用来表示数字的字符可能因文化而异。这种方法指定了要使用的零字符,这意味着1到9的字符。</target>
        </trans-unit>
        <trans-unit id="a005f0c7035b2bf5efb6b65407b084e0584a607c" translate="yes" xml:space="preserve">
          <source>The character used to separate thousands groups,</source>
          <target state="translated">用来分隔千组的字符。</target>
        </trans-unit>
        <trans-unit id="1edb505c87a80b6cf210744640fa626208a69fbc" translate="yes" xml:space="preserve">
          <source>The character with hexadecimal value &lt;code&gt;0x&lt;/code&gt;</source>
          <target state="translated">十六进制值为 &lt;code&gt;0x&lt;/code&gt; 的字符</target>
        </trans-unit>
        <trans-unit id="c84b095cdf29086ff619529958524051e0271274" translate="yes" xml:space="preserve">
          <source>The character with octal value &lt;code&gt;0&lt;/code&gt;</source>
          <target state="translated">八进制值 &lt;code&gt;0&lt;/code&gt; 的字符</target>
        </trans-unit>
        <trans-unit id="82172894cc0762c353026f8ba1c885f10551b86a" translate="yes" xml:space="preserve">
          <source>The character-to-digit mapping is provided by &lt;a href=&quot;../lang/character#digit-char-int-&quot;&gt;&lt;code&gt;Character.digit(char, int)&lt;/code&gt;&lt;/a&gt; set to convert to radix 10. The String may not contain any extraneous characters (whitespace, for example).</source>
          <target state="translated">字符到数字的映射是由设置为转换为基数10的&lt;a href=&quot;../lang/character#digit-char-int-&quot;&gt; &lt;code&gt;Character.digit(char, int)&lt;/code&gt; &lt;/a&gt;提供的。String不能包含任何多余的字符（例如，空格）。</target>
        </trans-unit>
        <trans-unit id="435d5181f703f0ee95ddc2bbae114562f2df9834" translate="yes" xml:space="preserve">
          <source>The characteristics of a given spliterator before splitting may differ from the characteristics after splitting. For specific examples see the characteristic values &lt;a href=&quot;spliterator#SIZED&quot;&gt;&lt;code&gt;SIZED&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;spliterator#SUBSIZED&quot;&gt;&lt;code&gt;SUBSIZED&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;spliterator#CONCURRENT&quot;&gt;&lt;code&gt;CONCURRENT&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">拆分之前给定拆分器的特性可能与拆分之后的特性有所不同。有关特定示例，请参见特性值&lt;a href=&quot;spliterator#SIZED&quot;&gt; &lt;code&gt;SIZED&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;spliterator#SUBSIZED&quot;&gt; &lt;code&gt;SUBSIZED&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;spliterator#CONCURRENT&quot;&gt; &lt;code&gt;CONCURRENT&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="28dbbf3eadec14e8427d691728ace1fef26d6786" translate="yes" xml:space="preserve">
          <source>The characters in the string &lt;code&gt;&quot;,;:$&amp;amp;+=&quot;&lt;/code&gt;</source>
          <target state="translated">字符串 &lt;code&gt;&quot;,;:$&amp;amp;+=&quot;&lt;/code&gt; 中的字符</target>
        </trans-unit>
        <trans-unit id="30cd469e4707a34de20913da0df9601ef8663134" translate="yes" xml:space="preserve">
          <source>The characters listed here are used in non-localized patterns. Localized patterns use the corresponding characters taken from this formatter's &lt;code&gt;DecimalFormatSymbols&lt;/code&gt; object instead, and these characters lose their special status. Two exceptions are the currency sign and quote, which are not localized.</source>
          <target state="translated">此处列出的字符用于非本地化模式。本地化模式使用从此格式化程序的 &lt;code&gt;DecimalFormatSymbols&lt;/code&gt; 对象获取的相应字符代替，这些字符会失去其特殊状态。货币符号和报价是两个例外，它们没有本地化。</target>
        </trans-unit>
        <trans-unit id="99f9de68302286576fe3ff6f67c73b8ba839df97" translate="yes" xml:space="preserve">
          <source>The characters of the &lt;code&gt;CharSequence&lt;/code&gt; argument are appended, in order, increasing the length of this sequence by the length of the argument.</source>
          <target state="translated">按顺序附加 &lt;code&gt;CharSequence&lt;/code&gt; 自变量的字符，以此序列的长度增加自变量的长度。</target>
        </trans-unit>
        <trans-unit id="131a3485d970889cbd1a189397eb208a790f9256" translate="yes" xml:space="preserve">
          <source>The characters of the &lt;code&gt;CharSequence&lt;/code&gt; argument are inserted, in order, into this sequence at the indicated offset, moving up any characters originally above that position and increasing the length of this sequence by the length of the argument s.</source>
          <target state="translated">将 &lt;code&gt;CharSequence&lt;/code&gt; 自变量的字符按指定的偏移量顺序插入此序列中，将原来在该位置上方的所有字符上移，并将该序列的长度增加自变量s的长度。</target>
        </trans-unit>
        <trans-unit id="f293b85c86723e9d3bf915086157971fe6916192" translate="yes" xml:space="preserve">
          <source>The characters of the &lt;code&gt;String&lt;/code&gt; argument are appended, in order, increasing the length of this sequence by the length of the argument. If &lt;code&gt;str&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, then the four characters &lt;code&gt;&quot;null&quot;&lt;/code&gt; are appended.</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; 参数的字符按顺序附加，以此序列的长度增加参数的长度。如果 &lt;code&gt;str&lt;/code&gt; 为 &lt;code&gt;null&lt;/code&gt; ，则附加四个字符 &lt;code&gt;&quot;null&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4608ed44802d04c08139f51bfa64aeda4d30bd74" translate="yes" xml:space="preserve">
          <source>The characters of the &lt;code&gt;String&lt;/code&gt; argument are inserted, in order, into this sequence at the indicated offset, moving up any characters originally above that position and increasing the length of this sequence by the length of the argument. If &lt;code&gt;str&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, then the four characters &lt;code&gt;&quot;null&quot;&lt;/code&gt; are inserted into this sequence.</source>
          <target state="translated">将 &lt;code&gt;String&lt;/code&gt; 自变量的字符按指定的偏移量顺序插入此序列中，将原来在该位置上方的所有字符上移，然后将此序列的长度增加自变量的长度。如果 &lt;code&gt;str&lt;/code&gt; 为 &lt;code&gt;null&lt;/code&gt; ，则将四个字符 &lt;code&gt;&quot;null&quot;&lt;/code&gt; 插入此序列。</target>
        </trans-unit>
        <trans-unit id="79d83c330c94a3aa502af5b18cdbaab8bce643e4" translate="yes" xml:space="preserve">
          <source>The characters of the &lt;code&gt;StringBuffer&lt;/code&gt; argument are appended, in order, to the contents of this &lt;code&gt;StringBuffer&lt;/code&gt;, increasing the length of this &lt;code&gt;StringBuffer&lt;/code&gt; by the length of the argument. If &lt;code&gt;sb&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, then the four characters &lt;code&gt;&quot;null&quot;&lt;/code&gt; are appended to this &lt;code&gt;StringBuffer&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;StringBuffer&lt;/code&gt; 自变量的字符按顺序附加到此 &lt;code&gt;StringBuffer&lt;/code&gt; 的内容，从而通过参数的长度增加此 &lt;code&gt;StringBuffer&lt;/code&gt; 的长度。如果 &lt;code&gt;sb&lt;/code&gt; 为 &lt;code&gt;null&lt;/code&gt; ，则将四个字符 &lt;code&gt;&quot;null&quot;&lt;/code&gt; 附加到此 &lt;code&gt;StringBuffer&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7edc50505e461cd6fdf61331e374acd6a8173601" translate="yes" xml:space="preserve">
          <source>The characters of the &lt;code&gt;StringBuffer&lt;/code&gt; argument are appended, in order, to this sequence, increasing the length of this sequence by the length of the argument. If &lt;code&gt;sb&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, then the four characters &lt;code&gt;&quot;null&quot;&lt;/code&gt; are appended to this sequence.</source>
          <target state="translated">将 &lt;code&gt;StringBuffer&lt;/code&gt; 自变量的字符按顺序附加到此序列，使该序列的长度增加自变量的长度。如果 &lt;code&gt;sb&lt;/code&gt; 为 &lt;code&gt;null&lt;/code&gt; ，则将四个字符 &lt;code&gt;&quot;null&quot;&lt;/code&gt; 附加到此序列。</target>
        </trans-unit>
        <trans-unit id="5790ab1c515a529581222483c7c357bb2b14a2d7" translate="yes" xml:space="preserve">
          <source>The characters of the array argument are appended, in order, to the contents of this sequence. The length of this sequence increases by the length of the argument.</source>
          <target state="translated">数组参数的字符依次追加到这个序列的内容上。这个序列的长度随参数的长度而增加。</target>
        </trans-unit>
        <trans-unit id="44ce3e7b31696b9d255c03623ddf7ab6eef4959a" translate="yes" xml:space="preserve">
          <source>The characters of the array argument are inserted into the contents of this sequence at the position indicated by &lt;code&gt;offset&lt;/code&gt;. The length of this sequence increases by the length of the argument.</source>
          <target state="translated">数组参数的字符在 &lt;code&gt;offset&lt;/code&gt; 指示的位置插入到此序列的内容中。该序列的长度增加自变量的长度。</target>
        </trans-unit>
        <trans-unit id="a2e130797df8bfbb83081b72694f55f678e4cdeb" translate="yes" xml:space="preserve">
          <source>The characters to be appended should be valid Unicode characters as described in &lt;a href=&quot;character#unicode&quot;&gt;Unicode Character Representation&lt;/a&gt;. Note that supplementary characters may be composed of multiple 16-bit &lt;code&gt;char&lt;/code&gt; values.</source>
          <target state="translated">如&lt;a href=&quot;character#unicode&quot;&gt;Unicode字符表示中&lt;/a&gt;所述，要附加的字符应该是有效的Unicode字符。请注意，补充字符可能由多个16位 &lt;code&gt;char&lt;/code&gt; 值组成。</target>
        </trans-unit>
        <trans-unit id="2a2ed22fca7e3896fc3bc86e089e89c687ca7a5b" translate="yes" xml:space="preserve">
          <source>The chars between the buffer's current position and its limit, if any, are copied to the beginning of the buffer. That is, the char at index</source>
          <target state="translated">缓冲区当前位置和极限之间的字符(如果有的话)会被复制到缓冲区的开头。也就是说,位于索引</target>
        </trans-unit>
        <trans-unit id="2eb67236cbfc275c0a8a4f77193881e74832ba7b" translate="yes" xml:space="preserve">
          <source>The charset detected by this auto-detecting decoder, or &lt;code&gt;null&lt;/code&gt; if the charset has not yet been determined</source>
          <target state="translated">此自动检测解码器检测到的字符集；如果尚未确定字符集，则为 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="024b1b6be1629de97b24774ad57c6eda0415a449" translate="yes" xml:space="preserve">
          <source>The charset used is the &lt;a href=&quot;../nio/charset/charset#defaultCharset--&quot;&gt;default charset&lt;/a&gt; for this instance of the Java virtual machine.</source>
          <target state="translated">使用的&lt;a href=&quot;../nio/charset/charset#defaultCharset--&quot;&gt;字符集&lt;/a&gt;是此Java虚拟机实例的默认字符集。</target>
        </trans-unit>
        <trans-unit id="c8fd2435042ade2989834d385b33d7983d058f57" translate="yes" xml:space="preserve">
          <source>The children of an element must conform to one of a few simple patterns, described in the documentation for the &lt;code&gt;CHILD_*&lt;/code&gt; constants;</source>
          <target state="translated">元素的子元素必须符合 &lt;code&gt;CHILD_*&lt;/code&gt; 常量文档中所述的几种简单模式之一；</target>
        </trans-unit>
        <trans-unit id="5ed4829be2fc8be2f19b67a2fdfd7c5f6f6f875e" translate="yes" xml:space="preserve">
          <source>The choice should be made based on which makes the code more readable.</source>
          <target state="translated">应根据哪种方式使代码更易读来选择。</target>
        </trans-unit>
        <trans-unit id="81abce803b2b576873096c050698e84ce7b2adb3" translate="yes" xml:space="preserve">
          <source>The chronology is determined. The chronology of the result is either the chronology that was parsed, or if no chronology was parsed, it is the chronology set on this class, or if that is null, it is &lt;code&gt;IsoChronology&lt;/code&gt;.</source>
          <target state="translated">确定了年代。结果的时间顺序要么是已解析的时间顺序，要么是如果未解析任何时间顺序，则是在此类上设置的时间顺序，如果为null，则是 &lt;code&gt;IsoChronology&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a16292e267ee8e923f5ad107d6d91fc2c30e6c22" translate="yes" xml:space="preserve">
          <source>The chronology may be a system chronology or a chronology provided by the application via ServiceLoader configuration.</source>
          <target state="translated">年表可以是系统年表,也可以是应用程序通过ServiceLoader配置提供的年表。</target>
        </trans-unit>
        <trans-unit id="de1734dbd2ea904560b6d9da0267c5e3bc7d2d75" translate="yes" xml:space="preserve">
          <source>The chronology of the first date is used. The chronology of the second date is ignored, with the date being converted to the target chronology system before the calculation starts.</source>
          <target state="translated">使用第一个日期的年表。第二个日期的年表被忽略,日期在计算开始前被转换为目标年表系统。</target>
        </trans-unit>
        <trans-unit id="782f61b1130e60fa0fb037f8e4955382779eb421" translate="yes" xml:space="preserve">
          <source>The chunk-length when using chunked encoding streaming mode for output. A value of &lt;code&gt;-1&lt;/code&gt; means chunked encoding is disabled for output.</source>
          <target state="translated">使用分块编码流传输模式进行输出时的分块长度。值为 &lt;code&gt;-1&lt;/code&gt; 表示将禁用分块编码以进行输出。</target>
        </trans-unit>
        <trans-unit id="b625f56a9aa5a9cfd0dba0b4ba26b41f91c3d8d0" translate="yes" xml:space="preserve">
          <source>The cipher is initialized for one of the following four operations: encryption, decryption, key wrapping or key unwrapping, depending on the value of &lt;code&gt;opmode&lt;/code&gt;.</source>
          <target state="translated">针对以下四个操作之一初始化密码：加密，解密，密钥包装或密钥解包，具体取决于 &lt;code&gt;opmode&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="a7062f5c31a9aefcc821d9d0c94628fe97a3602f" translate="yes" xml:space="preserve">
          <source>The cipher suite used is established by a negotiation process called &quot;handshaking&quot;. The goal of this process is to create or rejoin a &quot;session&quot;, which may protect many connections over time. After handshaking has completed, you can access session attributes by using the &lt;a href=&quot;sslengine#getSession--&quot;&gt;&lt;code&gt;getSession()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">使用的密码套件是通过称为&amp;ldquo;握手&amp;rdquo;的协商过程建立的。此过程的目标是创建或重新加入&amp;ldquo;会话&amp;rdquo;，以保护许多连接。握手完成后，可以使用&lt;a href=&quot;sslengine#getSession--&quot;&gt; &lt;code&gt;getSession()&lt;/code&gt; &lt;/a&gt;方法访问会话属性。</target>
        </trans-unit>
        <trans-unit id="b4991f1ddbcd690dbea95abe4922ab873f65fad7" translate="yes" xml:space="preserve">
          <source>The cipher suite used is established by a negotiation process called &quot;handshaking&quot;. The goal of this process is to create or rejoin a &quot;session&quot;, which may protect many connections over time. After handshaking has completed, you can access session attributes by using the &lt;em&gt;getSession&lt;/em&gt; method. The initial handshake on this connection can be initiated in one of three ways:</source>
          <target state="translated">使用的密码套件是通过称为&amp;ldquo;握手&amp;rdquo;的协商过程建立的。此过程的目标是创建或重新加入&amp;ldquo;会话&amp;rdquo;，以保护许多连接。握手完成后，可以使用&lt;em&gt;getSession&lt;/em&gt;方法访问会话属性。可以通过以下三种方式之一启动此连接上的初始握手：</target>
        </trans-unit>
        <trans-unit id="83ac4045333504efe877655bdd2b37e50cb50200" translate="yes" xml:space="preserve">
          <source>The cipher suites must have been listed by getSupportedCipherSuites() as being supported. Following a successful call to this method, only suites listed in the &lt;code&gt;suites&lt;/code&gt; parameter are enabled for use.</source>
          <target state="translated">密码套件必须已由getSupportedCipherSuites（）列出为受支持。成功调用此方法后，仅启用 &lt;code&gt;suites&lt;/code&gt; 参数中列出的套件。</target>
        </trans-unit>
        <trans-unit id="b1dff289b9d5493dc4b93e102227e4045f5c8b60" translate="yes" xml:space="preserve">
          <source>The circular buffer into which incoming data is placed.</source>
          <target state="translated">放置输入数据的循环缓冲区。</target>
        </trans-unit>
        <trans-unit id="b2f5972a5da0630a3ea1ce16a259ac7e2bc027c1" translate="yes" xml:space="preserve">
          <source>The class &lt;a href=&quot;methodhandle&quot;&gt;&lt;code&gt;MethodHandle&lt;/code&gt;&lt;/a&gt; contains &lt;a href=&quot;methodhandle#sigpoly&quot;&gt;signature polymorphic methods&lt;/a&gt; which can be linked regardless of their type descriptor. Normally, method linkage requires exact matching of type descriptors.</source>
          <target state="translated">&lt;a href=&quot;methodhandle&quot;&gt; &lt;code&gt;MethodHandle&lt;/code&gt; &lt;/a&gt;类包含&lt;a href=&quot;methodhandle#sigpoly&quot;&gt;签名多态方法&lt;/a&gt;，无论它们的类型描述符如何，都可以链接它们。通常，方法链接需要类型描述符的精确匹配。</target>
        </trans-unit>
        <trans-unit id="eab9997c80610f9c64f20b81263d0bcfad837f30" translate="yes" xml:space="preserve">
          <source>The class &lt;a href=&quot;requiredmodelmbean&quot;&gt;&lt;code&gt;RequiredModelMBean&lt;/code&gt;&lt;/a&gt; provides a standard Model MBean implementation.</source>
          <target state="translated">类&lt;a href=&quot;requiredmodelmbean&quot;&gt; &lt;code&gt;RequiredModelMBean&lt;/code&gt; &lt;/a&gt;提供了标准的Model MBean实现。</target>
        </trans-unit>
        <trans-unit id="e2db3d1c22a729a290e85045bcd4bfe1eb80a35a" translate="yes" xml:space="preserve">
          <source>The class &lt;a href=&quot;streamsupport&quot;&gt;&lt;code&gt;StreamSupport&lt;/code&gt;&lt;/a&gt; has a number of low-level methods for creating a stream, all using some form of a &lt;a href=&quot;../spliterator&quot;&gt;&lt;code&gt;Spliterator&lt;/code&gt;&lt;/a&gt;. A spliterator is the parallel analogue of an &lt;a href=&quot;../iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;; it describes a (possibly infinite) collection of elements, with support for sequentially advancing, bulk traversal, and splitting off some portion of the input into another spliterator which can be processed in parallel. At the lowest level, all streams are driven by a spliterator.</source>
          <target state="translated">&lt;a href=&quot;streamsupport&quot;&gt; &lt;code&gt;StreamSupport&lt;/code&gt; &lt;/a&gt;类具有许多用于创建流的低级方法，所有方法均使用某种形式的&lt;a href=&quot;../spliterator&quot;&gt; &lt;code&gt;Spliterator&lt;/code&gt; &lt;/a&gt;。分离器是&lt;a href=&quot;../iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;的并行模拟; 它描述了一个（可能是无限的）元素集合，并支持顺序前进，批量遍历以及将输入的一部分分解为另一个可以并行处理的分离器。在最低级别，所有流均由分离器驱动。</target>
        </trans-unit>
        <trans-unit id="684f89869c3a9936722182499d56cdcd4cbcf40a" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;Date&lt;/code&gt; represents a specific instant in time, with millisecond precision.</source>
          <target state="translated">&lt;code&gt;Date&lt;/code&gt; 类表示特定的时间瞬间，精度为毫秒。</target>
        </trans-unit>
        <trans-unit id="f304ba88bc19705d6cbe2036bbfe4f2d2fdb0d77" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;Exception&lt;/code&gt; and any subclasses that are not also subclasses of &lt;a href=&quot;runtimeexception&quot;&gt;&lt;code&gt;RuntimeException&lt;/code&gt;&lt;/a&gt; are &lt;em&gt;checked exceptions&lt;/em&gt;. Checked exceptions need to be declared in a method or constructor's &lt;code&gt;throws&lt;/code&gt; clause if they can be thrown by the execution of the method or constructor and propagate outside the method or constructor boundary.</source>
          <target state="translated">&lt;code&gt;Exception&lt;/code&gt; 类和不是&lt;a href=&quot;runtimeexception&quot;&gt; &lt;code&gt;RuntimeException&lt;/code&gt; &lt;/a&gt;子类的任何子类都是已&lt;em&gt;检查异常&lt;/em&gt;。如果检查的异常可以由方法或构造函数的执行抛出并在方法或构造函数边界之外传播，则需要在方法或构造函数的 &lt;code&gt;throws&lt;/code&gt; 子句中声明它们。</target>
        </trans-unit>
        <trans-unit id="b63ddbb8255c4c5cc301a4d4eeaca5eac941924c" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;Exception&lt;/code&gt; and its subclasses are a form of &lt;code&gt;Throwable&lt;/code&gt; that indicates conditions that a reasonable application might want to catch.</source>
          <target state="translated">&lt;code&gt;Exception&lt;/code&gt; 类及其子类是 &lt;code&gt;Throwable&lt;/code&gt; 的一种形式，它指示合理的应用程序可能希望捕获的条件。</target>
        </trans-unit>
        <trans-unit id="690c5f3da265a415109fd3011e41d9d5ea3c3c22" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;FilterOutputStream&lt;/code&gt; itself simply overrides all methods of &lt;code&gt;OutputStream&lt;/code&gt; with versions that pass all requests to the underlying output stream. Subclasses of &lt;code&gt;FilterOutputStream&lt;/code&gt; may further override some of these methods as well as provide additional methods and fields.</source>
          <target state="translated">类 &lt;code&gt;FilterOutputStream&lt;/code&gt; 本身简单地使用将所有请求传递到基础输出流的版本覆盖 &lt;code&gt;OutputStream&lt;/code&gt; 的所有方法。 &lt;code&gt;FilterOutputStream&lt;/code&gt; 的子类可以进一步覆盖其中的某些方法，并提供其他方法和字段。</target>
        </trans-unit>
        <trans-unit id="aa85724edba155c1163af251f7e5b2a8e32a3730" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;Math&lt;/code&gt; contains methods for performing basic numeric operations such as the elementary exponential, logarithm, square root, and trigonometric functions.</source>
          <target state="translated">&lt;code&gt;Math&lt;/code&gt; 类包含用于执行基本数值运算的方法，例如基本指数，对数，平方根和三角函数。</target>
        </trans-unit>
        <trans-unit id="e1871b5ab32d2e12a446537bb7460fb5726d74b1" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;Math&lt;/code&gt; provides commonly used mathematical functions such as sine, cosine, and square root. The classes &lt;code&gt;String&lt;/code&gt;, &lt;code&gt;StringBuffer&lt;/code&gt;, and &lt;code&gt;StringBuilder&lt;/code&gt; similarly provide commonly used operations on character strings.</source>
          <target state="translated">&lt;code&gt;Math&lt;/code&gt; 类提供了常用的数学函数，例如正弦，余弦和平方根。类似地， &lt;code&gt;String&lt;/code&gt; ， &lt;code&gt;StringBuffer&lt;/code&gt; 和 &lt;code&gt;StringBuilder&lt;/code&gt; 类提供了对字符串的常用操作。</target>
        </trans-unit>
        <trans-unit id="3791863b130a0f270b24ef71c5a66eb3739e86ed" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;Object&lt;/code&gt; does not itself implement the interface &lt;code&gt;Cloneable&lt;/code&gt;, so calling the &lt;code&gt;clone&lt;/code&gt; method on an object whose class is &lt;code&gt;Object&lt;/code&gt; will result in throwing an exception at run time.</source>
          <target state="translated">&lt;code&gt;Object&lt;/code&gt; 类本身并不实现 &lt;code&gt;Cloneable&lt;/code&gt; 接口，因此在其类为 &lt;code&gt;Object&lt;/code&gt; 的对象上调用 &lt;code&gt;clone&lt;/code&gt; 方法将导致在运行时引发异常。</target>
        </trans-unit>
        <trans-unit id="0624cc2712e980f0b92fbdb7083e89abc8924f4c" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;StrictMath&lt;/code&gt; contains methods for performing basic numeric operations such as the elementary exponential, logarithm, square root, and trigonometric functions.</source>
          <target state="translated">类 &lt;code&gt;StrictMath&lt;/code&gt; 包含用于执行基本数字操作，如指数，对数，平方根和三角函数的方法。</target>
        </trans-unit>
        <trans-unit id="0402c5931dd701f0cf78b33e69e39d00d48ee21d" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;String&lt;/code&gt; includes methods for examining individual characters of the sequence, for comparing strings, for searching strings, for extracting substrings, and for creating a copy of a string with all characters translated to uppercase or to lowercase. Case mapping is based on the Unicode Standard version specified by the &lt;a href=&quot;character&quot;&gt;&lt;code&gt;Character&lt;/code&gt;&lt;/a&gt; class.</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; 类包括用于检查序列中的各个字符，比较字符串，搜索字符串，提取子字符串以及创建字符串的副本的方法，这些字符串的所有字符均转换为大写或小写。大小写映射基于&lt;a href=&quot;character&quot;&gt; &lt;code&gt;Character&lt;/code&gt; &lt;/a&gt;类指定的Unicode标准版本。</target>
        </trans-unit>
        <trans-unit id="4f0e14063482da03a9517e0315c86c6d5e0da2a1" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;ThreadDeath&lt;/code&gt; is specifically a subclass of &lt;code&gt;Error&lt;/code&gt; rather than &lt;code&gt;Exception&lt;/code&gt;, even though it is a &quot;normal occurrence&quot;, because many applications catch all occurrences of &lt;code&gt;Exception&lt;/code&gt; and then discard the exception.</source>
          <target state="translated">类 &lt;code&gt;ThreadDeath&lt;/code&gt; 特别是子类 &lt;code&gt;Error&lt;/code&gt; ，而不是 &lt;code&gt;Exception&lt;/code&gt; ，尽管它是一个&amp;ldquo;正常现象&amp;rdquo;，因为许多应用程序赶上所有出现 &lt;code&gt;Exception&lt;/code&gt; ，然后丢弃异常。</target>
        </trans-unit>
        <trans-unit id="0ed9f55caeaa2d309bd40ff62b6a14ba0f7f4c18" translate="yes" xml:space="preserve">
          <source>The class Authenticator represents an object that knows how to obtain authentication for a network connection.</source>
          <target state="translated">Authenticator类表示一个知道如何获取网络连接的认证的对象。</target>
        </trans-unit>
        <trans-unit id="73f3f95a1b4468727a1f47724f198e0b3a19ce9c" translate="yes" xml:space="preserve">
          <source>The class Authenticator represents an object that knows how to obtain authentication for a network connection. Usually, it will do this by prompting the user for information.</source>
          <target state="translated">Authenticator类代表了一个知道如何获取网络连接认证的对象。通常,它将通过提示用户提供信息来实现。</target>
        </trans-unit>
        <trans-unit id="3ec0063817bf0bc470163e5295aa4de585ae7fe9" translate="yes" xml:space="preserve">
          <source>The class PasswordAuthentication is a data holder that is used by Authenticator.</source>
          <target state="translated">类PasswordAuthentication是一个由Authenticator使用的数据持有者。</target>
        </trans-unit>
        <trans-unit id="5dab3bdf681d65e4650c5df8d97994c50a3f16e6" translate="yes" xml:space="preserve">
          <source>The class PasswordAuthentication is a data holder that is used by Authenticator. It is simply a repository for a user name and a password.</source>
          <target state="translated">类PasswordAuthentication是一个由Authenticator使用的数据保存器。它只是一个用户名和密码的存储库。</target>
        </trans-unit>
        <trans-unit id="26afb3f34e19b6dd2d9b7a7cbd9df2a19bd4ff5c" translate="yes" xml:space="preserve">
          <source>The class also has methods for reading files, streams, and URLs that contain standard MIDI file data or soundbanks. You can query the &lt;code&gt;MidiSystem&lt;/code&gt; for the format of a specified MIDI file.</source>
          <target state="translated">该类还具有读取包含标准MIDI文件数据或音库的文件，流和URL的方法。您可以向 &lt;code&gt;MidiSystem&lt;/code&gt; 查询指定的MIDI文件的格式。</target>
        </trans-unit>
        <trans-unit id="8eec387ca6bcd129da5be587045e11a4e69c7d0e" translate="yes" xml:space="preserve">
          <source>The class also provides additional fields and methods for implementing a concrete calendar system outside the package. Those fields and methods are defined as &lt;code&gt;protected&lt;/code&gt;.</source>
          <target state="translated">该类还提供了其他字段和方法，用于在程序包外部实现具体的日历系统。这些字段和方法被定义为 &lt;code&gt;protected&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a83c31be57eb77d002f6fb8561dbfe1c5447ab07" translate="yes" xml:space="preserve">
          <source>The class also provides two methods to map between its constants and the corresponding Calendar constants.</source>
          <target state="translated">该类还提供了两个方法来映射其常量和相应的日历常量。</target>
        </trans-unit>
        <trans-unit id="9d313501a82f92b26a3e6cf1bf80484b0ab03c45" translate="yes" xml:space="preserve">
          <source>The class contains unknown datatypes</source>
          <target state="translated">该类包含未知的数据类型</target>
        </trans-unit>
        <trans-unit id="13d93d9b734d66221117665181f602c5532671b0" translate="yes" xml:space="preserve">
          <source>The class declares methods with the name given by &lt;code&gt;invokedName&lt;/code&gt;, and the signature given by &lt;code&gt;samMethodType&lt;/code&gt; and additional signatures given by &lt;code&gt;bridges&lt;/code&gt;</source>
          <target state="translated">该类声明方法的名称由 &lt;code&gt;invokedName&lt;/code&gt; 给出，签名由 &lt;code&gt;samMethodType&lt;/code&gt; 赋予， &lt;code&gt;bridges&lt;/code&gt; 附加的签名</target>
        </trans-unit>
        <trans-unit id="b60cd2a193307541db7fa376009f616ad9f49e04" translate="yes" xml:space="preserve">
          <source>The class does not have an accessible no-arg constructor</source>
          <target state="translated">该类没有一个可访问的无参数构造函数。</target>
        </trans-unit>
        <trans-unit id="cff5ea3c8c8e7aecbb4dbea85724a31e5e8e8645" translate="yes" xml:space="preserve">
          <source>The class fingerprint that is set to indicate serialization compatibility since J2SE 1.4.</source>
          <target state="translated">自J2SE 1.4以来,被设置为表示序列化兼容性的类指纹。</target>
        </trans-unit>
        <trans-unit id="3e56e7ff07bb8781fefafcc3605938ed932d77d3" translate="yes" xml:space="preserve">
          <source>The class fingerprint that is set to indicate serialization compatibility with a previous version of the class.</source>
          <target state="translated">设置的类指纹,表示与以前版本的类的序列化兼容性。</target>
        </trans-unit>
        <trans-unit id="a00aa6be9da30f0a48df242c586c275d828683b4" translate="yes" xml:space="preserve">
          <source>The class fingerprint that is set to indicate serialization compatibility.</source>
          <target state="translated">设置为表示序列化兼容性的类指纹。</target>
        </trans-unit>
        <trans-unit id="135e02082cd84a88b5861571042a7fe763a97717" translate="yes" xml:space="preserve">
          <source>The class implements a buffered output stream.</source>
          <target state="translated">该类实现了一个缓冲的输出流。</target>
        </trans-unit>
        <trans-unit id="8460a541a46a3829ad6445b112d205f85871207c" translate="yes" xml:space="preserve">
          <source>The class implements a buffered output stream. By setting up such an output stream, an application can write bytes to the underlying output stream without necessarily causing a call to the underlying system for each byte written.</source>
          <target state="translated">该类实现了一个缓冲的输出流。通过设置这样的输出流,应用程序可以向底层输出流写入字节,而不需要为每个写入的字节引起对底层系统的调用。</target>
        </trans-unit>
        <trans-unit id="3dfc1a1ea31b195bebaa4b8045733e43e88ceaec" translate="yes" xml:space="preserve">
          <source>The class implements the interface named by the return type of &lt;code&gt;invokedType&lt;/code&gt; and any interfaces named by &lt;code&gt;markerInterfaces&lt;/code&gt;</source>
          <target state="translated">该类实现以 &lt;code&gt;invokedType&lt;/code&gt; 的返回类型命名的接口以及以 &lt;code&gt;markerInterfaces&lt;/code&gt; 命名的任何接口</target>
        </trans-unit>
        <trans-unit id="89aaf05f9154c5d639e3b220e9a279db91a285c9" translate="yes" xml:space="preserve">
          <source>The class implies a maximum level of access permission, but the permissions may be additionally limited by the bitmask &lt;a href=&quot;methodhandles.lookup#lookupModes--&quot;&gt;&lt;code&gt;lookupModes&lt;/code&gt;&lt;/a&gt;, which controls whether non-public members can be accessed.</source>
          <target state="translated">该类隐含最大级别的访问权限，但是该权限可能还受bitmask &lt;a href=&quot;methodhandles.lookup#lookupModes--&quot;&gt; &lt;code&gt;lookupModes&lt;/code&gt; 的&lt;/a&gt;限制，该位控制了是否可以访问非公共成员。</target>
        </trans-unit>
        <trans-unit id="07a936057fd298f90ef4620016e6ba3d49dac02a" translate="yes" xml:space="preserve">
          <source>The class is designed so that there's never more than one &lt;code&gt;Currency&lt;/code&gt; instance for any given currency. Therefore, there's no public constructor. You obtain a &lt;code&gt;Currency&lt;/code&gt; instance using the &lt;code&gt;getInstance&lt;/code&gt; methods.</source>
          <target state="translated">设计该类的目的是使任何给定货币不超过一个 &lt;code&gt;Currency&lt;/code&gt; 实例。因此，没有公共构造函数。您可以使用 &lt;code&gt;getInstance&lt;/code&gt; 方法获取 &lt;code&gt;Currency&lt;/code&gt; 实例。</target>
        </trans-unit>
        <trans-unit id="4ba87f5fbbddbc4d6864e72595ed2ed1025acbc6" translate="yes" xml:space="preserve">
          <source>The class is examined for getters using the conventions &lt;a href=&quot;#naming-conv&quot;&gt;above&lt;/a&gt;. (Getters must be public instance methods.) If there are no getters, or if any getter has a type that is not convertible, then &lt;em&gt;J&lt;/em&gt; is not convertible.</source>
          <target state="translated">类被检查使用的约定吸气&lt;a href=&quot;#naming-conv&quot;&gt;以上&lt;/a&gt;。（字母必须是公共实例方法。）如果没有getter，或者任何getter具有不可转换的类型，则&lt;em&gt;J&lt;/em&gt;不可转换。</target>
        </trans-unit>
        <trans-unit id="6a46a2bceba51e26038bcf8bf9c04983b0c81d03" translate="yes" xml:space="preserve">
          <source>The class may override methods from &lt;code&gt;Object&lt;/code&gt;, and may implement methods related to serialization.</source>
          <target state="translated">该类可以覆盖 &lt;code&gt;Object&lt;/code&gt; 中的方法，并且可以实现与序列化有关的方法。</target>
        </trans-unit>
        <trans-unit id="b6eb7d47c9875da75274f0ffa32e24741e2b6b2d" translate="yes" xml:space="preserve">
          <source>The class name of the factory that creates the resulting context has the naming convention</source>
          <target state="translated">创建所产生的上下文的工厂的类名具有以下命名约定。</target>
        </trans-unit>
        <trans-unit id="32fd5d586f202bbf77341f1d00fc8fc880091605" translate="yes" xml:space="preserve">
          <source>The class name, member and object name parameters define a target name of the form &quot;&lt;code&gt;className#member[objectName]&lt;/code&gt;&quot; where each part is optional. This will be the result of &lt;a href=&quot;../../java/security/permission#getName--&quot;&gt;&lt;code&gt;Permission.getName()&lt;/code&gt;&lt;/a&gt; on the resultant MBeanPermission.</source>
          <target state="translated">类名称，成员和对象名称参数定义了形式为&amp;ldquo; &lt;code&gt;className#member[objectName]&lt;/code&gt; &amp;rdquo; 的目标名称，其中每个部分都是可选的。这将是结果MBeanPermission上&lt;a href=&quot;../../java/security/permission#getName--&quot;&gt; &lt;code&gt;Permission.getName()&lt;/code&gt; &lt;/a&gt;的结果。</target>
        </trans-unit>
        <trans-unit id="e7f527e6a2e74f94312874345a4b4bb09466dc5d" translate="yes" xml:space="preserve">
          <source>The class name, member, and object name can be written together as a single string, which is the &lt;em&gt;name&lt;/em&gt; of this permission. The name of the permission is the string returned by &lt;a href=&quot;../../java/security/permission#getName--&quot;&gt;&lt;code&gt;getName()&lt;/code&gt;&lt;/a&gt;. The format of the string is:</source>
          <target state="translated">可以将类名，成员和对象名一起写为单个字符串，这是此权限的&lt;em&gt;名称&lt;/em&gt;。权限的名称是&lt;a href=&quot;../../java/security/permission#getName--&quot;&gt; &lt;code&gt;getName()&lt;/code&gt; &lt;/a&gt;返回的字符串。字符串的格式为：</target>
        </trans-unit>
        <trans-unit id="24463e4dd2161bdd8170d4d26693be82652a2840" translate="yes" xml:space="preserve">
          <source>The class names of the exceptions that can be thrown when invoking a constructor or operation, or getting an attribute. The meaning of this field is defined by this specification but the field is not set or used by the JMX API itself. Exceptions thrown when setting an attribute are specified by the field &lt;a href=&quot;#setExceptions&quot;&gt;&lt;code&gt;setExceptions&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">调用构造函数或操作或获取属性时可能引发的异常的类名。该字段的含义由本规范定义，但JMX API本身未设置或使用该字段。设置属性时引发的异常由&lt;a href=&quot;#setExceptions&quot;&gt; &lt;code&gt;setExceptions&lt;/code&gt; &lt;/a&gt;字段指定。</target>
        </trans-unit>
        <trans-unit id="4f558354362711f7f870366ca77457f25ec982e1" translate="yes" xml:space="preserve">
          <source>The class names of the exceptions that can be thrown when setting an attribute. The meaning of this field is defined by this specification but the field is not set or used by the JMX API itself. Exceptions thrown when getting an attribute are specified by the field &lt;a href=&quot;#exceptions&quot;&gt;&lt;code&gt;exceptions&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">设置属性时可以引发的异常的类名。该字段的含义由本规范定义，但JMX API本身未设置或使用该字段。获取属性时引发的异常由字段&lt;a href=&quot;#exceptions&quot;&gt; &lt;code&gt;exceptions&lt;/code&gt; &lt;/a&gt;指定。</target>
        </trans-unit>
        <trans-unit id="67a17c362d3e1b1c120d30ec1c8988dcf8590e9f" translate="yes" xml:space="preserve">
          <source>The class of the implementation of this Standard MBean (or MXBean).</source>
          <target state="translated">该标准MBean(或MXBean)的实现类。</target>
        </trans-unit>
        <trans-unit id="aafaead25ed357736f7fa6d9e43fd8e44d23e040" translate="yes" xml:space="preserve">
          <source>The class of the mismatched argument</source>
          <target state="translated">错位论点的类别</target>
        </trans-unit>
        <trans-unit id="9f9c1e95a29aed3cd3487891bc5c2b07f99d1d46" translate="yes" xml:space="preserve">
          <source>The class or interface name</source>
          <target state="translated">类或接口名称</target>
        </trans-unit>
        <trans-unit id="0429235745a3b457b0c546403aed40bddedcce9d" translate="yes" xml:space="preserve">
          <source>The class-only format &lt;code&gt;List&lt;/code&gt; containing &lt;code&gt;&quot;java.class&quot;&lt;/code&gt;. This &lt;code&gt;List&lt;/code&gt; is &lt;a href=&quot;collections#unmodifiableList-java.util.List-&quot;&gt;unmodifiable&lt;/a&gt;.</source>
          <target state="translated">包含 &lt;code&gt;&quot;java.class&quot;&lt;/code&gt; 的纯类格式 &lt;code&gt;List&lt;/code&gt; 。这个 &lt;code&gt;List&lt;/code&gt; 是&lt;a href=&quot;collections#unmodifiableList-java.util.List-&quot;&gt;不可修改的&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="951f885ca705190ee66dda1a5c90080539c69c07" translate="yes" xml:space="preserve">
          <source>The classes &lt;a href=&quot;localdate&quot;&gt;&lt;code&gt;LocalDate&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;localtime&quot;&gt;&lt;code&gt;LocalTime&lt;/code&gt;&lt;/a&gt; implement &lt;code&gt;TemporalAdjuster&lt;/code&gt;, thus this method can be used to change the date, time or offset:</source>
          <target state="translated">&lt;a href=&quot;localdate&quot;&gt; &lt;code&gt;LocalDate&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;localtime&quot;&gt; &lt;code&gt;LocalTime&lt;/code&gt; &lt;/a&gt;类实现 &lt;code&gt;TemporalAdjuster&lt;/code&gt; ，因此可以使用此方法更改日期，时间或偏移量：</target>
        </trans-unit>
        <trans-unit id="91f35168bb8ac0d14680d3e7a283896058efa32f" translate="yes" xml:space="preserve">
          <source>The classes &lt;a href=&quot;localdate&quot;&gt;&lt;code&gt;LocalDate&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;localtime&quot;&gt;&lt;code&gt;LocalTime&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;zoneoffset&quot;&gt;&lt;code&gt;ZoneOffset&lt;/code&gt;&lt;/a&gt; implement &lt;code&gt;TemporalAdjuster&lt;/code&gt;, thus this method can be used to change the date, time or offset:</source>
          <target state="translated">类&lt;a href=&quot;localdate&quot;&gt; &lt;code&gt;LocalDate&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;localtime&quot;&gt; &lt;code&gt;LocalTime&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;zoneoffset&quot;&gt; &lt;code&gt;ZoneOffset&lt;/code&gt; &lt;/a&gt;实施 &lt;code&gt;TemporalAdjuster&lt;/code&gt; ，从而可以用这种方法来改变日期，时间或偏移：</target>
        </trans-unit>
        <trans-unit id="667e2b33474bdab83bd95b94b5fc3ee8acc932ff" translate="yes" xml:space="preserve">
          <source>The classes &lt;a href=&quot;localtime&quot;&gt;&lt;code&gt;LocalTime&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;zoneoffset&quot;&gt;&lt;code&gt;ZoneOffset&lt;/code&gt;&lt;/a&gt; implement &lt;code&gt;TemporalAdjuster&lt;/code&gt;, thus this method can be used to change the time or offset:</source>
          <target state="translated">的类&lt;a href=&quot;localtime&quot;&gt; &lt;code&gt;LocalTime&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;zoneoffset&quot;&gt; &lt;code&gt;ZoneOffset&lt;/code&gt; &lt;/a&gt;实施 &lt;code&gt;TemporalAdjuster&lt;/code&gt; ，因此可用于这种方法来改变时间或偏移：</target>
        </trans-unit>
        <trans-unit id="80a1b2807e3c199a522ca9fc26f06689a6f68c38" translate="yes" xml:space="preserve">
          <source>The classes and interfaces in this package have been superseded by classes in the java.security package.</source>
          <target state="translated">这个包中的类和接口已经被java.security包中的类所取代。</target>
        </trans-unit>
        <trans-unit id="ed5a6af1e3f7c3411e84709c3cbf34764ac2efbf" translate="yes" xml:space="preserve">
          <source>The classes and interfaces in this package have been superseded by classes in the java.security package. See that package and, for example, java.security.Permission for details.</source>
          <target state="translated">这个包中的类和接口已经被java.security包中的类所取代。详情请参见该包和java.security.Permission。</target>
        </trans-unit>
        <trans-unit id="8cc8dc37d5486db6b4ddadb26ec74de8ff37fc86" translate="yes" xml:space="preserve">
          <source>The classes defined here represent the principle date-time concepts, including instants, durations, dates, times, time-zones and periods. They are based on the ISO calendar system, which is the</source>
          <target state="translated">这里定义的类代表了主要的日期-时间概念,包括瞬间、持续时间、日期、时间、时区和周期。它们以ISO日历系统为基础,该日历系统是ISO日历系统的一部分。</target>
        </trans-unit>
        <trans-unit id="f1ddc966da7eb209890b6b98e471fd102a3dbfd7" translate="yes" xml:space="preserve">
          <source>The classes that are loaded are by default granted permission only to access the URLs specified when the URLClassLoader was created.</source>
          <target state="translated">默认情况下,被加载的类只被授予访问URLClassLoader创建时指定的URL的权限。</target>
        </trans-unit>
        <trans-unit id="a4f20c0c81d3fcf5f113e63defaf1a7e721b263f" translate="yes" xml:space="preserve">
          <source>The classification function maps elements to some key type &lt;code&gt;K&lt;/code&gt;. The collector produces a &lt;code&gt;ConcurrentMap&amp;lt;K, List&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; whose keys are the values resulting from applying the classification function to the input elements, and whose corresponding values are &lt;code&gt;List&lt;/code&gt;s containing the input elements which map to the associated key under the classification function.</source>
          <target state="translated">分类函数映射元素的一些关键类型 &lt;code&gt;K&lt;/code&gt; 。收集器生成一个 &lt;code&gt;ConcurrentMap&amp;lt;K, List&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 其键是将分类函数应用于输入元素后得到的值，并且其对应值是 &lt;code&gt;List&lt;/code&gt; ,其中 s包含映射到分类函数下关联键的输入元素。 。</target>
        </trans-unit>
        <trans-unit id="f7b6ff72cdcfcbf34cc479a3dd8ccba88f465aff" translate="yes" xml:space="preserve">
          <source>The classification function maps elements to some key type &lt;code&gt;K&lt;/code&gt;. The collector produces a &lt;code&gt;Map&amp;lt;K, List&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; whose keys are the values resulting from applying the classification function to the input elements, and whose corresponding values are &lt;code&gt;List&lt;/code&gt;s containing the input elements which map to the associated key under the classification function.</source>
          <target state="translated">分类函数映射元素的一些关键类型 &lt;code&gt;K&lt;/code&gt; 。收集器生成 &lt;code&gt;Map&amp;lt;K, List&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 其键是将分类函数应用于输入元素后得到的值，其对应值是 &lt;code&gt;List&lt;/code&gt; ,其中 s包含映射到分类函数下关联键的输入元素。</target>
        </trans-unit>
        <trans-unit id="8dcf0f47762fae0e87c464f9581d648ea3ae1c54" translate="yes" xml:space="preserve">
          <source>The classification function maps elements to some key type &lt;code&gt;K&lt;/code&gt;. The downstream collector operates on elements of type &lt;code&gt;T&lt;/code&gt; and produces a result of type &lt;code&gt;D&lt;/code&gt;. The resulting collector produces a &lt;code&gt;Map&amp;lt;K, D&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">分类函数映射元素的一些关键类型 &lt;code&gt;K&lt;/code&gt; 。下游收集器对 &lt;code&gt;T&lt;/code&gt; 类型的元素进行操作，并产生 &lt;code&gt;D&lt;/code&gt; 类型的结果。所得的收集器产生 &lt;code&gt;Map&amp;lt;K, D&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d66802f538547bc49310f369abc46f7fe953b16a" translate="yes" xml:space="preserve">
          <source>The client can always specify any &lt;a href=&quot;jobpriority&quot;&gt;&lt;code&gt;JobPriority&lt;/code&gt;&lt;/a&gt; value from 1 to 100 for a job. However, the Print Service instance may support fewer than 100 different job priority levels. If this is the case, the Print Service instance automatically maps the client-specified job priority value to one of the supported job priority levels, dividing the 100 job priority values equally among the available job priority levels.</source>
          <target state="translated">客户端始终可以为作业指定1到100之间的任何&lt;a href=&quot;jobpriority&quot;&gt; &lt;code&gt;JobPriority&lt;/code&gt; &lt;/a&gt;值。但是，打印服务实例可能支持少于100个不同的作业优先级。在这种情况下，打印服务实例会自动将客户端指定的作业优先级值映射到支持的作业优先级级别之一，将100个作业优先级值平均分配到可用的作业优先级级别中。</target>
        </trans-unit>
        <trans-unit id="f54e74b6cf6d674d95124793f818122cb381114e" translate="yes" xml:space="preserve">
          <source>The client can always specify any job priority value from 1 to 100 for a job. However, a Print Service instance may support fewer than 100 different job priority levels. If this is the case, the Print Service instance automatically maps the client-specified job priority value to one of the supported job priority levels, dividing the 100 job priority values equally among the available job priority levels.</source>
          <target state="translated">客户端始终可以为一项作业指定从1到100的任何作业优先级值。但是,打印服务实例可能支持少于100个不同的作业优先级。在这种情况下,打印服务实例会自动将客户端指定的作业优先级值映射到支持的作业优先级之一,将100个作业优先级值平均分配给可用的作业优先级。</target>
        </trans-unit>
        <trans-unit id="e36327ca2d0b7f027e93c0c6830f31c98a8858f0" translate="yes" xml:space="preserve">
          <source>The client code shown here is slightly more complicated for the MXBean client. But, if the client does in fact know the model, here the interface &lt;code&gt;MemoryPoolMXBean&lt;/code&gt; and the class &lt;code&gt;MemoryUsage&lt;/code&gt;, then it can construct a &lt;em&gt;proxy&lt;/em&gt;. This is the recommended way to interact with managed objects when you know the model beforehand, regardless of whether you are using Standard MBeans or MXBeans:</source>
          <target state="translated">对于MXBean客户端，此处显示的客户端代码稍微复杂一些。但是，如果客户端实际上确实知道模型，这里是接口 &lt;code&gt;MemoryPoolMXBean&lt;/code&gt; 和类 &lt;code&gt;MemoryUsage&lt;/code&gt; ，则它可以构造一个&lt;em&gt;proxy&lt;/em&gt;。无论您使用的是标准MBean还是MXBean，无论何时使用模型，这都是建议的与托管对象进行交互的方式：</target>
        </trans-unit>
        <trans-unit id="c82a5d98728343602350f3acf815500ea1c5ee2c" translate="yes" xml:space="preserve">
          <source>The client end of a JMX API connector.</source>
          <target state="translated">JMX API连接器的客户端。</target>
        </trans-unit>
        <trans-unit id="b4488646dd7bc568328ca00d7c96cdc5b511b54e" translate="yes" xml:space="preserve">
          <source>The client end of a JMX API connector. An object of this type can be used to establish a connection to a connector server.</source>
          <target state="translated">JMX API连接器的客户端。此类型的对象可用于建立与连接器服务器的连接。</target>
        </trans-unit>
        <trans-unit id="f6d8cb5abcc9dba2b35caaa1100aa8007bd4f05d" translate="yes" xml:space="preserve">
          <source>The client must itself perform all plain text print data formatting not addressed by the above requirements.</source>
          <target state="translated">客户端必须自行执行上述要求未涉及的所有纯文本打印数据格式化。</target>
        </trans-unit>
        <trans-unit id="61622044c23d1dc5bf6a5c87f1e0670101adac2f" translate="yes" xml:space="preserve">
          <source>The clock implementation provided here is based on &lt;a href=&quot;../lang/system#currentTimeMillis--&quot;&gt;&lt;code&gt;System.currentTimeMillis()&lt;/code&gt;&lt;/a&gt;. That method provides little to no guarantee about the accuracy of the clock. Applications requiring a more accurate clock must implement this abstract class themselves using a different external clock, such as an NTP server.</source>
          <target state="translated">此处提供的时钟实现基于&lt;a href=&quot;../lang/system#currentTimeMillis--&quot;&gt; &lt;code&gt;System.currentTimeMillis()&lt;/code&gt; &lt;/a&gt;。该方法几乎不能保证时钟的准确性。需要更精确时钟的应用程序必须使用其他外部时钟（例如NTP服务器）自己实现此抽象类。</target>
        </trans-unit>
        <trans-unit id="25e6815aa00a334e2bd9ee8bdf69f008eb1d1606" translate="yes" xml:space="preserve">
          <source>The clock sequence of this &lt;code&gt;UUID&lt;/code&gt;</source>
          <target state="translated">此 &lt;code&gt;UUID&lt;/code&gt; 的时钟序列</target>
        </trans-unit>
        <trans-unit id="4927698d61ddc5d19e93d88deb9e42d15dbacd87" translate="yes" xml:space="preserve">
          <source>The clock sequence value associated with this UUID.</source>
          <target state="translated">与此UUID相关联的时钟序列值。</target>
        </trans-unit>
        <trans-unit id="5d1b1f6ea1a364b40310f013d2e4ede7c72b865f" translate="yes" xml:space="preserve">
          <source>The clock-hour-of-am-pm.</source>
          <target state="translated">凌晨时分的时钟。</target>
        </trans-unit>
        <trans-unit id="d9d6945b9a1ccb1b98abde4cb5b49e528dae6fda" translate="yes" xml:space="preserve">
          <source>The clock-hour-of-day.</source>
          <target state="translated">一天中的时钟时间。</target>
        </trans-unit>
        <trans-unit id="67da0df2a20add6c7e78cab2dd3884834bc5386c" translate="yes" xml:space="preserve">
          <source>The close method will perform a &lt;code&gt;flush&lt;/code&gt; and then close the &lt;code&gt;Handler&lt;/code&gt;. After close has been called this &lt;code&gt;Handler&lt;/code&gt; should no longer be used. Method calls may either be silently ignored or may throw runtime exceptions.</source>
          <target state="translated">close方法将执行 &lt;code&gt;flush&lt;/code&gt; ，然后关闭 &lt;code&gt;Handler&lt;/code&gt; 。在调用close之后，不应再使用此 &lt;code&gt;Handler&lt;/code&gt; 。方法调用可能会被静默忽略，或者会抛出运行时异常。</target>
        </trans-unit>
        <trans-unit id="b1433e4121635551dd14010c6b704bba7b5e5e75" translate="yes" xml:space="preserve">
          <source>The code base URL.</source>
          <target state="translated">代码库URL。</target>
        </trans-unit>
        <trans-unit id="56ce6ef2114da8b3480773fc41a5bba91e0be358" translate="yes" xml:space="preserve">
          <source>The code fragment should be context free and must be a legal Java expression as specified by the JLS.</source>
          <target state="translated">代码片段应该是无上下文的,并且必须是JLS指定的合法Java表达式。</target>
        </trans-unit>
        <trans-unit id="7551fda94d924a51c214eacfb5d20ee1569ef738" translate="yes" xml:space="preserve">
          <source>The code sample in &lt;a href=&quot;pagedresultscontrol&quot;&gt;&lt;code&gt;PagedResultsControl&lt;/code&gt;&lt;/a&gt; shows how this class may be used.</source>
          <target state="translated">&lt;a href=&quot;pagedresultscontrol&quot;&gt; &lt;code&gt;PagedResultsControl&lt;/code&gt; &lt;/a&gt;中的代码示例显示了如何使用此类。</target>
        </trans-unit>
        <trans-unit id="2d9000efa3a911a92cbde4578c40faa3825deb27" translate="yes" xml:space="preserve">
          <source>The code sample in &lt;a href=&quot;sortcontrol&quot;&gt;&lt;code&gt;SortControl&lt;/code&gt;&lt;/a&gt; shows how this class may be used.</source>
          <target state="translated">&lt;a href=&quot;sortcontrol&quot;&gt; &lt;code&gt;SortControl&lt;/code&gt; &lt;/a&gt;中的代码示例显示了如何使用此类。</target>
        </trans-unit>
        <trans-unit id="30d83691e8c4e45b8fe52bdd6fd725a184c8ca07" translate="yes" xml:space="preserve">
          <source>The collation table is composed of a list of collation rules, where each rule is of one of three forms:</source>
          <target state="translated">整理表是由一个整理规则的列表组成,其中每个规则有三种形式之一。</target>
        </trans-unit>
        <trans-unit id="7c1827d597c9c77ae6e1e11339356cf0f6e7e02e" translate="yes" xml:space="preserve">
          <source>The collection is backed by the map, so changes to the map are reflected in the collection, and vice-versa. If the map is modified while an iteration over the collection is in progress (except through the iterator's own &lt;code&gt;remove&lt;/code&gt; operation), the results of the iteration are undefined. The collection supports element removal, which removes the corresponding mapping from the map, via the &lt;code&gt;Iterator.remove&lt;/code&gt;, &lt;code&gt;Collection.remove&lt;/code&gt;, &lt;code&gt;removeAll&lt;/code&gt;, &lt;code&gt;retainAll&lt;/code&gt; and &lt;code&gt;clear&lt;/code&gt; operations. It does not support the &lt;code&gt;add&lt;/code&gt; or &lt;code&gt;addAll&lt;/code&gt; operations.</source>
          <target state="translated">集合由地图支持，因此对地图的更改会反映在集合中，反之亦然。如果在对集合进行迭代时修改了映射（通过迭代器自己的 &lt;code&gt;remove&lt;/code&gt; 操作除外），则迭代的结果是不确定的。集合支持元素删除，该元素通过 &lt;code&gt;Iterator.remove&lt;/code&gt; ， &lt;code&gt;Collection.remove&lt;/code&gt; ， &lt;code&gt;removeAll&lt;/code&gt; ， &lt;code&gt;retainAll&lt;/code&gt; 和 &lt;code&gt;clear&lt;/code&gt; 操作从映射中删除相应的映射。它不支持 &lt;code&gt;add&lt;/code&gt; 或 &lt;code&gt;addAll&lt;/code&gt; 操作。</target>
        </trans-unit>
        <trans-unit id="08a9f493e12bc421d71667070210c7e0b80be588" translate="yes" xml:space="preserve">
          <source>The collection is backed by the map, so changes to the map are reflected in the collection, and vice-versa. The collection supports element removal, which removes the corresponding mapping from the map, via the &lt;code&gt;Iterator.remove&lt;/code&gt;, &lt;code&gt;Collection.remove&lt;/code&gt;, &lt;code&gt;removeAll&lt;/code&gt;, &lt;code&gt;retainAll&lt;/code&gt; and &lt;code&gt;clear&lt;/code&gt; operations. It does not support the &lt;code&gt;add&lt;/code&gt; or &lt;code&gt;addAll&lt;/code&gt; operations.</source>
          <target state="translated">集合由地图支持，因此对地图的更改会反映在集合中，反之亦然。集合支持元素删除，该元素通过 &lt;code&gt;Iterator.remove&lt;/code&gt; ， &lt;code&gt;Collection.remove&lt;/code&gt; ， &lt;code&gt;removeAll&lt;/code&gt; ， &lt;code&gt;retainAll&lt;/code&gt; 和 &lt;code&gt;clear&lt;/code&gt; 操作从映射中删除相应的映射。它不支持 &lt;code&gt;add&lt;/code&gt; 或 &lt;code&gt;addAll&lt;/code&gt; 操作。</target>
        </trans-unit>
        <trans-unit id="0ae6cac46e4d7c9b4fdc7934d10d1e2d1a73c597" translate="yes" xml:space="preserve">
          <source>The collection is created the first time this method is called, and returned in response to all subsequent calls. No synchronization is performed, so there is a slight chance that multiple calls to this method will not all return the same collection.</source>
          <target state="translated">该集合在第一次调用该方法时创建,并在所有后续调用时返回。没有进行同步,所以对该方法的多次调用有可能不会返回相同的集合。</target>
        </trans-unit>
        <trans-unit id="8bf124bacc13ad53500c93100391bd683fd0dda8" translate="yes" xml:space="preserve">
          <source>The collection usage threshold crossing checking is enabled in this memory pool if the threshold is set to a positive value. The collection usage threshold crossing checking is disabled if it is set to zero.</source>
          <target state="translated">如果阈值设置为正值,则在该内存池中启用收集使用阈值越界检查。如果阈值设置为零,则禁用收集使用量阈值越界检查。</target>
        </trans-unit>
        <trans-unit id="9156660a2ac7aa98ef313cabffe7060e8aa35409" translate="yes" xml:space="preserve">
          <source>The collection usage threshold is designed for monitoring the memory usage after the Java virtual machine has expended effort in reclaiming memory space. The collection usage could also be monitored by the polling and threshold notification mechanism described above for the &lt;a href=&quot;#UsageThreshold&quot;&gt;usage threshold&lt;/a&gt; in a similar fashion.</source>
          <target state="translated">收集使用量阈值旨在在Java虚拟机花费大量精力回收内存空间之后监视内存使用量。收集使用情况也可以通过上述轮询和阈值通知机制以类似的方式针对&lt;a href=&quot;#UsageThreshold&quot;&gt;使用情况阈值&lt;/a&gt;进行监视。</target>
        </trans-unit>
        <trans-unit id="0e2883e94761fa22e846a8f32267f5142a06c8d2" translate="yes" xml:space="preserve">
          <source>The collection's iterator returns the values in ascending order of the corresponding keys. The collection's spliterator is &lt;em&gt;&lt;a href=&quot;spliterator#binding&quot;&gt;late-binding&lt;/a&gt;&lt;/em&gt;, &lt;em&gt;fail-fast&lt;/em&gt;, and additionally reports &lt;a href=&quot;spliterator#ORDERED&quot;&gt;&lt;code&gt;Spliterator.ORDERED&lt;/code&gt;&lt;/a&gt; with an encounter order that is ascending order of the corresponding keys.</source>
          <target state="translated">集合的迭代器按相应键的升序返回值。集合的拆分器为&lt;em&gt;&lt;a href=&quot;spliterator#binding&quot;&gt;late-binding&lt;/a&gt;&lt;/em&gt;，&lt;em&gt;fail-fast&lt;/em&gt;，并另外报告&lt;a href=&quot;spliterator#ORDERED&quot;&gt; &lt;code&gt;Spliterator.ORDERED&lt;/code&gt; &lt;/a&gt;，其遇到顺序为相应键的升序。</target>
        </trans-unit>
        <trans-unit id="ea1bd030966840638731efedafac9a0ec7782728" translate="yes" xml:space="preserve">
          <source>The collection's iterator returns the values in ascending order of the corresponding keys. The collections's spliterator additionally reports &lt;a href=&quot;../spliterator#CONCURRENT&quot;&gt;&lt;code&gt;Spliterator.CONCURRENT&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../spliterator#NONNULL&quot;&gt;&lt;code&gt;Spliterator.NONNULL&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../spliterator#ORDERED&quot;&gt;&lt;code&gt;Spliterator.ORDERED&lt;/code&gt;&lt;/a&gt;, with an encounter order that is ascending order of the corresponding keys.</source>
          <target state="translated">集合的迭代器按相应键的升序返回值。集合的拆分器还会另外报告&lt;a href=&quot;../spliterator#CONCURRENT&quot;&gt; &lt;code&gt;Spliterator.CONCURRENT&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../spliterator#NONNULL&quot;&gt; &lt;code&gt;Spliterator.NONNULL&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../spliterator#ORDERED&quot;&gt; &lt;code&gt;Spliterator.ORDERED&lt;/code&gt; &lt;/a&gt;，其遇到顺序是相应键的升序。</target>
        </trans-unit>
        <trans-unit id="e274436db22ea8e689c8f92c1a625157a2ad4161" translate="yes" xml:space="preserve">
          <source>The collector has the &lt;a href=&quot;collector.characteristics#CONCURRENT&quot;&gt;&lt;code&gt;Collector.Characteristics.CONCURRENT&lt;/code&gt;&lt;/a&gt; characteristic, and;</source>
          <target state="translated">收集器具有&lt;a href=&quot;collector.characteristics#CONCURRENT&quot;&gt; &lt;code&gt;Collector.Characteristics.CONCURRENT&lt;/code&gt; &lt;/a&gt;特性，并且；</target>
        </trans-unit>
        <trans-unit id="91ec48482e2398b213123b4670de324887cddaf6" translate="yes" xml:space="preserve">
          <source>The colon character &lt;code&gt;':'&lt;/code&gt; (&lt;code&gt;'\u003a'&lt;/code&gt;, &lt;small&gt;COLON&lt;/small&gt;), and</source>
          <target state="translated">冒号 &lt;code&gt;':'&lt;/code&gt; （ &lt;code&gt;'\u003a'&lt;/code&gt; ，&lt;small&gt;COLON&lt;/small&gt;）和</target>
        </trans-unit>
        <trans-unit id="9fd1379c9afe56acbb2fb69be0fad0a683d98a4f" translate="yes" xml:space="preserve">
          <source>The colon separator need not be present if the request headers list is empty. No white-space is permitted in the actions string. The action strings supplied to the URLPermission constructors are case-insensitive and are normalized by converting method names to upper-case and header names to the form defines in RFC2616 (lower case with initial letter of each word capitalized). Either list can contain a wild-card '*' character which signifies all request methods or headers respectively.</source>
          <target state="translated">如果请求头列表为空,则不需要使用冒号分隔符。actions字符串中不允许有空格。提供给URLPermission构造函数的动作字符串不区分大小写,并通过将方法名转换为大写,将头名转换为RFC2616中定义的形式(小写,每个单词的首字母大写)进行规范化。任何一个列表都可以包含一个通配符'*',分别表示所有请求方法或头。</target>
        </trans-unit>
        <trans-unit id="2e641ea6fe64f0b8a19aa6317da464694488bcba" translate="yes" xml:space="preserve">
          <source>The column number. Returns -1 if a column number is unavailable.</source>
          <target state="translated">列号。如果列号不可用,返回-1。</target>
        </trans-unit>
        <trans-unit id="f59b440a5dce5861e4bd83979917698dd94ef608" translate="yes" xml:space="preserve">
          <source>The combination day-of-week and day-of-month (&quot;Friday the 13th&quot;) should not implement this interface. It does not represent a contiguous set of fields, as days to weeks overlaps days to months.</source>
          <target state="translated">周日和月日的组合(&quot;13号星期五&quot;)不应该实现这个接口。它并不代表一组连续的字段,因为从日到周的字段与从日到月的字段是重叠的。</target>
        </trans-unit>
        <trans-unit id="9a95804740becaea21fb0fb96083c1c9566eaf00" translate="yes" xml:space="preserve">
          <source>The combination of the 'before' date-time and offset represents the same instant as the 'after' date-time and offset.</source>
          <target state="translated">之前 &quot;的日期时间和偏移量的组合与 &quot;之后 &quot;的日期时间和偏移量的组合代表同一时刻。</target>
        </trans-unit>
        <trans-unit id="eeb7f12dcdc1b38ae56fe22eab8edc4e52262d56" translate="yes" xml:space="preserve">
          <source>The combine method takes two arguments. The first argument represents an array of ProtectionDomains from the current execution Thread, since the most recent call to &lt;code&gt;AccessController.doPrivileged&lt;/code&gt;. If no call to doPrivileged was made, then the first argument will contain all the ProtectionDomains from the current execution Thread. The second argument represents an array of inherited ProtectionDomains, which may be &lt;code&gt;null&lt;/code&gt;. ProtectionDomains may be inherited from a parent Thread, or from a privileged context. If no call to doPrivileged was made, then the second argument will contain the ProtectionDomains inherited from the parent Thread. If one or more calls to doPrivileged were made, and the most recent call was to doPrivileged(action, context), then the second argument will contain the ProtectionDomains from the privileged context. If the most recent call was to doPrivileged(action), then there is no privileged context, and the second argument will be &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">Combine方法有两个参数。自从最近一次 &lt;code&gt;AccessController.doPrivileged&lt;/code&gt; 以来，第一个参数表示当前执行线程中的ProtectionDomains数组。如果未调用doPrivileged，则第一个参数将包含当前执行线程中的所有ProtectionDomain。第二个参数表示继承的ProtectionDomains的数组，可以为 &lt;code&gt;null&lt;/code&gt; 。ProtectionDomain可以从父线程或特权上下文继承。如果未调用doPrivileged，则第二个参数将包含从父线程继承的ProtectionDomains。如果对doPrivileged进行了一个或多个调用，而最近一次对doPrivileged（action，context）进行了调用，则第二个参数将包含来自特权上下文的ProtectionDomain。如果最近的调用是对doPrivileged（action）的调用，则没有特权上下文，第二个参数将为 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7a16f5e65d2f83a96835a56079d0447983bf6e15" translate="yes" xml:space="preserve">
          <source>The comment element is a place holder for any comments that the code generator may want to include in the generated code.</source>
          <target state="translated">注释元素是代码生成器可能想要在生成的代码中包含的任何注释的位置。</target>
        </trans-unit>
        <trans-unit id="7cc3e34fc55f9b2b57ce4d53e61e6d6e9418fed9" translate="yes" xml:space="preserve">
          <source>The common definition of a week that starts on Sunday and the first week has a minimum of 1 day.</source>
          <target state="translated">常见的定义是,一周从周日开始,第一周至少有1天。</target>
        </trans-unit>
        <trans-unit id="54934fd2df13abeb43116e909517bf162f57134b" translate="yes" xml:space="preserve">
          <source>The common interface extended by all annotation types.</source>
          <target state="translated">由所有注解类型扩展的通用接口。</target>
        </trans-unit>
        <trans-unit id="1314aec14eff7f99258639556043ab2235382bb2" translate="yes" xml:space="preserve">
          <source>The common interface extended by all annotation types. Note that an interface that manually extends this one does</source>
          <target state="translated">所有注解类型扩展的通用接口。需要注意的是,手动扩展这个接口的接口并不会</target>
        </trans-unit>
        <trans-unit id="be8eec3709c1b7ba220252bd3ee06454fbc63cce" translate="yes" xml:space="preserve">
          <source>The common pool is by default constructed with default parameters, but these may be controlled by setting three &lt;a href=&quot;../../lang/system#getProperty-java.lang.String-&quot;&gt;system properties&lt;/a&gt;:</source>
          <target state="translated">默认情况下，公共池是使用默认参数构造的，但是可以通过设置以下三个&lt;a href=&quot;../../lang/system#getProperty-java.lang.String-&quot;&gt;系统属性&lt;/a&gt;来控制这些参数：</target>
        </trans-unit>
        <trans-unit id="40472696caa6671c3ae2d8a764be134346c666a2" translate="yes" xml:space="preserve">
          <source>The comparison is &quot;consistent with equals&quot;, as defined by &lt;a href=&quot;../lang/comparable&quot;&gt;&lt;code&gt;Comparable&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">根据&lt;a href=&quot;../lang/comparable&quot;&gt; &lt;code&gt;Comparable&lt;/code&gt; 的&lt;/a&gt;定义，比较是&amp;ldquo;等于等于&amp;rdquo; 。</target>
        </trans-unit>
        <trans-unit id="7544553cbef2741d51df7e2448ec9b3d30bfc038" translate="yes" xml:space="preserve">
          <source>The comparison is based first on the UTC equivalent instant, then on the local time. It is &quot;consistent with equals&quot;, as defined by &lt;a href=&quot;../lang/comparable&quot;&gt;&lt;code&gt;Comparable&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">比较首先基于UTC等效时间，然后基于本地时间。如&lt;a href=&quot;../lang/comparable&quot;&gt; &lt;code&gt;Comparable&lt;/code&gt; &lt;/a&gt;所定义，它是&amp;ldquo;等于等于&amp;rdquo; 。</target>
        </trans-unit>
        <trans-unit id="a9f1c042dcb61fa1cd287abce64f4635e9b92eae" translate="yes" xml:space="preserve">
          <source>The comparison is based first on the instant, then on the local date-time, then on the zone ID, then on the chronology. It is &quot;consistent with equals&quot;, as defined by &lt;a href=&quot;../../lang/comparable&quot;&gt;&lt;code&gt;Comparable&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">比较首先基于即时信息，然后基于本地日期时间，然后基于区域ID，再基于时间顺序。如&lt;a href=&quot;../../lang/comparable&quot;&gt; &lt;code&gt;Comparable&lt;/code&gt; &lt;/a&gt;所定义，它是&amp;ldquo;等于等于&amp;rdquo; 。</target>
        </trans-unit>
        <trans-unit id="ec2151de3ebbbe7f15e922252583edd296181fa3" translate="yes" xml:space="preserve">
          <source>The comparison is based first on the underlying time-line date, then on the chronology. It is &quot;consistent with equals&quot;, as defined by &lt;a href=&quot;../../lang/comparable&quot;&gt;&lt;code&gt;Comparable&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">比较首先基于基础时间轴日期，然后基于时间顺序。如&lt;a href=&quot;../../lang/comparable&quot;&gt; &lt;code&gt;Comparable&lt;/code&gt; &lt;/a&gt;所定义，它是&amp;ldquo;等于等于&amp;rdquo; 。</target>
        </trans-unit>
        <trans-unit id="85c7e6fc1e00fe1d64177c565a13d627754ef76f" translate="yes" xml:space="preserve">
          <source>The comparison is based first on the underlying time-line date-time, then on the chronology. It is &quot;consistent with equals&quot;, as defined by &lt;a href=&quot;../../lang/comparable&quot;&gt;&lt;code&gt;Comparable&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">比较首先基于基础的时间轴日期时间，然后基于时间顺序。如&lt;a href=&quot;../../lang/comparable&quot;&gt; &lt;code&gt;Comparable&lt;/code&gt; &lt;/a&gt;所定义，它是&amp;ldquo;等于等于&amp;rdquo; 。</target>
        </trans-unit>
        <trans-unit id="bc9c161855c82e99812fb51724a912bec4af797a" translate="yes" xml:space="preserve">
          <source>The comparison is based first on the value of the year, then on the value of the month. It is &quot;consistent with equals&quot;, as defined by &lt;a href=&quot;../lang/comparable&quot;&gt;&lt;code&gt;Comparable&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">比较首先基于年份的值，然后基于月份的值。如&lt;a href=&quot;../lang/comparable&quot;&gt; &lt;code&gt;Comparable&lt;/code&gt; &lt;/a&gt;所定义，它是&amp;ldquo;等于等于&amp;rdquo; 。</target>
        </trans-unit>
        <trans-unit id="a8022e23d05bb51e89c64c6b0e9af30219a8fdac" translate="yes" xml:space="preserve">
          <source>The comparison is based first on value of the month, then on the value of the day. It is &quot;consistent with equals&quot;, as defined by &lt;a href=&quot;../lang/comparable&quot;&gt;&lt;code&gt;Comparable&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">比较首先基于月份的值，然后基于日期的值。如&lt;a href=&quot;../lang/comparable&quot;&gt; &lt;code&gt;Comparable&lt;/code&gt; &lt;/a&gt;所定义，它是&amp;ldquo;等于等于&amp;rdquo; 。</target>
        </trans-unit>
        <trans-unit id="1235f74256f8786279bbc14ae61bc796d7600d41" translate="yes" xml:space="preserve">
          <source>The comparison is based on the ID.</source>
          <target state="translated">根据ID进行对比。</target>
        </trans-unit>
        <trans-unit id="fc65394da81a692e7946a055c22f7463a6a84557" translate="yes" xml:space="preserve">
          <source>The comparison is based on the amount of the offset in seconds. This is equivalent to a comparison by ID.</source>
          <target state="translated">比较的依据是以秒为单位的偏移量。这相当于按ID进行比较。</target>
        </trans-unit>
        <trans-unit id="b18c89c7d60fa0dae17d459068542c53d7e25964" translate="yes" xml:space="preserve">
          <source>The comparison is based on the entire state of the object.</source>
          <target state="translated">比较是基于对象的整个状态。</target>
        </trans-unit>
        <trans-unit id="5af66c17bf64182c96c3f385062b0126edaa4e54" translate="yes" xml:space="preserve">
          <source>The comparison is based on the entire state of the rules, which is the first day-of-week and minimal days.</source>
          <target state="translated">比较是基于规则的整个状态,也就是每周的第一天和最小的一天。</target>
        </trans-unit>
        <trans-unit id="192da957c0f4b80479e196d424d4d3775beb904f" translate="yes" xml:space="preserve">
          <source>The comparison is based on the four values, minimum, largest minimum, smallest maximum and maximum. Only objects of type &lt;code&gt;ValueRange&lt;/code&gt; are compared, other types return false.</source>
          <target state="translated">比较基于四个值：最小值，最大最小值，最小最大值和最大值。仅比较 &lt;code&gt;ValueRange&lt;/code&gt; 类型的对象，其他类型返回false。</target>
        </trans-unit>
        <trans-unit id="cba93eebbdf4e98ed715ba844e1f105f1a12c788" translate="yes" xml:space="preserve">
          <source>The comparison is based on the instant then on the local date-time. It is &quot;consistent with equals&quot;, as defined by &lt;a href=&quot;../lang/comparable&quot;&gt;&lt;code&gt;Comparable&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">比较是基于瞬间，然后基于本地日期时间。如&lt;a href=&quot;../lang/comparable&quot;&gt; &lt;code&gt;Comparable&lt;/code&gt; &lt;/a&gt;所定义，它是&amp;ldquo;等于等于&amp;rdquo; 。</target>
        </trans-unit>
        <trans-unit id="737cc9ee0e95935301bdbf824b243f30aec93c53" translate="yes" xml:space="preserve">
          <source>The comparison is based on the local date-time and the offset. To compare for the same instant on the time-line, use &lt;a href=&quot;offsetdatetime#isEqual-java.time.OffsetDateTime-&quot;&gt;&lt;code&gt;isEqual(java.time.OffsetDateTime)&lt;/code&gt;&lt;/a&gt;. Only objects of type &lt;code&gt;OffsetDateTime&lt;/code&gt; are compared, other types return false.</source>
          <target state="translated">比较是基于本地日期时间和偏移量。要在时间线上比较同一时刻，请使用&lt;a href=&quot;offsetdatetime#isEqual-java.time.OffsetDateTime-&quot;&gt; &lt;code&gt;isEqual(java.time.OffsetDateTime)&lt;/code&gt; &lt;/a&gt;。仅比较 &lt;code&gt;OffsetDateTime&lt;/code&gt; 类型的对象，其他类型返回false。</target>
        </trans-unit>
        <trans-unit id="d5a831b02c02275b1518078d06b087841d7f2158" translate="yes" xml:space="preserve">
          <source>The comparison is based on the local-time and the offset. To compare for the same instant on the time-line, use &lt;a href=&quot;offsettime#isEqual-java.time.OffsetTime-&quot;&gt;&lt;code&gt;isEqual(OffsetTime)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">比较是基于本地时间和偏移量。要在时间线上比较同一时刻，请使用&lt;a href=&quot;offsettime#isEqual-java.time.OffsetTime-&quot;&gt; &lt;code&gt;isEqual(OffsetTime)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="82e0667693e86c110e3044cc93f2d394e82a5c9b" translate="yes" xml:space="preserve">
          <source>The comparison is based on the offset date-time and the zone. Only objects of type &lt;code&gt;ZonedDateTime&lt;/code&gt; are compared, other types return false.</source>
          <target state="translated">比较是基于偏移日期时间和区域。仅比较 &lt;code&gt;ZonedDateTime&lt;/code&gt; 类型的对象，其他类型返回false。</target>
        </trans-unit>
        <trans-unit id="33b5a7379f272963b1231d6f7fe31e6ce7f2e169" translate="yes" xml:space="preserve">
          <source>The comparison is based on the offset date-time and the zone. To compare for the same instant on the time-line, use &lt;a href=&quot;chronozoneddatetime#compareTo-java.time.chrono.ChronoZonedDateTime-&quot;&gt;&lt;code&gt;compareTo(java.time.chrono.ChronoZonedDateTime&amp;lt;?&amp;gt;)&lt;/code&gt;&lt;/a&gt;. Only objects of type &lt;code&gt;ChronoZonedDateTime&lt;/code&gt; are compared, other types return false.</source>
          <target state="translated">比较是基于偏移日期时间和区域。要在时间线上比较同一时刻，请使用&lt;a href=&quot;chronozoneddatetime#compareTo-java.time.chrono.ChronoZonedDateTime-&quot;&gt; &lt;code&gt;compareTo(java.time.chrono.ChronoZonedDateTime&amp;lt;?&amp;gt;)&lt;/code&gt; &lt;/a&gt;。仅比较 &lt;code&gt;ChronoZonedDateTime&lt;/code&gt; 类型的对象，其他类型返回false。</target>
        </trans-unit>
        <trans-unit id="89ee64a765fb07b058f4c38bb5d7dd8adeb5ae39" translate="yes" xml:space="preserve">
          <source>The comparison is based on the time-line position of the instants.</source>
          <target state="translated">比较是基于本体的时间线位置。</target>
        </trans-unit>
        <trans-unit id="16b8d94d368fe5302d9f95a3fac584848bf6c823" translate="yes" xml:space="preserve">
          <source>The comparison is based on the time-line position of the instants. It is &quot;consistent with equals&quot;, as defined by &lt;a href=&quot;../lang/comparable&quot;&gt;&lt;code&gt;Comparable&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">比较是基于瞬时的时间线位置。如&lt;a href=&quot;../lang/comparable&quot;&gt; &lt;code&gt;Comparable&lt;/code&gt; &lt;/a&gt;所定义，它是&amp;ldquo;等于等于&amp;rdquo; 。</target>
        </trans-unit>
        <trans-unit id="c62e4664e20e19bb86140431a4348f682732596c" translate="yes" xml:space="preserve">
          <source>The comparison is based on the time-line position of the local times within a day. It is &quot;consistent with equals&quot;, as defined by &lt;a href=&quot;../lang/comparable&quot;&gt;&lt;code&gt;Comparable&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">比较是基于一天中当地时间的时间轴位置。如&lt;a href=&quot;../lang/comparable&quot;&gt; &lt;code&gt;Comparable&lt;/code&gt; &lt;/a&gt;所定义，它是&amp;ldquo;等于等于&amp;rdquo; 。</target>
        </trans-unit>
        <trans-unit id="596c353f32239015bd0dfaedc67872f34772e8a0" translate="yes" xml:space="preserve">
          <source>The comparison is based on the time-line position of the month-day within a year.</source>
          <target state="translated">根据一年内月日的时间线位置进行比较。</target>
        </trans-unit>
        <trans-unit id="4d10c99bef52962cda140baf526e052de919b106" translate="yes" xml:space="preserve">
          <source>The comparison is based on the time-line position of the time within a day.</source>
          <target state="translated">比较的依据是一天之内的时间线位置。</target>
        </trans-unit>
        <trans-unit id="bc4d73aa624f4c73d652784336ae68fda81a83f5" translate="yes" xml:space="preserve">
          <source>The comparison is based on the time-line position of the year-months.</source>
          <target state="translated">根据年月日的时间线位置进行比较。</target>
        </trans-unit>
        <trans-unit id="16bbd8a5d59cacd64bc82e497b6806c5905521a7" translate="yes" xml:space="preserve">
          <source>The comparison is based on the time-line position of the years.</source>
          <target state="translated">比较的依据是各年的时间线位置。</target>
        </trans-unit>
        <trans-unit id="687b4a5a03f3d03cd8074b28705f197dbd61474d" translate="yes" xml:space="preserve">
          <source>The comparison is based on the total length of the durations.</source>
          <target state="translated">比较是以总的持续时间为基础的。</target>
        </trans-unit>
        <trans-unit id="147c6ea90ff33076d2c31d50f28390aa314b97fa" translate="yes" xml:space="preserve">
          <source>The comparison is based on the total length of the durations. It is &quot;consistent with equals&quot;, as defined by &lt;a href=&quot;../lang/comparable&quot;&gt;&lt;code&gt;Comparable&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">比较是基于持续时间的总长度。如&lt;a href=&quot;../lang/comparable&quot;&gt; &lt;code&gt;Comparable&lt;/code&gt; &lt;/a&gt;所定义，它是&amp;ldquo;等于等于&amp;rdquo; 。</target>
        </trans-unit>
        <trans-unit id="dc1a66e5ec71f197e7d88a905f435f0152a887f3" translate="yes" xml:space="preserve">
          <source>The comparison is based on the type &lt;code&gt;Period&lt;/code&gt; and each of the three amounts. To be equal, the years, months and days units must be individually equal. Note that this means that a period of &quot;15 Months&quot; is not equal to a period of &quot;1 Year and 3 Months&quot;.</source>
          <target state="translated">比较基于 &lt;code&gt;Period&lt;/code&gt; 类型和三个金额中的每一个。为了相等，年，月和日的单位必须分别相等。请注意，这意味着&amp;ldquo; 15个月&amp;rdquo;的时间段不等于&amp;ldquo; 1年零3个月&amp;rdquo;的时间段。</target>
        </trans-unit>
        <trans-unit id="463960db060f3465393d7aee55fa6982b411192d" translate="yes" xml:space="preserve">
          <source>The comparison is based on the value of the year. It is &quot;consistent with equals&quot;, as defined by &lt;a href=&quot;../lang/comparable&quot;&gt;&lt;code&gt;Comparable&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">比较是基于年份的值。如&lt;a href=&quot;../lang/comparable&quot;&gt; &lt;code&gt;Comparable&lt;/code&gt; &lt;/a&gt;所定义，它是&amp;ldquo;等于等于&amp;rdquo; 。</target>
        </trans-unit>
        <trans-unit id="62f16067b7a90f0f4f245f000991fe2df5b1a555" translate="yes" xml:space="preserve">
          <source>The comparison is primarily based on the date, from earliest to latest. It is &quot;consistent with equals&quot;, as defined by &lt;a href=&quot;../lang/comparable&quot;&gt;&lt;code&gt;Comparable&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">比较主要基于日期，从最早到最晚。如&lt;a href=&quot;../lang/comparable&quot;&gt; &lt;code&gt;Comparable&lt;/code&gt; &lt;/a&gt;所定义，它是&amp;ldquo;等于等于&amp;rdquo; 。</target>
        </trans-unit>
        <trans-unit id="706f98b3cb9aba1254b020ff959b8465ce325b8c" translate="yes" xml:space="preserve">
          <source>The comparison is primarily based on the date-time, from earliest to latest. It is &quot;consistent with equals&quot;, as defined by &lt;a href=&quot;../lang/comparable&quot;&gt;&lt;code&gt;Comparable&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">比较主要基于日期时间，从最早到最晚。如&lt;a href=&quot;../lang/comparable&quot;&gt; &lt;code&gt;Comparable&lt;/code&gt; &lt;/a&gt;所定义，它是&amp;ldquo;等于等于&amp;rdquo; 。</target>
        </trans-unit>
        <trans-unit id="0062aa5848822076fe3842237a04acbf5acbd21a" translate="yes" xml:space="preserve">
          <source>The comparison order first by the chronology ID string, then by any additional information specific to the subclass. It is &quot;consistent with equals&quot;, as defined by &lt;a href=&quot;../../lang/comparable&quot;&gt;&lt;code&gt;Comparable&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">比较顺序首先是按时间顺序ID字符串，然后是特定于子类的其他任何信息。如&lt;a href=&quot;../../lang/comparable&quot;&gt; &lt;code&gt;Comparable&lt;/code&gt; &lt;/a&gt;所定义，它是&amp;ldquo;等于等于&amp;rdquo; 。</target>
        </trans-unit>
        <trans-unit id="3d38b5f16eb7a1039fb7fb049c7f6b1ebb31b6e6" translate="yes" xml:space="preserve">
          <source>The compiler might generate diagnostics during compilation (for example, error messages). If a diagnostic listener is provided, the diagnostics will be supplied to the listener. If no listener is provided, the diagnostics will be formatted in an unspecified format and written to the default output, which is &lt;code&gt;System.err&lt;/code&gt; unless otherwise specified. Even if a diagnostic listener is supplied, some diagnostics might not fit in a &lt;code&gt;Diagnostic&lt;/code&gt; and will be written to the default output.</source>
          <target state="translated">编译器可能会在编译过程中生成诊断信息（例如，错误消息）。如果提供了诊断侦听器，则将诊断信息提供给侦听器。如果未提供任何侦听器，则除非另有说明，否则诊断将以未指定的格式格式化，并写入默认输出 &lt;code&gt;System.err&lt;/code&gt; 。即使提供了诊断侦听器，某些诊断程序也可能不适合 &lt;code&gt;Diagnostic&lt;/code&gt; ，并将被写入默认输出。</target>
        </trans-unit>
        <trans-unit id="381f14496e56d0ef9908dc1f0d9bb14c74a2832d" translate="yes" xml:space="preserve">
          <source>The compiler relies on two services: &lt;a href=&quot;diagnosticlistener&quot;&gt;diagnostic listener&lt;/a&gt; and &lt;a href=&quot;javafilemanager&quot;&gt;file manager&lt;/a&gt;. Although most classes and interfaces in this package defines an API for compilers (and tools in general) the interfaces &lt;a href=&quot;diagnosticlistener&quot;&gt;DiagnosticListener&lt;/a&gt;, &lt;a href=&quot;javafilemanager&quot;&gt;JavaFileManager&lt;/a&gt;, &lt;a href=&quot;fileobject&quot;&gt;FileObject&lt;/a&gt;, and &lt;a href=&quot;javafileobject&quot;&gt;JavaFileObject&lt;/a&gt; are not intended to be used in applications. Instead these interfaces are intended to be implemented and used to provide customized services for a compiler and thus defines an SPI for compilers.</source>
          <target state="translated">编译器依赖于两种服务：&lt;a href=&quot;diagnosticlistener&quot;&gt;诊断侦听器&lt;/a&gt;和&lt;a href=&quot;javafilemanager&quot;&gt;文件管理器&lt;/a&gt;。尽管此软件包中的大多数类和接口都为编译器（和一般的工具）定义了API，但是&lt;a href=&quot;diagnosticlistener&quot;&gt;DiagnosticListener&lt;/a&gt;，&lt;a href=&quot;javafilemanager&quot;&gt;JavaFileManager&lt;/a&gt;，&lt;a href=&quot;fileobject&quot;&gt;FileObject&lt;/a&gt;和&lt;a href=&quot;javafileobject&quot;&gt;JavaFileObject&lt;/a&gt;接口并不打算在应用程序中使用。相反，这些接口旨在实现并用于为编译器提供定制服务，从而为编译器定义了SPI。</target>
        </trans-unit>
        <trans-unit id="362286647cd635d5481f683398fcaef1fc4da1f8" translate="yes" xml:space="preserve">
          <source>The complement of the specified set in this set</source>
          <target state="translated">这个集合中指定集合的补码</target>
        </trans-unit>
        <trans-unit id="a5e446a959aa30fea4f31ea3c5f55e40725fce89" translate="yes" xml:space="preserve">
          <source>The complete date is expressed using three fields:</source>
          <target state="translated">完整的日期用三个字段表示。</target>
        </trans-unit>
        <trans-unit id="62ccc62c3b00948e20f42cc9c3131d69e90ab141" translate="yes" xml:space="preserve">
          <source>The complete set of transitions for this rules instance is defined by this method and &lt;a href=&quot;zonerules#getTransitionRules--&quot;&gt;&lt;code&gt;getTransitionRules()&lt;/code&gt;&lt;/a&gt;. This method returns those transitions that have been fully defined. These are typically historical, but may be in the future.</source>
          <target state="translated">此规则实例的完整过渡集由此方法和&lt;a href=&quot;zonerules#getTransitionRules--&quot;&gt; &lt;code&gt;getTransitionRules()&lt;/code&gt; &lt;/a&gt;定义。此方法返回已完全定义的转换。这些通常是历史性的，但可能会在将来。</target>
        </trans-unit>
        <trans-unit id="3cbe2850875a6f72ed6ab4a88952848315078e96" translate="yes" xml:space="preserve">
          <source>The complete set of transitions for this rules instance is defined by this method and &lt;a href=&quot;zonerules#getTransitions--&quot;&gt;&lt;code&gt;getTransitions()&lt;/code&gt;&lt;/a&gt;. This method returns instances of &lt;a href=&quot;zoneoffsettransitionrule&quot;&gt;&lt;code&gt;ZoneOffsetTransitionRule&lt;/code&gt;&lt;/a&gt; that define an algorithm for when transitions will occur.</source>
          <target state="translated">此规则实例的完整过渡集由此方法和&lt;a href=&quot;zonerules#getTransitions--&quot;&gt; &lt;code&gt;getTransitions()&lt;/code&gt; &lt;/a&gt;定义。此方法返回&lt;a href=&quot;zoneoffsettransitionrule&quot;&gt; &lt;code&gt;ZoneOffsetTransitionRule&lt;/code&gt; &lt;/a&gt;实例，这些实例定义了何时发生转换的算法。</target>
        </trans-unit>
        <trans-unit id="524c842350764043be1381deb4e7a75d9303361c" translate="yes" xml:space="preserve">
          <source>The completion handler for an I/O operation initiated on a channel bound to a group is guaranteed to be invoked by one of the pooled threads in the group. This ensures that the completion handler is run by a thread with the expected &lt;em&gt;identity&lt;/em&gt;.</source>
          <target state="translated">确保在绑定到组的通道上启动的I / O操作的完成处理程序由组中的一个池化线程调用。这样可以确保完成处理程序由具有预期&lt;em&gt;标识&lt;/em&gt;的线程运行。</target>
        </trans-unit>
        <trans-unit id="0d8a524b8f0bfc14d5b33c03393a926327201c05" translate="yes" xml:space="preserve">
          <source>The component at index posn.</source>
          <target state="translated">索引位置的分量。</target>
        </trans-unit>
        <trans-unit id="6353bf9fb6b5c395dc80e83b16932093c258f2dc" translate="yes" xml:space="preserve">
          <source>The component removed (a String).</source>
          <target state="translated">删除的组件(字符串)。</target>
        </trans-unit>
        <trans-unit id="551e179ff0a1f6b74371033d523205c16478c234" translate="yes" xml:space="preserve">
          <source>The components of a LDAP name, that is, RDNs, are numbered. The indexes of a LDAP name with n RDNs range from 0 to n-1. This range may be written as [0,n). The right most RDN is at index 0, and the left most RDN is at index n-1. For example, the distinguished name: &quot;CN=Steve Kille, O=Isode Limited, C=GB&quot; is numbered in the following sequence ranging from 0 to 2: {C=GB, O=Isode Limited, CN=Steve Kille}. An empty LDAP name is represented by an empty RDN list.</source>
          <target state="translated">一个LDAP名称的组成部分,即RDNs,是有编号的。一个LDAP名的索引有n个RDNs,范围从0到n-1。这个范围可以写成[0,n)。最右边的RDN在索引0,最左边的RDN在索引n-1。例如,区别名称:&quot;CN=Steve Kille,O=Isode Limited,C=GB &quot;按以下从0到2的顺序编号:{C=GB,O=Isode Limited,CN=Steve Kille}。一个空的LDAP名称由一个空的RDN列表表示。</target>
        </trans-unit>
        <trans-unit id="5dc21cc1b67ef648051518375f8f7207d80d43fb" translate="yes" xml:space="preserve">
          <source>The components of a composite name are numbered. The indexes of a composite name with N components range from 0 up to, but not including, N. This range may be written as [0,N). The most significant component is at index 0. An empty composite name has no components.</source>
          <target state="translated">一个复合名称的组件都是有编号的,有N个组件的复合名称的索引范围是0,但不包括N。有N个成分的复合名称的索引范围从0到N,但不包括N,这个范围可以写成[0,N)。最重要的组件在索引0处。一个空的复合名称没有任何组件。</target>
        </trans-unit>
        <trans-unit id="14a1f972f1e3053de3d05dc8a5b4d01708c7f345" translate="yes" xml:space="preserve">
          <source>The components of a compound name are numbered. The indexes of a compound name with N components range from 0 up to, but not including, N. This range may be written as [0,N). The most significant component is at index 0. An empty compound name has no components.</source>
          <target state="translated">一个复合名称的组件是有编号的。有N个成分的复合名称的索引范围从0到N,但不包括N。这个范围可以写成[0,N)。最重要的组件在索引0处。一个空的复合名没有成分。</target>
        </trans-unit>
        <trans-unit id="3bfe595dae00ecadd506655e42ccf5b0136b9bf1" translate="yes" xml:space="preserve">
          <source>The components of a name are numbered. The indexes of a name with N components range from 0 up to, but not including, N. This range may be written as [0,N). The most significant component is at index 0. An empty name has no components.</source>
          <target state="translated">一个名字的组成部分是有编号的。一个名字的N个成分的索引范围从0到N,但不包括N。这个范围可以写成[0,N)。最重要的组件在索引0处。一个空的名字没有任何组件。</target>
        </trans-unit>
        <trans-unit id="5352c3728b0e0385e152a82e295d498e4fb174ac" translate="yes" xml:space="preserve">
          <source>The compression type strings and the image type(s) each supports are listed in the following table:</source>
          <target state="translated">压缩类型字符串和每个支持的图像类型列在下表中。</target>
        </trans-unit>
        <trans-unit id="de48d26fe33c726460e7d2fda077c5a4d41c831c" translate="yes" xml:space="preserve">
          <source>The computation of the value returned by this method is similar to that of the value returned by &lt;a href=&quot;list#hashCode--&quot;&gt;&lt;code&gt;List.hashCode()&lt;/code&gt;&lt;/a&gt; on a list containing the same elements as &lt;code&gt;a&lt;/code&gt; in the same order, with one difference: If an element &lt;code&gt;e&lt;/code&gt; of &lt;code&gt;a&lt;/code&gt; is itself an array, its hash code is computed not by calling &lt;code&gt;e.hashCode()&lt;/code&gt;, but as by calling the appropriate overloading of &lt;code&gt;Arrays.hashCode(e)&lt;/code&gt; if &lt;code&gt;e&lt;/code&gt; is an array of a primitive type, or as by calling &lt;code&gt;Arrays.deepHashCode(e)&lt;/code&gt; recursively if &lt;code&gt;e&lt;/code&gt; is an array of a reference type. If &lt;code&gt;a&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, this method returns 0.</source>
          <target state="translated">通过此方法返回的值的计算是类似于由返回的值的&lt;a href=&quot;list#hashCode--&quot;&gt; &lt;code&gt;List.hashCode()&lt;/code&gt; &lt;/a&gt;包含相同的元素作为列表上 &lt;code&gt;a&lt;/code&gt; 以相同的顺序，有一点不同：如果一个元素 &lt;code&gt;e&lt;/code&gt; 的 &lt;code&gt;a&lt;/code&gt; 本身是一个数组，其哈希码不是通过调用 &lt;code&gt;e.hashCode()&lt;/code&gt; 来计算的，而是通过调用 &lt;code&gt;Arrays.hashCode(e)&lt;/code&gt; 的适当重载（如果 &lt;code&gt;e&lt;/code&gt; 是原始类型的数组）来计算的，或者通过调用 &lt;code&gt;Arrays.deepHashCode(e)&lt;/code&gt; 来计算的如果 &lt;code&gt;e&lt;/code&gt; 是引用类型的数组，则递归地进行。如果 &lt;code&gt;a&lt;/code&gt; 为 &lt;code&gt;null&lt;/code&gt; ，则此方法返回0。</target>
        </trans-unit>
        <trans-unit id="214bb0bb62df51550823153b8ce29f6dab115c3a" translate="yes" xml:space="preserve">
          <source>The computation performed by a stage may be expressed as a Function, Consumer, or Runnable (using methods with names including &lt;em&gt;apply&lt;/em&gt;, &lt;em&gt;accept&lt;/em&gt;, or &lt;em&gt;run&lt;/em&gt;, respectively) depending on whether it requires arguments and/or produces results. For example, &lt;code&gt;stage.thenApply(x -&amp;gt; square(x)).thenAccept(x -&amp;gt;
 System.out.print(x)).thenRun(() -&amp;gt; System.out.println())&lt;/code&gt;. An additional form (&lt;em&gt;compose&lt;/em&gt;) applies functions of stages themselves, rather than their results.</source>
          <target state="translated">阶段执行的计算可以表示为Function，Consumer或Runnable（分别使用名称包括&lt;em&gt;apply&lt;/em&gt;，&lt;em&gt;accept&lt;/em&gt;或&lt;em&gt;run的方法&lt;/em&gt;），具体取决于它是否需要参数和/或产生结果。例如， &lt;code&gt;stage.thenApply(x -&amp;gt; square(x)).thenAccept(x -&amp;gt; System.out.print(x)).thenRun(() -&amp;gt; System.out.println())&lt;/code&gt; 。附加形式（&lt;em&gt;compose&lt;/em&gt;）应用阶段本身的功能，而不是其结果。</target>
        </trans-unit>
        <trans-unit id="1691fd27bc6e097f4599ed6bb1fc28887a525083" translate="yes" xml:space="preserve">
          <source>The computations for day-of-week, week-of-month, and week-of-year are based on the &lt;a href=&quot;chronofield#YEAR&quot;&gt;proleptic-year&lt;/a&gt;, &lt;a href=&quot;chronofield#MONTH_OF_YEAR&quot;&gt;month-of-year&lt;/a&gt;, &lt;a href=&quot;chronofield#DAY_OF_MONTH&quot;&gt;day-of-month&lt;/a&gt;, and &lt;a href=&quot;chronofield#DAY_OF_WEEK&quot;&gt;ISO day-of-week&lt;/a&gt; which are based on the &lt;a href=&quot;chronofield#EPOCH_DAY&quot;&gt;epoch-day&lt;/a&gt; and the chronology. The values may not be aligned with the &lt;a href=&quot;chronofield#YEAR_OF_ERA&quot;&gt;year-of-Era&lt;/a&gt; depending on the Chronology.</source>
          <target state="translated">对于本周日的最计算，一年周的周的日和是基于&lt;a href=&quot;chronofield#YEAR&quot;&gt;proleptic年&lt;/a&gt;，&lt;a href=&quot;chronofield#MONTH_OF_YEAR&quot;&gt;月的年中&lt;/a&gt;，&lt;a href=&quot;chronofield#DAY_OF_MONTH&quot;&gt;日的一个月&lt;/a&gt;，和&lt;a href=&quot;chronofield#DAY_OF_WEEK&quot;&gt;ISO星期几，&lt;/a&gt;这是基于&lt;a href=&quot;chronofield#EPOCH_DAY&quot;&gt;时代&lt;/a&gt;和年代。根据时间顺序，这些值可能与&lt;a href=&quot;chronofield#YEAR_OF_ERA&quot;&gt;年份&lt;/a&gt;不符。</target>
        </trans-unit>
        <trans-unit id="e0a314c28965a5184605c91a9dd77e2a63a6282c" translate="yes" xml:space="preserve">
          <source>The computed result must be within 1 ulp of the exact result.</source>
          <target state="translated">计算出的结果必须与精确结果相差1ulp以内。</target>
        </trans-unit>
        <trans-unit id="778968ebec250a920a57d7938e53b3467b9d8fb1" translate="yes" xml:space="preserve">
          <source>The computed result must be within 1 ulp of the exact result. If one parameter is held constant, the results must be semi-monotonic in the other parameter.</source>
          <target state="translated">计算出的结果必须与精确结果相差1ulp以内。如果一个参数保持不变,则另一个参数的结果必须是半单调的。</target>
        </trans-unit>
        <trans-unit id="a6674b79e473f3879ed7bc38a2aea8ceb42331e7" translate="yes" xml:space="preserve">
          <source>The computed result must be within 1 ulp of the exact result. Results must be semi-monotonic.</source>
          <target state="translated">计算的结果必须在1ulp以内。结果必须是半单调的。</target>
        </trans-unit>
        <trans-unit id="a95667f460b33082c1f4875f29adeb6b10893583" translate="yes" xml:space="preserve">
          <source>The computed result must be within 1 ulp of the exact result. Results must be semi-monotonic. The result of &lt;code&gt;expm1&lt;/code&gt; for any finite input must be greater than or equal to &lt;code&gt;-1.0&lt;/code&gt;. Note that once the exact result of</source>
          <target state="translated">计算结果必须在准确结果的1 ulp以内。结果必须是半单调的。任何有限输入的 &lt;code&gt;expm1&lt;/code&gt; 结果必须大于或等于 &lt;code&gt;-1.0&lt;/code&gt; 。请注意，一旦</target>
        </trans-unit>
        <trans-unit id="051083ed8bd5eb53cc6b0a3e3e4e3a859c790084" translate="yes" xml:space="preserve">
          <source>The computed result must be within 2 ulps of the exact result. Results must be semi-monotonic.</source>
          <target state="translated">计算的结果必须在2个尺码以内。结果必须是半单调的。</target>
        </trans-unit>
        <trans-unit id="8e8d50f4531c22cdf1c57032345e12f930311bee" translate="yes" xml:space="preserve">
          <source>The computed result must be within 2.5 ulps of the exact result.</source>
          <target state="translated">计算的结果必须在2.5ulps以内。</target>
        </trans-unit>
        <trans-unit id="5716b70a97e32988d2cb0c294378ce7e42458ba1" translate="yes" xml:space="preserve">
          <source>The computed result must be within 2.5 ulps of the exact result. The result of &lt;code&gt;tanh&lt;/code&gt; for any finite input must have an absolute value less than or equal to 1. Note that once the exact result of tanh is within 1/2 of an ulp of the limit value of &amp;plusmn;1, correctly signed &amp;plusmn;&lt;code&gt;1.0&lt;/code&gt; should be returned.</source>
          <target state="translated">计算结果必须在准确结果的2.5 ulps之内。任何有限输入的 &lt;code&gt;tanh&lt;/code&gt; 结果必须具有小于或等于1的绝对值。请注意，一旦tanh的精确结果在极限值&amp;plusmn;1的ulp的1/2范围内，则应正确签名&amp;plusmn; &lt;code&gt;1.0&lt;/code&gt; 回来。</target>
        </trans-unit>
        <trans-unit id="e44ba5b29ec6b29fa13a1c0b35b2b236c3e56f08" translate="yes" xml:space="preserve">
          <source>The concepts are easier to understand by comparison with the Standard MBean concept. Here is how a managed object might be represented as a Standard MBean, and as an MXBean:</source>
          <target state="translated">通过与标准MBean概念的比较,这些概念更容易理解。下面是如何将一个管理对象表示为一个标准MBean和一个MXBean。</target>
        </trans-unit>
        <trans-unit id="406e4cef7e07251a93d230aa3d12ee538ab9badb" translate="yes" xml:space="preserve">
          <source>The conceptual distinction between URIs and URLs is reflected in the differences between this class and the &lt;a href=&quot;url&quot;&gt;&lt;code&gt;URL&lt;/code&gt;&lt;/a&gt; class.</source>
          <target state="translated">URI和URL之间的概念区别体现在此类与&lt;a href=&quot;url&quot;&gt; &lt;code&gt;URL&lt;/code&gt; &lt;/a&gt;类之间的差异上。</target>
        </trans-unit>
        <trans-unit id="07517dfd669419de18de761dd5d44e2d407cd858" translate="yes" xml:space="preserve">
          <source>The concurrency properties of bulk operations follow from those of ConcurrentHashMap: Any non-null result returned from &lt;code&gt;get(key)&lt;/code&gt; and related access methods bears a happens-before relation with the associated insertion or update. The result of any bulk operation reflects the composition of these per-element relations (but is not necessarily atomic with respect to the map as a whole unless it is somehow known to be quiescent). Conversely, because keys and values in the map are never null, null serves as a reliable atomic indicator of the current lack of any result. To maintain this property, null serves as an implicit basis for all non-scalar reduction operations. For the double, long, and int versions, the basis should be one that, when combined with any other value, returns that other value (more formally, it should be the identity element for the reduction). Most common reductions have these properties; for example, computing a sum with basis 0 or a minimum with basis MAX_VALUE.</source>
          <target state="translated">批量操作的并发属性遵循ConcurrentHashMap的并发属性： &lt;code&gt;get(key)&lt;/code&gt; 返回的任何非空结果并且相关的访问方法与关联的插入或更新具有事前发生的关系。任何批量操作的结果都反映了这些每个元素关系的组成（但对于整个地图而言，不一定是原子的，除非以某种方式已知它是静态的）。相反，由于映射中的键和值永远不会为null，因此null可作为当前缺少任何结果的可靠原子指示。为了保持此属性，null用作所有非标量归约操作的隐式基础。对于double，long和int版本，其基础应该是当与任何其他值组合时返回该其他值的基础（更正式地讲，它应该是简化的标识元素）。最常见的还原具有这些特性。例如，计算基数为0的总和或基数为MAX_VALUE的最小值。</target>
        </trans-unit>
        <trans-unit id="695bcb81bf8921f2b489db3866dc5c4b73eb01e2" translate="yes" xml:space="preserve">
          <source>The conditional constructs &lt;code&gt;(?(&lt;/code&gt;</source>
          <target state="translated">条件构造 &lt;code&gt;(?(&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8f9289d113f06c7752017512ddee95d8472dadf4" translate="yes" xml:space="preserve">
          <source>The configuration files and their corresponding implementation classes must be accessible to the calling thread's context class loader.</source>
          <target state="translated">配置文件及其相应的实现类必须可以被调用线程的上下文类加载器访问。</target>
        </trans-unit>
        <trans-unit id="0bd8196d8a21097374666c4e69a129e9d0dc940d" translate="yes" xml:space="preserve">
          <source>The conjunction of the two arguments. The returned object will be serialized as an instance of the non-public class  javax.management.AndQueryExp.</source>
          <target state="translated">两个参数的组合。返回的对象将被序列化为非公开类javax.management.AndQueryExp.AndQueryExp的实例。</target>
        </trans-unit>
        <trans-unit id="fb86bc8294f16c5649875c6782a7b1a216e845cc" translate="yes" xml:space="preserve">
          <source>The connection ID to which this notification pertains.</source>
          <target state="translated">该通知所涉及的连接ID。</target>
        </trans-unit>
        <trans-unit id="f8ff508fdc1ac8bc4959ca20489757c5f0a674de" translate="yes" xml:space="preserve">
          <source>The connection object is created by invoking the &lt;code&gt;openConnection&lt;/code&gt; method on a URL.</source>
          <target state="translated">通过在URL上调用 &lt;code&gt;openConnection&lt;/code&gt; 方法来创建连接对象。</target>
        </trans-unit>
        <trans-unit id="c2f7f112153c54fb4cda2b130cddc1d8821a798f" translate="yes" xml:space="preserve">
          <source>The connection to the JAR file URL, if the connection has been initiated. This should be set by connect.</source>
          <target state="translated">连接到JAR文件的URL,如果连接已经启动。这应该由connect设置。</target>
        </trans-unit>
        <trans-unit id="2fdbc77cf21a62029729ae4d767690b0796a4208" translate="yes" xml:space="preserve">
          <source>The connector server will generate an &lt;code&gt;RMIServerImpl&lt;/code&gt; based on the protocol (&lt;code&gt;rmi&lt;/code&gt; or &lt;code&gt;iiop&lt;/code&gt;) and, for &lt;code&gt;rmi&lt;/code&gt;, the &lt;code&gt;&lt;em&gt;port&lt;/em&gt;&lt;/code&gt; if any. When the connector server is started, it will derive a stub from this object using its &lt;a href=&quot;rmiserverimpl#toStub--&quot;&gt;&lt;code&gt;toStub&lt;/code&gt;&lt;/a&gt; method and store the object using the given &lt;code&gt;&lt;em&gt;jndi-name&lt;/em&gt;&lt;/code&gt;. The properties defined by the JNDI API are consulted as usual.</source>
          <target state="translated">连接器服务器将基于协议（ &lt;code&gt;rmi&lt;/code&gt; 或 &lt;code&gt;iiop&lt;/code&gt; ）以及（对于 &lt;code&gt;rmi&lt;/code&gt; ） &lt;code&gt;&lt;em&gt;port&lt;/em&gt;&lt;/code&gt; 如果有）生成 &lt;code&gt;RMIServerImpl&lt;/code&gt; 。启动连接器服务器时，它将使用其&lt;a href=&quot;rmiserverimpl#toStub--&quot;&gt; &lt;code&gt;toStub&lt;/code&gt; &lt;/a&gt;方法从该对象派生一个存根，并使用给定的 &lt;code&gt;&lt;em&gt;jndi-name&lt;/em&gt;&lt;/code&gt; 存储该对象。照常查询JNDI API定义的属性。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9dd5ae6d1e3cade50eb6caf2c268a1278764c4fb" translate="yes" xml:space="preserve">
          <source>The console-read methods return &lt;code&gt;null&lt;/code&gt; when the end of the console input stream is reached, for example by typing control-D on Unix or control-Z on Windows. Subsequent read operations will succeed if additional characters are later entered on the console's input device.</source>
          <target state="translated">当到达控制台输入流的末尾时，例如通过在Unix上键入control-D或在Windows上键入control-Z，控制台读取方法返回 &lt;code&gt;null&lt;/code&gt; 。如果以后在控制台的输入设备上输入了其他字符，则后续的读取操作将成功。</target>
        </trans-unit>
        <trans-unit id="bf3c6b7bb1907894e51344d6616a6e7cb10386dc" translate="yes" xml:space="preserve">
          <source>The constant &lt;a href=&quot;elementtype#TYPE_USE&quot;&gt;&lt;code&gt;TYPE_USE&lt;/code&gt;&lt;/a&gt; corresponds to the 15 type contexts in JLS 4.11, as well as to two declaration contexts: type declarations (including annotation type declarations) and type parameter declarations.</source>
          <target state="translated">常量&lt;a href=&quot;elementtype#TYPE_USE&quot;&gt; &lt;code&gt;TYPE_USE&lt;/code&gt; &lt;/a&gt;对应于JLS 4.11中的15个类型上下文，以及两个声明上下文：类型声明（包括注释类型声明）和类型参数声明。</target>
        </trans-unit>
        <trans-unit id="fd7d21b839d915be854999ae3895c9fc0775c58b" translate="yes" xml:space="preserve">
          <source>The constant value of this field is the largest value of type &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;'\uFFFF'&lt;/code&gt;.</source>
          <target state="translated">此字段的常数值类型的最大值 &lt;code&gt;char&lt;/code&gt; ， &lt;code&gt;'\uFFFF'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="13a3d4f9e90fafbe487863d61e2c681b40a76e07" translate="yes" xml:space="preserve">
          <source>The constant value of this field is the smallest value of type &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;'\u0000'&lt;/code&gt;.</source>
          <target state="translated">此字段的恒定值是类型的最小值 &lt;code&gt;char&lt;/code&gt; ， &lt;code&gt;'\u0000'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a5c3ae86c80c0ffd5751f1bcac0fbdd026305053" translate="yes" xml:space="preserve">
          <source>The constant which defines the length of a DES key in bytes.</source>
          <target state="translated">定义DES密钥长度的常数,单位为字节。</target>
        </trans-unit>
        <trans-unit id="2c331109070150d080aecfe00c315900d5ffe214" translate="yes" xml:space="preserve">
          <source>The constant which defines the length of a DESede key in bytes.</source>
          <target state="translated">定义 DESede 密钥长度的常数,单位为字节。</target>
        </trans-unit>
        <trans-unit id="e3144d771789e4d26a103912ef85edcf80e38dfe" translate="yes" xml:space="preserve">
          <source>The constants &lt;a href=&quot;elementtype#ANNOTATION_TYPE&quot;&gt;&lt;code&gt;ANNOTATION_TYPE&lt;/code&gt;&lt;/a&gt; , &lt;a href=&quot;elementtype#CONSTRUCTOR&quot;&gt;&lt;code&gt;CONSTRUCTOR&lt;/code&gt;&lt;/a&gt; , &lt;a href=&quot;elementtype#FIELD&quot;&gt;&lt;code&gt;FIELD&lt;/code&gt;&lt;/a&gt; , &lt;a href=&quot;elementtype#LOCAL_VARIABLE&quot;&gt;&lt;code&gt;LOCAL_VARIABLE&lt;/code&gt;&lt;/a&gt; , &lt;a href=&quot;elementtype#METHOD&quot;&gt;&lt;code&gt;METHOD&lt;/code&gt;&lt;/a&gt; , &lt;a href=&quot;elementtype#PACKAGE&quot;&gt;&lt;code&gt;PACKAGE&lt;/code&gt;&lt;/a&gt; , &lt;a href=&quot;elementtype#PARAMETER&quot;&gt;&lt;code&gt;PARAMETER&lt;/code&gt;&lt;/a&gt; , &lt;a href=&quot;elementtype#TYPE&quot;&gt;&lt;code&gt;TYPE&lt;/code&gt;&lt;/a&gt; , and &lt;a href=&quot;elementtype#TYPE_PARAMETER&quot;&gt;&lt;code&gt;TYPE_PARAMETER&lt;/code&gt;&lt;/a&gt; correspond to the declaration contexts in JLS 9.6.4.1.</source>
          <target state="translated">常量&lt;a href=&quot;elementtype#ANNOTATION_TYPE&quot;&gt; &lt;code&gt;ANNOTATION_TYPE&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;elementtype#CONSTRUCTOR&quot;&gt; &lt;code&gt;CONSTRUCTOR&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;elementtype#FIELD&quot;&gt; &lt;code&gt;FIELD&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;elementtype#LOCAL_VARIABLE&quot;&gt; &lt;code&gt;LOCAL_VARIABLE&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;elementtype#METHOD&quot;&gt; &lt;code&gt;METHOD&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;elementtype#PACKAGE&quot;&gt; &lt;code&gt;PACKAGE&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;elementtype#PARAMETER&quot;&gt; &lt;code&gt;PARAMETER&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;elementtype#TYPE&quot;&gt; &lt;code&gt;TYPE&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;elementtype#TYPE_PARAMETER&quot;&gt; &lt;code&gt;TYPE_PARAMETER&lt;/code&gt; &lt;/a&gt;对应于JLS 9.6.4.1中的声明上下文。</target>
        </trans-unit>
        <trans-unit id="5c6db25e66548268914c017d479808b70cf00b1c" translate="yes" xml:space="preserve">
          <source>The constants of this enumerated type provide a simple classification of the syntactic locations where annotations may appear in a Java program.</source>
          <target state="translated">这个枚举类型的常量提供了对Java程序中可能出现注释的语法位置的简单分类。</target>
        </trans-unit>
        <trans-unit id="feb4cacf066dccc67c2a1e1cd57d17bf146fe670" translate="yes" xml:space="preserve">
          <source>The constants of this enumerated type provide a simple classification of the syntactic locations where annotations may appear in a Java program. These constants are used in &lt;a href=&quot;target&quot;&gt;&lt;code&gt;java.lang.annotation.Target&lt;/code&gt;&lt;/a&gt; meta-annotations to specify where it is legal to write annotations of a given type.</source>
          <target state="translated">此枚举类型的常量提供对Java程序中可能出现注释的句法位置的简单分类。这些常量在&lt;a href=&quot;target&quot;&gt; &lt;code&gt;java.lang.annotation.Target&lt;/code&gt; &lt;/a&gt;元注释中使用，以指定在何处编写给定类型的注释是合法的。</target>
        </trans-unit>
        <trans-unit id="ba3ca4b2e56262c71dbe0a15263e988db1d00eb8" translate="yes" xml:space="preserve">
          <source>The constraint that a matches s. The returned object will be serialized as an instance of the non-public class  javax.management.MatchQueryExp.</source>
          <target state="translated">返回的对象将被序列化为非公共类 javax.management.MatchQueryExp 的实例。</target>
        </trans-unit>
        <trans-unit id="6d919fe4516cb983d55f9db338ccc9c7dde1f1b9" translate="yes" xml:space="preserve">
          <source>The constraint that v1 lies between v2 and v3. The returned object will be serialized as an instance of the non-public class  javax.management.BetweenQueryExp.</source>
          <target state="translated">v1位于v2和v3之间的约束条件。返回的对象将被序列化为非公开类javax.management.BetweenQueryExp.AfterQueryExp的实例。</target>
        </trans-unit>
        <trans-unit id="3d680dfab2d7cf7f3941527a50827dfaf79d9cb1" translate="yes" xml:space="preserve">
          <source>The constructor checks that all the constraints listed below for each parameter are satisfied, and throws the appropriate exception if they are not.</source>
          <target state="translated">构造函数检查每个参数是否满足下面列出的所有约束条件,如果不满足则抛出相应的异常。</target>
        </trans-unit>
        <trans-unit id="55c1cac93e10dcceae66fd36ab495f0d17064a67" translate="yes" xml:space="preserve">
          <source>The constructor for this class accepts an optional &lt;em&gt;fairness&lt;/em&gt; parameter. When set &lt;code&gt;true&lt;/code&gt;, under contention, locks favor granting access to the longest-waiting thread. Otherwise this lock does not guarantee any particular access order. Programs using fair locks accessed by many threads may display lower overall throughput (i.e., are slower; often much slower) than those using the default setting, but have smaller variances in times to obtain locks and guarantee lack of starvation. Note however, that fairness of locks does not guarantee fairness of thread scheduling. Thus, one of many threads using a fair lock may obtain it multiple times in succession while other active threads are not progressing and not currently holding the lock. Also note that the untimed &lt;a href=&quot;reentrantlock#tryLock--&quot;&gt;&lt;code&gt;tryLock()&lt;/code&gt;&lt;/a&gt; method does not honor the fairness setting. It will succeed if the lock is available even if other threads are waiting.</source>
          <target state="translated">此类的构造函数接受一个可选的&lt;em&gt;fairness&lt;/em&gt;参数。设置为 &lt;code&gt;true&lt;/code&gt; 时，在争用条件下，锁倾向于授予对等待时间最长的线程的访问。否则，此锁不能保证任何特定的访问顺序。与使用默认设置的程序相比，使用许多线程访问的公平锁的程序可能会显示较低的总体吞吐量（即，速度较慢；通常要慢得多），但获得锁的时间变化较小，并确保没有饥饿。但是请注意，锁的公平性不能保证线程调度的公平性。因此，使用公平锁的许多线程之一可能会连续多次获得它，而其他活动线程未进行且当前未持有该锁。另请注意，未定时的&lt;a href=&quot;reentrantlock#tryLock--&quot;&gt; &lt;code&gt;tryLock()&lt;/code&gt; &lt;/a&gt;方法不遵循公平性设置。如果锁定可用，即使其他线程正在等待，它将成功。</target>
        </trans-unit>
        <trans-unit id="cabf2c65732e2de463fc3500f56a6de7aadab8e6" translate="yes" xml:space="preserve">
          <source>The constructor for this class optionally accepts a &lt;em&gt;fairness&lt;/em&gt; parameter. When set false, this class makes no guarantees about the order in which threads acquire permits. In particular, &lt;em&gt;barging&lt;/em&gt; is permitted, that is, a thread invoking &lt;a href=&quot;semaphore#acquire--&quot;&gt;&lt;code&gt;acquire()&lt;/code&gt;&lt;/a&gt; can be allocated a permit ahead of a thread that has been waiting - logically the new thread places itself at the head of the queue of waiting threads. When fairness is set true, the semaphore guarantees that threads invoking any of the &lt;a href=&quot;semaphore#acquire--&quot;&gt;&lt;code&gt;acquire&lt;/code&gt;&lt;/a&gt; methods are selected to obtain permits in the order in which their invocation of those methods was processed (first-in-first-out; FIFO). Note that FIFO ordering necessarily applies to specific internal points of execution within these methods. So, it is possible for one thread to invoke &lt;code&gt;acquire&lt;/code&gt; before another, but reach the ordering point after the other, and similarly upon return from the method. Also note that the untimed &lt;a href=&quot;semaphore#tryAcquire--&quot;&gt;&lt;code&gt;tryAcquire&lt;/code&gt;&lt;/a&gt; methods do not honor the fairness setting, but will take any permits that are available.</source>
          <target state="translated">此类的构造函数可以选择接受&lt;em&gt;公平&lt;/em&gt;参数。设置为false时，此类不保证线程获得许可的顺序。特别是，&lt;em&gt;闯入&lt;/em&gt;是允许的，也就是说，一个线程调用&lt;a href=&quot;semaphore#acquire--&quot;&gt; &lt;code&gt;acquire()&lt;/code&gt; &lt;/a&gt;可以提前已经等待线程分配的许可证-在逻辑上新的线程将自己置于等待线程队列的头部。当公平性设置为true时，信号量可确保线程调用任何&lt;a href=&quot;semaphore#acquire--&quot;&gt; &lt;code&gt;acquire&lt;/code&gt; &lt;/a&gt;选择方法以按照处理这些方法的调用顺序来获得许可（先进先出； FIFO）。请注意，FIFO排序必须适用于这些方法中的特定内部执行点。因此，一个线程有可能在另一个线程之前调用 &lt;code&gt;acquire&lt;/code&gt; ，但在另一个线程之后到达排序点，并且类似地在从方法返回时调用。另请注意，未计时的&lt;a href=&quot;semaphore#tryAcquire--&quot;&gt; &lt;code&gt;tryAcquire&lt;/code&gt; &lt;/a&gt;方法不遵循公平性设置，但会采用任何可用的许可。</target>
        </trans-unit>
        <trans-unit id="2f82cef178c196bbec6e0156b69c44428cb62da4" translate="yes" xml:space="preserve">
          <source>The constructor to reflect is the public constructor of the class represented by this &lt;code&gt;Class&lt;/code&gt; object whose formal parameter types match those specified by &lt;code&gt;parameterTypes&lt;/code&gt;.</source>
          <target state="translated">要反映的构造方法是此 &lt;code&gt;Class&lt;/code&gt; 对象表示的类的公共构造方法，其正式参数类型与 &lt;code&gt;parameterTypes&lt;/code&gt; 指定的类型相匹配。</target>
        </trans-unit>
        <trans-unit id="dc091f884e5b69128c7db36ffbfe76ae011df98f" translate="yes" xml:space="preserve">
          <source>The content and representation of an attribute and its values is defined by the attribute's &lt;em&gt;schema&lt;/em&gt;. The schema contains information about the attribute's syntax and other properties about the attribute. See &lt;code&gt;getAttributeDefinition()&lt;/code&gt; and &lt;code&gt;getAttributeSyntaxDefinition()&lt;/code&gt; for details regarding how to get schema information about an attribute if the underlying directory service supports schemas.</source>
          <target state="translated">属性及其值的内容和表示形式由属性的&lt;em&gt;schema&lt;/em&gt;定义。该模式包含有关属性语法的信息以及有关该属性的其他属性。有关在基础目录服务支持架构的情况下如何获取有关属性的架构信息的详细信息，请参见 &lt;code&gt;getAttributeDefinition()&lt;/code&gt; 和 &lt;code&gt;getAttributeSyntaxDefinition()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fcaf947eb04b0f9c4537af81320b15e8bade372f" translate="yes" xml:space="preserve">
          <source>The content length set by invoking this method takes precedence over any value set by &lt;a href=&quot;httpurlconnection#setFixedLengthStreamingMode-int-&quot;&gt;&lt;code&gt;setFixedLengthStreamingMode(int)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通过调用此方法设置的内容长度优先于&lt;a href=&quot;httpurlconnection#setFixedLengthStreamingMode-int-&quot;&gt; &lt;code&gt;setFixedLengthStreamingMode(int)&lt;/code&gt; &lt;/a&gt;设置的任何值。</target>
        </trans-unit>
        <trans-unit id="571ca938b3faeb08721ed17e39715453eb020c82" translate="yes" xml:space="preserve">
          <source>The content of a mapped byte buffer can change at any time, for example if the content of the corresponding region of the mapped file is changed by this program or another. Whether or not such changes occur, and when they occur, is operating-system dependent and therefore unspecified.</source>
          <target state="translated">映射的字节缓冲区的内容可以随时改变,例如,如果映射文件的相应区域的内容被这个程序或另一个程序改变了。这种变化是否发生,以及何时发生,取决于操作系统,因此没有说明。</target>
        </trans-unit>
        <trans-unit id="8ec1fd8ede78cb7ef9de2d4323ba7216c5e957fd" translate="yes" xml:space="preserve">
          <source>The content of the new buffer will be that of this buffer. Changes to this buffer's content will be visible in the new buffer, and vice versa; the two buffers' position, limit, and mark values will be independent.</source>
          <target state="translated">新缓冲区的内容将是这个缓冲区的内容。对这个缓冲区内容的更改将在新缓冲区中可见,反之亦然;两个缓冲区的位置、限制和标记值将是独立的。</target>
        </trans-unit>
        <trans-unit id="b52924f0667cd93dbfd903475fcb1b22e1203c6d" translate="yes" xml:space="preserve">
          <source>The content of the new buffer will be that of this buffer. Changes to this buffer's content will be visible in the new buffer; the new buffer itself, however, will be read-only and will not allow the shared content to be modified. The two buffers' position, limit, and mark values will be independent.</source>
          <target state="translated">新缓冲区的内容将是这个缓冲区的内容。对该缓冲区内容的修改将在新缓冲区中可见;但新缓冲区本身将是只读的,不允许修改共享内容。两个缓冲区的位置、限制和标记值将是独立的。</target>
        </trans-unit>
        <trans-unit id="8be5a548cfa9fe9bb9c255c2eb6075bfe2f8e059" translate="yes" xml:space="preserve">
          <source>The content of the new buffer will start at this buffer's current position. Changes to this buffer's content will be visible in the new buffer, and vice versa; the two buffers' position, limit, and mark values will be independent.</source>
          <target state="translated">新缓冲区的内容将从这个缓冲区的当前位置开始。对这个缓冲区内容的更改将在新缓冲区中可见,反之亦然;两个缓冲区的位置、限制和标记值将是独立的。</target>
        </trans-unit>
        <trans-unit id="cefde5877ed78f05c3cd681ed1cfc50dc6c6dc4c" translate="yes" xml:space="preserve">
          <source>The content of the new, read-only buffer will be the content of the given character sequence. The buffer's capacity will be &lt;code&gt;csq.length()&lt;/code&gt;, its position will be &lt;code&gt;start&lt;/code&gt;, its limit will be &lt;code&gt;end&lt;/code&gt;, and its mark will be undefined.</source>
          <target state="translated">新的只读缓冲区的内容将是给定字符序列的内容。缓冲区的容量将为 &lt;code&gt;csq.length()&lt;/code&gt; ，其位置将为 &lt;code&gt;start&lt;/code&gt; ，其限制将为 &lt;code&gt;end&lt;/code&gt; ，并且其标记将不确定。</target>
        </trans-unit>
        <trans-unit id="26c3cb709632b1f3d492bb30e289e528ee9018bc" translate="yes" xml:space="preserve">
          <source>The content of the new, read-only buffer will be the content of the given character sequence. The new buffer's capacity and limit will be &lt;code&gt;csq.length()&lt;/code&gt;, its position will be zero, and its mark will be undefined.</source>
          <target state="translated">新的只读缓冲区的内容将是给定字符序列的内容。新缓冲区的容量和限制将为 &lt;code&gt;csq.length()&lt;/code&gt; ，其位置将为零，并且其标记将不确定。</target>
        </trans-unit>
        <trans-unit id="a7af81925356d9326d970998ba5413043e77043f" translate="yes" xml:space="preserve">
          <source>The content type of the file, or &lt;code&gt;null&lt;/code&gt; if the content type cannot be determined</source>
          <target state="translated">文件的内容类型；如果无法确定内容类型，则为 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fefa96213a0f4f4a20404355dc88109a3b19df22" translate="yes" xml:space="preserve">
          <source>The content type or &lt;code&gt;null&lt;/code&gt; if the file type is not recognized</source>
          <target state="translated">内容类型；如果无法识别文件类型，则为 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="66f44833c6467f09c644d9346944666f84828bc6" translate="yes" xml:space="preserve">
          <source>The content will be imaged across the long edge of the medium, but in the opposite manner from landscape. Reverse-landscape is defined to be a rotation of the print-stream page to be imaged by -90 degrees with respect to the medium (i.e. clockwise) from the portrait orientation.</source>
          <target state="translated">内容将在介质的长边上成像,但方式与横向相反。反横向的定义是将打印流页面相对于介质(即顺时针)从纵向旋转90度成像。</target>
        </trans-unit>
        <trans-unit id="a6abed47322b2de7552654f3f1b6131fb26ff966" translate="yes" xml:space="preserve">
          <source>The content will be imaged across the long edge of the medium. Landscape is defined to be a rotation of the print-stream page to be imaged by +90 degrees with respect to the medium (i.e. anti-clockwise) from the portrait orientation.</source>
          <target state="translated">内容将在介质的长边上成像。横向定义为打印流页面相对于介质的旋转90度(即逆时针),从纵向开始成像。</target>
        </trans-unit>
        <trans-unit id="785e00c1b7145d81a8620ade1cef3fdb93caa602" translate="yes" xml:space="preserve">
          <source>The content will be imaged across the short edge of the medium, but in the opposite manner from portrait. Reverse-portrait is defined to be a rotation of the print-stream page to be imaged by 180 degrees with respect to the medium from the portrait orientation.</source>
          <target state="translated">内容将在介质的短边上成像,但方式与纵向相反。反向肖像的定义是将打印流页面从肖像方向相对于介质旋转180度成像。</target>
        </trans-unit>
        <trans-unit id="6852f939963698fc0410e778b02bf61dab00e768" translate="yes" xml:space="preserve">
          <source>The content will be imaged across the short edge of the medium.</source>
          <target state="translated">内容将在介质的短边上成像。</target>
        </trans-unit>
        <trans-unit id="bc28f755e5915277d2988d4a6013aea7ae1c7b98" translate="yes" xml:space="preserve">
          <source>The contents of &lt;code&gt;legalValues&lt;/code&gt; are copied, so subsequent modifications of the array referenced by &lt;code&gt;legalValues&lt;/code&gt; have no impact on this &lt;code&gt;OpenMBeanAttributeInfoSupport&lt;/code&gt; instance.</source>
          <target state="translated">的内容 &lt;code&gt;legalValues&lt;/code&gt; 来被复制，因此通过引用的数组的后续修改 &lt;code&gt;legalValues&lt;/code&gt; 来对此没有影响 &lt;code&gt;OpenMBeanAttributeInfoSupport&lt;/code&gt; 实例。</target>
        </trans-unit>
        <trans-unit id="1946580fff472131e18b708943cd99d690b0e519" translate="yes" xml:space="preserve">
          <source>The contents of &lt;code&gt;legalValues&lt;/code&gt; are copied, so subsequent modifications of the array referenced by &lt;code&gt;legalValues&lt;/code&gt; have no impact on this &lt;code&gt;OpenMBeanParameterInfoSupport&lt;/code&gt; instance.</source>
          <target state="translated">的内容 &lt;code&gt;legalValues&lt;/code&gt; 来被复制，因此通过引用的数组的后续修改 &lt;code&gt;legalValues&lt;/code&gt; 来对此没有影响 &lt;code&gt;OpenMBeanParameterInfoSupport&lt;/code&gt; 实例。</target>
        </trans-unit>
        <trans-unit id="c325ca178e48547f71dba766d1fb7d18b3def496" translate="yes" xml:space="preserve">
          <source>The contents of all files are valid (that is, public non-abstract subclasses of &lt;code&gt;ResourceBundle&lt;/code&gt; for the &quot;.class&quot; files, syntactically correct &quot;.properties&quot; files). The default locale is &lt;code&gt;Locale(&quot;en&quot;, &quot;GB&quot;)&lt;/code&gt;.</source>
          <target state="translated">所有文件的内容都是有效的（即，&amp;ldquo;。class&amp;rdquo;文件的 &lt;code&gt;ResourceBundle&lt;/code&gt; 的公共非抽象子类，从句法上来讲是正确的&amp;ldquo; .properties&amp;rdquo;文件）。默认语言环境是 &lt;code&gt;Locale(&quot;en&quot;, &quot;GB&quot;)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ebac3c238a1391d9c3c39bf23e530a85063ac59c" translate="yes" xml:space="preserve">
          <source>The contents of the &lt;code&gt;MBeanInfo&lt;/code&gt; for a Dynamic MBean are determined by its &lt;a href=&quot;dynamicmbean#getMBeanInfo--&quot;&gt;&lt;code&gt;getMBeanInfo()&lt;/code&gt;&lt;/a&gt; method. This includes Open MBeans and Model MBeans, which are kinds of Dynamic MBeans.</source>
          <target state="translated">动态MBean 的 &lt;code&gt;MBeanInfo&lt;/code&gt; 的内容由其&lt;a href=&quot;dynamicmbean#getMBeanInfo--&quot;&gt; &lt;code&gt;getMBeanInfo()&lt;/code&gt; &lt;/a&gt;方法确定。这包括Open MBean和Model MBean，它们是动态MBean。</target>
        </trans-unit>
        <trans-unit id="d848a8a7bfa54e24e5b7fcaf3feddaaa4c47c842" translate="yes" xml:space="preserve">
          <source>The contents of the &lt;code&gt;MBeanInfo&lt;/code&gt; for a Standard MBean are determined by the MBean server as follows:</source>
          <target state="translated">标准MBean 的 &lt;code&gt;MBeanInfo&lt;/code&gt; 的内容由MBean服务器确定，如下所示：</target>
        </trans-unit>
        <trans-unit id="b0b4c7cdb43c1b320218f1d15b6496c67a3847fe" translate="yes" xml:space="preserve">
          <source>The contents of the located files indicate the names of actual implementation classes which implement the aforementioned service provider interfaces; the default class loader is then used to load each of these classes and to instantiate an instance of each class, which is then placed into the registry for later retrieval.</source>
          <target state="translated">定位文件的内容表示实现上述服务提供者接口的实际实现类的名称;然后使用默认的类加载器加载这些类中的每一个,并实例化每个类的实例,然后将其放入注册表中,以便以后检索。</target>
        </trans-unit>
        <trans-unit id="388f439246bd0e7a4c23e29d7ee51483d463dcb8" translate="yes" xml:space="preserve">
          <source>The context class loader is used by system code and extensions when they need to lookup resources that might not exist in the system class loader. Granting enableContextClassLoaderOverride permission would allow a subclass of Thread to override the methods that are used to get or set the context class loader for a particular thread.</source>
          <target state="translated">当系统代码和扩展需要查找可能不存在于系统类加载器中的资源时,系统代码和扩展会使用上下文类加载器。授予enableContextClassLoaderOverride权限将允许Thread的子类覆盖用于获取或设置特定线程的上下文类加载器的方法。</target>
        </trans-unit>
        <trans-unit id="590a02352e6b07386297ba1df528c88dc41306dc" translate="yes" xml:space="preserve">
          <source>The context class loader is used by system code and extensions when they need to lookup resources that might not exist in the system class loader. Granting setContextClassLoader permission would allow code to change which context class loader is used for a particular thread, including system threads.</source>
          <target state="translated">当系统代码和扩展需要查找可能不存在于系统类加载器中的资源时,系统代码和扩展会使用上下文类加载器。授予setContextClassLoader权限将允许代码改变特定线程(包括系统线程)使用哪个上下文类加载器。</target>
        </trans-unit>
        <trans-unit id="5c382ea0f6e622d8b8b41c104555d098f7b132c4" translate="yes" xml:space="preserve">
          <source>The context in which the service has become available</source>
          <target state="translated">服务可用的环境</target>
        </trans-unit>
        <trans-unit id="7e89d3aadd2fc133242406bab583a28ade056edc" translate="yes" xml:space="preserve">
          <source>The context relative to which &lt;code&gt;altName&lt;/code&gt; is named. If null, then the default initial context is implied.</source>
          <target state="translated">相对于 &lt;code&gt;altName&lt;/code&gt; 命名的上下文。如果为null，则意味着默认的初始上下文。</target>
        </trans-unit>
        <trans-unit id="9ce2783e4e5dd5cbc5de3a3c2791fe493d1b5b93" translate="yes" xml:space="preserve">
          <source>The control character corresponding to</source>
          <target state="translated">对应的控制字符</target>
        </trans-unit>
        <trans-unit id="e74ab6fbf2fbd58d08490c2d7480131e843f9403" translate="yes" xml:space="preserve">
          <source>The control's ASN.1 BER encoded value.</source>
          <target state="translated">控制的 ASN.1 BER 编码值。</target>
        </trans-unit>
        <trans-unit id="10a80369bf3b0a07e4be4b96341c9aa03850a503" translate="yes" xml:space="preserve">
          <source>The control's criticality.</source>
          <target state="translated">控制的关键性。</target>
        </trans-unit>
        <trans-unit id="55775f89e5178f6ddda32a06da33c39badc6c01e" translate="yes" xml:space="preserve">
          <source>The control's object identifier string.</source>
          <target state="translated">控件的对象标识符字符串。</target>
        </trans-unit>
        <trans-unit id="5d6d978d47d58f71c7f1271ddd066ad095c8e7b6" translate="yes" xml:space="preserve">
          <source>The conversion</source>
          <target state="translated">转换</target>
        </trans-unit>
        <trans-unit id="270e247fd88eb7860b4d0a63df4b9c814a6bf3d7" translate="yes" xml:space="preserve">
          <source>The conversion creates an &lt;code&gt;Instant&lt;/code&gt; that represents the same point on the time-line as this &lt;code&gt;Calendar&lt;/code&gt;.</source>
          <target state="translated">转换将创建一个 &lt;code&gt;Instant&lt;/code&gt; ，该Instant表示与该 &lt;code&gt;Calendar&lt;/code&gt; 在时间轴上的同一点。</target>
        </trans-unit>
        <trans-unit id="efd60f8e9860e6d830f6fe82f385538e552bf494" translate="yes" xml:space="preserve">
          <source>The conversion creates an &lt;code&gt;Instant&lt;/code&gt; that represents the same point on the time-line as this &lt;code&gt;Date&lt;/code&gt;.</source>
          <target state="translated">转换将创建一个 &lt;code&gt;Instant&lt;/code&gt; ，该Instant表示与该 &lt;code&gt;Date&lt;/code&gt; 在时间轴上的同一点。</target>
        </trans-unit>
        <trans-unit id="54a6f4f7aad035dfcc7a40e216ebf648682262d6" translate="yes" xml:space="preserve">
          <source>The conversion creates an &lt;code&gt;Instant&lt;/code&gt; that represents the same point on the time-line as this &lt;code&gt;FileTime&lt;/code&gt;.</source>
          <target state="translated">转换将创建一个 &lt;code&gt;Instant&lt;/code&gt; ，该Instant表示与该 &lt;code&gt;FileTime&lt;/code&gt; 在时间轴上相同的点。</target>
        </trans-unit>
        <trans-unit id="0d9ef9299b2fb831504cc2147231f846f711cd03" translate="yes" xml:space="preserve">
          <source>The conversion does not correspond to any argument.</source>
          <target state="translated">转换不对应任何参数。</target>
        </trans-unit>
        <trans-unit id="12582e3813a1ad56415e3e99c5a9269b04638260" translate="yes" xml:space="preserve">
          <source>The conversion extracts and combines the &lt;code&gt;ChronoLocalDate&lt;/code&gt; and the &lt;code&gt;LocalTime&lt;/code&gt; from the temporal object. Implementations are permitted to perform optimizations such as accessing those fields that are equivalent to the relevant objects. The result uses this chronology.</source>
          <target state="translated">该转换从时间对象中提取并 &lt;code&gt;ChronoLocalDate&lt;/code&gt; 和 &lt;code&gt;LocalTime&lt;/code&gt; 。允许实现执行优化，例如访问等效于相关对象的那些字段。结果使用此年表。</target>
        </trans-unit>
        <trans-unit id="4b54547f5841ed450737930c04beb5ec751b5128" translate="yes" xml:space="preserve">
          <source>The conversion extracts and combines the &lt;code&gt;LocalDate&lt;/code&gt; and the &lt;code&gt;LocalTime&lt;/code&gt; from the temporal object. Implementations are permitted to perform optimizations such as accessing those fields that are equivalent to the relevant objects.</source>
          <target state="translated">该转换从时间对象中提取并 &lt;code&gt;LocalDate&lt;/code&gt; 和 &lt;code&gt;LocalTime&lt;/code&gt; 。允许实现执行优化，例如访问等效于相关对象的那些字段。</target>
        </trans-unit>
        <trans-unit id="70498ef0a69b6eab342c7fac47172341588c109c" translate="yes" xml:space="preserve">
          <source>The conversion extracts and combines the &lt;code&gt;ZoneOffset&lt;/code&gt; and the &lt;code&gt;LocalTime&lt;/code&gt; from the temporal object. Implementations are permitted to perform optimizations such as accessing those fields that are equivalent to the relevant objects.</source>
          <target state="translated">转换提取并组合所述 &lt;code&gt;ZoneOffset&lt;/code&gt; 和 &lt;code&gt;LocalTime&lt;/code&gt; 从时间对象。允许实现执行优化，例如访问等效于相关对象的那些字段。</target>
        </trans-unit>
        <trans-unit id="4b826735171361928b376c1342132346dd4ef147" translate="yes" xml:space="preserve">
          <source>The conversion extracts and combines the chronology and the date from the temporal object. The behavior is equivalent to using &lt;a href=&quot;chronology#date-java.time.temporal.TemporalAccessor-&quot;&gt;&lt;code&gt;Chronology.date(TemporalAccessor)&lt;/code&gt;&lt;/a&gt; with the extracted chronology. Implementations are permitted to perform optimizations such as accessing those fields that are equivalent to the relevant objects.</source>
          <target state="translated">转换从时间对象中提取和组合时间顺序和日期。该行为等效于将&lt;a href=&quot;chronology#date-java.time.temporal.TemporalAccessor-&quot;&gt; &lt;code&gt;Chronology.date(TemporalAccessor)&lt;/code&gt; &lt;/a&gt;与提取的年表一起使用。允许实现执行优化，例如访问等效于相关对象的那些字段。</target>
        </trans-unit>
        <trans-unit id="6b3b87af7f6d662b2b8b6d102b13718c4e5b2e3a" translate="yes" xml:space="preserve">
          <source>The conversion extracts and combines the chronology and the date-time from the temporal object. The behavior is equivalent to using &lt;a href=&quot;chronology#localDateTime-java.time.temporal.TemporalAccessor-&quot;&gt;&lt;code&gt;Chronology.localDateTime(TemporalAccessor)&lt;/code&gt;&lt;/a&gt; with the extracted chronology. Implementations are permitted to perform optimizations such as accessing those fields that are equivalent to the relevant objects.</source>
          <target state="translated">该转换从时间对象中提取并组合了时间顺序和日期时间。该行为等效于将&lt;a href=&quot;chronology#localDateTime-java.time.temporal.TemporalAccessor-&quot;&gt; &lt;code&gt;Chronology.localDateTime(TemporalAccessor)&lt;/code&gt; &lt;/a&gt;与提取的年表一起使用。允许实现执行优化，例如访问等效于相关对象的那些字段。</target>
        </trans-unit>
        <trans-unit id="bc0526ed650fd16edcc91d9d9d4f4c192d585a6f" translate="yes" xml:space="preserve">
          <source>The conversion extracts and combines the chronology, date, time and zone from the temporal object. The behavior is equivalent to using &lt;a href=&quot;chronology#zonedDateTime-java.time.temporal.TemporalAccessor-&quot;&gt;&lt;code&gt;Chronology.zonedDateTime(TemporalAccessor)&lt;/code&gt;&lt;/a&gt; with the extracted chronology. Implementations are permitted to perform optimizations such as accessing those fields that are equivalent to the relevant objects.</source>
          <target state="translated">转换从时间对象中提取并组合时间顺序，日期，时间和区域。该行为等效于将&lt;a href=&quot;chronology#zonedDateTime-java.time.temporal.TemporalAccessor-&quot;&gt; &lt;code&gt;Chronology.zonedDateTime(TemporalAccessor)&lt;/code&gt; &lt;/a&gt;与提取的年表一起使用。允许实现执行优化，例如访问等效于相关对象的那些字段。</target>
        </trans-unit>
        <trans-unit id="d1d03bf26e9a6cb1c5b95c5f95bbe5b5411246d5" translate="yes" xml:space="preserve">
          <source>The conversion extracts the &lt;a href=&quot;temporal/chronofield#DAY_OF_WEEK&quot;&gt;&lt;code&gt;DAY_OF_WEEK&lt;/code&gt;&lt;/a&gt; field.</source>
          <target state="translated">转换提取&lt;a href=&quot;temporal/chronofield#DAY_OF_WEEK&quot;&gt; &lt;code&gt;DAY_OF_WEEK&lt;/code&gt; &lt;/a&gt;字段。</target>
        </trans-unit>
        <trans-unit id="fa783f0d9bec9cbce0330f54aae9cb879d9ade79" translate="yes" xml:space="preserve">
          <source>The conversion extracts the &lt;a href=&quot;temporal/chronofield#INSTANT_SECONDS&quot;&gt;&lt;code&gt;INSTANT_SECONDS&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;temporal/chronofield#NANO_OF_SECOND&quot;&gt;&lt;code&gt;NANO_OF_SECOND&lt;/code&gt;&lt;/a&gt; fields.</source>
          <target state="translated">该转换提取&lt;a href=&quot;temporal/chronofield#INSTANT_SECONDS&quot;&gt; &lt;code&gt;INSTANT_SECONDS&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;temporal/chronofield#NANO_OF_SECOND&quot;&gt; &lt;code&gt;NANO_OF_SECOND&lt;/code&gt; &lt;/a&gt;字段。</target>
        </trans-unit>
        <trans-unit id="0b804266d47675c8fff80578d89c9217652722e5" translate="yes" xml:space="preserve">
          <source>The conversion extracts the &lt;a href=&quot;temporal/chronofield#MONTH_OF_YEAR&quot;&gt;&lt;code&gt;MONTH_OF_YEAR&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;temporal/chronofield#DAY_OF_MONTH&quot;&gt;&lt;code&gt;DAY_OF_MONTH&lt;/code&gt;&lt;/a&gt; fields. The extraction is only permitted if the temporal object has an ISO chronology, or can be converted to a &lt;code&gt;LocalDate&lt;/code&gt;.</source>
          <target state="translated">转换提取&lt;a href=&quot;temporal/chronofield#MONTH_OF_YEAR&quot;&gt; &lt;code&gt;MONTH_OF_YEAR&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;temporal/chronofield#DAY_OF_MONTH&quot;&gt; &lt;code&gt;DAY_OF_MONTH&lt;/code&gt; &lt;/a&gt;字段。仅当时间对象具有ISO时序，或者可以将其转换为 &lt;code&gt;LocalDate&lt;/code&gt; 时，才允许提取。</target>
        </trans-unit>
        <trans-unit id="81623a2ca823b67f80d520c5c052168f4c759622" translate="yes" xml:space="preserve">
          <source>The conversion extracts the &lt;a href=&quot;temporal/chronofield#MONTH_OF_YEAR&quot;&gt;&lt;code&gt;MONTH_OF_YEAR&lt;/code&gt;&lt;/a&gt; field. The extraction is only permitted if the temporal object has an ISO chronology, or can be converted to a &lt;code&gt;LocalDate&lt;/code&gt;.</source>
          <target state="translated">转换提取&lt;a href=&quot;temporal/chronofield#MONTH_OF_YEAR&quot;&gt; &lt;code&gt;MONTH_OF_YEAR&lt;/code&gt; &lt;/a&gt;字段。仅当时间对象具有ISO时序，或者可以将其转换为 &lt;code&gt;LocalDate&lt;/code&gt; 时，才允许提取。</target>
        </trans-unit>
        <trans-unit id="9820f4411a835c958ac7328575c291589f31326f" translate="yes" xml:space="preserve">
          <source>The conversion extracts the &lt;a href=&quot;temporal/chronofield#YEAR&quot;&gt;&lt;code&gt;YEAR&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;temporal/chronofield#MONTH_OF_YEAR&quot;&gt;&lt;code&gt;MONTH_OF_YEAR&lt;/code&gt;&lt;/a&gt; fields. The extraction is only permitted if the temporal object has an ISO chronology, or can be converted to a &lt;code&gt;LocalDate&lt;/code&gt;.</source>
          <target state="translated">该转换提取&lt;a href=&quot;temporal/chronofield#YEAR&quot;&gt; &lt;code&gt;YEAR&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;temporal/chronofield#MONTH_OF_YEAR&quot;&gt; &lt;code&gt;MONTH_OF_YEAR&lt;/code&gt; &lt;/a&gt;字段。仅当时间对象具有ISO时序，或者可以将其转换为 &lt;code&gt;LocalDate&lt;/code&gt; 时，才允许提取。</target>
        </trans-unit>
        <trans-unit id="41faf7243bccfcf6675028684c04068be4e78524" translate="yes" xml:space="preserve">
          <source>The conversion extracts the &lt;a href=&quot;temporal/chronofield#YEAR&quot;&gt;&lt;code&gt;year&lt;/code&gt;&lt;/a&gt; field. The extraction is only permitted if the temporal object has an ISO chronology, or can be converted to a &lt;code&gt;LocalDate&lt;/code&gt;.</source>
          <target state="translated">转换提取&lt;a href=&quot;temporal/chronofield#YEAR&quot;&gt; &lt;code&gt;year&lt;/code&gt; &lt;/a&gt;字段。仅当时间对象具有ISO时序，或者可以将其转换为 &lt;code&gt;LocalDate&lt;/code&gt; 时，才允许提取。</target>
        </trans-unit>
        <trans-unit id="6499ccce5fd40cb40838d7075f78094ebeb01d21" translate="yes" xml:space="preserve">
          <source>The conversion loops around the set of units from the amount and uses the &lt;a href=&quot;temporal/chronounit#YEARS&quot;&gt;&lt;code&gt;YEARS&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;temporal/chronounit#MONTHS&quot;&gt;&lt;code&gt;MONTHS&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;temporal/chronounit#DAYS&quot;&gt;&lt;code&gt;DAYS&lt;/code&gt;&lt;/a&gt; units to create a period. If any other units are found then an exception is thrown.</source>
          <target state="translated">转换以金额为单位循环，并使用&lt;a href=&quot;temporal/chronounit#YEARS&quot;&gt; &lt;code&gt;YEARS&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;temporal/chronounit#MONTHS&quot;&gt; &lt;code&gt;MONTHS&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;temporal/chronounit#DAYS&quot;&gt; &lt;code&gt;DAYS&lt;/code&gt; &lt;/a&gt;单位创建期间。如果找到任何其他单位，则会引发异常。</target>
        </trans-unit>
        <trans-unit id="d2027683d68cc5bd618e3f017b9f0057b1248599" translate="yes" xml:space="preserve">
          <source>The conversion loops around the set of units from the amount and uses the &lt;a href=&quot;temporal/temporalunit#getDuration--&quot;&gt;duration&lt;/a&gt; of the unit to calculate the total &lt;code&gt;Duration&lt;/code&gt;. Only a subset of units are accepted by this method. The unit must either have an &lt;a href=&quot;temporal/temporalunit#isDurationEstimated--&quot;&gt;exact duration&lt;/a&gt; or be &lt;a href=&quot;temporal/chronounit#DAYS&quot;&gt;&lt;code&gt;ChronoUnit.DAYS&lt;/code&gt;&lt;/a&gt; which is treated as 24 hours. If any other units are found then an exception is thrown.</source>
          <target state="translated">转换从金额中循环出一组单位，并使用单位的&lt;a href=&quot;temporal/temporalunit#getDuration--&quot;&gt;持续时间&lt;/a&gt;来计算总 &lt;code&gt;Duration&lt;/code&gt; 。此方法仅接受单位子集。该单位必须具有&lt;a href=&quot;temporal/temporalunit#isDurationEstimated--&quot;&gt;确切的持续时间&lt;/a&gt;或为&lt;a href=&quot;temporal/chronounit#DAYS&quot;&gt; &lt;code&gt;ChronoUnit.DAYS&lt;/code&gt; &lt;/a&gt;（被视为24小时）。如果找到任何其他单位，则会引发异常。</target>
        </trans-unit>
        <trans-unit id="adb8598ff9c8ce94abf829e4e923229b7296bb69" translate="yes" xml:space="preserve">
          <source>The conversion of a pathname string to or from an abstract pathname is inherently system-dependent. When an abstract pathname is converted into a pathname string, each name is separated from the next by a single copy of the default &lt;em&gt;separator character&lt;/em&gt;. The default name-separator character is defined by the system property &lt;code&gt;file.separator&lt;/code&gt;, and is made available in the public static fields &lt;code&gt;&lt;a href=&quot;file#separator&quot;&gt;&lt;code&gt;separator&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;file#separatorChar&quot;&gt;&lt;code&gt;separatorChar&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; of this class. When a pathname string is converted into an abstract pathname, the names within it may be separated by the default name-separator character or by any other name-separator character that is supported by the underlying system.</source>
          <target state="translated">路径名字符串与抽象路径名之间的转换本质上取决于系统。将抽象路径名转换为路径名字符串时，每个名称都由默认&lt;em&gt;分隔符&lt;/em&gt;的单个副本与下一个&lt;em&gt;分隔&lt;/em&gt;。默认名称分隔符由系统属性定义 &lt;code&gt;file.separator&lt;/code&gt; ，并在公共静态字段是提供 &lt;code&gt;&lt;a href=&quot;file#separator&quot;&gt;&lt;code&gt;separator&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;file#separatorChar&quot;&gt;&lt;code&gt;separatorChar&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; 这个类的。将路径名字符串转换为抽象路径名时，其中的名称可以用默认名称分隔符或底层系统支持的任何其他名称分隔符分隔。</target>
        </trans-unit>
        <trans-unit id="0f9ba598909cafcafc84e677c238200abf9bf623" translate="yes" xml:space="preserve">
          <source>The conversion process is the reverse of that used by the URLEncoder class. It is assumed that all characters in the encoded string are one of the following: &quot;&lt;code&gt;a&lt;/code&gt;&quot; through &quot;&lt;code&gt;z&lt;/code&gt;&quot;, &quot;&lt;code&gt;A&lt;/code&gt;&quot; through &quot;&lt;code&gt;Z&lt;/code&gt;&quot;, &quot;&lt;code&gt;0&lt;/code&gt;&quot; through &quot;&lt;code&gt;9&lt;/code&gt;&quot;, and &quot;&lt;code&gt;-&lt;/code&gt;&quot;, &quot;&lt;code&gt;_&lt;/code&gt;&quot;, &quot;&lt;code&gt;.&lt;/code&gt;&quot;, and &quot;&lt;code&gt;*&lt;/code&gt;&quot;. The character &quot;&lt;code&gt;%&lt;/code&gt;&quot; is allowed but is interpreted as the start of a special escaped sequence.</source>
          <target state="translated">转换过程与URLEncoder类所使用的过程相反。假定编码字符串中的所有字符均为以下字符之一：&amp;ldquo; &lt;code&gt;a&lt;/code&gt; &amp;rdquo;至&amp;ldquo; &lt;code&gt;z&lt;/code&gt; &amp;rdquo;，&amp;ldquo; &lt;code&gt;A&lt;/code&gt; &amp;rdquo;至&amp;ldquo; &lt;code&gt;Z&lt;/code&gt; &amp;rdquo;，&amp;ldquo; &lt;code&gt;0&lt;/code&gt; &amp;rdquo;至&amp;ldquo; &lt;code&gt;9&lt;/code&gt; &amp;rdquo;以及&amp;ldquo; &lt;code&gt;-&lt;/code&gt; &amp;rdquo;，&amp;ldquo; &lt;code&gt;_&lt;/code&gt; &amp;rdquo;，&amp;ldquo; &lt;code&gt;.&lt;/code&gt; 和&amp;ldquo; &lt;code&gt;*&lt;/code&gt; &amp;rdquo;。允许使用字符&amp;ldquo; &lt;code&gt;%&lt;/code&gt; &amp;rdquo;，但将其解释为特殊转义序列的开始。</target>
        </trans-unit>
        <trans-unit id="fb1ff74c5aed55df321b5f69eb36786f520db7dc" translate="yes" xml:space="preserve">
          <source>The conversion typically uses the &lt;a href=&quot;../temporal/chronofield#EPOCH_DAY&quot;&gt;&lt;code&gt;EPOCH_DAY&lt;/code&gt;&lt;/a&gt; field, which is standardized across calendar systems.</source>
          <target state="translated">转换通常使用跨日历系统标准化的&lt;a href=&quot;../temporal/chronofield#EPOCH_DAY&quot;&gt; &lt;code&gt;EPOCH_DAY&lt;/code&gt; &lt;/a&gt;字段。</target>
        </trans-unit>
        <trans-unit id="cbfdcd807f9acab66a49b1ca8f9b0af23d70ee42" translate="yes" xml:space="preserve">
          <source>The conversion uses the &lt;a href=&quot;temporal/temporalqueries#localDate--&quot;&gt;&lt;code&gt;TemporalQueries.localDate()&lt;/code&gt;&lt;/a&gt; query, which relies on extracting the &lt;a href=&quot;temporal/chronofield#EPOCH_DAY&quot;&gt;&lt;code&gt;EPOCH_DAY&lt;/code&gt;&lt;/a&gt; field.</source>
          <target state="translated">转换使用&lt;a href=&quot;temporal/temporalqueries#localDate--&quot;&gt; &lt;code&gt;TemporalQueries.localDate()&lt;/code&gt; &lt;/a&gt;查询，该查询依赖于提取&lt;a href=&quot;temporal/chronofield#EPOCH_DAY&quot;&gt; &lt;code&gt;EPOCH_DAY&lt;/code&gt; &lt;/a&gt;字段。</target>
        </trans-unit>
        <trans-unit id="dbddf0561d8a6eecdccec00ea1f9dc5a0286620b" translate="yes" xml:space="preserve">
          <source>The conversion uses the &lt;a href=&quot;temporal/temporalqueries#localTime--&quot;&gt;&lt;code&gt;TemporalQueries.localTime()&lt;/code&gt;&lt;/a&gt; query, which relies on extracting the &lt;a href=&quot;temporal/chronofield#NANO_OF_DAY&quot;&gt;&lt;code&gt;NANO_OF_DAY&lt;/code&gt;&lt;/a&gt; field.</source>
          <target state="translated">转换使用&lt;a href=&quot;temporal/temporalqueries#localTime--&quot;&gt; &lt;code&gt;TemporalQueries.localTime()&lt;/code&gt; &lt;/a&gt;查询，该查询依赖于提取&lt;a href=&quot;temporal/chronofield#NANO_OF_DAY&quot;&gt; &lt;code&gt;NANO_OF_DAY&lt;/code&gt; &lt;/a&gt;字段。</target>
        </trans-unit>
        <trans-unit id="3ab0f44ea5fc468726fdc2960c4ee1963521f34d" translate="yes" xml:space="preserve">
          <source>The conversion uses the &lt;a href=&quot;temporal/temporalqueries#offset--&quot;&gt;&lt;code&gt;TemporalQueries.offset()&lt;/code&gt;&lt;/a&gt; query, which relies on extracting the &lt;a href=&quot;temporal/chronofield#OFFSET_SECONDS&quot;&gt;&lt;code&gt;OFFSET_SECONDS&lt;/code&gt;&lt;/a&gt; field.</source>
          <target state="translated">该转换使用&lt;a href=&quot;temporal/temporalqueries#offset--&quot;&gt; &lt;code&gt;TemporalQueries.offset()&lt;/code&gt; &lt;/a&gt;查询，该查询依赖于提取&lt;a href=&quot;temporal/chronofield#OFFSET_SECONDS&quot;&gt; &lt;code&gt;OFFSET_SECONDS&lt;/code&gt; &lt;/a&gt;字段。</target>
        </trans-unit>
        <trans-unit id="b208e5c531e20f8176aafb88407764919d7c63ff" translate="yes" xml:space="preserve">
          <source>The conversion will first obtain a &lt;code&gt;ZoneId&lt;/code&gt; from the temporal object, falling back to a &lt;code&gt;ZoneOffset&lt;/code&gt; if necessary. It will then try to obtain an &lt;code&gt;Instant&lt;/code&gt;, falling back to a &lt;code&gt;ChronoLocalDateTime&lt;/code&gt; if necessary. The result will be either the combination of &lt;code&gt;ZoneId&lt;/code&gt; or &lt;code&gt;ZoneOffset&lt;/code&gt; with &lt;code&gt;Instant&lt;/code&gt; or &lt;code&gt;ChronoLocalDateTime&lt;/code&gt;. Implementations are permitted to perform optimizations such as accessing those fields that are equivalent to the relevant objects. The result uses this chronology.</source>
          <target state="translated">转换将首先从时态对象中获取 &lt;code&gt;ZoneId&lt;/code&gt; ， &lt;code&gt;ZoneOffset&lt;/code&gt; 在必要时回退到ZoneOffset。然后，它将在必要时尝试获取 &lt;code&gt;Instant&lt;/code&gt; ，并返回 &lt;code&gt;ChronoLocalDateTime&lt;/code&gt; 。结果将是 &lt;code&gt;ZoneId&lt;/code&gt; 或 &lt;code&gt;ZoneOffset&lt;/code&gt; 与 &lt;code&gt;Instant&lt;/code&gt; 或 &lt;code&gt;ChronoLocalDateTime&lt;/code&gt; 的组合。允许实现执行优化，例如访问等效于相关对象的那些字段。结果使用此年表。</target>
        </trans-unit>
        <trans-unit id="571d73d0d2e70c92b228d6825ccb709402d177e7" translate="yes" xml:space="preserve">
          <source>The conversion will first obtain a &lt;code&gt;ZoneId&lt;/code&gt; from the temporal object, falling back to a &lt;code&gt;ZoneOffset&lt;/code&gt; if necessary. It will then try to obtain an &lt;code&gt;Instant&lt;/code&gt;, falling back to a &lt;code&gt;LocalDateTime&lt;/code&gt; if necessary. The result will be either the combination of &lt;code&gt;ZoneId&lt;/code&gt; or &lt;code&gt;ZoneOffset&lt;/code&gt; with &lt;code&gt;Instant&lt;/code&gt; or &lt;code&gt;LocalDateTime&lt;/code&gt;. Implementations are permitted to perform optimizations such as accessing those fields that are equivalent to the relevant objects.</source>
          <target state="translated">转换将首先从时态对象中获取 &lt;code&gt;ZoneId&lt;/code&gt; ， &lt;code&gt;ZoneOffset&lt;/code&gt; 在必要时回退到ZoneOffset。然后，如果有必要，它将尝试获取 &lt;code&gt;Instant&lt;/code&gt; ，并返回到 &lt;code&gt;LocalDateTime&lt;/code&gt; 。结果将是 &lt;code&gt;ZoneId&lt;/code&gt; 或 &lt;code&gt;ZoneOffset&lt;/code&gt; 与 &lt;code&gt;Instant&lt;/code&gt; 或 &lt;code&gt;LocalDateTime&lt;/code&gt; 的组合。允许实现执行优化，例如访问等效于相关对象的那些字段。</target>
        </trans-unit>
        <trans-unit id="a4e422bfc9d1ec4b2959561dc366330dfb858376" translate="yes" xml:space="preserve">
          <source>The conversion will first obtain a &lt;code&gt;ZoneOffset&lt;/code&gt; from the temporal object. It will then try to obtain a &lt;code&gt;LocalDateTime&lt;/code&gt;, falling back to an &lt;code&gt;Instant&lt;/code&gt; if necessary. The result will be the combination of &lt;code&gt;ZoneOffset&lt;/code&gt; with either with &lt;code&gt;LocalDateTime&lt;/code&gt; or &lt;code&gt;Instant&lt;/code&gt;. Implementations are permitted to perform optimizations such as accessing those fields that are equivalent to the relevant objects.</source>
          <target state="translated">转换将首先从时态对象获得 &lt;code&gt;ZoneOffset&lt;/code&gt; 。然后它将尝试获取 &lt;code&gt;LocalDateTime&lt;/code&gt; ，并在必要时返回 &lt;code&gt;Instant&lt;/code&gt; 。结果将是 &lt;code&gt;ZoneOffset&lt;/code&gt; 与 &lt;code&gt;LocalDateTime&lt;/code&gt; 或 &lt;code&gt;Instant&lt;/code&gt; 的组合。允许实现执行优化，例如访问等效于相关对象的那些字段。</target>
        </trans-unit>
        <trans-unit id="6956bf86f5d6bf1d33c22f2f54c601f1ab0adbc0" translate="yes" xml:space="preserve">
          <source>The conversion will obtain the chronology using &lt;a href=&quot;../temporal/temporalqueries#chronology--&quot;&gt;&lt;code&gt;TemporalQueries.chronology()&lt;/code&gt;&lt;/a&gt;. If the specified temporal object does not have a chronology, &lt;a href=&quot;isochronology&quot;&gt;&lt;code&gt;IsoChronology&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">转换将使用&lt;a href=&quot;../temporal/temporalqueries#chronology--&quot;&gt; &lt;code&gt;TemporalQueries.chronology()&lt;/code&gt; &lt;/a&gt;获得年代。如果指定的时间对象不具有年代，则返回&lt;a href=&quot;isochronology&quot;&gt; &lt;code&gt;IsoChronology&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fc6ad7ff706fd21e39acd2de086b03b0801af3a8" translate="yes" xml:space="preserve">
          <source>The conversion will try to obtain the zone in a way that favours region-based zones over offset-based zones using &lt;a href=&quot;temporal/temporalqueries#zone--&quot;&gt;&lt;code&gt;TemporalQueries.zone()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">转换将尝试使用&lt;a href=&quot;temporal/temporalqueries#zone--&quot;&gt; &lt;code&gt;TemporalQueries.zone()&lt;/code&gt; &lt;/a&gt;来偏爱基于区域的区域而不是基于偏移量的区域。</target>
        </trans-unit>
        <trans-unit id="047a76b73af3eddf4a664a5aabf56f3f19a4cb48" translate="yes" xml:space="preserve">
          <source>The cookie is visible to all the pages in the directory you specify, and all the pages in that directory's subdirectories. A cookie's path must include the servlet that set the cookie, for example,</source>
          <target state="translated">该cookie对你指定的目录中的所有页面,以及该目录的子目录中的所有页面都是可见的。cookie的路径必须包括设置cookie的servlet,例如。</target>
        </trans-unit>
        <trans-unit id="67cce5ff929f9bdadcc685d8ff1ecd96493940f0" translate="yes" xml:space="preserve">
          <source>The corresponding &lt;code&gt;Bindings&lt;/code&gt;.</source>
          <target state="translated">相应的 &lt;code&gt;Bindings&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b70155a38b4df111e6e3074a162bafc1ae94748e" translate="yes" xml:space="preserve">
          <source>The corresponding Open Type, &lt;em&gt;opentype(J)&lt;/em&gt;. This is an instance of a subclass of &lt;a href=&quot;openmbean/opentype&quot;&gt;&lt;code&gt;OpenType&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">相应的Open Type，&lt;em&gt;opentype（J）&lt;/em&gt;。这是&lt;a href=&quot;openmbean/opentype&quot;&gt; &lt;code&gt;OpenType&lt;/code&gt; &lt;/a&gt;子类的实例。</target>
        </trans-unit>
        <trans-unit id="0c40dcf63722a8c192ee371c1356c058acb3b36f" translate="yes" xml:space="preserve">
          <source>The corresponding method in &lt;code&gt;ObjectInputStream&lt;/code&gt; is &lt;code&gt;resolveProxyClass&lt;/code&gt;. For a given subclass of &lt;code&gt;ObjectOutputStream&lt;/code&gt; that overrides this method, the &lt;code&gt;resolveProxyClass&lt;/code&gt; method in the corresponding subclass of &lt;code&gt;ObjectInputStream&lt;/code&gt; must read any data or objects written by &lt;code&gt;annotateProxyClass&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ObjectInputStream&lt;/code&gt; 中的相应方法是 &lt;code&gt;resolveProxyClass&lt;/code&gt; 。对于覆盖此方法的 &lt;code&gt;ObjectOutputStream&lt;/code&gt; 的给定子类， &lt;code&gt;ObjectInputStream&lt;/code&gt; 的相应子类中的 &lt;code&gt;resolveProxyClass&lt;/code&gt; 方法必须读取 &lt;code&gt;annotateProxyClass&lt;/code&gt; 写入的任何数据或对象。</target>
        </trans-unit>
        <trans-unit id="c30c5d8c1a677f64708a87d05ecef9aaa2803beb" translate="yes" xml:space="preserve">
          <source>The corresponding method in &lt;code&gt;ObjectOutputStream&lt;/code&gt; is &lt;code&gt;annotateClass&lt;/code&gt;. This method will be invoked only once for each unique class in the stream. This method can be implemented by subclasses to use an alternate loading mechanism but must return a &lt;code&gt;Class&lt;/code&gt; object. Once returned, if the class is not an array class, its serialVersionUID is compared to the serialVersionUID of the serialized class, and if there is a mismatch, the deserialization fails and an &lt;a href=&quot;invalidclassexception&quot;&gt;&lt;code&gt;InvalidClassException&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">&lt;code&gt;ObjectOutputStream&lt;/code&gt; 中的对应方法是 &lt;code&gt;annotateClass&lt;/code&gt; 。对于流中的每个唯一类，该方法将仅被调用一次。该方法可以由子类实现以使用备用加载机制，但必须返回 &lt;code&gt;Class&lt;/code&gt; 对象。一旦返回，如果该类不是数组类，则将其serialVersionUID与序列化类的serialVersionUID进行比较；如果不匹配，则反序列化将失败，并&lt;a href=&quot;invalidclassexception&quot;&gt; &lt;code&gt;InvalidClassException&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3ac5720f125cacb45fafbd1b321034291ac3311a" translate="yes" xml:space="preserve">
          <source>The corresponding method in &lt;code&gt;ObjectOutputStream&lt;/code&gt; is &lt;code&gt;annotateProxyClass&lt;/code&gt;. For a given subclass of &lt;code&gt;ObjectInputStream&lt;/code&gt; that overrides this method, the &lt;code&gt;annotateProxyClass&lt;/code&gt; method in the corresponding subclass of &lt;code&gt;ObjectOutputStream&lt;/code&gt; must write any data or objects read by this method.</source>
          <target state="translated">&lt;code&gt;ObjectOutputStream&lt;/code&gt; 中的相应方法是 &lt;code&gt;annotateProxyClass&lt;/code&gt; 。对于重写此方法的给定 &lt;code&gt;ObjectInputStream&lt;/code&gt; 子类， &lt;code&gt;ObjectOutputStream&lt;/code&gt; 相应子类中的 &lt;code&gt;annotateProxyClass&lt;/code&gt; 方法必须写入此方法读取的任何数据或对象。</target>
        </trans-unit>
        <trans-unit id="0abe9c5fa30d544cee3d19e6e84e698aa8e83f99" translate="yes" xml:space="preserve">
          <source>The count must be at least 1.</source>
          <target state="translated">数目必须至少为1。</target>
        </trans-unit>
        <trans-unit id="69acc6af217f96bcdf2f4de94a0523e36827c529" translate="yes" xml:space="preserve">
          <source>The count of pattern letters determine the format. See &lt;a href=&quot;datetimeformatter#patterns&quot;&gt;DateTimeFormatter&lt;/a&gt; for a user-focused description of the patterns. The following tables define how the pattern letters map to the builder.</source>
          <target state="translated">图案字母的数量决定格式。有关以用户为中心的模式说明，请参见&lt;a href=&quot;datetimeformatter#patterns&quot;&gt;DateTimeFormatter&lt;/a&gt;。下表定义了模式字母如何映射到构建器。</target>
        </trans-unit>
        <trans-unit id="fb5876d2502a179b75086c84bac845b92d02e1cc" translate="yes" xml:space="preserve">
          <source>The count of pattern letters determines the format.</source>
          <target state="translated">模式字母的数量决定了格式。</target>
        </trans-unit>
        <trans-unit id="0f4c68175b99dff8a42643f2632dfba5adfcaeeb" translate="yes" xml:space="preserve">
          <source>The count reaches zero due to invocations of the &lt;a href=&quot;countdownlatch#countDown--&quot;&gt;&lt;code&gt;countDown()&lt;/code&gt;&lt;/a&gt; method; or</source>
          <target state="translated">由于&lt;a href=&quot;countdownlatch#countDown--&quot;&gt; &lt;code&gt;countDown()&lt;/code&gt; &lt;/a&gt;方法的调用，计数达到零。要么</target>
        </trans-unit>
        <trans-unit id="e4087c27faf9f64f3d727250d7f786fc190aa5fd" translate="yes" xml:space="preserve">
          <source>The country value in the &lt;code&gt;Locale&lt;/code&gt; created by the &lt;code&gt;Builder&lt;/code&gt; is always normalized to upper case.</source>
          <target state="translated">由 &lt;code&gt;Builder&lt;/code&gt; 创建的 &lt;code&gt;Locale&lt;/code&gt; 的国家/地区值始终标准化为大写。</target>
        </trans-unit>
        <trans-unit id="9202768045feae2a7883c716972bbd4862e06c8f" translate="yes" xml:space="preserve">
          <source>The country/region code, or the empty string if none is defined.</source>
          <target state="translated">国家/区域代码,如果没有定义,则为空字符串。</target>
        </trans-unit>
        <trans-unit id="66e77c53bc1dd645c582b4b8aa762d175e4a06eb" translate="yes" xml:space="preserve">
          <source>The created &lt;code&gt;Spliterator&lt;/code&gt; additionally reports &lt;a href=&quot;spliterator#SIZED&quot;&gt;&lt;code&gt;Spliterator.SIZED&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">创建的 &lt;code&gt;Spliterator&lt;/code&gt; 还会报告&lt;a href=&quot;spliterator#SIZED&quot;&gt; &lt;code&gt;Spliterator.SIZED&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3451a12989e9215713f45711d9e6be0a3b84602a" translate="yes" xml:space="preserve">
          <source>The created &lt;code&gt;Spliterator&lt;/code&gt; additionally reports &lt;a href=&quot;spliterator#SUBSIZED&quot;&gt;&lt;code&gt;Spliterator.SUBSIZED&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">创建的 &lt;code&gt;Spliterator&lt;/code&gt; 还会报告&lt;a href=&quot;spliterator#SUBSIZED&quot;&gt; &lt;code&gt;Spliterator.SUBSIZED&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="90f5fcb7852a2398a51db098b96f0e8d95c7c56a" translate="yes" xml:space="preserve">
          <source>The created &lt;code&gt;Spliterator&lt;/code&gt; reports &lt;a href=&quot;spliterator#SIZED&quot;&gt;&lt;code&gt;Spliterator.SIZED&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">创建的 &lt;code&gt;Spliterator&lt;/code&gt; 报告&lt;a href=&quot;spliterator#SIZED&quot;&gt; &lt;code&gt;Spliterator.SIZED&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="690bf7556ab8654b5fd1284d20114a7176fdd25f" translate="yes" xml:space="preserve">
          <source>The creation of the channel should specify the &lt;a href=&quot;../../net/protocolfamily&quot;&gt;&lt;code&gt;ProtocolFamily&lt;/code&gt;&lt;/a&gt; that corresponds to the address type of the multicast groups that the channel will join. There is no guarantee that a channel to a socket in one protocol family can join and receive multicast datagrams when the address of the multicast group corresponds to another protocol family. For example, it is implementation specific if a channel to an &lt;a href=&quot;../../net/standardprotocolfamily#INET6&quot;&gt;&lt;code&gt;IPv6&lt;/code&gt;&lt;/a&gt; socket can join an &lt;a href=&quot;../../net/standardprotocolfamily#INET&quot;&gt;&lt;code&gt;IPv4&lt;/code&gt;&lt;/a&gt; multicast group and receive multicast datagrams sent to the group.</source>
          <target state="translated">通道的创建应指定与该通道将加入的多播组的地址类型相对应的&lt;a href=&quot;../../net/protocolfamily&quot;&gt; &lt;code&gt;ProtocolFamily&lt;/code&gt; &lt;/a&gt;。当多播组的地址对应于另一个协议族时，不能保证一个协议族中套接字的通道可以加入和接收多播数据报。例如，到&lt;a href=&quot;../../net/standardprotocolfamily#INET6&quot;&gt; &lt;code&gt;IPv6&lt;/code&gt; &lt;/a&gt;套接字的通道是否可以加入&lt;a href=&quot;../../net/standardprotocolfamily#INET&quot;&gt; &lt;code&gt;IPv4&lt;/code&gt; &lt;/a&gt;多播组并接收发送到该组的多播数据报，是特定于实现的。</target>
        </trans-unit>
        <trans-unit id="f42aa3178f37922aa46485101a1f963f93b83d8e" translate="yes" xml:space="preserve">
          <source>The creation time is from the extended timestamp fields of entry's &lt;code&gt;optional extra data&lt;/code&gt; when read from a ZIP file or ZIP file formatted stream.</source>
          <target state="translated">当从ZIP文件或ZIP文件格式的流中读取时，创建时间来自条目的 &lt;code&gt;optional extra data&lt;/code&gt; 的扩展时间戳字段。</target>
        </trans-unit>
        <trans-unit id="76b2b21e25b895ed5e224699e62899bac9537aa3" translate="yes" xml:space="preserve">
          <source>The cryptographic parameters used by the sealing Cipher, encoded in the default format.</source>
          <target state="translated">密封密码使用的加密参数,以默认格式编码。</target>
        </trans-unit>
        <trans-unit id="a420c5b7dc176e9c8376b29f3b99362d7409dae9" translate="yes" xml:space="preserve">
          <source>The cryptographic service name must not contain any dots.</source>
          <target state="translated">加密服务名称不得包含任何点。</target>
        </trans-unit>
        <trans-unit id="5fac18c065a17ba110664a833562fea825e207c5" translate="yes" xml:space="preserve">
          <source>The cryptographic service name must not contain any dots. There must be one or more space characters between the</source>
          <target state="translated">加密服务名称不得包含任何点。符号之间必须有一个或多个空格字符。</target>
        </trans-unit>
        <trans-unit id="f9ff403eaee48d46144b5af3402e6cddd71fa7cb" translate="yes" xml:space="preserve">
          <source>The current &lt;code&gt;Locale&lt;/code&gt; to be used for localization, or &lt;code&gt;null&lt;/code&gt; if none has been set.</source>
          <target state="translated">用于本地化的当前 &lt;code&gt;Locale&lt;/code&gt; 如果未设置，则为 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="19f45a48f0f52abbe57d28861906d21a733ea0ea" translate="yes" xml:space="preserve">
          <source>The current &lt;code&gt;Locale&lt;/code&gt; to be used for localization, or &lt;code&gt;null&lt;/code&gt; if none has been set. By default it is initialized to &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">用于本地化的当前 &lt;code&gt;Locale&lt;/code&gt; 如果未设置，则为 &lt;code&gt;null&lt;/code&gt; 。默认情况下，它初始化为 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9afbc55d0f58a4928c1ac93362ed95025cad363f" translate="yes" xml:space="preserve">
          <source>The current MIDI volume level for the voice. The value ranges from 0 to 127 if the voice is active, and is unspecified if the voice is inactive.</source>
          <target state="translated">语音的当前MIDI音量。如果声音处于活动状态,该值的范围是0到127,如果声音处于非活动状态,则未指定。</target>
        </trans-unit>
        <trans-unit id="3ad35119f4d6b600ad01fb75ffdc7cbb41a4dda7" translate="yes" xml:space="preserve">
          <source>The current bit offset within the stream. Subclasses are responsible for keeping this value current from any method they override that alters the bit offset.</source>
          <target state="translated">当前流中的位偏移。子类有责任在他们覆盖的任何改变位偏移量的方法中保持这个值是最新的。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
