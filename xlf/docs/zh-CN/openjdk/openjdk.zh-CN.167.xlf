<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="openjdk">
    <body>
      <group id="openjdk">
        <trans-unit id="9839a314b20b78f9253b406fd33020bc5eeae4df" translate="yes" xml:space="preserve">
          <source>The smallest reasonable width/height of the component or component group, in pixels.</source>
          <target state="translated">组件或组件组的最小合理宽度/高度,单位为像素。</target>
        </trans-unit>
        <trans-unit id="d29505ba6327a428e6ada6e998db00c29198a04c" translate="yes" xml:space="preserve">
          <source>The smallest valid index for reading, initially 0.</source>
          <target state="translated">读取的最小有效指数,初始为0。</target>
        </trans-unit>
        <trans-unit id="cc3e306f7c43f12a0cd31a1e11f56ee1c06bddfe" translate="yes" xml:space="preserve">
          <source>The smallest valid index for reading, initially 0. When &lt;code&gt;seekForwardOnly&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, various methods may throw an &lt;code&gt;IndexOutOfBoundsException&lt;/code&gt; on an attempt to access data associate with an image having a lower index.</source>
          <target state="translated">用于读取的最小有效索引，最初为0。当 &lt;code&gt;seekForwardOnly&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; 时，各种方法可能会尝试访问与索引较低的图像关联的数据时抛出 &lt;code&gt;IndexOutOfBoundsException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="47262b7bead58cc0b762a05c504fc361f30be635" translate="yes" xml:space="preserve">
          <source>The snippet has a valid signature and it is visible to other snippets (&lt;a href=&quot;#isDefined()&quot;&gt;&lt;code&gt;isDefined() == true&lt;/code&gt;&lt;/a&gt;) and thus can be referenced in existing or new snippets but the snippet cannot be executed. An &lt;a href=&quot;unresolvedreferenceexception&quot;&gt;&lt;code&gt;UnresolvedReferenceException&lt;/code&gt;&lt;/a&gt; will be thrown on an attempt to execute it.</source>
          <target state="translated">该代码段具有有效的签名，并且对其他代码段可见（&lt;a href=&quot;#isDefined()&quot;&gt; &lt;code&gt;isDefined() == true&lt;/code&gt; &lt;/a&gt;），因此可以在现有代码段或新代码段中进行引用，但该代码段无法执行。一个&lt;a href=&quot;unresolvedreferenceexception&quot;&gt; &lt;code&gt;UnresolvedReferenceException&lt;/code&gt; &lt;/a&gt;将在试图执行它被抛出。</target>
        </trans-unit>
        <trans-unit id="0d997d545268301277a9bcb7f89af28ce8cd435a" translate="yes" xml:space="preserve">
          <source>The snippet has an invalid signature or the implementation is otherwise unable to define it. The snippet it is not visible to other snippets (&lt;a href=&quot;#isDefined()&quot;&gt;&lt;code&gt;isDefined() == false&lt;/code&gt;&lt;/a&gt;) and thus cannot be referenced or executed.</source>
          <target state="translated">该代码段具有无效的签名，否则实现无法对其进行定义。其他代码段不可见的代码段（&lt;a href=&quot;#isDefined()&quot;&gt; &lt;code&gt;isDefined() == false&lt;/code&gt; &lt;/a&gt;），因此无法引用或执行。</target>
        </trans-unit>
        <trans-unit id="aa27fca3d9b651ed6796e1124fea3ceb65daeaff" translate="yes" xml:space="preserve">
          <source>The snippet is a declaration snippet with potentially recoverable unresolved references or other issues (in the context of current &lt;code&gt;JShell&lt;/code&gt; state).</source>
          <target state="translated">该代码段是一个声明代码段，具有可能可恢复的未解决的引用或其他问题（在当前 &lt;code&gt;JShell&lt;/code&gt; 状态的上下文中）。</target>
        </trans-unit>
        <trans-unit id="1703051353b6fbbbe0a98a60b44b9f8c07d2cba0" translate="yes" xml:space="preserve">
          <source>The snippet is a declaration snippet with potentially recoverable unresolved references or other issues (in the context of current &lt;code&gt;JShell&lt;/code&gt; state). Only a &lt;a href=&quot;declarationsnippet&quot;&gt;&lt;code&gt;DeclarationSnippet&lt;/code&gt;&lt;/a&gt; can have this &lt;code&gt;Status&lt;/code&gt;.</source>
          <target state="translated">该代码段是一个声明代码段，具有可能可恢复的未解决的引用或其他问题（在当前 &lt;code&gt;JShell&lt;/code&gt; 状态的上下文中）。只有&lt;a href=&quot;declarationsnippet&quot;&gt; &lt;code&gt;DeclarationSnippet&lt;/code&gt; &lt;/a&gt;可以具有此 &lt;code&gt;Status&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="534843ccba930540dd96d6a2040f6b9b01ffc247" translate="yes" xml:space="preserve">
          <source>The snippet is a declaration snippet with potentially recoverable unresolved references or other issues in its body (in the context of current &lt;code&gt;JShell&lt;/code&gt; state).</source>
          <target state="translated">该代码段是一个声明代码段，其主体中具有潜在的可恢复的未解决的引用或其他问题（在当前 &lt;code&gt;JShell&lt;/code&gt; 状态的上下文中）。</target>
        </trans-unit>
        <trans-unit id="36fb7e093d326a223b05fe5aa66add48a7b56c11" translate="yes" xml:space="preserve">
          <source>The snippet is a declaration snippet with potentially recoverable unresolved references or other issues in its body (in the context of current &lt;code&gt;JShell&lt;/code&gt; state). Only a &lt;a href=&quot;declarationsnippet&quot;&gt;&lt;code&gt;DeclarationSnippet&lt;/code&gt;&lt;/a&gt; can have this &lt;code&gt;Status&lt;/code&gt;.</source>
          <target state="translated">该代码段是一个声明代码段，其主体中具有潜在的可恢复的未解决的引用或其他问题（在当前 &lt;code&gt;JShell&lt;/code&gt; 状态的上下文中）。只有&lt;a href=&quot;declarationsnippet&quot;&gt; &lt;code&gt;DeclarationSnippet&lt;/code&gt; &lt;/a&gt;可以具有此 &lt;code&gt;Status&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c076e442c29974123067f6dd99c7c848ad814370" translate="yes" xml:space="preserve">
          <source>The snippet is a valid snippet (in the context of current &lt;code&gt;JShell&lt;/code&gt; state).</source>
          <target state="translated">该代码段是有效的代码段（在当前 &lt;code&gt;JShell&lt;/code&gt; 状态的上下文中）。</target>
        </trans-unit>
        <trans-unit id="01367707922b92652ec5a4fa560e56793668f4c1" translate="yes" xml:space="preserve">
          <source>The snippet is a valid snippet (in the context of current &lt;code&gt;JShell&lt;/code&gt; state). Only snippets with &lt;code&gt;VALID&lt;/code&gt;&lt;code&gt;Status&lt;/code&gt; can be executed (though not all &lt;code&gt;VALID&lt;/code&gt; snippets have executable code).</source>
          <target state="translated">该代码段是有效的代码段（在当前 &lt;code&gt;JShell&lt;/code&gt; 状态的上下文中）。只有片段 &lt;code&gt;VALID&lt;/code&gt; &lt;code&gt;Status&lt;/code&gt; 可以被执行（尽管不是所有 &lt;code&gt;VALID&lt;/code&gt; 片段具有可执行代码）。</target>
        </trans-unit>
        <trans-unit id="86ed097e60ce8d08b4843b18da7a9b776540867e" translate="yes" xml:space="preserve">
          <source>The snippet is defined (&lt;a href=&quot;#isDefined()&quot;&gt;&lt;code&gt;isDefined() == true&lt;/code&gt;&lt;/a&gt;). If the snippet is a declaration or import (&lt;a href=&quot;snippet.kind#isPersistent()&quot;&gt;&lt;code&gt;Snippet.Kind.isPersistent()&lt;/code&gt;&lt;/a&gt;), it is visible to other snippets</source>
          <target state="translated">该代码段已定义（&lt;a href=&quot;#isDefined()&quot;&gt; &lt;code&gt;isDefined() == true&lt;/code&gt; &lt;/a&gt;）。如果代码段是声明或导入（&lt;a href=&quot;snippet.kind#isPersistent()&quot;&gt; &lt;code&gt;Snippet.Kind.isPersistent()&lt;/code&gt; &lt;/a&gt;），则其他代码段可见</target>
        </trans-unit>
        <trans-unit id="cd5904cbd3573e566ff1f2085feb79f7f3379232" translate="yes" xml:space="preserve">
          <source>The snippet is inactive because it does not yet exist.</source>
          <target state="translated">该片段因尚未存在而不活跃。</target>
        </trans-unit>
        <trans-unit id="9a62709f6052670bec0af74609b5b12c267407e4" translate="yes" xml:space="preserve">
          <source>The snippet is inactive because it does not yet exist. Used only in &lt;code&gt;SnippetEvent.previousStatus&lt;/code&gt; for new snippets. &lt;a href=&quot;jshell#status(jdk.jshell.Snippet)&quot;&gt;&lt;code&gt;JShell.status(Snippet)&lt;/code&gt;&lt;/a&gt; will never return this &lt;code&gt;Status&lt;/code&gt;.</source>
          <target state="translated">该代码段无效，因为它尚不存在。仅在 &lt;code&gt;SnippetEvent.previousStatus&lt;/code&gt; 中用于新片段。&lt;a href=&quot;jshell#status(jdk.jshell.Snippet)&quot;&gt; &lt;code&gt;JShell.status(Snippet)&lt;/code&gt; &lt;/a&gt;永远不会返回此 &lt;code&gt;Status&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="46041cbcdec9e126fee187edfd581d626cd40425" translate="yes" xml:space="preserve">
          <source>The snippet is inactive because it failed compilation on initial evaluation and it is not capable of becoming valid with further changes to the JShell state.</source>
          <target state="translated">该代码段是不活跃的,因为它在初始评估时编译失败了,而且它不能够随着JShell状态的进一步改变而变得有效。</target>
        </trans-unit>
        <trans-unit id="ff59f9e01cd5b521bc7b8652604d7c50cd0bb4a8" translate="yes" xml:space="preserve">
          <source>The snippet is inactive because it has been replaced by a new snippet.</source>
          <target state="translated">该代码段已被新的代码段所取代,所以不活跃。</target>
        </trans-unit>
        <trans-unit id="7b34acaafe0b4b06404d2342a73ac1d09caae77c" translate="yes" xml:space="preserve">
          <source>The snippet is inactive because it has been replaced by a new snippet. This occurs when the new snippet added with &lt;a href=&quot;jshell#eval(java.lang.String)&quot;&gt;&lt;code&gt;eval&lt;/code&gt;&lt;/a&gt; matches a previous snippet. A &lt;code&gt;TypeDeclSnippet&lt;/code&gt; will match another &lt;code&gt;TypeDeclSnippet&lt;/code&gt; if the names match. For example &lt;code&gt;class X { }&lt;/code&gt; will overwrite &lt;code&gt;class X { int ii; }&lt;/code&gt; or &lt;code&gt;interface X { }&lt;/code&gt;. A &lt;code&gt;MethodSnippet&lt;/code&gt; will match another &lt;code&gt;MethodSnippet&lt;/code&gt; if the names and parameter types match. For example &lt;code&gt;void m(int a) { }&lt;/code&gt; will overwrite &lt;code&gt;int m(int a) { return a+a; }&lt;/code&gt;. A &lt;code&gt;VarSnippet&lt;/code&gt; will match another &lt;code&gt;VarSnippet&lt;/code&gt; if the names match. For example &lt;code&gt;double z;&lt;/code&gt; will overwrite &lt;code&gt;long z = 2L;&lt;/code&gt;. Only a &lt;a href=&quot;persistentsnippet&quot;&gt;&lt;code&gt;PersistentSnippet&lt;/code&gt;&lt;/a&gt; can have this &lt;code&gt;Status&lt;/code&gt;.</source>
          <target state="translated">该代码段无效，因为它已被新代码段替换。当添加了&lt;a href=&quot;jshell#eval(java.lang.String)&quot;&gt; &lt;code&gt;eval&lt;/code&gt; &lt;/a&gt;的新代码片段与先前的代码片段匹配时，就会发生这种情况。一个 &lt;code&gt;TypeDeclSnippet&lt;/code&gt; 将匹配另一个 &lt;code&gt;TypeDeclSnippet&lt;/code&gt; 如果名称相匹配。例如， &lt;code&gt;class X { }&lt;/code&gt; 将覆盖 &lt;code&gt;class X { int ii; }&lt;/code&gt; 或 &lt;code&gt;interface X { }&lt;/code&gt; 。一个 &lt;code&gt;MethodSnippet&lt;/code&gt; 将匹配另一个 &lt;code&gt;MethodSnippet&lt;/code&gt; 如果名称和参数类型相匹配。例如 &lt;code&gt;void m(int a) { }&lt;/code&gt; 将覆盖 &lt;code&gt;int m(int a) { return a+a; }&lt;/code&gt; 。一个 &lt;code&gt;VarSnippet&lt;/code&gt; 将与另一个 &lt;code&gt;VarSnippet&lt;/code&gt; 匹配如果名称匹配。例如 &lt;code&gt;double z;&lt;/code&gt; 将覆盖 &lt;code&gt;long z = 2L;&lt;/code&gt; 。只有&lt;a href=&quot;persistentsnippet&quot;&gt; &lt;code&gt;PersistentSnippet&lt;/code&gt; &lt;/a&gt;可以具有此 &lt;code&gt;Status&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="be7fc269089662edb796c5aac76419901a949bde" translate="yes" xml:space="preserve">
          <source>The snippet is inactive because of an explicit call to the &lt;a href=&quot;jshell#drop(jdk.jshell.Snippet)&quot;&gt;&lt;code&gt;JShell.drop(Snippet)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">由于显式调用了&lt;a href=&quot;jshell#drop(jdk.jshell.Snippet)&quot;&gt; &lt;code&gt;JShell.drop(Snippet)&lt;/code&gt; ,&lt;/a&gt;因此该代码段处于非活动状态。</target>
        </trans-unit>
        <trans-unit id="88904de386c079fccf3f30e7b543e31de3c3761f" translate="yes" xml:space="preserve">
          <source>The snippet is not visible to other snippets (&lt;a href=&quot;#isDefined()&quot;&gt;&lt;code&gt;isDefined() == false&lt;/code&gt;&lt;/a&gt;) and thus cannot be referenced or executed.</source>
          <target state="translated">该代码段对其他代码段不可见（&lt;a href=&quot;#isDefined()&quot;&gt; &lt;code&gt;isDefined() == false&lt;/code&gt; &lt;/a&gt;），因此无法引用或执行。</target>
        </trans-unit>
        <trans-unit id="dd303338297041406f7184b465492cfc79af727e" translate="yes" xml:space="preserve">
          <source>The snippet will not update as dependents change (&lt;a href=&quot;#isActive()&quot;&gt;&lt;code&gt;isActive() == false&lt;/code&gt;&lt;/a&gt;), its &lt;code&gt;Status&lt;/code&gt; will never change again.</source>
          <target state="translated">该代码段不会随着依赖项的更改而更新（&lt;a href=&quot;#isActive()&quot;&gt; &lt;code&gt;isActive() == false&lt;/code&gt; &lt;/a&gt;），其 &lt;code&gt;Status&lt;/code&gt; 将不再更改。</target>
        </trans-unit>
        <trans-unit id="9b1f33d6505253b243833ef1169501d91d39c62e" translate="yes" xml:space="preserve">
          <source>The snippet will update as dependents change (&lt;a href=&quot;#isActive()&quot;&gt;&lt;code&gt;isActive() == true&lt;/code&gt;&lt;/a&gt;), its status could become &lt;code&gt;RECOVERABLE_DEFINED&lt;/code&gt;, &lt;code&gt;RECOVERABLE_NOT_DEFINED&lt;/code&gt;, &lt;code&gt;DROPPED&lt;/code&gt;, or &lt;code&gt;OVERWRITTEN&lt;/code&gt;.</source>
          <target state="translated">该代码段将随着依赖项的更改而更新（&lt;a href=&quot;#isActive()&quot;&gt; &lt;code&gt;isActive() == true&lt;/code&gt; &lt;/a&gt;），其状态可能变为 &lt;code&gt;RECOVERABLE_DEFINED&lt;/code&gt; ， &lt;code&gt;RECOVERABLE_NOT_DEFINED&lt;/code&gt; ， &lt;code&gt;DROPPED&lt;/code&gt; 或 &lt;code&gt;OVERWRITTEN&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4b1eec2fab48735c90d5772f07bce5da4abb91fe" translate="yes" xml:space="preserve">
          <source>The snippet will update as dependents change (&lt;a href=&quot;#isActive()&quot;&gt;&lt;code&gt;isActive() == true&lt;/code&gt;&lt;/a&gt;), its status could become &lt;code&gt;VALID&lt;/code&gt;, &lt;code&gt;RECOVERABLE_DEFINED&lt;/code&gt;, &lt;code&gt;DROPPED&lt;/code&gt;, or &lt;code&gt;OVERWRITTEN&lt;/code&gt;.</source>
          <target state="translated">该代码段将随着依赖项的更改而更新（&lt;a href=&quot;#isActive()&quot;&gt; &lt;code&gt;isActive() == true&lt;/code&gt; &lt;/a&gt;），其状态可能变为 &lt;code&gt;VALID&lt;/code&gt; ， &lt;code&gt;RECOVERABLE_DEFINED&lt;/code&gt; ， &lt;code&gt;DROPPED&lt;/code&gt; 或 &lt;code&gt;OVERWRITTEN&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="752e212aff543f906f63d7b8eebdaaa65a70207e" translate="yes" xml:space="preserve">
          <source>The snippet will update as dependents change (&lt;a href=&quot;#isActive()&quot;&gt;&lt;code&gt;isActive() == true&lt;/code&gt;&lt;/a&gt;), its status could become &lt;code&gt;VALID&lt;/code&gt;, &lt;code&gt;RECOVERABLE_NOT_DEFINED&lt;/code&gt;, &lt;code&gt;DROPPED&lt;/code&gt;, or &lt;code&gt;OVERWRITTEN&lt;/code&gt;.</source>
          <target state="translated">该代码段将随着依赖项的更改而更新（&lt;a href=&quot;#isActive()&quot;&gt; &lt;code&gt;isActive() == true&lt;/code&gt; &lt;/a&gt;），其状态可能变为 &lt;code&gt;VALID&lt;/code&gt; ， &lt;code&gt;RECOVERABLE_NOT_DEFINED&lt;/code&gt; ， &lt;code&gt;DROPPED&lt;/code&gt; 或 &lt;code&gt;OVERWRITTEN&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d34a10ed96641b907e1eb213e81431652411700a" translate="yes" xml:space="preserve">
          <source>The socket address that the socket is bound to, or &lt;code&gt;null&lt;/code&gt; if the channel's socket is not bound</source>
          <target state="translated">套接字绑定到的套接字地址；如果未绑定通道的套接字，则返回 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="450eed1463cf271b1ec0cb13231cb29de59dc30a" translate="yes" xml:space="preserve">
          <source>The socket address, or &lt;code&gt;null&lt;/code&gt; if this instance is to be used for sending a message and has been construced without specifying a preferred destination address</source>
          <target state="translated">套接字地址；如果此实例将用于发送消息，并且已构造而未指定首选目标地址，则为 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="004c4bf3ac859ce08e79a8b3e914c8cf5426cb22" translate="yes" xml:space="preserve">
          <source>The socket channel for the new connection, or &lt;code&gt;null&lt;/code&gt; if this channel is in non-blocking mode and no connection is available to be accepted</source>
          <target state="translated">新连接的套接字通道；如果此通道处于非阻塞模式并且没有可用的连接，则为 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="72330096ca60d13bfb3300d243f2b2b77e32b537" translate="yes" xml:space="preserve">
          <source>The socket channel returned by this method, if any, will be in blocking mode regardless of the blocking mode of this channel.</source>
          <target state="translated">本方法返回的套接字通道,如果有的话,无论该通道的阻塞模式如何,都将处于阻塞模式。</target>
        </trans-unit>
        <trans-unit id="0916495727f93025eff6a66cbf7b722521e11aa1" translate="yes" xml:space="preserve">
          <source>The socket factories are used when creating sockets for secure https URL connections.</source>
          <target state="translated">当为安全的https URL连接创建套接字时,会用到套接字工厂。</target>
        </trans-unit>
        <trans-unit id="ad5881f1dd9699e6809bd7cb33d457d13c6558c9" translate="yes" xml:space="preserve">
          <source>The socket option is read-only and an attempt to set the socket option will throw &lt;code&gt;SocketException&lt;/code&gt;.</source>
          <target state="translated">套接字选项是只读的，尝试设置套接字选项将抛出 &lt;code&gt;SocketException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b9b1dacea19873875bd394d1604a0e5a5d30890d" translate="yes" xml:space="preserve">
          <source>The sockets returned to the application can be subclasses of java.net.Socket, so that they can directly expose new APIs for features such as compression, security, record marking, statistics collection, or firewall tunneling.</source>
          <target state="translated">返回给应用程序的套接字可以是java.net.Socket的子类,这样它们可以直接暴露新的API,以实现压缩、安全、记录标记、统计收集或防火墙隧道等功能。</target>
        </trans-unit>
        <trans-unit id="e877bbc8bfc38843765b0308b8332044317fbf2a" translate="yes" xml:space="preserve">
          <source>The sole constructor.</source>
          <target state="translated">唯一的构造者。</target>
        </trans-unit>
        <trans-unit id="d5d133be61491e0ac1417ab0eba748b3aa345615" translate="yes" xml:space="preserve">
          <source>The sole purpose of these additions is to allow the specification of tables for use in decoding abbreviated streams. The built-in JPEG reader will also accept an ordinary &lt;code&gt;ImageReadParam&lt;/code&gt;, which is sufficient for decoding non-abbreviated streams.</source>
          <target state="translated">这些增加的唯一目的是允许规范表以用于对缩写流进行解码。内置的JPEG阅读器还将接受一个普通的 &lt;code&gt;ImageReadParam&lt;/code&gt; ，足以对非缩写流进行解码。</target>
        </trans-unit>
        <trans-unit id="a6c3a336ac8595f00b634d72ee534ceffed81b71" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm offers O(n log(n)) performance on all data sets, and is typically faster than traditional (one-pivot) Quicksort implementations.</source>
          <target state="translated">排序算法是Vladimir Yaroslavskiy、Jon Bentley和Josh Bloch的Dual-Pivot Quicksort。该算法在所有数据集上提供了O(n log(n))的性能,通常比传统的(单枢轴)Quicksort实现更快。</target>
        </trans-unit>
        <trans-unit id="0f89eabf4c727d37647595fc5e3c16a6a2f03dd3" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on all data sets, and is typically faster than traditional (one-pivot) Quicksort implementations.</source>
          <target state="translated">排序算法是由Vladimir Yaroslavskiy、Jon Bentley和Joshua Bloch提出的Dual-Pivot Quicksort。这种算法在所有数据集上提供了O(n log(n))的性能,通常比传统的(单枢轴)Quicksort实现更快。</target>
        </trans-unit>
        <trans-unit id="89b93c3df541630653c18e1886ceb597afae62a2" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;#sort(byte%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;#sort(byte%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">排序算法是一个并行的排序合并，它将数组分解为子数组，这些子数组本身经过排序然后合并。当子数组的长度达到最小粒度时，将使用适当的&lt;a href=&quot;#sort(byte%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt;方法对子数组进行排序。如果指定数组的长度小于最小粒度，则使用适当的&lt;a href=&quot;#sort(byte%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt;方法对其进行排序。该算法需要的工作空间不大于原始数组的大小。该&lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt;是用来执行任何并行任务。</target>
        </trans-unit>
        <trans-unit id="784cdcae362dc5581521030a458ea9926ba3223b" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;#sort(byte%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;#sort(byte%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the specified range of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">排序算法是一个并行的排序合并，它将数组分解为子数组，这些子数组本身经过排序然后合并。当子数组的长度达到最小粒度时，将使用适当的&lt;a href=&quot;#sort(byte%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt;方法对子数组进行排序。如果指定数组的长度小于最小粒度，则使用适当的&lt;a href=&quot;#sort(byte%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt;方法对其进行排序。该算法要求的工作空间不大于原始数组指定范围的大小。该&lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt;是用来执行任何并行任务。</target>
        </trans-unit>
        <trans-unit id="7ff5d937d432a11ea2a201ecc58034dd5441a852" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;#sort(char%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;#sort(char%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">排序算法是一个并行的排序合并，它将数组分解为子数组，这些子数组本身经过排序然后合并。当子数组的长度达到最小粒度时，将使用适当的&lt;a href=&quot;#sort(char%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt;方法对子数组进行排序。如果指定数组的长度小于最小粒度，则使用适当的&lt;a href=&quot;#sort(char%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt;方法对其进行排序。该算法需要的工作空间不大于原始数组的大小。该&lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt;是用来执行任何并行任务。</target>
        </trans-unit>
        <trans-unit id="2e5b7af711e48ed5dc89614218be16edbd43e49c" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;#sort(char%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;#sort(char%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the specified range of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">排序算法是一个并行的排序合并，它将数组分解为子数组，这些子数组本身经过排序然后合并。当子数组的长度达到最小粒度时，将使用适当的&lt;a href=&quot;#sort(char%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt;方法对子数组进行排序。如果指定数组的长度小于最小粒度，则使用适当的&lt;a href=&quot;#sort(char%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt;方法对其进行排序。该算法要求的工作空间不大于原始数组指定范围的大小。该&lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt;是用来执行任何并行任务。</target>
        </trans-unit>
        <trans-unit id="2fddd1310d77bbe7f9dfe3d3aa01ae962a906b1b" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;#sort(double%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;#sort(double%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">排序算法是一个并行的排序合并，它将数组分解为子数组，这些子数组本身经过排序然后合并。当子数组的长度达到最小粒度时，将使用适当的&lt;a href=&quot;#sort(double%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt;方法对子数组进行排序。如果指定数组的长度小于最小粒度，则使用适当的&lt;a href=&quot;#sort(double%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt;方法对其进行排序。该算法需要的工作空间不大于原始数组的大小。该&lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt;是用来执行任何并行任务。</target>
        </trans-unit>
        <trans-unit id="02eeb024eac83701cb3dab1984790a4264154db6" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;#sort(double%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;#sort(double%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the specified range of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">排序算法是一个并行的排序合并，它将数组分解为子数组，这些子数组本身经过排序然后合并。当子数组的长度达到最小粒度时，将使用适当的&lt;a href=&quot;#sort(double%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt;方法对子数组进行排序。如果指定数组的长度小于最小粒度，则使用适当的&lt;a href=&quot;#sort(double%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt;方法对其进行排序。该算法要求的工作空间不大于原始数组指定范围的大小。该&lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt;是用来执行任何并行任务。</target>
        </trans-unit>
        <trans-unit id="4f90425a9cfcd671163aa3ba4f42ed3b9d2bc3a4" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;#sort(float%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;#sort(float%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">排序算法是一个并行的排序合并，它将数组分解为子数组，这些子数组本身经过排序然后合并。当子数组的长度达到最小粒度时，将使用适当的&lt;a href=&quot;#sort(float%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt;方法对子数组进行排序。如果指定数组的长度小于最小粒度，则使用适当的&lt;a href=&quot;#sort(float%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt;方法对其进行排序。该算法需要的工作空间不大于原始数组的大小。该&lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt;是用来执行任何并行任务。</target>
        </trans-unit>
        <trans-unit id="275540cfb6a8e26c5b313f0e391cacb2ad9d0076" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;#sort(float%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;#sort(float%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the specified range of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">排序算法是一个并行的排序合并，它将数组分解为子数组，这些子数组本身经过排序然后合并。当子数组的长度达到最小粒度时，将使用适当的&lt;a href=&quot;#sort(float%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt;方法对子数组进行排序。如果指定数组的长度小于最小粒度，则使用适当的&lt;a href=&quot;#sort(float%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt;方法对其进行排序。该算法要求的工作空间不大于原始数组指定范围的大小。该&lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt;是用来执行任何并行任务。</target>
        </trans-unit>
        <trans-unit id="94b575be4e8e24c03f457815c4ac16e5b75c882e" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;#sort(int%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;#sort(int%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">排序算法是一个并行的排序合并，它将数组分解为子数组，这些子数组本身经过排序然后合并。当子数组的长度达到最小粒度时，将使用适当的&lt;a href=&quot;#sort(int%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt;方法对子数组进行排序。如果指定数组的长度小于最小粒度，则使用适当的&lt;a href=&quot;#sort(int%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt;方法对其进行排序。该算法需要的工作空间不大于原始数组的大小。该&lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt;是用来执行任何并行任务。</target>
        </trans-unit>
        <trans-unit id="6ee0d5b8c7e0d8151809c5f26bb13f06d5c6f2a1" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;#sort(int%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;#sort(int%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the specified range of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">排序算法是一个并行的排序合并，它将数组分解为子数组，这些子数组本身经过排序然后合并。当子数组的长度达到最小粒度时，将使用适当的&lt;a href=&quot;#sort(int%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt;方法对子数组进行排序。如果指定数组的长度小于最小粒度，则使用适当的&lt;a href=&quot;#sort(int%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt;方法对其进行排序。该算法要求的工作空间不大于原始数组指定范围的大小。该&lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt;是用来执行任何并行任务。</target>
        </trans-unit>
        <trans-unit id="5e68b55659f65572149d90497e01649faf00e021" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;#sort(java.lang.Object%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;#sort(java.lang.Object%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">排序算法是一个并行的排序合并，它将数组分解为子数组，这些子数组本身经过排序然后合并。当子数组的长度达到最小粒度时，将使用适当的&lt;a href=&quot;#sort(java.lang.Object%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt;方法对子数组进行排序。如果指定数组的长度小于最小粒度，则使用适当的&lt;a href=&quot;#sort(java.lang.Object%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt;方法对其进行排序。该算法需要的工作空间不大于原始数组的大小。该&lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt;是用来执行任何并行任务。</target>
        </trans-unit>
        <trans-unit id="be292033b578af0efd8258008b00c522a942cd0c" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;#sort(java.lang.Object%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;#sort(java.lang.Object%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the specified range of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">排序算法是一个并行的排序合并，它将数组分解为子数组，这些子数组本身经过排序然后合并。当子数组的长度达到最小粒度时，将使用适当的&lt;a href=&quot;#sort(java.lang.Object%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt;方法对子数组进行排序。如果指定数组的长度小于最小粒度，则使用适当的&lt;a href=&quot;#sort(java.lang.Object%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt;方法对其进行排序。该算法要求的工作空间不大于原始数组指定范围的大小。该&lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt;是用来执行任何并行任务。</target>
        </trans-unit>
        <trans-unit id="4939742092d60ecdc9f5ff5d5d17f5c9210da4ff" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;#sort(long%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;#sort(long%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">排序算法是一个并行的排序合并，它将数组分解为子数组，这些子数组本身经过排序然后合并。当子数组的长度达到最小粒度时，将使用适当的&lt;a href=&quot;#sort(long%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt;方法对子数组进行排序。如果指定数组的长度小于最小粒度，则使用适当的&lt;a href=&quot;#sort(long%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt;方法对其进行排序。该算法需要的工作空间不大于原始数组的大小。该&lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt;是用来执行任何并行任务。</target>
        </trans-unit>
        <trans-unit id="311db9e136afe682fa40514c417dc4d15f8e69c5" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;#sort(long%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;#sort(long%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the specified range of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">排序算法是一个并行的排序合并，它将数组分解为子数组，这些子数组本身经过排序然后合并。当子数组的长度达到最小粒度时，将使用适当的&lt;a href=&quot;#sort(long%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt;方法对子数组进行排序。如果指定数组的长度小于最小粒度，则使用适当的&lt;a href=&quot;#sort(long%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt;方法对其进行排序。该算法要求的工作空间不大于原始数组指定范围的大小。该&lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt;是用来执行任何并行任务。</target>
        </trans-unit>
        <trans-unit id="1fde7bfb5ab47c4ddc5c959bc79b4e7eb9f4030c" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;#sort(short%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;#sort(short%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">排序算法是一个并行的排序合并，它将数组分解为子数组，这些子数组本身经过排序然后合并。当子数组的长度达到最小粒度时，将使用适当的&lt;a href=&quot;#sort(short%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt;方法对子数组进行排序。如果指定数组的长度小于最小粒度，则使用适当的&lt;a href=&quot;#sort(short%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt;方法对其进行排序。该算法需要的工作空间不大于原始数组的大小。该&lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt;是用来执行任何并行任务。</target>
        </trans-unit>
        <trans-unit id="c9a68b6c5882885166c6b5b6d4f8f9f68a7f939b" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;#sort(short%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;#sort(short%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the specified range of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">排序算法是一个并行的排序合并，它将数组分解为子数组，这些子数组本身经过排序然后合并。当子数组的长度达到最小粒度时，将使用适当的&lt;a href=&quot;#sort(short%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt;方法对子数组进行排序。如果指定数组的长度小于最小粒度，则使用适当的&lt;a href=&quot;#sort(short%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt;方法对其进行排序。该算法要求的工作空间不大于原始数组指定范围的大小。该&lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt;是用来执行任何并行任务。</target>
        </trans-unit>
        <trans-unit id="38844e94f41cc1969fb62e4894696634a14fe20b" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;arrays#sort-byte:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;arrays#sort-byte:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">排序算法是一个并行的排序合并，它将数组分成子数组，这些子数组本身先进行排序然后合并。当子数组的长度达到最小粒度时，将使用适当的&lt;a href=&quot;arrays#sort-byte:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt;方法对子数组进行排序。如果指定数组的长度小于最小粒度，则使用适当的&lt;a href=&quot;arrays#sort-byte:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt;方法对其进行排序。该算法需要的工作空间不大于原始数组的大小。该&lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt;是用来执行任何并行任务。</target>
        </trans-unit>
        <trans-unit id="75b2a84749a330a1c0b895e2bdf2312622f71cb8" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;arrays#sort-byte:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;arrays#sort-byte:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the specified range of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">排序算法是一个并行的排序合并，它将数组分成子数组，这些子数组本身先进行排序然后合并。当子数组的长度达到最小粒度时，将使用适当的&lt;a href=&quot;arrays#sort-byte:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt;方法对子数组进行排序。如果指定数组的长度小于最小粒度，则使用适当的&lt;a href=&quot;arrays#sort-byte:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt;方法对其进行排序。该算法要求的工作空间不大于原始数组指定范围的大小。该&lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt;是用来执行任何并行任务。</target>
        </trans-unit>
        <trans-unit id="20a31ccdaba6cb746cb91c886a84a8c2d7c538b7" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;arrays#sort-char:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;arrays#sort-char:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">排序算法是一个并行的排序合并，它将数组分成子数组，这些子数组本身先进行排序然后合并。当子数组的长度达到最小粒度时，将使用适当的&lt;a href=&quot;arrays#sort-char:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt;方法对子数组进行排序。如果指定数组的长度小于最小粒度，则使用适当的&lt;a href=&quot;arrays#sort-char:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt;方法对其进行排序。该算法需要的工作空间不大于原始数组的大小。该&lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt;是用来执行任何并行任务。</target>
        </trans-unit>
        <trans-unit id="48b9a8628a4883f257650b1adf775491c8f08839" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;arrays#sort-char:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;arrays#sort-char:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the specified range of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">排序算法是一个并行的排序合并，它将数组分成子数组，这些子数组本身先进行排序然后合并。当子数组的长度达到最小粒度时，将使用适当的&lt;a href=&quot;arrays#sort-char:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt;方法对子数组进行排序。如果指定数组的长度小于最小粒度，则使用适当的&lt;a href=&quot;arrays#sort-char:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt;方法对其进行排序。该算法要求的工作空间不大于原始数组指定范围的大小。该&lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt;是用来执行任何并行任务。</target>
        </trans-unit>
        <trans-unit id="d3cac5983cf37dcfe292291f746e0459fd7e8669" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;arrays#sort-double:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;arrays#sort-double:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">排序算法是一个并行的排序合并，它将数组分成子数组，这些子数组本身先进行排序然后合并。当子数组的长度达到最小粒度时，将使用适当的&lt;a href=&quot;arrays#sort-double:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt;方法对子数组进行排序。如果指定数组的长度小于最小粒度，则使用适当的&lt;a href=&quot;arrays#sort-double:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt;方法对其进行排序。该算法需要的工作空间不大于原始数组的大小。该&lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt;是用来执行任何并行任务。</target>
        </trans-unit>
        <trans-unit id="08eda0222f2f9308c70c208bbdafe98a9e736807" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;arrays#sort-double:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;arrays#sort-double:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the specified range of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">排序算法是一个并行的排序合并，它将数组分成子数组，这些子数组本身先进行排序然后合并。当子数组的长度达到最小粒度时，将使用适当的&lt;a href=&quot;arrays#sort-double:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt;方法对子数组进行排序。如果指定数组的长度小于最小粒度，则使用适当的&lt;a href=&quot;arrays#sort-double:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt;方法对其进行排序。该算法要求的工作空间不大于原始数组指定范围的大小。该&lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt;是用来执行任何并行任务。</target>
        </trans-unit>
        <trans-unit id="1b5efb4aa3ea50144cc0394f060b745aadbd838e" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;arrays#sort-float:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;arrays#sort-float:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">排序算法是一个并行的排序合并，它将数组分成子数组，这些子数组本身先进行排序然后合并。当子数组的长度达到最小粒度时，将使用适当的&lt;a href=&quot;arrays#sort-float:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt;方法对子数组进行排序。如果指定数组的长度小于最小粒度，则使用适当的&lt;a href=&quot;arrays#sort-float:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt;方法对其进行排序。该算法需要的工作空间不大于原始数组的大小。该&lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt;是用来执行任何并行任务。</target>
        </trans-unit>
        <trans-unit id="b9ac2ce61dcea76b147223bff87472496593df2a" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;arrays#sort-float:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;arrays#sort-float:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the specified range of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">排序算法是一个并行的排序合并，它将数组分成子数组，这些子数组本身先进行排序然后合并。当子数组的长度达到最小粒度时，将使用适当的&lt;a href=&quot;arrays#sort-float:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt;方法对子数组进行排序。如果指定数组的长度小于最小粒度，则使用适当的&lt;a href=&quot;arrays#sort-float:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt;方法对其进行排序。该算法要求的工作空间不大于原始数组指定范围的大小。该&lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt;是用来执行任何并行任务。</target>
        </trans-unit>
        <trans-unit id="ff09cbb5362e1360ac15f00a55f46a71d4e41ca1" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;arrays#sort-int:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;arrays#sort-int:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">排序算法是一个并行的排序合并，它将数组分成子数组，这些子数组本身先进行排序然后合并。当子数组的长度达到最小粒度时，将使用适当的&lt;a href=&quot;arrays#sort-int:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt;方法对子数组进行排序。如果指定数组的长度小于最小粒度，则使用适当的&lt;a href=&quot;arrays#sort-int:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt;方法对其进行排序。该算法需要的工作空间不大于原始数组的大小。该&lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt;是用来执行任何并行任务。</target>
        </trans-unit>
        <trans-unit id="edc68fa2b5db74746879cf023d506ffd46c30425" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;arrays#sort-int:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;arrays#sort-int:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the specified range of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">排序算法是一个并行的排序合并，它将数组分成子数组，这些子数组本身先进行排序然后合并。当子数组的长度达到最小粒度时，将使用适当的&lt;a href=&quot;arrays#sort-int:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt;方法对子数组进行排序。如果指定数组的长度小于最小粒度，则使用适当的&lt;a href=&quot;arrays#sort-int:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt;方法对其进行排序。该算法要求的工作空间不大于原始数组指定范围的大小。该&lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt;是用来执行任何并行任务。</target>
        </trans-unit>
        <trans-unit id="839592e0ded3d9de75771fbf4886b637ea10acea" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;arrays#sort-java.lang.Object:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;arrays#sort-java.lang.Object:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">排序算法是一个并行的排序合并，它将数组分成子数组，这些子数组本身先进行排序然后合并。当子数组的长度达到最小粒度时，将使用适当的&lt;a href=&quot;arrays#sort-java.lang.Object:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt;方法对子数组进行排序。如果指定数组的长度小于最小粒度，则使用适当的&lt;a href=&quot;arrays#sort-java.lang.Object:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt;方法对其进行排序。该算法需要的工作空间不大于原始数组的大小。该&lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt;是用来执行任何并行任务。</target>
        </trans-unit>
        <trans-unit id="614e7b8df8741ffaa018e919714cf7473694c642" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;arrays#sort-java.lang.Object:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;arrays#sort-java.lang.Object:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the specified range of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">排序算法是一个并行的排序合并，它将数组分成子数组，这些子数组本身先进行排序然后合并。当子数组的长度达到最小粒度时，将使用适当的&lt;a href=&quot;arrays#sort-java.lang.Object:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt;方法对子数组进行排序。如果指定数组的长度小于最小粒度，则使用适当的&lt;a href=&quot;arrays#sort-java.lang.Object:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt;方法对其进行排序。该算法要求的工作空间不大于原始数组指定范围的大小。该&lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt;是用来执行任何并行任务。</target>
        </trans-unit>
        <trans-unit id="648b93b50bbd09b1605688594b8660ecbbb90d1b" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;arrays#sort-long:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;arrays#sort-long:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">排序算法是一个并行的排序合并，它将数组分成子数组，这些子数组本身先进行排序然后合并。当子数组的长度达到最小粒度时，将使用适当的&lt;a href=&quot;arrays#sort-long:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt;方法对子数组进行排序。如果指定数组的长度小于最小粒度，则使用适当的&lt;a href=&quot;arrays#sort-long:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt;方法对其进行排序。该算法需要的工作空间不大于原始数组的大小。该&lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt;是用来执行任何并行任务。</target>
        </trans-unit>
        <trans-unit id="0247ed33cde4f71d592e6d7daa37c7760b936d47" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;arrays#sort-long:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;arrays#sort-long:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the specified range of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">排序算法是一个并行的排序合并，它将数组分成子数组，这些子数组本身先进行排序然后合并。当子数组的长度达到最小粒度时，将使用适当的&lt;a href=&quot;arrays#sort-long:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt;方法对子数组进行排序。如果指定数组的长度小于最小粒度，则使用适当的&lt;a href=&quot;arrays#sort-long:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt;方法对其进行排序。该算法要求的工作空间不大于原始数组指定范围的大小。该&lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt;是用来执行任何并行任务。</target>
        </trans-unit>
        <trans-unit id="777d40468912737a83340f22bc67c6f77af71aaf" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;arrays#sort-short:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;arrays#sort-short:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">排序算法是一个并行的排序合并，它将数组分成子数组，这些子数组本身先进行排序然后合并。当子数组的长度达到最小粒度时，将使用适当的&lt;a href=&quot;arrays#sort-short:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt;方法对子数组进行排序。如果指定数组的长度小于最小粒度，则使用适当的&lt;a href=&quot;arrays#sort-short:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt;方法对其进行排序。该算法需要的工作空间不大于原始数组的大小。该&lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt;是用来执行任何并行任务。</target>
        </trans-unit>
        <trans-unit id="e41f68150d548775a312ef7c6bad1b753c9c647c" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;arrays#sort-short:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;arrays#sort-short:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the specified range of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">排序算法是一个并行的排序合并，它将数组分成子数组，这些子数组本身先进行排序然后合并。当子数组的长度达到最小粒度时，将使用适当的&lt;a href=&quot;arrays#sort-short:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt;方法对子数组进行排序。如果指定数组的长度小于最小粒度，则使用适当的&lt;a href=&quot;arrays#sort-short:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt;方法对其进行排序。该算法要求的工作空间不大于原始数组指定范围的大小。该&lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt;是用来执行任何并行任务。</target>
        </trans-unit>
        <trans-unit id="b4ca5b611518435cd08b1d3ce800c9c8f468a67f" translate="yes" xml:space="preserve">
          <source>The source &lt;code&gt;DocumentView&lt;/code&gt; of which this is an &lt;code&gt;AbstractView&lt;/code&gt;.</source>
          <target state="translated">源 &lt;code&gt;DocumentView&lt;/code&gt; ，它是 &lt;code&gt;AbstractView&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="55944b789daff6ef5841d9434f11985f49ff23c4" translate="yes" xml:space="preserve">
          <source>The source actions represent the set of actions supported by the source of this transfer, and are represented as some bitwise-OR combination of &lt;code&gt;COPY&lt;/code&gt;, &lt;code&gt;MOVE&lt;/code&gt; and &lt;code&gt;LINK&lt;/code&gt;. You may wish to query this in &lt;code&gt;TransferHandler&lt;/code&gt;'s &lt;code&gt;canImport&lt;/code&gt; method when determining the suitability of a drop or when deciding on a drop action to explicitly choose. To determine if a particular action is supported by the source, bitwise-AND the action with the source drop actions, and then compare the result against the original action. For example:</source>
          <target state="translated">源操作表示此传输的源所支持的一组操作，并表示为 &lt;code&gt;COPY&lt;/code&gt; ， &lt;code&gt;MOVE&lt;/code&gt; 和 &lt;code&gt;LINK&lt;/code&gt; 的按位&amp;ldquo;或&amp;rdquo;组合。在确定 &lt;code&gt;canImport&lt;/code&gt; 的适用性或决定要显式选择的放置动作时，您可能希望在 &lt;code&gt;TransferHandler&lt;/code&gt; 的canImport方法中查询此内容。要确定源是否支持特定操作，请将该操作与源放置操作按位与，然后将结果与原始操作进行比较。例如：</target>
        </trans-unit>
        <trans-unit id="368f0e5364e526b1a62ff1d9e84b032a4799d112" translate="yes" xml:space="preserve">
          <source>The source address if this membership key is source-specific, otherwise &lt;code&gt;null&lt;/code&gt;</source>
          <target state="translated">如果此成员资格密钥是特定于源的，则为源地址，否则为 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="49ef1bc740369619f8b5584da49f9c3ff9ac10f5" translate="yes" xml:space="preserve">
          <source>The source and destination must be different.</source>
          <target state="translated">来源地和目的地必须是不同的。</target>
        </trans-unit>
        <trans-unit id="1c54b79003a5eb4cba89a06459605f65bd7f13fd" translate="yes" xml:space="preserve">
          <source>The source bean is used as the source of events for the property changes. This source should be used for information purposes only and should not be modified by the PropertyEditor.</source>
          <target state="translated">源Bean被用作属性更改的事件源。这个源应该只用于提供信息,不应该被PropertyEditor修改。</target>
        </trans-unit>
        <trans-unit id="d614f9d4f31f56431b30829db0ada88a1526496a" translate="yes" xml:space="preserve">
          <source>The source cannot be structurally interfered with.</source>
          <target state="translated">源头不能在结构上受到干扰。</target>
        </trans-unit>
        <trans-unit id="61689ca13fa0754b0dac1fef1851f1593b2946cb" translate="yes" xml:space="preserve">
          <source>The source format represents the format of the incoming audio data, which will be converted.</source>
          <target state="translated">源格式表示输入的音频数据的格式,它将被转换。</target>
        </trans-unit>
        <trans-unit id="46df136cd9cc4668c308b326cb05d7ed6808c192" translate="yes" xml:space="preserve">
          <source>The source increases the likelihood of throwing &lt;code&gt;ConcurrentModificationException&lt;/code&gt; since the window of potential interference is larger.</source>
          <target state="translated">由于潜在干扰的窗口较大，因此源增加了引发 &lt;code&gt;ConcurrentModificationException&lt;/code&gt; 的可能性。</target>
        </trans-unit>
        <trans-unit id="c1f61cf74a08642c4ff7ee4b8bc3cda7829bff8b" translate="yes" xml:space="preserve">
          <source>The source increases the risk of arbitrary, non-deterministic behavior since non-detected interference may occur after construction.</source>
          <target state="translated">由于施工后可能会出现未检测到的干扰,因此源头增加了任意性、非确定性行为的风险。</target>
        </trans-unit>
        <trans-unit id="03565c55ce32575c338f8855e376da1747bff628" translate="yes" xml:space="preserve">
          <source>The source information for a Location is dependent on the</source>
          <target state="translated">一个位置的源信息取决于以下因素</target>
        </trans-unit>
        <trans-unit id="03d33500fcd4a667ea73efed98252841199edc27" translate="yes" xml:space="preserve">
          <source>The source is composited over the destination (Porter-Duff Source Over Destination rule).</source>
          <target state="translated">源在目标上合成(波特-达夫源在目标上规则)。</target>
        </trans-unit>
        <trans-unit id="dfdd906a9cfc82513a491834d2af899dcb03b222" translate="yes" xml:space="preserve">
          <source>The source is copied to the destination (Porter-Duff Source rule).</source>
          <target state="translated">源点被复制到目的点(波特-达夫源点规则)。</target>
        </trans-unit>
        <trans-unit id="29c343852025e2139effd2803766c6065e489fe6" translate="yes" xml:space="preserve">
          <source>The source is copied to the destination (Porter-Duff Source rule). The destination is not used as input.</source>
          <target state="translated">源文件被复制到目的文件(波特-达夫源文件规则)。目的地不作为输入。</target>
        </trans-unit>
        <trans-unit id="7f5e35322fb74527344b994cfeb8d4a21c655439" translate="yes" xml:space="preserve">
          <source>The source manages concurrent modifications.</source>
          <target state="translated">源头管理并发修改。</target>
        </trans-unit>
        <trans-unit id="cc3c2e9f00eb13dba6597fe19ebf6cc799eb8981" translate="yes" xml:space="preserve">
          <source>The source may be divided and mapped to different locations within the wrapped source.</source>
          <target state="translated">可以对源进行划分,并映射到包装源内的不同位置。</target>
        </trans-unit>
        <trans-unit id="8a5d1008eaa1af299fb1410c7693c63aa92311bc" translate="yes" xml:space="preserve">
          <source>The source object is the Relation Service itself.</source>
          <target state="translated">源对象是关系服务本身。</target>
        </trans-unit>
        <trans-unit id="cc9b426ca5912c0c22947a2cdc8350ca098c22e1" translate="yes" xml:space="preserve">
          <source>The source object needing translating.</source>
          <target state="translated">需要翻译的源对象。</target>
        </trans-unit>
        <trans-unit id="aa58c7b11a77f180bde4263ee0c9af48ad826837" translate="yes" xml:space="preserve">
          <source>The source of the event can be retrieved with the method &lt;code&gt;event.getSource&lt;/code&gt;.</source>
          <target state="translated">可以使用 &lt;code&gt;event.getSource&lt;/code&gt; 方法检索事件的来源。</target>
        </trans-unit>
        <trans-unit id="4b758d7983ddc60e8668a83198491ca7fd663319" translate="yes" xml:space="preserve">
          <source>The source of the event can be retrieved with the method event.getSource.</source>
          <target state="translated">事件的来源可以用event.getSource方法来检索。</target>
        </trans-unit>
        <trans-unit id="ba472d8058ce42e7759745b4cd537b6da4c0628f" translate="yes" xml:space="preserve">
          <source>The source of this event is the SSLSocket on which handshaking just completed.</source>
          <target state="translated">该事件的来源是刚刚完成握手的SSLSocket。</target>
        </trans-unit>
        <trans-unit id="34b28226ae9b0c9b05be3b2b72d0f78f8a72db57" translate="yes" xml:space="preserve">
          <source>The source of this pattern</source>
          <target state="translated">这种模式的来源</target>
        </trans-unit>
        <trans-unit id="9d040b79148889dda3be3cace827402195b26754" translate="yes" xml:space="preserve">
          <source>The source region of interest specified by this method will be clipped as needed to fit within the source bounds, as well as the destination offsets, width, and height at the time of actual I/O.</source>
          <target state="translated">该方法指定的感兴趣的源区域将根据需要进行剪裁,以适应在实际I/O时的源边界以及目标偏移、宽度和高度。</target>
        </trans-unit>
        <trans-unit id="6c425edd2b72c5bd49ce0000e1e9c0d010d1b680" translate="yes" xml:space="preserve">
          <source>The source region, on &lt;code&gt;null&lt;/code&gt; if none is set.</source>
          <target state="translated">源区域，如果未设置，则为 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="79992770a23d8083e338e39d04240948297bfa86" translate="yes" xml:space="preserve">
          <source>The source risks arbitrary, non-deterministic behavior after traversal has commenced since interference is not detected.</source>
          <target state="translated">由于没有检测到干扰,因此在开始遍历后,源有可能出现任意的、非确定性的行为。</target>
        </trans-unit>
        <trans-unit id="3d10c68f89f90c7178d019f1f4c1c12f009d6876" translate="yes" xml:space="preserve">
          <source>The south layout constraint (bottom of container).</source>
          <target state="translated">南部布局约束(容器底部)。</target>
        </trans-unit>
        <trans-unit id="e68ddcb7c0e62435f6fe1696214e8145cd3b4f3c" translate="yes" xml:space="preserve">
          <source>The south-east-resize cursor type.</source>
          <target state="translated">东南大小游标型。</target>
        </trans-unit>
        <trans-unit id="73fec64518a4d7b3dec25260b8298e0b9bed5f17" translate="yes" xml:space="preserve">
          <source>The south-resize cursor type.</source>
          <target state="translated">南辕北辙型光标。</target>
        </trans-unit>
        <trans-unit id="3b088fa20b66361bda186416ad335eb99b17d70b" translate="yes" xml:space="preserve">
          <source>The south-west-resize cursor type.</source>
          <target state="translated">西南方向调整光标大小的类型。</target>
        </trans-unit>
        <trans-unit id="b1f69a5894aacc09dd4212a4b7863d5992a5dd30" translate="yes" xml:space="preserve">
          <source>The space between strings.</source>
          <target state="translated">弦与弦之间的空间。</target>
        </trans-unit>
        <trans-unit id="7900bed2b0d5a0428294adba3589eaef49b81ef4" translate="yes" xml:space="preserve">
          <source>The space character &quot; &quot; is converted into a plus sign &quot;&lt;code&gt;+&lt;/code&gt;&quot;.</source>
          <target state="translated">空格字符&amp;ldquo;&amp;rdquo;转换为加号&amp;ldquo; &lt;code&gt;+&lt;/code&gt; &amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="507149f00d63c959176bee1f4d30e062fc83fdd7" translate="yes" xml:space="preserve">
          <source>The special characters &quot;&lt;code&gt;.&lt;/code&gt;&quot;, &quot;&lt;code&gt;-&lt;/code&gt;&quot;, &quot;&lt;code&gt;*&lt;/code&gt;&quot;, and &quot;&lt;code&gt;_&lt;/code&gt;&quot; remain the same.</source>
          <target state="translated">特殊字符&amp;ldquo; &lt;code&gt;.&lt;/code&gt; &amp;rdquo;，&amp;ldquo; &lt;code&gt;-&lt;/code&gt; &amp;rdquo;，&amp;ldquo; &lt;code&gt;*&lt;/code&gt; &amp;rdquo;和&amp;ldquo; &lt;code&gt;_&lt;/code&gt; &amp;rdquo;保持不变。</target>
        </trans-unit>
        <trans-unit id="554ae3414c670a7436c25a4064ec6ae6a231747b" translate="yes" xml:space="preserve">
          <source>The special method &lt;a href=&quot;#checkPermission(java.security.Permission)&quot;&gt;&lt;code&gt;checkPermission(java.security.Permission)&lt;/code&gt;&lt;/a&gt; determines whether an access request indicated by a specified permission should be granted or denied. The default implementation calls</source>
          <target state="translated">特殊方法&lt;a href=&quot;#checkPermission(java.security.Permission)&quot;&gt; &lt;code&gt;checkPermission(java.security.Permission)&lt;/code&gt; &lt;/a&gt;确定是应允许还是拒绝由指定权限指示的访问请求。默认实现调用</target>
        </trans-unit>
        <trans-unit id="a9d1df01fb5b8d33027995ef22465c9c621f1abe" translate="yes" xml:space="preserve">
          <source>The special method &lt;a href=&quot;securitymanager#checkPermission-java.security.Permission-&quot;&gt;&lt;code&gt;checkPermission(java.security.Permission)&lt;/code&gt;&lt;/a&gt; determines whether an access request indicated by a specified permission should be granted or denied. The default implementation calls</source>
          <target state="translated">特殊方法&lt;a href=&quot;securitymanager#checkPermission-java.security.Permission-&quot;&gt; &lt;code&gt;checkPermission(java.security.Permission)&lt;/code&gt; &lt;/a&gt;确定是应允许还是拒绝由指定权限指示的访问请求。默认实现调用</target>
        </trans-unit>
        <trans-unit id="0f63e638f0c9b18504ea41e24439a23387628a9a" translate="yes" xml:space="preserve">
          <source>The special strings &lt;a href=&quot;#ERROR&quot;&gt;&lt;code&gt;ERROR&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#STRIP&quot;&gt;&lt;code&gt;STRIP&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#PASS&quot;&gt;&lt;code&gt;PASS&lt;/code&gt;&lt;/a&gt; are also allowed, with the same meaning as &lt;a href=&quot;#UNKNOWN_ATTRIBUTE&quot;&gt;&lt;code&gt;UNKNOWN_ATTRIBUTE&lt;/code&gt;&lt;/a&gt;. This provides a way for users to request that specific attributes be refused, stripped, or passed bitwise (with no class compression).</source>
          <target state="translated">还允许使用特殊字符串&lt;a href=&quot;#ERROR&quot;&gt; &lt;code&gt;ERROR&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#STRIP&quot;&gt; &lt;code&gt;STRIP&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#PASS&quot;&gt; &lt;code&gt;PASS&lt;/code&gt; &lt;/a&gt;，其含义与&lt;a href=&quot;#UNKNOWN_ATTRIBUTE&quot;&gt; &lt;code&gt;UNKNOWN_ATTRIBUTE&lt;/code&gt; &lt;/a&gt;相同。这为用户提供了一种请求，即按位拒绝，剥离或传递特定属性（不进行类压缩）。</target>
        </trans-unit>
        <trans-unit id="32010eba7b4259d4453391d1922bfa0e43808b88" translate="yes" xml:space="preserve">
          <source>The special strings &lt;a href=&quot;pack200.packer#ERROR&quot;&gt;&lt;code&gt;ERROR&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;pack200.packer#STRIP&quot;&gt;&lt;code&gt;STRIP&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;pack200.packer#PASS&quot;&gt;&lt;code&gt;PASS&lt;/code&gt;&lt;/a&gt; are also allowed, with the same meaning as &lt;a href=&quot;pack200.packer#UNKNOWN_ATTRIBUTE&quot;&gt;&lt;code&gt;UNKNOWN_ATTRIBUTE&lt;/code&gt;&lt;/a&gt;. This provides a way for users to request that specific attributes be refused, stripped, or passed bitwise (with no class compression).</source>
          <target state="translated">还允许使用特殊字符串&lt;a href=&quot;pack200.packer#ERROR&quot;&gt; &lt;code&gt;ERROR&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;pack200.packer#STRIP&quot;&gt; &lt;code&gt;STRIP&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;pack200.packer#PASS&quot;&gt; &lt;code&gt;PASS&lt;/code&gt; &lt;/a&gt;，其含义与&lt;a href=&quot;pack200.packer#UNKNOWN_ATTRIBUTE&quot;&gt; &lt;code&gt;UNKNOWN_ATTRIBUTE&lt;/code&gt; &lt;/a&gt;相同。这为用户提供了一种请求，要求按位拒绝，剥离或传递特定属性（不进行类压缩）。</target>
        </trans-unit>
        <trans-unit id="6a13bd69809d0a0a05735ac36655ba584ce36412" translate="yes" xml:space="preserve">
          <source>The special value 0 instructs the packer to copy through the original JAR file directly, with no compression. The JSR 200 standard requires any unpacker to understand this special case as a pass-through of the entire archive.</source>
          <target state="translated">特殊值0指示打包者直接复制原JAR文件,不进行压缩。JSR 200标准要求任何解包器将这种特殊情况理解为整个档案的传递。</target>
        </trans-unit>
        <trans-unit id="d43aa293b92f885948dfdec9b93e9f6263ba164c" translate="yes" xml:space="preserve">
          <source>The specialized subtype default implementations of &lt;a href=&quot;iterator#next()&quot;&gt;&lt;code&gt;Iterator.next()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;iterator#forEachRemaining(java.util.function.Consumer)&quot;&gt;&lt;code&gt;Iterator.forEachRemaining(java.util.function.Consumer)&lt;/code&gt;&lt;/a&gt; box primitive values to instances of their corresponding wrapper class. Such boxing may offset any advantages gained when using the primitive specializations. To avoid boxing, the corresponding primitive-based methods should be used. For example, &lt;a href=&quot;primitiveiterator.ofint#nextInt()&quot;&gt;&lt;code&gt;PrimitiveIterator.OfInt.nextInt()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;primitiveiterator.ofint#forEachRemaining(java.util.function.IntConsumer)&quot;&gt;&lt;code&gt;PrimitiveIterator.OfInt.forEachRemaining(java.util.function.IntConsumer)&lt;/code&gt;&lt;/a&gt; should be used in preference to &lt;a href=&quot;primitiveiterator.ofint#next()&quot;&gt;&lt;code&gt;PrimitiveIterator.OfInt.next()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;primitiveiterator.ofint#forEachRemaining(java.util.function.Consumer)&quot;&gt;&lt;code&gt;PrimitiveIterator.OfInt.forEachRemaining(java.util.function.Consumer)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;iterator#next()&quot;&gt; &lt;code&gt;Iterator.next()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;iterator#forEachRemaining(java.util.function.Consumer)&quot;&gt; &lt;code&gt;Iterator.forEachRemaining(java.util.function.Consumer)&lt;/code&gt; &lt;/a&gt;框的原始值的专用子类型默认实现将它们的相应包装类的实例包装起来。这种拳击可能会抵消使用原始专业化所获得的任何优势。为避免装箱，应使用相应的基于基元的方法。例如，&lt;a href=&quot;primitiveiterator.ofint#nextInt()&quot;&gt; &lt;code&gt;PrimitiveIterator.OfInt.nextInt()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;primitiveiterator.ofint#forEachRemaining(java.util.function.IntConsumer)&quot;&gt; &lt;code&gt;PrimitiveIterator.OfInt.forEachRemaining(java.util.function.IntConsumer)&lt;/code&gt; &lt;/a&gt;应优先用于&lt;a href=&quot;primitiveiterator.ofint#next()&quot;&gt; &lt;code&gt;PrimitiveIterator.OfInt.next()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;primitiveiterator.ofint#forEachRemaining(java.util.function.Consumer)&quot;&gt; &lt;code&gt;PrimitiveIterator.OfInt.forEachRemaining(java.util.function.Consumer)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bb3de17aa29974030176e4818ff90fa588d4cccd" translate="yes" xml:space="preserve">
          <source>The specialized subtype default implementations of &lt;a href=&quot;iterator#next--&quot;&gt;&lt;code&gt;Iterator.next()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;iterator#forEachRemaining-java.util.function.Consumer-&quot;&gt;&lt;code&gt;Iterator.forEachRemaining(java.util.function.Consumer)&lt;/code&gt;&lt;/a&gt; box primitive values to instances of their corresponding wrapper class. Such boxing may offset any advantages gained when using the primitive specializations. To avoid boxing, the corresponding primitive-based methods should be used. For example, &lt;a href=&quot;primitiveiterator.ofint#nextInt--&quot;&gt;&lt;code&gt;PrimitiveIterator.OfInt.nextInt()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;primitiveiterator.ofint#forEachRemaining-java.util.function.IntConsumer-&quot;&gt;&lt;code&gt;PrimitiveIterator.OfInt.forEachRemaining(java.util.function.IntConsumer)&lt;/code&gt;&lt;/a&gt; should be used in preference to &lt;a href=&quot;primitiveiterator.ofint#next--&quot;&gt;&lt;code&gt;PrimitiveIterator.OfInt.next()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;primitiveiterator.ofint#forEachRemaining-java.util.function.Consumer-&quot;&gt;&lt;code&gt;PrimitiveIterator.OfInt.forEachRemaining(java.util.function.Consumer)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;iterator#next--&quot;&gt; &lt;code&gt;Iterator.next()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;iterator#forEachRemaining-java.util.function.Consumer-&quot;&gt; &lt;code&gt;Iterator.forEachRemaining(java.util.function.Consumer)&lt;/code&gt; &lt;/a&gt;框的原始值的专用子类型默认实现将它们的相应包装器类的实例包装起来。这种拳击可能会抵消使用原始专业化所获得的任何优势。为避免装箱，应使用相应的基于基元的方法。例如，&lt;a href=&quot;primitiveiterator.ofint#nextInt--&quot;&gt; &lt;code&gt;PrimitiveIterator.OfInt.nextInt()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;primitiveiterator.ofint#forEachRemaining-java.util.function.IntConsumer-&quot;&gt; &lt;code&gt;PrimitiveIterator.OfInt.forEachRemaining(java.util.function.IntConsumer)&lt;/code&gt; &lt;/a&gt;应优先用于&lt;a href=&quot;primitiveiterator.ofint#next--&quot;&gt; &lt;code&gt;PrimitiveIterator.OfInt.next()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;primitiveiterator.ofint#forEachRemaining-java.util.function.Consumer-&quot;&gt; &lt;code&gt;PrimitiveIterator.OfInt.forEachRemaining(java.util.function.Consumer)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="50f407aa7fac51cbfd7197c06936b8340a15f9e5" translate="yes" xml:space="preserve">
          <source>The specification and implementation titles, versions, and vendors are unspecified.</source>
          <target state="translated">规范和实现的名称、版本、厂商均未明确。</target>
        </trans-unit>
        <trans-unit id="d6f9034bc2b0e9e47c35477b9b0c1050884a6e58" translate="yes" xml:space="preserve">
          <source>The specification of &lt;a href=&quot;#floatDWidth&quot;&gt;width&lt;/a&gt; and &lt;a href=&quot;#floatDPrec&quot;&gt;precision&lt;/a&gt; is the same as defined for Float and Double.</source>
          <target state="translated">&lt;a href=&quot;#floatDWidth&quot;&gt;宽度&lt;/a&gt;和&lt;a href=&quot;#floatDPrec&quot;&gt;精度&lt;/a&gt;的规格与&amp;ldquo;浮点&amp;rdquo;和&amp;ldquo;双精度&amp;rdquo;的定义相同。</target>
        </trans-unit>
        <trans-unit id="fa9ee937f65b438b3e28d90ed076c5fb130b0ebe" translate="yes" xml:space="preserve">
          <source>The specification of &lt;a href=&quot;#intWidth&quot;&gt;width&lt;/a&gt; is the same as defined for Byte, Short, Integer, and Long.</source>
          <target state="translated">的规格&lt;a href=&quot;#intWidth&quot;&gt;宽度&lt;/a&gt;为字节，短，Integer和Long定义是相同的。</target>
        </trans-unit>
        <trans-unit id="a10ca3cba79e422f1740bb3e0934c522a4f1925b" translate="yes" xml:space="preserve">
          <source>The specification of the &lt;a href=&quot;../nio/charset/charset&quot;&gt;&lt;code&gt;java.nio.charset.Charset&lt;/code&gt;&lt;/a&gt; class describes the naming conventions for character encodings as well as the set of standard encodings that must be supported by every implementation of the Java platform.</source>
          <target state="translated">&lt;a href=&quot;../nio/charset/charset&quot;&gt; &lt;code&gt;java.nio.charset.Charset&lt;/code&gt; &lt;/a&gt;类的规范描述了字符编码的命名约定以及Java平台的每个实现都必须支持的一组标准编码。</target>
        </trans-unit>
        <trans-unit id="5bc479f4b94e6ed3adb52c78855a8eaf971be4f5" translate="yes" xml:space="preserve">
          <source>The specifications of these methods enable implementations to employ efficient machine-level atomic instructions that are available on contemporary processors. However on some platforms, support may entail some form of internal locking. Thus the methods are not strictly guaranteed to be non-blocking -- a thread may block transiently before performing the operation.</source>
          <target state="translated">这些方法的规范使实现能够采用当代处理器上可用的高效机器级原子指令。然而在某些平台上,支持可能需要某种形式的内部锁定。因此,这些方法并不能严格保证是非阻塞的--线程在执行操作之前可能会暂时阻塞。</target>
        </trans-unit>
        <trans-unit id="5249ead0cea582438ce306dee2ff065c9121394e" translate="yes" xml:space="preserve">
          <source>The specified</source>
          <target state="translated">指定的</target>
        </trans-unit>
        <trans-unit id="6ef62c35d30b6f6e7b7d2f2944ffd8af1accdeb5" translate="yes" xml:space="preserve">
          <source>The specified &lt;code&gt;CompositeData&lt;/code&gt; must have the following item names and item types to be valid.</source>
          <target state="translated">指定的 &lt;code&gt;CompositeData&lt;/code&gt; 必须具有以下项目名称和项目类型才有效。</target>
        </trans-unit>
        <trans-unit id="62478b55800b13e9edc844048f06d81a5395c823" translate="yes" xml:space="preserve">
          <source>The specified &lt;code&gt;attributes&lt;/code&gt; is cloned before it is stored in the new &lt;code&gt;SecretKeyEntry&lt;/code&gt; object.</source>
          <target state="translated">在将指定的 &lt;code&gt;attributes&lt;/code&gt; 存储在新的 &lt;code&gt;SecretKeyEntry&lt;/code&gt; 对象中之前，将对其进行克隆。</target>
        </trans-unit>
        <trans-unit id="ce6192f33f7b86e9ead09fddf2eb53ecad7d96e2" translate="yes" xml:space="preserve">
          <source>The specified &lt;code&gt;attributes&lt;/code&gt; is cloned before it is stored in the new &lt;code&gt;TrustedCertificateEntry&lt;/code&gt; object.</source>
          <target state="translated">在将指定的 &lt;code&gt;attributes&lt;/code&gt; 存储在新的 &lt;code&gt;TrustedCertificateEntry&lt;/code&gt; 对象中之前，将对其进行克隆。</target>
        </trans-unit>
        <trans-unit id="d471977883e3ea29098c508c72fa94025049aa80" translate="yes" xml:space="preserve">
          <source>The specified &lt;code&gt;chain&lt;/code&gt; and &lt;code&gt;attributes&lt;/code&gt; are cloned before they are stored in the new &lt;code&gt;PrivateKeyEntry&lt;/code&gt; object.</source>
          <target state="translated">在将指定的 &lt;code&gt;chain&lt;/code&gt; 和 &lt;code&gt;attributes&lt;/code&gt; 存储在新的 &lt;code&gt;PrivateKeyEntry&lt;/code&gt; 对象中之前，将对其进行克隆。</target>
        </trans-unit>
        <trans-unit id="feecfb1f75d3f2369d375a91acbc68cab6f7dc08" translate="yes" xml:space="preserve">
          <source>The specified &lt;code&gt;chain&lt;/code&gt; is cloned before it is stored in the new &lt;code&gt;PrivateKeyEntry&lt;/code&gt; object.</source>
          <target state="translated">在将指定的 &lt;code&gt;chain&lt;/code&gt; 存储到新的 &lt;code&gt;PrivateKeyEntry&lt;/code&gt; 对象中之前，将对其进行克隆。</target>
        </trans-unit>
        <trans-unit id="91787ab6a545bac8438e8b3009f062a3b8a33372" translate="yes" xml:space="preserve">
          <source>The specified &lt;code&gt;name&lt;/code&gt; cannot begin with &quot;&lt;code&gt;java.&lt;/code&gt;&quot;, since all classes in the &quot;&lt;code&gt;java.*&lt;/code&gt; packages can only be defined by the bootstrap class loader. If &lt;code&gt;name&lt;/code&gt; is not &lt;code&gt;null&lt;/code&gt;, it must be equal to the &lt;a href=&quot;#name&quot;&gt;binary name&lt;/a&gt; of the class specified by the byte array &quot;&lt;code&gt;b&lt;/code&gt;&quot;, otherwise a &lt;a href=&quot;noclassdeffounderror&quot;&gt;&lt;code&gt;&lt;code&gt;NoClassDefFoundError&lt;/code&gt;&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">指定的 &lt;code&gt;name&lt;/code&gt; 不能以&amp;ldquo; &lt;code&gt;java.&lt;/code&gt; &amp;rdquo; 开头，因为&amp;ldquo; &lt;code&gt;java.*&lt;/code&gt; 包中的所有类只能由引导类加载器定义。如果 &lt;code&gt;name&lt;/code&gt; 不为 &lt;code&gt;null&lt;/code&gt; ，则它必须等于由java。*指定的类的&lt;a href=&quot;#name&quot;&gt;二进制名称&lt;/a&gt;。字节数组&amp;ldquo; &lt;code&gt;b&lt;/code&gt; &amp;rdquo;，否则将引发&lt;a href=&quot;noclassdeffounderror&quot;&gt; &lt;code&gt;&lt;code&gt;NoClassDefFoundError&lt;/code&gt;&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="eaef74f38f0fefbf6b797c4d769b36b62a96e610" translate="yes" xml:space="preserve">
          <source>The specified &lt;code&gt;password&lt;/code&gt; is cloned before it is stored in the new &lt;code&gt;PasswordProtection&lt;/code&gt; object.</source>
          <target state="translated">在将指定的 &lt;code&gt;password&lt;/code&gt; 存储在新的 &lt;code&gt;PasswordProtection&lt;/code&gt; 对象中之前，将对其进行克隆。</target>
        </trans-unit>
        <trans-unit id="c18dc4bf1e553fd51a6ef779b53c94ede909086a" translate="yes" xml:space="preserve">
          <source>The specified MBean does not exist in the repository.</source>
          <target state="translated">指定的MBean在存储库中不存在。</target>
        </trans-unit>
        <trans-unit id="1da5f575f6552b129ebced03a3fcca62b2e49042" translate="yes" xml:space="preserve">
          <source>The specified MBean listener does not exist in the repository.</source>
          <target state="translated">指定的MBean监听器在版本库中不存在。</target>
        </trans-unit>
        <trans-unit id="af5fc804aa4841cb6f3309cca620e06c665f28ff" translate="yes" xml:space="preserve">
          <source>The specified amount is typically an instance of &lt;code&gt;Period&lt;/code&gt;. Other types are interpreted using &lt;a href=&quot;#from(java.time.temporal.TemporalAmount)&quot;&gt;&lt;code&gt;from(TemporalAmount)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">指定的量通常是 &lt;code&gt;Period&lt;/code&gt; 的一个实例。其他类型使用&lt;a href=&quot;#from(java.time.temporal.TemporalAmount)&quot;&gt; &lt;code&gt;from(TemporalAmount)&lt;/code&gt; &lt;/a&gt;解释。</target>
        </trans-unit>
        <trans-unit id="190c4561e923b6d02247206d09c8f34b9f935a7d" translate="yes" xml:space="preserve">
          <source>The specified amount is typically an instance of &lt;code&gt;Period&lt;/code&gt;. Other types are interpreted using &lt;a href=&quot;period#from-java.time.temporal.TemporalAmount-&quot;&gt;&lt;code&gt;from(TemporalAmount)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">指定的量通常是 &lt;code&gt;Period&lt;/code&gt; 的一个实例。其他类型使用&lt;a href=&quot;period#from-java.time.temporal.TemporalAmount-&quot;&gt; &lt;code&gt;from(TemporalAmount)&lt;/code&gt; &lt;/a&gt;解释。</target>
        </trans-unit>
        <trans-unit id="9f3bf406b8fb479bb6ba897f4dfcf1ddc3eae351" translate="yes" xml:space="preserve">
          <source>The specified amount of real time has elapsed, more or less. If &lt;code&gt;timeout&lt;/code&gt; is zero, however, then real time is not taken into consideration and the thread simply waits until notified.</source>
          <target state="translated">指定的实时量或多或少已经过去。但是，如果 &lt;code&gt;timeout&lt;/code&gt; 为零，则不考虑实时，线程只是等待直到通知。</target>
        </trans-unit>
        <trans-unit id="00452a58dccb117675d49a429b178f798add4786" translate="yes" xml:space="preserve">
          <source>The specified amount of real time has elapsed, more or less. The amount of real time, in nanoseconds, is given by the expression &lt;code&gt;1000000 * timeoutMillis + nanos&lt;/code&gt;. If &lt;code&gt;timeoutMillis&lt;/code&gt; and &lt;code&gt;nanos&lt;/code&gt; are both zero, then real time is not taken into consideration and the thread waits until awakened by one of the other causes.</source>
          <target state="translated">指定的实时量或多或少已经过去。实时量（以纳秒为单位）由表达式 &lt;code&gt;1000000 * timeoutMillis + nanos&lt;/code&gt; 。如果 &lt;code&gt;timeoutMillis&lt;/code&gt; 和 &lt;code&gt;nanos&lt;/code&gt; 均为零，则不考虑实时，线程等待直到其他原因之一唤醒。</target>
        </trans-unit>
        <trans-unit id="2fb0d14ec3b91bd96d9fc6ab5161cd7aea17ba63" translate="yes" xml:space="preserve">
          <source>The specified attribute does not exist or cannot be retrieved.</source>
          <target state="translated">指定的属性不存在或无法检索。</target>
        </trans-unit>
        <trans-unit id="3c4052d464c8f6871afa7336bc62a9e77ae7434b" translate="yes" xml:space="preserve">
          <source>The specified comparator is used to determine if two array elements from the each array are not equal.</source>
          <target state="translated">指定的比较器用于判断每个数组中的两个数组元素是否不相等。</target>
        </trans-unit>
        <trans-unit id="2c8613acf6749ef0ed389aa41eb552a29cdf6d0d" translate="yes" xml:space="preserve">
          <source>The specified constructor is invoked with the arguments in the specified argument list. The invocation is synchronous; this method does not return until the constructor returns in the target VM. If the invoked method throws an exception, this method will throw an &lt;a href=&quot;invocationexception&quot;&gt;&lt;code&gt;InvocationException&lt;/code&gt;&lt;/a&gt; which contains a mirror to the exception object thrown.</source>
          <target state="translated">使用指定参数列表中的参数调用指定的构造函数。调用是同步的；直到构造函数在目标VM中返回后，该方法才返回。如果调用的方法引发异常，则此方法将引发&lt;a href=&quot;invocationexception&quot;&gt; &lt;code&gt;InvocationException&lt;/code&gt; &lt;/a&gt;，其中包含所引发的异常对象的镜像。</target>
        </trans-unit>
        <trans-unit id="7b8d3e0653b6d1561f69a4fc51247490be2c9fff" translate="yes" xml:space="preserve">
          <source>The specified deadline elapses; or</source>
          <target state="translated">规定的期限已过;或</target>
        </trans-unit>
        <trans-unit id="dfc1facec1624a9e49107544937a16179ab58cc9" translate="yes" xml:space="preserve">
          <source>The specified deadline passes; or</source>
          <target state="translated">规定的最后期限过去;或</target>
        </trans-unit>
        <trans-unit id="5247131e5691f2b17d264ef1c3dfc670058c9a69" translate="yes" xml:space="preserve">
          <source>The specified default value.</source>
          <target state="translated">指定的默认值。</target>
        </trans-unit>
        <trans-unit id="5b4866a14164fbbb9168f172b4e6e8d7dc395270" translate="yes" xml:space="preserve">
          <source>The specified dimensions are used to locate a matching &lt;code&gt;MediaSize&lt;/code&gt; instance from amongst all the standard &lt;code&gt;MediaSize&lt;/code&gt; instances.</source>
          <target state="translated">指定尺寸被用于定位一个匹配 &lt;code&gt;MediaSize&lt;/code&gt; 从在所有的标准实例 &lt;code&gt;MediaSize&lt;/code&gt; 实例。</target>
        </trans-unit>
        <trans-unit id="f68d5b41f2fafda46b89738c8f86f8e066852d0c" translate="yes" xml:space="preserve">
          <source>The specified dimensions are used to locate a matching &lt;code&gt;MediaSize&lt;/code&gt; instance from amongst all the standard &lt;code&gt;MediaSize&lt;/code&gt; instances. If there is no exact match, the closest match is used.</source>
          <target state="translated">指定尺寸被用于定位一个匹配 &lt;code&gt;MediaSize&lt;/code&gt; 从在所有的标准实例 &lt;code&gt;MediaSize&lt;/code&gt; 实例。如果没有精确匹配，则使用最接近的匹配。</target>
        </trans-unit>
        <trans-unit id="310ae4a82260e2743fd9957091b33702914d499e" translate="yes" xml:space="preserve">
          <source>The specified dimensions are used to locate a matching MediaSize instance from amongst all the standard MediaSize instances. If there is no exact match, the closest match is used.</source>
          <target state="translated">指定的尺寸用于从所有标准 MediaSize 实例中查找匹配的 MediaSize 实例。如果没有完全匹配的实例,则使用最接近的匹配实例。</target>
        </trans-unit>
        <trans-unit id="104dce0f8cf047aa941594c95f88524f18e28ce2" translate="yes" xml:space="preserve">
          <source>The specified list must be modifiable, but need not be resizable.</source>
          <target state="translated">指定的列表必须是可修改的,但不需要调整大小。</target>
        </trans-unit>
        <trans-unit id="8f09ffd7e81a93fd6948e5a765fff32edb59db61" translate="yes" xml:space="preserve">
          <source>The specified map contains the current state of the parse. The map is mutable and must be mutated to resolve the field and any related fields. This method will only be invoked during parsing if the map contains this field, and implementations should therefore assume this field is present.</source>
          <target state="translated">指定的映射包含解析的当前状态。该地图是可突变的,必须进行突变才能解析该字段和任何相关字段。只有当地图包含这个字段时,才会在解析过程中调用这个方法,因此,实现者应该假设这个字段是存在的。</target>
        </trans-unit>
        <trans-unit id="493032b220120145406a2c95c31eb22182fdc14e" translate="yes" xml:space="preserve">
          <source>The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:</source>
          <target state="translated">在调用本方法时,指定的map必须是空的,并且在本方法返回后不应该直接访问。如果地图被创建为空,直接传递给本方法,并且不保留对地图的引用,这些条件就得到了保证,如下代码片段所示。</target>
        </trans-unit>
        <trans-unit id="5458edf560d4ce470bc3f0200d198b4f628d8da9" translate="yes" xml:space="preserve">
          <source>The specified method is invoked with the arguments in the specified argument list. The method invocation is synchronous; this method does not return until the invoked method returns in the target VM. If the invoked method throws an exception, this method will throw an &lt;a href=&quot;invocationexception&quot;&gt;&lt;code&gt;InvocationException&lt;/code&gt;&lt;/a&gt; which contains a mirror to the exception object thrown.</source>
          <target state="translated">使用指定参数列表中的参数调用指定方法。方法调用是同步的；直到被调用的方法在目标VM中返回之前，此方法不会返回。如果调用的方法引发异常，则此方法将引发&lt;a href=&quot;invocationexception&quot;&gt; &lt;code&gt;InvocationException&lt;/code&gt; &lt;/a&gt;，其中包含所引发的异常对象的镜像。</target>
        </trans-unit>
        <trans-unit id="e8d2949ab1852b4adf83258648df2f3d3aea9bdc" translate="yes" xml:space="preserve">
          <source>The specified number of bytes have been read,</source>
          <target state="translated">已读取指定数量的字节。</target>
        </trans-unit>
        <trans-unit id="04268be0844ec6f86b3371c45be5d6b167be71f6" translate="yes" xml:space="preserve">
          <source>The specified number of characters have been read,</source>
          <target state="translated">已读取指定数量的字符。</target>
        </trans-unit>
        <trans-unit id="9c75e9930b115a843435f6e70515c2fbf02a4ce1" translate="yes" xml:space="preserve">
          <source>The specified path is added to the end of the classpath used in eval().</source>
          <target state="translated">指定的路径被添加到eval()中使用的classpath的末尾。</target>
        </trans-unit>
        <trans-unit id="2c0a2d50122bd703c21aacfe280b277010cfa080" translate="yes" xml:space="preserve">
          <source>The specified path is added to the end of the classpath used in eval(). Note that the unnamed package is not accessible from the package in which &lt;a href=&quot;#eval(java.lang.String)&quot;&gt;&lt;code&gt;eval(String)&lt;/code&gt;&lt;/a&gt; code is placed.</source>
          <target state="translated">指定的路径将添加到eval（）中使用的类路径的末尾。请注意，未命名的程序包无法从放置&lt;a href=&quot;#eval(java.lang.String)&quot;&gt; &lt;code&gt;eval(String)&lt;/code&gt; &lt;/a&gt;代码的程序包中访问。</target>
        </trans-unit>
        <trans-unit id="8b6cc3dc228a55bbb5be0ad0c4aa456b38c93c73" translate="yes" xml:space="preserve">
          <source>The specified stream is closed after this method returns.</source>
          <target state="translated">本方法返回后,指定的流被关闭。</target>
        </trans-unit>
        <trans-unit id="51786fb87bcf180e4b0079696fd451f32baf2367" translate="yes" xml:space="preserve">
          <source>The specified stream remains open after this method returns.</source>
          <target state="translated">在本方法返回后,指定的流仍然开放。</target>
        </trans-unit>
        <trans-unit id="7526737a0fdb5c1ec28cb0f7e645a738da9f21ee" translate="yes" xml:space="preserve">
          <source>The specified string</source>
          <target state="translated">指定的字符串</target>
        </trans-unit>
        <trans-unit id="020eb4b0a71ae7c3e458a5afa3348d57de83d3bc" translate="yes" xml:space="preserve">
          <source>The specified substring. If the sum of &lt;code&gt;offset&lt;/code&gt; and &lt;code&gt;count&lt;/code&gt; exceeds the &lt;code&gt;length&lt;/code&gt;, then all 16-bit units to the end of the data are returned.</source>
          <target state="translated">指定的子字符串。如果 &lt;code&gt;offset&lt;/code&gt; 和 &lt;code&gt;count&lt;/code&gt; 的总和超过 &lt;code&gt;length&lt;/code&gt; ，则返回到数据末尾的所有16位单元。</target>
        </trans-unit>
        <trans-unit id="2615e62cfbfda5abfd51b12dbda35048bb40079b" translate="yes" xml:space="preserve">
          <source>The specified temporal must have the same chronology as this period. This returns a temporal with the non-zero supported units added.</source>
          <target state="translated">指定的时间轴必须与这个时间段有相同的时间顺序。这将返回一个添加了非零支持单位的时间轴。</target>
        </trans-unit>
        <trans-unit id="157250d9b4b02aeb6925cbf93c8ae0c1bd6e00ac" translate="yes" xml:space="preserve">
          <source>The specified temporal must have the same chronology as this period. This returns a temporal with the non-zero supported units subtracted.</source>
          <target state="translated">指定的时间轴必须与这个时间段有相同的时间顺序。这将返回一个减去非零支持单位的时间轴。</target>
        </trans-unit>
        <trans-unit id="cc9a505a8f5c31216ff0ecff5662a313bc10a9ec" translate="yes" xml:space="preserve">
          <source>The specified temporal objects must support the &lt;a href=&quot;temporal/chronounit#SECONDS&quot;&gt;&lt;code&gt;SECONDS&lt;/code&gt;&lt;/a&gt; unit. For full accuracy, either the &lt;a href=&quot;temporal/chronounit#NANOS&quot;&gt;&lt;code&gt;NANOS&lt;/code&gt;&lt;/a&gt; unit or the &lt;a href=&quot;temporal/chronofield#NANO_OF_SECOND&quot;&gt;&lt;code&gt;NANO_OF_SECOND&lt;/code&gt;&lt;/a&gt; field should be supported.</source>
          <target state="translated">指定的时间对象必须支持&lt;a href=&quot;temporal/chronounit#SECONDS&quot;&gt; &lt;code&gt;SECONDS&lt;/code&gt; &lt;/a&gt;单元。为了获得完全的准确性，应支持&lt;a href=&quot;temporal/chronounit#NANOS&quot;&gt; &lt;code&gt;NANOS&lt;/code&gt; &lt;/a&gt;单位或&lt;a href=&quot;temporal/chronofield#NANO_OF_SECOND&quot;&gt; &lt;code&gt;NANO_OF_SECOND&lt;/code&gt; &lt;/a&gt;字段。</target>
        </trans-unit>
        <trans-unit id="48aa14ed6ed221e27d9f2cd6ffaee94b553e7c4d" translate="yes" xml:space="preserve">
          <source>The specified thread must be suspended.</source>
          <target state="translated">指定的线程必须暂停。</target>
        </trans-unit>
        <trans-unit id="9126ea58e2571bc036db8beb3f6e7cb81714d752" translate="yes" xml:space="preserve">
          <source>The specified timeout elapses; or</source>
          <target state="translated">指定的超时时间已过;或</target>
        </trans-unit>
        <trans-unit id="6c00c0e0136e5f97f317610379bde9404184da35" translate="yes" xml:space="preserve">
          <source>The specified title as a string.</source>
          <target state="translated">指定的标题为字符串。</target>
        </trans-unit>
        <trans-unit id="77816529a97b17e719694d443a16cc6eb0b2358f" translate="yes" xml:space="preserve">
          <source>The specified value is used for components that do not have an explicit visibility specified.</source>
          <target state="translated">指定的值用于没有指定显式可见性的组件。</target>
        </trans-unit>
        <trans-unit id="b837498e4f5bfb7ecf362b5a40901bb42bb72876" translate="yes" xml:space="preserve">
          <source>The specified waiting time elapses</source>
          <target state="translated">指定的等待时间已过</target>
        </trans-unit>
        <trans-unit id="2e16f4e41d2bec157ff32585a40c8df18c39455f" translate="yes" xml:space="preserve">
          <source>The specified waiting time elapses.</source>
          <target state="translated">指定的等待时间过去了。</target>
        </trans-unit>
        <trans-unit id="f6172c989e04cb91e71e97089eeadbcfd41054bf" translate="yes" xml:space="preserve">
          <source>The specified waiting time elapses; or</source>
          <target state="translated">指定的等待时间已过;或</target>
        </trans-unit>
        <trans-unit id="bcb09cd9d5c1d9cff3d8db3594d6e42aab3b0b8d" translate="yes" xml:space="preserve">
          <source>The spinner that we're a UI delegate for.</source>
          <target state="translated">我们是一个UI代表的旋转器。</target>
        </trans-unit>
        <trans-unit id="97f64657e5f059399930d54a08e9b83baa27ae28" translate="yes" xml:space="preserve">
          <source>The spinner that we're a UI delegate for. Initialized by the &lt;code&gt;installUI&lt;/code&gt; method, and reset to null by &lt;code&gt;uninstallUI&lt;/code&gt;.</source>
          <target state="translated">我们是UI委托的微调器。由 &lt;code&gt;installUI&lt;/code&gt; 方法初始化，并由 &lt;code&gt;uninstallUI&lt;/code&gt; 重置为null 。</target>
        </trans-unit>
        <trans-unit id="d585405edcff8efbfeceb28b75b5f670d57bbe62" translate="yes" xml:space="preserve">
          <source>The splash screen can be displayed at application startup, before the Java Virtual Machine (JVM) starts.</source>
          <target state="translated">闪屏可以在应用程序启动时,即Java虚拟机(JVM)启动前显示。</target>
        </trans-unit>
        <trans-unit id="799c8129c9adc3cde63003661b566735c720a9dc" translate="yes" xml:space="preserve">
          <source>The splash screen can be displayed at application startup, before the Java Virtual Machine (JVM) starts. The splash screen is displayed as an undecorated window containing an image. You can use GIF, JPEG, or PNG files for the image. Animation is supported for the GIF format, while transparency is supported both for GIF and PNG. The window is positioned at the center of the screen. The position on multi-monitor systems is not specified. It is platform and implementation dependent. The splash screen window is closed automatically as soon as the first window is displayed by Swing/AWT (may be also closed manually using the Java API, see below).</source>
          <target state="translated">闪屏可以在应用程序启动时,即Java虚拟机(JVM)启动前显示。闪屏显示为包含图像的无装饰窗口。您可以为图像使用GIF、JPEG或PNG文件。GIF格式支持动画,而GIF和PNG都支持透明度。窗口定位在屏幕的中心。多显示器系统上的位置没有指定。它取决于平台和实现。一旦第一个窗口被Swing/AWT显示,闪屏窗口就会自动关闭(也可以使用Java API手动关闭,见下文)。</target>
        </trans-unit>
        <trans-unit id="b1c8f20ff40da3f5e74a84ba6b16f559f12b32df" translate="yes" xml:space="preserve">
          <source>The splash screen will be displayed as faithfully as possible to present the whole splash screen image given the limitations of the target platform and display.</source>
          <target state="translated">考虑到目标平台和显示方式的限制,闪屏将尽可能忠实地呈现整个闪屏图像。</target>
        </trans-unit>
        <trans-unit id="358fe8f4c03c65db9f92645925be98830ef03da4" translate="yes" xml:space="preserve">
          <source>The spliterator is &lt;em&gt;&lt;a href=&quot;spliterator#binding&quot;&gt;late-binding&lt;/a&gt;&lt;/em&gt;, inherits the &lt;em&gt;fail-fast&lt;/em&gt; properties of the collection's iterator, and implements &lt;code&gt;trySplit&lt;/code&gt; to permit limited parallelism.</source>
          <target state="translated">分离器是&lt;em&gt;&lt;a href=&quot;spliterator#binding&quot;&gt;后期绑定的&lt;/a&gt;&lt;/em&gt;，继承了集合的迭代器&lt;em&gt;的快速失败&lt;/em&gt;属性，并实现了 &lt;code&gt;trySplit&lt;/code&gt; 以允许有限的并行性。</target>
        </trans-unit>
        <trans-unit id="5c3d939c98fbccf6b0709b1993b6b3ad3fbfd412" translate="yes" xml:space="preserve">
          <source>The spliterator is not &lt;em&gt;&lt;a href=&quot;spliterator#binding&quot;&gt;late-binding&lt;/a&gt;&lt;/em&gt;, inherits the &lt;em&gt;fail-fast&lt;/em&gt; properties of the iterator, and implements &lt;code&gt;trySplit&lt;/code&gt; to permit limited parallelism.</source>
          <target state="translated">分离器不是&lt;em&gt;&lt;a href=&quot;spliterator#binding&quot;&gt;后期绑定的&lt;/a&gt;&lt;/em&gt;，它继承了迭代器&lt;em&gt;的快速失败&lt;/em&gt;属性，并实现了 &lt;code&gt;trySplit&lt;/code&gt; 以允许有限的并行性。</target>
        </trans-unit>
        <trans-unit id="c89136b191a7ef1fb716259822efc70d2b8982ba" translate="yes" xml:space="preserve">
          <source>The spliterator is only traversed, split, or queried for estimated size after the terminal operation of the stream pipeline commences.</source>
          <target state="translated">劈裂器只有在流管线的终端操作开始后,才会进行遍历、劈裂或查询估计尺寸。</target>
        </trans-unit>
        <trans-unit id="2e796cc75190234b6abcae4603bbe835004bc5ff" translate="yes" xml:space="preserve">
          <source>The spliterator provides a snapshot of the state of the list when the spliterator was constructed. No synchronization is needed while operating on the spliterator.</source>
          <target state="translated">分割器提供了分割器构造时列表状态的快照。在分割器上操作时不需要同步。</target>
        </trans-unit>
        <trans-unit id="cb6fc47357accd5ef236f3f5c242ba1b0d8c1cb4" translate="yes" xml:space="preserve">
          <source>The spliterator provides a snapshot of the state of the set when the spliterator was constructed. No synchronization is needed while operating on the spliterator.</source>
          <target state="translated">分割器提供了分割器构建时集合状态的快照。在分割器上操作时不需要同步。</target>
        </trans-unit>
        <trans-unit id="8c63ef1d32be1189c32d967974dfe2fc9a2f274a" translate="yes" xml:space="preserve">
          <source>The spliterator reports &lt;a href=&quot;spliterator#SIZED&quot;&gt;&lt;code&gt;Spliterator.SIZED&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;spliterator#SUBSIZED&quot;&gt;&lt;code&gt;Spliterator.SUBSIZED&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;spliterator#ORDERED&quot;&gt;&lt;code&gt;Spliterator.ORDERED&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;spliterator#IMMUTABLE&quot;&gt;&lt;code&gt;Spliterator.IMMUTABLE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">拆分器报告&lt;a href=&quot;spliterator#SIZED&quot;&gt; &lt;code&gt;Spliterator.SIZED&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;spliterator#SUBSIZED&quot;&gt; &lt;code&gt;Spliterator.SUBSIZED&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;spliterator#ORDERED&quot;&gt; &lt;code&gt;Spliterator.ORDERED&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;spliterator#IMMUTABLE&quot;&gt; &lt;code&gt;Spliterator.IMMUTABLE&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c0e1fd6ad7e570320cb5c4dec58534b0c8203896" translate="yes" xml:space="preserve">
          <source>The spliterator's comparator (see &lt;a href=&quot;../spliterator#getComparator--&quot;&gt;&lt;code&gt;Spliterator.getComparator()&lt;/code&gt;&lt;/a&gt;) is &lt;code&gt;null&lt;/code&gt; if the set's comparator (see &lt;a href=&quot;concurrentskiplistset#comparator--&quot;&gt;&lt;code&gt;comparator()&lt;/code&gt;&lt;/a&gt;) is &lt;code&gt;null&lt;/code&gt;. Otherwise, the spliterator's comparator is the same as or imposes the same total ordering as the set's comparator.</source>
          <target state="translated">如果集合的比较器（请参见&lt;a href=&quot;../spliterator#getComparator--&quot;&gt; &lt;code&gt;Spliterator.getComparator()&lt;/code&gt; &lt;/a&gt;）为 &lt;code&gt;null&lt;/code&gt; ,则分隔器的比较器（请参见Spliterator.getComparator &lt;a href=&quot;concurrentskiplistset#comparator--&quot;&gt; &lt;code&gt;comparator()&lt;/code&gt; &lt;/a&gt;）为 &lt;code&gt;null&lt;/code&gt; 。否则，分离器的比较器与集合的比较器相同或施加相同的总排序。</target>
        </trans-unit>
        <trans-unit id="fe057f9948defb315751a3ca1f88f4994c9e14dd" translate="yes" xml:space="preserve">
          <source>The spliterator's comparator (see &lt;a href=&quot;spliterator#getComparator()&quot;&gt;&lt;code&gt;Spliterator.getComparator()&lt;/code&gt;&lt;/a&gt;) is &lt;code&gt;null&lt;/code&gt; if the tree set's comparator (see &lt;a href=&quot;sortedset#comparator()&quot;&gt;&lt;code&gt;SortedSet.comparator()&lt;/code&gt;&lt;/a&gt;) is &lt;code&gt;null&lt;/code&gt;. Otherwise, the spliterator's comparator is the same as or imposes the same total ordering as the tree set's comparator.</source>
          <target state="translated">该spliterator的比较（见&lt;a href=&quot;spliterator#getComparator()&quot;&gt; &lt;code&gt;Spliterator.getComparator()&lt;/code&gt; &lt;/a&gt;）是 &lt;code&gt;null&lt;/code&gt; ，如果树集的比较（见&lt;a href=&quot;sortedset#comparator()&quot;&gt; &lt;code&gt;SortedSet.comparator()&lt;/code&gt; &lt;/a&gt;）为 &lt;code&gt;null&lt;/code&gt; 。否则，分割器的比较器与树集的比较器相同或施加相同的总排序。</target>
        </trans-unit>
        <trans-unit id="f6b692dffef505c29f727633715bcaa25d9f58af" translate="yes" xml:space="preserve">
          <source>The spliterator's comparator (see &lt;a href=&quot;spliterator#getComparator()&quot;&gt;&lt;code&gt;Spliterator.getComparator()&lt;/code&gt;&lt;/a&gt;) must be &lt;code&gt;null&lt;/code&gt; if the sorted set's comparator (see &lt;a href=&quot;#comparator()&quot;&gt;&lt;code&gt;comparator()&lt;/code&gt;&lt;/a&gt;) is &lt;code&gt;null&lt;/code&gt;. Otherwise, the spliterator's comparator must be the same as or impose the same total ordering as the sorted set's comparator.</source>
          <target state="translated">该spliterator的比较（见&lt;a href=&quot;spliterator#getComparator()&quot;&gt; &lt;code&gt;Spliterator.getComparator()&lt;/code&gt; &lt;/a&gt;）必须是 &lt;code&gt;null&lt;/code&gt; 如果有序set的比较（见&lt;a href=&quot;#comparator()&quot;&gt; &lt;code&gt;comparator()&lt;/code&gt; &lt;/a&gt;）为 &lt;code&gt;null&lt;/code&gt; 。否则，分隔符的比较器必须与排序集的比较器相同或施加相同的总排序。</target>
        </trans-unit>
        <trans-unit id="48dde829f5e209bbf80a37d8886c87c609c3d85b" translate="yes" xml:space="preserve">
          <source>The spliterator's comparator (see &lt;a href=&quot;spliterator#getComparator--&quot;&gt;&lt;code&gt;Spliterator.getComparator()&lt;/code&gt;&lt;/a&gt;) is &lt;code&gt;null&lt;/code&gt; if the tree set's comparator (see &lt;a href=&quot;treeset#comparator--&quot;&gt;&lt;code&gt;comparator()&lt;/code&gt;&lt;/a&gt;) is &lt;code&gt;null&lt;/code&gt;. Otherwise, the spliterator's comparator is the same as or imposes the same total ordering as the tree set's comparator.</source>
          <target state="translated">如果树集的比较器（请参见&lt;a href=&quot;spliterator#getComparator--&quot;&gt; &lt;code&gt;Spliterator.getComparator()&lt;/code&gt; &lt;/a&gt;）为 &lt;code&gt;null&lt;/code&gt; ,则分隔器的比较器（请参见Spliterator.getComparator &lt;a href=&quot;treeset#comparator--&quot;&gt; &lt;code&gt;comparator()&lt;/code&gt; &lt;/a&gt;）为 &lt;code&gt;null&lt;/code&gt; 。否则，分割器的比较器与树集的比较器相同或施加相同的总排序。</target>
        </trans-unit>
        <trans-unit id="5d0a078e5e6eab06b16fc00059f9764476f503fd" translate="yes" xml:space="preserve">
          <source>The spliterator's comparator (see &lt;a href=&quot;spliterator#getComparator--&quot;&gt;&lt;code&gt;Spliterator.getComparator()&lt;/code&gt;&lt;/a&gt;) must be &lt;code&gt;null&lt;/code&gt; if the sorted set's comparator (see &lt;a href=&quot;sortedset#comparator--&quot;&gt;&lt;code&gt;comparator()&lt;/code&gt;&lt;/a&gt;) is &lt;code&gt;null&lt;/code&gt;. Otherwise, the spliterator's comparator must be the same as or impose the same total ordering as the sorted set's comparator.</source>
          <target state="translated">该spliterator的比较（见&lt;a href=&quot;spliterator#getComparator--&quot;&gt; &lt;code&gt;Spliterator.getComparator()&lt;/code&gt; &lt;/a&gt;）必须是 &lt;code&gt;null&lt;/code&gt; 如果有序set的比较（见&lt;a href=&quot;sortedset#comparator--&quot;&gt; &lt;code&gt;comparator()&lt;/code&gt; &lt;/a&gt;）为 &lt;code&gt;null&lt;/code&gt; 。否则，分隔符的比较器必须与排序集的比较器相同或施加相同的总排序。</target>
        </trans-unit>
        <trans-unit id="81c6f54339613405ef47fa4cf7fd2cfc6963fe4e" translate="yes" xml:space="preserve">
          <source>The spliterators for &lt;code&gt;Collection&lt;/code&gt; classes in the JDK that implement &lt;a href=&quot;navigableset&quot;&gt;&lt;code&gt;NavigableSet&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;sortedset&quot;&gt;&lt;code&gt;SortedSet&lt;/code&gt;&lt;/a&gt; report &lt;code&gt;SORTED&lt;/code&gt;.</source>
          <target state="translated">JDK中实现&lt;a href=&quot;navigableset&quot;&gt; &lt;code&gt;NavigableSet&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;sortedset&quot;&gt; &lt;code&gt;SortedSet&lt;/code&gt; 的&lt;/a&gt; &lt;code&gt;Collection&lt;/code&gt; 类的拆分器报告 &lt;code&gt;SORTED&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cd697bf3371b30cc43133d20204f9b133ffb8c0e" translate="yes" xml:space="preserve">
          <source>The spliterators returned by the spliterator method of the collections returned by all of this class's collection view methods are &lt;em&gt;&lt;a href=&quot;spliterator#binding&quot;&gt;late-binding&lt;/a&gt;&lt;/em&gt;, &lt;em&gt;fail-fast&lt;/em&gt;, and additionally report &lt;a href=&quot;spliterator#ORDERED&quot;&gt;&lt;code&gt;Spliterator.ORDERED&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">由所有此类的集合视图方法返回的集合的spliterator方法返回的分隔器为&lt;em&gt;&lt;a href=&quot;spliterator#binding&quot;&gt;后期绑定&lt;/a&gt;&lt;/em&gt;，&lt;em&gt;fail-fast&lt;/em&gt;，并另外报告&lt;a href=&quot;spliterator#ORDERED&quot;&gt; &lt;code&gt;Spliterator.ORDERED&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3f5421d4c1a6fd2ddf5564c1dd18506c0df41358" translate="yes" xml:space="preserve">
          <source>The spliterators returned by the spliterator method of the collections returned by all of this class's collection view methods are created from the iterators of the corresponding collections.</source>
          <target state="translated">本类所有集合视图方法返回的集合的splititerator方法所返回的splititerator是由相应集合的迭代器创建的。</target>
        </trans-unit>
        <trans-unit id="9f0eea49dd34a9dc6611340a54bee1813909e27a" translate="yes" xml:space="preserve">
          <source>The square root of a number numerically equal to &lt;code&gt;
 ZERO&lt;/code&gt; is numerically equal to &lt;code&gt;ZERO&lt;/code&gt; with a preferred scale according to the general rule above. In particular, for &lt;code&gt;ZERO&lt;/code&gt;, &lt;code&gt;ZERO.sqrt(mc).equals(ZERO)&lt;/code&gt; is true with any &lt;code&gt;MathContext&lt;/code&gt; as an argument.</source>
          <target state="translated">一个数的平方根数值上等于 &lt;code&gt; ZERO&lt;/code&gt; 在数值上等于 &lt;code&gt;ZERO&lt;/code&gt; 与根据上述的一般规则的优选比例。特别是，对于 &lt;code&gt;ZERO&lt;/code&gt; ，对于任何 &lt;code&gt;MathContext&lt;/code&gt; 作为参数， &lt;code&gt;ZERO.sqrt(mc).equals(ZERO)&lt;/code&gt; 为真。</target>
        </trans-unit>
        <trans-unit id="78e9aaccc7e1f2b7c96d28e2bb5525d00bd5e897" translate="yes" xml:space="preserve">
          <source>The stack can be queried by methods on &lt;code&gt;Exception&lt;/code&gt;. Note that in stack trace frames representing JShell Snippets, &lt;code&gt;StackTraceElement.getFileName()&lt;/code&gt; will return &quot;#&quot; followed by the Snippet id and for snippets without a method name (for example an expression) &lt;code&gt;StackTraceElement.getName()&lt;/code&gt; will be the empty string.</source>
          <target state="translated">可以通过 &lt;code&gt;Exception&lt;/code&gt; 上的方法查询堆栈。请注意，在表示JShell片断，堆栈跟踪帧 &lt;code&gt;StackTraceElement.getFileName()&lt;/code&gt; 将返回&amp;ldquo;＃&amp;rdquo;后面的片段ID和片段而不方法名称（例如表达） &lt;code&gt;StackTraceElement.getName()&lt;/code&gt; 将是空字符串。</target>
        </trans-unit>
        <trans-unit id="97a32597a130645adffb584e7165020d15f080bc" translate="yes" xml:space="preserve">
          <source>The standard &lt;code&gt;MultipleDocumentHandling&lt;/code&gt; values are:</source>
          <target state="translated">标准的 &lt;code&gt;MultipleDocumentHandling&lt;/code&gt; 值为：</target>
        </trans-unit>
        <trans-unit id="ec658a969bcb92aa1baad080b6a1974cf0ea66e2" translate="yes" xml:space="preserve">
          <source>The standard AC chrominance Huffman table.</source>
          <target state="translated">标准的交流色度赫夫曼表。</target>
        </trans-unit>
        <trans-unit id="de7f2a4797f9371ba730de4782f10f7289878bf4" translate="yes" xml:space="preserve">
          <source>The standard AC luminance Huffman table.</source>
          <target state="translated">标准的交流亮度赫夫曼表。</target>
        </trans-unit>
        <trans-unit id="c018ce1af2d766ca3e1a4abc0ceaf42164f207ce" translate="yes" xml:space="preserve">
          <source>The standard DC chrominance Huffman table.</source>
          <target state="translated">标准的直流色度赫夫曼表。</target>
        </trans-unit>
        <trans-unit id="a329f8b4144b879c7b6f5ae550949bccdbf73f49" translate="yes" xml:space="preserve">
          <source>The standard DC luminance Huffman table.</source>
          <target state="translated">标准的直流亮度赫夫曼表。</target>
        </trans-unit>
        <trans-unit id="db8c6341d94f5edfcecbdce8b46d6840a2f9998a" translate="yes" xml:space="preserve">
          <source>The standard MultipleDocumentHandling values are:</source>
          <target state="translated">标准的MultipleDocumentHandling值为:。</target>
        </trans-unit>
        <trans-unit id="cea92758ea1f357e469fa3131a98d496ed04fb3d" translate="yes" xml:space="preserve">
          <source>The standard WebRowSet XML Schema definition is available at the following URI:</source>
          <target state="translated">标准的WebRowSet XML Schema定义可通过以下URI获得。</target>
        </trans-unit>
        <trans-unit id="92cab317859f368c1aae7d7671cb740196644a9d" translate="yes" xml:space="preserve">
          <source>The standard astronomical definition uses a fraction to indicate the time-of-day, thus 3.25 would represent the time 18:00, since days start at midday. This implementation uses an integer and days starting at midnight. The integer value for the Julian Day Number is the astronomical Julian Day value at midday of the date in question. This amounts to the astronomical Julian Day, rounded to an integer &lt;code&gt;JDN = floor(JD + 0.5)&lt;/code&gt;.</source>
          <target state="translated">标准的天文定义使用小数表示一天中的时间，因此3.25表示时间18:00，因为天数从中午开始。此实现使用从午夜开始的整数和天。&amp;ldquo;儒略日数&amp;rdquo;的整数值是有关日期中午的天文&amp;ldquo;儒略日&amp;rdquo;值。这相当于天文儒略日，四舍五入为整数 &lt;code&gt;JDN = floor(JD + 0.5)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="880ecebc89a3bd9ce7264ab7dfc0e29562f0f35f" translate="yes" xml:space="preserve">
          <source>The standard astronomical definition uses a fraction to indicate the time-of-day, where each day is counted from midday to midday. For example, a fraction of 0 represents midday, a fraction of 0.25 represents 18:00, a fraction of 0.5 represents midnight and a fraction of 0.75 represents 06:00.</source>
          <target state="translated">标准的天文学定义是用分数来表示一天的时间,每一天都是从正午开始计算的。例如,0的分数代表正午,0.25的分数代表18点,0.5的分数代表午夜,0.75的分数代表6点。</target>
        </trans-unit>
        <trans-unit id="13ecff8dc7f4fb8e1c0a2ecc7b63b91ab8bf3498" translate="yes" xml:space="preserve">
          <source>The standard bold weight.</source>
          <target state="translated">标准的粗重。</target>
        </trans-unit>
        <trans-unit id="87015164736bf1cd9c8bbb4ea24b900496c33f69" translate="yes" xml:space="preserve">
          <source>The standard class for rendering (displaying) individual cells in a &lt;code&gt;JTable&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;JTable&lt;/code&gt; 中呈现（显示）单个单元格的标准类。</target>
        </trans-unit>
        <trans-unit id="42ca28b6f9992a10a95b6a95ebf901f9b15239be" translate="yes" xml:space="preserve">
          <source>The standard classes and interfaces that a third party vendor has to use in its implementation of a synchronization provider.</source>
          <target state="translated">第三方供应商在实现同步提供商时必须使用的标准类和接口。</target>
        </trans-unit>
        <trans-unit id="f20e3d89b127e95d58c2061d7d4c9dd74ba0ee75" translate="yes" xml:space="preserve">
          <source>The standard classes and interfaces that a third party vendor has to use in its implementation of a synchronization provider. These classes and interfaces are referred to as the Service Provider Interface (SPI). To make it possible for a &lt;code&gt;RowSet&lt;/code&gt; object to use an implementation, the vendor must register it with the &lt;code&gt;SyncFactory&lt;/code&gt; singleton. (See the class comment for &lt;code&gt;SyncProvider&lt;/code&gt; for a full explanation of the registration process and the naming convention to be used.)</source>
          <target state="translated">第三方供应商在实现同步提供程序时必须使用的标准类和接口。这些类和接口称为服务提供者接口（SPI）。为了使 &lt;code&gt;RowSet&lt;/code&gt; 对象可以使用实现，供应商必须在 &lt;code&gt;SyncFactory&lt;/code&gt; 单例中注册它。 （有关注册过程和要使用的命名约定的完整说明，请参见 &lt;code&gt;SyncProvider&lt;/code&gt; 的类注释。）</target>
        </trans-unit>
        <trans-unit id="b131b8a4797ef2827907440045a418e64b3fbf06" translate="yes" xml:space="preserve">
          <source>The standard column-handler for a &lt;code&gt;JTable&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;JTable&lt;/code&gt; 的标准列处理程序。</target>
        </trans-unit>
        <trans-unit id="ebd97f6234307a116f96853fd3903e56b9d40331" translate="yes" xml:space="preserve">
          <source>The standard default domain name is &lt;code&gt;DefaultDomain&lt;/code&gt;.</source>
          <target state="translated">标准的默认域名为 &lt;code&gt;DefaultDomain&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eba1c345bcad3128d67e184f5948f0c758533831" translate="yes" xml:space="preserve">
          <source>The standard doclet supports user-defined &lt;a href=&quot;taglet&quot;&gt;&lt;code&gt;taglets&lt;/code&gt;&lt;/a&gt;, which can be used to generate customized output for user-defined tags in documentation comments. Taglets invoked by the standard doclet must return strings from &lt;a href=&quot;taglet#toString(java.util.List,javax.lang.model.element.Element)&quot;&gt;&lt;code&gt;Taglet.toString&lt;/code&gt;&lt;/a&gt; as follows:</source>
          <target state="translated">标准doclet支持用户定义的&lt;a href=&quot;taglet&quot;&gt; &lt;code&gt;taglets&lt;/code&gt; &lt;/a&gt;，可用于为文档注释中的用户定义的标签生成自定义输出。由标准doclet调用的Taglet必须从&lt;a href=&quot;taglet#toString(java.util.List,javax.lang.model.element.Element)&quot;&gt; &lt;code&gt;Taglet.toString&lt;/code&gt; &lt;/a&gt;返回字符串，如下所示：</target>
        </trans-unit>
        <trans-unit id="ef55295fde5154a258f26679975fa232098fcdbf" translate="yes" xml:space="preserve">
          <source>The standard file manager serves two purposes:</source>
          <target state="translated">标准文件管理器有两个作用。</target>
        </trans-unit>
        <trans-unit id="6b7ea3f0338f77cf538431691011f031baff3b34" translate="yes" xml:space="preserve">
          <source>The standard file manager will be automatically reopened if it is accessed after calls to &lt;code&gt;flush&lt;/code&gt; or &lt;code&gt;close&lt;/code&gt;. The standard file manager must be usable with other tools.</source>
          <target state="translated">如果在调用 &lt;code&gt;flush&lt;/code&gt; 或 &lt;code&gt;close&lt;/code&gt; 之后访问标准文件管理器，它将自动重新打开它。标准文件管理器必须与其他工具一起使用。</target>
        </trans-unit>
        <trans-unit id="d899fd7b1f2ffca29d5ec4be5ab688999a5e0e42" translate="yes" xml:space="preserve">
          <source>The standard interface that all implementations of a &lt;code&gt;WebRowSet&lt;/code&gt; must implement.</source>
          <target state="translated">&lt;code&gt;WebRowSet&lt;/code&gt; 的所有实现都必须实现的标准接口。</target>
        </trans-unit>
        <trans-unit id="68aac4cc5c3cf5132e5aff63b1695213f60c720d" translate="yes" xml:space="preserve">
          <source>The standard interface that all standard implementations of &lt;code&gt;FilteredRowSet&lt;/code&gt; must implement.</source>
          <target state="translated">&lt;code&gt;FilteredRowSet&lt;/code&gt; 的所有标准实现都必须实现的标准接口。</target>
        </trans-unit>
        <trans-unit id="247ee5b52f4343f5290a6af4a99cb5a09ea9f68c" translate="yes" xml:space="preserve">
          <source>The standard interface that all standard implementations of &lt;code&gt;FilteredRowSet&lt;/code&gt; must implement. The &lt;code&gt;FilteredRowSetImpl&lt;/code&gt; class provides the reference implementation which may be extended if required. Alternatively, a vendor is free to implement its own version by implementing this interface.</source>
          <target state="translated">&lt;code&gt;FilteredRowSet&lt;/code&gt; 的所有标准实现都必须实现的标准接口。所述 &lt;code&gt;FilteredRowSetImpl&lt;/code&gt; 类提供的参考实现如果需要的话其可以被延长。另外，供应商可以通过实现此接口来自由实现其自己的版本。</target>
        </trans-unit>
        <trans-unit id="4179729038e158c2938276999d2a0f8a9a828d40" translate="yes" xml:space="preserve">
          <source>The standard interface that all standard implementations of &lt;code&gt;JdbcRowSet&lt;/code&gt; must implement.</source>
          <target state="translated">&lt;code&gt;JdbcRowSet&lt;/code&gt; 的所有标准实现都必须实现的标准接口。</target>
        </trans-unit>
        <trans-unit id="bbf8d9d8dbd72ecf1f4215ba8e97cd7badb383b6" translate="yes" xml:space="preserve">
          <source>The standard interface that provides the framework for all &lt;code&gt;FilteredRowSet&lt;/code&gt; objects to describe their filters.</source>
          <target state="translated">为所有 &lt;code&gt;FilteredRowSet&lt;/code&gt; 对象提供框架以描述其过滤器的标准接口。</target>
        </trans-unit>
        <trans-unit id="f8f169d2bb832c35eba59bc410c0b85f0003b6f8" translate="yes" xml:space="preserve">
          <source>The standard interface to a DSA private key.</source>
          <target state="translated">DSA私钥的标准接口。</target>
        </trans-unit>
        <trans-unit id="be4242d6a22a82129b32c761e9b997ab8bdb7b76" translate="yes" xml:space="preserve">
          <source>The standard interface to a DSA private key. DSA (Digital Signature Algorithm) is defined in NIST's FIPS-186.</source>
          <target state="translated">DSA私钥的标准接口。NIST的FIPS-186中定义了DSA(数字签名算法)。</target>
        </trans-unit>
        <trans-unit id="0aee232c28f9de3b58df1a19a8e2a72c95efd9f7" translate="yes" xml:space="preserve">
          <source>The standard italic posture.</source>
          <target state="translated">标准的楷体姿势。</target>
        </trans-unit>
        <trans-unit id="265e9fc158c49896c41933585c842cef5b8e987f" translate="yes" xml:space="preserve">
          <source>The standard layer, where most components go. This the bottommost layer.</source>
          <target state="translated">标准层,大部分组件都在这里。这是最底层。</target>
        </trans-unit>
        <trans-unit id="7b2b71d5aa7e1b0b260acaadc43d3221dce05731" translate="yes" xml:space="preserve">
          <source>The standard light weight.</source>
          <target state="translated">标准的轻量级。</target>
        </trans-unit>
        <trans-unit id="a8d8726b4a5a07328b176cca7d74f5e2a761a964" translate="yes" xml:space="preserve">
          <source>The standard mapping in the Java programming language for an SQL structured type.</source>
          <target state="translated">在Java编程语言中,SQL结构化类型的标准映射。</target>
        </trans-unit>
        <trans-unit id="c2eeb32dafb015f6f93305e7066122591f181fc8" translate="yes" xml:space="preserve">
          <source>The standard mapping in the Java programming language for an SQL structured type. A &lt;code&gt;Struct&lt;/code&gt; object contains a value for each attribute of the SQL structured type that it represents. By default, an instance of&lt;code&gt;Struct&lt;/code&gt; is valid as long as the application has a reference to it.</source>
          <target state="translated">Java编程语言中用于SQL结构化类型的标准映射。甲 &lt;code&gt;Struct&lt;/code&gt; 对象包含SQL结构类型，它代表的每个属性的值。默认情况下，只要应用程序引用了 &lt;code&gt;Struct&lt;/code&gt; 实例，该实例就是有效的。</target>
        </trans-unit>
        <trans-unit id="c927c0ada9cba1ad53c2c1bf1aa34f20c5ec2c56" translate="yes" xml:space="preserve">
          <source>The standard mental model for a date is based on three concepts - year, month and day. These map onto the &lt;code&gt;YEAR&lt;/code&gt;, &lt;code&gt;MONTH_OF_YEAR&lt;/code&gt; and &lt;code&gt;DAY_OF_MONTH&lt;/code&gt; fields. Note that there is no reference to eras. The full model for a date requires four concepts - era, year, month and day. These map onto the &lt;code&gt;ERA&lt;/code&gt;, &lt;code&gt;YEAR_OF_ERA&lt;/code&gt;, &lt;code&gt;MONTH_OF_YEAR&lt;/code&gt; and &lt;code&gt;DAY_OF_MONTH&lt;/code&gt; fields. Whether this field or &lt;code&gt;YEAR&lt;/code&gt; is used depends on which mental model is being used. See &lt;a href=&quot;../chrono/chronolocaldate&quot;&gt;&lt;code&gt;ChronoLocalDate&lt;/code&gt;&lt;/a&gt; for more discussion on this topic.</source>
          <target state="translated">日期的标准心理模型基于三个概念-年，月和日。这些映射到 &lt;code&gt;YEAR&lt;/code&gt; ， &lt;code&gt;MONTH_OF_YEAR&lt;/code&gt; 和 &lt;code&gt;DAY_OF_MONTH&lt;/code&gt; 字段。请注意，这里没有提到时代。日期的完整模型需要四个概念-时代，年，月和日。这些映射到 &lt;code&gt;ERA&lt;/code&gt; ， &lt;code&gt;YEAR_OF_ERA&lt;/code&gt; ， &lt;code&gt;MONTH_OF_YEAR&lt;/code&gt; 和 &lt;code&gt;DAY_OF_MONTH&lt;/code&gt; 字段。是否使用此字段或 &lt;code&gt;YEAR&lt;/code&gt; 取决于所使用的思维模型。有关此主题的更多讨论，请参见&lt;a href=&quot;../chrono/chronolocaldate&quot;&gt; &lt;code&gt;ChronoLocalDate&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="552969cac10043f5eb1e8db38405b389d7505393" translate="yes" xml:space="preserve">
          <source>The standard mental model for a date is based on three concepts - year, month and day. These map onto the &lt;code&gt;YEAR&lt;/code&gt;, &lt;code&gt;MONTH_OF_YEAR&lt;/code&gt; and &lt;code&gt;DAY_OF_MONTH&lt;/code&gt; fields. Note that there is no reference to eras. The full model for a date requires four concepts - era, year, month and day. These map onto the &lt;code&gt;ERA&lt;/code&gt;, &lt;code&gt;YEAR_OF_ERA&lt;/code&gt;, &lt;code&gt;MONTH_OF_YEAR&lt;/code&gt; and &lt;code&gt;DAY_OF_MONTH&lt;/code&gt; fields. Whether this field or &lt;code&gt;YEAR_OF_ERA&lt;/code&gt; is used depends on which mental model is being used. See &lt;a href=&quot;../chrono/chronolocaldate&quot;&gt;&lt;code&gt;ChronoLocalDate&lt;/code&gt;&lt;/a&gt; for more discussion on this topic.</source>
          <target state="translated">日期的标准心理模型基于三个概念-年，月和日。这些映射到 &lt;code&gt;YEAR&lt;/code&gt; ， &lt;code&gt;MONTH_OF_YEAR&lt;/code&gt; 和 &lt;code&gt;DAY_OF_MONTH&lt;/code&gt; 字段。请注意，这里没有提到时代。日期的完整模型需要四个概念-时代，年，月和日。这些映射到 &lt;code&gt;ERA&lt;/code&gt; ， &lt;code&gt;YEAR_OF_ERA&lt;/code&gt; ， &lt;code&gt;MONTH_OF_YEAR&lt;/code&gt; 和 &lt;code&gt;DAY_OF_MONTH&lt;/code&gt; 字段。是否使用此字段或 &lt;code&gt;YEAR_OF_ERA&lt;/code&gt; 取决于所使用的心理模型。有关此主题的更多讨论，请参见&lt;a href=&quot;../chrono/chronolocaldate&quot;&gt; &lt;code&gt;ChronoLocalDate&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3661c18690ae34088219c95d1f642f9094ca6650" translate="yes" xml:space="preserve">
          <source>The standard posture, upright.</source>
          <target state="translated">标准的姿势,立正。</target>
        </trans-unit>
        <trans-unit id="bcac68430abf1f9b59c3fc0c0ced10c89898d656" translate="yes" xml:space="preserve">
          <source>The standard posture, upright. This is the default value for &lt;code&gt;POSTURE&lt;/code&gt;.</source>
          <target state="translated">标准姿势，直立。这是 &lt;code&gt;POSTURE&lt;/code&gt; 的默认值。</target>
        </trans-unit>
        <trans-unit id="4204acbf3d5f3f85ee9f30f3059d6be897c6a196" translate="yes" xml:space="preserve">
          <source>The standard property-id for a synchronization provider implementation name.</source>
          <target state="translated">同步化提供商实现名称的标准属性标识。</target>
        </trans-unit>
        <trans-unit id="80bb8e7243eb06e9dd0a04e994954134803a7ab1" translate="yes" xml:space="preserve">
          <source>The standard property-id for a synchronization provider implementation vendor name.</source>
          <target state="translated">同步化提供商实施供应商名称的标准属性-id。</target>
        </trans-unit>
        <trans-unit id="f3300fc7bb9dd6b49894aeba609ac649a7e0edb1" translate="yes" xml:space="preserve">
          <source>The standard property-id for a synchronization provider implementation version tag.</source>
          <target state="translated">同步化提供商实现版本标签的标准属性-id。</target>
        </trans-unit>
        <trans-unit id="f924447dc30c0a207a7a8dd003998719d641a65d" translate="yes" xml:space="preserve">
          <source>The standard reference implementation for the &lt;code&gt;CachedRowSet&lt;/code&gt; interface uses a &lt;code&gt;TreeMap&lt;/code&gt; object for the rowset, with the values in each row being contained in &lt;code&gt;Vector&lt;/code&gt; objects. It is expected that most implementations will do the same.</source>
          <target state="translated">&lt;code&gt;CachedRowSet&lt;/code&gt; 接口的标准参考实现将 &lt;code&gt;TreeMap&lt;/code&gt; 对象用于行集，每行中的值都包含在 &lt;code&gt;Vector&lt;/code&gt; 对象中。预计大多数实现将执行相同的操作。</target>
        </trans-unit>
        <trans-unit id="44003f488ebc1e70329a9b7e5361903f72e0de08" translate="yes" xml:space="preserve">
          <source>The standard reference implementation uses a &lt;code&gt;Vector&lt;/code&gt; object to contain the column values, and it is expected that most implementations will do the same. If a &lt;code&gt;Vector&lt;/code&gt; object is used, it size must be exactly equal to the number of rows in this &lt;code&gt;CachedRowSet&lt;/code&gt; object.</source>
          <target state="translated">标准参考实现使用 &lt;code&gt;Vector&lt;/code&gt; 对象包含列值，并且期望大多数实现都将执行此操作。如果使用 &lt;code&gt;Vector&lt;/code&gt; 对象，则其大小必须完全等于此 &lt;code&gt;CachedRowSet&lt;/code&gt; 对象中的行数。</target>
        </trans-unit>
        <trans-unit id="5a269f562c7ddcb5223b4c729ca3aacff15045f7" translate="yes" xml:space="preserve">
          <source>The standard set of non-localized decimal style symbols.</source>
          <target state="translated">标准的非本地化十进制风格符号集。</target>
        </trans-unit>
        <trans-unit id="2aa618fb16592d9504ead37dd1498e07dc1eb2fd" translate="yes" xml:space="preserve">
          <source>The standard target names for an Authentication Permission are:</source>
          <target state="translated">认证权限的标准目标名称是:</target>
        </trans-unit>
        <trans-unit id="085376bdd00c3589b2477d9a9b7e25e5aa764bdf" translate="yes" xml:space="preserve">
          <source>The standard text outputting methods use the localized text in the JDK. This method allows that text to be specified directly. The supplied map is not validated by the builder to ensure that formatting or parsing is possible, thus an invalid map may throw an error during later use.</source>
          <target state="translated">标准文本输出方法使用JDK中的本地化文本。该方法允许直接指定该文本。提供的映射没有经过构建器的验证,以确保格式化或解析是可能的,因此无效的映射可能会在以后的使用中抛出错误。</target>
        </trans-unit>
        <trans-unit id="ace8ff3c243593fda8f90cc8a3f288d71a11483d" translate="yes" xml:space="preserve">
          <source>The standard value of the propertyName as fired from a BeanContext or other source of PropertyChangeEvents.</source>
          <target state="translated">从BeanContext或其他来源的PropertyChangeEvents发射的属性名的标准值。</target>
        </trans-unit>
        <trans-unit id="49ec7e4579c545f03b2dbae2595c4136e74f5f2a" translate="yes" xml:space="preserve">
          <source>The standard weight.</source>
          <target state="translated">标准重量。</target>
        </trans-unit>
        <trans-unit id="062b0e97b7470f28f4677451830d828c09857342" translate="yes" xml:space="preserve">
          <source>The standard weight. This is the default value for &lt;code&gt;WEIGHT&lt;/code&gt;.</source>
          <target state="translated">标准重量。这是 &lt;code&gt;WEIGHT&lt;/code&gt; 的默认值。</target>
        </trans-unit>
        <trans-unit id="5fa2e7b7afa217d5160022594a1240084ec90835" translate="yes" xml:space="preserve">
          <source>The standard width.</source>
          <target state="translated">标准宽度。</target>
        </trans-unit>
        <trans-unit id="1ec1dd1d6de288f3d7a0a8ac09f8cd6fa6f29d04" translate="yes" xml:space="preserve">
          <source>The standard width. This is the default value for &lt;code&gt;WIDTH&lt;/code&gt;.</source>
          <target state="translated">标准宽度。这是 &lt;code&gt;WIDTH&lt;/code&gt; 的默认值。</target>
        </trans-unit>
        <trans-unit id="f3bed9164e92a7973b9cbcd9ad79594c005f0947" translate="yes" xml:space="preserve">
          <source>The start and end points are &lt;code&gt;this&lt;/code&gt; and the specified date. The result will be negative if the end is before the start. The negative sign will be the same in each of year, month and day.</source>
          <target state="translated">起点和终点是 &lt;code&gt;this&lt;/code&gt; 日期和指定的日期。如果结束早于开始，则结果将为负。负号在每年，每月和每天中都相同。</target>
        </trans-unit>
        <trans-unit id="3c2d246e90e00803aeb29283b1b8bc16d249d5bc" translate="yes" xml:space="preserve">
          <source>The start argument must be nonnegative, and not greater than &lt;code&gt;end&lt;/code&gt;.</source>
          <target state="translated">start参数必须为非负且不大于 &lt;code&gt;end&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a4ddf7bb81f0c34d9260c89803dda3e7e413e128" translate="yes" xml:space="preserve">
          <source>The start date is included, but the end date is not. The period is calculated by removing complete months, then calculating the remaining number of days, adjusting to ensure that both have the same sign. The number of months is then normalized into years and months based on a 12 month year. A month is considered to be complete if the end day-of-month is greater than or equal to the start day-of-month. For example, from &lt;code&gt;2010-01-15&lt;/code&gt; to &lt;code&gt;2011-03-18&lt;/code&gt; is &quot;1 year, 2 months and 3 days&quot;.</source>
          <target state="translated">包括开始日期，但不包括结束日期。通过删除完整的月份，然后计算剩余的天数，并进行调整以确保两者具有相同的符号，来计算周期。然后将月数基于12个月的年归一化为年和月。如果月份的结束日期大于或等于月份的开始日期，则认为一个月已完成。例如，从 &lt;code&gt;2010-01-15&lt;/code&gt; 到 &lt;code&gt;2011-03-18&lt;/code&gt; 为&amp;ldquo; 1年2个月3天&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="6620cb9be5fc56436fc3a7c1b18ff6874dd29e0c" translate="yes" xml:space="preserve">
          <source>The start date is included, but the end date is not. The period is calculated by removing complete months, then calculating the remaining number of days, adjusting to ensure that both have the same sign. The number of months is then split into years and months based on a 12 month year. A month is considered if the end day-of-month is greater than or equal to the start day-of-month. For example, from &lt;code&gt;2010-01-15&lt;/code&gt; to &lt;code&gt;2011-03-18&lt;/code&gt; is one year, two months and three days.</source>
          <target state="translated">包括开始日期，但不包括结束日期。通过删除完整的月份，然后计算剩余的天数，并进行调整以确保两者具有相同的符号，来计算周期。然后，将月数基于12个月的年分为年份和月份。如果月的结束日期大于或等于月的开始日期，则考虑一个月。例如，从 &lt;code&gt;2010-01-15&lt;/code&gt; 到 &lt;code&gt;2011-03-18&lt;/code&gt; 是一年零两个月零三天。</target>
        </trans-unit>
        <trans-unit id="7220f597737d970989890a2427aecffcbf28c9bf" translate="yes" xml:space="preserve">
          <source>The start date is included, but the end date is not. The period is calculated using &lt;a href=&quot;chronolocaldate#until(java.time.chrono.ChronoLocalDate)&quot;&gt;&lt;code&gt;ChronoLocalDate.until(ChronoLocalDate)&lt;/code&gt;&lt;/a&gt;. As such, the calculation is chronology specific.</source>
          <target state="translated">包括开始日期，但不包括结束日期。使用&lt;a href=&quot;chronolocaldate#until(java.time.chrono.ChronoLocalDate)&quot;&gt; &lt;code&gt;ChronoLocalDate.until(ChronoLocalDate)&lt;/code&gt; &lt;/a&gt;计算时间段。这样，该计算是按时间顺序的。</target>
        </trans-unit>
        <trans-unit id="9238c2af9e0839f3491092fc2fe2b2c12cadecf1" translate="yes" xml:space="preserve">
          <source>The start date is included, but the end date is not. The period is calculated using &lt;a href=&quot;chronolocaldate#until-java.time.chrono.ChronoLocalDate-&quot;&gt;&lt;code&gt;ChronoLocalDate.until(ChronoLocalDate)&lt;/code&gt;&lt;/a&gt;. As such, the calculation is chronology specific.</source>
          <target state="translated">包括开始日期，但不包括结束日期。使用&lt;a href=&quot;chronolocaldate#until-java.time.chrono.ChronoLocalDate-&quot;&gt; &lt;code&gt;ChronoLocalDate.until(ChronoLocalDate)&lt;/code&gt; &lt;/a&gt;计算时间段。这样，计算是按时间顺序的。</target>
        </trans-unit>
        <trans-unit id="4616505c5d1d5433c8afbd259a8f16eac5343c68" translate="yes" xml:space="preserve">
          <source>The start index of the text sequence.</source>
          <target state="translated">文本序列的起始索引。</target>
        </trans-unit>
        <trans-unit id="2da02a77743138ef2df4ac8502302bd010532bde" translate="yes" xml:space="preserve">
          <source>The start time must be set before starting the stream</source>
          <target state="translated">在开始流之前必须设置开始时间</target>
        </trans-unit>
        <trans-unit id="6becf8d53264f434379756115b0b786e11e4f8c2" translate="yes" xml:space="preserve">
          <source>The startDrag() method invokes the createDragSourceContext() method to instantiate an appropriate &lt;code&gt;DragSourceContext&lt;/code&gt; and associate the &lt;code&gt;DragSourceContextPeer&lt;/code&gt; with that.</source>
          <target state="translated">的startDrag（）方法调用createDragSourceContext（）方法来实例化一个适当 &lt;code&gt;DragSourceContext&lt;/code&gt; 和关联 &lt;code&gt;DragSourceContextPeer&lt;/code&gt; 这一点。</target>
        </trans-unit>
        <trans-unit id="82e2ccda6d83bc11eba880fd5d75e0aa357c29cd" translate="yes" xml:space="preserve">
          <source>The starting angle of the arc in degrees.</source>
          <target state="translated">弧线的起始角度,单位为度。</target>
        </trans-unit>
        <trans-unit id="2264eaa8f12a8a3d18c204a6414263d50eec329f" translate="yes" xml:space="preserve">
          <source>The starting point of this matcher's region</source>
          <target state="translated">该匹配器区域的起点。</target>
        </trans-unit>
        <trans-unit id="711145c27ccf3166aa36ebb810ced05b44da407a" translate="yes" xml:space="preserve">
          <source>The state factories tried must each implement either &lt;code&gt;StateFactory&lt;/code&gt; or &lt;code&gt;DirStateFactory&lt;/code&gt;. If it implements &lt;code&gt;DirStateFactory&lt;/code&gt;, then &lt;code&gt;DirStateFactory.getStateToBind()&lt;/code&gt; is called; otherwise, &lt;code&gt;StateFactory.getStateToBind()&lt;/code&gt; is called.</source>
          <target state="translated">尝试过的状态工厂必须分别实现 &lt;code&gt;StateFactory&lt;/code&gt; 或 &lt;code&gt;DirStateFactory&lt;/code&gt; 。如果实现 &lt;code&gt;DirStateFactory&lt;/code&gt; ，则 &lt;code&gt;DirStateFactory.getStateToBind()&lt;/code&gt; ；否则，将调用DirStateFactory.getStateToBind（）。否则，将调用 &lt;code&gt;StateFactory.getStateToBind()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="069364d5e2bc01251c39eefbdac8ec561989f08f" translate="yes" xml:space="preserve">
          <source>The state information after the edit</source>
          <target state="translated">编辑后的状态信息</target>
        </trans-unit>
        <trans-unit id="78b85e5c07d69b00d4a00829691f1844f46ca899" translate="yes" xml:space="preserve">
          <source>The state information prior to the edit</source>
          <target state="translated">编辑前的状态信息</target>
        </trans-unit>
        <trans-unit id="b4b4593a62342b2b46d5d7ee91609ae7dd334526" translate="yes" xml:space="preserve">
          <source>The state maintained by an instance of &lt;code&gt;ImageReadParam&lt;/code&gt; is independent of any particular image being decoded. When actual decoding takes place, the values set in the read param are combined with the actual properties of the image being decoded from the stream and the destination &lt;code&gt;BufferedImage&lt;/code&gt; that will receive the decoded pixel data. For example, the source region set using &lt;code&gt;setSourceRegion&lt;/code&gt; will first be intersected with the actual valid source area. The result will be translated by the value returned by &lt;code&gt;getDestinationOffset&lt;/code&gt;, and the resulting rectangle intersected with the actual valid destination area to yield the destination area that will be written.</source>
          <target state="translated">由 &lt;code&gt;ImageReadParam&lt;/code&gt; 实例维护的状态与要解码的任何特定图像无关。当实际解码发生时，将在读取参数中设置的值与从流中解码的图像的实际属性以及将接收解码的像素数据的目标 &lt;code&gt;BufferedImage&lt;/code&gt; 组合在一起。例如，使用 &lt;code&gt;setSourceRegion&lt;/code&gt; 设置的源区域将首先与实际的有效源区域相交。结果将由 &lt;code&gt;getDestinationOffset&lt;/code&gt; 返回的值转换，结果矩形与实际的有效目标区域相交以产生将要写入的目标区域。</target>
        </trans-unit>
        <trans-unit id="3a932e6e75d4e4ee973a0e76a7f43125497f0c01" translate="yes" xml:space="preserve">
          <source>The state moves from readable to not readable once free() or any of the reading APIs are called: getBinaryStream(), getCharacterStream(), getSource(), and getString(). Implementations may also change the state to not writable when this occurs.</source>
          <target state="translated">一旦free()或任何一个读取API被调用:getBinaryStream()、getCharacterStream()、getSource()和getString(),状态就会从可读变为不可读。当这种情况发生时,实现也可以将状态改为不可写。</target>
        </trans-unit>
        <trans-unit id="5f6f7bffc98d1e8352d937b1d9d3e6a929292204" translate="yes" xml:space="preserve">
          <source>The state moves from writable to not writable once free() or any of the writing APIs are called: setBinaryStream(), setCharacterStream(), setResult(), and setString(). Implementations may also change the state to not readable when this occurs.</source>
          <target state="translated">一旦free()或任何写API被调用,状态就会从可写变为不可写:setBinaryStream()、setCharacterStream()、setResult()和setString()。当这种情况发生时,实现也可以将状态改为不可读。</target>
        </trans-unit>
        <trans-unit id="5f123d14f73abf8b927161bc953361f29bebc2d2" translate="yes" xml:space="preserve">
          <source>The state of each match result passed to the replacer function is guaranteed to be constant only for the duration of the replacer function call and only if the replacer function does not modify this matcher's state.</source>
          <target state="translated">传递给replacer函数的每个匹配结果的状态,只有在replacer函数调用期间,并且只有在replacer函数没有修改这个匹配器的状态时,才能保证其状态不变。</target>
        </trans-unit>
        <trans-unit id="861a0f2ac6e69c9f80d5a917a538314fa0c92b1d" translate="yes" xml:space="preserve">
          <source>The state of one method invocation on a thread's call stack.</source>
          <target state="translated">线程调用栈中一个方法调用的状态。</target>
        </trans-unit>
        <trans-unit id="cf0481dbb6b7adfb17cade428ef1369a516f361a" translate="yes" xml:space="preserve">
          <source>The state of one method invocation on a thread's call stack. As a thread executes, stack frames are pushed and popped from its call stack as methods are invoked and then return. A StackFrame mirrors one such frame from a target VM at some point in its thread's execution. The call stack is, then, simply a List of StackFrame objects. The call stack can be obtained any time a thread is suspended through a call to &lt;a href=&quot;threadreference#frames()&quot;&gt;&lt;code&gt;ThreadReference.frames()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">线程的调用堆栈上一个方法调用的状态。执行线程时，将在调用方法并返回时将堆栈帧推入并从其调用堆栈中弹出。 StackFrame在其线程执行的某个时刻从目标VM镜像一个这样的帧。因此，调用堆栈只是一个StackFrame对象列表。任何时候通过调用&lt;a href=&quot;threadreference#frames()&quot;&gt; &lt;code&gt;ThreadReference.frames()&lt;/code&gt; &lt;/a&gt;挂起线程都可以获取调用堆栈。</target>
        </trans-unit>
        <trans-unit id="67f87189b7cffe5c4bdbf9a74576a5752597c030" translate="yes" xml:space="preserve">
          <source>The state of resulting file attribute view is intimately connected to this directory stream. Once the directory stream &lt;a href=&quot;../../io/closeable#close()&quot;&gt;&lt;code&gt;closed&lt;/code&gt;&lt;/a&gt;, then all methods to read or update attributes will throw &lt;a href=&quot;closeddirectorystreamexception&quot;&gt;&lt;code&gt;ClosedDirectoryStreamException&lt;/code&gt;&lt;/a&gt;. The file is not required to exist at the time that the file attribute view is created but methods to read or update attributes of the file will fail when invoked and the file does not exist.</source>
          <target state="translated">结果文件属性视图的状态与该目录流紧密相连。目录流&lt;a href=&quot;../../io/closeable#close()&quot;&gt; &lt;code&gt;closed&lt;/code&gt; &lt;/a&gt;，所有读取或更新属性的方法都将引发&lt;a href=&quot;closeddirectorystreamexception&quot;&gt; &lt;code&gt;ClosedDirectoryStreamException&lt;/code&gt; &lt;/a&gt;。创建文件属性视图时不需要文件存在，但是在调用并且文件不存在时读取或更新文件属性的方法将失败。</target>
        </trans-unit>
        <trans-unit id="31371db7bcedb5e6ef0fa2a822080261021c1cbf" translate="yes" xml:space="preserve">
          <source>The state of resulting file attribute view is intimately connected to this directory stream. Once the directory stream &lt;a href=&quot;../../io/closeable#close--&quot;&gt;&lt;code&gt;closed&lt;/code&gt;&lt;/a&gt;, then all methods to read or update attributes will throw &lt;a href=&quot;closeddirectorystreamexception&quot;&gt;&lt;code&gt;ClosedDirectoryStreamException&lt;/code&gt;&lt;/a&gt;. The file is not required to exist at the time that the file attribute view is created but methods to read or update attributes of the file will fail when invoked and the file does not exist.</source>
          <target state="translated">结果文件属性视图的状态与该目录流紧密相连。目录流&lt;a href=&quot;../../io/closeable#close--&quot;&gt; &lt;code&gt;closed&lt;/code&gt; &lt;/a&gt;，所有读取或更新属性的方法都将引发&lt;a href=&quot;closeddirectorystreamexception&quot;&gt; &lt;code&gt;ClosedDirectoryStreamException&lt;/code&gt; &lt;/a&gt;。创建文件属性视图时不需要文件存在，但是在调用并且文件不存在时读取或更新文件属性的方法将失败。</target>
        </trans-unit>
        <trans-unit id="5387502d22d451f2fcf83887e20653a2840e5163" translate="yes" xml:space="preserve">
          <source>The state of resulting file attribute view is intimately connected to this directory stream. Once the directory stream is &lt;a href=&quot;../../io/closeable#close()&quot;&gt;&lt;code&gt;closed&lt;/code&gt;&lt;/a&gt;, then all methods to read or update attributes will throw &lt;a href=&quot;closeddirectorystreamexception&quot;&gt;&lt;code&gt;ClosedDirectoryStreamException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">结果文件属性视图的状态与该目录流紧密相连。&lt;a href=&quot;../../io/closeable#close()&quot;&gt; &lt;code&gt;closed&lt;/code&gt; &lt;/a&gt;目录流后，所有读取或更新属性的方法都将引发&lt;a href=&quot;closeddirectorystreamexception&quot;&gt; &lt;code&gt;ClosedDirectoryStreamException&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6e75ea05d69038d832d8131b3848e4927b08478a" translate="yes" xml:space="preserve">
          <source>The state of resulting file attribute view is intimately connected to this directory stream. Once the directory stream is &lt;a href=&quot;../../io/closeable#close--&quot;&gt;&lt;code&gt;closed&lt;/code&gt;&lt;/a&gt;, then all methods to read or update attributes will throw &lt;a href=&quot;closeddirectorystreamexception&quot;&gt;&lt;code&gt;ClosedDirectoryStreamException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">结果文件属性视图的状态与该目录流紧密相连。&lt;a href=&quot;../../io/closeable#close--&quot;&gt; &lt;code&gt;closed&lt;/code&gt; &lt;/a&gt;目录流后，所有读取或更新属性的方法都将引发&lt;a href=&quot;closeddirectorystreamexception&quot;&gt; &lt;code&gt;ClosedDirectoryStreamException&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5cfab20243a8ae6cc96b634df30cc6e006330263" translate="yes" xml:space="preserve">
          <source>The state of the horizontal and vertical scrollbars is represented by two &lt;code&gt;ScrollPaneAdjustable&lt;/code&gt; objects (one for each dimension) which implement the &lt;code&gt;Adjustable&lt;/code&gt; interface. The API provides methods to access those objects such that the attributes on the Adjustable object (such as unitIncrement, value, etc.) can be manipulated.</source>
          <target state="translated">水平和垂直滚动条的状态由两个 &lt;code&gt;ScrollPaneAdjustable&lt;/code&gt; 对象（每个维度一个）表示，这些对象实现了 &lt;code&gt;Adjustable&lt;/code&gt; 接口。API提供了访问这些对象的方法，以便可以操纵Adjustable对象上的属性（例如unitIncrement，value等）。</target>
        </trans-unit>
        <trans-unit id="996e9184ffea209eb07129d46d0cbe21a541d384" translate="yes" xml:space="preserve">
          <source>The state of the match result passed to the replacer function is guaranteed to be constant only for the duration of the replacer function call and only if the replacer function does not modify this matcher's state.</source>
          <target state="translated">传递给replacer函数的匹配结果的状态只有在replacer函数调用期间才能保证不变,而且只有在replacer函数没有修改这个匹配器的状态的情况下才能保证不变。</target>
        </trans-unit>
        <trans-unit id="5df4fed0eb737b7e2f38a8fe3aee9d1a9f382989" translate="yes" xml:space="preserve">
          <source>The state of the modifier keys.</source>
          <target state="translated">修饰键的状态。</target>
        </trans-unit>
        <trans-unit id="98da643dc29593f616d4b328dffe394f8b15ab99" translate="yes" xml:space="preserve">
          <source>The state of the modifier keys. This is replaced with InputEvent.getModifiers() In java 1.1 MouseEvent and KeyEvent are subclasses of InputEvent.</source>
          <target state="translated">修改器按键的状态。在java 1.1中,MouseEvent和KeyEvent是InputEvent的子类。</target>
        </trans-unit>
        <trans-unit id="e2b4f9494871b832aa6cdc89d8afd5085d887c4d" translate="yes" xml:space="preserve">
          <source>The state of the tree selection is characterized by a set of TreePaths, and optionally a set of integers. The mapping from TreePath to integer is done by way of an instance of RowMapper. It is not necessary for a TreeSelectionModel to have a RowMapper to correctly operate, but without a RowMapper &lt;code&gt;getSelectionRows&lt;/code&gt; will return null.</source>
          <target state="translated">树选择的状态由一组TreePath以及一组可选的整数来表征。从TreePath到整数的映射是通过RowMapper的实例完成的。TreeSelectionModel不一定必须具有RowMapper才能正确操作，但是如果没有RowMapper， &lt;code&gt;getSelectionRows&lt;/code&gt; 将返回null。</target>
        </trans-unit>
        <trans-unit id="1dd113847fce5d615aef061976b5b5490ed246b1" translate="yes" xml:space="preserve">
          <source>The static methods of this class are also guaranteed to be thread-safe. Multiple threads may concurrently invoke the static methods defined in this class with no ill effects.</source>
          <target state="translated">该类的静态方法也保证了线程安全。多个线程可以并发调用本类中定义的静态方法,而不会产生不良影响。</target>
        </trans-unit>
        <trans-unit id="cd0f94f9998daea410fa7e45671e8cee561746d9" translate="yes" xml:space="preserve">
          <source>The static methods of this class are guaranteed to be thread-safe. Multiple threads may concurrently invoke the static methods defined in this class with no ill effects.</source>
          <target state="translated">本类的静态方法保证是线程安全的,多个线程可以同时调用本类中定义的静态方法而不会产生不良影响。多个线程可以并发调用本类中定义的静态方法,而不会产生不良影响。</target>
        </trans-unit>
        <trans-unit id="32f29a8577aa7fa5da666083e0fd1a58f4e6d820" translate="yes" xml:space="preserve">
          <source>The status before the transition.</source>
          <target state="translated">过渡前的状态。</target>
        </trans-unit>
        <trans-unit id="e02a1b12a0469601ec44897d75008b5d8295adbb" translate="yes" xml:space="preserve">
          <source>The status before the transition. If this event describes a Snippet creation return &lt;a href=&quot;snippet.status#NONEXISTENT&quot;&gt;&lt;code&gt;NONEXISTENT&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">过渡前的状态。如果此事件描述了代码段的创建，则返回&lt;a href=&quot;snippet.status#NONEXISTENT&quot;&gt; &lt;code&gt;NONEXISTENT&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="453f0a5aaaeaa1b3ec705217a056ecbeb4f2af9e" translate="yes" xml:space="preserve">
          <source>The status is allowed.</source>
          <target state="translated">状态是允许的。</target>
        </trans-unit>
        <trans-unit id="b19b7fa28bfd0ac50416748ffc0c43c6c19d76ee" translate="yes" xml:space="preserve">
          <source>The status is rejected.</source>
          <target state="translated">状态被拒绝。</target>
        </trans-unit>
        <trans-unit id="43acb129e0f044bbc46043461b48630e54dab85d" translate="yes" xml:space="preserve">
          <source>The status is undecided, not allowed and not rejected.</source>
          <target state="translated">状态是未定,不允许,不拒绝。</target>
        </trans-unit>
        <trans-unit id="c8c42310ccefa275fea074e407b370d922b16a8c" translate="yes" xml:space="preserve">
          <source>The status of a check on the class, array length, number of references, depth, and stream size.</source>
          <target state="translated">类、数组长度、引用次数、深度、流大小的检查状态。</target>
        </trans-unit>
        <trans-unit id="0914f7bca27a68099a07b4e6076d13b547cbe3fd" translate="yes" xml:space="preserve">
          <source>The stax.properties file is read only once by the implementation and its values are then cached for future use. If the file does not exist when the first attempt is made to read from it, no further attempts are made to check for its existence. It is not possible to change the value of any property in stax.properties after it has been read for the first time.</source>
          <target state="translated">stax.properties 文件只被实现读取一次,它的值会被缓存起来供将来使用。如果第一次尝试从文件中读取时,文件不存在,则不会再尝试检查它的存在。第一次读取后,不可能更改 stax.properties 中任何属性的值。</target>
        </trans-unit>
        <trans-unit id="b80b91b73f97f322ab33c92b0bd0b2d998475afe" translate="yes" xml:space="preserve">
          <source>The step and pred functions are then executed, in clause order (step before pred), until a pred function returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">然后按子句顺序（在pred之前执行步骤）执行step和pred函数，直到pred函数返回 &lt;code&gt;false&lt;/code&gt; 为止。</target>
        </trans-unit>
        <trans-unit id="894a59007f0696d713a79c9ba3e2b5d5cb14c470" translate="yes" xml:space="preserve">
          <source>The steps in the rendering process are:</source>
          <target state="translated">渲染过程中的步骤是:</target>
        </trans-unit>
        <trans-unit id="c14f9f8f60727625d22b3850782fe64ea87452ab" translate="yes" xml:space="preserve">
          <source>The stipulation above does not imply that sets must accept all elements; sets may refuse to add any particular element, including &lt;code&gt;null&lt;/code&gt;, and throw an exception, as described in the specification for &lt;a href=&quot;collection#add(E)&quot;&gt;&lt;code&gt;Collection.add&lt;/code&gt;&lt;/a&gt;. Individual set implementations should clearly document any restrictions on the elements that they may contain.</source>
          <target state="translated">上面的规定并不意味着集合必须接受所有元素。集合可能拒绝添加任何特定元素，包括 &lt;code&gt;null&lt;/code&gt; ，并引发异常，如&lt;a href=&quot;collection#add(E)&quot;&gt; &lt;code&gt;Collection.add&lt;/code&gt; &lt;/a&gt;的规范中所述。单个集合的实现应清楚地记录对它们可能包含的元素的任何限制。</target>
        </trans-unit>
        <trans-unit id="8af2436810c570bd5737c0e2bb02a5d795441443" translate="yes" xml:space="preserve">
          <source>The stipulation above does not imply that sets must accept all elements; sets may refuse to add any particular element, including &lt;code&gt;null&lt;/code&gt;, and throw an exception, as described in the specification for &lt;a href=&quot;collection#add-E-&quot;&gt;&lt;code&gt;Collection.add&lt;/code&gt;&lt;/a&gt;. Individual set implementations should clearly document any restrictions on the elements that they may contain.</source>
          <target state="translated">上面的规定并不意味着集合必须接受所有元素。集合可能拒绝添加任何特定元素，包括 &lt;code&gt;null&lt;/code&gt; ，并引发异常，如&lt;a href=&quot;collection#add-E-&quot;&gt; &lt;code&gt;Collection.add&lt;/code&gt; &lt;/a&gt;的规范中所述。单个集合的实现应明确记录对它们可能包含的元素的任何限制。</target>
        </trans-unit>
        <trans-unit id="18eb68b1ed315d63fa4df9e04e256a50303f9665" translate="yes" xml:space="preserve">
          <source>The stored chain is cloned before being returned.</source>
          <target state="translated">在返回之前,存储的链会被克隆。</target>
        </trans-unit>
        <trans-unit id="34211847f3a2164208058d0523645bdef1169daa" translate="yes" xml:space="preserve">
          <source>The stored derived color</source>
          <target state="translated">储存的衍生颜色</target>
        </trans-unit>
        <trans-unit id="59fa77a75631a5fd04013364bcf5c35eed6bf5bc" translate="yes" xml:space="preserve">
          <source>The strategy used to shut down the application, if Sudden Termination is not enabled.</source>
          <target state="translated">如果未启用Sudden Termination,则用于关闭应用程序的策略。</target>
        </trans-unit>
        <trans-unit id="6a20537f8d5d92c9cff89f8fb6c2858031b1dd68" translate="yes" xml:space="preserve">
          <source>The stream binds to this bit set when the terminal stream operation commences (specifically, the spliterator for the stream is &lt;a href=&quot;spliterator#binding&quot;&gt;&lt;em&gt;late-binding&lt;/em&gt;&lt;/a&gt;). If the bit set is modified during that operation then the result is undefined.</source>
          <target state="translated">当终端流操作开始时（具体来说，该流的分隔符为Late &lt;a href=&quot;spliterator#binding&quot;&gt;&lt;em&gt;-binding&lt;/em&gt;&lt;/a&gt;），该流将绑定到该位设置。如果在该操作期间修改了该位集，则结果是不确定的。</target>
        </trans-unit>
        <trans-unit id="b503c50c6ec2a853d246bef99b17e237b1f62fe3" translate="yes" xml:space="preserve">
          <source>The stream binds to this sequence when the terminal stream operation commences (specifically, for mutable sequences the spliterator for the stream is &lt;a href=&quot;../util/spliterator#binding&quot;&gt;&lt;em&gt;late-binding&lt;/em&gt;&lt;/a&gt;). If the sequence is modified during that operation then the result is undefined.</source>
          <target state="translated">当终端流操作开始时，流将绑定到此序列（特别是，对于可变序列，流的分隔符为&lt;a href=&quot;../util/spliterator#binding&quot;&gt;&lt;em&gt;后期绑定&lt;/em&gt;&lt;/a&gt;）。如果在该操作期间修改了序列，则结果不确定。</target>
        </trans-unit>
        <trans-unit id="284a200aa5c754806caf07fbf13e99a88b0c7015" translate="yes" xml:space="preserve">
          <source>The stream is</source>
          <target state="translated">溪流是</target>
        </trans-unit>
        <trans-unit id="0f4127d1899727942c90922302e4fcbdc49bed7d" translate="yes" xml:space="preserve">
          <source>The stream is parallel;</source>
          <target state="translated">流是平行的。</target>
        </trans-unit>
        <trans-unit id="18c2dad420890c0c93e56bc71847c1ffc91d517a" translate="yes" xml:space="preserve">
          <source>The stream is written using the ISO 8859-1 character encoding.</source>
          <target state="translated">该流使用ISO 8859-1字符编码编写。</target>
        </trans-unit>
        <trans-unit id="cf2f279f616bcf76e47ab21d81f5d9638809710c" translate="yes" xml:space="preserve">
          <source>The stream may contain some data outside the specified range.</source>
          <target state="translated">流可能包含一些指定范围之外的数据。</target>
        </trans-unit>
        <trans-unit id="8981351805e6fb1fc8a0c57d5496e2d24e17c129" translate="yes" xml:space="preserve">
          <source>The stream number</source>
          <target state="translated">流程号</target>
        </trans-unit>
        <trans-unit id="40953f480e1f2608bd2829d4c5ca6a88b49f29cb" translate="yes" xml:space="preserve">
          <source>The stream of strings computed by splitting the input around matches of this pattern</source>
          <target state="translated">通过分割输入的匹配模式计算出的字符串流。</target>
        </trans-unit>
        <trans-unit id="0278f0c3b2832857f3b5d471e56fa1f750974135" translate="yes" xml:space="preserve">
          <source>The stream position is left at its prior position upon exit from this method.</source>
          <target state="translated">从本方法退出时,流的位置会留在之前的位置。</target>
        </trans-unit>
        <trans-unit id="0c88da049e966b7fa1b0336d227d0469c10d044c" translate="yes" xml:space="preserve">
          <source>The stream returned by this method contains each substring of the input sequence that is terminated by another subsequence that matches this pattern or is terminated by the end of the input sequence. The substrings in the stream are in the order in which they occur in the input. Trailing empty strings will be discarded and not encountered in the stream.</source>
          <target state="translated">本方法返回的流包含了输入序列的每一个子串,这些子串被与此模式相匹配的另一个子序列所终止,或者被输入序列的末端所终止。流中的子串按照它们在输入中出现的顺序排列。后面的空字符串将被丢弃,不会在流中出现。</target>
        </trans-unit>
        <trans-unit id="b6f6114953487ace92dd1c168418f7e9f095d3d0" translate="yes" xml:space="preserve">
          <source>The stream returned by this method contains the lines from this string in the order in which they occur.</source>
          <target state="translated">本方法返回的流包含了本字符串的行数,按其出现的顺序排列。</target>
        </trans-unit>
        <trans-unit id="cc5a36b07837d8684881fc09793cf7774af9e41a" translate="yes" xml:space="preserve">
          <source>The stream will not be buffered, and it will not support the &lt;a href=&quot;../../io/inputstream#mark(int)&quot;&gt;&lt;code&gt;mark&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../io/inputstream#reset()&quot;&gt;&lt;code&gt;reset&lt;/code&gt;&lt;/a&gt; methods. The stream will be safe for access by multiple concurrent threads. Closing the stream will in turn cause the channel to be closed.</source>
          <target state="translated">流将不会被缓冲，并且将不支持&lt;a href=&quot;../../io/inputstream#mark(int)&quot;&gt; &lt;code&gt;mark&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../../io/inputstream#reset()&quot;&gt; &lt;code&gt;reset&lt;/code&gt; &lt;/a&gt;方法。流可以安全地被多个并发线程访问。关闭流将导致通道关闭。</target>
        </trans-unit>
        <trans-unit id="8035d3c148eb320bea2a1229c6025747c0adc1f8" translate="yes" xml:space="preserve">
          <source>The stream will not be buffered, and it will not support the &lt;a href=&quot;../../io/inputstream#mark-int-&quot;&gt;&lt;code&gt;mark&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../io/inputstream#reset--&quot;&gt;&lt;code&gt;reset&lt;/code&gt;&lt;/a&gt; methods. The stream will be safe for access by multiple concurrent threads. Closing the stream will in turn cause the channel to be closed.</source>
          <target state="translated">流将不会被缓冲，并且将不支持&lt;a href=&quot;../../io/inputstream#mark-int-&quot;&gt; &lt;code&gt;mark&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../../io/inputstream#reset--&quot;&gt; &lt;code&gt;reset&lt;/code&gt; &lt;/a&gt;方法。流可以安全地被多个并发线程访问。关闭流将导致通道关闭。</target>
        </trans-unit>
        <trans-unit id="bc7063010775a8a4dfbf6ea7c3f4fd8168851da4" translate="yes" xml:space="preserve">
          <source>The stream will not be buffered. The stream will be safe for access by multiple concurrent threads. Closing the stream will in turn cause the channel to be closed.</source>
          <target state="translated">该流不会被缓冲。该流将被多个并发线程安全访问。关闭流会反过来导致通道被关闭。</target>
        </trans-unit>
        <trans-unit id="635eea582878c3cee66666dcef47dae09ac40dc8" translate="yes" xml:space="preserve">
          <source>The stream-based methods have been removed from RFC 8353.</source>
          <target state="translated">基于流的方法已经从RFC 8353中删除。</target>
        </trans-unit>
        <trans-unit id="1e0b7738c3889e14f5b400112462983b88473f42" translate="yes" xml:space="preserve">
          <source>The stream-based methods have been removed from RFC 8353. Use &lt;a href=&quot;#acceptSecContext(byte%5B%5D,int,int)&quot;&gt;&lt;code&gt;acceptSecContext(byte[], int, int)&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">基于流的方法已从RFC 8353中删除。改为使用&lt;a href=&quot;#acceptSecContext(byte%5B%5D,int,int)&quot;&gt; &lt;code&gt;acceptSecContext(byte[], int, int)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fdd1e4fc8cc236e807967eab1defe58a2d7fb81c" translate="yes" xml:space="preserve">
          <source>The stream-based methods have been removed from RFC 8353. Use &lt;a href=&quot;#getMIC(byte%5B%5D,int,int,org.ietf.jgss.MessageProp)&quot;&gt;&lt;code&gt;getMIC(byte[], int, int, MessageProp)&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">基于流的方法已从RFC 8353中删除。改为使用&lt;a href=&quot;#getMIC(byte%5B%5D,int,int,org.ietf.jgss.MessageProp)&quot;&gt; &lt;code&gt;getMIC(byte[], int, int, MessageProp)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="75a1f54ce108d9e7d4e20f8e2e55c349191efa71" translate="yes" xml:space="preserve">
          <source>The stream-based methods have been removed from RFC 8353. Use &lt;a href=&quot;#initSecContext(byte%5B%5D,int,int)&quot;&gt;&lt;code&gt;initSecContext(byte[], int, int)&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">基于流的方法已从RFC 8353中删除。改为使用&lt;a href=&quot;#initSecContext(byte%5B%5D,int,int)&quot;&gt; &lt;code&gt;initSecContext(byte[], int, int)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="837beaf6b0fd108bd6761b7a930f749f93c98a2f" translate="yes" xml:space="preserve">
          <source>The stream-based methods have been removed from RFC 8353. Use &lt;a href=&quot;#unwrap(byte%5B%5D,int,int,org.ietf.jgss.MessageProp)&quot;&gt;&lt;code&gt;unwrap(byte[], int, int, MessageProp)&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">基于流的方法已从RFC 8353中删除。改为使用unwrap &lt;a href=&quot;#unwrap(byte%5B%5D,int,int,org.ietf.jgss.MessageProp)&quot;&gt; &lt;code&gt;unwrap(byte[], int, int, MessageProp)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="20e163f975ddc90067dad425a1a8436ac6312c00" translate="yes" xml:space="preserve">
          <source>The stream-based methods have been removed from RFC 8353. Use &lt;a href=&quot;#verifyMIC(byte%5B%5D,int,int,byte%5B%5D,int,int,org.ietf.jgss.MessageProp)&quot;&gt;&lt;code&gt;verifyMIC(byte[], int, int, byte[], int, int, MessageProp)&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">基于流的方法已从RFC 8353中删除。改为使用&lt;a href=&quot;#verifyMIC(byte%5B%5D,int,int,byte%5B%5D,int,int,org.ietf.jgss.MessageProp)&quot;&gt; &lt;code&gt;verifyMIC(byte[], int, int, byte[], int, int, MessageProp)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3311a132a16f8c1f01912c04e4d437b623872dab" translate="yes" xml:space="preserve">
          <source>The stream-based methods have been removed from RFC 8353. Use &lt;a href=&quot;#wrap(byte%5B%5D,int,int,org.ietf.jgss.MessageProp)&quot;&gt;&lt;code&gt;wrap(byte[], int, int, MessageProp)&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">基于流的方法已从RFC 8353中删除。改为使用&lt;a href=&quot;#wrap(byte%5B%5D,int,int,org.ietf.jgss.MessageProp)&quot;&gt; &lt;code&gt;wrap(byte[], int, int, MessageProp)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6e7c1e2a83cde4b74baace6a01266e9922cbc527" translate="yes" xml:space="preserve">
          <source>The stream-based methods of &lt;code&gt;GSSContext&lt;/code&gt; have been deprecated in Java SE 11. These methods have also been removed from &lt;a href=&quot;http://tools.ietf.org/html/rfc8353&quot;&gt; RFC 8353: Generic Security Service API Version 2: Java Bindings Update&lt;/a&gt; for the following reasons (see section 11): &quot;The overloaded methods of GSSContext that use input and output streams as the means to convey authentication and per-message GSS-API tokens as described in Section 5.15 of RFC 5653 are removed in this update as the wire protocol should be defined by an application and not a library. It's also impossible to implement these methods correctly when the token has no self-framing (where the end cannot be determined), or the library has no knowledge of the token format (for example, as a bridge talking to another GSS library)&quot;. These methods include &lt;a href=&quot;#initSecContext(java.io.InputStream,java.io.OutputStream)&quot;&gt;&lt;code&gt;initSecContext(InputStream, OutputStream)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#acceptSecContext(java.io.InputStream,java.io.OutputStream)&quot;&gt;&lt;code&gt;acceptSecContext(InputStream, OutputStream)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#wrap(java.io.InputStream,java.io.OutputStream,org.ietf.jgss.MessageProp)&quot;&gt;&lt;code&gt;wrap(InputStream, OutputStream, MessageProp)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#unwrap(java.io.InputStream,java.io.OutputStream,org.ietf.jgss.MessageProp)&quot;&gt;&lt;code&gt;unwrap(InputStream, OutputStream, MessageProp)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#getMIC(java.io.InputStream,java.io.OutputStream,org.ietf.jgss.MessageProp)&quot;&gt;&lt;code&gt;getMIC(InputStream, OutputStream, MessageProp)&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#verifyMIC(java.io.InputStream,java.io.InputStream,org.ietf.jgss.MessageProp)&quot;&gt;&lt;code&gt;verifyMIC(InputStream, InputStream, MessageProp)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;GSSContext&lt;/code&gt; 的基于流的方法已在Java SE 11中弃用。出于以下原因，这些方法也已从&lt;a href=&quot;http://tools.ietf.org/html/rfc8353&quot;&gt;RFC 8353：通用安全服务API版本2：Java绑定更新中&lt;/a&gt;删除（请参见第11节）：在此更新中，删除了将输入和输出流用作传达身份验证和按消息的GSS-API令牌的方式的GSSContext（如RFC 5653的第5.15节所述），因为有线协议应由应用程序而不是库定义。当令牌没有自成帧（无法确定结尾）或库不知道令牌格式（例如，作为与另一个GSS库对话的桥梁）时，也无法正确实现这些方法。&amp;rdquo;这些方法包括&lt;a href=&quot;#initSecContext(java.io.InputStream,java.io.OutputStream)&quot;&gt; &lt;code&gt;initSecContext(InputStream, OutputStream)&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#acceptSecContext(java.io.InputStream,java.io.OutputStream)&quot;&gt; &lt;code&gt;acceptSecContext(InputStream, OutputStream)&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#wrap(java.io.InputStream,java.io.OutputStream,org.ietf.jgss.MessageProp)&quot;&gt; &lt;code&gt;wrap(InputStream, OutputStream, MessageProp)&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#unwrap(java.io.InputStream,java.io.OutputStream,org.ietf.jgss.MessageProp)&quot;&gt; &lt;code&gt;unwrap(InputStream, OutputStream, MessageProp)&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#getMIC(java.io.InputStream,java.io.OutputStream,org.ietf.jgss.MessageProp)&quot;&gt; &lt;code&gt;getMIC(InputStream, OutputStream, MessageProp)&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#verifyMIC(java.io.InputStream,java.io.InputStream,org.ietf.jgss.MessageProp)&quot;&gt; &lt;code&gt;verifyMIC(InputStream, InputStream, MessageProp)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="93d3cf16abf302a5134c3443f01b2257c53b0385" translate="yes" xml:space="preserve">
          <source>The stream-based methods of &lt;code&gt;GSSContext&lt;/code&gt; have been deprecated in Java SE 11. These methods have also been removed from &lt;a href=&quot;https://tools.ietf.org/html/rfc8353&quot;&gt; RFC 8353: Generic Security Service API Version 2: Java Bindings Update&lt;/a&gt; for the following reasons (see section 11): &quot;The overloaded methods of GSSContext that use input and output streams as the means to convey authentication and per-message GSS-API tokens as described in Section 5.15 of RFC 5653 are removed in this update as the wire protocol should be defined by an application and not a library. It's also impossible to implement these methods correctly when the token has no self-framing (where the end cannot be determined), or the library has no knowledge of the token format (for example, as a bridge talking to another GSS library)&quot;. These methods include &lt;a href=&quot;#initSecContext(java.io.InputStream,java.io.OutputStream)&quot;&gt;&lt;code&gt;initSecContext(InputStream, OutputStream)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#acceptSecContext(java.io.InputStream,java.io.OutputStream)&quot;&gt;&lt;code&gt;acceptSecContext(InputStream, OutputStream)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#wrap(java.io.InputStream,java.io.OutputStream,org.ietf.jgss.MessageProp)&quot;&gt;&lt;code&gt;wrap(InputStream, OutputStream, MessageProp)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#unwrap(java.io.InputStream,java.io.OutputStream,org.ietf.jgss.MessageProp)&quot;&gt;&lt;code&gt;unwrap(InputStream, OutputStream, MessageProp)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#getMIC(java.io.InputStream,java.io.OutputStream,org.ietf.jgss.MessageProp)&quot;&gt;&lt;code&gt;getMIC(InputStream, OutputStream, MessageProp)&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#verifyMIC(java.io.InputStream,java.io.InputStream,org.ietf.jgss.MessageProp)&quot;&gt;&lt;code&gt;verifyMIC(InputStream, InputStream, MessageProp)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;GSSContext&lt;/code&gt; 的基于流的方法已在Java SE 11中弃用。出于以下原因，这些方法也已从&lt;a href=&quot;https://tools.ietf.org/html/rfc8353&quot;&gt;RFC 8353：通用安全服务API版本2：Java绑定更新中&lt;/a&gt;删除（请参见第11节）：在此更新中，删除了将输入和输出流用作传达身份验证和按消息的GSS-API令牌的方式的GSSContext（如RFC 5653的第5.15节所述），因为有线协议应由应用程序而不是库定义。当令牌没有自成帧（无法确定结尾）或库不知道令牌格式（例如，作为与另一个GSS库对话的桥梁）时，也无法正确实现这些方法。&amp;rdquo;这些方法包括&lt;a href=&quot;#initSecContext(java.io.InputStream,java.io.OutputStream)&quot;&gt; &lt;code&gt;initSecContext(InputStream, OutputStream)&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#acceptSecContext(java.io.InputStream,java.io.OutputStream)&quot;&gt; &lt;code&gt;acceptSecContext(InputStream, OutputStream)&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#wrap(java.io.InputStream,java.io.OutputStream,org.ietf.jgss.MessageProp)&quot;&gt; &lt;code&gt;wrap(InputStream, OutputStream, MessageProp)&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#unwrap(java.io.InputStream,java.io.OutputStream,org.ietf.jgss.MessageProp)&quot;&gt; &lt;code&gt;unwrap(InputStream, OutputStream, MessageProp)&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#getMIC(java.io.InputStream,java.io.OutputStream,org.ietf.jgss.MessageProp)&quot;&gt; &lt;code&gt;getMIC(InputStream, OutputStream, MessageProp)&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#verifyMIC(java.io.InputStream,java.io.InputStream,org.ietf.jgss.MessageProp)&quot;&gt; &lt;code&gt;verifyMIC(InputStream, InputStream, MessageProp)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b3196486e12ee1ceae179dd2a0073d0d87998aba" translate="yes" xml:space="preserve">
          <source>The strict sequential order of invocations from &lt;code&gt;WebSocket&lt;/code&gt; to &lt;code&gt;Listener&lt;/code&gt; means, in particular, that the &lt;code&gt;Listener&lt;/code&gt;'s methods are treated as non-reentrant. This means that &lt;code&gt;Listener&lt;/code&gt; implementations do not need to be concerned with possible recursion or the order in which they invoke &lt;code&gt;WebSocket.request&lt;/code&gt; in relation to their processing logic.</source>
          <target state="translated">从 &lt;code&gt;WebSocket&lt;/code&gt; 到 &lt;code&gt;Listener&lt;/code&gt; 的严格的顺序调用顺序特别意味着，将 &lt;code&gt;Listener&lt;/code&gt; 的方法视为不可重入的。这意味着 &lt;code&gt;Listener&lt;/code&gt; 实现无需考虑可能的递归或它们相对于其处理逻辑调用 &lt;code&gt;WebSocket.request&lt;/code&gt; 的顺序。</target>
        </trans-unit>
        <trans-unit id="677e924344268647b9f4c33bebdbd774bffeedb1" translate="yes" xml:space="preserve">
          <source>The strikethrough affects both the visual bounds and the outline of the text.</source>
          <target state="translated">删除线既影响视觉界限,又影响文字的轮廓。</target>
        </trans-unit>
        <trans-unit id="08ace5725b5a326d5041f65d175699034a1c1db6" translate="yes" xml:space="preserve">
          <source>The string &quot;error&quot;, a possible value for certain properties.</source>
          <target state="translated">字符串 &quot;错误&quot;,是某些属性的可能值。</target>
        </trans-unit>
        <trans-unit id="bfc3fe82f3ff5835f163f82fa9c6c4dba766b9ab" translate="yes" xml:space="preserve">
          <source>The string &quot;false&quot;, a possible value for certain properties.</source>
          <target state="translated">字符串 &quot;false&quot;,是某些属性的可能值。</target>
        </trans-unit>
        <trans-unit id="e30c0643390c5dc7ebd25358b9755769e7551051" translate="yes" xml:space="preserve">
          <source>The string &quot;keep&quot;, a possible value for certain properties.</source>
          <target state="translated">字符串 &quot;keep&quot;,是某些属性的可能值。</target>
        </trans-unit>
        <trans-unit id="1f0cf467ff107c2e23c66f6d76abd1c756e88c98" translate="yes" xml:space="preserve">
          <source>The string &quot;latest&quot;, a possible value for certain properties.</source>
          <target state="translated">字符串 &quot;最新&quot;,是某些属性的可能值。</target>
        </trans-unit>
        <trans-unit id="108f1155e473064ee5869a10046f49c5f28678dc" translate="yes" xml:space="preserve">
          <source>The string &quot;pass&quot;, a possible value for certain properties.</source>
          <target state="translated">字符串 &quot;pass&quot;,是某些属性的可能值。</target>
        </trans-unit>
        <trans-unit id="558ef0c8eaf4af89eed40f1773ec89e05db3ff2d" translate="yes" xml:space="preserve">
          <source>The string &quot;strip&quot;, a possible value for certain properties.</source>
          <target state="translated">字符串 &quot;strip&quot;,是某些属性的可能值。</target>
        </trans-unit>
        <trans-unit id="465f99ea7628c0edb2cf953567db0aafbc5f0067" translate="yes" xml:space="preserve">
          <source>The string &quot;true&quot;, a possible value for certain properties.</source>
          <target state="translated">字符串 &quot;true&quot;,是某些属性的可能值。</target>
        </trans-unit>
        <trans-unit id="22c0cd468531813dfe7dcaa04b8b2d76bff20d6f" translate="yes" xml:space="preserve">
          <source>The string &lt;a href=&quot;#ERROR&quot;&gt;&lt;code&gt;ERROR&lt;/code&gt;&lt;/a&gt; means that the pack operation as a whole will fail, with an exception of type &lt;code&gt;IOException&lt;/code&gt;. The string &lt;a href=&quot;#STRIP&quot;&gt;&lt;code&gt;STRIP&lt;/code&gt;&lt;/a&gt; means that the attribute will be dropped. The string &lt;a href=&quot;#PASS&quot;&gt;&lt;code&gt;PASS&lt;/code&gt;&lt;/a&gt; means that the whole class-file will be passed through (as if it were a resource file) without compression, with a suitable warning. This is the default value for this property.</source>
          <target state="translated">字符串&lt;a href=&quot;#ERROR&quot;&gt; &lt;code&gt;ERROR&lt;/code&gt; &lt;/a&gt;表示整个打包操作将失败，但 &lt;code&gt;IOException&lt;/code&gt; 类型的异常除外。字符串&lt;a href=&quot;#STRIP&quot;&gt; &lt;code&gt;STRIP&lt;/code&gt; &lt;/a&gt;表示该属性将被删除。字符串&lt;a href=&quot;#PASS&quot;&gt; &lt;code&gt;PASS&lt;/code&gt; &lt;/a&gt;表示整个类文件将在没有适当压缩的情况下通过压缩（就像它是资源文件一样）而不经过压缩。这是此属性的默认值。</target>
        </trans-unit>
        <trans-unit id="b7d2fbb70acb3059d5c5bbd79c4294963cdbf352" translate="yes" xml:space="preserve">
          <source>The string &lt;a href=&quot;pack200.packer#ERROR&quot;&gt;&lt;code&gt;ERROR&lt;/code&gt;&lt;/a&gt; means that the pack operation as a whole will fail, with an exception of type &lt;code&gt;IOException&lt;/code&gt;. The string &lt;a href=&quot;pack200.packer#STRIP&quot;&gt;&lt;code&gt;STRIP&lt;/code&gt;&lt;/a&gt; means that the attribute will be dropped. The string &lt;a href=&quot;pack200.packer#PASS&quot;&gt;&lt;code&gt;PASS&lt;/code&gt;&lt;/a&gt; means that the whole class-file will be passed through (as if it were a resource file) without compression, with a suitable warning. This is the default value for this property.</source>
          <target state="translated">字符串&lt;a href=&quot;pack200.packer#ERROR&quot;&gt; &lt;code&gt;ERROR&lt;/code&gt; &lt;/a&gt;表示整个打包操作将失败，但 &lt;code&gt;IOException&lt;/code&gt; 类型的异常除外。字符串&lt;a href=&quot;pack200.packer#STRIP&quot;&gt; &lt;code&gt;STRIP&lt;/code&gt; &lt;/a&gt;表示将删除该属性。字符串&lt;a href=&quot;pack200.packer#PASS&quot;&gt; &lt;code&gt;PASS&lt;/code&gt; &lt;/a&gt;意味着整个类文件将在没有适当压缩的情况下通过压缩（就像它是资源文件一样）而不进行压缩。这是此属性的默认值。</target>
        </trans-unit>
        <trans-unit id="ad02c3d243be4e9c61737e03ba9c0bf8b38dbb60" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;&quot;boo:and:foo&quot;&lt;/code&gt;, for example, yields the following results with these expressions:</source>
          <target state="translated">例如，字符串 &lt;code&gt;&quot;boo:and:foo&quot;&lt;/code&gt; 通过这些表达式产生以下结果：</target>
        </trans-unit>
        <trans-unit id="0a75a6f894f0ae1c44cee0d9fcd6514b9f78e1dd" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;&quot;boo:and:foo&quot;&lt;/code&gt;, for example, yields the following results with these parameters:</source>
          <target state="translated">例如，字符串 &lt;code&gt;&quot;boo:and:foo&quot;&lt;/code&gt; 使用这些参数会产生以下结果：</target>
        </trans-unit>
        <trans-unit id="1565ac3867c9c20773f4cb4feb587c3d597a0245" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;&quot;precision=&quot;&lt;/code&gt;, immediately followed by the value of the precision setting as a numeric string as if generated by the &lt;a href=&quot;../lang/integer#toString(int)&quot;&gt;&lt;code&gt;Integer.toString&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">字符串 &lt;code&gt;&quot;precision=&quot;&lt;/code&gt; ，紧随其后的是作为数字字符串的精度设置值，就像由&lt;a href=&quot;../lang/integer#toString(int)&quot;&gt; &lt;code&gt;Integer.toString&lt;/code&gt; &lt;/a&gt;方法生成的一样。</target>
        </trans-unit>
        <trans-unit id="6550e9f9888c201023a4fc7c4d06f985451147bf" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;&quot;precision=&quot;&lt;/code&gt;, immediately followed by the value of the precision setting as a numeric string as if generated by the &lt;a href=&quot;../lang/integer#toString-int-&quot;&gt;&lt;code&gt;Integer.toString&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">字符串 &lt;code&gt;&quot;precision=&quot;&lt;/code&gt; ，紧随其后的是作为数字字符串的精度设置的值，就像由&lt;a href=&quot;../lang/integer#toString-int-&quot;&gt; &lt;code&gt;Integer.toString&lt;/code&gt; &lt;/a&gt;方法生成的一样。</target>
        </trans-unit>
        <trans-unit id="62905723a8ac431fa9dccaf628bb9c07af02e5dd" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;&quot;roundingMode=&quot;&lt;/code&gt;, immediately followed by the value of the &lt;code&gt;roundingMode&lt;/code&gt; setting as a word. This word will be the same as the name of the corresponding public constant in the &lt;a href=&quot;roundingmode&quot;&gt;&lt;code&gt;RoundingMode&lt;/code&gt;&lt;/a&gt; enum.</source>
          <target state="translated">字符串 &lt;code&gt;&quot;roundingMode=&quot;&lt;/code&gt; ，紧随其后的是word 的 &lt;code&gt;roundingMode&lt;/code&gt; 设置值。该单词将与&lt;a href=&quot;roundingmode&quot;&gt; &lt;code&gt;RoundingMode&lt;/code&gt; &lt;/a&gt;枚举中对应的公共常量的名称相同。</target>
        </trans-unit>
        <trans-unit id="a056f3c02b144a1272485d342c4c2a38f8a60c41" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;&quot;true&quot;&lt;/code&gt; or &lt;code&gt;&quot;false&quot;&lt;/code&gt; according as this MBean is an &lt;a href=&quot;mxbean&quot;&gt;&lt;code&gt;MXBean&lt;/code&gt;&lt;/a&gt;. A Standard MBean or MXBean registered directly with the MBean Server or created using the &lt;a href=&quot;standardmbean&quot;&gt;&lt;code&gt;StandardMBean&lt;/code&gt;&lt;/a&gt; class will have this field in its MBeanInfo Descriptor.</source>
          <target state="translated">根据此MBean 的字符串 &lt;code&gt;&quot;true&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;false&quot;&lt;/code&gt; 是&lt;a href=&quot;mxbean&quot;&gt; &lt;code&gt;MXBean&lt;/code&gt; &lt;/a&gt;。直接在MBean服务器上注册或使用&lt;a href=&quot;standardmbean&quot;&gt; &lt;code&gt;StandardMBean&lt;/code&gt; &lt;/a&gt;类创建的Standard MBean或MXBean 将在其MBeanInfo描述符中具有此字段。</target>
        </trans-unit>
        <trans-unit id="fa3bdb340e93ffe54892a6e3894a1d8cb94a703a" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;&quot;true&quot;&lt;/code&gt; or &lt;code&gt;&quot;false&quot;&lt;/code&gt; according as this MBean's MBeanInfo is &lt;em&gt;immutable&lt;/em&gt;. When this field is true, the MBeanInfo for the given MBean is guaranteed not to change over the lifetime of the MBean. Hence, a client can read it once and cache the read value. When this field is false or absent, there is no such guarantee, although that does not mean that the MBeanInfo will necessarily change. See also the &lt;a href=&quot;mbeaninfo#info-changed&quot;&gt;&lt;code&gt;&quot;jmx.mbean.info.changed&quot;&lt;/code&gt;&lt;/a&gt; notification.</source>
          <target state="translated">根据此MBean的MBeanInfo是&lt;em&gt;不可变&lt;/em&gt;的，字符串 &lt;code&gt;&quot;true&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;false&quot;&lt;/code&gt; 。当此字段为true时，保证给定MBean的MBeanInfo不会在MBean的生存期内更改。因此，客户端可以读取一次并缓存读取的值。当此字段为false或不存在时，没有这种保证，尽管这并不意味着MBeanInfo一定会发生变化。另请参见&lt;a href=&quot;mbeaninfo#info-changed&quot;&gt; &lt;code&gt;&quot;jmx.mbean.info.changed&quot;&lt;/code&gt; &lt;/a&gt;通知。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="58cf603470519c5b5e195c25d45c63e85fd34cc0" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;&quot;true&quot;&lt;/code&gt; or &lt;code&gt;&quot;false&quot;&lt;/code&gt; according as this item is enabled. When an attribute or operation is not enabled, it exists but cannot currently be accessed. A user interface might present it as a greyed-out item. For example, an attribute might only be meaningful after the &lt;code&gt;start()&lt;/code&gt; method of an MBean has been called, and is otherwise disabled. Likewise, a notification might be disabled if it cannot currently be emitted but could be in other circumstances.</source>
          <target state="translated">启用此项目的字符串 &lt;code&gt;&quot;true&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;false&quot;&lt;/code&gt; 。如果未启用属性或操作，则该属性或操作将存在，但当前无法访问。用户界面可能会将其显示为灰色项目。例如，属性可能仅在调用MBean 的 &lt;code&gt;start()&lt;/code&gt; 方法之后才有意义，否则将被禁用。同样，如果当前无法发出通知，但在其他情况下可能会禁用该通知。</target>
        </trans-unit>
        <trans-unit id="631ed054c3067658cc3a118e7936d64f51bfad09" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;&quot;unchecked&quot;&lt;/code&gt; is used to suppress unchecked warnings. Compiler vendors should document the additional warning names they support in conjunction with this annotation type. They are encouraged to cooperate to ensure that the same names work across multiple compilers.</source>
          <target state="translated">字符串 &lt;code&gt;&quot;unchecked&quot;&lt;/code&gt; 用于禁止未检查的警告。编译器供应商应与此注释类型一起记录他们支持的其他警告名称。鼓励他们合作以确保相同的名称可在多个编译器中使用。</target>
        </trans-unit>
        <trans-unit id="69491b7b47334ee084c1c31f631a979ba7599e82" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;s&lt;/code&gt; is processed from left to right, looking for data of interest. Any material in &lt;code&gt;s&lt;/code&gt; that is within the ASCII parenthesis characters &lt;code&gt;(&lt;/code&gt; and &lt;code&gt;)&lt;/code&gt; is ignored. Parentheses may be nested. Otherwise, the only characters permitted within &lt;code&gt;s&lt;/code&gt; are these ASCII characters:</source>
          <target state="translated">从左到右处理字符串 &lt;code&gt;s&lt;/code&gt; ，以查找感兴趣的数据。 &lt;code&gt;s&lt;/code&gt; 中ASCII括号字符 &lt;code&gt;(&lt;/code&gt; 和 &lt;code&gt;)&lt;/code&gt; 内的任何材料都将被忽略。括号可以嵌套。否则， &lt;code&gt;s&lt;/code&gt; 中允许的唯一字符是这些ASCII字符：</target>
        </trans-unit>
        <trans-unit id="fa07a44e85f7b0960fe0afe9cd1bc3596bb25ceb" translate="yes" xml:space="preserve">
          <source>The string NULL (not enclosed in quotes) - if NULL was specified as the default value</source>
          <target state="translated">字符串NULL(不包含在引号中)--如果NULL被指定为默认值。</target>
        </trans-unit>
        <trans-unit id="919c5615e88a8576efe725aa5581160688478bfe" translate="yes" xml:space="preserve">
          <source>The string attribute values are not interpreted as &lt;a href=&quot;http://www.ietf.org/rfc/rfc2253.txt&quot;&gt;RFC 2253&lt;/a&gt; formatted RDN strings. That is, the values are used literally (not parsed) and assumed to be unescaped.</source>
          <target state="translated">字符串属性值不解释为&lt;a href=&quot;http://www.ietf.org/rfc/rfc2253.txt&quot;&gt;RFC 2253&lt;/a&gt;格式的RDN字符串。即，这些值将按字面使用（未解析）并假定为未转义。</target>
        </trans-unit>
        <trans-unit id="281a06519e314093dc16bc940319b122ec1fafd2" translate="yes" xml:space="preserve">
          <source>The string attribute values are not interpreted as &lt;a href=&quot;https://www.ietf.org/rfc/rfc2253.txt&quot;&gt;RFC 2253&lt;/a&gt; formatted RDN strings. That is, the values are used literally (not parsed) and assumed to be unescaped.</source>
          <target state="translated">字符串属性值不解释为&lt;a href=&quot;https://www.ietf.org/rfc/rfc2253.txt&quot;&gt;RFC 2253&lt;/a&gt;格式的RDN字符串。即，这些值按原样使用（未解析），并假定为未转义。</target>
        </trans-unit>
        <trans-unit id="fad0ec093c3f0998c8bdd918a0718e5eab967d10" translate="yes" xml:space="preserve">
          <source>The string constructed by replacing each matching subsequence by the replacement string, substituting captured subsequences as needed</source>
          <target state="translated">通过将每个匹配的子序列替换为替换字符串来构建的字符串,根据需要替换捕获的子序列。</target>
        </trans-unit>
        <trans-unit id="afda6d3703500c7f92e7b1f7f59b56df33958ed8" translate="yes" xml:space="preserve">
          <source>The string constructed by replacing each matching subsequence with the result of applying the replacer function to that matched subsequence, substituting captured subsequences as needed.</source>
          <target state="translated">通过将每个匹配的子序列替换为应用replacer函数到该匹配子序列的结果来构建的字符串,根据需要替换捕获的子序列。</target>
        </trans-unit>
        <trans-unit id="c64ffe780cf31db4996cccb5e0b7a94f8f71ac12" translate="yes" xml:space="preserve">
          <source>The string constructed by replacing the first matching subsequence by the replacement string, substituting captured subsequences as needed</source>
          <target state="translated">通过将第一个匹配的子序列替换为替换字符串来构建的字符串,根据需要替换捕获的子序列。</target>
        </trans-unit>
        <trans-unit id="e0bec6f730c0449ee38f585e3dde0d82f697b3cb" translate="yes" xml:space="preserve">
          <source>The string constructed by replacing the first matching subsequence with the result of applying the replacer function to the matched subsequence, substituting captured subsequences as needed.</source>
          <target state="translated">通过将第一个匹配的子序列替换为对匹配的子序列应用replacer函数的结果来构建的字符串,根据需要替换捕获的子序列。</target>
        </trans-unit>
        <trans-unit id="57510220bfaf470419bb00af78884a6462f36070" translate="yes" xml:space="preserve">
          <source>The string containing the version of the module if recorded at compile-time, or an empty &lt;code&gt;Optional&lt;/code&gt; if no version was recorded</source>
          <target state="translated">包含模块版本的字符串（如果在编译时记录），或者为空（ &lt;code&gt;Optional&lt;/code&gt; 如果未记录版本）</target>
        </trans-unit>
        <trans-unit id="a584ad3952c728ec28d3c26b8f0d57ad4cd86d7a" translate="yes" xml:space="preserve">
          <source>The string containing the version of the module or an empty &lt;code&gt;Optional&lt;/code&gt; if the module does not have a version</source>
          <target state="translated">包含模块版本的字符串；如果模块没有版本，则为空 &lt;code&gt;Optional&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c31beff83674da5e332dc00712cbbbdd5562206f" translate="yes" xml:space="preserve">
          <source>The string form of the compound name follows the syntax described above. When the components of the compound name are turned into their string representation, the reserved syntax rules described above are applied (e.g. embedded separators are escaped or quoted) so that when the same string is parsed, it will yield the same components of the original compound name.</source>
          <target state="translated">复名的字符串形式遵循上述语法。当复合名称的组成部分被转化为字符串表示时,上述保留的语法规则被应用(例如,嵌入的分隔符被转义或引号),因此当相同的字符串被解析时,它将产生原始复合名称的相同组成部分。</target>
        </trans-unit>
        <trans-unit id="f10938b9c9c0c8797b9503b58353064a7df27786" translate="yes" xml:space="preserve">
          <source>The string form of this URI</source>
          <target state="translated">这个URI的字符串形式</target>
        </trans-unit>
        <trans-unit id="2fdc4bee66cbffe9f8926f8d8bb6b3ff409dbcc9" translate="yes" xml:space="preserve">
          <source>The string form of this URI, encoded as needed so that it only contains characters in the US-ASCII charset</source>
          <target state="translated">该URI的字符串形式,根据需要进行编码,因此它只包含US-ASCII字符集的字符。</target>
        </trans-unit>
        <trans-unit id="04761903fd7cc565bcc1b3b493f9a4d9ad183aaa" translate="yes" xml:space="preserve">
          <source>The string form of this abstract pathname</source>
          <target state="translated">这个抽象路径名的字符串形式</target>
        </trans-unit>
        <trans-unit id="a6a48b95d9bb03c06186693a1e56c1d93fae2d7c" translate="yes" xml:space="preserve">
          <source>The string from which bytes are read.</source>
          <target state="translated">读取字节的字符串。</target>
        </trans-unit>
        <trans-unit id="63b46307980099765e658cf440f0d03747b95b05" translate="yes" xml:space="preserve">
          <source>The string from which this version was parsed.</source>
          <target state="translated">从这个版本中解析出的字符串。</target>
        </trans-unit>
        <trans-unit id="b6724bb79c3c33d31e86e0f46c7de30b21951061" translate="yes" xml:space="preserve">
          <source>The string is between 1 and 128 characters in length inclusive</source>
          <target state="translated">字符串的长度在1到128个字符之间,其中包括</target>
        </trans-unit>
        <trans-unit id="15fa0640f7a89ad0499dc7372318874d0f8a6949" translate="yes" xml:space="preserve">
          <source>The string is not enclosed in double quotes</source>
          <target state="translated">字符串没有用双引号括起来。</target>
        </trans-unit>
        <trans-unit id="2361fc0fcc98f34cf7707bd58c3a48311a40b445" translate="yes" xml:space="preserve">
          <source>The string must match exactly the name of the era. (Extraneous whitespace characters are not permitted.)</source>
          <target state="translated">该字符串必须与时代名称完全匹配。(不允许使用多余的空白字符)</target>
        </trans-unit>
        <trans-unit id="528b474b80585c5bde4792fd2aaffc2f3fc1d745" translate="yes" xml:space="preserve">
          <source>The string must represent a valid date and is parsed using &lt;a href=&quot;format/datetimeformatter#ISO_LOCAL_DATE&quot;&gt;&lt;code&gt;DateTimeFormatter.ISO_LOCAL_DATE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该字符串必须表示一个有效日期，并使用&lt;a href=&quot;format/datetimeformatter#ISO_LOCAL_DATE&quot;&gt; &lt;code&gt;DateTimeFormatter.ISO_LOCAL_DATE&lt;/code&gt; &lt;/a&gt;进行解析。</target>
        </trans-unit>
        <trans-unit id="a92bea7fe20a26d29fc02f1b18cfeb4a64f2befc" translate="yes" xml:space="preserve">
          <source>The string must represent a valid date-time and is parsed using &lt;a href=&quot;format/datetimeformatter#ISO_LOCAL_DATE_TIME&quot;&gt;&lt;code&gt;DateTimeFormatter.ISO_LOCAL_DATE_TIME&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该字符串必须表示一个有效的日期时间，并使用&lt;a href=&quot;format/datetimeformatter#ISO_LOCAL_DATE_TIME&quot;&gt; &lt;code&gt;DateTimeFormatter.ISO_LOCAL_DATE_TIME&lt;/code&gt; &lt;/a&gt;进行解析。</target>
        </trans-unit>
        <trans-unit id="9546955f3024f065c5daeea861e41048af02e3a1" translate="yes" xml:space="preserve">
          <source>The string must represent a valid date-time and is parsed using &lt;a href=&quot;format/datetimeformatter#ISO_OFFSET_DATE_TIME&quot;&gt;&lt;code&gt;DateTimeFormatter.ISO_OFFSET_DATE_TIME&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该字符串必须表示一个有效的日期时间，并使用&lt;a href=&quot;format/datetimeformatter#ISO_OFFSET_DATE_TIME&quot;&gt; &lt;code&gt;DateTimeFormatter.ISO_OFFSET_DATE_TIME&lt;/code&gt; &lt;/a&gt;进行解析。</target>
        </trans-unit>
        <trans-unit id="ea655be45604489e8a988f1f62775445f297e35d" translate="yes" xml:space="preserve">
          <source>The string must represent a valid date-time and is parsed using &lt;a href=&quot;format/datetimeformatter#ISO_ZONED_DATE_TIME&quot;&gt;&lt;code&gt;DateTimeFormatter.ISO_ZONED_DATE_TIME&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该字符串必须表示一个有效的日期时间，并使用&lt;a href=&quot;format/datetimeformatter#ISO_ZONED_DATE_TIME&quot;&gt; &lt;code&gt;DateTimeFormatter.ISO_ZONED_DATE_TIME&lt;/code&gt; &lt;/a&gt;进行解析。</target>
        </trans-unit>
        <trans-unit id="b639943db6958d9063503c47072cf422d9417cda" translate="yes" xml:space="preserve">
          <source>The string must represent a valid instant in UTC and is parsed using &lt;a href=&quot;format/datetimeformatter#ISO_INSTANT&quot;&gt;&lt;code&gt;DateTimeFormatter.ISO_INSTANT&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该字符串必须表示UTC中的有效时刻，并使用&lt;a href=&quot;format/datetimeformatter#ISO_INSTANT&quot;&gt; &lt;code&gt;DateTimeFormatter.ISO_INSTANT&lt;/code&gt; &lt;/a&gt;进行解析。</target>
        </trans-unit>
        <trans-unit id="5d2f552261c78dde5773d5eb748ea70d7ae99393" translate="yes" xml:space="preserve">
          <source>The string must represent a valid month-day. The format is &lt;code&gt;--MM-dd&lt;/code&gt;.</source>
          <target state="translated">该字符串必须代表一个有效的月日。格式为 &lt;code&gt;--MM-dd&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0f5fc471abeddd2fc10059070b03a26ea0e4f0e6" translate="yes" xml:space="preserve">
          <source>The string must represent a valid time and is parsed using &lt;a href=&quot;format/datetimeformatter#ISO_LOCAL_TIME&quot;&gt;&lt;code&gt;DateTimeFormatter.ISO_LOCAL_TIME&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该字符串必须表示一个有效时间，并使用&lt;a href=&quot;format/datetimeformatter#ISO_LOCAL_TIME&quot;&gt; &lt;code&gt;DateTimeFormatter.ISO_LOCAL_TIME&lt;/code&gt; &lt;/a&gt;进行解析。</target>
        </trans-unit>
        <trans-unit id="4834d95eb10fdeb7855ef1f3b7f1815cd5f315de" translate="yes" xml:space="preserve">
          <source>The string must represent a valid time and is parsed using &lt;a href=&quot;format/datetimeformatter#ISO_OFFSET_TIME&quot;&gt;&lt;code&gt;DateTimeFormatter.ISO_OFFSET_TIME&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该字符串必须表示一个有效时间，并使用&lt;a href=&quot;format/datetimeformatter#ISO_OFFSET_TIME&quot;&gt; &lt;code&gt;DateTimeFormatter.ISO_OFFSET_TIME&lt;/code&gt; &lt;/a&gt;进行解析。</target>
        </trans-unit>
        <trans-unit id="522d37a5cb0dea2932c0223382f776eae3acb124" translate="yes" xml:space="preserve">
          <source>The string must represent a valid year-month. The format must be &lt;code&gt;uuuu-MM&lt;/code&gt;. Years outside the range 0000 to 9999 must be prefixed by the plus or minus symbol.</source>
          <target state="translated">该字符串必须表示有效的年月。格式必须为 &lt;code&gt;uuuu-MM&lt;/code&gt; 。范围在0000到9999之间的年份必须以加号或减号作为前缀。</target>
        </trans-unit>
        <trans-unit id="68fe36aa287218182684aa7a85b5b9b1977bc3ca" translate="yes" xml:space="preserve">
          <source>The string must represent a valid year. Years outside the range 0000 to 9999 must be prefixed by the plus or minus symbol.</source>
          <target state="translated">字符串必须代表一个有效的年份。0000至9999范围之外的年份必须以加号或减号作为前缀。</target>
        </trans-unit>
        <trans-unit id="137a5254a87fa6e0ce4c1568f6ddf435ae99c22b" translate="yes" xml:space="preserve">
          <source>The string only contains alphanumeric characters or the character &quot;_&quot;</source>
          <target state="translated">该字符串只包含字母数字字符或字符&quot;_&quot;</target>
        </trans-unit>
        <trans-unit id="abbf179f85853b351778a26629eb5657fc8e8fab" translate="yes" xml:space="preserve">
          <source>The string produced for a given number is always the same; it is not affected by locale. This means that it can be used as a canonical string representation for exchanging decimal data, or as a key for a Hashtable, etc. Locale-sensitive number formatting and parsing is handled by the &lt;a href=&quot;../text/numberformat&quot;&gt;&lt;code&gt;NumberFormat&lt;/code&gt;&lt;/a&gt; class and its subclasses.</source>
          <target state="translated">给定数字产生的字符串始终相同；它不受语言环境的影响。这意味着它可用作交换十进制数据的规范字符串表示形式，或用作哈希表的键等。区域设置敏感的数字格式设置和解析由&lt;a href=&quot;../text/numberformat&quot;&gt; &lt;code&gt;NumberFormat&lt;/code&gt; &lt;/a&gt;类及其子类处理。</target>
        </trans-unit>
        <trans-unit id="3fe8bf77d08eee400f8eacfe6cb5d936ae0a4f48" translate="yes" xml:space="preserve">
          <source>The string representation consists of a list of the array's elements, enclosed in square brackets (&lt;code&gt;&quot;[]&quot;&lt;/code&gt;). Adjacent elements are separated by the characters &lt;code&gt;&quot;, &quot;&lt;/code&gt; (a comma followed by a space). Elements are converted to strings as by &lt;code&gt;String.valueOf(Object)&lt;/code&gt;, unless they are themselves arrays.</source>
          <target state="translated">字符串表示形式由数组元素列表组成，并用方括号（ &lt;code&gt;&quot;[]&quot;&lt;/code&gt; ）括起来。相邻元素由字符 &lt;code&gt;&quot;, &quot;&lt;/code&gt; （逗号后跟空格）分隔。元素通过 &lt;code&gt;String.valueOf(Object)&lt;/code&gt; 转换为字符串，除非它们本身是数组。</target>
        </trans-unit>
        <trans-unit id="3b44741f71d142966f86ccc32acede59a84d445d" translate="yes" xml:space="preserve">
          <source>The string representation consists of the name of the implementing class, and the tabular type of this instance.</source>
          <target state="translated">字符串表示由实现类的名称和该实例的表格类型组成。</target>
        </trans-unit>
        <trans-unit id="53d83a239c2a7be1cb8fe5f1423384d5522b995b" translate="yes" xml:space="preserve">
          <source>The string representation consists of the name of the implementing class, the string representation of the composite type of this instance, and the string representation of the contents (ie list the itemName=itemValue mappings).</source>
          <target state="translated">字符串表示由实现类的名称、该实例的复合类型的字符串表示和内容的字符串表示组成(即列出itemName=itemValue的映射)。</target>
        </trans-unit>
        <trans-unit id="9ce6c605327807271ff809bf8c3e33f72c8d71fb" translate="yes" xml:space="preserve">
          <source>The string representation consists of the name of this class (i.e. &lt;code&gt;javax.management.openmbean.ArrayType&lt;/code&gt;), the type name, the dimension, the elements' open type and the primitive array flag defined for this instance.</source>
          <target state="translated">字符串表示形式包括此类的名称（即 &lt;code&gt;javax.management.openmbean.ArrayType&lt;/code&gt; ），类型名称，维，元素的打开类型以及为此实例定义的原始数组标志。</target>
        </trans-unit>
        <trans-unit id="2883eec75a628ef99c332dc7e2aaea10651f3902" translate="yes" xml:space="preserve">
          <source>The string representation consists of the name of this class (i.e. &lt;code&gt;javax.management.openmbean.OpenMBeanAttributeInfoSupport&lt;/code&gt;), the string representation of the name and open type of the described parameter, the string representation of its default, min, max and legal values and the string representation of its descriptor.</source>
          <target state="translated">字符串表示形式包括此类的名称（即 &lt;code&gt;javax.management.openmbean.OpenMBeanAttributeInfoSupport&lt;/code&gt; ），名称和所描述参数的开放类型的字符串表示形式，其默认值，最小，最大和合法值的字符串表示形式以及其描述符的字符串表示形式。</target>
        </trans-unit>
        <trans-unit id="8a2464b0766b9e81e51253aa84918715aa0cd068" translate="yes" xml:space="preserve">
          <source>The string representation consists of the name of this class (i.e. &lt;code&gt;javax.management.openmbean.OpenMBeanParameterInfoSupport&lt;/code&gt;), the string representation of the name and open type of the described parameter, the string representation of its default, min, max and legal values and the string representation of its descriptor.</source>
          <target state="translated">字符串表示形式包括此类的名称（即 &lt;code&gt;javax.management.openmbean.OpenMBeanParameterInfoSupport&lt;/code&gt; ），名称和所描述参数的开放类型的字符串表示形式，其默认值，最小，最大和合法值的字符串表示形式以及其描述符的字符串表示形式。</target>
        </trans-unit>
        <trans-unit id="4d29a8e6e5f83180a9a2655eeeb086d4d8e9f13e" translate="yes" xml:space="preserve">
          <source>The string representation consists of the name of this class (ie &lt;code&gt;
 javax.management.openmbean.OpenMBeanConstructorInfoSupport&lt;/code&gt;), the name and signature of the described constructor and the string representation of its descriptor.</source>
          <target state="translated">字符串表示形式包括此类的名称（即 &lt;code&gt; javax.management.openmbean.OpenMBeanConstructorInfoSupport&lt;/code&gt; ），所描述的构造方法的名称和签名以及其描述符的字符串表示形式。</target>
        </trans-unit>
        <trans-unit id="ac01ca9000354d194b07d70a4e1b8028f60f9f3e" translate="yes" xml:space="preserve">
          <source>The string representation consists of the name of this class (ie &lt;code&gt;
 javax.management.openmbean.OpenMBeanOperationInfoSupport&lt;/code&gt;), and the name, signature, return open type and impact of the described operation and the string representation of its descriptor.</source>
          <target state="translated">字符串表示形式包括此类的名称（即 &lt;code&gt; javax.management.openmbean.OpenMBeanOperationInfoSupport&lt;/code&gt; ），名称，签名，返回的打开类型和所描述操作的影响以及其描述符的字符串表示形式。</target>
        </trans-unit>
        <trans-unit id="9b6002a9339d22eed93f555f1481a07a002e5091" translate="yes" xml:space="preserve">
          <source>The string representation consists of the name of this class (ie &lt;code&gt;javax.management.openmbean.CompositeDataSupport&lt;/code&gt;), the string representation of the composite type of this instance, and the string representation of the contents (ie list the itemName=itemValue mappings).</source>
          <target state="translated">字符串表示形式包括此类的名称（即 &lt;code&gt;javax.management.openmbean.CompositeDataSupport&lt;/code&gt; ），此实例的复合类型的字符串表示形式以及内容的字符串表示形式（即列出itemName = itemValue映射）。</target>
        </trans-unit>
        <trans-unit id="789eed41269dc56a9082ac2a97089c1d128afaf4" translate="yes" xml:space="preserve">
          <source>The string representation consists of the name of this class (ie &lt;code&gt;javax.management.openmbean.CompositeType&lt;/code&gt;), the type name for this instance, and the list of the items names and types string representation of this instance.</source>
          <target state="translated">字符串表示形式包括此类的名称（即 &lt;code&gt;javax.management.openmbean.CompositeType&lt;/code&gt; ），此实例的类型名称以及该实例的项目名称和类型字符串表示形式的列表。</target>
        </trans-unit>
        <trans-unit id="a4e6ec5ac6aa3e0627edbc16f7c6430eb6a8d1d8" translate="yes" xml:space="preserve">
          <source>The string representation consists of the name of this class (ie &lt;code&gt;javax.management.openmbean.OpenMBeanAttributeInfo&lt;/code&gt;), the string representation of the name and open type of the described attribute, and the string representation of its default, min, max and legal values.</source>
          <target state="translated">字符串表示形式由此类的名称（即 &lt;code&gt;javax.management.openmbean.OpenMBeanAttributeInfo&lt;/code&gt; ），所描述属性的名称和开放类型的字符串表示形式以及其默认值，最小值，最大值和合法值组成。</target>
        </trans-unit>
        <trans-unit id="d7b716744f9ffc637689b371f05e304eff7af2a9" translate="yes" xml:space="preserve">
          <source>The string representation consists of the name of this class (ie &lt;code&gt;javax.management.openmbean.OpenMBeanConstructorInfo&lt;/code&gt;), and the name and signature of the described constructor.</source>
          <target state="translated">字符串表示形式由此类的名称（即 &lt;code&gt;javax.management.openmbean.OpenMBeanConstructorInfo&lt;/code&gt; ）以及所描述的构造方法的名称和签名组成。</target>
        </trans-unit>
        <trans-unit id="6ad27ad5ebd129c3ea4d4956977533104d272e95" translate="yes" xml:space="preserve">
          <source>The string representation consists of the name of this class (ie &lt;code&gt;javax.management.openmbean.OpenMBeanConstructorInfoSupport&lt;/code&gt;), the name and signature of the described constructor and the string representation of its descriptor.</source>
          <target state="translated">字符串表示形式包括此类的名称（即 &lt;code&gt;javax.management.openmbean.OpenMBeanConstructorInfoSupport&lt;/code&gt; ），所描述的构造函数的名称和签名以及其描述符的字符串表示形式。</target>
        </trans-unit>
        <trans-unit id="56f0f9a9629656eb5921de1b1b2280b717218bf7" translate="yes" xml:space="preserve">
          <source>The string representation consists of the name of this class (ie &lt;code&gt;javax.management.openmbean.OpenMBeanInfo&lt;/code&gt;), the MBean class name, and the string representation of infos on attributes, constructors, operations and notifications of the described MBean.</source>
          <target state="translated">字符串表示形式包括此类的名称（即 &lt;code&gt;javax.management.openmbean.OpenMBeanInfo&lt;/code&gt; ），MBean类名称以及有关所描述的MBean的属性，构造函数，操作和通知的信息的字符串表示形式。</target>
        </trans-unit>
        <trans-unit id="f9d79b194f6330817e69226b3c9fd464f3f27be2" translate="yes" xml:space="preserve">
          <source>The string representation consists of the name of this class (ie &lt;code&gt;javax.management.openmbean.OpenMBeanInfoSupport&lt;/code&gt;), the MBean class name, the string representation of infos on attributes, constructors, operations and notifications of the described MBean and the string representation of the descriptor.</source>
          <target state="translated">字符串表示形式包括此类的名称（即 &lt;code&gt;javax.management.openmbean.OpenMBeanInfoSupport&lt;/code&gt; ），MBean类名称，有关所描述的MBean的属性，构造函数，操作和通知的信息的字符串表示形式以及描述符的字符串表示形式。</target>
        </trans-unit>
        <trans-unit id="4ab6a7c24f824a223fbd8a3831c0c3e6970b8c12" translate="yes" xml:space="preserve">
          <source>The string representation consists of the name of this class (ie &lt;code&gt;javax.management.openmbean.OpenMBeanOperationInfo&lt;/code&gt;), and the name, signature, return open type and impact of the described operation.</source>
          <target state="translated">字符串表示形式由此类的名称（即 &lt;code&gt;javax.management.openmbean.OpenMBeanOperationInfo&lt;/code&gt; ）以及名称，签名，返回打开类型和所描述操作的影响组成。</target>
        </trans-unit>
        <trans-unit id="640c583f5e5f932dc18d233947e5f9f45c18d88c" translate="yes" xml:space="preserve">
          <source>The string representation consists of the name of this class (ie &lt;code&gt;javax.management.openmbean.OpenMBeanOperationInfoSupport&lt;/code&gt;), and the name, signature, return open type and impact of the described operation and the string representation of its descriptor.</source>
          <target state="translated">字符串表示形式包括此类的名称（即 &lt;code&gt;javax.management.openmbean.OpenMBeanOperationInfoSupport&lt;/code&gt; ），名称，签名，返回的打开类型和所描述操作的影响以及其描述符的字符串表示形式。</target>
        </trans-unit>
        <trans-unit id="56372f3341ed9c622ba1dff09dfa80ed9847d82f" translate="yes" xml:space="preserve">
          <source>The string representation consists of the name of this class (ie &lt;code&gt;javax.management.openmbean.OpenMBeanParameterInfo&lt;/code&gt;), the string representation of the name and open type of the described parameter, and the string representation of its default, min, max and legal values.</source>
          <target state="translated">字符串表示形式包括此类的名称（即 &lt;code&gt;javax.management.openmbean.OpenMBeanParameterInfo&lt;/code&gt; ），名称和所描述参数的开放类型的字符串表示形式以及其默认值，最小值，最大值和合法值的字符串表示形式。</target>
        </trans-unit>
        <trans-unit id="5e847596a7e03c71180c8216bb4f964ac80c8ce4" translate="yes" xml:space="preserve">
          <source>The string representation consists of the name of this class (ie &lt;code&gt;javax.management.openmbean.SimpleType&lt;/code&gt;) and the type name for this instance (which is the java class name of the values this &lt;code&gt;SimpleType&lt;/code&gt; instance represents).</source>
          <target state="translated">字符串表示形式由此类的名称（即 &lt;code&gt;javax.management.openmbean.SimpleType&lt;/code&gt; ）和该实例的类型名称（这是此 &lt;code&gt;SimpleType&lt;/code&gt; 实例表示的值的Java类名称）组成。</target>
        </trans-unit>
        <trans-unit id="cdd41d530879d983b77fc6d88438a6e273a7cdec" translate="yes" xml:space="preserve">
          <source>The string representation consists of the name of this class (ie &lt;code&gt;javax.management.openmbean.TabularDataSupport&lt;/code&gt;), the string representation of the tabular type of this instance, and the string representation of the contents (ie list the key=value mappings as returned by a call to &lt;code&gt;dataMap.&lt;/code&gt;&lt;a href=&quot;../../../../java.base/java/util/abstractmap#toString()&quot;&gt;&lt;code&gt;toString()&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">字符串表示形式包括此类的名称（即 &lt;code&gt;javax.management.openmbean.TabularDataSupport&lt;/code&gt; ），此实例的表格类型的字符串表示形式以及内容的字符串表示形式（即，列出由以下方法返回的key = value映射）调用 &lt;code&gt;dataMap.&lt;/code&gt; &lt;a href=&quot;../../../../java.base/java/util/abstractmap#toString()&quot;&gt; &lt;code&gt;toString()&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="574dc6c379e8e51bf167c7fea2d4d1304ca21c2f" translate="yes" xml:space="preserve">
          <source>The string representation consists of the name of this class (ie &lt;code&gt;javax.management.openmbean.TabularDataSupport&lt;/code&gt;), the string representation of the tabular type of this instance, and the string representation of the contents (ie list the key=value mappings as returned by a call to &lt;code&gt;dataMap.&lt;/code&gt;&lt;a href=&quot;../../../java/util/abstractmap#toString--&quot;&gt;&lt;code&gt;toString()&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">字符串表示形式包括此类的名称（即 &lt;code&gt;javax.management.openmbean.TabularDataSupport&lt;/code&gt; ），此实例的表格类型的字符串表示形式以及内容的字符串表示形式（即，列出由此类返回的key = value映射）调用 &lt;code&gt;dataMap.&lt;/code&gt; &lt;a href=&quot;../../../java/util/abstractmap#toString--&quot;&gt; &lt;code&gt;toString()&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="807fbdd5da5244bfb18ce040224682952e87d826" translate="yes" xml:space="preserve">
          <source>The string representation consists of the name of this class (ie &lt;code&gt;javax.management.openmbean.TabularType&lt;/code&gt;), the type name for this instance, the row type string representation of this instance, and the index names of this instance.</source>
          <target state="translated">字符串表示形式包括此类的名称（即 &lt;code&gt;javax.management.openmbean.TabularType&lt;/code&gt; ），此实例的类型名称，此实例的行类型字符串表示形式以及此实例的索引名称。</target>
        </trans-unit>
        <trans-unit id="fbc5fe65d5ab420dbf5b6b9fae291dad1f8925ed" translate="yes" xml:space="preserve">
          <source>The string representation for this &lt;code&gt;X500Principal&lt;/code&gt; can be obtained by calling the &lt;code&gt;getName&lt;/code&gt; methods.</source>
          <target state="translated">可以通过调用 &lt;code&gt;getName&lt;/code&gt; 方法获得此 &lt;code&gt;X500Principal&lt;/code&gt; 的字符串表示形式。</target>
        </trans-unit>
        <trans-unit id="cfa9c547b94d4a8505b4496d10852764a147d91f" translate="yes" xml:space="preserve">
          <source>The string representation may not have any leading and trailing whitespaces.</source>
          <target state="translated">字符串的表示方式不能有任何前导和尾部的空白。</target>
        </trans-unit>
        <trans-unit id="6b612d9c02babd7e1408d7e8d784cf99d9d55260" translate="yes" xml:space="preserve">
          <source>The string representation of the LdapName.</source>
          <target state="translated">LdapName的字符串表示。</target>
        </trans-unit>
        <trans-unit id="a420c385cddda341e69db0764ebb091c11a4a7be" translate="yes" xml:space="preserve">
          <source>The string representation of the Rdn.</source>
          <target state="translated">Rdn的字符串表示。</target>
        </trans-unit>
        <trans-unit id="06141090c2bbeee203d15ec52d1050014ee8d75b" translate="yes" xml:space="preserve">
          <source>The string representation of the attribute.</source>
          <target state="translated">属性的字符串表示。</target>
        </trans-unit>
        <trans-unit id="acdd753dd59a9a0afe3c3ebf5bba1d1c8f5326bd" translate="yes" xml:space="preserve">
          <source>The string representation of the attribute. This should exactly match the string specified in the CSS specification.</source>
          <target state="translated">属性的字符串表示。这应该与CSS规范中指定的字符串完全一致。</target>
        </trans-unit>
        <trans-unit id="6de482475e09c2eeff30bcc77f9f20ef06b16b86" translate="yes" xml:space="preserve">
          <source>The string representation of this SearchResult. Cannot be null.</source>
          <target state="translated">该SearchResult的字符串表示。不能为空。</target>
        </trans-unit>
        <trans-unit id="9095c816b4ff2b939ed38e5ec4c8dd104708dcc0" translate="yes" xml:space="preserve">
          <source>The string representation of this Service URL.</source>
          <target state="translated">该服务URL的字符串表示。</target>
        </trans-unit>
        <trans-unit id="19b1dc6e3c56c1f7d2c94a2810b048ff86117b35" translate="yes" xml:space="preserve">
          <source>The string representation of this Service URL. If the value returned by this method is supplied to the &lt;code&gt;JMXServiceURL&lt;/code&gt; constructor, the resultant object is equal to this one.</source>
          <target state="translated">此服务URL的字符串表示形式。如果此方法返回的值提供给 &lt;code&gt;JMXServiceURL&lt;/code&gt; 构造函数，则结果对象等于该对象。</target>
        </trans-unit>
        <trans-unit id="06f159652db61335f5666a5cf825b7a69627ed8c" translate="yes" xml:space="preserve">
          <source>The string representation of this exception consists of information about where the error occurred, and the first unexecuted modification.</source>
          <target state="translated">该异常的字符串表示由错误发生的位置和第一次未执行的修改信息组成。</target>
        </trans-unit>
        <trans-unit id="16f1d37b61e149769d5bb45d2d6b123bd696fbda" translate="yes" xml:space="preserve">
          <source>The string representation of this exception consists of information about where the error occurred, and the first unexecuted modification. This string is meant for debugging and not mean to be interpreted programmatically.</source>
          <target state="translated">这个异常的字符串表示包括错误发生的位置和第一次未执行的修改信息。这个字符串是用来调试的,而不是用来进行程序解释的。</target>
        </trans-unit>
        <trans-unit id="c7de16e9df6affa420db9ce81302405c1dfefd55" translate="yes" xml:space="preserve">
          <source>The string representation of this matcher</source>
          <target state="translated">该匹配器的字符串表示</target>
        </trans-unit>
        <trans-unit id="bb74ce786b3d545de3a84f33214617b02d5c2940" translate="yes" xml:space="preserve">
          <source>The string representation of this module</source>
          <target state="translated">该模块的字符串表示</target>
        </trans-unit>
        <trans-unit id="09eba65afc610d538d65c263d07c4a3212fcfe45" translate="yes" xml:space="preserve">
          <source>The string representation of this name/class pair.</source>
          <target state="translated">该名称/类对的字符串表示。</target>
        </trans-unit>
        <trans-unit id="053f914091e9887aaa58bf39744d8861af29fc0d" translate="yes" xml:space="preserve">
          <source>The string representation of this pattern</source>
          <target state="translated">该模式的字符串表示方法是</target>
        </trans-unit>
        <trans-unit id="c2acdbf9130b5c1f31215890014846c808d3f0b0" translate="yes" xml:space="preserve">
          <source>The string representation of this scanner</source>
          <target state="translated">该扫描仪的字符串表示</target>
        </trans-unit>
        <trans-unit id="f450b24ffb7d9483210505aa1ae5491f8f1973d0" translate="yes" xml:space="preserve">
          <source>The string returned by this method is equal to that returned by the &lt;a href=&quot;#getRawAuthority()&quot;&gt;&lt;code&gt;getRawAuthority&lt;/code&gt;&lt;/a&gt; method except that all sequences of escaped octets are &lt;a href=&quot;#decode&quot;&gt;decoded&lt;/a&gt;.</source>
          <target state="translated">此方法返回的字符串与&lt;a href=&quot;#getRawAuthority()&quot;&gt; &lt;code&gt;getRawAuthority&lt;/code&gt; &lt;/a&gt;方法返回的字符串相同，只是对所有转义八位字节的序列都进行了&lt;a href=&quot;#decode&quot;&gt;解码&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="17b139befffb2c60f26b6e3ef4ef71139b888633" translate="yes" xml:space="preserve">
          <source>The string returned by this method is equal to that returned by the &lt;a href=&quot;#getRawFragment()&quot;&gt;&lt;code&gt;getRawFragment&lt;/code&gt;&lt;/a&gt; method except that all sequences of escaped octets are &lt;a href=&quot;#decode&quot;&gt;decoded&lt;/a&gt;.</source>
          <target state="translated">此方法返回的字符串与&lt;a href=&quot;#getRawFragment()&quot;&gt; &lt;code&gt;getRawFragment&lt;/code&gt; &lt;/a&gt;方法返回的字符串相同，只是对所有转义八位字节的序列都进行了&lt;a href=&quot;#decode&quot;&gt;解码&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d13f16b94787c0c530d775e02f176898aa8709aa" translate="yes" xml:space="preserve">
          <source>The string returned by this method is equal to that returned by the &lt;a href=&quot;#getRawPath()&quot;&gt;&lt;code&gt;getRawPath&lt;/code&gt;&lt;/a&gt; method except that all sequences of escaped octets are &lt;a href=&quot;#decode&quot;&gt;decoded&lt;/a&gt;.</source>
          <target state="translated">此方法返回的字符串与&lt;a href=&quot;#getRawPath()&quot;&gt; &lt;code&gt;getRawPath&lt;/code&gt; &lt;/a&gt;方法返回的字符串相同，除了对所有转义八位字节的序列进行&lt;a href=&quot;#decode&quot;&gt;解码之外&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="49ceecc3a0a7b0c628428ecb824a9a4733fe10bc" translate="yes" xml:space="preserve">
          <source>The string returned by this method is equal to that returned by the &lt;a href=&quot;#getRawQuery()&quot;&gt;&lt;code&gt;getRawQuery&lt;/code&gt;&lt;/a&gt; method except that all sequences of escaped octets are &lt;a href=&quot;#decode&quot;&gt;decoded&lt;/a&gt;.</source>
          <target state="translated">此方法返回的字符串与&lt;a href=&quot;#getRawQuery()&quot;&gt; &lt;code&gt;getRawQuery&lt;/code&gt; &lt;/a&gt;方法返回的字符串相同，只是对所有转义八位字节的序列都进行了&lt;a href=&quot;#decode&quot;&gt;解码&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="950adaee23e256f95ac7d75c80da01a153533597" translate="yes" xml:space="preserve">
          <source>The string returned by this method is equal to that returned by the &lt;a href=&quot;#getRawSchemeSpecificPart()&quot;&gt;&lt;code&gt;getRawSchemeSpecificPart&lt;/code&gt;&lt;/a&gt; method except that all sequences of escaped octets are &lt;a href=&quot;#decode&quot;&gt;decoded&lt;/a&gt;.</source>
          <target state="translated">此方法返回的字符串与&lt;a href=&quot;#getRawSchemeSpecificPart()&quot;&gt; &lt;code&gt;getRawSchemeSpecificPart&lt;/code&gt; &lt;/a&gt;方法返回的字符串相同，只是对所有转义八位字节的序列都进行了&lt;a href=&quot;#decode&quot;&gt;解码&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="da24186777164723ddd293bab7dd828e99e48a24" translate="yes" xml:space="preserve">
          <source>The string returned by this method is equal to that returned by the &lt;a href=&quot;#getRawUserInfo()&quot;&gt;&lt;code&gt;getRawUserInfo&lt;/code&gt;&lt;/a&gt; method except that all sequences of escaped octets are &lt;a href=&quot;#decode&quot;&gt;decoded&lt;/a&gt;.</source>
          <target state="translated">此方法返回的字符串与&lt;a href=&quot;#getRawUserInfo()&quot;&gt; &lt;code&gt;getRawUserInfo&lt;/code&gt; &lt;/a&gt;方法返回的字符串相同，只是对所有转义八位字节的序列都进行了&lt;a href=&quot;#decode&quot;&gt;解码&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0428783f6a2a4ed333a95d1448a2bc32086c9f46" translate="yes" xml:space="preserve">
          <source>The string returned by this method is equal to that returned by the &lt;a href=&quot;uri#getRawAuthority--&quot;&gt;&lt;code&gt;getRawAuthority&lt;/code&gt;&lt;/a&gt; method except that all sequences of escaped octets are &lt;a href=&quot;#decode&quot;&gt;decoded&lt;/a&gt;.</source>
          <target state="translated">此方法返回的字符串与&lt;a href=&quot;uri#getRawAuthority--&quot;&gt; &lt;code&gt;getRawAuthority&lt;/code&gt; &lt;/a&gt;方法返回的字符串相同，只是对所有转义八位字节的序列进行&lt;a href=&quot;#decode&quot;&gt;解码&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="99f4ef96c814a7c3937663953ec5ac06f173ebb2" translate="yes" xml:space="preserve">
          <source>The string returned by this method is equal to that returned by the &lt;a href=&quot;uri#getRawFragment--&quot;&gt;&lt;code&gt;getRawFragment&lt;/code&gt;&lt;/a&gt; method except that all sequences of escaped octets are &lt;a href=&quot;#decode&quot;&gt;decoded&lt;/a&gt;.</source>
          <target state="translated">此方法返回的字符串与&lt;a href=&quot;uri#getRawFragment--&quot;&gt; &lt;code&gt;getRawFragment&lt;/code&gt; &lt;/a&gt;方法返回的字符串相同，只是对所有转义八位字节的序列进行&lt;a href=&quot;#decode&quot;&gt;解码&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a732cb50bbec78c973952b48ad9babe398c8380c" translate="yes" xml:space="preserve">
          <source>The string returned by this method is equal to that returned by the &lt;a href=&quot;uri#getRawPath--&quot;&gt;&lt;code&gt;getRawPath&lt;/code&gt;&lt;/a&gt; method except that all sequences of escaped octets are &lt;a href=&quot;#decode&quot;&gt;decoded&lt;/a&gt;.</source>
          <target state="translated">此方法返回的字符串与&lt;a href=&quot;uri#getRawPath--&quot;&gt; &lt;code&gt;getRawPath&lt;/code&gt; &lt;/a&gt;方法返回的字符串相同，只是对所有转义八位字节的序列进行&lt;a href=&quot;#decode&quot;&gt;解码&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ddd6a70f437a36a8a334d3aa1a18560bd5c5720e" translate="yes" xml:space="preserve">
          <source>The string returned by this method is equal to that returned by the &lt;a href=&quot;uri#getRawQuery--&quot;&gt;&lt;code&gt;getRawQuery&lt;/code&gt;&lt;/a&gt; method except that all sequences of escaped octets are &lt;a href=&quot;#decode&quot;&gt;decoded&lt;/a&gt;.</source>
          <target state="translated">此方法返回的字符串与&lt;a href=&quot;uri#getRawQuery--&quot;&gt; &lt;code&gt;getRawQuery&lt;/code&gt; &lt;/a&gt;方法返回的字符串相同，只是对所有转义八位字节的序列进行&lt;a href=&quot;#decode&quot;&gt;解码&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bc1a87d2cf19c437c64a305afdb85f728af90351" translate="yes" xml:space="preserve">
          <source>The string returned by this method is equal to that returned by the &lt;a href=&quot;uri#getRawSchemeSpecificPart--&quot;&gt;&lt;code&gt;getRawSchemeSpecificPart&lt;/code&gt;&lt;/a&gt; method except that all sequences of escaped octets are &lt;a href=&quot;#decode&quot;&gt;decoded&lt;/a&gt;.</source>
          <target state="translated">此方法返回的字符串与&lt;a href=&quot;uri#getRawSchemeSpecificPart--&quot;&gt; &lt;code&gt;getRawSchemeSpecificPart&lt;/code&gt; &lt;/a&gt;方法返回的字符串相同，只是对所有转义八位字节的序列进行&lt;a href=&quot;#decode&quot;&gt;解码&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fc4374f3d0ad6e121222206c9e637bf592e8f4f3" translate="yes" xml:space="preserve">
          <source>The string returned by this method is equal to that returned by the &lt;a href=&quot;uri#getRawUserInfo--&quot;&gt;&lt;code&gt;getRawUserInfo&lt;/code&gt;&lt;/a&gt; method except that all sequences of escaped octets are &lt;a href=&quot;#decode&quot;&gt;decoded&lt;/a&gt;.</source>
          <target state="translated">此方法返回的字符串与&lt;a href=&quot;uri#getRawUserInfo--&quot;&gt; &lt;code&gt;getRawUserInfo&lt;/code&gt; &lt;/a&gt;方法返回的字符串相同，只是对所有转义八位字节的序列进行&lt;a href=&quot;#decode&quot;&gt;解码&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="15003a859c5ec3a6cdfdb74230384f43324ebc22" translate="yes" xml:space="preserve">
          <source>The string returned by this method is not a JNDI composite name and should not be passed directly to context methods.</source>
          <target state="translated">该方法返回的字符串不是JNDI复合名,不应直接传递给上下文方法。</target>
        </trans-unit>
        <trans-unit id="720d46b0678e4b58ffd12635e35e8f669c782484" translate="yes" xml:space="preserve">
          <source>The string returned by this method may differ from the string returned by the &lt;a href=&quot;../../lang/object#toString()&quot;&gt;&lt;code&gt;toString&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">此方法返回的字符串可能与&lt;a href=&quot;../../lang/object#toString()&quot;&gt; &lt;code&gt;toString&lt;/code&gt; &lt;/a&gt;方法返回的字符串不同。</target>
        </trans-unit>
        <trans-unit id="f2d86e2c12a8b526574d8ed3d4f0ad084aa1496f" translate="yes" xml:space="preserve">
          <source>The string returned by this method may differ from the string returned by the &lt;a href=&quot;../../lang/object#toString--&quot;&gt;&lt;code&gt;toString&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">此方法返回的字符串可能与&lt;a href=&quot;../../lang/object#toString--&quot;&gt; &lt;code&gt;toString&lt;/code&gt; &lt;/a&gt;方法返回的字符串不同。</target>
        </trans-unit>
        <trans-unit id="edba6dbdeab519bfb2488ac8fa5d24d1d5096a05" translate="yes" xml:space="preserve">
          <source>The string returned is made of the text content of this node depending on its type, as defined below:</source>
          <target state="translated">返回的字符串是由这个节点的文本内容组成的,取决于其类型,定义如下。</target>
        </trans-unit>
        <trans-unit id="a98b16691a6548a5f40d785a69cfe7819a08aa9f" translate="yes" xml:space="preserve">
          <source>The string starts with an optional sign, denoted by the ASCII negative or positive symbol. If negative, the whole period is negated. The ASCII letter &quot;P&quot; is next in upper or lower case. There are then four sections, each consisting of a number and a suffix. At least one of the four sections must be present. The sections have suffixes in ASCII of &quot;Y&quot;, &quot;M&quot;, &quot;W&quot; and &quot;D&quot; for years, months, weeks and days, accepted in upper or lower case. The suffixes must occur in order. The number part of each section must consist of ASCII digits. The number may be prefixed by the ASCII negative or positive symbol. The number must parse to an &lt;code&gt;int&lt;/code&gt;.</source>
          <target state="translated">字符串以可选符号开头，以ASCII负号或正号表示。如果为负，则整个周期都取反。 ASCII字母&amp;ldquo; P&amp;rdquo;为大写或小写。然后有四个部分，每个部分都包含一个数字和一个后缀。必须至少存在四个部分之一。这些部分的年份，月份，星期和天的ASCII后缀&amp;ldquo; Y&amp;rdquo;，&amp;ldquo; M&amp;rdquo;，&amp;ldquo; W&amp;rdquo;和&amp;ldquo; D&amp;rdquo;以大写或小写接受。后缀必须按顺序出现。每个部分的数字部分必须由ASCII数字组成。该数字可以以ASCII负号或正号作为前缀。该数字必须解析为一个 &lt;code&gt;int&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d0a3cf68706224b4e1564938792fbbb36cb2a5f2" translate="yes" xml:space="preserve">
          <source>The string starts with an optional sign, denoted by the ASCII negative or positive symbol. If negative, the whole period is negated. The ASCII letter &quot;P&quot; is next in upper or lower case. There are then four sections, each consisting of a number and a suffix. The sections have suffixes in ASCII of &quot;D&quot;, &quot;H&quot;, &quot;M&quot; and &quot;S&quot; for days, hours, minutes and seconds, accepted in upper or lower case. The suffixes must occur in order. The ASCII letter &quot;T&quot; must occur before the first occurrence, if any, of an hour, minute or second section. At least one of the four sections must be present, and if &quot;T&quot; is present there must be at least one section after the &quot;T&quot;. The number part of each section must consist of one or more ASCII digits. The number may be prefixed by the ASCII negative or positive symbol. The number of days, hours and minutes must parse to a &lt;code&gt;long&lt;/code&gt;. The number of seconds must parse to a &lt;code&gt;long&lt;/code&gt; with optional fraction. The decimal point may be either a dot or a comma. The fractional part may have from zero to 9 digits.</source>
          <target state="translated">字符串以可选符号开头，以ASCII负号或正号表示。如果为负，则整个周期都取反。 ASCII字母&amp;ldquo; P&amp;rdquo;以大写或小写表示。然后有四个部分，每个部分都包含一个数字和一个后缀。这些部分具有以天，小时，分钟和秒为单位的ASCII后缀&amp;ldquo; D&amp;rdquo;，&amp;ldquo; H&amp;rdquo;，&amp;ldquo; M&amp;rdquo;和&amp;ldquo; S&amp;rdquo;，以大写或小写形式接受。后缀必须按顺序出现。 ASCII字母&amp;ldquo; T&amp;rdquo;必须出现在小时，分钟或第二部分的第一次出现之前（如果有的话）。必须存在四个部分中的至少一个，并且如果存在&amp;ldquo; T&amp;rdquo;，则必须在&amp;ldquo; T&amp;rdquo;之后至少包含一个部分。每个部分的数字部分必须包含一个或多个ASCII数字。该数字可以以ASCII负号或正号作为前缀。天数，小时数和分钟数必须解析为一个 &lt;code&gt;long&lt;/code&gt; 。秒数必须解析为带可选分数的 &lt;code&gt;long&lt;/code&gt; 整数。小数点可以是点或逗号。小数部分的位数可以为0到9位。</target>
        </trans-unit>
        <trans-unit id="89a747d82990c6aea3987f68f6f2f3b3b15c1eff" translate="yes" xml:space="preserve">
          <source>The string starts with an optional sign, denoted by the ASCII negative or positive symbol. If negative, the whole period is negated. The ASCII letter &quot;P&quot; is next in upper or lower case. There are then four sections, each consisting of a number and a suffix. The sections have suffixes in ASCII of &quot;D&quot;, &quot;H&quot;, &quot;M&quot; and &quot;S&quot; for days, hours, minutes and seconds, accepted in upper or lower case. The suffixes must occur in order. The ASCII letter &quot;T&quot; must occur before the first occurrence, if any, of an hour, minute or second section. At least one of the four sections must be present, and if &quot;T&quot; is present there must be at least one section after the &quot;T&quot;. The number part of each section must consist of one or more ASCII digits. The number may be prefixed by the ASCII negative or positive symbol. The number of days, hours and minutes must parse to an &lt;code&gt;long&lt;/code&gt;. The number of seconds must parse to an &lt;code&gt;long&lt;/code&gt; with optional fraction. The decimal point may be either a dot or a comma. The fractional part may have from zero to 9 digits.</source>
          <target state="translated">字符串以可选符号开头，以ASCII负号或正号表示。如果为负，则整个周期都取反。 ASCII字母&amp;ldquo; P&amp;rdquo;为大写或小写。然后有四个部分，每个部分都包含一个数字和一个后缀。这些部分具有以天，小时，分钟和秒为单位的ASCII后缀&amp;ldquo; D&amp;rdquo;，&amp;ldquo; H&amp;rdquo;，&amp;ldquo; M&amp;rdquo;和&amp;ldquo; S&amp;rdquo;，以大写或小写形式接受。后缀必须按顺序出现。 ASCII字母&amp;ldquo; T&amp;rdquo;必须在小时，分钟或第二部分的第一次出现（如果有）之前出现。必须存在四个部分中的至少一个，如果存在&amp;ldquo; T&amp;rdquo;，则必须在&amp;ldquo; T&amp;rdquo;之后至少有一个部分。每个部分的数字部分必须包含一个或多个ASCII数字。该数字可以以ASCII负号或正号作为前缀。天数，小时数和分钟数必须解析为一个 &lt;code&gt;long&lt;/code&gt; 。秒数必须解析为带可选分数的 &lt;code&gt;long&lt;/code&gt; 整数。小数点可以是点或逗号。小数部分的位数可以为0到9位。</target>
        </trans-unit>
        <trans-unit id="4685a9bbdb9380ea8c94c58ff588b3c8fbe09edf" translate="yes" xml:space="preserve">
          <source>The string that appears after a negative number (may be empty),</source>
          <target state="translated">负数后出现的字符串(可能为空)。</target>
        </trans-unit>
        <trans-unit id="121fd276daa28030f6a820cb1573874d3a75d6c9" translate="yes" xml:space="preserve">
          <source>The string that appears after a positive number (may be empty),</source>
          <target state="translated">出现在正数后面的字符串(可能为空)。</target>
        </trans-unit>
        <trans-unit id="5bdb1009de16112ed78878cf54efa430f792f9b9" translate="yes" xml:space="preserve">
          <source>The string that appears before a negative number (may be empty),</source>
          <target state="translated">出现在负数前的字符串(可能为空)。</target>
        </trans-unit>
        <trans-unit id="ca10167dd9b711a6fe69878b203a07e7493844d5" translate="yes" xml:space="preserve">
          <source>The string that appears before a positive number (may be empty),</source>
          <target state="translated">出现在正数前的字符串(可能为空)。</target>
        </trans-unit>
        <trans-unit id="1230518d13d5910243029a9e67f1cba26841e687" translate="yes" xml:space="preserve">
          <source>The string that represents infinity for floating-point values,</source>
          <target state="translated">代表浮点值的无穷大的字符串。</target>
        </trans-unit>
        <trans-unit id="0ef60f4fe5623badec9511506d8c3e9aab99fce8" translate="yes" xml:space="preserve">
          <source>The string that represents not-a-number for floating-point values,</source>
          <target state="translated">表示浮点数的非数值的字符串。</target>
        </trans-unit>
        <trans-unit id="a78a098297ed979ec8fd87a13cc391ae93c8972a" translate="yes" xml:space="preserve">
          <source>The string tokenizer class allows an application to break a string into tokens.</source>
          <target state="translated">string tokenizer类允许应用程序将一个字符串分解成标记。</target>
        </trans-unit>
        <trans-unit id="04fb2cffb71f257048052d20b8fe56a4f66e790f" translate="yes" xml:space="preserve">
          <source>The string tokenizer class allows an application to break a string into tokens. The tokenization method is much simpler than the one used by the &lt;code&gt;StreamTokenizer&lt;/code&gt; class. The &lt;code&gt;StringTokenizer&lt;/code&gt; methods do not distinguish among identifiers, numbers, and quoted strings, nor do they recognize and skip comments.</source>
          <target state="translated">字符串标记化程序类允许应用程序将字符串分成标记。令牌化方法比 &lt;code&gt;StreamTokenizer&lt;/code&gt; 类使用的方法简单得多。该 &lt;code&gt;StringTokenizer&lt;/code&gt; 的方法不标识符，数字和引用字符串区分，它们也不识别和跳过注释。</target>
        </trans-unit>
        <trans-unit id="53fa55c105fb0b4c765bc0d34087bf552da7b9c4" translate="yes" xml:space="preserve">
          <source>The string used to display the String in the syntax of the scripting language.</source>
          <target state="translated">用脚本语言的语法来显示String的字符串。</target>
        </trans-unit>
        <trans-unit id="045b2391e6e713813d68e301a750110f4ff3677c" translate="yes" xml:space="preserve">
          <source>The string value in the current unit. The current &lt;code&gt;primitiveType&lt;/code&gt; can only be a string unit type (i.e. &lt;code&gt;CSS_STRING&lt;/code&gt;, &lt;code&gt;CSS_URI&lt;/code&gt;, &lt;code&gt;CSS_IDENT&lt;/code&gt; and &lt;code&gt;CSS_ATTR&lt;/code&gt;).</source>
          <target state="translated">当前单位的字符串值。当前 &lt;code&gt;primitiveType&lt;/code&gt; 只能是一个字符串单元类型（即 &lt;code&gt;CSS_STRING&lt;/code&gt; ， &lt;code&gt;CSS_URI&lt;/code&gt; ， &lt;code&gt;CSS_IDENT&lt;/code&gt; 和 &lt;code&gt;CSS_ATTR&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="c78459f86d1f255e120d7d995d1329b245c41ee8" translate="yes" xml:space="preserve">
          <source>The string value of the output property, or null if no property was found.</source>
          <target state="translated">输出属性的字符串值,如果没有找到属性则为空。</target>
        </trans-unit>
        <trans-unit id="6b860b97ae2648994958ff5f145b7575c2d21991" translate="yes" xml:space="preserve">
          <source>The string value.</source>
          <target state="translated">字符串值。</target>
        </trans-unit>
        <trans-unit id="f11c947d653626328bad48f1c4cdf9159acc0a3b" translate="yes" xml:space="preserve">
          <source>The strings that can be parsed as numbers by an instance of this class are specified in terms of the following regular-expression grammar, where Rmax is the highest digit in the radix being used (for example, Rmax is 9 in base 10).</source>
          <target state="translated">这个类的实例可以解析为数字的字符串是用下面的正则表达式语法来指定的,其中Rmax是所使用的弧度中的最高位数(例如,Rmax是10进制的9)。</target>
        </trans-unit>
        <trans-unit id="192956733edd06bdd0c654a6ba995e1bcee04c0f" translate="yes" xml:space="preserve">
          <source>The structure and contents of the &quot;native&quot; metadata format are defined by the plug-in that created this &lt;code&gt;IIOMetadata&lt;/code&gt; object. Plug-ins for simple formats will usually create a dummy node for the root, and then a series of child nodes representing individual tags, chunks, or keyword/value pairs. A plug-in may choose whether or not to document its native format.</source>
          <target state="translated">&amp;ldquo;本机&amp;rdquo;元数据格式的结构和内容由创建此 &lt;code&gt;IIOMetadata&lt;/code&gt; 对象的插件定义。用于简单格式的插件通常会为根创建一个虚拟节点，然后为代表各个标签，块或关键字/值对的一系列子节点创建一个虚拟节点。插件可以选择是否记录其本机格式。</target>
        </trans-unit>
        <trans-unit id="0d00af5b5c0dfb3866ccfa55c912f873c782dbff" translate="yes" xml:space="preserve">
          <source>The structure and encoding of Oids is defined in ISOIEC-8824 and ISOIEC-8825. For example the Oid representation of Kerberos V5 mechanism is &quot;1.2.840.113554.1.2.2&quot;</source>
          <target state="translated">Oid的结构和编码在ISOIEC-8824和ISOIEC-8825中被定义。例如,Kerberos V5机制的Oid表示为 &quot;1.2.840.113554.1.2.2&quot;</target>
        </trans-unit>
        <trans-unit id="cb2c5dc909eef768d7f9cd7e34bb554bcaaaebaa" translate="yes" xml:space="preserve">
          <source>The structure is a return type accompanied by any number of parameter types. The types (primitive, &lt;code&gt;void&lt;/code&gt;, and reference) are represented by &lt;a href=&quot;../class&quot;&gt;&lt;code&gt;Class&lt;/code&gt;&lt;/a&gt; objects. (For ease of exposition, we treat &lt;code&gt;void&lt;/code&gt; as if it were a type. In fact, it denotes the absence of a return type.)</source>
          <target state="translated">该结构是返回类型，并带有任意数量的参数类型。类型（原始， &lt;code&gt;void&lt;/code&gt; 和引用）由&lt;a href=&quot;../class&quot;&gt; &lt;code&gt;Class&lt;/code&gt; &lt;/a&gt;对象表示。（为了便于说明，我们将 &lt;code&gt;void&lt;/code&gt; 当作类型来对待。实际上，它表示没有返回类型。）</target>
        </trans-unit>
        <trans-unit id="fdfbb9e2e84d666d2a855ee7c1631508d148c17f" translate="yes" xml:space="preserve">
          <source>The structures that may be described by this class are a subset of those expressible using XML document type definitions (DTDs), with the addition of some basic information on the datatypes of attributes and the ability to store an &lt;code&gt;Object&lt;/code&gt; reference within a node. In the future, XML Schemas could be used to represent these structures, and many others.</source>
          <target state="translated">此类可以描述的结构是可使用XML文档类型定义（DTD）表示的那些结构的子集，此外还添加了有关属性数据类型的一些基本信息以及在节点内存储 &lt;code&gt;Object&lt;/code&gt; 引用的能力。将来，XML模式可以用于表示这些结构以及许多其他结构。</target>
        </trans-unit>
        <trans-unit id="bc1300b7e4fbbe647c420f08d4ea464e607a0b93" translate="yes" xml:space="preserve">
          <source>The stub class is loaded by name using the class loader of the root class. The stub class must be public, it must extend &lt;a href=&quot;remotestub&quot;&gt;&lt;code&gt;RemoteStub&lt;/code&gt;&lt;/a&gt;, it must reside in a package that is exported to at least the &lt;code&gt;java.rmi&lt;/code&gt; module, and it must have a public constructor that has one parameter of type &lt;a href=&quot;remoteref&quot;&gt;&lt;code&gt;RemoteRef&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">存根类是使用根类的类加载器按名称加载的。存根类必须是公共的，它必须扩展&lt;a href=&quot;remotestub&quot;&gt; &lt;code&gt;RemoteStub&lt;/code&gt; &lt;/a&gt;，它必须驻留在至少导出到 &lt;code&gt;java.rmi&lt;/code&gt; 模块的包中，并且它必须具有一个公共构造函数，该构造函数具有一个类型为&lt;a href=&quot;remoteref&quot;&gt; &lt;code&gt;RemoteRef&lt;/code&gt; 的&lt;/a&gt;参数。</target>
        </trans-unit>
        <trans-unit id="a232a3677fbba52c761d261392a47c4a403e95f0" translate="yes" xml:space="preserve">
          <source>The stub might not yet be connected to the ORB. The stub will be serializable only if it is connected to the ORB.</source>
          <target state="translated">存根可能还没有连接到ORB。只有当存根连接到ORB时,存根才能被序列化。</target>
        </trans-unit>
        <trans-unit id="7a3dc219e67d57ff39f5f91a47d644371a7f81d7" translate="yes" xml:space="preserve">
          <source>The style attribute.</source>
          <target state="translated">风格属性。</target>
        </trans-unit>
        <trans-unit id="7ed2b6144ace5c60a1401e5428a1fc3686ffe408" translate="yes" xml:space="preserve">
          <source>The style of this &lt;code&gt;Font&lt;/code&gt;, as passed to the constructor.</source>
          <target state="translated">传递给构造函数的 &lt;code&gt;Font&lt;/code&gt; 的样式。</target>
        </trans-unit>
        <trans-unit id="498a3c78ad0c0604083f3769f1ef9e8b0c526e13" translate="yes" xml:space="preserve">
          <source>The style of this &lt;code&gt;Font&lt;/code&gt;, as passed to the constructor. This style can be PLAIN, BOLD, ITALIC, or BOLD+ITALIC.</source>
          <target state="translated">传递给构造函数的 &lt;code&gt;Font&lt;/code&gt; 的样式。此样式可以是PLAIN，BOLD，ITALIC或BOLD + ITALIC。</target>
        </trans-unit>
        <trans-unit id="3b5b369b33d039728a33986fe140d97ea7763679" translate="yes" xml:space="preserve">
          <source>The style rule at the &lt;code&gt;index&lt;/code&gt; position in the &lt;code&gt;CSSRuleList&lt;/code&gt;, or &lt;code&gt;null&lt;/code&gt; if that is not a valid index.</source>
          <target state="translated">在样式规则 &lt;code&gt;index&lt;/code&gt; 中的位置 &lt;code&gt;CSSRuleList&lt;/code&gt; ，或 &lt;code&gt;null&lt;/code&gt; ，如果这不是一个有效的索引。</target>
        </trans-unit>
        <trans-unit id="bbf88eb588be0aeabba5debf950c788477d4b197" translate="yes" xml:space="preserve">
          <source>The style sheet at the &lt;code&gt;index&lt;/code&gt; position in the &lt;code&gt;StyleSheetList&lt;/code&gt;, or &lt;code&gt;null&lt;/code&gt; if that is not a valid index.</source>
          <target state="translated">样式表的 &lt;code&gt;index&lt;/code&gt; 中的位置 &lt;code&gt;StyleSheetList&lt;/code&gt; ，或 &lt;code&gt;null&lt;/code&gt; ，如果不是有效的索引。</target>
        </trans-unit>
        <trans-unit id="f8c8a67944fd96db1f04f842832d7d391bf84eef" translate="yes" xml:space="preserve">
          <source>The style sheet referred to by this rule, if it has been loaded.</source>
          <target state="translated">该规则所引用的样式表,如果它已经被加载。</target>
        </trans-unit>
        <trans-unit id="4acffc6c2b340e9ca17170b9fd8575da7b38779f" translate="yes" xml:space="preserve">
          <source>The style sheet referred to by this rule, if it has been loaded. The value of this attribute is &lt;code&gt;null&lt;/code&gt; if the style sheet has not yet been loaded or if it will not be loaded (e.g. if the style sheet is for a media type not supported by the user agent).</source>
          <target state="translated">此规则引用的样式表（如果已加载）。如果尚未加载样式表或将不加载样式表，则此属性的值为 &lt;code&gt;null&lt;/code&gt; （例如，如果样式表用于用户代理不支持的媒体类型）。</target>
        </trans-unit>
        <trans-unit id="2f92ba7a8105c55f452b0e9e30526dc55ff36366" translate="yes" xml:space="preserve">
          <source>The style sheet that contains this rule.</source>
          <target state="translated">包含该规则的样式表。</target>
        </trans-unit>
        <trans-unit id="d9f53855d9d4fc11da63155553b0c59e74844f7d" translate="yes" xml:space="preserve">
          <source>The style sheet.</source>
          <target state="translated">样式表。</target>
        </trans-unit>
        <trans-unit id="aff2ab664c61a826342f48467d919591b7be5528" translate="yes" xml:space="preserve">
          <source>The sub-range is defined to be out of bounds if any of the following inequalities is true:</source>
          <target state="translated">如果以下任何一个不等式为真,则子范围被定义为越界。</target>
        </trans-unit>
        <trans-unit id="e5c879c6bdae17e077ece202d05c591a659999bb" translate="yes" xml:space="preserve">
          <source>The subclass may supply a different base name for the resource bundles using the &lt;code&gt;setResourceBaseName&lt;/code&gt; method.</source>
          <target state="translated">子类可以使用 &lt;code&gt;setResourceBaseName&lt;/code&gt; 方法为资源束提供不同的基本名称。</target>
        </trans-unit>
        <trans-unit id="527c0a0960cc0fe34b4ce860e5a1c2222c46e968" translate="yes" xml:space="preserve">
          <source>The subclass of &lt;a href=&quot;sqlexception&quot;&gt;&lt;code&gt;SQLException&lt;/code&gt;&lt;/a&gt; for the SQLState class value '</source>
          <target state="translated">SQLState的&lt;a href=&quot;sqlexception&quot;&gt; &lt;code&gt;SQLException&lt;/code&gt; &lt;/a&gt;子类值'</target>
        </trans-unit>
        <trans-unit id="7713c2f78de0d5ff78645f34f1aa9c89839a8b5a" translate="yes" xml:space="preserve">
          <source>The subclass of &lt;a href=&quot;sqlexception&quot;&gt;&lt;code&gt;SQLException&lt;/code&gt;&lt;/a&gt; is thrown in situations where a previously failed operation might be able to succeed when the operation is retried without any intervention by application-level functionality.</source>
          <target state="translated">在重试该操作而无需应用程序级功能干预的情况下，先前失败的操作可能能够成功的情况下，将抛出&lt;a href=&quot;sqlexception&quot;&gt; &lt;code&gt;SQLException&lt;/code&gt; &lt;/a&gt;的子类。</target>
        </trans-unit>
        <trans-unit id="80f483f7072263836c5107593eb17db254d36bf4" translate="yes" xml:space="preserve">
          <source>The subclass of &lt;a href=&quot;sqlexception&quot;&gt;&lt;code&gt;SQLException&lt;/code&gt;&lt;/a&gt; is thrown when one or more client info properties could not be set on a &lt;code&gt;Connection&lt;/code&gt;.</source>
          <target state="translated">当无法在 &lt;code&gt;Connection&lt;/code&gt; 上设置一个或多个客户端信息属性时，将&lt;a href=&quot;sqlexception&quot;&gt; &lt;code&gt;SQLException&lt;/code&gt; &lt;/a&gt;的子类。</target>
        </trans-unit>
        <trans-unit id="7b3fc8fd4fb26a88d9f95ef4851700e0411e08a2" translate="yes" xml:space="preserve">
          <source>The subclass of &lt;a href=&quot;sqlexception&quot;&gt;&lt;code&gt;SQLException&lt;/code&gt;&lt;/a&gt; is thrown when one or more client info properties could not be set on a &lt;code&gt;Connection&lt;/code&gt;. In addition to the information provided by &lt;code&gt;SQLException&lt;/code&gt;, a &lt;code&gt;SQLClientInfoException&lt;/code&gt; provides a list of client info properties that were not set. Some databases do not allow multiple client info properties to be set atomically. For those databases, it is possible that some of the client info properties had been set even though the &lt;code&gt;Connection.setClientInfo&lt;/code&gt; method threw an exception. An application can use the &lt;code&gt;getFailedProperties &lt;/code&gt; method to retrieve a list of client info properties that were not set. The properties are identified by passing a &lt;code&gt;Map&amp;lt;String,ClientInfoStatus&amp;gt;&lt;/code&gt; to the appropriate &lt;code&gt;SQLClientInfoException&lt;/code&gt; constructor.</source>
          <target state="translated">当无法在 &lt;code&gt;Connection&lt;/code&gt; 上设置一个或多个客户端信息属性时，将&lt;a href=&quot;sqlexception&quot;&gt; &lt;code&gt;SQLException&lt;/code&gt; &lt;/a&gt;的子类。除了 &lt;code&gt;SQLException&lt;/code&gt; 提供的信息之外， &lt;code&gt;SQLClientInfoException&lt;/code&gt; 还提供未设置的客户端信息属性的列表。某些数据库不允许自动设置多个客户端信息属性。对于那些数据库，即使 &lt;code&gt;Connection.setClientInfo&lt;/code&gt; 方法引发了异常，也可能已经设置了某些客户端信息属性。应用程序可以使用 &lt;code&gt;getFailedProperties &lt;/code&gt; 方法检索未设置的客户端信息属性的列表。通过传递一个 &lt;code&gt;Map&amp;lt;String,ClientInfoStatus&amp;gt;&lt;/code&gt; 到适当的 &lt;code&gt;SQLClientInfoException&lt;/code&gt; 构造函数。</target>
        </trans-unit>
        <trans-unit id="6717effbf2eae66083ee44deed5d8b60c5c6fe2d" translate="yes" xml:space="preserve">
          <source>The subclass of &lt;a href=&quot;sqlexception&quot;&gt;&lt;code&gt;SQLException&lt;/code&gt;&lt;/a&gt; thrown for the SQLState class value '</source>
          <target state="translated">为SQLState类值'抛出的&lt;a href=&quot;sqlexception&quot;&gt; &lt;code&gt;SQLException&lt;/code&gt; &lt;/a&gt;子类</target>
        </trans-unit>
        <trans-unit id="8607beac95f1d4cb0f607da7d63685d6dfbf8d4c" translate="yes" xml:space="preserve">
          <source>The subclass of &lt;a href=&quot;sqlexception&quot;&gt;&lt;code&gt;SQLException&lt;/code&gt;&lt;/a&gt; thrown in situations where a previously failed operation might be able to succeed if the application performs some recovery steps and retries the entire transaction or in the case of a distributed transaction, the transaction branch.</source>
          <target state="translated">如果应用程序执行一些恢复步骤并重试整个事务，或者如果是分布式事务，则返回事务分支，如果先前失败的操作可能能够成功，则抛出&lt;a href=&quot;sqlexception&quot;&gt; &lt;code&gt;SQLException&lt;/code&gt; &lt;/a&gt;的子类。</target>
        </trans-unit>
        <trans-unit id="bbb8274ee2db6a0201b391b30cdfd8adbecfb841" translate="yes" xml:space="preserve">
          <source>The subclass of &lt;a href=&quot;sqlexception&quot;&gt;&lt;code&gt;SQLException&lt;/code&gt;&lt;/a&gt; thrown in situations where a previously failed operation might be able to succeed if the application performs some recovery steps and retries the entire transaction or in the case of a distributed transaction, the transaction branch. At a minimum, the recovery operation must include closing the current connection and getting a new connection.</source>
          <target state="translated">如果应用程序执行一些恢复步骤并重试整个事务，或者如果是分布式事务，则返回事务分支，如果先前失败的操作可能能够成功，则抛出&lt;a href=&quot;sqlexception&quot;&gt; &lt;code&gt;SQLException&lt;/code&gt; &lt;/a&gt;的子类。至少，恢复操作必须包括关闭当前连接并获得新连接。</target>
        </trans-unit>
        <trans-unit id="a54587a45ff8b2645e125fd0b8ffb8307a8ef66b" translate="yes" xml:space="preserve">
          <source>The subclass of &lt;a href=&quot;sqlexception&quot;&gt;&lt;code&gt;SQLException&lt;/code&gt;&lt;/a&gt; thrown when an error occurs during a batch update operation.</source>
          <target state="translated">在批处理更新操作期间发生错误时引发的&lt;a href=&quot;sqlexception&quot;&gt; &lt;code&gt;SQLException&lt;/code&gt; &lt;/a&gt;的子类。</target>
        </trans-unit>
        <trans-unit id="803499fb5061ae4d61cec028a03de443ffd7786f" translate="yes" xml:space="preserve">
          <source>The subclass of &lt;a href=&quot;sqlexception&quot;&gt;&lt;code&gt;SQLException&lt;/code&gt;&lt;/a&gt; thrown when an error occurs during a batch update operation. In addition to the information provided by &lt;a href=&quot;sqlexception&quot;&gt;&lt;code&gt;SQLException&lt;/code&gt;&lt;/a&gt;, a &lt;code&gt;BatchUpdateException&lt;/code&gt; provides the update counts for all commands that were executed successfully during the batch update, that is, all commands that were executed before the error occurred. The order of elements in an array of update counts corresponds to the order in which commands were added to the batch.</source>
          <target state="translated">在批处理更新操作期间发生错误时引发的&lt;a href=&quot;sqlexception&quot;&gt; &lt;code&gt;SQLException&lt;/code&gt; &lt;/a&gt;的子类。除了&lt;a href=&quot;sqlexception&quot;&gt; &lt;code&gt;SQLException&lt;/code&gt; &lt;/a&gt;提供的信息之外， &lt;code&gt;BatchUpdateException&lt;/code&gt; 还提供了在批处理更新期间成功执行的所有命令（即，错误发生之前已执行的所有命令）的更新计数。更新计数数组中元素的顺序与命令添加到批处理中的顺序相对应。</target>
        </trans-unit>
        <trans-unit id="72d539ca6fdd4b7c88bd110f4dcd389de1ff790c" translate="yes" xml:space="preserve">
          <source>The subclass of &lt;a href=&quot;sqlexception&quot;&gt;&lt;code&gt;SQLException&lt;/code&gt;&lt;/a&gt; thrown when an instance where a retry of the same operation would fail unless the cause of the &lt;code&gt;SQLException&lt;/code&gt; is corrected.</source>
          <target state="translated">除非更正 &lt;code&gt;SQLException&lt;/code&gt; 的原因，否则在同一实例中重试同一操作将失败的实例时，将抛出&lt;a href=&quot;sqlexception&quot;&gt; &lt;code&gt;SQLException&lt;/code&gt; &lt;/a&gt;的子类。</target>
        </trans-unit>
        <trans-unit id="040505f7787304a32e3c75ae93a27084235243c1" translate="yes" xml:space="preserve">
          <source>The subclass of &lt;a href=&quot;sqlexception&quot;&gt;&lt;code&gt;SQLException&lt;/code&gt;&lt;/a&gt; thrown when the SQLState class value is '</source>
          <target state="translated">当SQLState类值为'时，&lt;a href=&quot;sqlexception&quot;&gt; &lt;code&gt;SQLException&lt;/code&gt; &lt;/a&gt;的子类。</target>
        </trans-unit>
        <trans-unit id="ccf2e655300c92dbbb85b4f642a0803f74b73233" translate="yes" xml:space="preserve">
          <source>The subclass of &lt;a href=&quot;sqlexception&quot;&gt;&lt;code&gt;SQLException&lt;/code&gt;&lt;/a&gt; thrown when the timeout specified by &lt;code&gt;Statement.setQueryTimeout&lt;/code&gt;, &lt;code&gt;DriverManager.setLoginTimeout&lt;/code&gt;, &lt;code&gt;DataSource.setLoginTimeout&lt;/code&gt;,&lt;code&gt;XADataSource.setLoginTimeout&lt;/code&gt; has expired.</source>
          <target state="translated">当 &lt;code&gt;Statement.setQueryTimeout&lt;/code&gt; ， &lt;code&gt;DriverManager.setLoginTimeout&lt;/code&gt; ， &lt;code&gt;DataSource.setLoginTimeout&lt;/code&gt; ， &lt;code&gt;XADataSource.setLoginTimeout&lt;/code&gt; 指定的超时到期时，&lt;a href=&quot;sqlexception&quot;&gt; &lt;code&gt;SQLException&lt;/code&gt; &lt;/a&gt;的子类。</target>
        </trans-unit>
        <trans-unit id="62072bc327b8cecfe4f10440c7fba64d72ceae2d" translate="yes" xml:space="preserve">
          <source>The subclass returned depends on the value of &lt;a href=&quot;#isParseBigDecimal()&quot;&gt;&lt;code&gt;isParseBigDecimal()&lt;/code&gt;&lt;/a&gt; as well as on the string being parsed.</source>
          <target state="translated">返回的子类取决于&lt;a href=&quot;#isParseBigDecimal()&quot;&gt; &lt;code&gt;isParseBigDecimal()&lt;/code&gt; &lt;/a&gt;的值以及要分析的字符串。</target>
        </trans-unit>
        <trans-unit id="bac1d40c541f2bc78282b5fcf04be8326df2e993" translate="yes" xml:space="preserve">
          <source>The subclass returned depends on the value of &lt;a href=&quot;decimalformat#isParseBigDecimal--&quot;&gt;&lt;code&gt;isParseBigDecimal()&lt;/code&gt;&lt;/a&gt; as well as on the string being parsed.</source>
          <target state="translated">返回的子类取决于&lt;a href=&quot;decimalformat#isParseBigDecimal--&quot;&gt; &lt;code&gt;isParseBigDecimal()&lt;/code&gt; &lt;/a&gt;的值以及要分析的字符串。</target>
        </trans-unit>
        <trans-unit id="b79749f58cf1bfcecb1d563bcce417c79a3f48ee" translate="yes" xml:space="preserve">
          <source>The subclass's &lt;code&gt;set(int, E)&lt;/code&gt;, &lt;code&gt;get(int)&lt;/code&gt;, &lt;code&gt;add(int, E)&lt;/code&gt;, &lt;code&gt;remove(int)&lt;/code&gt;, &lt;code&gt;addAll(int,
 Collection)&lt;/code&gt; and &lt;code&gt;removeRange(int, int)&lt;/code&gt; methods all delegate to the corresponding methods on the backing abstract list, after bounds-checking the index and adjusting for the offset. The &lt;code&gt;addAll(Collection c)&lt;/code&gt; method merely returns &lt;code&gt;addAll(size,
 c)&lt;/code&gt;.</source>
          <target state="translated">子类的 &lt;code&gt;set(int, E)&lt;/code&gt; ， &lt;code&gt;get(int)&lt;/code&gt; ， &lt;code&gt;add(int, E)&lt;/code&gt; ， &lt;code&gt;remove(int)&lt;/code&gt; ， &lt;code&gt;addAll(int, Collection)&lt;/code&gt; 和 &lt;code&gt;removeRange(int, int)&lt;/code&gt; 方法都委托给支持摘要上的相应方法边界检查索引并调整偏移量后列出。所述 &lt;code&gt;addAll(Collection c)&lt;/code&gt; 方法仅仅返回 &lt;code&gt;addAll(size, c)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="729c3d64219547cb810998bd0f169dacbb67b1a4" translate="yes" xml:space="preserve">
          <source>The subclasses of &lt;code&gt;LayerUI&lt;/code&gt; can either be stateless and shareable by multiple &lt;code&gt;JLayer&lt;/code&gt;s or not shareable.</source>
          <target state="translated">&lt;code&gt;LayerUI&lt;/code&gt; 的子类可以是无状态的，并且可以被多个 &lt;code&gt;JLayer&lt;/code&gt; 共享，也可以是不共享的。</target>
        </trans-unit>
        <trans-unit id="41754262853cd8dda8e7145fb4fe6436a4d4ac99" translate="yes" xml:space="preserve">
          <source>The subprocess is not killed when there are no more references to the &lt;code&gt;Process&lt;/code&gt; object, but rather the subprocess continues executing asynchronously.</source>
          <target state="translated">当不再有对 &lt;code&gt;Process&lt;/code&gt; 对象的引用时，子进程不会被杀死，而是子进程继续异步执行。</target>
        </trans-unit>
        <trans-unit id="7c7df4f8cdb60df8a1704c9b01b240279889a753" translate="yes" xml:space="preserve">
          <source>The subscriber returned by this handler is not flow controlled. Therefore, the supplied consumer must be able to process whatever amount of data is delivered in a timely fashion.</source>
          <target state="translated">该处理程序返回的订阅者不是流控制的。因此,提供的消费者必须能够及时处理任何数量的数据。</target>
        </trans-unit>
        <trans-unit id="24df0de55c6e5cbab8a446a4d7da62cab861430c" translate="yes" xml:space="preserve">
          <source>The subsequence of the argument &lt;code&gt;s&lt;/code&gt; specified by &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; are inserted, in order, into this sequence at the specified destination offset, moving up any characters originally above that position. The length of this sequence is increased by &lt;code&gt;end - start&lt;/code&gt;.</source>
          <target state="translated">将由 &lt;code&gt;start&lt;/code&gt; 和 &lt;code&gt;end&lt;/code&gt; 指定的参数 &lt;code&gt;s&lt;/code&gt; 的子序列按顺序插入到此序列中的指定目标偏移处，从而使该位置上方的所有原始字符向上移动。此序列的长度通过 &lt;code&gt;end - start&lt;/code&gt; 而增加。</target>
        </trans-unit>
        <trans-unit id="98347390f1f0edc351744b3bec1803d66b95c900" translate="yes" xml:space="preserve">
          <source>The subtract filter operation.</source>
          <target state="translated">减法过滤器的操作。</target>
        </trans-unit>
        <trans-unit id="fa32b35464f9186e85feb28d5c8d747a2ca57b4f" translate="yes" xml:space="preserve">
          <source>The subtypes of &lt;a href=&quot;constantdesc&quot;&gt;&lt;code&gt;ConstantDesc&lt;/code&gt;&lt;/a&gt; describe various kinds of constant values. For each type of loadable constant pool entry defined in JVMS 4.4, there is a corresponding subtype of &lt;a href=&quot;constantdesc&quot;&gt;&lt;code&gt;ConstantDesc&lt;/code&gt;&lt;/a&gt;: &lt;a href=&quot;classdesc&quot;&gt;&lt;code&gt;ClassDesc&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;methodtypedesc&quot;&gt;&lt;code&gt;MethodTypeDesc&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;directmethodhandledesc&quot;&gt;&lt;code&gt;DirectMethodHandleDesc&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../integer&quot;&gt;&lt;code&gt;Integer&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../long&quot;&gt;&lt;code&gt;Long&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../float&quot;&gt;&lt;code&gt;Float&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../double&quot;&gt;&lt;code&gt;Double&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;dynamicconstantdesc&quot;&gt;&lt;code&gt;DynamicConstantDesc&lt;/code&gt;&lt;/a&gt;. These classes provide type-specific accessor methods to extract the nominal information for that kind of constant. When a bytecode-writing API encounters a &lt;a href=&quot;constantdesc&quot;&gt;&lt;code&gt;ConstantDesc&lt;/code&gt;&lt;/a&gt;, it should examine it to see which of these types it is, cast it, extract its nominal information, and generate the corresponding entry to the constant pool. When a bytecode-reading API encounters a constant pool entry, it can convert it to the appropriate type of nominal descriptor. For dynamic constants, bytecode-reading APIs may wish to use the factory &lt;a href=&quot;dynamicconstantdesc#ofCanonical(java.lang.constant.DirectMethodHandleDesc,java.lang.String,java.lang.constant.ClassDesc,java.lang.constant.ConstantDesc%5B%5D)&quot;&gt;&lt;code&gt;DynamicConstantDesc.ofCanonical&lt;/code&gt;&lt;/a&gt;, which will inspect the bootstrap and, for well-known bootstraps, return a more specific subtype of &lt;a href=&quot;dynamicconstantdesc&quot;&gt;&lt;code&gt;DynamicConstantDesc&lt;/code&gt;&lt;/a&gt;, such as &lt;a href=&quot;../enum.enumdesc&quot;&gt;&lt;code&gt;Enum.EnumDesc&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;constantdesc&quot;&gt; &lt;code&gt;ConstantDesc&lt;/code&gt; &lt;/a&gt;的子类型描述了各种常数值。对于JVMS 4.4中定义的每种类型的可加载常量池条目，都有相应的&lt;a href=&quot;constantdesc&quot;&gt; &lt;code&gt;ConstantDesc&lt;/code&gt; &lt;/a&gt;子类型：&lt;a href=&quot;classdesc&quot;&gt; &lt;code&gt;ClassDesc&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;methodtypedesc&quot;&gt; &lt;code&gt;MethodTypeDesc&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;directmethodhandledesc&quot;&gt; &lt;code&gt;DirectMethodHandleDesc&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../integer&quot;&gt; &lt;code&gt;Integer&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../long&quot;&gt; &lt;code&gt;Long&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../float&quot;&gt; &lt;code&gt;Float&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../double&quot;&gt; &lt;code&gt;Double&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;dynamicconstantdesc&quot;&gt; &lt;code&gt;DynamicConstantDesc&lt;/code&gt; &lt;/a&gt;。这些类提供了特定于类型的访问器方法，以提取此类常量的名义信息。当字节码编写API遇到&lt;a href=&quot;constantdesc&quot;&gt; &lt;code&gt;ConstantDesc&lt;/code&gt; 时&lt;/a&gt;，它应该检查它是哪种类型，将其强制转换，提取其名义信息，并生成相应的常量池条目。当读取字节码的API遇到常量池条目时，它可以将其转换为适当类型的名义描述符。对于动态常量，读取字节码的API可能希望使用工厂&lt;a href=&quot;dynamicconstantdesc#ofCanonical(java.lang.constant.DirectMethodHandleDesc,java.lang.String,java.lang.constant.ClassDesc,java.lang.constant.ConstantDesc%5B%5D)&quot;&gt; &lt;code&gt;DynamicConstantDesc.ofCanonical&lt;/code&gt; &lt;/a&gt;，它将检查引导程序，对于众所周知的引导程序，返回更具体的&lt;a href=&quot;dynamicconstantdesc&quot;&gt; &lt;code&gt;DynamicConstantDesc&lt;/code&gt; &lt;/a&gt;子类型，例如&lt;a href=&quot;../enum.enumdesc&quot;&gt; &lt;code&gt;Enum.EnumDesc&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9bb649597713d07a6a3f68ef4b622114bd9bb42f" translate="yes" xml:space="preserve">
          <source>The sum returned can vary depending upon the order in which values are recorded, due to accumulated rounding error in addition of values of differing magnitudes. Values sorted by increasing absolute magnitude tend to yield more accurate results. If any recorded value is a &lt;code&gt;NaN&lt;/code&gt; or the sum is at any point a &lt;code&gt;NaN&lt;/code&gt; then the sum will be &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">由于累积的舍入误差以及大小不同的值，返回的总和可能会根据记录值的顺序而有所不同。通过增加绝对值排序的值往往会产生更准确的结果。如果任何记录的值是 &lt;code&gt;NaN&lt;/code&gt; 或总和在任何时候都是 &lt;code&gt;NaN&lt;/code&gt; ,则总和将是 &lt;code&gt;NaN&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b5b109e54c81cacf004fb931535e7f7c5e9a6ad4" translate="yes" xml:space="preserve">
          <source>The super class of all menu related containers.</source>
          <target state="translated">所有菜单相关容器的超级类。</target>
        </trans-unit>
        <trans-unit id="2edd5140cff4220974aa4530adeee309c448831e" translate="yes" xml:space="preserve">
          <source>The superclass behavior will try to update the child views which is not desired in this case, since the children are zones and not directly effected by the changes to the associated element.</source>
          <target state="translated">超类行为将尝试更新子视图,这在这种情况下是不可取的,因为子视图是区域,并不直接受到相关元素变化的影响。</target>
        </trans-unit>
        <trans-unit id="223c3b7c239c5d80bf9c6472a205737e2c00d21b" translate="yes" xml:space="preserve">
          <source>The superclass behavior will try to update the child views which is not desired in this case, since the children are zones and not directly effected by the changes to the associated element. This is reimplemented to do nothing and return false.</source>
          <target state="translated">超级类的行为将尝试更新子视图,这在本例中是不可取的,因为子视图是区域,并不直接受到关联元素变化的影响。这被重新实现为什么都不做并返回false。</target>
        </trans-unit>
        <trans-unit id="21955f67e39653298d554b40ee6256104e191d63" translate="yes" xml:space="preserve">
          <source>The superclass of JShell generated exceptions</source>
          <target state="translated">JShell生成异常的超类</target>
        </trans-unit>
        <trans-unit id="602000e37c0a2e549407c0c276a26b61377db86f" translate="yes" xml:space="preserve">
          <source>The supertypes (both class and interface types) of a declared type may be found using the &lt;a href=&quot;../util/types#directSupertypes(javax.lang.model.type.TypeMirror)&quot;&gt;&lt;code&gt;Types.directSupertypes(TypeMirror)&lt;/code&gt;&lt;/a&gt; method. This returns the supertypes with any type arguments substituted in.</source>
          <target state="translated">可以使用&lt;a href=&quot;../util/types#directSupertypes(javax.lang.model.type.TypeMirror)&quot;&gt; &lt;code&gt;Types.directSupertypes(TypeMirror)&lt;/code&gt; &lt;/a&gt;方法找到已声明类型的超类型（类和接口类型）。这将返回替换了任何类型参数的超类型。</target>
        </trans-unit>
        <trans-unit id="8b4fd272478c2bf5755a6c3fbfac56931cb9665d" translate="yes" xml:space="preserve">
          <source>The supertypes (both class and interface types) of a declared type may be found using the &lt;a href=&quot;../util/types#directSupertypes-javax.lang.model.type.TypeMirror-&quot;&gt;&lt;code&gt;Types.directSupertypes(TypeMirror)&lt;/code&gt;&lt;/a&gt; method. This returns the supertypes with any type arguments substituted in.</source>
          <target state="translated">可以使用&lt;a href=&quot;../util/types#directSupertypes-javax.lang.model.type.TypeMirror-&quot;&gt; &lt;code&gt;Types.directSupertypes(TypeMirror)&lt;/code&gt; &lt;/a&gt;方法找到已声明类型的超类型（类和接口类型）。这将返回替换了任何类型参数的超类型。</target>
        </trans-unit>
        <trans-unit id="dc5747fa903eaf6ac98267f42bc62b68fd35ff94" translate="yes" xml:space="preserve">
          <source>The supplied &lt;code&gt;CompositeData&lt;/code&gt; must have the following item names and item types to be valid.</source>
          <target state="translated">提供的 &lt;code&gt;CompositeData&lt;/code&gt; 必须具有以下项目名称和项目类型才有效。</target>
        </trans-unit>
        <trans-unit id="5ca7e4f038d5dc8de6f6523df8470fdb5a3affbb" translate="yes" xml:space="preserve">
          <source>The supplied &lt;code&gt;index&lt;/code&gt; corresponds to the index of the &lt;a href=&quot;valuedescriptor&quot;&gt;&lt;code&gt;ValueDescriptor&lt;/code&gt;&lt;/a&gt; object passed to the factory method of the &lt;code&gt;EventFactory&lt;/code&gt; class.</source>
          <target state="translated">提供的 &lt;code&gt;index&lt;/code&gt; 对应于传递给 &lt;code&gt;EventFactory&lt;/code&gt; 类的factory方法的&lt;a href=&quot;valuedescriptor&quot;&gt; &lt;code&gt;ValueDescriptor&lt;/code&gt; &lt;/a&gt;对象的索引。</target>
        </trans-unit>
        <trans-unit id="14dfb8fa2619f0e88128d788e30861e3728092dc" translate="yes" xml:space="preserve">
          <source>The supplied accumulator function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads. For predictable results, the accumulator function should be commutative and associative within the floating point tolerance required in usage contexts. The function is applied with an existing value (or identity) as one argument, and a given update as the other argument. For example, to maintain a running maximum value, you could supply &lt;code&gt;Double::max&lt;/code&gt; along with &lt;code&gt;Double.NEGATIVE_INFINITY&lt;/code&gt; as the identity. The order of accumulation within or across threads is not guaranteed. Thus, this class may not be applicable if numerical stability is required, especially when combining values of substantially different orders of magnitude.</source>
          <target state="translated">所提供的累加器功能应无副作用，因为当尝试更新由于线程间争用而失败时，可以重新应用该累加器功能。为了获得可预测的结果，累加器功能应在使用上下文所需的浮点公差范围内进行交换和关联。该函数以现有值（或标识）作为一个参数，并以给定的更新作为另一个参数来应用。例如，要保持运行的最大值，可以提供 &lt;code&gt;Double::max&lt;/code&gt; 以及 &lt;code&gt;Double.NEGATIVE_INFINITY&lt;/code&gt; 作为标识。不能保证线程内或线程间的累积顺序。因此，如果需要数值稳定性，尤其是在组合数量级基本不同的数值时，此类可能不适用。</target>
        </trans-unit>
        <trans-unit id="6acd237472bddb6f88b28a9f2fd993ab87094ddb" translate="yes" xml:space="preserve">
          <source>The supplied accumulator function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads. The function is applied with the current value as its first argument, and the given update as the second argument. For example, to maintain a running maximum value, you could supply &lt;code&gt;Double::max&lt;/code&gt; along with &lt;code&gt;Double.NEGATIVE_INFINITY&lt;/code&gt; as the identity. The order of accumulation within or across threads is not guaranteed. Thus, this class may not be applicable if numerical stability is required, especially when combining values of substantially different orders of magnitude.</source>
          <target state="translated">所提供的累加器功能应无副作用，因为当尝试更新由于线程间争用而失败时，可以重新应用该累加器功能。应用该函数时，将当前值作为其第一个参数，并将给定的update作为第二个参数。例如，要保持运行的最大值，可以提供 &lt;code&gt;Double::max&lt;/code&gt; 以及 &lt;code&gt;Double.NEGATIVE_INFINITY&lt;/code&gt; 作为标识。不保证线程内或线程间的累积顺序。因此，如果需要数值稳定性，尤其是在组合数量级基本不同的数值时，此类可能不适用。</target>
        </trans-unit>
        <trans-unit id="6025b666165a1f5fda89da5a8e8ee1de31444459" translate="yes" xml:space="preserve">
          <source>The supplied array holding three internalized strings representing the Namespace URI (or empty string), the local name, and the XML qualified name; or null if there is an undeclared prefix.</source>
          <target state="translated">提供的数组,包含三个内化的字符串,分别代表命名空间URI(或空字符串)、本地名称和XML限定名称;如果有未声明的前缀,则为空。</target>
        </trans-unit>
        <trans-unit id="7ad24e24ba3ab22cd4ef21994274386c9cd69325" translate="yes" xml:space="preserve">
          <source>The supplied object parameter acts as an optional configuration argument. For example, it could be of type &lt;code&gt;Component&lt;/code&gt;. A &lt;code&gt;Painter&lt;/code&gt; that expected it could then read state from that &lt;code&gt;Component&lt;/code&gt; and use the state for painting. For example, an implementation may read the backgroundColor and use that.</source>
          <target state="translated">提供的对象参数充当可选的配置参数。例如，它可以是 &lt;code&gt;Component&lt;/code&gt; 类型。期望它可以从该 &lt;code&gt;Component&lt;/code&gt; 读取状态并使用该状态进行绘制的 &lt;code&gt;Painter&lt;/code&gt; 。例如，一个实现可以读取backgroundColor并使用它。</target>
        </trans-unit>
        <trans-unit id="b84e7dcea201cffacdcbf9be7a2353ff95d845a5" translate="yes" xml:space="preserve">
          <source>The supplied thumbnails will be resized if needed, and any thumbnails in excess of the supported number will be ignored. If the format requires additional thumbnails that are not provided, the writer should generate them internally.</source>
          <target state="translated">如果需要的话,提供的缩略图将被调整大小,任何超过支持数量的缩略图将被忽略。如果格式要求额外的缩略图,而这些缩略图又没有提供,那么编写者应该在内部生成这些缩略图。</target>
        </trans-unit>
        <trans-unit id="753904bcbd3964af858d18cda3d913205d84b5e6" translate="yes" xml:space="preserve">
          <source>The supplied thumbnails will be resized if needed, and any thumbnails in excess of the supported number will be ignored. If the format requires additional thumbnails that are not provided, the writer will generate them internally.</source>
          <target state="translated">如果需要,将调整所提供的缩略图的大小,任何超过支持数量的缩略图将被忽略。如果格式要求额外的缩略图,而这些缩略图又没有提供,那么编写者将在内部生成这些缩略图。</target>
        </trans-unit>
        <trans-unit id="bce2b22d14479cd69e56124d69d47db8b57076ba" translate="yes" xml:space="preserve">
          <source>The support for this is provided by the &lt;code&gt;StyleSheet&lt;/code&gt; class. The presentation of the HTML can be heavily influenced by the setting of the StyleSheet property on the EditorKit.</source>
          <target state="translated">&lt;code&gt;StyleSheet&lt;/code&gt; 类提供对此的支持。HTML的显示方式在很大程度上受EditorKit上StyleSheet属性的设置的影响。</target>
        </trans-unit>
        <trans-unit id="cc15d8eee723cd7e4ccfbd5a0f0bd59ce88d1002" translate="yes" xml:space="preserve">
          <source>The supported &lt;code&gt;ChronoField&lt;/code&gt; instances are:</source>
          <target state="translated">支持的 &lt;code&gt;ChronoField&lt;/code&gt; 实例是：</target>
        </trans-unit>
        <trans-unit id="8b2cd39555d2c728a665b32d4100c19f45b92402" translate="yes" xml:space="preserve">
          <source>The supported calendar systems includes:</source>
          <target state="translated">支持的日历系统包括:</target>
        </trans-unit>
        <trans-unit id="83bd48a0eac4e9b358a53d73d8f0c393f28dcfbc" translate="yes" xml:space="preserve">
          <source>The supported categories are those of &lt;a href=&quot;http://www.unicode.org/unicode/standard/standard.html&quot;&gt; &lt;i&gt;The Unicode Standard&lt;/i&gt;&lt;/a&gt; in the version specified by the &lt;a href=&quot;../../lang/character&quot;&gt;&lt;code&gt;Character&lt;/code&gt;&lt;/a&gt; class. The category names are those defined in the Standard, both normative and informative.</source>
          <target state="translated">支持的类别是&lt;a href=&quot;../../lang/character&quot;&gt; &lt;code&gt;Character&lt;/code&gt; &lt;/a&gt;类指定的版本中&lt;a href=&quot;http://www.unicode.org/unicode/standard/standard.html&quot;&gt;&lt;i&gt;的Unicode标准&lt;/i&gt;&lt;/a&gt;类别。类别名称是标准中定义的名称，包括规范性的和信息性的。 &lt;i&gt;&lt;/i&gt;</target>
        </trans-unit>
        <trans-unit id="1b938fa603bd5aaba697922eb2fb711a539cf4d0" translate="yes" xml:space="preserve">
          <source>The supported categories are those of &lt;a href=&quot;https://www.unicode.org/unicode/standard/standard.html&quot;&gt; &lt;i&gt;The Unicode Standard&lt;/i&gt;&lt;/a&gt; in the version specified by the &lt;a href=&quot;../../lang/character&quot;&gt;&lt;code&gt;Character&lt;/code&gt;&lt;/a&gt; class. The category names are those defined in the Standard, both normative and informative.</source>
          <target state="translated">支持的类别是&lt;a href=&quot;../../lang/character&quot;&gt; &lt;code&gt;Character&lt;/code&gt; &lt;/a&gt;类指定的版本中&lt;a href=&quot;https://www.unicode.org/unicode/standard/standard.html&quot;&gt;&lt;i&gt;的Unicode标准&lt;/i&gt;&lt;/a&gt;类别。类别名称是标准中定义的名称，包括规范性的和信息性的。 &lt;i&gt;&lt;/i&gt;</target>
        </trans-unit>
        <trans-unit id="b4eb01860151689f1f6379a2545112126849a160" translate="yes" xml:space="preserve">
          <source>The supported class file changes are described in &lt;a href=&quot;https://docs.oracle.com/en/java/javase/15/docs/specs/jvmti.html#RedefineClasses&quot;&gt;JVM TI RedefineClasses&lt;/a&gt;. The class file bytes are not checked, verified and installed until after the transformations have been applied, if the resultant bytes are in error this method will throw an exception.</source>
          <target state="translated">&lt;a href=&quot;https://docs.oracle.com/en/java/javase/15/docs/specs/jvmti.html#RedefineClasses&quot;&gt;JVM TI RedefineClasses&lt;/a&gt;中描述了支持的类文件更改。在应用转换之后，才检查，验证和安装类文件字节，如果结果字节错误，则此方法将引发异常。</target>
        </trans-unit>
        <trans-unit id="e05137876edd3b6b6a29d96ad5b9b3edf239fae6" translate="yes" xml:space="preserve">
          <source>The supported class file changes are described in &lt;a href=&quot;https://docs.oracle.com/en/java/javase/15/docs/specs/jvmti.html#RetransformClasses&quot;&gt;JVM TI RetransformClasses&lt;/a&gt;. The class file bytes are not checked, verified and installed until after the transformations have been applied, if the resultant bytes are in error this method will throw an exception.</source>
          <target state="translated">&lt;a href=&quot;https://docs.oracle.com/en/java/javase/15/docs/specs/jvmti.html#RetransformClasses&quot;&gt;JVM TI RetransformClasses&lt;/a&gt;中描述了支持的类文件更改。在应用转换之后，才检查，验证和安装类文件字节，如果结果字节错误，则此方法将引发异常。</target>
        </trans-unit>
        <trans-unit id="27c2737ecb716851489499e7d8287bbcd13402f5" translate="yes" xml:space="preserve">
          <source>The supported component types (variables types) are &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt; and &lt;code&gt;double&lt;/code&gt;.</source>
          <target state="translated">支持的组件类型（变量类型）为 &lt;code&gt;short&lt;/code&gt; ， &lt;code&gt;char&lt;/code&gt; ， &lt;code&gt;int&lt;/code&gt; ， &lt;code&gt;long&lt;/code&gt; ， &lt;code&gt;float&lt;/code&gt; 和 &lt;code&gt;double&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1f2e9acf0920ea9550ff69da281e2ea26f2481f3" translate="yes" xml:space="preserve">
          <source>The supported syntax is:</source>
          <target state="translated">支持的语法是:</target>
        </trans-unit>
        <trans-unit id="8d6a5bc82895e1be1c598d816a928419e077fb62" translate="yes" xml:space="preserve">
          <source>The supported units are &lt;a href=&quot;temporal/chronounit#SECONDS&quot;&gt;&lt;code&gt;SECONDS&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;temporal/chronounit#NANOS&quot;&gt;&lt;code&gt;NANOS&lt;/code&gt;&lt;/a&gt;. They are returned in the order seconds, nanos.</source>
          <target state="translated">支持的单位是&lt;a href=&quot;temporal/chronounit#SECONDS&quot;&gt; &lt;code&gt;SECONDS&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;temporal/chronounit#NANOS&quot;&gt; &lt;code&gt;NANOS&lt;/code&gt; &lt;/a&gt;。它们以秒（nanos）的顺序返回。</target>
        </trans-unit>
        <trans-unit id="50995038a878ce286701de766382bef69778b604" translate="yes" xml:space="preserve">
          <source>The supported units are &lt;a href=&quot;temporal/chronounit#YEARS&quot;&gt;&lt;code&gt;YEARS&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;temporal/chronounit#MONTHS&quot;&gt;&lt;code&gt;MONTHS&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;temporal/chronounit#DAYS&quot;&gt;&lt;code&gt;DAYS&lt;/code&gt;&lt;/a&gt;. They are returned in the order years, months, days.</source>
          <target state="translated">支持的单位是&lt;a href=&quot;temporal/chronounit#YEARS&quot;&gt; &lt;code&gt;YEARS&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;temporal/chronounit#MONTHS&quot;&gt; &lt;code&gt;MONTHS&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;temporal/chronounit#DAYS&quot;&gt; &lt;code&gt;DAYS&lt;/code&gt; &lt;/a&gt;。它们按年，月，日的顺序返回。</target>
        </trans-unit>
        <trans-unit id="7618ee46d4016ebcae2e5cbf1a065473c760968b" translate="yes" xml:space="preserve">
          <source>The supported units are chronology specific. They will typically be &lt;a href=&quot;../temporal/chronounit#YEARS&quot;&gt;&lt;code&gt;YEARS&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../temporal/chronounit#MONTHS&quot;&gt;&lt;code&gt;MONTHS&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../temporal/chronounit#DAYS&quot;&gt;&lt;code&gt;DAYS&lt;/code&gt;&lt;/a&gt;. Requesting an unsupported unit will throw an exception.</source>
          <target state="translated">支持的单位是按时间顺序的。通常为&lt;a href=&quot;../temporal/chronounit#YEARS&quot;&gt; &lt;code&gt;YEARS&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../temporal/chronounit#MONTHS&quot;&gt; &lt;code&gt;MONTHS&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../temporal/chronounit#DAYS&quot;&gt; &lt;code&gt;DAYS&lt;/code&gt; &lt;/a&gt;。请求不受支持的单位将引发异常。</target>
        </trans-unit>
        <trans-unit id="b30d06d3ef729bd157ab81214e7e89bcf4f23fd7" translate="yes" xml:space="preserve">
          <source>The supported units are chronology specific. They will typically be &lt;a href=&quot;../temporal/chronounit#YEARS&quot;&gt;&lt;code&gt;YEARS&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../temporal/chronounit#MONTHS&quot;&gt;&lt;code&gt;MONTHS&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../temporal/chronounit#DAYS&quot;&gt;&lt;code&gt;DAYS&lt;/code&gt;&lt;/a&gt;. They are returned in order from largest to smallest.</source>
          <target state="translated">支持的单位是按时间顺序的。通常为&lt;a href=&quot;../temporal/chronounit#YEARS&quot;&gt; &lt;code&gt;YEARS&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../temporal/chronounit#MONTHS&quot;&gt; &lt;code&gt;MONTHS&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../temporal/chronounit#DAYS&quot;&gt; &lt;code&gt;DAYS&lt;/code&gt; &lt;/a&gt;。它们按从大到小的顺序返回。</target>
        </trans-unit>
        <trans-unit id="612ea5ebf89d96a0eba935a9ea4b0154afc481ad" translate="yes" xml:space="preserve">
          <source>The supported units of a period are &lt;a href=&quot;temporal/chronounit#YEARS&quot;&gt;&lt;code&gt;YEARS&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;temporal/chronounit#MONTHS&quot;&gt;&lt;code&gt;MONTHS&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;temporal/chronounit#DAYS&quot;&gt;&lt;code&gt;DAYS&lt;/code&gt;&lt;/a&gt;. All three fields are always present, but may be set to zero.</source>
          <target state="translated">一个期间支持的单位是&lt;a href=&quot;temporal/chronounit#YEARS&quot;&gt; &lt;code&gt;YEARS&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;temporal/chronounit#MONTHS&quot;&gt; &lt;code&gt;MONTHS&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;temporal/chronounit#DAYS&quot;&gt; &lt;code&gt;DAYS&lt;/code&gt; &lt;/a&gt;。所有三个字段始终存在，但可以设置为零。</target>
        </trans-unit>
        <trans-unit id="ba6f6bccc56ef3d310dd0f60418a50729535d8d9" translate="yes" xml:space="preserve">
          <source>The suppression behavior is enabled &lt;em&gt;unless&lt;/em&gt; disabled &lt;a href=&quot;#%3Cinit%3E(java.lang.String,java.lang.Throwable,boolean,boolean)&quot;&gt;via a constructor&lt;/a&gt;. When suppression is disabled, this method does nothing other than to validate its argument.</source>
          <target state="translated">&lt;em&gt;除非&lt;/em&gt;&lt;a href=&quot;#%3Cinit%3E(java.lang.String,java.lang.Throwable,boolean,boolean)&quot;&gt;通过构造函数&lt;/a&gt;禁用抑制行为，&lt;em&gt;否则&lt;/em&gt;将启用抑制行为。禁用抑制后，此方法除了验证其参数外不执行其他操作。</target>
        </trans-unit>
        <trans-unit id="f5be801d8d7c141429eb2a06d10b0aef903302c4" translate="yes" xml:space="preserve">
          <source>The suppression behavior is enabled &lt;em&gt;unless&lt;/em&gt; disabled &lt;a href=&quot;throwable#Throwable-java.lang.String-java.lang.Throwable-boolean-boolean-&quot;&gt;via a constructor&lt;/a&gt;. When suppression is disabled, this method does nothing other than to validate its argument.</source>
          <target state="translated">&lt;em&gt;除非&lt;/em&gt;&lt;a href=&quot;throwable#Throwable-java.lang.String-java.lang.Throwable-boolean-boolean-&quot;&gt;通过构造函数&lt;/a&gt;禁用抑制行为，&lt;em&gt;否则&lt;/em&gt;将启用抑制行为。禁用抑制后，此方法除了验证其参数外不执行其他操作。</target>
        </trans-unit>
        <trans-unit id="82ebf4133d954ce86d747b54dfa4cfd4018049ca" translate="yes" xml:space="preserve">
          <source>The suspended thread is guaranteed to remain suspended until resumed through one of the JDI resume methods mentioned above; the application in the target VM cannot resume the suspended thread through &lt;a href=&quot;../../../../java.base/java/lang/thread#resume()&quot;&gt;&lt;code&gt;Thread.resume()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通过上述一种JDI恢复方法，可以确保已暂停的线程保持暂停状态，直到恢复为止。目标VM中的应用程序无法通过&lt;a href=&quot;../../../../java.base/java/lang/thread#resume()&quot;&gt; &lt;code&gt;Thread.resume()&lt;/code&gt; &lt;/a&gt;恢复挂起的线程。</target>
        </trans-unit>
        <trans-unit id="2d792cc659c3710e68412ad26001e0365e4fe31b" translate="yes" xml:space="preserve">
          <source>The swing text components provide some support of thread safe operations. Because of the high level of configurability of the text components, it is possible to circumvent the protection provided. The protection primarily comes from the model, so the documentation of &lt;code&gt;AbstractDocument&lt;/code&gt; describes the assumptions of the protection provided. The methods that are safe to call asynchronously are marked with comments.</source>
          <target state="translated">Swing文本组件为线程安全操作提供了一些支持。由于文本组件的高度可配置性，有可能避开所提供的保护。保护主要来自模型，因此 &lt;code&gt;AbstractDocument&lt;/code&gt; 的文档描述了所提供保护的假设。可以安全地异步调用的方法带有注释。</target>
        </trans-unit>
        <trans-unit id="841ed2261b840ee034e2fc667a839f1eea97e56b" translate="yes" xml:space="preserve">
          <source>The symbolic type descriptor at the call site of &lt;code&gt;
 compareAndExchange&lt;/code&gt; must match the access mode type that is the result of calling &lt;code&gt;accessModeType(VarHandle.AccessMode.COMPARE_AND_EXCHANGE)&lt;/code&gt; on this VarHandle.</source>
          <target state="translated">&lt;code&gt; compareAndExchange&lt;/code&gt; 的调用站点上的符号类型描述符必须与访问模式类型匹配，该访问模式类型是在此VarHandle上调用 &lt;code&gt;accessModeType(VarHandle.AccessMode.COMPARE_AND_EXCHANGE)&lt;/code&gt; 的结果。</target>
        </trans-unit>
        <trans-unit id="80c4a3b73d48513a6615b83f39f27edf617e75d0" translate="yes" xml:space="preserve">
          <source>The symbolic type descriptor at the call site of &lt;code&gt;
 compareAndExchangeAcquire&lt;/code&gt; must match the access mode type that is the result of calling &lt;code&gt;accessModeType(VarHandle.AccessMode.COMPARE_AND_EXCHANGE_ACQUIRE)&lt;/code&gt; on this VarHandle.</source>
          <target state="translated">&lt;code&gt; compareAndExchangeAcquire&lt;/code&gt; 的调用站点上的符号类型描述符必须与访问模式类型匹配，该访问模式类型是在此VarHandle上调用 &lt;code&gt;accessModeType(VarHandle.AccessMode.COMPARE_AND_EXCHANGE_ACQUIRE)&lt;/code&gt; 的结果。</target>
        </trans-unit>
        <trans-unit id="6fd514eb09ba3f8f2597220841a1a986e13cd4bc" translate="yes" xml:space="preserve">
          <source>The symbolic type descriptor at the call site of &lt;code&gt;
 compareAndExchangeRelease&lt;/code&gt; must match the access mode type that is the result of calling &lt;code&gt;accessModeType(VarHandle.AccessMode.COMPARE_AND_EXCHANGE_RELEASE)&lt;/code&gt; on this VarHandle.</source>
          <target state="translated">&lt;code&gt; compareAndExchangeRelease&lt;/code&gt; 的调用站点上的符号类型描述符必须与访问模式类型匹配，该访问模式类型是在此VarHandle上调用 &lt;code&gt;accessModeType(VarHandle.AccessMode.COMPARE_AND_EXCHANGE_RELEASE)&lt;/code&gt; 的结果。</target>
        </trans-unit>
        <trans-unit id="d8383b8927a886acbd2d87b4f789aa3cd1800f65" translate="yes" xml:space="preserve">
          <source>The symbolic type descriptor at the call site of &lt;code&gt;
 compareAndSet&lt;/code&gt; must match the access mode type that is the result of calling &lt;code&gt;accessModeType(VarHandle.AccessMode.COMPARE_AND_SET)&lt;/code&gt; on this VarHandle.</source>
          <target state="translated">&lt;code&gt; compareAndSet&lt;/code&gt; 的调用站点上的符号类型描述符必须与访问模式类型匹配，该访问模式类型是在此VarHandle上调用 &lt;code&gt;accessModeType(VarHandle.AccessMode.COMPARE_AND_SET)&lt;/code&gt; 的结果。</target>
        </trans-unit>
        <trans-unit id="0fc1fe303a671f659dfcb75ed69ad915a0b9cf34" translate="yes" xml:space="preserve">
          <source>The symbolic type descriptor at the call site of &lt;code&gt;
 weakCompareAndSet&lt;/code&gt; must match the access mode type that is the result of calling &lt;code&gt;accessModeType(VarHandle.AccessMode.WEAK_COMPARE_AND_SET)&lt;/code&gt; on this VarHandle.</source>
          <target state="translated">&lt;code&gt; weakCompareAndSet&lt;/code&gt; 的调用站点上的符号类型描述符必须与访问模式类型匹配，该访问模式类型是在此VarHandle上调用 &lt;code&gt;accessModeType(VarHandle.AccessMode.WEAK_COMPARE_AND_SET)&lt;/code&gt; 的结果。</target>
        </trans-unit>
        <trans-unit id="a2d6fc33cce92819cac6f3c0aae23a1e0f658baf" translate="yes" xml:space="preserve">
          <source>The symbolic type descriptor at the call site of &lt;code&gt;
 weakCompareAndSetAcquire&lt;/code&gt; must match the access mode type that is the result of calling &lt;code&gt;accessModeType(VarHandle.AccessMode.WEAK_COMPARE_AND_SET_ACQUIRE)&lt;/code&gt; on this VarHandle.</source>
          <target state="translated">&lt;code&gt; weakCompareAndSetAcquire&lt;/code&gt; 调用站点上的符号类型描述符必须与访问模式类型匹配，该访问模式类型是在此VarHandle上调用 &lt;code&gt;accessModeType(VarHandle.AccessMode.WEAK_COMPARE_AND_SET_ACQUIRE)&lt;/code&gt; 的结果。</target>
        </trans-unit>
        <trans-unit id="c238fc4ba306a85bf1a7b6a1059990d27fd23416" translate="yes" xml:space="preserve">
          <source>The symbolic type descriptor at the call site of &lt;code&gt;
 weakCompareAndSetPlain&lt;/code&gt; must match the access mode type that is the result of calling &lt;code&gt;accessModeType(VarHandle.AccessMode.WEAK_COMPARE_AND_SET_PLAIN)&lt;/code&gt; on this VarHandle.</source>
          <target state="translated">&lt;code&gt; weakCompareAndSetPlain&lt;/code&gt; 的调用站点上的符号类型描述符必须与访问模式类型匹配，该访问模式类型是在此VarHandle上调用 &lt;code&gt;accessModeType(VarHandle.AccessMode.WEAK_COMPARE_AND_SET_PLAIN)&lt;/code&gt; 的结果。</target>
        </trans-unit>
        <trans-unit id="3caa02cdc85af699be3da720087d3b254a1e0d14" translate="yes" xml:space="preserve">
          <source>The symbolic type descriptor at the call site of &lt;code&gt;
 weakCompareAndSetRelease&lt;/code&gt; must match the access mode type that is the result of calling &lt;code&gt;accessModeType(VarHandle.AccessMode.WEAK_COMPARE_AND_SET_RELEASE)&lt;/code&gt; on this VarHandle.</source>
          <target state="translated">&lt;code&gt; weakCompareAndSetRelease&lt;/code&gt; 的调用站点上的符号类型描述符必须与访问模式类型匹配，该访问模式类型是在此VarHandle上调用 &lt;code&gt;accessModeType(VarHandle.AccessMode.WEAK_COMPARE_AND_SET_RELEASE)&lt;/code&gt; 的结果。</target>
        </trans-unit>
        <trans-unit id="d92d0c26fd0ceacd6a22912f8e08a2af1144ac03" translate="yes" xml:space="preserve">
          <source>The symbolic type descriptor at the call site of &lt;code&gt;get&lt;/code&gt; must match the access mode type that is the result of calling &lt;code&gt;accessModeType(VarHandle.AccessMode.GET)&lt;/code&gt; on this VarHandle.</source>
          <target state="translated">&lt;code&gt;get&lt;/code&gt; 的调用站点上的符号类型描述符必须与访问模式类型匹配，该访问模式类型是在此VarHandle上调用 &lt;code&gt;accessModeType(VarHandle.AccessMode.GET)&lt;/code&gt; 的结果。</target>
        </trans-unit>
        <trans-unit id="785e11e22d0e4f59f3c358dd707d0c8bb9c45c5d" translate="yes" xml:space="preserve">
          <source>The symbolic type descriptor at the call site of &lt;code&gt;getAcquire&lt;/code&gt; must match the access mode type that is the result of calling &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_ACQUIRE)&lt;/code&gt; on this VarHandle.</source>
          <target state="translated">&lt;code&gt;getAcquire&lt;/code&gt; 调用站点上的符号类型描述符必须与访问模式类型匹配，该访问模式类型是在此VarHandle上调用 &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_ACQUIRE)&lt;/code&gt; 的结果。</target>
        </trans-unit>
        <trans-unit id="3909d7fd71a3ce0d45b42b91b83a4cb3a38cc4c7" translate="yes" xml:space="preserve">
          <source>The symbolic type descriptor at the call site of &lt;code&gt;getAndAdd&lt;/code&gt; must match the access mode type that is the result of calling &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_AND_ADD)&lt;/code&gt; on this VarHandle.</source>
          <target state="translated">&lt;code&gt;getAndAdd&lt;/code&gt; 的调用站点上的符号类型描述符必须与访问模式类型匹配，该访问模式类型是在此VarHandle上调用 &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_AND_ADD)&lt;/code&gt; 的结果。</target>
        </trans-unit>
        <trans-unit id="b8c1e07e45f3df0e3f4c7960f4689cc7ff853fb5" translate="yes" xml:space="preserve">
          <source>The symbolic type descriptor at the call site of &lt;code&gt;getAndAddAcquire&lt;/code&gt; must match the access mode type that is the result of calling &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_AND_ADD_ACQUIRE)&lt;/code&gt; on this VarHandle.</source>
          <target state="translated">&lt;code&gt;getAndAddAcquire&lt;/code&gt; 的调用站点上的符号类型描述符必须与访问模式类型匹配，该访问模式类型是在此VarHandle上调用 &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_AND_ADD_ACQUIRE)&lt;/code&gt; 的结果。</target>
        </trans-unit>
        <trans-unit id="bb3556eafa083c922f5ddc536ef70abc23d8064c" translate="yes" xml:space="preserve">
          <source>The symbolic type descriptor at the call site of &lt;code&gt;getAndAddRelease&lt;/code&gt; must match the access mode type that is the result of calling &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_AND_ADD_RELEASE)&lt;/code&gt; on this VarHandle.</source>
          <target state="translated">&lt;code&gt;getAndAddRelease&lt;/code&gt; 的调用站点上的符号类型描述符必须与访问模式类型匹配，该访问模式类型是在此VarHandle上调用 &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_AND_ADD_RELEASE)&lt;/code&gt; 的结果。</target>
        </trans-unit>
        <trans-unit id="aab207cd06c5ec5d7499697ca6ba7769359b6579" translate="yes" xml:space="preserve">
          <source>The symbolic type descriptor at the call site of &lt;code&gt;getAndBitwiseAnd&lt;/code&gt; must match the access mode type that is the result of calling &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_AND)&lt;/code&gt; on this VarHandle.</source>
          <target state="translated">&lt;code&gt;getAndBitwiseAnd&lt;/code&gt; 调用站点上的符号类型描述符必须与访问模式类型匹配，该访问模式类型是在此VarHandle上调用 &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_AND)&lt;/code&gt; 的结果。</target>
        </trans-unit>
        <trans-unit id="836795e8bc56b921c84886828b4ff0823073d2b0" translate="yes" xml:space="preserve">
          <source>The symbolic type descriptor at the call site of &lt;code&gt;getAndBitwiseAndAcquire&lt;/code&gt; must match the access mode type that is the result of calling &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_AND_ACQUIRE)&lt;/code&gt; on this VarHandle.</source>
          <target state="translated">&lt;code&gt;getAndBitwiseAndAcquire&lt;/code&gt; 的调用站点上的符号类型描述符必须与访问模式类型匹配，该访问模式类型是在此VarHandle上调用 &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_AND_ACQUIRE)&lt;/code&gt; 的结果。</target>
        </trans-unit>
        <trans-unit id="78cc40ca583a385f170594f785f938d9b667b6eb" translate="yes" xml:space="preserve">
          <source>The symbolic type descriptor at the call site of &lt;code&gt;getAndBitwiseAndRelease&lt;/code&gt; must match the access mode type that is the result of calling &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_AND_RELEASE)&lt;/code&gt; on this VarHandle.</source>
          <target state="translated">&lt;code&gt;getAndBitwiseAndRelease&lt;/code&gt; 的调用站点上的符号类型描述符必须与访问模式类型匹配，该访问模式类型是在此VarHandle上调用 &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_AND_RELEASE)&lt;/code&gt; 的结果。</target>
        </trans-unit>
        <trans-unit id="845f2ed88bc26c3452225eb1d4ee813e31903cab" translate="yes" xml:space="preserve">
          <source>The symbolic type descriptor at the call site of &lt;code&gt;getAndBitwiseOr&lt;/code&gt; must match the access mode type that is the result of calling &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_OR)&lt;/code&gt; on this VarHandle.</source>
          <target state="translated">&lt;code&gt;getAndBitwiseOr&lt;/code&gt; 调用站点上的符号类型描述符必须与访问模式类型匹配，该访问模式类型是在此VarHandle上调用 &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_OR)&lt;/code&gt; 的结果。</target>
        </trans-unit>
        <trans-unit id="2ddd9f837d79fd41f1a93fe6a1f1e69fb4737c0f" translate="yes" xml:space="preserve">
          <source>The symbolic type descriptor at the call site of &lt;code&gt;getAndBitwiseOrAcquire&lt;/code&gt; must match the access mode type that is the result of calling &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_OR_ACQUIRE)&lt;/code&gt; on this VarHandle.</source>
          <target state="translated">&lt;code&gt;getAndBitwiseOrAcquire&lt;/code&gt; 调用站点上的符号类型描述符必须与访问模式类型匹配，该访问模式类型是在此VarHandle上调用 &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_OR_ACQUIRE)&lt;/code&gt; 的结果。</target>
        </trans-unit>
        <trans-unit id="b92e606932a5540d338db4148a4c5b8e213940b9" translate="yes" xml:space="preserve">
          <source>The symbolic type descriptor at the call site of &lt;code&gt;getAndBitwiseOrRelease&lt;/code&gt; must match the access mode type that is the result of calling &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_OR_RELEASE)&lt;/code&gt; on this VarHandle.</source>
          <target state="translated">&lt;code&gt;getAndBitwiseOrRelease&lt;/code&gt; 的调用站点上的符号类型描述符必须与访问模式类型匹配，该访问模式类型是在此VarHandle上调用 &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_OR_RELEASE)&lt;/code&gt; 的结果。</target>
        </trans-unit>
        <trans-unit id="248d840d1056e103e71ed4367a20a6f5c5c6b14b" translate="yes" xml:space="preserve">
          <source>The symbolic type descriptor at the call site of &lt;code&gt;getAndBitwiseXor&lt;/code&gt; must match the access mode type that is the result of calling &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_XOR)&lt;/code&gt; on this VarHandle.</source>
          <target state="translated">&lt;code&gt;getAndBitwiseXor&lt;/code&gt; 的调用站点上的符号类型描述符必须与访问模式类型匹配，该访问模式类型是在此VarHandle上调用 &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_XOR)&lt;/code&gt; 的结果。</target>
        </trans-unit>
        <trans-unit id="6603458f74711c546450ff99c0fa6a4f391bc1ad" translate="yes" xml:space="preserve">
          <source>The symbolic type descriptor at the call site of &lt;code&gt;getAndBitwiseXorAcquire&lt;/code&gt; must match the access mode type that is the result of calling &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_XOR_ACQUIRE)&lt;/code&gt; on this VarHandle.</source>
          <target state="translated">&lt;code&gt;getAndBitwiseXorAcquire&lt;/code&gt; 调用站点上的符号类型描述符必须与访问模式类型匹配，该访问模式类型是在此VarHandle上调用 &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_XOR_ACQUIRE)&lt;/code&gt; 的结果。</target>
        </trans-unit>
        <trans-unit id="582cd1e29d747ef96d86945b9cc3596d644def63" translate="yes" xml:space="preserve">
          <source>The symbolic type descriptor at the call site of &lt;code&gt;getAndBitwiseXorRelease&lt;/code&gt; must match the access mode type that is the result of calling &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_XOR_RELEASE)&lt;/code&gt; on this VarHandle.</source>
          <target state="translated">&lt;code&gt;getAndBitwiseXorRelease&lt;/code&gt; 的调用站点上的符号类型描述符必须与访问模式类型匹配，该访问模式类型是在此VarHandle上调用 &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_XOR_RELEASE)&lt;/code&gt; 的结果。</target>
        </trans-unit>
        <trans-unit id="0b49e84c3b73b7c67f75202b8dcf68959c3b67df" translate="yes" xml:space="preserve">
          <source>The symbolic type descriptor at the call site of &lt;code&gt;getAndSet&lt;/code&gt; must match the access mode type that is the result of calling &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_AND_SET)&lt;/code&gt; on this VarHandle.</source>
          <target state="translated">&lt;code&gt;getAndSet&lt;/code&gt; 的调用站点上的符号类型描述符必须与访问模式类型匹配，该访问模式类型是在此VarHandle上调用 &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_AND_SET)&lt;/code&gt; 的结果。</target>
        </trans-unit>
        <trans-unit id="726283d34708064e448798ed7558fd26056194bc" translate="yes" xml:space="preserve">
          <source>The symbolic type descriptor at the call site of &lt;code&gt;getAndSetAcquire&lt;/code&gt; must match the access mode type that is the result of calling &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_AND_SET_ACQUIRE)&lt;/code&gt; on this VarHandle.</source>
          <target state="translated">&lt;code&gt;getAndSetAcquire&lt;/code&gt; 调用站点上的符号类型描述符必须与访问模式类型匹配，该访问模式类型是在此VarHandle上调用 &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_AND_SET_ACQUIRE)&lt;/code&gt; 的结果。</target>
        </trans-unit>
        <trans-unit id="d72b516be7afed65c7b9b32c7e234a778cc590e8" translate="yes" xml:space="preserve">
          <source>The symbolic type descriptor at the call site of &lt;code&gt;getAndSetRelease&lt;/code&gt; must match the access mode type that is the result of calling &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_AND_SET_RELEASE)&lt;/code&gt; on this VarHandle.</source>
          <target state="translated">&lt;code&gt;getAndSetRelease&lt;/code&gt; 的调用站点上的符号类型描述符必须与访问模式类型匹配，该访问模式类型是在此VarHandle上调用 &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_AND_SET_RELEASE)&lt;/code&gt; 的结果。</target>
        </trans-unit>
        <trans-unit id="4a3f7c47047a21314dc4bcc3cfef336f2dea3704" translate="yes" xml:space="preserve">
          <source>The symbolic type descriptor at the call site of &lt;code&gt;getOpaque&lt;/code&gt; must match the access mode type that is the result of calling &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_OPAQUE)&lt;/code&gt; on this VarHandle.</source>
          <target state="translated">&lt;code&gt;getOpaque&lt;/code&gt; 的调用站点上的符号类型描述符必须与访问模式类型匹配，该访问模式类型是在此VarHandle上调用 &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_OPAQUE)&lt;/code&gt; 的结果。</target>
        </trans-unit>
        <trans-unit id="80d17bb7d7e04c4f675b8b6a6964580c44801bf2" translate="yes" xml:space="preserve">
          <source>The symbolic type descriptor at the call site of &lt;code&gt;getVolatile&lt;/code&gt; must match the access mode type that is the result of calling &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_VOLATILE)&lt;/code&gt; on this VarHandle.</source>
          <target state="translated">&lt;code&gt;getVolatile&lt;/code&gt; 的调用站点上的符号类型描述符必须与访问模式类型匹配，该访问模式类型是在此VarHandle上调用 &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_VOLATILE)&lt;/code&gt; 的结果。</target>
        </trans-unit>
        <trans-unit id="94be2d0c54621beaec5e232a04f1856df457acaf" translate="yes" xml:space="preserve">
          <source>The symbolic type descriptor at the call site of &lt;code&gt;set&lt;/code&gt; must match the access mode type that is the result of calling &lt;code&gt;accessModeType(VarHandle.AccessMode.SET)&lt;/code&gt; on this VarHandle.</source>
          <target state="translated">&lt;code&gt;set&lt;/code&gt; 的调用站点上的符号类型描述符必须与访问模式类型匹配，该访问模式类型是在此VarHandle上调用 &lt;code&gt;accessModeType(VarHandle.AccessMode.SET)&lt;/code&gt; 的结果。</target>
        </trans-unit>
        <trans-unit id="158dfc3921c96e11341de806f439c35a94497773" translate="yes" xml:space="preserve">
          <source>The symbolic type descriptor at the call site of &lt;code&gt;setOpaque&lt;/code&gt; must match the access mode type that is the result of calling &lt;code&gt;accessModeType(VarHandle.AccessMode.SET_OPAQUE)&lt;/code&gt; on this VarHandle.</source>
          <target state="translated">&lt;code&gt;setOpaque&lt;/code&gt; 的调用站点上的符号类型描述符必须与访问模式类型匹配，该访问模式类型是在此VarHandle上调用 &lt;code&gt;accessModeType(VarHandle.AccessMode.SET_OPAQUE)&lt;/code&gt; 的结果。</target>
        </trans-unit>
        <trans-unit id="342170d52a224940f39c38e69957aa300beeb148" translate="yes" xml:space="preserve">
          <source>The symbolic type descriptor at the call site of &lt;code&gt;setRelease&lt;/code&gt; must match the access mode type that is the result of calling &lt;code&gt;accessModeType(VarHandle.AccessMode.SET_RELEASE)&lt;/code&gt; on this VarHandle.</source>
          <target state="translated">&lt;code&gt;setRelease&lt;/code&gt; 的调用站点上的符号类型描述符必须与访问模式类型匹配，该访问模式类型是在此VarHandle上调用 &lt;code&gt;accessModeType(VarHandle.AccessMode.SET_RELEASE)&lt;/code&gt; 的结果。</target>
        </trans-unit>
        <trans-unit id="68ed9d8b4bcd184b8baaaf811374d5c92f6c83db" translate="yes" xml:space="preserve">
          <source>The symbolic type descriptor at the call site of &lt;code&gt;setVolatile&lt;/code&gt; must match the access mode type that is the result of calling &lt;code&gt;accessModeType(VarHandle.AccessMode.SET_VOLATILE)&lt;/code&gt; on this VarHandle.</source>
          <target state="translated">&lt;code&gt;setVolatile&lt;/code&gt; 的调用站点上的符号类型描述符必须与访问模式类型匹配，该访问模式类型是在此VarHandle上调用 &lt;code&gt;accessModeType(VarHandle.AccessMode.SET_VOLATILE)&lt;/code&gt; 的结果。</target>
        </trans-unit>
        <trans-unit id="52423f32e1b10ddbf83308406995a99e390cdeaf" translate="yes" xml:space="preserve">
          <source>The synchronization mechanism that provides reader/writer capabilities for disconnected &lt;code&gt;RowSet&lt;/code&gt; objects.</source>
          <target state="translated">为断开连接的 &lt;code&gt;RowSet&lt;/code&gt; 对象提供读取器/写入器功能的同步机制。</target>
        </trans-unit>
        <trans-unit id="711ab65736cb44038b84d447045e9ee485fba83d" translate="yes" xml:space="preserve">
          <source>The synchronization mechanism that provides reader/writer capabilities for disconnected &lt;code&gt;RowSet&lt;/code&gt; objects. A &lt;code&gt;SyncProvider&lt;/code&gt; implementation is a class that extends the &lt;code&gt;SyncProvider&lt;/code&gt; abstract class.</source>
          <target state="translated">为断开连接的 &lt;code&gt;RowSet&lt;/code&gt; 对象提供读取器/写入器功能的同步机制。一 &lt;code&gt;SyncProvider&lt;/code&gt; 实现是一个扩展一个类 &lt;code&gt;SyncProvider&lt;/code&gt; 抽象类。</target>
        </trans-unit>
        <trans-unit id="939dc2dd97681934d81029b8ea6d3b61888d9016" translate="yes" xml:space="preserve">
          <source>The syntactic form of this case:</source>
          <target state="translated">本案的语法形式。</target>
        </trans-unit>
        <trans-unit id="f3288e69953928bbb2335d7fc9bfc195092f73df" translate="yes" xml:space="preserve">
          <source>The syntactic form of this case: STATEMENT: &lt;code&gt;case &amp;lt;expression&amp;gt;: &amp;lt;statements&amp;gt;&lt;/code&gt; RULE: &lt;code&gt;case &amp;lt;expression&amp;gt; -&amp;gt; &amp;lt;expression&amp;gt;/&amp;lt;statement&amp;gt;&lt;/code&gt;</source>
          <target state="translated">此案例的句法形式：STATEMENT： &lt;code&gt;case &amp;lt;expression&amp;gt;: &amp;lt;statements&amp;gt;&lt;/code&gt; 规则： &lt;code&gt;case &amp;lt;expression&amp;gt; -&amp;gt; &amp;lt;expression&amp;gt;/&amp;lt;statement&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4e55e499a6fc5c1dbd4e8b7511cc0424a80a9f71" translate="yes" xml:space="preserve">
          <source>The syntactic locations where annotations may appear are split into &lt;em&gt;declaration contexts&lt;/em&gt; , where annotations apply to declarations, and &lt;em&gt;type contexts&lt;/em&gt; , where annotations apply to types used in declarations and expressions.</source>
          <target state="translated">可能会出现注释的句法位置分为&lt;em&gt;声明上下文&lt;/em&gt;，注释适用于声明的&lt;em&gt;类型上下文&lt;/em&gt;和&lt;em&gt;类型上下文&lt;/em&gt;，类型注释适用于声明和表达式中使用的&lt;em&gt;类型的类型上下文&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="d632ddfa97c4cad739a3e8bfa95d9d9894f9d8e2" translate="yes" xml:space="preserve">
          <source>The syntactic locations where annotations may appear are split into &lt;em&gt;declaration contexts&lt;/em&gt;, where annotations apply to declarations, and &lt;em&gt;type contexts&lt;/em&gt;, where annotations apply to types used in declarations and expressions.</source>
          <target state="translated">可能会出现注释的句法位置分为&lt;em&gt;声明上下文&lt;/em&gt;，注释适用于声明的&lt;em&gt;类型上下文&lt;/em&gt;和&lt;em&gt;类型上下文&lt;/em&gt;，类型注释适用于声明和表达式中使用的&lt;em&gt;类型的类型上下文&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="00a77c038c4619155739ddefe087cb77c766d025" translate="yes" xml:space="preserve">
          <source>The syntax of &lt;code&gt;URL&lt;/code&gt; is defined by &lt;a href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;&lt;i&gt;RFC 2396: Uniform Resource Identifiers (URI): Generic Syntax&lt;/i&gt;&lt;/a&gt;, amended by &lt;a href=&quot;http://www.ietf.org/rfc/rfc2732.txt&quot;&gt;&lt;i&gt;RFC 2732: Format for Literal IPv6 Addresses in URLs&lt;/i&gt;&lt;/a&gt;. The Literal IPv6 address format also supports scope_ids. The syntax and usage of scope_ids is described &lt;a href=&quot;inet6address#scoped&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;URL&lt;/code&gt; 的语法由&lt;a href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;&lt;i&gt;RFC 2396：统一资源标识符（URI）：通用语法定义&lt;/i&gt;&lt;/a&gt;，并由&lt;a href=&quot;http://www.ietf.org/rfc/rfc2732.txt&quot;&gt;&lt;i&gt;RFC 2732：URL中的文字IPv6地址格式&lt;/i&gt;&lt;/a&gt;修改。文字IPv6地址格式还支持scope_ids。&lt;a href=&quot;inet6address#scoped&quot;&gt;这里&lt;/a&gt;描述scope_ids的语法和用法。</target>
        </trans-unit>
        <trans-unit id="d30895ab44eb5b5f1c0c0bd25de8d5e5b87d3b73" translate="yes" xml:space="preserve">
          <source>The syntax of &lt;code&gt;URL&lt;/code&gt; is defined by &lt;a href=&quot;https://www.ietf.org/rfc/rfc2396.txt&quot;&gt;&lt;i&gt;RFC 2396: Uniform Resource Identifiers (URI): Generic Syntax&lt;/i&gt;&lt;/a&gt;, amended by &lt;a href=&quot;https://www.ietf.org/rfc/rfc2732.txt&quot;&gt;&lt;i&gt;RFC 2732: Format for Literal IPv6 Addresses in URLs&lt;/i&gt;&lt;/a&gt;. The Literal IPv6 address format also supports scope_ids. The syntax and usage of scope_ids is described &lt;a href=&quot;inet6address#scoped&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;URL&lt;/code&gt; 的语法由&lt;a href=&quot;https://www.ietf.org/rfc/rfc2396.txt&quot;&gt;&lt;i&gt;RFC 2396：统一资源标识符（URI）：通用语法定义&lt;/i&gt;&lt;/a&gt;，并由&lt;a href=&quot;https://www.ietf.org/rfc/rfc2732.txt&quot;&gt;&lt;i&gt;RFC 2732：URL中的文字IPv6地址格式&lt;/i&gt;&lt;/a&gt;修改。文字IPv6地址格式还支持scope_ids。&lt;a href=&quot;inet6address#scoped&quot;&gt;这里&lt;/a&gt;描述了scope_ids的语法和用法。</target>
        </trans-unit>
        <trans-unit id="449145cc99d61f1de8faac0f36747e42eeda60f0" translate="yes" xml:space="preserve">
          <source>The syntax of a JAR URL is:</source>
          <target state="translated">JAR URL的语法是:</target>
        </trans-unit>
        <trans-unit id="08fb1f0d6774918d6dc928c999a8c810bc3e1cf4" translate="yes" xml:space="preserve">
          <source>The syntax of a compound name is specified using a set of properties:</source>
          <target state="translated">复名的语法是用一组属性来指定的。</target>
        </trans-unit>
        <trans-unit id="4fb2ecb6c058b701542fac5ca88a96aa5fb606b8" translate="yes" xml:space="preserve">
          <source>The system &lt;code&gt;ClassLoader&lt;/code&gt;</source>
          <target state="translated">系统 &lt;code&gt;ClassLoader&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="74f5647e4732b56055ffb73b5ef679c9f6b0e018" translate="yes" xml:space="preserve">
          <source>The system &lt;code&gt;ClassLoader&lt;/code&gt; for delegation, or &lt;code&gt;null&lt;/code&gt; if none</source>
          <target state="translated">用于委托的系统 &lt;code&gt;ClassLoader&lt;/code&gt; ；如果没有，则为 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="09bd470fb008a04d052a9d37972d68c9fb1da6a5" translate="yes" xml:space="preserve">
          <source>The system can interpolate the provided value.</source>
          <target state="translated">系统可以对提供的数值进行插值。</target>
        </trans-unit>
        <trans-unit id="e53b892170425a40e4822de5a8c352ee0cdcdd75" translate="yes" xml:space="preserve">
          <source>The system class loader supports adding a JAR file to be searched if it implements a method named &lt;code&gt;appendToClassPathForInstrumentation&lt;/code&gt; which takes a single parameter of type &lt;code&gt;java.lang.String&lt;/code&gt;. The method is not required to have &lt;code&gt;public&lt;/code&gt; access. The name of the JAR file is obtained by invoking the &lt;a href=&quot;../../../../java.base/java/util/zip/zipfile#getName()&quot;&gt;&lt;code&gt;getName()&lt;/code&gt;&lt;/a&gt; method on the &lt;code&gt;jarfile&lt;/code&gt; and this is provided as the parameter to the &lt;code&gt;appendToClassPathForInstrumentation&lt;/code&gt; method.</source>
          <target state="translated">如果系统类加载器实现了一个名为 &lt;code&gt;appendToClassPathForInstrumentation&lt;/code&gt; 的方法，该方法采用单个 &lt;code&gt;java.lang.String&lt;/code&gt; 类型的参数，则它支持添加要搜索的JAR文件。该方法不需要具有 &lt;code&gt;public&lt;/code&gt; 访问权限。通过在 &lt;code&gt;jarfile&lt;/code&gt; 上调用&lt;a href=&quot;../../../../java.base/java/util/zip/zipfile#getName()&quot;&gt; &lt;code&gt;getName()&lt;/code&gt; &lt;/a&gt;方法来获得JAR文件的名称，并将其作为 &lt;code&gt;appendToClassPathForInstrumentation&lt;/code&gt; 方法的参数提供。</target>
        </trans-unit>
        <trans-unit id="74a5a2feb3472fb9649c9e133c6a12917cacd2aa" translate="yes" xml:space="preserve">
          <source>The system class loader supports adding a JAR file to be searched if it implements a method named &lt;code&gt;appendToClassPathForInstrumentation&lt;/code&gt; which takes a single parameter of type &lt;code&gt;java.lang.String&lt;/code&gt;. The method is not required to have &lt;code&gt;public&lt;/code&gt; access. The name of the JAR file is obtained by invoking the &lt;a href=&quot;../../util/zip/zipfile#getName--&quot;&gt;&lt;code&gt;getName()&lt;/code&gt;&lt;/a&gt; method on the &lt;code&gt;jarfile&lt;/code&gt; and this is provided as the parameter to the &lt;code&gt;appendToClassPathForInstrumentation&lt;/code&gt; method.</source>
          <target state="translated">如果系统类加载器实现了一个名为 &lt;code&gt;appendToClassPathForInstrumentation&lt;/code&gt; 的方法，该方法采用单个 &lt;code&gt;java.lang.String&lt;/code&gt; 类型的参数，则它支持添加要搜索的JAR文件。该方法不需要具有 &lt;code&gt;public&lt;/code&gt; 访问权限。通过在 &lt;code&gt;jarfile&lt;/code&gt; 上调用&lt;a href=&quot;../../util/zip/zipfile#getName--&quot;&gt; &lt;code&gt;getName()&lt;/code&gt; &lt;/a&gt;方法获得JAR文件的名称，并将其作为 &lt;code&gt;appendToClassPathForInstrumentation&lt;/code&gt; 方法的参数提供。</target>
        </trans-unit>
        <trans-unit id="e7007628b7373da2f3acc46dea4b6fc181e177f3" translate="yes" xml:space="preserve">
          <source>The system console, if any, otherwise &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">系统控制台（如果有），否则为 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="990083cbffe223d7dee670ed0f3eec843ed8520d" translate="yes" xml:space="preserve">
          <source>The system default &lt;code&gt;LoggerFinder&lt;/code&gt; implementation uses &lt;code&gt;java.util.logging&lt;/code&gt; as the backend framework when the &lt;code&gt;java.logging&lt;/code&gt; module is present. It returns a &lt;a href=&quot;system.logger&quot;&gt;logger&lt;/a&gt; instance that will route log messages to a &lt;a href=&quot;../../../java.logging/java/util/logging/logger&quot;&gt;&lt;code&gt;java.util.logging.Logger&lt;/code&gt;&lt;/a&gt;. Otherwise, if &lt;code&gt;java.logging&lt;/code&gt; is not present, the default implementation will return a simple logger instance that will route log messages of &lt;code&gt;INFO&lt;/code&gt; level and above to the console (&lt;code&gt;System.err&lt;/code&gt;).</source>
          <target state="translated">当存在 &lt;code&gt;java.logging&lt;/code&gt; 模块时，系统默认的 &lt;code&gt;LoggerFinder&lt;/code&gt; 实现将 &lt;code&gt;java.util.logging&lt;/code&gt; 用作后端框架。它返回一个&lt;a href=&quot;system.logger&quot;&gt;记录器&lt;/a&gt;实例，该记录器实例会将日志消息路由到&lt;a href=&quot;../../../java.logging/java/util/logging/logger&quot;&gt; &lt;code&gt;java.util.logging.Logger&lt;/code&gt; &lt;/a&gt;。否则，如果不存在 &lt;code&gt;java.logging&lt;/code&gt; ，则默认实现将返回一个简单的记录器实例，该实例会将 &lt;code&gt;INFO&lt;/code&gt; 级别及以上的日志消息路由到控制台（ &lt;code&gt;System.err&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="3cf101b78cd06413158b1ec4f8db88795dfdf0e0" translate="yes" xml:space="preserve">
          <source>The system does not provide a reason for a session change.</source>
          <target state="translated">系统不提供会话变更的原因。</target>
        </trans-unit>
        <trans-unit id="d37ff3b03f83b416aeccd9836d23dd0072998488" translate="yes" xml:space="preserve">
          <source>The system identifier as a string, or null if none is available.</source>
          <target state="translated">系统标识符为字符串,如果没有,则为空。</target>
        </trans-unit>
        <trans-unit id="c9d316b1fe86ec8261312bc65a64ba6fd6ecd9f6" translate="yes" xml:space="preserve">
          <source>The system identifier associated with the entity if specified, and &lt;code&gt;null&lt;/code&gt; otherwise.</source>
          <target state="translated">与实体关联的系统标识符（如果已指定），否则为 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="df19c9feca0d6dc04cc43c03e2d1251edf9e4510" translate="yes" xml:space="preserve">
          <source>The system identifier associated with the entity if specified, and &lt;code&gt;null&lt;/code&gt; otherwise. This may be an absolute URI or not.</source>
          <target state="translated">与实体关联的系统标识符（如果已指定），否则为 &lt;code&gt;null&lt;/code&gt; 。这可以是绝对URI，也可以不是。</target>
        </trans-unit>
        <trans-unit id="b32fa52354502a426e561283736887788b3252db" translate="yes" xml:space="preserve">
          <source>The system identifier is optional if the source does not get its data from a URL, but it may still be useful to provide one. The application can use a system identifier, for example, to resolve relative URIs and to include in error messages and warnings.</source>
          <target state="translated">如果源不从URL中获取数据,系统标识符是可选的,但提供一个系统标识符可能还是有用的。例如,应用程序可以使用系统标识符来解析相对的URI,并将其包含在错误信息和警告中。</target>
        </trans-unit>
        <trans-unit id="2364c05ce4f7479bebd35fee2edf0a7d214455de" translate="yes" xml:space="preserve">
          <source>The system identifier is optional if there is a byte stream or a character stream, but it is still useful to provide one, since the application can use it to resolve relative URIs and can include it in error messages and warnings (the parser will attempt to open a connection to the URI only if no byte stream or character stream is specified).</source>
          <target state="translated">如果有字节流或字符流,系统标识符是可选的,但提供一个系统标识符还是很有用的,因为应用程序可以用它来解析相对的URI,并可以将它包含在错误信息和警告中(只有在没有指定字节流或字符流的情况下,解析器才会尝试打开与URI的连接)。</target>
        </trans-unit>
        <trans-unit id="c83b9a58a230a52e3ca07250c92629dfdd6df1bf" translate="yes" xml:space="preserve">
          <source>The system identifier is optional if there is a byte stream or a character stream, but it is still useful to provide one, since the application can use it to resolve relative URIs and can include it in error messages and warnings (the parser will attempt to open a connection to the URI only if there is no byte stream or character stream specified).</source>
          <target state="translated">如果有字节流或字符流,系统标识符是可选的,但提供一个标识符还是很有用的,因为应用程序可以用它来解析相对的URI,并可以将它包含在错误信息和警告中(只有在没有指定字节流或字符流的情况下,解析器才会尝试打开与URI的连接)。</target>
        </trans-unit>
        <trans-unit id="3cef073d95130421d24f48582c3ee6a831095599" translate="yes" xml:space="preserve">
          <source>The system identifier may be &lt;code&gt;null&lt;/code&gt; or an empty &lt;code&gt;&quot;&quot;&lt;/code&gt;&lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">系统标识符可以为 &lt;code&gt;null&lt;/code&gt; 或为空的 &lt;code&gt;&quot;&quot;&lt;/code&gt; &lt;code&gt;String&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ff7e558528664a0592a67c50fde5c5a005f60b33" translate="yes" xml:space="preserve">
          <source>The system identifier of the external subset.</source>
          <target state="translated">外部子集的系统标识符。</target>
        </trans-unit>
        <trans-unit id="5b27a3eb89c729d7e642ff92ff95e3dac820f59c" translate="yes" xml:space="preserve">
          <source>The system identifier of the external subset. This may be an absolute URI or not.</source>
          <target state="translated">外部子集的系统标识符。这可能是一个绝对URI,也可能不是。</target>
        </trans-unit>
        <trans-unit id="ff0c997f101dd04693253ebc52fe8874df3b5062" translate="yes" xml:space="preserve">
          <source>The system identifier of this notation.</source>
          <target state="translated">本记号的系统标识符。</target>
        </trans-unit>
        <trans-unit id="54b96c3bc9ebc5adfe89119951cb415cb6d98e20" translate="yes" xml:space="preserve">
          <source>The system identifier of this notation. If the system identifier was not specified, this is &lt;code&gt;null&lt;/code&gt;. This may be an absolute URI or not.</source>
          <target state="translated">该符号的系统标识符。如果未指定系统标识符，则为 &lt;code&gt;null&lt;/code&gt; 。这可以是绝对URI，也可以不是。</target>
        </trans-unit>
        <trans-unit id="e0dc421d48b89f1f1bd983b514fa401be307f95f" translate="yes" xml:space="preserve">
          <source>The system identifier that was set with setSystemId, or null if setSystemId was not called.</source>
          <target state="translated">用setSystemId设置的系统标识符,如果没有调用setSystemId,则为空。</target>
        </trans-unit>
        <trans-unit id="a1ce02ce7ff2b78b9dae3fc1cf570c0f7333877f" translate="yes" xml:space="preserve">
          <source>The system identifier, a URI reference [&lt;a href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;IETF RFC 2396&lt;/a&gt;], for this input source.</source>
          <target state="translated">此输入源的系统标识符，即URI参考[ &lt;a href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;IETF RFC 2396&lt;/a&gt; ]。</target>
        </trans-unit>
        <trans-unit id="257e29fd1c5d73c7e7ae227aff860a12a6b60071" translate="yes" xml:space="preserve">
          <source>The system identifier, a URI reference [&lt;a href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;IETF RFC 2396&lt;/a&gt;], for this input source. The system identifier is optional if there is a byte stream, a character stream, or string data. It is still useful to provide one, since the application will use it to resolve any relative URIs and can include it in error messages and warnings. (The LSParser will only attempt to fetch the resource identified by the URI reference if there is no other input available in the input source.)</source>
          <target state="translated">此输入源的系统标识符，即URI参考[ &lt;a href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;IETF RFC 2396&lt;/a&gt; ]。如果存在字节流，字符流或字符串数​​据，则系统标识符是可选的。提供一个仍然很有用，因为应用程序将使用它来解析任何相对的URI，并将其包含在错误消息和警告中。（如果输入源中没有其他可用输入，则LSParser只会尝试获取URI引用标识的资源。）</target>
        </trans-unit>
        <trans-unit id="9aecaed599272a3cd0476ff61a2a3b31138ead77" translate="yes" xml:space="preserve">
          <source>The system identifier, a URI reference [&lt;a href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;IETF RFC 2396&lt;/a&gt;], for this output destination.</source>
          <target state="translated">此输出目标的系统标识符，即URI参考[ &lt;a href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;IETF RFC 2396&lt;/a&gt; ]。</target>
        </trans-unit>
        <trans-unit id="b0ed5624153545966ebdca177865c153cb4b447e" translate="yes" xml:space="preserve">
          <source>The system identifier, a URI reference [&lt;a href=&quot;https://www.ietf.org/rfc/rfc2396.txt&quot;&gt;IETF RFC 2396&lt;/a&gt;], for this input source.</source>
          <target state="translated">此输入源的系统标识符，即URI参考[ &lt;a href=&quot;https://www.ietf.org/rfc/rfc2396.txt&quot;&gt;IETF RFC 2396&lt;/a&gt; ]。</target>
        </trans-unit>
        <trans-unit id="68cb3432f3f6642c8c7a7d7fc19e09015d305ffe" translate="yes" xml:space="preserve">
          <source>The system identifier, a URI reference [&lt;a href=&quot;https://www.ietf.org/rfc/rfc2396.txt&quot;&gt;IETF RFC 2396&lt;/a&gt;], for this input source. The system identifier is optional if there is a byte stream, a character stream, or string data. It is still useful to provide one, since the application will use it to resolve any relative URIs and can include it in error messages and warnings. (The LSParser will only attempt to fetch the resource identified by the URI reference if there is no other input available in the input source.)</source>
          <target state="translated">此输入源的系统标识符，即URI参考[ &lt;a href=&quot;https://www.ietf.org/rfc/rfc2396.txt&quot;&gt;IETF RFC 2396&lt;/a&gt; ]。如果存在字节流，字符流或字符串数​​据，则系统标识符是可选的。提供一个仍然很有用，因为应用程序将使用它来解析任何相对的URI，并将其包含在错误消息和警告中。（如果输入源中没有其他可用输入，则LSParser只会尝试获取URI引用标识的资源。）</target>
        </trans-unit>
        <trans-unit id="c4a3303bba8bb8e092ba3f05afe26aab40de2240" translate="yes" xml:space="preserve">
          <source>The system identifier, a URI reference [&lt;a href=&quot;https://www.ietf.org/rfc/rfc2396.txt&quot;&gt;IETF RFC 2396&lt;/a&gt;], for this output destination.</source>
          <target state="translated">此输出目标的系统标识符，即URI参考[ &lt;a href=&quot;https://www.ietf.org/rfc/rfc2396.txt&quot;&gt;IETF RFC 2396&lt;/a&gt; ]。</target>
        </trans-unit>
        <trans-unit id="9ac19f96242350b7673acfdd7d4b02b017a83550" translate="yes" xml:space="preserve">
          <source>The system identifier, or null if none was supplied.</source>
          <target state="translated">系统标识符,如果没有提供,则为空。</target>
        </trans-unit>
        <trans-unit id="9432be2aa85292b809c263d55400ca2c13bb187f" translate="yes" xml:space="preserve">
          <source>The system identifier.</source>
          <target state="translated">系统标识符。</target>
        </trans-unit>
        <trans-unit id="33154309f44b1f3e4b9b63aa2db5ffb66d8d5f1d" translate="yes" xml:space="preserve">
          <source>The system modules, which are the compiled definitions built in to the environment.</source>
          <target state="translated">系统模块,就是环境中内置的编译定义。</target>
        </trans-unit>
        <trans-unit id="9ffce2da0a02206a57f77d7fbe2f3119028884ac" translate="yes" xml:space="preserve">
          <source>The system properties</source>
          <target state="translated">系统属性</target>
        </trans-unit>
        <trans-unit id="c60418fc7a6719a8685abc353065d31174ef68f2" translate="yes" xml:space="preserve">
          <source>The system property &lt;code&gt;&lt;span id=&quot;java.security.auth.login.config&quot;&gt;java.security.auth.login.config&lt;/span&gt;&lt;/code&gt; may also be set to a &lt;code&gt;URL&lt;/code&gt; pointing to another login configuration file (which is the case when a user uses the -D switch at runtime). If this property is defined, and its use is allowed by the security property file (the Security property,</source>
          <target state="translated">系统属性 &lt;code&gt;&lt;span id=&quot;java.security.auth.login.config&quot;&gt;java.security.auth.login.config&lt;/span&gt;&lt;/code&gt; 也可以设置为指向另一个登录配置文件的 &lt;code&gt;URL&lt;/code&gt; （用户在运行时使用-D开关时就是这种情况）。如果定义了此属性，并且安全属性文件（&amp;ldquo;安全&amp;rdquo;属性，</target>
        </trans-unit>
        <trans-unit id="84fb25c617804e775187a1ef35381adde7a462d2" translate="yes" xml:space="preserve">
          <source>The system property that controls which Factory implementation to create is named &lt;code&gt;&quot;javax.xml.parsers.SAXParserFactory&quot;&lt;/code&gt;. This property names a class that is a concrete subclass of this abstract class. If no property is defined, a platform default will be used.</source>
          <target state="translated">控制创建哪个Factory实现的系统属性称为 &lt;code&gt;&quot;javax.xml.parsers.SAXParserFactory&quot;&lt;/code&gt; 。该属性命名一个类，该类是此抽象类的具体子类。如果未定义任何属性，则将使用平台默认值。</target>
        </trans-unit>
        <trans-unit id="7d513879bd2964703d8728b1b4c20e907f2382f9" translate="yes" xml:space="preserve">
          <source>The system property that determines which Factory implementation to create is named &lt;code&gt;&quot;javax.xml.transform.TransformerFactory&quot;&lt;/code&gt;. This property names a concrete subclass of the &lt;code&gt;TransformerFactory&lt;/code&gt; abstract class. If the property is not defined, a platform default is be used.</source>
          <target state="translated">确定要创建哪个Factory实现的系统属性称为 &lt;code&gt;&quot;javax.xml.transform.TransformerFactory&quot;&lt;/code&gt; 。此属性为 &lt;code&gt;TransformerFactory&lt;/code&gt; 抽象类的具体子类命名。如果未定义该属性，则使用平台默认值。</target>
        </trans-unit>
        <trans-unit id="305047c960aad4ed37ebc14427e984473ca4e5f9" translate="yes" xml:space="preserve">
          <source>The system property to override the system class loader is not examined until the VM is almost fully initialized. Code that executes this method during startup should take care not to cache the return value until the system is fully initialized.</source>
          <target state="translated">在虚拟机几乎完全初始化之前,不会检查覆盖系统类加载器的系统属性。在启动期间执行此方法的代码应注意在系统完全初始化之前不要缓存返回值。</target>
        </trans-unit>
        <trans-unit id="1f722c038ba46377c26c7b3d111ee938421ee539" translate="yes" xml:space="preserve">
          <source>The system property to specify the DOMImplementationSource class names.</source>
          <target state="translated">系统属性,用于指定DOMImplementationSource类名。</target>
        </trans-unit>
        <trans-unit id="78a2fb8c1adaa830a99ae7c2ad610a98649d150e" translate="yes" xml:space="preserve">
          <source>The system will probe the specified file to determine its keystore type and return a keystore implementation with its entries already loaded. When this approach is used there is no need to call the keystore's &lt;a href=&quot;#load(java.io.InputStream,char%5B%5D)&quot;&gt;&lt;code&gt;load&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">系统将探测指定的文件以确定其密钥库类型，并返回已加载其条目的密钥库实现。使用此方法时，无需调用密钥库的&lt;a href=&quot;#load(java.io.InputStream,char%5B%5D)&quot;&gt; &lt;code&gt;load&lt;/code&gt; &lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="7923449f8c0c0791eb5aa081bc5a65fcb2555819" translate="yes" xml:space="preserve">
          <source>The system will return a keystore implementation for the default type.</source>
          <target state="translated">系统将返回一个默认类型的keystore实现。</target>
        </trans-unit>
        <trans-unit id="00bc1824cf3bd5ca4947f7d237f20eddafbb842c" translate="yes" xml:space="preserve">
          <source>The system will return the most preferred implementation of the specified keystore type available in the environment.</source>
          <target state="translated">系统将返回环境中可用的指定keystore类型的最优选实现。</target>
        </trans-unit>
        <trans-unit id="bf575b9617841369bd0654ef25dcbd4387d7d8b2" translate="yes" xml:space="preserve">
          <source>The system-dependent default name-separator character, represented as a string for convenience.</source>
          <target state="translated">系统默认的名字分隔符,为方便起见,用字符串表示。</target>
        </trans-unit>
        <trans-unit id="a94fecc52deafc39728c10e86b4031f2cc84b1c9" translate="yes" xml:space="preserve">
          <source>The system-dependent default name-separator character, represented as a string for convenience. This string contains a single character, namely &lt;a href=&quot;#separatorChar&quot;&gt;&lt;code&gt;separatorChar&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">与系统有关的默认名称分隔符，为方便起见，以字符串形式表示。该字符串包含一个字符，即&lt;a href=&quot;#separatorChar&quot;&gt; &lt;code&gt;separatorChar&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="db9af4ad444ca84eeeac9fb19764f73c768a1db0" translate="yes" xml:space="preserve">
          <source>The system-dependent default name-separator character, represented as a string for convenience. This string contains a single character, namely &lt;code&gt;&lt;a href=&quot;file#separatorChar&quot;&gt;&lt;code&gt;separatorChar&lt;/code&gt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">系统相关的默认名称分隔符，为方便起见，以字符串形式表示。该字符串包含单个字符，即 &lt;code&gt;&lt;a href=&quot;file#separatorChar&quot;&gt;&lt;code&gt;separatorChar&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="23edeff72c72b6eac94037a43840bbb8e7b551b6" translate="yes" xml:space="preserve">
          <source>The system-dependent default name-separator character.</source>
          <target state="translated">系统默认的名字分隔符。</target>
        </trans-unit>
        <trans-unit id="06c823441fa92d743c30c7c0a19a1d4b758a3865" translate="yes" xml:space="preserve">
          <source>The system-dependent default name-separator character. This field is initialized to contain the first character of the value of the system property &lt;code&gt;file.separator&lt;/code&gt;. On UNIX systems the value of this field is &lt;code&gt;'/'&lt;/code&gt;; on Microsoft Windows systems it is &lt;code&gt;'\\'&lt;/code&gt;.</source>
          <target state="translated">与系统有关的默认名称分隔符。该字段初始化为包含系统属性 &lt;code&gt;file.separator&lt;/code&gt; 的值的第一个字符。在UNIX系统上，该字段的值为 &lt;code&gt;'/'&lt;/code&gt; ；在Microsoft Windows系统上，它是 &lt;code&gt;'\\'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8793c76c9da5710b62dc7c9e42c8f2cdc86a36b3" translate="yes" xml:space="preserve">
          <source>The system-dependent path-separator character, represented as a string for convenience.</source>
          <target state="translated">依赖于系统的路径分隔符,为了方便,用字符串表示。</target>
        </trans-unit>
        <trans-unit id="1f14bf8cb7ba1cb6fe8976b4d14659286d00de2c" translate="yes" xml:space="preserve">
          <source>The system-dependent path-separator character, represented as a string for convenience. This string contains a single character, namely &lt;a href=&quot;#pathSeparatorChar&quot;&gt;&lt;code&gt;pathSeparatorChar&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">与系统有关的路径分隔符，为方便起见，以字符串形式表示。该字符串包含单个字符，即&lt;a href=&quot;#pathSeparatorChar&quot;&gt; &lt;code&gt;pathSeparatorChar&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a67c3801f69a10a5f6ee1400db51f1a4d991731c" translate="yes" xml:space="preserve">
          <source>The system-dependent path-separator character, represented as a string for convenience. This string contains a single character, namely &lt;code&gt;&lt;a href=&quot;file#pathSeparatorChar&quot;&gt;&lt;code&gt;pathSeparatorChar&lt;/code&gt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">系统相关的路径分隔符，为方便起见，以字符串形式表示。该字符串包含单个字符，即 &lt;code&gt;&lt;a href=&quot;file#pathSeparatorChar&quot;&gt;&lt;code&gt;pathSeparatorChar&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="56704d0b0a7bdab899863fa1d0c2f23658372f6a" translate="yes" xml:space="preserve">
          <source>The system-dependent path-separator character.</source>
          <target state="translated">系统依赖的路径分离符。</target>
        </trans-unit>
        <trans-unit id="79dc28fe296e6f9a3e10386e77dffcce367aaf90" translate="yes" xml:space="preserve">
          <source>The system-dependent path-separator character. This field is initialized to contain the first character of the value of the system property &lt;code&gt;path.separator&lt;/code&gt;. This character is used to separate filenames in a sequence of files given as a &lt;em&gt;path list&lt;/em&gt;. On UNIX systems, this character is &lt;code&gt;':'&lt;/code&gt;; on Microsoft Windows systems it is &lt;code&gt;';'&lt;/code&gt;.</source>
          <target state="translated">与系统有关的路径分隔符。初始化此字段以包含系统属性 &lt;code&gt;path.separator&lt;/code&gt; 的值的第一个字符。该字符用于分隔作为&lt;em&gt;路径列表&lt;/em&gt;给出的文件序列中的文件名。在UNIX系统上，此字符为 &lt;code&gt;':'&lt;/code&gt; ;。在Microsoft Windows系统上，它是 &lt;code&gt;';'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="518a2fc9a68e3f3d5382e5d1a00ce498fcc2e594" translate="yes" xml:space="preserve">
          <source>The system-wide default AsynchronousChannel provider</source>
          <target state="translated">全系统默认的异步通道提供者。</target>
        </trans-unit>
        <trans-unit id="80f05d1a680abd50bb2023299790a44b63aaeab1" translate="yes" xml:space="preserve">
          <source>The system-wide default HttpServerProvider</source>
          <target state="translated">全系统默认的HttpServerProvider。</target>
        </trans-unit>
        <trans-unit id="0f461893764b32c9834282b1f614f9186ccf0cf0" translate="yes" xml:space="preserve">
          <source>The system-wide default provider is used by the static &lt;code&gt;open&lt;/code&gt; methods of the &lt;a href=&quot;../datagramchannel#open()&quot;&gt;&lt;code&gt;DatagramChannel&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../pipe#open()&quot;&gt;&lt;code&gt;Pipe&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../selector#open()&quot;&gt;&lt;code&gt;Selector&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../serversocketchannel#open()&quot;&gt;&lt;code&gt;ServerSocketChannel&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../socketchannel#open()&quot;&gt;&lt;code&gt;SocketChannel&lt;/code&gt;&lt;/a&gt; classes. It is also used by the &lt;a href=&quot;../../../lang/system#inheritedChannel()&quot;&gt;&lt;code&gt;System.inheritedChannel()&lt;/code&gt;&lt;/a&gt; method. A program may make use of a provider other than the default provider by instantiating that provider and then directly invoking the &lt;code&gt;open&lt;/code&gt; methods defined in this class.</source>
          <target state="translated">&lt;a href=&quot;../datagramchannel#open()&quot;&gt; &lt;code&gt;DatagramChannel&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../pipe#open()&quot;&gt; &lt;code&gt;Pipe&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../selector#open()&quot;&gt; &lt;code&gt;Selector&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../serversocketchannel#open()&quot;&gt; &lt;code&gt;ServerSocketChannel&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../socketchannel#open()&quot;&gt; &lt;code&gt;SocketChannel&lt;/code&gt; &lt;/a&gt;类的静态 &lt;code&gt;open&lt;/code&gt; 方法使用系统范围的默认提供程序。&lt;a href=&quot;../../../lang/system#inheritedChannel()&quot;&gt; &lt;code&gt;System.inheritedChannel()&lt;/code&gt; &lt;/a&gt;方法也使用它。程序可以通过实例化默认提供程序，然后直接调用此类中定义的 &lt;code&gt;open&lt;/code&gt; 方法来使用默认提供程序以外的其他提供程序。</target>
        </trans-unit>
        <trans-unit id="7e7874d4b84773bdddf3caf1a22fc6b1ddcdb68c" translate="yes" xml:space="preserve">
          <source>The system-wide default provider is used by the static &lt;code&gt;open&lt;/code&gt; methods of the &lt;a href=&quot;../datagramchannel#open--&quot;&gt;&lt;code&gt;DatagramChannel&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../pipe#open--&quot;&gt;&lt;code&gt;Pipe&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../selector#open--&quot;&gt;&lt;code&gt;Selector&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../serversocketchannel#open--&quot;&gt;&lt;code&gt;ServerSocketChannel&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../socketchannel#open--&quot;&gt;&lt;code&gt;SocketChannel&lt;/code&gt;&lt;/a&gt; classes. It is also used by the &lt;a href=&quot;../../../lang/system#inheritedChannel--&quot;&gt;&lt;code&gt;System.inheritedChannel()&lt;/code&gt;&lt;/a&gt; method. A program may make use of a provider other than the default provider by instantiating that provider and then directly invoking the &lt;code&gt;open&lt;/code&gt; methods defined in this class.</source>
          <target state="translated">&lt;a href=&quot;../datagramchannel#open--&quot;&gt; &lt;code&gt;DatagramChannel&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../pipe#open--&quot;&gt; &lt;code&gt;Pipe&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../selector#open--&quot;&gt; &lt;code&gt;Selector&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../serversocketchannel#open--&quot;&gt; &lt;code&gt;ServerSocketChannel&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../socketchannel#open--&quot;&gt; &lt;code&gt;SocketChannel&lt;/code&gt; &lt;/a&gt;类的静态 &lt;code&gt;open&lt;/code&gt; 方法使用系统范围的默认提供程序。&lt;a href=&quot;../../../lang/system#inheritedChannel--&quot;&gt; &lt;code&gt;System.inheritedChannel()&lt;/code&gt; &lt;/a&gt;方法也使用它。程序可以通过实例化默认提供程序，然后直接调用此类中定义的 &lt;code&gt;open&lt;/code&gt; 方法来使用默认提供程序以外的其他提供程序。</target>
        </trans-unit>
        <trans-unit id="1854b090241392edcc60935113761df6965da7c2" translate="yes" xml:space="preserve">
          <source>The system-wide default selector provider</source>
          <target state="translated">全系统默认选择器提供者</target>
        </trans-unit>
        <trans-unit id="95bf3ad30c8dc77c99ea4e641b49758e0b289c1f" translate="yes" xml:space="preserve">
          <source>The system-wide default values are retrieved at the time the &lt;code&gt;HttpClient&lt;/code&gt; instance is constructed. Changing the system-wide values after an &lt;code&gt;HttpClient&lt;/code&gt; instance has been built, for instance, by calling &lt;a href=&quot;../../../../java.base/java/net/proxyselector#setDefault(java.net.ProxySelector)&quot;&gt;&lt;code&gt;ProxySelector.setDefault(ProxySelector)&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../../../java.base/javax/net/ssl/sslcontext#setDefault(javax.net.ssl.SSLContext)&quot;&gt;&lt;code&gt;SSLContext.setDefault(SSLContext)&lt;/code&gt;&lt;/a&gt;, has no effect on already built instances.</source>
          <target state="translated">在构造 &lt;code&gt;HttpClient&lt;/code&gt; 实例时检索系统范围的默认值。在构建 &lt;code&gt;HttpClient&lt;/code&gt; 实例之后，例如通过调用&lt;a href=&quot;../../../../java.base/java/net/proxyselector#setDefault(java.net.ProxySelector)&quot;&gt; &lt;code&gt;ProxySelector.setDefault(ProxySelector)&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../../../../java.base/javax/net/ssl/sslcontext#setDefault(javax.net.ssl.SSLContext)&quot;&gt; &lt;code&gt;SSLContext.setDefault(SSLContext)&lt;/code&gt; 来&lt;/a&gt;更改系统范围的值，对已构建的实例无效。</target>
        </trans-unit>
        <trans-unit id="b245a40ab8beba1018593de4068b70324a8a9b7f" translate="yes" xml:space="preserve">
          <source>The systemID of the Result is implementation dependent.</source>
          <target state="translated">Result的systemID取决于实现。</target>
        </trans-unit>
        <trans-unit id="03cfd5043423fd52868491470982807b0134453d" translate="yes" xml:space="preserve">
          <source>The systemID that was set with &lt;a href=&quot;#setSystemId(java.lang.String)&quot;&gt;&lt;code&gt;setSystemId(java.lang.String)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;#setSystemId(java.lang.String)&quot;&gt; &lt;code&gt;setSystemId(java.lang.String)&lt;/code&gt; &lt;/a&gt;设置的systemID 。</target>
        </trans-unit>
        <trans-unit id="a1045e7af40ef3b112d277437311ac29c399a948" translate="yes" xml:space="preserve">
          <source>The tab character (&lt;code&gt;'\u0009'&lt;/code&gt;)</source>
          <target state="translated">制表符（ &lt;code&gt;'\u0009'&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="724f41c531f5aa59b222eabf7abf5a6c43d9e2c4" translate="yes" xml:space="preserve">
          <source>The tab layout policy for wrapping tabs in multiple runs when all tabs will not fit within a single run.</source>
          <target state="translated">标签布局策略,当所有的标签页不能容纳在一个运行中时,将标签页包裹在多个运行中。</target>
        </trans-unit>
        <trans-unit id="199233d8422b6532357239677c0d77118df3b357" translate="yes" xml:space="preserve">
          <source>The tab pane</source>
          <target state="translated">标签窗格</target>
        </trans-unit>
        <trans-unit id="50f511f50ec79dac8854d97e6e1fc6b46ec9821b" translate="yes" xml:space="preserve">
          <source>The tab title can be rendered by a &lt;code&gt;Component&lt;/code&gt;. For example, the following produce similar results:</source>
          <target state="translated">选项卡标题可以由 &lt;code&gt;Component&lt;/code&gt; 呈现。例如，以下结果类似：</target>
        </trans-unit>
        <trans-unit id="70b6d74a75747576812470d4e1829a1958e25ff9" translate="yes" xml:space="preserve">
          <source>The table below defines the mapping between XML Schema 1.0 date/time datatype fields and this class' fields. It also summarizes the value constraints for the date and time fields defined in &lt;a href=&quot;http://www.w3.org/TR/xmlschema-2/#isoformats&quot;&gt;W3C XML Schema 1.0 Part 2, Appendix D, &lt;i&gt;ISO 8601 Date and Time Formats&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">下表定义了XML Schema 1.0日期/时间数据类型字段与此类的字段之间的映射。它还总结了&lt;a href=&quot;http://www.w3.org/TR/xmlschema-2/#isoformats&quot;&gt;W3C XML Schema 1.0第2部分，附录D，&lt;i&gt;ISO 8601日期和时间格式中&lt;/i&gt;&lt;/a&gt;定义的日期和时间字段的值约束。</target>
        </trans-unit>
        <trans-unit id="f62cb1c0c98a777d0a0d60bc177dbfdb331fdc8b" translate="yes" xml:space="preserve">
          <source>The table below defines the mapping between XML Schema 1.0 date/time datatype fields and this class' fields. It also summarizes the value constraints for the date and time fields defined in &lt;a href=&quot;https://www.w3.org/TR/xmlschema-2/#isoformats&quot;&gt;W3C XML Schema 1.0 Part 2, Appendix D, &lt;i&gt;ISO 8601 Date and Time Formats&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">下表定义了XML Schema 1.0日期/时间数据类型字段与此类的字段之间的映射。它还总结了&lt;a href=&quot;https://www.w3.org/TR/xmlschema-2/#isoformats&quot;&gt;W3C XML Schema 1.0第2部分，附录D，&lt;i&gt;ISO 8601日期和时间格式中&lt;/i&gt;&lt;/a&gt;定义的日期和时间字段的值约束。</target>
        </trans-unit>
        <trans-unit id="956c09a6d0ea87af6414b81e63f37ed614bbe89f" translate="yes" xml:space="preserve">
          <source>The table below lists all the printing attributes. The table shows the tagging interfaces each attribute class implements in addition to interface &lt;a href=&quot;../attribute&quot;&gt; Attribute&lt;/a&gt;, thus indicating how each attribute is used in the API. For each doc attribute and print request attribute, the column marked &quot;SupportedValuesAttribute&quot; lists the supported-values attribute class, if any, with which a print service indicates the supported values for that attribute category.</source>
          <target state="translated">下表列出了所有打印属性。该表显示了除接口&lt;a href=&quot;../attribute&quot;&gt;Attribute&lt;/a&gt;之外，每个属性类都实现的标记接口，从而指示了如何在API中使用每个属性。对于每个doc属性和打印请求属性，标记为&amp;ldquo; SupportedValuesAttribute&amp;rdquo;的列列出了受支持的值属性类（如果有的话），打印服务通过该类指示该属性类别的受支持的值。</target>
        </trans-unit>
        <trans-unit id="287f71a5c4a7b8e7e0742c0ff2ef999a33855d9e" translate="yes" xml:space="preserve">
          <source>The table below lists possible effective values if a certain capability is requested, i.e.</source>
          <target state="translated">下表列出了在请求某种能力时可能的有效值,即:</target>
        </trans-unit>
        <trans-unit id="08ad0b41961955c4da9313672d35116b01778502" translate="yes" xml:space="preserve">
          <source>The table below shows the access modes of a &lt;code&gt;Lookup&lt;/code&gt; produced by any of the following factory or transformation methods:</source>
          <target state="translated">下表显示了由以下任何工厂或转换方法产生的 &lt;code&gt;Lookup&lt;/code&gt; 的访问模式：</target>
        </trans-unit>
        <trans-unit id="cf06ceead298594cb308f75d4760c64b1d7032fe" translate="yes" xml:space="preserve">
          <source>The table below shows the effects of specifying a Chromaticity attribute of &lt;a href=&quot;#MONOCHROME&quot;&gt;&lt;code&gt;MONOCHROME&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#COLOR&quot;&gt;&lt;code&gt;COLOR&lt;/code&gt;&lt;/a&gt; for a monochrome or color document.</source>
          <target state="translated">下表显示了为单色或彩色文档指定&lt;a href=&quot;#MONOCHROME&quot;&gt; &lt;code&gt;MONOCHROME&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#COLOR&quot;&gt; &lt;code&gt;COLOR&lt;/code&gt; &lt;/a&gt;的色度属性的效果。</target>
        </trans-unit>
        <trans-unit id="93b17809af88bed6b165bc41c7cce6b651c3dd33" translate="yes" xml:space="preserve">
          <source>The table below shows the effects of specifying a Chromaticity attribute of &lt;a href=&quot;chromaticity#MONOCHROME&quot;&gt;&lt;code&gt;MONOCHROME&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;chromaticity#COLOR&quot;&gt;&lt;code&gt;COLOR&lt;/code&gt;&lt;/a&gt; for a monochrome or color document.</source>
          <target state="translated">下表显示了为单色或彩色文档指定&lt;a href=&quot;chromaticity#MONOCHROME&quot;&gt; &lt;code&gt;MONOCHROME&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;chromaticity#COLOR&quot;&gt; &lt;code&gt;COLOR&lt;/code&gt; &lt;/a&gt;的色度属性的效果。</target>
        </trans-unit>
        <trans-unit id="6550573ca0506c03709606c1bdd17da7666522cf" translate="yes" xml:space="preserve">
          <source>The table below summarizes which kind of annotation presence different methods in this interface examine.</source>
          <target state="translated">下表总结了该接口中不同方法所考察的注解存在的种类。</target>
        </trans-unit>
        <trans-unit id="0785827f1aca709e13a4cfacab1b11dec6fe1d51" translate="yes" xml:space="preserve">
          <source>The table draws horizontal lines between cells if &lt;code&gt;showHorizontalLines&lt;/code&gt; is true.</source>
          <target state="translated">如果 &lt;code&gt;showHorizontalLines&lt;/code&gt; 为true，则表格将在单元格之间绘制水平线。</target>
        </trans-unit>
        <trans-unit id="cc764edbccef2f5a651977b7ffdec182e128fba7" translate="yes" xml:space="preserve">
          <source>The table draws vertical lines between cells if &lt;code&gt;showVerticalLines&lt;/code&gt; is true.</source>
          <target state="translated">如果 &lt;code&gt;showVerticalLines&lt;/code&gt; 为true，则该表将在单元格之间绘制垂直线。</target>
        </trans-unit>
        <trans-unit id="d46376b57361e34cc862402a3ff75bfa5957b99c" translate="yes" xml:space="preserve">
          <source>The table for which this object is the header; the default is &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">该对象为其标题的表；默认值为 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="affe517f34332866171ca57d9e9e5b23870e7f83" translate="yes" xml:space="preserve">
          <source>The table is dynamically expanded when there are too many collisions (i.e., keys that have distinct hash codes but fall into the same slot modulo the table size), with the expected average effect of maintaining roughly two bins per mapping (corresponding to a 0.75 load factor threshold for resizing). There may be much variance around this average as mappings are added and removed, but overall, this maintains a commonly accepted time/space tradeoff for hash tables. However, resizing this or any other kind of hash table may be a relatively slow operation. When possible, it is a good idea to provide a size estimate as an optional &lt;code&gt;
 initialCapacity&lt;/code&gt; constructor argument. An additional optional &lt;code&gt;loadFactor&lt;/code&gt; constructor argument provides a further means of customizing initial table capacity by specifying the table density to be used in calculating the amount of space to allocate for the given number of elements. Also, for compatibility with previous versions of this class, constructors may optionally specify an expected &lt;code&gt;concurrencyLevel&lt;/code&gt; as an additional hint for internal sizing. Note that using many keys with exactly the same &lt;code&gt;hashCode()&lt;/code&gt; is a sure way to slow down performance of any hash table. To ameliorate impact, when keys are &lt;a href=&quot;../../lang/comparable&quot;&gt;&lt;code&gt;Comparable&lt;/code&gt;&lt;/a&gt;, this class may use comparison order among keys to help break ties.</source>
          <target state="translated">当冲突太多时（即，键具有不同的哈希码但以表大小为模落入相同的槽中），表将被动态扩展，预期的平均效果是每个映射大约维护两个bin（对应于0.75负载）调整大小的系数阈值）。添加和删​​除映射时，此平均值附近可能会有很大的差异，但是总的来说，这保持了哈希表通常接受的时间/空间权衡。但是，调整此哈希表或任何其他种类的哈希表的大小可能是一个相对较慢的操作。如果可能，最好将大小估计值作为可选的 &lt;code&gt; initialCapacity&lt;/code&gt; 构造函数参数提供。附加的可选 &lt;code&gt;loadFactor&lt;/code&gt; 构造函数自变量提供了另一种自定义初始表容量的方法，方法是指定表密度，该密度将用于计算为给定数量的元素分配的空间量。另外，为了与此类的早期版本兼容，构造函数可以选择指定期望的 &lt;code&gt;concurrencyLevel&lt;/code&gt; 作为内部调整的附加提示。请注意，使用许多具有完全相同的 &lt;code&gt;hashCode()&lt;/code&gt; 的键是降低任何哈希表性能的肯定方法。为了改善影响，当键为&lt;a href=&quot;../../lang/comparable&quot;&gt; &lt;code&gt;Comparable&lt;/code&gt; 时&lt;/a&gt;，此类可以使用键之间的比较顺序来帮助打破平局。</target>
        </trans-unit>
        <trans-unit id="abdfbcd8569ed822dbb9b0566e80bdcdfb0ce663" translate="yes" xml:space="preserve">
          <source>The table is dynamically expanded when there are too many collisions (i.e., keys that have distinct hash codes but fall into the same slot modulo the table size), with the expected average effect of maintaining roughly two bins per mapping (corresponding to a 0.75 load factor threshold for resizing). There may be much variance around this average as mappings are added and removed, but overall, this maintains a commonly accepted time/space tradeoff for hash tables. However, resizing this or any other kind of hash table may be a relatively slow operation. When possible, it is a good idea to provide a size estimate as an optional &lt;code&gt;initialCapacity&lt;/code&gt; constructor argument. An additional optional &lt;code&gt;loadFactor&lt;/code&gt; constructor argument provides a further means of customizing initial table capacity by specifying the table density to be used in calculating the amount of space to allocate for the given number of elements. Also, for compatibility with previous versions of this class, constructors may optionally specify an expected &lt;code&gt;concurrencyLevel&lt;/code&gt; as an additional hint for internal sizing. Note that using many keys with exactly the same &lt;code&gt;hashCode()&lt;/code&gt; is a sure way to slow down performance of any hash table. To ameliorate impact, when keys are &lt;a href=&quot;../../lang/comparable&quot;&gt;&lt;code&gt;Comparable&lt;/code&gt;&lt;/a&gt;, this class may use comparison order among keys to help break ties.</source>
          <target state="translated">当冲突太多时（即，键具有不同的哈希码但以表大小为模落入相同的槽中），表将被动态扩展，并且预期的平均效果是每个映射大约维护两个bin（对应于0.75负载）调整大小的系数阈值）。添加和删​​除映射时，此平均值附近可能会有很大的差异，但是总的来说，这保持了哈希表的公认的时间/空间权衡。但是，调整此哈希表或任何其他种类的哈希表的大小可能是一个相对较慢的操作。在可能的情况下，最好将大小估计值作为可选的 &lt;code&gt;initialCapacity&lt;/code&gt; 构造函数参数提供。附加的可选 &lt;code&gt;loadFactor&lt;/code&gt; 构造函数自变量提供了另一种自定义初始表容量的方法，方法是指定表密度，该密度将用于计算为给定数量的元素分配的空间量。另外，为了与此类的早期版本兼容，构造函数可以选择指定期望的 &lt;code&gt;concurrencyLevel&lt;/code&gt; 作为内部调整的附加提示。请注意，使用许多具有完全相同的 &lt;code&gt;hashCode()&lt;/code&gt; 的键是降低任何哈希表性能的肯定方法。为了改善影响，当键为&lt;a href=&quot;../../lang/comparable&quot;&gt; &lt;code&gt;Comparable&lt;/code&gt; 时&lt;/a&gt;，此类可以使用键之间的比较顺序来帮助打破平局。</target>
        </trans-unit>
        <trans-unit id="807c7f2278f08fd9a560612599a053ac4a77aa0b" translate="yes" xml:space="preserve">
          <source>The table of key properties.</source>
          <target state="translated">关键属性表。</target>
        </trans-unit>
        <trans-unit id="29c2e665a3b18a1ce29ba700eb12bfe8ef2d57b7" translate="yes" xml:space="preserve">
          <source>The table type is:</source>
          <target state="translated">该表的类型是:</target>
        </trans-unit>
        <trans-unit id="e72d6ec95379480e6ddcff8a30f3ae018d25f5a5" translate="yes" xml:space="preserve">
          <source>The table will query the &lt;code&gt;TableModel&lt;/code&gt; to build the default set of columns if this is true.</source>
          <target state="translated">如果为真，则表将查询 &lt;code&gt;TableModel&lt;/code&gt; 来构建默认的列集。</target>
        </trans-unit>
        <trans-unit id="4b683043db5214bb3bb29c225b881df7d62a7411" translate="yes" xml:space="preserve">
          <source>The tag number.</source>
          <target state="translated">标签号。</target>
        </trans-unit>
        <trans-unit id="e3034177648d7a592ed4b995252076ff2a379e97" translate="yes" xml:space="preserve">
          <source>The tag values for this property. May be null if this property cannot be represented as a tagged value.</source>
          <target state="translated">此属性的标签值。如果此属性不能以标签值表示,则可能为空。</target>
        </trans-unit>
        <trans-unit id="b446899d309ae9229be1541a42b9d0cf00a0ac6b" translate="yes" xml:space="preserve">
          <source>The target and cleanup must return the same type, even if the cleanup always throws. To create such a throwing cleanup, compose the cleanup logic with &lt;a href=&quot;#throwException(java.lang.Class,java.lang.Class)&quot;&gt;&lt;code&gt;throwException&lt;/code&gt;&lt;/a&gt;, in order to create a method handle of the correct return type.</source>
          <target state="translated">即使清除总是抛出，目标和清除也必须返回相同的类型。要创建这样的引发清除，请使用&lt;a href=&quot;#throwException(java.lang.Class,java.lang.Class)&quot;&gt; &lt;code&gt;throwException&lt;/code&gt; &lt;/a&gt;组成清除逻辑，以便创建正确返回类型的方法句柄。</target>
        </trans-unit>
        <trans-unit id="02cefdef6f6fd1cf2781c5dd156f06c3b67ffe8b" translate="yes" xml:space="preserve">
          <source>The target and fallback must be of exactly the same method type, and the resulting combined method handle will also be of this type.</source>
          <target state="translated">目标和回落必须是完全相同的方法类型,而产生的组合方法句柄也将是这种类型。</target>
        </trans-unit>
        <trans-unit id="f42cc55413084526e1a3b93e74bf70c3317cb6fa" translate="yes" xml:space="preserve">
          <source>The target and handler must have the same corresponding argument and return types, except that handler may omit trailing arguments (similarly to the predicate in &lt;a href=&quot;#guardWithTest(java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle)&quot;&gt;&lt;code&gt;guardWithTest&lt;/code&gt;&lt;/a&gt;). Also, the handler must have an extra leading parameter of &lt;code&gt;exType&lt;/code&gt; or a supertype.</source>
          <target state="translated">目标和处理程序必须具有相同的对应参数和返回类型，不同之处在于处理程序可以省略尾随参数（类似于&lt;a href=&quot;#guardWithTest(java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle)&quot;&gt; &lt;code&gt;guardWithTest&lt;/code&gt; 中&lt;/a&gt;的谓词）。此外，处理程序还必须具有 &lt;code&gt;exType&lt;/code&gt; 或超类型的额外前导参数。</target>
        </trans-unit>
        <trans-unit id="cfe18dce3e23910cc798ebbf8a13a2dd958ea48f" translate="yes" xml:space="preserve">
          <source>The target and handler must have the same corresponding argument and return types, except that handler may omit trailing arguments (similarly to the predicate in &lt;a href=&quot;methodhandles#guardWithTest-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-&quot;&gt;&lt;code&gt;guardWithTest&lt;/code&gt;&lt;/a&gt;). Also, the handler must have an extra leading parameter of &lt;code&gt;exType&lt;/code&gt; or a supertype.</source>
          <target state="translated">目标和处理程序必须具有相同的对应参数和返回类型，但处理程序可以省略尾随参数（类似于&lt;a href=&quot;methodhandles#guardWithTest-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-&quot;&gt; &lt;code&gt;guardWithTest&lt;/code&gt; 中&lt;/a&gt;的谓词）。此外，处理程序还必须具有 &lt;code&gt;exType&lt;/code&gt; 或超类型的额外前导参数。</target>
        </trans-unit>
        <trans-unit id="e01418ac4cb37a5ae8fb9a819eaaca5266eb99c3" translate="yes" xml:space="preserve">
          <source>The target and handler must return the same type, even if the handler always throws. (This might happen, for instance, because the handler is simulating a &lt;code&gt;finally&lt;/code&gt; clause). To create such a throwing handler, compose the handler creation logic with &lt;a href=&quot;#throwException(java.lang.Class,java.lang.Class)&quot;&gt;&lt;code&gt;throwException&lt;/code&gt;&lt;/a&gt;, in order to create a method handle of the correct return type.</source>
          <target state="translated">即使处理程序总是抛出异常，目标和处理程序也必须返回相同的类型。（例如，这可能发生，因为处理程序正在模拟 &lt;code&gt;finally&lt;/code&gt; 子句）。要创建这样的抛出处理程序，请使用&lt;a href=&quot;#throwException(java.lang.Class,java.lang.Class)&quot;&gt; &lt;code&gt;throwException&lt;/code&gt; &lt;/a&gt;组合处理程序创建逻辑，以便创建正确返回类型的方法句柄。</target>
        </trans-unit>
        <trans-unit id="44e11701adb06063c652521aa85aae71912799bf" translate="yes" xml:space="preserve">
          <source>The target and handler must return the same type, even if the handler always throws. (This might happen, for instance, because the handler is simulating a &lt;code&gt;finally&lt;/code&gt; clause). To create such a throwing handler, compose the handler creation logic with &lt;a href=&quot;methodhandles#throwException-java.lang.Class-java.lang.Class-&quot;&gt;&lt;code&gt;throwException&lt;/code&gt;&lt;/a&gt;, in order to create a method handle of the correct return type.</source>
          <target state="translated">即使处理程序总是抛出异常，目标和处理程序也必须返回相同的类型。（例如，这可能会发生，因为处理程序正在模拟 &lt;code&gt;finally&lt;/code&gt; 子句）。要创建这样的抛出处理程序，请使用&lt;a href=&quot;methodhandles#throwException-java.lang.Class-java.lang.Class-&quot;&gt; &lt;code&gt;throwException&lt;/code&gt; &lt;/a&gt;组合处理程序创建逻辑，以创建正确返回类型的方法句柄。</target>
        </trans-unit>
        <trans-unit id="a4a57d45fa595fa9efff16f036716b6ca28a789a" translate="yes" xml:space="preserve">
          <source>The target class must be a proper class, not a primitive or array class. (Thus, &lt;code&gt;M2&lt;/code&gt; is well-defined.)</source>
          <target state="translated">目标类必须是适当的类，而不是原始或数组类。（因此， &lt;code&gt;M2&lt;/code&gt; 定义明确。）</target>
        </trans-unit>
        <trans-unit id="6331eb65cfaeb17d610de47a1492d63404554822" translate="yes" xml:space="preserve">
          <source>The target component.</source>
          <target state="translated">目标部分。</target>
        </trans-unit>
        <trans-unit id="a48909c6d391288fca7020961e9c52b23bc4c69d" translate="yes" xml:space="preserve">
          <source>The target component. This indicates the component over which the event occurred or with which the event is associated. This object has been replaced by AWTEvent.getSource()</source>
          <target state="translated">目标组件。这表示事件发生的组件或与事件相关联的组件。该对象已被AWTEvent.getSource()取代。</target>
        </trans-unit>
        <trans-unit id="41cfd1c3c3da57cda5880021b389e8ff6e52178e" translate="yes" xml:space="preserve">
          <source>The target data line can be obtained from a mixer by invoking the &lt;a href=&quot;mixer#getLine(javax.sound.sampled.Line.Info)&quot;&gt;&lt;code&gt;getLine&lt;/code&gt;&lt;/a&gt; method of &lt;code&gt;Mixer&lt;/code&gt; with an appropriate &lt;a href=&quot;dataline.info&quot;&gt;&lt;code&gt;DataLine.Info&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">通过使用适当的&lt;a href=&quot;dataline.info&quot;&gt; &lt;code&gt;DataLine.Info&lt;/code&gt; &lt;/a&gt;对象调用 &lt;code&gt;Mixer&lt;/code&gt; 的&lt;a href=&quot;mixer#getLine(javax.sound.sampled.Line.Info)&quot;&gt; &lt;code&gt;getLine&lt;/code&gt; &lt;/a&gt;方法，可以从混合器获得目标数据线。</target>
        </trans-unit>
        <trans-unit id="294becfa926713ae4f4611aad1c89088d4f17efe" translate="yes" xml:space="preserve">
          <source>The target data line can be obtained from a mixer by invoking the &lt;code&gt;&lt;a href=&quot;mixer#getLine-javax.sound.sampled.Line.Info-&quot;&gt;&lt;code&gt;getLine&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; method of &lt;code&gt;Mixer&lt;/code&gt; with an appropriate &lt;code&gt;&lt;a href=&quot;dataline.info&quot;&gt;&lt;code&gt;DataLine.Info&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; object.</source>
          <target state="translated">通过使用适当的 &lt;code&gt;&lt;a href=&quot;dataline.info&quot;&gt;&lt;code&gt;DataLine.Info&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; 对象调用 &lt;code&gt;Mixer&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;mixer#getLine-javax.sound.sampled.Line.Info-&quot;&gt;&lt;code&gt;getLine&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; 方法，可以从混合器中获取目标数据线。</target>
        </trans-unit>
        <trans-unit id="2e92be738dd320065c504e7c597383304da41f9b" translate="yes" xml:space="preserve">
          <source>The target format represents the format of the processed, converted audio data. This is the format of the data that can be read from the stream returned by one of the &lt;code&gt;getAudioInputStream&lt;/code&gt; methods.</source>
          <target state="translated">目标格式表示已处理的已转换音频数据的格式。这是可以从 &lt;code&gt;getAudioInputStream&lt;/code&gt; 方法之一返回的流中读取的数据格式。</target>
        </trans-unit>
        <trans-unit id="e7de801befb3afea6c0cedebce5ac02cc3cf8db7" translate="yes" xml:space="preserve">
          <source>The target handle has the parameter type list &lt;code&gt;S..., M...&lt;/code&gt;, with as many types in &lt;code&gt;S&lt;/code&gt; as indicated by &lt;code&gt;skip&lt;/code&gt;. The &lt;code&gt;M&lt;/code&gt; types are those that are supposed to match part of the given type list, &lt;code&gt;newTypes&lt;/code&gt;.</source>
          <target state="translated">目标句柄的参数类型列表为 &lt;code&gt;S..., M...&lt;/code&gt; ，其中 &lt;code&gt;S&lt;/code&gt; 中的类型与 &lt;code&gt;skip&lt;/code&gt; 所指示的一样多。在 &lt;code&gt;M&lt;/code&gt; 类型是那些应该匹配给定类型列表中，一部分 &lt;code&gt;newTypes&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="03b0fb3903bf8315a0952c04b4865416cb3c9b29" translate="yes" xml:space="preserve">
          <source>The target height to scale the image.</source>
          <target state="translated">缩放图像的目标高度。</target>
        </trans-unit>
        <trans-unit id="61ee1882c6fbd7985ddaac74fcc91b429f418e8c" translate="yes" xml:space="preserve">
          <source>The target name is of the form &quot;&lt;code&gt;className#member[objectName]&lt;/code&gt;&quot; where each part is optional. It must not be empty or null.</source>
          <target state="translated">目标名称的格式为&amp;ldquo; &lt;code&gt;className#member[objectName]&lt;/code&gt; &amp;rdquo;，其中每个部分都是可选的。它不能为空或为空。</target>
        </trans-unit>
        <trans-unit id="2088b56d56c4f4d92fcefb476718d183cc8ee0fb" translate="yes" xml:space="preserve">
          <source>The target name is the &lt;a href=&quot;inquiretype&quot;&gt;&lt;code&gt;InquireType&lt;/code&gt;&lt;/a&gt; allowed.</source>
          <target state="translated">目标名称是允许的&lt;a href=&quot;inquiretype&quot;&gt; &lt;code&gt;InquireType&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ce62a8e103e81312eae100e20ed400ca3da9c713" translate="yes" xml:space="preserve">
          <source>The target name is the name of a security configuration parameter (see below). Currently the &lt;code&gt;AuthPermission&lt;/code&gt; object is used to guard access to the &lt;a href=&quot;subject&quot;&gt;&lt;code&gt;Subject&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;login/logincontext&quot;&gt;&lt;code&gt;LoginContext&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;login/configuration&quot;&gt;&lt;code&gt;Configuration&lt;/code&gt;&lt;/a&gt; objects.</source>
          <target state="translated">目标名称是安全性配置参数的名称（请参见下文）。当前， &lt;code&gt;AuthPermission&lt;/code&gt; 对象用于保护对&lt;a href=&quot;subject&quot;&gt; &lt;code&gt;Subject&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;login/logincontext&quot;&gt; &lt;code&gt;LoginContext&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;login/configuration&quot;&gt; &lt;code&gt;Configuration&lt;/code&gt; &lt;/a&gt;对象的访问。</target>
        </trans-unit>
        <trans-unit id="c855fc5f9080ecc03acfbcb7e0983b870dcc2a70" translate="yes" xml:space="preserve">
          <source>The target name is the name of a security configuration parameter (see below). Currently the &lt;code&gt;SecurityPermission&lt;/code&gt; object is used to guard access to the &lt;a href=&quot;accesscontrolcontext&quot;&gt;&lt;code&gt;AccessControlContext&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;policy&quot;&gt;&lt;code&gt;Policy&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;provider&quot;&gt;&lt;code&gt;Provider&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;security&quot;&gt;&lt;code&gt;Security&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;signer&quot;&gt;&lt;code&gt;Signer&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;identity&quot;&gt;&lt;code&gt;Identity&lt;/code&gt;&lt;/a&gt; objects.</source>
          <target state="translated">目标名称是安全性配置参数的名称（请参见下文）。当前， &lt;code&gt;SecurityPermission&lt;/code&gt; 对象用于保护对&lt;a href=&quot;accesscontrolcontext&quot;&gt; &lt;code&gt;AccessControlContext&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;policy&quot;&gt; &lt;code&gt;Policy&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;provider&quot;&gt; &lt;code&gt;Provider&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;security&quot;&gt; &lt;code&gt;Security&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;signer&quot;&gt; &lt;code&gt;Signer&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;identity&quot;&gt; &lt;code&gt;Identity&lt;/code&gt; &lt;/a&gt;对象的访问。</target>
        </trans-unit>
        <trans-unit id="7928d48cbde0bd5806a16e749b843ab056e2bff2" translate="yes" xml:space="preserve">
          <source>The target name is the name of a security configuration parameter (see below). Currently the AuthPermission object is used to guard access to the Policy, Subject, LoginContext, and Configuration objects.</source>
          <target state="translated">目标名称是安全配置参数的名称(见下文)。目前,AuthPermission对象用于保护对Policy、Subject、LoginContext和Configuration对象的访问。</target>
        </trans-unit>
        <trans-unit id="2890f709a91749b2fe10e52fd580bddb149e0444" translate="yes" xml:space="preserve">
          <source>The target name is the name of a security configuration parameter (see below). Currently the SecurityPermission object is used to guard access to the Policy, Security, Provider, Signer, and Identity objects.</source>
          <target state="translated">目标名称是一个安全配置参数的名称(见下文)。目前,SecurityPermission对象用于保护对Policy、Security、Provider、Signer和Identity对象的访问。</target>
        </trans-unit>
        <trans-unit id="17f38fb0c6986e5e7a83073a2ad1774730542b07" translate="yes" xml:space="preserve">
          <source>The target name is the name of the AWT permission (see below). The naming convention follows the hierarchical property naming convention. Also, an asterisk could be used to represent all AWT permissions.</source>
          <target state="translated">目标名称是AWT权限的名称(见下文)。命名惯例遵循层次化的属性命名惯例。另外,一个星号也可以用来代表所有AWT权限。</target>
        </trans-unit>
        <trans-unit id="9e139ec2f3c65e0160a69e0966a9e12f3721fc07" translate="yes" xml:space="preserve">
          <source>The target name is the name of the Serializable permission (see below).</source>
          <target state="translated">目标名称是可序列化权限的名称(见下文)。</target>
        </trans-unit>
        <trans-unit id="1d4510b6174912a740c895643371245def2a4d9e" translate="yes" xml:space="preserve">
          <source>The target name is the name of the audio permission (see the table below). The names follow the hierarchical property-naming convention. Also, an asterisk can be used to represent all the audio permissions.</source>
          <target state="translated">目标名称是音频权限的名称(见下表)。这些名称遵循层次化的属性命名惯例。此外,还可以用星号来表示所有的音频权限。</target>
        </trans-unit>
        <trans-unit id="d8645249d279e7c3cf29a83a9b3bb1e507d282b4" translate="yes" xml:space="preserve">
          <source>The target name is the name of the authorization principal classname followed by a period and the authorization principal name, that is &lt;code&gt;&quot;&lt;em&gt;PrincipalClassName&lt;/em&gt;.&lt;em&gt;PrincipalName&lt;/em&gt;&quot;&lt;/code&gt;.</source>
          <target state="translated">目标名称是授权主要类名后跟一个句点和所述授权主体名称，即名称 &lt;code&gt;&quot;&lt;em&gt;PrincipalClassName&lt;/em&gt;.&lt;em&gt;PrincipalName&lt;/em&gt;&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1de21a429ece939c67b7e50829885099ad2d45eb" translate="yes" xml:space="preserve">
          <source>The target name is the name of the network permission (see below). The naming convention follows the hierarchical property naming convention. Also, an asterisk may appear at the end of the name, following a &quot;.&quot;, or by itself, to signify a wildcard match. For example: &quot;foo.*&quot; and &quot;*&quot; signify a wildcard match, while &quot;*foo&quot; and &quot;a*b&quot; do not.</source>
          <target state="translated">目标名称是网络权限的名称(见下文)。命名惯例遵循层次化的属性命名惯例。另外,在名称的结尾处可以出现一个星号,跟在&quot;.&quot;后面,也可以单独出现,以表示通配符匹配。例如:&quot;foo.*&quot;和 &quot;foo.*&quot;。&quot;foo.*&quot;和 &quot;*&quot;表示通配符,而 &quot;*foo &quot;和 &quot;a*b &quot;则不表示通配符。</target>
        </trans-unit>
        <trans-unit id="35aa664b77bc8ac5af633fd3abfe001e77f837cd" translate="yes" xml:space="preserve">
          <source>The target name is the name of the runtime permission (see below). The naming convention follows the hierarchical property naming convention. Also, an asterisk may appear at the end of the name, following a &quot;.&quot;, or by itself, to signify a wildcard match. For example: &quot;loadLibrary.*&quot; and &quot;*&quot; signify a wildcard match, while &quot;*loadLibrary&quot; and &quot;a*b&quot; do not.</source>
          <target state="translated">目标名称是运行时权限的名称(见下文)。命名惯例遵循分级属性命名惯例。另外,在名称的结尾处可以出现一个星号,跟在&quot;.&quot;后面,也可以单独出现,以表示通配符的匹配。例如:&quot;loadLibrary.*&quot;和&quot;:&quot;loadLibrary.*&quot;和 &quot;*&quot;表示通配符,而 &quot;*loadLibrary &quot;和 &quot;a*b &quot;则不表示通配符。</target>
        </trans-unit>
        <trans-unit id="d958abd00740d8b81aa7e7e8a7237d717e401b13" translate="yes" xml:space="preserve">
          <source>The target name of this &lt;code&gt;Permission&lt;/code&gt; specifies a Credential class name, and a Set of Principals. The only valid value for this Permission's actions is, &quot;read&quot;. The target name must abide by the following syntax:</source>
          <target state="translated">此 &lt;code&gt;Permission&lt;/code&gt; 的目标名称指定凭据类名称和一组主体。此权限操作的唯一有效值为&amp;ldquo;读取&amp;rdquo;。目标名称必须遵守以下语法：</target>
        </trans-unit>
        <trans-unit id="91a399d1980f8a6ccc96217289bf0be48ee37eb6" translate="yes" xml:space="preserve">
          <source>The target name of this &lt;code&gt;Permission&lt;/code&gt; specifies a pair of kerberos service principals. The first is the subordinate service principal being entrusted to use the TGT. The second service principal designates the target service the subordinate service principal is to interact with on behalf of the initiating KerberosPrincipal. This latter service principal is specified to restrict the use of a proxiable ticket.</source>
          <target state="translated">此 &lt;code&gt;Permission&lt;/code&gt; 的目标名称指定一对kerberos服务主体。第一个是下级服务主体被委托使用TGT。第二个服务主体指定目标服务，下级服务主体将代表发起的KerberosPrincipal与之进行交互。指定后者的服务主体是为了限制可使用票证的使用。</target>
        </trans-unit>
        <trans-unit id="a69bc10fa3486dc0c871c21c9260fdc72fa60465" translate="yes" xml:space="preserve">
          <source>The target of the symbolic link</source>
          <target state="translated">符号链接的目标</target>
        </trans-unit>
        <trans-unit id="2c722da0815ce9e96b3f893e4617b9ba63277f4a" translate="yes" xml:space="preserve">
          <source>The target of this processing instruction.</source>
          <target state="translated">本处理指令的目标。</target>
        </trans-unit>
        <trans-unit id="161ea52ef7deec6ab2b397da40779879d17b9eba" translate="yes" xml:space="preserve">
          <source>The target of this processing instruction. XML defines this as being the first token following the markup that begins the processing instruction.</source>
          <target state="translated">这个处理指令的目标。XML将其定义为开始处理指令的标记后的第一个标记。</target>
        </trans-unit>
        <trans-unit id="0fba2a96aca3512f3b2fa2ec8c997febf4ea99a4" translate="yes" xml:space="preserve">
          <source>The target property may also be &quot;qualified&quot; with an arbitrary number of property prefixs delimited with the &quot;.&quot; character. For example, the following action listener:</source>
          <target state="translated">目标属性也可以用任意数量的用&quot;.&quot;字符分隔的属性前缀来 &quot;限定&quot;。例如,下面的动作监听器。</target>
        </trans-unit>
        <trans-unit id="1d3891a04d782b20001436f81be88566164c49f9" translate="yes" xml:space="preserve">
          <source>The target screen mentioned below is a screen to which the window should be placed after the setLocationRelativeTo method is called.</source>
          <target state="translated">下面提到的目标画面是指调用setLocationRelativeTo方法后,窗口应该放置到的画面。</target>
        </trans-unit>
        <trans-unit id="c97110c6e47104527f8b4580cb3b4fa2f5426ed0" translate="yes" xml:space="preserve">
          <source>The target section of the processing instruction</source>
          <target state="translated">处理指令的目标部分</target>
        </trans-unit>
        <trans-unit id="8a356eae8e68f37248d1a45a231f374ef9c3a79c" translate="yes" xml:space="preserve">
          <source>The target string buffer</source>
          <target state="translated">目标字符串缓冲区</target>
        </trans-unit>
        <trans-unit id="ce314a2a38875a9da27cad30daa60b7f939567ca" translate="yes" xml:space="preserve">
          <source>The target string builder</source>
          <target state="translated">目标字符串生成器</target>
        </trans-unit>
        <trans-unit id="5623b00860faa00ef9ff1fd5929f824daae38f10" translate="yes" xml:space="preserve">
          <source>The target virtual machine can maintain a list of properties on behalf of agents. The manner in which this is done, the names of the properties, and the types of values that are allowed, is implementation specific. Agent properties are typically used to store communication end-points and other agent configuration details. For example, a debugger agent might create an agent property for its transport address.</source>
          <target state="translated">目标虚拟机可以代表代理维护一个属性列表。完成这一工作的方式、属性的名称以及允许的值的类型是特定于实现的。代理属性通常用于存储通信端点和其他代理配置细节。例如,一个调试器代理可以为其传输地址创建一个代理属性。</target>
        </trans-unit>
        <trans-unit id="90b7bab6e96d93a1672aed421456af62833a888b" translate="yes" xml:space="preserve">
          <source>The target width to scale the image.</source>
          <target state="translated">要缩放图像的目标宽度。</target>
        </trans-unit>
        <trans-unit id="0a63b487811a4aecdd285055ad083a6242c879eb" translate="yes" xml:space="preserve">
          <source>The task is &lt;a href=&quot;future#cancel(boolean)&quot;&gt;explicitly cancelled&lt;/a&gt; via the returned future.</source>
          <target state="translated">该任务通过返回的Future&lt;a href=&quot;future#cancel(boolean)&quot;&gt;显式取消&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ac13bf867264e56e3d64038eb74fe1bea028918f" translate="yes" xml:space="preserve">
          <source>The tc &lt;b&gt;must&lt;/b&gt; be in the range &lt;code&gt;0 &amp;lt;= tc &amp;lt;=
 255&lt;/code&gt; or an IllegalArgumentException will be thrown.</source>
          <target state="translated">tc &lt;b&gt;必须&lt;/b&gt;在 &lt;code&gt;0 &amp;lt;= tc &amp;lt;= 255&lt;/code&gt; 范围内，否则将抛出IllegalArgumentException。</target>
        </trans-unit>
        <trans-unit id="351d171d0044484a95b6580add4a8d56a0b09177" translate="yes" xml:space="preserve">
          <source>The tempo-based timing type, for which the resolution is expressed in pulses (ticks) per quarter note.</source>
          <target state="translated">基于速度的计时类型,其分辨率以每个四分音符的脉冲(ticks)表示。</target>
        </trans-unit>
        <trans-unit id="92a16bca2794be2e4d981e961e77157c978a16e0" translate="yes" xml:space="preserve">
          <source>The term &quot;blit&quot; is the pronounced version of the PDP-10 BLT (BLock Transfer) instruction, which copied a block of bits. (In case you were curious.)</source>
          <target state="translated">&quot;blit &quot;一词是PDP-10 BLT(BLock Transfer)指令的发音版本,它复制了一个比特块。以防你好奇)。</target>
        </trans-unit>
        <trans-unit id="f2ec5ccb70e544f59fa930934598819b7960048f" translate="yes" xml:space="preserve">
          <source>The terms &lt;em&gt;directly present&lt;/em&gt;, &lt;em&gt;indirectly present&lt;/em&gt;, &lt;em&gt;present&lt;/em&gt;, and &lt;em&gt;associated&lt;/em&gt; are used throughout this interface to describe precisely which annotations are returned by methods:</source>
          <target state="translated">在整个界面中使用&lt;em&gt;直接呈现&lt;/em&gt;，&lt;em&gt;间接呈现&lt;/em&gt;，&lt;em&gt;呈现&lt;/em&gt;和&lt;em&gt;关联&lt;/em&gt;的术语来精确描述方法返回的注释：</target>
        </trans-unit>
        <trans-unit id="7bc919453997f5f639ef67c31f748841da8f874b" translate="yes" xml:space="preserve">
          <source>The text attributes.</source>
          <target state="translated">文本属性。</target>
        </trans-unit>
        <trans-unit id="5e5bbe231cb2211cfe2a7c06f4bc2ee771bc88c2" translate="yes" xml:space="preserve">
          <source>The text boundary returned from the above methods, first or last text boundary.</source>
          <target state="translated">以上方法返回的文本边界,第一个或最后一个文本边界。</target>
        </trans-unit>
        <trans-unit id="8858d11b87b0f0a3e19ee86a888321a1258f017b" translate="yes" xml:space="preserve">
          <source>The text components have a model-view split. A text component pulls together the objects used to represent the model, view, and controller. The text document model may be shared by other views which act as observers of the model (e.g. a document may be shared by multiple components).</source>
          <target state="translated">文本组件有一个模型-视图分割。文本组件将用于表示模型、视图和控制器的对象拉在一起。文本文档模型可以被作为模型观察者的其他视图共享(例如,一个文档可以被多个组件共享)。</target>
        </trans-unit>
        <trans-unit id="9f88b97ebbe499c00fc788624ded865b62c2d07e" translate="yes" xml:space="preserve">
          <source>The text components support flexible and internationalized text input, using keymaps and the input method framework, while maintaining compatibility with the AWT listener model.</source>
          <target state="translated">文本组件支持灵活的和国际化的文本输入,使用键盘映射和输入法框架,同时保持与AWT监听器模型的兼容性。</target>
        </trans-unit>
        <trans-unit id="535d6291a5e7978acac55699afbcc43c1abcfcca" translate="yes" xml:space="preserve">
          <source>The text contained within the option element.</source>
          <target state="translated">选项元素中包含的文本。</target>
        </trans-unit>
        <trans-unit id="bb4bc96683614ed09586bda7da975dbd546cc010" translate="yes" xml:space="preserve">
          <source>The text cursor type.</source>
          <target state="translated">文本光标类型。</target>
        </trans-unit>
        <trans-unit id="792c37abc4943eebd3bef907dbd09262f47b21d8" translate="yes" xml:space="preserve">
          <source>The text editing component also has to provide an input method event listener.</source>
          <target state="translated">文本编辑组件还必须提供一个输入法事件监听器。</target>
        </trans-unit>
        <trans-unit id="68f58f74d3780f9460b9207f3ef04661f0ea9185" translate="yes" xml:space="preserve">
          <source>The text editing component also has to provide an instance of InputMethodRequests.</source>
          <target state="translated">文本编辑组件还必须提供一个InputMethodRequests的实例。</target>
        </trans-unit>
        <trans-unit id="abe46b84ee53a236c2700231fa5bd7581d2fd49f" translate="yes" xml:space="preserve">
          <source>The text included with the input method event consists of two parts: committed text and composed text. Either part may be empty. The two parts together replace any uncommitted composed text sent in previous events, or the currently selected committed text. Committed text should be integrated into the text component's persistent data, it will not be sent again. Composed text may be sent repeatedly, with changes to reflect the user's editing operations. Committed text always precedes composed text.</source>
          <target state="translated">输入法事件中包含的文本由两部分组成:提交的文本和组成的文本。任何一部分都可以是空的。这两部分一起替换之前事件中发送的任何未提交的组成文本,或者当前选择的提交文本。已提交的文本应整合到文本组件的持久化数据中,它将不会被再次发送。组成文本可以重复发送,并根据用户的编辑操作进行修改。承诺文本总是在合成文本之前。</target>
        </trans-unit>
        <trans-unit id="1899b3e37537fc1d6b9f560d72d02ead7717a9d2" translate="yes" xml:space="preserve">
          <source>The text is parsed using the formatter, returning a date-time.</source>
          <target state="translated">使用formatter对文本进行解析,返回一个日期-时间。</target>
        </trans-unit>
        <trans-unit id="119fbb383bccf4eac0375adfb016d1b3f8304e40" translate="yes" xml:space="preserve">
          <source>The text is parsed using the formatter, returning a date.</source>
          <target state="translated">使用格式器对文本进行解析,返回一个日期。</target>
        </trans-unit>
        <trans-unit id="fc611f16d1b6999b1ff7fa074c651bc88768faa1" translate="yes" xml:space="preserve">
          <source>The text is parsed using the formatter, returning a month-day.</source>
          <target state="translated">使用格式器对文本进行解析,返回月日。</target>
        </trans-unit>
        <trans-unit id="2408a1b2fa16fded0ccd21134505f7a2dfa87a20" translate="yes" xml:space="preserve">
          <source>The text is parsed using the formatter, returning a time.</source>
          <target state="translated">使用格式器对文本进行解析,返回一个时间。</target>
        </trans-unit>
        <trans-unit id="8aa28741c1cf5a7ab0d06ececd2ac50c4950d93d" translate="yes" xml:space="preserve">
          <source>The text is parsed using the formatter, returning a year-month.</source>
          <target state="translated">使用格式器对文本进行解析,返回一个年月。</target>
        </trans-unit>
        <trans-unit id="1700b19da145b2d61543e5a3e6060e9ee5311e75" translate="yes" xml:space="preserve">
          <source>The text is parsed using the formatter, returning a year.</source>
          <target state="translated">使用格式器对文本进行解析,返回一个年份。</target>
        </trans-unit>
        <trans-unit id="714efd5fdbdc7a0051ac3528e30febfdfcc4d3b6" translate="yes" xml:space="preserve">
          <source>The text of the field will be output during a format. The value must be within the valid range of the field. If the value cannot be obtained then an exception will be thrown. If the field has no textual representation, then the numeric value will be used.</source>
          <target state="translated">字段的文本将在格式化过程中输出。该值必须在字段的有效范围内。如果不能获得该值,那么将抛出一个异常。如果字段没有文本表示,那么将使用数值。</target>
        </trans-unit>
        <trans-unit id="994a75acb429e80d94201f4b7fd1307dd3c02908" translate="yes" xml:space="preserve">
          <source>The text of the returned &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; is the same that would be returned by</source>
          <target state="translated">返回的文本 &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; 是会被返回相同</target>
        </trans-unit>
        <trans-unit id="8d32f65f9358481d68c26733468e9f5827be3bb9" translate="yes" xml:space="preserve">
          <source>The text range that the attribute is applied to is critical to the semantics of the range. That means, the attribute cannot be applied to subranges of the text range that it applies to, and, if two adjacent text ranges have the same value for this attribute, the attribute still cannot be applied to the combined range as a whole with this value.</source>
          <target state="translated">该属性所应用的文本范围对该范围的语义至关重要。也就是说,该属性不能应用于它所应用的文本范围的子范围,而且,如果两个相邻的文本范围对该属性具有相同的值,该属性仍然不能应用于具有该值的合并范围整体。</target>
        </trans-unit>
        <trans-unit id="7c3f83472e562d9215e150160baafa85452b5724" translate="yes" xml:space="preserve">
          <source>The text representation of each constant UnicodeBlock identifier. For example, this method will return the &lt;a href=&quot;#BASIC_LATIN&quot;&gt;&lt;code&gt;BASIC_LATIN&lt;/code&gt;&lt;/a&gt; block if provided with the &quot;BASIC_LATIN&quot; name. This form replaces all spaces and hyphens in the canonical name with underscores.</source>
          <target state="translated">每个常量UnicodeBlock标识符的文本表示形式。例如，如果提供了&amp;ldquo; BASIC_LATIN&amp;rdquo;名称，则此方法将返回&lt;a href=&quot;#BASIC_LATIN&quot;&gt; &lt;code&gt;BASIC_LATIN&lt;/code&gt; &lt;/a&gt;块。此格式用下划线替换规范名称中的所有空格和连字符。</target>
        </trans-unit>
        <trans-unit id="1b53d1b9f2d6a1ffec39094319a28b6fff2de1b3" translate="yes" xml:space="preserve">
          <source>The text representation of each constant UnicodeBlock identifier. For example, this method will return the &lt;a href=&quot;character.unicodeblock#BASIC_LATIN&quot;&gt;&lt;code&gt;BASIC_LATIN&lt;/code&gt;&lt;/a&gt; block if provided with the &quot;BASIC_LATIN&quot; name. This form replaces all spaces and hyphens in the canonical name with underscores.</source>
          <target state="translated">每个常量UnicodeBlock标识符的文本表示形式。例如，如果提供了&amp;ldquo; BASIC_LATIN&amp;rdquo;名称，则此方法将返回&lt;a href=&quot;character.unicodeblock#BASIC_LATIN&quot;&gt; &lt;code&gt;BASIC_LATIN&lt;/code&gt; &lt;/a&gt;块。此格式用下划线替换规范名称中的所有空格和连字符。</target>
        </trans-unit>
        <trans-unit id="77b9d7619830528efce6f7817705037fc5acc9d6" translate="yes" xml:space="preserve">
          <source>The text substituted for the individual format elements is derived from the current subformat of the format element and the &lt;code&gt;arguments&lt;/code&gt; element at the format element's argument index as indicated by the first matching line of the following table. An argument is</source>
          <target state="translated">替换单个格式元素的文本是从format元素的当前子格式和format元素的参数索引处的 &lt;code&gt;arguments&lt;/code&gt; 元素派生的，如下表的第一条匹配行所示。一个论点是</target>
        </trans-unit>
        <trans-unit id="9207fb7b3a8409b78131b80ed0af5df70aca6d6f" translate="yes" xml:space="preserve">
          <source>The text will be parsed from the specified start &lt;code&gt;ParsePosition&lt;/code&gt;. The entire length of the text does not have to be parsed, the &lt;code&gt;ParsePosition&lt;/code&gt; will be updated with the index at the end of parsing.</source>
          <target state="translated">将从指定的开始 &lt;code&gt;ParsePosition&lt;/code&gt; 开始解析文本。文本的整个长度不必解析，在解析结束时， &lt;code&gt;ParsePosition&lt;/code&gt; 将使用索引进行更新。</target>
        </trans-unit>
        <trans-unit id="ef359eb63a3e4e2e83b93c0386e4232cb9ad999c" translate="yes" xml:space="preserve">
          <source>The text.</source>
          <target state="translated">该文本:</target>
        </trans-unit>
        <trans-unit id="1448b4199b12055b6e038925f7a2322eace6c39d" translate="yes" xml:space="preserve">
          <source>The textual representation of IPv6 addresses as described above can be extended to specify IPv6 scoped addresses. This extension to the basic addressing architecture is described in [draft-ietf-ipngwg-scoping-arch-04.txt].</source>
          <target state="translated">上文所述的IPv6地址的文本表示可以扩展到指定IPv6范围内的地址。这种对基本寻址架构的扩展在[draft-ietf-ipngwg-scoping-arch-04.txt]中有所描述。</target>
        </trans-unit>
        <trans-unit id="619857d696535395d9a9e6e85c75cbda308cd69b" translate="yes" xml:space="preserve">
          <source>The textual representation of an IP address is address family specific.</source>
          <target state="translated">IP地址的文字表述是针对地址族的。</target>
        </trans-unit>
        <trans-unit id="2eeaee68cdaf2979e68f820a8cb381cb88cfe284" translate="yes" xml:space="preserve">
          <source>The textual representation of the selector for the rule set.</source>
          <target state="translated">规则集选择器的文字表述。</target>
        </trans-unit>
        <trans-unit id="a90596571ebf3cb87e069b539a095963b4c232a2" translate="yes" xml:space="preserve">
          <source>The textual representation of the selector for the rule set. The implementation may have stripped out insignificant whitespace while parsing the selector.</source>
          <target state="translated">规则集选择器的文本表示。在解析选择器时,执行过程中可能已经删除了不重要的空白。</target>
        </trans-unit>
        <trans-unit id="a243b35a93201c218afa01a0732e236f52dc54db" translate="yes" xml:space="preserve">
          <source>The third rule means for example that if the attribute &lt;code&gt;HeapMemoryUsage&lt;/code&gt; is a &lt;code&gt;MemoryUsage&lt;/code&gt;, monitoring &lt;code&gt;&quot;HeapMemoryUsage.used&quot;&lt;/code&gt; will obtain the observed value by calling &lt;code&gt;MemoryUsage.getUsed()&lt;/code&gt;.</source>
          <target state="translated">第三个规则意味着，例如，如果属性 &lt;code&gt;HeapMemoryUsage&lt;/code&gt; 是 &lt;code&gt;MemoryUsage&lt;/code&gt; ，则监视 &lt;code&gt;&quot;HeapMemoryUsage.used&quot;&lt;/code&gt; 将通过调用 &lt;code&gt;MemoryUsage.getUsed()&lt;/code&gt; 获得观测值。</target>
        </trans-unit>
        <trans-unit id="1524da4ee526fb66e2dfa2fc314cd6b0009b09e7" translate="yes" xml:space="preserve">
          <source>The third statement above returns a &lt;code&gt;SecureRandom&lt;/code&gt; object of the specific algorithm supporting the specific instantiate parameters. The implementation's effective instantiated parameters must match this minimum request but is not necessarily the same. For example, even if the request does not require a certain feature, the actual instantiation can provide the feature. An implementation may lazily instantiate a &lt;code&gt;SecureRandom&lt;/code&gt; until it's actually used, but the effective instantiate parameters must be determined right after it's created and &lt;a href=&quot;#getParameters()&quot;&gt;&lt;code&gt;getParameters()&lt;/code&gt;&lt;/a&gt; should always return the same result unchanged.</source>
          <target state="translated">上面的第三条语句返回支持特定实例化参数的特定算法的 &lt;code&gt;SecureRandom&lt;/code&gt; 对象。实现的有效实例化参数必须匹配此最小请求，但不一定相同。例如，即使请求不需要某个功能，实际的实例也可以提供该功能。一个实现可以延迟地实例化 &lt;code&gt;SecureRandom&lt;/code&gt; ,直到它被实际使用为止，但是有效的实例化参数必须在创建后立即确定，并且&lt;a href=&quot;#getParameters()&quot;&gt; &lt;code&gt;getParameters()&lt;/code&gt; &lt;/a&gt;始终应返回不变的相同结果。</target>
        </trans-unit>
        <trans-unit id="cd8c7b9c1c14ab7ee8912062724df6f9139f499d" translate="yes" xml:space="preserve">
          <source>The third type of ID are region-based IDs. A region-based ID must be of two or more characters, and not start with 'UTC', 'GMT', 'UT' '+' or '-'. Region-based IDs are defined by configuration, see &lt;a href=&quot;zone/zonerulesprovider&quot;&gt;&lt;code&gt;ZoneRulesProvider&lt;/code&gt;&lt;/a&gt;. The configuration focuses on providing the lookup from the ID to the underlying &lt;code&gt;ZoneRules&lt;/code&gt;.</source>
          <target state="translated">第三类ID是基于区域的ID。基于区域的ID必须是两个或多个字符，并且不能以&amp;ldquo; UTC&amp;rdquo;，&amp;ldquo; GMT&amp;rdquo;，&amp;ldquo; UT&amp;rdquo;，&amp;ldquo; +&amp;rdquo;或&amp;ldquo;-&amp;rdquo;开头。基于区域的ID由配置定义，请参见&lt;a href=&quot;zone/zonerulesprovider&quot;&gt; &lt;code&gt;ZoneRulesProvider&lt;/code&gt; &lt;/a&gt;。该配置着重于提供从ID到底层 &lt;code&gt;ZoneRules&lt;/code&gt; 的查找。</target>
        </trans-unit>
        <trans-unit id="7b2d5ce3a5a55711a2ea3b6fec5e3843d8b5a85a" translate="yes" xml:space="preserve">
          <source>The thread &lt;var&gt;T&lt;/var&gt; is then removed from the wait set for this object and re-enabled for thread scheduling. It competes in the usual manner with other threads for the right to synchronize on the object; once it has regained control of the object, all its synchronization claims on the object are restored to the status quo ante - that is, to the situation as of the time that the &lt;code&gt;wait&lt;/code&gt; method was invoked. Thread &lt;var&gt;T&lt;/var&gt; then returns from the invocation of the &lt;code&gt;wait&lt;/code&gt; method. Thus, on return from the &lt;code&gt;wait&lt;/code&gt; method, the synchronization state of the object and of thread &lt;code&gt;T&lt;/code&gt; is exactly as it was when the &lt;code&gt;wait&lt;/code&gt; method was invoked.</source>
          <target state="translated">然后将线程 &lt;var&gt;T&lt;/var&gt; 从该对象的等待集中删除，并重新启用线程调度。它以通常的方式与其他线程竞争在对象上进行同步的权利。一旦它重新获得了对对象的控制权，它对对象的所有同步声明都将恢复到原样-即，恢复到调用 &lt;code&gt;wait&lt;/code&gt; 方法时的情况。然后，线程 &lt;var&gt;T&lt;/var&gt; 从调用 &lt;code&gt;wait&lt;/code&gt; 方法返回。因此，从 &lt;code&gt;wait&lt;/code&gt; 方法返回时，对象和线程 &lt;code&gt;T&lt;/code&gt; 的同步状态与调用 &lt;code&gt;wait&lt;/code&gt; 方法时的状态完全相同。</target>
        </trans-unit>
        <trans-unit id="798fb3ab3b700a8b0974f49f646feb0adf6c0b98" translate="yes" xml:space="preserve">
          <source>The thread &lt;var&gt;T&lt;/var&gt; is then removed from the wait set for this object and re-enabled for thread scheduling. It then competes in the usual manner with other threads for the right to synchronize on the object; once it has gained control of the object, all its synchronization claims on the object are restored to the status quo ante - that is, to the situation as of the time that the &lt;code&gt;wait&lt;/code&gt; method was invoked. Thread &lt;var&gt;T&lt;/var&gt; then returns from the invocation of the &lt;code&gt;wait&lt;/code&gt; method. Thus, on return from the &lt;code&gt;wait&lt;/code&gt; method, the synchronization state of the object and of thread &lt;code&gt;T&lt;/code&gt; is exactly as it was when the &lt;code&gt;wait&lt;/code&gt; method was invoked.</source>
          <target state="translated">然后将线程 &lt;var&gt;T&lt;/var&gt; 从该对象的等待集中删除，并重新启用线程调度。然后，它以通常的方式与其他线程竞争在对象上进行同步的权利。一旦它获得了对象的控制权，它对对象的所有同步声明都将恢复到原样-即，恢复到调用 &lt;code&gt;wait&lt;/code&gt; 方法时的情况。然后，线程 &lt;var&gt;T&lt;/var&gt; 从调用 &lt;code&gt;wait&lt;/code&gt; 方法返回。因此，从 &lt;code&gt;wait&lt;/code&gt; 方法返回时，对象和线程 &lt;code&gt;T&lt;/code&gt; 的同步状态与调用 &lt;code&gt;wait&lt;/code&gt; 方法时的状态完全相同。</target>
        </trans-unit>
        <trans-unit id="3886d03f704e9f4661772e22e536d051a2540f61" translate="yes" xml:space="preserve">
          <source>The thread ID property will be initialized with a unique ID for the current thread.</source>
          <target state="translated">线程ID属性将被初始化为当前线程的唯一ID。</target>
        </trans-unit>
        <trans-unit id="3224cdeecc04e300e6f6eb5dd7b0f464a0f08ee9" translate="yes" xml:space="preserve">
          <source>The thread is in the &lt;a href=&quot;../../../../java.base/java/lang/thread.state#BLOCKED&quot;&gt;&lt;code&gt;BLOCKED&lt;/code&gt;&lt;/a&gt; state waiting to enter the &lt;code&gt;synchronized&lt;/code&gt; statement or method.</source>
          <target state="translated">线程处于&lt;a href=&quot;../../../../java.base/java/lang/thread.state#BLOCKED&quot;&gt; &lt;code&gt;BLOCKED&lt;/code&gt; &lt;/a&gt;状态，正在等待输入 &lt;code&gt;synchronized&lt;/code&gt; 语句或方法。</target>
        </trans-unit>
        <trans-unit id="f6a7e6fbe217b20213591b29b1d875c85171794a" translate="yes" xml:space="preserve">
          <source>The thread is in the &lt;a href=&quot;../../../../java.base/java/lang/thread.state#WAITING&quot;&gt;&lt;code&gt;WAITING&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../../../java.base/java/lang/thread.state#TIMED_WAITING&quot;&gt;&lt;code&gt;TIMED_WAITING&lt;/code&gt;&lt;/a&gt; state due to a call to the &lt;a href=&quot;../../../../java.base/java/lang/object#wait()&quot;&gt;&lt;code&gt;Object.wait&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">由于调用了&lt;a href=&quot;../../../../java.base/java/lang/object#wait()&quot;&gt; &lt;code&gt;Object.wait&lt;/code&gt; &lt;/a&gt;方法，该线程处于&lt;a href=&quot;../../../../java.base/java/lang/thread.state#WAITING&quot;&gt; &lt;code&gt;WAITING&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../../../../java.base/java/lang/thread.state#TIMED_WAITING&quot;&gt; &lt;code&gt;TIMED_WAITING&lt;/code&gt; &lt;/a&gt;状态。</target>
        </trans-unit>
        <trans-unit id="87a5145ea7018df714b4f0182c383913942e6f12" translate="yes" xml:space="preserve">
          <source>The thread is in the &lt;a href=&quot;../../../../java.base/java/lang/thread.state#WAITING&quot;&gt;&lt;code&gt;WAITING&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../../../java.base/java/lang/thread.state#TIMED_WAITING&quot;&gt;&lt;code&gt;TIMED_WAITING&lt;/code&gt;&lt;/a&gt; state due to a call to the &lt;a href=&quot;../../../../java.base/java/util/concurrent/locks/locksupport#park(java.lang.Object)&quot;&gt;&lt;code&gt;LockSupport.park&lt;/code&gt;&lt;/a&gt; method. The synchronization object is the object returned from &lt;a href=&quot;../../../../java.base/java/util/concurrent/locks/locksupport#getBlocker(java.lang.Thread)&quot;&gt;&lt;code&gt;LockSupport.getBlocker&lt;/code&gt;&lt;/a&gt; method. Typically it is an &lt;a href=&quot;lockinfo#OwnableSynchronizer&quot;&gt; ownable synchronizer&lt;/a&gt; or a &lt;a href=&quot;../../../../java.base/java/util/concurrent/locks/condition&quot;&gt;&lt;code&gt;Condition&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">由于调用了&lt;a href=&quot;../../../../java.base/java/util/concurrent/locks/locksupport#park(java.lang.Object)&quot;&gt; &lt;code&gt;LockSupport.park&lt;/code&gt; &lt;/a&gt;方法，该线程处于&lt;a href=&quot;../../../../java.base/java/lang/thread.state#WAITING&quot;&gt; &lt;code&gt;WAITING&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../../../../java.base/java/lang/thread.state#TIMED_WAITING&quot;&gt; &lt;code&gt;TIMED_WAITING&lt;/code&gt; &lt;/a&gt;状态。同步对象是从&lt;a href=&quot;../../../../java.base/java/util/concurrent/locks/locksupport#getBlocker(java.lang.Thread)&quot;&gt; &lt;code&gt;LockSupport.getBlocker&lt;/code&gt; &lt;/a&gt;方法返回的对象。通常，它是一个可&lt;a href=&quot;lockinfo#OwnableSynchronizer&quot;&gt;拥有的同步器&lt;/a&gt;或&lt;a href=&quot;../../../../java.base/java/util/concurrent/locks/condition&quot;&gt; &lt;code&gt;Condition&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4b9cc25b45a652d2428c1ca7ad40c7f0ae634fb0" translate="yes" xml:space="preserve">
          <source>The thread is in the &lt;a href=&quot;../thread.state#BLOCKED&quot;&gt;&lt;code&gt;BLOCKED&lt;/code&gt;&lt;/a&gt; state waiting to enter the &lt;code&gt;synchronized&lt;/code&gt; statement or method.</source>
          <target state="translated">线程处于&lt;a href=&quot;../thread.state#BLOCKED&quot;&gt; &lt;code&gt;BLOCKED&lt;/code&gt; &lt;/a&gt;状态，正在等待输入 &lt;code&gt;synchronized&lt;/code&gt; 语句或方法。</target>
        </trans-unit>
        <trans-unit id="77e59a24e2fff88b3f72bac70df76f307ccbec5b" translate="yes" xml:space="preserve">
          <source>The thread is in the &lt;a href=&quot;../thread.state#WAITING&quot;&gt;&lt;code&gt;WAITING&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../thread.state#TIMED_WAITING&quot;&gt;&lt;code&gt;TIMED_WAITING&lt;/code&gt;&lt;/a&gt; state due to a call to the &lt;a href=&quot;../../util/concurrent/locks/locksupport#park-java.lang.Object-&quot;&gt;&lt;code&gt;LockSupport.park&lt;/code&gt;&lt;/a&gt; method. The synchronization object is the object returned from &lt;a href=&quot;../../util/concurrent/locks/locksupport#getBlocker-java.lang.Thread-&quot;&gt;&lt;code&gt;LockSupport.getBlocker&lt;/code&gt;&lt;/a&gt; method. Typically it is an &lt;a href=&quot;lockinfo#OwnableSynchronizer&quot;&gt; ownable synchronizer&lt;/a&gt; or a &lt;a href=&quot;../../util/concurrent/locks/condition&quot;&gt;&lt;code&gt;Condition&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">由于调用了&lt;a href=&quot;../../util/concurrent/locks/locksupport#park-java.lang.Object-&quot;&gt; &lt;code&gt;LockSupport.park&lt;/code&gt; &lt;/a&gt;方法，该线程处于&lt;a href=&quot;../thread.state#WAITING&quot;&gt; &lt;code&gt;WAITING&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../thread.state#TIMED_WAITING&quot;&gt; &lt;code&gt;TIMED_WAITING&lt;/code&gt; &lt;/a&gt;状态。同步对象是从&lt;a href=&quot;../../util/concurrent/locks/locksupport#getBlocker-java.lang.Thread-&quot;&gt; &lt;code&gt;LockSupport.getBlocker&lt;/code&gt; &lt;/a&gt;方法返回的对象。通常，它是一个可&lt;a href=&quot;lockinfo#OwnableSynchronizer&quot;&gt;拥有的同步器&lt;/a&gt;或&lt;a href=&quot;../../util/concurrent/locks/condition&quot;&gt; &lt;code&gt;Condition&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d7b971951034e25a9cbf8c4a7520b71c76ce7c9c" translate="yes" xml:space="preserve">
          <source>The thread is in the &lt;a href=&quot;../thread.state#WAITING&quot;&gt;&lt;code&gt;WAITING&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../thread.state#TIMED_WAITING&quot;&gt;&lt;code&gt;TIMED_WAITING&lt;/code&gt;&lt;/a&gt; state due to a call to the &lt;a href=&quot;../object#wait-long-&quot;&gt;&lt;code&gt;Object.wait&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">由于调用了&lt;a href=&quot;../object#wait-long-&quot;&gt; &lt;code&gt;Object.wait&lt;/code&gt; &lt;/a&gt;方法，该线程处于&lt;a href=&quot;../thread.state#WAITING&quot;&gt; &lt;code&gt;WAITING&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../thread.state#TIMED_WAITING&quot;&gt; &lt;code&gt;TIMED_WAITING&lt;/code&gt; &lt;/a&gt;状态。</target>
        </trans-unit>
        <trans-unit id="fee6ea9eaa70ac63cd7bd687ae74dc9ebb1babb9" translate="yes" xml:space="preserve">
          <source>The thread must be suspended. The return occurs when execution of Java programming language code is resumed on this thread. Between the call to this method and resumption of thread execution, the state of the stack is undefined.</source>
          <target state="translated">该线程必须被暂停。当该线程上恢复执行Java编程语言代码时,就会发生返回。在调用本方法和恢复线程执行之间,堆栈的状态是未定义的。</target>
        </trans-unit>
        <trans-unit id="dc8e934b45026e9176ead01c6d486ce921318b0a" translate="yes" xml:space="preserve">
          <source>The thread owning this segment.</source>
          <target state="translated">线路自己这个环节。</target>
        </trans-unit>
        <trans-unit id="1cae8d80c59d4da83095fa5ad01a12ad0e9b0377" translate="yes" xml:space="preserve">
          <source>The thread represented by this thread is forced to stop whatever it is doing abnormally and to throw a newly created &lt;code&gt;ThreadDeath&lt;/code&gt; object as an exception.</source>
          <target state="translated">此线程代表的线程被迫停止异常处理，并抛出一个新创建的 &lt;code&gt;ThreadDeath&lt;/code&gt; 对象作为异常。</target>
        </trans-unit>
        <trans-unit id="0b3e60ed90635a926c08dd344792b7dde7c9298f" translate="yes" xml:space="preserve">
          <source>The thread then waits until it can re-obtain ownership of the monitor and resumes execution.</source>
          <target state="translated">然后,线程等待,直到它能重新获得监视器的所有权并恢复执行。</target>
        </trans-unit>
        <trans-unit id="25b717a3fa1cf9d27360f778068bc0905b1e3681" translate="yes" xml:space="preserve">
          <source>The threads may be executing while this method is called. The stack trace of each thread only represents a snapshot and each stack trace may be obtained at different time. A zero-length array will be returned in the map value if the virtual machine has no stack trace information about a thread.</source>
          <target state="translated">当本方法被调用时,线程可能正在执行。每个线程的堆栈跟踪只代表一个快照,每个堆栈跟踪可能在不同的时间获得。如果虚拟机没有某个线程的堆栈跟踪信息,则映射值中会返回一个零长度的数组。</target>
        </trans-unit>
        <trans-unit id="f6e3ff0b6b3a8faf4f1e95b0c706e80d227c4311" translate="yes" xml:space="preserve">
          <source>The three aspects of &lt;code&gt;collect&lt;/code&gt; -- supplier, accumulator, and combiner -- are tightly coupled. We can use the abstraction of a &lt;a href=&quot;collector&quot;&gt;&lt;code&gt;Collector&lt;/code&gt;&lt;/a&gt; to capture all three aspects. The above example for collecting strings into a &lt;code&gt;List&lt;/code&gt; can be rewritten using a standard &lt;code&gt;Collector&lt;/code&gt; as:</source>
          <target state="translated">&lt;code&gt;collect&lt;/code&gt; 的三个方面-供应商，累加器和合并器-紧密耦合。我们可以使用&lt;a href=&quot;collector&quot;&gt; &lt;code&gt;Collector&lt;/code&gt; &lt;/a&gt;的抽象来捕获所有三个方面。上面的将字符串收集到 &lt;code&gt;List&lt;/code&gt; 示例可以使用标准的 &lt;code&gt;Collector&lt;/code&gt; 重写为：</target>
        </trans-unit>
        <trans-unit id="ac4e5d34586392cc6376d13f3ac41b119993fff0" translate="yes" xml:space="preserve">
          <source>The three forms of &lt;code&gt;park&lt;/code&gt; each also support a &lt;code&gt;blocker&lt;/code&gt; object parameter. This object is recorded while the thread is blocked to permit monitoring and diagnostic tools to identify the reasons that threads are blocked. (Such tools may access blockers using method &lt;a href=&quot;#getBlocker(java.lang.Thread)&quot;&gt;&lt;code&gt;getBlocker(Thread)&lt;/code&gt;&lt;/a&gt;.) The use of these forms rather than the original forms without this parameter is strongly encouraged. The normal argument to supply as a &lt;code&gt;blocker&lt;/code&gt; within a lock implementation is &lt;code&gt;this&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;park&lt;/code&gt; 的三种形式也都支持 &lt;code&gt;blocker&lt;/code&gt; 对象参数。线程被阻塞时会记录该对象，以允许监视和诊断工具确定线程被阻塞的原因。（此类工具可以使用&lt;a href=&quot;#getBlocker(java.lang.Thread)&quot;&gt; &lt;code&gt;getBlocker(Thread)&lt;/code&gt; &lt;/a&gt;方法访问阻止程序。）强烈建议使用这些形式，而不使用没有此参数的原始形式。在锁实现中提供作为 &lt;code&gt;blocker&lt;/code&gt; 的正常参数是 &lt;code&gt;this&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ccdf2eb66d2e71f34a919a596f65bb338f795c35" translate="yes" xml:space="preserve">
          <source>The three forms of &lt;code&gt;park&lt;/code&gt; each also support a &lt;code&gt;blocker&lt;/code&gt; object parameter. This object is recorded while the thread is blocked to permit monitoring and diagnostic tools to identify the reasons that threads are blocked. (Such tools may access blockers using method &lt;a href=&quot;locksupport#getBlocker-java.lang.Thread-&quot;&gt;&lt;code&gt;getBlocker(Thread)&lt;/code&gt;&lt;/a&gt;.) The use of these forms rather than the original forms without this parameter is strongly encouraged. The normal argument to supply as a &lt;code&gt;blocker&lt;/code&gt; within a lock implementation is &lt;code&gt;this&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;park&lt;/code&gt; 的三种形式也都支持 &lt;code&gt;blocker&lt;/code&gt; 对象参数。线程被阻塞时会记录此对象，以允许监视和诊断工具确定线程被阻塞的原因。 （此类工具可以使用&lt;a href=&quot;locksupport#getBlocker-java.lang.Thread-&quot;&gt; &lt;code&gt;getBlocker(Thread)&lt;/code&gt; &lt;/a&gt;方法访问阻止程序。）强烈建议使用这些形式，而不使用没有此参数的原始形式。在锁实现中将提供作为 &lt;code&gt;blocker&lt;/code&gt; 的通常参数是 &lt;code&gt;this&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="df00dd95000e60bd282d65d477e94c0a82461152" translate="yes" xml:space="preserve">
          <source>The three forms of condition waiting (interruptible, non-interruptible, and timed) may differ in their ease of implementation on some platforms and in their performance characteristics. In particular, it may be difficult to provide these features and maintain specific semantics such as ordering guarantees. Further, the ability to interrupt the actual suspension of the thread may not always be feasible to implement on all platforms.</source>
          <target state="translated">条件等待的三种形式(可中断、不可中断和定时)在某些平台上的实现难易程度及其性能特征可能有所不同。特别是,提供这些特性并保持特定的语义(如排序保证)可能是困难的。此外,中断线程实际暂停的能力可能并不总是在所有平台上都能实现。</target>
        </trans-unit>
        <trans-unit id="db29ad82518a2ee6d7ddfaf1a9c7b34c8ecf4057" translate="yes" xml:space="preserve">
          <source>The three forms of lock acquisition (interruptible, non-interruptible, and timed) may differ in their performance characteristics, ordering guarantees, or other implementation qualities. Further, the ability to interrupt the &lt;em&gt;ongoing&lt;/em&gt; acquisition of a lock may not be available in a given &lt;code&gt;Lock&lt;/code&gt; class. Consequently, an implementation is not required to define exactly the same guarantees or semantics for all three forms of lock acquisition, nor is it required to support interruption of an ongoing lock acquisition. An implementation is required to clearly document the semantics and guarantees provided by each of the locking methods. It must also obey the interruption semantics as defined in this interface, to the extent that interruption of lock acquisition is supported: which is either totally, or only on method entry.</source>
          <target state="translated">锁获取的三种形式（可中断，不可中断和定时）可能在其性能特征，订购保证或其他实现质量方面有所不同。此外，中断的能力&lt;em&gt;不断&lt;/em&gt;收购的锁可能无法在一个给定的可 &lt;code&gt;Lock&lt;/code&gt; 类。因此，不需要为所有三种形式的锁获取定义完全相同的保证或语义的实现，也不需要支持正在进行的锁获取的中断的实现。需要一个实现来清楚地记录每个锁定方法提供的语义和保证。在支持锁获取中断的程度上，它还必须服从此接口中定义的中断语义：全部或仅在方法输入时才这样做。</target>
        </trans-unit>
        <trans-unit id="bb65090e22ab8912d71a3b4c421185f9239fb8c9" translate="yes" xml:space="preserve">
          <source>The three types of rendering operations, along with details of each of their particular rendering processes are:</source>
          <target state="translated">这三种类型的渲染操作,以及它们每个特定渲染过程的细节是:</target>
        </trans-unit>
        <trans-unit id="b1243cf17aa93cee91f50c4b5f0c4dfc5e1efee1" translate="yes" xml:space="preserve">
          <source>The three values for decomposition mode are:</source>
          <target state="translated">分解模式的三个值是:。</target>
        </trans-unit>
        <trans-unit id="466d6ba993a967766940f8a7a94e7ffe571cfcd1" translate="yes" xml:space="preserve">
          <source>The three ways to start an agent are described below.</source>
          <target state="translated">下面介绍一下代理的三种启动方式。</target>
        </trans-unit>
        <trans-unit id="eca35f7b2afddf8594835c4c8f46728d1529fce5" translate="yes" xml:space="preserve">
          <source>The three-argument form is a generalization of the two-argument form, incorporating a mapping step into the accumulation step. We could re-cast the simple sum-of-weights example using the more general form as follows:</source>
          <target state="translated">三参数形式是双参数形式的概括,在积累步骤中加入了一个映射步骤。我们可以将简单的权数总和的例子用更一般的形式重述如下:</target>
        </trans-unit>
        <trans-unit id="6013fc1c39f145cd90930c97bc7092d091abff1f" translate="yes" xml:space="preserve">
          <source>The threshold (for example, &lt;code&gt;&quot;20 ms&quot;&lt;/code&gt;).</source>
          <target state="translated">阈值（例如， &lt;code&gt;&quot;20 ms&quot;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="e2e826b013ebf5d13455251fda42b4b52a0a40d6" translate="yes" xml:space="preserve">
          <source>The threshold high or threshold low are not of the same type as the gauge (gauge monitors).</source>
          <target state="translated">阈值高或阈值低与仪表(仪表监控器)不是同一类型。</target>
        </trans-unit>
        <trans-unit id="618cf78884b8f69aa1ff4f548c236bef8d448a10" translate="yes" xml:space="preserve">
          <source>The threshold or the offset or the modulus are not of the same type as the counter (counter monitors).</source>
          <target state="translated">阈值或偏移或模数与计数器(计数器监控器)不是同一类型。</target>
        </trans-unit>
        <trans-unit id="5b761c49c0df6550fd9288c6d950a41463038892" translate="yes" xml:space="preserve">
          <source>The threshold value for the specified MBean if this MBean is in the set of observed MBeans, or &lt;code&gt;null&lt;/code&gt; otherwise.</source>
          <target state="translated">如果指定的MBean在观察到的MBean集合中，则为该MBean的阈值；否则为 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4abbaad922146601ba46b4fe49f8e578a3e9883a" translate="yes" xml:space="preserve">
          <source>The threshold value of the specified object.</source>
          <target state="translated">指定对象的阈值。</target>
        </trans-unit>
        <trans-unit id="93ccc78354f36ab6014746446d9124e4c9a55c8e" translate="yes" xml:space="preserve">
          <source>The threshold value.</source>
          <target state="translated">阈值;</target>
        </trans-unit>
        <trans-unit id="c8421d23d14f7481a0d1af497cd30f15efc9c681" translate="yes" xml:space="preserve">
          <source>The tick duration must be positive. If it has a part smaller than a whole millisecond, then the whole duration must divide into one second without leaving a remainder. All normal tick durations will match these criteria, including any multiple of hours, minutes, seconds and milliseconds, and sensible nanosecond durations, such as 20ns, 250,000ns and 500,000ns.</source>
          <target state="translated">tick持续时间必须是正数。如果它的部分小于整毫秒,那么整个持续时间必须除以一秒,不留余数。所有正常的刻度持续时间都符合这些标准,包括小时、分钟、秒和毫秒的任何倍数,以及合理的纳秒持续时间,如20ns、250,000ns和500,000ns。</target>
        </trans-unit>
        <trans-unit id="3d7a7f884123f38061b4f01b40f6fca44848eb92" translate="yes" xml:space="preserve">
          <source>The time and offset do not affect the calculation and will be the same in the result. If the day-of-month is invalid for the year, it will be changed to the last valid day of the month.</source>
          <target state="translated">时间和偏移量不影响计算,结果将是相同的。如果该年的月份无效,则将改为该月的最后一天。</target>
        </trans-unit>
        <trans-unit id="cf65733067f037d5f7c0913c18befc5a4452eae3" translate="yes" xml:space="preserve">
          <source>The time and offset do not affect the calculation and will be the same in the result. If the resulting &lt;code&gt;OffsetDateTime&lt;/code&gt; is invalid, an exception is thrown.</source>
          <target state="translated">时间和偏移量不会影响计算，结果将是相同的。如果结果 &lt;code&gt;OffsetDateTime&lt;/code&gt; 无效，则引发异常。</target>
        </trans-unit>
        <trans-unit id="6c06ad7fab5af0cf4e31869a72aaa8c0967814aa" translate="yes" xml:space="preserve">
          <source>The time does not affect the calculation and will be the same in the result. If the day-of-month is invalid for the year, it will be changed to the last valid day of the month.</source>
          <target state="translated">时间不会影响计算,结果也会一样。如果该年的月份无效,则将改为该月的最后一天。</target>
        </trans-unit>
        <trans-unit id="4106b4f9e69339c1872abca12ca2da7faed9666a" translate="yes" xml:space="preserve">
          <source>The time in milli-seconds that the MBeanInfo can reasonably be expected to be unchanged. The value can be a &lt;code&gt;Long&lt;/code&gt; or a decimal string. This provides a hint from a DynamicMBean or any MBean that does not define &lt;code&gt;immutableInfo&lt;/code&gt; as &lt;code&gt;true&lt;/code&gt; that the MBeanInfo is not likely to change within this period and therefore can be cached. When this field is missing or has the value zero, it is not recommended to cache the MBeanInfo unless it has the &lt;code&gt;immutableInfo&lt;/code&gt; set to &lt;code&gt;true&lt;/code&gt; or it has &lt;a href=&quot;mbeaninfo#info-changed&quot;&gt;&lt;code&gt;&quot;jmx.mbean.info.changed&quot;&lt;/code&gt;&lt;/a&gt; in its &lt;a href=&quot;mbeannotificationinfo&quot;&gt;&lt;code&gt;MBeanNotificationInfo&lt;/code&gt;&lt;/a&gt; array.</source>
          <target state="translated">MBeanInfo可以合理预期保持不变的时间（以毫秒为单位）。该值可以是 &lt;code&gt;Long&lt;/code&gt; 或十进制字符串。这提供了来自DynamicMBean或未将 &lt;code&gt;immutableInfo&lt;/code&gt; 定义为 &lt;code&gt;true&lt;/code&gt; 的任何MBean的提示，该MBeanInfo在此期间不太可能更改，因此可以缓存。当此字段丢失或值为零时，不建议缓存MBeanInfo，除非将 &lt;code&gt;immutableInfo&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; 或在其&lt;a href=&quot;mbeannotificationinfo&quot;&gt; &lt;code&gt;MBeanNotificationInfo&lt;/code&gt; &lt;/a&gt;数组中具有&lt;a href=&quot;mbeaninfo#info-changed&quot;&gt; &lt;code&gt;&quot;jmx.mbean.info.changed&quot;&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="acbf0fbbf2519547cc43bc06b63a9e4515272ec9" translate="yes" xml:space="preserve">
          <source>The time is converted into an instant using the time definition.</source>
          <target state="translated">利用时间定义将时间转换为瞬间。</target>
        </trans-unit>
        <trans-unit id="5996955378dd36992f5dee7922b6ee64c4396fe3" translate="yes" xml:space="preserve">
          <source>The time limit of these SearchControls in milliseconds.</source>
          <target state="translated">这些SearchControls的时间限制,单位为毫秒。</target>
        </trans-unit>
        <trans-unit id="526444c169e427c129c525d4df96c1420c7a51f7" translate="yes" xml:space="preserve">
          <source>The time of midnight at the start of the day, '00:00'.</source>
          <target state="translated">一天开始时的午夜时间,'00:00'。</target>
        </trans-unit>
        <trans-unit id="8f833517ae6c82bdf28f4d07f70897fd379d4f67" translate="yes" xml:space="preserve">
          <source>The time of noon in the middle of the day, '12:00'.</source>
          <target state="translated">中午的时间,'十二点'。</target>
        </trans-unit>
        <trans-unit id="64a643ca048518ba71b10504256b6f2db499384f" translate="yes" xml:space="preserve">
          <source>The time of the day at which daylight saving time starts or ends is specified by a millisecond value within the day. There are three kinds of &lt;em&gt;mode&lt;/em&gt;s to specify the time: &lt;a href=&quot;#WALL_TIME&quot;&gt;&lt;code&gt;WALL_TIME&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#STANDARD_TIME&quot;&gt;&lt;code&gt;STANDARD_TIME&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#UTC_TIME&quot;&gt;&lt;code&gt;UTC_TIME&lt;/code&gt;&lt;/a&gt;. For example, if daylight saving time ends at 2:00 am in the wall clock time, it can be specified by 7200000 milliseconds in the &lt;a href=&quot;#WALL_TIME&quot;&gt;&lt;code&gt;WALL_TIME&lt;/code&gt;&lt;/a&gt; mode. In this case, the wall clock time for an &lt;em&gt;end-rule&lt;/em&gt; means the same thing as the daylight time.</source>
          <target state="translated">夏令时开始或结束的一天中的时间由一天中的毫秒值指定。有三种用于指定时间的&lt;em&gt;模式&lt;/em&gt;：&lt;a href=&quot;#WALL_TIME&quot;&gt; &lt;code&gt;WALL_TIME&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#STANDARD_TIME&quot;&gt; &lt;code&gt;STANDARD_TIME&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#UTC_TIME&quot;&gt; &lt;code&gt;UTC_TIME&lt;/code&gt; &lt;/a&gt;。例如，如果夏令时在壁钟时间的凌晨2:00结束，则可以在&lt;a href=&quot;#WALL_TIME&quot;&gt; &lt;code&gt;WALL_TIME&lt;/code&gt; &lt;/a&gt;模式下将其指定为7200000毫秒。在这种情况下，&lt;em&gt;结束规则的&lt;/em&gt;挂钟时间与夏令时意义相同。</target>
        </trans-unit>
        <trans-unit id="8f963cde5781a47df760ad32650d381c8f0dbe75" translate="yes" xml:space="preserve">
          <source>The time of the day at which daylight saving time starts or ends is specified by a millisecond value within the day. There are three kinds of &lt;em&gt;mode&lt;/em&gt;s to specify the time: &lt;a href=&quot;simpletimezone#WALL_TIME&quot;&gt;&lt;code&gt;WALL_TIME&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;simpletimezone#STANDARD_TIME&quot;&gt;&lt;code&gt;STANDARD_TIME&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;simpletimezone#UTC_TIME&quot;&gt;&lt;code&gt;UTC_TIME&lt;/code&gt;&lt;/a&gt;. For example, if daylight saving time ends at 2:00 am in the wall clock time, it can be specified by 7200000 milliseconds in the &lt;a href=&quot;simpletimezone#WALL_TIME&quot;&gt;&lt;code&gt;WALL_TIME&lt;/code&gt;&lt;/a&gt; mode. In this case, the wall clock time for an &lt;em&gt;end-rule&lt;/em&gt; means the same thing as the daylight time.</source>
          <target state="translated">夏令时开始或结束的一天中的时间由一天中的毫秒值指定。有三种&lt;em&gt;模式&lt;/em&gt;可以指定时间：&lt;a href=&quot;simpletimezone#WALL_TIME&quot;&gt; &lt;code&gt;WALL_TIME&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;simpletimezone#STANDARD_TIME&quot;&gt; &lt;code&gt;STANDARD_TIME&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;simpletimezone#UTC_TIME&quot;&gt; &lt;code&gt;UTC_TIME&lt;/code&gt; &lt;/a&gt;。例如，如果夏令时在壁钟时间的凌晨2:00结束，则可以在&lt;a href=&quot;simpletimezone#WALL_TIME&quot;&gt; &lt;code&gt;WALL_TIME&lt;/code&gt; &lt;/a&gt;模式下将其指定为7200000毫秒。在这种情况下，&lt;em&gt;结束规则的&lt;/em&gt;挂钟时间与夏令时意义相同。</target>
        </trans-unit>
        <trans-unit id="da518f034e84f814aabae3807109e025837e0b57" translate="yes" xml:space="preserve">
          <source>The time period in milliseconds, or &lt;code&gt;0&lt;/code&gt;</source>
          <target state="translated">时间段（以毫秒为单位）或 &lt;code&gt;0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cf057ec490c0b8af2d8425ade1d7ae7ac4480b72" translate="yes" xml:space="preserve">
          <source>The time period that the sending side may expire the message if it has not been sent, or &lt;code&gt;0&lt;/code&gt; to indicate that no timeout should occur.</source>
          <target state="translated">如果尚未发送消息，则发送方可以使消息过期的时间段；如果为 &lt;code&gt;0&lt;/code&gt; ，则表示不应发生超时。</target>
        </trans-unit>
        <trans-unit id="8deb22926d2dc6ce60af21119793b60100298e6b" translate="yes" xml:space="preserve">
          <source>The time period that the sending side may expire the message if it has not been sent, or &lt;code&gt;0&lt;/code&gt; to indicate that no timeout should occur. This value is only applicable for messages being sent, it has no meaning for received messages.</source>
          <target state="translated">如果尚未发送消息，则发送方可以使消息过期的时间段；如果为 &lt;code&gt;0&lt;/code&gt; ，则表示不应发生超时。该值仅适用于正在发送的消息，对于已接收的消息没有意义。</target>
        </trans-unit>
        <trans-unit id="3f682fddb863e7c5b381d42cd6be2e0499225644" translate="yes" xml:space="preserve">
          <source>The time stamp.</source>
          <target state="translated">时间戳。</target>
        </trans-unit>
        <trans-unit id="3cb58d5d8003015620c159da03ce3e4d5619a359" translate="yes" xml:space="preserve">
          <source>The time stamp. Replaced by InputEvent.getWhen().</source>
          <target state="translated">时间戳。由InputEvent.getWhen()代替。</target>
        </trans-unit>
        <trans-unit id="422a6a0727efc668eadfab588f39e7901af76990" translate="yes" xml:space="preserve">
          <source>The time-to-live constant for disabling the expiration control for loaded resource bundle instances in the cache.</source>
          <target state="translated">用于禁用缓存中已加载资源捆绑实例的过期控制的活期常数。</target>
        </trans-unit>
        <trans-unit id="c09406968aca987adec6afd3d870562c13c5226c" translate="yes" xml:space="preserve">
          <source>The time-to-live constant for not caching loaded resource bundle instances.</source>
          <target state="translated">不缓存加载资源捆绑实例的生存时间常数。</target>
        </trans-unit>
        <trans-unit id="2948afa6c507e96db7157cef9cbb050870dbd00b" translate="yes" xml:space="preserve">
          <source>The time-zone offset for UTC, with an ID of 'Z'.</source>
          <target state="translated">UTC的时区偏移,ID为'Z'。</target>
        </trans-unit>
        <trans-unit id="1dfd324cfb41000f9d3aba1f9dad090939b1b93f" translate="yes" xml:space="preserve">
          <source>The timeout period, specified by &lt;code&gt;timeout&lt;/code&gt; milliseconds plus &lt;code&gt;nanos&lt;/code&gt; nanoseconds arguments, has elapsed.</source>
          <target state="translated">超时时间，通过指定 &lt;code&gt;timeout&lt;/code&gt; 毫秒加 &lt;code&gt;nanos&lt;/code&gt; 纳秒的论点，已经过去了。</target>
        </trans-unit>
        <trans-unit id="e87dd73958b4c331aa3b482b31ba9b3bb70f0291" translate="yes" xml:space="preserve">
          <source>The timeout value, in milliseconds, indicates the maximum amount of time the try should take. If the operation times out before getting an answer, the host is deemed unreachable. A negative value will result in an IllegalArgumentException being thrown.</source>
          <target state="translated">超时值,以毫秒为单位,表示该尝试应花费的最大时间。如果操作在得到回答之前就超时,则认为主机是不可到达的。负值将导致抛出IllegalArgumentException。</target>
        </trans-unit>
        <trans-unit id="5a3c7016b356d85ab2005993ec546da2021f5da3" translate="yes" xml:space="preserve">
          <source>The timer notification detailed message or null if the identifier is not mapped to any timer notification registered for this timer MBean.</source>
          <target state="translated">定时器通知详细消息,如果标识符没有映射到为该定时器MBean注册的任何定时器通知,则为空。</target>
        </trans-unit>
        <trans-unit id="e45c48a5b2ba20c62b4614e6273292d7390eb1e1" translate="yes" xml:space="preserve">
          <source>The timer notification type or null if the identifier is not mapped to any timer notification registered for this timer MBean.</source>
          <target state="translated">定时器通知类型,如果标识符没有映射到为该定时器MBean注册的任何定时器通知,则为空。</target>
        </trans-unit>
        <trans-unit id="23967f54cac8eb8b003d2fc196f922e43be03fd3" translate="yes" xml:space="preserve">
          <source>The timer notification user data object or null if the identifier is not mapped to any timer notification registered for this timer MBean.</source>
          <target state="translated">定时器通知用户数据对象,如果标识符没有映射到为该定时器MBean注册的任何定时器通知,则为空。</target>
        </trans-unit>
        <trans-unit id="d238facacd1f3d07587721542ed70d70cb4c4775" translate="yes" xml:space="preserve">
          <source>The timer notification will be handled once at the specified date.</source>
          <target state="translated">定时器通知将在指定日期处理一次。</target>
        </trans-unit>
        <trans-unit id="414f37292531292150b0ccb1cad0625336e616e7" translate="yes" xml:space="preserve">
          <source>The timer notification will repeat continuously using the timer period using a</source>
          <target state="translated">定时器通知将使用定时器周期连续重复使用一个</target>
        </trans-unit>
        <trans-unit id="315f63d583a4676ef18933ae7199a0ed0f9a00e4" translate="yes" xml:space="preserve">
          <source>The timer notifications are created and handled by the timer MBean.</source>
          <target state="translated">定时器通知由定时器MBean创建和处理。</target>
        </trans-unit>
        <trans-unit id="cd191085be187917516f28d90bc41b5e0e055de2" translate="yes" xml:space="preserve">
          <source>The timer service relies on the system date of the host where the &lt;code&gt;Timer&lt;/code&gt; class is loaded. Listeners may receive untimely notifications if their host has a different system date. To avoid such problems, synchronize the system date of all host machines where timing is needed.</source>
          <target state="translated">计时器服务依赖于加载了 &lt;code&gt;Timer&lt;/code&gt; 类的主机的系统日期。如果侦听器的主机具有不同的系统日期，则它们可能会收到不及时的通知。为避免此类问题，请在需要计时的所有主机上同步系统日期。</target>
        </trans-unit>
        <trans-unit id="60a7b8fc73dec0735c0c82b6db258aba41d55181" translate="yes" xml:space="preserve">
          <source>The timestamp of this &lt;code&gt;UUID&lt;/code&gt;.</source>
          <target state="translated">此 &lt;code&gt;UUID&lt;/code&gt; 的时间戳。</target>
        </trans-unit>
        <trans-unit id="5d91c8abe6606f2a3d89bcf82e749e9e60f3b44c" translate="yes" xml:space="preserve">
          <source>The timestamp or &lt;code&gt;null&lt;/code&gt; if none is present.</source>
          <target state="translated">时间戳；如果不存在，则为 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="41a65048c31509f7e0113cb6ea8961ee3f79f086" translate="yes" xml:space="preserve">
          <source>The timestamp value associated with this UUID.</source>
          <target state="translated">与此UUID相关联的时间戳值。</target>
        </trans-unit>
        <trans-unit id="77858a6a5789b904ad06d6e90ad129b1b4ed75fb" translate="yes" xml:space="preserve">
          <source>The timestamp value is only meaningful in a time-based UUID, which has version type 1. If this &lt;code&gt;UUID&lt;/code&gt; is not a time-based UUID then this method throws UnsupportedOperationException.</source>
          <target state="translated">时间戳记值仅在版本类型为1的基于时间的UUID中才有意义。如果此 &lt;code&gt;UUID&lt;/code&gt; 不是基于时间的UUID，则此方法将引发UnsupportedOperationException。</target>
        </trans-unit>
        <trans-unit id="562d9979ad13d306cfdc69375e27b692b4c4e6be" translate="yes" xml:space="preserve">
          <source>The timestamp's date and time.</source>
          <target state="translated">时间戳的日期和时间。</target>
        </trans-unit>
        <trans-unit id="2f99efc0a5831891f40ab823d3bf06354b6d699f" translate="yes" xml:space="preserve">
          <source>The timing division type of the sequence.</source>
          <target state="translated">序列的定时分割类型。</target>
        </trans-unit>
        <trans-unit id="b61d7655e56c95f2266c2fad01803ab318ea6674" translate="yes" xml:space="preserve">
          <source>The timing information and resolution for a track is controlled by and stored in the sequence containing the track. A given &lt;code&gt;Track&lt;/code&gt; is considered to belong to the particular &lt;a href=&quot;sequence&quot;&gt;&lt;code&gt;Sequence&lt;/code&gt;&lt;/a&gt; that maintains its timing. For this reason, a new (empty) track is created by calling the &lt;a href=&quot;sequence#createTrack()&quot;&gt;&lt;code&gt;Sequence.createTrack()&lt;/code&gt;&lt;/a&gt; method, rather than by directly invoking a &lt;code&gt;Track&lt;/code&gt; constructor.</source>
          <target state="translated">轨道的定时信息和分辨率由包含轨道的序列控制并存储在其中。给定的 &lt;code&gt;Track&lt;/code&gt; 被认为属于维护其时序的特定&lt;a href=&quot;sequence&quot;&gt; &lt;code&gt;Sequence&lt;/code&gt; &lt;/a&gt;。因此，通过调用&lt;a href=&quot;sequence#createTrack()&quot;&gt; &lt;code&gt;Sequence.createTrack()&lt;/code&gt; &lt;/a&gt;方法而不是直接调用 &lt;code&gt;Track&lt;/code&gt; 构造函数来创建新的（空）轨道。</target>
        </trans-unit>
        <trans-unit id="d0374fbf6438fbc3467dbf34b4e05683b94595c3" translate="yes" xml:space="preserve">
          <source>The timing information and resolution for a track is controlled by and stored in the sequence containing the track. A given &lt;code&gt;Track&lt;/code&gt; is considered to belong to the particular &lt;code&gt;&lt;a href=&quot;sequence&quot;&gt;&lt;code&gt;Sequence&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; that maintains its timing. For this reason, a new (empty) track is created by calling the &lt;code&gt;&lt;a href=&quot;sequence#createTrack--&quot;&gt;&lt;code&gt;Sequence.createTrack()&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; method, rather than by directly invoking a &lt;code&gt;Track&lt;/code&gt; constructor.</source>
          <target state="translated">轨道的定时信息和分辨率由包含轨道的序列控制并存储在其中。给定的 &lt;code&gt;Track&lt;/code&gt; 被认为属于维持其时序的特定 &lt;code&gt;&lt;a href=&quot;sequence&quot;&gt;&lt;code&gt;Sequence&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; 。因此，通过调用 &lt;code&gt;&lt;a href=&quot;sequence#createTrack--&quot;&gt;&lt;code&gt;Sequence.createTrack()&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; 方法而不是直接调用 &lt;code&gt;Track&lt;/code&gt; 构造函数来创建新的（空）轨道。</target>
        </trans-unit>
        <trans-unit id="6e6d3880f415cd4ec5def31690bbd751de4d2179" translate="yes" xml:space="preserve">
          <source>The timing resolution of the MIDI file.</source>
          <target state="translated">MIDI文件的定时分辨率。</target>
        </trans-unit>
        <trans-unit id="94d8255f666f78ba91e4c0653d1ddca333f07432" translate="yes" xml:space="preserve">
          <source>The timing resolution of the sequence.</source>
          <target state="translated">序列的时间分辨率。</target>
        </trans-unit>
        <trans-unit id="5ea038093e385d3d5e2fd57f0725ac3f67c851e4" translate="yes" xml:space="preserve">
          <source>The title displayed in this internal frame's title bar.</source>
          <target state="translated">这个内部框架的标题栏中显示的标题。</target>
        </trans-unit>
        <trans-unit id="acaeefe50cb5c6ee79bdfe6165ed6efca1e633ed" translate="yes" xml:space="preserve">
          <source>The title for the dialog box.</source>
          <target state="translated">对话框的标题。</target>
        </trans-unit>
        <trans-unit id="3a3106a5519a4cc49f3d21712c3f6fa49becfeb4" translate="yes" xml:space="preserve">
          <source>The title may or may not be displayed, depending on the actual type of window created.</source>
          <target state="translated">根据所创建窗口的实际类型,可能会显示或不显示标题。</target>
        </trans-unit>
        <trans-unit id="f0683018b81877e833126e6d3b7e7f8110b2e217" translate="yes" xml:space="preserve">
          <source>The title of a document as specified by the &lt;code&gt;TITLE&lt;/code&gt; element in the head of the document.</source>
          <target state="translated">由文档标题中的 &lt;code&gt;TITLE&lt;/code&gt; 元素指定的文档标题。</target>
        </trans-unit>
        <trans-unit id="8120bf9b224de89c2920e1546dcda46c8b1f8843" translate="yes" xml:space="preserve">
          <source>The title pane component used in the desktop icon.</source>
          <target state="translated">桌面图标中使用的标题窗格组件。</target>
        </trans-unit>
        <trans-unit id="53048a7dfc38ea7b3d5b7194f51d45f9a8b221a2" translate="yes" xml:space="preserve">
          <source>The title the border should display.</source>
          <target state="translated">边框应该显示的标题。</target>
        </trans-unit>
        <trans-unit id="6c8e5b4d5d69012c519b74be2af0f0e1bad6f4c4" translate="yes" xml:space="preserve">
          <source>The token was a duplicate of an earlier token.</source>
          <target state="translated">这块令牌是之前一块令牌的复制品。</target>
        </trans-unit>
        <trans-unit id="469511f0f8c8e5bb2c80808eab9d90b35b66e458" translate="yes" xml:space="preserve">
          <source>The token was a duplicate of an earlier token. This is a fatal error code that may occur during context establishment. It is not used to indicate supplementary status values. The MessageProp object is used for that purpose.</source>
          <target state="translated">该令牌与先前的令牌重复。这是一个致命的错误代码,可能在上下文建立期间发生。它不用于指示补充状态值。MessageProp对象用于此目的。</target>
        </trans-unit>
        <trans-unit id="309f8befb903508c4999847b0b027aa02db2ad23" translate="yes" xml:space="preserve">
          <source>The token's validity period has expired.</source>
          <target state="translated">代币的有效期已经过期。</target>
        </trans-unit>
        <trans-unit id="c12371230e30f66f3a76ec6704bded2a17df9644" translate="yes" xml:space="preserve">
          <source>The token's validity period has expired. This is a fatal error code that may occur during context establishment. It is not used to indicate supplementary status values. The MessageProp object is used for that purpose.</source>
          <target state="translated">令牌的有效期已经过期。这是一个致命的错误代码,可能在上下文建立期间发生。它不用于指示补充状态值。MessageProp对象用于此目的。</target>
        </trans-unit>
        <trans-unit id="46bd53fc951ee54ff26208f7f7d6b401775175dc" translate="yes" xml:space="preserve">
          <source>The tool environment is not required to support annotation processors that access environmental resources, either &lt;a href=&quot;roundenvironment&quot;&gt;per round&lt;/a&gt; or &lt;a href=&quot;processingenvironment&quot;&gt;cross-round&lt;/a&gt;, in a multi-threaded fashion.</source>
          <target state="translated">不需要工具环境来支持注释处理器以多线程方式&lt;a href=&quot;roundenvironment&quot;&gt;每轮&lt;/a&gt;或&lt;a href=&quot;processingenvironment&quot;&gt;跨轮&lt;/a&gt;访问环境资源。</target>
        </trans-unit>
        <trans-unit id="475033ec07ec172731d36e8e1a8c4e34cb1c0c10" translate="yes" xml:space="preserve">
          <source>The tool uses a</source>
          <target state="translated">该工具使用的是</target>
        </trans-unit>
        <trans-unit id="90d4e3e442dfc280941229ae11524075e2227322" translate="yes" xml:space="preserve">
          <source>The tool will create an instance of a doclet using the no-arg constructor of the doclet class.</source>
          <target state="translated">该工具将使用doclet类的no-arg构造函数创建一个doclet的实例。</target>
        </trans-unit>
        <trans-unit id="60edabc59c6f9e62a5a0fdea67fe30d15095591d" translate="yes" xml:space="preserve">
          <source>The tooltip text displayed on the approve button when a directory is selected and the current selection mode is FILES_ONLY.</source>
          <target state="translated">当选择目录且当前选择模式为FILES_ONLY时,批准按钮上显示的工具提示文字。</target>
        </trans-unit>
        <trans-unit id="6ee07dce8496ccc8327ec779a3d953aaa0190c20" translate="yes" xml:space="preserve">
          <source>The top input tray in the printer.</source>
          <target state="translated">打印机顶部的输入托盘。</target>
        </trans-unit>
        <trans-unit id="401590292bf1267b8c693854dc6321d52720a8be" translate="yes" xml:space="preserve">
          <source>The top inset of the border.</source>
          <target state="translated">边框的顶部镶边。</target>
        </trans-unit>
        <trans-unit id="40ca45217a397acf3cb9dde5c1b466e62f00362e" translate="yes" xml:space="preserve">
          <source>The top level representation of a documentation comment.</source>
          <target state="translated">文档评论的顶层表示。</target>
        </trans-unit>
        <trans-unit id="42a671ce68c829c9c3682af0e642fe256fbef14d" translate="yes" xml:space="preserve">
          <source>The top-level error handler that reacts to otherwise uncaught exceptions does not print out a message or otherwise notify the application if the uncaught exception is an instance of &lt;code&gt;ThreadDeath&lt;/code&gt;.</source>
          <target state="translated">如果未捕获的异常是 &lt;code&gt;ThreadDeath&lt;/code&gt; 的实例，则对未捕获的异常做出反应的顶级错误处理程序不会打印出消息或以其他方式通知应用程序。</target>
        </trans-unit>
        <trans-unit id="46f6d47ae13aad5695f239448bb57766c13e2aa1" translate="yes" xml:space="preserve">
          <source>The total length of the message in bytes (the status byte plus any data bytes)</source>
          <target state="translated">消息的总长度,以字节为单位(状态字节加上任何数据字节)。</target>
        </trans-unit>
        <trans-unit id="17fecdd4ddcdb8672f8d5932951da08117bd4dd0" translate="yes" xml:space="preserve">
          <source>The total number of bits in the pixel.</source>
          <target state="translated">像素的总位数。</target>
        </trans-unit>
        <trans-unit id="05917e7da6988078054932792c0c5486cd4b1b28" translate="yes" xml:space="preserve">
          <source>The total number of points.</source>
          <target state="translated">的总分。</target>
        </trans-unit>
        <trans-unit id="f62e7ead83f7b630f60dc2cbbcf456264118e6c3" translate="yes" xml:space="preserve">
          <source>The total number of points. The value of &lt;code&gt;npoints&lt;/code&gt; represents the number of valid points in this &lt;code&gt;Polygon&lt;/code&gt; and might be less than the number of elements in &lt;a href=&quot;#xpoints&quot;&gt;&lt;code&gt;xpoints&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#ypoints&quot;&gt;&lt;code&gt;ypoints&lt;/code&gt;&lt;/a&gt;. This value can be 0.</source>
          <target state="translated">总点数。值 &lt;code&gt;npoints&lt;/code&gt; 表示在此有效点数 &lt;code&gt;Polygon&lt;/code&gt; 并且可能小于元素的数量&lt;a href=&quot;#xpoints&quot;&gt; &lt;code&gt;xpoints&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#ypoints&quot;&gt; &lt;code&gt;ypoints&lt;/code&gt; 中&lt;/a&gt;。该值可以为0。</target>
        </trans-unit>
        <trans-unit id="7ad0ea114ec1ddf71f5fe2d46d0cb9e7197a57a0" translate="yes" xml:space="preserve">
          <source>The total number of significant digits in</source>
          <target state="translated">中的有效数字的总数</target>
        </trans-unit>
        <trans-unit id="e8f848286d69d23ec4b7259715c33925c847df30" translate="yes" xml:space="preserve">
          <source>The total size of the document including all external resources, this number might change as a document is being parsed if references to more external resources are seen.</source>
          <target state="translated">包括所有外部资源在内的文档总大小,如果看到更多外部资源的引用,这个数字可能会随着文档的解析而改变。</target>
        </trans-unit>
        <trans-unit id="1a52eb79799de442c045f35d0474d14d18b85672" translate="yes" xml:space="preserve">
          <source>The total size of the document including all external resources, this number might change as a document is being parsed if references to more external resources are seen. A value of &lt;code&gt;0&lt;/code&gt; is returned if the total size cannot be determined or estimated.</source>
          <target state="translated">文档的总大小（包括所有外部资源），如果看到对更多外部资源的引用，此数字可能会随着文档的解析而改变。如果无法确定或估计总大小，则返回 &lt;code&gt;0&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="c7cfb3d21fdcbe867349c0a9b8497b711e26d212" translate="yes" xml:space="preserve">
          <source>The total size of the list.</source>
          <target state="translated">名单的总规模。</target>
        </trans-unit>
        <trans-unit id="6b5d7d5da983bf443ff8b0d755377059b977f35d" translate="yes" xml:space="preserve">
          <source>The tracking value is multiplied by the font point size and passed through the font transform to determine an additional amount to add to the advance of each glyph cluster. Positive tracking values will inhibit formation of optional ligatures. Tracking values are typically between &lt;code&gt;-0.1&lt;/code&gt; and &lt;code&gt;0.3&lt;/code&gt;; values outside this range are generally not desirable.</source>
          <target state="translated">跟踪值乘以字体点大小，然后通过字体变换来确定要添加到每个字形簇前移的附加量。正跟踪值将抑制可选连字的形成。跟踪值通常在 &lt;code&gt;-0.1&lt;/code&gt; 和 &lt;code&gt;0.3&lt;/code&gt; 之间；通常不希望超出此范围的值。</target>
        </trans-unit>
        <trans-unit id="703deab7518e04de6cf78487901807570cefd5e8" translate="yes" xml:space="preserve">
          <source>The transaction branch has been heuristically committed and rolled back.</source>
          <target state="translated">交易枝节的已启发式投入和回滚。</target>
        </trans-unit>
        <trans-unit id="14b4d7ed7740cc11b56bff202adfa6d5c222e033" translate="yes" xml:space="preserve">
          <source>The transaction branch has been heuristically committed.</source>
          <target state="translated">交易分支已被启发式承诺。</target>
        </trans-unit>
        <trans-unit id="da0babcbf37a3af594d97dc69b6bf086d7544d2c" translate="yes" xml:space="preserve">
          <source>The transaction branch has been heuristically rolled back.</source>
          <target state="translated">交易分支已被启发式回滚。</target>
        </trans-unit>
        <trans-unit id="050d9fced3f39f16dd7abd1393e7514ef1ce5372" translate="yes" xml:space="preserve">
          <source>The transaction branch has been read-only and has been committed.</source>
          <target state="translated">交易分支已为只读,并已提交。</target>
        </trans-unit>
        <trans-unit id="33db632dad51ea9ae41ea3cf6edbcd4f22719c4e" translate="yes" xml:space="preserve">
          <source>The transaction branch may have been heuristically completed.</source>
          <target state="translated">交易分支可能已经启发式完成。</target>
        </trans-unit>
        <trans-unit id="861c2375e08c3476b0904853fa18832f2c36bb4e" translate="yes" xml:space="preserve">
          <source>The transaction branch was read-only and has been committed.</source>
          <target state="translated">交易分支是只读的,已经提交。</target>
        </trans-unit>
        <trans-unit id="b793d2f86bb5ddf2929ec67d8f137dd2ab9dd816" translate="yes" xml:space="preserve">
          <source>The transaction work has been prepared normally.</source>
          <target state="translated">交易工作已正常准备。</target>
        </trans-unit>
        <trans-unit id="9df96b47070ad60931e75c25b6080817de2717a9" translate="yes" xml:space="preserve">
          <source>The transfer &lt;em&gt;will not necessarily&lt;/em&gt; have been completed at the return of this call (i.e. the call does not block waiting for the drop). The transfer will take place through the Swing implementation of the &lt;code&gt;java.awt.dnd&lt;/code&gt; mechanism, requiring no further effort from the developer. The &lt;code&gt;exportDone&lt;/code&gt; method will be called when the transfer has completed.</source>
          <target state="translated">转移&lt;em&gt;不一定&lt;/em&gt;会在此呼叫返回时完成（即，呼叫不会阻塞等待挂断）。转移将通过 &lt;code&gt;java.awt.dnd&lt;/code&gt; 机制的Swing实现进行，而无需开发人员进一步的努力。该 &lt;code&gt;exportDone&lt;/code&gt; 当传输完成的方法将被调用。</target>
        </trans-unit>
        <trans-unit id="a8c4e8eb43c79370beb6a0b967d482c111e1ea42" translate="yes" xml:space="preserve">
          <source>The transfer will take place using the &lt;code&gt;java.awt.datatransfer&lt;/code&gt; mechanism, requiring no further effort from the developer. Any data transfer &lt;em&gt;will&lt;/em&gt; be complete and the &lt;code&gt;exportDone&lt;/code&gt; method will be called with the action that occurred, before this method returns. Should the clipboard be unavailable when attempting to place data on it, the &lt;code&gt;IllegalStateException&lt;/code&gt; thrown by &lt;a href=&quot;../../../java.datatransfer/java/awt/datatransfer/clipboard#setContents(java.awt.datatransfer.Transferable,java.awt.datatransfer.ClipboardOwner)&quot;&gt;&lt;code&gt;Clipboard.setContents(Transferable, ClipboardOwner)&lt;/code&gt;&lt;/a&gt; will be propagated through this method. However, &lt;code&gt;exportDone&lt;/code&gt; will first be called with an action of &lt;code&gt;NONE&lt;/code&gt; for consistency.</source>
          <target state="translated">传输将使用 &lt;code&gt;java.awt.datatransfer&lt;/code&gt; 机制进行，无需开发人员进一步的努力。任何数据传输&lt;em&gt;都&lt;/em&gt;将完成，并且在此方法返回之前，将使用发生的操作调用 &lt;code&gt;exportDone&lt;/code&gt; 方法。如果尝试在剪贴板上放置数据时剪贴板不可用，则&lt;a href=&quot;../../../java.datatransfer/java/awt/datatransfer/clipboard#setContents(java.awt.datatransfer.Transferable,java.awt.datatransfer.ClipboardOwner)&quot;&gt; &lt;code&gt;Clipboard.setContents(Transferable, ClipboardOwner)&lt;/code&gt; &lt;/a&gt;抛出的 &lt;code&gt;IllegalStateException&lt;/code&gt; 将通过此方法传播。但是，为保持一致性，将首先使用 &lt;code&gt;NONE&lt;/code&gt; 动作调用 &lt;code&gt;exportDone&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d87f3db630bd4bc1d40103fa67e3e1b3f2db8546" translate="yes" xml:space="preserve">
          <source>The transformation API throw three types of specialized exceptions. A &lt;a href=&quot;transformerfactoryconfigurationerror&quot;&gt;&lt;code&gt;TransformerFactoryConfigurationError&lt;/code&gt;&lt;/a&gt; is parallel to the &lt;a href=&quot;../parsers/factoryconfigurationerror&quot;&gt;&lt;code&gt;FactoryConfigurationError&lt;/code&gt;&lt;/a&gt;, and is thrown when a configuration problem with the TransformerFactory exists. This error will typically be thrown when the transformation factory class specified with the &quot;javax.xml.transform.TransformerFactory&quot; system property cannot be found or instantiated.</source>
          <target state="translated">转换API会抛出三种类型的特殊异常。甲&lt;a href=&quot;transformerfactoryconfigurationerror&quot;&gt; &lt;code&gt;TransformerFactoryConfigurationError&lt;/code&gt; &lt;/a&gt;平行于&lt;a href=&quot;../parsers/factoryconfigurationerror&quot;&gt; &lt;code&gt;FactoryConfigurationError&lt;/code&gt; &lt;/a&gt;，并且当与所述的TransformerFactory的结构存在问题，则抛出。当找不到或实例化用&amp;ldquo; javax.xml.transform.TransformerFactory&amp;rdquo;系统属性指定的转换工厂类时，通常会引发此错误。</target>
        </trans-unit>
        <trans-unit id="fe701db82a538a1330d479e42d071cac878afdf3" translate="yes" xml:space="preserve">
          <source>The transformed &lt;code&gt;Raster&lt;/code&gt;.</source>
          <target state="translated">转换后的 &lt;code&gt;Raster&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d806ee0a87e3109095fc859ea8eb5cc5532045bc" translate="yes" xml:space="preserve">
          <source>The transformer must continue to try and provide normal transformation after invoking this method. It should still be possible for the application to process the document through to the end if no other errors are encountered.</source>
          <target state="translated">变换器在调用此方法后必须继续尝试并提供正常的转换。如果没有遇到其他错误,应用程序仍然可以将文档处理到底。</target>
        </trans-unit>
        <trans-unit id="5fa423bbef1d4f0ed7a551ce1858b400fcccf4df" translate="yes" xml:space="preserve">
          <source>The transition may be represented as occurring at 24:00.</source>
          <target state="translated">过渡可以表示为发生在24:00。</target>
        </trans-unit>
        <trans-unit id="0bbbaf76aec7f9bf6cba6b78d515bbb3bf05d201" translate="yes" xml:space="preserve">
          <source>The translation between a parent and child Raster may be determined by subtracting the child's sampleModelTranslateX and sampleModelTranslateY values from those of the parent.</source>
          <target state="translated">父代和子代Raster之间的翻译可以通过从父代的样本ModelTranslateX和样本ModelTranslateY值中减去子代的样本ModelTranslateX值来确定。</target>
        </trans-unit>
        <trans-unit id="4d3c8c5c72b6b96fb6f59ecad375ecd5b5124beb" translate="yes" xml:space="preserve">
          <source>The translation from pixel sample values to color/alpha components for display or processing purposes is based on a one-to-one correspondence of samples to components. Depending on the transfer type used to create an instance of &lt;code&gt;ComponentColorModel&lt;/code&gt;, the pixel sample values represented by that instance may be signed or unsigned and may be of integral type or float or double (see below for details). The translation from sample values to normalized color/alpha components must follow certain rules. For float and double samples, the translation is an identity, i.e. normalized component values are equal to the corresponding sample values. For integral samples, the translation should be only a simple scale and offset, where the scale and offset constants may be different for each component. The result of applying the scale and offset constants is a set of color/alpha component values, which are guaranteed to fall within a certain range. Typically, the range for a color component will be the range defined by the &lt;code&gt;getMinValue&lt;/code&gt; and &lt;code&gt;getMaxValue&lt;/code&gt; methods of the &lt;code&gt;ColorSpace&lt;/code&gt; class. The range for an alpha component should be 0.0 to 1.0.</source>
          <target state="translated">用于显示或处理目的，从像素样本值到颜色/ alpha分量的转换是基于样本与分量的一一对应关系。取决于用于创建 &lt;code&gt;ComponentColorModel&lt;/code&gt; 实例的传输类型，由该实例表示的像素样本值可以是带符号的也可以是无符号的，并且可以是整数类型，也可以是浮点型或双精度型（有关详情，请参见下文）。从样本值到标准化颜色/ alpha分量的转换必须遵循某些规则。对于浮点和双精度样本，转换是一个标识，即，归一化的分量值等于相应的样本值。对于积分样本，平移应仅是简单的比例和偏移量，其中比例和偏移量常数对于每个组件可能都不同。应用比例和偏移常量的结果是一组颜色/ alpha分量值，这些值保证在一定范围内。通常，颜色分量的范围将是由 &lt;code&gt;getMinValue&lt;/code&gt; 和 &lt;code&gt;getMaxValue&lt;/code&gt; 定义的范围 &lt;code&gt;ColorSpace&lt;/code&gt; 类的方法。 alpha分量的范围应为0.0到1.0。</target>
        </trans-unit>
        <trans-unit id="b65a261d80d53542a10bedce8edbc81f70d91963" translate="yes" xml:space="preserve">
          <source>The translation from pixel values to color/alpha components for display or processing purposes is a one-to-one correspondence of samples to components. A &lt;code&gt;DirectColorModel&lt;/code&gt; is typically used with image data which uses masks to define packed samples. For example, a &lt;code&gt;DirectColorModel&lt;/code&gt; can be used in conjunction with a &lt;code&gt;SinglePixelPackedSampleModel&lt;/code&gt; to construct a &lt;a href=&quot;bufferedimage&quot;&gt;&lt;code&gt;BufferedImage&lt;/code&gt;&lt;/a&gt;. Normally the masks used by the &lt;a href=&quot;samplemodel&quot;&gt;&lt;code&gt;SampleModel&lt;/code&gt;&lt;/a&gt; and the &lt;code&gt;ColorModel&lt;/code&gt; would be the same. However, if they are different, the color interpretation of pixel data will be done according to the masks of the &lt;code&gt;ColorModel&lt;/code&gt;.</source>
          <target state="translated">用于显示或处理目的，从像素值到颜色/ alpha分量的转换是样本与分量的一一对应关系。甲 &lt;code&gt;DirectColorModel&lt;/code&gt; 通常与图像数据，它使用掩模来定义填充样品。例如，可以将 &lt;code&gt;DirectColorModel&lt;/code&gt; 与 &lt;code&gt;SinglePixelPackedSampleModel&lt;/code&gt; 结合使用以构造&lt;a href=&quot;bufferedimage&quot;&gt; &lt;code&gt;BufferedImage&lt;/code&gt; &lt;/a&gt;。通常，&lt;a href=&quot;samplemodel&quot;&gt; &lt;code&gt;SampleModel&lt;/code&gt; &lt;/a&gt;和 &lt;code&gt;ColorModel&lt;/code&gt; 使用的蒙版是相同的。但是，如果它们不同，则将根据 &lt;code&gt;ColorModel&lt;/code&gt; 的蒙版对像素数据进行颜色解释。</target>
        </trans-unit>
        <trans-unit id="168b1d4ef4c25a61d82bab781cf817cb6ee6ff78" translate="yes" xml:space="preserve">
          <source>The translation from pixel values to color/alpha components for display or processing purposes is a one-to-one correspondence of samples to components. A &lt;code&gt;PackedColorModel&lt;/code&gt; is typically used with image data that uses masks to define packed samples. For example, a &lt;code&gt;PackedColorModel&lt;/code&gt; can be used in conjunction with a &lt;a href=&quot;singlepixelpackedsamplemodel&quot;&gt;&lt;code&gt;SinglePixelPackedSampleModel&lt;/code&gt;&lt;/a&gt; to construct a &lt;a href=&quot;bufferedimage&quot;&gt;&lt;code&gt;BufferedImage&lt;/code&gt;&lt;/a&gt;. Normally the masks used by the &lt;a href=&quot;samplemodel&quot;&gt;&lt;code&gt;SampleModel&lt;/code&gt;&lt;/a&gt; and the &lt;code&gt;ColorModel&lt;/code&gt; would be the same. However, if they are different, the color interpretation of pixel data is done according to the masks of the &lt;code&gt;ColorModel&lt;/code&gt;.</source>
          <target state="translated">用于显示或处理目的，从像素值到颜色/ alpha分量的转换是样本与分量的一一对应关系。阿 &lt;code&gt;PackedColorModel&lt;/code&gt; 通常与图像数据，使用掩模来定义填充样品。例如，可以将 &lt;code&gt;PackedColorModel&lt;/code&gt; 与&lt;a href=&quot;singlepixelpackedsamplemodel&quot;&gt; &lt;code&gt;SinglePixelPackedSampleModel&lt;/code&gt; &lt;/a&gt;结合使用以构造&lt;a href=&quot;bufferedimage&quot;&gt; &lt;code&gt;BufferedImage&lt;/code&gt; &lt;/a&gt;。通常，&lt;a href=&quot;samplemodel&quot;&gt; &lt;code&gt;SampleModel&lt;/code&gt; &lt;/a&gt;和 &lt;code&gt;ColorModel&lt;/code&gt; 使用的蒙版是相同的。但是，如果它们不同，则根据 &lt;code&gt;ColorModel&lt;/code&gt; 的蒙版对像素数据进行颜色解释。</target>
        </trans-unit>
        <trans-unit id="b5d7a0a9a5aa913b72a0d7dce956d6a2d0147d1c" translate="yes" xml:space="preserve">
          <source>The translucency levels of individual pixels may also be effected by the alpha component of their color (see &lt;a href=&quot;#setBackground(java.awt.Color)&quot;&gt;&lt;code&gt;setBackground(Color)&lt;/code&gt;&lt;/a&gt;) and the current shape of this window (see &lt;a href=&quot;#setShape(java.awt.Shape)&quot;&gt;&lt;code&gt;setShape(Shape)&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">各个像素的半透明级别也可能受其颜色的alpha分量（请参见&lt;a href=&quot;#setBackground(java.awt.Color)&quot;&gt; &lt;code&gt;setBackground(Color)&lt;/code&gt; &lt;/a&gt;）和此窗口的当前形状（请参见&lt;a href=&quot;#setShape(java.awt.Shape)&quot;&gt; &lt;code&gt;setShape(Shape)&lt;/code&gt; &lt;/a&gt;）的影响。</target>
        </trans-unit>
        <trans-unit id="2749ff4c08edcd16b069e9cf4d2ed0371273c113" translate="yes" xml:space="preserve">
          <source>The translucency levels of individual pixels may also be effected by the alpha component of their color (see &lt;a href=&quot;#setBackground(java.awt.Color)&quot;&gt;&lt;code&gt;setBackground(Color)&lt;/code&gt;&lt;/a&gt;) and the opacity value (see &lt;a href=&quot;#setOpacity(float)&quot;&gt;&lt;code&gt;setOpacity(float)&lt;/code&gt;&lt;/a&gt;). See &lt;a href=&quot;graphicsdevice.windowtranslucency&quot;&gt;&lt;code&gt;GraphicsDevice.WindowTranslucency&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">各个像素的半透明级别也可能受其颜色的alpha分量（请参见&lt;a href=&quot;#setBackground(java.awt.Color)&quot;&gt; &lt;code&gt;setBackground(Color)&lt;/code&gt; &lt;/a&gt;）和不透明度值（请参见&lt;a href=&quot;#setOpacity(float)&quot;&gt; &lt;code&gt;setOpacity(float)&lt;/code&gt; &lt;/a&gt;）影响。有关更多详细信息，请参见&lt;a href=&quot;graphicsdevice.windowtranslucency&quot;&gt; &lt;code&gt;GraphicsDevice.WindowTranslucency&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7c1306905f8e445cab20995e9caae10676aed4f2" translate="yes" xml:space="preserve">
          <source>The transparency of an &lt;code&gt;IndexColorModel&lt;/code&gt; object is determined by examining the alpha components of the colors in the colormap and choosing the most specific value after considering the optional alpha values and any transparent index specified. The transparency value is &lt;code&gt;Transparency.OPAQUE&lt;/code&gt; only if all valid colors in the colormap are opaque and there is no valid transparent pixel. If all valid colors in the colormap are either completely opaque (alpha = 1.0) or completely transparent (alpha = 0.0), which typically occurs when a valid transparent pixel is specified, the value is &lt;code&gt;Transparency.BITMASK&lt;/code&gt;. Otherwise, the value is &lt;code&gt;Transparency.TRANSLUCENT&lt;/code&gt;, indicating that some valid color has an alpha component that is neither completely transparent nor completely opaque (0.0 &amp;lt; alpha &amp;lt; 1.0).</source>
          <target state="translated">一个的透明度 &lt;code&gt;IndexColorModel&lt;/code&gt; 的目的是通过检查颜色的alpha分量在颜色表和考虑可选的alpha值，并且指定的任何透明索引后选择最具体的值来确定。仅当颜色图中所有有效的颜色都是不透明的并且没有有效的透明像素时，透明度值才是 &lt;code&gt;Transparency.OPAQUE&lt;/code&gt; 。如果颜色图中的所有有效颜色都是完全不透明（alpha = 1.0）或完全透明（alpha = 0.0）（通常在指定有效的透明像素时发生），则值为 &lt;code&gt;Transparency.BITMASK&lt;/code&gt; 。否则，值为 &lt;code&gt;Transparency.TRANSLUCENT&lt;/code&gt; ，表示某些有效颜色的alpha分量既不完全透明也不完全不透明（0.0 &amp;lt;alpha &amp;lt;1.0）。</target>
        </trans-unit>
        <trans-unit id="c891870f2397ea5ffc5f4c8aade7bd8d1dab8055" translate="yes" xml:space="preserve">
          <source>The transparency value with which this image was created.</source>
          <target state="translated">创建此图像的透明度值。</target>
        </trans-unit>
        <trans-unit id="6338d039f89f1539f2243ca8c36cfd3178456a44" translate="yes" xml:space="preserve">
          <source>The transport service capabilities.</source>
          <target state="translated">运输服务能力。</target>
        </trans-unit>
        <trans-unit id="e081237b427051c5333deb296d65a823a7c2908e" translate="yes" xml:space="preserve">
          <source>The transport= value</source>
          <target state="translated">运输=价值</target>
        </trans-unit>
        <trans-unit id="a2e25a1118ce8877391b5f01b4a57a8df400e4ba" translate="yes" xml:space="preserve">
          <source>The tree has no model</source>
          <target state="translated">这棵树没有模型</target>
        </trans-unit>
        <trans-unit id="dd6f791fb336426f0b5c534f66eae3384f79ccf9" translate="yes" xml:space="preserve">
          <source>The trigger.</source>
          <target state="translated">扳机。</target>
        </trans-unit>
        <trans-unit id="19d46a2a9ae7b495f51fc356027feaf3becd628d" translate="yes" xml:space="preserve">
          <source>The truth value returned by this method is equivalent to: &lt;code&gt;getAnnotation(annotationClass) != null&lt;/code&gt;</source>
          <target state="translated">此方法返回的真值等效于： &lt;code&gt;getAnnotation(annotationClass) != null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8c46d6198c957c6c25b841cf0f4dfb6d6cb250b3" translate="yes" xml:space="preserve">
          <source>The ttl &lt;b&gt;must&lt;/b&gt; be in the range &lt;code&gt; 0 &amp;lt;= ttl &amp;lt;=
 255&lt;/code&gt; or an &lt;code&gt;IllegalArgumentException&lt;/code&gt; will be thrown. Multicast packets sent with a TTL of &lt;code&gt;0&lt;/code&gt; are not transmitted on the network but may be delivered locally.</source>
          <target state="translated">ttl&lt;b&gt;必须&lt;/b&gt;在 &lt;code&gt; 0 &amp;lt;= ttl &amp;lt;= 255&lt;/code&gt; 范围内，否则将抛出 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 。TTL为 &lt;code&gt;0&lt;/code&gt; 的多播数据包不在网络上传输，但可以在本地传输。</target>
        </trans-unit>
        <trans-unit id="2485bd279a135141b31dd6331097ba469508ddf1" translate="yes" xml:space="preserve">
          <source>The ttl &lt;b&gt;must&lt;/b&gt; be in the range &lt;code&gt;0 &amp;lt;= ttl &amp;lt;=
 255&lt;/code&gt; or an &lt;code&gt;IllegalArgumentException&lt;/code&gt; will be thrown. Multicast packets sent with a TTL of &lt;code&gt;0&lt;/code&gt; are not transmitted on the network but may be delivered locally.</source>
          <target state="translated">ttl &lt;b&gt;必须&lt;/b&gt;在 &lt;code&gt;0 &amp;lt;= ttl &amp;lt;= 255&lt;/code&gt; 范围内，否则将抛出 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 。TTL为 &lt;code&gt;0&lt;/code&gt; 的多播数据包不在网络上传输，但可以在本地传送。</target>
        </trans-unit>
        <trans-unit id="6940391f4a3596501f2f3676ceed69996fe5b256" translate="yes" xml:space="preserve">
          <source>The ttl is an &lt;b&gt;unsigned&lt;/b&gt; 8-bit quantity, and so &lt;b&gt;must&lt;/b&gt; be in the range &lt;code&gt;0 &amp;lt;= ttl &amp;lt;= 0xFF &lt;/code&gt;.</source>
          <target state="translated">ttl是一个&lt;b&gt;无符号的&lt;/b&gt; 8位数字，因此&lt;b&gt;必须&lt;/b&gt;在 &lt;code&gt;0 &amp;lt;= ttl &amp;lt;= 0xFF &lt;/code&gt; 的范围内。</target>
        </trans-unit>
        <trans-unit id="969fb09f0d47cbd4ef59365982ee80f259c1e668" translate="yes" xml:space="preserve">
          <source>The twelve methods described above are summarized in the following table:</source>
          <target state="translated">上述十二种方法归纳在下表中。</target>
        </trans-unit>
        <trans-unit id="60737d50d1714cdb7c9a212137135f035cb7e133" translate="yes" xml:space="preserve">
          <source>The two &lt;code&gt;Component&lt;/code&gt;s in a split pane can be aligned left to right using &lt;code&gt;JSplitPane.HORIZONTAL_SPLIT&lt;/code&gt;, or top to bottom using &lt;code&gt;JSplitPane.VERTICAL_SPLIT&lt;/code&gt;. The preferred way to change the size of the &lt;code&gt;Component&lt;/code&gt;s is to invoke &lt;code&gt;setDividerLocation&lt;/code&gt; where &lt;code&gt;location&lt;/code&gt; is either the new x or y position, depending on the orientation of the &lt;code&gt;JSplitPane&lt;/code&gt;.</source>
          <target state="translated">拆分窗格中的两个 &lt;code&gt;Component&lt;/code&gt; 可以使用 &lt;code&gt;JSplitPane.HORIZONTAL_SPLIT&lt;/code&gt; 从左到右对齐，或者使用 &lt;code&gt;JSplitPane.VERTICAL_SPLIT&lt;/code&gt; 从上到下对齐。更改 &lt;code&gt;Component&lt;/code&gt; 大小的首选方法是调用 &lt;code&gt;setDividerLocation&lt;/code&gt; ，其中 &lt;code&gt;location&lt;/code&gt; 是新的x或y位置，具体取决于 &lt;code&gt;JSplitPane&lt;/code&gt; 的方向。</target>
        </trans-unit>
        <trans-unit id="a3593155b51237a7085bf75da2140fc0fe3e8c66" translate="yes" xml:space="preserve">
          <source>The two calls have the same effect.</source>
          <target state="translated">这两个电话的效果是一样的。</target>
        </trans-unit>
        <trans-unit id="b92a8d153cce49ff845ddf50531191cd3a963be7" translate="yes" xml:space="preserve">
          <source>The two cases (&quot;ja&quot;, &quot;JP&quot;, &quot;JP&quot;) and (&quot;th&quot;, &quot;TH&quot;, &quot;TH&quot;) are handled specially, see &lt;a href=&quot;#special_cases_constructor&quot;&gt;Special Cases&lt;/a&gt; for more information.</source>
          <target state="translated">这两种情况（&amp;ldquo; ja&amp;rdquo;，&amp;ldquo; JP&amp;rdquo;，&amp;ldquo; JP&amp;rdquo;）和（&amp;ldquo; th&amp;rdquo;，&amp;ldquo; TH&amp;rdquo;，&amp;ldquo; TH&amp;rdquo;）是专门处理的，有关更多信息，请参见&lt;a href=&quot;#special_cases_constructor&quot;&gt;特殊情况&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="28393cbfd67002d6ad36a08762b2e38653599b68" translate="yes" xml:space="preserve">
          <source>The two characters are the same (as compared by the &lt;code&gt;==&lt;/code&gt; operator)</source>
          <target state="translated">这两个字符相同（与 &lt;code&gt;==&lt;/code&gt; 运算符相比）</target>
        </trans-unit>
        <trans-unit id="733cbbaea42ad75e1ffe40db5e03f1fed7b55f41" translate="yes" xml:space="preserve">
          <source>The two coordinate array sections can be exactly the same or can be overlapping sections of the same array without affecting the validity of the results. This method ensures that no source coordinates are overwritten by a previous operation before they can be transformed. The coordinates are stored in the arrays starting at the indicated offset in the order &lt;code&gt;[x0, y0, x1, y1, ..., xn, yn]&lt;/code&gt;.</source>
          <target state="translated">两个坐标数组部分可以完全相同，也可以是同一数组的重叠部分，而不会影响结果的有效性。此方法可确保在转换源坐标之前，不会将其由先前的操作覆盖。坐标以 &lt;code&gt;[x0, y0, x1, y1, ..., xn, yn]&lt;/code&gt; 的顺序从指定的偏移量开始存储在数组中。</target>
        </trans-unit>
        <trans-unit id="25387bc728d28df98473fda65f0865bfbdd9186f" translate="yes" xml:space="preserve">
          <source>The two files are the same size, and every byte in the first file is identical to the corresponding byte in the second file.</source>
          <target state="translated">两个文件的大小是一样的,第一个文件中的每一个字节都与第二个文件中的相应字节相同。</target>
        </trans-unit>
        <trans-unit id="f19211fbe1e7f4c1e87ed754cadc6b0cc14be4e6" translate="yes" xml:space="preserve">
          <source>The two nodes are disconnected.</source>
          <target state="translated">这两个节点是断开的。</target>
        </trans-unit>
        <trans-unit id="f398c8744bfdea0ef40d2e2e1377fe86aabbce87" translate="yes" xml:space="preserve">
          <source>The two nodes are disconnected. Order between disconnected nodes is always implementation-specific.</source>
          <target state="translated">这两个节点是断开的。断开连接的节点之间的顺序总是针对特定的实现。</target>
        </trans-unit>
        <trans-unit id="1ec974b380762a0bf9692b16ac0cfa7083a8a76b" translate="yes" xml:space="preserve">
          <source>The two nodes are of the same type.</source>
          <target state="translated">这两个节点是同一类型的。</target>
        </trans-unit>
        <trans-unit id="1416b8437ae024eb2f580e7eda38b503e80d7f1f" translate="yes" xml:space="preserve">
          <source>The two paths locate the &lt;a href=&quot;#isSameFile(java.nio.file.Path,java.nio.file.Path)&quot;&gt;same file&lt;/a&gt;, even if two &lt;a href=&quot;path#equals(java.lang.Object)&quot;&gt;equal&lt;/a&gt; paths locate a file does not exist, or</source>
          <target state="translated">即使两个&lt;a href=&quot;path#equals(java.lang.Object)&quot;&gt;相等的&lt;/a&gt;路径都找到一个文件，这两个路径也可以找到&lt;a href=&quot;#isSameFile(java.nio.file.Path,java.nio.file.Path)&quot;&gt;同&lt;/a&gt;一个文件，或者</target>
        </trans-unit>
        <trans-unit id="4a8e8cdc02eb816448907e6ad7e73c37517a03bf" translate="yes" xml:space="preserve">
          <source>The two possible authentication types for a resource.</source>
          <target state="translated">资源的两种可能的认证类型。</target>
        </trans-unit>
        <trans-unit id="8562722983b5297a255d72d065fc4efeeada15b3" translate="yes" xml:space="preserve">
          <source>The two sequences of remaining elements, considered independently of their starting positions, are pointwise equal.</source>
          <target state="translated">剩余元素的两个序列,不考虑它们的起始位置,在点上是相等的。</target>
        </trans-unit>
        <trans-unit id="d9e7a9794b9c62912ab9b974fd3e586ad8ce077c" translate="yes" xml:space="preserve">
          <source>The two sequences of remaining elements, considered independently of their starting positions, are pointwise equal. This method considers two double elements &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; to be equal if &lt;code&gt;(a == b) || (Double.isNaN(a) &amp;amp;&amp;amp; Double.isNaN(b))&lt;/code&gt;. The values &lt;code&gt;-0.0&lt;/code&gt; and &lt;code&gt;+0.0&lt;/code&gt; are considered to be equal, unlike &lt;a href=&quot;../lang/double#equals(java.lang.Object)&quot;&gt;&lt;code&gt;Double.equals(Object)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">独立于其起始位置考虑的其余元素的两个序列在​​点上相等。如果 &lt;code&gt;(a == b) || (Double.isNaN(a) &amp;amp;&amp;amp; Double.isNaN(b))&lt;/code&gt; 则此方法认为两个双精度元素 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 相等。（Double.isNaN（a）&amp;amp;&amp;amp; Double.isNaN（b））。与&lt;a href=&quot;../lang/double#equals(java.lang.Object)&quot;&gt; &lt;code&gt;Double.equals(Object)&lt;/code&gt; &lt;/a&gt;不同，值 &lt;code&gt;-0.0&lt;/code&gt; 和 &lt;code&gt;+0.0&lt;/code&gt; 被认为是相等的。</target>
        </trans-unit>
        <trans-unit id="1e9cc57517a9438e11a17414782fcda2ca6c93d7" translate="yes" xml:space="preserve">
          <source>The two sequences of remaining elements, considered independently of their starting positions, are pointwise equal. This method considers two double elements &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; to be equal if &lt;code&gt;(a == b) || (Double.isNaN(a) &amp;amp;&amp;amp; Double.isNaN(b))&lt;/code&gt;. The values &lt;code&gt;-0.0&lt;/code&gt; and &lt;code&gt;+0.0&lt;/code&gt; are considered to be equal, unlike &lt;a href=&quot;../lang/double#equals-java.lang.Object-&quot;&gt;&lt;code&gt;Double.equals(Object)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">独立于其起始位置考虑的其余元素的两个序列在​​点上相等。如果 &lt;code&gt;(a == b) || (Double.isNaN(a) &amp;amp;&amp;amp; Double.isNaN(b))&lt;/code&gt; 则此方法认为两个双精度元素 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 相等。（Double.isNaN（a）&amp;amp;&amp;amp; Double.isNaN（b））。与&lt;a href=&quot;../lang/double#equals-java.lang.Object-&quot;&gt; &lt;code&gt;Double.equals(Object)&lt;/code&gt; &lt;/a&gt;不同，值 &lt;code&gt;-0.0&lt;/code&gt; 和 &lt;code&gt;+0.0&lt;/code&gt; 被认为是相等的。</target>
        </trans-unit>
        <trans-unit id="677d0a0fc0aa5495b5b9a1ef2701a071bddcad42" translate="yes" xml:space="preserve">
          <source>The two sequences of remaining elements, considered independently of their starting positions, are pointwise equal. This method considers two float elements &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; to be equal if &lt;code&gt;(a == b) || (Float.isNaN(a) &amp;amp;&amp;amp; Float.isNaN(b))&lt;/code&gt;. The values &lt;code&gt;-0.0&lt;/code&gt; and &lt;code&gt;+0.0&lt;/code&gt; are considered to be equal, unlike &lt;a href=&quot;../lang/float#equals(java.lang.Object)&quot;&gt;&lt;code&gt;Float.equals(Object)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">独立于其起始位置考虑的其余元素的两个序列在​​点上相等。如果 &lt;code&gt;(a == b) || (Float.isNaN(a) &amp;amp;&amp;amp; Float.isNaN(b))&lt;/code&gt; 则此方法认为两个浮点元素 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 相等。（Float.isNaN（a）&amp;amp;&amp;amp; Float.isNaN（b））。与&lt;a href=&quot;../lang/float#equals(java.lang.Object)&quot;&gt; &lt;code&gt;Float.equals(Object)&lt;/code&gt; &lt;/a&gt;不同，值 &lt;code&gt;-0.0&lt;/code&gt; 和 &lt;code&gt;+0.0&lt;/code&gt; 被认为是相等的。</target>
        </trans-unit>
        <trans-unit id="f74bb945ec6a22ab7838a324a183e657cee9de65" translate="yes" xml:space="preserve">
          <source>The two sequences of remaining elements, considered independently of their starting positions, are pointwise equal. This method considers two float elements &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; to be equal if &lt;code&gt;(a == b) || (Float.isNaN(a) &amp;amp;&amp;amp; Float.isNaN(b))&lt;/code&gt;. The values &lt;code&gt;-0.0&lt;/code&gt; and &lt;code&gt;+0.0&lt;/code&gt; are considered to be equal, unlike &lt;a href=&quot;../lang/float#equals-java.lang.Object-&quot;&gt;&lt;code&gt;Float.equals(Object)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">独立于其起始位置考虑的其余元素的两个序列在​​点上相等。如果 &lt;code&gt;(a == b) || (Float.isNaN(a) &amp;amp;&amp;amp; Float.isNaN(b))&lt;/code&gt; 则此方法认为两个浮点元素 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 相等。（Float.isNaN（a）&amp;amp;&amp;amp; Float.isNaN（b））。与&lt;a href=&quot;../lang/float#equals-java.lang.Object-&quot;&gt; &lt;code&gt;Float.equals(Object)&lt;/code&gt; &lt;/a&gt;不同，值 &lt;code&gt;-0.0&lt;/code&gt; 和 &lt;code&gt;+0.0&lt;/code&gt; 被视为相等。</target>
        </trans-unit>
        <trans-unit id="f1be5e53cf7d411a8147d01132ffbb087dc37403" translate="yes" xml:space="preserve">
          <source>The two serialization-related fields are:</source>
          <target state="translated">与序列化有关的两个字段是:</target>
        </trans-unit>
        <trans-unit id="97983c767ff42d4647c2b3d8afd3922e461ec55b" translate="yes" xml:space="preserve">
          <source>The type</source>
          <target state="translated">类型</target>
        </trans-unit>
        <trans-unit id="8ac14b02e6f129743d1f8a28d779dc984a66b294" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; may be either a primitive or reference. Since type &lt;code&gt;Iterator&amp;lt;T&amp;gt;&lt;/code&gt; is erased in the method handle representation to the raw type &lt;code&gt;Iterator&lt;/code&gt;, the &lt;code&gt;iteratedLoop&lt;/code&gt; combinator adjusts the leading argument type for &lt;code&gt;body&lt;/code&gt; to &lt;code&gt;Object&lt;/code&gt; as if by the &lt;a href=&quot;methodhandle#asType(java.lang.invoke.MethodType)&quot;&gt;&lt;code&gt;asType&lt;/code&gt;&lt;/a&gt; conversion method. Therefore, if an iterator of the wrong type appears as the loop is executed, runtime exceptions may occur as the result of dynamic conversions performed by &lt;a href=&quot;methodhandle#asType(java.lang.invoke.MethodType)&quot;&gt;&lt;code&gt;MethodHandle.asType(MethodType)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">类型 &lt;code&gt;T&lt;/code&gt; 可以是原语或引用。由于在方法句柄表示形式中将 &lt;code&gt;Iterator&amp;lt;T&amp;gt;&lt;/code&gt; 类型擦除为原始类型 &lt;code&gt;Iterator&lt;/code&gt; ，因此 &lt;code&gt;iteratedLoop&lt;/code&gt; 组合器将 &lt;code&gt;body&lt;/code&gt; 的前导自变量类型调整为 &lt;code&gt;Object&lt;/code&gt; ，就像通过&lt;a href=&quot;methodhandle#asType(java.lang.invoke.MethodType)&quot;&gt; &lt;code&gt;asType&lt;/code&gt; &lt;/a&gt;转换方法一样。因此，如果在执行循环时出现错误类型的迭代器，则由于&lt;a href=&quot;methodhandle#asType(java.lang.invoke.MethodType)&quot;&gt; &lt;code&gt;MethodHandle.asType(MethodType)&lt;/code&gt; &lt;/a&gt;执行动态转换而可能会导致运行时异常。</target>
        </trans-unit>
        <trans-unit id="4d9c3e5a2e1ee1b8623092bbd4a2ad433a0d8102" translate="yes" xml:space="preserve">
          <source>The type and behavior of the adapter will be the same as the type and behavior of the target, except that certain &lt;code&gt;invoke&lt;/code&gt; and &lt;code&gt;asType&lt;/code&gt; requests can lead to trailing positional arguments being collected into target's trailing parameter. Also, the &lt;a href=&quot;methodtype#lastParameterType()&quot;&gt;last parameter type&lt;/a&gt; of the adapter will be &lt;code&gt;arrayType&lt;/code&gt;, even if the target has a different last parameter type.</source>
          <target state="translated">适配器的类型和行为将与目标的类型和行为相同，除了某些 &lt;code&gt;invoke&lt;/code&gt; 和 &lt;code&gt;asType&lt;/code&gt; 请求可能导致尾随位置参数被收集到目标的尾随参数中之外。同样，适配器的&lt;a href=&quot;methodtype#lastParameterType()&quot;&gt;最后一个参数类型&lt;/a&gt;将是 &lt;code&gt;arrayType&lt;/code&gt; ，即使目标具有不同的最后一个参数类型也是如此。</target>
        </trans-unit>
        <trans-unit id="c0ea19c65ec77bbed855a0ec57d24fe61a6f3cfc" translate="yes" xml:space="preserve">
          <source>The type and behavior of the adapter will be the same as the type and behavior of the target, except that certain &lt;code&gt;invoke&lt;/code&gt; and &lt;code&gt;asType&lt;/code&gt; requests can lead to trailing positional arguments being collected into target's trailing parameter. Also, the last parameter type of the adapter will be &lt;code&gt;arrayType&lt;/code&gt;, even if the target has a different last parameter type.</source>
          <target state="translated">适配器的类型和行为与目标的类型和行为相同，除了某些 &lt;code&gt;invoke&lt;/code&gt; 和 &lt;code&gt;asType&lt;/code&gt; 请求可能导致尾随位置参数被收集到目标的尾随参数中之外。同样，适配器的最后一个参数类型将是 &lt;code&gt;arrayType&lt;/code&gt; ，即使目标具有不同的最后一个参数类型也是如此。</target>
        </trans-unit>
        <trans-unit id="b9274643a3bf4ca4addb78cb6a98b74268f87044" translate="yes" xml:space="preserve">
          <source>The type and encodings are described in the &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html#certificatefactory-types&quot;&gt; CertificateFactory section&lt;/a&gt; and the &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html#certpath-encodings&quot;&gt; CertPath Encodings section&lt;/a&gt; of the Java Security Standard Algorithm Names Specification. Consult the release documentation for your implementation to see if any other types or encodings are supported.</source>
          <target state="translated">Java安全标准算法名称规范的&lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html#certificatefactory-types&quot;&gt;CertificateFactory部分&lt;/a&gt;和&lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html#certpath-encodings&quot;&gt;CertPath Encodings部分&lt;/a&gt;中描述了类型和编码。请查阅发布文档以了解您的实现，以查看是否支持其他任何类型或编码。</target>
        </trans-unit>
        <trans-unit id="c960b0be4588b06d03016cec1d59c31e1a26ee1a" translate="yes" xml:space="preserve">
          <source>The type and encodings are described in the &lt;a href=&quot;https://docs.oracle.com/en/java/javase/15/docs/specs/security/standard-names.html#certificatefactory-types&quot;&gt; CertificateFactory section&lt;/a&gt; and the &lt;a href=&quot;https://docs.oracle.com/en/java/javase/15/docs/specs/security/standard-names.html#certpath-encodings&quot;&gt; CertPath Encodings section&lt;/a&gt; of the Java Security Standard Algorithm Names Specification. Consult the release documentation for your implementation to see if any other types or encodings are supported.</source>
          <target state="translated">Java安全标准算法名称规范的&lt;a href=&quot;https://docs.oracle.com/en/java/javase/15/docs/specs/security/standard-names.html#certificatefactory-types&quot;&gt;CertificateFactory部分&lt;/a&gt;和&lt;a href=&quot;https://docs.oracle.com/en/java/javase/15/docs/specs/security/standard-names.html#certpath-encodings&quot;&gt;CertPath Encodings部分&lt;/a&gt;中描述了类型和编码。请查阅发布文档以了解您的实现，以查看是否支持其他任何类型或编码。</target>
        </trans-unit>
        <trans-unit id="ff6bb0cadf07db39ec6be40e5dae1eed885b4134" translate="yes" xml:space="preserve">
          <source>The type and encodings are described in the &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html#CertificateFactory&quot;&gt; CertificateFactory section&lt;/a&gt; and the &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html#CertPathEncodings&quot;&gt; CertPath Encodings section&lt;/a&gt; of the Java Cryptography Architecture Standard Algorithm Name Documentation. Consult the release documentation for your implementation to see if any other types or encodings are supported.</source>
          <target state="translated">Java密码体系结构体系结构标准算法名称文档的&lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html#CertificateFactory&quot;&gt;CertificateFactory部分&lt;/a&gt;和&lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html#CertPathEncodings&quot;&gt;CertPath Encodings部分&lt;/a&gt;中描述了类型和编码。请查阅发布文档以了解您的实现，以查看是否支持其他任何类型或编码。</target>
        </trans-unit>
        <trans-unit id="c6b186bc7aea698445dc40383caf4bf30781283e" translate="yes" xml:space="preserve">
          <source>The type associated with all custom cursors.</source>
          <target state="translated">与所有自定义光标相关联的类型。</target>
        </trans-unit>
        <trans-unit id="f5ec1e2d57fb1bd044b7c12346c65a90e63ab2a6" translate="yes" xml:space="preserve">
          <source>The type associated with non-object values in a target VM.</source>
          <target state="translated">目标虚拟机中与非对象值相关联的类型。</target>
        </trans-unit>
        <trans-unit id="a5acfd55f75f81b438121d9164a5ebdf07b1e583" translate="yes" xml:space="preserve">
          <source>The type associated with non-object values in a target VM. Instances of one of the sub-interfaces of this interface will be returned from &lt;a href=&quot;value#type()&quot;&gt;&lt;code&gt;Value.type()&lt;/code&gt;&lt;/a&gt; for all &lt;a href=&quot;primitivevalue&quot;&gt;&lt;code&gt;PrimitiveValue&lt;/code&gt;&lt;/a&gt; objects.</source>
          <target state="translated">与目标VM中的非对象值关联的类型。对于所有&lt;a href=&quot;primitivevalue&quot;&gt; &lt;code&gt;PrimitiveValue&lt;/code&gt; &lt;/a&gt;对象，将从&lt;a href=&quot;value#type()&quot;&gt; &lt;code&gt;Value.type()&lt;/code&gt; &lt;/a&gt;返回此接口的子接口之一的实例。</target>
        </trans-unit>
        <trans-unit id="948a046cc2e5aa5046c9417d1490884dfdc604b8" translate="yes" xml:space="preserve">
          <source>The type can be used to identify what type of setting this is.</source>
          <target state="translated">该类型可用于识别这是什么类型的设置。</target>
        </trans-unit>
        <trans-unit id="8a0aad1afcd781464b76996d424e8348249f28ac" translate="yes" xml:space="preserve">
          <source>The type fingerprint that is set to indicate serialization compatibility with a previous version of the type.</source>
          <target state="translated">类型指纹,设置为表示与以前版本的类型的序列化兼容性。</target>
        </trans-unit>
        <trans-unit id="93dbc281a6a1652e30aac933243bf7afad98e3d0" translate="yes" xml:space="preserve">
          <source>The type information associated with this attribute.</source>
          <target state="translated">与此属性相关的类型信息。</target>
        </trans-unit>
        <trans-unit id="6035b72b31597b588131e4a84cda217fb3253aca" translate="yes" xml:space="preserve">
          <source>The type information associated with this attribute. While the type information contained in this attribute is guarantee to be correct after loading the document or invoking &lt;code&gt;Document.normalizeDocument()&lt;/code&gt;, &lt;code&gt;schemaTypeInfo&lt;/code&gt; may not be reliable if the node was moved.</source>
          <target state="translated">与此属性关联的类型信息。尽管在加载文档或调用 &lt;code&gt;Document.normalizeDocument()&lt;/code&gt; 之后，可以保证此属性中包含的类型信息正确，但是如果移动了节点，则 &lt;code&gt;schemaTypeInfo&lt;/code&gt; 可能并不可靠。</target>
        </trans-unit>
        <trans-unit id="e61ac73041fcfd164a7302e03c2c4eb5aa4c9644" translate="yes" xml:space="preserve">
          <source>The type information associated with this element.</source>
          <target state="translated">与该元素相关的类型信息。</target>
        </trans-unit>
        <trans-unit id="47aacc9e53df6990e6cd21e34ac8f46081f60e02" translate="yes" xml:space="preserve">
          <source>The type is a &lt;code&gt;String&lt;/code&gt; that identifies the type of &lt;code&gt;Certificate&lt;/code&gt;s in the certification path. For each certificate &lt;code&gt;cert&lt;/code&gt; in a certification path &lt;code&gt;certPath&lt;/code&gt;, &lt;code&gt;cert.getType().equals(certPath.getType())&lt;/code&gt; must be &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">类型是一个 &lt;code&gt;String&lt;/code&gt; ，用于标识证书路径中 &lt;code&gt;Certificate&lt;/code&gt; 的类型。对于证书路径 &lt;code&gt;certPath&lt;/code&gt; 中的每个证书 &lt;code&gt;cert&lt;/code&gt; ， &lt;code&gt;cert.getType().equals(certPath.getType())&lt;/code&gt; 必须为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3992f3a6c4f1b89ac824af3b12e6534482315701" translate="yes" xml:space="preserve">
          <source>The type is an interface type and not an annotation type, enum, or class.</source>
          <target state="translated">该类型是一个接口类型,而不是注解类型、枚举或类。</target>
        </trans-unit>
        <trans-unit id="e26cf268f40425be61bd9fa65b49f0d6fe506153" translate="yes" xml:space="preserve">
          <source>The type name corresponding to the supplied type constant.</source>
          <target state="translated">与所提供的类型常量相对应的类型名称。</target>
        </trans-unit>
        <trans-unit id="dbbee8087c3ba28222fa95426623818374828807" translate="yes" xml:space="preserve">
          <source>The type of &lt;a href=&quot;processbuilder.redirect#INHERIT&quot;&gt;&lt;code&gt;Redirect.INHERIT&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;processbuilder.redirect#INHERIT&quot;&gt; &lt;code&gt;Redirect.INHERIT&lt;/code&gt; &lt;/a&gt;的类型。</target>
        </trans-unit>
        <trans-unit id="c0ad9640a3999591dd1d2029f7ecfcb72b0d98b2" translate="yes" xml:space="preserve">
          <source>The type of &lt;a href=&quot;processbuilder.redirect#PIPE&quot;&gt;&lt;code&gt;Redirect.PIPE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;processbuilder.redirect#PIPE&quot;&gt; &lt;code&gt;Redirect.PIPE&lt;/code&gt; &lt;/a&gt;的类型。</target>
        </trans-unit>
        <trans-unit id="e8d2db58ec658df2f7f6c171781a38ba46c53399" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;JOIN&lt;/code&gt; to be established is determined by setting one of the &lt;code&gt;JoinRowSet&lt;/code&gt; constants using the method &lt;code&gt;setJoinType&lt;/code&gt;. The following SQL &lt;code&gt;JOIN&lt;/code&gt; types can be set:</source>
          <target state="translated">通过使用 &lt;code&gt;setJoinType&lt;/code&gt; 方法设置 &lt;code&gt;JoinRowSet&lt;/code&gt; 常量之一来确定要建立的 &lt;code&gt;JOIN&lt;/code&gt; 的类型。可以设置以下SQL &lt;code&gt;JOIN&lt;/code&gt; 类型：</target>
        </trans-unit>
        <trans-unit id="f56f95d6997ec10a60d61b49368aad5c85b0c93d" translate="yes" xml:space="preserve">
          <source>The type of MIDI file.</source>
          <target state="translated">MIDI文件的类型。</target>
        </trans-unit>
        <trans-unit id="127e2dcfa435659f04a5c90d26c476f9ace2f0e1" translate="yes" xml:space="preserve">
          <source>The type of a &lt;a href=&quot;processbuilder.redirect&quot;&gt;&lt;code&gt;ProcessBuilder.Redirect&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;processbuilder.redirect&quot;&gt; &lt;code&gt;ProcessBuilder.Redirect&lt;/code&gt; &lt;/a&gt;的类型。</target>
        </trans-unit>
        <trans-unit id="19a111fbf1a4085482090a96e6a31a6562e4dbf5" translate="yes" xml:space="preserve">
          <source>The type of a metric, one of the strings &quot;counter&quot; or &quot;gauge&quot;. A metric is a measurement exported by an MBean, usually an attribute but sometimes the result of an operation. A metric that is a &lt;em&gt;counter&lt;/em&gt; has a value that never decreases except by being reset to a starting value. Counter metrics are almost always non-negative integers. An example might be the number of requests received. A metric that is a &lt;em&gt;gauge&lt;/em&gt; has a numeric value that can increase or decrease. Examples might be the number of open connections or a cache hit rate or a temperature reading.</source>
          <target state="translated">度量标准的类型，字符串&amp;ldquo; counter&amp;rdquo;或&amp;ldquo; gauge&amp;rdquo;之一。度量是MBean导出的度量，通常是一个属性，但有时又是一个操作的结果。作为&lt;em&gt;计数器的&lt;/em&gt;指标的值除非重置为初始值，否则不会减少。计数器指标几乎总是非负整数。一个示例可能是收到的请求数。作为量&lt;em&gt;规的&lt;/em&gt;度量&lt;em&gt;标准&lt;/em&gt;具有可以增加或减少的数值。例如打开的连接数或高速缓存命中率或温度读数。</target>
        </trans-unit>
        <trans-unit id="9bdd7b2e326fdca9bef79c30949c6c05c7225058" translate="yes" xml:space="preserve">
          <source>The type of all primitive &lt;code&gt;boolean&lt;/code&gt; values accessed in the target VM.</source>
          <target state="translated">在目标VM中访问的所有原始 &lt;code&gt;boolean&lt;/code&gt; 值的类型。</target>
        </trans-unit>
        <trans-unit id="d8c0284ee53aa32fc7cc5dfed6c7c451654a8d85" translate="yes" xml:space="preserve">
          <source>The type of all primitive &lt;code&gt;boolean&lt;/code&gt; values accessed in the target VM. Calls to &lt;a href=&quot;value#type()&quot;&gt;&lt;code&gt;Value.type()&lt;/code&gt;&lt;/a&gt; will return an implementor of this interface.</source>
          <target state="translated">在目标VM中访问的所有原始 &lt;code&gt;boolean&lt;/code&gt; 值的类型。调用&lt;a href=&quot;value#type()&quot;&gt; &lt;code&gt;Value.type()&lt;/code&gt; &lt;/a&gt;将返回此接口的实现。</target>
        </trans-unit>
        <trans-unit id="61964dfa1885c621370889e4999f6e08cf250877" translate="yes" xml:space="preserve">
          <source>The type of all primitive &lt;code&gt;int&lt;/code&gt; values accessed in the target VM.</source>
          <target state="translated">在目标VM中访问的所有原始 &lt;code&gt;int&lt;/code&gt; 值的类型。</target>
        </trans-unit>
        <trans-unit id="df58578877a7f7dbce54efa73e93ac7e75d5bad8" translate="yes" xml:space="preserve">
          <source>The type of all primitive &lt;code&gt;int&lt;/code&gt; values accessed in the target VM. Calls to &lt;a href=&quot;value#type()&quot;&gt;&lt;code&gt;Value.type()&lt;/code&gt;&lt;/a&gt; will return an implementor of this interface.</source>
          <target state="translated">在目标VM中访问的所有原始 &lt;code&gt;int&lt;/code&gt; 值的类型。调用&lt;a href=&quot;value#type()&quot;&gt; &lt;code&gt;Value.type()&lt;/code&gt; &lt;/a&gt;将返回此接口的实现。</target>
        </trans-unit>
        <trans-unit id="540e4e17c597fd8292e4c9cec5a4edcffb94495f" translate="yes" xml:space="preserve">
          <source>The type of all primitive &lt;code&gt;long&lt;/code&gt; values accessed in the target VM.</source>
          <target state="translated">在目标VM中访问的所有原始 &lt;code&gt;long&lt;/code&gt; 值的类型。</target>
        </trans-unit>
        <trans-unit id="905055b2779123645085eb861a2cc95d9d467c93" translate="yes" xml:space="preserve">
          <source>The type of all primitive &lt;code&gt;long&lt;/code&gt; values accessed in the target VM. Calls to &lt;a href=&quot;value#type()&quot;&gt;&lt;code&gt;Value.type()&lt;/code&gt;&lt;/a&gt; will return an implementor of this interface.</source>
          <target state="translated">在目标VM中访问的所有原始 &lt;code&gt;long&lt;/code&gt; 值的类型。调用&lt;a href=&quot;value#type()&quot;&gt; &lt;code&gt;Value.type()&lt;/code&gt; &lt;/a&gt;将返回此接口的实现。</target>
        </trans-unit>
        <trans-unit id="9fe183d2466ca0d9c323125274002bdc3684a996" translate="yes" xml:space="preserve">
          <source>The type of all primitive &lt;code&gt;short&lt;/code&gt; values accessed in the target VM.</source>
          <target state="translated">在目标VM中访问的所有原始 &lt;code&gt;short&lt;/code&gt; 值的类型。</target>
        </trans-unit>
        <trans-unit id="d27bac7cb7202d232d582730bb8128c9202fe730" translate="yes" xml:space="preserve">
          <source>The type of all primitive &lt;code&gt;short&lt;/code&gt; values accessed in the target VM. Calls to &lt;a href=&quot;value#type()&quot;&gt;&lt;code&gt;Value.type()&lt;/code&gt;&lt;/a&gt; will return an implementor of this interface.</source>
          <target state="translated">在目标VM中访问的所有原始 &lt;code&gt;short&lt;/code&gt; 值的类型。调用&lt;a href=&quot;value#type()&quot;&gt; &lt;code&gt;Value.type()&lt;/code&gt; &lt;/a&gt;将返回此接口的实现。</target>
        </trans-unit>
        <trans-unit id="fd6e4400fd88a4a31267dd38c5778ce3336b5d8f" translate="yes" xml:space="preserve">
          <source>The type of all primitive &lt;code&gt;void&lt;/code&gt; values accessed in the target VM.</source>
          <target state="translated">在目标VM中访问的所有原始 &lt;code&gt;void&lt;/code&gt; 值的类型。</target>
        </trans-unit>
        <trans-unit id="8e8deceef0c508dcd94caaf941dc08a19f880247" translate="yes" xml:space="preserve">
          <source>The type of all primitive &lt;code&gt;void&lt;/code&gt; values accessed in the target VM. Calls to &lt;a href=&quot;value#type()&quot;&gt;&lt;code&gt;Value.type()&lt;/code&gt;&lt;/a&gt; will return an implementor of this interface.</source>
          <target state="translated">在目标VM中访问的所有原始 &lt;code&gt;void&lt;/code&gt; 值的类型。调用&lt;a href=&quot;value#type()&quot;&gt; &lt;code&gt;Value.type()&lt;/code&gt; &lt;/a&gt;将返回此接口的实现。</target>
        </trans-unit>
        <trans-unit id="064a8cadc8286a472d0e81121b860e5de44daf4c" translate="yes" xml:space="preserve">
          <source>The type of all primitive byte values accessed in the target VM.</source>
          <target state="translated">目标虚拟机中访问的所有基元字节值的类型。</target>
        </trans-unit>
        <trans-unit id="ae99e2407df532833b4bd5daeb55032fa42beb46" translate="yes" xml:space="preserve">
          <source>The type of all primitive byte values accessed in the target VM. Calls to &lt;a href=&quot;value#type()&quot;&gt;&lt;code&gt;Value.type()&lt;/code&gt;&lt;/a&gt; will return an implementor of this interface.</source>
          <target state="translated">在目标VM中访问的所有原始字节值的类型。调用&lt;a href=&quot;value#type()&quot;&gt; &lt;code&gt;Value.type()&lt;/code&gt; &lt;/a&gt;将返回此接口的实现。</target>
        </trans-unit>
        <trans-unit id="e5e0aeccb527adb41cb0da6e5249975d3c490234" translate="yes" xml:space="preserve">
          <source>The type of all primitive char values accessed in the target VM.</source>
          <target state="translated">在目标虚拟机中访问的所有基本字符值的类型。</target>
        </trans-unit>
        <trans-unit id="6505cada2a662701f19d4d5b5ed6715d542e253b" translate="yes" xml:space="preserve">
          <source>The type of all primitive char values accessed in the target VM. Calls to &lt;a href=&quot;value#type()&quot;&gt;&lt;code&gt;Value.type()&lt;/code&gt;&lt;/a&gt; will return an implementor of this interface.</source>
          <target state="translated">在目标VM中访问的所有原始char值的类型。调用&lt;a href=&quot;value#type()&quot;&gt; &lt;code&gt;Value.type()&lt;/code&gt; &lt;/a&gt;将返回此接口的实现。</target>
        </trans-unit>
        <trans-unit id="a550f71331e0769b5e400814607f0b7218fb9579" translate="yes" xml:space="preserve">
          <source>The type of all primitive double values accessed in the target VM.</source>
          <target state="translated">目标虚拟机中访问的所有基元双值的类型。</target>
        </trans-unit>
        <trans-unit id="86f868aa8134d4079e3a5bb9f64d8a717ef59780" translate="yes" xml:space="preserve">
          <source>The type of all primitive double values accessed in the target VM. Calls to &lt;a href=&quot;value#type()&quot;&gt;&lt;code&gt;Value.type()&lt;/code&gt;&lt;/a&gt; will return an implementor of this interface.</source>
          <target state="translated">在目标VM中访问的所有原始double值的类型。调用&lt;a href=&quot;value#type()&quot;&gt; &lt;code&gt;Value.type()&lt;/code&gt; &lt;/a&gt;将返回此接口的实现。</target>
        </trans-unit>
        <trans-unit id="eee2eff2ed053ff8cac89c091400e52718845455" translate="yes" xml:space="preserve">
          <source>The type of all primitive float values accessed in the target VM.</source>
          <target state="translated">在目标虚拟机中访问的所有基元浮点值的类型。</target>
        </trans-unit>
        <trans-unit id="47dc858648622dee41077cbdcfdfdc492c80e8b4" translate="yes" xml:space="preserve">
          <source>The type of all primitive float values accessed in the target VM. Calls to &lt;a href=&quot;value#type()&quot;&gt;&lt;code&gt;Value.type()&lt;/code&gt;&lt;/a&gt; will return an implementor of this interface.</source>
          <target state="translated">在目标VM中访问的所有原始浮点值的类型。调用&lt;a href=&quot;value#type()&quot;&gt; &lt;code&gt;Value.type()&lt;/code&gt; &lt;/a&gt;将返回此接口的实现。</target>
        </trans-unit>
        <trans-unit id="cba2fcd15e0e72b34634a1ad0bba84c84df1612c" translate="yes" xml:space="preserve">
          <source>The type of an object in a target VM.</source>
          <target state="translated">目标虚拟机中对象的类型。</target>
        </trans-unit>
        <trans-unit id="b4256095924998c735a5e1d2daf580e5257830be" translate="yes" xml:space="preserve">
          <source>The type of an object in a target VM. ReferenceType encompasses classes, interfaces, and array types as defined in</source>
          <target state="translated">目标虚拟机中对象的类型。ReferenceType 包含了类、接口和数组类型,这些类型定义在</target>
        </trans-unit>
        <trans-unit id="9929588d4e4b50c57d34e2768c1aa928a93bbe18" translate="yes" xml:space="preserve">
          <source>The type of an object never changes, so this method will always return the same ReferenceType over the lifetime of the mirrored object.</source>
          <target state="translated">对象的类型永远不会改变,所以在镜像对象的生命周期内,这个方法将始终返回相同的ReferenceType。</target>
        </trans-unit>
        <trans-unit id="aae47c02e32deee2491afe6629f2f876ddd99027" translate="yes" xml:space="preserve">
          <source>The type of button.</source>
          <target state="translated">按钮的类型。</target>
        </trans-unit>
        <trans-unit id="3202c961e86ba8f5916fcea0584ce2db39729f98" translate="yes" xml:space="preserve">
          <source>The type of button. See the type attribute definition in HTML 4.0.</source>
          <target state="translated">按钮的类型。参见HTML 4.0中的类型属性定义。</target>
        </trans-unit>
        <trans-unit id="43b375eaf7b30c62522b5218a46c4f14ba523d62" translate="yes" xml:space="preserve">
          <source>The type of control created.</source>
          <target state="translated">创建的控制类型;</target>
        </trans-unit>
        <trans-unit id="bffc95d4cc2bec8109d90b097c24da8daf3af0d5" translate="yes" xml:space="preserve">
          <source>The type of control created. See the type attribute definition in HTML 4.0.</source>
          <target state="translated">创建的控件类型。参见HTML 4.0中的类型属性定义。</target>
        </trans-unit>
        <trans-unit id="516804b0e5437ce278d19350e7c4ad6ec7d75a1d" translate="yes" xml:space="preserve">
          <source>The type of etch to be drawn by the border.</source>
          <target state="translated">边框所要绘制的蚀刻类型。</target>
        </trans-unit>
        <trans-unit id="a72a6dcb29c4761d0c066bb8800e0746542672cb" translate="yes" xml:space="preserve">
          <source>The type of redirects returned from &lt;a href=&quot;processbuilder.redirect#appendTo(java.io.File)&quot;&gt;&lt;code&gt;Redirect.appendTo(File)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">从&lt;a href=&quot;processbuilder.redirect#appendTo(java.io.File)&quot;&gt; &lt;code&gt;Redirect.appendTo(File)&lt;/code&gt; &lt;/a&gt;返回的重定向类型。</target>
        </trans-unit>
        <trans-unit id="aa5066ac5677ba94a729db439698f3123b5e4800" translate="yes" xml:space="preserve">
          <source>The type of redirects returned from &lt;a href=&quot;processbuilder.redirect#appendTo-java.io.File-&quot;&gt;&lt;code&gt;Redirect.appendTo(File)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">从&lt;a href=&quot;processbuilder.redirect#appendTo-java.io.File-&quot;&gt; &lt;code&gt;Redirect.appendTo(File)&lt;/code&gt; &lt;/a&gt;返回的重定向类型。</target>
        </trans-unit>
        <trans-unit id="3a8c1186e5832691f4a75427966c37b78296c9e6" translate="yes" xml:space="preserve">
          <source>The type of redirects returned from &lt;a href=&quot;processbuilder.redirect#from(java.io.File)&quot;&gt;&lt;code&gt;Redirect.from(File)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">从&lt;a href=&quot;processbuilder.redirect#from(java.io.File)&quot;&gt; &lt;code&gt;Redirect.from(File)&lt;/code&gt; &lt;/a&gt;返回的重定向类型。</target>
        </trans-unit>
        <trans-unit id="b6c13fdf29d3471638747b7836301b890025ac8d" translate="yes" xml:space="preserve">
          <source>The type of redirects returned from &lt;a href=&quot;processbuilder.redirect#from-java.io.File-&quot;&gt;&lt;code&gt;Redirect.from(File)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">从&lt;a href=&quot;processbuilder.redirect#from-java.io.File-&quot;&gt; &lt;code&gt;Redirect.from(File)&lt;/code&gt; &lt;/a&gt;返回的重定向类型。</target>
        </trans-unit>
        <trans-unit id="23b43930e30ca0b29892d575065e9b7d29d48983" translate="yes" xml:space="preserve">
          <source>The type of redirects returned from &lt;a href=&quot;processbuilder.redirect#to(java.io.File)&quot;&gt;&lt;code&gt;Redirect.to(File)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">从&lt;a href=&quot;processbuilder.redirect#to(java.io.File)&quot;&gt; &lt;code&gt;Redirect.to(File)&lt;/code&gt; &lt;/a&gt;返回的重定向类型。</target>
        </trans-unit>
        <trans-unit id="1b7eaaee0ed7fe469cb15b4032d95ee3779bbd61" translate="yes" xml:space="preserve">
          <source>The type of redirects returned from &lt;a href=&quot;processbuilder.redirect#to-java.io.File-&quot;&gt;&lt;code&gt;Redirect.to(File)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">从&lt;a href=&quot;processbuilder.redirect#to-java.io.File-&quot;&gt; &lt;code&gt;Redirect.to(File)&lt;/code&gt; &lt;/a&gt;返回的重定向类型。</target>
        </trans-unit>
        <trans-unit id="62d360876f66c4619f7a66dbb6e3f42e2c3d1fb3" translate="yes" xml:space="preserve">
          <source>The type of the call site is permanently set to the given type.</source>
          <target state="translated">呼叫站点的类型永久设置为给定类型。</target>
        </trans-unit>
        <trans-unit id="84d0df6847a2c34f170737cbf47a403351061610" translate="yes" xml:space="preserve">
          <source>The type of the context is implementation-dependent. If the value is null, the operation must have no dependency on the context, otherwise an XPathExpressionException will be thrown. For the purposes of evaluating XPath expressions, a DocumentFragment is treated like a Document node.</source>
          <target state="translated">上下文的类型是依赖于实现的。如果该值为空,则操作必须不依赖于上下文,否则将抛出XPathExpressionException。为了评估 XPath 表达式,DocumentFragment 被当作 Document 节点对待。</target>
        </trans-unit>
        <trans-unit id="85c774280ae0c09e2cb54be7281c7ab8c6b5e39a" translate="yes" xml:space="preserve">
          <source>The type of the context is usually &lt;a href=&quot;../../../org/w3c/dom/node&quot;&gt;&lt;code&gt;Node&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">上下文的类型通常是&lt;a href=&quot;../../../org/w3c/dom/node&quot;&gt; &lt;code&gt;Node&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0f38c67fdfb625338235f720fe145ed3f504d4e9" translate="yes" xml:space="preserve">
          <source>The type of the entity requesting authentication.</source>
          <target state="translated">请求认证的实体的类型。</target>
        </trans-unit>
        <trans-unit id="c4ac73bf470d2de540cc66c6d49c584580982b87" translate="yes" xml:space="preserve">
          <source>The type of the entity.</source>
          <target state="translated">该实体的类型;</target>
        </trans-unit>
        <trans-unit id="978109c7e8978b8fd7fbcdabcf48636f10ce3310" translate="yes" xml:space="preserve">
          <source>The type of the event.</source>
          <target state="translated">事件的类型;</target>
        </trans-unit>
        <trans-unit id="9ab22e6a2b3ffe5a533cebd7300418770c8847b5" translate="yes" xml:space="preserve">
          <source>The type of the invocation is &lt;code&gt;(sourceType)&amp;rarr;targetType&lt;/code&gt;, while the type of the guard is &lt;code&gt;(sourceType)&amp;rarr;boolean&lt;/code&gt;. You are allowed to return unconditional invocations (with no guard) if the source type is specific to your runtime and your runtime only.</source>
          <target state="translated">调用的类型为 &lt;code&gt;(sourceType)&amp;rarr;targetType&lt;/code&gt; ，而保护的类型为 &lt;code&gt;(sourceType)&amp;rarr;boolean&lt;/code&gt; 。如果源类型特定于您的运行时且仅运行时，则允许您返回无条件调用（无保护）。</target>
        </trans-unit>
        <trans-unit id="a4fa5abe5b635270fa3ad327c2907ed1099d6b46" translate="yes" xml:space="preserve">
          <source>The type of the method at the call site.</source>
          <target state="translated">调用地点的方法类型。</target>
        </trans-unit>
        <trans-unit id="05a0aedd8679b410dfd61aa7d127e3dcd930c83d" translate="yes" xml:space="preserve">
          <source>The type of the new method handle will drop the types for the bound parameters from the original target type, since the new method handle will no longer require those arguments to be supplied by its callers.</source>
          <target state="translated">新方法句柄的类型将从原来的目标类型中放弃绑定参数的类型,因为新方法句柄将不再要求这些参数由其调用者提供。</target>
        </trans-unit>
        <trans-unit id="8627cf93d9b68632081d77f43eec00b2a809ba9f" translate="yes" xml:space="preserve">
          <source>The type of the new target must be &lt;a href=&quot;methodtype#equals(java.lang.Object)&quot;&gt;equal to&lt;/a&gt; the type of the old target.</source>
          <target state="translated">新目标的类型必须&lt;a href=&quot;methodtype#equals(java.lang.Object)&quot;&gt;等于&lt;/a&gt;旧目标的类型。</target>
        </trans-unit>
        <trans-unit id="689485c1e5985a3231bd5ec529f55e5aa04a546f" translate="yes" xml:space="preserve">
          <source>The type of the new target must be &lt;a href=&quot;methodtype#equals-java.lang.Object-&quot;&gt;equal to&lt;/a&gt; the type of the old target.</source>
          <target state="translated">新目标的类型必须&lt;a href=&quot;methodtype#equals-java.lang.Object-&quot;&gt;等于&lt;/a&gt;旧目标的类型。</target>
        </trans-unit>
        <trans-unit id="7259f8962518221961d6182316892012315276e5" translate="yes" xml:space="preserve">
          <source>The type of the notification emitted by a &lt;code&gt;GarbageCollectorMXBean&lt;/code&gt; is:</source>
          <target state="translated">&lt;code&gt;GarbageCollectorMXBean&lt;/code&gt; 发出的通知的类型为：</target>
        </trans-unit>
        <trans-unit id="a890ec2d11b23f48d0302a6f1ff678bb8116b7db" translate="yes" xml:space="preserve">
          <source>The type of the observed attribute is not correct.</source>
          <target state="translated">观察到的属性类型不正确。</target>
        </trans-unit>
        <trans-unit id="b3c3fe93c6de3b710c55d464afb4edc07007d62c" translate="yes" xml:space="preserve">
          <source>The type of the parameter. The returned String is the name of a type recognized by the diagnostic command parser. These types are not Java types and are implementation dependent.</source>
          <target state="translated">参数的类型。返回的String是诊断命令解析器识别的类型名称。这些类型不是Java类型,并且依赖于实现。</target>
        </trans-unit>
        <trans-unit id="c37d7b8236ac8a0ff81b6ebd996e68b65203530e" translate="yes" xml:space="preserve">
          <source>The type of the returned invoker will not be the given &lt;code&gt;type&lt;/code&gt;, but rather will have all parameters except the first &lt;code&gt;leadingArgCount&lt;/code&gt; replaced by a single array of type &lt;code&gt;Object[]&lt;/code&gt;, which will be the final parameter.</source>
          <target state="translated">返回的调用程序的类型将不是给定的 &lt;code&gt;type&lt;/code&gt; ，而是具有所有参数，但第一个 &lt;code&gt;leadingArgCount&lt;/code&gt; 除外，将替换为类型为 &lt;code&gt;Object[]&lt;/code&gt; 的单个数组，这将是最终参数。</target>
        </trans-unit>
        <trans-unit id="c364889480a81b2fc9121ce49a5a01a2d66a67ce" translate="yes" xml:space="preserve">
          <source>The type of the rule, as defined above.</source>
          <target state="translated">规则的类型,如上所述。</target>
        </trans-unit>
        <trans-unit id="ecbe8a1006a6e312de225e872d5b23409437bdf2" translate="yes" xml:space="preserve">
          <source>The type of the rule, as defined above. The expectation is that binding-specific casting methods can be used to cast down from an instance of the &lt;code&gt;CSSRule&lt;/code&gt; interface to the specific derived interface implied by the &lt;code&gt;type&lt;/code&gt;.</source>
          <target state="translated">规则的类型，如上定义。期望可以使用绑定特定的转换方法将 &lt;code&gt;CSSRule&lt;/code&gt; 接口的实例转换为 &lt;code&gt;type&lt;/code&gt; 所隐含的特定派生接口。</target>
        </trans-unit>
        <trans-unit id="92a94904f73be82548909cb1a0373fbdd3612118" translate="yes" xml:space="preserve">
          <source>The type of the value as defined by the constants specified above.</source>
          <target state="translated">上面指定的常量所定义的值的类型。</target>
        </trans-unit>
        <trans-unit id="3713b00b65f5a644a274c8162bd2331606919143" translate="yes" xml:space="preserve">
          <source>The type of this event.</source>
          <target state="translated">这个事件的类型。</target>
        </trans-unit>
        <trans-unit id="0989077c0348877c3be91687a3e0d4d6bbe2d1a9" translate="yes" xml:space="preserve">
          <source>The type of this form control.</source>
          <target state="translated">该表格控件的类型。</target>
        </trans-unit>
        <trans-unit id="7c7d64890e45fcb307183277dbb8d511b2dfb3e3" translate="yes" xml:space="preserve">
          <source>The type of this form control. This is the string &quot;select-multiple&quot; when the multiple attribute is &lt;code&gt;true&lt;/code&gt; and the string &quot;select-one&quot; when &lt;code&gt;false&lt;/code&gt; .</source>
          <target state="translated">此表单控件的类型。这是字符串&amp;ldquo;中选择，多&amp;rdquo;的时候，多属性为 &lt;code&gt;true&lt;/code&gt; 和字符串&amp;ldquo;选一&amp;rdquo;时， &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="db57b7b46e5a783ea336a363901e429b56acf3d8" translate="yes" xml:space="preserve">
          <source>The type of this form control. This the string &quot;textarea&quot;.</source>
          <target state="translated">这个表格控件的类型。此字符串为 &quot;textarea&quot;。</target>
        </trans-unit>
        <trans-unit id="1453673787a1d4f22a54ec78d24c607a777481d0" translate="yes" xml:space="preserve">
          <source>The type of this provider</source>
          <target state="translated">该供应商的类型</target>
        </trans-unit>
        <trans-unit id="efb86a4d23b927b4d7779a5f3229d3b046c17f0c" translate="yes" xml:space="preserve">
          <source>The types are compared for equality with their case ignored.</source>
          <target state="translated">类型比较平等,其大小写忽略不计。</target>
        </trans-unit>
        <trans-unit id="59391c7d69614504e0086f4dff6684db3e9ee2b5" translate="yes" xml:space="preserve">
          <source>The types of notifications emitted by &lt;code&gt;MemoryMXBean&lt;/code&gt; are:</source>
          <target state="translated">&lt;code&gt;MemoryMXBean&lt;/code&gt; 发出的通知类型为：</target>
        </trans-unit>
        <trans-unit id="444baca227e7a21fbc93ead1d887a79a164df63b" translate="yes" xml:space="preserve">
          <source>The typical language value is a two or three-letter language code as defined in ISO639.</source>
          <target state="translated">典型的语言值是ISO639中定义的两个或三个字母的语言代码。</target>
        </trans-unit>
        <trans-unit id="1e7cf956c9a56e2714ac4e67a566ab0ae200ecce" translate="yes" xml:space="preserve">
          <source>The typical life-cycle of a HttpExchange is shown in the sequence below.</source>
          <target state="translated">一个HttpExchange的典型生命周期如下所示。</target>
        </trans-unit>
        <trans-unit id="5c660145e6f646b3735ac4f7205ca9ace38822eb" translate="yes" xml:space="preserve">
          <source>The typical region value is a two-letter ISO 3166 code or a three-digit UN M.49 area code.</source>
          <target state="translated">典型的区域值是两个字母的ISO 3166代码或三位数的UN M.49区域代码。</target>
        </trans-unit>
        <trans-unit id="17cdcc250877b85946cb955da511369645e967cc" translate="yes" xml:space="preserve">
          <source>The typical script value is a four-letter script code as defined by ISO 15924.</source>
          <target state="translated">典型的脚本值是ISO 15924定义的四字母脚本代码。</target>
        </trans-unit>
        <trans-unit id="e493e7eb7efdddc83f3fbdc66df8a51d56849ee7" translate="yes" xml:space="preserve">
          <source>The underline affects both the visual bounds and the outline of the text.</source>
          <target state="translated">下划线既影响视觉界限,又影响文字的轮廓。</target>
        </trans-unit>
        <trans-unit id="20b0ef642374b714b39ebc2873baf17c5b426b78" translate="yes" xml:space="preserve">
          <source>The underlying &lt;code&gt;BoundedRangeModel&lt;/code&gt; handles any mathematical issues arising from assigning faulty values. See the &lt;code&gt;BoundedRangeModel&lt;/code&gt; documentation for details.</source>
          <target state="translated">底层的 &lt;code&gt;BoundedRangeModel&lt;/code&gt; 处理分配错误值引起的任何数学问题。有关详细信息，请参见 &lt;code&gt;BoundedRangeModel&lt;/code&gt; 文档。</target>
        </trans-unit>
        <trans-unit id="6549bcf9f7282eeb1f28dc2642a65415a4279869" translate="yes" xml:space="preserve">
          <source>The underlying SSL parameters may be established either via the set/get methods of this class, or else via a &lt;a href=&quot;../../../../../java.base/javax/net/ssl/sslparameters&quot;&gt;&lt;code&gt;SSLParameters&lt;/code&gt;&lt;/a&gt; object. SSLParameters is the preferred method, because in the future, additional configuration capabilities may be added to that class, and it is easier to determine the set of supported parameters and their default values with SSLParameters. Also, if an SSLParameters object is provided via &lt;a href=&quot;#setSSLParameters(javax.net.ssl.SSLParameters)&quot;&gt;&lt;code&gt;setSSLParameters(SSLParameters)&lt;/code&gt;&lt;/a&gt; then those parameter settings are used, and any settings made in this object are ignored.</source>
          <target state="translated">可以通过此类的set / get方法或通过&lt;a href=&quot;../../../../../java.base/javax/net/ssl/sslparameters&quot;&gt; &lt;code&gt;SSLParameters&lt;/code&gt; &lt;/a&gt;对象建立基础SSL参数。 SSLParameters是首选方法，因为将来可能会在该类中添加其他配置功能，并且使用SSLParameters确定支持的参数集及其默认值会更加容易。另外，如果通过&lt;a href=&quot;#setSSLParameters(javax.net.ssl.SSLParameters)&quot;&gt; &lt;code&gt;setSSLParameters(SSLParameters)&lt;/code&gt; &lt;/a&gt;提供了SSLParameters对象，则将使用这些参数设置，并且将忽略在此对象中进行的任何设置。</target>
        </trans-unit>
        <trans-unit id="121414ae83882d6978c3061ae2ccaf0b4cd3a7f5" translate="yes" xml:space="preserve">
          <source>The underlying character-input stream.</source>
          <target state="translated">底层字符输入流。</target>
        </trans-unit>
        <trans-unit id="66e9f85ce07195fbd2dc5d2f06d3273076e5b33d" translate="yes" xml:space="preserve">
          <source>The underlying character-output stream of this &lt;code&gt;PrintWriter&lt;/code&gt;.</source>
          <target state="translated">此 &lt;code&gt;PrintWriter&lt;/code&gt; 的基础字符输出流。</target>
        </trans-unit>
        <trans-unit id="997090c1014b7704de737ddf5326441d3f6eab7d" translate="yes" xml:space="preserve">
          <source>The underlying character-output stream.</source>
          <target state="translated">基本的字符输出流。</target>
        </trans-unit>
        <trans-unit id="48e3e0bfbed1be484de7c256629bbfc344226e62" translate="yes" xml:space="preserve">
          <source>The underlying field's value is obtained as follows:</source>
          <target state="translated">基础字段的值获得如下:</target>
        </trans-unit>
        <trans-unit id="6b7dedd2916acda5e4ddd9bf5218b5756a52e4ca" translate="yes" xml:space="preserve">
          <source>The underlying memory used by the &lt;code&gt;src&lt;/code&gt; and &lt;code&gt;dsts ByteBuffer&lt;/code&gt;s must not be the same.</source>
          <target state="translated">&lt;code&gt;src&lt;/code&gt; 和 &lt;code&gt;dsts ByteBuffer&lt;/code&gt; 使用的基础内存不能相同。</target>
        </trans-unit>
        <trans-unit id="028d275e77138b148a731ed31ec7168887398dc7" translate="yes" xml:space="preserve">
          <source>The underlying memory used by the &lt;code&gt;srcs&lt;/code&gt; and &lt;code&gt;dst ByteBuffer&lt;/code&gt;s must not be the same.</source>
          <target state="translated">&lt;code&gt;srcs&lt;/code&gt; 和 &lt;code&gt;dst ByteBuffer&lt;/code&gt; 使用的基础内存不能相同。</target>
        </trans-unit>
        <trans-unit id="b2dd44c58a8235d0ae8f513f91b8369937ea3aba" translate="yes" xml:space="preserve">
          <source>The underlying operating system is queried for an update as to the readiness of each remaining channel to perform any of the operations identified by its key's interest set as of the moment that the selection operation began.</source>
          <target state="translated">底层操作系统被查询更新,以了解在选择操作开始的时刻,每个剩余通道是否准备好执行由其键的兴趣集确定的任何操作。</target>
        </trans-unit>
        <trans-unit id="8bcc6a3ebcd69bf1c22f30e41fee2405130dbb8f" translate="yes" xml:space="preserve">
          <source>The underlying operating system is queried for an update as to the readiness of each remaining channel to perform any of the operations identified by its key's interest set as of the moment that the selection operation began. For a channel that is ready for at least one such operation, one of the following two actions is performed:</source>
          <target state="translated">底层操作系统被查询更新,以了解在选择操作开始的时刻,每个剩余的通道是否准备好执行由其密钥的兴趣集确定的任何操作。对于至少一个这样的操作准备好的通道,将执行以下两个操作之一。</target>
        </trans-unit>
        <trans-unit id="5fac40f1f061f6b657772e9f893915f23de48bf5" translate="yes" xml:space="preserve">
          <source>The underlying output stream to be filtered.</source>
          <target state="translated">要过滤的基本输出流。</target>
        </trans-unit>
        <trans-unit id="1a5764b11a39a7b859946ca022bc7546c2758d6c" translate="yes" xml:space="preserve">
          <source>The underlying signing algorithm is designated by the Signature object passed to the constructor and the &lt;code&gt;verify&lt;/code&gt; method. A typical usage for signing is the following:</source>
          <target state="translated">基础签名算法由传递给构造函数的Signature对象和 &lt;code&gt;verify&lt;/code&gt; 方法指定。签名的典型用法如下：</target>
        </trans-unit>
        <trans-unit id="1a0c62e15b608a731329638c7175e259e5b752ff" translate="yes" xml:space="preserve">
          <source>The underscore character &lt;code&gt;'_'&lt;/code&gt; (&lt;code&gt;'\u005f'&lt;/code&gt;, &lt;small&gt;LOW LINE&lt;/small&gt;).</source>
          <target state="translated">下划线字符 &lt;code&gt;'_'&lt;/code&gt; （ &lt;code&gt;'\u005f'&lt;/code&gt; ，&lt;small&gt;LOW LINE&lt;/small&gt;）。</target>
        </trans-unit>
        <trans-unit id="7c1ffa4ad50bf6adcf296f52ce5cec96c22f7318" translate="yes" xml:space="preserve">
          <source>The undo/redo presentation name</source>
          <target state="translated">撤销/重做演示名称</target>
        </trans-unit>
        <trans-unit id="c48b40a9584e8f5d48650d23e68347fe38a9dee0" translate="yes" xml:space="preserve">
          <source>The union filter operation.</source>
          <target state="translated">联合过滤操作。</target>
        </trans-unit>
        <trans-unit id="362e82993b25d36e57cda3f0236e2391a9c64582" translate="yes" xml:space="preserve">
          <source>The unique identifier for the snippet.</source>
          <target state="translated">该片段的唯一标识符。</target>
        </trans-unit>
        <trans-unit id="b57c4ef8ebd26949b03722f01f84db84a1628627" translate="yes" xml:space="preserve">
          <source>The unique identifier for the snippet. No two active snippets will have the same id(). Value of id has no prescribed meaning. The details of how the id is generated and the mechanism to change it is documented in &lt;a href=&quot;jshell.builder#idGenerator(java.util.function.BiFunction)&quot;&gt;&lt;code&gt;JShell.Builder.idGenerator(BiFunction)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">代码段的唯一标识符。没有两个活动代码段具有相同的id（）。id的值没有规定的含义。&lt;a href=&quot;jshell.builder#idGenerator(java.util.function.BiFunction)&quot;&gt; &lt;code&gt;JShell.Builder.idGenerator(BiFunction)&lt;/code&gt; 中&lt;/a&gt;记录了有关如何生成ID以及更改ID的机制的详细信息。</target>
        </trans-unit>
        <trans-unit id="6a8e2e49e14966e85af22f11acfb1faafb28a7dc" translate="yes" xml:space="preserve">
          <source>The unique name of this &lt;code&gt;ExecutionControlProvider&lt;/code&gt;.</source>
          <target state="translated">此 &lt;code&gt;ExecutionControlProvider&lt;/code&gt; 的唯一名称。</target>
        </trans-unit>
        <trans-unit id="8bdfcdd211ddc74b0f508ef9270b895cf9a13b87" translate="yes" xml:space="preserve">
          <source>The unique name of this &lt;code&gt;ExecutionControlProvider&lt;/code&gt;. The name must be a sequence of characters from the Basic Multilingual Plane which are &lt;a href=&quot;../../../../java.base/java/lang/character#isJavaIdentifierPart(int)&quot;&gt;&lt;code&gt;Character.isJavaIdentifierPart(char)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此 &lt;code&gt;ExecutionControlProvider&lt;/code&gt; 的唯一名称。名称必须是Basic Multilingual Plane中的一系列字符，它们是&lt;a href=&quot;../../../../java.base/java/lang/character#isJavaIdentifierPart(int)&quot;&gt; &lt;code&gt;Character.isJavaIdentifierPart(char)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cae92f9fce61041c312223fede1e34d5be987d37" translate="yes" xml:space="preserve">
          <source>The uniquely named method is allowed to be multiply declared, with distinct type descriptors. (E.g., it can be overloaded, or can possess bridge methods.) All such declarations are connected directly to the target method handle. Argument and return types are adjusted by &lt;code&gt;asType&lt;/code&gt; for each individual declaration.</source>
          <target state="translated">唯一命名的方法允许使用不同的类型描述符进行多重声明。（例如，它可以重载，也可以拥有桥方法。）所有此类声明都直接连接到目标方法句柄。对于每个单独的声明，参数和返回类型均由 &lt;code&gt;asType&lt;/code&gt; 调整。</target>
        </trans-unit>
        <trans-unit id="e2f80b55f26435dc0cbc6eebb8950484c5bf36aa" translate="yes" xml:space="preserve">
          <source>The unit decrement adjustment type.</source>
          <target state="translated">单位减量调整型。</target>
        </trans-unit>
        <trans-unit id="8e4fe19f8f0b8a705c06bdc855c9df43492e816b" translate="yes" xml:space="preserve">
          <source>The unit for the difference, measured in milliseconds, between the current time and midnight, January 1, 1970 UTC.</source>
          <target state="translated">当前时间与1970年1月1日世界协调时午夜之间的差值单位,以毫秒为单位。</target>
        </trans-unit>
        <trans-unit id="afbd65acfeebea3be9e24dee20e9983a3aa34936" translate="yes" xml:space="preserve">
          <source>The unit for the number of ticks that have transpired since some arbitrary starting date.</source>
          <target state="translated">从某个任意的起始日期开始,已经发生的滴答次数的单位。</target>
        </trans-unit>
        <trans-unit id="52717aab8cd685857c2c2638d23ee7812a035e0d" translate="yes" xml:space="preserve">
          <source>The unit increment adjustment type.</source>
          <target state="translated">单位增量调整型。</target>
        </trans-unit>
        <trans-unit id="1c7bdb009b913ad14ea197d918b5e289949be56f" translate="yes" xml:space="preserve">
          <source>The unit increment is the value that is added or subtracted when the user activates the unit increment area of the scroll bar, generally through a mouse or keyboard gesture that the scroll bar receives as an adjustment event. The unit increment must be greater than zero.</source>
          <target state="translated">单位增量是指当用户激活滚动条的单位增量区域时增加或减少的值,通常是通过鼠标或键盘手势,滚动条作为调整事件接收。单位增量必须大于零。</target>
        </trans-unit>
        <trans-unit id="701b9e479da0e3a00cf653bd228ba4360e20dee1" translate="yes" xml:space="preserve">
          <source>The unit increment is the value that is added or subtracted when the user activates the unit increment area of the scroll bar, generally through a mouse or keyboard gesture that the scroll bar receives as an adjustment event. The unit increment must be greater than zero. Attempts to set the unit increment to a value lower than 1 will result in a value of 1 being set.</source>
          <target state="translated">单位增量是指当用户激活滚动条的单位增量区域时增加或减少的值,通常是通过鼠标或键盘手势,滚动条作为调整事件接收。单位增量必须大于零。试图将单位增量设置为小于1的值,将导致设置为1。</target>
        </trans-unit>
        <trans-unit id="de9b1e61ecdfc95fda63a3a7e8d69c26ea6cf658" translate="yes" xml:space="preserve">
          <source>The unit must have a &lt;a href=&quot;temporal/temporalunit#getDuration()&quot;&gt;duration&lt;/a&gt; that divides into the length of a standard day without remainder. This includes all &lt;a href=&quot;temporal/chronounit#isTimeBased()&quot;&gt;time-based units on {@code ChronoUnit}&lt;/a&gt; and &lt;a href=&quot;temporal/chronounit#DAYS&quot;&gt;&lt;code&gt;DAYS&lt;/code&gt;&lt;/a&gt;. Other ChronoUnits throw an exception.</source>
          <target state="translated">该单元的&lt;a href=&quot;temporal/temporalunit#getDuration()&quot;&gt;持续时间&lt;/a&gt;必须等于标准天的时长，且没有剩余时间。这包括&lt;a href=&quot;temporal/chronounit#isTimeBased()&quot;&gt;{@code ChronoUnit}&lt;/a&gt;和&lt;a href=&quot;temporal/chronounit#DAYS&quot;&gt; &lt;code&gt;DAYS&lt;/code&gt; &lt;/a&gt;上所有基于时间的单位。其他ChronoUnit抛出异常。</target>
        </trans-unit>
        <trans-unit id="234aa0f061723f0a03a2a6d208b3bc5bcf171626" translate="yes" xml:space="preserve">
          <source>The unit must have a &lt;a href=&quot;temporal/temporalunit#getDuration()&quot;&gt;duration&lt;/a&gt; that divides into the length of a standard day without remainder. This includes all supplied time units on &lt;a href=&quot;temporal/chronounit&quot;&gt;&lt;code&gt;ChronoUnit&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;temporal/chronounit#DAYS&quot;&gt;&lt;code&gt;DAYS&lt;/code&gt;&lt;/a&gt;. Other units throw an exception.</source>
          <target state="translated">该单元的&lt;a href=&quot;temporal/temporalunit#getDuration()&quot;&gt;持续时间&lt;/a&gt;必须等于标准天的时长，且没有剩余时间。这包括&lt;a href=&quot;temporal/chronounit&quot;&gt; &lt;code&gt;ChronoUnit&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;temporal/chronounit#DAYS&quot;&gt; &lt;code&gt;DAYS&lt;/code&gt; &lt;/a&gt;上提供的所有时间单位。其他单位抛出异常。</target>
        </trans-unit>
        <trans-unit id="5191f12612fb84b7bbf9829ac12d3dce772f7d2d" translate="yes" xml:space="preserve">
          <source>The unit must have a &lt;a href=&quot;temporal/temporalunit#getDuration--&quot;&gt;duration&lt;/a&gt; that divides into the length of a standard day without remainder. This includes all supplied time units on &lt;a href=&quot;temporal/chronounit&quot;&gt;&lt;code&gt;ChronoUnit&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;temporal/chronounit#DAYS&quot;&gt;&lt;code&gt;DAYS&lt;/code&gt;&lt;/a&gt;. Other units throw an exception.</source>
          <target state="translated">该单元的&lt;a href=&quot;temporal/temporalunit#getDuration--&quot;&gt;持续时间&lt;/a&gt;必须等于标准天的时长，且不得剩余。这包括&lt;a href=&quot;temporal/chronounit&quot;&gt; &lt;code&gt;ChronoUnit&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;temporal/chronounit#DAYS&quot;&gt; &lt;code&gt;DAYS&lt;/code&gt; &lt;/a&gt;上所有提供的时间单位。其他单位抛出异常。</target>
        </trans-unit>
        <trans-unit id="968e96267f6d7165d1ebba6675f71b714928a68b" translate="yes" xml:space="preserve">
          <source>The unit of structure (i.e. a node of the tree) is referred to by the &lt;a href=&quot;element&quot;&gt;Element&lt;/a&gt; interface. Each Element can be tagged with a set of attributes. These attributes (name/value pairs) are defined by the &lt;a href=&quot;attributeset&quot;&gt;AttributeSet&lt;/a&gt; interface.</source>
          <target state="translated">结构单元（即树的节点）由&lt;a href=&quot;element&quot;&gt;Element&lt;/a&gt;接口引用。每个元素都可以使用一组属性进行标记。这些属性（名称/值对）由&lt;a href=&quot;attributeset&quot;&gt;AttributeSet&lt;/a&gt;接口定义。</target>
        </trans-unit>
        <trans-unit id="b14bacca6f7c6b6b2bf4f146f5a2674ddf076dea" translate="yes" xml:space="preserve">
          <source>The unit of the field is the period that varies within the range. For example, in the field 'MonthOfYear', the unit is 'Months'. See also &lt;a href=&quot;#getRangeUnit()&quot;&gt;&lt;code&gt;getRangeUnit()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">字段的单位是在该范围内变化的时间段。例如，在&amp;ldquo; MonthOfYear&amp;rdquo;字段中，单位为&amp;ldquo; Months&amp;rdquo;。另请参见&lt;a href=&quot;#getRangeUnit()&quot;&gt; &lt;code&gt;getRangeUnit()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5122174d5f83d404ea9a42f52e7c1c4179e0a65a" translate="yes" xml:space="preserve">
          <source>The unit of the field is the period that varies within the range. For example, in the field 'MonthOfYear', the unit is 'Months'. See also &lt;a href=&quot;temporalfield#getRangeUnit--&quot;&gt;&lt;code&gt;TemporalField.getRangeUnit()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">字段的单位是在该范围内变化的时间段。例如，在&amp;ldquo; MonthOfYear&amp;rdquo;字段中，单位为&amp;ldquo; Months&amp;rdquo;。另请参见&lt;a href=&quot;temporalfield#getRangeUnit--&quot;&gt; &lt;code&gt;TemporalField.getRangeUnit()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d2ac0d6412e7c41ea9d12640bb3ba8932b0b5834" translate="yes" xml:space="preserve">
          <source>The unit of the field is the period that varies within the range. For example, in the field 'MonthOfYear', the unit is 'Months'. See also &lt;a href=&quot;temporalfield#getRangeUnit--&quot;&gt;&lt;code&gt;getRangeUnit()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">字段的单位是在该范围内变化的时间段。例如，在&amp;ldquo; MonthOfYear&amp;rdquo;字段中，单位为&amp;ldquo; Months&amp;rdquo;。另请参见&lt;a href=&quot;temporalfield#getRangeUnit--&quot;&gt; &lt;code&gt;getRangeUnit()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1f111a51a42acb493693efa131e93c6ce9b6b10b" translate="yes" xml:space="preserve">
          <source>The unit that represents week-based-years for the purpose of addition and subtraction.</source>
          <target state="translated">表示以周为单位的年为单位进行加减法的单位。</target>
        </trans-unit>
        <trans-unit id="27ed7bbeff7184c6ce008c19d55f08c8ed276069" translate="yes" xml:space="preserve">
          <source>The unit works using double dispatch. Client code calls methods on a date-time like &lt;code&gt;LocalDateTime&lt;/code&gt; which check if the unit is a &lt;code&gt;ChronoUnit&lt;/code&gt;. If it is, then the date-time must handle it. Otherwise, the method call is re-dispatched to the matching method in this interface.</source>
          <target state="translated">该单元使用双调度。客户端代码在日期时间上调用诸如 &lt;code&gt;LocalDateTime&lt;/code&gt; 之类的方法，该方法检查该单位是否为 &lt;code&gt;ChronoUnit&lt;/code&gt; 。如果是，则日期时间必须处理它。否则，方法调用将重新分配到此接口中的匹配方法。</target>
        </trans-unit>
        <trans-unit id="81a001136d3eb214fc80d07847b64a02ef39f1b1" translate="yes" xml:space="preserve">
          <source>The units in which an attribute, parameter, or operation return value is measured, for example &lt;code&gt;&quot;bytes&quot;&lt;/code&gt; or &lt;code&gt;
 &quot;seconds&quot;&lt;/code&gt;.</source>
          <target state="translated">测量属性，参数或操作返回值的单位，例如 &lt;code&gt;&quot;bytes&quot;&lt;/code&gt; 或 &lt;code&gt; &quot;seconds&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="337c6ca2e533607b16bd03301e040526d12b467c" translate="yes" xml:space="preserve">
          <source>The units in which an attribute, parameter, or operation return value is measured, for example &lt;code&gt;&quot;bytes&quot;&lt;/code&gt; or &lt;code&gt;&quot;seconds&quot;&lt;/code&gt;.</source>
          <target state="translated">测量属性，参数或操作返回值的单位，例如 &lt;code&gt;&quot;bytes&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;seconds&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e3bd78e3001a8947a68a5cbb3ac87fe1fde628c2" translate="yes" xml:space="preserve">
          <source>The units used for the attributes &lt;code&gt;position&lt;/code&gt; and &lt;code&gt;totalSize&lt;/code&gt; are not specified and can be implementation and input dependent.</source>
          <target state="translated">没有指定用于属性 &lt;code&gt;position&lt;/code&gt; 和 &lt;code&gt;totalSize&lt;/code&gt; 的单位，并且可以取决于实现和输入。</target>
        </trans-unit>
        <trans-unit id="b5d174c8b0683065fbf044b493c3ef8ed79dc428" translate="yes" xml:space="preserve">
          <source>The unknown conversion.</source>
          <target state="translated">未知的转换。</target>
        </trans-unit>
        <trans-unit id="c542dae190003ebc86b3cb936114ebb4383cf9dc" translate="yes" xml:space="preserve">
          <source>The unloading characteristics are set for each hidden class when it is defined, and cannot be changed later. An advantage of allowing hidden classes to be unloaded independently of the class loader marked as their defining loader is that a very large number of hidden classes may be created by an application. In contrast, if &lt;code&gt;STRONG&lt;/code&gt; is used, then the JVM may run out of memory, just as if normal classes were created by class loaders.</source>
          <target state="translated">定义每个隐藏类时，将为其设置卸载特性，并且以后无法更改。允许独立于标记为定义加载程序的类加载程序卸载隐藏类的优点是，应用程序可能会创建大量隐藏类。相反，如果使用 &lt;code&gt;STRONG&lt;/code&gt; ，则JVM可能会耗尽内存，就像正常的类是由类加载器创建的一样。</target>
        </trans-unit>
        <trans-unit id="c132eeb914111eef836f7b17954aa6d06ab7144e" translate="yes" xml:space="preserve">
          <source>The unmatched format specifier</source>
          <target state="translated">未匹配的格式指定器</target>
        </trans-unit>
        <trans-unit id="9c3ed1d8f9191384bc27e1c770f53546798ad3be" translate="yes" xml:space="preserve">
          <source>The unnamed Module for this class loader</source>
          <target state="translated">该类加载器的未命名模块。</target>
        </trans-unit>
        <trans-unit id="89d7d1f2a0c6d2d00918acd6dc9254422a7dc31f" translate="yes" xml:space="preserve">
          <source>The unpacker engine converts the packed stream to a JAR file.</source>
          <target state="translated">解包器引擎将打包后的数据流转换为JAR文件。</target>
        </trans-unit>
        <trans-unit id="f17f3d929a42461873323e53b16339238f41d1f2" translate="yes" xml:space="preserve">
          <source>The unpacker engine converts the packed stream to a JAR file. An instance of the engine can be obtained using &lt;a href=&quot;pack200#newUnpacker()&quot;&gt;&lt;code&gt;Pack200.newUnpacker()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">解包引擎将打包的流转换为JAR文件。可以使用&lt;a href=&quot;pack200#newUnpacker()&quot;&gt; &lt;code&gt;Pack200.newUnpacker()&lt;/code&gt; &lt;/a&gt;获得引擎的实例。</target>
        </trans-unit>
        <trans-unit id="c2a58d4aa16389063e1d4593b8080b538ec67075" translate="yes" xml:space="preserve">
          <source>The unpacker engine converts the packed stream to a JAR file. An instance of the engine can be obtained using &lt;a href=&quot;pack200#newUnpacker--&quot;&gt;&lt;code&gt;Pack200.newUnpacker()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">解包引擎将打包的流转换为JAR文件。可以使用&lt;a href=&quot;pack200#newUnpacker--&quot;&gt; &lt;code&gt;Pack200.newUnpacker()&lt;/code&gt; &lt;/a&gt;获得引擎的实例。</target>
        </trans-unit>
        <trans-unit id="1b7887467cb1970d34f42e962bd76f284036d6cd" translate="yes" xml:space="preserve">
          <source>The unpacker's progress as a percentage, as periodically updated by the unpacker.</source>
          <target state="translated">解包者定期更新的以百分比表示的解包进度;</target>
        </trans-unit>
        <trans-unit id="101f5ee99703bb9848ebdb64b9a981d2574364ad" translate="yes" xml:space="preserve">
          <source>The unpacker's progress as a percentage, as periodically updated by the unpacker. Values of 0 - 100 are normal, and -1 indicates a stall. Progress can be monitored by polling the value of this property.</source>
          <target state="translated">拆包机定期更新的拆包进度百分比。0-100为正常值,-1表示停滞。可以通过轮询此属性的值来监测进度。</target>
        </trans-unit>
        <trans-unit id="7b61a518de7509b59d212e291756906cb8ecb6f4" translate="yes" xml:space="preserve">
          <source>The unqualified name of a proxy class is unspecified. The space of class names that begin with the string &lt;code&gt;&quot;$Proxy&quot;&lt;/code&gt; should be, however, reserved for proxy classes.</source>
          <target state="translated">代理类的非限定名称未指定。但是，应该为代理类保留以字符串 &lt;code&gt;&quot;$Proxy&quot;&lt;/code&gt; 开头的类名称的空间。</target>
        </trans-unit>
        <trans-unit id="eb7964c4b4dc617463023ff4866e3bcc872cfffc" translate="yes" xml:space="preserve">
          <source>The unsigned &lt;code&gt;long&lt;/code&gt; value is the argument plus 2&lt;sup&gt;64&lt;/sup&gt; if the argument is negative; otherwise, it is equal to the argument. This value is converted to a string of ASCII digits in binary (base 2) with no extra leading &lt;code&gt;0&lt;/code&gt;s.</source>
          <target state="translated">无符号 &lt;code&gt;long&lt;/code&gt; 值是自变量加上2 &lt;sup&gt;64（&lt;/sup&gt;如果自变量为负）；否则，它等于参数。该值将转换为二进制（以2为底）的ASCII数字字符串，且没有多余的前导 &lt;code&gt;0&lt;/code&gt; s。</target>
        </trans-unit>
        <trans-unit id="90b3bb257b666565307d76750b50c74e6f924841" translate="yes" xml:space="preserve">
          <source>The unsigned &lt;code&gt;long&lt;/code&gt; value is the argument plus 2&lt;sup&gt;64&lt;/sup&gt; if the argument is negative; otherwise, it is equal to the argument. This value is converted to a string of ASCII digits in hexadecimal (base 16) with no extra leading &lt;code&gt;0&lt;/code&gt;s.</source>
          <target state="translated">无符号 &lt;code&gt;long&lt;/code&gt; 值是自变量加上2 &lt;sup&gt;64（&lt;/sup&gt;如果自变量为负）；否则，它等于参数。该值将转换为十六进制的ASCII数字字符串（以16为基数），且没有多余的前导 &lt;code&gt;0&lt;/code&gt; s。</target>
        </trans-unit>
        <trans-unit id="43fc0c46437e63e9c1bc27fd8276c60615fc1eec" translate="yes" xml:space="preserve">
          <source>The unsigned &lt;code&gt;long&lt;/code&gt; value is the argument plus 2&lt;sup&gt;64&lt;/sup&gt; if the argument is negative; otherwise, it is equal to the argument. This value is converted to a string of ASCII digits in octal (base 8) with no extra leading &lt;code&gt;0&lt;/code&gt;s.</source>
          <target state="translated">无符号 &lt;code&gt;long&lt;/code&gt; 值是自变量加上2 &lt;sup&gt;64（&lt;/sup&gt;如果自变量为负）；否则，它等于参数。该值将转换为八进制（以8为底）的ASCII数字字符串，且没有多余的前导 &lt;code&gt;0&lt;/code&gt; s。</target>
        </trans-unit>
        <trans-unit id="9ef8dc1e7e596de25447c72effc2b78e2e9eda78" translate="yes" xml:space="preserve">
          <source>The unsigned integer value is the argument plus 2&lt;sup&gt;32&lt;/sup&gt; if the argument is negative; otherwise it is equal to the argument. This value is converted to a string of ASCII digits in binary (base 2) with no extra leading &lt;code&gt;0&lt;/code&gt;s.</source>
          <target state="translated">无符号整数值是自变量加上2 &lt;sup&gt;32（&lt;/sup&gt;如果自变量为负）；否则为0。否则等于参数。该值将转换为二进制（以2为底）的ASCII数字字符串，且没有多余的前导 &lt;code&gt;0&lt;/code&gt; s。</target>
        </trans-unit>
        <trans-unit id="054a6f2331c22a50fc40ea825d5bbe23a0c2752a" translate="yes" xml:space="preserve">
          <source>The unsigned integer value is the argument plus 2&lt;sup&gt;32&lt;/sup&gt; if the argument is negative; otherwise, it is equal to the argument. This value is converted to a string of ASCII digits in hexadecimal (base 16) with no extra leading &lt;code&gt;0&lt;/code&gt;s.</source>
          <target state="translated">无符号整数值是自变量加上2 &lt;sup&gt;32（&lt;/sup&gt;如果自变量为负）；否则为0。否则，它等于参数。该值将转换为十六进制的ASCII数字字符串（以16为基数），且没有多余的前导 &lt;code&gt;0&lt;/code&gt; s。</target>
        </trans-unit>
        <trans-unit id="4adf2f37edf13f4b7e5a873d42af291756d4bd27" translate="yes" xml:space="preserve">
          <source>The unsigned integer value is the argument plus 2&lt;sup&gt;32&lt;/sup&gt; if the argument is negative; otherwise, it is equal to the argument. This value is converted to a string of ASCII digits in octal (base 8) with no extra leading &lt;code&gt;0&lt;/code&gt;s.</source>
          <target state="translated">无符号整数值是自变量加上2 &lt;sup&gt;32（&lt;/sup&gt;如果自变量为负）；否则为0。否则，它等于参数。该值将转换为八进制（以8为底）的ASCII数字字符串，且没有多余的前导 &lt;code&gt;0&lt;/code&gt; s。</target>
        </trans-unit>
        <trans-unit id="6060d22783b5de73678a070487c0c6a5f000dbdf" translate="yes" xml:space="preserve">
          <source>The unusual compilation and linkage behavior of &lt;code&gt;invokeExact&lt;/code&gt; and plain &lt;code&gt;invoke&lt;/code&gt; is referenced by the term &lt;em&gt;signature polymorphism&lt;/em&gt;. As defined in the Java Language Specification, a signature polymorphic method is one which can operate with any of a wide range of call signatures and return types.</source>
          <target state="translated">术语&lt;em&gt;签名多态性&lt;/em&gt;引用了 &lt;code&gt;invokeExact&lt;/code&gt; 和纯 &lt;code&gt;invoke&lt;/code&gt; 的异常编译和链接行为。根据Java语言规范中的定义，签名多态方法是一种可以与多种调用签名和返回类型一起使用的方法。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="40b4d5652cfa127fc330a96253acd13ba3551734" translate="yes" xml:space="preserve">
          <source>The update event type.</source>
          <target state="translated">更新事件类型。</target>
        </trans-unit>
        <trans-unit id="29059f1033a4f76e60bdc626ae645add4bfc3353" translate="yes" xml:space="preserve">
          <source>The update level.</source>
          <target state="translated">更新级别。</target>
        </trans-unit>
        <trans-unit id="d313d97487f3c7f3cbc749779eb54e77639e2d72" translate="yes" xml:space="preserve">
          <source>The updated CompositeName, not a new one. Cannot be null.</source>
          <target state="translated">更新后的CompositeName,而不是新的。不能为空。</target>
        </trans-unit>
        <trans-unit id="9a42c811bccd6dd7e2f5a6b9d96175190ed03196" translate="yes" xml:space="preserve">
          <source>The updated CompoundName, not a new one. Cannot be null.</source>
          <target state="translated">更新后的化合物名称,而不是一个新的名称。不能为空。</target>
        </trans-unit>
        <trans-unit id="b0a53b9e80856c6692659d4301653ca2c511f3f2" translate="yes" xml:space="preserve">
          <source>The updated LdapName, not a new instance. Cannot be null.</source>
          <target state="translated">更新后的LdapName,而不是一个新的实例。不能为空。</target>
        </trans-unit>
        <trans-unit id="7ff1724ae2775960bc3b129d71cefa43e6c05193" translate="yes" xml:space="preserve">
          <source>The updated name (not a new instance).</source>
          <target state="translated">更新后的名称(不是新的实例)。</target>
        </trans-unit>
        <trans-unit id="355083b7f57eecb4574c96df4e2dcb55b6e39ceb" translate="yes" xml:space="preserve">
          <source>The updated time instant is then converted back into a &lt;a href=&quot;../../../../java.base/java/util/date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; object and used to update the given &lt;a href=&quot;../../../../java.base/java/util/date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">然后，将更新后的时刻转换回&lt;a href=&quot;../../../../java.base/java/util/date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;对象，并用于更新给定的&lt;a href=&quot;../../../../java.base/java/util/date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;对象。</target>
        </trans-unit>
        <trans-unit id="0baad8b72ddb35a83879b234fb143110d6defdf2" translate="yes" xml:space="preserve">
          <source>The updater methods are used to update column values in the current row or the insert row. The updater methods do not update the underlying database; instead the &lt;code&gt;updateRow&lt;/code&gt; or &lt;code&gt;insertRow&lt;/code&gt; methods are called to update the database.</source>
          <target state="translated">updater方法用于更新当前行或插入行中的列值。updater方法不会更新基础数据库；而是 &lt;code&gt;insertRow&lt;/code&gt; &lt;code&gt;updateRow&lt;/code&gt; 或insertRow方法来更新数据库。</target>
        </trans-unit>
        <trans-unit id="f2bcc2d49c180e5baf0e82f6c9fcc3ed64f68df8" translate="yes" xml:space="preserve">
          <source>The updater methods may be used in two ways:</source>
          <target state="translated">更新器方法可采用两种方式。</target>
        </trans-unit>
        <trans-unit id="c660520ce3264961f8c352c1ced2cca916613b71" translate="yes" xml:space="preserve">
          <source>The upgrade module path</source>
          <target state="translated">升级模块路径</target>
        </trans-unit>
        <trans-unit id="7e25e2dbc84508e95baa5cc07d894f889b8081b4" translate="yes" xml:space="preserve">
          <source>The upgrade module path. This path contains compiled definitions of modules that will be observed in preference to the compiled definitions of any</source>
          <target state="translated">升级模块路径。这个路径包含了模块的编译定义,这些模块将优先于任何模块的编译定义而被遵守。</target>
        </trans-unit>
        <trans-unit id="511c2c3c9bc3521c1996f4c7cf9369304efc81da" translate="yes" xml:space="preserve">
          <source>The upper bound for the value.</source>
          <target state="translated">值的上界。</target>
        </trans-unit>
        <trans-unit id="52b9900dc95e3fff929d15c46c76d6028fddcc38" translate="yes" xml:space="preserve">
          <source>The upper left corner of the Raster is given by the location argument. If location is null, (0, 0) will be used. The dataType parameter should be one of the enumerated values defined in the DataBuffer class.</source>
          <target state="translated">Raster的左上角由location参数给出。如果location为空,将使用(0,0)。dataType参数应该是DataBuffer类中定义的枚举值之一。</target>
        </trans-unit>
        <trans-unit id="67d6b1496d85bc73b81c00c805158bd666f5dfae" translate="yes" xml:space="preserve">
          <source>The upper left corner of the Raster is given by the location argument. The dataType parameter should be one of the enumerated values defined in the DataBuffer class.</source>
          <target state="translated">Raster的左上角由位置参数给出。dataType参数应该是DataBuffer类中定义的枚举值之一。</target>
        </trans-unit>
        <trans-unit id="9e5507eac7b1c8f8528ce3b0b75192849c664597" translate="yes" xml:space="preserve">
          <source>The upper-case variant of &lt;code&gt;'a'&lt;/code&gt;. The entire string representing the number will be converted to upper case including the &lt;code&gt;'x'&lt;/code&gt; (&lt;code&gt;'\u0078'&lt;/code&gt;) and &lt;code&gt;'p'&lt;/code&gt; (&lt;code&gt;'\u0070'&lt;/code&gt; and all hexadecimal digits &lt;code&gt;'a'&lt;/code&gt; - &lt;code&gt;'f'&lt;/code&gt; (&lt;code&gt;'\u0061'&lt;/code&gt; - &lt;code&gt;'\u0066'&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;'a'&lt;/code&gt; 的大写变体。表示数字的整个字符串将被转换为大写包括 &lt;code&gt;'x'&lt;/code&gt; （ &lt;code&gt;'\u0078'&lt;/code&gt; ）和 &lt;code&gt;'p'&lt;/code&gt; （ &lt;code&gt;'\u0070'&lt;/code&gt; 和所有十六进制数字 &lt;code&gt;'a'&lt;/code&gt; - &lt;code&gt;'f'&lt;/code&gt; （ &lt;code&gt;'\u0061'&lt;/code&gt; - &lt;code&gt;'\u0066'&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="13c5bb73738331e23e3b8d0a094ce01abeb63f19" translate="yes" xml:space="preserve">
          <source>The upper-case variant of &lt;code&gt;'b'&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;'b'&lt;/code&gt; 的大写变体。</target>
        </trans-unit>
        <trans-unit id="322e75fb849065f4ca52a6addf60e0ac9b017449" translate="yes" xml:space="preserve">
          <source>The upper-case variant of &lt;code&gt;'c'&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;'c'&lt;/code&gt; 的大写变体。</target>
        </trans-unit>
        <trans-unit id="a34a284aaae73cba16fd4c94692a85c43d38c457" translate="yes" xml:space="preserve">
          <source>The upper-case variant of &lt;code&gt;'e'&lt;/code&gt;. The exponent symbol will be &lt;code&gt;'E'&lt;/code&gt; (&lt;code&gt;'\u0045'&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;'e'&lt;/code&gt; 的大写变体。指数符号为 &lt;code&gt;'E'&lt;/code&gt; （ &lt;code&gt;'\u0045'&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="8e4023159140f742a67dc9be0c2aef26ca29decf" translate="yes" xml:space="preserve">
          <source>The upper-case variant of &lt;code&gt;'g'&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;'g'&lt;/code&gt; 的大写变体。</target>
        </trans-unit>
        <trans-unit id="0a797a98a3e9c41bf7072b33c0c5562f599482a3" translate="yes" xml:space="preserve">
          <source>The upper-case variant of &lt;code&gt;'h'&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;'h'&lt;/code&gt; 的大写变体。</target>
        </trans-unit>
        <trans-unit id="07e68ff070c96b0a5cf38a9497cd5a90681077a0" translate="yes" xml:space="preserve">
          <source>The upper-case variant of &lt;code&gt;'s'&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;'s'&lt;/code&gt; 的大写变体。</target>
        </trans-unit>
        <trans-unit id="6d089cd4117c5c549f52accd43d02871b2e37215" translate="yes" xml:space="preserve">
          <source>The upper-case variant of &lt;code&gt;'t'&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;'t'&lt;/code&gt; 的大写变体。</target>
        </trans-unit>
        <trans-unit id="3c81156a71ca9fedc956a7ac507aef205ed19e69" translate="yes" xml:space="preserve">
          <source>The upper-case variant of &lt;code&gt;'x'&lt;/code&gt;. The entire string representing the number will be converted to &lt;a href=&quot;../lang/string#toUpperCase(java.util.Locale)&quot;&gt;upper case&lt;/a&gt; including the &lt;code&gt;'x'&lt;/code&gt; (if any) and all hexadecimal digits &lt;code&gt;'a'&lt;/code&gt; - &lt;code&gt;'f'&lt;/code&gt; (&lt;code&gt;'\u0061'&lt;/code&gt; - &lt;code&gt;'\u0066'&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;'x'&lt;/code&gt; 的大写变体。代表数字的整个字符串将转换为&lt;a href=&quot;../lang/string#toUpperCase(java.util.Locale)&quot;&gt;大写，&lt;/a&gt;包括 &lt;code&gt;'x'&lt;/code&gt; （如果有）和所有十六进制数字 &lt;code&gt;'a'&lt;/code&gt; - &lt;code&gt;'f'&lt;/code&gt; （ &lt;code&gt;'\u0061'&lt;/code&gt; - &lt;code&gt;'\u0066'&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="a786ff8547a2a8f3e96b122c7d43bbbbe0cec7bd" translate="yes" xml:space="preserve">
          <source>The upper-case variant of &lt;code&gt;'x'&lt;/code&gt;. The entire string representing the number will be converted to &lt;a href=&quot;../lang/string#toUpperCase-java.util.Locale-&quot;&gt;upper case&lt;/a&gt; including the &lt;code&gt;'x'&lt;/code&gt; (if any) and all hexadecimal digits &lt;code&gt;'a'&lt;/code&gt; - &lt;code&gt;'f'&lt;/code&gt; (&lt;code&gt;'\u0061'&lt;/code&gt; - &lt;code&gt;'\u0066'&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;'x'&lt;/code&gt; 的大写变体。代表数字的整个字符串将转换为&lt;a href=&quot;../lang/string#toUpperCase-java.util.Locale-&quot;&gt;大写，&lt;/a&gt;包括 &lt;code&gt;'x'&lt;/code&gt; （如果有）和所有十六进制数字 &lt;code&gt;'a'&lt;/code&gt; - &lt;code&gt;'f'&lt;/code&gt; （ &lt;code&gt;'\u0061'&lt;/code&gt; - &lt;code&gt;'\u0066'&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="654f2289487545b8f3928941dfdc0d162440284e" translate="yes" xml:space="preserve">
          <source>The uppercase letters &lt;code&gt;'A'&lt;/code&gt; through &lt;code&gt;'Z'&lt;/code&gt; (&lt;code&gt;'\u0041'&lt;/code&gt; through &lt;code&gt;'\u005a'&lt;/code&gt;),</source>
          <target state="translated">大写字母 &lt;code&gt;'A'&lt;/code&gt; 至 &lt;code&gt;'Z'&lt;/code&gt; （ &lt;code&gt;'\u0041'&lt;/code&gt; 至 &lt;code&gt;'\u005a'&lt;/code&gt; ），</target>
        </trans-unit>
        <trans-unit id="4330d8d1977e43b23dd07bee2099b3f4b622bfa6" translate="yes" xml:space="preserve">
          <source>The url string has the following expected structure.</source>
          <target state="translated">url字符串具有以下预期结构。</target>
        </trans-unit>
        <trans-unit id="4cf7c2a834de05ed4f93377051cbab9b134c7cbe" translate="yes" xml:space="preserve">
          <source>The usage of the pseudo/hidden column cannot be determined.</source>
          <target state="translated">伪/隐藏列的用法无法确定。</target>
        </trans-unit>
        <trans-unit id="4af9a221919250af2a20e619455ccc9a51cf8601" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;synchronized&lt;/code&gt; methods or statements provides access to the implicit monitor lock associated with every object, but forces all lock acquisition and release to occur in a block-structured way: when multiple locks are acquired they must be released in the opposite order, and all locks must be released in the same lexical scope in which they were acquired.</source>
          <target state="translated">使用 &lt;code&gt;synchronized&lt;/code&gt; 方法或语句可以访问与每个对象关联的隐式监视器锁，但是强制所有锁的获取和释放以块结构的方式发生：当获取多个锁时，它们必须以相反的顺序释放，并且所有锁必须在获得它们的相同词汇范围内释放。</target>
        </trans-unit>
        <trans-unit id="f768e19a63b5119836728427dc1a9e6eab8e5416" translate="yes" xml:space="preserve">
          <source>The use of Object is conventional, and because the lookup modes are limited, there is no special access provided to the internals of Object, its package or its module. Consequently, the lookup context of this lookup object will be the bootstrap class loader, which means it cannot find user classes.</source>
          <target state="translated">Object的使用是传统的,由于查找模式是有限的,所以没有提供对Object的内部、其包或其模块的特殊访问。因此,该查找对象的查找上下文将是引导类加载器,这意味着它不能查找用户类。</target>
        </trans-unit>
        <trans-unit id="7864af2b761ca48231a7aca9c9fd7fe90f2ffeac" translate="yes" xml:space="preserve">
          <source>The use of Object is conventional, and because the lookup modes are limited, there is no special access provided to the internals of Object, its package or its module. This public lookup object or other lookup object with &lt;code&gt;UNCONDITIONAL&lt;/code&gt; mode assumes readability. Consequently, the lookup class is not used to determine the lookup context.</source>
          <target state="translated">Object的使用是常规的，并且由于查找模式受到限制，因此没有提供对Objects的内部，其包或模块的特殊访问。具有 &lt;code&gt;UNCONDITIONAL&lt;/code&gt; 模式的此公共查找对象或其他查找对象假定具有可读性。因此，查找类不用于确定查找上下文。</target>
        </trans-unit>
        <trans-unit id="63a7e152cb80dbfba69bf4ce931d07a2966b3c06" translate="yes" xml:space="preserve">
          <source>The use of a &lt;code&gt;Supplier&lt;/code&gt; in this form provides a level of indirection that reduces the scope of potential interference with the source. Since the supplier is only invoked after the terminal operation commences, any modifications to the source up to the start of the terminal operation are reflected in the stream result. See &lt;a href=&quot;package-summary#NonInterference&quot;&gt;Non-Interference&lt;/a&gt; for more details.</source>
          <target state="translated">以这种形式使用 &lt;code&gt;Supplier&lt;/code&gt; 提供了一定程度的间接性，从而减少了对源的潜在干扰范围。由于仅在终端操作开始之后才调用供应商，因此直到终端操作开始之前对源的任何修改都会反映在流结果中。有关更多详细信息，请参见&lt;a href=&quot;package-summary#NonInterference&quot;&gt;无干扰&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="454af7b03b7693d82fd0e4233351ee60b0851423" translate="yes" xml:space="preserve">
          <source>The user can also, when creating his own MBean relation class, have it extending RelationSupport, to retrieve the implementations of required interfaces (see below).</source>
          <target state="translated">用户在创建自己的MBean关系类时,也可以让它扩展RelationSupport,以检索所需接口的实现(见下文)。</target>
        </trans-unit>
        <trans-unit id="24733a45de02fe91d2ff96dd9438e11624cd8893" translate="yes" xml:space="preserve">
          <source>The user can specify the keytab location by using the option &lt;code&gt;keyTab&lt;/code&gt; in the configuration entry.</source>
          <target state="translated">用户可以使用配置条目中的选项 &lt;code&gt;keyTab&lt;/code&gt; 来指定keytab位置。</target>
        </trans-unit>
        <trans-unit id="8ad00fa84e19a6fca6352926bdfa6128425f1dd8" translate="yes" xml:space="preserve">
          <source>The user can specify the location of the ticket cache by using the option &lt;code&gt;ticketCache&lt;/code&gt; in the configuration entry.</source>
          <target state="translated">用户可以使用配置条目中的选项 &lt;code&gt;ticketCache&lt;/code&gt; 指定票证缓存的位置。</target>
        </trans-unit>
        <trans-unit id="df61ad83755512938c568feb25a069781cb800fc" translate="yes" xml:space="preserve">
          <source>The user data object. It is used for whatever data the notification source wishes to communicate to its consumers.</source>
          <target state="translated">用户数据对象。它用于通知源希望向其消费者传达的任何数据。</target>
        </trans-unit>
        <trans-unit id="f0196edde65cd18b677e6ea628933698bb77d6b6" translate="yes" xml:space="preserve">
          <source>The user data. The buffers position will be &lt;code&gt;0&lt;/code&gt; and its limit will be set to the end of the data.</source>
          <target state="translated">用户数据。缓冲区位置将为 &lt;code&gt;0&lt;/code&gt; ，其限制将设置为数据的末尾。</target>
        </trans-unit>
        <trans-unit id="36576d2c09dab27f1344420ca4bb05561dde7b39" translate="yes" xml:space="preserve">
          <source>The user doclet must implement this interface, as described in the &lt;a href=&quot;package-summary#package.description&quot;&gt;package description&lt;/a&gt;.</source>
          <target state="translated">如&lt;a href=&quot;package-summary#package.description&quot;&gt;包装说明中&lt;/a&gt;所述，用户doclet必须实现此接口。</target>
        </trans-unit>
        <trans-unit id="60a2448648f9fae5af8b19489689406b3bc11b9a" translate="yes" xml:space="preserve">
          <source>The user doclet must implement this interface, as described in the &lt;a href=&quot;package-summary#package.description&quot;&gt;package description&lt;/a&gt;. Each implementation of a Doclet must provide a public no-argument constructor to be used by tools to instantiate the doclet. The tool infrastructure will interact with classes implementing this interface as follows:</source>
          <target state="translated">如&lt;a href=&quot;package-summary#package.description&quot;&gt;包装说明中&lt;/a&gt;所述，用户doclet必须实现此接口。Doclet的每个实现都必须提供一个公共的无参数构造函数，以便工具实例化doclet。工具基础结构将与实现此接口的类进行交互，如下所示：</target>
        </trans-unit>
        <trans-unit id="3db14b3d19120ebd8508e01afa1c48fe94d62e5d" translate="yes" xml:space="preserve">
          <source>The user drop action is chosen for a drop as described in the documentation for &lt;a href=&quot;../../java/awt/dnd/droptargetdragevent&quot;&gt;&lt;code&gt;DropTargetDragEvent&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../java/awt/dnd/droptargetdropevent&quot;&gt;&lt;code&gt;DropTargetDropEvent&lt;/code&gt;&lt;/a&gt;. A different action may be chosen as the drop action by way of the &lt;code&gt;setDropAction&lt;/code&gt; method.</source>
          <target state="translated">如&lt;a href=&quot;../../java/awt/dnd/droptargetdragevent&quot;&gt; &lt;code&gt;DropTargetDragEvent&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../java/awt/dnd/droptargetdropevent&quot;&gt; &lt;code&gt;DropTargetDropEvent&lt;/code&gt; &lt;/a&gt;的文档中所述，为放置选择了用户放置动作。可以通过 &lt;code&gt;setDropAction&lt;/code&gt; 方法选择其他动作作为放置动作。</target>
        </trans-unit>
        <trans-unit id="ded37dd355a5696c21e0eddb21f83620c05ca906" translate="yes" xml:space="preserve">
          <source>The user has activated the &lt;em&gt;line down&lt;/em&gt; area of a scroll bar.</source>
          <target state="translated">用户已激活滚动条的&lt;em&gt;下移&lt;/em&gt;区域。</target>
        </trans-unit>
        <trans-unit id="a39c75ca8c5af9e1d6071e0c53aa08a01e2ada67" translate="yes" xml:space="preserve">
          <source>The user has activated the &lt;em&gt;line up&lt;/em&gt; area of a scroll bar.</source>
          <target state="translated">的用户已经激活了&lt;em&gt;排队&lt;/em&gt;的滚动条的区域。</target>
        </trans-unit>
        <trans-unit id="173345745a92c74955436882d12492db2df03cd8" translate="yes" xml:space="preserve">
          <source>The user has activated the &lt;em&gt;page down&lt;/em&gt; area of a scroll bar.</source>
          <target state="translated">用户已激活滚动条的下&lt;em&gt;翻页&lt;/em&gt;区域。</target>
        </trans-unit>
        <trans-unit id="193d0a150699d577c9a383562d0f5b4713e8495f" translate="yes" xml:space="preserve">
          <source>The user has activated the &lt;em&gt;page up&lt;/em&gt; area of a scroll bar.</source>
          <target state="translated">用户已经激活了&lt;em&gt;向上翻页&lt;/em&gt;滚动条的面积。</target>
        </trans-unit>
        <trans-unit id="5e0125de9eae2e97f0496830f88ba461cb0bd321" translate="yes" xml:space="preserve">
          <source>The user has asked the window manager to de-iconify the window.</source>
          <target state="translated">用户要求窗口管理器去掉窗口的图标。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
