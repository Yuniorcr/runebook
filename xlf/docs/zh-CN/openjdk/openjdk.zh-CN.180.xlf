<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="openjdk">
    <body>
      <group id="openjdk">
        <trans-unit id="170446f14af0c3b5edf1e2175605649be1920422" translate="yes" xml:space="preserve">
          <source>W3C XML Schema 1.0</source>
          <target state="translated">W3C XML Schema 1.0</target>
        </trans-unit>
        <trans-unit id="37586f773561615e8929c9418faba3b4a6a22221" translate="yes" xml:space="preserve">
          <source>W3C XML Schema 1.0 Part 2, Appendix D, ISO 8601 Date and Time Formats</source>
          <target state="translated">W3C XML Schema 1.0第2部分,附录D,ISO 8601日期和时间格式。</target>
        </trans-unit>
        <trans-unit id="77d0e99768248c6081369e0598fd5cf03d27af2e" translate="yes" xml:space="preserve">
          <source>W3C XML Schema 1.0 Part 2, Section 3.2.7-14</source>
          <target state="translated">W3C XML Schema 1.0第2部分,第3.2.7-14节。</target>
        </trans-unit>
        <trans-unit id="271c8d39a4392e9a0a2de219da136491c71de5d1" translate="yes" xml:space="preserve">
          <source>W3C XML Schema Data Type</source>
          <target state="translated">W3C XML Schema数据类型</target>
        </trans-unit>
        <trans-unit id="c2662a24f5eb4cfc1c0048662fdf479ff933df83" translate="yes" xml:space="preserve">
          <source>W3C XML Schema Instance Namespace URI.</source>
          <target state="translated">W3C XML Schema实例命名空间URI。</target>
        </trans-unit>
        <trans-unit id="82e488d4f831e35263673137dd6418f2df5380e2" translate="yes" xml:space="preserve">
          <source>W3C XML Schema Namespace URI.</source>
          <target state="translated">W3C XML Schema命名空间URI。</target>
        </trans-unit>
        <trans-unit id="84bf3d44dfe2e52293cb8a13de350992d23c0d74" translate="yes" xml:space="preserve">
          <source>W3C XML Schema data types that have a &quot;&lt;em&gt;natural&lt;/em&gt;&quot; mapping to Java types are defined by JSR 31: Java Architecture for XML Binding (JAXB) Specification, Binding XML Schema to Java Representations. JAXB defined mappings for XML Schema built-in data types include:</source>
          <target state="translated">JSR 31：&amp;ldquo;用于XML绑定的Java体系结构（JAXB）规范，将XML Schema绑定到Java表示形式&amp;rdquo;定义了到Java类型具有&amp;ldquo;&lt;em&gt;自然&lt;/em&gt;&amp;rdquo;映射的W3C XML Schema数据类型。JAXB为XML Schema内置数据类型定义的映射包括：</target>
        </trans-unit>
        <trans-unit id="ffaa3df1fc8b0442dd2ac58849dce19642c68925" translate="yes" xml:space="preserve">
          <source>W3C XML Schema data types that have a &quot;&lt;em&gt;natural&lt;/em&gt;&quot; mapping to Java types are defined by JSR 31: Java&amp;trade; Architecture for XML Binding (JAXB) Specification, Binding XML Schema to Java Representations. JAXB defined mappings for XML Schema built-in data types include:</source>
          <target state="translated">具有&amp;ldquo;&lt;em&gt;自然&lt;/em&gt;&amp;rdquo;映射到Java类型的W3C XML Schema数据类型由JSR 31：Java&amp;trade;XML绑定体系结构（JAXB）规范，将XML Schema绑定到Java表示形式定义。JAXB为XML Schema内置数据类型定义的映射包括：</target>
        </trans-unit>
        <trans-unit id="a761a1b61a68301345dca838116ba86c93849e7d" translate="yes" xml:space="preserve">
          <source>W3C XML Schema max timezone offset is -14:00.</source>
          <target state="translated">W3C XML Schema最大时区偏移为-14:00。</target>
        </trans-unit>
        <trans-unit id="ba00d5307494d8298fcec94af8aa33278a51de05" translate="yes" xml:space="preserve">
          <source>W3C XML Schema max timezone offset is -14:00. Zone offset is in minutes.</source>
          <target state="translated">W3C XML Schema最大时区偏移为-14:00。区位偏移以分钟为单位。</target>
        </trans-unit>
        <trans-unit id="f1ba4ba235f2b16bd8d96965919b13e4c57aea93" translate="yes" xml:space="preserve">
          <source>W3C XML Schema min timezone offset is +14:00.</source>
          <target state="translated">W3C XML Schema最小时区偏移为+14:00。</target>
        </trans-unit>
        <trans-unit id="cb5e294b315aa8b940877f2d9f7afcd5867f5239" translate="yes" xml:space="preserve">
          <source>W3C XML Schema min timezone offset is +14:00. Zone offset is in minutes.</source>
          <target state="translated">W3C XML Schema的最小时区偏移是+14:00。区位偏移的单位是分钟。</target>
        </trans-unit>
        <trans-unit id="63aa49bdd6eace38cc5a1a490b7a570e23754674" translate="yes" xml:space="preserve">
          <source>W3C XML Schema/Java Type Mappings</source>
          <target state="translated">W3C XML Schema/Java类型映射。</target>
        </trans-unit>
        <trans-unit id="6f88114b7a3a3b003272de4b3310ad49e63118f8" translate="yes" xml:space="preserve">
          <source>W3C XPath Datatype Namespace URI.</source>
          <target state="translated">W3C XPath数据类型命名空间URI。</target>
        </trans-unit>
        <trans-unit id="3d70d9a4e7af5c5acd8b7d87967c6559887d069d" translate="yes" xml:space="preserve">
          <source>W3C_LENGTH_UNITS</source>
          <target state="translated">W3C_LENGTH_UNITS</target>
        </trans-unit>
        <trans-unit id="56b3882ae7da2a0457386cf62046357c6e11049a" translate="yes" xml:space="preserve">
          <source>W3C_XML_SCHEMA_INSTANCE_NS_URI</source>
          <target state="translated">W3C_XML_SCHEMA_INSTANCE_NS_URI</target>
        </trans-unit>
        <trans-unit id="15d6c45b8f100a1de5044b3074aab5b39ee10103" translate="yes" xml:space="preserve">
          <source>W3C_XML_SCHEMA_NS_URI</source>
          <target state="translated">W3C_XML_SCHEMA_NS_URI</target>
        </trans-unit>
        <trans-unit id="cc837d56de0408bb2ac326794f32a1214d8bc10b" translate="yes" xml:space="preserve">
          <source>W3C_XPATH_DATATYPE_NS_URI</source>
          <target state="translated">W3C_XPATH_DATATYPE_NS_URI</target>
        </trans-unit>
        <trans-unit id="fa40942465857f664ea96930c1265cf73e3d0101" translate="yes" xml:space="preserve">
          <source>WAIS</source>
          <target state="translated">WAIS</target>
        </trans-unit>
        <trans-unit id="c271b656dedb85a67db52b58a06c052fe2ee23cc" translate="yes" xml:space="preserve">
          <source>WAITING</source>
          <target state="translated">WAITING</target>
        </trans-unit>
        <trans-unit id="4d6eec56cc4f076f9cc55092f478e2df2c607b64" translate="yes" xml:space="preserve">
          <source>WAIT_CURSOR</source>
          <target state="translated">WAIT_CURSOR</target>
        </trans-unit>
        <trans-unit id="101c43203a1a82572069e87c5288e77247fa4c44" translate="yes" xml:space="preserve">
          <source>WALL</source>
          <target state="translated">WALL</target>
        </trans-unit>
        <trans-unit id="225462bfb6556f3c24cf6d83becfd70d5f9d94e9" translate="yes" xml:space="preserve">
          <source>WALL_TIME</source>
          <target state="translated">WALL_TIME</target>
        </trans-unit>
        <trans-unit id="fdf489de6abf41d264e1a7aeea4ce59aa5cbd9a9" translate="yes" xml:space="preserve">
          <source>WANCHO</source>
          <target state="translated">WANCHO</target>
        </trans-unit>
        <trans-unit id="b3a0d21a0628d8bcfed93c1cb0f4f2031fae0a9e" translate="yes" xml:space="preserve">
          <source>WANTS_INPUT_PROPERTY</source>
          <target state="translated">WANTS_INPUT_PROPERTY</target>
        </trans-unit>
        <trans-unit id="2336c8cd0ff846d09239bd890b2dfd2f5b9f3b04" translate="yes" xml:space="preserve">
          <source>WARANG_CITI</source>
          <target state="translated">WARANG_CITI</target>
        </trans-unit>
        <trans-unit id="fd3edc641024a335a508fdacefb5f51ded5905cc" translate="yes" xml:space="preserve">
          <source>WARNING</source>
          <target state="translated">WARNING</target>
        </trans-unit>
        <trans-unit id="777d9894a8988f31ac1673a5e301f9ac39b37de4" translate="yes" xml:space="preserve">
          <source>WARNING is a message level indicating a potential problem.</source>
          <target state="translated">WARNING是一个表示潜在问题的信息级别。</target>
        </trans-unit>
        <trans-unit id="e9e69012c4cb989d3300b2fe8889ed233de2829c" translate="yes" xml:space="preserve">
          <source>WARNING message type.</source>
          <target state="translated">警告信息类型:</target>
        </trans-unit>
        <trans-unit id="d94056adc4a50baf8bc7d81233c438daa91a1d21" translate="yes" xml:space="preserve">
          <source>WARNING: Aside from those keys that are defined by the Java language (VK_ENTER, VK_BACK_SPACE, and VK_TAB), do not rely on the values of the VK_ constants. The platform steward reserves the right to change these values as needed to accommodate a wider range of keyboards in the future.</source>
          <target state="translated">警告:除了那些由Java语言定义的键(VK_ENTER、VK_BACK_SPACE和VK_TAB)之外,不要依赖VK_常量的值。平台管家保留根据需要改变这些值的权利,以适应未来更广泛的键盘。</target>
        </trans-unit>
        <trans-unit id="7d1674b5c146f7fb18afc62ad021342d8720b8c7" translate="yes" xml:space="preserve">
          <source>WARNING: No dithering takes place.</source>
          <target state="translated">警告:不发生抖动。</target>
        </trans-unit>
        <trans-unit id="8f7e2444369b17f6a9e6d13672ae7fa705c05f63" translate="yes" xml:space="preserve">
          <source>WARNING_DIALOG</source>
          <target state="translated">WARNING_DIALOG</target>
        </trans-unit>
        <trans-unit id="0fdb63e04ed8f636c508025987f608fd6233e853" translate="yes" xml:space="preserve">
          <source>WARNING_MESSAGE</source>
          <target state="translated">WARNING_MESSAGE</target>
        </trans-unit>
        <trans-unit id="fb914d3ca1348f0c104408c5794fe186ea61f9b4" translate="yes" xml:space="preserve">
          <source>WAVE</source>
          <target state="translated">WAVE</target>
        </trans-unit>
        <trans-unit id="762dd6a7da550e7b6fdc00b417847fd608d3d449" translate="yes" xml:space="preserve">
          <source>WBMP</source>
          <target state="translated">WBMP</target>
        </trans-unit>
        <trans-unit id="441e113a8be2d0d25038d1f2e4db42495ebe43bb" translate="yes" xml:space="preserve">
          <source>WBMP metadata</source>
          <target state="translated">WBMP元数据</target>
        </trans-unit>
        <trans-unit id="08a5164936a6007b1abd2d96d96fb4f14a463abb" translate="yes" xml:space="preserve">
          <source>WBMP metadata format</source>
          <target state="translated">WBMP元数据格式</target>
        </trans-unit>
        <trans-unit id="6e5801dcccbfde2a61ceca25ae96d3e75c518efe" translate="yes" xml:space="preserve">
          <source>WEAK_COMPARE_AND_SET</source>
          <target state="translated">WEAK_COMPARE_AND_SET</target>
        </trans-unit>
        <trans-unit id="3783cde1d6e5911aaab1d5ab97e08f789c60850d" translate="yes" xml:space="preserve">
          <source>WEAK_COMPARE_AND_SET_ACQUIRE</source>
          <target state="translated">WEAK_COMPARE_AND_SET_ACQUIRE</target>
        </trans-unit>
        <trans-unit id="70e04de5609ecd79a8fbff809af628951f2ab16a" translate="yes" xml:space="preserve">
          <source>WEAK_COMPARE_AND_SET_PLAIN</source>
          <target state="translated">WEAK_COMPARE_AND_SET_PLAIN</target>
        </trans-unit>
        <trans-unit id="d326a6137b4f3dc410a47c8858504305dc17e2c5" translate="yes" xml:space="preserve">
          <source>WEAK_COMPARE_AND_SET_RELEASE</source>
          <target state="translated">WEAK_COMPARE_AND_SET_RELEASE</target>
        </trans-unit>
        <trans-unit id="a86e95a3de6c6d679d6527aad5d93c5216555e6f" translate="yes" xml:space="preserve">
          <source>WEDNESDAY</source>
          <target state="translated">WEDNESDAY</target>
        </trans-unit>
        <trans-unit id="269ec4fae923a139b94c8dd206cdddcb59b23aa6" translate="yes" xml:space="preserve">
          <source>WEEKS</source>
          <target state="translated">WEEKS</target>
        </trans-unit>
        <trans-unit id="6f1c3d0860aa987c5f6e26c58ffaad4fe52dec56" translate="yes" xml:space="preserve">
          <source>WEEK_BASED_YEAR</source>
          <target state="translated">WEEK_BASED_YEAR</target>
        </trans-unit>
        <trans-unit id="9ee8eb01243e91a5b269b562f28c884ccb95f401" translate="yes" xml:space="preserve">
          <source>WEEK_BASED_YEARS</source>
          <target state="translated">WEEK_BASED_YEARS</target>
        </trans-unit>
        <trans-unit id="c95b132075af91925d3c2134c3fe5f729c60f0b1" translate="yes" xml:space="preserve">
          <source>WEEK_OF_MONTH</source>
          <target state="translated">WEEK_OF_MONTH</target>
        </trans-unit>
        <trans-unit id="98b20d168600b565fc84f5f7957805b55c109649" translate="yes" xml:space="preserve">
          <source>WEEK_OF_MONTH_FIELD</source>
          <target state="translated">WEEK_OF_MONTH_FIELD</target>
        </trans-unit>
        <trans-unit id="846bf32311a73ea91eefa5bc3874bfd5749b75a1" translate="yes" xml:space="preserve">
          <source>WEEK_OF_WEEK_BASED_YEAR</source>
          <target state="translated">WEEK_OF_WEEK_BASED_YEAR</target>
        </trans-unit>
        <trans-unit id="9ce3e66f3ec1aa53225ad36212840b0d2fc47f5d" translate="yes" xml:space="preserve">
          <source>WEEK_OF_YEAR</source>
          <target state="translated">WEEK_OF_YEAR</target>
        </trans-unit>
        <trans-unit id="4a1fa630771f8e5cf64861a7b9e3c6637ca68c80" translate="yes" xml:space="preserve">
          <source>WEEK_OF_YEAR_FIELD</source>
          <target state="translated">WEEK_OF_YEAR_FIELD</target>
        </trans-unit>
        <trans-unit id="d9ce8f10bcdab56b0a48a10f5cc6fb6ed8d35088" translate="yes" xml:space="preserve">
          <source>WEIGHT</source>
          <target state="translated">WEIGHT</target>
        </trans-unit>
        <trans-unit id="798c3508b013fc0e7795592c7e89393fcb1a7301" translate="yes" xml:space="preserve">
          <source>WEIGHT_BOLD</source>
          <target state="translated">WEIGHT_BOLD</target>
        </trans-unit>
        <trans-unit id="c56be856f0b67fbcea562921c9bc9eb751ecb52b" translate="yes" xml:space="preserve">
          <source>WEIGHT_DEMIBOLD</source>
          <target state="translated">WEIGHT_DEMIBOLD</target>
        </trans-unit>
        <trans-unit id="5d932cd773811aa53e846f4dcf331780ac0fd98e" translate="yes" xml:space="preserve">
          <source>WEIGHT_DEMILIGHT</source>
          <target state="translated">WEIGHT_DEMILIGHT</target>
        </trans-unit>
        <trans-unit id="637834ab0b0f9708c386b161eb45803092809c73" translate="yes" xml:space="preserve">
          <source>WEIGHT_EXTRABOLD</source>
          <target state="translated">WEIGHT_EXTRABOLD</target>
        </trans-unit>
        <trans-unit id="0b9cac5b4ba244248c014a918f5b0fcc2a3c86f6" translate="yes" xml:space="preserve">
          <source>WEIGHT_EXTRA_LIGHT</source>
          <target state="translated">WEIGHT_EXTRA_LIGHT</target>
        </trans-unit>
        <trans-unit id="ba8a2666e48b47e20913dae11144560f4cd619ea" translate="yes" xml:space="preserve">
          <source>WEIGHT_HEAVY</source>
          <target state="translated">WEIGHT_HEAVY</target>
        </trans-unit>
        <trans-unit id="a22369bcc41b9bdc9627efe05b4d14aa4e8821f8" translate="yes" xml:space="preserve">
          <source>WEIGHT_LIGHT</source>
          <target state="translated">WEIGHT_LIGHT</target>
        </trans-unit>
        <trans-unit id="eb6df2bb75a6b425cf368477ef6785a1e75a0e58" translate="yes" xml:space="preserve">
          <source>WEIGHT_MEDIUM</source>
          <target state="translated">WEIGHT_MEDIUM</target>
        </trans-unit>
        <trans-unit id="ff3d47fe6b036e793f8a49a44c1ec01a4f787c6d" translate="yes" xml:space="preserve">
          <source>WEIGHT_REGULAR</source>
          <target state="translated">WEIGHT_REGULAR</target>
        </trans-unit>
        <trans-unit id="2bcd6798d0bb29626c95e23aac8904cbd543fe63" translate="yes" xml:space="preserve">
          <source>WEIGHT_REGULAR, WEIGHT_BOLD</source>
          <target state="translated">WEIGHT_REGULAR,WEIGHT_BOLD(粗体)</target>
        </trans-unit>
        <trans-unit id="ff3c1c5dd38257d20f9395f2034a830f2d7e58c0" translate="yes" xml:space="preserve">
          <source>WEIGHT_SEMIBOLD</source>
          <target state="translated">WEIGHT_SEMIBOLD</target>
        </trans-unit>
        <trans-unit id="a590a5de30a230b9828d55f1cb23b91525977c72" translate="yes" xml:space="preserve">
          <source>WEIGHT_ULTRABOLD</source>
          <target state="translated">WEIGHT_ULTRABOLD</target>
        </trans-unit>
        <trans-unit id="50bd64333fee683dd2e31a9162044fe5c41dd3a4" translate="yes" xml:space="preserve">
          <source>WEST</source>
          <target state="translated">WEST</target>
        </trans-unit>
        <trans-unit id="fc8f4a59dd8a9eb56798b48a128dfd4aa795f14b" translate="yes" xml:space="preserve">
          <source>WHEEL_BLOCK_SCROLL</source>
          <target state="translated">WHEEL_BLOCK_SCROLL</target>
        </trans-unit>
        <trans-unit id="1f0150b303ef5eab00cebc4e9fb73dfefe005640" translate="yes" xml:space="preserve">
          <source>WHEEL_UNIT_SCROLL</source>
          <target state="translated">WHEEL_UNIT_SCROLL</target>
        </trans-unit>
        <trans-unit id="9327748bde1287d957ca3d4cc36145b457fdeb8a" translate="yes" xml:space="preserve">
          <source>WHEN_ANCESTOR_OF_FOCUSED_COMPONENT</source>
          <target state="translated">WHEN_ANCESTOR_OF_FOCUSED_COMPONENT</target>
        </trans-unit>
        <trans-unit id="c2ec3c4bf9f50d42fc83d2ec4333ffd0596530a6" translate="yes" xml:space="preserve">
          <source>WHEN_FOCUSED</source>
          <target state="translated">WHEN_FOCUSED</target>
        </trans-unit>
        <trans-unit id="237f6b22e2c305ffcf7f0307b2d889f52267b8e5" translate="yes" xml:space="preserve">
          <source>WHEN_IN_FOCUSED_WINDOW</source>
          <target state="translated">WHEN_IN_FOCUSED_WINDOW</target>
        </trans-unit>
        <trans-unit id="d6b9e1446d49c1a5077b747e616219bedcdc9b9f" translate="yes" xml:space="preserve">
          <source>WHERE_CLAUSE_ONLY</source>
          <target state="translated">WHERE_CLAUSE_ONLY</target>
        </trans-unit>
        <trans-unit id="986195fa2ccb3e6bcc0d7752ee51a526eab6f4c7" translate="yes" xml:space="preserve">
          <source>WHILE_LOOP</source>
          <target state="translated">WHILE_LOOP</target>
        </trans-unit>
        <trans-unit id="40d23f3b3af90554dade75ca1449213a1776239f" translate="yes" xml:space="preserve">
          <source>WHITE</source>
          <target state="translated">WHITE</target>
        </trans-unit>
        <trans-unit id="c1cd547450ddf19820dbba6198904ce66087e598" translate="yes" xml:space="preserve">
          <source>WHITESPACE</source>
          <target state="translated">WHITESPACE</target>
        </trans-unit>
        <trans-unit id="d194dea1795240817dfa4bd996d82fe187dabab1" translate="yes" xml:space="preserve">
          <source>WHITE_BALANCE_AUTO</source>
          <target state="translated">WHITE_BALANCE_AUTO</target>
        </trans-unit>
        <trans-unit id="41e86e6fe3188e861cfd8cd9ca282c460604b38e" translate="yes" xml:space="preserve">
          <source>WHITE_BALANCE_MANUAL</source>
          <target state="translated">WHITE_BALANCE_MANUAL</target>
        </trans-unit>
        <trans-unit id="1ffe1e73442645cbd5bb7e2150f72733ad744494" translate="yes" xml:space="preserve">
          <source>WHITE_SPACE</source>
          <target state="translated">WHITE_SPACE</target>
        </trans-unit>
        <trans-unit id="5e3d4c8c3394dc083bfb67877dcd60949f705f5f" translate="yes" xml:space="preserve">
          <source>WIDTH</source>
          <target state="translated">WIDTH</target>
        </trans-unit>
        <trans-unit id="2ccf926b7d7911891c3a63586cd085a087702c4c" translate="yes" xml:space="preserve">
          <source>WIDTH_CONDENSED</source>
          <target state="translated">WIDTH_CONDENSED</target>
        </trans-unit>
        <trans-unit id="4931e856d85a4b229703bca45afd5c120e0ad4b3" translate="yes" xml:space="preserve">
          <source>WIDTH_CONDENSED, WIDTH_REGULAR,</source>
          <target state="translated">WIDTH_CONDENSED,WIDTH_REGULAR,</target>
        </trans-unit>
        <trans-unit id="88b110346951865c1bb68a3ebb8acd67cdb6f5d4" translate="yes" xml:space="preserve">
          <source>WIDTH_EXTENDED</source>
          <target state="translated">WIDTH_EXTENDED</target>
        </trans-unit>
        <trans-unit id="f2c3eab64c1a48d622a29a27f816e042ade7152b" translate="yes" xml:space="preserve">
          <source>WIDTH_REGULAR</source>
          <target state="translated">WIDTH_REGULAR</target>
        </trans-unit>
        <trans-unit id="a4e8f9790df1d3458b9478fce8c01bedea0bf94d" translate="yes" xml:space="preserve">
          <source>WIDTH_SEMI_CONDENSED</source>
          <target state="translated">WIDTH_SEMI_CONDENSED</target>
        </trans-unit>
        <trans-unit id="be580bbe1264dcd204976ea1af8a09e331827608" translate="yes" xml:space="preserve">
          <source>WIDTH_SEMI_EXTENDED</source>
          <target state="translated">WIDTH_SEMI_EXTENDED</target>
        </trans-unit>
        <trans-unit id="dea5d6976f7c54b48ff5d6c539121232f52092ef" translate="yes" xml:space="preserve">
          <source>WILDCARD</source>
          <target state="translated">WILDCARD</target>
        </trans-unit>
        <trans-unit id="201f5bdde79034efdfb90c4b9a48c56dd51af9e1" translate="yes" xml:space="preserve">
          <source>WINDOW</source>
          <target state="translated">WINDOW</target>
        </trans-unit>
        <trans-unit id="f077619112eb62d32b3deefbfa219ced776e66b4" translate="yes" xml:space="preserve">
          <source>WINDOW_ACTIVATED</source>
          <target state="translated">WINDOW_ACTIVATED</target>
        </trans-unit>
        <trans-unit id="cf82cc2cb60949685311a0db721f99845a7aa8be" translate="yes" xml:space="preserve">
          <source>WINDOW_BORDER</source>
          <target state="translated">WINDOW_BORDER</target>
        </trans-unit>
        <trans-unit id="d91f63a1281e9a8adb85deb426f6f5ac0b85ffae" translate="yes" xml:space="preserve">
          <source>WINDOW_CLOSED</source>
          <target state="translated">WINDOW_CLOSED</target>
        </trans-unit>
        <trans-unit id="63385282825efbd7e38a94764336baa1473575fd" translate="yes" xml:space="preserve">
          <source>WINDOW_CLOSING</source>
          <target state="translated">WINDOW_CLOSING</target>
        </trans-unit>
        <trans-unit id="69d12c57282ba06641ed6a56238c9e6e2e71a88e" translate="yes" xml:space="preserve">
          <source>WINDOW_DEACTIVATED</source>
          <target state="translated">WINDOW_DEACTIVATED</target>
        </trans-unit>
        <trans-unit id="96084672dbf7b481b508cee67a8dc62823feea40" translate="yes" xml:space="preserve">
          <source>WINDOW_DEICONIFIED</source>
          <target state="translated">WINDOW_DEICONIFIED</target>
        </trans-unit>
        <trans-unit id="8d280dd9f51a6496153cbe08cf89eb5b45866051" translate="yes" xml:space="preserve">
          <source>WINDOW_DEICONIFY</source>
          <target state="translated">WINDOW_DEICONIFY</target>
        </trans-unit>
        <trans-unit id="c6e170a525954b26428bd11febd98c5707d5b35c" translate="yes" xml:space="preserve">
          <source>WINDOW_DESTROY</source>
          <target state="translated">WINDOW_DESTROY</target>
        </trans-unit>
        <trans-unit id="26844c06a46493264d9e50b6a44a5dbf7790aa4c" translate="yes" xml:space="preserve">
          <source>WINDOW_EVENT_MASK</source>
          <target state="translated">WINDOW_EVENT_MASK</target>
        </trans-unit>
        <trans-unit id="c603873fd7d2410ae3f063e7b1f8c751b72bae30" translate="yes" xml:space="preserve">
          <source>WINDOW_EXPOSE</source>
          <target state="translated">WINDOW_EXPOSE</target>
        </trans-unit>
        <trans-unit id="b174d6474916e37e5c03f46fdab39110ab0dc9e8" translate="yes" xml:space="preserve">
          <source>WINDOW_FIRST</source>
          <target state="translated">WINDOW_FIRST</target>
        </trans-unit>
        <trans-unit id="63d58af0713efc399dbcddba86153e7938cb6f31" translate="yes" xml:space="preserve">
          <source>WINDOW_FOCUS_EVENT_MASK</source>
          <target state="translated">WINDOW_FOCUS_EVENT_MASK</target>
        </trans-unit>
        <trans-unit id="d5f6fc44425ee2cb8e593bb84ccba8092b55a656" translate="yes" xml:space="preserve">
          <source>WINDOW_GAINED_FOCUS</source>
          <target state="translated">WINDOW_GAINED_FOCUS</target>
        </trans-unit>
        <trans-unit id="2a14a988f60d78faffe74016ab77cd19c874149a" translate="yes" xml:space="preserve">
          <source>WINDOW_ICONIFIED</source>
          <target state="translated">WINDOW_ICONIFIED</target>
        </trans-unit>
        <trans-unit id="54801db930103fa29a38d9f58db25e2cb8790ee1" translate="yes" xml:space="preserve">
          <source>WINDOW_ICONIFY</source>
          <target state="translated">WINDOW_ICONIFY</target>
        </trans-unit>
        <trans-unit id="2378e3d6b4829d442b4cc32442bdd1abf7eb3ac5" translate="yes" xml:space="preserve">
          <source>WINDOW_LAST</source>
          <target state="translated">WINDOW_LAST</target>
        </trans-unit>
        <trans-unit id="8f9a2f2d8f9fbb333bf22c699806d80ac43a06f7" translate="yes" xml:space="preserve">
          <source>WINDOW_LOST_FOCUS</source>
          <target state="translated">WINDOW_LOST_FOCUS</target>
        </trans-unit>
        <trans-unit id="a4655542aa8139f051b41a75ad681a1cc37da769" translate="yes" xml:space="preserve">
          <source>WINDOW_MOVED</source>
          <target state="translated">WINDOW_MOVED</target>
        </trans-unit>
        <trans-unit id="7d76c10e796d735702955620ab032e7b02e9ceb4" translate="yes" xml:space="preserve">
          <source>WINDOW_OPENED</source>
          <target state="translated">WINDOW_OPENED</target>
        </trans-unit>
        <trans-unit id="2255c9b01e590c2353fd989dcecfac12b990acfc" translate="yes" xml:space="preserve">
          <source>WINDOW_STATE_CHANGED</source>
          <target state="translated">WINDOW_STATE_CHANGED</target>
        </trans-unit>
        <trans-unit id="420bc96d5325cc4d73ae412b3a7eb9f216cfe027" translate="yes" xml:space="preserve">
          <source>WINDOW_STATE_EVENT_MASK</source>
          <target state="translated">WINDOW_STATE_EVENT_MASK</target>
        </trans-unit>
        <trans-unit id="156fa2ca70f9b3dbe2d061d8db6d1edb65777ee7" translate="yes" xml:space="preserve">
          <source>WINDOW_TEXT</source>
          <target state="translated">WINDOW_TEXT</target>
        </trans-unit>
        <trans-unit id="a536c532d01270c47a406ecad5fa16bbab75c7c5" translate="yes" xml:space="preserve">
          <source>WIND_EVEN_ODD</source>
          <target state="translated">WIND_EVEN_ODD</target>
        </trans-unit>
        <trans-unit id="5ca89cf4db105d3c703479b2e1e146d1244880c4" translate="yes" xml:space="preserve">
          <source>WIND_NON_ZERO</source>
          <target state="translated">WIND_NON_ZERO</target>
        </trans-unit>
        <trans-unit id="986b96d045e3b44c351b49c804df41703506da7c" translate="yes" xml:space="preserve">
          <source>WORD</source>
          <target state="translated">WORD</target>
        </trans-unit>
        <trans-unit id="6f18d3fc7f5f427a863731418e6bdb023b8e5b1f" translate="yes" xml:space="preserve">
          <source>WORD_SPACING</source>
          <target state="translated">WORD_SPACING</target>
        </trans-unit>
        <trans-unit id="f95d2ffbf9a1af1952ded5edbd37273e4bf5f711" translate="yes" xml:space="preserve">
          <source>WRAP_MODE</source>
          <target state="translated">WRAP_MODE</target>
        </trans-unit>
        <trans-unit id="e14777e687655bdd473dd90685b65388d2a008e7" translate="yes" xml:space="preserve">
          <source>WRAP_TAB_LAYOUT</source>
          <target state="translated">WRAP_TAB_LAYOUT</target>
        </trans-unit>
        <trans-unit id="27ad330619a7bfbee351115b167c5a6593f2530a" translate="yes" xml:space="preserve">
          <source>WRITE</source>
          <target state="translated">WRITE</target>
        </trans-unit>
        <trans-unit id="a6921d5e91e0590725089252fc7f27605e5b7022" translate="yes" xml:space="preserve">
          <source>WRITE_ACL</source>
          <target state="translated">WRITE_ACL</target>
        </trans-unit>
        <trans-unit id="f67e53af7185fbc8aea70c663d29dcf390c68218" translate="yes" xml:space="preserve">
          <source>WRITE_ATTRIBUTES</source>
          <target state="translated">WRITE_ATTRIBUTES</target>
        </trans-unit>
        <trans-unit id="047c274a3e7ebe073cff46c23124077218032cf0" translate="yes" xml:space="preserve">
          <source>WRITE_DATA</source>
          <target state="translated">WRITE_DATA</target>
        </trans-unit>
        <trans-unit id="58182c24cbe7fbdb0cdce51d37ac21f2e39d8164" translate="yes" xml:space="preserve">
          <source>WRITE_FAILURE</source>
          <target state="translated">WRITE_FAILURE</target>
        </trans-unit>
        <trans-unit id="5b7c3f4d5466238aba0f49b3928981ccc31b3ba3" translate="yes" xml:space="preserve">
          <source>WRITE_FAILURE is used when a write to an output stream fails.</source>
          <target state="translated">WRITE_FAILURE在对输出流的写入失败时使用。</target>
        </trans-unit>
        <trans-unit id="f2e00a21918992721472933614c38b3251857c93" translate="yes" xml:space="preserve">
          <source>WRITE_NAMED_ATTRS</source>
          <target state="translated">WRITE_NAMED_ATTRS</target>
        </trans-unit>
        <trans-unit id="22dbe35075cb33b41f60ad27f0c1e14653f5f4a3" translate="yes" xml:space="preserve">
          <source>WRITE_OWNER</source>
          <target state="translated">WRITE_OWNER</target>
        </trans-unit>
        <trans-unit id="e1bed94533b16e30bc87abcfefb2ed8856136c0a" translate="yes" xml:space="preserve">
          <source>WRONG_DOCUMENT_ERR</source>
          <target state="translated">WRONG_DOCUMENT_ERR</target>
        </trans-unit>
        <trans-unit id="f2ea9a9e20bc3d2ca808ee1674c9ca3777e6f2e3" translate="yes" xml:space="preserve">
          <source>WRONG_DOCUMENT_ERR: Raised if &lt;code&gt; newParent&lt;/code&gt; and the container of the start of the Range were not created from the same document.</source>
          <target state="translated">WRONG_DOCUMENT_ERR：如果 &lt;code&gt; newParent&lt;/code&gt; 和Range的起始容器不是从同一文档创建的，则引发该错误。</target>
        </trans-unit>
        <trans-unit id="71114af5da073a2e19c698dad03cd04381269b0e" translate="yes" xml:space="preserve">
          <source>WRONG_DOCUMENT_ERR: Raised if &lt;code&gt;doctype&lt;/code&gt; has already been used with a different document or was created from a different implementation.</source>
          <target state="translated">WRONG_DOCUMENT_ERR：如果 &lt;code&gt;doctype&lt;/code&gt; 已经用于其他文档或是从其他实现创建的，则引发。</target>
        </trans-unit>
        <trans-unit id="1d0ed205c69625a68cee870a7e40a70660d93314" translate="yes" xml:space="preserve">
          <source>WRONG_DOCUMENT_ERR: Raised if &lt;code&gt;newChild&lt;/code&gt; was created from a different document than the one that created this node.</source>
          <target state="translated">WRONG_DOCUMENT_ERR：如果 &lt;code&gt;newChild&lt;/code&gt; 是从与创建此节点的文档不同的文档创建的，则引发。</target>
        </trans-unit>
        <trans-unit id="3bd5a04c3e9380d1295c16e4d5fccbdcbc5dcf06" translate="yes" xml:space="preserve">
          <source>WRONG_DOCUMENT_ERR: Raised if &lt;code&gt;newNode&lt;/code&gt; and the container of the start of the Range were not created from the same document.</source>
          <target state="translated">WRONG_DOCUMENT_ERR：如果不是从同一文档创建 &lt;code&gt;newNode&lt;/code&gt; 和Range起点的容器，则引发。</target>
        </trans-unit>
        <trans-unit id="91fa1b68b2f952cba42828282d05c9724b500233" translate="yes" xml:space="preserve">
          <source>WRONG_DOCUMENT_ERR: Raised if &lt;code&gt;refNode&lt;/code&gt; was created from a different document than the one that created this range.</source>
          <target state="translated">WRONG_DOCUMENT_ERR：如果 &lt;code&gt;refNode&lt;/code&gt; 是从与创建该范围的文档不同的文档创建的，则引发。</target>
        </trans-unit>
        <trans-unit id="118d32bd5e53265934b0ac212e3c57bcd37a50a4" translate="yes" xml:space="preserve">
          <source>WRONG_DOCUMENT_ERR: Raised when the specified node was created from a different document than this document.</source>
          <target state="translated">WRONG_DOCUMENT_ERR:当指定的节点是由与本文档不同的文档创建时发生的。</target>
        </trans-unit>
        <trans-unit id="341617fc086d770d8ea4a594809231354f641b3e" translate="yes" xml:space="preserve">
          <source>WRONG_DOCUMENT_ERR: The Node is from a document that is not supported by this &lt;code&gt;XPathEvaluator&lt;/code&gt;.</source>
          <target state="translated">WRONG_DOCUMENT_ERR：节点来自此 &lt;code&gt;XPathEvaluator&lt;/code&gt; 不支持的文档。</target>
        </trans-unit>
        <trans-unit id="1be484a6783ddfe8f1ad29b1a3c0962002cadce7" translate="yes" xml:space="preserve">
          <source>W_RESIZE_CURSOR</source>
          <target state="translated">W_RESIZE_CURSOR</target>
        </trans-unit>
        <trans-unit id="598d8d2b12d9df9850b46eed40d26b4f7da3a541" translate="yes" xml:space="preserve">
          <source>Waiting threads are signalled in FIFO order.</source>
          <target state="translated">等待的线程按FIFO顺序发出信号。</target>
        </trans-unit>
        <trans-unit id="b74db5e9d2999d7bc071ef89872c133de19100b8" translate="yes" xml:space="preserve">
          <source>Waits (indefinitely or with timeout) to accept a connection from a target VM. Returns a connection representing the bi-directional communication channel to the target VM.</source>
          <target state="translated">等待(无限期或超时)接受来自目标虚拟机的连接。返回一个代表到目标虚拟机的双向通信通道的连接。</target>
        </trans-unit>
        <trans-unit id="199bd64233624c112a29d3830698c441ba8d4ee5" translate="yes" xml:space="preserve">
          <source>Waits a specified time for the next available event.</source>
          <target state="translated">等待下一个可用事件的指定时间。</target>
        </trans-unit>
        <trans-unit id="0dfac63144eb4e13fa4046effe1389039a7f73a0" translate="yes" xml:space="preserve">
          <source>Waits at most &lt;code&gt;millis&lt;/code&gt; milliseconds for this thread to die.</source>
          <target state="translated">最多等待 &lt;code&gt;millis&lt;/code&gt; 毫秒该线程终止。</target>
        </trans-unit>
        <trans-unit id="8d5ab81f6e9b8670844cee69bbeaf4be8c160cc0" translate="yes" xml:space="preserve">
          <source>Waits at most &lt;code&gt;millis&lt;/code&gt; milliseconds for this thread to die. A timeout of &lt;code&gt;0&lt;/code&gt; means to wait forever.</source>
          <target state="translated">最多等待 &lt;code&gt;millis&lt;/code&gt; 毫秒该线程终止。超时为 &lt;code&gt;0&lt;/code&gt; 表示永远等待。</target>
        </trans-unit>
        <trans-unit id="94a53993e8d3246a8674fea623793cc23fc795e9" translate="yes" xml:space="preserve">
          <source>Waits at most &lt;code&gt;millis&lt;/code&gt; milliseconds plus &lt;code&gt;nanos&lt;/code&gt; nanoseconds for this thread to die.</source>
          <target state="translated">最多等待 &lt;code&gt;millis&lt;/code&gt; 毫秒加上 &lt;code&gt;nanos&lt;/code&gt; 纳秒该线程死亡。</target>
        </trans-unit>
        <trans-unit id="364ac8a7340fa105aa8fcf68230fb933e4e39f0e" translate="yes" xml:space="preserve">
          <source>Waits at most &lt;code&gt;millis&lt;/code&gt; milliseconds plus &lt;code&gt;nanos&lt;/code&gt; nanoseconds for this thread to die. If both arguments are &lt;code&gt;0&lt;/code&gt;, it means to wait forever.</source>
          <target state="translated">最多等待 &lt;code&gt;millis&lt;/code&gt; 毫秒加上 &lt;code&gt;nanos&lt;/code&gt; 纳秒该线程死亡。如果两个参数均为 &lt;code&gt;0&lt;/code&gt; ，则意味着永远等待。</target>
        </trans-unit>
        <trans-unit id="b816db010f0b20f18e251c023169a10b494d51ba" translate="yes" xml:space="preserve">
          <source>Waits for a target VM to attach to this connector.</source>
          <target state="translated">等待目标虚拟机附加到这个连接器。</target>
        </trans-unit>
        <trans-unit id="6945ea299c349bf854bb71b57598d2ff62ecb7ad" translate="yes" xml:space="preserve">
          <source>Waits for another thread to arrive at this exchange point (unless the current thread is &lt;a href=&quot;../../lang/thread#interrupt()&quot;&gt;interrupted&lt;/a&gt; or the specified waiting time elapses), and then transfers the given object to it, receiving its object in return.</source>
          <target state="translated">等待另一个线程到达此交换点（除非当前线程被&lt;a href=&quot;../../lang/thread#interrupt()&quot;&gt;中断&lt;/a&gt;或经过了指定的等待时间），然后将给定对象传送给该对象，并返回其对象。</target>
        </trans-unit>
        <trans-unit id="a37b156af078a12dd88e1ceced75eef8714f1045" translate="yes" xml:space="preserve">
          <source>Waits for another thread to arrive at this exchange point (unless the current thread is &lt;a href=&quot;../../lang/thread#interrupt()&quot;&gt;interrupted&lt;/a&gt;), and then transfers the given object to it, receiving its object in return.</source>
          <target state="translated">等待另一个线程到达此交换点（除非当前线程被&lt;a href=&quot;../../lang/thread#interrupt()&quot;&gt;中断&lt;/a&gt;），然后将给定对象传输到该交换点，以接收其返回的对象。</target>
        </trans-unit>
        <trans-unit id="557c8f0f0804d3490aa53aee125e92a7445e1d48" translate="yes" xml:space="preserve">
          <source>Waits for another thread to arrive at this exchange point (unless the current thread is &lt;a href=&quot;../../lang/thread#interrupt--&quot;&gt;interrupted&lt;/a&gt; or the specified waiting time elapses), and then transfers the given object to it, receiving its object in return.</source>
          <target state="translated">等待另一个线程到达此交换点（除非当前线程被&lt;a href=&quot;../../lang/thread#interrupt--&quot;&gt;中断&lt;/a&gt;或经过了指定的等待时间），然后将给定对象传送给该对象，并返回其对象。</target>
        </trans-unit>
        <trans-unit id="a9714c3b990f72a16c64a297b3674cb6087cfeff" translate="yes" xml:space="preserve">
          <source>Waits for another thread to arrive at this exchange point (unless the current thread is &lt;a href=&quot;../../lang/thread#interrupt--&quot;&gt;interrupted&lt;/a&gt;), and then transfers the given object to it, receiving its object in return.</source>
          <target state="translated">等待另一个线程到达此交换点（除非当前线程被&lt;a href=&quot;../../lang/thread#interrupt--&quot;&gt;中断&lt;/a&gt;），然后将给定对象传输到该交换点，以接收其返回的对象。</target>
        </trans-unit>
        <trans-unit id="0dd1336c41594fd2e84fa160e878cce8748c4f56" translate="yes" xml:space="preserve">
          <source>Waits for card insertion or removal in any of the terminals of this object or until the timeout expires.</source>
          <target state="translated">等待在此对象的任何一个终端中插入或取出卡片,或直到超时结束。</target>
        </trans-unit>
        <trans-unit id="89745f25fc05bdd917e4f78d91659324affba37d" translate="yes" xml:space="preserve">
          <source>Waits for card insertion or removal in any of the terminals of this object.</source>
          <target state="translated">等待在此对象的任何一个终端中插入或取出卡片。</target>
        </trans-unit>
        <trans-unit id="77b3edd5fff3c71fb470f4dbfb6b9381ad255a30" translate="yes" xml:space="preserve">
          <source>Waits for this thread to die.</source>
          <target state="translated">等着这条线死掉。</target>
        </trans-unit>
        <trans-unit id="a6355004e98a1e303c517b5c0d2eea1c774e0c44" translate="yes" xml:space="preserve">
          <source>Waits forever for the next available event.</source>
          <target state="translated">永远等待下一个可用的活动。</target>
        </trans-unit>
        <trans-unit id="77a93294440eb49b7b2449dd795ae4ada0e190db" translate="yes" xml:space="preserve">
          <source>Waits if necessary for at most the given time for the computation to complete, and then retrieves its result, if available.</source>
          <target state="translated">必要时最多等待给定的时间完成计算,然后检索结果(如果有)。</target>
        </trans-unit>
        <trans-unit id="aafcd08752bc11a21870ec04b685933837e7d4cc" translate="yes" xml:space="preserve">
          <source>Waits if necessary for at most the given time for this future to complete, and then returns its result, if available.</source>
          <target state="translated">如果需要的话,最多等待给定的时间来完成这个未来,然后返回其结果(如果有的话)。</target>
        </trans-unit>
        <trans-unit id="da89866ec43b4f683e34b593be2844266c48a6dd" translate="yes" xml:space="preserve">
          <source>Waits if necessary for the computation to complete, and then retrieves its result.</source>
          <target state="translated">必要时等待计算完成,然后检索结果。</target>
        </trans-unit>
        <trans-unit id="803562ef43c8df90a6078b38fd0fbbbab986c81e" translate="yes" xml:space="preserve">
          <source>Waits if necessary for this future to complete, and then returns its result.</source>
          <target state="translated">如果需要的话,等待这个未来完成,然后返回其结果。</target>
        </trans-unit>
        <trans-unit id="423c0dce2f862ecc873615cade8b7995c39489c0" translate="yes" xml:space="preserve">
          <source>Waits until a card is absent in this terminal or the timeout expires.</source>
          <target state="translated">等到本终端缺卡或超时结束。</target>
        </trans-unit>
        <trans-unit id="1512b97cf54ca00cc89ed1c2a603b3152e72ec33" translate="yes" xml:space="preserve">
          <source>Waits until a card is absent in this terminal or the timeout expires. If the method returns due to an expired timeout, it returns false. Otherwise it return true.</source>
          <target state="translated">等到本终端中没有卡或超时失效。如果该方法因超时而返回,则返回false。否则返回true。</target>
        </trans-unit>
        <trans-unit id="da37e1e647ffb796a905e861477a96985985fab0" translate="yes" xml:space="preserve">
          <source>Waits until a card is present in this terminal or the timeout expires.</source>
          <target state="translated">等到本终端有卡存在或超时结束。</target>
        </trans-unit>
        <trans-unit id="264bc5d8b7b4158554047c2ebbbff929780a898b" translate="yes" xml:space="preserve">
          <source>Waits until a card is present in this terminal or the timeout expires. If the method returns due to an expired timeout, it returns false. Otherwise it return true.</source>
          <target state="translated">等待直到本终端有卡存在或超时结束。如果该方法因超时而返回,则返回false。否则返回true。</target>
        </trans-unit>
        <trans-unit id="db3a5831555426908400f4f11350ee1d9621e94c" translate="yes" xml:space="preserve">
          <source>Waits until all &lt;a href=&quot;#getParties()&quot;&gt;parties&lt;/a&gt; have invoked &lt;code&gt;await&lt;/code&gt; on this barrier, or the specified waiting time elapses.</source>
          <target state="translated">等待所有&lt;a href=&quot;#getParties()&quot;&gt;各方&lt;/a&gt;都调用 &lt;code&gt;await&lt;/code&gt; 在此barrier，或者指定的等待时间。</target>
        </trans-unit>
        <trans-unit id="9d2ee91fa38b3aa39b57f6f15bee41b407e896ba" translate="yes" xml:space="preserve">
          <source>Waits until all &lt;a href=&quot;#getParties()&quot;&gt;parties&lt;/a&gt; have invoked &lt;code&gt;await&lt;/code&gt; on this barrier.</source>
          <target state="translated">等到所有&lt;a href=&quot;#getParties()&quot;&gt;各方&lt;/a&gt;都在此障碍上调用 &lt;code&gt;await&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="acfb3663e0ca38989b8759e81be1ac615f97ff84" translate="yes" xml:space="preserve">
          <source>Waits until all &lt;a href=&quot;cyclicbarrier#getParties--&quot;&gt;parties&lt;/a&gt; have invoked &lt;code&gt;await&lt;/code&gt; on this barrier, or the specified waiting time elapses.</source>
          <target state="translated">等待所有&lt;a href=&quot;cyclicbarrier#getParties--&quot;&gt;各方&lt;/a&gt;都调用 &lt;code&gt;await&lt;/code&gt; 在此barrier，或者指定的等待时间。</target>
        </trans-unit>
        <trans-unit id="3b3ff44bfcf430c4e4b9e5670feffa1d028ea206" translate="yes" xml:space="preserve">
          <source>Waits until all &lt;a href=&quot;cyclicbarrier#getParties--&quot;&gt;parties&lt;/a&gt; have invoked &lt;code&gt;await&lt;/code&gt; on this barrier.</source>
          <target state="translated">等到所有&lt;a href=&quot;cyclicbarrier#getParties--&quot;&gt;各方&lt;/a&gt;都在此障碍上调用 &lt;code&gt;await&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="66e5902a91027833c1f24efb88602d6e5f5a340b" translate="yes" xml:space="preserve">
          <source>Waits until all events currently on the event queue have been processed.</source>
          <target state="translated">等到当前事件队列中的所有事件被处理完毕。</target>
        </trans-unit>
        <trans-unit id="195940d89a4d3d929b70126f3c4b3ed5d79a8702" translate="yes" xml:space="preserve">
          <source>Wakes up a single thread that is waiting on this object's monitor.</source>
          <target state="translated">唤醒一个在这个对象的监视器上等待的单线程。</target>
        </trans-unit>
        <trans-unit id="11472e63110fd1bbda989b4cb58d4fad230cee5d" translate="yes" xml:space="preserve">
          <source>Wakes up a single thread that is waiting on this object's monitor. If any threads are waiting on this object, one of them is chosen to be awakened. The choice is arbitrary and occurs at the discretion of the implementation. A thread waits on an object's monitor by calling one of the &lt;code&gt;wait&lt;/code&gt; methods.</source>
          <target state="translated">唤醒正在此对象的监视器上等待的单个线程。如果有任何线程在此对象上等待，则选择其中一个唤醒。选择是任意的，并且可以根据实现情况进行选择。线程通过调用其中一个 &lt;code&gt;wait&lt;/code&gt; 方法在对象的监视器上等待。</target>
        </trans-unit>
        <trans-unit id="917b6dee9d5785c9498c7fee94cb9cb413ff2ccb" translate="yes" xml:space="preserve">
          <source>Wakes up all threads that are waiting on this object's monitor.</source>
          <target state="translated">唤醒所有在这个对象的监视器上等待的线程。</target>
        </trans-unit>
        <trans-unit id="60bf1897ca2d5ea7f9fed100a197b8da56cd2f6b" translate="yes" xml:space="preserve">
          <source>Wakes up all threads that are waiting on this object's monitor. A thread waits on an object's monitor by calling one of the &lt;code&gt;wait&lt;/code&gt; methods.</source>
          <target state="translated">唤醒正在此对象的监视器上等待的所有线程。线程通过调用其中一个 &lt;code&gt;wait&lt;/code&gt; 方法在对象的监视器上等待。</target>
        </trans-unit>
        <trans-unit id="51a97180c73a6b656ee4a08e63d8a98f31c183ce" translate="yes" xml:space="preserve">
          <source>Wakes up all waiting threads.</source>
          <target state="translated">唤醒所有等待的线程。</target>
        </trans-unit>
        <trans-unit id="e2485f445b2ec82930218c1452c9df2adf2f4bf0" translate="yes" xml:space="preserve">
          <source>Wakes up one waiting thread.</source>
          <target state="translated">唤醒了一个个等待的线。</target>
        </trans-unit>
        <trans-unit id="21cc32a11b691c15416334d1e1e040558e915617" translate="yes" xml:space="preserve">
          <source>Walks a file tree.</source>
          <target state="translated">行走文件树。</target>
        </trans-unit>
        <trans-unit id="5c45ab05d45d1008d0b70706476bdc29a68fff57" translate="yes" xml:space="preserve">
          <source>Warning message.</source>
          <target state="translated">警告信息。</target>
        </trans-unit>
        <trans-unit id="e195a42e21ff3c9acfd11dbffb58c75674a8669a" translate="yes" xml:space="preserve">
          <source>Warning: To avoid deadlock, do not declare this method synchronized in a subclass.</source>
          <target state="translated">警告:为了避免死锁,不要在子类中声明这个方法是同步的。为了避免死锁,不要在子类中声明这个方法是同步的。</target>
        </trans-unit>
        <trans-unit id="d79c41e148d22dbcf85b4f38814ab88b9e8d6c0c" translate="yes" xml:space="preserve">
          <source>Warning: additional attribute type keywords may not be recognized by other implementations; therefore do not use this method if you are unsure if these keywords will be recognized by other implementations.</source>
          <target state="translated">警告:额外的属性类型关键字可能不被其他实现所识别;因此,如果您不确定这些关键字是否会被其他实现识别,请不要使用此方法。</target>
        </trans-unit>
        <trans-unit id="f594af464c78df78968d3e497d99f5a249bd81b8" translate="yes" xml:space="preserve">
          <source>Warnings may be retrieved from &lt;code&gt;Connection&lt;/code&gt;, &lt;code&gt;Statement&lt;/code&gt;, and &lt;code&gt;ResultSet&lt;/code&gt; objects. Trying to retrieve a warning on a connection after it has been closed will cause an exception to be thrown. Similarly, trying to retrieve a warning on a statement after it has been closed or on a result set after it has been closed will cause an exception to be thrown. Note that closing a statement also closes a result set that it might have produced.</source>
          <target state="translated">可以从 &lt;code&gt;Connection&lt;/code&gt; ， &lt;code&gt;Statement&lt;/code&gt; 和 &lt;code&gt;ResultSet&lt;/code&gt; 对象检索警告。在连接关闭后尝试检索警告将导致引发异常。同样，在语句关闭后或语句集关闭后尝试检索警告将导致引发异常。请注意，关闭语句还会关闭它可能产生的结果集。</target>
        </trans-unit>
        <trans-unit id="18af9205d481c81af0452c7b78307a2cc12e16a6" translate="yes" xml:space="preserve">
          <source>Watch events are immutable and safe for use by multiple concurrent threads.</source>
          <target state="translated">Watch事件是不可变的,并且可以安全地被多个并发线程使用。</target>
        </trans-unit>
        <trans-unit id="a4df0a14364157db35b0aeb27d103f08e65c5600" translate="yes" xml:space="preserve">
          <source>Watch keys are safe for use by multiple concurrent threads. Where there are several threads retrieving signalled keys from a watch service then care should be taken to ensure that the &lt;code&gt;reset&lt;/code&gt; method is only invoked after the events for the object have been processed. This ensures that one thread is processing the events for an object at any time.</source>
          <target state="translated">监视键可以安全地供多个并发线程使用。如果有多个线程从监视服务中检索信号键，则应注意确保仅在处理完对象的事件后才调用 &lt;code&gt;reset&lt;/code&gt; 方法。这样可确保一个线程随时处理一个对象的事件。</target>
        </trans-unit>
        <trans-unit id="ab89fdb591a29dd2157e80dd3fc09d166fa47e02" translate="yes" xml:space="preserve">
          <source>WatchEvent</source>
          <target state="translated">WatchEvent</target>
        </trans-unit>
        <trans-unit id="3104a16b096e2e87877444fb732ed4e244fd5fb4" translate="yes" xml:space="preserve">
          <source>WatchEvent.Kind</source>
          <target state="translated">WatchEvent.Kind</target>
        </trans-unit>
        <trans-unit id="2859a128288874ad24f4c98bf7cce397de08c723" translate="yes" xml:space="preserve">
          <source>WatchEvent.Kind.name()</source>
          <target state="translated">WatchEvent.Kind.name()</target>
        </trans-unit>
        <trans-unit id="d4ac1908a9c52fd3c2ca417375ae89c7dc6f90e4" translate="yes" xml:space="preserve">
          <source>WatchEvent.Kind.type()</source>
          <target state="translated">WatchEvent.Kind.type()</target>
        </trans-unit>
        <trans-unit id="dc0776148e4ccfbb27ab88bb6ce1339da4271d12" translate="yes" xml:space="preserve">
          <source>WatchEvent.Modifier</source>
          <target state="translated">WatchEvent.Modifier</target>
        </trans-unit>
        <trans-unit id="6151408b10f387c0c02499f23d0d49495a123adf" translate="yes" xml:space="preserve">
          <source>WatchEvent.Modifier.name()</source>
          <target state="translated">WatchEvent.Modifier.name()</target>
        </trans-unit>
        <trans-unit id="5f845280cded200c4b8a48929301464e398ac2fe" translate="yes" xml:space="preserve">
          <source>WatchEvent.context()</source>
          <target state="translated">WatchEvent.context()</target>
        </trans-unit>
        <trans-unit id="5548f15e22cdecc390d6071d79b41ad168545b10" translate="yes" xml:space="preserve">
          <source>WatchEvent.count()</source>
          <target state="translated">WatchEvent.count()</target>
        </trans-unit>
        <trans-unit id="3223fe7f2570a86db47dcd946b0550bb69148bdc" translate="yes" xml:space="preserve">
          <source>WatchEvent.kind()</source>
          <target state="translated">WatchEvent.kind()</target>
        </trans-unit>
        <trans-unit id="434feaccfe2a3f5790f514c688ddfee42a937ee8" translate="yes" xml:space="preserve">
          <source>WatchKey</source>
          <target state="translated">WatchKey</target>
        </trans-unit>
        <trans-unit id="613309ae99383a948104b176728f00b5db1221a3" translate="yes" xml:space="preserve">
          <source>WatchKey.cancel()</source>
          <target state="translated">WatchKey.cancel()</target>
        </trans-unit>
        <trans-unit id="fe242e0e137c753b42ee60cd35da60a895c553b9" translate="yes" xml:space="preserve">
          <source>WatchKey.isValid()</source>
          <target state="translated">WatchKey.isValid()</target>
        </trans-unit>
        <trans-unit id="9b1c89a2ee3b265e994b695b84f3a27bea880e84" translate="yes" xml:space="preserve">
          <source>WatchKey.pollEvents()</source>
          <target state="translated">WatchKey.pollEvents()</target>
        </trans-unit>
        <trans-unit id="ac44d1881e8bb9b33414336e6916521ad7abb29a" translate="yes" xml:space="preserve">
          <source>WatchKey.reset()</source>
          <target state="translated">WatchKey.reset()</target>
        </trans-unit>
        <trans-unit id="0ea52bb6949f4d37bbfce8963436ca586f1e8030" translate="yes" xml:space="preserve">
          <source>WatchKey.watchable()</source>
          <target state="translated">WatchKey.watchable()</target>
        </trans-unit>
        <trans-unit id="0ba6324b24ac8367d12f20a36f168e878432e873" translate="yes" xml:space="preserve">
          <source>WatchService</source>
          <target state="translated">WatchService</target>
        </trans-unit>
        <trans-unit id="366b61480307312fb6cf3ed210e7dbd19363dc32" translate="yes" xml:space="preserve">
          <source>WatchService.close()</source>
          <target state="translated">WatchService.close()</target>
        </trans-unit>
        <trans-unit id="6d641c1aa1ec04d7f4c2c802a6bd764a66c3c9c6" translate="yes" xml:space="preserve">
          <source>WatchService.poll()</source>
          <target state="translated">WatchService.poll()</target>
        </trans-unit>
        <trans-unit id="ba448bbc64fac97e5520011aa42f1172cd6b178d" translate="yes" xml:space="preserve">
          <source>WatchService.take()</source>
          <target state="translated">WatchService.take()</target>
        </trans-unit>
        <trans-unit id="7c475c44becae5d946d65a3f0efc654e48d04971" translate="yes" xml:space="preserve">
          <source>Watchable</source>
          <target state="translated">Watchable</target>
        </trans-unit>
        <trans-unit id="9d031ce99187a6db7969bfd9b309b28ef1bb8881" translate="yes" xml:space="preserve">
          <source>Watchable.register()</source>
          <target state="translated">Watchable.register()</target>
        </trans-unit>
        <trans-unit id="80afe1a592e75d65eca9d374d7b11511ca863272" translate="yes" xml:space="preserve">
          <source>WatchpointEvent</source>
          <target state="translated">WatchpointEvent</target>
        </trans-unit>
        <trans-unit id="2e07b609c1a4966b80ddf9977318b79bc793b675" translate="yes" xml:space="preserve">
          <source>WatchpointRequest</source>
          <target state="translated">WatchpointRequest</target>
        </trans-unit>
        <trans-unit id="ed9f48be68d70641d3c8097361c43176f33d0fe1" translate="yes" xml:space="preserve">
          <source>Ways to Access MXBeans</source>
          <target state="translated">访问MXBeans的方法</target>
        </trans-unit>
        <trans-unit id="c6e09e783a345f65b296bb6f46435937f099623b" translate="yes" xml:space="preserve">
          <source>We can assume in the above scenario that &lt;code&gt;CV.computeValue&lt;/code&gt; uses locks to properly observe the time-dependent states as it computes &lt;code&gt;V1&lt;/code&gt;, etc. This does not remove the threat of a stale value, since there is a window of time between the return of &lt;code&gt;computeValue&lt;/code&gt; in &lt;code&gt;T&lt;/code&gt; and the installation of the new value. No user synchronization is possible during this time.</source>
          <target state="translated">我们可以假设在上述情况下 &lt;code&gt;CV.computeValue&lt;/code&gt; 在计算 &lt;code&gt;V1&lt;/code&gt; 时使用锁来正确观察时间相关的状态，依此类推。这不会消除陈旧值的威胁，因为在返回值之间存在一段时间。 &lt;code&gt;computeValue&lt;/code&gt; 在 &lt;code&gt;T&lt;/code&gt; ，新价值的安装。在此期间，无法进行用户同步。</target>
        </trans-unit>
        <trans-unit id="b56109250239fd6335ae47d334eb34e1eb134e3e" translate="yes" xml:space="preserve">
          <source>We can assume in the above scenario that &lt;code&gt;CV.computeValue&lt;/code&gt; uses locks to properly observe the time-dependent states as it computes &lt;code&gt;V1&lt;/code&gt;, etc. This does not remove the threat of a stale value, since there is a window of time between the return of &lt;code&gt;computeValue&lt;/code&gt; in &lt;code&gt;T&lt;/code&gt; and the installation of the the new value. No user synchronization is possible during this time.</source>
          <target state="translated">我们可以假设在上述情况下 &lt;code&gt;CV.computeValue&lt;/code&gt; 在计算 &lt;code&gt;V1&lt;/code&gt; 时使用锁来正确观察时间相关的状态，依此类推。这不会消除陈旧值的威胁，因为在返回值之间存在一段时间。 &lt;code&gt;computeValue&lt;/code&gt; 在 &lt;code&gt;T&lt;/code&gt; 和新值的安装。在此期间，无法进行用户同步。</target>
        </trans-unit>
        <trans-unit id="9bd1711062d7dd1887987fad1cc09f74331b3cc9" translate="yes" xml:space="preserve">
          <source>We could transform the class file (with the ClassFileTransformer during the initial definition of the class) so that this becomes:</source>
          <target state="translated">我们可以对类文件进行转换(在类的初始定义过程中使用ClassFileTransformer),这样就变成了。</target>
        </trans-unit>
        <trans-unit id="5f1706f4d546751f5262ec58f5ada7af188fcd30" translate="yes" xml:space="preserve">
          <source>We draw the background in paintMenuItem() so override update (which fills the background of opaque components by default) to just call paint().</source>
          <target state="translated">我们在paintMenuItem()中绘制背景,所以覆盖update(默认填充不透明组件的背景),只调用paint()。</target>
        </trans-unit>
        <trans-unit id="59c0f6e503eaafc2be37d362079723229307a794" translate="yes" xml:space="preserve">
          <source>We pass &lt;code&gt;ModelChanged&lt;/code&gt; events along to the listeners with the tabbedpane (instead of the model itself) as the event source.</source>
          <target state="translated">我们使用Tabbedpane（而不是模型本身）作为事件源将 &lt;code&gt;ModelChanged&lt;/code&gt; 事件传递给侦听器。</target>
        </trans-unit>
        <trans-unit id="9081ad5208956aff9aea73dc70681b98af50b7b1" translate="yes" xml:space="preserve">
          <source>We would get the desired result, and it would even work in parallel. However, we might not be happy about the performance! Such an implementation would do a great deal of string copying, and the run time would be &lt;em&gt;O(n^2)&lt;/em&gt; in the number of characters. A more performant approach would be to accumulate the results into a &lt;a href=&quot;../../lang/stringbuilder&quot;&gt;&lt;code&gt;StringBuilder&lt;/code&gt;&lt;/a&gt;, which is a mutable container for accumulating strings. We can use the same technique to parallelize mutable reduction as we do with ordinary reduction.</source>
          <target state="translated">我们将获得理想的结果，甚至可以并行工作。但是，我们可能对性能不满意！这样的实现将进行大量的字符串复制，并且运行时间的字符数将为&lt;em&gt;O（n ^ 2）&lt;/em&gt;。一种更高效的方法是将结果累积到&lt;a href=&quot;../../lang/stringbuilder&quot;&gt; &lt;code&gt;StringBuilder&lt;/code&gt; 中&lt;/a&gt;，StringBuilder是用于累积字符串的可变容器。我们可以使用与普通归约相同的技术来并行化可变归约。</target>
        </trans-unit>
        <trans-unit id="a792d756a38347597c27360412bb8f8fa517b753" translate="yes" xml:space="preserve">
          <source>Weak bidirectional character type &quot;AN&quot; in the Unicode specification.</source>
          <target state="translated">Unicode规范中的弱双向字符类型 &quot;AN&quot;。</target>
        </trans-unit>
        <trans-unit id="24dbecca4697c39dcb12d83d3e21e053a4fbf4ac" translate="yes" xml:space="preserve">
          <source>Weak bidirectional character type &quot;BN&quot; in the Unicode specification.</source>
          <target state="translated">Unicode规范中的弱双向字符类型 &quot;BN&quot;。</target>
        </trans-unit>
        <trans-unit id="b592dbfa74287749b5b330052c7e3f462ec0a974" translate="yes" xml:space="preserve">
          <source>Weak bidirectional character type &quot;CS&quot; in the Unicode specification.</source>
          <target state="translated">Unicode规范中的弱双向字符类型 &quot;CS&quot;。</target>
        </trans-unit>
        <trans-unit id="d484194528c4965d5cfe46ac4072c437b4f7364f" translate="yes" xml:space="preserve">
          <source>Weak bidirectional character type &quot;EN&quot; in the Unicode specification.</source>
          <target state="translated">Unicode规范中的弱双向字符类型 &quot;EN&quot;。</target>
        </trans-unit>
        <trans-unit id="73f96fcc50384aeb2e177d07991c8003c66a6753" translate="yes" xml:space="preserve">
          <source>Weak bidirectional character type &quot;ES&quot; in the Unicode specification.</source>
          <target state="translated">Unicode规范中的弱双向字符类型 &quot;ES&quot;。</target>
        </trans-unit>
        <trans-unit id="818ef5444e8d72a94e14f04b5d6b122d1830655b" translate="yes" xml:space="preserve">
          <source>Weak bidirectional character type &quot;ET&quot; in the Unicode specification.</source>
          <target state="translated">Unicode规范中的弱双向字符类型 &quot;ET&quot;。</target>
        </trans-unit>
        <trans-unit id="c99874e66a6faaa3e643ce526bd272b2b92a2b54" translate="yes" xml:space="preserve">
          <source>Weak bidirectional character type &quot;FSI&quot; in the Unicode specification.</source>
          <target state="translated">Unicode规范中的弱双向字符类型 &quot;FSI&quot;。</target>
        </trans-unit>
        <trans-unit id="099fc15c3cb6ba98715a4b72dd526f5d81f830d5" translate="yes" xml:space="preserve">
          <source>Weak bidirectional character type &quot;LRI&quot; in the Unicode specification.</source>
          <target state="translated">Unicode规范中的弱双向字符类型 &quot;LRI&quot;。</target>
        </trans-unit>
        <trans-unit id="34c6763955af9013896491090181dbcd5a8dd74c" translate="yes" xml:space="preserve">
          <source>Weak bidirectional character type &quot;NSM&quot; in the Unicode specification.</source>
          <target state="translated">Unicode规范中的弱双向字符类型 &quot;NSM&quot;。</target>
        </trans-unit>
        <trans-unit id="956c2a4c465d4b08d54fa1ddb34419c1810351ef" translate="yes" xml:space="preserve">
          <source>Weak bidirectional character type &quot;PDF&quot; in the Unicode specification.</source>
          <target state="translated">Unicode规范中的弱双向字符类型 &quot;PDF&quot;。</target>
        </trans-unit>
        <trans-unit id="c69b4ec1842ff9f768a4e6dbdf7fddb256b1a65b" translate="yes" xml:space="preserve">
          <source>Weak bidirectional character type &quot;PDI&quot; in the Unicode specification.</source>
          <target state="translated">Unicode规范中的弱双向字符类型 &quot;PDI&quot;。</target>
        </trans-unit>
        <trans-unit id="df1f73aee439e20dfa86c7ecbef320f0ab18cfd1" translate="yes" xml:space="preserve">
          <source>Weak bidirectional character type &quot;RLI&quot; in the Unicode specification.</source>
          <target state="translated">Unicode规范中的弱双向字符类型 &quot;RLI&quot;。</target>
        </trans-unit>
        <trans-unit id="ea5a187b5f618fd1690650ad7c0db149755eff4a" translate="yes" xml:space="preserve">
          <source>Weak reference objects, which do not prevent their referents from being made finalizable, finalized, and then reclaimed.</source>
          <target state="translated">弱引用对象,并不妨碍其引用对象的可最终化、最终化,然后再回收。</target>
        </trans-unit>
        <trans-unit id="48563266c944d99d9eaba5e60d33852a238c2d45" translate="yes" xml:space="preserve">
          <source>Weak reference objects, which do not prevent their referents from being made finalizable, finalized, and then reclaimed. Weak references are most often used to implement canonicalizing mappings.</source>
          <target state="translated">弱引用对象,并不妨碍其引用对象的可最终化、最终化,然后再回收。弱引用最常用来实现规范化映射。</target>
        </trans-unit>
        <trans-unit id="03229c3ce0e1d4a5dea21e64ed5a7a21dd50346b" translate="yes" xml:space="preserve">
          <source>WeakHashMap</source>
          <target state="translated">WeakHashMap</target>
        </trans-unit>
        <trans-unit id="9f578a1ece44744875548c14accd3ab118f52f96" translate="yes" xml:space="preserve">
          <source>WeakHashMap.clear()</source>
          <target state="translated">WeakHashMap.clear()</target>
        </trans-unit>
        <trans-unit id="cac8951d07963c9661fb7627c7267795d5e7a4f2" translate="yes" xml:space="preserve">
          <source>WeakHashMap.containsKey()</source>
          <target state="translated">WeakHashMap.containsKey()</target>
        </trans-unit>
        <trans-unit id="356e80282ac519184e65c488908383906447f348" translate="yes" xml:space="preserve">
          <source>WeakHashMap.containsValue()</source>
          <target state="translated">WeakHashMap.containsValue()</target>
        </trans-unit>
        <trans-unit id="60be0515876f006e6ca1cd3d7d552af9ccd01ffe" translate="yes" xml:space="preserve">
          <source>WeakHashMap.entrySet()</source>
          <target state="translated">WeakHashMap.entrySet()</target>
        </trans-unit>
        <trans-unit id="e49f5cd6e00c4432b7ebd63f64c70d97e2bfbb24" translate="yes" xml:space="preserve">
          <source>WeakHashMap.forEach()</source>
          <target state="translated">WeakHashMap.forEach()</target>
        </trans-unit>
        <trans-unit id="19b9a321a4f1bd958cc8610a953bd1ee99035128" translate="yes" xml:space="preserve">
          <source>WeakHashMap.get()</source>
          <target state="translated">WeakHashMap.get()</target>
        </trans-unit>
        <trans-unit id="a5a9ba4e04afb8fcdfc19b61079a8ebd40110696" translate="yes" xml:space="preserve">
          <source>WeakHashMap.isEmpty()</source>
          <target state="translated">WeakHashMap.isEmpty()</target>
        </trans-unit>
        <trans-unit id="7bd691f3c04552e56d59d519f1a4666a626cae68" translate="yes" xml:space="preserve">
          <source>WeakHashMap.keySet()</source>
          <target state="translated">WeakHashMap.keySet()</target>
        </trans-unit>
        <trans-unit id="3e34f391baf109443d3eca81db8e406c21247e08" translate="yes" xml:space="preserve">
          <source>WeakHashMap.put()</source>
          <target state="translated">WeakHashMap.put()</target>
        </trans-unit>
        <trans-unit id="b834ab3cef7770bc9b59513aef17274348ef63ed" translate="yes" xml:space="preserve">
          <source>WeakHashMap.putAll()</source>
          <target state="translated">WeakHashMap.putAll()</target>
        </trans-unit>
        <trans-unit id="51c4de9f87dd1095d9471573ff074fdefaf0db3e" translate="yes" xml:space="preserve">
          <source>WeakHashMap.remove()</source>
          <target state="translated">WeakHashMap.remove()</target>
        </trans-unit>
        <trans-unit id="77d99b79dc28fd6bd9db3b97d88184d2de438fd0" translate="yes" xml:space="preserve">
          <source>WeakHashMap.replaceAll()</source>
          <target state="translated">WeakHashMap.replaceAll()</target>
        </trans-unit>
        <trans-unit id="42ea52208a3ce498ea844af7690268dde31e784f" translate="yes" xml:space="preserve">
          <source>WeakHashMap.size()</source>
          <target state="translated">WeakHashMap.size()</target>
        </trans-unit>
        <trans-unit id="8bc55d91cb214228db71f61c09b537092b4bec12" translate="yes" xml:space="preserve">
          <source>WeakHashMap.values()</source>
          <target state="translated">WeakHashMap.values()</target>
        </trans-unit>
        <trans-unit id="5ea903ebda4f9f28f642d78e916dc09051395c95" translate="yes" xml:space="preserve">
          <source>WeakReference</source>
          <target state="translated">WeakReference</target>
        </trans-unit>
        <trans-unit id="bf85b22fdda959fc428f30bfb2a0f068edc191bf" translate="yes" xml:space="preserve">
          <source>WebRowSet</source>
          <target state="translated">WebRowSet</target>
        </trans-unit>
        <trans-unit id="fd2fe2179b44fad347e37ec201d26ab520f15318" translate="yes" xml:space="preserve">
          <source>WebSocket</source>
          <target state="translated">WebSocket</target>
        </trans-unit>
        <trans-unit id="8d50debedf657789eb83e5bb579d738443688767" translate="yes" xml:space="preserve">
          <source>WebSocket has an input and an output side. These sides are independent from each other. A side can either be open or closed. Once closed, the side remains closed. WebSocket messages are sent through a &lt;code&gt;WebSocket&lt;/code&gt; and received through a &lt;code&gt;WebSocket.Listener&lt;/code&gt; associated with it. Messages can be sent until the WebSocket's output is closed, and received until the WebSocket's input is closed.</source>
          <target state="translated">WebSocket具有输入和输出端。这些方面彼此独立。侧面可以是打开的也可以是闭合的。一旦关闭，该侧保持关闭。WebSocket的消息通过发送 &lt;code&gt;WebSocket&lt;/code&gt; 通过和接收 &lt;code&gt;WebSocket.Listener&lt;/code&gt; 与它相关联。在关闭WebSocket的输出之前，可以发送消息，而在关闭WebSocket的输入之前，可以接收消息。</target>
        </trans-unit>
        <trans-unit id="9e7c0e37606b1f794c1372d83eddadb351ac3d9c" translate="yes" xml:space="preserve">
          <source>WebSocket.Builder</source>
          <target state="translated">WebSocket.Builder</target>
        </trans-unit>
        <trans-unit id="0de0866691e65f5871dab18f5e7b17347cdabb10" translate="yes" xml:space="preserve">
          <source>WebSocket.Listener</source>
          <target state="translated">WebSocket.Listener</target>
        </trans-unit>
        <trans-unit id="e5ae2288a1ae365d9dae39add24416582095231c" translate="yes" xml:space="preserve">
          <source>WebSocketHandshakeException</source>
          <target state="translated">WebSocketHandshakeException</target>
        </trans-unit>
        <trans-unit id="5656b9b79b0316fc611a9c30d2ffac25228b8371" translate="yes" xml:space="preserve">
          <source>Wednesday</source>
          <target state="translated">Wednesday</target>
        </trans-unit>
        <trans-unit id="10b774684253b67ed6046c62d38b42b91e852330" translate="yes" xml:space="preserve">
          <source>Week 0 of January 2009</source>
          <target state="translated">2009年1月第0周</target>
        </trans-unit>
        <trans-unit id="7b27856c3025a48dfd145f75086cda19de2ee70e" translate="yes" xml:space="preserve">
          <source>Week 1 of 2009</source>
          <target state="translated">2009年第一周</target>
        </trans-unit>
        <trans-unit id="e0b134e5cd0d67c325ab9181f61674f7eb847f4f" translate="yes" xml:space="preserve">
          <source>Week 1 of January 2009</source>
          <target state="translated">2009年1月第一周</target>
        </trans-unit>
        <trans-unit id="0273a235d369407f5bc0d09e86dc0804188d2c3d" translate="yes" xml:space="preserve">
          <source>Week 1 of week-based-year 2009</source>
          <target state="translated">2009年以周为单位的第一周</target>
        </trans-unit>
        <trans-unit id="61c045f9f24b3b90a55c9f64fb89b4cf33f3dbdd" translate="yes" xml:space="preserve">
          <source>Week 2 of 2009</source>
          <target state="translated">2009年第二周</target>
        </trans-unit>
        <trans-unit id="16159932e1ca3544ef8dd1d77e4cd53b696ac5c6" translate="yes" xml:space="preserve">
          <source>Week 2 of January 2009</source>
          <target state="translated">2009年1月第二周</target>
        </trans-unit>
        <trans-unit id="651b78362b5aaa1728d942efc5ee0ee574ce4c00" translate="yes" xml:space="preserve">
          <source>Week 2 of week-based-year 2009</source>
          <target state="translated">2009年以周为单位的第二周</target>
        </trans-unit>
        <trans-unit id="fc5ccf6381813c151159e75357417f783c0aec41" translate="yes" xml:space="preserve">
          <source>Week 5 of December 2008</source>
          <target state="translated">2008年12月第5周</target>
        </trans-unit>
        <trans-unit id="a6c2f210f4569dac04f3823e9662a42bc6ce2da1" translate="yes" xml:space="preserve">
          <source>Week 52 of week-based-year 2008</source>
          <target state="translated">2008年以星期为单位的第52周</target>
        </trans-unit>
        <trans-unit id="de9cd5103d931eb33add540394a1f571fcdcca10" translate="yes" xml:space="preserve">
          <source>Week 53 of 2008</source>
          <target state="translated">2008年第53周</target>
        </trans-unit>
        <trans-unit id="6c46029aa17fb600a21cad6bd08e77301e063307" translate="yes" xml:space="preserve">
          <source>Week Based Year</source>
          <target state="translated">以周为单位的年份</target>
        </trans-unit>
        <trans-unit id="0fcbe34401d64884bb36657832164bedeaa60659" translate="yes" xml:space="preserve">
          <source>Week Of Month</source>
          <target state="translated">月份星期</target>
        </trans-unit>
        <trans-unit id="f295af822500a48f0431b7b363da9a13a414b828" translate="yes" xml:space="preserve">
          <source>Week Of Year and Week Year</source>
          <target state="translated">周年和周年</target>
        </trans-unit>
        <trans-unit id="cf20b17dedbd2fa061bb084e6e427c23883b04dc" translate="yes" xml:space="preserve">
          <source>Week based years</source>
          <target state="translated">以周为单位的年份</target>
        </trans-unit>
        <trans-unit id="89443bf2616153b1df032a1eb1df761e955b11a3" translate="yes" xml:space="preserve">
          <source>Week in month</source>
          <target state="translated">月内周数</target>
        </trans-unit>
        <trans-unit id="cadc38e9abe6dd9dd6fcc84c98869fbd77cea946" translate="yes" xml:space="preserve">
          <source>Week in year</source>
          <target state="translated">年内一周</target>
        </trans-unit>
        <trans-unit id="66de1cb2f3c93d7fd3d3a0a272c173e1b5c911b9" translate="yes" xml:space="preserve">
          <source>Week of Month</source>
          <target state="translated">月份星期</target>
        </trans-unit>
        <trans-unit id="d6c62cdc6501a8ecf111466d9a326e871d8b8b6e" translate="yes" xml:space="preserve">
          <source>Week of Year</source>
          <target state="translated">年的一周</target>
        </trans-unit>
        <trans-unit id="c19474894e0551ed2105ef8e4012a429b6bad40c" translate="yes" xml:space="preserve">
          <source>Week one (1) is the week starting on the &lt;a href=&quot;#getFirstDayOfWeek()&quot;&gt;&lt;code&gt;getFirstDayOfWeek()&lt;/code&gt;&lt;/a&gt; where there are at least &lt;a href=&quot;#getMinimalDaysInFirstWeek()&quot;&gt;&lt;code&gt;getMinimalDaysInFirstWeek()&lt;/code&gt;&lt;/a&gt; days in the month. Thus, week one may start up to &lt;code&gt;minDays&lt;/code&gt; days before the start of the month. If the first week starts after the start of the month then the period before is week zero (0).</source>
          <target state="translated">第一周（1）是从&lt;a href=&quot;#getFirstDayOfWeek()&quot;&gt; &lt;code&gt;getFirstDayOfWeek()&lt;/code&gt; &lt;/a&gt;开始的一周，该月中至少有&lt;a href=&quot;#getMinimalDaysInFirstWeek()&quot;&gt; &lt;code&gt;getMinimalDaysInFirstWeek()&lt;/code&gt; &lt;/a&gt;天。因此，第一周的开始时间可能是 &lt;code&gt;minDays&lt;/code&gt; 之前的minDays天。如果第一周从月份开始之后开始，则之前的时间段为零周（0）。</target>
        </trans-unit>
        <trans-unit id="74d6db712bf03a49e67556ff1aec1f683642d8c2" translate="yes" xml:space="preserve">
          <source>Week one (1) is the week starting on the &lt;a href=&quot;weekfields#getFirstDayOfWeek--&quot;&gt;&lt;code&gt;getFirstDayOfWeek()&lt;/code&gt;&lt;/a&gt; where there are at least &lt;a href=&quot;weekfields#getMinimalDaysInFirstWeek--&quot;&gt;&lt;code&gt;getMinimalDaysInFirstWeek()&lt;/code&gt;&lt;/a&gt; days in the month. Thus, week one may start up to &lt;code&gt;minDays&lt;/code&gt; days before the start of the month. If the first week starts after the start of the month then the period before is week zero (0).</source>
          <target state="translated">第一周（1）是从&lt;a href=&quot;weekfields#getFirstDayOfWeek--&quot;&gt; &lt;code&gt;getFirstDayOfWeek()&lt;/code&gt; &lt;/a&gt;开始的一周，该月中至少有&lt;a href=&quot;weekfields#getMinimalDaysInFirstWeek--&quot;&gt; &lt;code&gt;getMinimalDaysInFirstWeek()&lt;/code&gt; &lt;/a&gt;天。因此，第一周的开始时间可能是 &lt;code&gt;minDays&lt;/code&gt; 之前的minDays天。如果第一周从月份开始之后开始，则之前的时间为零周（0）。</target>
        </trans-unit>
        <trans-unit id="12d77cb8838ad5fb792309f27517ce73b66b3ed1" translate="yes" xml:space="preserve">
          <source>Week one(1) is the week starting on the &lt;a href=&quot;#getFirstDayOfWeek()&quot;&gt;&lt;code&gt;getFirstDayOfWeek()&lt;/code&gt;&lt;/a&gt; where there are at least &lt;a href=&quot;#getMinimalDaysInFirstWeek()&quot;&gt;&lt;code&gt;getMinimalDaysInFirstWeek()&lt;/code&gt;&lt;/a&gt; days in the year. If the first week starts after the start of the year then the period before is in the last week of the previous year.</source>
          <target state="translated">第一周（1）是从&lt;a href=&quot;#getFirstDayOfWeek()&quot;&gt; &lt;code&gt;getFirstDayOfWeek()&lt;/code&gt; &lt;/a&gt;开始的一周，一年中至少有&lt;a href=&quot;#getMinimalDaysInFirstWeek()&quot;&gt; &lt;code&gt;getMinimalDaysInFirstWeek()&lt;/code&gt; &lt;/a&gt;天。如果第一周是在年初之后开始的，则之前的时间段是在上一年的最后一周。</target>
        </trans-unit>
        <trans-unit id="ceffe96a6e332c6dd3063a343f6124a6b5ee6477" translate="yes" xml:space="preserve">
          <source>Week one(1) is the week starting on the &lt;a href=&quot;#getFirstDayOfWeek()&quot;&gt;&lt;code&gt;getFirstDayOfWeek()&lt;/code&gt;&lt;/a&gt; where there are at least &lt;a href=&quot;#getMinimalDaysInFirstWeek()&quot;&gt;&lt;code&gt;getMinimalDaysInFirstWeek()&lt;/code&gt;&lt;/a&gt; days in the year. Thus, week one may start before the start of the year. If the first week starts after the start of the year then the period before is in the last week of the previous year.</source>
          <target state="translated">第一周（1）是从&lt;a href=&quot;#getFirstDayOfWeek()&quot;&gt; &lt;code&gt;getFirstDayOfWeek()&lt;/code&gt; &lt;/a&gt;开始的一周，一年中至少有&lt;a href=&quot;#getMinimalDaysInFirstWeek()&quot;&gt; &lt;code&gt;getMinimalDaysInFirstWeek()&lt;/code&gt; &lt;/a&gt;天。因此，第一周可能会在今年年初之前开始。如果第一周是在年初之后开始的，则之前的时间段是在上一年的最后一周。</target>
        </trans-unit>
        <trans-unit id="4f6f45d858ed4016de445396b12998ca4b8aad27" translate="yes" xml:space="preserve">
          <source>Week one(1) is the week starting on the &lt;a href=&quot;#getFirstDayOfWeek()&quot;&gt;&lt;code&gt;getFirstDayOfWeek()&lt;/code&gt;&lt;/a&gt; where there are at least &lt;a href=&quot;#getMinimalDaysInFirstWeek()&quot;&gt;&lt;code&gt;getMinimalDaysInFirstWeek()&lt;/code&gt;&lt;/a&gt; days in the year. Thus, week one may start up to &lt;code&gt;minDays&lt;/code&gt; days before the start of the year. If the first week starts after the start of the year then the period before is week zero (0).</source>
          <target state="translated">第一周（1）是从&lt;a href=&quot;#getFirstDayOfWeek()&quot;&gt; &lt;code&gt;getFirstDayOfWeek()&lt;/code&gt; &lt;/a&gt;开始的一周，一年中至少有&lt;a href=&quot;#getMinimalDaysInFirstWeek()&quot;&gt; &lt;code&gt;getMinimalDaysInFirstWeek()&lt;/code&gt; &lt;/a&gt;天。因此，第一周可能会在 &lt;code&gt;minDays&lt;/code&gt; 之前的minDays天开始。如果第一周从年初开始之后开始，则之前的时间段为零周（0）。</target>
        </trans-unit>
        <trans-unit id="44f1f99446cb5330dbad01f12f044f5a225971e2" translate="yes" xml:space="preserve">
          <source>Week one(1) is the week starting on the &lt;a href=&quot;weekfields#getFirstDayOfWeek--&quot;&gt;&lt;code&gt;getFirstDayOfWeek()&lt;/code&gt;&lt;/a&gt; where there are at least &lt;a href=&quot;weekfields#getMinimalDaysInFirstWeek--&quot;&gt;&lt;code&gt;getMinimalDaysInFirstWeek()&lt;/code&gt;&lt;/a&gt; days in the year. If the first week starts after the start of the year then the period before is in the last week of the previous year.</source>
          <target state="translated">第一周（1）是从&lt;a href=&quot;weekfields#getFirstDayOfWeek--&quot;&gt; &lt;code&gt;getFirstDayOfWeek()&lt;/code&gt; &lt;/a&gt;开始的一周，一年中至少有&lt;a href=&quot;weekfields#getMinimalDaysInFirstWeek--&quot;&gt; &lt;code&gt;getMinimalDaysInFirstWeek()&lt;/code&gt; &lt;/a&gt;天。如果第一周在年初之后开始，则之前的时间段是在上一年的最后一周。</target>
        </trans-unit>
        <trans-unit id="59d424ddfaa661a922cb86607e9a3548d6b3e08f" translate="yes" xml:space="preserve">
          <source>Week one(1) is the week starting on the &lt;a href=&quot;weekfields#getFirstDayOfWeek--&quot;&gt;&lt;code&gt;getFirstDayOfWeek()&lt;/code&gt;&lt;/a&gt; where there are at least &lt;a href=&quot;weekfields#getMinimalDaysInFirstWeek--&quot;&gt;&lt;code&gt;getMinimalDaysInFirstWeek()&lt;/code&gt;&lt;/a&gt; days in the year. Thus, week one may start before the start of the year. If the first week starts after the start of the year then the period before is in the last week of the previous year.</source>
          <target state="translated">第一周（1）是从&lt;a href=&quot;weekfields#getFirstDayOfWeek--&quot;&gt; &lt;code&gt;getFirstDayOfWeek()&lt;/code&gt; &lt;/a&gt;开始的一周，一年中至少有&lt;a href=&quot;weekfields#getMinimalDaysInFirstWeek--&quot;&gt; &lt;code&gt;getMinimalDaysInFirstWeek()&lt;/code&gt; &lt;/a&gt;天。因此，第一周可能会在今年年初之前开始。如果第一周在年初之后开始，则之前的时间段是在上一年的最后一周。</target>
        </trans-unit>
        <trans-unit id="edf457af9ac86c639d6fa25a82d99903848d2cc3" translate="yes" xml:space="preserve">
          <source>Week one(1) is the week starting on the &lt;a href=&quot;weekfields#getFirstDayOfWeek--&quot;&gt;&lt;code&gt;getFirstDayOfWeek()&lt;/code&gt;&lt;/a&gt; where there are at least &lt;a href=&quot;weekfields#getMinimalDaysInFirstWeek--&quot;&gt;&lt;code&gt;getMinimalDaysInFirstWeek()&lt;/code&gt;&lt;/a&gt; days in the year. Thus, week one may start up to &lt;code&gt;minDays&lt;/code&gt; days before the start of the year. If the first week starts after the start of the year then the period before is week zero (0).</source>
          <target state="translated">第一周（1）是从&lt;a href=&quot;weekfields#getFirstDayOfWeek--&quot;&gt; &lt;code&gt;getFirstDayOfWeek()&lt;/code&gt; &lt;/a&gt;开始的一周，一年中至少有&lt;a href=&quot;weekfields#getMinimalDaysInFirstWeek--&quot;&gt; &lt;code&gt;getMinimalDaysInFirstWeek()&lt;/code&gt; &lt;/a&gt;天。因此，第一周可能会在 &lt;code&gt;minDays&lt;/code&gt; 之前的minDays天开始。如果第一周从年初开始之后开始，则之前的时间段为零周（0）。</target>
        </trans-unit>
        <trans-unit id="21523175d42396f1b83a7d224bcef6c78db04431" translate="yes" xml:space="preserve">
          <source>Week year</source>
          <target state="translated">周年</target>
        </trans-unit>
        <trans-unit id="0f3cd7a23e2be7e3002b8bffb3ed9ec37177e7b2" translate="yes" xml:space="preserve">
          <source>WeekFields</source>
          <target state="translated">WeekFields</target>
        </trans-unit>
        <trans-unit id="22700d348b3e11d9fd6613090889ec190de727aa" translate="yes" xml:space="preserve">
          <source>WeekFields instances are singletons; for each unique combination of &lt;code&gt;firstDayOfWeek&lt;/code&gt; and &lt;code&gt;minimalDaysInFirstWeek&lt;/code&gt; the same instance will be returned.</source>
          <target state="translated">WeekFields实例是单例；对于 &lt;code&gt;firstDayOfWeek&lt;/code&gt; 和 &lt;code&gt;minimalDaysInFirstWeek&lt;/code&gt; 的每个唯一组合，将返回相同的实例。</target>
        </trans-unit>
        <trans-unit id="718dae35ec7f29671d329f016891913ac6dd0953" translate="yes" xml:space="preserve">
          <source>WeekFields instances are singletons; for each unique combination of &lt;code&gt;firstDayOfWeek&lt;/code&gt; and &lt;code&gt;minimalDaysInFirstWeek&lt;/code&gt; the the same instance will be returned.</source>
          <target state="translated">WeekFields实例是单例；对于 &lt;code&gt;firstDayOfWeek&lt;/code&gt; 和 &lt;code&gt;minimalDaysInFirstWeek&lt;/code&gt; 的每个唯一组合，将返回相同的实例。</target>
        </trans-unit>
        <trans-unit id="44d5d3a1e1dee13721fd9eb305d4686b3f9e55b7" translate="yes" xml:space="preserve">
          <source>WeekFields provides five fields, &lt;a href=&quot;#dayOfWeek()&quot;&gt;&lt;code&gt;dayOfWeek()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#weekOfMonth()&quot;&gt;&lt;code&gt;weekOfMonth()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#weekOfYear()&quot;&gt;&lt;code&gt;weekOfYear()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#weekOfWeekBasedYear()&quot;&gt;&lt;code&gt;weekOfWeekBasedYear()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#weekBasedYear()&quot;&gt;&lt;code&gt;weekBasedYear()&lt;/code&gt;&lt;/a&gt; that provide access to the values from any &lt;a href=&quot;temporal&quot;&gt;temporal object&lt;/a&gt;.</source>
          <target state="translated">WeekFields提供了五个字段，&lt;a href=&quot;#dayOfWeek()&quot;&gt; &lt;code&gt;dayOfWeek()&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#weekOfMonth()&quot;&gt; &lt;code&gt;weekOfMonth()&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#weekOfYear()&quot;&gt; &lt;code&gt;weekOfYear()&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#weekOfWeekBasedYear()&quot;&gt; &lt;code&gt;weekOfWeekBasedYear()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#weekBasedYear()&quot;&gt; &lt;code&gt;weekBasedYear()&lt;/code&gt; &lt;/a&gt;，它们可以访问任何&lt;a href=&quot;temporal&quot;&gt;时间对象&lt;/a&gt;的值。</target>
        </trans-unit>
        <trans-unit id="89a2292f88acbc8f0e38aee8edbc776ed1156087" translate="yes" xml:space="preserve">
          <source>WeekFields provides five fields, &lt;a href=&quot;weekfields#dayOfWeek--&quot;&gt;&lt;code&gt;dayOfWeek()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;weekfields#weekOfMonth--&quot;&gt;&lt;code&gt;weekOfMonth()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;weekfields#weekOfYear--&quot;&gt;&lt;code&gt;weekOfYear()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;weekfields#weekOfWeekBasedYear--&quot;&gt;&lt;code&gt;weekOfWeekBasedYear()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;weekfields#weekBasedYear--&quot;&gt;&lt;code&gt;weekBasedYear()&lt;/code&gt;&lt;/a&gt; that provide access to the values from any &lt;a href=&quot;temporal&quot;&gt;temporal object&lt;/a&gt;.</source>
          <target state="translated">WeekFields提供了五个字段，分别是&lt;a href=&quot;weekfields#dayOfWeek--&quot;&gt; &lt;code&gt;dayOfWeek()&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;weekfields#weekOfMonth--&quot;&gt; &lt;code&gt;weekOfMonth()&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;weekfields#weekOfYear--&quot;&gt; &lt;code&gt;weekOfYear()&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;weekfields#weekOfWeekBasedYear--&quot;&gt; &lt;code&gt;weekOfWeekBasedYear()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;weekfields#weekBasedYear--&quot;&gt; &lt;code&gt;weekBasedYear()&lt;/code&gt; &lt;/a&gt;，它们可以访问任何&lt;a href=&quot;temporal&quot;&gt;时间对象&lt;/a&gt;的值。</target>
        </trans-unit>
        <trans-unit id="6cb3080d6ff8341db52a2cdfe428e6fe7cfdc77d" translate="yes" xml:space="preserve">
          <source>WeekFields.dayOfWeek()</source>
          <target state="translated">WeekFields.dayOfWeek()</target>
        </trans-unit>
        <trans-unit id="63de50e0e26b59f3d9fe368fff1375c932f6dc68" translate="yes" xml:space="preserve">
          <source>WeekFields.equals()</source>
          <target state="translated">WeekFields.equals()</target>
        </trans-unit>
        <trans-unit id="307be796ddd4af18d3ea219c21738d280f71a9f6" translate="yes" xml:space="preserve">
          <source>WeekFields.getFirstDayOfWeek()</source>
          <target state="translated">WeekFields.getFirstDayOfWeek()</target>
        </trans-unit>
        <trans-unit id="9eb1a32786064c34464f305adb94564c93fc3d6a" translate="yes" xml:space="preserve">
          <source>WeekFields.getMinimalDaysInFirstWeek()</source>
          <target state="translated">WeekFields.getMinimalDaysInFirstWeek()</target>
        </trans-unit>
        <trans-unit id="0f4344dbb38df7c1dd4475092ee3cc1b31b7a1dc" translate="yes" xml:space="preserve">
          <source>WeekFields.hashCode()</source>
          <target state="translated">WeekFields.hashCode()</target>
        </trans-unit>
        <trans-unit id="f5a7902f43adfba0ce22ee041b83a1d8e9b00d05" translate="yes" xml:space="preserve">
          <source>WeekFields.of()</source>
          <target state="translated">WeekFields.of()</target>
        </trans-unit>
        <trans-unit id="0d111eab407e09a34fda6c1f334ea981ad02f8d3" translate="yes" xml:space="preserve">
          <source>WeekFields.toString()</source>
          <target state="translated">WeekFields.toString()</target>
        </trans-unit>
        <trans-unit id="f7d24644a2eae9dfbf214b9d12aa277c6a89292c" translate="yes" xml:space="preserve">
          <source>WeekFields.weekBasedYear()</source>
          <target state="translated">WeekFields.weekBasedYear()</target>
        </trans-unit>
        <trans-unit id="6ed8a499946db10836e56570eaad12d34de1b1e4" translate="yes" xml:space="preserve">
          <source>WeekFields.weekOfMonth()</source>
          <target state="translated">WeekFields.weekOfMonth()</target>
        </trans-unit>
        <trans-unit id="f94cf8e74a33d036b43c60e0a361b7ab911bc24a" translate="yes" xml:space="preserve">
          <source>WeekFields.weekOfWeekBasedYear()</source>
          <target state="translated">WeekFields.weekOfWeekBasedYear()</target>
        </trans-unit>
        <trans-unit id="2788abb8d6fe59a50dbde8e26f797c0be24e8bc7" translate="yes" xml:space="preserve">
          <source>WeekFields.weekOfYear()</source>
          <target state="translated">WeekFields.weekOfYear()</target>
        </trans-unit>
        <trans-unit id="7d75266a53b99ce4d80d337862ea1edd8ba1b1a1" translate="yes" xml:space="preserve">
          <source>Weeks</source>
          <target state="translated">Weeks</target>
        </trans-unit>
        <trans-unit id="8df986efff37f1cf0680e8b945fdb0be0bb07b78" translate="yes" xml:space="preserve">
          <source>Weight is the overall 'weight' of the glyph in the line. Generally it is proportional to the size of the font. Glyphs with larger weight are allocated a correspondingly larger amount of the change in space.</source>
          <target state="translated">重量是指字形在行中的整体 &quot;重量&quot;。一般来说,它与字体的大小成正比。权重较大的字形会被分配相应较大的空间变化量。</target>
        </trans-unit>
        <trans-unit id="20ac2f25a966eb781339ca5e0fe0f7f875b9cfc8" translate="yes" xml:space="preserve">
          <source>Well known port for registry.</source>
          <target state="translated">知名的注册表端口。</target>
        </trans-unit>
        <trans-unit id="b5ceaaaab5693bd089df6a3f31655e313dce3989" translate="yes" xml:space="preserve">
          <source>Well-formed country/region values have the form &lt;code&gt;[a-zA-Z]{2} | [0-9]{3}&lt;/code&gt;</source>
          <target state="translated">格式正确的国家/地区值的格式为 &lt;code&gt;[a-zA-Z]{2} | [0-9]{3}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0fe9a9ddb38f6c4d512e9dbb79376b8ca30e2bf0" translate="yes" xml:space="preserve">
          <source>Well-formed keys are single characters from the set &lt;code&gt;[0-9a-zA-Z]&lt;/code&gt;. Well-formed values have the form &lt;code&gt;SUBTAG ('-' SUBTAG)*&lt;/code&gt; where for the key 'x' &lt;code&gt;SUBTAG = [0-9a-zA-Z]{1,8}&lt;/code&gt; and for other keys &lt;code&gt;SUBTAG = [0-9a-zA-Z]{2,8}&lt;/code&gt; (that is, 'x' allows single-character subtags).</source>
          <target state="translated">格式正确的键是集合 &lt;code&gt;[0-9a-zA-Z]&lt;/code&gt; 中的单个字符。格式 &lt;code&gt;SUBTAG ('-' SUBTAG)*&lt;/code&gt; 值的格式为SUBTAG（'-'SUBTAG）*，其中对于键' &lt;code&gt;SUBTAG = [0-9a-zA-Z]{1,8}&lt;/code&gt; ，对于其他键 &lt;code&gt;SUBTAG = [0-9a-zA-Z]{2,8}&lt;/code&gt; （即'x'允许使用单个字符的子标记）。</target>
        </trans-unit>
        <trans-unit id="6162cb572cd0fa07269f9f853edbaab78da2fbaa" translate="yes" xml:space="preserve">
          <source>Well-formed language values have the form &lt;code&gt;[a-zA-Z]{2,8}&lt;/code&gt;. Note that this is not the full BCP47 language production, since it excludes extlang. They are not needed since modern three-letter language codes replace them.</source>
          <target state="translated">格式正确的语言值具有 &lt;code&gt;[a-zA-Z]{2,8}&lt;/code&gt; 的形式。请注意，这不是完整的BCP47语言版本，因为它不包括extlang。不需要它们，因为现代的三字母语言代码代替了它们。</target>
        </trans-unit>
        <trans-unit id="a50506c60f4a43fce22721c5603adee4e842c36f" translate="yes" xml:space="preserve">
          <source>Well-formed language values have the form &lt;code&gt;[a-zA-Z]{2,8}&lt;/code&gt;. Note that this is not the the full BCP47 language production, since it excludes extlang. They are not needed since modern three-letter language codes replace them.</source>
          <target state="translated">格式正确的语言值具有 &lt;code&gt;[a-zA-Z]{2,8}&lt;/code&gt; 的形式。请注意，这不是完整的BCP47语言版本，因为它不包括extlang。不需要它们，因为现代的三字母语言代码代替了它们。</target>
        </trans-unit>
        <trans-unit id="858fa2509ca423136e7cf31f512c6eefb90eeb81" translate="yes" xml:space="preserve">
          <source>Well-formed script values have the form &lt;code&gt;[a-zA-Z]{4}&lt;/code&gt;</source>
          <target state="translated">格式正确的脚本值的格式为 &lt;code&gt;[a-zA-Z]{4}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f4d5d35b51d9cbb55387c8e6d28bc1a22d820b0a" translate="yes" xml:space="preserve">
          <source>Well-formed variant values have the form &lt;code&gt;SUBTAG
   (('_'|'-') SUBTAG)*&lt;/code&gt; where &lt;code&gt;SUBTAG =
   [0-9][0-9a-zA-Z]{3} | [0-9a-zA-Z]{5,8}&lt;/code&gt;. (Note: BCP 47 only uses hyphen ('-') as a delimiter, this is more lenient).</source>
          <target state="translated">格式 &lt;code&gt;SUBTAG (('_'|'-') SUBTAG)*&lt;/code&gt; 变量值的形式为SUBTAG（（'_'|'-'）SUBTAG）*，其中 &lt;code&gt;SUBTAG = [0-9][0-9a-zA-Z]{3} | [0-9a-zA-Z]{5,8}&lt;/code&gt; 。（注意：BCP 47仅将连字符（'-'）用作分隔符，这样比较宽松）。</target>
        </trans-unit>
        <trans-unit id="ce95843c87158992b2858d825f7a237360e6b63f" translate="yes" xml:space="preserve">
          <source>West pane</source>
          <target state="translated">西窗格</target>
        </trans-unit>
        <trans-unit id="6671f7458666597da2926cfbb386f9379fec61ac" translate="yes" xml:space="preserve">
          <source>What can you already do with the above setup? &lt;code&gt;DynamicLinkerFactory&lt;/code&gt; by default creates a &lt;code&gt;DynamicLinker&lt;/code&gt; that can link Java objects with the usual Java semantics. If you have these three simple classes:</source>
          <target state="translated">使用上述设置您已经可以做什么？ &lt;code&gt;DynamicLinkerFactory&lt;/code&gt; 默认创建一个 &lt;code&gt;DynamicLinker&lt;/code&gt; ，可以链接与通常的Java语义的Java对象。如果您具有以下三个简单的类：</target>
        </trans-unit>
        <trans-unit id="c9e4b6efb7854b9fa304410f366631e4c9b775f3" translate="yes" xml:space="preserve">
          <source>What is an Attribute?</source>
          <target state="translated">什么是属性?</target>
        </trans-unit>
        <trans-unit id="301ddf4fd686c9921c42e78bd43366e889d8837c" translate="yes" xml:space="preserve">
          <source>What is the offset along the minor axis</source>
          <target state="translated">沿小轴的偏移量是多少</target>
        </trans-unit>
        <trans-unit id="c587c6fc95a9107db0097d9b15fd1d5ffc2e7330" translate="yes" xml:space="preserve">
          <source>What is the span along the major axis.</source>
          <target state="translated">沿主轴线的跨度是多少。</target>
        </trans-unit>
        <trans-unit id="8dbf8f4ff843b6789ff963d498444a2edfc85fed" translate="yes" xml:space="preserve">
          <source>What is the span along the minor axis.</source>
          <target state="translated">沿小轴的跨度是多少。</target>
        </trans-unit>
        <trans-unit id="e1253f057c65c5140688cb6f74eaff535608ffb8" translate="yes" xml:space="preserve">
          <source>What operation was being attempted when a conflict occurred</source>
          <target state="translated">发生冲突时,正在尝试什么行动?</target>
        </trans-unit>
        <trans-unit id="3dc6bced115a4ebb63076f833d6f3f46734f7360" translate="yes" xml:space="preserve">
          <source>What the &lt;code&gt;java.sql&lt;/code&gt; Package Contains</source>
          <target state="translated">什么 &lt;code&gt;java.sql&lt;/code&gt; 包包含</target>
        </trans-unit>
        <trans-unit id="7993d29ebd453bb82d2373c5e86cbe64769bdcd1" translate="yes" xml:space="preserve">
          <source>What the JDBC 4.3 API Includes</source>
          <target state="translated">JDBC 4.3 API包括什么?</target>
        </trans-unit>
        <trans-unit id="dae0b4b4d87d6d1381813d3114a08a7d3cf1d6f4" translate="yes" xml:space="preserve">
          <source>What the JDBC&amp;trade; 4.3 API Includes</source>
          <target state="translated">JDBC&amp;trade;4.3 API包括什么</target>
        </trans-unit>
        <trans-unit id="f523aaaa18b102076687e4244d4e07bb6f436a11" translate="yes" xml:space="preserve">
          <source>What the Permission Allows</source>
          <target state="translated">权限允许的内容</target>
        </trans-unit>
        <trans-unit id="373c94003a259747dc5ca0b92f838b2b5acf5d59" translate="yes" xml:space="preserve">
          <source>What this means is that the ClassLoader may be wrapped in another ClassLoader for security or other reasons.</source>
          <target state="translated">这意味着,出于安全或其他原因,ClassLoader可能会被包裹在另一个ClassLoader中。</target>
        </trans-unit>
        <trans-unit id="ca20440fd173e3537d3dbdf1472c311d148f0f89" translate="yes" xml:space="preserve">
          <source>What's returned by &lt;code&gt;AccessibleJEditorPaneHTML.getAccessibleText&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;AccessibleJEditorPaneHTML.getAccessibleText&lt;/code&gt; 返回的内容。</target>
        </trans-unit>
        <trans-unit id="caf5d2a20376b8ede2618bea6b71d51812f11949" translate="yes" xml:space="preserve">
          <source>What's returned by &lt;code&gt;AccessibleJEditorPaneHTML.getAccessibleText&lt;/code&gt;. Provides support for &lt;code&gt;AccessibleHypertext&lt;/code&gt; in case there is an HTML document being displayed in this &lt;code&gt;JEditorPane&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;AccessibleJEditorPaneHTML.getAccessibleText&lt;/code&gt; 返回的内容。在此 &lt;code&gt;JEditorPane&lt;/code&gt; 中显示HTML文档的情况下，提供对 &lt;code&gt;AccessibleHypertext&lt;/code&gt; 的支持。</target>
        </trans-unit>
        <trans-unit id="2c62f541df771dc9c17e6db7806198f01ce3df87" translate="yes" xml:space="preserve">
          <source>Whatever the</source>
          <target state="translated">不管是什么</target>
        </trans-unit>
        <trans-unit id="89357495a0b5512bbc9f5bc66b16ee57716aba68" translate="yes" xml:space="preserve">
          <source>Whatever the &lt;a href=&quot;#groupname&quot;&gt;named-capturing group&lt;/a&gt; &quot;name&quot; matched</source>
          <target state="translated">无论&lt;a href=&quot;#groupname&quot;&gt;命名捕获组&lt;/a&gt; &amp;ldquo;名称&amp;rdquo;是否匹配</target>
        </trans-unit>
        <trans-unit id="183f14f8a35d4f7ed23e203448b1fd0af728304e" translate="yes" xml:space="preserve">
          <source>When 'value' is no longer valid then the getter method is invoked for the attribute. The 'lastUpdatedTimeStamp' field and `value' fields are updated.</source>
          <target state="translated">当'value'不再有效时,那么就会调用该属性的getter方法。'lastUpdatedTimeStamp'字段和`value'字段会被更新。</target>
        </trans-unit>
        <trans-unit id="c20d6596c0516c20ee93280ced0b8c1583308051" translate="yes" xml:space="preserve">
          <source>When 'value' is no longer valid then the operation method is invoked. The 'lastUpdatedTimeStamp' field and `value' fields are updated.</source>
          <target state="translated">当'value'不再有效时,则调用操作方法。'lastUpdatedTimeStamp'字段和`value'字段被更新。</target>
        </trans-unit>
        <trans-unit id="7ad7cf61a538ac9682cd9c38c51af1051f6daf5e" translate="yes" xml:space="preserve">
          <source>When 'value' is valid, 'value' is returned.</source>
          <target state="translated">当'value'有效时,将返回'value'。</target>
        </trans-unit>
        <trans-unit id="7333d8d0058642dce5b6ba018287a61a8e12ae52" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#sendNotification(javax.management.Notification)&quot;&gt;&lt;code&gt;sendNotification&lt;/code&gt;&lt;/a&gt; is called, a listener is selected if it was added with a null &lt;a href=&quot;notificationfilter&quot;&gt;&lt;code&gt;NotificationFilter&lt;/code&gt;&lt;/a&gt;, or if &lt;a href=&quot;notificationfilter#isNotificationEnabled(javax.management.Notification)&quot;&gt;&lt;code&gt;isNotificationEnabled&lt;/code&gt;&lt;/a&gt; returns true for the notification being sent. The call to &lt;code&gt;NotificationFilter.isNotificationEnabled&lt;/code&gt; takes place in the thread that called &lt;code&gt;sendNotification&lt;/code&gt;. Then, for each selected listener, &lt;a href=&quot;../../../java.base/java/util/concurrent/executor#execute(java.lang.Runnable)&quot;&gt;&lt;code&gt;executor.execute&lt;/code&gt;&lt;/a&gt; is called with a command that calls the &lt;code&gt;handleNotification&lt;/code&gt; method.</source>
          <target state="translated">当&lt;a href=&quot;#sendNotification(javax.management.Notification)&quot;&gt; &lt;code&gt;sendNotification&lt;/code&gt; 时&lt;/a&gt;被调用时，选择了一个监听器，如果它是用空加&lt;a href=&quot;notificationfilter&quot;&gt; &lt;code&gt;NotificationFilter&lt;/code&gt; 的&lt;/a&gt;，或者如果&lt;a href=&quot;notificationfilter#isNotificationEnabled(javax.management.Notification)&quot;&gt; &lt;code&gt;isNotificationEnabled&lt;/code&gt; &lt;/a&gt;返回true为发送通知。对 &lt;code&gt;NotificationFilter.isNotificationEnabled&lt;/code&gt; 的调用发生在名为 &lt;code&gt;sendNotification&lt;/code&gt; 的线程中。然后，对于每个所选择的监听器，&lt;a href=&quot;../../../java.base/java/util/concurrent/executor#execute(java.lang.Runnable)&quot;&gt; &lt;code&gt;executor.execute&lt;/code&gt; &lt;/a&gt;被调用，调用一个命令 &lt;code&gt;handleNotification&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="720701165d46b861473379cd54f2570d2c747f20" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#value-field&quot;&gt;value&lt;/a&gt; was set.</source>
          <target state="translated">当&lt;a href=&quot;#value-field&quot;&gt;值&lt;/a&gt;被设置。</target>
        </trans-unit>
        <trans-unit id="2787518abc9792a673e362e95dc630f0312e2d2c" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#waitFor()&quot;&gt;&lt;code&gt;waitFor()&lt;/code&gt;&lt;/a&gt; returns successfully the CompletableFuture is &lt;a href=&quot;../util/concurrent/completablefuture#complete(T)&quot;&gt;completed&lt;/a&gt; regardless of the exit status of the process. This implementation may consume a lot of memory for thread stacks if a large number of processes are waited for concurrently.</source>
          <target state="translated">当&lt;a href=&quot;#waitFor()&quot;&gt; &lt;code&gt;waitFor()&lt;/code&gt; &lt;/a&gt;成功返回时，无论进程的退出状态如何，CompletableFuture都会&lt;a href=&quot;../util/concurrent/completablefuture#complete(T)&quot;&gt;完成&lt;/a&gt;。如果同时等待大量进程，则此实现可能会为线程堆栈消耗大量内存。</target>
        </trans-unit>
        <trans-unit id="0b41c0f3ed6f8adeecdcc86bb85da400ea38c18d" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;../../../org/xml/sax/contenthandler#startElement(java.lang.String,java.lang.String,java.lang.String,org.xml.sax.Attributes)&quot;&gt;&lt;code&gt;ContentHandler.startElement(String, String, String, Attributes)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../../org/xml/sax/contenthandler#endElement(java.lang.String,java.lang.String,java.lang.String)&quot;&gt;&lt;code&gt;ContentHandler.endElement(String, String, String)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../../org/xml/sax/contenthandler#startDocument()&quot;&gt;&lt;code&gt;ContentHandler.startDocument()&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;../../../org/xml/sax/contenthandler#endDocument()&quot;&gt;&lt;code&gt;ContentHandler.endDocument()&lt;/code&gt;&lt;/a&gt; are invoked on a &lt;a href=&quot;validatorhandler&quot;&gt;&lt;code&gt;ValidatorHandler&lt;/code&gt;&lt;/a&gt;, the same method on the user-specified &lt;a href=&quot;../../../org/xml/sax/contenthandler&quot;&gt;&lt;code&gt;ContentHandler&lt;/code&gt;&lt;/a&gt; must be invoked for the same event before the callback returns.</source>
          <target state="translated">当在&lt;a href=&quot;validatorhandler&quot;&gt; &lt;code&gt;ValidatorHandler&lt;/code&gt; &lt;/a&gt;上调用&lt;a href=&quot;../../../org/xml/sax/contenthandler#startElement(java.lang.String,java.lang.String,java.lang.String,org.xml.sax.Attributes)&quot;&gt; &lt;code&gt;ContentHandler.startElement(String, String, String, Attributes)&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../../../org/xml/sax/contenthandler#endElement(java.lang.String,java.lang.String,java.lang.String)&quot;&gt; &lt;code&gt;ContentHandler.endElement(String, String, String)&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../../../org/xml/sax/contenthandler#startDocument()&quot;&gt; &lt;code&gt;ContentHandler.startDocument()&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../../../org/xml/sax/contenthandler#endDocument()&quot;&gt; &lt;code&gt;ContentHandler.endDocument()&lt;/code&gt; &lt;/a&gt;时，用户使用相同的方法-在回调返回之前，必须为同一事件调用指定的&lt;a href=&quot;../../../org/xml/sax/contenthandler&quot;&gt; &lt;code&gt;ContentHandler&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="eb0c4944d21938573c8de12446d041f26931fa10" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;notificationbroadcastersupport#sendNotification-javax.management.Notification-&quot;&gt;&lt;code&gt;sendNotification&lt;/code&gt;&lt;/a&gt; is called, a listener is selected if it was added with a null &lt;a href=&quot;notificationfilter&quot;&gt;&lt;code&gt;NotificationFilter&lt;/code&gt;&lt;/a&gt;, or if &lt;a href=&quot;notificationfilter#isNotificationEnabled-javax.management.Notification-&quot;&gt;&lt;code&gt;isNotificationEnabled&lt;/code&gt;&lt;/a&gt; returns true for the notification being sent. The call to &lt;code&gt;NotificationFilter.isNotificationEnabled&lt;/code&gt; takes place in the thread that called &lt;code&gt;sendNotification&lt;/code&gt;. Then, for each selected listener, &lt;a href=&quot;../../java/util/concurrent/executor#execute-java.lang.Runnable-&quot;&gt;&lt;code&gt;executor.execute&lt;/code&gt;&lt;/a&gt; is called with a command that calls the &lt;code&gt;handleNotification&lt;/code&gt; method.</source>
          <target state="translated">当&lt;a href=&quot;notificationbroadcastersupport#sendNotification-javax.management.Notification-&quot;&gt; &lt;code&gt;sendNotification&lt;/code&gt; 时&lt;/a&gt;被调用时，选择了一个监听器，如果它是用空加&lt;a href=&quot;notificationfilter&quot;&gt; &lt;code&gt;NotificationFilter&lt;/code&gt; 的&lt;/a&gt;，或者如果&lt;a href=&quot;notificationfilter#isNotificationEnabled-javax.management.Notification-&quot;&gt; &lt;code&gt;isNotificationEnabled&lt;/code&gt; &lt;/a&gt;返回true为发送通知。对 &lt;code&gt;NotificationFilter.isNotificationEnabled&lt;/code&gt; 的调用发生在名为 &lt;code&gt;sendNotification&lt;/code&gt; 的线程中。然后，对于每个所选择的监听器，&lt;a href=&quot;../../java/util/concurrent/executor#execute-java.lang.Runnable-&quot;&gt; &lt;code&gt;executor.execute&lt;/code&gt; &lt;/a&gt;被调用，调用一个命令 &lt;code&gt;handleNotification&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="ca53de9dd5a05f67d73beacc0a06e218c4b8b4f7" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;FRACTIONALMETRICS&lt;/code&gt; are enabled, the true font design metrics are scaled by the point size and used for layout with sub-pixel accuracy. The average density of glyphs and total length of a long string of characters will therefore more closely match the theoretical design of the font, but readability may be affected since individual pairs of characters may not always appear to be consistent distances apart depending on how the sub-pixel accumulation of the glyph origins meshes with the device pixel grid. Enabling this hint may be desirable when text layout is being performed that must be consistent across a wide variety of output resolutions. Specifically, this hint may be desirable in situations where the layout of text is being previewed on a low resolution device like a screen for output that will eventually be rendered on a high resolution printer or typesetting device.</source>
          <target state="translated">当 &lt;code&gt;FRACTIONALMETRICS&lt;/code&gt; 启用后，真正的字体设计指标将按磅大小进行缩放，并用于具有亚像素精度的布局。因此，字形的平均密度和长字符串的总长度将更紧密地匹配字体的理论设计，但是可读性可能会受到影响，因为各个字符对可能并不总是看起来是一致的距离，具体取决于子字体的方式。字形原点的像素累积与设备像素网格啮合。当正在执行的文本布局必须在各种输出分辨率上保持一致时，启用此提示可能是理想的。具体来说，在低分辨率设备（例如用于最终将在高分辨率打印机或排版设备上呈现的输出屏幕）上预览文本布局的情况下，此提示可能是理想的。</target>
        </trans-unit>
        <trans-unit id="3907f83b19a6bc999820d92454ce9500f2d86571" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;SSLSocket&lt;/code&gt;s are first created, no handshaking is done so that applications may first set their communication preferences: what cipher suites to use, whether the socket should be in client or server mode, etc. However, security is always provided by the time that application data is sent over the connection.</source>
          <target state="translated">当 &lt;code&gt;SSLSocket&lt;/code&gt; 的首次创建S，没有握手是这样做的应用程序可能首先设置它们的通信首选项：什么密码套件的使用，插座是否应该在客户端或服务器模式，等等。然而，安全总是被时间所提供应用程序数据通过连接发送。</target>
        </trans-unit>
        <trans-unit id="2865b5a1279039e3aa9655c29d186fd9156ffb33" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;SecurityManager&lt;/code&gt; is installed, the invoking thread must be granted this permission in order to replace the current &lt;code&gt;KeyboardFocusManager&lt;/code&gt;. If permission is not granted, a &lt;code&gt;SecurityException&lt;/code&gt; will be thrown.</source>
          <target state="translated">当 &lt;code&gt;SecurityManager&lt;/code&gt; 安装，调用线程必须以取代目前被授予这个权限 &lt;code&gt;KeyboardFocusManager&lt;/code&gt; 。如果未授予许可，则将引发 &lt;code&gt;SecurityException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aec348ffd93df939ed7064797ce4b1223e7792d9" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;T&lt;/code&gt; attempts to install the newly computed value, if the state is still at &lt;code&gt;2N&lt;/code&gt;, the class value will be initialized with the computed value, advancing it to state &lt;code&gt;2N+1&lt;/code&gt;.</source>
          <target state="translated">当 &lt;code&gt;T&lt;/code&gt; 尝试安装新计算的值时，如果状态仍为 &lt;code&gt;2N&lt;/code&gt; ，则将使用计算的值初始化类值，将其推进到状态 &lt;code&gt;2N+1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f789b0022722a1185a4c15638dba2438089f1c62" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;jdk.io.permissionsUseCanonicalPath&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, an invalid &lt;code&gt;FilePermission&lt;/code&gt; does not equal to any object except for itself, even if they are created using the same invalid path.</source>
          <target state="translated">如果 &lt;code&gt;jdk.io.permissionsUseCanonicalPath&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; ，则无效的 &lt;code&gt;FilePermission&lt;/code&gt; 并不等于除其本身以外的任何对象，即使它们是使用相同的无效路径创建的也是如此。</target>
        </trans-unit>
        <trans-unit id="586cdea8cb0e9df3dba6780f86611e27368352ca" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;myButton&lt;/code&gt; is pressed, the statement &lt;code&gt;frame.toFront()&lt;/code&gt; will be executed. One could get the same effect, with some additional compile-time type safety, by defining a new implementation of the &lt;code&gt;ActionListener&lt;/code&gt; interface and adding an instance of it to the button:</source>
          <target state="translated">当按下 &lt;code&gt;myButton&lt;/code&gt; 时，将执行语句 &lt;code&gt;frame.toFront()&lt;/code&gt; 。通过定义 &lt;code&gt;ActionListener&lt;/code&gt; 接口的新实现并将其实例添加到按钮，可以实现相同的效果，并具有更多的编译时类型安全性：</target>
        </trans-unit>
        <trans-unit id="c0904a47635f2e7b7777a12e80e944727838b0aa" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;remove&lt;/code&gt; or &lt;code&gt;insertString&lt;/code&gt; is invoked on the &lt;code&gt;DocumentFilter&lt;/code&gt;, the &lt;code&gt;DocumentFilter&lt;/code&gt; may callback into the &lt;code&gt;FilterBypass&lt;/code&gt; multiple times, or for different regions, but it should not callback into the &lt;code&gt;FilterBypass&lt;/code&gt; after returning from the &lt;code&gt;remove&lt;/code&gt; or &lt;code&gt;insertString&lt;/code&gt; method.</source>
          <target state="translated">当 &lt;code&gt;remove&lt;/code&gt; 或 &lt;code&gt;insertString&lt;/code&gt; 被所调用 &lt;code&gt;DocumentFilter&lt;/code&gt; ，所述 &lt;code&gt;DocumentFilter&lt;/code&gt; 可以进入回调的 &lt;code&gt;FilterBypass&lt;/code&gt; 多次，或者为不同的区域，但它不应该进入回调的 &lt;code&gt;FilterBypass&lt;/code&gt; 从返回后 &lt;code&gt;remove&lt;/code&gt; 或 &lt;code&gt;insertString&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="b7b9af0e4285748c91632c575b592ae96d9c9970" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;setAutoCreateRowSorter(true)&lt;/code&gt; is invoked, a &lt;code&gt;
 TableRowSorter&lt;/code&gt; is immediately created and installed on the table. While the &lt;code&gt;autoCreateRowSorter&lt;/code&gt; property remains &lt;code&gt;true&lt;/code&gt;, every time the model is changed, a new &lt;code&gt;
 TableRowSorter&lt;/code&gt; is created and set as the table's row sorter. The default value for the &lt;code&gt;autoCreateRowSorter&lt;/code&gt; property is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">当 &lt;code&gt;setAutoCreateRowSorter(true)&lt;/code&gt; 被调用时，一个 &lt;code&gt; TableRowSorter&lt;/code&gt; 还立即创建和安装在桌子上。当 &lt;code&gt;autoCreateRowSorter&lt;/code&gt; 属性保持为 &lt;code&gt;true&lt;/code&gt; 时，每次更改模型时，都会创建一个新的 &lt;code&gt; TableRowSorter&lt;/code&gt; 并将其设置为表的行排序器。 &lt;code&gt;autoCreateRowSorter&lt;/code&gt; 属性的默认值为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fcc753ccd7f4f147341d78ae6bbdfd159682020f" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;setMaximum&lt;/code&gt; is called, the maximum value is changed, and other values (including the minimum, the visible amount, and the current scroll bar value) are changed to be consistent with the new maximum.</source>
          <target state="translated">当 &lt;code&gt;setMaximum&lt;/code&gt; 被调用时，最大值被改变，并且其它值（包括最小值，可见量，和当前滚动条的值）被改变为与新的最大一致。</target>
        </trans-unit>
        <trans-unit id="634dff626ecd014481529c2d6290cf015b2f06a2" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;setMinimum&lt;/code&gt; is called, the minimum value is changed, and other values (including the maximum, the visible amount, and the current scroll bar value) are changed to be consistent with the new minimum.</source>
          <target state="translated">当 &lt;code&gt;setMinimum&lt;/code&gt; 被调用时，最小值被改变，并且其它值（包括最大值，可见量，和当前滚动条的值）被改变为与新的最小相一致。</target>
        </trans-unit>
        <trans-unit id="6366d90e5b77dc1a2fecffb2e332c4bd6f6dd999" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;setValue&lt;/code&gt; is called on the sum spring, &lt;code&gt;s3&lt;/code&gt;, the strain in &lt;code&gt;s3&lt;/code&gt; is calculated using one of the formulas above. Once the strain of the sum is known, the &lt;em&gt;value&lt;/em&gt;s of &lt;code&gt;s1&lt;/code&gt; and &lt;code&gt;s2&lt;/code&gt; are then set so that they are have a strain equal to that of the sum. The formulas are evaluated so as to take rounding errors into account and ensure that the sum of the &lt;em&gt;value&lt;/em&gt;s of &lt;code&gt;s1&lt;/code&gt; and &lt;code&gt;s2&lt;/code&gt; is exactly equal to the &lt;em&gt;value&lt;/em&gt; of &lt;code&gt;s3&lt;/code&gt;.</source>
          <target state="translated">当 &lt;code&gt;setValue&lt;/code&gt; 上调用的总和弹簧， &lt;code&gt;s3&lt;/code&gt; ，在应变 &lt;code&gt;s3&lt;/code&gt; 是使用上述公式之一来计算。一旦知道了总和的应变，就可以设置 &lt;code&gt;s1&lt;/code&gt; 和 &lt;code&gt;s2&lt;/code&gt; 的s&lt;em&gt;值&lt;/em&gt;，使它们的应变等于总和的应变。计算公式以考虑舍入误差，并确保 &lt;code&gt;s1&lt;/code&gt; 和 &lt;code&gt;s2&lt;/code&gt; 的&lt;em&gt;值&lt;/em&gt;s之和与 &lt;code&gt;s3&lt;/code&gt; 的&lt;em&gt;值&lt;/em&gt;完全相等。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="56200bf85aca75288ef457ae1d31ce485573f186" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;targetSize&lt;/code&gt; is outside the [MIN, MAX] range, the algorithm sets all sizes to their appropriate limiting value (maximum or minimum).</source>
          <target state="translated">当 &lt;code&gt;targetSize&lt;/code&gt; 在[MIN，MAX]范围之外时，该算法会将所有大小设置为适当的限制值（最大值或最小值）。</target>
        </trans-unit>
        <trans-unit id="1dab6c6877815ac1b0667bd54ac4119d91348f67" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;this&lt;/code&gt; instance has an undefined field, this conversion relies on the &lt;code&gt;java.util.GregorianCalendar&lt;/code&gt; default for its corresponding field. A notable difference between XML Schema 1.0 date/time datatypes and &lt;code&gt;java.util.GregorianCalendar&lt;/code&gt; is that Timezone value is optional for date/time datatypes and it is a required field for &lt;code&gt;java.util.GregorianCalendar&lt;/code&gt;. See javadoc for &lt;code&gt;java.util.TimeZone.getDefault()&lt;/code&gt; on how the default is determined. To explicitly specify the &lt;code&gt;TimeZone&lt;/code&gt; instance, see &lt;a href=&quot;#toGregorianCalendar(java.util.TimeZone,java.util.Locale,javax.xml.datatype.XMLGregorianCalendar)&quot;&gt;&lt;code&gt;toGregorianCalendar(TimeZone, Locale, XMLGregorianCalendar)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">当 &lt;code&gt;this&lt;/code&gt; 实例具有未定义的字段时，此转换依赖于 &lt;code&gt;java.util.GregorianCalendar&lt;/code&gt; 缺省字段为其对应的字段。 XML Schema 1.0日期/时间数据类型与 &lt;code&gt;java.util.GregorianCalendar&lt;/code&gt; 之间的显着区别是，时区值对于日期/时间数据类型是可选的，并且对于 &lt;code&gt;java.util.GregorianCalendar&lt;/code&gt; 是必填字段。有关如何确定默认值的信息，请参见javadoc中的 &lt;code&gt;java.util.TimeZone.getDefault()&lt;/code&gt; 。要显式指定 &lt;code&gt;TimeZone&lt;/code&gt; 实例，请参见&lt;a href=&quot;#toGregorianCalendar(java.util.TimeZone,java.util.Locale,javax.xml.datatype.XMLGregorianCalendar)&quot;&gt; &lt;code&gt;toGregorianCalendar(TimeZone, Locale, XMLGregorianCalendar)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="967844a303c6a0441b717d8f28102abbf2d49116" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;type&lt;/code&gt; has the value &quot;Radio&quot; or &quot;Checkbox&quot;, this represents the HTML checked attribute of the element.</source>
          <target state="translated">当 &lt;code&gt;type&lt;/code&gt; 的值为&amp;ldquo; Radio&amp;rdquo;或&amp;ldquo; Checkbox&amp;rdquo;时，表示元素的HTML选中属性。</target>
        </trans-unit>
        <trans-unit id="41b28a6a663649d53514039c0624918668b913be" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;type&lt;/code&gt; has the value &quot;Radio&quot; or &quot;Checkbox&quot;, this represents the HTML checked attribute of the element. The value of this attribute does not change if the state of the corresponding form control, in an interactive user agent, changes. Changes to this attribute, however, resets the state of the form control. See the checked attribute definition in HTML 4.0.</source>
          <target state="translated">当 &lt;code&gt;type&lt;/code&gt; 的值为&amp;ldquo; Radio&amp;rdquo;或&amp;ldquo; Checkbox&amp;rdquo;时，表示元素的HTML选中属性。如果交互式用户代理中相应表单控件的状态发生更改，则此属性的值不会更改。但是，对此属性所做的更改将重置窗体控件的状态。请参阅HTML 4.0中选中的属性定义。</target>
        </trans-unit>
        <trans-unit id="df87c54daa5b6b22cd03fdfcb4a354ce9aff9581" translate="yes" xml:space="preserve">
          <source>When FEATURE_SECURE_PROCESSING is enabled, it is recommended that implementations restrict external connections by default, though this may cause problems for applications that process XML/XSD/XSL with external references.</source>
          <target state="translated">当FEATURE_SECURE_PROCESSING被启用时,建议实现在默认情况下限制外部连接,尽管这可能会给使用外部引用处理XML/XSD/XSL的应用程序带来问题。</target>
        </trans-unit>
        <trans-unit id="1fe0e12bc1e4fbc587d188553680ac3198949110" translate="yes" xml:space="preserve">
          <source>When FLAG_SERIALIZABLE is set in &lt;code&gt;flags&lt;/code&gt;, the function objects will implement &lt;code&gt;Serializable&lt;/code&gt;, and will have a &lt;code&gt;writeReplace&lt;/code&gt; method that returns an appropriate &lt;a href=&quot;serializedlambda&quot;&gt;&lt;code&gt;SerializedLambda&lt;/code&gt;&lt;/a&gt;. The &lt;code&gt;caller&lt;/code&gt; class must have an appropriate &lt;code&gt;$deserializeLambda$&lt;/code&gt; method, as described in &lt;a href=&quot;serializedlambda&quot;&gt;&lt;code&gt;SerializedLambda&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">当在 &lt;code&gt;flags&lt;/code&gt; 中设置FLAG_SERIALIZABLE时，函数对象将实现 &lt;code&gt;Serializable&lt;/code&gt; ，并将具有 &lt;code&gt;writeReplace&lt;/code&gt; 方法，该方法返回适当的&lt;a href=&quot;serializedlambda&quot;&gt; &lt;code&gt;SerializedLambda&lt;/code&gt; &lt;/a&gt;。所述 &lt;code&gt;caller&lt;/code&gt; 类必须具有适当的 &lt;code&gt;$deserializeLambda$&lt;/code&gt; 方法，如描述&lt;a href=&quot;serializedlambda&quot;&gt; &lt;code&gt;SerializedLambda&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c646c0ac257bca0396e71fe9d4cc99c62c09c803" translate="yes" xml:space="preserve">
          <source>When JNDI constructs an initial context, the context's environment is initialized with properties defined in the environment parameter passed to the constructor, the system properties, and the application resource files. See &lt;a href=&quot;initialcontext#ENVIRONMENT&quot;&gt;&lt;code&gt;InitialContext&lt;/code&gt;&lt;/a&gt; for details. This initial environment is then inherited by other context instances.</source>
          <target state="translated">当JNDI构造初始上下文时，将使用在传递给构造函数的环境参数，系统属性和应用程序资源文件中定义的属性来初始化上下文的环境。有关详细信息，请参见&lt;a href=&quot;initialcontext#ENVIRONMENT&quot;&gt; &lt;code&gt;InitialContext&lt;/code&gt; &lt;/a&gt;。然后，其他上下文实例将继承此初始环境。</target>
        </trans-unit>
        <trans-unit id="78166e3e3d24c054685e7318d257481464f62c87" translate="yes" xml:space="preserve">
          <source>When JNDI constructs an initial context, the context's environment is initialized with properties defined in the environment parameter passed to the constructor, the system properties, the applet parameters, and the application resource files. See &lt;a href=&quot;initialcontext#ENVIRONMENT&quot;&gt;&lt;code&gt;InitialContext&lt;/code&gt;&lt;/a&gt; for details. This initial environment is then inherited by other context instances.</source>
          <target state="translated">当JNDI构造初始上下文时，将使用在传递给构造函数的环境参数，系统属性，applet参数和应用程序资源文件中定义的属性来初始化上下文的环境。有关详细信息，请参见&lt;a href=&quot;initialcontext#ENVIRONMENT&quot;&gt; &lt;code&gt;InitialContext&lt;/code&gt; &lt;/a&gt;。然后，其他上下文实例将继承此初始环境。</target>
        </trans-unit>
        <trans-unit id="bcf229951ee0f52a0b20411c8b8db39b24c97b2e" translate="yes" xml:space="preserve">
          <source>When Java Sound is used to handle system exclusive data that is being received using MIDI wire protocol, it should place the data in one or more &lt;code&gt;SysexMessages&lt;/code&gt;. In this case, the length of the system exclusive data is not known in advance; the end of the system exclusive data is marked by an end-of-exclusive flag (0xF7) in the MIDI wire byte stream.</source>
          <target state="translated">当使用Java Sound处理通过MIDI有线协议接收的系统专有数据时，应将数据放在一个或多个 &lt;code&gt;SysexMessages&lt;/code&gt; 中。在这种情况下，系统专有数据的长度是未知的。系统排他数据的结尾在MIDI线字节流中由排他结束标志（0xF7）标记。</target>
        </trans-unit>
        <trans-unit id="3dab1f00d125a2ba1bd6dc4a77821fdb53b85de1" translate="yes" xml:space="preserve">
          <source>When LoginContext uses a caller-specified Configuration, the caller does not require any createLoginContext AuthPermission. The LoginContext saves the &lt;code&gt;AccessControlContext&lt;/code&gt; for the caller, and invokes the configured modules from within an &lt;code&gt;AccessController.doPrivileged&lt;/code&gt; call constrained by that context. This means the caller context (stored when the LoginContext was created) must have sufficient permissions to perform any security-sensitive tasks that the modules may perform.</source>
          <target state="translated">当LoginContext使用调用方指定的配置时，调用方不需要任何createLoginContext AuthPermission。 LoginContext保存调用方的 &lt;code&gt;AccessControlContext&lt;/code&gt; ，并从受该上下文约束的 &lt;code&gt;AccessController.doPrivileged&lt;/code&gt; 调用中调用配置的模块。这意味着调用者上下文（在创建LoginContext时存储）必须具有足够的权限才能执行模块可能执行的任何对安全性敏感的任务。</target>
        </trans-unit>
        <trans-unit id="cb8e6ccdc860924e083cd3b27c25e020271479ff" translate="yes" xml:space="preserve">
          <source>When LoginContext uses the installed Configuration, the caller requires the createLoginContext.&lt;em&gt;name&lt;/em&gt; and possibly createLoginContext.other AuthPermissions. Furthermore, the LoginContext will invoke configured modules from within an &lt;code&gt;AccessController.doPrivileged&lt;/code&gt; call so that modules that perform security-sensitive tasks (such as connecting to remote hosts, and updating the Subject) will require the respective permissions, but the callers of the LoginContext will not require those permissions.</source>
          <target state="translated">当LoginContext使用已安装的Configuration时，调用者需要createLoginContext。&lt;em&gt;名称&lt;/em&gt;以及createLoginContext.other AuthPermissions。此外，LoginContext将在 &lt;code&gt;AccessController.doPrivileged&lt;/code&gt; 调用中调用已配置的模块，以便执行对安全敏感的任务（例如，连接到远程主机和更新Subject）的模块将需要各自的权限，但是LoginContext的调用者将需要不需要这些权限。</target>
        </trans-unit>
        <trans-unit id="b505aae2a5e2bff9bbd6708f806b82cbadb154a8" translate="yes" xml:space="preserve">
          <source>When W3C XML Schema validation is being performed, in the case where an element has a union type, the &lt;a href=&quot;../../../org/w3c/dom/typeinfo&quot;&gt;&lt;code&gt;TypeInfo&lt;/code&gt;&lt;/a&gt; returned by a call to &lt;code&gt;getElementTypeInfo()&lt;/code&gt; from the startElement event will be the union type. The &lt;code&gt;TypeInfo&lt;/code&gt; returned by a call from the endElement event will be the actual member type used to validate the element.</source>
          <target state="translated">当执行W3C XML Schema验证时，如果元素具有联合类型，则从startElement事件调用 &lt;code&gt;getElementTypeInfo()&lt;/code&gt; 返回的&lt;a href=&quot;../../../org/w3c/dom/typeinfo&quot;&gt; &lt;code&gt;TypeInfo&lt;/code&gt; &lt;/a&gt;将是联合类型。从endElement事件的调用返回的 &lt;code&gt;TypeInfo&lt;/code&gt; 将是用于验证元素的实际成员类型。</target>
        </trans-unit>
        <trans-unit id="0a7f33f58f023f24e3769c354575ea8bcc59e8c4" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;../../../../../../java.base/java/lang/securitymanager&quot;&gt;&lt;code&gt;SecurityManager&lt;/code&gt;&lt;/a&gt; is active then an application that creates a &lt;a href=&quot;../../../../../../java.base/javax/security/auth/login/logincontext&quot;&gt;&lt;code&gt;LoginContext&lt;/code&gt;&lt;/a&gt; and uses a &lt;a href=&quot;../../../../../../java.base/javax/security/auth/spi/loginmodule&quot;&gt;&lt;code&gt;LoginModule&lt;/code&gt;&lt;/a&gt; must be granted certain permissions.</source>
          <target state="translated">当&lt;a href=&quot;../../../../../../java.base/java/lang/securitymanager&quot;&gt; &lt;code&gt;SecurityManager&lt;/code&gt; &lt;/a&gt;处于活动状态时，必须授予创建&lt;a href=&quot;../../../../../../java.base/javax/security/auth/login/logincontext&quot;&gt; &lt;code&gt;LoginContext&lt;/code&gt; &lt;/a&gt;并使用&lt;a href=&quot;../../../../../../java.base/javax/security/auth/spi/loginmodule&quot;&gt; &lt;code&gt;LoginModule&lt;/code&gt; &lt;/a&gt;的应用程序某些权限。</target>
        </trans-unit>
        <trans-unit id="9de406a5c3e84979aef9525dcc81e5d0b82d4a27" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;../../../../../java.base/java/lang/securitymanager&quot;&gt;&lt;code&gt;SecurityManager&lt;/code&gt;&lt;/a&gt; set, this is the permission which will be checked when code invokes &lt;a href=&quot;virtualmachine#attach(java.lang.String)&quot;&gt;&lt;code&gt;VirtualMachine.attach&lt;/code&gt;&lt;/a&gt; to attach to a target virtual machine.</source>
          <target state="translated">当&lt;a href=&quot;../../../../../java.base/java/lang/securitymanager&quot;&gt; &lt;code&gt;SecurityManager&lt;/code&gt; &lt;/a&gt;组，这是其将被检查当代码调用权限&lt;a href=&quot;virtualmachine#attach(java.lang.String)&quot;&gt; &lt;code&gt;VirtualMachine.attach&lt;/code&gt; &lt;/a&gt;附着到目标虚拟机。</target>
        </trans-unit>
        <trans-unit id="1add9c214b49be99fd432c2bc93ff6cef29c4381" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;../../../../../java.base/java/lang/securitymanager&quot;&gt;&lt;code&gt;SecurityManager&lt;/code&gt;&lt;/a&gt; set, this is the permission which will be checked when code invokes &lt;a href=&quot;virtualmachine#attach(java.lang.String)&quot;&gt;&lt;code&gt;VirtualMachine.attach&lt;/code&gt;&lt;/a&gt; to attach to a target virtual machine. This permission is also checked when an &lt;a href=&quot;spi/attachprovider&quot;&gt;&lt;code&gt;AttachProvider&lt;/code&gt;&lt;/a&gt; is created.</source>
          <target state="translated">当&lt;a href=&quot;../../../../../java.base/java/lang/securitymanager&quot;&gt; &lt;code&gt;SecurityManager&lt;/code&gt; &lt;/a&gt;组，这是其将被检查当代码调用权限&lt;a href=&quot;virtualmachine#attach(java.lang.String)&quot;&gt; &lt;code&gt;VirtualMachine.attach&lt;/code&gt; &lt;/a&gt;附着到目标虚拟机。创建&lt;a href=&quot;spi/attachprovider&quot;&gt; &lt;code&gt;AttachProvider&lt;/code&gt; &lt;/a&gt;时也会检查此权限。</target>
        </trans-unit>
        <trans-unit id="815b4cfc283610afe0ea69050a522abe02ee7ab9" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;../../../org/xml/sax/contenthandler&quot;&gt;&lt;code&gt;ContentHandler&lt;/code&gt;&lt;/a&gt; is specified, a &lt;a href=&quot;validatorhandler&quot;&gt;&lt;code&gt;ValidatorHandler&lt;/code&gt;&lt;/a&gt; will work as a filter and basically copy the incoming events to the specified &lt;a href=&quot;../../../org/xml/sax/contenthandler&quot;&gt;&lt;code&gt;ContentHandler&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">当&lt;a href=&quot;../../../org/xml/sax/contenthandler&quot;&gt; &lt;code&gt;ContentHandler&lt;/code&gt; 的&lt;/a&gt;规定是，一&lt;a href=&quot;validatorhandler&quot;&gt; &lt;code&gt;ValidatorHandler&lt;/code&gt; &lt;/a&gt;将作为一个过滤器，基本上复制输入事件到指定&lt;a href=&quot;../../../org/xml/sax/contenthandler&quot;&gt; &lt;code&gt;ContentHandler&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ed0149faee2af012851081107e6df3815ec1f855" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;../validation/schema&quot;&gt;&lt;code&gt;Schema&lt;/code&gt;&lt;/a&gt; is non-null, a parser will use a validator created from it to validate documents before it passes information down to the application.</source>
          <target state="translated">当&lt;a href=&quot;../validation/schema&quot;&gt; &lt;code&gt;Schema&lt;/code&gt; &lt;/a&gt;为非null时，解析器将使用从其创建的验证器来验证文档，然后再将信息传递给应用程序。</target>
        </trans-unit>
        <trans-unit id="27147dcbeed5c3bf2e29101bef7813b5d5587eaf" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;beanslinker&quot;&gt;&lt;code&gt;BeansLinker&lt;/code&gt;&lt;/a&gt; is configured without a missing member handler factory, or the factory returns &lt;code&gt;null&lt;/code&gt; for a particular handler creation invocation, the default behavior is used. The default behavior is to return &lt;code&gt;null&lt;/code&gt; from &lt;a href=&quot;../linker/guardingdynamiclinker#getGuardedInvocation(jdk.dynalink.linker.LinkRequest,jdk.dynalink.linker.LinkerServices)&quot;&gt;&lt;code&gt;GuardingDynamicLinker.getGuardedInvocation(LinkRequest, LinkerServices)&lt;/code&gt;&lt;/a&gt; when it can be determined at link time that the linked operation will never address an existing member. This lets the &lt;code&gt;DynamicLinker&lt;/code&gt; attempt the next linker if there is one, or ultimately fail the link request with &lt;a href=&quot;../nosuchdynamicmethodexception&quot;&gt;&lt;code&gt;NoSuchDynamicMethodException&lt;/code&gt;&lt;/a&gt;. For other cases (typically all unnamed member operations as well as most named operations on collection elements) &lt;code&gt;BeansLinker&lt;/code&gt; will produce a conditional linkage that will return &lt;code&gt;null&lt;/code&gt; when invoked at runtime with a name that does not match any member for getters and silently ignore the passed values for setters.</source>
          <target state="translated">当配置&lt;a href=&quot;beanslinker&quot;&gt; &lt;code&gt;BeansLinker&lt;/code&gt; 时&lt;/a&gt;没有缺少成员处理程序工厂，或者工厂为特定的处理程序创建调用返回 &lt;code&gt;null&lt;/code&gt; 时，将使用默认行为。默认行为是&lt;a href=&quot;../linker/guardingdynamiclinker#getGuardedInvocation(jdk.dynalink.linker.LinkRequest,jdk.dynalink.linker.LinkerServices)&quot;&gt; &lt;code&gt;GuardingDynamicLinker.getGuardedInvocation(LinkRequest, LinkerServices)&lt;/code&gt; &lt;/a&gt;当可以在链接时确定链接操作将永远不会寻址现有成员时，从GuardingDynamicLinker.getGuardedInvocation（LinkRequest，LinkerServices）返回 &lt;code&gt;null&lt;/code&gt; 。这使 &lt;code&gt;DynamicLinker&lt;/code&gt; 尝试下一个链接器（如果存在），或者最终导致链接请求失败，并带有&lt;a href=&quot;../nosuchdynamicmethodexception&quot;&gt; &lt;code&gt;NoSuchDynamicMethodException&lt;/code&gt; &lt;/a&gt;。对于其他情况（通常是所有未命名的成员操作以及集合元素上的大多数已命名操作）， &lt;code&gt;BeansLinker&lt;/code&gt; 将产生一个条件链接，该条件链接在运行时以与getter的任何成员都不匹配的名称调用时将返回 &lt;code&gt;null&lt;/code&gt; ，并默默忽略为setter传递的值。</target>
        </trans-unit>
        <trans-unit id="0c5f84dadcd17bdac77318bfd9b493ef7c34d713" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;Boolean&lt;/code&gt; return type is requested, &lt;code&gt;Boolean.TRUE&lt;/code&gt; is returned if one or more nodes were selected; otherwise, &lt;code&gt;Boolean.FALSE&lt;/code&gt; is returned.</source>
          <target state="translated">当请求 &lt;code&gt;Boolean&lt;/code&gt; 返回类型时，如果选择了一个或多个节点，则返回 &lt;code&gt;Boolean.TRUE&lt;/code&gt; ；否则，返回Boolean.TRUE。否则，返回 &lt;code&gt;Boolean.FALSE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e2dfe78f2ad4f3813f1c14b93d0ec0c6be233cf4" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;Calendar&lt;/code&gt; is in non-lenient mode, it throws an exception if there is any inconsistency in its calendar fields. For example, a &lt;code&gt;GregorianCalendar&lt;/code&gt; always produces &lt;code&gt;DAY_OF_MONTH&lt;/code&gt; values between 1 and the length of the month. A non-lenient &lt;code&gt;GregorianCalendar&lt;/code&gt; throws an exception upon calculating its time or calendar field values if any out-of-range field value has been set.</source>
          <target state="translated">当 &lt;code&gt;Calendar&lt;/code&gt; 处于非宽松模式时，如果其日历字段中存在任何不一致，它将引发异常。例如，一个 &lt;code&gt;GregorianCalendar&lt;/code&gt; 总是产生介于1和月份长度之间的 &lt;code&gt;DAY_OF_MONTH&lt;/code&gt; 值。如果设置了任何超出范围的值，则非宽松的 &lt;code&gt;GregorianCalendar&lt;/code&gt; 会在计算其时间或日历字段值时引发异常。</target>
        </trans-unit>
        <trans-unit id="42293990f57bc3f88207c3a41721f4ff5a428cf3" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;CompletionStage&lt;/code&gt; returned from &lt;a href=&quot;websocket.listener#onClose(java.net.http.WebSocket,int,java.lang.String)&quot;&gt;&lt;code&gt;Listener.onClose&lt;/code&gt;&lt;/a&gt; completes, the &lt;code&gt;WebSocket&lt;/code&gt; will send a Close message that has the same code the received message has and an empty reason.</source>
          <target state="translated">从&lt;a href=&quot;websocket.listener#onClose(java.net.http.WebSocket,int,java.lang.String)&quot;&gt; &lt;code&gt;Listener.onClose&lt;/code&gt; &lt;/a&gt;返回的 &lt;code&gt;CompletionStage&lt;/code&gt; 完成后， &lt;code&gt;WebSocket&lt;/code&gt; 将发送一个Close消息，该消息具有与接收到的消息相同的代码，并且为空。</target>
        </trans-unit>
        <trans-unit id="a356f25179772d20743b3c684279064beb377fbf" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;DatagramSocket&lt;/code&gt; is created the initial setting of &lt;code&gt;SO_REUSEADDR&lt;/code&gt; is disabled.</source>
          <target state="translated">当 &lt;code&gt;DatagramSocket&lt;/code&gt; 的创建的初始设定 &lt;code&gt;SO_REUSEADDR&lt;/code&gt; 被禁用。</target>
        </trans-unit>
        <trans-unit id="43ae46b786a991e294be5fd4ff96fd7edcdce9c4" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;Descriptor&lt;/code&gt; is used, the fields of interest are these:</source>
          <target state="translated">使用 &lt;code&gt;Descriptor&lt;/code&gt; ，感兴趣的字段为：</target>
        </trans-unit>
        <trans-unit id="8380d9c546aba4d2b7dbbdb71fb24b8c1ed97298" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;DocumentFragment&lt;/code&gt; is inserted into a &lt;code&gt;Document&lt;/code&gt; (or indeed any other &lt;code&gt;Node&lt;/code&gt; that may take children) the children of the &lt;code&gt;DocumentFragment&lt;/code&gt; and not the &lt;code&gt;DocumentFragment&lt;/code&gt; itself are inserted into the &lt;code&gt;Node&lt;/code&gt;. This makes the &lt;code&gt;DocumentFragment&lt;/code&gt; very useful when the user wishes to create nodes that are siblings; the &lt;code&gt;DocumentFragment&lt;/code&gt; acts as the parent of these nodes so that the user can use the standard methods from the &lt;code&gt;Node&lt;/code&gt; interface, such as &lt;code&gt;Node.insertBefore&lt;/code&gt; and &lt;code&gt;Node.appendChild&lt;/code&gt;.</source>
          <target state="translated">当将 &lt;code&gt;DocumentFragment&lt;/code&gt; 插入到 &lt;code&gt;Document&lt;/code&gt; （或实际上可能带孩子的其他任何 &lt;code&gt;Node&lt;/code&gt; ）中时， &lt;code&gt;DocumentFragment&lt;/code&gt; 的孩子而不是 &lt;code&gt;DocumentFragment&lt;/code&gt; 本身被插入 &lt;code&gt;Node&lt;/code&gt; 。当用户希望创建同级节点时，这使 &lt;code&gt;DocumentFragment&lt;/code&gt; 非常有用。所述 &lt;code&gt;DocumentFragment&lt;/code&gt; 充当这些节点的父节点，使得用户可以使用来自标准方法 &lt;code&gt;Node&lt;/code&gt; 接口，诸如 &lt;code&gt;Node.insertBefore&lt;/code&gt; 和 &lt;code&gt;Node.appendChild&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f9b7e8c421f422ce7ad6e056801a9b14403ef2ba" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;JoinRowSet&lt;/code&gt; object is created, it is empty. The first &lt;code&gt;RowSet&lt;/code&gt; object to be added becomes the basis for the &lt;code&gt;JOIN&lt;/code&gt; relationship. Applications must determine which column in each of the &lt;code&gt;RowSet&lt;/code&gt; objects to be added to the &lt;code&gt;JoinRowSet&lt;/code&gt; object should be the match column. All of the &lt;code&gt;RowSet&lt;/code&gt; objects must contain a match column, and the values in each match column must be ones that can be compared to values in the other match columns. The columns do not have to have the same name, though they often do, and they do not have to store the exact same data type as long as the data types can be compared.</source>
          <target state="translated">创建 &lt;code&gt;JoinRowSet&lt;/code&gt; 对象时，该对象为空。要添加的第一个 &lt;code&gt;RowSet&lt;/code&gt; 对象成为 &lt;code&gt;JOIN&lt;/code&gt; 关系的基础。应用程序必须确定要添加到 &lt;code&gt;JoinRowSet&lt;/code&gt; 对象中的每个 &lt;code&gt;RowSet&lt;/code&gt; 对象中的哪一列应为匹配列。所有 &lt;code&gt;RowSet&lt;/code&gt; 对象都必须包含一个匹配列，并且每个匹配列中的值都必须是可以与其他匹配列中的值进行比较的值。尽管这些列经常会使用相同的名称，但它们不必具有相同的名称，并且只要可以比较数据类型，它们就不必存储完全相同的数据类型。</target>
        </trans-unit>
        <trans-unit id="1ecb2985dc99729b931217f288615f118958b74e" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;LookAndFeel&lt;/code&gt; is installed the &lt;code&gt;UIManager&lt;/code&gt; does not check that an entry exists for all ui class ids. As such, random exceptions will occur if the current look and feel has not provided a value for a particular ui class id and an instance of the &lt;code&gt;JComponent&lt;/code&gt; subclass is created.</source>
          <target state="translated">当 &lt;code&gt;LookAndFeel&lt;/code&gt; 都安装了 &lt;code&gt;UIManager&lt;/code&gt; 的不检查一个条目是否存在所有ui类id。这样，如果当前外观未提供特定ui类ID的值，并且创建了 &lt;code&gt;JComponent&lt;/code&gt; 子类的实例，则将发生随机异常。</target>
        </trans-unit>
        <trans-unit id="4edebb78a9ed8786cce9617749fe858e6dcd6cf1" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;Lookup&lt;/code&gt; teleports from a class in one nest to another nest, &lt;code&gt;PRIVATE&lt;/code&gt; access is dropped. When a &lt;code&gt;Lookup&lt;/code&gt; teleports from a class in one package to another package, &lt;code&gt;PACKAGE&lt;/code&gt; access is dropped. When a &lt;code&gt;Lookup&lt;/code&gt; teleports from a class in one module to another module, &lt;code&gt;MODULE&lt;/code&gt; access is dropped. Teleporting across modules drops the ability to access non-exported classes in both the module of the new lookup class and the module of the old lookup class and the resulting &lt;code&gt;Lookup&lt;/code&gt; remains only &lt;code&gt;PUBLIC&lt;/code&gt; access. A &lt;code&gt;Lookup&lt;/code&gt; can teleport back and forth to a class in the module of the lookup class and the module of the previous class lookup. Teleporting across modules can only decrease access but cannot increase it. Teleporting to some third module drops all accesses.</source>
          <target state="translated">当 &lt;code&gt;Lookup&lt;/code&gt; 从一个嵌套中的类传送到另一个嵌套时，将 &lt;code&gt;PRIVATE&lt;/code&gt; 访问。当 &lt;code&gt;Lookup&lt;/code&gt; 从一个程序包中的一个类传送到另一个程序包时， &lt;code&gt;PACKAGE&lt;/code&gt; 访问将被丢弃。当 &lt;code&gt;Lookup&lt;/code&gt; 从一个模块中的一个类传送到另一个模块时， &lt;code&gt;MODULE&lt;/code&gt; 访问将被丢弃。跨模块传送将使您无法访问新查找类的模块和旧查找类的模块中的非导出类，并且生成的 &lt;code&gt;Lookup&lt;/code&gt; 仅保留 &lt;code&gt;PUBLIC&lt;/code&gt; 访问。一个 &lt;code&gt;Lookup&lt;/code&gt; 可以在查找类的模块和上一个类查找的模块中来回传送到一个类。跨模块传送只能减少访问，而不能增加访问。传送到第三个模块会丢弃所有访问权限。</target>
        </trans-unit>
        <trans-unit id="db057955ab30883a5287d3d1d0441c5297d96c2f" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;MathContext&lt;/code&gt; object is supplied with a precision setting of 0 (for example, &lt;a href=&quot;mathcontext#UNLIMITED&quot;&gt;&lt;code&gt;MathContext.UNLIMITED&lt;/code&gt;&lt;/a&gt;), arithmetic operations are exact, as are the arithmetic methods which take no &lt;code&gt;MathContext&lt;/code&gt; object. (This is the only behavior that was supported in releases prior to 5.) As a corollary of computing the exact result, the rounding mode setting of a &lt;code&gt;MathContext&lt;/code&gt; object with a precision setting of 0 is not used and thus irrelevant. In the case of divide, the exact quotient could have an infinitely long decimal expansion; for example, 1 divided by 3. If the quotient has a nonterminating decimal expansion and the operation is specified to return an exact result, an &lt;code&gt;ArithmeticException&lt;/code&gt; is thrown. Otherwise, the exact result of the division is returned, as done for other operations.</source>
          <target state="translated">为 &lt;code&gt;MathContext&lt;/code&gt; 对象提供的精度设置为0（例如&lt;a href=&quot;mathcontext#UNLIMITED&quot;&gt; &lt;code&gt;MathContext.UNLIMITED&lt;/code&gt; &lt;/a&gt;）时，算术运算是精确的，不采用 &lt;code&gt;MathContext&lt;/code&gt; 对象的算术方法也是如此。 （这是5之前的版本中支持的唯一行为。）作为计算精确结果的必然结果，未使用精度设置为0 的 &lt;code&gt;MathContext&lt;/code&gt; 对象的舍入模式设置，因此不相关。在除法的情况下，精确的商可能具有无限长的十进制扩展；例如，1除以3。如果商具有一个无终止的十进制扩展数，并且指定了该操作以返回精确的结果，则为 &lt;code&gt;ArithmeticException&lt;/code&gt; 被抛出。否则，将返回除法的精确结果，就像其他操作一样。</target>
        </trans-unit>
        <trans-unit id="0cea0471bcac1fec9656ca87e5e77807a3aadf7c" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;Node&lt;/code&gt; is copied using the &lt;code&gt;cloneNode&lt;/code&gt; method the &lt;code&gt;EventListener&lt;/code&gt;s attached to the source &lt;code&gt;Node&lt;/code&gt; are not attached to the copied &lt;code&gt;Node&lt;/code&gt;. If the user wishes the same &lt;code&gt;EventListener&lt;/code&gt;s to be added to the newly created copy the user must add them manually.</source>
          <target state="translated">当一个 &lt;code&gt;Node&lt;/code&gt; 被使用复制的 &lt;code&gt;cloneNode&lt;/code&gt; 方法的 &lt;code&gt;EventListener&lt;/code&gt; 小号连接到源 &lt;code&gt;Node&lt;/code&gt; 不附着于复制的 &lt;code&gt;Node&lt;/code&gt; 。如果用户希望将相同的 &lt;code&gt;EventListener&lt;/code&gt; 添加到新创建的副本中，则用户必须手动添加它们。</target>
        </trans-unit>
        <trans-unit id="8c8fb24cbf878544c9fafb9bba4f04c53ebcb063" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;PKIXParameters&lt;/code&gt; object is created, this flag is set to true. This setting reflects the most common (and simplest) strategy for processing policy qualifiers. Applications that want to use a more sophisticated policy must set this flag to false.</source>
          <target state="translated">当一个 &lt;code&gt;PKIXParameters&lt;/code&gt; 中创建对象，此标志设置为true。此设置反映了处理策略限定符的最常见（也是最简单）的策略。想要使用更复杂策略的应用程序必须将此标志设置为false。</target>
        </trans-unit>
        <trans-unit id="1fecae07ed08389b98c0a767668b060b64f63995" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;PKIXParameters&lt;/code&gt; object is created, this flag is set to true. This setting reflects the most common strategy for checking revocation, since each service provider must support revocation checking to be PKIX compliant. Sophisticated applications should set this flag to false when it is not practical to use a PKIX service provider's default revocation checking mechanism or when an alternative revocation checking mechanism is to be substituted (by also calling the &lt;a href=&quot;#addCertPathChecker(java.security.cert.PKIXCertPathChecker)&quot;&gt;&lt;code&gt;addCertPathChecker&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#setCertPathCheckers(java.util.List)&quot;&gt;&lt;code&gt;setCertPathCheckers&lt;/code&gt;&lt;/a&gt; methods).</source>
          <target state="translated">当一个 &lt;code&gt;PKIXParameters&lt;/code&gt; 中创建对象，此标志设置为true。此设置反映了检查吊销的最常用策略，因为每个服务提供商都必须支持吊销检查才能与PKIX兼容。如果不实际使用PKIX服务提供者的默认吊销检查机制，或者要替代替代吊销检查机制（也通过调用&lt;a href=&quot;#addCertPathChecker(java.security.cert.PKIXCertPathChecker)&quot;&gt; &lt;code&gt;addCertPathChecker&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#setCertPathCheckers(java.util.List)&quot;&gt; &lt;code&gt;setCertPathCheckers&lt;/code&gt; &lt;/a&gt;方法），则复杂的应用程序应将此标志设置为false 。</target>
        </trans-unit>
        <trans-unit id="e2e645d09fe7ffd9051e432a2e16d92d9eb058b1" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;PKIXParameters&lt;/code&gt; object is created, this flag is set to true. This setting reflects the most common strategy for checking revocation, since each service provider must support revocation checking to be PKIX compliant. Sophisticated applications should set this flag to false when it is not practical to use a PKIX service provider's default revocation checking mechanism or when an alternative revocation checking mechanism is to be substituted (by also calling the &lt;a href=&quot;pkixparameters#addCertPathChecker-java.security.cert.PKIXCertPathChecker-&quot;&gt;&lt;code&gt;addCertPathChecker&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;pkixparameters#setCertPathCheckers-java.util.List-&quot;&gt;&lt;code&gt;setCertPathCheckers&lt;/code&gt;&lt;/a&gt; methods).</source>
          <target state="translated">当一个 &lt;code&gt;PKIXParameters&lt;/code&gt; 中创建对象，此标志设置为true。此设置反映了检查吊销的最常用策略，因为每个服务提供商都必须支持吊销检查以符合PKIX。如果不实际使用PKIX服务提供商的默认吊销检查机制，或者要替代替代吊销检查机制（也通过调用&lt;a href=&quot;pkixparameters#addCertPathChecker-java.security.cert.PKIXCertPathChecker-&quot;&gt; &lt;code&gt;addCertPathChecker&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;pkixparameters#setCertPathCheckers-java.util.List-&quot;&gt; &lt;code&gt;setCertPathCheckers&lt;/code&gt; &lt;/a&gt;方法），则复杂的应用程序应将此标志设置为false 。</target>
        </trans-unit>
        <trans-unit id="e1bdbad97a0491d45ccc56940a6c55eb21cbca0d" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;ResourceBundle&lt;/code&gt; was inherited or specified through the &lt;a href=&quot;#setResourceBundle(java.util.ResourceBundle)&quot;&gt;&lt;code&gt;setResourceBundle&lt;/code&gt;&lt;/a&gt; method, then that &lt;code&gt;ResourceBundle&lt;/code&gt; will be used. Otherwise if the logger only has or inherited a resource bundle name, then that resource bundle name will be mapped to a &lt;code&gt;ResourceBundle&lt;/code&gt; object, using the default Locale at the time of logging.</source>
          <target state="translated">当 &lt;code&gt;ResourceBundle&lt;/code&gt; 被继承或指定通过&lt;a href=&quot;#setResourceBundle(java.util.ResourceBundle)&quot;&gt; &lt;code&gt;setResourceBundle&lt;/code&gt; &lt;/a&gt;方法，则该 &lt;code&gt;ResourceBundle&lt;/code&gt; 将被使用。否则，如果记录器仅具有或继承了资源束名称，则该资源束名称将使用记录时的默认Locale映射到 &lt;code&gt;ResourceBundle&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="c511cae88643a751f32e0d10e8a985db173ad353" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;ResourceBundle&lt;/code&gt; was inherited or specified through the &lt;a href=&quot;logger#setResourceBundle-java.util.ResourceBundle-&quot;&gt;&lt;code&gt;setResourceBundle&lt;/code&gt;&lt;/a&gt; method, then that &lt;code&gt;ResourceBundle&lt;/code&gt; will be used. Otherwise if the logger only has or inherited a resource bundle name, then that resource bundle name will be mapped to a &lt;code&gt;ResourceBundle&lt;/code&gt; object, using the default Locale at the time of logging.</source>
          <target state="translated">当 &lt;code&gt;ResourceBundle&lt;/code&gt; 被继承或指定通过&lt;a href=&quot;logger#setResourceBundle-java.util.ResourceBundle-&quot;&gt; &lt;code&gt;setResourceBundle&lt;/code&gt; &lt;/a&gt;方法，则该 &lt;code&gt;ResourceBundle&lt;/code&gt; 将被使用。否则，如果记录器仅具有或继承了资源束名称，则该资源束名称将使用记录时的默认Locale 映射到 &lt;code&gt;ResourceBundle&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="b7a5a177904b96f015c06307ad10fbc63f60c2f8" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;ResultSet&lt;/code&gt; is closed, any &lt;code&gt;ResultSetMetaData&lt;/code&gt; instances that were created by calling the &lt;code&gt;getMetaData&lt;/code&gt; method remain accessible.</source>
          <target state="translated">当 &lt;code&gt;ResultSet&lt;/code&gt; 的是封闭的，任何 &lt;code&gt;ResultSetMetaData&lt;/code&gt; 通过调用中创建的实例 &lt;code&gt;getMetaData&lt;/code&gt; 方法仍然可以访问。</target>
        </trans-unit>
        <trans-unit id="b33e9674235e0636be1c47ce12e9e34568e5c11d" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;Scanner&lt;/code&gt; is closed, it will close its input source if the source implements the &lt;a href=&quot;../io/closeable&quot;&gt;&lt;code&gt;Closeable&lt;/code&gt;&lt;/a&gt; interface.</source>
          <target state="translated">关闭 &lt;code&gt;Scanner&lt;/code&gt; ，如果源实现了&lt;a href=&quot;../io/closeable&quot;&gt; &lt;code&gt;Closeable&lt;/code&gt; &lt;/a&gt;接口，它将关闭其输入源。</target>
        </trans-unit>
        <trans-unit id="af91e23da41d9929e2e507d4f86a71d5504d82ff" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;ServerSocket&lt;/code&gt; is created the initial setting of &lt;a href=&quot;socketoptions#SO_REUSEADDR&quot;&gt;&lt;code&gt;SO_REUSEADDR&lt;/code&gt;&lt;/a&gt; is not defined. Applications can use &lt;a href=&quot;#getReuseAddress()&quot;&gt;&lt;code&gt;getReuseAddress()&lt;/code&gt;&lt;/a&gt; to determine the initial setting of &lt;a href=&quot;socketoptions#SO_REUSEADDR&quot;&gt;&lt;code&gt;SO_REUSEADDR&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">当 &lt;code&gt;ServerSocket&lt;/code&gt; 的创建的初始设定&lt;a href=&quot;socketoptions#SO_REUSEADDR&quot;&gt; &lt;code&gt;SO_REUSEADDR&lt;/code&gt; &lt;/a&gt;没有定义。应用程序可以使用&lt;a href=&quot;#getReuseAddress()&quot;&gt; &lt;code&gt;getReuseAddress()&lt;/code&gt; &lt;/a&gt;来确定&lt;a href=&quot;socketoptions#SO_REUSEADDR&quot;&gt; &lt;code&gt;SO_REUSEADDR&lt;/code&gt; &lt;/a&gt;的初始设置。</target>
        </trans-unit>
        <trans-unit id="d0ea93fe34d0cbcc920144a03e28605555397e46" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;ServerSocket&lt;/code&gt; is created the initial setting of &lt;a href=&quot;socketoptions#SO_REUSEADDR&quot;&gt;&lt;code&gt;SO_REUSEADDR&lt;/code&gt;&lt;/a&gt; is not defined. Applications can use &lt;a href=&quot;serversocket#getReuseAddress--&quot;&gt;&lt;code&gt;getReuseAddress()&lt;/code&gt;&lt;/a&gt; to determine the initial setting of &lt;a href=&quot;socketoptions#SO_REUSEADDR&quot;&gt;&lt;code&gt;SO_REUSEADDR&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">当 &lt;code&gt;ServerSocket&lt;/code&gt; 的创建的初始设定&lt;a href=&quot;socketoptions#SO_REUSEADDR&quot;&gt; &lt;code&gt;SO_REUSEADDR&lt;/code&gt; &lt;/a&gt;没有定义。应用程序可以使用&lt;a href=&quot;serversocket#getReuseAddress--&quot;&gt; &lt;code&gt;getReuseAddress()&lt;/code&gt; &lt;/a&gt;确定&lt;a href=&quot;socketoptions#SO_REUSEADDR&quot;&gt; &lt;code&gt;SO_REUSEADDR&lt;/code&gt; &lt;/a&gt;的初始设置。</target>
        </trans-unit>
        <trans-unit id="f0455bab8e7854f1380ef3d296a0c738fc6d405a" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;Socket&lt;/code&gt; is created the initial setting of &lt;a href=&quot;socketoptions#SO_REUSEADDR&quot;&gt;&lt;code&gt;SO_REUSEADDR&lt;/code&gt;&lt;/a&gt; is disabled.</source>
          <target state="translated">当一个 &lt;code&gt;Socket&lt;/code&gt; 被创建的初始设定&lt;a href=&quot;socketoptions#SO_REUSEADDR&quot;&gt; &lt;code&gt;SO_REUSEADDR&lt;/code&gt; &lt;/a&gt;被禁用。</target>
        </trans-unit>
        <trans-unit id="2fee0877683a4237d7d04165c6386560ed02539f" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;double&lt;/code&gt; must be used as a source for a &lt;code&gt;BigDecimal&lt;/code&gt;, note that this constructor provides an exact conversion; it does not give the same result as converting the &lt;code&gt;double&lt;/code&gt; to a &lt;code&gt;String&lt;/code&gt; using the &lt;a href=&quot;../lang/double#toString(double)&quot;&gt;&lt;code&gt;Double.toString(double)&lt;/code&gt;&lt;/a&gt; method and then using the &lt;a href=&quot;#%3Cinit%3E(java.lang.String)&quot;&gt;&lt;code&gt;BigDecimal(String)&lt;/code&gt;&lt;/a&gt; constructor. To get that result, use the &lt;code&gt;static&lt;/code&gt;&lt;a href=&quot;#valueOf(double)&quot;&gt;&lt;code&gt;valueOf(double)&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">当必须将 &lt;code&gt;double&lt;/code&gt; 用作 &lt;code&gt;BigDecimal&lt;/code&gt; 的源时，请注意，此构造函数提供了精确的转换。它与使用&lt;a href=&quot;../lang/double#toString(double)&quot;&gt; &lt;code&gt;Double.toString(double)&lt;/code&gt; &lt;/a&gt;方法然后使用&lt;a href=&quot;#%3Cinit%3E(java.lang.String)&quot;&gt; &lt;code&gt;BigDecimal(String)&lt;/code&gt; &lt;/a&gt;构造函数将 &lt;code&gt;double&lt;/code&gt; 转换为 &lt;code&gt;String&lt;/code&gt; 的结果不同。要获得该结果，请使用 &lt;code&gt;static&lt;/code&gt; &lt;a href=&quot;#valueOf(double)&quot;&gt; &lt;code&gt;valueOf(double)&lt;/code&gt; &lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="1a039e1d49f70a273c394bc527a427829f3c4985" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;double&lt;/code&gt; must be used as a source for a &lt;code&gt;BigDecimal&lt;/code&gt;, note that this constructor provides an exact conversion; it does not give the same result as converting the &lt;code&gt;double&lt;/code&gt; to a &lt;code&gt;String&lt;/code&gt; using the &lt;a href=&quot;../lang/double#toString-double-&quot;&gt;&lt;code&gt;Double.toString(double)&lt;/code&gt;&lt;/a&gt; method and then using the &lt;a href=&quot;bigdecimal#BigDecimal-java.lang.String-&quot;&gt;&lt;code&gt;BigDecimal(String)&lt;/code&gt;&lt;/a&gt; constructor. To get that result, use the &lt;code&gt;static&lt;/code&gt;&lt;a href=&quot;bigdecimal#valueOf-double-&quot;&gt;&lt;code&gt;valueOf(double)&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">当必须将 &lt;code&gt;double&lt;/code&gt; 用作 &lt;code&gt;BigDecimal&lt;/code&gt; 的源时，请注意，此构造函数提供了精确的转换。它与使用&lt;a href=&quot;../lang/double#toString-double-&quot;&gt; &lt;code&gt;Double.toString(double)&lt;/code&gt; &lt;/a&gt;方法然后使用&lt;a href=&quot;bigdecimal#BigDecimal-java.lang.String-&quot;&gt; &lt;code&gt;BigDecimal(String)&lt;/code&gt; &lt;/a&gt;构造函数将 &lt;code&gt;double&lt;/code&gt; 转换为 &lt;code&gt;String&lt;/code&gt; 的结果不同。要获得该结果，请使用 &lt;code&gt;static&lt;/code&gt; &lt;a href=&quot;bigdecimal#valueOf-double-&quot;&gt; &lt;code&gt;valueOf(double)&lt;/code&gt; &lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="6527806b79e3b486f23af62691038fe376e23d6f" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;java.lang.Error&lt;/code&gt; occurs in the agent it should be caught and re-thrown as a &lt;code&gt;RuntimeErrorException&lt;/code&gt;.</source>
          <target state="translated">当代理中发生 &lt;code&gt;java.lang.Error&lt;/code&gt; 时，应将其捕获并重新抛出为 &lt;code&gt;RuntimeErrorException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0a1362f6628b563d356e949983f03f9000a84379" translate="yes" xml:space="preserve">
          <source>When a BoundedRange model is used with a scrollbar the extent defines the length of the scrollbar knob (aka the &quot;thumb&quot; or &quot;elevator&quot;). The extent usually represents how much of the object being scrolled is visible. When used with a slider, the extent determines how much the value can &quot;jump&quot;, for example when the user presses PgUp or PgDn.</source>
          <target state="translated">当BoundedRange模型与滚动条一起使用时,范围定义了滚动条旋钮的长度(也就是 &quot;拇指 &quot;或 &quot;升降器&quot;)。范围通常表示被滚动的对象有多少是可见的。当与滑块一起使用时,范围决定了数值可以 &quot;跳动 &quot;的程度,例如当用户按下PgUp或PgDn时。</target>
        </trans-unit>
        <trans-unit id="9c90ea452e81ba4569ae99ffac2958ce33a2a19f" translate="yes" xml:space="preserve">
          <source>When a BoundedRange model is used with a scrollbar the value specifies the origin of the scrollbar knob (aka the &quot;thumb&quot; or &quot;elevator&quot;). The value usually represents the origin of the visible part of the object being scrolled.</source>
          <target state="translated">当BoundedRange模型与滚动条一起使用时,该值指定了滚动条旋钮(也就是 &quot;拇指 &quot;或 &quot;升降器&quot;)的原点。该值通常代表被滚动对象的可见部分的原点。</target>
        </trans-unit>
        <trans-unit id="2a2d8c26085a986f69098405e00452247f97fcb7" translate="yes" xml:space="preserve">
          <source>When a Driver class is loaded, it should create an instance of itself and register it with the DriverManager. This means that a user can load and register a driver by calling:</source>
          <target state="translated">当一个Driver类被加载时,它应该创建一个自己的实例并向DriverManager注册。这意味着用户可以通过调用来加载和注册一个驱动程序。</target>
        </trans-unit>
        <trans-unit id="f6bd36f3f0f0ddc2147aa4474e07857940e77421" translate="yes" xml:space="preserve">
          <source>When a HTTP request is received, the appropriate HttpContext (and handler) is located by finding the context whose path is the longest matching prefix of the request URI's path. Paths are matched literally, which means that the strings are compared case sensitively, and with no conversion to or from any encoded forms. For example. Given a HttpServer with the following HttpContexts configured.</source>
          <target state="translated">当接收到一个HTTP请求时,通过找到路径是请求URI路径最长匹配前缀的上下文来找到合适的HttpContext(和处理程序)。路径是按字面意思进行匹配的,这意味着字符串是按大小写进行比较的,没有转换为或从任何编码形式。例如:给定一个HttpServer,它的路径如下 给定一个配置了以下HttpContexts的HttpServer。</target>
        </trans-unit>
        <trans-unit id="ac2232cc133cdbf38b6f9aa25e3da077f2459d69" translate="yes" xml:space="preserve">
          <source>When a JVM is launched in a way that indicates an agent class. In that case an &lt;code&gt;Instrumentation&lt;/code&gt; instance is passed to the &lt;code&gt;premain&lt;/code&gt; method of the agent class.</source>
          <target state="translated">以指示代理类的方式启动JVM时。在这种情况下，将 &lt;code&gt;Instrumentation&lt;/code&gt; 实例传递给代理类的 &lt;code&gt;premain&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="bc6710d50791c1a74ebb5f190790f0fa28c0deca" translate="yes" xml:space="preserve">
          <source>When a JVM provides a mechanism to start agents sometime after the JVM is launched. In that case an &lt;code&gt;Instrumentation&lt;/code&gt; instance is passed to the &lt;code&gt;agentmain&lt;/code&gt; method of the agent code.</source>
          <target state="translated">JVM提供一种在JVM启动后的某个时间启动代理的机制。在这种情况下，将 &lt;code&gt;Instrumentation&lt;/code&gt; 实例传递给代理代码的 &lt;code&gt;agentmain&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="fe6f53c2c934674a6688b208d3ae4e419bb93e41" translate="yes" xml:space="preserve">
          <source>When a Java Virtual Machine starts up, there is usually a single non-daemon thread (which typically calls the method named &lt;code&gt;main&lt;/code&gt; of some designated class). The Java Virtual Machine continues to execute threads until either of the following occurs:</source>
          <target state="translated">当Java虚拟机启动时，通常只有一个非守护程序线程（通常调用某个指定类的名为 &lt;code&gt;main&lt;/code&gt; 的方法）。Java虚拟机将继续执行线程，直到发生以下任何一种情况：</target>
        </trans-unit>
        <trans-unit id="679be8f92ef7e9ad73d5185ae525f63b8b428a90" translate="yes" xml:space="preserve">
          <source>When a Java program runs, a large number of &lt;code&gt;Graphics&lt;/code&gt; objects can be created within a short time frame. Although the finalization process of the garbage collector also disposes of the same system resources, it is preferable to manually free the associated resources by calling this method rather than to rely on a finalization process which may not run to completion for a long period of time.</source>
          <target state="translated">当Java程序运行时，可以在很短的时间内创建大量的 &lt;code&gt;Graphics&lt;/code&gt; 对象。尽管垃圾回收器的完成过程也处理相同的系统资源，但最好通过调用此方法来手动释放关联的资源，而不是依赖可能无法长时间完成的完成过程。</target>
        </trans-unit>
        <trans-unit id="d6028fb5f8e727672bad305b1c6aea8a9507ccc5" translate="yes" xml:space="preserve">
          <source>When a JavaScript object is passed or returned to Java code, it is wrapped in an instance of &lt;code&gt;JSObject&lt;/code&gt;. When a &lt;code&gt;JSObject&lt;/code&gt; instance is passed to the JavaScript engine, it is unwrapped back to its original JavaScript object. The &lt;code&gt;JSObject&lt;/code&gt; class provides a way to invoke JavaScript methods and examine JavaScript properties.</source>
          <target state="translated">当将JavaScript对象传递或返回给Java代码时，它将包装在 &lt;code&gt;JSObject&lt;/code&gt; 实例中。当 &lt;code&gt;JSObject&lt;/code&gt; 实例传递给JavaScript引擎时，它将被解包回其原始JavaScript对象。该 &lt;code&gt;JSObject&lt;/code&gt; 类提供了一个方法来调用JavaScript方法和检查JavaScript的性能。</target>
        </trans-unit>
        <trans-unit id="591e6c34b6ba8d6f3eeb6796c729752f095528e6" translate="yes" xml:space="preserve">
          <source>When a LogRecord is passed into the logging framework it logically belongs to the framework and should no longer be used or updated by the client application.</source>
          <target state="translated">当一个LogRecord被传递到日志框架中时,它在逻辑上属于框架,不应该再被客户端应用程序使用或更新。</target>
        </trans-unit>
        <trans-unit id="760cbf62cac395bf976d73378ca4ebfb39c0855a" translate="yes" xml:space="preserve">
          <source>When a MenuElement receives an event from a KeyListener, it should never process the event directly.</source>
          <target state="translated">当MenuElement从KeyListener接收到一个事件时,它绝不应该直接处理该事件。</target>
        </trans-unit>
        <trans-unit id="f3e01acb00e3633472670e98ba3b82778f6c5de9" translate="yes" xml:space="preserve">
          <source>When a MenuElement receives an event from a KeyListener, it should never process the event directly. Instead all MenuElements should call this method with the event.</source>
          <target state="translated">当一个MenuElement从KeyListener接收到一个事件时,它不应该直接处理该事件。相反,所有的MenuElements都应该调用这个事件的方法。</target>
        </trans-unit>
        <trans-unit id="3a264f4f3f88ff6f8c7f2e0d665633e1f71e9b05" translate="yes" xml:space="preserve">
          <source>When a MenuElement receives an event from a MouseListener, it should never process the event directly.</source>
          <target state="translated">当MenuElement从MouseListener接收到一个事件时,它绝不应该直接处理该事件。</target>
        </trans-unit>
        <trans-unit id="4d11ed3673e1ba2ba2cacee39f6b7d24eb7ebca6" translate="yes" xml:space="preserve">
          <source>When a MenuElement receives an event from a MouseListener, it should never process the event directly. Instead all MenuElements should call this method with the event.</source>
          <target state="translated">当一个MenuElement从MouseListener接收到一个事件时,它不应该直接处理该事件。相反,所有的MenuElements都应该调用该事件的方法。</target>
        </trans-unit>
        <trans-unit id="b38b56c9df7506bfe3ea2ad2db230dd732a913c0" translate="yes" xml:space="preserve">
          <source>When a SAX2 driver is providing these events, all other events must be properly nested within start/end entity events. There is no additional requirement that events from &lt;a href=&quot;declhandler&quot;&gt;&lt;code&gt;DeclHandler&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../dtdhandler&quot;&gt;&lt;code&gt;DTDHandler&lt;/code&gt;&lt;/a&gt; be properly ordered.</source>
          <target state="translated">当SAX2驱动程序提供这些事件时，所有其他事件必须正确地嵌套在开始/结束实体事件中。没有额外的要求，以正确排序来自&lt;a href=&quot;declhandler&quot;&gt; &lt;code&gt;DeclHandler&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../dtdhandler&quot;&gt; &lt;code&gt;DTDHandler&lt;/code&gt; 的&lt;/a&gt;事件。</target>
        </trans-unit>
        <trans-unit id="ca65f59c344aab5c1b12d68027c6ad5c16f0ae24" translate="yes" xml:space="preserve">
          <source>When a Standard MBean is made from the &lt;code&gt;CacheControlMBean&lt;/code&gt;, the usual rules mean that it will have an attribute called &lt;code&gt;CacheSize&lt;/code&gt; of type &lt;code&gt;long&lt;/code&gt;. The &lt;code&gt;@Units&lt;/code&gt; annotation, given the above definition, will ensure that the &lt;a href=&quot;mbeanattributeinfo&quot;&gt;&lt;code&gt;MBeanAttributeInfo&lt;/code&gt;&lt;/a&gt; for this attribute will have a &lt;code&gt;Descriptor&lt;/code&gt; that has a field called &lt;code&gt;units&lt;/code&gt; with corresponding value &lt;code&gt;bytes&lt;/code&gt;.</source>
          <target state="translated">当一个标准的MBean从制造 &lt;code&gt;CacheControlMBean&lt;/code&gt; ，通常的规则意味着它将有一个名为属性 &lt;code&gt;CacheSize&lt;/code&gt; 的类型的 &lt;code&gt;long&lt;/code&gt; 。的 &lt;code&gt;@Units&lt;/code&gt; 注释，考虑到上述定义，将确保&lt;a href=&quot;mbeanattributeinfo&quot;&gt; &lt;code&gt;MBeanAttributeInfo&lt;/code&gt; &lt;/a&gt;该属性将具有 &lt;code&gt;Descriptor&lt;/code&gt; ，其具有所谓的场 &lt;code&gt;units&lt;/code&gt; 与对应值 &lt;code&gt;bytes&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cbdb2811ada49ec4e07a613aa3a52601e1be6d55" translate="yes" xml:space="preserve">
          <source>When a TCP connection is closed the connection may remain in a timeout state for a period of time after the connection is closed (typically known as the &lt;code&gt;TIME_WAIT&lt;/code&gt; state or &lt;code&gt;2MSL&lt;/code&gt; wait state). For applications using a well known socket address or port it may not be possible to bind a socket to the required &lt;code&gt;SocketAddress&lt;/code&gt; if there is a connection in the timeout state involving the socket address or port.</source>
          <target state="translated">当TCP连接关闭时，连接可能会在连接关闭后的一段时间内保持超时状态（通常称为 &lt;code&gt;TIME_WAIT&lt;/code&gt; 状态或 &lt;code&gt;2MSL&lt;/code&gt; 等待状态）。对于使用众所周知的套接字地址或端口的应用程序，如果在超时状态下存在涉及套接字地址或端口的连接，则可能无法将套接字绑定到所需的 &lt;code&gt;SocketAddress&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="35d883e644cee8d8bc00892c83d14b9e68a7c0d4" translate="yes" xml:space="preserve">
          <source>When a TemplatesHandler object is used as a ContentHandler for the parsing of transformation instructions, it creates a Templates object, which the caller can get once the SAX events have been completed.</source>
          <target state="translated">当TemplatesHandler对象作为ContentHandler来解析转换指令时,它会创建一个Templates对象,一旦SAX事件完成,调用者就可以得到这个对象。</target>
        </trans-unit>
        <trans-unit id="a41e85f29028d8394c11ed11faa2b621db688b13" translate="yes" xml:space="preserve">
          <source>When a URL string (a &lt;code&gt;String&lt;/code&gt; of the form &lt;em&gt;scheme_id:rest_of_name&lt;/em&gt;) is passed as a name parameter to any method, a URL context factory for handling that scheme is located and used to resolve the URL. If no such factory is found, the initial context specified by &lt;code&gt;&quot;java.naming.factory.initial&quot;&lt;/code&gt; is used. Similarly, when a &lt;code&gt;CompositeName&lt;/code&gt; object whose first component is a URL string is passed as a name parameter to any method, a URL context factory is located and used to resolve the first name component. See &lt;a href=&quot;spi/namingmanager#getURLContext(java.lang.String,java.util.Hashtable)&quot;&gt;&lt;code&gt;NamingManager.getURLContext()&lt;/code&gt;&lt;/a&gt; for a description of how URL context factories are located.</source>
          <target state="translated">将URL字符串（格式为&lt;em&gt;scheme_id：rest_of_name&lt;/em&gt;的 &lt;code&gt;String&lt;/code&gt; ）作为名称参数传递给任何方法时，将找到用于处理该方案的URL上下文工厂，并将其用于解析URL。如果找不到这样的工厂，则使用由 &lt;code&gt;&quot;java.naming.factory.initial&quot;&lt;/code&gt; 指定的初始上下文。同样，将第一个组成部分是URL字符串的 &lt;code&gt;CompositeName&lt;/code&gt; 对象作为名称参数传递给任何方法时，URL上下文工厂将被定位并用于解析第一个名字部分。有关如何定位URL上下文工厂的描述，请参见&lt;a href=&quot;spi/namingmanager#getURLContext(java.lang.String,java.util.Hashtable)&quot;&gt; &lt;code&gt;NamingManager.getURLContext()&lt;/code&gt; &lt;/a&gt;。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2f10e21dabecf61050cfb5e9bd4dbd4d574ca5d4" translate="yes" xml:space="preserve">
          <source>When a URL string (a &lt;code&gt;String&lt;/code&gt; of the form &lt;em&gt;scheme_id:rest_of_name&lt;/em&gt;) is passed as a name parameter to any method, a URL context factory for handling that scheme is located and used to resolve the URL. If no such factory is found, the initial context specified by &lt;code&gt;&quot;java.naming.factory.initial&quot;&lt;/code&gt; is used. Similarly, when a &lt;code&gt;CompositeName&lt;/code&gt; object whose first component is a URL string is passed as a name parameter to any method, a URL context factory is located and used to resolve the first name component. See &lt;a href=&quot;spi/namingmanager#getURLContext-java.lang.String-java.util.Hashtable-&quot;&gt;&lt;code&gt;&lt;code&gt;NamingManager.getURLContext()&lt;/code&gt;&lt;/code&gt;&lt;/a&gt; for a description of how URL context factories are located.</source>
          <target state="translated">将URL字符串（格式为&lt;em&gt;scheme_id：rest_of_name&lt;/em&gt;的 &lt;code&gt;String&lt;/code&gt; ）作为名称参数传递给任何方法时，将找到用于处理该方案的URL上下文工厂，并将其用于解析URL。如果找不到这样的工厂，则使用由 &lt;code&gt;&quot;java.naming.factory.initial&quot;&lt;/code&gt; 指定的初始上下文。类似地，将第一个组成部分为URL字符串的 &lt;code&gt;CompositeName&lt;/code&gt; 对象作为名称参数传递给任何方法时，URL上下文工厂将被定位并用于解析第一个名字部分。有关如何定位URL上下文工厂的描述，请参见&lt;a href=&quot;spi/namingmanager#getURLContext-java.lang.String-java.util.Hashtable-&quot;&gt; &lt;code&gt;&lt;code&gt;NamingManager.getURLContext()&lt;/code&gt;&lt;/code&gt; &lt;/a&gt;。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="429dc27d49480e2ab4eab569d5adf4cd4c7c135e" translate="yes" xml:space="preserve">
          <source>When a VolatileImage object is created, limited system resources such as video memory (VRAM) may be allocated in order to support the image. When a VolatileImage object is no longer used, it may be garbage-collected and those system resources will be returned, but this process does not happen at guaranteed times. Applications that create many VolatileImage objects (for example, a resizing window may force recreation of its back buffer as the size changes) may run out of optimal system resources for new VolatileImage objects simply because the old objects have not yet been removed from the system. (New VolatileImage objects may still be created, but they may not perform as well as those created in accelerated memory). The flush method may be called at any time to proactively release the resources used by a VolatileImage so that it does not prevent subsequent VolatileImage objects from being accelerated. In this way, applications can have more control over the state of the resources taken up by obsolete VolatileImage objects.</source>
          <target state="translated">当创建一个VolatileImage对象时,可能会分配有限的系统资源,如视频内存(VRAM),以支持图像。当VolatileImage对象不再使用时,可能会对其进行垃圾回收,并将这些系统资源返还,但这个过程不会在保证的时间内发生。创建许多VolatileImage对象的应用程序(例如,一个调整大小的窗口可能会在大小变化时强制重新创建其后置缓冲区)可能会耗尽新的VolatileImage对象的最佳系统资源,这仅仅是因为旧的对象尚未从系统中移除。新的VolatileImage对象仍可能被创建,但它们的性能可能不如在加速内存中创建的对象)。可以随时调用flush方法来主动释放VolatileImage使用的资源,这样就不会妨碍后续VolatileImage对象的加速。通过这种方式,应用程序可以对过时的VolatileImage对象所占用的资源状态有更多的控制。</target>
        </trans-unit>
        <trans-unit id="432971c4a856cab249165ae9a9e506665b76935a" translate="yes" xml:space="preserve">
          <source>When a button is pressed and released, AWT sends an instance of &lt;code&gt;ActionEvent&lt;/code&gt; to the button, by calling &lt;code&gt;processEvent&lt;/code&gt; on the button. The button's &lt;code&gt;processEvent&lt;/code&gt; method receives all events for the button; it passes an action event along by calling its own &lt;code&gt;processActionEvent&lt;/code&gt; method. The latter method passes the action event on to any action listeners that have registered an interest in action events generated by this button.</source>
          <target state="translated">当按下并释放按钮时，AWT通过在按钮上调用 &lt;code&gt;processEvent&lt;/code&gt; 将 &lt;code&gt;ActionEvent&lt;/code&gt; 的实例发送到该按钮。按钮的 &lt;code&gt;processEvent&lt;/code&gt; 方法接收按钮的所有事件；它通过调用自己的 &lt;code&gt;processActionEvent&lt;/code&gt; 方法传递动作事件。后一种方法将动作事件传递给已对此按钮生成的动作事件感兴趣的所有动作侦听器。</target>
        </trans-unit>
        <trans-unit id="2dffdc7e8d88a4030ccf25d0b91c9d8a92081e9c" translate="yes" xml:space="preserve">
          <source>When a call to the &lt;code&gt;next&lt;/code&gt; method returns &lt;code&gt;false&lt;/code&gt;, the cursor is positioned after the last row. Any invocation of a &lt;code&gt;ResultSet&lt;/code&gt; method which requires a current row will result in a &lt;code&gt;SQLException&lt;/code&gt; being thrown. If the result set type is &lt;code&gt;TYPE_FORWARD_ONLY&lt;/code&gt;, it is vendor specified whether their JDBC driver implementation will return &lt;code&gt;false&lt;/code&gt; or throw an &lt;code&gt;SQLException&lt;/code&gt; on a subsequent call to &lt;code&gt;next&lt;/code&gt;.</source>
          <target state="translated">当对 &lt;code&gt;next&lt;/code&gt; 方法的调用返回 &lt;code&gt;false&lt;/code&gt; 时，光标将位于最后一行之后。任何需要当前行的 &lt;code&gt;ResultSet&lt;/code&gt; 方法的调用都会导致 &lt;code&gt;SQLException&lt;/code&gt; 。如果结果集类型为 &lt;code&gt;TYPE_FORWARD_ONLY&lt;/code&gt; ，则由供应商指定其JDBC驱动程序实现是返回 &lt;code&gt;false&lt;/code&gt; 还是在后续对 &lt;code&gt;next&lt;/code&gt; 的调用上引发 &lt;code&gt;SQLException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dcde7f6440e70bd0233d9ec912e740d889f8535e" translate="yes" xml:space="preserve">
          <source>When a call to the &lt;code&gt;previous&lt;/code&gt; method returns &lt;code&gt;false&lt;/code&gt;, the cursor is positioned before the first row. Any invocation of a &lt;code&gt;ResultSet&lt;/code&gt; method which requires a current row will result in a &lt;code&gt;SQLException&lt;/code&gt; being thrown.</source>
          <target state="translated">当对 &lt;code&gt;previous&lt;/code&gt; 方法的调用返回 &lt;code&gt;false&lt;/code&gt; 时，光标将位于第一行之前。任何需要当前行的 &lt;code&gt;ResultSet&lt;/code&gt; 方法的调用都会导致 &lt;code&gt;SQLException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8a83c0113229dd8663248a6bb840a6358d3593d9" translate="yes" xml:space="preserve">
          <source>When a callback method on the specified &lt;a href=&quot;../../../org/xml/sax/contenthandler&quot;&gt;&lt;code&gt;ContentHandler&lt;/code&gt;&lt;/a&gt; throws an exception, the same exception object must be thrown from the &lt;a href=&quot;validatorhandler&quot;&gt;&lt;code&gt;ValidatorHandler&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;../../../org/xml/sax/errorhandler&quot;&gt;&lt;code&gt;ErrorHandler&lt;/code&gt;&lt;/a&gt; should not be notified of such an exception.</source>
          <target state="translated">当指定的&lt;a href=&quot;../../../org/xml/sax/contenthandler&quot;&gt; &lt;code&gt;ContentHandler&lt;/code&gt; &lt;/a&gt;上的回调方法引发异常时，必须从&lt;a href=&quot;validatorhandler&quot;&gt; &lt;code&gt;ValidatorHandler&lt;/code&gt; &lt;/a&gt;引发相同的异常对象。该&lt;a href=&quot;../../../org/xml/sax/errorhandler&quot;&gt; &lt;code&gt;ErrorHandler&lt;/code&gt; &lt;/a&gt;不应该被告知这样的异常。</target>
        </trans-unit>
        <trans-unit id="084f36ff7f74614b43cbed478a2f7b49522f6609" translate="yes" xml:space="preserve">
          <source>When a check box menu item is selected, AWT sends an item event to the item. Since the event is an instance of &lt;code&gt;ItemEvent&lt;/code&gt;, the &lt;code&gt;processEvent&lt;/code&gt; method examines the event and passes it along to &lt;code&gt;processItemEvent&lt;/code&gt;. The latter method redirects the event to any &lt;code&gt;ItemListener&lt;/code&gt; objects that have registered an interest in item events generated by this menu item.</source>
          <target state="translated">选中复选框菜单项后，AWT会将项目事件发送到该项目。由于事件是 &lt;code&gt;ItemEvent&lt;/code&gt; 的实例，因此 &lt;code&gt;processEvent&lt;/code&gt; 方法将检查事件并将其传递给 &lt;code&gt;processItemEvent&lt;/code&gt; 。后一种方法将事件重定向到已对此菜单项生成的项事件感兴趣的任何 &lt;code&gt;ItemListener&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="d040f2e41b4f688b6bbac9b4fc04238f264f901c" translate="yes" xml:space="preserve">
          <source>When a client application is designed to remotely access MXBeans for a running virtual machine whose version is different than the version on which the application is running, it should prepare to catch &lt;a href=&quot;../../../../java.base/java/io/invalidobjectexception&quot;&gt;&lt;code&gt;InvalidObjectException&lt;/code&gt;&lt;/a&gt; which is thrown when an MXBean proxy receives a name of an enum constant which is missing in the enum class loaded in the client application. If thrown, &lt;a href=&quot;../../../../java.base/java/io/invalidobjectexception&quot;&gt;&lt;code&gt;InvalidObjectException&lt;/code&gt;&lt;/a&gt; will be wrappped in &lt;a href=&quot;../../../../java.base/java/lang/reflect/undeclaredthrowableexception&quot;&gt;&lt;code&gt;UndeclaredThrowableException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">当客户端应用程序旨在为正在运行的虚拟机远程访问其版本不同于该应用程序所运行的版本的MXBean时，它应准备捕获&lt;a href=&quot;../../../../java.base/java/io/invalidobjectexception&quot;&gt; &lt;code&gt;InvalidObjectException&lt;/code&gt; &lt;/a&gt;，当MXBean代理接收到一个枚举常量的名称时，抛出该InvalidObjectException客户端应用程序中加载的enum类中缺少。如果抛出&lt;a href=&quot;../../../../java.base/java/io/invalidobjectexception&quot;&gt; &lt;code&gt;InvalidObjectException&lt;/code&gt; ,&lt;/a&gt;则将其包装在&lt;a href=&quot;../../../../java.base/java/lang/reflect/undeclaredthrowableexception&quot;&gt; &lt;code&gt;UndeclaredThrowableException&lt;/code&gt; 中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="902b9d017a9bed0402d7a996f72e41d3f25ab7ec" translate="yes" xml:space="preserve">
          <source>When a client application is designed to remotely access MXBeans for a running virtual machine whose version is different than the version on which the application is running, it should prepare to catch &lt;a href=&quot;../../io/invalidobjectexception&quot;&gt;&lt;code&gt;InvalidObjectException&lt;/code&gt;&lt;/a&gt; which is thrown when an MXBean proxy receives a name of an enum constant which is missing in the enum class loaded in the client application.</source>
          <target state="translated">当客户端应用程序旨在为正在运行的虚拟机（其版本与应用程序所运行的版本不同）远程访问正在运行的虚拟机的MXBean时，它应准备捕获&lt;a href=&quot;../../io/invalidobjectexception&quot;&gt; &lt;code&gt;InvalidObjectException&lt;/code&gt; &lt;/a&gt;，当MXBean代理接收到枚举常量的名称时，抛出该异常客户端应用程序中加载的enum类中缺少。</target>
        </trans-unit>
        <trans-unit id="7205693021c9fb69b57353ca24035c13ecb1c484" translate="yes" xml:space="preserve">
          <source>When a client connects to a server using the JMX Remote API, it is possible that they do not have the same version of the JMX specification. The version of the JMX specification described here is version 1.4. Previous versions were 1.0, 1.1, and 1.2. (There was no 1.3.) The standard JMX Remote API is defined to work with version 1.2 onwards, so in standards-based deployment the only interoperability questions that arise concern version 1.2 onwards.</source>
          <target state="translated">当客户端使用JMX远程API连接到服务器时,有可能他们的JMX规范版本不一样。这里描述的JMX规范的版本是1.4。之前的版本是1.0、1.1和1.2。(没有1.3。)标准的JMX远程API被定义为与1.2以上的版本一起工作,因此在基于标准的部署中,唯一出现的互操作性问题涉及1.2以上的版本。</target>
        </trans-unit>
        <trans-unit id="9ecf260d1def47441248c5413c0dd40de5045eac" translate="yes" xml:space="preserve">
          <source>When a client needs to print a job using the client's desired resolution exactly (no more, no less), the client specifies an instance of class &lt;code&gt;PrinterResolution&lt;/code&gt; as an attribute of the Print Job. This will fail if the Print Job doesn't support that exact resolution, and &lt;code&gt;Fidelity&lt;/code&gt; is set to true.</source>
          <target state="translated">当客户端需要使用客户端的准确分辨率来打印作业时（不多也不少），客户端将指定 &lt;code&gt;PrinterResolution&lt;/code&gt; 类的实例作为&amp;ldquo;打印作业&amp;rdquo;的属性。如果打印作业不支持该精确分辨率，并且 &lt;code&gt;Fidelity&lt;/code&gt; 设置为true ，则此操作将失败。</target>
        </trans-unit>
        <trans-unit id="c8a48941832ba5a4328e80c08b8ffedc13963178" translate="yes" xml:space="preserve">
          <source>When a client needs to print a job using the client's desired resolution exactly (no more, no less), the client specifies an instance of class PrinterResolution as an attribute of the Print Job. This will fail if the Print Job doesn't support that exact resolution, and Fidelity is set to true.</source>
          <target state="translated">当客户端需要使用客户端所需的精确分辨率(不多不少)打印作业时,客户端会指定一个类PrinterResolution的实例作为打印作业的属性。如果打印任务不支持该确切的分辨率,并且Fidelity被设置为true,那么这将失败。</target>
        </trans-unit>
        <trans-unit id="a335dacd4eaf5c3bce2ba4fb08c4775392c61b2f" translate="yes" xml:space="preserve">
          <source>When a client searches looking for a printer that supports the client's desired resolution exactly (no more, no less), the client specifies an instance of class &lt;code&gt;PrinterResolution&lt;/code&gt; indicating the exact resolution the client wants. Only printers supporting that exact resolution will match the search.</source>
          <target state="translated">当客户端搜索正在寻找的打印机正好（不多于，不少于）支持该客户端所需的分辨率时，客户端会指定一个 &lt;code&gt;PrinterResolution&lt;/code&gt; 类的实例，该实例指示客户端所需的确切分辨率。仅支持该精确分辨率的打印机将与搜索匹配。</target>
        </trans-unit>
        <trans-unit id="7de20097d88ff779f4bae860f8ac5bfcc78b886f" translate="yes" xml:space="preserve">
          <source>When a client searches looking for a printer that supports the client's desired resolution exactly (no more, no less), the client specifies an instance of class PrinterResolution indicating the exact resolution the client wants. Only printers supporting that exact resolution will match the search.</source>
          <target state="translated">当客户搜索寻找完全支持客户所需分辨率(不多不少)的打印机时,客户会指定一个类PrinterResolution的实例,表示客户想要的确切分辨率。只有支持该确切分辨率的打印机才会匹配搜索。</target>
        </trans-unit>
        <trans-unit id="af75d22b50227d1fb5318634310fcd020e5b369c" translate="yes" xml:space="preserve">
          <source>When a coded character set is used exclusively with a single character-encoding scheme then the corresponding charset is usually named for the coded character set; otherwise a charset is usually named for the encoding scheme and, possibly, the locale of the coded character sets that it supports. Hence &lt;code&gt;US-ASCII&lt;/code&gt; is both the name of a coded character set and of the charset that encodes it, while &lt;code&gt;EUC-JP&lt;/code&gt; is the name of the charset that encodes the JIS X 0201, JIS X 0208, and JIS X 0212 coded character sets for the Japanese language.</source>
          <target state="translated">当编码字符集仅与单个字符编码方案一起使用时，通常为编码字符集命名相应的字符集；否则，通常为编码方案以及可能支持的编码字符集的语言环境命名一个字符集。因此， &lt;code&gt;US-ASCII&lt;/code&gt; 既是编码字符集的名称，又是对其进行编码的字符集的名称，而 &lt;code&gt;EUC-JP&lt;/code&gt; 是对JIS X 0201，JIS X 0208和JIS X 0212编码字符集进行编码的字符集的名称。日语。</target>
        </trans-unit>
        <trans-unit id="359074a92233f14fabd3c8c60b9f6a18661913d1" translate="yes" xml:space="preserve">
          <source>When a column is adjusted in the UI, adjust the next column the opposite way.</source>
          <target state="translated">当在UI中调整一列时,以相反的方式调整下一列。</target>
        </trans-unit>
        <trans-unit id="abc368889970e1798a7b82782b317df91eb75a92" translate="yes" xml:space="preserve">
          <source>When a concrete &lt;code&gt;DragGestureRecognizer&lt;/code&gt; instance detects a drag initiating gesture on the &lt;code&gt;Component&lt;/code&gt; it is associated with, it fires a &lt;a href=&quot;draggestureevent&quot;&gt;&lt;code&gt;DragGestureEvent&lt;/code&gt;&lt;/a&gt; to the &lt;code&gt;DragGestureListener&lt;/code&gt; registered on its unicast event source for &lt;code&gt;DragGestureListener&lt;/code&gt; events. This &lt;code&gt;DragGestureListener&lt;/code&gt; is responsible for causing the associated &lt;code&gt;DragSource&lt;/code&gt; to start the Drag and Drop operation (if appropriate).</source>
          <target state="translated">当一个具体 &lt;code&gt;DragGestureRecognizer&lt;/code&gt; 实例检测的拖拽在启动动作 &lt;code&gt;Component&lt;/code&gt; 与它相关联，它触发一个&lt;a href=&quot;draggestureevent&quot;&gt; &lt;code&gt;DragGestureEvent&lt;/code&gt; &lt;/a&gt;到 &lt;code&gt;DragGestureListener&lt;/code&gt; 其单播事件源上注册 &lt;code&gt;DragGestureListener&lt;/code&gt; 事件。此 &lt;code&gt;DragGestureListener&lt;/code&gt; 负责使关联的 &lt;code&gt;DragSource&lt;/code&gt; 启动拖放操作（如果适用）。</target>
        </trans-unit>
        <trans-unit id="53280a61faf78dcb3ec848c2e2ddbf8b1f48355d" translate="yes" xml:space="preserve">
          <source>When a constructor or getter method that takes a &lt;code&gt;Map&lt;/code&gt; object is called, the JDBC driver calls the method &lt;code&gt;SQLData.getSQLType&lt;/code&gt; to determine the SQL type of the UDT being custom mapped. The driver creates an instance of &lt;code&gt;SQLInputImpl&lt;/code&gt;, populating it with the attributes of the UDT. The driver then passes the input stream to the method &lt;code&gt;SQLData.readSQL&lt;/code&gt;, which in turn calls the &lt;code&gt;SQLInputImpl&lt;/code&gt; methods to read the attributes from the input stream.</source>
          <target state="translated">调用带有 &lt;code&gt;Map&lt;/code&gt; 对象的构造函数或getter方法时，JDBC驱动程序将调用方法 &lt;code&gt;SQLData.getSQLType&lt;/code&gt; 以确定要自定义映射的UDT的SQL类型。驱动程序创建一个 &lt;code&gt;SQLInputImpl&lt;/code&gt; 实例，并使用UDT的属性填充它。然后，驱动程序将输入流传 &lt;code&gt;SQLData.readSQL&lt;/code&gt; 方法SQLData.readSQL，该方法进而调用 &lt;code&gt;SQLInputImpl&lt;/code&gt; 方法以从输入流中读取属性。</target>
        </trans-unit>
        <trans-unit id="5046ecec5b32705f3cc717979a666d129f7eb365" translate="yes" xml:space="preserve">
          <source>When a context method that may return response controls is invoked, response controls from the previous method invocation are cleared. &lt;code&gt;getResponseControls()&lt;/code&gt; returns all of the response controls generated by LDAP operations used by the context method in the order received from the LDAP server. Invoking &lt;code&gt;getResponseControls()&lt;/code&gt; does not clear the response controls. You can call it many times (and get back the same controls) until the next context method that may return controls is invoked.</source>
          <target state="translated">当调用可能返回响应控件的上下文方法时，将清除先前方法调用中的响应控件。 &lt;code&gt;getResponseControls()&lt;/code&gt; 以从LDAP服务器接收的顺序返回由context方法使用的LDAP操作生成的所有响应控件。调用 &lt;code&gt;getResponseControls()&lt;/code&gt; 不会清除响应控件。您可以多次调用它（并返回相同的控件），直到调用下一个可能返回控件的上下文方法为止。</target>
        </trans-unit>
        <trans-unit id="5d82dfd1d5fb556b3eaa04ee5dbf7ee49fcca1a9" translate="yes" xml:space="preserve">
          <source>When a directory is registered for this event then the &lt;a href=&quot;watchkey&quot;&gt;&lt;code&gt;WatchKey&lt;/code&gt;&lt;/a&gt; is queued when it is observed that an entry in the directory has been modified. The event &lt;a href=&quot;watchevent#count()&quot;&gt;&lt;code&gt;count&lt;/code&gt;&lt;/a&gt; for this event is &lt;code&gt;1&lt;/code&gt; or greater.</source>
          <target state="translated">当为该事件注册目录时，如果观察到目录中的条目已被修改，则&lt;a href=&quot;watchkey&quot;&gt; &lt;code&gt;WatchKey&lt;/code&gt; &lt;/a&gt;将排队。此事件的事件&lt;a href=&quot;watchevent#count()&quot;&gt; &lt;code&gt;count&lt;/code&gt; &lt;/a&gt;为 &lt;code&gt;1&lt;/code&gt; 或更大。</target>
        </trans-unit>
        <trans-unit id="451ee1cb627eed78bb98b62c3c2b734285d519cd" translate="yes" xml:space="preserve">
          <source>When a directory is registered for this event then the &lt;a href=&quot;watchkey&quot;&gt;&lt;code&gt;WatchKey&lt;/code&gt;&lt;/a&gt; is queued when it is observed that an entry in the directory has been modified. The event &lt;a href=&quot;watchevent#count--&quot;&gt;&lt;code&gt;count&lt;/code&gt;&lt;/a&gt; for this event is &lt;code&gt;1&lt;/code&gt; or greater.</source>
          <target state="translated">当为此事件注册目录时，如果观察到目录中的条目已被修改，则&lt;a href=&quot;watchkey&quot;&gt; &lt;code&gt;WatchKey&lt;/code&gt; &lt;/a&gt;将排队。此事件的事件&lt;a href=&quot;watchevent#count--&quot;&gt; &lt;code&gt;count&lt;/code&gt; &lt;/a&gt;为 &lt;code&gt;1&lt;/code&gt; 或更大。</target>
        </trans-unit>
        <trans-unit id="54c77a330dd41951e46e4b4a1e88cbe19100d080" translate="yes" xml:space="preserve">
          <source>When a directory is registered for this event then the &lt;a href=&quot;watchkey&quot;&gt;&lt;code&gt;WatchKey&lt;/code&gt;&lt;/a&gt; is queued when it is observed that an entry is created in the directory or renamed into the directory. The event &lt;a href=&quot;watchevent#count()&quot;&gt;&lt;code&gt;count&lt;/code&gt;&lt;/a&gt; for this event is always &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">当为该事件注册目录时，如果观察到在目录中创建了条目或将其重命名为目录，则&lt;a href=&quot;watchkey&quot;&gt; &lt;code&gt;WatchKey&lt;/code&gt; &lt;/a&gt;将排队。此事件的事件&lt;a href=&quot;watchevent#count()&quot;&gt; &lt;code&gt;count&lt;/code&gt; &lt;/a&gt;始终为 &lt;code&gt;1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="acde6e0c9e549621383ae5222820b57635b1abdb" translate="yes" xml:space="preserve">
          <source>When a directory is registered for this event then the &lt;a href=&quot;watchkey&quot;&gt;&lt;code&gt;WatchKey&lt;/code&gt;&lt;/a&gt; is queued when it is observed that an entry is created in the directory or renamed into the directory. The event &lt;a href=&quot;watchevent#count--&quot;&gt;&lt;code&gt;count&lt;/code&gt;&lt;/a&gt; for this event is always &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">当为该事件注册目录时，如果观察到在目录中创建了条目或将其重命名为目录，则&lt;a href=&quot;watchkey&quot;&gt; &lt;code&gt;WatchKey&lt;/code&gt; &lt;/a&gt;将排队。此事件的事件&lt;a href=&quot;watchevent#count--&quot;&gt; &lt;code&gt;count&lt;/code&gt; &lt;/a&gt;始终为 &lt;code&gt;1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a027f021c399f6f07c85633b797d323c94d4cfee" translate="yes" xml:space="preserve">
          <source>When a directory is registered for this event then the &lt;a href=&quot;watchkey&quot;&gt;&lt;code&gt;WatchKey&lt;/code&gt;&lt;/a&gt; is queued when it is observed that an entry is deleted or renamed out of the directory. The event &lt;a href=&quot;watchevent#count()&quot;&gt;&lt;code&gt;count&lt;/code&gt;&lt;/a&gt; for this event is always &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">当为此事件注册目录时，如果观察到条目&lt;a href=&quot;watchkey&quot;&gt; &lt;code&gt;WatchKey&lt;/code&gt; &lt;/a&gt;目录中删除或重命名，则WatchKey将排队。此事件的事件&lt;a href=&quot;watchevent#count()&quot;&gt; &lt;code&gt;count&lt;/code&gt; &lt;/a&gt;始终为 &lt;code&gt;1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4aa389d8c3635d68f9942230af80f43edbcdf866" translate="yes" xml:space="preserve">
          <source>When a directory is registered for this event then the &lt;a href=&quot;watchkey&quot;&gt;&lt;code&gt;WatchKey&lt;/code&gt;&lt;/a&gt; is queued when it is observed that an entry is deleted or renamed out of the directory. The event &lt;a href=&quot;watchevent#count--&quot;&gt;&lt;code&gt;count&lt;/code&gt;&lt;/a&gt; for this event is always &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">当为此事件注册目录时，如果观察到条目&lt;a href=&quot;watchkey&quot;&gt; &lt;code&gt;WatchKey&lt;/code&gt; &lt;/a&gt;目录中删除或重命名，则WatchKey将排队。此事件的事件&lt;a href=&quot;watchevent#count--&quot;&gt; &lt;code&gt;count&lt;/code&gt; &lt;/a&gt;始终为 &lt;code&gt;1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="134eb2244461f191f7d57bf1761d699a4a619aa5" translate="yes" xml:space="preserve">
          <source>When a document is first made available via the DOM, there is only one &lt;code&gt;Text&lt;/code&gt; node for each block of text. Users may create adjacent &lt;code&gt;Text&lt;/code&gt; nodes that represent the contents of a given element without any intervening markup, but should be aware that there is no way to represent the separations between these nodes in XML or HTML, so they will not (in general) persist between DOM editing sessions. The &lt;code&gt;Node.normalize()&lt;/code&gt; method merges any such adjacent &lt;code&gt;Text&lt;/code&gt; objects into a single node for each block of text.</source>
          <target state="translated">首次通过DOM提供文档时，每个文本块只有一个&amp;ldquo; &lt;code&gt;Text&lt;/code&gt; 节点。用户可以创建相邻的 &lt;code&gt;Text&lt;/code&gt; 节点来表示给定元素的内容，而无需任何中间标记，但应注意，无法用XML或HTML表示这些节点之间的分隔，因此（通常）它们之间不会存在DOM编辑会话。所述 &lt;code&gt;Node.normalize()&lt;/code&gt; 方法合并任何这样的相邻 &lt;code&gt;Text&lt;/code&gt; 对象到用于文本的每个块的单个节点。</target>
        </trans-unit>
        <trans-unit id="b4da85dd003901db71000007023e7612e6748206" translate="yes" xml:space="preserve">
          <source>When a drag gesture occurs, the &lt;code&gt;DragSource&lt;/code&gt;'s startDrag() method shall be invoked in order to cause processing of the user's navigational gestures and delivery of Drag and Drop protocol notifications. A &lt;code&gt;DragSource&lt;/code&gt; shall only permit a single Drag and Drop operation to be current at any one time, and shall reject any further startDrag() requests by throwing an &lt;code&gt;IllegalDnDOperationException&lt;/code&gt; until such time as the extant operation is complete.</source>
          <target state="translated">当发生拖动手势时，应调用 &lt;code&gt;DragSource&lt;/code&gt; 的startDrag（）方法，以处理用户的导航手势并传递拖放协议通知。甲 &lt;code&gt;DragSource&lt;/code&gt; 应只允许一个单一的拖放操作是在任一时刻的电流，并应通过抛出拒绝任何进一步的startDrag（）请求 &lt;code&gt;IllegalDnDOperationException&lt;/code&gt; 来作为现存操作完成，直到。</target>
        </trans-unit>
        <trans-unit id="c6e54cb2e2ced5f516b5c3c711efdeb13fed62ee" translate="yes" xml:space="preserve">
          <source>When a file system is constructed to access the contents of a file as a file system then it is highly implementation specific if the returned URI represents the given path in the file system or it represents a &lt;em&gt;compound&lt;/em&gt; URI that encodes the URI of the enclosing file system. A format for compound URIs is not defined in this release; such a scheme may be added in a future release.</source>
          <target state="translated">当构建文件系统以作为文件系统访问文件的内容时，返回的URI代表文件系统中的给定路径还是代表编码封闭文件系统URI的&lt;em&gt;复合&lt;/em&gt; URI，这在很大程度上取决于实现。。在此版本中未定义复合URI的格式。这样的方案可以在将来的版本中添加。</target>
        </trans-unit>
        <trans-unit id="920d75d308d8cfd3c9e9c09baeeb65ab14384dc3" translate="yes" xml:space="preserve">
          <source>When a file system provides access to a set of &lt;a href=&quot;../filestore&quot;&gt;&lt;code&gt;file-systems&lt;/code&gt;&lt;/a&gt; that are not homogeneous then only some of the file systems may support ACLs. The &lt;a href=&quot;../filestore#supportsFileAttributeView(java.lang.Class)&quot;&gt;&lt;code&gt;supportsFileAttributeView&lt;/code&gt;&lt;/a&gt; method can be used to test if a file system supports ACLs.</source>
          <target state="translated">当文件系统提供访问一组的&lt;a href=&quot;../filestore&quot;&gt; &lt;code&gt;file-systems&lt;/code&gt; &lt;/a&gt;是不是均匀，然后只有一些文件系统可以支持的ACL。所述&lt;a href=&quot;../filestore#supportsFileAttributeView(java.lang.Class)&quot;&gt; &lt;code&gt;supportsFileAttributeView&lt;/code&gt; &lt;/a&gt;如果一个文件系统支持的ACL方法可用于测试。</target>
        </trans-unit>
        <trans-unit id="5f8424e3622daa52db1d5d000f4c2d226449bfeb" translate="yes" xml:space="preserve">
          <source>When a file system provides access to a set of &lt;a href=&quot;../filestore&quot;&gt;&lt;code&gt;file-systems&lt;/code&gt;&lt;/a&gt; that are not homogeneous then only some of the file systems may support ACLs. The &lt;a href=&quot;../filestore#supportsFileAttributeView-java.lang.Class-&quot;&gt;&lt;code&gt;supportsFileAttributeView&lt;/code&gt;&lt;/a&gt; method can be used to test if a file system supports ACLs.</source>
          <target state="translated">当文件系统提供访问一组的&lt;a href=&quot;../filestore&quot;&gt; &lt;code&gt;file-systems&lt;/code&gt; &lt;/a&gt;是不是均匀，然后只有一些文件系统可以支持的ACL。所述&lt;a href=&quot;../filestore#supportsFileAttributeView-java.lang.Class-&quot;&gt; &lt;code&gt;supportsFileAttributeView&lt;/code&gt; &lt;/a&gt;如果一个文件系统支持的ACL方法可用于测试。</target>
        </trans-unit>
        <trans-unit id="2513b009af422c9e2dc954b7cd7076a8523df7e6" translate="yes" xml:space="preserve">
          <source>When a filter is provided, the implementation will call out to the filter as it is constructing the DOM tree structure.</source>
          <target state="translated">当提供了一个过滤器时,在构建DOM树结构时,实现将调用过滤器。</target>
        </trans-unit>
        <trans-unit id="b140beb62778d75da1fe8212e3da055f629c25ea" translate="yes" xml:space="preserve">
          <source>When a filter is provided, the implementation will call out to the filter as it is constructing the DOM tree structure. The filter can choose to remove elements from the document being constructed, or to terminate the parsing early.</source>
          <target state="translated">当提供了一个过滤器时,实现将在构建DOM树结构时调用过滤器。过滤器可以选择从正在构建的文档中删除元素,或者提前终止解析。</target>
        </trans-unit>
        <trans-unit id="563c181caf51bc9ca81a53828adbe47768c2b0e3" translate="yes" xml:space="preserve">
          <source>When a flush occurs on a newly created node, it is made persistent, as are any ancestors (and descendants) that have yet to be made persistent. Note however that any preference value changes in ancestors are</source>
          <target state="translated">当一个新创建的节点发生刷新时,它将被持久化,任何尚未被持久化的祖先(和子孙)也是如此。但是请注意,祖先节点中的任何偏好值变化都是</target>
        </trans-unit>
        <trans-unit id="256f93e3b06f4e8ff9204a92a84cbd4bc52fbd5a" translate="yes" xml:space="preserve">
          <source>When a font is requested in some style, eg &lt;code&gt;Font.BOLD&lt;/code&gt;, for which no exact match is available, then techniques to satisfy the requested rendering may similarly result in glyphs that are wider than the reported maximum.</source>
          <target state="translated">当请求某种样式的字体（例如 &lt;code&gt;Font.BOLD&lt;/code&gt; )时，无法使用完全匹配的字体，则满足请求的呈现的技术可能会类似地产生比所报告的最大值更宽的字形。</target>
        </trans-unit>
        <trans-unit id="1d4a0847838b4b0259eb6a3663209d9fef15018e" translate="yes" xml:space="preserve">
          <source>When a frame is in maximized state the system supplies some defaults bounds. This method allows some or all of those system supplied values to be overridden.</source>
          <target state="translated">当一个帧处于最大化状态时,系统会提供一些默认的边界。本方法允许覆盖部分或全部系统提供的值。</target>
        </trans-unit>
        <trans-unit id="14b01570d43320be8d365211a70fea5fddceea53" translate="yes" xml:space="preserve">
          <source>When a guarded delegator is created from a guarded pair, the pair is wrapped in a new method handle &lt;code&gt;M&lt;/code&gt;, which is permanently associated with the switch point that created it. Each pair consists of a target &lt;code&gt;T&lt;/code&gt; and a fallback &lt;code&gt;F&lt;/code&gt;. While the switch point is valid, invocations to &lt;code&gt;M&lt;/code&gt; are delegated to &lt;code&gt;T&lt;/code&gt;. After it is invalidated, invocations are delegated to &lt;code&gt;F&lt;/code&gt;.</source>
          <target state="translated">从受保护的对创建受保护的委托人时，将对包裹在新的方法句柄 &lt;code&gt;M&lt;/code&gt; 中，该方法将与创建它的交换点永久关联。每对由一个目标的 &lt;code&gt;T&lt;/code&gt; 和回退 &lt;code&gt;F&lt;/code&gt; 。而开关点是有效的，调用到 &lt;code&gt;M&lt;/code&gt; 委托给 &lt;code&gt;T&lt;/code&gt; 。它是无效后，调用委托给 &lt;code&gt;F&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4e4ff9b2bc60835e3eb9b787ed7b76295168a994" translate="yes" xml:space="preserve">
          <source>When a listener instance invokes &lt;code&gt;NamingEvent.getEventContext()&lt;/code&gt;, it must take into account the possibility that other threads will be working with that context concurrently. Likewise, when a listener is registered via &lt;code&gt;addNamingListener()&lt;/code&gt;, the registering thread must take into account the likely possibility that the service provider will later invoke the listeners in newly-created threads. As &lt;code&gt;Context&lt;/code&gt; instances are not guaranteed to be thread-safe in general, all context operations must be synchronized as needed.</source>
          <target state="translated">当侦听器实例调用 &lt;code&gt;NamingEvent.getEventContext()&lt;/code&gt; 时，必须考虑其他线程将同时使用该上下文的可能性。同样，当通过 &lt;code&gt;addNamingListener()&lt;/code&gt; 注册侦听器时，注册线程必须考虑到服务提供者以后将在新创建的线程中调用侦听器的可能性。由于通常不能保证 &lt;code&gt;Context&lt;/code&gt; 实例是线程安全的，因此必须根据需要同步所有上下文操作。</target>
        </trans-unit>
        <trans-unit id="72e45729b02983b1bd6705a44338889bc8ecf80f" translate="yes" xml:space="preserve">
          <source>When a listener is registered, the &lt;a href=&quot;transformerfactory&quot;&gt;&lt;code&gt;TransformerFactory&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;transformer&quot;&gt;&lt;code&gt;Transformer&lt;/code&gt;&lt;/a&gt; must use this interface to pass on all warnings and errors to the listener and let the application decide how to handle them. Note that the &lt;code&gt;TransformerFactory&lt;/code&gt; or &lt;code&gt;Transformer&lt;/code&gt; is not required to continue with the transformation after a call to &lt;a href=&quot;#fatalError(javax.xml.transform.TransformerException)&quot;&gt;&lt;code&gt;fatalError(TransformerException exception)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">注册侦听器后，&lt;a href=&quot;transformerfactory&quot;&gt; &lt;code&gt;TransformerFactory&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;transformer&quot;&gt; &lt;code&gt;Transformer&lt;/code&gt; &lt;/a&gt;必须使用此接口将所有警告和错误传递给侦听器，并让应用程序决定如何处理它们。请注意，在调用&lt;a href=&quot;#fatalError(javax.xml.transform.TransformerException)&quot;&gt; &lt;code&gt;fatalError(TransformerException exception)&lt;/code&gt; &lt;/a&gt;之后，不需要 &lt;code&gt;TransformerFactory&lt;/code&gt; 或 &lt;code&gt;Transformer&lt;/code&gt; 继续进行转换。</target>
        </trans-unit>
        <trans-unit id="bf04634d7ff1db386d9b9db0fb748a111b1c6a04" translate="yes" xml:space="preserve">
          <source>When a listener registers for events with a context, the context might need to do some internal processing in order to collect information required to generate the events. The context, for example, might need to make a request to the server to register interest in changes on the server that will eventually be translated into events. If an exception occurs that prevents information about the events from being collected, the listener will never be notified of the events. When such an exception occurs, a &lt;code&gt;NamingExceptionEvent&lt;/code&gt; is fired to notify the listener. The listener's &lt;code&gt;namingExceptionThrown()&lt;/code&gt; method is invoked, as shown in the sample code above, and the listener is automatically deregistered.</source>
          <target state="translated">当侦听器向上下文注册事件时，上下文可能需要进行一些内部处理才能收集生成事件所需的信息。例如，上下文可能需要向服务器发出请求，以注册对服务器上更改的兴趣，这些更改最终将转换为事件。如果发生异常而阻止收集有关事件的信息，则永远不会将事件通知给侦听器。发生此类异常时，将触发 &lt;code&gt;NamingExceptionEvent&lt;/code&gt; 来通知侦听器。如上面的示例代码所示，调用侦听器的 &lt;code&gt;namingExceptionThrown()&lt;/code&gt; 方法，并自动注销该侦听器。</target>
        </trans-unit>
        <trans-unit id="33b28d28af613b8d16f2122edfdaef0433849cdf" translate="yes" xml:space="preserve">
          <source>When a lookup class in one module &lt;code&gt;M1&lt;/code&gt; accesses a class in another module &lt;code&gt;M2&lt;/code&gt;, extra access checking is performed beyond the access mode bits. A &lt;code&gt;Lookup&lt;/code&gt; with &lt;a href=&quot;#PUBLIC&quot;&gt;&lt;code&gt;PUBLIC&lt;/code&gt;&lt;/a&gt; mode and a lookup class in &lt;code&gt;M1&lt;/code&gt; can access public types in &lt;code&gt;M2&lt;/code&gt; when &lt;code&gt;M2&lt;/code&gt; is readable to &lt;code&gt;M1&lt;/code&gt; and when the type is in a package of &lt;code&gt;M2&lt;/code&gt; that is exported to at least &lt;code&gt;M1&lt;/code&gt;.</source>
          <target state="translated">当一个模块 &lt;code&gt;M1&lt;/code&gt; 中的查找类访问另一个模块 &lt;code&gt;M2&lt;/code&gt; 中的类时，除了访问模式位之外，还会执行额外的访问检查。当 &lt;code&gt;M2&lt;/code&gt; 可以被 &lt;code&gt;M1&lt;/code&gt; 读取并且类型位于至少导出到 &lt;code&gt;M1&lt;/code&gt; 的 &lt;code&gt;M2&lt;/code&gt; 包中时，具有&lt;a href=&quot;#PUBLIC&quot;&gt; &lt;code&gt;PUBLIC&lt;/code&gt; &lt;/a&gt;模式的 &lt;code&gt;Lookup&lt;/code&gt; 和 &lt;code&gt;M1&lt;/code&gt; 中的查找类可以访问 &lt;code&gt;M2&lt;/code&gt; 中的公共类型。</target>
        </trans-unit>
        <trans-unit id="88240763f016e704f50f91eea618ff29da324203" translate="yes" xml:space="preserve">
          <source>When a menu item is selected, AWT sends an action event to the menu item. Since the event is an instance of &lt;code&gt;ActionEvent&lt;/code&gt;, the &lt;code&gt;processEvent&lt;/code&gt; method examines the event and passes it along to &lt;code&gt;processActionEvent&lt;/code&gt;. The latter method redirects the event to any &lt;code&gt;ActionListener&lt;/code&gt; objects that have registered an interest in action events generated by this menu item.</source>
          <target state="translated">选择菜单项后，AWT会将动作事件发送到菜单项。由于事件是 &lt;code&gt;ActionEvent&lt;/code&gt; 的实例，因此 &lt;code&gt;processEvent&lt;/code&gt; 方法将检查事件并将其传递给 &lt;code&gt;processActionEvent&lt;/code&gt; 。后一种方法将事件重定向到已对此菜单项生成的动作事件感兴趣的任何 &lt;code&gt;ActionListener&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="90dd254c09d1c776ecf5c2349e720c462b943059" translate="yes" xml:space="preserve">
          <source>When a method handle is obtained by executing an &lt;code&gt;ldc&lt;/code&gt; instruction of a &lt;code&gt;CONSTANT_MethodHandle&lt;/code&gt; constant, and the target method is marked as a variable arity method (with the modifier bit &lt;code&gt;0x0080&lt;/code&gt;), the method handle will accept multiple arities, as if the method handle constant were created by means of a call to &lt;code&gt;asVarargsCollector&lt;/code&gt;.</source>
          <target state="translated">通过执行 &lt;code&gt;CONSTANT_MethodHandle&lt;/code&gt; 常量的 &lt;code&gt;ldc&lt;/code&gt; 指令获得方法句柄并将目标方法标记为可变 &lt;code&gt;0x0080&lt;/code&gt; 方法（带有修饰符位0x0080）时，该方法句柄将接受多个Arities，就像该方法句柄常量为通过调用 &lt;code&gt;asVarargsCollector&lt;/code&gt; 创建。</target>
        </trans-unit>
        <trans-unit id="dc59d96f42634aad08455afa57812c0140efcb78" translate="yes" xml:space="preserve">
          <source>When a method handle to a virtual method is invoked, the method is always looked up in the receiver (that is, the first argument).</source>
          <target state="translated">当一个虚拟方法的方法句柄被调用时,该方法总是在接收器中被查找(即第一个参数)。</target>
        </trans-unit>
        <trans-unit id="ac3ed4c5aa8581e47e6e1d20592079740b067ad7" translate="yes" xml:space="preserve">
          <source>When a method such as list(), listBindings(), or search() returns a NamingEnumeration, any exceptions encountered are reserved until all results have been returned. At the end of the enumeration, the exception is thrown (by hasMore());</source>
          <target state="translated">当list()、listBindings()或search()等方法返回一个NamingEnumeration时,遇到的任何异常都会被保留,直到所有结果被返回。在枚举结束时,异常会被抛出(通过hasMore())。</target>
        </trans-unit>
        <trans-unit id="c77f58a997936db72fbff2f59c022214ac8f5bcc" translate="yes" xml:space="preserve">
          <source>When a module declares that the provider class is created by a provider factory then this method returns the return type of its public static &quot;&lt;code&gt;provider()&lt;/code&gt;&quot; method.</source>
          <target state="translated">当模块声明提供程序类是由提供程序工厂创建的时，则此方法返回其公共静态&amp;ldquo; &lt;code&gt;provider()&lt;/code&gt; &amp;rdquo;方法的返回类型。</target>
        </trans-unit>
        <trans-unit id="98cbaeab94a8ea21799291ebebb2b9e8ca8b5128" translate="yes" xml:space="preserve">
          <source>When a module is deprecated, the use of that module in &lt;code&gt;
 requires&lt;/code&gt;, but not in &lt;code&gt;exports&lt;/code&gt; or &lt;code&gt;opens&lt;/code&gt; clauses causes a warning to be issued. A module being deprecated does &lt;em&gt;not&lt;/em&gt; cause warnings to be issued for uses of types within the module.</source>
          <target state="translated">当一个模块已过时，使用该模块的 &lt;code&gt; requires&lt;/code&gt; ，而不是在 &lt;code&gt;exports&lt;/code&gt; 或 &lt;code&gt;opens&lt;/code&gt; 条款导致发出警告。不建议使用的模块&lt;em&gt;不会&lt;/em&gt;导致针对模块中使用的类型发出警告。</target>
        </trans-unit>
        <trans-unit id="d555a5a6abfd38f83f82a291e707b2b58a5605e9" translate="yes" xml:space="preserve">
          <source>When a mouse button is clicked, events are generated and sent to the registered &lt;code&gt;MouseListener&lt;/code&gt;s. The state of modal keys can be retrieved using &lt;a href=&quot;inputevent#getModifiers()&quot;&gt;&lt;code&gt;InputEvent.getModifiers()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;inputevent#getModifiersEx()&quot;&gt;&lt;code&gt;InputEvent.getModifiersEx()&lt;/code&gt;&lt;/a&gt;. The button mask returned by &lt;a href=&quot;inputevent#getModifiers()&quot;&gt;&lt;code&gt;InputEvent.getModifiers()&lt;/code&gt;&lt;/a&gt; reflects only the button that changed state, not the current state of all buttons. (Note: Due to overlap in the values of ALT_MASK/BUTTON2_MASK and META_MASK/BUTTON3_MASK, this is not always true for mouse events involving modifier keys). To get the state of all buttons and modifier keys, use &lt;a href=&quot;inputevent#getModifiersEx()&quot;&gt;&lt;code&gt;InputEvent.getModifiersEx()&lt;/code&gt;&lt;/a&gt;. The button which has changed state is returned by &lt;a href=&quot;#getButton()&quot;&gt;&lt;code&gt;getButton()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">单击鼠标按钮时，将生成事件并将其发送到已注册的 &lt;code&gt;MouseListener&lt;/code&gt; 。可以使用&lt;a href=&quot;inputevent#getModifiers()&quot;&gt; &lt;code&gt;InputEvent.getModifiers()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;inputevent#getModifiersEx()&quot;&gt; &lt;code&gt;InputEvent.getModifiersEx()&lt;/code&gt; &lt;/a&gt;来检索模式键的状态。&lt;a href=&quot;inputevent#getModifiers()&quot;&gt; &lt;code&gt;InputEvent.getModifiers()&lt;/code&gt; &lt;/a&gt;返回的按钮掩码仅反映更改状态的按钮，而不反映所有按钮的当前状态。 （注意：由于ALT_MASK / BUTTON2_MASK和META_MASK / BUTTON3_MASK的值重叠，因此对于涉及修饰键的鼠标事件并不总是如此）。要获取所有按钮和修饰键的状态，请使用&lt;a href=&quot;inputevent#getModifiersEx()&quot;&gt; &lt;code&gt;InputEvent.getModifiersEx()&lt;/code&gt; &lt;/a&gt;。状态已更改的按钮由&lt;a href=&quot;#getButton()&quot;&gt; &lt;code&gt;getButton()&lt;/code&gt; &lt;/a&gt;返回。</target>
        </trans-unit>
        <trans-unit id="00112656e542a277ccbb970384f5707477b0e0b9" translate="yes" xml:space="preserve">
          <source>When a new &lt;a href=&quot;schemafactory&quot;&gt;&lt;code&gt;SchemaFactory&lt;/code&gt;&lt;/a&gt; object is created, initially this field is set to null. This field will &lt;em&gt;NOT&lt;/em&gt; be inherited to &lt;a href=&quot;schema&quot;&gt;&lt;code&gt;Schema&lt;/code&gt;&lt;/a&gt;s, &lt;a href=&quot;validator&quot;&gt;&lt;code&gt;Validator&lt;/code&gt;&lt;/a&gt;s, or &lt;a href=&quot;validatorhandler&quot;&gt;&lt;code&gt;ValidatorHandler&lt;/code&gt;&lt;/a&gt;s that are created from this &lt;a href=&quot;schemafactory&quot;&gt;&lt;code&gt;SchemaFactory&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">创建新的&lt;a href=&quot;schemafactory&quot;&gt; &lt;code&gt;SchemaFactory&lt;/code&gt; &lt;/a&gt;对象时，最初将此字段设置为null。此字段&lt;em&gt;不会&lt;/em&gt;继承到从此&lt;a href=&quot;schemafactory&quot;&gt; &lt;code&gt;SchemaFactory&lt;/code&gt; &lt;/a&gt;创建的&lt;a href=&quot;schema&quot;&gt; &lt;code&gt;Schema&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;validator&quot;&gt; &lt;code&gt;Validator&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;validatorhandler&quot;&gt; &lt;code&gt;ValidatorHandler&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3e086a8e7068102271cf7d6fcc1d6a613e3a6593" translate="yes" xml:space="preserve">
          <source>When a new &lt;a href=&quot;validator&quot;&gt;&lt;code&gt;Validator&lt;/code&gt;&lt;/a&gt; object is created, initially this field is set to null.</source>
          <target state="translated">创建新的&lt;a href=&quot;validator&quot;&gt; &lt;code&gt;Validator&lt;/code&gt; &lt;/a&gt;对象时，此字段最初设置为null。</target>
        </trans-unit>
        <trans-unit id="55a52e9d9430d2238010dc383d8d5a916e167cd6" translate="yes" xml:space="preserve">
          <source>When a new &lt;a href=&quot;validatorhandler&quot;&gt;&lt;code&gt;ValidatorHandler&lt;/code&gt;&lt;/a&gt; object is created, initially this field is set to null.</source>
          <target state="translated">创建新的&lt;a href=&quot;validatorhandler&quot;&gt; &lt;code&gt;ValidatorHandler&lt;/code&gt; &lt;/a&gt;对象时，此字段最初设置为null。</target>
        </trans-unit>
        <trans-unit id="f0c78c3d3fddb6c5863a4d4f38ff7afd50aaf75d" translate="yes" xml:space="preserve">
          <source>When a new JConsole window is created for a connection, an instance of each &lt;code&gt;JConsolePlugin&lt;/code&gt; will be created. The &lt;code&gt;JConsoleContext&lt;/code&gt; object is not available at its construction time. JConsole will set the &lt;a href=&quot;jconsolecontext&quot;&gt;&lt;code&gt;JConsoleContext&lt;/code&gt;&lt;/a&gt; object for a plugin after the plugin object is created. It will then call its &lt;a href=&quot;#getTabs()&quot;&gt;&lt;code&gt;getTabs&lt;/code&gt;&lt;/a&gt; method and add the returned tabs to the JConsole window.</source>
          <target state="translated">为连接创建新的JConsole窗口时，将创建每个 &lt;code&gt;JConsolePlugin&lt;/code&gt; 的实例。该 &lt;code&gt;JConsoleContext&lt;/code&gt; 的对象不可在其施工时间。创建插件对象后，JConsole将为插件设置&lt;a href=&quot;jconsolecontext&quot;&gt; &lt;code&gt;JConsoleContext&lt;/code&gt; &lt;/a&gt;对象。然后，它将调用其&lt;a href=&quot;#getTabs()&quot;&gt; &lt;code&gt;getTabs&lt;/code&gt; &lt;/a&gt;方法，并将返回的选项卡添加到JConsole窗口。</target>
        </trans-unit>
        <trans-unit id="a16476348451a202ec7241c549e271abf68b5efa" translate="yes" xml:space="preserve">
          <source>When a new connection is accepted then the resulting &lt;code&gt;
 AsynchronousSocketChannel&lt;/code&gt; will be bound to the same &lt;a href=&quot;asynchronouschannelgroup&quot;&gt;&lt;code&gt;AsynchronousChannelGroup&lt;/code&gt;&lt;/a&gt; as this channel. If the group is &lt;a href=&quot;asynchronouschannelgroup#isShutdown()&quot;&gt;&lt;code&gt;shutdown&lt;/code&gt;&lt;/a&gt; and a connection is accepted, then the connection is closed, and the operation completes with an &lt;code&gt;
 IOException&lt;/code&gt; and cause &lt;a href=&quot;shutdownchannelgroupexception&quot;&gt;&lt;code&gt;ShutdownChannelGroupException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">接受新连接后，生成的 &lt;code&gt; AsynchronousSocketChannel&lt;/code&gt; 将与此通道绑定到相同的&lt;a href=&quot;asynchronouschannelgroup&quot;&gt; &lt;code&gt;AsynchronousChannelGroup&lt;/code&gt; &lt;/a&gt;。如果该组已&lt;a href=&quot;asynchronouschannelgroup#isShutdown()&quot;&gt; &lt;code&gt;shutdown&lt;/code&gt; &lt;/a&gt;并且接受了连接，则该连接将关闭，并且该操作将以 &lt;code&gt; IOException&lt;/code&gt; 结束并导致&lt;a href=&quot;shutdownchannelgroupexception&quot;&gt; &lt;code&gt;ShutdownChannelGroupException&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="eaa5aba63dd9f02bc423da3760cc790334dde37c" translate="yes" xml:space="preserve">
          <source>When a new connection is accepted then the resulting &lt;code&gt;AsynchronousSocketChannel&lt;/code&gt; will be bound to the same &lt;a href=&quot;asynchronouschannelgroup&quot;&gt;&lt;code&gt;AsynchronousChannelGroup&lt;/code&gt;&lt;/a&gt; as this channel. If the group is &lt;a href=&quot;asynchronouschannelgroup#isShutdown--&quot;&gt;&lt;code&gt;shutdown&lt;/code&gt;&lt;/a&gt; and a connection is accepted, then the connection is closed, and the operation completes with an &lt;code&gt;IOException&lt;/code&gt; and cause &lt;a href=&quot;shutdownchannelgroupexception&quot;&gt;&lt;code&gt;ShutdownChannelGroupException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">接受新连接后，生成的 &lt;code&gt;AsynchronousSocketChannel&lt;/code&gt; 将与此通道绑定到相同的&lt;a href=&quot;asynchronouschannelgroup&quot;&gt; &lt;code&gt;AsynchronousChannelGroup&lt;/code&gt; &lt;/a&gt;。如果该组已&lt;a href=&quot;asynchronouschannelgroup#isShutdown--&quot;&gt; &lt;code&gt;shutdown&lt;/code&gt; &lt;/a&gt;并且接受了连接，则该连接将关闭，并且该操作将以 &lt;code&gt;IOException&lt;/code&gt; 结束并导致&lt;a href=&quot;shutdownchannelgroupexception&quot;&gt; &lt;code&gt;ShutdownChannelGroupException&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b6d8a70cca16fc1a092f3e5b3fb7136e528d4e86" translate="yes" xml:space="preserve">
          <source>When a numeric shaper is defined, the text is first processed by the shaper before any other analysis of the text is performed.</source>
          <target state="translated">当定义了数字整形器时,在对文本进行任何其他分析之前,首先由整形器处理文本。</target>
        </trans-unit>
        <trans-unit id="020ef9f20f26ac791311bcdc46b2f2890f6d7b82" translate="yes" xml:space="preserve">
          <source>When a peer sends a</source>
          <target state="translated">当一个对等体发送一个</target>
        </trans-unit>
        <trans-unit id="f20b7bb9a7a0ed971069cd4bd43c35163e0303e3" translate="yes" xml:space="preserve">
          <source>When a printer controls more than one output device, this reason indicates that one or more output devices are stopped.</source>
          <target state="translated">当打印机控制一个以上的输出设备时,该原因表明一个或多个输出设备被停止。</target>
        </trans-unit>
        <trans-unit id="57b0000a9696b1c366c87328582e275d001b7acb" translate="yes" xml:space="preserve">
          <source>When a printer controls more than one output device, this reason indicates that one or more output devices are stopped. If the reason's severity is a report, fewer than half of the output devices are stopped. If the reason's severity is a warning, half or more but fewer than all of the output devices are stopped.</source>
          <target state="translated">当打印机控制一个以上的输出设备时,该原因表明一个或多个输出设备被停止。如果原因的严重性是报告,那么只有不到一半的输出设备被停止。如果原因的严重性为警告,则停止一半或更多的输出设备,但少于所有的输出设备。</target>
        </trans-unit>
        <trans-unit id="ccb21bbf1cfa3412cab733738537427c4a4c474e" translate="yes" xml:space="preserve">
          <source>When a proxy selector is registered, for instance, a subclass of URLConnection class should call the &lt;a href=&quot;#select(java.net.URI)&quot;&gt;&lt;code&gt;select&lt;/code&gt;&lt;/a&gt; method for each URL request so that the proxy selector can decide if a direct, or proxied connection should be used. The &lt;a href=&quot;#select(java.net.URI)&quot;&gt;&lt;code&gt;select&lt;/code&gt;&lt;/a&gt; method returns an iterator over a collection with the preferred connection approach.</source>
          <target state="translated">例如，注册代理选择器后，URLConnection类的子类应为每个URL请求调用&lt;a href=&quot;#select(java.net.URI)&quot;&gt; &lt;code&gt;select&lt;/code&gt; &lt;/a&gt;方法，以便代理选择器可以决定应使用直接连接还是代理连接。该&lt;a href=&quot;#select(java.net.URI)&quot;&gt; &lt;code&gt;select&lt;/code&gt; &lt;/a&gt;方法返回在与所述优选连接方法的集合的迭代器。</target>
        </trans-unit>
        <trans-unit id="48145dbd368db04ca5f1dc84946f81ac044581d7" translate="yes" xml:space="preserve">
          <source>When a proxy selector is registered, for instance, a subclass of URLConnection class should call the &lt;a href=&quot;proxyselector#select-java.net.URI-&quot;&gt;&lt;code&gt;select&lt;/code&gt;&lt;/a&gt; method for each URL request so that the proxy selector can decide if a direct, or proxied connection should be used. The &lt;a href=&quot;proxyselector#select-java.net.URI-&quot;&gt;&lt;code&gt;select&lt;/code&gt;&lt;/a&gt; method returns an iterator over a collection with the preferred connection approach.</source>
          <target state="translated">例如，注册代理选择器后，URLConnection类的子类应为每个URL请求调用&lt;a href=&quot;proxyselector#select-java.net.URI-&quot;&gt; &lt;code&gt;select&lt;/code&gt; &lt;/a&gt;方法，以便代理选择器可以决定应使用直接连接还是代理连接。该&lt;a href=&quot;proxyselector#select-java.net.URI-&quot;&gt; &lt;code&gt;select&lt;/code&gt; &lt;/a&gt;方法返回在与所述优选连接方法的集合的迭代器。</target>
        </trans-unit>
        <trans-unit id="4492abf48ec4645a23e3300769bfe838f92fe80f" translate="yes" xml:space="preserve">
          <source>When a recording is stopped it can't be restarted. If this recording has a destination, data is written to that destination and the recording is closed. After a recording is closed, the data is no longer available.</source>
          <target state="translated">当录音停止后,就不能重新开始。如果该录音有一个目的地,数据就会被写入该目的地,录音就会被关闭。录音被关闭后,数据不再可用。</target>
        </trans-unit>
        <trans-unit id="d0d0a0a75e5df0269d9b48018fdf0251b8588033" translate="yes" xml:space="preserve">
          <source>When a rendering or image manipulation operation produces a color value that must be stored into a destination, it must first convert that color into a form suitable for storing into the destination image or surface. Minimally, the color components must be converted to bit representations and ordered in the correct order or an index into a color lookup table must be chosen before the data can be stored into the destination memory. Without this minimal conversion, the data in the destination would likely represent random, incorrect or possibly even unsupported values. Algorithms to quickly convert the results of rendering operations into the color format of most common destinations are well known and fairly optimal to execute.</source>
          <target state="translated">当渲染或图像处理操作产生一个必须存储到目的地的颜色值时,它必须首先将该颜色转换为适合存储到目的地图像或表面的形式。最低限度地,必须将颜色分量转换为位表示,并以正确的顺序排序,或者在数据可以存储到目标存储器中之前,必须选择一个索引进入颜色查找表。如果没有这种最低限度的转换,目标中的数据很可能代表随机的、不正确的甚至可能是不支持的值。将渲染操作的结果快速转换为大多数常见目的地的颜色格式的算法是众所周知的,而且执行起来相当理想。</target>
        </trans-unit>
        <trans-unit id="7a3bf5e738a9141b4b95997a3f1e19dc1b7157d4" translate="yes" xml:space="preserve">
          <source>When a rowset gets its data from a relational database, it executes a command (a query) that produces a &lt;code&gt;ResultSet&lt;/code&gt; object. This query is the command that is set for the &lt;code&gt;RowSet&lt;/code&gt; object's command property. The rowset populates itself with data by reading the data from the &lt;code&gt;ResultSet&lt;/code&gt; object into itself. If the query contains placeholders for values to be set, the &lt;code&gt;BaseRowSet&lt;/code&gt; setter methods are used to set these values. All setter methods allow these values to be set to &lt;code&gt;null&lt;/code&gt; if required.</source>
          <target state="translated">当行集从关系数据库获取其数据时，它会执行产生 &lt;code&gt;ResultSet&lt;/code&gt; 对象的命令（查询）。此查询是为 &lt;code&gt;RowSet&lt;/code&gt; 对象的command属性设置的命令。通过将 &lt;code&gt;ResultSet&lt;/code&gt; 对象中的数据读取到自身中，行集将使用数据填充自身。如果查询包含要设置的值的占位符，则使用 &lt;code&gt;BaseRowSet&lt;/code&gt; setter方法设置这些值。所有setter方法都允许根据需要将这些值设置为 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="758869419d156f27990d997e0fa9fce2a685beea" translate="yes" xml:space="preserve">
          <source>When a scanner throws an &lt;a href=&quot;inputmismatchexception&quot;&gt;&lt;code&gt;InputMismatchException&lt;/code&gt;&lt;/a&gt;, the scanner will not pass the token that caused the exception, so that it may be retrieved or skipped via some other method.</source>
          <target state="translated">当扫描程序引发&lt;a href=&quot;inputmismatchexception&quot;&gt; &lt;code&gt;InputMismatchException&lt;/code&gt; 时&lt;/a&gt;，扫描程序将不会传递导致异常的令牌，因此可以通过其他方法检索或跳过该令牌。</target>
        </trans-unit>
        <trans-unit id="817af58e7bcbe10748b284737a339517287e3c10" translate="yes" xml:space="preserve">
          <source>When a scroll bar is used to select a range of values, the visible amount is used to represent the range of values that are currently visible. The size of the scroll bar's bubble (also called a thumb or scroll box), usually gives a visual representation of the relationship of the visible amount to the range of the scroll bar. Note that depending on platform, the value of the visible amount property may not be visually indicated by the size of the bubble.</source>
          <target state="translated">当滚动条用于选择数值范围时,可见量用来表示当前可见的数值范围。滚动条的气泡(也称为拇指或滚动框)的大小,通常可以直观地表示可见量与滚动条范围的关系。请注意,根据平台的不同,可见量属性的值可能无法通过气泡的大小直观地表示出来。</target>
        </trans-unit>
        <trans-unit id="a853e62233343e776fbd44333e92601acc2febbe" translate="yes" xml:space="preserve">
          <source>When a security manager is installed and it denies access to a file (or directory), then it is ignored and not included in the stream.</source>
          <target state="translated">当安装了安全管理器,并且它拒绝访问文件(或目录)时,那么它将被忽略,并且不包括在流中。</target>
        </trans-unit>
        <trans-unit id="e74c73e1d683b9fecd0a717afa160e6920257abc" translate="yes" xml:space="preserve">
          <source>When a security manager is installed and it denies access to a file (or directory), then it is ignored and the visitor is not invoked for that file (or directory).</source>
          <target state="translated">当安装了安全管理器,并且它拒绝访问某个文件(或目录)时,那么它就会被忽略,并且不会调用该文件(或目录)的访问者。</target>
        </trans-unit>
        <trans-unit id="61d88ca5288dc5b3be9b25739812ea67777f1b62" translate="yes" xml:space="preserve">
          <source>When a security manager is installed, it is invoked to check access to the each root directory. If denied, the root directory is not returned by the iterator. In the case of the default provider, the &lt;a href=&quot;../../lang/securitymanager#checkRead(java.lang.String)&quot;&gt;&lt;code&gt;SecurityManager.checkRead(String)&lt;/code&gt;&lt;/a&gt; method is invoked to check read access to each root directory. It is system dependent if the permission checks are done when the iterator is obtained or during iteration.</source>
          <target state="translated">安装安全管理器后，将调用它来检查对每个根目录的访问。如果被拒绝，则迭代器不会返回根目录。对于默认提供程序，将调用&lt;a href=&quot;../../lang/securitymanager#checkRead(java.lang.String)&quot;&gt; &lt;code&gt;SecurityManager.checkRead(String)&lt;/code&gt; &lt;/a&gt;方法以检查对每个根目录的读取访问。获取迭代器时或在迭代过程中是否进行了权限检查，这取决于系统。</target>
        </trans-unit>
        <trans-unit id="3b16d1c9ade5f68deff8b6a72ad86abd212f522b" translate="yes" xml:space="preserve">
          <source>When a security manager is installed, it is invoked to check access to the each root directory. If denied, the root directory is not returned by the iterator. In the case of the default provider, the &lt;a href=&quot;../../lang/securitymanager#checkRead-java.lang.String-&quot;&gt;&lt;code&gt;SecurityManager.checkRead(String)&lt;/code&gt;&lt;/a&gt; method is invoked to check read access to each root directory. It is system dependent if the permission checks are done when the iterator is obtained or during iteration.</source>
          <target state="translated">安装安全管理器后，将调用安全管理器以检查对每个根目录的访问。如果被拒绝，则迭代器不会返回根目录。对于默认提供程序，将调用&lt;a href=&quot;../../lang/securitymanager#checkRead-java.lang.String-&quot;&gt; &lt;code&gt;SecurityManager.checkRead(String)&lt;/code&gt; &lt;/a&gt;方法来检查对每个根目录的读取访问。获取迭代器时或在迭代过程中是否进行权限检查取决于系统。</target>
        </trans-unit>
        <trans-unit id="8c6148e86bea201a9f994d578beb5dfb43f4e09e" translate="yes" xml:space="preserve">
          <source>When a security manager is installed, some non-standard socket options may require a security permission before being set or get. The details are specified in &lt;a href=&quot;extendedsocketoptions&quot;&gt;&lt;code&gt;ExtendedSocketOptions&lt;/code&gt;&lt;/a&gt;. No permission is required for &lt;a href=&quot;../../../java.base/java/net/standardsocketoptions&quot;&gt;&lt;code&gt;StandardSocketOptions&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">安装安全管理器后，某些非标准套接字选项在设置或获取之前可能需要安全许可。详细信息在&lt;a href=&quot;extendedsocketoptions&quot;&gt; &lt;code&gt;ExtendedSocketOptions&lt;/code&gt; &lt;/a&gt;中指定。&lt;a href=&quot;../../../java.base/java/net/standardsocketoptions&quot;&gt; &lt;code&gt;StandardSocketOptions&lt;/code&gt; &lt;/a&gt;不需要权限。</target>
        </trans-unit>
        <trans-unit id="bd8e3e90bc0a4ad1eaf1fe672cd6021d8ff59c73" translate="yes" xml:space="preserve">
          <source>When a service provider needs to determine the value of a property, it will generally take that value directly from the environment. A service provider may define provider-specific properties to be placed in its own provider resource file. In that case it should merge values as described in the previous paragraph.</source>
          <target state="translated">当服务提供者需要确定一个属性的值时,它一般会直接从环境中获取该值。服务提供者可以定义特定于提供者的属性,并将其放在自己的提供者资源文件中。在这种情况下,它应该按上一段所述合并值。</target>
        </trans-unit>
        <trans-unit id="7807fd2cea76f3e1ce4a83a545e5b3a3ae40080e" translate="yes" xml:space="preserve">
          <source>When a service provider receives a response control, it uses control factories to return the specific/appropriate control class implementation.</source>
          <target state="translated">当服务提供者接收到响应控制时,它使用控制工厂来返回具体/适当的控制类实现。</target>
        </trans-unit>
        <trans-unit id="3ade58d0e25bc018ea163c0cdad7f4b776c6ab39" translate="yes" xml:space="preserve">
          <source>When a service provider receives response controls, it uses the &lt;code&gt;ControlFactory&lt;/code&gt; class to produce specific classes that implement the &lt;code&gt;Control&lt;/code&gt; interface.</source>
          <target state="translated">当服务提供者收到响应控件时，它将使用 &lt;code&gt;ControlFactory&lt;/code&gt; 类来生成实现 &lt;code&gt;Control&lt;/code&gt; 接口的特定类。</target>
        </trans-unit>
        <trans-unit id="3d30b140cad70a65f78e1eb56376dbfbaf7a9533" translate="yes" xml:space="preserve">
          <source>When a single argument is parsed more than once in the string, the last match will be the final result of the parsing. For example,</source>
          <target state="translated">当一个参数在字符串中被解析超过一次时,最后一次匹配将是解析的最终结果。例如:当一个参数在字符串中被解析多次时,最后一次匹配将是最后的解析结果。</target>
        </trans-unit>
        <trans-unit id="058e1674f7a000873c2028dd6c1dc5cce20b5b83" translate="yes" xml:space="preserve">
          <source>When a socket is connected, &lt;a href=&quot;#receive(java.net.DatagramPacket)&quot;&gt;&lt;code&gt;receive&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#send(java.net.DatagramPacket)&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt;&lt;b&gt;will not perform any security checks&lt;/b&gt; on incoming and outgoing packets, other than matching the packet's and the socket's address and port. On a send operation, if the packet's address is set and the packet's address and the socket's address do not match, an &lt;code&gt;IllegalArgumentException&lt;/code&gt; will be thrown. A socket connected to a multicast address may only be used to send packets.</source>
          <target state="translated">连接套接字后，&lt;a href=&quot;#receive(java.net.DatagramPacket)&quot;&gt; &lt;code&gt;receive&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#send(java.net.DatagramPacket)&quot;&gt; &lt;code&gt;send&lt;/code&gt; &lt;/a&gt;&lt;b&gt;将不会&lt;/b&gt;对传入和传出的数据包&lt;b&gt;执行任何安全检查&lt;/b&gt;，除非匹配数据包的地址和套接字的地址和端口。在发送操作中，如果设置了数据包的地址，并且数据包的地址和套接字的地址不匹配，则将抛出 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 。连接到多播地址的套接字只能用于发送数据包。</target>
        </trans-unit>
        <trans-unit id="b152721196e9350030fbce80cc3060686ce54e33" translate="yes" xml:space="preserve">
          <source>When a socket is connected, &lt;a href=&quot;datagramsocket#receive-java.net.DatagramPacket-&quot;&gt;&lt;code&gt;receive&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;datagramsocket#send-java.net.DatagramPacket-&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt;&lt;b&gt;will not perform any security checks&lt;/b&gt; on incoming and outgoing packets, other than matching the packet's and the socket's address and port. On a send operation, if the packet's address is set and the packet's address and the socket's address do not match, an &lt;code&gt;IllegalArgumentException&lt;/code&gt; will be thrown. A socket connected to a multicast address may only be used to send packets.</source>
          <target state="translated">连接套接字后，&lt;a href=&quot;datagramsocket#receive-java.net.DatagramPacket-&quot;&gt; &lt;code&gt;receive&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;datagramsocket#send-java.net.DatagramPacket-&quot;&gt; &lt;code&gt;send&lt;/code&gt; &lt;/a&gt;&lt;b&gt;将不会&lt;/b&gt;对传入和传出的数据包&lt;b&gt;执行任何安全检查&lt;/b&gt;，除非匹配数据包的地址和套接字的地址和端口。在发送操作中，如果设置了数据包的地址，并且数据包的地址和套接字的地址不匹配，则将抛出 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 。连接到多播地址的套接字只能用于发送数据包。</target>
        </trans-unit>
        <trans-unit id="a75cd6f6c3582a34b8ac5dfdb077e4af32675c83" translate="yes" xml:space="preserve">
          <source>When a socket subscribes to a multicast group/port, it receives datagrams sent by other hosts to the group/port, as do all other members of the group and port. A socket relinquishes membership in a group by the leaveGroup(InetAddress addr) method. &lt;b&gt; Multiple MulticastSocket's&lt;/b&gt; may subscribe to a multicast group and port concurrently, and they will all receive group datagrams.</source>
          <target state="translated">当套接字订阅多播组/端口时，它会接收其他主机发送到该组/端口的数据报，该组和端口的所有其他成员也是如此。套接字通过leaveGroup（InetAddress addr）方法放弃组中的成员身份。&lt;b&gt;多个MulticastSocket&lt;/b&gt;可以同时订阅一个多播组和端口，它们都将接收组数据报。</target>
        </trans-unit>
        <trans-unit id="bddb5b99af343e18d1e354487a694b6e21ce5e1d" translate="yes" xml:space="preserve">
          <source>When a socket subscribes to a multicast group/port, it receives datagrams sent by other hosts to the group/port, as do all other members of the group and port. A socket relinquishes membership in a group by the leaveGroup(SocketAddress mcastaddr, NetworkInterface netIf) method. &lt;b&gt;Multiple MulticastSockets&lt;/b&gt; may subscribe to a multicast group and port concurrently, and they will all receive group datagrams.</source>
          <target state="translated">当套接字订阅多播组/端口时，它会接收其他主机发送到该组/端口的数据报，该组和端口的所有其他成员也是如此。套接字通过leaveGroup（SocketAddress mcastaddr，NetworkInterface netIf）方法放弃组中的成员身份。&lt;b&gt;多个MulticastSocket&lt;/b&gt;可以同时订阅一个多播组和端口，并且它们都将接收组数据报。</target>
        </trans-unit>
        <trans-unit id="1542ee008a8e9f826667c4f42290447523aa89a6" translate="yes" xml:space="preserve">
          <source>When a stack is first created, it contains no items.</source>
          <target state="translated">当一个堆栈第一次创建时,它不包含任何项目。</target>
        </trans-unit>
        <trans-unit id="801c6b334aa2567242a3870abc03d3d6d3033d36" translate="yes" xml:space="preserve">
          <source>When a stream ends it is automatically closed. To manually stop processing of events, close the stream by invoking the &lt;a href=&quot;#close()&quot;&gt;&lt;code&gt;close()&lt;/code&gt;&lt;/a&gt; method. A stream can also be automatically closed in exceptional circumstances, for example if the JVM that is being monitored exits. To receive a notification in any of these occasions, use the &lt;a href=&quot;#onClose(java.lang.Runnable)&quot;&gt;&lt;code&gt;onClose(Runnable)&lt;/code&gt;&lt;/a&gt; method to register an action.</source>
          <target state="translated">流结束时，它会自动关闭。若要手动停止事件处理，请通过调用&lt;a href=&quot;#close()&quot;&gt; &lt;code&gt;close()&lt;/code&gt; &lt;/a&gt;方法关闭流。在特殊情况下，例如，如果正在监视的JVM退出，流也可以自动关闭。要在任何这些情况下接收通知，请使用&lt;a href=&quot;#onClose(java.lang.Runnable)&quot;&gt; &lt;code&gt;onClose(Runnable)&lt;/code&gt; &lt;/a&gt;方法注册一个动作。</target>
        </trans-unit>
        <trans-unit id="58680ac2a710c1c3ec572a26747c8ac4bf37321d" translate="yes" xml:space="preserve">
          <source>When a subclass is replacing objects it must insure that either a complementary substitution must be made during deserialization or that the substituted object is compatible with every field where the reference will be stored. Objects whose type is not a subclass of the type of the field or array element abort the serialization by raising an exception and the object is not be stored.</source>
          <target state="translated">当一个子类要替换对象时,它必须保证在反序列化过程中必须进行补充替换,或者被替换的对象与将存储引用的每个字段兼容。如果对象的类型不是字段或数组元素类型的子类,则会引发异常而中止序列化,并且不会存储该对象。</target>
        </trans-unit>
        <trans-unit id="4af4456165693adbeda480b45292ea0c955ff233" translate="yes" xml:space="preserve">
          <source>When a subclass is replacing objects it must insure that the substituted object is compatible with every field where the reference will be stored. Objects whose type is not a subclass of the type of the field or array element abort the serialization by raising an exception and the object is not be stored.</source>
          <target state="translated">当一个子类替换对象时,它必须确保被替换的对象与将存储引用的每个字段兼容。如果对象的类型不是字段或数组元素类型的子类,则会引发异常而中止序列化,并且不会存储该对象。</target>
        </trans-unit>
        <trans-unit id="e26d84240a67b35d599a0931c437428256b549e1" translate="yes" xml:space="preserve">
          <source>When a subclass overrides a &lt;code&gt;visit&lt;i&gt;XYZ&lt;/i&gt;&lt;/code&gt; method, the new method can cause the enclosed elements to be scanned in the default way by calling &lt;code&gt;super.visit&lt;i&gt;XYZ&lt;/i&gt;&lt;/code&gt;. In this fashion, the concrete visitor can control the ordering of traversal over the component elements with respect to the additional processing; for example, consistently calling &lt;code&gt;super.visit&lt;i&gt;XYZ&lt;/i&gt;&lt;/code&gt; at the start of the overridden methods will yield a preorder traversal, etc. If the component elements should be traversed in some other order, instead of calling &lt;code&gt;super.visit&lt;i&gt;XYZ&lt;/i&gt;&lt;/code&gt;, an overriding visit method should call &lt;code&gt;scan&lt;/code&gt; with the elements in the desired order.</source>
          <target state="translated">当子类覆盖 &lt;code&gt;visit&lt;i&gt;XYZ&lt;/i&gt;&lt;/code&gt; 方法时，新方法可以通过调用 &lt;code&gt;super.visit&lt;i&gt;XYZ&lt;/i&gt;&lt;/code&gt; 来以默认方式扫描封闭的元素。以这种方式，具体的访问者可以控制相对于附加处理在组成元素上的遍历顺序。例如，在重写方法的开头始终调用 &lt;code&gt;super.visit&lt;i&gt;XYZ&lt;/i&gt;&lt;/code&gt; 将产生预遍历，等等。如果应该以其他顺序遍历组件元素，而不是调用 &lt;code&gt;super.visit&lt;i&gt;XYZ&lt;/i&gt;&lt;/code&gt; ，则应调用重写访问方法按所需顺序 &lt;code&gt;scan&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="1982004121a817c184d129a04a27e56f1d2b9c31" translate="yes" xml:space="preserve">
          <source>When a subclass overrides a &lt;code&gt;visit&lt;i&gt;Xyz&lt;/i&gt;&lt;/code&gt; method, the new method can cause the enclosed elements to be scanned in the default way by calling &lt;code&gt;super.visit&lt;i&gt;Xyz&lt;/i&gt;&lt;/code&gt;. In this fashion, the concrete visitor can control the ordering of traversal over the component elements with respect to the additional processing; for example, consistently calling &lt;code&gt;super.visit&lt;i&gt;Xyz&lt;/i&gt;&lt;/code&gt; at the start of the overridden methods will yield a preorder traversal, etc. If the component elements should be traversed in some other order, instead of calling &lt;code&gt;super.visit&lt;i&gt;Xyz&lt;/i&gt;&lt;/code&gt;, an overriding visit method should call &lt;code&gt;scan&lt;/code&gt; with the elements in the desired order.</source>
          <target state="translated">当子类重写 &lt;code&gt;visit&lt;i&gt;Xyz&lt;/i&gt;&lt;/code&gt; 方法时，新方法可以通过调用 &lt;code&gt;super.visit&lt;i&gt;Xyz&lt;/i&gt;&lt;/code&gt; 来以默认方式扫描封闭的元素。以这种方式，具体的访问者可以控制相对于附加处理的组成元素上的遍历顺序。例如，在重写方法的开头始终调用 &lt;code&gt;super.visit&lt;i&gt;Xyz&lt;/i&gt;&lt;/code&gt; 将产生预遍历，等等。如果应该以其他顺序遍历组件元素，而不是调用 &lt;code&gt;super.visit&lt;i&gt;Xyz&lt;/i&gt;&lt;/code&gt; ，则应调用重写访问方法按所需顺序 &lt;code&gt;scan&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="9929247187f11924a98b560a646e45a4e67ae3c7" translate="yes" xml:space="preserve">
          <source>When a submitted task is cancelled before it is run, execution is suppressed. By default, such a cancelled task is not automatically removed from the work queue until its delay elapses. While this enables further inspection and monitoring, it may also cause unbounded retention of cancelled tasks. To avoid this, set &lt;a href=&quot;scheduledthreadpoolexecutor#setRemoveOnCancelPolicy-boolean-&quot;&gt;&lt;code&gt;setRemoveOnCancelPolicy(boolean)&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;true&lt;/code&gt;, which causes tasks to be immediately removed from the work queue at time of cancellation.</source>
          <target state="translated">当提交的任务在运行之前被取消时，执行被抑制。默认情况下，此类取消的任务不会自动从工作队列中删除，直到其延迟过去为止。尽管这可以进行进一步的检查和监视，但也可能导致无限期保留已取消的任务。为避免这种情况，请将&lt;a href=&quot;scheduledthreadpoolexecutor#setRemoveOnCancelPolicy-boolean-&quot;&gt; &lt;code&gt;setRemoveOnCancelPolicy(boolean)&lt;/code&gt; &lt;/a&gt;设置为 &lt;code&gt;true&lt;/code&gt; ，这将导致在取消时立即从工作队列中删除任务。</target>
        </trans-unit>
        <trans-unit id="b44cdb1f4c54b9f9c38dd96a59f19c9b972ead75" translate="yes" xml:space="preserve">
          <source>When a submitted task is cancelled before it is run, execution is suppressed. By default, such a cancelled task is not automatically removed from the work queue until its delay elapses. While this enables further inspection and monitoring, it may also cause unbounded retention of cancelled tasks. To avoid this, use &lt;a href=&quot;#setRemoveOnCancelPolicy(boolean)&quot;&gt;&lt;code&gt;setRemoveOnCancelPolicy(boolean)&lt;/code&gt;&lt;/a&gt; to cause tasks to be immediately removed from the work queue at time of cancellation.</source>
          <target state="translated">当提交的任务在运行之前被取消时，执行被抑制。默认情况下，此类取消的任务不会自动从工作队列中删除，直到其延迟过去为止。尽管这可以进行进一步的检查和监视，但也可能无限期地保留已取消的任务。为避免这种情况，请使用&lt;a href=&quot;#setRemoveOnCancelPolicy(boolean)&quot;&gt; &lt;code&gt;setRemoveOnCancelPolicy(boolean)&lt;/code&gt; &lt;/a&gt;使取消时立即将任务从工作队列中删除。</target>
        </trans-unit>
        <trans-unit id="10b74fcebd08424b7bb7bf29fe6e5a17d846f581" translate="yes" xml:space="preserve">
          <source>When a system exclusive message is read from a MIDI file, it always has a defined length. Data from a system exclusive message from a MIDI file should be stored in the data array of a &lt;code&gt;SysexMessage&lt;/code&gt; as follows: the system exclusive message status byte (0xF0 or 0xF7), all message data bytes, and finally the end-of-exclusive flag (0xF7). The length reported by the &lt;code&gt;SysexMessage&lt;/code&gt; object is therefore the length of the system exclusive data plus two: one byte for the status byte and one for the end-of-exclusive flag.</source>
          <target state="translated">从MIDI文件中读取系统专用消息时，该消息始终具有定义的长度。来自MIDI文件的系统独占消息的数据应按以下方式存储在 &lt;code&gt;SysexMessage&lt;/code&gt; 的数据数组中：系统独占消息状态字节（0xF0或0xF7），所有消息数据字节，最后是独占结束标志（ 0xF7）。因此， &lt;code&gt;SysexMessage&lt;/code&gt; 对象报告的长度是系统专用数据的长度加上两个：一个字节用于状态字节，一个字节用于结束标志。</target>
        </trans-unit>
        <trans-unit id="89b880bb7b0e20e4a94653fd28147b76b402fbeb" translate="yes" xml:space="preserve">
          <source>When a thread &lt;code&gt;T&lt;/code&gt; queries a class value in state &lt;code&gt;2N&lt;/code&gt;, the thread first attempts to initialize the class value to state &lt;code&gt;2N+1&lt;/code&gt; by invoking &lt;code&gt;computeValue&lt;/code&gt; and installing the resulting value.</source>
          <target state="translated">当线程 &lt;code&gt;T&lt;/code&gt; 查询状态 &lt;code&gt;2N&lt;/code&gt; 中的类值时，该线程首先尝试通过调用 &lt;code&gt;computeValue&lt;/code&gt; 并安装结果值来将类值初始化为状态 &lt;code&gt;2N+1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d0bb71d68a413b1e3688231ebd3a0fe5821666fc" translate="yes" xml:space="preserve">
          <source>When a thread &lt;code&gt;T&lt;/code&gt; removes a class value in state &lt;code&gt;2N&lt;/code&gt;, nothing happens, since the class value is already uninitialized. Otherwise, the state is advanced atomically to &lt;code&gt;2N+1&lt;/code&gt;.</source>
          <target state="translated">当线程 &lt;code&gt;T&lt;/code&gt; 删除状态 &lt;code&gt;2N&lt;/code&gt; 中的类值时，什么也没有发生，因为该类值已经被初始化。否则，该状态从原子上推进到 &lt;code&gt;2N+1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5f150b9d52841cfe078b29c41afb5606285d9203" translate="yes" xml:space="preserve">
          <source>When a thread is about to terminate due to an uncaught exception the Java Virtual Machine will query the thread for its &lt;code&gt;UncaughtExceptionHandler&lt;/code&gt; using &lt;a href=&quot;thread#getUncaughtExceptionHandler()&quot;&gt;&lt;code&gt;Thread.getUncaughtExceptionHandler()&lt;/code&gt;&lt;/a&gt; and will invoke the handler's &lt;code&gt;uncaughtException&lt;/code&gt; method, passing the thread and the exception as arguments. If a thread has not had its &lt;code&gt;UncaughtExceptionHandler&lt;/code&gt; explicitly set, then its &lt;code&gt;ThreadGroup&lt;/code&gt; object acts as its &lt;code&gt;UncaughtExceptionHandler&lt;/code&gt;. If the &lt;code&gt;ThreadGroup&lt;/code&gt; object has no special requirements for dealing with the exception, it can forward the invocation to the &lt;a href=&quot;thread#getDefaultUncaughtExceptionHandler()&quot;&gt;default uncaught exception handler&lt;/a&gt;.</source>
          <target state="translated">当线程由于未捕获的异常而将要终止时，Java虚拟机将使用&lt;a href=&quot;thread#getUncaughtExceptionHandler()&quot;&gt; &lt;code&gt;Thread.getUncaughtExceptionHandler()&lt;/code&gt; &lt;/a&gt;在线程中查询其 &lt;code&gt;UncaughtExceptionHandler&lt;/code&gt; 并将调用处理程序的 &lt;code&gt;uncaughtException&lt;/code&gt; 方法，并将线程和异常作为参数传递。如果尚未显式设置线程的 &lt;code&gt;UncaughtExceptionHandler&lt;/code&gt; ，则其 &lt;code&gt;ThreadGroup&lt;/code&gt; 对象将充当 &lt;code&gt;UncaughtExceptionHandler&lt;/code&gt; 。如果 &lt;code&gt;ThreadGroup&lt;/code&gt; 对象对处理异常没有特殊要求，则可以将调用转发到&lt;a href=&quot;thread#getDefaultUncaughtExceptionHandler()&quot;&gt;默认的未捕获异常处理程序&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="77fe3f278ecb8fc0ec8c3db5bded17a3ac83c0e0" translate="yes" xml:space="preserve">
          <source>When a thread is about to terminate due to an uncaught exception the Java Virtual Machine will query the thread for its &lt;code&gt;UncaughtExceptionHandler&lt;/code&gt; using &lt;a href=&quot;thread#getUncaughtExceptionHandler--&quot;&gt;&lt;code&gt;Thread.getUncaughtExceptionHandler()&lt;/code&gt;&lt;/a&gt; and will invoke the handler's &lt;code&gt;uncaughtException&lt;/code&gt; method, passing the thread and the exception as arguments. If a thread has not had its &lt;code&gt;UncaughtExceptionHandler&lt;/code&gt; explicitly set, then its &lt;code&gt;ThreadGroup&lt;/code&gt; object acts as its &lt;code&gt;UncaughtExceptionHandler&lt;/code&gt;. If the &lt;code&gt;ThreadGroup&lt;/code&gt; object has no special requirements for dealing with the exception, it can forward the invocation to the &lt;a href=&quot;thread#getDefaultUncaughtExceptionHandler--&quot;&gt;default uncaught exception handler&lt;/a&gt;.</source>
          <target state="translated">当线程由于未捕获的异常而将要终止时，Java虚拟机将使用&lt;a href=&quot;thread#getUncaughtExceptionHandler--&quot;&gt; &lt;code&gt;Thread.getUncaughtExceptionHandler()&lt;/code&gt; &lt;/a&gt;在线程中查询其 &lt;code&gt;UncaughtExceptionHandler&lt;/code&gt; 并将调用处理程序的 &lt;code&gt;uncaughtException&lt;/code&gt; 方法，并将线程和异常作为参数传递。如果尚未显式设置线程的 &lt;code&gt;UncaughtExceptionHandler&lt;/code&gt; ，则其 &lt;code&gt;ThreadGroup&lt;/code&gt; 对象将充当 &lt;code&gt;UncaughtExceptionHandler&lt;/code&gt; 。如果 &lt;code&gt;ThreadGroup&lt;/code&gt; 对象对处理异常没有特殊要求，则可以将调用转发到&lt;a href=&quot;thread#getDefaultUncaughtExceptionHandler--&quot;&gt;默认的未捕获异常处理程序&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b6517f9211529a6ef5c79a7f3adfdb2b5c1cfe48" translate="yes" xml:space="preserve">
          <source>When a thread is blocked in &lt;a href=&quot;connection#readPacket()&quot;&gt;&lt;code&gt;readPacket&lt;/code&gt;&lt;/a&gt; waiting for packet from a target VM the &lt;a href=&quot;connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt; may be closed asynchronous by another thread invokving the &lt;a href=&quot;connection#close()&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt; method. When this arises the thread in readPacket will throw this exception. Similiarly when a thread is blocked in &lt;a href=&quot;connection#writePacket(byte%5B%5D)&quot;&gt;&lt;code&gt;Connection.writePacket(byte[])&lt;/code&gt;&lt;/a&gt; the Connection may be closed. When this occurs the thread in writePacket will throw this exception.</source>
          <target state="translated">当线程在&lt;a href=&quot;connection#readPacket()&quot;&gt; &lt;code&gt;readPacket&lt;/code&gt; 中&lt;/a&gt;被阻塞，等待来自目标VM的数据包时，另一个线程可能会通过调用&lt;a href=&quot;connection#close()&quot;&gt; &lt;code&gt;close&lt;/code&gt; &lt;/a&gt;方法来异步关闭&lt;a href=&quot;connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt;。当出现这种情况时，readPacket中的线程将引发此异常。同样，当线程在&lt;a href=&quot;connection#writePacket(byte%5B%5D)&quot;&gt; &lt;code&gt;Connection.writePacket(byte[])&lt;/code&gt; &lt;/a&gt;被阻止时，连接可能会关闭。发生这种情况时，writePacket中的线程将引发此异常。</target>
        </trans-unit>
        <trans-unit id="895317443968ac47f3f92d75cb96a37c77319964" translate="yes" xml:space="preserve">
          <source>When a three part address is specified, the last part is interpreted as a 16-bit quantity and placed in the right most two bytes of the network address. This makes the three part address format convenient for specifying Class B net- work addresses as 128.net.host.</source>
          <target state="translated">当指定一个三部分地址时,最后一部分被解释为一个16位的数量,并放在网络地址的最右边两个字节中。这使得三部分地址格式对于指定128.net.host这样的B类网络工作地址非常方便。</target>
        </trans-unit>
        <trans-unit id="55c955456f3e00fb19bba01a0a16d6dc85d4343f" translate="yes" xml:space="preserve">
          <source>When a toolkit-modal dialog is shown from an applet, it blocks all other applets in the browser. When launching applications from Java Web Start, its windows (such as the security dialog) may also be blocked by toolkit-modal dialogs, shown from these applications.</source>
          <target state="translated">当一个工具包模式对话框从一个小程序中显示出来时,它会阻止浏览器中的所有其他小程序。当从Java Web Start启动应用程序时,它的窗口(如安全对话框)也可能被这些应用程序中显示的工具包模式对话框阻止。</target>
        </trans-unit>
        <trans-unit id="29a6c60ea1ad71509b0284da02c6071f09ce9c45" translate="yes" xml:space="preserve">
          <source>When a two part address is supplied, the last part is interpreted as a 24-bit quantity and placed in the right most three bytes of the network address. This makes the two part address format convenient for specifying Class A network addresses as net.host.</source>
          <target state="translated">当提供两部分地址时,最后一部分被解释为一个24位的数量,并放在网络地址的最右边三个字节中。这使得两部分地址格式在指定A类网络地址为net.host时非常方便。</target>
        </trans-unit>
        <trans-unit id="50fa67634b29d9a508bc8a6003503fb30f4c5d33" translate="yes" xml:space="preserve">
          <source>When a type map with an entry for the base type is supplied to the methods &lt;code&gt;getArray&lt;/code&gt; and &lt;code&gt;getResultSet&lt;/code&gt;, the mapping it contains will be used to map the elements of the &lt;code&gt;ARRAY&lt;/code&gt; value. If no type map is supplied, which would typically be the case, the connection's type map is used by default. If the connection's type map or a type map supplied to a method has no entry for the base type, the elements are mapped according to the standard mapping.</source>
          <target state="translated">当将具有基本类型的条目的类型映射提供给方法 &lt;code&gt;getArray&lt;/code&gt; 和 &lt;code&gt;getResultSet&lt;/code&gt; 时，其包含的映射将用于映射 &lt;code&gt;ARRAY&lt;/code&gt; 值的元素。如果没有提供类型映射（通常是这种情况），则默认情况下使用连接的类型映射。如果连接的类型映射或提供给方法的类型映射没有基类型的条目，则根据标准映射来映射元素。</target>
        </trans-unit>
        <trans-unit id="6aa8db231eb18f002bb271b220e13400b3ee853b" translate="yes" xml:space="preserve">
          <source>When a variable &lt;code&gt;{i}&lt;/code&gt; appears in a search filter, it indicates that the filter argument &lt;code&gt;filterArgs[i]&lt;/code&gt; is to be used in that place. Such variables may be used wherever an &lt;em&gt;attr&lt;/em&gt;, &lt;em&gt;value&lt;/em&gt;, or &lt;em&gt;matchingrule&lt;/em&gt; production appears in the filter grammar of RFC 2254, section 4. When a string-valued filter argument is substituted for a variable, the filter is interpreted as if the string were given in place of the variable, with any characters having special significance within filters (such as &lt;code&gt;'*'&lt;/code&gt;) having been escaped according to the rules of RFC 2254.</source>
          <target state="translated">当变量 &lt;code&gt;{i}&lt;/code&gt; 出现在搜索过滤器中时，表示该位置将使用过滤器参数 &lt;code&gt;filterArgs[i]&lt;/code&gt; 。此类变量可以在RFC 2254第4节的过滤器语法中出现&lt;em&gt;attr&lt;/em&gt;，&lt;em&gt;value&lt;/em&gt;或&lt;em&gt;matchingrule&lt;/em&gt;产生式的任何地方使用。用字符串值过滤器参数代替变量时，将过滤器解释为好像字符串是在变量的位置，过滤器中具有特殊意义的任何字符（例如 &lt;code&gt;'*'&lt;/code&gt; ）均已根据RFC 2254的规则进行了转义。</target>
        </trans-unit>
        <trans-unit id="a223dab9f441fba936619f7975da0a97a57c63a7" translate="yes" xml:space="preserve">
          <source>When a very large ASCII value is input to a &lt;code&gt;LONGVARCHAR&lt;/code&gt; parameter, it may be more practical to send it via a &lt;code&gt;java.io.InputStream&lt;/code&gt; object. A JDBC technology-enabled driver will read the data from the stream as needed until it reaches end-of-file. The driver will do any necessary conversion from ASCII to the database &lt;code&gt;CHAR&lt;/code&gt; format.</source>
          <target state="translated">当将非常大的ASCII值输入到 &lt;code&gt;LONGVARCHAR&lt;/code&gt; 参数时，通过 &lt;code&gt;java.io.InputStream&lt;/code&gt; 对象发送它可能更实际。启用了JDBC技术的驱动程序将根据需要从流中读取数据，直到到达文件末尾为止。驱动程序将进行任何必要的从ASCII到数据库 &lt;code&gt;CHAR&lt;/code&gt; 格式的转换。</target>
        </trans-unit>
        <trans-unit id="fcd897e7054adc322a89f61811e83785269eb890" translate="yes" xml:space="preserve">
          <source>When a very large Unicode value is input to a &lt;code&gt;LONGVARCHAR&lt;/code&gt; parameter, it may be more practical to send it via a &lt;code&gt;Reader&lt;/code&gt; object. A JDBC technology-enabled driver will read the data from the stream as needed until it reaches end-of-file. The driver will do any necessary conversion from Unicode to the database &lt;code&gt;CHAR&lt;/code&gt; format. The byte format of the Unicode stream must be Java UTF-8, as defined in the Java Virtual Machine Specification.</source>
          <target state="translated">当将非常大的Unicode值输入到 &lt;code&gt;LONGVARCHAR&lt;/code&gt; 参数时，通过 &lt;code&gt;Reader&lt;/code&gt; 对象发送它可能更实际。启用了JDBC技术的驱动程序将根据需要从流中读取数据，直到到达文件末尾为止。驱动程序将执行从Unicode到数据库 &lt;code&gt;CHAR&lt;/code&gt; 格式的所有必要转换。 Unicode流的字节格式必须为Java UTF-8（如Java虚拟机规范中所定义）。</target>
        </trans-unit>
        <trans-unit id="1e04bc4facdf8d539c4270ddd0aa73a722158aa2" translate="yes" xml:space="preserve">
          <source>When a very large Unicode value is input to a &lt;code&gt;LONGVARCHAR&lt;/code&gt; parameter, it may be more practical to send it via a &lt;code&gt;java.io.InputStream&lt;/code&gt; object. A JDBC technology-enabled driver will read the data from the stream as needed, until it reaches end-of-file. The driver will do any necessary conversion from Unicode to the database &lt;code&gt;CHAR&lt;/code&gt; format. The byte format of the Unicode stream must be Java UTF-8, as defined in the Java Virtual Machine Specification.</source>
          <target state="translated">当将非常大的Unicode值输入到 &lt;code&gt;LONGVARCHAR&lt;/code&gt; 参数时，通过 &lt;code&gt;java.io.InputStream&lt;/code&gt; 对象发送它可能更实际。启用了JDBC技术的驱动程序将根据需要从流中读取数据，直到到达文件末尾。驱动程序将执行从Unicode到数据库 &lt;code&gt;CHAR&lt;/code&gt; 格式的所有必要转换。Unicode流的字节格式必须为Java UTF-8（如Java虚拟机规范中所定义）。</target>
        </trans-unit>
        <trans-unit id="adc578dc87370a608ed5a2be5460fe895888ac7d" translate="yes" xml:space="preserve">
          <source>When a very large binary value is input to a &lt;code&gt;LONGVARBINARY&lt;/code&gt; parameter, it may be more practical to send it via a &lt;code&gt;java.io.InputStream&lt;/code&gt; object. A JDBC technology-enabled driver will read the data from the stream as needed until it reaches end-of-file.</source>
          <target state="translated">当将非常大的二进制值输入到 &lt;code&gt;LONGVARBINARY&lt;/code&gt; 参数时，通过 &lt;code&gt;java.io.InputStream&lt;/code&gt; 对象发送它可能更实际。启用了JDBC技术的驱动程序将根据需要从流中读取数据，直到到达文件末尾为止。</target>
        </trans-unit>
        <trans-unit id="e2c2469b19a3494bf3f5739b9534978d0c5455a7" translate="yes" xml:space="preserve">
          <source>When adding providers to the cache, the &lt;a href=&quot;serviceloader#iterator--&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; processes resources in the order that the &lt;a href=&quot;../lang/classloader#getResources-java.lang.String-&quot;&gt;&lt;code&gt;ClassLoader.getResources(String)&lt;/code&gt;&lt;/a&gt; method finds the service configuration files.</source>
          <target state="translated">在将提供程序添加到缓存时，&lt;a href=&quot;serviceloader#iterator--&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;按照&lt;a href=&quot;../lang/classloader#getResources-java.lang.String-&quot;&gt; &lt;code&gt;ClassLoader.getResources(String)&lt;/code&gt; &lt;/a&gt;方法查找服务配置文件的顺序处理资源。</target>
        </trans-unit>
        <trans-unit id="a3a63ad56f11301a43466ccd3853e7b3ff64e5a3" translate="yes" xml:space="preserve">
          <source>When all modules have been enumerated then a readability graph is computed, and in conjunction with the module exports and service use, checked for consistency.</source>
          <target state="translated">当所有模块都被列举出来后,就会计算出一个可读性图,并结合模块出口和服务使用情况,检查其一致性。</target>
        </trans-unit>
        <trans-unit id="bcd60d3bee845f9fdd7a82c5e0d643e282800575" translate="yes" xml:space="preserve">
          <source>When an &lt;a href=&quot;../../../org/xml/sax/errorhandler&quot;&gt;&lt;code&gt;ErrorHandler&lt;/code&gt;&lt;/a&gt; is set, the callee will report all the errors found in sources to the handler. If the handler throws an exception, it will abort the schema compilation and the same exception will be thrown from this method. Also, after an error is reported to a handler, the callee is allowed to abort the further processing by throwing it. If an error handler is not set, the callee will throw the first error it finds in the sources.</source>
          <target state="translated">当&lt;a href=&quot;../../../org/xml/sax/errorhandler&quot;&gt; &lt;code&gt;ErrorHandler&lt;/code&gt; &lt;/a&gt;设置，被叫方将报告所有来源的处理程序发现的错误。如果处理程序引发异常，它将中止架构编译，并且此方法将引发相同的异常。同样，在将错误报告给处理程序之后，被调用方可以通过抛出该异常来中止进一步的处理。如果未设置错误处理程序，则被调用方将抛出在源中找到的第一个错误。</target>
        </trans-unit>
        <trans-unit id="bb2dce23419118f6b8331bfb0b7c1d8142491745" translate="yes" xml:space="preserve">
          <source>When an &lt;a href=&quot;../inputsource&quot;&gt;&lt;code&gt;InputSource&lt;/code&gt;&lt;/a&gt; is used to provide an entity's character stream, this method returns the encoding provided in that input stream.</source>
          <target state="translated">当使用&lt;a href=&quot;../inputsource&quot;&gt; &lt;code&gt;InputSource&lt;/code&gt; &lt;/a&gt;提供实体的字符流时，此方法返回该输入流中提供的编码。</target>
        </trans-unit>
        <trans-unit id="4e81b728c5aff55890dffac2c0a02554a169937e" translate="yes" xml:space="preserve">
          <source>When an &lt;code&gt;SSLSocket&lt;/code&gt; is first created, no handshaking is done so that applications may first set their communication preferences: what cipher suites to use, whether the socket should be in client or server mode, etc. However, security is always provided by the time that application data is sent over the connection.</source>
          <target state="translated">当 &lt;code&gt;SSLSocket&lt;/code&gt; 第一次被创建，没有握手是这样做的应用程序可能首先设置它们的通信首选项：什么密码套件的使用，插座是否应该在客户端或服务器模式，等等。然而，安全总是被时间所提供应用程序数据通过连接发送。</target>
        </trans-unit>
        <trans-unit id="5c164b99953c48a40b73ea8b2b0ca7202f7ca056" translate="yes" xml:space="preserve">
          <source>When an &lt;code&gt;XMLSignature&lt;/code&gt; containing this reference is generated, the specified &lt;code&gt;transforms&lt;/code&gt; (if non-null) are applied to the specified &lt;code&gt;result&lt;/code&gt;. The &lt;code&gt;Transforms&lt;/code&gt; element of the resulting &lt;code&gt;Reference&lt;/code&gt; element is set to the concatenation of the &lt;code&gt;appliedTransforms&lt;/code&gt; and &lt;code&gt;transforms&lt;/code&gt;.</source>
          <target state="translated">生成包含此引用的 &lt;code&gt;XMLSignature&lt;/code&gt; 时，会将指定的 &lt;code&gt;transforms&lt;/code&gt; （如果非null）应用于指定的 &lt;code&gt;result&lt;/code&gt; 。结果 &lt;code&gt;Reference&lt;/code&gt; 元素的 &lt;code&gt;Transforms&lt;/code&gt; 元素设置为 &lt;code&gt;appliedTransforms&lt;/code&gt; 和 &lt;code&gt;transforms&lt;/code&gt; 的串联。</target>
        </trans-unit>
        <trans-unit id="bcaddb468356d4ee2035b39f238ba71251cf9ad5" translate="yes" xml:space="preserve">
          <source>When an Externalizable object is reconstructed, an instance is created using the public no-arg constructor, then the readExternal method called. Serializable objects are restored by reading them from an ObjectInputStream.</source>
          <target state="translated">当一个Externalizable对象被重建时,使用公共的no-arg构造函数创建一个实例,然后调用readExternal方法。可序列化对象是通过从ObjectInputStream中读取它们来恢复的。</target>
        </trans-unit>
        <trans-unit id="fb8f935efcf55f08e7d5d19a4cd9f7c5f2edf11a" translate="yes" xml:space="preserve">
          <source>When an MBean emits a notification, it considers each listener that has been added with &lt;a href=&quot;#addNotificationListener(javax.management.NotificationListener,javax.management.NotificationFilter,java.lang.Object)&quot;&gt;&lt;code&gt;addNotificationListener&lt;/code&gt;&lt;/a&gt; and not subsequently removed with &lt;a href=&quot;#removeNotificationListener(javax.management.NotificationListener)&quot;&gt;&lt;code&gt;removeNotificationListener&lt;/code&gt;&lt;/a&gt;. If a filter was provided with that listener, and if the filter's &lt;a href=&quot;notificationfilter#isNotificationEnabled(javax.management.Notification)&quot;&gt;&lt;code&gt;isNotificationEnabled&lt;/code&gt;&lt;/a&gt; method returns false, the listener is ignored. Otherwise, the listener's &lt;a href=&quot;notificationlistener#handleNotification(javax.management.Notification,java.lang.Object)&quot;&gt;&lt;code&gt;handleNotification&lt;/code&gt;&lt;/a&gt; method is called with the notification, as well as the handback object that was provided to &lt;code&gt;addNotificationListener&lt;/code&gt;.</source>
          <target state="translated">当MBean发出通知时，它将考虑已使用&lt;a href=&quot;#addNotificationListener(javax.management.NotificationListener,javax.management.NotificationFilter,java.lang.Object)&quot;&gt; &lt;code&gt;addNotificationListener&lt;/code&gt; &lt;/a&gt;添加但随后未使用&lt;a href=&quot;#removeNotificationListener(javax.management.NotificationListener)&quot;&gt; &lt;code&gt;removeNotificationListener&lt;/code&gt; &lt;/a&gt;移除的每个侦听器。如果该侦听器提供了一个过滤器，并且该过滤器的&lt;a href=&quot;notificationfilter#isNotificationEnabled(javax.management.Notification)&quot;&gt; &lt;code&gt;isNotificationEnabled&lt;/code&gt; &lt;/a&gt;方法返回false，则将忽略该侦听器。否则，将通过通知以及提供给 &lt;code&gt;addNotificationListener&lt;/code&gt; 的handback对象来调用侦听器的&lt;a href=&quot;notificationlistener#handleNotification(javax.management.Notification,java.lang.Object)&quot;&gt; &lt;code&gt;handleNotification&lt;/code&gt; &lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="fa3ea13008a777f73a92e7a4bb586fabfda6d863" translate="yes" xml:space="preserve">
          <source>When an MBean emits a notification, it considers each listener that has been added with &lt;a href=&quot;notificationbroadcaster#addNotificationListener(javax.management.NotificationListener,javax.management.NotificationFilter,java.lang.Object)&quot;&gt;&lt;code&gt;addNotificationListener&lt;/code&gt;&lt;/a&gt; and not subsequently removed with &lt;a href=&quot;#removeNotificationListener(javax.management.NotificationListener,javax.management.NotificationFilter,java.lang.Object)&quot;&gt;&lt;code&gt;removeNotificationListener&lt;/code&gt;&lt;/a&gt;. If a filter was provided with that listener, and if the filter's &lt;a href=&quot;notificationfilter#isNotificationEnabled(javax.management.Notification)&quot;&gt;&lt;code&gt;isNotificationEnabled&lt;/code&gt;&lt;/a&gt; method returns false, the listener is ignored. Otherwise, the listener's &lt;a href=&quot;notificationlistener#handleNotification(javax.management.Notification,java.lang.Object)&quot;&gt;&lt;code&gt;handleNotification&lt;/code&gt;&lt;/a&gt; method is called with the notification, as well as the handback object that was provided to &lt;code&gt;addNotificationListener&lt;/code&gt;.</source>
          <target state="translated">当MBean发出通知时，它将考虑已使用&lt;a href=&quot;notificationbroadcaster#addNotificationListener(javax.management.NotificationListener,javax.management.NotificationFilter,java.lang.Object)&quot;&gt; &lt;code&gt;addNotificationListener&lt;/code&gt; &lt;/a&gt;添加但随后未使用&lt;a href=&quot;#removeNotificationListener(javax.management.NotificationListener,javax.management.NotificationFilter,java.lang.Object)&quot;&gt; &lt;code&gt;removeNotificationListener&lt;/code&gt; &lt;/a&gt;移除的每个侦听器。如果该侦听器提供了一个过滤器，并且该过滤器的&lt;a href=&quot;notificationfilter#isNotificationEnabled(javax.management.Notification)&quot;&gt; &lt;code&gt;isNotificationEnabled&lt;/code&gt; &lt;/a&gt;方法返回false，则将忽略该侦听器。否则，将通过通知以及提供给 &lt;code&gt;addNotificationListener&lt;/code&gt; 的handback对象来调用侦听器的&lt;a href=&quot;notificationlistener#handleNotification(javax.management.Notification,java.lang.Object)&quot;&gt; &lt;code&gt;handleNotification&lt;/code&gt; &lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="45b4eddc256c7dd0ed23de01764919b7450154dc" translate="yes" xml:space="preserve">
          <source>When an MBean emits a notification, it considers each listener that has been added with &lt;a href=&quot;notificationbroadcaster#addNotificationListener-javax.management.NotificationListener-javax.management.NotificationFilter-java.lang.Object-&quot;&gt;&lt;code&gt;addNotificationListener&lt;/code&gt;&lt;/a&gt; and not subsequently removed with &lt;a href=&quot;notificationbroadcaster#removeNotificationListener-javax.management.NotificationListener-&quot;&gt;&lt;code&gt;removeNotificationListener&lt;/code&gt;&lt;/a&gt;. If a filter was provided with that listener, and if the filter's &lt;a href=&quot;notificationfilter#isNotificationEnabled-javax.management.Notification-&quot;&gt;&lt;code&gt;isNotificationEnabled&lt;/code&gt;&lt;/a&gt; method returns false, the listener is ignored. Otherwise, the listener's &lt;a href=&quot;notificationlistener#handleNotification-javax.management.Notification-java.lang.Object-&quot;&gt;&lt;code&gt;handleNotification&lt;/code&gt;&lt;/a&gt; method is called with the notification, as well as the handback object that was provided to &lt;code&gt;addNotificationListener&lt;/code&gt;.</source>
          <target state="translated">当MBean发出通知时，它将考虑已使用&lt;a href=&quot;notificationbroadcaster#addNotificationListener-javax.management.NotificationListener-javax.management.NotificationFilter-java.lang.Object-&quot;&gt; &lt;code&gt;addNotificationListener&lt;/code&gt; &lt;/a&gt;添加且随后未使用&lt;a href=&quot;notificationbroadcaster#removeNotificationListener-javax.management.NotificationListener-&quot;&gt; &lt;code&gt;removeNotificationListener&lt;/code&gt; &lt;/a&gt;移除的每个侦听器。如果该侦听器提供了一个过滤器，并且该过滤器的&lt;a href=&quot;notificationfilter#isNotificationEnabled-javax.management.Notification-&quot;&gt; &lt;code&gt;isNotificationEnabled&lt;/code&gt; &lt;/a&gt;方法返回false，则将忽略该侦听器。否则，将通过通知以及提供给 &lt;code&gt;addNotificationListener&lt;/code&gt; 的handback对象调用侦听器的&lt;a href=&quot;notificationlistener#handleNotification-javax.management.Notification-java.lang.Object-&quot;&gt; &lt;code&gt;handleNotification&lt;/code&gt; &lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="b71b50e0adb800b8bc569793e796446befc75eb6" translate="yes" xml:space="preserve">
          <source>When an MBean emits a notification, it considers each listener that has been added with &lt;a href=&quot;notificationbroadcaster#addNotificationListener-javax.management.NotificationListener-javax.management.NotificationFilter-java.lang.Object-&quot;&gt;&lt;code&gt;addNotificationListener&lt;/code&gt;&lt;/a&gt; and not subsequently removed with &lt;a href=&quot;notificationemitter#removeNotificationListener-javax.management.NotificationListener-javax.management.NotificationFilter-java.lang.Object-&quot;&gt;&lt;code&gt;removeNotificationListener&lt;/code&gt;&lt;/a&gt;. If a filter was provided with that listener, and if the filter's &lt;a href=&quot;notificationfilter#isNotificationEnabled-javax.management.Notification-&quot;&gt;&lt;code&gt;isNotificationEnabled&lt;/code&gt;&lt;/a&gt; method returns false, the listener is ignored. Otherwise, the listener's &lt;a href=&quot;notificationlistener#handleNotification-javax.management.Notification-java.lang.Object-&quot;&gt;&lt;code&gt;handleNotification&lt;/code&gt;&lt;/a&gt; method is called with the notification, as well as the handback object that was provided to &lt;code&gt;addNotificationListener&lt;/code&gt;.</source>
          <target state="translated">当MBean发出通知时，它将考虑已使用&lt;a href=&quot;notificationbroadcaster#addNotificationListener-javax.management.NotificationListener-javax.management.NotificationFilter-java.lang.Object-&quot;&gt; &lt;code&gt;addNotificationListener&lt;/code&gt; &lt;/a&gt;添加且随后未使用&lt;a href=&quot;notificationemitter#removeNotificationListener-javax.management.NotificationListener-javax.management.NotificationFilter-java.lang.Object-&quot;&gt; &lt;code&gt;removeNotificationListener&lt;/code&gt; &lt;/a&gt;移除的每个侦听器。如果该侦听器提供了一个过滤器，并且该过滤器的&lt;a href=&quot;notificationfilter#isNotificationEnabled-javax.management.Notification-&quot;&gt; &lt;code&gt;isNotificationEnabled&lt;/code&gt; &lt;/a&gt;方法返回false，则将忽略该侦听器。否则，将通过通知以及提供给 &lt;code&gt;addNotificationListener&lt;/code&gt; 的handback对象调用侦听器的&lt;a href=&quot;notificationlistener#handleNotification-javax.management.Notification-java.lang.Object-&quot;&gt; &lt;code&gt;handleNotification&lt;/code&gt; &lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="4a7fc36f9fbd29ea8d2c562e9942118b86a45c61" translate="yes" xml:space="preserve">
          <source>When an MBean is registered in an MBean Server, if it is of a subclass of &lt;a href=&quot;../../../../java.base/java/lang/classloader&quot;&gt;&lt;code&gt;ClassLoader&lt;/code&gt;&lt;/a&gt; and if it does not implement the interface &lt;a href=&quot;privateclassloader&quot;&gt;&lt;code&gt;PrivateClassLoader&lt;/code&gt;&lt;/a&gt;, it is added to the end of the MBean Server's &lt;code&gt;ClassLoaderRepository&lt;/code&gt;. If it is subsequently unregistered from the MBean Server, it is removed from the &lt;code&gt;ClassLoaderRepository&lt;/code&gt;.</source>
          <target state="translated">在MBean服务器中注册MBean时，如果它是&lt;a href=&quot;../../../../java.base/java/lang/classloader&quot;&gt; &lt;code&gt;ClassLoader&lt;/code&gt; &lt;/a&gt;的子类并且没有实现接口&lt;a href=&quot;privateclassloader&quot;&gt; &lt;code&gt;PrivateClassLoader&lt;/code&gt; &lt;/a&gt;，则它将添加到MBean Server的 &lt;code&gt;ClassLoaderRepository&lt;/code&gt; 的末尾。如果随后从MBean服务器取消注册，则将其从 &lt;code&gt;ClassLoaderRepository&lt;/code&gt; 中删除。</target>
        </trans-unit>
        <trans-unit id="fc7e40c74e30e9bdda780e2f49b9064de3f28184" translate="yes" xml:space="preserve">
          <source>When an MBean is registered in an MBean Server, if it is of a subclass of &lt;a href=&quot;../../../java/lang/classloader&quot;&gt;&lt;code&gt;ClassLoader&lt;/code&gt;&lt;/a&gt; and if it does not implement the interface &lt;a href=&quot;privateclassloader&quot;&gt;&lt;code&gt;PrivateClassLoader&lt;/code&gt;&lt;/a&gt;, it is added to the end of the MBean Server's &lt;code&gt;ClassLoaderRepository&lt;/code&gt;. If it is subsequently unregistered from the MBean Server, it is removed from the &lt;code&gt;ClassLoaderRepository&lt;/code&gt;.</source>
          <target state="translated">在MBean服务器中注册MBean时，如果它是&lt;a href=&quot;../../../java/lang/classloader&quot;&gt; &lt;code&gt;ClassLoader&lt;/code&gt; &lt;/a&gt;的子类，并且没有实现接口&lt;a href=&quot;privateclassloader&quot;&gt; &lt;code&gt;PrivateClassLoader&lt;/code&gt; &lt;/a&gt;，则它将添加到MBean Server的 &lt;code&gt;ClassLoaderRepository&lt;/code&gt; 的末尾。如果随后从MBean服务器取消注册，则将其从 &lt;code&gt;ClassLoaderRepository&lt;/code&gt; 中删除。</target>
        </trans-unit>
        <trans-unit id="196aa3134ab9e8ce892612894f6293eb271a9ead" translate="yes" xml:space="preserve">
          <source>When an MBean is registered or unregistered in the MBean server a &lt;a href=&quot;mbeanservernotification&quot;&gt;&lt;code&gt;MBeanServerNotification&lt;/code&gt;&lt;/a&gt; Notification is emitted. To register an object as listener to MBeanServerNotifications you should call the MBean server method &lt;a href=&quot;#addNotificationListener(javax.management.ObjectName,javax.management.NotificationListener,javax.management.NotificationFilter,java.lang.Object)&quot;&gt;&lt;code&gt;addNotificationListener&lt;/code&gt;&lt;/a&gt; with &lt;code&gt;ObjectName&lt;/code&gt; the &lt;code&gt;ObjectName&lt;/code&gt; of the &lt;a href=&quot;mbeanserverdelegate&quot;&gt;&lt;code&gt;MBeanServerDelegate&lt;/code&gt;&lt;/a&gt;. This &lt;code&gt;ObjectName&lt;/code&gt; is:</source>
          <target state="translated">当在MBean服务器中注册或取消注册MBean时，将发出&lt;a href=&quot;mbeanservernotification&quot;&gt; &lt;code&gt;MBeanServerNotification&lt;/code&gt; &lt;/a&gt;通知。要将对象注册为MBeanServerNotifications的侦听器，您应该使用 &lt;code&gt;ObjectName&lt;/code&gt; 和&lt;a href=&quot;mbeanserverdelegate&quot;&gt; &lt;code&gt;MBeanServerDelegate&lt;/code&gt; &lt;/a&gt;的 &lt;code&gt;ObjectName&lt;/code&gt; 调用MBean服务器方法&lt;a href=&quot;#addNotificationListener(javax.management.ObjectName,javax.management.NotificationListener,javax.management.NotificationFilter,java.lang.Object)&quot;&gt; &lt;code&gt;addNotificationListener&lt;/code&gt; &lt;/a&gt;。该 &lt;code&gt;ObjectName&lt;/code&gt; 是：</target>
        </trans-unit>
        <trans-unit id="6757f09ba74310403e9527263bc5d5dd7e032018" translate="yes" xml:space="preserve">
          <source>When an MBean is registered or unregistered in the MBean server a &lt;a href=&quot;mbeanservernotification&quot;&gt;&lt;code&gt;MBeanServerNotification&lt;/code&gt;&lt;/a&gt; Notification is emitted. To register an object as listener to MBeanServerNotifications you should call the MBean server method &lt;a href=&quot;mbeanserver#addNotificationListener-javax.management.ObjectName-javax.management.NotificationListener-javax.management.NotificationFilter-java.lang.Object-&quot;&gt;&lt;code&gt;addNotificationListener&lt;/code&gt;&lt;/a&gt; with &lt;code&gt;ObjectName&lt;/code&gt; the &lt;code&gt;ObjectName&lt;/code&gt; of the &lt;a href=&quot;mbeanserverdelegate&quot;&gt;&lt;code&gt;MBeanServerDelegate&lt;/code&gt;&lt;/a&gt;. This &lt;code&gt;ObjectName&lt;/code&gt; is:</source>
          <target state="translated">在MBean服务器中注册或取消注册MBean时，将发出&lt;a href=&quot;mbeanservernotification&quot;&gt; &lt;code&gt;MBeanServerNotification&lt;/code&gt; &lt;/a&gt;通知。要将对象注册为MBeanServerNotifications的侦听器，应使用 &lt;code&gt;ObjectName&lt;/code&gt; 和&lt;a href=&quot;mbeanserverdelegate&quot;&gt; &lt;code&gt;MBeanServerDelegate&lt;/code&gt; &lt;/a&gt;的 &lt;code&gt;ObjectName&lt;/code&gt; 调用MBean服务器方法&lt;a href=&quot;mbeanserver#addNotificationListener-javax.management.ObjectName-javax.management.NotificationListener-javax.management.NotificationFilter-java.lang.Object-&quot;&gt; &lt;code&gt;addNotificationListener&lt;/code&gt; &lt;/a&gt;。此 &lt;code&gt;ObjectName&lt;/code&gt; 是：</target>
        </trans-unit>
        <trans-unit id="182378d05279b361f0377c3dd82675fe9375ff7d" translate="yes" xml:space="preserve">
          <source>When an SSL handshake completes, new security parameters will have been established. Those parameters always include the security keys used to protect messages. They may also include parameters associated with a new &lt;em&gt;session&lt;/em&gt; such as authenticated peer identity and a new SSL cipher suite.</source>
          <target state="translated">SSL握手完成后，将建立新的安全性参数。这些参数始终包括用于保护消息的安全密钥。它们还可以包括与新&lt;em&gt;会话&lt;/em&gt;关联的参数，例如已验证的对等身份和新的SSL密码套件。</target>
        </trans-unit>
        <trans-unit id="8ab2123a1562813d9a5533055c9f0e64f556bdbf" translate="yes" xml:space="preserve">
          <source>When an action is performed, editing is ended.</source>
          <target state="translated">当执行一个动作时,编辑就结束了。</target>
        </trans-unit>
        <trans-unit id="86ee98b1741c7d393fb679867d1afb4d7f15770b" translate="yes" xml:space="preserve">
          <source>When an agent is specified at JVM launch time this attribute specifies the agent class. That is, the class containing the &lt;code&gt;premain&lt;/code&gt; method. When an agent is specified at JVM launch time this attribute is required. If the attribute is not present the JVM will abort. Note: this is a class name, not a file name or path.</source>
          <target state="translated">在JVM启动时指定代理时，此属性指定代理类。即，包含 &lt;code&gt;premain&lt;/code&gt; 方法的类。在JVM启动时指定了代理时，此属性是必需的。如果该属性不存在，则JVM将中止。注意：这是一个类名，而不是文件名或路径。</target>
        </trans-unit>
        <trans-unit id="f644b84769be94f27ad2e7583fcb5ad584a687f8" translate="yes" xml:space="preserve">
          <source>When an applet is first created, an applet stub is attached to it using the applet's &lt;code&gt;setStub&lt;/code&gt; method. This stub serves as the interface between the applet and the browser environment or applet viewer environment in which the application is running.</source>
          <target state="translated">首次创建小应用程序时，将使用小应用程序的 &lt;code&gt;setStub&lt;/code&gt; 方法将小应用程序存根附加到它。此存根充当applet与运行应用程序的浏览器环境或applet查看器环境之间的接口。</target>
        </trans-unit>
        <trans-unit id="bc9d555379c259dbd7e0e693ef8d791db7a25111" translate="yes" xml:space="preserve">
          <source>When an application adds two or more &lt;code&gt;RowSet&lt;/code&gt; objects to a &lt;code&gt;JoinRowSet&lt;/code&gt; object, the order of the indexes in the array is particularly important. Each index of the array maps directly to the corresponding index of the previously added &lt;code&gt;RowSet&lt;/code&gt; object. If overlap or underlap occurs, the match column data is maintained in the event an additional &lt;code&gt;Joinable&lt;/code&gt; RowSet is added and needs to relate to the match column data. Therefore, applications can set multiple match columns in any order, but this order has a direct effect on the outcome of the &lt;code&gt;SQL&lt;/code&gt; JOIN.</source>
          <target state="translated">当应用程序将两个或多个 &lt;code&gt;RowSet&lt;/code&gt; 对象添加到 &lt;code&gt;JoinRowSet&lt;/code&gt; 对象时，数组中索引的顺序特别重要。数组的每个索引都直接映射到先前添加的 &lt;code&gt;RowSet&lt;/code&gt; 对象的相应索引。如果发生重叠或重叠，则在添加了额外的 &lt;code&gt;Joinable&lt;/code&gt; RowSet且需要与匹配列数据相关的情况下，将保留匹配列数据。因此，应用程序可以按任何顺序设置多个匹配列，但是此顺序对 &lt;code&gt;SQL&lt;/code&gt; JOIN的结果有直接影响。</target>
        </trans-unit>
        <trans-unit id="6004d4830cb9cc2c843dbf654b352672ce73e9de" translate="yes" xml:space="preserve">
          <source>When an application asks to place a character at the position (</source>
          <target state="translated">当一个应用程序要求将一个字符放置在位置(</target>
        </trans-unit>
        <trans-unit id="9e03b89ff80e4bbb4d4255c8faad4eca56a28340" translate="yes" xml:space="preserve">
          <source>When an application calls a method that changes a row, such as the &lt;code&gt;CachedRowSet&lt;/code&gt; methods &lt;code&gt;insertRow&lt;/code&gt;, &lt;code&gt;updateRow&lt;/code&gt;, or &lt;code&gt;deleteRow&lt;/code&gt;, that method calls &lt;code&gt;notifyRowChanged&lt;/code&gt; internally. An application &lt;b&gt;should&lt;/b&gt; never invoke this method directly.</source>
          <target state="translated">当应用程序调用更改行的方法（例如 &lt;code&gt;CachedRowSet&lt;/code&gt; 方法 &lt;code&gt;insertRow&lt;/code&gt; ， &lt;code&gt;updateRow&lt;/code&gt; 或 &lt;code&gt;deleteRow&lt;/code&gt; )时，该方法 &lt;code&gt;notifyRowChanged&lt;/code&gt; 内部调用notifyRowChanged。一个应用程序&lt;b&gt;应该&lt;/b&gt;从来不直接调用此方法。</target>
        </trans-unit>
        <trans-unit id="c0cfa980c0a07be7b7ee79a3cef57eca20e01cc7" translate="yes" xml:space="preserve">
          <source>When an application calls a method to move the cursor, that method moves the cursor and then calls this method internally. An application &lt;b&gt;should&lt;/b&gt; never invoke this method directly.</source>
          <target state="translated">当应用程序调用一种方法移动光标时，该方法将移动光标，然后在内部调用此方法。一个应用程序&lt;b&gt;应该&lt;/b&gt;从来不直接调用此方法。</target>
        </trans-unit>
        <trans-unit id="d78e161e7c07f3b2a15255e1f4967a9555bee575" translate="yes" xml:space="preserve">
          <source>When an application calls methods that change the entire contents of the &lt;code&gt;RowSet&lt;/code&gt; object, such as the &lt;code&gt;CachedRowSet&lt;/code&gt; methods &lt;code&gt;execute&lt;/code&gt;, &lt;code&gt;populate&lt;/code&gt;, &lt;code&gt;restoreOriginal&lt;/code&gt;, or &lt;code&gt;release&lt;/code&gt;, that method calls &lt;code&gt;notifyRowSetChanged&lt;/code&gt; internally (either directly or indirectly). An application &lt;b&gt;should&lt;/b&gt; never invoke this method directly.</source>
          <target state="translated">当应用程序调用更改 &lt;code&gt;RowSet&lt;/code&gt; 对象的全部内容的方法（例如 &lt;code&gt;CachedRowSet&lt;/code&gt; 方法 &lt;code&gt;execute&lt;/code&gt; ， &lt;code&gt;populate&lt;/code&gt; ， &lt;code&gt;restoreOriginal&lt;/code&gt; 或 &lt;code&gt;release&lt;/code&gt; )时，该方法 &lt;code&gt;notifyRowSetChanged&lt;/code&gt; 内部（直接或间接）调用notifyRowSetChanged。一个应用程序&lt;b&gt;应该&lt;/b&gt;从来不直接调用此方法。</target>
        </trans-unit>
        <trans-unit id="a36226b3193ab064f255bcf6893a6f62f93d1f4e" translate="yes" xml:space="preserve">
          <source>When an application calls the method &lt;code&gt;DataSource.getConnection&lt;/code&gt;, it gets back a &lt;code&gt;Connection&lt;/code&gt; object. If connection pooling is being done, that &lt;code&gt;Connection&lt;/code&gt; object is actually a handle to a &lt;code&gt;PooledConnection&lt;/code&gt; object, which is a physical connection.</source>
          <target state="translated">当应用程序调用方法 &lt;code&gt;DataSource.getConnection&lt;/code&gt; 时，它将获取一个 &lt;code&gt;Connection&lt;/code&gt; 对象。如果完成连接池，则该 &lt;code&gt;Connection&lt;/code&gt; 对象实际上是 &lt;code&gt;PooledConnection&lt;/code&gt; 对象的句柄，该对象是物理连接。</target>
        </trans-unit>
        <trans-unit id="7d4d70ec9b9f3f954ef0f33460a4d65e403bee71" translate="yes" xml:space="preserve">
          <source>When an application calls the method &lt;code&gt;PreparedStatement.setObject&lt;/code&gt;, the driver checks to see whether the value to be written is a UDT with a custom mapping. If it is, there will be an entry in a type map containing the &lt;code&gt;Class&lt;/code&gt; object for the class that implements &lt;code&gt;SQLData&lt;/code&gt; for this UDT. If the value to be written is an instance of &lt;code&gt;SQLData&lt;/code&gt;, the driver will create an instance of &lt;code&gt;SQLOutputImpl&lt;/code&gt; and pass it to the method &lt;code&gt;SQLData.writeSQL&lt;/code&gt;. The method &lt;code&gt;writeSQL&lt;/code&gt; in turn calls the appropriate &lt;code&gt;SQLOutputImpl.writeXXX&lt;/code&gt; methods to write data from the &lt;code&gt;SQLData&lt;/code&gt; object to the &lt;code&gt;SQLOutputImpl&lt;/code&gt; output stream as the representation of an SQL user-defined type.</source>
          <target state="translated">当应用程序调用方法 &lt;code&gt;PreparedStatement.setObject&lt;/code&gt; 时，驱动程序将检查要写入的值是否为具有自定义映射的UDT。如果是，则类型映射中将存在一个条目，其中包含为该UDT实现 &lt;code&gt;SQLData&lt;/code&gt; 的类的 &lt;code&gt;Class&lt;/code&gt; 对象。如果要写入的值是 &lt;code&gt;SQLData&lt;/code&gt; 的实例，则驱动程序将创建 &lt;code&gt;SQLOutputImpl&lt;/code&gt; 的实例，并将其传递给方法 &lt;code&gt;SQLData.writeSQL&lt;/code&gt; 。方法 &lt;code&gt;writeSQL&lt;/code&gt; 依次调用适当的 &lt;code&gt;SQLOutputImpl.writeXXX&lt;/code&gt; 方法以将数据从 &lt;code&gt;SQLData&lt;/code&gt; 对象 &lt;code&gt;SQLOutputImpl&lt;/code&gt; 输出流作为SQL用户定义类型的表示形式。</target>
        </trans-unit>
        <trans-unit id="b7f5bb0538901d5f24c63eabe24a7b4f807abe0b" translate="yes" xml:space="preserve">
          <source>When an application calls the method &lt;code&gt;PreparedStatement.setObject&lt;/code&gt;, the driver checks to see whether the value to be written is a UDT with a custom mapping. If it is, there will be an entry in a type map containing the Class object for the class that implements &lt;code&gt;SQLData&lt;/code&gt; for this UDT. If the value to be written is an instance of &lt;code&gt;SQLData&lt;/code&gt;, the driver will create an instance of &lt;code&gt;SQLOutputImpl&lt;/code&gt; and pass it to the method &lt;code&gt;SQLData.writeSQL&lt;/code&gt;. The method &lt;code&gt;writeSQL&lt;/code&gt; in turn calls the appropriate &lt;code&gt;SQLOutputImpl&lt;/code&gt; writer methods to write data from the &lt;code&gt;SQLData&lt;/code&gt; object to the &lt;code&gt;SQLOutputImpl&lt;/code&gt; output stream as the representation of an SQL user-defined type.</source>
          <target state="translated">当应用程序调用方法 &lt;code&gt;PreparedStatement.setObject&lt;/code&gt; 时，驱动程序将检查要写入的值是否为具有自定义映射的UDT。如果是，则类型映射中将存在一个条目，其中包含为该UDT实现 &lt;code&gt;SQLData&lt;/code&gt; 的类的Class对象。如果要写入的值是 &lt;code&gt;SQLData&lt;/code&gt; 的实例，则驱动程序将创建 &lt;code&gt;SQLOutputImpl&lt;/code&gt; 的实例，并将其传递给方法 &lt;code&gt;SQLData.writeSQL&lt;/code&gt; 。方法 &lt;code&gt;writeSQL&lt;/code&gt; 依次调用适当的 &lt;code&gt;SQLOutputImpl&lt;/code&gt; 编写器方法，以将数据从 &lt;code&gt;SQLData&lt;/code&gt; 对象 &lt;code&gt;SQLOutputImpl&lt;/code&gt; 输出流作为SQL用户定义类型的表示形式。</target>
        </trans-unit>
        <trans-unit id="547bc639ed55a09b200965d2bc5a9106a8333ba6" translate="yes" xml:space="preserve">
          <source>When an application closes a connection, it calls the &lt;code&gt;Connection&lt;/code&gt; method &lt;code&gt;close&lt;/code&gt;. When connection pooling is being done, the connection pool manager is notified because it has registered itself as a &lt;code&gt;ConnectionEventListener&lt;/code&gt; object using the &lt;code&gt;ConnectionPool&lt;/code&gt; method &lt;code&gt;addConnectionEventListener&lt;/code&gt;. The connection pool manager deactivates the handle to the &lt;code&gt;PooledConnection&lt;/code&gt; object and returns the &lt;code&gt;PooledConnection&lt;/code&gt; object to the pool of connections so that it can be used again. Thus, when an application closes its connection, the underlying physical connection is recycled rather than being closed.</source>
          <target state="translated">当应用程序关闭连接时，它将调用 &lt;code&gt;Connection&lt;/code&gt; 方法 &lt;code&gt;close&lt;/code&gt; 。连接池完成后，将通知连接池管理器，因为它已使用 &lt;code&gt;ConnectionPool&lt;/code&gt; 方法 &lt;code&gt;addConnectionEventListener&lt;/code&gt; 将自身注册为 &lt;code&gt;ConnectionEventListener&lt;/code&gt; 对象。连接池管理停用句柄 &lt;code&gt;PooledConnection&lt;/code&gt; 对象和返回 &lt;code&gt;PooledConnection&lt;/code&gt; 对象，以便它可以再次使用连接池。因此，当应用程序关闭其连接时，底层物理连接将被回收而不是被关闭。</target>
        </trans-unit>
        <trans-unit id="a52c11dc01aed368f150065ba6a405d66f8451bf" translate="yes" xml:space="preserve">
          <source>When an application creates a new client socket, the socket implementation factory's &lt;code&gt;createSocketImpl&lt;/code&gt; method is called to create the actual socket implementation.</source>
          <target state="translated">当应用程序创建新的客户端套接字时，将调用套接字实现工厂的 &lt;code&gt;createSocketImpl&lt;/code&gt; 方法来创建实际的套接字实现。</target>
        </trans-unit>
        <trans-unit id="5070d5027d76071608fcfd8560f9541c493b061d" translate="yes" xml:space="preserve">
          <source>When an application creates a new datagram socket, the socket implementation factory's &lt;code&gt;createDatagramSocketImpl&lt;/code&gt; method is called to create the actual datagram socket implementation.</source>
          <target state="translated">当应用程序创建新的数据报套接字时，将调用套接字实现工厂的 &lt;code&gt;createDatagramSocketImpl&lt;/code&gt; 方法来创建实际的数据报套接字实现。</target>
        </trans-unit>
        <trans-unit id="53f882e0daa369f43672720af27805bcd63f9c59" translate="yes" xml:space="preserve">
          <source>When an application creates a new server socket, the socket implementation factory's &lt;code&gt;createSocketImpl&lt;/code&gt; method is called to create the actual socket implementation.</source>
          <target state="translated">当应用程序创建新的服务器套接字时，将调用套接字实现工厂的 &lt;code&gt;createSocketImpl&lt;/code&gt; 方法来创建实际的套接字实现。</target>
        </trans-unit>
        <trans-unit id="d3c0e2a071e7ad4e860991ae113034c7a8699231" translate="yes" xml:space="preserve">
          <source>When an application is deployed, it will generally have several codebase directories and JARs in its classpath. JNDI locates (using &lt;a href=&quot;../../../java.base/java/lang/classloader#getResources(java.lang.String)&quot;&gt;&lt;code&gt;ClassLoader.getResources()&lt;/code&gt;&lt;/a&gt;) all &lt;em&gt;application resource files&lt;/em&gt; named &lt;code&gt;jndi.properties&lt;/code&gt; in the classpath. In addition, if the Java installation directory contains a built-in properties file, typically &lt;code&gt;conf/jndi.properties&lt;/code&gt;, JNDI treats it as an additional application resource file. All of the properties contained in these files are placed into the environment of the initial context. This environment is then inherited by other contexts.</source>
          <target state="translated">部署应用程序时，通常在其类路径中将有几个代码库目录和JAR。 JNDI（使用&lt;a href=&quot;../../../java.base/java/lang/classloader#getResources(java.lang.String)&quot;&gt; &lt;code&gt;ClassLoader.getResources()&lt;/code&gt; &lt;/a&gt;）在类路径中找到所有名为 &lt;code&gt;jndi.properties&lt;/code&gt; 的&lt;em&gt;应用程序资源文件&lt;/em&gt;。另外，如果Java安装目录包含一个内置属性文件，通常是 &lt;code&gt;conf/jndi.properties&lt;/code&gt; ，则JNDI会将其视为附加的应用程序资源文件。这些文件中包含的所有属性都放置在初始上下文的环境中。然后，该环境将被其他上下文继承。</target>
        </trans-unit>
        <trans-unit id="6192da6041396e436b94b26592fc040462f804dd" translate="yes" xml:space="preserve">
          <source>When an application is deployed, it will generally have several codebase directories and JARs in its classpath. Similarly, when an applet is deployed, it will have a codebase and archives specifying where to find the applet's classes. JNDI locates (using &lt;a href=&quot;../../java/lang/classloader#getResources-java.lang.String-&quot;&gt;&lt;code&gt;&lt;code&gt;ClassLoader.getResources()&lt;/code&gt;&lt;/code&gt;&lt;/a&gt;) all &lt;em&gt;application resource files&lt;/em&gt; named &lt;code&gt;jndi.properties&lt;/code&gt; in the classpath. In addition, if the file</source>
          <target state="translated">部署应用程序时，它的类路径中通常会包含几个代码库目录和JAR。同样，在部署applet时，它将具有一个代码库和归档文件，用于指定在哪里可以找到applet的类。 JNDI（使用&lt;a href=&quot;../../java/lang/classloader#getResources-java.lang.String-&quot;&gt; &lt;code&gt;&lt;code&gt;ClassLoader.getResources()&lt;/code&gt;&lt;/code&gt; &lt;/a&gt;）在类路径中找到所有名为 &lt;code&gt;jndi.properties&lt;/code&gt; 的&lt;em&gt;应用程序资源文件&lt;/em&gt;。另外，如果文件</target>
        </trans-unit>
        <trans-unit id="ca3e625936706dd988b4e97b8710fc50248f15ec" translate="yes" xml:space="preserve">
          <source>When an attribute list is supplied as part of a &lt;a href=&quot;documenthandler#startElement(java.lang.String,org.xml.sax.AttributeList)&quot;&gt;&lt;code&gt;startElement&lt;/code&gt;&lt;/a&gt; event, the list will return valid results only during the scope of the event; once the event handler returns control to the parser, the attribute list is invalid. To save a persistent copy of the attribute list, use the SAX1 &lt;a href=&quot;helpers/attributelistimpl&quot;&gt;&lt;code&gt;AttributeListImpl&lt;/code&gt;&lt;/a&gt; helper class.</source>
          <target state="translated">当属性列表作为&lt;a href=&quot;documenthandler#startElement(java.lang.String,org.xml.sax.AttributeList)&quot;&gt; &lt;code&gt;startElement&lt;/code&gt; &lt;/a&gt;事件的一部分提供时，该列表将仅在事件范围内返回有效结果；否则，列表将仅在事件范围内返回有效结果。一旦事件处理程序将控制权返回给解析器，则属性列表无效。若要保存属性列表的永久副本，请使用SAX1 &lt;a href=&quot;helpers/attributelistimpl&quot;&gt; &lt;code&gt;AttributeListImpl&lt;/code&gt; &lt;/a&gt;帮助程序类。</target>
        </trans-unit>
        <trans-unit id="5ff3262456581061805ec48c0da1d47a0d84ee27" translate="yes" xml:space="preserve">
          <source>When an event is dispatched to a listener, the listener method (such as &lt;code&gt;objectChanged()&lt;/code&gt;) may be executed in a thread other than the one in which the call to &lt;code&gt;addNamingListener()&lt;/code&gt; was executed. The choice of which thread to use is made by the service provider. When an event is dispatched to multiple listeners, the service provider may choose (and is generally encouraged) to execute the listener methods concurrently in separate threads.</source>
          <target state="translated">将事件调度到侦听器时，侦听器方法（例如 &lt;code&gt;objectChanged()&lt;/code&gt; ）可以在与执行 &lt;code&gt;addNamingListener()&lt;/code&gt; 调用的线程不同的线程中执行。服务提供商选择使用哪个线程。当事件被分派到多个侦听器时，服务提供者可以选择（通常鼓励）在单独的线程中同时执行侦听器方法。</target>
        </trans-unit>
        <trans-unit id="c246ece3865225c2043f5d0d8ebe7428a4313f31" translate="yes" xml:space="preserve">
          <source>When an event is reported to indicate that a file in a watched directory has been modified then there is no guarantee that the program (or programs) that have modified the file have completed. Care should be taken to coordinate access with other programs that may be updating the file. The &lt;a href=&quot;../channels/filechannel&quot;&gt;&lt;code&gt;FileChannel&lt;/code&gt;&lt;/a&gt; class defines methods to lock regions of a file against access by other programs.</source>
          <target state="translated">当报告一个事件以指示监视的目录中的文件已被修改时，则不能保证已修改文件的一个或多个程序已经完成。应注意协调与可能正在更新文件的其他程序的访问。该&lt;a href=&quot;../channels/filechannel&quot;&gt; &lt;code&gt;FileChannel&lt;/code&gt; &lt;/a&gt;类定义以阻止其他程序访问方法对文件的锁定区域。</target>
        </trans-unit>
        <trans-unit id="bf730b9455534606824acbf9cbbe082f2399a34d" translate="yes" xml:space="preserve">
          <source>When an event occurs on a &lt;code&gt;RowSet&lt;/code&gt; object, one of the &lt;code&gt;RowSetListener&lt;/code&gt; methods will be sent to all registered listeners to notify them of the event. An &lt;code&gt;Event&lt;/code&gt; object is supplied to the &lt;code&gt;RowSetListener&lt;/code&gt; method so that the listener can use it to find out which &lt;code&gt;RowSet&lt;/code&gt; object is the source of the event.</source>
          <target state="translated">当 &lt;code&gt;RowSet&lt;/code&gt; 对象上发生事件时，会将 &lt;code&gt;RowSetListener&lt;/code&gt; 方法之一发送给所有已注册的侦听器，以将事件通知给他们。一个 &lt;code&gt;Event&lt;/code&gt; 对象被提供给 &lt;code&gt;RowSetListener&lt;/code&gt; 方法，使得收听者可以用它来找出哪个 &lt;code&gt;RowSet&lt;/code&gt; 对象是事件的来源。</target>
        </trans-unit>
        <trans-unit id="46c3263910b048a89e5d5d0939bdd2c5ae531805" translate="yes" xml:space="preserve">
          <source>When an exception is thrown by a factory, the exception is passed on to the caller of &lt;code&gt;DirectoryManager.getStateToBind()&lt;/code&gt;. The search for other factories that may produce a non-null answer is halted. A factory should only throw an exception if it is sure that it is the only intended factory and that no other factories should be tried. If this factory cannot create an object using the arguments supplied, it should return null.</source>
          <target state="translated">当工厂抛出异常时，该异常将传递给 &lt;code&gt;DirectoryManager.getStateToBind()&lt;/code&gt; 的调用方。停止寻找可能产生非空答案的其他工厂。只有在确定它是唯一打算使用的工厂并且不应尝试其他工厂的情况下，工厂才应该引发异常。如果该工厂无法使用提供的参数创建对象，则应返回null。</target>
        </trans-unit>
        <trans-unit id="86e9ee1cb6edb165bdea53c864741fcfebb100c1" translate="yes" xml:space="preserve">
          <source>When an exception is thrown by a factory, the exception is passed on to the caller of &lt;code&gt;NamingManager.getStateToBind()&lt;/code&gt; and &lt;code&gt;DirectoryManager.getStateToBind()&lt;/code&gt;. The search for other factories that may produce a non-null answer is halted. A factory should only throw an exception if it is sure that it is the only intended factory and that no other factories should be tried. If this factory cannot create an object using the arguments supplied, it should return null.</source>
          <target state="translated">当工厂抛出异常时，该异常将传递给 &lt;code&gt;NamingManager.getStateToBind()&lt;/code&gt; 和 &lt;code&gt;DirectoryManager.getStateToBind()&lt;/code&gt; 的调用方。停止寻找可能产生非空答案的其他工厂。只有在确定它是唯一打算使用的工厂并且不应尝试其他工厂的情况下，工厂才应该引发异常。如果该工厂无法使用提供的参数创建对象，则应返回null。</target>
        </trans-unit>
        <trans-unit id="f619bd42e631fde289b18b2557593f0674f15c8e" translate="yes" xml:space="preserve">
          <source>When an exception is thrown by an object factory, the exception is passed on to the caller of &lt;code&gt;DirectoryManager.getObjectInstance()&lt;/code&gt;. The search for other factories that may produce a non-null answer is halted. An object factory should only throw an exception if it is sure that it is the only intended factory and that no other object factories should be tried. If this factory cannot create an object using the arguments supplied, it should return null.</source>
          <target state="translated">当对象工厂抛出异常时，该异常将传递给 &lt;code&gt;DirectoryManager.getObjectInstance()&lt;/code&gt; 的调用方。停止寻找可能产生非空答案的其他工厂。只有在确定对象工厂是唯一的预期工厂并且不应尝试其他对象工厂的情况下，对象工厂才应引发异常。如果该工厂无法使用提供的参数创建对象，则应返回null。</target>
        </trans-unit>
        <trans-unit id="92d645b31af0488c8796e3e157fa1f6cd126e2c8" translate="yes" xml:space="preserve">
          <source>When an implementation supports operations on entries in the directory that execute in a race-free manner then the returned directory stream is a &lt;a href=&quot;securedirectorystream&quot;&gt;&lt;code&gt;SecureDirectoryStream&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">当实现支持对目录中以无竞争方式执行的条目的操作时，返回的目录流为&lt;a href=&quot;securedirectorystream&quot;&gt; &lt;code&gt;SecureDirectoryStream&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2052382560398859691564bf3c293b964fc894ad" translate="yes" xml:space="preserve">
          <source>When an input source is set (using the &lt;code&gt;setInput&lt;/code&gt; method), it may be marked as &quot;seek forward only&quot;. This setting means that images contained within the input source will only be read in order, possibly allowing the reader to avoid caching portions of the input containing data associated with images that have been read previously.</source>
          <target state="translated">设置输入源（使用 &lt;code&gt;setInput&lt;/code&gt; 方法）时，它可能被标记为&amp;ldquo;仅向前搜索&amp;rdquo;。此设置意味着将仅按顺序读取包含在输入源中的图像，这可能会使阅读器避免将包含与先前已读取的图像相关联的数据的输入部分进行缓存。</target>
        </trans-unit>
        <trans-unit id="7d2fac9efec8951293a4b9ad29501c8bcc43c755" translate="yes" xml:space="preserve">
          <source>When an instance of this class is used as a delegate for the implementation of the BeanContext protocols (and its subprotocols) there exists a 'chicken and egg' problem during deserialization</source>
          <target state="translated">当这个类的实例被用作实现BeanContext协议(及其子协议)的代表时,在反序列化过程中存在一个 &quot;鸡和蛋 &quot;的问题。</target>
        </trans-unit>
        <trans-unit id="f93de7fe2101ac2a970987b76df77b95b8fe1afa" translate="yes" xml:space="preserve">
          <source>When an interior node in the namespace tree has been renamed, the topmost node which is part of the listener's scope should used to generate a rename event. The extent to which this can be supported is provider-specific. For example, a service might generate rename notifications for all descendants of the changed interior node and the corresponding provider might not be able to prevent those notifications from being propagated to the listeners.</source>
          <target state="translated">当命名空间树中的内部节点被重命名时,应使用属于监听器作用域的最上面的节点来生成重命名事件。可以支持的程度是由提供者特定的。例如,一个服务可能会为已更改的内部节点的所有后裔生成重命名通知,而相应的提供者可能无法阻止这些通知传播给监听器。</target>
        </trans-unit>
        <trans-unit id="fd4237ea9c386be63cd7b4f69745e762d3518611" translate="yes" xml:space="preserve">
          <source>When an item is selected or deselected by the user, AWT sends an instance of &lt;code&gt;ItemEvent&lt;/code&gt; to the list. When the user double-clicks on an item in a scrolling list, AWT sends an instance of &lt;code&gt;ActionEvent&lt;/code&gt; to the list following the item event. AWT also generates an action event when the user presses the return key while an item in the list is selected.</source>
          <target state="translated">当用户选择或取消选择某个项目时，AWT会将 &lt;code&gt;ItemEvent&lt;/code&gt; 的一个实例发送到列表中。当用户双击滚动列表中的项目时，AWT会在该项目事件之后将 &lt;code&gt;ActionEvent&lt;/code&gt; 的实例发送到该列表。当用户在选择列表中的项目时按下返回键时，AWT还会生成一个动作事件。</target>
        </trans-unit>
        <trans-unit id="e732ae7cab683d25453439abc7257c33de065d2b" translate="yes" xml:space="preserve">
          <source>When an item's state changes, editing is ended.</source>
          <target state="translated">当一个项目的状态发生变化时,编辑结束。</target>
        </trans-unit>
        <trans-unit id="fbb2b60ef4c108dabfab274ea6d643ccbd813a96" translate="yes" xml:space="preserve">
          <source>When an m-let text file is loaded, an instance of each MBean specified in the file is created and registered.</source>
          <target state="translated">当加载m-let文本文件时,文件中指定的每个MBean的实例被创建并注册。</target>
        </trans-unit>
        <trans-unit id="a6d8aaee8e31c5a9c8176090117cbab7f1fb2776" translate="yes" xml:space="preserve">
          <source>When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used to create a thread, starting the thread causes the object's &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing thread.</source>
          <target state="translated">当使用实现接口 &lt;code&gt;Runnable&lt;/code&gt; 的对象创建线程时，启动线程会导致在单独执行的线程中调用对象的 &lt;code&gt;run&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="d44aeda78b237a6dbd1402c72d9234eba39323f7" translate="yes" xml:space="preserve">
          <source>When an object is registered in the MBean Server using the &lt;code&gt;registerMBean&lt;/code&gt; or &lt;code&gt;createMBean&lt;/code&gt; methods of the &lt;a href=&quot;mbeanserver&quot;&gt;&lt;code&gt;MBeanServer&lt;/code&gt;&lt;/a&gt; interface, the object's class is examined to determine what type of MBean it is:</source>
          <target state="translated">使用&lt;a href=&quot;mbeanserver&quot;&gt; &lt;code&gt;MBeanServer&lt;/code&gt; &lt;/a&gt;接口的 &lt;code&gt;registerMBean&lt;/code&gt; 或 &lt;code&gt;createMBean&lt;/code&gt; 方法在MBean Server中注册对象时，将检查该对象的类以确定它是哪种MBean：</target>
        </trans-unit>
        <trans-unit id="c2972251c7a28b4528fe63074ce4c9c1bf8739a3" translate="yes" xml:space="preserve">
          <source>When an object named &quot;x/y&quot; is subsequently deleted, the corresponding &lt;code&gt;NamingEvent&lt;/code&gt; (&lt;code&gt;evt&lt;/code&gt;) must contain:</source>
          <target state="translated">随后删除名为&amp;ldquo; x / y&amp;rdquo;的对象时，相应的 &lt;code&gt;NamingEvent&lt;/code&gt; （ &lt;code&gt;evt&lt;/code&gt; ）必须包含：</target>
        </trans-unit>
        <trans-unit id="4d30c71c9ef35dac87516151638b387d22978a40" translate="yes" xml:space="preserve">
          <source>When an object of a class implementing the interface &lt;code&gt;SQLData&lt;/code&gt; is passed as an argument to an SQL statement, the JDBC driver calls the method &lt;code&gt;SQLData.getSQLType&lt;/code&gt; to determine the kind of SQL datum being passed to the database. The driver then creates an instance of &lt;code&gt;SQLOutput&lt;/code&gt; and passes it to the method &lt;code&gt;SQLData.writeSQL&lt;/code&gt;. The method &lt;code&gt;writeSQL&lt;/code&gt; in turn calls the appropriate &lt;code&gt;SQLOutput&lt;/code&gt;</source>
          <target state="translated">当将实现接口 &lt;code&gt;SQLData&lt;/code&gt; 的类的对象作为参数传递给SQL语句时，JDBC驱动程序将调用方法 &lt;code&gt;SQLData.getSQLType&lt;/code&gt; 以确定传递给数据库的SQL数据的类型。然后，驱动程序创建一个 &lt;code&gt;SQLOutput&lt;/code&gt; 实例，并将其传递给方法 &lt;code&gt;SQLData.writeSQL&lt;/code&gt; 。方法 &lt;code&gt;writeSQL&lt;/code&gt; 依次调用相应的 &lt;code&gt;SQLOutput&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="918b1ed8da41a8cca49ec39767c9d3ef9075b75b" translate="yes" xml:space="preserve">
          <source>When an observable object is newly created, its set of observers is empty. Two observers are considered the same if and only if the &lt;code&gt;equals&lt;/code&gt; method returns true for them.</source>
          <target state="translated">新创建可观察对象时，其观察者集为空。当且仅当 &lt;code&gt;equals&lt;/code&gt; 方法为其返回true时，两个观察者才被视为相同。</target>
        </trans-unit>
        <trans-unit id="784d4ec1dda97713a3424a2f8d9aa99d1febb449" translate="yes" xml:space="preserve">
          <source>When an observed attribute crosses the high threshold, if the &lt;em&gt;notify high&lt;/em&gt; flag is true, then a notification is sent. Subsequent crossings of the high threshold value will not trigger further notifications until the gauge value becomes less than or equal to the low threshold.</source>
          <target state="translated">当观察到的属性超过上限阈值时，如果&lt;em&gt;notify high&lt;/em&gt;标志为true，则发送通知。直到测量值小于或等于下阈值时，随后超过上限阈值才会触发进一步的通知。</target>
        </trans-unit>
        <trans-unit id="1f5d6ec3eb5a523cc7305bf106145613183ee461" translate="yes" xml:space="preserve">
          <source>When an observed attribute crosses the low threshold, if the &lt;em&gt;notify low&lt;/em&gt; flag is true, then a notification is sent. Subsequent crossings of the low threshold value will not trigger further notifications until the gauge value becomes greater than or equal to the high threshold.</source>
          <target state="translated">当观察到的属性超过下限阈值时，如果&lt;em&gt;notify low&lt;/em&gt;标志为true，则发送通知。直到测量值变得大于或等于高阈值，随后越过低阈值，才触发进一步的通知。</target>
        </trans-unit>
        <trans-unit id="8376d748bc3d8b953550a26d5a316d63742f727e" translate="yes" xml:space="preserve">
          <source>When an output device is stopped, the device usually indicates its condition in human readable form locally at the device. A client can obtain more complete device status remotely by querying the printer's &lt;a href=&quot;printerstate&quot;&gt;&lt;code&gt;PrinterState&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;printerstatereasons&quot;&gt;&lt;code&gt;PrinterStateReasons&lt;/code&gt;&lt;/a&gt; attributes.</source>
          <target state="translated">当输出设备停止时，该设备通常在设备上以人类可读的形式指示其状态。客户端可以通过查询打印机的&lt;a href=&quot;printerstate&quot;&gt; &lt;code&gt;PrinterState&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;printerstatereasons&quot;&gt; &lt;code&gt;PrinterStateReasons&lt;/code&gt; &lt;/a&gt;属性来远程获取更完整的设备状态。</target>
        </trans-unit>
        <trans-unit id="147224cc677f556536d5eca49857d3c86cec24ef" translate="yes" xml:space="preserve">
          <source>When associating an object to a key on a node using &lt;code&gt;Node.setUserData()&lt;/code&gt; the application can provide a handler that gets called when the node the object is associated to is being cloned, imported, or renamed.</source>
          <target state="translated">当使用 &lt;code&gt;Node.setUserData()&lt;/code&gt; 将对象与节点上的键关联时，应用程序可以提供一个处理程序，当与该对象关联的节点被克隆，导入或重命名时，该处理程序将被调用。</target>
        </trans-unit>
        <trans-unit id="2d8993fa1903e158d7bbd09f3a46e487c5d7d23f" translate="yes" xml:space="preserve">
          <source>When associating an object to a key on a node using &lt;code&gt;Node.setUserData()&lt;/code&gt; the application can provide a handler that gets called when the node the object is associated to is being cloned, imported, or renamed. This can be used by the application to implement various behaviors regarding the data it associates to the DOM nodes. This interface defines that handler.</source>
          <target state="translated">当使用 &lt;code&gt;Node.setUserData()&lt;/code&gt; 将对象与节点上的键关联时，应用程序可以提供一个处理程序，当与该对象关联的节点被克隆，导入或重命名时，该处理程序将被调用。应用程序可以使用它来实现与其关联到DOM节点的数据有关的各种行为。此接口定义该处理程序。</target>
        </trans-unit>
        <trans-unit id="226cf009f96b2b42079ae33e7a64348a895c89af" translate="yes" xml:space="preserve">
          <source>When attaching to a target VM, using &lt;a href=&quot;attachingconnector#attach(java.util.Map)&quot;&gt;&lt;code&gt;attach&lt;/code&gt;&lt;/a&gt; this exception may be thrown if the connector supports a timeout &lt;a href=&quot;connector.argument&quot;&gt;&lt;code&gt;connector argument&lt;/code&gt;&lt;/a&gt;. Similiarly, when waiting to accept a connection from a target VM, using &lt;a href=&quot;listeningconnector#accept(java.util.Map)&quot;&gt;&lt;code&gt;accept&lt;/code&gt;&lt;/a&gt; this exception may be thrown if the connector supports a timeout connector argument when accepting.</source>
          <target state="translated">附加到目标VM时，如果连接器支持超时&lt;a href=&quot;connector.argument&quot;&gt; &lt;code&gt;connector argument&lt;/code&gt; &lt;/a&gt;，则使用&lt;a href=&quot;attachingconnector#attach(java.util.Map)&quot;&gt; &lt;code&gt;attach&lt;/code&gt; &lt;/a&gt;可能会引发此异常。类似地，当等待接受来自目标VM的连接时，如果连接器在接受时支持超时连接器参数，则使用&lt;a href=&quot;listeningconnector#accept(java.util.Map)&quot;&gt; &lt;code&gt;accept&lt;/code&gt; &lt;/a&gt;此异常可能会抛出。</target>
        </trans-unit>
        <trans-unit id="18f4b7b2881c180a5a41a1bfe21bf07fe45c228a" translate="yes" xml:space="preserve">
          <source>When automatic drag handling is enabled, most look and feels begin a drag-and-drop operation when the user presses the mouse button over the preview panel. Some look and feels might not support automatic drag and drop; they will ignore this property. You can work around such look and feels by modifying the component to directly call the &lt;code&gt;exportAsDrag&lt;/code&gt; method of a &lt;code&gt;TransferHandler&lt;/code&gt;.</source>
          <target state="translated">启用自动拖动处理后，当用户在预览面板上按下鼠标按钮时，大多数外观都会开始拖放操作。某些外观可能不支持自动拖放；他们将忽略此属性。您可以通过修改组件以直接调用 &lt;code&gt;TransferHandler&lt;/code&gt; 的 &lt;code&gt;exportAsDrag&lt;/code&gt; 方法来解决这种外观。</target>
        </trans-unit>
        <trans-unit id="8a5f68a5a8fdb6dc2c715dafb047525f1aa4d5b6" translate="yes" xml:space="preserve">
          <source>When automatic drag handling is enabled, most look and feels begin a drag-and-drop operation whenever the user presses the mouse button over an item and then moves the mouse a few pixels. Setting this property to &lt;code&gt;true&lt;/code&gt; can therefore have a subtle effect on how selections behave.</source>
          <target state="translated">启用自动拖动处理后，每当用户在项目上按下鼠标按钮然后将鼠标移动几像素时，大多数外观都会开始拖放操作。因此，将此属性设置为 &lt;code&gt;true&lt;/code&gt; 可以对选择的行为产生微妙的影响。</target>
        </trans-unit>
        <trans-unit id="8eb0988bb2d24757a9d15f5c99e1e1f5bc8136ae" translate="yes" xml:space="preserve">
          <source>When automatic redirection occurs, the request method of the redirected request may be modified depending on the specific &lt;code&gt;30X&lt;/code&gt; status code, as specified in &lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt; RFC 7231&lt;/a&gt;. In addition, the &lt;code&gt;301&lt;/code&gt; and &lt;code&gt;302&lt;/code&gt; status codes cause a &lt;code&gt;POST&lt;/code&gt; request to be converted to a &lt;code&gt;GET&lt;/code&gt; in the redirected request.</source>
          <target state="translated">当发生自动重定向时，可以根据&lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC 7231中&lt;/a&gt;指定的特定 &lt;code&gt;30X&lt;/code&gt; 状态代码来修改重定向请求的请求方法。此外， &lt;code&gt;301&lt;/code&gt; 和 &lt;code&gt;302&lt;/code&gt; 状态码会导致 &lt;code&gt;POST&lt;/code&gt; 请求转换为重定向请求中的 &lt;code&gt;GET&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f40895df8451d046636bb5b6689740f6972e5a85" translate="yes" xml:space="preserve">
          <source>When binding to an address and port number, the application can also specify an integer</source>
          <target state="translated">当绑定到地址和端口号时,应用程序还可以指定一个整数的</target>
        </trans-unit>
        <trans-unit id="cf1414265b010571580fbf696282e71d50cfa5f8" translate="yes" xml:space="preserve">
          <source>When both &lt;code&gt;lockedMonitors&lt;/code&gt; and &lt;code&gt;lockedSynchronizers&lt;/code&gt; parameters are &lt;code&gt;false&lt;/code&gt;, it is equivalent to calling:</source>
          <target state="translated">当 &lt;code&gt;lockedMonitors&lt;/code&gt; 和 &lt;code&gt;lockedSynchronizers&lt;/code&gt; 参数均为 &lt;code&gt;false&lt;/code&gt; 时，等效于调用：</target>
        </trans-unit>
        <trans-unit id="b0e8b092db7bbf9a9c972f6aa3306da587cceac0" translate="yes" xml:space="preserve">
          <source>When both the number of rows and the number of columns have been set to non-zero values, either by a constructor or by the &lt;code&gt;setRows&lt;/code&gt; and &lt;code&gt;setColumns&lt;/code&gt; methods, the number of columns specified is ignored. Instead, the number of columns is determined from the specified number of rows and the total number of components in the layout. So, for example, if three rows and two columns have been specified and nine components are added to the layout, they will be displayed as three rows of three columns. Specifying the number of columns affects the layout only when the number of rows is set to zero.</source>
          <target state="translated">当通过构造函数或 &lt;code&gt;setRows&lt;/code&gt; 和 &lt;code&gt;setColumns&lt;/code&gt; 方法将行数和列数均设置为非零值时，将忽略指定的列数。而是由指定的行数和布局中组件的总数确定列数。因此，例如，如果指定了三行两列并将九个组件添加到布局中，则它们将显示为三行三列。仅当行数设置为零时，指定列数才会影响布局。</target>
        </trans-unit>
        <trans-unit id="cada624aa7d2a950cc7dd4e36586280cf654538a" translate="yes" xml:space="preserve">
          <source>When both this flag and the &lt;a href=&quot;../../../../../java.security.jgss/org/ietf/jgss/gsscontext#requestCredDeleg(boolean)&quot;&gt;&lt;code&gt;credentials delegation flag&lt;/code&gt;&lt;/a&gt; are true, delegation will be always tried. However, if the delegation policy does not permit delegation, the value of &lt;a href=&quot;#getDelegPolicyState()&quot;&gt;&lt;code&gt;getDelegPolicyState()&lt;/code&gt;&lt;/a&gt; will be false, even if delegation is performed successfully.</source>
          <target state="translated">当此标志和&lt;a href=&quot;../../../../../java.security.jgss/org/ietf/jgss/gsscontext#requestCredDeleg(boolean)&quot;&gt; &lt;code&gt;credentials delegation flag&lt;/code&gt; &lt;/a&gt;都为true时，将始终尝试委派。但是，如果委派策略不允许委派，则即使成功执行委派，&lt;a href=&quot;#getDelegPolicyState()&quot;&gt; &lt;code&gt;getDelegPolicyState()&lt;/code&gt; &lt;/a&gt;的值也将为false。</target>
        </trans-unit>
        <trans-unit id="3bb6d7fddd6b84f1b1c496762483d19e659acc05" translate="yes" xml:space="preserve">
          <source>When cached value was set.</source>
          <target state="translated">缓存值设置时。</target>
        </trans-unit>
        <trans-unit id="045851de97f115ee864c6b5dbe8a118c8574969c" translate="yes" xml:space="preserve">
          <source>When called by the printing system the &lt;code&gt;Printable&lt;/code&gt; must inspect and honour the supplied PageFormat parameter as well as the page index. The format of the page to be drawn is specified by the supplied PageFormat. The size, orientation and imageable area of the page is therefore already determined and rendering must be within this imageable area. This is key to correct printing behaviour, and it has the implication that the client has the responsibility of tracking what content belongs on the specified page.</source>
          <target state="translated">当打印系统调用 &lt;code&gt;Printable&lt;/code&gt; 时,必须检查并遵守所提供的PageFormat参数以及页面索引。要绘制的页面格式由提供的PageFormat指定。因此，页面的大小，方向和可成像区域已经确定，并且渲染必须在此可成像区域内。这是纠正打印行为的关键，它暗示客户有责任跟踪指定页面上的内容。</target>
        </trans-unit>
        <trans-unit id="ce13d27b64835af608fbc58b333cc41ac2796b65" translate="yes" xml:space="preserve">
          <source>When called off the</source>
          <target state="translated">当被叫停时</target>
        </trans-unit>
        <trans-unit id="866ffa00bf7dcbeb92203e393cd8afd478ae5220" translate="yes" xml:space="preserve">
          <source>When called with &lt;a href=&quot;#invokeExact(java.lang.Object...)&quot;&gt;&lt;code&gt;invokeExact&lt;/code&gt;&lt;/a&gt;, the adapter invokes the target with no argument changes. (&lt;em&gt;Note:&lt;/em&gt; This behavior is different from a &lt;a href=&quot;#asCollector(java.lang.Class,int)&quot;&gt;fixed arity collector&lt;/a&gt;, since it accepts a whole array of indeterminate length, rather than a fixed number of arguments.)</source>
          <target state="translated">当使用&lt;a href=&quot;#invokeExact(java.lang.Object...)&quot;&gt; &lt;code&gt;invokeExact&lt;/code&gt; &lt;/a&gt;进行调用时，适配器将在不更改参数的情况下调用目标。（&lt;em&gt;注意：&lt;/em&gt;此行为不同于&lt;a href=&quot;#asCollector(java.lang.Class,int)&quot;&gt;固定的arity收集器&lt;/a&gt;，因为它接受不确定长度的整个数组，而不是固定数量的参数。）</target>
        </trans-unit>
        <trans-unit id="b53c0fffa0b51e47d71e7136baf9352bd22f9aa3" translate="yes" xml:space="preserve">
          <source>When called with &lt;a href=&quot;methodhandle#invokeExact-java.lang.Object...-&quot;&gt;&lt;code&gt;invokeExact&lt;/code&gt;&lt;/a&gt;, the adapter invokes the target with no argument changes. (&lt;em&gt;Note:&lt;/em&gt; This behavior is different from a &lt;a href=&quot;methodhandle#asCollector-java.lang.Class-int-&quot;&gt;fixed arity collector&lt;/a&gt;, since it accepts a whole array of indeterminate length, rather than a fixed number of arguments.)</source>
          <target state="translated">当使用&lt;a href=&quot;methodhandle#invokeExact-java.lang.Object...-&quot;&gt; &lt;code&gt;invokeExact&lt;/code&gt; &lt;/a&gt;调用时，适配器将在不更改参数的情况下调用目标。（&lt;em&gt;注意：&lt;/em&gt;此行为不同于&lt;a href=&quot;methodhandle#asCollector-java.lang.Class-int-&quot;&gt;固定的arity收集器&lt;/a&gt;，因为它接受不确定长度的整个数组，而不是固定数量的参数。）</target>
        </trans-unit>
        <trans-unit id="31883d2c4cae1cb71309d37302c9eb9553a801df" translate="yes" xml:space="preserve">
          <source>When called with plain, inexact &lt;a href=&quot;#invoke(java.lang.Object...)&quot;&gt;&lt;code&gt;invoke&lt;/code&gt;&lt;/a&gt;, if the caller type is the same as the adapter, the adapter invokes the target as with &lt;code&gt;invokeExact&lt;/code&gt;. (This is the normal behavior for &lt;code&gt;invoke&lt;/code&gt; when types match.)</source>
          <target state="translated">当使用普通的，不精确的&lt;a href=&quot;#invoke(java.lang.Object...)&quot;&gt; &lt;code&gt;invoke&lt;/code&gt; 调用时&lt;/a&gt;，如果调用者的类型与适配器相同，则适配器将像调用 &lt;code&gt;invokeExact&lt;/code&gt; 一样调用目标。（这是类型匹配时 &lt;code&gt;invoke&lt;/code&gt; 的正常行为。）</target>
        </trans-unit>
        <trans-unit id="4a0161ca009c0dbbc06ce2b6680929152732b54d" translate="yes" xml:space="preserve">
          <source>When called with plain, inexact &lt;a href=&quot;methodhandle#invoke-java.lang.Object...-&quot;&gt;&lt;code&gt;invoke&lt;/code&gt;&lt;/a&gt;, if the caller type is the same as the adapter, the adapter invokes the target as with &lt;code&gt;invokeExact&lt;/code&gt;. (This is the normal behavior for &lt;code&gt;invoke&lt;/code&gt; when types match.)</source>
          <target state="translated">当使用普通的，不精确的&lt;a href=&quot;methodhandle#invoke-java.lang.Object...-&quot;&gt; &lt;code&gt;invoke&lt;/code&gt; 调用时&lt;/a&gt;，如果调用者类型与适配器相同，则适配器将像调用 &lt;code&gt;invokeExact&lt;/code&gt; 一样调用目标。（这是类型匹配时 &lt;code&gt;invoke&lt;/code&gt; 的正常行为。）</target>
        </trans-unit>
        <trans-unit id="d2f5017e66f8dea9b28eb6f14ce79dfd0d322eb3" translate="yes" xml:space="preserve">
          <source>When called, indicates that compression should end with the current contents of the input buffer.</source>
          <target state="translated">调用时,表示压缩应该以输入缓冲区的当前内容结束。</target>
        </trans-unit>
        <trans-unit id="f8858e1ea3fd1c36363ba040b10db093a73798d1" translate="yes" xml:space="preserve">
          <source>When called, the adapter replaces a trailing array argument by the array's elements, each as its own argument to the target. (The order of the arguments is preserved.) They are converted pairwise by casting and/or unboxing to the types of the trailing parameters of the target. Finally the target is called. What the target eventually returns is returned unchanged by the adapter.</source>
          <target state="translated">当调用时,适配器用数组的元素替换尾部的数组参数,每个元素都是目标的自己的参数,(保留了参数的顺序。)它们通过转换和/或拆箱转换为目标的尾部参数类型。(参数的顺序被保留。)它们通过转换和/或解盒被转换成目标的尾部参数的类型。最后,目标被调用。target最终返回的内容被适配器原封不动地返回。</target>
        </trans-unit>
        <trans-unit id="32698ba91a41a47b1415719cfb3ee4d88be1ebde" translate="yes" xml:space="preserve">
          <source>When called, the adapter replaces its trailing &lt;code&gt;arrayLength&lt;/code&gt; arguments by a single new array of type &lt;code&gt;arrayType&lt;/code&gt;, whose elements comprise (in order) the replaced arguments. Finally the target is called. What the target eventually returns is returned unchanged by the adapter.</source>
          <target state="translated">调用该适配器时，适配器将使用一个 &lt;code&gt;arrayType&lt;/code&gt; 类型的新数组替换其尾随的 &lt;code&gt;arrayLength&lt;/code&gt; 参数，该数组的元素（按顺序）包括替换的参数。最终目标被调用。目标最终返回的内容将由适配器不变地返回。</target>
        </trans-unit>
        <trans-unit id="1d41427d5f2ba9b4f876eb45c993fa83acbb6861" translate="yes" xml:space="preserve">
          <source>When called, the bound handle inserts the given value &lt;code&gt;x&lt;/code&gt; as a new leading argument to the target. The other arguments are also passed unchanged. What the target eventually returns is returned unchanged by the bound handle.</source>
          <target state="translated">调用时，绑定句柄将给定值 &lt;code&gt;x&lt;/code&gt; 插入为目标的新前导参数。其他参数也保持不变。目标最终返回的内容将由绑定句柄保持不变。</target>
        </trans-unit>
        <trans-unit id="07e47dd6263746d4e6b3656f67f0733f7b685387" translate="yes" xml:space="preserve">
          <source>When called, the handle will treat the first argument as a receiver and dispatch on the receiver's type to determine which method implementation to enter. (The dispatching action is identical with that performed by an &lt;code&gt;invokevirtual&lt;/code&gt; or &lt;code&gt;invokeinterface&lt;/code&gt; instruction.)</source>
          <target state="translated">调用时，句柄会将第一个参数视为接收方，并根据接收方的类型进行分派，以确定要输入的方法实现。（该调度动作是与由执行相同 &lt;code&gt;invokevirtual&lt;/code&gt; 或 &lt;code&gt;invokeinterface&lt;/code&gt; 指令。）</target>
        </trans-unit>
        <trans-unit id="84c71118f0cab56f92d54fd7df74c2d3e7d46279" translate="yes" xml:space="preserve">
          <source>When called, the handle will treat the first argument as a receiver and, for non-private methods, dispatch on the receiver's type to determine which method implementation to enter. For private methods the named method in &lt;code&gt;refc&lt;/code&gt; will be invoked on the receiver. (The dispatching action is identical with that performed by an &lt;code&gt;invokevirtual&lt;/code&gt; or &lt;code&gt;invokeinterface&lt;/code&gt; instruction.)</source>
          <target state="translated">调用时，句柄会将第一个参数视为接收方，对于非私有方法，将按接收方的类型分派以确定要输入的方法实现。对于私有方法，将在接收方上调用 &lt;code&gt;refc&lt;/code&gt; 中的命名方法。 （该调度动作是与由执行相同 &lt;code&gt;invokevirtual&lt;/code&gt; 或 &lt;code&gt;invokeinterface&lt;/code&gt; 指令。）</target>
        </trans-unit>
        <trans-unit id="ddf5901ed93495490773362c9912bfbbd03d6639" translate="yes" xml:space="preserve">
          <source>When calling &lt;code&gt;parseWithContext&lt;/code&gt;, the values of the following configuration parameters will be ignored and their default values will always be used instead: &quot;&lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#parameter-validate&quot;&gt;validate&lt;/a&gt;&quot;, &quot;&lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#parameter-validate-if-schema&quot;&gt;validate-if-schema&lt;/a&gt;&quot;, and &quot;&lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#parameter-element-content-whitespace&quot;&gt;element-content-whitespace&lt;/a&gt;&quot;. Other parameters will be treated normally, and the parser is expected to call the &lt;code&gt;LSParserFilter&lt;/code&gt; just as if a whole document was parsed.</source>
          <target state="translated">当调用 &lt;code&gt;parseWithContext&lt;/code&gt; 时，以下配置参数的值将被忽略，并且将始终使用它们的默认值：&amp;ldquo; &lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#parameter-validate&quot;&gt;validate&lt;/a&gt; &amp;rdquo;，&amp;ldquo; &lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#parameter-validate-if-schema&quot;&gt;validate-if-schema&lt;/a&gt; &amp;rdquo;和&amp;ldquo; &lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#parameter-element-content-whitespace&quot;&gt;element-content-whitespace&lt;/a&gt; &amp;rdquo;。其他参数将被正常处理，并且解析器应调用 &lt;code&gt;LSParserFilter&lt;/code&gt; ,就像解析整个文档一样。</target>
        </trans-unit>
        <trans-unit id="b972447f4e4256626d78384b75e28dd0d79090b5" translate="yes" xml:space="preserve">
          <source>When calling e.g. &lt;a href=&quot;../../../../java.base/java/lang/invoke/varhandle#get(java.lang.Object...)&quot;&gt;&lt;code&gt;VarHandle.get(Object...)&lt;/code&gt;&lt;/a&gt; on the resulting var handle, incoming coordinate values are joined with bound coordinate values, and then passed to the target var handle.</source>
          <target state="translated">在生成的var句柄上调用例如&lt;a href=&quot;../../../../java.base/java/lang/invoke/varhandle#get(java.lang.Object...)&quot;&gt; &lt;code&gt;VarHandle.get(Object...)&lt;/code&gt; &lt;/a&gt;时，传入的坐标值与绑定的坐标值结合在一起，然后传递到目标var句柄。</target>
        </trans-unit>
        <trans-unit id="2d099492a6ffcce03c03ad112011e5bb621e995e" translate="yes" xml:space="preserve">
          <source>When calling e.g. &lt;a href=&quot;../../../../java.base/java/lang/invoke/varhandle#get(java.lang.Object...)&quot;&gt;&lt;code&gt;VarHandle.get(Object...)&lt;/code&gt;&lt;/a&gt; on the resulting var handle, the incoming coordinate values starting at position &lt;code&gt;pos&lt;/code&gt; (of type &lt;code&gt;C1, C2 ... Cn&lt;/code&gt;, where &lt;code&gt;C1, C2 ... Cn&lt;/code&gt; are the return type of the unary filter functions) are transformed into new values (of type &lt;code&gt;S1, S2 ... Sn&lt;/code&gt;, where &lt;code&gt;S1, S2 ... Sn&lt;/code&gt; are the parameter types of the unary filter functions), and then passed (along with any coordinate that was left unaltered by the adaptation) to the target var handle.</source>
          <target state="translated">在生成的var句柄上调用例如&lt;a href=&quot;../../../../java.base/java/lang/invoke/varhandle#get(java.lang.Object...)&quot;&gt; &lt;code&gt;VarHandle.get(Object...)&lt;/code&gt; &lt;/a&gt;时，传入的坐标值从位置 &lt;code&gt;pos&lt;/code&gt; （类型 &lt;code&gt;C1, C2 ... Cn&lt;/code&gt; ，此处 &lt;code&gt;C1, C2 ... Cn&lt;/code&gt; 是一元过滤器函数）转换为新值（类型为 &lt;code&gt;S1, S2 ... Sn&lt;/code&gt; ，其中 &lt;code&gt;S1, S2 ... Sn&lt;/code&gt; 是一元过滤器函数的参数类型），然后传递（以及保持原样不变）到目标var句柄。</target>
        </trans-unit>
        <trans-unit id="57e2cd51c61eee1c12f2f63fe569e6a067bd251e" translate="yes" xml:space="preserve">
          <source>When calling e.g. &lt;a href=&quot;../../../../java.base/java/lang/invoke/varhandle#set(java.lang.Object...)&quot;&gt;&lt;code&gt;VarHandle.set(Object...)&lt;/code&gt;&lt;/a&gt; on the resulting var handle, the incoming value (of type &lt;code&gt;T&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; is the &lt;em&gt;last&lt;/em&gt; parameter type of the first filter function) is processed using the first filter and then passed to the target var handle. Conversely, when calling e.g. &lt;a href=&quot;../../../../java.base/java/lang/invoke/varhandle#get(java.lang.Object...)&quot;&gt;&lt;code&gt;VarHandle.get(Object...)&lt;/code&gt;&lt;/a&gt; on the resulting var handle, the return value obtained from the target var handle (of type &lt;code&gt;T&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; is the &lt;em&gt;last&lt;/em&gt; parameter type of the second filter function) is processed using the second filter and returned to the caller. More advanced access mode types, such as &lt;a href=&quot;../../../../java.base/java/lang/invoke/varhandle.accessmode#COMPARE_AND_EXCHANGE&quot;&gt;&lt;code&gt;VarHandle.AccessMode.COMPARE_AND_EXCHANGE&lt;/code&gt;&lt;/a&gt; might apply both filters at the same time.</source>
          <target state="translated">在生成的var句柄上调用例如&lt;a href=&quot;../../../../java.base/java/lang/invoke/varhandle#set(java.lang.Object...)&quot;&gt; &lt;code&gt;VarHandle.set(Object...)&lt;/code&gt; &lt;/a&gt;时，使用第一个过滤器处理传入的值（类型 &lt;code&gt;T&lt;/code&gt; ，其中 &lt;code&gt;T&lt;/code&gt; 是第一个过滤器函数的&lt;em&gt;最后一个&lt;/em&gt;参数类型），然后将其传递给目标var句柄。相反，在结果var句柄上调用例如&lt;a href=&quot;../../../../java.base/java/lang/invoke/varhandle#get(java.lang.Object...)&quot;&gt; &lt;code&gt;VarHandle.get(Object...)&lt;/code&gt; &lt;/a&gt;，使用以下方法处理从目标var句柄（类型 &lt;code&gt;T&lt;/code&gt; ，其中 &lt;code&gt;T&lt;/code&gt; 是第二个过滤器函数的&lt;em&gt;最后一个&lt;/em&gt;参数类型）获得的返回值。第二个过滤条件，并返回给调用方。更高级的访问模式类型，例如&lt;a href=&quot;../../../../java.base/java/lang/invoke/varhandle.accessmode#COMPARE_AND_EXCHANGE&quot;&gt; &lt;code&gt;VarHandle.AccessMode.COMPARE_AND_EXCHANGE&lt;/code&gt; &lt;/a&gt; 可能会同时应用两个过滤器。</target>
        </trans-unit>
        <trans-unit id="5780deed2c48ceb9857f00bb76c9f644f13d5e00" translate="yes" xml:space="preserve">
          <source>When calling e.g. &lt;a href=&quot;../../../../java.base/java/lang/invoke/varhandle#set(java.lang.Object...)&quot;&gt;&lt;code&gt;VarHandle.set(Object...)&lt;/code&gt;&lt;/a&gt; on the resulting var handle, the incoming value (of type &lt;code&gt;adaptedType&lt;/code&gt;) is converted by a</source>
          <target state="translated">当在结果var句柄上调用例如&lt;a href=&quot;../../../../java.base/java/lang/invoke/varhandle#set(java.lang.Object...)&quot;&gt; &lt;code&gt;VarHandle.set(Object...)&lt;/code&gt; &lt;/a&gt;时，传入的值（类型为 &lt;code&gt;adaptedType&lt;/code&gt; ）由a转换。</target>
        </trans-unit>
        <trans-unit id="2391920a3b69011b129eed441073582d616d0af6" translate="yes" xml:space="preserve">
          <source>When changes are made to this &lt;code&gt;DirContext&lt;/code&gt;, the effect on enumerations returned by prior calls to this method is undefined.</source>
          <target state="translated">对此 &lt;code&gt;DirContext&lt;/code&gt; 进行更改后，对之前调用此方法返回的枚举的影响是不确定的。</target>
        </trans-unit>
        <trans-unit id="5ef4ed8d75e983238d9128ace6321d1ac8ecbb76" translate="yes" xml:space="preserve">
          <source>When choosing which member of a visitor family to subclass, subclassing the most recent one increases the range of source versions covered. When choosing which visitor family to subclass, consider their built-in capabilities:</source>
          <target state="translated">当选择对访客族的哪个成员进行子类时,对最新的成员进行子类可以增加覆盖的源版本范围。在选择对哪个访客族进行子类化时,要考虑它们的内置能力。</target>
        </trans-unit>
        <trans-unit id="903b7e48a00f4b84896728035808586f9ae200f1" translate="yes" xml:space="preserve">
          <source>When color data is stored in an image of this type, the closest color in the colormap is determined by the &lt;code&gt;IndexColorModel&lt;/code&gt; and the resulting index is stored. Approximation and loss of alpha or color components can result, depending on the colors in the &lt;code&gt;IndexColorModel&lt;/code&gt; colormap.</source>
          <target state="translated">当颜色数据存储在此类型的图像中时，颜色表中最接近的颜色由 &lt;code&gt;IndexColorModel&lt;/code&gt; 确定，并存储结果索引。取决于 &lt;code&gt;IndexColorModel&lt;/code&gt; 颜色图中的颜色，可能导致Alpha或颜色分量的近似和丢失。</target>
        </trans-unit>
        <trans-unit id="596a1e26a91b27916ea68a39d5613c909fc17bd2" translate="yes" xml:space="preserve">
          <source>When comparing corresponding components of two URIs, if one component is undefined but the other is defined then the first is considered to be less than the second. Unless otherwise noted, string components are ordered according to their natural, case-sensitive ordering as defined by the &lt;a href=&quot;../lang/comparable#compareTo(T)&quot;&gt;&lt;code&gt;String.compareTo&lt;/code&gt;&lt;/a&gt; method. String components that are subject to encoding are compared by comparing their raw forms rather than their encoded forms.</source>
          <target state="translated">在比较两个URI的相应组件时，如果一个组件未定义，而另一个已定义，则第一个组件小于第二个组件。除非另有说明，否则字符串组件将按照&lt;a href=&quot;../lang/comparable#compareTo(T)&quot;&gt; &lt;code&gt;String.compareTo&lt;/code&gt; &lt;/a&gt;方法定义的自然的，区分大小写的顺序进行排序。通过比较原始格式而不是编码格式来比较要编码的字符串成分。</target>
        </trans-unit>
        <trans-unit id="a1a9496b1bc6bdad32600169e992ba4825384491" translate="yes" xml:space="preserve">
          <source>When comparing corresponding components of two URIs, if one component is undefined but the other is defined then the first is considered to be less than the second. Unless otherwise noted, string components are ordered according to their natural, case-sensitive ordering as defined by the &lt;a href=&quot;../lang/comparable#compareTo-T-&quot;&gt;&lt;code&gt;String.compareTo&lt;/code&gt;&lt;/a&gt; method. String components that are subject to encoding are compared by comparing their raw forms rather than their encoded forms.</source>
          <target state="translated">在比较两个URI的相应组件时，如果一个组件未定义，而另一个已定义，则第一个组件小于第二个组件。除非另有说明，否则字符串组件将按照&lt;a href=&quot;../lang/comparable#compareTo-T-&quot;&gt; &lt;code&gt;String.compareTo&lt;/code&gt; &lt;/a&gt;方法定义的自然的，区分大小写的顺序进行排序。通过比较原始格式而不是编码格式来比较要编码的字符串成分。</target>
        </trans-unit>
        <trans-unit id="2c37c778c7dd1b525f37ac21c51d5e55c91f6a57" translate="yes" xml:space="preserve">
          <source>When comparing corresponding components of two URIs, if one component is undefined but the other is defined then the first is considered to be less than the second. Unless otherwise noted, string components are ordered according to their natural, case-sensitive ordering as defined by the &lt;a href=&quot;../lang/string#compareTo(java.lang.String)&quot;&gt;&lt;code&gt;String.compareTo&lt;/code&gt;&lt;/a&gt; method. String components that are subject to encoding are compared by comparing their raw forms rather than their encoded forms and the hexadecimal digits of escaped octets are compared without regard to case.</source>
          <target state="translated">在比较两个URI的相应组件时，如果一个组件未定义，而另一个已定义，则第一个组件小于第二个组件。除非另有说明，否则字符串组件将按照&lt;a href=&quot;../lang/string#compareTo(java.lang.String)&quot;&gt; &lt;code&gt;String.compareTo&lt;/code&gt; &lt;/a&gt;方法定义的自然的，区分大小写的顺序进行排序。通过比较原始格式而不是编码格式来比较要编码的字符串成分，并且不考虑大小写来比较转义八位字节的十六进制数字。</target>
        </trans-unit>
        <trans-unit id="3f5a301cfb1a53cc09533b6df9b74c243edd2ccf" translate="yes" xml:space="preserve">
          <source>When comparing two version strings, the elements of their corresponding components are compared in pointwise fashion. If one component is longer than the other, but otherwise equal to it, then the first component is considered the greater of the two; otherwise, if two corresponding elements are integers then they are compared as such; otherwise, at least one of the elements is a string, so the other is converted into a string if it is an integer and the two are compared lexicographically. Trailing integer elements with the value zero are ignored.</source>
          <target state="translated">当比较两个版本字符串时,它们对应的组件的元素以点的方式进行比较。如果一个组件比另一个长,但在其他方面与之相等,那么第一个组件被认为是两个组件中较大的一个;否则,如果两个对应的元素是整数,那么就按整数进行比较;否则,至少有一个元素是字符串,所以如果另一个元素是整数,则将其转换为字符串,并对两者进行词法比较。尾部为零的整数元素将被忽略。</target>
        </trans-unit>
        <trans-unit id="766794f1dde5c4c93fc09600ddd1b32f8b44bbe1" translate="yes" xml:space="preserve">
          <source>When comparing two version strings, the value of &lt;code&gt;$OPT&lt;/code&gt;, if present, may or may not be significant depending on the chosen comparison method. The comparison methods &lt;a href=&quot;#compareTo(java.lang.Runtime.Version)&quot;&gt;&lt;code&gt;compareTo()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#compareToIgnoreOptional(java.lang.Runtime.Version)&quot;&gt;&lt;code&gt;compareToIgnoreOptional()&lt;/code&gt;&lt;/a&gt; should be used consistently with the corresponding methods &lt;a href=&quot;#equals(java.lang.Object)&quot;&gt;&lt;code&gt;equals()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#equalsIgnoreOptional(java.lang.Object)&quot;&gt;&lt;code&gt;equalsIgnoreOptional()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">比较两个版本字符串时， &lt;code&gt;$OPT&lt;/code&gt; 的值（如果存在）可能会或可能不会很重要，具体取决于所选的比较方法。比较方法&lt;a href=&quot;#compareTo(java.lang.Runtime.Version)&quot;&gt; &lt;code&gt;compareTo()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#compareToIgnoreOptional(java.lang.Runtime.Version)&quot;&gt; &lt;code&gt;compareToIgnoreOptional()&lt;/code&gt; &lt;/a&gt;应与相应的&lt;a href=&quot;#equals(java.lang.Object)&quot;&gt; &lt;code&gt;equals()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#equalsIgnoreOptional(java.lang.Object)&quot;&gt; &lt;code&gt;equalsIgnoreOptional()&lt;/code&gt; &lt;/a&gt;方法一致使用。</target>
        </trans-unit>
        <trans-unit id="2103fe1187cedfb38f65d7ce9c0819c612ec17eb" translate="yes" xml:space="preserve">
          <source>When computing a date and time from the calendar fields, there may be insufficient information for the computation (such as only year and month with no day of month), or there may be inconsistent information (such as Tuesday, July 15, 1996 (Gregorian) -- July 15, 1996 is actually a Monday). &lt;code&gt;Calendar&lt;/code&gt; will resolve calendar field values to determine the date and time in the following way.</source>
          <target state="translated">从日历字段计算日期和时间时，可能没有足够的信息来进行计算（例如只有年份和月份而没有月份），或者可能有不一致的信息（例如1996年7月15日，星期二） ）-1996年7月15日实际上是一个星期一）。 &lt;code&gt;Calendar&lt;/code&gt; 将以以下方式解析日历字段值以确定日期和时间。</target>
        </trans-unit>
        <trans-unit id="0dcc686243f0157dc4e782a735e5dde3570a33bc" translate="yes" xml:space="preserve">
          <source>When concatenated with a class attribute name, indicates the format of that attribute, using the layout language specified in the JSR 200 specification.</source>
          <target state="translated">当与类属性名连在一起时,表示该属性的格式,使用JSR 200规范中指定的布局语言。</target>
        </trans-unit>
        <trans-unit id="bb74f60e238e6eeac7b5d4c50c88953481c44a68" translate="yes" xml:space="preserve">
          <source>When concatenated with a code attribute name, indicates the format of that attribute.</source>
          <target state="translated">当与代码属性名连在一起时,表示该属性的格式。</target>
        </trans-unit>
        <trans-unit id="1e9e7edd39470beed21937a91c20e5bb29b65a00" translate="yes" xml:space="preserve">
          <source>When concatenated with a code attribute name, indicates the format of that attribute. For example, the effect of this option is built in: &lt;code&gt;pack.code.attribute.LocalVariableTable=NH[PHOHRUHRSHH]&lt;/code&gt;. The special strings &lt;a href=&quot;#ERROR&quot;&gt;&lt;code&gt;ERROR&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#STRIP&quot;&gt;&lt;code&gt;STRIP&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#PASS&quot;&gt;&lt;code&gt;PASS&lt;/code&gt;&lt;/a&gt; are also allowed.</source>
          <target state="translated">与代码属性名称连接时，指示该属性的格式。例如，此选项的效果内置于： &lt;code&gt;pack.code.attribute.LocalVariableTable=NH[PHOHRUHRSHH]&lt;/code&gt; 。还允许使用特殊字符串&lt;a href=&quot;#ERROR&quot;&gt; &lt;code&gt;ERROR&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#STRIP&quot;&gt; &lt;code&gt;STRIP&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#PASS&quot;&gt; &lt;code&gt;PASS&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6c481650236192705c8984496664400b25ae4018" translate="yes" xml:space="preserve">
          <source>When concatenated with a code attribute name, indicates the format of that attribute. For example, the effect of this option is built in: &lt;code&gt;pack.code.attribute.LocalVariableTable=NH[PHOHRUHRSHH]&lt;/code&gt;. The special strings &lt;a href=&quot;pack200.packer#ERROR&quot;&gt;&lt;code&gt;ERROR&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;pack200.packer#STRIP&quot;&gt;&lt;code&gt;STRIP&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;pack200.packer#PASS&quot;&gt;&lt;code&gt;PASS&lt;/code&gt;&lt;/a&gt; are also allowed.</source>
          <target state="translated">与代码属性名称连接时，指示该属性的格式。例如，此选项的效果内置于： &lt;code&gt;pack.code.attribute.LocalVariableTable=NH[PHOHRUHRSHH]&lt;/code&gt; 。还允许使用特殊字符串&lt;a href=&quot;pack200.packer#ERROR&quot;&gt; &lt;code&gt;ERROR&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;pack200.packer#STRIP&quot;&gt; &lt;code&gt;STRIP&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;pack200.packer#PASS&quot;&gt; &lt;code&gt;PASS&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ceb1ddea1eb879c6878c1a1d7674d5ebeef2e985" translate="yes" xml:space="preserve">
          <source>When concatenated with a field attribute name, indicates the format of that attribute.</source>
          <target state="translated">当与字段属性名连在一起时,表示该属性的格式。</target>
        </trans-unit>
        <trans-unit id="47883ebf03b00718b34fcc759408570310a33897" translate="yes" xml:space="preserve">
          <source>When concatenated with a field attribute name, indicates the format of that attribute. For example, the effect of this option is built in: &lt;code&gt;pack.field.attribute.Deprecated=&lt;/code&gt;. The special strings &lt;a href=&quot;#ERROR&quot;&gt;&lt;code&gt;ERROR&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#STRIP&quot;&gt;&lt;code&gt;STRIP&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#PASS&quot;&gt;&lt;code&gt;PASS&lt;/code&gt;&lt;/a&gt; are also allowed.</source>
          <target state="translated">与字段属性名称连接时，指示该属性的格式。例如，此选项的效果内置于： &lt;code&gt;pack.field.attribute.Deprecated=&lt;/code&gt; 。还允许使用特殊字符串&lt;a href=&quot;#ERROR&quot;&gt; &lt;code&gt;ERROR&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#STRIP&quot;&gt; &lt;code&gt;STRIP&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#PASS&quot;&gt; &lt;code&gt;PASS&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="69b68d3b1ed8dc49253990c27eccbd09190abb43" translate="yes" xml:space="preserve">
          <source>When concatenated with a field attribute name, indicates the format of that attribute. For example, the effect of this option is built in: &lt;code&gt;pack.field.attribute.Deprecated=&lt;/code&gt;. The special strings &lt;a href=&quot;pack200.packer#ERROR&quot;&gt;&lt;code&gt;ERROR&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;pack200.packer#STRIP&quot;&gt;&lt;code&gt;STRIP&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;pack200.packer#PASS&quot;&gt;&lt;code&gt;PASS&lt;/code&gt;&lt;/a&gt; are also allowed.</source>
          <target state="translated">与字段属性名称连接时，指示该属性的格式。例如，此选项的效果内置于： &lt;code&gt;pack.field.attribute.Deprecated=&lt;/code&gt; 。还允许使用特殊字符串&lt;a href=&quot;pack200.packer#ERROR&quot;&gt; &lt;code&gt;ERROR&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;pack200.packer#STRIP&quot;&gt; &lt;code&gt;STRIP&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;pack200.packer#PASS&quot;&gt; &lt;code&gt;PASS&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="33a1709395545b56f118dfdd106e7258d9b8f06b" translate="yes" xml:space="preserve">
          <source>When concatenated with a method attribute name, indicates the format of that attribute.</source>
          <target state="translated">与方法属性名连在一起时,表示该属性的格式。</target>
        </trans-unit>
        <trans-unit id="c8da13828fde7c93e320323d44f6b62e3d17a27c" translate="yes" xml:space="preserve">
          <source>When concatenated with a method attribute name, indicates the format of that attribute. For example, the effect of this option is built in: &lt;code&gt;pack.method.attribute.Exceptions=NH[RCH]&lt;/code&gt;. The special strings &lt;a href=&quot;#ERROR&quot;&gt;&lt;code&gt;ERROR&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#STRIP&quot;&gt;&lt;code&gt;STRIP&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#PASS&quot;&gt;&lt;code&gt;PASS&lt;/code&gt;&lt;/a&gt; are also allowed.</source>
          <target state="translated">与方法属性名称连接时，指示该属性的格式。例如，此选项的效果内置于： &lt;code&gt;pack.method.attribute.Exceptions=NH[RCH]&lt;/code&gt; 。还允许使用特殊字符串&lt;a href=&quot;#ERROR&quot;&gt; &lt;code&gt;ERROR&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#STRIP&quot;&gt; &lt;code&gt;STRIP&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#PASS&quot;&gt; &lt;code&gt;PASS&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b1b39538a51627baa398137ae5124f3674a47944" translate="yes" xml:space="preserve">
          <source>When concatenated with a method attribute name, indicates the format of that attribute. For example, the effect of this option is built in: &lt;code&gt;pack.method.attribute.Exceptions=NH[RCH]&lt;/code&gt;. The special strings &lt;a href=&quot;pack200.packer#ERROR&quot;&gt;&lt;code&gt;ERROR&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;pack200.packer#STRIP&quot;&gt;&lt;code&gt;STRIP&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;pack200.packer#PASS&quot;&gt;&lt;code&gt;PASS&lt;/code&gt;&lt;/a&gt; are also allowed.</source>
          <target state="translated">与方法属性名称连接时，指示该属性的格式。例如，此选项的效果内置于： &lt;code&gt;pack.method.attribute.Exceptions=NH[RCH]&lt;/code&gt; 。还允许使用特殊字符串&lt;a href=&quot;pack200.packer#ERROR&quot;&gt; &lt;code&gt;ERROR&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;pack200.packer#STRIP&quot;&gt; &lt;code&gt;STRIP&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;pack200.packer#PASS&quot;&gt; &lt;code&gt;PASS&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="715e1e84dcaa0489832f5e6cede42eba32b7afd9" translate="yes" xml:space="preserve">
          <source>When constructed as fair, threads contend for entry using an approximately arrival-order policy. When the currently held lock is released, either the longest-waiting single writer thread will be assigned the write lock, or if there is a group of reader threads waiting longer than all waiting writer threads, that group will be assigned the read lock.</source>
          <target state="translated">当构造为公平时,线程使用大约到达顺序的策略争夺进入。当当前持有的锁被释放时,等待时间最长的单个写作者线程将被分配到写锁,或者如果有一组读者线程的等待时间长于所有等待的写作者线程,该组线程将被分配到读锁。</target>
        </trans-unit>
        <trans-unit id="61fbad8d5157fa12e2924a0b101d7488fca8edd0" translate="yes" xml:space="preserve">
          <source>When constructed as non-fair (the default), the order of entry to the read and write lock is unspecified, subject to reentrancy constraints. A nonfair lock that is continuously contended may indefinitely postpone one or more reader or writer threads, but will normally have higher throughput than a fair lock.</source>
          <target state="translated">当构造为非公平锁(默认)时,读写锁的进入顺序是不指定的,受重入约束。一个持续争用的非公平锁可能会无限期地推迟一个或多个读写线程,但通常会比公平锁有更高的吞吐量。</target>
        </trans-unit>
        <trans-unit id="0e952a0329782ab3d664a78b3d191c4eda125051" translate="yes" xml:space="preserve">
          <source>When constructing a JAR url via &lt;code&gt;new URL(context, spec)&lt;/code&gt;, the following rules apply:</source>
          <target state="translated">通过 &lt;code&gt;new URL(context, spec)&lt;/code&gt; 构造JAR url时，适用以下规则：</target>
        </trans-unit>
        <trans-unit id="41c8b69db960d9e4b36a2e8b2f092f79ddba9a4f" translate="yes" xml:space="preserve">
          <source>When constructing new JavaFileObjects, the file manager must determine where to create them. For example, if a file manager manages regular files on a file system, it would most likely have a current/working directory to use as default location when creating or finding files. A number of hints can be provided to a file manager as to where to create files. Any file manager might choose to ignore these hints.</source>
          <target state="translated">在构造新的JavaFileObjects时,文件管理器必须确定在哪里创建它们。例如,如果一个文件管理器管理文件系统上的常规文件,它很可能会有一个当前/工作目录作为创建或查找文件时的默认位置。在创建文件的位置上,可以向文件管理器提供一些提示。任何文件管理器都可能选择忽略这些提示。</target>
        </trans-unit>
        <trans-unit id="a964eaa3b3cf4ad1eed4195c0e00287e21036db6" translate="yes" xml:space="preserve">
          <source>When converting back to &lt;code&gt;ZonedDateTime&lt;/code&gt;, if the local date-time is in an overlap, then the offset will be retained if possible, otherwise the earlier offset will be used. If in a gap, the local date-time will be adjusted forward by the length of the gap.</source>
          <target state="translated">当转换回 &lt;code&gt;ZonedDateTime&lt;/code&gt; 时，如果本地日期时间重叠，则将尽可能保留偏移量，否则将使用更早的偏移量。如果有间隔，则本地日期时间将根据间隔的长度向前调整。</target>
        </trans-unit>
        <trans-unit id="da70171e9e306ca307ebacfcf0e847c01479df72" translate="yes" xml:space="preserve">
          <source>When copy of the object is retrieved (via the &lt;code&gt;get&lt;/code&gt; method), if the class is not available locally, it will be loaded from the appropriate location (specified the URL annotated with the class descriptor when the class was serialized.</source>
          <target state="translated">当检索到对象的副本（通过 &lt;code&gt;get&lt;/code&gt; 方法）时，如果该类在本地不可用，它将从适当的位置（指定了在序列化该类时用类描述符注释的URL）进行加载。</target>
        </trans-unit>
        <trans-unit id="335335544c2a50cfd694c3a55d6ae8a94af447f1" translate="yes" xml:space="preserve">
          <source>When copying a float or double source to an integral type destination, each source sample is cast to the destination type. When copying an integral type source to a float or double destination, the source is first converted to a 32-bit int (if necessary), using the above rules for integral types, and then the int is cast to float or double.</source>
          <target state="translated">当把一个浮点或双数源复制到一个积分类型的目的地时,每个源样本都会被转换为目的地类型。当将积分类型源复制到浮点或双目标时,首先使用上述积分类型的规则将源转换为32位的int(如有必要),然后将int转为浮点或双。</target>
        </trans-unit>
        <trans-unit id="3ade72b52f46fe9735881965253dded0d6c147b2" translate="yes" xml:space="preserve">
          <source>When created, the default implementation of &lt;code&gt;ActivationGroup&lt;/code&gt; will override the system properties with the properties requested when its &lt;code&gt;ActivationGroupDesc&lt;/code&gt; was created, and will set a &lt;a href=&quot;../../../../java.base/java/lang/securitymanager&quot;&gt;&lt;code&gt;SecurityManager&lt;/code&gt;&lt;/a&gt; as the default system security manager. If your application requires specific properties to be set when objects are activated in the group, the application should create a special &lt;code&gt;Properties&lt;/code&gt; object containing these properties, then create an &lt;code&gt;ActivationGroupDesc&lt;/code&gt; with the &lt;code&gt;Properties&lt;/code&gt; object, and use &lt;code&gt;ActivationGroup.createGroup&lt;/code&gt; before creating any &lt;code&gt;ActivationDesc&lt;/code&gt;s (before the default &lt;code&gt;ActivationGroupDesc&lt;/code&gt; is created). If your application requires the use of a security manager other than &lt;a href=&quot;../../../../java.base/java/lang/securitymanager&quot;&gt;&lt;code&gt;SecurityManager&lt;/code&gt;&lt;/a&gt;, in the ActivativationGroupDescriptor properties list you can set &lt;code&gt;java.security.manager&lt;/code&gt; property to the name of the security manager you would like to install.</source>
          <target state="translated">创建后， &lt;code&gt;ActivationGroup&lt;/code&gt; 的默认实现将使用创建其 &lt;code&gt;ActivationGroupDesc&lt;/code&gt; 时请求的属性覆盖系统属性，并将&lt;a href=&quot;../../../../java.base/java/lang/securitymanager&quot;&gt; &lt;code&gt;SecurityManager&lt;/code&gt; &lt;/a&gt;设置为默认系统安全管理器。如果应用程序需要特定的属性进行设置，当对象组中被激活，应用程序应该创建一个特殊的 &lt;code&gt;Properties&lt;/code&gt; 对象包含这些属性，然后创建一个 &lt;code&gt;ActivationGroupDesc&lt;/code&gt; 与 &lt;code&gt;Properties&lt;/code&gt; 的对象，并使用 &lt;code&gt;ActivationGroup.createGroup&lt;/code&gt; 创建任何前 &lt;code&gt;ActivationDesc&lt;/code&gt; 年代以前（默认的 &lt;code&gt;ActivationGroupDesc&lt;/code&gt; 被建造）。如果您的应用程序需要使用除&lt;a href=&quot;../../../../java.base/java/lang/securitymanager&quot;&gt; &lt;code&gt;SecurityManager&lt;/code&gt; 之外的&lt;/a&gt;其他安全管理器，则可以在ActivativationGroupDescriptor属性列表中将 &lt;code&gt;java.security.manager&lt;/code&gt; 属性设置为要安装的安全管理器的名称。</target>
        </trans-unit>
        <trans-unit id="330033318b9b32fd36ddd46bb1ced3469157a8be" translate="yes" xml:space="preserve">
          <source>When creating a &lt;code&gt;ChoiceFormat&lt;/code&gt;, you must specify an array of formats and an array of limits. The length of these arrays must be the same. For example,</source>
          <target state="translated">创建 &lt;code&gt;ChoiceFormat&lt;/code&gt; 时，必须指定一个格式数组和一个限制数组。这些数组的长度必须相同。例如，</target>
        </trans-unit>
        <trans-unit id="09c8af312b3d6fd01641b9e7028cc827b52cff1d" translate="yes" xml:space="preserve">
          <source>When creating a &lt;code&gt;Graphics2D&lt;/code&gt; object, the &lt;code&gt;GraphicsConfiguration&lt;/code&gt; specifies the &lt;a id=&quot;deftransform&quot;&gt;default transform&lt;/a&gt; for the target of the &lt;code&gt;Graphics2D&lt;/code&gt; (a &lt;a href=&quot;component&quot;&gt;&lt;code&gt;Component&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;image&quot;&gt;&lt;code&gt;Image&lt;/code&gt;&lt;/a&gt;). This default transform maps the user space coordinate system to screen and printer device coordinates such that the origin maps to the upper left hand corner of the target region of the device with increasing X coordinates extending to the right and increasing Y coordinates extending downward. The scaling of the default transform is set to identity for those devices that are close to 72 dpi, such as screen devices. The scaling of the default transform is set to approximately 72 user space coordinates per square inch for high resolution devices, such as printers. For image buffers, the default transform is the &lt;code&gt;Identity&lt;/code&gt; transform.</source>
          <target state="translated">创建 &lt;code&gt;Graphics2D&lt;/code&gt; 对象时， &lt;code&gt;GraphicsConfiguration&lt;/code&gt; 为 &lt;code&gt;Graphics2D&lt;/code&gt; 目标（&lt;a href=&quot;component&quot;&gt; &lt;code&gt;Component&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;image&quot;&gt; &lt;code&gt;Image&lt;/code&gt; &lt;/a&gt;指定&lt;a id=&quot;deftransform&quot;&gt;默认转换&lt;/a&gt;。）。此默认转换将用户空间坐标系映射到屏幕和打印机设备坐标，以使原点映射到设备目标区域的左上角，其中X坐标向右延伸，Y坐标向下延伸。默认转换的缩放比例设置为标识那些接近72 dpi的设备（例如屏幕设备）的身份。对于高分辨率设备（例如打印机），默认变换的缩放比例设置为每平方英寸约72个用户空间坐标。对于图像缓冲区，默认转换是 &lt;code&gt;Identity&lt;/code&gt; 转换。</target>
        </trans-unit>
        <trans-unit id="8c146d0b369274554520e962246ecbdade5c4558" translate="yes" xml:space="preserve">
          <source>When creating a &lt;code&gt;KerberosKey&lt;/code&gt; using the &lt;a href=&quot;#%3Cinit%3E(javax.security.auth.kerberos.KerberosPrincipal,char%5B%5D,java.lang.String)&quot;&gt;&lt;code&gt;KerberosKey(KerberosPrincipal, char[], String)&lt;/code&gt;&lt;/a&gt; constructor, an implementation may accept non-IANA algorithm names (For example, &quot;ArcFourMac&quot; for &quot;rc4-hmac&quot;), but the &lt;a href=&quot;#getAlgorithm()&quot;&gt;&lt;code&gt;getAlgorithm()&lt;/code&gt;&lt;/a&gt; method must always return the IANA algorithm name.</source>
          <target state="translated">当创建一个 &lt;code&gt;KerberosKey&lt;/code&gt; 使用&lt;a href=&quot;#%3Cinit%3E(javax.security.auth.kerberos.KerberosPrincipal,char%5B%5D,java.lang.String)&quot;&gt; &lt;code&gt;KerberosKey(KerberosPrincipal, char[], String)&lt;/code&gt; &lt;/a&gt;的构造，此实施方案可接受非IANA算法的名称（例如，&amp;ldquo;ArcFourMac&amp;rdquo;为&amp;ldquo;RC4-HMAC&amp;rdquo;），但&lt;a href=&quot;#getAlgorithm()&quot;&gt; &lt;code&gt;getAlgorithm()&lt;/code&gt; &lt;/a&gt;方法必须总是返回IANA算法名称。</target>
        </trans-unit>
        <trans-unit id="9b38bad41028682d65ecb4198fe6abc7015b87c2" translate="yes" xml:space="preserve">
          <source>When creating a &lt;code&gt;Paper&lt;/code&gt; object, it is the application's responsibility to ensure that the paper size and the imageable area are compatible. For example, if the paper size is changed from 11 x 17 to 8.5 x 11, the application might need to reduce the imageable area so that whatever is printed fits on the page.</source>
          <target state="translated">创建 &lt;code&gt;Paper&lt;/code&gt; 对象时，应用程序有责任确保纸张尺​​寸和可成像区域兼容。例如，如果纸张尺寸从11 x 17更改为8.5 x 11，则应用程序可能需要缩小可成像区域，以使所打印的内容适合页面。</target>
        </trans-unit>
        <trans-unit id="f380ad1809365a52c2f779b295ad176ba7cee1fe" translate="yes" xml:space="preserve">
          <source>When creating a &lt;code&gt;TimeZone&lt;/code&gt;, the specified custom time zone ID is normalized in the following syntax:</source>
          <target state="translated">创建 &lt;code&gt;TimeZone&lt;/code&gt; 时，将使用以下语法对指定的自定义时区ID进行规范化：</target>
        </trans-unit>
        <trans-unit id="105221734ccfc8a498e02b002ab64f6bd84a44d9" translate="yes" xml:space="preserve">
          <source>When creating a connector client or server, it is possible to supply an object of type &lt;a href=&quot;../../../../java.base/java/util/map&quot;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt; that defines additional parameters. Each entry in this Map has a key that is a string and an associated value whose type is appropriate for that key. The standard keys defined by the JMX Remote API all begin with the string &quot;&lt;code&gt;jmx.remote.&lt;/code&gt;&quot;. The document &lt;em&gt;JMX Remote API&lt;/em&gt; lists these standard keys.</source>
          <target state="translated">创建连接器客户端或服务器时，可以提供定义附加参数的&lt;a href=&quot;../../../../java.base/java/util/map&quot;&gt; &lt;code&gt;Map&lt;/code&gt; &lt;/a&gt;类型的对象。此映射中的每个条目都有一个键，该键是一个字符串和一个关联的值，其类型适用于该键。 JMX远程API定义的标准密钥均以字符串&amp;ldquo; &lt;code&gt;jmx.remote.&lt;/code&gt; &amp;rdquo;开头。文档&lt;em&gt;JMX Remote API&lt;/em&gt;列出了这些标准密钥。</target>
        </trans-unit>
        <trans-unit id="b9ab1915b79f38ba00b3dd084c59f43fd7b1a097" translate="yes" xml:space="preserve">
          <source>When creating a connector client or server, it is possible to supply an object of type &lt;a href=&quot;../../../java/util/map&quot;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt; that defines additional parameters. Each entry in this Map has a key that is a string and an associated value whose type is appropriate for that key. The standard keys defined by the JMX Remote API all begin with the string &quot;&lt;code&gt;jmx.remote.&lt;/code&gt;&quot;. The document &lt;em&gt;JMX Remote API&lt;/em&gt; lists these standard keys.</source>
          <target state="translated">创建连接器客户端或服务器时，可以提供定义附加参数的&lt;a href=&quot;../../../java/util/map&quot;&gt; &lt;code&gt;Map&lt;/code&gt; &lt;/a&gt;类型的对象。此映射中的每个条目都有一个键，该键是一个字符串和一个关联的值，其类型适用于该键。JMX远程API定义的标准密钥均以字符串&amp;ldquo; &lt;code&gt;jmx.remote.&lt;/code&gt; &amp;rdquo; 开头。文档&lt;em&gt;JMX远程API&lt;/em&gt;列出了这些标准密钥。</target>
        </trans-unit>
        <trans-unit id="96d5bb0b77a90195ba6f2cbc3333bf0e862753f3" translate="yes" xml:space="preserve">
          <source>When creating a new file this option is a &lt;em&gt;hint&lt;/em&gt; that the new file will be sparse. This option is ignored when not creating a new file.</source>
          <target state="translated">创建新文件时，此选项&lt;em&gt;提示&lt;/em&gt;新文件将是稀疏的。不创建新文件时，将忽略此选项。</target>
        </trans-unit>
        <trans-unit id="c39abb2d7aabb3ded864546db651700da7057721" translate="yes" xml:space="preserve">
          <source>When creating a subclass of InitialContext, use this method as follows. Define a new method that uses this method to get an initial context of the desired subclass.</source>
          <target state="translated">当创建InitialContext的子类时,使用该方法如下。定义一个新的方法,使用这个方法来获取所需子类的初始上下文。</target>
        </trans-unit>
        <trans-unit id="d46d936e93bb8a599591119f0d596c9ab0f11f7e" translate="yes" xml:space="preserve">
          <source>When data has been received, the &lt;code&gt;WebSocket&lt;/code&gt; invokes a receive method. Methods &lt;code&gt;onText&lt;/code&gt;, &lt;code&gt;onBinary&lt;/code&gt;, &lt;code&gt;onPing&lt;/code&gt; and &lt;code&gt;onPong&lt;/code&gt; must return a &lt;code&gt;CompletionStage&lt;/code&gt; that completes once the message has been received by the listener. If a listener's method returns &lt;code&gt;null&lt;/code&gt; rather than a &lt;code&gt;CompletionStage&lt;/code&gt;, &lt;code&gt;WebSocket&lt;/code&gt; will behave as if the listener returned a &lt;code&gt;CompletionStage&lt;/code&gt; that is already completed normally.</source>
          <target state="translated">接收到数据后， &lt;code&gt;WebSocket&lt;/code&gt; 会调用一个接收方法。方法 &lt;code&gt;onText&lt;/code&gt; ， &lt;code&gt;onBinary&lt;/code&gt; ， &lt;code&gt;onPing&lt;/code&gt; 和 &lt;code&gt;onPong&lt;/code&gt; 必须返回 &lt;code&gt;CompletionStage&lt;/code&gt; ，一旦侦听器收到消息，该CompletionStage将完成。如果侦听器的方法返回 &lt;code&gt;null&lt;/code&gt; 而不是 &lt;code&gt;CompletionStage&lt;/code&gt; ，则 &lt;code&gt;WebSocket&lt;/code&gt; 的行为就像侦听器返回已经正常 &lt;code&gt;CompletionStage&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="020fc5ad194f669ea119d61b8cd7bdd1712118d0" translate="yes" xml:space="preserve">
          <source>When data is being transported using MIDI wire protocol, a &lt;a href=&quot;shortmessage&quot;&gt;&lt;code&gt;ShortMessage&lt;/code&gt;&lt;/a&gt; with the status value &lt;code&gt;0xFF&lt;/code&gt; represents a system reset message. In MIDI files, this same status value denotes a &lt;code&gt;MetaMessage&lt;/code&gt;. The types of meta-message are distinguished from each other by the first byte that follows the status byte &lt;code&gt;0xFF&lt;/code&gt;. The subsequent bytes are data bytes. As with system exclusive messages, there are an arbitrary number of data bytes, depending on the type of &lt;code&gt;MetaMessage&lt;/code&gt;.</source>
          <target state="translated">当使用MIDI有线协议传输数据时，状态值为 &lt;code&gt;0xFF&lt;/code&gt; 的&lt;a href=&quot;shortmessage&quot;&gt; &lt;code&gt;ShortMessage&lt;/code&gt; &lt;/a&gt;表示系统重置消息。在MIDI文件中，此相同的状态值表示 &lt;code&gt;MetaMessage&lt;/code&gt; 。元消息的类型通过状态字节 &lt;code&gt;0xFF&lt;/code&gt; 之后的第一个字节相互区分。随后的字节是数据字节。与系统专用消息一样，有任意数量的数据字节，具体取决于 &lt;code&gt;MetaMessage&lt;/code&gt; 的类型。</target>
        </trans-unit>
        <trans-unit id="61fdfc98284714085a633464250d1ada20371927" translate="yes" xml:space="preserve">
          <source>When data is being transported using MIDI wire protocol, a &lt;code&gt;&lt;a href=&quot;shortmessage&quot;&gt;&lt;code&gt;ShortMessage&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; with the status value &lt;code&gt;0xFF&lt;/code&gt; represents a system reset message. In MIDI files, this same status value denotes a &lt;code&gt;MetaMessage&lt;/code&gt;. The types of meta-message are distinguished from each other by the first byte that follows the status byte &lt;code&gt;0xFF&lt;/code&gt;. The subsequent bytes are data bytes. As with system exclusive messages, there are an arbitrary number of data bytes, depending on the type of &lt;code&gt;MetaMessage&lt;/code&gt;.</source>
          <target state="translated">当使用MIDI有线协议传输数据时，状态值为 &lt;code&gt;0xFF&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;shortmessage&quot;&gt;&lt;code&gt;ShortMessage&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; 表示系统重置消息。在MIDI文件中，此相同的状态值表示 &lt;code&gt;MetaMessage&lt;/code&gt; 。元消息的类型通过状态字节 &lt;code&gt;0xFF&lt;/code&gt; 之后的第一个字节相互区分。随后的字节是数据字节。与系统专用消息一样，有任意数量的数据字节，具体取决于 &lt;code&gt;MetaMessage&lt;/code&gt; 的类型。</target>
        </trans-unit>
        <trans-unit id="5a3e7279e934de308bb5e4f4f6b1c9d576cc478a" translate="yes" xml:space="preserve">
          <source>When dealing with CSS &quot;shorthand&quot; properties, the shorthand properties should be decomposed into their component longhand properties as appropriate, and when querying for their value, the form returned should be the shortest form exactly equivalent to the declarations made in the ruleset. However, if there is no shorthand declaration that could be added to the ruleset without changing in any way the rules already declared in the ruleset (i.e., by adding longhand rules that were previously not declared in the ruleset), then the empty string should be returned for the shorthand property.</source>
          <target state="translated">在处理CSS &quot;速记 &quot;属性时,应将速记属性适当地分解为其组件的长项属性,在查询其值时,返回的形式应该是与规则集中的声明完全等同的最短形式。但是,如果在不以任何方式改变规则集中已经声明的规则的情况下,没有任何速记声明可以添加到规则集中(即添加以前在规则集中没有声明的长柄规则),那么速记属性应该返回空字符串。</target>
        </trans-unit>
        <trans-unit id="538871f766ab351c2d645502820fda06341f2446" translate="yes" xml:space="preserve">
          <source>When decoding, the &lt;code&gt;UTF-16&lt;/code&gt; charset interprets the byte-order mark at the beginning of the input stream to indicate the byte-order of the stream but defaults to big-endian if there is no byte-order mark; when encoding, it uses big-endian byte order and writes a big-endian byte-order mark.</source>
          <target state="translated">解码时， &lt;code&gt;UTF-16&lt;/code&gt; 字符集将解释输入流开头的字节顺序标记以指示流的字节顺序，但如果没有字节顺序标记，则默认为big-endian；编码时，它使用big-endian字节顺序并写入一个big-endian字节顺序标记。</target>
        </trans-unit>
        <trans-unit id="5d918b0ea7fbe3a38f352e3c01e13aa510f07228" translate="yes" xml:space="preserve">
          <source>When decoding, the &lt;code&gt;UTF-16BE&lt;/code&gt; and &lt;code&gt;UTF-16LE&lt;/code&gt; charsets interpret the initial byte-order marks as a &lt;small&gt;ZERO-WIDTH NON-BREAKING SPACE&lt;/small&gt;; when encoding, they do not write byte-order marks.</source>
          <target state="translated">解码时， &lt;code&gt;UTF-16BE&lt;/code&gt; 和 &lt;code&gt;UTF-16LE&lt;/code&gt; 字符集将初始字节顺序标记解释为零&lt;small&gt;宽度不间断空间&lt;/small&gt;；编码时，它们不写字节顺序标记。</target>
        </trans-unit>
        <trans-unit id="e1bbaedc1e7a3af98446547c47a00777304dd4bc" translate="yes" xml:space="preserve">
          <source>When designing applications that use the &lt;code&gt;JTable&lt;/code&gt; it is worth paying close attention to the data structures that will represent the table's data. The &lt;code&gt;DefaultTableModel&lt;/code&gt; is a model implementation that uses a &lt;code&gt;Vector&lt;/code&gt; of &lt;code&gt;Vector&lt;/code&gt;s of &lt;code&gt;Object&lt;/code&gt;s to store the cell values. As well as copying the data from an application into the &lt;code&gt;DefaultTableModel&lt;/code&gt;, it is also possible to wrap the data in the methods of the &lt;code&gt;TableModel&lt;/code&gt; interface so that the data can be passed to the &lt;code&gt;JTable&lt;/code&gt; directly, as in the example above. This often results in more efficient applications because the model is free to choose the internal representation that best suits the data. A good rule of thumb for deciding whether to use the &lt;code&gt;AbstractTableModel&lt;/code&gt; or the &lt;code&gt;DefaultTableModel&lt;/code&gt; is to use the &lt;code&gt;AbstractTableModel&lt;/code&gt; as the base class for creating subclasses and the &lt;code&gt;DefaultTableModel&lt;/code&gt; when subclassing is not required.</source>
          <target state="translated">在设计使用 &lt;code&gt;JTable&lt;/code&gt; 的应用程序时，值得密切注意将代表表数据的数据结构。该 &lt;code&gt;DefaultTableModel&lt;/code&gt; 是使用一个模型实现 &lt;code&gt;Vector&lt;/code&gt; 的 &lt;code&gt;Vector&lt;/code&gt; 第 &lt;code&gt;Object&lt;/code&gt; s到存储单元格的值。除了将数据从应用程序复制到 &lt;code&gt;DefaultTableModel&lt;/code&gt; 之外，还可以将数据包装在 &lt;code&gt;TableModel&lt;/code&gt; 接口的方法中，以便可以将数据传递到 &lt;code&gt;JTable&lt;/code&gt; 。如上例所示。由于模型可以自由选择最适合数据的内部表示形式，因此通常可以提高应用程序的效率。确定是使用 &lt;code&gt;AbstractTableModel&lt;/code&gt; 还是 &lt;code&gt;DefaultTableModel&lt;/code&gt; 的一个很好的经验法则是，将 &lt;code&gt;AbstractTableModel&lt;/code&gt; 用作创建子类的基类，而在不需要子类化时使用 &lt;code&gt;DefaultTableModel&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="59dd531cc5c7b8c2c34d67569898edd73dd7c276" translate="yes" xml:space="preserve">
          <source>When developing your bean, you can implement the bean features required for your application task omitting the rest of the &lt;code&gt;BeanInfo&lt;/code&gt; features. They will be obtained through the automatic analysis by using the low-level reflection of the bean methods and applying standard design patterns. You have an opportunity to provide additional bean information through various descriptor classes.</source>
          <target state="translated">开发bean时，您可以实现应用程序任务所需的bean功能，而忽略其余的 &lt;code&gt;BeanInfo&lt;/code&gt; 功能。通过使用bean方法的低级反射并应用标准设计模式，可以通过自动分析获得它们。您有机会通过各种描述符类提供其他bean信息。</target>
        </trans-unit>
        <trans-unit id="3e298bb1eb347b2cc28bf3c3db8299caa60036f9" translate="yes" xml:space="preserve">
          <source>When disabled, the scaled design metrics are rounded or adjusted to integer distances for layout. The distances between any specific pair of glyphs will be more uniform on the device, but the density and total length of long strings may no longer match the theoretical intentions of the font designer. Disabling this hint will typically produce more readable results on low resolution devices like computer monitors.</source>
          <target state="translated">当禁用时,缩放设计指标会被四舍五入或调整为整数距离,以便布局。任何特定的字形对之间的距离在设备上会更加统一,但长字符串的密度和总长度可能不再符合字体设计师的理论意图。禁用此提示通常会在电脑显示器等低分辨率设备上产生更可读的结果。</target>
        </trans-unit>
        <trans-unit id="984d0d26836dd3f7be2af922a5a2560cc3df5fe1" translate="yes" xml:space="preserve">
          <source>When displaying the &lt;code&gt;JToolTip&lt;/code&gt;, the &lt;code&gt;ToolTipManager&lt;/code&gt; chooses to use a lightweight &lt;code&gt;JPanel&lt;/code&gt; if it fits.</source>
          <target state="translated">显示 &lt;code&gt;JToolTip&lt;/code&gt; 时，如果合适， &lt;code&gt;ToolTipManager&lt;/code&gt; 选择使用轻量级的 &lt;code&gt;JPanel&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6d1107a71bf9e4fe0583e9859fa2adb2225f96b2" translate="yes" xml:space="preserve">
          <source>When displaying the &lt;code&gt;JToolTip&lt;/code&gt;, the &lt;code&gt;ToolTipManager&lt;/code&gt; chooses to use a lightweight &lt;code&gt;JPanel&lt;/code&gt; if it fits. This method allows you to disable this feature. You have to do disable it if your application mixes light weight and heavy weights components.</source>
          <target state="translated">显示 &lt;code&gt;JToolTip&lt;/code&gt; 时，如果合适， &lt;code&gt;ToolTipManager&lt;/code&gt; 选择使用轻量级的 &lt;code&gt;JPanel&lt;/code&gt; 。此方法使您可以禁用此功能。如果您的应用程序混合了轻量级和重量级组件，则必须禁用它。</target>
        </trans-unit>
        <trans-unit id="4c8c9e94fef6a9d661fc4f926a9c52a00769d2e8" translate="yes" xml:space="preserve">
          <source>When dragging a component, reassigning it to the drag layer ensures that it is positioned over every other component in the container. When finished dragging, it can be reassigned to its normal layer.</source>
          <target state="translated">拖动组件时,将其重新分配到拖动层可确保其位于容器中其他组件的上方。拖曳完成后,可将其重新分配到正常层。</target>
        </trans-unit>
        <trans-unit id="509eab7dc545a495647c552331312cb067390e94" translate="yes" xml:space="preserve">
          <source>When drawing operations are performed, pixels which are the current color are changed to the specified color, and vice versa.</source>
          <target state="translated">进行绘图操作时,将当前颜色的像素改为指定颜色,反之亦然。</target>
        </trans-unit>
        <trans-unit id="f7dc328ec17b4ced8684c2b7e2f146a6ba17ed33" translate="yes" xml:space="preserve">
          <source>When editing, this will be the Component that is doing the actual editing.</source>
          <target state="translated">编辑时,这将是进行实际编辑的组件。</target>
        </trans-unit>
        <trans-unit id="1145f6b1027e817559c57cddc450ec5598c076bb" translate="yes" xml:space="preserve">
          <source>When elements are specified individually, this method provides a convenient way to add a few elements to an existing collection:</source>
          <target state="translated">当元素被单独指定时,该方法提供了一种方便的方式来添加一些元素到现有的集合中。</target>
        </trans-unit>
        <trans-unit id="f0547e7d1fe9e7682b31c5b8e679a8b7cf7cdac7" translate="yes" xml:space="preserve">
          <source>When encoding a String, the following rules apply:</source>
          <target state="translated">当对一个字符串进行编码时,适用以下规则。</target>
        </trans-unit>
        <trans-unit id="2886df50730aa358b631dfc37a5f87ecf532d285" translate="yes" xml:space="preserve">
          <source>When entering full-screen mode, all the translucency effects are reset for the window. Its shape is set to &lt;code&gt;null&lt;/code&gt;, the opacity value is set to 1.0f, and the background color alpha is set to 255 (completely opaque). These values are not restored when returning to windowed mode.</source>
          <target state="translated">进入全屏模式时，将重置窗口的所有半透明效果。其形状设置为 &lt;code&gt;null&lt;/code&gt; ，不透明度值设置为1.0f，背景色alpha设置为255（完全不透明）。返回到窗口模式时，不会还原这些值。</target>
        </trans-unit>
        <trans-unit id="80c01c7c80e86af37db5c501ac99fcd713939de9" translate="yes" xml:space="preserve">
          <source>When entering full-screen mode, if the window to be used as a full-screen window is not visible, this method will make it visible. It will remain visible when returning to windowed mode.</source>
          <target state="translated">当进入全屏模式时,如果要用作全屏窗口的窗口不可见,本方法将使其可见。当返回到窗口模式时,它将保持可见。</target>
        </trans-unit>
        <trans-unit id="5f295f2bcf4f51adce71cb39e573a72525869fe4" translate="yes" xml:space="preserve">
          <source>When errors are found by the validator, the parser is responsible to report them to the user-specified &lt;a href=&quot;../../../org/xml/sax/errorhandler&quot;&gt;&lt;code&gt;ErrorHandler&lt;/code&gt;&lt;/a&gt; (or if the error handler is not set, ignore them or throw them), just like any other errors found by the parser itself. In other words, if the user-specified &lt;a href=&quot;../../../org/xml/sax/errorhandler&quot;&gt;&lt;code&gt;ErrorHandler&lt;/code&gt;&lt;/a&gt; is set, it must receive those errors, and if not, they must be treated according to the implementation specific default error handling rules.</source>
          <target state="translated">验证器发现错误后，解析器负责将错误报告给用户指定的&lt;a href=&quot;../../../org/xml/sax/errorhandler&quot;&gt; &lt;code&gt;ErrorHandler&lt;/code&gt; &lt;/a&gt;（或者如果未设置错误处理程序，则忽略它们或将其抛出），就像解析器本身发现的任何其他错误一样。换句话说，如果设置了用户指定的&lt;a href=&quot;../../../org/xml/sax/errorhandler&quot;&gt; &lt;code&gt;ErrorHandler&lt;/code&gt; &lt;/a&gt;，则它必须接收那些错误，如果没有，则必须根据实现特定的默认错误处理规则对其进行处理。</target>
        </trans-unit>
        <trans-unit id="519e81f7ec22f984619e01262e1e5c7f97e82d8a" translate="yes" xml:space="preserve">
          <source>When executed in parallel, multiple intermediate results may be instantiated, populated, and merged so as to maintain isolation of mutable data structures. Therefore, even when executed in parallel with non-thread-safe data structures (such as &lt;code&gt;ArrayList&lt;/code&gt;), no additional synchronization is needed for a parallel reduction.</source>
          <target state="translated">当并行执行时，可以实例化，填充和合并多个中间结果，以保持可变数据结构的隔离。因此，即使与非线程安全数据结构（例如 &lt;code&gt;ArrayList&lt;/code&gt; ）并行执行时，也不需要额外的同步来进行并行缩减。</target>
        </trans-unit>
        <trans-unit id="e56182ec56b64aac2076f02ce7d0f6f5838a88a0" translate="yes" xml:space="preserve">
          <source>When expanding the services that a module uses or provides then the onus is on the agent to ensure that the service type will be accessible at each instrumentation site where the service type is used. This method does not check if the service type is a member of the module or in a package exported to the module by another module that it reads.</source>
          <target state="translated">当扩展一个模块使用或提供的服务时,代理有责任确保服务类型在使用该服务类型的每个仪器站点都可以访问。这个方法不检查服务类型是否是模块的成员,或者是否在它所读取的另一个模块输出给模块的包中。</target>
        </trans-unit>
        <trans-unit id="7f0b5af857f1afde8bd6a1ceed3f08040c8b1571" translate="yes" xml:space="preserve">
          <source>When factor is, for example, 0.5f the result represents 'the mid-point' of its input - an operation that is useful for centering components in a container.</source>
          <target state="translated">例如,当因子为0.5f时,结果表示其输入的 &quot;中点&quot;--这种操作对容器中的组件居中很有用。</target>
        </trans-unit>
        <trans-unit id="d7ba7db81667141a1f9fae4de090c1beacde1d2f" translate="yes" xml:space="preserve">
          <source>When first constructed, an &lt;code&gt;X509CRLSelector&lt;/code&gt; has no criteria enabled and each of the &lt;code&gt;get&lt;/code&gt; methods return a default value (&lt;code&gt;null&lt;/code&gt;). Therefore, the &lt;a href=&quot;#match(java.security.cert.CRL)&quot;&gt;&lt;code&gt;match&lt;/code&gt;&lt;/a&gt; method would return &lt;code&gt;true&lt;/code&gt; for any &lt;code&gt;X509CRL&lt;/code&gt;. Typically, several criteria are enabled (by calling &lt;a href=&quot;#setIssuers(java.util.Collection)&quot;&gt;&lt;code&gt;setIssuers&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#setDateAndTime(java.util.Date)&quot;&gt;&lt;code&gt;setDateAndTime&lt;/code&gt;&lt;/a&gt;, for instance) and then the &lt;code&gt;X509CRLSelector&lt;/code&gt; is passed to &lt;a href=&quot;certstore#getCRLs(java.security.cert.CRLSelector)&quot;&gt;&lt;code&gt;CertStore.getCRLs&lt;/code&gt;&lt;/a&gt; or some similar method.</source>
          <target state="translated">首次构造时， &lt;code&gt;X509CRLSelector&lt;/code&gt; 没有启用任何条件，并且每个 &lt;code&gt;get&lt;/code&gt; 方法都返回一个默认值（ &lt;code&gt;null&lt;/code&gt; ）。因此，&lt;a href=&quot;#match(java.security.cert.CRL)&quot;&gt; &lt;code&gt;match&lt;/code&gt; &lt;/a&gt;方法将对任何 &lt;code&gt;X509CRL&lt;/code&gt; 返回 &lt;code&gt;true&lt;/code&gt; 。通常，启用多个条件（例如，通过调用&lt;a href=&quot;#setIssuers(java.util.Collection)&quot;&gt; &lt;code&gt;setIssuers&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#setDateAndTime(java.util.Date)&quot;&gt; &lt;code&gt;setDateAndTime&lt;/code&gt; &lt;/a&gt;），然后将 &lt;code&gt;X509CRLSelector&lt;/code&gt; 传递给&lt;a href=&quot;certstore#getCRLs(java.security.cert.CRLSelector)&quot;&gt; &lt;code&gt;CertStore.getCRLs&lt;/code&gt; &lt;/a&gt;或某些类似方法。</target>
        </trans-unit>
        <trans-unit id="9649a12169ece945cbfdacee36bb86668bdc338e" translate="yes" xml:space="preserve">
          <source>When first constructed, an &lt;code&gt;X509CRLSelector&lt;/code&gt; has no criteria enabled and each of the &lt;code&gt;get&lt;/code&gt; methods return a default value (&lt;code&gt;null&lt;/code&gt;). Therefore, the &lt;a href=&quot;x509crlselector#match-java.security.cert.CRL-&quot;&gt;&lt;code&gt;match&lt;/code&gt;&lt;/a&gt; method would return &lt;code&gt;true&lt;/code&gt; for any &lt;code&gt;X509CRL&lt;/code&gt;. Typically, several criteria are enabled (by calling &lt;a href=&quot;x509crlselector#setIssuers-java.util.Collection-&quot;&gt;&lt;code&gt;setIssuers&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;x509crlselector#setDateAndTime-java.util.Date-&quot;&gt;&lt;code&gt;setDateAndTime&lt;/code&gt;&lt;/a&gt;, for instance) and then the &lt;code&gt;X509CRLSelector&lt;/code&gt; is passed to &lt;a href=&quot;certstore#getCRLs-java.security.cert.CRLSelector-&quot;&gt;&lt;code&gt;CertStore.getCRLs&lt;/code&gt;&lt;/a&gt; or some similar method.</source>
          <target state="translated">首次构造时， &lt;code&gt;X509CRLSelector&lt;/code&gt; 没有启用任何条件，并且每个 &lt;code&gt;get&lt;/code&gt; 方法都返回一个默认值（ &lt;code&gt;null&lt;/code&gt; ）。因此，&lt;a href=&quot;x509crlselector#match-java.security.cert.CRL-&quot;&gt; &lt;code&gt;match&lt;/code&gt; &lt;/a&gt;方法将对任何 &lt;code&gt;X509CRL&lt;/code&gt; 返回 &lt;code&gt;true&lt;/code&gt; 。通常，启用多个条件（例如，通过调用&lt;a href=&quot;x509crlselector#setIssuers-java.util.Collection-&quot;&gt; &lt;code&gt;setIssuers&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;x509crlselector#setDateAndTime-java.util.Date-&quot;&gt; &lt;code&gt;setDateAndTime&lt;/code&gt; &lt;/a&gt;），然后将 &lt;code&gt;X509CRLSelector&lt;/code&gt; 传递给&lt;a href=&quot;certstore#getCRLs-java.security.cert.CRLSelector-&quot;&gt; &lt;code&gt;CertStore.getCRLs&lt;/code&gt; &lt;/a&gt;或某些类似方法。</target>
        </trans-unit>
        <trans-unit id="20860ac3af47ff5e6527ceeb9db68080e38b9d93" translate="yes" xml:space="preserve">
          <source>When first constructed, an &lt;code&gt;X509CertSelector&lt;/code&gt; has no criteria enabled and each of the &lt;code&gt;get&lt;/code&gt; methods return a default value (&lt;code&gt;null&lt;/code&gt;, or &lt;code&gt;-1&lt;/code&gt; for the &lt;a href=&quot;#getBasicConstraints()&quot;&gt;&lt;code&gt;getBasicConstraints&lt;/code&gt;&lt;/a&gt; method). Therefore, the &lt;a href=&quot;#match(java.security.cert.Certificate)&quot;&gt;&lt;code&gt;match&lt;/code&gt;&lt;/a&gt; method would return &lt;code&gt;true&lt;/code&gt; for any &lt;code&gt;X509Certificate&lt;/code&gt;. Typically, several criteria are enabled (by calling &lt;a href=&quot;#setIssuer(javax.security.auth.x500.X500Principal)&quot;&gt;&lt;code&gt;setIssuer&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#setKeyUsage(boolean%5B%5D)&quot;&gt;&lt;code&gt;setKeyUsage&lt;/code&gt;&lt;/a&gt;, for instance) and then the &lt;code&gt;X509CertSelector&lt;/code&gt; is passed to &lt;a href=&quot;certstore#getCertificates(java.security.cert.CertSelector)&quot;&gt;&lt;code&gt;CertStore.getCertificates&lt;/code&gt;&lt;/a&gt; or some similar method.</source>
          <target state="translated">首次构造时， &lt;code&gt;X509CertSelector&lt;/code&gt; 不会启用任何条件，并且每个 &lt;code&gt;get&lt;/code&gt; 方法都将返回默认值（ &lt;code&gt;null&lt;/code&gt; ，对于&lt;a href=&quot;#getBasicConstraints()&quot;&gt; &lt;code&gt;getBasicConstraints&lt;/code&gt; &lt;/a&gt;方法为 &lt;code&gt;-1&lt;/code&gt; ）。因此，&lt;a href=&quot;#match(java.security.cert.Certificate)&quot;&gt; &lt;code&gt;match&lt;/code&gt; &lt;/a&gt;方法对于任何 &lt;code&gt;X509Certificate&lt;/code&gt; 都将返回 &lt;code&gt;true&lt;/code&gt; 。通常，启用多个条件（例如，通过调用&lt;a href=&quot;#setIssuer(javax.security.auth.x500.X500Principal)&quot;&gt; &lt;code&gt;setIssuer&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#setKeyUsage(boolean%5B%5D)&quot;&gt; &lt;code&gt;setKeyUsage&lt;/code&gt; &lt;/a&gt;），然后将 &lt;code&gt;X509CertSelector&lt;/code&gt; 传递给&lt;a href=&quot;certstore#getCertificates(java.security.cert.CertSelector)&quot;&gt; &lt;code&gt;CertStore.getCertificates&lt;/code&gt; &lt;/a&gt;或类似的方法。</target>
        </trans-unit>
        <trans-unit id="d650c98b41df8d2991fdd69b36d1bd6550c57b66" translate="yes" xml:space="preserve">
          <source>When first constructed, an &lt;code&gt;X509CertSelector&lt;/code&gt; has no criteria enabled and each of the &lt;code&gt;get&lt;/code&gt; methods return a default value (&lt;code&gt;null&lt;/code&gt;, or &lt;code&gt;-1&lt;/code&gt; for the &lt;a href=&quot;x509certselector#getBasicConstraints--&quot;&gt;&lt;code&gt;getBasicConstraints&lt;/code&gt;&lt;/a&gt; method). Therefore, the &lt;a href=&quot;x509certselector#match-java.security.cert.Certificate-&quot;&gt;&lt;code&gt;match&lt;/code&gt;&lt;/a&gt; method would return &lt;code&gt;true&lt;/code&gt; for any &lt;code&gt;X509Certificate&lt;/code&gt;. Typically, several criteria are enabled (by calling &lt;a href=&quot;x509certselector#setIssuer-javax.security.auth.x500.X500Principal-&quot;&gt;&lt;code&gt;setIssuer&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;x509certselector#setKeyUsage-boolean:A-&quot;&gt;&lt;code&gt;setKeyUsage&lt;/code&gt;&lt;/a&gt;, for instance) and then the &lt;code&gt;X509CertSelector&lt;/code&gt; is passed to &lt;a href=&quot;certstore#getCertificates-java.security.cert.CertSelector-&quot;&gt;&lt;code&gt;CertStore.getCertificates&lt;/code&gt;&lt;/a&gt; or some similar method.</source>
          <target state="translated">首次构造时， &lt;code&gt;X509CertSelector&lt;/code&gt; 不会启用任何条件，并且每个 &lt;code&gt;get&lt;/code&gt; 方法都返回一个默认值（ &lt;code&gt;null&lt;/code&gt; ，对于&lt;a href=&quot;x509certselector#getBasicConstraints--&quot;&gt; &lt;code&gt;getBasicConstraints&lt;/code&gt; &lt;/a&gt;方法为 &lt;code&gt;-1&lt;/code&gt; ）。因此，&lt;a href=&quot;x509certselector#match-java.security.cert.Certificate-&quot;&gt; &lt;code&gt;match&lt;/code&gt; &lt;/a&gt;方法将对任何 &lt;code&gt;X509Certificate&lt;/code&gt; 返回 &lt;code&gt;true&lt;/code&gt; 。通常，启用多个条件（例如，通过调用&lt;a href=&quot;x509certselector#setIssuer-javax.security.auth.x500.X500Principal-&quot;&gt; &lt;code&gt;setIssuer&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;x509certselector#setKeyUsage-boolean:A-&quot;&gt; &lt;code&gt;setKeyUsage&lt;/code&gt; &lt;/a&gt;），然后将 &lt;code&gt;X509CertSelector&lt;/code&gt; 传递给&lt;a href=&quot;certstore#getCertificates-java.security.cert.CertSelector-&quot;&gt; &lt;code&gt;CertStore.getCertificates&lt;/code&gt; &lt;/a&gt;或类似的方法。</target>
        </trans-unit>
        <trans-unit id="6bdbc4072fa0aa2a890b6aafd2d77f59bcdf8288" translate="yes" xml:space="preserve">
          <source>When flip contents are &lt;code&gt;BACKGROUND&lt;/code&gt;, the contents of the back buffer are cleared with the background color after flipping.</source>
          <target state="translated">当翻转内容为 &lt;code&gt;BACKGROUND&lt;/code&gt; ，翻转后将使用背景色清除后缓冲区的内容。</target>
        </trans-unit>
        <trans-unit id="63cdfb20b747808fb558b523ddbdc11e871de470" translate="yes" xml:space="preserve">
          <source>When flip contents are &lt;code&gt;COPIED&lt;/code&gt;, the contents of the back buffer are copied to the front buffer when flipping.</source>
          <target state="translated">当翻转内容 &lt;code&gt;COPIED&lt;/code&gt; ，缓冲复制到前部的后面的内容缓冲区时翻转。</target>
        </trans-unit>
        <trans-unit id="b82198f8743b3ee395f98263a6da347029744bd3" translate="yes" xml:space="preserve">
          <source>When flip contents are &lt;code&gt;PRIOR&lt;/code&gt;, the contents of the back buffer are the prior contents of the front buffer (a true page flip).</source>
          <target state="translated">当翻转内容为 &lt;code&gt;PRIOR&lt;/code&gt; 时，后缓冲区的内容为前缓冲区的优先内容（真正的页面翻转）。</target>
        </trans-unit>
        <trans-unit id="6e1e2b99b6522b5b56f0b7775f1acd75a21bc115" translate="yes" xml:space="preserve">
          <source>When flip contents are &lt;code&gt;UNDEFINED&lt;/code&gt;, the contents of the back buffer are undefined after flipping.</source>
          <target state="translated">当翻转内容为 &lt;code&gt;UNDEFINED&lt;/code&gt; 时，翻转后未定义后缓冲区的内容。</target>
        </trans-unit>
        <trans-unit id="0ff93d04cdedfee3d54c1d406cb192a14d80e305" translate="yes" xml:space="preserve">
          <source>When formatting, if the temporal object contains a date, then it will be converted to a date in the override chronology. Whether the temporal contains a date is determined by querying the &lt;a href=&quot;../temporal/chronofield#EPOCH_DAY&quot;&gt;&lt;code&gt;EPOCH_DAY&lt;/code&gt;&lt;/a&gt; field. Any time or zone will be retained unaltered unless overridden.</source>
          <target state="translated">格式化时，如果时态对象包含日期，则它将按照覆盖年表转换为日期。通过查询&lt;a href=&quot;../temporal/chronofield#EPOCH_DAY&quot;&gt; &lt;code&gt;EPOCH_DAY&lt;/code&gt; &lt;/a&gt;字段来确定时态是否包含日期。除非被覆盖，否则任何时间或区域都将保持不变。</target>
        </trans-unit>
        <trans-unit id="c46c21d901a51405a6408d147e04ecbd8a3f7e31" translate="yes" xml:space="preserve">
          <source>When formatting, if the temporal object contains an instant, then it will be converted to a zoned date-time using the override zone. Whether the temporal is an instant is determined by querying the &lt;a href=&quot;../temporal/chronofield#INSTANT_SECONDS&quot;&gt;&lt;code&gt;INSTANT_SECONDS&lt;/code&gt;&lt;/a&gt; field. If the input has a chronology then it will be retained unless overridden. If the input does not have a chronology, such as &lt;code&gt;Instant&lt;/code&gt;, then the ISO chronology will be used.</source>
          <target state="translated">格式化时，如果时间对象包含一个瞬间，则将使用覆盖区域将其转换为带区域的日期时间。通过查询&lt;a href=&quot;../temporal/chronofield#INSTANT_SECONDS&quot;&gt; &lt;code&gt;INSTANT_SECONDS&lt;/code&gt; &lt;/a&gt;字段来确定时间是否为瞬时。如果输入具有时间顺序，那么它将被保留，除非被覆盖。如果输入没有时间顺序（例如 &lt;code&gt;Instant&lt;/code&gt; )，则将使用ISO时间顺序。</target>
        </trans-unit>
        <trans-unit id="aae3a28f3acb93e9d672fad6d406dd8367567c9e" translate="yes" xml:space="preserve">
          <source>When formatting, the instant will always be suffixed by 'Z' to indicate UTC. When parsing, the behaviour of &lt;a href=&quot;#appendOffsetId()&quot;&gt;&lt;code&gt;appendOffsetId()&lt;/code&gt;&lt;/a&gt; will be used to parse the offset, converting the instant to UTC as necessary.</source>
          <target state="translated">格式化时，该时刻将始终以&amp;ldquo; Z&amp;rdquo;作为后缀以表示UTC。解析时，将使用&lt;a href=&quot;#appendOffsetId()&quot;&gt; &lt;code&gt;appendOffsetId()&lt;/code&gt; &lt;/a&gt;的行为来解析偏移量，并根据需要将时刻转换为UTC。</target>
        </trans-unit>
        <trans-unit id="e3ccef18e16794ea6e4ca8f3deb0092f315cf23d" translate="yes" xml:space="preserve">
          <source>When four parts are specified, each is interpreted as a byte of data and assigned, from left to right, to the four bytes of an IPv4 address.</source>
          <target state="translated">当指定四个部分时,每个部分被解释为一个字节的数据,并从左到右分配到IPv4地址的四个字节。</target>
        </trans-unit>
        <trans-unit id="774dda26093b2a90cd6b2fb725005764df15f2fa" translate="yes" xml:space="preserve">
          <source>When getting a run with no explicit attributes specified (i.e., calling &lt;a href=&quot;#getRunStart()&quot;&gt;&lt;code&gt;getRunStart()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#getRunLimit()&quot;&gt;&lt;code&gt;getRunLimit()&lt;/code&gt;&lt;/a&gt;), any contiguous text segments having the same attributes (the same set of attribute/value pairs) are treated as separate runs if the attributes have been given to those text segments separately.</source>
          <target state="translated">当获得未指定显式属性的运行时（即，调用&lt;a href=&quot;#getRunStart()&quot;&gt; &lt;code&gt;getRunStart()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#getRunLimit()&quot;&gt; &lt;code&gt;getRunLimit()&lt;/code&gt; &lt;/a&gt;），如果具有相同属性（属性/值对的相同集合）的任何连续文本段都已被视为单独的运行，分别给这些文本段。</target>
        </trans-unit>
        <trans-unit id="1ae85906e6fddb6d1dc408436e61d763b88ac485" translate="yes" xml:space="preserve">
          <source>When getting a run with no explicit attributes specified (i.e., calling &lt;a href=&quot;attributedcharacteriterator#getRunStart--&quot;&gt;&lt;code&gt;getRunStart()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;attributedcharacteriterator#getRunLimit--&quot;&gt;&lt;code&gt;getRunLimit()&lt;/code&gt;&lt;/a&gt;), any contiguous text segments having the same attributes (the same set of attribute/value pairs) are treated as separate runs if the attributes have been given to those text segments separately.</source>
          <target state="translated">当获得未指定显式属性的运行时（即，调用&lt;a href=&quot;attributedcharacteriterator#getRunStart--&quot;&gt; &lt;code&gt;getRunStart()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;attributedcharacteriterator#getRunLimit--&quot;&gt; &lt;code&gt;getRunLimit()&lt;/code&gt; &lt;/a&gt;），如果具有相同属性（属性/值对的相同集合）的任何连续文本段都已被视为单独的运行，分别给这些文本段。</target>
        </trans-unit>
        <trans-unit id="b5ba05bc071c59eee04254d6fa68df75d14578d6" translate="yes" xml:space="preserve">
          <source>When initially formatting a value if the length of the string is less than the length of the mask, two things can happen. Either the placeholder string will be used, or the placeholder character will be used. Precedence is given to the placeholder string. For example:</source>
          <target state="translated">当最初格式化一个值时,如果字符串的长度小于掩码的长度,有两种情况可能发生。要么使用占位符串,要么使用占位符。优先使用占位符字符串。例如</target>
        </trans-unit>
        <trans-unit id="8dd1bcbc018d3b4bb41eefe5512da3834ff920d7" translate="yes" xml:space="preserve">
          <source>When invoked on an &lt;code&gt;ArrayType&lt;/code&gt; instance, the &lt;a href=&quot;opentype#getClassName()&quot;&gt;&lt;code&gt;getClassName&lt;/code&gt;&lt;/a&gt; method returns the class name of the array instances it describes (following the rules defined by the &lt;a href=&quot;../../../../java.base/java/lang/class#getName()&quot;&gt;&lt;code&gt;getName&lt;/code&gt;&lt;/a&gt; method of &lt;code&gt;java.lang.Class&lt;/code&gt;), not the class name of the array elements (which is returned by a call to &lt;code&gt;getElementOpenType().getClassName()&lt;/code&gt;).</source>
          <target state="translated">在 &lt;code&gt;ArrayType&lt;/code&gt; 实例上调用时，&lt;a href=&quot;opentype#getClassName()&quot;&gt; &lt;code&gt;getClassName&lt;/code&gt; &lt;/a&gt;方法返回其描述的数组实例的类名（遵循由 &lt;code&gt;java.lang.Class&lt;/code&gt; 的&lt;a href=&quot;../../../../java.base/java/lang/class#getName()&quot;&gt; &lt;code&gt;getName&lt;/code&gt; &lt;/a&gt;方法定义的规则），而不是数组元素的类名（由以下方法返回）：调用 &lt;code&gt;getElementOpenType().getClassName()&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="302acd17292bb6cb5b2e63e5ea447c50cffa715c" translate="yes" xml:space="preserve">
          <source>When invoked on an &lt;code&gt;ArrayType&lt;/code&gt; instance, the &lt;a href=&quot;opentype#getClassName--&quot;&gt;&lt;code&gt;getClassName&lt;/code&gt;&lt;/a&gt; method returns the class name of the array instances it describes (following the rules defined by the &lt;a href=&quot;../../../java/lang/class#getName--&quot;&gt;&lt;code&gt;getName&lt;/code&gt;&lt;/a&gt; method of &lt;code&gt;java.lang.Class&lt;/code&gt;), not the class name of the array elements (which is returned by a call to &lt;code&gt;getElementOpenType().getClassName()&lt;/code&gt;).</source>
          <target state="translated">在 &lt;code&gt;ArrayType&lt;/code&gt; 实例上调用时，&lt;a href=&quot;opentype#getClassName--&quot;&gt; &lt;code&gt;getClassName&lt;/code&gt; &lt;/a&gt;方法返回其描述的数组实例的类名（遵循 &lt;code&gt;java.lang.Class&lt;/code&gt; 的&lt;a href=&quot;../../../java/lang/class#getName--&quot;&gt; &lt;code&gt;getName&lt;/code&gt; &lt;/a&gt;方法定义的规则），而不是数组元素的类名（由调用 &lt;code&gt;getElementOpenType().getClassName()&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="580b70b0aa9940a4d315897412a3c8e6a50c10fb" translate="yes" xml:space="preserve">
          <source>When it is desirable to group together a number of Permission objects of the same type, the &lt;code&gt;newPermissionCollection&lt;/code&gt; method on that particular type of Permission object should first be called. The default behavior (from the Permission class) is to simply return null. Subclasses of class Permission override the method if they need to store their permissions in a particular PermissionCollection object in order to provide the correct semantics when the &lt;code&gt;PermissionCollection.implies&lt;/code&gt; method is called. If a non-null value is returned, that PermissionCollection must be used. If null is returned, then the caller of &lt;code&gt;newPermissionCollection&lt;/code&gt; is free to store permissions of the given type in any PermissionCollection they choose (one that uses a Hashtable, one that uses a Vector, etc).</source>
          <target state="translated">当需要将多个相同类型的Permission对象组合在一起时，应首先调用该特定类型的Permission对象上的 &lt;code&gt;newPermissionCollection&lt;/code&gt; 方法。默认行为（来自Permission类）是简单地返回null。如果在调用 &lt;code&gt;PermissionCollection.implies&lt;/code&gt; 方法时它们需要将其权限存储在特定的PermissionCollection对象中以提供正确的语义，则Permission类的子类将覆盖此方法。如果返回非空值，则必须使用该PermissionCollection。如果返回null，则 &lt;code&gt;newPermissionCollection&lt;/code&gt; 的调用者 可以自由地将给定类型的权限存储在他们选择的任何PermissionCollection中（一个使用Hashtable，一个使用Vector，等等）。</target>
        </trans-unit>
        <trans-unit id="ce33c85f5d00ceaaf151e94b617d0fd035ff89e8" translate="yes" xml:space="preserve">
          <source>When leaf Views (such as LabelView) are rendering they should call into this method.</source>
          <target state="translated">当叶子视图(如LabelView)正在渲染时,它们应该调用到这个方法。</target>
        </trans-unit>
        <trans-unit id="bf1e959633bde681b0bed5cc3b7b643970517499" translate="yes" xml:space="preserve">
          <source>When leaf Views (such as LabelView) are rendering they should call into this method. If a highlight is in the given region it will be drawn immediately.</source>
          <target state="translated">当叶子视图(如LabelView)正在渲染时,它们应该调用到这个方法。如果一个高光在给定的区域内,它将被立即绘制。</target>
        </trans-unit>
        <trans-unit id="174a6496db7aea116f5760d2cbbff2da29431d36" translate="yes" xml:space="preserve">
          <source>When loading or instantiating a service provider in a module, &lt;code&gt;
 ServiceConfigurationError&lt;/code&gt; can be thrown for the following reasons:</source>
          <target state="translated">在模块中加载或实例化服务提供程序时，由于以下原因，可能引发 &lt;code&gt; ServiceConfigurationError&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="4328d60614b67a469dcc46dc7b40428e7a16ab80" translate="yes" xml:space="preserve">
          <source>When locating modules then any exceptions or errors thrown by the &lt;code&gt;find&lt;/code&gt; or &lt;code&gt;findAll&lt;/code&gt; methods of the underlying module finders will be propagated to the caller of the resulting module finder's &lt;code&gt;find&lt;/code&gt; or &lt;code&gt;findAll&lt;/code&gt; methods.</source>
          <target state="translated">当定位模块，然后由抛出的任何异常或错误 &lt;code&gt;find&lt;/code&gt; 或 &lt;code&gt;findAll&lt;/code&gt; 底层模块拾得的方法将被传播到生成的模块取景器的调用者 &lt;code&gt;find&lt;/code&gt; 或 &lt;code&gt;findAll&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="16ba2f01e5d521afc7a1d8765c061f6962009acc" translate="yes" xml:space="preserve">
          <source>When locking and unlocking occur in different scopes, care must be taken to ensure that all code that is executed while the lock is held is protected by try-finally or try-catch to ensure that the lock is released when necessary.</source>
          <target state="translated">当锁定和解锁发生在不同的作用域中时,必须注意确保在锁被保持时执行的所有代码受到try-finally或try-catch的保护,以确保在必要时释放锁。</target>
        </trans-unit>
        <trans-unit id="d0d60a7362268503ac5f29c4e995b665bfa49ca4" translate="yes" xml:space="preserve">
          <source>When logging is enabled for the given level, the default implementation for this method calls &lt;code&gt;this.log(level, (ResourceBundle)null, msgSupplier.get(), (Object[])null);&lt;/code&gt;</source>
          <target state="translated">当为给定级别启用日志记录时，此方法的默认实现调用 &lt;code&gt;this.log(level, (ResourceBundle)null, msgSupplier.get(), (Object[])null);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4b48d582b593f5a0b71b33ebfba543a2007aa703" translate="yes" xml:space="preserve">
          <source>When logging is enabled for the given level, the default implementation for this method calls &lt;code&gt;this.log(level, (ResourceBundle)null, msgSupplier.get(), thrown);&lt;/code&gt;</source>
          <target state="translated">当为给定级别启用日志记录时，此方法的默认实现调用 &lt;code&gt;this.log(level, (ResourceBundle)null, msgSupplier.get(), thrown);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b1dd8bd9ca02efdcd9732b7cf62a3e53ee34a950" translate="yes" xml:space="preserve">
          <source>When logging is enabled for the given level, the default implementation for this method calls &lt;code&gt;this.log(level, (ResourceBundle)null, obj.toString(), (Object[])null);&lt;/code&gt;</source>
          <target state="translated">当为给定级别启用日志记录时，此方法的默认实现调用 &lt;code&gt;this.log(level, (ResourceBundle)null, obj.toString(), (Object[])null);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b6e7f5643792532437bd221471efc47beceaab52" translate="yes" xml:space="preserve">
          <source>When looking for a &lt;code&gt;ResourceBundle&lt;/code&gt;, the logger will first look at whether a bundle was specified using &lt;a href=&quot;#setResourceBundle(java.util.ResourceBundle)&quot;&gt;&lt;code&gt;setResourceBundle&lt;/code&gt;&lt;/a&gt;, and then only whether a resource bundle name was specified through the &lt;a href=&quot;#getLogger(java.lang.String,java.lang.String)&quot;&gt;&lt;code&gt;getLogger&lt;/code&gt;&lt;/a&gt; factory method. If no &lt;code&gt;ResourceBundle&lt;/code&gt; or no resource bundle name is found, then it will use the nearest &lt;code&gt;ResourceBundle&lt;/code&gt; or resource bundle name inherited from its parent tree.</source>
          <target state="translated">查找 &lt;code&gt;ResourceBundle&lt;/code&gt; 时，记录器将首先查看是否使用&lt;a href=&quot;#setResourceBundle(java.util.ResourceBundle)&quot;&gt; &lt;code&gt;setResourceBundle&lt;/code&gt; &lt;/a&gt;指定了捆绑包，然后仅查看是否通过&lt;a href=&quot;#getLogger(java.lang.String,java.lang.String)&quot;&gt; &lt;code&gt;getLogger&lt;/code&gt; &lt;/a&gt;工厂方法指定了资源捆绑包名称。如果未找到 &lt;code&gt;ResourceBundle&lt;/code&gt; 或资源束名称，则它将使用从其父树继承的最近的 &lt;code&gt;ResourceBundle&lt;/code&gt; 或资源束名称。</target>
        </trans-unit>
        <trans-unit id="1a0408130f81738a723c33c438670c4461590e47" translate="yes" xml:space="preserve">
          <source>When looking for a &lt;code&gt;ResourceBundle&lt;/code&gt;, the logger will first look at whether a bundle was specified using &lt;a href=&quot;logger#setResourceBundle-java.util.ResourceBundle-&quot;&gt;&lt;code&gt;setResourceBundle&lt;/code&gt;&lt;/a&gt;, and then only whether a resource bundle name was specified through the &lt;a href=&quot;logger#getLogger-java.lang.String-java.lang.String-&quot;&gt;&lt;code&gt;getLogger&lt;/code&gt;&lt;/a&gt; factory method. If no &lt;code&gt;ResourceBundle&lt;/code&gt; or no resource bundle name is found, then it will use the nearest &lt;code&gt;ResourceBundle&lt;/code&gt; or resource bundle name inherited from its parent tree.</source>
          <target state="translated">查找 &lt;code&gt;ResourceBundle&lt;/code&gt; 时，记录器将首先查看是否使用&lt;a href=&quot;logger#setResourceBundle-java.util.ResourceBundle-&quot;&gt; &lt;code&gt;setResourceBundle&lt;/code&gt; &lt;/a&gt;指定了捆绑包，然后仅查看是否通过&lt;a href=&quot;logger#getLogger-java.lang.String-java.lang.String-&quot;&gt; &lt;code&gt;getLogger&lt;/code&gt; &lt;/a&gt;工厂方法指定了资源捆绑包名称。如果未找到 &lt;code&gt;ResourceBundle&lt;/code&gt; 或资源束名称，则它将使用从其父树继承的最近的 &lt;code&gt;ResourceBundle&lt;/code&gt; 或资源束名称。</target>
        </trans-unit>
        <trans-unit id="0a8e75474aa9a3fb3f0db3e2785307495315a60e" translate="yes" xml:space="preserve">
          <source>When looking up a time zone name, the &lt;a href=&quot;resourcebundle.control#getCandidateLocales(java.lang.String,java.util.Locale)&quot;&gt;default &lt;code&gt;Locale&lt;/code&gt;search path of &lt;code&gt;ResourceBundle&lt;/code&gt;&lt;/a&gt; derived from the specified &lt;code&gt;locale&lt;/code&gt; is used. (No &lt;a href=&quot;resourcebundle.control#getFallbackLocale(java.lang.String,java.util.Locale)&quot;&gt;fallback &lt;code&gt;Locale&lt;/code&gt;&lt;/a&gt; search is performed.) If a time zone name in any &lt;code&gt;Locale&lt;/code&gt; of the search path, including &lt;a href=&quot;locale#ROOT&quot;&gt;&lt;code&gt;Locale.ROOT&lt;/code&gt;&lt;/a&gt;, is found, the name is returned. Otherwise, a string in the &lt;a href=&quot;#NormalizedCustomID&quot;&gt;normalized custom ID format&lt;/a&gt; is returned.</source>
          <target state="translated">查找时区名称时，将&lt;a href=&quot;resourcebundle.control#getCandidateLocales(java.lang.String,java.util.Locale)&quot;&gt;使用 &lt;code&gt;Locale&lt;/code&gt; &lt;code&gt;ResourceBundle&lt;/code&gt; &lt;/a&gt;从指定 &lt;code&gt;locale&lt;/code&gt; 派生的ResourceBundle的默认语言环境搜索路径。 （不执行&lt;a href=&quot;resourcebundle.control#getFallbackLocale(java.lang.String,java.util.Locale)&quot;&gt;回退 &lt;code&gt;Locale&lt;/code&gt; &lt;/a&gt;搜索。）如果在搜索路径的任何 &lt;code&gt;Locale&lt;/code&gt; 中找到一个时区名称，包括&lt;a href=&quot;locale#ROOT&quot;&gt; &lt;code&gt;Locale.ROOT&lt;/code&gt; &lt;/a&gt;，则返回该名称。否则，将返回&lt;a href=&quot;#NormalizedCustomID&quot;&gt;标准化的自定义ID格式&lt;/a&gt;的字符串。</target>
        </trans-unit>
        <trans-unit id="21d53a267b267d5210cc4f8a1f75a8f56a77b7e6" translate="yes" xml:space="preserve">
          <source>When looking up a time zone name, the &lt;a href=&quot;resourcebundle.control#getCandidateLocales(java.lang.String,java.util.Locale)&quot;&gt;default {@code Locale} search path of {@code ResourceBundle}&lt;/a&gt; derived from the specified &lt;code&gt;locale&lt;/code&gt; is used. (No &lt;a href=&quot;resourcebundle.control#getFallbackLocale(java.lang.String,java.util.Locale)&quot;&gt;fallback {@code Locale}&lt;/a&gt; search is performed.) If a time zone name in any &lt;code&gt;Locale&lt;/code&gt; of the search path, including &lt;a href=&quot;locale#ROOT&quot;&gt;&lt;code&gt;Locale.ROOT&lt;/code&gt;&lt;/a&gt;, is found, the name is returned. Otherwise, a string in the &lt;a href=&quot;#NormalizedCustomID&quot;&gt;normalized custom ID format&lt;/a&gt; is returned.</source>
          <target state="translated">查找时区名称时，使用从指定 &lt;code&gt;locale&lt;/code&gt; 派生的&lt;a href=&quot;resourcebundle.control#getCandidateLocales(java.lang.String,java.util.Locale)&quot;&gt;默认{@code ResourceBundle}搜索路径&lt;/a&gt;。 （不执行&lt;a href=&quot;resourcebundle.control#getFallbackLocale(java.lang.String,java.util.Locale)&quot;&gt;回退{@code Locale}&lt;/a&gt;搜索。）如果在搜索路径的任何 &lt;code&gt;Locale&lt;/code&gt; 中找到一个时区名称，包括&lt;a href=&quot;locale#ROOT&quot;&gt; &lt;code&gt;Locale.ROOT&lt;/code&gt; &lt;/a&gt;，则返回该名称。否则，将返回&lt;a href=&quot;#NormalizedCustomID&quot;&gt;标准化的自定义ID格式&lt;/a&gt;的字符串。</target>
        </trans-unit>
        <trans-unit id="b9993ef66f72f6a538299eeaaa5c894846a8a38b" translate="yes" xml:space="preserve">
          <source>When looking up a time zone name, the &lt;a href=&quot;resourcebundle.control#getCandidateLocales-java.lang.String-java.util.Locale-&quot;&gt;default &lt;code&gt;Locale&lt;/code&gt; search path of &lt;code&gt;ResourceBundle&lt;/code&gt;&lt;/a&gt; derived from the specified &lt;code&gt;locale&lt;/code&gt; is used. (No &lt;a href=&quot;resourcebundle.control#getFallbackLocale-java.lang.String-java.util.Locale-&quot;&gt;fallback &lt;code&gt;Locale&lt;/code&gt;&lt;/a&gt; search is performed.) If a time zone name in any &lt;code&gt;Locale&lt;/code&gt; of the search path, including &lt;a href=&quot;locale#ROOT&quot;&gt;&lt;code&gt;Locale.ROOT&lt;/code&gt;&lt;/a&gt;, is found, the name is returned. Otherwise, a string in the &lt;a href=&quot;#NormalizedCustomID&quot;&gt;normalized custom ID format&lt;/a&gt; is returned.</source>
          <target state="translated">查找时区名称时，将&lt;a href=&quot;resourcebundle.control#getCandidateLocales-java.lang.String-java.util.Locale-&quot;&gt;使用 &lt;code&gt;Locale&lt;/code&gt; &lt;code&gt;ResourceBundle&lt;/code&gt; &lt;/a&gt;从指定 &lt;code&gt;locale&lt;/code&gt; 派生的ResourceBundle的默认语言环境搜索路径。 （不执行&lt;a href=&quot;resourcebundle.control#getFallbackLocale-java.lang.String-java.util.Locale-&quot;&gt;回退 &lt;code&gt;Locale&lt;/code&gt; &lt;/a&gt;搜索。）如果在搜索路径的任何 &lt;code&gt;Locale&lt;/code&gt; 中找到时区名称，包括&lt;a href=&quot;locale#ROOT&quot;&gt; &lt;code&gt;Locale.ROOT&lt;/code&gt; &lt;/a&gt;，则返回该名称。否则，将返回&lt;a href=&quot;#NormalizedCustomID&quot;&gt;标准化的自定义ID格式&lt;/a&gt;的字符串。</target>
        </trans-unit>
        <trans-unit id="82f732f406e110c12eb9e6c2262a006ddaeaa4e2" translate="yes" xml:space="preserve">
          <source>When mapping resource bundle names to &lt;code&gt;ResourceBundle&lt;/code&gt; objects, the logger will first try to use the Thread's &lt;a href=&quot;../../../../java.base/java/lang/thread#getContextClassLoader()&quot;&gt;context class loader&lt;/a&gt; to map the given resource bundle name to a &lt;code&gt;ResourceBundle&lt;/code&gt;. If the thread context class loader is &lt;code&gt;null&lt;/code&gt;, it will try the &lt;a href=&quot;../../../../java.base/java/lang/classloader#getSystemClassLoader()&quot;&gt;system class loader&lt;/a&gt; instead. If the &lt;code&gt;ResourceBundle&lt;/code&gt; is still not found, it will use the class loader of the first caller of the &lt;a href=&quot;#getLogger(java.lang.String,java.lang.String)&quot;&gt;&lt;code&gt;getLogger&lt;/code&gt;&lt;/a&gt; factory method.</source>
          <target state="translated">将资源包名称映射到 &lt;code&gt;ResourceBundle&lt;/code&gt; 对象时，记录器将首先尝试使用线程的&lt;a href=&quot;../../../../java.base/java/lang/thread#getContextClassLoader()&quot;&gt;上下文类加载器&lt;/a&gt;将给定的资源包名称映射到 &lt;code&gt;ResourceBundle&lt;/code&gt; 。如果线程上下文类加载器为 &lt;code&gt;null&lt;/code&gt; ，它将尝试使用&lt;a href=&quot;../../../../java.base/java/lang/classloader#getSystemClassLoader()&quot;&gt;系统类加载器&lt;/a&gt;。如果仍然找不到 &lt;code&gt;ResourceBundle&lt;/code&gt; ，它将使用&lt;a href=&quot;#getLogger(java.lang.String,java.lang.String)&quot;&gt; &lt;code&gt;getLogger&lt;/code&gt; &lt;/a&gt;工厂方法的第一个调用程序的类加载器。</target>
        </trans-unit>
        <trans-unit id="be5fb3253fce93d08c0e8b8dd053dbdf2da012a3" translate="yes" xml:space="preserve">
          <source>When mapping resource bundle names to &lt;code&gt;ResourceBundle&lt;/code&gt; objects, the logger will first try to use the Thread's &lt;a href=&quot;../../lang/thread#getContextClassLoader--&quot;&gt;context class loader&lt;/a&gt; to map the given resource bundle name to a &lt;code&gt;ResourceBundle&lt;/code&gt;. If the thread context class loader is &lt;code&gt;null&lt;/code&gt;, it will try the &lt;a href=&quot;../../lang/classloader#getSystemClassLoader--&quot;&gt;system class loader&lt;/a&gt; instead. If the &lt;code&gt;ResourceBundle&lt;/code&gt; is still not found, it will use the class loader of the first caller of the &lt;a href=&quot;logger#getLogger-java.lang.String-java.lang.String-&quot;&gt;&lt;code&gt;getLogger&lt;/code&gt;&lt;/a&gt; factory method.</source>
          <target state="translated">将资源包名称映射到 &lt;code&gt;ResourceBundle&lt;/code&gt; 对象时，记录器将首先尝试使用线程的&lt;a href=&quot;../../lang/thread#getContextClassLoader--&quot;&gt;上下文类加载器&lt;/a&gt;将给定的资源包名称映射到 &lt;code&gt;ResourceBundle&lt;/code&gt; 。如果线程上下文类加载器为 &lt;code&gt;null&lt;/code&gt; ，它将尝试使用&lt;a href=&quot;../../lang/classloader#getSystemClassLoader--&quot;&gt;系统类加载器&lt;/a&gt;。如果仍然找不到 &lt;code&gt;ResourceBundle&lt;/code&gt; ，它将使用&lt;a href=&quot;logger#getLogger-java.lang.String-java.lang.String-&quot;&gt; &lt;code&gt;getLogger&lt;/code&gt; &lt;/a&gt;工厂方法的第一个调用程序的类加载器。</target>
        </trans-unit>
        <trans-unit id="5817dccb8a24dc56e1279e061808065c8af108b0" translate="yes" xml:space="preserve">
          <source>When multiple certificates are available for use in a handshake, the implementation chooses what it considers the &quot;best&quot; certificate chain available, and transmits that to the other side. This method allows the caller to know which certificate chain was actually sent.</source>
          <target state="translated">当有多个证书可用于握手时,实现会选择它认为可用的 &quot;最佳 &quot;证书链,并将其传送给对方。这个方法可以让调用者知道实际发送的是哪条证书链。</target>
        </trans-unit>
        <trans-unit id="e3c423c16dcc60cd6b3423d29ca5549e570d4cde" translate="yes" xml:space="preserve">
          <source>When multiple certificates are available for use in a handshake, the implementation chooses what it considers the &quot;best&quot; certificate chain available, and transmits that to the other side. This method allows the caller to know which certificate chain was actually used.</source>
          <target state="translated">当握手过程中有多个证书可供使用时,实现会选择它认为 &quot;最好 &quot;的证书链,并将其传送给对方。这个方法可以让调用者知道实际使用的是哪条证书链。</target>
        </trans-unit>
        <trans-unit id="e3b28bc24e19b6732ac42b3b00b62e8ef0542f5f" translate="yes" xml:space="preserve">
          <source>When multiple mechanisms to retrieve a ticket or key is provided, the preference order is:</source>
          <target state="translated">当提供多种检索票据或密钥的机制时,优先顺序为:。</target>
        </trans-unit>
        <trans-unit id="e850be999ec8886286adca7b7397c7e98dbc4504" translate="yes" xml:space="preserve">
          <source>When multiple mouse buttons are pressed, each press, release, and click results in a separate event.</source>
          <target state="translated">当多个鼠标按钮被按下时,每次按下、释放和点击都会导致一个单独的事件。</target>
        </trans-unit>
        <trans-unit id="b583a6caec2f5a60ad8b2a97fc56411186997e09" translate="yes" xml:space="preserve">
          <source>When multiple threads attempt updates, map operations and the remapping function may be called multiple times.</source>
          <target state="translated">当多个线程尝试更新时,映射操作和重映射函数可能被多次调用。</target>
        </trans-unit>
        <trans-unit id="421a63f8d081ab15313773fe4ca2f494ee90642e" translate="yes" xml:space="preserve">
          <source>When names are tested for equality, attribute types, both binary and string values, are case-insensitive. String values with different but equivalent usage of quoting, escaping, or UTF8-hex-encoding are considered equal. The order of components in multi-valued RDNs (such as &quot;ou=Sales+cn=Bob&quot;) is not significant.</source>
          <target state="translated">当对名称进行平等性测试时,属性类型,无论是二进制还是字符串值,都是不区分大小写的。使用不同但相等的引号、转义或UTF8-hex-encoding的字符串值被视为相等。在多值的RDN中,组件的顺序并不重要(如 &quot;ou=Sales+cn=Bob&quot;)。</target>
        </trans-unit>
        <trans-unit id="6883b8562675f0154aa3d30123f4e8a85ff6259b" translate="yes" xml:space="preserve">
          <source>When not already closed, the &lt;code&gt;close&lt;/code&gt; method of &lt;code&gt;
 FilterOutputStream&lt;/code&gt; calls its &lt;code&gt;flush&lt;/code&gt; method, and then calls the &lt;code&gt;close&lt;/code&gt; method of its underlying output stream.</source>
          <target state="translated">如果尚未关闭，则 &lt;code&gt; FilterOutputStream&lt;/code&gt; 的 &lt;code&gt;close&lt;/code&gt; 方法将调用其 &lt;code&gt;flush&lt;/code&gt; 方法，然后再调用其基础输出流的 &lt;code&gt;close&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="4a545d4bb404c11d8dba04dd5da469b88f7c0cfb" translate="yes" xml:space="preserve">
          <source>When not using the try-with-resources construct, then directory stream's &lt;code&gt;close&lt;/code&gt; method should be invoked after iteration is completed so as to free any resources held for the open directory.</source>
          <target state="translated">当不使用try-with-resources构造时，应在迭代完成后调用目录流的 &lt;code&gt;close&lt;/code&gt; 方法，以释放为打开目录保留的所有资源。</target>
        </trans-unit>
        <trans-unit id="be40b60dc5533eb85b6daed004aaac933ffdf025" translate="yes" xml:space="preserve">
          <source>When obtaining a mapped segment from a newly created file, the initialization state of the contents of the block of mapped memory associated with the returned mapped memory segment is unspecified and should not be relied upon.</source>
          <target state="translated">当从新创建的文件中获取映射段时,与返回的映射内存段相关联的映射内存块的内容的初始化状态是不明确的,不应依赖。</target>
        </trans-unit>
        <trans-unit id="f0eff43acb661f5302995be06d4dfab4083a1196" translate="yes" xml:space="preserve">
          <source>When one of the &lt;code&gt;showXxxDialog&lt;/code&gt; methods returns an integer, the possible values are:</source>
          <target state="translated">当 &lt;code&gt;showXxxDialog&lt;/code&gt; 方法之一返回整数时，可能的值为：</target>
        </trans-unit>
        <trans-unit id="08da4f2fc44fc2ee4201a796e38c5af9ee0a82e4" translate="yes" xml:space="preserve">
          <source>When one of those methods is invoked, its behavior is to delegate to a corresponding method on an instance of this class. The details of how each method delegates to the provider instance is described in the documentation for each particular method. See the documentation for &lt;a href=&quot;rmiclassloader&quot;&gt;&lt;code&gt;RMIClassLoader&lt;/code&gt;&lt;/a&gt; for a description of how a provider instance is chosen.</source>
          <target state="translated">当调用这些方法之一时，其行为是委托给此类实例上的相应方法。有关每种特定方法的文档中介绍了每种方法如何委派给提供程序实例的详细信息。有关如何选择提供程序实例的说明，请参见&lt;a href=&quot;rmiclassloader&quot;&gt; &lt;code&gt;RMIClassLoader&lt;/code&gt; &lt;/a&gt;的文档。</target>
        </trans-unit>
        <trans-unit id="61d8ce27b955b14a389038bf014cbe85cc67752c" translate="yes" xml:space="preserve">
          <source>When one sends a message to a multicast group, &lt;b&gt;all&lt;/b&gt; subscribing recipients to that host and port receive the message (within the time-to-live range of the packet, see below). The socket needn't be a member of the multicast group to send messages to it.</source>
          <target state="translated">当一个人向多播组发送一条消息时，&lt;b&gt;所有&lt;/b&gt;订阅该主机和端口的收件人都会收到该消息（在包的生存时间范围内，请参见下文）。套接字不必是多播组的成员即可向其发送消息。</target>
        </trans-unit>
        <trans-unit id="2c665e1ac4c57d3ccf2437d891eb0ae431f77c0f" translate="yes" xml:space="preserve">
          <source>When only one part is given, the value is stored directly in the network address without any byte rearrangement.</source>
          <target state="translated">当只给出一个部分时,该值直接存储在网络地址中,而不进行任何字节重排。</target>
        </trans-unit>
        <trans-unit id="1875b9065ed910ca6ec4ee04408f7621f55c467c" translate="yes" xml:space="preserve">
          <source>When opening an existing file, the file is first truncated to a size of 0 bytes. This option is ignored when the file is opened only for reading.</source>
          <target state="translated">当打开一个现有的文件时,文件首先被截断为0字节大小。当打开文件仅用于读取时,该选项被忽略。</target>
        </trans-unit>
        <trans-unit id="55ad5bbbd836b22033fccd6daca4b9d44a123e8e" translate="yes" xml:space="preserve">
          <source>When output streaming is enabled, authentication and redirection cannot be handled automatically. A &lt;a href=&quot;httpretryexception&quot;&gt;HttpRetryException&lt;/a&gt; will be thrown when reading the response if authentication or redirection are required. This exception can be queried for the details of the error.</source>
          <target state="translated">启用输出流传输后，无法自动处理身份验证和重定向。一个&lt;a href=&quot;httpretryexception&quot;&gt;HttpRetryException&lt;/a&gt;读取响应时是否需要身份验证或重定向将被抛出。可以查询此异常以获取错误的详细信息。</target>
        </trans-unit>
        <trans-unit id="0a1daf55edfb1251014f98d686349fc2cf29836a" translate="yes" xml:space="preserve">
          <source>When output streaming is enabled, authentication and redirection cannot be handled automatically. A HttpRetryException will be thrown when reading the response if authentication or redirection are required. This exception can be queried for the details of the error.</source>
          <target state="translated">当启用输出流时,不能自动处理认证和重定向。如果需要认证或重定向,在读取响应时将抛出一个HttpRetryException。这个异常可以查询到错误的细节。</target>
        </trans-unit>
        <trans-unit id="70789a8a89c99dae4c53ce0b0096f13062e5be96" translate="yes" xml:space="preserve">
          <source>When output to a ZIP file or ZIP file formatted output stream the last modification time set by this method will be stored into zip file entry's &lt;code&gt;date and time fields&lt;/code&gt; in &lt;code&gt;standard
 MS-DOS date and time format&lt;/code&gt;), and the extended timestamp fields in &lt;code&gt;optional extra data&lt;/code&gt; in UTC time.</source>
          <target state="translated">当输出到ZIP文件或ZIP文件格式的输出流时，此方法设置的最后修改时间将以 &lt;code&gt;standard MS-DOS date and time format&lt;/code&gt; 存储在zip文件条目的 &lt;code&gt;date and time fields&lt;/code&gt; 中，而扩展时间戳记字段则存储在 &lt;code&gt;optional extra data&lt;/code&gt; UTC时间中的数据。</target>
        </trans-unit>
        <trans-unit id="fc606ceb2f424146aad8bdb4fde4bd8dd7c5761f" translate="yes" xml:space="preserve">
          <source>When overriding this method it is recommended that an implementation ensures that any delegation is consistent with the &lt;a href=&quot;#getResource(java.lang.String)&quot;&gt;&lt;code&gt;getResource(String)&lt;/code&gt;&lt;/a&gt; method. This should ensure that the first element returned by the stream is the same resource that the &lt;code&gt;getResource(String)&lt;/code&gt; method would return.</source>
          <target state="translated">重写此方法时，建议实现确保任何委托与&lt;a href=&quot;#getResource(java.lang.String)&quot;&gt; &lt;code&gt;getResource(String)&lt;/code&gt; &lt;/a&gt;方法一致。这应该确保流返回的第一个元素与 &lt;code&gt;getResource(String)&lt;/code&gt; 方法将返回的资源相同。</target>
        </trans-unit>
        <trans-unit id="33b67f1448d9e46c92a5dd8ca3e0c7d32d1730ae" translate="yes" xml:space="preserve">
          <source>When overriding this method it is recommended that an implementation ensures that any delegation is consistent with the &lt;a href=&quot;classloader#getResource-java.lang.String-&quot;&gt;&lt;code&gt;getResource(String)&lt;/code&gt;&lt;/a&gt; method. This should ensure that the first element returned by the Enumeration's &lt;code&gt;nextElement&lt;/code&gt; method is the same resource that the &lt;code&gt;getResource(String)&lt;/code&gt; method would return.</source>
          <target state="translated">重写此方法时，建议实现确保任何委托与&lt;a href=&quot;classloader#getResource-java.lang.String-&quot;&gt; &lt;code&gt;getResource(String)&lt;/code&gt; &lt;/a&gt;方法一致。这应该确保Enumeration的 &lt;code&gt;nextElement&lt;/code&gt; 方法返回的第一个元素与 &lt;code&gt;getResource(String)&lt;/code&gt; 方法将返回的资源相同。</target>
        </trans-unit>
        <trans-unit id="059fdccbaa1b79359a5fe3e6137c458d9b8b9713" translate="yes" xml:space="preserve">
          <source>When overriding this method it is recommended that an implementation ensures that any delegation is consistent with the &lt;a href=&quot;classloader#getResources-java.lang.String-&quot;&gt;&lt;code&gt;getResources(String)&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">重写此方法时，建议实现确保任何委托与&lt;a href=&quot;classloader#getResources-java.lang.String-&quot;&gt; &lt;code&gt;getResources(String)&lt;/code&gt; &lt;/a&gt;方法一致。</target>
        </trans-unit>
        <trans-unit id="bc58d21adb8af8af625121a5b2b080c75e23b139" translate="yes" xml:space="preserve">
          <source>When parsing in lenient mode, only the hours are mandatory - minutes and seconds are optional. The colons are required if the specified pattern contains a colon. If the specified pattern is &quot;+HH&quot;, the presence of colons is determined by whether the character after the hour digits is a colon or not. If the offset cannot be parsed then an exception is thrown unless the section of the formatter is optional.</source>
          <target state="translated">在宽松模式下解析时,只有小时是必须的,分和秒是可选的。如果指定的模式包含冒号,则冒号是必须的。如果指定的模式是 &quot;+HH&quot;,那么冒号的存在取决于小时数字后面的字符是否是冒号。如果偏移量不能被解析,那么就会抛出一个异常,除非格式器的部分是可选的。</target>
        </trans-unit>
        <trans-unit id="4bcac0e3e99ade4d27a61abe4610e8ad6c3973f0" translate="yes" xml:space="preserve">
          <source>When parsing in strict mode, the input must contain the mandatory and optional elements are defined by the specified pattern. If the offset cannot be parsed then an exception is thrown unless the section of the formatter is optional.</source>
          <target state="translated">在严格模式下解析时,输入必须包含强制性元素,可选元素由指定的模式定义。如果偏移量不能被解析,那么就会抛出一个异常,除非格式器的部分是可选的。</target>
        </trans-unit>
        <trans-unit id="631f29a71edc58dfc93bdc965a349f3c402f1d37" translate="yes" xml:space="preserve">
          <source>When parsing in strict mode, the number of parsed digits must be between the minimum and maximum width. In strict mode, if the minimum and maximum widths are equal and there is no decimal point then the parser will participate in adjacent value parsing, see &lt;a href=&quot;#appendValue(java.time.temporal.TemporalField,int)&quot;&gt;&lt;code&gt;appendValue(java.time.temporal.TemporalField,int)&lt;/code&gt;&lt;/a&gt;. When parsing in lenient mode, the minimum width is considered to be zero and the maximum is nine.</source>
          <target state="translated">在严格模式下解析时，解析位数必须在最小和最大宽度之间。在严格模式下，如果最小和最大宽度相等且没有小数点，则解析器将参与相邻的值解析，请参见&lt;a href=&quot;#appendValue(java.time.temporal.TemporalField,int)&quot;&gt; &lt;code&gt;appendValue(java.time.temporal.TemporalField,int)&lt;/code&gt; &lt;/a&gt;。在宽大模式下分析时，最小宽度被视为零，最大宽度被视为九。</target>
        </trans-unit>
        <trans-unit id="88186acbb81a8c14eb592e644ed27a9e055dc197" translate="yes" xml:space="preserve">
          <source>When parsing in strict mode, the number of parsed digits must be between the minimum and maximum width. When parsing in lenient mode, the minimum width is considered to be zero and the maximum is nine.</source>
          <target state="translated">在严格模式下解析时,解析的数字必须在最小和最大宽度之间。在宽松模式下解析时,最小宽度为0,最大宽度为9。</target>
        </trans-unit>
        <trans-unit id="d50f0289d83049487a7e415ef71230bcec841f7c" translate="yes" xml:space="preserve">
          <source>When parsing in strict mode, the number of parsed digits must match the fractional digits. When parsing in lenient mode, any number of fractional digits from zero to nine are accepted.</source>
          <target state="translated">当在严格模式下进行解析时,解析的数字必须与小数位数一致。当在宽松模式下进行解析时,可以接受从0到9的任何数量的小数位。</target>
        </trans-unit>
        <trans-unit id="398b9ccde24d723bc63ead376818c485f7b9a32f" translate="yes" xml:space="preserve">
          <source>When parsing this field it behaves equivalent to the following: The value is validated from 0 to 1 in strict and smart mode. In lenient mode the value is not validated. It is combined with &lt;code&gt;HOUR_OF_AMPM&lt;/code&gt; to form &lt;code&gt;HOUR_OF_DAY&lt;/code&gt; by multiplying the {AMPM_OF_DAY} value by 12.</source>
          <target state="translated">解析此字段时，其行为等同于以下内容：在严格和智能模式下，该值从0到1进行验证。在宽大模式下，该值未被验证。通过将{AMPM_OF_DAY}值乘以12，将其与 &lt;code&gt;HOUR_OF_AMPM&lt;/code&gt; 组合形成 &lt;code&gt;HOUR_OF_DAY&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fc167eb2f61a597fa4fcdf11893ccfde6bdc0602" translate="yes" xml:space="preserve">
          <source>When parsing this field it behaves equivalent to the following: The value is validated from 0 to 11 in strict and smart mode. In lenient mode the value is not validated. It is combined with &lt;code&gt;AMPM_OF_DAY&lt;/code&gt; to form &lt;code&gt;HOUR_OF_DAY&lt;/code&gt; by multiplying the {AMPM_OF_DAY} value by 12.</source>
          <target state="translated">解析此字段时，其行为等效于以下内容：在严格和智能模式下，该值从0到11进行验证。在宽大模式下，该值未被验证。通过将{AMPM_OF_DAY}值乘以12，将其与 &lt;code&gt;AMPM_OF_DAY&lt;/code&gt; 组合以形成 &lt;code&gt;HOUR_OF_DAY&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="957785487bc5a171742676f4c57e468f23bbf945" translate="yes" xml:space="preserve">
          <source>When parsing this field it behaves equivalent to the following: The value is validated from 1 to 12 in strict mode and from 0 to 12 in smart mode. In lenient mode the value is not validated. The field is converted to an &lt;code&gt;HOUR_OF_AMPM&lt;/code&gt; with the same value, unless the value is 12, in which case it is converted to 0.</source>
          <target state="translated">解析此字段时，其行为等效于以下内容：在严格模式下，该值从1到12进行验证；在智能模式下，该值从0到12进行验证。在宽大模式下，该值未被验证。该字段将转换为具有相同值的 &lt;code&gt;HOUR_OF_AMPM&lt;/code&gt; ，除非该值为12，在这种情况下，它将转换为0。</target>
        </trans-unit>
        <trans-unit id="392153078b1342cc9b804c5665b0c975ca3bc7c5" translate="yes" xml:space="preserve">
          <source>When parsing this field it behaves equivalent to the following: The value is validated from 1 to 24 in strict mode and from 0 to 24 in smart mode. In lenient mode the value is not validated. The field is converted to an &lt;code&gt;HOUR_OF_DAY&lt;/code&gt; with the same value, unless the value is 24, in which case it is converted to 0.</source>
          <target state="translated">解析此字段时，其行为等效于以下内容：在严格模式下，该值从1到24验证；在智能模式下，该值从0到24验证。在宽大模式下，该值未被验证。该字段将转换为具有相同值的 &lt;code&gt;HOUR_OF_DAY&lt;/code&gt; ，除非该值为24，在这种情况下，它将转换为0。</target>
        </trans-unit>
        <trans-unit id="99eb9e50057d1c711aa0384492b14a1cc96c9df7" translate="yes" xml:space="preserve">
          <source>When parsing this field it behaves equivalent to the following: The value is validated in strict and smart mode but not in lenient mode.</source>
          <target state="translated">当解析这个字段时,它的行为等同于以下。该值在严格和智能模式下有效,但在宽松模式下无效。</target>
        </trans-unit>
        <trans-unit id="1fc9716f73232473fc7fb6cbb3857d50c0ce6738" translate="yes" xml:space="preserve">
          <source>When parsing this field it behaves equivalent to the following: The value is validated in strict and smart mode but not in lenient mode. The field is combined with &lt;code&gt;MINUTE_OF_HOUR&lt;/code&gt;, &lt;code&gt;SECOND_OF_MINUTE&lt;/code&gt; and &lt;code&gt;NANO_OF_SECOND&lt;/code&gt; to produce a &lt;code&gt;LocalTime&lt;/code&gt;. In lenient mode, any excess days are added to the parsed date, or made available via &lt;a href=&quot;../format/datetimeformatter#parsedExcessDays()&quot;&gt;&lt;code&gt;DateTimeFormatter.parsedExcessDays()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">解析此字段时，其行为等效于以下内容：该值在严格和智能模式下经过验证，但在宽松模式下未经验证。该字段与组合 &lt;code&gt;MINUTE_OF_HOUR&lt;/code&gt; ， &lt;code&gt;SECOND_OF_MINUTE&lt;/code&gt; 和 &lt;code&gt;NANO_OF_SECOND&lt;/code&gt; 以产生 &lt;code&gt;LocalTime&lt;/code&gt; 。在宽大模式下，任何多余的天数都将添加到解析日期中，或通过&lt;a href=&quot;../format/datetimeformatter#parsedExcessDays()&quot;&gt; &lt;code&gt;DateTimeFormatter.parsedExcessDays()&lt;/code&gt; &lt;/a&gt;使其可用。</target>
        </trans-unit>
        <trans-unit id="2ddaf4c446a794e052910439758bc7ef035eeef6" translate="yes" xml:space="preserve">
          <source>When parsing this field it behaves equivalent to the following: The value is validated in strict and smart mode but not in lenient mode. The field is combined with &lt;code&gt;MINUTE_OF_HOUR&lt;/code&gt;, &lt;code&gt;SECOND_OF_MINUTE&lt;/code&gt; and &lt;code&gt;NANO_OF_SECOND&lt;/code&gt; to produce a &lt;code&gt;LocalTime&lt;/code&gt;. In lenient mode, any excess days are added to the parsed date, or made available via &lt;a href=&quot;../format/datetimeformatter#parsedExcessDays--&quot;&gt;&lt;code&gt;DateTimeFormatter.parsedExcessDays()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">解析此字段时，其行为等效于以下内容：该值在严格和智能模式下经过验证，但在宽松模式下未经验证。该字段与组合 &lt;code&gt;MINUTE_OF_HOUR&lt;/code&gt; ， &lt;code&gt;SECOND_OF_MINUTE&lt;/code&gt; 和 &lt;code&gt;NANO_OF_SECOND&lt;/code&gt; 以产生 &lt;code&gt;LocalTime&lt;/code&gt; 。在宽大模式下，任何多余的天数都将添加到解析日期中，或通过&lt;a href=&quot;../format/datetimeformatter#parsedExcessDays--&quot;&gt; &lt;code&gt;DateTimeFormatter.parsedExcessDays()&lt;/code&gt; &lt;/a&gt;使其可用。</target>
        </trans-unit>
        <trans-unit id="3ae9bc249b42914740d59028697394c29456af8c" translate="yes" xml:space="preserve">
          <source>When parsing this field it behaves equivalent to the following: The value is validated in strict and smart mode but not in lenient mode. The field is resolved in combination with &lt;code&gt;MICRO_OF_SECOND&lt;/code&gt; to produce &lt;code&gt;NANO_OF_SECOND&lt;/code&gt;.</source>
          <target state="translated">解析此字段时，其行为等效于以下内容：该值在严格和智能模式下经过验证，但在宽松模式下未经验证。结合 &lt;code&gt;MICRO_OF_SECOND&lt;/code&gt; 解析该字段以产生 &lt;code&gt;NANO_OF_SECOND&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a924c762f617440d33adf98834b01ed6f029b945" translate="yes" xml:space="preserve">
          <source>When parsing this field it behaves equivalent to the following: The value is validated in strict and smart mode but not in lenient mode. The field is resolved in combination with &lt;code&gt;MILLI_OF_SECOND&lt;/code&gt; and &lt;code&gt;MICRO_OF_SECOND&lt;/code&gt;.</source>
          <target state="translated">解析此字段时，其行为等效于以下内容：该值在严格和智能模式下经过验证，但在宽松模式下未经验证。结合 &lt;code&gt;MILLI_OF_SECOND&lt;/code&gt; 和 &lt;code&gt;MICRO_OF_SECOND&lt;/code&gt; 解析该字段。</target>
        </trans-unit>
        <trans-unit id="a8dbf53e5aefb77318b4486598a6313d9b941472" translate="yes" xml:space="preserve">
          <source>When parsing this field it behaves equivalent to the following: The value is validated in strict and smart mode but not in lenient mode. The field is resolved in combination with &lt;code&gt;MILLI_OF_SECOND&lt;/code&gt; to produce &lt;code&gt;NANO_OF_SECOND&lt;/code&gt;.</source>
          <target state="translated">解析此字段时，其行为等效于以下内容：该值在严格和智能模式下经过验证，但在宽松模式下未经验证。结合 &lt;code&gt;MILLI_OF_SECOND&lt;/code&gt; 解析该字段以产生 &lt;code&gt;NANO_OF_SECOND&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c800d57db7922ab39c14b13ae86f803dc109a26b" translate="yes" xml:space="preserve">
          <source>When parsing this field it behaves equivalent to the following: The value is validated in strict and smart mode but not in lenient mode. The value is split to form &lt;code&gt;MICRO_OF_SECOND&lt;/code&gt;, &lt;code&gt;SECOND_OF_MINUTE&lt;/code&gt;, &lt;code&gt;MINUTE_OF_HOUR&lt;/code&gt; and &lt;code&gt;HOUR_OF_DAY&lt;/code&gt; fields.</source>
          <target state="translated">解析此字段时，其行为等效于以下内容：该值在严格和智能模式下经过验证，但在宽松模式下未经验证。该值被拆分为 &lt;code&gt;MICRO_OF_SECOND&lt;/code&gt; ， &lt;code&gt;SECOND_OF_MINUTE&lt;/code&gt; ， &lt;code&gt;MINUTE_OF_HOUR&lt;/code&gt; 和 &lt;code&gt;HOUR_OF_DAY&lt;/code&gt; 字段。</target>
        </trans-unit>
        <trans-unit id="c294e00d68fa9137c919614e2026adac17298586" translate="yes" xml:space="preserve">
          <source>When parsing this field it behaves equivalent to the following: The value is validated in strict and smart mode but not in lenient mode. The value is split to form &lt;code&gt;MILLI_OF_SECOND&lt;/code&gt;, &lt;code&gt;SECOND_OF_MINUTE&lt;/code&gt;, &lt;code&gt;MINUTE_OF_HOUR&lt;/code&gt; and &lt;code&gt;HOUR_OF_DAY&lt;/code&gt; fields.</source>
          <target state="translated">解析此字段时，其行为等效于以下内容：该值在严格和智能模式下经过验证，但在宽松模式下未经验证。将该值拆分为以下形式： &lt;code&gt;MILLI_OF_SECOND&lt;/code&gt; ， &lt;code&gt;SECOND_OF_MINUTE&lt;/code&gt; ， &lt;code&gt;MINUTE_OF_HOUR&lt;/code&gt; 和 &lt;code&gt;HOUR_OF_DAY&lt;/code&gt; 字段。</target>
        </trans-unit>
        <trans-unit id="f645cbf7fae3ea37f1aeb723d42fd638100f86e8" translate="yes" xml:space="preserve">
          <source>When parsing this field it behaves equivalent to the following: The value is validated in strict and smart mode but not in lenient mode. The value is split to form &lt;code&gt;MINUTE_OF_HOUR&lt;/code&gt; and &lt;code&gt;HOUR_OF_DAY&lt;/code&gt; fields.</source>
          <target state="translated">解析此字段时，其行为等效于以下内容：该值在严格和智能模式下经过验证，但在宽松模式下未经验证。将该值拆分为 &lt;code&gt;MINUTE_OF_HOUR&lt;/code&gt; 和 &lt;code&gt;HOUR_OF_DAY&lt;/code&gt; 字段。</target>
        </trans-unit>
        <trans-unit id="1be57e4bffee0d932e9b78c3b2c86a25070821da" translate="yes" xml:space="preserve">
          <source>When parsing this field it behaves equivalent to the following: The value is validated in strict and smart mode but not in lenient mode. The value is split to form &lt;code&gt;NANO_OF_SECOND&lt;/code&gt;, &lt;code&gt;SECOND_OF_MINUTE&lt;/code&gt;, &lt;code&gt;MINUTE_OF_HOUR&lt;/code&gt; and &lt;code&gt;HOUR_OF_DAY&lt;/code&gt; fields.</source>
          <target state="translated">解析此字段时，其行为等效于以下内容：该值在严格和智能模式下经过验证，但在宽松模式下未经验证。该值被拆分成 &lt;code&gt;NANO_OF_SECOND&lt;/code&gt; ， &lt;code&gt;SECOND_OF_MINUTE&lt;/code&gt; ， &lt;code&gt;MINUTE_OF_HOUR&lt;/code&gt; 和 &lt;code&gt;HOUR_OF_DAY&lt;/code&gt; 字段。</target>
        </trans-unit>
        <trans-unit id="375544438a835cc62e84a73073301cc45d0d9edd" translate="yes" xml:space="preserve">
          <source>When parsing this field it behaves equivalent to the following: The value is validated in strict and smart mode but not in lenient mode. The value is split to form &lt;code&gt;SECOND_OF_MINUTE&lt;/code&gt;, &lt;code&gt;MINUTE_OF_HOUR&lt;/code&gt; and &lt;code&gt;HOUR_OF_DAY&lt;/code&gt; fields.</source>
          <target state="translated">解析此字段时，其行为等效于以下内容：该值在严格和智能模式下经过验证，但在宽松模式下未经验证。该值被拆分为 &lt;code&gt;SECOND_OF_MINUTE&lt;/code&gt; ， &lt;code&gt;MINUTE_OF_HOUR&lt;/code&gt; 和 &lt;code&gt;HOUR_OF_DAY&lt;/code&gt; 字段。</target>
        </trans-unit>
        <trans-unit id="4cd8446097afcf131ca40bba9bd5d77aaa9438f7" translate="yes" xml:space="preserve">
          <source>When parsing, there are two distinct cases to consider. If a chronology has been parsed directly from the text, perhaps because &lt;a href=&quot;datetimeformatterbuilder#appendChronologyId()&quot;&gt;&lt;code&gt;DateTimeFormatterBuilder.appendChronologyId()&lt;/code&gt;&lt;/a&gt; was used, then this override chronology has no effect. If no zone has been parsed, then this override chronology will be used to interpret the &lt;code&gt;ChronoField&lt;/code&gt; values into a date according to the date resolving rules of the chronology.</source>
          <target state="translated">解析时，要考虑两种不同的情况。如果直接从文本中分析了年代，则可能是因为使用了&lt;a href=&quot;datetimeformatterbuilder#appendChronologyId()&quot;&gt; &lt;code&gt;DateTimeFormatterBuilder.appendChronologyId()&lt;/code&gt; &lt;/a&gt;，所以此替代年代没有任何作用。如果未解析任何区域，则将使用该替代年代，以根据年代的日期解析规则将 &lt;code&gt;ChronoField&lt;/code&gt; 值解释为一个日期。</target>
        </trans-unit>
        <trans-unit id="f28daa7170bb1fcc870df5a101d2c5b9ccdbc619" translate="yes" xml:space="preserve">
          <source>When parsing, there are two distinct cases to consider. If a chronology has been parsed directly from the text, perhaps because &lt;a href=&quot;datetimeformatterbuilder#appendChronologyId--&quot;&gt;&lt;code&gt;DateTimeFormatterBuilder.appendChronologyId()&lt;/code&gt;&lt;/a&gt; was used, then this override chronology has no effect. If no zone has been parsed, then this override chronology will be used to interpret the &lt;code&gt;ChronoField&lt;/code&gt; values into a date according to the date resolving rules of the chronology.</source>
          <target state="translated">解析时，要考虑两种不同的情况。如果直接从文本中分析了年代，则可能是因为使用了&lt;a href=&quot;datetimeformatterbuilder#appendChronologyId--&quot;&gt; &lt;code&gt;DateTimeFormatterBuilder.appendChronologyId()&lt;/code&gt; &lt;/a&gt;，所以该替代年代没有任何作用。如果未解析任何区域，则将使用该替代年代，以根据年代的日期解析规则将 &lt;code&gt;ChronoField&lt;/code&gt; 值解释为一个日期。</target>
        </trans-unit>
        <trans-unit id="be3406dfdd119662bd0b600c9668e269a43af897" translate="yes" xml:space="preserve">
          <source>When parsing, there are two distinct cases to consider. If a zone has been parsed directly from the text, perhaps because &lt;a href=&quot;datetimeformatterbuilder#appendZoneId()&quot;&gt;&lt;code&gt;DateTimeFormatterBuilder.appendZoneId()&lt;/code&gt;&lt;/a&gt; was used, then this override zone has no effect. If no zone has been parsed, then this override zone will be included in the result of the parse where it can be used to build instants and date-times.</source>
          <target state="translated">解析时，要考虑两种不同的情况。如果直接从文本中解析了区域，则可能是因为使用了&lt;a href=&quot;datetimeformatterbuilder#appendZoneId()&quot;&gt; &lt;code&gt;DateTimeFormatterBuilder.appendZoneId()&lt;/code&gt; &lt;/a&gt;，所以此覆盖区域无效。如果没有解析任何区域，则此覆盖区域将包含在解析结果中，可用于构建即时和日期时间。</target>
        </trans-unit>
        <trans-unit id="a965e09e870a4e87e4a218aed3653bd2efbce188" translate="yes" xml:space="preserve">
          <source>When parsing, there are two distinct cases to consider. If a zone has been parsed directly from the text, perhaps because &lt;a href=&quot;datetimeformatterbuilder#appendZoneId--&quot;&gt;&lt;code&gt;DateTimeFormatterBuilder.appendZoneId()&lt;/code&gt;&lt;/a&gt; was used, then this override zone has no effect. If no zone has been parsed, then this override zone will be included in the result of the parse where it can be used to build instants and date-times.</source>
          <target state="translated">解析时，要考虑两种不同的情况。如果直接从文本中解析了区域，则可能是因为使用了&lt;a href=&quot;datetimeformatterbuilder#appendZoneId--&quot;&gt; &lt;code&gt;DateTimeFormatterBuilder.appendZoneId()&lt;/code&gt; &lt;/a&gt;，所以此覆盖区域无效。如果没有解析任何区域，则此覆盖区域将包含在解析结果中，可在该结果中用于构建瞬间和日期时间。</target>
        </trans-unit>
        <trans-unit id="9264bb427a83af410610e532031647c00607e8c7" translate="yes" xml:space="preserve">
          <source>When passed a class representing a primitive type, returns the class representing the corresponding wrapper type.</source>
          <target state="translated">当传递一个代表基元类型的类时,返回代表相应包装器类型的类。</target>
        </trans-unit>
        <trans-unit id="be1da10029189914f99bc7ebde561e24a5d3c404" translate="yes" xml:space="preserve">
          <source>When passed a class representing a primitive type, returns the class representing the corresponding wrapper type. I.e. calling it with &lt;code&gt;int.class&lt;/code&gt; will return &lt;code&gt;Integer.class&lt;/code&gt;. If passed a class that is not a primitive type, returns null.</source>
          <target state="translated">当传递表示原始类型的类时，返回表示相应包装器类型的类。即用 &lt;code&gt;int.class&lt;/code&gt; 调用它将返回 &lt;code&gt;Integer.class&lt;/code&gt; 。如果传递的不是原始类型的类，则返回null。</target>
        </trans-unit>
        <trans-unit id="8d49812d12bf76de817b7cbc2516a1f236f2d1d4" translate="yes" xml:space="preserve">
          <source>When passed a class representing a wrapper for a primitive type, returns the class representing the corresponding primitive type.</source>
          <target state="translated">当传递一个代表基元类型的包装器的类时,返回代表相应基元类型的类。</target>
        </trans-unit>
        <trans-unit id="0bc5124ca5a36473d0fea5385e8be8c746341c88" translate="yes" xml:space="preserve">
          <source>When passed a class representing a wrapper for a primitive type, returns the class representing the corresponding primitive type. I.e. calling it with &lt;code&gt;Integer.class&lt;/code&gt; will return &lt;code&gt;Integer.TYPE&lt;/code&gt;. If passed a class that is not a wrapper for primitive type, returns null.</source>
          <target state="translated">当传递一个表示原始类型包装器的类时，返回表示相应原始类型的类。即用 &lt;code&gt;Integer.class&lt;/code&gt; 调用它会返回 &lt;code&gt;Integer.TYPE&lt;/code&gt; 。如果传递了不是原始类型包装器的类，则返回null。</target>
        </trans-unit>
        <trans-unit id="6cf15c2cadbf1d2f9101df44d9400a393f3cd777" translate="yes" xml:space="preserve">
          <source>When passing information to a Java subprocess, &lt;a href=&quot;#EnvironmentVSSystemProperties&quot;&gt;system properties&lt;/a&gt; are generally preferred over environment variables.</source>
          <target state="translated">将信息传递给Java子流程时，通常优先于环境变量使用&lt;a href=&quot;#EnvironmentVSSystemProperties&quot;&gt;系统属性&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="678a637edd80c217c54e61b9e25c8439ebfa7bf7" translate="yes" xml:space="preserve">
          <source>When passing information to a Java subprocess, &lt;a href=&quot;system#EnvironmentVSSystemProperties&quot;&gt;system properties&lt;/a&gt; are generally preferred over environment variables.</source>
          <target state="translated">将信息传递给Java子流程时，通常优先于环境变量使用&lt;a href=&quot;system#EnvironmentVSSystemProperties&quot;&gt;系统属性&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="468a7461c40962d54c04cec0adab0486b4f75193" translate="yes" xml:space="preserve">
          <source>When pending counts can be precomputed, they can be established in the constructor:</source>
          <target state="translated">当待定计数可以预先计算时,可以在构造函数中建立。</target>
        </trans-unit>
        <trans-unit id="ee906d2367a93c8434f7349879af51a79dadb0c5" translate="yes" xml:space="preserve">
          <source>When possible this simply changes the name of the given node, otherwise this creates a new node with the specified name and replaces the existing node with the new node as described below.</source>
          <target state="translated">在可能的情况下,这只是简单地改变给定节点的名称,否则会用指定的名称创建一个新的节点,并用新节点替换现有的节点,如下所述。</target>
        </trans-unit>
        <trans-unit id="1d9df05f42f191fd30f4013d3bc48c1dc951d2b7" translate="yes" xml:space="preserve">
          <source>When processing logging output, if a Handler encounters problems then rather than throwing an Exception back to the issuer of the logging call (who is unlikely to be interested) the Handler should call its associated ErrorManager.</source>
          <target state="translated">在处理日志输出时,如果处理程序遇到问题,那么处理程序应该调用其关联的ErrorManager,而不是将一个Exception丢回给日志调用的发出者(后者不太可能感兴趣)。</target>
        </trans-unit>
        <trans-unit id="3e179726ee6a6f7644de1db6d67bff96f348bf5e" translate="yes" xml:space="preserve">
          <source>When providing implementations for the new methods in the subclass, use this newly defined method to get the initial context.</source>
          <target state="translated">当为子类中的新方法提供实现时,使用这个新定义的方法来获取初始上下文。</target>
        </trans-unit>
        <trans-unit id="ac5bba685209949c2cc3f67e3cab5d31b729dde6" translate="yes" xml:space="preserve">
          <source>When reading a document if a CRLF is encountered a property with this name is added and the value will be &quot;\r\n&quot;.</source>
          <target state="translated">当读取文档时,如果遇到CRLF,就会添加一个带有这个名字的属性,其值将为&quot;\r\n&quot;。</target>
        </trans-unit>
        <trans-unit id="093663f9827304bad79b038495f5092c12dadca2" translate="yes" xml:space="preserve">
          <source>When reading a provider-configuration file, or loading or instantiating a provider class named in a provider-configuration file, then &lt;code&gt;
 ServiceConfigurationError&lt;/code&gt; can be thrown for the following reasons:</source>
          <target state="translated">读取提供程序配置文件或加载或实例化提供程序配置文件中命名的提供程序类时，由于以下原因，可能引发 &lt;code&gt; ServiceConfigurationError&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="ff2175fd5a0c9824ca3682906ca8e8c785a2e2f5" translate="yes" xml:space="preserve">
          <source>When reading an image, its per-stream and per-image metadata is made available as an &lt;code&gt;IIOMetadata&lt;/code&gt; object. The internals of this object are specific to the plug-in that created it. Its contents may be accessed in the form of an XML &lt;code&gt;Document&lt;/code&gt;, which is implemented as a tree of &lt;code&gt;IIOMetadataNode&lt;/code&gt; objects.</source>
          <target state="translated">读取图像时，其每个流和每个图像元数据可作为 &lt;code&gt;IIOMetadata&lt;/code&gt; 对象使用。该对象的内部特定于创建它的插件。它的内容可以以XML &lt;code&gt;Document&lt;/code&gt; 的形式访问，该文档被实现为 &lt;code&gt;IIOMetadataNode&lt;/code&gt; 对象的树。</target>
        </trans-unit>
        <trans-unit id="c064a445936071cf19ecbcb598a24cd0f5fcf1e9" translate="yes" xml:space="preserve">
          <source>When reading from a standard &lt;code&gt;InputStream&lt;/code&gt;, it may be necessary to save previously read information in a cache since the underlying stream does not allow data to be re-read. Similarly, when writing to a standard &lt;code&gt;OutputStream&lt;/code&gt;, a cache may be used to allow a previously written value to be changed before flushing it to the final destination.</source>
          <target state="translated">从标准 &lt;code&gt;InputStream&lt;/code&gt; 进行读取时，可能有必要将先前读取的信息保存在缓存中，因为基础流不允许重新读取数据。类似地，当写入标准 &lt;code&gt;OutputStream&lt;/code&gt; 时，可以使用缓存来允许在将先前写入的值刷新到最终目的地之前对其进行更改。</target>
        </trans-unit>
        <trans-unit id="967c7f2fd4e6ef5e74644bcb7e0d2a8f5a951bbd" translate="yes" xml:space="preserve">
          <source>When reading, a &lt;code&gt;TIFFDirectory&lt;/code&gt; may be created by passing the value returned by &lt;a href=&quot;../../imagereader#getImageMetadata(int)&quot;&gt;&lt;code&gt;ImageReader.getImageMetadata()&lt;/code&gt;&lt;/a&gt; to &lt;a href=&quot;#createFromMetadata(javax.imageio.metadata.IIOMetadata)&quot;&gt;&lt;code&gt;createFromMetadata()&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;tifffield&quot;&gt;&lt;code&gt;TIFFField&lt;/code&gt;&lt;/a&gt;s in the directory may then be obtained using the accessor methods provided in this class.</source>
          <target state="translated">读取时，一个 &lt;code&gt;TIFFDirectory&lt;/code&gt; 可以通过返回的值传递被创建&lt;a href=&quot;../../imagereader#getImageMetadata(int)&quot;&gt; &lt;code&gt;ImageReader.getImageMetadata()&lt;/code&gt; &lt;/a&gt;至&lt;a href=&quot;#createFromMetadata(javax.imageio.metadata.IIOMetadata)&quot;&gt; &lt;code&gt;createFromMetadata()&lt;/code&gt; &lt;/a&gt;。然后可以使用此类提供的访问器方法获取目录中的&lt;a href=&quot;tifffield&quot;&gt; &lt;code&gt;TIFFField&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1d63913965696a9f9c40e306e81ce84323b71ddc" translate="yes" xml:space="preserve">
          <source>When reading, if the layout of the destination has been set using this method, each call to an &lt;code&gt;ImageReader&lt;/code&gt;&lt;code&gt;read&lt;/code&gt; method will return a new &lt;code&gt;BufferedImage&lt;/code&gt; using the format specified by the supplied type specifier. As a side effect, any destination &lt;code&gt;BufferedImage&lt;/code&gt; set by &lt;code&gt;ImageReadParam.setDestination(BufferedImage)&lt;/code&gt; will no longer be set as the destination. In other words, this method may be thought of as calling &lt;code&gt;setDestination((BufferedImage)null)&lt;/code&gt;.</source>
          <target state="translated">读取时，如果已使用此方法设置了目标的布局，则对 &lt;code&gt;ImageReader&lt;/code&gt; &lt;code&gt;read&lt;/code&gt; 方法的每次调用都将使用提供的类型说明符指定的格式返回一个新的 &lt;code&gt;BufferedImage&lt;/code&gt; 。副作用是，不再将 &lt;code&gt;ImageReadParam.setDestination(BufferedImage)&lt;/code&gt; 设置的任何目标 &lt;code&gt;BufferedImage&lt;/code&gt; 设置为目标。换句话说，可以将此方法视为调用 &lt;code&gt;setDestination((BufferedImage)null)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a5b68a7995942b34e6fb81c415ca17f384da8a72" translate="yes" xml:space="preserve">
          <source>When reading, the region to be written within the destination &lt;code&gt;BufferedImage&lt;/code&gt; will start at this offset and have a width and height determined by the source region of interest, the subsampling parameters, and the destination bounds.</source>
          <target state="translated">读取时，要在目标 &lt;code&gt;BufferedImage&lt;/code&gt; 中写入的区域将从该偏移量开始，并且其宽度和高度由感兴趣的源区域，子采样参数和目标边界确定。</target>
        </trans-unit>
        <trans-unit id="948c72e84f23a6d80190a196cfc3c27ca22ecf53" translate="yes" xml:space="preserve">
          <source>When replacing a leaf this will attempt to make sure there is a newline present if one is needed. This may result in an additional element being inserted. Consider, if you were to replace a character element that contained a newline with &amp;lt;img&amp;gt; this would create two elements, one for the image, and one for the newline.</source>
          <target state="translated">替换叶子时，这将尝试确保存在换行符（如果需要的话）。这可能会导致插入其他元素。考虑一下，如果要用&amp;lt;img&amp;gt;替换包含换行符的character元素，这将创建两个元素，一个用于图像，一个用于换行。</target>
        </trans-unit>
        <trans-unit id="e4073d7c2224019b5107064c858d7e912ce2c1aa" translate="yes" xml:space="preserve">
          <source>When requested by setting the parameter &quot;&lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#parameter-normalize-characters&quot;&gt;normalize-characters&lt;/a&gt;&quot; on &lt;code&gt;LSSerializer&lt;/code&gt; to true, character normalization is performed according to the definition of &lt;a href=&quot;http://www.w3.org/TR/2004/REC-xml11-20040204/#dt-fullnorm&quot;&gt;fully normalized&lt;/a&gt; characters included in appendix E of [&lt;a href=&quot;http://www.w3.org/TR/2004/REC-xml11-20040204/&quot;&gt;XML 1.1&lt;/a&gt;] on all data to be serialized, both markup and character data. The character normalization process affects only the data as it is being written; it does not alter the DOM's view of the document after serialization has completed.</source>
          <target state="translated">通过将 &lt;code&gt;LSSerializer&lt;/code&gt; 上的参数&amp;ldquo; &lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#parameter-normalize-characters&quot;&gt;normalize-characters&lt;/a&gt; &amp;rdquo;设置为true进行请求时，将根据[ &lt;a href=&quot;http://www.w3.org/TR/2004/REC-xml11-20040204/&quot;&gt;XML 1.1&lt;/a&gt; ]附录E中包含的&lt;a href=&quot;http://www.w3.org/TR/2004/REC-xml11-20040204/#dt-fullnorm&quot;&gt;完全标准化&lt;/a&gt;字符的定义，对要序列化的所有数据（包括标记和字符数据）执行字符标准化。字符规范化过程仅影响正在写入的数据。序列化完成后，它不会更改文档的DOM视图。</target>
        </trans-unit>
        <trans-unit id="deb3421d1dd9eb4f1df73503f046814ae2b3a1c6" translate="yes" xml:space="preserve">
          <source>When requested by setting the parameter &quot;&lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#parameter-normalize-characters&quot;&gt;normalize-characters&lt;/a&gt;&quot; on &lt;code&gt;LSSerializer&lt;/code&gt; to true, character normalization is performed according to the definition of &lt;a href=&quot;https://www.w3.org/TR/2004/REC-xml11-20040204/#dt-fullnorm&quot;&gt;fully normalized&lt;/a&gt; characters included in appendix E of [&lt;a href=&quot;https://www.w3.org/TR/2004/REC-xml11-20040204/&quot;&gt;XML 1.1&lt;/a&gt;] on all data to be serialized, both markup and character data. The character normalization process affects only the data as it is being written; it does not alter the DOM's view of the document after serialization has completed.</source>
          <target state="translated">通过将 &lt;code&gt;LSSerializer&lt;/code&gt; 上的参数&amp;ldquo; &lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#parameter-normalize-characters&quot;&gt;normalize-characters&lt;/a&gt; &amp;rdquo;设置为true进行请求时，将根据[ &lt;a href=&quot;https://www.w3.org/TR/2004/REC-xml11-20040204/&quot;&gt;XML 1.1&lt;/a&gt; ]附录E中包含的&lt;a href=&quot;https://www.w3.org/TR/2004/REC-xml11-20040204/#dt-fullnorm&quot;&gt;完全标准化&lt;/a&gt;字符的定义，对要序列化的所有数据（包括标记和字符数据）执行字符标准化。字符规范化过程仅影响正在写入的数据。序列化完成后，它不会更改文档的DOM视图。</target>
        </trans-unit>
        <trans-unit id="9829ac48f456c01c997a54312f4d28ae239840e5" translate="yes" xml:space="preserve">
          <source>When requesting a Namespace URI by prefix, the following table describes the returned Namespace URI value for all possible prefix values:</source>
          <target state="translated">当通过前缀请求命名空间URI时,下表描述了所有可能的前缀值的返回命名空间URI值。</target>
        </trans-unit>
        <trans-unit id="8c473adada2bf0879238d13edc56b7303e5f6472" translate="yes" xml:space="preserve">
          <source>When requesting a prefix by Namespace URI, the following table describes the returned prefix value for all Namespace URI values:</source>
          <target state="translated">当通过Namespace URI请求前缀时,下表中描述了所有Namespace URI值的返回前缀值。</target>
        </trans-unit>
        <trans-unit id="4469f523c26a6a607eb001a67af246e496c67ea8" translate="yes" xml:space="preserve">
          <source>When requesting prefixes by Namespace URI, the following table describes the returned prefixes value for all Namespace URI values:</source>
          <target state="translated">当通过Namespace URI请求前缀时,下表描述了所有Namespace URI值的返回前缀值。</target>
        </trans-unit>
        <trans-unit id="47eff58ddedc0bc2eb7327683e454ec2dfb1f6d0" translate="yes" xml:space="preserve">
          <source>When resolving time fields, the map will be altered and null returned. When resolving date fields, the date is normally returned from the method, with the map altered to remove the resolved fields. However, it would also be acceptable for the date fields to be resolved into other &lt;code&gt;ChronoField&lt;/code&gt; instances that can produce a date, such as &lt;code&gt;EPOCH_DAY&lt;/code&gt;.</source>
          <target state="translated">解决时间字段时，地图将被更改并返回null。解决日期字段时，通常从方法返回日期，并更改映射以删除解决的字段。然而，它也将是可接受的日期字段被解析成其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例，可以产生一个日期，如 &lt;code&gt;EPOCH_DAY&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7d8cf7bc5f7e0ab67c20394ce506b32ad70404b7" translate="yes" xml:space="preserve">
          <source>When returning to windowed mode from an exclusive full-screen window, any display changes made by calling &lt;code&gt;setDisplayMode&lt;/code&gt; are automatically restored to their original state.</source>
          <target state="translated">从排他的全屏窗口返回窗口模式时，通过调用 &lt;code&gt;setDisplayMode&lt;/code&gt; 进行的任何显示更改都将自动恢复到其原始状态。</target>
        </trans-unit>
        <trans-unit id="ed495f5df0234ba9158fa7c63e4629f640c9c226" translate="yes" xml:space="preserve">
          <source>When run the following is produced.</source>
          <target state="translated">运行时,会产生以下内容。</target>
        </trans-unit>
        <trans-unit id="71220676e6e26c91102efdd4c23b78003dc6007b" translate="yes" xml:space="preserve">
          <source>When running in an environment which supports modules, processors are encouraged to include the module prefix when describing their supported annotation types. The method &lt;a href=&quot;abstractprocessor#getSupportedAnnotationTypes()&quot;&gt;&lt;code&gt;AbstractProcessor.getSupportedAnnotationTypes&lt;/code&gt;&lt;/a&gt; provides support for stripping off the module prefix when running in an environment without modules.</source>
          <target state="translated">在支持模块的环境中运行时，建议处理器在描述其支持的注释类型时包括模块前缀。方法&lt;a href=&quot;abstractprocessor#getSupportedAnnotationTypes()&quot;&gt; &lt;code&gt;AbstractProcessor.getSupportedAnnotationTypes&lt;/code&gt; &lt;/a&gt;提供了在没有模块的环境中运行时剥离模块前缀的支持。</target>
        </trans-unit>
        <trans-unit id="b2e3a16dad606054ad91ef38f6e33de06fd97381" translate="yes" xml:space="preserve">
          <source>When sending a request that contains a body, the HTTP Client subscribes to the request's &lt;code&gt;BodyPublisher&lt;/code&gt; in order to receive the flow of outgoing request body data. The normal semantics of &lt;a href=&quot;../../../../java.base/java/util/concurrent/flow.subscriber&quot;&gt;&lt;code&gt;Flow.Subscriber&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../../../java.base/java/util/concurrent/flow.publisher&quot;&gt;&lt;code&gt;Flow.Publisher&lt;/code&gt;&lt;/a&gt; are implemented by the HTTP Client and are expected from &lt;code&gt;BodyPublisher&lt;/code&gt; implementations. Each outgoing request results in one HTTP Client &lt;code&gt;Subscriber&lt;/code&gt; subscribing to the &lt;code&gt;BodyPublisher&lt;/code&gt; in order to provide the sequence of byte buffers containing the request body. Instances of &lt;code&gt;
 ByteBuffer&lt;/code&gt; published by the publisher must be allocated by the publisher, and must not be accessed after being published to the HTTP Client. These subscriptions complete normally when the request body is fully sent, and can be canceled or terminated early through error. If a request needs to be resent for any reason, then a new subscription is created which is expected to generate the same data as before.</source>
          <target state="translated">发送包含正文的请求时，HTTP客户端会订阅该请求的 &lt;code&gt;BodyPublisher&lt;/code&gt; ，以接收传出的请求正文数据流。&lt;a href=&quot;../../../../java.base/java/util/concurrent/flow.subscriber&quot;&gt; &lt;code&gt;Flow.Subscriber&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../../../java.base/java/util/concurrent/flow.publisher&quot;&gt; &lt;code&gt;Flow.Publisher&lt;/code&gt; &lt;/a&gt;的常规语义由HTTP客户端实现，并且可以从 &lt;code&gt;BodyPublisher&lt;/code&gt; 实现中获得。每个传出请求都会导致一个HTTP客户端 &lt;code&gt;Subscriber&lt;/code&gt; 订阅 &lt;code&gt;BodyPublisher&lt;/code&gt; ，以提供包含请求正文的字节缓冲区序列。 &lt;code&gt; ByteBuffer&lt;/code&gt; 的实例由发布者发布的内容必须由发布者分配，并且在发布到HTTP客户端之后一定不能访问。这些订阅通常在请求正文完全发送后正常完成，并且可以通过错误提前取消或终止。如果由于某种原因需要重新发送请求，则将创建一个新的订阅，该订阅将生成与以前相同的数据。</target>
        </trans-unit>
        <trans-unit id="76363a09529976afbe0f0801c413175b6a84dc98" translate="yes" xml:space="preserve">
          <source>When sending timer notifications, the timer updates the notification sequence number irrespective of the notification type.</source>
          <target state="translated">发送定时器通知时,无论通知类型如何,定时器都会更新通知序列号。</target>
        </trans-unit>
        <trans-unit id="e95bdd8162adf9968f7adc4afbf013d6f5093728" translate="yes" xml:space="preserve">
          <source>When serializing an &lt;code&gt;Element&lt;/code&gt;, the element is passed to the filter before any of its attributes are passed to the filter. Namespace declaration attributes, and default attributes (except in the case when &quot; discard-default-content&quot; is set to &lt;code&gt;false&lt;/code&gt;), are never passed to the filter.</source>
          <target state="translated">序列化 &lt;code&gt;Element&lt;/code&gt; 时，先将元素传递给过滤器，然后再将其任何属性传递给过滤器。命名空间声明属性和默认属性（除非将&amp;ldquo; discard-default-content&amp;rdquo;设置为 &lt;code&gt;false&lt;/code&gt; 的情况除外）都不会传递到过滤器。</target>
        </trans-unit>
        <trans-unit id="016bd53a30e369ac9500dd916cae37c51e43c195" translate="yes" xml:space="preserve">
          <source>When setting or getting the &lt;code&gt;WEEK_OF_MONTH&lt;/code&gt; or &lt;code&gt;WEEK_OF_YEAR&lt;/code&gt; fields, &lt;code&gt;Calendar&lt;/code&gt; must determine the first week of the month or year as a reference point. The first week of a month or year is defined as the earliest seven day period beginning on &lt;code&gt;getFirstDayOfWeek()&lt;/code&gt; and containing at least &lt;code&gt;getMinimalDaysInFirstWeek()&lt;/code&gt; days of that month or year. Weeks numbered ..., -1, 0 precede the first week; weeks numbered 2, 3,... follow it. Note that the normalized numbering returned by &lt;code&gt;get()&lt;/code&gt; may be different. For example, a specific &lt;code&gt;Calendar&lt;/code&gt; subclass may designate the week before week 1 of a year as week &lt;code&gt;&lt;i&gt;n&lt;/i&gt;&lt;/code&gt; of the previous year.</source>
          <target state="translated">在设置或获取 &lt;code&gt;WEEK_OF_MONTH&lt;/code&gt; 或 &lt;code&gt;WEEK_OF_YEAR&lt;/code&gt; 字段时， &lt;code&gt;Calendar&lt;/code&gt; 必须确定月份或年份的第一周作为参考点。每月或每年的第一 &lt;code&gt;getFirstDayOfWeek()&lt;/code&gt; 为最早的7天时段，从getFirstDayOfWeek（）开始，并且至少包含该月或一年中的 &lt;code&gt;getMinimalDaysInFirstWeek()&lt;/code&gt; 天。在第一周之前编号为...，-1、0的周；编号为2、3，...的星期。请注意，由 &lt;code&gt;get()&lt;/code&gt; 返回的规范化编号可能有所不同。例如，特定的 &lt;code&gt;Calendar&lt;/code&gt; 子类可以将一年的第1周之前的一周指定为上一年的 &lt;code&gt;&lt;i&gt;n&lt;/i&gt;&lt;/code&gt; 周。</target>
        </trans-unit>
        <trans-unit id="d95cdd09e08dbf61e5dd1557a78ec0a6f3ed5062" translate="yes" xml:space="preserve">
          <source>When setting the filter, it should be stateless and idempotent, reporting the same result when passed the same arguments.</source>
          <target state="translated">在设置过滤器时,应该是无状态和幂等的,当传递相同的参数时,报告相同的结果。</target>
        </trans-unit>
        <trans-unit id="6a17a22214c7c2e160d3cfa1f6db1fc4e32a144d" translate="yes" xml:space="preserve">
          <source>When setting this field, the value is allowed to be partially lenient, taking any value from 1 to 92. If the quarter has less than 92 days, then day 92, and potentially day 91, is in the following quarter.</source>
          <target state="translated">设置该字段时,允许取值部分宽松,取1到92的任意值。如果季度的天数少于92天,那么第92天,也可能是第91天,就在下一个季度。</target>
        </trans-unit>
        <trans-unit id="669b10bb52f2a514a970d8c5edffcfcd75525b6b" translate="yes" xml:space="preserve">
          <source>When setting up a print job, a client specifies two things: &lt;b&gt;print data&lt;/b&gt; and &lt;b&gt;processing instructions.&lt;/b&gt; The print data is the actual content to be printed. The processing instructions tell the printer how to print the print data, such as: what media to use, how many copies to print, and whether to print on one or both sides of a sheet. The client specifies these processing instructions with the attribute definitions of the Java Print Service API.</source>
          <target state="translated">设置打印作业时，客户端会指定两件事：&lt;b&gt;打印数据&lt;/b&gt;和&lt;b&gt;处理指令。&lt;/b&gt;打印数据是要打印的实际内容。处理说明告诉打印机如何打印打印数据，例如：使用哪种介质，要打印多少份以及是否在纸的一面或两面打印。客户端使用Java Print Service API的属性定义指定这些处理指令。</target>
        </trans-unit>
        <trans-unit id="3895d679fc7204e5dcd10a6d612e982d4bf1edef" translate="yes" xml:space="preserve">
          <source>When specific characters are mapped into glyphs in some rendering context, instructions in the font itself together with the rasterization process may cause some glyph to have a wider advance than reported.</source>
          <target state="translated">当特定的字符在某些渲染上下文中被映射成字形时,字体本身的指令以及光栅化过程可能会导致某些字形的提前量比报告的要大。</target>
        </trans-unit>
        <trans-unit id="992deb8ce4de81a3a8e6eef7b845fb57e8e29bfe" translate="yes" xml:space="preserve">
          <source>When specified at the doc level, an attribute applies just to that one doc. When specified at the Print Request level, an attribute applies to the whole job, including all the docs in the job. However, an attribute specified at the doc level overrides an attribute in the same category specified at the Print Request level.</source>
          <target state="translated">当在文档级别指定时,属性仅适用于该文档。当在打印请求级别指定时,属性适用于整个作业,包括作业中的所有文档。但是,在文档级别指定的属性会覆盖在打印请求级别指定的同一类别的属性。</target>
        </trans-unit>
        <trans-unit id="812c36aefe75f1f01b1e22e1de7ca89fc2466e0d" translate="yes" xml:space="preserve">
          <source>When submitting a print job to a printer, the client provides the attributes describing the characteristics of the print data, such as the document name, and how the print data should be printed, such as double-sided, five copies. If a print job consists of multiple pieces of print data, different pieces might have different processing instructions, such as 8 x 11 inch media for the first document, and 11 x 17 inch media for another document.</source>
          <target state="translated">当向打印机提交打印作业时,客户端提供描述打印数据特性的属性,如文档名称,以及打印数据的打印方式,如双面、五份。如果一个打印任务由多份打印数据组成,不同的打印数据可能有不同的处理说明,例如第一份文件用8×11英寸的介质,另一份文件用11×17英寸的介质。</target>
        </trans-unit>
        <trans-unit id="8e9ff7cc584e16b6ab10015ab9bcdd0ba01476c5" translate="yes" xml:space="preserve">
          <source>When such a new visit method is added, the default implementation in this class will be to call the &lt;a href=&quot;#visitUnknown(javax.lang.model.element.AnnotationValue,P)&quot;&gt;&lt;code&gt;visitUnknown&lt;/code&gt;&lt;/a&gt; method. A new abstract annotation value visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question. When the new visitor is introduced, all or portions of this visitor may be deprecated.</source>
          <target state="translated">当添加了这样一个新的visit方法时，此类中的默认实现将是调用&lt;a href=&quot;#visitUnknown(javax.lang.model.element.AnnotationValue,P)&quot;&gt; &lt;code&gt;visitUnknown&lt;/code&gt; &lt;/a&gt;方法。还将引入一个新的抽象注释值访问者类，以对应于新的语言级别。对于有问题的访问方法，此访问者将具有不同的默认行为。当引入新访客时，可能会不赞成使用此访客的全部或部分。</target>
        </trans-unit>
        <trans-unit id="7cee9708c809ea2c5706271d9f5de6094df8928a" translate="yes" xml:space="preserve">
          <source>When such a new visit method is added, the default implementation in this class will be to call the &lt;a href=&quot;#visitUnknown(javax.lang.model.element.Element,P)&quot;&gt;&lt;code&gt;visitUnknown&lt;/code&gt;&lt;/a&gt; method. A new abstract element visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question. When the new visitor is introduced, all or portions of this visitor may be deprecated.</source>
          <target state="translated">当添加了这样一个新的visit方法时，此类中的默认实现将是调用&lt;a href=&quot;#visitUnknown(javax.lang.model.element.Element,P)&quot;&gt; &lt;code&gt;visitUnknown&lt;/code&gt; &lt;/a&gt;方法。还将引入一个新的抽象元素访问者类，以对应于新的语言级别。对于有问题的访问方法，此访问者将具有不同的默认行为。当引入新访客时，可能会不赞成使用此访客的全部或部分。</target>
        </trans-unit>
        <trans-unit id="103e345f76c16d48cafc8a85f69a007ae6fc9260" translate="yes" xml:space="preserve">
          <source>When such a new visit method is added, the default implementation in this class will be to call the &lt;a href=&quot;#visitUnknown(javax.lang.model.type.TypeMirror,P)&quot;&gt;&lt;code&gt;visitUnknown&lt;/code&gt;&lt;/a&gt; method. A new abstract type visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question. When the new visitor is introduced, all or portions of this visitor may be deprecated.</source>
          <target state="translated">当添加了这样一个新的visit方法时，此类中的默认实现将是调用&lt;a href=&quot;#visitUnknown(javax.lang.model.type.TypeMirror,P)&quot;&gt; &lt;code&gt;visitUnknown&lt;/code&gt; &lt;/a&gt;方法。还将引入一个新的抽象类型的访问者类，以对应于新的语言级别。对于有问题的访问方法，此访问者将具有不同的默认行为。当引入新访客时，可能会不赞成使用此访客的全部或部分。</target>
        </trans-unit>
        <trans-unit id="f0634269e692a9a236845f34b129b30b4ad1d950" translate="yes" xml:space="preserve">
          <source>When such a new visit method is added, the default implementation in this class will be to call the &lt;a href=&quot;abstractannotationvaluevisitor6#visitUnknown(javax.lang.model.element.AnnotationValue,P)&quot;&gt;&lt;code&gt;visitUnknown&lt;/code&gt;&lt;/a&gt; method. A new abstract annotation value visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question. When the new visitor is introduced, all or portions of this visitor may be deprecated.</source>
          <target state="translated">当添加了这样一个新的visit方法时，此类中的默认实现将是调用&lt;a href=&quot;abstractannotationvaluevisitor6#visitUnknown(javax.lang.model.element.AnnotationValue,P)&quot;&gt; &lt;code&gt;visitUnknown&lt;/code&gt; &lt;/a&gt;方法。还将引入一个新的抽象注释值访问者类，以对应于新的语言级别。对于有问题的访问方法，此访问者将具有不同的默认行为。当引入新访客时，可能会不赞成使用此访客的全部或部分。</target>
        </trans-unit>
        <trans-unit id="5bd8fde8037f05021ae5406815b06bfefd44e332" translate="yes" xml:space="preserve">
          <source>When such a new visit method is added, the default implementation in this class will be to call the &lt;a href=&quot;abstractannotationvaluevisitor6#visitUnknown(javax.lang.model.element.AnnotationValue,P)&quot;&gt;&lt;code&gt;visitUnknown&lt;/code&gt;&lt;/a&gt; method. A new simple annotation value visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question. When the new visitor is introduced, all or portions of this visitor may be deprecated.</source>
          <target state="translated">当添加了这样一个新的visit方法时，此类中的默认实现将是调用&lt;a href=&quot;abstractannotationvaluevisitor6#visitUnknown(javax.lang.model.element.AnnotationValue,P)&quot;&gt; &lt;code&gt;visitUnknown&lt;/code&gt; &lt;/a&gt;方法。还将引入一个新的简单注释值访问者类，以对应于新的语言级别。对于有问题的访问方法，此访问者将具有不同的默认行为。当引入新访客时，可能会不赞成使用此访客的全部或部分。</target>
        </trans-unit>
        <trans-unit id="03ec6c25b6d376081732b85e415911f8c6ec0d3e" translate="yes" xml:space="preserve">
          <source>When such a new visit method is added, the default implementation in this class will be to call the &lt;a href=&quot;abstractannotationvaluevisitor6#visitUnknown-javax.lang.model.element.AnnotationValue-P-&quot;&gt;&lt;code&gt;visitUnknown&lt;/code&gt;&lt;/a&gt; method. A new abstract annotation value visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question. When the new visitor is introduced, all or portions of this visitor may be deprecated.</source>
          <target state="translated">当添加了这样一个新的visit方法时，此类中的默认实现将是调用&lt;a href=&quot;abstractannotationvaluevisitor6#visitUnknown-javax.lang.model.element.AnnotationValue-P-&quot;&gt; &lt;code&gt;visitUnknown&lt;/code&gt; &lt;/a&gt;方法。还将引入一个新的抽象注释值访问者类，以对应于新的语言级别。对于有问题的访问方法，此访问者将具有不同的默认行为。引入新访客后，可能会不赞成使用此访客的全部或部分。</target>
        </trans-unit>
        <trans-unit id="05ff925b46ec11d08257cdc7e971c5f6bf2e8675" translate="yes" xml:space="preserve">
          <source>When such a new visit method is added, the default implementation in this class will be to call the &lt;a href=&quot;abstractannotationvaluevisitor6#visitUnknown-javax.lang.model.element.AnnotationValue-P-&quot;&gt;&lt;code&gt;visitUnknown&lt;/code&gt;&lt;/a&gt; method. A new simple annotation value visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question. When the new visitor is introduced, all or portions of this visitor may be deprecated.</source>
          <target state="translated">当添加了这样一个新的visit方法时，此类中的默认实现将是调用&lt;a href=&quot;abstractannotationvaluevisitor6#visitUnknown-javax.lang.model.element.AnnotationValue-P-&quot;&gt; &lt;code&gt;visitUnknown&lt;/code&gt; &lt;/a&gt;方法。还将引入一个新的简单注释值访问者类，以对应于新的语言级别。对于有问题的访问方法，此访问者将具有不同的默认行为。引入新访客后，可能会不赞成使用此访客的全部或部分。</target>
        </trans-unit>
        <trans-unit id="27c4228447106a355af0159031dee75cd1cf6476" translate="yes" xml:space="preserve">
          <source>When such a new visit method is added, the default implementation in this class will be to call the &lt;a href=&quot;abstractelementvisitor6#visitUnknown(javax.lang.model.element.Element,P)&quot;&gt;&lt;code&gt;visitUnknown&lt;/code&gt;&lt;/a&gt; method. A new abstract element kind visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question. When the new visitor is introduced, all or portions of this visitor may be deprecated.</source>
          <target state="translated">当添加了这样一个新的visit方法时，此类中的默认实现将是调用&lt;a href=&quot;abstractelementvisitor6#visitUnknown(javax.lang.model.element.Element,P)&quot;&gt; &lt;code&gt;visitUnknown&lt;/code&gt; &lt;/a&gt;方法。还将引入一个新的抽象元素类型的访问者类，以对应于新的语言级别。对于有问题的访问方法，此访问者将具有不同的默认行为。当引入新访客时，可能会不赞成使用此访客的全部或部分。</target>
        </trans-unit>
        <trans-unit id="6211be69d40865a23b57629a99ebded376b30392" translate="yes" xml:space="preserve">
          <source>When such a new visit method is added, the default implementation in this class will be to call the &lt;a href=&quot;abstractelementvisitor6#visitUnknown(javax.lang.model.element.Element,P)&quot;&gt;&lt;code&gt;visitUnknown&lt;/code&gt;&lt;/a&gt; method. A new abstract element visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question. When the new visitor is introduced, all or portions of this visitor may be deprecated.</source>
          <target state="translated">当添加了这样一个新的visit方法时，此类中的默认实现将是调用&lt;a href=&quot;abstractelementvisitor6#visitUnknown(javax.lang.model.element.Element,P)&quot;&gt; &lt;code&gt;visitUnknown&lt;/code&gt; &lt;/a&gt;方法。还将引入一个新的抽象元素访问者类，以对应于新的语言级别。对于有问题的访问方法，此访问者将具有不同的默认行为。当引入新访客时，可能会不赞成使用此访客的全部或部分。</target>
        </trans-unit>
        <trans-unit id="6c6e97c8e268ce1819909e688b39f6199c9409ae" translate="yes" xml:space="preserve">
          <source>When such a new visit method is added, the default implementation in this class will be to call the &lt;a href=&quot;abstractelementvisitor6#visitUnknown(javax.lang.model.element.Element,P)&quot;&gt;&lt;code&gt;visitUnknown&lt;/code&gt;&lt;/a&gt; method. A new element scanner visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question. When the new visitor is introduced, all or portions of this visitor may be deprecated.</source>
          <target state="translated">当添加了这样一个新的visit方法时，此类中的默认实现将是调用&lt;a href=&quot;abstractelementvisitor6#visitUnknown(javax.lang.model.element.Element,P)&quot;&gt; &lt;code&gt;visitUnknown&lt;/code&gt; &lt;/a&gt;方法。还将引入一个新的元素扫描器访客类，以对应于新的语言级别；对于有问题的访问方法，此访问者将具有不同的默认行为。当引入新访客时，可能会不赞成使用此访客的全部或部分。</target>
        </trans-unit>
        <trans-unit id="86581670b2bf6977794da9d077dabee784e08b42" translate="yes" xml:space="preserve">
          <source>When such a new visit method is added, the default implementation in this class will be to call the &lt;a href=&quot;abstractelementvisitor6#visitUnknown(javax.lang.model.element.Element,P)&quot;&gt;&lt;code&gt;visitUnknown&lt;/code&gt;&lt;/a&gt; method. A new simple element visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question. When the new visitor is introduced, all or portions of this visitor may be deprecated.</source>
          <target state="translated">当添加了这样一个新的visit方法时，此类中的默认实现将是调用&lt;a href=&quot;abstractelementvisitor6#visitUnknown(javax.lang.model.element.Element,P)&quot;&gt; &lt;code&gt;visitUnknown&lt;/code&gt; &lt;/a&gt;方法。还将引入一个新的简单元素访问者类，以对应于新的语言级别；对于有问题的访问方法，此访问者将具有不同的默认行为。当引入新访客时，可能会不赞成使用此访客的全部或部分。</target>
        </trans-unit>
        <trans-unit id="044c236c1377724dc963f7b253a1633adebf4edd" translate="yes" xml:space="preserve">
          <source>When such a new visit method is added, the default implementation in this class will be to call the &lt;a href=&quot;abstractelementvisitor6#visitUnknown-javax.lang.model.element.Element-P-&quot;&gt;&lt;code&gt;visitUnknown&lt;/code&gt;&lt;/a&gt; method. A new abstract element kind visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question. When the new visitor is introduced, all or portions of this visitor may be deprecated.</source>
          <target state="translated">当添加了这样一个新的visit方法时，此类中的默认实现将是调用&lt;a href=&quot;abstractelementvisitor6#visitUnknown-javax.lang.model.element.Element-P-&quot;&gt; &lt;code&gt;visitUnknown&lt;/code&gt; &lt;/a&gt;方法。还将引入一个新的抽象元素类型的访问者类，以对应于新的语言级别；对于有问题的访问方法，此访问者将具有不同的默认行为。当引入新访客时，可能会不赞成使用此访客的全部或部分。</target>
        </trans-unit>
        <trans-unit id="710e79e570a5917821dfd7344c3f17284d9a4964" translate="yes" xml:space="preserve">
          <source>When such a new visit method is added, the default implementation in this class will be to call the &lt;a href=&quot;abstractelementvisitor6#visitUnknown-javax.lang.model.element.Element-P-&quot;&gt;&lt;code&gt;visitUnknown&lt;/code&gt;&lt;/a&gt; method. A new abstract element visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question. When the new visitor is introduced, all or portions of this visitor may be deprecated.</source>
          <target state="translated">当添加了这样一个新的visit方法时，此类中的默认实现将是调用&lt;a href=&quot;abstractelementvisitor6#visitUnknown-javax.lang.model.element.Element-P-&quot;&gt; &lt;code&gt;visitUnknown&lt;/code&gt; &lt;/a&gt;方法。还将引入一个新的抽象元素访问者类，以对应于新的语言级别。对于有问题的访问方法，此访问者将具有不同的默认行为。当引入新访客时，可能会不赞成使用此访客的全部或部分。</target>
        </trans-unit>
        <trans-unit id="bf2a73437432866576d26e93ec38ac98756a0ab7" translate="yes" xml:space="preserve">
          <source>When such a new visit method is added, the default implementation in this class will be to call the &lt;a href=&quot;abstractelementvisitor6#visitUnknown-javax.lang.model.element.Element-P-&quot;&gt;&lt;code&gt;visitUnknown&lt;/code&gt;&lt;/a&gt; method. A new element scanner visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question. When the new visitor is introduced, all or portions of this visitor may be deprecated.</source>
          <target state="translated">当添加了这样一个新的visit方法时，此类中的默认实现将是调用&lt;a href=&quot;abstractelementvisitor6#visitUnknown-javax.lang.model.element.Element-P-&quot;&gt; &lt;code&gt;visitUnknown&lt;/code&gt; &lt;/a&gt;方法。还将引入一个新的元素扫描器访客类，以对应于新的语言级别；对于有问题的访问方法，此访问者将具有不同的默认行为。当引入新访客时，可能会不赞成使用此访客的全部或部分。</target>
        </trans-unit>
        <trans-unit id="d632be78f99f513b8aa8e1b7f5cb5683a59ff22f" translate="yes" xml:space="preserve">
          <source>When such a new visit method is added, the default implementation in this class will be to call the &lt;a href=&quot;abstractelementvisitor6#visitUnknown-javax.lang.model.element.Element-P-&quot;&gt;&lt;code&gt;visitUnknown&lt;/code&gt;&lt;/a&gt; method. A new simple element visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question. When the new visitor is introduced, all or portions of this visitor may be deprecated.</source>
          <target state="translated">当添加了这样一个新的visit方法时，此类中的默认实现将是调用&lt;a href=&quot;abstractelementvisitor6#visitUnknown-javax.lang.model.element.Element-P-&quot;&gt; &lt;code&gt;visitUnknown&lt;/code&gt; &lt;/a&gt;方法。还将引入一个新的简单元素访问者类，以适应新的语言水平；对于有问题的访问方法，此访问者将具有不同的默认行为。当引入新访客时，可能会不赞成使用此访客的全部或部分。</target>
        </trans-unit>
        <trans-unit id="425c228d797e1d155d3a9aacad4b65a7e3cd8fc7" translate="yes" xml:space="preserve">
          <source>When such a new visit method is added, the default implementation in this class will be to call the &lt;a href=&quot;abstracttypevisitor6#visitUnknown(javax.lang.model.type.TypeMirror,P)&quot;&gt;&lt;code&gt;visitUnknown&lt;/code&gt;&lt;/a&gt; method. A new abstract type visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question. When the new visitor is introduced, all or portions of this visitor may be deprecated.</source>
          <target state="translated">当添加了这样一个新的visit方法时，此类中的默认实现将是调用&lt;a href=&quot;abstracttypevisitor6#visitUnknown(javax.lang.model.type.TypeMirror,P)&quot;&gt; &lt;code&gt;visitUnknown&lt;/code&gt; &lt;/a&gt;方法。还将引入一个新的抽象类型的访问者类，以对应于新的语言级别。对于有问题的访问方法，此访问者将具有不同的默认行为。当引入新访客时，可能会不赞成使用此访客的全部或部分。</target>
        </trans-unit>
        <trans-unit id="ca02dde6bf89fc22036125452b0233a9a4bb4fe0" translate="yes" xml:space="preserve">
          <source>When such a new visit method is added, the default implementation in this class will be to call the &lt;a href=&quot;abstracttypevisitor6#visitUnknown(javax.lang.model.type.TypeMirror,P)&quot;&gt;&lt;code&gt;visitUnknown&lt;/code&gt;&lt;/a&gt; method. A new simple type visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question. When the new visitor is introduced, all or portions of this visitor may be deprecated.</source>
          <target state="translated">当添加了这样一个新的visit方法时，此类中的默认实现将是调用&lt;a href=&quot;abstracttypevisitor6#visitUnknown(javax.lang.model.type.TypeMirror,P)&quot;&gt; &lt;code&gt;visitUnknown&lt;/code&gt; &lt;/a&gt;方法。还将引入一个新的简单类型的访问者类，以对应于新的语言级别；对于有问题的访问方法，此访问者将具有不同的默认行为。当引入新访客时，可能会不赞成使用此访客的全部或部分。</target>
        </trans-unit>
        <trans-unit id="06a03ed21f6890e3698866751eba23ff67280af0" translate="yes" xml:space="preserve">
          <source>When such a new visit method is added, the default implementation in this class will be to call the &lt;a href=&quot;abstracttypevisitor6#visitUnknown(javax.lang.model.type.TypeMirror,P)&quot;&gt;&lt;code&gt;visitUnknown&lt;/code&gt;&lt;/a&gt; method. A new type kind visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question. When the new visitor is introduced, all or portions of this visitor may be deprecated.</source>
          <target state="translated">当添加了这样一个新的visit方法时，此类中的默认实现将是调用&lt;a href=&quot;abstracttypevisitor6#visitUnknown(javax.lang.model.type.TypeMirror,P)&quot;&gt; &lt;code&gt;visitUnknown&lt;/code&gt; &lt;/a&gt;方法。还将引入一种新型的访客类，以适应新的语言水平；对于有问题的访问方法，此访问者将具有不同的默认行为。当引入新访客时，可能会不赞成使用此访客的全部或部分。</target>
        </trans-unit>
        <trans-unit id="31a71bf88455082c4bc48a8526d303b8ca6d7ee4" translate="yes" xml:space="preserve">
          <source>When such a new visit method is added, the default implementation in this class will be to call the &lt;a href=&quot;abstracttypevisitor6#visitUnknown-javax.lang.model.type.TypeMirror-P-&quot;&gt;&lt;code&gt;visitUnknown&lt;/code&gt;&lt;/a&gt; method. A new abstract type visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question. When the new visitor is introduced, all or portions of this visitor may be deprecated.</source>
          <target state="translated">当添加了这样一个新的visit方法时，此类中的默认实现将是调用&lt;a href=&quot;abstracttypevisitor6#visitUnknown-javax.lang.model.type.TypeMirror-P-&quot;&gt; &lt;code&gt;visitUnknown&lt;/code&gt; &lt;/a&gt;方法。还将引入一个新的抽象类型的访问者类，以对应于新的语言级别。对于有问题的访问方法，此访问者将具有不同的默认行为。当引入新访客时，可能会不赞成使用此访客的全部或部分。</target>
        </trans-unit>
        <trans-unit id="b0bd9887b4dede673a8a857fd6f562d2e6651e7c" translate="yes" xml:space="preserve">
          <source>When such a new visit method is added, the default implementation in this class will be to call the &lt;a href=&quot;abstracttypevisitor6#visitUnknown-javax.lang.model.type.TypeMirror-P-&quot;&gt;&lt;code&gt;visitUnknown&lt;/code&gt;&lt;/a&gt; method. A new simple type visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question. When the new visitor is introduced, all or portions of this visitor may be deprecated.</source>
          <target state="translated">当添加了这样一个新的visit方法时，此类中的默认实现将是调用&lt;a href=&quot;abstracttypevisitor6#visitUnknown-javax.lang.model.type.TypeMirror-P-&quot;&gt; &lt;code&gt;visitUnknown&lt;/code&gt; &lt;/a&gt;方法。还将引入一个新的简单类型的访问者类，以对应于新的语言级别；对于有问题的访问方法，此访问者将具有不同的默认行为。当引入新访客时，可能会不赞成使用此访客的全部或部分。</target>
        </trans-unit>
        <trans-unit id="c5e7913304df13157eca5adf23774332e392edc0" translate="yes" xml:space="preserve">
          <source>When such a new visit method is added, the default implementation in this class will be to call the &lt;a href=&quot;abstracttypevisitor6#visitUnknown-javax.lang.model.type.TypeMirror-P-&quot;&gt;&lt;code&gt;visitUnknown&lt;/code&gt;&lt;/a&gt; method. A new type kind visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question. When the new visitor is introduced, all or portions of this visitor may be deprecated.</source>
          <target state="translated">当添加了这样一个新的visit方法时，此类中的默认实现将是调用&lt;a href=&quot;abstracttypevisitor6#visitUnknown-javax.lang.model.type.TypeMirror-P-&quot;&gt; &lt;code&gt;visitUnknown&lt;/code&gt; &lt;/a&gt;方法。还将引入一种新型的访客类，以适应新的语言水平；对于有问题的访问方法，此访问者将具有不同的默认行为。引入新访客后，可能会不赞成使用此访客的全部或部分。</target>
        </trans-unit>
        <trans-unit id="38469fe20bc4e9d1029889724c85678da2e32e2a" translate="yes" xml:space="preserve">
          <source>When such a new visit method is added, the default implementation in this class will be to directly or indirectly call the &lt;a href=&quot;#visitUnknown(javax.lang.model.element.AnnotationValue,P)&quot;&gt;&lt;code&gt;visitUnknown&lt;/code&gt;&lt;/a&gt; method. A new abstract annotation value visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question. When a new visitor is introduced, portions of this visitor class may be deprecated, including its constructors.</source>
          <target state="translated">添加此类新的visit方法后，此类中的默认实现将是直接或间接调用&lt;a href=&quot;#visitUnknown(javax.lang.model.element.AnnotationValue,P)&quot;&gt; &lt;code&gt;visitUnknown&lt;/code&gt; &lt;/a&gt;方法。还将引入一个新的抽象注释值访问者类，以对应于新的语言级别。对于有问题的访问方法，此访问者将具有不同的默认行为。当引入新的访问者时，可能会不赞成使用此访问者类的某些部分，包括其构造函数。</target>
        </trans-unit>
        <trans-unit id="c39d5a543c6e0acd6f0d74dc5aae219e75371e8b" translate="yes" xml:space="preserve">
          <source>When such a new visit method is added, the default implementation in this class will be to directly or indirectly call the &lt;a href=&quot;#visitUnknown(javax.lang.model.element.Element,P)&quot;&gt;&lt;code&gt;visitUnknown&lt;/code&gt;&lt;/a&gt; method. A new abstract element visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question. When a new visitor is introduced, portions of this visitor class may be deprecated, including its constructors.</source>
          <target state="translated">添加此类新的visit方法后，此类中的默认实现将是直接或间接调用&lt;a href=&quot;#visitUnknown(javax.lang.model.element.Element,P)&quot;&gt; &lt;code&gt;visitUnknown&lt;/code&gt; &lt;/a&gt;方法。还将引入一个新的抽象元素访问者类，以对应于新的语言级别。对于有问题的访问方法，此访问者将具有不同的默认行为。当引入新的访问者时，可能会不赞成使用此访问者类的某些部分，包括其构造函数。</target>
        </trans-unit>
        <trans-unit id="476153c757f00667de98633999b28f08798d719e" translate="yes" xml:space="preserve">
          <source>When such a new visit method is added, the default implementation in this class will be to directly or indirectly call the &lt;a href=&quot;#visitUnknown(javax.lang.model.type.TypeMirror,P)&quot;&gt;&lt;code&gt;visitUnknown&lt;/code&gt;&lt;/a&gt; method. A new abstract type visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question. When a new visitor is introduced, portions of this visitor class may be deprecated, including its constructors.</source>
          <target state="translated">添加此类新的visit方法后，此类中的默认实现将是直接或间接调用&lt;a href=&quot;#visitUnknown(javax.lang.model.type.TypeMirror,P)&quot;&gt; &lt;code&gt;visitUnknown&lt;/code&gt; &lt;/a&gt;方法。还将引入一个新的抽象类型的访问者类，以对应于新的语言级别。对于有问题的访问方法，此访问者将具有不同的默认行为。当引入新的访问者时，可能会不赞成使用此访问者类的某些部分，包括其构造函数。</target>
        </trans-unit>
        <trans-unit id="29383727360a6849aedf41675deb7286fbdbe298" translate="yes" xml:space="preserve">
          <source>When such a new visit method is added, the default implementation in this class will be to directly or indirectly call the &lt;a href=&quot;abstractannotationvaluevisitor6#visitUnknown(javax.lang.model.element.AnnotationValue,P)&quot;&gt;&lt;code&gt;visitUnknown&lt;/code&gt;&lt;/a&gt; method. A new simple annotation value visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question. When a new visitor is introduced, portions of this visitor class may be deprecated, including its constructors.</source>
          <target state="translated">添加此类新的visit方法后，此类中的默认实现将是直接或间接调用&lt;a href=&quot;abstractannotationvaluevisitor6#visitUnknown(javax.lang.model.element.AnnotationValue,P)&quot;&gt; &lt;code&gt;visitUnknown&lt;/code&gt; &lt;/a&gt;方法。还将引入一个新的简单注释值访问者类，以对应于新的语言级别。对于有问题的访问方法，此访问者将具有不同的默认行为。当引入新的访问者时，可能会不赞成使用此访问者类的某些部分，包括其构造函数。</target>
        </trans-unit>
        <trans-unit id="8c34c99c81a259843368afc68e40fda6e68328bb" translate="yes" xml:space="preserve">
          <source>When such a new visit method is added, the default implementation in this class will be to directly or indirectly call the &lt;a href=&quot;abstractelementvisitor6#visitUnknown(javax.lang.model.element.Element,P)&quot;&gt;&lt;code&gt;visitUnknown&lt;/code&gt;&lt;/a&gt; method. A new abstract element kind visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question. When a new visitor is introduced, portions of this visitor class may be deprecated, including its constructors.</source>
          <target state="translated">添加此类新的visit方法后，此类中的默认实现将是直接或间接调用&lt;a href=&quot;abstractelementvisitor6#visitUnknown(javax.lang.model.element.Element,P)&quot;&gt; &lt;code&gt;visitUnknown&lt;/code&gt; &lt;/a&gt;方法。还将引入一个新的抽象元素类型的访问者类，以对应于新的语言级别。对于有问题的访问方法，此访问者将具有不同的默认行为。当引入新的访问者时，可能会不赞成使用此访问者类的某些部分，包括其构造函数。</target>
        </trans-unit>
        <trans-unit id="bbe8c34b910b4b626addcd7a24df0849f71e163d" translate="yes" xml:space="preserve">
          <source>When such a new visit method is added, the default implementation in this class will be to directly or indirectly call the &lt;a href=&quot;abstractelementvisitor6#visitUnknown(javax.lang.model.element.Element,P)&quot;&gt;&lt;code&gt;visitUnknown&lt;/code&gt;&lt;/a&gt; method. A new element scanner visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question. When a new visitor is introduced, portions of this visitor class may be deprecated, including its constructors.</source>
          <target state="translated">添加此类新的visit方法后，此类中的默认实现将是直接或间接调用&lt;a href=&quot;abstractelementvisitor6#visitUnknown(javax.lang.model.element.Element,P)&quot;&gt; &lt;code&gt;visitUnknown&lt;/code&gt; &lt;/a&gt;方法。还将引入一个新的元素扫描器访客类，以对应于新的语言级别；对于有问题的访问方法，此访问者将具有不同的默认行为。当引入新的访问者时，可能会不赞成使用此访问者类的某些部分，包括其构造函数。</target>
        </trans-unit>
        <trans-unit id="c8e990163a52ce2479b286e22e932209c387e7bf" translate="yes" xml:space="preserve">
          <source>When such a new visit method is added, the default implementation in this class will be to directly or indirectly call the &lt;a href=&quot;abstractelementvisitor6#visitUnknown(javax.lang.model.element.Element,P)&quot;&gt;&lt;code&gt;visitUnknown&lt;/code&gt;&lt;/a&gt; method. A new simple element visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question. When a new visitor is introduced, portions of this visitor class may be deprecated, including its constructors.</source>
          <target state="translated">添加此类新的visit方法后，此类中的默认实现将是直接或间接调用&lt;a href=&quot;abstractelementvisitor6#visitUnknown(javax.lang.model.element.Element,P)&quot;&gt; &lt;code&gt;visitUnknown&lt;/code&gt; &lt;/a&gt;方法。还将引入一个新的简单元素访问者类，以对应于新的语言级别；对于有问题的访问方法，此访问者将具有不同的默认行为。当引入新的访问者时，可能会不赞成使用此访问者类的某些部分，包括其构造函数。</target>
        </trans-unit>
        <trans-unit id="d9aeb498e8df1efa9575905f07475db10e0ddc77" translate="yes" xml:space="preserve">
          <source>When such a new visit method is added, the default implementation in this class will be to directly or indirectly call the &lt;a href=&quot;abstracttypevisitor6#visitUnknown(javax.lang.model.type.TypeMirror,P)&quot;&gt;&lt;code&gt;visitUnknown&lt;/code&gt;&lt;/a&gt; method. A new simple type visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question. When a new visitor is introduced, portions of this visitor class may be deprecated, including its constructors.</source>
          <target state="translated">添加此类新的visit方法后，此类中的默认实现将是直接或间接调用&lt;a href=&quot;abstracttypevisitor6#visitUnknown(javax.lang.model.type.TypeMirror,P)&quot;&gt; &lt;code&gt;visitUnknown&lt;/code&gt; &lt;/a&gt;方法。还将引入一个新的简单类型的访问者类，以对应于新的语言级别；对于有问题的访问方法，此访问者将具有不同的默认行为。当引入新的访问者时，可能会不赞成使用此访问者类的某些部分，包括其构造函数。</target>
        </trans-unit>
        <trans-unit id="d5c1896c09a17da8abbadc461792ff89b596952b" translate="yes" xml:space="preserve">
          <source>When such a new visit method is added, the default implementation in this class will be to directly or indirectly call the &lt;a href=&quot;abstracttypevisitor6#visitUnknown(javax.lang.model.type.TypeMirror,P)&quot;&gt;&lt;code&gt;visitUnknown&lt;/code&gt;&lt;/a&gt; method. A new type kind visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question. When a new visitor is introduced, portions of this visitor class may be deprecated, including its constructors.</source>
          <target state="translated">添加此类新的visit方法后，此类中的默认实现将是直接或间接调用&lt;a href=&quot;abstracttypevisitor6#visitUnknown(javax.lang.model.type.TypeMirror,P)&quot;&gt; &lt;code&gt;visitUnknown&lt;/code&gt; &lt;/a&gt;方法。还将引入一种新型的访客类，以适应新的语言水平；对于有问题的访问方法，此访问者将具有不同的默认行为。当引入新的访问者时，可能会不赞成使用此访问者类的某些部分，包括其构造函数。</target>
        </trans-unit>
        <trans-unit id="7169edd82e18117207c8b43effbe612c3734164e" translate="yes" xml:space="preserve">
          <source>When symbolic links are supported, then whether the resulting path, when resolved against this path, yields a path that can be used to locate the &lt;a href=&quot;files#isSameFile(java.nio.file.Path,java.nio.file.Path)&quot;&gt;&lt;code&gt;same&lt;/code&gt;&lt;/a&gt; file as &lt;code&gt;other&lt;/code&gt; is implementation dependent. For example, if this path is &lt;code&gt;&quot;/a/b&quot;&lt;/code&gt; and the given path is &lt;code&gt;&quot;/a/x&quot;&lt;/code&gt; then the resulting relative path may be &lt;code&gt;
 &quot;../x&quot;&lt;/code&gt;. If &lt;code&gt;&quot;b&quot;&lt;/code&gt; is a symbolic link then is implementation dependent if &lt;code&gt;&quot;a/b/../x&quot;&lt;/code&gt; would locate the same file as &lt;code&gt;&quot;/a/x&quot;&lt;/code&gt;.</source>
          <target state="translated">如果支持符号链接，则针对该路径解析后得到的路径是否产生可用于与 &lt;code&gt;other&lt;/code&gt; 文件定位&lt;a href=&quot;files#isSameFile(java.nio.file.Path,java.nio.file.Path)&quot;&gt; &lt;code&gt;same&lt;/code&gt; &lt;/a&gt;文件的路径，具体取决于实现。例如，如果此路径为 &lt;code&gt;&quot;/a/b&quot;&lt;/code&gt; 且给定路径为 &lt;code&gt;&quot;/a/x&quot;&lt;/code&gt; 则所得的相对路径可以为 &lt;code&gt; &quot;../x&quot;&lt;/code&gt; 。如果 &lt;code&gt;&quot;b&quot;&lt;/code&gt; 是符号链接，则如果 &lt;code&gt;&quot;a/b/../x&quot;&lt;/code&gt; 将定位与 &lt;code&gt;&quot;/a/x&quot;&lt;/code&gt; 相同的文件，则依赖于实现。</target>
        </trans-unit>
        <trans-unit id="21130ee63b47bcee22d5206a3b440986ec034278" translate="yes" xml:space="preserve">
          <source>When symbolic links are supported, then whether the resulting path, when resolved against this path, yields a path that can be used to locate the &lt;a href=&quot;files#isSameFile-java.nio.file.Path-java.nio.file.Path-&quot;&gt;&lt;code&gt;same&lt;/code&gt;&lt;/a&gt; file as &lt;code&gt;other&lt;/code&gt; is implementation dependent. For example, if this path is &lt;code&gt;&quot;/a/b&quot;&lt;/code&gt; and the given path is &lt;code&gt;&quot;/a/x&quot;&lt;/code&gt; then the resulting relative path may be &lt;code&gt;&quot;../x&quot;&lt;/code&gt;. If &lt;code&gt;&quot;b&quot;&lt;/code&gt; is a symbolic link then is implementation dependent if &lt;code&gt;&quot;a/b/../x&quot;&lt;/code&gt; would locate the same file as &lt;code&gt;&quot;/a/x&quot;&lt;/code&gt;.</source>
          <target state="translated">如果支持符号链接，则针对该路径解析时，生成的路径是否生成可用于查找&lt;a href=&quot;files#isSameFile-java.nio.file.Path-java.nio.file.Path-&quot;&gt; &lt;code&gt;same&lt;/code&gt; &lt;/a&gt; &lt;code&gt;other&lt;/code&gt; 文件相同的文件的路径，具体取决于实现。例如，如果此路径为 &lt;code&gt;&quot;/a/b&quot;&lt;/code&gt; 并且给定路径为 &lt;code&gt;&quot;/a/x&quot;&lt;/code&gt; 则所得的相对路径可以为 &lt;code&gt;&quot;../x&quot;&lt;/code&gt; 。如果 &lt;code&gt;&quot;b&quot;&lt;/code&gt; 是符号链接，则如果 &lt;code&gt;&quot;a/b/../x&quot;&lt;/code&gt; 将定位与 &lt;code&gt;&quot;/a/x&quot;&lt;/code&gt; 相同的文件，则依赖于实现。</target>
        </trans-unit>
        <trans-unit id="9201aa7cc9fa88f4813925552674c147d8b25ef5" translate="yes" xml:space="preserve">
          <source>When testing the user-information, path, query, fragment, authority, or scheme-specific parts of two URIs for equality, the raw forms rather than the encoded forms of these components are compared and the hexadecimal digits of escaped octets are compared without regard to case.</source>
          <target state="translated">当测试两个URI的用户信息、路径、查询、片段、权限或特定方案部分是否相同时,比较的是这些组件的原始形式而不是编码形式,并且比较转义八位数的十六进制数字,而不考虑大小写。</target>
        </trans-unit>
        <trans-unit id="2cb5a2d45e0a1e497d3635ca731bd3fec76abfbe" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;#enter()&quot;&gt;&lt;code&gt;enter()&lt;/code&gt;&lt;/a&gt; method is called, the current thread is blocked until the loop is terminated by the &lt;a href=&quot;#exit()&quot;&gt;&lt;code&gt;exit()&lt;/code&gt;&lt;/a&gt; method. Also, a new event loop is started on the event dispatch thread, which may or may not be the current thread. The loop can be terminated on any thread by calling its &lt;a href=&quot;#exit()&quot;&gt;&lt;code&gt;exit()&lt;/code&gt;&lt;/a&gt; method. After the loop is terminated, the &lt;code&gt;SecondaryLoop&lt;/code&gt; object can be reused to run a new nested event loop.</source>
          <target state="translated">当&lt;a href=&quot;#enter()&quot;&gt; &lt;code&gt;enter()&lt;/code&gt; &lt;/a&gt;方法被调用时，当前线程被阻塞，直到环路是由封端的&lt;a href=&quot;#exit()&quot;&gt; &lt;code&gt;exit()&lt;/code&gt; &lt;/a&gt;方法。此外，新的事件循环将在事件分发线程上启动，该线程可能是当前线程，也可能不是当前线程。通过调用其&lt;a href=&quot;#exit()&quot;&gt; &lt;code&gt;exit()&lt;/code&gt; &lt;/a&gt;方法，可以在任何线程上终止该循环。循环终止后，可以重复使用 &lt;code&gt;SecondaryLoop&lt;/code&gt; 对象以运行新的嵌套事件循环。</target>
        </trans-unit>
        <trans-unit id="59f0744a6b287db23096a83cb187666b95b7fc4d" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;../../../java.base/java/net/standardsocketoptions#SO_KEEPALIVE&quot;&gt;&lt;code&gt;SO_KEEPALIVE&lt;/code&gt;&lt;/a&gt; option is enabled, TCP probes a connection that has been idle for some amount of time. If the remote system does not respond to a keep-alive probe, TCP retransmits the probe a certain number of times before a connection is considered to be broken. The default value for this keep-alive probe retransmit limit is system dependent, but is typically 8. The &lt;code&gt;TCP_KEEPCOUNT&lt;/code&gt; option can be used to affect this value for a given socket.</source>
          <target state="translated">当&lt;a href=&quot;../../../java.base/java/net/standardsocketoptions#SO_KEEPALIVE&quot;&gt; &lt;code&gt;SO_KEEPALIVE&lt;/code&gt; &lt;/a&gt;选项时，TCP探针已经空闲了一定时间的连接。如果远程系统没有响应&amp;ldquo;保持活动&amp;rdquo;探测，则在认为连接断开之前，TCP会重新传输探测一定次数。此保持活动状态探针重传限制的默认值取决于系统，但通常为 &lt;code&gt;TCP_KEEPCOUNT&lt;/code&gt; 选项可用于影响给定套接字的此值。</target>
        </trans-unit>
        <trans-unit id="9a0c228e997d3d3e4db09196df54969099e8b4f9" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;../../../java.base/java/net/standardsocketoptions#SO_KEEPALIVE&quot;&gt;&lt;code&gt;SO_KEEPALIVE&lt;/code&gt;&lt;/a&gt; option is enabled, TCP probes a connection that has been idle for some amount of time. If the remote system does not respond to a keep-alive probe, TCP retransmits the probe after some amount of time. The default value for this retransmission interval is system dependent, but is typically 75 seconds. The &lt;code&gt;TCP_KEEPINTERVAL&lt;/code&gt; option can be used to affect this value for a given socket.</source>
          <target state="translated">当&lt;a href=&quot;../../../java.base/java/net/standardsocketoptions#SO_KEEPALIVE&quot;&gt; &lt;code&gt;SO_KEEPALIVE&lt;/code&gt; &lt;/a&gt;选项时，TCP探针已经空闲了一定时间的连接。如果远程系统不响应保持活动的探测，则TCP将在一段时间后重新传输该探测。此重传间隔的默认值取决于系统，但通常为75秒。该 &lt;code&gt;TCP_KEEPINTERVAL&lt;/code&gt; 选项可用于影响给定套接字的该值。</target>
        </trans-unit>
        <trans-unit id="dc3cf674897013f49a0a716d0c54d91cef247e3f" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;../../../java.base/java/net/standardsocketoptions#SO_KEEPALIVE&quot;&gt;&lt;code&gt;SO_KEEPALIVE&lt;/code&gt;&lt;/a&gt; option is enabled, TCP probes a connection that has been idle for some amount of time. The default value for this idle period is system dependent, but is typically 2 hours. The &lt;code&gt;TCP_KEEPIDLE&lt;/code&gt; option can be used to affect this value for a given socket.</source>
          <target state="translated">当&lt;a href=&quot;../../../java.base/java/net/standardsocketoptions#SO_KEEPALIVE&quot;&gt; &lt;code&gt;SO_KEEPALIVE&lt;/code&gt; &lt;/a&gt;选项时，TCP探针已经空闲了一定时间的连接。此空闲时间的默认值取决于系统，但通常为2小时。该 &lt;code&gt;TCP_KEEPIDLE&lt;/code&gt; 选项可用于影响给定套接字的该值。</target>
        </trans-unit>
        <trans-unit id="93c5bf1f5d3d11b7b3d1d812715baf3c9fe0fecb" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;../../../org/w3c/dom/ls/lsresourceresolver&quot;&gt;&lt;code&gt;LSResourceResolver&lt;/code&gt;&lt;/a&gt; is null, the implementation will behave as if the following &lt;a href=&quot;../../../org/w3c/dom/ls/lsresourceresolver&quot;&gt;&lt;code&gt;LSResourceResolver&lt;/code&gt;&lt;/a&gt; is set:</source>
          <target state="translated">当&lt;a href=&quot;../../../org/w3c/dom/ls/lsresourceresolver&quot;&gt; &lt;code&gt;LSResourceResolver&lt;/code&gt; &lt;/a&gt;为null时，实现的行为就像设置了以下&lt;a href=&quot;../../../org/w3c/dom/ls/lsresourceresolver&quot;&gt; &lt;code&gt;LSResourceResolver&lt;/code&gt; 一样&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="9c71a117a0d78807772c45691dff3b7188404bd9" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;../../../org/xml/sax/errorhandler&quot;&gt;&lt;code&gt;ErrorHandler&lt;/code&gt;&lt;/a&gt; is null, the implementation will behave as if the following &lt;a href=&quot;../../../org/xml/sax/errorhandler&quot;&gt;&lt;code&gt;ErrorHandler&lt;/code&gt;&lt;/a&gt; is set:</source>
          <target state="translated">当&lt;a href=&quot;../../../org/xml/sax/errorhandler&quot;&gt; &lt;code&gt;ErrorHandler&lt;/code&gt; &lt;/a&gt;为null时，实现的行为就像设置了以下&lt;a href=&quot;../../../org/xml/sax/errorhandler&quot;&gt; &lt;code&gt;ErrorHandler&lt;/code&gt; 一样&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="349843d9371dc6f3aced62d1709febefa1cdc8d8" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;objectinputfilter#checkInput(java.io.ObjectInputFilter.FilterInfo)&quot;&gt;&lt;code&gt;checkInput&lt;/code&gt;&lt;/a&gt; method is invoked it is given access to the current class, the array length, the current number of references already read from the stream, the depth of nested calls to &lt;a href=&quot;#readObject()&quot;&gt;&lt;code&gt;readObject&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#readUnshared()&quot;&gt;&lt;code&gt;readUnshared&lt;/code&gt;&lt;/a&gt;, and the implementation dependent number of bytes consumed from the input stream.</source>
          <target state="translated">调用&lt;a href=&quot;objectinputfilter#checkInput(java.io.ObjectInputFilter.FilterInfo)&quot;&gt; &lt;code&gt;checkInput&lt;/code&gt; &lt;/a&gt;方法时，它可以访问当前类，数组长度，已从流中读取的当前引用数，对&lt;a href=&quot;#readObject()&quot;&gt; &lt;code&gt;readObject&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#readUnshared()&quot;&gt; &lt;code&gt;readUnshared&lt;/code&gt; &lt;/a&gt;的嵌套调用的深度以及从该类消耗的实现相关的字节数。输入流。</target>
        </trans-unit>
        <trans-unit id="ab0a44a62ffe84a96b19e3bf378964ba73e0fcca" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;CachedRowSet&lt;/code&gt; method &lt;code&gt;acceptChanges&lt;/code&gt; is called, it delegates to the &lt;code&gt;RowSet&lt;/code&gt; object's &lt;code&gt;SyncProvider&lt;/code&gt; object. How the writer provided by that &lt;code&gt;SyncProvider&lt;/code&gt; object is implemented determines what level (grade) of checking for conflicts will be done. After all checking for conflicts is completed and one or more conflicts has been found, the method &lt;code&gt;acceptChanges&lt;/code&gt; throws a &lt;code&gt;SyncProviderException&lt;/code&gt; object. The application can catch the exception and use it to obtain a &lt;code&gt;SyncResolver&lt;/code&gt; object.</source>
          <target state="translated">当 &lt;code&gt;CachedRowSet&lt;/code&gt; 的方法 &lt;code&gt;acceptChanges&lt;/code&gt; 被调用时，将其委托给 &lt;code&gt;RowSet&lt;/code&gt; 对象 &lt;code&gt;SyncProvider&lt;/code&gt; 对象。由 &lt;code&gt;SyncProvider&lt;/code&gt; 对象提供的编写器的实现方式决定了将执行哪个级别（等级）的冲突检查。在完成所有冲突检查并找到一个或多个冲突之后，方法 &lt;code&gt;acceptChanges&lt;/code&gt; 引发 &lt;code&gt;SyncProviderException&lt;/code&gt; 对象。应用程序可以捕获异常，并使用它来获取 &lt;code&gt;SyncResolver&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="72afefcfd2d2b20f95a8bc304631fb4c64f7b278" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;HttpResponse&lt;/code&gt; object is returned, the body has been completely written to the byte array.</source>
          <target state="translated">当 &lt;code&gt;HttpResponse&lt;/code&gt; 被返回对象，身体已经完全写入到字节数组。</target>
        </trans-unit>
        <trans-unit id="0d9e780897f9f330f634a20683b4c50779ddf071" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;HttpResponse&lt;/code&gt; object is returned, the body has been completely written to the consumer.</source>
          <target state="translated">当 &lt;code&gt;HttpResponse&lt;/code&gt; 返回的对象，身体已经完全写入到消费者。</target>
        </trans-unit>
        <trans-unit id="ba9826c0dffb73820d59d4df3c02f81a55a41d8a" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;HttpResponse&lt;/code&gt; object is returned, the body has been completely written to the file and &lt;a href=&quot;httpresponse#body()&quot;&gt;&lt;code&gt;HttpResponse.body()&lt;/code&gt;&lt;/a&gt; returns a &lt;code&gt;Path&lt;/code&gt; object for the file. The returned &lt;code&gt;Path&lt;/code&gt; is the combination of the supplied directory name and the file name supplied by the server. If the destination directory does not exist or cannot be written to, then the response will fail with an &lt;a href=&quot;../../../../java.base/java/io/ioexception&quot;&gt;&lt;code&gt;IOException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">当 &lt;code&gt;HttpResponse&lt;/code&gt; 返回的对象，身体已经完全写入文件和&lt;a href=&quot;httpresponse#body()&quot;&gt; &lt;code&gt;HttpResponse.body()&lt;/code&gt; &lt;/a&gt;返回 &lt;code&gt;Path&lt;/code&gt; 的文件对象。返回的 &lt;code&gt;Path&lt;/code&gt; 是提供的目录名和服务器提供的文件名的组合。如果目标目录不存在或无法写入，则响应将失败，并出现&lt;a href=&quot;../../../../java.base/java/io/ioexception&quot;&gt; &lt;code&gt;IOException&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ae8fe4cf9af58eae2641375733a0acff7ecc038a" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;HttpResponse&lt;/code&gt; object is returned, the body has been completely written to the file, and &lt;a href=&quot;httpresponse#body()&quot;&gt;&lt;code&gt;HttpResponse.body()&lt;/code&gt;&lt;/a&gt; returns a reference to its &lt;a href=&quot;../../../../java.base/java/nio/file/path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">当 &lt;code&gt;HttpResponse&lt;/code&gt; 返回的对象，身体已经完全写入文件，并&lt;a href=&quot;httpresponse#body()&quot;&gt; &lt;code&gt;HttpResponse.body()&lt;/code&gt; &lt;/a&gt;返回到它的参考&lt;a href=&quot;../../../../java.base/java/nio/file/path&quot;&gt; &lt;code&gt;Path&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7f8b7f93bc4b770c2f3611214ea9f4ae4a8f5b0d" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;HttpResponse&lt;/code&gt; object is returned, the body has been completely written to the string.</source>
          <target state="translated">当 &lt;code&gt;HttpResponse&lt;/code&gt; 返回的对象，身体已完全写入字符串。</target>
        </trans-unit>
        <trans-unit id="d434402a35c684d119251a82bd168ecbc741dd91" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;HttpResponse&lt;/code&gt; object is returned, the body may not have been completely received.</source>
          <target state="translated">当 &lt;code&gt;HttpResponse&lt;/code&gt; 返回的对象，身体可能没有被完全接受。</target>
        </trans-unit>
        <trans-unit id="920362988fe9f44a3ddb764c3063325d40a93a51" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;HttpResponse&lt;/code&gt; object is returned, the response headers will have been completely read, but the body may not have been fully received yet. The &lt;a href=&quot;httpresponse#body()&quot;&gt;&lt;code&gt;HttpResponse.body()&lt;/code&gt;&lt;/a&gt; method returns a &lt;a href=&quot;../../../../java.base/java/util/concurrent/flow.publisher&quot;&gt;&lt;code&gt;Publisher&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;List&amp;lt;ByteBuffer&amp;gt;&amp;gt;&lt;/code&gt; from which the body response bytes can be obtained as they are received. The publisher can and must be subscribed to only once.</source>
          <target state="translated">当 &lt;code&gt;HttpResponse&lt;/code&gt; 返回对象，响应头将被完全读取，但身体可能还没有完全尚未收到。所述&lt;a href=&quot;httpresponse#body()&quot;&gt; &lt;code&gt;HttpResponse.body()&lt;/code&gt; &lt;/a&gt;方法返回一个&lt;a href=&quot;../../../../java.base/java/util/concurrent/flow.publisher&quot;&gt; &lt;code&gt;Publisher&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;List&amp;lt;ByteBuffer&amp;gt;&amp;gt;&lt;/code&gt; 从中体响应字节可以如它们被接收而获得。发布者只能而且只能订阅一次。</target>
        </trans-unit>
        <trans-unit id="3e5ca13755a6bfd06a017657997d9818861116f6" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;HttpResponse&lt;/code&gt; object is returned, the response headers will have been completely read, but the body may not have been fully received yet. The &lt;a href=&quot;httpresponse#body()&quot;&gt;&lt;code&gt;HttpResponse.body()&lt;/code&gt;&lt;/a&gt; method returns a &lt;a href=&quot;../../../../java.base/java/util/concurrent/flow.publisher&quot;&gt;&lt;code&gt;Publisher&lt;list&gt;&amp;gt;&lt;/list&gt;&lt;/code&gt;&lt;/a&gt; from which the body response bytes can be obtained as they are received. The publisher can and must be subscribed to only once.</source>
          <target state="translated">当 &lt;code&gt;HttpResponse&lt;/code&gt; 返回对象，响应头将被完全读取，但身体可能还没有完全尚未收到。所述&lt;a href=&quot;httpresponse#body()&quot;&gt; &lt;code&gt;HttpResponse.body()&lt;/code&gt; &lt;/a&gt;方法返回一个&lt;a href=&quot;../../../../java.base/java/util/concurrent/flow.publisher&quot;&gt; &lt;code&gt;Publisher&lt;list&gt;&amp;gt;&lt;/list&gt;&lt;/code&gt; &lt;/a&gt;从中可以获取接收到的正文响应字节。发布者只能而且只能订阅一次。</target>
        </trans-unit>
        <trans-unit id="9b1d642a866048552e189045dd9a35591fae905b" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;HttpResponse&lt;/code&gt; object is returned, the response headers will have been completely read, but the body may not have been fully received yet. The &lt;a href=&quot;httpresponse#body()&quot;&gt;&lt;code&gt;HttpResponse.body()&lt;/code&gt;&lt;/a&gt; method returns an &lt;a href=&quot;../../../../java.base/java/io/inputstream&quot;&gt;&lt;code&gt;InputStream&lt;/code&gt;&lt;/a&gt; from which the body can be read as it is received.</source>
          <target state="translated">当 &lt;code&gt;HttpResponse&lt;/code&gt; 返回对象，响应头将被完全读取，但身体可能还没有完全尚未收到。所述&lt;a href=&quot;httpresponse#body()&quot;&gt; &lt;code&gt;HttpResponse.body()&lt;/code&gt; &lt;/a&gt;方法返回&lt;a href=&quot;../../../../java.base/java/io/inputstream&quot;&gt; &lt;code&gt;InputStream&lt;/code&gt; &lt;/a&gt;从在其被接收的身体可被读取。</target>
        </trans-unit>
        <trans-unit id="1ee08c821ac6ffd8d690cbbc08d004846b4f65e3" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;Printable&lt;/code&gt; is obtained from a client-supplied &lt;code&gt;Pageable&lt;/code&gt; then the client may provide different PageFormats for each page index. Calculations of page breaks must account for this.</source>
          <target state="translated">当从客户端提供的 &lt;code&gt;Pageable&lt;/code&gt; 中获取 &lt;code&gt;Printable&lt;/code&gt; 时，客户端可以为每个页面索引提供不同的PageFormat。分页符的计算必须考虑到这一点。</target>
        </trans-unit>
        <trans-unit id="8da723286e46b5dcc04253d5d4b818f47a7e075f" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;RowSet&lt;/code&gt; object changes one of its rows, changes all of it rows, or moves its cursor, it also notifies each listener that is registered with it. The listener reacts by carrying out its implementation of the notification method called on it.</source>
          <target state="translated">当 &lt;code&gt;RowSet&lt;/code&gt; 对象更改其一行之一，更改其所有行或移动其光标时，它还将通知向其注册的每个侦听器。侦听器通过对其调用的通知方法执行其实现来做出反应。</target>
        </trans-unit>
        <trans-unit id="ee7ac132993577ecd59468c3647a9e567b53ac77" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;add&lt;/code&gt; method is called to add a Permission, the Permission is stored in the appropriate PermissionCollection. If no such collection exists yet, the Permission object's class is determined and the &lt;code&gt;newPermissionCollection&lt;/code&gt; method is called on that class to create the PermissionCollection and add it to the Permissions object. If &lt;code&gt;newPermissionCollection&lt;/code&gt; returns null, then a default PermissionCollection that uses a hashtable will be created and used. Each hashtable entry stores a Permission object as both the key and the value.</source>
          <target state="translated">当 &lt;code&gt;add&lt;/code&gt; 方法被调用来添加权限，权限被存储在适当的PermissionCollection。如果尚不存在这样的集合，则确定Permission对象的类，并在 &lt;code&gt;newPermissionCollection&lt;/code&gt; 上调用newPermissionCollection方法以创建PermissionCollection并将其添加到Permissions对象。如果 &lt;code&gt;newPermissionCollection&lt;/code&gt; 返回null，则将创建并使用使用哈希表的默认PermissionCollection。每个哈希表条目都将一个Permission对象存储为键和值。</target>
        </trans-unit>
        <trans-unit id="b88d575b7afc2c5eb726273e486f2105b12c75a9" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;cellRenderer&lt;/code&gt; or &lt;code&gt;cellEditor&lt;/code&gt; parameter is &lt;code&gt;null&lt;/code&gt;, a default value provided by the &lt;code&gt;JTable&lt;/code&gt;&lt;code&gt;getDefaultRenderer&lt;/code&gt; or &lt;code&gt;getDefaultEditor&lt;/code&gt; method, respectively, is used to provide defaults based on the type of the data in this column. This column-centric rendering strategy can be circumvented by overriding the &lt;code&gt;getCellRenderer&lt;/code&gt; methods in &lt;code&gt;JTable&lt;/code&gt;.</source>
          <target state="translated">当 &lt;code&gt;cellRenderer&lt;/code&gt; 或 &lt;code&gt;cellEditor&lt;/code&gt; 参数为 &lt;code&gt;null&lt;/code&gt; 时，将分别使用 &lt;code&gt;JTable&lt;/code&gt; 的 &lt;code&gt;getDefaultRenderer&lt;/code&gt; 或 &lt;code&gt;getDefaultEditor&lt;/code&gt; 方法提供的默认值，以根据此列中的数据类型提供默认值。可以通过重写 &lt;code&gt;JTable&lt;/code&gt; 中的 &lt;code&gt;getCellRenderer&lt;/code&gt; 方法来绕过这种以列为中心的呈现策略。</target>
        </trans-unit>
        <trans-unit id="7bda165d83525f9548659c3eec7e03d20271f7a7" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;getCallerClass&lt;/code&gt; method is called from a method that is the bottom most frame on the stack, for example, &lt;code&gt;static public void main&lt;/code&gt; method launched by the &lt;code&gt;java&lt;/code&gt; launcher, or a method invoked from a JNI attached thread, &lt;code&gt;IllegalCallerException&lt;/code&gt; is thrown.</source>
          <target state="translated">当从堆栈中最底层框架的方法（例如，由 &lt;code&gt;java&lt;/code&gt; 启动器启动的 &lt;code&gt;static public void main&lt;/code&gt; 方法或从JNI附加线程调用的方法）调用 &lt;code&gt;getCallerClass&lt;/code&gt; 方法时，将抛出 &lt;code&gt;IllegalCallerException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5d8cbad25caa72fa532ed2521b7fd96e96a6b5fa" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;invokevirtual&lt;/code&gt; is executed after linking, the receiving VarHandle's access mode type is first checked by the JVM to ensure that it matches the symbolic type descriptor. If the type match fails, it means that the access mode method which the caller is invoking is not present on the individual VarHandle being invoked.</source>
          <target state="translated">当 &lt;code&gt;invokevirtual&lt;/code&gt; 在链接之后，执行，接收VarHandle的接入模式类型首先检查由JVM，以确保它的符号类型描述符相匹配。如果类型匹配失败，则意味着调用者正在调用的访问方式方法不存在于被调用的各个VarHandle上。</target>
        </trans-unit>
        <trans-unit id="d4ff583386f934e25bcb252a53631116c45f985a" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;invokevirtual&lt;/code&gt; is executed after linking, the receiving method handle's type is first checked by the JVM to ensure that it matches the symbolic type descriptor. If the type match fails, it means that the method which the caller is invoking is not present on the individual method handle being invoked.</source>
          <target state="translated">当 &lt;code&gt;invokevirtual&lt;/code&gt; 是连接后执行时，该接收方法手柄的类型首先被JVM检查，以确保它的符号类型描述符相匹配。如果类型匹配失败，则表示正在调用的单个方法句柄上不存在调用方正在调用的方法。</target>
        </trans-unit>
        <trans-unit id="8226f6246b0d0b9cfb2a7ab0e96a44673f4a1c3a" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;keyIdentifier&lt;/code&gt; field of &lt;code&gt;AuthorityKeyIdentifier&lt;/code&gt; is populated, the value is usually taken from the &lt;code&gt;SubjectKeyIdentifier&lt;/code&gt; extension in the issuer's certificate. Note, however, that the result of &lt;code&gt;X509Certificate.getExtensionValue(&amp;lt;SubjectKeyIdentifier Object
 Identifier&amp;gt;)&lt;/code&gt; on the issuer's certificate may NOT be used directly as the input to &lt;code&gt;setAuthorityKeyIdentifier&lt;/code&gt;. This is because the SubjectKeyIdentifier contains only a KeyIdentifier OCTET STRING, and not a SEQUENCE of KeyIdentifier, GeneralNames, and CertificateSerialNumber. In order to use the extension value of the issuer certificate's &lt;code&gt;SubjectKeyIdentifier&lt;/code&gt; extension, it will be necessary to extract the value of the embedded &lt;code&gt;KeyIdentifier&lt;/code&gt; OCTET STRING, then DER encode this OCTET STRING inside a SEQUENCE. For more details on SubjectKeyIdentifier, see &lt;a href=&quot;#setSubjectKeyIdentifier(byte%5B%5D)&quot;&gt;&lt;code&gt;setSubjectKeyIdentifier(byte[] subjectKeyID)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">当填充 &lt;code&gt;AuthorityKeyIdentifier&lt;/code&gt; 的 &lt;code&gt;keyIdentifier&lt;/code&gt; 字段时，该值通常取自颁发者证书中的 &lt;code&gt;SubjectKeyIdentifier&lt;/code&gt; 扩展名。但是请注意，颁发者证书上的 &lt;code&gt;X509Certificate.getExtensionValue(&amp;lt;SubjectKeyIdentifier Object Identifier&amp;gt;)&lt;/code&gt; 的结果不得直接用作 &lt;code&gt;setAuthorityKeyIdentifier&lt;/code&gt; 的输入。这是因为SubjectKeyIdentifier仅包含KeyIdentifier OCTET STRING，而不包含KeyIdentifier，GeneralNames和CertificateSerialNumber的SEQUENCE。为了使用颁发者证书的 &lt;code&gt;SubjectKeyIdentifier&lt;/code&gt; 扩展名的扩展值，有必要提取嵌入的值。 &lt;code&gt;KeyIdentifier&lt;/code&gt; OCTET STRING，然后DER在SEQUENCE中对该OCTET STRING进行编码。有关SubjectKeyIdentifier的更多详细信息，请参见&lt;a href=&quot;#setSubjectKeyIdentifier(byte%5B%5D)&quot;&gt; &lt;code&gt;setSubjectKeyIdentifier(byte[] subjectKeyID)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="834601037ab0662f3396b5a79222cc36559945fd" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;keyIdentifier&lt;/code&gt; field of &lt;code&gt;AuthorityKeyIdentifier&lt;/code&gt; is populated, the value is usually taken from the &lt;code&gt;SubjectKeyIdentifier&lt;/code&gt; extension in the issuer's certificate. Note, however, that the result of &lt;code&gt;X509Certificate.getExtensionValue(&amp;lt;SubjectKeyIdentifier Object
 Identifier&amp;gt;)&lt;/code&gt; on the issuer's certificate may NOT be used directly as the input to &lt;code&gt;setAuthorityKeyIdentifier&lt;/code&gt;. This is because the SubjectKeyIdentifier contains only a KeyIdentifier OCTET STRING, and not a SEQUENCE of KeyIdentifier, GeneralNames, and CertificateSerialNumber. In order to use the extension value of the issuer certificate's &lt;code&gt;SubjectKeyIdentifier&lt;/code&gt; extension, it will be necessary to extract the value of the embedded &lt;code&gt;KeyIdentifier&lt;/code&gt; OCTET STRING, then DER encode this OCTET STRING inside a SEQUENCE. For more details on SubjectKeyIdentifier, see &lt;a href=&quot;x509certselector#setSubjectKeyIdentifier-byte:A-&quot;&gt;&lt;code&gt;setSubjectKeyIdentifier(byte[] subjectKeyID)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">当填充 &lt;code&gt;AuthorityKeyIdentifier&lt;/code&gt; 的 &lt;code&gt;keyIdentifier&lt;/code&gt; 字段时，该值通常取自颁发者证书中的 &lt;code&gt;SubjectKeyIdentifier&lt;/code&gt; 扩展名。但是请注意，颁发者证书上的 &lt;code&gt;X509Certificate.getExtensionValue(&amp;lt;SubjectKeyIdentifier Object Identifier&amp;gt;)&lt;/code&gt; 的结果不得直接用作 &lt;code&gt;setAuthorityKeyIdentifier&lt;/code&gt; 的输入。这是因为SubjectKeyIdentifier仅包含KeyIdentifier OCTET STRING，而不包含KeyIdentifier，GeneralNames和CertificateSerialNumber的SEQUENCE。为了使用颁发者证书的 &lt;code&gt;SubjectKeyIdentifier&lt;/code&gt; 扩展名的扩展值，有必要提取嵌入的值。 &lt;code&gt;KeyIdentifier&lt;/code&gt; OCTET STRING，然后DER在SEQUENCE中对该OCTET STRING进行编码。有关SubjectKeyIdentifier的更多详细信息，请参见&lt;a href=&quot;x509certselector#setSubjectKeyIdentifier-byte:A-&quot;&gt; &lt;code&gt;setSubjectKeyIdentifier(byte[] subjectKeyID)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a8d5a455eaa9bae77e2400ec125089de5958ee67" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;nextToken&lt;/code&gt; method encounters a string constant, the &lt;code&gt;ttype&lt;/code&gt; field is set to the string delimiter and the &lt;code&gt;sval&lt;/code&gt; field is set to the body of the string.</source>
          <target state="translated">当 &lt;code&gt;nextToken&lt;/code&gt; 方法遇到字符串常量时， &lt;code&gt;ttype&lt;/code&gt; 字段将设置为字符串定界符，而 &lt;code&gt;sval&lt;/code&gt; 字段将设置为字符串的主体。</target>
        </trans-unit>
        <trans-unit id="479c547e4f51a87c5259ae916511976a07f64d0b" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;object&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, this method writes an SQL &lt;code&gt;NULL&lt;/code&gt; to the stream.</source>
          <target state="translated">当 &lt;code&gt;object&lt;/code&gt; 为 &lt;code&gt;null&lt;/code&gt; 时，此方法将SQL &lt;code&gt;NULL&lt;/code&gt; 写入流。</target>
        </trans-unit>
        <trans-unit id="a7c8af093f9042d418aa0a04feb575a30082784d" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;registerApplicationClasspathSpis&lt;/code&gt; method is called, additional service provider instances will be discovered using &lt;a href=&quot;../../../../java.base/java/util/serviceloader&quot;&gt;&lt;code&gt;ServiceLoader&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">当 &lt;code&gt;registerApplicationClasspathSpis&lt;/code&gt; 方法被调用时，额外的服务提供商实例将使用被发现&lt;a href=&quot;../../../../java.base/java/util/serviceloader&quot;&gt; &lt;code&gt;ServiceLoader&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fad260ae6f20782961df5b3d238d1f3fbcb7ca36" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;registerApplicationClasspathSpis&lt;/code&gt; method is called, service provider instances declared in the meta-information section of JAR files on the application class path are loaded. To declare a service provider, a &lt;code&gt;services&lt;/code&gt; subdirectory is placed within the &lt;code&gt;META-INF&lt;/code&gt; directory that is present in every JAR file. This directory contains a file for each service provider interface that has one or more implementation classes present in the JAR file. For example, if the JAR file contained a class named &lt;code&gt;com.mycompany.imageio.MyFormatReaderSpi&lt;/code&gt; which implements the &lt;code&gt;ImageReaderSpi&lt;/code&gt; interface, the JAR file would contain a file named:</source>
          <target state="translated">当 &lt;code&gt;registerApplicationClasspathSpis&lt;/code&gt; 方法被调用，在应用程序类路径上的JAR文件的元信息部分声明的服务提供商实例被加载。为了声明服务提供者， &lt;code&gt;services&lt;/code&gt; 子目录位于每个JAR文件中存在的 &lt;code&gt;META-INF&lt;/code&gt; 目录中。该目录包含每个服务提供者接口的文件，该文件在JAR文件中具有一个或多个实现类。例如，如果JAR文件包含一个名为 &lt;code&gt;com.mycompany.imageio.MyFormatReaderSpi&lt;/code&gt; 的类，该类实现了 &lt;code&gt;ImageReaderSpi&lt;/code&gt; 接口，则JAR文件将包含一个名为：</target>
        </trans-unit>
        <trans-unit id="1d7c29a50f078499455eb20c32d93d78a48c9f01" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;type&lt;/code&gt; attribute has the value &quot;Image&quot;, this attribute specifies the location of the image to be used to decorate the graphical submit button.</source>
          <target state="translated">当 &lt;code&gt;type&lt;/code&gt; 属性的值为&amp;ldquo; Image&amp;rdquo;时，此属性指定用于装饰图形提交按钮的图像的位置。</target>
        </trans-unit>
        <trans-unit id="fe420595726ef6f4cea43793d3befe1ec70bb431" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;type&lt;/code&gt; attribute has the value &quot;Image&quot;, this attribute specifies the location of the image to be used to decorate the graphical submit button. See the src attribute definition in HTML 4.0.</source>
          <target state="translated">当 &lt;code&gt;type&lt;/code&gt; 属性的值为&amp;ldquo; Image&amp;rdquo;时，此属性指定用于装饰图形提交按钮的图像的位置。请参阅HTML 4.0中的src属性定义。</target>
        </trans-unit>
        <trans-unit id="6a87e75448196368d2ca88dfa8eb1d149546fe87" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;type&lt;/code&gt; attribute of the element has the value &quot;Radio&quot; or &quot;Checkbox&quot;, this represents the current state of the form control, in an interactive user agent.</source>
          <target state="translated">当元素的 &lt;code&gt;type&lt;/code&gt; 属性具有值&amp;ldquo; Radio&amp;rdquo;或&amp;ldquo; Checkbox&amp;rdquo;时，这表示交互式用户代理中表单控件的当前状态。</target>
        </trans-unit>
        <trans-unit id="d49c80b9841e84f8a7c8515f76b433ba145603d8" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;type&lt;/code&gt; attribute of the element has the value &quot;Radio&quot; or &quot;Checkbox&quot;, this represents the current state of the form control, in an interactive user agent. Changes to this attribute change the state of the form control, but do not change the value of the HTML value attribute of the element.</source>
          <target state="translated">当元素的 &lt;code&gt;type&lt;/code&gt; 属性具有值&amp;ldquo; Radio&amp;rdquo;或&amp;ldquo; Checkbox&amp;rdquo;时，这表示交互式用户代理中表单控件的当前状态。对此属性所做的更改将更改表单控件的状态，但不要更改元素的HTML值属性的值。</target>
        </trans-unit>
        <trans-unit id="a4bbc557616f805bd97932df07680b227edc6b97" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;type&lt;/code&gt; attribute of the element has the value &quot;Text&quot;, &quot;File&quot; or &quot;Password&quot;, this represents the HTML value attribute of the element.</source>
          <target state="translated">当元素的 &lt;code&gt;type&lt;/code&gt; 属性的值为&amp;ldquo;文本&amp;rdquo;，&amp;ldquo;文件&amp;rdquo;或&amp;ldquo;密码&amp;rdquo;时，这表示元素的HTML值属性。</target>
        </trans-unit>
        <trans-unit id="1f273c5edddbd7d73cb1be1527d8123a3894a875" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;type&lt;/code&gt; attribute of the element has the value &quot;Text&quot;, &quot;File&quot; or &quot;Password&quot;, this represents the HTML value attribute of the element. The value of this attribute does not change if the contents of the corresponding form control, in an interactive user agent, changes. Changing this attribute, however, resets the contents of the form control. See the value attribute definition in HTML 4.0.</source>
          <target state="translated">当元素的 &lt;code&gt;type&lt;/code&gt; 属性的值为&amp;ldquo;文本&amp;rdquo;，&amp;ldquo;文件&amp;rdquo;或&amp;ldquo;密码&amp;rdquo;时，这表示元素的HTML值属性。如果交互式用户代理中相应表单控件的内容发生更改，则此属性的值不会更改。但是，更改此属性将重置表单控件的内容。请参见HTML 4.0中的value属性定义。</target>
        </trans-unit>
        <trans-unit id="3c7473c1965c73d523c3c557041cab9f803c0e19" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;type&lt;/code&gt; attribute of the element has the value &quot;Text&quot;, &quot;File&quot; or &quot;Password&quot;, this represents the current contents of the corresponding form control, in an interactive user agent.</source>
          <target state="translated">当元素的 &lt;code&gt;type&lt;/code&gt; 属性的值为&amp;ldquo;文本&amp;rdquo;，&amp;ldquo;文件&amp;rdquo;或&amp;ldquo;密码&amp;rdquo;时，这表示交互式用户代理中相应表单控件的当前内容。</target>
        </trans-unit>
        <trans-unit id="0e120dc1f42b3033cc55ae4adc8c02b21e666f32" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;type&lt;/code&gt; attribute of the element has the value &quot;Text&quot;, &quot;File&quot; or &quot;Password&quot;, this represents the current contents of the corresponding form control, in an interactive user agent. Changing this attribute changes the contents of the form control, but does not change the value of the HTML value attribute of the element. When the &lt;code&gt;type&lt;/code&gt; attribute of the element has the value &quot;Button&quot;, &quot;Hidden&quot;, &quot;Submit&quot;, &quot;Reset&quot;, &quot;Image&quot;, &quot;Checkbox&quot; or &quot;Radio&quot;, this represents the HTML value attribute of the element. See the value attribute definition in HTML 4.0.</source>
          <target state="translated">当元素的 &lt;code&gt;type&lt;/code&gt; 属性的值为&amp;ldquo;文本&amp;rdquo;，&amp;ldquo;文件&amp;rdquo;或&amp;ldquo;密码&amp;rdquo;时，这表示交互式用户代理中相应表单控件的当前内容。更改此属性将更改表单控件的内容，但不会更改元素的HTML值属性的值。当元素的 &lt;code&gt;type&lt;/code&gt; 属性的值为&amp;ldquo;按钮&amp;rdquo;，&amp;ldquo;隐藏&amp;rdquo;，&amp;ldquo;提交&amp;rdquo;，&amp;ldquo;重置&amp;rdquo;，&amp;ldquo;图像&amp;rdquo;，&amp;ldquo;复选框&amp;rdquo;或&amp;ldquo;无线电&amp;rdquo;时，这表示元素的HTML值属性。请参见HTML 4.0中的value属性定义。</target>
        </trans-unit>
        <trans-unit id="800a8722fdd5697538b5f0c521ac05a66ca1b2c2" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;value&lt;/code&gt; property changes, &lt;code&gt;ChangeListeners&lt;/code&gt; are notified. &lt;code&gt;SpinnerModel&lt;/code&gt; may choose to notify the &lt;code&gt;ChangeListeners&lt;/code&gt; under other circumstances.</source>
          <target state="translated">当 &lt;code&gt;value&lt;/code&gt; 属性更改时，将通知 &lt;code&gt;ChangeListeners&lt;/code&gt; 。在其他情况下， &lt;code&gt;SpinnerModel&lt;/code&gt; 可以选择通知 &lt;code&gt;ChangeListeners&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="515adaec2191bebc2d2c17a699cb4b4c2d2e4592" translate="yes" xml:space="preserve">
          <source>When the BasicAttributes class needs to create an Attribute, it uses BasicAttribute. There is no other dependency on BasicAttribute.</source>
          <target state="translated">当BasicAttributes类需要创建一个Attribute时,它使用BasicAttribute。BasicAttribute没有其他依赖性。</target>
        </trans-unit>
        <trans-unit id="3ec9901f8b0995c7d238dee247f5bc92ba92c9c8" translate="yes" xml:space="preserve">
          <source>When the DBMS does not store time zone information, the driver will use the given &lt;code&gt;Calendar&lt;/code&gt; object to construct the SQL &lt;code&gt;TIME&lt;/code&gt; value to send to the database. With a &lt;code&gt;Calendar&lt;/code&gt; object, the driver can calculate the date taking into account a custom time zone. If no &lt;code&gt;Calendar&lt;/code&gt; object is specified, the driver uses the time zone of the Virtual Machine that is running the application.</source>
          <target state="translated">当DBMS不存储时区信息时，驱动程序将使用给定的 &lt;code&gt;Calendar&lt;/code&gt; 对象构造要发送到数据库的SQL &lt;code&gt;TIME&lt;/code&gt; 值。使用 &lt;code&gt;Calendar&lt;/code&gt; 对象，驱动程序可以考虑自定义时区来计算日期。如果未指定 &lt;code&gt;Calendar&lt;/code&gt; 对象，则驱动程序将使用运行应用程序的虚拟机的时区。</target>
        </trans-unit>
        <trans-unit id="45a7b9314633389caa68b45c357b57d0f9fe579c" translate="yes" xml:space="preserve">
          <source>When the DBMS does not store time zone information, the driver will use the given &lt;code&gt;Calendar&lt;/code&gt; object to construct the SQL &lt;code&gt;TIMESTAMP&lt;/code&gt; value to send to the database. With a &lt;code&gt;Calendar&lt;/code&gt; object, the driver can calculate the timestamp taking into account a custom time zone. If no &lt;code&gt;Calendar&lt;/code&gt; object is specified, the driver uses the time zone of the Virtual Machine that is running the application.</source>
          <target state="translated">当DBMS不存储时区信息时，驱动程序将使用给定的 &lt;code&gt;Calendar&lt;/code&gt; 对象构造SQL &lt;code&gt;TIMESTAMP&lt;/code&gt; 值以发送到数据库。使用 &lt;code&gt;Calendar&lt;/code&gt; 对象，驱动程序可以在考虑自定义时区的情况下计算时间戳。如果未指定 &lt;code&gt;Calendar&lt;/code&gt; 对象，则驱动程序将使用运行应用程序的虚拟机的时区。</target>
        </trans-unit>
        <trans-unit id="e2b0cfb7cdca209b8227f0135c9ead5e644da49f" translate="yes" xml:space="preserve">
          <source>When the JNDI class library needs to determine the value of a property, it does so by merging the values from the following two sources, in order:</source>
          <target state="translated">当JNDI类库需要确定一个属性的值时,它通过按顺序合并以下两个来源的值来实现。</target>
        </trans-unit>
        <trans-unit id="8ff307d52b74a9d5a00fe0eeed0ad2b6f63f945d" translate="yes" xml:space="preserve">
          <source>When the JVM materializes a &lt;code&gt;MethodType&lt;/code&gt; from a descriptor string, all classes named in the descriptor must be accessible, and will be loaded. (But the classes need not be initialized, as is the case with a &lt;code&gt;CONSTANT_Class&lt;/code&gt;.) This loading may occur at any time before the &lt;code&gt;MethodType&lt;/code&gt; object is first derived.</source>
          <target state="translated">当JVM 从描述符字符串中实现 &lt;code&gt;MethodType&lt;/code&gt; 时，该描述符中命名的所有类都必须可访问并将被加载。 （但是不需要像 &lt;code&gt;CONSTANT_Class&lt;/code&gt; 那样初始化类。）这种加载可能在首次派生 &lt;code&gt;MethodType&lt;/code&gt; 对象之前的任何时间发生。</target>
        </trans-unit>
        <trans-unit id="242f542a50d3a5d71e04513db113467fef250729" translate="yes" xml:space="preserve">
          <source>When the JVM processes bytecode containing signature polymorphic calls, it will successfully link any such call, regardless of its symbolic type descriptor. (In order to retain type safety, the JVM will guard such calls with suitable dynamic type checks, as described elsewhere.)</source>
          <target state="translated">当JVM处理包含签名多态调用的字节码时,无论其符号类型描述符是什么,它都会成功链接任何这样的调用。为了保持类型安全,JVM将用适当的动态类型检查来保护这类调用,如其他地方所述)。</target>
        </trans-unit>
        <trans-unit id="2193c7a9c7d458a9821bb858408d7793d0ae7d86" translate="yes" xml:space="preserve">
          <source>When the Java Virtual Machine first starts, it determines if the system property &lt;code&gt;java.compiler&lt;/code&gt; exists. (System properties are accessible through &lt;a href=&quot;system#getProperty-java.lang.String-&quot;&gt;&lt;code&gt;System.getProperty(String)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;system#getProperty-java.lang.String-java.lang.String-&quot;&gt;&lt;code&gt;System.getProperty(String, String)&lt;/code&gt;&lt;/a&gt;. If so, it is assumed to be the name of a library (with a platform-dependent exact location and type); &lt;a href=&quot;system#loadLibrary-java.lang.String-&quot;&gt;&lt;code&gt;System.loadLibrary(java.lang.String)&lt;/code&gt;&lt;/a&gt; is called to load that library. If this loading succeeds, the function named &lt;code&gt;java_lang_Compiler_start()&lt;/code&gt; in that library is called.</source>
          <target state="translated">Java虚拟机首次启动时，它将确定系统属性 &lt;code&gt;java.compiler&lt;/code&gt; 是否存在。（系统属性可通过&lt;a href=&quot;system#getProperty-java.lang.String-&quot;&gt; &lt;code&gt;System.getProperty(String)&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;system#getProperty-java.lang.String-java.lang.String-&quot;&gt; &lt;code&gt;System.getProperty(String, String)&lt;/code&gt; &lt;/a&gt;。如果是，则假定它是库的名称（具有与平台有关的确切位置和类型）；&lt;a href=&quot;system#loadLibrary-java.lang.String-&quot;&gt; &lt;code&gt;System.loadLibrary(java.lang.String)&lt;/code&gt; &lt;/a&gt;被调用以加载该库，如果加载成功，则该库中名为 &lt;code&gt;java_lang_Compiler_start()&lt;/code&gt; 的函数被调用。</target>
        </trans-unit>
        <trans-unit id="ddddab91c8fcafe94a4c994027d61bf864bf4c44" translate="yes" xml:space="preserve">
          <source>When the Java virtual machine has no stack trace information about a thread or &lt;code&gt;maxDepth == 0&lt;/code&gt;, the stack trace in the &lt;code&gt;ThreadInfo&lt;/code&gt; object will be an empty array of &lt;code&gt;StackTraceElement&lt;/code&gt;.</source>
          <target state="translated">当Java虚拟机没有有关线程的堆栈跟踪信息或 &lt;code&gt;maxDepth == 0&lt;/code&gt; ， &lt;code&gt;ThreadInfo&lt;/code&gt; 对象中的堆栈跟踪将为 &lt;code&gt;StackTraceElement&lt;/code&gt; 的空数组。</target>
        </trans-unit>
        <trans-unit id="38db82049f33225d933e0b41a46907899f2d6c86" translate="yes" xml:space="preserve">
          <source>When the LoginContext uses the installed Configuration (instead of a caller-specified Configuration, see above), then this LoginContext must wrap any caller-specified or default CallbackHandler implementation in a new CallbackHandler implementation whose &lt;code&gt;handle&lt;/code&gt; method implementation invokes the specified CallbackHandler's &lt;code&gt;handle&lt;/code&gt; method in a &lt;code&gt;java.security.AccessController.doPrivileged&lt;/code&gt; call constrained by the caller's current &lt;code&gt;AccessControlContext&lt;/code&gt;.</source>
          <target state="translated">当LoginContext使用已安装的Configuration（而不是调用方指定的Configuration，请参见上文）时，则此LoginContext必须将任何调用方指定的或默认的CallbackHandler实现包装在新的CallbackHandler实现中，该实现的 &lt;code&gt;handle&lt;/code&gt; 方法实现会在一个新的CallbackHandler中调用指定的CallbackHandler的 &lt;code&gt;handle&lt;/code&gt; 方法。受调用者当前 &lt;code&gt;AccessControlContext&lt;/code&gt; 约束的 &lt;code&gt;java.security.AccessController.doPrivileged&lt;/code&gt; 调用。</target>
        </trans-unit>
        <trans-unit id="5cf48683ff79ab19b22e2f40ce14d8b39cb8a4f9" translate="yes" xml:space="preserve">
          <source>When the MAX and MIN bounds are hit</source>
          <target state="translated">当达到MAX和MIN界限时</target>
        </trans-unit>
        <trans-unit id="d4284eca7ac5f100fd0fbfcaaa47ff80683f124b" translate="yes" xml:space="preserve">
          <source>When the OOBINLINE option is set, any TCP urgent data received on the socket will be received through the socket input stream.</source>
          <target state="translated">当设置OOBINLINE选项时,套接字上收到的任何TCP紧急数据都将通过套接字输入流接收。</target>
        </trans-unit>
        <trans-unit id="59ad08ab5cdf3a4c4f05c736af38894997dad527" translate="yes" xml:space="preserve">
          <source>When the OOBINLINE option is set, any TCP urgent data received on the socket will be received through the socket input stream. When the option is disabled (which is the default) urgent data is silently discarded.</source>
          <target state="translated">当设置OOBINLINE选项时,套接字上收到的任何TCP紧急数据将通过套接字输入流接收。当该选项被禁用时(默认情况下),紧急数据将被默默丢弃。</target>
        </trans-unit>
        <trans-unit id="9833dcc09e733a827020ccf648bcb6cd4665e7ef" translate="yes" xml:space="preserve">
          <source>When the Open Type is &lt;code&gt;CompositeType&lt;/code&gt;, the corresponding mapped Java type (&lt;em&gt;opendata(J)&lt;/em&gt;) is &lt;a href=&quot;openmbean/compositedata&quot;&gt;&lt;code&gt;CompositeData&lt;/code&gt;&lt;/a&gt;. The mapping from an instance of &lt;em&gt;J&lt;/em&gt; to a &lt;code&gt;CompositeData&lt;/code&gt; corresponding to the &lt;code&gt;CompositeType&lt;/code&gt; just described is done as follows. First, if &lt;em&gt;J&lt;/em&gt; implements the interface &lt;a href=&quot;openmbean/compositedataview&quot;&gt;&lt;code&gt;CompositeDataView&lt;/code&gt;&lt;/a&gt;, then that interface's &lt;a href=&quot;openmbean/compositedataview#toCompositeData(javax.management.openmbean.CompositeType)&quot;&gt;&lt;code&gt;toCompositeData&lt;/code&gt;&lt;/a&gt; method is called to do the conversion. Otherwise, the &lt;code&gt;CompositeData&lt;/code&gt; is constructed by calling the getter for each item and converting it to the corresponding Open Data type. Thus, a getter such as</source>
          <target state="translated">当Open Type为 &lt;code&gt;CompositeType&lt;/code&gt; 时，对应的映射Java类型（&lt;em&gt;opendata（J）&lt;/em&gt;）为&lt;a href=&quot;openmbean/compositedata&quot;&gt; &lt;code&gt;CompositeData&lt;/code&gt; &lt;/a&gt;。从&lt;em&gt;J&lt;/em&gt;的实例到对应于刚才描述的 &lt;code&gt;CompositeType&lt;/code&gt; 的 &lt;code&gt;CompositeData&lt;/code&gt; 的映射如下进行。首先，如果&lt;em&gt;J&lt;/em&gt;实现接口&lt;a href=&quot;openmbean/compositedataview&quot;&gt; &lt;code&gt;CompositeDataView&lt;/code&gt; &lt;/a&gt;，则调用该接口的&lt;a href=&quot;openmbean/compositedataview#toCompositeData(javax.management.openmbean.CompositeType)&quot;&gt; &lt;code&gt;toCompositeData&lt;/code&gt; &lt;/a&gt;方法进行转换。否则，将通过为每个项目调用getter并将其转换为相应的Open Data类型来构造 &lt;code&gt;CompositeData&lt;/code&gt; 。因此，诸如&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="dabf2aef104d7b63f254f09d8ef274526085868a" translate="yes" xml:space="preserve">
          <source>When the Open Type is &lt;code&gt;CompositeType&lt;/code&gt;, the corresponding mapped Java type (&lt;em&gt;opendata(J)&lt;/em&gt;) is &lt;a href=&quot;openmbean/compositedata&quot;&gt;&lt;code&gt;CompositeData&lt;/code&gt;&lt;/a&gt;. The mapping from an instance of &lt;em&gt;J&lt;/em&gt; to a &lt;code&gt;CompositeData&lt;/code&gt; corresponding to the &lt;code&gt;CompositeType&lt;/code&gt; just described is done as follows. First, if &lt;em&gt;J&lt;/em&gt; implements the interface &lt;a href=&quot;openmbean/compositedataview&quot;&gt;&lt;code&gt;CompositeDataView&lt;/code&gt;&lt;/a&gt;, then that interface's &lt;a href=&quot;openmbean/compositedataview#toCompositeData-javax.management.openmbean.CompositeType-&quot;&gt;&lt;code&gt;toCompositeData&lt;/code&gt;&lt;/a&gt; method is called to do the conversion. Otherwise, the &lt;code&gt;CompositeData&lt;/code&gt; is constructed by calling the getter for each item and converting it to the corresponding Open Data type. Thus, a getter such as</source>
          <target state="translated">当Open Type为 &lt;code&gt;CompositeType&lt;/code&gt; 时，对应的映射Java类型（&lt;em&gt;opendata（J）&lt;/em&gt;）为&lt;a href=&quot;openmbean/compositedata&quot;&gt; &lt;code&gt;CompositeData&lt;/code&gt; &lt;/a&gt;。从&lt;em&gt;J&lt;/em&gt;的实例到对应于刚才描述的 &lt;code&gt;CompositeType&lt;/code&gt; 的 &lt;code&gt;CompositeData&lt;/code&gt; 的映射如下进行。首先，如果&lt;em&gt;J&lt;/em&gt;实现接口&lt;a href=&quot;openmbean/compositedataview&quot;&gt; &lt;code&gt;CompositeDataView&lt;/code&gt; &lt;/a&gt;，那么将调用该接口的&lt;a href=&quot;openmbean/compositedataview#toCompositeData-javax.management.openmbean.CompositeType-&quot;&gt; &lt;code&gt;toCompositeData&lt;/code&gt; &lt;/a&gt;方法进行转换。否则，通过为每个项目调用getter并将其转换为相应的Open Data类型来构造 &lt;code&gt;CompositeData&lt;/code&gt; 。因此，诸如&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="96641c01f072f14964ded9541c6c86f41bebe686" translate="yes" xml:space="preserve">
          <source>When the access permissions are set at file creation time then the actual value of the permissions may differ from the value of the attribute object. The reasons for this are implementation specific. On UNIX systems, for example, a process has a &lt;em&gt;umask&lt;/em&gt; that impacts the permission bits of newly created files. Where an implementation supports the setting of the access permissions, and the underlying file system supports access permissions, then it is required that the value of the actual access permissions will be equal or less than the value of the attribute provided to the &lt;a href=&quot;../files#createFile(java.nio.file.Path,java.nio.file.attribute.FileAttribute...)&quot;&gt;&lt;code&gt;createFile&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../files#createDirectory(java.nio.file.Path,java.nio.file.attribute.FileAttribute...)&quot;&gt;&lt;code&gt;createDirectory&lt;/code&gt;&lt;/a&gt; methods. In other words, the file may be more secure than requested.</source>
          <target state="translated">当在文件创建时设置访问权限时，权限的实际值可能与属性对象的值不同。这样做的原因是特定于实现的。例如，在UNIX系统上，进程的&lt;em&gt;umask&lt;/em&gt;影响新创建文件的权限位。如果实现支持访问权限的设置，而基础文件系统支持访问权限，则要求实际访问权限的值等于或小于提供给&lt;a href=&quot;../files#createFile(java.nio.file.Path,java.nio.file.attribute.FileAttribute...)&quot;&gt; &lt;code&gt;createFile&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../files#createDirectory(java.nio.file.Path,java.nio.file.attribute.FileAttribute...)&quot;&gt; &lt;code&gt;createDirectory&lt;/code&gt; &lt;/a&gt;方法的属性的值。换句话说，文件可能比请求的文件更安全。</target>
        </trans-unit>
        <trans-unit id="6807cd6ed53e44e911717bb50e25ffb553b8f9ce" translate="yes" xml:space="preserve">
          <source>When the access permissions are set at file creation time then the actual value of the permissions may differ that the value of the attribute object. The reasons for this are implementation specific. On UNIX systems, for example, a process has a &lt;em&gt;umask&lt;/em&gt; that impacts the permission bits of newly created files. Where an implementation supports the setting of the access permissions, and the underlying file system supports access permissions, then it is required that the value of the actual access permissions will be equal or less than the value of the attribute provided to the &lt;a href=&quot;../files#createFile(java.nio.file.Path,java.nio.file.attribute.FileAttribute...)&quot;&gt;&lt;code&gt;createFile&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../files#createDirectory(java.nio.file.Path,java.nio.file.attribute.FileAttribute...)&quot;&gt;&lt;code&gt;createDirectory&lt;/code&gt;&lt;/a&gt; methods. In other words, the file may be more secure than requested.</source>
          <target state="translated">当在文件创建时设置访问权限时，权限的实际值可能与属性对象的值不同。这样做的原因是特定于实现的。例如，在UNIX系统上，进程的&lt;em&gt;umask&lt;/em&gt;影响新创建文件的权限位。如果实现支持访问权限的设置，而基础文件系统支持访问权限，则要求实际访问权限的值等于或小于提供给&lt;a href=&quot;../files#createFile(java.nio.file.Path,java.nio.file.attribute.FileAttribute...)&quot;&gt; &lt;code&gt;createFile&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../files#createDirectory(java.nio.file.Path,java.nio.file.attribute.FileAttribute...)&quot;&gt; &lt;code&gt;createDirectory&lt;/code&gt; &lt;/a&gt;方法的属性的值。换句话说，文件可能比请求的文件更安全。</target>
        </trans-unit>
        <trans-unit id="5cc6a806fe924f827c1be349c2dda336ff41691d" translate="yes" xml:space="preserve">
          <source>When the access permissions are set at file creation time then the actual value of the permissions may differ that the value of the attribute object. The reasons for this are implementation specific. On UNIX systems, for example, a process has a &lt;em&gt;umask&lt;/em&gt; that impacts the permission bits of newly created files. Where an implementation supports the setting of the access permissions, and the underlying file system supports access permissions, then it is required that the value of the actual access permissions will be equal or less than the value of the attribute provided to the &lt;a href=&quot;../files#createFile-java.nio.file.Path-java.nio.file.attribute.FileAttribute...-&quot;&gt;&lt;code&gt;createFile&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../files#createDirectory-java.nio.file.Path-java.nio.file.attribute.FileAttribute...-&quot;&gt;&lt;code&gt;createDirectory&lt;/code&gt;&lt;/a&gt; methods. In other words, the file may be more secure than requested.</source>
          <target state="translated">当在文件创建时设置访问权限时，权限的实际值可能与属性对象的值不同。这样做的原因是特定于实现的。例如，在UNIX系统上，进程的&lt;em&gt;umask&lt;/em&gt;影响新创建文件的权限位。如果实现支持访问权限的设置，而基础文件系统支持访问权限，则要求实际访问权限的值等于或小于提供给&lt;a href=&quot;../files#createFile-java.nio.file.Path-java.nio.file.attribute.FileAttribute...-&quot;&gt; &lt;code&gt;createFile&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../files#createDirectory-java.nio.file.Path-java.nio.file.attribute.FileAttribute...-&quot;&gt; &lt;code&gt;createDirectory&lt;/code&gt; &lt;/a&gt;方法的属性的值。换句话说，文件可能比请求的文件更安全。</target>
        </trans-unit>
        <trans-unit id="69569ad21e8363df8daeddf8b551ab74285ca4d0" translate="yes" xml:space="preserve">
          <source>When the adapter is called, the length of the supplied &lt;code&gt;array&lt;/code&gt; argument is queried as if by &lt;code&gt;array.length&lt;/code&gt; or &lt;code&gt;arraylength&lt;/code&gt; bytecode. If the adapter accepts a zero-length trailing array argument, the supplied &lt;code&gt;array&lt;/code&gt; argument can either be a zero-length array or &lt;code&gt;null&lt;/code&gt;; otherwise, the adapter will throw a &lt;code&gt;NullPointerException&lt;/code&gt; if the array is &lt;code&gt;null&lt;/code&gt; and throw an &lt;a href=&quot;../illegalargumentexception&quot;&gt;&lt;code&gt;IllegalArgumentException&lt;/code&gt;&lt;/a&gt; if the array does not have the correct number of elements.</source>
          <target state="translated">调用适配器时，将像通过 &lt;code&gt;array.length&lt;/code&gt; 或 &lt;code&gt;arraylength&lt;/code&gt; 字节码查询所提供的 &lt;code&gt;array&lt;/code&gt; 参数的长度。如果适配器接受零长度的尾随数组参数，则提供的 &lt;code&gt;array&lt;/code&gt; 参数可以是零长度数组或 &lt;code&gt;null&lt;/code&gt; ；否则，适配器将抛出一个 &lt;code&gt;NullPointerException&lt;/code&gt; 异常如果数组为 &lt;code&gt;null&lt;/code&gt; 并抛出&lt;a href=&quot;../illegalargumentexception&quot;&gt; &lt;code&gt;IllegalArgumentException&lt;/code&gt; &lt;/a&gt;如果数组没有正确的元素数量。</target>
        </trans-unit>
        <trans-unit id="f27103f429183890d7b676c4e6d53958062dc5b7" translate="yes" xml:space="preserve">
          <source>When the application provides a filter, the serializer will call out to the filter before serializing each Node.</source>
          <target state="translated">当应用程序提供一个过滤器时,序列化器将在序列化每个Node之前调用过滤器。</target>
        </trans-unit>
        <trans-unit id="eafdeecdd692ae88f791f406318133fd82c05cf0" translate="yes" xml:space="preserve">
          <source>When the application provides a filter, the serializer will call out to the filter before serializing each Node. The filter implementation can choose to remove the node from the stream or to terminate the serialization early.</source>
          <target state="translated">当应用程序提供过滤器时,序列化器将在序列化每个Node之前向过滤器调用。过滤器的实现可以选择从流中删除节点,或者提前终止序列化。</target>
        </trans-unit>
        <trans-unit id="b18b14612d284db82e4ae58a49b67bd2c4968f17" translate="yes" xml:space="preserve">
          <source>When the attribute at the head of the stream is an SQL &lt;code&gt;NULL&lt;/code&gt; the method returns &lt;code&gt;null&lt;/code&gt;. If the attribute is an SQL structured or distinct type, it determines the SQL type of the attribute at the head of the stream. If the stream's type map has an entry for that SQL type, the driver constructs an object of the appropriate class and calls the method &lt;code&gt;SQLData.readSQL&lt;/code&gt; on that object, which reads additional data from the stream, using the protocol described for that method.</source>
          <target state="translated">当流头的属性为SQL &lt;code&gt;NULL&lt;/code&gt; 时,该方法返回 &lt;code&gt;null&lt;/code&gt; 。如果属性是SQL结构化或不同类型，则它确定流顶部的属性的SQL类型。如果流的类型映射具有该SQL类型的条目，则驱动程序将构造一个适当的类的对象，并对该对象调用 &lt;code&gt;SQLData.readSQL&lt;/code&gt; 方法，该对象将使用针对该方法描述的协议从该流中读取其他数据。</target>
        </trans-unit>
        <trans-unit id="2e26fb92c98071abdc173b7cc97141c52fde98ec" translate="yes" xml:space="preserve">
          <source>When the bootstrap method is invoked, it needs to create a &lt;a href=&quot;../java.base/java/lang/invoke/callsite&quot;&gt;&lt;code&gt;CallSite&lt;/code&gt;&lt;/a&gt; object. In Dynalink, these call sites need to additionally implement the &lt;a href=&quot;jdk/dynalink/relinkablecallsite&quot;&gt;&lt;code&gt;RelinkableCallSite&lt;/code&gt;&lt;/a&gt; interface. &quot;Relinkable&quot; here alludes to the fact that if the call site encounters objects of different types at run time, its target will be changed to a method handle that can perform the operation on the newly encountered type. &lt;a href=&quot;jdk/dynalink/support/simplerelinkablecallsite&quot;&gt;&lt;code&gt;SimpleRelinkableCallSite&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;jdk/dynalink/support/chainedcallsite&quot;&gt;&lt;code&gt;ChainedCallSite&lt;/code&gt;&lt;/a&gt; (not used in the above example) are two implementations already provided by the library.</source>
          <target state="translated">调用bootstrap方法时，需要创建一个&lt;a href=&quot;../java.base/java/lang/invoke/callsite&quot;&gt; &lt;code&gt;CallSite&lt;/code&gt; &lt;/a&gt;对象。在Dynalink中，这些呼叫站点需要另外实现&lt;a href=&quot;jdk/dynalink/relinkablecallsite&quot;&gt; &lt;code&gt;RelinkableCallSite&lt;/code&gt; &lt;/a&gt;接口。 &amp;ldquo;可链接&amp;rdquo;在此暗示这样一个事实，即如果调用站点在运行时遇到不同类型的对象，则其目标将更改为可以对新遇到的类型执行操作的方法句柄。&lt;a href=&quot;jdk/dynalink/support/simplerelinkablecallsite&quot;&gt; &lt;code&gt;SimpleRelinkableCallSite&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;jdk/dynalink/support/chainedcallsite&quot;&gt; &lt;code&gt;ChainedCallSite&lt;/code&gt; &lt;/a&gt;（在上面的示例中未使用）是该库已经提供的两个实现。</target>
        </trans-unit>
        <trans-unit id="67e1e670368e0408444ca57de73d1a38a08a71cb" translate="yes" xml:space="preserve">
          <source>When the client is running a later version than the server, certain newer features may not be available, as detailed in the next sections. The client can determine the server's version by examining the &lt;a href=&quot;mbeanserverdelegatembean#getSpecificationVersion()&quot;&gt;&lt;code&gt;SpecificationVersion&lt;/code&gt;&lt;/a&gt; attribute of the &lt;code&gt;
        MBeanServerDelegate&lt;/code&gt;.</source>
          <target state="translated">当客户端运行的服务器版本高于服务器时，某些较新的功能可能不可用，如以下各节所述。客户端可以通过检查 &lt;code&gt; MBeanServerDelegate&lt;/code&gt; 的&lt;a href=&quot;mbeanserverdelegatembean#getSpecificationVersion()&quot;&gt; &lt;code&gt;SpecificationVersion&lt;/code&gt; &lt;/a&gt;属性来确定服务器的版本。</target>
        </trans-unit>
        <trans-unit id="3dd6047101821af20c03ece3438348c43a2a0666" translate="yes" xml:space="preserve">
          <source>When the client is running a later version than the server, certain newer features may not be available, as detailed in the next sections. The client can determine the server's version by examining the &lt;a href=&quot;mbeanserverdelegatembean#getSpecificationVersion--&quot;&gt;&lt;code&gt;SpecificationVersion&lt;/code&gt;&lt;/a&gt; attribute of the &lt;code&gt;MBeanServerDelegate&lt;/code&gt;.</source>
          <target state="translated">当客户端运行的服务器版本高于服务器时，某些较新的功能可能不可用，如以下各节所述。客户端可以通过检查 &lt;code&gt;MBeanServerDelegate&lt;/code&gt; 的&lt;a href=&quot;mbeanserverdelegatembean#getSpecificationVersion--&quot;&gt; &lt;code&gt;SpecificationVersion&lt;/code&gt; &lt;/a&gt;属性来确定服务器的版本。</target>
        </trans-unit>
        <trans-unit id="5656bb0d523a39fd577359655a0712dc9a981a5c" translate="yes" xml:space="preserve">
          <source>When the condition &lt;a href=&quot;condition#await()&quot;&gt;waiting&lt;/a&gt; methods are called the lock is released and, before they return, the lock is reacquired and the lock hold count restored to what it was when the method was called.</source>
          <target state="translated">当调用条件&lt;a href=&quot;condition#await()&quot;&gt;等待&lt;/a&gt;方法时，将释放锁，并在锁返回之前，重新获取该锁，并将锁保持计数恢复到调用该方法时的状态。</target>
        </trans-unit>
        <trans-unit id="d87e1d90469eb807a66798a3412565993b14ba79" translate="yes" xml:space="preserve">
          <source>When the condition &lt;a href=&quot;condition#await()&quot;&gt;waiting&lt;/a&gt; methods are called the write lock is released and, before they return, the write lock is reacquired and the lock hold count restored to what it was when the method was called.</source>
          <target state="translated">当条件&lt;a href=&quot;condition#await()&quot;&gt;等待&lt;/a&gt;方法被调用时，写锁被释放，并且在它们返回之前，将重新获取写锁，并将锁保持计数恢复到调用该方法时的状态。</target>
        </trans-unit>
        <trans-unit id="5b2259ec0cf9dd1eabb68562ba1068a405b4ffb3" translate="yes" xml:space="preserve">
          <source>When the condition &lt;a href=&quot;condition#await--&quot;&gt;waiting&lt;/a&gt; methods are called the lock is released and, before they return, the lock is reacquired and the lock hold count restored to what it was when the method was called.</source>
          <target state="translated">当调用条件&lt;a href=&quot;condition#await--&quot;&gt;等待&lt;/a&gt;方法时，将释放该锁，并在它们返回之前，重新获取该锁，并将锁保持计数恢复到调用该方法时的状态。</target>
        </trans-unit>
        <trans-unit id="79dff109a2169a02dd1a4794f9a2ae88690f5d47" translate="yes" xml:space="preserve">
          <source>When the condition &lt;a href=&quot;condition#await--&quot;&gt;waiting&lt;/a&gt; methods are called the write lock is released and, before they return, the write lock is reacquired and the lock hold count restored to what it was when the method was called.</source>
          <target state="translated">当条件&lt;a href=&quot;condition#await--&quot;&gt;等待&lt;/a&gt;方法被调用时，写锁定被释放，并且在它们返回之前，将重新获取写锁定，并将锁保持计数恢复到调用该方法时的状态。</target>
        </trans-unit>
        <trans-unit id="638ae07a84d9d47123b5ecd412e4b6945e5f6478" translate="yes" xml:space="preserve">
          <source>When the connection is no longer needed, the client and server applications should each close both sides of their respective connection. For &lt;code&gt;SSLSocket&lt;/code&gt; objects, for example, an application can call &lt;a href=&quot;../../../java/net/socket#shutdownOutput()&quot;&gt;&lt;code&gt;Socket.shutdownOutput()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../../java/io/outputstream#close()&quot;&gt;&lt;code&gt;OutputStream.close()&lt;/code&gt;&lt;/a&gt; for output stream close and call &lt;a href=&quot;../../../java/net/socket#shutdownInput()&quot;&gt;&lt;code&gt;Socket.shutdownInput()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../../java/io/inputstream#close()&quot;&gt;&lt;code&gt;InputStream.close()&lt;/code&gt;&lt;/a&gt; for input stream close. Note that in some cases, closing the input stream may depend on the peer's output stream being closed first. If the connection is not closed in an orderly manner (for example &lt;a href=&quot;../../../java/net/socket#shutdownInput()&quot;&gt;&lt;code&gt;Socket.shutdownInput()&lt;/code&gt;&lt;/a&gt; is called before the peer's write closure notification has been received), exceptions may be raised to indicate that an error has occurred. Once an &lt;code&gt;SSLSocket&lt;/code&gt; is closed, it is not reusable: a new &lt;code&gt;SSLSocket&lt;/code&gt; must be created.</source>
          <target state="translated">当不再需要连接时，客户端和服务器应用程序应分别关闭其各自连接的两端。例如，对于 &lt;code&gt;SSLSocket&lt;/code&gt; 对象，应用程序可以调用&lt;a href=&quot;../../../java/net/socket#shutdownOutput()&quot;&gt; &lt;code&gt;Socket.shutdownOutput()&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../../../java/io/outputstream#close()&quot;&gt; &lt;code&gt;OutputStream.close()&lt;/code&gt; &lt;/a&gt;来关闭输出流，并调用&lt;a href=&quot;../../../java/net/socket#shutdownInput()&quot;&gt; &lt;code&gt;Socket.shutdownInput()&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../../../java/io/inputstream#close()&quot;&gt; &lt;code&gt;InputStream.close()&lt;/code&gt; &lt;/a&gt;来关闭输入流。注意，在某些情况下，关闭输入流可能取决于对等方的输出流首先被关闭。如果未按顺序关闭连接（例如&lt;a href=&quot;../../../java/net/socket#shutdownInput()&quot;&gt; &lt;code&gt;Socket.shutdownInput()&lt;/code&gt; &lt;/a&gt;在收到对等方的写关闭通知之前调用），可能会引发异常以指示发生了错误。一旦关闭 &lt;code&gt;SSLSocket&lt;/code&gt; ，它便不可重用：必须创建一个新的 &lt;code&gt;SSLSocket&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="16423c8ea158b78447a1469fc88d081d49349aa7" translate="yes" xml:space="preserve">
          <source>When the connection is no longer needed, the client and server applications should each close both sides of their respective connection. For &lt;code&gt;SSLSocket&lt;/code&gt; objects, for example, an application can call &lt;a href=&quot;../../../java/net/socket#shutdownOutput()&quot;&gt;&lt;code&gt;Socket.shutdownOutput()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../../java/io/outputstream#close()&quot;&gt;&lt;code&gt;OutputStream.close()&lt;/code&gt;&lt;/a&gt; for output strean close and call &lt;a href=&quot;../../../java/net/socket#shutdownInput()&quot;&gt;&lt;code&gt;Socket.shutdownInput()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../../java/io/inputstream#close()&quot;&gt;&lt;code&gt;InputStream.close()&lt;/code&gt;&lt;/a&gt; for input stream close. Note that in some cases, closing the input stream may depend on the peer's output stream being closed first. If the connection is not closed in an orderly manner (for example &lt;a href=&quot;../../../java/net/socket#shutdownInput()&quot;&gt;&lt;code&gt;Socket.shutdownInput()&lt;/code&gt;&lt;/a&gt; is called before the peer's write closure notification has been received), exceptions may be raised to indicate that an error has occurred. Once an &lt;code&gt;SSLSocket&lt;/code&gt; is closed, it is not reusable: a new &lt;code&gt;SSLSocket&lt;/code&gt; must be created.</source>
          <target state="translated">当不再需要连接时，客户端和服务器应用程序应分别关闭其各自连接的两端。例如，对于 &lt;code&gt;SSLSocket&lt;/code&gt; 对象，应用程序可以调用&lt;a href=&quot;../../../java/net/socket#shutdownOutput()&quot;&gt; &lt;code&gt;Socket.shutdownOutput()&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../../../java/io/outputstream#close()&quot;&gt; &lt;code&gt;OutputStream.close()&lt;/code&gt; &lt;/a&gt;来关闭输出，并调用&lt;a href=&quot;../../../java/net/socket#shutdownInput()&quot;&gt; &lt;code&gt;Socket.shutdownInput()&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../../../java/io/inputstream#close()&quot;&gt; &lt;code&gt;InputStream.close()&lt;/code&gt; &lt;/a&gt;来关闭输入流。注意，在某些情况下，关闭输入流可能取决于对等方的输出流首先被关闭。如果未按顺序关闭连接（例如&lt;a href=&quot;../../../java/net/socket#shutdownInput()&quot;&gt; &lt;code&gt;Socket.shutdownInput()&lt;/code&gt; &lt;/a&gt;在收到对等方的写关闭通知之前调用），可能会引发异常以指示发生了错误。一旦关闭 &lt;code&gt;SSLSocket&lt;/code&gt; ，它便不可重用：必须创建一个新的 &lt;code&gt;SSLSocket&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a0cd6246ef32e2e28cb6a34b88aea8b151567df6" translate="yes" xml:space="preserve">
          <source>When the context is no longer needed, the application should call &lt;a href=&quot;#dispose()&quot;&gt;&lt;code&gt;dispose&lt;/code&gt;&lt;/a&gt; to release any system resources the context may be using.</source>
          <target state="translated">当不再需要上下文时，应用程序应调用&lt;a href=&quot;#dispose()&quot;&gt; &lt;code&gt;dispose&lt;/code&gt; &lt;/a&gt;释放上下文可能正在使用的任何系统资源。</target>
        </trans-unit>
        <trans-unit id="1c9937e2f6e05020b636f955f2f392f42a8a5be9" translate="yes" xml:space="preserve">
          <source>When the datum at the head of the stream is an SQL &lt;code&gt;NULL&lt;/code&gt;, the method returns &lt;code&gt;null&lt;/code&gt;. If the datum is an SQL structured or distinct type, it determines the SQL type of the datum at the head of the stream. If the stream's type map has an entry for that SQL type, the driver constructs an object of the appropriate class and calls the method &lt;code&gt;SQLData.readSQL&lt;/code&gt; on that object, which reads additional data from the stream, using the protocol described for that method.</source>
          <target state="translated">当流的开头的数据为SQL &lt;code&gt;NULL&lt;/code&gt; 时，该方法返回 &lt;code&gt;null&lt;/code&gt; 。如果基准是SQL结构化或不同的类型，则它将确定流顶部的基准的SQL类型。如果流的类型映射具有该SQL类型的条目，则驱动程序将构造一个适当的类的对象，并对该对象调用 &lt;code&gt;SQLData.readSQL&lt;/code&gt; 方法，该对象将使用针对该方法描述的协议从该流中读取其他数据。</target>
        </trans-unit>
        <trans-unit id="1c57fa8db99fc971d583cc8742f486aed25eac72" translate="yes" xml:space="preserve">
          <source>When the datum at the head of the stream is an SQL &lt;code&gt;NULL&lt;/code&gt;, this method returns &lt;code&gt;null&lt;/code&gt;. If the datum is an SQL structured or distinct type with a custom mapping, this method determines the SQL type of the datum at the head of the stream, constructs an object of the appropriate class, and calls the method &lt;code&gt;SQLData.readSQL&lt;/code&gt; on that object. The &lt;code&gt;readSQL&lt;/code&gt; method then calls the appropriate &lt;code&gt;SQLInputImpl.readXXX&lt;/code&gt; methods to retrieve the attribute values from the stream.</source>
          <target state="translated">当流的开头的数据为SQL &lt;code&gt;NULL&lt;/code&gt; 时，此方法返回 &lt;code&gt;null&lt;/code&gt; 。如果数据是具有自定义映射的SQL结构化或不同类型的数据，则此方法确定流顶部的数据的SQL类型，构造适当类的对象，然后在该对象上调用方法 &lt;code&gt;SQLData.readSQL&lt;/code&gt; 。然后， &lt;code&gt;readSQL&lt;/code&gt; 方法调用适当的 &lt;code&gt;SQLInputImpl.readXXX&lt;/code&gt; 方法以从流中检索属性值。</target>
        </trans-unit>
        <trans-unit id="0207ee2dfd538e974d952ff6af0b2a657d033d63" translate="yes" xml:space="preserve">
          <source>When the dialog is shown, the specified file is selected. The kind of selection depends on the file existence, the dialog type, and the native platform. E.g., the file could be highlighted in the file list, or a file name editbox could be populated with the file name.</source>
          <target state="translated">当对话框显示时,指定的文件被选中。选择的方式取决于文件的存在、对话框的类型和本地平台。例如,文件可以在文件列表中高亮显示,或者在文件名编辑框中填入文件名。</target>
        </trans-unit>
        <trans-unit id="c397667a78f1a660562462490477701fa7482ccb" translate="yes" xml:space="preserve">
          <source>When the driver determines that the &lt;code&gt;setNetworkTimeout&lt;/code&gt; timeout value has expired, the JDBC driver marks the connection closed and releases any resources held by the connection.</source>
          <target state="translated">当驱动程序确定 &lt;code&gt;setNetworkTimeout&lt;/code&gt; 超时值已过期时，JDBC驱动程序会将连接标记为已关闭，并释放该连接保留的所有资源。</target>
        </trans-unit>
        <trans-unit id="4cd824f5c7e1568ccbcd115d44b4eb96a3accf69" translate="yes" xml:space="preserve">
          <source>When the environment property &quot;java.naming.factory.initial&quot; is non-null, the InitialContext constructor will attempt to create the initial context specified therein. At that time, the initial context factory involved might throw an exception if a problem is encountered. However, it is provider implementation-dependent when it verifies and indicates to the users of the initial context any environment property- or connection- related problems. It can do so lazily--delaying until an operation is performed on the context, or eagerly, at the time the context is constructed.</source>
          <target state="translated">当环境属性 &quot;java.naming.factory.initial &quot;为非空时,InitialContext构造函数将尝试创建其中指定的初始上下文。此时,如果遇到问题,涉及的初始上下文工厂可能会抛出一个异常。然而,当它验证并向初始上下文的用户指示任何环境属性或连接相关的问题时,它是依赖于提供者实现的。它可以懒惰地这样做--推迟到对上下文进行操作,也可以急切地在上下文被构造时这样做。</target>
        </trans-unit>
        <trans-unit id="5e1fbcb7e24cac03595809d83a43116184df4d35" translate="yes" xml:space="preserve">
          <source>When the feature is &lt;code&gt;false&lt;/code&gt;, the implementation will processing XML according to the XML specifications without regard to possible implementation limits.</source>
          <target state="translated">当此功能为 &lt;code&gt;false&lt;/code&gt; 时，实现将根据XML规范处理XML，而不考虑可能的实现限制。</target>
        </trans-unit>
        <trans-unit id="09c83d44797e06cf825594da62f38b3618a765cb" translate="yes" xml:space="preserve">
          <source>When the file system uses an ACL model that differs from the NFSv4 defined ACL model, then this method returns an ACL that is the translation of the ACL to the NFSv4 ACL model.</source>
          <target state="translated">当文件系统使用的ACL模型与NFSv4定义的ACL模型不同时,那么这个方法返回的ACL就是该ACL向NFSv4 ACL模型的翻译。</target>
        </trans-unit>
        <trans-unit id="34c8ca9cd568392c4eb67ef03c9038a10b794d59" translate="yes" xml:space="preserve">
          <source>When the initial context is constructed, its environment is initialized with properties defined in the environment parameter passed to the constructor, and in any &lt;a href=&quot;context#RESOURCEFILES&quot; id=&quot;ENVIRONMENT&quot;&gt;application resource files&lt;/a&gt;. In addition, a small number of standard JNDI properties may be specified as system properties or as applet parameters (through the use of &lt;a href=&quot;context#APPLET&quot;&gt;&lt;code&gt;Context.APPLET&lt;/code&gt;&lt;/a&gt;). These special properties are listed in the field detail sections of the &lt;a href=&quot;context#field_detail&quot;&gt;&lt;code&gt;Context&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;ldap/ldapcontext#field_detail&quot;&gt;&lt;code&gt;LdapContext&lt;/code&gt;&lt;/a&gt; interface documentation.</source>
          <target state="translated">构造初始上下文时，将使用在传递给构造函数的环境参数以及所有&lt;a href=&quot;context#RESOURCEFILES&quot; id=&quot;ENVIRONMENT&quot;&gt;应用程序资源文件中&lt;/a&gt;定义的属性来初始化其环境。另外，可以将少量标准JNDI属性指定为系统属性或applet参数（通过使用&lt;a href=&quot;context#APPLET&quot;&gt; &lt;code&gt;Context.APPLET&lt;/code&gt; &lt;/a&gt;）。这些特殊属性在&lt;a href=&quot;context#field_detail&quot;&gt; &lt;code&gt;Context&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;ldap/ldapcontext#field_detail&quot;&gt; &lt;code&gt;LdapContext&lt;/code&gt; &lt;/a&gt;接口文档的字段详细信息部分中列出。</target>
        </trans-unit>
        <trans-unit id="9f2e2ab8bd29748019ef4bf990564b30618f21a2" translate="yes" xml:space="preserve">
          <source>When the initial context is constructed, its environment is initialized with properties defined in the environment parameter passed to the constructor, and in any &lt;a href=&quot;context#RESOURCEFILES&quot;&gt;application resource files&lt;/a&gt;.</source>
          <target state="translated">构造初始上下文时，将使用在传递给构造函数的环境参数以及任何&lt;a href=&quot;context#RESOURCEFILES&quot;&gt;应用程序资源文件中&lt;/a&gt;定义的属性来初始化其环境。</target>
        </trans-unit>
        <trans-unit id="696a039c384cd3258c09a0ffb67d7220e4c8e54b" translate="yes" xml:space="preserve">
          <source>When the intern method is invoked, if the pool already contains a string equal to this &lt;code&gt;String&lt;/code&gt; object as determined by the &lt;a href=&quot;#equals(java.lang.Object)&quot;&gt;&lt;code&gt;equals(Object)&lt;/code&gt;&lt;/a&gt; method, then the string from the pool is returned. Otherwise, this &lt;code&gt;String&lt;/code&gt; object is added to the pool and a reference to this &lt;code&gt;String&lt;/code&gt; object is returned.</source>
          <target state="translated">调用intern方法时，如果池已经包含&lt;a href=&quot;#equals(java.lang.Object)&quot;&gt; &lt;code&gt;equals(Object)&lt;/code&gt; &lt;/a&gt;方法确定的此 &lt;code&gt;String&lt;/code&gt; 对象的字符串，则返回池中的字符串。否则，将此 &lt;code&gt;String&lt;/code&gt; 对象添加到池中，并返回对此 &lt;code&gt;String&lt;/code&gt; 对象的引用。</target>
        </trans-unit>
        <trans-unit id="3af901ecd46db6d3c503ad63c889dcb1df5223cb" translate="yes" xml:space="preserve">
          <source>When the intern method is invoked, if the pool already contains a string equal to this &lt;code&gt;String&lt;/code&gt; object as determined by the &lt;a href=&quot;string#equals-java.lang.Object-&quot;&gt;&lt;code&gt;equals(Object)&lt;/code&gt;&lt;/a&gt; method, then the string from the pool is returned. Otherwise, this &lt;code&gt;String&lt;/code&gt; object is added to the pool and a reference to this &lt;code&gt;String&lt;/code&gt; object is returned.</source>
          <target state="translated">调用intern方法时，如果池已经包含&lt;a href=&quot;string#equals-java.lang.Object-&quot;&gt; &lt;code&gt;equals(Object)&lt;/code&gt; &lt;/a&gt;方法确定的此 &lt;code&gt;String&lt;/code&gt; 对象的字符串，则返回池中的字符串。否则，将此 &lt;code&gt;String&lt;/code&gt; 对象添加到池中，并返回对此 &lt;code&gt;String&lt;/code&gt; 对象的引用。</target>
        </trans-unit>
        <trans-unit id="f8bbc3f973b7168a4616c7de9f75c0600151427a" translate="yes" xml:space="preserve">
          <source>When the job is in the &lt;code&gt;PROCESSING&lt;/code&gt; state, the entire job state includes the detailed status represented in the printer's &lt;a href=&quot;printerstate&quot;&gt;&lt;code&gt;PrinterState&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;printerstatereasons&quot;&gt;&lt;code&gt;PrinterStateReasons&lt;/code&gt;&lt;/a&gt; attributes.</source>
          <target state="translated">当作业处于&amp;ldquo;正在 &lt;code&gt;PROCESSING&lt;/code&gt; 状态时，整个作业状态包括打印机的&lt;a href=&quot;printerstate&quot;&gt; &lt;code&gt;PrinterState&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;printerstatereasons&quot;&gt; &lt;code&gt;PrinterStateReasons&lt;/code&gt; &lt;/a&gt;属性中表示的详细状态。</target>
        </trans-unit>
        <trans-unit id="1a58835a2387f608fd8e7fa6effa626edf3d2325" translate="yes" xml:space="preserve">
          <source>When the job is in the PROCESSING state, the entire job state includes the detailed status represented in the printer's &lt;a href=&quot;printerstate&quot;&gt;&lt;code&gt;PrinterState&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;printerstatereasons&quot;&gt;&lt;code&gt;PrinterStateReasons&lt;/code&gt;&lt;/a&gt; attributes.</source>
          <target state="translated">当作业处于&amp;ldquo;正在处理&amp;rdquo;状态时，整个作业状态包括打印机的&lt;a href=&quot;printerstate&quot;&gt; &lt;code&gt;PrinterState&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;printerstatereasons&quot;&gt; &lt;code&gt;PrinterStateReasons&lt;/code&gt; &lt;/a&gt;属性中表示的详细状态。</target>
        </trans-unit>
        <trans-unit id="66a9921b5b8623505ad852c1a7dd9d532fe13cfc" translate="yes" xml:space="preserve">
          <source>When the keepalive option is set for a TCP socket and no data has been exchanged across the socket in either direction for 2 hours (NOTE: the actual value is implementation dependent), TCP automatically sends a keepalive probe to the peer.</source>
          <target state="translated">当为一个TCP套接字设置了keepalive选项,并且在2小时内没有在套接字的任何一个方向上交换数据时(注意:实际值取决于实现),TCP会自动向对等体发送一个keepalive探针。</target>
        </trans-unit>
        <trans-unit id="bb6061dea9059e4de3096353b5e5aab377ef19b3" translate="yes" xml:space="preserve">
          <source>When the keepalive option is set for a TCP socket and no data has been exchanged across the socket in either direction for 2 hours (NOTE: the actual value is implementation dependent), TCP automatically sends a keepalive probe to the peer. This probe is a TCP segment to which the peer must respond. One of three responses is expected: 1. The peer responds with the expected ACK. The application is not notified (since everything is OK). TCP will send another probe following another 2 hours of inactivity. 2. The peer responds with an RST, which tells the local TCP that the peer host has crashed and rebooted. The socket is closed. 3. There is no response from the peer. The socket is closed. The purpose of this option is to detect if the peer host crashes. Valid only for TCP socket: SocketImpl</source>
          <target state="translated">当为一个TCP套接字设置了keepalive选项,并且在2小时内没有在套接字的任何一个方向上交换数据时(注意:实际值取决于实现),TCP会自动向对等体发送一个keepalive探针。这个探针是对等体必须响应的TCP段。三种响应中的一种是预期的:1.对等体用预期的ACK响应。应用程序没有得到通知(因为一切正常)。TCP将在另一个2小时的不活动之后发送另一个探针。2.对等体用RST响应,它告诉本地TCP,对等体主机已经崩溃并重新启动。套接字被关闭。3.对等体没有响应。该套接字被关闭。这个选项的目的是检测对等主机是否崩溃。仅对TCP套接字有效。SocketImpl</target>
        </trans-unit>
        <trans-unit id="866732f7e1f1ba8888b09a311866448987c8a922" translate="yes" xml:space="preserve">
          <source>When the languageTag argument contains an extlang subtag, the first such subtag is used as the language, and the primary language subtag and other extlang subtags are ignored:</source>
          <target state="translated">当languageTag参数包含一个extlang子标签时,第一个这样的子标签被用作语言,而主语言子标签和其他extlang子标签被忽略。</target>
        </trans-unit>
        <trans-unit id="ed36ba14c7223ab42eda132f49f243999c7fe2b2" translate="yes" xml:space="preserve">
          <source>When the listener is notified of an event, the listener may in invoked in a thread other than the one in which &lt;code&gt;addNamingListener()&lt;/code&gt; is executed. Care must be taken when multiple threads are accessing the same &lt;code&gt;EventContext&lt;/code&gt; concurrently. See the &lt;a href=&quot;package-summary#THREADING&quot;&gt;package description&lt;/a&gt; for more information on threading issues.</source>
          <target state="translated">当侦听器收到事件通知时，侦听器可以在不同于执行 &lt;code&gt;addNamingListener()&lt;/code&gt; 的线程中调用。当多个线程同时访问同一 &lt;code&gt;EventContext&lt;/code&gt; 时，必须小心。有关线程问题的更多信息，请参见&lt;a href=&quot;package-summary#THREADING&quot;&gt;软件包描述&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0d9cde70e42ddbed9e83b6ac5078af513cb772df" translate="yes" xml:space="preserve">
          <source>When the locale has neither script nor extensions, the result is the same as in Java 6 and prior.</source>
          <target state="translated">当locale既没有脚本也没有扩展时,其结果与Java 6及以前的版本相同。</target>
        </trans-unit>
        <trans-unit id="1b1fe4c6f5b74a16eccbbff7c89d6b2a2b6653a7" translate="yes" xml:space="preserve">
          <source>When the look and feel is changed, &lt;code&gt;UIManager&lt;/code&gt; alters only the look and feel defaults; the developer and system defaults are not altered by the &lt;code&gt;UIManager&lt;/code&gt; in any way.</source>
          <target state="translated">更改外观时， &lt;code&gt;UIManager&lt;/code&gt; 仅更改外观默认值；否则，默认设置为默认值。 &lt;code&gt;UIManager&lt;/code&gt; 不会以任何方式更改开发者和系统的默认值。</target>
        </trans-unit>
        <trans-unit id="93d0b3309dfdbd682000d72cebceb5604b73431a" translate="yes" xml:space="preserve">
          <source>When the loop is called, the loop input values are saved in locals, to be passed to every clause function. These locals are loop invariant.</source>
          <target state="translated">当循环被调用时,循环的输入值被保存在locals中,传递给每个子句函数。这些locals是循环不变的。</target>
        </trans-unit>
        <trans-unit id="007b0e1775e7a297cd0ad9889941a2a02fa5ed07" translate="yes" xml:space="preserve">
          <source>When the method &lt;code&gt;acceptChanges&lt;/code&gt; encounters conflicts, the &lt;code&gt;SyncProvider&lt;/code&gt; object creates a &lt;code&gt;SyncProviderException&lt;/code&gt; object and sets it with the new &lt;code&gt;SyncResolver&lt;/code&gt; object. The method &lt;code&gt;acceptChanges&lt;/code&gt; will throw this exception, which the application can then catch and use to retrieve the &lt;code&gt;SyncResolver&lt;/code&gt; object it contains. The following code snippet uses the &lt;code&gt;SyncProviderException&lt;/code&gt; method &lt;code&gt;getSyncResolver&lt;/code&gt; to get the &lt;code&gt;SyncResolver&lt;/code&gt; object</source>
          <target state="translated">当方法 &lt;code&gt;acceptChanges&lt;/code&gt; 遇到冲突时， &lt;code&gt;SyncProvider&lt;/code&gt; 对象将创建一个 &lt;code&gt;SyncProviderException&lt;/code&gt; 对象，并使用新的 &lt;code&gt;SyncResolver&lt;/code&gt; 对象对其进行设置。方法 &lt;code&gt;acceptChanges&lt;/code&gt; 将抛出此异常，然后应用程序可以捕获该异常，并使用该异常来检索它包含的 &lt;code&gt;SyncResolver&lt;/code&gt; 对象。以下代码段使用 &lt;code&gt;SyncProviderException&lt;/code&gt; 方法 &lt;code&gt;getSyncResolver&lt;/code&gt; 获取 &lt;code&gt;SyncResolver&lt;/code&gt; 对象</target>
        </trans-unit>
        <trans-unit id="761ffe43252810926439462ad9f307e7fa5b5d7e" translate="yes" xml:space="preserve">
          <source>When the method &lt;code&gt;acceptChanges&lt;/code&gt; executes successfully, in addition to writing changes to the data source, it makes the values in the current row be the values in the original row.</source>
          <target state="translated">当方法 &lt;code&gt;acceptChanges&lt;/code&gt; 成功执行后，除了将更改写入数据源之外，它还使当前行中的值成为原始行中的值。</target>
        </trans-unit>
        <trans-unit id="eacefaf622ae1cba296aa64de13b41c77b34ebc2" translate="yes" xml:space="preserve">
          <source>When the method &lt;code&gt;acceptChanges&lt;/code&gt; is executed, the &lt;code&gt;CachedRowSet&lt;/code&gt; object's writer, a &lt;code&gt;RowSetWriterImpl&lt;/code&gt; object, is called behind the scenes to write the changes made to the rowset to the underlying data source. The writer is implemented to make a connection to the data source and write updates to it.</source>
          <target state="translated">执行方法 &lt;code&gt;acceptChanges&lt;/code&gt; 时，将在 &lt;code&gt;RowSetWriterImpl&lt;/code&gt; &lt;code&gt;CachedRowSet&lt;/code&gt; 对象的编写器RowSetWriterImpl对象，以将对行集所做的更改写入基础数据源。编写器实现为与数据源建立连接并向其写入更新。</target>
        </trans-unit>
        <trans-unit id="f0a87c8c83eb227ae747569302b9215bbb8f49c6" translate="yes" xml:space="preserve">
          <source>When the method &lt;code&gt;getConnection&lt;/code&gt; is called, the &lt;code&gt;DriverManager&lt;/code&gt; will attempt to locate a suitable driver from amongst those loaded at initialization and those loaded explicitly using the same class loader as the current application.</source>
          <target state="translated">调用方法 &lt;code&gt;getConnection&lt;/code&gt; 时， &lt;code&gt;DriverManager&lt;/code&gt; 将尝试从初始化时加载的驱动程序和使用与当前应用程序相同的类加载器显式加载的驱动程序中找到合适的驱动程序。</target>
        </trans-unit>
        <trans-unit id="64b1a414ef040f7d4a015e56bd76285cd50c4d87" translate="yes" xml:space="preserve">
          <source>When the method &lt;code&gt;getObject&lt;/code&gt; is called with an object of a class implementing the interface &lt;code&gt;SQLData&lt;/code&gt;, the JDBC driver calls the method &lt;code&gt;SQLData.getSQLType&lt;/code&gt; to determine the SQL type of the UDT being custom mapped. The driver creates an instance of &lt;code&gt;SQLInputImpl&lt;/code&gt;, populating it with the attributes of the UDT. The driver then passes the input stream to the method &lt;code&gt;SQLData.readSQL&lt;/code&gt;, which in turn calls the &lt;code&gt;SQLInputImpl&lt;/code&gt; reader methods to read the attributes from the input stream.</source>
          <target state="translated">当使用实现接口 &lt;code&gt;SQLData&lt;/code&gt; 的类的对象调用方法 &lt;code&gt;getObject&lt;/code&gt; 时，JDBC驱动程序将调用方法 &lt;code&gt;SQLData.getSQLType&lt;/code&gt; 以确定要自定义映射的UDT的SQL类型。驱动程序创建一个 &lt;code&gt;SQLInputImpl&lt;/code&gt; 实例，并使用UDT的属性填充它。然后，驱动程序将输入流传 &lt;code&gt;SQLData.readSQL&lt;/code&gt; 方法SQLData.readSQL，该方法进而调用 &lt;code&gt;SQLInputImpl&lt;/code&gt; 阅读器方法以从输入流中读取属性。</target>
        </trans-unit>
        <trans-unit id="fc2f4707a729deed0932994b739ae33c7d74de2f" translate="yes" xml:space="preserve">
          <source>When the method &lt;code&gt;getObject&lt;/code&gt; is called with an object of a class implementing the interface &lt;code&gt;SQLData&lt;/code&gt;, the JDBC driver calls the method &lt;code&gt;SQLData.getSQLType&lt;/code&gt; to determine the SQL type of the user-defined type (UDT) being custom mapped. The driver creates an instance of &lt;code&gt;SQLInput&lt;/code&gt;, populating it with the attributes of the UDT. The driver then passes the input stream to the method &lt;code&gt;SQLData.readSQL&lt;/code&gt;, which in turn calls the &lt;code&gt;SQLInput&lt;/code&gt; reader methods in its implementation for reading the attributes from the input stream.</source>
          <target state="translated">当使用实现接口 &lt;code&gt;SQLData&lt;/code&gt; 的类的对象调用方法 &lt;code&gt;getObject&lt;/code&gt; 时，JDBC驱动程序将调用方法 &lt;code&gt;SQLData.getSQLType&lt;/code&gt; 以确定要自定义映射的用户定义类型（UDT）的SQL类型。驱动程序创建一个 &lt;code&gt;SQLInput&lt;/code&gt; 实例，并使用UDT的属性填充它。然后，驱动程序将输入流传 &lt;code&gt;SQLData.readSQL&lt;/code&gt; 方法SQLData.readSQL，该方法进而在其实现中调用 &lt;code&gt;SQLInput&lt;/code&gt; reader方法，以从输入流中读取属性。</target>
        </trans-unit>
        <trans-unit id="a7076acb7964a150cbcde4cd84fa0a6df2b7d477" translate="yes" xml:space="preserve">
          <source>When the node being renamed is an &lt;code&gt;Attr&lt;/code&gt; that is attached to an &lt;code&gt;Element&lt;/code&gt;, the node is first removed from the &lt;code&gt;Element&lt;/code&gt; attributes map. Then, once renamed, either by modifying the existing node or creating a new one as described above, it is put back.</source>
          <target state="translated">当重命名的节点是附加到 &lt;code&gt;Element&lt;/code&gt; 的 &lt;code&gt;Attr&lt;/code&gt; 时，首先从 &lt;code&gt;Element&lt;/code&gt; 属性映射中删除该节点。然后，一旦重命名，要么通过修改现有节点，要么如上所述创建一个新节点，将其放回原处。</target>
        </trans-unit>
        <trans-unit id="c89febf12ab0e3c4977c50a6e144102ca2b758a1" translate="yes" xml:space="preserve">
          <source>When the node being renamed is an &lt;code&gt;Element&lt;/code&gt; only the specified attributes are moved, default attributes originated from the DTD are updated according to the new element name. In addition, the implementation may update default attributes from other schemas. Applications should use &lt;code&gt;Document.normalizeDocument()&lt;/code&gt; to guarantee these attributes are up-to-date.</source>
          <target state="translated">当要重命名的节点是 &lt;code&gt;Element&lt;/code&gt; 时,仅移动指定的属性，源自DTD的默认属性将根据新的元素名称进行更新。另外，该实现可以从其他架构更新默认属性。应用程序应使用 &lt;code&gt;Document.normalizeDocument()&lt;/code&gt; 来确保这些属性是最新的。</target>
        </trans-unit>
        <trans-unit id="b3f2c7cd9cb9265342d2a6fc6218dfca1e62cee5" translate="yes" xml:space="preserve">
          <source>When the output method is &quot;xml&quot;, the version value specifies the version of XML to be used for outputting the result tree. The default value for the xml output method is 1.0. When the output method is &quot;html&quot;, the version value indicates the version of the HTML. The default value for the xml output method is 4.0, which specifies that the result should be output as HTML conforming to the HTML 4.0 Recommendation [HTML]. If the output method is &quot;text&quot;, the version property is ignored.</source>
          <target state="translated">当输出方法为 &quot;xml &quot;时,版本值指定用于输出结果树的XML版本。xml输出方法的默认值是1.0。当输出方法为 &quot;html &quot;时,版本值表示HTML的版本。xml输出方法的默认值是4.0,它指定结果应以符合HTML 4.0建议[HTML]的HTML输出。如果输出方式为 &quot;text&quot;,则会忽略版本属性。</target>
        </trans-unit>
        <trans-unit id="f8a5f29e1d264a025ea5669456267893f0f08fec" translate="yes" xml:space="preserve">
          <source>When the parse fails, use ParsePosition.getErrorIndex() to find out where in the string the parsing failed. The returned error index is the starting offset of the sub-patterns that the string is comparing with. For example, if the parsing string &quot;AAA {0} BBB&quot; is comparing against the pattern &quot;AAD {0} BBB&quot;, the error index is 0. When an error occurs, the call to this method will return null. If the source is null, return an empty array.</source>
          <target state="translated">当解析失败时,使用ParsePosition.getErrorIndex()找出字符串中哪里解析失败。返回的错误索引是字符串所比较的子模式的起始偏移量。例如,如果解析字符串 &quot;AAA {0}BBBB &quot;与模式 &quot;AAD {0}BBBB &quot;进行比较,则错误索引为0。 当发生错误时,对该方法的调用将返回null。如果源为空,则返回一个空数组。</target>
        </trans-unit>
        <trans-unit id="72cc5d6ed97f5b594ccc044348c9065ad0416c01" translate="yes" xml:space="preserve">
          <source>When the parser encounters a word token that has the format of a double precision floating-point number, it treats the token as a number rather than a word, by setting the &lt;code&gt;ttype&lt;/code&gt; field to the value &lt;code&gt;TT_NUMBER&lt;/code&gt; and putting the numeric value of the token into the &lt;code&gt;nval&lt;/code&gt; field.</source>
          <target state="translated">当解析器遇到具有双精度浮点数格式的单词标记时，它将 &lt;code&gt;ttype&lt;/code&gt; 字段设置为值 &lt;code&gt;TT_NUMBER&lt;/code&gt; 并将该标记的数值放入该 &lt;code&gt;nval&lt;/code&gt; 场。</target>
        </trans-unit>
        <trans-unit id="78bae3a9fd2477af6b829cef33248071afc46dc2" translate="yes" xml:space="preserve">
          <source>When the peer was not able to identify itself (for example; no certificate, the particular cipher suite being used does not support authentication, or no peer authentication was established during SSL handshaking) this exception is thrown.</source>
          <target state="translated">当对等体无法识别自己的身份时(例如:没有证书,所使用的特定密码套件不支持身份验证,或者在SSL握手期间没有建立对等体身份验证),就会抛出这个异常。</target>
        </trans-unit>
        <trans-unit id="e0488e20002eb573a021336f9689d0df5866d2de" translate="yes" xml:space="preserve">
          <source>When the precision setting is not 0, the rules of &lt;code&gt;BigDecimal&lt;/code&gt; arithmetic are broadly compatible with selected modes of operation of the arithmetic defined in ANSI X3.274-1996 and ANSI X3.274-1996/AM 1-2000 (section 7.4). Unlike those standards, &lt;code&gt;BigDecimal&lt;/code&gt; includes many rounding modes, which were mandatory for division in &lt;code&gt;BigDecimal&lt;/code&gt; releases prior to 5. Any conflicts between these ANSI standards and the &lt;code&gt;BigDecimal&lt;/code&gt; specification are resolved in favor of &lt;code&gt;BigDecimal&lt;/code&gt;.</source>
          <target state="translated">当精度设置不为0时， &lt;code&gt;BigDecimal&lt;/code&gt; 算术规则与ANSI X3.274-1996和ANSI X3.274-1996 / AM 1-2000（第7.4节）中定义的算术的选定操作模式广泛兼容。与上述标准不同， &lt;code&gt;BigDecimal&lt;/code&gt; 的包括多种舍入模式，这是强制性的除法中 &lt;code&gt;BigDecimal&lt;/code&gt; 释放之前5.这些ANSI标准和之间的任何冲突 &lt;code&gt;BigDecimal&lt;/code&gt; 规格有利于得到解决 &lt;code&gt;BigDecimal&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5843d706baf770064c5e4bf338f1a63714ad7a1d" translate="yes" xml:space="preserve">
          <source>When the representation class is a URL, the print service itself accesses and downloads the document directly from its URL address, without involving the client. The service may be some form of network print service which is executing in a different environment. This means you should not use a URL print data flavor to print a document at a restricted URL that the client can see but the printer cannot see. This also means you should not use a URL print data flavor to print a document stored in a local file that is not available at a URL accessible independently of the client. For example, a file that is not served up by an HTTP server or FTP server. To print such documents, let the client open an input stream on the URL or file and use an input stream data flavor.</source>
          <target state="translated">当表示类是URL时,打印服务本身直接从其URL地址访问和下载文档,而不涉及客户端。该服务可能是某种形式的网络打印服务,它在不同的环境中执行。这意味着您不应该使用 URL 打印数据功能在客户端可以看到但打印机无法看到的受限 URL 上打印文档。这也意味着您不应该使用 URL 打印数据风味来打印存储在本地文件中的文档,而该文档在客户端独立访问的 URL 中不可用。例如,不是由HTTP服务器或FTP服务器提供的文件。要打印这类文档,请让客户端在URL或文件上打开一个输入流,并使用输入流数据风味。</target>
        </trans-unit>
        <trans-unit id="c50fdf0c297e395312b19932d6d698d6fe9410ab" translate="yes" xml:space="preserve">
          <source>When the returned &lt;code&gt;VarHandle&lt;/code&gt; is invoked, the array reference and array index are checked. A &lt;code&gt;NullPointerException&lt;/code&gt; will be thrown if the array reference is &lt;code&gt;null&lt;/code&gt; and an &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt; will be thrown if the index is negative or if it is greater than or equal to the length of the array.</source>
          <target state="translated">调用返回的 &lt;code&gt;VarHandle&lt;/code&gt; 时，将检查数组引用和数组索引。甲 &lt;code&gt;NullPointerException&lt;/code&gt; 将如果数组引用是被抛出 &lt;code&gt;null&lt;/code&gt; 和 &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt; 异常如果索引是负将被抛出，或者如果它是大于或等于所述阵列的长度。</target>
        </trans-unit>
        <trans-unit id="f2890f46cc50adad6b16a722b172030e24df5540" translate="yes" xml:space="preserve">
          <source>When the returned method handle is invoked, the array reference and array index are checked. A &lt;code&gt;NullPointerException&lt;/code&gt; will be thrown if the array reference is &lt;code&gt;null&lt;/code&gt; and an &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt; will be thrown if the index is negative or if it is greater than or equal to the length of the array.</source>
          <target state="translated">调用返回的方法句柄时，将检查数组引用和数组索引。甲 &lt;code&gt;NullPointerException&lt;/code&gt; 将如果数组引用是被抛出 &lt;code&gt;null&lt;/code&gt; 和 &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt; 异常如果索引是负将被抛出，或者如果它是大于或等于所述阵列的长度。</target>
        </trans-unit>
        <trans-unit id="65a8d19d4c40ff2e75d5423b676fb0c582abe879" translate="yes" xml:space="preserve">
          <source>When the selection is changed, &lt;code&gt;setValue&lt;/code&gt; is invoked, which generates a &lt;code&gt;PropertyChangeEvent&lt;/code&gt;.</source>
          <target state="translated">更改选择后，将调用 &lt;code&gt;setValue&lt;/code&gt; ，这将生成一个 &lt;code&gt;PropertyChangeEvent&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="34f9e72cd7ab06f0430202d13d67e17e3e697217" translate="yes" xml:space="preserve">
          <source>When the set of diagnostic commands currently supported by the Java Virtual Machine is modified, the &lt;code&gt;DiagnosticCommandMBean&lt;/code&gt; emits a &lt;a href=&quot;../../../../java.management/javax/management/notification&quot;&gt;&lt;code&gt;Notification&lt;/code&gt;&lt;/a&gt; with a &lt;a href=&quot;../../../../java.management/javax/management/notification#getType()&quot;&gt;type&lt;/a&gt; of &lt;a href=&quot;../../../../java.management/javax/management/mbeaninfo#info-changed&quot;&gt; &lt;code&gt;&quot;jmx.mbean.info.changed&quot;&lt;/code&gt;&lt;/a&gt; and a &lt;a href=&quot;../../../../java.management/javax/management/notification#getUserData()&quot;&gt;userData&lt;/a&gt; that is the new &lt;code&gt;MBeanInfo&lt;/code&gt;.</source>
          <target state="translated">修改Java虚拟机当前支持的诊断命令集后， &lt;code&gt;DiagnosticCommandMBean&lt;/code&gt; 会发出一个&lt;a href=&quot;../../../../java.management/javax/management/notification#getType()&quot;&gt;类型&lt;/a&gt;为&lt;a href=&quot;../../../../java.management/javax/management/mbeaninfo#info-changed&quot;&gt; &lt;code&gt;&quot;jmx.mbean.info.changed&quot;&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;../../../../java.management/javax/management/notification&quot;&gt; &lt;code&gt;Notification&lt;/code&gt; &lt;/a&gt;和一个新的 &lt;code&gt;MBeanInfo&lt;/code&gt; &lt;a href=&quot;../../../../java.management/javax/management/notification#getUserData()&quot;&gt;userData&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="750413507a9e50e7dd4ee48691a0e0e569f733c7" translate="yes" xml:space="preserve">
          <source>When the socket is created the &lt;a href=&quot;datagramsocket#setReuseAddress(boolean)&quot;&gt;&lt;code&gt;DatagramSocket.setReuseAddress(boolean)&lt;/code&gt;&lt;/a&gt; method is called to enable the SO_REUSEADDR socket option.</source>
          <target state="translated">创建套接字后，将调用&lt;a href=&quot;datagramsocket#setReuseAddress(boolean)&quot;&gt; &lt;code&gt;DatagramSocket.setReuseAddress(boolean)&lt;/code&gt; &lt;/a&gt;方法以启用SO_REUSEADDR套接字选项。</target>
        </trans-unit>
        <trans-unit id="c97f96f2fd46091c0f2026852faa74a91e5bd86f" translate="yes" xml:space="preserve">
          <source>When the socket is created the &lt;a href=&quot;datagramsocket#setReuseAddress-boolean-&quot;&gt;&lt;code&gt;DatagramSocket.setReuseAddress(boolean)&lt;/code&gt;&lt;/a&gt; method is called to enable the SO_REUSEADDR socket option.</source>
          <target state="translated">创建套接字后，将调用&lt;a href=&quot;datagramsocket#setReuseAddress-boolean-&quot;&gt; &lt;code&gt;DatagramSocket.setReuseAddress(boolean)&lt;/code&gt; &lt;/a&gt;方法以启用SO_REUSEADDR套接字选项。</target>
        </trans-unit>
        <trans-unit id="23d0fb38ca6d6e11edcf3b7e63aa87f6a871583e" translate="yes" xml:space="preserve">
          <source>When the specified date-time arrives, the printer must remove the &lt;a href=&quot;jobstatereason&quot;&gt;&lt;code&gt;JobStateReason&lt;/code&gt;&lt;/a&gt; value of &lt;code&gt;JOB_HOLD_UNTIL_SPECIFIED&lt;/code&gt; from the job's &lt;a href=&quot;jobstatereasons&quot;&gt;&lt;code&gt;JobStateReasons&lt;/code&gt;&lt;/a&gt; attribute, if present. If there are no other job state reasons that keep the job in the &lt;code&gt;PENDING_HELD&lt;/code&gt; state, the printer must consider the job as a candidate for processing by moving the job to the PENDING state.</source>
          <target state="translated">当指定的日期时间到来时，打印机必须从作业的&lt;a href=&quot;jobstatereasons&quot;&gt; &lt;code&gt;JobStateReasons&lt;/code&gt; &lt;/a&gt;属性（如果存在）中删除 &lt;code&gt;JOB_HOLD_UNTIL_SPECIFIED&lt;/code&gt; 的&lt;a href=&quot;jobstatereason&quot;&gt; &lt;code&gt;JobStateReason&lt;/code&gt; &lt;/a&gt;值。如果没有其他作业状态原因使作业保持在 &lt;code&gt;PENDING_HELD&lt;/code&gt; 状态，则打印机必须通过将作业移到PENDING状态来将其视为要处理的候选对象。</target>
        </trans-unit>
        <trans-unit id="5705af97d2330caf062737553687cb90dd63be9e" translate="yes" xml:space="preserve">
          <source>When the specified date-time arrives, the printer must remove the &lt;a href=&quot;jobstatereason&quot;&gt;&lt;code&gt;JobStateReason&lt;/code&gt;&lt;/a&gt; value of JOB_HOLD_UNTIL_SPECIFIED from the job's &lt;a href=&quot;jobstatereasons&quot;&gt;&lt;code&gt;JobStateReasons&lt;/code&gt;&lt;/a&gt; attribute, if present. If there are no other job state reasons that keep the job in the PENDING_HELD state, the printer must consider the job as a candidate for processing by moving the job to the PENDING state.</source>
          <target state="translated">当指定的日期时间到来时，打印机必须从作业的&lt;a href=&quot;jobstatereasons&quot;&gt; &lt;code&gt;JobStateReasons&lt;/code&gt; &lt;/a&gt;属性（如果存在）中删除JOB_HOLD_UNTIL_SPECIFIED 的&lt;a href=&quot;jobstatereason&quot;&gt; &lt;code&gt;JobStateReason&lt;/code&gt; &lt;/a&gt;值。如果没有其他作业状态原因使作业保持在PENDING_HELD状态，则打印机必须通过将作业移至PENDING状态将作业视为要处理的候选对象。</target>
        </trans-unit>
        <trans-unit id="88645d98095c743d1978459bbe537d54c96def54" translate="yes" xml:space="preserve">
          <source>When the specified provider is removed, all providers located at a position greater than where the specified provider was are shifted down one position (towards the head of the list of installed providers).</source>
          <target state="translated">当指定的供应商被删除时,位于比指定供应商位置更高的位置的所有供应商都会下移一个位置(朝向已安装供应商列表的头部)。</target>
        </trans-unit>
        <trans-unit id="a42df38aa359f6593f2ef17a8352c58477850724" translate="yes" xml:space="preserve">
          <source>When the syntax is &quot;&lt;code&gt;glob&lt;/code&gt;&quot; then the &lt;code&gt;String&lt;/code&gt; representation of the path is matched using a limited pattern language that resembles regular expressions but with a simpler syntax. For example:</source>
          <target state="translated">当语法为&amp;ldquo; &lt;code&gt;glob&lt;/code&gt; &amp;rdquo;时，将使用类似于正则表达式但语法更简单的有限模式语言来匹配路径的 &lt;code&gt;String&lt;/code&gt; 表示形式。例如：</target>
        </trans-unit>
        <trans-unit id="a34d7bcd42ea49862772510bb9b109c7b63aa486" translate="yes" xml:space="preserve">
          <source>When the syntax is &quot;&lt;code&gt;regex&lt;/code&gt;&quot; then the pattern component is a regular expression as defined by the &lt;a href=&quot;../../util/regex/pattern&quot;&gt;&lt;code&gt;Pattern&lt;/code&gt;&lt;/a&gt; class.</source>
          <target state="translated">当语法为&amp;ldquo; &lt;code&gt;regex&lt;/code&gt; &amp;rdquo;时，模式组件是由&lt;a href=&quot;../../util/regex/pattern&quot;&gt; &lt;code&gt;Pattern&lt;/code&gt; &lt;/a&gt;类定义的正则表达式。</target>
        </trans-unit>
        <trans-unit id="846a62fdfe658618e67bb6666bfc83ef7036c188" translate="yes" xml:space="preserve">
          <source>When the target of the &lt;code&gt;CallSite&lt;/code&gt; returned from this method is invoked, it returns the result of String concatenation, taking all function arguments and constants passed to the linkage method as inputs for concatenation. The target signature is given by &lt;code&gt;concatType&lt;/code&gt;, and does not include constants. For a target accepting:</source>
          <target state="translated">调用从此方法返回的 &lt;code&gt;CallSite&lt;/code&gt; 的目标时，它将返回String串联的结果，并将传递给该链接方法的所有函数参数和常量作为串联的输入。目标签名由 &lt;code&gt;concatType&lt;/code&gt; 给出，并且不包含常量。对于接受目标：</target>
        </trans-unit>
        <trans-unit id="d29230ce7aa0f83e52a9d0b8aae6ea61d3af4a88" translate="yes" xml:space="preserve">
          <source>When the target of the &lt;code&gt;CallSite&lt;/code&gt; returned from this method is invoked, it returns the result of String concatenation, taking all function arguments passed to the linkage method as inputs for concatenation. The target signature is given by &lt;code&gt;concatType&lt;/code&gt;. For a target accepting:</source>
          <target state="translated">调用从该方法返回的 &lt;code&gt;CallSite&lt;/code&gt; 的目标时，它将返回String串联的结果，并将传递给该链接方法的所有函数参数作为串联的输入。目标签名由 &lt;code&gt;concatType&lt;/code&gt; 给出。对于接受目标：</target>
        </trans-unit>
        <trans-unit id="d7d520f5e0468b072c681c7152b26b75810e8caf" translate="yes" xml:space="preserve">
          <source>When the target of the &lt;code&gt;CallSite&lt;/code&gt; returned from this method is invoked, the resulting function objects are instances of a class which implements the interface named by the return type of &lt;code&gt;invokedType&lt;/code&gt;, declares a method with the name given by &lt;code&gt;invokedName&lt;/code&gt; and the signature given by &lt;code&gt;samMethodType&lt;/code&gt;. It may also override additional methods from &lt;code&gt;Object&lt;/code&gt;.</source>
          <target state="translated">调用从此方法返回的 &lt;code&gt;CallSite&lt;/code&gt; 的目标时，生成的函数对象是一个类的实例，该类实现以 &lt;code&gt;invokedType&lt;/code&gt; 的返回类型命名的接口，声明一个方法，其名称由 &lt;code&gt;invokedName&lt;/code&gt; 给出，并且签名由 &lt;code&gt;samMethodType&lt;/code&gt; 给出。它还可能会覆盖 &lt;code&gt;Object&lt;/code&gt; 中的其他方法。</target>
        </trans-unit>
        <trans-unit id="935f09a1ca1fda156388d4a2ee040efb3dfa7c02" translate="yes" xml:space="preserve">
          <source>When the target of the &lt;code&gt;CallSite&lt;/code&gt; returned from this method is invoked, the resulting function objects are instances of a class with the following properties:</source>
          <target state="translated">调用从此方法返回的 &lt;code&gt;CallSite&lt;/code&gt; 的目标时，生成的函数对象是具有以下属性的类的实例：</target>
        </trans-unit>
        <trans-unit id="6d07b79c3fe52992e2c96caa5963c279054fc29d" translate="yes" xml:space="preserve">
          <source>When the user changes the value of the scroll bar, the scroll bar receives an instance of &lt;code&gt;AdjustmentEvent&lt;/code&gt;. The scroll bar processes this event, passing it along to any registered listeners.</source>
          <target state="translated">当用户更改滚动条的值时，滚动条会收到 &lt;code&gt;AdjustmentEvent&lt;/code&gt; 的实例。滚动条处理此事件，并将其传递给任何已注册的侦听器。</target>
        </trans-unit>
        <trans-unit id="16eee6e04be75731d2c23d0789dd273c70555ca5" translate="yes" xml:space="preserve">
          <source>When the user is resizing the &lt;code&gt;Component&lt;/code&gt;s the minimum size of the &lt;code&gt;Components&lt;/code&gt; is used to determine the maximum/minimum position the &lt;code&gt;Component&lt;/code&gt;s can be set to. If the minimum size of the two components is greater than the size of the split pane the divider will not allow you to resize it. To alter the minimum size of a &lt;code&gt;JComponent&lt;/code&gt;, see &lt;a href=&quot;jcomponent#setMinimumSize(java.awt.Dimension)&quot;&gt;&lt;code&gt;JComponent.setMinimumSize(java.awt.Dimension)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">当用户是在调整大小的 &lt;code&gt;Component&lt;/code&gt; S中的最小大小 &lt;code&gt;Components&lt;/code&gt; 被用来确定最大/最小位置的 &lt;code&gt;Component&lt;/code&gt; s时，可以设置为。如果两个组件的最小大小大于拆分窗格的大小，则分隔符将不允许您调整其大小。要更改 &lt;code&gt;JComponent&lt;/code&gt; 的最小大小，请参见&lt;a href=&quot;jcomponent#setMinimumSize(java.awt.Dimension)&quot;&gt; &lt;code&gt;JComponent.setMinimumSize(java.awt.Dimension)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="955102ac80658721d1f432faef28beba4c5e0ef3" translate="yes" xml:space="preserve">
          <source>When the user resizes the split pane the new space is distributed between the two components based on the &lt;code&gt;resizeWeight&lt;/code&gt; property. A value of 0, the default, indicates the right/bottom component gets all the space, where as a value of 1 indicates the left/top component gets all the space.</source>
          <target state="translated">当用户调整分割窗格的大小时，新空间将基于 &lt;code&gt;resizeWeight&lt;/code&gt; 属性在两个组件之间分配。缺省值为0表示右/底组件获得所有空间，其中值为1表示左/上组件获得所有空间。</target>
        </trans-unit>
        <trans-unit id="c90b9a5fd33f3cd980097a956b05ef5be63c5895" translate="yes" xml:space="preserve">
          <source>When the user terminates the drag operation, normally resulting in a successful Drop, both the &lt;code&gt;DragSource&lt;/code&gt; and &lt;code&gt;DropTarget&lt;/code&gt; receive notifications that include, and result in the type negotiation and transfer of, the information associated with the &lt;code&gt;DragSource&lt;/code&gt; via a &lt;code&gt;Transferable&lt;/code&gt; object.</source>
          <target state="translated">当用户终止拖动操作（通常会成功完成Drop）时， &lt;code&gt;DragSource&lt;/code&gt; 和 &lt;code&gt;DropTarget&lt;/code&gt; 都将接收通知，这些通知包括并通过 &lt;code&gt;Transferable&lt;/code&gt; 对象与 &lt;code&gt;DragSource&lt;/code&gt; 关联的信息进行类型协商和传输。</target>
        </trans-unit>
        <trans-unit id="1b69617c3d426ae0b52b14cd7b31c80e8f2ff7cf" translate="yes" xml:space="preserve">
          <source>When the virtual machine's built-in class loader, known as the &quot;bootstrap class loader&quot;, unsuccessfully searches for a class, the entries in the &lt;a href=&quot;../../../../java.base/java/util/jar/jarfile&quot;&gt;&lt;code&gt;JAR file&lt;/code&gt;&lt;/a&gt; will be searched as well.</source>
          <target state="translated">当虚拟机的内置类加载器（称为&amp;ldquo;引导类加载器&amp;rdquo;）无法成功搜索类时，还将搜索&lt;a href=&quot;../../../../java.base/java/util/jar/jarfile&quot;&gt; &lt;code&gt;JAR file&lt;/code&gt; &lt;/a&gt;的条目。</target>
        </trans-unit>
        <trans-unit id="3845d46c4ef86f663a835d134902a3051dd1ea04" translate="yes" xml:space="preserve">
          <source>When the virtual machine's built-in class loader, known as the &quot;bootstrap class loader&quot;, unsuccessfully searches for a class, the entries in the &lt;a href=&quot;../../util/jar/jarfile&quot;&gt;&lt;code&gt;JAR file&lt;/code&gt;&lt;/a&gt; will be searched as well.</source>
          <target state="translated">当虚拟机的内置类加载器（称为&amp;ldquo;引导类加载器&amp;rdquo;）无法成功搜索类时，还将搜索&lt;a href=&quot;../../util/jar/jarfile&quot;&gt; &lt;code&gt;JAR file&lt;/code&gt; &lt;/a&gt;的条目。</target>
        </trans-unit>
        <trans-unit id="9f5936d0319917d0904a3bc84216aec8fd20dcb1" translate="yes" xml:space="preserve">
          <source>When the window is per-pixel translucent, the drawing sub-system respects the alpha value of each individual pixel. If a pixel gets painted with the alpha color component equal to zero, it becomes visually transparent. If the alpha of the pixel is equal to 1.0f, the pixel is fully opaque. Interim values of the alpha color component make the pixel semi-transparent. In this mode, the background of the window gets painted with the alpha value of the given background color. If the alpha value of the argument of this method is equal to &lt;code&gt;0&lt;/code&gt;, the background is not painted at all.</source>
          <target state="translated">当窗口是每个像素半透明时，绘图子系统会考虑每个单独像素的alpha值。如果用等于零的alpha颜色分量绘制像素，则它在视觉上会变得透明。如果像素的Alpha等于1.0f，则该像素是完全不透明的。 Alpha颜色分量的中间值使像素变为半透明。在此模式下，窗口的背景将使用给定背景色的Alpha值进行绘制。如果此方法的参数的alpha值等于 &lt;code&gt;0&lt;/code&gt; ，则根本不会绘制背景。</target>
        </trans-unit>
        <trans-unit id="78301597bc29e04c67c4b5e8569630b44e2a80b1" translate="yes" xml:space="preserve">
          <source>When there are no more tokens, the last value found in the child-cache or returned by &lt;code&gt;childSpi&lt;/code&gt; is returned by this method. If during the traversal, two &lt;code&gt;&quot;/&quot;&lt;/code&gt; tokens occur consecutively, or the final token is &lt;code&gt;&quot;/&quot;&lt;/code&gt; (rather than a name), an appropriate &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown.</source>
          <target state="translated">如果没有更多的令牌，则此方法将返回在子缓存中找到或由 &lt;code&gt;childSpi&lt;/code&gt; 返回的最后一个值。如果在遍历期间连续出现两个 &lt;code&gt;&quot;/&quot;&lt;/code&gt; 标记，或者最终标记为 &lt;code&gt;&quot;/&quot;&lt;/code&gt; （而不是名称），则会引发适当的 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dd91b0658c6cf431015b14f6a00de46f9c97ac60" translate="yes" xml:space="preserve">
          <source>When there is a positive-width match at the beginning of the input sequence then an empty leading substring is included at the beginning of the resulting array. A zero-width match at the beginning however never produces such empty leading substring.</source>
          <target state="translated">当输入序列的开头有一个正宽度的匹配,那么一个空的前导子串就会包含在结果数组的开头。然而,在开头的零宽度匹配永远不会产生这样的空前导子串。</target>
        </trans-unit>
        <trans-unit id="ab6bcee9543d79d3bbe811e0f20b9a8c6356f175" translate="yes" xml:space="preserve">
          <source>When there is a positive-width match at the beginning of the input sequence then an empty leading substring is included at the beginning of the stream. A zero-width match at the beginning however never produces such empty leading substring.</source>
          <target state="translated">当输入序列的开头有一个正宽度的匹配,那么一个空的前导子串就会被包含在数据流的开头。然而,在开头的零宽度匹配绝不会产生这样的空前导子串。</target>
        </trans-unit>
        <trans-unit id="735c807118b30a042caeeea37d2a0653aefeb1e0" translate="yes" xml:space="preserve">
          <source>When there is a positive-width match at the beginning of this string then an empty leading substring is included at the beginning of the resulting array. A zero-width match at the beginning however never produces such empty leading substring.</source>
          <target state="translated">当这个字符串的开头有一个正宽度的匹配,那么一个空的前导子串就会包含在结果数组的开头。然而,在开头的零宽度匹配永远不会产生这样一个空的前导子串。</target>
        </trans-unit>
        <trans-unit id="9a4d1a71ed66693f31054772316c85b0392b49d2" translate="yes" xml:space="preserve">
          <source>When these are in place for a UDT, calling the methods &lt;code&gt;ResultSet.getObject&lt;/code&gt; or &lt;code&gt;CallableStatement.getObject&lt;/code&gt; on that UDT will automatically retrieve the custom mapping for it. Also, the &lt;code&gt;PreparedStatement.setObject&lt;/code&gt; method will automatically map the object back to its SQL type to store it in the data source.</source>
          <target state="translated">将这些放置在UDT上后，在该UDT上调用 &lt;code&gt;ResultSet.getObject&lt;/code&gt; 或 &lt;code&gt;CallableStatement.getObject&lt;/code&gt; 方法将自动为其获取自定义映射。另外， &lt;code&gt;PreparedStatement.setObject&lt;/code&gt; 方法将自动将对象映射回其SQL类型，以将其存储在数据源中。</target>
        </trans-unit>
        <trans-unit id="59b930f7ddff7332085ec26d6fac4974e8e12b10" translate="yes" xml:space="preserve">
          <source>When this code runs,</source>
          <target state="translated">当这段代码运行时。</target>
        </trans-unit>
        <trans-unit id="cbcf2b7b42302b4ba4fae27e923d6a973f224d28" translate="yes" xml:space="preserve">
          <source>When this fails, the resolution will be retried with the specified prefix deleted from the implementation name, yielding the correct resolution:</source>
          <target state="translated">如果失败了,将从实现名称中删除指定的前缀,重新进行解析,得到正确的解析结果。</target>
        </trans-unit>
        <trans-unit id="ff9da4b4449f564bcf08ecf5f687a2592cebde98" translate="yes" xml:space="preserve">
          <source>When this fails, the resolution will be retried with the specified prefix prepended to the method name, yielding the correct resolution:</source>
          <target state="translated">如果失败了,将用指定的方法名前缀重新进行解析,得到正确的解析结果。</target>
        </trans-unit>
        <trans-unit id="75154f3aadedea422fd3c7633a9889ca79a529a3" translate="yes" xml:space="preserve">
          <source>When this field is used for setting a value, it should behave in the same way as setting &lt;a href=&quot;#NANO_OF_DAY&quot;&gt;&lt;code&gt;NANO_OF_DAY&lt;/code&gt;&lt;/a&gt; with the value multiplied by 1,000,000.</source>
          <target state="translated">当此字段用于设置值时，其行为应与设置值乘以1,000,000的&lt;a href=&quot;#NANO_OF_DAY&quot;&gt; &lt;code&gt;NANO_OF_DAY&lt;/code&gt; &lt;/a&gt;相同。</target>
        </trans-unit>
        <trans-unit id="15ccb1c283c4e094f90353b08299e4e2a2ecb732" translate="yes" xml:space="preserve">
          <source>When this field is used for setting a value, it should behave in the same way as setting &lt;a href=&quot;#NANO_OF_DAY&quot;&gt;&lt;code&gt;NANO_OF_DAY&lt;/code&gt;&lt;/a&gt; with the value multiplied by 1,000.</source>
          <target state="translated">当此字段用于设置值时，其行为应与设置&lt;a href=&quot;#NANO_OF_DAY&quot;&gt; &lt;code&gt;NANO_OF_DAY&lt;/code&gt; &lt;/a&gt;（将值乘以1000）相同。</target>
        </trans-unit>
        <trans-unit id="53f8544461b05bbe464ff7823a230bfc4bf04760" translate="yes" xml:space="preserve">
          <source>When this field is used for setting a value, it should behave in the same way as setting &lt;a href=&quot;#NANO_OF_SECOND&quot;&gt;&lt;code&gt;NANO_OF_SECOND&lt;/code&gt;&lt;/a&gt; with the value multiplied by 1,000,000.</source>
          <target state="translated">当此字段用于设置值时，其行为应与设置值乘以1,000,000的&lt;a href=&quot;#NANO_OF_SECOND&quot;&gt; &lt;code&gt;NANO_OF_SECOND&lt;/code&gt; &lt;/a&gt;相同。</target>
        </trans-unit>
        <trans-unit id="f8f0fa54e907e8e2466eda8f3397fead3f7ec0b2" translate="yes" xml:space="preserve">
          <source>When this field is used for setting a value, it should behave in the same way as setting &lt;a href=&quot;#NANO_OF_SECOND&quot;&gt;&lt;code&gt;NANO_OF_SECOND&lt;/code&gt;&lt;/a&gt; with the value multiplied by 1,000.</source>
          <target state="translated">当此字段用于设置值时，其行为应与将值乘以1000设置&lt;a href=&quot;#NANO_OF_SECOND&quot;&gt; &lt;code&gt;NANO_OF_SECOND&lt;/code&gt; &lt;/a&gt;相同。</target>
        </trans-unit>
        <trans-unit id="eaab9ca0b04a7049f2a9f2eca0230f3f4e33a263" translate="yes" xml:space="preserve">
          <source>When this field is used for setting a value, it should behave in the same way as setting &lt;a href=&quot;chronofield#NANO_OF_DAY&quot;&gt;&lt;code&gt;NANO_OF_DAY&lt;/code&gt;&lt;/a&gt; with the value multiplied by 1,000,000.</source>
          <target state="translated">当此字段用于设置值时，其行为应与设置值乘以1,000,000的&lt;a href=&quot;chronofield#NANO_OF_DAY&quot;&gt; &lt;code&gt;NANO_OF_DAY&lt;/code&gt; &lt;/a&gt;相同。</target>
        </trans-unit>
        <trans-unit id="db9acfde62bdc912d95eb549ddc180babc48a672" translate="yes" xml:space="preserve">
          <source>When this field is used for setting a value, it should behave in the same way as setting &lt;a href=&quot;chronofield#NANO_OF_DAY&quot;&gt;&lt;code&gt;NANO_OF_DAY&lt;/code&gt;&lt;/a&gt; with the value multiplied by 1,000.</source>
          <target state="translated">当此字段用于设置值时，其行为应与设置&lt;a href=&quot;chronofield#NANO_OF_DAY&quot;&gt; &lt;code&gt;NANO_OF_DAY&lt;/code&gt; &lt;/a&gt;（值乘以1000）相同。</target>
        </trans-unit>
        <trans-unit id="b434d16d4beadd3f769e9c367e4be1fa9657e587" translate="yes" xml:space="preserve">
          <source>When this field is used for setting a value, it should behave in the same way as setting &lt;a href=&quot;chronofield#NANO_OF_SECOND&quot;&gt;&lt;code&gt;NANO_OF_SECOND&lt;/code&gt;&lt;/a&gt; with the value multiplied by 1,000,000.</source>
          <target state="translated">当此字段用于设置值时，其行为应与设置值乘以1,000,000的&lt;a href=&quot;chronofield#NANO_OF_SECOND&quot;&gt; &lt;code&gt;NANO_OF_SECOND&lt;/code&gt; &lt;/a&gt;相同。</target>
        </trans-unit>
        <trans-unit id="4dce2d6953f5a46462f20dc8f01aaa03fa0ee37c" translate="yes" xml:space="preserve">
          <source>When this field is used for setting a value, it should behave in the same way as setting &lt;a href=&quot;chronofield#NANO_OF_SECOND&quot;&gt;&lt;code&gt;NANO_OF_SECOND&lt;/code&gt;&lt;/a&gt; with the value multiplied by 1,000.</source>
          <target state="translated">当此字段用于设置值时，其行为应与将值乘以1000 设置&lt;a href=&quot;chronofield#NANO_OF_SECOND&quot;&gt; &lt;code&gt;NANO_OF_SECOND&lt;/code&gt; &lt;/a&gt;相同。</target>
        </trans-unit>
        <trans-unit id="7f48a54b9eb38bdd2ccfe0a591106ec4e77d4089" translate="yes" xml:space="preserve">
          <source>When this field is used for setting a value, it should set as much precision as the object stores, using integer division to remove excess precision. For example, if the &lt;code&gt;TemporalAccessor&lt;/code&gt; stores time to millisecond precision, then the nano-of-second must be divided by 1,000,000 before replacing the milli-of-second.</source>
          <target state="translated">使用此字段设置值时，应设置与对象存储的精度相同的精度，并使用整数除法删除多余的精度。例如，如果 &lt;code&gt;TemporalAccessor&lt;/code&gt; 以毫秒为单位存储时间，则在替换毫秒之前必须将1纳秒除以1,000,000。</target>
        </trans-unit>
        <trans-unit id="fa1979bf73c3be15be38db625d744988147dfdcd" translate="yes" xml:space="preserve">
          <source>When this flag is false, delegation will only be tried when the &lt;a href=&quot;../../../../../java.security.jgss/org/ietf/jgss/gsscontext#requestCredDeleg(boolean)&quot;&gt;&lt;code&gt;credentials delegation flag&lt;/code&gt;&lt;/a&gt; is true.</source>
          <target state="translated">如果此标志为假，则仅在&lt;a href=&quot;../../../../../java.security.jgss/org/ietf/jgss/gsscontext#requestCredDeleg(boolean)&quot;&gt; &lt;code&gt;credentials delegation flag&lt;/code&gt; &lt;/a&gt;为true时才尝试委派。</target>
        </trans-unit>
        <trans-unit id="e2e89c6cff8f954a3f0ea54f5e7b16399bcbf000" translate="yes" xml:space="preserve">
          <source>When this flag is specified then case-insensitive matching, when enabled by the &lt;a href=&quot;#CASE_INSENSITIVE&quot;&gt;&lt;code&gt;CASE_INSENSITIVE&lt;/code&gt;&lt;/a&gt; flag, is done in a manner consistent with the Unicode Standard. By default, case-insensitive matching assumes that only characters in the US-ASCII charset are being matched.</source>
          <target state="translated">如果指定了此标志，则以&lt;a href=&quot;#CASE_INSENSITIVE&quot;&gt; &lt;code&gt;CASE_INSENSITIVE&lt;/code&gt; &lt;/a&gt;标志启用时，不区分大小写的匹配将以与Unicode标准一致的方式进行。默认情况下，不区分大小写的匹配假定只匹配US-ASCII字符集中的字符。</target>
        </trans-unit>
        <trans-unit id="7586fee8208377dc85e8eeb7ce578740e81e481a" translate="yes" xml:space="preserve">
          <source>When this flag is specified then case-insensitive matching, when enabled by the &lt;a href=&quot;pattern#CASE_INSENSITIVE&quot;&gt;&lt;code&gt;CASE_INSENSITIVE&lt;/code&gt;&lt;/a&gt; flag, is done in a manner consistent with the Unicode Standard. By default, case-insensitive matching assumes that only characters in the US-ASCII charset are being matched.</source>
          <target state="translated">如果指定了此标志，则由&lt;a href=&quot;pattern#CASE_INSENSITIVE&quot;&gt; &lt;code&gt;CASE_INSENSITIVE&lt;/code&gt; &lt;/a&gt;标志启用时，不区分大小写的匹配将以与Unicode标准一致的方式进行。默认情况下，不区分大小写的匹配假定只匹配US-ASCII字符集中的字符。</target>
        </trans-unit>
        <trans-unit id="14b51aaf8931fe8814ff8bce6f0f7714b23eea9c" translate="yes" xml:space="preserve">
          <source>When this flag is specified then the (US-ASCII only)</source>
          <target state="translated">如果指定了这个标志,那么(仅适用于US-ASCII)。</target>
        </trans-unit>
        <trans-unit id="a5a64aeef21bfe24b3dc25f14183010379e48ae2" translate="yes" xml:space="preserve">
          <source>When this flag is specified then the input string that specifies the pattern is treated as a sequence of literal characters. Metacharacters or escape sequences in the input sequence will be given no special meaning.</source>
          <target state="translated">当指定了这个标志时,指定模式的输入字符串将被视为一个文字字符序列。输入序列中的元字符或转义序列不会被赋予特殊意义。</target>
        </trans-unit>
        <trans-unit id="21f1033522929794d630209592d380a1564d3a0e" translate="yes" xml:space="preserve">
          <source>When this flag is specified then two characters will be considered to match if, and only if, their full canonical decompositions match. The expression &lt;code&gt;&quot;a\u030A&quot;&lt;/code&gt;, for example, will match the string &lt;code&gt;&quot;\u00E5&quot;&lt;/code&gt; when this flag is specified. By default, matching does not take canonical equivalence into account.</source>
          <target state="translated">指定此标志后，只有且仅当其完整规范分解匹配时，两个字符才会被视为匹配。例如，在指定此标志时，表达式 &lt;code&gt;&quot;a\u030A&quot;&lt;/code&gt; 将匹配字符串 &lt;code&gt;&quot;\u00E5&quot;&lt;/code&gt; 。默认情况下，匹配不考虑规范对等。</target>
        </trans-unit>
        <trans-unit id="3ee555d7b34f75912704f0605b8959fada5a0e2b" translate="yes" xml:space="preserve">
          <source>When this flag is true but the &lt;a href=&quot;../../../../../java.security.jgss/org/ietf/jgss/gsscontext#requestCredDeleg(boolean)&quot;&gt;&lt;code&gt;credentials delegation flag&lt;/code&gt;&lt;/a&gt; is false, delegation will be only tried if the delegation policy permits delegation.</source>
          <target state="translated">当此标志为true但&lt;a href=&quot;../../../../../java.security.jgss/org/ietf/jgss/gsscontext#requestCredDeleg(boolean)&quot;&gt; &lt;code&gt;credentials delegation flag&lt;/code&gt; &lt;/a&gt;为false时，仅在委派策略允许委派的情况下才尝试委派。</target>
        </trans-unit>
        <trans-unit id="2eb07b710886c04bce981e5cfa33253d986b6149" translate="yes" xml:space="preserve">
          <source>When this method is called from a named module and the given loader is the class loader of the caller module, this is equivalent to calling:</source>
          <target state="translated">当这个方法从一个命名的模块中调用,并且给定的加载器是调用者模块的类加载器时,相当于调用。</target>
        </trans-unit>
        <trans-unit id="97ec7609c528b9efd3de6f2bb7f5796b603e2fd8" translate="yes" xml:space="preserve">
          <source>When this method is called on a window with a value of &lt;code&gt;false&lt;/code&gt; the always-on-top state is set to normal. It may also cause an unspecified, platform-dependent change in the z-order of top-level windows, but other always-on-top windows will remain in top-most position. Calling this method with a value of &lt;code&gt;false&lt;/code&gt; on a window that has a normal state has no effect.</source>
          <target state="translated">当在值为 &lt;code&gt;false&lt;/code&gt; 的窗口上调用此方法时，永远在线状态将设置为正常。它还可能会导致顶层窗口的z顺序发生未指定的，与平台相关的变化，但是其他始终位于顶层的窗口将保持在最顶层。在具有正常状态的窗口上以 &lt;code&gt;false&lt;/code&gt; 值调用此方法无效。</target>
        </trans-unit>
        <trans-unit id="35fc6a39f3e8a32dd792f6a29a5416db989863ad" translate="yes" xml:space="preserve">
          <source>When this method is called on a window with a value of &lt;code&gt;true&lt;/code&gt;, and the window is visible and the platform supports always-on-top for this window, the window is immediately brought forward, &quot;sticking&quot; it in the top-most position. If the window isn`t currently visible, this method sets the always-on-top state to &lt;code&gt;true&lt;/code&gt; but does not bring the window forward. When the window is later shown, it will be always-on-top.</source>
          <target state="translated">如果在值为 &lt;code&gt;true&lt;/code&gt; 的窗口上调用此方法，并且该窗口可见并且平台支持该窗口始终位于顶部，则该窗口将立即移至顶部，将其&amp;ldquo;粘贴&amp;rdquo;在最上方。如果窗口当前不可见，则此方法将始终处于顶部的状态设置为 &lt;code&gt;true&lt;/code&gt; ,但不会使窗口前移。稍后显示该窗口时，它将始终位于顶部。</target>
        </trans-unit>
        <trans-unit id="34681f8822dac6f93802ce310f175da3ecf86017" translate="yes" xml:space="preserve">
          <source>When this method is called, a &lt;code&gt;CachedRowSet&lt;/code&gt; implementation must ensure that all updates, inserts, and deletes to the current rowset instance are replaced by the previous values. In addition, the cursor should be reset to the first row and a &lt;code&gt;rowSetChanged&lt;/code&gt; event should be fired to notify all registered listeners.</source>
          <target state="translated">调用此方法时， &lt;code&gt;CachedRowSet&lt;/code&gt; 实现必须确保对当前行集实例的所有更新，插入和删除均被先前的值替换。此外，应将游标重置为第一行，并应触发 &lt;code&gt;rowSetChanged&lt;/code&gt; 事件以通知所有已注册的侦听器。</target>
        </trans-unit>
        <trans-unit id="c46ec6437cd48feaac1a48bb7981ed49d818cc15" translate="yes" xml:space="preserve">
          <source>When this method is first called, it creates a single new pseudorandom-number generator, exactly as if by the expression</source>
          <target state="translated">当这个方法第一次被调用时,它创建了一个新的伪随机数生成器,就像通过表达式一样。</target>
        </trans-unit>
        <trans-unit id="8017fa479dbb420d64cc0450b94e2122cd6d705f" translate="yes" xml:space="preserve">
          <source>When this method is observed via the Core Reflection API, it will appear as a single native method, taking an object array and returning an object. If this native method is invoked directly via &lt;a href=&quot;../reflect/method#invoke(java.lang.Object,java.lang.Object...)&quot;&gt;&lt;code&gt;java.lang.reflect.Method.invoke&lt;/code&gt;&lt;/a&gt;, via JNI, or indirectly via &lt;a href=&quot;methodhandles.lookup#unreflect(java.lang.reflect.Method)&quot;&gt;&lt;code&gt;Lookup.unreflect&lt;/code&gt;&lt;/a&gt;, it will throw an &lt;code&gt;UnsupportedOperationException&lt;/code&gt;.</source>
          <target state="translated">当通过Core Reflection API观察到此方法时，它将显示为单个本机方法，它采用一个对象数组并返回一个对象。如果直接通过&lt;a href=&quot;../reflect/method#invoke(java.lang.Object,java.lang.Object...)&quot;&gt; &lt;code&gt;java.lang.reflect.Method.invoke&lt;/code&gt; &lt;/a&gt;，通过JNI或通过&lt;a href=&quot;methodhandles.lookup#unreflect(java.lang.reflect.Method)&quot;&gt; &lt;code&gt;Lookup.unreflect&lt;/code&gt; &lt;/a&gt;间接调用此本地方法，它将抛出 &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="52757c7befe8d92c9dd6861f446c19ec7ae3c908" translate="yes" xml:space="preserve">
          <source>When this method is observed via the Core Reflection API, it will appear as a single native method, taking an object array and returning an object. If this native method is invoked directly via &lt;a href=&quot;../reflect/method#invoke-java.lang.Object-java.lang.Object...-&quot;&gt;&lt;code&gt;java.lang.reflect.Method.invoke&lt;/code&gt;&lt;/a&gt;, via JNI, or indirectly via &lt;a href=&quot;methodhandles.lookup#unreflect-java.lang.reflect.Method-&quot;&gt;&lt;code&gt;Lookup.unreflect&lt;/code&gt;&lt;/a&gt;, it will throw an &lt;code&gt;UnsupportedOperationException&lt;/code&gt;.</source>
          <target state="translated">当通过Core Reflection API观察到此方法时，它将显示为单个本机方法，它采用一个对象数组并返回一个对象。如果直接通过&lt;a href=&quot;../reflect/method#invoke-java.lang.Object-java.lang.Object...-&quot;&gt; &lt;code&gt;java.lang.reflect.Method.invoke&lt;/code&gt; &lt;/a&gt;，通过JNI或通过&lt;a href=&quot;methodhandles.lookup#unreflect-java.lang.reflect.Method-&quot;&gt; &lt;code&gt;Lookup.unreflect&lt;/code&gt; &lt;/a&gt;间接调用此本机方法，它将抛出 &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a38dc9de2e7e26b0458b9e11ee50544cbc7608fa" translate="yes" xml:space="preserve">
          <source>When this method returns both the input and the output will have been closed. Any pending send operations will fail with &lt;code&gt;IOException&lt;/code&gt;. Subsequent invocations of &lt;code&gt;abort&lt;/code&gt; will have no effect.</source>
          <target state="translated">当此方法返回时，输入和输出都将被关闭。任何挂起的发送操作将失败，并带有 &lt;code&gt;IOException&lt;/code&gt; 。随后的 &lt;code&gt;abort&lt;/code&gt; 调用将无效。</target>
        </trans-unit>
        <trans-unit id="3ee3ff5f0b0cb85ef35aeb00902b551ab3ba4149" translate="yes" xml:space="preserve">
          <source>When this method returns true, then it is possible that more input would have changed the result of the last search.</source>
          <target state="translated">当这个方法返回true时,那么有可能更多的输入会改变上次搜索的结果。</target>
        </trans-unit>
        <trans-unit id="6509e5735d2c1c6ef7c6f2ecc98960052393fc92" translate="yes" xml:space="preserve">
          <source>When this object is passed to a &lt;code&gt;SecureRandom.getInstance()&lt;/code&gt; call, it is the requested minimum capability. When it's returned from &lt;code&gt;SecureRandom.getParameters()&lt;/code&gt;, it is the effective capability.</source>
          <target state="translated">当将此对象传递给 &lt;code&gt;SecureRandom.getInstance()&lt;/code&gt; 调用时，它是所请求的最低功能。从 &lt;code&gt;SecureRandom.getParameters()&lt;/code&gt; 返回时，它是有效的功能。</target>
        </trans-unit>
        <trans-unit id="1b6f8486c17688cf0a3d019c7be76ba42109c755" translate="yes" xml:space="preserve">
          <source>When this option is present then the implementation makes a &lt;em&gt;best effort&lt;/em&gt; attempt to delete the file when closed by the &lt;a href=&quot;../channels/channel#close()&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt; method. If the &lt;code&gt;close&lt;/code&gt; method is not invoked then a &lt;em&gt;best effort&lt;/em&gt; attempt is made to delete the file when the Java virtual machine terminates.</source>
          <target state="translated">如果存在此选项，则当使用&lt;a href=&quot;../channels/channel#close()&quot;&gt; &lt;code&gt;close&lt;/code&gt; &lt;/a&gt;方法关闭该实现时，实现会&lt;em&gt;尽最大努力&lt;/em&gt;尝试删除该文件。如果未调用 &lt;code&gt;close&lt;/code&gt; 方法，则在Java虚拟机终止时会&lt;em&gt;尽最大努力&lt;/em&gt;删除该文件。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c3d23117d12579aaf94e4afd1d23df8d2a8c9c22" translate="yes" xml:space="preserve">
          <source>When this option is present then the implementation makes a &lt;em&gt;best effort&lt;/em&gt; attempt to delete the file when closed by the &lt;a href=&quot;../channels/channel#close--&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt; method. If the &lt;code&gt;close&lt;/code&gt; method is not invoked then a &lt;em&gt;best effort&lt;/em&gt; attempt is made to delete the file when the Java virtual machine terminates.</source>
          <target state="translated">如果存在此选项，则当使用&lt;a href=&quot;../channels/channel#close--&quot;&gt; &lt;code&gt;close&lt;/code&gt; &lt;/a&gt;方法关闭时，实现会&lt;em&gt;尽最大努力&lt;/em&gt;尝试删除文件。如果未调用 &lt;code&gt;close&lt;/code&gt; 方法，则在Java虚拟机终止时会&lt;em&gt;尽最大努力&lt;/em&gt;删除该文件。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="154a44d02d610434ad7eb55b13886c24f76c0303" translate="yes" xml:space="preserve">
          <source>When this option is present then the implementation makes a &lt;em&gt;best effort&lt;/em&gt; attempt to delete the file when closed by the &lt;a href=&quot;asynchronouschannel#close()&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt; method. If the &lt;code&gt;close&lt;/code&gt; method is not invoked then a &lt;em&gt;best effort&lt;/em&gt; attempt is made to delete the file when the Java virtual machine terminates.</source>
          <target state="translated">如果存在此选项，则当使用&lt;a href=&quot;asynchronouschannel#close()&quot;&gt; &lt;code&gt;close&lt;/code&gt; &lt;/a&gt;方法关闭该实现时，实现会&lt;em&gt;尽最大努力&lt;/em&gt;尝试删除该文件。如果未调用 &lt;code&gt;close&lt;/code&gt; 方法，则在Java虚拟机终止时会&lt;em&gt;尽最大努力&lt;/em&gt;删除该文件。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f56b2fb23d344e1a50af4c3e2e123c61d288eb20" translate="yes" xml:space="preserve">
          <source>When this option is present then the implementation makes a &lt;em&gt;best effort&lt;/em&gt; attempt to delete the file when closed by the &lt;a href=&quot;spi/abstractinterruptiblechannel#close()&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt; method. If the &lt;code&gt;close&lt;/code&gt; method is not invoked then a &lt;em&gt;best effort&lt;/em&gt; attempt is made to delete the file when the Java virtual machine terminates.</source>
          <target state="translated">如果存在此选项，则当使用&lt;a href=&quot;spi/abstractinterruptiblechannel#close()&quot;&gt; &lt;code&gt;close&lt;/code&gt; &lt;/a&gt;方法关闭该实现时，实现会&lt;em&gt;尽最大努力&lt;/em&gt;尝试删除该文件。如果未调用 &lt;code&gt;close&lt;/code&gt; 方法，则在Java虚拟机终止时会&lt;em&gt;尽最大努力&lt;/em&gt;删除该文件。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b452042a8719f181a9d60ae51034b9bcd166e197" translate="yes" xml:space="preserve">
          <source>When this option is present then the implementation makes a &lt;em&gt;best effort&lt;/em&gt; attempt to delete the file when closed by the the &lt;a href=&quot;asynchronouschannel#close--&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt; method. If the &lt;code&gt;close&lt;/code&gt; method is not invoked then a &lt;em&gt;best effort&lt;/em&gt; attempt is made to delete the file when the Java virtual machine terminates.</source>
          <target state="translated">如果存在此选项，则当使用&lt;a href=&quot;asynchronouschannel#close--&quot;&gt; &lt;code&gt;close&lt;/code&gt; &lt;/a&gt;方法关闭该实现时，实现会&lt;em&gt;尽最大努力&lt;/em&gt;删除该文件。如果未调用 &lt;code&gt;close&lt;/code&gt; 方法，则在Java虚拟机终止时会&lt;em&gt;尽最大努力&lt;/em&gt;删除该文件。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0f88517540cae38f29035447f8bcd48cdb8f163b" translate="yes" xml:space="preserve">
          <source>When this option is present then the implementation makes a &lt;em&gt;best effort&lt;/em&gt; attempt to delete the file when closed by the the &lt;a href=&quot;spi/abstractinterruptiblechannel#close--&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt; method. If the &lt;code&gt;close&lt;/code&gt; method is not invoked then a &lt;em&gt;best effort&lt;/em&gt; attempt is made to delete the file when the Java virtual machine terminates.</source>
          <target state="translated">如果存在此选项，则当使用&lt;a href=&quot;spi/abstractinterruptiblechannel#close--&quot;&gt; &lt;code&gt;close&lt;/code&gt; &lt;/a&gt;方法关闭该实现时，实现会&lt;em&gt;尽最大努力&lt;/em&gt;删除该文件。如果未调用 &lt;code&gt;close&lt;/code&gt; 方法，则在Java虚拟机终止时会&lt;em&gt;尽最大努力&lt;/em&gt;删除该文件。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a7cc18013b4812cde5f7d9912f2b87d319240ca6" translate="yes" xml:space="preserve">
          <source>When this property changes, a property change event with name &quot;dropLocation&quot; is fired by the component.</source>
          <target state="translated">当该属性发生变化时,组件会触发一个名称为 &quot;dropLocation &quot;的属性变化事件。</target>
        </trans-unit>
        <trans-unit id="038f87151a058e2199fb9c59c3147f43fabc5ee1" translate="yes" xml:space="preserve">
          <source>When this stage completes normally, the given function is invoked with this stage's result as the argument, returning another CompletionStage. When that stage completes normally, the CompletionStage returned by this method is completed with the same value.</source>
          <target state="translated">当这个阶段正常完成时,调用给定的函数,以这个阶段的结果作为参数,返回另一个 CompletionStage。当该阶段正常完成时,本方法返回的完成阶段以相同的值完成。</target>
        </trans-unit>
        <trans-unit id="939cadcf27e2f0c5c29ad269b174f1448284da61" translate="yes" xml:space="preserve">
          <source>When this stage is complete, the given action is invoked with the result (or &lt;code&gt;null&lt;/code&gt; if none) and the exception (or &lt;code&gt;null&lt;/code&gt; if none) of this stage as arguments. The returned stage is completed when the action returns.</source>
          <target state="translated">当这一阶段完成后，给定的动作被调用，有结果（或 &lt;code&gt;null&lt;/code&gt; ，如果没有）和异常（或 &lt;code&gt;null&lt;/code&gt; ，如果没有）这个阶段作为参数。动作返回时，返回的阶段已完成。</target>
        </trans-unit>
        <trans-unit id="aaf41e965e28c5483c92f84aed2e73228dbc1a97" translate="yes" xml:space="preserve">
          <source>When this stage is complete, the given action is invoked with the result (or &lt;code&gt;null&lt;/code&gt; if none) and the exception (or &lt;code&gt;null&lt;/code&gt; if none) of this stage as arguments. The returned stage is completed when the action returns. If the supplied action itself encounters an exception, then the returned stage exceptionally completes with this exception unless this stage also completed exceptionally.</source>
          <target state="translated">当这一阶段完成后，给定的动作被调用，有结果（或 &lt;code&gt;null&lt;/code&gt; ，如果没有）和异常（或 &lt;code&gt;null&lt;/code&gt; ，如果没有）这个阶段作为参数。动作返回时，返回的阶段完成。如果所提供的操作本身遇到异常，那么除非此阶段也异常完成，否则返回阶段将异常终止。</target>
        </trans-unit>
        <trans-unit id="3f6f82cd6d0f4507ceec2cd68bde83c6bb558834" translate="yes" xml:space="preserve">
          <source>When this stage is complete, the given function is invoked with the result (or &lt;code&gt;null&lt;/code&gt; if none) and the exception (or &lt;code&gt;null&lt;/code&gt; if none) of this stage as arguments, and the function's result is used to complete the returned stage.</source>
          <target state="translated">当这一阶段完成后，给定函数被调用，有结果（或 &lt;code&gt;null&lt;/code&gt; ，如果没有）和异常（或 &lt;code&gt;null&lt;/code&gt; ，如果没有）这个阶段作为参数，函数的结果来完成恢复阶段。</target>
        </trans-unit>
        <trans-unit id="bac49680cb60a5ee049452f6e78185889fe92438" translate="yes" xml:space="preserve">
          <source>When this stream reaches end of stream, further invocations of this method will return an empty byte array.</source>
          <target state="translated">当这个流达到流的末端时,进一步调用这个方法将返回一个空的字节数组。</target>
        </trans-unit>
        <trans-unit id="48eb95265e7d021d7c0bcfe7d5877c9bf2e00f35" translate="yes" xml:space="preserve">
          <source>When to implement</source>
          <target state="translated">何时实施</target>
        </trans-unit>
        <trans-unit id="b19e6fec33654d65225b5a683c7ddc3223d7ead2" translate="yes" xml:space="preserve">
          <source>When to use this interface</source>
          <target state="translated">何时使用此接口</target>
        </trans-unit>
        <trans-unit id="2987413b1ccabfe41476e5c2416ebf03f5549889" translate="yes" xml:space="preserve">
          <source>When traversing a graph, an object may be encountered that does not support the Serializable interface. In this case the NotSerializableException will be thrown and will identify the class of the non-serializable object.</source>
          <target state="translated">当遍历一个图时,可能会遇到一个不支持Serializable接口的对象。在这种情况下,NotSerializableException将被抛出,并将识别不可序列化对象的类。</target>
        </trans-unit>
        <trans-unit id="2b9c24656f8fed2cf3b6f2a56f50610d27fc3e1a" translate="yes" xml:space="preserve">
          <source>When true, forbid user from resizing frame.</source>
          <target state="translated">当为 &quot;true &quot;时,禁止用户调整帧的大小。</target>
        </trans-unit>
        <trans-unit id="9d9a1f383307d792fbf66d13ce7bf3c300a5369a" translate="yes" xml:space="preserve">
          <source>When true, forbid user from resizing frame. See the noresize attribute definition in HTML 4.0.</source>
          <target state="translated">当为 &quot;true &quot;时,禁止用户调整帧的大小。参见HTML 4.0中的noresize属性定义。</target>
        </trans-unit>
        <trans-unit id="72491fa06ce4e80db58d269ec31cc9c29821a7b3" translate="yes" xml:space="preserve">
          <source>When two composite names are compared, the case of the characters is significant.</source>
          <target state="translated">当两个复合名进行比较时,字符的大小写是重要的。</target>
        </trans-unit>
        <trans-unit id="d39ea45a6268a67c061975b6eb4abdceccee5c88" translate="yes" xml:space="preserve">
          <source>When two or more interfaces of a proxy class contain a method with the same name and parameter signature, the order of the proxy class's interfaces becomes significant. When such a</source>
          <target state="translated">当一个代理类的两个或两个以上的接口包含一个具有相同名称和参数签名的方法时,代理类的接口的顺序就变得很重要。当这样的</target>
        </trans-unit>
        <trans-unit id="824dd2ec1443a6d10bed31844958381a75362daa" translate="yes" xml:space="preserve">
          <source>When two or more proxy interfaces contain a method with the same name and parameter signature, the order of the proxy class's interfaces becomes significant. When such a</source>
          <target state="translated">当两个或两个以上的代理接口包含一个具有相同名称和参数签名的方法时,代理类的接口的顺序变得很重要。当这样的</target>
        </trans-unit>
        <trans-unit id="f1f676950e16294bc9c468cad050677459c84e82" translate="yes" xml:space="preserve">
          <source>When two or more threads attempt to &lt;a href=&quot;#complete(T)&quot;&gt;&lt;code&gt;complete&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#completeExceptionally(java.lang.Throwable)&quot;&gt;&lt;code&gt;completeExceptionally&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;#cancel(boolean)&quot;&gt;&lt;code&gt;cancel&lt;/code&gt;&lt;/a&gt; a CompletableFuture, only one of them succeeds.</source>
          <target state="translated">当两个或多个线程尝试&lt;a href=&quot;#complete(T)&quot;&gt; &lt;code&gt;complete&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#completeExceptionally(java.lang.Throwable)&quot;&gt; &lt;code&gt;completeExceptionally&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#cancel(boolean)&quot;&gt; &lt;code&gt;cancel&lt;/code&gt; &lt;/a&gt;CompletableFuture时，只有其中一个成功。</target>
        </trans-unit>
        <trans-unit id="e2cbb5b6ffa96f013fd73efb6c2acd02f012d948" translate="yes" xml:space="preserve">
          <source>When two or more threads attempt to &lt;a href=&quot;completablefuture#complete-T-&quot;&gt;&lt;code&gt;complete&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;completablefuture#completeExceptionally-java.lang.Throwable-&quot;&gt;&lt;code&gt;completeExceptionally&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;completablefuture#cancel-boolean-&quot;&gt;&lt;code&gt;cancel&lt;/code&gt;&lt;/a&gt; a CompletableFuture, only one of them succeeds.</source>
          <target state="translated">当两个或多个线程尝试&lt;a href=&quot;completablefuture#complete-T-&quot;&gt; &lt;code&gt;complete&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;completablefuture#completeExceptionally-java.lang.Throwable-&quot;&gt; &lt;code&gt;completeExceptionally&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;completablefuture#cancel-boolean-&quot;&gt; &lt;code&gt;cancel&lt;/code&gt; &lt;/a&gt; CompletableFuture时，只有其中一个成功。</target>
        </trans-unit>
        <trans-unit id="58e55e5b4a52749f3a8f688b451a56c8f51e84a5" translate="yes" xml:space="preserve">
          <source>When used in &lt;a href=&quot;securerandom#getInstance(java.lang.String,java.security.SecureRandomParameters)&quot;&gt;&lt;code&gt;SecureRandom.getInstance(String, SecureRandomParameters)&lt;/code&gt;&lt;/a&gt; or one of the other similar &lt;code&gt;getInstance&lt;/code&gt; calls that take a &lt;code&gt;SecureRandomParameters&lt;/code&gt; parameter, it means the requested instantiate parameters the newly created &lt;code&gt;SecureRandom&lt;/code&gt; object must minimally support. When used as the return value of the &lt;a href=&quot;securerandom#getParameters()&quot;&gt;&lt;code&gt;SecureRandom.getParameters()&lt;/code&gt;&lt;/a&gt; method, it means the effective instantiate parameters of the &lt;code&gt;SecureRandom&lt;/code&gt; object.</source>
          <target state="translated">当在&lt;a href=&quot;securerandom#getInstance(java.lang.String,java.security.SecureRandomParameters)&quot;&gt; &lt;code&gt;SecureRandom.getInstance(String, SecureRandomParameters)&lt;/code&gt; &lt;/a&gt;或采用 &lt;code&gt;SecureRandomParameters&lt;/code&gt; 参数的其他类似 &lt;code&gt;getInstance&lt;/code&gt; 调用之一中使用时，这意味着新创建的 &lt;code&gt;SecureRandom&lt;/code&gt; 对象必须最低限度地支持所请求的实例化参数。当用作&lt;a href=&quot;securerandom#getParameters()&quot;&gt; &lt;code&gt;SecureRandom.getParameters()&lt;/code&gt; &lt;/a&gt;方法的返回值时，它表示 &lt;code&gt;SecureRandom&lt;/code&gt; 对象的有效实例化参数。</target>
        </trans-unit>
        <trans-unit id="43ffb4ecf968163232f09f73384f19b3a01bf3e9" translate="yes" xml:space="preserve">
          <source>When used in conjunction with the &lt;a href=&quot;formatter&quot;&gt;&lt;code&gt;Formatter&lt;/code&gt;&lt;/a&gt;, the above class produces the following output for various format strings.</source>
          <target state="translated">与&lt;a href=&quot;formatter&quot;&gt; &lt;code&gt;Formatter&lt;/code&gt; &lt;/a&gt;结合使用时，上述类为各种格式字符串产生以下输出。</target>
        </trans-unit>
        <trans-unit id="7e3a4f8ce8f2ce779cc7d5b71b65b0b477e564ce" translate="yes" xml:space="preserve">
          <source>When used in conjunction with the &lt;a href=&quot;formatter&quot;&gt;&lt;code&gt;Formatter&lt;/code&gt;&lt;/a&gt;, the above class produces the following output for various format strings. &lt;code&gt;Formatter fmt = new Formatter();
   StockName sn = new StockName(&quot;HUGE&quot;, &quot;Huge Fruit, Inc.&quot;,
                                &quot;Fruit Titanesque, Inc.&quot;);
   fmt.format(&quot;%s&quot;, sn);                   //   -&amp;gt; &quot;Huge Fruit, Inc.&quot;
   fmt.format(&quot;%s&quot;, sn.toString());        //   -&amp;gt; &quot;HUGE - Huge Fruit, Inc.&quot;
   fmt.format(&quot;%#s&quot;, sn);                  //   -&amp;gt; &quot;HUGE&quot;
   fmt.format(&quot;%-10.8s&quot;, sn);              //   -&amp;gt; &quot;HUGE      &quot;
   fmt.format(&quot;%.12s&quot;, sn);                //   -&amp;gt; &quot;Huge Fruit,*&quot;
   fmt.format(Locale.FRANCE, &quot;%25s&quot;, sn);  //   -&amp;gt; &quot;   Fruit Titanesque, Inc.&quot;
 &lt;/code&gt;</source>
          <target state="translated">与&lt;a href=&quot;formatter&quot;&gt; &lt;code&gt;Formatter&lt;/code&gt; &lt;/a&gt;结合使用时，上述类为各种格式字符串产生以下输出。 &lt;code&gt;Formatter fmt = new Formatter(); StockName sn = new StockName(&quot;HUGE&quot;, &quot;Huge Fruit, Inc.&quot;, &quot;Fruit Titanesque, Inc.&quot;); fmt.format(&quot;%s&quot;, sn); // -&amp;gt; &quot;Huge Fruit, Inc.&quot; fmt.format(&quot;%s&quot;, sn.toString()); // -&amp;gt; &quot;HUGE - Huge Fruit, Inc.&quot; fmt.format(&quot;%#s&quot;, sn); // -&amp;gt; &quot;HUGE&quot; fmt.format(&quot;%-10.8s&quot;, sn); // -&amp;gt; &quot;HUGE &quot; fmt.format(&quot;%.12s&quot;, sn); // -&amp;gt; &quot;Huge Fruit,*&quot; fmt.format(Locale.FRANCE, &quot;%25s&quot;, sn); // -&amp;gt; &quot; Fruit Titanesque, Inc.&quot; &lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="35a55ec2987f39f2327b6b1dee7f6dda3600a7d1" translate="yes" xml:space="preserve">
          <source>When used in the context of annotation processing, an accurate model of the element being represented must be returned. As this is a language model, the source code provides the fiducial (reference) representation of the construct in question rather than a representation in an executable output like a class file. Executable output may serve as the basis for creating a modeling element. However, the process of translating source code to executable output may not permit recovering some aspects of the source code representation. For example, annotations with &lt;a href=&quot;../../../../../java.base/java/lang/annotation/retentionpolicy#SOURCE&quot;&gt;source&lt;/a&gt;&lt;a href=&quot;../../../../../java.base/java/lang/annotation/retention&quot;&gt;retention&lt;/a&gt; cannot be recovered from class files and class files might not be able to provide source position information. Names of parameters may not be recoverable from class files. The &lt;a href=&quot;modifier&quot;&gt;modifiers&lt;/a&gt; on an element created from a class file may differ in some cases from an element for the same declaration created from a source file including:</source>
          <target state="translated">在注释处理的上下文中使用时，必须返回所表示元素的精确模型。由于这是语言模型，因此源代码提供了所讨论结构的基准（参考）表示形式，而不是可执行输出（如类文件）中的表示形式。可执行输出可以用作创建建模元素的基础。但是，将源代码转换为可执行输出的过程可能不允许恢复源代码表示的某些方面。例如，带有&lt;a href=&quot;../../../../../java.base/java/lang/annotation/retentionpolicy#SOURCE&quot;&gt;源&lt;/a&gt;&lt;a href=&quot;../../../../../java.base/java/lang/annotation/retention&quot;&gt;保留的&lt;/a&gt;注释不能从类文件中恢复，并且类文件可能无法提供源位置信息。参数名称可能无法从类文件中恢复。该&lt;a href=&quot;modifier&quot;&gt;修饰符&lt;/a&gt; 从类文件创建的元素上的声明在某些情况下可能与从源文件创建的同一声明的元素不同，包括：</target>
        </trans-unit>
        <trans-unit id="ece0b7fb1ed791cbe7da72a2d53b96e1e02fbd42" translate="yes" xml:space="preserve">
          <source>When used in the context of annotation processing, an accurate model of the element being represented must be returned. As this is a language model, the source code provides the fiducial (reference) representation of the construct in question rather than a representation in an executable output like a class file. Executable output may serve as the basis for creating a modeling element. However, the process of translating source code to executable output may not permit recovering some aspects of the source code representation. For example, annotations with &lt;a href=&quot;../../../../java/lang/annotation/retentionpolicy#SOURCE&quot;&gt;source&lt;/a&gt;&lt;a href=&quot;../../../../java/lang/annotation/retention&quot;&gt;retention&lt;/a&gt; cannot be recovered from class files and class files might not be able to provide source position information. Names of parameters may not be recoverable from class files. The &lt;a href=&quot;modifier&quot;&gt;modifiers&lt;/a&gt; on an element may differ in some cases including:</source>
          <target state="translated">在注释处理的上下文中使用时，必须返回所表示元素的精确模型。由于这是语言模型，因此源代码提供了所讨论结构的基准（参考）表示形式，而不是可执行输出（如类文件）中的表示形式。可执行输出可以用作创建建模元素的基础。但是，将源代码转换为可执行输出的过程可能不允许恢复源代码表示的某些方面。例如，带有&lt;a href=&quot;../../../../java/lang/annotation/retentionpolicy#SOURCE&quot;&gt;源&lt;/a&gt;&lt;a href=&quot;../../../../java/lang/annotation/retention&quot;&gt;保留的&lt;/a&gt;注释不能从类文件中恢复，并且类文件可能无法提供源位置信息。参数名称可能无法从类文件中恢复。该&lt;a href=&quot;modifier&quot;&gt;修饰符&lt;/a&gt; 在某些情况下，元素上的可能有所不同，包括：</target>
        </trans-unit>
        <trans-unit id="6ecb08ff72bf2beff0f22f91d00d7f8a358093b0" translate="yes" xml:space="preserve">
          <source>When used with other calendar systems it must correspond to an integral number of days and is normally an integral number of years.</source>
          <target state="translated">当与其他历法一起使用时,它必须对应一个整数天,通常是一个整数年。</target>
        </trans-unit>
        <trans-unit id="f21fcfe8b96da09eeaeaa464fe8fd54f0f415d2c" translate="yes" xml:space="preserve">
          <source>When used with other calendar systems it must correspond to an integral number of days or months roughly equal to a year defined by the passage of the Earth around the Sun.</source>
          <target state="translated">当与其他历法一起使用时,它必须对应于一个完整的日数或月数,大致等于地球绕太阳运行的一年。</target>
        </trans-unit>
        <trans-unit id="a27413589719b5a8253a0b8d9af0f9739bd28a5f" translate="yes" xml:space="preserve">
          <source>When used with other calendar systems it must correspond to an integral number of days.</source>
          <target state="translated">当与其他日历系统一起使用时,它必须对应于一个完整的天数。</target>
        </trans-unit>
        <trans-unit id="9efada4e2737579f4bfde83c300d21f0a7943686" translate="yes" xml:space="preserve">
          <source>When used with other calendar systems it must correspond to the day defined by the rising and setting of the Sun on Earth. It is not required that days begin at midnight - when converting between calendar systems, the date should be equivalent at midday.</source>
          <target state="translated">当与其他历法一起使用时,它必须对应于地球上太阳升起和落下所定义的一天。日子不需要从午夜开始 ----当在不同历法之间转换时,日期应与正午相当。</target>
        </trans-unit>
        <trans-unit id="62385eeb0c56551d6fa61230b23e3cea9e372c16" translate="yes" xml:space="preserve">
          <source>When used with other calendar systems there are no restrictions on the unit.</source>
          <target state="translated">当与其他日历系统一起使用时,对设备没有任何限制。</target>
        </trans-unit>
        <trans-unit id="62abbe6041a1324368c7391f51baabfb09713986" translate="yes" xml:space="preserve">
          <source>When used with the GSSContext interface's wrap and getMIC methods, an instance of this class is used to indicate the desired Quality-of-Protection (QOP) and to request if confidentiality services are to be applied to caller supplied data (wrap only). To request default QOP, the value of 0 should be used for QOP.</source>
          <target state="translated">当与GSSContext接口的wrap和getMIC方法一起使用时,该类的实例用于指示所需的保护质量(QOP),并请求是否对调用者提供的数据应用保密性服务(仅wrap)。要请求默认的QOP,QOP的值应使用0。</target>
        </trans-unit>
        <trans-unit id="313c2c16bb6b15d1f21bba9cb9b9b5bc5566a742" translate="yes" xml:space="preserve">
          <source>When used with the unwrap and verifyMIC methods of the GSSContext interface, an instance of this class will be used to indicate the applied QOP and confidentiality services over the supplied message. In the case of verifyMIC, the confidentiality state will always be &lt;code&gt;false&lt;/code&gt;. Upon return from these methods, this object will also contain any supplementary status values applicable to the processed token. The supplementary status values can indicate old tokens, out of sequence tokens, gap tokens or duplicate tokens.</source>
          <target state="translated">当与GSSContext接口的unwrap和verifyMIC方法一起使用时，此类的实例将用于指示在提供的消息上应用的QOP和机密性服务。在verifyMIC的情况下，机密状态将始终为 &lt;code&gt;false&lt;/code&gt; 。从这些方法返回后，该对象还将包含适用于已处理令牌的任何补充状态值。补充状态值可以指示旧令牌，乱序令牌，间隙令牌或重复令牌。</target>
        </trans-unit>
        <trans-unit id="9e6a51ecf8fcb17dbda43fef7e1c274e8aff30af" translate="yes" xml:space="preserve">
          <source>When used, this method changes the parsing to be lenient from this point onwards. The change will remain in force until the end of the formatter that is eventually constructed or until &lt;code&gt;parseStrict&lt;/code&gt; is called.</source>
          <target state="translated">从那时起，使用此方法时，将解析更改为宽松。更改将一直生效，直到最终构造的格式化程序结束或调用 &lt;code&gt;parseStrict&lt;/code&gt; 为止。</target>
        </trans-unit>
        <trans-unit id="ff556f1f879598b7bb76a699a0aec5ddb4224db2" translate="yes" xml:space="preserve">
          <source>When used, this method changes the parsing to be strict from this point onwards. As strict is the default, this is normally only needed after calling &lt;a href=&quot;#parseLenient()&quot;&gt;&lt;code&gt;parseLenient()&lt;/code&gt;&lt;/a&gt;. The change will remain in force until the end of the formatter that is eventually constructed or until &lt;code&gt;parseLenient&lt;/code&gt; is called.</source>
          <target state="translated">从此以后，使用此方法时，将解析更改为严格。由于默认值是严格的，因此通常仅在调用&lt;a href=&quot;#parseLenient()&quot;&gt; &lt;code&gt;parseLenient()&lt;/code&gt; &lt;/a&gt;之后才需要这样做。更改将一直有效，直到最终构造的格式化程序结束或调用 &lt;code&gt;parseLenient&lt;/code&gt; 为止。</target>
        </trans-unit>
        <trans-unit id="5af032fc78d26434042d41d26faa4d468835b7bf" translate="yes" xml:space="preserve">
          <source>When used, this method changes the parsing to be strict from this point onwards. As strict is the default, this is normally only needed after calling &lt;a href=&quot;datetimeformatterbuilder#parseLenient--&quot;&gt;&lt;code&gt;parseLenient()&lt;/code&gt;&lt;/a&gt;. The change will remain in force until the end of the formatter that is eventually constructed or until &lt;code&gt;parseLenient&lt;/code&gt; is called.</source>
          <target state="translated">从那时起，使用此方法时，将解析更改为严格。默认情况下严格，通常仅在调用&lt;a href=&quot;datetimeformatterbuilder#parseLenient--&quot;&gt; &lt;code&gt;parseLenient()&lt;/code&gt; &lt;/a&gt;之后才需要这样做。更改将一直有效，直到最终构造的格式化程序结束或调用 &lt;code&gt;parseLenient&lt;/code&gt; 为止。</target>
        </trans-unit>
        <trans-unit id="3bea6a91a61ac47b8bd9736fff1365a319fd7ad0" translate="yes" xml:space="preserve">
          <source>When using a capacity-restricted deque, it is generally preferable to call &lt;a href=&quot;#offer(E)&quot;&gt;&lt;code&gt;offer&lt;/code&gt;&lt;/a&gt; separately on each element.</source>
          <target state="translated">使用容量受限的双端队列时，通常最好在每个元素上分别调用&lt;a href=&quot;#offer(E)&quot;&gt; &lt;code&gt;offer&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="da316a4cc51c1899088ef95b5f213463772f58cf" translate="yes" xml:space="preserve">
          <source>When using a loader's &lt;a href=&quot;serviceloader#stream()&quot;&gt;&lt;code&gt;stream()&lt;/code&gt;&lt;/a&gt; method then the elements are of type &lt;code&gt;Provider&lt;/code&gt;. This allows processing to select or filter on the provider class without instantiating the provider.</source>
          <target state="translated">使用加载程序的&lt;a href=&quot;serviceloader#stream()&quot;&gt; &lt;code&gt;stream()&lt;/code&gt; &lt;/a&gt;方法时，元素的类型为 &lt;code&gt;Provider&lt;/code&gt; 。这允许处理过程在不实例化提供程序的情况下选择或筛选提供程序类。</target>
        </trans-unit>
        <trans-unit id="31ca175d1f09c132ed4a2c9c0157e1e350eb6ede" translate="yes" xml:space="preserve">
          <source>When using the IIOP transport, the client and server can specify what ORB to use with the attribute &lt;code&gt;java.naming.corba.orb&lt;/code&gt;. Connection to the ORB happens at &lt;a href=&quot;rmiconnectorserver#start--&quot;&gt;&lt;code&gt;start&lt;/code&gt;&lt;/a&gt; time for the connector server, and at &lt;a href=&quot;rmiconnector#connect-java.util.Map-&quot;&gt;&lt;code&gt;connect&lt;/code&gt;&lt;/a&gt; time for the connector client. If the &lt;code&gt;java.naming.corba.orb&lt;/code&gt; attribute is contained in the environment Map, then its value (an &lt;a href=&quot;/openjdk~8_web/org/omg/corba/orb&quot;&gt;&lt;code&gt;ORB&lt;/code&gt;&lt;/a&gt;), is used to connect the IIOP Stubs. Otherwise, a new org.omg.CORBA.ORB is created by calling &lt;a href=&quot;/openjdk~8_web/org/omg/corba/orb&quot;&gt;&lt;code&gt;org.omg.CORBA.ORB.init((String[])null,(Properties)null)&lt;/code&gt;&lt;/a&gt;. A later RMI connector client or server in the same JVM can reuse this ORB, or it can create another one in the same way.</source>
          <target state="translated">使用IIOP传输时，客户端和服务器可以使用属性 &lt;code&gt;java.naming.corba.orb&lt;/code&gt; 指定要使用的ORB 。连接器服务器的&lt;a href=&quot;rmiconnectorserver#start--&quot;&gt; &lt;code&gt;start&lt;/code&gt; &lt;/a&gt;时间和&lt;a href=&quot;rmiconnector#connect-java.util.Map-&quot;&gt; &lt;code&gt;connect&lt;/code&gt; &lt;/a&gt;器客户端的连接时间都发生与ORB 的连接。如果环境Map中包含 &lt;code&gt;java.naming.corba.orb&lt;/code&gt; 属性，则使用其值（&lt;a href=&quot;/openjdk~8_web/org/omg/corba/orb&quot;&gt; &lt;code&gt;ORB&lt;/code&gt; &lt;/a&gt;）来连接IIOP Stub。否则，通过调用&lt;a href=&quot;/openjdk~8_web/org/omg/corba/orb&quot;&gt; &lt;code&gt;org.omg.CORBA.ORB.init((String[])null,(Properties)null)&lt;/code&gt; &lt;/a&gt;来创建新的org.omg.CORBA.ORB 。同一JVM中的更高版本的RMI连接器客户端或服务器可以重用此ORB，也可以以相同的方式创建另一个ORB。</target>
        </trans-unit>
        <trans-unit id="1094d843de7943a57b50e6ec3d12297784b464f6" translate="yes" xml:space="preserve">
          <source>When using the beanName as a serialized object name we convert the given beanName to a resource pathname and add a trailing &quot;.ser&quot; suffix. We then try to load a serialized object from that resource.</source>
          <target state="translated">当使用beanName作为序列化对象名称时,我们将给定的beanName转换为资源路径名,并在后面添加&quot;.ser &quot;后缀。然后我们尝试从该资源中加载一个序列化对象。</target>
        </trans-unit>
        <trans-unit id="a40a619f30648218521f9a9f35ae6461ea88f8ec" translate="yes" xml:space="preserve">
          <source>When using the default JRMP transport, RMI socket factories can be specified using the attributes &lt;code&gt;jmx.remote.rmi.client.socket.factory&lt;/code&gt; and &lt;code&gt;jmx.remote.rmi.server.socket.factory&lt;/code&gt; in the &lt;code&gt;environment&lt;/code&gt; given to the &lt;code&gt;RMIConnectorServer&lt;/code&gt; constructor. The values of these attributes must be of type &lt;a href=&quot;../../../../../java.rmi/java/rmi/server/rmiclientsocketfactory&quot;&gt;&lt;code&gt;RMIClientSocketFactory&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../../../../java.rmi/java/rmi/server/rmiserversocketfactory&quot;&gt;&lt;code&gt;RMIServerSocketFactory&lt;/code&gt;&lt;/a&gt;, respectively. These factories are used when creating the RMI objects associated with the connector.</source>
          <target state="translated">使用默认的JRMP传输时，可以在给 &lt;code&gt;RMIConnectorServer&lt;/code&gt; 构造函数的 &lt;code&gt;environment&lt;/code&gt; 使用属性 &lt;code&gt;jmx.remote.rmi.client.socket.factory&lt;/code&gt; 和 &lt;code&gt;jmx.remote.rmi.server.socket.factory&lt;/code&gt; 指定RMI套接字工厂。这些属性的值必须分别为&lt;a href=&quot;../../../../../java.rmi/java/rmi/server/rmiclientsocketfactory&quot;&gt; &lt;code&gt;RMIClientSocketFactory&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../../../../java.rmi/java/rmi/server/rmiserversocketfactory&quot;&gt; &lt;code&gt;RMIServerSocketFactory&lt;/code&gt; &lt;/a&gt;类型。这些工厂在创建与连接器关联的RMI对象时使用。</target>
        </trans-unit>
        <trans-unit id="9b289c10690d3b720cf943c114f2a703d731c855" translate="yes" xml:space="preserve">
          <source>When using the default JRMP transport, RMI socket factories can be specified using the attributes &lt;code&gt;jmx.remote.rmi.client.socket.factory&lt;/code&gt; and &lt;code&gt;jmx.remote.rmi.server.socket.factory&lt;/code&gt; in the &lt;code&gt;environment&lt;/code&gt; given to the &lt;code&gt;RMIConnectorServer&lt;/code&gt; constructor. The values of these attributes must be of type &lt;a href=&quot;/openjdk~8_web/java/rmi/server/rmiclientsocketfactory&quot;&gt;&lt;code&gt;RMIClientSocketFactory&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;/openjdk~8_web/java/rmi/server/rmiserversocketfactory&quot;&gt;&lt;code&gt;RMIServerSocketFactory&lt;/code&gt;&lt;/a&gt;, respectively. These factories are used when creating the RMI objects associated with the connector.</source>
          <target state="translated">使用默认的JRMP传输时，可以在给 &lt;code&gt;RMIConnectorServer&lt;/code&gt; 构造函数的 &lt;code&gt;environment&lt;/code&gt; 使用属性 &lt;code&gt;jmx.remote.rmi.client.socket.factory&lt;/code&gt; 和 &lt;code&gt;jmx.remote.rmi.server.socket.factory&lt;/code&gt; 指定RMI套接字工厂。这些属性的值必须分别为&lt;a href=&quot;/openjdk~8_web/java/rmi/server/rmiclientsocketfactory&quot;&gt; &lt;code&gt;RMIClientSocketFactory&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;/openjdk~8_web/java/rmi/server/rmiserversocketfactory&quot;&gt; &lt;code&gt;RMIServerSocketFactory&lt;/code&gt; &lt;/a&gt;类型。创建与连接器关联的RMI对象时，将使用这些工厂。</target>
        </trans-unit>
        <trans-unit id="5e657ee77256cf44030f873d13206c74a10610ec" translate="yes" xml:space="preserve">
          <source>When using the service loader's &lt;code&gt;iterator&lt;/code&gt;, the &lt;a href=&quot;iterator#hasNext()&quot;&gt;&lt;code&gt;hasNext&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;iterator#next()&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; methods will fail with &lt;a href=&quot;serviceconfigurationerror&quot;&gt;&lt;code&gt;ServiceConfigurationError&lt;/code&gt;&lt;/a&gt; if an error occurs locating, loading or instantiating a service provider. When processing the service loader's stream then &lt;code&gt;ServiceConfigurationError&lt;/code&gt; may be thrown by any method that causes a service provider to be located or loaded.</source>
          <target state="translated">使用服务加载程序的 &lt;code&gt;iterator&lt;/code&gt; ，如果在查找，加载或实例化服务提供程序时发生错误，则&lt;a href=&quot;iterator#hasNext()&quot;&gt; &lt;code&gt;hasNext&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;iterator#next()&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt;方法将失败，并出现&lt;a href=&quot;serviceconfigurationerror&quot;&gt; &lt;code&gt;ServiceConfigurationError&lt;/code&gt; &lt;/a&gt;。在处理服务加载程序的流时，任何导致定位或加载服务提供程序的方法都可能引发 &lt;code&gt;ServiceConfigurationError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ba566ef2656d9a242d602964e496b4d893948bab" translate="yes" xml:space="preserve">
          <source>When using this constructor, the Namespace URI is set to &lt;a href=&quot;../xmlconstants#NULL_NS_URI&quot;&gt;&lt;code&gt;XMLConstants.NULL_NS_URI&lt;/code&gt;&lt;/a&gt; and the prefix is set to &lt;a href=&quot;../xmlconstants#DEFAULT_NS_PREFIX&quot;&gt;&lt;code&gt;XMLConstants.DEFAULT_NS_PREFIX&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">使用此构造函数时，名称空间URI设置为&lt;a href=&quot;../xmlconstants#NULL_NS_URI&quot;&gt; &lt;code&gt;XMLConstants.NULL_NS_URI&lt;/code&gt; &lt;/a&gt;，前缀设置为&lt;a href=&quot;../xmlconstants#DEFAULT_NS_PREFIX&quot;&gt; &lt;code&gt;XMLConstants.DEFAULT_NS_PREFIX&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="96c5642595e980fed49cb21924a5425817039bc3" translate="yes" xml:space="preserve">
          <source>When using this constructor, the prefix is set to &lt;a href=&quot;../xmlconstants#DEFAULT_NS_PREFIX&quot;&gt;&lt;code&gt;XMLConstants.DEFAULT_NS_PREFIX&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">使用此构造函数时，前缀设置为&lt;a href=&quot;../xmlconstants#DEFAULT_NS_PREFIX&quot;&gt; &lt;code&gt;XMLConstants.DEFAULT_NS_PREFIX&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e87d4e305eeee8d02bfe9d7476f259cac952cdb2" translate="yes" xml:space="preserve">
          <source>When viewed as a character sequence, the length of a character buffer is simply the number of characters between the position (inclusive) and the limit (exclusive); that is, it is equivalent to &lt;code&gt;remaining()&lt;/code&gt;.</source>
          <target state="translated">当作为字符序列查看时，字符缓冲区的长度就是位置（含）和限制（不含）之间的字符数。也就是说，它等同于 &lt;code&gt;remaining()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b74b06615a3effa44bf4fa9888e60a5a1492ac50" translate="yes" xml:space="preserve">
          <source>When viewed as a member of a third type &lt;code&gt;C&lt;/code&gt;, however, the method in &lt;code&gt;A&lt;/code&gt; does override the one in &lt;code&gt;B&lt;/code&gt;:</source>
          <target state="translated">但是，当被视为第三种类型 &lt;code&gt;C&lt;/code&gt; 的成员时， &lt;code&gt;A&lt;/code&gt; 中的方法确实会覆盖 &lt;code&gt;B&lt;/code&gt; 中的方法：</target>
        </trans-unit>
        <trans-unit id="70641d46fc36740d8882e1912ac1db22e717a0cd" translate="yes" xml:space="preserve">
          <source>When waiting upon a &lt;code&gt;Condition&lt;/code&gt;, a &quot;&lt;em&gt;spurious wakeup&lt;/em&gt;&quot; is permitted to occur, in general, as a concession to the underlying platform semantics. This has little practical impact on most application programs as a &lt;code&gt;Condition&lt;/code&gt; should always be waited upon in a loop, testing the state predicate that is being waited for. An implementation is free to remove the possibility of spurious wakeups but it is recommended that applications programmers always assume that they can occur and so always wait in a loop.</source>
          <target state="translated">当等待 &lt;code&gt;Condition&lt;/code&gt; 时，通常会允许&amp;ldquo; &lt;em&gt;虚假唤醒&lt;/em&gt; &amp;rdquo;，作为对底层平台语义的让步。这对大多数应用程序几乎没有实际影响，因为应该始终在循环中等待一个 &lt;code&gt;Condition&lt;/code&gt; ，测试正在等待的状态谓词。一个实现是免费的，可以消除虚假唤醒的可能性，但是建议应用程序程序员始终假定它们会发生，因此总是在循环中等待。</target>
        </trans-unit>
        <trans-unit id="4246b2cc19c9676bfe631da16932f916fd42e34e" translate="yes" xml:space="preserve">
          <source>When warnings/errors/fatal errors are found by the validator, the parser must handle them as if those errors were found by the parser itself. In other words, if the user-specified &lt;a href=&quot;../../../org/xml/sax/errorhandler&quot;&gt;&lt;code&gt;ErrorHandler&lt;/code&gt;&lt;/a&gt; is set, it must receive those errors, and if not, they must be treated according to the implementation specific default error handling rules.</source>
          <target state="translated">当验证器发现警告/错误/重大错误时，解析器必须像解析器本身发现的那些错误一样对它们进行处理。换句话说，如果设置了用户指定的&lt;a href=&quot;../../../org/xml/sax/errorhandler&quot;&gt; &lt;code&gt;ErrorHandler&lt;/code&gt; &lt;/a&gt;，则它必须接收那些错误，如果没有，则必须根据实现特定的默认错误处理规则对其进行处理。</target>
        </trans-unit>
        <trans-unit id="4b65ea9216658615a74fbadc89129a9320a6d2b4" translate="yes" xml:space="preserve">
          <source>When writing a multi-threaded application using Swing, there are two constraints to keep in mind: (refer to &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/concurrency/index.html&quot;&gt; Concurrency in Swing &lt;/a&gt; for more details):</source>
          <target state="translated">使用Swing编写多线程应用程序时，要牢记两个约束：（有关更多详细信息，请参见&lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/concurrency/index.html&quot;&gt;Swing中的并发性&lt;/a&gt;）：</target>
        </trans-unit>
        <trans-unit id="820acf1a539f093ef923cbe7206d4636f08ce510" translate="yes" xml:space="preserve">
          <source>When writing a multi-threaded application using Swing, there are two constraints to keep in mind: (refer to &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/uiswing/concurrency/index.html&quot;&gt; Concurrency in Swing &lt;/a&gt; for more details):</source>
          <target state="translated">使用Swing编写多线程应用程序时，要牢记两个约束：（有关更多详细信息，请参见&lt;a href=&quot;https://docs.oracle.com/javase/tutorial/uiswing/concurrency/index.html&quot;&gt;Swing中的并发性&lt;/a&gt;）：</target>
        </trans-unit>
        <trans-unit id="50097f566388737a84366cf10ac13d1ccd775d2d" translate="yes" xml:space="preserve">
          <source>When writing an image, its metadata may be set by defining or modifying an &lt;code&gt;IIOMetadata&lt;/code&gt; object. Such an object may be obtained from an &lt;code&gt;ImageWriter&lt;/code&gt; or &lt;code&gt;ImageTranscoder&lt;/code&gt; (from the &lt;code&gt;javax.imageio&lt;/code&gt; package). Once such an object has been obtained, its contents may be set of modified via a &lt;code&gt;Document&lt;/code&gt; consisting of &lt;code&gt;IIOMetadataNode&lt;/code&gt;s. The document format may optionally be described using an &lt;code&gt;IIOMetadataFormat&lt;/code&gt; object.</source>
          <target state="translated">写入图像时，可以通过定义或修改 &lt;code&gt;IIOMetadata&lt;/code&gt; 对象来设置其元数据。可以从 &lt;code&gt;ImageWriter&lt;/code&gt; 或 &lt;code&gt;ImageTranscoder&lt;/code&gt; （从 &lt;code&gt;javax.imageio&lt;/code&gt; 包）获得此类对象。一旦获得了这样的对象，就可以通过由 &lt;code&gt;IIOMetadataNode&lt;/code&gt; 组成的 &lt;code&gt;Document&lt;/code&gt; 修改其内容集。可以选择使用 &lt;code&gt;IIOMetadataFormat&lt;/code&gt; 对象描述文档格式。</target>
        </trans-unit>
        <trans-unit id="539a87ee8e580df1a3e2f775f3342dcf0824a272" translate="yes" xml:space="preserve">
          <source>When writing code that manipulates memory segments, especially if backed by memory which resides outside the Java heap, it is crucial that the resources associated with a memory segment are released when the segment is no longer in use, by calling the &lt;a href=&quot;memorysegment#close()&quot;&gt;&lt;code&gt;MemorySegment.close()&lt;/code&gt;&lt;/a&gt; method either explicitly, or implicitly, by relying on try-with-resources construct (as demonstrated in the example above). Closing a given memory segment is an &lt;em&gt;atomic&lt;/em&gt; operation which can either succeed - and result in the underlying memory associated with the segment to be released, or &lt;em&gt;fail&lt;/em&gt; with an exception.</source>
          <target state="translated">在编写用于操纵内存段的代码时，尤其是当内存驻留在Java堆之外时，尤其是当不再使用该内存段时，必须通过调用&lt;a href=&quot;memorysegment#close()&quot;&gt; &lt;code&gt;MemorySegment.close()&lt;/code&gt; &lt;/a&gt;释放与内存段关联的资源，这一点至关重要。通过依赖try-with-resources构造（如上例所示）显式或隐式地使用此方法。关闭给定的内存段是一项&lt;em&gt;原子&lt;/em&gt;操作，它可以成功执行-并导致与该段相关联的基础内存被释放，或者因异常而&lt;em&gt;失败&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="44b4a60f0d785ceae4f2f44785b50fadd22e0a67" translate="yes" xml:space="preserve">
          <source>When writing to a &lt;code&gt;LSOutput&lt;/code&gt;, the encoding is found by looking at the encoding information that is reachable through the &lt;code&gt;LSOutput&lt;/code&gt; and the item to be written (or its owner document) in this order:</source>
          <target state="translated">写入 &lt;code&gt;LSOutput&lt;/code&gt; 时，通过按以下 &lt;code&gt;LSOutput&lt;/code&gt; 通过LSOutput和要写入的项目（或其所有者文档）可到达的编码信息来找到编码：</target>
        </trans-unit>
        <trans-unit id="d2afab89366cad1e703d500543bdeff2a26cf52f" translate="yes" xml:space="preserve">
          <source>When writing to a HTTP URI, a HTTP PUT is performed. When writing to other types of URIs, the mechanism for writing the data to the URI is implementation dependent.</source>
          <target state="translated">当写入HTTP URI时,会执行HTTP PUT。当写入其他类型的URI时,向URI写入数据的机制取决于实现。</target>
        </trans-unit>
        <trans-unit id="da3859e404597e0949c5fd1f7d9550737c714ec5" translate="yes" xml:space="preserve">
          <source>When writing, an &lt;a href=&quot;../../metadata/iiometadata&quot;&gt;&lt;code&gt;IIOMetadata&lt;/code&gt;&lt;/a&gt; object for use by one of the &lt;code&gt;write()&lt;/code&gt; methods of &lt;a href=&quot;../../imagewriter&quot;&gt;&lt;code&gt;ImageWriter&lt;/code&gt;&lt;/a&gt; may be created from a &lt;code&gt;TIFFDirectory&lt;/code&gt; by &lt;a href=&quot;#getAsMetadata()&quot;&gt;&lt;code&gt;getAsMetadata()&lt;/code&gt;&lt;/a&gt;. The &lt;code&gt;TIFFDirectory&lt;/code&gt; itself may be created by construction or from the &lt;code&gt;IIOMetadata&lt;/code&gt; object returned by &lt;a href=&quot;../../imagewriter#getDefaultImageMetadata(javax.imageio.ImageTypeSpecifier,javax.imageio.ImageWriteParam)&quot;&gt;&lt;code&gt;ImageWriter.getDefaultImageMetadata()&lt;/code&gt;&lt;/a&gt;. The &lt;code&gt;TIFFField&lt;/code&gt;s in the directory may be set using the mutator methods provided in this class.</source>
          <target state="translated">写入时，可以通过&lt;a href=&quot;#getAsMetadata()&quot;&gt; &lt;code&gt;getAsMetadata()&lt;/code&gt; &lt;/a&gt;从 &lt;code&gt;TIFFDirectory&lt;/code&gt; 创建供&lt;a href=&quot;../../imagewriter&quot;&gt; &lt;code&gt;ImageWriter&lt;/code&gt; &lt;/a&gt;的 &lt;code&gt;write()&lt;/code&gt; 方法之一使用的&lt;a href=&quot;../../metadata/iiometadata&quot;&gt; &lt;code&gt;IIOMetadata&lt;/code&gt; &lt;/a&gt;对象。所述 &lt;code&gt;TIFFDirectory&lt;/code&gt; 本身可以通过构造或从被创建 &lt;code&gt;IIOMetadata&lt;/code&gt; 由返回的对象&lt;a href=&quot;../../imagewriter#getDefaultImageMetadata(javax.imageio.ImageTypeSpecifier,javax.imageio.ImageWriteParam)&quot;&gt; &lt;code&gt;ImageWriter.getDefaultImageMetadata()&lt;/code&gt; &lt;/a&gt;。可以使用此类中提供的mutator方法设置目录中的 &lt;code&gt;TIFFField&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eea2b78361ef1f62a351050fb4d8e084b0419681" translate="yes" xml:space="preserve">
          <source>When writing, the destination type maybe used to determine the color type of the image. The &lt;code&gt;SampleModel&lt;/code&gt; information will be ignored, and may be &lt;code&gt;null&lt;/code&gt;. For example, a 4-banded image could represent either CMYK or RGBA data. If a destination type is set, its &lt;code&gt;ColorModel&lt;/code&gt; will override any &lt;code&gt;ColorModel&lt;/code&gt; on the image itself. This is crucial when &lt;code&gt;setSourceBands&lt;/code&gt; is used since the image's &lt;code&gt;ColorModel&lt;/code&gt; will refer to the entire image rather than to the subset of bands being written.</source>
          <target state="translated">写入时，目标类型可用于确定图像的颜色类型。该 &lt;code&gt;SampleModel&lt;/code&gt; 中的信息将被忽略，并且可以是 &lt;code&gt;null&lt;/code&gt; 。例如，一个4带图像可以表示CMYK或RGBA数据。如果设置了目标类型，则其 &lt;code&gt;ColorModel&lt;/code&gt; 将覆盖图像本身上的任何 &lt;code&gt;ColorModel&lt;/code&gt; 。当使用 &lt;code&gt;setSourceBands&lt;/code&gt; 时，这是至关重要的，因为图像的 &lt;code&gt;ColorModel&lt;/code&gt; 将引用整个图像，而不是所写带的子集。</target>
        </trans-unit>
        <trans-unit id="9a6b169cf5cbb999580ca1588fd37eab8e71b189" translate="yes" xml:space="preserve">
          <source>When you create an initial context (&lt;code&gt;InitialLdapContext&lt;/code&gt;), you can specify a list of request controls. These controls will be used as the request controls for any implicit LDAP &quot;bind&quot; operation performed by the context or contexts derived from the context. These are called &lt;em&gt;connection request controls&lt;/em&gt;. Use &lt;code&gt;getConnectControls()&lt;/code&gt; to get a context's connection request controls.</source>
          <target state="translated">创建初始上下文（ &lt;code&gt;InitialLdapContext&lt;/code&gt; ）时，可以指定请求控件列表。这些控件将用作由上下文或从上下文派生的上下文执行的任何隐式LDAP&amp;ldquo;绑定&amp;rdquo;操作的请求控件。这些称为&lt;em&gt;连接请求控件&lt;/em&gt;。使用 &lt;code&gt;getConnectControls()&lt;/code&gt; 获取上下文的连接请求控件。</target>
        </trans-unit>
        <trans-unit id="7a55210ed8a9bbd91ed99904496d79d9e437e1c1" translate="yes" xml:space="preserve">
          <source>When you request this property, &lt;code&gt;LabelView&lt;/code&gt; re-syncs its state with the properties of the &lt;code&gt;Element&lt;/code&gt;'s &lt;code&gt;AttributeSet&lt;/code&gt;. If &lt;code&gt;Element&lt;/code&gt;'s &lt;code&gt;AttributeSet&lt;/code&gt; does not have this property set, it will revert to false.</source>
          <target state="translated">当您请求此属性时， &lt;code&gt;LabelView&lt;/code&gt; 会将其状态与 &lt;code&gt;Element&lt;/code&gt; 的 &lt;code&gt;AttributeSet&lt;/code&gt; 的属性重新同步。如果 &lt;code&gt;Element&lt;/code&gt; 的 &lt;code&gt;AttributeSet&lt;/code&gt; 没有设置此属性，它将恢复为false。</target>
        </trans-unit>
        <trans-unit id="76c291d7ec2e2a61da9c355ee091458c7391b573" translate="yes" xml:space="preserve">
          <source>When you want the &lt;code&gt;SwingWorker&lt;/code&gt; to block on the</source>
          <target state="translated">当您希望 &lt;code&gt;SwingWorker&lt;/code&gt; 阻止</target>
        </trans-unit>
        <trans-unit id="221e0f97f37cb411d57af917bcf79190807898c6" translate="yes" xml:space="preserve">
          <source>When your program needs a locale-specific object, it loads the &lt;code&gt;ResourceBundle&lt;/code&gt; class using the &lt;a href=&quot;#getBundle(java.lang.String,java.util.Locale)&quot;&gt;&lt;code&gt;getBundle&lt;/code&gt;&lt;/a&gt; method:</source>
          <target state="translated">当您的程序需要特定于语言环境的对象时，它将使用&lt;a href=&quot;#getBundle(java.lang.String,java.util.Locale)&quot;&gt; &lt;code&gt;getBundle&lt;/code&gt; &lt;/a&gt;方法加载 &lt;code&gt;ResourceBundle&lt;/code&gt; 类：</target>
        </trans-unit>
        <trans-unit id="f5d6850ccbdf18f11fe78451acaa45891ec324a4" translate="yes" xml:space="preserve">
          <source>When your program needs a locale-specific object, it loads the &lt;code&gt;ResourceBundle&lt;/code&gt; class using the &lt;a href=&quot;resourcebundle#getBundle-java.lang.String-java.util.Locale-&quot;&gt;&lt;code&gt;getBundle&lt;/code&gt;&lt;/a&gt; method:</source>
          <target state="translated">当您的程序需要特定于语言环境的对象时，它将使用&lt;a href=&quot;resourcebundle#getBundle-java.lang.String-java.util.Locale-&quot;&gt; &lt;code&gt;getBundle&lt;/code&gt; &lt;/a&gt;方法加载 &lt;code&gt;ResourceBundle&lt;/code&gt; 类：</target>
        </trans-unit>
        <trans-unit id="294687126fefbc03d977b1180723b4fd8063c95a" translate="yes" xml:space="preserve">
          <source>Whenever a permission is added to a heterogeneous PermissionCollection such as Permissions, and the PermissionCollection doesn't yet contain a PermissionCollection of the specified permission's type, the PermissionCollection should call the &lt;code&gt;newPermissionCollection&lt;/code&gt; method on the permission's class to see if it requires a special PermissionCollection. If &lt;code&gt;newPermissionCollection&lt;/code&gt; returns null, the PermissionCollection is free to store the permission in any type of PermissionCollection it desires (one using a Hashtable, one using a Vector, etc.). For example, the Permissions object uses a default PermissionCollection implementation that stores the permission objects in a Hashtable.</source>
          <target state="translated">每当将权限添加到异构的PermissionCollection（例如Permissions），并且PermissionCollection尚未包含指定权限类型的PermissionCollection时，PermissionCollection都应在该权限的类上调用 &lt;code&gt;newPermissionCollection&lt;/code&gt; 方法，以查看它是否需要特殊的PermissionCollection。如果 &lt;code&gt;newPermissionCollection&lt;/code&gt; 返回null，则PermissionCollection可以自由将权限存储在所需的任何类型的PermissionCollection中（一种使用Hashtable，一种使用Vector，等等）。例如，Permissions对象使用默认的PermissionCollection实现，该实现将权限对象存储在Hashtable中。</target>
        </trans-unit>
        <trans-unit id="657dbd1f56168fcdb6c057d84ffab8877f436bb8" translate="yes" xml:space="preserve">
          <source>Whenever an operation occurs involving a source sequence (such as appending or inserting from a source sequence), this class synchronizes only on the string buffer performing the operation, not on the source. Note that while &lt;code&gt;StringBuffer&lt;/code&gt; is designed to be safe to use concurrently from multiple threads, if the constructor or the &lt;code&gt;append&lt;/code&gt; or &lt;code&gt;insert&lt;/code&gt; operation is passed a source sequence that is shared across threads, the calling code must ensure that the operation has a consistent and unchanging view of the source sequence for the duration of the operation. This could be satisfied by the caller holding a lock during the operation's call, by using an immutable source sequence, or by not sharing the source sequence across threads.</source>
          <target state="translated">每当发生涉及源序列的操作（例如，从源序列追加或插入）时，此类仅在执行操作的字符串缓冲区上同步，而不在源上同步。请注意，虽然 &lt;code&gt;StringBuffer&lt;/code&gt; 被设计为可以安全地从多个线程中并发使用，但如果传递了构造函数或 &lt;code&gt;append&lt;/code&gt; 或 &lt;code&gt;insert&lt;/code&gt; 操作的源序列在线程之间共享，则调用代码必须确保该操作具有一致且不变的视图操作期间源序列的长度。这可以通过调用方在操作调用期间保持锁定，使用不可变的源序列或不跨线程共享源序列来满足。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
