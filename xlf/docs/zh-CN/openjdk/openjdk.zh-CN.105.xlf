<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="openjdk">
    <body>
      <group id="openjdk">
        <trans-unit id="2e3dc4746bcf1b64502e6c10b09f75bae504e08f" translate="yes" xml:space="preserve">
          <source>ImageWriter.getOutput()</source>
          <target state="translated">ImageWriter.getOutput()</target>
        </trans-unit>
        <trans-unit id="17b68947f77c2816d5402030aae865b9c6bf49d7" translate="yes" xml:space="preserve">
          <source>ImageWriter.getPreferredThumbnailSizes()</source>
          <target state="translated">ImageWriter.getPreferredThumbnailSizes()</target>
        </trans-unit>
        <trans-unit id="f0996382875ebc3931f8227d1da9d9999c6262f0" translate="yes" xml:space="preserve">
          <source>ImageWriter.prepareInsertEmpty()</source>
          <target state="translated">ImageWriter.prepareInsertEmpty()</target>
        </trans-unit>
        <trans-unit id="1600a8485e8aee5eabdb03fa172a540fa208a9ca" translate="yes" xml:space="preserve">
          <source>ImageWriter.prepareReplacePixels()</source>
          <target state="translated">ImageWriter.prepareReplacePixels()</target>
        </trans-unit>
        <trans-unit id="35d0acbd7d75f38aa62c22dada23269ac6e692a6" translate="yes" xml:space="preserve">
          <source>ImageWriter.prepareWriteEmpty()</source>
          <target state="translated">ImageWriter.prepareWriteEmpty()</target>
        </trans-unit>
        <trans-unit id="77b62910eb17e81d20d2ac6ee3a1451fec8f7b11" translate="yes" xml:space="preserve">
          <source>ImageWriter.prepareWriteSequence()</source>
          <target state="translated">ImageWriter.prepareWriteSequence()</target>
        </trans-unit>
        <trans-unit id="264a512aa75f545384e20d5c2a2d44f8cfd28c22" translate="yes" xml:space="preserve">
          <source>ImageWriter.processImageComplete()</source>
          <target state="translated">ImageWriter.processImageComplete()</target>
        </trans-unit>
        <trans-unit id="d899034a5d569f4ed1324d22847e032242084711" translate="yes" xml:space="preserve">
          <source>ImageWriter.processImageProgress()</source>
          <target state="translated">ImageWriter.processImageProgress()</target>
        </trans-unit>
        <trans-unit id="27332d4fb5ca683298f89fcef5f985ee18b1e27d" translate="yes" xml:space="preserve">
          <source>ImageWriter.processImageStarted()</source>
          <target state="translated">ImageWriter.processImageStarted()</target>
        </trans-unit>
        <trans-unit id="ea20b4712a47bc75f276b4adf8231f76d03fb566" translate="yes" xml:space="preserve">
          <source>ImageWriter.processThumbnailComplete()</source>
          <target state="translated">ImageWriter.processThumbnailComplete()</target>
        </trans-unit>
        <trans-unit id="51d80f53b4677d0c618c41e75214b7f17c0cfefb" translate="yes" xml:space="preserve">
          <source>ImageWriter.processThumbnailProgress()</source>
          <target state="translated">ImageWriter.processThumbnailProgress()</target>
        </trans-unit>
        <trans-unit id="e8d245e553e69546053b699570a19cf917b0ff1e" translate="yes" xml:space="preserve">
          <source>ImageWriter.processThumbnailStarted()</source>
          <target state="translated">ImageWriter.processThumbnailStarted()</target>
        </trans-unit>
        <trans-unit id="db5f4715eb940bd70bc26506a945db7ea9b2da98" translate="yes" xml:space="preserve">
          <source>ImageWriter.processWarningOccurred()</source>
          <target state="translated">ImageWriter.processWarningOccurred()</target>
        </trans-unit>
        <trans-unit id="7858acf7ee93b4017b8847e7702c868343598811" translate="yes" xml:space="preserve">
          <source>ImageWriter.processWriteAborted()</source>
          <target state="translated">ImageWriter.processWriteAborted()</target>
        </trans-unit>
        <trans-unit id="03fbfbe0ce8b469a11cc57d3d2f89ca0bcce678a" translate="yes" xml:space="preserve">
          <source>ImageWriter.removeAllIIOWriteProgressListeners()</source>
          <target state="translated">ImageWriter.removeAllIIOWriteProgressListeners()</target>
        </trans-unit>
        <trans-unit id="b83fee8f0c7d4508aa22b6525bb5d98ed0b3322f" translate="yes" xml:space="preserve">
          <source>ImageWriter.removeAllIIOWriteWarningListeners()</source>
          <target state="translated">ImageWriter.removeAllIIOWriteWarningListeners()</target>
        </trans-unit>
        <trans-unit id="cde86c599bcb774b43043a447041773b82450a7d" translate="yes" xml:space="preserve">
          <source>ImageWriter.removeIIOWriteProgressListener()</source>
          <target state="translated">ImageWriter.removeIIOWriteProgressListener()</target>
        </trans-unit>
        <trans-unit id="b9c0bc66df2955815d28d74bdff020a6af20a3d1" translate="yes" xml:space="preserve">
          <source>ImageWriter.removeIIOWriteWarningListener()</source>
          <target state="translated">ImageWriter.removeIIOWriteWarningListener()</target>
        </trans-unit>
        <trans-unit id="31fbb91214d8d39ad428825a48f3fbdb6fa60e2a" translate="yes" xml:space="preserve">
          <source>ImageWriter.removeImage()</source>
          <target state="translated">ImageWriter.removeImage()</target>
        </trans-unit>
        <trans-unit id="4f44e6546a9791fa9ab18d909a79abb19a863b88" translate="yes" xml:space="preserve">
          <source>ImageWriter.replaceImageMetadata()</source>
          <target state="translated">ImageWriter.replaceImageMetadata()</target>
        </trans-unit>
        <trans-unit id="c40e5cfd970633aa96ec6453b5cd39189eec519f" translate="yes" xml:space="preserve">
          <source>ImageWriter.replacePixels()</source>
          <target state="translated">ImageWriter.replacePixels()</target>
        </trans-unit>
        <trans-unit id="74e4c3be0799bbe1f7c421eb7be21b166ff60279" translate="yes" xml:space="preserve">
          <source>ImageWriter.replaceStreamMetadata()</source>
          <target state="translated">ImageWriter.replaceStreamMetadata()</target>
        </trans-unit>
        <trans-unit id="85d06995be275a5540df30d0831143341e3bbff7" translate="yes" xml:space="preserve">
          <source>ImageWriter.reset()</source>
          <target state="translated">ImageWriter.reset()</target>
        </trans-unit>
        <trans-unit id="8fe56500c78199dad9352d8f603280356d3ac6c3" translate="yes" xml:space="preserve">
          <source>ImageWriter.setLocale()</source>
          <target state="translated">ImageWriter.setLocale()</target>
        </trans-unit>
        <trans-unit id="3c39e2913413d8d0162136d0c5d1d8e02851ce04" translate="yes" xml:space="preserve">
          <source>ImageWriter.setOutput()</source>
          <target state="translated">ImageWriter.setOutput()</target>
        </trans-unit>
        <trans-unit id="843ab49be0e6f42a53e35a4061fe467639fa6461" translate="yes" xml:space="preserve">
          <source>ImageWriter.write()</source>
          <target state="translated">ImageWriter.write()</target>
        </trans-unit>
        <trans-unit id="85fea7a2a9c977e351bbbfbd5963fa188c87bdac" translate="yes" xml:space="preserve">
          <source>ImageWriter.writeInsert()</source>
          <target state="translated">ImageWriter.writeInsert()</target>
        </trans-unit>
        <trans-unit id="ff12abc364282e927d5d6556cd4e677d4b326b02" translate="yes" xml:space="preserve">
          <source>ImageWriter.writeToSequence()</source>
          <target state="translated">ImageWriter.writeToSequence()</target>
        </trans-unit>
        <trans-unit id="d4c1cd6c86ba14ace868abe5436b6c3ea6867041" translate="yes" xml:space="preserve">
          <source>ImageWriterSpi</source>
          <target state="translated">ImageWriterSpi</target>
        </trans-unit>
        <trans-unit id="7907c00c50feae52e7cd33381c995a5fe91a5327" translate="yes" xml:space="preserve">
          <source>ImageWriterSpi.canEncodeImage()</source>
          <target state="translated">ImageWriterSpi.canEncodeImage()</target>
        </trans-unit>
        <trans-unit id="114df7b0203df03ac058feb677cbc146b5ae8953" translate="yes" xml:space="preserve">
          <source>ImageWriterSpi.createWriterInstance()</source>
          <target state="translated">ImageWriterSpi.createWriterInstance()</target>
        </trans-unit>
        <trans-unit id="8c525960abeb10238cfa5bdebd4bafd51d80f9a9" translate="yes" xml:space="preserve">
          <source>ImageWriterSpi.getImageReaderSpiNames()</source>
          <target state="translated">ImageWriterSpi.getImageReaderSpiNames()</target>
        </trans-unit>
        <trans-unit id="2576cfdd9438a00c172370eb8ea0ed0dea89009f" translate="yes" xml:space="preserve">
          <source>ImageWriterSpi.getOutputTypes()</source>
          <target state="translated">ImageWriterSpi.getOutputTypes()</target>
        </trans-unit>
        <trans-unit id="b8388bf6802a2e78f4d3d0f825bbf4e83e656d96" translate="yes" xml:space="preserve">
          <source>ImageWriterSpi.isFormatLossless()</source>
          <target state="translated">ImageWriterSpi.isFormatLossless()</target>
        </trans-unit>
        <trans-unit id="473bc7237ab98736b74f2348995a72361b8fe8de" translate="yes" xml:space="preserve">
          <source>ImageWriterSpi.isOwnWriter()</source>
          <target state="translated">ImageWriterSpi.isOwnWriter()</target>
        </trans-unit>
        <trans-unit id="f3bbe23a175ec37e8cc3e09e80fbc7806f08b9b6" translate="yes" xml:space="preserve">
          <source>Images with 2 or 4 bits per pixel may be constructed via the &lt;code&gt;BufferedImage&lt;/code&gt; constructor that takes a &lt;code&gt;ColorModel&lt;/code&gt; argument by supplying a &lt;code&gt;ColorModel&lt;/code&gt; with an appropriate map size.</source>
          <target state="translated">可以通过 &lt;code&gt;BufferedImage&lt;/code&gt; 构造函数构造每个像素2或4位的图像，该构造函数通过为 &lt;code&gt;ColorModel&lt;/code&gt; 提供适当的贴图大小来接受 &lt;code&gt;ColorModel&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="1d0b7a4a289cb642b58d04e1e7fbb91d92814504" translate="yes" xml:space="preserve">
          <source>Images with 8 bits per pixel should use the image types &lt;code&gt;TYPE_BYTE_INDEXED&lt;/code&gt; or &lt;code&gt;TYPE_BYTE_GRAY&lt;/code&gt; depending on their &lt;code&gt;ColorModel&lt;/code&gt;.</source>
          <target state="translated">每像素8位的图像应根据其 &lt;code&gt;ColorModel&lt;/code&gt; 使用图像类型 &lt;code&gt;TYPE_BYTE_INDEXED&lt;/code&gt; 或 &lt;code&gt;TYPE_BYTE_GRAY&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="63ce1f7ade23f27731d8bef9021d16cca263431a" translate="yes" xml:space="preserve">
          <source>Images with an IndexColorModel cannot be rescaled.</source>
          <target state="translated">具有IndexColorModel的图像不能重新缩放。</target>
        </trans-unit>
        <trans-unit id="35f524310930c051d8da9bc51a1b0a045b71ab2c" translate="yes" xml:space="preserve">
          <source>Images with an IndexColorModel cannot be used.</source>
          <target state="translated">不能使用带有IndexColorModel的图像。</target>
        </trans-unit>
        <trans-unit id="d6b0d05ca581d19b3503a81b578fda4383632307" translate="yes" xml:space="preserve">
          <source>ImagingOpException</source>
          <target state="translated">ImagingOpException</target>
        </trans-unit>
        <trans-unit id="b6a1b86fae938216f357d1624854ea77f4576400" translate="yes" xml:space="preserve">
          <source>Immediately performs the base action of this task and returns true if, upon return from this method, this task is guaranteed to have completed normally.</source>
          <target state="translated">立即执行该任务的基础动作,如果从该方法返回后,保证该任务正常完成,则返回true。</target>
        </trans-unit>
        <trans-unit id="4211eb9c1fee9874525c7e0858d275f457d53e7d" translate="yes" xml:space="preserve">
          <source>Immediately performs the base action of this task and returns true if, upon return from this method, this task is guaranteed to have completed normally. This method may return false otherwise, to indicate that this task is not necessarily complete (or is not known to be complete), for example in asynchronous actions that require explicit invocations of completion methods. This method may also throw an (unchecked) exception to indicate abnormal exit. This method is designed to support extensions, and should not in general be called otherwise.</source>
          <target state="translated">立即执行这个任务的基本操作,如果从这个方法返回时,保证这个任务正常完成,则返回true。否则,这个方法可能返回false,以表示这个任务不一定完成(或不知道是否完成),例如在需要显式调用完成方法的异步操作中。这个方法也可以抛出一个(未选中)异常来表示异常退出。这个方法是为了支持扩展而设计的,一般情况下不应该被调用。</target>
        </trans-unit>
        <trans-unit id="0897814d55ff174d5c1cfa71fe0a9353ebf76f09" translate="yes" xml:space="preserve">
          <source>Immediately performs the base action of this task and returns true if, upon return from this method, this task is guaranteed to have completed.</source>
          <target state="translated">立即执行该任务的基本动作,如果从该方法返回后,保证该任务已经完成,则返回true。</target>
        </trans-unit>
        <trans-unit id="26cd90a79a8c2afb8e5a4931f886f1a3dd45067c" translate="yes" xml:space="preserve">
          <source>Immediately performs the base action of this task and returns true if, upon return from this method, this task is guaranteed to have completed. This method may return false otherwise, to indicate that this task is not necessarily complete (or is not known to be complete), for example in asynchronous actions that require explicit invocations of completion methods. This method may also throw an (unchecked) exception to indicate abnormal exit. This method is designed to support extensions, and should not in general be called otherwise.</source>
          <target state="translated">立即执行这个任务的基本动作,如果从这个方法返回时,保证这个任务已经完成,则返回true。否则,这个方法可能返回false,以表示这个任务不一定完成(或不知道是否完成),例如在需要显式调用完成方法的异步操作中。这个方法也可以抛出一个(未选中)异常来表示异常退出。这个方法是为了支持扩展而设计的,一般情况下不应该被调用。</target>
        </trans-unit>
        <trans-unit id="78a6ee9cdbd11937f920f9cf6abd0fcc93bbeeab" translate="yes" xml:space="preserve">
          <source>Immediately removes the current row from this &lt;code&gt;CachedRowSet&lt;/code&gt; object if the row has been inserted, and also notifies listeners that a row has changed.</source>
          <target state="translated">如果已插入行，则立即从此 &lt;code&gt;CachedRowSet&lt;/code&gt; 对象中删除当前行，并通知侦听器行已更改。</target>
        </trans-unit>
        <trans-unit id="e3c8282a36b8a47dc4b2f78994ea2dd708f414e0" translate="yes" xml:space="preserve">
          <source>Immediately removes the current row from this &lt;code&gt;CachedRowSet&lt;/code&gt; object if the row has been inserted, and also notifies listeners that a row has changed. This method can be called at any time during the lifetime of a rowset and assuming the current row is within the exception limitations (see below), it cancels the row insertion of the current row.</source>
          <target state="translated">如果已插入行，则立即从此 &lt;code&gt;CachedRowSet&lt;/code&gt; 对象中删除当前行，并通知侦听器行已更改。可以在行集的生存期内随时调用此方法，并且假设当前行在异常限制之内（请参见下文），它将取消当前行的行插入。</target>
        </trans-unit>
        <trans-unit id="d58d2e0de365bbfe06df3bd3e214308fc7b4c341" translate="yes" xml:space="preserve">
          <source>Immediately reverses the last update operation if the row has been modified.</source>
          <target state="translated">如果行已被修改,则立即撤销上次的更新操作。</target>
        </trans-unit>
        <trans-unit id="178618a784f41413ed0dba00dd3910328200d108" translate="yes" xml:space="preserve">
          <source>Immediately reverses the last update operation if the row has been modified. This method can be called to reverse updates on all columns until all updates in a row have been rolled back to their state just prior to the last synchronization (&lt;code&gt;acceptChanges&lt;/code&gt;) or population. This method may also be called while performing updates to the insert row.</source>
          <target state="translated">如果该行已被修改，则立即撤消上一次更新操作。可以调用此方法以对所有列进行反向更新，直到一行中的所有更新都已回滚到上一次同步（ &lt;code&gt;acceptChanges&lt;/code&gt; ）或填充之前的状态。在对插入行执行更新时，也可以调用此方法。</target>
        </trans-unit>
        <trans-unit id="ac8d36e07cc56e5300256f2a8edfaee0ed2e6146" translate="yes" xml:space="preserve">
          <source>Immediately turns off all sounding notes on this channel, ignoring the state of the Hold Pedal and the internal decay rate of the current &lt;code&gt;Instrument&lt;/code&gt;.</source>
          <target state="translated">立即关闭此通道上的所有音符，而忽略&amp;ldquo;保持踏板&amp;rdquo;的状态和当前&amp;ldquo; &lt;code&gt;Instrument&lt;/code&gt; 的内部衰减率。</target>
        </trans-unit>
        <trans-unit id="8758ee05b925965fd186ddc64c16d26477e3f464" translate="yes" xml:space="preserve">
          <source>Immutable arbitrary-precision integers.</source>
          <target state="translated">不可变的任意精度整数。</target>
        </trans-unit>
        <trans-unit id="9dadabf71766048113467cbc9b081255811fb85d" translate="yes" xml:space="preserve">
          <source>Immutable arbitrary-precision integers. All operations behave as if BigIntegers were represented in two's-complement notation (like Java's primitive integer types). BigInteger provides analogues to all of Java's primitive integer operators, and all relevant methods from java.lang.Math. Additionally, BigInteger provides operations for modular arithmetic, GCD calculation, primality testing, prime generation, bit manipulation, and a few other miscellaneous operations.</source>
          <target state="translated">不可改变的任意精度整数。所有的操作就像BigIntegers用two's-complement符号表示一样(就像Java的原始整数类型)。BigInteger 提供了所有 Java 原始整数运算符的类比,以及 java.lang.Math.Math.BigInteger 的所有相关方法。此外,BigInteger还提供了模块化算术、GCD计算、质性检验、质数生成、位操作和其他一些杂项操作的操作。</target>
        </trans-unit>
        <trans-unit id="0d3137173d33f7241e713b1cc45e83e35598949c" translate="yes" xml:space="preserve">
          <source>Immutable in-memory representation of grammar.</source>
          <target state="translated">语法的不可改变的内存表示。</target>
        </trans-unit>
        <trans-unit id="9135fe2945023ddca478ae564e2500e0944e20a3" translate="yes" xml:space="preserve">
          <source>Immutable objects which encapsulate the context settings which describe certain rules for numerical operators, such as those implemented by the &lt;a href=&quot;bigdecimal&quot;&gt;&lt;code&gt;BigDecimal&lt;/code&gt;&lt;/a&gt; class.</source>
          <target state="translated">不变的对象封装了上下文设置，这些上下文设置描述了数字运算符的某些规则，例如由&lt;a href=&quot;bigdecimal&quot;&gt; &lt;code&gt;BigDecimal&lt;/code&gt; &lt;/a&gt;类实现的规则。</target>
        </trans-unit>
        <trans-unit id="3e6d3d9a67ba06c33eaf819b41614751d94fff83" translate="yes" xml:space="preserve">
          <source>Immutable representation of a time span as defined in the W3C XML Schema 1.0 specification.</source>
          <target state="translated">W3C XML Schema 1.0规范中定义的时间跨度的不可更改的表示。</target>
        </trans-unit>
        <trans-unit id="946d1618638d399656d4c970d5ff50225bc47ca3" translate="yes" xml:space="preserve">
          <source>Immutable, arbitrary-precision signed decimal numbers.</source>
          <target state="translated">不可变的、任意精度的有符号十进制数。</target>
        </trans-unit>
        <trans-unit id="10a4ef5ea8019a3a68a2a4a396691f1d378d5c37" translate="yes" xml:space="preserve">
          <source>Immutable, arbitrary-precision signed decimal numbers. A &lt;code&gt;BigDecimal&lt;/code&gt; consists of an arbitrary precision integer</source>
          <target state="translated">不变的，任意精度的带符号十进制数字。甲 &lt;code&gt;BigDecimal&lt;/code&gt; 由任意精度的整数的</target>
        </trans-unit>
        <trans-unit id="7319e7f2b2dabeaa6c7b27e3568a5f5708e41dfe" translate="yes" xml:space="preserve">
          <source>ImmutableDescriptor</source>
          <target state="translated">ImmutableDescriptor</target>
        </trans-unit>
        <trans-unit id="b36cd894ece50e6aeffc14aae55cd0c27226fd98" translate="yes" xml:space="preserve">
          <source>ImmutableDescriptor.clone()</source>
          <target state="translated">ImmutableDescriptor.clone()</target>
        </trans-unit>
        <trans-unit id="ed62e375f112ad9ccee1fba5b30840d38fa2702b" translate="yes" xml:space="preserve">
          <source>ImmutableDescriptor.equals()</source>
          <target state="translated">ImmutableDescriptor.equals()</target>
        </trans-unit>
        <trans-unit id="cc2486aaa3fee33eb39977e70168c71e9c152579" translate="yes" xml:space="preserve">
          <source>ImmutableDescriptor.getFieldNames()</source>
          <target state="translated">ImmutableDescriptor.getFieldNames()</target>
        </trans-unit>
        <trans-unit id="33c0e00e50294d5765396d16bed5b31e31b33704" translate="yes" xml:space="preserve">
          <source>ImmutableDescriptor.getFieldValue()</source>
          <target state="translated">ImmutableDescriptor.getFieldValue()</target>
        </trans-unit>
        <trans-unit id="27f5f695db4a9c871dae6c1af910d2e02e2d8827" translate="yes" xml:space="preserve">
          <source>ImmutableDescriptor.getFieldValues()</source>
          <target state="translated">ImmutableDescriptor.getFieldValues()</target>
        </trans-unit>
        <trans-unit id="c74b89a34fa2994f4dc20dbdb82753d62c2f8dba" translate="yes" xml:space="preserve">
          <source>ImmutableDescriptor.getFields()</source>
          <target state="translated">ImmutableDescriptor.getFields()</target>
        </trans-unit>
        <trans-unit id="1ef304a4a99d2ee1d85fa6fa5017995b00e2e0d9" translate="yes" xml:space="preserve">
          <source>ImmutableDescriptor.hashCode()</source>
          <target state="translated">ImmutableDescriptor.hashCode()</target>
        </trans-unit>
        <trans-unit id="1bed3158b55a0ff6dc6cf7eee07c3cb59df5f3ae" translate="yes" xml:space="preserve">
          <source>ImmutableDescriptor.isValid()</source>
          <target state="translated">ImmutableDescriptor.isValid()</target>
        </trans-unit>
        <trans-unit id="9d20352efe423c7d09b17d5ea975cfa82b08c2a1" translate="yes" xml:space="preserve">
          <source>ImmutableDescriptor.removeField()</source>
          <target state="translated">ImmutableDescriptor.removeField()</target>
        </trans-unit>
        <trans-unit id="d8f820196ba5acc46b266d1f2d228cf55ed7e0e1" translate="yes" xml:space="preserve">
          <source>ImmutableDescriptor.setField()</source>
          <target state="translated">ImmutableDescriptor.setField()</target>
        </trans-unit>
        <trans-unit id="b253285758003719de94b91f5f21225436dd43df" translate="yes" xml:space="preserve">
          <source>ImmutableDescriptor.setFields()</source>
          <target state="translated">ImmutableDescriptor.setFields()</target>
        </trans-unit>
        <trans-unit id="3331b138f3a353ed1554e90d8d377dd39afe2405" translate="yes" xml:space="preserve">
          <source>ImmutableDescriptor.toString()</source>
          <target state="translated">ImmutableDescriptor.toString()</target>
        </trans-unit>
        <trans-unit id="58bb6a00dee16db192f8a0654a1c5b9c33aee672" translate="yes" xml:space="preserve">
          <source>ImmutableDescriptor.union()</source>
          <target state="translated">ImmutableDescriptor.union()</target>
        </trans-unit>
        <trans-unit id="ce2554a69e87f8fcc40f97d7741454517747cdfd" translate="yes" xml:space="preserve">
          <source>Impersonates a principal.</source>
          <target state="translated">冒充校长。</target>
        </trans-unit>
        <trans-unit id="b5ab3a15fc18443d3018726e55985246e70150af" translate="yes" xml:space="preserve">
          <source>Impersonates a principal. In Kerberos, this can be implemented using the Microsoft S4U2self extension.</source>
          <target state="translated">冒充委托人。在 Kerberos 中,这可以使用 Microsoft S4U2self 扩展来实现。</target>
        </trans-unit>
        <trans-unit id="53ec8c0efe8d1c9632dd1fa4a2184ba29ffd5a20" translate="yes" xml:space="preserve">
          <source>Impl</source>
          <target state="translated">Impl</target>
        </trans-unit>
        <trans-unit id="f0056cd1979fbe037e426222b348d25fd0689453" translate="yes" xml:space="preserve">
          <source>Implement &lt;code&gt;NamingListener.namingExceptionThrown()&lt;/code&gt; so that it will be notified of exceptions thrown while attempting to collect information about the events.</source>
          <target state="translated">实现 &lt;code&gt;NamingListener.namingExceptionThrown()&lt;/code&gt; ,以便在尝试收集有关事件的信息时将其通知抛出的异常。</target>
        </trans-unit>
        <trans-unit id="690dbe719c377561373486aa2f92fb2d6f5e4ff2" translate="yes" xml:space="preserve">
          <source>Implement &lt;code&gt;NamingListener.namingExceptionThrown()&lt;/code&gt; so that it will be notified of exceptions thrown while attempting to collect unsolicited notification events.</source>
          <target state="translated">实现 &lt;code&gt;NamingListener.namingExceptionThrown()&lt;/code&gt; ,以便在尝试收集未经请求的通知事件时将通知其抛出的异常。</target>
        </trans-unit>
        <trans-unit id="75affea7e53c52cd8fab4edffef65fbf6ddb7308" translate="yes" xml:space="preserve">
          <source>Implement this interface and its method</source>
          <target state="translated">实现这个接口和它的方法</target>
        </trans-unit>
        <trans-unit id="5063beca960838bb432eb32e9373f94a39f1f788" translate="yes" xml:space="preserve">
          <source>Implement this interface and its method (&lt;code&gt;objectChanged()&lt;/code&gt;)</source>
          <target state="translated">实现此接口及其方法（ &lt;code&gt;objectChanged()&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="aff6c99e6945c218f388a4965c6177505dfafc44" translate="yes" xml:space="preserve">
          <source>Implement this interface and its methods.</source>
          <target state="translated">实现这个接口和它的方法。</target>
        </trans-unit>
        <trans-unit id="2e66b6c0aeb65e7c92f1357992e37901f5147726" translate="yes" xml:space="preserve">
          <source>Implementation Caveats</source>
          <target state="translated">实施注意事项</target>
        </trans-unit>
        <trans-unit id="1ea8952f50fb61a30b61a3567d5ee3bac1c761f1" translate="yes" xml:space="preserve">
          <source>Implementation Considerations</source>
          <target state="translated">执行方面的考虑</target>
        </trans-unit>
        <trans-unit id="5392a59cf19d936f582c62933f66e98178ed888b" translate="yes" xml:space="preserve">
          <source>Implementation Note:</source>
          <target state="translated">执行说明:</target>
        </trans-unit>
        <trans-unit id="35577183da3a83c37a96990c90025cb613ff293d" translate="yes" xml:space="preserve">
          <source>Implementation Notes</source>
          <target state="translated">执行说明</target>
        </trans-unit>
        <trans-unit id="56bd65881e479e23bf147d909b47f36e4767545c" translate="yes" xml:space="preserve">
          <source>Implementation Requirements:</source>
          <target state="translated">执行要求:</target>
        </trans-unit>
        <trans-unit id="c054b6d2d6fae8ccc22414dda4a08abbd6309cb2" translate="yes" xml:space="preserve">
          <source>Implementation classes can implement any number of remote interfaces and can extend other remote implementation classes. RMI provides some convenience classes that remote object implementations can extend which facilitate remote object creation. These classes are &lt;code&gt;java.rmi.server.UnicastRemoteObject&lt;/code&gt; and &lt;code&gt;java.rmi.activation.Activatable&lt;/code&gt;.</source>
          <target state="translated">实现类可以实现任意数量的远程接口，并且可以扩展其他远程实现类。RMI提供了一些便利类，远程对象实现可以扩展这些便利类，从而促进远程对象的创建。这些类是 &lt;code&gt;java.rmi.server.UnicastRemoteObject&lt;/code&gt; 和 &lt;code&gt;java.rmi.activation.Activatable&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b4db05a22307844f1edc4910aee61a1ebef7a63d" translate="yes" xml:space="preserve">
          <source>Implementation defaults require that only cipher suites which authenticate servers and provide confidentiality be enabled by default. Only if both sides explicitly agree to unauthenticated and/or non-private (unencrypted) communications will such a cipher suite be selected.</source>
          <target state="translated">实施默认情况下,只有验证服务器和提供保密性的密码套件才会被默认启用。只有当双方明确同意未认证和/或非私密(未加密)的通信时,才会选择这样的密码套件。</target>
        </trans-unit>
        <trans-unit id="c2f7359e09ff4796735a0de165edbf80e271b48e" translate="yes" xml:space="preserve">
          <source>Implementation defaults require that only cipher suites which authenticate servers and provide confidentiality be enabled by default. Only if both sides explicitly agree to unauthenticated and/or non-private (unencrypted) communications will such a ciphersuite be selected.</source>
          <target state="translated">实施默认情况下,只有验证服务器和提供保密性的密码套件才会被默认启用。只有当双方明确同意未认证和/或非私密(未加密)的通信时,才会选择这样的密码套件。</target>
        </trans-unit>
        <trans-unit id="89a26f51603685592a55c536acb5f2c479db2b32" translate="yes" xml:space="preserve">
          <source>Implementation dependent*</source>
          <target state="translated">取决于执行情况*</target>
        </trans-unit>
        <trans-unit id="7d8419888cec7209ae96fa638de54f65acbe69d3" translate="yes" xml:space="preserve">
          <source>Implementation note: All basic operations execute in constant time. They are likely (though not guaranteed) to be faster than their &lt;a href=&quot;hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; counterparts.</source>
          <target state="translated">实施注意事项：所有基本操作均按固定时间执行。它们可能（尽管不能保证）比其&lt;a href=&quot;hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt;同行更快。</target>
        </trans-unit>
        <trans-unit id="cf02ce9de07c112e78515bdd74f832a2026eaf4c" translate="yes" xml:space="preserve">
          <source>Implementation note: All basic operations execute in constant time. They are likely (though not guaranteed) to be much faster than their &lt;a href=&quot;hashset&quot;&gt;&lt;code&gt;HashSet&lt;/code&gt;&lt;/a&gt; counterparts. Even bulk operations execute in constant time if their argument is also an enum set.</source>
          <target state="translated">实施注意事项：所有基本操作均按固定时间执行。它们可能（尽管不能保证）比其&lt;a href=&quot;hashset&quot;&gt; &lt;code&gt;HashSet&lt;/code&gt; &lt;/a&gt;对应对象快得多。如果批量操作的参数也是一个枚举集，则即使批量操作也会在恒定时间内执行。</target>
        </trans-unit>
        <trans-unit id="c78934415a11eef7fc53181c42efe07bfe3abdfc" translate="yes" xml:space="preserve">
          <source>Implementation note: All constructors start a timer thread.</source>
          <target state="translated">实现说明:所有构造函数都会启动一个定时器线程。</target>
        </trans-unit>
        <trans-unit id="9f92508b268a3c37cb005d5f88087365e6264aad" translate="yes" xml:space="preserve">
          <source>Implementation note: Currently the syntax properties of n are not used when doing the comparison. They might be in the future.</source>
          <target state="translated">实施说明:目前在进行比较时没有使用n的语法属性。将来可能会使用。</target>
        </trans-unit>
        <trans-unit id="357fbc883df7f4e052dd8544280cd702a44ddce7" translate="yes" xml:space="preserve">
          <source>Implementation note: Currently the syntax properties of suffix is not used or checked. They might be in the future.</source>
          <target state="translated">实施说明:目前没有使用或检查后缀的语法属性。将来可能会使用。</target>
        </trans-unit>
        <trans-unit id="57c22944b726188bf6ae7fd68a8e4603e289bff8" translate="yes" xml:space="preserve">
          <source>Implementation note: Currently the syntax properties of the two compound names are not compared for equality. They might be in the future.</source>
          <target state="translated">实施说明:目前两个复合名的语法属性没有进行平等比较。将来可能会这样做。</target>
        </trans-unit>
        <trans-unit id="17efe67f11fa0904c5508671cc86b1f03383b987" translate="yes" xml:space="preserve">
          <source>Implementation note: Currently the syntax properties of the two compound names are not compared when checking order. They might be in the future.</source>
          <target state="translated">实施说明:目前在检查顺序时,两个复名的语法属性没有进行比较。将来可能会这样做。</target>
        </trans-unit>
        <trans-unit id="fadd3ec1701bf6a8dfbeac94df0eeb78424f23bc" translate="yes" xml:space="preserve">
          <source>Implementation note: In Sun's JRE, the &lt;code&gt;PreferencesFactory&lt;/code&gt; implementation is located as follows:</source>
          <target state="translated">实施说明：在Sun的JRE中， &lt;code&gt;PreferencesFactory&lt;/code&gt; 的实现位于以下位置：</target>
        </trans-unit>
        <trans-unit id="32af97f107bce0105a0965130e4994d46e36fe62" translate="yes" xml:space="preserve">
          <source>Implementation note: In Sun's default &lt;code&gt;Preferences&lt;/code&gt; implementations, the user's identity is inherited from the underlying operating system and does not change for the lifetime of the virtual machine. It is recognized that server-side &lt;code&gt;Preferences&lt;/code&gt; implementations may have the user identity change from request to request, implicitly passed to &lt;code&gt;Preferences&lt;/code&gt; methods via the use of a static &lt;a href=&quot;../../../../java.base/java/lang/threadlocal&quot;&gt;&lt;code&gt;ThreadLocal&lt;/code&gt;&lt;/a&gt; instance. Authors of such implementations are</source>
          <target state="translated">实施说明：在Sun的默认 &lt;code&gt;Preferences&lt;/code&gt; 实施中，用户身份是从基础操作系统继承的，并且在虚拟机的生存期内不会更改。已经认识到，服务器端的 &lt;code&gt;Preferences&lt;/code&gt; 实现可能会在请求之间更改用户身份，并通过使用静态&lt;a href=&quot;../../../../java.base/java/lang/threadlocal&quot;&gt; &lt;code&gt;ThreadLocal&lt;/code&gt; &lt;/a&gt;实例隐式传递给 &lt;code&gt;Preferences&lt;/code&gt; 方法。此类实现的作者是</target>
        </trans-unit>
        <trans-unit id="e83e39679a9ec5b714b7a869ee88c37537f350ca" translate="yes" xml:space="preserve">
          <source>Implementation note: In Sun's default &lt;code&gt;Preferences&lt;/code&gt; implementations, the user's identity is inherited from the underlying operating system and does not change for the lifetime of the virtual machine. It is recognized that server-side &lt;code&gt;Preferences&lt;/code&gt; implementations may have the user identity change from request to request, implicitly passed to &lt;code&gt;Preferences&lt;/code&gt; methods via the use of a static &lt;a href=&quot;../../lang/threadlocal&quot;&gt;&lt;code&gt;ThreadLocal&lt;/code&gt;&lt;/a&gt; instance. Authors of such implementations are</source>
          <target state="translated">实施说明：在Sun的默认 &lt;code&gt;Preferences&lt;/code&gt; 实施中，用户身份是从基础操作系统继承的，并且在虚拟机的生存期内不会更改。已经认识到，服务器端的 &lt;code&gt;Preferences&lt;/code&gt; 实施可能会在请求之间更改用户身份，并通过使用静态&lt;a href=&quot;../../lang/threadlocal&quot;&gt; &lt;code&gt;ThreadLocal&lt;/code&gt; &lt;/a&gt;实例隐式传递给 &lt;code&gt;Preferences&lt;/code&gt; 方法。此类实现的作者是</target>
        </trans-unit>
        <trans-unit id="f8347a8d9b2c4d7fc6f3f82a020b9be3d04e1235" translate="yes" xml:space="preserve">
          <source>Implementation note: It is a good idea for the returned input stream to be buffered.</source>
          <target state="translated">实施说明:对返回的输入流进行缓冲是个好主意。</target>
        </trans-unit>
        <trans-unit id="e620b36bbd87ef780306fc9678272515771dd91b" translate="yes" xml:space="preserve">
          <source>Implementation note: It is a good idea for the returned output stream to be buffered.</source>
          <target state="translated">实施说明:对返回的输出流进行缓冲是个好主意。</target>
        </trans-unit>
        <trans-unit id="12c36d0f22c12cc8b408418579ca954e388e69cb" translate="yes" xml:space="preserve">
          <source>Implementation note: Java platform implementers are encouraged to document their implementation's behavior with respect to the &lt;code&gt;stackSize&lt;/code&gt; parameter.</source>
          <target state="translated">实施说明：鼓励Java平台实施人员针对 &lt;code&gt;stackSize&lt;/code&gt; 参数记录其实施的行为。</target>
        </trans-unit>
        <trans-unit id="a80652326887f793e45705b34277de3fc6ce115d" translate="yes" xml:space="preserve">
          <source>Implementation note: The implementations of the &quot;bit twiddling&quot; methods (such as &lt;a href=&quot;#highestOneBit(int)&quot;&gt;&lt;code&gt;highestOneBit&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#numberOfTrailingZeros(int)&quot;&gt;&lt;code&gt;numberOfTrailingZeros&lt;/code&gt;&lt;/a&gt;) are based on material from Henry S. Warren, Jr.'s</source>
          <target state="translated">实施说明：&amp;ldquo;位&lt;a href=&quot;#highestOneBit(int)&quot;&gt; &lt;code&gt;highestOneBit&lt;/code&gt; &lt;/a&gt;&amp;rdquo;方法的实现（例如highestOneBit和&lt;a href=&quot;#numberOfTrailingZeros(int)&quot;&gt; &lt;code&gt;numberOfTrailingZeros&lt;/code&gt; &lt;/a&gt;）基于亨利&amp;middot;S&amp;middot;沃伦（Henry S. Warren，Jr.）的资料</target>
        </trans-unit>
        <trans-unit id="a7085ff44d84babc5ff1f7930ff810b8715a1f05" translate="yes" xml:space="preserve">
          <source>Implementation note: The implementations of the &quot;bit twiddling&quot; methods (such as &lt;a href=&quot;#highestOneBit(long)&quot;&gt;&lt;code&gt;highestOneBit&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#numberOfTrailingZeros(long)&quot;&gt;&lt;code&gt;numberOfTrailingZeros&lt;/code&gt;&lt;/a&gt;) are based on material from Henry S. Warren, Jr.'s</source>
          <target state="translated">实施说明：&amp;ldquo;位&lt;a href=&quot;#highestOneBit(long)&quot;&gt; &lt;code&gt;highestOneBit&lt;/code&gt; &lt;/a&gt;&amp;rdquo;方法的实现（例如highestOneBit和&lt;a href=&quot;#numberOfTrailingZeros(long)&quot;&gt; &lt;code&gt;numberOfTrailingZeros&lt;/code&gt; &lt;/a&gt;）基于亨利&amp;middot;S&amp;middot;沃伦（Henry S. Warren，Jr.）的资料</target>
        </trans-unit>
        <trans-unit id="cc3f67c06af9914501ca24f8883a4e8966569d3d" translate="yes" xml:space="preserve">
          <source>Implementation note: The implementations of the &quot;bit twiddling&quot; methods (such as &lt;a href=&quot;integer#highestOneBit-int-&quot;&gt;&lt;code&gt;highestOneBit&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;integer#numberOfTrailingZeros-int-&quot;&gt;&lt;code&gt;numberOfTrailingZeros&lt;/code&gt;&lt;/a&gt;) are based on material from Henry S. Warren, Jr.'s</source>
          <target state="translated">实施说明：&amp;ldquo;位&lt;a href=&quot;integer#highestOneBit-int-&quot;&gt; &lt;code&gt;highestOneBit&lt;/code&gt; &lt;/a&gt; &amp;rdquo;方法的实现（例如highestOneBit和&lt;a href=&quot;integer#numberOfTrailingZeros-int-&quot;&gt; &lt;code&gt;numberOfTrailingZeros&lt;/code&gt; &lt;/a&gt;）是基于小亨利&amp;middot;沃伦（Henry S. Warren，Jr.）</target>
        </trans-unit>
        <trans-unit id="8a4a16b7058693cbd0304356eead5736843a8092" translate="yes" xml:space="preserve">
          <source>Implementation note: The implementations of the &quot;bit twiddling&quot; methods (such as &lt;a href=&quot;long#highestOneBit-long-&quot;&gt;&lt;code&gt;highestOneBit&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;long#numberOfTrailingZeros-long-&quot;&gt;&lt;code&gt;numberOfTrailingZeros&lt;/code&gt;&lt;/a&gt;) are based on material from Henry S. Warren, Jr.'s</source>
          <target state="translated">实施说明：&amp;ldquo;位&lt;a href=&quot;long#highestOneBit-long-&quot;&gt; &lt;code&gt;highestOneBit&lt;/code&gt; &lt;/a&gt; &amp;rdquo;方法的实现（例如highestOneBit和&lt;a href=&quot;long#numberOfTrailingZeros-long-&quot;&gt; &lt;code&gt;numberOfTrailingZeros&lt;/code&gt; &lt;/a&gt;）是基于小亨利&amp;middot;沃伦（Henry S. Warren，Jr.）</target>
        </trans-unit>
        <trans-unit id="3188db0c530c042cb96da0a5994510f97bfc5cc0" translate="yes" xml:space="preserve">
          <source>Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations.</source>
          <target state="translated">实现说明:排序算法是由Vladimir Yaroslavskiy、Jon Bentley和Joshua Bloch提出的Dual-Pivot Quicksort。这种算法在许多数据集上提供了O(n log(n))的性能,导致其他quicksort性能下降到二次方,并且通常比传统的(单枢轴)Quicksort实现更快。</target>
        </trans-unit>
        <trans-unit id="b1d5721596c5d27ffa016e87f4ba7a7afcdd3a37" translate="yes" xml:space="preserve">
          <source>Implementation note: This class scales to large numbers of concurrently scheduled tasks (thousands should present no problem). Internally, it uses a binary heap to represent its task queue, so the cost to schedule a task is O(log n), where n is the number of concurrently scheduled tasks.</source>
          <target state="translated">实现说明:这个类可以扩展到大量的并发调度任务(成千上万的任务应该没有问题)。在内部,它使用一个二进制堆来表示它的任务队列,所以调度一个任务的成本是O(log n),其中n是并发调度任务的数量。</target>
        </trans-unit>
        <trans-unit id="8ef20428f4dadec2f47e6e6850bd2a0025279b42" translate="yes" xml:space="preserve">
          <source>Implementation note: This implementation is a stable, adaptive, iterative mergesort that requires far fewer than n lg(n) comparisons when the input array is partially sorted, while offering the performance of a traditional mergesort when the input array is randomly ordered. If the input array is nearly sorted, the implementation requires approximately n comparisons. Temporary storage requirements vary from a small constant for nearly sorted input arrays to n/2 object references for randomly ordered input arrays.</source>
          <target state="translated">实现说明:本实现是一个稳定的、自适应的、迭代的mergesort,当输入数组部分排序时,所需的比较次数远远少于n lg(n)次,而当输入数组是随机排序时,则具有传统mergesort的性能。如果输入数组接近排序,则实现需要大约n次比较。临时存储需求从近乎排序的输入数组的一个小常数到随机排序的输入数组的n/2个对象引用不等。</target>
        </trans-unit>
        <trans-unit id="eb0470b2fedea042771a02bc0a5cad6afbd16278" translate="yes" xml:space="preserve">
          <source>Implementation note: This implementation maintains markable references by creating internal objects representing &quot;boxed&quot; [reference, boolean] pairs.</source>
          <target state="translated">实施说明:本实施例通过创建表示 &quot;盒状&quot;[reference,boolean]对的内部对象来维护可标记的引用。</target>
        </trans-unit>
        <trans-unit id="2cff0a7e73f6f3b914b5fc7d60794f6a681ade41" translate="yes" xml:space="preserve">
          <source>Implementation note: This implementation maintains stamped references by creating internal objects representing &quot;boxed&quot; [reference, integer] pairs.</source>
          <target state="translated">实施说明:本实施例通过创建表示 &quot;盒状&quot;[引用,整数]对的内部对象来维护盖章的引用。</target>
        </trans-unit>
        <trans-unit id="82eefb0670ba392863839d4b7c351ae2f2aec431" translate="yes" xml:space="preserve">
          <source>Implementation note: This is a simple</source>
          <target state="translated">实施说明:这是一个简单的</target>
        </trans-unit>
        <trans-unit id="0f1b03ffa0afe0f4d925ad6c4cbaf6a53cc3d45c" translate="yes" xml:space="preserve">
          <source>Implementation note: this implementation provides O(log(n)) time for the enqueuing and dequeuing methods (&lt;code&gt;offer&lt;/code&gt;, &lt;code&gt;poll&lt;/code&gt;, &lt;code&gt;remove()&lt;/code&gt; and &lt;code&gt;add&lt;/code&gt;); linear time for the &lt;code&gt;remove(Object)&lt;/code&gt; and &lt;code&gt;contains(Object)&lt;/code&gt; methods; and constant time for the retrieval methods (&lt;code&gt;peek&lt;/code&gt;, &lt;code&gt;element&lt;/code&gt;, and &lt;code&gt;size&lt;/code&gt;).</source>
          <target state="translated">实施注意事项：此实现为入队和出队方法（ &lt;code&gt;offer&lt;/code&gt; ， &lt;code&gt;poll&lt;/code&gt; ， &lt;code&gt;remove()&lt;/code&gt; 和 &lt;code&gt;add&lt;/code&gt; ）提供O（log（n））时间； &lt;code&gt;remove(Object)&lt;/code&gt; 和 &lt;code&gt;contains(Object)&lt;/code&gt; 方法的线性时间；和固定时间的检索方法（ &lt;code&gt;peek&lt;/code&gt; ， &lt;code&gt;element&lt;/code&gt; 和 &lt;code&gt;size&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="62d6f06657d3359a7c49b4f528b67ee2cdba413a" translate="yes" xml:space="preserve">
          <source>Implementation of ComboPopup.getKeyListener().</source>
          <target state="translated">ComboPopup.getKeyListener()的实现。</target>
        </trans-unit>
        <trans-unit id="70462c77e4382253855b86e4e7f6f7c7c0723bf8" translate="yes" xml:space="preserve">
          <source>Implementation of ComboPopup.getList().</source>
          <target state="translated">ComboPopup.getList()的实现。</target>
        </trans-unit>
        <trans-unit id="5788526cf7b5f9f213ed4c51c11bc1a3c88db823" translate="yes" xml:space="preserve">
          <source>Implementation of ComboPopup.getMouseListener().</source>
          <target state="translated">ComboPopup.getMouseListener()的实现。</target>
        </trans-unit>
        <trans-unit id="dcfea7aadf5f0efc973fd90897934bacf8738909" translate="yes" xml:space="preserve">
          <source>Implementation of ComboPopup.getMouseMotionListener().</source>
          <target state="translated">ComboPopup.getMouseMotionListener()的实现。</target>
        </trans-unit>
        <trans-unit id="6bbde2392be17daf4b5536ddf29fc67cd5e4611f" translate="yes" xml:space="preserve">
          <source>Implementation of ComboPopup.hide().</source>
          <target state="translated">ComboPopup.hide()的实现。</target>
        </trans-unit>
        <trans-unit id="987207700ef33908715f75cb881ee0043c420d73" translate="yes" xml:space="preserve">
          <source>Implementation of ComboPopup.show().</source>
          <target state="translated">ComboPopup.show()的实现。</target>
        </trans-unit>
        <trans-unit id="fa0fb2c8ec52562d3cc085877c70e27e31dce0d3" translate="yes" xml:space="preserve">
          <source>Implementation of ScrollBarUI for the Basic Look and Feel</source>
          <target state="translated">实现ScrollBarUI的基本外观和感觉。</target>
        </trans-unit>
        <trans-unit id="e4c2e8d390498cc8b74a825e1fe79b2f66af8b30" translate="yes" xml:space="preserve">
          <source>Implementation of ScrollBarUI for the Metal Look and Feel</source>
          <target state="translated">实现ScrollBarUI的金属外观和感觉。</target>
        </trans-unit>
        <trans-unit id="e5d871d42e339265298961acaedbdd4193e5ecce" translate="yes" xml:space="preserve">
          <source>Implementation of an ActionListener that the JSplitPane UI uses for handling specific key presses.</source>
          <target state="translated">JSplitPane UI用于处理特定按键的ActionListener的实现。</target>
        </trans-unit>
        <trans-unit id="3118ec0d79d222bcd2256d07c590a042e52e16c7" translate="yes" xml:space="preserve">
          <source>Implementation of the &lt;a href=&quot;rmiconnection&quot;&gt;&lt;code&gt;RMIConnection&lt;/code&gt;&lt;/a&gt; interface.</source>
          <target state="translated">在实施&lt;a href=&quot;rmiconnection&quot;&gt; &lt;code&gt;RMIConnection&lt;/code&gt; &lt;/a&gt;接口。</target>
        </trans-unit>
        <trans-unit id="f35fc1148f7585e27e0b304b08634ba0530c650a" translate="yes" xml:space="preserve">
          <source>Implementation of the &lt;a href=&quot;rmiconnection&quot;&gt;&lt;code&gt;RMIConnection&lt;/code&gt;&lt;/a&gt; interface. User code will not usually reference this class.</source>
          <target state="translated">在实施&lt;a href=&quot;rmiconnection&quot;&gt; &lt;code&gt;RMIConnection&lt;/code&gt; &lt;/a&gt;接口。用户代码通常不会引用此类。</target>
        </trans-unit>
        <trans-unit id="7aae3f60380c55bc82937af4ac2577abd3646434" translate="yes" xml:space="preserve">
          <source>Implementation of the FocusListener that the JSplitPane UI uses.</source>
          <target state="translated">JSplitPane UI使用的FocusListener的实现。</target>
        </trans-unit>
        <trans-unit id="e45222ac40e5e9145fe91fecc0ab9e099a479550" translate="yes" xml:space="preserve">
          <source>Implementation of the PropertyChangeListener that the JSplitPane UI uses.</source>
          <target state="translated">JSplitPane UI使用的PropertyChangeListener的实现。</target>
        </trans-unit>
        <trans-unit id="2a530c76800e044b9bf6aafcd3efc974a11ea05e" translate="yes" xml:space="preserve">
          <source>Implementation of this &quot;interface&quot; can be obtained through the &lt;a href=&quot;validatorhandler#getTypeInfoProvider()&quot;&gt;&lt;code&gt;ValidatorHandler.getTypeInfoProvider()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">可以通过&lt;a href=&quot;validatorhandler#getTypeInfoProvider()&quot;&gt; &lt;code&gt;ValidatorHandler.getTypeInfoProvider()&lt;/code&gt; &lt;/a&gt;方法获得此&amp;ldquo;接口&amp;rdquo;的实现。</target>
        </trans-unit>
        <trans-unit id="7f55d131a2dc1cfdadfdc55ae7393f24e57ed10d" translate="yes" xml:space="preserve">
          <source>Implementation of this compound name. This field is initialized by the constructors and cannot be null. It should be treated as a read-only variable by subclasses.</source>
          <target state="translated">这个复合名称的实现。该字段由构造函数初始化,不能为空。它应该被子类视为一个只读变量。</target>
        </trans-unit>
        <trans-unit id="c455488aae5e9f5d4d1f7ba581ef3e990cd0d089" translate="yes" xml:space="preserve">
          <source>Implementation of this method should make sure the returned keys match the latest content of the keytab file. The result is a newly created copy that can be modified by the caller without modifying the keytab object. The caller should &lt;a href=&quot;kerberoskey#destroy()&quot;&gt;&lt;code&gt;destroy&lt;/code&gt;&lt;/a&gt; the result keys after they are used.</source>
          <target state="translated">此方法的实现应确保返回的密钥与keytab文件的最新内容匹配。结果是一个新创建的副本，调用者可以在不修改keytab对象的情况下对其进行修改。使用结果键后，调用方应&lt;a href=&quot;kerberoskey#destroy()&quot;&gt; &lt;code&gt;destroy&lt;/code&gt; &lt;/a&gt;它们。</target>
        </trans-unit>
        <trans-unit id="4588461e3c03d7bc79552363d89b889505499be0" translate="yes" xml:space="preserve">
          <source>Implementation of this method should make sure the returned keys match the latest content of the keytab file. The result is a newly created copy that can be modified by the caller without modifying the keytab object. The caller should &lt;a href=&quot;kerberoskey#destroy--&quot;&gt;&lt;code&gt;destroy&lt;/code&gt;&lt;/a&gt; the result keys after they are used.</source>
          <target state="translated">此方法的实现应确保返回的密钥与keytab文件的最新内容匹配。结果是一个新创建的副本，调用者可以在不修改keytab对象的情况下对其进行修改。使用结果键后，调用方应&lt;a href=&quot;kerberoskey#destroy--&quot;&gt; &lt;code&gt;destroy&lt;/code&gt; &lt;/a&gt;它们。</target>
        </trans-unit>
        <trans-unit id="396c510a1fc2ba783df94b6f422e4210a3731d18" translate="yes" xml:space="preserve">
          <source>Implementation specific properties are prefixed with a package name associated with the implementor, beginning with &lt;code&gt;com.&lt;/code&gt; or a similar prefix. All property names beginning with &lt;code&gt;pack.&lt;/code&gt; and &lt;code&gt;unpack.&lt;/code&gt; are reserved for use by this API.</source>
          <target state="translated">特定于实现的属性以与实现器关联的程序包名称为前缀，以 &lt;code&gt;com.&lt;/code&gt; 开头。或类似的前缀。所有属性名称均以 &lt;code&gt;pack.&lt;/code&gt; 开头。然后 &lt;code&gt;unpack.&lt;/code&gt; 保留供此API使用。</target>
        </trans-unit>
        <trans-unit id="f7b530c2bf8258e2420563a2fcc5823de5071326" translate="yes" xml:space="preserve">
          <source>Implementations are free to flush changes into the persistent store at any time. They do not need to wait for this method to be called.</source>
          <target state="translated">实现者可以在任何时候自由地将更改冲入持久化存储中,他们不需要等待这个方法被调用。他们不需要等待这个方法被调用。</target>
        </trans-unit>
        <trans-unit id="bbef6d428d76eba48a5e342afaf9006175c411f4" translate="yes" xml:space="preserve">
          <source>Implementations are free to ignore the hints completely, but should try to use an implementation algorithm that is as close as possible to the request. If an implementation supports a given algorithm when any value is used for an associated hint key, then minimally it must do so when the value for that key is the exact value that specifies the algorithm.</source>
          <target state="translated">实现可以自由地完全忽略这些提示,但应该尽量使用与请求尽可能接近的实现算法。如果一个实现在任何值被用于相关的提示键时支持一个给定的算法,那么最低限度地,当该键的值是指定算法的精确值时,它必须这样做。</target>
        </trans-unit>
        <trans-unit id="eafb44c538b7aa7794d10b653782aa71d2cf24c8" translate="yes" xml:space="preserve">
          <source>Implementations are free to implement the Cloneable interface.</source>
          <target state="translated">实现者可以自由实现Cloneable接口。</target>
        </trans-unit>
        <trans-unit id="90d7991836c70f5920ce49a6302cb1849e347963" translate="yes" xml:space="preserve">
          <source>Implementations are free to implement the Cloneable interface. Client applications can test cloneability by attempting cloning and catching the CloneNotSupportedException:</source>
          <target state="translated">实现者可以自由实现Cloneable接口。客户端应用程序可以通过尝试克隆和捕获CloneNotSupportedException来测试可克隆性。</target>
        </trans-unit>
        <trans-unit id="cf03efd7cfc8f1ec7309d501f6cf5b8fc2e0cc89" translate="yes" xml:space="preserve">
          <source>Implementations are not required to support the activation mechanism. If activation is not supported by this implementation, several specific activation API methods are all required to throw &lt;code&gt;UnsupportedOperationException&lt;/code&gt;. If activation is supported by this implementation, these methods must never throw &lt;code&gt;
UnsupportedOperationException&lt;/code&gt;. These methods are denoted by the presence of an entry for &lt;code&gt;UnsupportedOperationException&lt;/code&gt; in the &lt;strong&gt;Throws&lt;/strong&gt; section of each method's specification.</source>
          <target state="translated">不需要实现来支持激活机制。如果此实现不支持激活，则都需要几种特定的激活API方法来引发 &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 。如果此实现支持激活，则这些方法绝不能抛出 &lt;code&gt; UnsupportedOperationException&lt;/code&gt; 。这些方法由每个方法的规范的&lt;strong&gt;Throws&lt;/strong&gt;部分中存在 &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 的条目表示。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3aaeb0d29c017dba3531c1ffc50226364e7eb90c" translate="yes" xml:space="preserve">
          <source>Implementations are not required to support the inter-process transfer of security contexts. Before exporting a context, calling the &lt;a href=&quot;gsscontext#isTransferable()&quot;&gt;&lt;code&gt;GSSContext.isTransferable&lt;/code&gt;&lt;/a&gt; will indicate if the context is transferable. Calling this method in an implementation that does not support it will result in a &lt;code&gt;GSSException&lt;/code&gt; with the error code &lt;a href=&quot;gssexception#UNAVAILABLE&quot;&gt;&lt;code&gt;GSSException.UNAVAILABLE&lt;/code&gt;&lt;/a&gt;. Some mechanism providers might require that the caller be granted permission to initiate or accept a security context. A failed permission check might cause a &lt;a href=&quot;../../../../java.base/java/lang/securityexception&quot;&gt;&lt;code&gt;SecurityException&lt;/code&gt;&lt;/a&gt; to be thrown from this method.</source>
          <target state="translated">不需要实现来支持安全上下文的进程间转移。在导出上下文之前，调用&lt;a href=&quot;gsscontext#isTransferable()&quot;&gt; &lt;code&gt;GSSContext.isTransferable&lt;/code&gt; &lt;/a&gt;将指示上下文是否可转让。在不支持该实现的实现中调用此方法将导致 &lt;code&gt;GSSException&lt;/code&gt; ，错误代码为&lt;a href=&quot;gssexception#UNAVAILABLE&quot;&gt; &lt;code&gt;GSSException.UNAVAILABLE&lt;/code&gt; &lt;/a&gt;。某些机制提供程序可能要求授予调用方启动或接受安全上下文的权限。权限检查失败可能会导致从此方法引发&lt;a href=&quot;../../../../java.base/java/lang/securityexception&quot;&gt; &lt;code&gt;SecurityException&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="300c1a5202ff7486ff2aa1de97b32a5d09be7717" translate="yes" xml:space="preserve">
          <source>Implementations are not required to support the inter-process transfer of security contexts. Calling the &lt;a href=&quot;#isTransferable()&quot;&gt;&lt;code&gt;isTransferable&lt;/code&gt;&lt;/a&gt; method will indicate if the context object is transferable.</source>
          <target state="translated">不需要实现来支持安全上下文的进程间转移。调用&lt;a href=&quot;#isTransferable()&quot;&gt; &lt;code&gt;isTransferable&lt;/code&gt; &lt;/a&gt;方法将指示上下文对象是否可转让。</target>
        </trans-unit>
        <trans-unit id="279ebb8422b455b13529fc4a3a9cbf3ded65a160" translate="yes" xml:space="preserve">
          <source>Implementations are required to support the encodings &quot;UTF-8&quot;, &quot;UTF-16&quot;, &quot;UTF-16BE&quot;, and &quot;UTF-16LE&quot; to guarantee that data is serializable in all encodings that are required to be supported by all XML parsers. When the encoding is UTF-8, whether or not a byte order mark is serialized, or if the output is big-endian or little-endian, is implementation dependent. When the encoding is UTF-16, whether or not the output is big-endian or little-endian is implementation dependent, but a Byte Order Mark must be generated for non-character outputs, such as &lt;code&gt;LSOutput.byteStream&lt;/code&gt; or &lt;code&gt;LSOutput.systemId&lt;/code&gt;. If the Byte Order Mark is not generated, a &quot;byte-order-mark-needed&quot; warning is reported. When the encoding is UTF-16LE or UTF-16BE, the output is big-endian (UTF-16BE) or little-endian (UTF-16LE) and the Byte Order Mark is not be generated. In all cases, the encoding declaration, if generated, will correspond to the encoding used during the serialization (e.g. &lt;code&gt;encoding=&quot;UTF-16&quot;&lt;/code&gt; will appear if UTF-16 was requested).</source>
          <target state="translated">需要实现以支持编码&amp;ldquo; UTF-8&amp;rdquo;，&amp;ldquo; UTF-16&amp;rdquo;，&amp;ldquo; UTF-16BE&amp;rdquo;和&amp;ldquo; UTF-16LE&amp;rdquo;，以确保数据可序列化为所有XML解析器都支持的所有编码。当编码为UTF-8时，是否将字节顺序标记序列化，或者输出是big-endian还是little-endian，则取决于实现。当编码为UTF-16时，输出是big-endian还是little-endian取决于实现，但是必须为非字符输出生成字节顺序标记，例如 &lt;code&gt;LSOutput.byteStream&lt;/code&gt; 或 &lt;code&gt;LSOutput.systemId&lt;/code&gt; 。如果未生成字节顺序标记，则会报告&amp;ldquo;需要字节顺序标记&amp;rdquo;警告。当编码为UTF-16LE或UTF-16BE时，输出为big-endian（UTF-16BE）或little-endian（UTF-16LE），并且不会生成字节顺序标记。在所有情况下，编码声明（如果生成）将对应于序列化过程中使用的编码（例如，如果请求UTF-16，则将显示 &lt;code&gt;encoding=&quot;UTF-16&quot;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="c6210cf47411e0dfdee18058689ad0ba683b6a96" translate="yes" xml:space="preserve">
          <source>Implementations may declare support for units not listed by &lt;a href=&quot;#getUnits()&quot;&gt;&lt;code&gt;getUnits()&lt;/code&gt;&lt;/a&gt;. Typically, the implementation would define additional units as conversions for the convenience of developers.</source>
          <target state="translated">实现可以声明对未由&lt;a href=&quot;#getUnits()&quot;&gt; &lt;code&gt;getUnits()&lt;/code&gt; &lt;/a&gt;列出的单元的支持。通常，为方便开发人员，该实现会将其他单位定义为转换。</target>
        </trans-unit>
        <trans-unit id="72941d4649ad680b0f6b254a46807c194c448b61" translate="yes" xml:space="preserve">
          <source>Implementations may declare support for units not listed by &lt;a href=&quot;temporalamount#getUnits--&quot;&gt;&lt;code&gt;getUnits()&lt;/code&gt;&lt;/a&gt;. Typically, the implementation would define additional units as conversions for the convenience of developers.</source>
          <target state="translated">实现可以声明对&lt;a href=&quot;temporalamount#getUnits--&quot;&gt; &lt;code&gt;getUnits()&lt;/code&gt; &lt;/a&gt;未列出的单元的支持。通常，为方便开发人员，该实现会将其他单位定义为转换。</target>
        </trans-unit>
        <trans-unit id="90019721b0e69908f3a99c86842dc54fd684fc05" translate="yes" xml:space="preserve">
          <source>Implementations may define additional target names, but should use naming conventions such as reverse domain name notation to avoid name clashes.</source>
          <target state="translated">实现者可以定义更多的目标名称,但应使用命名惯例,如反向域名符号,以避免名称冲突。</target>
        </trans-unit>
        <trans-unit id="7ed96c27054978247c25aafe7cde2ed3d3f6d247" translate="yes" xml:space="preserve">
          <source>Implementations may define implementation-specific keys.</source>
          <target state="translated">实现可以定义特定的实现键。</target>
        </trans-unit>
        <trans-unit id="3d744716af7fd8fb39c04d68e9c8e3b43a019eaf" translate="yes" xml:space="preserve">
          <source>Implementations may use a caching strategy for performance reasons. As such, it is possible that the start of the millisecond observed via this clock will be later than that observed directly via the underlying clock.</source>
          <target state="translated">出于性能原因,实现可能会使用缓存策略。因此,通过该时钟观察到的毫秒的开始时间有可能会晚于直接通过底层时钟观察到的时间。</target>
        </trans-unit>
        <trans-unit id="e57a2e93acdecde99104a5856de790d14178c604" translate="yes" xml:space="preserve">
          <source>Implementations may use a caching strategy for performance reasons. As such, it is possible that the start of the minute observed via this clock will be later than that observed directly via the underlying clock.</source>
          <target state="translated">出于性能原因,实现可能会使用缓存策略。因此,通过该时钟观察到的分钟开始时间有可能会比直接通过底层时钟观察到的时间晚。</target>
        </trans-unit>
        <trans-unit id="04f1ca2276b8a29b06fcbeeba05dd07d9e348abf" translate="yes" xml:space="preserve">
          <source>Implementations may use a caching strategy for performance reasons. As such, it is possible that the start of the requested duration observed via this clock will be later than that observed directly via the underlying clock.</source>
          <target state="translated">出于性能原因,实现可能会使用缓存策略。因此,通过该时钟观察到的请求持续时间的开始时间有可能会晚于直接通过底层时钟观察到的时间。</target>
        </trans-unit>
        <trans-unit id="267df03caeacf7ccfb622de33114e48140903168" translate="yes" xml:space="preserve">
          <source>Implementations may use a caching strategy for performance reasons. As such, it is possible that the start of the second observed via this clock will be later than that observed directly via the underlying clock.</source>
          <target state="translated">出于性能原因,实现可能会使用缓存策略。因此,通过该时钟观察到的第二秒的开始时间有可能会晚于直接通过底层时钟观察到的时间。</target>
        </trans-unit>
        <trans-unit id="42a423f39aec87a0b698a181814535acfa0c37d2" translate="yes" xml:space="preserve">
          <source>Implementations may, though they need not, include additional values in the job's &lt;a href=&quot;jobstatereasons&quot;&gt;&lt;code&gt;JobStateReasons&lt;/code&gt;&lt;/a&gt; attribute to indicate the progress of the job, such as adding the &lt;code&gt;JOB_PRINTING&lt;/code&gt; value to indicate when the output device is actually making marks on paper and/or the &lt;code&gt;PROCESSING_TO_STOP_POINT&lt;/code&gt; value to indicate that the printer is in the process of canceling or aborting the job.</source>
          <target state="translated">实现可以（尽管不需要）在作业的&lt;a href=&quot;jobstatereasons&quot;&gt; &lt;code&gt;JobStateReasons&lt;/code&gt; &lt;/a&gt;属性中包含其他值以指示作业的进度，例如添加 &lt;code&gt;JOB_PRINTING&lt;/code&gt; 值以指示输出设备何时实际在纸上进行标记和/或 &lt;code&gt;PROCESSING_TO_STOP_POINT&lt;/code&gt; 值以指示打印机正在取消或中止作业。</target>
        </trans-unit>
        <trans-unit id="72c785333a007e0af3308efdcee58fc2bb59ca70" translate="yes" xml:space="preserve">
          <source>Implementations may, though they need not, include additional values in the job's &lt;a href=&quot;jobstatereasons&quot;&gt;&lt;code&gt;JobStateReasons&lt;/code&gt;&lt;/a&gt; attribute to indicate the progress of the job, such as adding the JOB_PRINTING value to indicate when the output device is actually making marks on paper and/or the PROCESSING_TO_STOP_POINT value to indicate that the printer is in the process of canceling or aborting the job.</source>
          <target state="translated">实现可以（尽管不需要）在作业的&lt;a href=&quot;jobstatereasons&quot;&gt; &lt;code&gt;JobStateReasons&lt;/code&gt; &lt;/a&gt;属性中包含其他值以指示作业的进度，例如添加JOB_PRINTING值以指示输出设备何时实际在纸上进行标记和/或PROCESSING_TO_STOP_POINT值以指示打印机正在取消或中止作业。</target>
        </trans-unit>
        <trans-unit id="5c2a22452963a67974d8eca84853200d44148ad1" translate="yes" xml:space="preserve">
          <source>Implementations must begin by checking to ensure that the input temporal object is of the same observable type as the implementation. They must then perform the calculation for all instances of &lt;a href=&quot;chronounit&quot;&gt;&lt;code&gt;ChronoUnit&lt;/code&gt;&lt;/a&gt;. An &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; must be thrown for &lt;code&gt;ChronoUnit&lt;/code&gt; instances that are unsupported.</source>
          <target state="translated">实现必须首先检查以确保输入的时间对象与实现具有相同的可观察类型。然后，他们必须对&lt;a href=&quot;chronounit&quot;&gt; &lt;code&gt;ChronoUnit&lt;/code&gt; 的&lt;/a&gt;所有实例执行计算。一个 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 必须抛出 &lt;code&gt;ChronoUnit&lt;/code&gt; 情况下是不支持的。</target>
        </trans-unit>
        <trans-unit id="bdb87811bb31cda5ac17ddd36108afefeabd84e6" translate="yes" xml:space="preserve">
          <source>Implementations must begin by checking to if the two temporals have the same type using &lt;code&gt;getClass()&lt;/code&gt;. If they do not, then the result must be obtained by calling &lt;code&gt;temporal1Inclusive.until(temporal2Exclusive, this)&lt;/code&gt;.</source>
          <target state="translated">实现必须首先使用 &lt;code&gt;getClass()&lt;/code&gt; 检查两个时态是否具有相同的类型。如果没有，则必须通过调用 &lt;code&gt;temporal1Inclusive.until(temporal2Exclusive, this)&lt;/code&gt; 获得结果。</target>
        </trans-unit>
        <trans-unit id="99c64c5755e63efaf236d48da5e987824e3c2112" translate="yes" xml:space="preserve">
          <source>Implementations must behave in a manor equivalent to the default method behavior.</source>
          <target state="translated">实现必须以与默认方法行为相当的方式进行。</target>
        </trans-unit>
        <trans-unit id="605da4bf3bfd7a213bfefbf11d71af5029cff3f0" translate="yes" xml:space="preserve">
          <source>Implementations must check and handle all fields defined in &lt;a href=&quot;chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt;. If the field is supported and has an &lt;code&gt;int&lt;/code&gt; range, then the value of the field must be returned. If unsupported, then an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; must be thrown.</source>
          <target state="translated">实现必须检查并处理&lt;a href=&quot;chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 中&lt;/a&gt;定义的所有字段。如果该字段受支持并且具有 &lt;code&gt;int&lt;/code&gt; 范围，则必须返回该字段的值。如果不受支持，则必须引发 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="326e8afcb79071d12736245c0670a0b22ed327ab" translate="yes" xml:space="preserve">
          <source>Implementations must check and handle all fields defined in &lt;a href=&quot;chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt;. If the field is supported, then the adjustment must be performed. If unsupported, then an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; must be thrown.</source>
          <target state="translated">实现必须检查并处理&lt;a href=&quot;chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 中&lt;/a&gt;定义的所有字段。如果支持该字段，则必须进行调整。如果不受支持，则必须引发 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="24d6daafcab1ab7caec669e141738ff42d7ea11e" translate="yes" xml:space="preserve">
          <source>Implementations must check and handle all fields defined in &lt;a href=&quot;chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt;. If the field is supported, then the range of the field must be returned. If unsupported, then an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; must be thrown.</source>
          <target state="translated">实现必须检查并处理&lt;a href=&quot;chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 中&lt;/a&gt;定义的所有字段。如果支持该字段，则必须返回该字段的范围。如果不受支持，则必须引发 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0d3ca1653868ebecb681dc93b4d875e227530a96" translate="yes" xml:space="preserve">
          <source>Implementations must check and handle all fields defined in &lt;a href=&quot;chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt;. If the field is supported, then the value of the field must be returned. If unsupported, then an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; must be thrown.</source>
          <target state="translated">实现必须检查并处理&lt;a href=&quot;chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 中&lt;/a&gt;定义的所有字段。如果支持该字段，则必须返回该字段的值。如果不受支持，则必须引发 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="88d058d164cfb523e09f28cd76915ef7323f9f89" translate="yes" xml:space="preserve">
          <source>Implementations must check and handle all fields defined in &lt;a href=&quot;chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt;. If the field is supported, then true must be returned, otherwise false must be returned.</source>
          <target state="translated">实现必须检查并处理&lt;a href=&quot;chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 中&lt;/a&gt;定义的所有字段。如果支持该字段，则必须返回true，否则必须返回false。</target>
        </trans-unit>
        <trans-unit id="7bd8473721518ac9344401f3ce0ebff69428b906" translate="yes" xml:space="preserve">
          <source>Implementations must check and handle all units defined in &lt;a href=&quot;chronounit&quot;&gt;&lt;code&gt;ChronoUnit&lt;/code&gt;&lt;/a&gt;. If the unit is supported, then the addition must be performed. If unsupported, then an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; must be thrown.</source>
          <target state="translated">实现必须检查并处理&lt;a href=&quot;chronounit&quot;&gt; &lt;code&gt;ChronoUnit&lt;/code&gt; 中&lt;/a&gt;定义的所有单元。如果支持该装置，则必须执行添加。如果不受支持，则必须引发 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="54a5a6f5a6257c54b041e51e2f466300a629dac3" translate="yes" xml:space="preserve">
          <source>Implementations must check and handle all units defined in &lt;a href=&quot;chronounit&quot;&gt;&lt;code&gt;ChronoUnit&lt;/code&gt;&lt;/a&gt;. If the unit is supported, then true must be returned, otherwise false must be returned.</source>
          <target state="translated">实现必须检查并处理&lt;a href=&quot;chronounit&quot;&gt; &lt;code&gt;ChronoUnit&lt;/code&gt; 中&lt;/a&gt;定义的所有单元。如果支持该单元，则必须返回true，否则必须返回false。</target>
        </trans-unit>
        <trans-unit id="bac724627545efd92aff130adf9ca347e33f9433" translate="yes" xml:space="preserve">
          <source>Implementations must ensure that no observable state is altered when this read-only method is invoked.</source>
          <target state="translated">实现必须确保在调用这个只读方法时,不会改变可观察的状态。</target>
        </trans-unit>
        <trans-unit id="ed106bff8c1e29175cd31f921160a542066c5d66" translate="yes" xml:space="preserve">
          <source>Implementations must not alter either this object or the specified temporal object. Instead, an adjusted copy of the original must be returned. This provides equivalent, safe behavior for immutable and mutable implementations.</source>
          <target state="translated">实现不得改变这个对象或指定的时间对象。相反,必须返回一个调整后的原始副本。这为不可变和可变的实现提供了等同的安全行为。</target>
        </trans-unit>
        <trans-unit id="cd2cfa4068cda0e805725377df4ada91ed41d4d7" translate="yes" xml:space="preserve">
          <source>Implementations must not alter the specified temporal object. Instead, an adjusted copy of the original must be returned. This provides equivalent, safe behavior for immutable and mutable implementations.</source>
          <target state="translated">实现不得改变指定的时间对象。相反,必须返回一个调整后的原始副本。这为不可变和可变的实现提供了等同的安全行为。</target>
        </trans-unit>
        <trans-unit id="3f230e75f808fadf35c94cfc851888119bcf87f0" translate="yes" xml:space="preserve">
          <source>Implementations must not alter this object. Instead, an adjusted copy of the original must be returned. This provides equivalent, safe behavior for immutable and mutable implementations.</source>
          <target state="translated">实现者不能改变这个对象。相反,必须返回一个调整后的原始副本。这为不可变和可变的实现提供了等同的安全行为。</target>
        </trans-unit>
        <trans-unit id="74a6d982447b042f899eb1e8d5f95251242078cc" translate="yes" xml:space="preserve">
          <source>Implementations must provide a result for each valid zone ID, however they do not have to provide a history of rules. Thus the map will always contain one element, and will only contain more than one element if historical rule information is available.</source>
          <target state="translated">实现必须为每个有效的区域ID提供一个结果,但是他们不必提供规则的历史。因此,地图将始终包含一个元素,只有在有历史规则信息的情况下,才会包含一个以上的元素。</target>
        </trans-unit>
        <trans-unit id="25d23de117447ed754f1b335e41805de9782f446" translate="yes" xml:space="preserve">
          <source>Implementations must provide a result for each valid zone ID, however they do not have to provide a history of rules. Thus the map will contain at least one element, and will only contain more than one element if historical rule information is available.</source>
          <target state="translated">实现必须为每个有效的区域ID提供一个结果,但是他们不必提供规则的历史。因此,地图将至少包含一个元素,只有在有历史规则信息的情况下才会包含一个以上的元素。</target>
        </trans-unit>
        <trans-unit id="c2fcd171ac5ea0d1a6a331955bf015198a85c6ae" translate="yes" xml:space="preserve">
          <source>Implementations of &lt;a href=&quot;collector&quot;&gt;&lt;code&gt;Collector&lt;/code&gt;&lt;/a&gt; that implement various useful reduction operations, such as accumulating elements into collections, summarizing elements according to various criteria, etc.</source>
          <target state="translated">实现各种有用的约简操作的&lt;a href=&quot;collector&quot;&gt; &lt;code&gt;Collector&lt;/code&gt; 的&lt;/a&gt;实现，例如将元素累积到集合中，根据各种标准对元素进行汇总等。</target>
        </trans-unit>
        <trans-unit id="50aa90cc364d703e70a936297fb56eed8f786007" translate="yes" xml:space="preserve">
          <source>Implementations of &lt;a href=&quot;constantdesc&quot;&gt;ConstantDesc&lt;/a&gt; must be &lt;a href=&quot;https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/lang/doc-files/ValueBased.html&quot;&gt;value-based&lt;/a&gt; classes.</source>
          <target state="translated">&lt;a href=&quot;constantdesc&quot;&gt;ConstantDesc的&lt;/a&gt;实现必须是&lt;a href=&quot;https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/lang/doc-files/ValueBased.html&quot;&gt;基于值的&lt;/a&gt;类。</target>
        </trans-unit>
        <trans-unit id="56c583707ceca10be97e7528d97e75c1ef0caad2" translate="yes" xml:space="preserve">
          <source>Implementations of &lt;a href=&quot;httprequest.bodypublisher&quot;&gt;&lt;code&gt;BodyPublisher&lt;/code&gt;&lt;/a&gt; that implement various useful publishers, such as publishing the request body from a String, or from a file.</source>
          <target state="translated">&lt;a href=&quot;httprequest.bodypublisher&quot;&gt; &lt;code&gt;BodyPublisher&lt;/code&gt; 的&lt;/a&gt;实现，该实现实现了各种有用的发布者，例如从String或从文件发布请求正文。</target>
        </trans-unit>
        <trans-unit id="f0e5930142ddaf85b2c690a6452341555a620717" translate="yes" xml:space="preserve">
          <source>Implementations of &lt;a href=&quot;httpresponse.bodyhandler&quot;&gt;&lt;code&gt;BodyHandler&lt;/code&gt;&lt;/a&gt; that implement various useful handlers, such as handling the response body as a String, or streaming the response body to a file.</source>
          <target state="translated">的实施方式中&lt;a href=&quot;httpresponse.bodyhandler&quot;&gt; &lt;code&gt;BodyHandler&lt;/code&gt; &lt;/a&gt;实现各种有用的处理，例如处理响应主体为字符串，或者响应体流式传输到一个文件。</target>
        </trans-unit>
        <trans-unit id="eafe6d74c7776fb65071b9a548e19a8c637730ac" translate="yes" xml:space="preserve">
          <source>Implementations of &lt;a href=&quot;httpresponse.bodysubscriber&quot;&gt;&lt;code&gt;BodySubscriber&lt;/code&gt;&lt;/a&gt; that implement various useful subscribers, such as converting the response body bytes into a String, or streaming the bytes to a file.</source>
          <target state="translated">&lt;a href=&quot;httpresponse.bodysubscriber&quot;&gt; &lt;code&gt;BodySubscriber&lt;/code&gt; 的&lt;/a&gt;实现，该实现实现了各种有用的订阅者，例如将响应正文字节转换为String或将字节流传输到文件。</target>
        </trans-unit>
        <trans-unit id="fda3fc111a7c70a81a169cb2fa4b3f7a1e491639" translate="yes" xml:space="preserve">
          <source>Implementations of &lt;code&gt;ModuleReader&lt;/code&gt; should take great care when translating an abstract resource name to the location of a resource in a packaged module or on the file system. Implementations are advised to treat resource names with elements such as '&lt;code&gt;.&lt;/code&gt;, '&lt;code&gt;..&lt;/code&gt;', elements containing file separators, or empty elements as &quot;not found&quot;. More generally, if the resource name is not in the stream of elements that the &lt;code&gt;list&lt;/code&gt; method returns then the resource should be treated as &quot;not found&quot; to avoid inconsistencies.</source>
          <target state="translated">将抽象资源名称转换为打包模块或文件系统中资源的位置时， &lt;code&gt;ModuleReader&lt;/code&gt; 的实现应格外小心。建议实现将资源名称用诸如'等元素对待 &lt;code&gt;.&lt;/code&gt; ，&amp;ldquo; &lt;code&gt;..&lt;/code&gt; &amp;rdquo;，包含文件分隔符的元素或&amp;ldquo;未找到&amp;rdquo;的空元素。更一般而言，如果资源名称不在 &lt;code&gt;list&lt;/code&gt; 方法返回的元素流中，则应将资源视为&amp;ldquo;未找到&amp;rdquo;，以避免不一致。</target>
        </trans-unit>
        <trans-unit id="d62ca42b5c26ec3f438b17776a6e4557007f5596" translate="yes" xml:space="preserve">
          <source>Implementations of &lt;code&gt;TreeNode&lt;/code&gt; that override &lt;code&gt;equals&lt;/code&gt; will typically need to override &lt;code&gt;hashCode&lt;/code&gt; as well. Refer to &lt;a href=&quot;treemodel&quot;&gt;&lt;code&gt;TreeModel&lt;/code&gt;&lt;/a&gt; for more information. For further information and examples of using tree nodes, see &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/components/tree.html&quot;&gt;How to Use Tree Nodes&lt;/a&gt; in &lt;em&gt;The Java Tutorial.&lt;/em&gt;</source>
          <target state="translated">覆盖 &lt;code&gt;equals&lt;/code&gt; 的 &lt;code&gt;TreeNode&lt;/code&gt; 实现通常也需要覆盖 &lt;code&gt;hashCode&lt;/code&gt; 。有关更多信息，请参考&lt;a href=&quot;treemodel&quot;&gt; &lt;code&gt;TreeModel&lt;/code&gt; &lt;/a&gt;。有关使用树节点的更多信息和示例，请参见&lt;em&gt;《 Java教程&lt;/em&gt;&lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/components/tree.html&quot;&gt;》&lt;/a&gt;中的&lt;em&gt;&amp;ldquo;&lt;/em&gt;如何使用树节点&lt;em&gt;&amp;rdquo;。&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d38f88e4c94db7a0d7874b2e028aca9c57ede1cb" translate="yes" xml:space="preserve">
          <source>Implementations of &lt;code&gt;TreeNode&lt;/code&gt; that override &lt;code&gt;equals&lt;/code&gt; will typically need to override &lt;code&gt;hashCode&lt;/code&gt; as well. Refer to &lt;a href=&quot;treemodel&quot;&gt;&lt;code&gt;TreeModel&lt;/code&gt;&lt;/a&gt; for more information. For further information and examples of using tree nodes, see &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/uiswing/components/tree.html&quot;&gt;How to Use Tree Nodes&lt;/a&gt; in &lt;em&gt;The Java Tutorial.&lt;/em&gt;</source>
          <target state="translated">覆盖 &lt;code&gt;equals&lt;/code&gt; 的 &lt;code&gt;TreeNode&lt;/code&gt; 实现通常也需要覆盖 &lt;code&gt;hashCode&lt;/code&gt; 。有关更多信息，请参考&lt;a href=&quot;treemodel&quot;&gt; &lt;code&gt;TreeModel&lt;/code&gt; &lt;/a&gt;。有关使用树节点的更多信息和示例，请参见&lt;em&gt;《 Java教程&lt;/em&gt;&lt;a href=&quot;https://docs.oracle.com/javase/tutorial/uiswing/components/tree.html&quot;&gt;》&lt;/a&gt;中的&lt;em&gt;&amp;ldquo;&lt;/em&gt;如何使用树节点&lt;em&gt;&amp;rdquo;。&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="993e4aede7d89287621098e82da0b0a8d21ce0b4" translate="yes" xml:space="preserve">
          <source>Implementations of entry-returning methods are expected to return &lt;code&gt;Map.Entry&lt;/code&gt; pairs representing snapshots of mappings at the time they were produced, and thus generally do &lt;em&gt;not&lt;/em&gt; support the optional &lt;code&gt;Entry.setValue&lt;/code&gt; method. Note however that it is possible to change mappings in the associated map using method &lt;code&gt;put&lt;/code&gt;.</source>
          <target state="translated">预期返回条目的方法的实现将返回 &lt;code&gt;Map.Entry&lt;/code&gt; 对，它们表示映射生成时的快照，因此通常&lt;em&gt;不&lt;/em&gt;支持可选的 &lt;code&gt;Entry.setValue&lt;/code&gt; 方法。但是请注意，可以使用 &lt;code&gt;put&lt;/code&gt; 方法更改关联映射中的映射。</target>
        </trans-unit>
        <trans-unit id="d3b30e509d044195699ed5241d1f9e400fe5a8aa" translate="yes" xml:space="preserve">
          <source>Implementations of the DataInput and DataOutput interfaces represent Unicode strings in a format that is a slight modification of UTF-8. (For information regarding the standard UTF-8 format, see section</source>
          <target state="translated">DataInput和DataOutput接口的实现以UTF-8的轻微修改格式表示Unicode字符串。(关于标准UTF-8格式的信息,请参见章节</target>
        </trans-unit>
        <trans-unit id="0a34c5a5639e138de40d514fc9cb6812e04cb9ff" translate="yes" xml:space="preserve">
          <source>Implementations of the Java time-scale using the JSR-310 API are not required to provide any clock that is sub-second accurate, or that progresses monotonically or smoothly. Implementations are therefore not required to actually perform the UTC-SLS slew or to otherwise be aware of leap seconds. JSR-310 does, however, require that implementations must document the approach they use when defining a clock representing the current instant. See &lt;a href=&quot;clock&quot;&gt;&lt;code&gt;Clock&lt;/code&gt;&lt;/a&gt; for details on the available clocks.</source>
          <target state="translated">不需要使用JSR-310 API来实现Java时标，即可提供亚秒级精度或单调或平稳进行的时钟。因此，不需要实际执行UTC-SLS转换或以其他方式意识到otherwise秒的实现。但是，JSR-310确实要求实现必须记录它们在定义代表当前时刻的时钟时使用的方法。见&lt;a href=&quot;clock&quot;&gt; &lt;code&gt;Clock&lt;/code&gt; &lt;/a&gt;上可用的时钟细节。</target>
        </trans-unit>
        <trans-unit id="7ee8c35661e0c08111bc2cda529b33eb9ba4c61e" translate="yes" xml:space="preserve">
          <source>Implementations of these locale sensitive services are packaged using the Java Extension Mechanism as installed extensions. A provider identifies itself with a provider-configuration file in the resource directory META-INF/services, using the fully qualified provider interface class name as the file name. The file should contain a list of fully-qualified concrete provider class names, one per line. A line is terminated by any one of a line feed ('\n'), a carriage return ('\r'), or a carriage return followed immediately by a line feed. Space and tab characters surrounding each name, as well as blank lines, are ignored. The comment character is '#' ('#'); on each line all characters following the first comment character are ignored. The file must be encoded in UTF-8.</source>
          <target state="translated">这些locale敏感服务的实现是使用Java扩展机制作为安装的扩展进行打包的。提供者用资源目录META-INF/services中的提供者配置文件来标识自己,使用完全限定的提供者接口类名作为文件名。该文件应该包含一个完全限定的具体提供者类名的列表,每行一个。每行由换行符('\n')、回车符('\r')或紧接着换行符的回车符中的任何一种结束。每个名字周围的空格和制表符,以及空行都会被忽略。注释字符是'#'('#');每行中第一个注释字符之后的所有字符都将被忽略。文件必须以UTF-8编码。</target>
        </trans-unit>
        <trans-unit id="acf4fcd382a74c4dbdd3e6fcf810f002d6e56033" translate="yes" xml:space="preserve">
          <source>Implementations of these locale sensitive services can be made available by adding them to the application's class path. A provider identifies itself with a provider-configuration file in the resource directory META-INF/services, using the fully qualified provider interface class name as the file name. The file should contain a list of fully-qualified concrete provider class names, one per line. A line is terminated by any one of a line feed ('\n'), a carriage return ('\r'), or a carriage return followed immediately by a line feed. Space and tab characters surrounding each name, as well as blank lines, are ignored. The comment character is '#' ('#'); on each line all characters following the first comment character are ignored. The file must be encoded in UTF-8.</source>
          <target state="translated">这些对语言环境敏感的服务的实现可以通过将它们添加到应用程序的类路径中来实现。提供者用资源目录META-INF/services中的提供者配置文件来标识自己,使用完全限定的提供者接口类名作为文件名。该文件应该包含一个完全限定的具体提供者类名的列表,每行一个。每行由换行符('\n')、回车符('\r')或紧接着换行符的回车符中的任何一种结束。每个名字周围的空格和制表符,以及空行都会被忽略。注释字符是'#'('#');每行中第一个注释字符之后的所有字符都将被忽略。文件必须以UTF-8编码。</target>
        </trans-unit>
        <trans-unit id="9c79b815c8ed87dfe91404db79bb52d71de12170" translate="yes" xml:space="preserve">
          <source>Implementations of this class provide lookup services for print services (typically equivalent to printers) of a particular type.</source>
          <target state="translated">该类的实现为特定类型的打印服务(通常相当于打印机)提供查找服务。</target>
        </trans-unit>
        <trans-unit id="089a7b88f26f69596bf9828e528be33ab419614f" translate="yes" xml:space="preserve">
          <source>Implementations of this interface and of &lt;code&gt;NotificationBroadcaster&lt;/code&gt; should be careful about synchronization. In particular, it is not a good idea for an implementation to hold any locks while it is calling a listener. To deal with the possibility that the list of listeners might change while a notification is being dispatched, a good strategy is to use a &lt;a href=&quot;../../../java.base/java/util/concurrent/copyonwritearraylist&quot;&gt;&lt;code&gt;CopyOnWriteArrayList&lt;/code&gt;&lt;/a&gt; for this list.</source>
          <target state="translated">此接口和 &lt;code&gt;NotificationBroadcaster&lt;/code&gt; 的实现应注意同步。特别是，实现在调用侦听器时保持任何锁不是一个好主意。为了处理在发送通知时侦听器列表可能更改的可能性，一个好的策略是对该列表使用&lt;a href=&quot;../../../java.base/java/util/concurrent/copyonwritearraylist&quot;&gt; &lt;code&gt;CopyOnWriteArrayList&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f006a559626fb65e046d55aa1f754669269e0a38" translate="yes" xml:space="preserve">
          <source>Implementations of this interface and of &lt;code&gt;NotificationBroadcaster&lt;/code&gt; should be careful about synchronization. In particular, it is not a good idea for an implementation to hold any locks while it is calling a listener. To deal with the possibility that the list of listeners might change while a notification is being dispatched, a good strategy is to use a &lt;a href=&quot;../../java/util/concurrent/copyonwritearraylist&quot;&gt;&lt;code&gt;CopyOnWriteArrayList&lt;/code&gt;&lt;/a&gt; for this list.</source>
          <target state="translated">此接口和 &lt;code&gt;NotificationBroadcaster&lt;/code&gt; 的实现应注意同步。特别是，实现在调用侦听器时保留任何锁不是一个好主意。为了处理在发送通知时侦听器列表可能更改的可能性，一个好的策略是对该列表使用&lt;a href=&quot;../../java/util/concurrent/copyonwritearraylist&quot;&gt; &lt;code&gt;CopyOnWriteArrayList&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9c232244698db00ce36774a2c87375ef2ab6b6f4" translate="yes" xml:space="preserve">
          <source>Implementations of this interface and of &lt;code&gt;NotificationEmitter&lt;/code&gt; should be careful about synchronization. In particular, it is not a good idea for an implementation to hold any locks while it is calling a listener. To deal with the possibility that the list of listeners might change while a notification is being dispatched, a good strategy is to use a &lt;a href=&quot;../../../java.base/java/util/concurrent/copyonwritearraylist&quot;&gt;&lt;code&gt;CopyOnWriteArrayList&lt;/code&gt;&lt;/a&gt; for this list.</source>
          <target state="translated">此接口和 &lt;code&gt;NotificationEmitter&lt;/code&gt; 的实现应注意同步。特别是，实现在调用侦听器时保持任何锁不是一个好主意。为了处理在发送通知时侦听器列表可能更改的可能性，一个好的策略是对该列表使用&lt;a href=&quot;../../../java.base/java/util/concurrent/copyonwritearraylist&quot;&gt; &lt;code&gt;CopyOnWriteArrayList&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="58aa1ab9d54f0bb6c3d1e90d7b35e36a53ae6ddf" translate="yes" xml:space="preserve">
          <source>Implementations of this interface and of &lt;code&gt;NotificationEmitter&lt;/code&gt; should be careful about synchronization. In particular, it is not a good idea for an implementation to hold any locks while it is calling a listener. To deal with the possibility that the list of listeners might change while a notification is being dispatched, a good strategy is to use a &lt;a href=&quot;../../java/util/concurrent/copyonwritearraylist&quot;&gt;&lt;code&gt;CopyOnWriteArrayList&lt;/code&gt;&lt;/a&gt; for this list.</source>
          <target state="translated">此接口和 &lt;code&gt;NotificationEmitter&lt;/code&gt; 的实现应注意同步。特别是，实现在调用侦听器时保持任何锁不是一个好主意。为了解决在分发通知时侦听器列表可能更改的可能性，一种好的策略是对此列表使用&lt;a href=&quot;../../java/util/concurrent/copyonwritearraylist&quot;&gt; &lt;code&gt;CopyOnWriteArrayList&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="94b491a654af895b6d8857d4a56507944db181aa" translate="yes" xml:space="preserve">
          <source>Implementations of this interface are attached to a &lt;a href=&quot;../docprintjob&quot;&gt;&lt;code&gt;DocPrintJob&lt;/code&gt;&lt;/a&gt; to monitor the status of attribute changes associated with the print job.</source>
          <target state="translated">该接口的实现附加到&lt;a href=&quot;../docprintjob&quot;&gt; &lt;code&gt;DocPrintJob&lt;/code&gt; 上,&lt;/a&gt;以监视与打印作业关联的属性更改的状态。</target>
        </trans-unit>
        <trans-unit id="4aa8cb2baf5c284c221df16a7268ff0b1941abb2" translate="yes" xml:space="preserve">
          <source>Implementations of this interface are immutable and safe for use by multiple concurrent threads.</source>
          <target state="translated">这个接口的实现是不可变的,并且可以安全地被多个并发线程使用。</target>
        </trans-unit>
        <trans-unit id="400d75bea668902088fb6f4dd120ccf19da096c5" translate="yes" xml:space="preserve">
          <source>Implementations of this interface are immutable and thread-safe.</source>
          <target state="translated">这个接口的实现是不可变和线程安全的。</target>
        </trans-unit>
        <trans-unit id="699030129df57c43c6cb54ecff7c6b735c0f2aac" translate="yes" xml:space="preserve">
          <source>Implementations of this interface are immutable, thread-safe and &lt;a href=&quot;https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/lang/doc-files/ValueBased.html&quot;&gt;value-based&lt;/a&gt;.</source>
          <target state="translated">此接口的实现是不可变的，线程安全的和&lt;a href=&quot;https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/lang/doc-files/ValueBased.html&quot;&gt;基于值的&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="49c062426f85483f883d6e693db7f7fa3fbe1290" translate="yes" xml:space="preserve">
          <source>Implementations of this interface are passed to a &lt;code&gt;CallbackHandler&lt;/code&gt;, allowing underlying security services the ability to interact with a calling application to retrieve specific authentication data such as usernames and passwords, or to display certain information, such as error and warning messages.</source>
          <target state="translated">此接口的实现传递给 &lt;code&gt;CallbackHandler&lt;/code&gt; ，使基础安全服务能够与调用应用程序进行交互，以检索特定的身份验证数据（例如用户名和密码），或显示某些信息（例如错误和警告消息）。</target>
        </trans-unit>
        <trans-unit id="58261f86ebc3621d1ab8d9da33065adeb7d657d0" translate="yes" xml:space="preserve">
          <source>Implementations of this interface can differ regarding the thread in which the methods of filters and listeners are called.</source>
          <target state="translated">这个接口的实现可以在调用过滤器和监听器方法的线程上有所不同。</target>
        </trans-unit>
        <trans-unit id="027d52c95dd46e88fa1635d12867938271a5588b" translate="yes" xml:space="preserve">
          <source>Implementations of this interface should specify the events they support.</source>
          <target state="translated">该接口的实现应指定其支持的事件。</target>
        </trans-unit>
        <trans-unit id="c6e3891d672494d0423b2340b5ba53445ff48f7f" translate="yes" xml:space="preserve">
          <source>Implementations of this listener interface are attached to a &lt;a href=&quot;../printservice&quot;&gt;&lt;code&gt;PrintService&lt;/code&gt;&lt;/a&gt; to monitor the status of the print service.</source>
          <target state="translated">此侦听器接口的实现附加到&lt;a href=&quot;../printservice&quot;&gt; &lt;code&gt;PrintService&lt;/code&gt; ,&lt;/a&gt;以监视打印服务的状态。</target>
        </trans-unit>
        <trans-unit id="75c9d5402d09dbbffee2d3bf6c5bc10e82a612cd" translate="yes" xml:space="preserve">
          <source>Implementations of this listener interface should be attached to a &lt;a href=&quot;../docprintjob&quot;&gt;&lt;code&gt;DocPrintJob&lt;/code&gt;&lt;/a&gt; to monitor the status of the printer job.</source>
          <target state="translated">此侦听器接口的实现应附加到&lt;a href=&quot;../docprintjob&quot;&gt; &lt;code&gt;DocPrintJob&lt;/code&gt; 上,&lt;/a&gt;以监视打印机作业的状态。</target>
        </trans-unit>
        <trans-unit id="98cca08688fad60efd0ff1cada2bd3924fcafeb7" translate="yes" xml:space="preserve">
          <source>Implementations of this listener interface should be attached to a &lt;a href=&quot;../docprintjob&quot;&gt;&lt;code&gt;DocPrintJob&lt;/code&gt;&lt;/a&gt; to monitor the status of the printer job. These callback methods may be invoked on the thread processing the print job, or a service created notification thread. In either case the client should not perform lengthy processing in these callbacks.</source>
          <target state="translated">此侦听器接口的实现应附加到&lt;a href=&quot;../docprintjob&quot;&gt; &lt;code&gt;DocPrintJob&lt;/code&gt; 上,&lt;/a&gt;以监视打印机作业的状态。这些回调方法可以在处理打印作业的线程或服务创建的通知线程上调用。无论哪种情况，客户端都不应该在这些回调中执行冗长的处理。</target>
        </trans-unit>
        <trans-unit id="4402cd1b45417982edba7b2ac6df98c76b27647c" translate="yes" xml:space="preserve">
          <source>Implementations of this method are permitted, but not required, to return the same object from multiple invocations.</source>
          <target state="translated">该方法的实现允许但不要求从多次调用中返回同一个对象。</target>
        </trans-unit>
        <trans-unit id="a1f0a740fb87b360af2d304f28d804dd997ef4e9" translate="yes" xml:space="preserve">
          <source>Implementations of this method need not create a separate &lt;code&gt;List&lt;/code&gt; object for each call. Using this method is likely to have comparable cost to using the like-named field. (Unlike this method, the field does not provide type safety.)</source>
          <target state="translated">此方法的实现无需为每个调用创建单独的 &lt;code&gt;List&lt;/code&gt; 对象。使用此方法可能具有与使用类似名称的字段相当的成本。（与这种方法不同，该字段不提供类型安全性。）</target>
        </trans-unit>
        <trans-unit id="7d7e4eb6f727ccc34715a0e9ae615998421dde8c" translate="yes" xml:space="preserve">
          <source>Implementations of this method need not create a separate &lt;code&gt;Map&lt;/code&gt; object for each call. Using this method is likely to have comparable cost to using the like-named field. (Unlike this method, the field does not provide type safety.)</source>
          <target state="translated">此方法的实现无需为每个调用创建单独的 &lt;code&gt;Map&lt;/code&gt; 对象。使用此方法可能具有与使用类似名称的字段相当的成本。（与这种方法不同，该字段不提供类型安全性。）</target>
        </trans-unit>
        <trans-unit id="f753f34db48ccb0310777f203dd093fd8129db52" translate="yes" xml:space="preserve">
          <source>Implementations of this method need not create a separate &lt;code&gt;NavigableMap&lt;/code&gt; object for each call.</source>
          <target state="translated">此方法的实现无需为每个调用创建单独的 &lt;code&gt;NavigableMap&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="724af2588f9712c349db1f2980acabcda1643883" translate="yes" xml:space="preserve">
          <source>Implementations of this method need not create a separate &lt;code&gt;NavigableSet&lt;/code&gt; object for each call.</source>
          <target state="translated">此方法的实现无需为每个调用创建单独的 &lt;code&gt;NavigableSet&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="8c569f90769c2ffcc16f17ff5ae79fd3729cd607" translate="yes" xml:space="preserve">
          <source>Implementations of this method need not create a separate &lt;code&gt;Set&lt;/code&gt; object for each call. Using this method is likely to have comparable cost to using the like-named field. (Unlike this method, the field does not provide type safety.)</source>
          <target state="translated">此方法的实现无需为每个调用创建单独的 &lt;code&gt;Set&lt;/code&gt; 对象。使用此方法可能具有与使用类似名称的字段相当的成本。（与这种方法不同，该字段不提供类型安全性。）</target>
        </trans-unit>
        <trans-unit id="a6219835d128fc2b015c10dfba2058045935cdb9" translate="yes" xml:space="preserve">
          <source>Implementations of this method need not create a separate &lt;code&gt;SortedMap&lt;/code&gt; object for each call.</source>
          <target state="translated">此方法的实现无需为每个调用创建单独的 &lt;code&gt;SortedMap&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="4148397f35d90aa072e66df043b8d5c754ee09b6" translate="yes" xml:space="preserve">
          <source>Implementations of this method need not create a separate &lt;code&gt;SortedSet&lt;/code&gt; object for each call.</source>
          <target state="translated">此方法的实现无需为每个调用创建单独的 &lt;code&gt;SortedSet&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="fc865e84a8b192577a99b4d5bdcabe36bdf2a1ba" translate="yes" xml:space="preserve">
          <source>Implementations should combine duplicate TreePaths that are added to the selection. For example, the following code</source>
          <target state="translated">实现时应将添加到选择中的重复的TreePaths合并。例如,下面的代码</target>
        </trans-unit>
        <trans-unit id="e09a8eb7b589680f1982a4e270b31adca911a817" translate="yes" xml:space="preserve">
          <source>Implementations should determine whether they are supported using the fields available in &lt;a href=&quot;chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">实现应使用&lt;a href=&quot;chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 中&lt;/a&gt;可用的字段来确定是否支持它们。</target>
        </trans-unit>
        <trans-unit id="6d0dc13ed50551259c51f74f77585ebb3686a0b5" translate="yes" xml:space="preserve">
          <source>Implementations should implement &lt;code&gt;Serializable&lt;/code&gt; wherever possible and must document whether or not they do support serialization.</source>
          <target state="translated">实现应尽可能实现 &lt;code&gt;Serializable&lt;/code&gt; ,并且必须记录它们是否支持序列化。</target>
        </trans-unit>
        <trans-unit id="f20a07b2b8fb2eb7d7481c5c66b280630e90b787" translate="yes" xml:space="preserve">
          <source>Implementations should override the default &lt;code&gt;destroy&lt;/code&gt; and &lt;code&gt;isDestroyed&lt;/code&gt; methods from the &lt;a href=&quot;../../javax/security/auth/destroyable&quot;&gt;&lt;code&gt;Destroyable&lt;/code&gt;&lt;/a&gt; interface to enable sensitive key information to be destroyed, cleared, or in the case where such information is immutable, unreferenced. Finally, since &lt;code&gt;PrivateKey&lt;/code&gt; is &lt;code&gt;Serializable&lt;/code&gt;, implementations should also override &lt;a href=&quot;../io/objectoutputstream#writeObject(java.lang.Object)&quot;&gt;&lt;code&gt;ObjectOutputStream.writeObject(java.lang.Object)&lt;/code&gt;&lt;/a&gt; to prevent keys that have been destroyed from being serialized.</source>
          <target state="translated">实现应覆盖&lt;a href=&quot;../../javax/security/auth/destroyable&quot;&gt; &lt;code&gt;Destroyable&lt;/code&gt; &lt;/a&gt;接口中的默认 &lt;code&gt;destroy&lt;/code&gt; 和 &lt;code&gt;isDestroyed&lt;/code&gt; 方法，以使敏感密钥信息能够被销毁，清除，或者在此类信息不可更改的情况下不受引用。最后，由于 &lt;code&gt;PrivateKey&lt;/code&gt; 是 &lt;code&gt;Serializable&lt;/code&gt; ，因此实现还应该重写&lt;a href=&quot;../io/objectoutputstream#writeObject(java.lang.Object)&quot;&gt; &lt;code&gt;ObjectOutputStream.writeObject(java.lang.Object)&lt;/code&gt; &lt;/a&gt;以防止序列化销毁的密钥。</target>
        </trans-unit>
        <trans-unit id="c2023f1a7cd65e43dc987df91289f438391353dd" translate="yes" xml:space="preserve">
          <source>Implementations should override the default &lt;code&gt;destroy&lt;/code&gt; and &lt;code&gt;isDestroyed&lt;/code&gt; methods from the &lt;a href=&quot;../../javax/security/auth/destroyable&quot;&gt;&lt;code&gt;Destroyable&lt;/code&gt;&lt;/a&gt; interface to enable sensitive key information to be destroyed, cleared, or in the case where such information is immutable, unreferenced. Finally, since &lt;code&gt;PrivateKey&lt;/code&gt; is &lt;code&gt;Serializable&lt;/code&gt;, implementations should also override &lt;a href=&quot;../io/objectoutputstream#writeObject-java.lang.Object-&quot;&gt;&lt;code&gt;ObjectOutputStream.writeObject(java.lang.Object)&lt;/code&gt;&lt;/a&gt; to prevent keys that have been destroyed from being serialized.</source>
          <target state="translated">实现应覆盖&lt;a href=&quot;../../javax/security/auth/destroyable&quot;&gt; &lt;code&gt;Destroyable&lt;/code&gt; &lt;/a&gt;接口中默认的 &lt;code&gt;destroy&lt;/code&gt; 和 &lt;code&gt;isDestroyed&lt;/code&gt; 方法，以使敏感密钥信息能够被销毁，清除，或者在此类信息不可更改的情况下不受引用。最后，由于 &lt;code&gt;PrivateKey&lt;/code&gt; 是 &lt;code&gt;Serializable&lt;/code&gt; ，因此实现还应该重写&lt;a href=&quot;../io/objectoutputstream#writeObject-java.lang.Object-&quot;&gt; &lt;code&gt;ObjectOutputStream.writeObject(java.lang.Object)&lt;/code&gt; &lt;/a&gt;以防止序列化销毁的密钥。</target>
        </trans-unit>
        <trans-unit id="3f89a141b40f5b504d614a3aa48c27dfceeae9ae" translate="yes" xml:space="preserve">
          <source>Implementations should perform any queries or calculations using the fields available in &lt;a href=&quot;chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt;. If the field is not supported an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; must be thrown.</source>
          <target state="translated">实现应使用&lt;a href=&quot;chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 中&lt;/a&gt;可用的字段执行任何查询或计算。如果不支持该字段，则必须引发 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bb7adf8c98b0949039b35e12066594b1afab0446" translate="yes" xml:space="preserve">
          <source>Implementations should perform any queries or calculations using the units available in &lt;a href=&quot;chronounit&quot;&gt;&lt;code&gt;ChronoUnit&lt;/code&gt;&lt;/a&gt; or the fields available in &lt;a href=&quot;chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt;. If the unit is not supported an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; must be thrown.</source>
          <target state="translated">实现应使用&lt;a href=&quot;chronounit&quot;&gt; &lt;code&gt;ChronoUnit&lt;/code&gt; 中&lt;/a&gt;可用的单位或&lt;a href=&quot;chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 中&lt;/a&gt;可用的字段执行任何查询或计算。如果不支持该单元，则必须引发 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7ceb7c1ca9b69ca4554167b37ceed67cb09622fc" translate="yes" xml:space="preserve">
          <source>Implementations should perform any queries or calculations using the units available in &lt;a href=&quot;chronounit&quot;&gt;&lt;code&gt;ChronoUnit&lt;/code&gt;&lt;/a&gt; or the fields available in &lt;a href=&quot;chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt;. If the unit is not supported an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; must be thrown. Implementations must not alter the specified temporal objects.</source>
          <target state="translated">实现应使用&lt;a href=&quot;chronounit&quot;&gt; &lt;code&gt;ChronoUnit&lt;/code&gt; 中&lt;/a&gt;可用的单位或&lt;a href=&quot;chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 中&lt;/a&gt;可用的字段执行任何查询或计算。如果不支持该单元，则必须引发 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。实现不得更改指定的时间对象。</target>
        </trans-unit>
        <trans-unit id="f4c8d5deb5010407f725941d6330fb83e7adf8c4" translate="yes" xml:space="preserve">
          <source>Implementations should raise other exceptions under other circumstances. For example, implementations should raise an implementation-dependent exception if a &lt;code&gt;null&lt;/code&gt; argument is passed when &lt;code&gt;null&lt;/code&gt; was not expected.</source>
          <target state="translated">在其他情况下，实现应引发其他例外情况。例如，如果一个实现应该引发一个与实现有关的异常 &lt;code&gt;null&lt;/code&gt; 当参数传递 &lt;code&gt;null&lt;/code&gt; 预期不会了。</target>
        </trans-unit>
        <trans-unit id="d8fb224f30dd82a4384971b67059784a6d15590c" translate="yes" xml:space="preserve">
          <source>Implementations should transparently handle artifacts of the transmission protocol. For example, when using the T=0 protocol, the following processing should occur as described in ISO/IEC 7816-4:</source>
          <target state="translated">实现应透明地处理传输协议的工件。例如,当使用T=0协议时,应按照ISO/IEC 7816-4的描述进行以下处理。</target>
        </trans-unit>
        <trans-unit id="9525ca7fbcb8134eb42edfabd5ffb3edf11a4d7c" translate="yes" xml:space="preserve">
          <source>Implementations supporting this attribute view may also support setting the initial ACL when creating a file or directory. The initial ACL may be provided to methods such as &lt;a href=&quot;../files#createFile(java.nio.file.Path,java.nio.file.attribute.FileAttribute...)&quot;&gt;&lt;code&gt;createFile&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../files#createDirectory(java.nio.file.Path,java.nio.file.attribute.FileAttribute...)&quot;&gt;&lt;code&gt;createDirectory&lt;/code&gt;&lt;/a&gt; as an &lt;a href=&quot;fileattribute&quot;&gt;&lt;code&gt;FileAttribute&lt;/code&gt;&lt;/a&gt; with &lt;a href=&quot;fileattribute#name()&quot;&gt;&lt;code&gt;name&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&quot;acl:acl&quot;&lt;/code&gt; and a &lt;a href=&quot;fileattribute#value()&quot;&gt;&lt;code&gt;value&lt;/code&gt;&lt;/a&gt; that is the list of &lt;code&gt;AclEntry&lt;/code&gt; objects.</source>
          <target state="translated">支持此属性视图的实现可能还支持在创建文件或目录时设置初始ACL。初始ACL可被提供给方法如&lt;a href=&quot;../files#createFile(java.nio.file.Path,java.nio.file.attribute.FileAttribute...)&quot;&gt; &lt;code&gt;createFile&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../files#createDirectory(java.nio.file.Path,java.nio.file.attribute.FileAttribute...)&quot;&gt; &lt;code&gt;createDirectory&lt;/code&gt; &lt;/a&gt;作为&lt;a href=&quot;fileattribute&quot;&gt; &lt;code&gt;FileAttribute&lt;/code&gt; &lt;/a&gt;与&lt;a href=&quot;fileattribute#name()&quot;&gt; &lt;code&gt;name&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&quot;acl:acl&quot;&lt;/code&gt; 和&lt;a href=&quot;fileattribute#value()&quot;&gt; &lt;code&gt;value&lt;/code&gt; &lt;/a&gt;是列表 &lt;code&gt;AclEntry&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="9265c990fd1a70dc9468d67065e182a75e5b85cc" translate="yes" xml:space="preserve">
          <source>Implementations supporting this attribute view may also support setting the initial ACL when creating a file or directory. The initial ACL may be provided to methods such as &lt;a href=&quot;../files#createFile-java.nio.file.Path-java.nio.file.attribute.FileAttribute...-&quot;&gt;&lt;code&gt;createFile&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../files#createDirectory-java.nio.file.Path-java.nio.file.attribute.FileAttribute...-&quot;&gt;&lt;code&gt;createDirectory&lt;/code&gt;&lt;/a&gt; as an &lt;a href=&quot;fileattribute&quot;&gt;&lt;code&gt;FileAttribute&lt;/code&gt;&lt;/a&gt; with &lt;a href=&quot;fileattribute#name--&quot;&gt;&lt;code&gt;name&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&quot;acl:acl&quot;&lt;/code&gt; and a &lt;a href=&quot;fileattribute#value--&quot;&gt;&lt;code&gt;value&lt;/code&gt;&lt;/a&gt; that is the list of &lt;code&gt;AclEntry&lt;/code&gt; objects.</source>
          <target state="translated">支持此属性视图的实现可能还支持在创建文件或目录时设置初始ACL。初始ACL可被提供给方法如&lt;a href=&quot;../files#createFile-java.nio.file.Path-java.nio.file.attribute.FileAttribute...-&quot;&gt; &lt;code&gt;createFile&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../files#createDirectory-java.nio.file.Path-java.nio.file.attribute.FileAttribute...-&quot;&gt; &lt;code&gt;createDirectory&lt;/code&gt; &lt;/a&gt;作为&lt;a href=&quot;fileattribute&quot;&gt; &lt;code&gt;FileAttribute&lt;/code&gt; &lt;/a&gt;与&lt;a href=&quot;fileattribute#name--&quot;&gt; &lt;code&gt;name&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&quot;acl:acl&quot;&lt;/code&gt; 和&lt;a href=&quot;fileattribute#value--&quot;&gt; &lt;code&gt;value&lt;/code&gt; &lt;/a&gt;是列表 &lt;code&gt;AclEntry&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="10dd796e1e9bf0840bd0fadcb7619888855b0e5e" translate="yes" xml:space="preserve">
          <source>Implementations supporting this attribute view may also support setting the initial permissions when creating a file or directory. The initial permissions are provided to the &lt;a href=&quot;../files#createFile(java.nio.file.Path,java.nio.file.attribute.FileAttribute...)&quot;&gt;&lt;code&gt;createFile&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../files#createDirectory(java.nio.file.Path,java.nio.file.attribute.FileAttribute...)&quot;&gt;&lt;code&gt;createDirectory&lt;/code&gt;&lt;/a&gt; methods as a &lt;a href=&quot;fileattribute&quot;&gt;&lt;code&gt;FileAttribute&lt;/code&gt;&lt;/a&gt; with &lt;a href=&quot;fileattribute#name()&quot;&gt;&lt;code&gt;name&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&quot;posix:permissions&quot;&lt;/code&gt; and a &lt;a href=&quot;fileattribute#value()&quot;&gt;&lt;code&gt;value&lt;/code&gt;&lt;/a&gt; that is the set of permissions. The following example uses the &lt;a href=&quot;posixfilepermissions#asFileAttribute(java.util.Set)&quot;&gt;&lt;code&gt;asFileAttribute&lt;/code&gt;&lt;/a&gt; method to construct a &lt;code&gt;FileAttribute&lt;/code&gt; when creating a file:</source>
          <target state="translated">支持此属性视图的实现可能还支持在创建文件或目录时设置初始权限。初始权限作为&lt;a href=&quot;fileattribute&quot;&gt; &lt;code&gt;FileAttribute&lt;/code&gt; &lt;/a&gt;提供给&lt;a href=&quot;../files#createFile(java.nio.file.Path,java.nio.file.attribute.FileAttribute...)&quot;&gt; &lt;code&gt;createFile&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../files#createDirectory(java.nio.file.Path,java.nio.file.attribute.FileAttribute...)&quot;&gt; &lt;code&gt;createDirectory&lt;/code&gt; &lt;/a&gt;方法，&lt;a href=&quot;fileattribute#name()&quot;&gt; &lt;code&gt;name&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&quot;posix:permissions&quot;&lt;/code&gt; ，&lt;a href=&quot;fileattribute#value()&quot;&gt; &lt;code&gt;value&lt;/code&gt; &lt;/a&gt;是权限集。以下示例在创建文件时使用&lt;a href=&quot;posixfilepermissions#asFileAttribute(java.util.Set)&quot;&gt; &lt;code&gt;asFileAttribute&lt;/code&gt; &lt;/a&gt;方法构造 &lt;code&gt;FileAttribute&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="c46af4741218e7b1b97c7da9603c5a880f593947" translate="yes" xml:space="preserve">
          <source>Implementations supporting this attribute view may also support setting the initial permissions when creating a file or directory. The initial permissions are provided to the &lt;a href=&quot;../files#createFile-java.nio.file.Path-java.nio.file.attribute.FileAttribute...-&quot;&gt;&lt;code&gt;createFile&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../files#createDirectory-java.nio.file.Path-java.nio.file.attribute.FileAttribute...-&quot;&gt;&lt;code&gt;createDirectory&lt;/code&gt;&lt;/a&gt; methods as a &lt;a href=&quot;fileattribute&quot;&gt;&lt;code&gt;FileAttribute&lt;/code&gt;&lt;/a&gt; with &lt;a href=&quot;fileattribute#name--&quot;&gt;&lt;code&gt;name&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&quot;posix:permissions&quot;&lt;/code&gt; and a &lt;a href=&quot;fileattribute#value--&quot;&gt;&lt;code&gt;value&lt;/code&gt;&lt;/a&gt; that is the set of permissions. The following example uses the &lt;a href=&quot;posixfilepermissions#asFileAttribute-java.util.Set-&quot;&gt;&lt;code&gt;asFileAttribute&lt;/code&gt;&lt;/a&gt; method to construct a &lt;code&gt;FileAttribute&lt;/code&gt; when creating a file:</source>
          <target state="translated">支持此属性视图的实现可能还支持在创建文件或目录时设置初始权限。初始权限被提供给&lt;a href=&quot;../files#createFile-java.nio.file.Path-java.nio.file.attribute.FileAttribute...-&quot;&gt; &lt;code&gt;createFile&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../files#createDirectory-java.nio.file.Path-java.nio.file.attribute.FileAttribute...-&quot;&gt; &lt;code&gt;createDirectory&lt;/code&gt; &lt;/a&gt;方法作为&lt;a href=&quot;fileattribute&quot;&gt; &lt;code&gt;FileAttribute&lt;/code&gt; &lt;/a&gt;与&lt;a href=&quot;fileattribute#name--&quot;&gt; &lt;code&gt;name&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&quot;posix:permissions&quot;&lt;/code&gt; 和一个&lt;a href=&quot;fileattribute#value--&quot;&gt; &lt;code&gt;value&lt;/code&gt; &lt;/a&gt;是一组权限。下面的示例在创建文件时使用&lt;a href=&quot;posixfilepermissions#asFileAttribute-java.util.Set-&quot;&gt; &lt;code&gt;asFileAttribute&lt;/code&gt; &lt;/a&gt;方法构造 &lt;code&gt;FileAttribute&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="e4f7352bd5189bae4e86402d1ca84f5a70c34ad4" translate="yes" xml:space="preserve">
          <source>Implemented by a service provider, used by the static methods of this class.</source>
          <target state="translated">由服务提供者实现,由该类的静态方法使用。</target>
        </trans-unit>
        <trans-unit id="5d27247adfc98a632446be7b025feb0b66fde48b" translate="yes" xml:space="preserve">
          <source>Implemented by objects that can have a &lt;code&gt;JMXServiceURL&lt;/code&gt; address.</source>
          <target state="translated">由可以具有 &lt;code&gt;JMXServiceURL&lt;/code&gt; 地址的对象实现。</target>
        </trans-unit>
        <trans-unit id="e18ec9389651cc68787839f4398e87d90fd1fb0e" translate="yes" xml:space="preserve">
          <source>Implemented by objects that can have a &lt;code&gt;JMXServiceURL&lt;/code&gt; address. All &lt;a href=&quot;jmxconnectorserver&quot;&gt;&lt;code&gt;JMXConnectorServer&lt;/code&gt;&lt;/a&gt; objects implement this interface. Depending on the connector implementation, a &lt;a href=&quot;jmxconnector&quot;&gt;&lt;code&gt;JMXConnector&lt;/code&gt;&lt;/a&gt; object may implement this interface too. &lt;code&gt;JMXConnector&lt;/code&gt; objects for the RMI Connector are instances of &lt;a href=&quot;../../../../java.management.rmi/javax/management/remote/rmi/rmiconnector&quot;&gt;&lt;code&gt;RMIConnector&lt;/code&gt;&lt;/a&gt; which implements this interface.</source>
          <target state="translated">由可以具有 &lt;code&gt;JMXServiceURL&lt;/code&gt; 地址的对象实现。所有&lt;a href=&quot;jmxconnectorserver&quot;&gt; &lt;code&gt;JMXConnectorServer&lt;/code&gt; &lt;/a&gt;对象都实现此接口。根据连接器的实现，&lt;a href=&quot;jmxconnector&quot;&gt; &lt;code&gt;JMXConnector&lt;/code&gt; &lt;/a&gt;对象也可以实现此接口。RMI连接器的 &lt;code&gt;JMXConnector&lt;/code&gt; 对象是实现此接口的&lt;a href=&quot;../../../../java.management.rmi/javax/management/remote/rmi/rmiconnector&quot;&gt; &lt;code&gt;RMIConnector&lt;/code&gt; 的&lt;/a&gt;实例。</target>
        </trans-unit>
        <trans-unit id="61cd05b213ed2ee1d81c4aee8d8fd0536738b4af" translate="yes" xml:space="preserve">
          <source>Implemented by objects that can have a &lt;code&gt;JMXServiceURL&lt;/code&gt; address. All &lt;a href=&quot;jmxconnectorserver&quot;&gt;&lt;code&gt;JMXConnectorServer&lt;/code&gt;&lt;/a&gt; objects implement this interface. Depending on the connector implementation, a &lt;a href=&quot;jmxconnector&quot;&gt;&lt;code&gt;JMXConnector&lt;/code&gt;&lt;/a&gt; object may implement this interface too. &lt;code&gt;JMXConnector&lt;/code&gt; objects for the RMI Connector are instances of &lt;a href=&quot;rmi/rmiconnector&quot;&gt;&lt;code&gt;RMIConnector&lt;/code&gt;&lt;/a&gt; which implements this interface.</source>
          <target state="translated">由可以具有 &lt;code&gt;JMXServiceURL&lt;/code&gt; 地址的对象实现。所有&lt;a href=&quot;jmxconnectorserver&quot;&gt; &lt;code&gt;JMXConnectorServer&lt;/code&gt; &lt;/a&gt;对象都实现此接口。根据连接器的实现，&lt;a href=&quot;jmxconnector&quot;&gt; &lt;code&gt;JMXConnector&lt;/code&gt; &lt;/a&gt;对象也可以实现此接口。RMI连接器的 &lt;code&gt;JMXConnector&lt;/code&gt; 对象是实现此接口的&lt;a href=&quot;rmi/rmiconnector&quot;&gt; &lt;code&gt;RMIConnector&lt;/code&gt; &lt;/a&gt;实例。</target>
        </trans-unit>
        <trans-unit id="e3d61810bc73f33e4e00486624813fd3c76d0745" translate="yes" xml:space="preserve">
          <source>Implemented to be a &lt;code&gt;MenuElement&lt;/code&gt; -- does nothing.</source>
          <target state="translated">实现为 &lt;code&gt;MenuElement&lt;/code&gt; －不执行任何操作。</target>
        </trans-unit>
        <trans-unit id="cbf96cb764bf289e584a3256d8b7340a013852d9" translate="yes" xml:space="preserve">
          <source>Implemented to be a &lt;code&gt;MenuElement&lt;/code&gt; -- returns the menus in this menu bar.</source>
          <target state="translated">实现为 &lt;code&gt;MenuElement&lt;/code&gt; －返回此菜单栏中的菜单。</target>
        </trans-unit>
        <trans-unit id="49ed97f064afc431455d8a8d0c9ee34d43d19b3b" translate="yes" xml:space="preserve">
          <source>Implemented to be a &lt;code&gt;MenuElement&lt;/code&gt; -- returns the menus in this menu bar. This is the reason for implementing the &lt;code&gt;MenuElement&lt;/code&gt; interface -- so that the menu bar can be treated the same as other menu elements.</source>
          <target state="translated">实现为 &lt;code&gt;MenuElement&lt;/code&gt; －返回此菜单栏中的菜单。这就是实现 &lt;code&gt;MenuElement&lt;/code&gt; 接口的原因-以便可以将菜单栏与其他菜单元素一样对待。</target>
        </trans-unit>
        <trans-unit id="af39823a4addc01a879447b01511360237f5e522" translate="yes" xml:space="preserve">
          <source>Implemented to be a &lt;code&gt;MenuElement&lt;/code&gt;.</source>
          <target state="translated">实现为 &lt;code&gt;MenuElement&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e7203d79e1e510762b33e93ba6a7d51389952311" translate="yes" xml:space="preserve">
          <source>Implemented to be a &lt;code&gt;MenuElement&lt;/code&gt;. Returns this object.</source>
          <target state="translated">实现为 &lt;code&gt;MenuElement&lt;/code&gt; 。返回此对象。</target>
        </trans-unit>
        <trans-unit id="6106e4896a692c93ab85fcb3e444b73ba8fbeee9" translate="yes" xml:space="preserve">
          <source>Implementer's Guide</source>
          <target state="translated">实施者指南</target>
        </trans-unit>
        <trans-unit id="492fa413aa34c053a664565f4e23bc9d32ccaa54" translate="yes" xml:space="preserve">
          <source>Implementers should specify the name of an appropriate class to be instantiated if no other implementation resolution mechanism succeeds.</source>
          <target state="translated">如果没有其他实现解决机制成功,实现者应该指定一个合适的类的名称来实例化。</target>
        </trans-unit>
        <trans-unit id="1a10d60e6dba62c913d7dd56fce36c003939f7df" translate="yes" xml:space="preserve">
          <source>Implementing exception-throwing behavior</source>
          <target state="translated">实现异常抛出行为</target>
        </trans-unit>
        <trans-unit id="6316c998aaf80f52e21906c45a08ecf6dd94f2cb" translate="yes" xml:space="preserve">
          <source>Implementing the Externalizable interface allows the object to assume complete control over the contents and format of the object's serialized form. The methods of the Externalizable interface, writeExternal and readExternal, are called to save and restore the objects state. When implemented by a class they can write and read their own state using all of the methods of ObjectOutput and ObjectInput. It is the responsibility of the objects to handle any versioning that occurs.</source>
          <target state="translated">实现Externalizable接口可以让对象完全控制对象序列化形式的内容和格式。Externalizable接口的方法writeExternal和readExternal被调用来保存和恢复对象的状态。当由一个类实现时,它们可以使用ObjectOutput和ObjectInput的所有方法来写入和读取自己的状态。处理任何发生的版本化是对象的责任。</target>
        </trans-unit>
        <trans-unit id="85a1b32441e6f8998efff0a593cf96d0554294af" translate="yes" xml:space="preserve">
          <source>Implementing the MemoryPool object works similarly for both Standard MBeans and MXBeans.</source>
          <target state="translated">实现MemoryPool对象的工作原理类似于标准MBeans和MXBeans。</target>
        </trans-unit>
        <trans-unit id="b27273a4fe2fe56656ab15058c038de342b8f1ba" translate="yes" xml:space="preserve">
          <source>Implementing the Serializable interface allows object serialization to save and restore the entire state of the object and it allows classes to evolve between the time the stream is written and the time it is read. It automatically traverses references between objects, saving and restoring entire graphs.</source>
          <target state="translated">实现Serializable接口可以让对象序列化保存和恢复对象的整个状态,它允许类在写流和读流之间进化。它可以自动遍历对象之间的引用,保存和恢复整个图形。</target>
        </trans-unit>
        <trans-unit id="c4eba021a9e9d2a95adfd121f50523d25266d18b" translate="yes" xml:space="preserve">
          <source>Implementing this interface allows an object to be the target of the &quot;for-each loop&quot; statement.</source>
          <target state="translated">实现这个接口可以让一个对象成为 &quot;for-each循环 &quot;语句的目标。</target>
        </trans-unit>
        <trans-unit id="b2c3a655b63b5ea1f21619a61f5d5ab25bccd7b1" translate="yes" xml:space="preserve">
          <source>Implementing this interface allows an object to be the target of the &quot;for-each loop&quot; statement. See &lt;strong&gt; &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/language/foreach.html&quot;&gt;For-each Loop&lt;/a&gt; &lt;/strong&gt;</source>
          <target state="translated">实现此接口使对象成为&amp;ldquo; for-each循环&amp;rdquo;语句的目标。请参阅&lt;strong&gt;&lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/language/foreach.html&quot;&gt;每个循环&lt;/a&gt;&lt;/strong&gt;&lt;strong&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="677667db2207746335237bb2c25d22bd60cea248" translate="yes" xml:space="preserve">
          <source>Implementing this interface allows an object to be the target of the enhanced &lt;code&gt;for&lt;/code&gt; statement (sometimes called the &quot;for-each loop&quot; statement).</source>
          <target state="translated">实现此接口可使对象成为增强的 &lt;code&gt;for&lt;/code&gt; 语句（有时称为&amp;ldquo; for-each循环&amp;rdquo;语句）的目标。</target>
        </trans-unit>
        <trans-unit id="16b8440feaff663be30e5ff98a6229d156358ad9" translate="yes" xml:space="preserve">
          <source>Implementors and developers should pay particular attention to how the features set on this &lt;a href=&quot;schemafactory&quot;&gt;&lt;code&gt;SchemaFactory&lt;/code&gt;&lt;/a&gt; are processed by this special &lt;a href=&quot;schema&quot;&gt;&lt;code&gt;Schema&lt;/code&gt;&lt;/a&gt;. In some cases, for example, when the &lt;a href=&quot;schemafactory&quot;&gt;&lt;code&gt;SchemaFactory&lt;/code&gt;&lt;/a&gt; and the class actually loading the schema come from different implementations, it may not be possible for &lt;a href=&quot;schemafactory&quot;&gt;&lt;code&gt;SchemaFactory&lt;/code&gt;&lt;/a&gt; features to be inherited automatically. Developers should make sure that features, such as secure processing, are explicitly set in both places.</source>
          <target state="translated">实现者和开发者应特别注意此特殊&lt;a href=&quot;schema&quot;&gt; &lt;code&gt;Schema&lt;/code&gt; &lt;/a&gt;如何处理在&lt;a href=&quot;schemafactory&quot;&gt; &lt;code&gt;SchemaFactory&lt;/code&gt; &lt;/a&gt;上设置的功能。例如，在某些情况下，当&lt;a href=&quot;schemafactory&quot;&gt; &lt;code&gt;SchemaFactory&lt;/code&gt; &lt;/a&gt;和实际加载架构的类来自不同的实现时，可能无法自动继承&lt;a href=&quot;schemafactory&quot;&gt; &lt;code&gt;SchemaFactory&lt;/code&gt; &lt;/a&gt;功能。开发人员应确保在两个地方都明确设置了诸如安全处理之类的功能。</target>
        </trans-unit>
        <trans-unit id="99951e523cfc57b1343f700e7220490f37aa210c" translate="yes" xml:space="preserve">
          <source>Implementors and developers should pay particular attention to how the special &lt;a href=&quot;schema&quot;&gt;&lt;code&gt;Schema&lt;/code&gt;&lt;/a&gt; object returned by &lt;a href=&quot;#newSchema()&quot;&gt;&lt;code&gt;newSchema()&lt;/code&gt;&lt;/a&gt; is processed. In some cases, for example, when the &lt;code&gt;SchemaFactory&lt;/code&gt; and the class actually loading the schema come from different implementations, it may not be possible for &lt;code&gt;SchemaFactory&lt;/code&gt; features to be inherited automatically. Developers should make sure that features, such as secure processing, are explicitly set in both places.</source>
          <target state="translated">实现者和开发人员应特别注意如何处理&lt;a href=&quot;#newSchema()&quot;&gt; &lt;code&gt;newSchema()&lt;/code&gt; &lt;/a&gt;返回的特殊&lt;a href=&quot;schema&quot;&gt; &lt;code&gt;Schema&lt;/code&gt; &lt;/a&gt;对象。例如，在某些情况下，当 &lt;code&gt;SchemaFactory&lt;/code&gt; 和实际加载架构的类来自不同的实现时，可能无法自动继承 &lt;code&gt;SchemaFactory&lt;/code&gt; 功能。开发人员应确保在两个地方都明确设置了诸如安全处理之类的功能。</target>
        </trans-unit>
        <trans-unit id="8577e7b0e57464789c03fce26dcd7c74511a3795" translate="yes" xml:space="preserve">
          <source>Implementors are free (and encouraged) to invent their own features, using names built on their own URIs.</source>
          <target state="translated">实施者可以自由(并鼓励)使用建立在自己URI上的名称来发明自己的功能。</target>
        </trans-unit>
        <trans-unit id="dc3a77180c30a4d8539025481958848c09be493e" translate="yes" xml:space="preserve">
          <source>Implementors are free (and encouraged) to invent their own properties, using names built on their own URIs.</source>
          <target state="translated">实现者可以自由(并鼓励)使用建立在自己URI上的名称来发明自己的属性。</target>
        </trans-unit>
        <trans-unit id="ee508ec5b0694cae10b7518c95bffc14abcc25ed" translate="yes" xml:space="preserve">
          <source>Implementors are notified when the app becomes the foreground app and when it is no longer the foreground app.</source>
          <target state="translated">当应用成为前台应用和不再是前台应用时,会通知实施者。</target>
        </trans-unit>
        <trans-unit id="ba3e9207c3154f7847ddc0b6161132c852925581" translate="yes" xml:space="preserve">
          <source>Implementors are notified when the app becomes the foreground app and when it is no longer the foreground app. This notification is useful for hiding and showing transient UI like palette windows which should be hidden when the app is in the background.</source>
          <target state="translated">当应用成为前景应用和不再是前景应用时,会通知实现者。这个通知对于隐藏和显示像调色板窗口这样的瞬时UI很有用,当应用处于后台时,这些UI应该被隐藏。</target>
        </trans-unit>
        <trans-unit id="9d37a186316d3ce73428e4b8ed79605fa6ada0ad" translate="yes" xml:space="preserve">
          <source>Implementors are notified when the app is hidden or shown by the user.</source>
          <target state="translated">当应用被用户隐藏或显示时,会通知实施者。</target>
        </trans-unit>
        <trans-unit id="275d1a155c071e2398e4415f5c0fade0a1bc4c93" translate="yes" xml:space="preserve">
          <source>Implementors are notified when the app is hidden or shown by the user. This notification is helpful for discontinuing a costly animation if it's not visible to the user.</source>
          <target state="translated">当应用被用户隐藏或显示时,实施者会得到通知。如果用户不可见,这个通知对中止一个昂贵的动画很有帮助。</target>
        </trans-unit>
        <trans-unit id="1817a58b9d07fbaa655fd6f4ebbd89e569525612" translate="yes" xml:space="preserve">
          <source>Implementors must call either &lt;a href=&quot;quitresponse#cancelQuit()&quot;&gt;&lt;code&gt;QuitResponse.cancelQuit()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;quitresponse#performQuit()&quot;&gt;&lt;code&gt;QuitResponse.performQuit()&lt;/code&gt;&lt;/a&gt;, or ensure the application terminates. The process (or log-out) requesting this app to quit will be blocked until the &lt;a href=&quot;quitresponse&quot;&gt;&lt;code&gt;QuitResponse&lt;/code&gt;&lt;/a&gt; is handled. Apps that require complex UI to shutdown may call the &lt;a href=&quot;quitresponse&quot;&gt;&lt;code&gt;QuitResponse&lt;/code&gt;&lt;/a&gt; from any thread. Your app may be asked to quit multiple times before you have responded to the initial request. This handler is called each time a quit is requested, and the same &lt;a href=&quot;quitresponse&quot;&gt;&lt;code&gt;QuitResponse&lt;/code&gt;&lt;/a&gt; object is passed until it is handled. Once used, the &lt;a href=&quot;quitresponse&quot;&gt;&lt;code&gt;QuitResponse&lt;/code&gt;&lt;/a&gt; cannot be used again to change the decision.</source>
          <target state="translated">实现者必须调用&lt;a href=&quot;quitresponse#cancelQuit()&quot;&gt; &lt;code&gt;QuitResponse.cancelQuit()&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;quitresponse#performQuit()&quot;&gt; &lt;code&gt;QuitResponse.performQuit()&lt;/code&gt; &lt;/a&gt;或确保应用程序终止。请求退出该应用的过程（或注销）将被阻止，直到处理&lt;a href=&quot;quitresponse&quot;&gt; &lt;code&gt;QuitResponse&lt;/code&gt; &lt;/a&gt;为止。需要关闭复杂UI的应用程序可以从任何线程调用&lt;a href=&quot;quitresponse&quot;&gt; &lt;code&gt;QuitResponse&lt;/code&gt; &lt;/a&gt;。您可能会要求您的应用程序多次退出，然后才能响应初始请求。每次请求退出时都会调用此处理程序，并且传递相同的&lt;a href=&quot;quitresponse&quot;&gt; &lt;code&gt;QuitResponse&lt;/code&gt; &lt;/a&gt;对象直到对其进行处理。一旦使用了&lt;a href=&quot;quitresponse&quot;&gt; &lt;code&gt;QuitResponse&lt;/code&gt; ,&lt;/a&gt;就不能再次使用它来更改决策。</target>
        </trans-unit>
        <trans-unit id="138204779c48d5972dd906bafe8996d60eaece4f" translate="yes" xml:space="preserve">
          <source>Implementors must override the nine abstract service-provider interface (SPI) methods: &lt;a href=&quot;#getSpi(java.lang.String)&quot;&gt;&lt;code&gt;getSpi(String)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#putSpi(java.lang.String,java.lang.String)&quot;&gt;&lt;code&gt;putSpi(String,String)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#removeSpi(java.lang.String)&quot;&gt;&lt;code&gt;removeSpi(String)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#childSpi(java.lang.String)&quot;&gt;&lt;code&gt;childSpi(String)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#removeNodeSpi()&quot;&gt;&lt;code&gt;removeNodeSpi()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#keysSpi()&quot;&gt;&lt;code&gt;keysSpi()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#childrenNamesSpi()&quot;&gt;&lt;code&gt;childrenNamesSpi()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#syncSpi()&quot;&gt;&lt;code&gt;syncSpi()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#flushSpi()&quot;&gt;&lt;code&gt;flushSpi()&lt;/code&gt;&lt;/a&gt;. All of the concrete methods specify precisely how they are implemented atop these SPI methods. The implementor may, at his discretion, override one or more of the concrete methods if the default implementation is unsatisfactory for any reason, such as performance.</source>
          <target state="translated">实现者必须重写九种抽象服务提供者接口（SPI）方法：&lt;a href=&quot;#getSpi(java.lang.String)&quot;&gt; &lt;code&gt;getSpi(String)&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#putSpi(java.lang.String,java.lang.String)&quot;&gt; &lt;code&gt;putSpi(String,String)&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#removeSpi(java.lang.String)&quot;&gt; &lt;code&gt;removeSpi(String)&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#childSpi(java.lang.String)&quot;&gt; &lt;code&gt;childSpi(String)&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#removeNodeSpi()&quot;&gt; &lt;code&gt;removeNodeSpi()&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#keysSpi()&quot;&gt; &lt;code&gt;keysSpi()&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#childrenNamesSpi()&quot;&gt; &lt;code&gt;childrenNamesSpi()&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#syncSpi()&quot;&gt; &lt;code&gt;syncSpi()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#flushSpi()&quot;&gt; &lt;code&gt;flushSpi()&lt;/code&gt; &lt;/a&gt;。所有具体方法都精确地指定了如何在这些SPI方法之上实现它们。如果默认实现由于某种原因（例如性能）不理想，则实现者可以自行决定覆盖一种或多种具体方法。</target>
        </trans-unit>
        <trans-unit id="cfc9c018f8a42ee85a1ab091653d70a1654d6247" translate="yes" xml:space="preserve">
          <source>Implementors must override the nine abstract service-provider interface (SPI) methods: &lt;a href=&quot;abstractpreferences#getSpi-java.lang.String-&quot;&gt;&lt;code&gt;getSpi(String)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;abstractpreferences#putSpi-java.lang.String-java.lang.String-&quot;&gt;&lt;code&gt;putSpi(String,String)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;abstractpreferences#removeSpi-java.lang.String-&quot;&gt;&lt;code&gt;removeSpi(String)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;abstractpreferences#childSpi-java.lang.String-&quot;&gt;&lt;code&gt;childSpi(String)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;abstractpreferences#removeNodeSpi--&quot;&gt;&lt;code&gt;removeNodeSpi()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;abstractpreferences#keysSpi--&quot;&gt;&lt;code&gt;keysSpi()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;abstractpreferences#childrenNamesSpi--&quot;&gt;&lt;code&gt;childrenNamesSpi()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;abstractpreferences#syncSpi--&quot;&gt;&lt;code&gt;syncSpi()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;abstractpreferences#flushSpi--&quot;&gt;&lt;code&gt;flushSpi()&lt;/code&gt;&lt;/a&gt;. All of the concrete methods specify precisely how they are implemented atop these SPI methods. The implementor may, at his discretion, override one or more of the concrete methods if the default implementation is unsatisfactory for any reason, such as performance.</source>
          <target state="translated">实现者必须重写九种抽象服务提供者接口（SPI）方法：&lt;a href=&quot;abstractpreferences#getSpi-java.lang.String-&quot;&gt; &lt;code&gt;getSpi(String)&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;abstractpreferences#putSpi-java.lang.String-java.lang.String-&quot;&gt; &lt;code&gt;putSpi(String,String)&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;abstractpreferences#removeSpi-java.lang.String-&quot;&gt; &lt;code&gt;removeSpi(String)&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;abstractpreferences#childSpi-java.lang.String-&quot;&gt; &lt;code&gt;childSpi(String)&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;abstractpreferences#removeNodeSpi--&quot;&gt; &lt;code&gt;removeNodeSpi()&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;abstractpreferences#keysSpi--&quot;&gt; &lt;code&gt;keysSpi()&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;abstractpreferences#childrenNamesSpi--&quot;&gt; &lt;code&gt;childrenNamesSpi()&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;abstractpreferences#syncSpi--&quot;&gt; &lt;code&gt;syncSpi()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;abstractpreferences#flushSpi--&quot;&gt; &lt;code&gt;flushSpi()&lt;/code&gt; &lt;/a&gt;。所有具体方法都精确地指定了如何在这些SPI方法之上实现它们。如果默认实现由于某种原因（例如性能）不理想，则实现者可以自行决定覆盖一种或多种具体方法。</target>
        </trans-unit>
        <trans-unit id="aead7400492ac0da3dcc2b29c778531e2a05071f" translate="yes" xml:space="preserve">
          <source>Implementors of serializable lambdas, such as compilers or language runtime libraries, are expected to ensure that instances deserialize properly. One means to do so is to ensure that the &lt;code&gt;writeReplace&lt;/code&gt; method returns an instance of &lt;code&gt;SerializedLambda&lt;/code&gt;, rather than allowing default serialization to proceed.</source>
          <target state="translated">可序列化lambda的实现者（例如编译器或语言运行时库）应确保实例正确反序列化。这样做的一种方法是确保 &lt;code&gt;writeReplace&lt;/code&gt; 方法返回 &lt;code&gt;SerializedLambda&lt;/code&gt; 的实例，而不是允许进行默认序列化。</target>
        </trans-unit>
        <trans-unit id="44c88085cccf2d65812bb1fc7a1aca637317273a" translate="yes" xml:space="preserve">
          <source>Implementors of this class which wrap an underlying implementation can consider using the &lt;a href=&quot;../../../org/xml/sax/helpers/parseradapter&quot;&gt;&lt;code&gt;ParserAdapter&lt;/code&gt;&lt;/a&gt; class to initially adapt their SAX1 implementation to work under this revised class.</source>
          <target state="translated">此类包装了基础实现的实现者可以考虑使用&lt;a href=&quot;../../../org/xml/sax/helpers/parseradapter&quot;&gt; &lt;code&gt;ParserAdapter&lt;/code&gt; &lt;/a&gt;类来使他们的SAX1实现最初适应于该修订后的类。</target>
        </trans-unit>
        <trans-unit id="659cd7b74c1d7802de5869ebeaf003d5a53e8f3a" translate="yes" xml:space="preserve">
          <source>Implementors of this interface may find it convenient to extend &lt;a href=&quot;abstractprocessor&quot;&gt;&lt;code&gt;AbstractProcessor&lt;/code&gt;&lt;/a&gt; rather than implementing this interface directly.</source>
          <target state="translated">此接口的实现者可能会发现，扩展&lt;a href=&quot;abstractprocessor&quot;&gt; &lt;code&gt;AbstractProcessor&lt;/code&gt; &lt;/a&gt;而不是直接实现此接口很方便。</target>
        </trans-unit>
        <trans-unit id="d68709ed0031e9d20d4e17ec993bab81dd93a700" translate="yes" xml:space="preserve">
          <source>Implementors receive notification as the system is entering sleep, and after the system wakes.</source>
          <target state="translated">在系统进入睡眠状态时,以及系统唤醒后,实施者会收到通知。</target>
        </trans-unit>
        <trans-unit id="7798e91330173822181e6655dadd7e58496cc350" translate="yes" xml:space="preserve">
          <source>Implementors receive notification as the system is entering sleep, and after the system wakes. This notification is useful for disconnecting from network services prior to sleep, or re-establishing a connection if the network configuration has changed during sleep.</source>
          <target state="translated">实施者在系统进入睡眠时和系统唤醒后会收到通知。这种通知对于在睡眠前断开网络服务,或者在睡眠期间网络配置发生变化时重新建立连接非常有用。</target>
        </trans-unit>
        <trans-unit id="447da6c7b13c5c1f40bebb620e8d04cab91b424d" translate="yes" xml:space="preserve">
          <source>Implementors receive notification when the app has been asked to open again.</source>
          <target state="translated">当应用程序被要求再次打开时,实施者会收到通知。</target>
        </trans-unit>
        <trans-unit id="8d4c4b3d7fe642c2f0cbd29a70ec392e711ab9d9" translate="yes" xml:space="preserve">
          <source>Implementors receive notification when the app has been asked to open again. This notification is useful for showing a new document when your app has no open windows.</source>
          <target state="translated">当应用程序被要求再次打开时,实施者会收到通知。当你的应用程序没有打开的窗口时,这个通知对于显示新的文档很有用。</target>
        </trans-unit>
        <trans-unit id="aa5fd4cfebec19ecb97f8db63b20c59efe6a87de" translate="yes" xml:space="preserve">
          <source>Implementors receive notification when the displays attached to the system have entered power save sleep.</source>
          <target state="translated">当连接到系统的显示器进入省电睡眠状态时,实施者会收到通知。</target>
        </trans-unit>
        <trans-unit id="f3ac142b1424fd9c9ed9c1112ef26559d15b4ba3" translate="yes" xml:space="preserve">
          <source>Implementors receive notification when the displays attached to the system have entered power save sleep. This notification is useful for discontinuing a costly animation, or indicating that the user is no longer present on a network service.</source>
          <target state="translated">当连接到系统的显示器进入省电睡眠状态时,实施者会收到通知。这种通知对于中止昂贵的动画,或表明用户不再出现在网络服务上很有用。</target>
        </trans-unit>
        <trans-unit id="a8b4aaea29398e416216bb5778297092d40e3545" translate="yes" xml:space="preserve">
          <source>Implementors receive notification when the user session changes.</source>
          <target state="translated">当用户会话发生变化时,实施者会收到通知。</target>
        </trans-unit>
        <trans-unit id="4e1a43914199e6b094a085a07ae83622bf99a286" translate="yes" xml:space="preserve">
          <source>Implementors receive notification when the user session changes. This notification is useful for discontinuing a costly animation, or indicating that the user is no longer present on a network service. Some systems may provide a reason of the user session change.</source>
          <target state="translated">当用户会话发生变化时,实施者会收到通知。这种通知对于中止一个昂贵的动画,或者表明用户不再出现在网络服务上是有用的。有些系统可以提供用户会话变化的原因。</target>
        </trans-unit>
        <trans-unit id="aa19933155a45f4e0ac8040534fd17524cd4459a" translate="yes" xml:space="preserve">
          <source>Implementors should assure that the properties set on the &lt;a href=&quot;schemafactory&quot;&gt;&lt;code&gt;SchemaFactory&lt;/code&gt;&lt;/a&gt; that created this &lt;a href=&quot;schema&quot;&gt;&lt;code&gt;Schema&lt;/code&gt;&lt;/a&gt; are also set on the &lt;a href=&quot;validator&quot;&gt;&lt;code&gt;Validator&lt;/code&gt;&lt;/a&gt; constructed.</source>
          <target state="translated">实现者应确保在创建此&lt;a href=&quot;schema&quot;&gt; &lt;code&gt;Schema&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;schemafactory&quot;&gt; &lt;code&gt;SchemaFactory&lt;/code&gt; &lt;/a&gt;上设置的属性也应在构造的&lt;a href=&quot;validator&quot;&gt; &lt;code&gt;Validator&lt;/code&gt; &lt;/a&gt;上进行设置。</target>
        </trans-unit>
        <trans-unit id="c34a71d5c363e25ed5c27a45f3f354fa775afff6" translate="yes" xml:space="preserve">
          <source>Implementors should assure that the properties set on the &lt;a href=&quot;schemafactory&quot;&gt;&lt;code&gt;SchemaFactory&lt;/code&gt;&lt;/a&gt; that created this &lt;a href=&quot;schema&quot;&gt;&lt;code&gt;Schema&lt;/code&gt;&lt;/a&gt; are also set on the &lt;a href=&quot;validatorhandler&quot;&gt;&lt;code&gt;ValidatorHandler&lt;/code&gt;&lt;/a&gt; constructed.</source>
          <target state="translated">实现者应确保在创建此&lt;a href=&quot;schema&quot;&gt; &lt;code&gt;Schema&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;schemafactory&quot;&gt; &lt;code&gt;SchemaFactory&lt;/code&gt; &lt;/a&gt;上设置的属性也应在构造的&lt;a href=&quot;validatorhandler&quot;&gt; &lt;code&gt;ValidatorHandler&lt;/code&gt; &lt;/a&gt;上设置。</target>
        </trans-unit>
        <trans-unit id="a6eff8d7cc5d25aa20d533294644c7c1a063c35c" translate="yes" xml:space="preserve">
          <source>Implementors should note that there is also a &lt;code&gt;ContentHandler&lt;/code&gt; class in the &lt;code&gt;java.net&lt;/code&gt; package; that means that it's probably a bad idea to do</source>
          <target state="translated">实现者应注意， &lt;code&gt;java.net&lt;/code&gt; 包中还有一个 &lt;code&gt;ContentHandler&lt;/code&gt; 类。这意味着这样做可能不是一个好主意</target>
        </trans-unit>
        <trans-unit id="59e497ae7e63a78a2d82a59d17c0703a451bb786" translate="yes" xml:space="preserve">
          <source>Implements &lt;a href=&quot;../../../org/w3c/dom/ls/lsresourceresolver&quot;&gt;&lt;code&gt;LSResourceResolver&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">实现&lt;a href=&quot;../../../org/w3c/dom/ls/lsresourceresolver&quot;&gt; &lt;code&gt;LSResourceResolver&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a83a690b5e99d54d516b6b75e55e496defe55a9b" translate="yes" xml:space="preserve">
          <source>Implements &lt;a href=&quot;../../../org/w3c/dom/ls/lsresourceresolver&quot;&gt;&lt;code&gt;LSResourceResolver&lt;/code&gt;&lt;/a&gt;. For the purpose of resolving &lt;code&gt;publicId&lt;/code&gt; and &lt;code&gt;systemId&lt;/code&gt;, this method is equivalent to &lt;a href=&quot;#resolveEntity(java.lang.String,java.lang.String)&quot;&gt;&lt;code&gt;resolveEntity(java.lang.String, java.lang.String)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">实现&lt;a href=&quot;../../../org/w3c/dom/ls/lsresourceresolver&quot;&gt; &lt;code&gt;LSResourceResolver&lt;/code&gt; &lt;/a&gt;。为了解决 &lt;code&gt;publicId&lt;/code&gt; 和 &lt;code&gt;systemId&lt;/code&gt; 的目的，此方法等效于&lt;a href=&quot;#resolveEntity(java.lang.String,java.lang.String)&quot;&gt; &lt;code&gt;resolveEntity(java.lang.String, java.lang.String)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="62ff680457fbba2bd8145e76bbc89b6262c6dacf" translate="yes" xml:space="preserve">
          <source>Implements &lt;a href=&quot;../../../org/xml/sax/entityresolver&quot;&gt;&lt;code&gt;EntityResolver&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">实现&lt;a href=&quot;../../../org/xml/sax/entityresolver&quot;&gt; &lt;code&gt;EntityResolver&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="483362f4faeee60c16638b977df7afab8a6d2ef0" translate="yes" xml:space="preserve">
          <source>Implements &lt;a href=&quot;../../../org/xml/sax/entityresolver&quot;&gt;&lt;code&gt;EntityResolver&lt;/code&gt;&lt;/a&gt;. The method searches through the catalog entries in the main and alternative catalogs to attempt to find a match with the specified &lt;code&gt;publicId&lt;/code&gt; or systemId.</source>
          <target state="translated">实现&lt;a href=&quot;../../../org/xml/sax/entityresolver&quot;&gt; &lt;code&gt;EntityResolver&lt;/code&gt; &lt;/a&gt;。该方法搜索主目录和备用目录中的目录条目，以尝试查找与指定的 &lt;code&gt;publicId&lt;/code&gt; 或systemId匹配的项。</target>
        </trans-unit>
        <trans-unit id="f1d270d856595d65238b888f07006bd1a30a5f8c" translate="yes" xml:space="preserve">
          <source>Implements &lt;a href=&quot;../stream/xmlresolver&quot;&gt;&lt;code&gt;XMLResolver&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">实现&lt;a href=&quot;../stream/xmlresolver&quot;&gt; &lt;code&gt;XMLResolver&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ddbd6ccd580e849d089ad33405309e2013332735" translate="yes" xml:space="preserve">
          <source>Implements &lt;a href=&quot;../stream/xmlresolver&quot;&gt;&lt;code&gt;XMLResolver&lt;/code&gt;&lt;/a&gt;. For the purpose of resolving &lt;code&gt;publicId&lt;/code&gt; and &lt;code&gt;systemId&lt;/code&gt;, this method is equivalent to &lt;a href=&quot;#resolveEntity(java.lang.String,java.lang.String)&quot;&gt;&lt;code&gt;resolveEntity(java.lang.String, java.lang.String)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">实现&lt;a href=&quot;../stream/xmlresolver&quot;&gt; &lt;code&gt;XMLResolver&lt;/code&gt; &lt;/a&gt;。为了解决 &lt;code&gt;publicId&lt;/code&gt; 和 &lt;code&gt;systemId&lt;/code&gt; 的目的，此方法等效于&lt;a href=&quot;#resolveEntity(java.lang.String,java.lang.String)&quot;&gt; &lt;code&gt;resolveEntity(java.lang.String, java.lang.String)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8863098812e88b16cb4e5ec4c94cb23e73164a4a" translate="yes" xml:space="preserve">
          <source>Implements CharacterIterator.current() for String.</source>
          <target state="translated">为String实现CharacterIterator.current()。</target>
        </trans-unit>
        <trans-unit id="38609ff217165cfd288c6a9112395629b53b1ba0" translate="yes" xml:space="preserve">
          <source>Implements CharacterIterator.first() for String.</source>
          <target state="translated">为String实现CharacterIterator.first()。</target>
        </trans-unit>
        <trans-unit id="2061a474328a606288949699b4d01ead864c594e" translate="yes" xml:space="preserve">
          <source>Implements CharacterIterator.getBeginIndex() for String.</source>
          <target state="translated">为String实现CharacterIterator.getBeginIndex()。</target>
        </trans-unit>
        <trans-unit id="f3e0d313072ecadecf8f42575d03f852e7618f30" translate="yes" xml:space="preserve">
          <source>Implements CharacterIterator.getEndIndex() for String.</source>
          <target state="translated">为String实现CharacterIterator.getEndIndex()。</target>
        </trans-unit>
        <trans-unit id="37d2fcb4f6e906f747d683461fcc4508ccb0e9f3" translate="yes" xml:space="preserve">
          <source>Implements CharacterIterator.getIndex() for String.</source>
          <target state="translated">为String实现CharacterIterator.getIndex()。</target>
        </trans-unit>
        <trans-unit id="e6267a8f45083745718daf081f7ae536fff0541e" translate="yes" xml:space="preserve">
          <source>Implements CharacterIterator.last() for String.</source>
          <target state="translated">为String实现CharacterIterator.last()。</target>
        </trans-unit>
        <trans-unit id="9ca927fd2f3bfbd655d908c44ae43b9f811f2ea5" translate="yes" xml:space="preserve">
          <source>Implements CharacterIterator.next() for String.</source>
          <target state="translated">为String实现CharacterIterator.next()。</target>
        </trans-unit>
        <trans-unit id="6fa220d3128cac8bac5353ff3943c263da81da91" translate="yes" xml:space="preserve">
          <source>Implements CharacterIterator.previous() for String.</source>
          <target state="translated">为String实现CharacterIterator.previous()。</target>
        </trans-unit>
        <trans-unit id="4ad2159627bb0908caad3b333ea29cbd16bf1140" translate="yes" xml:space="preserve">
          <source>Implements CharacterIterator.setIndex() for String.</source>
          <target state="translated">为String实现CharacterIterator.setIndex()。</target>
        </trans-unit>
        <trans-unit id="d7d801a17ff9284b9b5a555fad45b98ca0144a28" translate="yes" xml:space="preserve">
          <source>Implements URIResolver.</source>
          <target state="translated">执行URIResolver。</target>
        </trans-unit>
        <trans-unit id="318cd35cc48f383eeda6d6fd1b9667781c2143fe" translate="yes" xml:space="preserve">
          <source>Implements URIResolver. The method searches through the catalog entries in the main and alternative catalogs to attempt to find a match with the specified &lt;code&gt;href&lt;/code&gt; attribute. The &lt;code&gt;href&lt;/code&gt; attribute will be used literally, with no attempt to be made absolute to the &lt;code&gt;base&lt;/code&gt;.</source>
          <target state="translated">实现URIResolver。该方法搜索主目录和备用目录中的目录条目，以尝试查找具有指定 &lt;code&gt;href&lt;/code&gt; 属性的匹配项。该 &lt;code&gt;href&lt;/code&gt; 属性将用文字代替，没有试图做出绝对的 &lt;code&gt;base&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="31c4b09be804aaf138edc0afa59e53f472c6e688" translate="yes" xml:space="preserve">
          <source>Implements View interface for a simple multi-line text view that has text in one font and color.</source>
          <target state="translated">实现一个简单的多行文本视图的视图接口,该视图中的文本使用一种字体和颜色。</target>
        </trans-unit>
        <trans-unit id="fb2809aa78c909534686dfa4a5a387ba869c24e6" translate="yes" xml:space="preserve">
          <source>Implements View interface for a simple multi-line text view that has text in one font and color. The view represents each child element as a line of text.</source>
          <target state="translated">实现一个简单的多行文本视图的视图接口,该视图的文本采用一种字体和颜色。该视图将每个子元素表示为一行文本。</target>
        </trans-unit>
        <trans-unit id="bb36a4fb29616c43d77d4ae60696878082fa8f31" translate="yes" xml:space="preserve">
          <source>Implements View interface for a table, that is composed of an element structure where the child elements of the element this view is responsible for represent rows and the child elements of the row elements are cells.</source>
          <target state="translated">实现一个表的视图接口,该表由元素结构组成,该视图负责的元素的子元素代表行,行元素的子元素是单元格。</target>
        </trans-unit>
        <trans-unit id="16821c6318c86c959d397b02a216025ffa6f1bdf" translate="yes" xml:space="preserve">
          <source>Implements View interface for a table, that is composed of an element structure where the child elements of the element this view is responsible for represent rows and the child elements of the row elements are cells. The cell elements can have an arbitrary element structure under them, which will be built with the ViewFactory returned by the getViewFactory method.</source>
          <target state="translated">实现一个表的View接口,该表由一个元素结构组成,其中该View负责的元素的子元素代表行,行元素的子元素是单元格。单元格元素下可以有一个任意的元素结构,它将用getViewFactory方法返回的ViewFactory来构建。</target>
        </trans-unit>
        <trans-unit id="93d7b85b84f5df6147819e746f11ca13dcd596e9" translate="yes" xml:space="preserve">
          <source>Implements W3C XML Schema Part 2, Section 3.2.7.3 (A).</source>
          <target state="translated">执行W3C XML Schema第2部分第3.2.7.3(A)节。</target>
        </trans-unit>
        <trans-unit id="4ed37c520c0b09ffc1b4b1e2621ae8fa8595db68" translate="yes" xml:space="preserve">
          <source>Implements a View suitable for use in JPasswordField UI implementations.</source>
          <target state="translated">实现一个适合在JPasswordField UI实现中使用的视图。</target>
        </trans-unit>
        <trans-unit id="067b74bffa3943fb1bb2edc38d7679a72dfb5897" translate="yes" xml:space="preserve">
          <source>Implements a View suitable for use in JPasswordField UI implementations. This is basically a field ui that renders its contents as the echo character specified in the associated component (if it can narrow the component to a JPasswordField).</source>
          <target state="translated">实现一个适用于JPasswordField UI实现的视图。这基本上是一个字段ui,它将其内容渲染为关联组件中指定的回声字符(如果它能将组件缩小到JPasswordField)。</target>
        </trans-unit>
        <trans-unit id="122506fa9d8f19a72b209a6463f3c3f6806b913f" translate="yes" xml:space="preserve">
          <source>Implements a composite element that contains other elements.</source>
          <target state="translated">实现一个包含其他元素的复合元素。</target>
        </trans-unit>
        <trans-unit id="eb77268cf31c9d1b7065ac4f346f0f4f62633aa5" translate="yes" xml:space="preserve">
          <source>Implements a non-terminal append-and-replace step.</source>
          <target state="translated">实施一个非终端的追加和替换步骤。</target>
        </trans-unit>
        <trans-unit id="8fc7388752bff5a1959372aa839600a88a0d6560" translate="yes" xml:space="preserve">
          <source>Implements a terminal append-and-replace step.</source>
          <target state="translated">实现终端的追加和替换步骤。</target>
        </trans-unit>
        <trans-unit id="a4195097f3d067f532df1fff9627a92a21d4eb32" translate="yes" xml:space="preserve">
          <source>Implements absolute timed condition wait.</source>
          <target state="translated">实现绝对定时的条件等待。</target>
        </trans-unit>
        <trans-unit id="65420a72d88c9de714dd31d95f63cbe8c1653bea" translate="yes" xml:space="preserve">
          <source>Implements an element that directly represents content of some kind.</source>
          <target state="translated">实现一个直接表示某种内容的元素。</target>
        </trans-unit>
        <trans-unit id="37c1e8dcf99a0f703b26aac24a1a89f9d4541abd" translate="yes" xml:space="preserve">
          <source>Implements an input stream filter for compressing data in the &quot;deflate&quot; compression format.</source>
          <target state="translated">实施一个输入流过滤器,用于压缩 &quot;deflate &quot;压缩格式的数据。</target>
        </trans-unit>
        <trans-unit id="fb39bbcec1c774b4fba93fc21190a47bc5971af5" translate="yes" xml:space="preserve">
          <source>Implements an output stream filter for uncompressing data stored in the &quot;deflate&quot; compression format.</source>
          <target state="translated">实施一个输出流过滤器,用于解压存储在 &quot;deflate &quot;压缩格式中的数据。</target>
        </trans-unit>
        <trans-unit id="9c43b35ae2a5e1c03476a63c25a2b6caa54dc356" translate="yes" xml:space="preserve">
          <source>Implements execution conventions for CountedCompleters.</source>
          <target state="translated">执行CountedCompleters的执行约定。</target>
        </trans-unit>
        <trans-unit id="551f1837817dc3b5cc8875eeb3c93a0ab8888206" translate="yes" xml:space="preserve">
          <source>Implements execution conventions for RecursiveActions.</source>
          <target state="translated">执行RecursiveActions的执行约定。</target>
        </trans-unit>
        <trans-unit id="f0fdfaa1349a464aa045ad325a724296034d0863" translate="yes" xml:space="preserve">
          <source>Implements execution conventions for RecursiveTask.</source>
          <target state="translated">执行RecursiveTask的执行约定。</target>
        </trans-unit>
        <trans-unit id="4cf0ccace084c50198d2ff61513b820d4b7ab184" translate="yes" xml:space="preserve">
          <source>Implements interruptible condition wait.</source>
          <target state="translated">实施可中断条件等待。</target>
        </trans-unit>
        <trans-unit id="5ef5d897a19fb982809f56979cd95dfafbb96664" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;TableCellEditor&lt;/code&gt; interface.</source>
          <target state="translated">实现 &lt;code&gt;TableCellEditor&lt;/code&gt; 接口。</target>
        </trans-unit>
        <trans-unit id="1614df85be305c9188349340b94e25e4e4c33b0d" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;TreeCellEditor&lt;/code&gt; interface.</source>
          <target state="translated">实现 &lt;code&gt;TreeCellEditor&lt;/code&gt; 接口。</target>
        </trans-unit>
        <trans-unit id="5a884e5830e3412fc3cf287954f6b32ab405511f" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;absolutePath&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#absolutePath()&quot;&gt;&lt;code&gt;Preferences.absolutePath()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">根据&lt;a href=&quot;preferences#absolutePath()&quot;&gt; &lt;code&gt;Preferences.absolutePath()&lt;/code&gt; 中&lt;/a&gt;的规范实现 &lt;code&gt;absolutePath&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="2303304616ae77f7756f510ceeff5058198c36af" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;absolutePath&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#absolutePath--&quot;&gt;&lt;code&gt;Preferences.absolutePath()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">根据&lt;a href=&quot;preferences#absolutePath--&quot;&gt; &lt;code&gt;Preferences.absolutePath()&lt;/code&gt; 中&lt;/a&gt;的规范实现 &lt;code&gt;absolutePath&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="497711fb7d3b95561f2fd887f3f3cff39b4d70b2" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;children&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#childrenNames()&quot;&gt;&lt;code&gt;Preferences.childrenNames()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">根据&lt;a href=&quot;preferences#childrenNames()&quot;&gt; &lt;code&gt;Preferences.childrenNames()&lt;/code&gt; 中&lt;/a&gt;的规范实现 &lt;code&gt;children&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="034f9deafba508d9af3bcf5b68973bd9dea1bd76" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;children&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#childrenNames--&quot;&gt;&lt;code&gt;Preferences.childrenNames()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">根据&lt;a href=&quot;preferences#childrenNames--&quot;&gt; &lt;code&gt;Preferences.childrenNames()&lt;/code&gt; 中&lt;/a&gt;的规范实现 &lt;code&gt;children&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="059e0498a51dfd4925cfb2b3102695e450c99c62" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;clear&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#clear()&quot;&gt;&lt;code&gt;Preferences.clear()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">根据&lt;a href=&quot;preferences#clear()&quot;&gt; &lt;code&gt;Preferences.clear()&lt;/code&gt; 中&lt;/a&gt;的规范实现 &lt;code&gt;clear&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="46cb2a81f204b4143be54da7ee4ce2b43a9f0e15" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;clear&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#clear--&quot;&gt;&lt;code&gt;Preferences.clear()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">根据&lt;a href=&quot;preferences#clear--&quot;&gt; &lt;code&gt;Preferences.clear()&lt;/code&gt; 中&lt;/a&gt;的规范实现 &lt;code&gt;clear&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="27384530e833319c1741f425fdd02affb746be4a" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;exportNode&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#exportNode(java.io.OutputStream)&quot;&gt;&lt;code&gt;Preferences.exportNode(OutputStream)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">根据&lt;a href=&quot;preferences#exportNode(java.io.OutputStream)&quot;&gt; &lt;code&gt;Preferences.exportNode(OutputStream)&lt;/code&gt; 中&lt;/a&gt;的规范实现 &lt;code&gt;exportNode&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="c5271f0b8def61c25744f1dd1f9a7a0866178042" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;exportNode&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#exportNode-java.io.OutputStream-&quot;&gt;&lt;code&gt;Preferences.exportNode(OutputStream)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">根据&lt;a href=&quot;preferences#exportNode-java.io.OutputStream-&quot;&gt; &lt;code&gt;Preferences.exportNode(OutputStream)&lt;/code&gt; 中&lt;/a&gt;的规范实现 &lt;code&gt;exportNode&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="98aad1f6a054ecea9742f417fa73cff7c9b09ac3" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;exportSubtree&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#exportSubtree(java.io.OutputStream)&quot;&gt;&lt;code&gt;Preferences.exportSubtree(OutputStream)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">根据&lt;a href=&quot;preferences#exportSubtree(java.io.OutputStream)&quot;&gt; &lt;code&gt;Preferences.exportSubtree(OutputStream)&lt;/code&gt; 中&lt;/a&gt;的规范实现 &lt;code&gt;exportSubtree&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="6992328892719c452810c6ca8560c959a91e93f4" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;exportSubtree&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#exportSubtree-java.io.OutputStream-&quot;&gt;&lt;code&gt;Preferences.exportSubtree(OutputStream)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">根据&lt;a href=&quot;preferences#exportSubtree-java.io.OutputStream-&quot;&gt; &lt;code&gt;Preferences.exportSubtree(OutputStream)&lt;/code&gt; 中&lt;/a&gt;的规范实现 &lt;code&gt;exportSubtree&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="f75a22f3a2ce6719749fb126229e20961cecf828" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;flush&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#flush()&quot;&gt;&lt;code&gt;Preferences.flush()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">根据&lt;a href=&quot;preferences#flush()&quot;&gt; &lt;code&gt;Preferences.flush()&lt;/code&gt; 中&lt;/a&gt;的规范实现 &lt;code&gt;flush&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="0bcf92c331b449f42058427c1857f88ad0cc933d" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;flush&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#flush--&quot;&gt;&lt;code&gt;Preferences.flush()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">根据&lt;a href=&quot;preferences#flush--&quot;&gt; &lt;code&gt;Preferences.flush()&lt;/code&gt; 中&lt;/a&gt;的规范实现 &lt;code&gt;flush&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="78015e2cb6a6572466b2f3107eadbeb75649f6f0" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;get&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#get(java.lang.String,java.lang.String)&quot;&gt;&lt;code&gt;Preferences.get(String,String)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">根据&lt;a href=&quot;preferences#get(java.lang.String,java.lang.String)&quot;&gt; &lt;code&gt;Preferences.get(String,String)&lt;/code&gt; 中&lt;/a&gt;的规范实现 &lt;code&gt;get&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="fd60f453d49bb8d7d210813e6ce68cc6bfb94562" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;get&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#get-java.lang.String-java.lang.String-&quot;&gt;&lt;code&gt;Preferences.get(String,String)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">根据&lt;a href=&quot;preferences#get-java.lang.String-java.lang.String-&quot;&gt; &lt;code&gt;Preferences.get(String,String)&lt;/code&gt; 中&lt;/a&gt;的规范实现 &lt;code&gt;get&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="ea353e66c1ac86790405e5ed097438b417b79346" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;getBoolean&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#getBoolean(java.lang.String,boolean)&quot;&gt;&lt;code&gt;Preferences.getBoolean(String,boolean)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">根据&lt;a href=&quot;preferences#getBoolean(java.lang.String,boolean)&quot;&gt; &lt;code&gt;Preferences.getBoolean(String,boolean)&lt;/code&gt; 中&lt;/a&gt;的规范实现 &lt;code&gt;getBoolean&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="bb5155ae4fbbe6ae18c3ab26004b7eece250eb0f" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;getBoolean&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#getBoolean-java.lang.String-boolean-&quot;&gt;&lt;code&gt;Preferences.getBoolean(String,boolean)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">根据&lt;a href=&quot;preferences#getBoolean-java.lang.String-boolean-&quot;&gt; &lt;code&gt;Preferences.getBoolean(String,boolean)&lt;/code&gt; 中&lt;/a&gt;的规范实现 &lt;code&gt;getBoolean&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="0b7fc840c8fcf629db0b7313f488ea98f77836eb" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;getByteArray&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#getByteArray(java.lang.String,byte%5B%5D)&quot;&gt;&lt;code&gt;Preferences.getByteArray(String,byte[])&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">根据&lt;a href=&quot;preferences#getByteArray(java.lang.String,byte%5B%5D)&quot;&gt; &lt;code&gt;Preferences.getByteArray(String,byte[])&lt;/code&gt; &lt;/a&gt;的规范实现 &lt;code&gt;getByteArray&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="f0b4007d76b02ecf996288a0c19ed712d960828e" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;getByteArray&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#getByteArray-java.lang.String-byte:A-&quot;&gt;&lt;code&gt;Preferences.getByteArray(String,byte[])&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">根据&lt;a href=&quot;preferences#getByteArray-java.lang.String-byte:A-&quot;&gt; &lt;code&gt;Preferences.getByteArray(String,byte[])&lt;/code&gt; &lt;/a&gt;的规范实现 &lt;code&gt;getByteArray&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="a44773ab8dcb04f9357998eb6b4f39e88e41394d" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;getDouble&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#getDouble(java.lang.String,double)&quot;&gt;&lt;code&gt;Preferences.getDouble(String,double)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">根据&lt;a href=&quot;preferences#getDouble(java.lang.String,double)&quot;&gt; &lt;code&gt;Preferences.getDouble(String,double)&lt;/code&gt; 中&lt;/a&gt;的规范实现 &lt;code&gt;getDouble&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="e9e450fbaa690dcceaab8d53b8c3cbedb82f9d78" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;getDouble&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#getDouble-java.lang.String-double-&quot;&gt;&lt;code&gt;Preferences.getDouble(String,double)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">根据&lt;a href=&quot;preferences#getDouble-java.lang.String-double-&quot;&gt; &lt;code&gt;Preferences.getDouble(String,double)&lt;/code&gt; 中&lt;/a&gt;的规范实现 &lt;code&gt;getDouble&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="4b1e5f933602798366ed31ec748973cb8f3739c0" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;getFloat&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#getFloat(java.lang.String,float)&quot;&gt;&lt;code&gt;Preferences.getFloat(String,float)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">根据&lt;a href=&quot;preferences#getFloat(java.lang.String,float)&quot;&gt; &lt;code&gt;Preferences.getFloat(String,float)&lt;/code&gt; 中&lt;/a&gt;的规范实现 &lt;code&gt;getFloat&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="84b21b049297b5e1b111acffab81a95f30370f84" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;getFloat&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#getFloat-java.lang.String-float-&quot;&gt;&lt;code&gt;Preferences.getFloat(String,float)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">根据&lt;a href=&quot;preferences#getFloat-java.lang.String-float-&quot;&gt; &lt;code&gt;Preferences.getFloat(String,float)&lt;/code&gt; 中&lt;/a&gt;的规范实现 &lt;code&gt;getFloat&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="b5f74f30c5422d8d952c57c972e6d8fc8639e2dc" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;getInt&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#getInt(java.lang.String,int)&quot;&gt;&lt;code&gt;Preferences.getInt(String,int)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">根据&lt;a href=&quot;preferences#getInt(java.lang.String,int)&quot;&gt; &lt;code&gt;Preferences.getInt(String,int)&lt;/code&gt; 中&lt;/a&gt;的规范实现 &lt;code&gt;getInt&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="c274f814517f4670c893c66cb2bfa98eeab7e4bd" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;getInt&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#getInt-java.lang.String-int-&quot;&gt;&lt;code&gt;Preferences.getInt(String,int)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">根据&lt;a href=&quot;preferences#getInt-java.lang.String-int-&quot;&gt; &lt;code&gt;Preferences.getInt(String,int)&lt;/code&gt; 中&lt;/a&gt;的规范实现 &lt;code&gt;getInt&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="f9716d025f1b0da02dcfcfcafecd8a4dc2e3ab9f" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;getLong&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#getLong(java.lang.String,long)&quot;&gt;&lt;code&gt;Preferences.getLong(String,long)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">根据&lt;a href=&quot;preferences#getLong(java.lang.String,long)&quot;&gt; &lt;code&gt;Preferences.getLong(String,long)&lt;/code&gt; 中&lt;/a&gt;的规范实现 &lt;code&gt;getLong&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="1da387d0a91dd5384161de4e156bcc24ea6fbf17" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;getLong&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#getLong-java.lang.String-long-&quot;&gt;&lt;code&gt;Preferences.getLong(String,long)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">根据&lt;a href=&quot;preferences#getLong-java.lang.String-long-&quot;&gt; &lt;code&gt;Preferences.getLong(String,long)&lt;/code&gt; 中&lt;/a&gt;的规范实现 &lt;code&gt;getLong&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="4eaa95ecc8b1c6d190deea16df5803f9a33f646f" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;isUserNode&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#isUserNode()&quot;&gt;&lt;code&gt;Preferences.isUserNode()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">根据&lt;a href=&quot;preferences#isUserNode()&quot;&gt; &lt;code&gt;Preferences.isUserNode()&lt;/code&gt; 中&lt;/a&gt;的规范实现 &lt;code&gt;isUserNode&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="ea4fec525521819b707dbeac6d4f7ff72f03a4c2" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;isUserNode&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#isUserNode--&quot;&gt;&lt;code&gt;Preferences.isUserNode()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">根据&lt;a href=&quot;preferences#isUserNode--&quot;&gt; &lt;code&gt;Preferences.isUserNode()&lt;/code&gt; 中&lt;/a&gt;的规范实现 &lt;code&gt;isUserNode&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="e5056bd26346ca8c414eb53534dd9265bec86009" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;keys&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#keys()&quot;&gt;&lt;code&gt;Preferences.keys()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">根据&lt;a href=&quot;preferences#keys()&quot;&gt; &lt;code&gt;Preferences.keys()&lt;/code&gt; 中&lt;/a&gt;的规范实现 &lt;code&gt;keys&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="dd3d33b98e343258fdc365b452fe2c54c3a57a8c" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;keys&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#keys--&quot;&gt;&lt;code&gt;Preferences.keys()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">根据&lt;a href=&quot;preferences#keys--&quot;&gt; &lt;code&gt;Preferences.keys()&lt;/code&gt; 中&lt;/a&gt;的规范实现 &lt;code&gt;keys&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="f5c94dffc44ba9a6355d9a0ae6ff61d2d2dd03f3" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;name&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#name()&quot;&gt;&lt;code&gt;Preferences.name()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">根据&lt;a href=&quot;preferences#name()&quot;&gt; &lt;code&gt;Preferences.name()&lt;/code&gt; 中&lt;/a&gt;的规范实现 &lt;code&gt;name&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="b8b350943fb40b138fd56f36c6dbef682a6322e1" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;name&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#name--&quot;&gt;&lt;code&gt;Preferences.name()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">根据&lt;a href=&quot;preferences#name--&quot;&gt; &lt;code&gt;Preferences.name()&lt;/code&gt; 中&lt;/a&gt;的规范实现 &lt;code&gt;name&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="e852153c5eb8ea699e3354d9551a6e43544dcd03" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;node&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#node(java.lang.String)&quot;&gt;&lt;code&gt;Preferences.node(String)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">根据&lt;a href=&quot;preferences#node(java.lang.String)&quot;&gt; &lt;code&gt;Preferences.node(String)&lt;/code&gt; 中&lt;/a&gt;的规范实现 &lt;code&gt;node&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="0649c8cc433a5e7005ae22f20906c8b707b86e84" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;node&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#node-java.lang.String-&quot;&gt;&lt;code&gt;Preferences.node(String)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">根据&lt;a href=&quot;preferences#node-java.lang.String-&quot;&gt; &lt;code&gt;Preferences.node(String)&lt;/code&gt; 中&lt;/a&gt;的规范实现 &lt;code&gt;node&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="721cd1cca821bc0d961d9aefe3bb96e48fb959bf" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;nodeExists&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#nodeExists(java.lang.String)&quot;&gt;&lt;code&gt;Preferences.nodeExists(String)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">根据&lt;a href=&quot;preferences#nodeExists(java.lang.String)&quot;&gt; &lt;code&gt;Preferences.nodeExists(String)&lt;/code&gt; 中&lt;/a&gt;的规范实现 &lt;code&gt;nodeExists&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="e4aa7ebab34301da1cde7559e5697decfe5af827" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;nodeExists&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#nodeExists-java.lang.String-&quot;&gt;&lt;code&gt;Preferences.nodeExists(String)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">根据&lt;a href=&quot;preferences#nodeExists-java.lang.String-&quot;&gt; &lt;code&gt;Preferences.nodeExists(String)&lt;/code&gt; 中&lt;/a&gt;的规范实现 &lt;code&gt;nodeExists&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="7e8f9fb1d98b5f9d794284d8ed809f6806b7c844" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;parent&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#parent()&quot;&gt;&lt;code&gt;Preferences.parent()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">根据&lt;a href=&quot;preferences#parent()&quot;&gt; &lt;code&gt;Preferences.parent()&lt;/code&gt; 中&lt;/a&gt;的规范实现 &lt;code&gt;parent&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="f4fe173b9d0a89ea7f1b5eba6be1698ca690f55e" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;parent&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#parent--&quot;&gt;&lt;code&gt;Preferences.parent()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">根据&lt;a href=&quot;preferences#parent--&quot;&gt; &lt;code&gt;Preferences.parent()&lt;/code&gt; 中&lt;/a&gt;的规范实现 &lt;code&gt;parent&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="9d809f3091f242364c316d9f4236b053d68715fb" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;put&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#put(java.lang.String,java.lang.String)&quot;&gt;&lt;code&gt;Preferences.put(String,String)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">根据&lt;a href=&quot;preferences#put(java.lang.String,java.lang.String)&quot;&gt; &lt;code&gt;Preferences.put(String,String)&lt;/code&gt; 中&lt;/a&gt;的规范实现 &lt;code&gt;put&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="56c5e61149b3eee9a14a2381738dfc70bccfc389" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;put&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#put-java.lang.String-java.lang.String-&quot;&gt;&lt;code&gt;Preferences.put(String,String)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">根据&lt;a href=&quot;preferences#put-java.lang.String-java.lang.String-&quot;&gt; &lt;code&gt;Preferences.put(String,String)&lt;/code&gt; 中&lt;/a&gt;的规范实现 &lt;code&gt;put&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="8f056c5d095a472be619608c64cedd250d13f1d7" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;putBoolean&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#putBoolean(java.lang.String,boolean)&quot;&gt;&lt;code&gt;Preferences.putBoolean(String,boolean)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">根据&lt;a href=&quot;preferences#putBoolean(java.lang.String,boolean)&quot;&gt; &lt;code&gt;Preferences.putBoolean(String,boolean)&lt;/code&gt; 中&lt;/a&gt;的规范实现 &lt;code&gt;putBoolean&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="c964cfd9449cfba5f084d6eb883e09669a4711ef" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;putBoolean&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#putBoolean-java.lang.String-boolean-&quot;&gt;&lt;code&gt;Preferences.putBoolean(String,boolean)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">根据&lt;a href=&quot;preferences#putBoolean-java.lang.String-boolean-&quot;&gt; &lt;code&gt;Preferences.putBoolean(String,boolean)&lt;/code&gt; 中&lt;/a&gt;的规范实现 &lt;code&gt;putBoolean&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="af75d3c130947f6453fb67efe7a6515eaa2f9eb7" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;putByteArray&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#putByteArray(java.lang.String,byte%5B%5D)&quot;&gt;&lt;code&gt;Preferences.putByteArray(String,byte[])&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">根据&lt;a href=&quot;preferences#putByteArray(java.lang.String,byte%5B%5D)&quot;&gt; &lt;code&gt;Preferences.putByteArray(String,byte[])&lt;/code&gt; &lt;/a&gt;的规范实现 &lt;code&gt;putByteArray&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="6dfb192ca6481e94bbe487fe93ad8e390c6a8ddf" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;putByteArray&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#putByteArray-java.lang.String-byte:A-&quot;&gt;&lt;code&gt;Preferences.putByteArray(String,byte[])&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">根据&lt;a href=&quot;preferences#putByteArray-java.lang.String-byte:A-&quot;&gt; &lt;code&gt;Preferences.putByteArray(String,byte[])&lt;/code&gt; &lt;/a&gt;的规范实现 &lt;code&gt;putByteArray&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="86f038d3dbcc6bf189a5c7d2b8d83b4055d9607e" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;putDouble&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#putDouble(java.lang.String,double)&quot;&gt;&lt;code&gt;Preferences.putDouble(String,double)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">根据&lt;a href=&quot;preferences#putDouble(java.lang.String,double)&quot;&gt; &lt;code&gt;Preferences.putDouble(String,double)&lt;/code&gt; 中&lt;/a&gt;的规范实现 &lt;code&gt;putDouble&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="700b1f1d7618f6e22ebcf34385a559a63ca591ae" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;putDouble&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#putDouble-java.lang.String-double-&quot;&gt;&lt;code&gt;Preferences.putDouble(String,double)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">根据&lt;a href=&quot;preferences#putDouble-java.lang.String-double-&quot;&gt; &lt;code&gt;Preferences.putDouble(String,double)&lt;/code&gt; 中&lt;/a&gt;的规范实现 &lt;code&gt;putDouble&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="d8603d94d3fb23a4921e68448f26bf91b23e2187" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;putFloat&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#putFloat(java.lang.String,float)&quot;&gt;&lt;code&gt;Preferences.putFloat(String,float)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">根据&lt;a href=&quot;preferences#putFloat(java.lang.String,float)&quot;&gt; &lt;code&gt;Preferences.putFloat(String,float)&lt;/code&gt; 中&lt;/a&gt;的规范实现 &lt;code&gt;putFloat&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="80192947101c876eaade219b960719ce5fba52be" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;putFloat&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#putFloat-java.lang.String-float-&quot;&gt;&lt;code&gt;Preferences.putFloat(String,float)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">根据&lt;a href=&quot;preferences#putFloat-java.lang.String-float-&quot;&gt; &lt;code&gt;Preferences.putFloat(String,float)&lt;/code&gt; 中&lt;/a&gt;的规范实现 &lt;code&gt;putFloat&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="c2a61e9f0bf4527abc6bd4ad38427bfcb330d4db" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;putInt&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#putInt(java.lang.String,int)&quot;&gt;&lt;code&gt;Preferences.putInt(String,int)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">根据&lt;a href=&quot;preferences#putInt(java.lang.String,int)&quot;&gt; &lt;code&gt;Preferences.putInt(String,int)&lt;/code&gt; 中&lt;/a&gt;的规范实现 &lt;code&gt;putInt&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="4a885f79dd7082ca994a78ab5b9536740b01678f" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;putInt&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#putInt-java.lang.String-int-&quot;&gt;&lt;code&gt;Preferences.putInt(String,int)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">根据&lt;a href=&quot;preferences#putInt-java.lang.String-int-&quot;&gt; &lt;code&gt;Preferences.putInt(String,int)&lt;/code&gt; 中&lt;/a&gt;的规范实现 &lt;code&gt;putInt&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="dfa859440e2acc402f4baa4bb6bfe19c14468b22" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;putLong&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#putLong(java.lang.String,long)&quot;&gt;&lt;code&gt;Preferences.putLong(String,long)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">根据&lt;a href=&quot;preferences#putLong(java.lang.String,long)&quot;&gt; &lt;code&gt;Preferences.putLong(String,long)&lt;/code&gt; 中&lt;/a&gt;的规范实现 &lt;code&gt;putLong&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="95eb710c08c834586c53fc11e79b1b0c9ead4298" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;putLong&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#putLong-java.lang.String-long-&quot;&gt;&lt;code&gt;Preferences.putLong(String,long)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">根据&lt;a href=&quot;preferences#putLong-java.lang.String-long-&quot;&gt; &lt;code&gt;Preferences.putLong(String,long)&lt;/code&gt; 中&lt;/a&gt;的规范实现 &lt;code&gt;putLong&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="1145d33fa13a92fc862f33552963cbefaf56a0dd" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;remove(String)&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#remove(java.lang.String)&quot;&gt;&lt;code&gt;Preferences.remove(String)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">根据&lt;a href=&quot;preferences#remove(java.lang.String)&quot;&gt; &lt;code&gt;Preferences.remove(String)&lt;/code&gt; 中&lt;/a&gt;的规范实现 &lt;code&gt;remove(String)&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="b0b2653970946b64ed4ddaa3ebfdafe0eb71373a" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;remove(String)&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#remove-java.lang.String-&quot;&gt;&lt;code&gt;Preferences.remove(String)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">根据&lt;a href=&quot;preferences#remove-java.lang.String-&quot;&gt; &lt;code&gt;Preferences.remove(String)&lt;/code&gt; 中&lt;/a&gt;的规范实现 &lt;code&gt;remove(String)&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="f73d465ace07becf08f1ef90ce5d0fc36fd68877" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;removeNode()&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#removeNode()&quot;&gt;&lt;code&gt;Preferences.removeNode()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">根据&lt;a href=&quot;preferences#removeNode()&quot;&gt; &lt;code&gt;Preferences.removeNode()&lt;/code&gt; 中&lt;/a&gt;的规范实现 &lt;code&gt;removeNode()&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="a9fc2ab6783e8c0ed4c3c6887838e051d6ead650" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;removeNode()&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#removeNode--&quot;&gt;&lt;code&gt;Preferences.removeNode()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">根据&lt;a href=&quot;preferences#removeNode--&quot;&gt; &lt;code&gt;Preferences.removeNode()&lt;/code&gt; 中&lt;/a&gt;的规范实现 &lt;code&gt;removeNode()&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="4e514973362c210c6c0a45eabf33779bc4abe69e" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;sync&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#sync()&quot;&gt;&lt;code&gt;Preferences.sync()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">根据&lt;a href=&quot;preferences#sync()&quot;&gt; &lt;code&gt;Preferences.sync()&lt;/code&gt; 中&lt;/a&gt;的规范实现 &lt;code&gt;sync&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="0f50cf978662ba1a1c66109922a9ef7df030c0f8" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;sync&lt;/code&gt; method as per the specification in &lt;a href=&quot;preferences#sync--&quot;&gt;&lt;code&gt;Preferences.sync()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">根据&lt;a href=&quot;preferences#sync--&quot;&gt; &lt;code&gt;Preferences.sync()&lt;/code&gt; 中&lt;/a&gt;的规范实现 &lt;code&gt;sync&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="8070a9651a28f504d3ee606de0cb54a78c1a449a" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;write&lt;/code&gt; method of &lt;code&gt;OutputStream&lt;/code&gt;.</source>
          <target state="translated">实现 &lt;code&gt;OutputStream&lt;/code&gt; 的 &lt;code&gt;write&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="eba7a76fb44749a7dc70c0178e32f86bfaaab0bb" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;write&lt;/code&gt; method of &lt;code&gt;Writer&lt;/code&gt;.</source>
          <target state="translated">实现 &lt;code&gt;Writer&lt;/code&gt; 的 &lt;code&gt;write&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="7345100c6205aaddd53c33150182817376407dd0" translate="yes" xml:space="preserve">
          <source>Implements the Highlighter interfaces.</source>
          <target state="translated">实现Highlighter接口。</target>
        </trans-unit>
        <trans-unit id="713527e650aa1d514fc11e2fb72846d8adfaba95" translate="yes" xml:space="preserve">
          <source>Implements the Highlighter interfaces. Implements a simple highlight painter that renders in a solid color.</source>
          <target state="translated">实现高光绘制接口。实现一个简单的高光画笔,以纯色渲染。</target>
        </trans-unit>
        <trans-unit id="1df7d1f3a6612a7a78698f998e2369cabdbb3654" translate="yes" xml:space="preserve">
          <source>Implements the abstract &lt;code&gt;write&lt;/code&gt; method of &lt;code&gt;OutputStream&lt;/code&gt;.</source>
          <target state="translated">实现 &lt;code&gt;OutputStream&lt;/code&gt; 的抽象 &lt;code&gt;write&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="e84e5d2d6f3ad30c13bbffe6f10586dcbe14843b" translate="yes" xml:space="preserve">
          <source>Implements the abstract part of an element.</source>
          <target state="translated">实现元素的抽象部分。</target>
        </trans-unit>
        <trans-unit id="55af899b56f29b0b6a4178b4545eb0b45c43ff18" translate="yes" xml:space="preserve">
          <source>Implements the abstract part of an element. By default elements support attributes by having a field that represents the immutable part of the current attribute set for the element. The element itself implements MutableAttributeSet which can be used to modify the set by fetching a new immutable set. The immutable sets are provided by the AttributeContext associated with the document.</source>
          <target state="translated">实现元素的抽象部分。默认情况下,元素通过拥有一个字段来支持属性,这个字段代表元素当前属性集的不可变部分。元素本身实现了MutableAttributeSet,可以通过获取一个新的不可变集来修改该集。不可变集由与文档关联的AttributeContext提供。</target>
        </trans-unit>
        <trans-unit id="ab32001571b15dd2de30bb6329e0837209226884" translate="yes" xml:space="preserve">
          <source>Implements the guard interface for a permission.</source>
          <target state="translated">实现一个权限的守护接口。</target>
        </trans-unit>
        <trans-unit id="85dcc3ce4240cbda68572ddbcac72a94ce15863a" translate="yes" xml:space="preserve">
          <source>Implements the guard interface for a permission. The &lt;code&gt;SecurityManager.checkPermission&lt;/code&gt; method is called, passing this permission object as the permission to check. Returns silently if access is granted. Otherwise, throws a SecurityException.</source>
          <target state="translated">实现保护接口以获得许可。该 &lt;code&gt;SecurityManager.checkPermission&lt;/code&gt; 方法被调用，通过该权限对象作为检查的权限。如果授予访问权限，则以静默方式返回。否则，抛出SecurityException。</target>
        </trans-unit>
        <trans-unit id="9c8baefff3346231902a3ebabd8df14c787b0f9b" translate="yes" xml:space="preserve">
          <source>Implements timed condition wait.</source>
          <target state="translated">实施定时条件等待。</target>
        </trans-unit>
        <trans-unit id="97bc4b1502ef7ea7fd18271c7831c9405cc5ea04" translate="yes" xml:space="preserve">
          <source>Implements uninterruptible condition wait.</source>
          <target state="translated">实现不间断的条件等待。</target>
        </trans-unit>
        <trans-unit id="dd92548143f247a24fedf6b61a62fa9529e2d435" translate="yes" xml:space="preserve">
          <source>Implicitly images are defined to provide color samples at integer coordinate locations. When images are rendered upright with no scaling onto a destination, the choice of which image pixels map to which device pixels is obvious and the samples at the integer coordinate locations in the image are transferred to the pixels at the corresponding integer locations on the device pixel grid one for one. When images are rendered in a scaled, rotated, or otherwise transformed coordinate system, then the mapping of device pixel coordinates back to the image can raise the question of what color sample to use for the continuous coordinates that lie between the integer locations of the provided image samples. Interpolation algorithms define functions which provide a color sample for any continuous coordinate in an image based on the color samples at the surrounding integer coordinates.</source>
          <target state="translated">隐式图像被定义为在整数坐标位置提供颜色样本。当图像在没有缩放到目标上的情况下直立渲染时,哪些图像像素映射到哪些设备像素的选择是显而易见的,图像中整数坐标位置的样本会被一一转移到设备像素网格上相应整数位置的像素上。当图像以缩放、旋转或其他方式变换坐标系渲染时,那么设备像素坐标映射回图像就会产生一个问题,即在提供的图像样本的整数位置之间的连续坐标使用什么颜色的样本。插值算法定义了根据周围整数坐标处的颜色样本为图像中的任何连续坐标提供颜色样本的函数。</target>
        </trans-unit>
        <trans-unit id="82b3d6709372f3305bd61ec994ba088cc9e06444" translate="yes" xml:space="preserve">
          <source>Import underlying NT system identity information.</source>
          <target state="translated">导入NT系统底层身份信息。</target>
        </trans-unit>
        <trans-unit id="8e4f0037413323f64894225f1af30ec273d7739a" translate="yes" xml:space="preserve">
          <source>ImportSnippet</source>
          <target state="translated">ImportSnippet</target>
        </trans-unit>
        <trans-unit id="fa11bae66b379e4bbc361aa296630ba39df663cf" translate="yes" xml:space="preserve">
          <source>ImportTree</source>
          <target state="translated">ImportTree</target>
        </trans-unit>
        <trans-unit id="5d62bf28fded11386befccfd3cdcdab774d0246a" translate="yes" xml:space="preserve">
          <source>Important properties associated with &lt;code&gt;Status&lt;/code&gt; are: &lt;a href=&quot;#isDefined()&quot;&gt;&lt;code&gt;isDefined()&lt;/code&gt;&lt;/a&gt;, if it is visible to other existing and new snippets; and &lt;a href=&quot;#isActive()&quot;&gt;&lt;code&gt;isActive()&lt;/code&gt;&lt;/a&gt;, if, as the JShell state changes, the snippet will update, possibly changing &lt;code&gt;Status&lt;/code&gt;. An executable Snippet can only be executed if it is in the the &lt;a href=&quot;#VALID&quot;&gt;&lt;code&gt;VALID&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Status&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;Status&lt;/code&gt; 相关联的重要属性是：&lt;a href=&quot;#isDefined()&quot;&gt; &lt;code&gt;isDefined()&lt;/code&gt; &lt;/a&gt;（如果其他现有片段和新片段可见）；和&lt;a href=&quot;#isActive()&quot;&gt; &lt;code&gt;isActive()&lt;/code&gt; &lt;/a&gt;，如果随着JShell状态的改变，代码段将更新，可能会更改 &lt;code&gt;Status&lt;/code&gt; 。可执行代码段仅在处于&lt;a href=&quot;#VALID&quot;&gt; &lt;code&gt;VALID&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Status&lt;/code&gt; 时才能执行。</target>
        </trans-unit>
        <trans-unit id="b87df961a9a5842e2e0bd58fed3cd0c357e92df5" translate="yes" xml:space="preserve">
          <source>Imports a node from another document to this document, without altering or removing the source node from the original document; this method creates a new copy of the source node.</source>
          <target state="translated">将另一个文档中的节点导入到这个文档中,而不改变或删除原文档中的源节点;本方法为源节点创建一个新的副本。</target>
        </trans-unit>
        <trans-unit id="e917c5488e98c0c27be507a69f948d4511aef81e" translate="yes" xml:space="preserve">
          <source>Imports a node from another document to this document, without altering or removing the source node from the original document; this method creates a new copy of the source node. The returned node has no parent; (&lt;code&gt;parentNode&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;).</source>
          <target state="translated">将一个节点从另一个文档导入到此文档，而无需更改或从原始文档中删除源节点；此方法创建源节点的新副本。返回的节点没有父节点。（ &lt;code&gt;parentNode&lt;/code&gt; 为 &lt;code&gt;null&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="0c6ca8c58332c18473e39f6c0dc8388cdd462423" translate="yes" xml:space="preserve">
          <source>Imports a style sheet from &lt;code&gt;url&lt;/code&gt;.</source>
          <target state="translated">从 &lt;code&gt;url&lt;/code&gt; 导入样式表。</target>
        </trans-unit>
        <trans-unit id="c4ad0c0cd3e499422f46a1d9968702d23884ac58" translate="yes" xml:space="preserve">
          <source>Imports a style sheet from &lt;code&gt;url&lt;/code&gt;. The resulting rules are directly added to the receiver. If you do not want the rules to become part of the receiver, create a new StyleSheet and use addStyleSheet to link it in.</source>
          <target state="translated">从 &lt;code&gt;url&lt;/code&gt; 导入样式表。生成的规则直接添加到接收器。如果您不希望规则成为接收者的一部分，请创建一个新的StyleSheet并使用addStyleSheet进行链接。</target>
        </trans-unit>
        <trans-unit id="d8049e75e7deb9a5b855f06e7154ee44499587ef" translate="yes" xml:space="preserve">
          <source>Imports all of the preferences represented by the XML document on the specified input stream.</source>
          <target state="translated">在指定的输入流上导入所有由XML文档表示的偏好。</target>
        </trans-unit>
        <trans-unit id="c71923291c8740cc76f9206ce1cdd5cb8964838b" translate="yes" xml:space="preserve">
          <source>Imports all of the preferences represented by the XML document on the specified input stream. The document may represent user preferences or system preferences. If it represents user preferences, the preferences will be imported into the calling user's preference tree (even if they originally came from a different user's preference tree). If any of the preferences described by the document inhabit preference nodes that do not exist, the nodes will be created.</source>
          <target state="translated">导入指定输入流上的XML文档所代表的所有偏好。该文档可以代表用户偏好,也可以代表系统偏好,如果它代表用户偏好,那么偏好将被导入到调用用户的偏好树中(即使它们最初来自不同的用户)。如果它代表了用户偏好,这些偏好将被导入到调用用户的偏好树中(即使它们最初来自不同用户的偏好树)。如果文档中描述的任何偏好占用了不存在的偏好节点,那么这些节点将被创建。</target>
        </trans-unit>
        <trans-unit id="7a226069a9c2b9c733fa93be074ddc8ebc8389b5" translate="yes" xml:space="preserve">
          <source>Imports the parameters from &lt;code&gt;params&lt;/code&gt; and decodes them according to the specified decoding format.</source>
          <target state="translated">从 &lt;code&gt;params&lt;/code&gt; 导入参数，并根据指定的解码格式对其进行解码。</target>
        </trans-unit>
        <trans-unit id="c3b5a559d458b855feabfd942350c4d64812e691" translate="yes" xml:space="preserve">
          <source>Imports the parameters from &lt;code&gt;params&lt;/code&gt; and decodes them according to the specified decoding format. If &lt;code&gt;format&lt;/code&gt; is null, the primary decoding format for parameters is used. The primary decoding format is ASN.1, if an ASN.1 specification for these parameters exists.</source>
          <target state="translated">从 &lt;code&gt;params&lt;/code&gt; 导入参数，并根据指定的解码格式对其进行解码。如果 &lt;code&gt;format&lt;/code&gt; 为null，则使用参数的主要解码格式。如果存在针对这些参数的ASN.1规范，则主要解码格式为ASN.1。</target>
        </trans-unit>
        <trans-unit id="b9528a5169d705e997248664b82ddd257d316162" translate="yes" xml:space="preserve">
          <source>Imports the parameters from &lt;code&gt;params&lt;/code&gt; and decodes them according to the specified decoding scheme.</source>
          <target state="translated">从 &lt;code&gt;params&lt;/code&gt; 中导入参数，并根据指定的解码方案对其进行解码。</target>
        </trans-unit>
        <trans-unit id="8daf910475ce86194cd83279397f2ce3ae7b465e" translate="yes" xml:space="preserve">
          <source>Imports the parameters from &lt;code&gt;params&lt;/code&gt; and decodes them according to the specified decoding scheme. If &lt;code&gt;format&lt;/code&gt; is null, the primary decoding format for parameters is used. The primary decoding format is ASN.1, if an ASN.1 specification for these parameters exists.</source>
          <target state="translated">从 &lt;code&gt;params&lt;/code&gt; 导入参数，并根据指定的解码方案对其进行解码。如果 &lt;code&gt;format&lt;/code&gt; 为null，则使用参数的主要解码格式。如果存在针对这些参数的ASN.1规范，则主要解码格式为ASN.1。</target>
        </trans-unit>
        <trans-unit id="22b4275a83eb032a3c18ec6f1903022b54365237" translate="yes" xml:space="preserve">
          <source>Imports the specified parameters and decodes them according to the primary decoding format for parameters.</source>
          <target state="translated">导入指定的参数,并根据参数的主要解码格式进行解码。</target>
        </trans-unit>
        <trans-unit id="9e1a8d9caf50a44dc7557cdf109bddec4a771f9e" translate="yes" xml:space="preserve">
          <source>Imports the specified parameters and decodes them according to the primary decoding format for parameters. The primary decoding format for parameters is ASN.1, if an ASN.1 specification for this type of parameters exists.</source>
          <target state="translated">导入指定的参数并根据参数的主要解码格式进行解码。如果有ASN.1规格的参数,则参数的主要解码格式为ASN.1。</target>
        </trans-unit>
        <trans-unit id="5db680fa20839f2707dc803343b2a35951c109b1" translate="yes" xml:space="preserve">
          <source>Imposes each consecutive pair of print-stream pages upon front and back sides of consecutive media sheets, such that the orientation of each pair of print-stream pages on the medium would be correct for the reader as if for binding on the long edge.</source>
          <target state="translated">将每一对连续的印刷流页面强加在连续的介质页的正反两面,使介质上每一对印刷流页面的方向对读者来说是正确的,就像在长边上装订一样。</target>
        </trans-unit>
        <trans-unit id="4d2c0bf8d32601bc858999c087909fdfb54b33dc" translate="yes" xml:space="preserve">
          <source>Imposes each consecutive pair of print-stream pages upon front and back sides of consecutive media sheets, such that the orientation of each pair of print-stream pages on the medium would be correct for the reader as if for binding on the long edge. This imposition is also known as &quot;duplex&quot; (see &lt;a href=&quot;#DUPLEX&quot;&gt;&lt;code&gt;DUPLEX&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">将每对连续的打印流页面强加在连续介质页的正面和背面上，以使介质上每对打印流页面的方向对于读者来说都是正确的，就好像在长边上装订一样。这种拼版也称为&amp;ldquo;双工&amp;rdquo;（请参见&lt;a href=&quot;#DUPLEX&quot;&gt; &lt;code&gt;DUPLEX&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="ebb09cb4d38a6b66afe6af78e3d1ad2ebf60b9fe" translate="yes" xml:space="preserve">
          <source>Imposes each consecutive pair of print-stream pages upon front and back sides of consecutive media sheets, such that the orientation of each pair of print-stream pages on the medium would be correct for the reader as if for binding on the long edge. This imposition is also known as &quot;duplex&quot; (see &lt;a href=&quot;sides#DUPLEX&quot;&gt;&lt;code&gt;DUPLEX&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">将每对连续的打印流页面强加在连续的介质纸的正面和背面上，以使介质上每对打印流页面的方向对于读者来说都是正确的，就好像在长边上装订一样。这种拼版也称为&amp;ldquo;双工&amp;rdquo;（请参见&lt;a href=&quot;sides#DUPLEX&quot;&gt; &lt;code&gt;DUPLEX&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="1f05e8edf660348d6f25a6c7698a3fed9d42d663" translate="yes" xml:space="preserve">
          <source>Imposes each consecutive pair of print-stream pages upon front and back sides of consecutive media sheets, such that the orientation of each pair of print-stream pages on the medium would be correct for the reader as if for binding on the short edge.</source>
          <target state="translated">将每一对连续的印刷流页面强加在连续的介质页的正反两面,使介质上每一对印刷流页面的方向对读者来说是正确的,就像在短边上装订一样。</target>
        </trans-unit>
        <trans-unit id="1aef01edddd4b2d9c074f505881ac04fe92598e9" translate="yes" xml:space="preserve">
          <source>Imposes each consecutive pair of print-stream pages upon front and back sides of consecutive media sheets, such that the orientation of each pair of print-stream pages on the medium would be correct for the reader as if for binding on the short edge. This imposition is also known as &quot;tumble&quot; (see &lt;a href=&quot;#TUMBLE&quot;&gt;&lt;code&gt;TUMBLE&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">将每对连续的打印流页面强加在连续介质页的正面和背面上，以使介质上每对打印流页面的方向对于读者来说都是正确的，就好像在短边上装订一样。这种强加也称为&amp;ldquo;翻转&amp;rdquo;（请参见&lt;a href=&quot;#TUMBLE&quot;&gt; &lt;code&gt;TUMBLE&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="54db18fccd287c2e1b6e20e055a1cdacd0a5564b" translate="yes" xml:space="preserve">
          <source>Imposes each consecutive pair of print-stream pages upon front and back sides of consecutive media sheets, such that the orientation of each pair of print-stream pages on the medium would be correct for the reader as if for binding on the short edge. This imposition is also known as &quot;tumble&quot; (see &lt;a href=&quot;sides#TUMBLE&quot;&gt;&lt;code&gt;TUMBLE&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">将每对连续的打印流页面强加在连续的介质纸的正面和背面上，以使介质上每对打印流页面的方向对于阅读器来说都是正确的，就好像在短边上装订一样。这种强加也称为&amp;ldquo;翻转&amp;rdquo;（请参见&lt;a href=&quot;sides#TUMBLE&quot;&gt; &lt;code&gt;TUMBLE&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="d2be57fb742356053fcc2d4484541e57728aa6dd" translate="yes" xml:space="preserve">
          <source>Imposes each consecutive print-stream page upon the same side of consecutive media sheets.</source>
          <target state="translated">将每个连续的打印流页面强加在连续介质页的同一侧。</target>
        </trans-unit>
        <trans-unit id="cecfaf1a15b7081e3c047943c8dccba7e77b2633" translate="yes" xml:space="preserve">
          <source>In 2008, time-zone offsets around the world extended from -12:00 to +14:00. To prevent any problems with that range being extended, yet still provide validation, the range of offsets is restricted to -18:00 to 18:00 inclusive.</source>
          <target state="translated">2008年,世界各地的时区偏移量从-12:00扩大到+14:00。为了防止因扩大时区范围而出现任何问题,但仍然提供验证,偏移量的范围限制在-18:00至18:00(含18:00)。</target>
        </trans-unit>
        <trans-unit id="86389704bee7bc2f2d5910700581356c0e5689e9" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;../format/resolverstyle#LENIENT&quot;&gt;lenient mode&lt;/a&gt;, only the week-based-year is validated against the range of valid values. If the day-of-week is outside the range 1 to 7, then the resulting date is adjusted by a suitable number of weeks to reduce the day-of-week to the range 1 to 7. If the week-of-week-based-year value is outside the range 1 to 52, then any excess weeks are added or subtracted from the resulting date.</source>
          <target state="translated">在&lt;a href=&quot;../format/resolverstyle#LENIENT&quot;&gt;宽松模式下&lt;/a&gt;，仅对基于周的年份进行有效值范围的验证。如果星期几不在1到7的范围内，则将日期调整适当的星期数，以将星期几减少到1到7的范围。基于年的值超出1到52的范围，则从结果日期中添加或减去任何多余的星期。</target>
        </trans-unit>
        <trans-unit id="f9e4a79de23768eb149fc2303c479b95439f491c" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;../format/resolverstyle#LENIENT&quot;&gt;lenient mode&lt;/a&gt;, only the year is validated against the range of valid values. The resulting date is calculated equivalent to the following three stage approach. First, create a date on the first of January in the requested year. Then take the quarter-of-year, subtract one, and add the amount in quarters to the date. Finally, take the day-of-quarter, subtract one, and add the amount in days to the date.</source>
          <target state="translated">在&lt;a href=&quot;../format/resolverstyle#LENIENT&quot;&gt;宽大模式下&lt;/a&gt;，仅在有效值范围内验证年份。计算得出的日期等效于以下三个阶段的方法。首先，在要求的年份的1月1日创建一个日期。然后取一年的四分之一，减去一，然后将四分之一的金额添加到日期。最后，取一季度的天数，减去一，然后将天数加到日期中。</target>
        </trans-unit>
        <trans-unit id="cd6ec172c1edc269b53c0583f46c3f095ab84cae" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;../format/resolverstyle#LENIENT&quot;&gt;lenient mode&lt;/a&gt;, the year and day-of-week are validated against the range of valid values. The resulting date is calculated equivalent to the following four stage approach. First, create a date on the first day of the first week of January in the requested year. Then take the month-of-year, subtract one, and add the amount in months to the date. Then take the week-of-month, subtract one, and add the amount in weeks to the date. Finally, adjust to the correct day-of-week within the localized week.</source>
          <target state="translated">在&lt;a href=&quot;../format/resolverstyle#LENIENT&quot;&gt;宽大模式下&lt;/a&gt;，将根据有效值的范围验证年和星期几。计算得出的日期等效于以下四个阶段的方法。首先，在请求的年份的1月的第一周的第一天的第一天创建日期。然后取一年中的月份，减去一个，然后将月份中的金额加到日期中。然后以每月的星期为单位，减去一个，然后将以周为单位的金额添加到日期中。最后，在本地化周内调整为正确的星期几。</target>
        </trans-unit>
        <trans-unit id="4e3729f6e6efd6616dbdd65aa7497b7c86a2f948" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;../format/resolverstyle#LENIENT&quot;&gt;lenient mode&lt;/a&gt;, the year and day-of-week are validated against the range of valid values. The resulting date is calculated equivalent to the following three stage approach. First, create a date on the first day of the first week in the requested week-based-year. Then take the week-of-week-based-year, subtract one, and add the amount in weeks to the date. Finally, adjust to the correct day-of-week within the localized week.</source>
          <target state="translated">在&lt;a href=&quot;../format/resolverstyle#LENIENT&quot;&gt;宽大模式下&lt;/a&gt;，将根据有效值的范围验证年和星期几。计算得出的日期等效于以下三个阶段的方法。首先，在要求的以周为基础的年中的第一周的第一天创建日期。然后，以周为基础的年份，减去一年，然后将以周为单位的金额添加到日期。最后，在本地化周内调整为正确的星期几。</target>
        </trans-unit>
        <trans-unit id="59cdf6f2f16e3f4bbc8085642ff9ed4c512d12dd" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;../format/resolverstyle#LENIENT&quot;&gt;lenient mode&lt;/a&gt;, the year and day-of-week are validated against the range of valid values. The resulting date is calculated equivalent to the following three stage approach. First, create a date on the first day of the first week in the requested year. Then take the week-of-year, subtract one, and add the amount in weeks to the date. Finally, adjust to the correct day-of-week within the localized week.</source>
          <target state="translated">在&lt;a href=&quot;../format/resolverstyle#LENIENT&quot;&gt;宽大模式下&lt;/a&gt;，将根据有效值的范围验证年和星期几。计算得出的日期等效于以下三个阶段的方法。首先，在请求年份的第一周的第一天创建日期。然后取一年中的一周，减去一个，然后将以周为单位的金额添加到日期中。最后，在本地化周内调整为正确的星期几。</target>
        </trans-unit>
        <trans-unit id="0fb07a317c3eaba0aff1f9dde717867e0b71ef5e" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;../format/resolverstyle#SMART&quot;&gt;smart mode&lt;/a&gt;, all four fields are validated against their range of valid values. The week-of-month field is validated from 0 to 6, meaning that the resulting date can be in a different month to that specified.</source>
          <target state="translated">在&lt;a href=&quot;../format/resolverstyle#SMART&quot;&gt;智能模式下&lt;/a&gt;，将对四个字段的有效值范围进行验证。每月的星期几字段的验证范围是0到6，这意味着结果日期可以与指定的日期不同。</target>
        </trans-unit>
        <trans-unit id="8e475c8cf450e0722c0f73724f68b49888b78026" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;../format/resolverstyle#SMART&quot;&gt;smart mode&lt;/a&gt;, all three fields are validated against their range of valid values. The day-of-quarter field is validated between 1 and 92, ignoring the actual range based on the year and quarter. If the day-of-quarter exceeds the actual range by one day, then the resulting date is one day later. If the day-of-quarter exceeds the actual range by two days, then the resulting date is two days later.</source>
          <target state="translated">在&lt;a href=&quot;../format/resolverstyle#SMART&quot;&gt;智能模式下&lt;/a&gt;，将针对这三个字段的有效值范围进行验证。&amp;ldquo;季度日期&amp;rdquo;字段在1到92之间验证，而忽略了基于年份和季度的实际范围。如果季度日期超出实际范围一天，则结果日期将是一天之后。如果季度日期超出实际范围两天，则结果日期将是两天后。</target>
        </trans-unit>
        <trans-unit id="48298e99d0fc04b4dade93a7fa8a98aa3f5d9136" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;../format/resolverstyle#SMART&quot;&gt;smart mode&lt;/a&gt;, all three fields are validated against their range of valid values. The week-of-week-based-year field is validated between 1 and 53, ignoring the week-based-year. If the week-of-week-based-year is 53, but the week-based-year only has 52 weeks, then the resulting date is in week 1 of the following week-based-year.</source>
          <target state="translated">在&lt;a href=&quot;../format/resolverstyle#SMART&quot;&gt;智能模式下&lt;/a&gt;，将针对这三个字段的有效值范围进行验证。在1到53之间验证基于周的年字段，而忽略基于周的年。如果以周为基础的年份为53，但以周为基础的年份只有52周，则结果日期位于下一个以周为基础的年份的第1周。</target>
        </trans-unit>
        <trans-unit id="78349302167faa6d7a2aed1df47448ca5048b25d" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;../format/resolverstyle#SMART&quot;&gt;smart mode&lt;/a&gt;, all three fields are validated against their range of valid values. The week-of-week-based-year field is validated from 1 to 53, meaning that the resulting date can be in the following week-based-year to that specified.</source>
          <target state="translated">在&lt;a href=&quot;../format/resolverstyle#SMART&quot;&gt;智能模式下&lt;/a&gt;，将针对这三个字段的有效值范围进行验证。以周为基础的年份字段从1到53进​​行验证，这意味着结果日期可以是指定日期之后的以周为基础的年份。</target>
        </trans-unit>
        <trans-unit id="f232305a5c1e15ea107e37a90c2ece7913724549" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;../format/resolverstyle#SMART&quot;&gt;smart mode&lt;/a&gt;, all three fields are validated against their range of valid values. The week-of-year field is validated from 0 to 54, meaning that the resulting date can be in a different year to that specified.</source>
          <target state="translated">在&lt;a href=&quot;../format/resolverstyle#SMART&quot;&gt;智能模式下&lt;/a&gt;，将针对这三个字段的有效值范围进行验证。每年的星期几字段的验证范围是0到54，这意味着结果日期可以与指定的日期不同。</target>
        </trans-unit>
        <trans-unit id="92aff29473ae74aa918cfecc94d38303412532e6" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;../format/resolverstyle#STRICT&quot;&gt;strict mode&lt;/a&gt;, all four fields are validated against their range of valid values. The week-of-month field is validated to ensure that the resulting month is the month requested.</source>
          <target state="translated">在&lt;a href=&quot;../format/resolverstyle#STRICT&quot;&gt;严格模式下&lt;/a&gt;，将针对所有四个字段的有效值范围进行验证。验证&amp;ldquo;星期几&amp;rdquo;字段以确保结果月份是请求的月份。</target>
        </trans-unit>
        <trans-unit id="0f0e202932cebbe8a155bd934de772f0860489c8" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;../format/resolverstyle#STRICT&quot;&gt;strict mode&lt;/a&gt;, all three fields are validated against their range of valid values. The day-of-quarter field is validated from 1 to 90, 91 or 92 depending on the year and quarter.</source>
          <target state="translated">在&lt;a href=&quot;../format/resolverstyle#STRICT&quot;&gt;严格模式下&lt;/a&gt;，将针对这三个字段的有效值范围进行验证。季度日期字段的验证范围是1到90、91或92，具体取决于年份和季度。</target>
        </trans-unit>
        <trans-unit id="61038d4b8c7da66e5b7168e9d72153f9f95dd9b8" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;../format/resolverstyle#STRICT&quot;&gt;strict mode&lt;/a&gt;, all three fields are validated against their range of valid values. The week-of-week-based-year field is validated from 1 to 52 or 53 depending on the week-based-year.</source>
          <target state="translated">在&lt;a href=&quot;../format/resolverstyle#STRICT&quot;&gt;严格模式下&lt;/a&gt;，将针对这三个字段的有效值范围进行验证。根据周基准年，将周有效周字段验证为1到52或53。</target>
        </trans-unit>
        <trans-unit id="6c209b717e4718fb111069dea4a3876d7d3d886e" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;../format/resolverstyle#STRICT&quot;&gt;strict mode&lt;/a&gt;, all three fields are validated against their range of valid values. The week-of-year field is validated to ensure that the resulting week-based-year is the week-based-year requested.</source>
          <target state="translated">在&lt;a href=&quot;../format/resolverstyle#STRICT&quot;&gt;严格模式下&lt;/a&gt;，将针对这三个字段的有效值范围进行验证。验证&amp;ldquo;年度周&amp;rdquo;字段以确保所得的基于周的年是请求的基于周的年。</target>
        </trans-unit>
        <trans-unit id="0e3442bcb8b50ab377f46533d2cb10831695feee" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;../format/resolverstyle#STRICT&quot;&gt;strict mode&lt;/a&gt;, all three fields are validated against their range of valid values. The week-of-year field is validated to ensure that the resulting year is the year requested.</source>
          <target state="translated">在&lt;a href=&quot;../format/resolverstyle#STRICT&quot;&gt;严格模式下&lt;/a&gt;，将针对这三个字段的有效值范围进行验证。验证年度字段以确保得出的年份为要求的年份。</target>
        </trans-unit>
        <trans-unit id="94d0612798926c7af8d39f4a4589255d75a064c6" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;threadpoolexecutor.callerrunspolicy&quot;&gt;&lt;code&gt;ThreadPoolExecutor.CallerRunsPolicy&lt;/code&gt;&lt;/a&gt;, the thread that invokes &lt;code&gt;execute&lt;/code&gt; itself runs the task. This provides a simple feedback control mechanism that will slow down the rate that new tasks are submitted.</source>
          <target state="translated">在&lt;a href=&quot;threadpoolexecutor.callerrunspolicy&quot;&gt; &lt;code&gt;ThreadPoolExecutor.CallerRunsPolicy&lt;/code&gt; 中&lt;/a&gt;，调用 &lt;code&gt;execute&lt;/code&gt; 自己的线程运行任务。这提供了一种简单的反馈控制机制，将降低新任务的提交速度。</target>
        </trans-unit>
        <trans-unit id="cb2aef34e8541d620db480296296a5005b0d8ebb" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;threadpoolexecutor.discardoldestpolicy&quot;&gt;&lt;code&gt;ThreadPoolExecutor.DiscardOldestPolicy&lt;/code&gt;&lt;/a&gt;, if the executor is not shut down, the task at the head of the work queue is dropped, and then execution is retried (which can fail again, causing this to be repeated.)</source>
          <target state="translated">在&lt;a href=&quot;threadpoolexecutor.discardoldestpolicy&quot;&gt; &lt;code&gt;ThreadPoolExecutor.DiscardOldestPolicy&lt;/code&gt; 中&lt;/a&gt;，如果未关闭执行程序，则将丢弃工作队列开头的任务，然后重试执行（该操作可能再次失败，导致重复执行此操作）。</target>
        </trans-unit>
        <trans-unit id="c8f191d695cda03baf1111a2194130a680c23105" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;threadpoolexecutor.discardpolicy&quot;&gt;&lt;code&gt;ThreadPoolExecutor.DiscardPolicy&lt;/code&gt;&lt;/a&gt;, a task that cannot be executed is simply dropped.</source>
          <target state="translated">在&lt;a href=&quot;threadpoolexecutor.discardpolicy&quot;&gt; &lt;code&gt;ThreadPoolExecutor.DiscardPolicy&lt;/code&gt; 中&lt;/a&gt;，简单地删除了无法执行的任务。</target>
        </trans-unit>
        <trans-unit id="6a15117b6493b903456265f081034d8302acd07d" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;HORIZONTAL_WRAP&lt;/code&gt; and &lt;code&gt;VERTICAL_WRAP&lt;/code&gt; orientations:</source>
          <target state="translated">在 &lt;code&gt;HORIZONTAL_WRAP&lt;/code&gt; 和 &lt;code&gt;VERTICAL_WRAP&lt;/code&gt; 方向上：</target>
        </trans-unit>
        <trans-unit id="657094c86ed548da67d27b0e04ccf6a2d6ee6e00" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;PrintMode.NORMAL&lt;/code&gt; when a column is too wide to fit in the printable area -- print the center portion of the column and leave the left and right borders off the table.</source>
          <target state="translated">在 &lt;code&gt;PrintMode.NORMAL&lt;/code&gt; 中,当一列太宽而无法容纳在可打印区域中时，请打印该列的中心部分，并在表格的左边框和右边框之外留下空白。</target>
        </trans-unit>
        <trans-unit id="77ab4acd6e3939d9de1d113380fbf9c5a2f82c8c" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;SINGLE_INTERVAL_SELECTION&lt;/code&gt; selection mode, if the removal would produce two disjoint selections, the removal is extended through the greater end of the selection. For example, if the selection is &lt;code&gt;0-10&lt;/code&gt; and you supply indices &lt;code&gt;5,6&lt;/code&gt; (in any order) the resulting selection is &lt;code&gt;0-4&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;SINGLE_INTERVAL_SELECTION&lt;/code&gt; 选择模式下，如果删除将产生两个不相交的选择，则删除将扩展到选择的较大端。例如，如果选择为 &lt;code&gt;0-10&lt;/code&gt; 且您提供索引 &lt;code&gt;5,6&lt;/code&gt; （以任何顺序），则结果选择为 &lt;code&gt;0-4&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aece51993e01377983c7d1ade636af0247e43c89" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;SINGLE_SELECTION&lt;/code&gt; selection mode, only the second index is used.</source>
          <target state="translated">在 &lt;code&gt;SINGLE_SELECTION&lt;/code&gt; 选择模式下，仅使用第二个索引。</target>
        </trans-unit>
        <trans-unit id="d06087fed3dfc62f5a68adee13608ed1d4cf33b1" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;SINGLE_SELECTION&lt;/code&gt; selection mode, this is equivalent to calling &lt;code&gt;setSelectionInterval&lt;/code&gt;, and only the second index is used. In &lt;code&gt;SINGLE_INTERVAL_SELECTION&lt;/code&gt; selection mode, this method behaves like &lt;code&gt;setSelectionInterval&lt;/code&gt;, unless the given interval is immediately adjacent to or overlaps the existing selection, and can therefore be used to grow it.</source>
          <target state="translated">在 &lt;code&gt;SINGLE_SELECTION&lt;/code&gt; 选择模式下，这等效于调用 &lt;code&gt;setSelectionInterval&lt;/code&gt; ，并且仅使用第二个索引。在 &lt;code&gt;SINGLE_INTERVAL_SELECTION&lt;/code&gt; 选择模式下，此方法的行为类似于 &lt;code&gt;setSelectionInterval&lt;/code&gt; ，除非给定的时间间隔紧邻现有选择或与现有选择重叠，因此可以用于扩大选择范围。</target>
        </trans-unit>
        <trans-unit id="df3c016e449ce26f1586e36d7017736782ea197d" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;SINGLE_SELECTION&lt;/code&gt; selection mode, this is equivalent to calling &lt;code&gt;setSelectionInterval&lt;/code&gt;, and only the second index is used. In &lt;code&gt;SINGLE_INTERVAL_SELECTION&lt;/code&gt; selection mode, this method behaves like &lt;code&gt;setSelectionInterval&lt;/code&gt;, unless the given interval is immediately adjacent to or overlaps the existing selection, and can therefore be used to grow the selection.</source>
          <target state="translated">在 &lt;code&gt;SINGLE_SELECTION&lt;/code&gt; 选择模式下，这等效于调用 &lt;code&gt;setSelectionInterval&lt;/code&gt; ，并且仅使用第二个索引。在 &lt;code&gt;SINGLE_INTERVAL_SELECTION&lt;/code&gt; 选择模式下，此方法的行为类似于 &lt;code&gt;setSelectionInterval&lt;/code&gt; ，除非给定的时间间隔紧邻现有选择或与现有选择重叠，因此可以用于扩展选择。</target>
        </trans-unit>
        <trans-unit id="a254052d2946ad1ebd808cc9b17d1d7fc3e2c385" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;VERTICAL&lt;/code&gt; orientation:</source>
          <target state="translated">在 &lt;code&gt;VERTICAL&lt;/code&gt; 方向上：</target>
        </trans-unit>
        <trans-unit id="0564ee6a70dbf13f614fae05c50df5afc450037f" translate="yes" xml:space="preserve">
          <source>In Beans 1.0 the given name can indicate either a serialized object or a class. Other mechanisms may be added in the future. In beans 1.0 we first try to treat the beanName as a serialized object name then as a class name.</source>
          <target state="translated">在Beans 1.0中,给定的名称可以表示一个序列化对象,也可以表示一个类。未来可能会添加其他机制。在 beans 1.0 中,我们首先尝试将 beanName 作为一个序列化对象的名称,然后再作为一个类的名称。</target>
        </trans-unit>
        <trans-unit id="042c75bc8038a7bfe93454be2f4ccc7544315dc7" translate="yes" xml:space="preserve">
          <source>In InetAddress and Inet6Address, it is used for internal representation; it has no functional role. Java will never return an IPv4-mapped address. These classes can take an IPv4-mapped address as input, both in byte array and text representation. However, it will be converted into an IPv4 address.</source>
          <target state="translated">在InetAddress和Inet6Address中,它用于内部表示,它没有功能作用。Java永远不会返回一个IPv4映射的地址。这些类可以接受一个IPv4映射的地址作为输入,无论是字节数组还是文本表示。但是,它将被转换为IPv4地址。</target>
        </trans-unit>
        <trans-unit id="91a3386d3d8e0fe925a78b33bc378a60b9ea79c5" translate="yes" xml:space="preserve">
          <source>In JAR files, all file names must be encoded in the UTF-8 encoding.</source>
          <target state="translated">在JAR文件中,所有的文件名必须用UTF-8编码。</target>
        </trans-unit>
        <trans-unit id="014f1fa7c567eb71497930106403f0d11979f4bc" translate="yes" xml:space="preserve">
          <source>In JNDI, all naming and directory operations are performed relative to a context. There are no absolute roots. Therefore JNDI defines an &lt;em&gt;initial context&lt;/em&gt;, &lt;code&gt;InitialContext&lt;/code&gt;, which provides a starting point for naming and directory operations. Once you have an initial context, you can use it to look up other contexts and objects.</source>
          <target state="translated">在JNDI中，所有命名和目录操作都是相对于上下文执行的。没有绝对的根源。因此JNDI限定&lt;em&gt;初始上下文&lt;/em&gt;， &lt;code&gt;InitialContext&lt;/code&gt; 的，它提供了一个起点命名和目录操作。一旦有了初始上下文，就可以使用它来查找其他上下文和对象。</target>
        </trans-unit>
        <trans-unit id="79426411ad6360c359271abac5b6331b8b48b7e0" translate="yes" xml:space="preserve">
          <source>In Java Sound, &lt;code&gt;MidiEvent&lt;/code&gt; objects are typically contained in a &lt;a href=&quot;track&quot;&gt;&lt;code&gt;Track&lt;/code&gt;&lt;/a&gt;, and &lt;code&gt;Tracks&lt;/code&gt; are likewise contained in a &lt;code&gt;Sequence&lt;/code&gt;.</source>
          <target state="translated">在Java Sound中， &lt;code&gt;MidiEvent&lt;/code&gt; 对象通常包含在&lt;a href=&quot;track&quot;&gt; &lt;code&gt;Track&lt;/code&gt; 中&lt;/a&gt;，而 &lt;code&gt;Tracks&lt;/code&gt; 同样包含在 &lt;code&gt;Sequence&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="13209128b680b3afe374b6116423184d3647e46c" translate="yes" xml:space="preserve">
          <source>In Java Sound, &lt;code&gt;MidiEvent&lt;/code&gt; objects are typically contained in a &lt;code&gt;&lt;a href=&quot;track&quot;&gt;&lt;code&gt;Track&lt;/code&gt;&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;Tracks&lt;/code&gt; are likewise contained in a &lt;code&gt;Sequence&lt;/code&gt;.</source>
          <target state="translated">在Java Sound中， &lt;code&gt;MidiEvent&lt;/code&gt; 对象通常包含在 &lt;code&gt;&lt;a href=&quot;track&quot;&gt;&lt;code&gt;Track&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; 中，而 &lt;code&gt;Tracks&lt;/code&gt; 同样包含在 &lt;code&gt;Sequence&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="fe5a504b5bd5d313a777bae81479bb507e440e57" translate="yes" xml:space="preserve">
          <source>In Java Sound, however, a &lt;code&gt;Synthesizer&lt;/code&gt; class can expose the contents of its voices through its &lt;a href=&quot;synthesizer#getVoiceStatus()&quot;&gt;&lt;code&gt;getVoiceStatus()&lt;/code&gt;&lt;/a&gt; method. This behavior is recommended but optional; synthesizers that don't expose their voice allocation simply return a zero-length array. A &lt;code&gt;Synthesizer&lt;/code&gt; that does report its voice status should maintain this information at all times for all of its voices, whether they are currently sounding or not. In other words, a given type of &lt;code&gt;Synthesizer&lt;/code&gt; always has a fixed number of voices, equal to the maximum number of simultaneous notes it is capable of sounding.</source>
          <target state="translated">但是，在Java Sound中， &lt;code&gt;Synthesizer&lt;/code&gt; 类可以通过其&lt;a href=&quot;synthesizer#getVoiceStatus()&quot;&gt; &lt;code&gt;getVoiceStatus()&lt;/code&gt; &lt;/a&gt;方法公开其声音的内容。此行为是建议的，但是可选的；不公开语音分配的合成器仅返回零长度的数组。一个 &lt;code&gt;Synthesizer&lt;/code&gt; ，做报告其声音状态应该时刻保持信息的所有的声音，无论是当前发声与否。换句话说，给定类型的 &lt;code&gt;Synthesizer&lt;/code&gt; 始终具有固定数量的声音，等于其能够发声的同时发声的最大数量。</target>
        </trans-unit>
        <trans-unit id="98331511b3ce4c496aa8e2ac58efd2c1a6a50995" translate="yes" xml:space="preserve">
          <source>In Java Sound, however, a &lt;code&gt;Synthesizer&lt;/code&gt; class can expose the contents of its voices through its &lt;a href=&quot;synthesizer#getVoiceStatus--&quot;&gt;&lt;code&gt;getVoiceStatus()&lt;/code&gt;&lt;/a&gt; method. This behavior is recommended but optional; synthesizers that don't expose their voice allocation simply return a zero-length array. A &lt;code&gt;Synthesizer&lt;/code&gt; that does report its voice status should maintain this information at all times for all of its voices, whether they are currently sounding or not. In other words, a given type of &lt;code&gt;Synthesizer&lt;/code&gt; always has a fixed number of voices, equal to the maximum number of simultaneous notes it is capable of sounding.</source>
          <target state="translated">但是，在Java Sound中， &lt;code&gt;Synthesizer&lt;/code&gt; 类可以通过其&lt;a href=&quot;synthesizer#getVoiceStatus--&quot;&gt; &lt;code&gt;getVoiceStatus()&lt;/code&gt; &lt;/a&gt;方法公开其声音的内容。此行为是建议的，但是可选的；不公开语音分配的合成器仅返回零长度的数组。一个 &lt;code&gt;Synthesizer&lt;/code&gt; ，做报告其声音状态应该时刻保持信息的所有的声音，无论是当前发声与否。换句话说，给定类型的 &lt;code&gt;Synthesizer&lt;/code&gt; 始终具有固定数量的声音，等于其能够发声的同时发声的最大数量。</target>
        </trans-unit>
        <trans-unit id="7717ad4c43dc4f90b8dc37532fbf48149788e4e0" translate="yes" xml:space="preserve">
          <source>In June of 1996, the basic X.509 v3 format was completed by ISO/IEC and ANSI X9, which is described below in ASN.1:</source>
          <target state="translated">1996年6月,ISO/IEC和ANSI X9完成了X.509 v3的基本格式,下面在ASN.1中介绍。</target>
        </trans-unit>
        <trans-unit id="bd04fce7fa942ea18d8a8670f1b727e68adbc514" translate="yes" xml:space="preserve">
          <source>In Open MBeans, attributes and parameters can have default values and/or constraints associated with them in the &lt;code&gt;
      OpenMBeanAttributeInfo&lt;/code&gt; or &lt;code&gt;OpenMBeanParameterInfo&lt;/code&gt;. There are two ways to specify these constraints. Either the values are directly specified as parameters to one of the constructors of &lt;code&gt;OpenMBeanAttributeInfoSupport&lt;/code&gt; or &lt;code&gt;OpenMBeanParameterInfoSupport&lt;/code&gt;, for example &lt;a href=&quot;openmbeanparameterinfosupport#%3Cinit%3E(java.lang.String,java.lang.String,javax.management.openmbean.OpenType,T,T%5B%5D)&quot;&gt;&lt;code&gt;OpenMBeanParameterInfoSupport(
      String, String, OpenType, Object, Object[])&lt;/code&gt;&lt;/a&gt;; or the values are specified in a &lt;a href=&quot;../descriptor&quot;&gt;&lt;code&gt;Descriptor&lt;/code&gt;&lt;/a&gt; given as a parameter to one of the constructors.</source>
          <target state="translated">在Open MBean中，属性和参数可以在 &lt;code&gt; OpenMBeanAttributeInfo&lt;/code&gt; 或 &lt;code&gt;OpenMBeanParameterInfo&lt;/code&gt; 中具有默认值和/或与它们关联的约束。有两种方法可以指定这些约束。可以将这些值直接指定为 &lt;code&gt;OpenMBeanAttributeInfoSupport&lt;/code&gt; 或 &lt;code&gt;OpenMBeanParameterInfoSupport&lt;/code&gt; 的构造函数之一的参数，例如&lt;a href=&quot;openmbeanparameterinfosupport#%3Cinit%3E(java.lang.String,java.lang.String,javax.management.openmbean.OpenType,T,T%5B%5D)&quot;&gt; &lt;code&gt;OpenMBeanParameterInfoSupport( String, String, OpenType, Object, Object[])&lt;/code&gt; &lt;/a&gt; ; 或在&lt;a href=&quot;../descriptor&quot;&gt; &lt;code&gt;Descriptor&lt;/code&gt; &lt;/a&gt;中指定值，这些描述符作为参数之一提供给构造函数。</target>
        </trans-unit>
        <trans-unit id="0cd5532b3248e413385cbfc9fc717eba269294fb" translate="yes" xml:space="preserve">
          <source>In Open MBeans, attributes and parameters can have default values and/or constraints associated with them in the &lt;code&gt;OpenMBeanAttributeInfo&lt;/code&gt; or &lt;code&gt;OpenMBeanParameterInfo&lt;/code&gt;. There are two ways to specify these constraints. Either the values are directly specified as parameters to one of the constructors of &lt;code&gt;OpenMBeanAttributeInfoSupport&lt;/code&gt; or &lt;code&gt;OpenMBeanParameterInfoSupport&lt;/code&gt;, for example &lt;a href=&quot;openmbeanparameterinfosupport#OpenMBeanParameterInfoSupport-java.lang.String-java.lang.String-javax.management.openmbean.OpenType-T-T:A-&quot;&gt;&lt;code&gt;OpenMBeanParameterInfoSupport.OpenMBeanParameterInfoSupport(
      String, String, OpenType, Object, Object[])&lt;/code&gt;&lt;/a&gt;; or the values are specified in a &lt;a href=&quot;../descriptor&quot;&gt;&lt;code&gt;Descriptor&lt;/code&gt;&lt;/a&gt; given as a parameter to one of the constructors.</source>
          <target state="translated">在Open MBean中，属性和参数可以在 &lt;code&gt;OpenMBeanAttributeInfo&lt;/code&gt; 或 &lt;code&gt;OpenMBeanParameterInfo&lt;/code&gt; 中具有默认值和/或与它们关联的约束。有两种方法可以指定这些约束。可以将值直接指定为 &lt;code&gt;OpenMBeanAttributeInfoSupport&lt;/code&gt; 或 &lt;code&gt;OpenMBeanParameterInfoSupport&lt;/code&gt; 的构造函数之一的参数，例如&lt;a href=&quot;openmbeanparameterinfosupport#OpenMBeanParameterInfoSupport-java.lang.String-java.lang.String-javax.management.openmbean.OpenType-T-T:A-&quot;&gt; &lt;code&gt;OpenMBeanParameterInfoSupport.OpenMBeanParameterInfoSupport( String, String, OpenType, Object, Object[])&lt;/code&gt; &lt;/a&gt; ;或在&lt;a href=&quot;../descriptor&quot;&gt; &lt;code&gt;Descriptor&lt;/code&gt; &lt;/a&gt;中指定值，这些描述符作为参数之一提供给构造函数。</target>
        </trans-unit>
        <trans-unit id="57742fea34c047c7946636e9200af85a7134f451" translate="yes" xml:space="preserve">
          <source>In Perl, &lt;code&gt;\1&lt;/code&gt; through &lt;code&gt;\9&lt;/code&gt; are always interpreted as back references; a backslash-escaped number greater than &lt;code&gt;9&lt;/code&gt; is treated as a back reference if at least that many subexpressions exist, otherwise it is interpreted, if possible, as an octal escape. In this class octal escapes must always begin with a zero. In this class, &lt;code&gt;\1&lt;/code&gt; through &lt;code&gt;\9&lt;/code&gt; are always interpreted as back references, and a larger number is accepted as a back reference if at least that many subexpressions exist at that point in the regular expression, otherwise the parser will drop digits until the number is smaller or equal to the existing number of groups or it is one digit.</source>
          <target state="translated">在Perl中， &lt;code&gt;\1&lt;/code&gt; 到 &lt;code&gt;\9&lt;/code&gt; 始终被解释为反向引用；如果至少存在许多子表达式，则大于 &lt;code&gt;9&lt;/code&gt; 的反斜杠转义数字将被视为反向引用，否则，如果可能，将其解释为八进制转义。在此类中，八进制转义必须始终以零开头。在此类中， &lt;code&gt;\1&lt;/code&gt; 到 &lt;code&gt;\9&lt;/code&gt; 始终被解释为反向引用，并且如果正则表达式中至少在那个点存在许多子表达式，则接受更大的数字作为反向引用，否则解析器将丢弃数字直到该数字小于或等于现有组数，或者是一位数字。</target>
        </trans-unit>
        <trans-unit id="4d1565310b4b37e62e7a911cfa4fcf890fef7d66" translate="yes" xml:space="preserve">
          <source>In Perl, embedded flags at the top level of an expression affect the whole expression. In this class, embedded flags always take effect at the point at which they appear, whether they are at the top level or within a group; in the latter case, flags are restored at the end of the group just as in Perl.</source>
          <target state="translated">在Perl中,一个表达式顶层的嵌入标志会影响整个表达式。在这个类中,嵌入的标志总是在它们出现的地方生效,无论它们是在顶层还是在一个组中;在后一种情况下,标志会像在Perl中一样在组的末尾恢复。</target>
        </trans-unit>
        <trans-unit id="45254eb83c7215694144dea45c11035bc6d7f671" translate="yes" xml:space="preserve">
          <source>In SQL, a result table is retrieved through a cursor that is named. The current row of a result set can be updated or deleted using a positioned update/delete statement that references the cursor name. To insure that the cursor has the proper isolation level to support update, the cursor's &lt;code&gt;SELECT&lt;/code&gt; statement should be of the form &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt;. If &lt;code&gt;FOR UPDATE&lt;/code&gt; is omitted, the positioned updates may fail.</source>
          <target state="translated">在SQL中，通过命名的游标检索结果表。可以使用引用游标名称的定位更新/删除语句来更新或删除结果集的当前行。为了确保游标具有适当的隔离级别以支持更新，游标的 &lt;code&gt;SELECT&lt;/code&gt; 语句应采用 &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; 的形式。如果省略 &lt;code&gt;FOR UPDATE&lt;/code&gt; ，则定位的更新可能会失败。</target>
        </trans-unit>
        <trans-unit id="3b570462cd79d760be3948904adcdedf1d492b06" translate="yes" xml:space="preserve">
          <source>In SSL, sessions are used to describe an ongoing relationship between two entities.</source>
          <target state="translated">在SSL中,会话用于描述两个实体之间的持续关系。</target>
        </trans-unit>
        <trans-unit id="1ff794ab8aeeb7f642a324d3b35b851cc6c68096" translate="yes" xml:space="preserve">
          <source>In SSL, sessions are used to describe an ongoing relationship between two entities. Each SSL connection involves one session at a time, but that session may be used on many connections between those entities, simultaneously or sequentially. The session used on a connection may also be replaced by a different session. Sessions are created, or rejoined, as part of the SSL handshaking protocol. Sessions may be invalidated due to policies affecting security or resource usage, or by an application explicitly calling &lt;code&gt;invalidate&lt;/code&gt;. Session management policies are typically used to tune performance.</source>
          <target state="translated">在SSL中，会话用于描述两个实体之间的持续关系。每个SSL连接一次涉及一个会话，但是该会话可以同时或顺序用于这些实体之间的许多连接。连接上使用的会话也可以由其他会话代替。会话是作为SSL握手协议的一部分创建或重新加入的。可能由于影响安全性或资源使用的策略或通过显式调用 &lt;code&gt;invalidate&lt;/code&gt; 的应用程序使会话无效。会话管理策略通常用于调整性​​能。</target>
        </trans-unit>
        <trans-unit id="dacc622167500cd916a0808c821aecd15f9adae6" translate="yes" xml:space="preserve">
          <source>In XML, this is described by the &lt;code&gt;modifyRow&lt;/code&gt; tag. Both the original and new values are contained within the tag for original row tracking purposes.</source>
          <target state="translated">在XML中，这由 &lt;code&gt;modifyRow&lt;/code&gt; 标记描述。标记中包含原始值和新值，以进行原始行跟踪。</target>
        </trans-unit>
        <trans-unit id="4d1efbff85d860f1baeae7205b1916956c1776cb" translate="yes" xml:space="preserve">
          <source>In XML, where the value of an attribute can contain entity references, the child nodes of the &lt;code&gt;Attr&lt;/code&gt; node may be either &lt;code&gt;Text&lt;/code&gt; or &lt;code&gt;EntityReference&lt;/code&gt; nodes (when these are in use; see the description of &lt;code&gt;EntityReference&lt;/code&gt; for discussion).</source>
          <target state="translated">在XML中，属性的值可以包含实体引用，而 &lt;code&gt;Attr&lt;/code&gt; 节点的子节点可以是 &lt;code&gt;Text&lt;/code&gt; 或 &lt;code&gt;EntityReference&lt;/code&gt; 节点（使用它们时；请参见 &lt;code&gt;EntityReference&lt;/code&gt; 的描述以进行讨论）。</target>
        </trans-unit>
        <trans-unit id="89a3d9e997a1741012b57bb389e6d0d560cfaf98" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;SpringLayout&lt;/code&gt;, the position of each edge is dependent on the position of just one other edge. If a constraint is subsequently added to create a new binding for an edge, the previous binding is discarded and the edge remains dependent on a single edge. Springs should only be attached between edges of the container and its immediate children; the behavior of the &lt;code&gt;SpringLayout&lt;/code&gt; when presented with constraints linking the edges of components from different containers (either internal or external) is undefined.</source>
          <target state="translated">在 &lt;code&gt;SpringLayout&lt;/code&gt; 中，每个边的位置仅取决于另一个边的位置。如果随后添加了约束以为边创建新的绑定，则先前的绑定将被丢弃，并且该边仍然依赖于单个边。弹簧仅应连接在容器边缘与其直接子容器之间；当 &lt;code&gt;SpringLayout&lt;/code&gt; 出现约束链接来自不同容器（内部或外部）的组件边缘的约束时，其行为是不确定的。</target>
        </trans-unit>
        <trans-unit id="26f05bf5ad6ab1df97bc4c4688975872f5e533e1" translate="yes" xml:space="preserve">
          <source>In a comma-separated list of actions, spaces are allowed before and after each action.</source>
          <target state="translated">在以逗号分隔的动作列表中,每个动作前后都允许有空格。</target>
        </trans-unit>
        <trans-unit id="f1b27c3d7f721836425a197858414f76de2981f3" translate="yes" xml:space="preserve">
          <source>In a directory, named objects can have associated with them attributes. The &lt;code&gt;Attribute&lt;/code&gt; interface represents an attribute associated with a named object. An attribute contains 0 or more, possibly null, values. The attribute values can be ordered or unordered (see &lt;code&gt;isOrdered()&lt;/code&gt;). If the values are unordered, no duplicates are allowed. If the values are ordered, duplicates are allowed.</source>
          <target state="translated">在目录中，命名对象可以具有与其相关联的属性。的 &lt;code&gt;Attribute&lt;/code&gt; 接口表示与命名对象相关联的属性。属性包含0个或多个（可能为null）值。属性值可以有序或无序（请参见 &lt;code&gt;isOrdered()&lt;/code&gt; ）。如果值是无序的，则不允许重复。如果值是有序的，则允许重复。</target>
        </trans-unit>
        <trans-unit id="d814ed6a72f0f727435c36a8f8920d7394fc6592" translate="yes" xml:space="preserve">
          <source>In a directory, named objects can have associated with them attributes. The Attributes interface represents a collection of attributes. For example, you can request from the directory the attributes associated with an object. Those attributes are returned in an object that implements the Attributes interface.</source>
          <target state="translated">在一个目录中,命名的对象可以有与之相关的属性。Attributes接口代表了一个属性的集合。例如,您可以从目录中请求与对象相关联的属性。这些属性会在实现Attributes接口的对象中返回。</target>
        </trans-unit>
        <trans-unit id="ef39a078f24c6cadc5267973ce916397b861c70d" translate="yes" xml:space="preserve">
          <source>In a federated naming system, a context from one naming system may be bound to a name in another. One can subsequently look up and perform operations on the foreign context using a composite name. However, an attempt destroy the context using this composite name will fail with &lt;code&gt;NotContextException&lt;/code&gt;, because the foreign context is not a &quot;subcontext&quot; of the context in which it is bound. Instead, use &lt;code&gt;unbind()&lt;/code&gt; to remove the binding of the foreign context. Destroying the foreign context requires that the &lt;code&gt;destroySubcontext()&lt;/code&gt; be performed on a context from the foreign context's &quot;native&quot; naming system.</source>
          <target state="translated">在联合命名系统中，来自一个命名系统的上下文可以绑定到另一个命名系统中的名称。随后，可以使用复合名称在外部上下文中查找并执行操作。但是，使用该复合名称破坏上下文的尝试将失败，并显示 &lt;code&gt;NotContextException&lt;/code&gt; ，因为外部上下文不是绑定它的上下文的&amp;ldquo;子上下文&amp;rdquo;。而是使用 &lt;code&gt;unbind()&lt;/code&gt; 删除外部上下文的绑定。销毁外部上下文需要从外部上下文的&amp;ldquo;本机&amp;rdquo;命名系统中对上下文执行 &lt;code&gt;destroySubcontext()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="114c0d7797271a679147f3a27754dcc0dd68dfa2" translate="yes" xml:space="preserve">
          <source>In a given instance any particular component is either</source>
          <target state="translated">在一个给定的实例中,任何特定的组件都是</target>
        </trans-unit>
        <trans-unit id="5a88cd9c503e0a1686f90cc15c6ea972d48245fb" translate="yes" xml:space="preserve">
          <source>In a multi-screen environment with a virtual device, the location is specified in the corresponding virtual coordinate system. If the cursor location is outside the bounds of the virtual device the reported coordinates are clipped to fit within the bounds of the virtual device.</source>
          <target state="translated">在有虚拟设备的多屏环境中,位置是在相应的虚拟坐标系中指定的。如果光标的位置在虚拟设备的范围之外,则报告的坐标将被剪掉,以适应虚拟设备的范围。</target>
        </trans-unit>
        <trans-unit id="beec8e3caa686180234f4b8afe0fdcd9210ef4f5" translate="yes" xml:space="preserve">
          <source>In a multi-screen environment with a virtual device:</source>
          <target state="translated">在多屏环境下,通过虚拟设备。</target>
        </trans-unit>
        <trans-unit id="2234900dfb150b5e384fa3f5f81373e10b3301c9" translate="yes" xml:space="preserve">
          <source>In a multi-screen environment without a virtual device, the cursor location is specified in the coordinate system of the</source>
          <target state="translated">在没有虚拟设备的多屏环境中,光标位置是在坐标系中指定的。</target>
        </trans-unit>
        <trans-unit id="2c6404a0209e09710c9372e3d7d693cc85df5520" translate="yes" xml:space="preserve">
          <source>In a multi-screen environment without a virtual device:</source>
          <target state="translated">在没有虚拟设备的多屏环境中。</target>
        </trans-unit>
        <trans-unit id="f1a97eb3ece37ddd086b40af97826bcd430f5f23" translate="yes" xml:space="preserve">
          <source>In a multi-screen environment, the &lt;code&gt;GraphicsConfiguration&lt;/code&gt; objects can be used to render components on multiple screens. The following code sample demonstrates how to create a &lt;code&gt;JFrame&lt;/code&gt; object for each &lt;code&gt;GraphicsConfiguration&lt;/code&gt; on each screen device in the &lt;code&gt;GraphicsEnvironment&lt;/code&gt;:</source>
          <target state="translated">在多屏幕环境中，可以使用 &lt;code&gt;GraphicsConfiguration&lt;/code&gt; 对象在多个屏幕上呈现组件。下面的代码示例演示如何创建 &lt;code&gt;JFrame&lt;/code&gt; 对象的每个 &lt;code&gt;GraphicsConfiguration&lt;/code&gt; 在每个屏幕设备上 &lt;code&gt;GraphicsEnvironment&lt;/code&gt; 中：</target>
        </trans-unit>
        <trans-unit id="3b320df9cfdd61b94d5da4cf0c882fd741be52ee" translate="yes" xml:space="preserve">
          <source>In a multi-screen environment, you can create a &lt;code&gt;Dialog&lt;/code&gt; on a different screen device than its owner. See &lt;a href=&quot;frame&quot;&gt;&lt;code&gt;Frame&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">在多屏幕环境中，可以在不同于其所有者的屏幕设备上创建 &lt;code&gt;Dialog&lt;/code&gt; 。有关更多信息，请参见&lt;a href=&quot;frame&quot;&gt; &lt;code&gt;Frame&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d07ce735bcf4902c8204f1f63d8f440d8bc34c23" translate="yes" xml:space="preserve">
          <source>In a multi-screen environment, you can create a &lt;code&gt;Frame&lt;/code&gt; on a different screen device by constructing the &lt;code&gt;Frame&lt;/code&gt; with &lt;a href=&quot;#%3Cinit%3E(java.awt.GraphicsConfiguration)&quot;&gt;&lt;code&gt;Frame(GraphicsConfiguration)&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#%3Cinit%3E(java.lang.String,java.awt.GraphicsConfiguration)&quot;&gt;&lt;code&gt;Frame(String title, GraphicsConfiguration)&lt;/code&gt;&lt;/a&gt;. The &lt;code&gt;GraphicsConfiguration&lt;/code&gt; object is one of the &lt;code&gt;GraphicsConfiguration&lt;/code&gt; objects of the target screen device.</source>
          <target state="translated">在多屏幕环境中，你可以创建一个 &lt;code&gt;Frame&lt;/code&gt; 通过构建不同的屏幕设备上的 &lt;code&gt;Frame&lt;/code&gt; 与&lt;a href=&quot;#%3Cinit%3E(java.awt.GraphicsConfiguration)&quot;&gt; &lt;code&gt;Frame(GraphicsConfiguration)&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#%3Cinit%3E(java.lang.String,java.awt.GraphicsConfiguration)&quot;&gt; &lt;code&gt;Frame(String title, GraphicsConfiguration)&lt;/code&gt; &lt;/a&gt;。所述 &lt;code&gt;GraphicsConfiguration&lt;/code&gt; 对象是之一 &lt;code&gt;GraphicsConfiguration&lt;/code&gt; 目标屏幕设备的对象。</target>
        </trans-unit>
        <trans-unit id="e9512c06f1bf7d4fe185f8414ab76dfe1eb4fa74" translate="yes" xml:space="preserve">
          <source>In a multi-screen environment, you can create a &lt;code&gt;JDialog&lt;/code&gt; on a different screen device than its owner. See &lt;a href=&quot;../../java/awt/frame&quot;&gt;&lt;code&gt;Frame&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">在多屏幕环境中，可以在不同于其所有者的屏幕设备上创建 &lt;code&gt;JDialog&lt;/code&gt; 。有关更多信息，请参见&lt;a href=&quot;../../java/awt/frame&quot;&gt; &lt;code&gt;Frame&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cc171c3b95f3c60739318307a09709f0df11ea58" translate="yes" xml:space="preserve">
          <source>In a multi-screen environment, you can create a &lt;code&gt;JFrame&lt;/code&gt; on a different screen device. See &lt;a href=&quot;../../java/awt/frame&quot;&gt;&lt;code&gt;Frame&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">在多屏幕环境中，可以在其他屏幕设备上创建 &lt;code&gt;JFrame&lt;/code&gt; 。有关更多信息，请参见&lt;a href=&quot;../../java/awt/frame&quot;&gt; &lt;code&gt;Frame&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="58e515a085d497dcf291b45c8fdb16f2cb60b541" translate="yes" xml:space="preserve">
          <source>In a multi-screen environment, you can create a &lt;code&gt;JWindow&lt;/code&gt; on a different screen device. See &lt;a href=&quot;../../java/awt/window&quot;&gt;&lt;code&gt;Window&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">在多屏幕环境中，可以在其他屏幕设备上创建 &lt;code&gt;JWindow&lt;/code&gt; 。有关更多信息，请参见&lt;a href=&quot;../../java/awt/window&quot;&gt; &lt;code&gt;Window&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3ffadd88ef62e8dc7d903ba85453cda0c5774bb0" translate="yes" xml:space="preserve">
          <source>In a multi-screen environment, you can create a &lt;code&gt;Window&lt;/code&gt; on a different screen device by constructing the &lt;code&gt;Window&lt;/code&gt; with &lt;a href=&quot;#%3Cinit%3E(java.awt.Window,java.awt.GraphicsConfiguration)&quot;&gt;&lt;code&gt;Window(Window, GraphicsConfiguration)&lt;/code&gt;&lt;/a&gt;. The &lt;code&gt;GraphicsConfiguration&lt;/code&gt; object is one of the &lt;code&gt;GraphicsConfiguration&lt;/code&gt; objects of the target screen device.</source>
          <target state="translated">在多屏幕环境中，你可以创建一个 &lt;code&gt;Window&lt;/code&gt; 通过构建不同的屏幕设备上的 &lt;code&gt;Window&lt;/code&gt; 与&lt;a href=&quot;#%3Cinit%3E(java.awt.Window,java.awt.GraphicsConfiguration)&quot;&gt; &lt;code&gt;Window(Window, GraphicsConfiguration)&lt;/code&gt; &lt;/a&gt;。所述 &lt;code&gt;GraphicsConfiguration&lt;/code&gt; 对象是之一 &lt;code&gt;GraphicsConfiguration&lt;/code&gt; 目标屏幕设备的对象。</target>
        </trans-unit>
        <trans-unit id="cbb6f1b2109695564847c69426e7cd2b5d348cd9" translate="yes" xml:space="preserve">
          <source>In a multithreaded application, &lt;a href=&quot;keyeventdispatcher&quot;&gt;&lt;code&gt;KeyEventDispatcher&lt;/code&gt;&lt;/a&gt; behaves the same as other AWT listeners. See &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.desktop/java/awt/doc-files/AWTThreadIssues.html#ListenersThreads&quot;&gt;AWT Threading Issues&lt;/a&gt; for more details.</source>
          <target state="translated">在多线程应用程序中，&lt;a href=&quot;keyeventdispatcher&quot;&gt; &lt;code&gt;KeyEventDispatcher&lt;/code&gt; 的&lt;/a&gt;行为与其他AWT侦听器相同。有关更多详细信息，请参见&lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.desktop/java/awt/doc-files/AWTThreadIssues.html#ListenersThreads&quot;&gt;AWT线程问题&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dde14c7a5b872a20e74ed058b19e9e683da406a4" translate="yes" xml:space="preserve">
          <source>In a multithreaded application, &lt;a href=&quot;keyeventdispatcher&quot;&gt;&lt;code&gt;KeyEventDispatcher&lt;/code&gt;&lt;/a&gt; behaves the same as other AWT listeners. See &lt;a href=&quot;https://docs.oracle.com/en/java/javase/15/docs/api/java.desktop/java/awt/doc-files/AWTThreadIssues.html#ListenersThreads&quot;&gt;AWT Threading Issues&lt;/a&gt; for more details.</source>
          <target state="translated">在多线程应用程序中，&lt;a href=&quot;keyeventdispatcher&quot;&gt; &lt;code&gt;KeyEventDispatcher&lt;/code&gt; 的&lt;/a&gt;行为与其他AWT侦听器相同。有关更多详细信息，请参见&lt;a href=&quot;https://docs.oracle.com/en/java/javase/15/docs/api/java.desktop/java/awt/doc-files/AWTThreadIssues.html#ListenersThreads&quot;&gt;AWT线程问题&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="25abd890f9d831cb21b6f248256eaa8ffdec0eec" translate="yes" xml:space="preserve">
          <source>In a multithreaded application, &lt;a href=&quot;keyeventpostprocessor&quot;&gt;&lt;code&gt;KeyEventPostProcessor&lt;/code&gt;&lt;/a&gt; behaves the same as other AWT listeners. See &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.desktop/java/awt/doc-files/AWTThreadIssues.html#ListenersThreads&quot;&gt;AWT Threading Issues&lt;/a&gt; for more details.</source>
          <target state="translated">在多线程应用程序中，&lt;a href=&quot;keyeventpostprocessor&quot;&gt; &lt;code&gt;KeyEventPostProcessor&lt;/code&gt; 的&lt;/a&gt;行为与其他AWT侦听器相同。有关更多详细信息，请参见&lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.desktop/java/awt/doc-files/AWTThreadIssues.html#ListenersThreads&quot;&gt;AWT线程问题&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="422163756360415662916055c0a9fd5929217c4a" translate="yes" xml:space="preserve">
          <source>In a multithreaded application, &lt;a href=&quot;keyeventpostprocessor&quot;&gt;&lt;code&gt;KeyEventPostProcessor&lt;/code&gt;&lt;/a&gt; behaves the same as other AWT listeners. See &lt;a href=&quot;https://docs.oracle.com/en/java/javase/15/docs/api/java.desktop/java/awt/doc-files/AWTThreadIssues.html#ListenersThreads&quot;&gt;AWT Threading Issues&lt;/a&gt; for more details.</source>
          <target state="translated">在多线程应用程序中，&lt;a href=&quot;keyeventpostprocessor&quot;&gt; &lt;code&gt;KeyEventPostProcessor&lt;/code&gt; 的&lt;/a&gt;行为与其他AWT侦听器相同。有关更多详细信息，请参见&lt;a href=&quot;https://docs.oracle.com/en/java/javase/15/docs/api/java.desktop/java/awt/doc-files/AWTThreadIssues.html#ListenersThreads&quot;&gt;AWT线程问题&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="efe47ac7935506f54f1c9824300c5228ddba832f" translate="yes" xml:space="preserve">
          <source>In a provider-configuration file, any mention of a service provider that is deployed in a named module is ignored. This is to avoid duplicates that would otherwise arise when a named module has both a</source>
          <target state="translated">在提供商配置文件中,对部署在命名模块中的服务提供商的任何提及都会被忽略。这是为了避免重复,否则,当一个命名的模块同时拥有一个</target>
        </trans-unit>
        <trans-unit id="4f34c121362e6825cfb7979d461f740a49f541c2" translate="yes" xml:space="preserve">
          <source>In a similar manner, this method can be used to ignore secondary fields that would otherwise be cross-checked. For example, if the formatter consists of year, month, day-of-month and day-of-week, then there is only one way to resolve a date, but the parsed value for day-of-week will be cross-checked against the resolved date. Calling this method with the arguments &lt;a href=&quot;../temporal/chronofield#YEAR&quot;&gt;&lt;code&gt;YEAR&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../temporal/chronofield#MONTH_OF_YEAR&quot;&gt;&lt;code&gt;MONTH_OF_YEAR&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../temporal/chronofield#DAY_OF_MONTH&quot;&gt;&lt;code&gt;DAY_OF_MONTH&lt;/code&gt;&lt;/a&gt; will ensure that the date is resolved correctly, but without any cross-check for the day-of-week.</source>
          <target state="translated">以类似的方式，该方法可用于忽略否则将被交叉检查的次级字段。例如，如果格式化程序由年，月，月日和星期几组成，则只有一种方法可以解析日期，但是将对星期几的解析值进行交叉检查。根据解决的日期。使用参数&lt;a href=&quot;../temporal/chronofield#YEAR&quot;&gt; &lt;code&gt;YEAR&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../temporal/chronofield#MONTH_OF_YEAR&quot;&gt; &lt;code&gt;MONTH_OF_YEAR&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../temporal/chronofield#DAY_OF_MONTH&quot;&gt; &lt;code&gt;DAY_OF_MONTH&lt;/code&gt; &lt;/a&gt;调用此方法将确保正确解析日期，但不会对星期几进行任何交叉检查。</target>
        </trans-unit>
        <trans-unit id="90329937fe209cdc5c56c8a7860e7f3ea7544235" translate="yes" xml:space="preserve">
          <source>In a string without quotes or escapes, any instance of the separator delimits two atomic names. Each atomic name is referred to as a &lt;em&gt;component&lt;/em&gt;.</source>
          <target state="translated">在没有引号或转义符的字符串中，分隔符的任何实例都分隔两个原子名称。每个原子名称都称为一个&lt;em&gt;组件&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="0ed539e402cf385b4dd9e80abdc848541c1447f9" translate="yes" xml:space="preserve">
          <source>In a text processing application that can cache intermediate representations of text, creation and subsequent caching of a &lt;code&gt;GlyphVector&lt;/code&gt; for use during rendering is the fastest method to present the visual representation of characters to a user.</source>
          <target state="translated">在可以缓存文本的中间表示的文本处理应用程序中，创建 &lt;code&gt;GlyphVector&lt;/code&gt; 并随后对其进行缓存以供渲染期间使用，是将字符的可视表示呈现给用户的最快方法。</target>
        </trans-unit>
        <trans-unit id="ed263b2f5c9c11d52878d6f815cf7ac22d9692aa" translate="yes" xml:space="preserve">
          <source>In a tree of tiered phasers, registration and deregistration of child phasers with their parent are managed automatically. Whenever the number of registered parties of a child phaser becomes non-zero (as established in the &lt;a href=&quot;#%3Cinit%3E(java.util.concurrent.Phaser,int)&quot;&gt;&lt;code&gt;Phaser(Phaser,int)&lt;/code&gt;&lt;/a&gt; constructor, &lt;a href=&quot;#register()&quot;&gt;&lt;code&gt;register()&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;#bulkRegister(int)&quot;&gt;&lt;code&gt;bulkRegister(int)&lt;/code&gt;&lt;/a&gt;), the child phaser is registered with its parent. Whenever the number of registered parties becomes zero as the result of an invocation of &lt;a href=&quot;#arriveAndDeregister()&quot;&gt;&lt;code&gt;arriveAndDeregister()&lt;/code&gt;&lt;/a&gt;, the child phaser is deregistered from its parent.</source>
          <target state="translated">在分层的相位器树中，将自动管理子相位器及其父级的注册和注销。每当子相位器的注册方数量变为非零（如在&lt;a href=&quot;#%3Cinit%3E(java.util.concurrent.Phaser,int)&quot;&gt; &lt;code&gt;Phaser(Phaser,int)&lt;/code&gt; &lt;/a&gt;构造函数，&lt;a href=&quot;#register()&quot;&gt; &lt;code&gt;register()&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#bulkRegister(int)&quot;&gt; &lt;code&gt;bulkRegister(int)&lt;/code&gt; 中确定的那样&lt;/a&gt;）时，子相位器就会向其父级注册。每当调用&lt;a href=&quot;#arriveAndDeregister()&quot;&gt; &lt;code&gt;arriveAndDeregister()&lt;/code&gt; &lt;/a&gt;的结果而导致注册方的数量为零时，子相位器都会从其父级取消注册。</target>
        </trans-unit>
        <trans-unit id="85fe56db10a3c0d908e17d31e5b4da75440bafdf" translate="yes" xml:space="preserve">
          <source>In a tree of tiered phasers, registration and deregistration of child phasers with their parent are managed automatically. Whenever the number of registered parties of a child phaser becomes non-zero (as established in the &lt;a href=&quot;phaser#Phaser-java.util.concurrent.Phaser-int-&quot;&gt;&lt;code&gt;Phaser(Phaser,int)&lt;/code&gt;&lt;/a&gt; constructor, &lt;a href=&quot;phaser#register--&quot;&gt;&lt;code&gt;register()&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;phaser#bulkRegister-int-&quot;&gt;&lt;code&gt;bulkRegister(int)&lt;/code&gt;&lt;/a&gt;), the child phaser is registered with its parent. Whenever the number of registered parties becomes zero as the result of an invocation of &lt;a href=&quot;phaser#arriveAndDeregister--&quot;&gt;&lt;code&gt;arriveAndDeregister()&lt;/code&gt;&lt;/a&gt;, the child phaser is deregistered from its parent.</source>
          <target state="translated">在分层的相位器树中，将自动管理子相位器及其父级的注册和注销。只要子相位器的注册方数量非零（如&lt;a href=&quot;phaser#Phaser-java.util.concurrent.Phaser-int-&quot;&gt; &lt;code&gt;Phaser(Phaser,int)&lt;/code&gt; &lt;/a&gt;构造函数，&lt;a href=&quot;phaser#register--&quot;&gt; &lt;code&gt;register()&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;phaser#bulkRegister-int-&quot;&gt; &lt;code&gt;bulkRegister(int)&lt;/code&gt; 中所建立&lt;/a&gt;），子相位器就会向其父级注册。每当调用&lt;a href=&quot;phaser#arriveAndDeregister--&quot;&gt; &lt;code&gt;arriveAndDeregister()&lt;/code&gt; &lt;/a&gt;的结果而导致注册方的数量为零时，子相位器就会从其父级注销。</target>
        </trans-unit>
        <trans-unit id="6842084fd313a8aff5259cff4e2ee349f7ffc691" translate="yes" xml:space="preserve">
          <source>In a virtual device multi-screen environment in which the desktop area could span multiple physical screen devices, the bounds of all configurations are relative to the virtual device coordinate system. The origin of the virtual-coordinate system is at the upper left-hand corner of the primary physical screen. Depending on the location of the primary screen in the virtual device, negative coordinates are possible, as shown in the following figure.</source>
          <target state="translated">在虚拟设备多屏环境中,桌面区域可以跨越多个物理屏幕设备,所有配置的边界都是相对于虚拟设备坐标系的。虚拟坐标系的原点在主物理屏幕的左上角。根据主屏幕在虚拟设备中的位置,可以采用负坐标,如下图所示。</target>
        </trans-unit>
        <trans-unit id="cf00b9b973d8c83ad9d8253cbb4fa615258d8038" translate="yes" xml:space="preserve">
          <source>In a virtual device multi-screen environment in which the desktop area could span multiple physical screen devices, the bounds of all configurations are relative to the virtual-coordinate system. The origin of the virtual-coordinate system is at the upper left-hand corner of the primary physical screen. Depending on the location of the primary screen in the virtual device, negative coordinates are possible, as shown in the following figure.</source>
          <target state="translated">在虚拟设备多屏环境中,桌面区域可以跨越多个物理屏幕设备,所有配置的边界都是相对于虚拟坐标系的。虚拟坐标系的原点在主物理屏幕的左上角。根据主屏幕在虚拟设备中的位置,可以采用负坐标,如下图所示。</target>
        </trans-unit>
        <trans-unit id="37042eb4e42e068b312195920663ac63249d62d0" translate="yes" xml:space="preserve">
          <source>In a virtual device multi-screen environment in which the desktop area could span multiple physical screen devices, the bounds of the &lt;code&gt;GraphicsConfiguration&lt;/code&gt; objects are relative to the virtual coordinate system. When setting the location of a component, use &lt;a href=&quot;#getBounds()&quot;&gt;&lt;code&gt;getBounds&lt;/code&gt;&lt;/a&gt; to get the bounds of the desired &lt;code&gt;GraphicsConfiguration&lt;/code&gt; and offset the location with the coordinates of the &lt;code&gt;GraphicsConfiguration&lt;/code&gt;, as the following code sample illustrates:</source>
          <target state="translated">在桌面区域可以跨越多个物理屏幕设备的虚拟设备多屏幕环境中， &lt;code&gt;GraphicsConfiguration&lt;/code&gt; 对象的边界是相对于虚拟坐标系的。当设置一个组件的位置，使用&lt;a href=&quot;#getBounds()&quot;&gt; &lt;code&gt;getBounds&lt;/code&gt; &lt;/a&gt;以获得所需的边界 &lt;code&gt;GraphicsConfiguration&lt;/code&gt; 和偏移与所述的坐标位置 &lt;code&gt;GraphicsConfiguration&lt;/code&gt; ，如下面的代码示例说明：</target>
        </trans-unit>
        <trans-unit id="4de1fa88647ce453435c8841d38d13382e76babc" translate="yes" xml:space="preserve">
          <source>In a weighted list, each language range is given a weight value. The weight value is identical to the &quot;quality value&quot; in &lt;a href=&quot;http://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt;, and it expresses how much the user prefers the language. A weight value is specified after a corresponding language range followed by &lt;code&gt;&quot;;q=&quot;&lt;/code&gt;, and the default weight value is &lt;code&gt;MAX_WEIGHT&lt;/code&gt; when it is omitted.</source>
          <target state="translated">在加权列表中，每个语言范围都被赋予一个权重值。权重值与&lt;a href=&quot;http://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616中&lt;/a&gt;的&amp;ldquo;质量值&amp;rdquo;相同，它表示用户偏爱该语言的程度。在相应的语言范围后指定一个权重值，后跟 &lt;code&gt;&quot;;q=&quot;&lt;/code&gt; ，并且省略时，默认权重值为 &lt;code&gt;MAX_WEIGHT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="002825ebdd61f5a4f813bc2146c1718e2830b558" translate="yes" xml:space="preserve">
          <source>In a weighted list, each language range is given a weight value. The weight value is identical to the &quot;quality value&quot; in &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt;, and it expresses how much the user prefers the language. A weight value is specified after a corresponding language range followed by &lt;code&gt;&quot;;q=&quot;&lt;/code&gt;, and the default weight value is &lt;code&gt;MAX_WEIGHT&lt;/code&gt; when it is omitted.</source>
          <target state="translated">在加权列表中，每个语言范围都被赋予一个权重值。权重值与&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616中&lt;/a&gt;的&amp;ldquo;质量值&amp;rdquo;相同，它表示用户偏爱该语言的程度。在相应的语言范围后指定一个权重值，后跟 &lt;code&gt;&quot;;q=&quot;&lt;/code&gt; ，并且省略时，默认权重值为 &lt;code&gt;MAX_WEIGHT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="db07c01b971410649ed0adc273a6cbcf93d8159c" translate="yes" xml:space="preserve">
          <source>In addition it provides an extension mechanism so that arbitrary attribute/value pairs can be associated with a design feature.</source>
          <target state="translated">此外,它还提供了一种扩展机制,使任意的属性/值对可以与设计特征相关联。</target>
        </trans-unit>
        <trans-unit id="aee5260cc3f43d7a4d3d6be25379877f1d070d35" translate="yes" xml:space="preserve">
          <source>In addition there is a level OFF that can be used to turn off logging, and a level ALL that can be used to enable logging of all messages.</source>
          <target state="translated">此外,还有一个级别OFF可以用来关闭日志记录,还有一个级别ALL可以用来启用所有消息的记录。</target>
        </trans-unit>
        <trans-unit id="25aa82e21834a941721fb6024ff6ae38ee5c486b" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;READ&lt;/code&gt; and &lt;code&gt;WRITE&lt;/code&gt;, the following options may be present:</source>
          <target state="translated">除了 &lt;code&gt;READ&lt;/code&gt; 和 &lt;code&gt;WRITE&lt;/code&gt; 之外，还可以提供以下选项：</target>
        </trans-unit>
        <trans-unit id="a77e8c6c29cfcb07a58299b7f377977a6631ab29" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;Stream&lt;/code&gt;, which is a stream of object references, there are primitive specializations for &lt;a href=&quot;intstream&quot;&gt;&lt;code&gt;IntStream&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;longstream&quot;&gt;&lt;code&gt;LongStream&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;doublestream&quot;&gt;&lt;code&gt;DoubleStream&lt;/code&gt;&lt;/a&gt;, all of which are referred to as &quot;streams&quot; and conform to the characteristics and restrictions described here.</source>
          <target state="translated">除了 &lt;code&gt;Stream&lt;/code&gt; （它是对象引用的流）之外，还有&lt;a href=&quot;intstream&quot;&gt; &lt;code&gt;IntStream&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;longstream&quot;&gt; &lt;code&gt;LongStream&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;doublestream&quot;&gt; &lt;code&gt;DoubleStream&lt;/code&gt; 的&lt;/a&gt;原始规范，它们都被称为&amp;ldquo;流&amp;rdquo;，并符合此处描述的特征和限制。</target>
        </trans-unit>
        <trans-unit id="5a7506e4f08af8d27e12cc695d0acc8c53237c90" translate="yes" xml:space="preserve">
          <source>In addition to Connectors installed on the platform the VirtualMachineManager will also create Connectors to encapsulate any &lt;a href=&quot;connect/spi/transportservice&quot;&gt;&lt;code&gt;TransportService&lt;/code&gt;&lt;/a&gt; implementations that are installed on the platform. A TransportService is installed on the platform if it installed in a jar file that is visible to the defining class loader for the &lt;a href=&quot;connect/spi/transportservice&quot;&gt;&lt;code&gt;TransportService&lt;/code&gt;&lt;/a&gt; type, and that jar file contains a provider configuration file named &lt;code&gt;TransportService&lt;/code&gt; in the resource directory &lt;code&gt;META-INF/services&lt;/code&gt;, and the provider configuration file lists the full-qualified class name of the TransportService implementation. A TransportService is a concrete sub-class of &lt;a href=&quot;connect/spi/transportservice&quot;&gt;&lt;code&gt;TransportService&lt;/code&gt;&lt;/a&gt;. The format of the provider configuration file is the same as the provider configuration file for Connectors except that each class listed must be the fully-qualified class name of a class that implements the TransportService interface.</source>
          <target state="translated">除了在平台上安装的连接器之外，VirtualMachineManager还将创建连接器以封装平台上安装的所有&lt;a href=&quot;connect/spi/transportservice&quot;&gt; &lt;code&gt;TransportService&lt;/code&gt; &lt;/a&gt;实施。如果TransportService安装在平台上，并且安装在对于定义类加载器可见的jar文件中，该jar文件对于&lt;a href=&quot;connect/spi/transportservice&quot;&gt; &lt;code&gt;TransportService&lt;/code&gt; &lt;/a&gt;类型是可见的，并且该jar文件在资源目录 &lt;code&gt;META-INF/services&lt;/code&gt; 中包含名为 &lt;code&gt;TransportService&lt;/code&gt; 的提供程序配置文件，并且提供程序配置文件列出了TransportService实现的完全限定的类名。一个TransportService是一个具体的子类的&lt;a href=&quot;connect/spi/transportservice&quot;&gt; &lt;code&gt;TransportService&lt;/code&gt; &lt;/a&gt;。提供程序配置文件的格式与连接器的提供程序配置文件的格式相同，除了列出的每个类必须是实现TransportService接口的类的标准类名。</target>
        </trans-unit>
        <trans-unit id="f7053d093b3d7495ffccb4caf96bc92474aae362" translate="yes" xml:space="preserve">
          <source>In addition to JAR files, an implementation may also support modules that are packaged in other implementation specific module formats. If an element in the array specified to this method is a path to a directory of modules then entries in the directory that not recognized as modules are ignored. If an element in the array is a path to a packaged module that is not recognized then a &lt;code&gt;FindException&lt;/code&gt; is thrown when the file is encountered. Paths to files that do not exist are always ignored.</source>
          <target state="translated">除了JAR文件，实现还可以支持以其他实现特定的模块格式打包的模块。如果为此方法指定的数组中的元素是模块目录的路径，则该目录中未被识别为模块的条目将被忽略。如果数组中的元素是无法识别的打包模块的路径，则在遇到文件时将引发 &lt;code&gt;FindException&lt;/code&gt; 。到不存在的文件的路径始终被忽略。</target>
        </trans-unit>
        <trans-unit id="863160dc390b3ec933c01afa4c507995a466826d" translate="yes" xml:space="preserve">
          <source>In addition to a message string, a reference to another &lt;code&gt;Throwable&lt;/code&gt; (&lt;code&gt;Error&lt;/code&gt; or &lt;code&gt;Exception&lt;/code&gt;) is maintained. This reference, if non-&lt;code&gt;null&lt;/code&gt;, refers to the event that caused this exception to occur. For example, an &lt;code&gt;IOException&lt;/code&gt; while reading from a &lt;code&gt;File&lt;/code&gt; would be stored there.</source>
          <target state="translated">除了消息字符串之外，还保留了对另一个 &lt;code&gt;Throwable&lt;/code&gt; （ &lt;code&gt;Error&lt;/code&gt; 或 &lt;code&gt;Exception&lt;/code&gt; ）的引用。此引用（如果非 &lt;code&gt;null&lt;/code&gt; ）引用导致此异常发生的事件。例如，从 &lt;code&gt;File&lt;/code&gt; 读取时， &lt;code&gt;IOException&lt;/code&gt; 将存储在此处。</target>
        </trans-unit>
        <trans-unit id="7cae3428a9414e77995a69af58d38c2d85c371b2" translate="yes" xml:space="preserve">
          <source>In addition to accessing the components of a path, a &lt;code&gt;Path&lt;/code&gt; also defines the &lt;a href=&quot;#resolve(java.nio.file.Path)&quot;&gt;&lt;code&gt;resolve&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#resolveSibling(java.nio.file.Path)&quot;&gt;&lt;code&gt;resolveSibling&lt;/code&gt;&lt;/a&gt; methods to combine paths. The &lt;a href=&quot;#relativize(java.nio.file.Path)&quot;&gt;&lt;code&gt;relativize&lt;/code&gt;&lt;/a&gt; method that can be used to construct a relative path between two paths. Paths can be &lt;a href=&quot;#compareTo(java.nio.file.Path)&quot;&gt;&lt;code&gt;compared&lt;/code&gt;&lt;/a&gt;, and tested against each other using the &lt;a href=&quot;#startsWith(java.nio.file.Path)&quot;&gt;&lt;code&gt;startsWith&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#endsWith(java.nio.file.Path)&quot;&gt;&lt;code&gt;endsWith&lt;/code&gt;&lt;/a&gt; methods.</source>
          <target state="translated">除了访问路径的组成部分之外， &lt;code&gt;Path&lt;/code&gt; 还定义了&lt;a href=&quot;#resolve(java.nio.file.Path)&quot;&gt; &lt;code&gt;resolve&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#resolveSibling(java.nio.file.Path)&quot;&gt; &lt;code&gt;resolveSibling&lt;/code&gt; &lt;/a&gt;方法来组合路径。的&lt;a href=&quot;#relativize(java.nio.file.Path)&quot;&gt; &lt;code&gt;relativize&lt;/code&gt; &lt;/a&gt;可用于构建两个路径之间的相对路径的方法。可以使用&lt;a href=&quot;#startsWith(java.nio.file.Path)&quot;&gt; &lt;code&gt;startsWith&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#endsWith(java.nio.file.Path)&quot;&gt; &lt;code&gt;endsWith&lt;/code&gt; &lt;/a&gt;方法对路径进行&lt;a href=&quot;#compareTo(java.nio.file.Path)&quot;&gt; &lt;code&gt;compared&lt;/code&gt; &lt;/a&gt;和相互测试。</target>
        </trans-unit>
        <trans-unit id="2ad396eb168616040e6ae0797aa5e8deb8ca87b3" translate="yes" xml:space="preserve">
          <source>In addition to accessing the components of a path, a &lt;code&gt;Path&lt;/code&gt; also defines the &lt;a href=&quot;path#resolve-java.nio.file.Path-&quot;&gt;&lt;code&gt;resolve&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;path#resolveSibling-java.nio.file.Path-&quot;&gt;&lt;code&gt;resolveSibling&lt;/code&gt;&lt;/a&gt; methods to combine paths. The &lt;a href=&quot;path#relativize-java.nio.file.Path-&quot;&gt;&lt;code&gt;relativize&lt;/code&gt;&lt;/a&gt; method that can be used to construct a relative path between two paths. Paths can be &lt;a href=&quot;path#compareTo-java.nio.file.Path-&quot;&gt;&lt;code&gt;compared&lt;/code&gt;&lt;/a&gt;, and tested against each other using the &lt;a href=&quot;path#startsWith-java.nio.file.Path-&quot;&gt;&lt;code&gt;startsWith&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;path#endsWith-java.nio.file.Path-&quot;&gt;&lt;code&gt;endsWith&lt;/code&gt;&lt;/a&gt; methods.</source>
          <target state="translated">除了访问路径的组成部分之外， &lt;code&gt;Path&lt;/code&gt; 还定义了&lt;a href=&quot;path#resolve-java.nio.file.Path-&quot;&gt; &lt;code&gt;resolve&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;path#resolveSibling-java.nio.file.Path-&quot;&gt; &lt;code&gt;resolveSibling&lt;/code&gt; &lt;/a&gt;方法来组合路径。的&lt;a href=&quot;path#relativize-java.nio.file.Path-&quot;&gt; &lt;code&gt;relativize&lt;/code&gt; &lt;/a&gt;可用于构建两个路径之间的相对路径的方法。可以使用&lt;a href=&quot;path#startsWith-java.nio.file.Path-&quot;&gt; &lt;code&gt;startsWith&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;path#endsWith-java.nio.file.Path-&quot;&gt; &lt;code&gt;endsWith&lt;/code&gt; &lt;/a&gt;方法对路径进行&lt;a href=&quot;path#compareTo-java.nio.file.Path-&quot;&gt; &lt;code&gt;compared&lt;/code&gt; &lt;/a&gt;和相互测试。</target>
        </trans-unit>
        <trans-unit id="b69db6d9c887a09c80baed2338b0466acc408a2c" translate="yes" xml:space="preserve">
          <source>In addition to adjusting a date-time, an interface is provided to enable querying via &lt;a href=&quot;temporalquery&quot;&gt;&lt;code&gt;TemporalQuery&lt;/code&gt;&lt;/a&gt;. The most common implementations of the query interface are method references. The &lt;code&gt;from(TemporalAccessor)&lt;/code&gt; methods on major classes can all be used, such as &lt;code&gt;LocalDate::from&lt;/code&gt; or &lt;code&gt;Month::from&lt;/code&gt;. Further implementations are provided in &lt;a href=&quot;temporalqueries&quot;&gt;&lt;code&gt;TemporalQueries&lt;/code&gt;&lt;/a&gt; as static methods. Applications can also define queries by implementing &lt;a href=&quot;temporalquery&quot;&gt;&lt;code&gt;TemporalQuery&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">除了调整日期时间外，还提供了一个接口，以允许通过&lt;a href=&quot;temporalquery&quot;&gt; &lt;code&gt;TemporalQuery&lt;/code&gt; &lt;/a&gt;进行查询。查询接口的最常见实现是方法引用。可以使用主要类上的 &lt;code&gt;from(TemporalAccessor)&lt;/code&gt; 方法，例如 &lt;code&gt;LocalDate::from&lt;/code&gt; 或 &lt;code&gt;Month::from&lt;/code&gt; 。在&lt;a href=&quot;temporalqueries&quot;&gt; &lt;code&gt;TemporalQueries&lt;/code&gt; 中&lt;/a&gt;作为静态方法提供了进一步的实现。应用程序还可以通过实现&lt;a href=&quot;temporalquery&quot;&gt; &lt;code&gt;TemporalQuery&lt;/code&gt; &lt;/a&gt;来定义查询。</target>
        </trans-unit>
        <trans-unit id="b19c15dcc38f6284d861a9041b2c5b74bc056854" translate="yes" xml:space="preserve">
          <source>In addition to any and all default formats text returned by the system Clipboard's &lt;code&gt;getTransferData()&lt;/code&gt; method is available in the following flavors:</source>
          <target state="translated">除了系统剪贴板的 &lt;code&gt;getTransferData()&lt;/code&gt; 方法返回的所有默认格式的文本以外，还可以使用以下几种格式：</target>
        </trans-unit>
        <trans-unit id="18dd49d60299a8c8c9308c9ee36eeeae82c291e1" translate="yes" xml:space="preserve">
          <source>In addition to any notification specified by the application, a ModelMBean may always send also two additional notifications:</source>
          <target state="translated">除了应用程序指定的任何通知外,一个ModelMBean还可以总是发送两个额外的通知。</target>
        </trans-unit>
        <trans-unit id="d4c0aa78ed39e161d449ed162b18522a30f07ac8" translate="yes" xml:space="preserve">
          <source>In addition to attribute views, this package also defines classes and interfaces that are used when accessing attributes:</source>
          <target state="translated">除了属性视图,这个包还定义了访问属性时使用的类和接口。</target>
        </trans-unit>
        <trans-unit id="bc50128c00af4b489ab96e5629b96a88aadeb5af" translate="yes" xml:space="preserve">
          <source>In addition to classes representing single values and arrays, this package contains &lt;em&gt;Updater&lt;/em&gt; classes that can be used to obtain &lt;code&gt;compareAndSet&lt;/code&gt; and related operations on any selected &lt;code&gt;volatile&lt;/code&gt; field of any selected class. These classes predate the introduction of &lt;a href=&quot;../../../lang/invoke/varhandle&quot;&gt;&lt;code&gt;VarHandle&lt;/code&gt;&lt;/a&gt;, and are of more limited use. &lt;a href=&quot;atomicreferencefieldupdater&quot;&gt;&lt;code&gt;AtomicReferenceFieldUpdater&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;atomicintegerfieldupdater&quot;&gt;&lt;code&gt;AtomicIntegerFieldUpdater&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;atomiclongfieldupdater&quot;&gt;&lt;code&gt;AtomicLongFieldUpdater&lt;/code&gt;&lt;/a&gt; are reflection-based utilities that provide access to the associated field types. These are mainly of use in atomic data structures in which several &lt;code&gt;volatile&lt;/code&gt; fields of the same node (for example, the links of a tree node) are independently subject to atomic updates. These classes enable greater flexibility in how and when to use atomic updates, at the expense of more awkward reflection-based setup, less convenient usage, and weaker guarantees.</source>
          <target state="translated">除了表示单个值和数组的类之外，此程序包还包含&lt;em&gt;Updater&lt;/em&gt;类，这些类可用于获取 &lt;code&gt;compareAndSet&lt;/code&gt; 和对任何选定类的任何选定 &lt;code&gt;volatile&lt;/code&gt; 字段的相关操作。这些类在引入&lt;a href=&quot;../../../lang/invoke/varhandle&quot;&gt; &lt;code&gt;VarHandle&lt;/code&gt; &lt;/a&gt;之前就已经存在，并且用途更有限。&lt;a href=&quot;atomicreferencefieldupdater&quot;&gt; &lt;code&gt;AtomicReferenceFieldUpdater&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;atomicintegerfieldupdater&quot;&gt; &lt;code&gt;AtomicIntegerFieldUpdater&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;atomiclongfieldupdater&quot;&gt; &lt;code&gt;AtomicLongFieldUpdater&lt;/code&gt; &lt;/a&gt;是基于反射的实用程序，它们提供对关联字段类型的访问。这些主要用于原子数据结构，其中几个 &lt;code&gt;volatile&lt;/code&gt; 相同节点（例如，树节点的链接）的字段独立进行原子更新。这些类在如何以及何时使用原子更新方面提供了更大的灵活性，但代价是基于反射的设置更加笨拙，使用不方便且保证较弱。</target>
        </trans-unit>
        <trans-unit id="27cf5bf5dd1546b6480b43a44092643f35de07f9" translate="yes" xml:space="preserve">
          <source>In addition to classes representing single values, this package contains &lt;em&gt;Updater&lt;/em&gt; classes that can be used to obtain &lt;code&gt;compareAndSet&lt;/code&gt; operations on any selected &lt;code&gt;volatile&lt;/code&gt; field of any selected class. &lt;a href=&quot;atomicreferencefieldupdater&quot;&gt;&lt;code&gt;AtomicReferenceFieldUpdater&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;atomicintegerfieldupdater&quot;&gt;&lt;code&gt;AtomicIntegerFieldUpdater&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;atomiclongfieldupdater&quot;&gt;&lt;code&gt;AtomicLongFieldUpdater&lt;/code&gt;&lt;/a&gt; are reflection-based utilities that provide access to the associated field types. These are mainly of use in atomic data structures in which several &lt;code&gt;volatile&lt;/code&gt; fields of the same node (for example, the links of a tree node) are independently subject to atomic updates. These classes enable greater flexibility in how and when to use atomic updates, at the expense of more awkward reflection-based setup, less convenient usage, and weaker guarantees.</source>
          <target state="translated">除了表示单个值的类之外，此程序包还包含&lt;em&gt;Updater&lt;/em&gt;类，这些类可用于获取对任何选定类的任何选定 &lt;code&gt;volatile&lt;/code&gt; 字段的 &lt;code&gt;compareAndSet&lt;/code&gt; 操作。&lt;a href=&quot;atomicreferencefieldupdater&quot;&gt; &lt;code&gt;AtomicReferenceFieldUpdater&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;atomicintegerfieldupdater&quot;&gt; &lt;code&gt;AtomicIntegerFieldUpdater&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;atomiclongfieldupdater&quot;&gt; &lt;code&gt;AtomicLongFieldUpdater&lt;/code&gt; &lt;/a&gt;是基于反射的实用程序，它们提供对关联字段类型的访问。这些主要用于原子数据结构，其中几个 &lt;code&gt;volatile&lt;/code&gt; 同一节点的字段（例如，树节点的链接）独立地接受原子更新。这些类在如何以及何时使用原子更新方面提供了更大的灵活性，但代价是基于反射的设置更加笨拙，使用不方便且保证较弱。</target>
        </trans-unit>
        <trans-unit id="0bc4ccff0ab1bd17b3276b9194d147e971d51782" translate="yes" xml:space="preserve">
          <source>In addition to creating a factory instance using the same process as &lt;a href=&quot;#newDefaultInstance()&quot;&gt;&lt;code&gt;newDefaultInstance()&lt;/code&gt;&lt;/a&gt;, this method must set NamespaceAware to true.</source>
          <target state="translated">除了使用与&lt;a href=&quot;#newDefaultInstance()&quot;&gt; &lt;code&gt;newDefaultInstance()&lt;/code&gt; &lt;/a&gt;相同的过程创建工厂实例外，此方法还必须将NamespaceAware设置为true。</target>
        </trans-unit>
        <trans-unit id="eca4ec2f7b1be3398a48a882ea6b958d98ce287f" translate="yes" xml:space="preserve">
          <source>In addition to creating a factory instance using the same process as &lt;a href=&quot;#newInstance()&quot;&gt;&lt;code&gt;newInstance()&lt;/code&gt;&lt;/a&gt;, this method must set NamespaceAware to true.</source>
          <target state="translated">除了使用与&lt;a href=&quot;#newInstance()&quot;&gt; &lt;code&gt;newInstance()&lt;/code&gt; &lt;/a&gt;相同的过程创建工厂实例外，此方法还必须将NamespaceAware设置为true。</target>
        </trans-unit>
        <trans-unit id="c3f45c92415ecef104de1c062fe9e8437ce4b6ff" translate="yes" xml:space="preserve">
          <source>In addition to creating a factory instance using the same process as &lt;a href=&quot;#newInstance(java.lang.String,java.lang.ClassLoader)&quot;&gt;&lt;code&gt;newInstance(java.lang.String, java.lang.ClassLoader)&lt;/code&gt;&lt;/a&gt;, this method must set NamespaceAware to true.</source>
          <target state="translated">除了使用与&lt;a href=&quot;#newInstance(java.lang.String,java.lang.ClassLoader)&quot;&gt; &lt;code&gt;newInstance(java.lang.String, java.lang.ClassLoader)&lt;/code&gt; &lt;/a&gt;相同的过程创建工厂实例外，此方法还必须将NamespaceAware设置为true。</target>
        </trans-unit>
        <trans-unit id="86cfc1a551a2b499d9426296495d7d86d23960f2" translate="yes" xml:space="preserve">
          <source>In addition to element nodes, XPath location paths may also address attribute nodes, text nodes, comment nodes, and processing instruction nodes. The following table gives examples of location paths for each of these node types:</source>
          <target state="translated">除了元素节点外,XPath位置路径还可以解决属性节点、文本节点、注释节点和处理指令节点。下表给出了这些节点类型的位置路径示例。</target>
        </trans-unit>
        <trans-unit id="1a910912e92276c4c5b3275eff73b6ba6d758828" translate="yes" xml:space="preserve">
          <source>In addition to execution and lifecycle control methods, this class provides status check methods (for example &lt;a href=&quot;#getStealCount()&quot;&gt;&lt;code&gt;getStealCount()&lt;/code&gt;&lt;/a&gt;) that are intended to aid in developing, tuning, and monitoring fork/join applications. Also, method &lt;a href=&quot;#toString()&quot;&gt;&lt;code&gt;toString()&lt;/code&gt;&lt;/a&gt; returns indications of pool state in a convenient form for informal monitoring.</source>
          <target state="translated">除了执行和生命周期控制方法之外，此类还提供状态检查方法（例如&lt;a href=&quot;#getStealCount()&quot;&gt; &lt;code&gt;getStealCount()&lt;/code&gt; &lt;/a&gt;），旨在帮助开发，调整和监视fork / join应用程序。同样，方法&lt;a href=&quot;#toString()&quot;&gt; &lt;code&gt;toString()&lt;/code&gt; &lt;/a&gt;以方便的形式返回池状态的指示，以进行非正式监视。</target>
        </trans-unit>
        <trans-unit id="c07668fb78a3e8b44ef261341e115a92aefc5157" translate="yes" xml:space="preserve">
          <source>In addition to execution and lifecycle control methods, this class provides status check methods (for example &lt;a href=&quot;forkjoinpool#getStealCount--&quot;&gt;&lt;code&gt;getStealCount()&lt;/code&gt;&lt;/a&gt;) that are intended to aid in developing, tuning, and monitoring fork/join applications. Also, method &lt;a href=&quot;forkjoinpool#toString--&quot;&gt;&lt;code&gt;toString()&lt;/code&gt;&lt;/a&gt; returns indications of pool state in a convenient form for informal monitoring.</source>
          <target state="translated">除了执行和生命周期控制方法之外，此类还提供状态检查方法（例如&lt;a href=&quot;forkjoinpool#getStealCount--&quot;&gt; &lt;code&gt;getStealCount()&lt;/code&gt; &lt;/a&gt;），旨在帮助开发，调整和监视fork / join应用程序。同样，方法&lt;a href=&quot;forkjoinpool#toString--&quot;&gt; &lt;code&gt;toString()&lt;/code&gt; &lt;/a&gt;以方便的形式返回池状态的指示，以进行非正式监视。</target>
        </trans-unit>
        <trans-unit id="c14f1da366289ef8301d035cb42e8fc05d0b3be6" translate="yes" xml:space="preserve">
          <source>In addition to groups created explicitly, the Java virtual machine maintains a system-wide &lt;em&gt;default group&lt;/em&gt; that is constructed automatically. Asynchronous channels that do not specify a group at construction time are bound to the default group. The default group has an associated thread pool that creates new threads as needed. The default group may be configured by means of system properties defined in the table below. Where the &lt;a href=&quot;../../util/concurrent/threadfactory&quot;&gt;&lt;code&gt;ThreadFactory&lt;/code&gt;&lt;/a&gt; for the default group is not configured then the pooled threads of the default group are &lt;a href=&quot;../../lang/thread#isDaemon()&quot;&gt;&lt;code&gt;daemon&lt;/code&gt;&lt;/a&gt; threads.</source>
          <target state="translated">除了显式创建的组之外，Java虚拟机还维护一个系统范围的&lt;em&gt;默认组&lt;/em&gt;，该&lt;em&gt;组&lt;/em&gt;是自动构建的。在构造时未指定组的异步通道将绑定到默认组。缺省组具有一个关联的线程池，该线程池可根据需要创建新线程。可以通过下表中定义的系统属性来配置默认组。如果未配置默认组的&lt;a href=&quot;../../util/concurrent/threadfactory&quot;&gt; &lt;code&gt;ThreadFactory&lt;/code&gt; &lt;/a&gt;，则默认组的池线程是&lt;a href=&quot;../../lang/thread#isDaemon()&quot;&gt; &lt;code&gt;daemon&lt;/code&gt; &lt;/a&gt;线程。</target>
        </trans-unit>
        <trans-unit id="249af950c1dd714f44dfbec5cb9ac53d258e1718" translate="yes" xml:space="preserve">
          <source>In addition to groups created explicitly, the Java virtual machine maintains a system-wide &lt;em&gt;default group&lt;/em&gt; that is constructed automatically. Asynchronous channels that do not specify a group at construction time are bound to the default group. The default group has an associated thread pool that creates new threads as needed. The default group may be configured by means of system properties defined in the table below. Where the &lt;a href=&quot;../../util/concurrent/threadfactory&quot;&gt;&lt;code&gt;ThreadFactory&lt;/code&gt;&lt;/a&gt; for the default group is not configured then the pooled threads of the default group are &lt;a href=&quot;../../lang/thread#isDaemon--&quot;&gt;&lt;code&gt;daemon&lt;/code&gt;&lt;/a&gt; threads.</source>
          <target state="translated">除了显式创建的组之外，Java虚拟机还维护一个系统范围的&lt;em&gt;默认组&lt;/em&gt;，该&lt;em&gt;组&lt;/em&gt;是自动构建的。在构造时未指定组的异步通道将绑定到默认组。缺省组具有一个关联的线程池，该线程池可根据需要创建新线程。可以通过下表中定义的系统属性来配置默认组。如果未配置默认组的&lt;a href=&quot;../../util/concurrent/threadfactory&quot;&gt; &lt;code&gt;ThreadFactory&lt;/code&gt; &lt;/a&gt;，则默认组的池线程是&lt;a href=&quot;../../lang/thread#isDaemon--&quot;&gt; &lt;code&gt;daemon&lt;/code&gt; &lt;/a&gt;线程。</target>
        </trans-unit>
        <trans-unit id="e10fc02d16ef570a75e8db5a40d2d23818a250fc" translate="yes" xml:space="preserve">
          <source>In addition to implementing the &lt;a href=&quot;lock&quot;&gt;&lt;code&gt;Lock&lt;/code&gt;&lt;/a&gt; interface, this class defines a number of &lt;code&gt;public&lt;/code&gt; and &lt;code&gt;protected&lt;/code&gt; methods for inspecting the state of the lock. Some of these methods are only useful for instrumentation and monitoring.</source>
          <target state="translated">除了实现&lt;a href=&quot;lock&quot;&gt; &lt;code&gt;Lock&lt;/code&gt; &lt;/a&gt;接口之外，此类还定义了许多用于检查锁状态的 &lt;code&gt;public&lt;/code&gt; 方法和 &lt;code&gt;protected&lt;/code&gt; 方法。其中一些方法仅对仪器和监视有用。</target>
        </trans-unit>
        <trans-unit id="5b3095dce17ab3236e109d68bfdd862d89e9f0ad" translate="yes" xml:space="preserve">
          <source>In addition to loading agents a VirtualMachine provides read access to the &lt;a href=&quot;../../../../../java.base/java/lang/system#getProperties()&quot;&gt;&lt;code&gt;system properties&lt;/code&gt;&lt;/a&gt; in the target VM. This can be useful in some environments where properties such as &lt;code&gt;java.home&lt;/code&gt;, &lt;code&gt;os.name&lt;/code&gt;, or &lt;code&gt;os.arch&lt;/code&gt; are used to construct the path to agent that will be loaded into the target VM.</source>
          <target state="translated">除了加载代理之外，VirtualMachine还提供对目标VM中的&lt;a href=&quot;../../../../../java.base/java/lang/system#getProperties()&quot;&gt; &lt;code&gt;system properties&lt;/code&gt; &lt;/a&gt;读取访问权限。在某些使用 &lt;code&gt;java.home&lt;/code&gt; ， &lt;code&gt;os.name&lt;/code&gt; 或 &lt;code&gt;os.arch&lt;/code&gt; 之类的属性来构造将被加载到目标VM的代理的路径的某些环境中，这很有用。</target>
        </trans-unit>
        <trans-unit id="91e7be4c0bd9afd5d0219e0805abd80ce1a6ae2d" translate="yes" xml:space="preserve">
          <source>In addition to loading classes, a class loader is also responsible for locating resources. A resource is some data (a &quot;&lt;code&gt;.class&lt;/code&gt;&quot; file, configuration data, or an image for example) that is identified with an abstract '/'-separated path name. Resources are typically packaged with an application or library so that they can be located by code in the application or library. In some cases, the resources are included so that they can be located by other libraries.</source>
          <target state="translated">除了加载类，类加载器还负责查找资源。资源是某些数据（例如，&amp;ldquo;。 &lt;code&gt;.class&lt;/code&gt; &amp;rdquo;文件，配置数据或映像），这些数据用抽象的&amp;ldquo; /&amp;rdquo;分隔的路径名标识。资源通常与应用程序或库打包在一起，以便可以通过代码在应用程序或库中找到它们。在某些情况下，会包括资源，以便其他库可以找到它们。</target>
        </trans-unit>
        <trans-unit id="ec4b220124539fad132ce531bce148656eb3511a" translate="yes" xml:space="preserve">
          <source>In addition to methods for accessing the position, limit, and capacity values and for marking and resetting, this class also defines the following operations upon buffers:</source>
          <target state="translated">除了访问位置、极限、容量值以及标记和重置的方法外,该类还定义了以下缓冲区的操作。</target>
        </trans-unit>
        <trans-unit id="c9c67790b6c91037224cb0e43f334ace4be9115f" translate="yes" xml:space="preserve">
          <source>In addition to raising the defined errors and warnings, implementations are expected to raise implementation specific errors and warnings for any other error and warning cases such as IO errors (file not found, permission denied,...) and so on.</source>
          <target state="translated">除了引发定义的错误和警告之外,实现还应该为任何其他错误和警告情况引发特定的实现错误和警告,例如IO错误(文件未找到,权限被拒绝,...)等等。</target>
        </trans-unit>
        <trans-unit id="fd52079bbe205b3bcd374f203efffc0470e1745b" translate="yes" xml:space="preserve">
          <source>In addition to raising the defined errors and warnings, implementations are expected to raise implementation specific errors and warnings for any other error and warning cases such as IO errors (file not found, permission denied,...), XML well-formedness errors, and so on.</source>
          <target state="translated">除了引发定义的错误和警告外,实现还应该为任何其他错误和警告情况引发特定的实现错误和警告,如IO错误(文件未找到、权限拒绝......)、XML格式良好的错误等。</target>
        </trans-unit>
        <trans-unit id="4afd3c157bbfa30f1d336e095cfe8fd7e7490d3a" translate="yes" xml:space="preserve">
          <source>In addition to read and write operations, this class defines the following operations:</source>
          <target state="translated">除了读写操作外,该类还定义了以下操作。</target>
        </trans-unit>
        <trans-unit id="bec83f051a9027148e6a86a6c722b1724d907132" translate="yes" xml:space="preserve">
          <source>In addition to reading bytes from the input buffer and writing characters to the output buffer, this method returns a &lt;a href=&quot;coderresult&quot;&gt;&lt;code&gt;CoderResult&lt;/code&gt;&lt;/a&gt; object to describe its reason for termination:</source>
          <target state="translated">除了从输入缓冲区读取字节并将字符写入输出缓冲区之外，此方法还返回&lt;a href=&quot;coderresult&quot;&gt; &lt;code&gt;CoderResult&lt;/code&gt; &lt;/a&gt;对象以描述其终止原因：</target>
        </trans-unit>
        <trans-unit id="6511f7091630bdef1a1d4d49b93dfe3aaad905c0" translate="yes" xml:space="preserve">
          <source>In addition to reading characters from the input buffer and writing bytes to the output buffer, this method returns a &lt;a href=&quot;coderresult&quot;&gt;&lt;code&gt;CoderResult&lt;/code&gt;&lt;/a&gt; object to describe its reason for termination:</source>
          <target state="translated">除了从输入缓冲区读取字符并将字节写入输出缓冲区之外，此方法还返回&lt;a href=&quot;coderresult&quot;&gt; &lt;code&gt;CoderResult&lt;/code&gt; &lt;/a&gt;对象以描述其终止原因：</target>
        </trans-unit>
        <trans-unit id="426c21be8d23fc549653794732dd4ec11d9e7056" translate="yes" xml:space="preserve">
          <source>In addition to serving as a standalone class, this class provides &lt;code&gt;protected&lt;/code&gt; functionality that may be useful when creating customized task classes.</source>
          <target state="translated">除了用作独立类之外，此类还提供 &lt;code&gt;protected&lt;/code&gt; 功能，这些功能在创建自定义任务类时可能很有用。</target>
        </trans-unit>
        <trans-unit id="de03a6972c04d5b1cdbf9debef3b7b16ba094ed9" translate="yes" xml:space="preserve">
          <source>In addition to serving as the base class for other component-related events (InputEvent, FocusEvent, WindowEvent, ContainerEvent), this class defines the events that indicate changes in a component's size, position, or visibility.</source>
          <target state="translated">除了作为其他组件相关事件(InputEvent、FocusEvent、WindowEvent、ContainerEvent)的基类外,该类还定义了指示组件的大小、位置或可见性变化的事件。</target>
        </trans-unit>
        <trans-unit id="67587c18b575b6663ae372b4e32c91ccb2a965bf" translate="yes" xml:space="preserve">
          <source>In addition to sorting &lt;code&gt;TableRowSorter&lt;/code&gt; provides the ability to filter. A filter is specified using the &lt;code&gt;setFilter&lt;/code&gt; method. The following example will only show rows containing the string &quot;foo&quot;:</source>
          <target state="translated">除了排序外， &lt;code&gt;TableRowSorter&lt;/code&gt; 还提供过滤功能。使用 &lt;code&gt;setFilter&lt;/code&gt; 方法指定过滤器。以下示例将仅显示包含字符串&amp;ldquo; foo&amp;rdquo;的行：</target>
        </trans-unit>
        <trans-unit id="ab8996f20e697a6d14a3748b6ff488d071e6087b" translate="yes" xml:space="preserve">
          <source>In addition to sorting, &lt;code&gt;DefaultRowSorter&lt;/code&gt; provides the ability to filter rows. Filtering is done by way of a &lt;code&gt;RowFilter&lt;/code&gt; that is specified using the &lt;code&gt;setRowFilter&lt;/code&gt; method. If no filter has been specified all rows are included.</source>
          <target state="translated">除排序外， &lt;code&gt;DefaultRowSorter&lt;/code&gt; 还提供过滤行的功能。过滤是通过使用 &lt;code&gt;setRowFilter&lt;/code&gt; 方法指定的 &lt;code&gt;RowFilter&lt;/code&gt; 进行的。如果未指定过滤器，则包括所有行。</target>
        </trans-unit>
        <trans-unit id="70d7ce344f3e3d1092fd258a0707f75b56a6ae69" translate="yes" xml:space="preserve">
          <source>In addition to supporting</source>
          <target state="translated">除了支持</target>
        </trans-unit>
        <trans-unit id="8c7f0496437b99dd6707c416172fdab3ba96b9f6" translate="yes" xml:space="preserve">
          <source>In addition to supporting access to variables under various access modes, a set of static methods, referred to as memory fence methods, is also provided for fine-grained control of memory ordering. The Java Language Specification permits other threads to observe operations as if they were executed in orders different than are apparent in program source code, subject to constraints arising, for example, from the use of locks, &lt;code&gt;volatile&lt;/code&gt; fields or VarHandles. The static methods, &lt;a href=&quot;#fullFence()&quot;&gt;&lt;code&gt;fullFence&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#acquireFence()&quot;&gt;&lt;code&gt;acquireFence&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#releaseFence()&quot;&gt;&lt;code&gt;releaseFence&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#loadLoadFence()&quot;&gt;&lt;code&gt;loadLoadFence&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#storeStoreFence()&quot;&gt;&lt;code&gt;storeStoreFence&lt;/code&gt;&lt;/a&gt;, can also be used to impose constraints. Their specifications, as is the case for certain access modes, are phrased in terms of the lack of &quot;reorderings&quot; -- observable ordering effects that might otherwise occur if the fence was not present. More precise phrasing of the specification of access mode methods and memory fence methods may accompany future updates of the Java Language Specification.</source>
          <target state="translated">除了支持在各种访问模式下访问变量之外，还提供了一组静态方法（称为内存隔离方法），用于对内存顺序进行细粒度控制。Java语言规范允许其他线程观察操作，就像它们以不同于程序源代码中明显的顺序执行一样，受制于因使用锁， &lt;code&gt;volatile&lt;/code&gt; 字段或VarHandles而产生的约束。静态方法&lt;a href=&quot;#fullFence()&quot;&gt; &lt;code&gt;fullFence&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#acquireFence()&quot;&gt; &lt;code&gt;acquireFence&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#releaseFence()&quot;&gt; &lt;code&gt;releaseFence&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#loadLoadFence()&quot;&gt; &lt;code&gt;loadLoadFence&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#storeStoreFence()&quot;&gt; &lt;code&gt;storeStoreFence&lt;/code&gt; &lt;/a&gt;，也可以用来施加约束。它们的规范（如某些访问模式的情况）用缺乏&amp;ldquo;重新排序&amp;rdquo;的措辞来表达-如果没有栅栏，则可能会出现可观察到的排序效果。访问模式方法和内存围栏方法的规范的更精确的措词可能会伴随Java语言规范的未来更新。</target>
        </trans-unit>
        <trans-unit id="2a815c33174399dfdfa26b67123da63d59d1595e" translate="yes" xml:space="preserve">
          <source>In addition to the &quot;&lt;code&gt;zip&lt;/code&gt;&quot; view, a Zip file system optionally supports the &lt;a href=&quot;../java.base/java/nio/file/attribute/posixfileattributeview&quot;&gt;&lt;code&gt;PosixFileAttributeView&lt;/code&gt;&lt;/a&gt; (&quot;&lt;code&gt;posix&lt;/code&gt;&quot;). This view extends the &quot;&lt;code&gt;basic&lt;/code&gt;&quot; view with type safe access to the &lt;a href=&quot;../java.base/java/nio/file/attribute/posixfileattributes#owner()&quot;&gt;&lt;code&gt;owner&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../java.base/java/nio/file/attribute/posixfileattributes#group()&quot;&gt;&lt;code&gt;group-owner&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../java.base/java/nio/file/attribute/posixfileattributes#permissions()&quot;&gt;&lt;code&gt;permissions&lt;/code&gt;&lt;/a&gt; attributes. The &quot;&lt;code&gt;posix&lt;/code&gt;&quot; view is only supported when the Zip file system is created with the provider property &quot;&lt;code&gt;enablePosixFileAttributes&lt;/code&gt;&quot; set to &quot;&lt;code&gt;true&lt;/code&gt;&quot;. The following creates a file system with this property and reads the access permissions of a file:</source>
          <target state="translated">除了&amp;ldquo; &lt;code&gt;zip&lt;/code&gt; &amp;rdquo;视图之外，Zip文件系统还可以选择支持&lt;a href=&quot;../java.base/java/nio/file/attribute/posixfileattributeview&quot;&gt; &lt;code&gt;PosixFileAttributeView&lt;/code&gt; &lt;/a&gt;（&amp;ldquo; &lt;code&gt;posix&lt;/code&gt; &amp;rdquo;）。该视图通过对&lt;a href=&quot;../java.base/java/nio/file/attribute/posixfileattributes#owner()&quot;&gt; &lt;code&gt;owner&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../java.base/java/nio/file/attribute/posixfileattributes#group()&quot;&gt; &lt;code&gt;group-owner&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../java.base/java/nio/file/attribute/posixfileattributes#permissions()&quot;&gt; &lt;code&gt;permissions&lt;/code&gt; &lt;/a&gt;属性的类型安全访问来扩展&amp;ldquo; &lt;code&gt;basic&lt;/code&gt; &amp;rdquo;视图。仅当在提供者属性&amp;ldquo; &lt;code&gt;enablePosixFileAttributes&lt;/code&gt; &amp;rdquo;设置为&amp;ldquo; &lt;code&gt;true&lt;/code&gt; &amp;rdquo;的情况下创建Zip文件系统时，才支持&amp;ldquo; &lt;code&gt;posix&lt;/code&gt; &amp;rdquo;视图。以下内容使用此属性创建文件系统，并读取文件的访问权限：</target>
        </trans-unit>
        <trans-unit id="34538930b92f28d4b10712af813efa3f3e99ed40" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;code&gt;XMLSignatureFactory&lt;/code&gt; and &lt;code&gt;KeyInfoFactory&lt;/code&gt; classes, the API supports a service provider interface for transform and canonicalization algorithms. The &lt;a href=&quot;transformservice&quot;&gt;&lt;code&gt;TransformService&lt;/code&gt;&lt;/a&gt; class allows you to develop and plug in an implementation of a specific transform or canonicalization algorithm for a particular XML mechanism type. The &lt;code&gt;
 TransformService&lt;/code&gt; class uses the standard JCA provider model for registering and loading implementations. Each service provider implementation SHOULD use the &lt;code&gt;TransformService&lt;/code&gt; class to find a provider that supports transform and canonicalization algorithms in XML Signatures that it is generating or validating.</source>
          <target state="translated">除了 &lt;code&gt;XMLSignatureFactory&lt;/code&gt; 和 &lt;code&gt;KeyInfoFactory&lt;/code&gt; 类之外，API还支持用于转换和规范化算法的服务提供程序接口。该&lt;a href=&quot;transformservice&quot;&gt; &lt;code&gt;TransformService&lt;/code&gt; &lt;/a&gt;类允许你在一个特定的转换或规范化算法特定XML机制类型的实现开发和插头。该 &lt;code&gt; TransformService&lt;/code&gt; 类使用标准的JCA提供者模型用于注册和加载实现。每个服务提供者实现都应该使用 &lt;code&gt;TransformService&lt;/code&gt; 类来找到一个提供者，该提供者在其正在生成或验证的XML签名中支持转换和规范化算法。</target>
        </trans-unit>
        <trans-unit id="1859092e8b0634ddf24a8ae6a3d0f5a50355a662" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;code&gt;actionPerformed&lt;/code&gt; method defined by the &lt;code&gt;ActionListener&lt;/code&gt; interface, this interface allows the application to define, in a single place:</source>
          <target state="translated">除了由 &lt;code&gt;ActionListener&lt;/code&gt; 接口定义的 &lt;code&gt;actionPerformed&lt;/code&gt; 方法之外，该接口还允许应用程序在单个位置定义：</target>
        </trans-unit>
        <trans-unit id="dc3b5860862c2beb6fcb5c470df7d2a1f92ba9de" translate="yes" xml:space="preserve">
          <source>In addition to the QName types, the XPath API supports the use of Class types through the &lt;code&gt;XPathExpression.evaluteExpression(...)&lt;/code&gt; or &lt;code&gt;XPath.evaluateExpression(...)&lt;/code&gt; methods. The XPath data types are mapped to Class types as follows:</source>
          <target state="translated">除了QName类型之外，XPath API还支持通过 &lt;code&gt;XPathExpression.evaluteExpression(...)&lt;/code&gt; 或 &lt;code&gt;XPath.evaluateExpression(...)&lt;/code&gt; 方法使用Class类型。XPath数据类型被映射为Class类型，如下所示：</target>
        </trans-unit>
        <trans-unit id="1db36d86361d1b95831e09d49fbfd3fd4e22ef41" translate="yes" xml:space="preserve">
          <source>In addition to the above entry types, a catalog may define nextCatalog entries to add additional catalog entry files.</source>
          <target state="translated">除了上述条目类型外,一个目录还可以定义nextCatalog条目,以添加额外的目录条目文件。</target>
        </trans-unit>
        <trans-unit id="18c728a111c8455b1f773c9317d47ab5f17511c4" translate="yes" xml:space="preserve">
          <source>In addition to the abstract methods of &lt;a href=&quot;view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt;, subclasses of &lt;code&gt;CompositeView&lt;/code&gt; will need to override:</source>
          <target state="translated">除了&lt;a href=&quot;view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt;的抽象方法外， &lt;code&gt;CompositeView&lt;/code&gt; 的子类还需要重写：</target>
        </trans-unit>
        <trans-unit id="ce31b60794642f2f5ac852c05072694e4e7f3686" translate="yes" xml:space="preserve">
          <source>In addition to the actions performed by the &lt;a href=&quot;#shutdown()&quot;&gt;&lt;code&gt;shutdown&lt;/code&gt;&lt;/a&gt; method, this method invokes the &lt;a href=&quot;asynchronouschannel#close()&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt; method on all open channels in the group. This method does not attempt to stop or interrupt threads that are executing completion handlers. The group terminates when all actively executing completion handlers have run to completion and all resources have been released. This method may be invoked at any time. If some other thread has already invoked it, then another invocation will block until the first invocation is complete, after which it will return without effect.</source>
          <target state="translated">除了&lt;a href=&quot;#shutdown()&quot;&gt; &lt;code&gt;shutdown&lt;/code&gt; &lt;/a&gt;方法执行的操作外，此方法还会在组中所有打开的通道上调用&lt;a href=&quot;asynchronouschannel#close()&quot;&gt; &lt;code&gt;close&lt;/code&gt; &lt;/a&gt;方法。此方法不会尝试停止或中断正在执行完成处理程序的线程。当所有活动执行的完成处理程序运行完毕并释放所有资源时，该组终止。可以随时调用此方法。如果某个其他线程已经调用了它，则另一个调用将阻塞，直到第一个调用完成为止，之后它将返回而没有任何效果。</target>
        </trans-unit>
        <trans-unit id="c50e8ec4869b062e7983b8307d360d622f72d425" translate="yes" xml:space="preserve">
          <source>In addition to the actions performed by the &lt;a href=&quot;asynchronouschannelgroup#shutdown--&quot;&gt;&lt;code&gt;shutdown&lt;/code&gt;&lt;/a&gt; method, this method invokes the &lt;a href=&quot;asynchronouschannel#close--&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt; method on all open channels in the group. This method does not attempt to stop or interrupt threads that are executing completion handlers. The group terminates when all actively executing completion handlers have run to completion and all resources have been released. This method may be invoked at any time. If some other thread has already invoked it, then another invocation will block until the first invocation is complete, after which it will return without effect.</source>
          <target state="translated">除了&lt;a href=&quot;asynchronouschannelgroup#shutdown--&quot;&gt; &lt;code&gt;shutdown&lt;/code&gt; &lt;/a&gt;方法执行的操作外，此方法还会在组中的所有打开通道上调用&lt;a href=&quot;asynchronouschannel#close--&quot;&gt; &lt;code&gt;close&lt;/code&gt; &lt;/a&gt;方法。此方法不会尝试停止或中断正在执行完成处理程序的线程。当所有活动执行的完成处理程序运行完毕并释放所有资源时，该组终止。可以随时调用此方法。如果某个其他线程已经调用了它，则另一个调用将被阻塞，直到第一个调用完成为止，之后它将返回而没有任何效果。</target>
        </trans-unit>
        <trans-unit id="db5536f8eff9177c520068c301225ff17b585888" translate="yes" xml:space="preserve">
          <source>In addition to the available calendar types returned by the &lt;a href=&quot;calendar#getAvailableCalendarTypes()&quot;&gt;&lt;code&gt;Calendar.getAvailableCalendarTypes&lt;/code&gt;&lt;/a&gt; method, &lt;code&gt;&quot;gregorian&quot;&lt;/code&gt; and &lt;code&gt;&quot;iso8601&quot;&lt;/code&gt; as aliases of &lt;code&gt;&quot;gregory&quot;&lt;/code&gt; can be used with this method.</source>
          <target state="translated">除了&lt;a href=&quot;calendar#getAvailableCalendarTypes()&quot;&gt; &lt;code&gt;Calendar.getAvailableCalendarTypes&lt;/code&gt; &lt;/a&gt;方法返回的可用日历类型外，此方法还可以使用别名 &lt;code&gt;&quot;gregorian&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;iso8601&quot;&lt;/code&gt; 作为 &lt;code&gt;&quot;gregory&quot;&lt;/code&gt; 别名。</target>
        </trans-unit>
        <trans-unit id="28f37e8f3f69aa56facb878f44fda7bd5bd3c674" translate="yes" xml:space="preserve">
          <source>In addition to the available calendar types returned by the &lt;a href=&quot;calendar#getAvailableCalendarTypes--&quot;&gt;&lt;code&gt;Calendar.getAvailableCalendarTypes&lt;/code&gt;&lt;/a&gt; method, &lt;code&gt;&quot;gregorian&quot;&lt;/code&gt; and &lt;code&gt;&quot;iso8601&quot;&lt;/code&gt; as aliases of &lt;code&gt;&quot;gregory&quot;&lt;/code&gt; can be used with this method.</source>
          <target state="translated">除了&lt;a href=&quot;calendar#getAvailableCalendarTypes--&quot;&gt; &lt;code&gt;Calendar.getAvailableCalendarTypes&lt;/code&gt; &lt;/a&gt;方法返回的可用日历类型外，此方法还可以使用别名 &lt;code&gt;&quot;gregorian&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;iso8601&quot;&lt;/code&gt; 作为 &lt;code&gt;&quot;gregory&quot;&lt;/code&gt; 别名。</target>
        </trans-unit>
        <trans-unit id="fd12ac6606823d59289f6ff193c3f677e411d491" translate="yes" xml:space="preserve">
          <source>In addition to the callback methods, the &lt;a href=&quot;#toBundleName(java.lang.String,java.util.Locale)&quot;&gt;&lt;code&gt;toBundleName&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#toResourceName(java.lang.String,java.lang.String)&quot;&gt;&lt;code&gt;toResourceName&lt;/code&gt;&lt;/a&gt; methods are defined primarily for convenience in implementing the callback methods. However, the &lt;code&gt;toBundleName&lt;/code&gt; method could be overridden to provide different conventions in the organization and packaging of localized resources. The &lt;code&gt;toResourceName&lt;/code&gt; method is &lt;code&gt;final&lt;/code&gt; to avoid use of wrong resource and class name separators.</source>
          <target state="translated">除了回调方法外，主要是为了方便实现回调方法，还定义了&lt;a href=&quot;#toBundleName(java.lang.String,java.util.Locale)&quot;&gt; &lt;code&gt;toBundleName&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#toResourceName(java.lang.String,java.lang.String)&quot;&gt; &lt;code&gt;toResourceName&lt;/code&gt; &lt;/a&gt;方法。但是，可以重写 &lt;code&gt;toBundleName&lt;/code&gt; 方法以在本地化资源的组织和打包中提供不同的约定。 &lt;code&gt;final&lt;/code&gt; 的 &lt;code&gt;toResourceName&lt;/code&gt; 方法是避免使用错误的资源和类名称分隔符的方法。</target>
        </trans-unit>
        <trans-unit id="e0a216003ee5984925855b502c7955bbfbb35501" translate="yes" xml:space="preserve">
          <source>In addition to the callback methods, the &lt;a href=&quot;resourcebundle.control#toBundleName-java.lang.String-java.util.Locale-&quot;&gt;&lt;code&gt;toBundleName&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;resourcebundle.control#toResourceName-java.lang.String-java.lang.String-&quot;&gt;&lt;code&gt;toResourceName&lt;/code&gt;&lt;/a&gt; methods are defined primarily for convenience in implementing the callback methods. However, the &lt;code&gt;toBundleName&lt;/code&gt; method could be overridden to provide different conventions in the organization and packaging of localized resources. The &lt;code&gt;toResourceName&lt;/code&gt; method is &lt;code&gt;final&lt;/code&gt; to avoid use of wrong resource and class name separators.</source>
          <target state="translated">除了回调方法外，主要是为了方便实现回调方法，还定义了&lt;a href=&quot;resourcebundle.control#toBundleName-java.lang.String-java.util.Locale-&quot;&gt; &lt;code&gt;toBundleName&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;resourcebundle.control#toResourceName-java.lang.String-java.lang.String-&quot;&gt; &lt;code&gt;toResourceName&lt;/code&gt; &lt;/a&gt;方法。但是，可以重写 &lt;code&gt;toBundleName&lt;/code&gt; 方法以在本地化资源的组织和打包中提供不同的约定。 &lt;code&gt;final&lt;/code&gt; 的 &lt;code&gt;toResourceName&lt;/code&gt; 方法是避免使用错误的资源和类名称分隔符的方法。</target>
        </trans-unit>
        <trans-unit id="491aa20d021002d74c407245ae5546393cb48e59" translate="yes" xml:space="preserve">
          <source>In addition to the date-time parameters, the &lt;a href=&quot;#setLocale(java.util.Locale)&quot;&gt;locale&lt;/a&gt;, &lt;a href=&quot;#setTimeZone(java.util.TimeZone)&quot;&gt;time zone&lt;/a&gt;, &lt;a href=&quot;#setWeekDefinition(int,int)&quot;&gt;week definition&lt;/a&gt;, and &lt;a href=&quot;#setLenient(boolean)&quot;&gt;leniency mode&lt;/a&gt; parameters can be set.</source>
          <target state="translated">除了日期时间参数外，还可以设置&lt;a href=&quot;#setLocale(java.util.Locale)&quot;&gt;locale&lt;/a&gt;，&lt;a href=&quot;#setTimeZone(java.util.TimeZone)&quot;&gt;time zone&lt;/a&gt;，&lt;a href=&quot;#setWeekDefinition(int,int)&quot;&gt;week定义&lt;/a&gt;和&lt;a href=&quot;#setLenient(boolean)&quot;&gt;宽大处理模式&lt;/a&gt;参数。</target>
        </trans-unit>
        <trans-unit id="cfc19ac6ac647d4ae06152ad3a7c4c90d5c62ae5" translate="yes" xml:space="preserve">
          <source>In addition to the date-time parameters, the &lt;a href=&quot;calendar.builder#setLocale-java.util.Locale-&quot;&gt;locale&lt;/a&gt;, &lt;a href=&quot;calendar.builder#setTimeZone-java.util.TimeZone-&quot;&gt;time zone&lt;/a&gt;, &lt;a href=&quot;calendar.builder#setWeekDefinition-int-int-&quot;&gt;week definition&lt;/a&gt;, and &lt;a href=&quot;calendar.builder#setLenient-boolean-&quot;&gt;leniency mode&lt;/a&gt; parameters can be set.</source>
          <target state="translated">除了日期时间参数外，还可以设置&lt;a href=&quot;calendar.builder#setLocale-java.util.Locale-&quot;&gt;locale&lt;/a&gt;，&lt;a href=&quot;calendar.builder#setTimeZone-java.util.TimeZone-&quot;&gt;time zone&lt;/a&gt;，&lt;a href=&quot;calendar.builder#setWeekDefinition-int-int-&quot;&gt;week定义&lt;/a&gt;和&lt;a href=&quot;calendar.builder#setLenient-boolean-&quot;&gt;宽大处理模式&lt;/a&gt;参数。</target>
        </trans-unit>
        <trans-unit id="7614b1698980716dbcbacae739451584fa463381" translate="yes" xml:space="preserve">
          <source>In addition to the encoding, the audio format includes other properties that further specify the exact arrangement of the data. These include the number of channels, sample rate, sample size, byte order, frame rate, and frame size. Sounds may have different numbers of audio channels: one for mono, two for stereo. The sample rate measures how many &quot;snapshots&quot; (samples) of the sound pressure are taken per second, per channel. (If the sound is stereo rather than mono, two samples are actually measured at each instant of time: one for the left channel, and another for the right channel; however, the sample rate still measures the number per channel, so the rate is the same regardless of the number of channels. This is the standard use of the term.) The sample size indicates how many bits are used to store each snapshot; 8 and 16 are typical values. For 16-bit samples (or any other sample size larger than a byte), byte order is important; the bytes in each sample are arranged in either the &quot;little-endian&quot; or &quot;big-endian&quot; style. For encodings like PCM, a frame consists of the set of samples for all channels at a given point in time, and so the size of a frame (in bytes) is always equal to the size of a sample (in bytes) times the number of channels. However, with some other sorts of encodings a frame can contain a bundle of compressed data for a whole series of samples, as well as additional, non-sample data. For such encodings, the sample rate and sample size refer to the data after it is decoded into PCM, and so they are completely different from the frame rate and frame size.</source>
          <target state="translated">除了编码之外,音频格式还包括其他属性,这些属性进一步指定了数据的确切安排。这些属性包括通道数、采样率、采样大小、字节顺序、帧率和帧大小。声音可能有不同数量的音频通道:一个为单声道,两个为立体声。采样率测量的是每个通道每秒有多少声压的 &quot;快照&quot;(采样)。如果声音是立体声,而不是单声道,实际上是在每个瞬间测量两个样本:一个为左声道,另一个为右声道,然而,采样率仍然测量每个通道的数量,所以无论通道数量如何,速率是相同的。这是该术语的标准用法)。)采样大小表示用于存储每个快照的比特数;8和16是典型的值。对于16位的样本(或任何其他大于一个字节的样本大小),字节顺序是很重要的;每个样本中的字节以 &quot;小恩迪安 &quot;或 &quot;大恩迪安 &quot;的方式排列。对于像PCM这样的编码,一帧由所有通道在给定时间点的采样集组成,因此一帧的大小(以字节为单位)总是等于采样的大小(以字节为单位)乘以通道数。然而,对于一些其他类型的编码,一个帧可以包含一整系列样本的压缩数据束,以及额外的非样本数据。对于这种编码,采样率和采样大小指的是数据被解码成PCM后的数据,因此它们与帧率和帧大小完全不同。</target>
        </trans-unit>
        <trans-unit id="d6a83c2e73788cf89b876bfa744823e9380a8ac0" translate="yes" xml:space="preserve">
          <source>In addition to the familiar read, write, and close operations of byte channels, this class defines the following file-specific operations:</source>
          <target state="translated">除了我们熟悉的字节通道的读、写和关闭操作外,这个类还定义了以下文件专用操作。</target>
        </trans-unit>
        <trans-unit id="4f1190da5af20b63b0a7ea53b9dcbc33953d6769" translate="yes" xml:space="preserve">
          <source>In addition to the format, formatters can be created with desired Locale, Chronology, ZoneId, and DecimalStyle.</source>
          <target state="translated">除了格式之外,还可以使用所需的Locale、Chronology、ZoneId和DecimalStyle来创建格式。</target>
        </trans-unit>
        <trans-unit id="1e059e38a779b1f301213b52de153cb2600a26b3" translate="yes" xml:space="preserve">
          <source>In addition to the method area, a Java virtual machine implementation may require memory for internal processing or optimization which also belongs to non-heap memory. For example, the JIT compiler requires memory for storing the native machine code translated from the Java virtual machine code for high performance.</source>
          <target state="translated">除了方法区外,Java虚拟机实现可能还需要用于内部处理或优化的内存,这些内存也属于非堆内存。例如,JIT编译器需要内存来存储从Java虚拟机代码翻译过来的本机代码,以实现高性能。</target>
        </trans-unit>
        <trans-unit id="ee283b61b3d9459d225d145542e24d6b57b4d6d2" translate="yes" xml:space="preserve">
          <source>In addition to the methods defined by this class, a file store may support one or more &lt;a href=&quot;attribute/filestoreattributeview&quot;&gt;&lt;code&gt;FileStoreAttributeView&lt;/code&gt;&lt;/a&gt; classes that provide a read-only or updatable view of a set of file store attributes.</source>
          <target state="translated">除了此类定义的方法之外，文件存储还可以支持一个或多个&lt;a href=&quot;attribute/filestoreattributeview&quot;&gt; &lt;code&gt;FileStoreAttributeView&lt;/code&gt; &lt;/a&gt;类，这些类提供一组文件存储属性的只读或可更新视图。</target>
        </trans-unit>
        <trans-unit id="2986e636ae207892e9dac39e23fe9879168cb86f" translate="yes" xml:space="preserve">
          <source>In addition to the methods provided by Document and StyledDocument for mutating an HTMLDocument, HTMLDocument provides a number of convenience methods. The following methods can be used to insert HTML content into an existing document.</source>
          <target state="translated">除了Document和StyledDocument提供的用于突变HTMLDocument的方法外,HTMLDocument还提供了一些方便的方法。以下方法可用于在现有文档中插入HTML内容。</target>
        </trans-unit>
        <trans-unit id="432330f85a6a85defb1d0daea6e69ee9342c7288" translate="yes" xml:space="preserve">
          <source>In addition to the network-oriented channels described in &lt;a href=&quot;../nio/channels/spi/selectorprovider#inheritedChannel()&quot;&gt;&lt;code&gt;inheritedChannel&lt;/code&gt;&lt;/a&gt;, this method may return other kinds of channels in the future.</source>
          <target state="translated">除了在所描述的面向网络的信道&lt;a href=&quot;../nio/channels/spi/selectorprovider#inheritedChannel()&quot;&gt; &lt;code&gt;inheritedChannel&lt;/code&gt; &lt;/a&gt;，这种方法可能会在将来返回其他种信道。</target>
        </trans-unit>
        <trans-unit id="6b02ab5a714cd80e6567da7665467edf7fd5e8ed" translate="yes" xml:space="preserve">
          <source>In addition to the network-oriented channels described in &lt;a href=&quot;../nio/channels/spi/selectorprovider#inheritedChannel--&quot;&gt;&lt;code&gt;inheritedChannel&lt;/code&gt;&lt;/a&gt;, this method may return other kinds of channels in the future.</source>
          <target state="translated">除了在所描述的面向网络的信道&lt;a href=&quot;../nio/channels/spi/selectorprovider#inheritedChannel--&quot;&gt; &lt;code&gt;inheritedChannel&lt;/code&gt; &lt;/a&gt;，这种方法可能会在将来返回其他种信道。</target>
        </trans-unit>
        <trans-unit id="a33bc2b0c620d7bc4fb0799e179286bb4b725634" translate="yes" xml:space="preserve">
          <source>In addition to the network-oriented channels described, this method may return other kinds of channels in the future.</source>
          <target state="translated">除了所述的面向网络的通道外,本方法将来还可能返回其他种类的通道。</target>
        </trans-unit>
        <trans-unit id="a905ba3369b4a4f562d01a3f87216887f67f158a" translate="yes" xml:space="preserve">
          <source>In addition to the parameters described here, other GCM inputs/output (Additional Authenticated Data (AAD), Keys, block ciphers, plain/ciphertext and authentication tags) are handled in the &lt;code&gt;
 Cipher&lt;/code&gt; class.</source>
          <target state="translated">除此处描述的参数外，其他GCM输入/输出（附加身份验证数据（AAD），密钥，分组密码，明文/密文和身份验证标签）在 &lt;code&gt; Cipher&lt;/code&gt; 类中进行处理。</target>
        </trans-unit>
        <trans-unit id="6ed6b95a08d3c44af62e52f25de87e487d831331" translate="yes" xml:space="preserve">
          <source>In addition to the parameters described here, other GCM inputs/output (Additional Authenticated Data (AAD), Keys, block ciphers, plain/ciphertext and authentication tags) are handled in the &lt;code&gt;Cipher&lt;/code&gt; class.</source>
          <target state="translated">除了此处描述的参数外，其他GCM输入/输出（附加身份验证数据（AAD），密钥，分组密码，明文/密文和身份验证标签）都在 &lt;code&gt;Cipher&lt;/code&gt; 类中进行处理。</target>
        </trans-unit>
        <trans-unit id="2068645f319b6e731f1184b3eeafec498fde158b" translate="yes" xml:space="preserve">
          <source>In addition to the parameters recognized by the &lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#DOMConfiguration&quot;&gt;DOMConfiguration&lt;/a&gt; interface defined in [&lt;a href=&quot;http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407&quot;&gt;DOM Level 3 Core&lt;/a&gt;] , the &lt;code&gt;DOMConfiguration&lt;/code&gt; objects for &lt;code&gt;LSSerializer&lt;/code&gt; adds, or modifies, the following parameters:</source>
          <target state="translated">除了[ &lt;a href=&quot;http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407&quot;&gt;DOM Level 3 Core&lt;/a&gt; ]中定义的&lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#DOMConfiguration&quot;&gt;DOMConfiguration&lt;/a&gt;接口可以识别的参数外，用于 &lt;code&gt;LSSerializer&lt;/code&gt; 的 &lt;code&gt;DOMConfiguration&lt;/code&gt; 对象还添加或修改了以下参数：</target>
        </trans-unit>
        <trans-unit id="613cd728eab98e323895a85a69de5a14558afcc1" translate="yes" xml:space="preserve">
          <source>In addition to the parameters recognized by the &lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#DOMConfiguration&quot;&gt;DOMConfiguration&lt;/a&gt; interface defined in [&lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407&quot;&gt;DOM Level 3 Core&lt;/a&gt;] , the &lt;code&gt;DOMConfiguration&lt;/code&gt; objects for &lt;code&gt;LSSerializer&lt;/code&gt; adds, or modifies, the following parameters:</source>
          <target state="translated">除了[ &lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407&quot;&gt;DOM Level 3 Core&lt;/a&gt; ]中定义的&lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#DOMConfiguration&quot;&gt;DOMConfiguration&lt;/a&gt;接口可以识别的参数外，用于 &lt;code&gt;LSSerializer&lt;/code&gt; 的 &lt;code&gt;DOMConfiguration&lt;/code&gt; 对象还添加或修改了以下参数：</target>
        </trans-unit>
        <trans-unit id="48faa16800a54ef7adf79ec21201779ba48c231e" translate="yes" xml:space="preserve">
          <source>In addition to the parameters recognized in on the &lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#DOMConfiguration&quot;&gt;DOMConfiguration&lt;/a&gt; interface defined in [&lt;a href=&quot;http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407&quot;&gt;DOM Level 3 Core&lt;/a&gt;] , the &lt;code&gt;DOMConfiguration&lt;/code&gt; objects for &lt;code&gt;LSParser&lt;/code&gt; add or modify the following parameters:</source>
          <target state="translated">除了在[ &lt;a href=&quot;http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407&quot;&gt;DOM Level 3 Core&lt;/a&gt; ]中定义的&lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#DOMConfiguration&quot;&gt;DOMConfiguration&lt;/a&gt;接口上识别的参数外，用于 &lt;code&gt;LSParser&lt;/code&gt; 的 &lt;code&gt;DOMConfiguration&lt;/code&gt; 对象还添加或修改了以下参数：</target>
        </trans-unit>
        <trans-unit id="34a97b50c3e99b889dd35851dc73d89e83ed43d9" translate="yes" xml:space="preserve">
          <source>In addition to the parameters recognized in on the &lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#DOMConfiguration&quot;&gt;DOMConfiguration&lt;/a&gt; interface defined in [&lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407&quot;&gt;DOM Level 3 Core&lt;/a&gt;] , the &lt;code&gt;DOMConfiguration&lt;/code&gt; objects for &lt;code&gt;LSParser&lt;/code&gt; add or modify the following parameters:</source>
          <target state="translated">除了在[ &lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407&quot;&gt;DOM Level 3 Core&lt;/a&gt; ]中定义的&lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#DOMConfiguration&quot;&gt;DOMConfiguration&lt;/a&gt;接口上识别的参数外，用于 &lt;code&gt;LSParser&lt;/code&gt; 的 &lt;code&gt;DOMConfiguration&lt;/code&gt; 对象还添加或修改了以下参数：</target>
        </trans-unit>
        <trans-unit id="6f624142e4495c5af474cb0a78db2e72fbaa8b70" translate="yes" xml:space="preserve">
          <source>In addition to the predefined implementations in &lt;a href=&quot;collectors&quot;&gt;&lt;code&gt;Collectors&lt;/code&gt;&lt;/a&gt;, the static factory methods &lt;a href=&quot;#of(java.util.function.Supplier,java.util.function.BiConsumer,java.util.function.BinaryOperator,java.util.stream.Collector.Characteristics...)&quot;&gt;&lt;code&gt;of(Supplier, BiConsumer, BinaryOperator, Characteristics...)&lt;/code&gt;&lt;/a&gt; can be used to construct collectors. For example, you could create a collector that accumulates widgets into a &lt;code&gt;TreeSet&lt;/code&gt; with:</source>
          <target state="translated">除了&lt;a href=&quot;collectors&quot;&gt; &lt;code&gt;Collectors&lt;/code&gt; 中&lt;/a&gt;的预定义实现之外&lt;a href=&quot;#of(java.util.function.Supplier,java.util.function.BiConsumer,java.util.function.BinaryOperator,java.util.stream.Collector.Characteristics...)&quot;&gt; &lt;code&gt;of(Supplier, BiConsumer, BinaryOperator, Characteristics...)&lt;/code&gt; &lt;/a&gt;的静态工厂方法也可以用于构造Collector。例如，您可以创建一个收集器，该收集器使用以下命令将小部件累积到 &lt;code&gt;TreeSet&lt;/code&gt; 中：</target>
        </trans-unit>
        <trans-unit id="df0afba264acde97691ac7208acbd4a41b35b800" translate="yes" xml:space="preserve">
          <source>In addition to the predefined implementations in &lt;a href=&quot;collectors&quot;&gt;&lt;code&gt;Collectors&lt;/code&gt;&lt;/a&gt;, the static factory methods &lt;a href=&quot;collector#of-java.util.function.Supplier-java.util.function.BiConsumer-java.util.function.BinaryOperator-java.util.stream.Collector.Characteristics...-&quot;&gt;&lt;code&gt;of(Supplier, BiConsumer, BinaryOperator, Characteristics...)&lt;/code&gt;&lt;/a&gt; can be used to construct collectors. For example, you could create a collector that accumulates widgets into a &lt;code&gt;TreeSet&lt;/code&gt; with:</source>
          <target state="translated">除了&lt;a href=&quot;collectors&quot;&gt; &lt;code&gt;Collectors&lt;/code&gt; 中&lt;/a&gt;的预定义实现之外&lt;a href=&quot;collector#of-java.util.function.Supplier-java.util.function.BiConsumer-java.util.function.BinaryOperator-java.util.stream.Collector.Characteristics...-&quot;&gt; &lt;code&gt;of(Supplier, BiConsumer, BinaryOperator, Characteristics...)&lt;/code&gt; &lt;/a&gt;的静态工厂方法也可以用于构造Collector。例如，您可以创建一个收集器，通过以下方式将小部件累积到 &lt;code&gt;TreeSet&lt;/code&gt; 中：</target>
        </trans-unit>
        <trans-unit id="adf89d4fe796fb988f7407950dd9eefb826761d9" translate="yes" xml:space="preserve">
          <source>In addition to the properties of the super class, the &lt;code&gt;Expression&lt;/code&gt; object provides a &lt;em&gt;value&lt;/em&gt; which is the object returned when this expression is evaluated. The return value is typically not provided by the caller and is instead computed by dynamically finding the method and invoking it when the first call to &lt;code&gt;getValue&lt;/code&gt; is made.</source>
          <target state="translated">除了超类的属性外， &lt;code&gt;Expression&lt;/code&gt; 对象还提供一个&lt;em&gt;值&lt;/em&gt;，该&lt;em&gt;值&lt;/em&gt;是计算该表达式时返回的对象。返回值通常不是由调用者提供的，而是通过动态查找方法并在首次调用 &lt;code&gt;getValue&lt;/code&gt; 时调用该方法来计算的。</target>
        </trans-unit>
        <trans-unit id="d2394c9520c75ba71dccb27ec850e0d98f0290f5" translate="yes" xml:space="preserve">
          <source>In addition to the restrictions on characters spelt out above, no part of an ObjectName may contain a newline character (&lt;code&gt;'\n'&lt;/code&gt;), whether the domain, a key, or a value, whether quoted or unquoted. The newline character can be represented in a quoted value with the sequence &lt;code&gt;\n&lt;/code&gt;.</source>
          <target state="translated">除了上面阐明的字符限制外，ObjectName的任何部分都不能包含换行符（ &lt;code&gt;'\n'&lt;/code&gt; ），无论是域，键还是值（带引号或不带引号）。换行符可以用带引号的 &lt;code&gt;\n&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c33e9e8d1cb86388922d67f15e1b30f1c2d89d24" translate="yes" xml:space="preserve">
          <source>In addition to the scroll bars and viewport, a &lt;code&gt;JScrollPane&lt;/code&gt; can have a column header and a row header. Each of these is a &lt;code&gt;JViewport&lt;/code&gt; object that you specify with &lt;code&gt;setRowHeaderView&lt;/code&gt;, and &lt;code&gt;setColumnHeaderView&lt;/code&gt;. The column header viewport automatically scrolls left and right, tracking the left-right scrolling of the main viewport. (It never scrolls vertically, however.) The row header acts in a similar fashion.</source>
          <target state="translated">除了滚动条和视口之外， &lt;code&gt;JScrollPane&lt;/code&gt; 还可具有列标题和行标题。每个对象都是您使用 &lt;code&gt;setRowHeaderView&lt;/code&gt; 和 &lt;code&gt;setColumnHeaderView&lt;/code&gt; 指定的 &lt;code&gt;JViewport&lt;/code&gt; 对象。列标题视口会自动向左和向右滚动，从而跟踪主视口的左右滚动。（但是，它永远不会垂直滚动。）行标题的行为与此类似。</target>
        </trans-unit>
        <trans-unit id="b2c1ff8172f1e7aba63f37e75d386a7d225ec94c" translate="yes" xml:space="preserve">
          <source>In addition to the standard session attributes, SSL sessions expose these read-only attributes:</source>
          <target state="translated">除了标准会话属性外,SSL会话还暴露了这些只读属性。</target>
        </trans-unit>
        <trans-unit id="9f4f266b17adc8e2aeb86a93d5446474a986f525" translate="yes" xml:space="preserve">
          <source>In addition to the standard system properties, the system properties may include the following keys:</source>
          <target state="translated">除标准系统属性外,系统属性还可包括以下键。</target>
        </trans-unit>
        <trans-unit id="83938c315c82af2806ebd155f43016814eda7fb4" translate="yes" xml:space="preserve">
          <source>In addition to the textual enum name, each day-of-week has an &lt;code&gt;int&lt;/code&gt; value. The &lt;code&gt;int&lt;/code&gt; value follows the ISO-8601 standard, from 1 (Monday) to 7 (Sunday). It is recommended that applications use the enum rather than the &lt;code&gt;int&lt;/code&gt; value to ensure code clarity.</source>
          <target state="translated">除了文本枚举名称外，每周的每一天都有一个 &lt;code&gt;int&lt;/code&gt; 值。的 &lt;code&gt;int&lt;/code&gt; 值遵循ISO-8601标准，从1（星期一）至7（星期日）。建议应用程序使用枚举而不是 &lt;code&gt;int&lt;/code&gt; 值，以确保代码清晰。</target>
        </trans-unit>
        <trans-unit id="2d4d3851f8f7049f215ed834737db941515f6412" translate="yes" xml:space="preserve">
          <source>In addition to the textual enum name, each month-of-year has an &lt;code&gt;int&lt;/code&gt; value. The &lt;code&gt;int&lt;/code&gt; value follows normal usage and the ISO-8601 standard, from 1 (January) to 12 (December). It is recommended that applications use the enum rather than the &lt;code&gt;int&lt;/code&gt; value to ensure code clarity.</source>
          <target state="translated">除文本枚举名称外，每年的每个月都有一个 &lt;code&gt;int&lt;/code&gt; 值。的 &lt;code&gt;int&lt;/code&gt; 值遵循正常使用和ISO-8601标准，从1（1月）到12（12月）。建议应用程序使用枚举而不是 &lt;code&gt;int&lt;/code&gt; 值，以确保代码清晰。</target>
        </trans-unit>
        <trans-unit id="dbbe182566bca48d0fbeb7cd780b3e1c5f49a252" translate="yes" xml:space="preserve">
          <source>In addition to the usage restrictions imposed by its &lt;a href=&quot;annotation/target&quot;&gt;&lt;code&gt;@Target&lt;/code&gt;&lt;/a&gt; meta-annotation, compilers are required to implement additional usage restrictions on this annotation type; it is a compile-time error if a method or constructor declaration is annotated with a &lt;code&gt;@SafeVarargs&lt;/code&gt; annotation, and either:</source>
          <target state="translated">除了其&lt;a href=&quot;annotation/target&quot;&gt; &lt;code&gt;@Target&lt;/code&gt; &lt;/a&gt;元注释所施加的使用限制之外，还要求编译器对此注释类型实施附加的使用限制。如果用 &lt;code&gt;@SafeVarargs&lt;/code&gt; 批注对方法或构造函数声明进行批注，并且是以下两种情况，则是编译时错误：</target>
        </trans-unit>
        <trans-unit id="48906b2213eda76c1ef9cb3120b0f8752c37d2ea" translate="yes" xml:space="preserve">
          <source>In addition to these and related methods for directly manipulating status and results, CompletableFuture implements interface &lt;a href=&quot;completionstage&quot;&gt;&lt;code&gt;CompletionStage&lt;/code&gt;&lt;/a&gt; with the following policies:</source>
          <target state="translated">除了这些和直接处理状态和结果的相关方法外，CompletableFuture还使用以下策略实现接口&lt;a href=&quot;completionstage&quot;&gt; &lt;code&gt;CompletionStage&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="f1816d3d4810c4371cbfeb9a6ae404d0e121f11c" translate="yes" xml:space="preserve">
          <source>In addition to this general contract, record classes must further participate in the invariant that any two records which are &lt;a href=&quot;#equals(java.lang.Object)&quot;&gt;equal&lt;/a&gt; must produce equal strings. This invariant is necessarily relaxed in the rare case where corresponding equal component values might fail to produce equal strings for themselves.</source>
          <target state="translated">除此一般约定外，记录类还必须参与不变的条件，即任何两个&lt;a href=&quot;#equals(java.lang.Object)&quot;&gt;相等的&lt;/a&gt;记录都必须产生相等的字符串。在极少数情况下，此不变式必须放宽，在这种情况下，相应的相等分量值可能无法为其自身生成相等的字符串。</target>
        </trans-unit>
        <trans-unit id="53919e02325aec34ba4ab39d138ab42852e587c0" translate="yes" xml:space="preserve">
          <source>In addition to using a delegation model, this persistence scheme differs from traditional serialization schemes in requiring an analog of the &lt;code&gt;writeObject&lt;/code&gt; method without a corresponding &lt;code&gt;readObject&lt;/code&gt; method. The &lt;code&gt;writeObject&lt;/code&gt; analog encodes each instance in terms of its public API and there is no need to define a &lt;code&gt;readObject&lt;/code&gt; analog since the procedure for reading the serialized form is defined by the semantics of method invocation as laid out in the Java Language Specification. Breaking the dependency between &lt;code&gt;writeObject&lt;/code&gt; and &lt;code&gt;readObject&lt;/code&gt; implementations, which may change from version to version, is the key factor in making the archives produced by this technique immune to changes in the private implementations of the classes to which they refer.</source>
          <target state="translated">除了使用委派模型外，此持久性方案与传统的序列化方案的不同之处在于，它需要 &lt;code&gt;writeObject&lt;/code&gt; 方法的模拟，而没有相应的 &lt;code&gt;readObject&lt;/code&gt; 方法。所述 &lt;code&gt;writeObject&lt;/code&gt; 模拟在其公共API的方面编码每个实例，也没有必要限定 &lt;code&gt;readObject&lt;/code&gt; 因为该过程模拟用于读取序列化形式是通过方法调用的语义以Java语言规范制定了规定。打破 &lt;code&gt;writeObject&lt;/code&gt; 和 &lt;code&gt;readObject&lt;/code&gt; 之间的依赖关系实现可能会因版本而异，这是使使用此技术生成的归档不受其所引用类的私有实现更改的影响的关键因素。</target>
        </trans-unit>
        <trans-unit id="af9d69a85de071c5503c968b6878570e7a051f81" translate="yes" xml:space="preserve">
          <source>In addition,</source>
          <target state="translated">此外:</target>
        </trans-unit>
        <trans-unit id="d13d4f13ec02cd9aaa9c26800becfd83ad1806e2" translate="yes" xml:space="preserve">
          <source>In addition, &lt;code&gt;BorderLayout&lt;/code&gt; supports the relative positioning constants, &lt;code&gt;PAGE_START&lt;/code&gt;, &lt;code&gt;PAGE_END&lt;/code&gt;, &lt;code&gt;LINE_START&lt;/code&gt;, and &lt;code&gt;LINE_END&lt;/code&gt;. In a container whose &lt;code&gt;ComponentOrientation&lt;/code&gt; is set to &lt;code&gt;ComponentOrientation.LEFT_TO_RIGHT&lt;/code&gt;, these constants map to &lt;code&gt;NORTH&lt;/code&gt;, &lt;code&gt;SOUTH&lt;/code&gt;, &lt;code&gt;WEST&lt;/code&gt;, and &lt;code&gt;EAST&lt;/code&gt;, respectively.</source>
          <target state="translated">另外， &lt;code&gt;BorderLayout&lt;/code&gt; 支持相对定位常数 &lt;code&gt;PAGE_START&lt;/code&gt; ， &lt;code&gt;PAGE_END&lt;/code&gt; ， &lt;code&gt;LINE_START&lt;/code&gt; 和 &lt;code&gt;LINE_END&lt;/code&gt; 。在 &lt;code&gt;ComponentOrientation&lt;/code&gt; 设置为 &lt;code&gt;ComponentOrientation.LEFT_TO_RIGHT&lt;/code&gt; 的容器中，这些常量分别映射到 &lt;code&gt;NORTH&lt;/code&gt; ， &lt;code&gt;SOUTH&lt;/code&gt; ， &lt;code&gt;WEST&lt;/code&gt; 和 &lt;code&gt;EAST&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f1f23c6ebcae32c016f175cd630762e9b2b7d49f" translate="yes" xml:space="preserve">
          <source>In addition, &lt;code&gt;Runnable&lt;/code&gt; provides the means for a class to be active while not subclassing &lt;code&gt;Thread&lt;/code&gt;. A class that implements &lt;code&gt;Runnable&lt;/code&gt; can run without subclassing &lt;code&gt;Thread&lt;/code&gt; by instantiating a &lt;code&gt;Thread&lt;/code&gt; instance and passing itself in as the target. In most cases, the &lt;code&gt;Runnable&lt;/code&gt; interface should be used if you are only planning to override the &lt;code&gt;run()&lt;/code&gt; method and no other &lt;code&gt;Thread&lt;/code&gt; methods. This is important because classes should not be subclassed unless the programmer intends on modifying or enhancing the fundamental behavior of the class.</source>
          <target state="translated">另外， &lt;code&gt;Runnable&lt;/code&gt; 提供了一种使类在不继承 &lt;code&gt;Thread&lt;/code&gt; 的情况下处于活动状态的方法。实现 &lt;code&gt;Runnable&lt;/code&gt; 的类可以通过实例化 &lt;code&gt;Thread&lt;/code&gt; 实例并将其自身作为目标传递而无需继承 &lt;code&gt;Thread&lt;/code&gt; 的子类。在大多数情况下，如果您仅打算覆盖 &lt;code&gt;run()&lt;/code&gt; 方法而没有其他 &lt;code&gt;Thread&lt;/code&gt; 方法，则应使用 &lt;code&gt;Runnable&lt;/code&gt; 接口。这很重要，因为除非程序员打算修改或增强类的基本行为，否则不应将类归为子类。</target>
        </trans-unit>
        <trans-unit id="d0ffa912abbac66bc23c7cc4eb525a47987acde5" translate="yes" xml:space="preserve">
          <source>In addition, BCP 47 imposes syntax restrictions that are not imposed by Locale's constructors. This means that conversions between some Locales and BCP 47 language tags cannot be made without losing information. Thus &lt;code&gt;toLanguageTag&lt;/code&gt; cannot represent the state of locales whose language, country, or variant do not conform to BCP 47.</source>
          <target state="translated">此外，BCP 47施加了Locale的构造函数未施加的语法限制。这意味着在某些语言环境和BCP 47语言标记之间进行转换不会丢失信息。因此， &lt;code&gt;toLanguageTag&lt;/code&gt; 不能表示其语言，国家或变体不符合BCP 47的语言环境的状态。</target>
        </trans-unit>
        <trans-unit id="90c28b724a8b29cd571cc3e38dd5717b9002649b" translate="yes" xml:space="preserve">
          <source>In addition, NimbusStyle handles ColorTypes slightly differently from Synth.</source>
          <target state="translated">此外,NimbusStyle处理ColorTypes的方式与Synth略有不同。</target>
        </trans-unit>
        <trans-unit id="579421e1e85ce32e6e5ea22308534b8f6511e547" translate="yes" xml:space="preserve">
          <source>In addition, a layer cannot be created if the configuration contains a module named &quot;&lt;code&gt;java.base&lt;/code&gt;&quot;, a configuration contains a module with a package named &quot;&lt;code&gt;java&lt;/code&gt;&quot; or a package name starting with &quot;&lt;code&gt;java.&lt;/code&gt;&quot;, or the function to map a module name to a class loader returns &lt;code&gt;null&lt;/code&gt; or the &lt;a href=&quot;classloader#getPlatformClassLoader()&quot;&gt;platform class loader&lt;/a&gt;.</source>
          <target state="translated">此外，如果配置包含名为&amp;ldquo; &lt;code&gt;java.base&lt;/code&gt; &amp;rdquo;的模块，配置包含包含名为&amp;ldquo; &lt;code&gt;java&lt;/code&gt; &amp;rdquo;的程序包或以&amp;ldquo; java &amp;rdquo;开头的程序包名称的模块或映射a的函数的层，则无法创建层 &lt;code&gt;java.&lt;/code&gt; 向类加载器发送的模块名称返回 &lt;code&gt;null&lt;/code&gt; 或&lt;a href=&quot;classloader#getPlatformClassLoader()&quot;&gt;平台类加载&lt;/a&gt;器返回。</target>
        </trans-unit>
        <trans-unit id="6bbe447b352cd3c67e1d9564f1a4f7893ccf3bb5" translate="yes" xml:space="preserve">
          <source>In addition, a layer cannot be created if the configuration contains a module named &quot;&lt;code&gt;java.base&lt;/code&gt;&quot;, or a module contains a package named &quot;&lt;code&gt;java&lt;/code&gt;&quot; or a package with a name starting with &quot;&lt;code&gt;java.&lt;/code&gt;&quot;.</source>
          <target state="translated">另外，如果配置中包含名为&amp;ldquo; &lt;code&gt;java.base&lt;/code&gt; &amp;rdquo;的模块，或模块包含名为&amp;ldquo; &lt;code&gt;java&lt;/code&gt; &amp;rdquo;的程序包或名称以&amp;ldquo; &lt;code&gt;java.&lt;/code&gt; &amp;rdquo;开头的程序包，则无法创建层。</target>
        </trans-unit>
        <trans-unit id="0dca754d6c2d6b8518fc03f50d1c276e3093b30c" translate="yes" xml:space="preserve">
          <source>In addition, an application can use the &lt;code&gt;SyncProvider&lt;/code&gt; object returned by this method to call methods that return information about the &lt;code&gt;SyncProvider&lt;/code&gt; object, including information about the vendor, version, provider identification, synchronization grade, and locks it currently has set.</source>
          <target state="translated">此外，应用程序可以使用此方法返回的 &lt;code&gt;SyncProvider&lt;/code&gt; 对象来调用返回有关 &lt;code&gt;SyncProvider&lt;/code&gt; 对象的信息的方法，这些信息包括有关供应商，版本，提供者标识，同步等级以及它当前设置的锁定的信息。</target>
        </trans-unit>
        <trans-unit id="0fe92cfe39db7917857638c730c6e8a9d72af5f4" translate="yes" xml:space="preserve">
          <source>In addition, an application must specify constraints on the target certificate that the &lt;code&gt;CertPathBuilder&lt;/code&gt; will attempt to build a path to. The constraints are specified as a &lt;code&gt;CertSelector&lt;/code&gt; object. These constraints should provide the &lt;code&gt;CertPathBuilder&lt;/code&gt; with enough search criteria to find the target certificate. Minimal criteria for an &lt;code&gt;X509Certificate&lt;/code&gt; usually include the subject name and/or one or more subject alternative names. If enough criteria is not specified, the &lt;code&gt;CertPathBuilder&lt;/code&gt; may throw a &lt;code&gt;CertPathBuilderException&lt;/code&gt;.</source>
          <target state="translated">此外，应用程序必须在目标证书上指定 &lt;code&gt;CertPathBuilder&lt;/code&gt; 将尝试为其建立路径的约束。约束被指定为 &lt;code&gt;CertSelector&lt;/code&gt; 对象。这些限制应为 &lt;code&gt;CertPathBuilder&lt;/code&gt; 提供足够的搜索条件以找到目标证书。 &lt;code&gt;X509Certificate&lt;/code&gt; 最低标准通常包括主题名称和/或一个或多个主题备用名称。如果未指定足够的条件，则 &lt;code&gt;CertPathBuilder&lt;/code&gt; 可能会抛出 &lt;code&gt;CertPathBuilderException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a9e610984b972d7e5beb58e119cffbd2ab22c70f" translate="yes" xml:space="preserve">
          <source>In addition, an instance has four flags. These flags indicate:</source>
          <target state="translated">此外,一个实例有四个标志。这些标志表明:</target>
        </trans-unit>
        <trans-unit id="870e411531c039af2dbdb3bb6e5d628c5975e9bb" translate="yes" xml:space="preserve">
          <source>In addition, an offset mechanism enables particular counting intervals to be detected. If the offset value is not zero, whenever the threshold is triggered by the counter value reaching a comparison level, that comparison level is incremented by the offset value. This is regarded as taking place instantaneously, that is, before the count is incremented. Thus, for each level, the threshold triggers an event notification every time the count increases by an interval equal to the offset value.</source>
          <target state="translated">此外,偏移机制使特定的计数区间能够被检测出来。如果偏移值不为零,每当计数器值达到比较水平而触发阈值时,该比较水平就会被偏移值递增。这被认为是瞬时发生的,也就是说,在计数增量之前。因此,对于每个级别,每当计数增加一个等于偏移值的间隔时,阈值就会触发一个事件通知。</target>
        </trans-unit>
        <trans-unit id="a450ba34174b50c1a21d59970e5437dc6cb80f12" translate="yes" xml:space="preserve">
          <source>In addition, any &lt;code&gt;RowSet&lt;/code&gt; object created by this method will have the same properties as this &lt;code&gt;CachedRowSet&lt;/code&gt; object. For example, if this &lt;code&gt;CachedRowSet&lt;/code&gt; object is read-only, all of its duplicates will also be read-only. If it is changed to be updatable, the duplicates also become updatable.</source>
          <target state="translated">此外，此方法创建的任何 &lt;code&gt;RowSet&lt;/code&gt; 对象都具有与此 &lt;code&gt;CachedRowSet&lt;/code&gt; 对象相同的属性。例如，如果此 &lt;code&gt;CachedRowSet&lt;/code&gt; 对象为只读，则其所有重复项也将为只读。如果将其更改为可更新，则重复项也将变为可更新。</target>
        </trans-unit>
        <trans-unit id="53b8d630d402819b1f760ea377f44b6a16712937" translate="yes" xml:space="preserve">
          <source>In addition, any of the elements may be decorated by padding, either with spaces or any other character.</source>
          <target state="translated">此外,任何一个元素都可以用空格或任何其他字符来装饰。</target>
        </trans-unit>
        <trans-unit id="5b0ddda2d0f82cf4aed49fad8ad8b055e9a723d9" translate="yes" xml:space="preserve">
          <source>In addition, every character in a font has an</source>
          <target state="translated">此外,字体中的每个字符都有一个</target>
        </trans-unit>
        <trans-unit id="dc82c69af4f096ce0679e2968658d3aec212fcf3" translate="yes" xml:space="preserve">
          <source>In addition, for developers creating &lt;a href=&quot;spi/transportservice&quot;&gt;&lt;code&gt;TransportService&lt;/code&gt;&lt;/a&gt; implementations this exception is thrown when &lt;a href=&quot;spi/transportservice#attach(java.lang.String,long,long)&quot;&gt;&lt;code&gt;attach&lt;/code&gt;&lt;/a&gt; times out when establishing a connection to a target VM, or &lt;a href=&quot;spi/transportservice#accept(com.sun.jdi.connect.spi.TransportService.ListenKey,long,long)&quot;&gt;&lt;code&gt;accept&lt;/code&gt;&lt;/a&gt; times out while waiting for a target VM to connect.</source>
          <target state="translated">另外，对于创建&lt;a href=&quot;spi/transportservice&quot;&gt; &lt;code&gt;TransportService&lt;/code&gt; &lt;/a&gt;实现的开发人员，在建立与目标VM的连接时&lt;a href=&quot;spi/transportservice#attach(java.lang.String,long,long)&quot;&gt; &lt;code&gt;attach&lt;/code&gt; &lt;/a&gt;超时或在等待目标VM连接时&lt;a href=&quot;spi/transportservice#accept(com.sun.jdi.connect.spi.TransportService.ListenKey,long,long)&quot;&gt; &lt;code&gt;accept&lt;/code&gt; &lt;/a&gt;超时时，将引发此异常。</target>
        </trans-unit>
        <trans-unit id="fe6d4ce281cc41c2d663795cad62610decb0511e" translate="yes" xml:space="preserve">
          <source>In addition, if a &lt;a href=&quot;finishings&quot;&gt;&lt;code&gt;Finishings&lt;/code&gt;&lt;/a&gt; attribute of &lt;a href=&quot;finishings#STAPLE&quot;&gt;&lt;code&gt;STAPLE&lt;/code&gt;&lt;/a&gt; is specified, then:</source>
          <target state="translated">另外，如果指定了&lt;a href=&quot;finishings#STAPLE&quot;&gt; &lt;code&gt;STAPLE&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;finishings&quot;&gt; &lt;code&gt;Finishings&lt;/code&gt; &lt;/a&gt;属性，则：</target>
        </trans-unit>
        <trans-unit id="1fa3f127cf7a63d846e423fccda6af2e43a26b4b" translate="yes" xml:space="preserve">
          <source>In addition, if a &lt;code&gt;Map&lt;/code&gt; object is passed to one of the constructors or to the method &lt;code&gt;getAttributes&lt;/code&gt;, the structured type is custom mapped according to the mapping specified in the &lt;code&gt;Map&lt;/code&gt; object.</source>
          <target state="translated">另外，如果将 &lt;code&gt;Map&lt;/code&gt; 对象传递给构造函数之一或方法 &lt;code&gt;getAttributes&lt;/code&gt; ，则将根据 &lt;code&gt;Map&lt;/code&gt; 对象中指定的映射对结构化类型进行自定义映射。</target>
        </trans-unit>
        <trans-unit id="4c71d449e4a597019a72691ecc234388e0f7fdd8" translate="yes" xml:space="preserve">
          <source>In addition, if the class loader is not the bootstrap or &lt;a href=&quot;../lang/classloader#getPlatformClassLoader()&quot;&gt;platform class loader&lt;/a&gt;, then service providers may be located in the named modules of other class loaders. Specifically, if the class loader, or any class loader reachable via parent delegation, has a module in a &lt;a href=&quot;../lang/modulelayer&quot;&gt;module layer&lt;/a&gt;, then service providers in all modules in the module layer are located.</source>
          <target state="translated">另外，如果类加载器不是引导程序或&lt;a href=&quot;../lang/classloader#getPlatformClassLoader()&quot;&gt;平台类加载器&lt;/a&gt;，则服务提供者可能位于其他类加载器的命名模块中。具体来说，如果类加载器或通过父委派可访问的任何类加载器在&lt;a href=&quot;../lang/modulelayer&quot;&gt;模块层中&lt;/a&gt;都有一个模块，则将定位模块层中所有模块中的服务提供者。</target>
        </trans-unit>
        <trans-unit id="6693592d77694b84bdf498092215f9da7f914aab" translate="yes" xml:space="preserve">
          <source>In addition, if there are known attributes with default values, &lt;code&gt;Attr&lt;/code&gt; nodes representing them are automatically created and attached to the element.</source>
          <target state="translated">另外，如果存在具有默认值的已知属性，则表示它们的 &lt;code&gt;Attr&lt;/code&gt; 节点将自动创建并附加到元素。</target>
        </trans-unit>
        <trans-unit id="f8b9f82e72f2b3c1e6ed1ce52ca067600e701bc2" translate="yes" xml:space="preserve">
          <source>In addition, instances of &lt;a href=&quot;../java.compiler/javax/tools/javacompiler.compilationtask&quot;&gt;&lt;code&gt;JavaCompiler.CompilationTask&lt;/code&gt;&lt;/a&gt; obtained from &lt;a href=&quot;../java.compiler/javax/tools/javacompiler&quot;&gt;JavaCompiler&lt;/a&gt; can be downcast to &lt;a href=&quot;com/sun/source/util/javactask&quot;&gt;&lt;code&gt;JavacTask&lt;/code&gt;&lt;/a&gt; for access to lower level aspects of &lt;em&gt;javac&lt;/em&gt;, such as the &lt;a href=&quot;com/sun/source/tree/package-summary&quot;&gt;&lt;code&gt;Abstract Syntax Tree&lt;/code&gt;&lt;/a&gt; (AST).</source>
          <target state="translated">此外，可以将从&lt;a href=&quot;../java.compiler/javax/tools/javacompiler.compilationtask&quot;&gt; &lt;code&gt;JavaCompiler.CompilationTask&lt;/code&gt; &lt;/a&gt;获得的&lt;a href=&quot;../java.compiler/javax/tools/javacompiler&quot;&gt;JavaCompiler.CompilationTask&lt;/a&gt;实例下转换为&lt;a href=&quot;com/sun/source/util/javactask&quot;&gt; &lt;code&gt;JavacTask&lt;/code&gt; ,&lt;/a&gt;以访问&lt;em&gt;javac的&lt;/em&gt;较低方面，例如&lt;a href=&quot;com/sun/source/tree/package-summary&quot;&gt; &lt;code&gt;Abstract Syntax Tree&lt;/code&gt; &lt;/a&gt;（AST）。</target>
        </trans-unit>
        <trans-unit id="3719d936e29998d0689eb9e0adf828047d1a0f6c" translate="yes" xml:space="preserve">
          <source>In addition, its &lt;code&gt;checkPermission&lt;/code&gt; method is invoked with the &lt;code&gt;RuntimePermission(&quot;enableContextClassLoaderOverride&quot;)&lt;/code&gt; permission when invoked directly or indirectly by the constructor of a subclass which overrides the &lt;code&gt;getContextClassLoader&lt;/code&gt; or &lt;code&gt;setContextClassLoader&lt;/code&gt; methods.</source>
          <target state="translated">另外，当子类的构造方法覆盖 &lt;code&gt;getContextClassLoader&lt;/code&gt; 或 &lt;code&gt;setContextClassLoader&lt;/code&gt; 方法直接或间接调用该方法时，将使用 &lt;code&gt;RuntimePermission(&quot;enableContextClassLoaderOverride&quot;)&lt;/code&gt; 权限调用其 &lt;code&gt;checkPermission&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="de54fb02014412ecd1787d4096721b6bd9a09795" translate="yes" xml:space="preserve">
          <source>In addition, multiple cancellations of row deletions can be made by adjusting the position of the cursor using any of the cursor position control methods such as:</source>
          <target state="translated">此外,还可以通过使用任何一种光标位置控制方法调整光标的位置来实现多行删除的取消,如:。</target>
        </trans-unit>
        <trans-unit id="5a982507e35bcbb8afa02271b7a356830dfdca5b" translate="yes" xml:space="preserve">
          <source>In addition, multiple cancellations of row insertions can be made by adjusting the position of the cursor using any of the cursor position control methods such as:</source>
          <target state="translated">此外,还可以通过使用任何一种光标位置控制方法调整光标的位置来实现行插入的多次取消,例如:。</target>
        </trans-unit>
        <trans-unit id="d0be37ef9695b65cf9e9180a2ae0ea88d1cdf6af" translate="yes" xml:space="preserve">
          <source>In addition, some operations, such as Arabic shaping, require context, so that the characters at the start and limit can have the proper shapes. Sometimes the data in the buffer outside the provided range does not have valid data. The values LAYOUT_NO_START_CONTEXT and LAYOUT_NO_LIMIT_CONTEXT can be added to the flags parameter to indicate that the text before start, or after limit, respectively, should not be examined for context.</source>
          <target state="translated">此外,一些操作,如阿拉伯文整形,需要上下文,以便在开始和限制的字符可以有正确的形状。有时,缓冲区中的数据在提供的范围之外,并没有有效的数据,这时可以使用LAYOUT_NO_START_CONTEXT和LAYOUT_NONO的值。LAYOUT_NO_START_CONTEXT和LAYOUT_NO_LIMIT_CONTEXT这两个值可以添加到flags参数中,分别表示开始前的文本或限制后的文本不应该被检查上下文。</target>
        </trans-unit>
        <trans-unit id="eb227b57999fd7e909da8da1d2a7fde11cad3089" translate="yes" xml:space="preserve">
          <source>In addition, some subclasses may also implement other &lt;code&gt;getXxxxInstance&lt;/code&gt; methods for more specialized control. For example, the &lt;code&gt;NumberFormat&lt;/code&gt; class provides &lt;code&gt;getPercentInstance&lt;/code&gt; and &lt;code&gt;getCurrencyInstance&lt;/code&gt; methods for getting specialized number formatters.</source>
          <target state="translated">此外，某些子类还可以实现其他 &lt;code&gt;getXxxxInstance&lt;/code&gt; 方法以进行更专门的控制。例如， &lt;code&gt;NumberFormat&lt;/code&gt; 类提供了 &lt;code&gt;getPercentInstance&lt;/code&gt; 和 &lt;code&gt;getCurrencyInstance&lt;/code&gt; 方法，用于获取专用的数字格式化程序。</target>
        </trans-unit>
        <trans-unit id="8521432ca817c76647f2d846f1bef6c88792da85" translate="yes" xml:space="preserve">
          <source>In addition, the &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; contains at least attributes indicating where text was generated from an argument in the &lt;code&gt;arguments&lt;/code&gt; array. The keys of these attributes are of type &lt;code&gt;MessageFormat.Field&lt;/code&gt;, their values are &lt;code&gt;Integer&lt;/code&gt; objects indicating the index in the &lt;code&gt;arguments&lt;/code&gt; array of the argument from which the text was generated.</source>
          <target state="translated">此外， &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; 至少包含一些属性，这些属性指示从 &lt;code&gt;arguments&lt;/code&gt; 数组中的某个参数生成文本的位置。这些属性的键的类型为 &lt;code&gt;MessageFormat.Field&lt;/code&gt; ，它们的值是 &lt;code&gt;Integer&lt;/code&gt; 对象，指示从中生成文本的参数的 &lt;code&gt;arguments&lt;/code&gt; 数组中的索引。</target>
        </trans-unit>
        <trans-unit id="a6e2e314534ac045cf69b2d41f6340feecc19940" translate="yes" xml:space="preserve">
          <source>In addition, the PrincipalClass/PrincipalName pairing may be repeated:</source>
          <target state="translated">此外,PrincipalClass/PrincipalName的配对可以重复。</target>
        </trans-unit>
        <trans-unit id="059ef3ffe1e79dfc5ca9021949523c0f33a49b34" translate="yes" xml:space="preserve">
          <source>In addition, the class defines methods that are used to maintain a current &lt;em&gt;selection&lt;/em&gt; from the text. The text selection, a substring of the component's text, is the target of editing operations. It is also referred to as the &lt;em&gt;selected text&lt;/em&gt;.</source>
          <target state="translated">此外，该类还定义了用于维护文本中当前&lt;em&gt;选择&lt;/em&gt;的方法。文本选择是组件文本的子字符串，是编辑操作的目标。也称为&lt;em&gt;选定文本&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="f903153f3f79cd8363e00d5f09abdc372525f060" translate="yes" xml:space="preserve">
          <source>In addition, the following must hold:</source>
          <target state="translated">此外,还必须具备以下条件:</target>
        </trans-unit>
        <trans-unit id="cf2386bcd0be6584acdb144b841b15f4c960e9dd" translate="yes" xml:space="preserve">
          <source>In addition, the following operations are supported, either directly, or indirectly through objects that the &lt;code&gt;Sequencer&lt;/code&gt; has access to:</source>
          <target state="translated">此外，直接或通过 &lt;code&gt;Sequencer&lt;/code&gt; 可以访问的对象间接支持以下操作：</target>
        </trans-unit>
        <trans-unit id="b49601d6aae95f2a139f03510edca3cb80c87127" translate="yes" xml:space="preserve">
          <source>In addition, the horizontal and vertical gaps are set to the specified values. Horizontal gaps are placed between each of the columns. Vertical gaps are placed between each of the rows.</source>
          <target state="translated">此外,水平和垂直间隙设置为指定值。水平间隙放置在每一列之间。垂直间隙放在每行之间。</target>
        </trans-unit>
        <trans-unit id="e95a48cd4b0c0c77f9a895c979e24d8c600e0c7e" translate="yes" xml:space="preserve">
          <source>In addition, the structured type is custom mapped to a class in the Java programming language if there is such a mapping, as are its attributes, if appropriate.</source>
          <target state="translated">此外,结构化类型在Java编程语言中被自定义映射到一个类,如果有这样的映射,它的属性也是如此,如果合适的话。</target>
        </trans-unit>
        <trans-unit id="4847332e5f9a256254c2b8f86ee3aff2ec216774" translate="yes" xml:space="preserve">
          <source>In addition, this class provides a large number of static methods for determining a character's category (lowercase letter, digit, etc.) and for converting characters from uppercase to lowercase and vice versa.</source>
          <target state="translated">此外,该类还提供了大量的静态方法,用于确定字符的类别(小写字母、数字等)以及将字符从大写转换为小写,反之亦然。</target>
        </trans-unit>
        <trans-unit id="c0f1f85aac1e1e7e02b8f9ea172b9f1824281377" translate="yes" xml:space="preserve">
          <source>In addition, this class provides many methods for converting a &lt;code&gt;boolean&lt;/code&gt; to a &lt;code&gt;String&lt;/code&gt; and a &lt;code&gt;String&lt;/code&gt; to a &lt;code&gt;boolean&lt;/code&gt;, as well as other constants and methods useful when dealing with a &lt;code&gt;boolean&lt;/code&gt;.</source>
          <target state="translated">此外，此类提供了许多用于将 &lt;code&gt;boolean&lt;/code&gt; 转换为 &lt;code&gt;String&lt;/code&gt; 以及将 &lt;code&gt;String&lt;/code&gt; 转换为 &lt;code&gt;boolean&lt;/code&gt; ，以及在处理 &lt;code&gt;boolean&lt;/code&gt; 时有用的其他常量和方法。</target>
        </trans-unit>
        <trans-unit id="86218e012109407362f27dd46c0b2b37d9a404bc" translate="yes" xml:space="preserve">
          <source>In addition, this class provides several methods for converting a &lt;code&gt;byte&lt;/code&gt; to a &lt;code&gt;String&lt;/code&gt; and a &lt;code&gt;String&lt;/code&gt; to a &lt;code&gt;
 byte&lt;/code&gt;, as well as other constants and methods useful when dealing with a &lt;code&gt;byte&lt;/code&gt;.</source>
          <target state="translated">另外，此类提供了几种将 &lt;code&gt;byte&lt;/code&gt; 转换为 &lt;code&gt;String&lt;/code&gt; 并将 &lt;code&gt;String&lt;/code&gt; 转换为 &lt;code&gt; byte&lt;/code&gt; ，以及其他在处理 &lt;code&gt;byte&lt;/code&gt; 时有用的常量和方法。</target>
        </trans-unit>
        <trans-unit id="8ffeb51b3224523ef436b1d1938bf920a43bfc60" translate="yes" xml:space="preserve">
          <source>In addition, this class provides several methods for converting a &lt;code&gt;byte&lt;/code&gt; to a &lt;code&gt;String&lt;/code&gt; and a &lt;code&gt;String&lt;/code&gt; to a &lt;code&gt;byte&lt;/code&gt;, as well as other constants and methods useful when dealing with a &lt;code&gt;byte&lt;/code&gt;.</source>
          <target state="translated">另外，此类提供了几种将 &lt;code&gt;byte&lt;/code&gt; 转换为 &lt;code&gt;String&lt;/code&gt; 并将 &lt;code&gt;String&lt;/code&gt; 转换为 &lt;code&gt;byte&lt;/code&gt; ，以及其他在处理 &lt;code&gt;byte&lt;/code&gt; 时有用的常量和方法。</target>
        </trans-unit>
        <trans-unit id="e85c3617c388e7fe3a9752600be2c78c296128c0" translate="yes" xml:space="preserve">
          <source>In addition, this class provides several methods for converting a &lt;code&gt;double&lt;/code&gt; to a &lt;code&gt;String&lt;/code&gt; and a &lt;code&gt;String&lt;/code&gt; to a &lt;code&gt;double&lt;/code&gt;, as well as other constants and methods useful when dealing with a &lt;code&gt;double&lt;/code&gt;.</source>
          <target state="translated">另外，此类提供了几种将 &lt;code&gt;double&lt;/code&gt; 转换为 &lt;code&gt;String&lt;/code&gt; 并将 &lt;code&gt;String&lt;/code&gt; 转换为 &lt;code&gt;double&lt;/code&gt; 的方法，以及其他在处理 &lt;code&gt;double&lt;/code&gt; 时有用的常量和方法。</target>
        </trans-unit>
        <trans-unit id="68a2ece26a8ec24ff52bdb5b8ffee400c05c5514" translate="yes" xml:space="preserve">
          <source>In addition, this class provides several methods for converting a &lt;code&gt;float&lt;/code&gt; to a &lt;code&gt;String&lt;/code&gt; and a &lt;code&gt;String&lt;/code&gt; to a &lt;code&gt;float&lt;/code&gt;, as well as other constants and methods useful when dealing with a &lt;code&gt;float&lt;/code&gt;.</source>
          <target state="translated">另外，此类提供了几种将 &lt;code&gt;float&lt;/code&gt; 转换为 &lt;code&gt;String&lt;/code&gt; 并将 &lt;code&gt;String&lt;/code&gt; 转换为 &lt;code&gt;float&lt;/code&gt; 的方法，以及其他在处理 &lt;code&gt;float&lt;/code&gt; 时有用的常量和方法。</target>
        </trans-unit>
        <trans-unit id="2d7a80682c0aaad3c6f64e1cc3e7a4dd1f8f891d" translate="yes" xml:space="preserve">
          <source>In addition, this class provides several methods for converting a &lt;code&gt;long&lt;/code&gt; to a &lt;code&gt;String&lt;/code&gt; and a &lt;code&gt;String&lt;/code&gt; to a &lt;code&gt;
 long&lt;/code&gt;, as well as other constants and methods useful when dealing with a &lt;code&gt;long&lt;/code&gt;.</source>
          <target state="translated">另外，此类提供了几种用于将 &lt;code&gt;long&lt;/code&gt; 转换为 &lt;code&gt;String&lt;/code&gt; 和将 &lt;code&gt;String&lt;/code&gt; 转换为 &lt;code&gt; long&lt;/code&gt; 的方法，以及在处理 &lt;code&gt;long&lt;/code&gt; 时有用的其他常量和方法。</target>
        </trans-unit>
        <trans-unit id="c3209e7895f5274dda2c59c01800db0e7f1a6cb9" translate="yes" xml:space="preserve">
          <source>In addition, this class provides several methods for converting a &lt;code&gt;long&lt;/code&gt; to a &lt;code&gt;String&lt;/code&gt; and a &lt;code&gt;String&lt;/code&gt; to a &lt;code&gt;long&lt;/code&gt;, as well as other constants and methods useful when dealing with a &lt;code&gt;long&lt;/code&gt;.</source>
          <target state="translated">另外，此类提供了几种将 &lt;code&gt;long&lt;/code&gt; 转换为 &lt;code&gt;String&lt;/code&gt; 和将 &lt;code&gt;String&lt;/code&gt; 转换为 &lt;code&gt;long&lt;/code&gt; 的方法，以及其他在处理 &lt;code&gt;long&lt;/code&gt; 时有用的常量和方法。</target>
        </trans-unit>
        <trans-unit id="bceab1896f5431f9616536d2c3debec95c7baf0d" translate="yes" xml:space="preserve">
          <source>In addition, this class provides several methods for converting a &lt;code&gt;short&lt;/code&gt; to a &lt;code&gt;String&lt;/code&gt; and a &lt;code&gt;String&lt;/code&gt; to a &lt;code&gt;short&lt;/code&gt;, as well as other constants and methods useful when dealing with a &lt;code&gt;short&lt;/code&gt;.</source>
          <target state="translated">另外，此类提供了几种将 &lt;code&gt;short&lt;/code&gt; 转换为 &lt;code&gt;String&lt;/code&gt; 和将 &lt;code&gt;String&lt;/code&gt; 转换为 &lt;code&gt;short&lt;/code&gt; 的方法，以及在处理 &lt;code&gt;short&lt;/code&gt; 时有用的其他常量和方法。</target>
        </trans-unit>
        <trans-unit id="77411ccbd611f6cf25185bc001e7ca50aa01649a" translate="yes" xml:space="preserve">
          <source>In addition, this class provides several methods for converting an &lt;code&gt;int&lt;/code&gt; to a &lt;code&gt;String&lt;/code&gt; and a &lt;code&gt;String&lt;/code&gt; to an &lt;code&gt;int&lt;/code&gt;, as well as other constants and methods useful when dealing with an &lt;code&gt;int&lt;/code&gt;.</source>
          <target state="translated">另外，此类提供了几种将 &lt;code&gt;int&lt;/code&gt; 转换为 &lt;code&gt;String&lt;/code&gt; 并将 &lt;code&gt;String&lt;/code&gt; 转换为 &lt;code&gt;int&lt;/code&gt; 的方法，以及其他在处理 &lt;code&gt;int&lt;/code&gt; 时有用的常量和方法。</target>
        </trans-unit>
        <trans-unit id="68c06dbee76a5636d9963ea08f8ff95d58d1e068" translate="yes" xml:space="preserve">
          <source>In addition, this class provides several methods for determining a character's category (lowercase letter, digit, etc.) and for converting characters from uppercase to lowercase and vice versa.</source>
          <target state="translated">此外,该类还提供了几种方法,用于确定字符的类别(小写字母、数字等)以及将字符从大写转换为小写,反之亦然。</target>
        </trans-unit>
        <trans-unit id="e292b452247845d9e091ce216510934fc5ca8378" translate="yes" xml:space="preserve">
          <source>In addition, unlike &lt;code&gt;set()&lt;/code&gt;, &lt;code&gt;add()&lt;/code&gt; forces an immediate recomputation of the calendar's milliseconds and all fields.</source>
          <target state="translated">另外，与 &lt;code&gt;set()&lt;/code&gt; 不同， &lt;code&gt;add()&lt;/code&gt; 强制立即重新计算日历的毫秒数和所有字段。</target>
        </trans-unit>
        <trans-unit id="4885f27aaffdd79828e0a037c13dc416292803f1" translate="yes" xml:space="preserve">
          <source>In addition, when a security manager is present, loggers provided to system classes should not be directly configurable through the logging backend without requiring permissions.</source>
          <target state="translated">此外,当有安全管理器时,提供给系统类的日志记录器不应在不需要权限的情况下直接通过日志记录后台进行配置。</target>
        </trans-unit>
        <trans-unit id="de31f43eb8e0b918bd2b3f41713ffd72120e2ef0" translate="yes" xml:space="preserve">
          <source>In all cases the value set by this option is used in the negotiation of new associations setup on the channel's socket and the actual maximum number of inbound/outbound streams that have been negotiated with the peer can be retrieved from the appropriate &lt;a href=&quot;association&quot;&gt;&lt;code&gt;Association&lt;/code&gt;&lt;/a&gt;. The &lt;code&gt;Association&lt;/code&gt; can be retrieved from the &lt;a href=&quot;associationchangenotification.assocchangeevent#COMM_UP&quot;&gt;&lt;code&gt;COMM_UP&lt;/code&gt;&lt;/a&gt;&lt;a href=&quot;associationchangenotification&quot;&gt;&lt;code&gt;AssociationChangeNotification&lt;/code&gt;&lt;/a&gt; belonging to that association.</source>
          <target state="translated">在所有情况下，通过此选项设置的值都用于协商通道套接字上的新关联设置，并且可以从适当的&lt;a href=&quot;association&quot;&gt; &lt;code&gt;Association&lt;/code&gt; 中&lt;/a&gt;检索与对等方协商的实际最大入站/出站流数。该 &lt;code&gt;Association&lt;/code&gt; 可以从检索&lt;a href=&quot;associationchangenotification.assocchangeevent#COMM_UP&quot;&gt; &lt;code&gt;COMM_UP&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;associationchangenotification&quot;&gt; &lt;code&gt;AssociationChangeNotification&lt;/code&gt; &lt;/a&gt;属于该协会。</target>
        </trans-unit>
        <trans-unit id="a9dfe816f9d7068cb163a587c8942b7b0c372c47" translate="yes" xml:space="preserve">
          <source>In all cases, &lt;code&gt;pos&lt;/code&gt; must be greater than or equal to zero, and &lt;code&gt;pos&lt;/code&gt; must also be less than or equal to the target's arity.</source>
          <target state="translated">在所有情况下， &lt;code&gt;pos&lt;/code&gt; 都必须大于或等于零，并且 &lt;code&gt;pos&lt;/code&gt; 也必须小于或等于目标的Arity。</target>
        </trans-unit>
        <trans-unit id="09e47909f30bd0dae2adcaf9dec3e17da3c754a0" translate="yes" xml:space="preserve">
          <source>In all cases, arguments given to methods for these purposes need not fall within the indicated ranges; for example, a date may be specified as January 32 and is interpreted as meaning February 1.</source>
          <target state="translated">在所有情况下,为这些目的而给予方法的论据不必在指定的范围内;例如,一个日期可能被指定为1月32日,并被解释为2月1日的意思。</target>
        </trans-unit>
        <trans-unit id="710a1058addac3a4778571f2e89fe86199a733c7" translate="yes" xml:space="preserve">
          <source>In all cases, before this method can return the current thread must re-acquire the lock associated with this condition. When the thread returns it is &lt;em&gt;guaranteed&lt;/em&gt; to hold this lock.</source>
          <target state="translated">在所有情况下，在此方法可以返回之前，当前线程必须重新获取与此条件关联的锁。当线程返回时，可以&lt;em&gt;保证&lt;/em&gt;保持此锁。</target>
        </trans-unit>
        <trans-unit id="26a8f8af04f382db67be9b5de3a26f6c349c6b6b" translate="yes" xml:space="preserve">
          <source>In all cases, calculations that use this method to calculate results along one axis will not fail because of anomalies in calculations along the other axis. When the cell is not valid the &lt;code&gt;includeSpacing&lt;/code&gt; parameter is ignored.</source>
          <target state="translated">在所有情况下，使用此方法沿一个轴计算结果的计算都不会失败，因为沿另一个轴的计算异常。当单元格无效时，将忽略 &lt;code&gt;includeSpacing&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="89452fe59efb654a902cd41128a35da921fe424a" translate="yes" xml:space="preserve">
          <source>In all cases, if the new value is outside the valid range of values for the field then a &lt;code&gt;DateTimeException&lt;/code&gt; will be thrown.</source>
          <target state="translated">在所有情况下，如果新值超出该字段的有效值范围，则将引发 &lt;code&gt;DateTimeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="81081b4ee2ad6edc756e2675593e859604468b70" translate="yes" xml:space="preserve">
          <source>In all cases, it is legal to return a more capable metadata object than strictly necessary. The format name and node names are merely hints that may be used to reduce the reader's workload.</source>
          <target state="translated">在所有情况下,返回一个比严格必要的元数据对象能力更强的元数据是合法的。格式名和节点名只是一种提示,可以用来减少读者的工作量。</target>
        </trans-unit>
        <trans-unit id="a8642fd07de10ab15e255b32922459adaf42a0c8" translate="yes" xml:space="preserve">
          <source>In all cases, the result is a &lt;code&gt;long&lt;/code&gt; integer that, when given to the &lt;a href=&quot;#longBitsToDouble(long)&quot;&gt;&lt;code&gt;longBitsToDouble(long)&lt;/code&gt;&lt;/a&gt; method, will produce a floating-point value the same as the argument to &lt;code&gt;doubleToLongBits&lt;/code&gt; (except all NaN values are collapsed to a single &quot;canonical&quot; NaN value).</source>
          <target state="translated">在所有情况下，结果都是一个 &lt;code&gt;long&lt;/code&gt; 整数，将其提供给&lt;a href=&quot;#longBitsToDouble(long)&quot;&gt; &lt;code&gt;longBitsToDouble(long)&lt;/code&gt; &lt;/a&gt;方法时，将产生一个与 &lt;code&gt;doubleToLongBits&lt;/code&gt; 的参数相同的浮点值（除非所有NaN值都折叠为单个&amp;ldquo;规范&amp;rdquo; NaN）价值）。</target>
        </trans-unit>
        <trans-unit id="8837bb6be2c5fdd23d8a48631d7aee2f241759eb" translate="yes" xml:space="preserve">
          <source>In all cases, the result is a &lt;code&gt;long&lt;/code&gt; integer that, when given to the &lt;a href=&quot;#longBitsToDouble(long)&quot;&gt;&lt;code&gt;longBitsToDouble(long)&lt;/code&gt;&lt;/a&gt; method, will produce a floating-point value the same as the argument to &lt;code&gt;doubleToRawLongBits&lt;/code&gt;.</source>
          <target state="translated">在所有情况下，结果都是一个 &lt;code&gt;long&lt;/code&gt; 整数，将其提供给&lt;a href=&quot;#longBitsToDouble(long)&quot;&gt; &lt;code&gt;longBitsToDouble(long)&lt;/code&gt; &lt;/a&gt;方法时，将产生一个与 &lt;code&gt;doubleToRawLongBits&lt;/code&gt; 的参数相同的浮点值。</target>
        </trans-unit>
        <trans-unit id="3e386c1014f9389cd75e4097f8ba05b0eb55648f" translate="yes" xml:space="preserve">
          <source>In all cases, the result is a &lt;code&gt;long&lt;/code&gt; integer that, when given to the &lt;a href=&quot;double#longBitsToDouble-long-&quot;&gt;&lt;code&gt;longBitsToDouble(long)&lt;/code&gt;&lt;/a&gt; method, will produce a floating-point value the same as the argument to &lt;code&gt;doubleToLongBits&lt;/code&gt; (except all NaN values are collapsed to a single &quot;canonical&quot; NaN value).</source>
          <target state="translated">在所有情况下，结果都是一个 &lt;code&gt;long&lt;/code&gt; 整数，将其提供给&lt;a href=&quot;double#longBitsToDouble-long-&quot;&gt; &lt;code&gt;longBitsToDouble(long)&lt;/code&gt; &lt;/a&gt;方法时，将产生一个与 &lt;code&gt;doubleToLongBits&lt;/code&gt; 参数相同的浮点值（除了所有NaN值都折叠为单个&amp;ldquo;规范&amp;rdquo; NaN）值）。</target>
        </trans-unit>
        <trans-unit id="94e816d46d03eaaedcfd4333b2b790c79aab00a5" translate="yes" xml:space="preserve">
          <source>In all cases, the result is a &lt;code&gt;long&lt;/code&gt; integer that, when given to the &lt;a href=&quot;double#longBitsToDouble-long-&quot;&gt;&lt;code&gt;longBitsToDouble(long)&lt;/code&gt;&lt;/a&gt; method, will produce a floating-point value the same as the argument to &lt;code&gt;doubleToRawLongBits&lt;/code&gt;.</source>
          <target state="translated">在所有情况下，结果都是一个 &lt;code&gt;long&lt;/code&gt; 整数，当将其提供给&lt;a href=&quot;double#longBitsToDouble-long-&quot;&gt; &lt;code&gt;longBitsToDouble(long)&lt;/code&gt; &lt;/a&gt;方法时，该整数将生成与 &lt;code&gt;doubleToRawLongBits&lt;/code&gt; 的参数相同的浮点值。</target>
        </trans-unit>
        <trans-unit id="1fd6b3425097c0e30a0d9da2eb4d3433636ea847" translate="yes" xml:space="preserve">
          <source>In all cases, the result is an integer that, when given to the &lt;a href=&quot;#intBitsToFloat(int)&quot;&gt;&lt;code&gt;intBitsToFloat(int)&lt;/code&gt;&lt;/a&gt; method, will produce a floating-point value the same as the argument to &lt;code&gt;floatToIntBits&lt;/code&gt; (except all NaN values are collapsed to a single &quot;canonical&quot; NaN value).</source>
          <target state="translated">在所有情况下，结果都是一个整数，将其提供给&lt;a href=&quot;#intBitsToFloat(int)&quot;&gt; &lt;code&gt;intBitsToFloat(int)&lt;/code&gt; &lt;/a&gt;方法时，将产生一个与 &lt;code&gt;floatToIntBits&lt;/code&gt; 参数相同的浮点值（除非所有NaN值都折叠为单个&amp;ldquo;规范&amp;rdquo; NaN值） ）。</target>
        </trans-unit>
        <trans-unit id="84c117b508f6a4eab4d75f1234503941d79ab2fb" translate="yes" xml:space="preserve">
          <source>In all cases, the result is an integer that, when given to the &lt;a href=&quot;#intBitsToFloat(int)&quot;&gt;&lt;code&gt;intBitsToFloat(int)&lt;/code&gt;&lt;/a&gt; method, will produce a floating-point value the same as the argument to &lt;code&gt;floatToRawIntBits&lt;/code&gt;.</source>
          <target state="translated">在所有情况下，结果都是一个整数，将其提供给&lt;a href=&quot;#intBitsToFloat(int)&quot;&gt; &lt;code&gt;intBitsToFloat(int)&lt;/code&gt; &lt;/a&gt;方法时，将产生一个与 &lt;code&gt;floatToRawIntBits&lt;/code&gt; 的参数相同的浮点值。</target>
        </trans-unit>
        <trans-unit id="8fa2f7b6b965b0569cfce25d70b8a9ac24c40131" translate="yes" xml:space="preserve">
          <source>In all cases, the result is an integer that, when given to the &lt;a href=&quot;float#intBitsToFloat-int-&quot;&gt;&lt;code&gt;intBitsToFloat(int)&lt;/code&gt;&lt;/a&gt; method, will produce a floating-point value the same as the argument to &lt;code&gt;floatToIntBits&lt;/code&gt; (except all NaN values are collapsed to a single &quot;canonical&quot; NaN value).</source>
          <target state="translated">在所有情况下，结果都是一个整数，将其提供给&lt;a href=&quot;float#intBitsToFloat-int-&quot;&gt; &lt;code&gt;intBitsToFloat(int)&lt;/code&gt; &lt;/a&gt;方法时，将产生一个与 &lt;code&gt;floatToIntBits&lt;/code&gt; 参数相同的浮点值（除了所有NaN值都折叠为单个&amp;ldquo;规范&amp;rdquo; NaN值） ）。</target>
        </trans-unit>
        <trans-unit id="f8ae1992023cdf3fa87efe9d9a4061db37810e06" translate="yes" xml:space="preserve">
          <source>In all cases, the result is an integer that, when given to the &lt;a href=&quot;float#intBitsToFloat-int-&quot;&gt;&lt;code&gt;intBitsToFloat(int)&lt;/code&gt;&lt;/a&gt; method, will produce a floating-point value the same as the argument to &lt;code&gt;floatToRawIntBits&lt;/code&gt;.</source>
          <target state="translated">在所有情况下，结果都是一个整数，将其提供给&lt;a href=&quot;float#intBitsToFloat-int-&quot;&gt; &lt;code&gt;intBitsToFloat(int)&lt;/code&gt; &lt;/a&gt;方法时，将产生一个与 &lt;code&gt;floatToRawIntBits&lt;/code&gt; 的参数相同的浮点值。</target>
        </trans-unit>
        <trans-unit id="d3f55b4dbef121f94603171922b50a3691948cf6" translate="yes" xml:space="preserve">
          <source>In all cases, this method returns &lt;code&gt;true&lt;/code&gt;, since DefaultKeyboardFocusManager is designed so that neither &lt;code&gt;dispatchEvent&lt;/code&gt;, nor the AWT event dispatcher, should take further action on the event in any situation.</source>
          <target state="translated">在所有情况下，此方法都将返回 &lt;code&gt;true&lt;/code&gt; ，这是因为对DefaultKeyboardFocusManager进行了设计，以使 &lt;code&gt;dispatchEvent&lt;/code&gt; 和AWT事件分派器在任何情况下都不应对该事件采取进一步的措施。</target>
        </trans-unit>
        <trans-unit id="d859740a340aab2ef2df184897feb73868229deb" translate="yes" xml:space="preserve">
          <source>In all cases, what the target eventually returns is returned unchanged by the adapter.</source>
          <target state="translated">在所有的情况下,目标最终返回的内容都会被适配器不变的返回。</target>
        </trans-unit>
        <trans-unit id="3f9e867ee25c16d7f93432110c660aa7dfa2f352" translate="yes" xml:space="preserve">
          <source>In all methods of class &lt;code&gt;Date&lt;/code&gt; that accept or return year, month, date, hours, minutes, and seconds values, the following representations are used:</source>
          <target state="translated">在 &lt;code&gt;Date&lt;/code&gt; 类的所有接受或返回年，月，日，时，分和秒值的方法中，使用以下表示形式：</target>
        </trans-unit>
        <trans-unit id="13fb9ca977fc45a075a964a2af1e52f78784083b" translate="yes" xml:space="preserve">
          <source>In all other cases the default persistence delegate is returned. The default persistence delegate assumes the type is a &lt;em&gt;JavaBean&lt;/em&gt;, implying that it has a default constructor and that its state may be characterized by the matching pairs of &quot;setter&quot; and &quot;getter&quot; methods returned by the &lt;a href=&quot;introspector&quot;&gt;&lt;code&gt;Introspector&lt;/code&gt;&lt;/a&gt; class. The default constructor is the constructor with the greatest number of parameters that has the &lt;a href=&quot;constructorproperties&quot;&gt;&lt;code&gt;ConstructorProperties&lt;/code&gt;&lt;/a&gt; annotation. If none of the constructors has the &lt;code&gt;ConstructorProperties&lt;/code&gt; annotation, then the nullary constructor (constructor with no parameters) will be used. For example, in the following code fragment, the nullary constructor for the &lt;code&gt;Foo&lt;/code&gt; class will be used, while the two-parameter constructor for the &lt;code&gt;Bar&lt;/code&gt; class will be used.</source>
          <target state="translated">在所有其他情况下，将返回默认的持久性委托。默认的持久性委托假定类型为&lt;em&gt;JavaBean&lt;/em&gt;，这意味着它具有默认的构造函数，并且其状态可以由&lt;a href=&quot;introspector&quot;&gt; &lt;code&gt;Introspector&lt;/code&gt; &lt;/a&gt;类返回的&amp;ldquo; setter&amp;rdquo;和&amp;ldquo; getter&amp;rdquo;方法的匹配对来表征。默认的构造函数是带有&lt;a href=&quot;constructorproperties&quot;&gt; &lt;code&gt;ConstructorProperties&lt;/code&gt; &lt;/a&gt;批注的参数数量最多的构造函数。如果没有一个构造函数具有 &lt;code&gt;ConstructorProperties&lt;/code&gt; 批注，则将使用无效构造函数（不带参数的构造函数）。例如，在下面的代码片段中， &lt;code&gt;Foo&lt;/code&gt; 的无效构造函数类将被使用，而 &lt;code&gt;Bar&lt;/code&gt; 类的二参数构造函数将被使用。</target>
        </trans-unit>
        <trans-unit id="4f080e0ee2b15b4c102aa7079a0aa7b6d0e55888" translate="yes" xml:space="preserve">
          <source>In all other cases, let</source>
          <target state="translated">在所有其他情况下,让</target>
        </trans-unit>
        <trans-unit id="a11fe3cb468743e49daade63ee6734a831ca51f6" translate="yes" xml:space="preserve">
          <source>In all other respects, this method does the same thing as the method &lt;a href=&quot;object#wait-long-&quot;&gt;&lt;code&gt;wait(long)&lt;/code&gt;&lt;/a&gt; of one argument. In particular, &lt;code&gt;wait(0, 0)&lt;/code&gt; means the same thing as &lt;code&gt;wait(0)&lt;/code&gt;.</source>
          <target state="translated">在所有其他方面，此方法与一个参数的&lt;a href=&quot;object#wait-long-&quot;&gt; &lt;code&gt;wait(long)&lt;/code&gt; &lt;/a&gt;方法具有相同的作用。特别地， &lt;code&gt;wait(0, 0)&lt;/code&gt; 含义与 &lt;code&gt;wait(0)&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="d2a52a46fb3d14d37051820f4fdc8a542f211e8c" translate="yes" xml:space="preserve">
          <source>In all respects, this method behaves as if &lt;code&gt;wait(0L, 0)&lt;/code&gt; had been called. See the specification of the &lt;a href=&quot;#wait(long,int)&quot;&gt;&lt;code&gt;wait(long, int)&lt;/code&gt;&lt;/a&gt; method for details.</source>
          <target state="translated">在所有方面，此方法的行为就像已调用 &lt;code&gt;wait(0L, 0)&lt;/code&gt; 。有关详细信息，请参见&lt;a href=&quot;#wait(long,int)&quot;&gt; &lt;code&gt;wait(long, int)&lt;/code&gt; &lt;/a&gt;方法的规范。</target>
        </trans-unit>
        <trans-unit id="876c5fadd4e670707e8da62775562984c13c2478" translate="yes" xml:space="preserve">
          <source>In all respects, this method behaves as if &lt;code&gt;wait(timeoutMillis, 0)&lt;/code&gt; had been called. See the specification of the &lt;a href=&quot;#wait(long,int)&quot;&gt;&lt;code&gt;wait(long, int)&lt;/code&gt;&lt;/a&gt; method for details.</source>
          <target state="translated">在所有方面，此方法的行为就像已调用 &lt;code&gt;wait(timeoutMillis, 0)&lt;/code&gt; 。有关详细信息，请参见&lt;a href=&quot;#wait(long,int)&quot;&gt; &lt;code&gt;wait(long, int)&lt;/code&gt; &lt;/a&gt;方法的规范。</target>
        </trans-unit>
        <trans-unit id="c0e855a066ba9ae8a18027dd4b39faaff03ebf05" translate="yes" xml:space="preserve">
          <source>In an Overview document.</source>
          <target state="translated">在一份概述文件中:</target>
        </trans-unit>
        <trans-unit id="5881c9128a5b4634af69fc3e5e6bf8a1e1d2fddf" translate="yes" xml:space="preserve">
          <source>In an application which requires &lt;code&gt;invokedynamic&lt;/code&gt; instructions with individually mutable behaviors, their bootstrap methods should produce distinct &lt;a href=&quot;callsite&quot;&gt;&lt;code&gt;CallSite&lt;/code&gt;&lt;/a&gt; objects, one for each linkage request. Alternatively, an application can link a single &lt;code&gt;CallSite&lt;/code&gt; object to several &lt;code&gt;invokedynamic&lt;/code&gt; instructions, in which case a change to the target method will become visible at each of the instructions.</source>
          <target state="translated">在需要具有单独可变行为的 &lt;code&gt;invokedynamic&lt;/code&gt; 指令的应用程序中，它们的引导方法应产生不同的&lt;a href=&quot;callsite&quot;&gt; &lt;code&gt;CallSite&lt;/code&gt; &lt;/a&gt;对象，每个链接请求一个。或者，应用程序可以将单个 &lt;code&gt;CallSite&lt;/code&gt; 对象链接到多个 &lt;code&gt;invokedynamic&lt;/code&gt; 指令，在这种情况下，对目标方法的更改将在每条指令处可见。</target>
        </trans-unit>
        <trans-unit id="effcf63c91f615a32cf1d9dcd223b04f78c7e609" translate="yes" xml:space="preserve">
          <source>In an application which requires dynamic call sites with individually mutable behaviors, their bootstrap methods should produce distinct &lt;a href=&quot;callsite&quot;&gt;&lt;code&gt;CallSite&lt;/code&gt;&lt;/a&gt; objects, one for each linkage request. Alternatively, an application can link a single &lt;code&gt;CallSite&lt;/code&gt; object to several &lt;code&gt;invokedynamic&lt;/code&gt; instructions, in which case a change to the target method will become visible at each of the instructions.</source>
          <target state="translated">在需要具有单独可变行为的动态呼叫站点的应用程序中，它们的引导方法应产生不同的&lt;a href=&quot;callsite&quot;&gt; &lt;code&gt;CallSite&lt;/code&gt; &lt;/a&gt;对象，每个链接请求一个。或者，应用程序可以将单个 &lt;code&gt;CallSite&lt;/code&gt; 对象链接到多个 &lt;code&gt;invokedynamic&lt;/code&gt; 指令，在这种情况下，对目标方法的更改将在每条指令处可见。</target>
        </trans-unit>
        <trans-unit id="a6322785784db32ea230804c456ea63d59ad58e8" translate="yes" xml:space="preserve">
          <source>In an element representing a method named &quot;get&quot; taking one integer argument, the &quot;method&quot; attribute is replaced with an &quot;index&quot; attribute whose value the value of the first argument.</source>
          <target state="translated">在代表名为 &quot;get &quot;的方法的元素中,取一个整数参数,&quot;method &quot;属性被替换为 &quot;index &quot;属性,其值为第一个参数的值。</target>
        </trans-unit>
        <trans-unit id="c3d66182f526cc1c3711397e1bc8a88caa07d70f" translate="yes" xml:space="preserve">
          <source>In an element representing a method named &quot;set&quot; taking two arguments, the first of which is an integer, the &quot;method&quot; attribute is replaced with an &quot;index&quot; attribute whose value the value of the first argument.</source>
          <target state="translated">在表示名为 &quot;set &quot;的方法的元素中,取两个参数,其中第一个是整数,&quot;method &quot;属性被替换为 &quot;index &quot;属性,其值是第一个参数的值。</target>
        </trans-unit>
        <trans-unit id="3defc8fdafc7a95d821ad6a2e72f02a3b02b057c" translate="yes" xml:space="preserve">
          <source>In an element representing a monadic method whose name starts with &quot;set&quot;, the &quot;method&quot; attribute is replaced with a &quot;property&quot; attribute whose value is given by removing the &quot;set&quot; prefix and decapitalizing the result.</source>
          <target state="translated">在表示名称以 &quot;set &quot;开头的单项方法的元素中,&quot;method &quot;属性被 &quot;property &quot;属性所取代,其值是通过去掉 &quot;set &quot;前缀并将结果去掉大写来给出的。</target>
        </trans-unit>
        <trans-unit id="c9402abdb3bb2eff2c83147b78c26d50aa2578b7" translate="yes" xml:space="preserve">
          <source>In an element representing a nullary method whose name starts with &quot;get&quot;, the &quot;method&quot; attribute is replaced with a &quot;property&quot; attribute whose value is given by removing the &quot;get&quot; prefix and decapitalizing the result.</source>
          <target state="translated">在代表名称以 &quot;get &quot;开头的空方法的元素中,&quot;method &quot;属性被 &quot;property &quot;属性所取代,其值是通过去掉 &quot;get &quot;前缀并将结果去掉大写来给出的。</target>
        </trans-unit>
        <trans-unit id="f680341ae630eeaec6f425095320e0e5baed727c" translate="yes" xml:space="preserve">
          <source>In another example, if a search() method was invoked with a specified size limit of 'n'. If the answer consists of more than 'n' results, search() would first return a NamingEnumeration. When the n'th result has been returned by invoking next() on the NamingEnumeration, a SizeLimitExceedException would then thrown when hasMore() is invoked.</source>
          <target state="translated">在另一个例子中,如果调用search()方法时,指定的大小限制是'n',那么如果答案由超过'n'的结果组成,search()将首先返回一个NamingEnumeration。如果答案由超过'n'个结果组成,search()将首先返回一个NamingEnumeration。当调用namingEnumeration上的next()返回第n个结果时,当调用hasMore()时就会抛出一个SizeLimitExceedException。</target>
        </trans-unit>
        <trans-unit id="63473c669373298ff8b126a800c3c9be701d8f25" translate="yes" xml:space="preserve">
          <source>In any case, byte order marks occurring after the first element of an input sequence are not omitted since the same code is used to represent &lt;small&gt;ZERO-WIDTH NON-BREAKING SPACE&lt;/small&gt;.</source>
          <target state="translated">在任何情况下，都不会忽略在输入序列的第一个元素之后出现的字节顺序标记，因为相同的代码用于表示&lt;small&gt;零宽度不间断空格&lt;/small&gt;。</target>
        </trans-unit>
        <trans-unit id="630747a247f01b32c4e11bc4da00e49faf1558a9" translate="yes" xml:space="preserve">
          <source>In any case, if the delegation is not successful, the value returned by &lt;a href=&quot;../../../../../java.security.jgss/org/ietf/jgss/gsscontext#getCredDelegState()&quot;&gt;&lt;code&gt;GSSContext.getCredDelegState()&lt;/code&gt;&lt;/a&gt; is false, and the value returned by &lt;a href=&quot;#getDelegPolicyState()&quot;&gt;&lt;code&gt;getDelegPolicyState()&lt;/code&gt;&lt;/a&gt; is also false.</source>
          <target state="translated">无论如何，如果委派不成功，则&lt;a href=&quot;../../../../../java.security.jgss/org/ietf/jgss/gsscontext#getCredDelegState()&quot;&gt; &lt;code&gt;GSSContext.getCredDelegState()&lt;/code&gt; &lt;/a&gt;返回的值为false，而&lt;a href=&quot;#getDelegPolicyState()&quot;&gt; &lt;code&gt;getDelegPolicyState()&lt;/code&gt; &lt;/a&gt;返回的值为false。</target>
        </trans-unit>
        <trans-unit id="ec213efaa5103b31dfaf4a45519f35d0934bea15" translate="yes" xml:space="preserve">
          <source>In any case, if this method is to be reinvoked in the same decoding operation then care should be taken to preserve any bytes remaining in the input buffer so that they are available to the next invocation.</source>
          <target state="translated">在任何情况下,如果这个方法要在同一个解码操作中重新调用,那么就应该注意保存输入缓冲区中剩余的任何字节,以便在下一次调用时可用。</target>
        </trans-unit>
        <trans-unit id="de7b4cedf7b1b3605cbb4d5e220c17ec91cfeb27" translate="yes" xml:space="preserve">
          <source>In any case, if this method is to be reinvoked in the same encoding operation then care should be taken to preserve any characters remaining in the input buffer so that they are available to the next invocation.</source>
          <target state="translated">在任何情况下,如果这个方法要在同一个编码操作中重新调用,那么就应该注意保留输入缓冲区中剩余的字符,以便在下一次调用时可以使用。</target>
        </trans-unit>
        <trans-unit id="e3d361555e6e7f2aefd6719812880d76caffb268" translate="yes" xml:space="preserve">
          <source>In any mode, when a row is too tall to fit in the printable area -- print the upper-most portion of the row and paint no lower border on the table.</source>
          <target state="translated">在任何模式下,当一行太高,无法放入可打印区域时--打印该行的最上层部分,并在表格上不画下边框。</target>
        </trans-unit>
        <trans-unit id="42c371089599906ae5216970a156c82451cbcf79" translate="yes" xml:space="preserve">
          <source>In any mode, when the header or footer text is too wide to fit completely in the printable area -- print as much of the text as possible starting from the beginning, as determined by the table's &lt;code&gt;ComponentOrientation&lt;/code&gt;.</source>
          <target state="translated">在任何模式下，如果页眉或页脚文本太宽而无法完全适合可打印区域，则应从表的 &lt;code&gt;ComponentOrientation&lt;/code&gt; 确定，从头开始尽可能多地打印文本。</target>
        </trans-unit>
        <trans-unit id="b7c25745d87214e8c648f8952d20a0f3e9a240b8" translate="yes" xml:space="preserve">
          <source>In any other part of the system, where a date must be manipulated in a calendar system other than ISO, the use case will generally specify the calendar system to use. For example, an application may need to calculate the next Islamic or Hebrew holiday which may require manipulating the date. This kind of use case can be handled as follows:</source>
          <target state="translated">在系统的任何其他部分,如果日期必须在ISO以外的日历系统中进行操作,用例通常会指定要使用的日历系统。例如,一个应用程序可能需要计算下一个伊斯兰或希伯来节日,这可能需要操作日期。这种用例可以按以下方式处理。</target>
        </trans-unit>
        <trans-unit id="6bfb37bc0f12d7bd938335d6fa2308caf29415db" translate="yes" xml:space="preserve">
          <source>In attribute subclassing, attributes are defined in a class hierarchy. In some directories, for example, the &quot;name&quot; attribute might be the superclass of all name-related attributes, including &quot;commonName&quot; and &quot;surName&quot;. Asking for the &quot;name&quot; attribute might return both the &quot;commonName&quot; and &quot;surName&quot; attributes.</source>
          <target state="translated">在属性子类中,属性是在一个类的层次结构中定义的。例如,在某些目录中,&quot;name &quot;属性可能是所有与名字有关的属性的超类,包括 &quot;commonName &quot;和 &quot;surName&quot;。询问 &quot;name &quot;属性可能会返回 &quot;commonName &quot;和 &quot;surName &quot;属性。</target>
        </trans-unit>
        <trans-unit id="c23d3434cbaf26efe476b28de6017e225a21d4fd" translate="yes" xml:space="preserve">
          <source>In authentication-first mode, authentication is attempted using the supplied username and password and then the LDAP directory is searched. If authentication is successful then a search is performed using the supplied username in conjunction with a specified search filter. To enable this mode, set the &lt;code&gt;authIdentity&lt;/code&gt; and the &lt;code&gt;userFilter&lt;/code&gt; options. Use authentication-first mode when accessing an LDAP directory that has been configured to disallow anonymous searches.</source>
          <target state="translated">在认证优先模式下，尝试使用提供的用户名和密码进行认证，然后搜索LDAP目录。如果身份验证成功，则使用提供的用户名和指定的搜索过滤器进行搜索。要启用此模式，请设置 &lt;code&gt;authIdentity&lt;/code&gt; 和 &lt;code&gt;userFilter&lt;/code&gt; 选项。访问已配置为禁止匿名搜索的LDAP目录时，请使用身份验证优先模式。</target>
        </trans-unit>
        <trans-unit id="a97b825d53724264d907e0b84831a3c9d7bd4f16" translate="yes" xml:space="preserve">
          <source>In authentication-only mode, authentication is attempted using the supplied username and password. The LDAP directory is not searched because the user's distinguished name is already known. To enable this mode, set the &lt;code&gt;authIdentity&lt;/code&gt; option to a valid distinguished name and omit the &lt;code&gt;userFilter&lt;/code&gt; option. Use authentication-only mode when the user's distinguished name is known in advance.</source>
          <target state="translated">在仅身份验证模式下，尝试使用提供的用户名和密码进行身份验证。由于用户的专有名称是已知的，因此不会搜索LDAP目录。要启用此模式，请将 &lt;code&gt;authIdentity&lt;/code&gt; 选项设置为有效的专有名称，并省略 &lt;code&gt;userFilter&lt;/code&gt; 选项。事先知道用户的专有名称时，请使用仅身份验证模式。</target>
        </trans-unit>
        <trans-unit id="db07d9eddd1469a03a0d4523aef982ea0329c470" translate="yes" xml:space="preserve">
          <source>In both cases, if a complete &lt;code&gt;ChronoLocalDateTime&lt;/code&gt; or &lt;code&gt;Instant&lt;/code&gt; is parsed, then the excess days are added to the date part. As a result, this query will return a zero period.</source>
          <target state="translated">在这两种情况下，如果都解析了完整的 &lt;code&gt;ChronoLocalDateTime&lt;/code&gt; 或 &lt;code&gt;Instant&lt;/code&gt; ，则多余的天数将添加到日期部分。结果，此查询将返回零周期。</target>
        </trans-unit>
        <trans-unit id="91a4a245b640227d3d4414ba8ce731f1a8ba5d28" translate="yes" xml:space="preserve">
          <source>In both string form and array form, each successive integer group gives a range of integers to be included in the set. The first integer in each group gives the lower bound of the range; the second integer in each group gives the upper bound of the range; if there is only one integer in the group, the upper bound is the same as the lower bound. If the upper bound is less than the lower bound, it denotes a &lt;code&gt;null&lt;/code&gt; range (no values). If the upper bound is equal to the lower bound, it denotes a range consisting of a single value. If the upper bound is greater than the lower bound, it denotes a range consisting of more than one value. The ranges may appear in any order and are allowed to overlap. The union of all the ranges gives the set's contents. Once a &lt;code&gt;SetOfIntegerSyntax&lt;/code&gt; instance is constructed, its value is immutable.</source>
          <target state="translated">在字符串形式和数组形式中，每个连续的整数组都给出要包含在集合中的整数范围。每组中的第一个整数给出范围的下限；每组中的第二个整数给出范围的上限；如果组中只有一个整数，则上限与下限相同。如果上限小于下限，则表示 &lt;code&gt;null&lt;/code&gt; 范围（无值）。如果上限等于下限，则表示由单个值组成的范围。如果上限大于下限，则表示由多个值组成的范围。范围可以按任何顺序出现，并且可以重叠。所有范围的并集将给出集合的内容。一旦 &lt;code&gt;SetOfIntegerSyntax&lt;/code&gt; 实例被构造，其值是不可变的。</target>
        </trans-unit>
        <trans-unit id="2f636f886ea66f4a3a9afd96f753e53de19a4e47" translate="yes" xml:space="preserve">
          <source>In both string form and array form, each successive integer group gives a range of integers to be included in the set. The first integer in each group gives the lower bound of the range; the second integer in each group gives the upper bound of the range; if there is only one integer in the group, the upper bound is the same as the lower bound. If the upper bound is less than the lower bound, it denotes a null range (no values). If the upper bound is equal to the lower bound, it denotes a range consisting of a single value. If the upper bound is greater than the lower bound, it denotes a range consisting of more than one value. The ranges may appear in any order and are allowed to overlap. The union of all the ranges gives the set's contents. Once a SetOfIntegerSyntax instance is constructed, its value is immutable.</source>
          <target state="translated">在字符串形式和数组形式中,每一个连续的整数组都给出了一个要包含在集合中的整数范围。每组中的第一个整数给出了范围的下界;每组中的第二个整数给出了范围的上界;如果组中只有一个整数,则上界与下界相同。如果上界小于下界,则表示范围为空(无值)。如果上界等于下界,则表示一个由单个值组成的范围,如果上界大于下界,则表示一个空范围(没有值)。如果上界大于下界,则表示由一个以上的值组成的范围。这些范围可以以任何顺序出现,并且允许重叠。所有范围的联合给出了集合的内容。一旦SetOfIntegerSyntax实例被构造出来,它的值是不可改变的。</target>
        </trans-unit>
        <trans-unit id="4d2d378458c146562d67eef1a8ddb1eb555f8996" translate="yes" xml:space="preserve">
          <source>In case of &lt;a href=&quot;../../../../java.base/java/util/serviceconfigurationerror&quot;&gt;&lt;code&gt;ServiceConfigurationError&lt;/code&gt;&lt;/a&gt; a &lt;a href=&quot;schemafactoryconfigurationerror&quot;&gt;&lt;code&gt;SchemaFactoryConfigurationError&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">在的情况下，&lt;a href=&quot;../../../../java.base/java/util/serviceconfigurationerror&quot;&gt; &lt;code&gt;ServiceConfigurationError&lt;/code&gt; &lt;/a&gt;一个&lt;a href=&quot;schemafactoryconfigurationerror&quot;&gt; &lt;code&gt;SchemaFactoryConfigurationError&lt;/code&gt; &lt;/a&gt;将被抛出。</target>
        </trans-unit>
        <trans-unit id="9d8151180e8b90a1132b0cccb8774fce54d1a54c" translate="yes" xml:space="preserve">
          <source>In case of &lt;a href=&quot;../../../../java.base/java/util/serviceconfigurationerror&quot;&gt;&lt;code&gt;ServiceConfigurationError&lt;/code&gt;&lt;/a&gt; an &lt;a href=&quot;xpathfactoryconfigurationexception&quot;&gt;&lt;code&gt;XPathFactoryConfigurationException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">如果出现&lt;a href=&quot;../../../../java.base/java/util/serviceconfigurationerror&quot;&gt; &lt;code&gt;ServiceConfigurationError&lt;/code&gt; &lt;/a&gt;，将抛出&lt;a href=&quot;xpathfactoryconfigurationexception&quot;&gt; &lt;code&gt;XPathFactoryConfigurationException&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6ab38b391c63c43cfa86dbd08744e0705f58ee43" translate="yes" xml:space="preserve">
          <source>In case of &lt;a href=&quot;../../../../java.base/java/util/serviceconfigurationerror&quot;&gt;&lt;code&gt;service
     configuration error&lt;/code&gt;&lt;/a&gt;, a &lt;a href=&quot;datatypeconfigurationexception&quot;&gt;&lt;code&gt;DatatypeConfigurationException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">如果&lt;a href=&quot;../../../../java.base/java/util/serviceconfigurationerror&quot;&gt; &lt;code&gt;service configuration error&lt;/code&gt; &lt;/a&gt;，将抛出&lt;a href=&quot;datatypeconfigurationexception&quot;&gt; &lt;code&gt;DatatypeConfigurationException&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="db84e0385f04bf317a34c9ba8a75997a83654f61" translate="yes" xml:space="preserve">
          <source>In case of a fatal error, the parser may choose to stop the parsing process with a &lt;a href=&quot;saxexception&quot;&gt;&lt;code&gt;SAXException&lt;/code&gt;&lt;/a&gt;, in which case, this method will never be called. Refer to &lt;a href=&quot;errorhandler#fatalError(org.xml.sax.SAXParseException)&quot;&gt;&lt;code&gt;ErrorHandler.fatalError(org.xml.sax.SAXParseException)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果发生致命错误，解析器可能会选择使用&lt;a href=&quot;saxexception&quot;&gt; &lt;code&gt;SAXException&lt;/code&gt; &lt;/a&gt;来停止解析过程，在这种情况下，将永远不会调用此方法。请参阅&lt;a href=&quot;errorhandler#fatalError(org.xml.sax.SAXParseException)&quot;&gt; &lt;code&gt;ErrorHandler.fatalError(org.xml.sax.SAXParseException)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6ad8b6db0e5041707a878e8f2137cb2dc1e748f6" translate="yes" xml:space="preserve">
          <source>In case of error while checking the byte or character stream, the method will return false to allow the XML processor to handle the error.</source>
          <target state="translated">如果在检查字节或字符流时出现错误,该方法将返回false以允许XML处理器处理该错误。</target>
        </trans-unit>
        <trans-unit id="beaa91ad6c8eaa4dea63cdc3004dcaca25742485" translate="yes" xml:space="preserve">
          <source>In case of exceptional completion with a CompletionException, methods &lt;a href=&quot;#get()&quot;&gt;&lt;code&gt;get()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#get(long,java.util.concurrent.TimeUnit)&quot;&gt;&lt;code&gt;get(long, TimeUnit)&lt;/code&gt;&lt;/a&gt; throw an &lt;a href=&quot;executionexception&quot;&gt;&lt;code&gt;ExecutionException&lt;/code&gt;&lt;/a&gt; with the same cause as held in the corresponding CompletionException. To simplify usage in most contexts, this class also defines methods &lt;a href=&quot;#join()&quot;&gt;&lt;code&gt;join()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#getNow(T)&quot;&gt;&lt;code&gt;getNow(T)&lt;/code&gt;&lt;/a&gt; that instead throw the CompletionException directly in these cases.</source>
          <target state="translated">如果使用CompletionException异常完成，则方法&lt;a href=&quot;#get()&quot;&gt; &lt;code&gt;get()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#get(long,java.util.concurrent.TimeUnit)&quot;&gt; &lt;code&gt;get(long, TimeUnit)&lt;/code&gt; &lt;/a&gt;抛出&lt;a href=&quot;executionexception&quot;&gt; &lt;code&gt;ExecutionException&lt;/code&gt; &lt;/a&gt;，其原因与相应的CompletionException中保存的原因相同。为了简化大多数情况下的用法，此类还定义了方法&lt;a href=&quot;#join()&quot;&gt; &lt;code&gt;join()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#getNow(T)&quot;&gt; &lt;code&gt;getNow(T)&lt;/code&gt; &lt;/a&gt;，它们在这些情况下直接抛出CompletionException。</target>
        </trans-unit>
        <trans-unit id="a484bdc7d644636e56b6e425fca8f967f78e3d13" translate="yes" xml:space="preserve">
          <source>In case of exceptional completion with a CompletionException, methods &lt;a href=&quot;completablefuture#get--&quot;&gt;&lt;code&gt;get()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;completablefuture#get-long-java.util.concurrent.TimeUnit-&quot;&gt;&lt;code&gt;get(long, TimeUnit)&lt;/code&gt;&lt;/a&gt; throw an &lt;a href=&quot;executionexception&quot;&gt;&lt;code&gt;ExecutionException&lt;/code&gt;&lt;/a&gt; with the same cause as held in the corresponding CompletionException. To simplify usage in most contexts, this class also defines methods &lt;a href=&quot;completablefuture#join--&quot;&gt;&lt;code&gt;join()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;completablefuture#getNow-T-&quot;&gt;&lt;code&gt;getNow(T)&lt;/code&gt;&lt;/a&gt; that instead throw the CompletionException directly in these cases.</source>
          <target state="translated">如果使用CompletionException异常完成，则方法&lt;a href=&quot;completablefuture#get--&quot;&gt; &lt;code&gt;get()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;completablefuture#get-long-java.util.concurrent.TimeUnit-&quot;&gt; &lt;code&gt;get(long, TimeUnit)&lt;/code&gt; &lt;/a&gt;抛出&lt;a href=&quot;executionexception&quot;&gt; &lt;code&gt;ExecutionException&lt;/code&gt; &lt;/a&gt;，其原因与相应的CompletionException中保存的原因相同。为了简化大多数情况下的用法，此类还定义了方法&lt;a href=&quot;completablefuture#join--&quot;&gt; &lt;code&gt;join()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;completablefuture#getNow-T-&quot;&gt; &lt;code&gt;getNow(T)&lt;/code&gt; &lt;/a&gt;，它们在这些情况下直接抛出CompletionException。</target>
        </trans-unit>
        <trans-unit id="02e1bf0c0b871bf4e85899ff41b22e62b5894d0a" translate="yes" xml:space="preserve">
          <source>In case of local transfer a serialized copy of the object returned by the encapsulated transferable is provided when the data is requested in application/x-java-serialized-object data flavor.</source>
          <target state="translated">在本地传输的情况下,当在application/x-java-serialized-object数据风味中请求数据时,会提供一个由封装的可传输对象返回的序列化副本。</target>
        </trans-unit>
        <trans-unit id="7ca173802763fd40eaac3b453114441ec080c6f1" translate="yes" xml:space="preserve">
          <source>In case some localization requires compact number patterns to be different for plurals, each singular and plural pattern can be enumerated within a pair of curly brackets &lt;code&gt;'{' (U+007B)&lt;/code&gt; and &lt;code&gt;'}' (U+007D)&lt;/code&gt;, separated by a space &lt;code&gt;' ' (U+0020)&lt;/code&gt;. If this format is used, each pattern needs to be prepended by its &lt;code&gt;count&lt;/code&gt;, followed by a single colon &lt;code&gt;':' (U+003A)&lt;/code&gt;. If the pattern includes spaces literally, they must be quoted.</source>
          <target state="translated">如果某些本地化要求紧凑的数字模式对于复数形式是不同的，则每个单数和复数模式都可以在一对大括号 &lt;code&gt;'{' (U+007B)&lt;/code&gt; 和 &lt;code&gt;'}' (U+007D)&lt;/code&gt; ，并用空格隔开 &lt;code&gt;' ' (U+0020)&lt;/code&gt; 。如果使用此格式，则每个模式都必须在其 &lt;code&gt;count&lt;/code&gt; 加上一个冒号 &lt;code&gt;':' (U+003A)&lt;/code&gt; 。如果模式在字面上包含空格，则必须用引号引起来。</target>
        </trans-unit>
        <trans-unit id="6b30498fac7ace93c84b231cbf2811b4209e3742" translate="yes" xml:space="preserve">
          <source>In case the client does not explicitly initialize the AlgorithmParameterGenerator (via a call to an &lt;code&gt;engineInit&lt;/code&gt; method), each provider must supply (and document) a default initialization. For example, the Sun provider uses a default modulus prime size of 1024 bits for the generation of DSA parameters.</source>
          <target state="translated">如果客户端未通过调用 &lt;code&gt;engineInit&lt;/code&gt; 方法显式初始化AlgorithmParameterGenerator ，则每个提供程序都必须提供（并记录）默认初始化。例如，Sun提供程序将默认的模数素数大小为1024位用于生成DSA参数。</target>
        </trans-unit>
        <trans-unit id="5a60f8a52be924e57f59281a52dcdd1a0c0876ed" translate="yes" xml:space="preserve">
          <source>In case the client does not explicitly initialize the AlgorithmParameterGenerator (via a call to an &lt;code&gt;engineInit&lt;/code&gt; method), each provider must supply (and document) a default initialization. See the Keysize Restriction sections of the &lt;a href=&quot;https://docs.oracle.com/pls/topic/lookup?ctx=javase15&amp;amp;id=security_guide_jdk_providers&quot;&gt;JDK Providers&lt;/a&gt; document for information on the AlgorithmParameterGenerator defaults used by JDK providers. However, note that defaults may vary across different providers. Additionally, the default value for a provider may change in a future version. Therefore, it is recommended to explicitly initialize the AlgorithmParameterGenerator instead of relying on provider-specific defaults.</source>
          <target state="translated">如果客户端未通过调用 &lt;code&gt;engineInit&lt;/code&gt; 方法显式初始化AlgorithmParameterGenerator ，则每个提供程序都必须提供（并记录）默认初始化。有关&lt;a href=&quot;https://docs.oracle.com/pls/topic/lookup?ctx=javase15&amp;amp;id=security_guide_jdk_providers&quot;&gt;JDK提供程序&lt;/a&gt;使用的AlgorithmParameterGenerator默认值的信息，请参见JDK提供程序文档的&amp;ldquo;密钥大小限制&amp;rdquo;部分。但是，请注意，默认值在不同的提供程序之间可能有所不同。此外，提供者的默认值可能会在将来的版本中更改。因此，建议显式初始化AlgorithmParameterGenerator，而不是依赖提供程序特定的默认值。</target>
        </trans-unit>
        <trans-unit id="68e407b5b13916cde2cd11c5f37eb5f842e4f9a5" translate="yes" xml:space="preserve">
          <source>In case the client does not explicitly initialize the AlgorithmParameterGenerator (via a call to an &lt;code&gt;engineInit&lt;/code&gt; method), each provider must supply (and document) a default initialization. See the Keysize Restriction sections of the &lt;a href=&quot;https://www.oracle.com/pls/topic/lookup?ctx=javase11&amp;amp;id=security_guide_jdk_providers&quot;&gt;JDK Providers&lt;/a&gt; document for information on the AlgorithmParameterGenerator defaults used by JDK providers. However, note that defaults may vary across different providers. Additionally, the default value for a provider may change in a future version. Therefore, it is recommended to explicitly initialize the AlgorithmParameterGenerator instead of relying on provider-specific defaults.</source>
          <target state="translated">如果客户端未通过调用 &lt;code&gt;engineInit&lt;/code&gt; 方法显式初始化AlgorithmParameterGenerator ，则每个提供程序都必须提供（并记录）默认初始化。有关&lt;a href=&quot;https://www.oracle.com/pls/topic/lookup?ctx=javase11&amp;amp;id=security_guide_jdk_providers&quot;&gt;JDK提供程序&lt;/a&gt;使用的AlgorithmParameterGenerator默认值的信息，请参见JDK提供程序文档的&amp;ldquo;密钥大小限制&amp;rdquo;部分。但是，请注意，默认值在不同的提供程序之间可能有所不同。此外，提供者的默认值可能会在将来的版本中更改。因此，建议显式初始化AlgorithmParameterGenerator，而不是依赖提供程序特定的默认值。</target>
        </trans-unit>
        <trans-unit id="a37d2611d020aa41b4751a0d8cd1144f2acda07a" translate="yes" xml:space="preserve">
          <source>In case the client does not explicitly initialize the AlgorithmParameterGenerator (via a call to an &lt;code&gt;init&lt;/code&gt; method), each provider must supply (and document) a default initialization. For example, the Sun provider uses a default modulus prime size of 1024 bits for the generation of DSA parameters.</source>
          <target state="translated">如果客户端未通过调用 &lt;code&gt;init&lt;/code&gt; 方法显式初始化AlgorithmParameterGenerator ，则每个提供程序都必须提供（并记录）默认初始化。例如，Sun提供程序将默认的模数素数大小为1024位用于生成DSA参数。</target>
        </trans-unit>
        <trans-unit id="d74b2c8ae5b09378f034d44e8b2df4f90dd16539" translate="yes" xml:space="preserve">
          <source>In case the client does not explicitly initialize the AlgorithmParameterGenerator (via a call to an &lt;code&gt;init&lt;/code&gt; method), each provider must supply (and document) a default initialization. See the Keysize Restriction sections of the &lt;a href=&quot;https://docs.oracle.com/pls/topic/lookup?ctx=javase15&amp;amp;id=security_guide_jdk_providers&quot;&gt;JDK Providers&lt;/a&gt; document for information on the AlgorithmParameterGenerator defaults used by JDK providers. However, note that defaults may vary across different providers. Additionally, the default value for a provider may change in a future version. Therefore, it is recommended to explicitly initialize the AlgorithmParameterGenerator instead of relying on provider-specific defaults.</source>
          <target state="translated">如果客户端未通过调用 &lt;code&gt;init&lt;/code&gt; 方法显式初始化AlgorithmParameterGenerator ，则每个提供程序都必须提供（并记录）默认初始化。有关&lt;a href=&quot;https://docs.oracle.com/pls/topic/lookup?ctx=javase15&amp;amp;id=security_guide_jdk_providers&quot;&gt;JDK提供程序&lt;/a&gt;使用的AlgorithmParameterGenerator默认值的信息，请参见JDK提供程序文档的&amp;ldquo;密钥大小限制&amp;rdquo;部分。但是，请注意，默认值在不同的提供程序之间可能有所不同。此外，提供者的默认值可能会在将来的版本中更改。因此，建议显式初始化AlgorithmParameterGenerator，而不是依赖提供程序特定的默认值。</target>
        </trans-unit>
        <trans-unit id="618f13f618647d566b20d8751205271f6da0fde1" translate="yes" xml:space="preserve">
          <source>In case the client does not explicitly initialize the AlgorithmParameterGenerator (via a call to an &lt;code&gt;init&lt;/code&gt; method), each provider must supply (and document) a default initialization. See the Keysize Restriction sections of the &lt;a href=&quot;https://www.oracle.com/pls/topic/lookup?ctx=javase11&amp;amp;id=security_guide_jdk_providers&quot;&gt;JDK Providers&lt;/a&gt; document for information on the AlgorithmParameterGenerator defaults used by JDK providers. However, note that defaults may vary across different providers. Additionally, the default value for a provider may change in a future version. Therefore, it is recommended to explicitly initialize the AlgorithmParameterGenerator instead of relying on provider-specific defaults.</source>
          <target state="translated">如果客户端未通过调用 &lt;code&gt;init&lt;/code&gt; 方法显式初始化AlgorithmParameterGenerator ，则每个提供程序都必须提供（并记录）默认初始化。有关&lt;a href=&quot;https://www.oracle.com/pls/topic/lookup?ctx=javase11&amp;amp;id=security_guide_jdk_providers&quot;&gt;JDK提供程序&lt;/a&gt;使用的AlgorithmParameterGenerator默认值的信息，请参见JDK提供程序文档的&amp;ldquo;密钥大小限制&amp;rdquo;部分。但是，请注意，默认值在不同的提供程序之间可能有所不同。此外，提供者的默认值可能会在将来的版本中更改。因此，建议显式初始化AlgorithmParameterGenerator，而不是依赖提供程序特定的默认值。</target>
        </trans-unit>
        <trans-unit id="5eb2b1a734ed185b35dd6d539f47ccd18d6fa259" translate="yes" xml:space="preserve">
          <source>In case the client does not explicitly initialize the KeyGenerator (via a call to an &lt;code&gt;init&lt;/code&gt; method), each provider must supply (and document) a default initialization.</source>
          <target state="translated">如果客户端未通过调用 &lt;code&gt;init&lt;/code&gt; 方法显式初始化KeyGenerator ，则每个提供程序都必须提供（并记录）默认初始化。</target>
        </trans-unit>
        <trans-unit id="8c4df440ea931c6bc94ef4ea292efce1962279c2" translate="yes" xml:space="preserve">
          <source>In case the client does not explicitly initialize the KeyGenerator (via a call to an &lt;code&gt;init&lt;/code&gt; method), each provider must supply (and document) a default initialization. See the Keysize Restriction sections of the &lt;a href=&quot;https://docs.oracle.com/pls/topic/lookup?ctx=javase15&amp;amp;id=security_guide_jdk_providers&quot;&gt;JDK Providers&lt;/a&gt; document for information on the KeyGenerator defaults used by JDK providers. However, note that defaults may vary across different providers. Additionally, the default value for a provider may change in a future version. Therefore, it is recommended to explicitly initialize the KeyGenerator instead of relying on provider-specific defaults.</source>
          <target state="translated">如果客户端未通过调用 &lt;code&gt;init&lt;/code&gt; 方法显式初始化KeyGenerator ，则每个提供程序都必须提供（并记录）默认初始化。有关&lt;a href=&quot;https://docs.oracle.com/pls/topic/lookup?ctx=javase15&amp;amp;id=security_guide_jdk_providers&quot;&gt;JDK提供程序&lt;/a&gt;使用的KeyGenerator默认值的信息，请参见JDK提供程序文档的&amp;ldquo;密钥大小限制&amp;rdquo;部分。但是，请注意，默认值在不同的提供程序之间可能有所不同。此外，提供者的默认值可能会在将来的版本中更改。因此，建议显式初始化KeyGenerator，而不要依赖提供程序特定的默认值。</target>
        </trans-unit>
        <trans-unit id="850cecd70d52ca77c6e849b65f63f33d0551283d" translate="yes" xml:space="preserve">
          <source>In case the client does not explicitly initialize the KeyGenerator (via a call to an &lt;code&gt;init&lt;/code&gt; method), each provider must supply (and document) a default initialization. See the Keysize Restriction sections of the &lt;a href=&quot;https://www.oracle.com/pls/topic/lookup?ctx=javase11&amp;amp;id=security_guide_jdk_providers&quot;&gt;JDK Providers&lt;/a&gt; document for information on the KeyGenerator defaults used by JDK providers. However, note that defaults may vary across different providers. Additionally, the default value for a provider may change in a future version. Therefore, it is recommended to explicitly initialize the KeyGenerator instead of relying on provider-specific defaults.</source>
          <target state="translated">如果客户端未通过调用 &lt;code&gt;init&lt;/code&gt; 方法显式初始化KeyGenerator ，则每个提供程序都必须提供（并记录）默认初始化。有关&lt;a href=&quot;https://www.oracle.com/pls/topic/lookup?ctx=javase11&amp;amp;id=security_guide_jdk_providers&quot;&gt;JDK提供程序&lt;/a&gt;使用的KeyGenerator默认值的信息，请参见JDK提供程序文档的&amp;ldquo;密钥大小限制&amp;rdquo;部分。但是，请注意，默认值在不同的提供程序之间可能有所不同。此外，提供者的默认值可能会在将来的版本中更改。因此，建议显式初始化KeyGenerator，而不要依赖提供程序特定的默认值。</target>
        </trans-unit>
        <trans-unit id="debfe51230845fafd7d09cad852623660ca1f4b3" translate="yes" xml:space="preserve">
          <source>In case the client does not explicitly initialize the KeyPairGenerator (via a call to an &lt;code&gt;initialize&lt;/code&gt; method), each provider must supply (and document) a default initialization. For example, the</source>
          <target state="translated">如果客户端未通过调用 &lt;code&gt;initialize&lt;/code&gt; 方法显式初始化KeyPairGenerator ，则每个提供程序都必须提供（并记录）默认初始化。例如，</target>
        </trans-unit>
        <trans-unit id="4c87f4698bfd8d6cf08b74e7658b62d2e71d7cef" translate="yes" xml:space="preserve">
          <source>In case the client does not explicitly initialize the KeyPairGenerator (via a call to an &lt;code&gt;initialize&lt;/code&gt; method), each provider must supply (and document) a default initialization. See the Keysize Restriction sections of the &lt;a href=&quot;https://docs.oracle.com/pls/topic/lookup?ctx=javase15&amp;amp;id=security_guide_jdk_providers&quot;&gt;JDK Providers&lt;/a&gt; document for information on the KeyPairGenerator defaults used by JDK providers. However, note that defaults may vary across different providers. Additionally, the default value for a provider may change in a future version. Therefore, it is recommended to explicitly initialize the KeyPairGenerator instead of relying on provider-specific defaults.</source>
          <target state="translated">如果客户端未通过调用 &lt;code&gt;initialize&lt;/code&gt; 方法显式初始化KeyPairGenerator ，则每个提供程序都必须提供（并记录）默认初始化。有关&lt;a href=&quot;https://docs.oracle.com/pls/topic/lookup?ctx=javase15&amp;amp;id=security_guide_jdk_providers&quot;&gt;JDK提供程序&lt;/a&gt;使用的KeyPairGenerator默认值的信息，请参见JDK提供程序文档的&amp;ldquo;密钥大小限制&amp;rdquo;部分。但是，请注意，默认值在不同的提供程序之间可能有所不同。此外，提供者的默认值可能会在将来的版本中更改。因此，建议显式初始化KeyPairGenerator而不是依赖于提供程序特定的默认值。</target>
        </trans-unit>
        <trans-unit id="204488c07139beb503a6394353ed2128445b7fb4" translate="yes" xml:space="preserve">
          <source>In case the client does not explicitly initialize the KeyPairGenerator (via a call to an &lt;code&gt;initialize&lt;/code&gt; method), each provider must supply (and document) a default initialization. See the Keysize Restriction sections of the &lt;a href=&quot;https://www.oracle.com/pls/topic/lookup?ctx=javase11&amp;amp;id=security_guide_jdk_providers&quot;&gt;JDK Providers&lt;/a&gt; document for information on the KeyPairGenerator defaults used by JDK providers. However, note that defaults may vary across different providers. Additionally, the default value for a provider may change in a future version. Therefore, it is recommended to explicitly initialize the KeyPairGenerator instead of relying on provider-specific defaults.</source>
          <target state="translated">如果客户端未通过调用 &lt;code&gt;initialize&lt;/code&gt; 方法显式初始化KeyPairGenerator ，则每个提供程序都必须提供（并记录）默认初始化。有关&lt;a href=&quot;https://www.oracle.com/pls/topic/lookup?ctx=javase11&amp;amp;id=security_guide_jdk_providers&quot;&gt;JDK提供程序&lt;/a&gt;使用的KeyPairGenerator默认值的信息，请参见JDK提供程序文档的&amp;ldquo;密钥大小限制&amp;rdquo;部分。但是，请注意，默认值在不同的提供程序之间可能有所不同。此外，提供者的默认值可能会在将来的版本中更改。因此，建议显式初始化KeyPairGenerator而不是依赖于提供程序特定的默认值。</target>
        </trans-unit>
        <trans-unit id="74c4c704743eaa4c51b305733ce161d1198c7af9" translate="yes" xml:space="preserve">
          <source>In cases where the given member is of variable arity (i.e., a method or constructor) the returned method handle will also be of &lt;a href=&quot;methodhandle#asVarargsCollector(java.lang.Class)&quot;&gt;variable arity&lt;/a&gt;. In all other cases, the returned method handle will be of fixed arity.</source>
          <target state="translated">如果给定成员具有可变变量（即方法或构造函数），则返回的方法句柄也将具有&lt;a href=&quot;methodhandle#asVarargsCollector(java.lang.Class)&quot;&gt;可变变量&lt;/a&gt;。在所有其他情况下，返回的方法句柄将具有固定的有效性。</target>
        </trans-unit>
        <trans-unit id="9941fbe4a1552d799e92803cbaeb391d95bf7051" translate="yes" xml:space="preserve">
          <source>In cases where the given member is of variable arity (i.e., a method or constructor) the returned method handle will also be of &lt;a href=&quot;methodhandle#asVarargsCollector-java.lang.Class-&quot;&gt;variable arity&lt;/a&gt;. In all other cases, the returned method handle will be of fixed arity.</source>
          <target state="translated">如果给定成员具有可变变量（即方法或构造函数），则返回的方法句柄也将具有&lt;a href=&quot;methodhandle#asVarargsCollector-java.lang.Class-&quot;&gt;可变变量&lt;/a&gt;。在所有其他情况下，返回的方法句柄将具有固定的有效性。</target>
        </trans-unit>
        <trans-unit id="b23a675004466dd2b4cbce7eda7eaf631095a71f" translate="yes" xml:space="preserve">
          <source>In cases where the inherited channel represents a network socket then the &lt;a href=&quot;../channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; type returned by this method is determined as follows:</source>
          <target state="translated">在继承的通道表示网络套接字的情况下，此方法返回的&lt;a href=&quot;../channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt;类型确定如下：</target>
        </trans-unit>
        <trans-unit id="f6aa2646aaa3d5e37e2c5cce3a7678a57dd20872" translate="yes" xml:space="preserve">
          <source>In cases where the lookup object is &lt;a href=&quot;methodhandles#publicLookup()&quot;&gt;&lt;code&gt;publicLookup()&lt;/code&gt;&lt;/a&gt;, or some other lookup object without &lt;a href=&quot;methodhandles.lookup#privacc&quot;&gt;private access&lt;/a&gt;, the lookup class is disregarded. In such cases, no caller-sensitive method handle can be created, access is forbidden, and the lookup fails with an &lt;code&gt;IllegalAccessException&lt;/code&gt;.</source>
          <target state="translated">如果查找对象是&lt;a href=&quot;methodhandles#publicLookup()&quot;&gt; &lt;code&gt;publicLookup()&lt;/code&gt; &lt;/a&gt;或其他没有&lt;a href=&quot;methodhandles.lookup#privacc&quot;&gt;私有访问权限的&lt;/a&gt;查找对象，则忽略查找类。在这种情况下，无法创建调用方敏感的方法句柄，禁止访问，并且查找失败，并带有 &lt;code&gt;IllegalAccessException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3524328c595110554140b187da4cefa2feca12c6" translate="yes" xml:space="preserve">
          <source>In cases where the lookup object is &lt;a href=&quot;methodhandles#publicLookup()&quot;&gt;&lt;code&gt;publicLookup()&lt;/code&gt;&lt;/a&gt;, or some other lookup object without the &lt;a href=&quot;#hasFullPrivilegeAccess()&quot;&gt;full privilege access&lt;/a&gt;, the lookup class is disregarded. In such cases, no caller-sensitive method handle can be created, access is forbidden, and the lookup fails with an &lt;code&gt;IllegalAccessException&lt;/code&gt;.</source>
          <target state="translated">如果查找对象是&lt;a href=&quot;methodhandles#publicLookup()&quot;&gt; &lt;code&gt;publicLookup()&lt;/code&gt; &lt;/a&gt;或其他没有&lt;a href=&quot;#hasFullPrivilegeAccess()&quot;&gt;完全特权访问权限的&lt;/a&gt;查找对象，则忽略查找类。在这种情况下，无法创建调用方敏感的方法句柄，禁止访问，并且查找失败，并带有 &lt;code&gt;IllegalAccessException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e96745c8c1f08936c49bcea65ee1327783f9c9d0" translate="yes" xml:space="preserve">
          <source>In cases where the lookup object is &lt;a href=&quot;methodhandles#publicLookup--&quot;&gt;&lt;code&gt;publicLookup()&lt;/code&gt;&lt;/a&gt;, or some other lookup object without &lt;a href=&quot;methodhandles.lookup#privacc&quot;&gt;private access&lt;/a&gt;, the lookup class is disregarded. In such cases, no caller-sensitive method handle can be created, access is forbidden, and the lookup fails with an &lt;code&gt;IllegalAccessException&lt;/code&gt;.</source>
          <target state="translated">如果查找对象是&lt;a href=&quot;methodhandles#publicLookup--&quot;&gt; &lt;code&gt;publicLookup()&lt;/code&gt; &lt;/a&gt;或其他一些没有&lt;a href=&quot;methodhandles.lookup#privacc&quot;&gt;私有访问权限的&lt;/a&gt;查找对象，则忽略查找类。在这种情况下，无法创建调用方敏感的方法句柄，禁止访问，并且查找失败，并带有 &lt;code&gt;IllegalAccessException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="610432ed467c71937577f34e5257a28d540e06ac" translate="yes" xml:space="preserve">
          <source>In cases where the stream implementation is able to optimize away the production of some or all the elements (such as with short-circuiting operations like &lt;code&gt;findFirst&lt;/code&gt;, or in the example described in &lt;a href=&quot;#count()&quot;&gt;&lt;code&gt;count()&lt;/code&gt;&lt;/a&gt;), the action will not be invoked for those elements.</source>
          <target state="translated">在流实现能够优化某些或所有元素的产生的情况下（例如使用诸如 &lt;code&gt;findFirst&lt;/code&gt; 之类的短路操作，或者在&lt;a href=&quot;#count()&quot;&gt; &lt;code&gt;count()&lt;/code&gt; 中&lt;/a&gt;描述的示例中），将不会为那些元素调用该操作。 。</target>
        </trans-unit>
        <trans-unit id="77f68deaa108cb1537a1eec87f3fc8ea57159538" translate="yes" xml:space="preserve">
          <source>In client mode, unless the return &lt;a href=&quot;../../../java/util/list&quot;&gt;&lt;code&gt;List&lt;/code&gt;&lt;/a&gt; is empty, the client should use the requested server names to guide its endpoint identification of the peer's identity, and/or other aspects of security policy.</source>
          <target state="translated">在客户端模式下，除非返回&lt;a href=&quot;../../../java/util/list&quot;&gt; &lt;code&gt;List&lt;/code&gt; &lt;/a&gt;为空，否则客户端应使用请求的服务器名称来指导其端点对等身份的标识和/或安全策略的其他方面。</target>
        </trans-unit>
        <trans-unit id="766cdb2ff65ab81907f3f51a9b0d20746cd713e5" translate="yes" xml:space="preserve">
          <source>In conforming implementations of Element Traversal, all objects that implement &lt;a href=&quot;element&quot;&gt;&lt;code&gt;Element&lt;/code&gt;&lt;/a&gt; must also implement the &lt;code&gt;ElementTraversal&lt;/code&gt; interface. Four of the methods, &lt;a href=&quot;#getFirstElementChild()&quot;&gt;&lt;code&gt;getFirstElementChild()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#getLastElementChild()&quot;&gt;&lt;code&gt;getLastElementChild()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#getPreviousElementSibling()&quot;&gt;&lt;code&gt;getPreviousElementSibling()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#getNextElementSibling()&quot;&gt;&lt;code&gt;getNextElementSibling()&lt;/code&gt;&lt;/a&gt;, each provides a live reference to another element with the defined relationship to the current element, if the related element exists. The fifth method, &lt;a href=&quot;#getChildElementCount()&quot;&gt;&lt;code&gt;getChildElementCount()&lt;/code&gt;&lt;/a&gt;, exposes the number of child elements of an element, for preprocessing before navigation.</source>
          <target state="translated">在符合元素遍历的实现中，所有实现&lt;a href=&quot;element&quot;&gt; &lt;code&gt;Element&lt;/code&gt; 的&lt;/a&gt;对象也必须实现 &lt;code&gt;ElementTraversal&lt;/code&gt; 接口。其中的四个方法&lt;a href=&quot;#getFirstElementChild()&quot;&gt; &lt;code&gt;getFirstElementChild()&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#getLastElementChild()&quot;&gt; &lt;code&gt;getLastElementChild()&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#getPreviousElementSibling()&quot;&gt; &lt;code&gt;getPreviousElementSibling()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#getNextElementSibling()&quot;&gt; &lt;code&gt;getNextElementSibling()&lt;/code&gt; &lt;/a&gt;，如果相关元素存在，则每个方法都提供对另一个元素的实时引用，该引用与当前元素具有已定义的关系。第五个方法&lt;a href=&quot;#getChildElementCount()&quot;&gt; &lt;code&gt;getChildElementCount()&lt;/code&gt; &lt;/a&gt;公开元素的子元素数量，以便在导航之前进行预处理。</target>
        </trans-unit>
        <trans-unit id="79b29a8711f23dff025211e81b749f6713301187" translate="yes" xml:space="preserve">
          <source>In contrast, the &lt;a href=&quot;printermoreinfo&quot;&gt;&lt;code&gt;PrinterMoreInfo&lt;/code&gt;&lt;/a&gt; attribute is used to find out more information about this specific printer rather than this general kind of printer.</source>
          <target state="translated">相反，&lt;a href=&quot;printermoreinfo&quot;&gt; &lt;code&gt;PrinterMoreInfo&lt;/code&gt; &lt;/a&gt;属性用于查找有关此特定打印机而不是这种常规打印机的更多信息。</target>
        </trans-unit>
        <trans-unit id="9caffca4032e0bb867acc7983198b345a565191b" translate="yes" xml:space="preserve">
          <source>In contrast, the &lt;a href=&quot;printermoreinfomanufacturer&quot;&gt;&lt;code&gt;PrinterMoreInfoManufacturer&lt;/code&gt;&lt;/a&gt; attribute is used to find out more information about this general kind of printer rather than this specific printer.</source>
          <target state="translated">相比之下，&lt;a href=&quot;printermoreinfomanufacturer&quot;&gt; &lt;code&gt;PrinterMoreInfoManufacturer&lt;/code&gt; &lt;/a&gt;属性用于查找有关此常规打印机而不是此特定打印机的更多信息。</target>
        </trans-unit>
        <trans-unit id="bed3edf217562c5e1423cbcacb264e83e97f8ab1" translate="yes" xml:space="preserve">
          <source>In details, the state model for buttons works as follows when used with the keyboard:</source>
          <target state="translated">详细来说,按钮的状态模型与键盘配合使用时的工作原理如下。</target>
        </trans-unit>
        <trans-unit id="4062e12a39d4486940201fa830bbde974cf851ea" translate="yes" xml:space="preserve">
          <source>In details, the state model for buttons works as follows when used with the mouse:</source>
          <target state="translated">详细来说,按钮的状态模型在使用鼠标时的工作原理如下。</target>
        </trans-unit>
        <trans-unit id="ee40bba43e6448bd8f50c5059985279d975f96e9" translate="yes" xml:space="preserve">
          <source>In doing so, a &lt;a href=&quot;validatorhandler&quot;&gt;&lt;code&gt;ValidatorHandler&lt;/code&gt;&lt;/a&gt; may modify the events, for example by adding defaulted attributes.</source>
          <target state="translated">这样做时，&lt;a href=&quot;validatorhandler&quot;&gt; &lt;code&gt;ValidatorHandler&lt;/code&gt; &lt;/a&gt;可以修改事件，例如，通过添加默认属性。</target>
        </trans-unit>
        <trans-unit id="060627d2546f44e2eb02a70e34bf6f73812e4991" translate="yes" xml:space="preserve">
          <source>In dotall mode, the expression &lt;code&gt;.&lt;/code&gt; matches any character, including a line terminator. By default this expression does not match line terminators.</source>
          <target state="translated">在dotall模式下，表达式 &lt;code&gt;.&lt;/code&gt; 匹配任何字符，包括行终止符。默认情况下，此表达式与行终止符不匹配。</target>
        </trans-unit>
        <trans-unit id="56eb79ce8d988bd4f7d4412f2ff9d697e4ca2aec" translate="yes" xml:space="preserve">
          <source>In each iteration, the iteration variables are passed to an invocation of the &lt;code&gt;body&lt;/code&gt; handle. A non-&lt;code&gt;void&lt;/code&gt; value returned from the body (of type &lt;code&gt;V&lt;/code&gt;) updates the leading iteration variable. The result of the loop handle execution will be the final &lt;code&gt;V&lt;/code&gt; value of that variable (or &lt;code&gt;void&lt;/code&gt; if there is no &lt;code&gt;V&lt;/code&gt; variable).</source>
          <target state="translated">在每次迭代中，迭代变量都传递给 &lt;code&gt;body&lt;/code&gt; 句柄的调用。从主体（类型 &lt;code&gt;V&lt;/code&gt; ）返回的非 &lt;code&gt;void&lt;/code&gt; 值将更新前导迭代变量。循环句柄执行的结果将是该变量的最终 &lt;code&gt;V&lt;/code&gt; 值（如果没有 &lt;code&gt;V&lt;/code&gt; 变量，则为 &lt;code&gt;void&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="d88997d2890c678dab9000d415f1fe8afb3e8043" translate="yes" xml:space="preserve">
          <source>In either case, if the host was specified using the &lt;code&gt;[...]&lt;/code&gt; syntax for numeric IPv6 addresses, the square brackets are not included in the return value here.</source>
          <target state="translated">在这两种情况下，如果使用指定的主机 &lt;code&gt;[...]&lt;/code&gt; 语法数字IPv6地址，方括号不包括在这里的返回值。</target>
        </trans-unit>
        <trans-unit id="4f9f1eeccbc325e134332f21c771ad94fb506cd0" translate="yes" xml:space="preserve">
          <source>In either case, language ranges are sorted in descending order in the Language Priority List based on priority or weight. If a language range appears in the given &lt;code&gt;ranges&lt;/code&gt; more than once, only the first one is included on the Language Priority List.</source>
          <target state="translated">在任何一种情况下，语言范围都基于优先级或权重在语言优先级列表中按降序排序。如果一种语言范围在给定 &lt;code&gt;ranges&lt;/code&gt; 出现多次，则&amp;ldquo;语言优先级列表&amp;rdquo;中仅包含第一个语言范围。</target>
        </trans-unit>
        <trans-unit id="769252c126293283cc7c83a2b1bd6109e998defc" translate="yes" xml:space="preserve">
          <source>In either case, the &quot;*&quot; or &quot;-&quot; character at the end of a wildcard &lt;code&gt;path&lt;/code&gt; is removed before canonicalization or normalization. It is stored in a separate wildcard flag field.</source>
          <target state="translated">无论哪种情况，通配符 &lt;code&gt;path&lt;/code&gt; 末尾的&amp;ldquo; *&amp;rdquo;或&amp;ldquo;-&amp;rdquo;字符在规范化或规范化之前都将被删除。它存储在单独的通配符标志字段中。</target>
        </trans-unit>
        <trans-unit id="55b6c09f46927e3b4d92afe1b61f0c38ea762b03" translate="yes" xml:space="preserve">
          <source>In either case, the class</source>
          <target state="translated">在这两种情况下,该类</target>
        </trans-unit>
        <trans-unit id="236fdad6a9437be057f2da47354343f51080d4cd" translate="yes" xml:space="preserve">
          <source>In either case, the code that instantiates an X.509 certificate consults the value of the &lt;code&gt;cert.provider.x509v1&lt;/code&gt; security property to locate the actual implementation or instantiates a default implementation.</source>
          <target state="translated">在这两种情况下，实例化X.509证书的代码都将查阅 &lt;code&gt;cert.provider.x509v1&lt;/code&gt; 安全属性的值以定位实际的实现或实例化默认的实现。</target>
        </trans-unit>
        <trans-unit id="45f7d360a66191e21bd373f5aba227e8c0490155" translate="yes" xml:space="preserve">
          <source>In either case, the quality setting in an &lt;code&gt;ImageWriteParam&lt;/code&gt; has the same meaning as for the underlying library: 1.00 means a quantization table of all 1's, 0.75 means the &quot;standard&quot;, visually lossless quantization table, and 0.00 means aquantization table of all 255's.</source>
          <target state="translated">无论哪种情况， &lt;code&gt;ImageWriteParam&lt;/code&gt; 中的质量设置都与基础库的含义相同：1.00表示全1的量化表，0.75表示&amp;ldquo;标准&amp;rdquo;，视觉上无损的量化表，0.00表示所有255的量化表。</target>
        </trans-unit>
        <trans-unit id="eb55847a08d18a4afa181d4462c2342b7398dcea" translate="yes" xml:space="preserve">
          <source>In environments in which the delegation model is not strictly hierarchical, class loaders need to be parallel capable, otherwise class loading can lead to deadlocks because the loader lock is held for the duration of the class loading process (see &lt;a href=&quot;classloader#loadClass-java.lang.String-&quot;&gt;&lt;code&gt;&lt;code&gt;loadClass&lt;/code&gt;&lt;/code&gt;&lt;/a&gt; methods).</source>
          <target state="translated">在委派模型不是严格分层的环境中，类加载器需要具有并行功能，否则类加载会导致死锁，因为在类加载过程中保持了加载器锁（请参见&lt;a href=&quot;classloader#loadClass-java.lang.String-&quot;&gt; &lt;code&gt;&lt;code&gt;loadClass&lt;/code&gt;&lt;/code&gt; &lt;/a&gt;方法）。</target>
        </trans-unit>
        <trans-unit id="c22bcef59b65807b22a81446aa681e17a7f9b7cf" translate="yes" xml:space="preserve">
          <source>In essence, a menu is a button with an associated &lt;code&gt;JPopupMenu&lt;/code&gt;. When the &quot;button&quot; is pressed, the &lt;code&gt;JPopupMenu&lt;/code&gt; appears. If the &quot;button&quot; is on the &lt;code&gt;JMenuBar&lt;/code&gt;, the menu is a top-level window. If the &quot;button&quot; is another menu item, then the &lt;code&gt;JPopupMenu&lt;/code&gt; is &quot;pull-right&quot; menu.</source>
          <target state="translated">本质上，菜单是具有关联的 &lt;code&gt;JPopupMenu&lt;/code&gt; 的按钮。当按下&amp;ldquo;按钮&amp;rdquo;时，将显示 &lt;code&gt;JPopupMenu&lt;/code&gt; 。如果&amp;ldquo;按钮&amp;rdquo;在 &lt;code&gt;JMenuBar&lt;/code&gt; 上，则菜单是顶级窗口。如果&amp;ldquo;按钮&amp;rdquo;是另一个菜单项，则 &lt;code&gt;JPopupMenu&lt;/code&gt; 是&amp;ldquo;向右拉&amp;rdquo;菜单。</target>
        </trans-unit>
        <trans-unit id="faab38268cdc96b7c1163f83f9fb2bca22cf6359" translate="yes" xml:space="preserve">
          <source>In every case, elements &lt;code&gt;b[0]&lt;/code&gt; through &lt;code&gt;b[off-1]&lt;/code&gt; and elements &lt;code&gt;b[off+len]&lt;/code&gt; through &lt;code&gt;b[b.length-1]&lt;/code&gt; are unaffected.</source>
          <target state="translated">在每种情况下，元素 &lt;code&gt;b[0]&lt;/code&gt; 至 &lt;code&gt;b[off-1]&lt;/code&gt; 和元素 &lt;code&gt;b[off+len]&lt;/code&gt; 至 &lt;code&gt;b[b.length-1]&lt;/code&gt; 不受影响。</target>
        </trans-unit>
        <trans-unit id="76b01c569fddbef2fd279870bf0626c68e22edb7" translate="yes" xml:space="preserve">
          <source>In every case, elements &lt;code&gt;b[0]&lt;/code&gt; through &lt;code&gt;b[off]&lt;/code&gt; and elements &lt;code&gt;b[off+len]&lt;/code&gt; through &lt;code&gt;b[b.length-1]&lt;/code&gt; are unaffected.</source>
          <target state="translated">在每种情况下，元素 &lt;code&gt;b[0]&lt;/code&gt; 至 &lt;code&gt;b[off]&lt;/code&gt; 和元素 &lt;code&gt;b[off+len]&lt;/code&gt; 至 &lt;code&gt;b[b.length-1]&lt;/code&gt; 不受影响。</target>
        </trans-unit>
        <trans-unit id="801d9d22e0c396affe549d48580efe1c12d56b6f" translate="yes" xml:space="preserve">
          <source>In every other case, an &lt;code&gt;OpenType&lt;/code&gt; is assignable from another &lt;code&gt;OpenType&lt;/code&gt; only if they are equal.</source>
          <target state="translated">在所有其他情况下， &lt;code&gt;OpenType&lt;/code&gt; 字体是从另一个可分配 &lt;code&gt;OpenType&lt;/code&gt; 只有当它们相等。</target>
        </trans-unit>
        <trans-unit id="2542cc96f3c5e1b57effa4d62600ff590801b978" translate="yes" xml:space="preserve">
          <source>In fact, &quot;import ...*&quot; is usually a sign of sloppy programming anyway, so the user should consider this a feature rather than a bug.</source>
          <target state="translated">事实上,无论如何,&quot;import ...*&quot;通常都是编程草率的表现,所以用户应该将其视为一个功能而不是一个bug。</target>
        </trans-unit>
        <trans-unit id="7180b2cd8aff78dc10263ca1b56b42ba5afd94b5" translate="yes" xml:space="preserve">
          <source>In fixed-delay execution, each execution is scheduled relative to the actual execution time of the previous execution. If an execution is delayed for any reason (such as garbage collection or other background activity), subsequent executions will be delayed as well. In the long run, the frequency of execution will generally be slightly lower than the reciprocal of the specified period (assuming the system clock underlying &lt;code&gt;Object.wait(long)&lt;/code&gt; is accurate).</source>
          <target state="translated">在固定延迟执行中，相对于上一次执行的实际执行时间安排每次执行。如果执行由于任何原因（例如垃圾回收或其他后台活动）而延迟，则后续执行也将延迟。从长远来看，执行频率通常会略低于指定周期的倒数（假设 &lt;code&gt;Object.wait(long)&lt;/code&gt; 底层的系统时钟是准确的）。</target>
        </trans-unit>
        <trans-unit id="06dd4ce58b291cfcd7c050a8ac56352c9904d7d1" translate="yes" xml:space="preserve">
          <source>In fixed-delay execution, each execution is scheduled relative to the actual execution time of the previous execution. If an execution is delayed for any reason (such as garbage collection or other background activity), subsequent executions will be delayed as well. In the long run, the frequency of execution will generally be slightly lower than the reciprocal of the specified period (assuming the system clock underlying &lt;code&gt;Object.wait(long)&lt;/code&gt; is accurate). As a consequence of the above, if the scheduled first time is in the past, it is scheduled for immediate execution.</source>
          <target state="translated">在固定延迟执行中，相对于上一次执行的实际执行时间安排每次执行。如果执行由于任何原因（例如垃圾回收或其他后台活动）而延迟，则后续执行也将延迟。从长远来看，执行频率通常会略低于指定周期的倒数（假设 &lt;code&gt;Object.wait(long)&lt;/code&gt; 底层的系统时钟是准确的）。由于上述原因，如果计划的第一次是过去的时间，则计划立即执行。</target>
        </trans-unit>
        <trans-unit id="38f4d1c31bc026707af439dd64fd16f577250fa5" translate="yes" xml:space="preserve">
          <source>In fixed-rate execution, each execution is scheduled relative to the scheduled execution time of the initial execution. If an execution is delayed for any reason (such as garbage collection or other background activity), two or more executions will occur in rapid succession to &quot;catch up.&quot; In the long run, the frequency of execution will be exactly the reciprocal of the specified period (assuming the system clock underlying &lt;code&gt;Object.wait(long)&lt;/code&gt; is accurate).</source>
          <target state="translated">在固定速率执行中，相对于初始执行的计划执行时间来计划每个执行。如果执行由于某种原因（例如垃圾回收或其他后台活动）而延迟，则将快速连续发生两个或更多执行以&amp;ldquo;追上&amp;rdquo;。从长远来看，执行频率将恰好是指定时间段的倒数（假设 &lt;code&gt;Object.wait(long)&lt;/code&gt; 底层的系统时钟是准确的）。</target>
        </trans-unit>
        <trans-unit id="6c5dab1a04b2f64b424e450784bf531fabb4f1ec" translate="yes" xml:space="preserve">
          <source>In fixed-rate execution, each execution is scheduled relative to the scheduled execution time of the initial execution. If an execution is delayed for any reason (such as garbage collection or other background activity), two or more executions will occur in rapid succession to &quot;catch up.&quot; In the long run, the frequency of execution will be exactly the reciprocal of the specified period (assuming the system clock underlying &lt;code&gt;Object.wait(long)&lt;/code&gt; is accurate). As a consequence of the above, if the scheduled first time is in the past, then any &quot;missed&quot; executions will be scheduled for immediate &quot;catch up&quot; execution.</source>
          <target state="translated">在固定速率执行中，相对于初始执行的计划执行时间来计划每个执行。如果执行由于某种原因（例如垃圾回收或其他后台活动）而延迟，则将快速连续发生两个或更多执行以&amp;ldquo;追上&amp;rdquo;。从长远来看，执行频率将恰好是指定时间段的倒数（假设 &lt;code&gt;Object.wait(long)&lt;/code&gt; 底层的系统时钟是准确的）。由于上述原因，如果计划的第一次是过去的时间，那么将为任何&amp;ldquo;遗漏&amp;rdquo;的执行安排立即进行&amp;ldquo;追赶&amp;rdquo;执行。</target>
        </trans-unit>
        <trans-unit id="377721e57496fed42d1cae3373a6f0668f7794a9" translate="yes" xml:space="preserve">
          <source>In general SEVERE messages should describe events that are of considerable importance and which will prevent normal program execution. They should be reasonably intelligible to end users and to system administrators. This level is initialized to &lt;code&gt;1000&lt;/code&gt;.</source>
          <target state="translated">通常，SEVERE消息应描述非常重要的事件，这些事件将阻止正常的程序执行。它们对于最终用户和系统管理员应该是合理理解的。此级别初始化为 &lt;code&gt;1000&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="61cf99ed5ef8da1599e976e4159b4d46eb5f6234" translate="yes" xml:space="preserve">
          <source>In general Swing is not thread safe. All Swing components and related classes, unless otherwise documented, must be accessed on the event dispatching thread.</source>
          <target state="translated">一般来说,Swing不是线程安全的。所有的Swing组件和相关类,除非另有说明,否则必须在事件派遣线程上访问。</target>
        </trans-unit>
        <trans-unit id="ca89517b7bed3fbab9bcbe3cd835aaae375b5494" translate="yes" xml:space="preserve">
          <source>In general WARNING messages should describe events that will be of interest to end users or system managers, or which indicate potential problems. This level is initialized to &lt;code&gt;900&lt;/code&gt;.</source>
          <target state="translated">通常，警告消息应描述最终用户或系统管理员感兴趣的事件，或指示潜在问题的事件。此级别初始化为 &lt;code&gt;900&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="52ab12fc5c3f521826991557e9ca1a023d1a3454" translate="yes" xml:space="preserve">
          <source>In general the FINE level should be used for information that will be broadly interesting to developers who do not have a specialized interest in the specific subsystem.</source>
          <target state="translated">一般来说,FINE级别应该用于那些对特定子系统没有专门兴趣的开发人员广泛感兴趣的信息。</target>
        </trans-unit>
        <trans-unit id="fc5cc8c0864383c85fb2bed4626443c7e7721dce" translate="yes" xml:space="preserve">
          <source>In general the rounding modes and precision setting determine how operations return results with a limited number of digits when the exact result has more digits (perhaps infinitely many in the case of division and square root) than the number of digits returned. First, the total number of digits to return is specified by the &lt;code&gt;MathContext&lt;/code&gt;'s &lt;code&gt;precision&lt;/code&gt; setting; this determines the result's</source>
          <target state="translated">通常，四舍五入模式和精度设置确定当精确结果的位数比返回的位数更多时（精确的结果在除法和平方根的情况下可能无限多）时，操作如何以有限的位数返回结果。首先，要返回的总位数是由 &lt;code&gt;MathContext&lt;/code&gt; 的 &lt;code&gt;precision&lt;/code&gt; 设置指定的；这决定了结果的</target>
        </trans-unit>
        <trans-unit id="1963e8a87e697420d77d12336068a0b78ee8491b" translate="yes" xml:space="preserve">
          <source>In general the rounding modes and precision setting determine how operations return results with a limited number of digits when the exact result has more digits (perhaps infinitely many in the case of division) than the number of digits returned. First, the total number of digits to return is specified by the &lt;code&gt;MathContext&lt;/code&gt;'s &lt;code&gt;precision&lt;/code&gt; setting; this determines the result's</source>
          <target state="translated">通常，舍入模式和精度设置确定当精确结果的位数比返回的位数多时（如果是除法，可能无限多个）时，操作如何以有限的位数返回结果。首先，要返回的总位数是由 &lt;code&gt;MathContext&lt;/code&gt; 的 &lt;code&gt;precision&lt;/code&gt; 设置指定的；这决定了结果的</target>
        </trans-unit>
        <trans-unit id="efb1ad58a65f9bea2add8227af1103b53b3080cd" translate="yes" xml:space="preserve">
          <source>In general this approach is much faster. Compared to the backing store approach this avoids the overhead of maintaining an offscreen buffer and having to do two &lt;code&gt;copyArea&lt;/code&gt;s. Compared to the non backing store case this approach will greatly reduce the painted region.</source>
          <target state="translated">通常，这种方法要快得多。与后备存储方法相比，这避免了维护屏幕外缓冲区以及必须执行两个 &lt;code&gt;copyArea&lt;/code&gt; 的开销。与无后备箱的情况相比，这种方法将大大减少涂漆区域。</target>
        </trans-unit>
        <trans-unit id="c0e94901874b2ae22cda0cfde069060cc90a5196" translate="yes" xml:space="preserve">
          <source>In general, &lt;a href=&quot;string#toLowerCase()&quot;&gt;&lt;code&gt;String.toLowerCase()&lt;/code&gt;&lt;/a&gt; should be used to map characters to lowercase. &lt;code&gt;String&lt;/code&gt; case mapping methods have several benefits over &lt;code&gt;Character&lt;/code&gt; case mapping methods. &lt;code&gt;String&lt;/code&gt; case mapping methods can perform locale-sensitive mappings, context-sensitive mappings, and 1:M character mappings, whereas the &lt;code&gt;Character&lt;/code&gt; case mapping methods cannot.</source>
          <target state="translated">通常，应使用&lt;a href=&quot;string#toLowerCase()&quot;&gt; &lt;code&gt;String.toLowerCase()&lt;/code&gt; &lt;/a&gt;将字符映射为小写。 &lt;code&gt;String&lt;/code&gt; 大小写映射方法比 &lt;code&gt;Character&lt;/code&gt; 大小写映射方法具有多个优点。 &lt;code&gt;String&lt;/code&gt; 大小写映射方法可以执行区域设置敏感的映射，上下文敏感的映射和1：M字符映射，而 &lt;code&gt;Character&lt;/code&gt; 大小写映射方法则不能。</target>
        </trans-unit>
        <trans-unit id="7903ecabcfca49b9b51c9a6417d726476aff19c9" translate="yes" xml:space="preserve">
          <source>In general, &lt;a href=&quot;string#toLowerCase--&quot;&gt;&lt;code&gt;String.toLowerCase()&lt;/code&gt;&lt;/a&gt; should be used to map characters to lowercase. &lt;code&gt;String&lt;/code&gt; case mapping methods have several benefits over &lt;code&gt;Character&lt;/code&gt; case mapping methods. &lt;code&gt;String&lt;/code&gt; case mapping methods can perform locale-sensitive mappings, context-sensitive mappings, and 1:M character mappings, whereas the &lt;code&gt;Character&lt;/code&gt; case mapping methods cannot.</source>
          <target state="translated">通常，应使用&lt;a href=&quot;string#toLowerCase--&quot;&gt; &lt;code&gt;String.toLowerCase()&lt;/code&gt; &lt;/a&gt;将字符映射为小写。 &lt;code&gt;String&lt;/code&gt; 大小写映射方法比 &lt;code&gt;Character&lt;/code&gt; 大小写映射方法具有多个优点。 &lt;code&gt;String&lt;/code&gt; 大小写映射方法可以执行区域设置敏感的映射，上下文敏感的映射和1：M字符映射，而 &lt;code&gt;Character&lt;/code&gt; 大小写映射方法则不能。</target>
        </trans-unit>
        <trans-unit id="fcb952ce2751f84d52d12ddb4b53912b10d6c4f4" translate="yes" xml:space="preserve">
          <source>In general, &lt;a href=&quot;string#toUpperCase()&quot;&gt;&lt;code&gt;String.toUpperCase()&lt;/code&gt;&lt;/a&gt; should be used to map characters to uppercase. &lt;code&gt;String&lt;/code&gt; case mapping methods have several benefits over &lt;code&gt;Character&lt;/code&gt; case mapping methods. &lt;code&gt;String&lt;/code&gt; case mapping methods can perform locale-sensitive mappings, context-sensitive mappings, and 1:M character mappings, whereas the &lt;code&gt;Character&lt;/code&gt; case mapping methods cannot.</source>
          <target state="translated">通常，应使用&lt;a href=&quot;string#toUpperCase()&quot;&gt; &lt;code&gt;String.toUpperCase()&lt;/code&gt; &lt;/a&gt;将字符映射为大写。 &lt;code&gt;String&lt;/code&gt; 大小写映射方法比 &lt;code&gt;Character&lt;/code&gt; 大小写映射方法具有多个优点。 &lt;code&gt;String&lt;/code&gt; 大小写映射方法可以执行区域设置敏感的映射，上下文敏感的映射和1：M字符映射，而 &lt;code&gt;Character&lt;/code&gt; 大小写映射方法则不能。</target>
        </trans-unit>
        <trans-unit id="e84c348879217d2774b2e6f52daa41be1dbd7647" translate="yes" xml:space="preserve">
          <source>In general, &lt;a href=&quot;string#toUpperCase--&quot;&gt;&lt;code&gt;String.toUpperCase()&lt;/code&gt;&lt;/a&gt; should be used to map characters to uppercase. &lt;code&gt;String&lt;/code&gt; case mapping methods have several benefits over &lt;code&gt;Character&lt;/code&gt; case mapping methods. &lt;code&gt;String&lt;/code&gt; case mapping methods can perform locale-sensitive mappings, context-sensitive mappings, and 1:M character mappings, whereas the &lt;code&gt;Character&lt;/code&gt; case mapping methods cannot.</source>
          <target state="translated">通常，应使用&lt;a href=&quot;string#toUpperCase--&quot;&gt; &lt;code&gt;String.toUpperCase()&lt;/code&gt; &lt;/a&gt;将字符映射为大写。 &lt;code&gt;String&lt;/code&gt; 大小写映射方法比 &lt;code&gt;Character&lt;/code&gt; 大小写映射方法具有多个优点。 &lt;code&gt;String&lt;/code&gt; 大小写映射方法可以执行区域设置敏感的映射，上下文敏感的映射和1：M字符映射，而 &lt;code&gt;Character&lt;/code&gt; 大小写映射方法则不能。</target>
        </trans-unit>
        <trans-unit id="d7e17baf4657b727413c0aba5c861df347a6bdea" translate="yes" xml:space="preserve">
          <source>In general, a URL can be broken into several parts. Consider the following example:</source>
          <target state="translated">一般来说,一个URL可以被分解成几个部分。请看下面的例子。</target>
        </trans-unit>
        <trans-unit id="bdd376741f3d8082da9a304e1c250753cd486c5b" translate="yes" xml:space="preserve">
          <source>In general, a Writer sends its output immediately to the underlying character or byte stream. Unless prompt output is required, it is advisable to wrap a BufferedWriter around any Writer whose write() operations may be costly, such as FileWriters and OutputStreamWriters. For example,</source>
          <target state="translated">一般来说,Writer会立即将其输出发送到底层字符或字节流。除非需要提示输出,否则建议将 BufferedWriter 包裹在其 write()操作可能很昂贵的任何 Writer 上,例如 FileWriters 和 OutputStreamWriters。例如</target>
        </trans-unit>
        <trans-unit id="639aff6278df151aefd56fe9abfe51c6c6546a60" translate="yes" xml:space="preserve">
          <source>In general, asynchronous tasks execute in either the thread invoking the operation, e.g. &lt;a href=&quot;httpclient#send(java.net.http.HttpRequest,java.net.http.HttpResponse.BodyHandler)&quot;&gt;sending&lt;/a&gt; an HTTP request, or by the threads supplied by the client's &lt;a href=&quot;httpclient#executor()&quot;&gt;&lt;code&gt;executor&lt;/code&gt;&lt;/a&gt;. Dependent tasks, those that are triggered by returned CompletionStages or CompletableFutures, that do not explicitly specify an executor, execute in the same &lt;a href=&quot;../../../../java.base/java/util/concurrent/completablefuture#defaultExecutor()&quot;&gt;&lt;code&gt;default executor&lt;/code&gt;&lt;/a&gt; as that of &lt;code&gt;
 CompletableFuture&lt;/code&gt;, or the invoking thread if the operation completes before the dependent task is registered.</source>
          <target state="translated">通常，异步任务要么在调用操作（例如&lt;a href=&quot;httpclient#send(java.net.http.HttpRequest,java.net.http.HttpResponse.BodyHandler)&quot;&gt;发送&lt;/a&gt;HTTP请求）的线程中执行，要么在客户端&lt;a href=&quot;httpclient#executor()&quot;&gt; &lt;code&gt;executor&lt;/code&gt; &lt;/a&gt;提供的线程中执行。相关的任务，那些被退回CompletionStages或CompletableFutures触发，没有明确指定遗嘱执行人，执行在同一个&lt;a href=&quot;../../../../java.base/java/util/concurrent/completablefuture#defaultExecutor()&quot;&gt; &lt;code&gt;default executor&lt;/code&gt; &lt;/a&gt;为的 &lt;code&gt; CompletableFuture&lt;/code&gt; 如果从属任务之前，操作完成注册，或者调用线程。</target>
        </trans-unit>
        <trans-unit id="b8c3a1d31a2b60ee471be38513d574e12d32af96" translate="yes" xml:space="preserve">
          <source>In general, creating a connection to a URL is a multistep process:</source>
          <target state="translated">一般来说,创建一个URL的连接是一个多步骤的过程。</target>
        </trans-unit>
        <trans-unit id="bfd8112757a14085d8d97c9f9777d5d3cd54f34f" translate="yes" xml:space="preserve">
          <source>In general, developers should use the &lt;code&gt;UIDefaults&lt;/code&gt; returned from &lt;code&gt;getDefaults()&lt;/code&gt;. As the current look and feel may expect certain values to exist, altering the &lt;code&gt;UIDefaults&lt;/code&gt; returned from this method could have unexpected results.</source>
          <target state="translated">通常，开发人员应使用从 &lt;code&gt;getDefaults()&lt;/code&gt; 返回的 &lt;code&gt;UIDefaults&lt;/code&gt; 。由于当前的外观可能期望某些值存在，因此更改从此方法返回的 &lt;code&gt;UIDefaults&lt;/code&gt; 可能会产生意外的结果。</target>
        </trans-unit>
        <trans-unit id="2098f901fe353218eb3766afcbda6c9dd9a40b32" translate="yes" xml:space="preserve">
          <source>In general, each read request made of a Reader causes a corresponding read request to be made of the underlying character or byte stream. It is therefore advisable to wrap a BufferedReader around any Reader whose read() operations may be costly, such as FileReaders and InputStreamReaders. For example,</source>
          <target state="translated">一般来说,对Reader的每个读请求都会导致对底层字符或字节流的相应读请求。因此,建议将BufferedReader包裹在任何Reader周围,因为这些Reader的read()操作可能是昂贵的,例如FileReaders和InputStreamReaders。例如</target>
        </trans-unit>
        <trans-unit id="3316f354198c51080a3833552e7b39608bce991e" translate="yes" xml:space="preserve">
          <source>In general, if sb refers to an instance of a &lt;code&gt;StringBuffer&lt;/code&gt;, then &lt;code&gt;sb.append(x)&lt;/code&gt; has the same effect as &lt;code&gt;sb.insert(sb.length(), x)&lt;/code&gt;.</source>
          <target state="translated">通常，如果sb引用 &lt;code&gt;StringBuffer&lt;/code&gt; 的实例，则 &lt;code&gt;sb.append(x)&lt;/code&gt; 与 &lt;code&gt;sb.insert(sb.length(), x)&lt;/code&gt; 具有相同的效果。</target>
        </trans-unit>
        <trans-unit id="915babbb9e40489175934fdd5d39ee98d92d2ac1" translate="yes" xml:space="preserve">
          <source>In general, if sb refers to an instance of a &lt;code&gt;StringBuilder&lt;/code&gt;, then &lt;code&gt;sb.append(x)&lt;/code&gt; has the same effect as &lt;code&gt;sb.insert(sb.length(), x)&lt;/code&gt;.</source>
          <target state="translated">通常，如果sb引用 &lt;code&gt;StringBuilder&lt;/code&gt; 的实例，则 &lt;code&gt;sb.append(x)&lt;/code&gt; 与 &lt;code&gt;sb.insert(sb.length(), x)&lt;/code&gt; 具有相同的效果。</target>
        </trans-unit>
        <trans-unit id="42ad5e48d6d5adf2f12d6cf9f61d8fa7a84aac0c" translate="yes" xml:space="preserve">
          <source>In general, if the text used to construct the &lt;code&gt;LineBreakMeasurer&lt;/code&gt; changes, a new &lt;code&gt;LineBreakMeasurer&lt;/code&gt; must be constructed to reflect the change. (The old &lt;code&gt;LineBreakMeasurer&lt;/code&gt; continues to function properly, but it won't be aware of the text change.) Nevertheless, if the text change is the insertion or deletion of a single character, an existing &lt;code&gt;LineBreakMeasurer&lt;/code&gt; can be 'updated' by calling &lt;code&gt;insertChar&lt;/code&gt; or &lt;code&gt;deleteChar&lt;/code&gt;. Updating an existing &lt;code&gt;LineBreakMeasurer&lt;/code&gt; is much faster than creating a new one. Clients who modify text based on user typing should take advantage of these methods.</source>
          <target state="translated">通常，如果用于构造 &lt;code&gt;LineBreakMeasurer&lt;/code&gt; 的文本发生更改，则必须构造一个新的 &lt;code&gt;LineBreakMeasurer&lt;/code&gt; 来反映该更改。（老 &lt;code&gt;LineBreakMeasurer&lt;/code&gt; 继续正常运行，但它不知道该文本的变化。）然而，如果文本的变化是一个单个字符的，现有的插入或删除 &lt;code&gt;LineBreakMeasurer&lt;/code&gt; 可以&amp;ldquo;更新&amp;rdquo;通过调用 &lt;code&gt;insertChar&lt;/code&gt; 或 &lt;code&gt;deleteChar&lt;/code&gt; 。更新现有的 &lt;code&gt;LineBreakMeasurer&lt;/code&gt; 比创建新的LineBreakMeasurer快得多。根据用户键入修改文本的客户端应利用这些方法。</target>
        </trans-unit>
        <trans-unit id="6bd60088580eccde556a63506e5f80dae1b4ac3c" translate="yes" xml:space="preserve">
          <source>In general, it is preferable to use a &lt;code&gt;FileCacheImageInputStream&lt;/code&gt; when reading from a regular &lt;code&gt;InputStream&lt;/code&gt;. This class is provided for cases where it is not possible to create a writable temporary file.</source>
          <target state="translated">通常，从常规 &lt;code&gt;InputStream&lt;/code&gt; 读取时，最好使用 &lt;code&gt;FileCacheImageInputStream&lt;/code&gt; 。此类在无法创建可写临时文件的情况下提供。</target>
        </trans-unit>
        <trans-unit id="21e5e3c075e0b11cb1e347193c00ff4d2551bbce" translate="yes" xml:space="preserve">
          <source>In general, manipulating a date, and even querying a date, is wide open to bugs when the calendar system is unknown at development time. This is why it is essential that code using this interface is subjected to additional code reviews. It is also why an architectural decision to avoid this interface type is usually the correct one.</source>
          <target state="translated">一般来说,在开发时,如果日历系统是未知的,那么对日期的操作,甚至是查询日期,都会有很大的漏洞,这就是为什么使用这个接口的代码必须经过额外的代码审查。这就是为什么使用这种接口的代码必须接受额外的代码审查的原因。这也是为什么避免使用这种接口类型的架构决定通常是正确的。</target>
        </trans-unit>
        <trans-unit id="39aaaeecd067c9c412df4df520158abdb4239fe8" translate="yes" xml:space="preserve">
          <source>In general, parameter values remain in force for repeated use in this &lt;code&gt;RowSet&lt;/code&gt; object's command. Setting a parameter value with the setter methods automatically clears the value of the designated parameter and replaces it with the new specified value.</source>
          <target state="translated">通常，参数值保持有效，以便在此 &lt;code&gt;RowSet&lt;/code&gt; 对象的命令中重复使用。使用setter方法设置参数值会自动清除指定参数的值，并将其替换为新的指定值。</target>
        </trans-unit>
        <trans-unit id="71c31f7c17038994ad8645a2526545f703559d4a" translate="yes" xml:space="preserve">
          <source>In general, parameter values remain in force for repeated use of a &lt;code&gt;RowSet&lt;/code&gt; object. Setting a parameter value automatically clears its previous value. However, in some cases it is useful to immediately release the resources used by the current parameter values, which can be done by calling the method &lt;code&gt;clearParameters&lt;/code&gt;.</source>
          <target state="translated">通常，参数值对于重复使用 &lt;code&gt;RowSet&lt;/code&gt; 对象仍然有效。设置参数值会自动清除其先前的值。但是，在某些情况下，立即释放当前参数值使用的资源很有用，这可以通过调用 &lt;code&gt;clearParameters&lt;/code&gt; 方法来完成。</target>
        </trans-unit>
        <trans-unit id="5618fd2f8fa2eb38f62b620d4f37d70fac329de9" translate="yes" xml:space="preserve">
          <source>In general, parameter values remain in force for repeated use of a statement. Setting a parameter value automatically clears its previous value. However, in some cases it is useful to immediately release the resources used by the current parameter values; this can be done by calling the method &lt;code&gt;clearParameters&lt;/code&gt;.</source>
          <target state="translated">通常，参数值对于重复使用语句仍然有效。设置参数值会自动清除其先前的值。但是，在某些情况下，立即释放当前参数值使用的资源很有用；这可以通过调用 &lt;code&gt;clearParameters&lt;/code&gt; 方法来完成。</target>
        </trans-unit>
        <trans-unit id="d3191d89aec4e6dd8c1fe52f14c52757a8cac353" translate="yes" xml:space="preserve">
          <source>In general, preformatted PDL print data is provided in a byte oriented representation class (byte array, &lt;code&gt;InputStream&lt;/code&gt;, &lt;code&gt;URL&lt;/code&gt;).</source>
          <target state="translated">通常，在面向字节的表示形式类（字节数组， &lt;code&gt;InputStream&lt;/code&gt; ， &lt;code&gt;URL&lt;/code&gt; ）中提供预格式化的PDL打印数据。</target>
        </trans-unit>
        <trans-unit id="fde684fe3ce7e630fddfb34fcb022e3e0a8c906d" translate="yes" xml:space="preserve">
          <source>In general, preformatted PDL print data is provided in a byte oriented representation class (byte array, InputStream, URL).</source>
          <target state="translated">一般来说,预格式化的PDL打印数据是以一个面向字节的表示类(字节数组、InputStream、URL)提供的。</target>
        </trans-unit>
        <trans-unit id="1105749eb220cc12502bb7cf78e0bd9681ecb820" translate="yes" xml:space="preserve">
          <source>In general, preformatted image print data is provided in a byte oriented representation class (byte array, &lt;code&gt;InputStream&lt;/code&gt;, &lt;code&gt;URL&lt;/code&gt;).</source>
          <target state="translated">通常，在面向字节的表示形式类（字节数组， &lt;code&gt;InputStream&lt;/code&gt; ， &lt;code&gt;URL&lt;/code&gt; ）中提供预格式化的图像打印数据。</target>
        </trans-unit>
        <trans-unit id="a1a70f78ea99c155d3ce2eddde22908dd11fa016" translate="yes" xml:space="preserve">
          <source>In general, preformatted image print data is provided in a byte oriented representation class (byte array, InputStream, URL).</source>
          <target state="translated">一般来说,预格式化的图像打印数据是以一个面向字节的表示类(字节数组、InputStream、URL)提供的。</target>
        </trans-unit>
        <trans-unit id="8f59090f50a6fbd17d3d80f0442b0770cb6823af" translate="yes" xml:space="preserve">
          <source>In general, preformatted text print data is provided either in a character oriented representation class (character array, String, Reader) or in a byte oriented representation class (byte array, InputStream, URL).</source>
          <target state="translated">一般来说,预格式化的文本打印数据是以面向字符的表示类(字符数组、String、Reader)或面向字节的表示类(字节数组、InputStream、URL)提供的。</target>
        </trans-unit>
        <trans-unit id="ea1acfd551ae424b2b0f0cdb837009a958059593" translate="yes" xml:space="preserve">
          <source>In general, processors must not knowingly attempt to overwrite existing files that were not generated by some processor. A &lt;code&gt;
 Filer&lt;/code&gt; may reject attempts to open a file corresponding to an existing type, like &lt;code&gt;java.lang.Object&lt;/code&gt;. Likewise, the invoker of the annotation processing tool must not knowingly configure the tool such that the discovered processors will attempt to overwrite existing files that were not generated.</source>
          <target state="translated">通常，处理器不得在有意的情况下尝试覆盖某些处理器未生成的现有文件。甲 &lt;code&gt; Filer&lt;/code&gt; 可以拒绝试图打开对应于现有的类型，像一个文件 &lt;code&gt;java.lang.Object&lt;/code&gt; 中。同样，注释处理工具的调用者也不得故意配置工具，以使发现的处理器将尝试覆盖未生成的现有文件。</target>
        </trans-unit>
        <trans-unit id="e174721fc57e1470b14637e03eed9bd9757b2c64" translate="yes" xml:space="preserve">
          <source>In general, processors must not knowingly attempt to overwrite existing files that were not generated by some processor. A &lt;code&gt;Filer&lt;/code&gt; may reject attempts to open a file corresponding to an existing type, like &lt;code&gt;java.lang.Object&lt;/code&gt;. Likewise, the invoker of the annotation processing tool must not knowingly configure the tool such that the discovered processors will attempt to overwrite existing files that were not generated.</source>
          <target state="translated">通常，处理器不得在有意的情况下尝试覆盖某些处理器未生成的现有文件。甲 &lt;code&gt;Filer&lt;/code&gt; 可以拒绝试图打开对应于现有的类型，像一个文件 &lt;code&gt;java.lang.Object&lt;/code&gt; 中。同样，注释处理工具的调用者也不得故意配置工具，以使发现的处理器将尝试覆盖未生成的现有文件。</target>
        </trans-unit>
        <trans-unit id="431a353f97c38c8d198b7fc7b29758a7a00dead2" translate="yes" xml:space="preserve">
          <source>In general, the best results will be achieved when format-specific metadata objects can be created to encapsulate as much information about the image and its associated metadata as possible, in terms that are understood by the specific &lt;code&gt;ImageWriter&lt;/code&gt; used to perform the encoding.</source>
          <target state="translated">通常，按照用于执行编码的特定 &lt;code&gt;ImageWriter&lt;/code&gt; 理解的方式，创建特定于格式的元数据对象以尽可能多地封装有关图像及其相关元数据的信息时，将获得最佳结果。</target>
        </trans-unit>
        <trans-unit id="53eade6b2898bdabeab389a3447d258d06173156" translate="yes" xml:space="preserve">
          <source>In general, the conditions under which a method handle may be looked up for a method &lt;code&gt;M&lt;/code&gt; are no more restrictive than the conditions under which the lookup class could have compiled, verified, and resolved a call to &lt;code&gt;M&lt;/code&gt;. Where the JVM would raise exceptions like &lt;code&gt;NoSuchMethodError&lt;/code&gt;, a method handle lookup will generally raise a corresponding checked exception, such as &lt;code&gt;NoSuchMethodException&lt;/code&gt;. And the effect of invoking the method handle resulting from the lookup is &lt;a href=&quot;methodhandles.lookup#equiv&quot;&gt;exactly equivalent&lt;/a&gt; to executing the compiled, verified, and resolved call to &lt;code&gt;M&lt;/code&gt;. The same point is true of fields and constructors.</source>
          <target state="translated">通常，可以为方法 &lt;code&gt;M&lt;/code&gt; 查找方法句柄的条件没有比可以由查找类编译，验证和解决对 &lt;code&gt;M&lt;/code&gt; 的调用的条件更严格的限制。 JVM会引发类似 &lt;code&gt;NoSuchMethodError&lt;/code&gt; 的异常，而方法句柄查找通常会引发相应的已检查异常，例如 &lt;code&gt;NoSuchMethodException&lt;/code&gt; 。调用由查找产生的方法句柄的效果与执行对 &lt;code&gt;M&lt;/code&gt; 的编译，验证和解析调用&lt;a href=&quot;methodhandles.lookup#equiv&quot;&gt;完全相同&lt;/a&gt;。字段和构造函数也是如此。</target>
        </trans-unit>
        <trans-unit id="fc8aa2bd1828abadaa5eb8121e1cdc0acddb6b87" translate="yes" xml:space="preserve">
          <source>In general, this method does not need to be overridden by subclasses. All Look and Feel rendering code should reside in the &lt;code&gt;paint&lt;/code&gt; method.</source>
          <target state="translated">通常，此方法不需要被子类覆盖。所有外观渲染代码都应驻留在 &lt;code&gt;paint&lt;/code&gt; 方法中。</target>
        </trans-unit>
        <trans-unit id="7e29aefc51ddd907e426422b3411bda4d27c9e92" translate="yes" xml:space="preserve">
          <source>In general, this method is a lightweight operation for getting an approximate memory usage. For some memory pools, for example, when objects are not packed contiguously, this method may be an expensive operation that requires some computation to determine the current memory usage. An implementation should document when this is the case.</source>
          <target state="translated">一般来说,这个方法是一个轻量级的操作,可以得到一个大概的内存使用量。对于某些内存池来说,例如,当对象没有连续打包时,这个方法可能是一个昂贵的操作,需要一些计算来确定当前的内存使用量。在这种情况下,实现应该记录下来。</target>
        </trans-unit>
        <trans-unit id="ec36e3e2d136d0a7304c8a66d67a23e51eac0920" translate="yes" xml:space="preserve">
          <source>In general, unless otherwise noted in the javadoc, methods and constructors will throw NullPointerException if passed a null argument. The one broad exception to this rule is that the logging convenience methods in the Logger class (the config, entering, exiting, fine, finer, finest, log, logp, logrb, severe, throwing, and warning methods) will accept null values for all arguments except for the initial Level argument (if any).</source>
          <target state="translated">一般来说,除非javadoc中另有说明,否则如果传递了一个空参数,方法和构造函数将抛出NullPointerException。这个规则的一个广泛的例外是,Logger 类中的日志记录方便方法(config、entering、exiting、fine、finer、frequest、log、logp、logrb、severe、throwing 和 warning 方法)将接受所有参数的空值,除了初始 Level 参数(如果有的话)。</target>
        </trans-unit>
        <trans-unit id="7192acbc6c0b02d808beb4e0437459650d042c65" translate="yes" xml:space="preserve">
          <source>In general, user-written adjusters should be static constants:</source>
          <target state="translated">一般来说,用户编写的调整器应该是静态常数。</target>
        </trans-unit>
        <trans-unit id="9d5425a3de90c437c3b6df07d4a422e34dce646a" translate="yes" xml:space="preserve">
          <source>In implementation terms, this method behaves as follows. The result of the parsing phase can be considered to be a map of field to value. The behavior of this method is to cause that map to be filtered between phase 1 and 2, removing all fields other than those specified as arguments to this method.</source>
          <target state="translated">在实现上,这个方法的行为如下。解析阶段的结果可以被认为是字段到值的映射,本方法的行为是使该映射在阶段1和阶段2之间被过滤,删除所有不属于本方法参数的字段。本方法的行为是使该映射在阶段1和阶段2之间被过滤,删除除指定为本方法参数的字段以外的所有字段。</target>
        </trans-unit>
        <trans-unit id="1352cdc6280239b4d087354bb36004ed465fd5c1" translate="yes" xml:space="preserve">
          <source>In its more general form, a &lt;code&gt;reduce&lt;/code&gt; operation on elements of type &lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt; yielding a result of type &lt;code&gt;&amp;lt;U&amp;gt;&lt;/code&gt; requires three parameters:</source>
          <target state="translated">在其更一般的形式中，对类型为 &lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt; 的元素进行 &lt;code&gt;reduce&lt;/code&gt; 运算以产生类型为 &lt;code&gt;&amp;lt;U&amp;gt;&lt;/code&gt; 的结果需要三个参数：</target>
        </trans-unit>
        <trans-unit id="43dfe4436becbfa9f6b5de81d5020076fec9ff35" translate="yes" xml:space="preserve">
          <source>In its typical usage, a &lt;code&gt;Registry&lt;/code&gt; enables RMI client bootstrapping: it provides a simple means for a client to obtain an initial reference to a remote object. Therefore, a registry's remote object implementation is typically exported with a well-known address, such as with a well-known &lt;a href=&quot;../server/objid#REGISTRY_ID&quot;&gt;&lt;code&gt;ObjID&lt;/code&gt;&lt;/a&gt; and TCP port number (default is &lt;a href=&quot;#REGISTRY_PORT&quot;&gt;&lt;code&gt;1099&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">在其典型用法中， &lt;code&gt;Registry&lt;/code&gt; 启用RMI客户端引导程序：它为客户端提供了一种获取远程对象的初始引用的简单方法。因此，通常使用众所周知的地址（例如，众所周知的&lt;a href=&quot;../server/objid#REGISTRY_ID&quot;&gt; &lt;code&gt;ObjID&lt;/code&gt; &lt;/a&gt;和TCP端口号）导出注册表的远程对象实现（默认值为&lt;a href=&quot;#REGISTRY_PORT&quot;&gt; &lt;code&gt;1099&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="77aca6d6bcab1192b1be419302b328975bd20263" translate="yes" xml:space="preserve">
          <source>In lazy implementations then an &lt;code&gt;IOException&lt;/code&gt; may be thrown when using the stream to list the module contents. If this occurs then the &lt;code&gt;IOException&lt;/code&gt; will be wrapped in an &lt;a href=&quot;../../io/uncheckedioexception&quot;&gt;&lt;code&gt;UncheckedIOException&lt;/code&gt;&lt;/a&gt; and thrown from the method that caused the access to be attempted. &lt;code&gt;SecurityException&lt;/code&gt; may also be thrown when using the stream to list the module contents and access is denied by the security manager.</source>
          <target state="translated">在惰性实现中，当使用流列出模块内容时，可能会引发 &lt;code&gt;IOException&lt;/code&gt; 。如果发生这种情况，则 &lt;code&gt;IOException&lt;/code&gt; 将被包装在&lt;a href=&quot;../../io/uncheckedioexception&quot;&gt; &lt;code&gt;UncheckedIOException&lt;/code&gt; 中,&lt;/a&gt;并从导致尝试访问的方法中抛出。当使用流列出模块内容并且安全管理器拒绝访问时，也可能引发 &lt;code&gt;SecurityException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9e886fad24b40d123f8ce1e5b68aaa4e75e75121" translate="yes" xml:space="preserve">
          <source>In many cases, it will be more efficient to look up the name once and use the index query methods rather than using the name query methods repeatedly.</source>
          <target state="translated">在很多情况下,查一次名字就用索引查询方法,比重复使用名字查询方法效率更高。</target>
        </trans-unit>
        <trans-unit id="d236b645a588e6e29bda92b7b1d5fa7a8b31381c" translate="yes" xml:space="preserve">
          <source>In many common situations, for example when working URIs that are known to be either URNs or URLs, the hierarchical URIs being used will always be server-based. They therefore must either be parsed as such or treated as an error. In these cases a statement such as</source>
          <target state="translated">在许多常见的情况下,例如,当处理已知是URN或URL的URI时,使用的分层URI总是基于服务器的。因此,它们必须被解析为基于服务器的URI,或者作为错误处理。在这些情况下,可以使用诸如</target>
        </trans-unit>
        <trans-unit id="ec1d65c264699522caa10138b97ab127e6edf2aa" translate="yes" xml:space="preserve">
          <source>In more formal terms, assume these two type lists:</source>
          <target state="translated">用更正式的说法,假设这两个类型列表。</target>
        </trans-unit>
        <trans-unit id="0e2934043ae8a161cfa924a72c9b0eec317155f8" translate="yes" xml:space="preserve">
          <source>In most cases, an instance of a &lt;code&gt;URLStreamHandler&lt;/code&gt; subclass is not created directly by an application. Rather, the first time a protocol name is encountered when constructing a &lt;code&gt;URL&lt;/code&gt;, the appropriate stream protocol handler is automatically loaded.</source>
          <target state="translated">在大多数情况下， &lt;code&gt;URLStreamHandler&lt;/code&gt; 子类的实例不是由应用程序直接创建的。而是在构造 &lt;code&gt;URL&lt;/code&gt; 时第一次遇到协议名称时，会自动加载适当的流协议处理程序。</target>
        </trans-unit>
        <trans-unit id="39e51666ca03ae4454c2806c86a9f15ed69b1513" translate="yes" xml:space="preserve">
          <source>In most cases, applications should use &lt;a href=&quot;#zone()&quot;&gt;&lt;code&gt;zone()&lt;/code&gt;&lt;/a&gt; as this query is too strict.</source>
          <target state="translated">在大多数情况下，应用程序应使用&lt;a href=&quot;#zone()&quot;&gt; &lt;code&gt;zone()&lt;/code&gt; ,&lt;/a&gt;因为此查询过于严格。</target>
        </trans-unit>
        <trans-unit id="f03c583c4f9a187f67c9d5064698de3c6ba9e5f8" translate="yes" xml:space="preserve">
          <source>In most cases, applications should use &lt;a href=&quot;temporalqueries#zone--&quot;&gt;&lt;code&gt;zone()&lt;/code&gt;&lt;/a&gt; as this query is too strict.</source>
          <target state="translated">在大多数情况下，应用程序应使用&lt;a href=&quot;temporalqueries#zone--&quot;&gt; &lt;code&gt;zone()&lt;/code&gt; ,&lt;/a&gt;因为此查询过于严格。</target>
        </trans-unit>
        <trans-unit id="d8bced82c06bec9c190b301d0f390306ca5fd209" translate="yes" xml:space="preserve">
          <source>In most cases, applications should use this query rather than &lt;code&gt;#zoneId()&lt;/code&gt;.</source>
          <target state="translated">在大多数情况下，应用程序应使用此查询而不是 &lt;code&gt;#zoneId()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ff9326ee0d49e5994ec528af6a841b42fa62eb09" translate="yes" xml:space="preserve">
          <source>In most cases, it is clearer to reverse the calling pattern by using &lt;a href=&quot;../temporal/temporal#minus(java.time.temporal.TemporalAmount)&quot;&gt;&lt;code&gt;Temporal.minus(TemporalAmount)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在大多数情况下，使用&lt;a href=&quot;../temporal/temporal#minus(java.time.temporal.TemporalAmount)&quot;&gt; &lt;code&gt;Temporal.minus(TemporalAmount)&lt;/code&gt; &lt;/a&gt;来反转调用模式会更加清楚。</target>
        </trans-unit>
        <trans-unit id="05534aa8b63ec4048eccf7a07834ab90e9df5565" translate="yes" xml:space="preserve">
          <source>In most cases, it is clearer to reverse the calling pattern by using &lt;a href=&quot;../temporal/temporal#minus-java.time.temporal.TemporalAmount-&quot;&gt;&lt;code&gt;Temporal.minus(TemporalAmount)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在大多数情况下，使用&lt;a href=&quot;../temporal/temporal#minus-java.time.temporal.TemporalAmount-&quot;&gt; &lt;code&gt;Temporal.minus(TemporalAmount)&lt;/code&gt; &lt;/a&gt;来反转调用模式会更加清楚。</target>
        </trans-unit>
        <trans-unit id="1a03a50d10f16d909a9a2f2d2612f04f2547de58" translate="yes" xml:space="preserve">
          <source>In most cases, it is clearer to reverse the calling pattern by using &lt;a href=&quot;../temporal/temporal#plus(java.time.temporal.TemporalAmount)&quot;&gt;&lt;code&gt;Temporal.plus(TemporalAmount)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在大多数情况下，使用&lt;a href=&quot;../temporal/temporal#plus(java.time.temporal.TemporalAmount)&quot;&gt; &lt;code&gt;Temporal.plus(TemporalAmount)&lt;/code&gt; &lt;/a&gt;可以更清楚地反转调用模式。</target>
        </trans-unit>
        <trans-unit id="5ca0f70a9b9175c2c2fe451007859b67358fa814" translate="yes" xml:space="preserve">
          <source>In most cases, it is clearer to reverse the calling pattern by using &lt;a href=&quot;../temporal/temporal#plus-java.time.temporal.TemporalAmount-&quot;&gt;&lt;code&gt;Temporal.plus(TemporalAmount)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在大多数情况下，使用&lt;a href=&quot;../temporal/temporal#plus-java.time.temporal.TemporalAmount-&quot;&gt; &lt;code&gt;Temporal.plus(TemporalAmount)&lt;/code&gt; &lt;/a&gt;来反转调用模式会更加清楚。</target>
        </trans-unit>
        <trans-unit id="e78619b09a6dd4ed26333f4a9efd4ae771d133b4" translate="yes" xml:space="preserve">
          <source>In most cases, it is clearer to reverse the calling pattern by using &lt;a href=&quot;../temporal/temporal#with(java.time.temporal.TemporalAdjuster)&quot;&gt;&lt;code&gt;Temporal.with(TemporalAdjuster)&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">在大多数情况下，使用&lt;a href=&quot;../temporal/temporal#with(java.time.temporal.TemporalAdjuster)&quot;&gt; &lt;code&gt;Temporal.with(TemporalAdjuster)&lt;/code&gt; &lt;/a&gt;可以更清楚地反转调用模式：</target>
        </trans-unit>
        <trans-unit id="4cc6b9a301072df7f4a3865fb76f7c4481348a1a" translate="yes" xml:space="preserve">
          <source>In most cases, it is clearer to reverse the calling pattern by using &lt;a href=&quot;../temporal/temporal#with-java.time.temporal.TemporalAdjuster-&quot;&gt;&lt;code&gt;Temporal.with(TemporalAdjuster)&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">在大多数情况下，使用&lt;a href=&quot;../temporal/temporal#with-java.time.temporal.TemporalAdjuster-&quot;&gt; &lt;code&gt;Temporal.with(TemporalAdjuster)&lt;/code&gt; &lt;/a&gt;可以更清楚地反转调用模式：</target>
        </trans-unit>
        <trans-unit id="3c5ecb0a687c7d88d6e9b87e2938edab6b659f7a" translate="yes" xml:space="preserve">
          <source>In most cases, it is clearer to reverse the calling pattern by using &lt;a href=&quot;temporal/temporal#minus(java.time.temporal.TemporalAmount)&quot;&gt;&lt;code&gt;Temporal.minus(TemporalAmount)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在大多数情况下，使用&lt;a href=&quot;temporal/temporal#minus(java.time.temporal.TemporalAmount)&quot;&gt; &lt;code&gt;Temporal.minus(TemporalAmount)&lt;/code&gt; &lt;/a&gt;来反转调用模式会更加清楚。</target>
        </trans-unit>
        <trans-unit id="8187c2e6793a987f620d69a1063da034bcf390bd" translate="yes" xml:space="preserve">
          <source>In most cases, it is clearer to reverse the calling pattern by using &lt;a href=&quot;temporal/temporal#minus-java.time.temporal.TemporalAmount-&quot;&gt;&lt;code&gt;Temporal.minus(TemporalAmount)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在大多数情况下，使用&lt;a href=&quot;temporal/temporal#minus-java.time.temporal.TemporalAmount-&quot;&gt; &lt;code&gt;Temporal.minus(TemporalAmount)&lt;/code&gt; &lt;/a&gt;来反转调用模式会更加清楚。</target>
        </trans-unit>
        <trans-unit id="eb51aa028ce5cd74c12a4c145f287af28b12ae51" translate="yes" xml:space="preserve">
          <source>In most cases, it is clearer to reverse the calling pattern by using &lt;a href=&quot;temporal/temporal#plus(java.time.temporal.TemporalAmount)&quot;&gt;&lt;code&gt;Temporal.plus(TemporalAmount)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在大多数情况下，使用&lt;a href=&quot;temporal/temporal#plus(java.time.temporal.TemporalAmount)&quot;&gt; &lt;code&gt;Temporal.plus(TemporalAmount)&lt;/code&gt; &lt;/a&gt;可以更清楚地反转调用模式。</target>
        </trans-unit>
        <trans-unit id="0561b8f397e2afe69a4c02418cf7771d9bd7c4a0" translate="yes" xml:space="preserve">
          <source>In most cases, it is clearer to reverse the calling pattern by using &lt;a href=&quot;temporal/temporal#plus-java.time.temporal.TemporalAmount-&quot;&gt;&lt;code&gt;Temporal.plus(TemporalAmount)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在大多数情况下，使用&lt;a href=&quot;temporal/temporal#plus-java.time.temporal.TemporalAmount-&quot;&gt; &lt;code&gt;Temporal.plus(TemporalAmount)&lt;/code&gt; &lt;/a&gt;来反转调用模式会更加清楚。</target>
        </trans-unit>
        <trans-unit id="99db46c681c29fba900cb5c04104ad2c95eeb307" translate="yes" xml:space="preserve">
          <source>In most cases, it is clearer to reverse the calling pattern by using &lt;a href=&quot;temporal/temporal#with(java.time.temporal.TemporalAdjuster)&quot;&gt;&lt;code&gt;Temporal.with(TemporalAdjuster)&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">在大多数情况下，使用&lt;a href=&quot;temporal/temporal#with(java.time.temporal.TemporalAdjuster)&quot;&gt; &lt;code&gt;Temporal.with(TemporalAdjuster)&lt;/code&gt; &lt;/a&gt;可以更清楚地反转调用模式：</target>
        </trans-unit>
        <trans-unit id="56f3a9f6060c00fbd937e2e83c6bfc005f30256c" translate="yes" xml:space="preserve">
          <source>In most cases, it is clearer to reverse the calling pattern by using &lt;a href=&quot;temporal/temporal#with-java.time.temporal.TemporalAdjuster-&quot;&gt;&lt;code&gt;Temporal.with(TemporalAdjuster)&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">在大多数情况下，使用&lt;a href=&quot;temporal/temporal#with-java.time.temporal.TemporalAdjuster-&quot;&gt; &lt;code&gt;Temporal.with(TemporalAdjuster)&lt;/code&gt; &lt;/a&gt;可以更清楚地反转调用模式：</target>
        </trans-unit>
        <trans-unit id="4dc8fca0cd4dde7b02954c863b88c3a8c6cd211a" translate="yes" xml:space="preserve">
          <source>In most cases, the exact pages to be printed will be generated by a device driver and this attribute would not be required. However, when printing an archived document which has already been formatted, the end user may elect to print just a subset of the pages contained in the document. In this case, if a page range of &lt;code&gt;&quot;&lt;i&gt;n&lt;/i&gt;-&lt;i&gt;m&lt;/i&gt;&quot;&lt;/code&gt; is specified, the first page to be printed will be page</source>
          <target state="translated">在大多数情况下，要打印的确切页面将由设备驱动程序生成，并且不需要此属性。但是，当打印已格式化的存档文档时，最终用户可以选择仅打印文档中包含的部分页面。在这种情况下，如果指定的页面范围是 &lt;code&gt;&quot;&lt;i&gt;n&lt;/i&gt;-&lt;i&gt;m&lt;/i&gt;&quot;&lt;/code&gt; ，则要打印的第一页将是</target>
        </trans-unit>
        <trans-unit id="228fae619d417827abbff2695d0e3ef18a476bdf" translate="yes" xml:space="preserve">
          <source>In most cases, the methods defined here will delegate to the associated file system provider to perform the file operations.</source>
          <target state="translated">在大多数情况下,这里定义的方法将委托给相关的文件系统提供者来执行文件操作。</target>
        </trans-unit>
        <trans-unit id="400b1753d04b7af8e5783d26598d8e066c54a2d8" translate="yes" xml:space="preserve">
          <source>In most cases, the transition duration is one hour, however this is not always the case. The duration will be positive for a gap and negative for an overlap. Time-zones are second-based, so the nanosecond part of the duration will be zero.</source>
          <target state="translated">在大多数情况下,过渡期为一小时,但并非总是如此。间隙的持续时间为正数,重叠的持续时间为负数。时区是以秒为基础的,所以持续时间的纳秒部分将为零。</target>
        </trans-unit>
        <trans-unit id="e7ed0da15e8a41892d662dc53e44bec661e54f79" translate="yes" xml:space="preserve">
          <source>In most cases, there is only one valid offset for a local date-time. In the case of an overlap, there are two valid offsets, and the earlier one is used, corresponding to the first occurrence of midnight on the date. In the case of a gap, the zoned date-time will represent the instant just after the gap.</source>
          <target state="translated">在大多数情况下,一个本地日期时间只有一个有效的偏移量。在重叠的情况下,有两个有效的偏移,使用较早的一个,对应于第一次出现的日期的午夜。在有空隙的情况下,区划的日期时间将代表空隙之后的瞬间。</target>
        </trans-unit>
        <trans-unit id="625ac3988fae19a7227d921594f35e99f65364f8" translate="yes" xml:space="preserve">
          <source>In most cases, there is only one valid offset for a local date-time. In the case of an overlap, when clocks are set back, there are two valid offsets. This method uses the earlier offset typically corresponding to &quot;summer&quot;.</source>
          <target state="translated">在大多数情况下,一个本地日期-时间只有一个有效的偏移。在重叠的情况下,当时钟被后退时,有两个有效的偏移量。这种方法使用较早的偏移量,通常对应 &quot;夏季&quot;。</target>
        </trans-unit>
        <trans-unit id="c2b939591e64208fc1e25691b062275e7929457a" translate="yes" xml:space="preserve">
          <source>In most cases, there is only one valid offset for a local date-time. In the case of an overlap, where clocks are set back, there are two valid offsets. If the preferred offset is one of the valid offsets then it is used. Otherwise the earlier valid offset is used, typically corresponding to &quot;summer&quot;.</source>
          <target state="translated">在大多数情况下,一个本地日期-时间只有一个有效的偏移。在时钟后移的重叠情况下,有两个有效的偏移。如果首选的偏移量是其中一个有效的偏移量,那么就使用它。否则使用较早的有效偏移量,通常对应 &quot;夏季&quot;。</target>
        </trans-unit>
        <trans-unit id="cd9baba77f7578454bd94a07cc240ce1b5e694d3" translate="yes" xml:space="preserve">
          <source>In most cases, there is only one valid offset for a local date-time. In the case of an overlap, where clocks are set back, there are two valid offsets. This method uses the earlier offset typically corresponding to &quot;summer&quot;.</source>
          <target state="translated">在大多数情况下,一个本地日期-时间只有一个有效的偏移。在时钟后移的重叠情况下,有两个有效的偏移。这种方法使用较早的偏移量,通常对应 &quot;夏季&quot;。</target>
        </trans-unit>
        <trans-unit id="127050ddf27677df3d01d5dadb8b80d81f1bb8d8" translate="yes" xml:space="preserve">
          <source>In most instances, &lt;code&gt;key&lt;/code&gt; will be &lt;code&gt;action.getValue(NAME)&lt;/code&gt;.</source>
          <target state="translated">在大多数情况下， &lt;code&gt;key&lt;/code&gt; 为 &lt;code&gt;action.getValue(NAME)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1ba29f0eb3427ba3bc8f620c7fd7795c4d04cb6f" translate="yes" xml:space="preserve">
          <source>In multiline mode the expressions &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; match just after or just before, respectively, a line terminator or the end of the input sequence. By default these expressions only match at the beginning and the end of the entire input sequence.</source>
          <target state="translated">在多行模式下，表达式 &lt;code&gt;^&lt;/code&gt; 和 &lt;code&gt;$&lt;/code&gt; 分别在行终止符或输入序列的结尾之后或之前匹配。默认情况下，这些表达式仅在整个输入序列的开头和结尾匹配。</target>
        </trans-unit>
        <trans-unit id="8cd3059f796b099e853c5ec37ef7ff133f0e47a7" translate="yes" xml:space="preserve">
          <source>In naming systems for which the notion of full name does not apply to this binding an &lt;code&gt;UnsupportedOperationException&lt;/code&gt; is thrown. This exception is also thrown when a service provider written before the introduction of the method is in use.</source>
          <target state="translated">在全名概念不适用于此绑定的命名系统中，抛出 &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 。当使用在引入方法之前编写的服务提供者时，也会引发此异常。</target>
        </trans-unit>
        <trans-unit id="2a34c892345a3ff0220626c939a8b01b18ac6ead" translate="yes" xml:space="preserve">
          <source>In negative patterns, the minimum and maximum counts are ignored; these are presumed to be set in the positive pattern.</source>
          <target state="translated">在负数模式中,最小和最大计数被忽略;这些计数被认为是在正数模式中设置的。</target>
        </trans-unit>
        <trans-unit id="31e73ad7a9634e0be529544b2d80db294c151284" translate="yes" xml:space="preserve">
          <source>In older versions of JDK a frame state could only be NORMAL or ICONIFIED. Since JDK 1.4 set of supported frame states is expanded and frame state is represented as a bitwise mask.</source>
          <target state="translated">在旧版本的JDK中,帧状态只能是NORMAL或ICONIFIED。从JDK 1.4开始,支持的帧状态集得到了扩展,帧状态被表示为一个位性掩码。</target>
        </trans-unit>
        <trans-unit id="59d8176c2778d52eb9144cafca492c89026c206d" translate="yes" xml:space="preserve">
          <source>In order for Views to store less state and therefore be more lightweight, the StyleSheet can act as a factory for painters that handle some of the rendering tasks. This allows implementations to determine what they want to cache and have the sharing potentially at the level that a selector is common to multiple views. Since the StyleSheet may be used by views over multiple documents and typically the HTML attributes don't effect the selector being used, the potential for sharing is significant.</source>
          <target state="translated">为了让Views存储更少的状态,从而更加轻量级,StyleSheet可以作为处理一些渲染任务的painters的工厂。这允许实现者决定他们想要缓存的内容,并有可能在一个选择器是多个视图所共有的水平上进行共享。由于样式表可能会被多个文档的视图使用,而且通常HTML属性不会影响正在使用的选择器,因此共享的可能性很大。</target>
        </trans-unit>
        <trans-unit id="c005fc9511ccd0821d902a0c463f0c8001a2d950" translate="yes" xml:space="preserve">
          <source>In order for activation to be successful, one of the following requirements must be met, otherwise &lt;a href=&quot;activationexception&quot;&gt;&lt;code&gt;ActivationException&lt;/code&gt;&lt;/a&gt; is thrown:</source>
          <target state="translated">为了使激活成功，必须满足以下要求之一，否则会抛出&lt;a href=&quot;activationexception&quot;&gt; &lt;code&gt;ActivationException&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="77231df36a359866f2786c79f888114ce42dbf6e" translate="yes" xml:space="preserve">
          <source>In order for major ticks to be painted, &lt;code&gt;setPaintTicks&lt;/code&gt; must be set to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">为了绘制主要刻度线，必须将 &lt;code&gt;setPaintTicks&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="90b0d441ed8104d5d1d6520953b3feb27d631b33" translate="yes" xml:space="preserve">
          <source>In order for minor ticks to be painted, &lt;code&gt;setPaintTicks&lt;/code&gt; must be set to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">为了绘制较小的刻度线，必须将 &lt;code&gt;setPaintTicks&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="027f5f7c874f0b05685665c2baaf2e4a0856aaaa" translate="yes" xml:space="preserve">
          <source>In order for persistence mechanisms to function properly on BeanContextChild instances across a broad variety of scenarios, implementing classes of this interface are required to define as transient, any or all fields, or instance variables, that may contain, or represent, references to the nesting BeanContext instance or other resources obtained from the BeanContext via any unspecified mechanisms.</source>
          <target state="translated">为了使持久化机制能够在广泛的各种场景下在BeanContextChild实例上正常运行,要求该接口的实现类将任何或所有字段或实例变量定义为瞬态,这些字段或实例变量可能包含或表示对嵌套的BeanContext实例或通过任何未指定机制从BeanContext获得的其他资源的引用。</target>
        </trans-unit>
        <trans-unit id="ca3336b46c543839bf0e83bd249246ba9ceac2c3" translate="yes" xml:space="preserve">
          <source>In order to align a &lt;code&gt;SequentialGroup&lt;/code&gt; along the baseline of a baseline aligned &lt;code&gt;ParallelGroup&lt;/code&gt; you need to specify which of the elements of the &lt;code&gt;SequentialGroup&lt;/code&gt; is used to determine the baseline. The element used to calculate the baseline is specified using one of the &lt;code&gt;add&lt;/code&gt; methods that take a &lt;code&gt;boolean&lt;/code&gt;. The last element added with a value of &lt;code&gt;true&lt;/code&gt; for &lt;code&gt;useAsBaseline&lt;/code&gt; is used to calculate the baseline.</source>
          <target state="translated">为了使 &lt;code&gt;SequentialGroup&lt;/code&gt; 沿着基线对齐的 &lt;code&gt;ParallelGroup&lt;/code&gt; 的基线对齐，您需要指定 &lt;code&gt;SequentialGroup&lt;/code&gt; 的哪些元素用于确定基线。用于计算基线的元素是使用采用 &lt;code&gt;boolean&lt;/code&gt; 的 &lt;code&gt;add&lt;/code&gt; 方法之一指定的。为 &lt;code&gt;useAsBaseline&lt;/code&gt; 添加的值为 &lt;code&gt;true&lt;/code&gt; 的最后一个元素用于计算基线。</target>
        </trans-unit>
        <trans-unit id="eff19433d04180ca81ab86aab4794962f4daa886" translate="yes" xml:space="preserve">
          <source>In order to allow changes to be persisted back to the datasource to the originating tables, the &lt;code&gt;acceptChanges&lt;/code&gt; method should be used and called on a JoinRowSet object instance. Implementations can leverage the internal data and update tracking in their implementations to interact with the SyncProvider to persist any changes.</source>
          <target state="translated">为了使更改可以持久化回到原始表的数据源，应该在JoinRowSet对象实例上使用并调用 &lt;code&gt;acceptChanges&lt;/code&gt; 方法。实施可以利用内部数据并在其实施中更新跟踪以与SyncProvider交互以保留任何更改。</target>
        </trans-unit>
        <trans-unit id="0a71a13ccef17116df35b112242d16e8495db897" translate="yes" xml:space="preserve">
          <source>In order to be able to populate itself with data from a database, a rowset needs to set a command property. This property is a query that is a &lt;code&gt;PreparedStatement&lt;/code&gt; object, which allows the query to have parameter placeholders that are set at run time, as opposed to design time. To set these placeholder parameters with values, a rowset provides setter methods for setting values of each data type, similar to the setter methods provided by the &lt;code&gt;PreparedStatement&lt;/code&gt; interface.</source>
          <target state="translated">为了能够使用数据库中的数据填充自身，行集需要设置命令属性。此属性是作为 &lt;code&gt;PreparedStatement&lt;/code&gt; 对象的查询，它允许查询具有在运行时（而不是设计时）设置的参数占位符。要使用值设置这些占位符参数，行集提供用于设置每种数据类型的值的设置器方法，类似于 &lt;code&gt;PreparedStatement&lt;/code&gt; 接口提供的设置器方法。</target>
        </trans-unit>
        <trans-unit id="0ba893cd9f06a3e56a7d28781c82514ba4b91f11" translate="yes" xml:space="preserve">
          <source>In order to be used with a selector, an instance of this class must first be</source>
          <target state="translated">为了与选择器一起使用,这个类的实例必须先被称为 &quot;选择器&quot;。</target>
        </trans-unit>
        <trans-unit id="b98e8db6ce4d9f52c1ffa4b7dff7087581ce0c75" translate="yes" xml:space="preserve">
          <source>In order to create a Cipher object, the application calls the Cipher's &lt;code&gt;getInstance&lt;/code&gt; method, and passes the name of the requested</source>
          <target state="translated">为了创建Cipher对象，应用程序调用Cipher的 &lt;code&gt;getInstance&lt;/code&gt; 方法，并传递所请求的名称。</target>
        </trans-unit>
        <trans-unit id="956aaf85b665f70ca7103583817b288193842ddf" translate="yes" xml:space="preserve">
          <source>In order to create a collecting adapter which collects a predetermined number of arguments, and whose type reflects this predetermined number, use &lt;a href=&quot;#asCollector(java.lang.Class,int)&quot;&gt;&lt;code&gt;asCollector&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">为了创建一个收集适配器，该适配器收集预定数量的参数，并且其类型反映该预定数量，请改用&lt;a href=&quot;#asCollector(java.lang.Class,int)&quot;&gt; &lt;code&gt;asCollector&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="31c0dc79be70085d164b878d4cb4d45a32f8f726" translate="yes" xml:space="preserve">
          <source>In order to create a collecting adapter which collects a predetermined number of arguments, and whose type reflects this predetermined number, use &lt;a href=&quot;methodhandle#asCollector-java.lang.Class-int-&quot;&gt;&lt;code&gt;asCollector&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">为了创建一个收集适配器，该适配器收集预定数量的参数，并且其类型反映该预定数量，请改用&lt;a href=&quot;methodhandle#asCollector-java.lang.Class-int-&quot;&gt; &lt;code&gt;asCollector&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="68bca81ab917de25475d73141757208db5018151" translate="yes" xml:space="preserve">
          <source>In order to create a collecting adapter which is not restricted to a particular number of collected arguments, use &lt;a href=&quot;#asVarargsCollector(java.lang.Class)&quot;&gt;&lt;code&gt;asVarargsCollector&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#withVarargs(boolean)&quot;&gt;&lt;code&gt;withVarargs&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">为了创建不限于特定数量的收集参数的收集适配器，请改用&lt;a href=&quot;#asVarargsCollector(java.lang.Class)&quot;&gt; &lt;code&gt;asVarargsCollector&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#withVarargs(boolean)&quot;&gt; &lt;code&gt;withVarargs&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="53922bd99347421945f987d026bbbefad691f64a" translate="yes" xml:space="preserve">
          <source>In order to create a collecting adapter which is not restricted to a particular number of collected arguments, use &lt;a href=&quot;methodhandle#asVarargsCollector-java.lang.Class-&quot;&gt;&lt;code&gt;asVarargsCollector&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">为了创建不限于特定数量的收集参数的收集适配器，请改用&lt;a href=&quot;methodhandle#asVarargsCollector-java.lang.Class-&quot;&gt; &lt;code&gt;asVarargsCollector&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d50236bff40706c4ebaf917ac3e33937a82d5dd3" translate="yes" xml:space="preserve">
          <source>In order to create an empty keystore, or if the keystore cannot be initialized from a stream, pass &lt;code&gt;null&lt;/code&gt; as the &lt;code&gt;stream&lt;/code&gt; argument.</source>
          <target state="translated">为了创建一个空的密钥库，或者如果不能从流中初始化密钥库，请将 &lt;code&gt;null&lt;/code&gt; 作为 &lt;code&gt;stream&lt;/code&gt; 参数传递。</target>
        </trans-unit>
        <trans-unit id="4caf267f8fd9df9e41675d8b26bc879093570dba" translate="yes" xml:space="preserve">
          <source>In order to create an instance of &lt;code&gt;Cipher&lt;/code&gt;, which encapsulates an instance of this &lt;code&gt;CipherSpi&lt;/code&gt; class, an application calls one of the &lt;a href=&quot;cipher#getInstance(java.lang.String)&quot;&gt;&lt;code&gt;getInstance&lt;/code&gt;&lt;/a&gt; factory methods of the &lt;a href=&quot;cipher&quot;&gt;&lt;code&gt;Cipher&lt;/code&gt;&lt;/a&gt; engine class and specifies the requested</source>
          <target state="translated">为了创建一个 &lt;code&gt;Cipher&lt;/code&gt; 实例，该实例封装了此 &lt;code&gt;CipherSpi&lt;/code&gt; 类的实例，应用程序调用&lt;a href=&quot;cipher&quot;&gt; &lt;code&gt;Cipher&lt;/code&gt; &lt;/a&gt;引擎类的&lt;a href=&quot;cipher#getInstance(java.lang.String)&quot;&gt; &lt;code&gt;getInstance&lt;/code&gt; &lt;/a&gt;工厂方法之一，并指定所请求的</target>
        </trans-unit>
        <trans-unit id="7b607b82a2b60c884e3dbe9e1575c5d5d265ec4d" translate="yes" xml:space="preserve">
          <source>In order to create an instance of &lt;code&gt;Cipher&lt;/code&gt;, which encapsulates an instance of this &lt;code&gt;CipherSpi&lt;/code&gt; class, an application calls one of the &lt;a href=&quot;cipher#getInstance-java.lang.String-&quot;&gt;&lt;code&gt;getInstance&lt;/code&gt;&lt;/a&gt; factory methods of the &lt;a href=&quot;cipher&quot;&gt;&lt;code&gt;Cipher&lt;/code&gt;&lt;/a&gt; engine class and specifies the requested</source>
          <target state="translated">为了创建一个 &lt;code&gt;Cipher&lt;/code&gt; 实例，该实例封装了此 &lt;code&gt;CipherSpi&lt;/code&gt; 类的实例，应用程序调用&lt;a href=&quot;cipher&quot;&gt; &lt;code&gt;Cipher&lt;/code&gt; &lt;/a&gt;引擎类的&lt;a href=&quot;cipher#getInstance-java.lang.String-&quot;&gt; &lt;code&gt;getInstance&lt;/code&gt; &lt;/a&gt;工厂方法之一并指定所请求的</target>
        </trans-unit>
        <trans-unit id="64007bb6dc6fcb0629d5ca08ad2441e78ed9b545" translate="yes" xml:space="preserve">
          <source>In order to do matching a user's preferred locales to a set of language tags, &lt;a href=&quot;http://tools.ietf.org/html/rfc4647&quot;&gt;RFC 4647 Matching of Language Tags&lt;/a&gt; defines two mechanisms: filtering and lookup. &lt;em&gt;Filtering&lt;/em&gt; is used to get all matching locales, whereas &lt;em&gt;lookup&lt;/em&gt; is to choose the best matching locale. Matching is done case-insensitively. These matching mechanisms are described in the following sections.</source>
          <target state="translated">为了将用户的首选语言环境与一组语言标签进行&lt;a href=&quot;http://tools.ietf.org/html/rfc4647&quot;&gt;匹配&lt;/a&gt;，RFC 4647语言标签的匹配定义了两种机制：过滤和查找。&lt;em&gt;过滤&lt;/em&gt;用于获取所有匹配的语言环境，而&lt;em&gt;查找&lt;/em&gt;用于选择最佳匹配的语言环境。匹配不区分大小写。这些匹配机制将在以下各节中介绍。</target>
        </trans-unit>
        <trans-unit id="0d75b74813d64745ba8760b2f7c1ae362c26dd6b" translate="yes" xml:space="preserve">
          <source>In order to do matching a user's preferred locales to a set of language tags, &lt;a href=&quot;https://tools.ietf.org/html/rfc4647&quot;&gt;RFC 4647 Matching of Language Tags&lt;/a&gt; defines two mechanisms: filtering and lookup. &lt;em&gt;Filtering&lt;/em&gt; is used to get all matching locales, whereas &lt;em&gt;lookup&lt;/em&gt; is to choose the best matching locale. Matching is done case-insensitively. These matching mechanisms are described in the following sections.</source>
          <target state="translated">为了将用户的首选语言环境与一组语言标签进行&lt;a href=&quot;https://tools.ietf.org/html/rfc4647&quot;&gt;匹配&lt;/a&gt;，RFC 4647语言标签的匹配定义了两种机制：过滤和查找。&lt;em&gt;过滤&lt;/em&gt;用于获取所有匹配的语言环境，而&lt;em&gt;查找&lt;/em&gt;用于选择最佳匹配的语言环境。匹配不区分大小写。这些匹配机制将在以下各节中介绍。</target>
        </trans-unit>
        <trans-unit id="f843ab19b8395ea6dc81b7d0ba4b053d8211f31d" translate="yes" xml:space="preserve">
          <source>In order to ensure proper run-time semantics of RequireModelMBean, Any subclass of RequiredModelMBean overloading or overriding this method should call &lt;code&gt;super.postDeregister()&lt;/code&gt; in its own &lt;code&gt;postDeregister&lt;/code&gt; implementation.</source>
          <target state="translated">为了确保RequireModelMBean的运行时语义正确，RequiredModelMBean的 &lt;code&gt;super.postDeregister()&lt;/code&gt; 类重载或重写此方法都应在其自己的 &lt;code&gt;postDeregister&lt;/code&gt; 实现中调用super.postDeregister（）。</target>
        </trans-unit>
        <trans-unit id="b37a3f7800e5557d0d455028524d0c955aed3436" translate="yes" xml:space="preserve">
          <source>In order to ensure proper run-time semantics of RequireModelMBean, Any subclass of RequiredModelMBean overloading or overriding this method should call &lt;code&gt;super.postRegister(registrationDone)&lt;/code&gt; in its own &lt;code&gt;postRegister&lt;/code&gt; implementation.</source>
          <target state="translated">为了确保RequireModelMBean的运行时语义正确，RequiredModelMBean的 &lt;code&gt;super.postRegister(registrationDone)&lt;/code&gt; 类重载或重写此方法都应在其自己的 &lt;code&gt;postRegister&lt;/code&gt; 实现中调用super.postRegister（registrationDone）。</target>
        </trans-unit>
        <trans-unit id="2e25f9de51dfcb2d1f611315c4d8da31e3829630" translate="yes" xml:space="preserve">
          <source>In order to ensure proper run-time semantics of RequireModelMBean, Any subclass of RequiredModelMBean overloading or overriding this method should call &lt;code&gt;super.preDeregister()&lt;/code&gt; in its own &lt;code&gt;preDeregister&lt;/code&gt; implementation.</source>
          <target state="translated">为了确保RequireModelMBean的运行时语义正确，RequiredModelMBean的 &lt;code&gt;super.preDeregister()&lt;/code&gt; 类重载或重写此方法都应在其自己的 &lt;code&gt;preDeregister&lt;/code&gt; 实现中调用super.preDeregister（）。</target>
        </trans-unit>
        <trans-unit id="8be29ac641af15071548526b32a215df98b96343" translate="yes" xml:space="preserve">
          <source>In order to ensure proper run-time semantics of RequireModelMBean, Any subclass of RequiredModelMBean overloading or overriding this method should call &lt;code&gt;super.preRegister(server, name)&lt;/code&gt; in its own &lt;code&gt;preRegister&lt;/code&gt; implementation.</source>
          <target state="translated">为了确保RequireModelMBean的运行时语义正确，RequiredModelMBean的 &lt;code&gt;super.preRegister(server, name)&lt;/code&gt; 类重载或重写此方法都应在其自己的 &lt;code&gt;preRegister&lt;/code&gt; 实现中调用super.preRegister（server，name）。</target>
        </trans-unit>
        <trans-unit id="1d55e2199f2b3cc24d9c9bff8ece9cf2b2665ec8" translate="yes" xml:space="preserve">
          <source>In order to ensure that a reclaimable object remains so, the referent of a phantom reference may not be retrieved: The &lt;code&gt;get&lt;/code&gt; method of a phantom reference always returns &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">为了确保保留可回收对象，可能不会检索幻像引用的引用对象：幻像引用的 &lt;code&gt;get&lt;/code&gt; 方法始终返回 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a8da3317d1bcb4070918ebd341897147e3ca33b9" translate="yes" xml:space="preserve">
          <source>In order to explain the interaction between &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;remove&lt;/code&gt; calls, we must model the state transitions of a class value to take into account the alternation between uninitialized and initialized states. To do this, number these states sequentially from zero, and note that uninitialized (or removed) states are numbered with even numbers, while initialized (or re-initialized) states have odd numbers.</source>
          <target state="translated">为了解释 &lt;code&gt;get&lt;/code&gt; 和 &lt;code&gt;remove&lt;/code&gt; 调用之间的交互，我们必须对类值的状态转换建模，以考虑未初始化状态和已初始化状态之间的交替。为此，请从零开始依次编号这些状态，并注意未初始化（或删除）的状态用偶数编号，而初始化（或重新初始化）的状态则为奇数。</target>
        </trans-unit>
        <trans-unit id="ae5e5880459069b953e075dc524330387fe93649" translate="yes" xml:space="preserve">
          <source>In order to initialize the &quot;current path&quot;, the scan must be started by calling one of the &lt;code&gt;scan&lt;/code&gt; methods.</source>
          <target state="translated">为了初始化&amp;ldquo;当前路径&amp;rdquo;，必须通过调用 &lt;code&gt;scan&lt;/code&gt; 方法之一来启动扫描。</target>
        </trans-unit>
        <trans-unit id="c0991e1d5079a5b5ac92f45894b755d53a3f23c5" translate="yes" xml:space="preserve">
          <source>In order to link the &lt;code&gt;invokedynamic&lt;/code&gt; instruction, we need a bootstrap method. A minimalist bootstrap method with Dynalink could look like this:</source>
          <target state="translated">为了链接 &lt;code&gt;invokedynamic&lt;/code&gt; 指令，我们需要一个bootstrap方法。Dynalink的极简引导方法可能如下所示：</target>
        </trans-unit>
        <trans-unit id="b805d69ab19ad3f3d3727f4943dc0a7712be9ed2" translate="yes" xml:space="preserve">
          <source>In order to maintain backward compatibility, the pack file's version is set to accommodate the class files present in the input JAR file. In other words, the pack file version will be the latest, if the class files are the latest and conversely the pack file version will be the oldest if the class file versions are also the oldest. For intermediate class file versions the corresponding pack file version will be used. For example: If the input JAR-files are solely comprised of 1.5 (or lesser) class files, a 1.5 compatible pack file is produced. This will also be the case for archives that have no class files. If the input JAR-files contains a 1.6 class file, then the pack file version will be set to 1.6.</source>
          <target state="translated">为了保持向后的兼容性,包文件的版本被设置为适应输入JAR文件中存在的类文件。换句话说,如果类文件是最新的,那么包文件的版本将是最新的,反之,如果类文件的版本也是最老的,那么包文件的版本将是最老的。对于中间的类文件版本,将使用相应的包文件版本。例如,如果输入的JAR-文件是最新的,那么就会使用相应的包文件版本。如果输入的 JAR 文件仅由 1.5(或更小)的类文件组成,则会产生一个 1.5 兼容的打包文件。这也是没有类文件的存档的情况。如果输入的 JAR 文件包含 1.6 的类文件,那么打包文件的版本将被设置为 1.6。</target>
        </trans-unit>
        <trans-unit id="40ebdaa097d4b8db005e51e585c4da7a094004d1" translate="yes" xml:space="preserve">
          <source>In order to maintain backward-compatibility, specifying a null String, or a String which is formatted incorrectly, returns null.</source>
          <target state="translated">为了保持向后的兼容性,指定一个空字符串,或者一个格式不正确的字符串,返回null。</target>
        </trans-unit>
        <trans-unit id="d3d65dfde4a90052c0dc072e889d8e093b67722e" translate="yes" xml:space="preserve">
          <source>In order to maintain compatibility with existing usage, Locale's constructors retain their behavior prior to the Java Runtime Environment version 1.7. The same is largely true for the &lt;code&gt;toString&lt;/code&gt; method. Thus Locale objects can continue to be used as they were. In particular, clients who parse the output of toString into language, country, and variant fields can continue to do so (although this is strongly discouraged), although the variant field will have additional information in it if script or extensions are present.</source>
          <target state="translated">为了保持与现有用法的兼容性，Locale的构造函数在Java Runtime Environment 1.7版之前保留其行为。对于 &lt;code&gt;toString&lt;/code&gt; 方法，大致相同。因此，语言环境对象可以继续原样使用。特别是，将toString的输出解析为语言，国家和变量字段的客户可以继续这样做（尽管强烈建议不要这样做），尽管如果存在脚本或扩展名，则变量字段中将包含其他信息。</target>
        </trans-unit>
        <trans-unit id="d246a53a5685a8f3eb185469887766737b2fe2fa" translate="yes" xml:space="preserve">
          <source>In order to obtain an invoker method for a particular access mode type, use &lt;a href=&quot;methodhandles#varHandleExactInvoker(java.lang.invoke.VarHandle.AccessMode,java.lang.invoke.MethodType)&quot;&gt;&lt;code&gt;MethodHandles.varHandleExactInvoker(java.lang.invoke.VarHandle.AccessMode, java.lang.invoke.MethodType)&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;methodhandles#varHandleInvoker(java.lang.invoke.VarHandle.AccessMode,java.lang.invoke.MethodType)&quot;&gt;&lt;code&gt;MethodHandles.varHandleInvoker(java.lang.invoke.VarHandle.AccessMode, java.lang.invoke.MethodType)&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;methodhandles.lookup#findVirtual(java.lang.Class,java.lang.String,java.lang.invoke.MethodType)&quot;&gt;&lt;code&gt;Lookup.findVirtual&lt;/code&gt;&lt;/a&gt; API is also able to return a method handle to call an access mode method for any specified access mode type and is equivalent in behaviour to &lt;a href=&quot;methodhandles#varHandleInvoker(java.lang.invoke.VarHandle.AccessMode,java.lang.invoke.MethodType)&quot;&gt;&lt;code&gt;MethodHandles.varHandleInvoker(java.lang.invoke.VarHandle.AccessMode, java.lang.invoke.MethodType)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">为了获得特定访问模式类型的调用程序方法，请使用&lt;a href=&quot;methodhandles#varHandleExactInvoker(java.lang.invoke.VarHandle.AccessMode,java.lang.invoke.MethodType)&quot;&gt; &lt;code&gt;MethodHandles.varHandleExactInvoker(java.lang.invoke.VarHandle.AccessMode, java.lang.invoke.MethodType)&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;methodhandles#varHandleInvoker(java.lang.invoke.VarHandle.AccessMode,java.lang.invoke.MethodType)&quot;&gt; &lt;code&gt;MethodHandles.varHandleInvoker(java.lang.invoke.VarHandle.AccessMode, java.lang.invoke.MethodType)&lt;/code&gt; &lt;/a&gt;。所述&lt;a href=&quot;methodhandles.lookup#findVirtual(java.lang.Class,java.lang.String,java.lang.invoke.MethodType)&quot;&gt; &lt;code&gt;Lookup.findVirtual&lt;/code&gt; &lt;/a&gt; API还能够返回一个方法句柄调用的接入模式的方法对于任何指定的访问模式的类型和是在行为等效&lt;a href=&quot;methodhandles#varHandleInvoker(java.lang.invoke.VarHandle.AccessMode,java.lang.invoke.MethodType)&quot;&gt; &lt;code&gt;MethodHandles.varHandleInvoker(java.lang.invoke.VarHandle.AccessMode, java.lang.invoke.MethodType)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ce4ef230fb80e9e871692b3856524d75987acf48" translate="yes" xml:space="preserve">
          <source>In order to obtain an invoker method for a particular type descriptor, use &lt;a href=&quot;methodhandles#exactInvoker(java.lang.invoke.MethodType)&quot;&gt;&lt;code&gt;MethodHandles.exactInvoker&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;methodhandles#invoker(java.lang.invoke.MethodType)&quot;&gt;&lt;code&gt;MethodHandles.invoker&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;methodhandles.lookup#findVirtual(java.lang.Class,java.lang.String,java.lang.invoke.MethodType)&quot;&gt;&lt;code&gt;Lookup.findVirtual&lt;/code&gt;&lt;/a&gt; API is also able to return a method handle to call &lt;code&gt;invokeExact&lt;/code&gt; or plain &lt;code&gt;invoke&lt;/code&gt;, for any specified type descriptor .</source>
          <target state="translated">为了获得特定类型描述符的调用者方法，请使用&lt;a href=&quot;methodhandles#exactInvoker(java.lang.invoke.MethodType)&quot;&gt; &lt;code&gt;MethodHandles.exactInvoker&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;methodhandles#invoker(java.lang.invoke.MethodType)&quot;&gt; &lt;code&gt;MethodHandles.invoker&lt;/code&gt; &lt;/a&gt;。所述&lt;a href=&quot;methodhandles.lookup#findVirtual(java.lang.Class,java.lang.String,java.lang.invoke.MethodType)&quot;&gt; &lt;code&gt;Lookup.findVirtual&lt;/code&gt; &lt;/a&gt; API还能够返回一个方法句柄调用 &lt;code&gt;invokeExact&lt;/code&gt; 或平原 &lt;code&gt;invoke&lt;/code&gt; ，对于任何指定的类型描述符。</target>
        </trans-unit>
        <trans-unit id="8c341ab99b93cd08ae1cd8fe6f9e4f20ad47ad03" translate="yes" xml:space="preserve">
          <source>In order to obtain an invoker method for a particular type descriptor, use &lt;a href=&quot;methodhandles#exactInvoker-java.lang.invoke.MethodType-&quot;&gt;&lt;code&gt;MethodHandles.exactInvoker&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;methodhandles#invoker-java.lang.invoke.MethodType-&quot;&gt;&lt;code&gt;MethodHandles.invoker&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;methodhandles.lookup#findVirtual-java.lang.Class-java.lang.String-java.lang.invoke.MethodType-&quot;&gt;&lt;code&gt;Lookup.findVirtual&lt;/code&gt;&lt;/a&gt; API is also able to return a method handle to call &lt;code&gt;invokeExact&lt;/code&gt; or plain &lt;code&gt;invoke&lt;/code&gt;, for any specified type descriptor .</source>
          <target state="translated">为了获得特定类型描述符的调用者方法，请使用&lt;a href=&quot;methodhandles#exactInvoker-java.lang.invoke.MethodType-&quot;&gt; &lt;code&gt;MethodHandles.exactInvoker&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;methodhandles#invoker-java.lang.invoke.MethodType-&quot;&gt; &lt;code&gt;MethodHandles.invoker&lt;/code&gt; &lt;/a&gt;。所述&lt;a href=&quot;methodhandles.lookup#findVirtual-java.lang.Class-java.lang.String-java.lang.invoke.MethodType-&quot;&gt; &lt;code&gt;Lookup.findVirtual&lt;/code&gt; &lt;/a&gt; API还能够返回一个方法句柄调用 &lt;code&gt;invokeExact&lt;/code&gt; 或平原 &lt;code&gt;invoke&lt;/code&gt; ，对于任何指定的类型描述符。</target>
        </trans-unit>
        <trans-unit id="810bead2e372dd39834a34f84480e291cf7bbae9" translate="yes" xml:space="preserve">
          <source>In order to pass a live link to a Remote object via a Drag and Drop &lt;code&gt;ACTION_LINK&lt;/code&gt; operation a Mime Content Type of application/x-java-remote-object should be used, where the representation class of the &lt;code&gt;DataFlavor&lt;/code&gt; represents the type of the &lt;code&gt;Remote&lt;/code&gt; interface to be transferred.</source>
          <target state="translated">为了通过拖放 &lt;code&gt;ACTION_LINK&lt;/code&gt; 操作将实时链接传递给Remote对象，应使用application / x-java-remote-object的Mime Content Type，其中 &lt;code&gt;DataFlavor&lt;/code&gt; 的表示形式表示 &lt;code&gt;Remote&lt;/code&gt; 接口的类型。被转移。</target>
        </trans-unit>
        <trans-unit id="7caad4369bff00659280f907da0a4b977bd41341" translate="yes" xml:space="preserve">
          <source>In order to pass namespaced values to transformations, for instance when setting a property or a parameter on a &lt;a href=&quot;transformer&quot;&gt;&lt;code&gt;Transformer&lt;/code&gt;&lt;/a&gt; object, this specification defines that a String &quot;qname&quot; object parameter be passed as two-part string, the namespace URI enclosed in curly braces ({}), followed by the local name. If the qname has a null URI, then the String object only contains the local name. An application can safely check for a non-null URI by testing to see if the first character of the name is a '{' character.</source>
          <target state="translated">为了将命名空间的值传递给转换，例如在&lt;a href=&quot;transformer&quot;&gt; &lt;code&gt;Transformer&lt;/code&gt; &lt;/a&gt;对象上设置属性或参数时，此规范定义将字符串&amp;ldquo; qname&amp;rdquo;对象参数作为两部分字符串传递，命名空间URI用花括号括起来（ {}），然后是本地名称。如果qname的URI为空，则String对象仅包含本地名称。应用程序可以通过测试名称的第一个字符是否为'{'字符来安全地检查非null URI。</target>
        </trans-unit>
        <trans-unit id="7ce62073d8b8243aff397ab4c4bebe1848f0dc18" translate="yes" xml:space="preserve">
          <source>In order to return the version number in a double, when there are more than two components (separated by '.' as defined above), only the first two components are retained. The resulting string is then passed to &lt;a href=&quot;../lang/double#valueOf(java.lang.String)&quot;&gt;&lt;code&gt;Double.valueOf(String)&lt;/code&gt;&lt;/a&gt; to generate version number, i.e. &lt;a href=&quot;#getVersion()&quot;&gt;&lt;code&gt;getVersion()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">为了以双精度形式返回版本号，当有两个以上的组件（如上定义的&amp;ldquo;。&amp;rdquo;分隔）时，仅保留前两个组件。然后将所得的字符串传递给&lt;a href=&quot;../lang/double#valueOf(java.lang.String)&quot;&gt; &lt;code&gt;Double.valueOf(String)&lt;/code&gt; &lt;/a&gt;以生成版本号，即&lt;a href=&quot;#getVersion()&quot;&gt; &lt;code&gt;getVersion()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="264efb423c60280550c1587a3402f655e3fa2c21" translate="yes" xml:space="preserve">
          <source>In order to supply a predicate for the &lt;code&gt;FilteredRowSet&lt;/code&gt;. this interface must be implemented. At this time, the JDBC RowSet Implementations (JSR-114) does not specify any standard filters definitions. By specifying a standard means and mechanism for a range of filters to be defined and deployed with both the reference and vendor implementations of the &lt;code&gt;FilteredRowSet&lt;/code&gt; interface, this allows for a flexible and application motivated implementations of &lt;code&gt;Predicate&lt;/code&gt; to emerge.</source>
          <target state="translated">为了提供 &lt;code&gt;FilteredRowSet&lt;/code&gt; 的谓词。此接口必须实现。目前，JDBC RowSet实现（JSR-114）没有指定任何标准过滤器定义。通过为 &lt;code&gt;FilteredRowSet&lt;/code&gt; 接口的参考实现和供应商实现指定和定义一系列过滤器的标准方法和机制，可以使 &lt;code&gt;Predicate&lt;/code&gt; 灵活，以应用程序为动机的实现出现。</target>
        </trans-unit>
        <trans-unit id="21171aa5fee1cb0c9ac069787ce53f4fb32d4b2d" translate="yes" xml:space="preserve">
          <source>In order to supply localized descriptions of elements and attributes, a &lt;code&gt;ResourceBundle&lt;/code&gt; with a base name of &lt;code&gt;this.getClass().getName() + &quot;Resources&quot;&lt;/code&gt; should be supplied via the usual mechanism used by &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt;. Briefly, the subclasser supplies one or more additional classes according to a naming convention (by default, the fully-qualified name of the subclass extending &lt;code&gt;IIMetadataFormatImpl&lt;/code&gt;, plus the string &quot;Resources&quot;, plus the country, language, and variant codes separated by underscores). At run time, calls to &lt;code&gt;getElementDescription&lt;/code&gt; or &lt;code&gt;getAttributeDescription&lt;/code&gt; will attempt to load such classes dynamically according to the supplied locale, and will use either the element name, or the element name followed by a '/' character followed by the attribute name as a key. This key will be supplied to the &lt;code&gt;ResourceBundle&lt;/code&gt;'s &lt;code&gt;getString&lt;/code&gt; method, and the resulting localized description of the node or attribute is returned.</source>
          <target state="translated">为了提供元素和属性，一个的局部描述 &lt;code&gt;ResourceBundle&lt;/code&gt; 用的基本名称 &lt;code&gt;this.getClass().getName() + &quot;Resources&quot;&lt;/code&gt; 应通过所使用的通常的机构供给 &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; 。简而言之，子类程序根据命名约定提供一个或多个其他类（默认情况下，子类的全限定名称扩展 &lt;code&gt;IIMetadataFormatImpl&lt;/code&gt; ，加上字符串&amp;ldquo; Resources&amp;rdquo;，再加上下划线分隔的国家/地区，语言和变体代码） 。在运行时，调用 &lt;code&gt;getElementDescription&lt;/code&gt; 或 &lt;code&gt;getAttributeDescription&lt;/code&gt; 会尝试根据提供的语言环境动态加载此类，并使用元素名称或元素名称，后跟&amp;ldquo; /&amp;rdquo;字符，后跟属性名称作为键。该键将提供给 &lt;code&gt;ResourceBundle&lt;/code&gt; 的 &lt;code&gt;getString&lt;/code&gt; 方法，并返回结果的节点或属性的本地化描述。</target>
        </trans-unit>
        <trans-unit id="014683c12502c542584ab5d18031c8c4346b0831" translate="yes" xml:space="preserve">
          <source>In order to support the platform-independent handling of action keys, the Java platform uses a few additional virtual key constants for functions that would otherwise have to be recognized by interpreting virtual key codes and modifiers. For example, for Japanese Windows keyboards, VK_ALL_CANDIDATES is returned instead of VK_CONVERT with the ALT modifier.</source>
          <target state="translated">为了支持对动作键的平台独立处理,Java平台对一些额外的虚拟键常量使用,否则就必须通过解释虚拟键代码和修饰符来识别这些功能。例如,对于日本的Windows键盘,VK_ALL_CANDIDATES被返回,而不是使用ALT修饰符的VK_CONVERT。</target>
        </trans-unit>
        <trans-unit id="b948f84b10418ce16ffc2d20202029b8cb2b47a0" translate="yes" xml:space="preserve">
          <source>In order to take advantage of the specialized CRL format supported by this certificate factory, each element in the returned collection view can be typecast to the corresponding CRL class. For example, if this certificate factory implements X.509 CRLs, the elements in the returned collection can be typecast to the &lt;code&gt;X509CRL&lt;/code&gt; class.</source>
          <target state="translated">为了利用此证书工厂支持的特殊CRL格式，可以将返回的集合视图中的每个元素类型转换为相应的CRL类。例如，如果此证书工厂实现X.509 CRL，则可以将返回的集合中的元素类型转换为 &lt;code&gt;X509CRL&lt;/code&gt; 类。</target>
        </trans-unit>
        <trans-unit id="80e182cdf13fd4175ed2ea3f937aa79716e1a63a" translate="yes" xml:space="preserve">
          <source>In order to take advantage of the specialized CRL format supported by this certificate factory, the returned CRL object can be typecast to the corresponding CRL class. For example, if this certificate factory implements X.509 CRLs, the returned CRL object can be typecast to the &lt;code&gt;X509CRL&lt;/code&gt; class.</source>
          <target state="translated">为了利用此证书工厂支持的专用CRL格式，可以将返回的CRL对象类型转换为相应的CRL类。例如，如果此证书工厂实现X.509 CRL，则可以将返回的CRL对象类型转换为 &lt;code&gt;X509CRL&lt;/code&gt; 类。</target>
        </trans-unit>
        <trans-unit id="01401a15feb01ba8cb6b8c41aeda0f7926741999" translate="yes" xml:space="preserve">
          <source>In order to take advantage of the specialized certificate format supported by this certificate factory, each element in the returned collection view can be typecast to the corresponding certificate class. For example, if this certificate factory implements X.509 certificates, the elements in the returned collection can be typecast to the &lt;code&gt;X509Certificate&lt;/code&gt; class.</source>
          <target state="translated">为了利用此证书工厂支持的专用证书格式，可以将返回的集合视图中的每个元素类型转换为相应的证书类。例如，如果此证书工厂实现X.509证书，则可以将返回的集合中的元素类型转换为 &lt;code&gt;X509Certificate&lt;/code&gt; 类。</target>
        </trans-unit>
        <trans-unit id="dbcefe87046aa2f225b01d92aac3ff3e9e108c45" translate="yes" xml:space="preserve">
          <source>In order to take advantage of the specialized certificate format supported by this certificate factory, the returned certificate object can be typecast to the corresponding certificate class. For example, if this certificate factory implements X.509 certificates, the returned certificate object can be typecast to the &lt;code&gt;X509Certificate&lt;/code&gt; class.</source>
          <target state="translated">为了利用此证书工厂支持的专用证书格式，可以将返回的证书对象类型转换为相应的证书类。例如，如果此证书工厂实现X.509证书，则可以将返回的证书对象类型转换为 &lt;code&gt;X509Certificate&lt;/code&gt; 类。</target>
        </trans-unit>
        <trans-unit id="4526bf5772005a098203e20083dabc3115a81c2b" translate="yes" xml:space="preserve">
          <source>In order to use the optimistic concurrency control routine, the &lt;code&gt;RIOptimisticProvider&lt;/code&gt; maintains both its current value and its original value (the value it had immediately preceding the current value). Note that if no changes have been made to the data in a &lt;code&gt;RowSet&lt;/code&gt; object, its current values and its original values are the same, both being the values with which the &lt;code&gt;RowSet&lt;/code&gt; object was initially populated. However, once any values in the &lt;code&gt;RowSet&lt;/code&gt; object have been changed, the current values and the original values will be different, though at this stage, the original values are still the initial values. With any subsequent changes to data in a &lt;code&gt;RowSet&lt;/code&gt; object, its original values and current values will still differ, but its original values will be the values that were previously the current values.</source>
          <target state="translated">为了使用乐观并发控制例程， &lt;code&gt;RIOptimisticProvider&lt;/code&gt; 保留其当前值和其原始值（它在当前值之前的值）。请注意，如果未对 &lt;code&gt;RowSet&lt;/code&gt; 对象中的数据进行任何更改，则其当前值和原始值都相同，这两个值都是最初填充 &lt;code&gt;RowSet&lt;/code&gt; 对象时使用的值。但是，一旦更改 &lt;code&gt;RowSet&lt;/code&gt; 对象中的任何值，当前值和原始值将有所不同，尽管在此阶段，原始值仍然是初始值。在 &lt;code&gt;RowSet&lt;/code&gt; 中对数据进行任何后续更改 对象，其原始值和当前值仍会有所不同，但其原始值将是以前的当前值。</target>
        </trans-unit>
        <trans-unit id="9662b58c0cd62c1e89334c9b72a6441f78201246" translate="yes" xml:space="preserve">
          <source>In other respects, a &lt;code&gt;VolatileCallSite&lt;/code&gt; is interchangeable with &lt;code&gt;MutableCallSite&lt;/code&gt;.</source>
          <target state="translated">在其他方面， &lt;code&gt;VolatileCallSite&lt;/code&gt; 可与 &lt;code&gt;MutableCallSite&lt;/code&gt; 互换。</target>
        </trans-unit>
        <trans-unit id="d25898f69afb15ff5dda349d53baa06f69e822e2" translate="yes" xml:space="preserve">
          <source>In other words for the best results use an LCD display with a digital display connector and specify the appropriate sub-pixel configuration.</source>
          <target state="translated">换句话说,为了达到最好的效果,请使用带有数字显示连接器的液晶显示器,并指定适当的子像素配置。</target>
        </trans-unit>
        <trans-unit id="460f5295687a3c368d02873df1172a34752df226" translate="yes" xml:space="preserve">
          <source>In other words, an invocation of this method has exactly the same effect as invoking &lt;code&gt;new String(encode(src), StandardCharsets.ISO_8859_1)&lt;/code&gt;.</source>
          <target state="translated">换句话说，此方法的调用与调用 &lt;code&gt;new String(encode(src), StandardCharsets.ISO_8859_1)&lt;/code&gt; 效果完全相同。</target>
        </trans-unit>
        <trans-unit id="61a5057b103f32156f27c9e72a6cd22cf425b56f" translate="yes" xml:space="preserve">
          <source>In other words, an invocation of this method of the form &lt;code&gt;dst.put(src)&lt;/code&gt; has exactly the same effect as the loop</source>
          <target state="translated">换句话说，以 &lt;code&gt;dst.put(src)&lt;/code&gt; 形式调用此方法具有与循环完全相同的效果。</target>
        </trans-unit>
        <trans-unit id="4a97cb7c262be521a458a66846dc006d3685b23d" translate="yes" xml:space="preserve">
          <source>In other words, an invocation of this method of the form &lt;code&gt;dst.put(src, off, len)&lt;/code&gt; has exactly the same effect as the loop</source>
          <target state="translated">换句话说，以 &lt;code&gt;dst.put(src, off, len)&lt;/code&gt; 形式调用此方法具有与循环完全相同的效果。</target>
        </trans-unit>
        <trans-unit id="12ad70fe4669e051fdd06980e62705cee95c894a" translate="yes" xml:space="preserve">
          <source>In other words, an invocation of this method of the form &lt;code&gt;dst.put(src, start, end)&lt;/code&gt; has exactly the same effect as the loop</source>
          <target state="translated">换句话说，以 &lt;code&gt;dst.put(src, start, end)&lt;/code&gt; 形式调用此方法具有与循环完全相同的效果。</target>
        </trans-unit>
        <trans-unit id="4ac9d9eff73538c3cdb11833e85cd96968621454" translate="yes" xml:space="preserve">
          <source>In other words, an invocation of this method of the form &lt;code&gt;dst.put(src,&amp;nbsp;off,&amp;nbsp;len)&lt;/code&gt; has exactly the same effect as the loop</source>
          <target state="translated">换句话说，以 &lt;code&gt;dst.put(src,&amp;nbsp;off,&amp;nbsp;len)&lt;/code&gt; 形式调用此方法具有与循环完全相同的效果。</target>
        </trans-unit>
        <trans-unit id="356e5407810f1577f49a325b3dc66beaf9ce52a3" translate="yes" xml:space="preserve">
          <source>In other words, an invocation of this method of the form &lt;code&gt;dst.put(src,&amp;nbsp;start,&amp;nbsp;end)&lt;/code&gt; has exactly the same effect as the loop</source>
          <target state="translated">换句话说，以 &lt;code&gt;dst.put(src,&amp;nbsp;start,&amp;nbsp;end)&lt;/code&gt; 形式调用此方法具有与循环完全相同的效果。</target>
        </trans-unit>
        <trans-unit id="1a3bcb813c7ffe2873d728a358d0e842e6cd293f" translate="yes" xml:space="preserve">
          <source>In other words, an invocation of this method of the form &lt;code&gt;src.get(dst, off, len)&lt;/code&gt; has exactly the same effect as the loop</source>
          <target state="translated">换句话说，以 &lt;code&gt;src.get(dst, off, len)&lt;/code&gt; 形式调用此方法与循环具有完全相同的效果。</target>
        </trans-unit>
        <trans-unit id="f5e54dab6d94048e7a8977a11929efc013de3da6" translate="yes" xml:space="preserve">
          <source>In other words, an invocation of this method of the form &lt;code&gt;src.get(dst,&amp;nbsp;off,&amp;nbsp;len)&lt;/code&gt; has exactly the same effect as the loop</source>
          <target state="translated">换句话说，以 &lt;code&gt;src.get(dst,&amp;nbsp;off,&amp;nbsp;len)&lt;/code&gt; 形式调用此方法具有与循环完全相同的效果。</target>
        </trans-unit>
        <trans-unit id="aea96e5b08f931cbd38dfab20fcd644c9067f3df" translate="yes" xml:space="preserve">
          <source>In other words, it does not follow symbolic links, and visits all levels of the file tree.</source>
          <target state="translated">换句话说,它不遵循符号链接,并访问文件树的所有层次。</target>
        </trans-unit>
        <trans-unit id="c6ec43bec0b5d5c5060ec2f33c0616c173c9f676" translate="yes" xml:space="preserve">
          <source>In other words, it visits all levels of the file tree.</source>
          <target state="translated">换句话说,它访问文件树的所有层次。</target>
        </trans-unit>
        <trans-unit id="1c26574665b279451ba4a488577fb7d302c5b7eb" translate="yes" xml:space="preserve">
          <source>In other words, the result is the same as the value of the expression:</source>
          <target state="translated">换句话说,结果和表达式的值是一样的。</target>
        </trans-unit>
        <trans-unit id="505244a8ed297e57506cfc02395be44d1d47281d" translate="yes" xml:space="preserve">
          <source>In other words, this method returns a &lt;code&gt;Byte&lt;/code&gt; object equal to the value of:</source>
          <target state="translated">换句话说，此方法返回一个 &lt;code&gt;Byte&lt;/code&gt; 对象，该对象等于：</target>
        </trans-unit>
        <trans-unit id="1369f9d282c98b0db1a38a7bb381cd40063821b2" translate="yes" xml:space="preserve">
          <source>In other words, this method returns a &lt;code&gt;Long&lt;/code&gt; object equal to the value of:</source>
          <target state="translated">换句话说，此方法返回一个 &lt;code&gt;Long&lt;/code&gt; 对象，该对象等于：</target>
        </trans-unit>
        <trans-unit id="ba6028b1e1ba371422242dcd6a746ef6b3d2d511" translate="yes" xml:space="preserve">
          <source>In other words, this method returns a &lt;code&gt;Short&lt;/code&gt; object equal to the value of:</source>
          <target state="translated">换句话说，此方法返回一个 &lt;code&gt;Short&lt;/code&gt; 对象，该对象等于：</target>
        </trans-unit>
        <trans-unit id="9a00355912a405656ac89583daae0b5f9ae8b495" translate="yes" xml:space="preserve">
          <source>In other words, this method returns an &lt;code&gt;Integer&lt;/code&gt; object equal to the value of:</source>
          <target state="translated">换句话说，此方法返回一个 &lt;code&gt;Integer&lt;/code&gt; 对象，该对象等于：</target>
        </trans-unit>
        <trans-unit id="97ff7fb7f0f6bafc2c9433156da41b6f41305d24" translate="yes" xml:space="preserve">
          <source>In particular this class implements certain required semantics of the &lt;code&gt;Doc&lt;/code&gt; specification as follows:</source>
          <target state="translated">特别是，此类实现了 &lt;code&gt;Doc&lt;/code&gt; 规范的某些必需语义，如下所示：</target>
        </trans-unit>
        <trans-unit id="41833e830e1de28bbdb99be4725e3eef06b2861c" translate="yes" xml:space="preserve">
          <source>In particular this class implements certain required semantics of the Doc specification as follows:</source>
          <target state="translated">特别是这个类实现了Doc规范的某些必要语义,具体如下。</target>
        </trans-unit>
        <trans-unit id="a948b83113ae7326141669ba70d964072cd3a296" translate="yes" xml:space="preserve">
          <source>In particular, for a mouse with one, two, or three buttons this method may return the following values:</source>
          <target state="translated">特别是对于一个有一个、两个或三个按钮的鼠标,这个方法可以返回以下值。</target>
        </trans-unit>
        <trans-unit id="81bb4c56da829ee7121302c977f07bc6625c5153" translate="yes" xml:space="preserve">
          <source>In particular, if the two ObjectName instances have different domains then their order is the lexicographical order of the domains. The ordering of the key property list remains unspecified.</source>
          <target state="translated">特别是,如果两个ObjectName实例具有不同的域,那么它们的顺序就是域的词法顺序。关键属性列表的顺序仍然没有规定。</target>
        </trans-unit>
        <trans-unit id="5894ea611cab3c030c00283ed49599698fcfcfad" translate="yes" xml:space="preserve">
          <source>In particular, operations on collection-views do</source>
          <target state="translated">特别是,对集合视图的操作,可以做到</target>
        </trans-unit>
        <trans-unit id="8661f32f8775daadf95377f956a10599c2e08e36" translate="yes" xml:space="preserve">
          <source>In particular, the current thread is required to issue a fresh read of the target from memory, and must not fail to see a recent update to the target by another thread.</source>
          <target state="translated">特别是要求当前线程从内存中发出对目标的全新读取,并且不能看不到其他线程最近对目标的更新。</target>
        </trans-unit>
        <trans-unit id="005c3ba59a8712aeaee68de4ef1f56b993202750" translate="yes" xml:space="preserve">
          <source>In particular, the current thread may choose to reuse the result of a previous read of the target from memory, and may fail to see a recent update to the target by another thread.</source>
          <target state="translated">特别是,当前线程可能会选择重用之前从内存中读取目标的结果,可能看不到另一个线程最近对目标的更新。</target>
        </trans-unit>
        <trans-unit id="a4260599128e85660497f6cee135c7909951b6ba" translate="yes" xml:space="preserve">
          <source>In particular, the model makes a distinction between declared language constructs, like the &lt;a href=&quot;element/package-summary&quot;&gt;element&lt;/a&gt; representing &lt;code&gt;java.util.Set&lt;/code&gt;, and the family of &lt;a href=&quot;type/package-summary&quot;&gt;types&lt;/a&gt; that may be associated with an element, like the raw type &lt;code&gt;java.util.Set&lt;/code&gt;, &lt;code&gt;
 java.util.Set&amp;lt;String&amp;gt;&lt;/code&gt;, and &lt;code&gt;java.util.Set&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">特别是，该模型在声明的语言构造（例如表示 &lt;code&gt;java.util.Set&lt;/code&gt; 的&lt;a href=&quot;element/package-summary&quot;&gt;元素）&lt;/a&gt;和可能与该元素关联的&lt;a href=&quot;type/package-summary&quot;&gt;类型&lt;/a&gt;族（例如原始类型 &lt;code&gt;java.util.Set&lt;/code&gt; ， &lt;code&gt; java.util.Set&amp;lt;String&amp;gt;&lt;/code&gt; 之间进行区分。 Set &amp;lt;String&amp;gt;和 &lt;code&gt;java.util.Set&amp;lt;T&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2a0c491100aaf4dd16c8cf6cf2c75893b008214b" translate="yes" xml:space="preserve">
          <source>In particular, the model makes a distinction between static language constructs, like the &lt;a href=&quot;element/package-summary&quot;&gt;element&lt;/a&gt; representing &lt;code&gt;java.util.Set&lt;/code&gt;, and the family of &lt;a href=&quot;type/package-summary&quot;&gt;types&lt;/a&gt; that may be associated with an element, like the raw type &lt;code&gt;java.util.Set&lt;/code&gt;, &lt;code&gt;
 java.util.Set&amp;lt;String&amp;gt;&lt;/code&gt;, and &lt;code&gt;java.util.Set&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">特别是，该模型在静态语言构造（例如表示 &lt;code&gt;java.util.Set&lt;/code&gt; 的&lt;a href=&quot;element/package-summary&quot;&gt;元素）&lt;/a&gt;和可能与该元素关联的&lt;a href=&quot;type/package-summary&quot;&gt;类型&lt;/a&gt;族（例如原始类型 &lt;code&gt;java.util.Set&lt;/code&gt; ， &lt;code&gt; java.util.Set&amp;lt;String&amp;gt;&lt;/code&gt; 之间进行了区分。 Set &amp;lt;String&amp;gt;和 &lt;code&gt;java.util.Set&amp;lt;T&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="397ea1619f838bf6759858af4a9e7980654e1c14" translate="yes" xml:space="preserve">
          <source>In particular, the model makes a distinction between static language constructs, like the &lt;a href=&quot;element/package-summary&quot;&gt;element&lt;/a&gt; representing &lt;code&gt;java.util.Set&lt;/code&gt;, and the family of &lt;a href=&quot;type/package-summary&quot;&gt;types&lt;/a&gt; that may be associated with an element, like the raw type &lt;code&gt;java.util.Set&lt;/code&gt;, &lt;code&gt;java.util.Set&amp;lt;String&amp;gt;&lt;/code&gt;, and &lt;code&gt;java.util.Set&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">特别地，该模型在静态语言构造（例如表示 &lt;code&gt;java.util.Set&lt;/code&gt; 的&lt;a href=&quot;element/package-summary&quot;&gt;元素）&lt;/a&gt;和可能与该元素关联的&lt;a href=&quot;type/package-summary&quot;&gt;类型&lt;/a&gt;族（例如原始类型 &lt;code&gt;java.util.Set&lt;/code&gt; ， &lt;code&gt;java.util.Set&amp;lt;String&amp;gt;&lt;/code&gt; 之间进行区分。 Set &amp;lt;String&amp;gt;和 &lt;code&gt;java.util.Set&amp;lt;T&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f662f0574d9aac457b04052d9413b3d9616ae3c4" translate="yes" xml:space="preserve">
          <source>In particular, the resolver is only called for functions in an another namespace (functions with an explicit prefix). This means that you cannot use the &lt;code&gt;XPathFunctionResolver&lt;/code&gt; to implement specifications like &lt;a href=&quot;http://www.w3.org/TR/xmldsig-core/&quot;&gt;XML-Signature Syntax and Processing&lt;/a&gt; which extend the function library of XPath 1.0 in the same namespace. This is a consequence of the design of the resolver.</source>
          <target state="translated">特别是，仅针对另一个命名空间中的函数（具有显式前缀的函数）调用解析器。这意味着您不能使用 &lt;code&gt;XPathFunctionResolver&lt;/code&gt; 来实现&lt;a href=&quot;http://www.w3.org/TR/xmldsig-core/&quot;&gt;XML签名语法和处理之&lt;/a&gt;类的规范，这些规范在同一名称空间中扩展了XPath 1.0的功能库。这是解析器设计的结果。</target>
        </trans-unit>
        <trans-unit id="4a7b85f1a7177b465a8c40afcadae5d65f90a3ee" translate="yes" xml:space="preserve">
          <source>In particular, the resolver is only called for functions in an another namespace (functions with an explicit prefix). This means that you cannot use the &lt;code&gt;XPathFunctionResolver&lt;/code&gt; to implement specifications like &lt;a href=&quot;https://www.w3.org/TR/xmldsig-core/&quot;&gt;XML-Signature Syntax and Processing&lt;/a&gt; which extend the function library of XPath 1.0 in the same namespace. This is a consequence of the design of the resolver.</source>
          <target state="translated">特别是，仅针对另一个命名空间中的函数（具有显式前缀的函数）调用解析器。这意味着您不能使用 &lt;code&gt;XPathFunctionResolver&lt;/code&gt; 来实现&lt;a href=&quot;https://www.w3.org/TR/xmldsig-core/&quot;&gt;XML签名语法和处理之&lt;/a&gt;类的规范，这些规范在同一名称空间中扩展了XPath 1.0的功能库。这是解析器设计的结果。</target>
        </trans-unit>
        <trans-unit id="6d59d813a2d2c234fbceea2f8ac2972003697777" translate="yes" xml:space="preserve">
          <source>In particular, this class handles most or all of the details of byte order interpretation, buffering, mark/reset, discarding, closing, and disposing.</source>
          <target state="translated">特别是,该类处理了字节顺序解释、缓冲、标记/重置、丢弃、关闭和处理的大部分或全部细节。</target>
        </trans-unit>
        <trans-unit id="9e3426680847347aed69bf7f9bd9aa973db72a2e" translate="yes" xml:space="preserve">
          <source>In particular, this interface is intended to be a common abstraction for constructs that have different formats but important common uses. For example, different types of certificates, such as X.509 certificates and PGP certificates, share general certificate functionality (the need to encode and decode certificates) and some types of information, such as a public key, the principal whose key it is, and the guarantor guaranteeing that the public key is that of the specified principal. So an implementation of X.509 certificates and an implementation of PGP certificates can both utilize the Certificate interface, even though their formats and additional types and amounts of information stored are different.</source>
          <target state="translated">特别是,这个接口的目的是为那些格式不同但有重要共同用途的构造提供一个共同的抽象。例如,不同类型的证书,如X.509证书和PGP证书,共享一般的证书功能(需要对证书进行编码和解码)和一些类型的信息,如公钥、其密钥的委托人以及保证公钥是指定委托人的保证人。因此,X.509证书的实现和PGP证书的实现都可以使用证书接口,尽管它们的格式和附加的信息类型和存储量是不同的。</target>
        </trans-unit>
        <trans-unit id="2e10efdd6b0f7e97bb954a45d7a40fb01f574c42" translate="yes" xml:space="preserve">
          <source>In particular, unrelated threads may fail to see the updated target until they perform a read from memory. Stronger guarantees can be created by putting appropriate operations into the bootstrap method and/or the target methods used at any given call site.</source>
          <target state="translated">特别是,不相关的线程可能看不到更新的目标,直到它们执行从内存中读取。可以通过在引导方法和/或在任何给定调用站点使用的目标方法中加入适当的操作来创建更强的保证。</target>
        </trans-unit>
        <trans-unit id="b8f69fa80998eb9c6dbcb7b318ca2c3c6434c7cd" translate="yes" xml:space="preserve">
          <source>In passing these statements to the output stream, where they will be executed, side effects are made to the &lt;code&gt;newInstance&lt;/code&gt;. In most cases this allows the problem of properties whose values depend on each other to actually help the serialization process by making the number of statements that need to be written to the output smaller. In general, the problem of handling interdependent properties is reduced to that of finding an order for the properties in a class such that no property value depends on the value of a subsequent property.</source>
          <target state="translated">将这些语句传递到将在其中执行的输出流时，会对 &lt;code&gt;newInstance&lt;/code&gt; 产生副作用。在大多数情况下，这使属性值相互依赖的问题可以通过减少需要写入输出的语句数来实际帮助序列化过程。通常，将处理相互依赖的属性的问题简化为在类中查找属性的顺序的问题，以使属性值不依赖于后续属性的值。</target>
        </trans-unit>
        <trans-unit id="4594727a51da542b6483bfc22c69e4100582700e" translate="yes" xml:space="preserve">
          <source>In performing an operation on a name that spans multiple namespaces, a context from one naming system may need to pass the operation on to the next naming system. The context implementation does this by first constructing a &lt;code&gt;CannotProceedException&lt;/code&gt; containing information pinpointing how far it has proceeded. It then obtains a continuation context from JNDI by calling &lt;code&gt;getContinuationContext&lt;/code&gt;. The context implementation should then resume the context operation by invoking the same operation on the continuation context, using the remainder of the name that has not yet been resolved.</source>
          <target state="translated">在对跨越多个名称空间的名称执行操作时，来自一个命名系统的上下文可能需要将操作传递给下一个命名系统。上下文实现是通过首先构造一个 &lt;code&gt;CannotProceedException&lt;/code&gt; 来实现此目的的，该CannotProceedException包含精确指出它进行了多远的信息。然后，它通过调用 &lt;code&gt;getContinuationContext&lt;/code&gt; 从JNDI获取延续上下文。然后，上下文实现应使用尚未解析的名称的其余部分，通过在延续上下文上调用相同的操作来恢复上下文操作。</target>
        </trans-unit>
        <trans-unit id="6f56d490a4b579758b87f7072b8c010487f0805a" translate="yes" xml:space="preserve">
          <source>In practical terms, the &lt;code&gt;Chronology&lt;/code&gt; instance also acts as a factory. The &lt;a href=&quot;#of(java.lang.String)&quot;&gt;&lt;code&gt;of(String)&lt;/code&gt;&lt;/a&gt; method allows an instance to be looked up by identifier, while the &lt;a href=&quot;#ofLocale(java.util.Locale)&quot;&gt;&lt;code&gt;ofLocale(Locale)&lt;/code&gt;&lt;/a&gt; method allows lookup by locale.</source>
          <target state="translated">实际上， &lt;code&gt;Chronology&lt;/code&gt; 实例还充当工厂。的&lt;a href=&quot;#of(java.lang.String)&quot;&gt; &lt;code&gt;of(String)&lt;/code&gt; &lt;/a&gt;方法允许通过标识符来搜索一个实例起来，而&lt;a href=&quot;#ofLocale(java.util.Locale)&quot;&gt; &lt;code&gt;ofLocale(Locale)&lt;/code&gt; &lt;/a&gt;方法允许查找由区域设置。</target>
        </trans-unit>
        <trans-unit id="12abb72312e94f1909297d8e075f5705219a1c91" translate="yes" xml:space="preserve">
          <source>In practical terms, the &lt;code&gt;Chronology&lt;/code&gt; instance also acts as a factory. The &lt;a href=&quot;chronology#of-java.lang.String-&quot;&gt;&lt;code&gt;of(String)&lt;/code&gt;&lt;/a&gt; method allows an instance to be looked up by identifier, while the &lt;a href=&quot;chronology#ofLocale-java.util.Locale-&quot;&gt;&lt;code&gt;ofLocale(Locale)&lt;/code&gt;&lt;/a&gt; method allows lookup by locale.</source>
          <target state="translated">实际上， &lt;code&gt;Chronology&lt;/code&gt; 实例还充当工厂。的&lt;a href=&quot;chronology#of-java.lang.String-&quot;&gt; &lt;code&gt;of(String)&lt;/code&gt; &lt;/a&gt;方法允许通过标识符来搜索一个实例起来，而&lt;a href=&quot;chronology#ofLocale-java.util.Locale-&quot;&gt; &lt;code&gt;ofLocale(Locale)&lt;/code&gt; &lt;/a&gt;方法允许查找由区域设置。</target>
        </trans-unit>
        <trans-unit id="44b3d89c096779e08fc6e85e71fb403f5510a848" translate="yes" xml:space="preserve">
          <source>In practice, &lt;code&gt;node&lt;/code&gt; and &lt;code&gt;nextSibling&lt;/code&gt; should be a &lt;a href=&quot;../../../../org/w3c/dom/document&quot;&gt;&lt;code&gt;Document&lt;/code&gt;&lt;/a&gt; node, a &lt;a href=&quot;../../../../org/w3c/dom/documentfragment&quot;&gt;&lt;code&gt;DocumentFragment&lt;/code&gt;&lt;/a&gt; node, or a &lt;a href=&quot;../../../../org/w3c/dom/element&quot;&gt;&lt;code&gt;Element&lt;/code&gt;&lt;/a&gt; node. In other words, a node that accepts children.</source>
          <target state="translated">实际上， &lt;code&gt;node&lt;/code&gt; 和 &lt;code&gt;nextSibling&lt;/code&gt; 应该是&lt;a href=&quot;../../../../org/w3c/dom/document&quot;&gt; &lt;code&gt;Document&lt;/code&gt; &lt;/a&gt;节点，&lt;a href=&quot;../../../../org/w3c/dom/documentfragment&quot;&gt; &lt;code&gt;DocumentFragment&lt;/code&gt; &lt;/a&gt;节点或&lt;a href=&quot;../../../../org/w3c/dom/element&quot;&gt; &lt;code&gt;Element&lt;/code&gt; &lt;/a&gt;节点。换句话说，就是一个接受子节点的节点。</target>
        </trans-unit>
        <trans-unit id="e66b20b0561cf0c6243ea2c6668f24f53e4932e9" translate="yes" xml:space="preserve">
          <source>In practice, the difference between a plain &lt;code&gt;int&lt;/code&gt; and &lt;code&gt;
      Integer&lt;/code&gt;, etc, does not show up because operations in the JMX API are always on Java objects, not primitives. However, the difference &lt;em&gt;does&lt;/em&gt; show up with arrays.</source>
          <target state="translated">在实践中，普通 &lt;code&gt;int&lt;/code&gt; 和 &lt;code&gt; Integer&lt;/code&gt; 等之间的区别不会显示出来，因为JMX API中的操作始终在Java对象上进行，而不是在基元上进行。但是，差异&lt;em&gt;确实&lt;/em&gt;在数组&lt;em&gt;中&lt;/em&gt;显示出来。</target>
        </trans-unit>
        <trans-unit id="796f045d0c1c5aaebd129b5c1ce4d6bab163576c" translate="yes" xml:space="preserve">
          <source>In practice, the difference between a plain &lt;code&gt;int&lt;/code&gt; and &lt;code&gt;Integer&lt;/code&gt;, etc, does not show up because operations in the JMX API are always on Java objects, not primitives. However, the difference &lt;em&gt;does&lt;/em&gt; show up with arrays.</source>
          <target state="translated">在实践中，由于 &lt;code&gt;int&lt;/code&gt; 和 &lt;code&gt;Integer&lt;/code&gt; 等的区别并不存在，因为JMX API中的操作始终在Java对象上，而不是在原语上。但是，差异&lt;em&gt;确实&lt;/em&gt;在数组&lt;em&gt;中&lt;/em&gt;显示出来。</target>
        </trans-unit>
        <trans-unit id="3ec9d5278256fac554e36e5f309da0d6e49663e6" translate="yes" xml:space="preserve">
          <source>In practice, the node should be a &lt;a href=&quot;../../../../org/w3c/dom/document&quot;&gt;&lt;code&gt;Document&lt;/code&gt;&lt;/a&gt; node, a &lt;a href=&quot;../../../../org/w3c/dom/documentfragment&quot;&gt;&lt;code&gt;DocumentFragment&lt;/code&gt;&lt;/a&gt; node, or a &lt;a href=&quot;../../../../org/w3c/dom/element&quot;&gt;&lt;code&gt;Element&lt;/code&gt;&lt;/a&gt; node. In other words, a node that accepts children.</source>
          <target state="translated">实际上，该节点应该是&lt;a href=&quot;../../../../org/w3c/dom/document&quot;&gt; &lt;code&gt;Document&lt;/code&gt; &lt;/a&gt;节点，&lt;a href=&quot;../../../../org/w3c/dom/documentfragment&quot;&gt; &lt;code&gt;DocumentFragment&lt;/code&gt; &lt;/a&gt;节点或&lt;a href=&quot;../../../../org/w3c/dom/element&quot;&gt; &lt;code&gt;Element&lt;/code&gt; &lt;/a&gt;节点。换句话说，就是一个接受子节点的节点。</target>
        </trans-unit>
        <trans-unit id="8ae5216b4c4be405db42d2e5ded9009a76bacd15" translate="yes" xml:space="preserve">
          <source>In rare cases, TCP servers need to act in the SSL client mode on newly accepted connections. For example, FTP clients acquire server sockets and listen there for reverse connections from the server. An FTP client would use an SSLServerSocket in &quot;client&quot; mode to accept the reverse connection while the FTP server uses an SSLSocket with &quot;client&quot; mode disabled to initiate the connection. During the resulting handshake, existing SSL sessions may be reused.</source>
          <target state="translated">在极少数情况下,TCP服务器需要在新接受的连接上以SSL客户端模式行事。例如,FTP客户端获取服务器套接字并在那里监听来自服务器的反向连接。FTP客户端将使用 &quot;客户端 &quot;模式下的SSLServerSocket来接受反向连接,而FTP服务器则使用禁用 &quot;客户端 &quot;模式的SSLSocket来启动连接。在由此产生的握手过程中,现有的SSL会话可能被重复使用。</target>
        </trans-unit>
        <trans-unit id="b810759f912ac005695919570b77b44fdefa6d66" translate="yes" xml:space="preserve">
          <source>In rare cases, the suspend policy may differ from the requested value if a &lt;a href=&quot;classprepareevent&quot;&gt;&lt;code&gt;ClassPrepareEvent&lt;/code&gt;&lt;/a&gt; has occurred in a debugger system thread. See &lt;a href=&quot;classprepareevent#thread()&quot;&gt;&lt;code&gt;ClassPrepareEvent.thread()&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">在极少数情况下，如果在调试器系统线程中发生&lt;a href=&quot;classprepareevent&quot;&gt; &lt;code&gt;ClassPrepareEvent&lt;/code&gt; &lt;/a&gt;，则挂起策略可能与请求的值不同。有关详细信息，请参见&lt;a href=&quot;classprepareevent#thread()&quot;&gt; &lt;code&gt;ClassPrepareEvent.thread()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6d19c55b52426ff64442b2441b6a6e687d2a4a8a" translate="yes" xml:space="preserve">
          <source>In rare cases, this event may occur in a debugger system thread within the target VM. Debugger threads take precautions to prevent these events, but they cannot be avoided under some conditions, especially for some subclasses of &lt;a href=&quot;../../../../../java.base/java/lang/error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt;. If the event was generated by a debugger system thread, the value returned by this method is null, and if the requested suspend policy for the event was &lt;a href=&quot;../request/eventrequest#SUSPEND_EVENT_THREAD&quot;&gt;&lt;code&gt;EventRequest.SUSPEND_EVENT_THREAD&lt;/code&gt;&lt;/a&gt;, all threads will be suspended instead, and the &lt;a href=&quot;eventset#suspendPolicy()&quot;&gt;&lt;code&gt;EventSet.suspendPolicy()&lt;/code&gt;&lt;/a&gt; will reflect this change.</source>
          <target state="translated">在极少数情况下，此事件可能会在目标VM内的调试器系统线程中发生。调试器线程采取了预防措施来防止这些事件，但是在某些情况下尤其是对于&lt;a href=&quot;../../../../../java.base/java/lang/error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; 的&lt;/a&gt;某些子类，它们是无法避免的。如果事件是由调试器系统线程生成的，则此方法返回的值为null，并且如果事件的请求的挂起策略为&lt;a href=&quot;../request/eventrequest#SUSPEND_EVENT_THREAD&quot;&gt; &lt;code&gt;EventRequest.SUSPEND_EVENT_THREAD&lt;/code&gt; &lt;/a&gt;，则所有线程将被挂起，并且&lt;a href=&quot;eventset#suspendPolicy()&quot;&gt; &lt;code&gt;EventSet.suspendPolicy()&lt;/code&gt; &lt;/a&gt;将反映这个变化。</target>
        </trans-unit>
        <trans-unit id="7834b390e944da71c10ffa54e9f786537a580ef7" translate="yes" xml:space="preserve">
          <source>In rare circumstances the virtual machine may</source>
          <target state="translated">在极少数情况下,虚拟机可能</target>
        </trans-unit>
        <trans-unit id="f2bf8cc36315c630d7cdf208f95ef8dbe558b95e" translate="yes" xml:space="preserve">
          <source>In release 1.4, the focus subsystem was rearchitected. For more information, see &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/misc/focus.html&quot;&gt; How to Use the Focus Subsystem&lt;/a&gt;, a section in &lt;em&gt;The Java Tutorial&lt;/em&gt;.</source>
          <target state="translated">在版本1.4中，重新设计了焦点子系统。有关更多信息，请参见&lt;em&gt;《 Java教程》&lt;/em&gt;中的&lt;em&gt;&amp;ldquo;&lt;/em&gt;&lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/misc/focus.html&quot;&gt;如何使用Focus子系统&lt;/a&gt;&lt;em&gt;&amp;rdquo;&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="cb14d8deeca51291d202e185e57cc08298667949" translate="yes" xml:space="preserve">
          <source>In release 1.4, the focus subsystem was rearchitected. For more information, see &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/uiswing/misc/focus.html&quot;&gt; How to Use the Focus Subsystem&lt;/a&gt;, a section in &lt;em&gt;The Java Tutorial&lt;/em&gt;.</source>
          <target state="translated">在版本1.4中，重新设计了焦点子系统。有关更多信息，请参见&lt;em&gt;《 Java教程》&lt;/em&gt;中的&lt;em&gt;&amp;ldquo;&lt;/em&gt;&lt;a href=&quot;https://docs.oracle.com/javase/tutorial/uiswing/misc/focus.html&quot;&gt;如何使用Focus子系统&lt;/a&gt;&lt;em&gt;&amp;rdquo;&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="645e57415a74ea7e4204ec66a0aebe2987a0db9a" translate="yes" xml:space="preserve">
          <source>In search-first mode, the LDAP directory is searched to determine the user's distinguished name and then authentication is attempted. An (anonymous) search is performed using the supplied username in conjunction with a specified search filter. If successful then authentication is attempted using the user's distinguished name and the supplied password. To enable this mode, set the &lt;code&gt;userFilter&lt;/code&gt; option and omit the &lt;code&gt;authIdentity&lt;/code&gt; option. Use search-first mode when the user's distinguished name is not known in advance.</source>
          <target state="translated">在搜索优先模式下，将搜索LDAP目录以确定用户的专有名称，然后尝试进行身份验证。使用提供的用户名和指定的搜索过滤器来执行（匿名）搜索。如果成功，则尝试使用用户的专有名称和提供的密码进行身份验证。要启用此模式，请设置 &lt;code&gt;userFilter&lt;/code&gt; 选项，并省略 &lt;code&gt;authIdentity&lt;/code&gt; 选项。如果事先不知道用户的专有名称，请使用搜索优先模式。</target>
        </trans-unit>
        <trans-unit id="177a25f922fe44253f5e5b34f55196c5dbfa3006" translate="yes" xml:space="preserve">
          <source>In server mode, unless the return &lt;a href=&quot;../../../java/util/list&quot;&gt;&lt;code&gt;List&lt;/code&gt;&lt;/a&gt; is empty, the server should use the requested server names to guide its selection of an appropriate authentication certificate, and/or other aspects of security policy.</source>
          <target state="translated">在服务器模式下，除非返回&lt;a href=&quot;../../../java/util/list&quot;&gt; &lt;code&gt;List&lt;/code&gt; &lt;/a&gt;为空，否则服务器应使用请求的服务器名称来指导其选择适当的身份验证证书和/或安全策略的其他方面。</target>
        </trans-unit>
        <trans-unit id="acaf40d027afc81cab351c04ea9fa2f4414092e5" translate="yes" xml:space="preserve">
          <source>In simple terms, pressing and releasing the mouse over a regular button triggers the button and causes and &lt;code&gt;ActionEvent&lt;/code&gt; to be fired. The same behavior can be produced via a keyboard key defined by the look and feel of the button (typically the SPACE BAR). Pressing and releasing this key while the button has focus will give the same results. For check boxes and radio buttons, the mouse or keyboard equivalent sequence just described causes the button to become selected.</source>
          <target state="translated">简单来说，在常规按钮上按下并释放鼠标会触发该按钮，并触发 &lt;code&gt;ActionEvent&lt;/code&gt; 。通过按钮的外观和感觉（通常是空格键）定义的键盘键可以产生相同的行为。当按钮具有焦点时，按下并释放此键将得到相同的结果。对于复选框和单选按钮，刚刚描述的鼠标或键盘等效顺序使按钮变为选中状态。</target>
        </trans-unit>
        <trans-unit id="7a5c60686b7505cac148f61afec24255ceeab119" translate="yes" xml:space="preserve">
          <source>In some (uncommon) situations, a single SQL statement may return multiple result sets and/or update counts. Normally you can ignore this unless you are (1) executing a stored procedure that you know may return multiple results or (2) you are dynamically executing an unknown SQL string.</source>
          <target state="translated">在某些(不常见的)情况下,一条SQL语句可能会返回多个结果集和/或更新计数。通常情况下,你可以忽略这一点,除非你正在(1)执行一个你知道可能返回多个结果的存储过程,或者(2)你正在动态地执行一个未知的SQL字符串。</target>
        </trans-unit>
        <trans-unit id="27938542553bf1f14e02f219723f076f24891f73" translate="yes" xml:space="preserve">
          <source>In some VMs method entry events can occur for a particular thread before its &lt;a href=&quot;threadstartevent&quot;&gt;&lt;code&gt;ThreadStartEvent&lt;/code&gt;&lt;/a&gt; occurs if methods are called as part of the thread's initialization.</source>
          <target state="translated">在某些VM中，如果将方法作为线程初始化的一部分进行调用，则在该线程的&lt;a href=&quot;threadstartevent&quot;&gt; &lt;code&gt;ThreadStartEvent&lt;/code&gt; &lt;/a&gt;发生之前，方法进入事件可能会发生。</target>
        </trans-unit>
        <trans-unit id="9b3839dadf4c5e906a621c1be0df22a48774d481" translate="yes" xml:space="preserve">
          <source>In some cases use of this permission may affect other applications because manipulation of a mixer affects the audio for all lines using that mixer. This permission can enable an applet or application to eavesdrop on a user.</source>
          <target state="translated">在某些情况下,使用这个权限可能会影响其他应用程序,因为对混音器的操作会影响使用该混音器的所有线路的音频。这个权限可以让小程序或应用程序窃听用户的声音。</target>
        </trans-unit>
        <trans-unit id="a848177f0354f031651d0cc5a0c1339e1883a198" translate="yes" xml:space="preserve">
          <source>In some cases use of this permission may affect other applications because the audio from one line may be mixed with other audio being played on the system, or because manipulation of a mixer affects the audio for all lines using that mixer.</source>
          <target state="translated">在某些情况下,使用这个权限可能会影响其他应用程序,因为一条线路的音频可能会与系统中正在播放的其他音频混合,或者因为对混音器的操作会影响使用该混音器的所有线路的音频。</target>
        </trans-unit>
        <trans-unit id="5afcd4bc923f5719f106155a0a4d4e2a58c6b53a" translate="yes" xml:space="preserve">
          <source>In some cases, a non-blocking read (or skip) may appear to be blocked when it is merely slow, for example when reading large files over slow networks.</source>
          <target state="translated">在某些情况下,当非阻塞读取(或跳过)仅仅是缓慢时,例如在缓慢的网络上读取大文件时,可能会出现阻塞。</target>
        </trans-unit>
        <trans-unit id="e3fa68306b77ec8a7b03a1c5eb53b2702e05a9e8" translate="yes" xml:space="preserve">
          <source>In some cases, access between nested classes is obtained by the Java compiler by creating an wrapper method to access a private method of another class in the same top-level declaration. For example, a nested class &lt;code&gt;C.D&lt;/code&gt; can access private members within other related classes such as &lt;code&gt;C&lt;/code&gt;, &lt;code&gt;C.D.E&lt;/code&gt;, or &lt;code&gt;C.B&lt;/code&gt;, but the Java compiler may need to generate wrapper methods in those related classes. In such cases, a &lt;code&gt;Lookup&lt;/code&gt; object on &lt;code&gt;C.E&lt;/code&gt; would be unable to those private members. A workaround for this limitation is the &lt;a href=&quot;methodhandles.lookup#in-java.lang.Class-&quot;&gt;&lt;code&gt;Lookup.in&lt;/code&gt;&lt;/a&gt; method, which can transform a lookup on &lt;code&gt;C.E&lt;/code&gt; into one on any of those other classes, without special elevation of privilege.</source>
          <target state="translated">在某些情况下，Java编译器通过创建包装器方法来访问嵌套类之间的访问，以在同一顶级声明中访问另一个类的私有方法。例如，嵌套类 &lt;code&gt;C.D&lt;/code&gt; 可以访问其他相关类（例如 &lt;code&gt;C&lt;/code&gt; ， &lt;code&gt;C.D.E&lt;/code&gt; 或 &lt;code&gt;C.B&lt;/code&gt; 内的私有成员，但是Java编译器可能需要在那些相关类中生成包装方法。在这种情况下， &lt;code&gt;C.E&lt;/code&gt; 上的 &lt;code&gt;Lookup&lt;/code&gt; 对象将无法访问那些私有成员。解决此限制的方法是&lt;a href=&quot;methodhandles.lookup#in-java.lang.Class-&quot;&gt; &lt;code&gt;Lookup.in&lt;/code&gt; &lt;/a&gt;方法，该方法可以将 &lt;code&gt;C.E&lt;/code&gt; 上的查找转换为其他任何类上的查找，而无需特殊的特权提升。</target>
        </trans-unit>
        <trans-unit id="d5cbaf96fc9f77ef0b3f4f97b798f3b481096d3a" translate="yes" xml:space="preserve">
          <source>In some cases, adding the amount can cause the resulting date to become invalid. For example, adding one month to 31st January would result in 31st February. In cases like this, the unit is responsible for resolving the date. Typically it will choose the previous valid date, which would be the last valid day of February in this example.</source>
          <target state="translated">在某些情况下,添加金额会导致结果日期无效。例如,在1月31日的基础上增加一个月,结果是2月31日。在这样的情况下,单位负责解决日期问题。通常情况下,它将选择以前的有效日期,在这个例子中,这将是2月的最后一天有效日期。</target>
        </trans-unit>
        <trans-unit id="79dbde154ada935a1511e0a5ad056015e1ce81bb" translate="yes" xml:space="preserve">
          <source>In some cases, changing a field is not fully defined. For example, if the target object is a date representing the 31st January, then adding one month would be unclear. In cases like this, the field is responsible for resolving the result. Typically it will choose the previous valid date, which would be the last valid day of February in this example.</source>
          <target state="translated">在某些情况下,改变一个字段是不完全定义的。例如,如果目标对象是一个代表1月31日的日期,那么增加一个月就不清楚了。在这样的情况下,字段负责解析结果。通常情况下,它会选择之前的有效日期,在这个例子中就是2月的最后一天有效日期。</target>
        </trans-unit>
        <trans-unit id="bd10444116ccb781851e313beb7e47d91bc0acac" translate="yes" xml:space="preserve">
          <source>In some cases, changing a field is not fully defined. For example, if the target object is a date representing the 31st January, then changing the month to February would be unclear. In cases like this, the field is responsible for resolving the result. Typically it will choose the previous valid date, which would be the last valid day of February in this example.</source>
          <target state="translated">在某些情况下,改变一个字段是不完全定义的。例如,如果目标对象是一个代表1月31日的日期,那么将月份改为2月就不清楚了。在这样的情况下,字段负责解析结果。通常情况下,它会选择之前的有效日期,也就是本例中2月的最后一天有效日期。</target>
        </trans-unit>
        <trans-unit id="d624716cd77a5fbae34ea08ee2b7ffe4d4819511" translate="yes" xml:space="preserve">
          <source>In some cases, changing a field is not fully defined. For example, if the target object is a date representing the 31st January, then changing the month to February would be unclear. In cases like this, the implementation is responsible for resolving the result. Typically it will choose the previous valid date, which would be the last valid day of February in this example.</source>
          <target state="translated">在某些情况下,改变一个字段是不完全定义的。例如,如果目标对象是一个代表1月31日的日期,那么将月份改为2月就不清楚了。在这样的情况下,实现要负责解决这个结果。通常情况下,它会选择之前的有效日期,也就是本例中2月的最后一天有效日期。</target>
        </trans-unit>
        <trans-unit id="c3b9cc17b785ff40a460004eb2e4df03a0601252" translate="yes" xml:space="preserve">
          <source>In some cases, changing a field is not fully defined. For example, if the target object is a date representing the 31st March, then subtracting one month would be unclear. In cases like this, the field is responsible for resolving the result. Typically it will choose the previous valid date, which would be the last valid day of February in this example.</source>
          <target state="translated">在某些情况下,改变一个字段是不完全定义的。例如,如果目标对象是一个代表3月31日的日期,那么减去一个月就不清楚了。在这样的情况下,字段负责解析结果。通常情况下,它会选择之前的有效日期,也就是本例中2月的最后一天有效日期。</target>
        </trans-unit>
        <trans-unit id="9633ad6bd00dc94ae7a6b39be76eec4e5fff7990" translate="yes" xml:space="preserve">
          <source>In some cases, changing the specified field can cause the resulting date to become invalid, such as changing the month from 31st January to February would make the day-of-month invalid. In cases like this, the field is responsible for resolving the date. Typically it will choose the previous valid date, which would be the last valid day of February in this example.</source>
          <target state="translated">在某些情况下,更改指定的字段会导致结果的日期无效,例如将月份从1月31日改为2月,会使月份的日期无效。在这样的情况下,该字段负责解析日期。通常情况下,它将选择以前的有效日期,在这个例子中,这将是2月的最后一天有效日期。</target>
        </trans-unit>
        <trans-unit id="463fb2df4e64e20bb07cdf986fe873e31fa41b06" translate="yes" xml:space="preserve">
          <source>In some cases, changing the specified field can cause the resulting date-time to become invalid, such as changing the month from 31st January to February would make the day-of-month invalid. In cases like this, the field is responsible for resolving the date. Typically it will choose the previous valid date, which would be the last valid day of February in this example.</source>
          <target state="translated">在某些情况下,更改指定的字段会导致结果的日期-时间无效,例如将月份从1月31日改为2月,会使月份的日期无效。在这样的情况下,该字段负责解析日期。通常情况下,它将选择以前的有效日期,在这个例子中是2月的最后一天。</target>
        </trans-unit>
        <trans-unit id="76ad22f41ac4d331fd71edfa827b6a2c78d142d0" translate="yes" xml:space="preserve">
          <source>In some cases, initialization parameters other than a keystore and password may be needed by a provider. Users of that particular provider are expected to pass an implementation of the appropriate &lt;code&gt;ManagerFactoryParameters&lt;/code&gt; as defined by the provider. The provider can then call the specified methods in the &lt;code&gt;ManagerFactoryParameters&lt;/code&gt; implementation to obtain the needed information.</source>
          <target state="translated">在某些情况下，提供程序可能需要除密钥库和密码之外的初始化参数。期望该特定提供者的用户传递该提供者定义的相应 &lt;code&gt;ManagerFactoryParameters&lt;/code&gt; 的实现。然后，提供程序可以调用 &lt;code&gt;ManagerFactoryParameters&lt;/code&gt; 实现中的指定方法来获取所需的信息。</target>
        </trans-unit>
        <trans-unit id="3ec5bdcecc9af12d3c9fc36893ac4dcc77cab3ee" translate="yes" xml:space="preserve">
          <source>In some cases, initialization parameters other than a keystore and password may be needed by a provider. Users of that particular provider are expected to pass an implementation of the appropriate &lt;code&gt;ManagerFactoryParameters&lt;/code&gt; as defined by the provider. The provider can then call the specified methods in the ManagerFactoryParameters implementation to obtain the needed information.</source>
          <target state="translated">在某些情况下，提供程序可能需要除密钥库和密码之外的初始化参数。希望该特定提供者的用户通过提供者定义的适当 &lt;code&gt;ManagerFactoryParameters&lt;/code&gt; 的实现。然后，提供程序可以调用ManagerFactoryParameters实现中的指定方法来获取所需的信息。</target>
        </trans-unit>
        <trans-unit id="5ee40fd23ac237d6d567e29c474e7a44c66c598d" translate="yes" xml:space="preserve">
          <source>In some cases, initialization parameters other than a keystore may be needed by a provider. Users of that particular provider are expected to pass an implementation of the appropriate &lt;code&gt;ManagerFactoryParameters&lt;/code&gt; as defined by the provider. The provider can then call the specified methods in the &lt;code&gt;ManagerFactoryParameters&lt;/code&gt; implementation to obtain the needed information.</source>
          <target state="translated">在某些情况下，提供程序可能需要除密钥库以外的初始化参数。期望该特定提供者的用户传递该提供者定义的相应 &lt;code&gt;ManagerFactoryParameters&lt;/code&gt; 的实现。然后，提供程序可以调用 &lt;code&gt;ManagerFactoryParameters&lt;/code&gt; 实现中的指定方法来获取所需的信息。</target>
        </trans-unit>
        <trans-unit id="3943e5fcf21e0c58931ef360cbd3da2eb118dd9f" translate="yes" xml:space="preserve">
          <source>In some cases, initialization parameters other than keystores may be needed by a provider. Users of that particular provider are expected to pass an implementation of the appropriate sub-interface of this class as defined by the provider. The provider can then call the specified methods in the &lt;code&gt;ManagerFactoryParameters&lt;/code&gt; implementation to obtain the needed information.</source>
          <target state="translated">在某些情况下，提供程序可能需要除密钥库以外的初始化参数。该特定提供者的用户应通过提供者定义的此类的适当子接口的实现。然后，提供程序可以调用 &lt;code&gt;ManagerFactoryParameters&lt;/code&gt; 实现中的指定方法来获取所需的信息。</target>
        </trans-unit>
        <trans-unit id="c496c5f7f012a292df8162bd2c83fa12ce7acf10" translate="yes" xml:space="preserve">
          <source>In some cases, it might be useful for multiple threads to process the contents of the same memory segment concurrently (e.g. in the case of parallel processing); while memory segments provide strong confinement guarantees, it is possible to obtain a &lt;a href=&quot;../../../../java.base/java/util/spliterator&quot;&gt;&lt;code&gt;Spliterator&lt;/code&gt;&lt;/a&gt; from a segment, which can be used to slice the segment and allow multiple thread to work in parallel on disjoint segment slices (this assumes that the access mode &lt;a href=&quot;#ACQUIRE&quot;&gt;&lt;code&gt;ACQUIRE&lt;/code&gt;&lt;/a&gt; is set). For instance, the following code can be used to sum all int values in a memory segment in parallel:</source>
          <target state="translated">在某些情况下，多个线程同时处理同一内存段的内容可能很有用（例如，在并行处理的情况下）；尽管内存段提供了强大的限制保证，但可以从段中获取一个&lt;a href=&quot;../../../../java.base/java/util/spliterator&quot;&gt; &lt;code&gt;Spliterator&lt;/code&gt; &lt;/a&gt;，该拆分器可用于对段进行切片并允许多个线程在不相交的段切片上并行工作（这假设已设置访问模式&lt;a href=&quot;#ACQUIRE&quot;&gt; &lt;code&gt;ACQUIRE&lt;/code&gt; &lt;/a&gt;） 。例如，以下代码可用于对内存段中的所有int值进行并行求和：</target>
        </trans-unit>
        <trans-unit id="908a46abad9690abd6da29405c9fa1fb549231ef" translate="yes" xml:space="preserve">
          <source>In some contexts, an attribute set is read-only, which means that the client is only allowed to examine an attribute set's contents but not change them. In other contexts, the attribute set is read-write, which means that the client is allowed both to examine and to change an attribute set's contents. For a read-only attribute set, calling a mutating operation throws an &lt;code&gt;UnmodifiableSetException&lt;/code&gt;.</source>
          <target state="translated">在某些情况下，属性集是只读的，这意味着仅允许客户端检查属性集的内容，而不能更改它们。在其他情况下，属性集是可读写的，这意味着允许客户端检查和更改属性集的内容。对于只读属性集，调用变异操作将引发 &lt;code&gt;UnmodifiableSetException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cac15a18bb25793bfe2d1768e0c7a9131fa203a2" translate="yes" xml:space="preserve">
          <source>In some contexts, the client is only allowed to examine an attribute set's contents but not change them (the set is read-only). In other places, the client is allowed both to examine and to change an attribute set's contents (the set is read-write). For a read-only attribute set, calling a mutating operation throws an &lt;code&gt;UnmodifiableSetException&lt;/code&gt;.</source>
          <target state="translated">在某些情况下，仅允许客户端检查属性集的内容，而不能更改它们（该集是只读的）。在其他地方，允许客户端检查和更改属性集的内容（该集是可读写的）。对于只读属性集，调用变异操作将引发 &lt;code&gt;UnmodifiableSetException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ce412aedb62ca8d47d285d3295efb33f716cb96d" translate="yes" xml:space="preserve">
          <source>In some contexts, the client is only allowed to examine an attribute set's contents but not change them (the set is read-only). In other places, the client is allowed both to examine and to change an attribute set's contents (the set is read-write). For a read-only attribute set, calling a mutating operation throws an UnmodifiableSetException.</source>
          <target state="translated">在某些情况下,客户端只允许检查一个属性集的内容,而不允许更改它们(该集是只读)。在其他地方,客户端既可以检查也可以改变属性集的内容(该集是读写的)。对于一个只读属性集,调用突变操作会抛出一个UnmodifiableSetException。</target>
        </trans-unit>
        <trans-unit id="eb551e97ee529776d55d9be5a6002c26fcb54fe2" translate="yes" xml:space="preserve">
          <source>In some operating systems, this property can be ignored by the underlying controls.</source>
          <target state="translated">在某些操作系统中,这个属性可以被底层控件忽略。</target>
        </trans-unit>
        <trans-unit id="7f6acaf9d833b5998133b034cac67f51895d1578" translate="yes" xml:space="preserve">
          <source>In some variations of the &lt;code&gt;rotate&lt;/code&gt; methods in the &lt;code&gt;AffineTransform&lt;/code&gt; class, a double-precision argument specifies the angle of rotation in radians. These methods have special handling for rotations of approximately 90 degrees (including multiples such as 180, 270, and 360 degrees), so that the common case of quadrant rotation is handled more efficiently. This special handling can cause angles very close to multiples of 90 degrees to be treated as if they were exact multiples of 90 degrees. For small multiples of 90 degrees the range of angles treated as a quadrant rotation is approximately 0.00000121 degrees wide. This section explains why such special care is needed and how it is implemented.</source>
          <target state="translated">在的一些变型中 &lt;code&gt;rotate&lt;/code&gt; 的方法中 &lt;code&gt;AffineTransform&lt;/code&gt; 类，双精度参数指定旋转弧度的角度。这些方法对大约90度的旋转（包括180、270和360度的倍数）进行特殊处理，从而可以更有效地处理象限旋转的常见情况。这种特殊处理可能导致将非常接近90度倍数的角度视为正好是90度倍数。对于90度的较小倍数，被视为象限旋转的角度范围大约为0.00000121度。本节说明了为什么需要这种特殊护理及其实施方式。</target>
        </trans-unit>
        <trans-unit id="885ee299391385d6ba4dabda1e81289629f68f72" translate="yes" xml:space="preserve">
          <source>In source code, a call to a signature polymorphic method will compile, regardless of the requested symbolic type descriptor. As usual, the Java compiler emits an &lt;code&gt;invokevirtual&lt;/code&gt; instruction with the given symbolic type descriptor against the named method. The unusual part is that the symbolic type descriptor is derived from the actual argument and return types, not from the method declaration.</source>
          <target state="translated">在源代码中，无论请求的符号类型描述符如何，都将编译对签名多态方法的调用。像往常一样，Java编译器针对命名方法发出带有给定符号类型描述符的 &lt;code&gt;invokevirtual&lt;/code&gt; 指令。不寻常的部分是符号类型描述符是从实际参数和返回类型派生的，而不是从方法声明派生的。</target>
        </trans-unit>
        <trans-unit id="1b915bf0ccf792776f6e76bfd8e1c08e30939ddb" translate="yes" xml:space="preserve">
          <source>In strict parsing mode, the minimum number of parsed digits is &lt;code&gt;minWidth&lt;/code&gt; and the maximum is &lt;code&gt;maxWidth&lt;/code&gt;. In lenient parsing mode, the minimum number of parsed digits is one and the maximum is 19 (except as limited by adjacent value parsing).</source>
          <target state="translated">在严格解析模式下，解析数字的最小数量为 &lt;code&gt;minWidth&lt;/code&gt; ，最大为 &lt;code&gt;maxWidth&lt;/code&gt; 。在宽解析模式下，解析的位数最少为1，最大为19（除非受相邻值解析的限制）。</target>
        </trans-unit>
        <trans-unit id="e32a1c5a51d2f15051e0db94aa6b8b5a7875526d" translate="yes" xml:space="preserve">
          <source>In strict parsing, any sign will be rejected. In lenient parsing, any sign will be accepted unless the width is fixed.</source>
          <target state="translated">在严格的解析中,任何符号都将被拒绝。在宽松的解析中,任何符号都会被接受,除非宽度是固定的。</target>
        </trans-unit>
        <trans-unit id="b74dc38e8b9a0ecab2c681d95be38243e38c6415" translate="yes" xml:space="preserve">
          <source>In strict parsing, the absence of a sign will be rejected. In lenient parsing, any sign will be accepted, with the absence of a sign treated as a positive number.</source>
          <target state="translated">在严格的解析中,没有符号将被拒绝。在宽松的解析中,任何符号都将被接受,而没有符号则被视为正数。</target>
        </trans-unit>
        <trans-unit id="5c8071a6cb7a80c6d715aae673f0d54a56ce4046" translate="yes" xml:space="preserve">
          <source>In strict parsing, the negative sign will be accepted and the positive sign rejected. In lenient parsing, any sign will be accepted.</source>
          <target state="translated">在严格的解析中,负号将被接受,正号将被拒绝。在宽松的解析中,将接受任何符号。</target>
        </trans-unit>
        <trans-unit id="67fe828640d1605e5d14133978083d2888d9dcd4" translate="yes" xml:space="preserve">
          <source>In strict parsing, the sign will be rejected unless the pad width is exceeded. In lenient parsing, any sign will be accepted, with the absence of a sign treated as a positive number.</source>
          <target state="translated">在严格的解析中,符号将被拒绝,除非超过垫宽。在宽松的解析中,任何符号都会被接受,没有符号的符号将被视为正数。</target>
        </trans-unit>
        <trans-unit id="32f38d097aca41b5fd2eca03a22d2ba7f888ee6d" translate="yes" xml:space="preserve">
          <source>In styled text, the baselines for each such run are aligned one after the other to potentially create a non-linear baseline for the entire run of text. For more information, see &lt;a href=&quot;textlayout#getLayoutPath()&quot;&gt;&lt;code&gt;TextLayout.getLayoutPath()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在样式化的文本中，每个这样的运行的基线彼此对齐，从而有可能为整个文本运行创建非线性基线。有关更多信息，请参见&lt;a href=&quot;textlayout#getLayoutPath()&quot;&gt; &lt;code&gt;TextLayout.getLayoutPath()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="14e6d10be963a858682493890b1c1e45150c4841" translate="yes" xml:space="preserve">
          <source>In such an environment, when calling &lt;code&gt;setLocation&lt;/code&gt;, you must pass a virtual coordinate to this method. Similarly, calling &lt;code&gt;getLocationOnScreen&lt;/code&gt; on a &lt;code&gt;Frame&lt;/code&gt; returns virtual device coordinates. Call the &lt;code&gt;getBounds&lt;/code&gt; method of a &lt;code&gt;GraphicsConfiguration&lt;/code&gt; to find its origin in the virtual coordinate system.</source>
          <target state="translated">在这种环境中，调用 &lt;code&gt;setLocation&lt;/code&gt; 时，必须将虚拟坐标传递给此方法。同样，在 &lt;code&gt;Frame&lt;/code&gt; 上调用 &lt;code&gt;getLocationOnScreen&lt;/code&gt; 会返回虚拟设备坐标。调用 &lt;code&gt;GraphicsConfiguration&lt;/code&gt; 的 &lt;code&gt;getBounds&lt;/code&gt; 方法以在虚拟坐标系中找到其原点。</target>
        </trans-unit>
        <trans-unit id="430fe4c1fa3678008389acec40576ab47a3e8f92" translate="yes" xml:space="preserve">
          <source>In such an environment, when calling &lt;code&gt;setLocation&lt;/code&gt;, you must pass a virtual coordinate to this method. Similarly, calling &lt;code&gt;getLocationOnScreen&lt;/code&gt; on a &lt;code&gt;Window&lt;/code&gt; returns virtual device coordinates. Call the &lt;code&gt;getBounds&lt;/code&gt; method of a &lt;code&gt;GraphicsConfiguration&lt;/code&gt; to find its origin in the virtual coordinate system.</source>
          <target state="translated">在这种环境中，调用 &lt;code&gt;setLocation&lt;/code&gt; 时，必须将虚拟坐标传递给此方法。同样，在 &lt;code&gt;Window&lt;/code&gt; 上调用 &lt;code&gt;getLocationOnScreen&lt;/code&gt; 会返回虚拟设备坐标。调用 &lt;code&gt;GraphicsConfiguration&lt;/code&gt; 的 &lt;code&gt;getBounds&lt;/code&gt; 方法以在虚拟坐标系中找到其原点。</target>
        </trans-unit>
        <trans-unit id="214ba9516aa4a0067c4a338c78f5324a4ab75fa7" translate="yes" xml:space="preserve">
          <source>In such cases an exception will be thrown. The exact nature of the exception is system-dependent, but it will always be a subclass of &lt;a href=&quot;../io/ioexception&quot;&gt;&lt;code&gt;IOException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在这种情况下，将引发异常。异常的确切性质与系统有关，但是它将始终是&lt;a href=&quot;../io/ioexception&quot;&gt; &lt;code&gt;IOException&lt;/code&gt; &lt;/a&gt;的子类。</target>
        </trans-unit>
        <trans-unit id="7c326a999ddfe2daddd2659ccac12ca5a92c10aa" translate="yes" xml:space="preserve">
          <source>In such situations it is desirable that the GUI control detect this and institute a scroll operation in order to make obscured region(s) visible to the user. This feature is known as autoscrolling.</source>
          <target state="translated">在这种情况下,GUI 控件最好能检测到这一点,并进行滚动操作,以使被遮挡的区域对用户可见。这个功能被称为自动滚动。</target>
        </trans-unit>
        <trans-unit id="882463d8c19c07511a6474e0e79380cb4537f977" translate="yes" xml:space="preserve">
          <source>In summary, a &lt;code&gt;CachedRowSet&lt;/code&gt; object can be thought of as simply a disconnected set of rows that are being cached outside of a data source. Being thin and serializable, it can easily be sent across a wire, and it is well suited to sending data to a thin client. However, a &lt;code&gt;CachedRowSet&lt;/code&gt; object does have a limitation: It is limited in size by the amount of data it can store in memory at one time.</source>
          <target state="translated">总而言之，可以将 &lt;code&gt;CachedRowSet&lt;/code&gt; 对象简单地视为一组断开连接的行，这些行在数据源外部进行缓存。它是瘦的且可序列化的，因此可以很容易地通过电线发送，非常适合将数据发送到瘦客户机。但是， &lt;code&gt;CachedRowSet&lt;/code&gt; 对象确实有一个局限性：它的大小受到它一次可以存储在内存中的数据量的限制。</target>
        </trans-unit>
        <trans-unit id="8067decfb6c0c5c43694b67ad35b84389b8af373" translate="yes" xml:space="preserve">
          <source>In summary, implementations must behave in a manner equivalent to this pseudo-code:</source>
          <target state="translated">总而言之,实现必须以与此伪代码相当的方式进行。</target>
        </trans-unit>
        <trans-unit id="2a7a4f8124d00a71da6f2135edc013ec316ce00a" translate="yes" xml:space="preserve">
          <source>In summary, instances of this class act as namespaces for static members and as constructors for classes, much the same way as specifying a class name in Java language does, except that in Java this is just a syntactic element, while in Dynalink they are expressed as actual objects.</source>
          <target state="translated">总而言之,这个类的实例作为静态成员的命名空间和类的构造函数,就像在Java语言中指定类名一样,只是在Java中这只是一个语法元素,而在Dynalink中,它们是作为实际的对象来表达的。</target>
        </trans-unit>
        <trans-unit id="cdf106eacebc34e81f8addeba1ccd69fb18807c7" translate="yes" xml:space="preserve">
          <source>In summary, this method makes no absolute guarantee, nor can it even make a guarantee to be correct within some margin of error. So it should be used at most only for estimating the total space sufficient to display some number of as yet unknown characters from the font. And that might be either an overestimate, or an underestimate depending on the specific text and rendering conext.</source>
          <target state="translated">总之,这种方法不能绝对保证,甚至不能保证在一定误差范围内正确。所以,它最多只能用于估计足以显示一些未知字符的字体的总空间。而这可能是一个高估,也可能是一个低估,这取决于具体的文本和渲染conext。</target>
        </trans-unit>
        <trans-unit id="ed941580cb00e2437d3c9ed1b978822bc3ddf2fb" translate="yes" xml:space="preserve">
          <source>In terms of design, this class should be viewed primarily as the combination of a &lt;code&gt;LocalDateTime&lt;/code&gt; and a &lt;code&gt;ZoneId&lt;/code&gt;. The &lt;code&gt;ZoneOffset&lt;/code&gt; is a vital, but secondary, piece of information, used to ensure that the class represents an instant, especially during a daylight savings overlap.</source>
          <target state="translated">就设计而言，此类应主要视为 &lt;code&gt;LocalDateTime&lt;/code&gt; 和 &lt;code&gt;ZoneId&lt;/code&gt; 的组合。所述 &lt;code&gt;ZoneOffset&lt;/code&gt; 是至关重要的，但次要的，一条信息，用于确保所述类表示瞬间，特别是在夏令重叠。</target>
        </trans-unit>
        <trans-unit id="76eb19d7c964e4c05ae134c3d7adb2c9eb092b77" translate="yes" xml:space="preserve">
          <source>In terms of the Java Memory Model, this operation performs a synchronization action which is comparable in effect to the writing of a volatile variable by the current thread, and an eventual volatile read by every other thread that may access one of the affected call sites.</source>
          <target state="translated">就Java内存模型而言,这个操作执行了一个同步操作,其效果相当于当前线程写入一个易失性变量,以及可能访问受影响的调用站点之一的每一个其他线程最终读取一个易失性变量。</target>
        </trans-unit>
        <trans-unit id="835cfd0b944daf64dbddb89f8c199c78f037cfd7" translate="yes" xml:space="preserve">
          <source>In that case it is up to the user to call it to maintain the consistency of the relations. To be kept in mind that if an MBean is unregistered and the purge not done immediately, if the ObjectName is reused and assigned to another MBean referenced in a relation, calling manually this purgeRelations() method will cause trouble, as will consider the ObjectName as corresponding to the unregistered MBean, not seeing the new one.</source>
          <target state="translated">在这种情况下,由用户来调用它来维持关系的一致性。需要注意的是,如果一个MBean未注册,没有立即进行清除,如果ObjectName被重用并分配给关系中引用的另一个MBean,手动调用这个purgeRelations()方法会造成麻烦,因为会认为ObjectName对应的是未注册的MBean,而不是看到新的MBean。</target>
        </trans-unit>
        <trans-unit id="bef1807ddf0304b74d57e74ae70d10d603d4b799" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;../nio/channels/package-summary&quot;&gt;&lt;code&gt;channels&lt;/code&gt;&lt;/a&gt; package, the &lt;a href=&quot;../nio/channels/networkchannel&quot;&gt;&lt;code&gt;NetworkChannel&lt;/code&gt;&lt;/a&gt; interface defines the &lt;a href=&quot;../nio/channels/networkchannel#setOption(java.net.SocketOption,T)&quot;&gt;&lt;code&gt;setOption&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../nio/channels/networkchannel#getOption(java.net.SocketOption)&quot;&gt;&lt;code&gt;getOption&lt;/code&gt;&lt;/a&gt; methods to set and query the channel's socket options.</source>
          <target state="translated">在&lt;a href=&quot;../nio/channels/package-summary&quot;&gt; &lt;code&gt;channels&lt;/code&gt; &lt;/a&gt;包中，&lt;a href=&quot;../nio/channels/networkchannel&quot;&gt; &lt;code&gt;NetworkChannel&lt;/code&gt; &lt;/a&gt;接口定义了&lt;a href=&quot;../nio/channels/networkchannel#setOption(java.net.SocketOption,T)&quot;&gt; &lt;code&gt;setOption&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../nio/channels/networkchannel#getOption(java.net.SocketOption)&quot;&gt; &lt;code&gt;getOption&lt;/code&gt; &lt;/a&gt;方法以设置和查询通道的套接字选项。</target>
        </trans-unit>
        <trans-unit id="8ebc8aa5c940b2b5ec99046211ecd0bca8ea5a52" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;../nio/channels/package-summary&quot;&gt;&lt;code&gt;channels&lt;/code&gt;&lt;/a&gt; package, the &lt;a href=&quot;../nio/channels/networkchannel&quot;&gt;&lt;code&gt;NetworkChannel&lt;/code&gt;&lt;/a&gt; interface defines the &lt;a href=&quot;../nio/channels/networkchannel#setOption-java.net.SocketOption-T-&quot;&gt;&lt;code&gt;setOption&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../nio/channels/networkchannel#getOption-java.net.SocketOption-&quot;&gt;&lt;code&gt;getOption&lt;/code&gt;&lt;/a&gt; methods to set and query the channel's socket options.</source>
          <target state="translated">在&lt;a href=&quot;../nio/channels/package-summary&quot;&gt; &lt;code&gt;channels&lt;/code&gt; &lt;/a&gt;包中，&lt;a href=&quot;../nio/channels/networkchannel&quot;&gt; &lt;code&gt;NetworkChannel&lt;/code&gt; &lt;/a&gt;接口定义了&lt;a href=&quot;../nio/channels/networkchannel#setOption-java.net.SocketOption-T-&quot;&gt; &lt;code&gt;setOption&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../nio/channels/networkchannel#getOption-java.net.SocketOption-&quot;&gt; &lt;code&gt;getOption&lt;/code&gt; &lt;/a&gt;方法以设置和查询通道的套接字选项。</target>
        </trans-unit>
        <trans-unit id="f99321475eab479310036c2b9a6f3cd03c044420" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;../util/locale#US&quot;&gt;&lt;code&gt;US locale&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;1000&lt;/code&gt; can be formatted as &lt;code&gt;&quot;1K&quot;&lt;/code&gt;, and &lt;code&gt;1000000&lt;/code&gt; as &lt;code&gt;&quot;1M&quot;&lt;/code&gt;, depending upon the &lt;a href=&quot;#compact_number_style&quot;&gt;style&lt;/a&gt; used.</source>
          <target state="translated">在&lt;a href=&quot;../util/locale#US&quot;&gt; &lt;code&gt;US locale&lt;/code&gt; &lt;/a&gt;，根据所使用的&lt;a href=&quot;#compact_number_style&quot;&gt;样式&lt;/a&gt;，可以将 &lt;code&gt;1000&lt;/code&gt; 格式化为 &lt;code&gt;&quot;1K&quot;&lt;/code&gt; ，将 &lt;code&gt;1000000&lt;/code&gt; 格式化为 &lt;code&gt;&quot;1M&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a54fca9920ed5db589a408716c8ca00ff8fbb833" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;&quot;hi_IN&quot;&lt;/code&gt; locale, &lt;code&gt;1000&lt;/code&gt; can be formatted as &quot;1 &amp;agrave;&amp;curren;&amp;sup1;&amp;agrave;&amp;curren;&amp;agrave;&amp;curren;&amp;frac14;&amp;agrave;&amp;curren;&amp;frac34;&amp;agrave;&amp;curren;&amp;deg;&quot;, and &lt;code&gt;50000000&lt;/code&gt; as &quot;5 &amp;agrave;&amp;curren;.&quot;, depending upon the &lt;a href=&quot;#compact_number_style&quot;&gt;style&lt;/a&gt; used.</source>
          <target state="translated">在 &lt;code&gt;&quot;hi_IN&quot;&lt;/code&gt; 语言环境中，根据所使用的&lt;a href=&quot;#compact_number_style&quot;&gt;样式&lt;/a&gt;，可以将 &lt;code&gt;1000&lt;/code&gt; 格式化为&amp;ldquo; 1&amp;agrave;&amp;curren;?????&amp;agrave;&amp;curren;&amp;frac14;&amp;agrave;&amp;curren;&amp;frac34;&amp;frac34;&amp;curren;&amp;deg;&amp;rdquo;，将 &lt;code&gt;50000000&lt;/code&gt; 格式化为&amp;ldquo; 5&amp;agrave;?????&amp;rdquo; 。</target>
        </trans-unit>
        <trans-unit id="b62cb44c2b6302f47dd64bfc710a64f101a0b462" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;getAttributes()&lt;/code&gt; and &lt;code&gt;search()&lt;/code&gt; methods, you can specify that all attributes associated with the requested objects be returned by supply &lt;code&gt;null&lt;/code&gt; as the list of attributes to return. The attributes returned do &lt;em&gt;not&lt;/em&gt; include operational attributes. In order to retrieve operational attributes, you must name them explicitly.</source>
          <target state="translated">在 &lt;code&gt;getAttributes()&lt;/code&gt; 和 &lt;code&gt;search()&lt;/code&gt; 方法中，您可以指定由提供的 &lt;code&gt;null&lt;/code&gt; 作为要返回的属性列表返回与请求的对象关联的所有属性。返回的属性&lt;em&gt;不&lt;/em&gt;包括操作属性。为了检索操作属性，必须显式命名它们。</target>
        </trans-unit>
        <trans-unit id="65574745feadc55e1e05a1c122606bd23b2ae9c4" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;getAttributes()&lt;/code&gt; and &lt;code&gt;search()&lt;/code&gt; methods, you can supply the attributes to return by supplying a list of attribute names (strings). The attributes that you get back might not have the same names as the attribute names you have specified. This is because some directories support features that cause them to return other attributes. Such features include attribute subclassing, attribute name synonyms, and attribute language codes.</source>
          <target state="translated">在 &lt;code&gt;getAttributes()&lt;/code&gt; 和 &lt;code&gt;search()&lt;/code&gt; 方法中，可以通过提供属性名称（字符串）列表来提供要返回的属性。您获得的属性名称可能与您指定的属性名称不同。这是因为某些目录支持使它们返回其他属性的功能。这些功能包括属性子类，属性名称同义词和属性语言代码。</target>
        </trans-unit>
        <trans-unit id="87d152e8e73df7131decd25ad1ce40aac0f21673" translate="yes" xml:space="preserve">
          <source>In the &lt;em&gt;JNDI form&lt;/em&gt;, the URL indicates &lt;em&gt;where to find an RMI stub for the connector&lt;/em&gt;. This RMI stub is a Java object of type &lt;a href=&quot;rmiserver&quot;&gt;&lt;code&gt;RMIServer&lt;/code&gt;&lt;/a&gt; that gives remote access to the connector server. With this address form, the RMI stub is obtained from an external directory entry included in the URL. An external directory is any directory recognized by &lt;a href=&quot;../../../../../java.naming/javax/naming/package-summary&quot;&gt;&lt;code&gt;JNDI&lt;/code&gt;&lt;/a&gt;, typically the RMI registry, LDAP, or COS Naming.</source>
          <target state="translated">在&lt;em&gt;JNDI表单中&lt;/em&gt;，URL指示&lt;em&gt;在何处找到连接器的RMI存根&lt;/em&gt;。此RMI存根是&lt;a href=&quot;rmiserver&quot;&gt; &lt;code&gt;RMIServer&lt;/code&gt; &lt;/a&gt;类型的Java对象，该对象提供对连接器服务器的远程访问。使用此地址格式，可以从URL中包含的外部目录条目中获取RMI存根。外部目录是&lt;a href=&quot;../../../../../java.naming/javax/naming/package-summary&quot;&gt; &lt;code&gt;JNDI&lt;/code&gt; &lt;/a&gt;识别的任何目录，通常是RMI注册表，LDAP或COS命名。</target>
        </trans-unit>
        <trans-unit id="bbbf3a71704058ced1b5b8411ec253780bd68226" translate="yes" xml:space="preserve">
          <source>In the &lt;em&gt;JNDI form&lt;/em&gt;, the URL indicates &lt;em&gt;where to find an RMI stub for the connector&lt;/em&gt;. This RMI stub is a Java object of type &lt;a href=&quot;rmiserver&quot;&gt;&lt;code&gt;RMIServer&lt;/code&gt;&lt;/a&gt; that gives remote access to the connector server. With this address form, the RMI stub is obtained from an external directory entry included in the URL. An external directory is any directory recognized by &lt;a href=&quot;../../../naming/package-summary&quot;&gt;&lt;code&gt;JNDI&lt;/code&gt;&lt;/a&gt;, typically the RMI registry, LDAP, or COS Naming.</source>
          <target state="translated">在&lt;em&gt;JNDI表单中&lt;/em&gt;，URL指示&lt;em&gt;在哪里可以找到连接器的RMI存根&lt;/em&gt;。此RMI存根是&lt;a href=&quot;rmiserver&quot;&gt; &lt;code&gt;RMIServer&lt;/code&gt; &lt;/a&gt;类型的Java对象，该对象提供对连接器服务器的远程访问。使用此地址格式，可以从URL中包含的外部目录条目中获取RMI存根。外部目录是&lt;a href=&quot;../../../naming/package-summary&quot;&gt; &lt;code&gt;JNDI&lt;/code&gt; &lt;/a&gt;识别的任何目录，通常是RMI注册表，LDAP或COS命名。</target>
        </trans-unit>
        <trans-unit id="fd216e1fa9eb5f8e146da12b5c1bfee5cf25ef08" translate="yes" xml:space="preserve">
          <source>In the &lt;em&gt;encoded form&lt;/em&gt;, the URL directly includes the information needed to connect to the connector server. When using RMI/JRMP, the encoded form is the serialized RMI stub for the server object, encoded using BASE64 without embedded newlines.</source>
          <target state="translated">URL以&lt;em&gt;编码形式&lt;/em&gt;直接包含连接到连接器服务器所需的信息。使用RMI / JRMP时，编码形式是服务器对象的序列化RMI存根，使用BASE64编码而没有嵌入换行符。</target>
        </trans-unit>
        <trans-unit id="da195228b955a3ad9cf4e29226a227ba11eca748" translate="yes" xml:space="preserve">
          <source>In the &lt;em&gt;encoded form&lt;/em&gt;, the URL directly includes the information needed to connect to the connector server. When using RMI/JRMP, the encoded form is the serialized RMI stub for the server object, encoded using BASE64 without embedded newlines. When using RMI/IIOP, the encoded form is the CORBA IOR for the server object.</source>
          <target state="translated">URL 以&lt;em&gt;编码形式&lt;/em&gt;直接包含连接到连接器服务器所需的信息。使用RMI / JRMP时，编码形式是服务器对象的序列化RMI存根，使用BASE64编码而没有嵌入式换行符。使用RMI / IIOP时，编码形式是服务器对象的CORBA IOR。</target>
        </trans-unit>
        <trans-unit id="86f6b7e5dc81391222de88d79367433c554f6d3d" translate="yes" xml:space="preserve">
          <source>In the JDBC 2.0 API, the behavior of the method &lt;code&gt;getObject&lt;/code&gt; is extended to materialize data of SQL user-defined types. When a column contains a structured or distinct value, the behavior of this method is as if it were a call to: &lt;code&gt;getObject(columnIndex,
 this.getStatement().getConnection().getTypeMap())&lt;/code&gt;.</source>
          <target state="translated">在JDBC 2.0 API中，扩展了 &lt;code&gt;getObject&lt;/code&gt; 方法的行为，以实现SQL用户定义类型的数据。当列包含结构化值或不同值时，此方法的行为就像是对以下对象的调用： &lt;code&gt;getObject(columnIndex, this.getStatement().getConnection().getTypeMap())&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="59950f40b5787cdd0a4b696de35fcc5a0acc6f9e" translate="yes" xml:space="preserve">
          <source>In the JDK Reference Implementation, interruption of a thread that is not alive still records that the interrupt request was made and will report it via &lt;code&gt;interrupted&lt;/code&gt; and &lt;a href=&quot;#isInterrupted()&quot;&gt;&lt;code&gt;isInterrupted()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在《 JDK参考实现》中，未存活的线程的中断仍会记录该中断请求，并将通过 &lt;code&gt;interrupted&lt;/code&gt; 和&lt;a href=&quot;#isInterrupted()&quot;&gt; &lt;code&gt;isInterrupted()&lt;/code&gt; &lt;/a&gt;报告它。</target>
        </trans-unit>
        <trans-unit id="e0b25ce08b6f47b4e151f392dccbd4429bbddff1" translate="yes" xml:space="preserve">
          <source>In the JDK implementation, if the Java virtual machine is started with the system property &lt;code&gt;java.security.manager&lt;/code&gt; set to the special token &quot;&lt;code&gt;disallow&lt;/code&gt;&quot; then the &lt;code&gt;setSecurityManager&lt;/code&gt; method cannot be used to set a security manager.</source>
          <target state="translated">在JDK实现中，如果以系统属性 &lt;code&gt;java.security.manager&lt;/code&gt; 设置为特殊标记&amp;ldquo; &lt;code&gt;disallow&lt;/code&gt; &amp;rdquo;启动Java虚拟机，则不能使用 &lt;code&gt;setSecurityManager&lt;/code&gt; 方法来设置安全管理器。</target>
        </trans-unit>
        <trans-unit id="5e6e492afa18abccbc15a09e9c9801f7982bd748" translate="yes" xml:space="preserve">
          <source>In the Java 1.0 event model, an event contains an &lt;a href=&quot;#id&quot;&gt;&lt;code&gt;id&lt;/code&gt;&lt;/a&gt; field that indicates what type of event it is and which other &lt;code&gt;Event&lt;/code&gt; variables are relevant for the event.</source>
          <target state="translated">在Java 1.0事件模型中，事件包含一个&lt;a href=&quot;#id&quot;&gt; &lt;code&gt;id&lt;/code&gt; &lt;/a&gt;字段，该ID字段指示事件是什么类型以及哪些其他 &lt;code&gt;Event&lt;/code&gt; 变量与该事件相关。</target>
        </trans-unit>
        <trans-unit id="a77ab9d4544f54d35b2613f822310c541fff6180" translate="yes" xml:space="preserve">
          <source>In the Java Print Service API, an attribute category is represented by a Java class implementing the &lt;a href=&quot;attribute&quot;&gt;Attribute&lt;/a&gt; interface. Attribute values are instances of such a class or one of its subclasses. For example, to specify the number of copies, an application constructs an instance of the &lt;a href=&quot;standard/copies&quot;&gt;Copies&lt;/a&gt; class with the number of desired copies and uses the &lt;code&gt;Copies&lt;/code&gt; instance as part of the print request. In this case, the &lt;code&gt;Copies&lt;/code&gt; class represents the attribute category, and the &lt;code&gt;Copies&lt;/code&gt; instance represents the attribute value.</source>
          <target state="translated">在Java Print Service API中，属性类别由实现&lt;a href=&quot;attribute&quot;&gt;Attribute&lt;/a&gt;接口的Java类表示。属性值是该类或其子类之一的实例。例如，要指定份数，应用程序将使用所需份数构造&lt;a href=&quot;standard/copies&quot;&gt;Copies&lt;/a&gt;类的实例，并将 &lt;code&gt;Copies&lt;/code&gt; 实例用作打印请求的一部分。在这种情况下， &lt;code&gt;Copies&lt;/code&gt; 类表示属性类别，而 &lt;code&gt;Copies&lt;/code&gt; 实例表示属性值。</target>
        </trans-unit>
        <trans-unit id="67a8902a6ba14e2b0903baaddb1578c58648db1e" translate="yes" xml:space="preserve">
          <source>In the Java SE API documentation, &lt;em&gt;Unicode code point&lt;/em&gt; is used for character values in the range between U+0000 and U+10FFFF, and &lt;em&gt;Unicode code unit&lt;/em&gt; is used for 16-bit &lt;code&gt;char&lt;/code&gt; values that are code units of the &lt;em&gt;UTF-16&lt;/em&gt; encoding. For more information on Unicode terminology, refer to the &lt;a href=&quot;http://www.unicode.org/glossary/&quot;&gt;Unicode Glossary&lt;/a&gt;.</source>
          <target state="translated">在Java SE API文档中，&lt;em&gt;Unicode代码点&lt;/em&gt;用于U + 0000到U + 10FFFF之间的字符值，而&lt;em&gt;Unicode代码单元&lt;/em&gt;用于16位 &lt;code&gt;char&lt;/code&gt; 值，它们是&lt;em&gt;UTF-16&lt;/em&gt;编码的代码单元。有关Unicode术语的更多信息，请参考&lt;a href=&quot;http://www.unicode.org/glossary/&quot;&gt;Unicode术语表&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="53237f05e240f55ed0ab5bb5d6d12f4a7558387d" translate="yes" xml:space="preserve">
          <source>In the Java SE API documentation, &lt;em&gt;Unicode code point&lt;/em&gt; is used for character values in the range between U+0000 and U+10FFFF, and &lt;em&gt;Unicode code unit&lt;/em&gt; is used for 16-bit &lt;code&gt;char&lt;/code&gt; values that are code units of the &lt;em&gt;UTF-16&lt;/em&gt; encoding. For more information on Unicode terminology, refer to the &lt;a href=&quot;https://www.unicode.org/glossary/&quot;&gt;Unicode Glossary&lt;/a&gt;.</source>
          <target state="translated">在Java SE API文档中，&lt;em&gt;Unicode代码点&lt;/em&gt;用于U + 0000到U + 10FFFF之间的字符值，而&lt;em&gt;Unicode代码单元&lt;/em&gt;用于16位 &lt;code&gt;char&lt;/code&gt; 值，它们是&lt;em&gt;UTF-16&lt;/em&gt;编码的代码单元。有关Unicode术语的更多信息，请参考&lt;a href=&quot;https://www.unicode.org/glossary/&quot;&gt;Unicode术语表&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5bc8709b34a011f36b043d3971d48950764a1f4c" translate="yes" xml:space="preserve">
          <source>In the Swing component set, borders supercede Insets as the mechanism for creating a (decorated or plain) area around the edge of a component.</source>
          <target state="translated">在Swing组件集中,边框取代了Insets,作为在组件边缘创建一个(装饰或平原)区域的机制。</target>
        </trans-unit>
        <trans-unit id="32ca1e6fb51aad1d95bdee75e64df5cc2c5ef0f3" translate="yes" xml:space="preserve">
          <source>In the Swing text API's document model, the interface Element defines a structural piece of a Document, like a paragraph, a line of text, or a list item in an HTML document.</source>
          <target state="translated">在Swing文本API的文档模型中,接口元素定义了一个Document的结构件,就像HTML文档中的一个段落、一行文本或一个列表项。</target>
        </trans-unit>
        <trans-unit id="890cc57ecf9bbe3ff59180e50104a57930b04712" translate="yes" xml:space="preserve">
          <source>In the above cases, the type of the expected results are known. In case where the result type is unknown or any type, the &lt;a href=&quot;xpathevaluationresult&quot;&gt;&lt;code&gt;XPathEvaluationResult&lt;/code&gt;&lt;/a&gt; may be used to determine the return type. The following code demonstrates the usage:</source>
          <target state="translated">在上述情况下，预期结果的类型是已知的。如果结果类型是未知的或任何类型，则可以使用&lt;a href=&quot;xpathevaluationresult&quot;&gt; &lt;code&gt;XPathEvaluationResult&lt;/code&gt; &lt;/a&gt;确定返回类型。以下代码演示了用法：</target>
        </trans-unit>
        <trans-unit id="bcedd509439bbad0ee5b96154cd316b25dd19892" translate="yes" xml:space="preserve">
          <source>In the above example, if &lt;code&gt;C&lt;/code&gt; and &lt;code&gt;D&lt;/code&gt; are in different modules, &lt;code&gt;lookup2&lt;/code&gt; records &lt;code&gt;D&lt;/code&gt; as its lookup class and &lt;code&gt;C&lt;/code&gt; as its previous lookup class and &lt;code&gt;lookup2&lt;/code&gt; has only &lt;code&gt;PUBLIC&lt;/code&gt; access. &lt;code&gt;lookup2&lt;/code&gt; can teleport to other class in &lt;code&gt;C&lt;/code&gt;'s module and &lt;code&gt;D&lt;/code&gt;'s module. If class &lt;code&gt;E&lt;/code&gt; is in a third module, &lt;code&gt;lookup2.in(E.class)&lt;/code&gt; creates a &lt;code&gt;Lookup&lt;/code&gt; on &lt;code&gt;E&lt;/code&gt; with no access and &lt;code&gt;lookup2&lt;/code&gt;'s lookup class &lt;code&gt;D&lt;/code&gt; is recorded as its previous lookup class.</source>
          <target state="translated">在上面的示例中，如果 &lt;code&gt;C&lt;/code&gt; 和 &lt;code&gt;D&lt;/code&gt; 在不同的模块中，则 &lt;code&gt;lookup2&lt;/code&gt; 将 &lt;code&gt;D&lt;/code&gt; 记录为其查找类，并将 &lt;code&gt;C&lt;/code&gt; 记录为其先前的查找类，并且 &lt;code&gt;lookup2&lt;/code&gt; 仅具有 &lt;code&gt;PUBLIC&lt;/code&gt; 访问权限。 &lt;code&gt;lookup2&lt;/code&gt; 可以传送到 &lt;code&gt;C&lt;/code&gt; 的模块和 &lt;code&gt;D&lt;/code&gt; 的模块中的其他类。如果类 &lt;code&gt;E&lt;/code&gt; 在第三个模块中，则 &lt;code&gt;lookup2.in(E.class)&lt;/code&gt; 在 &lt;code&gt;E&lt;/code&gt; 上创建一个没有访问权的 &lt;code&gt;Lookup&lt;/code&gt; ，并且 &lt;code&gt;lookup2&lt;/code&gt; 的查找类 &lt;code&gt;D&lt;/code&gt; 被记录为其先前的查找类。</target>
        </trans-unit>
        <trans-unit id="b7235ee23269ea4f01cc38b0aac3b8a2cb7f2edf" translate="yes" xml:space="preserve">
          <source>In the above example, the XML file is read into a DOM Document before being passed to the XPath API. The following code demonstrates the use of InputSource to leave it to the XPath implementation to process it:</source>
          <target state="translated">在上面的例子中,XML文件在被传递给XPath API之前被读入一个DOM文档。下面的代码演示了InputSource的使用,让XPath实现来处理它。</target>
        </trans-unit>
        <trans-unit id="6463be53e9fdab868fcd86a08889119e4172ad7b" translate="yes" xml:space="preserve">
          <source>In the above examples, the return type is always &lt;code&gt;CallSite&lt;/code&gt;, but that is not a necessary feature of bootstrap methods. In the case of a dynamically-computed call site, the only requirement is that the return type of the bootstrap method must be convertible (using the &lt;code&gt;asType&lt;/code&gt; conversions) to &lt;code&gt;CallSite&lt;/code&gt;, which means the bootstrap method return type might be &lt;code&gt;Object&lt;/code&gt; or &lt;code&gt;ConstantCallSite&lt;/code&gt;. In the case of a dynamically-resolved constant, the return type of the bootstrap method must be convertible to the type of the constant, as represented by its field type descriptor. For example, if the dynamic constant has a field type descriptor of &lt;code&gt;&quot;C&quot;&lt;/code&gt; (&lt;code&gt;char&lt;/code&gt;) then the bootstrap method return type could be &lt;code&gt;Object&lt;/code&gt;, &lt;code&gt;Character&lt;/code&gt;, or &lt;code&gt;char&lt;/code&gt;, but not &lt;code&gt;int&lt;/code&gt; or &lt;code&gt;Integer&lt;/code&gt;.</source>
          <target state="translated">在上面的示例中，返回类型始终为 &lt;code&gt;CallSite&lt;/code&gt; ，但这不是引导方法的必要功能。对于动态计算的调用站点，唯一的要求是引导方法的返回类型必须可转换（使用 &lt;code&gt;asType&lt;/code&gt; 转换）为 &lt;code&gt;CallSite&lt;/code&gt; ，这意味着引导方法的返回类型可以为 &lt;code&gt;Object&lt;/code&gt; 或 &lt;code&gt;ConstantCallSite&lt;/code&gt; 。对于动态解析的常量，引导方法的返回类型必须可转换为常量的类型，如其字段类型描述符所表示。例如，如果动态常数的字段类型描述符为 &lt;code&gt;&quot;C&quot;&lt;/code&gt; （ &lt;code&gt;char&lt;/code&gt; ），则bootstrap方法的返回类型可以是 &lt;code&gt;Object&lt;/code&gt; ， &lt;code&gt;Character&lt;/code&gt; 或 &lt;code&gt;char&lt;/code&gt; ，但不能是 &lt;code&gt;int&lt;/code&gt; 或 &lt;code&gt;Integer&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b2e436a63fb82b00c3480e918656abba05842f97" translate="yes" xml:space="preserve">
          <source>In the above, the &lt;em&gt;package name&lt;/em&gt; for a resource is derived from the subsequence of characters that precedes the last &lt;code&gt;'/'&lt;/code&gt; in the name and then replacing each &lt;code&gt;'/'&lt;/code&gt; character in the subsequence with &lt;code&gt;'.'&lt;/code&gt;. A leading slash is ignored when deriving the package name. As an example, the package name derived for a resource named &quot;&lt;code&gt;a/b/c/foo.properties&lt;/code&gt;&quot; is &quot;&lt;code&gt;a.b.c&lt;/code&gt;&quot;. A resource name with the name &quot;&lt;code&gt;META-INF/MANIFEST.MF&lt;/code&gt;&quot; is never encapsulated because &quot;&lt;code&gt;META-INF&lt;/code&gt;&quot; is not a legal package name.</source>
          <target state="translated">在上面，资源的&lt;em&gt;包名称&lt;/em&gt;是从&lt;em&gt;名称&lt;/em&gt;中最后一个 &lt;code&gt;'/'&lt;/code&gt; 之前的字符子序列派生的，然后用 &lt;code&gt;'.'&lt;/code&gt; 替换子序列中的每个 &lt;code&gt;'/'&lt;/code&gt; 字符。。导出程序包名称时，将忽略前导斜线。例如，派生自名为&amp;ldquo; &lt;code&gt;a/b/c/foo.properties&lt;/code&gt; &amp;rdquo;的资源的程序包名称为&amp;ldquo; &lt;code&gt;a.b.c&lt;/code&gt; &amp;rdquo;。永远不会封装名称为&amp;ldquo; &lt;code&gt;META-INF/MANIFEST.MF&lt;/code&gt; &amp;rdquo;的资源名称，因为&amp;ldquo; &lt;code&gt;META-INF&lt;/code&gt; &amp;rdquo;不是合法的程序包名称。</target>
        </trans-unit>
        <trans-unit id="60b93c27d35d4ef73db7b1a5de3b9ca5e3bbc362" translate="yes" xml:space="preserve">
          <source>In the absence of &lt;code&gt;remove&lt;/code&gt; calls, a class value has a simple state diagram: uninitialized and initialized. When &lt;code&gt;remove&lt;/code&gt; calls are made, the rules for value observation are more complex. See the documentation for &lt;a href=&quot;#remove(java.lang.Class)&quot;&gt;&lt;code&gt;remove&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">在没有 &lt;code&gt;remove&lt;/code&gt; 调用的情况下，类值具有简单的状态图：未初始化和初始化。进行 &lt;code&gt;remove&lt;/code&gt; 调用时，价值观察的规则更加复杂。有关更多信息，请参阅文档以进行&lt;a href=&quot;#remove(java.lang.Class)&quot;&gt; &lt;code&gt;remove&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5d6c6f9ca13ab5451799666ab96c66ed377dbd22" translate="yes" xml:space="preserve">
          <source>In the absence of &lt;code&gt;remove&lt;/code&gt; calls, a class value has a simple state diagram: uninitialized and initialized. When &lt;code&gt;remove&lt;/code&gt; calls are made, the rules for value observation are more complex. See the documentation for &lt;a href=&quot;classvalue#remove-java.lang.Class-&quot;&gt;&lt;code&gt;remove&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">在没有 &lt;code&gt;remove&lt;/code&gt; 调用的情况下，类值具有简单的状态图：未初始化和初始化。进行 &lt;code&gt;remove&lt;/code&gt; 调用时，价值观察规则更加复杂。有关更多信息，请参阅文档以进行&lt;a href=&quot;classvalue#remove-java.lang.Class-&quot;&gt; &lt;code&gt;remove&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a254ee0af676fe77ed6ba824317943df316a8c7a" translate="yes" xml:space="preserve">
          <source>In the absence of other alternatives, the method may throw an unchecked &lt;a href=&quot;rejectedexecutionexception&quot;&gt;&lt;code&gt;RejectedExecutionException&lt;/code&gt;&lt;/a&gt;, which will be propagated to the caller of &lt;code&gt;execute&lt;/code&gt;.</source>
          <target state="translated">在没有其他选择的情况下，该方法可能会抛出未经检查的&lt;a href=&quot;rejectedexecutionexception&quot;&gt; &lt;code&gt;RejectedExecutionException&lt;/code&gt; &lt;/a&gt;，该异常将传播到 &lt;code&gt;execute&lt;/code&gt; 的调用者。</target>
        </trans-unit>
        <trans-unit id="e0fcd323662ee68a5bf74deb7c77fe408fd53411" translate="yes" xml:space="preserve">
          <source>In the addition to &lt;code&gt;READ&lt;/code&gt; and &lt;code&gt;WRITE&lt;/code&gt;, the following options may be present:</source>
          <target state="translated">除了 &lt;code&gt;READ&lt;/code&gt; 和 &lt;code&gt;WRITE&lt;/code&gt; 之外，还可以提供以下选项：</target>
        </trans-unit>
        <trans-unit id="e177711c2e7ebd76cba6572a163ac3437710fb82" translate="yes" xml:space="preserve">
          <source>In the case of &lt;a href=&quot;#FULL_FLUSH&quot;&gt;&lt;code&gt;FULL_FLUSH&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#SYNC_FLUSH&quot;&gt;&lt;code&gt;SYNC_FLUSH&lt;/code&gt;&lt;/a&gt;, if the return value is &lt;code&gt;len&lt;/code&gt;, the space available in output buffer &lt;code&gt;b&lt;/code&gt;, this method should be invoked again with the same &lt;code&gt;flush&lt;/code&gt; parameter and more output space. Make sure that &lt;code&gt;len&lt;/code&gt; is greater than 6 to avoid flush marker (5 bytes) being repeatedly output to the output buffer every time this method is invoked.</source>
          <target state="translated">在&lt;a href=&quot;#FULL_FLUSH&quot;&gt; &lt;code&gt;FULL_FLUSH&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#SYNC_FLUSH&quot;&gt; &lt;code&gt;SYNC_FLUSH&lt;/code&gt; &lt;/a&gt;的情况下，如果返回值为 &lt;code&gt;len&lt;/code&gt; （输出缓冲区 &lt;code&gt;b&lt;/code&gt; 中的可用空间），则应使用相同的 &lt;code&gt;flush&lt;/code&gt; 参数和更多的输出空间再次调用此方法。确保 &lt;code&gt;len&lt;/code&gt; 大于6，以避免在每次调用此方法时将刷新标记（5个字节）重复输出到输出缓冲区。</target>
        </trans-unit>
        <trans-unit id="dd96ad5a66fc2285518bf3ab8cbec8fd8e9d5c66" translate="yes" xml:space="preserve">
          <source>In the case of &lt;a href=&quot;#FULL_FLUSH&quot;&gt;&lt;code&gt;FULL_FLUSH&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#SYNC_FLUSH&quot;&gt;&lt;code&gt;SYNC_FLUSH&lt;/code&gt;&lt;/a&gt;, if the return value is equal to the &lt;a href=&quot;../../nio/buffer#remaining()&quot;&gt;remaining space&lt;/a&gt; of the buffer, this method should be invoked again with the same &lt;code&gt;flush&lt;/code&gt; parameter and more output space. Make sure that the buffer has at least 6 bytes of remaining space to avoid the flush marker (5 bytes) being repeatedly output to the output buffer every time this method is invoked.</source>
          <target state="translated">在&lt;a href=&quot;#FULL_FLUSH&quot;&gt; &lt;code&gt;FULL_FLUSH&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#SYNC_FLUSH&quot;&gt; &lt;code&gt;SYNC_FLUSH&lt;/code&gt; &lt;/a&gt;的情况下，如果返回值等于缓冲区的&lt;a href=&quot;../../nio/buffer#remaining()&quot;&gt;剩余空间&lt;/a&gt;，则应使用相同的 &lt;code&gt;flush&lt;/code&gt; 参数和更多的输出空间再次调用此方法。确保缓冲区至少有6个字节的剩余空间，以避免刷新标记（5个字节）在每次调用此方法时重复输出到输出缓冲区。</target>
        </trans-unit>
        <trans-unit id="82201373a2610441e998008c462731da12155c0d" translate="yes" xml:space="preserve">
          <source>In the case of &lt;a href=&quot;deflater#FULL_FLUSH&quot;&gt;&lt;code&gt;FULL_FLUSH&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;deflater#SYNC_FLUSH&quot;&gt;&lt;code&gt;SYNC_FLUSH&lt;/code&gt;&lt;/a&gt;, if the return value is &lt;code&gt;len&lt;/code&gt;, the space available in output buffer &lt;code&gt;b&lt;/code&gt;, this method should be invoked again with the same &lt;code&gt;flush&lt;/code&gt; parameter and more output space.</source>
          <target state="translated">在&lt;a href=&quot;deflater#FULL_FLUSH&quot;&gt; &lt;code&gt;FULL_FLUSH&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;deflater#SYNC_FLUSH&quot;&gt; &lt;code&gt;SYNC_FLUSH&lt;/code&gt; &lt;/a&gt;的情况下，如果返回值为 &lt;code&gt;len&lt;/code&gt; （输出缓冲区 &lt;code&gt;b&lt;/code&gt; 中的可用空间），则应使用相同的 &lt;code&gt;flush&lt;/code&gt; 参数和更多的输出空间再次调用此方法。</target>
        </trans-unit>
        <trans-unit id="b7bc1d11380671a0651c6a64eb86fb652cb256f0" translate="yes" xml:space="preserve">
          <source>In the case of &lt;a href=&quot;standardwatcheventkinds#ENTRY_CREATE&quot;&gt;&lt;code&gt;ENTRY_CREATE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;standardwatcheventkinds#ENTRY_DELETE&quot;&gt;&lt;code&gt;ENTRY_DELETE&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;standardwatcheventkinds#ENTRY_MODIFY&quot;&gt;&lt;code&gt;ENTRY_MODIFY&lt;/code&gt;&lt;/a&gt; events the context is a &lt;code&gt;Path&lt;/code&gt; that is the &lt;a href=&quot;path#relativize(java.nio.file.Path)&quot;&gt;&lt;code&gt;relative&lt;/code&gt;&lt;/a&gt; path between the directory registered with the watch service, and the entry that is created, deleted, or modified.</source>
          <target state="translated">对于&lt;a href=&quot;standardwatcheventkinds#ENTRY_CREATE&quot;&gt; &lt;code&gt;ENTRY_CREATE&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;standardwatcheventkinds#ENTRY_DELETE&quot;&gt; &lt;code&gt;ENTRY_DELETE&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;standardwatcheventkinds#ENTRY_MODIFY&quot;&gt; &lt;code&gt;ENTRY_MODIFY&lt;/code&gt; &lt;/a&gt;事件，上下文是一个 &lt;code&gt;Path&lt;/code&gt; ，它是在监视服务中注册的目录与创建，删除或修改的条目之间的&lt;a href=&quot;path#relativize(java.nio.file.Path)&quot;&gt; &lt;code&gt;relative&lt;/code&gt; &lt;/a&gt;路径。</target>
        </trans-unit>
        <trans-unit id="08a4a6b6701bb5e9bce132b1aa14d72ca141be81" translate="yes" xml:space="preserve">
          <source>In the case of &lt;a href=&quot;standardwatcheventkinds#ENTRY_CREATE&quot;&gt;&lt;code&gt;ENTRY_CREATE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;standardwatcheventkinds#ENTRY_DELETE&quot;&gt;&lt;code&gt;ENTRY_DELETE&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;standardwatcheventkinds#ENTRY_MODIFY&quot;&gt;&lt;code&gt;ENTRY_MODIFY&lt;/code&gt;&lt;/a&gt; events the context is a &lt;code&gt;Path&lt;/code&gt; that is the &lt;a href=&quot;path#relativize-java.nio.file.Path-&quot;&gt;&lt;code&gt;relative&lt;/code&gt;&lt;/a&gt; path between the directory registered with the watch service, and the entry that is created, deleted, or modified.</source>
          <target state="translated">在&lt;a href=&quot;standardwatcheventkinds#ENTRY_CREATE&quot;&gt; &lt;code&gt;ENTRY_CREATE&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;standardwatcheventkinds#ENTRY_DELETE&quot;&gt; &lt;code&gt;ENTRY_DELETE&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;standardwatcheventkinds#ENTRY_MODIFY&quot;&gt; &lt;code&gt;ENTRY_MODIFY&lt;/code&gt; &lt;/a&gt;事件的情况下，上下文是一个 &lt;code&gt;Path&lt;/code&gt; ，它是在监视服务中注册的目录与创建，删除或修改的条目之间的&lt;a href=&quot;path#relativize-java.nio.file.Path-&quot;&gt; &lt;code&gt;relative&lt;/code&gt; &lt;/a&gt;路径。</target>
        </trans-unit>
        <trans-unit id="44bf9479e2baf7bea92c9e7d1d3e49e131a1ef7b" translate="yes" xml:space="preserve">
          <source>In the case of &lt;code&gt;invokeExact&lt;/code&gt;, the type descriptor of the invocation (after resolving symbolic type names) must exactly match the method type of the receiving method handle. In the case of plain, inexact &lt;code&gt;invoke&lt;/code&gt;, the resolved type descriptor must be a valid argument to the receiver's &lt;a href=&quot;#asType(java.lang.invoke.MethodType)&quot;&gt;&lt;code&gt;asType&lt;/code&gt;&lt;/a&gt; method. Thus, plain &lt;code&gt;invoke&lt;/code&gt; is more permissive than &lt;code&gt;invokeExact&lt;/code&gt;.</source>
          <target state="translated">对于 &lt;code&gt;invokeExact&lt;/code&gt; ，调用的类型描述符（在解析符号类型名称之后）必须与接收方法句柄的方法类型完全匹配。对于普通的，不精确的 &lt;code&gt;invoke&lt;/code&gt; ，解析的类型描述符必须是接收者的&lt;a href=&quot;#asType(java.lang.invoke.MethodType)&quot;&gt; &lt;code&gt;asType&lt;/code&gt; &lt;/a&gt;方法的有效参数。因此，普通 &lt;code&gt;invoke&lt;/code&gt; 比 &lt;code&gt;invokeExact&lt;/code&gt; 更宽容。</target>
        </trans-unit>
        <trans-unit id="0141b656cd010a95045e183f56a7350cc6b6fbd6" translate="yes" xml:space="preserve">
          <source>In the case of &lt;code&gt;invokeExact&lt;/code&gt;, the type descriptor of the invocation (after resolving symbolic type names) must exactly match the method type of the receiving method handle. In the case of plain, inexact &lt;code&gt;invoke&lt;/code&gt;, the resolved type descriptor must be a valid argument to the receiver's &lt;a href=&quot;methodhandle#asType-java.lang.invoke.MethodType-&quot;&gt;&lt;code&gt;asType&lt;/code&gt;&lt;/a&gt; method. Thus, plain &lt;code&gt;invoke&lt;/code&gt; is more permissive than &lt;code&gt;invokeExact&lt;/code&gt;.</source>
          <target state="translated">对于 &lt;code&gt;invokeExact&lt;/code&gt; ，调用的类型描述符（在解析符号类型名称之后）必须与接收方法句柄的方法类型完全匹配。对于普通的，不精确的 &lt;code&gt;invoke&lt;/code&gt; ，解析的类型描述符必须是接收者的&lt;a href=&quot;methodhandle#asType-java.lang.invoke.MethodType-&quot;&gt; &lt;code&gt;asType&lt;/code&gt; &lt;/a&gt;方法的有效参数。因此，普通 &lt;code&gt;invoke&lt;/code&gt; 比 &lt;code&gt;invokeExact&lt;/code&gt; 更宽容。</target>
        </trans-unit>
        <trans-unit id="ab2ee1acf84658ca3734ba1e3885215a35ed71a6" translate="yes" xml:space="preserve">
          <source>In the case of a certificate factory for X.509 CRLs, &lt;code&gt;inStream&lt;/code&gt; may contain a sequence of DER-encoded CRLs. In addition, &lt;code&gt;inStream&lt;/code&gt; may contain a PKCS#7 CRL set. This is a PKCS#7</source>
          <target state="translated">对于X.509 CRL的证书工厂， &lt;code&gt;inStream&lt;/code&gt; 可能包含一系列DER编码的CRL。另外， &lt;code&gt;inStream&lt;/code&gt; 可能包含PKCS＃7 CRL集。这是PKCS＃7</target>
        </trans-unit>
        <trans-unit id="08ac21be0ad130188c9cac95e7929ab7e554db46" translate="yes" xml:space="preserve">
          <source>In the case of a certificate factory for X.509 CRLs, &lt;code&gt;inStream&lt;/code&gt; may contain a single DER-encoded CRL. In addition, &lt;code&gt;inStream&lt;/code&gt; may contain a PKCS#7 CRL set. This is a PKCS#7</source>
          <target state="translated">对于X.509 CRL的证书工厂， &lt;code&gt;inStream&lt;/code&gt; 可能包含单个DER编码的CRL。另外， &lt;code&gt;inStream&lt;/code&gt; 可能包含PKCS＃7 CRL集。这是PKCS＃7</target>
        </trans-unit>
        <trans-unit id="08442fbda5448829acda7334681c1abf6040c3e1" translate="yes" xml:space="preserve">
          <source>In the case of a certificate factory for X.509 certificates, &lt;code&gt;inStream&lt;/code&gt; may contain a sequence of DER-encoded certificates in the formats described for &lt;a href=&quot;#generateCertificate(java.io.InputStream)&quot;&gt;&lt;code&gt;generateCertificate&lt;/code&gt;&lt;/a&gt;. In addition, &lt;code&gt;inStream&lt;/code&gt; may contain a PKCS#7 certificate chain. This is a PKCS#7</source>
          <target state="translated">对于X.509证书的证书工厂， &lt;code&gt;inStream&lt;/code&gt; 可以包含针对&lt;a href=&quot;#generateCertificate(java.io.InputStream)&quot;&gt; &lt;code&gt;generateCertificate&lt;/code&gt; &lt;/a&gt;描述的格式的DER编码证书序列。另外， &lt;code&gt;inStream&lt;/code&gt; 可能包含PKCS＃7证书链。这是PKCS＃7</target>
        </trans-unit>
        <trans-unit id="1fc2160b4adf857b1556e09bd5dd1ba9ce62d01b" translate="yes" xml:space="preserve">
          <source>In the case of a certificate factory for X.509 certificates, &lt;code&gt;inStream&lt;/code&gt; may contain a sequence of DER-encoded certificates in the formats described for &lt;a href=&quot;certificatefactory#generateCertificate-java.io.InputStream-&quot;&gt;&lt;code&gt;generateCertificate&lt;/code&gt;&lt;/a&gt;. In addition, &lt;code&gt;inStream&lt;/code&gt; may contain a PKCS#7 certificate chain. This is a PKCS#7</source>
          <target state="translated">对于X.509证书的证书工厂， &lt;code&gt;inStream&lt;/code&gt; 可以包含针对&lt;a href=&quot;certificatefactory#generateCertificate-java.io.InputStream-&quot;&gt; &lt;code&gt;generateCertificate&lt;/code&gt; &lt;/a&gt;描述的格式的DER编码证书序列。另外， &lt;code&gt;inStream&lt;/code&gt; 可能包含PKCS＃7证书链。这是PKCS＃7</target>
        </trans-unit>
        <trans-unit id="1280b4cb57ef8893db4d47767dab95ce080e8f83" translate="yes" xml:space="preserve">
          <source>In the case of a certificate factory for X.509 certificates, &lt;code&gt;inStream&lt;/code&gt; may contain a single DER-encoded certificate in the formats described for &lt;a href=&quot;certificatefactory#generateCertificate(java.io.InputStream)&quot;&gt;&lt;code&gt;generateCertificate&lt;/code&gt;&lt;/a&gt;. In addition, &lt;code&gt;inStream&lt;/code&gt; may contain a PKCS#7 certificate chain. This is a PKCS#7</source>
          <target state="translated">对于X.509证书的证书工厂， &lt;code&gt;inStream&lt;/code&gt; 可以包含一个单独的DER编码证书，格式与&lt;a href=&quot;certificatefactory#generateCertificate(java.io.InputStream)&quot;&gt; &lt;code&gt;generateCertificate&lt;/code&gt; 相同&lt;/a&gt;。另外， &lt;code&gt;inStream&lt;/code&gt; 可能包含PKCS＃7证书链。这是PKCS＃7</target>
        </trans-unit>
        <trans-unit id="9dc29d2259ad105e7403a0727eb82c65459584a5" translate="yes" xml:space="preserve">
          <source>In the case of a certificate factory for X.509 certificates, &lt;code&gt;inStream&lt;/code&gt; may contain a single DER-encoded certificate in the formats described for &lt;a href=&quot;certificatefactory#generateCertificate-java.io.InputStream-&quot;&gt;&lt;code&gt;generateCertificate&lt;/code&gt;&lt;/a&gt;. In addition, &lt;code&gt;inStream&lt;/code&gt; may contain a PKCS#7 certificate chain. This is a PKCS#7</source>
          <target state="translated">对于X.509证书的证书工厂， &lt;code&gt;inStream&lt;/code&gt; 可以包含一个单独的DER编码证书，格式与&lt;a href=&quot;certificatefactory#generateCertificate-java.io.InputStream-&quot;&gt; &lt;code&gt;generateCertificate&lt;/code&gt; 相同&lt;/a&gt;。另外， &lt;code&gt;inStream&lt;/code&gt; 可能包含PKCS＃7证书链。这是PKCS＃7</target>
        </trans-unit>
        <trans-unit id="50da2fff261ef006a8b616c0bf4d45a215566afb" translate="yes" xml:space="preserve">
          <source>In the case of a certificate factory for X.509 certificates, the certificate provided in &lt;code&gt;inStream&lt;/code&gt; must be DER-encoded and may be supplied in binary or printable (Base64) encoding. If the certificate is provided in Base64 encoding, it must be bounded at the beginning by -----BEGIN CERTIFICATE-----, and must be bounded at the end by -----END CERTIFICATE-----.</source>
          <target state="translated">对于X.509证书的证书工厂， &lt;code&gt;inStream&lt;/code&gt; 中提供的证书必须经过DER编码，并且可以二进制或可打印（Base64）编码提供。如果证书是以Base64编码提供的，则必须以----- BEGIN CERTIFICATE -----开头，并且必须以----- END CERTIFICATE -----结尾。 。</target>
        </trans-unit>
        <trans-unit id="1d5701b6b4b744bfc6a3efcf6ae43a047cc32ed3" translate="yes" xml:space="preserve">
          <source>In the case of a channel to an &lt;a href=&quot;../../net/standardprotocolfamily#INET&quot;&gt;&lt;code&gt;IPv4&lt;/code&gt;&lt;/a&gt; socket, the underlying operating system optionally supports &lt;a href=&quot;http://www.ietf.org/rfc/rfc2236.txt&quot;&gt; &lt;i&gt;RFC 2236: Internet Group Management Protocol, Version 2 (IGMPv2)&lt;/i&gt;&lt;/a&gt;. When IGMPv2 is supported then the operating system may additionally support source filtering as specified by &lt;a href=&quot;http://www.ietf.org/rfc/rfc3376.txt&quot;&gt; &lt;i&gt;RFC 3376: Internet Group Management Protocol, Version 3 (IGMPv3)&lt;/i&gt;&lt;/a&gt;. For channels to an &lt;a href=&quot;../../net/standardprotocolfamily#INET6&quot;&gt;&lt;code&gt;IPv6&lt;/code&gt;&lt;/a&gt; socket, the equivalent standards are &lt;a href=&quot;http://www.ietf.org/rfc/rfc2710.txt&quot;&gt; &lt;i&gt;RFC 2710: Multicast Listener Discovery (MLD) for IPv6&lt;/i&gt;&lt;/a&gt; and &lt;a href=&quot;http://www.ietf.org/rfc/rfc3810.txt&quot;&gt; &lt;i&gt;RFC 3810: Multicast Listener Discovery Version 2 (MLDv2) for IPv6&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">如果是通向&lt;a href=&quot;../../net/standardprotocolfamily#INET&quot;&gt; &lt;code&gt;IPv4&lt;/code&gt; &lt;/a&gt;套接字的通道，则底层操作系统可以选择支持&lt;a href=&quot;http://www.ietf.org/rfc/rfc2236.txt&quot;&gt;&lt;i&gt;RFC 2236：Internet组管理协议，版本2（IGMPv2）&lt;/i&gt;&lt;/a&gt;。当支持IGMPv2时，操作系统可以另外支持&lt;a href=&quot;http://www.ietf.org/rfc/rfc3376.txt&quot;&gt;&lt;i&gt;RFC 3376：Internet组管理协议版本3（IGMPv3）&lt;/i&gt;&lt;/a&gt;指定的源过滤。对于通往&lt;a href=&quot;../../net/standardprotocolfamily#INET6&quot;&gt; &lt;code&gt;IPv6&lt;/code&gt; &lt;/a&gt;套接字的通道，等效标准为&lt;a href=&quot;http://www.ietf.org/rfc/rfc2710.txt&quot;&gt;&lt;i&gt;RFC 2710：用于IPv6的多播侦听器发现（MLD）&lt;/i&gt;&lt;/a&gt;和&lt;a href=&quot;http://www.ietf.org/rfc/rfc3810.txt&quot;&gt;&lt;i&gt;RFC 3810：&lt;/i&gt;&lt;/a&gt;&lt;i&gt;用于IPv6的&lt;/i&gt;&lt;i&gt;多播侦听器发现版本2（MLDv2）&lt;/i&gt;。 &lt;i&gt;&lt;/i&gt; &lt;i&gt;&lt;/i&gt; &lt;i&gt;&lt;/i&gt; &lt;i&gt;&lt;/i&gt;</target>
        </trans-unit>
        <trans-unit id="3ef58cd33624ae44343ffc4ef5d48a749d01d1a9" translate="yes" xml:space="preserve">
          <source>In the case of a channel to an &lt;a href=&quot;../../net/standardprotocolfamily#INET&quot;&gt;&lt;code&gt;IPv4&lt;/code&gt;&lt;/a&gt; socket, the underlying operating system optionally supports &lt;a href=&quot;https://www.ietf.org/rfc/rfc2236.txt&quot;&gt; &lt;i&gt;RFC 2236: Internet Group Management Protocol, Version 2 (IGMPv2)&lt;/i&gt;&lt;/a&gt;. When IGMPv2 is supported then the operating system may additionally support source filtering as specified by &lt;a href=&quot;https://www.ietf.org/rfc/rfc3376.txt&quot;&gt; &lt;i&gt;RFC 3376: Internet Group Management Protocol, Version 3 (IGMPv3)&lt;/i&gt;&lt;/a&gt;. For channels to an &lt;a href=&quot;../../net/standardprotocolfamily#INET6&quot;&gt;&lt;code&gt;IPv6&lt;/code&gt;&lt;/a&gt; socket, the equivalent standards are &lt;a href=&quot;https://www.ietf.org/rfc/rfc2710.txt&quot;&gt; &lt;i&gt;RFC 2710: Multicast Listener Discovery (MLD) for IPv6&lt;/i&gt;&lt;/a&gt; and &lt;a href=&quot;https://www.ietf.org/rfc/rfc3810.txt&quot;&gt; &lt;i&gt;RFC 3810: Multicast Listener Discovery Version 2 (MLDv2) for IPv6&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">如果是通向&lt;a href=&quot;../../net/standardprotocolfamily#INET&quot;&gt; &lt;code&gt;IPv4&lt;/code&gt; &lt;/a&gt;套接字的通道，则底层操作系统可以选择支持&lt;a href=&quot;https://www.ietf.org/rfc/rfc2236.txt&quot;&gt;&lt;i&gt;RFC 2236：Internet组管理协议，版本2（IGMPv2）&lt;/i&gt;&lt;/a&gt;。当支持IGMPv2时，操作系统可以另外支持&lt;a href=&quot;https://www.ietf.org/rfc/rfc3376.txt&quot;&gt;&lt;i&gt;RFC 3376：Internet组管理协议版本3（IGMPv3）&lt;/i&gt;&lt;/a&gt;指定的源过滤。对于通往&lt;a href=&quot;../../net/standardprotocolfamily#INET6&quot;&gt; &lt;code&gt;IPv6&lt;/code&gt; &lt;/a&gt;套接字的通道，等效标准为&lt;a href=&quot;https://www.ietf.org/rfc/rfc2710.txt&quot;&gt;&lt;i&gt;RFC 2710：用于IPv6的多播侦听器发现（MLD）&lt;/i&gt;&lt;/a&gt;和&lt;a href=&quot;https://www.ietf.org/rfc/rfc3810.txt&quot;&gt;&lt;i&gt;RFC 3810：&lt;/i&gt;&lt;/a&gt;&lt;i&gt;用于IPv6的&lt;/i&gt;&lt;i&gt;多播侦听器发现版本2（MLDv2）&lt;/i&gt;。 &lt;i&gt;&lt;/i&gt; &lt;i&gt;&lt;/i&gt; &lt;i&gt;&lt;/i&gt; &lt;i&gt;&lt;/i&gt;</target>
        </trans-unit>
        <trans-unit id="19a2051fd0e5e72f45a371eb872d31545b4adfc3" translate="yes" xml:space="preserve">
          <source>In the case of a channel to an &lt;a href=&quot;../../net/standardprotocolfamily#INET&quot;&gt;&lt;code&gt;IPv4&lt;/code&gt;&lt;/a&gt; socket, the underlying operating system supports &lt;a href=&quot;http://www.ietf.org/rfc/rfc2236.txt&quot;&gt; &lt;i&gt;RFC 2236: Internet Group Management Protocol, Version 2 (IGMPv2)&lt;/i&gt;&lt;/a&gt;. It may optionally support source filtering as specified by &lt;a href=&quot;http://www.ietf.org/rfc/rfc3376.txt&quot;&gt; &lt;i&gt;RFC 3376: Internet Group Management Protocol, Version 3 (IGMPv3)&lt;/i&gt;&lt;/a&gt;. For channels to an &lt;a href=&quot;../../net/standardprotocolfamily#INET6&quot;&gt;&lt;code&gt;IPv6&lt;/code&gt;&lt;/a&gt; socket, the equivalent standards are &lt;a href=&quot;http://www.ietf.org/rfc/rfc2710.txt&quot;&gt; &lt;i&gt;RFC 2710: Multicast Listener Discovery (MLD) for IPv6&lt;/i&gt;&lt;/a&gt; and &lt;a href=&quot;http://www.ietf.org/rfc/rfc3810.txt&quot;&gt; &lt;i&gt;RFC 3810: Multicast Listener Discovery Version 2 (MLDv2) for IPv6&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">对于到&lt;a href=&quot;../../net/standardprotocolfamily#INET&quot;&gt; &lt;code&gt;IPv4&lt;/code&gt; &lt;/a&gt;套接字的通道，底层操作系统支持&lt;a href=&quot;http://www.ietf.org/rfc/rfc2236.txt&quot;&gt;&lt;i&gt;RFC 2236：Internet组管理协议，版本2（IGMPv2）&lt;/i&gt;&lt;/a&gt;。它可以选择支持&lt;a href=&quot;http://www.ietf.org/rfc/rfc3376.txt&quot;&gt;&lt;i&gt;RFC 3376：Internet组管理协议版本3（IGMPv3）中&lt;/i&gt;&lt;/a&gt;指定的源过滤。对于通往&lt;a href=&quot;../../net/standardprotocolfamily#INET6&quot;&gt; &lt;code&gt;IPv6&lt;/code&gt; &lt;/a&gt;套接字的通道，等效标准为&lt;a href=&quot;http://www.ietf.org/rfc/rfc2710.txt&quot;&gt;&lt;i&gt;RFC 2710：用于IPv6的多播侦听器发现（MLD）&lt;/i&gt;&lt;/a&gt;和&lt;a href=&quot;http://www.ietf.org/rfc/rfc3810.txt&quot;&gt;&lt;i&gt;RFC 3810：&lt;/i&gt;&lt;/a&gt;&lt;i&gt;用于IPv6的&lt;/i&gt;&lt;i&gt;多播侦听器发现版本2（MLDv2）&lt;/i&gt;。 &lt;i&gt;&lt;/i&gt; &lt;i&gt;&lt;/i&gt; &lt;i&gt;&lt;/i&gt; &lt;i&gt;&lt;/i&gt;</target>
        </trans-unit>
        <trans-unit id="e531c3c2e234b2ee1973c771c135218a06466ad9" translate="yes" xml:space="preserve">
          <source>In the case of a gap, when clocks jump forward, there is no valid offset. Instead, the local date-time is adjusted to be later by the length of the gap. For a typical one hour daylight savings change, the local date-time will be moved one hour later into the offset typically corresponding to &quot;summer&quot;.</source>
          <target state="translated">在间隙的情况下,当时钟向前跳时,没有有效的偏移。取而代之的是,当地的日期时间会被调整为较晚的差距长度。对于典型的一个小时的夏令时变化,当地的日期时间将被移到通常对应于 &quot;夏季 &quot;的偏移量中晚一小时。</target>
        </trans-unit>
        <trans-unit id="9fb01ead713905f1c81d4e6999c70b57340a9655" translate="yes" xml:space="preserve">
          <source>In the case of a gap, where clocks jump forward, there is no valid offset. Instead, the local date-time is adjusted to be later by the length of the gap. For a typical one hour daylight savings change, the local date-time will be moved one hour later into the offset typically corresponding to &quot;summer&quot;.</source>
          <target state="translated">在间隙的情况下,时钟向前跳跃,没有有效的偏移。取而代之的是,当地的日期时间会被调整为较晚的差距长度。对于典型的一小时夏令时变化,当地的日期时间将被移到通常对应于 &quot;夏季 &quot;的偏移量中,晚一小时。</target>
        </trans-unit>
        <trans-unit id="b86e31d3309c9966888d1ce571949f78da06b9f0" translate="yes" xml:space="preserve">
          <source>In the case of a periodic notification, the value of parameter</source>
          <target state="translated">如果是定期通知,则参数</target>
        </trans-unit>
        <trans-unit id="96af2556cfa1cd3f7eb8b73ee624b6aaa0970cfe" translate="yes" xml:space="preserve">
          <source>In the case of a periodic notification, uses a</source>
          <target state="translated">在定期通知书的情况下,使用的是:</target>
        </trans-unit>
        <trans-unit id="c9d56fa1d686e2f987ac2bf8aff1d4833e84b98f" translate="yes" xml:space="preserve">
          <source>In the case of a stored entry, the compressed size will be the same as the uncompressed size of the entry.</source>
          <target state="translated">在存储条目的情况下,压缩后的大小将与该条目的未压缩大小相同。</target>
        </trans-unit>
        <trans-unit id="79f5f7cb66c356485e0341ec28ed935ec708859f" translate="yes" xml:space="preserve">
          <source>In the case of an error event, the &lt;code&gt;SQLException&lt;/code&gt; about to be thrown to the application</source>
          <target state="translated">如果发生错误事件，则将 &lt;code&gt;SQLException&lt;/code&gt; 抛出给应用程序</target>
        </trans-unit>
        <trans-unit id="db9e1ca64bffdeb509e25f717c03ee7e37e961d7" translate="yes" xml:space="preserve">
          <source>In the case of jar: and file: URLs, it also closes any files that were opened by it. If another thread is loading a class when the &lt;code&gt;close&lt;/code&gt; method is invoked, then the result of that load is undefined.</source>
          <target state="translated">对于jar：和file：URL，它还会关闭由它打开的所有文件。如果在调用 &lt;code&gt;close&lt;/code&gt; 方法时另一个线程正在加载一个类，则该加载的结果是不确定的。</target>
        </trans-unit>
        <trans-unit id="6d29bc847b83395a5115bf2af88720192d26de17" translate="yes" xml:space="preserve">
          <source>In the case of nested elements mouse events are always targeted at the most deeply nested element. Ancestors of the targeted element may use bubbling to obtain notification of mouse events which occur within its descendent elements.</source>
          <target state="translated">在嵌套元素的情况下,鼠标事件总是针对嵌套最深的元素。目标元素的祖先可以使用冒泡来获得发生在其子代元素中的鼠标事件的通知。</target>
        </trans-unit>
        <trans-unit id="4807dcb176adbdc605239808fd2a7d991465460a" translate="yes" xml:space="preserve">
          <source>In the case of stream-oriented sockets and the TCP/IP protocol, the size of the socket receive buffer may be used when advertising the size of the TCP receive window to the remote peer.</source>
          <target state="translated">在面向流的套接字和TCP/IP协议的情况下,当向远程对等体宣传TCP接收窗口的大小时,可以使用套接字接收缓冲区的大小。</target>
        </trans-unit>
        <trans-unit id="bf471b822472cd913bb8281589b6b04dc469c7d2" translate="yes" xml:space="preserve">
          <source>In the case of stream-oriented sockets, this socket option usually allows multiple listening sockets to be bound to both same address and same port.</source>
          <target state="translated">在面向流的套接字的情况下,这个套接字选项通常允许多个监听套接字同时绑定到同一个地址和同一个端口。</target>
        </trans-unit>
        <trans-unit id="1564f388d1bc3d2b047f3cec6463a2aca746fb14" translate="yes" xml:space="preserve">
          <source>In the case of stream-oriented sockets, this socket option will usually determine whether the socket can be bound to a socket address when a previous connection involving that socket address is in the &lt;em&gt;TIME_WAIT&lt;/em&gt; state. On implementations where the semantics differ, and the socket option is not required to be enabled in order to bind the socket when a previous connection is in this state, then the implementation may choose to ignore this option.</source>
          <target state="translated">对于面向流的套接字，当涉及该套接字地址的先前连接处于&lt;em&gt;TIME_WAIT&lt;/em&gt;状态时，此套接字选项通常将确定是否可以将套接字绑定到套接字地址。在语义不同的实现上，并且当先前的连接处于此状态时，不需要启用socket选项以绑定套接字，则实现可以选择忽略此选项。</target>
        </trans-unit>
        <trans-unit id="dbce8b76773e0924f547ca32e02c138abec61f0c" translate="yes" xml:space="preserve">
          <source>In the case of the default &lt;a href=&quot;spi/filesystemprovider&quot;&gt;&lt;code&gt;provider&lt;/code&gt;&lt;/a&gt;, and a security manager is set, then the permission checks are performed using the path obtained by resolving the given relative path against the</source>
          <target state="translated">如果使用默认&lt;a href=&quot;spi/filesystemprovider&quot;&gt; &lt;code&gt;provider&lt;/code&gt; &lt;/a&gt;，并且设置了安全管理器，则将使用通过针对给定的相对路径解析获得的路径来执行权限检查。</target>
        </trans-unit>
        <trans-unit id="2acbb2a942c10226f4e1277dd7d72a0351f0b499" translate="yes" xml:space="preserve">
          <source>In the case of the default file system provider, security manager permission checks are performed in this factory method, when the &lt;code&gt;BodyHandler&lt;/code&gt; is created. Otherwise, &lt;a href=&quot;../../../../java.base/java/nio/channels/filechannel#open(java.nio.file.Path,java.nio.file.OpenOption...)&quot;&gt;permission checks&lt;/a&gt; may be performed asynchronously against the caller's context at file access time. Care must be taken that the &lt;code&gt;BodyHandler&lt;/code&gt; is not shared with untrusted code.</source>
          <target state="translated">对于默认文件系统提供程序，在创建 &lt;code&gt;BodyHandler&lt;/code&gt; 时，将使用此工厂方法执行安全管理器权限检查。否则，可以在文件访问时针对调用者的上下文异步执行&lt;a href=&quot;../../../../java.base/java/nio/channels/filechannel#open(java.nio.file.Path,java.nio.file.OpenOption...)&quot;&gt;权限检查&lt;/a&gt;。必须注意不要与不受信任的代码共享 &lt;code&gt;BodyHandler&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8360a55eabc67cedca5aa11d65115bb731e33710" translate="yes" xml:space="preserve">
          <source>In the case of the default file system provider, security manager permission checks are performed in this factory method, when the &lt;code&gt;BodySubscriber&lt;/code&gt; is created. Otherwise, &lt;a href=&quot;../../../../java.base/java/nio/channels/filechannel#open(java.nio.file.Path,java.nio.file.OpenOption...)&quot;&gt;permission checks&lt;/a&gt; may be performed asynchronously against the caller's context at file access time. Care must be taken that the &lt;code&gt;BodySubscriber&lt;/code&gt; is not shared with untrusted code.</source>
          <target state="translated">对于默认文件系统提供程序，在创建 &lt;code&gt;BodySubscriber&lt;/code&gt; 时，将使用此工厂方法执行安全管理器权限检查。否则，可以在文件访问时针对调用者的上下文异步执行&lt;a href=&quot;../../../../java.base/java/nio/channels/filechannel#open(java.nio.file.Path,java.nio.file.OpenOption...)&quot;&gt;权限检查&lt;/a&gt;。必须注意不要与不受信任的代码共享 &lt;code&gt;BodySubscriber&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5968dc2de2ab512d950a835df9b47f509611629e" translate="yes" xml:space="preserve">
          <source>In the case of the default provider, and a security manager is installed, the security manager is invoked to check &lt;a href=&quot;../../lang/runtimepermission&quot;&gt;&lt;code&gt;RuntimePermission&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(&quot;getFileStoreAttributes&quot;)&lt;/code&gt;. If denied, then no file stores are returned by the iterator. In addition, the security manager's &lt;a href=&quot;../../lang/securitymanager#checkRead(java.lang.String)&quot;&gt;&lt;code&gt;SecurityManager.checkRead(String)&lt;/code&gt;&lt;/a&gt; method is invoked to check read access to the file store's &lt;em&gt;top-most&lt;/em&gt; directory. If denied, the file store is not returned by the iterator. It is system dependent if the permission checks are done when the iterator is obtained or during iteration.</source>
          <target state="translated">对于默认提供程序，并安装了安全管理器，将调用安全管理器以检查&lt;a href=&quot;../../lang/runtimepermission&quot;&gt; &lt;code&gt;RuntimePermission&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(&quot;getFileStoreAttributes&quot;)&lt;/code&gt; 。如果被拒绝，则迭代器不返回任何文件存储。另外，安全管理器的&lt;a href=&quot;../../lang/securitymanager#checkRead(java.lang.String)&quot;&gt; &lt;code&gt;SecurityManager.checkRead(String)&lt;/code&gt; &lt;/a&gt;方法被调用以检查对文件存储的&lt;em&gt;最顶层&lt;/em&gt;目录的读取访问。如果被拒绝，则迭代器不返回文件存储。获取迭代器时或在迭代过程中是否进行了权限检查，这取决于系统。</target>
        </trans-unit>
        <trans-unit id="9d2512a124feacc9023efa7b4655feac56aa98d5" translate="yes" xml:space="preserve">
          <source>In the case of the default provider, and a security manager is installed, the security manager is invoked to check &lt;a href=&quot;../../lang/runtimepermission&quot;&gt;&lt;code&gt;RuntimePermission&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(&quot;getFileStoreAttributes&quot;)&lt;/code&gt;. If denied, then no file stores are returned by the iterator. In addition, the security manager's &lt;a href=&quot;../../lang/securitymanager#checkRead-java.lang.String-&quot;&gt;&lt;code&gt;SecurityManager.checkRead(String)&lt;/code&gt;&lt;/a&gt; method is invoked to check read access to the file store's &lt;em&gt;top-most&lt;/em&gt; directory. If denied, the file store is not returned by the iterator. It is system dependent if the permission checks are done when the iterator is obtained or during iteration.</source>
          <target state="translated">对于默认提供程序，并安装了安全管理器，将调用安全管理器以检查&lt;a href=&quot;../../lang/runtimepermission&quot;&gt; &lt;code&gt;RuntimePermission&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(&quot;getFileStoreAttributes&quot;)&lt;/code&gt; 。如果被拒绝，则迭代器不返回任何文件存储。另外，安全管理器的&lt;a href=&quot;../../lang/securitymanager#checkRead-java.lang.String-&quot;&gt; &lt;code&gt;SecurityManager.checkRead(String)&lt;/code&gt; &lt;/a&gt;方法被调用以检查对文件存储的&lt;em&gt;最顶层&lt;/em&gt;目录的读取访问。如果被拒绝，则迭代器不返回文件存储。获取迭代器时或在迭代过程中是否进行了权限检查，这取决于系统。</target>
        </trans-unit>
        <trans-unit id="ea663ac7ab663b6f6b3fe5151c0ca401f469a636" translate="yes" xml:space="preserve">
          <source>In the case of the default provider, identified by the URI scheme &quot;file&quot;, the given URI has a non-empty path component, and undefined query and fragment components. Whether the authority component may be present is platform specific. The returned &lt;code&gt;Path&lt;/code&gt; is associated with the &lt;a href=&quot;filesystems#getDefault()&quot;&gt;&lt;code&gt;default&lt;/code&gt;&lt;/a&gt; file system.</source>
          <target state="translated">对于默认提供程序（由URI方案&amp;ldquo;文件&amp;rdquo;标识），给定URI具有非空路径组件以及未定义的查询和片段组件。权限组件是否存在取决于平台。返回的 &lt;code&gt;Path&lt;/code&gt; 与&lt;a href=&quot;filesystems#getDefault()&quot;&gt; &lt;code&gt;default&lt;/code&gt; &lt;/a&gt;文件系统关联。</target>
        </trans-unit>
        <trans-unit id="f4b5c76d8aaed40c475f832a5a54a3692fea75a4" translate="yes" xml:space="preserve">
          <source>In the case of the default provider, identified by the URI scheme &quot;file&quot;, the given URI has a non-empty path component, and undefined query and fragment components. Whether the authority component may be present is platform specific. The returned &lt;code&gt;Path&lt;/code&gt; is associated with the &lt;a href=&quot;filesystems#getDefault--&quot;&gt;&lt;code&gt;default&lt;/code&gt;&lt;/a&gt; file system.</source>
          <target state="translated">对于默认提供程序（由URI方案&amp;ldquo;文件&amp;rdquo;标识），给定URI具有非空路径组件以及未定义的查询和片段组件。权限组件是否存在取决于平台。返回的 &lt;code&gt;Path&lt;/code&gt; 与&lt;a href=&quot;filesystems#getDefault--&quot;&gt; &lt;code&gt;default&lt;/code&gt; &lt;/a&gt;文件系统关联。</target>
        </trans-unit>
        <trans-unit id="99df03667bc9a4291eea54f38aa6ac17e53c146f" translate="yes" xml:space="preserve">
          <source>In the case of the default provider, path strings are parsed based on the definition of paths at the platform or virtual file system level. For example, an operating system may not allow specific characters to be present in a file name, but a specific underlying file store may impose different or additional restrictions on the set of legal characters.</source>
          <target state="translated">在默认提供者的情况下,路径字符串是根据平台或虚拟文件系统级别的路径定义来解析的。例如,操作系统可能不允许文件名中出现特定的字符,但特定的底层文件存储可能会对合法字符集施加不同的或额外的限制。</target>
        </trans-unit>
        <trans-unit id="0e677b2f41e86e85d7c1fa6979a637c642297d74" translate="yes" xml:space="preserve">
          <source>In the case of the default provider, the URI is hierarchical with a &lt;a href=&quot;../../net/uri#getPath()&quot;&gt;&lt;code&gt;path&lt;/code&gt;&lt;/a&gt; component that is absolute. The query and fragment components are undefined. Whether the authority component is defined or not is implementation dependent. There is no guarantee that the &lt;code&gt;URI&lt;/code&gt; may be used to construct a &lt;a href=&quot;../../io/file&quot;&gt;&lt;code&gt;java.io.File&lt;/code&gt;&lt;/a&gt;. In particular, if this path represents a Universal Naming Convention (UNC) path, then the UNC server name may be encoded in the authority component of the resulting URI. In the case of the default provider, and the file exists, and it can be determined that the file is a directory, then the resulting &lt;code&gt;URI&lt;/code&gt; will end with a slash.</source>
          <target state="translated">在默认提供程序的情况下，URI是具有绝对&lt;a href=&quot;../../net/uri#getPath()&quot;&gt; &lt;code&gt;path&lt;/code&gt; &lt;/a&gt;组件的分层结构。查询和片段组件是未定义的。权限组件是否已定义取决于实现。无法保证可以使用 &lt;code&gt;URI&lt;/code&gt; 来构造&lt;a href=&quot;../../io/file&quot;&gt; &lt;code&gt;java.io.File&lt;/code&gt; &lt;/a&gt;。尤其是，如果此路径表示通用命名约定（UNC）路径，则UNC服务器名称可以编码在所得URI的权限组件中。如果是默认提供程序，并且文件存在，并且可以确定该文件是目录，那么生成的 &lt;code&gt;URI&lt;/code&gt; 将以斜杠结尾。</target>
        </trans-unit>
        <trans-unit id="a898e5309a9ca4566bd5a4562ddfa9fccc431258" translate="yes" xml:space="preserve">
          <source>In the case of the default provider, the URI is hierarchical with a &lt;a href=&quot;../../net/uri#getPath--&quot;&gt;&lt;code&gt;path&lt;/code&gt;&lt;/a&gt; component that is absolute. The query and fragment components are undefined. Whether the authority component is defined or not is implementation dependent. There is no guarantee that the &lt;code&gt;URI&lt;/code&gt; may be used to construct a &lt;a href=&quot;../../io/file&quot;&gt;&lt;code&gt;java.io.File&lt;/code&gt;&lt;/a&gt;. In particular, if this path represents a Universal Naming Convention (UNC) path, then the UNC server name may be encoded in the authority component of the resulting URI. In the case of the default provider, and the file exists, and it can be determined that the file is a directory, then the resulting &lt;code&gt;URI&lt;/code&gt; will end with a slash.</source>
          <target state="translated">在默认提供程序的情况下，URI是带有绝对&lt;a href=&quot;../../net/uri#getPath--&quot;&gt; &lt;code&gt;path&lt;/code&gt; &lt;/a&gt;组件的层次结构。查询和片段组件未定义。权限组件是否已定义取决于实现。无法保证可以使用 &lt;code&gt;URI&lt;/code&gt; 来构造&lt;a href=&quot;../../io/file&quot;&gt; &lt;code&gt;java.io.File&lt;/code&gt; &lt;/a&gt;。特别是，如果此路径表示通用命名约定（UNC）路径，则UNC服务器名称可以编码在所得URI的授权机构中。如果是默认提供程序，并且文件存在，并且可以确定该文件是目录，那么结果 &lt;code&gt;URI&lt;/code&gt; 将以斜杠结尾。</target>
        </trans-unit>
        <trans-unit id="4e1f93856d74c7fdd21e5edb4105cb0eea03c3e1" translate="yes" xml:space="preserve">
          <source>In the case of the default provider, the returned seekable byte channel is a &lt;a href=&quot;../channels/filechannel&quot;&gt;&lt;code&gt;FileChannel&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">对于默认提供程序，返回的可搜索字节通道是&lt;a href=&quot;../channels/filechannel&quot;&gt; &lt;code&gt;FileChannel&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e6297028bcf457506860f8e5340cbccdf1009eaa" translate="yes" xml:space="preserve">
          <source>In the case of the default provider, this method returns the same separator as &lt;a href=&quot;../../io/file#separator&quot;&gt;&lt;code&gt;File.separator&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">对于默认提供程序，此方法返回与&lt;a href=&quot;../../io/file#separator&quot;&gt; &lt;code&gt;File.separator&lt;/code&gt; &lt;/a&gt;相同的分隔符。</target>
        </trans-unit>
        <trans-unit id="3d33ebb7e876e61c518f2ef8d424778898f27226" translate="yes" xml:space="preserve">
          <source>In the case that the variant contains one or more underscores ('_'), a sequence of bundle names generated by truncating the last underscore and the part following it is inserted after a candidate bundle name with the original variant. For example, for a locale with language &quot;en&quot;, script &quot;Latn, country &quot;US&quot; and variant &quot;WINDOWS_VISTA&quot;, and bundle base name &quot;MyResource&quot;, the list of candidate bundle names below is generated:</source>
          <target state="translated">如果变体中包含一个或多个下划线('_'),则会将最后一个下划线及其后面的部分截断后生成的捆绑名称序列插入到带有原始变体的候选捆绑名称之后。例如,对于语言为 &quot;en&quot;,脚本为 &quot;Latn&quot;,国家为 &quot;US&quot;,变体为 &quot;WINDOWS_VISTA&quot;,捆绑包基名为 &quot;MyResource &quot;的locale,就会生成下面的候选捆绑包名称列表。</target>
        </trans-unit>
        <trans-unit id="97ac944d7ca320a7d3a94df81af470a08f017bde" translate="yes" xml:space="preserve">
          <source>In the case where ProcessHandles cannot be supported then the factory methods must consistently throw &lt;a href=&quot;unsupportedoperationexception&quot;&gt;&lt;code&gt;UnsupportedOperationException&lt;/code&gt;&lt;/a&gt;. The methods of this class throw &lt;a href=&quot;unsupportedoperationexception&quot;&gt;&lt;code&gt;UnsupportedOperationException&lt;/code&gt;&lt;/a&gt; if the operating system does not allow access to query or kill a process.</source>
          <target state="translated">在无法支持ProcessHandles的情况下，工厂方法必须一致地抛出&lt;a href=&quot;unsupportedoperationexception&quot;&gt; &lt;code&gt;UnsupportedOperationException&lt;/code&gt; &lt;/a&gt;。如果操作系统不允许访问查询或杀死进程，则此类的方法将引发&lt;a href=&quot;unsupportedoperationexception&quot;&gt; &lt;code&gt;UnsupportedOperationException&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fa5051ebc5f7be9551f7d184b62acf3110ac4cef" translate="yes" xml:space="preserve">
          <source>In the case where a new connection needs to be established, if the connection cannot be established within the given &lt;code&gt;
 duration&lt;/code&gt;, then &lt;a href=&quot;httpclient#send(java.net.http.HttpRequest,java.net.http.HttpResponse.BodyHandler)&quot;&gt;&lt;code&gt;HttpClient::send&lt;/code&gt;&lt;/a&gt; throws an &lt;a href=&quot;httpconnecttimeoutexception&quot;&gt;&lt;code&gt;HttpConnectTimeoutException&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;httpclient#sendAsync(java.net.http.HttpRequest,java.net.http.HttpResponse.BodyHandler)&quot;&gt;&lt;code&gt;HttpClient::sendAsync&lt;/code&gt;&lt;/a&gt; completes exceptionally with an &lt;code&gt;HttpConnectTimeoutException&lt;/code&gt;. If a new connection does not need to be established, for example if a connection can be reused from a previous request, then this timeout duration has no effect.</source>
          <target state="translated">在需要建立新连接的情况下，如果无法在给定的 &lt;code&gt; duration&lt;/code&gt; 内建立连接，则&lt;a href=&quot;httpclient#send(java.net.http.HttpRequest,java.net.http.HttpResponse.BodyHandler)&quot;&gt; &lt;code&gt;HttpClient::send&lt;/code&gt; &lt;/a&gt;抛出&lt;a href=&quot;httpconnecttimeoutexception&quot;&gt; &lt;code&gt;HttpConnectTimeoutException&lt;/code&gt; &lt;/a&gt;，或者&lt;a href=&quot;httpclient#sendAsync(java.net.http.HttpRequest,java.net.http.HttpResponse.BodyHandler)&quot;&gt; &lt;code&gt;HttpClient::sendAsync&lt;/code&gt; &lt;/a&gt;异常完成并带有 &lt;code&gt;HttpConnectTimeoutException&lt;/code&gt; 。如果不需要建立新的连接，例如，如果可以从先前的请求中重用连接，则此超时持续时间无效。</target>
        </trans-unit>
        <trans-unit id="52c38dad2c1d9a6ad351c582c8369d290f1b4496" translate="yes" xml:space="preserve">
          <source>In the case where end of stream is reached before &lt;code&gt;len&lt;/code&gt; bytes have been read, then the actual number of bytes read will be returned. When this stream reaches end of stream, further invocations of this method will return zero.</source>
          <target state="translated">如果在读取 &lt;code&gt;len&lt;/code&gt; 个字节之前已到达流的末尾，则将返回读取的实际字节数。当此流到达流的末尾时，对该方法的进一步调用将返回零。</target>
        </trans-unit>
        <trans-unit id="b7b93472fb0fb86fea81d8d8443ed8bdc46acd42" translate="yes" xml:space="preserve">
          <source>In the case where multiple LoginModules fail, this method propagates the exception raised by the first &lt;code&gt;LoginModule&lt;/code&gt; which failed.</source>
          <target state="translated">在多个LoginModule失败的情况下，此方法传播第一个失败的 &lt;code&gt;LoginModule&lt;/code&gt; 引发的异常。</target>
        </trans-unit>
        <trans-unit id="a70c45e6aeb095e66dfd74054e5938ceea08a232" translate="yes" xml:space="preserve">
          <source>In the common case, all of the pre-connection parameters and general request properties can be ignored: the pre-connection parameters and request properties default to sensible values. For most clients of this interface, there are only two interesting methods: &lt;code&gt;getInputStream&lt;/code&gt; and &lt;code&gt;getContent&lt;/code&gt;, which are mirrored in the &lt;code&gt;URL&lt;/code&gt; class by convenience methods.</source>
          <target state="translated">在通常情况下，所有预连接参数和常规请求属性都可以忽略：预连接参数和请求属性默认为明智的值。对于此接口的大多数客户端，只有两种有趣的方法： &lt;code&gt;getInputStream&lt;/code&gt; 和 &lt;code&gt;getContent&lt;/code&gt; ，它们是通过便捷方法在 &lt;code&gt;URL&lt;/code&gt; 类中进行镜像的。</target>
        </trans-unit>
        <trans-unit id="fc4e72373a72929421b52e76471660916eb25cad" translate="yes" xml:space="preserve">
          <source>In the context of &lt;a href=&quot;../../../annotation/processing/processingenvironment&quot;&gt;annotation processing&lt;/a&gt;, the guarantees for &quot;the same&quot; implementation must include contexts where the &lt;a href=&quot;../../../annotation/processing/package-summary&quot;&gt;API mediated&lt;/a&gt; side effects of &lt;a href=&quot;../../../annotation/processing/processor&quot;&gt;processors&lt;/a&gt; could be visible to each other, including successive annotation processing &lt;a href=&quot;../../../annotation/processing/roundenvironment&quot;&gt;rounds&lt;/a&gt;.</source>
          <target state="translated">在&lt;a href=&quot;../../../annotation/processing/processingenvironment&quot;&gt;注释处理&lt;/a&gt;的上下文中，对&amp;ldquo;相同&amp;rdquo;实现的保证必须包括上下文，在该上下文中，&lt;a href=&quot;../../../annotation/processing/package-summary&quot;&gt;API介导&lt;/a&gt;的&lt;a href=&quot;../../../annotation/processing/processor&quot;&gt;处理器&lt;/a&gt;副作用可能彼此可见，包括连续的注释处理&lt;a href=&quot;../../../annotation/processing/roundenvironment&quot;&gt;回合&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="47f91444a15f2bda2fa6d35d205ab3bb0e17ca5f" translate="yes" xml:space="preserve">
          <source>In the context of a &lt;code&gt;StAXResult&lt;/code&gt;, it is not appropriate to explicitly set the system identifier.</source>
          <target state="translated">在 &lt;code&gt;StAXResult&lt;/code&gt; 的上下文中，显式设置系统标识符是不合适的。</target>
        </trans-unit>
        <trans-unit id="bf720f95058f2decf42fefd32a1e2515dafa3d6f" translate="yes" xml:space="preserve">
          <source>In the context of a &lt;code&gt;StAXResult&lt;/code&gt;, it is not appropriate to explicitly set the system identifier. The &lt;code&gt;XMLEventWriter&lt;/code&gt; or &lt;code&gt;XMLStreamWriter&lt;/code&gt; used to construct this &lt;code&gt;StAXResult&lt;/code&gt; determines the system identifier of the XML result.</source>
          <target state="translated">在 &lt;code&gt;StAXResult&lt;/code&gt; 的上下文中，显式设置系统标识符是不合适的。用于构造此 &lt;code&gt;StAXResult&lt;/code&gt; 的 &lt;code&gt;XMLEventWriter&lt;/code&gt; 或 &lt;code&gt;XMLStreamWriter&lt;/code&gt; 确定XML结果的系统标识符。</target>
        </trans-unit>
        <trans-unit id="d34a9a5234275a7027509815264f773e5a1e5697" translate="yes" xml:space="preserve">
          <source>In the context of a &lt;code&gt;StAXSource&lt;/code&gt;, it is not appropriate to explicitly set the system identifier.</source>
          <target state="translated">在 &lt;code&gt;StAXSource&lt;/code&gt; 的上下文中，显式设置系统标识符是不合适的。</target>
        </trans-unit>
        <trans-unit id="7a373946bb662d5a2a82c9ba24e1f7f6ecff6794" translate="yes" xml:space="preserve">
          <source>In the context of a &lt;code&gt;StAXSource&lt;/code&gt;, it is not appropriate to explicitly set the system identifier. The &lt;code&gt;XMLStreamReader&lt;/code&gt; or &lt;code&gt;XMLEventReader&lt;/code&gt; used to construct this &lt;code&gt;StAXSource&lt;/code&gt; determines the system identifier of the XML source.</source>
          <target state="translated">在 &lt;code&gt;StAXSource&lt;/code&gt; 的上下文中，显式设置系统标识符是不合适的。用于构造此 &lt;code&gt;StAXSource&lt;/code&gt; 的 &lt;code&gt;XMLStreamReader&lt;/code&gt; 或 &lt;code&gt;XMLEventReader&lt;/code&gt; 确定XML源的系统标识符。</target>
        </trans-unit>
        <trans-unit id="b0fc226575948bc5d8749aeade7f2700d90dccef" translate="yes" xml:space="preserve">
          <source>In the default &lt;a href=&quot;threadpoolexecutor.abortpolicy&quot;&gt;&lt;code&gt;ThreadPoolExecutor.AbortPolicy&lt;/code&gt;&lt;/a&gt;, the handler throws a runtime &lt;a href=&quot;rejectedexecutionexception&quot;&gt;&lt;code&gt;RejectedExecutionException&lt;/code&gt;&lt;/a&gt; upon rejection.</source>
          <target state="translated">在默认的&lt;a href=&quot;threadpoolexecutor.abortpolicy&quot;&gt; &lt;code&gt;ThreadPoolExecutor.AbortPolicy&lt;/code&gt; 中&lt;/a&gt;，处理程序在拒绝时会抛出运行时&lt;a href=&quot;rejectedexecutionexception&quot;&gt; &lt;code&gt;RejectedExecutionException&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="48bb0c8e4f3b335269acf6c1e788fce51afc4c47" translate="yes" xml:space="preserve">
          <source>In the default ISO calendar system, June 2012 would have the value &lt;code&gt;(2012 * 12 + 6 - 1)&lt;/code&gt;. This field is primarily for internal use.</source>
          <target state="translated">在默认的ISO日历系统中，2012年6月将具有值 &lt;code&gt;(2012 * 12 + 6 - 1)&lt;/code&gt; 。该字段主要供内部使用。</target>
        </trans-unit>
        <trans-unit id="e85a59438f2ed3bcea699be96233c620667aa495" translate="yes" xml:space="preserve">
          <source>In the default ISO calendar system, there are two eras defined, 'BCE' and 'CE'. The era 'CE' is the one currently in use and year-of-era runs from 1 to the maximum value. The era 'BCE' is the previous era, and the year-of-era runs backwards.</source>
          <target state="translated">在默认的ISO日历系统中,定义了两个时代,&quot;BCE &quot;和 &quot;CE&quot;。年代'CE'是当前使用的年代,年代的年份从1到最大值。年代'BCE'是以前的年代,年代年份向后运行。</target>
        </trans-unit>
        <trans-unit id="0553d6dc2b136e33c3dc86748155cb284b375b0b" translate="yes" xml:space="preserve">
          <source>In the default ISO calendar system, there are two eras defined, 'BCE' and 'CE'. The era 'CE' is the one currently in use and year-of-era runs from 1 to the maximum value. The era 'BCE' is the previous era, and the year-of-era runs backwards. See &lt;a href=&quot;#YEAR_OF_ERA&quot;&gt;&lt;code&gt;YEAR_OF_ERA&lt;/code&gt;&lt;/a&gt; for a full example.</source>
          <target state="translated">在默认的ISO日历系统中，定义了两个时代，即&amp;ldquo; BCE&amp;rdquo;和&amp;ldquo; CE&amp;rdquo;。&amp;ldquo; CE&amp;rdquo;时代是当前正在使用的时代，年龄从1到最大值。&amp;ldquo;公元前&amp;rdquo;时代是前一个时代，而年代则倒退了。有关完整示例，请参见&lt;a href=&quot;#YEAR_OF_ERA&quot;&gt; &lt;code&gt;YEAR_OF_ERA&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b2989432ae07e543d739ca5a5f8fcc5927ec8aa7" translate="yes" xml:space="preserve">
          <source>In the default ISO calendar system, there are two eras defined, 'BCE' and 'CE'. The era 'CE' is the one currently in use and year-of-era runs from 1 to the maximum value. The era 'BCE' is the previous era, and the year-of-era runs backwards. See &lt;a href=&quot;chronofield#YEAR_OF_ERA&quot;&gt;&lt;code&gt;YEAR_OF_ERA&lt;/code&gt;&lt;/a&gt; for a full example.</source>
          <target state="translated">在默认的ISO日历系统中，定义了两个时代，即&amp;ldquo; BCE&amp;rdquo;和&amp;ldquo; CE&amp;rdquo;。&amp;ldquo; CE&amp;rdquo;时代是当前正在使用的时代，年龄从1到最大值。&amp;ldquo;公元前&amp;rdquo;时代是前一个时代，这一年倒退了。有关完整示例，请参见&lt;a href=&quot;chronofield#YEAR_OF_ERA&quot;&gt; &lt;code&gt;YEAR_OF_ERA&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bd780fa87d177f6d0024f4d49192abdd1c6c63cd" translate="yes" xml:space="preserve">
          <source>In the definitions below, an annotation</source>
          <target state="translated">在下面的定义中,一个注解</target>
        </trans-unit>
        <trans-unit id="09bc6c63a67020bf7c2978262bc3265e74344acb" translate="yes" xml:space="preserve">
          <source>In the detailed explanations below, if &quot;&lt;code&gt;a&lt;/code&gt;&quot; represents an instance of document data, then the result of processing the data in document &quot;&lt;code&gt;a&lt;/code&gt;&quot; is a sequence of media sheets represented by &quot;&lt;code&gt;a(*)&lt;/code&gt;&quot;.</source>
          <target state="translated">在下面的详细说明中，如果&amp;ldquo; &lt;code&gt;a&lt;/code&gt; &amp;rdquo;表示文档数据的实例，则在文档&amp;ldquo; &lt;code&gt;a&lt;/code&gt; &amp;rdquo; 中处理数据的结果是由&amp;ldquo; &lt;code&gt;a(*)&lt;/code&gt; &amp;rdquo; 表示的一系列介质薄片。</target>
        </trans-unit>
        <trans-unit id="b6d9e5dc1f809175b0e42391ea9e37c40c1951ed" translate="yes" xml:space="preserve">
          <source>In the documentation for a constructor.</source>
          <target state="translated">在一个构造函数的文档中。</target>
        </trans-unit>
        <trans-unit id="80b8312a0fbbad96b4c2ebfe23bc26532a9f5ab5" translate="yes" xml:space="preserve">
          <source>In the documentation for a field.</source>
          <target state="translated">在某一领域的文件中:</target>
        </trans-unit>
        <trans-unit id="3868e8bb7921c86e225142d68cd3af17d23c1a97" translate="yes" xml:space="preserve">
          <source>In the documentation for a method.</source>
          <target state="translated">在一个方法的文件中:</target>
        </trans-unit>
        <trans-unit id="e7541a4cccb8fb8e628efa6347d5e77754a8e242" translate="yes" xml:space="preserve">
          <source>In the documentation for a module.</source>
          <target state="translated">在一个模块的文件中:</target>
        </trans-unit>
        <trans-unit id="c6b6efbfbb2bad2589c323fdc9f281678d69cb36" translate="yes" xml:space="preserve">
          <source>In the documentation for a package.</source>
          <target state="translated">在一个包的文档中。</target>
        </trans-unit>
        <trans-unit id="c97eab382f09819781526a1957fea3b2b6108ab2" translate="yes" xml:space="preserve">
          <source>In the documentation for a type, such as a class, interface or enum.</source>
          <target state="translated">在一个类型的文档中,如类、接口或枚举。</target>
        </trans-unit>
        <trans-unit id="b0f79dec8b3ab7b6c24fbe11e1ac1e7891ecced8" translate="yes" xml:space="preserve">
          <source>In the event that multiple package defaults apply to a given class, the package default pertaining to the most specific package takes precedence over the others. For example, if &lt;code&gt;javax.lang&lt;/code&gt; and &lt;code&gt;javax.lang.reflect&lt;/code&gt; both have package defaults associated with them, the latter package default applies to classes in &lt;code&gt;javax.lang.reflect&lt;/code&gt;.</source>
          <target state="translated">如果多个包默认值适用于给定的类，则与最具体的包有关的包默认值优先于其他包。例如，如果 &lt;code&gt;javax.lang&lt;/code&gt; 和 &lt;code&gt;javax.lang.reflect&lt;/code&gt; 都具有与之关联的程序包默认值，则后者的程序包默认值适用于 &lt;code&gt;javax.lang.reflect&lt;/code&gt; 中的类。</target>
        </trans-unit>
        <trans-unit id="9e8bb46a346e88375edb24d85374a9154807145b" translate="yes" xml:space="preserve">
          <source>In the event that the plugin is provided as part of a named module, that module must export the package containing the implementation class to the</source>
          <target state="translated">如果插件是作为一个命名模块的一部分提供的,该模块必须将包含实现类的包导出到</target>
        </trans-unit>
        <trans-unit id="be93f24cde87a11bdd29fa572b15cfd5ab339a32" translate="yes" xml:space="preserve">
          <source>In the event that the user does not set the first keyframe value equal to 0 and/or the last keyframe value equal to 1, keyframes will be created at these positions and the first and last colors will be replicated there. So, if a user specifies the following arrays to construct a gradient:</source>
          <target state="translated">如果用户没有将第一个关键帧的值设为0和/或最后一个关键帧的值设为1,则会在这些位置创建关键帧,并在那里复制第一个和最后一个颜色。因此,如果用户指定以下数组来构建渐变。</target>
        </trans-unit>
        <trans-unit id="6464a7e6bb699eb4c5f67dfb7579ab5520cb8ff9" translate="yes" xml:space="preserve">
          <source>In the example above, a keystore file called &quot;testkeys&quot;, created with the keytool utility is used as a certificate store for client and server certificates. The following code shows how the SSLContext is then used in a HttpsConfigurator and how the SSLContext and HttpsConfigurator are linked to the HttpsServer.</source>
          <target state="translated">在上面的例子中,用keytool工具创建的名为 &quot;testkeys &quot;的keystore文件被用作客户端和服务器证书的证书存储。下面的代码显示了SSLContext如何在HttpsConfigurator中使用,以及SSLContext和HttpsConfigurator如何链接到HttpsServer。</target>
        </trans-unit>
        <trans-unit id="00fd509d5a993973e1038d029ec2399af029eb1f" translate="yes" xml:space="preserve">
          <source>In the example above, we initialize a &lt;code&gt;Range&lt;/code&gt; object which implements the &lt;code&gt;Predicate&lt;/code&gt; interface. This object expresses the following constraints: All rows outputted or modified from this &lt;code&gt;FilteredRowSet&lt;/code&gt; object must fall between the values 'Alpha' and 'Bravo' both values inclusive, in the column 'columnName'. If a filter is applied to a &lt;code&gt;FilteredRowSet&lt;/code&gt; object that contains no data that falls within the range of the filter, no rows are returned.</source>
          <target state="translated">在上面的示例中，我们初始化了一个 &lt;code&gt;Range&lt;/code&gt; 对象，该对象实现了 &lt;code&gt;Predicate&lt;/code&gt; 接口。该对象表示以下约束：从此 &lt;code&gt;FilteredRowSet&lt;/code&gt; 对象输出或修改的所有行都必须位于列'columnName'中的值'Alpha'和'Bravo'之间（包括两个值）。如果将筛选器应用于不包含该筛选器范围内的数据的 &lt;code&gt;FilteredRowSet&lt;/code&gt; 对象，则不会返回任何行。</target>
        </trans-unit>
        <trans-unit id="d1500759c4854f4c300acd35e9ef7742f5686f96" translate="yes" xml:space="preserve">
          <source>In the example below, the reference &lt;code&gt;CachedRowSetImpl&lt;/code&gt; implementation reconfigures its current &lt;code&gt;SyncProvider&lt;/code&gt; object by calling the &lt;code&gt;setSyncProvider&lt;/code&gt; method.</source>
          <target state="translated">在下面的示例中，引用 &lt;code&gt;CachedRowSetImpl&lt;/code&gt; 实现通过调用 &lt;code&gt;setSyncProvider&lt;/code&gt; 方法来重新配置其当前的 &lt;code&gt;SyncProvider&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="05277234739d6763969157714d95b5b473c13a38" translate="yes" xml:space="preserve">
          <source>In the example, if the content of a document is the sequence &quot;The quick brown fox,&quot; as shown in the preceding diagram, the location just before the word &quot;The&quot; is 0, and the location after the word &quot;The&quot; and before the whitespace that follows it is 3. The entire sequence of characters in the sequence &quot;The&quot; is called a &lt;em&gt;range&lt;/em&gt;.</source>
          <target state="translated">在此示例中，如果文档的内容是序列&amp;ldquo; The quick brown fox&amp;rdquo;，如上图所示，则单词&amp;ldquo; The&amp;rdquo;之前的位置为0，单词&amp;ldquo; The&amp;rdquo;之后和之前的位置紧跟其后的空白是3。序列&amp;ldquo; The&amp;rdquo;中的整个字符序列称为&lt;em&gt;range&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="b8e11d48b9526227594c6c159985f8ef09465796" translate="yes" xml:space="preserve">
          <source>In the figure, the first index (0) corresponds to the first column, the second index (1) to the second column, and so on. The first column's position starts at 0, and the column occupies &lt;em&gt;size&lt;sub&gt;0&lt;/sub&gt;&lt;/em&gt; pixels, where &lt;em&gt;size&lt;sub&gt;0&lt;/sub&gt;&lt;/em&gt; is the value returned by &lt;code&gt;getSize(0)&lt;/code&gt;. Thus, the first column ends at &lt;em&gt;size&lt;sub&gt;0&lt;/sub&gt;&lt;/em&gt; - 1. The second column then begins at the position &lt;em&gt;size&lt;sub&gt;0&lt;/sub&gt;&lt;/em&gt; and occupies &lt;em&gt;size&lt;sub&gt;1&lt;/sub&gt;&lt;/em&gt; (&lt;code&gt;getSize(1)&lt;/code&gt;) pixels.</source>
          <target state="translated">在图中，第一个索引（0）对应于第一列，第二个索引（1）对应于第二列，依此类推。第一列的位置从0开始，并且该列占用&lt;em&gt;大小&lt;sub&gt;0&lt;/sub&gt;&lt;/em&gt;像素，其中&lt;em&gt;大小&lt;sub&gt;0&lt;/sub&gt;&lt;/em&gt;是 &lt;code&gt;getSize(0)&lt;/code&gt; 返回的值。因此，第一列的&lt;em&gt;大小为&lt;sub&gt;0-1&lt;/sub&gt;&lt;/em&gt;。然后第二列的位置为&lt;em&gt;大小&lt;sub&gt;0，&lt;/sub&gt;&lt;/em&gt;并占据&lt;em&gt;大小为&lt;sub&gt;1&lt;/sub&gt;&lt;/em&gt;（ &lt;code&gt;getSize(1)&lt;/code&gt; ）像素。</target>
        </trans-unit>
        <trans-unit id="497f116b21347428eb7a6e8312ca399ca290624a" translate="yes" xml:space="preserve">
          <source>In the final case, it is exactly as if the target method handle were temporarily adapted with a &lt;a href=&quot;#asCollector(java.lang.Class,int)&quot;&gt;fixed arity collector&lt;/a&gt; to the arity required by the caller type. (As with &lt;code&gt;asCollector&lt;/code&gt;, if the array length is zero, a shared constant may be used instead of a new array. If the implied call to &lt;code&gt;asCollector&lt;/code&gt; would throw an &lt;code&gt;IllegalArgumentException&lt;/code&gt; or &lt;code&gt;WrongMethodTypeException&lt;/code&gt;, the call to the variable arity adapter must throw &lt;code&gt;WrongMethodTypeException&lt;/code&gt;.)</source>
          <target state="translated">在最后一种情况下，就好像目标方法句柄是使用&lt;a href=&quot;#asCollector(java.lang.Class,int)&quot;&gt;固定的Arity收集器&lt;/a&gt;临时适应了调用者类型所需的Arity一样。（与 &lt;code&gt;asCollector&lt;/code&gt; 一样，如果数组长度为零，则可以使用共享常量而不是新数组。如果对 &lt;code&gt;asCollector&lt;/code&gt; 的隐式调用将引发 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 或 &lt;code&gt;WrongMethodTypeException&lt;/code&gt; ，则对变量arity适配器的调用必须引发 &lt;code&gt;WrongMethodTypeException&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="6debf46fe39f4012b9544dd84da9e6f547b36977" translate="yes" xml:space="preserve">
          <source>In the final case, it is exactly as if the target method handle were temporarily adapted with a &lt;a href=&quot;methodhandle#asCollector-java.lang.Class-int-&quot;&gt;fixed arity collector&lt;/a&gt; to the arity required by the caller type. (As with &lt;code&gt;asCollector&lt;/code&gt;, if the array length is zero, a shared constant may be used instead of a new array. If the implied call to &lt;code&gt;asCollector&lt;/code&gt; would throw an &lt;code&gt;IllegalArgumentException&lt;/code&gt; or &lt;code&gt;WrongMethodTypeException&lt;/code&gt;, the call to the variable arity adapter must throw &lt;code&gt;WrongMethodTypeException&lt;/code&gt;.)</source>
          <target state="translated">在最后一种情况下，就好像目标方法句柄是使用&lt;a href=&quot;methodhandle#asCollector-java.lang.Class-int-&quot;&gt;固定的Arity收集器&lt;/a&gt;临时适应了调用者类型所需的Arity一样。 （与 &lt;code&gt;asCollector&lt;/code&gt; 一样，如果数组长度为零，则可以使用共享常量而不是新数组。如果对 &lt;code&gt;asCollector&lt;/code&gt; 的隐式调用将引发 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 或 &lt;code&gt;WrongMethodTypeException&lt;/code&gt; ，则对变量arity适配器的调用必须引发 &lt;code&gt;WrongMethodTypeException&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="0b39f33db050daf5a8b13214fd8a45e5e32089c0" translate="yes" xml:space="preserve">
          <source>In the first case the global color table in the stream metadata is used, in the second the local color table in the image metadata is used, and in the third a global color table is created from the ColorModel or SampleModel of the (first) image.</source>
          <target state="translated">在第一种情况下,使用流元数据中的全局颜色表,在第二种情况下,使用图像元数据中的局部颜色表,在第三种情况下,从(第一)图像的ColorModel或SampleModel创建一个全局颜色表。</target>
        </trans-unit>
        <trans-unit id="13e8476783a96421ed140a44cbc492ba23ff9c6b" translate="yes" xml:space="preserve">
          <source>In the first form, the methods defined by the &lt;a href=&quot;../../util/concurrent/future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; interface may be used to check if the operation has completed, wait for its completion, and to retrieve the result. In the second form, a &lt;a href=&quot;completionhandler&quot;&gt;&lt;code&gt;CompletionHandler&lt;/code&gt;&lt;/a&gt; is invoked to consume the result of the I/O operation when it completes or fails.</source>
          <target state="translated">在第一种形式中，&lt;a href=&quot;../../util/concurrent/future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt;接口定义的方法可用于检查操作是否已完成，等待操作完成并检索结果。在第二种形式中，当&lt;a href=&quot;completionhandler&quot;&gt; &lt;code&gt;CompletionHandler&lt;/code&gt; &lt;/a&gt;完成或失败时，将调用它来消耗I / O操作的结果。</target>
        </trans-unit>
        <trans-unit id="3f3a74e19b90c7de60244c50e295be122becdcae" translate="yes" xml:space="preserve">
          <source>In the following code fragment, the table &lt;code&gt;EMPLOYEES&lt;/code&gt;, whose match column is set to the first column (&lt;code&gt;EMP_ID&lt;/code&gt;), is added to the &lt;code&gt;JoinRowSet&lt;/code&gt; object</source>
          <target state="translated">在下面的代码片段中，将其match列设置为第一列（ &lt;code&gt;EMP_ID&lt;/code&gt; ）的表 &lt;code&gt;EMPLOYEES&lt;/code&gt; 添加到 &lt;code&gt;JoinRowSet&lt;/code&gt; 对象中</target>
        </trans-unit>
        <trans-unit id="ae14c7e2717e4399f35c3ed2c4bc1bb7e0a3378a" translate="yes" xml:space="preserve">
          <source>In the following example of setting a parameter, &lt;code&gt;con&lt;/code&gt; represents an active connection:</source>
          <target state="translated">在以下设置参数的示例中， &lt;code&gt;con&lt;/code&gt; 表示活动连接：</target>
        </trans-unit>
        <trans-unit id="b99e380dc2e8d3b1db4402535306cb8216227f20" translate="yes" xml:space="preserve">
          <source>In the following example, a transaction event is defined with two user-defined annotations, &lt;code&gt;@Severity&lt;/code&gt; and &lt;code&gt;@TransactionId&lt;/code&gt;.</source>
          <target state="translated">在以下示例中，使用两个用户定义的注释 &lt;code&gt;@Severity&lt;/code&gt; 和 &lt;code&gt;@TransactionId&lt;/code&gt; 定义了事务事件。</target>
        </trans-unit>
        <trans-unit id="fe00899315524b658035f51f874a90b5e72b844e" translate="yes" xml:space="preserve">
          <source>In the following example, the program prints a histogram of all method samples in a recording.</source>
          <target state="translated">在下面的例子中,程序打印了记录中所有方法样本的直方图。</target>
        </trans-unit>
        <trans-unit id="8831d20c4571848af5234f8bd06f8194e229c8bb" translate="yes" xml:space="preserve">
          <source>In the following sample:</source>
          <target state="translated">在下面的样本中:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
