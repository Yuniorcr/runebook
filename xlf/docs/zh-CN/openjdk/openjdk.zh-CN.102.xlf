<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="openjdk">
    <body>
      <group id="openjdk">
        <trans-unit id="d3fe3fca46a00d556efb3e52ff334ccc25f6d2f2" translate="yes" xml:space="preserve">
          <source>If set, the last access time will be stored into the extended timestamp fields of entry's &lt;code&gt;optional extra data&lt;/code&gt;, when output to a ZIP file or ZIP file formatted stream.</source>
          <target state="translated">如果设置，则最后一次访问时间在输出到ZIP文件或ZIP文件格式的流时，将存储到条目的 &lt;code&gt;optional extra data&lt;/code&gt; 的扩展时间戳字段中。</target>
        </trans-unit>
        <trans-unit id="8f308d30cc56ad52b3bab469509470a688175d5d" translate="yes" xml:space="preserve">
          <source>If several threads simultaneously execute a bootstrap method for a single dynamic call site, the JVM must choose one &lt;code&gt;CallSite&lt;/code&gt; object and install it visibly to all threads. Any other bootstrap method calls are allowed to complete, but their results are ignored, and their dynamic call site invocations proceed with the originally chosen target object.</source>
          <target state="translated">如果多个线程同时为一个动态调用站点执行引导程序方法，则JVM必须选择一个 &lt;code&gt;CallSite&lt;/code&gt; 对象并将其可视地安装到所有线程。任何其他引导方法调用都可以完成，但是其结果将被忽略，并且它们的动态调用站点调用将以最初选择的目标对象进行。</target>
        </trans-unit>
        <trans-unit id="18b1b4b5ea1cd9ac6c8f6934c943af5a9030e95e" translate="yes" xml:space="preserve">
          <source>If several threads simultaneously execute a bootstrap method for a single dynamically-computed call site or constant, the JVM must choose one bootstrap method result and install it visibly to all threads. Any other bootstrap method calls are allowed to complete, but their results are ignored.</source>
          <target state="translated">如果几个线程同时执行一个动态计算的调用站点或常量的引导方法,JVM必须选择一个引导方法结果,并将其明显地安装到所有线程中。任何其他的引导方法调用都被允许完成,但它们的结果会被忽略。</target>
        </trans-unit>
        <trans-unit id="653e73bbef0b2a0664fc9c6111cdb7e33befdd39" translate="yes" xml:space="preserve">
          <source>If simply changing the name of the given node is not possible, the following operations are performed: a new node is created, any registered event listener is registered on the new node, any user data attached to the old node is removed from that node, the old node is removed from its parent if it has one, the children are moved to the new node, if the renamed node is an &lt;code&gt;Element&lt;/code&gt; its attributes are moved to the new node, the new node is inserted at the position the old node used to have in its parent's child nodes list if it has one, the user data that was attached to the old node is attached to the new node.</source>
          <target state="translated">如果无法简单地更改给定节点的名称，则执行以下操作：创建一个新节点，在该新节点上注册所有已注册的事件侦听器，从该节点上删除附加到旧节点的任何用户数据，如果旧节点有其父节点，则将其从其父节点中移除，将子节点移至新节点，如果重命名的节点为 &lt;code&gt;Element&lt;/code&gt; ，则将其属性移至新节点，则将新节点插入到旧节点使用的位置如果要在其父级的子节点列表中包含一个，则附加到旧节点的用户数据将附加到新节点。</target>
        </trans-unit>
        <trans-unit id="d7c65182d3cadba09ddb23fbbd8a75757afd7c8e" translate="yes" xml:space="preserve">
          <source>If size requirements are explicitly specified for the paragraph, use that requirements. Otherwise, use the requirements of the superclass &lt;a href=&quot;../paragraphview&quot;&gt;&lt;code&gt;ParagraphView&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果为该段明确指定了尺寸要求，请使用该要求。否则，请使用超类&lt;a href=&quot;../paragraphview&quot;&gt; &lt;code&gt;ParagraphView&lt;/code&gt; &lt;/a&gt;的要求。</target>
        </trans-unit>
        <trans-unit id="a30312a3ee2ee2f769f60fddc7aed8e6e676a91e" translate="yes" xml:space="preserve">
          <source>If so, the SQL AS clause can be used to provide names for computed columns or to provide alias names for columns as required.</source>
          <target state="translated">如果是这样,可以使用SQL AS子句为计算列提供名称,或者根据需要为列提供别名。</target>
        </trans-unit>
        <trans-unit id="3080743f4d15c8fc1f75465fc6801e428e44fe7c" translate="yes" xml:space="preserve">
          <source>If some listeners have been added with a named property, then the returned array will be a mixture of PropertyChangeListeners and &lt;code&gt;PropertyChangeListenerProxy&lt;/code&gt;s. If the calling method is interested in distinguishing the listeners then it must test each element to see if it's a &lt;code&gt;PropertyChangeListenerProxy&lt;/code&gt;, perform the cast, and examine the parameter.</source>
          <target state="translated">如果添加了带有命名属性的某些侦听器，则返回的数组将是PropertyChangeListeners和 &lt;code&gt;PropertyChangeListenerProxy&lt;/code&gt; 的混合。如果调用方法有兴趣区分侦听器，则它必须测试每个元素以查看它是否是 &lt;code&gt;PropertyChangeListenerProxy&lt;/code&gt; ，执行强制转换并检查参数。</target>
        </trans-unit>
        <trans-unit id="6cf497c1785865189fe796ed0e1d220915d011be" translate="yes" xml:space="preserve">
          <source>If some listeners have been added with a named property, then the returned array will be a mixture of VetoableChangeListeners and &lt;code&gt;VetoableChangeListenerProxy&lt;/code&gt;s. If the calling method is interested in distinguishing the listeners then it must test each element to see if it's a &lt;code&gt;VetoableChangeListenerProxy&lt;/code&gt;, perform the cast, and examine the parameter.</source>
          <target state="translated">如果添加了具有命名属性的某些侦听器，则返回的数组将是VetoableChangeListeners和 &lt;code&gt;VetoableChangeListenerProxy&lt;/code&gt; 的混合。如果调用方法有兴趣区分侦听器，则它必须测试每个元素以查看它是否是 &lt;code&gt;VetoableChangeListenerProxy&lt;/code&gt; ，执行强制转换并检查参数。</target>
        </trans-unit>
        <trans-unit id="0cc3c7dd73763675362089e6dbd76aa79687340e" translate="yes" xml:space="preserve">
          <source>If some of the clause functions are virtual methods on an instance, the instance itself can be conveniently placed in an initial invariant loop &quot;variable&quot;, using an initial clause like &lt;code&gt;new MethodHandle[]{identity(ObjType.class)}&lt;/code&gt;. In that case, the instance reference will be the first iteration variable value, and it will be easy to use virtual methods as clause parts, since all of them will take a leading instance reference matching that value.</source>
          <target state="translated">如果某些子句函数是实例上的虚方法，则可以使用诸如 &lt;code&gt;new MethodHandle[]{identity(ObjType.class)}&lt;/code&gt; 类的初始子句将实例本身方便地放置在初始不变循环&amp;ldquo;变量&amp;rdquo;中。在这种情况下，实例引用将是第一个迭代变量值，并且将虚拟方法用作子句部分会很容易，因为它们都将采用与该值匹配的前导实例引用。</target>
        </trans-unit>
        <trans-unit id="4809b1b1dafea4dfced97329f0d27180c7e418e7" translate="yes" xml:space="preserve">
          <source>If some other window is already always-on-top then the relative order between these windows is unspecified (depends on platform). No window can be brought to be over the always-on-top window except maybe another always-on-top window.</source>
          <target state="translated">如果其他窗口已经在顶部了,那么这些窗口之间的相对顺序是不确定的(取决于平台)。除了另一个总是在顶部的窗口外,没有任何窗口可以被置于总是在顶部的窗口之上。</target>
        </trans-unit>
        <trans-unit id="9c852ab67f6ae0af547293dc6511f0705244b787" translate="yes" xml:space="preserve">
          <source>If specified, these insets act as padding around the cell renderer when laying out and painting the &quot;selected&quot; item in the combo box.</source>
          <target state="translated">如果指定了,在布局和绘制组合框中的 &quot;选定 &quot;项目时,这些插页将作为单元格渲染器周围的填充物。</target>
        </trans-unit>
        <trans-unit id="5a8e20a8b6edf9f99ddfa05066dd30cd8c55b9b1" translate="yes" xml:space="preserve">
          <source>If specified, these insets act as padding around the cell renderer when laying out and painting the &quot;selected&quot; item in the combo box. These insets add to those specified by the cell renderer.</source>
          <target state="translated">如果指定了,当在组合框中布局和绘制 &quot;选定 &quot;项目时,这些插页作为单元格渲染器周围的填充物。这些插页会添加到单元格渲染器指定的插页中。</target>
        </trans-unit>
        <trans-unit id="a5c010eef59c15644a375468c16c24a59e5c43de" translate="yes" xml:space="preserve">
          <source>If starting any of the processes throws an Exception, all processes are forcibly destroyed.</source>
          <target state="translated">如果启动任何一个进程都会引发异常,那么所有进程都会被强制销毁。</target>
        </trans-unit>
        <trans-unit id="ee377394ee6fe11a94b05880ae8a4e56e23eb11b" translate="yes" xml:space="preserve">
          <source>If state is &lt;a href=&quot;cardterminals.state#ALL&quot;&gt;&lt;code&gt;State.ALL&lt;/code&gt;&lt;/a&gt;, this method returns all CardTerminals encapsulated by this object. If state is &lt;a href=&quot;cardterminals.state#CARD_PRESENT&quot;&gt;&lt;code&gt;State.CARD_PRESENT&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;cardterminals.state#CARD_ABSENT&quot;&gt;&lt;code&gt;State.CARD_ABSENT&lt;/code&gt;&lt;/a&gt;, it returns all CardTerminals where a card is currently present or absent, respectively.</source>
          <target state="translated">如果state为&lt;a href=&quot;cardterminals.state#ALL&quot;&gt; &lt;code&gt;State.ALL&lt;/code&gt; &lt;/a&gt;，则此方法返回此对象封装的所有CardTerminals。如果state为&lt;a href=&quot;cardterminals.state#CARD_PRESENT&quot;&gt; &lt;code&gt;State.CARD_PRESENT&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;cardterminals.state#CARD_ABSENT&quot;&gt; &lt;code&gt;State.CARD_ABSENT&lt;/code&gt; &lt;/a&gt;，则分别返回当前存在或不存在卡的所有CardTerminal。</target>
        </trans-unit>
        <trans-unit id="97e2c677edafae44cb499869bec55d8b0b28cb2c" translate="yes" xml:space="preserve">
          <source>If state is &lt;a href=&quot;cardterminals.state#CARD_INSERTION&quot;&gt;&lt;code&gt;State.CARD_INSERTION&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;cardterminals.state#CARD_REMOVAL&quot;&gt;&lt;code&gt;State.CARD_REMOVAL&lt;/code&gt;&lt;/a&gt;, it returns all CardTerminals for which an insertion (or removal, respectively) was detected during the last call to &lt;a href=&quot;#waitForChange()&quot;&gt;waitForChange()&lt;/a&gt;. If &lt;code&gt;waitForChange()&lt;/code&gt; has not been called on this object, &lt;code&gt;CARD_INSERTION&lt;/code&gt; is equivalent to &lt;code&gt;CARD_PRESENT&lt;/code&gt; and &lt;code&gt;CARD_REMOVAL&lt;/code&gt; is equivalent to &lt;code&gt;CARD_ABSENT&lt;/code&gt;. For an example of the use of &lt;code&gt;CARD_INSERTION&lt;/code&gt;, see &lt;a href=&quot;#waitForChange()&quot;&gt;&lt;code&gt;waitForChange()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果state是&lt;a href=&quot;cardterminals.state#CARD_INSERTION&quot;&gt; &lt;code&gt;State.CARD_INSERTION&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;cardterminals.state#CARD_REMOVAL&quot;&gt; &lt;code&gt;State.CARD_REMOVAL&lt;/code&gt; &lt;/a&gt;，则它将返回在上次调用&lt;a href=&quot;#waitForChange()&quot;&gt;waitForChange（）&lt;/a&gt;期间检测到插入（或移除）的所有CardTerminal 。如果 &lt;code&gt;waitForChange()&lt;/code&gt; 没有被调用这个对象上， &lt;code&gt;CARD_INSERTION&lt;/code&gt; 相当于 &lt;code&gt;CARD_PRESENT&lt;/code&gt; 和 &lt;code&gt;CARD_REMOVAL&lt;/code&gt; 相当于 &lt;code&gt;CARD_ABSENT&lt;/code&gt; 。有关使用 &lt;code&gt;CARD_INSERTION&lt;/code&gt; 的示例，请参见&lt;a href=&quot;#waitForChange()&quot;&gt; &lt;code&gt;waitForChange()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="36119d6ef751d0ba1a40bc06d8c08c0232acb626" translate="yes" xml:space="preserve">
          <source>If still no result bundle is found, the base name alone is looked up. If this still fails, a &lt;code&gt;MissingResourceException&lt;/code&gt; is thrown.</source>
          <target state="translated">如果仍未找到结果包，则仅查找基本名称。如果仍然失败，则抛出 &lt;code&gt;MissingResourceException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="49c2d956b15c160db2755278d76b95411d1638e9" translate="yes" xml:space="preserve">
          <source>If such a service has been registered with the context, or one of its nesting context's, in the case where a context delegate to its context to satisfy a service request, then the BeanContextServiceProvider associated with the service is asked to provide an instance of that service.</source>
          <target state="translated">如果这样的服务已经在上下文或它的一个嵌套上下文中注册,在上下文委托给它的上下文以满足服务请求的情况下,那么与服务相关联的BeanContextServiceProvider被要求提供该服务的实例。</target>
        </trans-unit>
        <trans-unit id="94b0570a3ef5bacc1df2844b6f6f55155f5164cd" translate="yes" xml:space="preserve">
          <source>If such an &lt;code&gt;IOException&lt;/code&gt; is not thrown, then the stream is reset to a state such that all the bytes read since the most recent call to &lt;code&gt;mark&lt;/code&gt; (or since the start of the file, if &lt;code&gt;mark&lt;/code&gt; has not been called) will be resupplied to subsequent callers of the &lt;code&gt;read&lt;/code&gt; method, followed by any bytes that otherwise would have been the next input data as of the time of the call to &lt;code&gt;reset&lt;/code&gt;.</source>
          <target state="translated">如果未抛出这样的 &lt;code&gt;IOException&lt;/code&gt; ，则将流重置为一种状态，以便将自最近一次对 &lt;code&gt;mark&lt;/code&gt; 的调用（或从文件的开始，如果尚未调用 &lt;code&gt;mark&lt;/code&gt; ）以来读取的所有字节重新提供给后续操作。调用 &lt;code&gt;read&lt;/code&gt; 方法的调用者，后跟截至 &lt;code&gt;reset&lt;/code&gt; 调用时本来应该是下一个输入数据的任何字节。</target>
        </trans-unit>
        <trans-unit id="ba67a915702ddd93a2439399e9e5620bf22a0c62" translate="yes" xml:space="preserve">
          <source>If such an error is thrown then subsequent invocations of the iterator will make a best effort to locate and instantiate the next available provider, but in general such recovery cannot be guaranteed.</source>
          <target state="translated">如果抛出这样的错误,那么后续对迭代器的调用将尽最大努力定位并实例化下一个可用的提供者,但一般情况下,这种恢复无法保证。</target>
        </trans-unit>
        <trans-unit id="0ca56d49fb83daa43c8cab6e57a0bc195c1fa094" translate="yes" xml:space="preserve">
          <source>If support for extended mouse buttons is &lt;a href=&quot;toolkit#areExtraMouseButtonsEnabled()&quot;&gt;&lt;code&gt;disabled&lt;/code&gt;&lt;/a&gt; by Java then it is allowed to use only the following standard button masks: &lt;code&gt;InputEvent.BUTTON1_DOWN_MASK&lt;/code&gt;, &lt;code&gt;InputEvent.BUTTON2_DOWN_MASK&lt;/code&gt;, &lt;code&gt;InputEvent.BUTTON3_DOWN_MASK&lt;/code&gt;.</source>
          <target state="translated">如果Java&lt;a href=&quot;toolkit#areExtraMouseButtonsEnabled()&quot;&gt; &lt;code&gt;disabled&lt;/code&gt; &lt;/a&gt;了对扩展鼠标按钮的支持，则只允许使用以下标准按钮掩码： &lt;code&gt;InputEvent.BUTTON1_DOWN_MASK&lt;/code&gt; ， &lt;code&gt;InputEvent.BUTTON2_DOWN_MASK&lt;/code&gt; ， &lt;code&gt;InputEvent.BUTTON3_DOWN_MASK&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d39904b337a524b3be8e74dcbdcdc3b283655905" translate="yes" xml:space="preserve">
          <source>If support for extended mouse buttons is &lt;a href=&quot;toolkit#areExtraMouseButtonsEnabled()&quot;&gt;&lt;code&gt;enabled&lt;/code&gt;&lt;/a&gt; by Java then it is allowed to use the standard button masks and masks for existing extended mouse buttons, if the mouse has more then three buttons. In that way, it is allowed to use the button masks corresponding to the buttons in the range from 1 to &lt;a href=&quot;mouseinfo#getNumberOfButtons()&quot;&gt;&lt;code&gt;MouseInfo.getNumberOfButtons()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果Java&lt;a href=&quot;toolkit#areExtraMouseButtonsEnabled()&quot;&gt; &lt;code&gt;enabled&lt;/code&gt; &lt;/a&gt;了对扩展鼠标按钮的支持，则允许使用标准按钮掩码和现有扩展鼠标按钮的掩码（如果鼠标具有三个以上的按钮）。这样，允许使用与按钮相对应的按钮掩码，范围从1到&lt;a href=&quot;mouseinfo#getNumberOfButtons()&quot;&gt; &lt;code&gt;MouseInfo.getNumberOfButtons()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="486f3c00239a42cba8b1916fb667e0081bff0684" translate="yes" xml:space="preserve">
          <source>If support for the extended mouse buttons is &lt;a href=&quot;../toolkit#areExtraMouseButtonsEnabled()&quot;&gt;&lt;code&gt;disabled&lt;/code&gt;&lt;/a&gt; by Java then it is allowed to create &lt;code&gt;MouseEvent&lt;/code&gt; objects only with the standard buttons: &lt;code&gt;NOBUTTON&lt;/code&gt;, &lt;code&gt;BUTTON1&lt;/code&gt;, &lt;code&gt;BUTTON2&lt;/code&gt;, and &lt;code&gt;BUTTON3&lt;/code&gt;.</source>
          <target state="translated">如果Java&lt;a href=&quot;../toolkit#areExtraMouseButtonsEnabled()&quot;&gt; &lt;code&gt;disabled&lt;/code&gt; &lt;/a&gt;了对扩展鼠标按钮的支持，则只允许使用以下标准按钮创建 &lt;code&gt;MouseEvent&lt;/code&gt; 对象： &lt;code&gt;NOBUTTON&lt;/code&gt; ， &lt;code&gt;BUTTON1&lt;/code&gt; ， &lt;code&gt;BUTTON2&lt;/code&gt; 和 &lt;code&gt;BUTTON3&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="65884caffeef70616af6ac015fb22950976842d5" translate="yes" xml:space="preserve">
          <source>If support for the extended mouse buttons is &lt;a href=&quot;../toolkit#areExtraMouseButtonsEnabled()&quot;&gt;&lt;code&gt;enabled&lt;/code&gt;&lt;/a&gt; by Java then it is allowed to create &lt;code&gt;MouseEvent&lt;/code&gt; objects with the standard buttons. In case the support for extended mouse buttons is &lt;a href=&quot;../toolkit#areExtraMouseButtonsEnabled()&quot;&gt;&lt;code&gt;enabled&lt;/code&gt;&lt;/a&gt; by Java, then in addition to the standard buttons, &lt;code&gt;MouseEvent&lt;/code&gt; objects can be created using buttons from the range starting from 4 to &lt;a href=&quot;../mouseinfo#getNumberOfButtons()&quot;&gt;&lt;code&gt;MouseInfo.getNumberOfButtons()&lt;/code&gt;&lt;/a&gt; if the mouse has more than three buttons.</source>
          <target state="translated">如果Java&lt;a href=&quot;../toolkit#areExtraMouseButtonsEnabled()&quot;&gt; &lt;code&gt;enabled&lt;/code&gt; &lt;/a&gt;了对扩展鼠标按钮的支持，则允许使用标准按钮创建 &lt;code&gt;MouseEvent&lt;/code&gt; 对象。如果Java&lt;a href=&quot;../toolkit#areExtraMouseButtonsEnabled()&quot;&gt; &lt;code&gt;enabled&lt;/code&gt; &lt;/a&gt;了对扩展鼠标按钮的支持，则除了标准按钮之外，如果鼠标具有三个以上的按钮，则可以使用从4到&lt;a href=&quot;../mouseinfo#getNumberOfButtons()&quot;&gt; &lt;code&gt;MouseInfo.getNumberOfButtons()&lt;/code&gt; &lt;/a&gt;范围内的按钮来创建 &lt;code&gt;MouseEvent&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="5d3c9f547885ed5dc664bee523aaf2e97a59a19a" translate="yes" xml:space="preserve">
          <source>If supported by the underlying SSL/TLS/DTLS implementation, application name negotiation mechanisms such as &lt;a href=&quot;http://www.ietf.org/rfc/rfc7301.txt&quot;&gt; RFC 7301 &lt;/a&gt;, the Application-Layer Protocol Negotiation (ALPN), can negotiate application-level values between peers.</source>
          <target state="translated">如果基础SSL / TLS / DTLS实施支持，则应用程序名称协商机制（例如&lt;a href=&quot;http://www.ietf.org/rfc/rfc7301.txt&quot;&gt;RFC 7301&lt;/a&gt;，即应用程序层协议协商（ALPN））可以在同级之间协商应用程序级别的值。</target>
        </trans-unit>
        <trans-unit id="b56b6a2c479a52bb0285125852b4bd46d6cc96d3" translate="yes" xml:space="preserve">
          <source>If supported by the underlying SSL/TLS/DTLS implementation, application name negotiation mechanisms such as &lt;a href=&quot;https://www.ietf.org/rfc/rfc7301.txt&quot;&gt; RFC 7301 &lt;/a&gt;, the Application-Layer Protocol Negotiation (ALPN), can negotiate application-level values between peers.</source>
          <target state="translated">如果基础SSL / TLS / DTLS实施支持，则应用程序名称协商机制（例如&lt;a href=&quot;https://www.ietf.org/rfc/rfc7301.txt&quot;&gt;RFC 7301&lt;/a&gt;，即应用程序层协议协商（ALPN））可以在同级之间协商应用程序级别的值。</target>
        </trans-unit>
        <trans-unit id="483297556e0d86a729fc879bc3d6a3a654a16eca" translate="yes" xml:space="preserve">
          <source>If system exclusive data from &lt;code&gt;SysexMessages&lt;/code&gt; objects is being transmitted using MIDI wire protocol, only the initial 0xF0 status byte, the system exclusive data itself, and the final 0xF7 (EOX) byte should be propagated; any 0xF7 status bytes used to indicate that a &lt;code&gt;SysexMessage&lt;/code&gt; contains continuing system exclusive data should not be propagated via MIDI wire protocol.</source>
          <target state="translated">如果使用MIDI有线协议传输 &lt;code&gt;SysexMessages&lt;/code&gt; 对象的系统独占数据，则仅应传播初始的0xF0状态字节，系统独占数据本身和最后的0xF7（EOX）字节；用于指示 &lt;code&gt;SysexMessage&lt;/code&gt; 包含连续的系统独占数据的任何0xF7状态字节都不应通过MIDI有线协议传播。</target>
        </trans-unit>
        <trans-unit id="8a60148766d9542dcdda7613f880094d44b2ef2c" translate="yes" xml:space="preserve">
          <source>If system properties &lt;code&gt;javax.sound.sampled.Clip&lt;/code&gt;, &lt;code&gt;javax.sound.sampled.Port&lt;/code&gt;, &lt;code&gt;javax.sound.sampled.SourceDataLine&lt;/code&gt; and &lt;code&gt;javax.sound.sampled.TargetDataLine&lt;/code&gt; are defined or they are defined in the file &quot;sound.properties&quot;, they are used to retrieve default lines. For details, refer to the &lt;a href=&quot;audiosystem&quot;&gt;&lt;code&gt;class description&lt;/code&gt;&lt;/a&gt;. If the respective property is not set, or the mixer requested in the property is not installed or does not provide the requested line, all installed mixers are queried for the requested line type. A Line will be returned from the first mixer providing the requested line type.</source>
          <target state="translated">如果定义了系统属性 &lt;code&gt;javax.sound.sampled.Clip&lt;/code&gt; ， &lt;code&gt;javax.sound.sampled.Port&lt;/code&gt; ， &lt;code&gt;javax.sound.sampled.SourceDataLine&lt;/code&gt; 和 &lt;code&gt;javax.sound.sampled.TargetDataLine&lt;/code&gt; 或在文件&amp;ldquo; sound.properties&amp;rdquo;中定义了它们，用于检索默认行。有关详细信息，请参阅&lt;a href=&quot;audiosystem&quot;&gt; &lt;code&gt;class description&lt;/code&gt; &lt;/a&gt;。如果未设置相应的属性，或者未安装该属性中请求的混合器或未提供请求的行，则将查询所有已安装的混合器以获取请求的行类型。从第一台调音台返回的线路将提供所请求的线路类型。</target>
        </trans-unit>
        <trans-unit id="a8e3d47700ce7e07788d64cbfa2cd41b86d9c136" translate="yes" xml:space="preserve">
          <source>If target is _self, the action is to change the value of the &lt;code&gt;HTML.Attribute.SRC&lt;/code&gt; attribute and fires a &lt;code&gt;ChangedUpdate&lt;/code&gt; event.</source>
          <target state="translated">如果target是_self，则操作是更改 &lt;code&gt;HTML.Attribute.SRC&lt;/code&gt; 属性的值并触发 &lt;code&gt;ChangedUpdate&lt;/code&gt; 事件。</target>
        </trans-unit>
        <trans-unit id="3d9b7696c9777c3fdef5f5f1690ef14ee23382d9" translate="yes" xml:space="preserve">
          <source>If the</source>
          <target state="translated">如果</target>
        </trans-unit>
        <trans-unit id="1f583398dc1f86dc2870e17e17525bfe7bcb7fe2" translate="yes" xml:space="preserve">
          <source>If the &quot;java.util.logging.config.class&quot; property is set, then the property value is treated as a class name. The given class will be loaded, an object will be instantiated, and that object's constructor is responsible for reading in the initial configuration. (That object may use other system properties to control its configuration.) The alternate configuration class can use &lt;code&gt;readConfiguration(InputStream)&lt;/code&gt; to define properties in the LogManager.</source>
          <target state="translated">如果设置了&amp;ldquo; java.util.logging.config.class&amp;rdquo;属性，则将该属性值视为类名。给定的类将被加载，一个对象将被实例化，并且该对象的构造函数负责读取初始配置。（该对象可以使用其他系统属性来控制其配置。）备用配置类可以使用 &lt;code&gt;readConfiguration(InputStream)&lt;/code&gt; 在LogManager中定义属性。</target>
        </trans-unit>
        <trans-unit id="7c21737341f78d589edcf2b473c1e9d4710529e7" translate="yes" xml:space="preserve">
          <source>If the &quot;java.util.logging.config.class&quot; system property is set, then the property value is treated as a class name. The given class will be loaded, an object will be instantiated, and that object's constructor is responsible for reading in the initial configuration. (That object may use other system properties to control its configuration.) The alternate configuration class can use &lt;code&gt;readConfiguration(InputStream)&lt;/code&gt; to define properties in the LogManager.</source>
          <target state="translated">如果设置了&amp;ldquo; java.util.logging.config.class&amp;rdquo;系统属性，则将该属性值视为类名。给定的类将被加载，一个对象将被实例化，并且该对象的构造函数负责读取初始配置。（该对象可以使用其他系统属性来控制其配置。）备用配置类可以使用 &lt;code&gt;readConfiguration(InputStream)&lt;/code&gt; 在LogManager中定义属性。</target>
        </trans-unit>
        <trans-unit id="ee9a28b9f37694fc322c18e7908dd9236e4f1f5e" translate="yes" xml:space="preserve">
          <source>If the &quot;java.util.logging.config.file&quot; system property is set, then the property value specifies the properties file to be read as the new configuration. Otherwise, the LogManager default configuration is used.</source>
          <target state="translated">如果设置了 &quot;java.util.logging.config.file &quot;系统属性,那么该属性值就会指定要作为新配置读取的属性文件。否则,将使用 LogManager 默认配置。</target>
        </trans-unit>
        <trans-unit id="2d3e35bcf72871950c117a29249ba322eaf7916a" translate="yes" xml:space="preserve">
          <source>If the 'getMethod' field contains the name of a valid operation descriptor, then the method described by the operation descriptor is executed. The response from the method is returned as the value of the attribute. If the operation fails or the returned value is not compatible with the declared type of the attribute, an exception will be thrown.</source>
          <target state="translated">如果'getMethod'字段包含一个有效的操作描述符的名称,那么操作描述符所描述的方法将被执行。该方法的响应将作为属性的值返回。如果操作失败或者返回的值与属性的声明类型不兼容,则会抛出一个异常。</target>
        </trans-unit>
        <trans-unit id="e0d548ba22d2542cb9fd6382914ac5396917edaa" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#%3Cinit%3E(java.security.SecureRandomParameters)&quot;&gt;&lt;code&gt;SecureRandomSpi(SecureRandomParameters)&lt;/code&gt;&lt;/a&gt; constructor is overridden in an implementation, it will always be called whenever a &lt;code&gt;SecureRandom&lt;/code&gt; is instantiated. Precisely, if an object is instantiated with one of &lt;code&gt;SecureRandom&lt;/code&gt;'s &lt;code&gt;getInstance&lt;/code&gt; methods &lt;em&gt;without&lt;/em&gt; a &lt;a href=&quot;securerandomparameters&quot;&gt;&lt;code&gt;SecureRandomParameters&lt;/code&gt;&lt;/a&gt; parameter, the constructor will be called with a &lt;code&gt;null&lt;/code&gt; argument and the implementation is responsible for creating its own &lt;code&gt;SecureRandomParameters&lt;/code&gt; parameter for use when &lt;a href=&quot;#engineGetParameters()&quot;&gt;&lt;code&gt;engineGetParameters()&lt;/code&gt;&lt;/a&gt; is called. If an object is instantiated with one of &lt;code&gt;SecureRandom&lt;/code&gt;'s &lt;code&gt;getInstance&lt;/code&gt; methods &lt;em&gt;with&lt;/em&gt; a &lt;code&gt;SecureRandomParameters&lt;/code&gt; argument, the constructor will be called with that argument. The &lt;a href=&quot;#engineGetParameters()&quot;&gt;&lt;code&gt;engineGetParameters()&lt;/code&gt;&lt;/a&gt; method must not return &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">如果在实现中重写了&lt;a href=&quot;#%3Cinit%3E(java.security.SecureRandomParameters)&quot;&gt; &lt;code&gt;SecureRandomSpi(SecureRandomParameters)&lt;/code&gt; &lt;/a&gt;构造函数，则无论何时实例化 &lt;code&gt;SecureRandom&lt;/code&gt; 都将始终调用该构造函数。准确地说，如果对象是用一个实例化 &lt;code&gt;SecureRandom&lt;/code&gt; 的 &lt;code&gt;getInstance&lt;/code&gt; 方法&lt;em&gt;没有&lt;/em&gt;一个&lt;a href=&quot;securerandomparameters&quot;&gt; &lt;code&gt;SecureRandomParameters&lt;/code&gt; &lt;/a&gt;参数，构造函数会被一个叫 &lt;code&gt;null&lt;/code&gt; 论证和实现负责创建自己的 &lt;code&gt;SecureRandomParameters&lt;/code&gt; 参数使用时&lt;a href=&quot;#engineGetParameters()&quot;&gt; &lt;code&gt;engineGetParameters()&lt;/code&gt; &lt;/a&gt;被调用。如果使用 &lt;code&gt;SecureRandom&lt;/code&gt; 的 &lt;code&gt;getInstance&lt;/code&gt; 方法之一实例化对象&lt;em&gt;有&lt;/em&gt;一个 &lt;code&gt;SecureRandomParameters&lt;/code&gt; 参数，构造函数将与参数来调用。该&lt;a href=&quot;#engineGetParameters()&quot;&gt; &lt;code&gt;engineGetParameters()&lt;/code&gt; &lt;/a&gt;方法不能返回 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3fd0e8651509209ab66f4363379a0875ab48d6ad" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#FOREGROUND&quot;&gt;&lt;code&gt;FOREGROUND&lt;/code&gt;&lt;/a&gt; attribute is set, its &lt;code&gt;Paint&lt;/code&gt; will be used as the background, otherwise the &lt;code&gt;Paint&lt;/code&gt; currently on the &lt;code&gt;Graphics&lt;/code&gt; will be used. If the &lt;a href=&quot;#BACKGROUND&quot;&gt;&lt;code&gt;BACKGROUND&lt;/code&gt;&lt;/a&gt; attribute is set, its &lt;code&gt;Paint&lt;/code&gt; will be used as the foreground, otherwise the system will find a contrasting color to the (resolved) background so that the text will be visible.</source>
          <target state="translated">如果设置了&lt;a href=&quot;#FOREGROUND&quot;&gt; &lt;code&gt;FOREGROUND&lt;/code&gt; &lt;/a&gt;属性，则将其&amp;ldquo; &lt;code&gt;Paint&lt;/code&gt; 用作背景，否则将使用&amp;ldquo; &lt;code&gt;Graphics&lt;/code&gt; 上当前使用的&amp;ldquo; &lt;code&gt;Paint&lt;/code&gt; 。如果设置了&lt;a href=&quot;#BACKGROUND&quot;&gt; &lt;code&gt;BACKGROUND&lt;/code&gt; &lt;/a&gt;属性，则将其 &lt;code&gt;Paint&lt;/code&gt; 用作前景，否则系统将找到与（解析的）背景形成对比的颜色，从而使文本可见。</target>
        </trans-unit>
        <trans-unit id="266d9b29b8861792af1fe586314983e8903d9fa3" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#eval(java.lang.String)&quot;&gt;&lt;code&gt;eval(java.lang.String)&lt;/code&gt;&lt;/a&gt; method is not running, does nothing.</source>
          <target state="translated">如果&lt;a href=&quot;#eval(java.lang.String)&quot;&gt; &lt;code&gt;eval(java.lang.String)&lt;/code&gt; &lt;/a&gt;方法未运行，则不执行任何操作。</target>
        </trans-unit>
        <trans-unit id="86337241a9668cc6a25c97b5de65d911d14a1894" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#redirectErrorStream()&quot;&gt;&lt;code&gt;redirectErrorStream&lt;/code&gt;&lt;/a&gt; attribute has been set &lt;code&gt;true&lt;/code&gt;, then the redirection set by this method has no effect.</source>
          <target state="translated">如果&lt;a href=&quot;#redirectErrorStream()&quot;&gt; &lt;code&gt;redirectErrorStream&lt;/code&gt; &lt;/a&gt;属性设置为 &lt;code&gt;true&lt;/code&gt; ，则此方法设置的重定向无效。</target>
        </trans-unit>
        <trans-unit id="b85fc122285cb0d2f89cc05f312ee0e46a0a070d" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#setInput(java.nio.ByteBuffer)&quot;&gt;&lt;code&gt;setInput(ByteBuffer)&lt;/code&gt;&lt;/a&gt; method was called to provide a buffer for input, the input buffer's position will be advanced by the number of bytes consumed by this operation, even in the event that a &lt;a href=&quot;dataformatexception&quot;&gt;&lt;code&gt;DataFormatException&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">如果调用&lt;a href=&quot;#setInput(java.nio.ByteBuffer)&quot;&gt; &lt;code&gt;setInput(ByteBuffer)&lt;/code&gt; &lt;/a&gt;方法为输入提供缓冲区，则即使抛出&lt;a href=&quot;dataformatexception&quot;&gt; &lt;code&gt;DataFormatException&lt;/code&gt; &lt;/a&gt;事件，输入缓冲区的位置也将被该操作消耗的字节数提高。</target>
        </trans-unit>
        <trans-unit id="beaa63bfc2c275017816960a621f79d777650f26" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#setInput(java.nio.ByteBuffer)&quot;&gt;&lt;code&gt;setInput(ByteBuffer)&lt;/code&gt;&lt;/a&gt; method was called to provide a buffer for input, the input buffer's position will be advanced by the number of bytes consumed by this operation.</source>
          <target state="translated">如果调用&lt;a href=&quot;#setInput(java.nio.ByteBuffer)&quot;&gt; &lt;code&gt;setInput(ByteBuffer)&lt;/code&gt; &lt;/a&gt;方法以提供输入缓冲区，则该操作消耗的字节数将使输入缓冲区的位置提前。</target>
        </trans-unit>
        <trans-unit id="89d95c390fbfbed6f9512b14bde317e19394155e" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#staticPermissionsOnly()&quot;&gt;&lt;code&gt;staticPermissionsOnly()&lt;/code&gt;&lt;/a&gt; method returns true, then the permission will only be checked against the PermissionCollection supplied at construction.</source>
          <target state="translated">如果&lt;a href=&quot;#staticPermissionsOnly()&quot;&gt; &lt;code&gt;staticPermissionsOnly()&lt;/code&gt; &lt;/a&gt;方法返回true，则仅根据构造时提供的PermissionCollection来检查权限。</target>
        </trans-unit>
        <trans-unit id="8f3202df3f64a60f68be2f6e8445b0bee61ca858" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;../../../java.base/java/util/properties&quot;&gt;&lt;code&gt;Properties&lt;/code&gt;&lt;/a&gt; file &lt;code&gt;swing.properties&lt;/code&gt; exists and contains the key &lt;code&gt;swing.defaultlaf&lt;/code&gt;, use its value as the default look and feel class name. The location that is checked for &lt;code&gt;swing.properties&lt;/code&gt; may vary depending upon the implementation of the Java platform. Typically the &lt;code&gt;swing.properties&lt;/code&gt; file is located in the &lt;code&gt;conf&lt;/code&gt; subdirectory of the Java installation directory. Refer to the release notes of the implementation being used for further details.</source>
          <target state="translated">如果&lt;a href=&quot;../../../java.base/java/util/properties&quot;&gt; &lt;code&gt;Properties&lt;/code&gt; &lt;/a&gt;文件 &lt;code&gt;swing.properties&lt;/code&gt; 存在并且包含键 &lt;code&gt;swing.defaultlaf&lt;/code&gt; ，则将其值用作默认外观类名称。根据Java平台的实现，检查 &lt;code&gt;swing.properties&lt;/code&gt; 的位置可能会有所不同。通常， &lt;code&gt;swing.properties&lt;/code&gt; 文件位于Java安装目录的 &lt;code&gt;conf&lt;/code&gt; 子目录中。有关更多详细信息，请参阅所用实现的发行说明。</target>
        </trans-unit>
        <trans-unit id="0cf976d251facbb1b28639a31b11358b94746e84" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;beaninfo&quot;&gt;&lt;code&gt;BeanInfo&lt;/code&gt;&lt;/a&gt; for this type has a &lt;a href=&quot;beandescriptor&quot;&gt;&lt;code&gt;BeanDescriptor&lt;/code&gt;&lt;/a&gt; which defined a &quot;persistenceDelegate&quot; attribute, the value of this named attribute is returned.</source>
          <target state="translated">如果此类型的&lt;a href=&quot;beaninfo&quot;&gt; &lt;code&gt;BeanInfo&lt;/code&gt; &lt;/a&gt;具有定义了&amp;ldquo; persistenceDelegate&amp;rdquo;属性的&lt;a href=&quot;beandescriptor&quot;&gt; &lt;code&gt;BeanDescriptor&lt;/code&gt; &lt;/a&gt;，则将返回此命名属性的值。</target>
        </trans-unit>
        <trans-unit id="f7796e655e99564bb42833b6c22ae781567c8b7e" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;processbuilder#redirectErrorStream&quot;&gt;&lt;code&gt;redirectErrorStream&lt;/code&gt;&lt;/a&gt; attribute has been set &lt;code&gt;true&lt;/code&gt;, then the redirection set by this method has no effect.</source>
          <target state="translated">如果&lt;a href=&quot;processbuilder#redirectErrorStream&quot;&gt; &lt;code&gt;redirectErrorStream&lt;/code&gt; &lt;/a&gt;属性设置为 &lt;code&gt;true&lt;/code&gt; ，则此方法设置的重定向无效。</target>
        </trans-unit>
        <trans-unit id="6369ec721b8ca4ab5fda1157ad5cc4775754c615" translate="yes" xml:space="preserve">
          <source>If the &lt;a id=&quot;floatDPrec&quot;&gt;conversion&lt;/a&gt; is &lt;code&gt;'e'&lt;/code&gt;, &lt;code&gt;'E'&lt;/code&gt; or &lt;code&gt;'f'&lt;/code&gt;, then the precision is the number of digits after the decimal separator. If the precision is not specified, then it is assumed to be &lt;code&gt;6&lt;/code&gt;.</source>
          <target state="translated">如果&lt;a id=&quot;floatDPrec&quot;&gt;转换&lt;/a&gt;为 &lt;code&gt;'e'&lt;/code&gt; ， &lt;code&gt;'E'&lt;/code&gt; 或 &lt;code&gt;'f'&lt;/code&gt; ，则精度为小数点分隔符后的位数。如果未指定精度，则假定为 &lt;code&gt;6&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="69cea4d19b20fb91d97db82c5ca57aaf842e28d6" translate="yes" xml:space="preserve">
          <source>If the &lt;a name=&quot;floatDPrec&quot;&gt;conversion&lt;/a&gt; is &lt;code&gt;'e'&lt;/code&gt;, &lt;code&gt;'E'&lt;/code&gt; or &lt;code&gt;'f'&lt;/code&gt;, then the precision is the number of digits after the decimal separator. If the precision is not specified, then it is assumed to be &lt;code&gt;6&lt;/code&gt;.</source>
          <target state="translated">如果&lt;a name=&quot;floatDPrec&quot;&gt;转换&lt;/a&gt;为 &lt;code&gt;'e'&lt;/code&gt; ， &lt;code&gt;'E'&lt;/code&gt; 或 &lt;code&gt;'f'&lt;/code&gt; ，则精度为小数点分隔符后的位数。如果未指定精度，则假定为 &lt;code&gt;6&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5059e8ee90e4d07843498ec51dc8abef786de5aa" translate="yes" xml:space="preserve">
          <source>If the &lt;b&gt;[member type definition anonymous]&lt;/b&gt; exists:</source>
          <target state="translated">如果&lt;b&gt;[匿名成员类型定义]&lt;/b&gt;存在：</target>
        </trans-unit>
        <trans-unit id="b3bdad546a4d7a971b883151ac70a2ccbe1f0095" translate="yes" xml:space="preserve">
          <source>If the &lt;b&gt;[type definition anonymous]&lt;/b&gt; exists:</source>
          <target state="translated">如果存在&lt;b&gt;[匿名类型定义]&lt;/b&gt;：</target>
        </trans-unit>
        <trans-unit id="224235c33cd803b74bad7dc5b6641bf25c3410c2" translate="yes" xml:space="preserve">
          <source>If the &lt;b&gt;[type definition]&lt;/b&gt; property exists:</source>
          <target state="translated">如果&lt;b&gt;[类型定义]&lt;/b&gt;属性存在：</target>
        </trans-unit>
        <trans-unit id="ea735b3ad144dc0d3c88616e2055c7a3baba85a5" translate="yes" xml:space="preserve">
          <source>If the &lt;b&gt;[validity]&lt;/b&gt; property exists AND is &lt;em&gt;&quot;invalid&quot;&lt;/em&gt; or &lt;em&gt;&quot;notKnown&quot;&lt;/em&gt;: the {target namespace} and {name} properties of the declared type if available, otherwise &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">如果&lt;b&gt;[validity]&lt;/b&gt;属性存在并且为&lt;em&gt;&amp;ldquo; invalid&amp;rdquo;&lt;/em&gt;或&lt;em&gt;&amp;ldquo; notKnown&amp;rdquo;&lt;/em&gt;：声明类型的{target名称空间}和{name}属性（如果可用），否则为 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c5654c5178b9647add1bfe15b4562bdf804149ac" translate="yes" xml:space="preserve">
          <source>If the &lt;b&gt;[validity]&lt;/b&gt; property exists and is &lt;em&gt;&quot;valid&quot;&lt;/em&gt;:</source>
          <target state="translated">如果&lt;b&gt;[validity]&lt;/b&gt;属性存在且为&lt;em&gt;&amp;ldquo;有效&amp;rdquo;&lt;/em&gt;：</target>
        </trans-unit>
        <trans-unit id="244d88b2fe1f7cc3d006bcc6bed47c61fe2ec794" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&quot;zh&quot;&lt;/code&gt;-to-&lt;code&gt;&quot;zh&quot;&lt;/code&gt; mapping isn't included in the map, a simple replacement will be performed and the customized list won't include &lt;code&gt;&quot;zh&quot;&lt;/code&gt; and &lt;code&gt;&quot;zh-CN&quot;&lt;/code&gt;.</source>
          <target state="translated">如果映射中不包含 &lt;code&gt;&quot;zh&quot;&lt;/code&gt; 到 &lt;code&gt;&quot;zh&quot;&lt;/code&gt; 映射，则将执行简单替换，并且自定义列表将不包含 &lt;code&gt;&quot;zh&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;zh-CN&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="23f4d1d76d4c61640485815093054acc02ce819f" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;'#'&lt;/code&gt; flag is given &lt;a href=&quot;formatflagsconversionmismatchexception&quot;&gt;&lt;code&gt;FormatFlagsConversionMismatchException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">如果给定 &lt;code&gt;'#'&lt;/code&gt; 标志，&lt;a href=&quot;formatflagsconversionmismatchexception&quot;&gt; &lt;code&gt;FormatFlagsConversionMismatchException&lt;/code&gt; &lt;/a&gt;引发FormatFlagsConversionMismatchException。</target>
        </trans-unit>
        <trans-unit id="1c680cd1a5cd595f752bed838baa38292f42bbcd" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;'#'&lt;/code&gt; flag is given and the argument is not a &lt;a href=&quot;formattable&quot;&gt;&lt;code&gt;Formattable&lt;/code&gt;&lt;/a&gt; , then a &lt;a href=&quot;formatflagsconversionmismatchexception&quot;&gt;&lt;code&gt;FormatFlagsConversionMismatchException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">如果给出 &lt;code&gt;'#'&lt;/code&gt; 标志并且参数不是&lt;a href=&quot;formattable&quot;&gt; &lt;code&gt;Formattable&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;formatflagsconversionmismatchexception&quot;&gt; &lt;code&gt;FormatFlagsConversionMismatchException&lt;/code&gt; &lt;/a&gt;引发FormatFlagsConversionMismatchException。</target>
        </trans-unit>
        <trans-unit id="6a276179b3d9aede60085715e083872d2bc9bb28" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;'#'&lt;/code&gt; flag is given and the argument is not a &lt;a href=&quot;formattable&quot;&gt;&lt;code&gt;Formattable&lt;/code&gt;&lt;/a&gt;, then a &lt;a href=&quot;formatflagsconversionmismatchexception&quot;&gt;&lt;code&gt;FormatFlagsConversionMismatchException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">如果给出 &lt;code&gt;'#'&lt;/code&gt; 标志并且参数不是&lt;a href=&quot;formattable&quot;&gt; &lt;code&gt;Formattable&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;formatflagsconversionmismatchexception&quot;&gt; &lt;code&gt;FormatFlagsConversionMismatchException&lt;/code&gt; &lt;/a&gt;引发FormatFlagsConversionMismatchException。</target>
        </trans-unit>
        <trans-unit id="8f3ca6b4a24528a74561304ff78b46e45f7ce091" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;'#'&lt;/code&gt; flag is given then a &lt;a href=&quot;formatflagsconversionmismatchexception&quot;&gt;&lt;code&gt;FormatFlagsConversionMismatchException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">如果给出 &lt;code&gt;'#'&lt;/code&gt; 标志，&lt;a href=&quot;formatflagsconversionmismatchexception&quot;&gt; &lt;code&gt;FormatFlagsConversionMismatchException&lt;/code&gt; &lt;/a&gt;引发FormatFlagsConversionMismatchException。</target>
        </trans-unit>
        <trans-unit id="95f5e2ee606537dc80cd0c08600e71779319b292" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;'#'&lt;/code&gt; flag is given then an &lt;a href=&quot;formatflagsconversionmismatchexception&quot;&gt;&lt;code&gt;FormatFlagsConversionMismatchException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">如果给出 &lt;code&gt;'#'&lt;/code&gt; 标志，&lt;a href=&quot;formatflagsconversionmismatchexception&quot;&gt; &lt;code&gt;FormatFlagsConversionMismatchException&lt;/code&gt; &lt;/a&gt;引发FormatFlagsConversionMismatchException。</target>
        </trans-unit>
        <trans-unit id="705393d5e4190c15bb4ded3f92e669b7967af3af" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;'#'&lt;/code&gt; flag is given then the output will always begin with &lt;code&gt;'0'&lt;/code&gt; prefix.</source>
          <target state="translated">如果给出 &lt;code&gt;'#'&lt;/code&gt; 标志，则输出将始终以 &lt;code&gt;'0'&lt;/code&gt; 前缀开头。</target>
        </trans-unit>
        <trans-unit id="d94fd5d1c396bfff4fed3e4917313944fa0d8ce4" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;'#'&lt;/code&gt; flag is given then the output will always begin with the radix indicator &lt;code&gt;&quot;0x&quot;&lt;/code&gt;.</source>
          <target state="translated">如果给出 &lt;code&gt;'#'&lt;/code&gt; 标志，则输出将始终以基数指示符 &lt;code&gt;&quot;0x&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="af351499ffe1eb584449ad1db1312af2f6169806" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;'#'&lt;/code&gt; flag is given then the output will always begin with the radix indicator &lt;code&gt;'0'&lt;/code&gt;.</source>
          <target state="translated">如果给出 &lt;code&gt;'#'&lt;/code&gt; 标志，那么输出将始终以基数指示符 &lt;code&gt;'0'&lt;/code&gt; 开始。</target>
        </trans-unit>
        <trans-unit id="2e2b33eac4b29de7dc276798ef6bb121e0f191c3" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;'#'&lt;/code&gt; flag is given, then a &lt;a href=&quot;formatflagsconversionmismatchexception&quot;&gt;&lt;code&gt;FormatFlagsConversionMismatchException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">如果给出 &lt;code&gt;'#'&lt;/code&gt; 标志，&lt;a href=&quot;formatflagsconversionmismatchexception&quot;&gt; &lt;code&gt;FormatFlagsConversionMismatchException&lt;/code&gt; &lt;/a&gt;引发FormatFlagsConversionMismatchException。</target>
        </trans-unit>
        <trans-unit id="193a49527f28f69b767038d67c1984e036b12529" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;'#'&lt;/code&gt; flag is given, then the decimal separator will always be present.</source>
          <target state="translated">如果给出 &lt;code&gt;'#'&lt;/code&gt; 标志，则十进制分隔符将始终存在。</target>
        </trans-unit>
        <trans-unit id="170d2f39d6b7a451069152ef956aa45571ac5f4f" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;'('&lt;/code&gt; or &lt;code&gt;','&lt;/code&gt; flags are given, then a &lt;a href=&quot;formatflagsconversionmismatchexception&quot;&gt;&lt;code&gt;FormatFlagsConversionMismatchException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">如果给出了 &lt;code&gt;'('&lt;/code&gt; 或 &lt;code&gt;','&lt;/code&gt; 标志，&lt;a href=&quot;formatflagsconversionmismatchexception&quot;&gt; &lt;code&gt;FormatFlagsConversionMismatchException&lt;/code&gt; &lt;/a&gt;引发FormatFlagsConversionMismatchException。</target>
        </trans-unit>
        <trans-unit id="25f8f50b77134591d75e17a674bec028e9c6e997" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;'+'&lt;/code&gt; flag is given and the value is positive or zero (or floating-point positive zero), then a &lt;code&gt;'+'&lt;/code&gt; (&lt;code&gt;'\u002b'&lt;/code&gt;) will be prepended.</source>
          <target state="translated">如果给出了 &lt;code&gt;'+'&lt;/code&gt; 标志，并且该值是正数或零（或浮点数正零），则将添加 &lt;code&gt;'+'&lt;/code&gt; （ &lt;code&gt;'\u002b'&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="dd8701b10b903c76286404a520374517bcb6cb05" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;','&lt;/code&gt; (&lt;code&gt;'\u002c'&lt;/code&gt;) &lt;a id=&quot;L10nGroup&quot;&gt;flag&lt;/a&gt; is given, then the locale-specific &lt;a href=&quot;../text/decimalformatsymbols#getGroupingSeparator()&quot;&gt;grouping separator&lt;/a&gt; is inserted by scanning the integer part of the string from least significant to most significant digits and inserting a separator at intervals defined by the locale's &lt;a href=&quot;../text/decimalformat#getGroupingSize()&quot;&gt;grouping size&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;','&lt;/code&gt; （ &lt;code&gt;'\u002c'&lt;/code&gt; ）&lt;a id=&quot;L10nGroup&quot;&gt;标志&lt;/a&gt;给出，那么语言环境的特定的&lt;a href=&quot;../text/decimalformatsymbols#getGroupingSeparator()&quot;&gt;分组分离器&lt;/a&gt;通过在由语言环境的定义的时间间隔扫描所述字符串从至少显著到最显著位数的整数部分和插入一个分离器被插入&lt;a href=&quot;../text/decimalformat#getGroupingSize()&quot;&gt;分组大小&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="910241aebecc3c9182f2e0462c8f58f123333d6e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;','&lt;/code&gt; (&lt;code&gt;'\u002c'&lt;/code&gt;) &lt;a name=&quot;L10nGroup&quot;&gt;flag&lt;/a&gt; is given, then the locale-specific &lt;a href=&quot;../text/decimalformatsymbols#getGroupingSeparator--&quot;&gt;grouping separator&lt;/a&gt; is inserted by scanning the integer part of the string from least significant to most significant digits and inserting a separator at intervals defined by the locale's &lt;a href=&quot;../text/decimalformat#getGroupingSize--&quot;&gt;grouping size&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;','&lt;/code&gt; （ &lt;code&gt;'\u002c'&lt;/code&gt; ）&lt;a name=&quot;L10nGroup&quot;&gt;标志&lt;/a&gt;给出，那么语言环境的特定的&lt;a href=&quot;../text/decimalformatsymbols#getGroupingSeparator--&quot;&gt;分组分离器&lt;/a&gt;通过在由语言环境的定义的时间间隔扫描所述字符串从至少显著到最显著位数的整数部分和插入一个分离器被插入&lt;a href=&quot;../text/decimalformat#getGroupingSize--&quot;&gt;分组大小&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="44a9f549cf29b75acc2fdec3fc183e7f16568846" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;','&lt;/code&gt; flag is given then a &lt;a href=&quot;formatflagsconversionmismatchexception&quot;&gt;&lt;code&gt;FormatFlagsConversionMismatchException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">如果给定 &lt;code&gt;','&lt;/code&gt; 标志，&lt;a href=&quot;formatflagsconversionmismatchexception&quot;&gt; &lt;code&gt;FormatFlagsConversionMismatchException&lt;/code&gt; &lt;/a&gt;引发FormatFlagsConversionMismatchException。</target>
        </trans-unit>
        <trans-unit id="45726f7fab2e09c7f3869df2e50226749801e01e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;','&lt;/code&gt; flag is given, then an &lt;a href=&quot;formatflagsconversionmismatchexception&quot;&gt;&lt;code&gt;FormatFlagsConversionMismatchException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">如果给出 &lt;code&gt;','&lt;/code&gt; 标志，&lt;a href=&quot;formatflagsconversionmismatchexception&quot;&gt; &lt;code&gt;FormatFlagsConversionMismatchException&lt;/code&gt; &lt;/a&gt;引发FormatFlagsConversionMismatchException。</target>
        </trans-unit>
        <trans-unit id="970c69f921423c9cb9e926402bc01ce17c9690e0" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;'-'&lt;/code&gt; flag is not given, then the space padding will occur before the sign.</source>
          <target state="translated">如果未给出 &lt;code&gt;'-'&lt;/code&gt; 标志，则空格将在符号前出现。</target>
        </trans-unit>
        <trans-unit id="4999add0ec4ab7e8f065de52e1702ab41f20c0ce" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;'0'&lt;/code&gt; flag is given and the value is negative, then the zero padding will occur after the sign.</source>
          <target state="translated">如果给定了 &lt;code&gt;'0'&lt;/code&gt; 标志且该值为负，则零填充将在符号后发生。</target>
        </trans-unit>
        <trans-unit id="5c36904575776fe73769eda50759d8e13da3acc3" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;'0'&lt;/code&gt; flag is given then the output will be padded to the field width with leading zeros after the radix indicator or sign (if present).</source>
          <target state="translated">如果给定 &lt;code&gt;'0'&lt;/code&gt; 标志，则输出将在基数指示符或符号（如果存在）之后用前导零填充到字段宽度。</target>
        </trans-unit>
        <trans-unit id="b5e7f4a54ddb769b1293d2814dfdf865f8198b97" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;'0'&lt;/code&gt; flag is given then the output will be padded with leading zeros to the field width following any indication of sign.</source>
          <target state="translated">如果给定 &lt;code&gt;'0'&lt;/code&gt; 标志，则输出将在任何符号指示后填充前导零到字段宽度。</target>
        </trans-unit>
        <trans-unit id="e0f0743f520ad52ab8654c0fd8007d4814742634" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;'0'&lt;/code&gt; flag is given, then the locale-specific &lt;a href=&quot;../text/decimalformatsymbols#getZeroDigit()&quot;&gt;zero digits&lt;/a&gt; are inserted after the sign character, if any, and before the first non-zero digit, until the length of the string is equal to the requested field width.</source>
          <target state="translated">如果 &lt;code&gt;'0'&lt;/code&gt; 标志被给出，那么语言环境的具体的&lt;a href=&quot;../text/decimalformatsymbols#getZeroDigit()&quot;&gt;零位&lt;/a&gt;被符号字符之后插入，如果有的话，和第一非零数字之前，直到该字符串的长度等于所请求的字段宽度。</target>
        </trans-unit>
        <trans-unit id="ba1bcf00b5c45bf451134d21adaed5e63f1fcd56" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;'0'&lt;/code&gt; flag is given, then the locale-specific &lt;a href=&quot;../text/decimalformatsymbols#getZeroDigit--&quot;&gt;zero digits&lt;/a&gt; are inserted after the sign character, if any, and before the first non-zero digit, until the length of the string is equal to the requested field width.</source>
          <target state="translated">如果 &lt;code&gt;'0'&lt;/code&gt; 标志被给出，那么语言环境的具体的&lt;a href=&quot;../text/decimalformatsymbols#getZeroDigit--&quot;&gt;零位&lt;/a&gt;被符号字符之后插入，如果有的话，和第一非零数字之前，直到该字符串的长度等于所请求的字段宽度。</target>
        </trans-unit>
        <trans-unit id="e6f16828d0308872e7e04a7c1ddeb45e9f4f1750" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;(x,&amp;nbsp;y)&lt;/code&gt; point lies outside the grid, the following rules are used. The column index is returned as zero if &lt;code&gt;x&lt;/code&gt; lies to the left of the layout for a left-to-right container or to the right of the layout for a right-to-left container. The column index is returned as the number of columns if &lt;code&gt;x&lt;/code&gt; lies to the right of the layout in a left-to-right container or to the left in a right-to-left container. The row index is returned as zero if &lt;code&gt;y&lt;/code&gt; lies above the layout, and as the number of rows if &lt;code&gt;y&lt;/code&gt; lies below the layout. The orientation of a container is determined by its &lt;code&gt;ComponentOrientation&lt;/code&gt; property.</source>
          <target state="translated">如果 &lt;code&gt;(x,&amp;nbsp;y)&lt;/code&gt; 点位于网格外部，则使用以下规则。如果 &lt;code&gt;x&lt;/code&gt; 从左到右的容器位于布局的左侧，或者从右到左的容器位于布局的右侧，则列索引将返回零。如果 &lt;code&gt;x&lt;/code&gt; 在从左到右的容器中位于布局的右侧，或者在从右到左的容器中位于左侧，则以列数的形式返回列索引。行索引的返回零，如果 &lt;code&gt;y&lt;/code&gt; 位于上面的布局，并作为行数如果 &lt;code&gt;y&lt;/code&gt; 布局位于下方。容器的方向由其 &lt;code&gt;ComponentOrientation&lt;/code&gt; 属性确定。</target>
        </trans-unit>
        <trans-unit id="63ecf98d0ab81bb97ce68818ba3aa39c86211b49" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Agent_OnAttach[_L]&lt;/code&gt; function in the agent library returns an error then an &lt;a href=&quot;agentinitializationexception&quot;&gt;&lt;code&gt;AgentInitializationException&lt;/code&gt;&lt;/a&gt; is thrown. The return value from the &lt;code&gt;Agent_OnAttach[_L]&lt;/code&gt; can then be obtained by invoking the &lt;a href=&quot;agentinitializationexception#returnValue()&quot;&gt;&lt;code&gt;returnValue&lt;/code&gt;&lt;/a&gt; method on the exception.</source>
          <target state="translated">如果代理程序库中的 &lt;code&gt;Agent_OnAttach[_L]&lt;/code&gt; 函数返回错误，则抛出&lt;a href=&quot;agentinitializationexception&quot;&gt; &lt;code&gt;AgentInitializationException&lt;/code&gt; &lt;/a&gt;。然后可以通过在异常上调用&lt;a href=&quot;agentinitializationexception#returnValue()&quot;&gt; &lt;code&gt;returnValue&lt;/code&gt; &lt;/a&gt;方法来获取 &lt;code&gt;Agent_OnAttach[_L]&lt;/code&gt; 的返回值。</target>
        </trans-unit>
        <trans-unit id="9ecc4eb34ec8dfb382771373ad86df4d2c178e13" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Collection&lt;/code&gt; will be modified by one thread while another thread is calling a method of a Collection &lt;code&gt;CertStore&lt;/code&gt; that has been initialized with this &lt;code&gt;Collection&lt;/code&gt;, the &lt;code&gt;Collection&lt;/code&gt; must have fail-fast iterators.</source>
          <target state="translated">如果一个线程将修改 &lt;code&gt;Collection&lt;/code&gt; ，而另一个线程正在调用已使用此 &lt;code&gt;Collection&lt;/code&gt; 初始化的Collection &lt;code&gt;CertStore&lt;/code&gt; 的方法，则 &lt;code&gt;Collection&lt;/code&gt; 必须具有快速失败的迭代器。</target>
        </trans-unit>
        <trans-unit id="810e8374c563e183f8b4590c3bc968fbd81b2167" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;CompositeData&lt;/code&gt; came from an earlier version of &lt;em&gt;J&lt;/em&gt;, some items might not be present. In this case, the corresponding setters will not be called.</source>
          <target state="translated">如果 &lt;code&gt;CompositeData&lt;/code&gt; 来自&lt;em&gt;J&lt;/em&gt;的早期版本，则某些项目可能不存在。在这种情况下，将不会调用相应的二传手。</target>
        </trans-unit>
        <trans-unit id="71b4bf78e68bc6776b7a8f7a0eb4ed1d04a8d512" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Event&lt;/code&gt;'s type was not specified by initializing the event before the method was called.</source>
          <target state="translated">如果未通过在调用方法之前初始化事件来指定 &lt;code&gt;Event&lt;/code&gt; 的类型。</target>
        </trans-unit>
        <trans-unit id="203c00aa85f63e7b6b9375fddd15c02205fb7dda" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Event&lt;/code&gt;'s type was not specified by initializing the event before the method was called. Specification of the Event's type as &lt;code&gt;null&lt;/code&gt; or an empty string will also trigger this exception.</source>
          <target state="translated">如果未通过在调用方法之前初始化事件来指定 &lt;code&gt;Event&lt;/code&gt; 的类型。将事件类型指定为 &lt;code&gt;null&lt;/code&gt; 或空字符串也将触发此异常。</target>
        </trans-unit>
        <trans-unit id="02b4cc8da4d2810c0fbe1d7c64fd610170148d2b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;ExecuteExistingDelayedTasksAfterShutdownPolicy&lt;/code&gt; has been set &lt;code&gt;false&lt;/code&gt;, existing delayed tasks whose delays have not yet elapsed are cancelled. And unless the &lt;code&gt;
 ContinueExistingPeriodicTasksAfterShutdownPolicy&lt;/code&gt; has been set &lt;code&gt;true&lt;/code&gt;, future executions of existing periodic tasks will be cancelled.</source>
          <target state="translated">如果 &lt;code&gt;ExecuteExistingDelayedTasksAfterShutdownPolicy&lt;/code&gt; 设置为 &lt;code&gt;false&lt;/code&gt; ，则将取消尚未延迟的现有延迟任务。并且，除非将 &lt;code&gt; ContinueExistingPeriodicTasksAfterShutdownPolicy&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; ，否则将取消现有定期任务的将来执行。</target>
        </trans-unit>
        <trans-unit id="179c5197a088bdfb3577b89615e0f80069ec54a3" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;ExecuteExistingDelayedTasksAfterShutdownPolicy&lt;/code&gt; has been set &lt;code&gt;false&lt;/code&gt;, existing delayed tasks whose delays have not yet elapsed are cancelled. And unless the &lt;code&gt;ContinueExistingPeriodicTasksAfterShutdownPolicy&lt;/code&gt; has been set &lt;code&gt;true&lt;/code&gt;, future executions of existing periodic tasks will be cancelled.</source>
          <target state="translated">如果 &lt;code&gt;ExecuteExistingDelayedTasksAfterShutdownPolicy&lt;/code&gt; 设置为 &lt;code&gt;false&lt;/code&gt; ，则将取消尚未延迟的现有延迟任务。并且，除非将 &lt;code&gt;ContinueExistingPeriodicTasksAfterShutdownPolicy&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; ，否则将取消现有定期任务的将来执行。</target>
        </trans-unit>
        <trans-unit id="924b95b5bc360f5419eb164ad25c4917e3384c4f" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Graphics2D&lt;/code&gt; object cannot handle the curved segments that the &lt;code&gt;PathIterator&lt;/code&gt; object returns then it can call the alternate &lt;a href=&quot;shape#getPathIterator(java.awt.geom.AffineTransform,double)&quot;&gt;&lt;code&gt;getPathIterator&lt;/code&gt;&lt;/a&gt; method of &lt;code&gt;Shape&lt;/code&gt;, which flattens the &lt;code&gt;Shape&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Graphics2D&lt;/code&gt; 的对象不能处理所述弯曲段，所述 &lt;code&gt;PathIterator&lt;/code&gt; 对象返回然后它可以调用备用&lt;a href=&quot;shape#getPathIterator(java.awt.geom.AffineTransform,double)&quot;&gt; &lt;code&gt;getPathIterator&lt;/code&gt; &lt;/a&gt;的方法 &lt;code&gt;Shape&lt;/code&gt; ，其变平的 &lt;code&gt;Shape&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4d9438386cfe32fda0c1181ccd31aab76978f092" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;InvocationHandler&lt;/code&gt; is for an MXBean, then the parameters of a method are converted from the type declared in the MXBean interface into the corresponding mapped type, and the return value is converted from the mapped type into the declared type. For example, with the method</source>
          <target state="translated">如果 &lt;code&gt;InvocationHandler&lt;/code&gt; 用于MXBean，则将方法的参数从MXBean接口中声明的类型转换为相应的映射类型，并将返回值从映射类型转换为声明的类型。例如，用</target>
        </trans-unit>
        <trans-unit id="db17038cfaa4ef45c73437ed292d512029f6bfe8" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;JInternalFrame&lt;/code&gt; is not in maximized state, returns &lt;code&gt;getBounds()&lt;/code&gt;; otherwise, returns the bounds that the &lt;code&gt;JInternalFrame&lt;/code&gt; would be restored to.</source>
          <target state="translated">如果 &lt;code&gt;JInternalFrame&lt;/code&gt; 不在最大化状态，则返回 &lt;code&gt;getBounds()&lt;/code&gt; ; 否则，返回将 &lt;code&gt;JInternalFrame&lt;/code&gt; 还原到的边界。</target>
        </trans-unit>
        <trans-unit id="f060428dfdce4f587aa2a33814a603772ec95345" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;JLayer&lt;/code&gt;'s view component is not &lt;code&gt;null&lt;/code&gt;, this calls the view's &lt;code&gt;getBaseline()&lt;/code&gt; method.</source>
          <target state="translated">如果 &lt;code&gt;JLayer&lt;/code&gt; 的视图组件不为 &lt;code&gt;null&lt;/code&gt; ，则此方法将调用视图的 &lt;code&gt;getBaseline()&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="2d2acc95bb253287fb1fd9ad280f5e3c68a344b4" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;JLayer&lt;/code&gt;'s view component is not &lt;code&gt;null&lt;/code&gt;, this calls the view's &lt;code&gt;getBaseline()&lt;/code&gt; method. Otherwise, the default implementation is called.</source>
          <target state="translated">如果 &lt;code&gt;JLayer&lt;/code&gt; 的视图组件不为 &lt;code&gt;null&lt;/code&gt; ，则此方法将调用视图的 &lt;code&gt;getBaseline()&lt;/code&gt; 方法。否则，将调用默认实现。</target>
        </trans-unit>
        <trans-unit id="3f2bc6a4dfcf47dbe29117aa68de225f1c61e8cb" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;JLayer&lt;/code&gt;'s view component is not &lt;code&gt;null&lt;/code&gt;, this returns the result of the view's &lt;code&gt;getBaselineResizeBehavior()&lt;/code&gt; method.</source>
          <target state="translated">如果 &lt;code&gt;JLayer&lt;/code&gt; 的视图组件不为 &lt;code&gt;null&lt;/code&gt; ，则返回视图的 &lt;code&gt;getBaselineResizeBehavior()&lt;/code&gt; 方法的结果。</target>
        </trans-unit>
        <trans-unit id="1bd4ebb8a1743bab39929e4ec06130e5519f66ca" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;JLayer&lt;/code&gt;'s view component is not &lt;code&gt;null&lt;/code&gt;, this returns the result of the view's &lt;code&gt;getBaselineResizeBehavior()&lt;/code&gt; method. Otherwise, the default implementation is called.</source>
          <target state="translated">如果 &lt;code&gt;JLayer&lt;/code&gt; 的视图组件不为 &lt;code&gt;null&lt;/code&gt; ，则返回视图的 &lt;code&gt;getBaselineResizeBehavior()&lt;/code&gt; 方法的结果。否则，将调用默认实现。</target>
        </trans-unit>
        <trans-unit id="b88a2323263a45207c7b90c89107a58d6356d56a" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;JLayer&lt;/code&gt;'s view component is not &lt;code&gt;null&lt;/code&gt;, this returns the result of the view's &lt;code&gt;getMaximumSize()&lt;/code&gt; method.</source>
          <target state="translated">如果 &lt;code&gt;JLayer&lt;/code&gt; 的视图组件不为 &lt;code&gt;null&lt;/code&gt; ，则返回视图的 &lt;code&gt;getMaximumSize()&lt;/code&gt; 方法的结果。</target>
        </trans-unit>
        <trans-unit id="78f3308c92a131ac53ba0a2b91ae5625bc8378a8" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;JLayer&lt;/code&gt;'s view component is not &lt;code&gt;null&lt;/code&gt;, this returns the result of the view's &lt;code&gt;getMaximumSize()&lt;/code&gt; method. Otherwise, the default implementation is used.</source>
          <target state="translated">如果 &lt;code&gt;JLayer&lt;/code&gt; 的视图组件不为 &lt;code&gt;null&lt;/code&gt; ，则返回视图的 &lt;code&gt;getMaximumSize()&lt;/code&gt; 方法的结果。否则，将使用默认实现。</target>
        </trans-unit>
        <trans-unit id="30e2482d382c7844747a1e9c47c53ce8993e3afa" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;JLayer&lt;/code&gt;'s view component is not &lt;code&gt;null&lt;/code&gt;, this returns the result of the view's &lt;code&gt;getMinimalSize()&lt;/code&gt; method.</source>
          <target state="translated">如果 &lt;code&gt;JLayer&lt;/code&gt; 的视图组件不为 &lt;code&gt;null&lt;/code&gt; ，则返回视图的 &lt;code&gt;getMinimalSize()&lt;/code&gt; 方法的结果。</target>
        </trans-unit>
        <trans-unit id="cd6e2b2d459272e76855c9dfdd3c3d186a8512b9" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;JLayer&lt;/code&gt;'s view component is not &lt;code&gt;null&lt;/code&gt;, this returns the result of the view's &lt;code&gt;getMinimalSize()&lt;/code&gt; method. Otherwise, the default implementation is used.</source>
          <target state="translated">如果 &lt;code&gt;JLayer&lt;/code&gt; 的视图组件不为 &lt;code&gt;null&lt;/code&gt; ，则返回视图的 &lt;code&gt;getMinimalSize()&lt;/code&gt; 方法的结果。否则，将使用默认实现。</target>
        </trans-unit>
        <trans-unit id="3e114e0c18eb9a3a04e50b88c65e47b3d1177a2d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;JLayer&lt;/code&gt;'s view component is not &lt;code&gt;null&lt;/code&gt;, this returns the result of the view's &lt;code&gt;getPreferredSize()&lt;/code&gt; method.</source>
          <target state="translated">如果 &lt;code&gt;JLayer&lt;/code&gt; 的视图组件不为 &lt;code&gt;null&lt;/code&gt; ，则返回视图的 &lt;code&gt;getPreferredSize()&lt;/code&gt; 方法的结果。</target>
        </trans-unit>
        <trans-unit id="1909e9311585c50274c3f90139597ea7f32cfbeb" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;JLayer&lt;/code&gt;'s view component is not &lt;code&gt;null&lt;/code&gt;, this returns the result of the view's &lt;code&gt;getPreferredSize()&lt;/code&gt; method. Otherwise, the default implementation is used.</source>
          <target state="translated">如果 &lt;code&gt;JLayer&lt;/code&gt; 的视图组件不为 &lt;code&gt;null&lt;/code&gt; ，则返回视图的 &lt;code&gt;getPreferredSize()&lt;/code&gt; 方法的结果。否则，将使用默认实现。</target>
        </trans-unit>
        <trans-unit id="b773147646e5d6ae4684d585a997f76f520542ef" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;JMXServiceURL&lt;/code&gt; is:</source>
          <target state="translated">如果 &lt;code&gt;JMXServiceURL&lt;/code&gt; 为：</target>
        </trans-unit>
        <trans-unit id="3f268e97c59dcc626388a2e991c9c9562516a82d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;JMXServiceURL&lt;/code&gt; uses the directory syntax, as described above under &lt;a href=&quot;#directory&quot;&gt;&quot;connector addresses based on directory entries&quot;&lt;/a&gt;, then the client may obtain it as just explained, or client and server may both know the appropriate directory entry to use. For example, if the connector server for the Whatsit agent uses the entry &lt;code&gt;whatsit-agent-connector&lt;/code&gt; in the RMI registry on host &lt;code&gt;myhost&lt;/code&gt;, then client and server can both know that the appropriate &lt;code&gt;JMXServiceURL&lt;/code&gt; is:</source>
          <target state="translated">如果 &lt;code&gt;JMXServiceURL&lt;/code&gt; 使用目录语法（如上文&lt;a href=&quot;#directory&quot;&gt;&amp;ldquo;基于目录条目的连接器地址&amp;rdquo;所述）&lt;/a&gt;，则客户端可以如刚刚解释的那样获取它，或者客户端和服务器都可以知道要使用的适当目录条目。例如，如果Whatsit代理的连接器服务器在主机 &lt;code&gt;myhost&lt;/code&gt; 的RMI注册表中使用条目 &lt;code&gt;whatsit-agent-connector&lt;/code&gt; ，则客户端和服务器都可以知道适当的 &lt;code&gt;JMXServiceURL&lt;/code&gt; 为：</target>
        </trans-unit>
        <trans-unit id="3f826af6b5dd95bfc92e77f04fdf460591da5f81" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;JMXServiceURL&lt;/code&gt; was generated by the server, as described above under &lt;a href=&quot;#servergen&quot;&gt;&quot;connector addresses generated by the server&quot;&lt;/a&gt;, then the client will need to obtain it directly or indirectly from the server. Typically, the server makes the &lt;code&gt;JMXServiceURL&lt;/code&gt; available by storing it in a file or a lookup service.</source>
          <target state="translated">如果 &lt;code&gt;JMXServiceURL&lt;/code&gt; 是由服务器生成的，如上面&lt;a href=&quot;#servergen&quot;&gt;&amp;ldquo;服务器生成的连接器地址&amp;rdquo;下所述&lt;/a&gt;，则客户端将需要直接或间接从服务器获取它。通常，服务器通过将 &lt;code&gt;JMXServiceURL&lt;/code&gt; 存储在文件或查找服务中来使其可用。</target>
        </trans-unit>
        <trans-unit id="19e53ac3ee0ca858d684bd217c73cfeb534f1225" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;LSParser&lt;/code&gt; is a synchronous &lt;code&gt;LSParser&lt;/code&gt;, the newly created and populated &lt;code&gt;Document&lt;/code&gt; is returned, or &lt;code&gt;null&lt;/code&gt; if an error occured. If the &lt;code&gt;LSParser&lt;/code&gt; is asynchronous, &lt;code&gt;null&lt;/code&gt; is returned since the document object may not yet be constructed when this method returns.</source>
          <target state="translated">如果 &lt;code&gt;LSParser&lt;/code&gt; 是同步 &lt;code&gt;LSParser&lt;/code&gt; ，则返回新创建并填充的 &lt;code&gt;Document&lt;/code&gt; ；如果发生错误，则返回 &lt;code&gt;null&lt;/code&gt; 。如果 &lt;code&gt;LSParser&lt;/code&gt; 是异步的，则返回 &lt;code&gt;null&lt;/code&gt; ，因为此方法返回时可能尚未构造文档对象。</target>
        </trans-unit>
        <trans-unit id="7fc52b341e17306f0b31074b4f7a8dcfcbafb512" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;LSParser&lt;/code&gt; is a synchronous &lt;code&gt;LSParser&lt;/code&gt;, the newly created and populated &lt;code&gt;Document&lt;/code&gt; is returned. If the &lt;code&gt;LSParser&lt;/code&gt; is asynchronous, &lt;code&gt;null&lt;/code&gt; is returned since the document object may not yet be constructed when this method returns.</source>
          <target state="translated">如果 &lt;code&gt;LSParser&lt;/code&gt; 是同步 &lt;code&gt;LSParser&lt;/code&gt; ，则返回新创建并填充的 &lt;code&gt;Document&lt;/code&gt; 。如果 &lt;code&gt;LSParser&lt;/code&gt; 是异步的，则返回 &lt;code&gt;null&lt;/code&gt; ，因为此方法返回时可能尚未构造文档对象。</target>
        </trans-unit>
        <trans-unit id="b5e161a884b01a34270547339690293148ba8fa6" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;LayoutManager&lt;/code&gt; installed on this container is an instance of the &lt;code&gt;LayoutManager2&lt;/code&gt; interface, then the &lt;a href=&quot;layoutmanager2#invalidateLayout(java.awt.Container)&quot;&gt;&lt;code&gt;LayoutManager2.invalidateLayout(Container)&lt;/code&gt;&lt;/a&gt; method is invoked on it supplying this &lt;code&gt;Container&lt;/code&gt; as the argument.</source>
          <target state="translated">如果 &lt;code&gt;LayoutManager&lt;/code&gt; 的安装在此容器上是的一个实例 &lt;code&gt;LayoutManager2&lt;/code&gt; 中接口，则&lt;a href=&quot;layoutmanager2#invalidateLayout(java.awt.Container)&quot;&gt; &lt;code&gt;LayoutManager2.invalidateLayout(Container)&lt;/code&gt; &lt;/a&gt;方法被调用就可以提供这种 &lt;code&gt;Container&lt;/code&gt; 作为参数。</target>
        </trans-unit>
        <trans-unit id="e3f171d07666393092d63f7170ed5ec052f7118d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Level&lt;/code&gt; of the specified logger is &lt;code&gt;null&lt;/code&gt;, which means that this logger's effective level is inherited from its parent, an empty string will be returned.</source>
          <target state="translated">如果指定记录器的 &lt;code&gt;Level&lt;/code&gt; 为 &lt;code&gt;null&lt;/code&gt; ，这意味着该记录器的有效级别是从其父级继承的，则将返回一个空字符串。</target>
        </trans-unit>
        <trans-unit id="6ebbc0e52293490f8f9b76660317e3c20fc9979e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;MBeanPermission&lt;/code&gt; check succeeds, the MBean's class is validated by checking that its &lt;a href=&quot;../../../java.base/java/security/protectiondomain&quot;&gt;&lt;code&gt;ProtectionDomain&lt;/code&gt;&lt;/a&gt; implies &lt;a href=&quot;mbeantrustpermission#%3Cinit%3E(java.lang.String)&quot;&gt;&lt;code&gt;MBeanTrustPermission(&quot;register&quot;)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;MBeanPermission&lt;/code&gt; 检查成功，则通过检查MBean的&lt;a href=&quot;../../../java.base/java/security/protectiondomain&quot;&gt; &lt;code&gt;ProtectionDomain&lt;/code&gt; &lt;/a&gt;隐含&lt;a href=&quot;mbeantrustpermission#%3Cinit%3E(java.lang.String)&quot;&gt; &lt;code&gt;MBeanTrustPermission(&quot;register&quot;)&lt;/code&gt; &lt;/a&gt;来验证MBean的类。</target>
        </trans-unit>
        <trans-unit id="458d82c56d9fb33c66e562fe6ab97aea8cc80904" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;MBeanPermission&lt;/code&gt; check succeeds, the MBean's class is validated by checking that its &lt;a href=&quot;../../java/security/protectiondomain&quot;&gt;&lt;code&gt;ProtectionDomain&lt;/code&gt;&lt;/a&gt; implies &lt;a href=&quot;mbeantrustpermission#MBeanTrustPermission-java.lang.String-&quot;&gt;&lt;code&gt;MBeanTrustPermission(&quot;register&quot;)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;MBeanPermission&lt;/code&gt; 检查成功，则通过检查MBean的&lt;a href=&quot;../../java/security/protectiondomain&quot;&gt; &lt;code&gt;ProtectionDomain&lt;/code&gt; &lt;/a&gt;隐含&lt;a href=&quot;mbeantrustpermission#MBeanTrustPermission-java.lang.String-&quot;&gt; &lt;code&gt;MBeanTrustPermission(&quot;register&quot;)&lt;/code&gt; &lt;/a&gt;来验证MBean的类。</target>
        </trans-unit>
        <trans-unit id="f890b35cefa98c94269d1a9a764077652d426848" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Object&lt;/code&gt; to be tested is not a &lt;code&gt;QName&lt;/code&gt; or is &lt;code&gt;null&lt;/code&gt;, then this method returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果要测试的 &lt;code&gt;Object&lt;/code&gt; 不是 &lt;code&gt;QName&lt;/code&gt; 或为 &lt;code&gt;null&lt;/code&gt; ，则此方法返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="021af7bb755cf93cf54c9f5f352c98d0f4ca4622" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;ObservedAttribute&lt;/code&gt; contains more than one period, for example &lt;code&gt;&quot;ConnectionPool.connectionStats.length&quot;&lt;/code&gt;, then the above rules are applied iteratively. Here,</source>
          <target state="translated">如果 &lt;code&gt;ObservedAttribute&lt;/code&gt; 包含多个句点，例如 &lt;code&gt;&quot;ConnectionPool.connectionStats.length&quot;&lt;/code&gt; ，则上述规则将迭代应用。这里，</target>
        </trans-unit>
        <trans-unit id="ea89dee9c534a6485cf68abb91d3ac324905d7e6" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;RMIServerImpl&lt;/code&gt; was bound to a JNDI directory by the &lt;a href=&quot;#start()&quot;&gt;&lt;code&gt;start&lt;/code&gt;&lt;/a&gt; method, it is unbound from the directory by this method.</source>
          <target state="translated">如果 &lt;code&gt;RMIServerImpl&lt;/code&gt; 通过&lt;a href=&quot;#start()&quot;&gt; &lt;code&gt;start&lt;/code&gt; &lt;/a&gt;方法绑定到JNDI目录，则通过该方法将其与目录解除绑定。</target>
        </trans-unit>
        <trans-unit id="7cb7f5f842a73d2190c2e8a4561e728aa057bb8f" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;RMIServerImpl&lt;/code&gt; was bound to a JNDI directory by the &lt;a href=&quot;rmiconnectorserver#start--&quot;&gt;&lt;code&gt;start&lt;/code&gt;&lt;/a&gt; method, it is unbound from the directory by this method.</source>
          <target state="translated">如果 &lt;code&gt;RMIServerImpl&lt;/code&gt; 通过&lt;a href=&quot;rmiconnectorserver#start--&quot;&gt; &lt;code&gt;start&lt;/code&gt; &lt;/a&gt;方法绑定到JNDI目录，则通过此方法将其与目录解除绑定。</target>
        </trans-unit>
        <trans-unit id="5e181fd53600dcd77e327b5091e7925935330a6f" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;ResolverStyle&lt;/code&gt; is &lt;code&gt;LENIENT&lt;/code&gt; and a time is parsed without a date, then the complete result of the parse consists of a &lt;code&gt;LocalTime&lt;/code&gt; and an excess &lt;code&gt;Period&lt;/code&gt; in days.</source>
          <target state="translated">如果 &lt;code&gt;ResolverStyle&lt;/code&gt; 为 &lt;code&gt;LENIENT&lt;/code&gt; 并且解析的时间不带日期，则解析的完整结果包括 &lt;code&gt;LocalTime&lt;/code&gt; 和以天为单位的多余 &lt;code&gt;Period&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="801480d1156ab6ed42af2047f9f67f81a9ed2968" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;ResolverStyle&lt;/code&gt; is &lt;code&gt;SMART&lt;/code&gt; and a time is parsed without a date where the time is 24:00:00, then the complete result of the parse consists of a &lt;code&gt;LocalTime&lt;/code&gt; of 00:00:00 and an excess &lt;code&gt;Period&lt;/code&gt; of one day.</source>
          <target state="translated">如果 &lt;code&gt;ResolverStyle&lt;/code&gt; 是 &lt;code&gt;SMART&lt;/code&gt; 以及其中时间是24:00:00，一时间不注日期的解析，则解析的完整结果由的 &lt;code&gt;LocalTime&lt;/code&gt; 的00:00:00和过量 &lt;code&gt;Period&lt;/code&gt; 一天。</target>
        </trans-unit>
        <trans-unit id="ea383b2cd69ecf52b9ec7ee59229284018a85985" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;String&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; or does not conform to &lt;a href=&quot;#toString()&quot;&gt;&lt;code&gt;QName.toString()&lt;/code&gt;&lt;/a&gt; formatting, an &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown.</source>
          <target state="translated">如果 &lt;code&gt;String&lt;/code&gt; 为 &lt;code&gt;null&lt;/code&gt; 或不符合&lt;a href=&quot;#toString()&quot;&gt; &lt;code&gt;QName.toString()&lt;/code&gt; &lt;/a&gt;格式，则抛出 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="679d594737099d64f4c8a7bd67a360d72bcf8bdd" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Type&lt;/code&gt; is a parameterized type, the &lt;code&gt;Type&lt;/code&gt; object returned must accurately reflect the actual type parameters used in the source code.</source>
          <target state="translated">如果 &lt;code&gt;Type&lt;/code&gt; 是参数化类型，则返回的 &lt;code&gt;Type&lt;/code&gt; 对象必须准确反映源代码中使用的实际类型参数。</target>
        </trans-unit>
        <trans-unit id="9c0eea94ebf724c08a182505b07f4b40fc26c467" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;UndoManager&lt;/code&gt; contains edits it will call &lt;code&gt;addEdit&lt;/code&gt; on the current edit passing in the new edit as the argument. If &lt;code&gt;addEdit&lt;/code&gt; returns true the new edit is assumed to have been incorporated into the current edit and the new edit will not be added to the list of current edits. Edits can use &lt;code&gt;addEdit&lt;/code&gt; as a way for smaller edits to be incorporated into a larger edit and treated as a single edit.</source>
          <target state="translated">如果 &lt;code&gt;UndoManager&lt;/code&gt; 包含编辑，它将在当前编辑上调用 &lt;code&gt;addEdit&lt;/code&gt; ，并将新编辑作为参数传递。如果 &lt;code&gt;addEdit&lt;/code&gt; 返回true，则假定新编辑已合并到当前编辑中，并且新编辑不会添加到当前编辑列表中。编辑可以使用 &lt;code&gt;addEdit&lt;/code&gt; 作为将较小的编辑合并到较大的编辑中并视为单个编辑的一种方式。</target>
        </trans-unit>
        <trans-unit id="35ff53d86b4bc68486f63c50ba3db4d56f3b6812" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;ZoneId&lt;/code&gt; to be used is a &lt;code&gt;ZoneOffset&lt;/code&gt;, this method is equivalent to &lt;a href=&quot;#of(java.time.LocalDateTime,java.time.ZoneId)&quot;&gt;&lt;code&gt;of(LocalDateTime, ZoneId)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;ZoneId&lt;/code&gt; 使用是 &lt;code&gt;ZoneOffset&lt;/code&gt; ，该方法等效于&lt;a href=&quot;#of(java.time.LocalDateTime,java.time.ZoneId)&quot;&gt; &lt;code&gt;of(LocalDateTime, ZoneId)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="be1a0f77a615842bdf82ef7b9ebede6a9bce0b3f" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;ZoneId&lt;/code&gt; to be used is a &lt;code&gt;ZoneOffset&lt;/code&gt;, this method is equivalent to &lt;a href=&quot;zoneddatetime#of-java.time.LocalDateTime-java.time.ZoneId-&quot;&gt;&lt;code&gt;of(LocalDateTime, ZoneId)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;ZoneId&lt;/code&gt; 使用是 &lt;code&gt;ZoneOffset&lt;/code&gt; ，该方法等效于&lt;a href=&quot;zoneddatetime#of-java.time.LocalDateTime-java.time.ZoneId-&quot;&gt; &lt;code&gt;of(LocalDateTime, ZoneId)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9d86f839b1695227093964559a355f46055cbd60" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;abort&lt;/code&gt; phase fails for any reason, then this method propagates the original exception thrown either during the &lt;code&gt;login&lt;/code&gt; phase or the &lt;code&gt;commit&lt;/code&gt; phase. In either case, the overall authentication fails.</source>
          <target state="translated">如果 &lt;code&gt;abort&lt;/code&gt; 阶段由于任何原因而失败，则此方法将传播在 &lt;code&gt;login&lt;/code&gt; 阶段或 &lt;code&gt;commit&lt;/code&gt; 阶段抛出的原始异常。在任何一种情况下，整体身份验证都会失败。</target>
        </trans-unit>
        <trans-unit id="a7b16f00ee4043e4aeba76ef6283f2971eb30418" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;acceptor&lt;/code&gt; function is not successfully invoked, then the push promise is rejected. The &lt;code&gt;acceptor&lt;/code&gt; function will throw an &lt;code&gt;IllegalStateException&lt;/code&gt; if invoked more than once.</source>
          <target state="translated">如果没有成功调用 &lt;code&gt;acceptor&lt;/code&gt; 函数，则推送承诺将被拒绝。该 &lt;code&gt;acceptor&lt;/code&gt; 功能会抛出一个 &lt;code&gt;IllegalStateException&lt;/code&gt; 异常，如果多次调用。</target>
        </trans-unit>
        <trans-unit id="446c80fa5bc5f4e37afc5fc9e155b09818c5562f" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;addAll()&lt;/code&gt; operation throws an exception, the effect on this attribute set's state is implementation dependent; elements from the specified set before the point of the exception may or may not have been added to this attribute set.</source>
          <target state="translated">如果 &lt;code&gt;addAll()&lt;/code&gt; 操作引发异常，则此属性集状态的影响取决于实现；异常点之前指定集合中的元素可能已添加或可能未添加到此属性集。</target>
        </trans-unit>
        <trans-unit id="04ef5598f3ce002caa707d0e8dab5fc3e129e43c" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;addAll(AttributeSet)&lt;/code&gt; operation throws an exception, the effect on this attribute set's state is implementation dependent; elements from the specified set before the point of the exception may or may not have been added to this attribute set.</source>
          <target state="translated">如果 &lt;code&gt;addAll(AttributeSet)&lt;/code&gt; 操作引发异常，则对该属性集状态的影响取决于实现；异常点之前指定集合中的元素可能已添加或可能未添加到此属性集。</target>
        </trans-unit>
        <trans-unit id="9c0511263cbc485e9efb3be19eb199baa7484f96" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;algorithm&lt;/code&gt; parameter is non-null or non-empty, the endpoint identification/verification procedures must be handled during SSL/TLS handshaking. This is to prevent man-in-the-middle attacks.</source>
          <target state="translated">如果 &lt;code&gt;algorithm&lt;/code&gt; 参数为非null或非空，则必须在SSL / TLS握手期间处理端点标识/验证过程。这是为了防止中间人攻击。</target>
        </trans-unit>
        <trans-unit id="6834dc9ff0b8ff599b86ecc51718d6f5b5574c58" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;algorithm&lt;/code&gt; parameter is non-null or non-empty, the endpoint identification/verification procedures must be handled during SSL/TLS/DTLS handshaking. This is to prevent man-in-the-middle attacks.</source>
          <target state="translated">如果 &lt;code&gt;algorithm&lt;/code&gt; 参数为非null或非空，则必须在SSL / TLS / DTLS握手过程中处理端点标识/验证过程。这是为了防止中间人攻击。</target>
        </trans-unit>
        <trans-unit id="ce642f2bb7f80adee08e960922be3c55ad9db8fc" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;attributes&lt;/code&gt; parameter contains an &lt;code&gt;Attribute&lt;/code&gt; whose category is the same as the &lt;code&gt;category&lt;/code&gt; parameter, the service must ignore this attribute in the &lt;code&gt;AttributeSet&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;attributes&lt;/code&gt; 参数包含一个类别与 &lt;code&gt;category&lt;/code&gt; 参数相同的 &lt;code&gt;Attribute&lt;/code&gt; ，则服务必须在 &lt;code&gt;AttributeSet&lt;/code&gt; 中忽略此属性。</target>
        </trans-unit>
        <trans-unit id="df2ce529fb9d0af1fa8bdee431df9ad0c85e4344" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;attributes&lt;/code&gt; parameter contains an Attribute whose category is the same as the &lt;code&gt;category&lt;/code&gt; parameter, the service must ignore this attribute in the AttributeSet.</source>
          <target state="translated">如果 &lt;code&gt;attributes&lt;/code&gt; 参数包含一个类别与 &lt;code&gt;category&lt;/code&gt; 参数相同的Attribute ，则服务必须在AttributeSet中忽略该属性。</target>
        </trans-unit>
        <trans-unit id="98b6741e1086600d52bcba89af328ea50edfba2c" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;axis&lt;/code&gt; parameter is neither &lt;code&gt;View.X_AXIS&lt;/code&gt; nor &lt;code&gt;View.Y_AXIS&lt;/code&gt;, &lt;a href=&quot;../../../../../java.base/java/lang/illegalargumentexception&quot;&gt;&lt;code&gt;IllegalArgumentException&lt;/code&gt;&lt;/a&gt; is thrown. If the &lt;code&gt;r&lt;/code&gt; parameter is &lt;code&gt;null,&lt;/code&gt; a new &lt;code&gt;SizeRequirements&lt;/code&gt; object is created, otherwise the supplied &lt;code&gt;SizeRequirements&lt;/code&gt; object is returned.</source>
          <target state="translated">如果 &lt;code&gt;axis&lt;/code&gt; 参数既不是 &lt;code&gt;View.X_AXIS&lt;/code&gt; 也不是 &lt;code&gt;View.Y_AXIS&lt;/code&gt; ，则抛出&lt;a href=&quot;../../../../../java.base/java/lang/illegalargumentexception&quot;&gt; &lt;code&gt;IllegalArgumentException&lt;/code&gt; &lt;/a&gt;。如果 &lt;code&gt;r&lt;/code&gt; 参数为 &lt;code&gt;null,&lt;/code&gt; 则创建一个新的 &lt;code&gt;SizeRequirements&lt;/code&gt; 对象，否则返回提供的 &lt;code&gt;SizeRequirements&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="560ee03306807fcb6258a99873dd7c023d6a7244" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;axis&lt;/code&gt; parameter is neither &lt;code&gt;View.X_AXIS&lt;/code&gt; nor &lt;code&gt;View.Y_AXIS&lt;/code&gt;, &lt;a href=&quot;../../../../java.base/java/lang/illegalargumentexception&quot;&gt;&lt;code&gt;IllegalArgumentException&lt;/code&gt;&lt;/a&gt; is thrown. If the &lt;code&gt;r&lt;/code&gt; parameter is &lt;code&gt;null,&lt;/code&gt; a new &lt;code&gt;SizeRequirements&lt;/code&gt; object is created, otherwise the supplied &lt;code&gt;SizeRequirements&lt;/code&gt; object is returned.</source>
          <target state="translated">如果 &lt;code&gt;axis&lt;/code&gt; 参数既不是 &lt;code&gt;View.X_AXIS&lt;/code&gt; 也不是 &lt;code&gt;View.Y_AXIS&lt;/code&gt; ，则抛出&lt;a href=&quot;../../../../java.base/java/lang/illegalargumentexception&quot;&gt; &lt;code&gt;IllegalArgumentException&lt;/code&gt; &lt;/a&gt;。如果 &lt;code&gt;r&lt;/code&gt; 参数为 &lt;code&gt;null,&lt;/code&gt; 则创建一个新的 &lt;code&gt;SizeRequirements&lt;/code&gt; 对象，否则返回提供的 &lt;code&gt;SizeRequirements&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="717cef07fc5b446c1f7069da0b2b9e9376ef7862" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;body&lt;/code&gt; handle returns a non-&lt;code&gt;void&lt;/code&gt; type &lt;code&gt;V&lt;/code&gt;, a leading loop iteration variable of that type is also present. This variable is initialized using the optional &lt;code&gt;init&lt;/code&gt; handle, or to the &lt;a href=&quot;#empty(java.lang.invoke.MethodType)&quot;&gt;default value&lt;/a&gt; of type &lt;code&gt;V&lt;/code&gt; if that handle is &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;body&lt;/code&gt; 句柄返回非 &lt;code&gt;void&lt;/code&gt; 类型 &lt;code&gt;V&lt;/code&gt; ，则还将存在该类型的前导循环迭代变量。该变量使用可选的 &lt;code&gt;init&lt;/code&gt; 句柄初始化，或者如果该句柄为 &lt;code&gt;null&lt;/code&gt; ，则初始化为类型 &lt;code&gt;V&lt;/code&gt; 的&lt;a href=&quot;#empty(java.lang.invoke.MethodType)&quot;&gt;默认值&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="66b2ac942fdab810011fedc70461bf42a1dedd98" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;boolean&lt;/code&gt; argument is &lt;code&gt;false&lt;/code&gt;, this method causes the virtual machine to stop performing the detailed instruction trace it is performing.</source>
          <target state="translated">如果 &lt;code&gt;boolean&lt;/code&gt; 参数为 &lt;code&gt;false&lt;/code&gt; ，则此方法导致虚拟机停止执行其正在执行的详细指令跟踪。</target>
        </trans-unit>
        <trans-unit id="88001e51dd6c79b8369de89a8cbe2fdfe3865e70" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;char&lt;/code&gt; value at &lt;code&gt;(index - 1)&lt;/code&gt; is in the low-surrogate range, &lt;code&gt;(index - 2)&lt;/code&gt; is not negative, and the &lt;code&gt;char&lt;/code&gt; value at &lt;code&gt;(index -
 2)&lt;/code&gt; is in the high-surrogate range, then the supplementary code point value of the surrogate pair is returned. If the &lt;code&gt;char&lt;/code&gt; value at &lt;code&gt;index -
 1&lt;/code&gt; is an unpaired low-surrogate or a high-surrogate, the surrogate value is returned.</source>
          <target state="translated">如果 &lt;code&gt;(index - 1)&lt;/code&gt; 处的 &lt;code&gt;char&lt;/code&gt; 值在低代理范围内， &lt;code&gt;(index - 2)&lt;/code&gt; 不为负，并且 &lt;code&gt;(index - 2)&lt;/code&gt; 处的 &lt;code&gt;char&lt;/code&gt; 值在高代理范围内，则补充代码点返回代理对的值。如果 &lt;code&gt;index - 1&lt;/code&gt; 处的 &lt;code&gt;char&lt;/code&gt; 值是未配对的低代理或高代理，则返回代理值。</target>
        </trans-unit>
        <trans-unit id="4dc1506abc2a5f78b19fe3dd96f18038b15e4e22" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;char&lt;/code&gt; value specified at the given index is in the high-surrogate range, the following index is less than the length of this &lt;code&gt;String&lt;/code&gt;, and the &lt;code&gt;char&lt;/code&gt; value at the following index is in the low-surrogate range, then the supplementary code point corresponding to this surrogate pair is returned. Otherwise, the &lt;code&gt;char&lt;/code&gt; value at the given index is returned.</source>
          <target state="translated">如果在给定索引处指定的 &lt;code&gt;char&lt;/code&gt; 值在高代理范围内，则以下索引小于此 &lt;code&gt;String&lt;/code&gt; 的长度，并且在随后索引处的 &lt;code&gt;char&lt;/code&gt; 值在低代理范围内，则补充代码点返回与此代理对相对应。否则，将返回给定索引处的 &lt;code&gt;char&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="e0c3a606e3f3d827b22e0257098f87d4bbd176eb" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;char&lt;/code&gt; value specified at the given index is in the high-surrogate range, the following index is less than the length of this sequence, and the &lt;code&gt;char&lt;/code&gt; value at the following index is in the low-surrogate range, then the supplementary code point corresponding to this surrogate pair is returned. Otherwise, the &lt;code&gt;char&lt;/code&gt; value at the given index is returned.</source>
          <target state="translated">如果在给定索引处指定的 &lt;code&gt;char&lt;/code&gt; 值在高代理范围内，则后续索引小于此序列的长度，并且在随后索引处的 &lt;code&gt;char&lt;/code&gt; 值在低代理范围内，则补充代码点返回与此代理对相对应。否则，将返回给定索引处的 &lt;code&gt;char&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="adfa6cd0e81b003e1bb2d5b808729dc1489e6300" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;char&lt;/code&gt; value specified by the index is a &lt;a href=&quot;../../../../java.base/java/lang/character#unicode&quot;&gt;surrogate&lt;/a&gt;, the surrogate value is returned.</source>
          <target state="translated">如果 &lt;code&gt;char&lt;/code&gt; 由索引指定的值是一个&lt;a href=&quot;../../../../java.base/java/lang/character#unicode&quot;&gt;替代&lt;/a&gt;，则返回所述替代值。</target>
        </trans-unit>
        <trans-unit id="7059bfb26c628d831ae809e02477cb1879e60f94" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;char&lt;/code&gt; value specified by the index is a &lt;a href=&quot;character#unicode&quot;&gt;surrogate&lt;/a&gt;, the surrogate value is returned.</source>
          <target state="translated">如果索引指定的 &lt;code&gt;char&lt;/code&gt; 值是&lt;a href=&quot;character#unicode&quot;&gt;代理&lt;/a&gt;，则返回代理值。</target>
        </trans-unit>
        <trans-unit id="8250d512b905f35c6a410fcb5609b7900e346a5b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;commit&lt;/code&gt; phase of the authentication process fails, then the overall authentication fails and this method invokes the &lt;code&gt;abort&lt;/code&gt; method for each configured &lt;code&gt;LoginModule&lt;/code&gt;.</source>
          <target state="translated">如果身份验证过程的 &lt;code&gt;commit&lt;/code&gt; 阶段失败，则整个身份验证将失败，并且此方法将为每个已配置的 &lt;code&gt;LoginModule&lt;/code&gt; 调用 &lt;code&gt;abort&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="84555e61977552659f8d8d7542bd52057f6a2286" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;connect&lt;/code&gt; method is called when the connection has already been opened (indicated by the &lt;code&gt;connected&lt;/code&gt; field having the value &lt;code&gt;true&lt;/code&gt;), the call is ignored.</source>
          <target state="translated">如果在已经打开连接时调用 &lt;code&gt;connect&lt;/code&gt; 方法（由 &lt;code&gt;connected&lt;/code&gt; 字段表示值为 &lt;code&gt;true&lt;/code&gt; ），则该调用将被忽略。</target>
        </trans-unit>
        <trans-unit id="342ba2fb4627294d3b781daa9697b718b5c068d6" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;constraints&lt;/code&gt; object is &lt;code&gt;null&lt;/code&gt;, the component is added in the first available position (left/top if open, else right/bottom).</source>
          <target state="translated">如果 &lt;code&gt;constraints&lt;/code&gt; 对象为 &lt;code&gt;null&lt;/code&gt; ，则将组件添加到第一个可用位置（如果打开，则在左侧/顶部，否则在右侧/底部）。</target>
        </trans-unit>
        <trans-unit id="671e297a3a1ea6f0c42770e029c80abaa60e1bfb" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;constraints&lt;/code&gt; parameter is non-null, every cryptographic algorithm, key and algorithm parameters used in the SSL/TLS handshake must be permitted by the constraints.</source>
          <target state="translated">如果 &lt;code&gt;constraints&lt;/code&gt; 参数为非null，则约束必须允许SSL / TLS握手中使用的每个加密算法，密钥和算法参数。</target>
        </trans-unit>
        <trans-unit id="b40b2d9ff34a0913ffad16fe301b6eeb61865ff0" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;constraints&lt;/code&gt; parameter is non-null, every cryptographic algorithm, key and algorithm parameters used in the SSL/TLS/DTLS handshake must be permitted by the constraints.</source>
          <target state="translated">如果 &lt;code&gt;constraints&lt;/code&gt; 参数为非null，那么约束必须允许SSL / TLS / DTLS握手中使用的每个加密算法，密钥和算法参数。</target>
        </trans-unit>
        <trans-unit id="6a5dce44bc4531313d43efc02c3d4e5307173391" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;deep&lt;/code&gt; option was set to &lt;code&gt;true&lt;/code&gt;, the descendants of the source &lt;code&gt;DocumentFragment&lt;/code&gt; are recursively imported and the resulting nodes reassembled under the imported &lt;code&gt;DocumentFragment&lt;/code&gt; to form the corresponding subtree. Otherwise, this simply generates an empty &lt;code&gt;DocumentFragment&lt;/code&gt;.</source>
          <target state="translated">如果将 &lt;code&gt;deep&lt;/code&gt; 选项设置为 &lt;code&gt;true&lt;/code&gt; ，则将递归地导入源 &lt;code&gt;DocumentFragment&lt;/code&gt; 的后代，并且在导入的 &lt;code&gt;DocumentFragment&lt;/code&gt; 下重新组合结果节点，以形成相应的子树。否则，这只会​​生成一个空的 &lt;code&gt;DocumentFragment&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="16c20fefbf5f84e3a9d83640712edb423384c25b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;defaultLoader&lt;/code&gt; argument is non-&lt;code&gt;null&lt;/code&gt; and all of the named interfaces can be resolved through that loader, then,</source>
          <target state="translated">如果 &lt;code&gt;defaultLoader&lt;/code&gt; 参数为非 &lt;code&gt;null&lt;/code&gt; ,并且可以通过该加载器解析所有命名接口，则，</target>
        </trans-unit>
        <trans-unit id="b0dd399ffadc3a633c7172c0f219386bda780906" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;defaultLoader&lt;/code&gt; argument is non-&lt;code&gt;null&lt;/code&gt;, it first attempts to load the class with the specified &lt;code&gt;name&lt;/code&gt; using the &lt;code&gt;defaultLoader&lt;/code&gt;, such as by evaluating</source>
          <target state="translated">如果 &lt;code&gt;defaultLoader&lt;/code&gt; 参数为非 &lt;code&gt;null&lt;/code&gt; ，则它首先尝试使用 &lt;code&gt;defaultLoader&lt;/code&gt; 加载具有指定 &lt;code&gt;name&lt;/code&gt; 的类，例如通过求值</target>
        </trans-unit>
        <trans-unit id="e999b0a3f9b176b6320891b00b86e62b47b692fe" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;dereference&lt;/code&gt; method of user-specified &lt;code&gt;
 URIDereferencer&lt;/code&gt;s returns &lt;code&gt;NodeSetData&lt;/code&gt; objects, the &lt;code&gt;iterator&lt;/code&gt; method MUST return an iteration over objects of type &lt;code&gt;
 org.w3c.dom.Node&lt;/code&gt;.</source>
          <target state="translated">如果用户指定的 &lt;code&gt; URIDereferencer&lt;/code&gt; 的 &lt;code&gt;dereference&lt;/code&gt; 方法返回 &lt;code&gt;NodeSetData&lt;/code&gt; 对象，则 &lt;code&gt;iterator&lt;/code&gt; 方法务必返回对 &lt;code&gt; org.w3c.dom.Node&lt;/code&gt; 类型的对象的迭代。</target>
        </trans-unit>
        <trans-unit id="44563c51972a22c15c4aac96132c92755f5fb940" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;directory&lt;/code&gt; argument is &lt;code&gt;null&lt;/code&gt; then the system-dependent default temporary-file directory will be used. The default temporary-file directory is specified by the system property &lt;code&gt;java.io.tmpdir&lt;/code&gt;. On UNIX systems the default value of this property is typically &lt;code&gt;&quot;/tmp&quot;&lt;/code&gt; or &lt;code&gt;&quot;/var/tmp&quot;&lt;/code&gt;; on Microsoft Windows systems it is typically &lt;code&gt;&quot;C:\\WINNT\\TEMP&quot;&lt;/code&gt;. A different value may be given to this system property when the Java virtual machine is invoked, but programmatic changes to this property are not guaranteed to have any effect upon the temporary directory used by this method.</source>
          <target state="translated">如果 &lt;code&gt;directory&lt;/code&gt; 参数为 &lt;code&gt;null&lt;/code&gt; ,则将使用系统相关的默认临时文件目录。默认临时文件目录由系统属性 &lt;code&gt;java.io.tmpdir&lt;/code&gt; 指定。在UNIX系统上，此属性的默认值通常为 &lt;code&gt;&quot;/tmp&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;/var/tmp&quot;&lt;/code&gt; ；在Microsoft Windows系统上，通常为 &lt;code&gt;&quot;C:\\WINNT\\TEMP&quot;&lt;/code&gt; 。调用Java虚拟机时，可以为此系统属性赋予不同的值，但不能保证对此属性的编程更改对此方法使用的临时目录没有任何影响。</target>
        </trans-unit>
        <trans-unit id="e2c4e3bcad43dd7e533a7fbe7a4541570c19bd7c" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;emitter&lt;/code&gt; parameter to the constructor was an instance of &lt;code&gt;NotificationBroadcasterSupport&lt;/code&gt; then this method will call &lt;code&gt;emitter.&lt;/code&gt;&lt;a href=&quot;notificationbroadcastersupport#sendNotification(javax.management.Notification)&quot;&gt;&lt;code&gt;sendNotification&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果构造方法的 &lt;code&gt;emitter&lt;/code&gt; 参数是 &lt;code&gt;NotificationBroadcasterSupport&lt;/code&gt; 的实例，则此方法将调用 &lt;code&gt;emitter.&lt;/code&gt; &lt;a href=&quot;notificationbroadcastersupport#sendNotification(javax.management.Notification)&quot;&gt; &lt;code&gt;sendNotification&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="61b3f5e27ccdfa6299b991fa9397c7fbc31d2c50" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;emitter&lt;/code&gt; parameter to the constructor was an instance of &lt;code&gt;NotificationBroadcasterSupport&lt;/code&gt; then this method will call &lt;code&gt;emitter.&lt;/code&gt;&lt;a href=&quot;notificationbroadcastersupport#sendNotification-javax.management.Notification-&quot;&gt;&lt;code&gt;sendNotification&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果构造方法的 &lt;code&gt;emitter&lt;/code&gt; 参数是 &lt;code&gt;NotificationBroadcasterSupport&lt;/code&gt; 的实例，则此方法将调用 &lt;code&gt;emitter.&lt;/code&gt; &lt;a href=&quot;notificationbroadcastersupport#sendNotification-javax.management.Notification-&quot;&gt; &lt;code&gt;sendNotification&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9ab969fd58c84fba8fefef4d68297aff8fba763d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;engine&lt;/code&gt; parameter is available, and the algorithm constraints of the &lt;code&gt;SSLParameters&lt;/code&gt; is non-null, for every certificate in the certification path, fields such as subject public key, the signature algorithm, key usage, extended key usage, etc. need to conform to the algorithm constraints in place on this engine.</source>
          <target state="translated">如果 &lt;code&gt;engine&lt;/code&gt; 参数可用，并且 &lt;code&gt;SSLParameters&lt;/code&gt; 的算法约束为非空，则对于证书路径中的每个证书，都需要符合诸如主题公钥，签名算法，密钥用法，扩展密钥用法等字段限制在此引擎上的算法约束。</target>
        </trans-unit>
        <trans-unit id="4eab346c804a32d54771d78aef5cb1081f3a8a5a" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;engine&lt;/code&gt; parameter is available, and the endpoint identification algorithm of the &lt;code&gt;SSLParameters&lt;/code&gt; is non-empty, to prevent man-in-the-middle attacks, the address that the &lt;code&gt;engine&lt;/code&gt; connected to should be checked against the peer's identity presented in the end-entity X509 certificate, as specified in the endpoint identification algorithm.</source>
          <target state="translated">如果 &lt;code&gt;engine&lt;/code&gt; 参数可用，并且 &lt;code&gt;SSLParameters&lt;/code&gt; 的端点标识算法为非空，则为防止中间人攻击，应针对 &lt;code&gt;engine&lt;/code&gt; 连接到的地址与末尾显示的对等方身份进行检查，端点标识算法中指定的X509实体证书。</target>
        </trans-unit>
        <trans-unit id="c489bda8ac51d0adb2cd2ea9ed206915eaf00580" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;environment&lt;/code&gt; parameter to &lt;a href=&quot;#newJMXConnector(javax.management.remote.JMXServiceURL,java.util.Map)&quot;&gt;&lt;code&gt;newJMXConnector&lt;/code&gt;&lt;/a&gt; contains the key &lt;code&gt;jmx.remote.protocol.provider.class.loader&lt;/code&gt; then the associated value is the class loader to use to load the provider. If the associated value is not an instance of &lt;a href=&quot;../../../../java.base/java/lang/classloader&quot;&gt;&lt;code&gt;ClassLoader&lt;/code&gt;&lt;/a&gt;, an &lt;a href=&quot;../../../../java.base/java/lang/illegalargumentexception&quot;&gt;&lt;code&gt;IllegalArgumentException&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">如果&lt;a href=&quot;#newJMXConnector(javax.management.remote.JMXServiceURL,java.util.Map)&quot;&gt; &lt;code&gt;newJMXConnector&lt;/code&gt; &lt;/a&gt;的 &lt;code&gt;environment&lt;/code&gt; 参数包含键 &lt;code&gt;jmx.remote.protocol.provider.class.loader&lt;/code&gt; ,则关联的值是用于加载提供程序的类加载器。如果关联的值不是一个实例&lt;a href=&quot;../../../../java.base/java/lang/classloader&quot;&gt; &lt;code&gt;ClassLoader&lt;/code&gt; &lt;/a&gt;，一个&lt;a href=&quot;../../../../java.base/java/lang/illegalargumentexception&quot;&gt; &lt;code&gt;IllegalArgumentException&lt;/code&gt; &lt;/a&gt;异常。</target>
        </trans-unit>
        <trans-unit id="def3bb99565bff52201998cb9934892d1dd9c8bd" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;environment&lt;/code&gt; parameter to &lt;a href=&quot;#newJMXConnector(javax.management.remote.JMXServiceURL,java.util.Map)&quot;&gt;&lt;code&gt;newJMXConnector&lt;/code&gt;&lt;/a&gt; contains the key &lt;code&gt;jmx.remote.protocol.provider.pkgs&lt;/code&gt; then the associated value is the provider package list.</source>
          <target state="translated">如果&lt;a href=&quot;#newJMXConnector(javax.management.remote.JMXServiceURL,java.util.Map)&quot;&gt; &lt;code&gt;newJMXConnector&lt;/code&gt; &lt;/a&gt;的 &lt;code&gt;environment&lt;/code&gt; 参数包含键 &lt;code&gt;jmx.remote.protocol.provider.pkgs&lt;/code&gt; ,则关联的值为提供程序包列表。</target>
        </trans-unit>
        <trans-unit id="6b551db3025e219ae99ad787aed372f0514c1f97" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;environment&lt;/code&gt; parameter to &lt;a href=&quot;#newJMXConnectorServer(javax.management.remote.JMXServiceURL,java.util.Map,javax.management.MBeanServer)&quot;&gt;&lt;code&gt;newJMXConnectorServer&lt;/code&gt;&lt;/a&gt; contains the key &lt;code&gt;jmx.remote.protocol.provider.class.loader&lt;/code&gt; then the associated value is the class loader to use to load the provider. If the associated value is not an instance of &lt;a href=&quot;../../../../java.base/java/lang/classloader&quot;&gt;&lt;code&gt;ClassLoader&lt;/code&gt;&lt;/a&gt;, an &lt;a href=&quot;../../../../java.base/java/lang/illegalargumentexception&quot;&gt;&lt;code&gt;IllegalArgumentException&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">如果&lt;a href=&quot;#newJMXConnectorServer(javax.management.remote.JMXServiceURL,java.util.Map,javax.management.MBeanServer)&quot;&gt; &lt;code&gt;newJMXConnectorServer&lt;/code&gt; &lt;/a&gt;的 &lt;code&gt;environment&lt;/code&gt; 参数包含键 &lt;code&gt;jmx.remote.protocol.provider.class.loader&lt;/code&gt; ,则关联的值是用于加载提供程序的类加载器。如果关联的值不是一个实例&lt;a href=&quot;../../../../java.base/java/lang/classloader&quot;&gt; &lt;code&gt;ClassLoader&lt;/code&gt; &lt;/a&gt;，一个&lt;a href=&quot;../../../../java.base/java/lang/illegalargumentexception&quot;&gt; &lt;code&gt;IllegalArgumentException&lt;/code&gt; &lt;/a&gt;异常。</target>
        </trans-unit>
        <trans-unit id="c01021b847664573167d59264418973e495b23f1" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;environment&lt;/code&gt; parameter to &lt;a href=&quot;#newJMXConnectorServer(javax.management.remote.JMXServiceURL,java.util.Map,javax.management.MBeanServer)&quot;&gt;&lt;code&gt;newJMXConnectorServer&lt;/code&gt;&lt;/a&gt; contains the key &lt;code&gt;jmx.remote.protocol.provider.pkgs&lt;/code&gt; then the associated value is the provider package list.</source>
          <target state="translated">如果&lt;a href=&quot;#newJMXConnectorServer(javax.management.remote.JMXServiceURL,java.util.Map,javax.management.MBeanServer)&quot;&gt; &lt;code&gt;newJMXConnectorServer&lt;/code&gt; &lt;/a&gt;的 &lt;code&gt;environment&lt;/code&gt; 参数包含键 &lt;code&gt;jmx.remote.protocol.provider.pkgs&lt;/code&gt; ,则关联的值是提供程序包列表。</target>
        </trans-unit>
        <trans-unit id="56c06cc3e424dcdff076cdd1bf18f2a3b0d87e7a" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;environment&lt;/code&gt; parameter to &lt;a href=&quot;jmxconnectorfactory#newJMXConnector-javax.management.remote.JMXServiceURL-java.util.Map-&quot;&gt;&lt;code&gt;newJMXConnector&lt;/code&gt;&lt;/a&gt; contains the key &lt;code&gt;jmx.remote.protocol.provider.class.loader&lt;/code&gt; then the associated value is the class loader to use to load the provider. If the associated value is not an instance of &lt;a href=&quot;../../../java/lang/classloader&quot;&gt;&lt;code&gt;ClassLoader&lt;/code&gt;&lt;/a&gt;, an &lt;a href=&quot;../../../java/lang/illegalargumentexception&quot;&gt;&lt;code&gt;IllegalArgumentException&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">如果&lt;a href=&quot;jmxconnectorfactory#newJMXConnector-javax.management.remote.JMXServiceURL-java.util.Map-&quot;&gt; &lt;code&gt;newJMXConnector&lt;/code&gt; &lt;/a&gt;的 &lt;code&gt;environment&lt;/code&gt; 参数包含键 &lt;code&gt;jmx.remote.protocol.provider.class.loader&lt;/code&gt; ,则关联的值是用于加载提供程序的类加载器。如果关联的值不是一个实例&lt;a href=&quot;../../../java/lang/classloader&quot;&gt; &lt;code&gt;ClassLoader&lt;/code&gt; &lt;/a&gt;，一个&lt;a href=&quot;../../../java/lang/illegalargumentexception&quot;&gt; &lt;code&gt;IllegalArgumentException&lt;/code&gt; &lt;/a&gt;异常。</target>
        </trans-unit>
        <trans-unit id="d005cee8b528479b05c0be85b9c4205d983a4967" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;environment&lt;/code&gt; parameter to &lt;a href=&quot;jmxconnectorfactory#newJMXConnector-javax.management.remote.JMXServiceURL-java.util.Map-&quot;&gt;&lt;code&gt;newJMXConnector&lt;/code&gt;&lt;/a&gt; contains the key &lt;code&gt;jmx.remote.protocol.provider.pkgs&lt;/code&gt; then the associated value is the provider package list.</source>
          <target state="translated">如果&lt;a href=&quot;jmxconnectorfactory#newJMXConnector-javax.management.remote.JMXServiceURL-java.util.Map-&quot;&gt; &lt;code&gt;newJMXConnector&lt;/code&gt; &lt;/a&gt;的 &lt;code&gt;environment&lt;/code&gt; 参数包含键 &lt;code&gt;jmx.remote.protocol.provider.pkgs&lt;/code&gt; ,则关联的值为提供程序包列表。</target>
        </trans-unit>
        <trans-unit id="826709e7b964ff5f55e8bba64d589128adee0453" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;environment&lt;/code&gt; parameter to &lt;a href=&quot;jmxconnectorserverfactory#newJMXConnectorServer-javax.management.remote.JMXServiceURL-java.util.Map-javax.management.MBeanServer-&quot;&gt;&lt;code&gt;newJMXConnectorServer&lt;/code&gt;&lt;/a&gt; contains the key &lt;code&gt;jmx.remote.protocol.provider.class.loader&lt;/code&gt; then the associated value is the class loader to use to load the provider. If the associated value is not an instance of &lt;a href=&quot;../../../java/lang/classloader&quot;&gt;&lt;code&gt;ClassLoader&lt;/code&gt;&lt;/a&gt;, an &lt;a href=&quot;../../../java/lang/illegalargumentexception&quot;&gt;&lt;code&gt;IllegalArgumentException&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">如果&lt;a href=&quot;jmxconnectorserverfactory#newJMXConnectorServer-javax.management.remote.JMXServiceURL-java.util.Map-javax.management.MBeanServer-&quot;&gt; &lt;code&gt;newJMXConnectorServer&lt;/code&gt; &lt;/a&gt;的 &lt;code&gt;environment&lt;/code&gt; 参数包含键 &lt;code&gt;jmx.remote.protocol.provider.class.loader&lt;/code&gt; ,则关联的值是用于加载提供程序的类加载器。如果关联的值不是一个实例&lt;a href=&quot;../../../java/lang/classloader&quot;&gt; &lt;code&gt;ClassLoader&lt;/code&gt; &lt;/a&gt;，一个&lt;a href=&quot;../../../java/lang/illegalargumentexception&quot;&gt; &lt;code&gt;IllegalArgumentException&lt;/code&gt; &lt;/a&gt;异常。</target>
        </trans-unit>
        <trans-unit id="57ace146c6c02d090ae1128a0850bf8c4adb9e91" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;environment&lt;/code&gt; parameter to &lt;a href=&quot;jmxconnectorserverfactory#newJMXConnectorServer-javax.management.remote.JMXServiceURL-java.util.Map-javax.management.MBeanServer-&quot;&gt;&lt;code&gt;newJMXConnectorServer&lt;/code&gt;&lt;/a&gt; contains the key &lt;code&gt;jmx.remote.protocol.provider.pkgs&lt;/code&gt; then the associated value is the provider package list.</source>
          <target state="translated">如果&lt;a href=&quot;jmxconnectorserverfactory#newJMXConnectorServer-javax.management.remote.JMXServiceURL-java.util.Map-javax.management.MBeanServer-&quot;&gt; &lt;code&gt;newJMXConnectorServer&lt;/code&gt; &lt;/a&gt;的 &lt;code&gt;environment&lt;/code&gt; 参数包含键 &lt;code&gt;jmx.remote.protocol.provider.pkgs&lt;/code&gt; ,则关联的值为提供程序包列表。</target>
        </trans-unit>
        <trans-unit id="6ad40577697d2d3214b29500713b40249dcf0017" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;execute&lt;/code&gt; method is called at this point, the query sent to the DBMS will be:</source>
          <target state="translated">如果此时 &lt;code&gt;execute&lt;/code&gt; 方法，则发送到DBMS的查询将是：</target>
        </trans-unit>
        <trans-unit id="d7e356babec0dbd66ed893c5d593e3b80f2c4c69" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;execute&lt;/code&gt; method is successful, it will set the appropriate private &lt;code&gt;JdbcRowSet&lt;/code&gt; fields with the following:</source>
          <target state="translated">如果 &lt;code&gt;execute&lt;/code&gt; 方法成功，它将使用以下命令设置适当的私有 &lt;code&gt;JdbcRowSet&lt;/code&gt; 字段：</target>
        </trans-unit>
        <trans-unit id="f6b8bda61da14baa6de0517de831488bd2ee3ae0" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;flag&lt;/code&gt; is false, end-of-line characters are treated as white space and serve only to separate tokens.</source>
          <target state="translated">如果该 &lt;code&gt;flag&lt;/code&gt; 为假，则将行尾字符视为空格，并且仅用于分隔令牌。</target>
        </trans-unit>
        <trans-unit id="7c1442b96066ac814d95028e3d47c625abac13dd" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;handleError&lt;/code&gt; method returns &lt;code&gt;false&lt;/code&gt;, the DOM implementation should stop the current processing when possible. If the method returns &lt;code&gt;true&lt;/code&gt;, the processing may continue depending on &lt;code&gt;DOMError.severity&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;handleError&lt;/code&gt; 方法返回 &lt;code&gt;false&lt;/code&gt; ，则DOM实现应在可能的情况下停止当前处理。如果该方法返回 &lt;code&gt;true&lt;/code&gt; ，则根据 &lt;code&gt;DOMError.severity&lt;/code&gt; 的处理可能会继续。</target>
        </trans-unit>
        <trans-unit id="5e167f1b0b7b6f2ec44852a0a73f6c3eeb0559e5" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;hsbvals&lt;/code&gt; argument is &lt;code&gt;null&lt;/code&gt;, then a new array is allocated to return the result. Otherwise, the method returns the array &lt;code&gt;hsbvals&lt;/code&gt;, with the values put into that array.</source>
          <target state="translated">如果 &lt;code&gt;hsbvals&lt;/code&gt; 参数为 &lt;code&gt;null&lt;/code&gt; ，则分配一个新数组以返回结果。否则，该方法将返回数组 &lt;code&gt;hsbvals&lt;/code&gt; ，并将值放入该数组中。</target>
        </trans-unit>
        <trans-unit id="57070b75c38e47f9bec4e11be8d75f04d3e68264" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;info&lt;/code&gt; array is not empty, then it is cloned by the constructor as if by &lt;code&gt;info.clone()&lt;/code&gt;, and each call to &lt;a href=&quot;notificationbroadcaster#getNotificationInfo()&quot;&gt;&lt;code&gt;NotificationBroadcaster.getNotificationInfo()&lt;/code&gt;&lt;/a&gt; returns a new clone.</source>
          <target state="translated">如果 &lt;code&gt;info&lt;/code&gt; 数组不为空，则构造方法会像 &lt;code&gt;info.clone()&lt;/code&gt; 一样克隆它，并且每次对&lt;a href=&quot;notificationbroadcaster#getNotificationInfo()&quot;&gt; &lt;code&gt;NotificationBroadcaster.getNotificationInfo()&lt;/code&gt; 的&lt;/a&gt;调用都会返回一个新的克隆。</target>
        </trans-unit>
        <trans-unit id="f96a39d4789943d7d6902746fb2340490af74ceb" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;info&lt;/code&gt; array is not empty, then it is cloned by the constructor as if by &lt;code&gt;info.clone()&lt;/code&gt;, and each call to &lt;a href=&quot;notificationbroadcastersupport#getNotificationInfo--&quot;&gt;&lt;code&gt;getNotificationInfo()&lt;/code&gt;&lt;/a&gt; returns a new clone.</source>
          <target state="translated">如果 &lt;code&gt;info&lt;/code&gt; 数组不为空，则构造方法将其克隆为 &lt;code&gt;info.clone()&lt;/code&gt; ，并且每次调用&lt;a href=&quot;notificationbroadcastersupport#getNotificationInfo--&quot;&gt; &lt;code&gt;getNotificationInfo()&lt;/code&gt; 都会&lt;/a&gt;返回一个新克隆。</target>
        </trans-unit>
        <trans-unit id="fc7fb96d1c52310781ca0701cabfa84235cc6cad" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;initialize&lt;/code&gt; parameter is &lt;code&gt;true&lt;/code&gt;, then &lt;code&gt;C&lt;/code&gt; is initialized by the Java Virtual Machine.</source>
          <target state="translated">如果 &lt;code&gt;initialize&lt;/code&gt; 参数为 &lt;code&gt;true&lt;/code&gt; ，那么Java虚拟机将初始化 &lt;code&gt;C&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3eb68d70f873d065dccf85e83072633accafa5b8" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;iterator&lt;/code&gt; handle is non-&lt;code&gt;null&lt;/code&gt;, it must have the return type &lt;code&gt;java.util.Iterator&lt;/code&gt; or a subtype thereof. The iterator it produces when the loop is executed will be assumed to yield values which can be converted to type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;iterator&lt;/code&gt; 句柄为非 &lt;code&gt;null&lt;/code&gt; ，则它必须具有返回类型 &lt;code&gt;java.util.Iterator&lt;/code&gt; 或其子类型。将假定执行循环时产生的迭代器产生可转换为 &lt;code&gt;T&lt;/code&gt; 类型的值。</target>
        </trans-unit>
        <trans-unit id="b2eafd26f57a8ac8bfe07dee9777924ccc1ddeef" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;java.naming.corba.orb&lt;/code&gt; attribute is specified and does not point to an &lt;a href=&quot;/openjdk~8_web/org/omg/corba/orb&quot;&gt;&lt;code&gt;ORB&lt;/code&gt;&lt;/a&gt;, then an &lt;code&gt;&lt;a href=&quot;../../../../java/lang/illegalargumentexception&quot;&gt;&lt;code&gt;IllegalArgumentException&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; will be thrown.</source>
          <target state="translated">如果指定了 &lt;code&gt;java.naming.corba.orb&lt;/code&gt; 属性且未指向&lt;a href=&quot;/openjdk~8_web/org/omg/corba/orb&quot;&gt; &lt;code&gt;ORB&lt;/code&gt; &lt;/a&gt;，则将 &lt;code&gt;&lt;a href=&quot;../../../../java/lang/illegalargumentexception&quot;&gt;&lt;code&gt;IllegalArgumentException&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f447975377ba6d22540be764d0328fb281a024f7" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;java.naming.provider.url&lt;/code&gt; property of the supplied environment consists of a URL (or a list of URLs) using the ldap protocol the resulting &lt;a href=&quot;../ldap/ldapcontext&quot;&gt;&lt;code&gt;LdapContext&lt;/code&gt;&lt;/a&gt; will use an LDAP server resolved by the configured &lt;a href=&quot;../ldap/spi/ldapdnsprovider&quot;&gt;&lt;code&gt;LdapDnsProviders&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">如果所提供环境的 &lt;code&gt;java.naming.provider.url&lt;/code&gt; 属性由使用ldap协议的URL（或URL列表）组成，则生成的&lt;a href=&quot;../ldap/ldapcontext&quot;&gt; &lt;code&gt;LdapContext&lt;/code&gt; &lt;/a&gt;将使用由配置的&lt;a href=&quot;../ldap/spi/ldapdnsprovider&quot;&gt; &lt;code&gt;LdapDnsProviders&lt;/code&gt; &lt;/a&gt;解析的LDAP服务器：</target>
        </trans-unit>
        <trans-unit id="c4278296c23500bf6c0cea864ef00fd56ed5236d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;jmx.remote.protocol.provider.class.loader&lt;/code&gt; key is not present in the &lt;code&gt;environment&lt;/code&gt; parameter, the calling thread's context class loader is used.</source>
          <target state="translated">如果 &lt;code&gt;environment&lt;/code&gt; 参数中不存在 &lt;code&gt;jmx.remote.protocol.provider.class.loader&lt;/code&gt; 密钥，则使用调用线程的上下文类加载器。</target>
        </trans-unit>
        <trans-unit id="3056297b7728c6033d8b58edc893075abdeaf0f3" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;listenerMethodName&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;&lt;em&gt;all&lt;/em&gt; methods in the interface trigger the &lt;code&gt;action&lt;/code&gt; to be executed on the &lt;code&gt;target&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;listenerMethodName&lt;/code&gt; 为 &lt;code&gt;null&lt;/code&gt; ，则接口中的&lt;em&gt;所有&lt;/em&gt;方法都会触发要在 &lt;code&gt;target&lt;/code&gt; 上执行的 &lt;code&gt;action&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c26cc70217e4df47d29c0c2d3d16af4b3ed49f81" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;loader&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, and a security manager is present, and the caller's class loader is not null, then this method calls the security manager's &lt;code&gt;checkPermission&lt;/code&gt; method with a &lt;code&gt;RuntimePermission(&quot;getClassLoader&quot;)&lt;/code&gt; permission to ensure it's ok to access the bootstrap class loader.</source>
          <target state="translated">如果 &lt;code&gt;loader&lt;/code&gt; 为 &lt;code&gt;null&lt;/code&gt; ，并且存在安全管理器，并且调用者的类加载器不为null，则此方法使用 &lt;code&gt;RuntimePermission(&quot;getClassLoader&quot;)&lt;/code&gt; 权限调用安全管理器的 &lt;code&gt;checkPermission&lt;/code&gt; 方法，以确保可以访问引导类加载器。</target>
        </trans-unit>
        <trans-unit id="883de64909ad64380525bc73b0b1943d2957d4ad" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;login&lt;/code&gt; method returns without throwing an exception, then the overall authentication succeeded. The caller can then retrieve the newly authenticated Subject by invoking the &lt;code&gt;getSubject&lt;/code&gt; method. Principals and Credentials associated with the Subject may be retrieved by invoking the Subject's respective &lt;code&gt;getPrincipals&lt;/code&gt;, &lt;code&gt;getPublicCredentials&lt;/code&gt;, and &lt;code&gt;getPrivateCredentials&lt;/code&gt; methods.</source>
          <target state="translated">如果 &lt;code&gt;login&lt;/code&gt; 方法返回时没有引发异常，则说明整体身份验证成功。然后，调用者可以通过调用 &lt;code&gt;getSubject&lt;/code&gt; 方法来检索新认证的Subject 。可以通过调用主题各自的 &lt;code&gt;getPrincipals&lt;/code&gt; ， &lt;code&gt;getPublicCredentials&lt;/code&gt; 和 &lt;code&gt;getPrivateCredentials&lt;/code&gt; 方法来检索与主题关联的主体和凭据。</target>
        </trans-unit>
        <trans-unit id="60cd069f53c1777bbf4cf31f1344fe37a4dd9ac1" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;mimeType&lt;/code&gt; is &quot;application/x-java-serialized-object; class=&amp;lt;representation class&amp;gt;&quot;, the result is the same as calling &lt;code&gt;new DataFlavor(Class.forName(&amp;lt;representation class&amp;gt;)&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;mimeType&lt;/code&gt; 为&amp;ldquo; application / x-java-serialized-object; class = &amp;lt;representation class&amp;gt;&amp;rdquo;，则结果与调用 &lt;code&gt;new DataFlavor(Class.forName(&amp;lt;representation class&amp;gt;)&lt;/code&gt; )相同。</target>
        </trans-unit>
        <trans-unit id="b49049ac47e926595641db8085788c19725bedae" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;minimumCapacity&lt;/code&gt; argument is nonpositive, this method takes no action and simply returns. Note that subsequent operations on this object can reduce the actual capacity below that requested here.</source>
          <target state="translated">如果 &lt;code&gt;minimumCapacity&lt;/code&gt; 参数为非正数，则此方法不执行任何操作，仅返回。请注意，对该对象的后续操作可能会将实际容量减少到此处要求的以下。</target>
        </trans-unit>
        <trans-unit id="848f1dae842a9e3e26ccb5fe35a5a76ed09b5792" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;modes&lt;/code&gt; parameter is of length zero, then the existence of the file is checked.</source>
          <target state="translated">如果 &lt;code&gt;modes&lt;/code&gt; 参数的长度为零，则检查文件的存在。</target>
        </trans-unit>
        <trans-unit id="26efd0bf17769d06237d7690d4aec1e552ef72d2" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;modifiers&lt;/code&gt; passed to the constructor are invalid, this method returns them unchanged.</source>
          <target state="translated">如果传递给构造函数的 &lt;code&gt;modifiers&lt;/code&gt; 无效，则此方法将使它们不变。</target>
        </trans-unit>
        <trans-unit id="68e361de8335b69d5e82c2e65544790404d5fa01" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;mouseX&lt;/code&gt; and &lt;code&gt;mouseY&lt;/code&gt; are in the expand/collapse region of the &lt;code&gt;row&lt;/code&gt;, this will toggle the row.</source>
          <target state="translated">如果 &lt;code&gt;mouseX&lt;/code&gt; 和 &lt;code&gt;mouseY&lt;/code&gt; 在该 &lt;code&gt;row&lt;/code&gt; 的展开/折叠区域中，则将切换该行。</target>
        </trans-unit>
        <trans-unit id="d2a314f2aa28a80e456c2b1019bb7151fb7190ec" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;name&lt;/code&gt; begins with a &lt;code&gt;'/'&lt;/code&gt; (&lt;code&gt;'\u002f'&lt;/code&gt;), then the absolute name of the resource is the portion of the &lt;code&gt;name&lt;/code&gt; following the &lt;code&gt;'/'&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;name&lt;/code&gt; 以 &lt;code&gt;'/'&lt;/code&gt; 开头（ &lt;code&gt;'\u002f'&lt;/code&gt; ），则资源的绝对名称是 &lt;code&gt;name&lt;/code&gt; 位于 &lt;code&gt;'/'&lt;/code&gt; 之后的部分。</target>
        </trans-unit>
        <trans-unit id="64bdc0e92c398401f342c415851da39654a29de8" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;name&lt;/code&gt; is &quot;&lt;code&gt;&amp;lt;init&amp;gt;&lt;/code&gt;&quot; or &quot;&lt;code&gt;&amp;lt;clinit&amp;gt;&lt;/code&gt;&quot; a &lt;code&gt;NoSuchMethodException&lt;/code&gt; is raised. Otherwise, the method to be reflected is determined by the algorithm that follows. Let C be the class or interface represented by this object:</source>
          <target state="translated">如果 &lt;code&gt;name&lt;/code&gt; 是&amp;ldquo; &lt;code&gt;&amp;lt;init&amp;gt;&lt;/code&gt; &amp;rdquo;或&amp;ldquo; &lt;code&gt;&amp;lt;clinit&amp;gt;&lt;/code&gt; &amp;rdquo;，则会引发 &lt;code&gt;NoSuchMethodException&lt;/code&gt; 。否则，要反映的方法由随后的算法确定。令C为该对象表示的类或接口：</target>
        </trans-unit>
        <trans-unit id="cf8f40175e230701ae0b215435cd687b9dbe0a2f" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;name&lt;/code&gt; parameter represents something other than a logical font, i.e. is interpreted as a physical font face or family, and this cannot be mapped by the implementation to a physical font or a compatible alternative, then the font system will map the Font instance to &quot;Dialog&quot;, such that for example, the family as reported by &lt;a href=&quot;#getFamily()&quot;&gt;&lt;code&gt;getFamily&lt;/code&gt;&lt;/a&gt; will be &quot;Dialog&quot;.</source>
          <target state="translated">如果 &lt;code&gt;name&lt;/code&gt; 参数表示逻辑字体以外的其他东西，即被解释为物理字体或字体，并且实现无法将其映射到物理字体或兼容的替代字体，则字体系统会将Font实例映射到&amp;ldquo;对话框&amp;rdquo;，例如，由&lt;a href=&quot;#getFamily()&quot;&gt; &lt;code&gt;getFamily&lt;/code&gt; &lt;/a&gt;报告的家族将是&amp;ldquo;对话框&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="83d37bcba2e6c3af77d7d4ae04d7689d9a46d013" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;newAttr&lt;/code&gt; attribute replaces an existing attribute with the same local name and namespace URI, the replaced &lt;code&gt;Attr&lt;/code&gt; node is returned, otherwise &lt;code&gt;null&lt;/code&gt; is returned.</source>
          <target state="translated">如果 &lt;code&gt;newAttr&lt;/code&gt; 属性用相同的本地名称和名称空间URI替换现有属性，则返回被替换的 &lt;code&gt;Attr&lt;/code&gt; 节点，否则返回 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5c99c4ecff1480f789773edec7e413ca2eabcdc6" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;newAttr&lt;/code&gt; attribute replaces an existing attribute, the replaced &lt;code&gt;Attr&lt;/code&gt; node is returned, otherwise &lt;code&gt;null&lt;/code&gt; is returned.</source>
          <target state="translated">如果 &lt;code&gt;newAttr&lt;/code&gt; 属性替换了现有属性，则返回替换的 &lt;code&gt;Attr&lt;/code&gt; 节点，否则返回 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e562c3377bc531b17a3856d97697e38d3cf5595e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;newLength&lt;/code&gt; argument is greater than or equal to the current length, sufficient null characters (&lt;code&gt;'\u0000'&lt;/code&gt;) are appended so that length becomes the &lt;code&gt;newLength&lt;/code&gt; argument.</source>
          <target state="translated">如果 &lt;code&gt;newLength&lt;/code&gt; 自变量大于或等于当前长度，则将附加足够的空字符（ &lt;code&gt;'\u0000'&lt;/code&gt; ），以使长度成为 &lt;code&gt;newLength&lt;/code&gt; 自变量。</target>
        </trans-unit>
        <trans-unit id="31c964b999377de0a92c3ddd622adf97746585c7" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;notifier.notifyAll()&lt;/code&gt; happens before the waiting thread enters the &lt;code&gt;notifier.wait()&lt;/code&gt; method, the &lt;code&gt;while&lt;/code&gt; loop ensures that the waiting thread will not enter the &lt;code&gt;notifier.wait()&lt;/code&gt; method. Otherwise, there is no guarantee that the waiting thread will ever be woken from the wait.</source>
          <target state="translated">如果 &lt;code&gt;notifier.notifyAll()&lt;/code&gt; 在等待线程进入 &lt;code&gt;notifier.wait()&lt;/code&gt; 方法之前发生，则 &lt;code&gt;while&lt;/code&gt; 循环可确保等待线程不会进入 &lt;code&gt;notifier.wait()&lt;/code&gt; 方法。否则，不能保证等待线程会从等待状态中唤醒。</target>
        </trans-unit>
        <trans-unit id="cd7d35bb1b07a6fa45d7d92b3c84889d6cce40ac" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;options&lt;/code&gt; parameter contains the &lt;a href=&quot;filevisitoption#FOLLOW_LINKS&quot;&gt;&lt;code&gt;FOLLOW_LINKS&lt;/code&gt;&lt;/a&gt; option then the stream keeps track of directories visited so that cycles can be detected. A cycle arises when there is an entry in a directory that is an ancestor of the directory. Cycle detection is done by recording the &lt;a href=&quot;attribute/basicfileattributes#fileKey()&quot;&gt;&lt;code&gt;file-key&lt;/code&gt;&lt;/a&gt; of directories, or if file keys are not available, by invoking the &lt;a href=&quot;#isSameFile(java.nio.file.Path,java.nio.file.Path)&quot;&gt;&lt;code&gt;isSameFile&lt;/code&gt;&lt;/a&gt; method to test if a directory is the same file as an ancestor. When a cycle is detected it is treated as an I/O error with an instance of &lt;a href=&quot;filesystemloopexception&quot;&gt;&lt;code&gt;FileSystemLoopException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;options&lt;/code&gt; 参数包含&lt;a href=&quot;filevisitoption#FOLLOW_LINKS&quot;&gt; &lt;code&gt;FOLLOW_LINKS&lt;/code&gt; &lt;/a&gt;选项，那么流将跟踪已访问的目录，以便可以检测到周期。当目录中有一个条目是该目录的祖先时，就会出现一个循环。通过记录目录的&lt;a href=&quot;attribute/basicfileattributes#fileKey()&quot;&gt; &lt;code&gt;file-key&lt;/code&gt; &lt;/a&gt;来完成循环检测，或者如果文件密钥不可用，则通过调用&lt;a href=&quot;#isSameFile(java.nio.file.Path,java.nio.file.Path)&quot;&gt; &lt;code&gt;isSameFile&lt;/code&gt; &lt;/a&gt;方法来测试目录是否与祖先文件相同来进行循环检测。当检测到周期时，将其作为&lt;a href=&quot;filesystemloopexception&quot;&gt; &lt;code&gt;FileSystemLoopException&lt;/code&gt; &lt;/a&gt;实例的I / O错误。</target>
        </trans-unit>
        <trans-unit id="301c55c1d2d5648b427ee3a645ab8146cd1a941a" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;options&lt;/code&gt; parameter contains the &lt;a href=&quot;filevisitoption#FOLLOW_LINKS&quot;&gt;&lt;code&gt;FOLLOW_LINKS&lt;/code&gt;&lt;/a&gt; option then the stream keeps track of directories visited so that cycles can be detected. A cycle arises when there is an entry in a directory that is an ancestor of the directory. Cycle detection is done by recording the &lt;a href=&quot;attribute/basicfileattributes#fileKey--&quot;&gt;&lt;code&gt;file-key&lt;/code&gt;&lt;/a&gt; of directories, or if file keys are not available, by invoking the &lt;a href=&quot;files#isSameFile-java.nio.file.Path-java.nio.file.Path-&quot;&gt;&lt;code&gt;isSameFile&lt;/code&gt;&lt;/a&gt; method to test if a directory is the same file as an ancestor. When a cycle is detected it is treated as an I/O error with an instance of &lt;a href=&quot;filesystemloopexception&quot;&gt;&lt;code&gt;FileSystemLoopException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;options&lt;/code&gt; 参数包含&lt;a href=&quot;filevisitoption#FOLLOW_LINKS&quot;&gt; &lt;code&gt;FOLLOW_LINKS&lt;/code&gt; &lt;/a&gt;选项，则流将跟踪已访问的目录，以便可以检测到周期。当目录中有一个条目是该目录的祖先时，就会出现一个循环。循环检测通过记录目录的&lt;a href=&quot;attribute/basicfileattributes#fileKey--&quot;&gt; &lt;code&gt;file-key&lt;/code&gt; &lt;/a&gt;来完成，或者如果文件密钥不可用，则通过调用&lt;a href=&quot;files#isSameFile-java.nio.file.Path-java.nio.file.Path-&quot;&gt; &lt;code&gt;isSameFile&lt;/code&gt; &lt;/a&gt;方法来测试目录是否与祖先文件相同。当检测到一个周期时，将其作为&lt;a href=&quot;filesystemloopexception&quot;&gt; &lt;code&gt;FileSystemLoopException&lt;/code&gt; &lt;/a&gt;实例的I / O错误。</target>
        </trans-unit>
        <trans-unit id="c55674bb2b5b73e671fc2ec40dcb555e23d9e8d4" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;options&lt;/code&gt; parameter contains the &lt;a href=&quot;filevisitoption#FOLLOW_LINKS&quot;&gt;&lt;code&gt;FOLLOW_LINKS&lt;/code&gt;&lt;/a&gt; option then this method keeps track of directories visited so that cycles can be detected. A cycle arises when there is an entry in a directory that is an ancestor of the directory. Cycle detection is done by recording the &lt;a href=&quot;attribute/basicfileattributes#fileKey()&quot;&gt;&lt;code&gt;file-key&lt;/code&gt;&lt;/a&gt; of directories, or if file keys are not available, by invoking the &lt;a href=&quot;#isSameFile(java.nio.file.Path,java.nio.file.Path)&quot;&gt;&lt;code&gt;isSameFile&lt;/code&gt;&lt;/a&gt; method to test if a directory is the same file as an ancestor. When a cycle is detected it is treated as an I/O error, and the &lt;a href=&quot;filevisitor#visitFileFailed(T,java.io.IOException)&quot;&gt;&lt;code&gt;visitFileFailed&lt;/code&gt;&lt;/a&gt; method is invoked with an instance of &lt;a href=&quot;filesystemloopexception&quot;&gt;&lt;code&gt;FileSystemLoopException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;options&lt;/code&gt; 参数包含&lt;a href=&quot;filevisitoption#FOLLOW_LINKS&quot;&gt; &lt;code&gt;FOLLOW_LINKS&lt;/code&gt; &lt;/a&gt;选项，则此方法将跟踪所访问的目录，以便可以检测到周期。当目录中有一个条目是该目录的祖先时，就会出现一个循环。通过记录目录的&lt;a href=&quot;attribute/basicfileattributes#fileKey()&quot;&gt; &lt;code&gt;file-key&lt;/code&gt; &lt;/a&gt;来完成循环检测，或者如果文件密钥不可用，则通过调用&lt;a href=&quot;#isSameFile(java.nio.file.Path,java.nio.file.Path)&quot;&gt; &lt;code&gt;isSameFile&lt;/code&gt; &lt;/a&gt;方法来测试目录是否与祖先文件相同来进行循环检测。当检测到周期时，将其视为I / O错误，并使用&lt;a href=&quot;filesystemloopexception&quot;&gt; &lt;code&gt;FileSystemLoopException&lt;/code&gt; &lt;/a&gt;的实例调用&lt;a href=&quot;filevisitor#visitFileFailed(T,java.io.IOException)&quot;&gt; &lt;code&gt;visitFileFailed&lt;/code&gt; &lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="ecea4dec8dcb1fadb716a28cf7ec70ca81e1d565" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;options&lt;/code&gt; parameter contains the &lt;a href=&quot;filevisitoption#FOLLOW_LINKS&quot;&gt;&lt;code&gt;FOLLOW_LINKS&lt;/code&gt;&lt;/a&gt; option then this method keeps track of directories visited so that cycles can be detected. A cycle arises when there is an entry in a directory that is an ancestor of the directory. Cycle detection is done by recording the &lt;a href=&quot;attribute/basicfileattributes#fileKey--&quot;&gt;&lt;code&gt;file-key&lt;/code&gt;&lt;/a&gt; of directories, or if file keys are not available, by invoking the &lt;a href=&quot;files#isSameFile-java.nio.file.Path-java.nio.file.Path-&quot;&gt;&lt;code&gt;isSameFile&lt;/code&gt;&lt;/a&gt; method to test if a directory is the same file as an ancestor. When a cycle is detected it is treated as an I/O error, and the &lt;a href=&quot;filevisitor#visitFileFailed-T-java.io.IOException-&quot;&gt;&lt;code&gt;visitFileFailed&lt;/code&gt;&lt;/a&gt; method is invoked with an instance of &lt;a href=&quot;filesystemloopexception&quot;&gt;&lt;code&gt;FileSystemLoopException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;options&lt;/code&gt; 参数包含&lt;a href=&quot;filevisitoption#FOLLOW_LINKS&quot;&gt; &lt;code&gt;FOLLOW_LINKS&lt;/code&gt; &lt;/a&gt;选项，则此方法将跟踪访问的目录，以便可以检测到周期。当目录中有一个条目是该目录的祖先时，就会出现一个循环。循环检测通过记录目录的&lt;a href=&quot;attribute/basicfileattributes#fileKey--&quot;&gt; &lt;code&gt;file-key&lt;/code&gt; &lt;/a&gt;来完成，或者如果文件密钥不可用，则通过调用&lt;a href=&quot;files#isSameFile-java.nio.file.Path-java.nio.file.Path-&quot;&gt; &lt;code&gt;isSameFile&lt;/code&gt; &lt;/a&gt;方法来测试目录是否与祖先文件相同。当检测到周期时，将其视为I / O错误，并使用&lt;a href=&quot;filesystemloopexception&quot;&gt; &lt;code&gt;FileSystemLoopException&lt;/code&gt; &lt;/a&gt;的实例调用&lt;a href=&quot;filevisitor#visitFileFailed-T-java.io.IOException-&quot;&gt; &lt;code&gt;visitFileFailed&lt;/code&gt; &lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="31072125bfcecae8a94f901f25b6fafec9dc2ff7" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;other&lt;/code&gt; parameter is an &lt;a href=&quot;#isAbsolute()&quot;&gt;&lt;code&gt;absolute&lt;/code&gt;&lt;/a&gt; path then this method trivially returns &lt;code&gt;other&lt;/code&gt;. If &lt;code&gt;other&lt;/code&gt; is an</source>
          <target state="translated">如果 &lt;code&gt;other&lt;/code&gt; 参数是&lt;a href=&quot;#isAbsolute()&quot;&gt; &lt;code&gt;absolute&lt;/code&gt; &lt;/a&gt;路径，则此方法会简单地返回 &lt;code&gt;other&lt;/code&gt; 。如果 &lt;code&gt;other&lt;/code&gt; 是</target>
        </trans-unit>
        <trans-unit id="88ff2d156a33a9f0f1f1ee553f98ff8909648b12" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;other&lt;/code&gt; parameter is an &lt;a href=&quot;path#isAbsolute--&quot;&gt;&lt;code&gt;absolute&lt;/code&gt;&lt;/a&gt; path then this method trivially returns &lt;code&gt;other&lt;/code&gt;. If &lt;code&gt;other&lt;/code&gt; is an</source>
          <target state="translated">如果 &lt;code&gt;other&lt;/code&gt; 参数是&lt;a href=&quot;path#isAbsolute--&quot;&gt; &lt;code&gt;absolute&lt;/code&gt; &lt;/a&gt;路径，则此方法会简单地返回 &lt;code&gt;other&lt;/code&gt; 。如果 &lt;code&gt;other&lt;/code&gt; 是</target>
        </trans-unit>
        <trans-unit id="9865b3d772f73983f404112e79623aa8e389cc36" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;output&lt;/code&gt; buffer is too small to hold the result, a &lt;code&gt;ShortBufferException&lt;/code&gt; is thrown.</source>
          <target state="translated">如果 &lt;code&gt;output&lt;/code&gt; 缓冲区太小而无法容纳结果，则抛出 &lt;code&gt;ShortBufferException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4c153c7b1ed1d9892cc1783d56a0214ceb0e6260" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;output&lt;/code&gt; buffer is too small to hold the result, a &lt;code&gt;ShortBufferException&lt;/code&gt; is thrown. In this case, repeat this call with a larger output buffer. Use &lt;a href=&quot;#engineGetOutputSize(int)&quot;&gt;&lt;code&gt;engineGetOutputSize&lt;/code&gt;&lt;/a&gt; to determine how big the output buffer should be.</source>
          <target state="translated">如果 &lt;code&gt;output&lt;/code&gt; 缓冲区太小而无法容纳结果，则抛出 &lt;code&gt;ShortBufferException&lt;/code&gt; 。在这种情况下，请使用更大的输出缓冲区重复此调用。使用&lt;a href=&quot;#engineGetOutputSize(int)&quot;&gt; &lt;code&gt;engineGetOutputSize&lt;/code&gt; &lt;/a&gt;确定输出缓冲区应该有多大。</target>
        </trans-unit>
        <trans-unit id="e5001b62a3fa0f461f2cf7ef6760eeea626b5baf" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;output&lt;/code&gt; buffer is too small to hold the result, a &lt;code&gt;ShortBufferException&lt;/code&gt; is thrown. In this case, repeat this call with a larger output buffer. Use &lt;a href=&quot;#getOutputSize(int)&quot;&gt;&lt;code&gt;getOutputSize&lt;/code&gt;&lt;/a&gt; to determine how big the output buffer should be.</source>
          <target state="translated">如果 &lt;code&gt;output&lt;/code&gt; 缓冲区太小而无法容纳结果，则抛出 &lt;code&gt;ShortBufferException&lt;/code&gt; 。在这种情况下，请使用更大的输出缓冲区重复此调用。使用&lt;a href=&quot;#getOutputSize(int)&quot;&gt; &lt;code&gt;getOutputSize&lt;/code&gt; &lt;/a&gt;确定输出缓冲区应该有多大。</target>
        </trans-unit>
        <trans-unit id="3573d5215011c7d840ccb006ba46e8ea91465ab0" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;output&lt;/code&gt; buffer is too small to hold the result, a &lt;code&gt;ShortBufferException&lt;/code&gt; is thrown. In this case, repeat this call with a larger output buffer. Use &lt;a href=&quot;cipher#getOutputSize-int-&quot;&gt;&lt;code&gt;getOutputSize&lt;/code&gt;&lt;/a&gt; to determine how big the output buffer should be.</source>
          <target state="translated">如果 &lt;code&gt;output&lt;/code&gt; 缓冲区太小而无法容纳结果，则抛出 &lt;code&gt;ShortBufferException&lt;/code&gt; 。在这种情况下，请使用更大的输出缓冲区重复此调用。使用&lt;a href=&quot;cipher#getOutputSize-int-&quot;&gt; &lt;code&gt;getOutputSize&lt;/code&gt; &lt;/a&gt;确定输出缓冲区应该有多大。</target>
        </trans-unit>
        <trans-unit id="d4e86a833a3d986a22969c431219896e2f0d39b7" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;output&lt;/code&gt; buffer is too small to hold the result, a &lt;code&gt;ShortBufferException&lt;/code&gt; is thrown. In this case, repeat this call with a larger output buffer. Use &lt;a href=&quot;exemptionmechanism#getOutputSize-int-&quot;&gt;&lt;code&gt;getOutputSize&lt;/code&gt;&lt;/a&gt; to determine how big the output buffer should be.</source>
          <target state="translated">如果 &lt;code&gt;output&lt;/code&gt; 缓冲区太小而无法容纳结果，则抛出 &lt;code&gt;ShortBufferException&lt;/code&gt; 。在这种情况下，请使用更大的输出缓冲区重复此调用。使用&lt;a href=&quot;exemptionmechanism#getOutputSize-int-&quot;&gt; &lt;code&gt;getOutputSize&lt;/code&gt; &lt;/a&gt;确定输出缓冲区应该有多大。</target>
        </trans-unit>
        <trans-unit id="04b14a126287c47f1542560e798db984f2eaa1bd" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;output&lt;/code&gt; buffer is too small to hold the result, a &lt;code&gt;ShortBufferException&lt;/code&gt; is thrown. In this case, repeat this call with a larger output buffer. Use &lt;a href=&quot;exemptionmechanismspi#engineGetOutputSize-int-&quot;&gt;&lt;code&gt;engineGetOutputSize&lt;/code&gt;&lt;/a&gt; to determine how big the output buffer should be.</source>
          <target state="translated">如果 &lt;code&gt;output&lt;/code&gt; 缓冲区太小而无法容纳结果，则抛出 &lt;code&gt;ShortBufferException&lt;/code&gt; 。在这种情况下，请使用更大的输出缓冲区重复此调用。使用&lt;a href=&quot;exemptionmechanismspi#engineGetOutputSize-int-&quot;&gt; &lt;code&gt;engineGetOutputSize&lt;/code&gt; &lt;/a&gt;确定输出缓冲区应该有多大。</target>
        </trans-unit>
        <trans-unit id="89fab518710d4b47a17308246643c8e2a1ae9311" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;preferredSize&lt;/code&gt; has been set to a non-&lt;code&gt;null&lt;/code&gt; value just returns it.</source>
          <target state="translated">如果 &lt;code&gt;preferredSize&lt;/code&gt; 已设置为非 &lt;code&gt;null&lt;/code&gt; 值，则将其返回。</target>
        </trans-unit>
        <trans-unit id="e3f72f3125072f59960bf1220d641055ff086775" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;preferredSize&lt;/code&gt; has been set to a non-&lt;code&gt;null&lt;/code&gt; value just returns it. If the UI delegate's &lt;code&gt;getPreferredSize&lt;/code&gt; method returns a non &lt;code&gt;null&lt;/code&gt; value then return that; otherwise defer to the component's layout manager.</source>
          <target state="translated">如果 &lt;code&gt;preferredSize&lt;/code&gt; 已设置为非 &lt;code&gt;null&lt;/code&gt; 值，则将其返回。如果UI委托的 &lt;code&gt;getPreferredSize&lt;/code&gt; 方法返回非 &lt;code&gt;null&lt;/code&gt; 值，则返回该值；否则，返回null。否则，请遵照组件的布局管理器。</target>
        </trans-unit>
        <trans-unit id="e09b11d717ca9d2b9db6e423c314021366d5f96d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;pri&lt;/code&gt; argument is less than &lt;a href=&quot;thread#MIN_PRIORITY&quot;&gt;&lt;code&gt;Thread.MIN_PRIORITY&lt;/code&gt;&lt;/a&gt; or greater than &lt;a href=&quot;thread#MAX_PRIORITY&quot;&gt;&lt;code&gt;Thread.MAX_PRIORITY&lt;/code&gt;&lt;/a&gt;, the maximum priority of the group remains unchanged.</source>
          <target state="translated">如果 &lt;code&gt;pri&lt;/code&gt; 参数小于&lt;a href=&quot;thread#MIN_PRIORITY&quot;&gt; &lt;code&gt;Thread.MIN_PRIORITY&lt;/code&gt; &lt;/a&gt;或大于&lt;a href=&quot;thread#MAX_PRIORITY&quot;&gt; &lt;code&gt;Thread.MAX_PRIORITY&lt;/code&gt; &lt;/a&gt;，则组的最大优先级保持不变。</target>
        </trans-unit>
        <trans-unit id="c2d320fca5e0359eb42dfb70629d91de0ba8bdc2" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;prototypeCellValue&lt;/code&gt; property is &lt;code&gt;non-null&lt;/code&gt;, setting the cell renderer also causes the &lt;code&gt;fixedCellWidth&lt;/code&gt; and &lt;code&gt;fixedCellHeight&lt;/code&gt; properties to be re-calculated. Only one &lt;code&gt;PropertyChangeEvent&lt;/code&gt; is generated however - for the &lt;code&gt;cellRenderer&lt;/code&gt; property.</source>
          <target state="translated">如果 &lt;code&gt;prototypeCellValue&lt;/code&gt; 属性 &lt;code&gt;non-null&lt;/code&gt; ，则设置单元格渲染器还将导致 &lt;code&gt;fixedCellWidth&lt;/code&gt; 和 &lt;code&gt;fixedCellHeight&lt;/code&gt; 属性被重新计算。但是，仅生成一个 &lt;code&gt;PropertyChangeEvent&lt;/code&gt; -用于 &lt;code&gt;cellRenderer&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="7ab6fa23ab907d0e5b9b458534eaceb7cc5333a4" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;realEditor&lt;/code&gt; returns true to this message, &lt;code&gt;prepareForEditing&lt;/code&gt; is messaged and true is returned.</source>
          <target state="translated">如果 &lt;code&gt;realEditor&lt;/code&gt; 对此消息返回true，则发送 &lt;code&gt;prepareForEditing&lt;/code&gt; 消息，并返回true 。</target>
        </trans-unit>
        <trans-unit id="7083b5d57e80daca82c9ea7e4f69ee995d29855a" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;realEditor&lt;/code&gt; will allow editing to stop, the &lt;code&gt;realEditor&lt;/code&gt; is removed and true is returned, otherwise false is returned.</source>
          <target state="translated">如果 &lt;code&gt;realEditor&lt;/code&gt; 将允许停止编辑，则将 &lt;code&gt;realEditor&lt;/code&gt; 删除并返回true，否则返回false。</target>
        </trans-unit>
        <trans-unit id="72da6eb0f51543265c08bfdc0d2bc08c5c28b9d9" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;reload&lt;/code&gt; flag is &lt;code&gt;true&lt;/code&gt;, it indicates that this method is being called because the previously loaded resource bundle has expired.</source>
          <target state="translated">如果 &lt;code&gt;reload&lt;/code&gt; 标志为 &lt;code&gt;true&lt;/code&gt; ，则表示正在调用此方法，因为先前加载的资源束已过期。</target>
        </trans-unit>
        <trans-unit id="f1c25c2d5a4c3be0ad0ceae100cbbd46dd49166c" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;resizingColumn&lt;/code&gt; is not &lt;code&gt;null&lt;/code&gt;, it is one of the columns in the table that has changed size rather than the table itself. In this case the auto-resize modes govern the way the extra (or deficit) space is distributed amongst the available columns.</source>
          <target state="translated">如果 &lt;code&gt;resizingColumn&lt;/code&gt; 不为 &lt;code&gt;null&lt;/code&gt; ，则它是表中已更改大小的列之一，而不是表本身。在这种情况下，自动调整大小模式将控制多余（或不足）空间在可用列之间的分配方式。</target>
        </trans-unit>
        <trans-unit id="9cf1a2b060b2436670293c7813d34eef4b639e76" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;returnDelims&lt;/code&gt; flag is &lt;code&gt;true&lt;/code&gt;, then the delimiter characters are also returned as tokens. Each delimiter is returned as a string of length one. If the flag is &lt;code&gt;false&lt;/code&gt;, the delimiter characters are skipped and only serve as separators between tokens.</source>
          <target state="translated">如果 &lt;code&gt;returnDelims&lt;/code&gt; 标志为 &lt;code&gt;true&lt;/code&gt; ，则分隔符也作为标记返回。每个定界符以长度为一的字符串返回。如果该标志为 &lt;code&gt;false&lt;/code&gt; ，则分隔符将被跳过，仅用作标记之间的分隔符。</target>
        </trans-unit>
        <trans-unit id="13d413d3ee252e112f59337a3ad9bdce1bc727e1" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;rootVisible&lt;/code&gt; setting specifies that the root node is to be displayed, then that is the only node at the topmost level. If the root node is not displayed, then all of its children are at the topmost level of the tree. Handles are always displayed for nodes other than the topmost.</source>
          <target state="translated">如果 &lt;code&gt;rootVisible&lt;/code&gt; 设置指定要显示根节点，则该节点是最顶层的唯一节点。如果未显示根节点，则其所有子节点都在树的最顶层。总是显示除最顶端节点以外的节点的句柄。</target>
        </trans-unit>
        <trans-unit id="814c644fd80ff6c6cfb5225d71687f0ea854f3a6" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;serviceURL&lt;/code&gt; looks like:</source>
          <target state="translated">如果 &lt;code&gt;serviceURL&lt;/code&gt; 看起来像：</target>
        </trans-unit>
        <trans-unit id="135f589d26f864ce90f30a25047418b479d5f710" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;serviceURL&lt;/code&gt; you specify has an empty URL path (after the optional host and port), or if you do not specify a &lt;code&gt;serviceURL&lt;/code&gt;, then the connector server will fabricate a new &lt;code&gt;JMXServiceURL&lt;/code&gt; that clients can use to connect:</source>
          <target state="translated">如果您指定的 &lt;code&gt;serviceURL&lt;/code&gt; 的URL路径为空（在可选的主机和端口之后），或者您未指定 &lt;code&gt;serviceURL&lt;/code&gt; ，则连接器服务器将 &lt;code&gt;JMXServiceURL&lt;/code&gt; 一个新的JMXServiceURL，客户端可以使用该JMXServiceURL进行连接：</target>
        </trans-unit>
        <trans-unit id="7de93d07441877a38ae86e0b1d48750f6d309642" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;setSize&lt;/code&gt; or &lt;code&gt;setBounds&lt;/code&gt; methods are called afterwards with a width or height less than that was specified by the &lt;code&gt;setMinimumSize&lt;/code&gt; method the window is automatically enlarged to meet the &lt;code&gt;minimumSize&lt;/code&gt; value. The &lt;code&gt;minimumSize&lt;/code&gt; value also affects the behaviour of the &lt;code&gt;pack&lt;/code&gt; method.</source>
          <target state="translated">如果随后以小于 &lt;code&gt;setMinimumSize&lt;/code&gt; 方法指定的宽度或高度的宽度或高度调用 &lt;code&gt;setSize&lt;/code&gt; 或 &lt;code&gt;setBounds&lt;/code&gt; 方法，则窗口将自动放大以符合 &lt;code&gt;minimumSize&lt;/code&gt; 值。该 &lt;code&gt;minimumSize&lt;/code&gt; 值也会影响的行为 &lt;code&gt;pack&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="a4c7fe60b96360a2fce6906e7dfb1015497d385d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;sharedSecret&lt;/code&gt; buffer is too small to hold the result, a &lt;code&gt;ShortBufferException&lt;/code&gt; is thrown. In this case, this call should be repeated with a larger output buffer.</source>
          <target state="translated">如果 &lt;code&gt;sharedSecret&lt;/code&gt; 缓冲区太小而无法容纳结果，则将引发 &lt;code&gt;ShortBufferException&lt;/code&gt; 。在这种情况下，应使用更大的输出缓冲区重复此调用。</target>
        </trans-unit>
        <trans-unit id="a59bde6bd9cfdf4f9c0e2000a8690929361fab50" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;socket&lt;/code&gt; parameter is an instance of &lt;a href=&quot;sslsocket&quot;&gt;&lt;code&gt;SSLSocket&lt;/code&gt;&lt;/a&gt;, and the algorithm constraints of the &lt;code&gt;SSLParameters&lt;/code&gt; is non-null, for every certificate in the certification path, fields such as subject public key, the signature algorithm, key usage, extended key usage, etc. need to conform to the algorithm constraints in place on this socket.</source>
          <target state="translated">如果 &lt;code&gt;socket&lt;/code&gt; 参数是&lt;a href=&quot;sslsocket&quot;&gt; &lt;code&gt;SSLSocket&lt;/code&gt; &lt;/a&gt;的实例，并且 &lt;code&gt;SSLParameters&lt;/code&gt; 的算法约束为非null，则对于证书路径中的每个证书，都将包含诸如主题公钥，签名算法，密钥用法，扩展密钥用法等字段。需要符合此套接字上的算法约束。</target>
        </trans-unit>
        <trans-unit id="e9eeaa551ce6db761bfe71fcd9d95ed24d11d58e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;socket&lt;/code&gt; parameter is an instance of &lt;a href=&quot;sslsocket&quot;&gt;&lt;code&gt;SSLSocket&lt;/code&gt;&lt;/a&gt;, and the endpoint identification algorithm of the &lt;code&gt;SSLParameters&lt;/code&gt; is non-empty, to prevent man-in-the-middle attacks, the address that the &lt;code&gt;socket&lt;/code&gt; connected to should be checked against the peer's identity presented in the end-entity X509 certificate, as specified in the endpoint identification algorithm.</source>
          <target state="translated">如果 &lt;code&gt;socket&lt;/code&gt; 参数是&lt;a href=&quot;sslsocket&quot;&gt; &lt;code&gt;SSLSocket&lt;/code&gt; &lt;/a&gt;的实例，并且 &lt;code&gt;SSLParameters&lt;/code&gt; 的端点标识算法为非空，则为防止中间人攻击，应对照在其中显示的对等方身份检查 &lt;code&gt;socket&lt;/code&gt; 连接的地址端点标识算法中指定的最终实体X509证书。</target>
        </trans-unit>
        <trans-unit id="a8ad5fb90dd67b864239c52c78d91a33b02bcd3e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;src&lt;/code&gt; and &lt;code&gt;dest&lt;/code&gt; arguments refer to the same array object, then the copying is performed as if the components at positions &lt;code&gt;srcPos&lt;/code&gt; through &lt;code&gt;srcPos+length-1&lt;/code&gt; were first copied to a temporary array with &lt;code&gt;length&lt;/code&gt; components and then the contents of the temporary array were copied into positions &lt;code&gt;destPos&lt;/code&gt; through &lt;code&gt;destPos+length-1&lt;/code&gt; of the destination array.</source>
          <target state="translated">如果 &lt;code&gt;src&lt;/code&gt; 和 &lt;code&gt;dest&lt;/code&gt; 参数引用相同的数组对象，则执行复制，就好像首先将 &lt;code&gt;srcPos&lt;/code&gt; 到 &lt;code&gt;srcPos+length-1&lt;/code&gt; 位置上的分量复制到具有 &lt;code&gt;length&lt;/code&gt; 分量的临时数组，然后将临时数组的内容通过目标数组的 &lt;code&gt;destPos+length-1&lt;/code&gt; 复制到位置 &lt;code&gt;destPos&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1326d1ae8f7029fe206d3181337e183fd5b2f733" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;targetClass&lt;/code&gt; is in the same module as the lookup class, the lookup class is &lt;code&gt;LC&lt;/code&gt; in module &lt;code&gt;M1&lt;/code&gt; and the previous lookup class is in module &lt;code&gt;M0&lt;/code&gt; or &lt;code&gt;null&lt;/code&gt; if not present, &lt;code&gt;targetClass&lt;/code&gt; is accessible if and only if one of the following is true:</source>
          <target state="translated">如果 &lt;code&gt;targetClass&lt;/code&gt; 与查找类在同一个模块中，则查找类在模块 &lt;code&gt;M1&lt;/code&gt; 中为 &lt;code&gt;LC&lt;/code&gt; ，而先前的查找类在模块 &lt;code&gt;M0&lt;/code&gt; 中,或者如果不存在 &lt;code&gt;targetClass&lt;/code&gt; &lt;code&gt;null&lt;/code&gt; ，则当且仅当以下条件之一为true时，targetClass才可访问：</target>
        </trans-unit>
        <trans-unit id="50552460698026ff8f20b17c1d4139edc635e7a4" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;verify&lt;/code&gt; flag is on when opening a signed jar file, the content of the jar entry is verified against the signature embedded inside the manifest that is associated with its &lt;a href=&quot;jarentry#getRealName()&quot;&gt;&lt;code&gt;path name&lt;/code&gt;&lt;/a&gt;. For a multi-release jar file, the content of a versioned entry is verfieid against its own signature and &lt;a href=&quot;jarentry#getCodeSigners()&quot;&gt;&lt;code&gt;JarEntry.getCodeSigners()&lt;/code&gt;&lt;/a&gt; returns its own signers. Please note that the verification process does not include validating the signer's certificate. A caller should inspect the return value of &lt;a href=&quot;jarentry#getCodeSigners()&quot;&gt;&lt;code&gt;JarEntry.getCodeSigners()&lt;/code&gt;&lt;/a&gt; to further determine if the signature can be trusted.</source>
          <target state="translated">如果打开签名的jar文件时 &lt;code&gt;verify&lt;/code&gt; 标记处于打开状态，则将jar条目的内容针对嵌入在清单文件中的与其&lt;a href=&quot;jarentry#getRealName()&quot;&gt; &lt;code&gt;path name&lt;/code&gt; &lt;/a&gt;相关联的签名进行校验。对于多发行版本的jar文件，版本化条目的内容将针对其自身的签名进行精确验证，并且&lt;a href=&quot;jarentry#getCodeSigners()&quot;&gt; &lt;code&gt;JarEntry.getCodeSigners()&lt;/code&gt; &lt;/a&gt;返回其自身的签名者。请注意，验证过程不包括验证签名者的证书。调用者应检查&lt;a href=&quot;jarentry#getCodeSigners()&quot;&gt; &lt;code&gt;JarEntry.getCodeSigners()&lt;/code&gt; &lt;/a&gt;的返回值，以进一步确定签名是否可以信任。</target>
        </trans-unit>
        <trans-unit id="384a467e1b3d5e62425baa603c92bb9909dbf0dc" translate="yes" xml:space="preserve">
          <source>If the &lt;em&gt;quoted value&lt;/em&gt; contains at least one occurrence of the characters asterisk or question mark and they are not preceded by a backslash, then they are considered as wildcard characters and the object name is a &lt;em&gt;property value pattern&lt;/em&gt;. The asterisk matches any sequence of zero or more characters, while the question mark matches any single character.</source>
          <target state="translated">如果&lt;em&gt;引用的值&lt;/em&gt;包含至少一个出现的字符星号或问号，并且前面没有反斜杠，则将它们视为通配符，并且对象名称是&lt;em&gt;属性值模式&lt;/em&gt;。星号匹配零个或多个字符的任何序列，而问号匹配任何单个字符。</target>
        </trans-unit>
        <trans-unit id="383d196bbc70848d6d2a83c15bee341a49633abd" translate="yes" xml:space="preserve">
          <source>If the &lt;em&gt;unquoted value&lt;/em&gt; contains at least one occurrence of the wildcard characters asterisk or question mark, then the object name is a &lt;em&gt;property value pattern&lt;/em&gt;. The asterisk matches any sequence of zero or more characters, while the question mark matches any single character.</source>
          <target state="translated">如果&lt;em&gt;未引用的值&lt;/em&gt;至少包含一次出现的通配符星号或问号，则对象名称为&lt;em&gt;属性值模式&lt;/em&gt;。星号匹配零个或多个字符的任何序列，而问号匹配任何单个字符。</target>
        </trans-unit>
        <trans-unit id="8fc60c08a8c50456909645784a1769d622137e78" translate="yes" xml:space="preserve">
          <source>If the ALLOW_UNASSIGNED flag is used, the domain name string to be converted can contain code points that are unassigned in Unicode 3.2, which is the Unicode version on which IDN conversion is based. If the flag is not used, the presence of such unassigned code points is treated as an error.</source>
          <target state="translated">如果使用了ALLOW_UNASSIGNED标志,要转换的域名字符串可以包含Unicode 3.2中未分配的代码点,Unicode 3.2是IDN转换的基础版本。如果不使用该标志,则这种未分配代码点的存在将被视为错误。</target>
        </trans-unit>
        <trans-unit id="700fc7ae106ff84c28cd4140489739bfdaaa88d6" translate="yes" xml:space="preserve">
          <source>If the API can not be used to configure a &lt;code&gt;JarFile&lt;/code&gt; (e.g. to override the configuration of a compiled application or library), two &lt;code&gt;System&lt;/code&gt; properties are available.</source>
          <target state="translated">如果无法使用API​​配置 &lt;code&gt;JarFile&lt;/code&gt; （例如，覆盖已编译的应用程序或库的配置），则可以使用两个 &lt;code&gt;System&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="2a7c711b7120183f899af59849df74982f595de0" translate="yes" xml:space="preserve">
          <source>If the BeanInfo class for a Java Bean has been previously Introspected based on the same arguments then the BeanInfo class is retrieved from the BeanInfo cache.</source>
          <target state="translated">如果一个Java Bean的BeanInfo类之前已经基于相同的参数被Introspected过,那么BeanInfo类就会从BeanInfo缓存中被检索出来。</target>
        </trans-unit>
        <trans-unit id="27052094f3a72a9f04c55988b8fcc4b55c99cb46" translate="yes" xml:space="preserve">
          <source>If the BeanInfo class for a Java Bean has been previously Introspected based on the same arguments, then the BeanInfo class is retrieved from the BeanInfo cache.</source>
          <target state="translated">如果一个Java Bean的BeanInfo类之前已经基于相同的参数被Introspected过,那么BeanInfo类就会从BeanInfo缓存中被检索出来。</target>
        </trans-unit>
        <trans-unit id="bf6802705f363000e83d105cf3b075ebc1fbcacb" translate="yes" xml:space="preserve">
          <source>If the BeanInfo class for a Java Bean has been previously Introspected then the BeanInfo class is retrieved from the BeanInfo cache.</source>
          <target state="translated">如果一个Java Bean的BeanInfo类之前已经被Introspected,那么BeanInfo类就会从BeanInfo缓存中被检索出来。</target>
        </trans-unit>
        <trans-unit id="74b13711d7aed1bc07acd1271fe358967b6f6726" translate="yes" xml:space="preserve">
          <source>If the BeanInfo class for a Java Bean has been previously introspected based on the same arguments then the BeanInfo class is retrieved from the BeanInfo cache.</source>
          <target state="translated">如果一个Java Bean的BeanInfo类之前已经基于相同的参数进行了反省,那么BeanInfo类就会从BeanInfo缓存中检索出来。</target>
        </trans-unit>
        <trans-unit id="2d00c2a268a3801edc2c4c099c48a140b0fd8461" translate="yes" xml:space="preserve">
          <source>If the CleaningExample is used in a try-finally block then the &lt;code&gt;close&lt;/code&gt; method calls the cleaning action. If the &lt;code&gt;close&lt;/code&gt; method is not called, the cleaning action is called by the Cleaner when the CleaningExample instance has become phantom reachable.</source>
          <target state="translated">如果在try-finally块中使用了CleaningExample，则 &lt;code&gt;close&lt;/code&gt; 方法将调用清洁动作。如果未调用 &lt;code&gt;close&lt;/code&gt; 方法，则当CleaningExample实例变为幻影可达时，清洁器将调用清洁动作。</target>
        </trans-unit>
        <trans-unit id="454995cc2e260c1d06757623f1b5ad1b2feb2e38" translate="yes" xml:space="preserve">
          <source>If the ColorModel is an IndexColorModel and the subclass has set the canFilterIndexColorModel flag to true, we substitute a filtered version of the color model here and wherever that original ColorModel object appears in the setPixels methods.</source>
          <target state="translated">如果ColorModel是一个IndexColorModel,并且子类已经将canFilterIndexColorModel标志设置为true,那么我们在这里以及在setPixels方法中出现该原始ColorModel对象的任何地方替换一个过滤后的颜色模型。</target>
        </trans-unit>
        <trans-unit id="a17b4fd0fc3c2da711064a3199127d020c189ac1" translate="yes" xml:space="preserve">
          <source>If the ColorModel is an IndexColorModel and the subclass has set the canFilterIndexColorModel flag to true, we substitute a filtered version of the color model here and wherever that original ColorModel object appears in the setPixels methods. If the ColorModel is not an IndexColorModel or is null, this method overrides the default ColorModel used by the ImageProducer and specifies the default RGB ColorModel instead.</source>
          <target state="translated">如果ColorModel是一个IndexColorModel,并且子类已经将canFilterIndexColorModel标志设置为true,那么我们就在这里以及在setPixels方法中出现的原始ColorModel对象的任何地方替换一个过滤后的颜色模型。如果ColorModel不是IndexColorModel或者是空的,这个方法会覆盖ImageProducer使用的默认ColorModel,并指定默认的RGB ColorModel代替。</target>
        </trans-unit>
        <trans-unit id="ebb62725402f17c9f293bd13a4222501b92b1afb" translate="yes" xml:space="preserve">
          <source>If the ColorModel object is the same one that has already been converted, then simply passes the pixels through with the converted ColorModel, otherwise converts the buffer of integer pixels to the default RGB ColorModel and passes the converted buffer to the filterRGBPixels method to be converted one by one.</source>
          <target state="translated">如果ColorModel对象是已经转换过的同一个对象,那么只需将像素与转换后的ColorModel传递过去即可,否则将整数像素的缓冲区转换为默认的RGB ColorModel,并将转换后的缓冲区传递给filterRGBPixels方法进行逐一转换。</target>
        </trans-unit>
        <trans-unit id="b15f89fd97901ee1fb24930f37e7ae4ef300f4ae" translate="yes" xml:space="preserve">
          <source>If the ColorModel object is the same one that has already been converted, then simply passes the pixels through with the converted ColorModel, otherwise converts the buffer of integer pixels to the default RGB ColorModel and passes the converted buffer to the filterRGBPixels method to be converted one by one. Converts a buffer of integer pixels to the default RGB ColorModel and passes the converted buffer to the filterRGBPixels method.</source>
          <target state="translated">如果ColorModel对象与已经转换的ColorModel对象相同,则简单地将像素与转换后的ColorModel一起传递,否则将整数像素的缓冲区转换为默认的RGB ColorModel,并将转换后的缓冲区逐一传递给filterRGBPixels方法进行转换。将整数像素的缓冲区转换为默认的RGB ColorModel,并将转换后的缓冲区传递给filterRGBPixels方法。</target>
        </trans-unit>
        <trans-unit id="a2d4a4e4912ac5e9ff71960aac1cb3d98b8ae728" translate="yes" xml:space="preserve">
          <source>If the ColorModel object is the same one that has already been converted, then simply passes the pixels through with the converted ColorModel.</source>
          <target state="translated">如果ColorModel对象是已经转换过的同一个对象,那么只需将像素与转换后的ColorModel传递过去即可。</target>
        </trans-unit>
        <trans-unit id="f5b2b08b4860ee3f58dfbccb3e9b728f83daa433" translate="yes" xml:space="preserve">
          <source>If the ColorModel object is the same one that has already been converted, then simply passes the pixels through with the converted ColorModel. Otherwise converts the buffer of byte pixels to the default RGB ColorModel and passes the converted buffer to the filterRGBPixels method to be converted one by one.</source>
          <target state="translated">如果ColorModel对象是已经转换过的同一个对象,那么只需将像素与转换后的ColorModel一起传递过去。否则将字节像素的缓冲区转换为默认的RGB ColorModel,并将转换后的缓冲区逐一传递给filterRGBPixels方法进行转换。</target>
        </trans-unit>
        <trans-unit id="2fc0046f2b504de87c74868c9d33ea3f35f1d246" translate="yes" xml:space="preserve">
          <source>If the DTD contains an explicit value, as in: &lt;code&gt;&amp;lt;!ATTLIST OPTION selected (selected) #IMPLIED&amp;gt;&lt;/code&gt; this value from the dtd (in this case selected) will be used.</source>
          <target state="translated">如果DTD包含一个显式值，例如： &lt;code&gt;&amp;lt;!ATTLIST OPTION selected (selected) #IMPLIED&amp;gt;&lt;/code&gt; ，则将使用dtd中的此值（在本例中为selected）。</target>
        </trans-unit>
        <trans-unit id="2cb72115f8155cafe91c7be2e683edb1180ccb8f" translate="yes" xml:space="preserve">
          <source>If the DTD does not contain an definition for the element, or the definition does not have an explicit value then the value in the AttributeSet will be &lt;code&gt;HTML.NULL_ATTRIBUTE_VALUE&lt;/code&gt;.</source>
          <target state="translated">如果DTD不包含该元素的定义，或者该定义不具有显式值，则AttributeSet中的值将为 &lt;code&gt;HTML.NULL_ATTRIBUTE_VALUE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b8f28761ed1b352634ef38205fef3a87519af308" translate="yes" xml:space="preserve">
          <source>If the Document structure changed as result of the insertion, the details of what Elements were inserted and removed in response to the change will also be contained in the generated DocumentEvent. It is up to the implementation of a Document to decide how the structure should change in response to an insertion.</source>
          <target state="translated">如果Document结构因插入而改变,那么在生成的DocumentEvent中也会包含哪些元素被插入和删除的详细信息。由Document的实现者来决定结构应该如何响应插入而改变。</target>
        </trans-unit>
        <trans-unit id="030cb95378711b1636920c7d0827ed5b14eb88fe" translate="yes" xml:space="preserve">
          <source>If the Document structure changed as result of the removal, the details of what Elements were inserted and removed in response to the change will also be contained in the generated DocumentEvent. It is up to the implementation of a Document to decide how the structure should change in response to a remove.</source>
          <target state="translated">如果Document结构因删除而改变,那么在生成的DocumentEvent中也会包含哪些元素被插入和删除的详细信息。由Document的实现者来决定结构应该如何响应删除而改变。</target>
        </trans-unit>
        <trans-unit id="80ce8c0f1c1c211a90c8b7e66061c58778167da6" translate="yes" xml:space="preserve">
          <source>If the Document supports undo/redo, an UndoableEditEvent will also be generated.</source>
          <target state="translated">如果文档支持撤消/重做,还将生成一个UndoableEditEvent。</target>
        </trans-unit>
        <trans-unit id="b0a6b6c38e66debb2926492a33b326ecee7be585" translate="yes" xml:space="preserve">
          <source>If the Drag and Drop System is unable to initiate a drag operation for some reason, the startDrag() method throws a &lt;code&gt;java.awt.dnd.InvalidDnDOperationException&lt;/code&gt; to signal such a condition. Typically this exception is thrown when the underlying platform system is either not in a state to initiate a drag, or the parameters specified are invalid.</source>
          <target state="translated">如果拖放系统由于某种原因无法启动拖动操作，则startDrag（）方法将引发 &lt;code&gt;java.awt.dnd.InvalidDnDOperationException&lt;/code&gt; 来发出这种情况的信号。通常，当基础平台系统未处于启动拖动的状态或指定的参数无效时，将引发此异常。</target>
        </trans-unit>
        <trans-unit id="b36a3a37ab405a50245f8ca60d31eb1f24fccf64" translate="yes" xml:space="preserve">
          <source>If the Executor for this publisher throws a RejectedExecutionException (or any other RuntimeException or Error) when attempting to asynchronously notify subscribers, or the drop handler throws an exception when processing a dropped item, then this exception is rethrown.</source>
          <target state="translated">如果这个发布者的Executor在试图异步通知订阅者时抛出RejectedExecutionException(或任何其他RuntimeException或Error),或者drop处理程序在处理drop项时抛出异常,那么这个异常就会被重抛。</target>
        </trans-unit>
        <trans-unit id="b41cd91e530f36a9b0da3d978e7ece27002c8489" translate="yes" xml:space="preserve">
          <source>If the Executor for this publisher throws a RejectedExecutionException (or any other RuntimeException or Error) when attempting to asynchronously notify subscribers, then this exception is rethrown, in which case not all subscribers will have been issued this item.</source>
          <target state="translated">如果这个发布者的Executor在试图异步通知订阅者时抛出RejectedExecutionException(或任何其他RuntimeException或Error),那么这个异常就会被重新抛出,在这种情况下,并不是所有的订阅者都会被发布这个项目。</target>
        </trans-unit>
        <trans-unit id="0a887cc255dc4733cf1b5653b5998661c76f2b20" translate="yes" xml:space="preserve">
          <source>If the GSSManager implementation does not support an SPI with a pluggable provider architecture it should throw a GSSException with the status code GSSException.UNAVAILABLE to indicate that the operation is unavailable.</source>
          <target state="translated">如果GSSManager实现不支持具有可插拔提供者架构的SPI,它应该抛出一个状态码为GSSException.UNAVAILABLE的GSSException来表示该操作不可用。</target>
        </trans-unit>
        <trans-unit id="da20e7ea76a9a643faf6481a32f3400ecce492d3" translate="yes" xml:space="preserve">
          <source>If the IP address is a &lt;a href=&quot;inetaddress#isAnyLocalAddress()&quot;&gt;&lt;code&gt;wildcard&lt;/code&gt;&lt;/a&gt; address, or is &lt;code&gt;null&lt;/code&gt;, the socket will be bound to the wildcard address.</source>
          <target state="translated">如果IP地址是&lt;a href=&quot;inetaddress#isAnyLocalAddress()&quot;&gt; &lt;code&gt;wildcard&lt;/code&gt; &lt;/a&gt;地址或为 &lt;code&gt;null&lt;/code&gt; ，则套接字将绑定到通配符地址。</target>
        </trans-unit>
        <trans-unit id="ad4939c5094269e4f9d10a41688acc1a518009fa" translate="yes" xml:space="preserve">
          <source>If the JAR file has a &lt;code&gt;Main-Class&lt;/code&gt; attribute in its main manifest, its value is a legal class name, and its package is in the set of packages derived for the module, then the value is the module &lt;a href=&quot;moduledescriptor#mainClass()&quot;&gt;main class&lt;/a&gt;.</source>
          <target state="translated">如果JAR文件在其主清单中具有 &lt;code&gt;Main-Class&lt;/code&gt; 属性，则其值为合法的类名，并且其包位于为该模块派生的一组包中，则该值为模块&lt;a href=&quot;moduledescriptor#mainClass()&quot;&gt;main class&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c9ace20d58b64f9f5ea681de79599cbf699eebec" translate="yes" xml:space="preserve">
          <source>If the JAR file has the attribute &quot;&lt;code&gt;Automatic-Module-Name&lt;/code&gt;&quot; in its main manifest then its value is the &lt;a href=&quot;moduledescriptor#name()&quot;&gt;module name&lt;/a&gt;. The module name is otherwise derived from the name of the JAR file.</source>
          <target state="translated">如果JAR文件的主要清单中具有属性&amp;ldquo; &lt;code&gt;Automatic-Module-Name&lt;/code&gt; &amp;rdquo;，则其值为&lt;a href=&quot;moduledescriptor#name()&quot;&gt;模块名称&lt;/a&gt;。否则，模块名称是从JAR文件的名称派生的。</target>
        </trans-unit>
        <trans-unit id="bce7057e5b6fdd5c5ebdea045f965918043cd418" translate="yes" xml:space="preserve">
          <source>If the JDBC type expected to be returned to this output parameter is specific to this particular database, &lt;code&gt;sqlType&lt;/code&gt; may be &lt;code&gt;JDBCType.OTHER&lt;/code&gt; or a &lt;code&gt;SQLType&lt;/code&gt; that is supported by the JDBC driver. The method &lt;a href=&quot;#getObject(int)&quot;&gt;&lt;code&gt;getObject(int)&lt;/code&gt;&lt;/a&gt; retrieves the value.</source>
          <target state="translated">如果期望返回到此输出参数的JDBC类型特定于此特定数据库，则 &lt;code&gt;sqlType&lt;/code&gt; 可以是 &lt;code&gt;JDBCType.OTHER&lt;/code&gt; 或JDBC驱动程序支持的 &lt;code&gt;SQLType&lt;/code&gt; 。方法&lt;a href=&quot;#getObject(int)&quot;&gt; &lt;code&gt;getObject(int)&lt;/code&gt; &lt;/a&gt;检索值。</target>
        </trans-unit>
        <trans-unit id="eaed8c58c642d50f6930fd66554c7e5248239528" translate="yes" xml:space="preserve">
          <source>If the JDBC type expected to be returned to this output parameter is specific to this particular database, &lt;code&gt;sqlType&lt;/code&gt; should be &lt;code&gt;JDBCType.OTHER&lt;/code&gt; or a &lt;code&gt;SQLType&lt;/code&gt; that is supported by the JDBC driver.. The method &lt;a href=&quot;#getObject(int)&quot;&gt;&lt;code&gt;getObject(int)&lt;/code&gt;&lt;/a&gt; retrieves the value.</source>
          <target state="translated">如果期望返回到此输出参数的JDBC类型是特定于此特定数据库的，则 &lt;code&gt;sqlType&lt;/code&gt; 应该是 &lt;code&gt;JDBCType.OTHER&lt;/code&gt; 或JDBC驱动程序支持的 &lt;code&gt;SQLType&lt;/code&gt; 。.方法&lt;a href=&quot;#getObject(int)&quot;&gt; &lt;code&gt;getObject(int)&lt;/code&gt; &lt;/a&gt;检索该值。</target>
        </trans-unit>
        <trans-unit id="b6b43fc4ae5c3356c9a39c1f15c9fcd8a5ed346a" translate="yes" xml:space="preserve">
          <source>If the JDBC type expected to be returned to this output parameter is specific to this particular database, &lt;code&gt;sqlType&lt;/code&gt; should be &lt;code&gt;java.sql.Types.OTHER&lt;/code&gt;. The method &lt;a href=&quot;#getObject(int)&quot;&gt;&lt;code&gt;getObject(int)&lt;/code&gt;&lt;/a&gt; retrieves the value.</source>
          <target state="translated">如果期望返回到此输出参数的JDBC类型是特定于此特定数据库的，则 &lt;code&gt;sqlType&lt;/code&gt; 应该为 &lt;code&gt;java.sql.Types.OTHER&lt;/code&gt; 。方法&lt;a href=&quot;#getObject(int)&quot;&gt; &lt;code&gt;getObject(int)&lt;/code&gt; &lt;/a&gt;检索值。</target>
        </trans-unit>
        <trans-unit id="d8e121332002fc8657fe1d312a926bed5da0268b" translate="yes" xml:space="preserve">
          <source>If the Java implementation provides the command-line interface and you run your application by using the command line or a shortcut, use the Java application launcher option to show a splash screen. The Oracle reference implementation allows you to specify the splash screen image location with the &lt;code&gt;-splash:&lt;/code&gt; option.</source>
          <target state="translated">如果Java实现提供了命令行界面，并且您使用命令行或快捷方式运行了应用程序，请使用Java应用程序启动器选项显示初始屏幕。Oracle参考实现允许您使用 &lt;code&gt;-splash:&lt;/code&gt; 选项指定初始屏幕图像的位置。</target>
        </trans-unit>
        <trans-unit id="540e105812b408574fe65500e02fda28804c6512" translate="yes" xml:space="preserve">
          <source>If the List allows multiple selections, then clicking on an item that is already selected deselects it. In the preceding example, only one item from the scrolling list can be selected at a time, since the second argument when creating the new scrolling list is &lt;code&gt;false&lt;/code&gt;. If the List does not allow multiple selections, selecting an item causes any other selected item to be deselected.</source>
          <target state="translated">如果列表允许多个选择，则单击已选择的项目将取消选择它。在前面的示例中，一次只能选择滚动列表中的一项，因为创建新滚动列表时的第二个参数为 &lt;code&gt;false&lt;/code&gt; 。如果&amp;ldquo;列表&amp;rdquo;不允许多项选择，则选择一个项目将导致取消选择任何其他选定的项目。</target>
        </trans-unit>
        <trans-unit id="b9320150224d23795105d0b84d8ba0219f014f46" translate="yes" xml:space="preserve">
          <source>If the LoginContext's overall authentication failed (the relevant REQUIRED, REQUISITE, SUFFICIENT and OPTIONAL LoginModules did not succeed), then the &lt;code&gt;abort&lt;/code&gt; method for each &lt;code&gt;LoginModule&lt;/code&gt; gets invoked. In this case, the &lt;code&gt;LoginModule&lt;/code&gt; removes/destroys any authentication state originally saved.</source>
          <target state="translated">如果LoginContext的整体身份验证失败（相关的REQUIRED，REQUISITE，SUFFICIENT和OPTIONAL LoginModules不成功），则将调用每个 &lt;code&gt;LoginModule&lt;/code&gt; 的 &lt;code&gt;abort&lt;/code&gt; 方法。在这种情况下， &lt;code&gt;LoginModule&lt;/code&gt; 删除/破坏最初保存的任何身份验证状态。</target>
        </trans-unit>
        <trans-unit id="8b1ca264c954dc0a754372106598096735c9ddf1" translate="yes" xml:space="preserve">
          <source>If the MXBean is a notification emitter (i.e., it implements &lt;a href=&quot;../../../javax/management/notificationemitter&quot;&gt;&lt;code&gt;NotificationEmitter&lt;/code&gt;&lt;/a&gt;), both the &lt;code&gt;mxbeanInterface&lt;/code&gt; and &lt;code&gt;NotificationEmitter&lt;/code&gt; will be implemented by this proxy.</source>
          <target state="translated">如果MXBean是通知发射器（即，它实现&lt;a href=&quot;../../../javax/management/notificationemitter&quot;&gt; &lt;code&gt;NotificationEmitter&lt;/code&gt; &lt;/a&gt;），则此代理将同时实现 &lt;code&gt;mxbeanInterface&lt;/code&gt; 和 &lt;code&gt;NotificationEmitter&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="474328420a397c96b5f80aa5f7aa2f2d53878174" translate="yes" xml:space="preserve">
          <source>If the ModelMBean is currently registered, this method throws a &lt;a href=&quot;../runtimeoperationsexception&quot;&gt;&lt;code&gt;RuntimeOperationsException&lt;/code&gt;&lt;/a&gt; wrapping an &lt;a href=&quot;../../../../java.base/java/lang/illegalstateexception&quot;&gt;&lt;code&gt;IllegalStateException&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">如果当前已注册ModelMBean，则此方法将引发包装&lt;a href=&quot;../../../../java.base/java/lang/illegalstateexception&quot;&gt; &lt;code&gt;IllegalStateException&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;../runtimeoperationsexception&quot;&gt; &lt;code&gt;RuntimeOperationsException&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b43d6c84cc6fb1e54fa1b85884c057f4a6774967" translate="yes" xml:space="preserve">
          <source>If the ModelMBean is currently registered, this method throws a &lt;a href=&quot;../runtimeoperationsexception&quot;&gt;&lt;code&gt;RuntimeOperationsException&lt;/code&gt;&lt;/a&gt; wrapping an &lt;a href=&quot;../../../java/lang/illegalstateexception&quot;&gt;&lt;code&gt;IllegalStateException&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">如果当前已注册ModelMBean，则此方法将引发包装&lt;a href=&quot;../../../java/lang/illegalstateexception&quot;&gt; &lt;code&gt;IllegalStateException&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;../runtimeoperationsexception&quot;&gt; &lt;code&gt;RuntimeOperationsException&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0961519d04df02ef89d0ae88943ca50d0c3606b3" translate="yes" xml:space="preserve">
          <source>If the Namespace URI is &lt;code&gt;null&lt;/code&gt;, it is set to &lt;a href=&quot;../xmlconstants#NULL_NS_URI&quot;&gt;&lt;code&gt;XMLConstants.NULL_NS_URI&lt;/code&gt;&lt;/a&gt;. This value represents no explicitly defined Namespace as defined by the &lt;a href=&quot;http://www.w3.org/TR/REC-xml-names/#ns-qualnames&quot;&gt;Namespaces in XML&lt;/a&gt; specification. This action preserves compatible behavior with QName 1.0. Explicitly providing the &lt;a href=&quot;../xmlconstants#NULL_NS_URI&quot;&gt;&lt;code&gt;XMLConstants.NULL_NS_URI&lt;/code&gt;&lt;/a&gt; value is the preferred coding style.</source>
          <target state="translated">如果命名空间URI为 &lt;code&gt;null&lt;/code&gt; ，则将其设置为&lt;a href=&quot;../xmlconstants#NULL_NS_URI&quot;&gt; &lt;code&gt;XMLConstants.NULL_NS_URI&lt;/code&gt; &lt;/a&gt;。此值不表示&lt;a href=&quot;http://www.w3.org/TR/REC-xml-names/#ns-qualnames&quot;&gt;XML&lt;/a&gt;规范中的命名空间所定义的显式定义的命名空间。此操作保留与QName 1.0兼容的行为。显式提供&lt;a href=&quot;../xmlconstants#NULL_NS_URI&quot;&gt; &lt;code&gt;XMLConstants.NULL_NS_URI&lt;/code&gt; &lt;/a&gt;值是首选的编码样式。</target>
        </trans-unit>
        <trans-unit id="dabcc8898ed3cdd7dba813817a17b3c719cbc02b" translate="yes" xml:space="preserve">
          <source>If the Namespace URI is &lt;code&gt;null&lt;/code&gt;, it is set to &lt;a href=&quot;../xmlconstants#NULL_NS_URI&quot;&gt;&lt;code&gt;XMLConstants.NULL_NS_URI&lt;/code&gt;&lt;/a&gt;. This value represents no explicitly defined Namespace as defined by the &lt;a href=&quot;https://www.w3.org/TR/REC-xml-names/#ns-qualnames&quot;&gt;Namespaces in XML&lt;/a&gt; specification. This action preserves compatible behavior with QName 1.0. Explicitly providing the &lt;a href=&quot;../xmlconstants#NULL_NS_URI&quot;&gt;&lt;code&gt;XMLConstants.NULL_NS_URI&lt;/code&gt;&lt;/a&gt; value is the preferred coding style.</source>
          <target state="translated">如果命名空间URI为 &lt;code&gt;null&lt;/code&gt; ，则将其设置为&lt;a href=&quot;../xmlconstants#NULL_NS_URI&quot;&gt; &lt;code&gt;XMLConstants.NULL_NS_URI&lt;/code&gt; &lt;/a&gt;。此值不表示&lt;a href=&quot;https://www.w3.org/TR/REC-xml-names/#ns-qualnames&quot;&gt;XML&lt;/a&gt;规范中的命名空间所定义的显式定义的命名空间。此操作保留与QName 1.0兼容的行为。显式提供&lt;a href=&quot;../xmlconstants#NULL_NS_URI&quot;&gt; &lt;code&gt;XMLConstants.NULL_NS_URI&lt;/code&gt; &lt;/a&gt;值是首选的编码样式。</target>
        </trans-unit>
        <trans-unit id="e5cc0b4b6523113fb60bbdd890e2ed587190e3eb" translate="yes" xml:space="preserve">
          <source>If the PropertyEditor doesn't honor paint requests (see isPaintable) this method should be a silent noop.</source>
          <target state="translated">如果PropertyEditor不尊重绘画请求(见isPaintable),这个方法应该是一个沉默的noop。</target>
        </trans-unit>
        <trans-unit id="edc7ecb68896dc99cf3bfe6d1c68065fc233cc04" translate="yes" xml:space="preserve">
          <source>If the ProtectionDomain was constructed to a &lt;a href=&quot;protectiondomain#ProtectionDomain-java.security.CodeSource-java.security.PermissionCollection-&quot;&gt;&lt;code&gt;statically bound&lt;/code&gt;&lt;/a&gt; PermissionCollection then the permission will only be checked against the PermissionCollection supplied at construction.</source>
          <target state="translated">如果将ProtectionDomain构造为&lt;a href=&quot;protectiondomain#ProtectionDomain-java.security.CodeSource-java.security.PermissionCollection-&quot;&gt; &lt;code&gt;statically bound&lt;/code&gt; &lt;/a&gt; PermissionCollection，则将仅对照构造时提供的PermissionCollection来检查权限。</target>
        </trans-unit>
        <trans-unit id="a847aec68a3d5a379f34ca3fc370c158f7a9888a" translate="yes" xml:space="preserve">
          <source>If the Result is not to be written to a file, the system identifier is optional. The application may still want to provide one, however, for use in error messages and warnings, or to resolve relative output identifiers.</source>
          <target state="translated">如果不将结果写入文件,系统标识符是可选的。但是,应用程序可能仍然希望提供一个系统标识符,以便在错误信息和警告中使用,或者解析相对的输出标识符。</target>
        </trans-unit>
        <trans-unit id="d85ecd870d90f0c4db4acd7de59edc66dc5f937f" translate="yes" xml:space="preserve">
          <source>If the URL path part of the &lt;code&gt;JMXServiceURL&lt;/code&gt; was empty or a single slash (&lt;code&gt;/&lt;/code&gt;), then the RMI object will not be bound to a directory. Instead, a reference to it will be encoded in the URL path of the RMIConnectorServer address (returned by &lt;a href=&quot;../../../../../java.management/javax/management/remote/jmxconnectorservermbean#getAddress()&quot;&gt;&lt;code&gt;JMXConnectorServerMBean.getAddress()&lt;/code&gt;&lt;/a&gt;). The encodings for &lt;code&gt;rmi&lt;/code&gt; are described in the package documentation for &lt;a href=&quot;package-summary&quot;&gt;&lt;code&gt;javax.management.remote.rmi&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;JMXServiceURL&lt;/code&gt; 的URL路径部分为空或单个斜杠（ &lt;code&gt;/&lt;/code&gt; ），则RMI对象将不会绑定到目录。相反，对它的引用将被编码在RMIConnectorServer地址的URL路径中（由&lt;a href=&quot;../../../../../java.management/javax/management/remote/jmxconnectorservermbean#getAddress()&quot;&gt; &lt;code&gt;JMXConnectorServerMBean.getAddress()&lt;/code&gt; &lt;/a&gt;返回）。 &lt;code&gt;rmi&lt;/code&gt; 的编码在&lt;a href=&quot;package-summary&quot;&gt; &lt;code&gt;javax.management.remote.rmi&lt;/code&gt; &lt;/a&gt;的软件包文档中描述。</target>
        </trans-unit>
        <trans-unit id="1eb3e9bfa37e0fb36cbe25f740fc69395067b33e" translate="yes" xml:space="preserve">
          <source>If the URL path part of the &lt;code&gt;JMXServiceURL&lt;/code&gt; was empty or a single slash (&lt;code&gt;/&lt;/code&gt;), then the RMI object will not be bound to a directory. Instead, a reference to it will be encoded in the URL path of the RMIConnectorServer address (returned by &lt;a href=&quot;rmiconnectorserver#getAddress--&quot;&gt;&lt;code&gt;getAddress()&lt;/code&gt;&lt;/a&gt;). The encodings for &lt;code&gt;rmi&lt;/code&gt; and &lt;code&gt;iiop&lt;/code&gt; are described in the package documentation for &lt;a href=&quot;package-summary&quot;&gt;&lt;code&gt;javax.management.remote.rmi&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;JMXServiceURL&lt;/code&gt; 的URL路径部分为空或单个斜杠（ &lt;code&gt;/&lt;/code&gt; ），则RMI对象将不会绑定到目录。相反，对它的引用将被编码在RMIConnectorServer地址的URL路径中（由&lt;a href=&quot;rmiconnectorserver#getAddress--&quot;&gt; &lt;code&gt;getAddress()&lt;/code&gt; &lt;/a&gt;返回）。 &lt;code&gt;rmi&lt;/code&gt; 和 &lt;code&gt;iiop&lt;/code&gt; 的编码在&lt;a href=&quot;package-summary&quot;&gt; &lt;code&gt;javax.management.remote.rmi&lt;/code&gt; &lt;/a&gt;的软件包文档中描述。</target>
        </trans-unit>
        <trans-unit id="7c88147c00b169cc4a7d700bc22d47ae19dc49b7" translate="yes" xml:space="preserve">
          <source>If the URL specified is &lt;code&gt;null&lt;/code&gt; or is already in the list of URLs, or if this loader is closed, then invoking this method has no effect.</source>
          <target state="translated">如果指定的URL为 &lt;code&gt;null&lt;/code&gt; 或已经在URL列表中，或者关闭了此加载器，则调用此方法无效。</target>
        </trans-unit>
        <trans-unit id="2c0237f144da2fa8c67cb271e88ffe70a6e43f35" translate="yes" xml:space="preserve">
          <source>If the USE_STD3_ASCII_RULES flag is used, ASCII strings are checked against &lt;a href=&quot;http://www.ietf.org/rfc/rfc1122.txt&quot;&gt;RFC 1122&lt;/a&gt; and &lt;a href=&quot;http://www.ietf.org/rfc/rfc1123.txt&quot;&gt;RFC 1123&lt;/a&gt;. It is an error if they don't meet the requirements.</source>
          <target state="translated">如果使用USE_STD3_ASCII_RULES标志，则根据&lt;a href=&quot;http://www.ietf.org/rfc/rfc1122.txt&quot;&gt;RFC 1122&lt;/a&gt;和&lt;a href=&quot;http://www.ietf.org/rfc/rfc1123.txt&quot;&gt;RFC 1123&lt;/a&gt;检查ASCII字符串。如果他们不符合要求，那就是错误的。</target>
        </trans-unit>
        <trans-unit id="b6f15acd38bd7687f1a77e9bf3871ba04075f07a" translate="yes" xml:space="preserve">
          <source>If the USE_STD3_ASCII_RULES flag is used, ASCII strings are checked against &lt;a href=&quot;https://www.ietf.org/rfc/rfc1122.txt&quot;&gt;RFC 1122&lt;/a&gt; and &lt;a href=&quot;https://www.ietf.org/rfc/rfc1123.txt&quot;&gt;RFC 1123&lt;/a&gt;. It is an error if they don't meet the requirements.</source>
          <target state="translated">如果使用USE_STD3_ASCII_RULES标志，则根据&lt;a href=&quot;https://www.ietf.org/rfc/rfc1122.txt&quot;&gt;RFC 1122&lt;/a&gt;和&lt;a href=&quot;https://www.ietf.org/rfc/rfc1123.txt&quot;&gt;RFC 1123&lt;/a&gt;检查ASCII字符串。如果他们不符合要求，那就是错误的。</target>
        </trans-unit>
        <trans-unit id="27b1988df75b26444a795d6673a2d8719150a662" translate="yes" xml:space="preserve">
          <source>If the Unicode Standard changes block names, both the previous and current names will be accepted.</source>
          <target state="translated">如果Unicode标准改变了块名,以前的和当前的名称都会被接受。</target>
        </trans-unit>
        <trans-unit id="4474e2c1fcf43dbf037954df628912501189beb2" translate="yes" xml:space="preserve">
          <source>If the Vector fits in the specified array with room to spare (i.e., the array has more elements than the Vector), the element in the array immediately following the end of the Vector is set to null. (This is useful in determining the length of the Vector &lt;em&gt;only&lt;/em&gt; if the caller knows that the Vector does not contain any null elements.)</source>
          <target state="translated">如果Vector符合指定数组的剩余空间（即，数组中的元素多于Vector），则将紧随Vector末尾的数组中的元素设置为null。（&lt;em&gt;仅&lt;/em&gt;当调用者知道Vector不包含任何null元素时，这才对确定Vector的长度很有用。）</target>
        </trans-unit>
        <trans-unit id="ce465ff8cda6a5a08541bee73f2366bdc5b6d6b4" translate="yes" xml:space="preserve">
          <source>If the WebSocket's output is not already closed, the &lt;code&gt;CompletionStage&lt;/code&gt; returned by this method will be used as an indication that the WebSocket's output may be closed. The WebSocket will close its output at the earliest of completion of the returned &lt;code&gt;CompletionStage&lt;/code&gt; or invoking either of the &lt;code&gt;sendClose&lt;/code&gt; or &lt;code&gt;abort&lt;/code&gt; methods.</source>
          <target state="translated">如果尚未关闭WebSocket的输出，则此方法返回的 &lt;code&gt;CompletionStage&lt;/code&gt; 将用作表明WebSocket的输出可能已关闭的指示。WebSocket将在完成返回的 &lt;code&gt;CompletionStage&lt;/code&gt; 或调用 &lt;code&gt;sendClose&lt;/code&gt; 或 &lt;code&gt;abort&lt;/code&gt; 方法中的最早一个时关闭其输出。</target>
        </trans-unit>
        <trans-unit id="fa08a72545add7979284f586fe9352374af63dad" translate="yes" xml:space="preserve">
          <source>If the above rules do not produce a value, and if introspection, as if by calling &lt;a href=&quot;../../../../java.desktop/java/beans/introspector#getBeanInfo(java.lang.Class)&quot;&gt;&lt;code&gt;Introspector.getBeanInfo&lt;/code&gt;&lt;/a&gt;, for the class of</source>
          <target state="translated">如果上述规则未产生值，并且进行了自省，就好像通过调用&lt;a href=&quot;../../../../java.desktop/java/beans/introspector#getBeanInfo(java.lang.Class)&quot;&gt; &lt;code&gt;Introspector.getBeanInfo&lt;/code&gt; &lt;/a&gt;来获得</target>
        </trans-unit>
        <trans-unit id="9f95877bd50006d6d00056ef2a51aa22bd21083c" translate="yes" xml:space="preserve">
          <source>If the above rules do not produce a value, and if introspection, as if by calling &lt;a href=&quot;../../../java/beans/introspector#getBeanInfo-java.lang.Class-&quot;&gt;&lt;code&gt;Introspector.getBeanInfo&lt;/code&gt;&lt;/a&gt;, for the class of</source>
          <target state="translated">如果上述规则未产生值，并且进行了自省，就好像通过调用&lt;a href=&quot;../../../java/beans/introspector#getBeanInfo-java.lang.Class-&quot;&gt; &lt;code&gt;Introspector.getBeanInfo&lt;/code&gt; &lt;/a&gt;为该类</target>
        </trans-unit>
        <trans-unit id="9b05835af2c154a7c76f77377aa6c52d404cdcb8" translate="yes" xml:space="preserve">
          <source>If the absolute value of the first argument equals 1 and the second argument is infinite, then the result is NaN.</source>
          <target state="translated">如果第一个参数的绝对值等于1,第二个参数是无限的,那么结果就是NaN。</target>
        </trans-unit>
        <trans-unit id="fe0dcdb806d329477c57d32f9509598b1acef0b9" translate="yes" xml:space="preserve">
          <source>If the accelerator is hidden, the method returns &lt;code&gt;true&lt;/code&gt;, otherwise, returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果隐藏了加速器，则该方法返回 &lt;code&gt;true&lt;/code&gt; ，否则返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6775ecd73f74676bf13df91da30c3cc2254a84a5" translate="yes" xml:space="preserve">
          <source>If the action has been registered multiple times, all instances are unregistered.</source>
          <target state="translated">如果动作已被多次注册,则所有实例均未注册。</target>
        </trans-unit>
        <trans-unit id="e03f3411418a033b6bfa2f883c240355cb3f69a7" translate="yes" xml:space="preserve">
          <source>If the action is an instance of &lt;code&gt;DoubleConsumer&lt;/code&gt; then it is cast to &lt;code&gt;DoubleConsumer&lt;/code&gt; and passed to &lt;a href=&quot;#forEachRemaining(java.util.function.DoubleConsumer)&quot;&gt;&lt;code&gt;forEachRemaining(java.util.function.DoubleConsumer)&lt;/code&gt;&lt;/a&gt;; otherwise the action is adapted to an instance of &lt;code&gt;DoubleConsumer&lt;/code&gt;, by boxing the argument of &lt;code&gt;DoubleConsumer&lt;/code&gt;, and then passed to &lt;a href=&quot;#forEachRemaining(java.util.function.DoubleConsumer)&quot;&gt;&lt;code&gt;forEachRemaining(java.util.function.DoubleConsumer)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果操作是 &lt;code&gt;DoubleConsumer&lt;/code&gt; 的实例，则将其&lt;a href=&quot;#forEachRemaining(java.util.function.DoubleConsumer)&quot;&gt; &lt;code&gt;forEachRemaining(java.util.function.DoubleConsumer)&lt;/code&gt; &lt;/a&gt; &lt;code&gt;DoubleConsumer&lt;/code&gt; 为DoubleConsumer并传递给forEachRemaining（java.util.function.DoubleConsumer）；否则，通过将 &lt;code&gt;DoubleConsumer&lt;/code&gt; 的参数装箱，将操作调整为 &lt;code&gt;DoubleConsumer&lt;/code&gt; 实例，然后将其传递给&lt;a href=&quot;#forEachRemaining(java.util.function.DoubleConsumer)&quot;&gt; &lt;code&gt;forEachRemaining(java.util.function.DoubleConsumer)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d6afccfd8739251584afc0914039b51c90ada53f" translate="yes" xml:space="preserve">
          <source>If the action is an instance of &lt;code&gt;DoubleConsumer&lt;/code&gt; then it is cast to &lt;code&gt;DoubleConsumer&lt;/code&gt; and passed to &lt;a href=&quot;primitiveiterator.ofdouble#forEachRemaining-java.util.function.DoubleConsumer-&quot;&gt;&lt;code&gt;forEachRemaining(java.util.function.DoubleConsumer)&lt;/code&gt;&lt;/a&gt;; otherwise the action is adapted to an instance of &lt;code&gt;DoubleConsumer&lt;/code&gt;, by boxing the argument of &lt;code&gt;DoubleConsumer&lt;/code&gt;, and then passed to &lt;a href=&quot;primitiveiterator.ofdouble#forEachRemaining-java.util.function.DoubleConsumer-&quot;&gt;&lt;code&gt;forEachRemaining(java.util.function.DoubleConsumer)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果操作是 &lt;code&gt;DoubleConsumer&lt;/code&gt; 的实例，则将其&lt;a href=&quot;primitiveiterator.ofdouble#forEachRemaining-java.util.function.DoubleConsumer-&quot;&gt; &lt;code&gt;forEachRemaining(java.util.function.DoubleConsumer)&lt;/code&gt; &lt;/a&gt; &lt;code&gt;DoubleConsumer&lt;/code&gt; 为DoubleConsumer并传递给forEachRemaining（java.util.function.DoubleConsumer）；否则，通过将 &lt;code&gt;DoubleConsumer&lt;/code&gt; 的参数装箱，将操作调整为 &lt;code&gt;DoubleConsumer&lt;/code&gt; 的实例，然后将其传递给&lt;a href=&quot;primitiveiterator.ofdouble#forEachRemaining-java.util.function.DoubleConsumer-&quot;&gt; &lt;code&gt;forEachRemaining(java.util.function.DoubleConsumer)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="66516904fde9701dc7f61bc426819fb4f146f708" translate="yes" xml:space="preserve">
          <source>If the action is an instance of &lt;code&gt;DoubleConsumer&lt;/code&gt; then it is cast to &lt;code&gt;DoubleConsumer&lt;/code&gt; and passed to &lt;a href=&quot;spliterator.ofdouble#forEachRemaining-java.util.function.DoubleConsumer-&quot;&gt;&lt;code&gt;forEachRemaining(java.util.function.DoubleConsumer)&lt;/code&gt;&lt;/a&gt;; otherwise the action is adapted to an instance of &lt;code&gt;DoubleConsumer&lt;/code&gt;, by boxing the argument of &lt;code&gt;DoubleConsumer&lt;/code&gt;, and then passed to &lt;a href=&quot;spliterator.ofdouble#forEachRemaining-java.util.function.DoubleConsumer-&quot;&gt;&lt;code&gt;forEachRemaining(java.util.function.DoubleConsumer)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果操作是 &lt;code&gt;DoubleConsumer&lt;/code&gt; 的实例，则将其&lt;a href=&quot;spliterator.ofdouble#forEachRemaining-java.util.function.DoubleConsumer-&quot;&gt; &lt;code&gt;forEachRemaining(java.util.function.DoubleConsumer)&lt;/code&gt; &lt;/a&gt; &lt;code&gt;DoubleConsumer&lt;/code&gt; 为DoubleConsumer并传递给forEachRemaining（java.util.function.DoubleConsumer）；否则，通过将 &lt;code&gt;DoubleConsumer&lt;/code&gt; 的参数装箱，将操作调整为 &lt;code&gt;DoubleConsumer&lt;/code&gt; 的实例，然后将其传递给&lt;a href=&quot;spliterator.ofdouble#forEachRemaining-java.util.function.DoubleConsumer-&quot;&gt; &lt;code&gt;forEachRemaining(java.util.function.DoubleConsumer)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6e52e55025286a627afde1b1d2b384ea2bee735b" translate="yes" xml:space="preserve">
          <source>If the action is an instance of &lt;code&gt;DoubleConsumer&lt;/code&gt; then it is cast to &lt;code&gt;DoubleConsumer&lt;/code&gt; and passed to &lt;a href=&quot;spliterator.ofdouble#tryAdvance-java.util.function.DoubleConsumer-&quot;&gt;&lt;code&gt;tryAdvance(java.util.function.DoubleConsumer)&lt;/code&gt;&lt;/a&gt;; otherwise the action is adapted to an instance of &lt;code&gt;DoubleConsumer&lt;/code&gt;, by boxing the argument of &lt;code&gt;DoubleConsumer&lt;/code&gt;, and then passed to &lt;a href=&quot;spliterator.ofdouble#tryAdvance-java.util.function.DoubleConsumer-&quot;&gt;&lt;code&gt;tryAdvance(java.util.function.DoubleConsumer)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果操作是 &lt;code&gt;DoubleConsumer&lt;/code&gt; 的实例，则将其&lt;a href=&quot;spliterator.ofdouble#tryAdvance-java.util.function.DoubleConsumer-&quot;&gt; &lt;code&gt;tryAdvance(java.util.function.DoubleConsumer)&lt;/code&gt; &lt;/a&gt; &lt;code&gt;DoubleConsumer&lt;/code&gt; 为DoubleConsumer并传递给tryAdvance（java.util.function.DoubleConsumer）；否则，通过将 &lt;code&gt;DoubleConsumer&lt;/code&gt; 的参数装箱，将操作调整为 &lt;code&gt;DoubleConsumer&lt;/code&gt; 实例，然后将其传递给&lt;a href=&quot;spliterator.ofdouble#tryAdvance-java.util.function.DoubleConsumer-&quot;&gt; &lt;code&gt;tryAdvance(java.util.function.DoubleConsumer)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f5601c43da232fcabd407827972e1da20bb1375e" translate="yes" xml:space="preserve">
          <source>If the action is an instance of &lt;code&gt;DoubleConsumer&lt;/code&gt; then it is cast to &lt;code&gt;DoubleConsumer&lt;/code&gt; and passed to &lt;a href=&quot;spliterator.ofprimitive#forEachRemaining(T_CONS)&quot;&gt;&lt;code&gt;Spliterator.OfPrimitive.forEachRemaining(java.util.function.DoubleConsumer)&lt;/code&gt;&lt;/a&gt;; otherwise the action is adapted to an instance of &lt;code&gt;DoubleConsumer&lt;/code&gt;, by boxing the argument of &lt;code&gt;DoubleConsumer&lt;/code&gt;, and then passed to &lt;a href=&quot;spliterator.ofprimitive#forEachRemaining(T_CONS)&quot;&gt;&lt;code&gt;Spliterator.OfPrimitive.forEachRemaining(java.util.function.DoubleConsumer)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果操作是 &lt;code&gt;DoubleConsumer&lt;/code&gt; 的实例，则将其&lt;a href=&quot;spliterator.ofprimitive#forEachRemaining(T_CONS)&quot;&gt; &lt;code&gt;Spliterator.OfPrimitive.forEachRemaining(java.util.function.DoubleConsumer)&lt;/code&gt; &lt;/a&gt; &lt;code&gt;DoubleConsumer&lt;/code&gt; 为DoubleConsumer并传递给Spliterator.OfPrimitive.forEachRemaining（java.util.function.DoubleConsumer）；否则，通过将 &lt;code&gt;DoubleConsumer&lt;/code&gt; 的参数装箱，将操作调整为 &lt;code&gt;DoubleConsumer&lt;/code&gt; 实例，然后将其传递给&lt;a href=&quot;spliterator.ofprimitive#forEachRemaining(T_CONS)&quot;&gt; &lt;code&gt;Spliterator.OfPrimitive.forEachRemaining(java.util.function.DoubleConsumer)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="69341c18d84e15fb20d184c341ea1d0d7b8cbcda" translate="yes" xml:space="preserve">
          <source>If the action is an instance of &lt;code&gt;DoubleConsumer&lt;/code&gt; then it is cast to &lt;code&gt;DoubleConsumer&lt;/code&gt; and passed to &lt;a href=&quot;spliterator.ofprimitive#tryAdvance(T_CONS)&quot;&gt;&lt;code&gt;Spliterator.OfPrimitive.tryAdvance(java.util.function.DoubleConsumer)&lt;/code&gt;&lt;/a&gt;; otherwise the action is adapted to an instance of &lt;code&gt;DoubleConsumer&lt;/code&gt;, by boxing the argument of &lt;code&gt;DoubleConsumer&lt;/code&gt;, and then passed to &lt;a href=&quot;spliterator.ofprimitive#tryAdvance(T_CONS)&quot;&gt;&lt;code&gt;Spliterator.OfPrimitive.tryAdvance(java.util.function.DoubleConsumer)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果操作是 &lt;code&gt;DoubleConsumer&lt;/code&gt; 的实例，则将其&lt;a href=&quot;spliterator.ofprimitive#tryAdvance(T_CONS)&quot;&gt; &lt;code&gt;Spliterator.OfPrimitive.tryAdvance(java.util.function.DoubleConsumer)&lt;/code&gt; &lt;/a&gt; &lt;code&gt;DoubleConsumer&lt;/code&gt; 为DoubleConsumer并传递给Spliterator.OfPrimitive.tryAdvance（java.util.function.DoubleConsumer）；否则，通过对 &lt;code&gt;DoubleConsumer&lt;/code&gt; 的参数进行装箱，将操作调整为 &lt;code&gt;DoubleConsumer&lt;/code&gt; 的实例，然后将其传递给&lt;a href=&quot;spliterator.ofprimitive#tryAdvance(T_CONS)&quot;&gt; &lt;code&gt;Spliterator.OfPrimitive.tryAdvance(java.util.function.DoubleConsumer)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0773f07cee5964ddff6a0726a10424e6fde400aa" translate="yes" xml:space="preserve">
          <source>If the action is an instance of &lt;code&gt;IntConsumer&lt;/code&gt; then it is cast to &lt;code&gt;IntConsumer&lt;/code&gt; and passed to &lt;a href=&quot;#forEachRemaining(java.util.function.IntConsumer)&quot;&gt;&lt;code&gt;forEachRemaining(java.util.function.IntConsumer)&lt;/code&gt;&lt;/a&gt;; otherwise the action is adapted to an instance of &lt;code&gt;IntConsumer&lt;/code&gt;, by boxing the argument of &lt;code&gt;IntConsumer&lt;/code&gt;, and then passed to &lt;a href=&quot;#forEachRemaining(java.util.function.IntConsumer)&quot;&gt;&lt;code&gt;forEachRemaining(java.util.function.IntConsumer)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果操作是 &lt;code&gt;IntConsumer&lt;/code&gt; 的实例，则将其强制转换为 &lt;code&gt;IntConsumer&lt;/code&gt; 并传递给&lt;a href=&quot;#forEachRemaining(java.util.function.IntConsumer)&quot;&gt; &lt;code&gt;forEachRemaining(java.util.function.IntConsumer)&lt;/code&gt; &lt;/a&gt;；否则，通过将 &lt;code&gt;IntConsumer&lt;/code&gt; 的参数置于框内，然后将该操作适应 &lt;code&gt;IntConsumer&lt;/code&gt; 的实例，然后将其传递给&lt;a href=&quot;#forEachRemaining(java.util.function.IntConsumer)&quot;&gt; &lt;code&gt;forEachRemaining(java.util.function.IntConsumer)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6eb467bff49959d09e05c7bab75146704c0dc28d" translate="yes" xml:space="preserve">
          <source>If the action is an instance of &lt;code&gt;IntConsumer&lt;/code&gt; then it is cast to &lt;code&gt;IntConsumer&lt;/code&gt; and passed to &lt;a href=&quot;primitiveiterator.ofint#forEachRemaining-java.util.function.IntConsumer-&quot;&gt;&lt;code&gt;forEachRemaining(java.util.function.IntConsumer)&lt;/code&gt;&lt;/a&gt;; otherwise the action is adapted to an instance of &lt;code&gt;IntConsumer&lt;/code&gt;, by boxing the argument of &lt;code&gt;IntConsumer&lt;/code&gt;, and then passed to &lt;a href=&quot;primitiveiterator.ofint#forEachRemaining-java.util.function.IntConsumer-&quot;&gt;&lt;code&gt;forEachRemaining(java.util.function.IntConsumer)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果操作是 &lt;code&gt;IntConsumer&lt;/code&gt; 的实例，则将其强制转换为 &lt;code&gt;IntConsumer&lt;/code&gt; 并传递给&lt;a href=&quot;primitiveiterator.ofint#forEachRemaining-java.util.function.IntConsumer-&quot;&gt; &lt;code&gt;forEachRemaining(java.util.function.IntConsumer)&lt;/code&gt; &lt;/a&gt;；否则，通过将 &lt;code&gt;IntConsumer&lt;/code&gt; 的参数装箱，将操作调整为 &lt;code&gt;IntConsumer&lt;/code&gt; 的实例，然后将其传递给&lt;a href=&quot;primitiveiterator.ofint#forEachRemaining-java.util.function.IntConsumer-&quot;&gt; &lt;code&gt;forEachRemaining(java.util.function.IntConsumer)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2cc7b37b752547334d50d87c5179ebe5f7826e35" translate="yes" xml:space="preserve">
          <source>If the action is an instance of &lt;code&gt;IntConsumer&lt;/code&gt; then it is cast to &lt;code&gt;IntConsumer&lt;/code&gt; and passed to &lt;a href=&quot;spliterator.ofint#forEachRemaining-java.util.function.IntConsumer-&quot;&gt;&lt;code&gt;forEachRemaining(java.util.function.IntConsumer)&lt;/code&gt;&lt;/a&gt;; otherwise the action is adapted to an instance of &lt;code&gt;IntConsumer&lt;/code&gt;, by boxing the argument of &lt;code&gt;IntConsumer&lt;/code&gt;, and then passed to &lt;a href=&quot;spliterator.ofint#forEachRemaining-java.util.function.IntConsumer-&quot;&gt;&lt;code&gt;forEachRemaining(java.util.function.IntConsumer)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果操作是 &lt;code&gt;IntConsumer&lt;/code&gt; 的实例，则将其强制转换为 &lt;code&gt;IntConsumer&lt;/code&gt; 并传递给&lt;a href=&quot;spliterator.ofint#forEachRemaining-java.util.function.IntConsumer-&quot;&gt; &lt;code&gt;forEachRemaining(java.util.function.IntConsumer)&lt;/code&gt; &lt;/a&gt;；否则，通过将 &lt;code&gt;IntConsumer&lt;/code&gt; 的参数装箱，将操作调整为 &lt;code&gt;IntConsumer&lt;/code&gt; 的实例，然后将其传递给&lt;a href=&quot;spliterator.ofint#forEachRemaining-java.util.function.IntConsumer-&quot;&gt; &lt;code&gt;forEachRemaining(java.util.function.IntConsumer)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e4a7f713f21116ad3b228e0623aa03e2b62a6679" translate="yes" xml:space="preserve">
          <source>If the action is an instance of &lt;code&gt;IntConsumer&lt;/code&gt; then it is cast to &lt;code&gt;IntConsumer&lt;/code&gt; and passed to &lt;a href=&quot;spliterator.ofint#tryAdvance-java.util.function.IntConsumer-&quot;&gt;&lt;code&gt;tryAdvance(java.util.function.IntConsumer)&lt;/code&gt;&lt;/a&gt;; otherwise the action is adapted to an instance of &lt;code&gt;IntConsumer&lt;/code&gt;, by boxing the argument of &lt;code&gt;IntConsumer&lt;/code&gt;, and then passed to &lt;a href=&quot;spliterator.ofint#tryAdvance-java.util.function.IntConsumer-&quot;&gt;&lt;code&gt;tryAdvance(java.util.function.IntConsumer)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果该动作是 &lt;code&gt;IntConsumer&lt;/code&gt; 的实例，则将其强制转换为 &lt;code&gt;IntConsumer&lt;/code&gt; 并传递给&lt;a href=&quot;spliterator.ofint#tryAdvance-java.util.function.IntConsumer-&quot;&gt; &lt;code&gt;tryAdvance(java.util.function.IntConsumer)&lt;/code&gt; &lt;/a&gt;；否则，通过将 &lt;code&gt;IntConsumer&lt;/code&gt; 的参数装箱，将操作调整为 &lt;code&gt;IntConsumer&lt;/code&gt; 的实例，然后将其传递给&lt;a href=&quot;spliterator.ofint#tryAdvance-java.util.function.IntConsumer-&quot;&gt; &lt;code&gt;tryAdvance(java.util.function.IntConsumer)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="91611fb9a517d38eefd5a99f44bd0d85a21d0920" translate="yes" xml:space="preserve">
          <source>If the action is an instance of &lt;code&gt;IntConsumer&lt;/code&gt; then it is cast to &lt;code&gt;IntConsumer&lt;/code&gt; and passed to &lt;a href=&quot;spliterator.ofprimitive#forEachRemaining(T_CONS)&quot;&gt;&lt;code&gt;Spliterator.OfPrimitive.forEachRemaining(java.util.function.IntConsumer)&lt;/code&gt;&lt;/a&gt;; otherwise the action is adapted to an instance of &lt;code&gt;IntConsumer&lt;/code&gt;, by boxing the argument of &lt;code&gt;IntConsumer&lt;/code&gt;, and then passed to &lt;a href=&quot;spliterator.ofprimitive#forEachRemaining(T_CONS)&quot;&gt;&lt;code&gt;Spliterator.OfPrimitive.forEachRemaining(java.util.function.IntConsumer)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果操作是 &lt;code&gt;IntConsumer&lt;/code&gt; 的实例，则将其强制转换为 &lt;code&gt;IntConsumer&lt;/code&gt; 并传递给&lt;a href=&quot;spliterator.ofprimitive#forEachRemaining(T_CONS)&quot;&gt; &lt;code&gt;Spliterator.OfPrimitive.forEachRemaining(java.util.function.IntConsumer)&lt;/code&gt; &lt;/a&gt;；否则，通过将 &lt;code&gt;IntConsumer&lt;/code&gt; 的参数装箱，将操作调整为 &lt;code&gt;IntConsumer&lt;/code&gt; 的实例，然后将其传递给&lt;a href=&quot;spliterator.ofprimitive#forEachRemaining(T_CONS)&quot;&gt; &lt;code&gt;Spliterator.OfPrimitive.forEachRemaining(java.util.function.IntConsumer)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5728c1fd6c7474b8e5ee24332d657e8c59b795d7" translate="yes" xml:space="preserve">
          <source>If the action is an instance of &lt;code&gt;IntConsumer&lt;/code&gt; then it is cast to &lt;code&gt;IntConsumer&lt;/code&gt; and passed to &lt;a href=&quot;spliterator.ofprimitive#tryAdvance(T_CONS)&quot;&gt;&lt;code&gt;Spliterator.OfPrimitive.tryAdvance(java.util.function.IntConsumer)&lt;/code&gt;&lt;/a&gt;; otherwise the action is adapted to an instance of &lt;code&gt;IntConsumer&lt;/code&gt;, by boxing the argument of &lt;code&gt;IntConsumer&lt;/code&gt;, and then passed to &lt;a href=&quot;spliterator.ofprimitive#tryAdvance(T_CONS)&quot;&gt;&lt;code&gt;Spliterator.OfPrimitive.tryAdvance(java.util.function.IntConsumer)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果操作是 &lt;code&gt;IntConsumer&lt;/code&gt; 的实例，则将其强制转换为 &lt;code&gt;IntConsumer&lt;/code&gt; 并传递给&lt;a href=&quot;spliterator.ofprimitive#tryAdvance(T_CONS)&quot;&gt; &lt;code&gt;Spliterator.OfPrimitive.tryAdvance(java.util.function.IntConsumer)&lt;/code&gt; &lt;/a&gt;；否则，通过将 &lt;code&gt;IntConsumer&lt;/code&gt; 的参数装箱，将操作调整为 &lt;code&gt;IntConsumer&lt;/code&gt; 的实例，然后将其传递给&lt;a href=&quot;spliterator.ofprimitive#tryAdvance(T_CONS)&quot;&gt; &lt;code&gt;Spliterator.OfPrimitive.tryAdvance(java.util.function.IntConsumer)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="06d370e1cbaab2bb12cd8d0300073053596d5bf6" translate="yes" xml:space="preserve">
          <source>If the action is an instance of &lt;code&gt;LongConsumer&lt;/code&gt; then it is cast to &lt;code&gt;LongConsumer&lt;/code&gt; and passed to &lt;a href=&quot;#forEachRemaining(java.util.function.LongConsumer)&quot;&gt;&lt;code&gt;forEachRemaining(java.util.function.LongConsumer)&lt;/code&gt;&lt;/a&gt;; otherwise the action is adapted to an instance of &lt;code&gt;LongConsumer&lt;/code&gt;, by boxing the argument of &lt;code&gt;LongConsumer&lt;/code&gt;, and then passed to &lt;a href=&quot;#forEachRemaining(java.util.function.LongConsumer)&quot;&gt;&lt;code&gt;forEachRemaining(java.util.function.LongConsumer)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果该操作是 &lt;code&gt;LongConsumer&lt;/code&gt; 的实例，则将其强制转换为 &lt;code&gt;LongConsumer&lt;/code&gt; 并传递给&lt;a href=&quot;#forEachRemaining(java.util.function.LongConsumer)&quot;&gt; &lt;code&gt;forEachRemaining(java.util.function.LongConsumer)&lt;/code&gt; &lt;/a&gt;；否则，通过将 &lt;code&gt;LongConsumer&lt;/code&gt; 的参数装箱，将操作调整为 &lt;code&gt;LongConsumer&lt;/code&gt; 的实例，然后将其传递给&lt;a href=&quot;#forEachRemaining(java.util.function.LongConsumer)&quot;&gt; &lt;code&gt;forEachRemaining(java.util.function.LongConsumer)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="290eeb3f1f54f16b09955c88d8cfd90d14b9557d" translate="yes" xml:space="preserve">
          <source>If the action is an instance of &lt;code&gt;LongConsumer&lt;/code&gt; then it is cast to &lt;code&gt;LongConsumer&lt;/code&gt; and passed to &lt;a href=&quot;primitiveiterator.oflong#forEachRemaining-java.util.function.LongConsumer-&quot;&gt;&lt;code&gt;forEachRemaining(java.util.function.LongConsumer)&lt;/code&gt;&lt;/a&gt;; otherwise the action is adapted to an instance of &lt;code&gt;LongConsumer&lt;/code&gt;, by boxing the argument of &lt;code&gt;LongConsumer&lt;/code&gt;, and then passed to &lt;a href=&quot;primitiveiterator.oflong#forEachRemaining-java.util.function.LongConsumer-&quot;&gt;&lt;code&gt;forEachRemaining(java.util.function.LongConsumer)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果该操作是 &lt;code&gt;LongConsumer&lt;/code&gt; 的实例，则将其强制转换为 &lt;code&gt;LongConsumer&lt;/code&gt; 并传递给&lt;a href=&quot;primitiveiterator.oflong#forEachRemaining-java.util.function.LongConsumer-&quot;&gt; &lt;code&gt;forEachRemaining(java.util.function.LongConsumer)&lt;/code&gt; &lt;/a&gt;；否则，通过对 &lt;code&gt;LongConsumer&lt;/code&gt; 的参数进行装箱，将操作调整为 &lt;code&gt;LongConsumer&lt;/code&gt; 的实例，然后将其传递给&lt;a href=&quot;primitiveiterator.oflong#forEachRemaining-java.util.function.LongConsumer-&quot;&gt; &lt;code&gt;forEachRemaining(java.util.function.LongConsumer)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f0dcd5ef32e41f4bca014a916ec5e3e0e6b1fab7" translate="yes" xml:space="preserve">
          <source>If the action is an instance of &lt;code&gt;LongConsumer&lt;/code&gt; then it is cast to &lt;code&gt;LongConsumer&lt;/code&gt; and passed to &lt;a href=&quot;spliterator.oflong#forEachRemaining-java.util.function.LongConsumer-&quot;&gt;&lt;code&gt;forEachRemaining(java.util.function.LongConsumer)&lt;/code&gt;&lt;/a&gt;; otherwise the action is adapted to an instance of &lt;code&gt;LongConsumer&lt;/code&gt;, by boxing the argument of &lt;code&gt;LongConsumer&lt;/code&gt;, and then passed to &lt;a href=&quot;spliterator.oflong#forEachRemaining-java.util.function.LongConsumer-&quot;&gt;&lt;code&gt;forEachRemaining(java.util.function.LongConsumer)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果该操作是 &lt;code&gt;LongConsumer&lt;/code&gt; 的实例，则将其强制转换为 &lt;code&gt;LongConsumer&lt;/code&gt; 并传递给&lt;a href=&quot;spliterator.oflong#forEachRemaining-java.util.function.LongConsumer-&quot;&gt; &lt;code&gt;forEachRemaining(java.util.function.LongConsumer)&lt;/code&gt; &lt;/a&gt;；否则，通过对 &lt;code&gt;LongConsumer&lt;/code&gt; 的参数进行装箱，将操作调整为 &lt;code&gt;LongConsumer&lt;/code&gt; 的实例，然后将其传递给&lt;a href=&quot;spliterator.oflong#forEachRemaining-java.util.function.LongConsumer-&quot;&gt; &lt;code&gt;forEachRemaining(java.util.function.LongConsumer)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="00bbc10814534bf0219172f193911a9aeadd7e16" translate="yes" xml:space="preserve">
          <source>If the action is an instance of &lt;code&gt;LongConsumer&lt;/code&gt; then it is cast to &lt;code&gt;LongConsumer&lt;/code&gt; and passed to &lt;a href=&quot;spliterator.oflong#tryAdvance-java.util.function.LongConsumer-&quot;&gt;&lt;code&gt;tryAdvance(java.util.function.LongConsumer)&lt;/code&gt;&lt;/a&gt;; otherwise the action is adapted to an instance of &lt;code&gt;LongConsumer&lt;/code&gt;, by boxing the argument of &lt;code&gt;LongConsumer&lt;/code&gt;, and then passed to &lt;a href=&quot;spliterator.oflong#tryAdvance-java.util.function.LongConsumer-&quot;&gt;&lt;code&gt;tryAdvance(java.util.function.LongConsumer)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果该动作是 &lt;code&gt;LongConsumer&lt;/code&gt; 的实例，则将其强制转换为 &lt;code&gt;LongConsumer&lt;/code&gt; 并传递给&lt;a href=&quot;spliterator.oflong#tryAdvance-java.util.function.LongConsumer-&quot;&gt; &lt;code&gt;tryAdvance(java.util.function.LongConsumer)&lt;/code&gt; &lt;/a&gt;；否则，通过将 &lt;code&gt;LongConsumer&lt;/code&gt; 的参数装箱，将操作调整为 &lt;code&gt;LongConsumer&lt;/code&gt; 的实例，然后将其传递给&lt;a href=&quot;spliterator.oflong#tryAdvance-java.util.function.LongConsumer-&quot;&gt; &lt;code&gt;tryAdvance(java.util.function.LongConsumer)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c8e64dea02dd187ab7473bf716270a883a77afdc" translate="yes" xml:space="preserve">
          <source>If the action is an instance of &lt;code&gt;LongConsumer&lt;/code&gt; then it is cast to &lt;code&gt;LongConsumer&lt;/code&gt; and passed to &lt;a href=&quot;spliterator.ofprimitive#forEachRemaining(T_CONS)&quot;&gt;&lt;code&gt;Spliterator.OfPrimitive.forEachRemaining(java.util.function.LongConsumer)&lt;/code&gt;&lt;/a&gt;; otherwise the action is adapted to an instance of &lt;code&gt;LongConsumer&lt;/code&gt;, by boxing the argument of &lt;code&gt;LongConsumer&lt;/code&gt;, and then passed to &lt;a href=&quot;spliterator.ofprimitive#forEachRemaining(T_CONS)&quot;&gt;&lt;code&gt;Spliterator.OfPrimitive.forEachRemaining(java.util.function.LongConsumer)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果该操作是 &lt;code&gt;LongConsumer&lt;/code&gt; 的实例，则将其强制转换为 &lt;code&gt;LongConsumer&lt;/code&gt; 并传递给&lt;a href=&quot;spliterator.ofprimitive#forEachRemaining(T_CONS)&quot;&gt; &lt;code&gt;Spliterator.OfPrimitive.forEachRemaining(java.util.function.LongConsumer)&lt;/code&gt; &lt;/a&gt;；否则，通过将 &lt;code&gt;LongConsumer&lt;/code&gt; 的参数装箱，将操作调整为 &lt;code&gt;LongConsumer&lt;/code&gt; 实例，然后将其传递给&lt;a href=&quot;spliterator.ofprimitive#forEachRemaining(T_CONS)&quot;&gt; &lt;code&gt;Spliterator.OfPrimitive.forEachRemaining(java.util.function.LongConsumer)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2cd031f75c6a92efb253dc0527bb3d0bd986894f" translate="yes" xml:space="preserve">
          <source>If the action is an instance of &lt;code&gt;LongConsumer&lt;/code&gt; then it is cast to &lt;code&gt;LongConsumer&lt;/code&gt; and passed to &lt;a href=&quot;spliterator.ofprimitive#tryAdvance(T_CONS)&quot;&gt;&lt;code&gt;Spliterator.OfPrimitive.tryAdvance(java.util.function.LongConsumer)&lt;/code&gt;&lt;/a&gt;; otherwise the action is adapted to an instance of &lt;code&gt;LongConsumer&lt;/code&gt;, by boxing the argument of &lt;code&gt;LongConsumer&lt;/code&gt;, and then passed to &lt;a href=&quot;spliterator.ofprimitive#tryAdvance(T_CONS)&quot;&gt;&lt;code&gt;Spliterator.OfPrimitive.tryAdvance(java.util.function.LongConsumer)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果该操作是 &lt;code&gt;LongConsumer&lt;/code&gt; 的实例，则将其强制转换为 &lt;code&gt;LongConsumer&lt;/code&gt; 并传递给&lt;a href=&quot;spliterator.ofprimitive#tryAdvance(T_CONS)&quot;&gt; &lt;code&gt;Spliterator.OfPrimitive.tryAdvance(java.util.function.LongConsumer)&lt;/code&gt; &lt;/a&gt;；否则，通过将 &lt;code&gt;LongConsumer&lt;/code&gt; 的参数装箱，将操作调整为 &lt;code&gt;LongConsumer&lt;/code&gt; 的实例，然后将其传递给&lt;a href=&quot;spliterator.ofprimitive#tryAdvance(T_CONS)&quot;&gt; &lt;code&gt;Spliterator.OfPrimitive.tryAdvance(java.util.function.LongConsumer)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3b5ff8c69ea26957c669b0830c3787c984d9d074" translate="yes" xml:space="preserve">
          <source>If the action performed in your &lt;code&gt;run&lt;/code&gt; method could throw a &quot;checked&quot; exception (those listed in the &lt;code&gt;throws&lt;/code&gt; clause of a method), then you need to use the &lt;code&gt;PrivilegedExceptionAction&lt;/code&gt; interface instead of the &lt;code&gt;PrivilegedAction&lt;/code&gt; interface:</source>
          <target state="translated">如果在 &lt;code&gt;run&lt;/code&gt; 方法中执行的操作可能引发&amp;ldquo;已检查&amp;rdquo;异常（方法的 &lt;code&gt;throws&lt;/code&gt; 子句中列出的异常），则需要使用 &lt;code&gt;PrivilegedExceptionAction&lt;/code&gt; 接口而不是 &lt;code&gt;PrivilegedAction&lt;/code&gt; 接口：</target>
        </trans-unit>
        <trans-unit id="1c19e93235c53e902185c8c29dee0714c658ee6f" translate="yes" xml:space="preserve">
          <source>If the action was registered via &lt;code&gt;registerKeyboardAction&lt;/code&gt;, then the command string passed in (&lt;code&gt;null&lt;/code&gt; will be used if &lt;code&gt;null&lt;/code&gt; was passed in).</source>
          <target state="translated">如果操作是通过 &lt;code&gt;registerKeyboardAction&lt;/code&gt; 注册的，则传入的命令字符串（如果传入 &lt;code&gt;null&lt;/code&gt; ,则使用 &lt;code&gt;null&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="f8b6f3a11b20582c114df00bdb40a1e0e0cbd27f" translate="yes" xml:space="preserve">
          <source>If the action's &lt;code&gt;run&lt;/code&gt; method throws an</source>
          <target state="translated">如果操作的 &lt;code&gt;run&lt;/code&gt; 方法抛出一个</target>
        </trans-unit>
        <trans-unit id="6baa6ffe1bf64066619e4375881dfdc0f383d936" translate="yes" xml:space="preserve">
          <source>If the action's &lt;code&gt;run&lt;/code&gt; method throws an (unchecked) exception, it will propagate through this method.</source>
          <target state="translated">如果操作的 &lt;code&gt;run&lt;/code&gt; 方法抛出（未检查的）异常，它将通过此​​方法传播。</target>
        </trans-unit>
        <trans-unit id="81ae8e4005f2526ae09ac862718dd7fa76cfe92e" translate="yes" xml:space="preserve">
          <source>If the activation group for the object's group descriptor does not yet exist, the activator starts an &lt;code&gt;ActivationInstantiator&lt;/code&gt; executing (by spawning a child process, for example). When the activator receives the activation group's call back (via the &lt;code&gt;ActivationSystem&lt;/code&gt;'s &lt;code&gt;activeGroup&lt;/code&gt; method) specifying the activation group's reference, the activator can then invoke that activation instantiator's &lt;code&gt;newInstance&lt;/code&gt; method to forward each pending activation request to the activation group and return the result (a marshalled remote object reference, a stub) to the caller.</source>
          <target state="translated">如果对象的组描述符的激活组尚不存在，则激活器将启动一个 &lt;code&gt;ActivationInstantiator&lt;/code&gt; 执行（例如，通过生成子进程）。当激活器接收到激活组的回调（通过 &lt;code&gt;ActivationSystem&lt;/code&gt; 的 &lt;code&gt;activeGroup&lt;/code&gt; 方法）指定激活组的引用时，激活器可以调用该激活实例化器的 &lt;code&gt;newInstance&lt;/code&gt; 方法，将每个未决的激活请求转发给激活组并返回结果（a编组给调用方的远程对象引用（存根）。</target>
        </trans-unit>
        <trans-unit id="6c727c33b10329c8a55fc35a2c969597ddaf2670" translate="yes" xml:space="preserve">
          <source>If the address is &lt;code&gt;null&lt;/code&gt; an unbound socket will be created.</source>
          <target state="translated">如果地址为 &lt;code&gt;null&lt;/code&gt; ，则将创建一个未绑定的套接字。</target>
        </trans-unit>
        <trans-unit id="102269f064fade95ae910ba7bdf983251013c399" translate="yes" xml:space="preserve">
          <source>If the address is &lt;code&gt;null&lt;/code&gt;, then the system will pick up an ephemeral port and a valid local address to bind the socket.</source>
          <target state="translated">如果地址为 &lt;code&gt;null&lt;/code&gt; ，则系统将选择一个临时端口和一个有效的本地地址来绑定套接字。</target>
        </trans-unit>
        <trans-unit id="deed334073f68c6d00e85a8098ad4ebaa1319066" translate="yes" xml:space="preserve">
          <source>If the agent cannot be started (for example, because the agent class cannot be loaded, or because the agent class does not have an appropriate &lt;code&gt;premain&lt;/code&gt; method), the JVM will abort. If a &lt;code&gt;premain&lt;/code&gt; method throws an uncaught exception, the JVM will abort.</source>
          <target state="translated">如果无法启动代理（例如，因为无法加载代理类，或者因为代理类没有适当的 &lt;code&gt;premain&lt;/code&gt; 方法），则JVM将中止。如果 &lt;code&gt;premain&lt;/code&gt; 方法抛出未捕获的异常，则JVM将中止。</target>
        </trans-unit>
        <trans-unit id="3bdc279bcf6c5ee605cac5004f25fb4a4dd94ae8" translate="yes" xml:space="preserve">
          <source>If the agent class does not implement this method then the JVM will attempt to invoke:</source>
          <target state="translated">如果代理类没有实现这个方法,那么JVM将尝试调用。</target>
        </trans-unit>
        <trans-unit id="e4c80757c9e2ecb6b75dc0a37636c30cb9490032" translate="yes" xml:space="preserve">
          <source>If the algorithm is the</source>
          <target state="translated">如果算法是</target>
        </trans-unit>
        <trans-unit id="80ea754a698145f128fdf52efea523a98452381c" translate="yes" xml:space="preserve">
          <source>If the alpha component of the requested background color is less than &lt;code&gt;1.0f&lt;/code&gt;, and any of the above conditions are not met, the background color of this window will not change, the alpha component of the given background color will not affect the mode of operation for this window, and either the &lt;code&gt;UnsupportedOperationException&lt;/code&gt; or &lt;code&gt;
 IllegalComponentStateException&lt;/code&gt; will be thrown.</source>
          <target state="translated">如果请求的背景色的alpha分量小于 &lt;code&gt;1.0f&lt;/code&gt; ，并且不满足上述任何条件，则此窗口的背景色将不会更改，给定背景色的alpha分量将不会影响操作模式对于此窗口，将抛出 &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 或 &lt;code&gt; IllegalComponentStateException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0e8d5a3e745f1450eac261edbc32910b4882938f" translate="yes" xml:space="preserve">
          <source>If the amount is a &lt;code&gt;ChronoPeriod&lt;/code&gt; then it must use the ISO chronology.</source>
          <target state="translated">如果金额是 &lt;code&gt;ChronoPeriod&lt;/code&gt; ,则必须使用ISO年代。</target>
        </trans-unit>
        <trans-unit id="88b1d50bbaec9f5487c27e8e4cb2386eb42847f9" translate="yes" xml:space="preserve">
          <source>If the amount of saving time at any given time stamp is required, construct a &lt;a href=&quot;calendar&quot;&gt;&lt;code&gt;Calendar&lt;/code&gt;&lt;/a&gt; with this &lt;code&gt;
 TimeZone&lt;/code&gt; and the time stamp, and call &lt;a href=&quot;calendar#get(int)&quot;&gt;&lt;code&gt;Calendar.get&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(&lt;/code&gt;&lt;a href=&quot;calendar#DST_OFFSET&quot;&gt;&lt;code&gt;Calendar.DST_OFFSET&lt;/code&gt;&lt;/a&gt;&lt;code&gt;)&lt;/code&gt;.</source>
          <target state="translated">如果需要在任何给定的时间戳上节省时间，请使用此 &lt;code&gt; TimeZone&lt;/code&gt; 和时间戳构造一个&lt;a href=&quot;calendar&quot;&gt; &lt;code&gt;Calendar&lt;/code&gt; &lt;/a&gt;，然后调用&lt;a href=&quot;calendar#get(int)&quot;&gt; &lt;code&gt;Calendar.get&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(&lt;/code&gt; &lt;a href=&quot;calendar#DST_OFFSET&quot;&gt; &lt;code&gt;Calendar.DST_OFFSET&lt;/code&gt; &lt;/a&gt; &lt;code&gt;)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4d740232e114f21d31c73ca4687c4057fb29ccd4" translate="yes" xml:space="preserve">
          <source>If the amount of saving time at any given time stamp is required, construct a &lt;a href=&quot;calendar&quot;&gt;&lt;code&gt;Calendar&lt;/code&gt;&lt;/a&gt; with this &lt;code&gt;TimeZone&lt;/code&gt; and the time stamp, and call &lt;a href=&quot;calendar#get-int-&quot;&gt;&lt;code&gt;Calendar.get&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(&lt;/code&gt;&lt;a href=&quot;calendar#DST_OFFSET&quot;&gt;&lt;code&gt;Calendar.DST_OFFSET&lt;/code&gt;&lt;/a&gt;&lt;code&gt;)&lt;/code&gt;.</source>
          <target state="translated">如果需要在任何给定的时间戳上节省时间，请使用此 &lt;code&gt;TimeZone&lt;/code&gt; 和时间戳构造一个&lt;a href=&quot;calendar&quot;&gt; &lt;code&gt;Calendar&lt;/code&gt; &lt;/a&gt;，然后调用&lt;a href=&quot;calendar#get-int-&quot;&gt; &lt;code&gt;Calendar.get&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(&lt;/code&gt; &lt;a href=&quot;calendar#DST_OFFSET&quot;&gt; &lt;code&gt;Calendar.DST_OFFSET&lt;/code&gt; &lt;/a&gt; &lt;code&gt;)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="08afeee4bde07dab89f440c39fce86a0eb463b56" translate="yes" xml:space="preserve">
          <source>If the annotation &lt;code&gt;@Documented&lt;/code&gt; is present on the declaration of an annotation type</source>
          <target state="translated">如果注释类型的声明中存在注释 &lt;code&gt;@Documented&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="272549f61fd737d1e73b2c36c4aa004c00079132" translate="yes" xml:space="preserve">
          <source>If the answer is NO, go to the next step.</source>
          <target state="translated">如果答案是NO,则进入下一步。</target>
        </trans-unit>
        <trans-unit id="f57b79608f2a3ff0ec11e483aaaa3a019d8c2b5b" translate="yes" xml:space="preserve">
          <source>If the answer is NO, throw a &lt;code&gt;NoSuchAlgorithmException&lt;/code&gt; exception.</source>
          <target state="translated">如果答案为否，则抛出 &lt;code&gt;NoSuchAlgorithmException&lt;/code&gt; 异常。</target>
        </trans-unit>
        <trans-unit id="434e3dee0acd3560230fa30595feca5a213bbce4" translate="yes" xml:space="preserve">
          <source>If the answer is YES, instantiate it, and call &lt;code&gt;engineSetMode(&lt;i&gt;mode&lt;/i&gt;)&lt;/code&gt; and &lt;code&gt;engineSetPadding(&lt;i&gt;padding&lt;/i&gt;)&lt;/code&gt; on the new instance.</source>
          <target state="translated">如果答案为是，请实例化它，然后在新实例上调用 &lt;code&gt;engineSetMode(&lt;i&gt;mode&lt;/i&gt;)&lt;/code&gt; 和 &lt;code&gt;engineSetPadding(&lt;i&gt;padding&lt;/i&gt;)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a1eb85cb2614bd41f0d6af38673aa7528bca07f4" translate="yes" xml:space="preserve">
          <source>If the answer is YES, instantiate it, and call &lt;code&gt;engineSetMode(&lt;i&gt;mode&lt;/i&gt;)&lt;/code&gt; on the new instance.</source>
          <target state="translated">如果答案为是，请实例化它，然后在新实例上调用 &lt;code&gt;engineSetMode(&lt;i&gt;mode&lt;/i&gt;)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="de83ee4eae564494ffc414cfaf8cc18d47b2bed1" translate="yes" xml:space="preserve">
          <source>If the answer is YES, instantiate it, and call &lt;code&gt;engineSetPadding(&lt;i&gt;padding&lt;/i&gt;)&lt;/code&gt; on the new instance.</source>
          <target state="translated">如果答案为是，请实例化它，然后在新实例上调用 &lt;code&gt;engineSetPadding(&lt;i&gt;padding&lt;/i&gt;)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="56a7594c327855897bea9f06e5423ff72ccb1d7b" translate="yes" xml:space="preserve">
          <source>If the answer is YES, instantiate it.</source>
          <target state="translated">如果答案是YES,将其实例化。</target>
        </trans-unit>
        <trans-unit id="160782cdb54c84087be65e0efddfac392e283c77" translate="yes" xml:space="preserve">
          <source>If the answer is YES, instantiate this class, for whose mode and padding scheme default values (as supplied by the provider) are used.</source>
          <target state="translated">如果答案是YES,则实例化这个类,使用其模式和填充方案的默认值(由提供者提供)。</target>
        </trans-unit>
        <trans-unit id="e4bd31b53dccf5705cdd32f1466082805129fc6c" translate="yes" xml:space="preserve">
          <source>If the application creates a login context using an &lt;em&gt;installed&lt;/em&gt;&lt;a href=&quot;../../../../../../java.base/javax/security/auth/login/configuration&quot;&gt;&lt;code&gt;Configuration&lt;/code&gt;&lt;/a&gt; then the application must be granted the &lt;a href=&quot;../../../../../../java.base/javax/security/auth/authpermission&quot;&gt;&lt;code&gt;AuthPermission&lt;/code&gt;&lt;/a&gt; to create login contexts. For example, the following security policy allows an application in the user's current directory to instantiate &lt;em&gt;any&lt;/em&gt; login context:</source>
          <target state="translated">如果应用程序使用已&lt;em&gt;安装的&lt;/em&gt;&lt;a href=&quot;../../../../../../java.base/javax/security/auth/login/configuration&quot;&gt; &lt;code&gt;Configuration&lt;/code&gt; &lt;/a&gt;创建登录上下文，则必须授予该应用程序&lt;a href=&quot;../../../../../../java.base/javax/security/auth/authpermission&quot;&gt; &lt;code&gt;AuthPermission&lt;/code&gt; &lt;/a&gt;才能创建登录上下文。例如，以下安全策略允许用户当前目录中的应用程序实例化&lt;em&gt;任何&lt;/em&gt;登录上下文：</target>
        </trans-unit>
        <trans-unit id="5fe99f49bc1a1090e02dd6efd4b8d8fd6a67f30a" translate="yes" xml:space="preserve">
          <source>If the application does not register a DTD handler, all DTD events reported by the SAX parser will be silently ignored (this is the default behaviour implemented by HandlerBase).</source>
          <target state="translated">如果应用程序没有注册DTD处理程序,SAX解析器报告的所有DTD事件将被默默忽略(这是HandlerBase实现的默认行为)。</target>
        </trans-unit>
        <trans-unit id="1c521b3dbb8b44d5fe2bd6f0ccfd70ada67afc00" translate="yes" xml:space="preserve">
          <source>If the application does not register a DTD handler, all DTD events reported by the SAX parser will be silently ignored.</source>
          <target state="translated">如果应用程序没有注册DTD处理程序,SAX解析器报告的所有DTD事件将被默默忽略。</target>
        </trans-unit>
        <trans-unit id="1995f916cc7b7a0f6ced6ac9ec5d117bf0b42738" translate="yes" xml:space="preserve">
          <source>If the application does not register a content handler, all content events reported by the SAX parser will be silently ignored.</source>
          <target state="translated">如果应用程序没有注册内容处理程序,SAX解析器报告的所有内容事件将被静静地忽略。</target>
        </trans-unit>
        <trans-unit id="a62c70d6bc1bda91dda6bd20cde5a3d284087c97" translate="yes" xml:space="preserve">
          <source>If the application does not register a document handler, all document events reported by the SAX parser will be silently ignored (this is the default behaviour implemented by HandlerBase).</source>
          <target state="translated">如果应用程序没有注册文档处理程序,SAX解析器报告的所有文档事件将被默默地忽略(这是HandlerBase实现的默认行为)。</target>
        </trans-unit>
        <trans-unit id="5cbd83d12c880c04a3ca2b1f0acd010cea0950ae" translate="yes" xml:space="preserve">
          <source>If the application does not register an entity resolver, the SAX parser will resolve system identifiers and open connections to entities itself (this is the default behaviour implemented in HandlerBase).</source>
          <target state="translated">如果应用程序没有注册实体解析器,SAX解析器将自己解析系统标识符并打开与实体的连接(这是HandlerBase中实现的默认行为)。</target>
        </trans-unit>
        <trans-unit id="a8af630e8d72ae977eff66966545a162b07a84de" translate="yes" xml:space="preserve">
          <source>If the application does not register an entity resolver, the XMLReader will perform its own default resolution.</source>
          <target state="translated">如果应用程序没有注册实体解析器,XMLReader将执行自己的默认解析。</target>
        </trans-unit>
        <trans-unit id="0b84de5172675bfd46a10466b2f6619156504747" translate="yes" xml:space="preserve">
          <source>If the application does not register an error event handler, all error events reported by the SAX parser will be silently ignored, except for fatalError, which will throw a SAXException (this is the default behaviour implemented by HandlerBase).</source>
          <target state="translated">如果应用程序没有注册错误事件处理程序,SAX解析器报告的所有错误事件都将被默默地忽略,除了fatalError,它将抛出一个SAXException(这是HandlerBase实现的默认行为)。</target>
        </trans-unit>
        <trans-unit id="cc77f1bc697f56ce88184dfc957115a66d88b958" translate="yes" xml:space="preserve">
          <source>If the application does not register an error handler, all error events reported by the SAX parser will be silently ignored; however, normal processing may not continue. It is highly recommended that all SAX applications implement an error handler to avoid unexpected bugs.</source>
          <target state="translated">如果应用程序没有注册错误处理程序,SAX解析器报告的所有错误事件都将被默默地忽略;但是,正常的处理可能不会继续。强烈建议所有的SAX应用程序都实现一个错误处理程序,以避免意外的错误。</target>
        </trans-unit>
        <trans-unit id="968a78947275cffe7a67b6a953d091962ffdb8ec" translate="yes" xml:space="preserve">
          <source>If the application has previously set up an instance of &lt;code&gt;URLStreamHandlerFactory&lt;/code&gt; as the stream handler factory, then the &lt;code&gt;createURLStreamHandler&lt;/code&gt; method of that instance is called with the protocol string as an argument to create the stream protocol handler.</source>
          <target state="translated">如果应用程序先前已将 &lt;code&gt;URLStreamHandlerFactory&lt;/code&gt; 的实例设置为流处理程序工厂，则使用协议字符串作为参数来 &lt;code&gt;createURLStreamHandler&lt;/code&gt; 该实例的createURLStreamHandler方法，以创建流协议处理程序。</target>
        </trans-unit>
        <trans-unit id="2070d70078ec2db5e6d48447de6438828f0279ed" translate="yes" xml:space="preserve">
          <source>If the application has set up a content handler factory instance using the &lt;code&gt;setContentHandlerFactory&lt;/code&gt; method, the &lt;code&gt;createContentHandler&lt;/code&gt; method of that instance is called with the content type as an argument; the result is a content handler for that content type.</source>
          <target state="translated">如果应用程序已使用 &lt;code&gt;setContentHandlerFactory&lt;/code&gt; 方法设置了内容处理程序工厂实例，则使用内容类型作为参数来调用该实例的 &lt;code&gt;createContentHandler&lt;/code&gt; 方法；否则，将使用内容类型作为参数来调用该实例。结果是该内容类型的内容处理程序。</target>
        </trans-unit>
        <trans-unit id="070f984b52d47c94ac613db630c4269a97e28431" translate="yes" xml:space="preserve">
          <source>If the application has specified a client socket implementation factory, that factory's &lt;code&gt;createSocketImpl&lt;/code&gt; method is called to create the actual socket implementation. Otherwise a system-default socket implementation is created.</source>
          <target state="translated">如果应用程序指定了客户端套接字实现工厂，则将调用该工厂的 &lt;code&gt;createSocketImpl&lt;/code&gt; 方法来创建实际的套接字实现。否则，将创建系统默认的套接字实现。</target>
        </trans-unit>
        <trans-unit id="91fdcd973932e65f09e9bdaebd48fb198c503271" translate="yes" xml:space="preserve">
          <source>If the application has specified a server socket factory, that factory's &lt;code&gt;createSocketImpl&lt;/code&gt; method is called to create the actual socket implementation. Otherwise a &quot;plain&quot; socket is created.</source>
          <target state="translated">如果应用程序指定了服务器套接字工厂，则将调用该工厂的 &lt;code&gt;createSocketImpl&lt;/code&gt; 方法来创建实际的套接字实现。否则，将创建一个&amp;ldquo;普通&amp;rdquo;套接字。</target>
        </trans-unit>
        <trans-unit id="465cff58e0c3971e42da1cffbcef9b2b3ac06798" translate="yes" xml:space="preserve">
          <source>If the application has specified a server socket implementation factory, that factory's &lt;code&gt;createSocketImpl&lt;/code&gt; method is called to create the actual socket implementation. Otherwise a system-default socket implementation is created.</source>
          <target state="translated">如果应用程序指定了服务器套接字实现工厂，则将调用该工厂的 &lt;code&gt;createSocketImpl&lt;/code&gt; 方法来创建实际的套接字实现。否则，将创建系统默认的套接字实现。</target>
        </trans-unit>
        <trans-unit id="221a9611027772cf1f0b3bdc427ffc5e66a9af4e" translate="yes" xml:space="preserve">
          <source>If the application has specified a socket factory, that factory's &lt;code&gt;createSocketImpl&lt;/code&gt; method is called to create the actual socket implementation. Otherwise a &quot;plain&quot; socket is created.</source>
          <target state="translated">如果应用程序指定了套接字工厂，则将调用该工厂的 &lt;code&gt;createSocketImpl&lt;/code&gt; 方法来创建实际的套接字实现。否则，将创建一个&amp;ldquo;普通&amp;rdquo;套接字。</target>
        </trans-unit>
        <trans-unit id="242a93fe7324bd12593bab009aad2ea56baf1bef" translate="yes" xml:space="preserve">
          <source>If the application initiated the closing process by calling &lt;a href=&quot;#closeOutbound()&quot;&gt;&lt;code&gt;closeOutbound()&lt;/code&gt;&lt;/a&gt;, under some circumstances it is not required that the initiator wait for the peer's corresponding close message. (See section 7.2.1 of the TLS specification (&lt;a href=&quot;http://www.ietf.org/rfc/rfc2246.txt&quot;&gt;RFC 2246&lt;/a&gt;) for more information on waiting for closure alerts.) In such cases, this method need not be called.</source>
          <target state="translated">如果应用程序通过调用&lt;a href=&quot;#closeOutbound()&quot;&gt; &lt;code&gt;closeOutbound()&lt;/code&gt; &lt;/a&gt;启动关闭过程，则在某些情况下，不需要启动器等待对等方的相应关闭消息。（有关等待关闭警报的更多信息，请参见TLS规范（&lt;a href=&quot;http://www.ietf.org/rfc/rfc2246.txt&quot;&gt;RFC 2246&lt;/a&gt;）的7.2.1节。）在这种情况下，不需要调用此方法。</target>
        </trans-unit>
        <trans-unit id="eda2dea38deaa01112fb283b1676ae6c672f0afa" translate="yes" xml:space="preserve">
          <source>If the application initiated the closing process by calling &lt;a href=&quot;#closeOutbound()&quot;&gt;&lt;code&gt;closeOutbound()&lt;/code&gt;&lt;/a&gt;, under some circumstances it is not required that the initiator wait for the peer's corresponding close message. (See section 7.2.1 of the TLS specification (&lt;a href=&quot;https://www.ietf.org/rfc/rfc2246.txt&quot;&gt;RFC 2246&lt;/a&gt;) for more information on waiting for closure alerts.) In such cases, this method need not be called.</source>
          <target state="translated">如果应用程序通过调用&lt;a href=&quot;#closeOutbound()&quot;&gt; &lt;code&gt;closeOutbound()&lt;/code&gt; &lt;/a&gt;启动关闭过程，则在某些情况下，不需要启动器等待对等方的相应关闭消息。（有关等待关闭警报的更多信息，请参见TLS规范（&lt;a href=&quot;https://www.ietf.org/rfc/rfc2246.txt&quot;&gt;RFC 2246&lt;/a&gt;）的7.2.1节。）在这种情况下，不需要调用此方法。</target>
        </trans-unit>
        <trans-unit id="2b8dff9cb695d7cf445c13c7a8630fbe3ce30315" translate="yes" xml:space="preserve">
          <source>If the application initiated the closing process by calling &lt;a href=&quot;sslengine#closeOutbound--&quot;&gt;&lt;code&gt;closeOutbound()&lt;/code&gt;&lt;/a&gt;, under some circumstances it is not required that the initiator wait for the peer's corresponding close message. (See section 7.2.1 of the TLS specification (&lt;a href=&quot;http://www.ietf.org/rfc/rfc2246.txt&quot;&gt;RFC 2246&lt;/a&gt;) for more information on waiting for closure alerts.) In such cases, this method need not be called.</source>
          <target state="translated">如果应用程序通过调用&lt;a href=&quot;sslengine#closeOutbound--&quot;&gt; &lt;code&gt;closeOutbound()&lt;/code&gt; &lt;/a&gt;启动关闭过程，则在某些情况下，不需要启动程序等待对等方的相应关闭消息。（有关等待关闭警报的更多信息，请参见TLS规范（&lt;a href=&quot;http://www.ietf.org/rfc/rfc2246.txt&quot;&gt;RFC 2246&lt;/a&gt;）的7.2.1节。）在这种情况下，不需要调用此方法。</target>
        </trans-unit>
        <trans-unit id="9b49e74988c341dbee66d98c70300f05b412e8ad" translate="yes" xml:space="preserve">
          <source>If the application knows the character encoding of the byte stream, it should set it with the setEncoding method.</source>
          <target state="translated">如果应用程序知道字节流的字符编码,就应该用setEncoding方法设置它。</target>
        </trans-unit>
        <trans-unit id="85ff560af776424016a6f3b941fc1f9585879f10" translate="yes" xml:space="preserve">
          <source>If the application knows the character encoding of the byte stream, it should set the encoding attribute. Setting the encoding in this way will override any encoding specified in an XML declaration in the data.</source>
          <target state="translated">如果应用程序知道字节流的字符编码,它应该设置编码属性。以这种方式设置编码将覆盖数据中XML声明中指定的任何编码。</target>
        </trans-unit>
        <trans-unit id="7cfd6e9f0bb81bae2991028adadfb572b93731b0" translate="yes" xml:space="preserve">
          <source>If the application knows the character encoding of the object pointed to by the system identifier, it can register the encoding using the setEncoding method.</source>
          <target state="translated">如果应用程序知道系统标识符所指向的对象的字符编码,它可以使用setEncoding方法注册编码。</target>
        </trans-unit>
        <trans-unit id="059304a89c9e8193f2d1a44c913f61a85c77d63d" translate="yes" xml:space="preserve">
          <source>If the application knows the character encoding of the object pointed to by the system identifier, it can set the encoding using the &lt;code&gt;encoding&lt;/code&gt; attribute.</source>
          <target state="translated">如果应用程序知道系统标识符指向的对象的字符编码，则可以使用 &lt;code&gt;encoding&lt;/code&gt; 属性设置编码。</target>
        </trans-unit>
        <trans-unit id="a649bc726d746209da5a8d07601c510d8a5af68b" translate="yes" xml:space="preserve">
          <source>If the application needs to pass through other types of exceptions, it must wrap those exceptions in a SAXException or an exception derived from a SAXException.</source>
          <target state="translated">如果应用程序需要通过其他类型的异常,它必须将这些异常包裹在SAXException或从SAXException派生的异常中。</target>
        </trans-unit>
        <trans-unit id="ff002a2eb7163e0d2f905c4e93d3942c2cb282be" translate="yes" xml:space="preserve">
          <source>If the appropriate stub class could not be found, or if the stub class could not be loaded, or if a problem occurs creating the stub instance, a &lt;a href=&quot;../stubnotfoundexception&quot;&gt;&lt;code&gt;StubNotFoundException&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">如果找不到合适的存根类，或者无法加载存根类，或者在创建存根实例时发生问题，则抛出&lt;a href=&quot;../stubnotfoundexception&quot;&gt; &lt;code&gt;StubNotFoundException&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9908f3b7f0fcd38e518a64cda27a8bcf7af02eae" translate="yes" xml:space="preserve">
          <source>If the argument</source>
          <target state="translated">如果争论</target>
        </trans-unit>
        <trans-unit id="a274d22f689f758fbbc17c1c36e25f56726e9e93" translate="yes" xml:space="preserve">
          <source>If the argument implements &lt;a href=&quot;formattable&quot;&gt;&lt;code&gt;Formattable&lt;/code&gt;&lt;/a&gt;, then its &lt;a href=&quot;formattable#formatTo(java.util.Formatter,int,int,int)&quot;&gt;&lt;code&gt;formatTo&lt;/code&gt;&lt;/a&gt; method is invoked. Otherwise, the result is obtained by invoking the argument's &lt;code&gt;toString()&lt;/code&gt; method.</source>
          <target state="translated">如果参数实现&lt;a href=&quot;formattable&quot;&gt; &lt;code&gt;Formattable&lt;/code&gt; &lt;/a&gt;，则调用其&lt;a href=&quot;formattable#formatTo(java.util.Formatter,int,int,int)&quot;&gt; &lt;code&gt;formatTo&lt;/code&gt; &lt;/a&gt;方法。否则，通过调用参数的 &lt;code&gt;toString()&lt;/code&gt; 方法获得结果。</target>
        </trans-unit>
        <trans-unit id="18ba07a0dacca161f919bf38b3942c5cbf0de7b4" translate="yes" xml:space="preserve">
          <source>If the argument index is used for more than one format element in the pattern string, then the new format is used for all such format elements. If the argument index is not used for any format element in the pattern string, then the new format is ignored.</source>
          <target state="translated">如果参数索引用于模式字符串中一个以上的格式元素,那么新的格式将用于所有这些格式元素。如果参数索引没有用于模式字符串中的任何格式元素,那么新格式将被忽略。</target>
        </trans-unit>
        <trans-unit id="201ffc4148225e00891b41aafa471a7bc0ae4e31" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;&lt;code&gt;Double.MAX_VALUE&lt;/code&gt;, then the result is equal to 2&lt;sup&gt;971&lt;/sup&gt;.</source>
          <target state="translated">如果参数为&amp;plusmn; &lt;code&gt;Double.MAX_VALUE&lt;/code&gt; ，则结果等于2 &lt;sup&gt;971&lt;/sup&gt;。</target>
        </trans-unit>
        <trans-unit id="0500f3687980d0c066085bfc637859d5a0f94f45" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;&lt;code&gt;Float.MAX_VALUE&lt;/code&gt;, then the result is equal to 2&lt;sup&gt;104&lt;/sup&gt;.</source>
          <target state="translated">如果参数为&amp;plusmn; &lt;code&gt;Float.MAX_VALUE&lt;/code&gt; ，则结果等于2 &lt;sup&gt;104&lt;/sup&gt;。</target>
        </trans-unit>
        <trans-unit id="e418b56eeca30ec55767a713e51154185f73b688" translate="yes" xml:space="preserve">
          <source>If the argument is &lt;code&gt;0x7f800000&lt;/code&gt;, the result is positive infinity.</source>
          <target state="translated">如果参数为 &lt;code&gt;0x7f800000&lt;/code&gt; ，则结果为正无穷大。</target>
        </trans-unit>
        <trans-unit id="cc33fb1734d8e8472093718dadfa691efa944850" translate="yes" xml:space="preserve">
          <source>If the argument is &lt;code&gt;0x7ff0000000000000L&lt;/code&gt;, the result is positive infinity.</source>
          <target state="translated">如果参数为 &lt;code&gt;0x7ff0000000000000L&lt;/code&gt; ，则结果为正无穷大。</target>
        </trans-unit>
        <trans-unit id="67ad4ce5c4db05b329a5cf076b7ace8df7e07d24" translate="yes" xml:space="preserve">
          <source>If the argument is &lt;code&gt;0xff800000&lt;/code&gt;, the result is negative infinity.</source>
          <target state="translated">如果参数为 &lt;code&gt;0xff800000&lt;/code&gt; ，则结果为负无穷大。</target>
        </trans-unit>
        <trans-unit id="44b83a1db6251fafa0226412a16d0a5aa743a573" translate="yes" xml:space="preserve">
          <source>If the argument is &lt;code&gt;0xfff0000000000000L&lt;/code&gt;, the result is negative infinity.</source>
          <target state="translated">如果参数为 &lt;code&gt;0xfff0000000000000L&lt;/code&gt; ，则结果为负无穷大。</target>
        </trans-unit>
        <trans-unit id="d97807e539c09446e4934a8ca25166f2ed929f7e" translate="yes" xml:space="preserve">
          <source>If the argument is &lt;code&gt;null&lt;/code&gt;, then the result is &quot;&lt;code&gt;false&lt;/code&gt;&quot;. If the argument is a &lt;code&gt;boolean&lt;/code&gt; or &lt;a href=&quot;../lang/boolean&quot;&gt;&lt;code&gt;Boolean&lt;/code&gt;&lt;/a&gt;, then the result is the string returned by &lt;a href=&quot;../lang/string#valueOf(boolean)&quot;&gt;&lt;code&gt;String.valueOf()&lt;/code&gt;&lt;/a&gt;. Otherwise, the result is &quot;&lt;code&gt;true&lt;/code&gt;&quot;.</source>
          <target state="translated">如果参数为 &lt;code&gt;null&lt;/code&gt; ，则结果为&amp;ldquo; &lt;code&gt;false&lt;/code&gt; &amp;rdquo;。如果参数是 &lt;code&gt;boolean&lt;/code&gt; 或&lt;a href=&quot;../lang/boolean&quot;&gt; &lt;code&gt;Boolean&lt;/code&gt; &lt;/a&gt;，则结果是&lt;a href=&quot;../lang/string#valueOf(boolean)&quot;&gt; &lt;code&gt;String.valueOf()&lt;/code&gt; &lt;/a&gt;返回的字符串。否则，结果为&amp;ldquo; &lt;code&gt;true&lt;/code&gt; &amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="970f258bf10d8b6db35da86a6962bea7e6f056c5" translate="yes" xml:space="preserve">
          <source>If the argument is &lt;code&gt;null&lt;/code&gt;, then the result is &quot;&lt;code&gt;false&lt;/code&gt;&quot;. If the argument is a &lt;code&gt;boolean&lt;/code&gt; or &lt;a href=&quot;../lang/boolean&quot;&gt;&lt;code&gt;Boolean&lt;/code&gt;&lt;/a&gt;, then the result is the string returned by &lt;a href=&quot;../lang/string#valueOf-boolean-&quot;&gt;&lt;code&gt;String.valueOf()&lt;/code&gt;&lt;/a&gt;. Otherwise, the result is &quot;&lt;code&gt;true&lt;/code&gt;&quot;.</source>
          <target state="translated">如果参数为 &lt;code&gt;null&lt;/code&gt; ，则结果为&amp;ldquo; &lt;code&gt;false&lt;/code&gt; &amp;rdquo;。如果参数是 &lt;code&gt;boolean&lt;/code&gt; 或&lt;a href=&quot;../lang/boolean&quot;&gt; &lt;code&gt;Boolean&lt;/code&gt; &lt;/a&gt;，则结果是&lt;a href=&quot;../lang/string#valueOf-boolean-&quot;&gt; &lt;code&gt;String.valueOf()&lt;/code&gt; &lt;/a&gt;返回的字符串。否则，结果为&amp;ldquo; &lt;code&gt;true&lt;/code&gt; &amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="4acdffc199e6f4f9b1d96e0f15f8a4c625bb7edd" translate="yes" xml:space="preserve">
          <source>If the argument is &lt;code&gt;null&lt;/code&gt;, then the result is &quot;&lt;code&gt;null&lt;/code&gt;&quot;. If the argument implements &lt;a href=&quot;formattable&quot;&gt;&lt;code&gt;Formattable&lt;/code&gt;&lt;/a&gt;, then its &lt;a href=&quot;formattable#formatTo-java.util.Formatter-int-int-int-&quot;&gt;&lt;code&gt;formatTo&lt;/code&gt;&lt;/a&gt; method is invoked. Otherwise, the result is obtained by invoking the argument's &lt;code&gt;toString()&lt;/code&gt; method.</source>
          <target state="translated">如果参数为 &lt;code&gt;null&lt;/code&gt; ，则结果为&amp;ldquo; &lt;code&gt;null&lt;/code&gt; &amp;rdquo;。如果参数实现&lt;a href=&quot;formattable&quot;&gt; &lt;code&gt;Formattable&lt;/code&gt; &lt;/a&gt;，则调用其&lt;a href=&quot;formattable#formatTo-java.util.Formatter-int-int-int-&quot;&gt; &lt;code&gt;formatTo&lt;/code&gt; &lt;/a&gt;方法。否则，通过调用参数的 &lt;code&gt;toString()&lt;/code&gt; 方法获得结果。</target>
        </trans-unit>
        <trans-unit id="fe94a89675405323875ef4ec6ff361112380225e" translate="yes" xml:space="preserve">
          <source>If the argument is NaN or an infinity or positive zero or negative zero, then the result is the same as the argument.</source>
          <target state="translated">如果参数是NaN或无穷大或正零或负零,那么结果与参数相同。</target>
        </trans-unit>
        <trans-unit id="0f1490c0a73a4bdc7beee59aa0b2e8886fa1ac76" translate="yes" xml:space="preserve">
          <source>If the argument is NaN or an infinity, then the result is NaN.</source>
          <target state="translated">如果参数是NaN或无穷大,那么结果就是NaN。</target>
        </trans-unit>
        <trans-unit id="e8d658cc42466718800cf906b23004b8262a330a" translate="yes" xml:space="preserve">
          <source>If the argument is NaN or infinite, then the result is &lt;a href=&quot;double#MAX_EXPONENT&quot;&gt;&lt;code&gt;Double.MAX_EXPONENT&lt;/code&gt;&lt;/a&gt; + 1.</source>
          <target state="translated">如果参数为NaN或无限，则结果为&lt;a href=&quot;double#MAX_EXPONENT&quot;&gt; &lt;code&gt;Double.MAX_EXPONENT&lt;/code&gt; &lt;/a&gt; + 1。</target>
        </trans-unit>
        <trans-unit id="cc7b80c9b72e91dff938c54c51871d14f95c81ca" translate="yes" xml:space="preserve">
          <source>If the argument is NaN or infinite, then the result is &lt;a href=&quot;float#MAX_EXPONENT&quot;&gt;&lt;code&gt;Float.MAX_EXPONENT&lt;/code&gt;&lt;/a&gt; + 1.</source>
          <target state="translated">如果参数为NaN或无限，则结果为&lt;a href=&quot;float#MAX_EXPONENT&quot;&gt; &lt;code&gt;Float.MAX_EXPONENT&lt;/code&gt; &lt;/a&gt; + 1。</target>
        </trans-unit>
        <trans-unit id="745e5106ba9365f2bce0539ab810d8720f71215b" translate="yes" xml:space="preserve">
          <source>If the argument is NaN or its absolute value is greater than 1, then the result is NaN.</source>
          <target state="translated">如果参数为NaN或其绝对值大于1,则结果为NaN。</target>
        </trans-unit>
        <trans-unit id="07291af92544374b52ef8f433433f39f1dbb80d9" translate="yes" xml:space="preserve">
          <source>If the argument is NaN or less than -1, then the result is NaN.</source>
          <target state="translated">如果参数是NaN或小于-1,那么结果就是NaN。</target>
        </trans-unit>
        <trans-unit id="13a256cb6eee91493a6f005cfe5cd4ae37f9697f" translate="yes" xml:space="preserve">
          <source>If the argument is NaN or less than zero, then the result is NaN.</source>
          <target state="translated">如果参数是NaN或小于零,那么结果就是NaN。</target>
        </trans-unit>
        <trans-unit id="31b76fec8c3bc86ab1662b04d7bb45867ec9f9d7" translate="yes" xml:space="preserve">
          <source>If the argument is NaN, the result is 0.</source>
          <target state="translated">如果参数是NaN,结果为0。</target>
        </trans-unit>
        <trans-unit id="3aa89491f3556c271cee0931546f3e5660ec7ac7" translate="yes" xml:space="preserve">
          <source>If the argument is NaN, the result is &lt;code&gt;0x7fc00000&lt;/code&gt;.</source>
          <target state="translated">如果参数为NaN，则结果为 &lt;code&gt;0x7fc00000&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a83c5a6baaa1bd2366e8865b925beaeea4e26b42" translate="yes" xml:space="preserve">
          <source>If the argument is NaN, the result is &lt;code&gt;0x7ff8000000000000L&lt;/code&gt;.</source>
          <target state="translated">如果参数为NaN，则结果为 &lt;code&gt;0x7ff8000000000000L&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="118d734407198a907583b63ea2fc64d7c89b2c28" translate="yes" xml:space="preserve">
          <source>If the argument is NaN, the result is NaN.</source>
          <target state="translated">如果参数是NaN,结果就是NaN。</target>
        </trans-unit>
        <trans-unit id="e064879a9427f94b4430bb8b2822c39d482f8755" translate="yes" xml:space="preserve">
          <source>If the argument is NaN, the result is the &lt;code&gt;long&lt;/code&gt; integer representing the actual NaN value. Unlike the &lt;code&gt;doubleToLongBits&lt;/code&gt; method, &lt;code&gt;doubleToRawLongBits&lt;/code&gt; does not collapse all the bit patterns encoding a NaN to a single &quot;canonical&quot; NaN value.</source>
          <target state="translated">如果参数为NaN，则结果为代表实际NaN值的 &lt;code&gt;long&lt;/code&gt; 整数。与 &lt;code&gt;doubleToLongBits&lt;/code&gt; 方法不同， &lt;code&gt;doubleToRawLongBits&lt;/code&gt; 不会将编码NaN的所有位模式折叠为单个&amp;ldquo;规范&amp;rdquo; NaN值。</target>
        </trans-unit>
        <trans-unit id="bca2d981cbc0638a09fdc8f8c3691bf1f893da00" translate="yes" xml:space="preserve">
          <source>If the argument is NaN, the result is the integer representing the actual NaN value. Unlike the &lt;code&gt;floatToIntBits&lt;/code&gt; method, &lt;code&gt;floatToRawIntBits&lt;/code&gt; does not collapse all the bit patterns encoding a NaN to a single &quot;canonical&quot; NaN value.</source>
          <target state="translated">如果参数为NaN，则结果为代表实际NaN值的整数。与 &lt;code&gt;floatToIntBits&lt;/code&gt; 方法不同， &lt;code&gt;floatToRawIntBits&lt;/code&gt; 不会将编码NaN的所有位模式折叠为单个&amp;ldquo;规范&amp;rdquo; NaN值。</target>
        </trans-unit>
        <trans-unit id="db8eab43bb6026b1e9b4780ecae1f1526f2beff3" translate="yes" xml:space="preserve">
          <source>If the argument is NaN, the result is the string &quot;&lt;code&gt;NaN&lt;/code&gt;&quot;.</source>
          <target state="translated">如果参数为NaN，则结果为字符串&amp;ldquo; &lt;code&gt;NaN&lt;/code&gt; &amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="c12f1031f1e9c83194d8ac6506dee76af527571a" translate="yes" xml:space="preserve">
          <source>If the argument is NaN, then the result is NaN.</source>
          <target state="translated">如果参数是NaN,那么结果就是NaN。</target>
        </trans-unit>
        <trans-unit id="d554a647f92a4934769f60285a8988bfd2109472" translate="yes" xml:space="preserve">
          <source>If the argument is a &lt;a href=&quot;font/glyphvector&quot;&gt;&lt;code&gt;GlyphVector&lt;/code&gt;&lt;/a&gt;, then the &lt;code&gt;GlyphVector&lt;/code&gt; object already contains the appropriate font-specific glyph codes with explicit coordinates for the position of each glyph.</source>
          <target state="translated">如果参数是&lt;a href=&quot;font/glyphvector&quot;&gt; &lt;code&gt;GlyphVector&lt;/code&gt; &lt;/a&gt;，则 &lt;code&gt;GlyphVector&lt;/code&gt; 对象已经包含适当的特定于字体的字形代码，并带有每个字形位置的显式坐标。</target>
        </trans-unit>
        <trans-unit id="33084cbb24930f6a9f5be37e387df07eb5022040" translate="yes" xml:space="preserve">
          <source>If the argument is a &lt;code&gt;String&lt;/code&gt;, then the current &lt;code&gt;Font&lt;/code&gt; in the &lt;code&gt;Graphics2D&lt;/code&gt; context is asked to convert the Unicode characters in the &lt;code&gt;String&lt;/code&gt; into a set of glyphs for presentation with whatever basic layout and shaping algorithms the font implements.</source>
          <target state="translated">如果参数是一个 &lt;code&gt;String&lt;/code&gt; ，则当前 &lt;code&gt;Font&lt;/code&gt; 在 &lt;code&gt;Graphics2D&lt;/code&gt; 的情况下被要求在中的Unicode字符转换成 &lt;code&gt;String&lt;/code&gt; 与任何基本布局和成形算法的字体工具为一组字形的呈现。</target>
        </trans-unit>
        <trans-unit id="5a923aa0ff948589bbbea2c5c98edba0c8041581" translate="yes" xml:space="preserve">
          <source>If the argument is already a localized stream, it may be returned as the result.</source>
          <target state="translated">如果参数已经是一个本地化的流,它可能作为结果返回。</target>
        </trans-unit>
        <trans-unit id="e184dfc2be8d0cd0cc281824d50fb9ce2efa94b1" translate="yes" xml:space="preserve">
          <source>If the argument is an &lt;a href=&quot;../../../java.base/java/text/attributedcharacteriterator&quot;&gt;&lt;code&gt;AttributedCharacterIterator&lt;/code&gt;&lt;/a&gt;, the iterator is asked to convert itself to a &lt;a href=&quot;font/textlayout&quot;&gt;&lt;code&gt;TextLayout&lt;/code&gt;&lt;/a&gt; using its embedded font attributes. The &lt;code&gt;TextLayout&lt;/code&gt; implements more sophisticated glyph layout algorithms that perform Unicode bi-directional layout adjustments automatically for multiple fonts of differing writing directions.</source>
          <target state="translated">如果参数是&lt;a href=&quot;../../../java.base/java/text/attributedcharacteriterator&quot;&gt; &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; &lt;/a&gt;，则要求迭代器使用其嵌入的字体属性将其自身转换为&lt;a href=&quot;font/textlayout&quot;&gt; &lt;code&gt;TextLayout&lt;/code&gt; &lt;/a&gt;。该 &lt;code&gt;TextLayout&lt;/code&gt; 的工具更复杂的字形布局算法，自动执行Unicode的双向布局调整为不同的书写方向的多种字体。</target>
        </trans-unit>
        <trans-unit id="e9264d5fd055500aa5c8726a54e413523844cbaf" translate="yes" xml:space="preserve">
          <source>If the argument is any value in the range &lt;code&gt;0x7f800001&lt;/code&gt; through &lt;code&gt;0x7fffffff&lt;/code&gt; or in the range &lt;code&gt;0xff800001&lt;/code&gt; through &lt;code&gt;0xffffffff&lt;/code&gt;, the result is a NaN. No IEEE 754 floating-point operation provided by Java can distinguish between two NaN values of the same type with different bit patterns. Distinct values of NaN are only distinguishable by use of the &lt;code&gt;Float.floatToRawIntBits&lt;/code&gt; method.</source>
          <target state="translated">如果参数是 &lt;code&gt;0x7f800001&lt;/code&gt; 到 &lt;code&gt;0x7fffffff&lt;/code&gt; 范围内的任何值，或者 &lt;code&gt;0xff800001&lt;/code&gt; 到 &lt;code&gt;0xffffffff&lt;/code&gt; 范围内的值，则结果为NaN。 Java提供的IEEE 754浮点运算无法区分具有不同位模式的相同类型的两个NaN值。 NaN的不同值只能通过使用 &lt;code&gt;Float.floatToRawIntBits&lt;/code&gt; 方法来区分。</target>
        </trans-unit>
        <trans-unit id="e09c36577e890868103778c6cad080360d9fef25" translate="yes" xml:space="preserve">
          <source>If the argument is any value in the range &lt;code&gt;0x7ff0000000000001L&lt;/code&gt; through &lt;code&gt;0x7fffffffffffffffL&lt;/code&gt; or in the range &lt;code&gt;0xfff0000000000001L&lt;/code&gt; through &lt;code&gt;0xffffffffffffffffL&lt;/code&gt;, the result is a NaN. No IEEE 754 floating-point operation provided by Java can distinguish between two NaN values of the same type with different bit patterns. Distinct values of NaN are only distinguishable by use of the &lt;code&gt;Double.doubleToRawLongBits&lt;/code&gt; method.</source>
          <target state="translated">如果参数是介于 &lt;code&gt;0x7ff0000000000001L&lt;/code&gt; 到 &lt;code&gt;0x7fffffffffffffffL&lt;/code&gt; 或介于 &lt;code&gt;0xfff0000000000001L&lt;/code&gt; 到 &lt;code&gt;0xffffffffffffffffL&lt;/code&gt; 范围内的任何值，则结果为NaN。Java提供的IEEE 754浮点运算无法区分具有不同位模式的相同类型的两个NaN值。NaN的不同值只能通过使用 &lt;code&gt;Double.doubleToRawLongBits&lt;/code&gt; 方法来区分。</target>
        </trans-unit>
        <trans-unit id="108d000cc41c657851b0d27f0a1ac78cf5e4ee70" translate="yes" xml:space="preserve">
          <source>If the argument is equal to 10&lt;sup&gt;&lt;i&gt;n&lt;/i&gt;&lt;/sup&gt; for integer</source>
          <target state="translated">如果参数等于10 &lt;sup&gt;&lt;i&gt;n&lt;/i&gt;&lt;/sup&gt;（整数）</target>
        </trans-unit>
        <trans-unit id="65efe2e81fa8d1ba670e4b1992ae1775f4b62a76" translate="yes" xml:space="preserve">
          <source>If the argument is infinite, the result is positive infinity.</source>
          <target state="translated">如果论点是无穷大,结果就是正无穷大。</target>
        </trans-unit>
        <trans-unit id="336889ed81a3144be451220af338acfcbb6c9ba3" translate="yes" xml:space="preserve">
          <source>If the argument is infinite, then the result is an infinity with the same sign as the argument.</source>
          <target state="translated">如果参数是无限的,那么结果就是与参数同号的无限。</target>
        </trans-unit>
        <trans-unit id="4691c35189f88af211fb42ae9607c8ae123c02d6" translate="yes" xml:space="preserve">
          <source>If the argument is infinite, then the result is positive infinity.</source>
          <target state="translated">如果论点是无穷大,那么结果就是正无穷大。</target>
        </trans-unit>
        <trans-unit id="ec376818cb2e255655d1881f54f64a5f81a51e7b" translate="yes" xml:space="preserve">
          <source>If the argument is negative infinity or any value less than or equal to the value of &lt;code&gt;Integer.MIN_VALUE&lt;/code&gt;, the result is equal to the value of &lt;code&gt;Integer.MIN_VALUE&lt;/code&gt;.</source>
          <target state="translated">如果参数为负无穷大或任何小于或等于 &lt;code&gt;Integer.MIN_VALUE&lt;/code&gt; 的值，则结果等于 &lt;code&gt;Integer.MIN_VALUE&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="5a08fe9d371940e4f9d92ad57a75f846bb063ec2" translate="yes" xml:space="preserve">
          <source>If the argument is negative infinity or any value less than or equal to the value of &lt;code&gt;Long.MIN_VALUE&lt;/code&gt;, the result is equal to the value of &lt;code&gt;Long.MIN_VALUE&lt;/code&gt;.</source>
          <target state="translated">如果参数为负无穷大或任何小于或等于 &lt;code&gt;Long.MIN_VALUE&lt;/code&gt; 的值，则结果等于 &lt;code&gt;Long.MIN_VALUE&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="f1c38692773d898bd9643813b94e0ae1993eb556" translate="yes" xml:space="preserve">
          <source>If the argument is negative infinity, the result is &lt;code&gt;0xff800000&lt;/code&gt;.</source>
          <target state="translated">如果参数为负无穷大，则结果为 &lt;code&gt;0xff800000&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3bb987ea3c954538087573e2f402d9fdf305369d" translate="yes" xml:space="preserve">
          <source>If the argument is negative infinity, the result is &lt;code&gt;0xfff0000000000000L&lt;/code&gt;.</source>
          <target state="translated">如果参数为负无穷大，则结果为 &lt;code&gt;0xfff0000000000000L&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a6a939ea1df7c37cb72e17d44d1754a7325b1cce" translate="yes" xml:space="preserve">
          <source>If the argument is negative infinity, the result is negative infinity.</source>
          <target state="translated">如果论点是负无穷大,结果就是负无穷大。</target>
        </trans-unit>
        <trans-unit id="ba927f3f79a46354d9209dcd811d86b8a661221b" translate="yes" xml:space="preserve">
          <source>If the argument is negative infinity, then the result is -1.0.</source>
          <target state="translated">如果参数是负无穷大,那么结果就是-1.0。</target>
        </trans-unit>
        <trans-unit id="20f8e0486c54aeb853e7804b4611ce1c56a73d1b" translate="yes" xml:space="preserve">
          <source>If the argument is negative infinity, then the result is &lt;code&gt;-1.0&lt;/code&gt;.</source>
          <target state="translated">如果参数为负无穷大，则结果为 &lt;code&gt;-1.0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d9e3b1cc495f1cc8092755d393fd54a8be9e0bff" translate="yes" xml:space="preserve">
          <source>If the argument is negative infinity, then the result is positive zero.</source>
          <target state="translated">如果参数是负无穷大,那么结果就是正零。</target>
        </trans-unit>
        <trans-unit id="d08b29e2ea8c8a74d04b752def011f9cda30c497" translate="yes" xml:space="preserve">
          <source>If the argument is negative one, then the result is negative infinity.</source>
          <target state="translated">如果论点是负一,那么结果就是负无穷。</target>
        </trans-unit>
        <trans-unit id="ad3d4a3e9566e2c0df155d95c37161c79599330f" translate="yes" xml:space="preserve">
          <source>If the argument is positive infinity or any value greater than or equal to the value of &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;, the result is equal to the value of &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;.</source>
          <target state="translated">如果参数为正无穷大或任何大于或等于 &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt; 的值，则结果等于 &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="eff50c12018038db62b68855eb707df57d7cd5ae" translate="yes" xml:space="preserve">
          <source>If the argument is positive infinity or any value greater than or equal to the value of &lt;code&gt;Long.MAX_VALUE&lt;/code&gt;, the result is equal to the value of &lt;code&gt;Long.MAX_VALUE&lt;/code&gt;.</source>
          <target state="translated">如果参数为正无穷大或任何大于或等于 &lt;code&gt;Long.MAX_VALUE&lt;/code&gt; 的值，则结果等于 &lt;code&gt;Long.MAX_VALUE&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="6a13758d0f976c89623e38e841da2cbc62912670" translate="yes" xml:space="preserve">
          <source>If the argument is positive infinity, the result is &lt;code&gt;0x7f800000&lt;/code&gt;.</source>
          <target state="translated">如果参数为正无穷大，则结果为 &lt;code&gt;0x7f800000&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8c05eefbf6b8959edbbea1c8b9a02322d8935ca7" translate="yes" xml:space="preserve">
          <source>If the argument is positive infinity, the result is &lt;code&gt;0x7ff0000000000000L&lt;/code&gt;.</source>
          <target state="translated">如果参数为正无穷大，则结果为 &lt;code&gt;0x7ff0000000000000L&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cf429a21c2dc34b66e4269078332483b3641ead6" translate="yes" xml:space="preserve">
          <source>If the argument is positive infinity, the result is positive infinity.</source>
          <target state="translated">如果论点是正无穷大,结果就是正无穷大。</target>
        </trans-unit>
        <trans-unit id="31b9de6b24ff8d5ffbebf56f3f1cecc792456081" translate="yes" xml:space="preserve">
          <source>If the argument is positive infinity, then the result is &lt;code&gt;+1.0&lt;/code&gt;.</source>
          <target state="translated">如果参数为正无穷大，则结果为 &lt;code&gt;+1.0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f87ee2c0e3d173098373d3990b3903acb3bfadf9" translate="yes" xml:space="preserve">
          <source>If the argument is positive infinity, then the result is positive infinity.</source>
          <target state="translated">如果论点是正无穷大,那么结果就是正无穷大。</target>
        </trans-unit>
        <trans-unit id="96dab47247ae7e1056e56799ef0665e4ab651c26" translate="yes" xml:space="preserve">
          <source>If the argument is positive or negative infinity, then the result is positive infinity.</source>
          <target state="translated">如果参数是正无穷或负无穷,那么结果就是正无穷。</target>
        </trans-unit>
        <trans-unit id="78148cd34a5b7680af0ed6412b4903e44701b46c" translate="yes" xml:space="preserve">
          <source>If the argument is positive or negative zero, then the result is &lt;code&gt;Double.MIN_VALUE&lt;/code&gt;.</source>
          <target state="translated">如果参数为正零或负零，则结果为 &lt;code&gt;Double.MIN_VALUE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0c4032eb755d363cebfbea8af5b3c0b4a94596cf" translate="yes" xml:space="preserve">
          <source>If the argument is positive or negative zero, then the result is &lt;code&gt;Float.MIN_VALUE&lt;/code&gt;.</source>
          <target state="translated">如果参数为正零或负零，则结果为 &lt;code&gt;Float.MIN_VALUE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f15f3f96dc5106b38775f4ba76d739b00aa110dd" translate="yes" xml:space="preserve">
          <source>If the argument is positive zero or negative zero, the result is positive zero.</source>
          <target state="translated">如果参数是正零或负零,结果就是正零。</target>
        </trans-unit>
        <trans-unit id="0553928b250b89074ae0163da0309f356dd0aea5" translate="yes" xml:space="preserve">
          <source>If the argument is positive zero or negative zero, then the result is negative infinity.</source>
          <target state="translated">如果参数是正零或负零,那么结果就是负无穷。</target>
        </trans-unit>
        <trans-unit id="f8ad8830694a6f7c940aad7bd91216f8c775287b" translate="yes" xml:space="preserve">
          <source>If the argument is positive zero or negative zero, then the result is the same as the argument.</source>
          <target state="translated">如果参数是正零或负零,那么结果与参数相同。</target>
        </trans-unit>
        <trans-unit id="11b6940276c4e767ac8a361ca5f19636e270c2d9" translate="yes" xml:space="preserve">
          <source>If the argument is zero or subnormal, then the result is &lt;a href=&quot;double#MIN_EXPONENT&quot;&gt;&lt;code&gt;Double.MIN_EXPONENT&lt;/code&gt;&lt;/a&gt; -1.</source>
          <target state="translated">如果参数为零或次正规，则结果为&lt;a href=&quot;double#MIN_EXPONENT&quot;&gt; &lt;code&gt;Double.MIN_EXPONENT&lt;/code&gt; &lt;/a&gt; -1。</target>
        </trans-unit>
        <trans-unit id="3905704a484368c3992190c17ec803f5c9734872" translate="yes" xml:space="preserve">
          <source>If the argument is zero or subnormal, then the result is &lt;a href=&quot;float#MIN_EXPONENT&quot;&gt;&lt;code&gt;Float.MIN_EXPONENT&lt;/code&gt;&lt;/a&gt; -1.</source>
          <target state="translated">如果参数为零或次正规，则结果为&lt;a href=&quot;float#MIN_EXPONENT&quot;&gt; &lt;code&gt;Float.MIN_EXPONENT&lt;/code&gt; &lt;/a&gt; -1。</target>
        </trans-unit>
        <trans-unit id="65b605eea787dfcd26a427a347ea4ad7abd516d5" translate="yes" xml:space="preserve">
          <source>If the argument is zero, the result is &lt;a href=&quot;double#MIN_VALUE&quot;&gt;&lt;code&gt;Double.MIN_VALUE&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">如果参数为零，则结果为&lt;a href=&quot;double#MIN_VALUE&quot;&gt; &lt;code&gt;Double.MIN_VALUE&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="82de080d3a1d56fdbaf695d271e223d79695fa9d" translate="yes" xml:space="preserve">
          <source>If the argument is zero, the result is &lt;a href=&quot;float#MIN_VALUE&quot;&gt;&lt;code&gt;Float.MIN_VALUE&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">如果参数为零，则结果为&lt;a href=&quot;float#MIN_VALUE&quot;&gt; &lt;code&gt;Float.MIN_VALUE&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="368d7952fccceed4084cffb62407a857e1140ff5" translate="yes" xml:space="preserve">
          <source>If the argument is zero, the result is &lt;code&gt;-Double.MIN_VALUE&lt;/code&gt;</source>
          <target state="translated">如果参数为零，则结果为 &lt;code&gt;-Double.MIN_VALUE&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e43dae92e6e1f445b98367ed57735c6219a0d0f9" translate="yes" xml:space="preserve">
          <source>If the argument is zero, the result is &lt;code&gt;-Float.MIN_VALUE&lt;/code&gt;</source>
          <target state="translated">如果参数为零，则结果为 &lt;code&gt;-Float.MIN_VALUE&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5db3ba052bf056b3adf9c2be7e6188d33a4e952e" translate="yes" xml:space="preserve">
          <source>If the argument is zero, then the result is &lt;code&gt;1.0&lt;/code&gt;.</source>
          <target state="translated">如果参数为零，则结果为 &lt;code&gt;1.0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b8d665f9570f8b5f180ad4bdb572f1e1aab98bad" translate="yes" xml:space="preserve">
          <source>If the argument is zero, then the result is a zero with the same sign as the argument.</source>
          <target state="translated">如果参数为零,那么结果就是与参数同号的零。</target>
        </trans-unit>
        <trans-unit id="d1f82cc652138d856ee89a85be827d630ca9f31c" translate="yes" xml:space="preserve">
          <source>If the argument value is already equal to a mathematical integer, then the result is the same as the argument.</source>
          <target state="translated">如果参数值已经等于一个数学整数,那么结果与参数相同。</target>
        </trans-unit>
        <trans-unit id="38b3adaab247759b54b2aa2e88f5b5ce2609340f" translate="yes" xml:space="preserve">
          <source>If the argument value is less than zero but greater than -1.0, then the result is negative zero.</source>
          <target state="translated">如果参数值小于零但大于-1.0,则结果为负零。</target>
        </trans-unit>
        <trans-unit id="acfd94f24240c24943c8ec432b5700b6212aa09a" translate="yes" xml:space="preserve">
          <source>If the argument,</source>
          <target state="translated">如果争论。</target>
        </trans-unit>
        <trans-unit id="d16beeb819e4ac6862b921fde8350a257a9f5ad7" translate="yes" xml:space="preserve">
          <source>If the arguments are inconsistent then an &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown. The necessary consistent argument conditions are:</source>
          <target state="translated">如果参数不一致，则抛出 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 。必要的一致参数条件是：</target>
        </trans-unit>
        <trans-unit id="9c14cc5c25518873c4d133fdea60caf8bcd4ae3d" translate="yes" xml:space="preserve">
          <source>If the array contains several elements that reference equal &lt;code&gt;DataFlavor&lt;/code&gt;s, this method will establish new mappings for the first of those elements and ignore the rest of them.</source>
          <target state="translated">如果数组包含多个引用相等的 &lt;code&gt;DataFlavor&lt;/code&gt; 的元素，则此方法将为第一个元素建立新的映射，而忽略其余元素。</target>
        </trans-unit>
        <trans-unit id="cfbcde248a8dade1dd31dd66e1705de02944b301" translate="yes" xml:space="preserve">
          <source>If the array contains several elements that reference equal &lt;code&gt;String&lt;/code&gt; natives, this method will establish new mappings for the first of those elements and ignore the rest of them.</source>
          <target state="translated">如果数组包含多个引用相等的 &lt;code&gt;String&lt;/code&gt; native的元素，则此方法将为第一个元素建立新的映射，而忽略其余元素。</target>
        </trans-unit>
        <trans-unit id="9501d16613e807e8eab597eb061cf001422db435" translate="yes" xml:space="preserve">
          <source>If the array element type differs from any of the corresponding argument types on the original target, the original target is adapted to take the array elements directly, as if by a call to &lt;a href=&quot;#asType(java.lang.invoke.MethodType)&quot;&gt;&lt;code&gt;asType&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果数组元素类型与原始目标上的任何对应参数类型不同，则原始目标适合直接采用数组元素，就像通过调用&lt;a href=&quot;#asType(java.lang.invoke.MethodType)&quot;&gt; &lt;code&gt;asType&lt;/code&gt; 一样&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7b613ad1d7b1ad953ca4724e10cf0c2ca14a21e9" translate="yes" xml:space="preserve">
          <source>If the array element type differs from any of the corresponding argument types on the original target, the original target is adapted to take the array elements directly, as if by a call to &lt;a href=&quot;methodhandle#asType-java.lang.invoke.MethodType-&quot;&gt;&lt;code&gt;asType&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果数组元素类型与原始目标上的任何对应参数类型不同，则原始目标适合直接采用数组元素，就像通过调用&lt;a href=&quot;methodhandle#asType-java.lang.invoke.MethodType-&quot;&gt; &lt;code&gt;asType&lt;/code&gt; 一样&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="50771cd3c005f627dc72ab8c8e5ba994b9a7354f" translate="yes" xml:space="preserve">
          <source>If the array type differs from the final argument type on the original target, the original target is adapted to take the array type directly, as if by a call to &lt;a href=&quot;#asType(java.lang.invoke.MethodType)&quot;&gt;&lt;code&gt;asType&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果数组类型与原始目标上的最终参数类型不同，则原始目标将被适配为直接采用数组类型，就像通过调用&lt;a href=&quot;#asType(java.lang.invoke.MethodType)&quot;&gt; &lt;code&gt;asType&lt;/code&gt; 一样&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8c623454e44ca641a6c552859181a701097e3dda" translate="yes" xml:space="preserve">
          <source>If the array type differs from the final argument type on the original target, the original target is adapted to take the array type directly, as if by a call to &lt;a href=&quot;methodhandle#asType-java.lang.invoke.MethodType-&quot;&gt;&lt;code&gt;asType&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果数组类型与原始目标上的最终参数类型不同，则原始目标将被适配为直接采用数组类型，就像通过调用&lt;a href=&quot;methodhandle#asType-java.lang.invoke.MethodType-&quot;&gt; &lt;code&gt;asType&lt;/code&gt; 一样&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4602014772a49fdb1a8fa2feb07dd113fad7727a" translate="yes" xml:space="preserve">
          <source>If the attempt to load this class produces a &lt;a href=&quot;../../../../java.base/java/lang/classnotfoundexception&quot;&gt;&lt;code&gt;ClassNotFoundException&lt;/code&gt;&lt;/a&gt;, the search for a handler continues with the next element of the list.</source>
          <target state="translated">如果尝试加载此类会产生&lt;a href=&quot;../../../../java.base/java/lang/classnotfoundexception&quot;&gt; &lt;code&gt;ClassNotFoundException&lt;/code&gt; &lt;/a&gt;，则将继续搜索列表中的下一个元素，以查找处理程序。</target>
        </trans-unit>
        <trans-unit id="4389eb5f009bdfaeb30b67c701fdcfe35730fb30" translate="yes" xml:space="preserve">
          <source>If the attempt to load this class produces a &lt;a href=&quot;../../../java/lang/classnotfoundexception&quot;&gt;&lt;code&gt;ClassNotFoundException&lt;/code&gt;&lt;/a&gt;, the search for a handler continues with the next element of the list.</source>
          <target state="translated">如果尝试加载此类会产生&lt;a href=&quot;../../../java/lang/classnotfoundexception&quot;&gt; &lt;code&gt;ClassNotFoundException&lt;/code&gt; &lt;/a&gt;，则将继续搜索列表中的下一个元素，以查找处理程序。</target>
        </trans-unit>
        <trans-unit id="27bcadd9ba9512f4ef4c571a9d187c3039f12ed0" translate="yes" xml:space="preserve">
          <source>If the attribute is not set, or is null, then any class is deemed acceptable.</source>
          <target state="translated">如果属性没有设置,或者为空,那么任何类都被认为是可以接受的。</target>
        </trans-unit>
        <trans-unit id="21f75ebcde7181c9e3879b54dc6999c343b75757" translate="yes" xml:space="preserve">
          <source>If the attribute name has a namespace prefix in the document, the application must include the prefix here.</source>
          <target state="translated">如果属性名在文档中具有命名空间前缀,应用程序必须在这里包含前缀。</target>
        </trans-unit>
        <trans-unit id="318b1b00162c20584c04e29ce092027abd6ca2c6" translate="yes" xml:space="preserve">
          <source>If the attribute name has a namespace prefix, the prefix will still be attached.</source>
          <target state="translated">如果属性名有一个命名空间前缀,前缀仍然会被附加。</target>
        </trans-unit>
        <trans-unit id="43f1e5d2810e31afb29d4cbb5b203ff69de05156" translate="yes" xml:space="preserve">
          <source>If the attribute value is a list of tokens (IDREFS, ENTITIES, or NMTOKENS), the tokens will be concatenated into a single string separated by whitespace.</source>
          <target state="translated">如果属性值是一个标记列表(IDREFS、ENTITIES或NMTOKENS),这些标记将被连接成一个单一的字符串,用空格分隔。</target>
        </trans-unit>
        <trans-unit id="604294b7c0dd6e4d28df89e25837ca4a62600385" translate="yes" xml:space="preserve">
          <source>If the attribute value is a list of tokens (IDREFS, ENTITIES, or NMTOKENS), the tokens will be concatenated into a single string with each token separated by a single space.</source>
          <target state="translated">如果属性值是一个标记列表(IDREFS、ENTITIES或NMTOKENS),这些标记将被连接成一个单一的字符串,每个标记用一个空格隔开。</target>
        </trans-unit>
        <trans-unit id="62a3db83b82f314fea33a46956ad055372005abd" translate="yes" xml:space="preserve">
          <source>If the attribute was not explicitly given a value in the instance document but has a default value provided by the schema associated with the document, an attribute node will be created with &lt;code&gt;specified&lt;/code&gt; set to &lt;code&gt;false&lt;/code&gt;. Removing attribute nodes for which a default value is defined in the schema generates a new attribute node with the default value and &lt;code&gt;specified&lt;/code&gt; set to &lt;code&gt;false&lt;/code&gt;. If validation occurred while invoking &lt;code&gt;Document.normalizeDocument()&lt;/code&gt;, attribute nodes with &lt;code&gt;specified&lt;/code&gt; equals to &lt;code&gt;false&lt;/code&gt; are recomputed according to the default attribute values provided by the schema. If no default value is associate with this attribute in the schema, the attribute node is discarded.</source>
          <target state="translated">如果没有在实例文档中为属性提供明确的值，但具有与文档相关联的架构提供的默认值，则将创建一个属性节点，并将其 &lt;code&gt;specified&lt;/code&gt; 设置设置为 &lt;code&gt;false&lt;/code&gt; 。去除针对其缺省值在模式中定义的属性节点生成与默认值和一个新的属性节点 &lt;code&gt;specified&lt;/code&gt; 集到 &lt;code&gt;false&lt;/code&gt; 。如果在调用 &lt;code&gt;Document.normalizeDocument()&lt;/code&gt; 时发生验证，则 &lt;code&gt;specified&lt;/code&gt; 属性节点等于 &lt;code&gt;false&lt;/code&gt; 根据架构提供的默认属性值重新计算。如果架构中没有默认值与此属性相关联，则该属性节点将被丢弃。</target>
        </trans-unit>
        <trans-unit id="b24e421bf1afcae52b5b217643f689a5e02c7896" translate="yes" xml:space="preserve">
          <source>If the attributes did not match, we would get the results shown in &lt;u&gt;Figure 12&lt;/u&gt;.</source>
          <target state="translated">如果属性不匹配，我们将得到&lt;u&gt;如图12&lt;/u&gt;所示的结果。</target>
        </trans-unit>
        <trans-unit id="3de2839318027a87b01d1160931d4ec1a7e54992" translate="yes" xml:space="preserve">
          <source>If the authority component is present in the spec then the spec is treated as absolute and the spec authority and path will replace the context authority and path. If the authority component is absent in the spec then the authority of the new URL will be inherited from the context.</source>
          <target state="translated">如果规范中存在权限组件,那么规范将被视为绝对的,规范的权限和路径将取代上下文的权限和路径。如果规范中没有权限组件,那么新URL的权限将从上下文中继承。</target>
        </trans-unit>
        <trans-unit id="a027f872693de9d0e476629ed221d81049ef3c8e" translate="yes" xml:space="preserve">
          <source>If the barrier action does not rely on the parties being suspended when it is executed, then any of the threads in the party could execute that action when it is released. To facilitate this, each invocation of &lt;a href=&quot;#await()&quot;&gt;&lt;code&gt;await()&lt;/code&gt;&lt;/a&gt; returns the arrival index of that thread at the barrier. You can then choose which thread should execute the barrier action, for example:</source>
          <target state="translated">如果屏障操作不依赖于执行时暂停的各方，则该方中的任何线程都可以在释放该操作时执行该操作。为方便起见，每次调用&lt;a href=&quot;#await()&quot;&gt; &lt;code&gt;await()&lt;/code&gt; 都会&lt;/a&gt;返回该线程在屏障处的到达索引。然后，您可以选择应该执行屏障操作的线程，例如：</target>
        </trans-unit>
        <trans-unit id="bf5687cbde3be28238012b6e16935454ba496a38" translate="yes" xml:space="preserve">
          <source>If the barrier action does not rely on the parties being suspended when it is executed, then any of the threads in the party could execute that action when it is released. To facilitate this, each invocation of &lt;a href=&quot;cyclicbarrier#await--&quot;&gt;&lt;code&gt;await()&lt;/code&gt;&lt;/a&gt; returns the arrival index of that thread at the barrier. You can then choose which thread should execute the barrier action, for example:</source>
          <target state="translated">如果屏障操作不依赖于执行时暂停的各方，则该方中的任何线程在释放时都可以执行该操作。为方便起见，每次调用&lt;a href=&quot;cyclicbarrier#await--&quot;&gt; &lt;code&gt;await()&lt;/code&gt; 都会&lt;/a&gt;返回该线程在屏障处的到达索引。然后，您可以选择哪个线程应执行屏障操作，例如：</target>
        </trans-unit>
        <trans-unit id="1553601469def15f7ee0f8465070fbc819973117" translate="yes" xml:space="preserve">
          <source>If the barrier is &lt;a href=&quot;#reset()&quot;&gt;&lt;code&gt;reset()&lt;/code&gt;&lt;/a&gt; while any thread is waiting, or if the barrier &lt;a href=&quot;#isBroken()&quot;&gt;is broken&lt;/a&gt; when &lt;code&gt;await&lt;/code&gt; is invoked, or while any thread is waiting, then &lt;a href=&quot;brokenbarrierexception&quot;&gt;&lt;code&gt;BrokenBarrierException&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">如果在任何线程正在等待时&lt;a href=&quot;#reset()&quot;&gt; &lt;code&gt;reset()&lt;/code&gt; &lt;/a&gt;屏障（ barrier ），或者在调用 &lt;code&gt;await&lt;/code&gt; 或任何线程正在等待时&lt;a href=&quot;#isBroken()&quot;&gt;打破&lt;/a&gt;了屏障，则将抛出&lt;a href=&quot;brokenbarrierexception&quot;&gt; &lt;code&gt;BrokenBarrierException&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dac9df73081697b7b7531c1d6a0b9c3e69c870d7" translate="yes" xml:space="preserve">
          <source>If the barrier is &lt;a href=&quot;cyclicbarrier#reset--&quot;&gt;&lt;code&gt;reset()&lt;/code&gt;&lt;/a&gt; while any thread is waiting, or if the barrier &lt;a href=&quot;cyclicbarrier#isBroken--&quot;&gt;is broken&lt;/a&gt; when &lt;code&gt;await&lt;/code&gt; is invoked, or while any thread is waiting, then &lt;a href=&quot;brokenbarrierexception&quot;&gt;&lt;code&gt;BrokenBarrierException&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">如果在任何线程正在等待时屏障被&lt;a href=&quot;cyclicbarrier#reset--&quot;&gt; &lt;code&gt;reset()&lt;/code&gt; &lt;/a&gt;，或者在调用 &lt;code&gt;await&lt;/code&gt; 时或在任何线程正在等待时屏障&lt;a href=&quot;cyclicbarrier#isBroken--&quot;&gt;被打破&lt;/a&gt;，则将抛出&lt;a href=&quot;brokenbarrierexception&quot;&gt; &lt;code&gt;BrokenBarrierException&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="575a83a87991707c167ff499c572b2c82c888c2d" translate="yes" xml:space="preserve">
          <source>If the bean also implemented the zero argument get listener method:</source>
          <target state="translated">如果bean也实现了零参数get监听器方法。</target>
        </trans-unit>
        <trans-unit id="2c223aaa7bd3533fb82949d6d90648ac9350bba7" translate="yes" xml:space="preserve">
          <source>If the bean is a subtype of java.applet.Applet, then it is given some special initialization. First, it is supplied with a default AppletStub and AppletContext. Second, if it was instantiated from a classname the applet's &quot;init&quot; method is called. (If the bean was deserialized this step is skipped.)</source>
          <target state="translated">如果bean是java.applet.Applet的一个子类型,那么就会给它一些特殊的初始化。首先,它被提供了一个默认的AppletStub和AppletContext。其次,如果它是从一个类名实例化而来的,那么applet的 &quot;init &quot;方法就会被调用。(如果bean是被反序列化的,则跳过这一步。)</target>
        </trans-unit>
        <trans-unit id="80874718dd7a5a6c0f974bdb517de9b9cdeaa788" translate="yes" xml:space="preserve">
          <source>If the behavioral parameters do have side-effects, unless explicitly stated, there are no guarantees as to the &lt;a href=&quot;../concurrent/package-summary#MemoryVisibility&quot;&gt;&lt;i&gt;visibility&lt;/i&gt;&lt;/a&gt; of those side-effects to other threads, nor are there any guarantees that different operations on the &quot;same&quot; element within the same stream pipeline are executed in the same thread. Further, the ordering of those effects may be surprising. Even when a pipeline is constrained to produce a &lt;em&gt;result&lt;/em&gt; that is consistent with the encounter order of the stream source (for example, &lt;code&gt;IntStream.range(0,5).parallel().map(x -&amp;gt; x*2).toArray()&lt;/code&gt; must produce &lt;code&gt;[0, 2, 4, 6, 8]&lt;/code&gt;), no guarantees are made as to the order in which the mapper function is applied to individual elements, or in what thread any behavioral parameter is executed for a given element.</source>
          <target state="translated">如果行为参数确实具有副作用，除非明确说明，否则不能保证这些副作用对其他线程的&lt;a href=&quot;../concurrent/package-summary#MemoryVisibility&quot;&gt;&lt;i&gt;可见性&lt;/i&gt;&lt;/a&gt;，也不能保证在同一流管道中对&amp;ldquo;相同&amp;rdquo;元素进行不同的操作在同一线程中执行。此外，这些效果的排序可能令人惊讶。即使当管道被约束以产生与流源的遇到顺序一致的&lt;em&gt;结果时&lt;/em&gt;（例如， &lt;code&gt;IntStream.range(0,5).parallel().map(x -&amp;gt; x*2).toArray()&lt;/code&gt; 必须产生 &lt;code&gt;[0, 2, 4, 6, 8]&lt;/code&gt; ），则无法保证将映射器函数应用于单个元素的顺序，或对给定元素执行任何行为参数的线程。</target>
        </trans-unit>
        <trans-unit id="f3cae85a2bc3049c2747d3d97aa3594bc11da611" translate="yes" xml:space="preserve">
          <source>If the behavioral parameters do have side-effects, unless explicitly stated, there are no guarantees as to:</source>
          <target state="translated">如果行为参数确实有副作用,除非明确说明,否则不能保证:</target>
        </trans-unit>
        <trans-unit id="ccf27e1407104ddd4079359fbf08f2ee48d40b5e" translate="yes" xml:space="preserve">
          <source>If the best MIME type in the array does not support the charset parameter, the flavors which share that MIME type will then be sorted by their representation classes in the following order: &lt;code&gt;java.io.InputStream&lt;/code&gt;, &lt;code&gt;java.nio.ByteBuffer&lt;/code&gt;, &lt;code&gt;[B&lt;/code&gt;, &amp;lt;all others&amp;gt;.</source>
          <target state="translated">如果数组中最好的MIME类型不支持charset参数，则共享该MIME类型的风味将按其表示形式类按以下顺序排序： &lt;code&gt;java.io.InputStream&lt;/code&gt; ， &lt;code&gt;java.nio.ByteBuffer&lt;/code&gt; ， &lt;code&gt;[B&lt;/code&gt; ， &amp;lt;所有其他&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="ca5ea6c87eee103edbf011257ea8f6318b689500" translate="yes" xml:space="preserve">
          <source>If the best MIME type in the array does support the charset parameter, the flavors which share that MIME type will then be sorted by their representation classes in the following order: &lt;code&gt;java.io.Reader&lt;/code&gt;, &lt;code&gt;java.lang.String&lt;/code&gt;, &lt;code&gt;java.nio.CharBuffer&lt;/code&gt;, &lt;code&gt;[C&lt;/code&gt;, &amp;lt;all others&amp;gt;.</source>
          <target state="translated">如果数组中最好的MIME类型确实支持charset参数，则共享该MIME类型的样式将按其表示形式类按以下顺序排序： &lt;code&gt;java.io.Reader&lt;/code&gt; ， &lt;code&gt;java.lang.String&lt;/code&gt; ， &lt;code&gt;java.nio.CharBuffer&lt;/code&gt; ， &lt;code&gt;[C&lt;/code&gt; ，&amp;lt;所有其他&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="e64f9482d0004a103071d818b6eabe3a9e8fa8ce" translate="yes" xml:space="preserve">
          <source>If the bit offset is non-zero, forces the remaining bits in the current byte to 0 and advances the stream position by one.</source>
          <target state="translated">如果位偏移量不为零,则强制当前字节中的剩余位为0,并将流位置前进一位。</target>
        </trans-unit>
        <trans-unit id="f00562687194200d7d3d4e8dbcd71f247eefddae" translate="yes" xml:space="preserve">
          <source>If the bit offset is non-zero, forces the remaining bits in the current byte to 0 and advances the stream position by one. This method should be called by subclasses at the beginning of the &lt;code&gt;write(int)&lt;/code&gt; and &lt;code&gt;write(byte[], int, int)&lt;/code&gt; methods.</source>
          <target state="translated">如果位偏移量不为零，则将当前字节中的其余位强制为0，并将流位置前进1。子类应在 &lt;code&gt;write(int)&lt;/code&gt; 和 &lt;code&gt;write(byte[], int, int)&lt;/code&gt; 方法的开头调用此方法。</target>
        </trans-unit>
        <trans-unit id="92b946e43c30c152e86047538b9789992732b7fc" translate="yes" xml:space="preserve">
          <source>If the bit offset within the stream is non-zero, the remainder of the current byte is padded with 0s and written out first. The bit offset will be 0 after the write.</source>
          <target state="translated">如果流内的位偏移量为非零,则当前字节的剩余部分用0填充,并先写出。写出后,位偏移量将为0。</target>
        </trans-unit>
        <trans-unit id="618cf6b5a31a53e5fb031a41327ab959ec20a724" translate="yes" xml:space="preserve">
          <source>If the bit offset within the stream is non-zero, the remainder of the current byte is padded with 0s and written out first. The bit offset will be 0 after the write. Implementers can use the &lt;a href=&quot;imageoutputstreamimpl#flushBits()&quot;&gt;&lt;code&gt;flushBits&lt;/code&gt;&lt;/a&gt; method of &lt;a href=&quot;imageoutputstreamimpl&quot;&gt;&lt;code&gt;ImageOutputStreamImpl&lt;/code&gt;&lt;/a&gt; to guarantee this.</source>
          <target state="translated">如果流中的位偏移量不为零，则将当前字节的其余部分填充为0，然后首先写出。写入后位偏移量将为0。实现者可以使用&lt;a href=&quot;imageoutputstreamimpl&quot;&gt; &lt;code&gt;ImageOutputStreamImpl&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;imageoutputstreamimpl#flushBits()&quot;&gt; &lt;code&gt;flushBits&lt;/code&gt; &lt;/a&gt;方法来保证这一点。</target>
        </trans-unit>
        <trans-unit id="a17bf4b09c9d50c7630d0558298715e241010710" translate="yes" xml:space="preserve">
          <source>If the bit offset within the stream is non-zero, the remainder of the current byte is padded with 0s and written out first. The bit offset will be 0 after the write. Implementers can use the &lt;a href=&quot;imageoutputstreamimpl#flushBits--&quot;&gt;&lt;code&gt;flushBits&lt;/code&gt;&lt;/a&gt; method of &lt;a href=&quot;imageoutputstreamimpl&quot;&gt;&lt;code&gt;ImageOutputStreamImpl&lt;/code&gt;&lt;/a&gt; to guarantee this.</source>
          <target state="translated">如果流中的位偏移量不为零，则将当前字节的其余部分填充为0，然后首先写出。写入后位偏移量将为0。实现者可以使用&lt;a href=&quot;imageoutputstreamimpl&quot;&gt; &lt;code&gt;ImageOutputStreamImpl&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;imageoutputstreamimpl#flushBits--&quot;&gt; &lt;code&gt;flushBits&lt;/code&gt; &lt;/a&gt;方法来保证这一点。</target>
        </trans-unit>
        <trans-unit id="5508ed99f9c67a4ebbd4b73e88b50a057b0cdcc0" translate="yes" xml:space="preserve">
          <source>If the boolean system property &lt;code&gt;&lt;span id=&quot;org.openjdk.java.util.stream.tripwire&quot;&gt;org.openjdk.java.util.stream.tripwire&lt;/span&gt;&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt; then diagnostic warnings are reported if boxing of primitive values occur when operating on primitive subtype specializations.</source>
          <target state="translated">如果布尔系统属性 &lt;code&gt;&lt;span id=&quot;org.openjdk.java.util.stream.tripwire&quot;&gt;org.openjdk.java.util.stream.tripwire&lt;/span&gt;&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; ,则在对原始子类型专门化进行操作时，如果发生原始值的装箱，则会报告诊断警告。</target>
        </trans-unit>
        <trans-unit id="7c99084a7828ec1a975c99c15549a5685147fb7b" translate="yes" xml:space="preserve">
          <source>If the boolean system property &lt;code&gt;org.openjdk.java.util.stream.tripwire&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt; then diagnostic warnings are reported if boxing of primitive values occur when operating on primitive subtype specializations.</source>
          <target state="translated">如果布尔系统属性 &lt;code&gt;org.openjdk.java.util.stream.tripwire&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; ,则在对原始子类型专门化进行操作时如果发生原始值的装箱，则会报告诊断警告。</target>
        </trans-unit>
        <trans-unit id="5a92adab1b458e89d84f2de880f27113ac825c1c" translate="yes" xml:space="preserve">
          <source>If the bootstrap class loader is represented as &lt;code&gt;null&lt;/code&gt; in the Java Virtual Machine (JVM), then &lt;code&gt;null&lt;/code&gt; is also the return value of this method.</source>
          <target state="translated">如果引导类加载器在Java虚拟机（JVM）中表示为 &lt;code&gt;null&lt;/code&gt; ，则 &lt;code&gt;null&lt;/code&gt; 也是此方法的返回值。</target>
        </trans-unit>
        <trans-unit id="1b7842845f7cac936a098919d982da718dd2d664" translate="yes" xml:space="preserve">
          <source>If the border, font, or color property values are not specified in the constructor or by invoking the appropriate set methods, the property values will be defined by the current look and feel, using the following property names in the Defaults Table:</source>
          <target state="translated">如果在构造函数中没有指定边框、字体或颜色属性值,或者没有调用相应的设置方法,那么属性值将由当前的外观和感觉来定义,使用默认表中的以下属性名。</target>
        </trans-unit>
        <trans-unit id="99c31ef671411db209dfcab81af4e78e3e5b165e" translate="yes" xml:space="preserve">
          <source>If the boundary-points of a Range do not meet specific requirements.</source>
          <target state="translated">如果一个范围的边界点不符合具体要求。</target>
        </trans-unit>
        <trans-unit id="87e5deffba95ab1ac7918aac0643a0fb2206533c" translate="yes" xml:space="preserve">
          <source>If the calendar type is &lt;code&gt;&quot;iso8601&quot;&lt;/code&gt;, the &lt;a href=&quot;gregoriancalendar#setGregorianChange(java.util.Date)&quot;&gt;Gregorian change date&lt;/a&gt; of a &lt;a href=&quot;gregoriancalendar&quot;&gt;&lt;code&gt;GregorianCalendar&lt;/code&gt;&lt;/a&gt; is set to &lt;code&gt;Date(Long.MIN_VALUE)&lt;/code&gt; to be the &lt;em&gt;proleptic&lt;/em&gt; Gregorian calendar. Its week definition parameters are also set to be &lt;a href=&quot;gregoriancalendar#iso8601_compatible_setting&quot;&gt;compatible with the ISO 8601 standard&lt;/a&gt;. Note that the &lt;a href=&quot;gregoriancalendar#getCalendarType()&quot;&gt;&lt;code&gt;getCalendarType&lt;/code&gt;&lt;/a&gt; method of a &lt;code&gt;GregorianCalendar&lt;/code&gt; created with &lt;code&gt;&quot;iso8601&quot;&lt;/code&gt; returns &lt;code&gt;&quot;gregory&quot;&lt;/code&gt;.</source>
          <target state="translated">如果日历类型是 &lt;code&gt;&quot;iso8601&quot;&lt;/code&gt; ，在&lt;a href=&quot;gregoriancalendar#setGregorianChange(java.util.Date)&quot;&gt;公历更改日期&lt;/a&gt;一的&lt;a href=&quot;gregoriancalendar&quot;&gt; &lt;code&gt;GregorianCalendar&lt;/code&gt; 的&lt;/a&gt;设置为 &lt;code&gt;Date(Long.MIN_VALUE)&lt;/code&gt; 是&lt;em&gt;proleptic&lt;/em&gt;公历。还可以将其周定义参数设置为&lt;a href=&quot;gregoriancalendar#iso8601_compatible_setting&quot;&gt;与ISO 8601标准兼容&lt;/a&gt;。注意，&lt;a href=&quot;gregoriancalendar#getCalendarType()&quot;&gt; &lt;code&gt;getCalendarType&lt;/code&gt; &lt;/a&gt;一个方法 &lt;code&gt;GregorianCalendar&lt;/code&gt; 与创建 &lt;code&gt;&quot;iso8601&quot;&lt;/code&gt; 回报 &lt;code&gt;&quot;gregory&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="486a42feea23b408f730eefa4db49a5a9bbd4a21" translate="yes" xml:space="preserve">
          <source>If the calendar type is &lt;code&gt;&quot;iso8601&quot;&lt;/code&gt;, the &lt;a href=&quot;gregoriancalendar#setGregorianChange-java.util.Date-&quot;&gt;Gregorian change date&lt;/a&gt; of a &lt;a href=&quot;gregoriancalendar&quot;&gt;&lt;code&gt;GregorianCalendar&lt;/code&gt;&lt;/a&gt; is set to &lt;code&gt;Date(Long.MIN_VALUE)&lt;/code&gt; to be the &lt;em&gt;proleptic&lt;/em&gt; Gregorian calendar. Its week definition parameters are also set to be &lt;a href=&quot;gregoriancalendar#iso8601_compatible_setting&quot;&gt;compatible with the ISO 8601 standard&lt;/a&gt;. Note that the &lt;a href=&quot;gregoriancalendar#getCalendarType--&quot;&gt;&lt;code&gt;getCalendarType&lt;/code&gt;&lt;/a&gt; method of a &lt;code&gt;GregorianCalendar&lt;/code&gt; created with &lt;code&gt;&quot;iso8601&quot;&lt;/code&gt; returns &lt;code&gt;&quot;gregory&quot;&lt;/code&gt;.</source>
          <target state="translated">如果日历类型是 &lt;code&gt;&quot;iso8601&quot;&lt;/code&gt; ，在&lt;a href=&quot;gregoriancalendar#setGregorianChange-java.util.Date-&quot;&gt;公历更改日期&lt;/a&gt;一的&lt;a href=&quot;gregoriancalendar&quot;&gt; &lt;code&gt;GregorianCalendar&lt;/code&gt; 的&lt;/a&gt;设置为 &lt;code&gt;Date(Long.MIN_VALUE)&lt;/code&gt; 是&lt;em&gt;proleptic&lt;/em&gt;公历。其周定义参数也设置为&lt;a href=&quot;gregoriancalendar#iso8601_compatible_setting&quot;&gt;与ISO 8601标准兼容&lt;/a&gt;。注意，&lt;a href=&quot;gregoriancalendar#getCalendarType--&quot;&gt; &lt;code&gt;getCalendarType&lt;/code&gt; &lt;/a&gt;一个方法 &lt;code&gt;GregorianCalendar&lt;/code&gt; 与创建 &lt;code&gt;&quot;iso8601&quot;&lt;/code&gt; 回报 &lt;code&gt;&quot;gregory&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="533aa6e407d4df4fa84a0752b83c5cc2a43222eb" translate="yes" xml:space="preserve">
          <source>If the call site's symbolic type descriptor exactly matches this method handle's &lt;a href=&quot;#type()&quot;&gt;&lt;code&gt;type&lt;/code&gt;&lt;/a&gt;, the call proceeds as if by &lt;a href=&quot;#invokeExact(java.lang.Object...)&quot;&gt;&lt;code&gt;invokeExact&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果调用站点的符号类型描述符与该方法句柄的&lt;a href=&quot;#type()&quot;&gt; &lt;code&gt;type&lt;/code&gt; &lt;/a&gt;完全匹配，则调用将像通过&lt;a href=&quot;#invokeExact(java.lang.Object...)&quot;&gt; &lt;code&gt;invokeExact&lt;/code&gt; 一样进行&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="aa913ecbed54558eb291f0922076e469c78e1e5a" translate="yes" xml:space="preserve">
          <source>If the call site's symbolic type descriptor exactly matches this method handle's &lt;a href=&quot;methodhandle#type&quot;&gt;&lt;code&gt;type&lt;/code&gt;&lt;/a&gt;, the call proceeds as if by &lt;a href=&quot;methodhandle#invokeExact-java.lang.Object...-&quot;&gt;&lt;code&gt;invokeExact&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果调用站点的符号类型描述符与该方法句柄的&lt;a href=&quot;methodhandle#type&quot;&gt; &lt;code&gt;type&lt;/code&gt; &lt;/a&gt;完全匹配，则调用将像通过&lt;a href=&quot;methodhandle#invokeExact-java.lang.Object...-&quot;&gt; &lt;code&gt;invokeExact&lt;/code&gt; 一样进行&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="598d1ca28e965a4e453fe096de8cef9a2d34ea67" translate="yes" xml:space="preserve">
          <source>If the call to sendResponseHeaders() specified a fixed response body length, then the exact number of bytes specified in that call must be written to this stream. If too many bytes are written, then write() will throw an IOException. If too few bytes are written then the stream close() will throw an IOException. In both cases, the exchange is aborted and the underlying TCP connection closed.</source>
          <target state="translated">如果对sendResponseHeaders()的调用指定了固定的响应体长度,那么必须将该调用中指定的确切字节数写入这个流。如果写入的字节数太多,那么write()将抛出一个IOException。如果写入的字节数太少,那么流关闭()将抛出一个IOException。在这两种情况下,都会中止交换,并关闭底层的TCP连接。</target>
        </trans-unit>
        <trans-unit id="8da6d1bbefc65f4e59f9e3250b8dcf1e6a450b67" translate="yes" xml:space="preserve">
          <source>If the call was executed on Windows, with SOURCE_PATH set to &lt;code&gt;&quot;C:\Documents&amp;nbsp;and&amp;nbsp;Settings\UncleBob\src\share\classes&quot;&lt;/code&gt;, a valid result would be a file object representing the file &lt;code&gt;&quot;C:\Documents&amp;nbsp;and&amp;nbsp;Settings\UncleBob\src\share\classes\com\sun\tools\javac\resources\compiler.properties&quot;&lt;/code&gt;.</source>
          <target state="translated">如果调用是在Windows上执行的，并且SOURCE_PATH设置为 &lt;code&gt;&quot;C:\Documents&amp;nbsp;and&amp;nbsp;Settings\UncleBob\src\share\classes&quot;&lt;/code&gt; ，则有效结果将是代表文件 &lt;code&gt;&quot;C:\Documents&amp;nbsp;and&amp;nbsp;Settings\UncleBob\src\share\classes\com\sun\tools\javac\resources\compiler.properties&quot;&lt;/code&gt; 的文件对象。 src \ share \ classes \ com \ sun \ tools \ javac \ resources \ compiler.properties&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="82c1f7dd616c9fa0f0453a51b6c0d76cd6731897" translate="yes" xml:space="preserve">
          <source>If the caller instantiates the context using the default &lt;code&gt;GSSManager&lt;/code&gt; instance, then the Kerberos v5 GSS-API mechanism is guaranteed to be available for context establishment. This mechanism is identified by the Oid &quot;1.2.840.113554.1.2.2&quot; and is defined in RFC 1964.</source>
          <target state="translated">如果调用者使用默认的 &lt;code&gt;GSSManager&lt;/code&gt; 实例实例化上下文，则可以保证Kerberos v5 GSS-API机制可用于上下文建立。此机制由Oid&amp;ldquo; 1.2.840.113554.1.2.2&amp;rdquo;标识，并在RFC 1964中定义。</target>
        </trans-unit>
        <trans-unit id="6ff260529ceaf173f6b333228a7d30097feb002e" translate="yes" xml:space="preserve">
          <source>If the caller module &lt;code&gt;M1&lt;/code&gt; differs from the target module &lt;code&gt;M2&lt;/code&gt; then both of the following must be true:</source>
          <target state="translated">如果调用方模块 &lt;code&gt;M1&lt;/code&gt; 与目标模块 &lt;code&gt;M2&lt;/code&gt; 不同，则以下两个条件必须为真：</target>
        </trans-unit>
        <trans-unit id="76dba0e51a985d3607bdbbe713e1aa4f8e5d2e2f" translate="yes" xml:space="preserve">
          <source>If the caller module is a &lt;a href=&quot;spi/resourcebundleprovider#obtain-resource-bundle&quot;&gt; resource bundle provider&lt;/a&gt;, it does not fall back to the class loader search.</source>
          <target state="translated">如果调用方模块是&lt;a href=&quot;spi/resourcebundleprovider#obtain-resource-bundle&quot;&gt;资源束提供程序&lt;/a&gt;，则它不会退回到类加载器搜索中。</target>
        </trans-unit>
        <trans-unit id="127ed743b798d2c554cd5dbd0da31702ddd38bcb" translate="yes" xml:space="preserve">
          <source>If the caller module is a named module and the given &lt;code&gt;loader&lt;/code&gt; is the caller module's class loader, this method is equivalent to &lt;code&gt;getBundle(baseName, locale)&lt;/code&gt;; otherwise, it may not find resource bundles from named modules. Use &lt;a href=&quot;#getBundle(java.lang.String,java.util.Locale,java.lang.Module)&quot;&gt;&lt;code&gt;getBundle(String, Locale, Module)&lt;/code&gt;&lt;/a&gt; to load resource bundles on behalf on a specific module instead.</source>
          <target state="translated">如果调用方模块是命名模块，并且给定的 &lt;code&gt;loader&lt;/code&gt; 是调用方模块的类加载器，则此方法等效于 &lt;code&gt;getBundle(baseName, locale)&lt;/code&gt; ; 否则，它可能无法从命名模块中找到资源束。使用&lt;a href=&quot;#getBundle(java.lang.String,java.util.Locale,java.lang.Module)&quot;&gt; &lt;code&gt;getBundle(String, Locale, Module)&lt;/code&gt; &lt;/a&gt;代替特定模块代表加载资源束。</target>
        </trans-unit>
        <trans-unit id="9bab532ba6bbba009ffbae752606d6da2e48286a" translate="yes" xml:space="preserve">
          <source>If the caller specifies a &lt;code&gt;null&lt;/code&gt; Subject and a &lt;code&gt;null&lt;/code&gt; value is permitted, the LoginContext instantiates a new Subject.</source>
          <target state="translated">如果调用方指定一个 &lt;code&gt;null&lt;/code&gt; Subject，并且允许使用 &lt;code&gt;null&lt;/code&gt; 值，则LoginContext实例化一个新的Subject。</target>
        </trans-unit>
        <trans-unit id="cddd5c45ec5323f48597c6883597894f02cc5d57" translate="yes" xml:space="preserve">
          <source>If the caller supplies values that are inconsistent or out of bounds, the method enforces these constraints silently, and without failure. Specifically, if the start position or end position is greater than the length of the text, it is reset to equal the text length. If the start position is less than zero, it is reset to zero, and if the end position is less than the start position, it is reset to the start position.</source>
          <target state="translated">如果调用者提供的值不一致或超出边界,该方法就会默默地执行这些约束,而且不会失败。具体来说,如果起始位置或结束位置大于文本的长度,则重置为等于文本长度。如果起始位置小于零,则重置为零,如果结束位置小于起始位置,则重置为起始位置。</target>
        </trans-unit>
        <trans-unit id="8d99d89b43899a3641eb5674cead1a33a1d5f371" translate="yes" xml:space="preserve">
          <source>If the caller's class loader defines a &lt;code&gt;Package&lt;/code&gt; of the given name, the &lt;code&gt;Package&lt;/code&gt; is returned. Otherwise, the ancestors of the caller's class loader are searched recursively (parent by parent) for a &lt;code&gt;Package&lt;/code&gt; of the given name.</source>
          <target state="translated">如果调用者的类加载器定义了一个 &lt;code&gt;Package&lt;/code&gt; 给定名称时， &lt;code&gt;Package&lt;/code&gt; 被返回。否则，将递归搜索调用方的类加载器的祖先（父级为父级）以查找给定名称的 &lt;code&gt;Package&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="326d2f1653f789cda443686d18377e6514d2a778" translate="yes" xml:space="preserve">
          <source>If the caller's module is this module then update this module to add a service dependence on the given service type.</source>
          <target state="translated">如果调用者的模块是这个模块,那么更新这个模块,在给定的服务类型上添加服务依赖。</target>
        </trans-unit>
        <trans-unit id="0de0313a99182f5f835a0cf120f13fa81db11645" translate="yes" xml:space="preserve">
          <source>If the caller's module is this module then update this module to add a service dependence on the given service type. This method is intended for use by frameworks that invoke &lt;a href=&quot;../util/serviceloader&quot;&gt;&lt;code&gt;ServiceLoader&lt;/code&gt;&lt;/a&gt; on behalf of other modules or where the framework is passed a reference to the service type by other code. This method is a no-op when invoked on an unnamed module or an automatic module.</source>
          <target state="translated">如果调用者的模块是此模块，则更新此模块以添加对给定服务类型的服务依赖性。此方法旨在供代表其他模块调用&lt;a href=&quot;../util/serviceloader&quot;&gt; &lt;code&gt;ServiceLoader&lt;/code&gt; &lt;/a&gt;的框架使用，或在框架通过其他代码传递对服务类型的引用的情况下使用。在未命名的模块或自动模块上调用此方法时，此方法是无操作的。</target>
        </trans-unit>
        <trans-unit id="2df2be70297edd88e8c12a7c5f300e9bb81d2b5b" translate="yes" xml:space="preserve">
          <source>If the caller's module is this module then update this module to export the given package to the given module.</source>
          <target state="translated">如果调用者的模块是这个模块,那么就更新这个模块,将给定的包导出到给定的模块。</target>
        </trans-unit>
        <trans-unit id="6758eb950c4ad23ad7160ebf4f955a5a3f8c692e" translate="yes" xml:space="preserve">
          <source>If the caller's module is this module then update this module to read the given module.</source>
          <target state="translated">如果调用者的模块是这个模块,那么更新这个模块来读取给定的模块。</target>
        </trans-unit>
        <trans-unit id="360e9083fc3848da89a866e2997b26119a42eb1d" translate="yes" xml:space="preserve">
          <source>If the caller's module is this module then update this module to read the given module. This method is a no-op if &lt;code&gt;other&lt;/code&gt; is this module (all modules read themselves), this module is an unnamed module (as unnamed modules read all modules), or this module already reads &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">如果调用者的模块是此模块，则更新该模块以读取给定的模块。如果 &lt;code&gt;other&lt;/code&gt; 模块是此模块（所有模块均读取自身），该模块是未命名的模块（因为未命名的模块读取所有模块）或此模块已读取 &lt;code&gt;other&lt;/code&gt; ，则此方法为空操作。</target>
        </trans-unit>
        <trans-unit id="269b3f0fe8fb44df4ce0a6fe047dfebd11282f41" translate="yes" xml:space="preserve">
          <source>If the calling method is interested in retrieving the named property then it would have to test the element to see if it is a proxy class.</source>
          <target state="translated">如果调用方法对检索命名的属性感兴趣,那么它就必须测试该元素是否是一个代理类。</target>
        </trans-unit>
        <trans-unit id="9253130a27a78e3a08350cf89cd42b9d30c402d8" translate="yes" xml:space="preserve">
          <source>If the certificate is of type X.509 and has a</source>
          <target state="translated">如果证书的类型为X.509,并且有一个</target>
        </trans-unit>
        <trans-unit id="aaacbc8edbe2f8c424f5386b7ac1e0da44e25e33" translate="yes" xml:space="preserve">
          <source>If the channel has already been closed then this method returns immediately. Otherwise it marks the channel as closed and then invokes the &lt;a href=&quot;#implCloseChannel()&quot;&gt;&lt;code&gt;implCloseChannel&lt;/code&gt;&lt;/a&gt; method in order to complete the close operation.</source>
          <target state="translated">如果通道已经关闭，则此方法将立即返回。否则，它将通道标记为已关闭，然后调用&lt;a href=&quot;#implCloseChannel()&quot;&gt; &lt;code&gt;implCloseChannel&lt;/code&gt; &lt;/a&gt;方法以完成关闭操作。</target>
        </trans-unit>
        <trans-unit id="b697d0518cb0986befd095c4c07f371b7bc19eb6" translate="yes" xml:space="preserve">
          <source>If the channel has already been closed then this method returns immediately. Otherwise it marks the channel as closed and then invokes the &lt;a href=&quot;abstractinterruptiblechannel#implCloseChannel--&quot;&gt;&lt;code&gt;implCloseChannel&lt;/code&gt;&lt;/a&gt; method in order to complete the close operation.</source>
          <target state="translated">如果通道已经关闭，则此方法立即返回。否则，它将通道标记为已关闭，然后调用&lt;a href=&quot;abstractinterruptiblechannel#implCloseChannel--&quot;&gt; &lt;code&gt;implCloseChannel&lt;/code&gt; &lt;/a&gt;方法以完成关闭操作。</target>
        </trans-unit>
        <trans-unit id="d252f820f6c574294d1558501615ce3622e72864" translate="yes" xml:space="preserve">
          <source>If the channel is a member of a multicast group then the membership is &lt;a href=&quot;membershipkey#drop()&quot;&gt;&lt;code&gt;dropped&lt;/code&gt;&lt;/a&gt;. Upon return, the &lt;a href=&quot;membershipkey&quot;&gt;&lt;code&gt;membership-key&lt;/code&gt;&lt;/a&gt; will be &lt;a href=&quot;membershipkey#isValid()&quot;&gt;&lt;code&gt;invalid&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果通道是多播组的成员，则成员资格将被&lt;a href=&quot;membershipkey#drop()&quot;&gt; &lt;code&gt;dropped&lt;/code&gt; &lt;/a&gt;。返回时，&lt;a href=&quot;membershipkey&quot;&gt; &lt;code&gt;membership-key&lt;/code&gt; &lt;/a&gt;将&lt;a href=&quot;membershipkey#isValid()&quot;&gt; &lt;code&gt;invalid&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="258471a2858a2bd50b28d36eb9c0232d73db11d8" translate="yes" xml:space="preserve">
          <source>If the channel is a member of a multicast group then the membership is &lt;a href=&quot;membershipkey#drop--&quot;&gt;&lt;code&gt;dropped&lt;/code&gt;&lt;/a&gt;. Upon return, the &lt;a href=&quot;membershipkey&quot;&gt;&lt;code&gt;membership-key&lt;/code&gt;&lt;/a&gt; will be &lt;a href=&quot;membershipkey#isValid--&quot;&gt;&lt;code&gt;invalid&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果通道是多播组的成员，则成员资格将被&lt;a href=&quot;membershipkey#drop--&quot;&gt; &lt;code&gt;dropped&lt;/code&gt; &lt;/a&gt;。返回时，&lt;a href=&quot;membershipkey&quot;&gt; &lt;code&gt;membership-key&lt;/code&gt; &lt;/a&gt;将&lt;a href=&quot;membershipkey#isValid--&quot;&gt; &lt;code&gt;invalid&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a6196d1052cc76b7a767033a57f3c2ef48c6f463" translate="yes" xml:space="preserve">
          <source>If the channel is connected to a remote peer that is bound to multiple addresses then it is these addresses that the channel's socket is connected.</source>
          <target state="translated">如果通道连接的远程对等体绑定了多个地址,那么通道的socket连接的就是这些地址。</target>
        </trans-unit>
        <trans-unit id="fca12487d5034313786755dfdbb1487ee9174606" translate="yes" xml:space="preserve">
          <source>If the channel's key is not already in the selected-key set then it is added to that set and its ready-operation set is modified to identify exactly those operations for which the channel is now reported to be ready. Any readiness information previously recorded in the ready set is discarded.</source>
          <target state="translated">如果通道的密钥还没有在选定的密钥集中,那么它被添加到该集中,它的就绪操作集被修改,以准确地识别那些通道现在被报告为就绪的操作。任何先前记录在就绪集的就绪信息被丢弃。</target>
        </trans-unit>
        <trans-unit id="a74fcb99fe153ea5c299a617e13d7e98b79feb03" translate="yes" xml:space="preserve">
          <source>If the character &lt;code&gt;oldChar&lt;/code&gt; does not occur in the character sequence represented by this &lt;code&gt;String&lt;/code&gt; object, then a reference to this &lt;code&gt;String&lt;/code&gt; object is returned. Otherwise, a &lt;code&gt;String&lt;/code&gt; object is returned that represents a character sequence identical to the character sequence represented by this &lt;code&gt;String&lt;/code&gt; object, except that every occurrence of &lt;code&gt;oldChar&lt;/code&gt; is replaced by an occurrence of &lt;code&gt;newChar&lt;/code&gt;.</source>
          <target state="translated">如果在此 &lt;code&gt;String&lt;/code&gt; 对象表示的字符序列中未出现字符 &lt;code&gt;oldChar&lt;/code&gt; ，则返回对此 &lt;code&gt;String&lt;/code&gt; 对象的引用。否则，将返回一个 &lt;code&gt;String&lt;/code&gt; 对象，该对象表示一个与此 &lt;code&gt;String&lt;/code&gt; 对象表示的字符序列相同的字符序列，只是每次出现的 &lt;code&gt;oldChar&lt;/code&gt; 都会替换为出现的 &lt;code&gt;newChar&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2356291f03c93e71b96f7a671fd497dc56ec73d3" translate="yes" xml:space="preserve">
          <source>If the character defined by the mnemonic is found within the button's label string, the first occurrence of it will be underlined to indicate the mnemonic to the user.</source>
          <target state="translated">如果在按钮的标签字符串中发现了由记忆符定义的字符,那么第一次出现的字符将以下划线的方式向用户表明该记忆符。</target>
        </trans-unit>
        <trans-unit id="7e2733b75e92ebe16a2ce70438529de312b56641" translate="yes" xml:space="preserve">
          <source>If the character does not have a numeric value, then -1 is returned. If the character has a numeric value that cannot be represented as a nonnegative integer (for example, a fractional value), then -2 is returned.</source>
          <target state="translated">如果该字符没有数值,则返回-1.如果该字符的数值不能用非负整数表示,则返回-2。如果字符的数值不能用非负整数表示(例如,分数值),则返回-2。</target>
        </trans-unit>
        <trans-unit id="a94e7ca6896af3627bbb39f5e579611a67b2ce91" translate="yes" xml:space="preserve">
          <source>If the characteristic &lt;code&gt;IDENTITY_FINISH&lt;/code&gt; is set, this function may be presumed to be an identity transform with an unchecked cast from &lt;code&gt;A&lt;/code&gt; to &lt;code&gt;R&lt;/code&gt;.</source>
          <target state="translated">如果设置了特征 &lt;code&gt;IDENTITY_FINISH&lt;/code&gt; ，则可以假定此函数是从 &lt;code&gt;A&lt;/code&gt; 到 &lt;code&gt;R&lt;/code&gt; 的未经检查的强制转换的身份转换。</target>
        </trans-unit>
        <trans-unit id="1ef817a66adab96584398608e88fbe1d608af344" translate="yes" xml:space="preserve">
          <source>If the characteristic &lt;code&gt;IDENTITY_TRANSFORM&lt;/code&gt; is set, this function may be presumed to be an identity transform with an unchecked cast from &lt;code&gt;A&lt;/code&gt; to &lt;code&gt;R&lt;/code&gt;.</source>
          <target state="translated">如果设置了特征 &lt;code&gt;IDENTITY_TRANSFORM&lt;/code&gt; ，则可以假定此函数为从 &lt;code&gt;A&lt;/code&gt; 到 &lt;code&gt;R&lt;/code&gt; 的未经检查的强制转换的身份转换。</target>
        </trans-unit>
        <trans-unit id="8a0ae11bb0853d1ee68bf0914e7935640792833e" translate="yes" xml:space="preserve">
          <source>If the check box argument is &lt;code&gt;null&lt;/code&gt;, all check boxes in this check box group are deselected. If the check box argument belongs to a different check box group, this method does nothing.</source>
          <target state="translated">如果checkbox参数为 &lt;code&gt;null&lt;/code&gt; ，则取消选中此复选框组中的所有复选框。如果复选框参数属于另一个复选框组，则此方法不执行任何操作。</target>
        </trans-unit>
        <trans-unit id="497068c1a55f2d965c9c1d485ba0e4ac4c0bfb03" translate="yes" xml:space="preserve">
          <source>If the check fails we throw a SecurityException, otherwise we return normally.</source>
          <target state="translated">如果检查失败,我们会抛出一个SecurityException,否则我们正常返回。</target>
        </trans-unit>
        <trans-unit id="f0f200f54b8913d720a0fc8f80cb58e7fb832b09" translate="yes" xml:space="preserve">
          <source>If the chronology makes active use of eras, such as &lt;code&gt;JapaneseChronology&lt;/code&gt; then the year-of-era will be validated against the era. For other chronologies, validation is optional.</source>
          <target state="translated">如果时间顺序积极使用了诸如 &lt;code&gt;JapaneseChronology&lt;/code&gt; 时间顺序之类的时代，那么将根据该时代对年份进行验证。对于其他年代，验证是可选的。</target>
        </trans-unit>
        <trans-unit id="907a36ef0b6c060f7a9d6a76251b166f6ce74a74" translate="yes" xml:space="preserve">
          <source>If the class can successfully be loaded, an attempt will be made to create an instance of it by calling &lt;code&gt;Class.newInstance&lt;/code&gt;. An attempt will be made to narrow the instance to type &lt;code&gt;java.awt.Component&lt;/code&gt; to display the object.</source>
          <target state="translated">如果可以成功加载该类，则将尝试通过调用 &lt;code&gt;Class.newInstance&lt;/code&gt; 创建它的实例。将尝试缩小实例的范围，以键入 &lt;code&gt;java.awt.Component&lt;/code&gt; 来显示对象。</target>
        </trans-unit>
        <trans-unit id="993043b6674c4a35b36d9c742df1bbfe992c7c06" translate="yes" xml:space="preserve">
          <source>If the class has several constructors, &lt;a href=&quot;../standardoperation#NEW&quot;&gt;&lt;code&gt;StandardOperation.NEW&lt;/code&gt;&lt;/a&gt; on &lt;code&gt;StaticClass&lt;/code&gt; will try to select the most specific applicable constructor. You might want to expose a mechanism in your language for selecting a constructor with an explicit signature through &lt;a href=&quot;beanslinker#getConstructorMethod(java.lang.Class,java.lang.String)&quot;&gt;&lt;code&gt;BeansLinker.getConstructorMethod(Class, String)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果类有几个构造函数，&lt;a href=&quot;../standardoperation#NEW&quot;&gt; &lt;code&gt;StandardOperation.NEW&lt;/code&gt; &lt;/a&gt;上 &lt;code&gt;StaticClass&lt;/code&gt; 会尽量选择最具体适用的构造。您可能想要公开一种语言，用于通过&lt;a href=&quot;beanslinker#getConstructorMethod(java.lang.Class,java.lang.String)&quot;&gt; &lt;code&gt;BeansLinker.getConstructorMethod(Class, String)&lt;/code&gt; &lt;/a&gt;选择具有显式签名的构造函数的机制。</target>
        </trans-unit>
        <trans-unit id="0c7a6047da53758486c24b6ceb6b4575875d974a" translate="yes" xml:space="preserve">
          <source>If the class implements the interface &lt;a href=&quot;dynamicmbean&quot;&gt;&lt;code&gt;DynamicMBean&lt;/code&gt;&lt;/a&gt; then the MBean is a Dynamic MBean. Note that the class &lt;code&gt;StandardMBean&lt;/code&gt; implements this interface, so this case applies to a Standard MBean or MXBean created using the class &lt;code&gt;StandardMBean&lt;/code&gt;.</source>
          <target state="translated">如果该类实现了&lt;a href=&quot;dynamicmbean&quot;&gt; &lt;code&gt;DynamicMBean&lt;/code&gt; &lt;/a&gt;接口，则MBean是动态MBean。请注意，类 &lt;code&gt;StandardMBean&lt;/code&gt; 实现了此接口，因此，这种情况适用于使用类 &lt;code&gt;StandardMBean&lt;/code&gt; 创建的Standard MBean或MXBean 。</target>
        </trans-unit>
        <trans-unit id="d9ebf03c3837794b9118548515dce9c5eeac747f" translate="yes" xml:space="preserve">
          <source>If the class is &lt;code&gt;VarHandle&lt;/code&gt; and the name string corresponds to the name of a signature-polymorphic access mode method, the resulting method handle is equivalent to one produced by &lt;a href=&quot;methodhandles#varHandleInvoker(java.lang.invoke.VarHandle.AccessMode,java.lang.invoke.MethodType)&quot;&gt;&lt;code&gt;MethodHandles.varHandleInvoker(java.lang.invoke.VarHandle.AccessMode, java.lang.invoke.MethodType)&lt;/code&gt;&lt;/a&gt; with the access mode corresponding to the name string and with the same &lt;code&gt;type&lt;/code&gt; arguments.</source>
          <target state="translated">如果该类是 &lt;code&gt;VarHandle&lt;/code&gt; ，并且名称字符串对应于签名多态访问模式方法的名称，则结果方法句柄等效于&lt;a href=&quot;methodhandles#varHandleInvoker(java.lang.invoke.VarHandle.AccessMode,java.lang.invoke.MethodType)&quot;&gt; &lt;code&gt;MethodHandles.varHandleInvoker(java.lang.invoke.VarHandle.AccessMode, java.lang.invoke.MethodType)&lt;/code&gt; &lt;/a&gt;具有对应于名称字符串和相同 &lt;code&gt;type&lt;/code&gt; 参数的访问模式的invoke.MethodType）。</target>
        </trans-unit>
        <trans-unit id="3b8178b28745cbf9a8c356b7ccd5c7490b446121" translate="yes" xml:space="preserve">
          <source>If the class is successfully loaded from the &lt;code&gt;defaultLoader&lt;/code&gt;, that class is returned. If an exception other than &lt;code&gt;ClassNotFoundException&lt;/code&gt; is thrown, that exception is thrown to the caller.</source>
          <target state="translated">如果从 &lt;code&gt;defaultLoader&lt;/code&gt; 成功加载了该类，则返回该类。如果引发了 &lt;code&gt;ClassNotFoundException&lt;/code&gt; 以外的其他异常，则该异常将引发给调用者。</target>
        </trans-unit>
        <trans-unit id="7d4839c4011be06ed972a50b4707c4c87c520b22" translate="yes" xml:space="preserve">
          <source>If the class loader is a &lt;a href=&quot;classloader#builtinLoaders&quot;&gt; built-in class loader&lt;/a&gt; or is not named then the first element and its following &lt;code&gt;&quot;/&quot;&lt;/code&gt; are omitted as shown in &quot;&lt;code&gt;acme@2.1/org.acme.Lib.test(Lib.java:80)&lt;/code&gt;&quot;. If the first element is omitted and the module is an unnamed module, the second element and its following &lt;code&gt;&quot;/&quot;&lt;/code&gt; are also omitted as shown in &quot;&lt;code&gt;MyClass.mash(MyClass.java:9)&lt;/code&gt;&quot;.</source>
          <target state="translated">如果类加载器是&lt;a href=&quot;classloader#builtinLoaders&quot;&gt;内置类加载器&lt;/a&gt;或未命名，则省略第一个元素及其 &lt;code&gt;acme@2.1/org.acme.Lib.test(Lib.java:80)&lt;/code&gt; &lt;code&gt;&quot;/&quot;&lt;/code&gt; ，如&amp;ldquo; acme@2.1/org.acme.Lib.test（Lib.java:80） &amp;rdquo;所示。 。如果省略第一个元素，并且模块是未命名的模块，则也将省略第二个元素及其后跟的 &lt;code&gt;&quot;/&quot;&lt;/code&gt; ，如&amp;ldquo; &lt;code&gt;MyClass.mash(MyClass.java:9)&lt;/code&gt; &amp;rdquo;所示。</target>
        </trans-unit>
        <trans-unit id="4a4555f48b556983b593c81b2e7a7b846ff92e83" translate="yes" xml:space="preserve">
          <source>If the class loader is the system class loader (see &lt;a href=&quot;../../../../java.base/java/lang/classloader#getSystemClassLoader()&quot;&gt;&lt;code&gt;ClassLoader.getSystemClassLoader()&lt;/code&gt;&lt;/a&gt;), a parent of the system class loader such as the loader used for installed extensions, or the bootstrap class loader (which may be represented by &lt;code&gt;null&lt;/code&gt;), then the value of the &lt;code&gt;&lt;span id=&quot;java.rmi.server.codebase&quot;&gt;java.rmi.server.codebase&lt;/span&gt;&lt;/code&gt; property (or possibly an earlier cached value) is returned, or &lt;code&gt;null&lt;/code&gt; is returned if that property is not set.</source>
          <target state="translated">如果类加载器是系统类加载器（请参见&lt;a href=&quot;../../../../java.base/java/lang/classloader#getSystemClassLoader()&quot;&gt; &lt;code&gt;ClassLoader.getSystemClassLoader()&lt;/code&gt; &lt;/a&gt;），系统类加载器的父级（例如用于已安装扩展的加载器）或引导类加载器（可能由 &lt;code&gt;null&lt;/code&gt; 表示），则返回 &lt;code&gt;&lt;span id=&quot;java.rmi.server.codebase&quot;&gt;java.rmi.server.codebase&lt;/span&gt;&lt;/code&gt; 属性的值（或者可能是更早的缓存值），如果未设置该属性，则返回 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="572e2e8607da1aaa832eee294d600cd0b74c2f51" translate="yes" xml:space="preserve">
          <source>If the class loader is the system class loader (see &lt;a href=&quot;../../../../java.base/java/lang/classloader#getSystemClassLoader()&quot;&gt;&lt;code&gt;ClassLoader.getSystemClassLoader()&lt;/code&gt;&lt;/a&gt;), a parent of the system class loader such as the loader used for installed extensions, or the bootstrap class loader (which may be represented by &lt;code&gt;null&lt;/code&gt;), then the value of the &lt;code&gt;java.rmi.server.codebase&lt;/code&gt; property (or possibly an earlier cached value) is returned, or &lt;code&gt;null&lt;/code&gt; is returned if that property is not set.</source>
          <target state="translated">如果类加载器是系统类加载器（请参见&lt;a href=&quot;../../../../java.base/java/lang/classloader#getSystemClassLoader()&quot;&gt; &lt;code&gt;ClassLoader.getSystemClassLoader()&lt;/code&gt; &lt;/a&gt;），系统类加载器的父级（例如用于已安装扩展的加载器）或引导类加载器（可能由 &lt;code&gt;null&lt;/code&gt; 表示），则返回 &lt;code&gt;java.rmi.server.codebase&lt;/code&gt; 属性的值（或者可能是更早的缓存值），如果未设置该属性，则返回 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="18dfc6c9d8012fcb4afd5d4cd53b47b6e173ddd4" translate="yes" xml:space="preserve">
          <source>If the class loader of the given module defines other modules and the given name is a class defined in a different module, this method returns &lt;code&gt;null&lt;/code&gt; after the class is loaded.</source>
          <target state="translated">如果给定模块的类加载器定义了其他模块，并且给定名称是在其他模块中定义的类，则在加载该类后，此方法返回 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e1700f5a5e32f3348ed050e68e0d59e005f7128b" translate="yes" xml:space="preserve">
          <source>If the class or interface is &lt;a href=&quot;#isHidden()&quot;&gt;hidden&lt;/a&gt;, then the result is a string of the form:</source>
          <target state="translated">如果该类或接口是&lt;a href=&quot;#isHidden()&quot;&gt;hidden&lt;/a&gt;，则结果是以下形式的字符串：</target>
        </trans-unit>
        <trans-unit id="7320eb1655071247a7cb27de5cad18feb2e575d5" translate="yes" xml:space="preserve">
          <source>If the class or interface is hidden, then the result is a string of the form: &lt;code&gt;N + '/' + &amp;lt;suffix&amp;gt;&lt;/code&gt; where &lt;code&gt;N&lt;/code&gt; is the &lt;a href=&quot;classloader#binary-name&quot;&gt;binary name&lt;/a&gt; indicated by the &lt;code&gt;class&lt;/code&gt; file passed to &lt;a href=&quot;invoke/methodhandles.lookup#defineHiddenClass(byte%5B%5D,boolean,java.lang.invoke.MethodHandles.Lookup.ClassOption...)&quot;&gt;&lt;code&gt;Lookup::defineHiddenClass&lt;/code&gt;&lt;/a&gt;, and &lt;code&gt;&amp;lt;suffix&amp;gt;&lt;/code&gt; is an unqualified name.</source>
          <target state="translated">如果隐藏了类或接口，则结果是以下形式的字符串： &lt;code&gt;N + '/' + &amp;lt;suffix&amp;gt;&lt;/code&gt; 其中 &lt;code&gt;N&lt;/code&gt; 是传递给&lt;a href=&quot;invoke/methodhandles.lookup#defineHiddenClass(byte%5B%5D,boolean,java.lang.invoke.MethodHandles.Lookup.ClassOption...)&quot;&gt; &lt;code&gt;Lookup::defineHiddenClass&lt;/code&gt; &lt;/a&gt;的 &lt;code&gt;class&lt;/code&gt; 文件指示的&lt;a href=&quot;classloader#binary-name&quot;&gt;二进制名称&lt;/a&gt;，而 &lt;code&gt;&amp;lt;suffix&amp;gt;&lt;/code&gt; 是不合格的名称。</target>
        </trans-unit>
        <trans-unit id="647c68d85ca3579e0c43d0d82206a9ec49464973" translate="yes" xml:space="preserve">
          <source>If the class or interface is not &lt;a href=&quot;#isHidden()&quot;&gt;hidden&lt;/a&gt;, then the &lt;a href=&quot;classloader#binary-name&quot;&gt;binary name&lt;/a&gt; of the class or interface is returned.</source>
          <target state="translated">如果该类或接口未&lt;a href=&quot;#isHidden()&quot;&gt;隐藏&lt;/a&gt;，则返回该类或接口的&lt;a href=&quot;classloader#binary-name&quot;&gt;二进制名称&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8ad83fe743eecc6f15470c8181d8587012fcdace" translate="yes" xml:space="preserve">
          <source>If the class or interface is not &lt;a href=&quot;#isHidden()&quot;&gt;hidden&lt;/a&gt;, then the result is a field descriptor (JVMS &lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se15/html/jvms-4.html#jls-4.3.2&quot;&gt;4.3.2&lt;/a&gt;) for the class or interface. Calling &lt;a href=&quot;constant/classdesc#ofDescriptor(java.lang.String)&quot;&gt;&lt;code&gt;ClassDesc::ofDescriptor&lt;/code&gt;&lt;/a&gt; with the result descriptor string produces a &lt;a href=&quot;constant/classdesc&quot;&gt;&lt;code&gt;ClassDesc&lt;/code&gt;&lt;/a&gt; describing this class or interface.</source>
          <target state="translated">如果未&lt;a href=&quot;#isHidden()&quot;&gt;隐藏&lt;/a&gt;该类或接口，则结果是该类或接口的字段描述符（JVMS &lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se15/html/jvms-4.html#jls-4.3.2&quot;&gt;4.3.2&lt;/a&gt;）。用结果描述符字符串调用&lt;a href=&quot;constant/classdesc#ofDescriptor(java.lang.String)&quot;&gt; &lt;code&gt;ClassDesc::ofDescriptor&lt;/code&gt; &lt;/a&gt;会生成描述该类或接口的&lt;a href=&quot;constant/classdesc&quot;&gt; &lt;code&gt;ClassDesc&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b6cbdce4f03e8864e2078a8ebda20df5d53693b1" translate="yes" xml:space="preserve">
          <source>If the class or interface represented by this &lt;code&gt;Class&lt;/code&gt; object is a member of another class, returns the &lt;code&gt;Class&lt;/code&gt; object representing the class in which it was declared.</source>
          <target state="translated">如果由此 &lt;code&gt;Class&lt;/code&gt; 对象表示的类或接口是另一个类的成员，则返回表示在其中声明该类的类的 &lt;code&gt;Class&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="952c977645377144d1e9387499dba9c6a0e6f790" translate="yes" xml:space="preserve">
          <source>If the class or interface represented by this &lt;code&gt;Class&lt;/code&gt; object is a member of another class, returns the &lt;code&gt;Class&lt;/code&gt; object representing the class in which it was declared. This method returns null if this class or interface is not a member of any other class. If this &lt;code&gt;Class&lt;/code&gt; object represents an array class, a primitive type, or void,then this method returns null.</source>
          <target state="translated">如果此 &lt;code&gt;Class&lt;/code&gt; 对象表示的类或接口是另一个类的成员，则返回表示在其中声明该类的类的 &lt;code&gt;Class&lt;/code&gt; 对象。如果此类或接口不是任何其他类的成员，则此方法返回null。如果此 &lt;code&gt;Class&lt;/code&gt; 对象表示数组类，原始类型或void，则此方法返回null。</target>
        </trans-unit>
        <trans-unit id="c4b1d6d0e3e6bf78e4579733a8155fce8794f591" translate="yes" xml:space="preserve">
          <source>If the class path of the class loader includes remote network URLs then those URLs may be dereferenced in the process of searching for provider-configuration files.</source>
          <target state="translated">如果类加载器的类路径包括远程网络URL,那么在搜索提供者配置文件的过程中,这些URL可能会被重新引用。</target>
        </trans-unit>
        <trans-unit id="5149c7a2ea949082634b5eade9a189fb43ba3574" translate="yes" xml:space="preserve">
          <source>If the class pointed to by the property cannot be loaded, or does not correspond to a valid subclass of MBeanServerBuilder then an exception is propagated, and no MBeanServer can be created until the &lt;b&gt;javax.management.builder.initial&lt;/b&gt; system property is reset to valid value.</source>
          <target state="translated">如果无法加载由该属性指向的类，或者该类不对应于MBeanServerBuilder的有效子类，则将传播异常，并且在将&lt;b&gt;javax.management.builder.initial&lt;/b&gt;系统属性重置为有效值之前，无法创建MBeanServer。。</target>
        </trans-unit>
        <trans-unit id="255675b731bcc7202d59daefb4cbc3dbea4fde7b" translate="yes" xml:space="preserve">
          <source>If the class was found using the above steps, and the &lt;code&gt;resolve&lt;/code&gt; flag is true, this method will then invoke the &lt;a href=&quot;#resolveClass(java.lang.Class)&quot;&gt;&lt;code&gt;resolveClass(Class)&lt;/code&gt;&lt;/a&gt; method on the resulting &lt;code&gt;Class&lt;/code&gt; object.</source>
          <target state="translated">如果使用上述步骤找到了该类，并且 &lt;code&gt;resolve&lt;/code&gt; 标志为true，则此方法将在所得的 &lt;code&gt;Class&lt;/code&gt; 对象上调用&lt;a href=&quot;#resolveClass(java.lang.Class)&quot;&gt; &lt;code&gt;resolveClass(Class)&lt;/code&gt; &lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="a48f463646ddc67b0927be2d8f5a0d7e6779ec57" translate="yes" xml:space="preserve">
          <source>If the class was found using the above steps, and the &lt;code&gt;resolve&lt;/code&gt; flag is true, this method will then invoke the &lt;a href=&quot;classloader#resolveClass-java.lang.Class-&quot;&gt;&lt;code&gt;resolveClass(Class)&lt;/code&gt;&lt;/a&gt; method on the resulting &lt;code&gt;Class&lt;/code&gt; object.</source>
          <target state="translated">如果使用上述步骤找到了该类，并且 &lt;code&gt;resolve&lt;/code&gt; 标志为true，则此方法将在所得的 &lt;code&gt;Class&lt;/code&gt; 对象上调用&lt;a href=&quot;classloader#resolveClass-java.lang.Class-&quot;&gt; &lt;code&gt;resolveClass(Class)&lt;/code&gt; &lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="003444596c67295858def4a629af62005e80f04a" translate="yes" xml:space="preserve">
          <source>If the client does not specify a &lt;code&gt;JobPriority&lt;/code&gt; attribute for a Print Job and the printer does support the JobPriority attribute, the printer must use an implementation-defined default JobPriority value.</source>
          <target state="translated">如果客户端未为打印作业指定 &lt;code&gt;JobPriority&lt;/code&gt; 属性，并且打印机确实支持JobPriority属性，则打印机必须使用实现定义的默认JobPriority值。</target>
        </trans-unit>
        <trans-unit id="0cb1171375f133959d5fe66bf3b2a054030b8896" translate="yes" xml:space="preserve">
          <source>If the client does not specify a JobPriority attribute for a Print Job and the printer does support the JobPriority attribute, the printer must use an implementation-defined default JobPriority value.</source>
          <target state="translated">如果客户端没有为打印任务指定JobPriority属性,而打印机支持JobPriority属性,则打印机必须使用执行中定义的默认JobPriority值。</target>
        </trans-unit>
        <trans-unit id="3d048044cc6cddb0cf0dbc1da3f8b399bcca1c52" translate="yes" xml:space="preserve">
          <source>If the client does not supply this attribute in a Print Request and the printer supports this attribute, the printer must use its (implementation-dependent) default &lt;code&gt;JobHoldUntil&lt;/code&gt; value at job submission time (unlike most job template attributes that are used if necessary at job processing time).</source>
          <target state="translated">如果客户端未在&amp;ldquo;打印请求&amp;rdquo;中提供此属性，并且打印机支持此属性，则打印机必须在作业提交时使用其（取决于实现）默认 &lt;code&gt;JobHoldUntil&lt;/code&gt; 值（与大多数作业模板属性不同，该属性在作业处理时需要使用）时间）。</target>
        </trans-unit>
        <trans-unit id="8819695d5b9293144506d78213d046dbf29c7943" translate="yes" xml:space="preserve">
          <source>If the client does not supply this attribute in a Print Request and the printer supports this attribute, the printer must use its (implementation-dependent) default JobHoldUntil value at job submission time (unlike most job template attributes that are used if necessary at job processing time).</source>
          <target state="translated">如果客户端没有在打印请求中提供该属性,而打印机支持该属性,则打印机必须在作业提交时使用其(依赖于实施的)默认JobHoldUntil值(与大多数作业模板属性不同,这些属性在作业处理时需要使用)。</target>
        </trans-unit>
        <trans-unit id="b95b0051a1d9e6aeda4cecd24f2f226586dceb7a" translate="yes" xml:space="preserve">
          <source>If the column class as returned by &lt;code&gt;getColumnClass&lt;/code&gt; is &lt;code&gt;String&lt;/code&gt;, use the &lt;code&gt;Comparator&lt;/code&gt; returned by &lt;code&gt;Collator.getInstance()&lt;/code&gt;.</source>
          <target state="translated">如果由返回的柱类 &lt;code&gt;getColumnClass&lt;/code&gt; 是 &lt;code&gt;String&lt;/code&gt; ，可使用 &lt;code&gt;Comparator&lt;/code&gt; 返回的由 &lt;code&gt;Collator.getInstance()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1d2bea1ba481bf3017c0de86b5926674c8b57a55" translate="yes" xml:space="preserve">
          <source>If the column class implements &lt;code&gt;Comparable&lt;/code&gt;, use a &lt;code&gt;Comparator&lt;/code&gt; that invokes the &lt;code&gt;compareTo&lt;/code&gt; method.</source>
          <target state="translated">如果列类实现 &lt;code&gt;Comparable&lt;/code&gt; ，则使用一个 &lt;code&gt;Comparator&lt;/code&gt; 来调用 &lt;code&gt;compareTo&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="425608db615fcee29a758153b3f2f63df2fa7cde" translate="yes" xml:space="preserve">
          <source>If the column index is valid but the row index is less than zero the method returns a rectangle with the &lt;code&gt;y&lt;/code&gt; and &lt;code&gt;height&lt;/code&gt; values set appropriately and the &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;width&lt;/code&gt; values both set to zero. In general, when either the row or column indices indicate a cell outside the appropriate range, the method returns a rectangle depicting the closest edge of the closest cell that is within the table's range. When both row and column indices are out of range the returned rectangle covers the closest point of the closest cell.</source>
          <target state="translated">如果列索引有效，但行索引小于零，则该方法将返回一个矩形，该矩形的 &lt;code&gt;y&lt;/code&gt; 和 &lt;code&gt;height&lt;/code&gt; 值均设置为适当，而 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;width&lt;/code&gt; 值均设置为零。通常，当行或列索引指示某个单元格超出适当范围时，该方法将返回一个矩形，该矩形描述表范围内最近单元格的最近边缘。当行和列索引都超出范围时，返回的矩形将覆盖最近的单元格的最近点。</target>
        </trans-unit>
        <trans-unit id="6f068094c0b9101658e1bd4638d11b46b0682d00" translate="yes" xml:space="preserve">
          <source>If the combiner has a void return, no result will be inserted, and the first &lt;code&gt;N&lt;/code&gt; parameter types of the target must exactly match the parameters of the combiner.</source>
          <target state="translated">如果组合器的返回值无效，则不会插入任何结果，并且目标的前 &lt;code&gt;N&lt;/code&gt; 个参数类型必须与组合器的参数完全匹配。</target>
        </trans-unit>
        <trans-unit id="7bd33812eb44d59d69e1fa86993dc6c1b417f658" translate="yes" xml:space="preserve">
          <source>If the combiner returns a value, the first parameter type of the target must be identical with the return type of the combiner, and the next &lt;code&gt;N&lt;/code&gt; parameter types of the target must exactly match the parameters of the combiner.</source>
          <target state="translated">如果组合器返回一个值，则目标的第一个参数类型必须与组合器的返回类型相同，并且目标的后 &lt;code&gt;N&lt;/code&gt; 个参数类型必须与组合器的参数完全匹配。</target>
        </trans-unit>
        <trans-unit id="2a835e3176ef9901dbf657a51a0dc111ab329f96" translate="yes" xml:space="preserve">
          <source>If the combo box is editable, then this value may not have been added to the combo box with &lt;code&gt;addItem&lt;/code&gt;, &lt;code&gt;insertItemAt&lt;/code&gt; or the data constructors.</source>
          <target state="translated">如果组合框是可编辑的，则可能尚未使用 &lt;code&gt;addItem&lt;/code&gt; ， &lt;code&gt;insertItemAt&lt;/code&gt; 或数据构造函数将此值添加到组合框。</target>
        </trans-unit>
        <trans-unit id="f746d1a0f0f5d1b71eddaef84d93690d98f495a0" translate="yes" xml:space="preserve">
          <source>If the comment is present (not null) it is written, otherwise an an empty comment is written</source>
          <target state="translated">如果评论存在(不是空的),就会被写入,否则就会写入一个空的评论。</target>
        </trans-unit>
        <trans-unit id="700d0c6d66bdf7dd366a71fc298f1463af466dfa" translate="yes" xml:space="preserve">
          <source>If the comments argument is not null, then an ASCII &lt;code&gt;#&lt;/code&gt; character, the comments string, and a line separator are first written to the output stream. Thus, the &lt;code&gt;comments&lt;/code&gt; can serve as an identifying comment. Any one of a line feed ('\n'), a carriage return ('\r'), or a carriage return followed immediately by a line feed in comments is replaced by a line separator generated by the &lt;code&gt;Writer&lt;/code&gt; and if the next character in comments is not character &lt;code&gt;#&lt;/code&gt; or character &lt;code&gt;!&lt;/code&gt; then an ASCII &lt;code&gt;#&lt;/code&gt; is written out after that line separator.</source>
          <target state="translated">如果comment参数不为null，则首先将ASCII &lt;code&gt;#&lt;/code&gt; 字符，注释字符串和行分隔符写入输出流。因此， &lt;code&gt;comments&lt;/code&gt; 可以用作识别评论。换行符（'\ n'），回车符（'\ r'）或回车符后紧接着注释中的换行符中的任何一个均由 &lt;code&gt;Writer&lt;/code&gt; 生成的换行符替换，如果下一个字符在注释中不是字符 &lt;code&gt;#&lt;/code&gt; 或字符 &lt;code&gt;!&lt;/code&gt; 然后在该行分隔符之后写出ASCII &lt;code&gt;#&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d734df054f4a2c1ef528f0ad746950c442305d2a" translate="yes" xml:space="preserve">
          <source>If the component doesn't have composed text, the offset should be ignored, and the location returned should reflect the beginning (in line direction) of the highlight in the last line containing selected text. For example, for horizontal left-to-right text (such as English), the location to the left of the left-most character on the last line containing selected text is returned. For vertical top-to-bottom text, with lines proceeding from right to left, the location to the top of the left-most line containing selected text is returned.</source>
          <target state="translated">如果该组件没有组成的文本,则应忽略偏移量,返回的位置应反映包含所选文本的最后一行中高亮部分的开始(按行方向)。例如,对于从左到右的水平文本(如英文),返回包含所选文本的最后一行中最左边的字符的位置。对于垂直的从上到下的文本,从右到左的行,返回包含所选文本的最左行的顶部位置。</target>
        </trans-unit>
        <trans-unit id="52458478773761d2bba8b8c640a23a52fc2877dc" translate="yes" xml:space="preserve">
          <source>If the component has composed text (because the most recent InputMethodEvent sent to it contained composed text), then the offset is relative to the composed text - offset 0 indicates the first character in the composed text. The location returned should be for this character.</source>
          <target state="translated">如果该组件有合成文本(因为最近向其发送的InputMethodEvent包含合成文本),那么偏移量是相对于合成文本而言的--偏移量0表示合成文本中的第一个字符。返回的位置应该是这个字符的位置。</target>
        </trans-unit>
        <trans-unit id="fa083a799f0c4b27fbcd704b725195417a71c40c" translate="yes" xml:space="preserve">
          <source>If the component is &lt;code&gt;null&lt;/code&gt;, or the &lt;code&gt;
 GraphicsConfiguration&lt;/code&gt; associated with this component is &lt;code&gt;null&lt;/code&gt;, the window is placed in the center of the screen. The center point can be obtained with the &lt;a href=&quot;graphicsenvironment#getCenterPoint()&quot;&gt;&lt;code&gt;GraphicsEnvironment.getCenterPoint&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">如果该组件为 &lt;code&gt;null&lt;/code&gt; ，或者与此组件关联的 &lt;code&gt; GraphicsConfiguration&lt;/code&gt; 为 &lt;code&gt;null&lt;/code&gt; ，则该窗口将放置在屏幕的中央。中心点可以使用&lt;a href=&quot;graphicsenvironment#getCenterPoint()&quot;&gt; &lt;code&gt;GraphicsEnvironment.getCenterPoint&lt;/code&gt; &lt;/a&gt;方法获得。</target>
        </trans-unit>
        <trans-unit id="0dd6f4c457146450ded7e20b80ac380bbab18e53" translate="yes" xml:space="preserve">
          <source>If the component is a child of some other container, it is removed from that container before being added to this container. The important difference between this method and &lt;code&gt;java.awt.Container.add(Component, int)&lt;/code&gt; is that this method doesn't call &lt;code&gt;removeNotify&lt;/code&gt; on the component while removing it from its previous container unless necessary and when allowed by the underlying native windowing system. This way, if the component has the keyboard focus, it maintains the focus when moved to the new position.</source>
          <target state="translated">如果该组件是其他某个容器的子组件，则在将其添加到该容器之前将其从该容器中删除。此方法与 &lt;code&gt;java.awt.Container.add(Component, int)&lt;/code&gt; 之间的重要区别在于，除非从底层容器窗口系统中移除了必要的方法，否则此方法在从其先前容器中移除组件时不会在组件上调用 &lt;code&gt;removeNotify&lt;/code&gt; 。这样，如果组件具有键盘焦点，则当移动到新位置时它将保持焦点。</target>
        </trans-unit>
        <trans-unit id="9f28aca33e4b7d20b3d3eab00c327afedf0feed4" translate="yes" xml:space="preserve">
          <source>If the component is marked as opaque, the background is painted in the current background color of the component.</source>
          <target state="translated">如果组件被标记为不透明,则背景将以组件当前的背景颜色绘制。</target>
        </trans-unit>
        <trans-unit id="49528cc920475018bcff626e6ad10c005e36e46d" translate="yes" xml:space="preserve">
          <source>If the component is not &lt;code&gt;null&lt;/code&gt; and is shown on the screen, then the window is located in such a way that the center of the window coincides with the center of the component.</source>
          <target state="translated">如果组件不为 &lt;code&gt;null&lt;/code&gt; 并且显示在屏幕上，则窗口的位置应使窗口的中心与组件的中心重合。</target>
        </trans-unit>
        <trans-unit id="5eda8ad7764dbe33c30b572a11e1b1539c4e718f" translate="yes" xml:space="preserve">
          <source>If the component is not &lt;code&gt;null&lt;/code&gt;, but it is not currently showing, the window is placed in the center of the target screen defined by the &lt;code&gt;
 GraphicsConfiguration&lt;/code&gt; associated with this component.</source>
          <target state="translated">如果该组件不为 &lt;code&gt;null&lt;/code&gt; ，但当前未显示，则该窗口将放置在与此组件关联的 &lt;code&gt; GraphicsConfiguration&lt;/code&gt; 定义的目标屏幕的中心。</target>
        </trans-unit>
        <trans-unit id="f9fde55638308a4ea2d10d2c4b49e0eee2a91067" translate="yes" xml:space="preserve">
          <source>If the component is not an ancestor of this container and has a non-null parent, it is removed from its current parent before it is added to this container.</source>
          <target state="translated">如果组件不是这个容器的祖先,并且有一个非空的父体,那么在它被添加到这个容器之前,它就会从它的当前父体中移除。</target>
        </trans-unit>
        <trans-unit id="a58ff69484b85d5dedc93ea849fe6dfb636f6bc6" translate="yes" xml:space="preserve">
          <source>If the component is of a primitive type, using the corresponding primitive wrapper class &lt;code&gt;PW&lt;/code&gt; (the corresponding wrapper class for &lt;code&gt;int&lt;/code&gt; is &lt;code&gt;
 java.lang.Integer&lt;/code&gt;, and so on), the component is considered equal if and only if &lt;code&gt;
 PW.valueOf(this.c()).equals(PW.valueOf(r.c()))&lt;/code&gt; would return &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">如果组件是原始类型，则使用相应的原始包装器类 &lt;code&gt;PW&lt;/code&gt; （ &lt;code&gt;int&lt;/code&gt; 的相应包装器类是 &lt;code&gt; java.lang.Integer&lt;/code&gt; ，依此类推），则当且仅当 &lt;code&gt; PW.valueOf(this.c()).equals(PW.valueOf(r.c()))&lt;/code&gt; 将返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="767273f6356c7f1819c424c6f45b8a2226912dcd" translate="yes" xml:space="preserve">
          <source>If the component is of a reference type, the component is considered equal if and only if &lt;a href=&quot;../util/objects#equals(java.lang.Object,java.lang.Object)&quot;&gt;&lt;code&gt;Objects.equals(this.c(), r.c()&lt;/code&gt;&lt;/a&gt; would return &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">如果组件是引用类型，则仅当&lt;a href=&quot;../util/objects#equals(java.lang.Object,java.lang.Object)&quot;&gt; &lt;code&gt;Objects.equals(this.c(), r.c()&lt;/code&gt; &lt;/a&gt;返回 &lt;code&gt;true&lt;/code&gt; 时，该组件才被视为相等。</target>
        </trans-unit>
        <trans-unit id="a8a4141d2aef13471dd4a0e737c385e9dc0e5ad9" translate="yes" xml:space="preserve">
          <source>If the component type is &lt;code&gt;float&lt;/code&gt; or &lt;code&gt;double&lt;/code&gt; then numeric and atomic update access modes compare values using their bitwise representation (see &lt;a href=&quot;../float#floatToRawIntBits(float)&quot;&gt;&lt;code&gt;Float.floatToRawIntBits(float)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../double#doubleToRawLongBits(double)&quot;&gt;&lt;code&gt;Double.doubleToRawLongBits(double)&lt;/code&gt;&lt;/a&gt;, respectively).</source>
          <target state="translated">如果组件类型是 &lt;code&gt;float&lt;/code&gt; 或 &lt;code&gt;double&lt;/code&gt; ,则数字和原子更新访问模式将使用其按位表示形式比较值（分别参见&lt;a href=&quot;../float#floatToRawIntBits(float)&quot;&gt; &lt;code&gt;Float.floatToRawIntBits(float)&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../double#doubleToRawLongBits(double)&quot;&gt; &lt;code&gt;Double.doubleToRawLongBits(double)&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="2c31ff2ad53aa80158077167d3c0952e042633e3" translate="yes" xml:space="preserve">
          <source>If the compression level is changed, the next invocation of &lt;code&gt;deflate&lt;/code&gt; will compress the input available so far with the old level (and may be flushed); the new level will take effect only after that invocation.</source>
          <target state="translated">如果更改了压缩级别，则 &lt;code&gt;deflate&lt;/code&gt; 的下一次调用将使用旧级别压缩到目前为止可用的输入（并且可能会被刷新）；新级别仅在该调用之后生效。</target>
        </trans-unit>
        <trans-unit id="392c53482c9474c39ea6e8d51c4ff85e2db64e08" translate="yes" xml:space="preserve">
          <source>If the compression strategy is changed, the next invocation of &lt;code&gt;deflate&lt;/code&gt; will compress the input available so far with the old strategy (and may be flushed); the new strategy will take effect only after that invocation.</source>
          <target state="translated">如果更改了压缩策略，则 &lt;code&gt;deflate&lt;/code&gt; 的下一次调用将使用旧的策略压缩到目前为止可用的输入（并且可能被刷新）；新策略仅在该调用之后才生效。</target>
        </trans-unit>
        <trans-unit id="8e9497f125d07fc51b01287bbc25b0587bcf8337" translate="yes" xml:space="preserve">
          <source>If the configuration entry for &lt;code&gt;KerberosLoginModule&lt;/code&gt; has the option &lt;code&gt;storeKey&lt;/code&gt; set to true, then &lt;code&gt;KerberosKey&lt;/code&gt; or &lt;code&gt;KeyTab&lt;/code&gt; will also be added to the subject's private credentials. &lt;code&gt;KerberosKey&lt;/code&gt;, the principal's key(s) will be derived from user's password, and &lt;code&gt;KeyTab&lt;/code&gt; is the keytab used when &lt;code&gt;useKeyTab&lt;/code&gt; is set to true. The &lt;code&gt;KeyTab&lt;/code&gt; object is restricted to be used by the specified principal unless the principal value is &quot;*&quot;.</source>
          <target state="translated">如果 &lt;code&gt;KerberosLoginModule&lt;/code&gt; 的配置条目的 &lt;code&gt;storeKey&lt;/code&gt; 选项设置为true，则 &lt;code&gt;KerberosKey&lt;/code&gt; 或 &lt;code&gt;KeyTab&lt;/code&gt; 也将添加到主题的专用凭据中。 &lt;code&gt;KerberosKey&lt;/code&gt; ，主体的密钥将从用户的密码派生而来， &lt;code&gt;KeyTab&lt;/code&gt; 是将 &lt;code&gt;useKeyTab&lt;/code&gt; 设置为true时使用的密钥表。该 &lt;code&gt;KeyTab&lt;/code&gt; 对象被限制为通过指定的主体一起使用，除非主值是&amp;ldquo;*&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="83fc6066134ba11a7853023c02cbbfe0403e55b4" translate="yes" xml:space="preserve">
          <source>If the connection is already closed then invoking this method has no effect. After a connection is closed, any further attempt calls to &lt;a href=&quot;#readPacket()&quot;&gt;&lt;code&gt;readPacket&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#writePacket(byte%5B%5D)&quot;&gt;&lt;code&gt;writePacket&lt;/code&gt;&lt;/a&gt; will throw a &lt;a href=&quot;closedconnectionexception&quot;&gt;&lt;code&gt;ClosedConnectionException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果连接已经关闭，则调用此方法无效。关闭连接后，对&lt;a href=&quot;#readPacket()&quot;&gt; &lt;code&gt;readPacket&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#writePacket(byte%5B%5D)&quot;&gt; &lt;code&gt;writePacket&lt;/code&gt; 的&lt;/a&gt;任何进一步尝试调用都将引发&lt;a href=&quot;closedconnectionexception&quot;&gt; &lt;code&gt;ClosedConnectionException&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1941e8a43fce582de3711ef131570c2be6988f0c" translate="yes" xml:space="preserve">
          <source>If the connection is not established within the specified duration then building of the &lt;code&gt;WebSocket&lt;/code&gt; will fail with &lt;a href=&quot;httptimeoutexception&quot;&gt;&lt;code&gt;HttpTimeoutException&lt;/code&gt;&lt;/a&gt;. If this method is not invoked then the infinite timeout is assumed.</source>
          <target state="translated">如果未在指定的时间内建立连接，则 &lt;code&gt;WebSocket&lt;/code&gt; 的构建将失败，并出现&lt;a href=&quot;httptimeoutexception&quot;&gt; &lt;code&gt;HttpTimeoutException&lt;/code&gt; &lt;/a&gt;。如果未调用此方法，则假定无限超时。</target>
        </trans-unit>
        <trans-unit id="fc304512711f4e405bbe651d78fc410942cc454e" translate="yes" xml:space="preserve">
          <source>If the connection pool manager supports &lt;code&gt;Statement&lt;/code&gt; pooling, for &lt;code&gt;PreparedStatements&lt;/code&gt;, which can be determined by invoking the method &lt;code&gt;DatabaseMetaData.supportsStatementPooling&lt;/code&gt;, the connection pool manager will register as a &lt;code&gt;StatementEventListener&lt;/code&gt; object with the new &lt;code&gt;PooledConnection&lt;/code&gt; object. When the &lt;code&gt;PreparedStatement&lt;/code&gt; is closed or there is an error, the connection pool manager (being a listener) gets a notification that includes a &lt;code&gt;StatementEvent&lt;/code&gt; object.</source>
          <target state="translated">如果连接池管理器支持对于 &lt;code&gt;PreparedStatements&lt;/code&gt; 的 &lt;code&gt;Statement&lt;/code&gt; 池，可以通过调用方法 &lt;code&gt;DatabaseMetaData.supportsStatementPooling&lt;/code&gt; 来确定，则连接池管理器将使用新的 &lt;code&gt;PooledConnection&lt;/code&gt; 对象注册为 &lt;code&gt;StatementEventListener&lt;/code&gt; 对象。当 &lt;code&gt;PreparedStatement&lt;/code&gt; 关闭或发生错误时，连接池管理器（作为侦听器）将获得一个包含 &lt;code&gt;StatementEvent&lt;/code&gt; 对象的通知。</target>
        </trans-unit>
        <trans-unit id="c056d8bc44889ca1c50db14d914cd7e3d8e99f1b" translate="yes" xml:space="preserve">
          <source>If the connection pool manager wraps or provides a proxy to the logical handle returned from a call to &lt;code&gt;PoolConnection.getConnection&lt;/code&gt;, the pool manager must do one of the following when the connection pool manager closes or returns the &lt;code&gt;PooledConnection&lt;/code&gt; to the pool in response to the application calling &lt;code&gt;Connection.close&lt;/code&gt;:</source>
          <target state="translated">如果连接池管理器包装或提供对从 &lt;code&gt;PoolConnection.getConnection&lt;/code&gt; 的调用返回的逻辑句柄的代理或提供代理，则当连接池管理器关闭或将 &lt;code&gt;PooledConnection&lt;/code&gt; 返回到池以响应应用程序时，池管理器必须执行以下操作之一调用 &lt;code&gt;Connection.close&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="f881d8d4f5f09d46f8c2856b6d2d804f3ec96cc6" translate="yes" xml:space="preserve">
          <source>If the constructor completes normally, returns the newly created and initialized instance.</source>
          <target state="translated">如果构造函数正常完成,返回新创建并初始化的实例。</target>
        </trans-unit>
        <trans-unit id="2aeb09eb6e0fcfe242a17792207492aa120605ac" translate="yes" xml:space="preserve">
          <source>If the constructor does &lt;b&gt;not&lt;/b&gt; have a CallbackHandler input parameter, or if the caller specifies a &lt;code&gt;null&lt;/code&gt; CallbackHandler object (and a &lt;code&gt;null&lt;/code&gt; value is permitted), the LoginContext queries the &lt;code&gt;auth.login.defaultCallbackHandler&lt;/code&gt; security property for the fully qualified class name of a default handler implementation. If the security property is not set, then the underlying modules will not have a CallbackHandler for use in communicating with users. The caller thus assumes that the configured modules have alternative means for authenticating the user.</source>
          <target state="translated">如果构造确实&lt;b&gt;不&lt;/b&gt;具备给CallbackHandler输入参数，或者调用者指定一个 &lt;code&gt;null&lt;/code&gt; CallbackHandler对象（并且 &lt;code&gt;null&lt;/code&gt; 值是允许的），则LoginContext查询 &lt;code&gt;auth.login.defaultCallbackHandler&lt;/code&gt; 安全属性的默认处理程序的完全限定类名实施。如果未设置security属性，则基础模块将没有用于与用户通信的CallbackHandler。因此，调用者假定已配置的模块具有用于验证用户身份的替代方法。</target>
        </trans-unit>
        <trans-unit id="96edcc96b78112d3bb9f9d209b5477cb96759906" translate="yes" xml:space="preserve">
          <source>If the constructor does &lt;b&gt;not&lt;/b&gt; have a Configuration input parameter, or if the caller specifies a &lt;code&gt;null&lt;/code&gt; Configuration object, the constructor uses the following call to get the installed Configuration:</source>
          <target state="translated">如果构造确实&lt;b&gt;不&lt;/b&gt;存在Configuration输入参数，或者调用者指定了一个 &lt;code&gt;null&lt;/code&gt; 的配置对象，构造函数使用以下调用来获取安装配置：</target>
        </trans-unit>
        <trans-unit id="56ea3a3517b6a27cca0834c9f4eb544d3dc38d39" translate="yes" xml:space="preserve">
          <source>If the constructor does &lt;b&gt;not&lt;/b&gt; have a Subject input parameter, the LoginContext instantiates a new Subject.</source>
          <target state="translated">如果构造并&lt;b&gt;没有&lt;/b&gt;有对象的输入参数，则LoginContext实例化一个新的主题。</target>
        </trans-unit>
        <trans-unit id="51d999e9fc75b0313b56adf5745b9fffcd061b50" translate="yes" xml:space="preserve">
          <source>If the constructor has a CallbackHandler input parameter, the LoginContext uses the caller-specified CallbackHandler object.</source>
          <target state="translated">如果构造函数有CallbackHandler输入参数,LoginContext会使用调用者指定的CallbackHandler对象。</target>
        </trans-unit>
        <trans-unit id="e1e00d077c5cc21a366671e33a8a738802bc618a" translate="yes" xml:space="preserve">
          <source>If the constructor has a Configuration input parameter and the caller specifies a non-null Configuration, the LoginContext uses the caller-specified Configuration.</source>
          <target state="translated">如果构造函数有一个Configuration输入参数,并且调用者指定了一个非空的Configuration,那么LoginContext会使用调用者指定的Configuration。</target>
        </trans-unit>
        <trans-unit id="3de799a960e7be55aab3ca032d285e2179f3390f" translate="yes" xml:space="preserve">
          <source>If the constructor has a Subject input parameter, the LoginContext uses the caller-specified Subject object.</source>
          <target state="translated">如果构造函数有Subject输入参数,LoginContext使用调用者指定的Subject对象。</target>
        </trans-unit>
        <trans-unit id="3a99d0a19bc0f8c41b49ce35b93e620433ac8f02" translate="yes" xml:space="preserve">
          <source>If the constructor is declared to throw exceptions, the parameter list is followed by a space, followed by the word &quot;&lt;code&gt;throws&lt;/code&gt;&quot; followed by a comma-separated list of the thrown exception types.</source>
          <target state="translated">如果声明构造函数引发异常，则参数列表后跟一个空格，后跟单词&amp;ldquo; &lt;code&gt;throws&lt;/code&gt; &amp;rdquo;，然后是逗号分隔的引发异常类型的列表。</target>
        </trans-unit>
        <trans-unit id="8c9ed368492503e51fcc4ae43d3e8d4462771fd7" translate="yes" xml:space="preserve">
          <source>If the constructor's &lt;code&gt;accessible&lt;/code&gt; flag is not set, access checking is performed immediately on behalf of the lookup class.</source>
          <target state="translated">如果未设置构造函数的 &lt;code&gt;accessible&lt;/code&gt; 标志，则代表查找类立即执行访问检查。</target>
        </trans-unit>
        <trans-unit id="2473d04d22b81fa38fb3fac97ebfc248b300280e" translate="yes" xml:space="preserve">
          <source>If the constructor's declaring class is an inner class in a non-static context, the first argument to the constructor needs to be the enclosing instance; see section 15.9.3 of</source>
          <target state="translated">如果构造函数的声明类是非静态上下文中的内类,那么构造函数的第一个参数需要是包围实例;请参见</target>
        </trans-unit>
        <trans-unit id="f8c1d043cdccb51e8a4ceda740614fe5576a5363" translate="yes" xml:space="preserve">
          <source>If the container of an boundary-point of a Range is being set to either a node of an invalid type or a node with an ancestor of an invalid type.</source>
          <target state="translated">如果Range的边界点的容器被设置为无效类型的节点或祖先为无效类型的节点。</target>
        </trans-unit>
        <trans-unit id="eae554929c7a6131d929bc3da9b88deb58a80b03" translate="yes" xml:space="preserve">
          <source>If the container's &lt;code&gt;ComponentOrientation&lt;/code&gt; property is horizontal and left-to-right, the above example produces the output shown in Figure 1. If the container's &lt;code&gt;ComponentOrientation&lt;/code&gt; property is horizontal and right-to-left, the example produces the output shown in Figure 2.</source>
          <target state="translated">如果容器的 &lt;code&gt;ComponentOrientation&lt;/code&gt; 属性是水平的并且从左到右，则上面的示例生成图1所示的输出。如果容器的 &lt;code&gt;ComponentOrientation&lt;/code&gt; 属性是水平的并且从右到左，则该示例生成图2所示的输出。</target>
        </trans-unit>
        <trans-unit id="12ab1266a164c0f6072aaf95e501de64c7ac066d" translate="yes" xml:space="preserve">
          <source>If the containing type is a parameterized type, the number of type arguments must equal the number of &lt;code&gt;typeElem&lt;/code&gt;'s formal type parameters. If it is not parameterized or if it is &lt;code&gt;null&lt;/code&gt;, this method is equivalent to &lt;code&gt;getDeclaredType(typeElem, typeArgs)&lt;/code&gt;.</source>
          <target state="translated">如果包含的类型是参数化类型，则类型实参的数量必须等于 &lt;code&gt;typeElem&lt;/code&gt; 的形式类型参数的数量。如果未参数化或为 &lt;code&gt;null&lt;/code&gt; ，则此方法等效于 &lt;code&gt;getDeclaredType(typeElem, typeArgs)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eba2ca49b1b8640f5521ff4ce667486544415323" translate="yes" xml:space="preserve">
          <source>If the content-length response header has not already been set then this is set to the appropriate value depending on the response length parameter.</source>
          <target state="translated">如果还没有设置内容长度响应头,那么根据响应长度参数,将其设置为适当的值。</target>
        </trans-unit>
        <trans-unit id="1b29895ec70403fd2e17d250a3c6d70239c8ec92" translate="yes" xml:space="preserve">
          <source>If the contents of the underlying document containing the &lt;code&gt;XMLSignature&lt;/code&gt; are subsequently modified, the behavior is undefined.</source>
          <target state="translated">如果随后修改了包含 &lt;code&gt;XMLSignature&lt;/code&gt; 的基础文档的内容，则该行为是未定义的。</target>
        </trans-unit>
        <trans-unit id="54595108c68c9e1528174df34d61161ee7d1002c" translate="yes" xml:space="preserve">
          <source>If the context is available and there is a security manager installed, the caller may require permission to access it or a security exception may be thrown. In a Java environment, the security manager's &lt;code&gt;checkPermission&lt;/code&gt; method is called with a &lt;code&gt;SSLPermission(&quot;getSSLSessionContext&quot;)&lt;/code&gt; permission.</source>
          <target state="translated">如果上下文可用，并且安装了安全管理器，则调用者可能需要访问权限才能访问它，否则可能引发安全异常。在Java环境中，使用 &lt;code&gt;SSLPermission(&quot;getSSLSessionContext&quot;)&lt;/code&gt; 权限调用安全管理器的 &lt;code&gt;checkPermission&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="e7936f29deee3d60765c1418e1263abb6aa6cc3c" translate="yes" xml:space="preserve">
          <source>If the context node is a &lt;code&gt;Document&lt;/code&gt; node and the action is &lt;code&gt;ACTION_REPLACE_CHILDREN&lt;/code&gt;, then the document that is passed as the context node will be changed such that its &lt;code&gt;xmlEncoding&lt;/code&gt;, &lt;code&gt;documentURI&lt;/code&gt;, &lt;code&gt;xmlVersion&lt;/code&gt;, &lt;code&gt;inputEncoding&lt;/code&gt;, &lt;code&gt;xmlStandalone&lt;/code&gt;, and all other such attributes are set to what they would be set to if the input source was parsed using &lt;code&gt;LSParser.parse()&lt;/code&gt;.</source>
          <target state="translated">如果上下文节点是 &lt;code&gt;Document&lt;/code&gt; 节点，并且操作是 &lt;code&gt;ACTION_REPLACE_CHILDREN&lt;/code&gt; ，则将更改作为上下文节点传递的文档，以便将其 &lt;code&gt;xmlEncoding&lt;/code&gt; ， &lt;code&gt;documentURI&lt;/code&gt; ， &lt;code&gt;xmlVersion&lt;/code&gt; ， &lt;code&gt;inputEncoding&lt;/code&gt; ， &lt;code&gt;xmlStandalone&lt;/code&gt; 以及所有其他此类属性设置为它们的属性。如果使用 &lt;code&gt;LSParser.parse()&lt;/code&gt; 解析了输入源，则将设置为。</target>
        </trans-unit>
        <trans-unit id="3a360ee8a79bfd6943a67c78860b71ba39acaa75" translate="yes" xml:space="preserve">
          <source>If the conversion failed, value 0 will be used.</source>
          <target state="translated">如果转换失败,将使用0值。</target>
        </trans-unit>
        <trans-unit id="2e4edf267c4c18b01156d4fb736a0d9de264f347" translate="yes" xml:space="preserve">
          <source>If the conversion is &lt;code&gt;'a'&lt;/code&gt; or &lt;code&gt;'A'&lt;/code&gt;, then the precision is the number of hexadecimal digits after the radix point. If the precision is not provided, then all of the digits as returned by &lt;a href=&quot;../lang/double#toHexString(double)&quot;&gt;&lt;code&gt;Double.toHexString(double)&lt;/code&gt;&lt;/a&gt; will be output.</source>
          <target state="translated">如果转换为 &lt;code&gt;'a'&lt;/code&gt; 或 &lt;code&gt;'A'&lt;/code&gt; ，则精度为小数点后的十六进制数字。如果未提供精度，则将输出&lt;a href=&quot;../lang/double#toHexString(double)&quot;&gt; &lt;code&gt;Double.toHexString(double)&lt;/code&gt; &lt;/a&gt;返回的所有数字。</target>
        </trans-unit>
        <trans-unit id="6d873373059873c2f9dda2243106e00e462486c8" translate="yes" xml:space="preserve">
          <source>If the conversion is &lt;code&gt;'a'&lt;/code&gt; or &lt;code&gt;'A'&lt;/code&gt;, then the precision is the number of hexadecimal digits after the radix point. If the precision is not provided, then all of the digits as returned by &lt;a href=&quot;../lang/double#toHexString-double-&quot;&gt;&lt;code&gt;Double.toHexString(double)&lt;/code&gt;&lt;/a&gt; will be output.</source>
          <target state="translated">如果转换为 &lt;code&gt;'a'&lt;/code&gt; 或 &lt;code&gt;'A'&lt;/code&gt; ，则精度为小数点后的十六进制数字。如果未提供精度，则将输出&lt;a href=&quot;../lang/double#toHexString-double-&quot;&gt; &lt;code&gt;Double.toHexString(double)&lt;/code&gt; &lt;/a&gt;返回的所有数字。</target>
        </trans-unit>
        <trans-unit id="4920cb3a35e9ffdd181f2cc1c02598946a361975" translate="yes" xml:space="preserve">
          <source>If the conversion is &lt;code&gt;'g'&lt;/code&gt; or &lt;code&gt;'G'&lt;/code&gt;, then the precision is the total number of significant digits in the resulting magnitude after rounding. If the precision is not specified, then the default value is &lt;code&gt;6&lt;/code&gt;. If the precision is &lt;code&gt;0&lt;/code&gt;, then it is taken to be &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">如果转换是 &lt;code&gt;'g'&lt;/code&gt; 或 &lt;code&gt;'G'&lt;/code&gt; ，则精度是四舍五入后得到的幅度中有效位数的总数。如果未指定精度，则默认值为 &lt;code&gt;6&lt;/code&gt; 。如果精度为 &lt;code&gt;0&lt;/code&gt; ，则将其视为 &lt;code&gt;1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5b740696da8433363284a2a09b00def3e5dd32a1" translate="yes" xml:space="preserve">
          <source>If the conversion is &lt;code&gt;'o'&lt;/code&gt;, &lt;code&gt;'x'&lt;/code&gt;, or &lt;code&gt;'X'&lt;/code&gt; and both the &lt;code&gt;'#'&lt;/code&gt; and the &lt;code&gt;'0'&lt;/code&gt; flags are given, then result will contain the base indicator (&lt;code&gt;'0'&lt;/code&gt; for octal and &lt;code&gt;&quot;0x&quot;&lt;/code&gt; or &lt;code&gt;&quot;0X&quot;&lt;/code&gt; for hexadecimal), some number of zeros (based on the width), and the value.</source>
          <target state="translated">如果转换是 &lt;code&gt;'o'&lt;/code&gt; ， &lt;code&gt;'x'&lt;/code&gt; 或 &lt;code&gt;'X'&lt;/code&gt; 并且给出了 &lt;code&gt;'#'&lt;/code&gt; 和 &lt;code&gt;'0'&lt;/code&gt; 标志，则结果将包含基本指示符（八进制为 &lt;code&gt;'0'&lt;/code&gt; ， &lt;code&gt;&quot;0x&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;0X&quot;&lt;/code&gt; （十六进制），一些零（基于宽度）和值。</target>
        </trans-unit>
        <trans-unit id="8d9565e696ad547e1a513117ec394adf4606346c" translate="yes" xml:space="preserve">
          <source>If the conversion is &lt;code&gt;'o'&lt;/code&gt;, &lt;code&gt;'x'&lt;/code&gt;, or &lt;code&gt;'X'&lt;/code&gt; and both the &lt;code&gt;'#'&lt;/code&gt; and the &lt;code&gt;'0'&lt;/code&gt; flags are given, then result will contain the radix indicator (&lt;code&gt;'0'&lt;/code&gt; for octal and &lt;code&gt;&quot;0x&quot;&lt;/code&gt; or &lt;code&gt;&quot;0X&quot;&lt;/code&gt; for hexadecimal), some number of zeros (based on the width), and the value.</source>
          <target state="translated">如果转换为 &lt;code&gt;'o'&lt;/code&gt; ， &lt;code&gt;'x'&lt;/code&gt; 或 &lt;code&gt;'X'&lt;/code&gt; 并且给出了 &lt;code&gt;'#'&lt;/code&gt; 和 &lt;code&gt;'0'&lt;/code&gt; 标志，则结果将包含基数指示符（八进制为 &lt;code&gt;'0'&lt;/code&gt; ， &lt;code&gt;&quot;0x&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;0X&quot;&lt;/code&gt; （十六进制），一些零（基于宽度）和值。</target>
        </trans-unit>
        <trans-unit id="f92ee64ab913667741eadac9533a1057cb848b90" translate="yes" xml:space="preserve">
          <source>If the count reaches zero then the method returns with the value &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">如果计数达到零，则该方法返回值 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ebf6135f725f6abcb2f61e9b10a4d1d32a5ee738" translate="yes" xml:space="preserve">
          <source>If the counter can wrap around its maximum value, the modulus needs to be specified. The modulus is the value at which the counter is reset to zero.</source>
          <target state="translated">如果计数器可以环绕其最大值,则需要指定模数。模数是将计数器重置为零的值。</target>
        </trans-unit>
        <trans-unit id="7b2012ddc4ebb24e7045b7a055ac3ae1d060dc81" translate="yes" xml:space="preserve">
          <source>If the counter difference mode is used, the value of the derived gauge is calculated as the difference between the observed counter values for two successive observations. If this difference is negative, the value of the derived gauge is incremented by the value of the modulus. The derived gauge value (V[t]) is calculated using the following method:</source>
          <target state="translated">如果使用计数器差值模式,推导出的量规值是以连续两次观测的计数器值之差计算的。如果这个差值是负数,则导出的轨距值将以模数的值递增。得出的轨距值(V[t])用以下方法计算:</target>
        </trans-unit>
        <trans-unit id="5d33f0fe4d8b3f6830caa94328f7bd32d5be7376" translate="yes" xml:space="preserve">
          <source>If the creation of this &lt;code&gt;Receiver&lt;/code&gt; resulted in implicitly opening the underlying device, the device is implicitly closed by this method. This is true unless the device is kept open by other &lt;code&gt;Receiver&lt;/code&gt; or &lt;code&gt;Transmitter&lt;/code&gt; instances that opened the device implicitly, and unless the device has been opened explicitly. If the device this &lt;code&gt;Receiver&lt;/code&gt; is retrieved from is closed explicitly by calling &lt;a href=&quot;mididevice#close()&quot;&gt;&lt;code&gt;MidiDevice.close&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;Receiver&lt;/code&gt; is closed, too. For a detailed description of open/close behaviour see the class description of &lt;a href=&quot;mididevice&quot;&gt;&lt;code&gt;MidiDevice&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果创建此 &lt;code&gt;Receiver&lt;/code&gt; 导致隐式打开底层设备，则此方法将隐式关闭该设备。这是正确的，除非该设备被其他隐式打开该设备的 &lt;code&gt;Receiver&lt;/code&gt; 或 &lt;code&gt;Transmitter&lt;/code&gt; 实例保持打开状态，并且除非该设备已显式打开。如果通过调用&lt;a href=&quot;mididevice#close()&quot;&gt; &lt;code&gt;MidiDevice.close&lt;/code&gt; &lt;/a&gt;显式关闭了从此 &lt;code&gt;Receiver&lt;/code&gt; 检索到的设备，则 &lt;code&gt;Receiver&lt;/code&gt; 也将关闭。有关打开/关闭行为的详细说明，请参见&lt;a href=&quot;mididevice&quot;&gt; &lt;code&gt;MidiDevice&lt;/code&gt; &lt;/a&gt;的类说明。</target>
        </trans-unit>
        <trans-unit id="0f1b34ff7dc9bdfbc17c9da13d95b1516d17ebbc" translate="yes" xml:space="preserve">
          <source>If the creation of this &lt;code&gt;Receiver&lt;/code&gt; resulted in implicitly opening the underlying device, the device is implicitly closed by this method. This is true unless the device is kept open by other &lt;code&gt;Receiver&lt;/code&gt; or &lt;code&gt;Transmitter&lt;/code&gt; instances that opened the device implicitly, and unless the device has been opened explicitly. If the device this &lt;code&gt;Receiver&lt;/code&gt; is retrieved from is closed explicitly by calling &lt;a href=&quot;mididevice#close--&quot;&gt;&lt;code&gt;MidiDevice.close&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;Receiver&lt;/code&gt; is closed, too. For a detailed description of open/close behaviour see the class description of &lt;a href=&quot;mididevice&quot;&gt;&lt;code&gt;MidiDevice&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果创建此 &lt;code&gt;Receiver&lt;/code&gt; 导致隐式打开底层设备，则此方法将隐式关闭该设备。这是正确的，除非该设备被其他隐式打开该设备的 &lt;code&gt;Receiver&lt;/code&gt; 或 &lt;code&gt;Transmitter&lt;/code&gt; 实例保持打开状态，并且除非该设备已显式打开。如果通过调用&lt;a href=&quot;mididevice#close--&quot;&gt; &lt;code&gt;MidiDevice.close&lt;/code&gt; &lt;/a&gt;显式关闭了从此 &lt;code&gt;Receiver&lt;/code&gt; 检索到的设备，则 &lt;code&gt;Receiver&lt;/code&gt; 也将关闭。有关打开/关闭行为的详细说明，请参见&lt;a href=&quot;mididevice&quot;&gt; &lt;code&gt;MidiDevice&lt;/code&gt; &lt;/a&gt;的类说明。</target>
        </trans-unit>
        <trans-unit id="e1af258f9977741775b4573e8cb983831177f305" translate="yes" xml:space="preserve">
          <source>If the creation of this &lt;code&gt;Transmitter&lt;/code&gt; resulted in implicitly opening the underlying device, the device is implicitly closed by this method. This is true unless the device is kept open by other &lt;code&gt;Receiver&lt;/code&gt; or &lt;code&gt;Transmitter&lt;/code&gt; instances that opened the device implicitly, and unless the device has been opened explicitly. If the device this &lt;code&gt;Transmitter&lt;/code&gt; is retrieved from is closed explicitly by calling &lt;a href=&quot;mididevice#close()&quot;&gt;&lt;code&gt;MidiDevice.close&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;Transmitter&lt;/code&gt; is closed, too. For a detailed description of open/close behaviour see the class description of &lt;a href=&quot;mididevice&quot;&gt;&lt;code&gt;MidiDevice&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果创建此 &lt;code&gt;Transmitter&lt;/code&gt; 导致隐式打开底层设备，则该方法将隐式关闭该设备。这是正确的，除非该设备被其他隐式打开该设备的 &lt;code&gt;Receiver&lt;/code&gt; 或 &lt;code&gt;Transmitter&lt;/code&gt; 实例保持打开状态，并且除非该设备已显式打开。如果通过调用&lt;a href=&quot;mididevice#close()&quot;&gt; &lt;code&gt;MidiDevice.close&lt;/code&gt; &lt;/a&gt;显式关闭了要从中检索此 &lt;code&gt;Transmitter&lt;/code&gt; 的设备，则 &lt;code&gt;Transmitter&lt;/code&gt; 也将关闭。有关打开/关闭行为的详细说明，请参见&lt;a href=&quot;mididevice&quot;&gt; &lt;code&gt;MidiDevice&lt;/code&gt; &lt;/a&gt;的类说明。</target>
        </trans-unit>
        <trans-unit id="9ae995006fbd46da8baab1bfa646c3f1a74c6123" translate="yes" xml:space="preserve">
          <source>If the creation of this &lt;code&gt;Transmitter&lt;/code&gt; resulted in implicitly opening the underlying device, the device is implicitly closed by this method. This is true unless the device is kept open by other &lt;code&gt;Receiver&lt;/code&gt; or &lt;code&gt;Transmitter&lt;/code&gt; instances that opened the device implicitly, and unless the device has been opened explicitly. If the device this &lt;code&gt;Transmitter&lt;/code&gt; is retrieved from is closed explicitly by calling &lt;a href=&quot;mididevice#close--&quot;&gt;&lt;code&gt;MidiDevice.close&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;Transmitter&lt;/code&gt; is closed, too. For a detailed description of open/close behaviour see the class description of &lt;a href=&quot;mididevice&quot;&gt;&lt;code&gt;MidiDevice&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果创建此 &lt;code&gt;Transmitter&lt;/code&gt; 导致隐式打开底层设备，则该方法将隐式关闭该设备。这是正确的，除非该设备被其他隐式打开该设备的 &lt;code&gt;Receiver&lt;/code&gt; 或 &lt;code&gt;Transmitter&lt;/code&gt; 实例保持打开状态，并且除非该设备已显式打开。如果通过调用&lt;a href=&quot;mididevice#close--&quot;&gt; &lt;code&gt;MidiDevice.close&lt;/code&gt; &lt;/a&gt;显式关闭了要从中检索此 &lt;code&gt;Transmitter&lt;/code&gt; 的设备，则 &lt;code&gt;Transmitter&lt;/code&gt; 也将关闭。有关打开/关闭行为的详细说明，请参见&lt;a href=&quot;mididevice&quot;&gt; &lt;code&gt;MidiDevice&lt;/code&gt; &lt;/a&gt;的类说明。</target>
        </trans-unit>
        <trans-unit id="6c179704df7cb8ed1b3ce0d3934ef2876dfdab64" translate="yes" xml:space="preserve">
          <source>If the current capacity of this vector is less than &lt;code&gt;minCapacity&lt;/code&gt;, then its capacity is increased by replacing its internal data array, kept in the field &lt;code&gt;elementData&lt;/code&gt;, with a larger one. The size of the new data array will be the old size plus &lt;code&gt;capacityIncrement&lt;/code&gt;, unless the value of &lt;code&gt;capacityIncrement&lt;/code&gt; is less than or equal to zero, in which case the new capacity will be twice the old capacity; but if this new size is still smaller than &lt;code&gt;minCapacity&lt;/code&gt;, then the new capacity will be &lt;code&gt;minCapacity&lt;/code&gt;.</source>
          <target state="translated">如果此向量的当前容量小于 &lt;code&gt;minCapacity&lt;/code&gt; ，则可以通过使用更大的内部数组替换保留在字段 &lt;code&gt;elementData&lt;/code&gt; 中的内部数据数组来增加其容量。新的数据阵列的大小将是原来的大小加上 &lt;code&gt;capacityIncrement&lt;/code&gt; ，除非的值 &lt;code&gt;capacityIncrement&lt;/code&gt; 小于或等于零，在这种情况下，新的容量将是原来容量的两倍; 但是如果此新大小仍小于 &lt;code&gt;minCapacity&lt;/code&gt; ，则新容量将为 &lt;code&gt;minCapacity&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="15aa95f18520c9768c5e75e2d00df5cd87e5c814" translate="yes" xml:space="preserve">
          <source>If the current count equals zero then nothing happens.</source>
          <target state="translated">如果当前的计数等于零,那么什么都不会发生。</target>
        </trans-unit>
        <trans-unit id="f94ee3549183c062116cda5b26a97df611673964" translate="yes" xml:space="preserve">
          <source>If the current count is greater than zero then it is decremented. If the new count is zero then all waiting threads are re-enabled for thread scheduling purposes.</source>
          <target state="translated">如果当前的计数大于零,那么它将被递减。如果新的计数为零,那么所有等待的线程将被重新启用,以达到线程调度的目的。</target>
        </trans-unit>
        <trans-unit id="3a7db62e9957e4a583a5bb47860c808eb80b034b" translate="yes" xml:space="preserve">
          <source>If the current count is greater than zero then the current thread becomes disabled for thread scheduling purposes and lies dormant until one of three things happen:</source>
          <target state="translated">如果当前计数大于零,那么当前线程就会因为线程调度的目的而被禁用,并处于休眠状态,直到三种情况之一发生。</target>
        </trans-unit>
        <trans-unit id="d7ac4173a35be7aa72f90b5ce9f676b82ef7108f" translate="yes" xml:space="preserve">
          <source>If the current count is greater than zero then the current thread becomes disabled for thread scheduling purposes and lies dormant until one of two things happen:</source>
          <target state="translated">如果当前计数大于零,那么当前线程就会因为线程调度的目的而被禁用,并处于休眠状态,直到两种情况之一发生。</target>
        </trans-unit>
        <trans-unit id="0e615f8a82085afa953ed38e8e8581f0bc679866" translate="yes" xml:space="preserve">
          <source>If the current count is zero then this method returns immediately with the value &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">如果当前计数为零，则此方法立即返回 &lt;code&gt;true&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="bf13f63814d624078b38288a8fd1cdef5534f01f" translate="yes" xml:space="preserve">
          <source>If the current count is zero then this method returns immediately.</source>
          <target state="translated">如果当前计数为零,那么这个方法立即返回。</target>
        </trans-unit>
        <trans-unit id="7fd54efda8852abf1726c4425c8e78d3b50cf5d3" translate="yes" xml:space="preserve">
          <source>If the current event is a START_ELEMENT or END_ELEMENT this method returns the URI of the prefix or the default namespace.</source>
          <target state="translated">如果当前事件是START_ELEMENT或END_ELEMENT,则该方法返回前缀的URI或默认命名空间。</target>
        </trans-unit>
        <trans-unit id="2cd4616380038d25f830f6fb1b42637233fe3f86" translate="yes" xml:space="preserve">
          <source>If the current event is a START_ELEMENT or END_ELEMENT this method returns the URI of the prefix or the default namespace. Returns null if the event does not have a prefix.</source>
          <target state="translated">如果当前事件是START_ELEMENT或END_ELEMENT,本方法返回前缀或默认命名空间的URI。如果事件没有前缀,则返回null。</target>
        </trans-unit>
        <trans-unit id="5887879e6691c6cf6cd544bc0267797a7fb44c5c" translate="yes" xml:space="preserve">
          <source>If the current layout manager implements &lt;code&gt;LayoutManager2&lt;/code&gt;, then &lt;a href=&quot;../../java/awt/layoutmanager2#addLayoutComponent(java.awt.Component,java.lang.Object)&quot;&gt;&lt;code&gt;LayoutManager2.addLayoutComponent(Component,Object)&lt;/code&gt;&lt;/a&gt; is invoked on it. If the current layout manager does not implement &lt;code&gt;LayoutManager2&lt;/code&gt;, and constraints is a &lt;code&gt;String&lt;/code&gt;, then &lt;a href=&quot;../../java/awt/layoutmanager#addLayoutComponent(java.lang.String,java.awt.Component)&quot;&gt;&lt;code&gt;LayoutManager.addLayoutComponent(String,Component)&lt;/code&gt;&lt;/a&gt; is invoked on it.</source>
          <target state="translated">如果当前布局管理器实现 &lt;code&gt;LayoutManager2&lt;/code&gt; ，则在其上调用&lt;a href=&quot;../../java/awt/layoutmanager2#addLayoutComponent(java.awt.Component,java.lang.Object)&quot;&gt; &lt;code&gt;LayoutManager2.addLayoutComponent(Component,Object)&lt;/code&gt; &lt;/a&gt;。如果当前布局管理器未实现 &lt;code&gt;LayoutManager2&lt;/code&gt; ，并且constraints是 &lt;code&gt;String&lt;/code&gt; ，则在其上调用&lt;a href=&quot;../../java/awt/layoutmanager#addLayoutComponent(java.lang.String,java.awt.Component)&quot;&gt; &lt;code&gt;LayoutManager.addLayoutComponent(String,Component)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3a447a386debb26576b066a1d7df35582ff0b666" translate="yes" xml:space="preserve">
          <source>If the current layout manager implements &lt;code&gt;LayoutManager2&lt;/code&gt;, then &lt;a href=&quot;layoutmanager2#addLayoutComponent(java.awt.Component,java.lang.Object)&quot;&gt;&lt;code&gt;LayoutManager2.addLayoutComponent(Component,Object)&lt;/code&gt;&lt;/a&gt; is invoked on it. If the current layout manager does not implement &lt;code&gt;LayoutManager2&lt;/code&gt;, and constraints is a &lt;code&gt;String&lt;/code&gt;, then &lt;a href=&quot;layoutmanager#addLayoutComponent(java.lang.String,java.awt.Component)&quot;&gt;&lt;code&gt;LayoutManager.addLayoutComponent(String,Component)&lt;/code&gt;&lt;/a&gt; is invoked on it.</source>
          <target state="translated">如果当前布局管理器实现 &lt;code&gt;LayoutManager2&lt;/code&gt; ，则在其上调用&lt;a href=&quot;layoutmanager2#addLayoutComponent(java.awt.Component,java.lang.Object)&quot;&gt; &lt;code&gt;LayoutManager2.addLayoutComponent(Component,Object)&lt;/code&gt; &lt;/a&gt;。如果当前布局管理器未实现 &lt;code&gt;LayoutManager2&lt;/code&gt; ，并且constraints是 &lt;code&gt;String&lt;/code&gt; ，则在其上调用&lt;a href=&quot;layoutmanager#addLayoutComponent(java.lang.String,java.awt.Component)&quot;&gt; &lt;code&gt;LayoutManager.addLayoutComponent(String,Component)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d4b49d04a03e7f62716b78c4449ecc798158a3b8" translate="yes" xml:space="preserve">
          <source>If the current method handle is not of &lt;a href=&quot;#asVarargsCollector(java.lang.Class)&quot;&gt;variable arity&lt;/a&gt;, the current method handle is returned. This is true even if the current method handle could not be a valid input to &lt;code&gt;asVarargsCollector&lt;/code&gt;.</source>
          <target state="translated">如果当前方法句柄不是&lt;a href=&quot;#asVarargsCollector(java.lang.Class)&quot;&gt;可变变量&lt;/a&gt;，则返回当前方法句柄。即使当前方法句柄不能作为 &lt;code&gt;asVarargsCollector&lt;/code&gt; 的有效输入，也是如此。</target>
        </trans-unit>
        <trans-unit id="a37f29b7a24ab724ec62dade14ae458a9a6defe6" translate="yes" xml:space="preserve">
          <source>If the current method handle is not of &lt;a href=&quot;methodhandle#asVarargsCollector-java.lang.Class-&quot;&gt;variable arity&lt;/a&gt;, the current method handle is returned. This is true even if the current method handle could not be a valid input to &lt;code&gt;asVarargsCollector&lt;/code&gt;.</source>
          <target state="translated">如果当前方法句柄不是&lt;a href=&quot;methodhandle#asVarargsCollector-java.lang.Class-&quot;&gt;可变变量&lt;/a&gt;，则返回当前方法句柄。即使当前方法句柄不能作为 &lt;code&gt;asVarargsCollector&lt;/code&gt; 的有效输入，也是如此。</target>
        </trans-unit>
        <trans-unit id="8cbc4f7fe8db524f0e4673c73c93f44a75301142" translate="yes" xml:space="preserve">
          <source>If the current method is a variable arity method handle argument list conversion may involve the conversion and collection of several arguments into an array, as &lt;a href=&quot;#asVarargsCollector(java.lang.Class)&quot;&gt;described elsewhere&lt;/a&gt;. In every other case, all conversions are applied &lt;em&gt;pairwise&lt;/em&gt;, which means that each argument or return value is converted to exactly one argument or return value (or no return value). The applied conversions are defined by consulting the corresponding component types of the old and new method handle types.</source>
          <target state="translated">如果当前方法是可变Arity方法，则处理参数列表的转换可能涉及将多个参数的转换和集合到数组中，如&lt;a href=&quot;#asVarargsCollector(java.lang.Class)&quot;&gt;其他地方所述&lt;/a&gt;。在所有其他情况下，所有转换都是&lt;em&gt;成对&lt;/em&gt;应用的，这意味着每个参数或返回值都将精确地转换为一个参数或返回值（或没有返回值）。通过咨询旧方法和新方法句柄类型的相应组件类型来定义应用的转换。</target>
        </trans-unit>
        <trans-unit id="c10541f1b7a87a46fca0e82cb887f1f5cdfbfc64" translate="yes" xml:space="preserve">
          <source>If the current method is a variable arity method handle argument list conversion may involve the conversion and collection of several arguments into an array, as &lt;a href=&quot;methodhandle#asVarargsCollector-java.lang.Class-&quot;&gt;described elsewhere&lt;/a&gt;. In every other case, all conversions are applied &lt;em&gt;pairwise&lt;/em&gt;, which means that each argument or return value is converted to exactly one argument or return value (or no return value). The applied conversions are defined by consulting the the corresponding component types of the old and new method handle types.</source>
          <target state="translated">如果当前方法是可变Arity方法，则处理参数列表的转换可能涉及将多个参数转换和收集到数组中，如&lt;a href=&quot;methodhandle#asVarargsCollector-java.lang.Class-&quot;&gt;其他地方所述&lt;/a&gt;。在所有其他情况下，所有转换都是&lt;em&gt;成对&lt;/em&gt;应用的，这意味着每个参数或返回值都将精确地转换为一个参数或返回值（或没有返回值）。通过咨询旧方法和新方法句柄类型的相应组件类型来定义应用的转换。</target>
        </trans-unit>
        <trans-unit id="3234b563a8a8287e5245f9226141091af776f5ee" translate="yes" xml:space="preserve">
          <source>If the current position when this method is invoked is greater than the loop end point, playback continues to the end of the sequence without looping, unless the loop end point is changed subsequently.</source>
          <target state="translated">如果调用本方法时的当前位置大于循环结束点,除非循环结束点随后被改变,否则回放将继续到序列的末端,而不会循环。</target>
        </trans-unit>
        <trans-unit id="7e2a55a1a8bd4ad8685ae28cb47b45b0f898fa44" translate="yes" xml:space="preserve">
          <source>If the current position when this method is invoked is greater than the loop end point, playback simply continues to the end of the clip without looping.</source>
          <target state="translated">如果调用本方法时的当前位置大于循环结束点,则回放只需继续到剪辑结束,不进行循环。</target>
        </trans-unit>
        <trans-unit id="53f9e2fbf2a84ba1f43f8095838a4643dc8b642a" translate="yes" xml:space="preserve">
          <source>If the current thread already holds the lock then the hold count is incremented by one and the method returns immediately.</source>
          <target state="translated">如果当前线程已经持有锁,那么持有数就会递增1,然后该方法立即返回。</target>
        </trans-unit>
        <trans-unit id="bea401fb42f3ffdcd05852cff501d885235ba3f7" translate="yes" xml:space="preserve">
          <source>If the current thread already holds the write lock then the hold count is incremented by one and the method returns immediately.</source>
          <target state="translated">如果当前线程已经持有写锁,那么持有数就会递增1,然后该方法立即返回。</target>
        </trans-unit>
        <trans-unit id="b5d5c6242f9711c787eadd91061f9abc9aef5a8f" translate="yes" xml:space="preserve">
          <source>If the current thread already holds this lock then the hold count is incremented by one and the method returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">如果当前线程已经持有此锁，则持有计数将增加一，并且该方法返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e1db59e340b43fddf7a6d53a8527759fc071b7e9" translate="yes" xml:space="preserve">
          <source>If the current thread already holds this lock then the hold count is incremented by one and the method returns immediately.</source>
          <target state="translated">如果当前线程已经持有这个锁,那么持有数就会递增1,并且该方法立即返回。</target>
        </trans-unit>
        <trans-unit id="de1ccea35bb4ddb6a5d8665f27c10c6698fe0002" translate="yes" xml:space="preserve">
          <source>If the current thread is &lt;a href=&quot;../../lang/thread#interrupt()&quot;&gt;interrupted&lt;/a&gt; while waiting for a permit then it will continue to wait, but the time at which the thread is assigned a permit may change compared to the time it would have received the permit had no interruption occurred. When the thread does return from this method its interrupt status will be set.</source>
          <target state="translated">如果当前线程在等待许可时被&lt;a href=&quot;../../lang/thread#interrupt()&quot;&gt;中断&lt;/a&gt;，则它将继续等待，但是与未发生中断的情况下获得许可的时间相比，为线程分配许可的时间可能会发生变化。当线程确实从该方法返回时，将设置其中断状态。</target>
        </trans-unit>
        <trans-unit id="967846e3a908254c0237f926edc93e8f505ceba6" translate="yes" xml:space="preserve">
          <source>If the current thread is &lt;a href=&quot;../../lang/thread#interrupt()&quot;&gt;interrupted&lt;/a&gt; while waiting for permits then it will continue to wait and its position in the queue is not affected. When the thread does return from this method its interrupt status will be set.</source>
          <target state="translated">如果当前线程在等待许可时&lt;a href=&quot;../../lang/thread#interrupt()&quot;&gt;中断&lt;/a&gt;，则它将继续等待，并且其在队列中的位置不受影响。当线程确实从该方法返回时，将设置其中断状态。</target>
        </trans-unit>
        <trans-unit id="c86b44509cfe15cabcfd2d4aab1300bc1d4ef97f" translate="yes" xml:space="preserve">
          <source>If the current thread is &lt;a href=&quot;../../lang/thread#interrupt--&quot;&gt;interrupted&lt;/a&gt; while waiting for a permit then it will continue to wait, but the time at which the thread is assigned a permit may change compared to the time it would have received the permit had no interruption occurred. When the thread does return from this method its interrupt status will be set.</source>
          <target state="translated">如果当前线程在等待许可时被&lt;a href=&quot;../../lang/thread#interrupt--&quot;&gt;中断&lt;/a&gt;，则它将继续等待，但是与没有发生中断的情况下获得许可的时间相比，分配线程许可的时间可能会有所变化。当线程确实从该方法返回时，将设置其中断状态。</target>
        </trans-unit>
        <trans-unit id="40fca319282952e93dfb024ecdef67ea1fa9292a" translate="yes" xml:space="preserve">
          <source>If the current thread is &lt;a href=&quot;../../lang/thread#interrupt--&quot;&gt;interrupted&lt;/a&gt; while waiting for permits then it will continue to wait and its position in the queue is not affected. When the thread does return from this method its interrupt status will be set.</source>
          <target state="translated">如果当前线程在等待许可时&lt;a href=&quot;../../lang/thread#interrupt--&quot;&gt;中断&lt;/a&gt;，则它将继续等待，并且其在队列中的位置不受影响。当线程确实从该方法返回时，将设置其中断状态。</target>
        </trans-unit>
        <trans-unit id="161cfbc9814785c409424f6bf227b4259b6505f5" translate="yes" xml:space="preserve">
          <source>If the current thread is &lt;a href=&quot;thread#interrupt()&quot;&gt;interrupted&lt;/a&gt; by any thread before or while it is waiting, then an &lt;code&gt;InterruptedException&lt;/code&gt; is thrown. The &lt;em&gt;interrupted status&lt;/em&gt; of the current thread is cleared when this exception is thrown. This exception is not thrown until the lock status of this object has been restored as described above.</source>
          <target state="translated">如果当前线程被&lt;a href=&quot;thread#interrupt()&quot;&gt;中断&lt;/a&gt;任何线程之前或在等待时，那么 &lt;code&gt;InterruptedException&lt;/code&gt; 异常被抛出。引发此异常时，将清除当前线程的&lt;em&gt;中断状态&lt;/em&gt;。如上所述，直到该对象的锁定状态恢复之前，不会引发此异常。</target>
        </trans-unit>
        <trans-unit id="b1885c7979cce95514869fcb5fe52518650ad751" translate="yes" xml:space="preserve">
          <source>If the current thread is &lt;a href=&quot;thread#interrupt--&quot;&gt;interrupted&lt;/a&gt; by any thread before or while it is waiting, then an &lt;code&gt;InterruptedException&lt;/code&gt; is thrown. This exception is not thrown until the lock status of this object has been restored as described above.</source>
          <target state="translated">如果当前线程被&lt;a href=&quot;thread#interrupt--&quot;&gt;中断&lt;/a&gt;任何线程之前或在等待时，那么 &lt;code&gt;InterruptedException&lt;/code&gt; 异常被抛出。如上所述，直到该对象的锁定状态恢复之前，不会引发此异常。</target>
        </trans-unit>
        <trans-unit id="24ed769eb7f1d50760a5de23563feab0d013a7eb" translate="yes" xml:space="preserve">
          <source>If the current thread is not the last to arrive then it is disabled for thread scheduling purposes and lies dormant until one of the following things happens:</source>
          <target state="translated">如果当前线程不是最后一个到达的,那么为了线程调度的目的,它将被禁用,并处于休眠状态,直到发生以下情况之一。</target>
        </trans-unit>
        <trans-unit id="e93c6ed45977774fb9b45dd0f270b3aadbc2d8b5" translate="yes" xml:space="preserve">
          <source>If the current thread is operating in a ForkJoinPool, unschedules and returns, without executing, a task externally submitted to the pool, if one is available.</source>
          <target state="translated">如果当前线程在ForkJoinPool中运行,如果有一个外部提交给池子的任务,则取消计划并返回,不执行。</target>
        </trans-unit>
        <trans-unit id="8a9ec92500bb555146f4ac53bbc7fab388d80cf9" translate="yes" xml:space="preserve">
          <source>If the current thread is operating in a ForkJoinPool, unschedules and returns, without executing, a task externally submitted to the pool, if one is available. Availability may be transient, so a &lt;code&gt;null&lt;/code&gt; result does not necessarily imply quiescence of the pool. This method is designed primarily to support extensions, and is unlikely to be useful otherwise.</source>
          <target state="translated">如果当前线程在ForkJoinPool中运行，则取消计划并返回（如果不执行）从外部提交到池中的任务（如果有）。可用性可能是暂时的，因此， &lt;code&gt;null&lt;/code&gt; 结果不一定表示池处于静止状态。此方法主要是为了支持扩展而设计的，否则不太可能有用。</target>
        </trans-unit>
        <trans-unit id="e3e28b29b93f45a59813378f46cf35c86d696607" translate="yes" xml:space="preserve">
          <source>If the current thread is operating in a ForkJoinPool, unschedules and returns, without executing, the next task queued by the current thread but not yet executed, if one is available, or if not available, a task that was forked by some other thread, if available.</source>
          <target state="translated">如果当前线程在ForkJoinPool中运行,如果有当前线程排队但尚未执行的下一个任务,则取消排队并返回,不执行;如果没有,则返回被其他线程分叉的任务(如果有)。</target>
        </trans-unit>
        <trans-unit id="644fbda54838e93f9bd7f153a0b223117b46c3c3" translate="yes" xml:space="preserve">
          <source>If the current thread is operating in a ForkJoinPool, unschedules and returns, without executing, the next task queued by the current thread but not yet executed, if one is available, or if not available, a task that was forked by some other thread, if available. Availability may be transient, so a &lt;code&gt;null&lt;/code&gt; result does not necessarily imply quiescence of the pool this task is operating in. This method is designed primarily to support extensions, and is unlikely to be useful otherwise.</source>
          <target state="translated">如果当前线程在ForkJoinPool中运行，则对当前线程排队但尚未执行的下一个任务进行调度并返回而不执行，如果一个任务可用，或者如果不可用，则是由其他线程分叉的任务，如果可供使用的话。可用性可能是暂时的，因此， &lt;code&gt;null&lt;/code&gt; 结果不一定表示该任务正在运行的池处于静止状态。此方法主要是为了支持扩展而设计的，否则不太可能有用。</target>
        </trans-unit>
        <trans-unit id="9d049c03bd38570f1b5a5d1aad9ff5cbfe4db5f0" translate="yes" xml:space="preserve">
          <source>If the current thread is the holder of this lock then the hold count is decremented. If the hold count is now zero then the lock is released. If the current thread is not the holder of this lock then &lt;a href=&quot;../../../lang/illegalmonitorstateexception&quot;&gt;&lt;code&gt;IllegalMonitorStateException&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">如果当前线程是此锁的持有者，则保留计数将减少。如果保持计数现在为零，则释放锁定。如果当前线程不是此锁的持有者，则抛出&lt;a href=&quot;../../../lang/illegalmonitorstateexception&quot;&gt; &lt;code&gt;IllegalMonitorStateException&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2cbfc6598ed6d1e50de22bbc3b671f7d2bef7cad" translate="yes" xml:space="preserve">
          <source>If the current thread is the last thread to arrive, and a non-null barrier action was supplied in the constructor, then the current thread runs the action before allowing the other threads to continue. If an exception occurs during the barrier action then that exception will be propagated in the current thread and the barrier is placed in the broken state.</source>
          <target state="translated">如果当前线程是最后到达的线程,并且在构造函数中提供了一个非空的屏障动作,那么当前线程在允许其他线程继续之前运行该动作。如果在屏障动作过程中发生了异常,那么该异常将在当前线程中传播,屏障将被置于破损状态。</target>
        </trans-unit>
        <trans-unit id="b1e09d61076e9dee8c7eca8604a1a4fdebca47aa" translate="yes" xml:space="preserve">
          <source>If the current thread's interrupted status is set when it enters this method, or it is &lt;a href=&quot;../../../lang/thread#interrupt()&quot;&gt;interrupted&lt;/a&gt; while waiting, it will continue to wait until signalled. When it finally returns from this method its interrupted status will still be set.</source>
          <target state="translated">如果当前线程进入此方法时设置了中断状态，或者在等待时被&lt;a href=&quot;../../../lang/thread#interrupt()&quot;&gt;中断&lt;/a&gt;，它将继续等待，直到发出信号为止。当它最终从该方法返回时，其中断状态仍将被设置。</target>
        </trans-unit>
        <trans-unit id="480b46196b0983b7baf6bc149cb22ece25ccb0df" translate="yes" xml:space="preserve">
          <source>If the current thread's interrupted status is set when it enters this method, or it is &lt;a href=&quot;../../../lang/thread#interrupt--&quot;&gt;interrupted&lt;/a&gt; while waiting, it will continue to wait until signalled. When it finally returns from this method its interrupted status will still be set.</source>
          <target state="translated">如果当前线程进入此方法时设置了中断状态，或者在等待时被&lt;a href=&quot;../../../lang/thread#interrupt--&quot;&gt;中断&lt;/a&gt;，它将继续等待直到发出信号。当它最终从该方法返回时，其中断状态仍将被设置。</target>
        </trans-unit>
        <trans-unit id="b9ceafb860d280bdbbb95ef180a5ebfa010ab70b" translate="yes" xml:space="preserve">
          <source>If the current thread:</source>
          <target state="translated">如果当前线。</target>
        </trans-unit>
        <trans-unit id="1b6dd611de80c284ec3983e42c194ba2625b5744" translate="yes" xml:space="preserve">
          <source>If the current token is a number, this field contains the value of that number.</source>
          <target state="translated">如果当前的标记是一个数字,这个字段包含该数字的值。</target>
        </trans-unit>
        <trans-unit id="a766629228a237157e338578f73608fe87ee3533" translate="yes" xml:space="preserve">
          <source>If the current token is a number, this field contains the value of that number. The current token is a number when the value of the &lt;code&gt;ttype&lt;/code&gt; field is &lt;code&gt;TT_NUMBER&lt;/code&gt;.</source>
          <target state="translated">如果当前令牌是数字，则此字段包含该数字的值。当 &lt;code&gt;ttype&lt;/code&gt; 字段的值为 &lt;code&gt;TT_NUMBER&lt;/code&gt; 时，当前令牌是一个数字。</target>
        </trans-unit>
        <trans-unit id="b366b28cb0c7e588029e3e176037326753259a0b" translate="yes" xml:space="preserve">
          <source>If the current token is a word token, this field contains a string giving the characters of the word token.</source>
          <target state="translated">如果当前标记是单词标记,该字段包含一个字符串,提供单词标记的字符。</target>
        </trans-unit>
        <trans-unit id="6e1d9b63def477efdc3e54487d9fe89e9c35bd3c" translate="yes" xml:space="preserve">
          <source>If the current token is a word token, this field contains a string giving the characters of the word token. When the current token is a quoted string token, this field contains the body of the string.</source>
          <target state="translated">如果当前标记是单词标记,则此字段包含单词标记的字符串。当当前标记为引号标记时,该字段包含字符串的主体。</target>
        </trans-unit>
        <trans-unit id="b562295eceffafbb5ee1280fac546021ba6d2f83" translate="yes" xml:space="preserve">
          <source>If the currently selected input method or keyboard layout supports the requested locale, it remains selected.</source>
          <target state="translated">如果当前选择的输入法或键盘布局支持所要求的语言,则保持选择。</target>
        </trans-unit>
        <trans-unit id="e560277f9d287926b99c30eb8d401571d2c384c5" translate="yes" xml:space="preserve">
          <source>If the data to be updated has already been changed in the data source, there is a conflict, in which case the writer will not write the changes to the data source. The algorithm the writer uses for preventing or limiting conflicts depends entirely on its implementation.</source>
          <target state="translated">如果要更新的数据在数据源中已经发生了变化,就会出现冲突,在这种情况下,写入器将不会把变化写入数据源。写入器用于防止或限制冲突的算法完全取决于它的实现。</target>
        </trans-unit>
        <trans-unit id="4610902d947f8dfa90bc178c559c33b46139cb9c" translate="yes" xml:space="preserve">
          <source>If the database supports SQL distinct types, then getTypeInfo() will return a single row with a TYPE_NAME of DISTINCT and a DATA_TYPE of Types.DISTINCT. If the database supports SQL structured types, then getTypeInfo() will return a single row with a TYPE_NAME of STRUCT and a DATA_TYPE of Types.STRUCT.</source>
          <target state="translated">如果数据库支持SQL distinct类型,那么getTypeInfo()将返回一条TYPE_NAME为DISTINCT和DATA_TYPE为Types.DISTINCT的单行。如果数据库支持SQL结构化类型,那么getTypeInfo()将返回一条具有TYPE_NAME of STRUCT和DATA_TYPE of Types.STRUCT的单行。</target>
        </trans-unit>
        <trans-unit id="a247e695dc806480de65475cdb7e49df5eec14fe" translate="yes" xml:space="preserve">
          <source>If the day-of-month is invalid for the year, it will be changed to the last valid day of the month.</source>
          <target state="translated">如果该年的月份无效,将改为该月的最后一天有效。</target>
        </trans-unit>
        <trans-unit id="5735c07ca103e22b6407b4ed7457c3834e66f98c" translate="yes" xml:space="preserve">
          <source>If the day-of-week is not available to format or parse then jump to day-of-month.</source>
          <target state="translated">如果没有星期的格式或解析,则跳转到月份的日期。</target>
        </trans-unit>
        <trans-unit id="e4a38749edf09c8d242c279b91b8274b568cddfc" translate="yes" xml:space="preserve">
          <source>If the declared type of the field is a parameterized type, the &lt;code&gt;Type&lt;/code&gt; object returned must accurately reflect the actual type arguments used in the source code.</source>
          <target state="translated">如果字段的声明类型是参数化类型，则返回的 &lt;code&gt;Type&lt;/code&gt; 对象必须准确反映源代码中使用的实际类型参数。</target>
        </trans-unit>
        <trans-unit id="680a3260a09bc245ba12ad31e3216d2204601bd3" translate="yes" xml:space="preserve">
          <source>If the declared type of the record component is a parameterized type, the &lt;code&gt;Type&lt;/code&gt; object returned reflects the actual type arguments used in the source code.</source>
          <target state="translated">如果记录组件的声明类型是参数化类型，则返回的 &lt;code&gt;Type&lt;/code&gt; 对象将反映源代码中使用的实际类型参数。</target>
        </trans-unit>
        <trans-unit id="836dc244145205490ef4ca5e728f09d48ff45702" translate="yes" xml:space="preserve">
          <source>If the decoded byte output of the needed size can not be allocated, the decode methods of this class will cause an &lt;a href=&quot;../lang/outofmemoryerror&quot;&gt;&lt;code&gt;OutOfMemoryError&lt;/code&gt;&lt;/a&gt; to be thrown.</source>
          <target state="translated">如果无法分配所需大小的解码字节输出，则此类的解码方法将引发&lt;a href=&quot;../lang/outofmemoryerror&quot;&gt; &lt;code&gt;OutOfMemoryError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f18de43b225ddbb14630d1c44418bb878cab7e5f" translate="yes" xml:space="preserve">
          <source>If the default &lt;a href=&quot;locale.category#DISPLAY&quot;&gt;&lt;code&gt;DISPLAY&lt;/code&gt;&lt;/a&gt; locale contains &quot;rg&quot; (region override) &lt;a href=&quot;locale#def_locale_extension&quot;&gt;Unicode extension&lt;/a&gt;, the symbol returned from this method reflects the value specified with that extension.</source>
          <target state="translated">如果默认的&lt;a href=&quot;locale.category#DISPLAY&quot;&gt; &lt;code&gt;DISPLAY&lt;/code&gt; &lt;/a&gt;语言环境包含&amp;ldquo; rg&amp;rdquo;（区域覆盖）&lt;a href=&quot;locale#def_locale_extension&quot;&gt;Unicode扩展名&lt;/a&gt;，则此方法返回的符号将反映该扩展名指定的值。</target>
        </trans-unit>
        <trans-unit id="dfa93f2a463d291904aa277d4928f5e5cc774981" translate="yes" xml:space="preserve">
          <source>If the default behavior is not desired, then a Java security property can be set to a different Time-to-live (TTL) value for positive caching. Likewise, a system admin can configure a different negative caching TTL value when needed.</source>
          <target state="translated">如果不需要默认的行为,那么可以将Java安全属性设置为不同的正向缓存的上线时间(TTL)值。同样,系统管理员也可以在需要时配置不同的负缓存TTL值。</target>
        </trans-unit>
        <trans-unit id="6889d388923a46b89918d04e5ceb2d2c40c4a81f" translate="yes" xml:space="preserve">
          <source>If the default drag cursor behavior is active, this method sets the default drag cursor for the specified actions supported by the drag source, the drop target action, and status, otherwise this method does nothing.</source>
          <target state="translated">如果默认的拖动光标行为处于活动状态,本方法将为拖动源支持的指定动作、投放目标动作和状态设置默认的拖动光标,否则本方法不做任何操作。</target>
        </trans-unit>
        <trans-unit id="28ec4fb264f4592c3191c9dfa387e6201501d30a" translate="yes" xml:space="preserve">
          <source>If the descriptor encoded in the byte buffer does not indicate a set of packages in the module then the &lt;code&gt;packageFinder&lt;/code&gt; will be invoked. The set of packages that the &lt;code&gt;packageFinder&lt;/code&gt; returns must include all the packages that the module exports, opens, as well as the packages of the service implementations that the module provides, and the package of the main class (if the module has a main class). If the &lt;code&gt;packageFinder&lt;/code&gt; throws an &lt;a href=&quot;../../io/uncheckedioexception&quot;&gt;&lt;code&gt;UncheckedIOException&lt;/code&gt;&lt;/a&gt; then &lt;a href=&quot;../../io/ioexception&quot;&gt;&lt;code&gt;IOException&lt;/code&gt;&lt;/a&gt; cause will be re-thrown.</source>
          <target state="translated">如果在字节缓冲区中编码的描述符未指示模块中的一组软件包，则将调用 &lt;code&gt;packageFinder&lt;/code&gt; 。 &lt;code&gt;packageFinder&lt;/code&gt; 返回的软件包集合必须包括模块导出，打开的所有软件包，以及该模块提供的服务实现的软件包，以及主类的软件包（如果模块具有主类） 。如果 &lt;code&gt;packageFinder&lt;/code&gt; 抛出&lt;a href=&quot;../../io/uncheckedioexception&quot;&gt; &lt;code&gt;UncheckedIOException&lt;/code&gt; ,&lt;/a&gt;则将重新抛出&lt;a href=&quot;../../io/ioexception&quot;&gt; &lt;code&gt;IOException&lt;/code&gt; &lt;/a&gt;原因。</target>
        </trans-unit>
        <trans-unit id="b98052904a44628625b06f819a5054b172f83074" translate="yes" xml:space="preserve">
          <source>If the descriptor encoded in the input stream does not indicate a set of packages in the module then the &lt;code&gt;packageFinder&lt;/code&gt; will be invoked. The set of packages that the &lt;code&gt;packageFinder&lt;/code&gt; returns must include all the packages that the module exports, opens, as well as the packages of the service implementations that the module provides, and the package of the main class (if the module has a main class). If the &lt;code&gt;packageFinder&lt;/code&gt; throws an &lt;a href=&quot;../../io/uncheckedioexception&quot;&gt;&lt;code&gt;UncheckedIOException&lt;/code&gt;&lt;/a&gt; then &lt;a href=&quot;../../io/ioexception&quot;&gt;&lt;code&gt;IOException&lt;/code&gt;&lt;/a&gt; cause will be re-thrown.</source>
          <target state="translated">如果输入流中编码的描述符未指示模块中的一组软件包，则将调用 &lt;code&gt;packageFinder&lt;/code&gt; 。 &lt;code&gt;packageFinder&lt;/code&gt; 返回的软件包集合必须包括模块导出，打开的所有软件包，以及该模块提供的服务实现的软件包，以及主类的软件包（如果模块具有主类） 。如果 &lt;code&gt;packageFinder&lt;/code&gt; 抛出&lt;a href=&quot;../../io/uncheckedioexception&quot;&gt; &lt;code&gt;UncheckedIOException&lt;/code&gt; ,&lt;/a&gt;则将重新抛出&lt;a href=&quot;../../io/ioexception&quot;&gt; &lt;code&gt;IOException&lt;/code&gt; &lt;/a&gt;原因。</target>
        </trans-unit>
        <trans-unit id="b2cac5e3a466b13ae80c01fca973dcf37b93b686" translate="yes" xml:space="preserve">
          <source>If the descriptor is empty the following String is returned: &amp;lt;Descriptor&amp;gt;&amp;lt;/Descriptor&amp;gt;</source>
          <target state="translated">如果描述符为空，则返回以下字符串：&amp;lt;Descriptor&amp;gt; &amp;lt;/ Descriptor&amp;gt;</target>
        </trans-unit>
        <trans-unit id="873e8f5cab98a9e1326f6e91f9c4bb6efc23d9fb" translate="yes" xml:space="preserve">
          <source>If the designated column has a datatype of CHAR or VARCHAR and contains a &quot;0&quot; or has a datatype of BIT, TINYINT, SMALLINT, INTEGER or BIGINT and contains a 0, a value of &lt;code&gt;false&lt;/code&gt; is returned. If the designated column has a datatype of CHAR or VARCHAR and contains a &quot;1&quot; or has a datatype of BIT, TINYINT, SMALLINT, INTEGER or BIGINT and contains a 1, a value of &lt;code&gt;true&lt;/code&gt; is returned.</source>
          <target state="translated">如果指定的列的数据类型为CHAR或VARCHAR，并且包含&amp;ldquo; 0&amp;rdquo;，或者数据类型为BIT，TINYINT，SMALLINT，INTEGER或BIGINT，并且包含0，则返回 &lt;code&gt;false&lt;/code&gt; 值。如果指定的列的数据类型为CHAR或VARCHAR，并且包含&amp;ldquo; 1&amp;rdquo;，或者数据类型为BIT，TINYINT，SMALLINT，INTEGER或BIGINT，并且包含1，则返回 &lt;code&gt;true&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="8424e147bec876cffc18c36963ed5006f3be55ca" translate="yes" xml:space="preserve">
          <source>If the desired URL is not the one currently being displayed, the &lt;code&gt;getStream&lt;/code&gt; method is called to give subclasses control over the stream provided.</source>
          <target state="translated">如果所需的URL不是当前显示的URL，则调用 &lt;code&gt;getStream&lt;/code&gt; 方法以使子类对提供的流进行控制。</target>
        </trans-unit>
        <trans-unit id="3e04d7b4037ef0253d1eb9639910efd968b0cd89" translate="yes" xml:space="preserve">
          <source>If the desired member is &lt;code&gt;protected&lt;/code&gt;, the usual JVM rules apply, including the requirement that the lookup class must be either be in the same package as the desired member, or must inherit that member. (See the Java Virtual Machine Specification, sections 4.9.2, 5.4.3.5, and 6.4.) In addition, if the desired member is a non-static field or method in a different package, the resulting method handle may only be applied to objects of the lookup class or one of its subclasses. This requirement is enforced by narrowing the type of the leading &lt;code&gt;this&lt;/code&gt; parameter from &lt;code&gt;C&lt;/code&gt; (which will necessarily be a superclass of the lookup class) to the lookup class itself.</source>
          <target state="translated">如果所需的成员 &lt;code&gt;protected&lt;/code&gt; ，则适用常规JVM规则，包括要求查找类必须与所需的成员位于同一程序包中，或者必须继承该成员。 （请参阅Java虚拟机规范，第4.9.2、5.4.3.5和6.4节。）此外，如果所需成员是非静态字段或其他程序包中的方法，则结果方法句柄可能仅应用于查找类或其子类之一的对象。通过 &lt;code&gt;this&lt;/code&gt; 参数的类型从 &lt;code&gt;C&lt;/code&gt; （必然是查找类的超类）缩小到查找类本身，可以强制实施此要求。</target>
        </trans-unit>
        <trans-unit id="9cfcd353d5f1c2be5e212dcf6a896c2900365e70" translate="yes" xml:space="preserve">
          <source>If the desired member is &lt;code&gt;protected&lt;/code&gt;, the usual JVM rules apply, including the requirement that the lookup class must either be in the same package as the desired member, or must inherit that member. (See the Java Virtual Machine Specification, sections &lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se15/html/jvms-4.html#jls-4.9.2&quot;&gt;4.9.2&lt;/a&gt;, &lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se15/html/jvms-5.html#jls-5.4.3.5&quot;&gt;5.4.3.5&lt;/a&gt;, and &lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se15/html/jvms-6.html#jls-6.4&quot;&gt;6.4&lt;/a&gt;.) In addition, if the desired member is a non-static field or method in a different package, the resulting method handle may only be applied to objects of the lookup class or one of its subclasses. This requirement is enforced by narrowing the type of the leading &lt;code&gt;this&lt;/code&gt; parameter from &lt;code&gt;C&lt;/code&gt; (which will necessarily be a superclass of the lookup class) to the lookup class itself.</source>
          <target state="translated">如果所需的成员 &lt;code&gt;protected&lt;/code&gt; ，则适用常规的JVM规则，包括要求查找类必须与所需的成员位于同一程序包中，或者必须继承该成员。（请参阅Java虚拟机规范，部分&lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se15/html/jvms-4.html#jls-4.9.2&quot;&gt;4.9.2&lt;/a&gt;，&lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se15/html/jvms-5.html#jls-5.4.3.5&quot;&gt;5.4.3.5&lt;/a&gt;，和&lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se15/html/jvms-6.html#jls-6.4&quot;&gt;6.4&lt;/a&gt;。）此外，如果所期望的构件是在不同的封装中的非静态字段或方法，所得到的方法手柄可仅被应用到查找类或其子类之一的对象。通过 &lt;code&gt;this&lt;/code&gt; 参数的类型从 &lt;code&gt;C&lt;/code&gt; （必然是查找类的超类）缩小到查找类本身，可以强制实施此要求。</target>
        </trans-unit>
        <trans-unit id="ff1be7735213926c3d2c892b139efeed267ca86c" translate="yes" xml:space="preserve">
          <source>If the destination &lt;code&gt;Raster&lt;/code&gt; is null, a new &lt;code&gt;Raster&lt;/code&gt; is created. An &lt;code&gt;IllegalArgumentException&lt;/code&gt; may be thrown if the source is the same as the destination or if the number of bands in the source is not equal to the number of bands in the destination.</source>
          <target state="translated">如果目标 &lt;code&gt;Raster&lt;/code&gt; 为空，则创建一个新的 &lt;code&gt;Raster&lt;/code&gt; 。一个 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 如果源是相同的目的地，或者如果在源频带的数目不等于在目标频带的数量可以被抛出。</target>
        </trans-unit>
        <trans-unit id="562d186cddc9b882f1164e575c0ca6cdd70e8771" translate="yes" xml:space="preserve">
          <source>If the destination is &lt;a href=&quot;processbuilder.redirect#PIPE&quot;&gt;&lt;code&gt;Redirect.PIPE&lt;/code&gt;&lt;/a&gt; (the initial value), then the error output of a subprocess can be read using the input stream returned by &lt;a href=&quot;process#getErrorStream()&quot;&gt;&lt;code&gt;Process.getErrorStream()&lt;/code&gt;&lt;/a&gt;. If the destination is set to any other value, then &lt;a href=&quot;process#getErrorStream()&quot;&gt;&lt;code&gt;Process.getErrorStream()&lt;/code&gt;&lt;/a&gt; will return a &lt;a href=&quot;#redirect-output&quot;&gt;null input stream&lt;/a&gt;.</source>
          <target state="translated">如果目标是&lt;a href=&quot;processbuilder.redirect#PIPE&quot;&gt; &lt;code&gt;Redirect.PIPE&lt;/code&gt; &lt;/a&gt;（初始值），则可以使用&lt;a href=&quot;process#getErrorStream()&quot;&gt; &lt;code&gt;Process.getErrorStream()&lt;/code&gt; &lt;/a&gt;返回的输入流读取子流程的错误输出。如果目的地设置为任何其他值，则&lt;a href=&quot;process#getErrorStream()&quot;&gt; &lt;code&gt;Process.getErrorStream()&lt;/code&gt; &lt;/a&gt;将返回&lt;a href=&quot;#redirect-output&quot;&gt;空输入流&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2f1759b66bcf0473ca1f75eb77e287f807f0be61" translate="yes" xml:space="preserve">
          <source>If the destination is &lt;a href=&quot;processbuilder.redirect#PIPE&quot;&gt;&lt;code&gt;Redirect.PIPE&lt;/code&gt;&lt;/a&gt; (the initial value), then the error output of a subprocess can be read using the input stream returned by &lt;a href=&quot;process#getErrorStream--&quot;&gt;&lt;code&gt;Process.getErrorStream()&lt;/code&gt;&lt;/a&gt;. If the destination is set to any other value, then &lt;a href=&quot;process#getErrorStream--&quot;&gt;&lt;code&gt;Process.getErrorStream()&lt;/code&gt;&lt;/a&gt; will return a &lt;a href=&quot;#redirect-output&quot;&gt;null input stream&lt;/a&gt;.</source>
          <target state="translated">如果目的地是&lt;a href=&quot;processbuilder.redirect#PIPE&quot;&gt; &lt;code&gt;Redirect.PIPE&lt;/code&gt; &lt;/a&gt;（初始值），则可以使用&lt;a href=&quot;process#getErrorStream--&quot;&gt; &lt;code&gt;Process.getErrorStream()&lt;/code&gt; &lt;/a&gt;返回的输入流读取子流程的错误输出。如果目标设置为任何其他值，则&lt;a href=&quot;process#getErrorStream--&quot;&gt; &lt;code&gt;Process.getErrorStream()&lt;/code&gt; &lt;/a&gt;将返回&lt;a href=&quot;#redirect-output&quot;&gt;空输入流&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3ca5de5b614e7eb26d543dee9c4a10ca118934c5" translate="yes" xml:space="preserve">
          <source>If the destination is &lt;a href=&quot;processbuilder.redirect#PIPE&quot;&gt;&lt;code&gt;Redirect.PIPE&lt;/code&gt;&lt;/a&gt; (the initial value), then the standard output of a subprocess can be read using the input stream returned by &lt;a href=&quot;process#getInputStream()&quot;&gt;&lt;code&gt;Process.getInputStream()&lt;/code&gt;&lt;/a&gt;. If the destination is set to any other value, then &lt;a href=&quot;process#getInputStream()&quot;&gt;&lt;code&gt;Process.getInputStream()&lt;/code&gt;&lt;/a&gt; will return a &lt;a href=&quot;#redirect-output&quot;&gt;null input stream&lt;/a&gt;.</source>
          <target state="translated">如果目的地是&lt;a href=&quot;processbuilder.redirect#PIPE&quot;&gt; &lt;code&gt;Redirect.PIPE&lt;/code&gt; &lt;/a&gt;（初始值），则可以使用&lt;a href=&quot;process#getInputStream()&quot;&gt; &lt;code&gt;Process.getInputStream()&lt;/code&gt; &lt;/a&gt;返回的输入流读取子流程的标准输出。如果目的地设置为任何其他值，则&lt;a href=&quot;process#getInputStream()&quot;&gt; &lt;code&gt;Process.getInputStream()&lt;/code&gt; &lt;/a&gt;将返回&lt;a href=&quot;#redirect-output&quot;&gt;空输入流&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b68154bc9bb15cf5c833579d040cf02c8940944f" translate="yes" xml:space="preserve">
          <source>If the destination is &lt;a href=&quot;processbuilder.redirect#PIPE&quot;&gt;&lt;code&gt;Redirect.PIPE&lt;/code&gt;&lt;/a&gt; (the initial value), then the standard output of a subprocess can be read using the input stream returned by &lt;a href=&quot;process#getInputStream--&quot;&gt;&lt;code&gt;Process.getInputStream()&lt;/code&gt;&lt;/a&gt;. If the destination is set to any other value, then &lt;a href=&quot;process#getInputStream--&quot;&gt;&lt;code&gt;Process.getInputStream()&lt;/code&gt;&lt;/a&gt; will return a &lt;a href=&quot;#redirect-output&quot;&gt;null input stream&lt;/a&gt;.</source>
          <target state="translated">如果目的地是&lt;a href=&quot;processbuilder.redirect#PIPE&quot;&gt; &lt;code&gt;Redirect.PIPE&lt;/code&gt; &lt;/a&gt;（初始值），则可以使用&lt;a href=&quot;process#getInputStream--&quot;&gt; &lt;code&gt;Process.getInputStream()&lt;/code&gt; &lt;/a&gt;返回的输入流读取子流程的标准输出。如果目的地设置为任何其他值，则&lt;a href=&quot;process#getInputStream--&quot;&gt; &lt;code&gt;Process.getInputStream()&lt;/code&gt; &lt;/a&gt;将返回&lt;a href=&quot;#redirect-output&quot;&gt;空输入流&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="24fa6417e10753014fbf446e67531a964d3dc7f5" translate="yes" xml:space="preserve">
          <source>If the destination is null, it will be created with a number of bands equalling the number of rows in the matrix. No exception is thrown if the operation causes a data overflow.</source>
          <target state="translated">如果目标值为空,则会创建一个与矩阵中行数相等的带状结构,如果操作导致数据溢出,则不会产生异常。如果该操作导致数据溢出,则不会产生异常。</target>
        </trans-unit>
        <trans-unit id="5814c260a49a2bf524faa7ed1d2bd24188a54959" translate="yes" xml:space="preserve">
          <source>If the destination's &lt;code&gt;append()&lt;/code&gt; method never throws &lt;code&gt;IOException&lt;/code&gt;, then this method will always return &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">如果目标的 &lt;code&gt;append()&lt;/code&gt; 方法从不抛出 &lt;code&gt;IOException&lt;/code&gt; ，则此方法将始终返回 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="00009ef2f2723f566d5cd7d5ea238cfdfa3f8286" translate="yes" xml:space="preserve">
          <source>If the determinant is non-zero, then this transform is invertible and the various methods that depend on the inverse transform do not need to throw a &lt;a href=&quot;noninvertibletransformexception&quot;&gt;&lt;code&gt;NoninvertibleTransformException&lt;/code&gt;&lt;/a&gt;. If the determinant is zero then this transform can not be inverted since the transform maps all input coordinates onto a line or a point. If the determinant is near enough to zero then inverse transform operations might not carry enough precision to produce meaningful results.</source>
          <target state="translated">如果行列式不为零，则此变换是可逆的，并且依赖于逆变换的各种方法都不需要抛出&lt;a href=&quot;noninvertibletransformexception&quot;&gt; &lt;code&gt;NoninvertibleTransformException&lt;/code&gt; &lt;/a&gt;。如果行列式为零，则此变换无法反转，因为该变换会将所有输入坐标映射到一条线或一个点上。如果行列式足够接近于零，则逆变换操作可能没有足够的精度来产生有意义的结果。</target>
        </trans-unit>
        <trans-unit id="1f6980173cd7348cb8d2c24081aedaf81b540b3f" translate="yes" xml:space="preserve">
          <source>If the device does not support setting a specific controller, this method returns 0 for that controller. Calling &lt;code&gt;controlChange&lt;/code&gt; will have no effect then.</source>
          <target state="translated">如果设备不支持设置特定的控制器，则此方法为该控制器返回0。调用 &lt;code&gt;controlChange&lt;/code&gt; 将不起作用。</target>
        </trans-unit>
        <trans-unit id="df1f0903f6dd8ca3989d88e94f2d77f67eb5ad33" translate="yes" xml:space="preserve">
          <source>If the device does not support setting channel pressure, this method always returns 0. Calling &lt;code&gt;setChannelPressure&lt;/code&gt; will have no effect then.</source>
          <target state="translated">如果设备不支持设置通道压力，则此方法始终返回0。然后，调用 &lt;code&gt;setChannelPressure&lt;/code&gt; 将无效。</target>
        </trans-unit>
        <trans-unit id="8233a3647bc57e6741c1cb20e7987108b8967295" translate="yes" xml:space="preserve">
          <source>If the device does not support setting poly pressure, this method always returns 0. Calling &lt;code&gt;setPolyPressure&lt;/code&gt; will have no effect then.</source>
          <target state="translated">如果设备不支持设置聚合压力，则此方法始终返回0。然后，调用 &lt;code&gt;setPolyPressure&lt;/code&gt; 将无效。</target>
        </trans-unit>
        <trans-unit id="f8a2d79cc304a6be8aee1283d70f86196ba6e581" translate="yes" xml:space="preserve">
          <source>If the dialog is modal and is not already visible, this call will not return until the dialog is hidden by calling hide or dispose. It is permissible to show modal dialogs from the event dispatching thread because the toolkit will ensure that another event pump runs while the one which invoked this method is blocked.</source>
          <target state="translated">如果对话框是模态的,而且还不可见,那么这个调用将不会返回,直到通过调用隐藏或处理来隐藏对话框。允许从事件派遣线程中显示模态对话框,因为工具包会确保在调用该方法的线程被阻塞时,另一个事件泵会运行。</target>
        </trans-unit>
        <trans-unit id="ec907f76145e8ddd032cdc8267ff559cc1c48182" translate="yes" xml:space="preserve">
          <source>If the digit is less than 10, then &lt;code&gt;'0' + digit&lt;/code&gt; is returned. Otherwise, the value &lt;code&gt;'a' + digit - 10&lt;/code&gt; is returned.</source>
          <target state="translated">如果数字小于10，则返回 &lt;code&gt;'0' + digit&lt;/code&gt; 。否则，返回值 &lt;code&gt;'a' + digit - 10&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d397471c9fa609642a9cc71822d0d3db3f61ef8d" translate="yes" xml:space="preserve">
          <source>If the directory does not support a string representation of some or all of its attributes, the form of &lt;code&gt;search&lt;/code&gt; that accepts filter arguments in the form of Objects can be used instead. The service provider for such a directory would then translate the filter arguments to its service-specific representation for filter evaluation. See &lt;code&gt;search(Name, String, Object[], SearchControls)&lt;/code&gt;.</source>
          <target state="translated">如果目录不支持部分或全部属性的字符串表示形式，则可以使用接受对象形式的过滤器参数的 &lt;code&gt;search&lt;/code&gt; 形式。然后，此类目录的服务提供者会将过滤器参数转换为其特定于服务的表示形式，以进行过滤器评估。参见 &lt;code&gt;search(Name, String, Object[], SearchControls)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="77d2e43114de0de16774d5ed4ecd9f6313b3e490" translate="yes" xml:space="preserve">
          <source>If the doctype-public or doctype-system properties are specified, then the html output method should output a document type declaration immediately before the first element. The name following &amp;lt;!DOCTYPE should be HTML or html. If the doctype-public property is specified, then the output method should output PUBLIC followed by the specified public identifier; if the doctype-system property is also specified, it should also output the specified system identifier following the public identifier. If the doctype-system property is specified but the doctype-public property is not specified, then the output method should output SYSTEM followed by the specified system identifier.</source>
          <target state="translated">如果指定了doctype-public或doctype-system属性，则html输出方法应在第一个元素之前输出文档类型声明。&amp;lt;！DOCTYPE之后的名称应为HTML或html。如果指定了doctype-public属性，则输出方法应输出PUBLIC，然后输出指定的公共标识符；否则，输出方法应为PUBLIC。如果还指定了doctype-system属性，则还应在公共标识符之后输出指定的系统标识符。如果指定了doctype-system属性，但未指定doctype-public属性，则输出方法应输出SYSTEM，后跟指定的系统标识符。</target>
        </trans-unit>
        <trans-unit id="86b3eab9594a91d2810de348de7dd9c40f4c769d" translate="yes" xml:space="preserve">
          <source>If the doctype-system property is specified, the xml output method should output a document type declaration immediately before the first element. The name following &amp;lt;!DOCTYPE should be the name of the first element. If doctype-public property is also specified, then the xml output method should output PUBLIC followed by the public identifier and then the system identifier; otherwise, it should output SYSTEM followed by the system identifier. The internal subset should be empty. The value of the doctype-public property should be ignored unless the doctype-system property is specified.</source>
          <target state="translated">如果指定了doctype-system属性，则xml输出方法应在第一个元素之前输出文档类型声明。&amp;lt;！DOCTYPE之后的名称应该是第一个元素的名称。如果还指定了doctype-public属性，则xml输出方法应输出PUBLIC，后跟公共标识符，然后是系统标识符；否则，应输出SYSTEM，后跟系统标识符。内部子集应该为空。除非指定了doctype-system属性，否则应忽略doctype-public属性的值。</target>
        </trans-unit>
        <trans-unit id="cee8facf69b90419835e8685cee670049ac617cb" translate="yes" xml:space="preserve">
          <source>If the document is loaded asynchronously, the document will be installed into the editor immediately using a call to &lt;code&gt;setDocument&lt;/code&gt; which will fire a document property change event, then a thread will be created which will begin doing the actual loading. In this case, the page property change event will not be fired by the call to this method directly, but rather will be fired when the thread doing the loading has finished. It will also be fired on the event-dispatch thread. Since the calling thread can not throw an &lt;code&gt;IOException&lt;/code&gt; in the event of failure on the other thread, the page property change event will be fired when the other thread is done whether the load was successful or not.</source>
          <target state="translated">如果文档是异步加载的，则将使用对 &lt;code&gt;setDocument&lt;/code&gt; 的调用立即将文档安装到编辑器中，这将触发文档属性更改事件，然后将创建一个线程，该线程将开始进行实际加载。在这种情况下，不会直接通过调用此方法来触发page属性更改事件，而是在完成加载的线程时将触发该事件。它还将在事件调度线程上触发。由于调用线程无法在另一个线程失败的情况下引发 &lt;code&gt;IOException&lt;/code&gt; ，因此无论加载成功与否，当另一个线程完成时，都会触发页面属性更改事件。</target>
        </trans-unit>
        <trans-unit id="7aa862933af1b586831035ab71ba5bcc647784cc" translate="yes" xml:space="preserve">
          <source>If the document is loaded synchronously, it will be filled in with the stream prior to being installed into the editor with a call to &lt;code&gt;setDocument&lt;/code&gt;, which is bound and will fire a property change event. If an &lt;code&gt;IOException&lt;/code&gt; is thrown the partially loaded document will be discarded and neither the document or page property change events will be fired. If the document is successfully loaded and installed, a view will be built for it by the UI which will then be scrolled if necessary, and then the page property change event will be fired.</source>
          <target state="translated">如果文档是同步加载的，则在将其安装到编辑器中之前，将通过调用 &lt;code&gt;setDocument&lt;/code&gt; 来将其填充到流中，该调用将被绑定并触发属性更改事件。如果引发 &lt;code&gt;IOException&lt;/code&gt; ,则部分加载的文档将被丢弃，并且不会触发文档或页面属性更改事件。如果文档已成功加载和安装，则UI将为其创建视图，然后在必要时滚动视图，然后将触发page属性更改事件。</target>
        </trans-unit>
        <trans-unit id="662626e1d4e27eb6ce910acdf4f7275869e7a388" translate="yes" xml:space="preserve">
          <source>If the document's schema is a DTD or no schema is associated with the document, this method will always return &lt;code&gt;false&lt;/code&gt; . If the document's schema is an XML Schema, the method will return &lt;code&gt;true&lt;/code&gt; if the reference type definition is derived from the other type definition according to the derivation parameter. If the value of the parameter is &lt;code&gt;0&lt;/code&gt; (no bit is set to &lt;code&gt;1&lt;/code&gt; for the &lt;code&gt;derivationMethod&lt;/code&gt; parameter), the method will return &lt;code&gt;true&lt;/code&gt; if the other type definition can be reached by recursing any combination of {base type definition}, {item type definition}, or {member type definitions} from the reference type definition.</source>
          <target state="translated">如果文档的模式是DTD或没有模式与文档关联，则此方法将始终返回 &lt;code&gt;false&lt;/code&gt; 。如果文档的架构是XML架构，并且引用类型定义是根据派生参数从另一个类型定义派生的，则该方法将返回 &lt;code&gt;true&lt;/code&gt; 。如果该参数的值是 &lt;code&gt;0&lt;/code&gt; （没有位被设置为 &lt;code&gt;1&lt;/code&gt; 用于 &lt;code&gt;derivationMethod&lt;/code&gt; 参数），该方法将返回 &lt;code&gt;true&lt;/code&gt; ，如果其它类型的定义可以通过递归{基本类型定义}，{项类型定义}的任意组合来达到，或引用类型定义中的{member type definitions}。</target>
        </trans-unit>
        <trans-unit id="57aa15be161d274da17fe9d39d1cfb694489d07e" translate="yes" xml:space="preserve">
          <source>If the document's schema is an XML DTD [&lt;a href=&quot;http://www.w3.org/TR/2004/REC-xml-20040204&quot;&gt;XML 1.0&lt;/a&gt;], the values are computed as follows:</source>
          <target state="translated">如果文档的架构是XML DTD [ &lt;a href=&quot;http://www.w3.org/TR/2004/REC-xml-20040204&quot;&gt;XML 1.0&lt;/a&gt; ]，则值的计算如下：</target>
        </trans-unit>
        <trans-unit id="2c1b98243027ae1c98645a593d178914a7c6839f" translate="yes" xml:space="preserve">
          <source>If the document's schema is an XML DTD [&lt;a href=&quot;https://www.w3.org/TR/2004/REC-xml-20040204&quot;&gt;XML 1.0&lt;/a&gt;], the values are computed as follows:</source>
          <target state="translated">如果文档的架构是XML DTD [ &lt;a href=&quot;https://www.w3.org/TR/2004/REC-xml-20040204&quot;&gt;XML 1.0&lt;/a&gt; ]，则值的计算如下：</target>
        </trans-unit>
        <trans-unit id="e10cb29a1e33b183a4131d16eb45066ea4a21c22" translate="yes" xml:space="preserve">
          <source>If the document's schema is an XML Schema [&lt;a href=&quot;http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/&quot;&gt;XML Schema Part 1&lt;/a&gt;] , the values are computed as follows using the post-schema-validation infoset contributions (also called PSVI contributions):</source>
          <target state="translated">如果文档的架构是XML架构[ &lt;a href=&quot;http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/&quot;&gt;XML架构第1部分&lt;/a&gt;]，则使用架构后验证信息集贡献（也称为PSVI贡献）按如下方式计算值：</target>
        </trans-unit>
        <trans-unit id="8f795881894f367bf4d53a272b0c02b6372a7907" translate="yes" xml:space="preserve">
          <source>If the document's schema is an XML Schema [&lt;a href=&quot;http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/&quot;&gt;XML Schema Part 1&lt;/a&gt;] , this constant represents the &lt;a href=&quot;http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/#element-list&quot;&gt;list&lt;/a&gt;.</source>
          <target state="translated">如果文档的架构是XML架构[ &lt;a href=&quot;http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/&quot;&gt;XML Schema Part 1&lt;/a&gt; ]，则此常数表示&lt;a href=&quot;http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/#element-list&quot;&gt;list&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d81ff9adf73e073ce8071daca81533194b267a61" translate="yes" xml:space="preserve">
          <source>If the document's schema is an XML Schema [&lt;a href=&quot;http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/&quot;&gt;XML Schema Part 1&lt;/a&gt;] , this constant represents the &lt;a href=&quot;http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/#element-union&quot;&gt; union&lt;/a&gt; if simple types are involved.</source>
          <target state="translated">如果文档的模式是XML Schema [ &lt;a href=&quot;http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/&quot;&gt;XML Schema Part 1&lt;/a&gt; ]，则在涉及简单类型时，此常量表示&lt;a href=&quot;http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/#element-union&quot;&gt;联合&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f779afced39b6f1300c741f0c131c9d3b3d3d63b" translate="yes" xml:space="preserve">
          <source>If the document's schema is an XML Schema [&lt;a href=&quot;http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/&quot;&gt;XML Schema Part 1&lt;/a&gt;] , this constant represents the derivation by &lt;a href=&quot;http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/#key-typeExtension&quot;&gt; extension&lt;/a&gt;.</source>
          <target state="translated">如果文档的架构是XML架构[ &lt;a href=&quot;http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/&quot;&gt;XML Schema Part 1&lt;/a&gt; ]，则此常量表示&lt;a href=&quot;http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/#key-typeExtension&quot;&gt;扩展名&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="31d86e81e617797ac0b52ef3cd63e328b705ec68" translate="yes" xml:space="preserve">
          <source>If the document's schema is an XML Schema [&lt;a href=&quot;http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/&quot;&gt;XML Schema Part 1&lt;/a&gt;] , this constant represents the derivation by &lt;a href=&quot;http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/#key-typeRestriction&quot;&gt; restriction&lt;/a&gt; if complex types are involved, or a &lt;a href=&quot;http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/#element-restriction&quot;&gt; restriction&lt;/a&gt; if simple types are involved.</source>
          <target state="translated">如果文档的模式是一个XML Schema [ &lt;a href=&quot;http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/&quot;&gt;XML模式第1&lt;/a&gt; ]，这个常数代表由所述导出&lt;a href=&quot;http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/#key-typeRestriction&quot;&gt;限制&lt;/a&gt;如果复杂类型参与，或&lt;a href=&quot;http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/#element-restriction&quot;&gt;限制&lt;/a&gt;，如果简单类型的参与。</target>
        </trans-unit>
        <trans-unit id="cbe9e7664e4f4017ad96a68076cc598006d5d112" translate="yes" xml:space="preserve">
          <source>If the document's schema is an XML Schema [&lt;a href=&quot;https://www.w3.org/TR/2001/REC-xmlschema-1-20010502/&quot;&gt;XML Schema Part 1&lt;/a&gt;] , the values are computed as follows using the post-schema-validation infoset contributions (also called PSVI contributions):</source>
          <target state="translated">如果文档的架构是XML架构[ &lt;a href=&quot;https://www.w3.org/TR/2001/REC-xmlschema-1-20010502/&quot;&gt;XML架构第1部分&lt;/a&gt;]，则使用架构后验证信息集贡献（也称为PSVI贡献）按如下方式计算值：</target>
        </trans-unit>
        <trans-unit id="a6f1168404c7c56d4e8e498e42bad0edb3c4bb73" translate="yes" xml:space="preserve">
          <source>If the document's schema is an XML Schema [&lt;a href=&quot;https://www.w3.org/TR/2001/REC-xmlschema-1-20010502/&quot;&gt;XML Schema Part 1&lt;/a&gt;] , this constant represents the &lt;a href=&quot;https://www.w3.org/TR/2001/REC-xmlschema-1-20010502/#element-list&quot;&gt;list&lt;/a&gt;.</source>
          <target state="translated">如果文档的架构是XML架构[ &lt;a href=&quot;https://www.w3.org/TR/2001/REC-xmlschema-1-20010502/&quot;&gt;XML Schema Part 1&lt;/a&gt; ]，则此常数表示&lt;a href=&quot;https://www.w3.org/TR/2001/REC-xmlschema-1-20010502/#element-list&quot;&gt;list&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7aae511fcf2af94431f32c6ee8cbcd05c4ea0a08" translate="yes" xml:space="preserve">
          <source>If the document's schema is an XML Schema [&lt;a href=&quot;https://www.w3.org/TR/2001/REC-xmlschema-1-20010502/&quot;&gt;XML Schema Part 1&lt;/a&gt;] , this constant represents the &lt;a href=&quot;https://www.w3.org/TR/2001/REC-xmlschema-1-20010502/#element-union&quot;&gt; union&lt;/a&gt; if simple types are involved.</source>
          <target state="translated">如果文档的模式是XML Schema [ &lt;a href=&quot;https://www.w3.org/TR/2001/REC-xmlschema-1-20010502/&quot;&gt;XML Schema Part 1&lt;/a&gt; ]，则在涉及简单类型时，此常量表示&lt;a href=&quot;https://www.w3.org/TR/2001/REC-xmlschema-1-20010502/#element-union&quot;&gt;联合&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8ba3d777f238d863319685e6c88d4e59e078f28f" translate="yes" xml:space="preserve">
          <source>If the document's schema is an XML Schema [&lt;a href=&quot;https://www.w3.org/TR/2001/REC-xmlschema-1-20010502/&quot;&gt;XML Schema Part 1&lt;/a&gt;] , this constant represents the derivation by &lt;a href=&quot;https://www.w3.org/TR/2001/REC-xmlschema-1-20010502/#key-typeExtension&quot;&gt; extension&lt;/a&gt;.</source>
          <target state="translated">如果文档的架构是XML架构[ &lt;a href=&quot;https://www.w3.org/TR/2001/REC-xmlschema-1-20010502/&quot;&gt;XML Schema Part 1&lt;/a&gt; ]，则此常量表示&lt;a href=&quot;https://www.w3.org/TR/2001/REC-xmlschema-1-20010502/#key-typeExtension&quot;&gt;扩展名&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="18883cd53e5a6700508528271465beb712205ee0" translate="yes" xml:space="preserve">
          <source>If the document's schema is an XML Schema [&lt;a href=&quot;https://www.w3.org/TR/2001/REC-xmlschema-1-20010502/&quot;&gt;XML Schema Part 1&lt;/a&gt;] , this constant represents the derivation by &lt;a href=&quot;https://www.w3.org/TR/2001/REC-xmlschema-1-20010502/#key-typeRestriction&quot;&gt; restriction&lt;/a&gt; if complex types are involved, or a &lt;a href=&quot;https://www.w3.org/TR/2001/REC-xmlschema-1-20010502/#element-restriction&quot;&gt; restriction&lt;/a&gt; if simple types are involved.</source>
          <target state="translated">如果文档的模式是一个XML Schema [ &lt;a href=&quot;https://www.w3.org/TR/2001/REC-xmlschema-1-20010502/&quot;&gt;XML模式第1&lt;/a&gt; ]，这个常数代表由所述导出&lt;a href=&quot;https://www.w3.org/TR/2001/REC-xmlschema-1-20010502/#key-typeRestriction&quot;&gt;限制&lt;/a&gt;如果复杂类型参与，或&lt;a href=&quot;https://www.w3.org/TR/2001/REC-xmlschema-1-20010502/#element-restriction&quot;&gt;限制&lt;/a&gt;，如果简单类型的参与。</target>
        </trans-unit>
        <trans-unit id="762fcdd3511f74261ffaaa36150e2a54b62d2512" translate="yes" xml:space="preserve">
          <source>If the domain includes at least one occurrence of the wildcard characters asterisk (&lt;code&gt;*&lt;/code&gt;) or question mark (&lt;code&gt;?&lt;/code&gt;), then the object name is a pattern. The asterisk matches any sequence of zero or more characters, while the question mark matches any single character.</source>
          <target state="translated">如果域中至少包含一次出现的通配符星号（ &lt;code&gt;*&lt;/code&gt; ）或问号（ &lt;code&gt;?&lt;/code&gt; ），则对象名称为模式。星号匹配零个或多个字符的任何序列，而问号匹配任何单个字符。</target>
        </trans-unit>
        <trans-unit id="b1cec24c27c8efb590156606b357f3a860a3a802" translate="yes" xml:space="preserve">
          <source>If the domain is empty, it will be replaced in certain contexts by the &lt;em&gt;default domain&lt;/em&gt; of the MBean server in which the ObjectName is used.</source>
          <target state="translated">如果该域为空，则在某些上下文中，它将被使用ObjectName的MBean服务器的&lt;em&gt;默认域&lt;/em&gt;替换。</target>
        </trans-unit>
        <trans-unit id="e3eaf7e155e25958dd79b0ca8cbf2ed30fa28298" translate="yes" xml:space="preserve">
          <source>If the driver does not support catalogs, it will silently ignore this request.</source>
          <target state="translated">如果驱动程序不支持目录,它将默默地忽略这个请求。</target>
        </trans-unit>
        <trans-unit id="49cc5727dc2cc7276bd0bd19c6deedc6d76a47a7" translate="yes" xml:space="preserve">
          <source>If the driver does not support schemas, it will silently ignore this request.</source>
          <target state="translated">如果驱动程序不支持模式,它将默默地忽略这个请求。</target>
        </trans-unit>
        <trans-unit id="2ec76dcdc78eed5e3ce7b1d5f25a9c8e1223867e" translate="yes" xml:space="preserve">
          <source>If the drop mode is &lt;code&gt;DropMode.INSERT&lt;/code&gt;, the return value refers to the path that should become the parent of the new data, in which case &lt;code&gt;getChildIndex()&lt;/code&gt; indicates where the new item should be inserted into this parent path. A &lt;code&gt;null&lt;/code&gt; path indicates that no parent path has been determined, which can happen for multiple reasons:</source>
          <target state="translated">如果放置模式为 &lt;code&gt;DropMode.INSERT&lt;/code&gt; ，则返回值指向应成为新数据父级的路径，在这种情况下， &lt;code&gt;getChildIndex()&lt;/code&gt; 指示将新项目插入此父级路径的位置。一个 &lt;code&gt;null&lt;/code&gt; 路径表示没有父路径已经确定，它可以发生于多种原因：</target>
        </trans-unit>
        <trans-unit id="7e77cff0b1d03502e9a750d78a9d1c0130ccaafc" translate="yes" xml:space="preserve">
          <source>If the drop mode is &lt;code&gt;DropMode.ON_OR_INSERT&lt;/code&gt;, &lt;code&gt;getChildIndex&lt;/code&gt; can be used to determine whether the drop is on top of the path itself (&lt;code&gt;-1&lt;/code&gt;) or the index at which it should be inserted into the path (values other than &lt;code&gt;-1&lt;/code&gt;).</source>
          <target state="translated">如果放置模式是 &lt;code&gt;DropMode.ON_OR_INSERT&lt;/code&gt; ， &lt;code&gt;getChildIndex&lt;/code&gt; 可用于确定液滴是否在路径本身（的顶部 &lt;code&gt;-1&lt;/code&gt; ）或指数在它应该被插入到路径（比其它值 &lt;code&gt;-1&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="561e98f303c7dc9236bf9ca6b8c00ec7bcd40ae7" translate="yes" xml:space="preserve">
          <source>If the editor is an instance of &lt;code&gt;DefaultEditor&lt;/code&gt;, the call if forwarded to the editor, otherwise this does nothing.</source>
          <target state="translated">如果编辑器是 &lt;code&gt;DefaultEditor&lt;/code&gt; 的实例，则将调用转发给编辑器，否则将不执行任何操作。</target>
        </trans-unit>
        <trans-unit id="9bc2230764f1928dcd4435430ac5eacac22d06da" translate="yes" xml:space="preserve">
          <source>If the element contains end-of-content mark (the last &lt;code&gt;
 &quot;\n&quot;&lt;/code&gt; character in document), this character is not removed; instead, preceding leaf element is extended to cover the character. If the last leaf already ends with &lt;code&gt;&quot;\n&quot;,&lt;/code&gt; it is included in content removal.</source>
          <target state="translated">如果元素包含内容结尾标记（文档中的最后一个 &lt;code&gt; &quot;\n&quot;&lt;/code&gt; 字符），则不会删除此字符；而是将前一个叶子元素扩展为覆盖该字符。如果最后一个叶子已经以 &lt;code&gt;&quot;\n&quot;,&lt;/code&gt; 结尾，则它将包含在内容删除中。</target>
        </trans-unit>
        <trans-unit id="f5906e0e63b8f49e34b6700f88bda4ec0d7f3b19" translate="yes" xml:space="preserve">
          <source>If the element is &lt;code&gt;null,&lt;/code&gt;&lt;code&gt;NullPointerException&lt;/code&gt; is thrown. If the element structure would become invalid after the removal, for example if the element is the document root element, &lt;code&gt;
 IllegalArgumentException&lt;/code&gt; is thrown. If the current element structure is invalid, &lt;code&gt;IllegalStateException&lt;/code&gt; is thrown.</source>
          <target state="translated">如果元素为 &lt;code&gt;null,&lt;/code&gt; 则抛出 &lt;code&gt;NullPointerException&lt;/code&gt; 。如果元素结构在删除后将变为无效，例如，如果该元素是文档根元素，则抛出 &lt;code&gt; IllegalArgumentException&lt;/code&gt; 。如果当前元素结构无效，则抛出 &lt;code&gt;IllegalStateException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="75155a89667cb2237cd0f9e72cff17a55ac4b5e0" translate="yes" xml:space="preserve">
          <source>If the element name has a namespace prefix, the prefix will still be attached to the name.</source>
          <target state="translated">如果元素名称有一个命名空间前缀,前缀仍然会被附加到名称上。</target>
        </trans-unit>
        <trans-unit id="292c4a6cbb150ef1068ec19842ed8e1904c50655" translate="yes" xml:space="preserve">
          <source>If the element name has a namespace prefix, the prefix will still be attached. Note that the attribute list provided will contain only attributes with explicit values (specified or defaulted): #IMPLIED attributes will be omitted.</source>
          <target state="translated">如果元素名有一个命名空间前缀,前缀仍然会被附加。请注意,所提供的属性列表将只包含具有显式值(指定或默认)的属性。#IMPLIED属性将被省略。</target>
        </trans-unit>
        <trans-unit id="26be7554fade8f3ee174b1c39de7db2088b22346" translate="yes" xml:space="preserve">
          <source>If the element type is a &lt;a href=&quot;#isHidden()&quot;&gt;hidden&lt;/a&gt; class or interface, then this array class cannot be described nominally. The result string is not a type descriptor.</source>
          <target state="translated">如果元素类型是&lt;a href=&quot;#isHidden()&quot;&gt;隐藏&lt;/a&gt;类或接口，则不能名义上描述此数组类。结果字符串不是类型描述符。</target>
        </trans-unit>
        <trans-unit id="18dd08f74ca34145a1c536a7fe2e41c8bb656227" translate="yes" xml:space="preserve">
          <source>If the element type is not a &lt;a href=&quot;#isHidden()&quot;&gt;hidden&lt;/a&gt; class or interface, then this array class can be described nominally. Calling &lt;a href=&quot;constant/classdesc#ofDescriptor(java.lang.String)&quot;&gt;&lt;code&gt;ClassDesc::ofDescriptor&lt;/code&gt;&lt;/a&gt; with the result descriptor string produces a &lt;a href=&quot;constant/classdesc&quot;&gt;&lt;code&gt;ClassDesc&lt;/code&gt;&lt;/a&gt; describing this array class.</source>
          <target state="translated">如果元素类型不是&lt;a href=&quot;#isHidden()&quot;&gt;隐藏的&lt;/a&gt;类或接口，则可以名义上描述此数组类。用结果描述符字符串调用&lt;a href=&quot;constant/classdesc#ofDescriptor(java.lang.String)&quot;&gt; &lt;code&gt;ClassDesc::ofDescriptor&lt;/code&gt; &lt;/a&gt;会生成描述此数组类的&lt;a href=&quot;constant/classdesc&quot;&gt; &lt;code&gt;ClassDesc&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="632011698fb01f0e0fc60062d6f97f830dba4d90" translate="yes" xml:space="preserve">
          <source>If the elements contain infinities of one sign and an intermediate sum overflows to an infinity of the opposite sign, the sum may be NaN.</source>
          <target state="translated">如果元素中含有一个符号的无穷大,中间的和溢出到一个相反符号的无穷大,那么这个和可能是NaN。</target>
        </trans-unit>
        <trans-unit id="925e78d915a458c34d3eb7516f6e0b5010e2a01e" translate="yes" xml:space="preserve">
          <source>If the elements contain infinities of opposite sign, the sum will be NaN.</source>
          <target state="translated">如果元素中含有相反符号的无穷大,则和为NaN。</target>
        </trans-unit>
        <trans-unit id="be74757b15685dd5fdb4eea579602429c42b5b4c" translate="yes" xml:space="preserve">
          <source>If the elements contain one or more infinities, the sum will be infinite or NaN.</source>
          <target state="translated">如果元素中含有一个或多个无穷大,则和将是无穷大或NaN。</target>
        </trans-unit>
        <trans-unit id="1e256faf6974a8c97c36c1d2dc5a8b6122f7344d" translate="yes" xml:space="preserve">
          <source>If the elements of the source Vector of the ParameterBlock used to construct the RenderableImageOp are instances of RenderedImage, then the CRIF.create() method is called immediately using the original ParameterBlock. This provides a basis case for the recursion.</source>
          <target state="translated">如果用于构造RenderableImageOp的ParameterBlock的源Vector的元素是RenderedImage的实例,那么CRIF.create()方法将使用原始ParameterBlock立即调用。这就为递归提供了一个基础案例。</target>
        </trans-unit>
        <trans-unit id="65b15f4158c3ccc225eea910594e13a346b7fa3c" translate="yes" xml:space="preserve">
          <source>If the encoded byte output of the needed size can not be allocated, the encode methods of this class will cause an &lt;a href=&quot;../lang/outofmemoryerror&quot;&gt;&lt;code&gt;OutOfMemoryError&lt;/code&gt;&lt;/a&gt; to be thrown.</source>
          <target state="translated">如果无法分配所需大小的编码字节输出，则此类的编码方法将引发&lt;a href=&quot;../lang/outofmemoryerror&quot;&gt; &lt;code&gt;OutOfMemoryError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="166569c27e8b2a7656f585d48975b7df17589d30" translate="yes" xml:space="preserve">
          <source>If the encoding has an historical name then that name is returned; otherwise the encoding's canonical name is returned.</source>
          <target state="translated">如果编码有历史名称,那么将返回该名称;否则将返回编码的规范名称。</target>
        </trans-unit>
        <trans-unit id="3837fdfef6f0110640afb54a092f9fb29173f9df" translate="yes" xml:space="preserve">
          <source>If the end of the stream is encountered before all the bits have been read, a &lt;code&gt;java.io.EOFException&lt;/code&gt; is thrown.</source>
          <target state="translated">如果在读取所有位之前遇到流的末尾，则将引发 &lt;code&gt;java.io.EOFException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="48c3f477e37a6d7f2bde864091bbef88c4c21567" translate="yes" xml:space="preserve">
          <source>If the end of the stream is encountered before all the bits have been read, an &lt;code&gt;java.io.EOFException&lt;/code&gt; is thrown.</source>
          <target state="translated">如果在读取所有位之前遇到流的末尾，则将抛出 &lt;code&gt;java.io.EOFException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2217350c5c68b3e5ab4a98715b4b5c48f6366d39" translate="yes" xml:space="preserve">
          <source>If the entire string has been read or skipped, then this method has no effect and always returns 0.</source>
          <target state="translated">如果整个字符串已经被读取或跳过,那么这个方法没有任何效果,总是返回0。</target>
        </trans-unit>
        <trans-unit id="8ece76de2aa9cb829e9b2c9714827801ca68dc1f" translate="yes" xml:space="preserve">
          <source>If the entry being considered was created by a call to &lt;code&gt;setKeyEntry&lt;/code&gt;, or created by a call to &lt;code&gt;setEntry&lt;/code&gt; with a &lt;code&gt;PrivateKeyEntry&lt;/code&gt;, then the given certificate is compared to the first element of that entry's certificate chain.</source>
          <target state="translated">如果考虑的条目是通过调用 &lt;code&gt;setKeyEntry&lt;/code&gt; 创建的，或者是通过调用带有 &lt;code&gt;PrivateKeyEntry&lt;/code&gt; 的 &lt;code&gt;setEntry&lt;/code&gt; 创建的，则将给定的证书与该条目的证书链的第一个元素进行比较。</target>
        </trans-unit>
        <trans-unit id="901709c9c92242d1f05529c7ed99092d836cea48" translate="yes" xml:space="preserve">
          <source>If the entry is output to a ZIP file or ZIP file formatted output stream the last modification time set by this method will be stored into the &lt;code&gt;date and time fields&lt;/code&gt; of the zip file entry and encoded in standard &lt;code&gt;MS-DOS date and time format&lt;/code&gt;. If the date-time set is out of the range of the standard &lt;code&gt;
 MS-DOS date and time format&lt;/code&gt;, the time will also be stored into zip file entry's extended timestamp fields in &lt;code&gt;optional
 extra data&lt;/code&gt; in UTC time. The &lt;a href=&quot;../../time/zoneid#systemDefault()&quot;&gt;&lt;code&gt;system default TimeZone&lt;/code&gt;&lt;/a&gt; is used to convert the local date-time to UTC time.</source>
          <target state="translated">如果将条目输出到ZIP文件或ZIP文件格式的输出流，则通过此方法设置的最后修改时间将存储在zip文件条目的 &lt;code&gt;date and time fields&lt;/code&gt; 中，并以标准 &lt;code&gt;MS-DOS date and time format&lt;/code&gt; 编码。如果日期时间设置超出标准 &lt;code&gt; MS-DOS date and time format&lt;/code&gt; ，则该时间还将以UTC时间的 &lt;code&gt;optional extra data&lt;/code&gt; 存储到zip文件条目的扩展时间戳字段中。该&lt;a href=&quot;../../time/zoneid#systemDefault()&quot;&gt; &lt;code&gt;system default TimeZone&lt;/code&gt; &lt;/a&gt;用于本地日期时间为UTC时间转换。</target>
        </trans-unit>
        <trans-unit id="b500fa31b73e631f7dcb75621d0a2f6abc54a397" translate="yes" xml:space="preserve">
          <source>If the entry is output to a ZIP file or ZIP file formatted output stream the last modification time set by this method will be stored into the &lt;code&gt;date and time fields&lt;/code&gt; of the zip file entry and encoded in standard &lt;code&gt;MS-DOS date and time format&lt;/code&gt;. The &lt;a href=&quot;../timezone#getDefault()&quot;&gt;&lt;code&gt;default TimeZone&lt;/code&gt;&lt;/a&gt; is used to convert the epoch time to the MS-DOS data and time.</source>
          <target state="translated">如果将条目输出到ZIP文件或ZIP文件格式的输出流，则通过此方法设置的最后修改时间将存储在zip文件条目的 &lt;code&gt;date and time fields&lt;/code&gt; 中，并以标准 &lt;code&gt;MS-DOS date and time format&lt;/code&gt; 编码。的&lt;a href=&quot;../timezone#getDefault()&quot;&gt; &lt;code&gt;default TimeZone&lt;/code&gt; &lt;/a&gt;被用于历元时间转换为MS-DOS数据和时间。</target>
        </trans-unit>
        <trans-unit id="0a00a113b23cd107c1f980e1846beabb40469342" translate="yes" xml:space="preserve">
          <source>If the entry is output to a ZIP file or ZIP file formatted output stream the last modification time set by this method will be stored into the &lt;code&gt;date and time fields&lt;/code&gt; of the zip file entry and encoded in standard &lt;code&gt;MS-DOS date and time format&lt;/code&gt;. The &lt;a href=&quot;../timezone#getDefault--&quot;&gt;&lt;code&gt;default TimeZone&lt;/code&gt;&lt;/a&gt; is used to convert the epoch time to the MS-DOS data and time.</source>
          <target state="translated">如果将条目输出到ZIP文件或ZIP文件格式的输出流，则通过此方法设置的最后修改时间将存储在zip文件条目的 &lt;code&gt;date and time fields&lt;/code&gt; 中，并以标准 &lt;code&gt;MS-DOS date and time format&lt;/code&gt; 编码。的&lt;a href=&quot;../timezone#getDefault--&quot;&gt; &lt;code&gt;default TimeZone&lt;/code&gt; &lt;/a&gt;被用于历元时间转换为MS-DOS数据和时间。</target>
        </trans-unit>
        <trans-unit id="85a5272c1bab15e68743538f438b05df60195e22" translate="yes" xml:space="preserve">
          <source>If the entry is read from a ZIP file or ZIP file formatted input stream, this is the last modification time from the &lt;code&gt;
 date and time fields&lt;/code&gt; of the zip file entry. The &lt;a href=&quot;../timezone#getDefault()&quot;&gt;&lt;code&gt;default TimeZone&lt;/code&gt;&lt;/a&gt; is used to convert the standard MS-DOS formatted date and time to the epoch time.</source>
          <target state="translated">如果从ZIP文件或ZIP文件格式的输入流中读取条目，则这是zip文件条目的 &lt;code&gt; date and time fields&lt;/code&gt; 中的最后修改时间。的&lt;a href=&quot;../timezone#getDefault()&quot;&gt; &lt;code&gt;default TimeZone&lt;/code&gt; &lt;/a&gt;被用于标准的MS-DOS格式的日期和时间转换为信号出现时间。</target>
        </trans-unit>
        <trans-unit id="a5ccafee62ee3362796ffa2f54139e7599780958" translate="yes" xml:space="preserve">
          <source>If the entry is read from a ZIP file or ZIP file formatted input stream, this is the last modification time from the &lt;code&gt;date and time fields&lt;/code&gt; of the zip file entry. The &lt;a href=&quot;../timezone#getDefault--&quot;&gt;&lt;code&gt;default TimeZone&lt;/code&gt;&lt;/a&gt; is used to convert the standard MS-DOS formatted date and time to the epoch time.</source>
          <target state="translated">如果从ZIP文件或ZIP文件格式的输入流中读取条目，则这是zip文件条目的 &lt;code&gt;date and time fields&lt;/code&gt; 中的最后修改时间。的&lt;a href=&quot;../timezone#getDefault--&quot;&gt; &lt;code&gt;default TimeZone&lt;/code&gt; &lt;/a&gt;被用于标准的MS-DOS格式的日期和时间转换为信号出现时间。</target>
        </trans-unit>
        <trans-unit id="0ab32364343d6a000b40b013685c0fce3d0cb517" translate="yes" xml:space="preserve">
          <source>If the entry is read from a ZIP file or ZIP file formatted input stream, this is the last modification time from the zip file entry's &lt;code&gt;optional extra data&lt;/code&gt; if the extended timestamp fields are present. Otherwise the last modification time is read from the entry's &lt;code&gt;date and time fields&lt;/code&gt;, the &lt;a href=&quot;../timezone#getDefault()&quot;&gt;&lt;code&gt;default TimeZone&lt;/code&gt;&lt;/a&gt; is used to convert the standard MS-DOS formatted date and time to the epoch time.</source>
          <target state="translated">如果从ZIP文件或ZIP文件格式的输入流中读取条目，则这是zip文件条目的 &lt;code&gt;optional extra data&lt;/code&gt; 如果存在扩展时间戳记字段）的最后修改时间。否则，将从条目的 &lt;code&gt;date and time fields&lt;/code&gt; 读取最后的修改时间，&lt;a href=&quot;../timezone#getDefault()&quot;&gt; &lt;code&gt;default TimeZone&lt;/code&gt; &lt;/a&gt;用于将标准MS-DOS格式的日期和时间转换为纪元时间。</target>
        </trans-unit>
        <trans-unit id="4b289b42cb002e533856d62e0fbbde21b7d11a5b" translate="yes" xml:space="preserve">
          <source>If the entry is read from a ZIP file or ZIP file formatted input stream, this is the last modification time from the zip file entry's &lt;code&gt;optional extra data&lt;/code&gt; if the extended timestamp fields are present. Otherwise the last modification time is read from the entry's &lt;code&gt;date and time fields&lt;/code&gt;, the &lt;a href=&quot;../timezone#getDefault--&quot;&gt;&lt;code&gt;default TimeZone&lt;/code&gt;&lt;/a&gt; is used to convert the standard MS-DOS formatted date and time to the epoch time.</source>
          <target state="translated">如果从ZIP文件或ZIP文件格式的输入流中读取条目，则这是存在扩展时间戳字段的情况下来自zip文件条目的 &lt;code&gt;optional extra data&lt;/code&gt; 的最后修改时间。否则，将从条目的 &lt;code&gt;date and time fields&lt;/code&gt; 读取最后的修改时间，&lt;a href=&quot;../timezone#getDefault--&quot;&gt; &lt;code&gt;default TimeZone&lt;/code&gt; &lt;/a&gt;用于将标准MS-DOS格式的日期和时间转换为纪元时间。</target>
        </trans-unit>
        <trans-unit id="05d613b0e17c16e0c66c734b0a98a9ba4f184306" translate="yes" xml:space="preserve">
          <source>If the entry is read from a ZIP file or ZIP file formatted input stream, this is the last modification time from the zip file entry's &lt;code&gt;optional extra data&lt;/code&gt; if the extended timestamp fields are present. Otherwise, the last modification time is read from entry's standard MS-DOS formatted &lt;code&gt;date and time fields&lt;/code&gt;.</source>
          <target state="translated">如果从ZIP文件或ZIP文件格式的输入流中读取条目，则这是zip文件条目的 &lt;code&gt;optional extra data&lt;/code&gt; 如果存在扩展时间戳记字段）的最后修改时间。否则，将从条目的标准MS-DOS格式的 &lt;code&gt;date and time fields&lt;/code&gt; 读取最后的修改时间。</target>
        </trans-unit>
        <trans-unit id="797642f2d5761f48870b5a97a0e9081a36bc1501" translate="yes" xml:space="preserve">
          <source>If the event class associated with this event factory is already registered, the call to this method is ignored.</source>
          <target state="translated">如果与该事件工厂相关联的事件类已经被注册,则对该方法的调用将被忽略。</target>
        </trans-unit>
        <trans-unit id="659072435671da166f323fd01cd2350cabee3286" translate="yes" xml:space="preserve">
          <source>If the event class associated with this event factory is not already registered, the call to this method is ignored.</source>
          <target state="translated">如果与该事件工厂相关联的事件类尚未注册,则对该方法的调用将被忽略。</target>
        </trans-unit>
        <trans-unit id="1131461e543048c9f3d0dad87b28281f4c97ad31" translate="yes" xml:space="preserve">
          <source>If the event class is already registered, then the invocation of this method is ignored.</source>
          <target state="translated">如果事件类已经被注册,那么该方法的调用将被忽略。</target>
        </trans-unit>
        <trans-unit id="63079cda2661b4d19d530c94c9bca72825955418" translate="yes" xml:space="preserve">
          <source>If the event class is not registered, then the invocation of this method is ignored.</source>
          <target state="translated">如果事件类没有注册,那么该方法的调用将被忽略。</target>
        </trans-unit>
        <trans-unit id="e02b2a061b3320b01237249ddfaa9eb0520ac284" translate="yes" xml:space="preserve">
          <source>If the event doesn't get filtered, it will try to insert content into the text editor. The content is fetched from the command string of the ActionEvent. The text entry is done through the &lt;code&gt;replaceSelection&lt;/code&gt; method on the target text component. This is the action that will be fired for most text entry tasks.</source>
          <target state="translated">如果未过滤事件，它将尝试将内容插入文本编辑器。内容是从ActionEvent的命令字符串中提取的。文本输入是通过目标文本组件上的 &lt;code&gt;replaceSelection&lt;/code&gt; 方法完成的。这是将对大多数文本输入任务触发的操作。</target>
        </trans-unit>
        <trans-unit id="44db14d1e9cdb3209ffe191f5a2a3430583832df" translate="yes" xml:space="preserve">
          <source>If the event involved an exception, this will be the exception object. Otherwise null.</source>
          <target state="translated">如果事件涉及到异常,这将是异常对象,否则为空。否则为空。</target>
        </trans-unit>
        <trans-unit id="8e47a9d7666abe192af5ff31d67d31063f85d1ad" translate="yes" xml:space="preserve">
          <source>If the event is an instant event, then the start time and end time are the same.</source>
          <target state="translated">如果事件是即时事件,那么开始时间和结束时间是一样的。</target>
        </trans-unit>
        <trans-unit id="636af865dd5520f93c482ef1d513964eb35efb7f" translate="yes" xml:space="preserve">
          <source>If the event parameter is &lt;code&gt;null&lt;/code&gt; the behavior is unspecified and may result in an exception.</source>
          <target state="translated">如果event参数为 &lt;code&gt;null&lt;/code&gt; ,则行为未指定，并可能导致异常。</target>
        </trans-unit>
        <trans-unit id="86bcde70649fd800362c8d848bf84e937894cfad" translate="yes" xml:space="preserve">
          <source>If the event starts with an invocation of the &lt;code&gt;begin&lt;/code&gt; method, but does not end with an explicit invocation of the &lt;code&gt;end&lt;/code&gt; method, then the event ends when the &lt;code&gt;commit&lt;/code&gt; method is invoked.</source>
          <target state="translated">如果事件以 &lt;code&gt;begin&lt;/code&gt; 方法的调用开始，但没有以 &lt;code&gt;end&lt;/code&gt; 方法的显式调用结束，则事件在 &lt;code&gt;commit&lt;/code&gt; 方法被调用时结束。</target>
        </trans-unit>
        <trans-unit id="af1991d1905a17c3a61e8189297ee3cdafb502d7" translate="yes" xml:space="preserve">
          <source>If the event type is not one of the above, nothing happens.</source>
          <target state="translated">如果事件类型不是上述之一,则不会发生任何事情。</target>
        </trans-unit>
        <trans-unit id="04ee175a91380bcfff6774332dbdc8f91673dbd2" translate="yes" xml:space="preserve">
          <source>If the exact product of the first two arguments is infinite (in other words, at least one of the arguments is infinite and the other is neither zero nor NaN) and the third argument is an infinity of the opposite sign, the result is NaN.</source>
          <target state="translated">如果前两个论点的精确乘积是无限的(换句话说,至少有一个论点是无限的,另一个既不是零,也不是NaN),第三个论点是相反符号的无限,结果是NaN。</target>
        </trans-unit>
        <trans-unit id="2ad6e084350af847bf5f8d8cac23d0487a14cc12" translate="yes" xml:space="preserve">
          <source>If the exception was created with the return value from the agent &lt;code&gt;Agent_OnAttach&lt;/code&gt; function then this returns that value, otherwise returns &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">如果使用代理程序 &lt;code&gt;Agent_OnAttach&lt;/code&gt; 函数的返回值创建了异常，则将返回该值，否则返回 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="89efede28f8340ed4b4384494bc673df18dd7978" translate="yes" xml:space="preserve">
          <source>If the expression cannot be converted to return the specified type.</source>
          <target state="translated">如果表达式不能转换为返回指定类型。</target>
        </trans-unit>
        <trans-unit id="e95e52b95a3d17be2a361085bc902faa16c60d26" translate="yes" xml:space="preserve">
          <source>If the expression contains a function reference, the function will be found through the &lt;a href=&quot;xpathfunctionresolver&quot;&gt;&lt;code&gt;XPathFunctionResolver&lt;/code&gt;&lt;/a&gt; set with &lt;a href=&quot;#setXPathFunctionResolver(javax.xml.xpath.XPathFunctionResolver)&quot;&gt;&lt;code&gt;setXPathFunctionResolver(XPathFunctionResolver resolver)&lt;/code&gt;&lt;/a&gt;. An &lt;a href=&quot;xpathexpressionexception&quot;&gt;&lt;code&gt;XPathExpressionException&lt;/code&gt;&lt;/a&gt; is raised if the function resolver is undefined or the function resolver returns &lt;code&gt;null&lt;/code&gt; for the function.</source>
          <target state="translated">如果表达式包含函数引用，则可以通过使用&lt;a href=&quot;#setXPathFunctionResolver(javax.xml.xpath.XPathFunctionResolver)&quot;&gt; &lt;code&gt;setXPathFunctionResolver(XPathFunctionResolver resolver)&lt;/code&gt; &lt;/a&gt;设置的&lt;a href=&quot;xpathfunctionresolver&quot;&gt; &lt;code&gt;XPathFunctionResolver&lt;/code&gt; &lt;/a&gt;找到该函数。一个&lt;a href=&quot;xpathexpressionexception&quot;&gt; &lt;code&gt;XPathExpressionException&lt;/code&gt; &lt;/a&gt;是，如果函数解析器未定义或凸起的函数解析器返回 &lt;code&gt;null&lt;/code&gt; 的功能。</target>
        </trans-unit>
        <trans-unit id="43696688f3c4489c7b41ec9b95dff40a7fa60072" translate="yes" xml:space="preserve">
          <source>If the expression contains a function reference, the function will be found through the &lt;a href=&quot;xpathfunctionresolver&quot;&gt;&lt;code&gt;XPathFunctionResolver&lt;/code&gt;&lt;/a&gt;. An &lt;a href=&quot;xpathexpressionexception&quot;&gt;&lt;code&gt;XPathExpressionException&lt;/code&gt;&lt;/a&gt; is raised if the function resolver is undefined or the function resolver returns &lt;code&gt;null&lt;/code&gt; for the function.</source>
          <target state="translated">如果表达式包含函数引用，则可以通过&lt;a href=&quot;xpathfunctionresolver&quot;&gt; &lt;code&gt;XPathFunctionResolver&lt;/code&gt; &lt;/a&gt;找到该函数。一个&lt;a href=&quot;xpathexpressionexception&quot;&gt; &lt;code&gt;XPathExpressionException&lt;/code&gt; &lt;/a&gt;是，如果函数解析器未定义或凸起的函数解析器返回 &lt;code&gt;null&lt;/code&gt; 的功能。</target>
        </trans-unit>
        <trans-unit id="8ec91836ab8810be357b49e4f3c052ec4bf73ac1" translate="yes" xml:space="preserve">
          <source>If the expression contains a variable reference, its value will be found through the &lt;a href=&quot;xpathvariableresolver&quot;&gt;&lt;code&gt;XPathVariableResolver&lt;/code&gt;&lt;/a&gt; set with &lt;a href=&quot;#setXPathVariableResolver(javax.xml.xpath.XPathVariableResolver)&quot;&gt;&lt;code&gt;setXPathVariableResolver(XPathVariableResolver resolver)&lt;/code&gt;&lt;/a&gt;. An &lt;a href=&quot;xpathexpressionexception&quot;&gt;&lt;code&gt;XPathExpressionException&lt;/code&gt;&lt;/a&gt; is raised if the variable resolver is undefined or the resolver returns &lt;code&gt;null&lt;/code&gt; for the variable. The value of a variable must be immutable through the course of any single evaluation.</source>
          <target state="translated">如果表达式包含变量引用，则可以通过使用&lt;a href=&quot;#setXPathVariableResolver(javax.xml.xpath.XPathVariableResolver)&quot;&gt; &lt;code&gt;setXPathVariableResolver(XPathVariableResolver resolver)&lt;/code&gt; &lt;/a&gt;设置的&lt;a href=&quot;xpathvariableresolver&quot;&gt; &lt;code&gt;XPathVariableResolver&lt;/code&gt; &lt;/a&gt;找到其值。一个&lt;a href=&quot;xpathexpressionexception&quot;&gt; &lt;code&gt;XPathExpressionException&lt;/code&gt; &lt;/a&gt;是如果变量解析器未定义或凸起解析器返回 &lt;code&gt;null&lt;/code&gt; 的变量。在任何一次求值过程中，变量的值都必须是不变的。</target>
        </trans-unit>
        <trans-unit id="ac27a65340aff2ce4aa55c84684d42f7fc9702ed" translate="yes" xml:space="preserve">
          <source>If the expression contains a variable reference, its value will be found through the &lt;a href=&quot;xpathvariableresolver&quot;&gt;&lt;code&gt;XPathVariableResolver&lt;/code&gt;&lt;/a&gt;. An &lt;a href=&quot;xpathexpressionexception&quot;&gt;&lt;code&gt;XPathExpressionException&lt;/code&gt;&lt;/a&gt; is raised if the variable resolver is undefined or the resolver returns &lt;code&gt;null&lt;/code&gt; for the variable. The value of a variable must be immutable through the course of any single evaluation.</source>
          <target state="translated">如果表达式包含变量引用，则可以通过&lt;a href=&quot;xpathvariableresolver&quot;&gt; &lt;code&gt;XPathVariableResolver&lt;/code&gt; &lt;/a&gt;找到其值。一个&lt;a href=&quot;xpathexpressionexception&quot;&gt; &lt;code&gt;XPathExpressionException&lt;/code&gt; &lt;/a&gt;是如果变量解析器未定义或凸起解析器返回 &lt;code&gt;null&lt;/code&gt; 的变量。在任何一次求值过程中，变量的值都必须是不变的。</target>
        </trans-unit>
        <trans-unit id="e47c3d09f4791484483e78797bfa839979548f7c" translate="yes" xml:space="preserve">
          <source>If the expression has a syntax error or otherwise is not a legal expression according to the rules of the specific &lt;code&gt;XPathEvaluator&lt;/code&gt; or contains specialized extension functions or variables not supported by this implementation.</source>
          <target state="translated">根据特定 &lt;code&gt;XPathEvaluator&lt;/code&gt; 的规则，如果该表达式存在语法错误，或者不是合法表达式，或者包含此实现不支持的特殊扩展功能或变量。</target>
        </trans-unit>
        <trans-unit id="e0292adc0114844d25fb79e16b7258d6d3885abd" translate="yes" xml:space="preserve">
          <source>If the extension class loader cannot be found then the system class loader is used; if there is no system class loader then the bootstrap class loader is used.</source>
          <target state="translated">如果找不到扩展类加载器,则使用系统类加载器;如果没有系统类加载器,则使用引导类加载器。</target>
        </trans-unit>
        <trans-unit id="173d1b8bf14c80f810bc6e9721b807d2048ebbcd" translate="yes" xml:space="preserve">
          <source>If the field has the &lt;code&gt;@Unsigned&lt;/code&gt; annotation and is of a narrower type than &lt;code&gt;int&lt;/code&gt;, then the value will be returned as an unsigned.</source>
          <target state="translated">如果该字段具有 &lt;code&gt;@Unsigned&lt;/code&gt; 批注并且类型比 &lt;code&gt;int&lt;/code&gt; 窄，则该值将以无符号形式返回。</target>
        </trans-unit>
        <trans-unit id="b39d0fb537a08b776be7ac77a06fcd2b3da27f28" translate="yes" xml:space="preserve">
          <source>If the field has the &lt;code&gt;@Unsigned&lt;/code&gt; annotation and is of a narrower type than &lt;code&gt;long&lt;/code&gt;, then the value will be returned as an unsigned.</source>
          <target state="translated">如果该字段具有 &lt;code&gt;@Unsigned&lt;/code&gt; 批注并且类型比 &lt;code&gt;long&lt;/code&gt; 窄，则该值将以无符号形式返回。</target>
        </trans-unit>
        <trans-unit id="2ed1f18b615e007d2288b83889463bb892c443f1" translate="yes" xml:space="preserve">
          <source>If the field has the &lt;code&gt;@Unsigned&lt;/code&gt; annotation and is of a narrower type than &lt;code&gt;short&lt;/code&gt;, then the value is returned as an unsigned.</source>
          <target state="translated">如果该字段具有 &lt;code&gt;@Unsigned&lt;/code&gt; 批注并且类型比 &lt;code&gt;short&lt;/code&gt; 窄，则该值将以无符号形式返回。</target>
        </trans-unit>
        <trans-unit id="2f6968b385e002c9508a424a478292c0f3a7af81" translate="yes" xml:space="preserve">
          <source>If the field is &lt;a href=&quot;temporal/chronofield#DAY_OF_WEEK&quot;&gt;&lt;code&gt;DAY_OF_WEEK&lt;/code&gt;&lt;/a&gt; then the range of the day-of-week, from 1 to 7, will be returned. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronofield#DAY_OF_WEEK&quot;&gt; &lt;code&gt;DAY_OF_WEEK&lt;/code&gt; &lt;/a&gt;，则将返回星期几的范围，从1到7。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将抛出 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5c19fc73e0fc2d097b24a11cffd6f4ae4696359b" translate="yes" xml:space="preserve">
          <source>If the field is &lt;a href=&quot;temporal/chronofield#DAY_OF_WEEK&quot;&gt;&lt;code&gt;DAY_OF_WEEK&lt;/code&gt;&lt;/a&gt; then the value of the day-of-week, from 1 to 7, will be returned. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">如果该字段为&lt;a href=&quot;temporal/chronofield#DAY_OF_WEEK&quot;&gt; &lt;code&gt;DAY_OF_WEEK&lt;/code&gt; &lt;/a&gt;，则将返回星期几，从1到7。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将抛出 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="30d9439a6bb009c979b0800716929ef61f2bbd69" translate="yes" xml:space="preserve">
          <source>If the field is &lt;a href=&quot;temporal/chronofield#DAY_OF_WEEK&quot;&gt;&lt;code&gt;DAY_OF_WEEK&lt;/code&gt;&lt;/a&gt; then this method returns true. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will return false.</source>
          <target state="translated">如果该字段为&lt;a href=&quot;temporal/chronofield#DAY_OF_WEEK&quot;&gt; &lt;code&gt;DAY_OF_WEEK&lt;/code&gt; ,&lt;/a&gt;则此方法返回true。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将返回false。</target>
        </trans-unit>
        <trans-unit id="326c5765ea79518cbefcc0303c7d41108e792d2b" translate="yes" xml:space="preserve">
          <source>If the field is &lt;a href=&quot;temporal/chronofield#MONTH_OF_YEAR&quot;&gt;&lt;code&gt;MONTH_OF_YEAR&lt;/code&gt;&lt;/a&gt; then the range of the month-of-year, from 1 to 12, will be returned. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">如果该字段为&lt;a href=&quot;temporal/chronofield#MONTH_OF_YEAR&quot;&gt; &lt;code&gt;MONTH_OF_YEAR&lt;/code&gt; &lt;/a&gt;，则将返回年份的范围（从1到12）。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将抛出 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="af240bad736f05e53adae955dd58de67cb50462f" translate="yes" xml:space="preserve">
          <source>If the field is &lt;a href=&quot;temporal/chronofield#MONTH_OF_YEAR&quot;&gt;&lt;code&gt;MONTH_OF_YEAR&lt;/code&gt;&lt;/a&gt; then the value of the month-of-year, from 1 to 12, will be returned. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">如果该字段为&lt;a href=&quot;temporal/chronofield#MONTH_OF_YEAR&quot;&gt; &lt;code&gt;MONTH_OF_YEAR&lt;/code&gt; &lt;/a&gt;，则将返回年份的值（从1到12）。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将抛出 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4fe971066ffd7c4b8626dd60c34bb8f8261cfed9" translate="yes" xml:space="preserve">
          <source>If the field is &lt;a href=&quot;temporal/chronofield#MONTH_OF_YEAR&quot;&gt;&lt;code&gt;MONTH_OF_YEAR&lt;/code&gt;&lt;/a&gt; then this method returns true. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will return false.</source>
          <target state="translated">如果该字段为&lt;a href=&quot;temporal/chronofield#MONTH_OF_YEAR&quot;&gt; &lt;code&gt;MONTH_OF_YEAR&lt;/code&gt; ,&lt;/a&gt;则此方法返回true。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将返回false。</target>
        </trans-unit>
        <trans-unit id="e7faeadf7c05f00989d9bc2390cd06288a8ff039" translate="yes" xml:space="preserve">
          <source>If the field is &lt;code&gt;final&lt;/code&gt;, write access will not be allowed and access checking will fail, except under certain narrow circumstances documented for &lt;a href=&quot;../reflect/field#set(java.lang.Object,java.lang.Object)&quot;&gt;&lt;code&gt;Field.set&lt;/code&gt;&lt;/a&gt;. A method handle is returned only if a corresponding call to the &lt;code&gt;Field&lt;/code&gt; object's &lt;code&gt;set&lt;/code&gt; method could return normally. In particular, fields which are both &lt;code&gt;static&lt;/code&gt; and &lt;code&gt;final&lt;/code&gt; may never be set.</source>
          <target state="translated">如果该字段是 &lt;code&gt;final&lt;/code&gt; ，则除非在为&lt;a href=&quot;../reflect/field#set(java.lang.Object,java.lang.Object)&quot;&gt; &lt;code&gt;Field.set&lt;/code&gt; &lt;/a&gt;记录的某些狭窄情况下，否则不允许写访问，并且访问检查将失败。仅当对 &lt;code&gt;Field&lt;/code&gt; 对象的 &lt;code&gt;set&lt;/code&gt; 方法的相应调用可以正常返回时，才返回方法句柄。特别是，永远不能设置 &lt;code&gt;static&lt;/code&gt; 和 &lt;code&gt;final&lt;/code&gt; 字段。</target>
        </trans-unit>
        <trans-unit id="38484743a496914be1e808c10f80951caa603c0e" translate="yes" xml:space="preserve">
          <source>If the field is &lt;code&gt;static&lt;/code&gt;, and if the returned method handle is invoked, the field's class will be initialized, if it has not already been initialized.</source>
          <target state="translated">如果该字段是 &lt;code&gt;static&lt;/code&gt; ，并且如果调用了返回的方法句柄，则该字段的类将被初始化（如果尚未初始化）。</target>
        </trans-unit>
        <trans-unit id="3cbe7e72fb8b0010865d68d0c08c6481722f84e6" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;../temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;code&gt;ERA&lt;/code&gt; field returns the range. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;../temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; ,&lt;/a&gt;则在此处实现查询。在 &lt;code&gt;ERA&lt;/code&gt; 字段返回的范围内。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将抛出 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="184058e0a14902aa21c927d78bf2821afd7ffb8f" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;../temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;code&gt;ERA&lt;/code&gt; field returns the value of the era. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;../temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; ,&lt;/a&gt;则在此处实现查询。在 &lt;code&gt;ERA&lt;/code&gt; 字段返回的时代价值。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将抛出 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1953db0f99dd40e5aaa224b3ed2d92f821f4fad2" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;../temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;code&gt;ERA&lt;/code&gt; field returns true. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will return false.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;../temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; ,&lt;/a&gt;则在此处实现查询。在 &lt;code&gt;ERA&lt;/code&gt; 场返回true。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将返回false。</target>
        </trans-unit>
        <trans-unit id="5df5ba306c3a00473938e546303760434732261a" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;../temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The supported fields are:</source>
          <target state="translated">如果该字段是&lt;a href=&quot;../temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; ,&lt;/a&gt;则在此处实现查询。支持的字段是：</target>
        </trans-unit>
        <trans-unit id="9ddb65541050763763b556e80a29c16db72c7248" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the adjustment is implemented here.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; ,&lt;/a&gt;则在此处执行调整。</target>
        </trans-unit>
        <trans-unit id="871d99f928633d452b234c707859c60ee439a250" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the adjustment is implemented here. The &lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will behave as per the matching method on &lt;a href=&quot;localdate#with(java.time.temporal.TemporalField,long)&quot;&gt;&lt;code&gt;LocalDate&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;localtime#with(java.time.temporal.TemporalField,long)&quot;&gt;&lt;code&gt;LocalTime&lt;/code&gt;&lt;/a&gt;. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; ,&lt;/a&gt;则在此处执行调整。的&lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt;将表现为每对匹配方法&lt;a href=&quot;localdate#with(java.time.temporal.TemporalField,long)&quot;&gt; &lt;code&gt;LocalDate&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;localtime#with(java.time.temporal.TemporalField,long)&quot;&gt; &lt;code&gt;LocalTime&lt;/code&gt; &lt;/a&gt;。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将抛出 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cc3692f941d5abe057e214a3bd9f234905a09651" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the adjustment is implemented here. The &lt;a href=&quot;localdatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will behave as per the matching method on &lt;a href=&quot;localdate#with-java.time.temporal.TemporalField-long-&quot;&gt;&lt;code&gt;LocalDate&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;localtime#with-java.time.temporal.TemporalField-long-&quot;&gt;&lt;code&gt;LocalTime&lt;/code&gt;&lt;/a&gt;. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; ,&lt;/a&gt;则在此处执行调整。的&lt;a href=&quot;localdatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt;将表现为每对匹配方法&lt;a href=&quot;localdate#with-java.time.temporal.TemporalField-long-&quot;&gt; &lt;code&gt;LocalDate&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;localtime#with-java.time.temporal.TemporalField-long-&quot;&gt; &lt;code&gt;LocalTime&lt;/code&gt; &lt;/a&gt;。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将抛出 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1d4babbf0823e08d2dba83490653149a8a5cf2ed" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the adjustment is implemented here. The supported fields behave as follows:</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; ,&lt;/a&gt;则在此处执行调整。支持的字段的行为如下：</target>
        </trans-unit>
        <trans-unit id="654ffbe0ee041234f33cf275c87fc4c9fc7c6dd4" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return appropriate range instances. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; ,&lt;/a&gt;则在此处实现查询。该&lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt;将返回适当的范围内的情况。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将抛出 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="073a987d8c755e83cfc6ffb42e22775ce7412bb2" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this date, except &lt;code&gt;EPOCH_DAY&lt;/code&gt; and &lt;code&gt;PROLEPTIC_MONTH&lt;/code&gt; which are too large to fit in an &lt;code&gt;int&lt;/code&gt; and throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; ,&lt;/a&gt;则在此处实现查询。该&lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt;将返回除了基于此日期有效值， &lt;code&gt;EPOCH_DAY&lt;/code&gt; 和 &lt;code&gt;PROLEPTIC_MONTH&lt;/code&gt; 这是太大，无法在 &lt;code&gt;int&lt;/code&gt; 和抛出 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将抛出 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="393ab92db0d7f28b2848265a88f15c6d53af21b2" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this date-time, except &lt;code&gt;INSTANT_SECONDS&lt;/code&gt; which is too large to fit in an &lt;code&gt;int&lt;/code&gt; and throws a &lt;code&gt;DateTimeException&lt;/code&gt;. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; ,&lt;/a&gt;则在此处实现查询。该&lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt;将返回基于此日期时间有效值，除了 &lt;code&gt;INSTANT_SECONDS&lt;/code&gt; 这是太大，无法在 &lt;code&gt;int&lt;/code&gt; 和抛出一个 &lt;code&gt;DateTimeException&lt;/code&gt; 。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将抛出 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7152b3b52d7c7f0f4904764283f2e7cc4e36acbd" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this date-time, except &lt;code&gt;NANO_OF_DAY&lt;/code&gt;, &lt;code&gt;MICRO_OF_DAY&lt;/code&gt;, &lt;code&gt;EPOCH_DAY&lt;/code&gt; and &lt;code&gt;PROLEPTIC_MONTH&lt;/code&gt; which are too large to fit in an &lt;code&gt;int&lt;/code&gt; and throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; ,&lt;/a&gt;则在此处实现查询。该&lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt;将返回除了基于此日期时间有效值， &lt;code&gt;NANO_OF_DAY&lt;/code&gt; ， &lt;code&gt;MICRO_OF_DAY&lt;/code&gt; ， &lt;code&gt;EPOCH_DAY&lt;/code&gt; 和 &lt;code&gt;PROLEPTIC_MONTH&lt;/code&gt; 这是太大，无法在 &lt;code&gt;int&lt;/code&gt; 和抛出 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将抛出 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="67d10135df9a9ec6dcec81f7c4eba9e088b27dc9" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this date-time, except &lt;code&gt;NANO_OF_DAY&lt;/code&gt;, &lt;code&gt;MICRO_OF_DAY&lt;/code&gt;, &lt;code&gt;EPOCH_DAY&lt;/code&gt;, &lt;code&gt;PROLEPTIC_MONTH&lt;/code&gt; and &lt;code&gt;INSTANT_SECONDS&lt;/code&gt; which are too large to fit in an &lt;code&gt;int&lt;/code&gt; and throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; ,&lt;/a&gt;则在此处实现查询。该&lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt;将返回基于此日期时间，除了有效值 &lt;code&gt;NANO_OF_DAY&lt;/code&gt; ， &lt;code&gt;MICRO_OF_DAY&lt;/code&gt; ， &lt;code&gt;EPOCH_DAY&lt;/code&gt; ， &lt;code&gt;PROLEPTIC_MONTH&lt;/code&gt; 和 &lt;code&gt;INSTANT_SECONDS&lt;/code&gt; 这是太大，无法在 &lt;code&gt;int&lt;/code&gt; 和抛出 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将抛出 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="241448bc71c4585fd6b57179f68b0b3ae2b77f80" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this date-time. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; ,&lt;/a&gt;则在此处实现查询。该&lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt;将返回基于此日期时间有效值。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将抛出 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4394383d7f696594ca101d030728c860c4bd2767" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this date. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; ,&lt;/a&gt;则在此处实现查询。该&lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt;将返回基于此日期有效值。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将抛出 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="55f31e63ce0b6d34f732d6c74159b03dff5fbefe" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this month-day. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; ,&lt;/a&gt;则在此处实现查询。该&lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt;将返回基于本月天有效值。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将抛出 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3d5a1d9d7bbcd893d7dda7838ecb8f4a2331eaea" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this time, except &lt;code&gt;NANO_OF_DAY&lt;/code&gt; and &lt;code&gt;MICRO_OF_DAY&lt;/code&gt; which are too large to fit in an &lt;code&gt;int&lt;/code&gt; and throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; ,&lt;/a&gt;则在此处实现查询。该&lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt;将返回除了基于这个时候有效值， &lt;code&gt;NANO_OF_DAY&lt;/code&gt; 和 &lt;code&gt;MICRO_OF_DAY&lt;/code&gt; 这是太大，无法在 &lt;code&gt;int&lt;/code&gt; 和抛出 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将抛出 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="54d4291388dc2b83820f747cb1f95091292f696d" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this time. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; ,&lt;/a&gt;则在此处实现查询。该&lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt;将返回基于这个时候有效值。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将抛出 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e757166ab7f790e16750f19e7591a3771d8323b1" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this year-month, except &lt;code&gt;PROLEPTIC_MONTH&lt;/code&gt; which is too large to fit in an &lt;code&gt;int&lt;/code&gt; and throw a &lt;code&gt;DateTimeException&lt;/code&gt;. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; ,&lt;/a&gt;则在此处实现查询。该&lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt;将返回基础上，今年个月的有效值，除了 &lt;code&gt;PROLEPTIC_MONTH&lt;/code&gt; 这是太大，无法在 &lt;code&gt;int&lt;/code&gt; 和抛出 &lt;code&gt;DateTimeException&lt;/code&gt; 。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将抛出 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="07988f9ebdc9aba8f17f1634be192d7cbfc13f5d" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this year-month. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; ,&lt;/a&gt;则在此处实现查询。该&lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt;将返回基础上，今年个月的有效值。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将抛出 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="24967a514d85ca0fb445207b1151d9d0b3e22369" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this year. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; ,&lt;/a&gt;则在此处实现查询。该&lt;a href=&quot;#isSupported(java.time.temporal.TemporalField)&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt;将返回基于今年有效值。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将抛出 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b3a122466042d935dfadf2919be12e5c6bf577cb" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;instant#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return appropriate range instances. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; ,&lt;/a&gt;则在此处实现查询。该&lt;a href=&quot;instant#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt;将返回适当的范围内的情况。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将抛出 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b2fae4d33d968604493905d86ff128c82e5db2f2" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;instant#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this date-time, except &lt;code&gt;INSTANT_SECONDS&lt;/code&gt; which is too large to fit in an &lt;code&gt;int&lt;/code&gt; and throws a &lt;code&gt;DateTimeException&lt;/code&gt;. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; ,&lt;/a&gt;则在此处实现查询。该&lt;a href=&quot;instant#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt;将返回基于此日期时间有效值，除了 &lt;code&gt;INSTANT_SECONDS&lt;/code&gt; 这是太大，无法在 &lt;code&gt;int&lt;/code&gt; 和抛出一个 &lt;code&gt;DateTimeException&lt;/code&gt; 。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将抛出 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="552594823755dd323e34fbb36aa82bd02dc7ccec" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;instant#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this date-time. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; ,&lt;/a&gt;则在此处实现查询。该&lt;a href=&quot;instant#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt;将返回基于此日期时间有效值。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将抛出 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="64682870ad58c05c116e810cd345d87fe71b6bca" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;localdate#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return appropriate range instances. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; ,&lt;/a&gt;则在此处实现查询。该&lt;a href=&quot;localdate#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt;将返回适当的范围内的情况。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将抛出 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e53df72b9538f5704d56c85109a2837d5a0400cf" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;localdate#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this date, except &lt;code&gt;EPOCH_DAY&lt;/code&gt; and &lt;code&gt;PROLEPTIC_MONTH&lt;/code&gt; which are too large to fit in an &lt;code&gt;int&lt;/code&gt; and throw a &lt;code&gt;DateTimeException&lt;/code&gt;. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; ,&lt;/a&gt;则在此处实现查询。该&lt;a href=&quot;localdate#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt;将返回除了基于此日期有效值， &lt;code&gt;EPOCH_DAY&lt;/code&gt; 和 &lt;code&gt;PROLEPTIC_MONTH&lt;/code&gt; 这是太大，无法在 &lt;code&gt;int&lt;/code&gt; 和抛出 &lt;code&gt;DateTimeException&lt;/code&gt; 。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将抛出 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="32c54db3dedc37f0421eb1580db3b740ec121cad" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;localdate#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this date. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; ,&lt;/a&gt;则在此处实现查询。该&lt;a href=&quot;localdate#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt;将返回基于此日期有效值。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将抛出 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="11ea794a31defe3e3eefa9ea5db21eca50570400" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;localdatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return appropriate range instances. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; ,&lt;/a&gt;则在此处实现查询。该&lt;a href=&quot;localdatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt;将返回适当的范围内的情况。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将抛出 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a90c6eb29cbac028e8449f9cf54d00261c219feb" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;localdatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this date-time, except &lt;code&gt;NANO_OF_DAY&lt;/code&gt;, &lt;code&gt;MICRO_OF_DAY&lt;/code&gt;, &lt;code&gt;EPOCH_DAY&lt;/code&gt; and &lt;code&gt;PROLEPTIC_MONTH&lt;/code&gt; which are too large to fit in an &lt;code&gt;int&lt;/code&gt; and throw a &lt;code&gt;DateTimeException&lt;/code&gt;. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; ,&lt;/a&gt;则在此处实现查询。该&lt;a href=&quot;localdatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt;将返回除了基于此日期时间有效值， &lt;code&gt;NANO_OF_DAY&lt;/code&gt; ， &lt;code&gt;MICRO_OF_DAY&lt;/code&gt; ， &lt;code&gt;EPOCH_DAY&lt;/code&gt; 和 &lt;code&gt;PROLEPTIC_MONTH&lt;/code&gt; 这是太大，无法在 &lt;code&gt;int&lt;/code&gt; 和抛出 &lt;code&gt;DateTimeException&lt;/code&gt; 。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将抛出 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5b5f3e15dbf7f02cadaff2b1f715b8a83fed50ca" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;localdatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this date-time. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; ,&lt;/a&gt;则在此处实现查询。该&lt;a href=&quot;localdatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt;将返回基于此日期时间有效值。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将抛出 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2d7280f2ef05621f8965764c134012686323f8c9" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;localtime#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return appropriate range instances. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; ,&lt;/a&gt;则在此处实现查询。该&lt;a href=&quot;localtime#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt;将返回适当的范围内的情况。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将抛出 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a08bb7dfd7f2733af861740d800b7ce9f70eb5cf" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;localtime#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this time, except &lt;code&gt;NANO_OF_DAY&lt;/code&gt; and &lt;code&gt;MICRO_OF_DAY&lt;/code&gt; which are too large to fit in an &lt;code&gt;int&lt;/code&gt; and throw a &lt;code&gt;DateTimeException&lt;/code&gt;. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; ,&lt;/a&gt;则在此处实现查询。该&lt;a href=&quot;localtime#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt;将返回除了基于这个时候有效值， &lt;code&gt;NANO_OF_DAY&lt;/code&gt; 和 &lt;code&gt;MICRO_OF_DAY&lt;/code&gt; 这是太大，无法在 &lt;code&gt;int&lt;/code&gt; 和抛出 &lt;code&gt;DateTimeException&lt;/code&gt; 。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将抛出 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f2ea46b126ff3b5bdbf666ca3c46b71e50576dc7" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;localtime#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this time. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; ,&lt;/a&gt;则在此处实现查询。该&lt;a href=&quot;localtime#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt;将返回基于这个时候有效值。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将抛出 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3f81a778997a088523214d2edc7a7aab7a300ca4" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;monthday#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return appropriate range instances. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; ,&lt;/a&gt;则在此处实现查询。该&lt;a href=&quot;monthday#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt;将返回适当的范围内的情况。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将抛出 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ce1690eace7e2c6d89cc928ca7a7a051f9a8d0f2" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;monthday#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this month-day. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; ,&lt;/a&gt;则在此处实现查询。该&lt;a href=&quot;monthday#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt;将返回基于本月天有效值。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将抛出 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="54c277810f3ed7c547f4b1ad6fd3fb8f9a746292" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;offsetdatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return appropriate range instances. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; ,&lt;/a&gt;则在此处实现查询。该&lt;a href=&quot;offsetdatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt;将返回适当的范围内的情况。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将抛出 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="20e764af5b165d57d63cb3a6753fd7d4d9d38420" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;offsetdatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this date-time, except &lt;code&gt;NANO_OF_DAY&lt;/code&gt;, &lt;code&gt;MICRO_OF_DAY&lt;/code&gt;, &lt;code&gt;EPOCH_DAY&lt;/code&gt;, &lt;code&gt;PROLEPTIC_MONTH&lt;/code&gt; and &lt;code&gt;INSTANT_SECONDS&lt;/code&gt; which are too large to fit in an &lt;code&gt;int&lt;/code&gt; and throw a &lt;code&gt;DateTimeException&lt;/code&gt;. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; ,&lt;/a&gt;则在此处实现查询。该&lt;a href=&quot;offsetdatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt;将返回基于此日期时间，除了有效值 &lt;code&gt;NANO_OF_DAY&lt;/code&gt; ， &lt;code&gt;MICRO_OF_DAY&lt;/code&gt; ， &lt;code&gt;EPOCH_DAY&lt;/code&gt; ， &lt;code&gt;PROLEPTIC_MONTH&lt;/code&gt; 和 &lt;code&gt;INSTANT_SECONDS&lt;/code&gt; 这是太大，无法在 &lt;code&gt;int&lt;/code&gt; 和抛出 &lt;code&gt;DateTimeException&lt;/code&gt; 。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将抛出 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bbfa08249a8a681a77ac31ded9b0970961cb7e45" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;offsetdatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this date-time. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; ,&lt;/a&gt;则在此处实现查询。该&lt;a href=&quot;offsetdatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt;将返回基于此日期时间有效值。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将抛出 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="216d1b40d29dcd13ae455e39ff25a34173b680bc" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;offsettime#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return appropriate range instances. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; ,&lt;/a&gt;则在此处实现查询。该&lt;a href=&quot;offsettime#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt;将返回适当的范围内的情况。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将抛出 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="89af7f61649fef38a7f170c1bd0ab908cfde7464" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;offsettime#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this time, except &lt;code&gt;NANO_OF_DAY&lt;/code&gt; and &lt;code&gt;MICRO_OF_DAY&lt;/code&gt; which are too large to fit in an &lt;code&gt;int&lt;/code&gt; and throw a &lt;code&gt;DateTimeException&lt;/code&gt;. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; ,&lt;/a&gt;则在此处实现查询。该&lt;a href=&quot;offsettime#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt;将返回除了基于这个时候有效值， &lt;code&gt;NANO_OF_DAY&lt;/code&gt; 和 &lt;code&gt;MICRO_OF_DAY&lt;/code&gt; 这是太大，无法在 &lt;code&gt;int&lt;/code&gt; 和抛出 &lt;code&gt;DateTimeException&lt;/code&gt; 。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将抛出 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f135da292374c58a63e9a7dd6bf4f22cdbf128fc" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;offsettime#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this time. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; ,&lt;/a&gt;则在此处实现查询。该&lt;a href=&quot;offsettime#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt;将返回基于这个时候有效值。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将抛出 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="66a31e186370c87394aabeac098a9be857ade9fd" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;year#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return appropriate range instances. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; ,&lt;/a&gt;则在此处实现查询。该&lt;a href=&quot;year#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt;将返回适当的范围内的情况。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将抛出 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1a78917caede284548be462696171d8a8df88818" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;year#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this year. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; ,&lt;/a&gt;则在此处实现查询。该&lt;a href=&quot;year#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt;将返回基于今年有效值。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将抛出 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="638fba149e2f9605d4c8dd06cfefd8163837f176" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;yearmonth#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return appropriate range instances. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; ,&lt;/a&gt;则在此处实现查询。该&lt;a href=&quot;yearmonth#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt;将返回适当的范围内的情况。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将抛出 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bc96611b6dd2d22d3132d6d3df53e51b38124d7a" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;yearmonth#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this year-month, except &lt;code&gt;PROLEPTIC_MONTH&lt;/code&gt; which is too large to fit in an &lt;code&gt;int&lt;/code&gt; and throw a &lt;code&gt;DateTimeException&lt;/code&gt;. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; ,&lt;/a&gt;则在此处实现查询。该&lt;a href=&quot;yearmonth#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt;将返回基础上，今年个月的有效值，除了 &lt;code&gt;PROLEPTIC_MONTH&lt;/code&gt; 这是太大，无法在 &lt;code&gt;int&lt;/code&gt; 和抛出 &lt;code&gt;DateTimeException&lt;/code&gt; 。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将抛出 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5f2e16d3207b8a1b377b13995b5829979baa3c06" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;yearmonth#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this year-month. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; ,&lt;/a&gt;则在此处实现查询。该&lt;a href=&quot;yearmonth#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt;将返回基础上，今年个月的有效值。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将抛出 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5fda7020a7bae43a5df2b5286206bb91d72d039d" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;zoneddatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return appropriate range instances. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; ,&lt;/a&gt;则在此处实现查询。该&lt;a href=&quot;zoneddatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt;将返回适当的范围内的情况。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将抛出 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="88d03525f1042dd0011a22419c6df4c5121eba14" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;zoneddatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this date-time, except &lt;code&gt;NANO_OF_DAY&lt;/code&gt;, &lt;code&gt;MICRO_OF_DAY&lt;/code&gt;, &lt;code&gt;EPOCH_DAY&lt;/code&gt;, &lt;code&gt;PROLEPTIC_MONTH&lt;/code&gt; and &lt;code&gt;INSTANT_SECONDS&lt;/code&gt; which are too large to fit in an &lt;code&gt;int&lt;/code&gt; and throw a &lt;code&gt;DateTimeException&lt;/code&gt;. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; ,&lt;/a&gt;则在此处实现查询。该&lt;a href=&quot;zoneddatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt;将返回基于此日期时间，除了有效值 &lt;code&gt;NANO_OF_DAY&lt;/code&gt; ， &lt;code&gt;MICRO_OF_DAY&lt;/code&gt; ， &lt;code&gt;EPOCH_DAY&lt;/code&gt; ， &lt;code&gt;PROLEPTIC_MONTH&lt;/code&gt; 和 &lt;code&gt;INSTANT_SECONDS&lt;/code&gt; 这是太大，无法在 &lt;code&gt;int&lt;/code&gt; 和抛出 &lt;code&gt;DateTimeException&lt;/code&gt; 。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将抛出 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a0124fd3059f644ca04188c31653732caf32a08f" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;zoneddatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return valid values based on this date-time. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; ,&lt;/a&gt;则在此处实现查询。该&lt;a href=&quot;zoneddatetime#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt;将返回基于此日期时间有效值。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将抛出 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0337a2eda7a472dc0aa83a7e1eef644d5a370e32" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;a href=&quot;zoneoffset#isSupported-java.time.temporal.TemporalField-&quot;&gt;&lt;code&gt;supported fields&lt;/code&gt;&lt;/a&gt; will return appropriate range instances. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; ,&lt;/a&gt;则在此处实现查询。该&lt;a href=&quot;zoneoffset#isSupported-java.time.temporal.TemporalField-&quot;&gt; &lt;code&gt;supported fields&lt;/code&gt; &lt;/a&gt;将返回适当的范围内的情况。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将抛出 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4046ccaca6ad2d1bf0b7e5c2e124396f1812f96d" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;code&gt;OFFSET_SECONDS&lt;/code&gt; field returns the value of the offset. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will throw an &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt;.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; ,&lt;/a&gt;则在此处实现查询。该 &lt;code&gt;OFFSET_SECONDS&lt;/code&gt; 场返回的偏移值。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将抛出 &lt;code&gt;UnsupportedTemporalTypeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="09800c7a5d51ab3ac1ecbfa59a39761992b8d783" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The &lt;code&gt;OFFSET_SECONDS&lt;/code&gt; field returns true. All other &lt;code&gt;ChronoField&lt;/code&gt; instances will return false.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; ,&lt;/a&gt;则在此处实现查询。该 &lt;code&gt;OFFSET_SECONDS&lt;/code&gt; 场返回true。所有其他 &lt;code&gt;ChronoField&lt;/code&gt; 实例将返回false。</target>
        </trans-unit>
        <trans-unit id="bcdaaec98194652eaec2e755f354592d8a5f1fa2" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The supported fields are:</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; ,&lt;/a&gt;则在此处实现查询。支持的字段是：</target>
        </trans-unit>
        <trans-unit id="26f815de83bf9d85fe8094749e5ea200739939d5" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronounit&quot;&gt;&lt;code&gt;ChronoUnit&lt;/code&gt;&lt;/a&gt; then the addition is implemented by &lt;a href=&quot;localdatetime#plus(long,java.time.temporal.TemporalUnit)&quot;&gt;&lt;code&gt;LocalDateTime.plus(long, TemporalUnit)&lt;/code&gt;&lt;/a&gt;. The offset is not part of the calculation and will be unchanged in the result.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronounit&quot;&gt; &lt;code&gt;ChronoUnit&lt;/code&gt; ,&lt;/a&gt;则添加由&lt;a href=&quot;localdatetime#plus(long,java.time.temporal.TemporalUnit)&quot;&gt; &lt;code&gt;LocalDateTime.plus(long, TemporalUnit)&lt;/code&gt; &lt;/a&gt;。偏移量不是计算的一部分，其结果将保持不变。</target>
        </trans-unit>
        <trans-unit id="3d8816d4bddc205a3c0266b4706842519edca858" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronounit&quot;&gt;&lt;code&gt;ChronoUnit&lt;/code&gt;&lt;/a&gt; then the addition is implemented by &lt;a href=&quot;localdatetime#plus-long-java.time.temporal.TemporalUnit-&quot;&gt;&lt;code&gt;LocalDateTime.plus(long, TemporalUnit)&lt;/code&gt;&lt;/a&gt;. The offset is not part of the calculation and will be unchanged in the result.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronounit&quot;&gt; &lt;code&gt;ChronoUnit&lt;/code&gt; ,&lt;/a&gt;则添加由&lt;a href=&quot;localdatetime#plus-long-java.time.temporal.TemporalUnit-&quot;&gt; &lt;code&gt;LocalDateTime.plus(long, TemporalUnit)&lt;/code&gt; &lt;/a&gt;。偏移量不是计算的一部分，其结果将保持不变。</target>
        </trans-unit>
        <trans-unit id="30e6967c28e9ee1cc43dcf0ccc34a23008296abc" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronounit&quot;&gt;&lt;code&gt;ChronoUnit&lt;/code&gt;&lt;/a&gt; then the addition is implemented by &lt;a href=&quot;localtime#plus(long,java.time.temporal.TemporalUnit)&quot;&gt;&lt;code&gt;LocalTime.plus(long, TemporalUnit)&lt;/code&gt;&lt;/a&gt;. The offset is not part of the calculation and will be unchanged in the result.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronounit&quot;&gt; &lt;code&gt;ChronoUnit&lt;/code&gt; ,&lt;/a&gt;则添加由&lt;a href=&quot;localtime#plus(long,java.time.temporal.TemporalUnit)&quot;&gt; &lt;code&gt;LocalTime.plus(long, TemporalUnit)&lt;/code&gt; &lt;/a&gt;。偏移量不是计算的一部分，其结果将保持不变。</target>
        </trans-unit>
        <trans-unit id="5a927c94cc558aa44e673d3c09b5dede6b4bbec9" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronounit&quot;&gt;&lt;code&gt;ChronoUnit&lt;/code&gt;&lt;/a&gt; then the addition is implemented by &lt;a href=&quot;localtime#plus-long-java.time.temporal.TemporalUnit-&quot;&gt;&lt;code&gt;LocalTime.plus(long, TemporalUnit)&lt;/code&gt;&lt;/a&gt;. The offset is not part of the calculation and will be unchanged in the result.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronounit&quot;&gt; &lt;code&gt;ChronoUnit&lt;/code&gt; ,&lt;/a&gt;则添加由&lt;a href=&quot;localtime#plus-long-java.time.temporal.TemporalUnit-&quot;&gt; &lt;code&gt;LocalTime.plus(long, TemporalUnit)&lt;/code&gt; &lt;/a&gt;。偏移量不是计算的一部分，其结果将保持不变。</target>
        </trans-unit>
        <trans-unit id="edd9f66100a0f8ebdeaf7afd13edd4d404894480" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronounit&quot;&gt;&lt;code&gt;ChronoUnit&lt;/code&gt;&lt;/a&gt; then the addition is implemented here. Date units are added as per &lt;a href=&quot;localdate#plus(long,java.time.temporal.TemporalUnit)&quot;&gt;&lt;code&gt;LocalDate.plus(long, TemporalUnit)&lt;/code&gt;&lt;/a&gt;. Time units are added as per &lt;a href=&quot;localtime#plus(long,java.time.temporal.TemporalUnit)&quot;&gt;&lt;code&gt;LocalTime.plus(long, TemporalUnit)&lt;/code&gt;&lt;/a&gt; with any overflow in days added equivalent to using &lt;a href=&quot;#plusDays(long)&quot;&gt;&lt;code&gt;plusDays(long)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronounit&quot;&gt; &lt;code&gt;ChronoUnit&lt;/code&gt; ,&lt;/a&gt;则在此处实现添加。按照&lt;a href=&quot;localdate#plus(long,java.time.temporal.TemporalUnit)&quot;&gt; &lt;code&gt;LocalDate.plus(long, TemporalUnit)&lt;/code&gt; &lt;/a&gt;添加日期单位。时间单位是根据&lt;a href=&quot;localtime#plus(long,java.time.temporal.TemporalUnit)&quot;&gt; &lt;code&gt;LocalTime.plus(long, TemporalUnit)&lt;/code&gt; &lt;/a&gt;添加的，任何以天为单位的溢出都等于使用&lt;a href=&quot;#plusDays(long)&quot;&gt; &lt;code&gt;plusDays(long)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f5cba436d7af3b0ad553fc0358e491b4ffeb23a3" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronounit&quot;&gt;&lt;code&gt;ChronoUnit&lt;/code&gt;&lt;/a&gt; then the addition is implemented here. Date units are added as per &lt;a href=&quot;localdate#plus-long-java.time.temporal.TemporalUnit-&quot;&gt;&lt;code&gt;LocalDate.plus(long, TemporalUnit)&lt;/code&gt;&lt;/a&gt;. Time units are added as per &lt;a href=&quot;localtime#plus-long-java.time.temporal.TemporalUnit-&quot;&gt;&lt;code&gt;LocalTime.plus(long, TemporalUnit)&lt;/code&gt;&lt;/a&gt; with any overflow in days added equivalent to using &lt;a href=&quot;localdatetime#plusDays-long-&quot;&gt;&lt;code&gt;plusDays(long)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronounit&quot;&gt; &lt;code&gt;ChronoUnit&lt;/code&gt; ,&lt;/a&gt;则在此处实现添加。按照&lt;a href=&quot;localdate#plus-long-java.time.temporal.TemporalUnit-&quot;&gt; &lt;code&gt;LocalDate.plus(long, TemporalUnit)&lt;/code&gt; &lt;/a&gt;添加日期单位。时间单位是根据&lt;a href=&quot;localtime#plus-long-java.time.temporal.TemporalUnit-&quot;&gt; &lt;code&gt;LocalTime.plus(long, TemporalUnit)&lt;/code&gt; &lt;/a&gt;添加的，以天为单位的任何溢出都等于使用&lt;a href=&quot;localdatetime#plusDays-long-&quot;&gt; &lt;code&gt;plusDays(long)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="87edabfd23bcd4b5580257d424970351a200d0e6" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronounit&quot;&gt;&lt;code&gt;ChronoUnit&lt;/code&gt;&lt;/a&gt; then the addition is implemented here. The supported fields behave as follows:</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronounit&quot;&gt; &lt;code&gt;ChronoUnit&lt;/code&gt; ,&lt;/a&gt;则在此处实现添加。支持的字段的行为如下：</target>
        </trans-unit>
        <trans-unit id="7d28f15788411edaf2c4769963134a70f9a51014" translate="yes" xml:space="preserve">
          <source>If the field is a &lt;a href=&quot;temporal/chronounit&quot;&gt;&lt;code&gt;ChronoUnit&lt;/code&gt;&lt;/a&gt; then the addition is implemented here. The zone is not part of the calculation and will be unchanged in the result. The calculation for date and time units differ.</source>
          <target state="translated">如果该字段是&lt;a href=&quot;temporal/chronounit&quot;&gt; &lt;code&gt;ChronoUnit&lt;/code&gt; ,&lt;/a&gt;则在此处实现添加。该区域不是计算的一部分，其结果将保持不变。日期和时间单位的计算方式不同。</target>
        </trans-unit>
        <trans-unit id="472a2bad58441686158034a719ecf7233180fcd9" translate="yes" xml:space="preserve">
          <source>If the field is declared &lt;code&gt;volatile&lt;/code&gt; then the returned VarHandle will override access to the field (effectively ignore the &lt;code&gt;volatile&lt;/code&gt; declaration) in accordance to its specified access modes.</source>
          <target state="translated">如果将该字段声明为 &lt;code&gt;volatile&lt;/code&gt; ,则返回的VarHandle将根据其指定的访问模式来覆盖对该字段的访问（有效地忽略 &lt;code&gt;volatile&lt;/code&gt; 声明）。</target>
        </trans-unit>
        <trans-unit id="df5997d9cb9eb98daf0677e44c78da78084843dc" translate="yes" xml:space="preserve">
          <source>If the field is hidden in the type of &lt;code&gt;obj&lt;/code&gt;, the field's value is obtained according to the preceding rules.</source>
          <target state="translated">如果该字段以 &lt;code&gt;obj&lt;/code&gt; 类型隐藏，则根据前面的规则获得该字段的值。</target>
        </trans-unit>
        <trans-unit id="3cd0fa2a6c549544bf0fa17d3fe9a0bbdad3a534" translate="yes" xml:space="preserve">
          <source>If the field is hidden in the type of &lt;code&gt;obj&lt;/code&gt;, the field's value is set according to the preceding rules.</source>
          <target state="translated">如果该字段以 &lt;code&gt;obj&lt;/code&gt; 类型隐藏，则根据前面的规则设置该字段的值。</target>
        </trans-unit>
        <trans-unit id="c8f06458338d0982fde844f74e3eac7907ffd72d" translate="yes" xml:space="preserve">
          <source>If the field is not a &lt;code&gt;ChronoField&lt;/code&gt;, then the result of this method is obtained by invoking &lt;code&gt;TemporalField.adjustInto(Temporal, long)&lt;/code&gt; passing &lt;code&gt;this&lt;/code&gt; as the argument. In this case, the field determines whether and how to adjust the instant.</source>
          <target state="translated">如果该字段不是 &lt;code&gt;ChronoField&lt;/code&gt; ，则通过调用 &lt;code&gt;TemporalField.adjustInto(Temporal, long)&lt;/code&gt; 并将 &lt;code&gt;this&lt;/code&gt; 作为参数来获取此方法的结果。在这种情况下，该字段确定是否以及如何调整瞬时。</target>
        </trans-unit>
        <trans-unit id="bc13b792f3c5838d3770d636dc87567d506bc218" translate="yes" xml:space="preserve">
          <source>If the field is not a &lt;code&gt;ChronoField&lt;/code&gt;, then the result of this method is obtained by invoking &lt;code&gt;TemporalField.adjustInto(Temporal, long)&lt;/code&gt; passing &lt;code&gt;this&lt;/code&gt; as the first argument.</source>
          <target state="translated">如果该字段不是 &lt;code&gt;ChronoField&lt;/code&gt; ，则通过调用 &lt;code&gt;TemporalField.adjustInto(Temporal, long)&lt;/code&gt; 并将 &lt;code&gt;this&lt;/code&gt; 作为第一个参数来获取此方法的结果。</target>
        </trans-unit>
        <trans-unit id="593408760a93df2aae450a2a246b1f8f655869de" translate="yes" xml:space="preserve">
          <source>If the field is not a &lt;code&gt;ChronoField&lt;/code&gt;, then the result of this method is obtained by invoking &lt;code&gt;TemporalField.getFrom(TemporalAccessor)&lt;/code&gt; passing &lt;code&gt;this&lt;/code&gt; as the argument.</source>
          <target state="translated">如果该字段不是 &lt;code&gt;ChronoField&lt;/code&gt; ，则通过调用 &lt;code&gt;TemporalField.getFrom(TemporalAccessor)&lt;/code&gt; 并将 &lt;code&gt;this&lt;/code&gt; 作为参数来获取此方法的结果。</target>
        </trans-unit>
        <trans-unit id="84111e9c7052aea445fc84ff88640c7d9d47a3e1" translate="yes" xml:space="preserve">
          <source>If the field is not a &lt;code&gt;ChronoField&lt;/code&gt;, then the result of this method is obtained by invoking &lt;code&gt;TemporalField.getFrom(TemporalAccessor)&lt;/code&gt; passing &lt;code&gt;this&lt;/code&gt; as the argument. Whether the value can be obtained, and what the value represents, is determined by the field.</source>
          <target state="translated">如果该字段不是 &lt;code&gt;ChronoField&lt;/code&gt; ，则通过调用 &lt;code&gt;TemporalField.getFrom(TemporalAccessor)&lt;/code&gt; 并将 &lt;code&gt;this&lt;/code&gt; 作为参数来获取此方法的结果。该字段是否可以获取该值以及该值代表什么。</target>
        </trans-unit>
        <trans-unit id="8c0976d6ec775eae314c44e1cc501085eba97650" translate="yes" xml:space="preserve">
          <source>If the field is not a &lt;code&gt;ChronoField&lt;/code&gt;, then the result of this method is obtained by invoking &lt;code&gt;TemporalField.isSupportedBy(TemporalAccessor)&lt;/code&gt; passing &lt;code&gt;this&lt;/code&gt; as the argument.</source>
          <target state="translated">如果该字段不是 &lt;code&gt;ChronoField&lt;/code&gt; ，则通过调用 &lt;code&gt;TemporalField.isSupportedBy(TemporalAccessor)&lt;/code&gt; 并将 &lt;code&gt;this&lt;/code&gt; 作为参数来获取此方法的结果。</target>
        </trans-unit>
        <trans-unit id="8bfc158b937ea3897727206425819d75e46f302c" translate="yes" xml:space="preserve">
          <source>If the field is not a &lt;code&gt;ChronoField&lt;/code&gt;, then the result of this method is obtained by invoking &lt;code&gt;TemporalField.isSupportedBy(TemporalAccessor)&lt;/code&gt; passing &lt;code&gt;this&lt;/code&gt; as the argument. Whether the field is supported is determined by the field.</source>
          <target state="translated">如果该字段不是 &lt;code&gt;ChronoField&lt;/code&gt; ，则通过调用 &lt;code&gt;TemporalField.isSupportedBy(TemporalAccessor)&lt;/code&gt; 并将 &lt;code&gt;this&lt;/code&gt; 作为参数来获取此方法的结果。该字段是否受支持由该字段确定。</target>
        </trans-unit>
        <trans-unit id="63182facd2f63b4b7afccc2a4e59688c8ba979ee" translate="yes" xml:space="preserve">
          <source>If the field is not a &lt;code&gt;ChronoField&lt;/code&gt;, then the result of this method is obtained by invoking &lt;code&gt;TemporalField.rangeRefinedBy(TemporalAccessor)&lt;/code&gt; passing &lt;code&gt;this&lt;/code&gt; as the argument.</source>
          <target state="translated">如果该字段不是 &lt;code&gt;ChronoField&lt;/code&gt; ，则通过调用 &lt;code&gt;TemporalField.rangeRefinedBy(TemporalAccessor)&lt;/code&gt; 并将 &lt;code&gt;this&lt;/code&gt; 作为参数来获取此方法的结果。</target>
        </trans-unit>
        <trans-unit id="7688528113c7572e4ebfde7d3d5c748187dbd155" translate="yes" xml:space="preserve">
          <source>If the field is not a &lt;code&gt;ChronoField&lt;/code&gt;, then the result of this method is obtained by invoking &lt;code&gt;TemporalField.rangeRefinedBy(TemporalAccessor)&lt;/code&gt; passing &lt;code&gt;this&lt;/code&gt; as the argument. Whether the range can be obtained is determined by the field.</source>
          <target state="translated">如果该字段不是 &lt;code&gt;ChronoField&lt;/code&gt; ，则通过调用 &lt;code&gt;TemporalField.rangeRefinedBy(TemporalAccessor)&lt;/code&gt; 并将 &lt;code&gt;this&lt;/code&gt; 作为参数来获取此方法的结果。是否可以获取范围由现场确定。</target>
        </trans-unit>
        <trans-unit id="9dc945edaeb99a9dd905b6958af0da2b698eb2ff" translate="yes" xml:space="preserve">
          <source>If the field is not a &lt;code&gt;ChronoField&lt;/code&gt;, then the result of this method is obtained by invoking &lt;code&gt;TemporalField.rangeRefinedBy(TemporalAccessorl)&lt;/code&gt; passing &lt;code&gt;this&lt;/code&gt; as the argument.</source>
          <target state="translated">如果该字段不是 &lt;code&gt;ChronoField&lt;/code&gt; ，则通过调用 &lt;code&gt;TemporalField.rangeRefinedBy(TemporalAccessorl)&lt;/code&gt; 并将 &lt;code&gt;this&lt;/code&gt; 作为参数来获取此方法的结果。</target>
        </trans-unit>
        <trans-unit id="1bc2facd61e2bb2d253a7e2d751714a8d91fd304" translate="yes" xml:space="preserve">
          <source>If the field is not a &lt;code&gt;ChronoUnit&lt;/code&gt;, then the result of this method is obtained by invoking &lt;code&gt;TemporalUnit.addTo(Temporal, long)&lt;/code&gt; passing &lt;code&gt;this&lt;/code&gt; as the argument. In this case, the unit determines whether and how to perform the addition.</source>
          <target state="translated">如果该字段不是 &lt;code&gt;ChronoUnit&lt;/code&gt; ，则通过调用 &lt;code&gt;TemporalUnit.addTo(Temporal, long)&lt;/code&gt; 并将 &lt;code&gt;this&lt;/code&gt; 作为参数来获取此方法的结果。在这种情况下，该单元确定是否以及如何执行加法。</target>
        </trans-unit>
        <trans-unit id="3745b108d29fe526d4efe7b06863f59e4b41c30c" translate="yes" xml:space="preserve">
          <source>If the field is not a &lt;code&gt;ChronoUnit&lt;/code&gt;, then the result of this method is obtained by invoking &lt;code&gt;TemporalUnit.isSupportedBy(Temporal)&lt;/code&gt; passing &lt;code&gt;this&lt;/code&gt; as the argument.</source>
          <target state="translated">如果该字段不是 &lt;code&gt;ChronoUnit&lt;/code&gt; ，则通过调用 &lt;code&gt;TemporalUnit.isSupportedBy(Temporal)&lt;/code&gt; 并将 &lt;code&gt;this&lt;/code&gt; 作为参数来获取此方法的结果。</target>
        </trans-unit>
        <trans-unit id="7c31bf8c81eb5e3fa5966507ecfeb7eeb414a7a3" translate="yes" xml:space="preserve">
          <source>If the field is static, and if the returned VarHandle is operated on, the field's declaring class will be initialized, if it has not already been initialized.</source>
          <target state="translated">如果字段是静态的,并且如果返回的VarHandle被操作,字段的声明类将被初始化,如果它还没有被初始化。</target>
        </trans-unit>
        <trans-unit id="73f48c353a2b4ef722c15d4cc5583b25df30a788" translate="yes" xml:space="preserve">
          <source>If the field is static, and if the returned method handle is invoked, the field's class will be initialized, if it has not already been initialized.</source>
          <target state="translated">如果字段是静态的,并且如果返回的方法句柄被调用,字段的类将被初始化,如果它还没有被初始化。</target>
        </trans-unit>
        <trans-unit id="f75aa0d9bdab9beccdb246276fa853bdf88f9fa1" translate="yes" xml:space="preserve">
          <source>If the field type is &lt;code&gt;float&lt;/code&gt; or &lt;code&gt;double&lt;/code&gt; then numeric and atomic update access modes compare values using their bitwise representation (see &lt;a href=&quot;../float#floatToRawIntBits(float)&quot;&gt;&lt;code&gt;Float.floatToRawIntBits(float)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../double#doubleToRawLongBits(double)&quot;&gt;&lt;code&gt;Double.doubleToRawLongBits(double)&lt;/code&gt;&lt;/a&gt;, respectively).</source>
          <target state="translated">如果字段类型为 &lt;code&gt;float&lt;/code&gt; 或 &lt;code&gt;double&lt;/code&gt; ,则数字和原子更新访问模式将使用其按位表示形式比较值（分别参见&lt;a href=&quot;../float#floatToRawIntBits(float)&quot;&gt; &lt;code&gt;Float.floatToRawIntBits(float)&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../double#doubleToRawLongBits(double)&quot;&gt; &lt;code&gt;Double.doubleToRawLongBits(double)&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="9a766268cd602d31dba43c646e17e366517c908b" translate="yes" xml:space="preserve">
          <source>If the file already exists and it is opened for &lt;a href=&quot;#WRITE&quot;&gt;&lt;code&gt;WRITE&lt;/code&gt;&lt;/a&gt; access, then its length is truncated to 0.</source>
          <target state="translated">如果该文件已经存在并且已打开以进行&lt;a href=&quot;#WRITE&quot;&gt; &lt;code&gt;WRITE&lt;/code&gt; &lt;/a&gt;访问，则其长度将被截断为0。</target>
        </trans-unit>
        <trans-unit id="929d4fca608fb0e25c4e8a63977f3cccb4c4213a" translate="yes" xml:space="preserve">
          <source>If the file already exists and it is opened for &lt;a href=&quot;#WRITE&quot;&gt;&lt;code&gt;WRITE&lt;/code&gt;&lt;/a&gt; access, then its length is truncated to 0. This option is ignored if the file is opened only for &lt;a href=&quot;#READ&quot;&gt;&lt;code&gt;READ&lt;/code&gt;&lt;/a&gt; access.</source>
          <target state="translated">如果文件已经存在并且已打开以进行&lt;a href=&quot;#WRITE&quot;&gt; &lt;code&gt;WRITE&lt;/code&gt; &lt;/a&gt;访问，则其长度将被截断为0。如果仅为&lt;a href=&quot;#READ&quot;&gt; &lt;code&gt;READ&lt;/code&gt; &lt;/a&gt;访问而打开了文件，则忽略此选项。</target>
        </trans-unit>
        <trans-unit id="99de1988747f1a4d19117e077c897d899a759367" translate="yes" xml:space="preserve">
          <source>If the file already exists and it is opened for &lt;a href=&quot;standardopenoption#WRITE&quot;&gt;&lt;code&gt;WRITE&lt;/code&gt;&lt;/a&gt; access, then its length is truncated to 0. This option is ignored if the file is opened only for &lt;a href=&quot;standardopenoption#READ&quot;&gt;&lt;code&gt;READ&lt;/code&gt;&lt;/a&gt; access.</source>
          <target state="translated">如果文件已存在并且已打开以进行&lt;a href=&quot;standardopenoption#WRITE&quot;&gt; &lt;code&gt;WRITE&lt;/code&gt; &lt;/a&gt;访问，则其长度将被截断为0。如果仅为&lt;a href=&quot;standardopenoption#READ&quot;&gt; &lt;code&gt;READ&lt;/code&gt; &lt;/a&gt;访问而打开了文件，则忽略此选项。</target>
        </trans-unit>
        <trans-unit id="717bfba6c0a90a03523ab0b13a3750e80f9e6288" translate="yes" xml:space="preserve">
          <source>If the file does not reside on a local device then no such guarantee is made.</source>
          <target state="translated">如果文件不在本地设备上,那么就没有这样的保证。</target>
        </trans-unit>
        <trans-unit id="0c9b9ed3b31f95435fd26b9b50e781fb7b10f8ba" translate="yes" xml:space="preserve">
          <source>If the file exists but is a directory rather than a regular file, does not exist but cannot be created, or cannot be opened for any other reason then a &lt;code&gt;FileNotFoundException&lt;/code&gt; is thrown.</source>
          <target state="translated">如果文件存在但是目录而不是常规文件，则不存在但无法创建，或者由于任何其他原因而无法打开文件，则抛出 &lt;code&gt;FileNotFoundException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f72ad9bda52a7b14dd7371372743b4037fafc486" translate="yes" xml:space="preserve">
          <source>If the file is a directory then the directory must be empty. In some implementations a directory has entries for special files or links that are created when the directory is created. In such implementations a directory is considered empty when only the special entries exist.</source>
          <target state="translated">如果文件是一个目录,那么该目录必须是空的。在某些实现中,一个目录有特殊文件或链接的条目,这些条目是在创建目录时创建的。在这种实现中,当只有特殊条目存在时,一个目录被认为是空的。</target>
        </trans-unit>
        <trans-unit id="d8fa9367e398fcca0e927495045f7052187e809e" translate="yes" xml:space="preserve">
          <source>If the file is a directory then the directory must be empty. In some implementations a directory has entries for special files or links that are created when the directory is created. In such implementations a directory is considered empty when only the special entries exist. This method can be used with the &lt;a href=&quot;#walkFileTree(java.nio.file.Path,java.util.Set,int,java.nio.file.FileVisitor)&quot;&gt;&lt;code&gt;walkFileTree&lt;/code&gt;&lt;/a&gt; method to delete a directory and all entries in the directory, or an entire</source>
          <target state="translated">如果文件是目录，则该目录必须为空。在某些实现中，目录具有创建目录时创建的特殊文件或链接的条目。在这样的实现中，当仅存在特殊条目时，目录被认为是空的。此方法可以与&lt;a href=&quot;#walkFileTree(java.nio.file.Path,java.util.Set,int,java.nio.file.FileVisitor)&quot;&gt; &lt;code&gt;walkFileTree&lt;/code&gt; &lt;/a&gt;方法一起使用，以删除目录和目录中的所有条目，或者删除整个目录</target>
        </trans-unit>
        <trans-unit id="d0c1117a6df1c8b656d3b8ee4f35129ed11c6504" translate="yes" xml:space="preserve">
          <source>If the file is a directory then the directory must be empty. In some implementations a directory has entries for special files or links that are created when the directory is created. In such implementations a directory is considered empty when only the special entries exist. This method can be used with the &lt;a href=&quot;files#walkFileTree-java.nio.file.Path-java.util.Set-int-java.nio.file.FileVisitor-&quot;&gt;&lt;code&gt;walkFileTree&lt;/code&gt;&lt;/a&gt; method to delete a directory and all entries in the directory, or an entire</source>
          <target state="translated">如果文件是目录，则目录必须为空。在某些实现中，目录具有创建目录时创建的特殊文件或链接的条目。在这样的实现中，当仅存在特殊条目时，目录被认为是空的。此方法可以与&lt;a href=&quot;files#walkFileTree-java.nio.file.Path-java.util.Set-int-java.nio.file.FileVisitor-&quot;&gt; &lt;code&gt;walkFileTree&lt;/code&gt; &lt;/a&gt;方法一起使用，以删除目录和目录中的所有条目，或者删除整个目录</target>
        </trans-unit>
        <trans-unit id="6d651a40c8a6027fa645d02154642d3d0cbb9614" translate="yes" xml:space="preserve">
          <source>If the file is opened for &lt;a href=&quot;#WRITE&quot;&gt;&lt;code&gt;WRITE&lt;/code&gt;&lt;/a&gt; access then bytes will be written to the end of the file rather than the beginning.</source>
          <target state="translated">如果打开文件以进行&lt;a href=&quot;#WRITE&quot;&gt; &lt;code&gt;WRITE&lt;/code&gt; &lt;/a&gt;访问，则字节将被写入文件的末尾而不是开始。</target>
        </trans-unit>
        <trans-unit id="7dbd0c6e9ab04a8789ef0e83e00003ffa2ee9662" translate="yes" xml:space="preserve">
          <source>If the file is opened for &lt;a href=&quot;standardopenoption#WRITE&quot;&gt;&lt;code&gt;WRITE&lt;/code&gt;&lt;/a&gt; access then bytes will be written to the end of the file rather than the beginning.</source>
          <target state="translated">如果打开该文件以进行&lt;a href=&quot;standardopenoption#WRITE&quot;&gt; &lt;code&gt;WRITE&lt;/code&gt; &lt;/a&gt;访问，则字节将被写入文件的末尾而不是开头。</target>
        </trans-unit>
        <trans-unit id="f9d2a8154b6e04db066d371ce68d85675117b48d" translate="yes" xml:space="preserve">
          <source>If the file is opened for write access by other programs, then it is file system specific if writing to the end of the file is atomic.</source>
          <target state="translated">如果文件被其他程序打开写访问,那么如果对文件末尾的写是原子性的,则是文件系统特有的。</target>
        </trans-unit>
        <trans-unit id="363aa2bf9bc4403e90b3304537b4850955de2d6f" translate="yes" xml:space="preserve">
          <source>If the file mapped into this buffer resides on a local storage device then when this method returns it is guaranteed that all changes made to the buffer since it was created, or since this method was last invoked, will have been written to that device.</source>
          <target state="translated">如果映射到这个缓冲区的文件位于本地存储设备上,那么当本方法返回时,保证自创建缓冲区以来或自本方法最后一次被调用以来对缓冲区所做的所有更改都将被写入该设备。</target>
        </trans-unit>
        <trans-unit id="26650d7e2c0ee9c777086da59ae41956022f191f" translate="yes" xml:space="preserve">
          <source>If the file mapped into this buffer resides on a local storage device then when this method returns it is guaranteed that all changes made to the selected region buffer since it was created, or since this method was last invoked, will have been written to that device. The force operation is free to write bytes that lie outside the specified region, for example to ensure that data blocks of some device-specific granularity are transferred in their entirety.</source>
          <target state="translated">如果映射到该缓冲区的文件位于本地存储设备上,那么当该方法返回时,保证自创建以来或自上次调用该方法以来对所选区域缓冲区所做的所有更改都将被写入该设备。强制操作可以自由地写入位于指定区域之外的字节,例如为了保证某些设备特定粒度的数据块被完整地传输。</target>
        </trans-unit>
        <trans-unit id="5c66fa0bc0370be55e7f6902e9819c235f1ae2c1" translate="yes" xml:space="preserve">
          <source>If the file mapped into this segment resides on a local storage device then when this method returns it is guaranteed that all changes made to the segment since it was created, or since this method was last invoked, will have been written to that device.</source>
          <target state="translated">如果映射到这个段的文件驻留在本地存储设备上,那么当这个方法返回时,它保证自该段创建以来,或者自这个方法最后一次被调用以来,对该段所做的所有更改都将被写入该设备。</target>
        </trans-unit>
        <trans-unit id="5d3f80a7c47e0dee8ff25771e1984095801d55de" translate="yes" xml:space="preserve">
          <source>If the file system and files remain static, then this method implements an equivalence relation for non-null &lt;code&gt;Paths&lt;/code&gt;.</source>
          <target state="translated">如果文件系统和文件保持静态，则此方法将对非null &lt;code&gt;Paths&lt;/code&gt; 实现等效关系。</target>
        </trans-unit>
        <trans-unit id="bf2540a956606dd24c05d911dfb014b7471baead" translate="yes" xml:space="preserve">
          <source>If the file system implementation does not support a time stamp to indicate the time of last access then this method returns an implementation specific default value, typically the &lt;a href=&quot;#lastModifiedTime()&quot;&gt;&lt;code&gt;last-modified-time&lt;/code&gt;&lt;/a&gt; or a &lt;code&gt;FileTime&lt;/code&gt; representing the epoch (1970-01-01T00:00:00Z).</source>
          <target state="translated">如果文件系统实现不支持时间戳来指示上次访问的时间，则此方法返回特定于实现的默认值，通常是&lt;a href=&quot;#lastModifiedTime()&quot;&gt; &lt;code&gt;last-modified-time&lt;/code&gt; &lt;/a&gt;或代表纪元（1970-01-01T00：00的 &lt;code&gt;FileTime&lt;/code&gt; ： 00Z）。</target>
        </trans-unit>
        <trans-unit id="1cc09fc7cf4f903c9ad57909dbe23e700dcd6cfb" translate="yes" xml:space="preserve">
          <source>If the file system implementation does not support a time stamp to indicate the time of last access then this method returns an implementation specific default value, typically the &lt;a href=&quot;basicfileattributes#lastModifiedTime--&quot;&gt;&lt;code&gt;last-modified-time&lt;/code&gt;&lt;/a&gt; or a &lt;code&gt;FileTime&lt;/code&gt; representing the epoch (1970-01-01T00:00:00Z).</source>
          <target state="translated">如果文件系统实现不支持时间戳来指示上次访问的时间，则此方法返回特定于实现的默认值，通常是&lt;a href=&quot;basicfileattributes#lastModifiedTime--&quot;&gt; &lt;code&gt;last-modified-time&lt;/code&gt; &lt;/a&gt;或代表纪元（1970-01-01T00：00 的 &lt;code&gt;FileTime&lt;/code&gt; ： 00Z）。</target>
        </trans-unit>
        <trans-unit id="fa544bd520d9dcec26b2ece7f7dc9e779d24b413" translate="yes" xml:space="preserve">
          <source>If the file system implementation does not support a time stamp to indicate the time of last modification then this method returns an implementation specific default value, typically a &lt;code&gt;FileTime&lt;/code&gt; representing the epoch (1970-01-01T00:00:00Z).</source>
          <target state="translated">如果文件系统实现不支持时间戳来指示上次修改的时间，则此方法将返回实现特定的默认值，通常是代表纪元（1970-01-01T00：00：00Z）的 &lt;code&gt;FileTime&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="02f361be725f40f9d2cf1b1f7f87f23ccb88afbd" translate="yes" xml:space="preserve">
          <source>If the file system implementation does not support a time stamp to indicate the time when the file was created then this method returns an implementation specific default value, typically the &lt;a href=&quot;#lastModifiedTime()&quot;&gt;&lt;code&gt;last-modified-time&lt;/code&gt;&lt;/a&gt; or a &lt;code&gt;FileTime&lt;/code&gt; representing the epoch (1970-01-01T00:00:00Z).</source>
          <target state="translated">如果文件系统实现不支持时间戳来指示创建文件的时间，则此方法返回特定于实现的默认值，通常是&lt;a href=&quot;#lastModifiedTime()&quot;&gt; &lt;code&gt;last-modified-time&lt;/code&gt; &lt;/a&gt;或代表时期的 &lt;code&gt;FileTime&lt;/code&gt; （1970-01-01T00： 00：00Z）。</target>
        </trans-unit>
        <trans-unit id="823bb3918b8c7dfd2716375b3397ec3520a2d6b4" translate="yes" xml:space="preserve">
          <source>If the file system implementation does not support a time stamp to indicate the time when the file was created then this method returns an implementation specific default value, typically the &lt;a href=&quot;basicfileattributes#lastModifiedTime--&quot;&gt;&lt;code&gt;last-modified-time&lt;/code&gt;&lt;/a&gt; or a &lt;code&gt;FileTime&lt;/code&gt; representing the epoch (1970-01-01T00:00:00Z).</source>
          <target state="translated">如果文件系统实现不支持的时间戳，以指示何时创建文件，则此方法返回一个特定于实现的默认值，典型地，时间&lt;a href=&quot;basicfileattributes#lastModifiedTime--&quot;&gt; &lt;code&gt;last-modified-time&lt;/code&gt; &lt;/a&gt;或 &lt;code&gt;FileTime&lt;/code&gt; 表示纪元（1970-01-01T00： 00：00Z）。</target>
        </trans-unit>
        <trans-unit id="cbaa60988de0c25a04ce29dd95934e886dae24fd" translate="yes" xml:space="preserve">
          <source>If the file system object identified by this object is currently registered with the watch service then the watch key, representing that registration, is returned after changing the event set or modifiers to those specified by the &lt;code&gt;events&lt;/code&gt; and &lt;code&gt;modifiers&lt;/code&gt; parameters. Changing the event set does not cause pending events for the object to be discarded. Objects are automatically registered for the &lt;a href=&quot;standardwatcheventkinds#OVERFLOW&quot;&gt;&lt;code&gt;OVERFLOW&lt;/code&gt;&lt;/a&gt; event. This event is not required to be present in the array of events.</source>
          <target state="translated">如果此对象标识的文件系统对象当前已在监视服务中注册，则在将事件集或修饰符更改为 &lt;code&gt;events&lt;/code&gt; 和 &lt;code&gt;modifiers&lt;/code&gt; 参数指定的键之后，将返回表示该注册的监视键。更改事件集不会导致对象的挂起事件被丢弃。将自动为&lt;a href=&quot;standardwatcheventkinds#OVERFLOW&quot;&gt; &lt;code&gt;OVERFLOW&lt;/code&gt; &lt;/a&gt;事件注册对象。该事件不需要出现在事件数组中。</target>
        </trans-unit>
        <trans-unit id="459754495e8f2fc830a24baaf3d7fd1c98e3b5d4" translate="yes" xml:space="preserve">
          <source>If the file system supports &lt;a href=&quot;package-summary#links&quot;&gt;symbolic links&lt;/a&gt; then this method is used to read the target of the link, failing if the file is not a symbolic link. The target of the link need not exist. The returned &lt;code&gt;Path&lt;/code&gt; object will be associated with the same file system as &lt;code&gt;link&lt;/code&gt;.</source>
          <target state="translated">如果文件系统支持&lt;a href=&quot;package-summary#links&quot;&gt;符号链接，&lt;/a&gt;则使用此方法读取链接的目标，如果文件不是符号链接，则失败。链接的目标不需要存在。返回的 &lt;code&gt;Path&lt;/code&gt; 对象将与 &lt;code&gt;link&lt;/code&gt; 相同的文件系统关联。</target>
        </trans-unit>
        <trans-unit id="fb0c8d3a8a398a77e00455877d296ebfc50c2a10" translate="yes" xml:space="preserve">
          <source>If the file system supports other security related file attributes (such as a file &lt;a href=&quot;posixfileattributes#permissions()&quot;&gt;&lt;code&gt;access-permissions&lt;/code&gt;&lt;/a&gt; for example), the updating the access control list may also cause these security related attributes to be updated.</source>
          <target state="translated">如果文件系统支持其他与安全性有关的文件属性（例如，文件&lt;a href=&quot;posixfileattributes#permissions()&quot;&gt; &lt;code&gt;access-permissions&lt;/code&gt; &lt;/a&gt;），则更新访问控制列表还可能导致这些与安全性有关的属性被更新。</target>
        </trans-unit>
        <trans-unit id="d7347290370c35baf47e41039a48176f518ba6b9" translate="yes" xml:space="preserve">
          <source>If the file system supports other security related file attributes (such as a file &lt;a href=&quot;posixfileattributes#permissions--&quot;&gt;&lt;code&gt;access-permissions&lt;/code&gt;&lt;/a&gt; for example), the updating the access control list may also cause these security related attributes to be updated.</source>
          <target state="translated">如果文件系统支持其他与安全相关的文件属性（例如，文件&lt;a href=&quot;posixfileattributes#permissions--&quot;&gt; &lt;code&gt;access-permissions&lt;/code&gt; &lt;/a&gt;），则更新访问控制列表还可能导致这些与安全相关的属性被更新。</target>
        </trans-unit>
        <trans-unit id="67de7dc4816dc3dd80c82da2f81ec2067ab1b35e" translate="yes" xml:space="preserve">
          <source>If the filter returns &lt;a href=&quot;objectinputfilter.status#REJECTED&quot;&gt;&lt;code&gt;Status.REJECTED&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;null&lt;/code&gt; or throws a &lt;a href=&quot;../lang/runtimeexception&quot;&gt;&lt;code&gt;RuntimeException&lt;/code&gt;&lt;/a&gt;, the active &lt;code&gt;readObject&lt;/code&gt; or &lt;code&gt;readUnshared&lt;/code&gt; throws &lt;a href=&quot;invalidclassexception&quot;&gt;&lt;code&gt;InvalidClassException&lt;/code&gt;&lt;/a&gt;, otherwise deserialization continues uninterrupted.</source>
          <target state="translated">如果过滤器返回&lt;a href=&quot;objectinputfilter.status#REJECTED&quot;&gt; &lt;code&gt;Status.REJECTED&lt;/code&gt; &lt;/a&gt;，为 &lt;code&gt;null&lt;/code&gt; 或抛出&lt;a href=&quot;../lang/runtimeexception&quot;&gt; &lt;code&gt;RuntimeException&lt;/code&gt; &lt;/a&gt;，则活动的 &lt;code&gt;readObject&lt;/code&gt; 或 &lt;code&gt;readUnshared&lt;/code&gt; 抛出&lt;a href=&quot;invalidclassexception&quot;&gt; &lt;code&gt;InvalidClassException&lt;/code&gt; &lt;/a&gt;，否则反序列化将继续进行而不会中断。</target>
        </trans-unit>
        <trans-unit id="9f05868501904493829d0907142a7754fe1122ce" translate="yes" xml:space="preserve">
          <source>If the filter returns a value, the target must accept that value as its argument in position &lt;code&gt;pos&lt;/code&gt;, preceded and/or followed by any arguments not passed to the filter. If the filter returns void, the target must accept all arguments not passed to the filter. No arguments are reordered, and a result returned from the filter replaces (in order) the whole subsequence of arguments originally passed to the adapter.</source>
          <target state="translated">如果过滤器返回一个值，则目标必须在位置 &lt;code&gt;pos&lt;/code&gt; 接受该值作为其参数，在此之前和/或之后是未传递给过滤器的任何参数。如果过滤器返回void，则目标必须接受未传递给过滤器的所有参数。没有对参数进行重新排序，并且从过滤器返回的结果将替换（按顺序）最初传递给适配器的参数的整个子序列。</target>
        </trans-unit>
        <trans-unit id="4842b7ba908041edda9019cd8af48573f8706e76" translate="yes" xml:space="preserve">
          <source>If the first &lt;code&gt;read&lt;/code&gt; on the underlying stream returns &lt;code&gt;-1&lt;/code&gt; to indicate end-of-file then this method returns &lt;code&gt;-1&lt;/code&gt;. Otherwise this method returns the number of bytes actually read.</source>
          <target state="translated">如果对基础流的第一次 &lt;code&gt;read&lt;/code&gt; 返回 &lt;code&gt;-1&lt;/code&gt; 以指示文件结束，则此方法返回 &lt;code&gt;-1&lt;/code&gt; 。否则，此方法返回实际读取的字节数。</target>
        </trans-unit>
        <trans-unit id="33b359247ef4ee2d114342c7c506f4ed4d411b51" translate="yes" xml:space="preserve">
          <source>If the first &lt;code&gt;read&lt;/code&gt; on the underlying stream returns &lt;code&gt;-1&lt;/code&gt; to indicate end-of-file then this method returns &lt;code&gt;-1&lt;/code&gt;. Otherwise this method returns the number of characters actually read.</source>
          <target state="translated">如果对基础流的第一次 &lt;code&gt;read&lt;/code&gt; 返回 &lt;code&gt;-1&lt;/code&gt; 以指示文件结束，则此方法返回 &lt;code&gt;-1&lt;/code&gt; 。否则，此方法返回实际读取的字符数。</target>
        </trans-unit>
        <trans-unit id="ce60218f2510c7e7fddf8a7ccb70e4c23d7ed409" translate="yes" xml:space="preserve">
          <source>If the first argument is NaN and the second argument is nonzero, then the result is NaN.</source>
          <target state="translated">如果第一个参数是NaN,第二个参数是非零,那么结果就是NaN。</target>
        </trans-unit>
        <trans-unit id="8870d606c771442922f1503139366f1c5f6ffb42" translate="yes" xml:space="preserve">
          <source>If the first argument is NaN, NaN is returned.</source>
          <target state="translated">如果第一个参数是NaN,则返回NaN。</target>
        </trans-unit>
        <trans-unit id="9089269bb48d32b9328e7c9f2b5e776cab13b138" translate="yes" xml:space="preserve">
          <source>If the first argument is finite and less than zero</source>
          <target state="translated">如果第一个参数是有限的,且小于零。</target>
        </trans-unit>
        <trans-unit id="40390f7aa327fdf0e7159e3c2ee52c76dda4cc5d" translate="yes" xml:space="preserve">
          <source>If the first argument is finite and the second argument is infinite, then the result is the same as the first argument.</source>
          <target state="translated">如果第一个论点是有限的,第二个论点是无限的,那么结果与第一个论点相同。</target>
        </trans-unit>
        <trans-unit id="c79e66b15f81ddc9a951871c47a016d3318d1439" translate="yes" xml:space="preserve">
          <source>If the first argument is infinite, then an infinity of the same sign is returned.</source>
          <target state="translated">如果第一个参数是无穷大,那么将返回一个相同符号的无穷大。</target>
        </trans-unit>
        <trans-unit id="ac7d4927f7484d5a09a609cfa4c9572e1d2c7f45" translate="yes" xml:space="preserve">
          <source>If the first argument is negative and the second argument is positive zero or negative zero, or the first argument is negative infinity and the second argument is finite, then the result is the &lt;code&gt;double&lt;/code&gt; value closest to -</source>
          <target state="translated">如果第一个参数为负，第二个参数为正零或负零，或者第一个参数为负无穷大，第二个参数为有限，那么结果是最接近- 的 &lt;code&gt;double&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="c8e4a59b27a1fe3d520aae3637f149a7db9573ea" translate="yes" xml:space="preserve">
          <source>If the first argument is negative infinity and the second argument is positive infinity, then the result is the &lt;code&gt;double&lt;/code&gt; value closest to -</source>
          <target state="translated">如果第一个参数为负无穷大，第二个参数为正无穷大，则结果是最接近- 的 &lt;code&gt;double&lt;/code&gt; 值</target>
        </trans-unit>
        <trans-unit id="82b10d31a7012b44b539ae72f08e4e4c13a206b9" translate="yes" xml:space="preserve">
          <source>If the first argument is negative zero and the second argument is negative, or the first argument is negative and finite and the second argument is negative infinity, then the result is the &lt;code&gt;double&lt;/code&gt; value closest to -</source>
          <target state="translated">如果第一个参数为负零，第二个参数为负，或者第一个参数为负且有限，第二个参数为负无穷大，则结果是最接近- 的 &lt;code&gt;double&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="8e475337333e7011c577f6dfd579b80f0f2ae245" translate="yes" xml:space="preserve">
          <source>If the first argument is negative zero and the second argument is positive, or the first argument is negative and finite and the second argument is positive infinity, then the result is negative zero.</source>
          <target state="translated">如果第一个论点是负零,第二个论点是正数,或者第一个论点是负有限,第二个论点是正无限,那么结果就是负零。</target>
        </trans-unit>
        <trans-unit id="e71c64d3bcd633902a2d641246fcfc98d2800c74" translate="yes" xml:space="preserve">
          <source>If the first argument is negative, the first element of the result is the ASCII minus character &lt;code&gt;'-'&lt;/code&gt; (&lt;code&gt;'\u002D'&lt;/code&gt;). If the first argument is not negative, no sign character appears in the result.</source>
          <target state="translated">如果第一个参数为负，则结果的第一个元素为ASCII减号 &lt;code&gt;'-'&lt;/code&gt; （ &lt;code&gt;'\u002D'&lt;/code&gt; ）。如果第一个参数不为负，则结果中不会出现符号字符。</target>
        </trans-unit>
        <trans-unit id="f757bab2a5b1e8678119d7c70a633d7f48cfbb1b" translate="yes" xml:space="preserve">
          <source>If the first argument is negative, the first element of the result is the ASCII minus sign &lt;code&gt;'-'&lt;/code&gt; (&lt;code&gt;'\u002d'&lt;/code&gt;). If the first argument is not negative, no sign character appears in the result.</source>
          <target state="translated">如果第一个参数为负，则结果的第一个元素为ASCII减号 &lt;code&gt;'-'&lt;/code&gt; （ &lt;code&gt;'\u002d'&lt;/code&gt; ）。如果第一个参数不为负，则结果中不会出现符号字符。</target>
        </trans-unit>
        <trans-unit id="be73a6c34da2b109aed6beaf3902ff7b8fa1d76b" translate="yes" xml:space="preserve">
          <source>If the first argument is positive and the second argument is positive zero or negative zero, or the first argument is positive infinity and the second argument is finite, then the result is the &lt;code&gt;double&lt;/code&gt; value closest to</source>
          <target state="translated">如果第一个参数为正，第二个参数为正零或负零，或者第一个参数为正无穷大，而第二个参数为有限，那么结果是最接近的 &lt;code&gt;double&lt;/code&gt; 值</target>
        </trans-unit>
        <trans-unit id="ebb6e09520d0766b54210b09e064a33ea2e4b570" translate="yes" xml:space="preserve">
          <source>If the first argument is positive infinity and the second argument is negative infinity, then the result is the &lt;code&gt;double&lt;/code&gt; value closest to 3*</source>
          <target state="translated">如果第一个参数为正无穷大，第二个参数为负无穷大，则结果是最接近3 * 的 &lt;code&gt;double&lt;/code&gt; 值</target>
        </trans-unit>
        <trans-unit id="a545d4a869ce0070ee3a2c5a7bd5c19feeb5e959" translate="yes" xml:space="preserve">
          <source>If the first argument is positive zero and the second argument is negative, or the first argument is positive and finite and the second argument is negative infinity, then the result is the &lt;code&gt;double&lt;/code&gt; value closest to</source>
          <target state="translated">如果第一个参数是正零，第二个参数是负的，或者第一参数是正的有限值，第二个参数是负无穷大，那么结果是 &lt;code&gt;double&lt;/code&gt; 最接近值</target>
        </trans-unit>
        <trans-unit id="2b99cd366559b0aa882f76d5433c550ae23a29d2" translate="yes" xml:space="preserve">
          <source>If the first argument is positive zero and the second argument is positive, or the first argument is positive and finite and the second argument is positive infinity, then the result is positive zero.</source>
          <target state="translated">如果第一个论点是正零,第二个论点是正数,或者第一个论点是正有限,第二个论点是正无穷,那么结果就是正零。</target>
        </trans-unit>
        <trans-unit id="90dbabf1b114fed471b1a3cd65fc77c1740f1756" translate="yes" xml:space="preserve">
          <source>If the first argument is zero, then a zero of the same sign is returned.</source>
          <target state="translated">如果第一个参数为零,则返回相同符号的零。</target>
        </trans-unit>
        <trans-unit id="a1663731875dc28dccca70ad4bb3ad9c2ee28bff" translate="yes" xml:space="preserve">
          <source>If the first byte of a group matches the bit pattern &lt;code&gt;0xxxxxxx&lt;/code&gt; (where &lt;code&gt;x&lt;/code&gt; means &quot;may be &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt;&quot;), then the group consists of just that byte. The byte is zero-extended to form a character.</source>
          <target state="translated">如果组的第一个字节与位模式 &lt;code&gt;0xxxxxxx&lt;/code&gt; 相匹配（其中 &lt;code&gt;x&lt;/code&gt; 表示&amp;ldquo;可能是 &lt;code&gt;0&lt;/code&gt; 或 &lt;code&gt;1&lt;/code&gt; &amp;rdquo;），则该组仅由该字节组成。字节零扩展以形成一个字符。</target>
        </trans-unit>
        <trans-unit id="43977f5f9b49b5f068ba277caf7c1c9b82cc82fa" translate="yes" xml:space="preserve">
          <source>If the first byte of a group matches the bit pattern &lt;code&gt;110xxxxx&lt;/code&gt;, then the group consists of that byte &lt;code&gt;a&lt;/code&gt; and a second byte &lt;code&gt;b&lt;/code&gt;. If there is no byte &lt;code&gt;b&lt;/code&gt; (because byte &lt;code&gt;a&lt;/code&gt; was the last of the bytes to be read), or if byte &lt;code&gt;b&lt;/code&gt; does not match the bit pattern &lt;code&gt;10xxxxxx&lt;/code&gt;, then a &lt;code&gt;UTFDataFormatException&lt;/code&gt; is thrown. Otherwise, the group is converted to the character:</source>
          <target state="translated">如果组的第一个字节与位模式 &lt;code&gt;110xxxxx&lt;/code&gt; 相匹配，则该组由该字节 &lt;code&gt;a&lt;/code&gt; 和第二个字节 &lt;code&gt;b&lt;/code&gt; 组成。如果没有字节 &lt;code&gt;b&lt;/code&gt; （因为字节 &lt;code&gt;a&lt;/code&gt; 是要读取的最后一个字节），或者如果字节 &lt;code&gt;b&lt;/code&gt; 与位模式 &lt;code&gt;10xxxxxx&lt;/code&gt; 不匹配，则抛出 &lt;code&gt;UTFDataFormatException&lt;/code&gt; 。否则，该组将转换为字符：</target>
        </trans-unit>
        <trans-unit id="d0e5e1a187c24e47368e1814e48c4f2e5999e848" translate="yes" xml:space="preserve">
          <source>If the first byte of a group matches the bit pattern &lt;code&gt;1110xxxx&lt;/code&gt;, then the group consists of that byte &lt;code&gt;a&lt;/code&gt; and two more bytes &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt;. If there is no byte &lt;code&gt;c&lt;/code&gt; (because byte &lt;code&gt;a&lt;/code&gt; was one of the last two of the bytes to be read), or either byte &lt;code&gt;b&lt;/code&gt; or byte &lt;code&gt;c&lt;/code&gt; does not match the bit pattern &lt;code&gt;10xxxxxx&lt;/code&gt;, then a &lt;code&gt;UTFDataFormatException&lt;/code&gt; is thrown. Otherwise, the group is converted to the character:</source>
          <target state="translated">如果组的第一个字节与位模式 &lt;code&gt;1110xxxx&lt;/code&gt; 相匹配，则该组由该字节 &lt;code&gt;a&lt;/code&gt; 和另外两个字节 &lt;code&gt;b&lt;/code&gt; 和 &lt;code&gt;c&lt;/code&gt; 组成。如果没有字节 &lt;code&gt;c&lt;/code&gt; （因为字节 &lt;code&gt;a&lt;/code&gt; 是要读取的最后两个字节之一），或者字节 &lt;code&gt;b&lt;/code&gt; 或字节 &lt;code&gt;c&lt;/code&gt; 与位模式 &lt;code&gt;10xxxxxx&lt;/code&gt; 不匹配，则抛出 &lt;code&gt;UTFDataFormatException&lt;/code&gt; 。否则，该组将转换为字符：</target>
        </trans-unit>
        <trans-unit id="4b4205a0b70ecc18a1f7d17bb4cefe1ef7847e2c" translate="yes" xml:space="preserve">
          <source>If the first byte of a group matches the pattern &lt;code&gt;1111xxxx&lt;/code&gt; or the pattern &lt;code&gt;10xxxxxx&lt;/code&gt;, then a &lt;code&gt;UTFDataFormatException&lt;/code&gt; is thrown.</source>
          <target state="translated">如果组的第一个字节与模式 &lt;code&gt;1111xxxx&lt;/code&gt; 或模式 &lt;code&gt;10xxxxxx&lt;/code&gt; 相匹配，则将引发 &lt;code&gt;UTFDataFormatException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="de12fa584ec591ad89fe529ab99890cef05ff7df" translate="yes" xml:space="preserve">
          <source>If the first character of &lt;code&gt;path&lt;/code&gt; is &lt;code&gt;'/'&lt;/code&gt; (indicating an absolute path name) this preference node's lock is dropped prior to breaking &lt;code&gt;path&lt;/code&gt; into tokens, and this method recursively traverses the path starting from the root (rather than starting from this node). The traversal is otherwise identical to the one described for relative path names. Dropping the lock on this node prior to commencing the traversal at the root node is essential to avoid the possibility of deadlock, as per the &lt;a href=&quot;#lock&quot;&gt;&lt;code&gt;locking invariant&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;path&lt;/code&gt; 的第一个字符为 &lt;code&gt;'/'&lt;/code&gt; （表示绝对路径名），则在将 &lt;code&gt;path&lt;/code&gt; 分成令牌之前，将删除此首选项节点的锁，并且此方法以从根（而不是从该节点开始）的方式递归遍历该路径。在其他方面，遍历与针对相对路径名描述的遍历相同。根据&lt;a href=&quot;#lock&quot;&gt; &lt;code&gt;locking invariant&lt;/code&gt; &lt;/a&gt;，在根节点上开始遍历之前删除该节点上的锁对于避免死锁的可能性至关重要。</target>
        </trans-unit>
        <trans-unit id="fe4bd2bc924f289ce5e3e243830c506290c8bfa3" translate="yes" xml:space="preserve">
          <source>If the first character of &lt;code&gt;path&lt;/code&gt; is &lt;code&gt;'/'&lt;/code&gt; (indicating an absolute path name) this preference node's lock is dropped prior to breaking &lt;code&gt;path&lt;/code&gt; into tokens, and this method recursively traverses the path starting from the root (rather than starting from this node). The traversal is otherwise identical to the one described for relative path names. Dropping the lock on this node prior to commencing the traversal at the root node is essential to avoid the possibility of deadlock, as per the &lt;a href=&quot;abstractpreferences#lock&quot;&gt;&lt;code&gt;locking invariant&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;path&lt;/code&gt; 的第一个字符为 &lt;code&gt;'/'&lt;/code&gt; （表示绝对路径名），则在将 &lt;code&gt;path&lt;/code&gt; 分成令牌之前，将删除此首选项节点的锁，并且此方法以从根（而不是从该节点开始）的方式递归遍历该路径。遍历在其他方面与针对相对路径名描述的遍历相同。根据&lt;a href=&quot;abstractpreferences#lock&quot;&gt; &lt;code&gt;locking invariant&lt;/code&gt; &lt;/a&gt;，在根节点上开始遍历之前，在此节点上放下锁对于避免死锁的可能性至关重要。</target>
        </trans-unit>
        <trans-unit id="de6a756f5a999d243dc3d549609d91cce131f2d6" translate="yes" xml:space="preserve">
          <source>If the first letter of the property defined by a getter is a capital, then this handler will look first for an item in the &lt;code&gt;CompositeData&lt;/code&gt; beginning with a capital, then, if that is not found, for an item beginning with the corresponding lowercase letter or code point. For a getter called &lt;code&gt;getNumber()&lt;/code&gt;, the handler will first look for an item called &lt;code&gt;Number&lt;/code&gt;, then for &lt;code&gt;number&lt;/code&gt;. If the getter is called &lt;code&gt;getnumber()&lt;/code&gt;, then the item must be called &lt;code&gt;number&lt;/code&gt;.</source>
          <target state="translated">如果由吸气剂定义的属性的第一个字母为大写字母，则此处理程序将首先在 &lt;code&gt;CompositeData&lt;/code&gt; 中查找以大写字母开头的项，然后，如果找不到，则查找以相应的小写字母开头的项或代码点。对于名为 &lt;code&gt;getNumber()&lt;/code&gt; 的吸气剂，处理程序将首先查找名为 &lt;code&gt;Number&lt;/code&gt; 的项目，然后查找 &lt;code&gt;number&lt;/code&gt; 。如果将getter称为 &lt;code&gt;getnumber()&lt;/code&gt; ，则该项目必须称为 &lt;code&gt;number&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c5b9fdddf990174b0c1bb31fd056338ffdb9f842" translate="yes" xml:space="preserve">
          <source>If the flag argument is &lt;code&gt;false&lt;/code&gt;, then C++-style comments are not treated specially.</source>
          <target state="translated">如果flag参数为 &lt;code&gt;false&lt;/code&gt; ，则不特别对待C ++样式的注释。</target>
        </trans-unit>
        <trans-unit id="6b755352a37aefb0ddd22fcf4ddac56889ee380f" translate="yes" xml:space="preserve">
          <source>If the flag argument is &lt;code&gt;false&lt;/code&gt;, then C-style comments are not treated specially.</source>
          <target state="translated">如果flag参数为 &lt;code&gt;false&lt;/code&gt; ，则不对C样式的注释进行特殊处理。</target>
        </trans-unit>
        <trans-unit id="ed5b11ba23b450c90177463610accda7b5ef8311" translate="yes" xml:space="preserve">
          <source>If the flag argument is &lt;code&gt;false&lt;/code&gt;, then the &lt;code&gt;sval&lt;/code&gt; field is not modified.</source>
          <target state="translated">如果flag参数为 &lt;code&gt;false&lt;/code&gt; ，则不会修改 &lt;code&gt;sval&lt;/code&gt; 字段。</target>
        </trans-unit>
        <trans-unit id="a51b936e9c60259867a0c6a0a1415a7006e73bc6" translate="yes" xml:space="preserve">
          <source>If the flag is &lt;code&gt;false&lt;/code&gt;, delimiter characters serve to separate tokens. A token is a maximal sequence of consecutive characters that are not delimiters.</source>
          <target state="translated">如果该标志为 &lt;code&gt;false&lt;/code&gt; ，则分隔符用于分隔标记。令牌是不是定界符的连续字符的最大序列。</target>
        </trans-unit>
        <trans-unit id="243de70bc00db3702139f3dd218555f6b229e223" translate="yes" xml:space="preserve">
          <source>If the flag is &lt;code&gt;true&lt;/code&gt;, delimiter characters are themselves considered to be tokens. A token is thus either one delimiter character, or a maximal sequence of consecutive characters that are not delimiters.</source>
          <target state="translated">如果该标志为 &lt;code&gt;true&lt;/code&gt; ，则分隔符本身被视为标记。因此，令牌可以是一个分隔符，也可以是不是分隔符的最大连续字符序列。</target>
        </trans-unit>
        <trans-unit id="b5b0bc25b0d262fecfa18b60166faf5e2347e80f" translate="yes" xml:space="preserve">
          <source>If the flag is set to &lt;code&gt;true&lt;/code&gt;, this text component becomes user editable. If the flag is set to &lt;code&gt;false&lt;/code&gt;, the user cannot change the text of this text component. By default, non-editable text components have a background color of SystemColor.control. This default can be overridden by calling setBackground.</source>
          <target state="translated">如果该标志设置为 &lt;code&gt;true&lt;/code&gt; ，则此文本组件将变为用户可编辑的。如果该标志设置为 &lt;code&gt;false&lt;/code&gt; ，则用户无法更改此文本组件的文本。默认情况下，不可编辑的文本组件的背景色为SystemColor.control。可以通过调用setBackground覆盖此默认值。</target>
        </trans-unit>
        <trans-unit id="f57f350c5b50d157976b5f5f9a315e16106f5450" translate="yes" xml:space="preserve">
          <source>If the focused Window is a Frame or a Dialog it is also the active Window. Otherwise, the active Window is the first Frame or Dialog that is an owner of the focused Window.</source>
          <target state="translated">如果聚焦的窗口是一个框架或对话框,它也是活动窗口。否则,活动窗口是焦点窗口的第一个框架或对话框的所有者。</target>
        </trans-unit>
        <trans-unit id="56c6279667d7868f05ad4fddd3dde243109f6834" translate="yes" xml:space="preserve">
          <source>If the font is &lt;code&gt;null&lt;/code&gt; or a &lt;code&gt;UIResource&lt;/code&gt;, the defaults table is queried with the key &lt;code&gt;fontKey&lt;/code&gt;. All of &lt;code&gt;UIDefault's&lt;/code&gt; get methods throw a &lt;code&gt;
 NullPointerException&lt;/code&gt; if passed in &lt;code&gt;null&lt;/code&gt;. As such, unless otherwise noted each of the various install methods of &lt;code&gt;
 LookAndFeel&lt;/code&gt; throw a &lt;code&gt;NullPointerException&lt;/code&gt; if the current value is &lt;code&gt;null&lt;/code&gt; or a &lt;code&gt;UIResource&lt;/code&gt; and the supplied defaults key is &lt;code&gt;null&lt;/code&gt;. In addition, unless otherwise specified all of the &lt;code&gt;install&lt;/code&gt; methods throw a &lt;code&gt;NullPointerException&lt;/code&gt; if a &lt;code&gt;null&lt;/code&gt; component is passed in.</source>
          <target state="translated">如果字体为 &lt;code&gt;null&lt;/code&gt; 或 &lt;code&gt;UIResource&lt;/code&gt; ，则使用键 &lt;code&gt;fontKey&lt;/code&gt; 查询默认表。如果传入 &lt;code&gt;null&lt;/code&gt; ,则所有 &lt;code&gt;UIDefault's&lt;/code&gt; get方法都会抛出 &lt;code&gt; NullPointerException&lt;/code&gt; 。这样，除非另有说明，否则，如果当前值为 &lt;code&gt;null&lt;/code&gt; 或 &lt;code&gt;UIResource&lt;/code&gt; ，并且提供的默认键为 &lt;code&gt;null&lt;/code&gt; ，则 &lt;code&gt; LookAndFeel&lt;/code&gt; 的各种安装方法均会抛出 &lt;code&gt;NullPointerException&lt;/code&gt; 。此外，除非另有说明，所有的 &lt;code&gt;install&lt;/code&gt; 方法抛出一个 &lt;code&gt;NullPointerException&lt;/code&gt; 异常，如果 &lt;code&gt;null&lt;/code&gt; 组件被传入。</target>
        </trans-unit>
        <trans-unit id="f77a5cbbfc5e7d2a5c0ad6a18e49115f1c49efaa" translate="yes" xml:space="preserve">
          <source>If the format of an argument loses information, such as with a choice format where a large number formats to &quot;many&quot;.</source>
          <target state="translated">如果一个论点的格式丢失了信息,比如选择格式,大数格式为 &quot;多&quot;。</target>
        </trans-unit>
        <trans-unit id="0dcd3261c6e6bc40c628cfcd3ed02c38b9a8ba09" translate="yes" xml:space="preserve">
          <source>If the format specifier contains a width or precision with an invalid value or which is otherwise unsupported, then a &lt;a href=&quot;illegalformatwidthexception&quot;&gt;&lt;code&gt;IllegalFormatWidthException&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;illegalformatprecisionexception&quot;&gt;&lt;code&gt;IllegalFormatPrecisionException&lt;/code&gt;&lt;/a&gt; respectively will be thrown.</source>
          <target state="translated">如果格式说明符包含具有无效值的宽度或精度，或者否则不支持该宽度或精度，&lt;a href=&quot;illegalformatprecisionexception&quot;&gt; &lt;code&gt;IllegalFormatPrecisionException&lt;/code&gt; &lt;/a&gt;分别抛出&lt;a href=&quot;illegalformatwidthexception&quot;&gt; &lt;code&gt;IllegalFormatWidthException&lt;/code&gt; &lt;/a&gt;或IllegalFormatPrecisionException。</target>
        </trans-unit>
        <trans-unit id="23d86bd64d57a83827a905eb3f62752e01b0a38e" translate="yes" xml:space="preserve">
          <source>If the formatter parses the same field more than once with different values, the result will be an error.</source>
          <target state="translated">如果格式化器多次用不同的值解析同一个字段,结果将是一个错误。</target>
        </trans-unit>
        <trans-unit id="db3731fc2aa4a3e087228df78b6ed03888b9aa5c" translate="yes" xml:space="preserve">
          <source>If the function returns &lt;code&gt;null&lt;/code&gt; no mapping is recorded. If the function itself throws an (unchecked) exception, the exception is rethrown, and no mapping is recorded. The most common usage is to construct a new object serving as an initial mapped value or memoized result, as in:</source>
          <target state="translated">如果函数返回 &lt;code&gt;null&lt;/code&gt; ,则不会记录任何映射。如果函数本身引发（未经检查的）异常，则重新引发该异常，并且不记录任何映射。最常见的用法是构造一个新对象，用作初始映射值或备注结果，如下所示：</target>
        </trans-unit>
        <trans-unit id="144af7e618eb46c9529d1d33c26d53810f2167da" translate="yes" xml:space="preserve">
          <source>If the function returns &lt;code&gt;null&lt;/code&gt; the mapping is removed. If the function itself throws an (unchecked) exception, the exception is rethrown, and the current mapping is left unchanged.</source>
          <target state="translated">如果函数返回 &lt;code&gt;null&lt;/code&gt; ，则删除映射。如果函数本身抛出（未经检查的）异常，则重新引发该异常，并且当前映射保持不变。</target>
        </trans-unit>
        <trans-unit id="26f473bb6caf3da04b1285866c6a28b1b984ef5f" translate="yes" xml:space="preserve">
          <source>If the function returns &lt;code&gt;null&lt;/code&gt;, the mapping is removed (or remains absent if initially absent). If the function itself throws an (unchecked) exception, the exception is rethrown, and the current mapping is left unchanged.</source>
          <target state="translated">如果函数返回 &lt;code&gt;null&lt;/code&gt; ，则删除映射（如果最初不存在，则保持不存在）。如果函数本身抛出（未经检查的）异常，则重新引发该异常，并且当前映射保持不变。</target>
        </trans-unit>
        <trans-unit id="91e50d7000baf56cbe84741a636dedc280c25287" translate="yes" xml:space="preserve">
          <source>If the function returns &lt;code&gt;null&lt;/code&gt;, the mapping is removed. If the function itself throws an (unchecked) exception, the exception is rethrown, and the current mapping is left unchanged.</source>
          <target state="translated">如果函数返回 &lt;code&gt;null&lt;/code&gt; ，则删除映射。如果函数本身抛出（未经检查的）异常，则重新引发该异常，并且当前映射保持不变。</target>
        </trans-unit>
        <trans-unit id="926782c512e4f063b419e0421193c8c7a7433138" translate="yes" xml:space="preserve">
          <source>If the function succeeds, instrument &lt;code&gt;from&lt;/code&gt; is unloaded.</source>
          <target state="translated">如果功能成功，仪器 &lt;code&gt;from&lt;/code&gt; 被卸载。</target>
        </trans-unit>
        <trans-unit id="253e6025d142f63cd0c731b35e5e54635921bd1e" translate="yes" xml:space="preserve">
          <source>If the function to map a module name to class loader throws an error or runtime exception then it is propagated to the caller of this method.</source>
          <target state="translated">如果将模块名映射到类加载器的函数抛出一个错误或运行时异常,那么它将被传播给这个方法的调用者。</target>
        </trans-unit>
        <trans-unit id="32a91e07ee88bec0b9954a59c4de099b9aa8f328" translate="yes" xml:space="preserve">
          <source>If the garbage collector determines at a certain point in time that the referent of a phantom reference is &lt;a href=&quot;package-summary#reachability&quot;&gt;phantom reachable&lt;/a&gt;, then at that time or at some later time it will enqueue the reference.</source>
          <target state="translated">如果垃圾收集器在某个时间点确定幻像引用的参照对象是&lt;a href=&quot;package-summary#reachability&quot;&gt;幻像可到达的&lt;/a&gt;，则在那个时候或以后的某个时间，它将使该引用入队。</target>
        </trans-unit>
        <trans-unit id="53adf0e26e84566de9caa7cabb62afdabd38f865" translate="yes" xml:space="preserve">
          <source>If the gauge difference mode is used, the value of the derived gauge is calculated as the difference between the observed gauge values for two successive observations.</source>
          <target state="translated">如果采用轨距差模式,则推导的轨距值按连续两次观测的轨距值之差计算。</target>
        </trans-unit>
        <trans-unit id="f36edc06d9e8ab3918e6499129015f8c141e7e54" translate="yes" xml:space="preserve">
          <source>If the generator function throws an exception, an unchecked exception is thrown from &lt;code&gt;parallelSetAll&lt;/code&gt; and the array is left in an indeterminate state.</source>
          <target state="translated">如果生成器函数引发异常，则会从 &lt;code&gt;parallelSetAll&lt;/code&gt; 引发未经检查的异常，并且数组将处于不确定状态。</target>
        </trans-unit>
        <trans-unit id="9d8173ed15e9b7709fd7094f05762f38b139637d" translate="yes" xml:space="preserve">
          <source>If the generator function throws an exception, it is relayed to the caller and the array is left in an indeterminate state.</source>
          <target state="translated">如果生成函数抛出异常,就会被转达给调用者,数组就会处于不确定的状态。</target>
        </trans-unit>
        <trans-unit id="76782efd69d7292ec1741cf01ee5b2215277c044" translate="yes" xml:space="preserve">
          <source>If the given &lt;code&gt;CompositeData&lt;/code&gt; does not contain this attribute, This attribute will be set to &lt;a href=&quot;../../../../java.base/java/lang/thread#NORM_PRIORITY&quot;&gt;&lt;code&gt;Thread.NORM_PRIORITY&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果给定的 &lt;code&gt;CompositeData&lt;/code&gt; 不包含此属性，则此属性将设置为&lt;a href=&quot;../../../../java.base/java/lang/thread#NORM_PRIORITY&quot;&gt; &lt;code&gt;Thread.NORM_PRIORITY&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0a37afbef057d6ba837b305b1cd9bad125d8e146" translate="yes" xml:space="preserve">
          <source>If the given &lt;code&gt;CompositeData&lt;/code&gt; does not contain this attribute, the &lt;code&gt;LockInfo&lt;/code&gt; object will be constructed from the value of the &lt;code&gt;lockName&lt;/code&gt; attribute.</source>
          <target state="translated">如果给定 &lt;code&gt;CompositeData&lt;/code&gt; 不包含该属性， &lt;code&gt;LockInfo&lt;/code&gt; 对象将从的值来构造 &lt;code&gt;lockName&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="e232e6d08b2921ecd51a0928548c7d20fb389fec" translate="yes" xml:space="preserve">
          <source>If the given &lt;code&gt;CompositeData&lt;/code&gt; does not contain this attribute, this attribute will be set to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果给定的 &lt;code&gt;CompositeData&lt;/code&gt; 不包含此属性，则此属性将设置为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1400b3eda5d304390a2540e7c1391b9930fe93a9" translate="yes" xml:space="preserve">
          <source>If the given &lt;code&gt;CompositeData&lt;/code&gt; does not contain this attribute, this attribute will be set to an empty array.</source>
          <target state="translated">如果给定的 &lt;code&gt;CompositeData&lt;/code&gt; 不包含此属性，则此属性将设置为空数组。</target>
        </trans-unit>
        <trans-unit id="0db7828d6899e244beb39f64663230573a2ea5f3" translate="yes" xml:space="preserve">
          <source>If the given &lt;code&gt;ProtectionDomain&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, then a default protection domain will be assigned to the class as specified in the documentation for &lt;a href=&quot;#defineClass(java.lang.String,byte%5B%5D,int,int)&quot;&gt;&lt;code&gt;defineClass(String, byte[], int, int)&lt;/code&gt;&lt;/a&gt;. Before the class can be used it must be resolved.</source>
          <target state="translated">如果给定的 &lt;code&gt;ProtectionDomain&lt;/code&gt; 为 &lt;code&gt;null&lt;/code&gt; ，则将按照文档中&lt;a href=&quot;#defineClass(java.lang.String,byte%5B%5D,int,int)&quot;&gt; &lt;code&gt;defineClass(String, byte[], int, int)&lt;/code&gt; &lt;/a&gt;指定将默认保护域分配给该类。在使用该类之前，必须先对其进行解析。</target>
        </trans-unit>
        <trans-unit id="0f34fbb4cfa40d33b09699390aae3ac53e8ab2c4" translate="yes" xml:space="preserve">
          <source>If the given &lt;code&gt;instant&lt;/code&gt; represents a point on the time-line too far in the future or past to fit in a &lt;code&gt;long&lt;/code&gt; milliseconds and nanoseconds adjustment, then an &lt;code&gt;ArithmeticException&lt;/code&gt; will be thrown.</source>
          <target state="translated">如果给定的 &lt;code&gt;instant&lt;/code&gt; 表示时间轴上的某个点在将来或过去太远而无法适应 &lt;code&gt;long&lt;/code&gt; 毫秒和纳秒的调整，则将引发 &lt;code&gt;ArithmeticException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="15c5a383f51c24f8825b786eaae7ec8e4fc3e1be" translate="yes" xml:space="preserve">
          <source>If the given &lt;code&gt;module&lt;/code&gt; is an unnamed module, then this method is equivalent to calling &lt;a href=&quot;#getBundle(java.lang.String,java.util.Locale,java.lang.ClassLoader)&quot;&gt;&lt;code&gt;getBundle(baseName, targetLocale, module.getClassLoader()&lt;/code&gt;&lt;/a&gt; to load resource bundles that are visible to the class loader of the given unnamed module. Custom &lt;a href=&quot;spi/resourcebundlecontrolprovider&quot;&gt;&lt;code&gt;ResourceBundleControlProvider&lt;/code&gt;&lt;/a&gt; implementations, if present, will only be invoked if the specified module is an unnamed module.</source>
          <target state="translated">如果给定的 &lt;code&gt;module&lt;/code&gt; 是一个未命名的模块，则该方法等效于调用&lt;a href=&quot;#getBundle(java.lang.String,java.util.Locale,java.lang.ClassLoader)&quot;&gt; &lt;code&gt;getBundle(baseName, targetLocale, module.getClassLoader()&lt;/code&gt; &lt;/a&gt;到对于所述给定的无名模块的类加载器可见负载资源束。自定义&lt;a href=&quot;spi/resourcebundlecontrolprovider&quot;&gt; &lt;code&gt;ResourceBundleControlProvider&lt;/code&gt; &lt;/a&gt;实现方式中，如果存在仅在指定模块为未命名模块时才调用。</target>
        </trans-unit>
        <trans-unit id="0e16e73e1c388c5bcfaf11ed9189d8791a0ccfd7" translate="yes" xml:space="preserve">
          <source>If the given &lt;var&gt;inModelMBeanInfo&lt;/var&gt; does not contain any &lt;a href=&quot;modelmbeannotificationinfo&quot;&gt;&lt;code&gt;ModelMBeanNotificationInfo&lt;/code&gt;&lt;/a&gt; for the &lt;code&gt;GENERIC&lt;/code&gt; or &lt;code&gt;ATTRIBUTE_CHANGE&lt;/code&gt; notifications, then the RequiredModelMBean will supply its own default &lt;a href=&quot;modelmbeannotificationinfo&quot;&gt;&lt;code&gt;ModelMBeanNotificationInfo&lt;/code&gt;&lt;/a&gt;s for those missing notifications.</source>
          <target state="translated">如果给定的 &lt;var&gt;inModelMBeanInfo&lt;/var&gt; 不包含用于 &lt;code&gt;GENERIC&lt;/code&gt; 或 &lt;code&gt;ATTRIBUTE_CHANGE&lt;/code&gt; 通知的任何&lt;a href=&quot;modelmbeannotificationinfo&quot;&gt; &lt;code&gt;ModelMBeanNotificationInfo&lt;/code&gt; &lt;/a&gt;，则RequiredModelMBean将为那些缺少的通知提供其自己的默认&lt;a href=&quot;modelmbeannotificationinfo&quot;&gt; &lt;code&gt;ModelMBeanNotificationInfo&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cf86ec019e6dc9802020d9a480bb2d423505a7f3" translate="yes" xml:space="preserve">
          <source>If the given Collection is an &lt;a href=&quot;#unmodifiable&quot;&gt;unmodifiable List&lt;/a&gt;, calling copyOf will generally not create a copy.</source>
          <target state="translated">如果给定的Collection是不可&lt;a href=&quot;#unmodifiable&quot;&gt;修改的List&lt;/a&gt;，则调用copyOf通常不会创建副本。</target>
        </trans-unit>
        <trans-unit id="f10d628399ffa67f965f7a348c67ac7f2b5b2030" translate="yes" xml:space="preserve">
          <source>If the given Collection is an &lt;a href=&quot;#unmodifiable&quot;&gt;unmodifiable Set&lt;/a&gt;, calling copyOf will generally not create a copy.</source>
          <target state="translated">如果给定的Collection是不可&lt;a href=&quot;#unmodifiable&quot;&gt;修改的Set&lt;/a&gt;，则调用copyOf通常不会创建副本。</target>
        </trans-unit>
        <trans-unit id="d42f41fcf7ca04751155bf461b15402f39209e6a" translate="yes" xml:space="preserve">
          <source>If the given Map is an &lt;a href=&quot;#unmodifiable&quot;&gt;unmodifiable Map&lt;/a&gt;, calling copyOf will generally not create a copy.</source>
          <target state="translated">如果给定的Map是不可&lt;a href=&quot;#unmodifiable&quot;&gt;修改的Map&lt;/a&gt;，则调用copyOf通常不会创建副本。</target>
        </trans-unit>
        <trans-unit id="871cb4309703aec2bc0023c758d9cf428cebc74f" translate="yes" xml:space="preserve">
          <source>If the given URI has an authority component then the new URI's authority and path are taken from the given URI.</source>
          <target state="translated">如果给定的URI有一个权限组件,那么新的URI的权限和路径就会从给定的URI中获取。</target>
        </trans-unit>
        <trans-unit id="e06d94bd934ab4eadeb7ce0dca1e7e7222d58665" translate="yes" xml:space="preserve">
          <source>If the given URI is already absolute, or if this URI is opaque, then the given URI is returned.</source>
          <target state="translated">如果给定的URI已经是绝对的,或者这个URI是不透明的,那么将返回给定的URI。</target>
        </trans-unit>
        <trans-unit id="2430c525f00d8a5ecee224a7a5b81e9aae39e412" translate="yes" xml:space="preserve">
          <source>If the given URI's fragment component is defined, its path component is empty, and its scheme, authority, and query components are undefined, then a URI with the given fragment but with all other components equal to those of this URI is returned. This allows a URI representing a standalone fragment reference, such as &lt;code id=&quot;resolve-frag&quot;&gt;&quot;#foo&quot;&lt;/code&gt;, to be usefully resolved against a base URI.</source>
          <target state="translated">如果定义了给定URI的片段组件，其路径组件为空，并且其方案，权限和查询组件未定义，则返回具有给定片段但所有其他组件与此URI相等的URI。这使代表独立片段引用的URI（例如 &lt;code id=&quot;resolve-frag&quot;&gt;&quot;#foo&quot;&lt;/code&gt; ）可以有效地针对基本URI进行解析。</target>
        </trans-unit>
        <trans-unit id="409ab55de149be7ee7466f039641cd5cdd79e97a" translate="yes" xml:space="preserve">
          <source>If the given URI's fragment component is defined, its path component is empty, and its scheme, authority, and query components are undefined, then a URI with the given fragment but with all other components equal to those of this URI is returned. This allows a URI representing a standalone fragment reference, such as &lt;code&gt;&quot;#foo&quot;&lt;/code&gt;, to be usefully resolved against a base URI.</source>
          <target state="translated">如果定义了给定URI的片段组件，其路径组件为空，并且其方案，权限和查询组件未定义，则将返回具有给定片段但所有其他组件均与此URI相等的URI。这使代表独立片段引用的URI（例如 &lt;code&gt;&quot;#foo&quot;&lt;/code&gt; ）可以有效地针对基本URI进行解析。</target>
        </trans-unit>
        <trans-unit id="c849fb5cce341a58fea462c01a105441e0cc9602" translate="yes" xml:space="preserve">
          <source>If the given URI's path is absolute then the new URI's path is taken from the given URI.</source>
          <target state="translated">如果给定的URI的路径是绝对的,那么新的URI的路径就取自给定的URI。</target>
        </trans-unit>
        <trans-unit id="14f7899ffb21b582de61406576d434576cfac581" translate="yes" xml:space="preserve">
          <source>If the given address includes a JNDI directory URL as specified in the package documentation for &lt;a href=&quot;package-summary&quot;&gt;&lt;code&gt;javax.management.remote.rmi&lt;/code&gt;&lt;/a&gt;, then this &lt;code&gt;RMIConnectorServer&lt;/code&gt; will bootstrap by binding the &lt;code&gt;RMIServerImpl&lt;/code&gt; to the given address.</source>
          <target state="translated">如果给定地址包括&lt;a href=&quot;package-summary&quot;&gt; &lt;code&gt;javax.management.remote.rmi&lt;/code&gt; &lt;/a&gt;软件包文档中指定的JNDI目录URL ，则此 &lt;code&gt;RMIConnectorServer&lt;/code&gt; 将通过将 &lt;code&gt;RMIServerImpl&lt;/code&gt; 绑定到给定地址来进行引导。</target>
        </trans-unit>
        <trans-unit id="ca814afbdb188e0d8eb604c68dacd59c7bf69539" translate="yes" xml:space="preserve">
          <source>If the given alias already exists, the keystore information associated with it is overridden by the given key (and possibly certificate chain).</source>
          <target state="translated">如果给定的别名已经存在,那么与之相关的密钥存储信息就会被给定的密钥(可能还有证书链)覆盖。</target>
        </trans-unit>
        <trans-unit id="3a595a56aadbb88b4114693edc5c1ee01ec9f96d" translate="yes" xml:space="preserve">
          <source>If the given alias identifies an existing entry created by a call to &lt;code&gt;setCertificateEntry&lt;/code&gt;, or created by a call to &lt;code&gt;setEntry&lt;/code&gt; with a &lt;code&gt;TrustedCertificateEntry&lt;/code&gt;, the trusted certificate in the existing entry is overridden by the given certificate.</source>
          <target state="translated">如果给定的别名标识通过调用创建现有条目 &lt;code&gt;setCertificateEntry&lt;/code&gt; ，或通过向调用创建 &lt;code&gt;setEntry&lt;/code&gt; 与 &lt;code&gt;TrustedCertificateEntry&lt;/code&gt; ，在现有条目中的可信证书被给定证书重写。</target>
        </trans-unit>
        <trans-unit id="5db25da879a6c8a2469a9ffa221b439cce428d7c" translate="yes" xml:space="preserve">
          <source>If the given alias name identifies an entry created by a call to &lt;code&gt;setCertificateEntry&lt;/code&gt;, or created by a call to &lt;code&gt;setEntry&lt;/code&gt; with a &lt;code&gt;TrustedCertificateEntry&lt;/code&gt;, then the trusted certificate contained in that entry is returned.</source>
          <target state="translated">如果给定的别名标识通过调用创建一个条目 &lt;code&gt;setCertificateEntry&lt;/code&gt; ，或通过向调用创建 &lt;code&gt;setEntry&lt;/code&gt; 与 &lt;code&gt;TrustedCertificateEntry&lt;/code&gt; ，则受信任的证书中包含的条目返回。</target>
        </trans-unit>
        <trans-unit id="4d4d7d88c3b4df9575339dccffaf79058f1c8930" translate="yes" xml:space="preserve">
          <source>If the given alias name identifies an entry created by a call to &lt;code&gt;setKeyEntry&lt;/code&gt;, or created by a call to &lt;code&gt;setEntry&lt;/code&gt; with a &lt;code&gt;PrivateKeyEntry&lt;/code&gt;, then the first element of the certificate chain in that entry (if a chain exists) is returned.</source>
          <target state="translated">如果给定别名标识了通过调用 &lt;code&gt;setKeyEntry&lt;/code&gt; 创建的条目，或通过调用带有 &lt;code&gt;PrivateKeyEntry&lt;/code&gt; 的 &lt;code&gt;setEntry&lt;/code&gt; 创建的条目，则将返回该条目中证书链的第一个元素（如果存在链）。</target>
        </trans-unit>
        <trans-unit id="c2ed3e7db9906e449ddb9d356b3252474de4e64c" translate="yes" xml:space="preserve">
          <source>If the given alias name identifies an entry created by a call to &lt;code&gt;setKeyEntry&lt;/code&gt;, or created by a call to &lt;code&gt;setEntry&lt;/code&gt; with a &lt;code&gt;PrivateKeyEntry&lt;/code&gt;, then the first element of the certificate chain in that entry is returned.</source>
          <target state="translated">如果给定的别名标识了通过调用 &lt;code&gt;setKeyEntry&lt;/code&gt; 创建的条目，或通过调用带有 &lt;code&gt;PrivateKeyEntry&lt;/code&gt; 的 &lt;code&gt;setEntry&lt;/code&gt; 创建的条目，则返回该条目中证书链的第一个元素。</target>
        </trans-unit>
        <trans-unit id="80577b628d04d07146a4c8598f72bfad40ed28b3" translate="yes" xml:space="preserve">
          <source>If the given blocking mode is different from the current blocking mode then this method invokes the &lt;a href=&quot;#implConfigureBlocking(boolean)&quot;&gt;&lt;code&gt;implConfigureBlocking&lt;/code&gt;&lt;/a&gt; method, while holding the appropriate locks, in order to change the mode.</source>
          <target state="translated">如果给定的阻止模式不同于当前的阻止模式，则此方法在保持适当的锁的同时调用&lt;a href=&quot;#implConfigureBlocking(boolean)&quot;&gt; &lt;code&gt;implConfigureBlocking&lt;/code&gt; &lt;/a&gt;方法，以更改模式。</target>
        </trans-unit>
        <trans-unit id="a7044af5535fc0b80bc9e6eb2af416837a93528e" translate="yes" xml:space="preserve">
          <source>If the given blocking mode is different from the current blocking mode then this method invokes the &lt;a href=&quot;abstractselectablechannel#implConfigureBlocking-boolean-&quot;&gt;&lt;code&gt;implConfigureBlocking&lt;/code&gt;&lt;/a&gt; method, while holding the appropriate locks, in order to change the mode.</source>
          <target state="translated">如果给定的阻止模式不同于当前的阻止模式，则此方法在保持适当的锁的同时调用&lt;a href=&quot;abstractselectablechannel#implConfigureBlocking-boolean-&quot;&gt; &lt;code&gt;implConfigureBlocking&lt;/code&gt; &lt;/a&gt;方法，以更改模式。</target>
        </trans-unit>
        <trans-unit id="099ac9d14ce6f3a8c241c4173bc2f3c060d37fae" translate="yes" xml:space="preserve">
          <source>If the given index is outside the list's range of cells, this method results in nothing.</source>
          <target state="translated">如果给定的索引在列表的单元格范围之外,这个方法就没有结果。</target>
        </trans-unit>
        <trans-unit id="ef47fccc5a72a56e061d58ffbc98135bb15f0e3b" translate="yes" xml:space="preserve">
          <source>If the given key is of type &lt;code&gt;java.security.PrivateKey&lt;/code&gt;, it must be accompanied by a certificate chain certifying the corresponding public key.</source>
          <target state="translated">如果给定密钥的类型为 &lt;code&gt;java.security.PrivateKey&lt;/code&gt; ，则必须随附一个证书链，以证明相应的公共密钥。</target>
        </trans-unit>
        <trans-unit id="fd6f94d655e9cba018e02791b4d2bafeaf0cd16b" translate="yes" xml:space="preserve">
          <source>If the given locale is equal to &lt;code&gt;Locale.ROOT&lt;/code&gt; (the root locale), a &lt;code&gt;List&lt;/code&gt; containing only the root &lt;code&gt;Locale&lt;/code&gt; must be returned. In this case, the &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; factory method loads only the base bundle as the resulting resource bundle.</source>
          <target state="translated">如果给定的区域设置为等于 &lt;code&gt;Locale.ROOT&lt;/code&gt; （根区域），一个 &lt;code&gt;List&lt;/code&gt; 仅包含根 &lt;code&gt;Locale&lt;/code&gt; 必须返回。在这种情况下， &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; 工厂方法仅加载基本捆绑包作为结果资源捆绑包。</target>
        </trans-unit>
        <trans-unit id="d78ff521c3166afea2224a7e827c542012a19f6e" translate="yes" xml:space="preserve">
          <source>If the given location is either a module oriented location, or an output location containing multiple modules, and no explicit modules prefix is given, a suitable module is inferred. If a suitable module cannot be inferred &lt;a href=&quot;filerexception&quot;&gt;&lt;code&gt;FilerException&lt;/code&gt;&lt;/a&gt; is thrown. An implementation may use information about the configuration of the annotation processing tool as part of the inference.</source>
          <target state="translated">如果给定位置是面向模块的位置，或者是包含多个模块的输出位置，并且未给出显式模块前缀，则将推断一个合适的模块。如果无法推断出合适的模块，则抛出&lt;a href=&quot;filerexception&quot;&gt; &lt;code&gt;FilerException&lt;/code&gt; &lt;/a&gt;。一个实现可以使用关于注释处理工具的配置的信息作为推断的一部分。</target>
        </trans-unit>
        <trans-unit id="dd86b458fa6c5cb798c0359d6978ebb6799d62aa" translate="yes" xml:space="preserve">
          <source>If the given location is neither a &lt;a href=&quot;../../tools/javafilemanager.location#isModuleOrientedLocation()&quot;&gt;module oriented location&lt;/a&gt;, nor an &lt;a href=&quot;../../tools/javafilemanager.location#isOutputLocation()&quot;&gt;output location containing multiple modules&lt;/a&gt;, and the explicit module prefix is given, &lt;a href=&quot;filerexception&quot;&gt;&lt;code&gt;FilerException&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">如果给定位置既不是&lt;a href=&quot;../../tools/javafilemanager.location#isModuleOrientedLocation()&quot;&gt;面向模块的位置&lt;/a&gt;，也不是&lt;a href=&quot;../../tools/javafilemanager.location#isOutputLocation()&quot;&gt;包含多个模块&lt;/a&gt;的输出位置，并且给出了显式模块前缀，则抛出&lt;a href=&quot;filerexception&quot;&gt; &lt;code&gt;FilerException&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a722054d6a8a85985b6af9a7f074ff6c9d6c5114" translate="yes" xml:space="preserve">
          <source>If the given method to be invoked, together with the provided signature, matches one of RequiredModelMbean accessible methods, this one will be call. Otherwise the call to the given method will be tried on the managed resource.</source>
          <target state="translated">如果要调用的方法以及提供的签名与所需ModelMbean可访问的方法之一相匹配,那么这个方法将被调用。否则,对给定方法的调用将在被管理资源上进行尝试。</target>
        </trans-unit>
        <trans-unit id="5903b5c68713e17c01106dc0242d392ba3fd13a3" translate="yes" xml:space="preserve">
          <source>If the given modality type is not supported, &lt;code&gt;MODELESS&lt;/code&gt; is used. You may want to call &lt;code&gt;getModalityType()&lt;/code&gt; after calling this method to ensure that the modality type has been set.</source>
          <target state="translated">如果不支持给定的模态类型，则使用 &lt;code&gt;MODELESS&lt;/code&gt; 。您可能需要在调用此方法后调用 &lt;code&gt;getModalityType()&lt;/code&gt; ，以确保已设置模态类型。</target>
        </trans-unit>
        <trans-unit id="7cf0a900811cd6f2b34fd3e614d21d91355d860b" translate="yes" xml:space="preserve">
          <source>If the given object is not a &lt;code&gt;ModuleDescriptor&lt;/code&gt; then this method returns &lt;code&gt;false&lt;/code&gt;. Two module descriptors are equal if each of their corresponding components is equal.</source>
          <target state="translated">如果给定的对象不是 &lt;code&gt;ModuleDescriptor&lt;/code&gt; ,则此方法返回 &lt;code&gt;false&lt;/code&gt; 。如果两个模块描述符的每个相应组件相等，则两个模块描述符相等。</target>
        </trans-unit>
        <trans-unit id="265ee67148fb3d461cae1321c492c06ad8be4305" translate="yes" xml:space="preserve">
          <source>If the given object is not a &lt;code&gt;Provides&lt;/code&gt; then this method returns &lt;code&gt;false&lt;/code&gt;. Two &lt;code&gt;Provides&lt;/code&gt; objects are equal if the service type is equal and the list of providers is equal.</source>
          <target state="translated">如果给定的对象不是 &lt;code&gt;Provides&lt;/code&gt; ,则此方法返回 &lt;code&gt;false&lt;/code&gt; 。如果服务类型相等且提供者列表相等，则两个 &lt;code&gt;Provides&lt;/code&gt; 对象相等。</target>
        </trans-unit>
        <trans-unit id="e9dc4b5ba6652e7ccce8cb26463d690c4e101f15" translate="yes" xml:space="preserve">
          <source>If the given object is not a &lt;code&gt;Requires&lt;/code&gt; then this method returns &lt;code&gt;false&lt;/code&gt;. Two module dependence objects are equal if the module names are equal, set of modifiers are equal, and the compiled version of both modules is equal or not recorded for both modules.</source>
          <target state="translated">如果给定的对象不是 &lt;code&gt;Requires&lt;/code&gt; ,则此方法返回 &lt;code&gt;false&lt;/code&gt; 。如果模块名称相等，修饰符集相等且两个模块的编译版本相等或未记录，则两个模块依赖性对象相等。</target>
        </trans-unit>
        <trans-unit id="087eec123268666bb5ff587f9f3824a68696a44d" translate="yes" xml:space="preserve">
          <source>If the given object is not a &lt;code&gt;ResolvedModule&lt;/code&gt; then this method returns &lt;code&gt;false&lt;/code&gt;. Two &lt;code&gt;ResolvedModule&lt;/code&gt; objects are equal if they are in the same configuration and have equal references to the module content.</source>
          <target state="translated">如果给定的对象不是 &lt;code&gt;ResolvedModule&lt;/code&gt; ,则此方法返回 &lt;code&gt;false&lt;/code&gt; 。如果两个 &lt;code&gt;ResolvedModule&lt;/code&gt; 对象处于相同的配置中，并且对模块内容的引用相同，则它们相等。</target>
        </trans-unit>
        <trans-unit id="cfd682a1d142327e25c86e6fd36c7f41a2a41ad9" translate="yes" xml:space="preserve">
          <source>If the given object is not a &lt;code&gt;Version&lt;/code&gt; then this method returns &lt;code&gt;false&lt;/code&gt;. Two module version are equal if their corresponding components are equal.</source>
          <target state="translated">如果给定的对象不是 &lt;code&gt;Version&lt;/code&gt; ,则此方法返回 &lt;code&gt;false&lt;/code&gt; 。如果两个模块的相应组件相同，则它们是相同的。</target>
        </trans-unit>
        <trans-unit id="a79eac791e4b86cfc10aabf01a42570af6907767" translate="yes" xml:space="preserve">
          <source>If the given object is not a Path, or is a Path associated with a different &lt;code&gt;FileSystem&lt;/code&gt;, then this method returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果给定的对象不是Path或与另一个 &lt;code&gt;FileSystem&lt;/code&gt; 关联的Path ，则此方法返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ab44b435bce5e6d0dd0d4400904c04dd1b50093c" translate="yes" xml:space="preserve">
          <source>If the given object is not a URI then this method immediately returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果给定的对象不是URI，则此方法立即返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dab849a2dfb627f012f49b202b71d39af39c2224" translate="yes" xml:space="preserve">
          <source>If the given object is not a URL then this method immediately returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果给定的对象不是URL，则此方法立即返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="01a564c21ef594219aeafdbf8732e9a0030e72be" translate="yes" xml:space="preserve">
          <source>If the given object is not a VirtualMachine then this method returns &lt;code&gt;false&lt;/code&gt;. For two VirtualMachines to be considered equal requires that they both reference the same provider, and their &lt;a href=&quot;virtualmachinedescriptor#id()&quot;&gt;&lt;code&gt;identifiers&lt;/code&gt;&lt;/a&gt; are equal.</source>
          <target state="translated">如果给定的对象不是VirtualMachine，则此方法返回 &lt;code&gt;false&lt;/code&gt; 。对于要被视为相等的两个VirtualMachines，要求它们都引用相同的提供程序，并且其&lt;a href=&quot;virtualmachinedescriptor#id()&quot;&gt; &lt;code&gt;identifiers&lt;/code&gt; &lt;/a&gt;相等。</target>
        </trans-unit>
        <trans-unit id="b305239f4bf84e68ec183969e76e319dbf5445c9" translate="yes" xml:space="preserve">
          <source>If the given object is not a VirtualMachineDescriptor then this method returns &lt;code&gt;false&lt;/code&gt;. For two VirtualMachineDescriptors to be considered equal requires that they both reference the same provider, and their &lt;a href=&quot;#id()&quot;&gt;&lt;code&gt;identifiers&lt;/code&gt;&lt;/a&gt; are equal.</source>
          <target state="translated">如果给定的对象不是VirtualMachineDescriptor，则此方法返回 &lt;code&gt;false&lt;/code&gt; 。为了使两个VirtualMachineDescriptor相等，要求它们都引用相同的提供程序，并且其&lt;a href=&quot;#id()&quot;&gt; &lt;code&gt;identifiers&lt;/code&gt; &lt;/a&gt;相等。</target>
        </trans-unit>
        <trans-unit id="51317f50e868ccac84e6251d8aade86da12219ac" translate="yes" xml:space="preserve">
          <source>If the given object is not an &lt;code&gt;AclEntry&lt;/code&gt; then this method immediately returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果给定的对象不是 &lt;code&gt;AclEntry&lt;/code&gt; ,则此方法立即返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="deee112803ae8aa28ebe1e7b06cce4d2e7efea17" translate="yes" xml:space="preserve">
          <source>If the given object is not an &lt;code&gt;Exports&lt;/code&gt; then this method returns &lt;code&gt;false&lt;/code&gt;. Two module exports objects are equal if their set of modifiers is equal, the package names are equal and the set of target module names is equal.</source>
          <target state="translated">如果给定的对象不是 &lt;code&gt;Exports&lt;/code&gt; ,则此方法返回 &lt;code&gt;false&lt;/code&gt; 。如果两个模块导出对象的修饰符集相等，程序包名称相等且目标模块名称集相等，则它们相等。</target>
        </trans-unit>
        <trans-unit id="ff01ba4aa3f9066a3a4d258504eb98e093cb3dd4" translate="yes" xml:space="preserve">
          <source>If the given object is not an &lt;code&gt;HttpHeaders&lt;/code&gt; then this method returns &lt;code&gt;false&lt;/code&gt;. Two HTTP headers are equal if each of their corresponding &lt;a href=&quot;#map()&quot;&gt;maps&lt;/a&gt; are equal.</source>
          <target state="translated">如果给定的对象不是 &lt;code&gt;HttpHeaders&lt;/code&gt; ,则此方法返回 &lt;code&gt;false&lt;/code&gt; 。如果两个HTTP标头各自对应的&lt;a href=&quot;#map()&quot;&gt;映射&lt;/a&gt;相等，则它们相等。</target>
        </trans-unit>
        <trans-unit id="2dc78364f9dc2b13b28a620cc038ded7d1559bd8" translate="yes" xml:space="preserve">
          <source>If the given object is not an &lt;code&gt;HttpRequest&lt;/code&gt; then this method returns &lt;code&gt;false&lt;/code&gt;. Two HTTP requests are equal if their URI, method, and headers fields are all equal.</source>
          <target state="translated">如果给定的对象不是 &lt;code&gt;HttpRequest&lt;/code&gt; ,则此方法返回 &lt;code&gt;false&lt;/code&gt; 。如果两个HTTP请求的URI，方法和标头字段均相等，则它们相等。</target>
        </trans-unit>
        <trans-unit id="a08bc86883e9dc33f9a3477bb9b5d3ab9ca49cb6" translate="yes" xml:space="preserve">
          <source>If the given object is not an &lt;code&gt;Opens&lt;/code&gt; then this method returns &lt;code&gt;false&lt;/code&gt;. Two &lt;code&gt;Opens&lt;/code&gt; objects are equal if their set of modifiers is equal, the package names are equal and the set of target module names is equal.</source>
          <target state="translated">如果给定的对象不是 &lt;code&gt;Opens&lt;/code&gt; ,则此方法返回 &lt;code&gt;false&lt;/code&gt; 。如果两个 &lt;code&gt;Opens&lt;/code&gt; 对象的修饰符集合相等，程序包名称相等且目标模块名称集合相等，则它们相等。</target>
        </trans-unit>
        <trans-unit id="5067d1933a7fb6de041c489427ed9f038cbf2e5d" translate="yes" xml:space="preserve">
          <source>If the given path has &lt;em&gt;N&lt;/em&gt; elements, and no root component, and this path has &lt;em&gt;N&lt;/em&gt; or more elements, then this path ends with the given path if the last &lt;em&gt;N&lt;/em&gt; elements of each path, starting at the element farthest from the root, are equal.</source>
          <target state="translated">如果给定路径具有&lt;em&gt;N个&lt;/em&gt;元素，并且没有根成分，并且此路径具有&lt;em&gt;N个&lt;/em&gt;或多个元素，则如果每个路径的最后&lt;em&gt;N个&lt;/em&gt;元素（从距离根最远的元素开始）相等，则此路径以给定路径结尾。</target>
        </trans-unit>
        <trans-unit id="fe7eaf75c5ca09e9dc37afa7038d8c228c398461" translate="yes" xml:space="preserve">
          <source>If the given path has a root component then this path ends with the given path if the root component of this path &lt;em&gt;ends with&lt;/em&gt; the root component of the given path, and the corresponding elements of both paths are equal. Whether or not the root component of this path ends with the root component of the given path is file system specific. If this path does not have a root component and the given path has a root component then this path does not end with the given path.</source>
          <target state="translated">如果给定路径具有根成分，则此路径以给定路径结束，如果该路径的根成分以给定路径的根成分&lt;em&gt;结束&lt;/em&gt;，并且两个路径的相应元素相等。此路径的根组件是否以给定路径的根组件结尾是特定于文件系统的。如果此路径没有根组件，并且给定路径具有根组件，则该路径不会以给定路径结尾。</target>
        </trans-unit>
        <trans-unit id="6fdc1f0bd8bdd66110dc3f031d4817dcf3caed63" translate="yes" xml:space="preserve">
          <source>If the given path is associated with a different &lt;code&gt;FileSystem&lt;/code&gt; to this path then &lt;code&gt;false&lt;/code&gt; is returned.</source>
          <target state="translated">如果给定路径与与此路径不同的 &lt;code&gt;FileSystem&lt;/code&gt; 关联，则返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4b2bf60e5452de4ddf9870cafed442c49431cf97" translate="yes" xml:space="preserve">
          <source>If the given provider is installed at the requested position, the provider that used to be at that position, and all providers with a position greater than &lt;code&gt;position&lt;/code&gt;, are shifted up one position (towards the end of the list of installed providers).</source>
          <target state="translated">如果给定提供程序安装在请求的位置，则以前位于该位置的提供程序以及位置大于 &lt;code&gt;position&lt;/code&gt; 的所有提供程序都将上移一个位置（朝已安装的提供程序列表的末尾移动）。</target>
        </trans-unit>
        <trans-unit id="0348730345bae0d2545ea8b21da48cf025a26fbe" translate="yes" xml:space="preserve">
          <source>If the given row number is negative, the cursor moves to an absolute row position with respect to the end of the result set. For example, calling the method &lt;code&gt;absolute(-1)&lt;/code&gt; positions the cursor on the last row; calling the method &lt;code&gt;absolute(-2)&lt;/code&gt; moves the cursor to the next-to-last row, and so on.</source>
          <target state="translated">如果给定的行号为负，则光标将移动到相对于结果集末尾的绝对行位置。例如，调用方法 &lt;code&gt;absolute(-1)&lt;/code&gt; 将光标定位在最后一行；否则，将光标定位在最后一行。调用方法 &lt;code&gt;absolute(-2)&lt;/code&gt; 将光标移动到倒数第二行，依此类推。</target>
        </trans-unit>
        <trans-unit id="ebbca2e71ca391fdcf53f907a578f53411598fa7" translate="yes" xml:space="preserve">
          <source>If the given runnable attempts to make any mutations in this implementation, a deadlock will occur. There is no tracking of individual rendering threads to enable detecting this situation, but a subclass could incur the overhead of tracking them and throwing an error.</source>
          <target state="translated">如果给定的可运行线程试图在本实现中进行任何突变,就会发生死锁。没有跟踪单个渲染线程以检测这种情况,但子类可能会产生跟踪线程和抛出错误的开销。</target>
        </trans-unit>
        <trans-unit id="be7b3561a355e78f18cdeae419abf0ee5e2ea933" translate="yes" xml:space="preserve">
          <source>If the given size is less than the current size then the entity is truncated, discarding any bytes beyond the new end. If the given size is greater than or equal to the current size then the entity is not modified. In either case, if the current position is greater than the given size then it is set to that size.</source>
          <target state="translated">如果给定的大小小于当前大小,那么实体将被截断,丢弃超出新末端的任何字节。如果给定的大小大于或等于当前的大小,那么实体不会被修改。在这两种情况下,如果当前位置大于给定的大小,则将其设置为该大小。</target>
        </trans-unit>
        <trans-unit id="aaefbc3d9c612129c52e3733260c322198b61ac6" translate="yes" xml:space="preserve">
          <source>If the given size is less than the file's current size then the file is truncated, discarding any bytes beyond the new end of the file. If the given size is greater than or equal to the file's current size then the file is not modified.</source>
          <target state="translated">如果给定的大小小于文件的当前大小,那么文件将被截断,丢弃超出文件新末端的任何字节。如果给定的大小大于或等于文件的当前大小,那么文件将不被修改。</target>
        </trans-unit>
        <trans-unit id="87ded65bf156680a79571d8a9d909a68f908630c" translate="yes" xml:space="preserve">
          <source>If the given size is less than the file's current size then the file is truncated, discarding any bytes beyond the new end of the file. If the given size is greater than or equal to the file's current size then the file is not modified. In either case, if this channel's file position is greater than the given size then it is set to that size.</source>
          <target state="translated">如果给定的大小小于文件的当前大小,那么文件将被截断,丢弃超出文件新末端的任何字节。如果给定的大小大于或等于文件的当前大小,那么文件不会被修改。在这两种情况下,如果这个通道的文件位置大于给定的大小,那么它就被设置为该大小。</target>
        </trans-unit>
        <trans-unit id="7dd1419e3ad877e5832a2e55c7efd5daa5e8f3e6" translate="yes" xml:space="preserve">
          <source>If the given type is not supported, &lt;code&gt;NO_EXCLUDE&lt;/code&gt; is used.</source>
          <target state="translated">如果不支持给定类型，则使用 &lt;code&gt;NO_EXCLUDE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ee541dacfad38286ca16f7b64502c1de0394dbf6" translate="yes" xml:space="preserve">
          <source>If the gradient and graphics rendering transforms are uniformly scaled and the user sets the focus so that it coincides with the center of the circle, the gradient color proportions are equal for any line drawn from the center. The following figure shows the distances AB, BC, AD, and DE. They are all equal.</source>
          <target state="translated">如果渐变和图形渲染变换的比例是统一的,并且用户设置焦点使其与圆心重合,那么从圆心画出的任何线的渐变颜色比例都是相等的。下图显示了AB、BC、AD和DE的距离。它们都是相等的。</target>
        </trans-unit>
        <trans-unit id="0dd273a96dc30568917e48986c0b9215f521962c" translate="yes" xml:space="preserve">
          <source>If the gradient is acyclic then points on the P1 side of the segment have the constant &lt;code&gt;Color&lt;/code&gt; C1 while points on the P2 side have the constant &lt;code&gt;Color&lt;/code&gt; C2.</source>
          <target state="translated">如果梯度是非循环的，则线段P1侧的点具有恒定的 &lt;code&gt;Color&lt;/code&gt; C1，而P2侧的点具有恒定的 &lt;code&gt;Color&lt;/code&gt; C2。</target>
        </trans-unit>
        <trans-unit id="896c9bfd563344965e7bce74bae30d109938cbeb" translate="yes" xml:space="preserve">
          <source>If the gradient is cyclic then the points on the extended P1, P2 connecting line cycle back and forth between the colors C1 and C2.</source>
          <target state="translated">如果渐变是循环的,那么延长的P1、P2连接线上的点在颜色C1和C2之间来回循环。</target>
        </trans-unit>
        <trans-unit id="677a4e88376df9d9470bda35c5236fc7e5c9051a" translate="yes" xml:space="preserve">
          <source>If the group class name specified in the &lt;code&gt;ActivationGroupDesc&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, then this method will behave as if the group descriptor contained the name of the default activation group implementation class.</source>
          <target state="translated">如果 &lt;code&gt;ActivationGroupDesc&lt;/code&gt; 中指定的组类名称为 &lt;code&gt;null&lt;/code&gt; ，则此方法的行为将类似于组描述符包含默认激活组实现类的名称。</target>
        </trans-unit>
        <trans-unit id="f0b0bf2a45ec36e583f47ca33513286c575ec604" translate="yes" xml:space="preserve">
          <source>If the handler is not null and there is a security manager, the security manager's &lt;code&gt;checkPermission&lt;/code&gt; method is called with a &lt;code&gt;NetPermission(&quot;specifyStreamHandler&quot;)&lt;/code&gt; permission. This may result in a SecurityException. No validation of the inputs is performed by this constructor.</source>
          <target state="translated">如果处理程序不为null且存在安全管理器，则使用 &lt;code&gt;NetPermission(&quot;specifyStreamHandler&quot;)&lt;/code&gt; 权限调用安全管理器的 &lt;code&gt;checkPermission&lt;/code&gt; 方法。这可能会导致SecurityException。此构造函数不执行输入验证。</target>
        </trans-unit>
        <trans-unit id="cd5ef3ee310fe9a2a0784c9212a810e58ed3a94b" translate="yes" xml:space="preserve">
          <source>If the history buffer is then rolled back (i.e. the last UndoableEdit undone), a DocumentEvent is sent to both views, causing both of them to reflect the undone mutation to the document (that is, the removal of the right component's mutation). If the history buffer again rolls back another change, another DocumentEvent is sent to both views, causing them to reflect the undone mutation to the document -- that is, the removal of the left component's mutation.</source>
          <target state="translated">如果历史缓冲区随后被回滚(即最后一个UndoableEdit被撤消),则一个DocumentEvent被发送到两个视图,使它们都反映出文档中未撤消的突变(即删除右边组件的突变)。如果历史缓冲区再次回滚另一个变化,另一个DocumentEvent被发送到两个视图,使它们反映出文档中未完成的突变--即删除左边组件的突变。</target>
        </trans-unit>
        <trans-unit id="a7b208411b1f838553bd26f17a98bd6ecf12f387" translate="yes" xml:space="preserve">
          <source>If the host is &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;host.length()&lt;/code&gt; is equal to zero, then an &lt;code&gt;InetAddress&lt;/code&gt; representing an address of the loopback interface is returned. See &lt;a href=&quot;http://www.ietf.org/rfc/rfc3330.txt&quot;&gt;RFC 3330&lt;/a&gt; section 2 and &lt;a href=&quot;http://www.ietf.org/rfc/rfc2373.txt&quot;&gt;RFC 2373&lt;/a&gt; section 2.5.3.</source>
          <target state="translated">如果host为 &lt;code&gt;null&lt;/code&gt; 或 &lt;code&gt;host.length()&lt;/code&gt; 等于零，则返回一个 &lt;code&gt;InetAddress&lt;/code&gt; ，该InetAddress表示回送接口的地址。请参阅&lt;a href=&quot;http://www.ietf.org/rfc/rfc3330.txt&quot;&gt;RFC 3330&lt;/a&gt;第2节和&lt;a href=&quot;http://www.ietf.org/rfc/rfc2373.txt&quot;&gt;RFC 2373&lt;/a&gt;第2.5.3节。</target>
        </trans-unit>
        <trans-unit id="17f223f38d5244a08362b498762d26000fb8d528" translate="yes" xml:space="preserve">
          <source>If the host is &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;host.length()&lt;/code&gt; is equal to zero, then an &lt;code&gt;InetAddress&lt;/code&gt; representing an address of the loopback interface is returned. See &lt;a href=&quot;https://www.ietf.org/rfc/rfc3330.txt&quot;&gt;RFC 3330&lt;/a&gt; section 2 and &lt;a href=&quot;https://www.ietf.org/rfc/rfc2373.txt&quot;&gt;RFC 2373&lt;/a&gt; section 2.5.3.</source>
          <target state="translated">如果host为 &lt;code&gt;null&lt;/code&gt; 或 &lt;code&gt;host.length()&lt;/code&gt; 等于零，则返回一个 &lt;code&gt;InetAddress&lt;/code&gt; ，该InetAddress表示回送接口的地址。请参阅&lt;a href=&quot;https://www.ietf.org/rfc/rfc3330.txt&quot;&gt;RFC 3330&lt;/a&gt;第2节和&lt;a href=&quot;https://www.ietf.org/rfc/rfc2373.txt&quot;&gt;RFC 2373&lt;/a&gt;第2.5.3节。</target>
        </trans-unit>
        <trans-unit id="82294cea404b457d7895b5f7849b8f8cdabef00b" translate="yes" xml:space="preserve">
          <source>If the host is &lt;code&gt;null&lt;/code&gt; then an &lt;code&gt;InetAddress&lt;/code&gt; representing an address of the loopback interface is returned. See &lt;a href=&quot;http://www.ietf.org/rfc/rfc3330.txt&quot;&gt;RFC 3330&lt;/a&gt; section 2 and &lt;a href=&quot;http://www.ietf.org/rfc/rfc2373.txt&quot;&gt;RFC 2373&lt;/a&gt; section 2.5.3.</source>
          <target state="translated">如果主机为 &lt;code&gt;null&lt;/code&gt; ,则返回代表Loopback接口地址的 &lt;code&gt;InetAddress&lt;/code&gt; 。请参阅&lt;a href=&quot;http://www.ietf.org/rfc/rfc3330.txt&quot;&gt;RFC 3330&lt;/a&gt;第2节和&lt;a href=&quot;http://www.ietf.org/rfc/rfc2373.txt&quot;&gt;RFC 2373&lt;/a&gt;第2.5.3节。</target>
        </trans-unit>
        <trans-unit id="13f82f51386e3d3d93037591572aea8cb88f6868" translate="yes" xml:space="preserve">
          <source>If the icon doesn't load, the border area is painted gray.</source>
          <target state="translated">如果图标没有加载,边框区域会被涂成灰色。</target>
        </trans-unit>
        <trans-unit id="9c743eca5b6b4b9d617040308e1ee27a4b7c6393" translate="yes" xml:space="preserve">
          <source>If the identity is marked as &quot;trusted&quot;, this allows an attacker to introduce a different public key (e.g., its own) that is not trusted by the system's identity scope, thereby granting applet or application code signed with that public key privileges that would have been denied otherwise.</source>
          <target state="translated">如果身份被标记为 &quot;受信任&quot;,这就允许攻击者引入不同的公钥(如自己的公钥),该公钥不受系统身份范围的信任,从而给予用该公钥签名的小程序或应用程序代码以特权,否则就会被拒绝。</target>
        </trans-unit>
        <trans-unit id="75b8821b16ad8c4bce7f71ae9f2499e34e968953" translate="yes" xml:space="preserve">
          <source>If the image can be rendered to a user-specified size, then this method returns the default height.</source>
          <target state="translated">如果图像可以渲染成用户指定的大小,那么本方法返回默认高度。</target>
        </trans-unit>
        <trans-unit id="d4a58cc703a9db33b11b3faf9dca4d8e83b20a1f" translate="yes" xml:space="preserve">
          <source>If the image can be rendered to a user-specified size, then this method returns the default width.</source>
          <target state="translated">如果图像可以渲染成用户指定的大小,那么本方法返回默认宽度。</target>
        </trans-unit>
        <trans-unit id="38702f2cc1d6bfec3cbebca538696adacba267f7" translate="yes" xml:space="preserve">
          <source>If the image has completely loaded and its pixels are no longer being changed, then &lt;code&gt;drawImage&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;. Otherwise, &lt;code&gt;drawImage&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt; and as more of the image becomes available or it is time to draw another frame of animation, the process that loads the image notifies the specified image observer.</source>
          <target state="translated">如果图像已完全加载并且不再更改其像素，则 &lt;code&gt;drawImage&lt;/code&gt; 返回 &lt;code&gt;true&lt;/code&gt; 。否则， &lt;code&gt;drawImage&lt;/code&gt; 返回 &lt;code&gt;false&lt;/code&gt; ,并且随着更多图像可用或是时候绘制另一帧动画了，加载图像的过程会通知指定的图像观察者。</target>
        </trans-unit>
        <trans-unit id="a0b05514b8f5d731608326b087f332a040bf4271" translate="yes" xml:space="preserve">
          <source>If the image is able to be rendered at an arbitrary size, sets the source width and height to the supplied values.</source>
          <target state="translated">如果图像能够以任意尺寸渲染,则将源宽度和高度设置为提供的值。</target>
        </trans-unit>
        <trans-unit id="1e4e52ec311e9e75dd4cc081567f1eae9e6bf20f" translate="yes" xml:space="preserve">
          <source>If the image is able to be rendered at an arbitrary size, sets the source width and height to the supplied values. Note that the values returned from the &lt;code&gt;getWidth&lt;/code&gt; and &lt;code&gt;getHeight&lt;/code&gt; methods on &lt;code&gt;ImageReader&lt;/code&gt; are not affected by this method; they will continue to return the default size for the image. Similarly, if the image is also tiled the tile width and height are given in terms of the default size.</source>
          <target state="translated">如果能够以任意大小渲染图像，请将源的宽度和高度设置为提供的值。请注意，从 &lt;code&gt;ImageReader&lt;/code&gt; 的 &lt;code&gt;getWidth&lt;/code&gt; 和 &lt;code&gt;getHeight&lt;/code&gt; 方法返回的值不受此方法的影响；他们将继续返回图像的默认尺寸。类似地，如果图像也被平铺，则以默认大小给出平铺的宽度和高度。</target>
        </trans-unit>
        <trans-unit id="3b13126a7b6fc1071a110411ef949559c81f856f" translate="yes" xml:space="preserve">
          <source>If the image represents an animated image, it will be animated automatically.</source>
          <target state="translated">如果图像代表的是动画图像,则会自动播放动画。</target>
        </trans-unit>
        <trans-unit id="f6a7ef1905b7717e6534c8262beb9af466dbbe75" translate="yes" xml:space="preserve">
          <source>If the image type is TYPE_BYTE_BINARY, the number of entries in the color model is used to determine whether the image should have 1, 2, or 4 bits per pixel. If the color model has 1 or 2 entries, the image will have 1 bit per pixel. If it has 3 or 4 entries, the image with have 2 bits per pixel. If it has between 5 and 16 entries, the image will have 4 bits per pixel. Otherwise, an IllegalArgumentException will be thrown.</source>
          <target state="translated">如果图像类型是TYPE_BYTE_BINARY,颜色模型的条目数用来决定图像每像素应该有1、2或4位。如果颜色模型有1个或2个条目,图像每像素将有1位。如果它有3或4个条目,则图像每像素有2位。如果它有5到16个条目,图像将有4位/像素。否则,将抛出IllegalArgumentException。</target>
        </trans-unit>
        <trans-unit id="d7ce886e7cf517b9dd1b8e4bf3972fb87acfaf11" translate="yes" xml:space="preserve">
          <source>If the implementation can supply a value for one of the queries listed in the if statement of the default implementation, then it must do so. For example, an application-defined &lt;code&gt;HourMin&lt;/code&gt; class storing the hour and minute must override this method as follows:</source>
          <target state="translated">如果实现可以为默认实现的if语句中列出的查询之一提供值，则必须这样做。例如，应用程序定义的存储小时和分钟的 &lt;code&gt;HourMin&lt;/code&gt; 类必须重写此方法，如下所示：</target>
        </trans-unit>
        <trans-unit id="ba2e71c9350a067beb4f36ed2c2123aef7d9b604" translate="yes" xml:space="preserve">
          <source>If the implementation does not support the requested type of object or operation.</source>
          <target state="translated">如果实现不支持所请求的对象或操作类型。</target>
        </trans-unit>
        <trans-unit id="8ab19508e52ba992a5a553d39a65472031820996" translate="yes" xml:space="preserve">
          <source>If the implementation of this class does not support persistence, an &lt;a href=&quot;../mbeanexception&quot;&gt;&lt;code&gt;MBeanException&lt;/code&gt;&lt;/a&gt; wrapping a &lt;a href=&quot;../servicenotfoundexception&quot;&gt;&lt;code&gt;ServiceNotFoundException&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">如果此类的实现不支持持久性，&lt;a href=&quot;../mbeanexception&quot;&gt; &lt;code&gt;MBeanException&lt;/code&gt; &lt;/a&gt;包装&lt;a href=&quot;../servicenotfoundexception&quot;&gt; &lt;code&gt;ServiceNotFoundException&lt;/code&gt; &lt;/a&gt;的MBeanException。</target>
        </trans-unit>
        <trans-unit id="05e9c8575bf962e5c616ffc00d01915b9381d7c7" translate="yes" xml:space="preserve">
          <source>If the implementation of this method throws a &lt;a href=&quot;../../../java.base/java/lang/runtimeexception&quot;&gt;&lt;code&gt;RuntimeException&lt;/code&gt;&lt;/a&gt; or an &lt;a href=&quot;../../../java.base/java/lang/error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt;, the MBean Server will rethrow those inside a &lt;a href=&quot;runtimembeanexception&quot;&gt;&lt;code&gt;RuntimeMBeanException&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;runtimeerrorexception&quot;&gt;&lt;code&gt;RuntimeErrorException&lt;/code&gt;&lt;/a&gt;, respectively. However, throwing an exception in &lt;code&gt;postDeregister&lt;/code&gt; will not change the state of the MBean: the MBean was already successfully deregistered and will remain so.</source>
          <target state="translated">如果此方法的实现引发&lt;a href=&quot;../../../java.base/java/lang/runtimeexception&quot;&gt; &lt;code&gt;RuntimeException&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../../../java.base/java/lang/error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt;，则MBean服务器将分别将它们分别抛出&lt;a href=&quot;runtimembeanexception&quot;&gt; &lt;code&gt;RuntimeMBeanException&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;runtimeerrorexception&quot;&gt; &lt;code&gt;RuntimeErrorException&lt;/code&gt; &lt;/a&gt;。但是，在 &lt;code&gt;postDeregister&lt;/code&gt; 中引发异常不会更改MBean的状态：MBean已成功注销，并将保持这种状态。</target>
        </trans-unit>
        <trans-unit id="b030ce654ec4888a547056d4d3abf6da997ebc0c" translate="yes" xml:space="preserve">
          <source>If the implementation of this method throws a &lt;a href=&quot;../../../java.base/java/lang/runtimeexception&quot;&gt;&lt;code&gt;RuntimeException&lt;/code&gt;&lt;/a&gt; or an &lt;a href=&quot;../../../java.base/java/lang/error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt;, the MBean Server will rethrow those inside a &lt;a href=&quot;runtimembeanexception&quot;&gt;&lt;code&gt;RuntimeMBeanException&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;runtimeerrorexception&quot;&gt;&lt;code&gt;RuntimeErrorException&lt;/code&gt;&lt;/a&gt;, respectively. However, throwing an exception in &lt;code&gt;postRegister&lt;/code&gt; will not change the state of the MBean: if the MBean was already registered (&lt;code&gt;registrationDone&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;), the MBean will remain registered.</source>
          <target state="translated">如果此方法的实现引发&lt;a href=&quot;../../../java.base/java/lang/runtimeexception&quot;&gt; &lt;code&gt;RuntimeException&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../../../java.base/java/lang/error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt;，则MBean服务器将分别将它们分别抛出&lt;a href=&quot;runtimembeanexception&quot;&gt; &lt;code&gt;RuntimeMBeanException&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;runtimeerrorexception&quot;&gt; &lt;code&gt;RuntimeErrorException&lt;/code&gt; &lt;/a&gt;。但是，在 &lt;code&gt;postRegister&lt;/code&gt; 中引发异常不会更改MBean的状态：如果已经注册了MBean（ &lt;code&gt;registrationDone&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ），则MBean将保持注册状态。</target>
        </trans-unit>
        <trans-unit id="61497ea0a67eb203673d203a0f2b5369b019bf33" translate="yes" xml:space="preserve">
          <source>If the implementation of this method throws a &lt;a href=&quot;../../../java/lang/runtimeexception&quot;&gt;&lt;code&gt;RuntimeException&lt;/code&gt;&lt;/a&gt; or an &lt;a href=&quot;../../../java/lang/error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt;, the MBean Server will rethrow those inside a &lt;a href=&quot;../runtimembeanexception&quot;&gt;&lt;code&gt;RuntimeMBeanException&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../runtimeerrorexception&quot;&gt;&lt;code&gt;RuntimeErrorException&lt;/code&gt;&lt;/a&gt;, respectively. However, throwing an exception in &lt;code&gt;postDeregister&lt;/code&gt; will not change the state of the MBean: the MBean was already successfully deregistered and will remain so.</source>
          <target state="translated">如果此方法的实现引发&lt;a href=&quot;../../../java/lang/runtimeexception&quot;&gt; &lt;code&gt;RuntimeException&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../../../java/lang/error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt;，则MBean服务器将分别将它们分别抛出&lt;a href=&quot;../runtimembeanexception&quot;&gt; &lt;code&gt;RuntimeMBeanException&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../runtimeerrorexception&quot;&gt; &lt;code&gt;RuntimeErrorException&lt;/code&gt; &lt;/a&gt;。但是，在 &lt;code&gt;postDeregister&lt;/code&gt; 中引发异常不会更改MBean的状态：MBean已成功注销，并将保持这种状态。</target>
        </trans-unit>
        <trans-unit id="b96b5c5ec491812d30a354e2cb6f11721b2e2b1d" translate="yes" xml:space="preserve">
          <source>If the implementation of this method throws a &lt;a href=&quot;../../../java/lang/runtimeexception&quot;&gt;&lt;code&gt;RuntimeException&lt;/code&gt;&lt;/a&gt; or an &lt;a href=&quot;../../../java/lang/error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt;, the MBean Server will rethrow those inside a &lt;a href=&quot;../runtimembeanexception&quot;&gt;&lt;code&gt;RuntimeMBeanException&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../runtimeerrorexception&quot;&gt;&lt;code&gt;RuntimeErrorException&lt;/code&gt;&lt;/a&gt;, respectively. However, throwing an exception in &lt;code&gt;postRegister&lt;/code&gt; will not change the state of the MBean: if the MBean was already registered (&lt;code&gt;registrationDone&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;), the MBean will remain registered.</source>
          <target state="translated">如果此方法的实现引发&lt;a href=&quot;../../../java/lang/runtimeexception&quot;&gt; &lt;code&gt;RuntimeException&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../../../java/lang/error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt;，则MBean服务器将分别将它们分别抛出&lt;a href=&quot;../runtimembeanexception&quot;&gt; &lt;code&gt;RuntimeMBeanException&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../runtimeerrorexception&quot;&gt; &lt;code&gt;RuntimeErrorException&lt;/code&gt; &lt;/a&gt;。但是，在 &lt;code&gt;postRegister&lt;/code&gt; 中引发异常不会更改MBean的状态：如果已经注册了MBean（ &lt;code&gt;registrationDone&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ），则MBean将保持注册状态。</target>
        </trans-unit>
        <trans-unit id="4535342913d52819782cb269ae901b36379460f0" translate="yes" xml:space="preserve">
          <source>If the implementation of this method throws a &lt;a href=&quot;../../java/lang/runtimeexception&quot;&gt;&lt;code&gt;RuntimeException&lt;/code&gt;&lt;/a&gt; or an &lt;a href=&quot;../../java/lang/error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt;, the MBean Server will rethrow those inside a &lt;a href=&quot;runtimembeanexception&quot;&gt;&lt;code&gt;RuntimeMBeanException&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;runtimeerrorexception&quot;&gt;&lt;code&gt;RuntimeErrorException&lt;/code&gt;&lt;/a&gt;, respectively. However, throwing an exception in &lt;code&gt;postDeregister&lt;/code&gt; will not change the state of the MBean: the MBean was already successfully deregistered and will remain so.</source>
          <target state="translated">如果此方法的实现引发&lt;a href=&quot;../../java/lang/runtimeexception&quot;&gt; &lt;code&gt;RuntimeException&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../../java/lang/error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt;，则MBean服务器将分别将它们分别抛出&lt;a href=&quot;runtimembeanexception&quot;&gt; &lt;code&gt;RuntimeMBeanException&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;runtimeerrorexception&quot;&gt; &lt;code&gt;RuntimeErrorException&lt;/code&gt; &lt;/a&gt;。但是，在 &lt;code&gt;postDeregister&lt;/code&gt; 中引发异常不会更改MBean的状态：MBean已成功注销，并将保持这种状态。</target>
        </trans-unit>
        <trans-unit id="76763841aca1fa1b12ea5b878cc85e9f7cde9edb" translate="yes" xml:space="preserve">
          <source>If the implementation of this method throws a &lt;a href=&quot;../../java/lang/runtimeexception&quot;&gt;&lt;code&gt;RuntimeException&lt;/code&gt;&lt;/a&gt; or an &lt;a href=&quot;../../java/lang/error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt;, the MBean Server will rethrow those inside a &lt;a href=&quot;runtimembeanexception&quot;&gt;&lt;code&gt;RuntimeMBeanException&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;runtimeerrorexception&quot;&gt;&lt;code&gt;RuntimeErrorException&lt;/code&gt;&lt;/a&gt;, respectively. However, throwing an exception in &lt;code&gt;postRegister&lt;/code&gt; will not change the state of the MBean: if the MBean was already registered (&lt;code&gt;registrationDone&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;), the MBean will remain registered.</source>
          <target state="translated">如果此方法的实现引发&lt;a href=&quot;../../java/lang/runtimeexception&quot;&gt; &lt;code&gt;RuntimeException&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../../java/lang/error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt;，则MBean服务器将分别将它们分别抛出&lt;a href=&quot;runtimembeanexception&quot;&gt; &lt;code&gt;RuntimeMBeanException&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;runtimeerrorexception&quot;&gt; &lt;code&gt;RuntimeErrorException&lt;/code&gt; &lt;/a&gt;。但是，在 &lt;code&gt;postRegister&lt;/code&gt; 中引发异常不会更改MBean的状态：如果已经注册了MBean（ &lt;code&gt;registrationDone&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ），则MBean将保持注册状态。</target>
        </trans-unit>
        <trans-unit id="1a75de9cc725b96c1261a9ca528b8f0bb1b31691" translate="yes" xml:space="preserve">
          <source>If the implementation requires some measurable time to cancel the job in the &lt;code&gt;PROCESSING&lt;/code&gt; or &lt;code&gt;PROCESSING_STOPPED&lt;/code&gt; job states, the printer must use this reason to indicate that the printer is still performing some actions on the job while the job remains in the &lt;code&gt;PROCESSING&lt;/code&gt; or &lt;code&gt;PROCESSING_STOPPED&lt;/code&gt; state. After all the job's job description attributes have stopped incrementing, the printer moves the job from the PROCESSING state to the &lt;code&gt;CANCELED&lt;/code&gt; or &lt;code&gt;ABORTED&lt;/code&gt; job states.</source>
          <target state="translated">如果实现需要一些可测量的时间来取消处于 &lt;code&gt;PROCESSING&lt;/code&gt; 或 &lt;code&gt;PROCESSING_STOPPED&lt;/code&gt; 作业状态的作业，则打印机必须使用此原因来指示当作业仍处于 &lt;code&gt;PROCESSING&lt;/code&gt; 或 &lt;code&gt;PROCESSING_STOPPED&lt;/code&gt; 状态时，打印机仍在对该作业执行某些操作。在所有作业的作业描述属性停止递增之后，打印机将作业从&amp;ldquo;处理中&amp;rdquo;状态移到&amp;ldquo;已 &lt;code&gt;CANCELED&lt;/code&gt; 或&amp;ldquo; &lt;code&gt;ABORTED&lt;/code&gt; 状态。</target>
        </trans-unit>
        <trans-unit id="e5a527012aa1181404e26ff9eba79c5215c6617c" translate="yes" xml:space="preserve">
          <source>If the implementation requires some measurable time to cancel the job in the PROCESSING or PROCESSING_STOPPED job states, the printer must use this reason to indicate that the printer is still performing some actions on the job while the job remains in the PROCESSING or PROCESSING_STOPPED state. After all the job's job description attributes have stopped incrementing, the printer moves the job from the PROCESSING state to the CANCELED or ABORTED job states.</source>
          <target state="translated">如果执行需要一些可衡量的时间来取消处于PROCESSING或PROCESSING_STOPPED作业状态下的作业,打印机必须使用这个理由来表明,当作业处于PROCESSING或PROCESSING_STOPPED状态时,打印机仍在对作业执行一些操作。当作业的所有作业描述属性停止递增后,打印机将作业从PROCESSING状态移至CANCELED或ABORTED作业状态。</target>
        </trans-unit>
        <trans-unit id="21a96789298a278046ce067991e2d31d04c7cbd4" translate="yes" xml:space="preserve">
          <source>If the implementation supports</source>
          <target state="translated">如果实施支持</target>
        </trans-unit>
        <trans-unit id="9c61e0dd2f97968224ba5bded184eb2a44d95c79" translate="yes" xml:space="preserve">
          <source>If the implementation supports a history mechanism, a reference to an Edit implementation will be returned, otherwise null.</source>
          <target state="translated">如果实现支持历史机制,将返回对Edit实现的引用,否则为null。</target>
        </trans-unit>
        <trans-unit id="35f873dd7c2035b38202cda19f7fef9dd8dbdb3b" translate="yes" xml:space="preserve">
          <source>If the implementing method determines that no transformations are needed, it should return &lt;code&gt;null&lt;/code&gt;. Otherwise, it should create a new &lt;code&gt;byte[]&lt;/code&gt; array, copy the input &lt;code&gt;classfileBuffer&lt;/code&gt; into it, along with all desired transformations, and return the new array. The input &lt;code&gt;classfileBuffer&lt;/code&gt; must not be modified.</source>
          <target state="translated">如果实现方法确定不需要任何转换，则应返回 &lt;code&gt;null&lt;/code&gt; 。否则，它应该创建一个新的 &lt;code&gt;byte[]&lt;/code&gt; 数组，将输入的 &lt;code&gt;classfileBuffer&lt;/code&gt; 连同所有所需的转换一起复制到其中，然后返回该新数组。输入的 &lt;code&gt;classfileBuffer&lt;/code&gt; 不得修改。</target>
        </trans-unit>
        <trans-unit id="81ca206f6782401fcc1f26d127affa8acd0e136d" translate="yes" xml:space="preserve">
          <source>If the implementing object is an instance of java.beans.beancontext.BeanContext, or a subinterface thereof, then that BeanContext should fire a PropertyChangeEvent, to its registered BeanContextMembershipListeners, with parameters:</source>
          <target state="translated">如果实现对象是java.beans.beancontext.BeanContext的实例,或者是其子接口,那么该BeanContext应该向其注册的BeanContextMembershipListeners发射一个PropertyChangeEvent,参数。</target>
        </trans-unit>
        <trans-unit id="36b6757dd0b7b9698143f2e5d681dfa198ff7d6d" translate="yes" xml:space="preserve">
          <source>If the incoming object does not implement any additional interfaces known to the writer, the writer has no choice but to access it via the standard &lt;code&gt;IIOMetadata&lt;/code&gt; interfaces such as the tree view provided by &lt;code&gt;IIOMetadata.getAsTree&lt;/code&gt;. In this case, there is likely to be significant loss of information.</source>
          <target state="translated">如果传入对象未实现编写者已知的任何其他接口，则编写者别无选择，只能通过标准 &lt;code&gt;IIOMetadata&lt;/code&gt; 接口（例如 &lt;code&gt;IIOMetadata.getAsTree&lt;/code&gt; 提供的树视图）访问它。在这种情况下，很可能会丢失大量信息。</target>
        </trans-unit>
        <trans-unit id="e436d84bd4232b4579b6124cd808ff4918e211d5" translate="yes" xml:space="preserve">
          <source>If the inherited channel is a datagram-oriented socket then a &lt;a href=&quot;../datagramchannel&quot;&gt;&lt;code&gt;DatagramChannel&lt;/code&gt;&lt;/a&gt; is returned. The datagram channel is, at least initially, in blocking mode, and bound to a socket address.</source>
          <target state="translated">如果继承的通道是面向数据报的套接字，则返回&lt;a href=&quot;../datagramchannel&quot;&gt; &lt;code&gt;DatagramChannel&lt;/code&gt; &lt;/a&gt;。数据报通道至少在最初处于阻塞模式，并绑定到套接字地址。</target>
        </trans-unit>
        <trans-unit id="3073a336a578c76af3c2fae533b0dcd45d01e490" translate="yes" xml:space="preserve">
          <source>If the inherited channel represents a stream-oriented connected socket then a &lt;a href=&quot;../socketchannel&quot;&gt;&lt;code&gt;SocketChannel&lt;/code&gt;&lt;/a&gt; is returned. The socket channel is, at least initially, in blocking mode, bound to a socket address, and connected to a peer.</source>
          <target state="translated">如果继承的通道表示面向流的连接套接字，则返回&lt;a href=&quot;../socketchannel&quot;&gt; &lt;code&gt;SocketChannel&lt;/code&gt; &lt;/a&gt;。套接字通道至少在最初处于阻塞模式，绑定到套接字地址，并连接到对等方。</target>
        </trans-unit>
        <trans-unit id="875d948792bb0df4386ddee7ed26751e7f15e361" translate="yes" xml:space="preserve">
          <source>If the inherited channel represents a stream-oriented listening socket then a &lt;a href=&quot;../serversocketchannel&quot;&gt;&lt;code&gt;ServerSocketChannel&lt;/code&gt;&lt;/a&gt; is returned. The server-socket channel is, at least initially, in blocking mode, and bound to a socket address.</source>
          <target state="translated">如果继承的通道表示面向流的侦听套接字，则返回&lt;a href=&quot;../serversocketchannel&quot;&gt; &lt;code&gt;ServerSocketChannel&lt;/code&gt; &lt;/a&gt;。服务器套接字通道至少在最初处于阻塞模式，并且绑定到套接字地址。</target>
        </trans-unit>
        <trans-unit id="046cd8116ea31a7deaa92b344ddffcaddc10e57f" translate="yes" xml:space="preserve">
          <source>If the input byte array is not in valid Base64 encoding scheme then some bytes may have been written to the output byte array before IllegalargumentException is thrown.</source>
          <target state="translated">如果输入字节数组不在有效的Base64编码方案中,那么在IllegalargumentException被抛出之前,一些字节可能已经被写入输出字节数组。</target>
        </trans-unit>
        <trans-unit id="91347d5773aae8847de673eedfeeb7e761115795" translate="yes" xml:space="preserve">
          <source>If the input is not a valid Snippet, this will not be a valid class/import definition.</source>
          <target state="translated">如果输入不是有效的Snippet,这将不是一个有效的类/导入定义。</target>
        </trans-unit>
        <trans-unit id="7b8c0e64cbb7daebfbf49419512f53ea309aa91a" translate="yes" xml:space="preserve">
          <source>If the input name does not contain a realm, the default realm is used. The default realm can be specified either in a Kerberos configuration file or via the &lt;code&gt;&lt;span id=&quot;java.security.krb5.realm&quot;&gt;java.security.krb5.realm&lt;/span&gt;&lt;/code&gt; system property. For more information, see the &lt;a href=&quot;https://docs.oracle.com/pls/topic/lookup?ctx=javase15&amp;amp;id=security_guide_jgss_tutorial&quot;&gt;Kerberos Requirements&lt;/a&gt;.</source>
          <target state="translated">如果输入名称不包含领域，则使用默认领域。可以在Kerberos配置文件中或通过 &lt;code&gt;&lt;span id=&quot;java.security.krb5.realm&quot;&gt;java.security.krb5.realm&lt;/span&gt;&lt;/code&gt; 系统属性指定默认领域。有关更多信息，请参见&lt;a href=&quot;https://docs.oracle.com/pls/topic/lookup?ctx=javase15&amp;amp;id=security_guide_jgss_tutorial&quot;&gt;Kerberos要求&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6bd58891e2c653b5383c76eb69e062e344690968" translate="yes" xml:space="preserve">
          <source>If the input name does not contain a realm, the default realm is used. The default realm can be specified either in a Kerberos configuration file or via the &lt;code&gt;&lt;span id=&quot;java.security.krb5.realm-1&quot;&gt;java.security.krb5.realm&lt;/span&gt;&lt;/code&gt; system property. For more information, see the &lt;a href=&quot;https://docs.oracle.com/pls/topic/lookup?ctx=javase15&amp;amp;id=security_guide_jgss_tutorial&quot;&gt;Kerberos Requirements&lt;/a&gt;.</source>
          <target state="translated">如果输入名称不包含领域，则使用默认领域。可以在Kerberos配置文件中或通过 &lt;code&gt;&lt;span id=&quot;java.security.krb5.realm-1&quot;&gt;java.security.krb5.realm&lt;/span&gt;&lt;/code&gt; 系统属性指定默认领域。有关更多信息，请参见&lt;a href=&quot;https://docs.oracle.com/pls/topic/lookup?ctx=javase15&amp;amp;id=security_guide_jgss_tutorial&quot;&gt;Kerberos要求&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="44c010f5bf051b0a98a728de40056665c0f4201b" translate="yes" xml:space="preserve">
          <source>If the input name does not contain a realm, the default realm is used. The default realm can be specified either in a Kerberos configuration file or via the java.security.krb5.realm system property. For more information,  Kerberos Requirements</source>
          <target state="translated">如果输入的名字不包含 realm,则会使用默认的 realm。默认的领域可以在 Kerberos 配置文件中或通过 java.security.krb5.realm 系统属性来指定。更多信息,请参阅 Kerberos 需求</target>
        </trans-unit>
        <trans-unit id="e2258789d44cebf2e677dac1a6ecd85ab5667fdc" translate="yes" xml:space="preserve">
          <source>If the input name does not contain a realm, the default realm is used. The default realm can be specified either in a Kerberos configuration file or via the java.security.krb5.realm system property. For more information, see  Kerberos Requirements.</source>
          <target state="translated">如果输入的名字不包含 realm,则会使用默认的 realm。默认的 realm 可以在 Kerberos 配置文件中指定,也可以通过 java.security.krb5.realm 系统属性来指定。更多信息请参见 Kerberos 要求。</target>
        </trans-unit>
        <trans-unit id="8a73e715c93a5e0127bac80ed71051dc7af6a5b8" translate="yes" xml:space="preserve">
          <source>If the input name does not contain a realm, the default realm is used. The default realm can be specified either in a Kerberos configuration file or via the java.security.krb5.realm system property. For more information, see the &lt;a href=&quot;https://www.oracle.com/pls/topic/lookup?ctx=javase11&amp;amp;id=security_guide_jgss_tutorial&quot;&gt;Kerberos Requirements&lt;/a&gt;. Additionally, if a security manager is installed, a &lt;a href=&quot;servicepermission&quot;&gt;&lt;code&gt;ServicePermission&lt;/code&gt;&lt;/a&gt; must be granted and the service principal of the permission must minimally be inside the &lt;code&gt;KerberosPrincipal&lt;/code&gt;'s realm. For example, if the result of &lt;code&gt;new KerberosPrincipal(&quot;user&quot;)&lt;/code&gt; is &lt;code&gt;user@EXAMPLE.COM&lt;/code&gt;, then a &lt;code&gt;ServicePermission&lt;/code&gt; with service principal &lt;code&gt;host/www.example.com@EXAMPLE.COM&lt;/code&gt; (and any action) must be granted.</source>
          <target state="translated">如果输入名称不包含领域，则使用默认领域。可以在Kerberos配置文件中或通过java.security.krb5.realm系统属性指定默认领域。有关更多信息，请参见&lt;a href=&quot;https://www.oracle.com/pls/topic/lookup?ctx=javase11&amp;amp;id=security_guide_jgss_tutorial&quot;&gt;Kerberos要求&lt;/a&gt;。此外，如果安装了安全管理器，则必须授予&lt;a href=&quot;servicepermission&quot;&gt; &lt;code&gt;ServicePermission&lt;/code&gt; ,&lt;/a&gt;并且该权限的服务主体必须至少位于 &lt;code&gt;KerberosPrincipal&lt;/code&gt; 的领域内。例如，如果 &lt;code&gt;new KerberosPrincipal(&quot;user&quot;)&lt;/code&gt; 为 &lt;code&gt;user@EXAMPLE.COM&lt;/code&gt; ，则必须授予具有服务主体 &lt;code&gt;host/www.example.com@EXAMPLE.COM&lt;/code&gt; 的 &lt;code&gt;ServicePermission&lt;/code&gt; （以及任何操作）。</target>
        </trans-unit>
        <trans-unit id="72db9a55602aeaacd8d06804f6747b4e1ec98ac6" translate="yes" xml:space="preserve">
          <source>If the input sequence is mutable, it must remain constant during the execution of the terminal stream operation. Otherwise, the result of the terminal stream operation is undefined.</source>
          <target state="translated">如果输入序列是可变的,那么在执行终端流操作的过程中必须保持不变。否则,终端流操作的结果是未定义的。</target>
        </trans-unit>
        <trans-unit id="9bc4fd432cad2c0de1cfdac5a329f31d55c9e12d" translate="yes" xml:space="preserve">
          <source>If the inserted character is '-', it is accepted.</source>
          <target state="translated">如果插入的字符是'-',则被接受。</target>
        </trans-unit>
        <trans-unit id="f3d3dcf4d36e88edd9ce623dd444c8f85abfe0b1" translate="yes" xml:space="preserve">
          <source>If the inserted character matches the mask for the next non-literal character, it is accepted at the new location.</source>
          <target state="translated">如果插入的字符与下一个非文字字符的掩码相匹配,则会在新的位置被接受。</target>
        </trans-unit>
        <trans-unit id="bdcd5cc0d6714ef6dfe7ad5151f92554586e46cb" translate="yes" xml:space="preserve">
          <source>If the intended destination of this stream is an abstraction provided by the underlying operating system, for example a file, then flushing the stream guarantees only that bytes previously written to the stream are passed to the operating system for writing; it does not guarantee that they are actually written to a physical device such as a disk drive.</source>
          <target state="translated">如果这个流的预期目标是底层操作系统提供的一个抽象,例如一个文件,那么刷新流只能保证之前写入流的字节被传递给操作系统进行写入,并不能保证这些字节真的被写入磁盘驱动器等物理设备。</target>
        </trans-unit>
        <trans-unit id="6dbed2351bbf5adacbd2e790b9255ca10dfcf5cc" translate="yes" xml:space="preserve">
          <source>If the internal frame is already closed, this method does nothing and returns immediately. Otherwise, this method begins by firing an &lt;code&gt;INTERNAL_FRAME_CLOSING&lt;/code&gt; event. Then this method sets the &lt;code&gt;closed&lt;/code&gt; property to &lt;code&gt;true&lt;/code&gt; unless a listener vetoes the property change. This method finishes by making the internal frame invisible and unselected, and then firing an &lt;code&gt;INTERNAL_FRAME_CLOSED&lt;/code&gt; event.</source>
          <target state="translated">如果内部框架已经关闭，则此方法不执行任何操作并立即返回。否则，此方法首先触发 &lt;code&gt;INTERNAL_FRAME_CLOSING&lt;/code&gt; 事件。然后，除非侦听器否决该属性更改，否则此方法将 &lt;code&gt;closed&lt;/code&gt; 属性设置为 &lt;code&gt;true&lt;/code&gt; 。该方法通过使内部框架不可见且未被选中，然后触发 &lt;code&gt;INTERNAL_FRAME_CLOSED&lt;/code&gt; 事件来结束。</target>
        </trans-unit>
        <trans-unit id="81483551df6d9559fcbeffe5f6509d97a94497cc" translate="yes" xml:space="preserve">
          <source>If the internal frame is not visible, brings the internal frame to the front, makes it visible, and attempts to select it.</source>
          <target state="translated">如果内部框架不可见,将内部框架带到前面,使其可见,并尝试选择它。</target>
        </trans-unit>
        <trans-unit id="5939dca1837b7f5c342938c51c20c51e55fd3d33" translate="yes" xml:space="preserve">
          <source>If the internal frame is not visible, brings the internal frame to the front, makes it visible, and attempts to select it. The first time the internal frame is made visible, this method also fires an &lt;code&gt;INTERNAL_FRAME_OPENED&lt;/code&gt; event. This method does nothing if the internal frame is already visible. Invoking this method has the same result as invoking &lt;code&gt;setVisible(true)&lt;/code&gt;.</source>
          <target state="translated">如果看不见内部框架，请将内部框架置于最前面，使其可见，然后尝试选择它。第一次使内部框架可见时，此方法还会触发 &lt;code&gt;INTERNAL_FRAME_OPENED&lt;/code&gt; 事件。如果内部框架已经可见，则此方法不执行任何操作。调用此方法与调用 &lt;code&gt;setVisible(true)&lt;/code&gt; 具有相同的结果。</target>
        </trans-unit>
        <trans-unit id="881b9ec107691ccb0574603b5fa37effa233e5be" translate="yes" xml:space="preserve">
          <source>If the invoked method completes normally, the value it returns is copied in the &lt;code&gt;value&lt;/code&gt; property. Note that the &lt;code&gt;value&lt;/code&gt; property is set to &lt;code&gt;null&lt;/code&gt;, if the return type of the underlying method is &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">如果调用的方法正常完成，则将其返回的 &lt;code&gt;value&lt;/code&gt; 复制到value属性中。请注意，如果基础方法的返回类型为 &lt;code&gt;void&lt;/code&gt; ，则 &lt;code&gt;value&lt;/code&gt; 属性设置为 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="55fa409a4b17ed3350505c8e7edb658e38fe64b1" translate="yes" xml:space="preserve">
          <source>If the invoking thread is interrupted while waiting to acquire the lock then its interrupt status will be set and a &lt;a href=&quot;filelockinterruptionexception&quot;&gt;&lt;code&gt;FileLockInterruptionException&lt;/code&gt;&lt;/a&gt; will be thrown. If the invoker's interrupt status is set when this method is invoked then that exception will be thrown immediately; the thread's interrupt status will not be changed.</source>
          <target state="translated">如果在等待获取锁的过程中调用线程被中断，则将设置其中断状态，并抛出&lt;a href=&quot;filelockinterruptionexception&quot;&gt; &lt;code&gt;FileLockInterruptionException&lt;/code&gt; &lt;/a&gt;。如果在调用此方法时设置了调用者的中断状态，则将立即引发该异常；否则，将立即抛出该异常。线程的中断状态将不会更改。</target>
        </trans-unit>
        <trans-unit id="9c99f7a43566c3e0f406a92c738f397ca332a50c" translate="yes" xml:space="preserve">
          <source>If the invoking thread is interrupted while waiting, then it will return immediately with the interrupt status set. If the interrupted status is already set, this method returns immediately with the interrupt status set.</source>
          <target state="translated">如果调用线程在等待过程中被中断,那么它将以设置的中断状态立即返回。如果已经设置了中断状态,那么本方法将以设置的中断状态立即返回。</target>
        </trans-unit>
        <trans-unit id="b769fc50fe26f32efef5297788dde55385ed9b56" translate="yes" xml:space="preserve">
          <source>If the item at the specified index is not selected, then the operation is ignored.</source>
          <target state="translated">如果没有选择指定索引的项目,则忽略该操作。</target>
        </trans-unit>
        <trans-unit id="609b6cb5da70d41c83a3aac10202e485bae19735" translate="yes" xml:space="preserve">
          <source>If the item is the first one being added to the choice, then the item becomes selected. Otherwise, if the selected item was one of the items shifted, the first item in the choice becomes the selected item. If the selected item was no among those shifted, it remains the selected item.</source>
          <target state="translated">如果该项目是第一个被添加到选择中的项目,那么该项目就会被选中。否则,如果被选中的项目是被移动的项目之一,则选择中的第一个项目成为被选中的项目。如果被选中的项目不在被移动的项目中,那么它仍然是被选中的项目。</target>
        </trans-unit>
        <trans-unit id="2f2c303e208ec2fac91ffa790d4de069ee4e7cc5" translate="yes" xml:space="preserve">
          <source>If the iteration variable type &lt;code&gt;V&lt;/code&gt; is dropped from the internal parameter list, the resulting shorter list &lt;code&gt;(A...)&lt;/code&gt; is called the &lt;em&gt;external parameter list&lt;/em&gt;.</source>
          <target state="translated">如果将迭代变量类型 &lt;code&gt;V&lt;/code&gt; 从内部参数列表中删除，则生成的较短列表 &lt;code&gt;(A...)&lt;/code&gt; 被称为&lt;em&gt;外部参数列表&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="677df4c5c3a72284b193dc3046a802a47d947204" translate="yes" xml:space="preserve">
          <source>If the iteration variable types &lt;code&gt;(V I)&lt;/code&gt; are dropped from the internal parameter list, the resulting shorter list &lt;code&gt;(A...)&lt;/code&gt; is called the &lt;em&gt;external parameter list&lt;/em&gt;.</source>
          <target state="translated">如果从内部参数列表中删除了迭代变量类型 &lt;code&gt;(V I)&lt;/code&gt; ，则生成的较短列表 &lt;code&gt;(A...)&lt;/code&gt; 被称为&lt;em&gt;外部参数列表&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="3b2f8ee14f1a5134aa879886d0c902676ccbfafd" translate="yes" xml:space="preserve">
          <source>If the iteration variable types &lt;code&gt;(V T)&lt;/code&gt; are dropped from the internal parameter list, the resulting shorter list &lt;code&gt;(A...)&lt;/code&gt; is called the &lt;em&gt;external parameter list&lt;/em&gt;.</source>
          <target state="translated">如果从内部参数列表中删除了迭代变量类型 &lt;code&gt;(V T)&lt;/code&gt; ，则生成的较短列表 &lt;code&gt;(A...)&lt;/code&gt; 被称为&lt;em&gt;外部参数列表&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="ace7c9d0c03c5a8591ce4f875b6cfb21a9fe43d8" translate="yes" xml:space="preserve">
          <source>If the jar file is on the class path, VendorJavaCompiler can be located using code like this:</source>
          <target state="translated">如果jar文件在类路径上,VendorJavaCompiler可以使用这样的代码来定位。</target>
        </trans-unit>
        <trans-unit id="05798c7b9d831dc45d92f33b15f7f3c7a9524b15" translate="yes" xml:space="preserve">
          <source>If the key agreement algorithm requires random bytes, it gets them from the given source of randomness, &lt;code&gt;random&lt;/code&gt;. However, if the underlying algorithm implementation does not require any random bytes, &lt;code&gt;random&lt;/code&gt; is ignored.</source>
          <target state="translated">如果密钥协商算法需要随机字节，则从给定的随机性源 &lt;code&gt;random&lt;/code&gt; 中获取它们。但是，如果基础算法实现不需要任何随机字节，则将忽略 &lt;code&gt;random&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b9ba2d545a01554992fedf0cb983cad56e6a2aca" translate="yes" xml:space="preserve">
          <source>If the key is stored on a hardware device, its specification may contain information that helps identify the key on the device.</source>
          <target state="translated">如果密钥存储在硬件设备上,其规格可能包含有助于识别设备上密钥的信息。</target>
        </trans-unit>
        <trans-unit id="c9af549a3a519458df47c4c31dbda4adcd0e3257" translate="yes" xml:space="preserve">
          <source>If the language requires different forms for formatting and stand-alone usages, This method returns short month names in the formatting form. For example, the preferred abbreviation for January in the Catalan language is &lt;em&gt;de gen.&lt;/em&gt; in the formatting form, while it is &lt;em&gt;gen.&lt;/em&gt; in the stand-alone form. This method returns &lt;code&gt;&quot;de gen.&quot;&lt;/code&gt; in this case. Refer to the &lt;a href=&quot;http://unicode.org/reports/tr35/#Calendar_Elements&quot;&gt; Calendar Elements in the Unicode Locale Data Markup Language (LDML) specification&lt;/a&gt; for more details.</source>
          <target state="translated">如果语言要求不同的格式格式和独立使用，则此方法以格式格式返回短月份名称。例如，加泰罗尼亚语中January的首选缩写是&lt;em&gt;de gen。&lt;/em&gt;在格式表格中，虽然它是&lt;em&gt;gen。&lt;/em&gt;以独立形式。此方法返回 &lt;code&gt;&quot;de gen.&quot;&lt;/code&gt; 在这种情况下。有关更多详细信息，请参考&lt;a href=&quot;http://unicode.org/reports/tr35/#Calendar_Elements&quot;&gt;Unicode区域设置数据标记语言（LDML）规范中&lt;/a&gt;的日历元素。</target>
        </trans-unit>
        <trans-unit id="93f027224547b6049ea9e0bfa7e65c576dd00372" translate="yes" xml:space="preserve">
          <source>If the language requires different forms for formatting and stand-alone usages, this method returns month names in the formatting form. For example, the preferred month name for January in the Czech language is &lt;em&gt;ledna&lt;/em&gt; in the formatting form, while it is &lt;em&gt;leden&lt;/em&gt; in the stand-alone form. This method returns &lt;code&gt;&quot;ledna&quot;&lt;/code&gt; in this case. Refer to the &lt;a href=&quot;http://unicode.org/reports/tr35/#Calendar_Elements&quot;&gt; Calendar Elements in the Unicode Locale Data Markup Language (LDML) specification&lt;/a&gt; for more details.</source>
          <target state="translated">如果语言要求不同的格式格式和独立用法，则此方法以格式格式返回月份名称。例如，对于1月在捷克语最佳月份名称是&lt;em&gt;ledna&lt;/em&gt;在格式化的形式，而它&lt;em&gt;LEDEN&lt;/em&gt;在单机形式。在这种情况下，此方法返回 &lt;code&gt;&quot;ledna&quot;&lt;/code&gt; 。有关更多详细信息，请参考&lt;a href=&quot;http://unicode.org/reports/tr35/#Calendar_Elements&quot;&gt;Unicode区域设置数据标记语言（LDML）规范中&lt;/a&gt;的日历元素。</target>
        </trans-unit>
        <trans-unit id="ec115a41fa789db2802143bd704e450eb4e10a17" translate="yes" xml:space="preserve">
          <source>If the language requires different forms for formatting and stand-alone usages, this method returns month names in the formatting form. For example, the preferred month name for January in the Czech language is &lt;em&gt;ledna&lt;/em&gt; in the formatting form, while it is &lt;em&gt;leden&lt;/em&gt; in the stand-alone form. This method returns &lt;code&gt;&quot;ledna&quot;&lt;/code&gt; in this case. Refer to the &lt;a href=&quot;https://unicode.org/reports/tr35/#Calendar_Elements&quot;&gt; Calendar Elements in the Unicode Locale Data Markup Language (LDML) specification&lt;/a&gt; for more details.</source>
          <target state="translated">如果语言要求不同的格式格式和独立用法，则此方法以格式格式返回月份名称。例如，对于1月在捷克语最佳月份名称是&lt;em&gt;ledna&lt;/em&gt;在格式化的形式，而它&lt;em&gt;LEDEN&lt;/em&gt;在单机形式。在这种情况下，此方法返回 &lt;code&gt;&quot;ledna&quot;&lt;/code&gt; 。有关更多详细信息，请参考&lt;a href=&quot;https://unicode.org/reports/tr35/#Calendar_Elements&quot;&gt;Unicode区域设置数据标记语言（LDML）规范中&lt;/a&gt;的日历元素。</target>
        </trans-unit>
        <trans-unit id="4df908f1fac23c580aff4bb5a5d73c49f92ce060" translate="yes" xml:space="preserve">
          <source>If the language requires different forms for formatting and stand-alone usages, this method returns short month names in the formatting form. For example, the preferred abbreviation for January in the Catalan language is &lt;em&gt;de gen.&lt;/em&gt; in the formatting form, while it is &lt;em&gt;gen.&lt;/em&gt; in the stand-alone form. This method returns &lt;code&gt;&quot;de gen.&quot;&lt;/code&gt; in this case. Refer to the &lt;a href=&quot;http://unicode.org/reports/tr35/#Calendar_Elements&quot;&gt; Calendar Elements in the Unicode Locale Data Markup Language (LDML) specification&lt;/a&gt; for more details.</source>
          <target state="translated">如果语言要求不同的格式格式和独立使用，则此方法以格式格式返回短月份名称。例如，加泰罗尼亚语中January的首选缩写是&lt;em&gt;de gen。&lt;/em&gt;在格式表格中，虽然它是&lt;em&gt;gen。&lt;/em&gt;以独立形式。此方法返回 &lt;code&gt;&quot;de gen.&quot;&lt;/code&gt; 在这种情况下。有关更多详细信息，请参考&lt;a href=&quot;http://unicode.org/reports/tr35/#Calendar_Elements&quot;&gt;Unicode区域设置数据标记语言（LDML）规范中&lt;/a&gt;的日历元素。</target>
        </trans-unit>
        <trans-unit id="9a36eee403712a7e42f21c34d895460cc4cd080c" translate="yes" xml:space="preserve">
          <source>If the language requires different forms for formatting and stand-alone usages, this method returns short month names in the formatting form. For example, the preferred abbreviation for January in the Catalan language is &lt;em&gt;de gen.&lt;/em&gt; in the formatting form, while it is &lt;em&gt;gen.&lt;/em&gt; in the stand-alone form. This method returns &lt;code&gt;&quot;de gen.&quot;&lt;/code&gt; in this case. Refer to the &lt;a href=&quot;https://unicode.org/reports/tr35/#Calendar_Elements&quot;&gt; Calendar Elements in the Unicode Locale Data Markup Language (LDML) specification&lt;/a&gt; for more details.</source>
          <target state="translated">如果语言要求不同的格式格式和独立使用，则此方法以格式格式返回短月份名称。例如，加泰罗尼亚语中January的首选缩写是&lt;em&gt;de gen。&lt;/em&gt;在格式表格中，虽然它是&lt;em&gt;gen。&lt;/em&gt;以独立形式。此方法返回 &lt;code&gt;&quot;de gen.&quot;&lt;/code&gt; 在这种情况下。有关更多详细信息，请参考&lt;a href=&quot;https://unicode.org/reports/tr35/#Calendar_Elements&quot;&gt;Unicode区域设置数据标记语言（LDML）规范中&lt;/a&gt;的日历元素。</target>
        </trans-unit>
        <trans-unit id="f1bf4283a4aed636a8a304bb68dccc18d01e161c" translate="yes" xml:space="preserve">
          <source>If the layout manager uses a per-component string, adds the component &lt;code&gt;comp&lt;/code&gt; to the layout, associating it with the string specified by &lt;code&gt;name&lt;/code&gt;.</source>
          <target state="translated">如果布局管理器使用每个组件的字符串，则将组件 &lt;code&gt;comp&lt;/code&gt; 添加到布局中，并将其与 &lt;code&gt;name&lt;/code&gt; 所指定的字符串相关联。</target>
        </trans-unit>
        <trans-unit id="721e40fbee0b627fcc6ccf4dd39ef80c9c24cc65" translate="yes" xml:space="preserve">
          <source>If the length of &lt;code&gt;b&lt;/code&gt; is zero, then no bytes are read and &lt;code&gt;0&lt;/code&gt; is returned; otherwise, there is an attempt to read at least one byte. If no byte is available because the stream is at the end of the file, the value &lt;code&gt;-1&lt;/code&gt; is returned; otherwise, at least one byte is read and stored into &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;b&lt;/code&gt; 的长度为零，则不读取任何字节，并返回 &lt;code&gt;0&lt;/code&gt; ；否则，返回0。否则，尝试读取至少一个字节。如果由于流位于文件末尾而没有字节可用，则返回值 &lt;code&gt;-1&lt;/code&gt; ；否则返回值-1。否则，读取至少一个字节并将其存储到 &lt;code&gt;b&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="945b37877bd5c51ba536e667136d3b4286b64c37" translate="yes" xml:space="preserve">
          <source>If the length of the argument string is &lt;code&gt;0&lt;/code&gt;, then this &lt;code&gt;String&lt;/code&gt; object is returned. Otherwise, a &lt;code&gt;String&lt;/code&gt; object is returned that represents a character sequence that is the concatenation of the character sequence represented by this &lt;code&gt;String&lt;/code&gt; object and the character sequence represented by the argument string.</source>
          <target state="translated">如果参数字符串的长度为 &lt;code&gt;0&lt;/code&gt; ，则返回此 &lt;code&gt;String&lt;/code&gt; 对象。否则，将返回一个 &lt;code&gt;String&lt;/code&gt; 对象，该对象表示一个字符序列，该字符序列是此 &lt;code&gt;String&lt;/code&gt; 对象表示的字符序列与参数字符串表示的字符序列的串联。</target>
        </trans-unit>
        <trans-unit id="0940fb46aa425a706a545b01258cef980fd6db8a" translate="yes" xml:space="preserve">
          <source>If the length of the specified &lt;code&gt;CharSequence&lt;/code&gt; is less than or equal to zero, then an empty buffer of capacity &lt;code&gt;16&lt;/code&gt; is returned.</source>
          <target state="translated">如果指定的 &lt;code&gt;CharSequence&lt;/code&gt; 的长度小于或等于零，则返回容量为 &lt;code&gt;16&lt;/code&gt; 的空缓冲区。</target>
        </trans-unit>
        <trans-unit id="383b812813a9ca054e67e8d7ed50b33281ee93ba" translate="yes" xml:space="preserve">
          <source>If the line is not open and has never been opened, it returns the default format. The default format is an implementation specific audio format, or, if the &lt;code&gt;DataLine.Info&lt;/code&gt; object, which was used to retrieve this &lt;code&gt;DataLine&lt;/code&gt;, specifies at least one fully qualified audio format, the last one will be used as the default format. Opening the line with a specific audio format (e.g. &lt;a href=&quot;sourcedataline#open(javax.sound.sampled.AudioFormat)&quot;&gt;&lt;code&gt;SourceDataLine.open(AudioFormat)&lt;/code&gt;&lt;/a&gt;) will override the default format.</source>
          <target state="translated">如果该行未打开并且从未被打开过，它将返回默认格式。默认格式是特定于实现的音频格式，或者，如果用于检索此 &lt;code&gt;DataLine&lt;/code&gt; 的 &lt;code&gt;DataLine.Info&lt;/code&gt; 对象指定了至少一种完全限定的音频格式，则最后一种将用作默认格式。用特定的音频格式（例如&lt;a href=&quot;sourcedataline#open(javax.sound.sampled.AudioFormat)&quot;&gt; &lt;code&gt;SourceDataLine.open(AudioFormat)&lt;/code&gt; &lt;/a&gt;）打开行将覆盖默认格式。</target>
        </trans-unit>
        <trans-unit id="009a7b082a7f277c626ca216eb6dd0590efc9900" translate="yes" xml:space="preserve">
          <source>If the line is not open and has never been opened, it returns the default format. The default format is an implementation specific audio format, or, if the &lt;code&gt;DataLine.Info&lt;/code&gt; object, which was used to retrieve this &lt;code&gt;DataLine&lt;/code&gt;, specifies at least one fully qualified audio format, the last one will be used as the default format. Opening the line with a specific audio format (e.g. &lt;a href=&quot;sourcedataline#open-javax.sound.sampled.AudioFormat-&quot;&gt;&lt;code&gt;SourceDataLine.open(AudioFormat)&lt;/code&gt;&lt;/a&gt;) will override the default format.</source>
          <target state="translated">如果该行未打开且从未打开过，则返回默认格式。默认格式是特定于实现的音频格式，或者，如果用于检索此 &lt;code&gt;DataLine&lt;/code&gt; 的 &lt;code&gt;DataLine.Info&lt;/code&gt; 对象指定了至少一种完全限定的音频格式，则最后一种将用作默认格式。用特定的音频格式（例如&lt;a href=&quot;sourcedataline#open-javax.sound.sampled.AudioFormat-&quot;&gt; &lt;code&gt;SourceDataLine.open(AudioFormat)&lt;/code&gt; &lt;/a&gt;）打开行将覆盖默认格式。</target>
        </trans-unit>
        <trans-unit id="7863f26128f8bba0e665024d8f8516c082ac4867" translate="yes" xml:space="preserve">
          <source>If the list fits in the specified array with room to spare (i.e., the array has more elements than the list), the element in the array immediately following the end of the collection is set to &lt;code&gt;null&lt;/code&gt;. (This is useful in determining the length of the list</source>
          <target state="translated">如果列表适合指定的数组并有剩余空间（即，数组中的元素多于列表），则紧接集合结束后的数组中的元素设置为 &lt;code&gt;null&lt;/code&gt; 。（这对于确定列表的长度很有用</target>
        </trans-unit>
        <trans-unit id="9d2a9e6acfe01f48880cc127c76590e8af39df2a" translate="yes" xml:space="preserve">
          <source>If the list fits in the specified array with room to spare (i.e., the array has more elements than the list), the element in the array immediately following the end of the list is set to &lt;code&gt;null&lt;/code&gt;. (This is useful in determining the length of the list</source>
          <target state="translated">如果列表适合指定的数组并有剩余空间（即，数组中的元素多于列表），则紧接列表结尾的数组中的元素将设置为 &lt;code&gt;null&lt;/code&gt; 。（这对于确定列表的长度很有用</target>
        </trans-unit>
        <trans-unit id="e2a6a2c57017a029e9ebb7681d955085f7ded61a" translate="yes" xml:space="preserve">
          <source>If the list is an instance of &lt;a href=&quot;randomaccess&quot;&gt;&lt;code&gt;RandomAccess&lt;/code&gt;&lt;/a&gt; then the default implementation creates a spliterator that traverses elements by invoking the method &lt;a href=&quot;#get(int)&quot;&gt;&lt;code&gt;get(int)&lt;/code&gt;&lt;/a&gt;. If such invocation results or would result in an &lt;code&gt;IndexOutOfBoundsException&lt;/code&gt; then the spliterator will &lt;em&gt;fail-fast&lt;/em&gt; and throw a &lt;code&gt;ConcurrentModificationException&lt;/code&gt;. If the list is also an instance of &lt;a href=&quot;abstractlist&quot;&gt;&lt;code&gt;AbstractList&lt;/code&gt;&lt;/a&gt; then the spliterator will use the list's &lt;a href=&quot;abstractlist#modCount&quot;&gt;&lt;code&gt;modCount&lt;/code&gt;&lt;/a&gt; field to provide additional &lt;em&gt;fail-fast&lt;/em&gt; behavior.</source>
          <target state="translated">如果列表是&lt;a href=&quot;randomaccess&quot;&gt; &lt;code&gt;RandomAccess&lt;/code&gt; &lt;/a&gt;的实例，则默认实现将创建一个拆分器，该拆分器通过调用方法&lt;a href=&quot;#get(int)&quot;&gt; &lt;code&gt;get(int)&lt;/code&gt; &lt;/a&gt;来遍历元素。如果这样的调用导致或将导致 &lt;code&gt;IndexOutOfBoundsException&lt;/code&gt; ,则分隔器将&lt;em&gt;快速失败&lt;/em&gt;并抛出 &lt;code&gt;ConcurrentModificationException&lt;/code&gt; 。如果列表也是&lt;a href=&quot;abstractlist&quot;&gt; &lt;code&gt;AbstractList&lt;/code&gt; &lt;/a&gt;的实例，则分隔符将使用列表的&lt;a href=&quot;abstractlist#modCount&quot;&gt; &lt;code&gt;modCount&lt;/code&gt; &lt;/a&gt;字段提供其他&lt;em&gt;的快速失败&lt;/em&gt;行为。</target>
        </trans-unit>
        <trans-unit id="1b902068f08330a0362c3c251027edac230d4119" translate="yes" xml:space="preserve">
          <source>If the list of assistive technology providers as provided through system property &quot;&lt;code&gt;&lt;span id=&quot;javax.accessibility.assistive_technologies&quot;&gt;javax.accessibility.assistive_technologies&lt;/span&gt;&lt;/code&gt;&quot; is the empty string or contains only &lt;a href=&quot;../../../java.base/java/lang/character#isWhitespace(int)&quot;&gt;white space&lt;/a&gt; characters it is ignored. All other errors are handled via an AWTError exception.</source>
          <target state="translated">如果通过系统属性&amp;ldquo; &lt;code&gt;&lt;span id=&quot;javax.accessibility.assistive_technologies&quot;&gt;javax.accessibility.assistive_technologies&lt;/span&gt;&lt;/code&gt; &amp;rdquo;提供的辅助技术提供者列表为空字符串或仅包含&lt;a href=&quot;../../../java.base/java/lang/character#isWhitespace(int)&quot;&gt;空格&lt;/a&gt;字符，则将其忽略。所有其他错误都通过AWTError异常处理。</target>
        </trans-unit>
        <trans-unit id="1566f18ef0180d3aac88323daa9341914ba885e6" translate="yes" xml:space="preserve">
          <source>If the list's list-iterator does not support the &lt;code&gt;set&lt;/code&gt; operation then an &lt;code&gt;UnsupportedOperationException&lt;/code&gt; will be thrown when replacing the first element.</source>
          <target state="translated">如果列表的列表迭代器不支持 &lt;code&gt;set&lt;/code&gt; 操作，则替换第一个元素时将引发 &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4ae175c3216a75f24ee407fdf582572db3c498ef" translate="yes" xml:space="preserve">
          <source>If the listener is registered more than once, perhaps with different filters or callbacks, this method will remove all those registrations.</source>
          <target state="translated">如果监听器注册了不止一次,也许是用不同的过滤器或回调,这个方法将删除所有这些注册。</target>
        </trans-unit>
        <trans-unit id="54b665bbf8eb506dbbe12fdda9847f03e69a163c" translate="yes" xml:space="preserve">
          <source>If the literal is empty, nothing is added to the formatter.</source>
          <target state="translated">如果字面意思为空,则不会向格式器添加任何内容。</target>
        </trans-unit>
        <trans-unit id="5586e5fb737ecf0129eedcffc9670c2876a5d020" translate="yes" xml:space="preserve">
          <source>If the load average is not available, a negative value is returned.</source>
          <target state="translated">如果没有负载平均值,则返回负值。</target>
        </trans-unit>
        <trans-unit id="c80e112fdf053b8009f76cd046e1d1d1382fcec5" translate="yes" xml:space="preserve">
          <source>If the loaded KeyStore's provider extends &lt;code&gt;java.security.AuthProvider&lt;/code&gt;, then the provider's &lt;code&gt;logout&lt;/code&gt; method is invoked.</source>
          <target state="translated">如果加载的KeyStore的提供程序扩展了 &lt;code&gt;java.security.AuthProvider&lt;/code&gt; ，则将调用提供程序的 &lt;code&gt;logout&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="612e3af41a7467295225df330e80d3aa55f31393" translate="yes" xml:space="preserve">
          <source>If the loading of the content handler class would be performed by a classloader that is outside of the delegation chain of the caller, the JVM will need the RuntimePermission &quot;getClassLoader&quot;.</source>
          <target state="translated">如果内容处理程序类的加载将由调用者的委托链之外的classloader执行,JVM将需要RuntimePermission &quot;getClassLoader&quot;。</target>
        </trans-unit>
        <trans-unit id="1001411e7601e30ddd0e0c79cdc5159c320dbf60" translate="yes" xml:space="preserve">
          <source>If the local part is &lt;code&gt;null&lt;/code&gt; an &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown. A local part of &quot;&quot; is allowed to preserve compatible behavior with QName 1.0.</source>
          <target state="translated">如果本地部分为 &lt;code&gt;null&lt;/code&gt; ，则抛出 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 。允许&amp;ldquo;&amp;rdquo;的本地部分保留与QName 1.0兼容的行为。</target>
        </trans-unit>
        <trans-unit id="2a740773690bece4f01892057f26d0f5a3505d90" translate="yes" xml:space="preserve">
          <source>If the locale contains &quot;nu&quot; (numbers) and/or &quot;rg&quot; (region override) &lt;a href=&quot;../util/locale#def_locale_extension&quot;&gt;Unicode extensions&lt;/a&gt;, the decimal digits, and/or the country used for formatting are overridden. If both &quot;nu&quot; and &quot;rg&quot; are specified, the decimal digits from the &quot;nu&quot; extension supersedes the implicit one from the &quot;rg&quot; extension.</source>
          <target state="translated">如果语言环境包含&amp;ldquo; nu&amp;rdquo;（数字）和/或&amp;ldquo; rg&amp;rdquo;（区域覆盖）&lt;a href=&quot;../util/locale#def_locale_extension&quot;&gt;Unicode扩展名&lt;/a&gt;，则十进制数字和/或用于格式化的国家/地区将被覆盖。如果同时指定了&amp;ldquo; nu&amp;rdquo;和&amp;ldquo; rg&amp;rdquo;，则&amp;ldquo; nu&amp;rdquo;扩展名中的十进制数字将取代&amp;ldquo; rg&amp;rdquo;扩展名中的隐式数字。</target>
        </trans-unit>
        <trans-unit id="cfd944ef78cfcaae58d9f89252c3afdb5b581936" translate="yes" xml:space="preserve">
          <source>If the locale contains &quot;rg&quot; (region override) &lt;a href=&quot;../util/locale#def_locale_extension&quot;&gt;Unicode extension&lt;/a&gt;, the symbols are overridden for the designated region.</source>
          <target state="translated">如果语言环境包含&amp;ldquo; rg&amp;rdquo;（区域覆盖）&lt;a href=&quot;../util/locale#def_locale_extension&quot;&gt;Unicode扩展名&lt;/a&gt;，则将替换指定区域的符号。</target>
        </trans-unit>
        <trans-unit id="8dd82e30f2bfd2487deb48a3cd1ca525cc48b4ce" translate="yes" xml:space="preserve">
          <source>If the locale contains the &quot;rg&quot; (region override) &lt;a href=&quot;../../util/locale#def_locale_extension&quot;&gt;Unicode extensions&lt;/a&gt;, the formatting pattern is overridden with the one appropriate for the region.</source>
          <target state="translated">如果语言环境包含&amp;ldquo; rg&amp;rdquo;（区域覆盖）&lt;a href=&quot;../../util/locale#def_locale_extension&quot;&gt;Unicode扩展名&lt;/a&gt;，则格式化格式将被适合该区域的格式覆盖。</target>
        </trans-unit>
        <trans-unit id="5d4e75ab16c0169470cb2e36bf63130f893a3f1a" translate="yes" xml:space="preserve">
          <source>If the locale contains the time zone with &quot;tz&quot; &lt;a href=&quot;locale#def_locale_extension&quot;&gt;Unicode extension&lt;/a&gt;, and time zone hasn't been given explicitly, time zone in the locale is used.</source>
          <target state="translated">如果语言环境包含带有&amp;ldquo; tz&amp;rdquo; &lt;a href=&quot;locale#def_locale_extension&quot;&gt;Unicode扩展名的&lt;/a&gt;时区，并且未明确给出时区，则使用语言环境中的时区。</target>
        </trans-unit>
        <trans-unit id="13aecb53d0af72473665627440df7f59b9fad86f" translate="yes" xml:space="preserve">
          <source>If the locale contains the time zone with &quot;tz&quot; &lt;a href=&quot;locale#def_locale_extension&quot;&gt;Unicode extension&lt;/a&gt;, that time zone is used instead.</source>
          <target state="translated">如果语言环境包含带有&amp;ldquo; tz&amp;rdquo; &lt;a href=&quot;locale#def_locale_extension&quot;&gt;Unicode扩展名的&lt;/a&gt;时区，则改用该时区。</target>
        </trans-unit>
        <trans-unit id="fb7426e4160f2b1fe5d7220ffa07b99d6ba7024b" translate="yes" xml:space="preserve">
          <source>If the locale is exactly &lt;code&gt;Locale(&quot;no&quot;, &quot;NO&quot;, &quot;NY&quot;)&lt;/code&gt;, it is first converted to &lt;code&gt;Locale(&quot;nn&quot;, &quot;NO&quot;)&lt;/code&gt; and then the above procedure is followed.</source>
          <target state="translated">如果语言环境恰好是 &lt;code&gt;Locale(&quot;no&quot;, &quot;NO&quot;, &quot;NY&quot;)&lt;/code&gt; ，则首先将其转换为 &lt;code&gt;Locale(&quot;nn&quot;, &quot;NO&quot;)&lt;/code&gt; ，然后按照上述过程进行操作。</target>
        </trans-unit>
        <trans-unit id="c64c3966e3d4abb3a14f499628ce198c1164f906" translate="yes" xml:space="preserve">
          <source>If the lock is acquired by the current thread then the lock hold count is set to one.</source>
          <target state="translated">如果锁被当前线程获取,那么锁的持有数就会被设置为1。</target>
        </trans-unit>
        <trans-unit id="822233d82712d166731e9dcca011715ab8bbe1d8" translate="yes" xml:space="preserve">
          <source>If the lock is acquired then the value &lt;code&gt;true&lt;/code&gt; is returned and the lock hold count is set to one.</source>
          <target state="translated">如果获取了锁，则返回 &lt;code&gt;true&lt;/code&gt; 值，并将锁保持计数设置为1。</target>
        </trans-unit>
        <trans-unit id="243ddf2fd70f54733945fc92a2c6210895bc2219" translate="yes" xml:space="preserve">
          <source>If the lock is acquired then the value &lt;code&gt;true&lt;/code&gt; is returned.</source>
          <target state="translated">如果获取了锁，则返回值 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e267ec383786f22b490efc4cbeb5a239987b49eb" translate="yes" xml:space="preserve">
          <source>If the lock is available this method returns immediately with the value &lt;code&gt;true&lt;/code&gt;. If the lock is not available then the current thread becomes disabled for thread scheduling purposes and lies dormant until one of three things happens:</source>
          <target state="translated">如果锁可用，则此方法立即返回 &lt;code&gt;true&lt;/code&gt; 值。如果该锁不可用，则出于线程调度目的，当前线程将被禁用，并在发生以下三种情况之一之前处于休眠状态：</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
