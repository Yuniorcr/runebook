<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="openjdk">
    <body>
      <group id="openjdk">
        <trans-unit id="3b3629e1c7a434db3fa94e4624595c63c91c3763" translate="yes" xml:space="preserve">
          <source>If the lock is held by another thread then the current thread becomes disabled for thread scheduling purposes and lies dormant until one of three things happens:</source>
          <target state="translated">如果锁被另一个线程持有,那么当前线程就会因为线程调度的目的而被禁用,并处于休眠状态,直到三种情况之一发生。</target>
        </trans-unit>
        <trans-unit id="bc3fb57c41848bc377b297ddabc5e3ff9216fa1a" translate="yes" xml:space="preserve">
          <source>If the lock is held by another thread then the current thread becomes disabled for thread scheduling purposes and lies dormant until one of two things happens:</source>
          <target state="translated">如果锁被另一个线程持有,那么当前线程就会因为线程调度的目的而被禁用,并处于休眠状态,直到两种情况之一发生。</target>
        </trans-unit>
        <trans-unit id="9a8c566c06708381b95a076b6d0a7ff9c3dd5f9a" translate="yes" xml:space="preserve">
          <source>If the lock is held by another thread then the current thread becomes disabled for thread scheduling purposes and lies dormant until the lock has been acquired, at which time the lock hold count is set to one.</source>
          <target state="translated">如果锁被另一个线程持有,那么当前线程就会因为线程调度的目的而被禁用,并处于休眠状态,直到锁被获取,这时锁的持有数被设置为1。</target>
        </trans-unit>
        <trans-unit id="d853278a5b45d2ebee3420faecb6ce65095ece12" translate="yes" xml:space="preserve">
          <source>If the lock is held by another thread then the current thread becomes disabled for thread scheduling purposes and lies dormant until the write lock has been acquired, at which time the write lock hold count is set to one.</source>
          <target state="translated">如果锁被其他线程持有,那么出于线程调度的目的,当前线程就会被禁用,并处于休眠状态,直到获得写锁为止,此时写锁持有数被设置为1。</target>
        </trans-unit>
        <trans-unit id="918d784e15001f2097233989116a220695ba3605" translate="yes" xml:space="preserve">
          <source>If the lock is held by another thread then this method will return immediately with the value &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果锁由另一个线程持有，则此方法将立即返回 &lt;code&gt;false&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="85233bd93c41bf81d5bd16d44009dd4101f01d92" translate="yes" xml:space="preserve">
          <source>If the lock is not available then the current thread becomes disabled for thread scheduling purposes and lies dormant until one of two things happens:</source>
          <target state="translated">如果锁不可用,那么当前线程就会因为线程调度的目的而被禁用,并处于休眠状态,直到两种情况之一发生。</target>
        </trans-unit>
        <trans-unit id="2fcde55af63c37dc1d170326de90648dbad927ec" translate="yes" xml:space="preserve">
          <source>If the lock is not available then the current thread becomes disabled for thread scheduling purposes and lies dormant until the lock has been acquired.</source>
          <target state="translated">如果锁不可用,那么当前线程就会因为线程调度的目的而被禁用,并处于休眠状态,直到锁被获取。</target>
        </trans-unit>
        <trans-unit id="98452bdc04ba24a75162b80592faf24a66256700" translate="yes" xml:space="preserve">
          <source>If the lock state matches the given stamp then, atomically, if the stamp represents holding a lock, releases it and returns an observation stamp.</source>
          <target state="translated">如果锁的状态与给定的印记相匹配,那么,原子上,如果印记代表持有锁,则释放它并返回观察印记。</target>
        </trans-unit>
        <trans-unit id="9531444c267d5feba915ddbb6e8e98d082819147" translate="yes" xml:space="preserve">
          <source>If the lock state matches the given stamp then, atomically, if the stamp represents holding a lock, releases it and returns an observation stamp. Or, if an optimistic read, returns it if validated. This method returns zero in all other cases, and so may be useful as a form of &quot;tryUnlock&quot;.</source>
          <target state="translated">如果锁状态与给定的戳记相匹配,那么,原子上,如果戳记代表持有锁,则释放它,并返回观察戳记。或者,如果是乐观的读取,如果验证了,则返回它。在所有其他情况下,这个方法都返回零,因此可以作为 &quot;tryUnlock &quot;的一种形式。</target>
        </trans-unit>
        <trans-unit id="a09e194cce7b274be7295eeba5f7cce4ea171773" translate="yes" xml:space="preserve">
          <source>If the lock state matches the given stamp then, if the stamp represents holding a lock, releases it and returns an observation stamp. Or, if an optimistic read, returns it if validated. This method returns zero in all other cases, and so may be useful as a form of &quot;tryUnlock&quot;.</source>
          <target state="translated">如果锁状态与给定的戳记相匹配,那么,如果戳记代表持有锁,则释放它,并返回观察戳记。或者,如果是乐观的读取,如果验证了就返回。在所有其他情况下,该方法返回零,因此可能作为 &quot;tryUnlock &quot;的一种形式。</target>
        </trans-unit>
        <trans-unit id="c02dbead9b54aba8193788d721d9f35fe265e8ac" translate="yes" xml:space="preserve">
          <source>If the lock state matches the given stamp, atomically performs one of the following actions.</source>
          <target state="translated">如果锁状态与给定的印记相匹配,则原子地执行以下操作之一。</target>
        </trans-unit>
        <trans-unit id="c68f8e544ee0dc6483d80e98a4e234377462da50" translate="yes" xml:space="preserve">
          <source>If the lock state matches the given stamp, atomically performs one of the following actions. If the stamp represents holding a write lock, releases it and obtains a read lock. Or, if a read lock, returns it. Or, if an optimistic read, acquires a read lock and returns a read stamp only if immediately available. This method returns zero in all other cases.</source>
          <target state="translated">如果锁的状态与给定的印记相匹配,则原子地执行以下操作之一:如果印记代表持有写锁,则释放它并获得读锁。如果印章代表持有一个写锁,则释放它,获得一个读锁。或者,如果是读锁,则返回它。或者,如果是乐观的读,则获取一个读锁,并只在立即可用的情况下返回一个读印章。其他情况下,本方法返回零。</target>
        </trans-unit>
        <trans-unit id="a4406ed634a16a7a2fc6a312ac7fcd3088591c18" translate="yes" xml:space="preserve">
          <source>If the lock state matches the given stamp, atomically performs one of the following actions. If the stamp represents holding a write lock, returns it. Or, if a read lock, if the write lock is available, releases the read lock and returns a write stamp. Or, if an optimistic read, returns a write stamp only if immediately available. This method returns zero in all other cases.</source>
          <target state="translated">如果锁的状态与给定的邮票相匹配,则原子地执行以下操作之一。如果印章代表持有一个写锁,则返回它。或者,如果是读锁,如果写锁可用,则释放读锁并返回写戳。或者,如果是乐观读,只有在立即可用的情况下才返回一个写戳。其他情况下,本方法返回零。</target>
        </trans-unit>
        <trans-unit id="eefa68914d354c4eea9a7f9d2e87edb5b5d3616c" translate="yes" xml:space="preserve">
          <source>If the lock state matches the given stamp, performs one of the following actions. If the stamp represents holding a write lock, releases it and obtains a read lock. Or, if a read lock, returns it. Or, if an optimistic read, acquires a read lock and returns a read stamp only if immediately available. This method returns zero in all other cases.</source>
          <target state="translated">如果锁的状态与给定的印记相匹配,则执行以下操作之一:如果印记代表持有一个写锁,则释放它并获得读锁。如果印记代表持有一个写锁,则释放它并获得一个读锁。或者,如果是读锁,则返回它。或者,如果是乐观的读,则获取一个读锁,只有在立即可用的情况下才返回一个读印章。其他情况下,本方法返回零。</target>
        </trans-unit>
        <trans-unit id="3fe6cd5b7f1314dfe53912057e75419a458d6c46" translate="yes" xml:space="preserve">
          <source>If the lock state matches the given stamp, performs one of the following actions. If the stamp represents holding a write lock, returns it. Or, if a read lock, if the write lock is available, releases the read lock and returns a write stamp. Or, if an optimistic read, returns a write stamp only if immediately available. This method returns zero in all other cases.</source>
          <target state="translated">如果锁的状态与给定的印章相匹配,则执行以下操作之一。如果印章代表持有一个写锁,则返回它。或者,如果是读锁,如果写锁可用,则释放读锁并返回写戳。或者,如果是乐观读,只有在立即可用的情况下才返回一个写戳。其他情况下,本方法返回零。</target>
        </trans-unit>
        <trans-unit id="14a53c83eff403dc5c623bd9e147872ed3ff94fc" translate="yes" xml:space="preserve">
          <source>If the lock state matches the given stamp, releases the corresponding mode of the lock.</source>
          <target state="translated">如果锁的状态符合给定的印章,则释放锁的相应模式。</target>
        </trans-unit>
        <trans-unit id="3114f1897355cfbc96b7a2b2a9909376a9675347" translate="yes" xml:space="preserve">
          <source>If the lock state matches the given stamp, releases the exclusive lock.</source>
          <target state="translated">如果锁的状态符合给定的印记,则释放专属锁。</target>
        </trans-unit>
        <trans-unit id="4a3ebac76180e9eaa8e069fe7a9c0cce392315b8" translate="yes" xml:space="preserve">
          <source>If the lock state matches the given stamp, releases the non-exclusive lock.</source>
          <target state="translated">如果锁的状态符合给定的印章,则释放非独占锁。</target>
        </trans-unit>
        <trans-unit id="e004c7523986b5ecc4e1749a86febcd1a6784511" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the CONFIG message level then the given message is forwarded to all the registered output Handler objects.</source>
          <target state="translated">如果记录仪当前启用了 CONFIG 消息级别,那么给定的消息将转发到所有注册的输出处理程序对象。</target>
        </trans-unit>
        <trans-unit id="2480ae012f96dc55272b45f972094f52d29f7772" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the CONFIG message level then the message is constructed by invoking the provided supplier function and forwarded to all the registered output Handler objects.</source>
          <target state="translated">如果记录仪当前启用了 CONFIG 消息级别,那么将通过调用提供的供应商函数来构建消息,并将其转发给所有注册的输出处理程序对象。</target>
        </trans-unit>
        <trans-unit id="f74f4184b1114d21694c20083bffeca6773ddbdc" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the FINE message level then the given message is forwarded to all the registered output Handler objects.</source>
          <target state="translated">如果记录仪当前启用了 FINE 消息级别,那么给定的消息将被转发给所有注册的输出处理程序对象。</target>
        </trans-unit>
        <trans-unit id="ef129fafed8fea9b1b19398062aeaf0403caccda" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the FINE message level then the message is constructed by invoking the provided supplier function and forwarded to all the registered output Handler objects.</source>
          <target state="translated">如果记录仪当前启用了FINE消息级别,那么消息将通过调用提供的供应商函数来构建,并转发给所有注册的输出处理程序对象。</target>
        </trans-unit>
        <trans-unit id="5c488b5e8261b0b9f6a94d2c335e06b774d3e4c2" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the FINER message level then the given message is forwarded to all the registered output Handler objects.</source>
          <target state="translated">如果记录仪当前启用了FINER消息级别,那么给定的消息将转发到所有注册的输出处理程序对象。</target>
        </trans-unit>
        <trans-unit id="400e0c53967d73d6073541aa2955ecfaedacc619" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the FINER message level then the message is constructed by invoking the provided supplier function and forwarded to all the registered output Handler objects.</source>
          <target state="translated">如果记录器当前启用了FINER消息级别,那么消息将通过调用提供的供应商函数来构建,并转发给所有注册的输出处理程序对象。</target>
        </trans-unit>
        <trans-unit id="c08c72ddfcb02350456ab868e8db332930e255e4" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the FINEST message level then the given message is forwarded to all the registered output Handler objects.</source>
          <target state="translated">如果记录仪当前启用了FINEST消息级别,那么给定的消息将被转发给所有注册的输出处理程序对象。</target>
        </trans-unit>
        <trans-unit id="776e22483061c922dbf981169c45b199faadcb6b" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the FINEST message level then the message is constructed by invoking the provided supplier function and forwarded to all the registered output Handler objects.</source>
          <target state="translated">如果记录仪当前启用了FINEST消息级别,那么将通过调用提供的供应商函数来构建消息,并将其转发给所有注册的输出处理程序对象。</target>
        </trans-unit>
        <trans-unit id="0c3de4bfb7369cf5faf7dd1122bdabc955fddf2e" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the INFO message level then the given message is forwarded to all the registered output Handler objects.</source>
          <target state="translated">如果记录仪当前启用了 INFO 消息级别,那么给定的消息将转发到所有注册的输出处理程序对象。</target>
        </trans-unit>
        <trans-unit id="b7c2334c2c90239d4c59ec8c7a0e4b1e0b78f35b" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the INFO message level then the message is constructed by invoking the provided supplier function and forwarded to all the registered output Handler objects.</source>
          <target state="translated">如果记录仪当前启用了 INFO 消息级别,那么将通过调用提供的供应商函数来构建消息,并将其转发给所有注册的输出处理程序对象。</target>
        </trans-unit>
        <trans-unit id="ab7e0ed2e38d83c57cfc908b346ba953ba01ea6e" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the SEVERE message level then the given message is forwarded to all the registered output Handler objects.</source>
          <target state="translated">如果记录仪当前启用了SEVERE消息级别,则给定消息将转发到所有注册的输出处理程序对象。</target>
        </trans-unit>
        <trans-unit id="8e167659c676fd6a76d1a8ff361acf900cf2dee4" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the SEVERE message level then the message is constructed by invoking the provided supplier function and forwarded to all the registered output Handler objects.</source>
          <target state="translated">如果记录仪当前启用了SEVERE消息级别,那么将通过调用提供的供应商函数来构建消息,并将其转发给所有注册的输出处理程序对象。</target>
        </trans-unit>
        <trans-unit id="700de6b174ae4293a822d7062908049e15243b9c" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the WARNING message level then the given message is forwarded to all the registered output Handler objects.</source>
          <target state="translated">如果记录仪当前启用了警告消息级别,那么给定的消息将转发给所有注册的输出处理程序对象。</target>
        </trans-unit>
        <trans-unit id="8548b61ec8126b5ee81ca57df60b3e51531c5a8a" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the WARNING message level then the message is constructed by invoking the provided supplier function and forwarded to all the registered output Handler objects.</source>
          <target state="translated">如果记录仪当前启用了警告消息级别,那么将通过调用提供的供应商函数来构建消息,并将其转发给所有注册的输出处理程序对象。</target>
        </trans-unit>
        <trans-unit id="5a707ce3f0ebdced7855946db27b8b7e46bf0539" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the given message &lt;code&gt;level&lt;/code&gt; then a corresponding &lt;code&gt;LogRecord&lt;/code&gt; is created and forwarded to all the registered output &lt;code&gt;Handler&lt;/code&gt; objects.</source>
          <target state="translated">如果当前为给定消息 &lt;code&gt;level&lt;/code&gt; 启用了记录器，则将创建相应的 &lt;code&gt;LogRecord&lt;/code&gt; 并将其转发到所有已注册的输出 &lt;code&gt;Handler&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="b378f215976c2e18ee9b57b56cfaa682e43ca7e1" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the given message &lt;code&gt;level&lt;/code&gt; then the given arguments are stored in a &lt;code&gt;LogRecord&lt;/code&gt; which is forwarded to all registered output handlers.</source>
          <target state="translated">如果当前为给定的消息 &lt;code&gt;level&lt;/code&gt; 启用了记录器，则给定的参数将存储在 &lt;code&gt;LogRecord&lt;/code&gt; 中，该记录将转发到所有已注册的输出处理程序。</target>
        </trans-unit>
        <trans-unit id="2998fe288d20db38f6f02724d9a3e1e03f44693c" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the given message level then a corresponding LogRecord is created and forwarded to all the registered output Handler objects.</source>
          <target state="translated">如果当前为给定的消息级别启用了日志记录器,那么就会创建一个相应的日志记录,并转发给所有注册的输出处理对象。</target>
        </trans-unit>
        <trans-unit id="5672874e662c52b70bec899dedf5a6f7d4107f79" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the given message level then the given arguments are stored in a LogRecord which is forwarded to all registered output handlers.</source>
          <target state="translated">如果当前给定消息级别的日志记录器处于启用状态,那么给定参数将存储在日志记录中,该记录将转发给所有注册的输出处理程序。</target>
        </trans-unit>
        <trans-unit id="0a20e1ab3ef4c4dda5575d5b6fbf96f00af911a8" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the given message level then the given arguments are stored in a LogRecord which is forwarded to all registered output handlers. The LogRecord's message is set to &quot;THROW&quot;.</source>
          <target state="translated">如果记录仪当前已为给定的消息级别启用,那么给定的参数将存储在日志记录中,该记录将转发给所有注册的输出处理程序。日志记录的消息被设置为 &quot;THROW&quot;。</target>
        </trans-unit>
        <trans-unit id="325dfec7a72934c84f66843540d89c8f3769035b" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the given message level then the given message is forwarded to all the registered output Handler objects.</source>
          <target state="translated">如果当前给定消息级别的记录器处于启用状态,那么给定消息将转发到所有注册的输出处理程序对象。</target>
        </trans-unit>
        <trans-unit id="09b15fa7220dfe741c8baffb5087e302fb89c908" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the given message level then the message is constructed by invoking the provided supplier function and forwarded to all the registered output Handler objects.</source>
          <target state="translated">如果当前给定消息级别的记录器已启用,则通过调用提供的供应商函数来构造消息,并将其转发给所有注册的输出处理程序对象。</target>
        </trans-unit>
        <trans-unit id="c33be9e7edb44141d7868af8327eb0567ce6ec4f" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the given message level then the message is constructed by invoking the provided supplier function. The message and the given &lt;a href=&quot;../../../../java.base/java/lang/throwable&quot;&gt;&lt;code&gt;Throwable&lt;/code&gt;&lt;/a&gt; are then stored in a &lt;a href=&quot;logrecord&quot;&gt;&lt;code&gt;LogRecord&lt;/code&gt;&lt;/a&gt; which is forwarded to all registered output handlers.</source>
          <target state="translated">如果当前为给定消息级别启用了记录器，则通过调用提供的供应商功能来构造消息。消息和给定的&lt;a href=&quot;../../../../java.base/java/lang/throwable&quot;&gt; &lt;code&gt;Throwable&lt;/code&gt; &lt;/a&gt;然后存储在&lt;a href=&quot;logrecord&quot;&gt; &lt;code&gt;LogRecord&lt;/code&gt; 中&lt;/a&gt;，该记录转发到所有已注册的输出处理程序。</target>
        </trans-unit>
        <trans-unit id="72eff8884364ee54a875323cb549fca604cb4b7b" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the given message level then the message is constructed by invoking the provided supplier function. The message and the given &lt;a href=&quot;../../lang/throwable&quot;&gt;&lt;code&gt;Throwable&lt;/code&gt;&lt;/a&gt; are then stored in a &lt;a href=&quot;logrecord&quot;&gt;&lt;code&gt;LogRecord&lt;/code&gt;&lt;/a&gt; which is forwarded to all registered output handlers.</source>
          <target state="translated">如果当前为给定消息级别启用了记录器，则可以通过调用提供的供应商功能来构造消息。消息和给定的&lt;a href=&quot;../../lang/throwable&quot;&gt; &lt;code&gt;Throwable&lt;/code&gt; &lt;/a&gt;然后存储在&lt;a href=&quot;logrecord&quot;&gt; &lt;code&gt;LogRecord&lt;/code&gt; 中&lt;/a&gt;，该记录转发到所有注册的输出处理程序。</target>
        </trans-unit>
        <trans-unit id="bb1c400f82a20624d25957d22a9309735bd25ad8" translate="yes" xml:space="preserve">
          <source>If the looked-up method has a &lt;a href=&quot;methodhandle#maxarity&quot;&gt;very large arity&lt;/a&gt;, the method handle creation may fail with an &lt;code&gt;IllegalArgumentException&lt;/code&gt;, due to the method handle type having &lt;a href=&quot;methodhandle#maxarity&quot;&gt;too many parameters.&lt;/a&gt;</source>
          <target state="translated">如果查找的方法具有&lt;a href=&quot;methodhandle#maxarity&quot;&gt;很大的Arity&lt;/a&gt;，则由于方法句柄类型具有&lt;a href=&quot;methodhandle#maxarity&quot;&gt;太多参数&lt;/a&gt;，因此方法句柄的创建可能会失败，并 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="df68511496b32d8949f42994423a12d97c5a37a3" translate="yes" xml:space="preserve">
          <source>If the looked-up method has a &lt;a href=&quot;methodhandle#maxarity&quot;&gt;very large arity&lt;/a&gt;, the method handle creation may fail, due to the method handle type having too many parameters.</source>
          <target state="translated">如果查找的方法具有&lt;a href=&quot;methodhandle#maxarity&quot;&gt;很大的Arity&lt;/a&gt;，则由于方法句柄类型的参数过多，因此可能无法创建方法句柄。</target>
        </trans-unit>
        <trans-unit id="d5a1d5c49aae5cb26d9965efa2b543eb65306a01" translate="yes" xml:space="preserve">
          <source>If the magnitude is zero, it is represented by a single zero character &lt;code&gt;'0'&lt;/code&gt; (&lt;code&gt;'\u0030'&lt;/code&gt;); otherwise, the first character of the representation of the magnitude will not be the zero character.</source>
          <target state="translated">如果大小为零，则用单个零字符 &lt;code&gt;'0'&lt;/code&gt; （ &lt;code&gt;'\u0030'&lt;/code&gt; ）表示；否则，表示幅度的第一个字符将不是零字符。</target>
        </trans-unit>
        <trans-unit id="e2b282ebf7062ed0ca134866fb50f5fe7dd48ced" translate="yes" xml:space="preserve">
          <source>If the main task must later await termination, it may re-register and then execute a similar loop:</source>
          <target state="translated">如果主任务以后必须等待终止,它可以重新注册,然后执行一个类似的循环。</target>
        </trans-unit>
        <trans-unit id="531cc08b857c4e56e257070320ab4f3d2accadae" translate="yes" xml:space="preserve">
          <source>If the mapped keys contain duplicates (according to &lt;a href=&quot;../../lang/object#equals(java.lang.Object)&quot;&gt;&lt;code&gt;Object.equals(Object)&lt;/code&gt;&lt;/a&gt;), an &lt;code&gt;IllegalStateException&lt;/code&gt; is thrown when the collection operation is performed. If the mapped keys may have duplicates, use &lt;a href=&quot;#toConcurrentMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator)&quot;&gt;&lt;code&gt;toConcurrentMap(Function, Function, BinaryOperator)&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">如果映射的键包含重复项（根据&lt;a href=&quot;../../lang/object#equals(java.lang.Object)&quot;&gt; &lt;code&gt;Object.equals(Object)&lt;/code&gt; &lt;/a&gt;），则在执行收集操作时将抛出 &lt;code&gt;IllegalStateException&lt;/code&gt; 。如果映射的键可能有重复，请改用&lt;a href=&quot;#toConcurrentMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator)&quot;&gt; &lt;code&gt;toConcurrentMap(Function, Function, BinaryOperator)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="088f14da8d2c154179e131d3ed238aa448ab02fb" translate="yes" xml:space="preserve">
          <source>If the mapped keys contain duplicates (according to &lt;a href=&quot;../../lang/object#equals(java.lang.Object)&quot;&gt;&lt;code&gt;Object.equals(Object)&lt;/code&gt;&lt;/a&gt;), an &lt;code&gt;IllegalStateException&lt;/code&gt; is thrown when the collection operation is performed. If the mapped keys might have duplicates, use &lt;a href=&quot;#toMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator)&quot;&gt;&lt;code&gt;toMap(Function, Function, BinaryOperator)&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">如果映射的键包含重复项（根据&lt;a href=&quot;../../lang/object#equals(java.lang.Object)&quot;&gt; &lt;code&gt;Object.equals(Object)&lt;/code&gt; &lt;/a&gt;），则在执行收集操作时将抛出 &lt;code&gt;IllegalStateException&lt;/code&gt; 。如果映射的键可能有重复，请改用&lt;a href=&quot;#toMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator)&quot;&gt; &lt;code&gt;toMap(Function, Function, BinaryOperator)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a291cf6a416b3035d499691d19d66c91e9db3e1a" translate="yes" xml:space="preserve">
          <source>If the mapped keys contain duplicates (according to &lt;a href=&quot;../../lang/object#equals(java.lang.Object)&quot;&gt;&lt;code&gt;Object.equals(Object)&lt;/code&gt;&lt;/a&gt;), an &lt;code&gt;IllegalStateException&lt;/code&gt; is thrown when the collection operation is performed. If the mapped keys might have duplicates, use &lt;a href=&quot;#toUnmodifiableMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator)&quot;&gt;&lt;code&gt;toUnmodifiableMap(Function, Function, BinaryOperator)&lt;/code&gt;&lt;/a&gt; to handle merging of the values.</source>
          <target state="translated">如果映射的键包含重复项（根据&lt;a href=&quot;../../lang/object#equals(java.lang.Object)&quot;&gt; &lt;code&gt;Object.equals(Object)&lt;/code&gt; &lt;/a&gt;），则在执行收集操作时将抛出 &lt;code&gt;IllegalStateException&lt;/code&gt; 。如果映射的键可能有重复，请使用&lt;a href=&quot;#toUnmodifiableMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator)&quot;&gt; &lt;code&gt;toUnmodifiableMap(Function, Function, BinaryOperator)&lt;/code&gt; &lt;/a&gt;处理值的合并。</target>
        </trans-unit>
        <trans-unit id="b1373a2f67fea002749155a531d7ee46df51febf" translate="yes" xml:space="preserve">
          <source>If the mapped keys contain duplicates (according to &lt;a href=&quot;../../lang/object#equals(java.lang.Object)&quot;&gt;&lt;code&gt;Object.equals(Object)&lt;/code&gt;&lt;/a&gt;), the value mapping function is applied to each equal element, and the results are merged using the provided merging function.</source>
          <target state="translated">如果映射的键包含重复项（根据&lt;a href=&quot;../../lang/object#equals(java.lang.Object)&quot;&gt; &lt;code&gt;Object.equals(Object)&lt;/code&gt; &lt;/a&gt;），则将值映射函数应用于每个equal元素，然后使用提供的合并函数合并结果。</target>
        </trans-unit>
        <trans-unit id="d6ebb09d651c50d7a498fdb18d45eddf7b8ceeeb" translate="yes" xml:space="preserve">
          <source>If the mapped keys contain duplicates (according to &lt;a href=&quot;../../lang/object#equals(java.lang.Object)&quot;&gt;&lt;code&gt;Object.equals(Object)&lt;/code&gt;&lt;/a&gt;), the value mapping function is applied to each equal element, and the results are merged using the provided merging function. The &lt;code&gt;ConcurrentMap&lt;/code&gt; is created by a provided supplier function.</source>
          <target state="translated">如果映射的键包含重复项（根据&lt;a href=&quot;../../lang/object#equals(java.lang.Object)&quot;&gt; &lt;code&gt;Object.equals(Object)&lt;/code&gt; &lt;/a&gt;），则将值映射函数应用于每个equal元素，然后使用提供的合并函数合并结果。该 &lt;code&gt;ConcurrentMap&lt;/code&gt; 是由供应商提供的函数创建。</target>
        </trans-unit>
        <trans-unit id="2e75e6f9c272bcc58cd0a4bb014e176c452d721a" translate="yes" xml:space="preserve">
          <source>If the mapped keys contain duplicates (according to &lt;a href=&quot;../../lang/object#equals(java.lang.Object)&quot;&gt;&lt;code&gt;Object.equals(Object)&lt;/code&gt;&lt;/a&gt;), the value mapping function is applied to each equal element, and the results are merged using the provided merging function. The &lt;code&gt;Map&lt;/code&gt; is created by a provided supplier function.</source>
          <target state="translated">如果映射的键包含重复项（根据&lt;a href=&quot;../../lang/object#equals(java.lang.Object)&quot;&gt; &lt;code&gt;Object.equals(Object)&lt;/code&gt; &lt;/a&gt;），则将值映射函数应用于每个equal元素，然后使用提供的合并函数合并结果。该 &lt;code&gt;Map&lt;/code&gt; 由提供的供应商功能创建。</target>
        </trans-unit>
        <trans-unit id="91601953e386bbcbf0a6b2f49eca2d05544c99f8" translate="yes" xml:space="preserve">
          <source>If the mapped keys contains duplicates (according to &lt;a href=&quot;../../lang/object#equals-java.lang.Object-&quot;&gt;&lt;code&gt;Object.equals(Object)&lt;/code&gt;&lt;/a&gt;), an &lt;code&gt;IllegalStateException&lt;/code&gt; is thrown when the collection operation is performed. If the mapped keys may have duplicates, use &lt;a href=&quot;collectors#toConcurrentMap-java.util.function.Function-java.util.function.Function-java.util.function.BinaryOperator-&quot;&gt;&lt;code&gt;toConcurrentMap(Function, Function, BinaryOperator)&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">如果映射的键包含重复项（根据&lt;a href=&quot;../../lang/object#equals-java.lang.Object-&quot;&gt; &lt;code&gt;Object.equals(Object)&lt;/code&gt; &lt;/a&gt;），则在执行收集操作时将抛出 &lt;code&gt;IllegalStateException&lt;/code&gt; 。如果映射的键可能有重复，请改用&lt;a href=&quot;collectors#toConcurrentMap-java.util.function.Function-java.util.function.Function-java.util.function.BinaryOperator-&quot;&gt; &lt;code&gt;toConcurrentMap(Function, Function, BinaryOperator)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="42bc70fbf81ca2e8ef91fd72811c9886f9c29e43" translate="yes" xml:space="preserve">
          <source>If the mapped keys contains duplicates (according to &lt;a href=&quot;../../lang/object#equals-java.lang.Object-&quot;&gt;&lt;code&gt;Object.equals(Object)&lt;/code&gt;&lt;/a&gt;), an &lt;code&gt;IllegalStateException&lt;/code&gt; is thrown when the collection operation is performed. If the mapped keys may have duplicates, use &lt;a href=&quot;collectors#toMap-java.util.function.Function-java.util.function.Function-java.util.function.BinaryOperator-&quot;&gt;&lt;code&gt;toMap(Function, Function, BinaryOperator)&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">如果映射的键包含重复项（根据&lt;a href=&quot;../../lang/object#equals-java.lang.Object-&quot;&gt; &lt;code&gt;Object.equals(Object)&lt;/code&gt; &lt;/a&gt;），则在执行收集操作时将抛出 &lt;code&gt;IllegalStateException&lt;/code&gt; 。如果映射的键可能有重复，请改用&lt;a href=&quot;collectors#toMap-java.util.function.Function-java.util.function.Function-java.util.function.BinaryOperator-&quot;&gt; &lt;code&gt;toMap(Function, Function, BinaryOperator)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ebd1a935a059b20128bc5042763d4c45de22fb0b" translate="yes" xml:space="preserve">
          <source>If the mapped keys contains duplicates (according to &lt;a href=&quot;../../lang/object#equals-java.lang.Object-&quot;&gt;&lt;code&gt;Object.equals(Object)&lt;/code&gt;&lt;/a&gt;), the value mapping function is applied to each equal element, and the results are merged using the provided merging function.</source>
          <target state="translated">如果映射的键包含重复项（根据&lt;a href=&quot;../../lang/object#equals-java.lang.Object-&quot;&gt; &lt;code&gt;Object.equals(Object)&lt;/code&gt; &lt;/a&gt;），则将值映射函数应用于每个equal元素，然后使用提供的合并函数合并结果。</target>
        </trans-unit>
        <trans-unit id="0ab1f12a020b33fa5cdaa6c8e92a327756ecc141" translate="yes" xml:space="preserve">
          <source>If the mapped keys contains duplicates (according to &lt;a href=&quot;../../lang/object#equals-java.lang.Object-&quot;&gt;&lt;code&gt;Object.equals(Object)&lt;/code&gt;&lt;/a&gt;), the value mapping function is applied to each equal element, and the results are merged using the provided merging function. The &lt;code&gt;ConcurrentMap&lt;/code&gt; is created by a provided supplier function.</source>
          <target state="translated">如果映射的键包含重复项（根据&lt;a href=&quot;../../lang/object#equals-java.lang.Object-&quot;&gt; &lt;code&gt;Object.equals(Object)&lt;/code&gt; &lt;/a&gt;），则将值映射函数应用于每个equal元素，然后使用提供的合并函数合并结果。该 &lt;code&gt;ConcurrentMap&lt;/code&gt; 是由供应商提供的函数创建。</target>
        </trans-unit>
        <trans-unit id="5d55abd598d0098b46d878c1a82407a1edf09085" translate="yes" xml:space="preserve">
          <source>If the mapped keys contains duplicates (according to &lt;a href=&quot;../../lang/object#equals-java.lang.Object-&quot;&gt;&lt;code&gt;Object.equals(Object)&lt;/code&gt;&lt;/a&gt;), the value mapping function is applied to each equal element, and the results are merged using the provided merging function. The &lt;code&gt;Map&lt;/code&gt; is created by a provided supplier function.</source>
          <target state="translated">如果映射的键包含重复项（根据&lt;a href=&quot;../../lang/object#equals-java.lang.Object-&quot;&gt; &lt;code&gt;Object.equals(Object)&lt;/code&gt; &lt;/a&gt;），则将值映射函数应用于每个equal元素，然后使用提供的合并函数合并结果。该 &lt;code&gt;Map&lt;/code&gt; 由提供的供应商功能创建。</target>
        </trans-unit>
        <trans-unit id="6776bff4be9d5889c77b053d4d78e203a02dda2b" translate="yes" xml:space="preserve">
          <source>If the mapping function returns &lt;code&gt;null&lt;/code&gt;, no mapping is recorded. If the mapping function itself throws an (unchecked) exception, the exception is rethrown, and no mapping is recorded. The most common usage is to construct a new object serving as an initial mapped value or memoized result, as in:</source>
          <target state="translated">如果映射函数返回 &lt;code&gt;null&lt;/code&gt; ，则不会记录任何映射。如果映射函数本身抛出（未经检查的）异常，则该异常将被重新抛出，并且不会记录任何映射。最常见的用法是构造一个新对象，用作初始映射值或备注结果，如下所示：</target>
        </trans-unit>
        <trans-unit id="cb025d3bf5eb9ce361d77c9eec5cc70908428bf7" translate="yes" xml:space="preserve">
          <source>If the mapping function returns a &lt;code&gt;null&lt;/code&gt; result then this method returns an empty &lt;code&gt;Optional&lt;/code&gt;.</source>
          <target state="translated">如果映射函数返回 &lt;code&gt;null&lt;/code&gt; 结果，则此方法返回空的 &lt;code&gt;Optional&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="12d75596707c6333177ca57803e56fd8714ec021" translate="yes" xml:space="preserve">
          <source>If the match succeeds then more information can be obtained via the &lt;code&gt;start&lt;/code&gt;, &lt;code&gt;end&lt;/code&gt;, and &lt;code&gt;group&lt;/code&gt; methods, and subsequent invocations of the &lt;a href=&quot;#find()&quot;&gt;&lt;code&gt;find()&lt;/code&gt;&lt;/a&gt; method will start at the first character not matched by this match.</source>
          <target state="translated">如果匹配成功，则可以通过 &lt;code&gt;start&lt;/code&gt; ， &lt;code&gt;end&lt;/code&gt; 和 &lt;code&gt;group&lt;/code&gt; 方法获取更多信息，并且&lt;a href=&quot;#find()&quot;&gt; &lt;code&gt;find()&lt;/code&gt; &lt;/a&gt;方法的后续调用将从与该匹配不匹配的第一个字符开始。</target>
        </trans-unit>
        <trans-unit id="38fcc3a9324656c7f62d52adcd0bcdf26f23941f" translate="yes" xml:space="preserve">
          <source>If the match succeeds then more information can be obtained via the &lt;code&gt;start&lt;/code&gt;, &lt;code&gt;end&lt;/code&gt;, and &lt;code&gt;group&lt;/code&gt; methods, and subsequent invocations of the &lt;a href=&quot;matcher#find--&quot;&gt;&lt;code&gt;find()&lt;/code&gt;&lt;/a&gt; method will start at the first character not matched by this match.</source>
          <target state="translated">如果匹配成功，则可以通过 &lt;code&gt;start&lt;/code&gt; ， &lt;code&gt;end&lt;/code&gt; 和 &lt;code&gt;group&lt;/code&gt; 方法获取更多信息，并且&lt;a href=&quot;matcher#find--&quot;&gt; &lt;code&gt;find()&lt;/code&gt; &lt;/a&gt;方法的后续调用将从与该匹配不匹配的第一个字符开始。</target>
        </trans-unit>
        <trans-unit id="e45d30a935b4cf0dbcaf8698457f96e2ee71e0db" translate="yes" xml:space="preserve">
          <source>If the match succeeds then more information can be obtained via the &lt;code&gt;start&lt;/code&gt;, &lt;code&gt;end&lt;/code&gt;, and &lt;code&gt;group&lt;/code&gt; methods.</source>
          <target state="translated">如果匹配成功，则可以通过 &lt;code&gt;start&lt;/code&gt; ， &lt;code&gt;end&lt;/code&gt; 和 &lt;code&gt;group&lt;/code&gt; 方法获取更多信息。</target>
        </trans-unit>
        <trans-unit id="4646f11996bf69cea5464367c1335e753c401c2e" translate="yes" xml:space="preserve">
          <source>If the match was successful but the group specified failed to match any part of the input sequence, then &lt;code&gt;null&lt;/code&gt; is returned. Note that some groups, for example &lt;code&gt;(a*)&lt;/code&gt;, match the empty string. This method will return the empty string when such a group successfully matches the empty string in the input.</source>
          <target state="translated">如果匹配成功，但是指定的组与输入序列的任何部分都不匹配，则返回 &lt;code&gt;null&lt;/code&gt; 。请注意，某些组（例如 &lt;code&gt;(a*)&lt;/code&gt; 匹配空字符串。当这样的组成功匹配输入中的空字符串时，此方法将返回空字符串。</target>
        </trans-unit>
        <trans-unit id="7978619400e787b4fa09d19e22379298e6ddd77a" translate="yes" xml:space="preserve">
          <source>If the matcher is to be used for further matching operations after the terminal stream operation completes then it should be first reset.</source>
          <target state="translated">如果在终端流操作完成后,匹配器要用于进一步的匹配操作,那么应该先将其复位。</target>
        </trans-unit>
        <trans-unit id="e27c63987af47673a3557d130f21afb577235397" translate="yes" xml:space="preserve">
          <source>If the maximum number of integer digits is greater than their minimum number and greater than 1, it forces the exponent to be a multiple of the maximum number of integer digits, and the minimum number of integer digits to be interpreted as 1. The most common use of this is to generate &lt;em&gt;engineering notation&lt;/em&gt;, in which the exponent is a multiple of three, e.g., &lt;code&gt;&quot;##0.#####E0&quot;&lt;/code&gt;. Using this pattern, the number 12345 formats to &lt;code&gt;&quot;12.345E3&quot;&lt;/code&gt;, and 123456 formats to &lt;code&gt;&quot;123.456E3&quot;&lt;/code&gt;.</source>
          <target state="translated">如果最大整数位数大于最小位数且大于1，则将指数强制为最大整数位数的倍数，并将最小整数位数解释为1。最常见使用它是为了生成&lt;em&gt;工程符号&lt;/em&gt;，其中指数是3的倍数，例如 &lt;code&gt;&quot;##0.#####E0&quot;&lt;/code&gt; 。使用此模式，数字12345格式化为 &lt;code&gt;&quot;12.345E3&quot;&lt;/code&gt; ，数字123456格式化为 &lt;code&gt;&quot;123.456E3&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fc02abf9ff2a8cfb39d93ed0d23fa96b285931bc" translate="yes" xml:space="preserve">
          <source>If the maximum packet size is too small to hold a minimal record, an implementation may attempt to generate as minimal records as possible. However, this may cause a generated packet to be larger than the maximum packet size.</source>
          <target state="translated">如果最大数据包大小太小,无法容纳最小的记录,则实施者可尝试生成尽可能小的记录。但是,这可能导致生成的数据包大于最大数据包大小。</target>
        </trans-unit>
        <trans-unit id="4b7136459975c689cb618446a7775563184c4f97" translate="yes" xml:space="preserve">
          <source>If the maximum size has been set to a non-&lt;code&gt;null&lt;/code&gt; value just returns it.</source>
          <target state="translated">如果最大大小已设置为非 &lt;code&gt;null&lt;/code&gt; 值，则将其返回。</target>
        </trans-unit>
        <trans-unit id="86b3b7a5e5f22c1bf8fae091e74834fd7dca174e" translate="yes" xml:space="preserve">
          <source>If the maximum size has been set to a non-&lt;code&gt;null&lt;/code&gt; value just returns it. If the UI delegate's &lt;code&gt;getMaximumSize&lt;/code&gt; method returns a non-&lt;code&gt;null&lt;/code&gt; value then return that; otherwise defer to the component's layout manager.</source>
          <target state="translated">如果最大大小已设置为非 &lt;code&gt;null&lt;/code&gt; 值，则将其返回。如果UI委托的 &lt;code&gt;getMaximumSize&lt;/code&gt; 方法返回非 &lt;code&gt;null&lt;/code&gt; 值，则返回该值；否则，返回null。否则，请遵照组件的布局管理器。</target>
        </trans-unit>
        <trans-unit id="a8ec7f18e844715a365255a5c9ce58a9ea8cde37" translate="yes" xml:space="preserve">
          <source>If the maximum value is different from the previous maximum, all change listeners are notified.</source>
          <target state="translated">如果最大值与之前的最大值不同,则会通知所有变更监听者。</target>
        </trans-unit>
        <trans-unit id="838dcf4d5b32bbaaf6507ff34ec3b9a39315ea1c" translate="yes" xml:space="preserve">
          <source>If the mechanism has an initial response, the library invokes &lt;code&gt;evaluateChallenge()&lt;/code&gt; with an empty challenge and to get initial response. Protocols such as IMAP4, which do not include an initial response with their first authentication command to the server, initiates the authentication without first calling &lt;code&gt;hasInitialResponse()&lt;/code&gt; or &lt;code&gt;evaluateChallenge()&lt;/code&gt;. When the server responds to the command, it sends an initial challenge. For a SASL mechanism in which the client sends data first, the server should have issued a challenge with no data. This will then result in a call (on the client) to &lt;code&gt;evaluateChallenge()&lt;/code&gt; with an empty challenge.</source>
          <target state="translated">如果该机制具有初始响应，则库将使用空质询来调用 &lt;code&gt;evaluateChallenge()&lt;/code&gt; 并获取初始响应。协议，如IMAP4，其不包括在其第一认证命令到服务器的初始响应，发起前未调用认证 &lt;code&gt;hasInitialResponse()&lt;/code&gt; 或 &lt;code&gt;evaluateChallenge()&lt;/code&gt; 。当服务器响应该命令时，它将发送初始质询。对于客户端首先发送数据的SASL机制，服务器应该发出没有数据的质询。然后，这将导致（在客户端上）调用带有空质询的 &lt;code&gt;evaluateChallenge()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4583d5e7e45e0fa2e945cb9ac4db80337ed6eff8" translate="yes" xml:space="preserve">
          <source>If the membership key represents a membership to receive all datagrams then the membership is dropped and the channel will no longer receive any datagrams sent to the group. If the membership key is source-specific then the channel will no longer receive datagrams sent to the group from that source address.</source>
          <target state="translated">如果成员密钥代表了接收所有数据报的成员资格,那么成员资格就会被放弃,信道将不再接收发送到该组的任何数据报。如果成员资格密钥是特定于源的,那么信道将不再接收从该源地址发送到组的数据报。</target>
        </trans-unit>
        <trans-unit id="6001952d56f121e245b493dc6d0d725d39114278" translate="yes" xml:space="preserve">
          <source>If the metadata does contain tables, the tables given in a &lt;code&gt;JPEGImageWriteParam&lt;/code&gt; are ignored. Furthermore, once a set of tables has been written, only tables in the metadata can override them for subsequent writes, whether to the same stream or a different one. In order to specify new tables using this class, the &lt;a href=&quot;../../imagewriter#reset()&quot;&gt;&lt;code&gt;reset&lt;/code&gt;&lt;/a&gt; method of the writer must be called.</source>
          <target state="translated">如果元数据确实包含表，则 &lt;code&gt;JPEGImageWriteParam&lt;/code&gt; 中给定的表将被忽略。此外，一旦写入了一组表，元数据中的表就可以覆盖它们以进行后续写入，无论是写入相同的流还是不同的。为了使用此类指定新表，必须调用writer的&lt;a href=&quot;../../imagewriter#reset()&quot;&gt; &lt;code&gt;reset&lt;/code&gt; &lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="578b6c8818072cd3e8eeb57e000ffbfdfb02eb42" translate="yes" xml:space="preserve">
          <source>If the metadata does contain tables, the tables given in a &lt;code&gt;JPEGImageWriteParam&lt;/code&gt; are ignored. Furthermore, once a set of tables has been written, only tables in the metadata can override them for subsequent writes, whether to the same stream or a different one. In order to specify new tables using this class, the &lt;a href=&quot;../../imagewriter#reset--&quot;&gt;&lt;code&gt;reset&lt;/code&gt;&lt;/a&gt; method of the writer must be called.</source>
          <target state="translated">如果元数据中确实包含表，则 &lt;code&gt;JPEGImageWriteParam&lt;/code&gt; 中给定的表将被忽略。此外，一旦写入了一组表，元数据中的表就可以覆盖它们以进行后续写入，无论是写入相同的流还是写入不同的流。为了使用此类指定新表，必须调用writer 的&lt;a href=&quot;../../imagewriter#reset--&quot;&gt; &lt;code&gt;reset&lt;/code&gt; &lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="ad0276650305bd3de8e01175bff74048c2dfe026" translate="yes" xml:space="preserve">
          <source>If the method &lt;code&gt;mark&lt;/code&gt; has not been called since the stream was created, or the number of bytes read from the stream since &lt;code&gt;mark&lt;/code&gt; was last called is larger than the argument to &lt;code&gt;mark&lt;/code&gt; at that last call, then an &lt;code&gt;IOException&lt;/code&gt; might be thrown.</source>
          <target state="translated">如果自创建流以来尚未调用方法 &lt;code&gt;mark&lt;/code&gt; ，或者自上次调用 &lt;code&gt;mark&lt;/code&gt; 以来从流读取的字节数大于上一次调用 &lt;code&gt;mark&lt;/code&gt; 的参数，则可能引发 &lt;code&gt;IOException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2cd81035982e12d53ca7e2f58a6ad2d674721fd8" translate="yes" xml:space="preserve">
          <source>If the method &lt;code&gt;markSupported&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;, then:</source>
          <target state="translated">如果方法 &lt;code&gt;markSupported&lt;/code&gt; 返回 &lt;code&gt;false&lt;/code&gt; ，则：</target>
        </trans-unit>
        <trans-unit id="864c00c6cb70175672417e9637771a48ccc4d334" translate="yes" xml:space="preserve">
          <source>If the method &lt;code&gt;markSupported&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, then:</source>
          <target state="translated">如果方法 &lt;code&gt;markSupported&lt;/code&gt; 返回 &lt;code&gt;true&lt;/code&gt; ，则：</target>
        </trans-unit>
        <trans-unit id="257969b0bfbf03841c2811e4e4900ba062f566de" translate="yes" xml:space="preserve">
          <source>If the method call of a filter or listener throws an &lt;a href=&quot;../../../java.base/java/lang/exception&quot;&gt;&lt;code&gt;Exception&lt;/code&gt;&lt;/a&gt;, then that exception does not prevent other listeners from being invoked. However, if the method call of a filter or of &lt;code&gt;Executor.execute&lt;/code&gt; or of &lt;code&gt;handleNotification&lt;/code&gt; (when no &lt;code&gt;Excecutor&lt;/code&gt; is specified) throws an &lt;a href=&quot;../../../java.base/java/lang/error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt;, then that &lt;code&gt;Error&lt;/code&gt; is propagated to the caller of &lt;a href=&quot;#sendNotification(javax.management.Notification)&quot;&gt;&lt;code&gt;sendNotification&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果过滤器或侦听器的方法调用抛出&lt;a href=&quot;../../../java.base/java/lang/exception&quot;&gt; &lt;code&gt;Exception&lt;/code&gt; &lt;/a&gt;，则该异常不会阻止其他侦听器被调用。然而，如果或过滤器的方法调用 &lt;code&gt;Executor.execute&lt;/code&gt; 或 &lt;code&gt;handleNotification&lt;/code&gt; （当没有 &lt;code&gt;Excecutor&lt;/code&gt; 指定）时会引发&lt;a href=&quot;../../../java.base/java/lang/error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt;，则该 &lt;code&gt;Error&lt;/code&gt; 被传播到的呼叫者&lt;a href=&quot;#sendNotification(javax.management.Notification)&quot;&gt; &lt;code&gt;sendNotification&lt;/code&gt; 的&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4a268179b4de151a916f950d2bb56b82b6124706" translate="yes" xml:space="preserve">
          <source>If the method call of a filter or listener throws an &lt;a href=&quot;../../../java.base/java/lang/exception&quot;&gt;&lt;code&gt;Exception&lt;/code&gt;&lt;/a&gt;, then that exception should not prevent other listeners from being invoked. However, if the method call throws an &lt;a href=&quot;../../../java.base/java/lang/error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt;, then it is recommended that processing of the notification stop at that point, and if it is possible to propagate the &lt;code&gt;Error&lt;/code&gt; to the sender of the notification, this should be done.</source>
          <target state="translated">如果过滤器或侦听器的方法调用抛出&lt;a href=&quot;../../../java.base/java/lang/exception&quot;&gt; &lt;code&gt;Exception&lt;/code&gt; &lt;/a&gt;，则该异常不应阻止其他侦听器的调用。但是，如果方法调用引发&lt;a href=&quot;../../../java.base/java/lang/error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt;，则建议在该点停止通知的处理，并且如果可以将 &lt;code&gt;Error&lt;/code&gt; 传播给通知的发送者，则应这样做。</target>
        </trans-unit>
        <trans-unit id="eaea82c9a23067ef7f772f7e498b434c683c927b" translate="yes" xml:space="preserve">
          <source>If the method call of a filter or listener throws an &lt;a href=&quot;../../java/lang/exception&quot;&gt;&lt;code&gt;Exception&lt;/code&gt;&lt;/a&gt;, then that exception does not prevent other listeners from being invoked. However, if the method call of a filter or of &lt;code&gt;Executor.execute&lt;/code&gt; or of &lt;code&gt;handleNotification&lt;/code&gt; (when no &lt;code&gt;Excecutor&lt;/code&gt; is specified) throws an &lt;a href=&quot;../../java/lang/error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt;, then that &lt;code&gt;Error&lt;/code&gt; is propagated to the caller of &lt;a href=&quot;notificationbroadcastersupport#sendNotification-javax.management.Notification-&quot;&gt;&lt;code&gt;sendNotification&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果过滤器或侦听器的方法调用抛出&lt;a href=&quot;../../java/lang/exception&quot;&gt; &lt;code&gt;Exception&lt;/code&gt; &lt;/a&gt;，则该异常不会阻止其他侦听器被调用。然而，如果或过滤器的方法调用 &lt;code&gt;Executor.execute&lt;/code&gt; 或 &lt;code&gt;handleNotification&lt;/code&gt; （当没有 &lt;code&gt;Excecutor&lt;/code&gt; 指定）时会引发&lt;a href=&quot;../../java/lang/error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt;，则该 &lt;code&gt;Error&lt;/code&gt; 被传播到的呼叫者&lt;a href=&quot;notificationbroadcastersupport#sendNotification-javax.management.Notification-&quot;&gt; &lt;code&gt;sendNotification&lt;/code&gt; 的&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="267719667d5da83b9f20baec6b480b3574e95dc7" translate="yes" xml:space="preserve">
          <source>If the method call of a filter or listener throws an &lt;a href=&quot;../../java/lang/exception&quot;&gt;&lt;code&gt;Exception&lt;/code&gt;&lt;/a&gt;, then that exception should not prevent other listeners from being invoked. However, if the method call throws an &lt;a href=&quot;../../java/lang/error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt;, then it is recommended that processing of the notification stop at that point, and if it is possible to propagate the &lt;code&gt;Error&lt;/code&gt; to the sender of the notification, this should be done.</source>
          <target state="translated">如果过滤器或侦听器的方法调用抛出&lt;a href=&quot;../../java/lang/exception&quot;&gt; &lt;code&gt;Exception&lt;/code&gt; &lt;/a&gt;，则该异常不应阻止其他侦听器的调用。但是，如果方法调用引发&lt;a href=&quot;../../java/lang/error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt;，则建议在该点停止通知的处理，并且如果有可能将 &lt;code&gt;Error&lt;/code&gt; 传播给通知的发送者，则应这样做。</target>
        </trans-unit>
        <trans-unit id="9f5c827066a55f3bfdaa44e5351bcaf2001cab9a" translate="yes" xml:space="preserve">
          <source>If the method completes normally, the value it returns is returned to the caller of invoke; if the value has a primitive type, it is first appropriately wrapped in an object. However, if the value has the type of an array of a primitive type, the elements of the array are</source>
          <target state="translated">如果方法正常完成,则将返回的值返回给调用invoke的调用者;如果值的类型为基元类型,则首先将其适当地封装在一个对象中。但是,如果值的类型为基元类型的数组,则数组中的元素会被</target>
        </trans-unit>
        <trans-unit id="b17c4dd6d3aeaac2e8381aefcb1bb96824a4c8a8" translate="yes" xml:space="preserve">
          <source>If the method given to &lt;a href=&quot;../../../../java.base/java/lang/reflect/invocationhandler#invoke(java.lang.Object,java.lang.reflect.Method,java.lang.Object%5B%5D)&quot;&gt;&lt;code&gt;invoke&lt;/code&gt;&lt;/a&gt; is the method &lt;code&gt;boolean equals(Object)&lt;/code&gt; inherited from &lt;code&gt;Object&lt;/code&gt;, then it will return true if and only if the argument is a &lt;code&gt;Proxy&lt;/code&gt; whose &lt;code&gt;InvocationHandler&lt;/code&gt; is also a &lt;code&gt;
   CompositeDataInvocationHandler&lt;/code&gt; and whose backing &lt;code&gt;
   CompositeData&lt;/code&gt; is equal (not necessarily identical) to this object's. If the method given to &lt;code&gt;invoke&lt;/code&gt; is the method &lt;code&gt;int hashCode()&lt;/code&gt; inherited from &lt;code&gt;Object&lt;/code&gt;, then it will return a value that is consistent with this definition of &lt;code&gt;
   equals&lt;/code&gt;: if two objects are equal according to &lt;code&gt;equals&lt;/code&gt;, then they will have the same &lt;code&gt;hashCode&lt;/code&gt;.</source>
          <target state="translated">如果提供给&lt;a href=&quot;../../../../java.base/java/lang/reflect/invocationhandler#invoke(java.lang.Object,java.lang.reflect.Method,java.lang.Object%5B%5D)&quot;&gt; &lt;code&gt;invoke&lt;/code&gt; &lt;/a&gt;的方法是从 &lt;code&gt;Object&lt;/code&gt; 继承的方法 &lt;code&gt;boolean equals(Object)&lt;/code&gt; ，则且仅当参数为 &lt;code&gt;Proxy&lt;/code&gt; 的 &lt;code&gt;InvocationHandler&lt;/code&gt; 也是 &lt;code&gt; CompositeDataInvocationHandler&lt;/code&gt; 且其后背 &lt;code&gt; CompositeData&lt;/code&gt; 等于（不一定相同）时，它才会返回true。这个对象的。如果提供给 &lt;code&gt;invoke&lt;/code&gt; 的方法是从 &lt;code&gt;Object&lt;/code&gt; 继承的方法 &lt;code&gt;int hashCode()&lt;/code&gt; ，则它将返回与以下 &lt;code&gt; equals&lt;/code&gt; 定义一致的值：如果两个对象根据 &lt;code&gt;equals&lt;/code&gt; 相等，则它们将具有相同的 &lt;code&gt;hashCode&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="16a48723a8d9e2801b89e415c711042c7335165b" translate="yes" xml:space="preserve">
          <source>If the method given to &lt;a href=&quot;compositedatainvocationhandler#invoke-java.lang.Object-java.lang.reflect.Method-java.lang.Object:A-&quot;&gt;&lt;code&gt;invoke&lt;/code&gt;&lt;/a&gt; is the method &lt;code&gt;boolean equals(Object)&lt;/code&gt; inherited from &lt;code&gt;Object&lt;/code&gt;, then it will return true if and only if the argument is a &lt;code&gt;Proxy&lt;/code&gt; whose &lt;code&gt;InvocationHandler&lt;/code&gt; is also a &lt;code&gt;CompositeDataInvocationHandler&lt;/code&gt; and whose backing &lt;code&gt;CompositeData&lt;/code&gt; is equal (not necessarily identical) to this object's. If the method given to &lt;code&gt;invoke&lt;/code&gt; is the method &lt;code&gt;int hashCode()&lt;/code&gt; inherited from &lt;code&gt;Object&lt;/code&gt;, then it will return a value that is consistent with this definition of &lt;code&gt;equals&lt;/code&gt;: if two objects are equal according to &lt;code&gt;equals&lt;/code&gt;, then they will have the same &lt;code&gt;hashCode&lt;/code&gt;.</source>
          <target state="translated">如果提供给&lt;a href=&quot;compositedatainvocationhandler#invoke-java.lang.Object-java.lang.reflect.Method-java.lang.Object:A-&quot;&gt; &lt;code&gt;invoke&lt;/code&gt; &lt;/a&gt;的方法是从 &lt;code&gt;Object&lt;/code&gt; 继承的方法 &lt;code&gt;boolean equals(Object)&lt;/code&gt; ，则仅当参数是 &lt;code&gt;InvocationHandler&lt;/code&gt; 也是 &lt;code&gt;CompositeDataInvocationHandler&lt;/code&gt; 且其后背 &lt;code&gt;CompositeData&lt;/code&gt; 等于（不一定相同）的 &lt;code&gt;Proxy&lt;/code&gt; 时，它将返回true。这个对象的。如果提供给 &lt;code&gt;invoke&lt;/code&gt; 的方法是从 &lt;code&gt;Object&lt;/code&gt; 继承的方法 &lt;code&gt;int hashCode()&lt;/code&gt; ，则它将返回与以下 &lt;code&gt;equals&lt;/code&gt; 定义一致的值：如果两个对象根据 &lt;code&gt;equals&lt;/code&gt; 相等，则它们将具有相同的 &lt;code&gt;hashCode&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="89482ab6ffc986fc87454df58fb0e43c7e1caddc" translate="yes" xml:space="preserve">
          <source>If the method is native or abstract, an empty list is returned.</source>
          <target state="translated">如果该方法是本地或抽象的,则返回一个空列表。</target>
        </trans-unit>
        <trans-unit id="0c8dd855a596d9b3681ae2a62cc0d2f6c52ee22d" translate="yes" xml:space="preserve">
          <source>If the method shows the window then the window is also made focused under the following conditions:</source>
          <target state="translated">如果该方法显示的是窗口,那么在以下条件下也会使窗口聚焦。</target>
        </trans-unit>
        <trans-unit id="2b6f07a7fdaf466e246e416a6d8be9d141006087" translate="yes" xml:space="preserve">
          <source>If the method throws an unchecked exception it is ignored except in the case of EJBs where the EJB can handle exceptions.</source>
          <target state="translated">如果方法抛出一个未被选中的异常,它将被忽略,除非在EJB的情况下,EJB可以处理异常。</target>
        </trans-unit>
        <trans-unit id="dd7f5b04deb2b9061789f4f81f1da0be43e66b30" translate="yes" xml:space="preserve">
          <source>If the method throws an unchecked exception the class MUST NOT be put into service except in the case of EJBs where the EJB can handle exceptions and even recover from them.</source>
          <target state="translated">如果方法抛出了一个未被选中的异常,那么这个类必须不被投入服务,除非在EJB的情况下,EJB可以处理异常,甚至从异常中恢复。</target>
        </trans-unit>
        <trans-unit id="71fad1ecc8a08eac94d160de9bd1bcb1628402e9" translate="yes" xml:space="preserve">
          <source>If the methods that return configuration information about the annotation processor return &lt;code&gt;null&lt;/code&gt;, return other invalid input, or throw an exception, the tool infrastructure must treat this as an error condition.</source>
          <target state="translated">如果返回有关注释处理器的配置信息的方法返回 &lt;code&gt;null&lt;/code&gt; ，返回其他无效输入或引发异常，则工具基础结构必须将此视为错误条件。</target>
        </trans-unit>
        <trans-unit id="4d9250ed3bc9c6d4ff0b925cf3b480e2220dbd67" translate="yes" xml:space="preserve">
          <source>If the mimeType is &quot;application/x-java-serialized-object; class=&amp;lt;representation class&amp;gt;&quot;, the result is the same as calling &lt;code&gt;new DataFlavor(Class.forName(&amp;lt;representation class&amp;gt;)&lt;/code&gt;.</source>
          <target state="translated">如果mimeType为&amp;ldquo; application / x-java-serialized-object; class = &amp;lt;representation class&amp;gt;&amp;rdquo;，则结果与调用 &lt;code&gt;new DataFlavor(Class.forName(&amp;lt;representation class&amp;gt;)&lt;/code&gt; )相同。</target>
        </trans-unit>
        <trans-unit id="645cb7d243c1be249a152ed3e295457a416dfa10" translate="yes" xml:space="preserve">
          <source>If the minimum size has been set to a non-&lt;code&gt;null&lt;/code&gt; value just returns it.</source>
          <target state="translated">如果最小大小已设置为非 &lt;code&gt;null&lt;/code&gt; 值，则将其返回。</target>
        </trans-unit>
        <trans-unit id="8876db76229cee3d170e10fbb666ffa91c4f625e" translate="yes" xml:space="preserve">
          <source>If the minimum size has been set to a non-&lt;code&gt;null&lt;/code&gt; value just returns it. If the UI delegate's &lt;code&gt;getMinimumSize&lt;/code&gt; method returns a non-&lt;code&gt;null&lt;/code&gt; value then return that; otherwise defer to the component's layout manager.</source>
          <target state="translated">如果最小大小已设置为非 &lt;code&gt;null&lt;/code&gt; 值，则将其返回。如果UI委托的 &lt;code&gt;getMinimumSize&lt;/code&gt; 方法返回非 &lt;code&gt;null&lt;/code&gt; 值，则返回该值；否则，返回null。否则，请遵照组件的布局管理器。</target>
        </trans-unit>
        <trans-unit id="34725787b80a4ac3e39668b42bbcaa23889b0833" translate="yes" xml:space="preserve">
          <source>If the minimum value is different from the previous minimum, all change listeners are notified.</source>
          <target state="translated">如果最小值与之前的最小值不同,则会通知所有变更监听者。</target>
        </trans-unit>
        <trans-unit id="691404a8b3e5b3eda8e1acec57c701c9733bf667" translate="yes" xml:space="preserve">
          <source>If the model isn't empty, the width is the preferred size's width, typically the width of the widest list element. The height is the height of the cell with index 0 multiplied by the &lt;code&gt;visibleRowCount&lt;/code&gt;, plus the list's vertical insets.</source>
          <target state="translated">如果模型不为空，则宽度是首选大小的宽度，通常是最宽列表元素的宽度。高度是索引为0的单元格的高度乘以 &lt;code&gt;visibleRowCount&lt;/code&gt; 加上列表的垂直插图。</target>
        </trans-unit>
        <trans-unit id="0b88a0b55b2b80ffaa036b69fe4a0d5c5dc0f38c" translate="yes" xml:space="preserve">
          <source>If the module name consists of one identifier, then this method returns that identifier, which is deemed to be module's fully qualified name despite not being in qualified form. If the module name consists of more than one identifier, then this method returns the entire name.</source>
          <target state="translated">如果模块名称由一个标识符组成,那么本方法返回该标识符,尽管该标识符不是以限定形式存在,但它被认为是模块的完全限定名称。如果模块名由一个以上的标识符组成,那么本方法将返回整个模块名。</target>
        </trans-unit>
        <trans-unit id="f7fafdcfebc35bea4dd094bd5605e29e57f9bd44" translate="yes" xml:space="preserve">
          <source>If the module name consists of one identifier, then this method returns that identifier. If the module name consists of more than one identifier, then this method returns the rightmost such identifier, which is deemed to be the module's simple name.</source>
          <target state="translated">如果模块名称由一个标识符组成,那么本方法返回该标识符。如果模块名由多个标识符组成,那么本方法返回最右边的标识符,它被认为是模块的简单名称。</target>
        </trans-unit>
        <trans-unit id="1d5473331af759f2d8229027168bed280516c881" translate="yes" xml:space="preserve">
          <source>If the module reader can determine that the name locates a directory then the resulting URI will end with a slash ('/').</source>
          <target state="translated">如果模块读取器可以确定名称定位在一个目录,那么产生的URI将以斜线('/')结束。</target>
        </trans-unit>
        <trans-unit id="504335c7ed6dbcdfc8abf3c7edbaa85154a6e4d7" translate="yes" xml:space="preserve">
          <source>If the mouse is pressed above the &quot;thumb&quot; component then reduce the scrollbars value by one page (&quot;page up&quot;), otherwise increase it by one page.</source>
          <target state="translated">如果鼠标被按在 &quot;拇指 &quot;组件上方,那么滚动条的值就减少一页(&quot;page up&quot;),否则就增加一页。</target>
        </trans-unit>
        <trans-unit id="ba4fc2c0db235b256084eb10160b50a98ca67f0a" translate="yes" xml:space="preserve">
          <source>If the mouse is pressed above the &quot;thumb&quot; component then reduce the scrollbars value by one page (&quot;page up&quot;), otherwise increase it by one page. If there is no thumb then page up if the mouse is in the upper half of the track.</source>
          <target state="translated">如果鼠标被按在 &quot;thumb &quot;组件的上方,则滚动条的值减少一页(&quot;page up&quot;),否则增加一页。如果没有拇指,那么如果鼠标在轨道的上半部分,则向上翻页。</target>
        </trans-unit>
        <trans-unit id="d66f64c9f7d27c9865a5a830293bbaacc7ca8be1" translate="yes" xml:space="preserve">
          <source>If the name matches the regular expression &lt;code&gt;
         &quot;-(\\d+(\\.|$))&quot;&lt;/code&gt; then the module name will be derived from the subsequence preceding the hyphen of the first occurrence. The subsequence after the hyphen is parsed as a &lt;a href=&quot;moduledescriptor.version&quot;&gt;&lt;code&gt;Version&lt;/code&gt;&lt;/a&gt; and ignored if it cannot be parsed as a &lt;code&gt;Version&lt;/code&gt;.</source>
          <target state="translated">如果名称与正则表达式 &lt;code&gt; &quot;-(\\d+(\\.|$))&quot;&lt;/code&gt; 匹配，则模块名称将从首次出现的连字符前面的子序列派生。连字符后的序列被解析为一个&lt;a href=&quot;moduledescriptor.version&quot;&gt; &lt;code&gt;Version&lt;/code&gt; &lt;/a&gt;，并忽略，如果它不能被解析为一个 &lt;code&gt;Version&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2c345ae50909ad753edc18ff3d914c0995558637" translate="yes" xml:space="preserve">
          <source>If the named Logger already exists and does not yet have a localization resource bundle then the given resource bundle name is used. If the named Logger already exists and has a different resource bundle name then an IllegalArgumentException is thrown.</source>
          <target state="translated">如果命名的记录仪已经存在,并且尚未有本地化资源捆绑,那么将使用给定的资源捆绑名称。如果命名的记录仪已经存在,并且具有不同的资源捆绑名称,则会抛出一个 IllegalArgumentException。</target>
        </trans-unit>
        <trans-unit id="68506597c2f99be04b0f47ace8cfa88608b7a8be" translate="yes" xml:space="preserve">
          <source>If the named class is not a top-level class, this invocation will have no effect on the actual assertion status of any class.</source>
          <target state="translated">如果命名的类不是顶层类,那么这个调用将不会对任何类的实际断言状态产生影响。</target>
        </trans-unit>
        <trans-unit id="482df42008c5e582c9e2d80de4a8c2c7a964f035" translate="yes" xml:space="preserve">
          <source>If the named file does not exist, is a directory rather than a regular file, or for some other reason cannot be opened for reading then a &lt;code&gt;FileNotFoundException&lt;/code&gt; is thrown.</source>
          <target state="translated">如果命名文件不存在，是目录而不是常规文件，或者由于某些其他原因而无法打开文件进行读取，则抛出 &lt;code&gt;FileNotFoundException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="95905c4bd2793861fb30aaa68b18d361d2c40205" translate="yes" xml:space="preserve">
          <source>If the named object is not a DirContext, search only the object. If the named object is a DirContext, search the subtree rooted at the named object, including the named object itself.</source>
          <target state="translated">如果命名的对象不是DirContext,则只搜索该对象。如果命名对象是DirContext,则搜索以命名对象为根的子树,包括命名对象本身。</target>
        </trans-unit>
        <trans-unit id="c355566b5306844a932460e0a37f46753cb3dc74" translate="yes" xml:space="preserve">
          <source>If the namespace-prefixes feature (see above) is &lt;var&gt;false&lt;/var&gt;, access by qualified name may not be available; if the &lt;code&gt;http://xml.org/sax/features/namespaces&lt;/code&gt; feature is &lt;var&gt;false&lt;/var&gt;, access by Namespace-qualified names may not be available.</source>
          <target state="translated">如果namespace-prefixes功能（参见上文）为 &lt;var&gt;false&lt;/var&gt; ，则可能无法使用限定名称进行访问；如果 &lt;code&gt;http://xml.org/sax/features/namespaces&lt;/code&gt; 功能为 &lt;var&gt;false&lt;/var&gt; ，则可能无法使用通过名称空间限定的名称进行访问。</target>
        </trans-unit>
        <trans-unit id="a797ab321ba29b078906111b6a9d36444e539b67" translate="yes" xml:space="preserve">
          <source>If the nano-of-second is zero or not available then the format is complete.</source>
          <target state="translated">如果nano-of-second为0或不可用,则格式完整。</target>
        </trans-unit>
        <trans-unit id="7b5bb80313d91ea06fa6a854209eaa7ff1477dde" translate="yes" xml:space="preserve">
          <source>If the natural result is a node set when &lt;code&gt;ANY_TYPE&lt;/code&gt; was requested, then &lt;code&gt;UNORDERED_NODE_ITERATOR_TYPE&lt;/code&gt; is always the resulting type. Any other representation of a node set must be explicitly requested.</source>
          <target state="translated">如果自然结果是请求 &lt;code&gt;ANY_TYPE&lt;/code&gt; 时设置的节点，则 &lt;code&gt;UNORDERED_NODE_ITERATOR_TYPE&lt;/code&gt; 始终是结果类型。必须明确请求节点集的任何其他表示形式。</target>
        </trans-unit>
        <trans-unit id="0fa9630681cd403ee0de2e898abe3034087ed2d1" translate="yes" xml:space="preserve">
          <source>If the nest host of the lookup class of this &lt;code&gt;Lookup&lt;/code&gt; has previously been determined, then let &lt;code&gt;H&lt;/code&gt; be the nest host of the lookup class. Otherwise, the nest host of the lookup class is determined using the algorithm in JVMS &lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se15/html/jvms-5.html#jls-5.4.4&quot;&gt;5.4.4&lt;/a&gt;, yielding &lt;code&gt;H&lt;/code&gt;.</source>
          <target state="translated">如果先前已经确定了此 &lt;code&gt;Lookup&lt;/code&gt; 的lookup类的嵌套宿主，则让 &lt;code&gt;H&lt;/code&gt; 为lookup类的嵌套宿主。否则，查找类的巢主机使用在JVMS的算法确定&lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se15/html/jvms-5.html#jls-5.4.4&quot;&gt;5.4.4&lt;/a&gt;，得到 &lt;code&gt;H&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5582ab669009a8a27be652376823390e57a44c93" translate="yes" xml:space="preserve">
          <source>If the new &lt;code&gt;Node&lt;/code&gt; replaces an existing node the replaced &lt;code&gt;Node&lt;/code&gt; is returned, otherwise &lt;code&gt;null&lt;/code&gt; is returned.</source>
          <target state="translated">如果新 &lt;code&gt;Node&lt;/code&gt; 替换了现有节点，则返回替换的 &lt;code&gt;Node&lt;/code&gt; ，否则返回 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2bc796f960d0884f7fa3798155b8968a45c48d83" translate="yes" xml:space="preserve">
          <source>If the new &lt;code&gt;TransferHandler&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, this method removes the drop target.</source>
          <target state="translated">如果新的 &lt;code&gt;TransferHandler&lt;/code&gt; 为 &lt;code&gt;null&lt;/code&gt; ，则此方法删除放置目标。</target>
        </trans-unit>
        <trans-unit id="1dda90377648f98704c19dc7bb65377bbe60c5ed" translate="yes" xml:space="preserve">
          <source>If the new &lt;code&gt;TransferHandler&lt;/code&gt; is not &lt;code&gt;null&lt;/code&gt;, this method also installs a &lt;b&gt;new&lt;/b&gt;&lt;code&gt;DropTarget&lt;/code&gt; on the component to activate drop handling through the &lt;code&gt;TransferHandler&lt;/code&gt; and activate any built-in support (such as calculating and displaying potential drop locations). If you do not wish for this component to respond in any way to drops, you can disable drop support entirely either by removing the drop target (&lt;code&gt;setDropTarget(null)&lt;/code&gt;) or by de-activating it (&lt;code&gt;getDropTaget().setActive(false)&lt;/code&gt;).</source>
          <target state="translated">如果新的 &lt;code&gt;TransferHandler&lt;/code&gt; 不为 &lt;code&gt;null&lt;/code&gt; ，则此方法还将在组件上安装&lt;b&gt;新的&lt;/b&gt; &lt;code&gt;DropTarget&lt;/code&gt; ，以通过 &lt;code&gt;TransferHandler&lt;/code&gt; 激活放置处理并激活任何内置支持（例如，计算和显示潜在放置位置）。如果您不希望此组件以任何方式响应放置，则可以通过删除放置目标（ &lt;code&gt;setDropTarget(null)&lt;/code&gt; ）或通过将其 &lt;code&gt;getDropTaget().setActive(false)&lt;/code&gt; ）来完全禁用放置支持。。</target>
        </trans-unit>
        <trans-unit id="0388ea5e05300452be6a29d74452f310aa91ce94" translate="yes" xml:space="preserve">
          <source>If the new extent value is different from the previous extent value, all change listeners are notified.</source>
          <target state="translated">如果新的范围值与之前的范围值不同,则会通知所有变更监听器。</target>
        </trans-unit>
        <trans-unit id="18bffcd626a18ef77083ada33a312e98a304ff4c" translate="yes" xml:space="preserve">
          <source>If the new level is null, it means that this node should inherit its level from its nearest ancestor with a specific (non-null) level value.</source>
          <target state="translated">如果新的级别为空,则意味着这个节点应该从它最近的祖先那里继承它的级别,并有一个特定的(非空)级别值。</target>
        </trans-unit>
        <trans-unit id="e9cd03b46165de5658cfad6de7730a3839030abf" translate="yes" xml:space="preserve">
          <source>If the new lookup class differs from the old one then &lt;code&gt;UNCONDITIONAL&lt;/code&gt; is lost.</source>
          <target state="translated">如果新的查找类与旧的查找类不同，则 &lt;code&gt;UNCONDITIONAL&lt;/code&gt; 丢失。</target>
        </trans-unit>
        <trans-unit id="bc536a2662e091e215ec8f641a7473d3709fe706" translate="yes" xml:space="preserve">
          <source>If the new lookup class differs from the old one, protected members will not be accessible by virtue of inheritance. (Protected members may continue to be accessible because of package sharing.)</source>
          <target state="translated">如果新的查找类与旧的查找类不同,受保护的成员将不能通过继承来访问。(由于包的共享,受保护的成员可以继续被访问。)</target>
        </trans-unit>
        <trans-unit id="3e53f9b359a105bac148750d2761e52e1cd4e8b5" translate="yes" xml:space="preserve">
          <source>If the new lookup class is in a different module from the old lookup class, the new previous lookup class is the old lookup class.</source>
          <target state="translated">如果新的查找类与旧的查找类在不同的模块中,那么新的以前的查找类就是旧的查找类。</target>
        </trans-unit>
        <trans-unit id="b6ba8835bff009366d798076903baa59224c126e" translate="yes" xml:space="preserve">
          <source>If the new lookup class is in a different module from the old one, i.e. &lt;a href=&quot;#MODULE&quot;&gt;&lt;code&gt;MODULE&lt;/code&gt;&lt;/a&gt; access is lost.</source>
          <target state="translated">如果新的查找类与旧的查找类不在同一个模块中，则将导致&lt;a href=&quot;#MODULE&quot;&gt; &lt;code&gt;MODULE&lt;/code&gt; &lt;/a&gt;访问丢失。</target>
        </trans-unit>
        <trans-unit id="a377cca7fdb7bec2b3b01bf2e347da0c2ef86e72" translate="yes" xml:space="preserve">
          <source>If the new lookup class is in a different package than the old one, protected and default (package) members will not be accessible, i.e. &lt;a href=&quot;#PROTECTED&quot;&gt;&lt;code&gt;PROTECTED&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#PACKAGE&quot;&gt;&lt;code&gt;PACKAGE&lt;/code&gt;&lt;/a&gt; access are lost.</source>
          <target state="translated">如果新的查找类与旧的查找类位于不同的包中，则将无法访问&lt;a href=&quot;#PROTECTED&quot;&gt; &lt;code&gt;PROTECTED&lt;/code&gt; &lt;/a&gt;成员和默认成员（包），即丢失了PROTECTED和&lt;a href=&quot;#PACKAGE&quot;&gt; &lt;code&gt;PACKAGE&lt;/code&gt; &lt;/a&gt;访问权限。</target>
        </trans-unit>
        <trans-unit id="60f2db2d23a3b70ce0836cac49cb47c5b9f6353f" translate="yes" xml:space="preserve">
          <source>If the new lookup class is in a different package than the old one, protected and default (package) members will not be accessible.</source>
          <target state="translated">如果新的查找类与旧的查找类在不同的包中,那么受保护的和默认的(包)成员将无法访问。</target>
        </trans-unit>
        <trans-unit id="68dca4027c2017d1c1cfe6cad29219610bdc524e" translate="yes" xml:space="preserve">
          <source>If the new lookup class is in the same module as the old lookup class, the new previous lookup class is the old previous lookup class.</source>
          <target state="translated">如果新的查找类与旧的查找类在同一个模块中,那么新的前一个查找类就是旧的前一个查找类。</target>
        </trans-unit>
        <trans-unit id="4ea2f0333a7bf60c58a21448f2c80569656a34b7" translate="yes" xml:space="preserve">
          <source>If the new lookup class is not &lt;a href=&quot;#accessClass(java.lang.Class)&quot;&gt;accessible&lt;/a&gt; to this lookup, then no members, not even public members, will be accessible i.e. all access modes are lost.</source>
          <target state="translated">如果无法&lt;a href=&quot;#accessClass(java.lang.Class)&quot;&gt;通过&lt;/a&gt;该查找访问新的查找类，则将无法访问任何成员，甚至公共成员，也就是所有访问模式都将丢失。</target>
        </trans-unit>
        <trans-unit id="ca96aa918a0139c5241a9be60ea7a47fde358969" translate="yes" xml:space="preserve">
          <source>If the new lookup class is not accessible to the old lookup class, then no members, not even public members, will be accessible. (In all other cases, public members will continue to be accessible.)</source>
          <target state="translated">如果新的查找类不能被旧的查找类访问,那么任何成员,甚至公共成员都不会被访问。在所有其他情况下,公共成员将继续被访问)。</target>
        </trans-unit>
        <trans-unit id="70a1ed61c4e5681283e25d035abcda938a4809a1" translate="yes" xml:space="preserve">
          <source>If the new lookup class is not within the same package member as the old one, private members will not be accessible, and protected members will not be accessible by virtue of inheritance, i.e. &lt;a href=&quot;#PRIVATE&quot;&gt;&lt;code&gt;PRIVATE&lt;/code&gt;&lt;/a&gt; access is lost. (Protected members may continue to be accessible because of package sharing.)</source>
          <target state="translated">如果新的查找类与旧的查找类不在同一包成员中，则私有成员将不可访问，并且受保护的成员也将无法通过继承进行访问，即&lt;a href=&quot;#PRIVATE&quot;&gt; &lt;code&gt;PRIVATE&lt;/code&gt; &lt;/a&gt;访问将丢失。（由于程序包共享，受保护的成员可能仍可访问。）</target>
        </trans-unit>
        <trans-unit id="46f23def278f0153e203621371a62fdba4471bd7" translate="yes" xml:space="preserve">
          <source>If the new lookup class is not within the same package member as the old one, private members will not be accessible, and protected members will not be accessible by virtue of inheritance. (Protected members may continue to be accessible because of package sharing.)</source>
          <target state="translated">如果新的查找类与旧的查找类不在同一个包成员中,那么私有成员将不能被访问,受保护成员也不会因为继承而被访问。受保护的成员可能会因为包共享而继续被访问)。</target>
        </trans-unit>
        <trans-unit id="1a7e98a2066ab4c0cf93405953a8d0cbcca7cb64" translate="yes" xml:space="preserve">
          <source>If the new lookup class is not within the same package member as the old one, private members will not be accessible.</source>
          <target state="translated">如果新的查找类与旧的查找类不在同一个包成员内,私有成员将无法访问。</target>
        </trans-unit>
        <trans-unit id="603c087e553c404966d23a0567bdcc13996bea64" translate="yes" xml:space="preserve">
          <source>If the new lookup class, the old lookup class and the previous lookup class are all in different modules i.e. teleporting to a third module, all access modes are lost.</source>
          <target state="translated">如果新的查找类、旧的查找类和以前的查找类都在不同的模块,即传送到第三个模块,所有的访问模式都会丢失。</target>
        </trans-unit>
        <trans-unit id="fe55e352ffb78a39a10dfbfe04744d52fb7c8ef9" translate="yes" xml:space="preserve">
          <source>If the new lookup object has &lt;a href=&quot;#UNCONDITIONAL&quot;&gt;&lt;code&gt;UNCONDITIONAL&lt;/code&gt;&lt;/a&gt; bit, the new previous lookup class is &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">如果新的查找对象具有&lt;a href=&quot;#UNCONDITIONAL&quot;&gt; &lt;code&gt;UNCONDITIONAL&lt;/code&gt; &lt;/a&gt;位，则新的先前查找类为 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cacfac52fe886f7cd2e9a3abcbc070941615f373" translate="yes" xml:space="preserve">
          <source>If the new maximum value is different from the previous maximum value, all change listeners are notified.</source>
          <target state="translated">如果新的最大值与之前的最大值不同,所有的变更监听器都会得到通知。</target>
        </trans-unit>
        <trans-unit id="86bb426f7dca2fb9a6984cb3ba264576f8178a89" translate="yes" xml:space="preserve">
          <source>If the new minimum value is different from the previous minimum value, all change listeners are notified.</source>
          <target state="translated">如果新的最小值与之前的最小值不同,所有的变更监听器都会得到通知。</target>
        </trans-unit>
        <trans-unit id="5c61d4985d9e12a6258d359254a6ef98f882749e" translate="yes" xml:space="preserve">
          <source>If the new value is different from the previous value, all change listeners are notified.</source>
          <target state="translated">如果新的值与之前的值不同,所有的变更监听器都会得到通知。</target>
        </trans-unit>
        <trans-unit id="dd3bd21f414045efb5b6e0572af661119b6ef82c" translate="yes" xml:space="preserve">
          <source>If the next token matches the &lt;a href=&quot;#Decimal-regex&quot;&gt;&lt;i&gt;Decimal&lt;/i&gt;&lt;/a&gt; regular expression defined above then the token is converted into a &lt;code&gt;BigDecimal&lt;/code&gt; value as if by removing all group separators, mapping non-ASCII digits into ASCII digits via the &lt;a href=&quot;../lang/character#digit(char,int)&quot;&gt;&lt;code&gt;Character.digit&lt;/code&gt;&lt;/a&gt;, and passing the resulting string to the &lt;a href=&quot;../math/bigdecimal#%3Cinit%3E(java.lang.String)&quot;&gt;&lt;code&gt;BigDecimal(String)&lt;/code&gt;&lt;/a&gt; constructor.</source>
          <target state="translated">如果下一个标记与上面定义的&lt;a href=&quot;#Decimal-regex&quot;&gt;&lt;i&gt;Decimal&lt;/i&gt;&lt;/a&gt;正则表达式匹配，则将该标记转换为 &lt;code&gt;BigDecimal&lt;/code&gt; 值，就像通过删除所有组分隔符，通过&lt;a href=&quot;../lang/character#digit(char,int)&quot;&gt; &lt;code&gt;Character.digit&lt;/code&gt; &lt;/a&gt;将非ASCII数字映射为ASCII数字并将结果字符串传递给&lt;a href=&quot;../math/bigdecimal#%3Cinit%3E(java.lang.String)&quot;&gt; &lt;code&gt;BigDecimal(String)&lt;/code&gt; &lt;/a&gt;构造函数。</target>
        </trans-unit>
        <trans-unit id="070950b6983687a52f5c8a4982aa2eebcfd77d61" translate="yes" xml:space="preserve">
          <source>If the next token matches the &lt;a href=&quot;#Decimal-regex&quot;&gt;&lt;i&gt;Decimal&lt;/i&gt;&lt;/a&gt; regular expression defined above then the token is converted into a &lt;code&gt;BigDecimal&lt;/code&gt; value as if by removing all group separators, mapping non-ASCII digits into ASCII digits via the &lt;a href=&quot;../lang/character#digit-char-int-&quot;&gt;&lt;code&gt;Character.digit&lt;/code&gt;&lt;/a&gt;, and passing the resulting string to the &lt;a href=&quot;../math/bigdecimal#BigDecimal-java.lang.String-&quot;&gt;&lt;code&gt;BigDecimal(String)&lt;/code&gt;&lt;/a&gt; constructor.</source>
          <target state="translated">如果下一个标记与上面定义的&lt;a href=&quot;#Decimal-regex&quot;&gt;&lt;i&gt;Decimal&lt;/i&gt;&lt;/a&gt;正则表达式匹配，则将该标记转换为 &lt;code&gt;BigDecimal&lt;/code&gt; 值，就像通过删除所有组分隔符，通过&lt;a href=&quot;../lang/character#digit-char-int-&quot;&gt; &lt;code&gt;Character.digit&lt;/code&gt; &lt;/a&gt;将非ASCII数字映射为ASCII数字并将结果字符串传递给&lt;a href=&quot;../math/bigdecimal#BigDecimal-java.lang.String-&quot;&gt; &lt;code&gt;BigDecimal(String)&lt;/code&gt; &lt;/a&gt;构造函数。</target>
        </trans-unit>
        <trans-unit id="efd903809d871bfd2261f9bb7c6f8847849f99dc" translate="yes" xml:space="preserve">
          <source>If the next token matches the &lt;a href=&quot;#Float-regex&quot;&gt;&lt;i&gt;Float&lt;/i&gt;&lt;/a&gt; regular expression defined above then the token is converted into a &lt;code&gt;double&lt;/code&gt; value as if by removing all locale specific prefixes, group separators, and locale specific suffixes, then mapping non-ASCII digits into ASCII digits via &lt;a href=&quot;../lang/character#digit(char,int)&quot;&gt;&lt;code&gt;Character.digit&lt;/code&gt;&lt;/a&gt;, prepending a negative sign (-) if the locale specific negative prefixes and suffixes were present, and passing the resulting string to &lt;a href=&quot;../lang/double#parseDouble(java.lang.String)&quot;&gt;&lt;code&gt;Double.parseDouble&lt;/code&gt;&lt;/a&gt;. If the token matches the localized NaN or infinity strings, then either &quot;Nan&quot; or &quot;Infinity&quot; is passed to &lt;a href=&quot;../lang/double#parseDouble(java.lang.String)&quot;&gt;&lt;code&gt;Double.parseDouble&lt;/code&gt;&lt;/a&gt; as appropriate.</source>
          <target state="translated">如果下一个标记与上面定义的&lt;a href=&quot;#Float-regex&quot;&gt;&lt;i&gt;Float&lt;/i&gt;&lt;/a&gt;正则表达式匹配，则该标记将转换为 &lt;code&gt;double&lt;/code&gt; 值，就像通过删除所有特定于语言环境的前缀，组分隔符和特定于语言环境的后缀，然后通过&lt;a href=&quot;../lang/character#digit(char,int)&quot;&gt; &lt;code&gt;Character.digit&lt;/code&gt; &lt;/a&gt;将非ASCII数字映射为ASCII数字一样。，如果存在特定于语言环境的否定前缀和后缀，则在其前面加上一个负号（-），并将结果字符串传递给&lt;a href=&quot;../lang/double#parseDouble(java.lang.String)&quot;&gt; &lt;code&gt;Double.parseDouble&lt;/code&gt; &lt;/a&gt;。如果令牌与本地化的NaN或无穷大字符串匹配，则将&amp;ldquo; Nan&amp;rdquo;或&amp;ldquo; Infinity&amp;rdquo;适当地传递给&lt;a href=&quot;../lang/double#parseDouble(java.lang.String)&quot;&gt; &lt;code&gt;Double.parseDouble&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e2b55b595ce54b4c7a0ff65ce30ecb0da6b4383c" translate="yes" xml:space="preserve">
          <source>If the next token matches the &lt;a href=&quot;#Float-regex&quot;&gt;&lt;i&gt;Float&lt;/i&gt;&lt;/a&gt; regular expression defined above then the token is converted into a &lt;code&gt;double&lt;/code&gt; value as if by removing all locale specific prefixes, group separators, and locale specific suffixes, then mapping non-ASCII digits into ASCII digits via &lt;a href=&quot;../lang/character#digit-char-int-&quot;&gt;&lt;code&gt;Character.digit&lt;/code&gt;&lt;/a&gt;, prepending a negative sign (-) if the locale specific negative prefixes and suffixes were present, and passing the resulting string to &lt;a href=&quot;../lang/double#parseDouble-java.lang.String-&quot;&gt;&lt;code&gt;Double.parseDouble&lt;/code&gt;&lt;/a&gt;. If the token matches the localized NaN or infinity strings, then either &quot;Nan&quot; or &quot;Infinity&quot; is passed to &lt;a href=&quot;../lang/double#parseDouble-java.lang.String-&quot;&gt;&lt;code&gt;Double.parseDouble&lt;/code&gt;&lt;/a&gt; as appropriate.</source>
          <target state="translated">如果下一个标记与上面定义的&lt;a href=&quot;#Float-regex&quot;&gt;&lt;i&gt;Float&lt;/i&gt;&lt;/a&gt;正则表达式匹配，则该标记将转换为 &lt;code&gt;double&lt;/code&gt; 值，就像通过删除所有特定于语言环境的前缀，组分隔符和特定于语言环境的后缀，然后通过&lt;a href=&quot;../lang/character#digit-char-int-&quot;&gt; &lt;code&gt;Character.digit&lt;/code&gt; &lt;/a&gt;将非ASCII数字映射为ASCII数字一样。，如果存在特定于语言环境的否定前缀和后缀，则在其前面加上一个负号（-），并将结果字符串传递给&lt;a href=&quot;../lang/double#parseDouble-java.lang.String-&quot;&gt; &lt;code&gt;Double.parseDouble&lt;/code&gt; &lt;/a&gt;。如果令牌与本地化的NaN或无穷大字符串匹配，则将&amp;ldquo; Nan&amp;rdquo;或&amp;ldquo; Infinity&amp;rdquo; 适当地传递给&lt;a href=&quot;../lang/double#parseDouble-java.lang.String-&quot;&gt; &lt;code&gt;Double.parseDouble&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3eb97346bea3b5a1c66d1ff73d9a7571c94316bf" translate="yes" xml:space="preserve">
          <source>If the next token matches the &lt;a href=&quot;#Float-regex&quot;&gt;&lt;i&gt;Float&lt;/i&gt;&lt;/a&gt; regular expression defined above then the token is converted into a &lt;code&gt;float&lt;/code&gt; value as if by removing all locale specific prefixes, group separators, and locale specific suffixes, then mapping non-ASCII digits into ASCII digits via &lt;a href=&quot;../lang/character#digit(char,int)&quot;&gt;&lt;code&gt;Character.digit&lt;/code&gt;&lt;/a&gt;, prepending a negative sign (-) if the locale specific negative prefixes and suffixes were present, and passing the resulting string to &lt;a href=&quot;../lang/float#parseFloat(java.lang.String)&quot;&gt;&lt;code&gt;Float.parseFloat&lt;/code&gt;&lt;/a&gt;. If the token matches the localized NaN or infinity strings, then either &quot;Nan&quot; or &quot;Infinity&quot; is passed to &lt;a href=&quot;../lang/float#parseFloat(java.lang.String)&quot;&gt;&lt;code&gt;Float.parseFloat&lt;/code&gt;&lt;/a&gt; as appropriate.</source>
          <target state="translated">如果下一个标记与上面定义的&lt;a href=&quot;#Float-regex&quot;&gt;&lt;i&gt;Float&lt;/i&gt;&lt;/a&gt;正则表达式匹配，则该标记将转换为 &lt;code&gt;float&lt;/code&gt; 值，就像通过删除所有特定于语言环境的前缀，组分隔符和特定于语言环境的后缀，然后通过&lt;a href=&quot;../lang/character#digit(char,int)&quot;&gt; &lt;code&gt;Character.digit&lt;/code&gt; &lt;/a&gt;将非ASCII数字映射为ASCII数字一样。，如果存在特定于语言环境的否定前缀和后缀，则在其前面加上一个负号（-），并将结果字符串传递给&lt;a href=&quot;../lang/float#parseFloat(java.lang.String)&quot;&gt; &lt;code&gt;Float.parseFloat&lt;/code&gt; &lt;/a&gt;。如果令牌与本地化的NaN或无穷大字符串匹配，则将&amp;ldquo; Nan&amp;rdquo;或&amp;ldquo; Infinity&amp;rdquo;适当地传递给&lt;a href=&quot;../lang/float#parseFloat(java.lang.String)&quot;&gt; &lt;code&gt;Float.parseFloat&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6a79c16b442949a70d19c9e0f0f3c3e6d85edf9f" translate="yes" xml:space="preserve">
          <source>If the next token matches the &lt;a href=&quot;#Float-regex&quot;&gt;&lt;i&gt;Float&lt;/i&gt;&lt;/a&gt; regular expression defined above then the token is converted into a &lt;code&gt;float&lt;/code&gt; value as if by removing all locale specific prefixes, group separators, and locale specific suffixes, then mapping non-ASCII digits into ASCII digits via &lt;a href=&quot;../lang/character#digit-char-int-&quot;&gt;&lt;code&gt;Character.digit&lt;/code&gt;&lt;/a&gt;, prepending a negative sign (-) if the locale specific negative prefixes and suffixes were present, and passing the resulting string to &lt;a href=&quot;../lang/float#parseFloat-java.lang.String-&quot;&gt;&lt;code&gt;Float.parseFloat&lt;/code&gt;&lt;/a&gt;. If the token matches the localized NaN or infinity strings, then either &quot;Nan&quot; or &quot;Infinity&quot; is passed to &lt;a href=&quot;../lang/float#parseFloat-java.lang.String-&quot;&gt;&lt;code&gt;Float.parseFloat&lt;/code&gt;&lt;/a&gt; as appropriate.</source>
          <target state="translated">如果下一个标记与上面定义的&lt;a href=&quot;#Float-regex&quot;&gt;&lt;i&gt;Float&lt;/i&gt;&lt;/a&gt;正则表达式匹配，则该标记将转换为 &lt;code&gt;float&lt;/code&gt; 值，就像通过删除所有特定于语言环境的前缀，组分隔符和特定于语言环境的后缀，然后通过&lt;a href=&quot;../lang/character#digit-char-int-&quot;&gt; &lt;code&gt;Character.digit&lt;/code&gt; &lt;/a&gt;将非ASCII数字映射为ASCII数字一样。，如果存在特定于语言环境的否定前缀和后缀，则在其前面加上一个负号（-），并将结果字符串传递给&lt;a href=&quot;../lang/float#parseFloat-java.lang.String-&quot;&gt; &lt;code&gt;Float.parseFloat&lt;/code&gt; &lt;/a&gt;。如果令牌与本地化的NaN或无穷大字符串匹配，则将&amp;ldquo; Nan&amp;rdquo;或&amp;ldquo; Infinity&amp;rdquo; 适当地传递给&lt;a href=&quot;../lang/float#parseFloat-java.lang.String-&quot;&gt; &lt;code&gt;Float.parseFloat&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5d2ff6a2387c543b478a622ed06f1bb7df0d7421" translate="yes" xml:space="preserve">
          <source>If the next token matches the &lt;a href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;Integer&lt;/i&gt;&lt;/a&gt; regular expression defined above then the token is converted into a &lt;code&gt;BigInteger&lt;/code&gt; value as if by removing all group separators, mapping non-ASCII digits into ASCII digits via the &lt;a href=&quot;../lang/character#digit(char,int)&quot;&gt;&lt;code&gt;Character.digit&lt;/code&gt;&lt;/a&gt;, and passing the resulting string to the &lt;a href=&quot;../math/biginteger#%3Cinit%3E(java.lang.String)&quot;&gt;&lt;code&gt;BigInteger(String, int)&lt;/code&gt;&lt;/a&gt; constructor with the specified radix.</source>
          <target state="translated">如果下一个标记与上面定义的&lt;a href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;Integer&lt;/i&gt;&lt;/a&gt;正则表达式匹配，则将该标记转换为 &lt;code&gt;BigInteger&lt;/code&gt; 值，就像通过删除所有组分隔符，通过&lt;a href=&quot;../lang/character#digit(char,int)&quot;&gt; &lt;code&gt;Character.digit&lt;/code&gt; &lt;/a&gt;将非ASCII数字映射为ASCII数字并将结果字符串传递给&lt;a href=&quot;../math/biginteger#%3Cinit%3E(java.lang.String)&quot;&gt; &lt;code&gt;BigInteger(String, int)&lt;/code&gt; &lt;/a&gt;具有指定基数的构造函数。</target>
        </trans-unit>
        <trans-unit id="1a4727cf6304247402307e6eaca3eff6d0258644" translate="yes" xml:space="preserve">
          <source>If the next token matches the &lt;a href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;Integer&lt;/i&gt;&lt;/a&gt; regular expression defined above then the token is converted into a &lt;code&gt;BigInteger&lt;/code&gt; value as if by removing all group separators, mapping non-ASCII digits into ASCII digits via the &lt;a href=&quot;../lang/character#digit-char-int-&quot;&gt;&lt;code&gt;Character.digit&lt;/code&gt;&lt;/a&gt;, and passing the resulting string to the &lt;a href=&quot;../math/biginteger#BigInteger-java.lang.String-&quot;&gt;&lt;code&gt;BigInteger(String, int)&lt;/code&gt;&lt;/a&gt; constructor with the specified radix.</source>
          <target state="translated">如果下一个标记与上面定义的&lt;a href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;Integer&lt;/i&gt;&lt;/a&gt;正则表达式匹配，则将该标记转换为 &lt;code&gt;BigInteger&lt;/code&gt; 值，就像通过删除所有组分隔符，通过&lt;a href=&quot;../lang/character#digit-char-int-&quot;&gt; &lt;code&gt;Character.digit&lt;/code&gt; &lt;/a&gt;将非ASCII数字映射为ASCII数字并将结果字符串传递给&lt;a href=&quot;../math/biginteger#BigInteger-java.lang.String-&quot;&gt; &lt;code&gt;BigInteger(String, int)&lt;/code&gt; &lt;/a&gt;具有指定基数的构造函数。</target>
        </trans-unit>
        <trans-unit id="fac93df718c735e73535bc4d3d4b9324ef4c5caf" translate="yes" xml:space="preserve">
          <source>If the next token matches the &lt;a href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;Integer&lt;/i&gt;&lt;/a&gt; regular expression defined above then the token is converted into a &lt;code&gt;byte&lt;/code&gt; value as if by removing all locale specific prefixes, group separators, and locale specific suffixes, then mapping non-ASCII digits into ASCII digits via &lt;a href=&quot;../lang/character#digit(char,int)&quot;&gt;&lt;code&gt;Character.digit&lt;/code&gt;&lt;/a&gt;, prepending a negative sign (-) if the locale specific negative prefixes and suffixes were present, and passing the resulting string to &lt;a href=&quot;../lang/byte#parseByte(java.lang.String,int)&quot;&gt;&lt;code&gt;Byte.parseByte&lt;/code&gt;&lt;/a&gt; with the specified radix.</source>
          <target state="translated">如果下一个标记与上面定义的&lt;a href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;Integer&lt;/i&gt;&lt;/a&gt;正则表达式匹配，则将该标记转换为 &lt;code&gt;byte&lt;/code&gt; 值，就像通过删除所有特定于语言环境的前缀，组分隔符和特定于语言环境的后缀，然后通过&lt;a href=&quot;../lang/character#digit(char,int)&quot;&gt; &lt;code&gt;Character.digit&lt;/code&gt; &lt;/a&gt;将非ASCII数字映射为ASCII数字一样。，如果存在特定于语言环境的否定前缀和后缀，则在其前面加上一个负号（-），并将结果字符串传递给具有指定基数的&lt;a href=&quot;../lang/byte#parseByte(java.lang.String,int)&quot;&gt; &lt;code&gt;Byte.parseByte&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="12b289473a0cfbe9016bed30eea7221cdd374181" translate="yes" xml:space="preserve">
          <source>If the next token matches the &lt;a href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;Integer&lt;/i&gt;&lt;/a&gt; regular expression defined above then the token is converted into a &lt;code&gt;byte&lt;/code&gt; value as if by removing all locale specific prefixes, group separators, and locale specific suffixes, then mapping non-ASCII digits into ASCII digits via &lt;a href=&quot;../lang/character#digit-char-int-&quot;&gt;&lt;code&gt;Character.digit&lt;/code&gt;&lt;/a&gt;, prepending a negative sign (-) if the locale specific negative prefixes and suffixes were present, and passing the resulting string to &lt;a href=&quot;../lang/byte#parseByte-java.lang.String-int-&quot;&gt;&lt;code&gt;Byte.parseByte&lt;/code&gt;&lt;/a&gt; with the specified radix.</source>
          <target state="translated">如果下一个标记与上面定义的&lt;a href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;Integer&lt;/i&gt;&lt;/a&gt;正则表达式匹配，则该标记将转换为 &lt;code&gt;byte&lt;/code&gt; 值，就像通过删除所有特定于语言环境的前缀，组分隔符和特定于语言环境的后缀，然后通过&lt;a href=&quot;../lang/character#digit-char-int-&quot;&gt; &lt;code&gt;Character.digit&lt;/code&gt; &lt;/a&gt;将非ASCII数字映射为ASCII数字一样。，如果存在特定于语言环境的否定前缀和后缀，则在其前面加上一个负号（-），并将结果字符串传递给具有指定基数的&lt;a href=&quot;../lang/byte#parseByte-java.lang.String-int-&quot;&gt; &lt;code&gt;Byte.parseByte&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3589f798ea949bb8459c5766611ecd61d78cc6ed" translate="yes" xml:space="preserve">
          <source>If the next token matches the &lt;a href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;Integer&lt;/i&gt;&lt;/a&gt; regular expression defined above then the token is converted into a &lt;code&gt;long&lt;/code&gt; value as if by removing all locale specific prefixes, group separators, and locale specific suffixes, then mapping non-ASCII digits into ASCII digits via &lt;a href=&quot;../lang/character#digit(char,int)&quot;&gt;&lt;code&gt;Character.digit&lt;/code&gt;&lt;/a&gt;, prepending a negative sign (-) if the locale specific negative prefixes and suffixes were present, and passing the resulting string to &lt;a href=&quot;../lang/long#parseLong(java.lang.String,int)&quot;&gt;&lt;code&gt;Long.parseLong&lt;/code&gt;&lt;/a&gt; with the specified radix.</source>
          <target state="translated">如果下一个标记与上面定义的&lt;a href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;Integer&lt;/i&gt;&lt;/a&gt;正则表达式匹配，则该标记将转换为 &lt;code&gt;long&lt;/code&gt; 值，就像通过删除所有特定于语言环境的前缀，组分隔符和特定于语言环境的后缀，然后通过&lt;a href=&quot;../lang/character#digit(char,int)&quot;&gt; &lt;code&gt;Character.digit&lt;/code&gt; &lt;/a&gt;将非ASCII数字映射为ASCII数字一样。，如果存在特定于语言环境的否定前缀和后缀，则在其前面加上一个负号（-），并将结果字符串传递给具有指定基数的&lt;a href=&quot;../lang/long#parseLong(java.lang.String,int)&quot;&gt; &lt;code&gt;Long.parseLong&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b349deb1d290eaa1752d8feff84d8af8caefc093" translate="yes" xml:space="preserve">
          <source>If the next token matches the &lt;a href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;Integer&lt;/i&gt;&lt;/a&gt; regular expression defined above then the token is converted into a &lt;code&gt;long&lt;/code&gt; value as if by removing all locale specific prefixes, group separators, and locale specific suffixes, then mapping non-ASCII digits into ASCII digits via &lt;a href=&quot;../lang/character#digit-char-int-&quot;&gt;&lt;code&gt;Character.digit&lt;/code&gt;&lt;/a&gt;, prepending a negative sign (-) if the locale specific negative prefixes and suffixes were present, and passing the resulting string to &lt;a href=&quot;../lang/long#parseLong-java.lang.String-int-&quot;&gt;&lt;code&gt;Long.parseLong&lt;/code&gt;&lt;/a&gt; with the specified radix.</source>
          <target state="translated">如果下一个标记与上面定义的&lt;a href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;Integer&lt;/i&gt;&lt;/a&gt;正则表达式匹配，则该标记将转换为 &lt;code&gt;long&lt;/code&gt; 值，就像通过删除所有特定于语言环境的前缀，组分隔符和特定于语言环境的后缀，然后通过&lt;a href=&quot;../lang/character#digit-char-int-&quot;&gt; &lt;code&gt;Character.digit&lt;/code&gt; &lt;/a&gt;将非ASCII数字映射为ASCII数字一样。，如果存在特定于语言环境的否定前缀和后缀，则在其前面加上一个负号（-），并将结果字符串传递给具有指定基数的&lt;a href=&quot;../lang/long#parseLong-java.lang.String-int-&quot;&gt; &lt;code&gt;Long.parseLong&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b68e5822216b2d7fa77ca18249aad6224e4ec92a" translate="yes" xml:space="preserve">
          <source>If the next token matches the &lt;a href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;Integer&lt;/i&gt;&lt;/a&gt; regular expression defined above then the token is converted into a &lt;code&gt;short&lt;/code&gt; value as if by removing all locale specific prefixes, group separators, and locale specific suffixes, then mapping non-ASCII digits into ASCII digits via &lt;a href=&quot;../lang/character#digit(char,int)&quot;&gt;&lt;code&gt;Character.digit&lt;/code&gt;&lt;/a&gt;, prepending a negative sign (-) if the locale specific negative prefixes and suffixes were present, and passing the resulting string to &lt;a href=&quot;../lang/short#parseShort(java.lang.String,int)&quot;&gt;&lt;code&gt;Short.parseShort&lt;/code&gt;&lt;/a&gt; with the specified radix.</source>
          <target state="translated">如果下一个标记与上面定义的&lt;a href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;Integer&lt;/i&gt;&lt;/a&gt;正则表达式匹配，则该标记将转换为 &lt;code&gt;short&lt;/code&gt; 值，就像通过删除所有特定于语言环境的前缀，组分隔符和特定于语言环境的后缀，然后通过&lt;a href=&quot;../lang/character#digit(char,int)&quot;&gt; &lt;code&gt;Character.digit&lt;/code&gt; &lt;/a&gt;将非ASCII数字映射为ASCII数字一样。，如果存在特定于语言环境的负前缀和后缀，则在前面加上一个负号（-），然后将结果字符串传递给具有指定基数的&lt;a href=&quot;../lang/short#parseShort(java.lang.String,int)&quot;&gt; &lt;code&gt;Short.parseShort&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cde2372e3435e6554a5b5741f761096f7eea5fcf" translate="yes" xml:space="preserve">
          <source>If the next token matches the &lt;a href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;Integer&lt;/i&gt;&lt;/a&gt; regular expression defined above then the token is converted into a &lt;code&gt;short&lt;/code&gt; value as if by removing all locale specific prefixes, group separators, and locale specific suffixes, then mapping non-ASCII digits into ASCII digits via &lt;a href=&quot;../lang/character#digit-char-int-&quot;&gt;&lt;code&gt;Character.digit&lt;/code&gt;&lt;/a&gt;, prepending a negative sign (-) if the locale specific negative prefixes and suffixes were present, and passing the resulting string to &lt;a href=&quot;../lang/short#parseShort-java.lang.String-int-&quot;&gt;&lt;code&gt;Short.parseShort&lt;/code&gt;&lt;/a&gt; with the specified radix.</source>
          <target state="translated">如果下一个标记与上面定义的&lt;a href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;Integer&lt;/i&gt;&lt;/a&gt;正则表达式匹配，则该标记将转换为 &lt;code&gt;short&lt;/code&gt; 值，就像通过删除所有特定于语言环境的前缀，组分隔符和特定于语言环境的后缀，然后通过&lt;a href=&quot;../lang/character#digit-char-int-&quot;&gt; &lt;code&gt;Character.digit&lt;/code&gt; &lt;/a&gt;将非ASCII数字映射为ASCII数字一样。，如果存在特定于语言环境的负前缀和后缀，则在前面加上一个负号（-），然后将结果字符串传递给具有指定基数的&lt;a href=&quot;../lang/short#parseShort-java.lang.String-int-&quot;&gt; &lt;code&gt;Short.parseShort&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d5aa82aacf2b2fd955865f9e55427bb7ea1a38f3" translate="yes" xml:space="preserve">
          <source>If the next token matches the &lt;a href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;Integer&lt;/i&gt;&lt;/a&gt; regular expression defined above then the token is converted into an &lt;code&gt;int&lt;/code&gt; value as if by removing all locale specific prefixes, group separators, and locale specific suffixes, then mapping non-ASCII digits into ASCII digits via &lt;a href=&quot;../lang/character#digit(char,int)&quot;&gt;&lt;code&gt;Character.digit&lt;/code&gt;&lt;/a&gt;, prepending a negative sign (-) if the locale specific negative prefixes and suffixes were present, and passing the resulting string to &lt;a href=&quot;../lang/integer#parseInt(java.lang.String,int)&quot;&gt;&lt;code&gt;Integer.parseInt&lt;/code&gt;&lt;/a&gt; with the specified radix.</source>
          <target state="translated">如果下一个标记与上面定义的&lt;a href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;Integer&lt;/i&gt;&lt;/a&gt;正则表达式匹配，则该标记将转换为 &lt;code&gt;int&lt;/code&gt; 值，就像通过删除所有特定于语言环境的前缀，组分隔符和特定于语言环境的后缀，然后通过&lt;a href=&quot;../lang/character#digit(char,int)&quot;&gt; &lt;code&gt;Character.digit&lt;/code&gt; &lt;/a&gt;将非ASCII数字映射为ASCII数字一样。，如果存在特定于语言环境的负前缀和后缀，则在前面加上一个负号（-），然后将结果字符串以指定的基数传递给&lt;a href=&quot;../lang/integer#parseInt(java.lang.String,int)&quot;&gt; &lt;code&gt;Integer.parseInt&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e2e6b9af16a7a0f10ca898c5788d2527ee4c8561" translate="yes" xml:space="preserve">
          <source>If the next token matches the &lt;a href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;Integer&lt;/i&gt;&lt;/a&gt; regular expression defined above then the token is converted into an &lt;code&gt;int&lt;/code&gt; value as if by removing all locale specific prefixes, group separators, and locale specific suffixes, then mapping non-ASCII digits into ASCII digits via &lt;a href=&quot;../lang/character#digit-char-int-&quot;&gt;&lt;code&gt;Character.digit&lt;/code&gt;&lt;/a&gt;, prepending a negative sign (-) if the locale specific negative prefixes and suffixes were present, and passing the resulting string to &lt;a href=&quot;../lang/integer#parseInt-java.lang.String-int-&quot;&gt;&lt;code&gt;Integer.parseInt&lt;/code&gt;&lt;/a&gt; with the specified radix.</source>
          <target state="translated">如果下一个标记与上面定义的&lt;a href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;Integer&lt;/i&gt;&lt;/a&gt;正则表达式匹配，则将该标记转换为 &lt;code&gt;int&lt;/code&gt; 值，就像通过删除所有特定于语言环境的前缀，组分隔符和特定于语言环境的后缀，然后通过&lt;a href=&quot;../lang/character#digit-char-int-&quot;&gt; &lt;code&gt;Character.digit&lt;/code&gt; &lt;/a&gt;将非ASCII数字映射为ASCII数字一样。，如果存在特定于语言环境的负前缀和后缀，则在其前加上一个负号（-），然后将结果字符串以指定的基数传递给&lt;a href=&quot;../lang/integer#parseInt-java.lang.String-int-&quot;&gt; &lt;code&gt;Integer.parseInt&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f51b9968b885ef1885dbe34821dc425278cfb9c3" translate="yes" xml:space="preserve">
          <source>If the node being visited has more than one child, the result will be determined by calling &lt;code&gt;scan&lt;/code&gt; each child in turn, and then combining the result of each scan after the first with the cumulative result so far, as determined by the &lt;a href=&quot;#reduce(R,R)&quot;&gt;&lt;code&gt;reduce(R, R)&lt;/code&gt;&lt;/a&gt; method. Each child may be either a simple node of a list of nodes. The default behavior of the &lt;code&gt;reduce&lt;/code&gt; method is such that the result of the visitXYZ method will be the result of the last child scanned.</source>
          <target state="translated">如果被访问的节点有多个子节点，则通过依次调用 &lt;code&gt;scan&lt;/code&gt; 每个子节点，然后将第一次扫描后的每次扫描结果与到目前为止的累积结果&lt;a href=&quot;#reduce(R,R)&quot;&gt; &lt;code&gt;reduce(R, R)&lt;/code&gt; &lt;/a&gt;由reduce（R， R）方法。每个子节点可以是节点列表中的一个简单节点。 &lt;code&gt;reduce&lt;/code&gt; 方法的默认行为是：visitXYZ方法的结果将是最后扫描的子级的结果。</target>
        </trans-unit>
        <trans-unit id="9c52658cbffb38373b711425c29a4d9b7f3c889c" translate="yes" xml:space="preserve">
          <source>If the node being visited has no children, the result will be &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">如果被访问的节点没有子节点，则结果将为 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="77bd3efb080ea23321f595eec5e2b18f84442b5f" translate="yes" xml:space="preserve">
          <source>If the node being visited has one child, the result will be the result of calling &lt;code&gt;scan&lt;/code&gt; on that child. The child may be a simple node or itself a list of nodes.</source>
          <target state="translated">如果要访问的节点有一个子节点，则结果将是对该子节点调用 &lt;code&gt;scan&lt;/code&gt; 的结果。子节点可以是简单节点，也可以是节点列表。</target>
        </trans-unit>
        <trans-unit id="50647ef6cfa173ffb331678172077c93b906dc08" translate="yes" xml:space="preserve">
          <source>If the number is followed by a colon, it is regarded as an hour, unless an hour has already been recognized, in which case it is regarded as a minute.</source>
          <target state="translated">如果数字后面有冒号,则视为小时,除非已经承认了小时,在这种情况下,则视为分钟。</target>
        </trans-unit>
        <trans-unit id="2185b02dab1b8be5d039095147b6a86e141a45f4" translate="yes" xml:space="preserve">
          <source>If the number is followed by a slash, it is regarded as a month (it is decreased by 1 to produce a number in the range &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;11&lt;/code&gt;), unless a month has already been recognized, in which case it is regarded as a day of the month.</source>
          <target state="translated">如果数字后跟斜杠，则将其视为月份（将数字减1以产生介于 &lt;code&gt;0&lt;/code&gt; 到 &lt;code&gt;11&lt;/code&gt; 之间的数字），除非已经识别出月份，则将其视为一天。这个月。</target>
        </trans-unit>
        <trans-unit id="24c204655d0c4e49fdb27ee92ac3fcb02b0bfac3" translate="yes" xml:space="preserve">
          <source>If the number is followed by whitespace, a comma, a hyphen, or end of string, then if an hour has been recognized but not a minute, it is regarded as a minute; otherwise, if a minute has been recognized but not a second, it is regarded as a second; otherwise, it is regarded as a day of the month.</source>
          <target state="translated">如果数字后面有空格、逗号、连字符或字符串末尾,则认准了小时而没有认准分钟,则视为分钟;否则认准了分钟而没有认准秒,则视为秒;否则视为月日。</target>
        </trans-unit>
        <trans-unit id="6291ad948edcd3847ce9e2ff7d5cea133a2c5935" translate="yes" xml:space="preserve">
          <source>If the number of arguments in the specified constructor is non-zero and the class of &lt;code&gt;oldInstance&lt;/code&gt; explicitly declares an &quot;equals&quot; method this method returns the value of &lt;code&gt;oldInstance.equals(newInstance)&lt;/code&gt;.</source>
          <target state="translated">如果指定构造函数中的参数数量为非零，并且 &lt;code&gt;oldInstance&lt;/code&gt; 类明确声明了一个&amp;ldquo;等于&amp;rdquo;方法，则此方法返回 &lt;code&gt;oldInstance.equals(newInstance)&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="28b1d7370c2a1b58a891d34fad7ee082b38756d3" translate="yes" xml:space="preserve">
          <source>If the number of arguments in the specified constructor is non-zero and the class of &lt;code&gt;oldInstance&lt;/code&gt; explicitly declares an &quot;equals&quot; method this method returns the value of &lt;code&gt;oldInstance.equals(newInstance)&lt;/code&gt;. Otherwise, this method uses the superclass's definition which returns true if the classes of the two instances are equal.</source>
          <target state="translated">如果指定构造函数中的参数数量为非零，并且 &lt;code&gt;oldInstance&lt;/code&gt; 类显式声明了一个&amp;ldquo;等于&amp;rdquo;方法，则此方法返回 &lt;code&gt;oldInstance.equals(newInstance)&lt;/code&gt; 的值。否则，此方法使用超类的定义，如果两个实例的类相等，则返回true。</target>
        </trans-unit>
        <trans-unit id="c24fe213e64505f30b52e8476bd73dee9a4a91ca" translate="yes" xml:space="preserve">
          <source>If the number of bands is more than one, the SampleModel will be a SinglePixelPackedSampleModel, with each band having bitsPerBand bits. In either case, the requirements on dataType and bitsPerBand imposed by the corresponding SampleModel must be met.</source>
          <target state="translated">如果频段数超过一个,SampleModel将是一个SinglePixelPackedSampleModel,每个频段都有bitsPerBand位。无论哪种情况,都必须满足相应SampleModel对dataType和bitsPerBand的要求。</target>
        </trans-unit>
        <trans-unit id="d4af9d2d4726a8f3ade67f849e06bc1d1ab1564a" translate="yes" xml:space="preserve">
          <source>If the number of formal parameters required by the underlying constructor is 0, the supplied &lt;code&gt;initargs&lt;/code&gt; array may be of length 0 or null.</source>
          <target state="translated">如果基础构造函数所需的形式参数数量为0，则提供的 &lt;code&gt;initargs&lt;/code&gt; 数组的长度可以为0或为null。</target>
        </trans-unit>
        <trans-unit id="1a45750d8cf5475f9813ae9cb718f088a466add3" translate="yes" xml:space="preserve">
          <source>If the number of formal parameters required by the underlying method is 0, the supplied &lt;code&gt;args&lt;/code&gt; array may be of length 0 or null.</source>
          <target state="translated">如果基础方法所需的形式参数数量为0，则提供的 &lt;code&gt;args&lt;/code&gt; 数组的长度可以为0或为null。</target>
        </trans-unit>
        <trans-unit id="d6aa952eaa67d2b3ae4ac72907b831466314c9b3" translate="yes" xml:space="preserve">
          <source>If the number of pattern letters is 4 or more, &lt;a href=&quot;../lang/illegalargumentexception&quot;&gt;&lt;code&gt;IllegalArgumentException&lt;/code&gt;&lt;/a&gt; is thrown when constructing a &lt;code&gt;
     SimpleDateFormat&lt;/code&gt; or &lt;a href=&quot;#applyPattern(java.lang.String)&quot;&gt;applying a pattern&lt;/a&gt;.</source>
          <target state="translated">如果模式字母的数量为4个或更多，则在构造 &lt;code&gt; SimpleDateFormat&lt;/code&gt; 或&lt;a href=&quot;#applyPattern(java.lang.String)&quot;&gt;应用pattern&lt;/a&gt;时将抛出&lt;a href=&quot;../lang/illegalargumentexception&quot;&gt; &lt;code&gt;IllegalArgumentException&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="aecea4a5924a64f71d7845e41d1c3b018c067a01" translate="yes" xml:space="preserve">
          <source>If the number of pattern letters is 4 or more, &lt;a href=&quot;../lang/illegalargumentexception&quot;&gt;&lt;code&gt;IllegalArgumentException&lt;/code&gt;&lt;/a&gt; is thrown when constructing a &lt;code&gt;SimpleDateFormat&lt;/code&gt; or &lt;a href=&quot;simpledateformat#applyPattern-java.lang.String-&quot;&gt;applying a pattern&lt;/a&gt;.</source>
          <target state="translated">如果模式字母的数量为4个或更多，则在构造 &lt;code&gt;SimpleDateFormat&lt;/code&gt; 或&lt;a href=&quot;simpledateformat#applyPattern-java.lang.String-&quot;&gt;应用pattern&lt;/a&gt;时将抛出&lt;a href=&quot;../lang/illegalargumentexception&quot;&gt; &lt;code&gt;IllegalArgumentException&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="40ebc6195d83e88d053f6b7f4d083dcca34d15e6" translate="yes" xml:space="preserve">
          <source>If the number of readers is now zero then the lock is made available for write lock attempts.</source>
          <target state="translated">如果现在读者的数量为零,那么该锁就可以用于写锁的尝试。</target>
        </trans-unit>
        <trans-unit id="57761664428c22b67f54914f3d10f06ea9626ec9" translate="yes" xml:space="preserve">
          <source>If the number of readers is now zero then the lock is made available for write lock attempts. If the current thread does not hold this lock then &lt;a href=&quot;../../../lang/illegalmonitorstateexception&quot;&gt;&lt;code&gt;IllegalMonitorStateException&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">如果现在读取器的数量为零，则该锁定可用于写锁定尝试。如果当前线程不持有此锁，则抛出&lt;a href=&quot;../../../lang/illegalmonitorstateexception&quot;&gt; &lt;code&gt;IllegalMonitorStateException&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9539dfa1e1c4ed8a395e2b48d8e6f0bcbf6c71d0" translate="yes" xml:space="preserve">
          <source>If the object does not have a requested attribute, that nonexistent attribute will be ignored. Those requested attributes that the object does have will be returned.</source>
          <target state="translated">如果对象没有请求的属性,那么不存在的属性将被忽略。那些对象有的请求属性将被返回。</target>
        </trans-unit>
        <trans-unit id="ba188f9b3d08b409858ffc14dad0538d6c066ad5" translate="yes" xml:space="preserve">
          <source>If the object does not have an attribute specified, the directory will ignore the nonexistent attribute and return those requested attributes that the object does have.</source>
          <target state="translated">如果对象没有指定属性,目录将忽略不存在的属性,并返回对象有的请求属性。</target>
        </trans-unit>
        <trans-unit id="1d2b3a1e7cd5b23b39d1f5133dc5c01a091b5bb9" translate="yes" xml:space="preserve">
          <source>If the object does not have the attribute specified, the directory will ignore the nonexistent attribute and return the requested attributes that the object does have.</source>
          <target state="translated">如果对象没有指定的属性,目录将忽略不存在的属性,并返回对象确实存在的请求属性。</target>
        </trans-unit>
        <trans-unit id="f7640b018347f47539ec443ff012615b370426e4" translate="yes" xml:space="preserve">
          <source>If the object has a &lt;code&gt;getPropertyChangeListeners&lt;/code&gt; method then the array returned could be a mixture of &lt;code&gt;PropertyChangeListener&lt;/code&gt; and &lt;code&gt;PropertyChangeListenerProxy&lt;/code&gt; objects.</source>
          <target state="translated">如果对象具有 &lt;code&gt;getPropertyChangeListeners&lt;/code&gt; 方法，则返回的数组可能是 &lt;code&gt;PropertyChangeListener&lt;/code&gt; 和 &lt;code&gt;PropertyChangeListenerProxy&lt;/code&gt; 对象的混合。</target>
        </trans-unit>
        <trans-unit id="3efaaa6db916f5e8dd0c50701e6e2af84aea78e5" translate="yes" xml:space="preserve">
          <source>If the object has a &lt;code&gt;getVetoableChangeListeners&lt;/code&gt; method then the array returned could be a mixture of &lt;code&gt;VetoableChangeListener&lt;/code&gt; and &lt;code&gt;VetoableChangeListenerProxy&lt;/code&gt; objects.</source>
          <target state="translated">如果对象具有 &lt;code&gt;getVetoableChangeListeners&lt;/code&gt; 方法，则返回的数组可能是 &lt;code&gt;VetoableChangeListener&lt;/code&gt; 和 &lt;code&gt;VetoableChangeListenerProxy&lt;/code&gt; 对象的混合。</target>
        </trans-unit>
        <trans-unit id="a0000bd104b2da8f8fad009e5ad16ebe1912acd0" translate="yes" xml:space="preserve">
          <source>If the object has a custom mapping (is of a class implementing the interface &lt;code&gt;SQLData&lt;/code&gt;), the JDBC driver should call the method &lt;code&gt;SQLData.writeSQL&lt;/code&gt; to write it to the SQL data stream. If, on the other hand, the object is of a class implementing &lt;code&gt;Ref&lt;/code&gt;, &lt;code&gt;Blob&lt;/code&gt;, &lt;code&gt;Clob&lt;/code&gt;, &lt;code&gt;NClob&lt;/code&gt;, &lt;code&gt;Struct&lt;/code&gt;, &lt;code&gt;java.net.URL&lt;/code&gt;, or &lt;code&gt;Array&lt;/code&gt;, the driver should pass it to the database as a value of the corresponding SQL type.</source>
          <target state="translated">如果对象具有自定义映射（属于实现接口 &lt;code&gt;SQLData&lt;/code&gt; 的类），则JDBC驱动程序应调用方法 &lt;code&gt;SQLData.writeSQL&lt;/code&gt; 将其写入SQL数据流。另一方面，如果对象是实现 &lt;code&gt;Ref&lt;/code&gt; ， &lt;code&gt;Blob&lt;/code&gt; ， &lt;code&gt;Clob&lt;/code&gt; ， &lt;code&gt;NClob&lt;/code&gt; ， &lt;code&gt;Struct&lt;/code&gt; ， &lt;code&gt;java.net.URL&lt;/code&gt; 或 &lt;code&gt;Array&lt;/code&gt; 的类，则驱动程序应将其作为相应SQL类型的值传递给数据库。</target>
        </trans-unit>
        <trans-unit id="c633f6da7ab2fee69bd882fac3b3abc472fa5a8a" translate="yes" xml:space="preserve">
          <source>If the object is a &lt;code&gt;DirContext&lt;/code&gt;, any existing attributes associated with the name are replaced with those of the object. Otherwise, any existing attributes associated with the name remain unchanged.</source>
          <target state="translated">如果对象是 &lt;code&gt;DirContext&lt;/code&gt; ，则与该名称关联的所有现有属性都将替换为该对象的那些属性。否则，与该名称关联的任何现有属性均保持不变。</target>
        </trans-unit>
        <trans-unit id="80b22f0afff8183f235d7fd8ee96b05798cb0cf3" translate="yes" xml:space="preserve">
          <source>If the object is of a class implementing &lt;code&gt;SQLData&lt;/code&gt;, the rowset should call the method &lt;code&gt;SQLData.writeSQL&lt;/code&gt; to write the object to an &lt;code&gt;SQLOutput&lt;/code&gt; data stream. If, on the other hand, the object is of a class implementing &lt;code&gt;Ref&lt;/code&gt;, &lt;code&gt;Blob&lt;/code&gt;, &lt;code&gt;Clob&lt;/code&gt;, &lt;code&gt;NClob&lt;/code&gt;, &lt;code&gt;Struct&lt;/code&gt;, &lt;code&gt;java.net.URL&lt;/code&gt;, or &lt;code&gt;Array&lt;/code&gt;, the driver should pass it to the database as a value of the corresponding SQL type.</source>
          <target state="translated">如果对象属于实现 &lt;code&gt;SQLData&lt;/code&gt; 的类，则行集应调用方法 &lt;code&gt;SQLData.writeSQL&lt;/code&gt; 将对象 &lt;code&gt;SQLOutput&lt;/code&gt; 数据流。另一方面，如果对象是实现 &lt;code&gt;Ref&lt;/code&gt; ， &lt;code&gt;Blob&lt;/code&gt; ， &lt;code&gt;Clob&lt;/code&gt; ， &lt;code&gt;NClob&lt;/code&gt; ， &lt;code&gt;Struct&lt;/code&gt; ， &lt;code&gt;java.net.URL&lt;/code&gt; 或 &lt;code&gt;Array&lt;/code&gt; 的类，则驱动程序应将其作为相应SQL类型的值传递给数据库。</target>
        </trans-unit>
        <trans-unit id="4f5b3142d8650d58dfbe46a9e556320ac2bd2e7d" translate="yes" xml:space="preserve">
          <source>If the offset is not available then the format is complete.</source>
          <target state="translated">如果没有偏移量,则格式完整。</target>
        </trans-unit>
        <trans-unit id="2519e323e000b11bce96906bcfd196efd2dc89f9" translate="yes" xml:space="preserve">
          <source>If the offset is not available to format or parse then the format is complete.</source>
          <target state="translated">如果偏移量不可用于格式化或解析,则格式化完成。</target>
        </trans-unit>
        <trans-unit id="83f30839a17edd7cfbb33b3121aaa65bc609378b" translate="yes" xml:space="preserve">
          <source>If the old configuration defined a level for a logger, and the resulting configuration doesn't, then this change will not be propagated to existing loggers, if any. To completely replace a configuration - the caller should therefore call &lt;a href=&quot;#reset()&quot;&gt;&lt;code&gt;reset&lt;/code&gt;&lt;/a&gt; to empty the current configuration, before calling &lt;code&gt;updateConfiguration&lt;/code&gt;.</source>
          <target state="translated">如果旧的配置为记录器定义了一个级别，而没有为结果配置，则此更改将不会传播到现有的记录器（如果有）。要完全替换配置-调用方应在调用 &lt;code&gt;updateConfiguration&lt;/code&gt; 之前调用&lt;a href=&quot;#reset()&quot;&gt; &lt;code&gt;reset&lt;/code&gt; &lt;/a&gt;以清空当前配置。</target>
        </trans-unit>
        <trans-unit id="50ff0a2d4c9016d9ad590b91ba476d4fd341c512" translate="yes" xml:space="preserve">
          <source>If the old configuration defined some handlers for a logger, and the resulting configuration doesn't, if that logger exists, its handlers will be removed and closed.</source>
          <target state="translated">如果旧配置为记录仪定义了一些处理程序,而结果配置没有定义,那么如果该记录仪存在,其处理程序将被删除并关闭。</target>
        </trans-unit>
        <trans-unit id="6272ea50e04f5a7acc04b3b46505bc6dc3d28d4e" translate="yes" xml:space="preserve">
          <source>If the old lookup class is in a &lt;a href=&quot;../module#isNamed()&quot;&gt;&lt;code&gt;named&lt;/code&gt;&lt;/a&gt; module, and the new lookup class is in a different module &lt;code&gt;M&lt;/code&gt;, then no members, not even public members in &lt;code&gt;M&lt;/code&gt;'s exported packages, will be accessible. The exception to this is when this lookup is &lt;a href=&quot;methodhandles#publicLookup()&quot;&gt;&lt;code&gt;publicLookup&lt;/code&gt;&lt;/a&gt;, in which case &lt;code&gt;PUBLIC&lt;/code&gt; access is not lost.</source>
          <target state="translated">如果旧的查找类在&lt;a href=&quot;../module#isNamed()&quot;&gt; &lt;code&gt;named&lt;/code&gt; &lt;/a&gt;模块中，而新的查找类在其他模块 &lt;code&gt;M&lt;/code&gt; 中，则将无法访问成员，甚至 &lt;code&gt;M&lt;/code&gt; 的导出包中的公共成员。例外是此查询为&lt;a href=&quot;methodhandles#publicLookup()&quot;&gt; &lt;code&gt;publicLookup&lt;/code&gt; &lt;/a&gt;，在这种情况下，不会丢失 &lt;code&gt;PUBLIC&lt;/code&gt; 访问。</target>
        </trans-unit>
        <trans-unit id="befd5d850eccad70e74cebb655eecf125efcc787" translate="yes" xml:space="preserve">
          <source>If the old lookup class is in an unnamed module, and the new lookup class is a different module then &lt;a href=&quot;#MODULE&quot;&gt;&lt;code&gt;MODULE&lt;/code&gt;&lt;/a&gt; access is lost.</source>
          <target state="translated">如果旧的查找类在未命名的模块中，而新的查找类在其他模块中，则将失去&lt;a href=&quot;#MODULE&quot;&gt; &lt;code&gt;MODULE&lt;/code&gt; &lt;/a&gt;访问权限。</target>
        </trans-unit>
        <trans-unit id="4c280c860cb9f7effbb5d1573c9db972ff6dade1" translate="yes" xml:space="preserve">
          <source>If the opaque representation of a key (see &lt;a href=&quot;../key&quot;&gt;&lt;code&gt;Key&lt;/code&gt;&lt;/a&gt;) can be transformed (see &lt;a href=&quot;../keyfactory&quot;&gt;&lt;code&gt;KeyFactory&lt;/code&gt;&lt;/a&gt;) into this key specification (or a subclass of it), &lt;code&gt;getFormat&lt;/code&gt; called on the opaque key returns the same value as the &lt;code&gt;getFormat&lt;/code&gt; method of this key specification.</source>
          <target state="translated">如果可以将键的不透明表示形式（请参见&lt;a href=&quot;../key&quot;&gt; &lt;code&gt;Key&lt;/code&gt; &lt;/a&gt;）转换（请参见&lt;a href=&quot;../keyfactory&quot;&gt; &lt;code&gt;KeyFactory&lt;/code&gt; &lt;/a&gt;）到此键规范（或其子类）中，则在不透明键上调用的 &lt;code&gt;getFormat&lt;/code&gt; 返回的值与此键规范的 &lt;code&gt;getFormat&lt;/code&gt; 方法相同。</target>
        </trans-unit>
        <trans-unit id="26d2d84804d4a76528e348ab91515fb0509d099f" translate="yes" xml:space="preserve">
          <source>If the operating system does not support the creation of processes, an &lt;a href=&quot;unsupportedoperationexception&quot;&gt;&lt;code&gt;UnsupportedOperationException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">如果操作系统不支持进程的创建，则将引发&lt;a href=&quot;unsupportedoperationexception&quot;&gt; &lt;code&gt;UnsupportedOperationException&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7608927d8184c584cd9d11cef0e073e1bb7bf926" translate="yes" xml:space="preserve">
          <source>If the operation is a &lt;code&gt;draw(Shape)&lt;/code&gt; operation, then the &lt;a href=&quot;stroke#createStrokedShape(java.awt.Shape)&quot;&gt;&lt;code&gt;createStrokedShape&lt;/code&gt;&lt;/a&gt; method on the current &lt;a href=&quot;stroke&quot;&gt;&lt;code&gt;Stroke&lt;/code&gt;&lt;/a&gt; attribute in the &lt;code&gt;Graphics2D&lt;/code&gt; context is used to construct a new &lt;code&gt;Shape&lt;/code&gt; object that contains the outline of the specified &lt;code&gt;Shape&lt;/code&gt;.</source>
          <target state="translated">如果该操作是 &lt;code&gt;draw(Shape)&lt;/code&gt; 操作，则使用 &lt;code&gt;Graphics2D&lt;/code&gt; 上下文中当前&lt;a href=&quot;stroke&quot;&gt; &lt;code&gt;Stroke&lt;/code&gt; &lt;/a&gt;属性上的&lt;a href=&quot;stroke#createStrokedShape(java.awt.Shape)&quot;&gt; &lt;code&gt;createStrokedShape&lt;/code&gt; &lt;/a&gt;方法来构造一个新 &lt;code&gt;Shape&lt;/code&gt; 对象，该对象包含指定 &lt;code&gt;Shape&lt;/code&gt; 的轮廓。</target>
        </trans-unit>
        <trans-unit id="a3a6f1065b50c79f203f06252e6050cc498ea0ba" translate="yes" xml:space="preserve">
          <source>If the original type and new type are equal, returns &lt;code&gt;this&lt;/code&gt;.</source>
          <target state="translated">如果原始类型和新类型相等，则返回 &lt;code&gt;this&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="15d571df526b560a24fbbc6f542b12d585fc4182" translate="yes" xml:space="preserve">
          <source>If the original type and new type are equal, returns target.</source>
          <target state="translated">如果原始类型和新类型相同,返回target。</target>
        </trans-unit>
        <trans-unit id="d132531fc669e517a82a3d82919ac097d06f2259" translate="yes" xml:space="preserve">
          <source>If the other &lt;code&gt;StringJoiner&lt;/code&gt; is using a different delimiter, then elements from the other &lt;code&gt;StringJoiner&lt;/code&gt; are concatenated with that delimiter and the result is appended to this &lt;code&gt;StringJoiner&lt;/code&gt; as a single element.</source>
          <target state="translated">如果另一个 &lt;code&gt;StringJoiner&lt;/code&gt; 使用其他定界符，则来自另一个 &lt;code&gt;StringJoiner&lt;/code&gt; 的元素将与该定界符连接，并且结果将作为单个元素附加到此 &lt;code&gt;StringJoiner&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="613b81a7888d7292adb45fa99af137ae84272f3b" translate="yes" xml:space="preserve">
          <source>If the output is an &lt;code&gt;ImageOutputStream&lt;/code&gt;, the existing contents of the output prior to the current seek position are flushed, and need not be readable or writable. If the format requires that &lt;code&gt;endWriteSequence&lt;/code&gt; be able to rewind to patch up the header information, such as for a sequence of images in a single TIFF file, then the metadata written by this method must remain in a writable portion of the stream. Other formats may flush the stream after this method and after each image.</source>
          <target state="translated">如果输出是 &lt;code&gt;ImageOutputStream&lt;/code&gt; ，则将刷新当前查找位置之前输出的现有内容，并且不需要可读或可写。如果格式要求 &lt;code&gt;endWriteSequence&lt;/code&gt; 能够倒带以修补标头信息，例如单个TIFF文件中的图像序列，则用此方法编写的元数据必须保留在流的可写部分中。其他格式可能会在此方法之后和每个图像之后刷新流。</target>
        </trans-unit>
        <trans-unit id="08f1019969adaf9147a2917277718270a6117c0e" translate="yes" xml:space="preserve">
          <source>If the overall view is represented by many pieces (which is the best situation if one want to be able to change the view and write the least amount of new code), it would be impractical to have a huge number of &lt;code&gt;DocumentListener&lt;/code&gt;s. If each view listened to the model, only a few would actually be interested in the changes broadcasted at any given time. Since the model has no knowledge of views, it has no way to filter the broadcast of change information. The view hierarchy itself is instead responsible for propagating the change information. At any level in the view hierarchy, that view knows enough about its children to best distribute the change information further. Changes are therefore broadcasted starting from the root of the view hierarchy. The methods for doing this are:</source>
          <target state="translated">如果整个视图由很多部分表示（如果希望能够更改视图并编写最少数量的新代码，这是最好的情况），那么拥有大量 &lt;code&gt;DocumentListener&lt;/code&gt; 就是不切实际的。如果每个视图都收听模型，那么实际上只有少数几个视图会对在任何给定时间广播的更改感兴趣。由于模型不了解视图，因此无法过滤更改信息的广播。视图层次结构本身负责传播更改信息。在视图层次结构的任何级别上，该视图都足够了解其子级，从而可以更好地进一步分发更改信息。因此，更改是从视图层次结构的根开始广播的。执行此操作的方法是：</target>
        </trans-unit>
        <trans-unit id="78a74da7cebb7ba0feae1474dc321fbaaddcde66" translate="yes" xml:space="preserve">
          <source>If the owner document of the &lt;code&gt;DOMStructure&lt;/code&gt; is different than the target document of an &lt;code&gt;XMLSignature&lt;/code&gt;, the &lt;a href=&quot;../dsig/xmlsignature#sign(javax.xml.crypto.dsig.XMLSignContext)&quot;&gt;&lt;code&gt;XMLSignature.sign(XMLSignContext)&lt;/code&gt;&lt;/a&gt; method imports the node into the target document before generating the signature.</source>
          <target state="translated">如果 &lt;code&gt;DOMStructure&lt;/code&gt; 的所有者文档与 &lt;code&gt;XMLSignature&lt;/code&gt; 的目标文档不同，则&lt;a href=&quot;../dsig/xmlsignature#sign(javax.xml.crypto.dsig.XMLSignContext)&quot;&gt; &lt;code&gt;XMLSignature.sign(XMLSignContext)&lt;/code&gt; &lt;/a&gt;方法在生成签名之前将节点导入到目标文档中。</target>
        </trans-unit>
        <trans-unit id="fa93ae60cb7452d1a5da6932448d22165c4af9a2" translate="yes" xml:space="preserve">
          <source>If the parameter &quot;&lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#parameter-entities&quot;&gt;entities&lt;/a&gt;&quot; is set to &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;EntityReference&lt;/code&gt; nodes are serialized as an entity reference of the form &quot; &lt;code&gt;&amp;amp;entityName;&lt;/code&gt;&quot; in the output. Child nodes (the expansion) of the entity reference are ignored. If the parameter &quot;&lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#parameter-entities&quot;&gt;entities&lt;/a&gt;&quot; is set to &lt;code&gt;false&lt;/code&gt;, only the children of the entity reference are serialized. &lt;code&gt;EntityReference&lt;/code&gt; nodes with no children (no corresponding &lt;code&gt;Entity&lt;/code&gt; node or the corresponding &lt;code&gt;Entity&lt;/code&gt; nodes have no children) are always serialized.</source>
          <target state="translated">如果参数&amp;ldquo; &lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#parameter-entities&quot;&gt;entities&lt;/a&gt; &amp;rdquo;设置为 &lt;code&gt;true&lt;/code&gt; ，则在输出中将 &lt;code&gt;EntityReference&lt;/code&gt; 节点序列化为形式为&amp;ldquo; &lt;code&gt;&amp;amp;entityName;&lt;/code&gt; &amp;rdquo;的实体引用。实体引用的子节点（扩展）将被忽略。如果参数&amp;ldquo; &lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#parameter-entities&quot;&gt;entities&lt;/a&gt; &amp;rdquo;设置为 &lt;code&gt;false&lt;/code&gt; ，则仅对实体引用的子级进行序列化。没有子代的 &lt;code&gt;EntityReference&lt;/code&gt; 节点（没有对应的 &lt;code&gt;Entity&lt;/code&gt; 节点或对应的 &lt;code&gt;Entity&lt;/code&gt; 节点没有子代）总是被序列化。</target>
        </trans-unit>
        <trans-unit id="bb3ac957b69da27cb19dfba9a08e05602d603ed4" translate="yes" xml:space="preserve">
          <source>If the parameter &lt;code&gt;isId&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, this method declares the specified attribute to be a user-determined ID attribute .</source>
          <target state="translated">如果参数 &lt;code&gt;isId&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ，则此方法将指定的属性声明为用户确定的ID属性。</target>
        </trans-unit>
        <trans-unit id="41c4967bfb211978283a04544f0d61d21594df4d" translate="yes" xml:space="preserve">
          <source>If the parameter &lt;code&gt;isId&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, this method declares the specified attribute to be a user-determined ID attribute . This affects the value of &lt;code&gt;Attr.isId&lt;/code&gt; and the behavior of &lt;code&gt;Document.getElementById&lt;/code&gt;, but does not change any schema that may be in use, in particular this does not affect the &lt;code&gt;Attr.schemaTypeInfo&lt;/code&gt; of the specified &lt;code&gt;Attr&lt;/code&gt; node. Use the value &lt;code&gt;false&lt;/code&gt; for the parameter &lt;code&gt;isId&lt;/code&gt; to undeclare an attribute for being a user-determined ID attribute.</source>
          <target state="translated">如果参数 &lt;code&gt;isId&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ，则此方法将指定的属性声明为用户确定的ID属性。这会影响 &lt;code&gt;Attr.isId&lt;/code&gt; 的值和 &lt;code&gt;Document.getElementById&lt;/code&gt; 的行为，但不会更改任何正在使用的架构，特别是这不会影响指定 &lt;code&gt;Attr&lt;/code&gt; 节点的 &lt;code&gt;Attr.schemaTypeInfo&lt;/code&gt; 。对参数 &lt;code&gt;isId&lt;/code&gt; 使用值 &lt;code&gt;false&lt;/code&gt; 取消声明属性，使其成为用户确定的ID属性。</target>
        </trans-unit>
        <trans-unit id="170b05155c2fff91755b761f2183540c80aa9948" translate="yes" xml:space="preserve">
          <source>If the parameter does not have a user-defined or &lt;code&gt;REF&lt;/code&gt; type, the given &lt;code&gt;typeName&lt;/code&gt; parameter is ignored.</source>
          <target state="translated">如果参数不具有用户定义或 &lt;code&gt;REF&lt;/code&gt; 类型，则忽略给定的 &lt;code&gt;typeName&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="18c245a7f9ecfcc3d829455a0e0abe420832d2a6" translate="yes" xml:space="preserve">
          <source>If the parameter is negative or beyond the length of the document, the caret is placed at the beginning or at the end, respectively.</source>
          <target state="translated">如果参数为负值或超出文档的长度,则分别在文档的开头或结尾放置小圆点。</target>
        </trans-unit>
        <trans-unit id="8249c3394f9981a5c6710331cd767e75fd4509a3" translate="yes" xml:space="preserve">
          <source>If the parameters exist in XML form, the &lt;a href=&quot;#init(javax.xml.crypto.XMLStructure,javax.xml.crypto.XMLCryptoContext)&quot;&gt;&lt;code&gt;init(XMLStructure, XMLCryptoContext)&lt;/code&gt;&lt;/a&gt; method should be used to initialize the &lt;code&gt;TransformService&lt;/code&gt;.</source>
          <target state="translated">如果参数以XML形式存在，则应使用&lt;a href=&quot;#init(javax.xml.crypto.XMLStructure,javax.xml.crypto.XMLCryptoContext)&quot;&gt; &lt;code&gt;init(XMLStructure, XMLCryptoContext)&lt;/code&gt; &lt;/a&gt;方法来初始化 &lt;code&gt;TransformService&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a23d99be271523bb82052d907e3db3f2dbe428c3" translate="yes" xml:space="preserve">
          <source>If the parent is specified as &lt;code&gt;null&lt;/code&gt; (for the bootstrap class loader) then there is no guarantee that all platform classes are visible.</source>
          <target state="translated">如果将父级指定为 &lt;code&gt;null&lt;/code&gt; （对于引导类加载器），则不能保证所有平台类都是可见的。</target>
        </trans-unit>
        <trans-unit id="a54204b2e99d7d060bb6235389e37beb7f049e32" translate="yes" xml:space="preserve">
          <source>If the parse completes without reading the entire length of the text, or a problem occurs during parsing or merging, then an exception is thrown.</source>
          <target state="translated">如果解析完成后没有读取整个文本的长度,或者在解析或合并过程中出现问题,那么就会抛出一个异常。</target>
        </trans-unit>
        <trans-unit id="966672a90f95f435f932b758ca1be0521185c7b2" translate="yes" xml:space="preserve">
          <source>If the parsed set of schemas includes error(s) as specified in the section 5.1 of the XML Schema spec, then the error must be reported to the &lt;a href=&quot;../../../org/xml/sax/errorhandler&quot;&gt;&lt;code&gt;ErrorHandler&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果解析的模式集包含XML Schema规范第5.1节中指定的错误，则必须将错误报告给&lt;a href=&quot;../../../org/xml/sax/errorhandler&quot;&gt; &lt;code&gt;ErrorHandler&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1ec9adbbdbd63160216787347e59341d3fd1989d" translate="yes" xml:space="preserve">
          <source>If the parser has not read a declaration for the attribute, or if the parser does not report attribute types, then it must return the value &quot;CDATA&quot; as stated in the XML 1.0 Recommendation (clause 3.3.3, &quot;Attribute-Value Normalization&quot;).</source>
          <target state="translated">如果解析器没有读取属性的声明,或者解析器没有报告属性类型,那么它必须返回XML 1.0建议中所说的值 &quot;CDATA&quot;(条款3.3.3,&quot;属性-值标准化&quot;)。</target>
        </trans-unit>
        <trans-unit id="951efcf89e37dc37c87ce691e02e23742bc9d33e" translate="yes" xml:space="preserve">
          <source>If the parser has not read a declaration for the attribute, or if the parser does not report attribute types, then it must return the value &quot;CDATA&quot; as stated in the XML 1.0 Recommentation (clause 3.3.3, &quot;Attribute-Value Normalization&quot;).</source>
          <target state="translated">如果解析器没有读到属性的声明,或者解析器没有报告属性类型,那么就必须按照XML 1.0 Recommentation(条款3.3.3,&quot;属性-值归一化&quot;)中的规定,返回值 &quot;CDATA&quot;。</target>
        </trans-unit>
        <trans-unit id="ee0a795fb5ae860545c1f74e1564f3e8fc66414d" translate="yes" xml:space="preserve">
          <source>If the parser or application needs to include information about a specific location in an XML document, it should use the &lt;a href=&quot;saxparseexception&quot;&gt;&lt;code&gt;SAXParseException&lt;/code&gt;&lt;/a&gt; subclass.</source>
          <target state="translated">如果解析器或应用程序需要在XML文档中包括有关特定位置的信息，则应使用&lt;a href=&quot;saxparseexception&quot;&gt; &lt;code&gt;SAXParseException&lt;/code&gt; &lt;/a&gt;子类。</target>
        </trans-unit>
        <trans-unit id="27392b4b5ae25c2878c249c3152c3d3160b5375b" translate="yes" xml:space="preserve">
          <source>If the partialReturn property on the txt parameter is false, the data returned in the Segment will be the entire length requested and may or may not be a copy depending upon how the data was stored. If the partialReturn property is true, only the amount of text that can be returned without creating a copy is returned. Using partial returns will give better performance for situations where large parts of the document are being scanned. The following is an example of using the partial return to access the entire document:</source>
          <target state="translated">如果txt参数上的partialReturn属性为false,则Segment中返回的数据将是所请求的整个长度,可能是也可能不是副本,这取决于数据的存储方式。如果 partialReturn 属性为真,则只返回不创建副本的文本量。使用部分返回将为扫描文档的大部分内容的情况提供更好的性能。以下是使用部分返回来访问整个文档的示例。</target>
        </trans-unit>
        <trans-unit id="310a520f747ac0f430b2cb202c7289354ce38544" translate="yes" xml:space="preserve">
          <source>If the passed in operation is a &lt;a href=&quot;namespaceoperation&quot;&gt;&lt;code&gt;NamespaceOperation&lt;/code&gt;&lt;/a&gt;, or a &lt;a href=&quot;namedoperation&quot;&gt;&lt;code&gt;NamedOperation&lt;/code&gt;&lt;/a&gt; wrapping a &lt;a href=&quot;namespaceoperation&quot;&gt;&lt;code&gt;NamespaceOperation&lt;/code&gt;&lt;/a&gt;, then it returns the first (if any) &lt;a href=&quot;standardnamespace&quot;&gt;&lt;code&gt;StandardNamespace&lt;/code&gt;&lt;/a&gt; in its namespace list.</source>
          <target state="translated">如果传入的操作是&lt;a href=&quot;namespaceoperation&quot;&gt; &lt;code&gt;NamespaceOperation&lt;/code&gt; &lt;/a&gt;或包装&lt;a href=&quot;namespaceoperation&quot;&gt; &lt;code&gt;NamespaceOperation&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;namedoperation&quot;&gt; &lt;code&gt;NamedOperation&lt;/code&gt; &lt;/a&gt;，则它将在其命名空间列表中返回第一个（如果有的话）&lt;a href=&quot;standardnamespace&quot;&gt; &lt;code&gt;StandardNamespace&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a7bd44336d4b3666a0011d9d7cbae158269a6fd5" translate="yes" xml:space="preserve">
          <source>If the passed in operation is a &lt;a href=&quot;namespaceoperation&quot;&gt;&lt;code&gt;NamespaceOperation&lt;/code&gt;&lt;/a&gt;, or a &lt;a href=&quot;namedoperation&quot;&gt;&lt;code&gt;NamedOperation&lt;/code&gt;&lt;/a&gt; wrapping a &lt;a href=&quot;namespaceoperation&quot;&gt;&lt;code&gt;NamespaceOperation&lt;/code&gt;&lt;/a&gt;, then it returns the first (if any) &lt;a href=&quot;standardnamespace&quot;&gt;&lt;code&gt;StandardNamespace&lt;/code&gt;&lt;/a&gt; in its namespace list. If the passed operation is not a namespace operation (optionally wrapped in a named operation), or if it doesn't have any standard namespaces in it, returns &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">如果传入的操作是&lt;a href=&quot;namespaceoperation&quot;&gt; &lt;code&gt;NamespaceOperation&lt;/code&gt; &lt;/a&gt;或包装&lt;a href=&quot;namespaceoperation&quot;&gt; &lt;code&gt;NamespaceOperation&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;namedoperation&quot;&gt; &lt;code&gt;NamedOperation&lt;/code&gt; &lt;/a&gt;，则它将在其命名空间列表中返回第一个（如果有的话）&lt;a href=&quot;standardnamespace&quot;&gt; &lt;code&gt;StandardNamespace&lt;/code&gt; &lt;/a&gt;。如果传递的操作不是名称空间操作（可选地包装在命名操作中），或者其中没有任何标准名称空间，则返回 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="79d69da696a97838674e241d7ea5d2d8014fb0e5" translate="yes" xml:space="preserve">
          <source>If the passed operation is a named operation, returns its &lt;a href=&quot;#getBaseOperation()&quot;&gt;&lt;code&gt;getBaseOperation()&lt;/code&gt;&lt;/a&gt;, otherwise returns the operation as is.</source>
          <target state="translated">如果传递的操作是命名操作，则返回其&lt;a href=&quot;#getBaseOperation()&quot;&gt; &lt;code&gt;getBaseOperation()&lt;/code&gt; &lt;/a&gt;，否则按原样返回操作。</target>
        </trans-unit>
        <trans-unit id="d934bcf86fcc533735822d99eeae5629daf70231" translate="yes" xml:space="preserve">
          <source>If the passed operation is a named operation, returns its &lt;a href=&quot;#getName()&quot;&gt;&lt;code&gt;getName()&lt;/code&gt;&lt;/a&gt;, otherwise returns null.</source>
          <target state="translated">如果传递的操作是命名操作，则返回其&lt;a href=&quot;#getName()&quot;&gt; &lt;code&gt;getName()&lt;/code&gt; &lt;/a&gt;，否则返回null。</target>
        </trans-unit>
        <trans-unit id="955cd55c42b1c749bf0d0200c01dd32b47c3552c" translate="yes" xml:space="preserve">
          <source>If the passed operation is a named operation, returns its &lt;a href=&quot;#getName()&quot;&gt;&lt;code&gt;getName()&lt;/code&gt;&lt;/a&gt;, otherwise returns null. Note that a named operation object can never have a null name, therefore returning null is indicative that the passed operation is not, in fact, a named operation.</source>
          <target state="translated">如果传递的操作是命名操作，则返回其&lt;a href=&quot;#getName()&quot;&gt; &lt;code&gt;getName()&lt;/code&gt; &lt;/a&gt;，否则返回null。请注意，命名操作对象永远不能具有null名称，因此返回null表示传递的操作实际上不是命名操作。</target>
        </trans-unit>
        <trans-unit id="b6f8e527f319773c3b4cecd9c9f7becb955367cb" translate="yes" xml:space="preserve">
          <source>If the passed operation is a namespace operation, returns its &lt;a href=&quot;#getBaseOperation()&quot;&gt;&lt;code&gt;getBaseOperation()&lt;/code&gt;&lt;/a&gt;, otherwise returns the operation as is.</source>
          <target state="translated">如果传递的操作是名称空间操作，则返回其&lt;a href=&quot;#getBaseOperation()&quot;&gt; &lt;code&gt;getBaseOperation()&lt;/code&gt; &lt;/a&gt;，否则按原样返回操作。</target>
        </trans-unit>
        <trans-unit id="a1c652576684afac677e6258e3c80046a8f1e595" translate="yes" xml:space="preserve">
          <source>If the passed operation is a namespace operation, returns its &lt;a href=&quot;#getNamespaces()&quot;&gt;&lt;code&gt;getNamespaces()&lt;/code&gt;&lt;/a&gt;, otherwise returns an empty array.</source>
          <target state="translated">如果传递的操作是名称空间操作，则返回其&lt;a href=&quot;#getNamespaces()&quot;&gt; &lt;code&gt;getNamespaces()&lt;/code&gt; &lt;/a&gt;，否则返回空数组。</target>
        </trans-unit>
        <trans-unit id="5ed75a33bb4145623122f20c780e9bac95e43865" translate="yes" xml:space="preserve">
          <source>If the path is relative, and if its first segment contains a colon character (&lt;code&gt;':'&lt;/code&gt;), then a &lt;code&gt;&quot;.&quot;&lt;/code&gt; segment is prepended. This prevents a relative URI with a path such as &lt;code&gt;&quot;a:b/c/d&quot;&lt;/code&gt; from later being re-parsed as an opaque URI with a scheme of &lt;code&gt;&quot;a&quot;&lt;/code&gt; and a scheme-specific part of &lt;code&gt;&quot;b/c/d&quot;&lt;/code&gt;. &lt;b&gt;&lt;i&gt;(Deviation from RFC 2396)&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">如果路径是相对的，并且路径的第一段包含冒号（ &lt;code&gt;':'&lt;/code&gt; ），则为 &lt;code&gt;&quot;.&quot;&lt;/code&gt; 段之前。这样可以防止以后将路径为 &lt;code&gt;&quot;a:b/c/d&quot;&lt;/code&gt; 的相对URI 重新解析为方案 &lt;code&gt;&quot;a&quot;&lt;/code&gt; 和方案特定部分 &lt;code&gt;&quot;b/c/d&quot;&lt;/code&gt; 的不透明URI。。&lt;b&gt;&lt;i&gt;（偏离RFC 2396）&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="bd2e4303923c73137d6318c7fb1a6ecc2cd9b62d" translate="yes" xml:space="preserve">
          <source>If the pattern contains &quot;/&quot;, the non-empty prefix up to the &quot;/&quot; is the module name; if the module name matches the module name of the class then the remaining pattern is matched with the class name. If there is no &quot;/&quot;, the module name is not compared.</source>
          <target state="translated">如果模式中包含&quot;/&quot;,则&quot;/&quot;之前的非空前缀为模块名;如果模块名与类的模块名相匹配,则剩余模式与类名相匹配。如果没有&quot;/&quot;,则不比较模块名。</target>
        </trans-unit>
        <trans-unit id="47d65275395c58dc9640d193b6ab38182a27d80c" translate="yes" xml:space="preserve">
          <source>If the pattern ends with &quot;*&quot;, it matches any class with the pattern as a prefix.</source>
          <target state="translated">如果模式以 &quot;*&quot;结尾,它将匹配任何以模式为前缀的类。</target>
        </trans-unit>
        <trans-unit id="2b99798368562eadf341b3140c731a962ac17514" translate="yes" xml:space="preserve">
          <source>If the pattern ends with &quot;.*&quot; it matches any class in the package.</source>
          <target state="translated">如果模式以&quot;.*&quot;结尾,则匹配包中的任何类。</target>
        </trans-unit>
        <trans-unit id="64908fcc581dd6ae74cbec11495eb53bd054a169" translate="yes" xml:space="preserve">
          <source>If the pattern ends with &quot;.**&quot; it matches any class in the package and all subpackages.</source>
          <target state="translated">如果模式以&quot;.**&quot;结尾,则匹配包中的任何类和所有子包。</target>
        </trans-unit>
        <trans-unit id="d4631732bf01387295ef2c9727234cf63af52f66" translate="yes" xml:space="preserve">
          <source>If the pattern is equal to the class name, it matches.</source>
          <target state="translated">如果模式与类名相等,则匹配。</target>
        </trans-unit>
        <trans-unit id="72a8f0cca7462c028e15e68df7691503088ae3a6" translate="yes" xml:space="preserve">
          <source>If the pattern letter is 'v' the output provides the zone name ignoring daylight savings time. If the count of letters is one, then the short name is output. If the count of letters is four, then the full name is output. Two, three and five or more letters throw &lt;code&gt;IllegalArgumentException&lt;/code&gt;.</source>
          <target state="translated">如果模式字母为&amp;ldquo; v&amp;rdquo;，则输出将提供忽略夏令时的区域名称。如果字母数为1，则输出简称。如果字母数为4，则输出全名。两个，三个和五个或更多个字母抛出 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2047fa1b9e42f9c7566436cd904af026a1d6b5e2" translate="yes" xml:space="preserve">
          <source>If the pattern starts with &quot;!&quot;, the class is rejected if the remaining pattern is matched; otherwise the class is allowed if the pattern matches.</source>
          <target state="translated">如果模式以&quot;!&quot;开头,则剩余模式匹配,则拒绝该类;否则模式匹配,则允许该类。</target>
        </trans-unit>
        <trans-unit id="87a4c8fb790be59120806baf097d003e2948d992" translate="yes" xml:space="preserve">
          <source>If the pending count is nonzero, (atomically) decrements it.</source>
          <target state="translated">如果待定计数是非零,(原子地)将其递减。</target>
        </trans-unit>
        <trans-unit id="8ad7048ac80247a957da8eeed8a41a5f37a54c39" translate="yes" xml:space="preserve">
          <source>If the pending count is nonzero, decrements the count; otherwise invokes &lt;a href=&quot;#onCompletion(java.util.concurrent.CountedCompleter)&quot;&gt;&lt;code&gt;onCompletion(CountedCompleter)&lt;/code&gt;&lt;/a&gt; and then similarly tries to complete this task's completer, if one exists, else marks this task as complete.</source>
          <target state="translated">如果未决计数为非零，则减少计数；否则，计数为0。否则，调用&lt;a href=&quot;#onCompletion(java.util.concurrent.CountedCompleter)&quot;&gt; &lt;code&gt;onCompletion(CountedCompleter)&lt;/code&gt; &lt;/a&gt;，然后类似地尝试完成此任务的完成者（如果存在），否则将其标记为完成。</target>
        </trans-unit>
        <trans-unit id="e572cb5e5dee791d5b39d6f57ac77915682e21a1" translate="yes" xml:space="preserve">
          <source>If the pending count is nonzero, decrements the count; otherwise invokes &lt;a href=&quot;countedcompleter#onCompletion-java.util.concurrent.CountedCompleter-&quot;&gt;&lt;code&gt;onCompletion(CountedCompleter)&lt;/code&gt;&lt;/a&gt; and then similarly tries to complete this task's completer, if one exists, else marks this task as complete.</source>
          <target state="translated">如果未决计数为非零，则减少计数；否则，计数为0。否则，调用&lt;a href=&quot;countedcompleter#onCompletion-java.util.concurrent.CountedCompleter-&quot;&gt; &lt;code&gt;onCompletion(CountedCompleter)&lt;/code&gt; &lt;/a&gt;，然后类似地尝试完成此任务的完成者（如果存在），否则将其标记为完成。</target>
        </trans-unit>
        <trans-unit id="bc17ec5f581dec30fa586e110a04b1eaf5b5b327" translate="yes" xml:space="preserve">
          <source>If the permit is available then it is consumed and the call returns immediately; otherwise the current thread becomes disabled for thread scheduling purposes and lies dormant until one of four things happens:</source>
          <target state="translated">如果许可是可用的,那么它就会被消耗掉,并立即返回调用;否则当前线程就会为了线程调度的目的而被禁用,并处于休眠状态,直到四种情况之一发生。</target>
        </trans-unit>
        <trans-unit id="d4223a7d1829a5930922236b794117f0ecfa3ef5" translate="yes" xml:space="preserve">
          <source>If the permit is available then it is consumed and the call returns immediately; otherwise the current thread becomes disabled for thread scheduling purposes and lies dormant until one of three things happens:</source>
          <target state="translated">如果许可是可用的,那么它就会被消耗掉,并立即返回调用;否则当前线程就会为了线程调度的目的而被禁用,并处于休眠状态,直到三种情况之一发生。</target>
        </trans-unit>
        <trans-unit id="1c7072c32b05b6fd0de10d7da5998d3dbfa5ec38" translate="yes" xml:space="preserve">
          <source>If the permits are acquired then the value &lt;code&gt;true&lt;/code&gt; is returned.</source>
          <target state="translated">如果获得许可，则返回值 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4cea382e9b6e94d448d8b5b7931ce98c85d158e1" translate="yes" xml:space="preserve">
          <source>If the persist field of the attribute's descriptor is not null then Persistence policy from the attribute descriptor is used to guide storing the attribute in a persistent store.</source>
          <target state="translated">如果属性描述符的持久化字段不是空的,那么来自属性描述符的持久化策略就被用来指导将属性存储在持久化存储中。</target>
        </trans-unit>
        <trans-unit id="0f4b331cf13e540556f5aca90f86b4e8ad5c60f9" translate="yes" xml:space="preserve">
          <source>If the plug-in does not handle image metadata, null should be returned.</source>
          <target state="translated">如果插件不处理图像元数据,应返回null。</target>
        </trans-unit>
        <trans-unit id="aab4c0c381c1b7fcd5929e45b451378e4a93f9be" translate="yes" xml:space="preserve">
          <source>If the plug-in does not handle metadata, null should be returned.</source>
          <target state="translated">如果插件不处理元数据,应返回null。</target>
        </trans-unit>
        <trans-unit id="06277a1c71d67301bd303d6a030fc9040d866b9c" translate="yes" xml:space="preserve">
          <source>If the point is colinear with the line segment, but not between the end points, then the value will be -1 if the point lies &quot;beyond &lt;code&gt;(x1,y1)&lt;/code&gt;&quot; or 1 if the point lies &quot;beyond &lt;code&gt;(x2,y2)&lt;/code&gt;&quot;.</source>
          <target state="translated">如果该点与线段共线，但不在端点之间，则如果该点位于&amp;ldquo;超出 &lt;code&gt;(x1,y1)&lt;/code&gt; &amp;rdquo; ，则该值为-1；如果该点位于&amp;ldquo;超出 &lt;code&gt;(x2,y2)&lt;/code&gt; &amp;rdquo; ，则该值为1。。</target>
        </trans-unit>
        <trans-unit id="566f0e2c0058f212146ef4067827ea84b517258f" translate="yes" xml:space="preserve">
          <source>If the pool currently has more than corePoolSize threads, excess threads will be terminated if they have been idle for more than the keepAliveTime (see &lt;a href=&quot;#getKeepAliveTime(java.util.concurrent.TimeUnit)&quot;&gt;&lt;code&gt;getKeepAliveTime(TimeUnit)&lt;/code&gt;&lt;/a&gt;). This provides a means of reducing resource consumption when the pool is not being actively used. If the pool becomes more active later, new threads will be constructed. This parameter can also be changed dynamically using method &lt;a href=&quot;#setKeepAliveTime(long,java.util.concurrent.TimeUnit)&quot;&gt;&lt;code&gt;setKeepAliveTime(long,
 TimeUnit)&lt;/code&gt;&lt;/a&gt;. Using a value of &lt;code&gt;Long.MAX_VALUE&lt;/code&gt;&lt;a href=&quot;timeunit#NANOSECONDS&quot;&gt;&lt;code&gt;TimeUnit.NANOSECONDS&lt;/code&gt;&lt;/a&gt; effectively disables idle threads from ever terminating prior to shut down. By default, the keep-alive policy applies only when there are more than corePoolSize threads, but method &lt;a href=&quot;#allowCoreThreadTimeOut(boolean)&quot;&gt;&lt;code&gt;allowCoreThreadTimeOut(boolean)&lt;/code&gt;&lt;/a&gt; can be used to apply this time-out policy to core threads as well, so long as the keepAliveTime value is non-zero.</source>
          <target state="translated">如果当前池中的线程数超过corePoolSize，则多余的线程将在空闲时间超过keepAliveTime时终止（请参见&lt;a href=&quot;#getKeepAliveTime(java.util.concurrent.TimeUnit)&quot;&gt; &lt;code&gt;getKeepAliveTime(TimeUnit)&lt;/code&gt; &lt;/a&gt;）。当不积极使用池时，这提供了一种减少资源消耗的方法。如果池稍后变得更活跃，则将构建新线程。也可以使用&lt;a href=&quot;#setKeepAliveTime(long,java.util.concurrent.TimeUnit)&quot;&gt; &lt;code&gt;setKeepAliveTime(long, TimeUnit)&lt;/code&gt; &lt;/a&gt;方法动态更改此参数。使用 &lt;code&gt;Long.MAX_VALUE&lt;/code&gt; &lt;a href=&quot;timeunit#NANOSECONDS&quot;&gt; &lt;code&gt;TimeUnit.NANOSECONDS&lt;/code&gt; &lt;/a&gt;值可以有效地使空闲线程永远不会在关闭之前终止。默认情况下，仅当存在多个corePoolSize线程时，保持活动策略才适用，但是方法&lt;a href=&quot;#allowCoreThreadTimeOut(boolean)&quot;&gt; &lt;code&gt;allowCoreThreadTimeOut(boolean)&lt;/code&gt; &lt;/a&gt; 只要keepAliveTime值不为零，也可以将超时策略应用于核心线程。</target>
        </trans-unit>
        <trans-unit id="5bf226ccbe41713d478e11aab7ab361a597353a7" translate="yes" xml:space="preserve">
          <source>If the pool currently has more than corePoolSize threads, excess threads will be terminated if they have been idle for more than the keepAliveTime (see &lt;a href=&quot;threadpoolexecutor#getKeepAliveTime-java.util.concurrent.TimeUnit-&quot;&gt;&lt;code&gt;getKeepAliveTime(TimeUnit)&lt;/code&gt;&lt;/a&gt;). This provides a means of reducing resource consumption when the pool is not being actively used. If the pool becomes more active later, new threads will be constructed. This parameter can also be changed dynamically using method &lt;a href=&quot;threadpoolexecutor#setKeepAliveTime-long-java.util.concurrent.TimeUnit-&quot;&gt;&lt;code&gt;setKeepAliveTime(long,
 TimeUnit)&lt;/code&gt;&lt;/a&gt;. Using a value of &lt;code&gt;Long.MAX_VALUE&lt;/code&gt;&lt;a href=&quot;timeunit#NANOSECONDS&quot;&gt;&lt;code&gt;TimeUnit.NANOSECONDS&lt;/code&gt;&lt;/a&gt; effectively disables idle threads from ever terminating prior to shut down. By default, the keep-alive policy applies only when there are more than corePoolSize threads. But method &lt;a href=&quot;threadpoolexecutor#allowCoreThreadTimeOut-boolean-&quot;&gt;&lt;code&gt;allowCoreThreadTimeOut(boolean)&lt;/code&gt;&lt;/a&gt; can be used to apply this time-out policy to core threads as well, so long as the keepAliveTime value is non-zero.</source>
          <target state="translated">如果当前池中的线程数超过corePoolSize，则多余的线程将在空闲时间超过keepAliveTime时终止（请参见&lt;a href=&quot;threadpoolexecutor#getKeepAliveTime-java.util.concurrent.TimeUnit-&quot;&gt; &lt;code&gt;getKeepAliveTime(TimeUnit)&lt;/code&gt; &lt;/a&gt;）。当不积极使用池时，这提供了减少资源消耗的方法。如果池稍后变得更加活跃，则将构建新线程。也可以使用&lt;a href=&quot;threadpoolexecutor#setKeepAliveTime-long-java.util.concurrent.TimeUnit-&quot;&gt; &lt;code&gt;setKeepAliveTime(long, TimeUnit)&lt;/code&gt; &lt;/a&gt;方法动态更改此参数。使用 &lt;code&gt;Long.MAX_VALUE&lt;/code&gt; &lt;a href=&quot;timeunit#NANOSECONDS&quot;&gt; &lt;code&gt;TimeUnit.NANOSECONDS&lt;/code&gt; &lt;/a&gt;值可以有效地使空闲线程永远不会在关闭之前终止。默认情况下，仅当corePoolSize线程数多时，保持活动策略才适用。但是方法&lt;a href=&quot;threadpoolexecutor#allowCoreThreadTimeOut-boolean-&quot;&gt; &lt;code&gt;allowCoreThreadTimeOut(boolean)&lt;/code&gt; &lt;/a&gt; 只要keepAliveTime值不为零，也可以将超时策略应用于核心线程。</target>
        </trans-unit>
        <trans-unit id="9a3ff33f4d5e297ea7ec3916317d36251a2ccb95" translate="yes" xml:space="preserve">
          <source>If the prefix is &quot;GMT&quot;, &quot;UTC&quot;, or &quot;UT&quot; a &lt;code&gt;ZoneId&lt;/code&gt; with the prefix and the non-zero offset is returned. If the prefix is empty &lt;code&gt;&quot;&quot;&lt;/code&gt; the &lt;code&gt;ZoneOffset&lt;/code&gt; is returned.</source>
          <target state="translated">如果前缀为&amp;ldquo; GMT&amp;rdquo;，&amp;ldquo; UTC&amp;rdquo;或&amp;ldquo; UT&amp;rdquo;，则 &lt;code&gt;ZoneId&lt;/code&gt; 带有前缀且非零偏移量的ZoneId。如果前缀为空 &lt;code&gt;&quot;&quot;&lt;/code&gt; ，则返回 &lt;code&gt;ZoneOffset&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a88d71fc9f54022eac4890ef06a233fa0844cac0" translate="yes" xml:space="preserve">
          <source>If the prefix is &lt;code&gt;null&lt;/code&gt;, an &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown. Use &lt;a href=&quot;../xmlconstants#DEFAULT_NS_PREFIX&quot;&gt;&lt;code&gt;XMLConstants.DEFAULT_NS_PREFIX&lt;/code&gt;&lt;/a&gt; to explicitly indicate that no prefix is present or the prefix is not relevant.</source>
          <target state="translated">如果前缀为 &lt;code&gt;null&lt;/code&gt; ，则抛出 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 。使用&lt;a href=&quot;../xmlconstants#DEFAULT_NS_PREFIX&quot;&gt; &lt;code&gt;XMLConstants.DEFAULT_NS_PREFIX&lt;/code&gt; &lt;/a&gt;明确指示不存在前缀或该前缀不相关。</target>
        </trans-unit>
        <trans-unit id="2958ef27e71136debb4afdbdf265b117d00e567e" translate="yes" xml:space="preserve">
          <source>If the present length of the file as returned by the &lt;code&gt;length&lt;/code&gt; method is greater than the &lt;code&gt;newLength&lt;/code&gt; argument then the file will be truncated. In this case, if the file offset as returned by the &lt;code&gt;getFilePointer&lt;/code&gt; method is greater than &lt;code&gt;newLength&lt;/code&gt; then after this method returns the offset will be equal to &lt;code&gt;newLength&lt;/code&gt;.</source>
          <target state="translated">如果使用 &lt;code&gt;length&lt;/code&gt; 方法返回的文件的当前长度大于 &lt;code&gt;newLength&lt;/code&gt; 参数，则文件将被截断。在这种情况下，如果 &lt;code&gt;getFilePointer&lt;/code&gt; 方法返回的文件偏移量大于 &lt;code&gt;newLength&lt;/code&gt; ,则此方法返回后，偏移量将等于 &lt;code&gt;newLength&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9cef2b80409c01c0c853b230c56f0ff2824529e5" translate="yes" xml:space="preserve">
          <source>If the present length of the file as returned by the &lt;code&gt;length&lt;/code&gt; method is smaller than the &lt;code&gt;newLength&lt;/code&gt; argument then the file will be extended. In this case, the contents of the extended portion of the file are not defined.</source>
          <target state="translated">如果使用 &lt;code&gt;length&lt;/code&gt; 方法返回的文件的当前长度小于 &lt;code&gt;newLength&lt;/code&gt; 参数，则将扩展文件。在这种情况下，未定义文件扩展部分的内容。</target>
        </trans-unit>
        <trans-unit id="087d7d53cb32d81d4bb2e8d37c5e0f4bd813cb56" translate="yes" xml:space="preserve">
          <source>If the previous step fails to find a protocol handler, the constructor reads the value of the system property:</source>
          <target state="translated">如果上一步未能找到协议处理程序,构造函数会读取系统属性的值。</target>
        </trans-unit>
        <trans-unit id="c6c92eb74a9e692df342c2385a09b40d4ef27afc" translate="yes" xml:space="preserve">
          <source>If the previous step fails to find a protocol handler, then the constructor tries to load a built-in protocol handler. If this class does not exist, or if the class exists but it is not a subclass of &lt;code&gt;URLStreamHandler&lt;/code&gt;, then a &lt;code&gt;MalformedURLException&lt;/code&gt; is thrown.</source>
          <target state="translated">如果上一步未能找到协议处理程序，则构造函数将尝试加载内置协议处理程序。如果此类不存在，或者存在，但它不是 &lt;code&gt;URLStreamHandler&lt;/code&gt; 的子类，则抛出 &lt;code&gt;MalformedURLException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dec7b0fc3a3fa3565bc2b4d09d4d15db4b1e4a93" translate="yes" xml:space="preserve">
          <source>If the previous step fails to find a protocol handler, then the constructor tries to load from a system default package.</source>
          <target state="translated">如果上一步未能找到协议处理程序,那么构造函数会尝试从系统默认包中加载。</target>
        </trans-unit>
        <trans-unit id="6585f9f7ecc69964ba3abd119ebdf439ff37f98d" translate="yes" xml:space="preserve">
          <source>If the previous step has found no resource bundle, proceed to Step 6. If a bundle has been found that is a base bundle (a bundle for &lt;code&gt;Locale(&quot;&quot;)&lt;/code&gt;), and the candidate locale list only contained &lt;code&gt;Locale(&quot;&quot;)&lt;/code&gt;, return the bundle to the caller. If a bundle has been found that is a base bundle, but the candidate locale list contained locales other than Locale(&quot;&quot;), put the bundle on hold and proceed to Step 6. If a bundle has been found that is not a base bundle, proceed to Step 7.</source>
          <target state="translated">如果上一步没有找到资源束，请继续执行步骤6。如果找到了一个作为基本束的束（ &lt;code&gt;Locale(&quot;&quot;)&lt;/code&gt; 束），并且候选语言环境列表仅包含 &lt;code&gt;Locale(&quot;&quot;)&lt;/code&gt; ，将捆绑包返回给调用者。如果找到的捆绑包是基本捆绑包，但是候选语言环境列表包含的语言环境不是Locale（&amp;ldquo;&amp;rdquo;），则将该捆绑包置于保留状态，然后继续执行步骤6。如果找到的捆绑包不是基本捆绑包， ，继续执行步骤7。</target>
        </trans-unit>
        <trans-unit id="ea2595038e3728d521540b9e147c81e0fa793394" translate="yes" xml:space="preserve">
          <source>If the principal system property or key is already provided, the value of &quot;javax.security.auth.login.name&quot; in the shared state is ignored.</source>
          <target state="translated">如果已经提供了主系统属性或密钥,则忽略共享状态中 &quot;javax.security.auth.login.name &quot;的值。</target>
        </trans-unit>
        <trans-unit id="6778bed4bae7f4aceabe96f43a91b258db12e0c7" translate="yes" xml:space="preserve">
          <source>If the print data is a stream, or a print job requests data as a stream, then &lt;code&gt;SimpleDoc&lt;/code&gt; does not monitor if the service properly closes the stream after data transfer completion or job termination. Clients may prefer to use provide their own implementation of doc that adds a listener to monitor job completion and to validate that resources such as streams are freed (ie closed).</source>
          <target state="translated">如果打印数据是流，或者打印作业请求将数据作为流，则 &lt;code&gt;SimpleDoc&lt;/code&gt; 不会监视服务在数据传输完成或作业终止后是否正确关闭了该流。客户可能更喜欢使用自己提供的doc实现，添加一个侦听器以监视作业完成并验证诸如流之类的资源是否已释放（即关闭）。</target>
        </trans-unit>
        <trans-unit id="bebb66852f6964b9bd2e3cea1ce8a7ef48446b3a" translate="yes" xml:space="preserve">
          <source>If the process has already terminated then this method returns immediately with the value &lt;code&gt;true&lt;/code&gt;. If the process has not terminated and the timeout value is less than, or equal to, zero, then this method returns immediately with the value &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果该进程已经终止，则此方法将立即返回 &lt;code&gt;true&lt;/code&gt; 值。如果进程尚未终止，并且超时值小于或等于零，则此方法立即返回 &lt;code&gt;false&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="b6c209a5eafb6c3fed5697bfbb41d0d1e8b8dc27" translate="yes" xml:space="preserve">
          <source>If the processor class is annotated with &lt;a href=&quot;supportedannotationtypes&quot;&gt;&lt;code&gt;SupportedAnnotationTypes&lt;/code&gt;&lt;/a&gt;, return an unmodifiable set with the same set of strings as the annotation.</source>
          <target state="translated">如果处理器类使用&lt;a href=&quot;supportedannotationtypes&quot;&gt; &lt;code&gt;SupportedAnnotationTypes&lt;/code&gt; 进行&lt;/a&gt;注释，则返回一个不可修改的集合，该集合具有与注释相同的字符串集。</target>
        </trans-unit>
        <trans-unit id="88bf35bed53cf1a7b9c25c4c647bfc4d663ad0d2" translate="yes" xml:space="preserve">
          <source>If the processor class is annotated with &lt;a href=&quot;supportedannotationtypes&quot;&gt;&lt;code&gt;SupportedAnnotationTypes&lt;/code&gt;&lt;/a&gt;, return an unmodifiable set with the same set of strings as the annotation. If the class is not so annotated, an empty set is returned.</source>
          <target state="translated">如果处理器类使用&lt;a href=&quot;supportedannotationtypes&quot;&gt; &lt;code&gt;SupportedAnnotationTypes&lt;/code&gt; 进行了&lt;/a&gt;注释，则返回一个不可修改的集合，该集合具有与注释相同的字符串集。如果未对类进行注释，则返回一个空集。</target>
        </trans-unit>
        <trans-unit id="f41793fe3304ceb1d00d62771a4aa39cb3d71ae7" translate="yes" xml:space="preserve">
          <source>If the processor class is annotated with &lt;a href=&quot;supportedannotationtypes&quot;&gt;&lt;code&gt;SupportedAnnotationTypes&lt;/code&gt;&lt;/a&gt;, return an unmodifiable set with the same set of strings as the annotation. If the class is not so annotated, an empty set is returned. If the &lt;a href=&quot;processingenvironment#getSourceVersion()&quot;&gt;&lt;code&gt;source
 version&lt;/code&gt;&lt;/a&gt; does not support modules, in other words if it is less than or equal to &lt;a href=&quot;../../lang/model/sourceversion#RELEASE_8&quot;&gt;&lt;code&gt;RELEASE_8&lt;/code&gt;&lt;/a&gt;, then any leading &lt;a href=&quot;processor#getSupportedAnnotationTypes()&quot;&gt;&lt;code&gt;module prefixes&lt;/code&gt;&lt;/a&gt; are stripped from the names.</source>
          <target state="translated">如果处理器类使用&lt;a href=&quot;supportedannotationtypes&quot;&gt; &lt;code&gt;SupportedAnnotationTypes&lt;/code&gt; 进行&lt;/a&gt;注释，则返回一个不可修改的集合，该集合具有与注释相同的字符串集。如果未对类进行注释，则返回一个空集。如果&lt;a href=&quot;processingenvironment#getSourceVersion()&quot;&gt; &lt;code&gt;source version&lt;/code&gt; &lt;/a&gt;不支持模块，也就是说，如果源版本小于或等于&lt;a href=&quot;../../lang/model/sourceversion#RELEASE_8&quot;&gt; &lt;code&gt;RELEASE_8&lt;/code&gt; &lt;/a&gt;，那么将从名称中删除任何前导&lt;a href=&quot;processor#getSupportedAnnotationTypes()&quot;&gt; &lt;code&gt;module prefixes&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7d2a0bffaf2c47cc7d7f992548c87fe48e574cab" translate="yes" xml:space="preserve">
          <source>If the processor class is annotated with &lt;a href=&quot;supportedannotationtypes&quot;&gt;&lt;code&gt;SupportedAnnotationTypes&lt;/code&gt;&lt;/a&gt;, return an unmodifiable set with the same set of strings as the annotation. If the class is not so annotated, an empty set is returned. If the &lt;a href=&quot;processingenvironment#getSourceVersion()&quot;&gt;source version&lt;/a&gt; does not support modules, in other words if it is less than or equal to &lt;a href=&quot;../../lang/model/sourceversion#RELEASE_8&quot;&gt;&lt;code&gt;RELEASE_8&lt;/code&gt;&lt;/a&gt;, then any leading &lt;a href=&quot;processor#getSupportedAnnotationTypes()&quot;&gt;module prefixes&lt;/a&gt; are stripped from the names.</source>
          <target state="translated">如果处理器类使用&lt;a href=&quot;supportedannotationtypes&quot;&gt; &lt;code&gt;SupportedAnnotationTypes&lt;/code&gt; 进行&lt;/a&gt;注释，则返回一个不可修改的集合，该集合具有与注释相同的字符串集。如果未对类进行注释，则返回一个空集。如果&lt;a href=&quot;processingenvironment#getSourceVersion()&quot;&gt;源版本&lt;/a&gt;不支持模块，也就是说，如果源版本小于或等于&lt;a href=&quot;../../lang/model/sourceversion#RELEASE_8&quot;&gt; &lt;code&gt;RELEASE_8&lt;/code&gt; &lt;/a&gt;，那么将从名称中删除任何前导&lt;a href=&quot;processor#getSupportedAnnotationTypes()&quot;&gt;模块前缀&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d3f67fa776d861f7bdbdce342363185f87f166e6" translate="yes" xml:space="preserve">
          <source>If the processor class is annotated with &lt;a href=&quot;supportedoptions&quot;&gt;&lt;code&gt;SupportedOptions&lt;/code&gt;&lt;/a&gt;, return an unmodifiable set with the same set of strings as the annotation.</source>
          <target state="translated">如果处理器类使用&lt;a href=&quot;supportedoptions&quot;&gt; &lt;code&gt;SupportedOptions&lt;/code&gt; 进行了&lt;/a&gt;注释，则返回一个不可修改的集合，该集合具有与注释相同的字符串集。</target>
        </trans-unit>
        <trans-unit id="09f9046e5ee10b9263ce6a07905ea1779eccbaa9" translate="yes" xml:space="preserve">
          <source>If the processor class is annotated with &lt;a href=&quot;supportedoptions&quot;&gt;&lt;code&gt;SupportedOptions&lt;/code&gt;&lt;/a&gt;, return an unmodifiable set with the same set of strings as the annotation. If the class is not so annotated, an empty set is returned.</source>
          <target state="translated">如果处理器类使用&lt;a href=&quot;supportedoptions&quot;&gt; &lt;code&gt;SupportedOptions&lt;/code&gt; 进行了&lt;/a&gt;注释，则返回一个不可修改的集合，该集合具有与注释相同的字符串集。如果未对类进行注释，则返回一个空集。</target>
        </trans-unit>
        <trans-unit id="b36cf0c2beb0dbdd953aff6325943dc74920fe4e" translate="yes" xml:space="preserve">
          <source>If the processor class is annotated with &lt;a href=&quot;supportedsourceversion&quot;&gt;&lt;code&gt;SupportedSourceVersion&lt;/code&gt;&lt;/a&gt;, return the source version in the annotation.</source>
          <target state="translated">如果处理器类使用&lt;a href=&quot;supportedsourceversion&quot;&gt; &lt;code&gt;SupportedSourceVersion&lt;/code&gt; &lt;/a&gt;进行了注释，则在注释中返回源版本。</target>
        </trans-unit>
        <trans-unit id="7003e770420135c1df12e09d555ca6780cff43c6" translate="yes" xml:space="preserve">
          <source>If the processor class is annotated with &lt;a href=&quot;supportedsourceversion&quot;&gt;&lt;code&gt;SupportedSourceVersion&lt;/code&gt;&lt;/a&gt;, return the source version in the annotation. If the class is not so annotated, &lt;a href=&quot;../../lang/model/sourceversion#RELEASE_6&quot;&gt;&lt;code&gt;SourceVersion.RELEASE_6&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">如果处理器类使用&lt;a href=&quot;supportedsourceversion&quot;&gt; &lt;code&gt;SupportedSourceVersion&lt;/code&gt; &lt;/a&gt;进行了注释，则在注释中返回源版本。如果未对类进行注释，则返回&lt;a href=&quot;../../lang/model/sourceversion#RELEASE_6&quot;&gt; &lt;code&gt;SourceVersion.RELEASE_6&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="83fa47aeaeb40c5cd4a73d7078ea6a57dab4dfda" translate="yes" xml:space="preserve">
          <source>If the profile has specified the corresponding TRC as linear (gamma = 1.0) or as a simple gamma value, this method throws an exception. In this case, the &lt;a href=&quot;#getGamma(int)&quot;&gt;&lt;code&gt;getGamma(int)&lt;/code&gt;&lt;/a&gt; method should be used to get the gamma value.</source>
          <target state="translated">如果配置文件已将对应的TRC指定为线性（gamma = 1.0）或作为简单的gamma值，则此方法将引发异常。在这种情况下，应使用&lt;a href=&quot;#getGamma(int)&quot;&gt; &lt;code&gt;getGamma(int)&lt;/code&gt; &lt;/a&gt;方法获取伽玛值。</target>
        </trans-unit>
        <trans-unit id="31cac7c5487d20649f40e4f99c36175d92d8d730" translate="yes" xml:space="preserve">
          <source>If the profile represents the TRC for the corresponding component as a table rather than a single gamma value, an exception is thrown. In this case the actual table can be obtained through the &lt;a href=&quot;#getTRC(int)&quot;&gt;&lt;code&gt;getTRC(int)&lt;/code&gt;&lt;/a&gt; method. When using a gamma value, the linear component (R, G, or B) is computed as follows:</source>
          <target state="translated">如果概要文件将对应组件的TRC表示为表而不是单个gamma值，则将引发异常。在这种情况下，可以通过&lt;a href=&quot;#getTRC(int)&quot;&gt; &lt;code&gt;getTRC(int)&lt;/code&gt; &lt;/a&gt;方法获得实际表。使用伽玛值时，线性分量（R，G或B）的计算如下：</target>
        </trans-unit>
        <trans-unit id="2a28ee9e20388a55d35f948cd48fff9c84de8808" translate="yes" xml:space="preserve">
          <source>If the program doesn't explicitly hide or dispose the window while processing this event, the window close operation is canceled.</source>
          <target state="translated">如果程序在处理该事件时没有显式地隐藏或处置窗口,则取消窗口关闭操作。</target>
        </trans-unit>
        <trans-unit id="b31e3a1fd2087ce273c8b857c1c713db2fbc7119" translate="yes" xml:space="preserve">
          <source>If the program wants to handle this exception in particular, it should catch AuthenticationException explicitly before attempting to catch NamingException. After catching AuthenticationException, the program could reattempt the authentication by updating the resolved context's environment properties with the appropriate appropriate credentials.</source>
          <target state="translated">如果程序要特别处理这个异常,就应该在尝试捕获NamingException之前显式地捕获AuthenticationException。在捕捉到AuthenticationException之后,程序可以通过用适当的相应凭证更新已解决的上下文的环境属性来重新尝试认证。</target>
        </trans-unit>
        <trans-unit id="1c285b45955c2c11ff3e733840c81852c7f62aeb" translate="yes" xml:space="preserve">
          <source>If the program wants to handle this exception in particular, it should catch AuthenticationException explicitly before attempting to catch NamingException. After catching AuthenticationException, the program could reattempt the authentication by updating the resolved context's environment properties with the appropriate credentials.</source>
          <target state="translated">如果程序要特别处理这个异常,就应该在尝试捕获NamingException之前显式地捕获AuthenticationException。在捕获AuthenticationException后,程序可以通过用适当的凭证更新解析上下文的环境属性来重新尝试认证。</target>
        </trans-unit>
        <trans-unit id="6f2dc297aa51d5849276a390a4e74ee5aecc6575" translate="yes" xml:space="preserve">
          <source>If the program wants to handle this exception in particular, it should catch AuthenticationNotSupportedException explicitly before attempting to catch NamingException. After catching &lt;code&gt;AuthenticationNotSupportedException&lt;/code&gt;, the program could reattempt the authentication using a different authentication flavor by updating the resolved context's environment properties accordingly.</source>
          <target state="translated">如果程序要特别处理此异常，则应在尝试捕获NamingException之前显式捕获AuthenticationNotSupportedException。捕获 &lt;code&gt;AuthenticationNotSupportedException&lt;/code&gt; 之后，程序可以通过相应地更新解析的上下文的环境属性，使用其他身份验证方式重新尝试进行身份验证。</target>
        </trans-unit>
        <trans-unit id="6aa89d5f48713a94a294fbe63d3a7465ee70153d" translate="yes" xml:space="preserve">
          <source>If the program wants to handle this exception in particular, it should catch CannotProceedException explicitly before attempting to catch NamingException.</source>
          <target state="translated">如果程序要特别处理这个异常,就应该在试图捕获NamingException之前显式地捕获CannotProceedException。</target>
        </trans-unit>
        <trans-unit id="e8620b756848fd740f3151a464311aed319d8483" translate="yes" xml:space="preserve">
          <source>If the program wants to handle this exception in particular, it should catch ContextNotEmptyException explicitly before attempting to catch NamingException. For example, after catching ContextNotEmptyException, the program might try to remove the contents of the context before reattempting the destroy.</source>
          <target state="translated">如果程序要特别处理这个异常,就应该在尝试捕获NamingException之前显式地捕获ContextNotEmptyException。例如,在捕获ContextNotEmptyException之后,程序可能会尝试在重新尝试destroy之前删除上下文的内容。</target>
        </trans-unit>
        <trans-unit id="895af51843785805eb993f6b245e3c37e050b292" translate="yes" xml:space="preserve">
          <source>If the program wants to handle this exception in particular, it should catch NamingSecurityException explicitly before attempting to catch NamingException. A program might want to do this, for example, if it wants to treat security-related exceptions specially from other sorts of naming exception.</source>
          <target state="translated">如果程序想要特别处理这个异常,它应该在尝试捕获NamingException之前显式地捕获NamingSecurityException。例如,如果一个程序想要特别处理与安全相关的异常,而不是其他类型的命名异常,那么它可能想要这样做。</target>
        </trans-unit>
        <trans-unit id="cb41eee27e4dcb52452672c25f0afd9d73a6363a" translate="yes" xml:space="preserve">
          <source>If the properties for this image are not yet known, this method returns &lt;code&gt;null&lt;/code&gt;, and the &lt;code&gt;ImageObserver&lt;/code&gt; object is notified later.</source>
          <target state="translated">如果尚不知道此图像的属性，则此方法返回 &lt;code&gt;null&lt;/code&gt; ，稍后将通知 &lt;code&gt;ImageObserver&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="c6f5f7560de8700736d8932ba9b65417b272c5ae" translate="yes" xml:space="preserve">
          <source>If the property editor class has a public constructor that takes an Object argument then it will be invoked using the bean parameter as the argument. Otherwise, the default constructor will be invoked.</source>
          <target state="translated">如果属性编辑器类有一个公共构造函数,它接受一个Object参数,那么它将使用bean参数作为参数被调用。否则,将调用默认的构造函数。</target>
        </trans-unit>
        <trans-unit id="9e0db0c19ce124c9165b021df450a93e7c1b610d" translate="yes" xml:space="preserve">
          <source>If the property value begins with the ASCII character &lt;code&gt;0&lt;/code&gt; followed by another character, it is parsed as an octal integer exactly as by the method &lt;a href=&quot;#valueOf(java.lang.String,int)&quot;&gt;&lt;code&gt;valueOf(java.lang.String, int)&lt;/code&gt;&lt;/a&gt; with radix 8.</source>
          <target state="translated">如果属性值以ASCII字符 &lt;code&gt;0&lt;/code&gt; 开头，后跟另一个字符，则该属性值将被解析为八进制整数，其值与方法&lt;a href=&quot;#valueOf(java.lang.String,int)&quot;&gt; &lt;code&gt;valueOf(java.lang.String, int)&lt;/code&gt; &lt;/a&gt;的基数为8完全相同。</target>
        </trans-unit>
        <trans-unit id="b2f66e3274b70113dec5b6e974df0367593c3c3b" translate="yes" xml:space="preserve">
          <source>If the property value begins with the ASCII character &lt;code&gt;0&lt;/code&gt; followed by another character, it is parsed as an octal integer exactly as by the method &lt;a href=&quot;integer#valueOf-java.lang.String-int-&quot;&gt;&lt;code&gt;valueOf(java.lang.String, int)&lt;/code&gt;&lt;/a&gt; with radix 8.</source>
          <target state="translated">如果属性值以ASCII字符 &lt;code&gt;0&lt;/code&gt; 开头，后跟另一个字符，则该属性值将被解析为八进制整数，其值与方法&lt;a href=&quot;integer#valueOf-java.lang.String-int-&quot;&gt; &lt;code&gt;valueOf(java.lang.String, int)&lt;/code&gt; &lt;/a&gt;的基数为8 完全相同。</target>
        </trans-unit>
        <trans-unit id="d846b960ac8982dfe609a8cc87db59aceb1d4596" translate="yes" xml:space="preserve">
          <source>If the property value begins with the ASCII character &lt;code&gt;0&lt;/code&gt; followed by another character, it is parsed as an octal integer exactly as by the method &lt;a href=&quot;long#valueOf-java.lang.String-int-&quot;&gt;&lt;code&gt;valueOf(java.lang.String, int)&lt;/code&gt;&lt;/a&gt; with radix 8.</source>
          <target state="translated">如果属性值以ASCII字符 &lt;code&gt;0&lt;/code&gt; 开头，后跟另一个字符，则该属性值将被解析为八进制整数，其值与方法&lt;a href=&quot;long#valueOf-java.lang.String-int-&quot;&gt; &lt;code&gt;valueOf(java.lang.String, int)&lt;/code&gt; &lt;/a&gt;的基数为8 完全相同。</target>
        </trans-unit>
        <trans-unit id="f31812e2389a3fbd5e06ae57741d1eba9e8ae01c" translate="yes" xml:space="preserve">
          <source>If the property value begins with the two ASCII characters &lt;code&gt;0x&lt;/code&gt; or the ASCII character &lt;code&gt;#&lt;/code&gt;, not followed by a minus sign, then the rest of it is parsed as a hexadecimal integer exactly as by the method &lt;a href=&quot;#valueOf(java.lang.String,int)&quot;&gt;&lt;code&gt;valueOf(java.lang.String, int)&lt;/code&gt;&lt;/a&gt; with radix 16.</source>
          <target state="translated">如果属性值以两个ASCII字符 &lt;code&gt;0x&lt;/code&gt; 或ASCII字符 &lt;code&gt;#&lt;/code&gt; 开头，而不后跟减号，则该属性的其余部分将与方法&lt;a href=&quot;#valueOf(java.lang.String,int)&quot;&gt; &lt;code&gt;valueOf(java.lang.String, int)&lt;/code&gt; &lt;/a&gt;完全一样被解析为十六进制整数。带基数16。</target>
        </trans-unit>
        <trans-unit id="0c2a7d82245ca935ebfab36515f8332c15126b95" translate="yes" xml:space="preserve">
          <source>If the property value begins with the two ASCII characters &lt;code&gt;0x&lt;/code&gt; or the ASCII character &lt;code&gt;#&lt;/code&gt;, not followed by a minus sign, then the rest of it is parsed as a hexadecimal integer exactly as by the method &lt;a href=&quot;integer#valueOf-java.lang.String-int-&quot;&gt;&lt;code&gt;valueOf(java.lang.String, int)&lt;/code&gt;&lt;/a&gt; with radix 16.</source>
          <target state="translated">如果属性值以两个ASCII字符 &lt;code&gt;0x&lt;/code&gt; 或ASCII字符 &lt;code&gt;#&lt;/code&gt; 开头，而不后跟减号，则该属性的其余部分将被解析为十六进制整数，与方法&lt;a href=&quot;integer#valueOf-java.lang.String-int-&quot;&gt; &lt;code&gt;valueOf(java.lang.String, int)&lt;/code&gt; &lt;/a&gt;完全相同。带基数16。</target>
        </trans-unit>
        <trans-unit id="3e08b19ba4e6b5c03dd249dfcc97aa3c284ebfc6" translate="yes" xml:space="preserve">
          <source>If the property value begins with the two ASCII characters &lt;code&gt;0x&lt;/code&gt; or the ASCII character &lt;code&gt;#&lt;/code&gt;, not followed by a minus sign, then the rest of it is parsed as a hexadecimal integer exactly as for the method &lt;a href=&quot;#valueOf(java.lang.String,int)&quot;&gt;&lt;code&gt;valueOf(java.lang.String, int)&lt;/code&gt;&lt;/a&gt; with radix 16.</source>
          <target state="translated">如果属性值以两个ASCII字符 &lt;code&gt;0x&lt;/code&gt; 或ASCII字符 &lt;code&gt;#&lt;/code&gt; 开头，而不以减号开头，则将其余部分解析为与方法&lt;a href=&quot;#valueOf(java.lang.String,int)&quot;&gt; &lt;code&gt;valueOf(java.lang.String, int)&lt;/code&gt; &lt;/a&gt;完全相同的十六进制整数。带基数16。</target>
        </trans-unit>
        <trans-unit id="b9750c4a61406d17de53527d1fc84ece847954d5" translate="yes" xml:space="preserve">
          <source>If the property value begins with the two ASCII characters &lt;code&gt;0x&lt;/code&gt; or the ASCII character &lt;code&gt;#&lt;/code&gt;, not followed by a minus sign, then the rest of it is parsed as a hexadecimal integer exactly as for the method &lt;a href=&quot;long#valueOf-java.lang.String-int-&quot;&gt;&lt;code&gt;valueOf(java.lang.String, int)&lt;/code&gt;&lt;/a&gt; with radix 16.</source>
          <target state="translated">如果属性值以两个ASCII字符 &lt;code&gt;0x&lt;/code&gt; 或ASCII字符 &lt;code&gt;#&lt;/code&gt; 开头，而不以减号开头，则将其其余部分解析为与方法&lt;a href=&quot;long#valueOf-java.lang.String-int-&quot;&gt; &lt;code&gt;valueOf(java.lang.String, int)&lt;/code&gt; &lt;/a&gt;完全相同的十六进制整数。带基数16。</target>
        </trans-unit>
        <trans-unit id="9341abc5c400faccf17a3a07de7fac11536f5e5a" translate="yes" xml:space="preserve">
          <source>If the property value must be one of a set of known tagged values, then this method should return an array of the tag values.</source>
          <target state="translated">如果属性值必须是一组已知标记值中的一个,那么这个方法应该返回一个标记值的数组。</target>
        </trans-unit>
        <trans-unit id="6bfe54e945e0b7d817f4c40688004d1c3e18c1e7" translate="yes" xml:space="preserve">
          <source>If the property value must be one of a set of known tagged values, then this method should return an array of the tag values. This can be used to represent (for example) enum values. If a PropertyEditor supports tags, then it should support the use of setAsText with a tag value as a way of setting the value.</source>
          <target state="translated">如果属性值必须是一组已知标记值中的一个,那么这个方法应该返回一个标记值的数组。这可以用来表示(例如)枚举值。如果一个 PropertyEditor 支持标签,那么它应该支持使用带有标签值的 setAsText 作为设置值的方式。</target>
        </trans-unit>
        <trans-unit id="6cd73dc02e49fa592dbe8e15dd72558ce6881cfe" translate="yes" xml:space="preserve">
          <source>If the property value must be one of a set of known tagged values, then this method should return an array of the tags.</source>
          <target state="translated">如果属性值必须是一组已知标记值中的一个,那么这个方法应该返回一个标记数组。</target>
        </trans-unit>
        <trans-unit id="ef546a8769cb06ecdb14394d21b131483d0cbdbf" translate="yes" xml:space="preserve">
          <source>If the property value must be one of a set of known tagged values, then this method should return an array of the tags. This can be used to represent (for example) enum values. If a PropertyEditor supports tags, then it should support the use of setAsText with a tag value as a way of setting the value and the use of getAsText to identify the current value.</source>
          <target state="translated">如果属性值必须是一组已知标记值中的一个,那么这个方法应该返回一个标记数组。这可以用来表示(例如)枚举值。如果一个 PropertyEditor 支持标签,那么它应该支持使用 setAsText 与标签值作为设置值的方式,并支持使用 getAsText 来识别当前值。</target>
        </trans-unit>
        <trans-unit id="9d4476facb38f8ef6d3eac0b77402edf9355a984" translate="yes" xml:space="preserve">
          <source>If the protected key is of type &lt;code&gt;java.security.PrivateKey&lt;/code&gt;, it must be accompanied by a certificate chain certifying the corresponding public key.</source>
          <target state="translated">如果受保护的密钥的类型为 &lt;code&gt;java.security.PrivateKey&lt;/code&gt; ，则必须随附一个证书链，以证明相应的公共密钥。</target>
        </trans-unit>
        <trans-unit id="8efe5ceae64e694176e05313f25266d8f3110e7f" translate="yes" xml:space="preserve">
          <source>If the protected key is of type &lt;code&gt;java.security.PrivateKey&lt;/code&gt;, it must be accompanied by a certificate chain certifying the corresponding public key. If the underlying keystore implementation is of type &lt;code&gt;jks&lt;/code&gt;, &lt;code&gt;key&lt;/code&gt; must be encoded as an &lt;code&gt;EncryptedPrivateKeyInfo&lt;/code&gt; as defined in the PKCS #8 standard.</source>
          <target state="translated">如果受保护的密钥的类型为 &lt;code&gt;java.security.PrivateKey&lt;/code&gt; ，则必须随附一个证书链，以证明相应的公共密钥。如果基础密钥库实现为 &lt;code&gt;jks&lt;/code&gt; 类型，则必须按照PKCS＃8标准中的定义，将 &lt;code&gt;key&lt;/code&gt; 编码为 &lt;code&gt;EncryptedPrivateKeyInfo&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1e8fade5fe2a933f005d764f4f99cdb58a44ddd5" translate="yes" xml:space="preserve">
          <source>If the protocol is &quot;file&quot; and there is an authority component, then permission to connect to and accept connections from that authority may be granted. If the protocol is &quot;file&quot; and the path specifies a file, then permission to read that file is granted. If protocol is &quot;file&quot; and the path is a directory, permission is granted to read all files and (recursively) all files and subdirectories contained in that directory.</source>
          <target state="translated">如果协议是 &quot;文件&quot;,并且有一个权限组件,那么可以授予连接到该权限并接受该权限的连接的权限。如果协议为 &quot;文件&quot;,路径为文件,则授予读取该文件的权限。如果协议是 &quot;file&quot;,路径是一个目录,则授予读取所有文件和(递归)该目录中包含的所有文件和子目录的权限。</target>
        </trans-unit>
        <trans-unit id="bb5e9c9f7d7d328c23292e6a5e585815516946f8" translate="yes" xml:space="preserve">
          <source>If the protocol is not &quot;file&quot;, then permission to connect to and accept connections from the URL's host is granted.</source>
          <target state="translated">如果协议不是 &quot;文件&quot;,则允许连接到URL的主机并接受其连接。</target>
        </trans-unit>
        <trans-unit id="40b1f09001ad2f74e8788b23bbde2accb73745d9" translate="yes" xml:space="preserve">
          <source>If the protocol of this URL is &quot;jar&quot;, then the permission granted is based on the permission that is required by the URL of the Jar file.</source>
          <target state="translated">如果这个URL的协议是 &quot;jar&quot;,那么授予的权限是基于Jar文件的URL所要求的权限。</target>
        </trans-unit>
        <trans-unit id="2f6b4c1a7017bece1784e1294dd82a4357362b10" translate="yes" xml:space="preserve">
          <source>If the provider class is specified, and it can be successfully retrieved from the installed providers, the list of &lt;code&gt;MidiDevice.Info&lt;/code&gt; objects is retrieved from the provider. Otherwise, or when these devices do not provide a subsequent match, the list is retrieved from &lt;a href=&quot;#getMidiDeviceInfo()&quot;&gt;&lt;code&gt;getMidiDeviceInfo()&lt;/code&gt;&lt;/a&gt; to contain all available &lt;code&gt;MidiDevice.Info&lt;/code&gt; objects.</source>
          <target state="translated">如果指定了提供程序类，并且可以从已安装的提供程序中成功检索到该提供程序类，则将从提供程序中检索 &lt;code&gt;MidiDevice.Info&lt;/code&gt; 对象的列表。否则，或者当这些设备不提供后续匹配项时，将从&lt;a href=&quot;#getMidiDeviceInfo()&quot;&gt; &lt;code&gt;getMidiDeviceInfo()&lt;/code&gt; 中&lt;/a&gt;检索列表以包含所有可用的 &lt;code&gt;MidiDevice.Info&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="f7aff0ef21850924145fd8d1eef710a0152583e2" translate="yes" xml:space="preserve">
          <source>If the provider class is specified, and it can be successfully retrieved from the installed providers, the list of &lt;code&gt;MidiDevice.Info&lt;/code&gt; objects is retrieved from the provider. Otherwise, or when these devices do not provide a subsequent match, the list is retrieved from &lt;a href=&quot;midisystem#getMidiDeviceInfo--&quot;&gt;&lt;code&gt;getMidiDeviceInfo()&lt;/code&gt;&lt;/a&gt; to contain all available &lt;code&gt;MidiDevice.Info&lt;/code&gt; objects.</source>
          <target state="translated">如果指定了提供程序类，并且可以从已安装的提供程序中成功检索到该提供程序类，则将从提供程序中检索 &lt;code&gt;MidiDevice.Info&lt;/code&gt; 对象的列表。否则，或者当这些设备不提供后续匹配项时，将从&lt;a href=&quot;midisystem#getMidiDeviceInfo--&quot;&gt; &lt;code&gt;getMidiDeviceInfo()&lt;/code&gt; 中&lt;/a&gt;检索列表以包含所有可用的 &lt;code&gt;MidiDevice.Info&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="4f695eb9c45a7476a06cdea16f6e7dbf1118f942" translate="yes" xml:space="preserve">
          <source>If the provider class is specified, and it can be successfully retrieved from the installed providers, the list of &lt;code&gt;Mixer.Info&lt;/code&gt; objects is retrieved from the provider. Otherwise, or when these mixers do not provide a subsequent match, the list is retrieved from &lt;a href=&quot;#getMixerInfo()&quot;&gt;&lt;code&gt;getMixerInfo()&lt;/code&gt;&lt;/a&gt; to contain all available &lt;code&gt;Mixer.Info&lt;/code&gt; objects.</source>
          <target state="translated">如果指定了提供程序类，并且可以从已安装的提供程序中成功检索到该提供程序类，则将从提供程序中检索 &lt;code&gt;Mixer.Info&lt;/code&gt; 对象的列表。否则，或者当这些混合器不提供后续匹配时，将从&lt;a href=&quot;#getMixerInfo()&quot;&gt; &lt;code&gt;getMixerInfo()&lt;/code&gt; 中&lt;/a&gt;检索列表以包含所有可用的 &lt;code&gt;Mixer.Info&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="0e695a51fa3964ae1c7613ee0169a232ee920a9d" translate="yes" xml:space="preserve">
          <source>If the provider class is specified, and it can be successfully retrieved from the installed providers, the list of &lt;code&gt;Mixer.Info&lt;/code&gt; objects is retrieved from the provider. Otherwise, or when these mixers do not provide a subsequent match, the list is retrieved from &lt;a href=&quot;audiosystem#getMixerInfo--&quot;&gt;&lt;code&gt;getMixerInfo()&lt;/code&gt;&lt;/a&gt; to contain all available &lt;code&gt;Mixer.Info&lt;/code&gt; objects.</source>
          <target state="translated">如果指定了提供程序类，并且可以从已安装的提供程序中成功检索到提供程序类，则将从提供程序中检索 &lt;code&gt;Mixer.Info&lt;/code&gt; 对象的列表。否则，或者当这些混合器不提供后续匹配时，将从&lt;a href=&quot;audiosystem#getMixerInfo--&quot;&gt; &lt;code&gt;getMixerInfo()&lt;/code&gt; 中&lt;/a&gt;检索列表以包含所有可用的 &lt;code&gt;Mixer.Info&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="60186988e7792b549f33f598eb6796ff82e377be" translate="yes" xml:space="preserve">
          <source>If the provider implementation is dynamic, then the flag gives the option of preventing the returned rules from being cached in &lt;a href=&quot;../zoneid&quot;&gt;&lt;code&gt;ZoneId&lt;/code&gt;&lt;/a&gt;. When the flag is true, the provider is permitted to return null, where null will prevent the rules from being cached in &lt;code&gt;ZoneId&lt;/code&gt;. When the flag is false, the provider must return non-null rules.</source>
          <target state="translated">如果提供者实现是动态的，则该标志提供了防止返回的规则缓存在&lt;a href=&quot;../zoneid&quot;&gt; &lt;code&gt;ZoneId&lt;/code&gt; &lt;/a&gt;中的选项。当该标志为true时，允许提供程序返回null，其中null可以防止将规则缓存在 &lt;code&gt;ZoneId&lt;/code&gt; 中。当标志为false时，提供程序必须返回非空规则。</target>
        </trans-unit>
        <trans-unit id="e445a3443a37b81ff119acc67b2ad73cb5fb6432" translate="yes" xml:space="preserve">
          <source>If the provider implementation is not dynamic, then the result of the method must be the non-null set of rules selected by the ID.</source>
          <target state="translated">如果提供者的实现不是动态的,那么该方法的结果必须是ID选择的非空规则集。</target>
        </trans-unit>
        <trans-unit id="17253c90de92aa58bc36b4a773f197b6ca04e1e5" translate="yes" xml:space="preserve">
          <source>If the provider package list exists and is not empty, then for each element &lt;code&gt;&lt;em&gt;pkg&lt;/em&gt;&lt;/code&gt; of the list, the factory will attempt to load the class</source>
          <target state="translated">如果提供程序包列表存在且不为空，则对于列表中的每个元素 &lt;code&gt;&lt;em&gt;pkg&lt;/em&gt;&lt;/code&gt; ，工厂将尝试加载该类</target>
        </trans-unit>
        <trans-unit id="622b60c7279314ec79406efe2e9c7dcfd8abc786" translate="yes" xml:space="preserve">
          <source>If the proxy could not be created, a &lt;a href=&quot;../stubnotfoundexception&quot;&gt;&lt;code&gt;StubNotFoundException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">如果无法创建代理，则将引发&lt;a href=&quot;../stubnotfoundexception&quot;&gt; &lt;code&gt;StubNotFoundException&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d01e7ab79ccc797c94edb821e2001a4b21858cc0" translate="yes" xml:space="preserve">
          <source>If the queue fits in the specified array with room to spare (i.e., the array has more elements than the queue), the element in the array immediately following the end of the collection is set to &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">如果队列适合指定的数组并有剩余空间（即，数组中的元素多于队列），则紧接集合结束后的数组中的元素设置为 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9a336b114f09759ab0e34346b42e3f6b6437e8fc" translate="yes" xml:space="preserve">
          <source>If the radix is less than &lt;a href=&quot;../lang/character#MIN_RADIX&quot;&gt;&lt;code&gt;Character.MIN_RADIX&lt;/code&gt;&lt;/a&gt; or greater than &lt;a href=&quot;../lang/character#MAX_RADIX&quot;&gt;&lt;code&gt;Character.MAX_RADIX&lt;/code&gt;&lt;/a&gt;, then an &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown.</source>
          <target state="translated">如果基数小于&lt;a href=&quot;../lang/character#MIN_RADIX&quot;&gt; &lt;code&gt;Character.MIN_RADIX&lt;/code&gt; &lt;/a&gt;或大于&lt;a href=&quot;../lang/character#MAX_RADIX&quot;&gt; &lt;code&gt;Character.MAX_RADIX&lt;/code&gt; &lt;/a&gt;，则抛出 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="99b3e8d45f37070b6c7a53d21e9f356902e9580a" translate="yes" xml:space="preserve">
          <source>If the radix is less than &lt;code&gt;Character.MIN_RADIX&lt;/code&gt; or greater than &lt;code&gt;Character.MAX_RADIX&lt;/code&gt;, then an &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown.</source>
          <target state="translated">如果基数小于 &lt;code&gt;Character.MIN_RADIX&lt;/code&gt; 或大于 &lt;code&gt;Character.MAX_RADIX&lt;/code&gt; ，则抛出 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a648ff4273d99de4e1bc95f12a1486f421ca4054" translate="yes" xml:space="preserve">
          <source>If the radix is not in the range &lt;code&gt;MIN_RADIX&lt;/code&gt; &amp;le; &lt;code&gt;radix&lt;/code&gt; &amp;le; &lt;code&gt;MAX_RADIX&lt;/code&gt; or if the character is not a valid digit in the specified radix, &lt;code&gt;-1&lt;/code&gt; is returned. A character is a valid digit if at least one of the following is true:</source>
          <target state="translated">如果基数不在范围 &lt;code&gt;MIN_RADIX&lt;/code&gt; &amp;le; &lt;code&gt;radix&lt;/code&gt; &amp;le; &lt;code&gt;MAX_RADIX&lt;/code&gt; 或者如果字符不是指定基数的有效数字， &lt;code&gt;-1&lt;/code&gt; 被返回。如果以下至少一项为真，则字符为有效数字：</target>
        </trans-unit>
        <trans-unit id="d4a1e7fa070e5bd8bde88ce903f985156a6f1b0d" translate="yes" xml:space="preserve">
          <source>If the radix is not in the range &lt;code&gt;MIN_RADIX&lt;/code&gt; &amp;le; &lt;code&gt;radix&lt;/code&gt; &amp;le; &lt;code&gt;MAX_RADIX&lt;/code&gt; or if the value of &lt;code&gt;ch&lt;/code&gt; is not a valid digit in the specified radix, &lt;code&gt;-1&lt;/code&gt; is returned. A character is a valid digit if at least one of the following is true:</source>
          <target state="translated">如果基数不在范围 &lt;code&gt;MIN_RADIX&lt;/code&gt; &amp;le; &lt;code&gt;radix&lt;/code&gt; &amp;le; &lt;code&gt;MAX_RADIX&lt;/code&gt; 或者如果值 &lt;code&gt;ch&lt;/code&gt; 不在指定基数的有效数位， &lt;code&gt;-1&lt;/code&gt; 被返回。如果以下至少一项为真，则字符为有效数字：</target>
        </trans-unit>
        <trans-unit id="671d0d109c8316ebaf1f99c9e9a6b5ad599bcdb9" translate="yes" xml:space="preserve">
          <source>If the radix is smaller than &lt;code&gt;Character.MIN_RADIX&lt;/code&gt; or larger than &lt;code&gt;Character.MAX_RADIX&lt;/code&gt;, then the radix &lt;code&gt;10&lt;/code&gt; is used instead.</source>
          <target state="translated">如果基数小于 &lt;code&gt;Character.MIN_RADIX&lt;/code&gt; 或大于 &lt;code&gt;Character.MAX_RADIX&lt;/code&gt; ，那么将使用基数 &lt;code&gt;10&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="88c548789120cc039a2be678f91a294c4a57446d" translate="yes" xml:space="preserve">
          <source>If the read lock is acquired then the value &lt;code&gt;true&lt;/code&gt; is returned.</source>
          <target state="translated">如果获取了读锁，则返回值 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f1de0197561ab1c42739d318716c6da06cb232ac" translate="yes" xml:space="preserve">
          <source>If the reader does not support thumbnails, (&lt;code&gt;readerSupportsThumbnails&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;), an &lt;code&gt;UnsupportedOperationException&lt;/code&gt; will be thrown regardless of whether an input source has been set or whether the indices are in bounds.</source>
          <target state="translated">如果阅读器不支持缩略图，（ &lt;code&gt;readerSupportsThumbnails&lt;/code&gt; 返回 &lt;code&gt;false&lt;/code&gt; ），则无论是否设置了输入源或索引是否在边界中，都会引发 &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bb2451c0113cb8c1e0775121dff8874d947bd15f" translate="yes" xml:space="preserve">
          <source>If the reader does not support thumbnails, (&lt;code&gt;readerSupportsThumbnails&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;), an &lt;code&gt;UnsupportedOperationException&lt;/code&gt; will be thrown.</source>
          <target state="translated">如果阅读器不支持缩略图，（ &lt;code&gt;readerSupportsThumbnails&lt;/code&gt; 返回 &lt;code&gt;false&lt;/code&gt; ），则将引发 &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="79b35d0dc9d2895dea0c8a3b110254c91b6bdc53" translate="yes" xml:space="preserve">
          <source>If the receiver is laying its &lt;code&gt;View&lt;/code&gt;s along the &lt;code&gt;Y_AXIS&lt;/code&gt;, this will return the value from invoking the same method on the &lt;code&gt;View&lt;/code&gt; responsible for rendering &lt;code&gt;position&lt;/code&gt; and &lt;code&gt;bias&lt;/code&gt;. Otherwise this will return false.</source>
          <target state="translated">如果接收方沿 &lt;code&gt;Y_AXIS&lt;/code&gt; 放置其 &lt;code&gt;View&lt;/code&gt; ，则将在 &lt;code&gt;View&lt;/code&gt; 上调用负责渲染 &lt;code&gt;position&lt;/code&gt; 和 &lt;code&gt;bias&lt;/code&gt; 的相同方法来返回该值。否则，它将返回false。</target>
        </trans-unit>
        <trans-unit id="00cde4cc70dae1cb495d031cb9acb67bc8abef24" translate="yes" xml:space="preserve">
          <source>If the recognized year number is less than 100, it is interpreted as an abbreviated year relative to a century of which dates are within 80 years before and 19 years after the time when the Date class is initialized. After adjusting the year number, 1900 is subtracted from it. For example, if the current year is 1999 then years in the range 19 to 99 are assumed to mean 1919 to 1999, while years from 0 to 18 are assumed to mean 2000 to 2018. Note that this is slightly different from the interpretation of years less than 100 that is used in &lt;a href=&quot;../text/simpledateformat&quot;&gt;&lt;code&gt;SimpleDateFormat&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果公认的年份数字小于100，则将其解释为相对于一个世纪的缩写年份，该日期的日期在初始化Date类的时间之前的80年之内和之后的19年之内。调整年份后，减去1900。例如，如果当前年份为1999，则假定范围19到99的年份表示1919到1999，而假定范围0到18的年份表示2000到2018。请注意，这与年份的解释略有不同少于&lt;a href=&quot;../text/simpledateformat&quot;&gt; &lt;code&gt;SimpleDateFormat&lt;/code&gt; 中&lt;/a&gt;使用的100 。</target>
        </trans-unit>
        <trans-unit id="010a039d9be90452e6c238ffa1c527f615bc99fe" translate="yes" xml:space="preserve">
          <source>If the recorded values contain infinities of one sign and an intermediate sum overflows to an infinity of the opposite sign, the sum may be NaN.</source>
          <target state="translated">如果记录的数值包含一个符号的无穷大,并且中间的和溢出到一个相反符号的无穷大,那么这个和可能是NaN。</target>
        </trans-unit>
        <trans-unit id="fcacf666045f97e91725b22bc1de0a3b50a4cbe3" translate="yes" xml:space="preserve">
          <source>If the recorded values contain infinities of opposite sign, the sum will be NaN.</source>
          <target state="translated">如果记录的数值中包含相反符号的无穷大,那么总和将是NaN。</target>
        </trans-unit>
        <trans-unit id="75c49e5b2d7ecad5d026c07a5fdde433fcf5271a" translate="yes" xml:space="preserve">
          <source>If the recorded values contain one or more infinities, the sum will be infinite or NaN.</source>
          <target state="translated">如果记录的数值中包含一个或多个无穷大,那么总和将是无穷大或NaN。</target>
        </trans-unit>
        <trans-unit id="3499044671723182fe3ed32287d4d0e02001dbb2" translate="yes" xml:space="preserve">
          <source>If the recording is already closed, invoking this method has no effect.</source>
          <target state="translated">如果录音已经关闭,调用本方法没有效果。</target>
        </trans-unit>
        <trans-unit id="57ad84aa4b7a2b33d920b4d445e6eaeb418fc1cc" translate="yes" xml:space="preserve">
          <source>If the region is such that this width is zero, an &lt;code&gt;IllegalStateException&lt;/code&gt; is thrown.</source>
          <target state="translated">如果该区域的宽度为零，则抛出 &lt;code&gt;IllegalStateException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5c3b8b1f31e8b1eb0578d0596a852433e7405f3a" translate="yes" xml:space="preserve">
          <source>If the relation is represented by an MBean (created by the user and added as a relation in the Relation Service), returns the ObjectName of the MBean.</source>
          <target state="translated">如果关系由MBean表示(由用户创建并在关系服务中作为关系添加),返回MBean的ObjectName。</target>
        </trans-unit>
        <trans-unit id="a4fea0cc0a062ac6f4b44054eaf08ec5f2eead20" translate="yes" xml:space="preserve">
          <source>If the relationship between nested types is expressed directly through the &lt;code&gt;NestHost&lt;/code&gt; and &lt;code&gt;NestMembers&lt;/code&gt; attributes (see the Java Virtual Machine Specification, sections 4.7.28 and 4.7.29), then the associated &lt;code&gt;Lookup&lt;/code&gt; object provides direct access to the lookup class and all of its nestmates (see &lt;a href=&quot;../class#getNestHost()&quot;&gt;&lt;code&gt;Class.getNestHost&lt;/code&gt;&lt;/a&gt;). Otherwise, access between nested classes is obtained by the Java compiler creating a wrapper method to access a private method of another class in the same nest. For example, a nested class &lt;code&gt;C.D&lt;/code&gt; can access private members within other related classes such as &lt;code&gt;C&lt;/code&gt;, &lt;code&gt;C.D.E&lt;/code&gt;, or &lt;code&gt;C.B&lt;/code&gt;, but the Java compiler may need to generate wrapper methods in those related classes. In such cases, a &lt;code&gt;Lookup&lt;/code&gt; object on &lt;code&gt;C.E&lt;/code&gt; would be unable to access those private members. A workaround for this limitation is the &lt;a href=&quot;#in(java.lang.Class)&quot;&gt;&lt;code&gt;Lookup.in&lt;/code&gt;&lt;/a&gt; method, which can transform a lookup on &lt;code&gt;C.E&lt;/code&gt; into one on any of those other classes, without special elevation of privilege.</source>
          <target state="translated">如果嵌套类型之间的关系是直接通过 &lt;code&gt;NestHost&lt;/code&gt; 和 &lt;code&gt;NestMembers&lt;/code&gt; 属性表示的（请参见Java虚拟机规范，第4.7.28和4.7.29节），则关联的 &lt;code&gt;Lookup&lt;/code&gt; 对象可以直接访问lookup类及其所有嵌套对象（请参见&lt;a href=&quot;../class#getNestHost()&quot;&gt; &lt;code&gt;Class.getNestHost&lt;/code&gt; &lt;/a&gt;）。否则，Java编译器将创建包装器方法以访问同一嵌套中另一个类的私有方法，从而获得嵌套类之间的访问。例如，嵌套的类 &lt;code&gt;C.D&lt;/code&gt; 可以访问其他相关类（例如 &lt;code&gt;C&lt;/code&gt; ， &lt;code&gt;C.D.E&lt;/code&gt; 或 &lt;code&gt;C.B&lt;/code&gt; 私有成员，但是Java编译器可能需要在那些相关的类中生成包装器方法。在这种情况下， &lt;code&gt;C.E&lt;/code&gt; 上的 &lt;code&gt;Lookup&lt;/code&gt; 对象将无法访问那些私有成员。解决此限制的方法是&lt;a href=&quot;#in(java.lang.Class)&quot;&gt; &lt;code&gt;Lookup.in&lt;/code&gt; &lt;/a&gt;方法，该方法可以将 &lt;code&gt;C.E&lt;/code&gt; 上的查找转换为其他任何类上的查找，而无需特殊的特权提升。</target>
        </trans-unit>
        <trans-unit id="47d94839dfe119ae8b427b70bc88efb6e6b48192" translate="yes" xml:space="preserve">
          <source>If the relationship between nested types is expressed directly through the &lt;code&gt;NestHost&lt;/code&gt; and &lt;code&gt;NestMembers&lt;/code&gt; attributes (see the Java Virtual Machine Specification, sections &lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se15/html/jvms-4.html#jls-4.7.28&quot;&gt;4.7.28&lt;/a&gt; and &lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se15/html/jvms-4.html#jls-4.7.29&quot;&gt;4.7.29&lt;/a&gt;), then the associated &lt;code&gt;Lookup&lt;/code&gt; object provides direct access to the lookup class and all of its nestmates (see &lt;a href=&quot;../class#getNestHost()&quot;&gt;&lt;code&gt;Class.getNestHost&lt;/code&gt;&lt;/a&gt;). Otherwise, access between nested classes is obtained by the Java compiler creating a wrapper method to access a private method of another class in the same nest. For example, a nested class &lt;code&gt;C.D&lt;/code&gt; can access private members within other related classes such as &lt;code&gt;C&lt;/code&gt;, &lt;code&gt;C.D.E&lt;/code&gt;, or &lt;code&gt;C.B&lt;/code&gt;, but the Java compiler may need to generate wrapper methods in those related classes. In such cases, a &lt;code&gt;Lookup&lt;/code&gt; object on &lt;code&gt;C.E&lt;/code&gt; would be unable to access those private members. A workaround for this limitation is the &lt;a href=&quot;#in(java.lang.Class)&quot;&gt;&lt;code&gt;Lookup.in&lt;/code&gt;&lt;/a&gt; method, which can transform a lookup on &lt;code&gt;C.E&lt;/code&gt; into one on any of those other classes, without special elevation of privilege.</source>
          <target state="translated">如果嵌套类型之间的关系是直接通过 &lt;code&gt;NestHost&lt;/code&gt; 和 &lt;code&gt;NestMembers&lt;/code&gt; 属性表示的（请参见Java虚拟机规范的&lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se15/html/jvms-4.html#jls-4.7.28&quot;&gt;4.7.28&lt;/a&gt;和&lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se15/html/jvms-4.html#jls-4.7.29&quot;&gt;4.7.29&lt;/a&gt;节），则关联的 &lt;code&gt;Lookup&lt;/code&gt; 对象可以直接访问lookup类及其所有嵌套对象（请参见&lt;a href=&quot;../class#getNestHost()&quot;&gt; &lt;code&gt;Class.getNestHost&lt;/code&gt; &lt;/a&gt;）。否则，Java编译器将创建包装器方法以访问同一嵌套中另一个类的私有方法，从而获得嵌套类之间的访问。例如，嵌套的类 &lt;code&gt;C.D&lt;/code&gt; 可以访问其他相关类（例如 &lt;code&gt;C&lt;/code&gt; ， &lt;code&gt;C.D.E&lt;/code&gt; 或 &lt;code&gt;C.B&lt;/code&gt; 私有成员，但是Java编译器可能需要在那些相关的类中生成包装器方法。在这种情况下， &lt;code&gt;C.E&lt;/code&gt; 上的 &lt;code&gt;Lookup&lt;/code&gt; 对象将无法访问那些私有成员。解决此限制的方法是&lt;a href=&quot;#in(java.lang.Class)&quot;&gt; &lt;code&gt;Lookup.in&lt;/code&gt; &lt;/a&gt;方法，该方法可以将 &lt;code&gt;C.E&lt;/code&gt; 上的查找转换为其他任何类上的查找，而无需特殊的特权提升。</target>
        </trans-unit>
        <trans-unit id="16b1911621b01dde472303d885688d4202ac98fc" translate="yes" xml:space="preserve">
          <source>If the remapping function returns &lt;code&gt;null&lt;/code&gt;, the mapping is removed (or remains absent if initially absent). If the remapping function itself throws an (unchecked) exception, the exception is rethrown, and the current mapping is left unchanged.</source>
          <target state="translated">如果重新映射函数返回 &lt;code&gt;null&lt;/code&gt; ，则映射将被删除（如果最初不存在，则保持不存在）。如果重映射函数本身抛出（未经检查的）异常，则该异常将被重新抛出，并且当前映射保持不变。</target>
        </trans-unit>
        <trans-unit id="eed62fa294d3e85832e433cc3d47b46c67241064" translate="yes" xml:space="preserve">
          <source>If the remapping function returns &lt;code&gt;null&lt;/code&gt;, the mapping is removed. If the remapping function itself throws an (unchecked) exception, the exception is rethrown, and the current mapping is left unchanged.</source>
          <target state="translated">如果重新映射函数返回 &lt;code&gt;null&lt;/code&gt; ，则删除映射。如果重映射函数本身抛出（未经检查的）异常，则该异常将被重新抛出，并且当前映射保持不变。</target>
        </trans-unit>
        <trans-unit id="6c90ca0b52fc5c89008817da193bca78cfc36ed6" translate="yes" xml:space="preserve">
          <source>If the remote MBean Server is 1.2</source>
          <target state="translated">如果远程MBean服务器为1.2</target>
        </trans-unit>
        <trans-unit id="03cc18ab3cabbd8e48236da939259f3b987d3f83" translate="yes" xml:space="preserve">
          <source>If the remote destination to which the socket is connected does not exist, or is otherwise unreachable, and if an ICMP destination unreachable packet has been received for that address, then a subsequent call to send or receive may throw a PortUnreachableException. Note, there is no guarantee that the exception will be thrown.</source>
          <target state="translated">如果连接到套接字的远程目标不存在,或者以其他方式无法到达,并且如果已经收到了该地址的ICMP目标无法到达数据包,那么后续的发送或接收调用可能会抛出一个PortUnreachableException。注意,不能保证会抛出异常。</target>
        </trans-unit>
        <trans-unit id="57098f4ee262627cd7b01db63d1f7f1265d43afa" translate="yes" xml:space="preserve">
          <source>If the requested attribute is not in the list, this is a no-op.</source>
          <target state="translated">如果所请求的属性不在列表中,这就是一个无操作。</target>
        </trans-unit>
        <trans-unit id="018a97b62ca2a70069aed6a1c61c5a920e8d9cac" translate="yes" xml:space="preserve">
          <source>If the requested opacity value is less than &lt;code&gt;1.0f&lt;/code&gt;, and any of the above conditions are not met, the window opacity will not change, and the &lt;code&gt;IllegalComponentStateException&lt;/code&gt; will be thrown.</source>
          <target state="translated">如果请求的不透明度值小于 &lt;code&gt;1.0f&lt;/code&gt; ，并且不满足上述任何条件，则窗口不透明度将不会更改，并且将抛出 &lt;code&gt;IllegalComponentStateException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1d89a1cc49adab461bf1f01dc66545d017f8bacb" translate="yes" xml:space="preserve">
          <source>If the requested option is binary, it can be set using this method by a java.lang.Boolean:</source>
          <target state="translated">如果所请求的选项是二进制的,那么可以通过java.lang.Boolean:</target>
        </trans-unit>
        <trans-unit id="38ce1c03b79a7b89afd15d63c7ba902df5495593" translate="yes" xml:space="preserve">
          <source>If the requested permission is allowed, this method returns quietly. If denied, a SecurityException is raised.</source>
          <target state="translated">如果请求的权限被允许,这个方法就会安静地返回。如果被拒绝,则会引发一个SecurityException。</target>
        </trans-unit>
        <trans-unit id="f2e93c0c542e53839669b61ae87dd1ffe992a629" translate="yes" xml:space="preserve">
          <source>If the requested shape is not &lt;code&gt;null&lt;/code&gt;, and any of the above conditions are not met, the shape of this window will not change, and either the &lt;code&gt;UnsupportedOperationException&lt;/code&gt; or &lt;code&gt;
 IllegalComponentStateException&lt;/code&gt; will be thrown.</source>
          <target state="translated">如果请求的形状不为 &lt;code&gt;null&lt;/code&gt; ，并且不满足上述任何条件，则此窗口的形状将不会更改，并且将引发 &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 或 &lt;code&gt; IllegalComponentStateException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4c37b9290b4ade460cdf802abd93f12770f8d7f0" translate="yes" xml:space="preserve">
          <source>If the required access and argument checks succeed and the instantiation will proceed, the constructor's declaring class is initialized if it has not already been initialized.</source>
          <target state="translated">如果所需的访问和参数检查成功,并且实例化将继续进行,那么构造函数的声明类就会被初始化,如果它还没有被初始化。</target>
        </trans-unit>
        <trans-unit id="0f30dad69df088eb0e8a01273d14f832b9a0aeff" translate="yes" xml:space="preserve">
          <source>If the required properties have not been set, an exception is thrown. If this method is successful, the current contents of the rowset are discarded and the rowset's metadata is also (re)set. If there are outstanding updates, they are ignored.</source>
          <target state="translated">如果所需的属性没有被设置,就会抛出一个异常。如果这个方法成功,行集的当前内容会被丢弃,行集的元数据也会被(重新)设置。如果有未完成的更新,它们将被忽略。</target>
        </trans-unit>
        <trans-unit id="1eeec4d99736a2aab560f80ec43309d2f90d3ed3" translate="yes" xml:space="preserve">
          <source>If the resolver argument is null, the URIResolver value will be cleared and the transformer will no longer have a resolver.</source>
          <target state="translated">如果 resolver 参数为空,URIResolver 值将被清空,变压器将不再有 resolver。</target>
        </trans-unit>
        <trans-unit id="fa7d4a7621c617404117d28c394ccda5b256dfa2" translate="yes" xml:space="preserve">
          <source>If the resource manager did not commit the transaction and the paramether onePhase is set to true, the resource manager may throw one of the XA_RB* exceptions. Upon return, the resource manager has rolled back the branch's work and has released all held resources.</source>
          <target state="translated">如果资源管理器没有提交事务,并且参数onePhase被设置为true,资源管理器可能会抛出XA_RB*异常之一。返回时,资源管理器已经回滚了该分支的工作,并释放了所有持有的资源。</target>
        </trans-unit>
        <trans-unit id="03e08a40eb5811e25250f7c549a9fd7b28757670" translate="yes" xml:space="preserve">
          <source>If the resource name ends with &quot;&lt;code&gt;.class&lt;/code&gt;&quot; then it is not encapsulated.</source>
          <target state="translated">如果资源名称以&amp;ldquo; &lt;code&gt;.class&lt;/code&gt; &amp;rdquo;结尾，则不会对其进行封装。</target>
        </trans-unit>
        <trans-unit id="62e2c41caf4aaf142a44a8c6c165f53c1d68b4be" translate="yes" xml:space="preserve">
          <source>If the result of this method is used to access the event source, for example, to look up the object or get its attributes, then it needs to be locked because implementations of &lt;code&gt;Context&lt;/code&gt; are not guaranteed to be thread-safe (and &lt;code&gt;EventContext&lt;/code&gt; is a subinterface of &lt;code&gt;Context&lt;/code&gt;). See the &lt;a href=&quot;package-summary#THREADING&quot;&gt;package description&lt;/a&gt; for more information on threading issues.</source>
          <target state="translated">如果使用此方法的结果来访问事件源（例如，查找对象或获取其属性），则需要锁定该对象，因为不能保证 &lt;code&gt;Context&lt;/code&gt; 的实现是线程安全的（ &lt;code&gt;EventContext&lt;/code&gt; 是一个 &lt;code&gt;Context&lt;/code&gt; 的子接口）。有关线程问题的更多信息，请参见&lt;a href=&quot;package-summary#THREADING&quot;&gt;软件包描述&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="da3549687bea03167816a9b17ffaee344e82b496" translate="yes" xml:space="preserve">
          <source>If the resulting &lt;code&gt;OffsetDateTime&lt;/code&gt; is invalid, an exception is thrown. The time and offset do not affect the calculation and will be the same in the result.</source>
          <target state="translated">如果结果 &lt;code&gt;OffsetDateTime&lt;/code&gt; 无效，则引发异常。时间和偏移量不会影响计算，结果将是相同的。</target>
        </trans-unit>
        <trans-unit id="35a287431d52af9ee48c2d5a75b9272669222ecb" translate="yes" xml:space="preserve">
          <source>If the resulting &lt;code&gt;Rectangle&lt;/code&gt; would have a dimension too large to be expressed as an &lt;code&gt;int&lt;/code&gt;, the result will have a dimension of &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt; along that dimension.</source>
          <target state="translated">如果所得 &lt;code&gt;Rectangle&lt;/code&gt; 的尺寸过大而无法表示为 &lt;code&gt;int&lt;/code&gt; ，则结果沿该尺寸将具有 &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt; 的尺寸。</target>
        </trans-unit>
        <trans-unit id="1d921983024b3a73fd6c36177cb6aac0894e7d34" translate="yes" xml:space="preserve">
          <source>If the resulting configuration defines a level for a logger and if the resulting level is different than the level specified in the the old configuration, or not specified in the old configuration, then if the logger exists or if children for that logger exist, the level for that logger will be updated, and the change propagated to any existing logger children. This may cause the logger to be created, if necessary.</source>
          <target state="translated">如果所产生的配置为记录仪定义了级别,如果所产生的级别与旧配置中指定的级别不同,或旧配置中未指定,则如果存在记录仪,或存在该记录仪的子代,则将更新该记录仪的级别,并将更改传播到任何现有的记录仪子代。必要时,这可能会导致创建记录仪。</target>
        </trans-unit>
        <trans-unit id="587aeb87194f308dfa93440ba8ff79e1c3891aa4" translate="yes" xml:space="preserve">
          <source>If the resulting configuration defines a list of handlers for a logger, and if the resulting list is different than the list specified in the old configuration for that logger (that could be empty), then if the logger exists or its children exist, the handlers associated with that logger are closed and removed and the new handlers will be created per the resulting configuration and added to that logger, creating that logger if necessary.</source>
          <target state="translated">如果生成的配置为记录仪定义了处理程序列表,并且如果生成的列表与旧配置中为该记录仪指定的列表不同(可能为空),那么如果记录仪存在或其子代存在,则关闭并删除与该记录仪相关联的处理程序,并根据生成的配置创建新的处理程序并将其添加到该记录仪,必要时创建该记录仪。</target>
        </trans-unit>
        <trans-unit id="8a3d11d3b73e216be8517618d151d35e100edd64" translate="yes" xml:space="preserve">
          <source>If the resulting date is invalid, an exception is thrown.</source>
          <target state="translated">如果生成的日期无效,则会抛出一个异常。</target>
        </trans-unit>
        <trans-unit id="6ca351660a2dc03d4cb71b7bc124559d23a4db29" translate="yes" xml:space="preserve">
          <source>If the resulting date-time is invalid, an exception is thrown.</source>
          <target state="translated">如果生成的日期-时间无效,则会抛出一个异常。</target>
        </trans-unit>
        <trans-unit id="44ca6bebbc9287dfb9c1097c7e056b162daf7bcb" translate="yes" xml:space="preserve">
          <source>If the resulting date-time is invalid, an exception is thrown. The time does not affect the calculation and will be the same in the result.</source>
          <target state="translated">如果结果的日期-时间无效,将抛出一个异常。时间不会影响计算,结果也会一样。</target>
        </trans-unit>
        <trans-unit id="4f6dc2bf2873abab7867f3b616c93e4b15b446fa" translate="yes" xml:space="preserve">
          <source>If the return type &lt;em&gt;T0&lt;/em&gt; is void and &lt;em&gt;T1&lt;/em&gt; a primitive, a zero value is introduced.</source>
          <target state="translated">如果返回类型&lt;em&gt;T0&lt;/em&gt;为空，&lt;em&gt;T1&lt;/em&gt;为原语，则将引入零值。</target>
        </trans-unit>
        <trans-unit id="f822d109dcf5c55256ad0bbca3b4f4180ce12367" translate="yes" xml:space="preserve">
          <source>If the return type &lt;em&gt;T0&lt;/em&gt; is void and &lt;em&gt;T1&lt;/em&gt; a reference, a null value is introduced.</source>
          <target state="translated">如果返回类型&lt;em&gt;T0&lt;/em&gt;为空，而&lt;em&gt;T1&lt;/em&gt;为引用，则将引入空值。</target>
        </trans-unit>
        <trans-unit id="22bfe5b1532d3b1937f6f097fa6b7e18ec35a472" translate="yes" xml:space="preserve">
          <source>If the return type &lt;em&gt;T1&lt;/em&gt; is marked as void, any returned value is discarded</source>
          <target state="translated">如果返回类型&lt;em&gt;T1&lt;/em&gt;标记为void，则任何返回值都将被丢弃</target>
        </trans-unit>
        <trans-unit id="d8afd9f745cfb7d28652f05e0fd4637227b676db" translate="yes" xml:space="preserve">
          <source>If the return type is a parameterized type, the &lt;code&gt;Type&lt;/code&gt; object returned must accurately reflect the actual type arguments used in the source code.</source>
          <target state="translated">如果返回类型是参数化类型，则返回的 &lt;code&gt;Type&lt;/code&gt; 对象必须准确反映源代码中使用的实际类型参数。</target>
        </trans-unit>
        <trans-unit id="8a413e6168d2b6897adbb71ca65aa2bb806445d1" translate="yes" xml:space="preserve">
          <source>If the return type is a parameterized type, the &lt;code&gt;Type&lt;/code&gt; object returned must accurately reflect the actual type parameters used in the source code.</source>
          <target state="translated">如果返回类型是参数化类型，则返回的 &lt;code&gt;Type&lt;/code&gt; 对象必须准确反映源代码中使用的实际类型参数。</target>
        </trans-unit>
        <trans-unit id="c790d87847b61c0198be1f5880f62ee8cbf59f42" translate="yes" xml:space="preserve">
          <source>If the return type is a type variable or a parameterized type, it is created. Otherwise, it is resolved.</source>
          <target state="translated">如果返回类型是类型变量或参数化类型,则创建该类型。否则,它将被解析。</target>
        </trans-unit>
        <trans-unit id="29af74f5a09429dcfd9193c144c392b2c8199600" translate="yes" xml:space="preserve">
          <source>If the return type of any of the methods is a primitive type or void, then all of the methods must have that same return type.</source>
          <target state="translated">如果任何方法的返回类型是基元类型或void,那么所有的方法都必须具有相同的返回类型。</target>
        </trans-unit>
        <trans-unit id="a5a546d9693c1042591033e7eb00ca2f2a455047" translate="yes" xml:space="preserve">
          <source>If the return value is &lt;code&gt;non-null&lt;/code&gt;, all attributes in the returned set are unsupported with this &lt;code&gt;DocFlavor&lt;/code&gt;. The returned set does not distinguish attribute categories that are unsupported from unsupported attribute values.</source>
          <target state="translated">如果返回值为 &lt;code&gt;non-null&lt;/code&gt; ，则此 &lt;code&gt;DocFlavor&lt;/code&gt; 不支持返回集中的所有属性。返回的集不区分不支持的属性类别和不支持的属性值。</target>
        </trans-unit>
        <trans-unit id="17d771c49fde9fd06df899fa732fea09b1398c4a" translate="yes" xml:space="preserve">
          <source>If the return value is non-null, all attributes in the returned set are unsupported with this DocFlavor. The returned set does not distinguish attribute categories that are unsupported from unsupported attribute values.</source>
          <target state="translated">如果返回值为非空,则返回集合中的所有属性都不支持这个DocFlavor。返回的集合不会区分不支持的属性类别和不支持的属性值。</target>
        </trans-unit>
        <trans-unit id="5779215ae457d29d8170805afb88e18c9cd73378" translate="yes" xml:space="preserve">
          <source>If the returned VarHandle is operated on, the declaring class will be initialized, if it has not already been initialized.</source>
          <target state="translated">如果对返回的VarHandle进行操作,声明类将被初始化,如果它还没有被初始化。</target>
        </trans-unit>
        <trans-unit id="eccb50eb8fca6c917cb62a8ea7ba110f808e9efb" translate="yes" xml:space="preserve">
          <source>If the returned method handle is invoked with a &lt;code&gt;null&lt;/code&gt; array reference, a &lt;code&gt;NullPointerException&lt;/code&gt; will be thrown.</source>
          <target state="translated">如果使用 &lt;code&gt;null&lt;/code&gt; 数组引用调用返回的方法句柄，则将引发 &lt;code&gt;NullPointerException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a121ca0e7664dd7a93409420197145f4f87f1e39" translate="yes" xml:space="preserve">
          <source>If the returned method handle is invoked with a negative array size, a &lt;code&gt;NegativeArraySizeException&lt;/code&gt; will be thrown.</source>
          <target state="translated">如果使用负数组大小调用返回的方法句柄，则将引发 &lt;code&gt;NegativeArraySizeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d67afcae574c0dadec33d0948d30e110523b788e" translate="yes" xml:space="preserve">
          <source>If the returned method handle is invoked, the constructor's class will be initialized, if it has not already been initialized.</source>
          <target state="translated">如果返回的方法句柄被调用,构造函数的类将被初始化,如果它还没有被初始化。</target>
        </trans-unit>
        <trans-unit id="bba8a24f154f8c33c7318be4afad7cbac85009fd" translate="yes" xml:space="preserve">
          <source>If the returned method handle is invoked, the field's class will be initialized, if it has not already been initialized.</source>
          <target state="translated">如果返回的方法句柄被调用,该字段的类将被初始化,如果它还没有被初始化。</target>
        </trans-unit>
        <trans-unit id="51fb639a4d11801aea7b926f5d54285fffc4a0fb" translate="yes" xml:space="preserve">
          <source>If the returned method handle is invoked, the method's class will be initialized, if it has not already been initialized.</source>
          <target state="translated">如果返回的方法句柄被调用,那么该方法的类将被初始化,如果它还没有被初始化的话。</target>
        </trans-unit>
        <trans-unit id="062c7a8a96f0cd16df82fd6a3d7ef90b21f0c525" translate="yes" xml:space="preserve">
          <source>If the returned node did not exist prior to this call, this node and any ancestors that were created by this call are not guaranteed to become permanent until the &lt;code&gt;flush&lt;/code&gt; method is called on the returned node (or one of its ancestors or descendants).</source>
          <target state="translated">如果返回的节点在此调用之前不存在，则在该返回的节点（或其祖先或子孙之一）上调用 &lt;code&gt;flush&lt;/code&gt; 方法之前，不能保证此节点和由此调用创建的任何祖先都将成为永久性的。</target>
        </trans-unit>
        <trans-unit id="31845fc89c4f6a02a974ef2eb4b2ee1fabe487a0" translate="yes" xml:space="preserve">
          <source>If the returned object represents a &lt;a href=&quot;javafileobject.kind#SOURCE&quot;&gt;source&lt;/a&gt; or &lt;a href=&quot;javafileobject.kind#CLASS&quot;&gt;class&lt;/a&gt; file, it must be an instance of &lt;a href=&quot;javafileobject&quot;&gt;&lt;code&gt;JavaFileObject&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果返回的对象表示&lt;a href=&quot;javafileobject.kind#SOURCE&quot;&gt;源&lt;/a&gt;文件或&lt;a href=&quot;javafileobject.kind#CLASS&quot;&gt;类&lt;/a&gt;文件，则它必须是&lt;a href=&quot;javafileobject&quot;&gt; &lt;code&gt;JavaFileObject&lt;/code&gt; &lt;/a&gt;的实例。</target>
        </trans-unit>
        <trans-unit id="730234ede727312ada9b756fde5db3279ce11863" translate="yes" xml:space="preserve">
          <source>If the root node isn't visible, it is generally a good to make this value true. Otherwise, the tree looks exactly like a list, and users may not know that the &quot;list entries&quot; are actually tree nodes.</source>
          <target state="translated">如果根节点不可见,一般情况下,让这个值为真就好了,否则,树看起来就像一个列表,用户可能不知道 &quot;列表条目 &quot;实际上是树节点。否则,树看起来就像一个列表,用户可能不知道 &quot;列表条目 &quot;实际上是树节点。</target>
        </trans-unit>
        <trans-unit id="5ec11db983f71de1343f50235b7b5724bd516b85" translate="yes" xml:space="preserve">
          <source>If the row number is positive, the cursor moves to the given row number with respect to the beginning of the result set. The first row is row 1, the second is row 2, and so on.</source>
          <target state="translated">如果行号为正数,那么光标就会相对于结果集的开头移动到给定的行号。第一行是第1行,第二行是第2行,以此类推。</target>
        </trans-unit>
        <trans-unit id="dca61f9ccb26f5859e93cf51aef9999003d9187e" translate="yes" xml:space="preserve">
          <source>If the row number specified is zero, the cursor is moved to before the first row.</source>
          <target state="translated">如果指定的行号为0,则光标移动到第一行之前。</target>
        </trans-unit>
        <trans-unit id="6e65e674c2c9738a67b46cbdff85eddf6bd7d6d6" translate="yes" xml:space="preserve">
          <source>If the rule defines a week where the cutover might occur, then this method returns the day-of-week that the month-day will be adjusted to. If the day is positive then the adjustment is later. If the day is negative then the adjustment is earlier.</source>
          <target state="translated">如果规则定义了可能发生切分的一周,那么这个方法将返回月日调整到的周的哪一天。如果这一天是正数,那么调整的时间就会晚一些;如果这一天是负数,那么调整的时间就会早一些。如果这一天是负数,那么调整时间就会提前。</target>
        </trans-unit>
        <trans-unit id="ab9f1126ac23de664120eeb0433d59deaee2f7bd" translate="yes" xml:space="preserve">
          <source>If the rule defines a week where the transition might occur, then the day defines either the start of the end of the transition week.</source>
          <target state="translated">如果规则定义了可能发生过渡的一周,那么这一天定义了过渡周的开始或结束。</target>
        </trans-unit>
        <trans-unit id="89f95b53b5119c06e7c28d0a4953b38d65679d33" translate="yes" xml:space="preserve">
          <source>If the rule defines a week where the transition might occur, then the month if the month of either the earliest or latest possible date of the cutover.</source>
          <target state="translated">如果规则定义了可能发生转换的一周,那么如果是最早或最晚的可能转换日期的月份,则是月份。</target>
        </trans-unit>
        <trans-unit id="c5876d137cd994c7ad4a664d7beaa1b898954c4d" translate="yes" xml:space="preserve">
          <source>If the rule defines an exact date then the day is the month of that date.</source>
          <target state="translated">如果规则定义了一个确切的日期,那么这一天就是该日期的月份。</target>
        </trans-unit>
        <trans-unit id="7a405331c7ddef3021a3335c00454f67145186ff" translate="yes" xml:space="preserve">
          <source>If the rule defines an exact date then the month is the month of that date.</source>
          <target state="translated">如果规则定义了一个确切的日期,那么月份就是该日期的月份。</target>
        </trans-unit>
        <trans-unit id="5034d0b228d4988928265c1d8ac1f628685a4b7f" translate="yes" xml:space="preserve">
          <source>If the rule defines an exact date then this returns null.</source>
          <target state="translated">如果规则定义了一个精确的日期,那么这条规则返回null。</target>
        </trans-unit>
        <trans-unit id="188251de9eebdf9999e55d3130ae4d68d97ee026" translate="yes" xml:space="preserve">
          <source>If the same &lt;code&gt;Action&lt;/code&gt; is used with menus and buttons you'll typically specify both a &lt;code&gt;SMALL_ICON&lt;/code&gt; and a &lt;code&gt;LARGE_ICON_KEY&lt;/code&gt;. The menu will use the &lt;code&gt;SMALL_ICON&lt;/code&gt; and the button the &lt;code&gt;LARGE_ICON_KEY&lt;/code&gt;.</source>
          <target state="translated">如果菜单和按钮使用了相同的 &lt;code&gt;Action&lt;/code&gt; ,则通常会同时指定 &lt;code&gt;SMALL_ICON&lt;/code&gt; 和 &lt;code&gt;LARGE_ICON_KEY&lt;/code&gt; 。菜单将使用 &lt;code&gt;SMALL_ICON&lt;/code&gt; ，按钮将使用 &lt;code&gt;LARGE_ICON_KEY&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="77685adc8a0c8449f2dc16b0f092c4e3cf760fa3" translate="yes" xml:space="preserve">
          <source>If the same &lt;code&gt;Action&lt;/code&gt; is used with menus and buttons you'll typically specify both a &lt;code&gt;SMALL_ICON&lt;/code&gt; and a &lt;code&gt;LARGE_ICON_KEY&lt;/code&gt;. The menu will use the &lt;code&gt;SMALL_ICON&lt;/code&gt; and the button will use the &lt;code&gt;LARGE_ICON_KEY&lt;/code&gt;.</source>
          <target state="translated">如果菜单和按钮使用了相同的 &lt;code&gt;Action&lt;/code&gt; ,则通常会同时指定 &lt;code&gt;SMALL_ICON&lt;/code&gt; 和 &lt;code&gt;LARGE_ICON_KEY&lt;/code&gt; 。菜单将使用 &lt;code&gt;SMALL_ICON&lt;/code&gt; ，按钮将使用 &lt;code&gt;LARGE_ICON_KEY&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2f0e91ac8cea622cd628a97cacbf583516eb1203" translate="yes" xml:space="preserve">
          <source>If the same MXBean were registered under two different &lt;code&gt;ObjectName&lt;/code&gt;s, a reference to that MXBean from another MXBean would be ambiguous. Therefore, if an MXBean object is already registered in an MBean Server and an attempt is made to register it in the same MBean Server under another name, the result is an &lt;a href=&quot;instancealreadyexistsexception&quot;&gt;&lt;code&gt;InstanceAlreadyExistsException&lt;/code&gt;&lt;/a&gt;. Registering the same MBean object under more than one name is discouraged in general, notably because it does not work well for MBeans that are &lt;a href=&quot;notificationbroadcaster&quot;&gt;&lt;code&gt;NotificationBroadcaster&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="translated">如果在两个不同的 &lt;code&gt;ObjectName&lt;/code&gt; 下注册了相同的MXBean ，则从另一个MXBean对该MXBean的引用将是不明确的。因此，如果MXBean对象已经在MBean服务器中注册，并尝试使用另一个名称在同一MBean服务器中注册它，则结果为&lt;a href=&quot;instancealreadyexistsexception&quot;&gt; &lt;code&gt;InstanceAlreadyExistsException&lt;/code&gt; &lt;/a&gt;。通常不建议使用多个名称注册同一MBean对象，特别是因为它不适用于&lt;a href=&quot;notificationbroadcaster&quot;&gt; &lt;code&gt;NotificationBroadcaster&lt;/code&gt; &lt;/a&gt;的MBean 。</target>
        </trans-unit>
        <trans-unit id="50eb773388c08998af191260a43e85de5e2d0eab" translate="yes" xml:space="preserve">
          <source>If the same listener is added more than once, it is considered as many times as it was added. It is often useful to add the same listener with different filters or handback objects.</source>
          <target state="translated">如果同一个监听器被添加了不止一次,那么它的添加次数就被认为是相同的。使用不同的过滤器或回传对象来添加同一个监听器通常很有用。</target>
        </trans-unit>
        <trans-unit id="7408f6bcba8070d6e3a1c46a3adc49506ab7c38a" translate="yes" xml:space="preserve">
          <source>If the same listener is added multiple times, only one instance is removed.</source>
          <target state="translated">如果同一监听器被多次添加,则只删除一个实例。</target>
        </trans-unit>
        <trans-unit id="a530990bfaa8ba340ab7814bcb938600df0674e3" translate="yes" xml:space="preserve">
          <source>If the same listener was added more than once, it will be notified one less time after being removed. If &lt;code&gt;listener&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, or was never added, no exception is thrown and no action is taken.</source>
          <target state="translated">如果多次添加同一个侦听器，则删除该通知后，通知时间将减少一秒钟。如果 &lt;code&gt;listener&lt;/code&gt; 为 &lt;code&gt;null&lt;/code&gt; ，或者从未添加过listener，则不会引发任何异常并且不执行任何操作。</target>
        </trans-unit>
        <trans-unit id="8a2f1faa361a4f239eecfaa4480ce58bb66c8e63" translate="yes" xml:space="preserve">
          <source>If the scale is greater than or equal to zero and the adjusted exponent is greater than or equal to &lt;code&gt;-6&lt;/code&gt;, the number will be converted to a character form without using exponential notation. In this case, if the scale is zero then no decimal point is added and if the scale is positive a decimal point will be inserted with the scale specifying the number of characters to the right of the decimal point. &lt;code&gt;'0'&lt;/code&gt; characters are added to the left of the converted unscaled value as necessary. If no character precedes the decimal point after this insertion then a conventional &lt;code&gt;'0'&lt;/code&gt; character is prefixed.</source>
          <target state="translated">如果小数位数大于或等于零，并且调整后的指数大于或等于 &lt;code&gt;-6&lt;/code&gt; ，则数字将转换为字符形式而无需使用指数表示法。在这种情况下，如果小数位为零，则不添加小数点；如果小数位为正，则将插入小数点，并在小数点右边指定小数位数。必要时，将 &lt;code&gt;'0'&lt;/code&gt; 字符添加到转换后的非标度值的左侧。如果在插入后小数点之前没有字符，则以常规的 &lt;code&gt;'0'&lt;/code&gt; 字符为前缀。</target>
        </trans-unit>
        <trans-unit id="b6699480c9af01ef59363f0886670fc80f9f3dd6" translate="yes" xml:space="preserve">
          <source>If the scheme component is defined in the given spec and does not match the scheme of the context, then the new URL is created as an absolute URL based on the spec alone. Otherwise the scheme component is inherited from the context URL.</source>
          <target state="translated">如果scheme组件是在给定的规范中定义的,并且与上下文的scheme不匹配,那么新的URL就会被创建为基于规范的绝对URL。否则,方案组件将从上下文URL中继承。</target>
        </trans-unit>
        <trans-unit id="0f6fbda65188dadd280d2d62127e7bf188917970" translate="yes" xml:space="preserve">
          <source>If the screens configuration does not allow the window to be moved from one screen to another, then the window is only placed at the location determined according to the above conditions and its &lt;code&gt;GraphicsConfiguration&lt;/code&gt; is not changed.</source>
          <target state="translated">如果屏幕配置不允许窗口从一个屏幕移动到另一个屏幕，则仅将窗口放置在根据上述条件确定的位置，并且不会更改其 &lt;code&gt;GraphicsConfiguration&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9dcb8547b15783f8929c319cccddbb69b3b6cf00" translate="yes" xml:space="preserve">
          <source>If the scrollbar display policy is defined as &quot;never&quot;, then the scrollpane can still be programmatically scrolled using the setScrollPosition() method and the scrollpane will move and clip the child's contents appropriately. This policy is useful if the program needs to create and manage its own adjustable controls.</source>
          <target state="translated">如果滚动条显示策略被定义为 &quot;never&quot;,那么仍然可以使用setScrollPosition()方法对滚动条进行编程滚动,并且滚动条会适当地移动和夹住子内容。如果程序需要创建和管理自己的可调节控件,那么这个策略就很有用。</target>
        </trans-unit>
        <trans-unit id="481d140f57a30b2cc9e64db972e10c648c8a2a3b" translate="yes" xml:space="preserve">
          <source>If the scrollpane has a non-&lt;code&gt;null&lt;/code&gt;&lt;code&gt;viewportBorder&lt;/code&gt;, then space is allocated for that.</source>
          <target state="translated">如果滚动窗格具有非 &lt;code&gt;null&lt;/code&gt; 的 &lt;code&gt;viewportBorder&lt;/code&gt; ，则为此分配空间。</target>
        </trans-unit>
        <trans-unit id="6ccd5d8778f5d88a5474e8c59978eccee5689a2e" translate="yes" xml:space="preserve">
          <source>If the second argument is 1.0, then the result is the same as the first argument.</source>
          <target state="translated">如果第二个参数是1.0,那么结果与第一个参数相同。</target>
        </trans-unit>
        <trans-unit id="f8344687c76c61e184619d725d0545c562c31518" translate="yes" xml:space="preserve">
          <source>If the second argument is NaN, then the result is NaN.</source>
          <target state="translated">如果第二个参数是NaN,那么结果就是NaN。</target>
        </trans-unit>
        <trans-unit id="728f5c52b29916aebc4c06ac0928425a83bcd984" translate="yes" xml:space="preserve">
          <source>If the second argument is an &lt;code&gt;InputStream&lt;/code&gt; then the stream must contain number of bytes specified by scaleOrLength. If the second argument is a &lt;code&gt;Reader&lt;/code&gt; then the reader must contain the number of characters specified by scaleOrLength. If these conditions are not true the driver will generate a &lt;code&gt;SQLException&lt;/code&gt; when the statement is executed.</source>
          <target state="translated">如果第二个参数是 &lt;code&gt;InputStream&lt;/code&gt; ,则流必须包含scaleOrLength指定的字节数。如果第二个参数是 &lt;code&gt;Reader&lt;/code&gt; ,则阅读器必须包含scaleOrLength指定的字符数。如果不满足这些条件，则驱动程序将在执行该语句时生成 &lt;code&gt;SQLException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5e66ea14e901f2694aafe98690642d15fedd9f3e" translate="yes" xml:space="preserve">
          <source>If the second argument is an &lt;code&gt;InputStream&lt;/code&gt; then the stream must contain the number of bytes specified by scaleOrLength. If the second argument is a &lt;code&gt;Reader&lt;/code&gt; then the reader must contain the number of characters specified by scaleOrLength. If these conditions are not true the driver will generate a &lt;code&gt;SQLException&lt;/code&gt; when the statement is executed.</source>
          <target state="translated">如果第二个参数是 &lt;code&gt;InputStream&lt;/code&gt; ,则流必须包含scaleOrLength指定的字节数。如果第二个参数是 &lt;code&gt;Reader&lt;/code&gt; ,则阅读器必须包含scaleOrLength指定的字符数。如果不满足这些条件，则驱动程序将在执行该语句时生成 &lt;code&gt;SQLException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="83af07e72de969c0ada685452a5155bf504024e7" translate="yes" xml:space="preserve">
          <source>If the second argument is positive or negative zero, then the result is 1.0.</source>
          <target state="translated">如果第二个参数是正或负零,那么结果就是1.0。</target>
        </trans-unit>
        <trans-unit id="9b941ca67a1b9bc33a6bb0d7bf06f63dc95c2df8" translate="yes" xml:space="preserve">
          <source>If the second-of-minute is not available then jump to the next space.</source>
          <target state="translated">如果没有分钟之秒,则跳到下一个空格。</target>
        </trans-unit>
        <trans-unit id="6ea372174aa5c23af0c1777c675872adacfad266" translate="yes" xml:space="preserve">
          <source>If the second-of-minute is not available then the format is complete.</source>
          <target state="translated">如果分秒不差,那么格式就完整了。</target>
        </trans-unit>
        <trans-unit id="a0ca0c8f14e74d6e3c35517091b31f9d9d7a6b0c" translate="yes" xml:space="preserve">
          <source>If the seconds field carries more digits than milli-second order, those will be simply discarded (or in other words, rounded to zero.) For example, for any &lt;code&gt;Date&lt;/code&gt; value &lt;code&gt;x&lt;/code&gt;,</source>
          <target state="translated">如果seconds字段携带的数字多于毫秒数，那么这些数字将被简单地丢弃（或换句话说，四舍五入为零）。例如，对于任何 &lt;code&gt;Date&lt;/code&gt; 值 &lt;code&gt;x&lt;/code&gt; ，</target>
        </trans-unit>
        <trans-unit id="6762d0d3f73a120d76591aa7109ff493352a5101" translate="yes" xml:space="preserve">
          <source>If the seconds field carries more digits than milli-second order, those will be simply discarded (or in other words, rounded to zero.) For example, for any Calendar value &lt;code&gt;x&lt;/code&gt;,</source>
          <target state="translated">如果seconds字段携带的数字多于毫秒，那么这些数字将被简单地丢弃（或换句话说，四舍五入为零）。例如，对于任何Calendar值 &lt;code&gt;x&lt;/code&gt; ，</target>
        </trans-unit>
        <trans-unit id="5653b3f59b63219b61535639dd8eec29f7dad782" translate="yes" xml:space="preserve">
          <source>If the security property is set to the fully qualified name of a &lt;code&gt;CallbackHandler&lt;/code&gt; implementation class, then a &lt;code&gt;LoginContext&lt;/code&gt; will load the specified &lt;code&gt;CallbackHandler&lt;/code&gt; and pass it to the underlying LoginModules. The &lt;code&gt;LoginContext&lt;/code&gt; only loads the default handler if it was not provided one.</source>
          <target state="translated">如果将security属性设置为 &lt;code&gt;CallbackHandler&lt;/code&gt; 实现类的标准名称，则 &lt;code&gt;LoginContext&lt;/code&gt; 将加载指定的 &lt;code&gt;CallbackHandler&lt;/code&gt; 并将其传递给基础LoginModules。该 &lt;code&gt;LoginContext&lt;/code&gt; 将只加载如果它没有提供一个默认的处理程序。</target>
        </trans-unit>
        <trans-unit id="d64a3fa99372fe6ed29fb93b51136151680efc81" translate="yes" xml:space="preserve">
          <source>If the selection includes the leftmost (topmost) position, the selection is extended to the left (top) of &lt;code&gt;bounds&lt;/code&gt;. If the selection includes the rightmost (bottommost) position, the selection is extended to the right (bottom) of the bounds. The height (width on vertical lines) of the selection is always extended to &lt;code&gt;bounds&lt;/code&gt;.</source>
          <target state="translated">如果所选内容包括最左侧（最顶部）的位置，则所选内容将扩展到 &lt;code&gt;bounds&lt;/code&gt; 的左侧（顶部）。如果选择包括最右边（最底）的位置，则选择范围将扩展到边界的右边（最底）。选择的高度（垂直线的宽度）始终扩展到 &lt;code&gt;bounds&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9c6ce13905c3b53f290f1fe802b6aed3d33f0e9f" translate="yes" xml:space="preserve">
          <source>If the selection mode is &lt;code&gt;CONTIGUOUS_TREE_SELECTION&lt;/code&gt;, and adding the new paths would make the selection discontiguous. Then two things can result: if the TreePaths in &lt;code&gt;paths&lt;/code&gt; are contiguous, then the selection becomes these TreePaths, otherwise the TreePaths aren't contiguous and the selection becomes the first TreePath in &lt;code&gt;paths&lt;/code&gt;.</source>
          <target state="translated">如果选择模式为 &lt;code&gt;CONTIGUOUS_TREE_SELECTION&lt;/code&gt; ，则添加新路径将使选择不连续。然后会产生两件事：如果 &lt;code&gt;paths&lt;/code&gt; 中的TreePath是连续的，则选择将成为这些TreePath，否则，这些TreePath将不连续，并且选择将成为 &lt;code&gt;paths&lt;/code&gt; 的第一个TreePath 。</target>
        </trans-unit>
        <trans-unit id="6e2c6505b616998dc824a56fb69330d1ffe1a66c" translate="yes" xml:space="preserve">
          <source>If the selection mode is &lt;code&gt;SINGLE_TREE_SELECTION&lt;/code&gt; and more than one TreePath is selected, the selection is reset to contain the first path currently selected.</source>
          <target state="translated">如果选择模式为 &lt;code&gt;SINGLE_TREE_SELECTION&lt;/code&gt; 且选择了多个TreePath，则重置该选择以包含当前选择的第一个路径。</target>
        </trans-unit>
        <trans-unit id="a9329c3f6f88e34510974b909e266bf49fd3da54" translate="yes" xml:space="preserve">
          <source>If the selection range includes the first logical character, the selection is extended to the portion of &lt;code&gt;bounds&lt;/code&gt; before the start of this &lt;code&gt;TextLayout&lt;/code&gt;. If the range includes the last logical character, the selection is extended to the portion of &lt;code&gt;bounds&lt;/code&gt; after the end of this &lt;code&gt;TextLayout&lt;/code&gt;. The height (width on vertical lines) of the selection is always extended to &lt;code&gt;bounds&lt;/code&gt;.</source>
          <target state="translated">如果选择范围包括第一个逻辑字符，则选择范围将扩展到此 &lt;code&gt;TextLayout&lt;/code&gt; 开始之前的 &lt;code&gt;bounds&lt;/code&gt; 部分。如果范围包括最后一个逻辑字符，则选择范围将扩展到此 &lt;code&gt;TextLayout&lt;/code&gt; 结束之后的 &lt;code&gt;bounds&lt;/code&gt; 部分。选择的高度（垂直线的宽度）始终扩展到 &lt;code&gt;bounds&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e6707140df46f6eb04938367483bc2c365bdb2e5" translate="yes" xml:space="preserve">
          <source>If the selector has already been closed then this method returns immediately. Otherwise it marks the selector as closed and then invokes the &lt;a href=&quot;#implCloseSelector()&quot;&gt;&lt;code&gt;implCloseSelector&lt;/code&gt;&lt;/a&gt; method in order to complete the close operation.</source>
          <target state="translated">如果选择器已经关闭，则此方法将立即返回。否则，它将选择器标记为已关闭，然后调用&lt;a href=&quot;#implCloseSelector()&quot;&gt; &lt;code&gt;implCloseSelector&lt;/code&gt; &lt;/a&gt;方法以完成关闭操作。</target>
        </trans-unit>
        <trans-unit id="08dd4228bba4510d42bc79e395b01540dece6a1f" translate="yes" xml:space="preserve">
          <source>If the selector has already been closed then this method returns immediately. Otherwise it marks the selector as closed and then invokes the &lt;a href=&quot;abstractselector#implCloseSelector--&quot;&gt;&lt;code&gt;implCloseSelector&lt;/code&gt;&lt;/a&gt; method in order to complete the close operation.</source>
          <target state="translated">如果选择器已经关闭，则此方法立即返回。否则，它将选择器标记为已关闭，然后调用&lt;a href=&quot;abstractselector#implCloseSelector--&quot;&gt; &lt;code&gt;implCloseSelector&lt;/code&gt; &lt;/a&gt;方法以完成关闭操作。</target>
        </trans-unit>
        <trans-unit id="c7ad935cdc55d4a107502fb1347aaf4da85ef291" translate="yes" xml:space="preserve">
          <source>If the selector itself is closed then the channel will be deregistered, and the key representing its registration will be invalidated, without further delay.</source>
          <target state="translated">如果选择器本身被关闭,那么该通道将被取消注册,代表其注册的密钥将失效,不再延迟。</target>
        </trans-unit>
        <trans-unit id="527b7c6f507b87aa21ddf93053b13e95205bb2c8" translate="yes" xml:space="preserve">
          <source>If the sequence is mutated while the stream is being read, the result is undefined.</source>
          <target state="translated">如果序列在读取流的过程中发生了突变,那么结果是未定义的。</target>
        </trans-unit>
        <trans-unit id="68365060e1fd3c2daf69dad059677cfed6352297" translate="yes" xml:space="preserve">
          <source>If the sequence of characters is already available as a character array, using this constructor is faster than converting the &lt;code&gt;char&lt;/code&gt; array to string and using the &lt;code&gt;BigDecimal(String)&lt;/code&gt; constructor.</source>
          <target state="translated">如果字符序列已经可以作为字符数组使用，则使用此构造函数比将 &lt;code&gt;char&lt;/code&gt; 数组转换为字符串和使用 &lt;code&gt;BigDecimal(String)&lt;/code&gt; 构造函数要快。</target>
        </trans-unit>
        <trans-unit id="44599ce71e2e538b01fd695f05e20f34c21d8951" translate="yes" xml:space="preserve">
          <source>If the sequence of characters is already available within a character array, using this constructor is faster than converting the &lt;code&gt;char&lt;/code&gt; array to string and using the &lt;code&gt;BigDecimal(String)&lt;/code&gt; constructor.</source>
          <target state="translated">如果字符序列在字符数组中已经可用，则使用此构造函数比将 &lt;code&gt;char&lt;/code&gt; 数组转换为字符串和使用 &lt;code&gt;BigDecimal(String)&lt;/code&gt; 构造函数要快。</target>
        </trans-unit>
        <trans-unit id="905718a38e6e40a4a44a638dd8e38175f57a597e" translate="yes" xml:space="preserve">
          <source>If the service provider declares a provider method, then the service loader invokes that method to obtain an instance of the service provider. A provider method is a public static method named &quot;provider&quot; with no formal parameters and a return type that is assignable to the service's interface or class.</source>
          <target state="translated">如果服务提供者声明了一个提供者方法,那么服务加载器就会调用该方法来获取服务提供者的实例。提供者方法是一个名为 &quot;provider &quot;的公共静态方法,它没有正式的参数,其返回类型可分配给服务的接口或类。</target>
        </trans-unit>
        <trans-unit id="3b23056cdaee0c387d69777057adce2233310c89" translate="yes" xml:space="preserve">
          <source>If the service provider does not declare a provider method, then the service provider is instantiated directly, via its provider constructor. A provider constructor is a public constructor with no formal parameters.</source>
          <target state="translated">如果服务提供者没有声明提供者方法,那么就直接通过其提供者构造函数实例化服务提供者。提供者构造函数是一个没有形式参数的公共构造函数。</target>
        </trans-unit>
        <trans-unit id="96cc80cb5c49589843f4c152dbe187b0d7672c14" translate="yes" xml:space="preserve">
          <source>If the set contains &lt;code&gt;null&lt;/code&gt; or elements that are not of type &lt;code&gt;PosixFilePermission&lt;/code&gt; then these elements are ignored.</source>
          <target state="translated">如果集合包含 &lt;code&gt;null&lt;/code&gt; 或非 &lt;code&gt;PosixFilePermission&lt;/code&gt; 类型的元素，则将忽略这些元素。</target>
        </trans-unit>
        <trans-unit id="bdd7ddd5abc6f06de4935b22a2b32f438818b4c2" translate="yes" xml:space="preserve">
          <source>If the set is modified after the iterator is created, in any way except by invoking the iterator's own &lt;a href=&quot;../../util/iterator#remove()&quot;&gt;&lt;code&gt;remove&lt;/code&gt;&lt;/a&gt; method, then a &lt;a href=&quot;../../util/concurrentmodificationexception&quot;&gt;&lt;code&gt;ConcurrentModificationException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">如果在创建迭代器之后修改了集合，则除了通过调用迭代器自己的&lt;a href=&quot;../../util/iterator#remove()&quot;&gt; &lt;code&gt;remove&lt;/code&gt; &lt;/a&gt;方法之外，可以通过任何方式进行修改，然后将引发&lt;a href=&quot;../../util/concurrentmodificationexception&quot;&gt; &lt;code&gt;ConcurrentModificationException&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6a2fc5c10d29d945ad7e76e24ac30350f31297ef" translate="yes" xml:space="preserve">
          <source>If the set is modified after the iterator is created, in any way except by invoking the iterator's own &lt;a href=&quot;../../util/iterator#remove--&quot;&gt;&lt;code&gt;remove&lt;/code&gt;&lt;/a&gt; method, then a &lt;a href=&quot;../../util/concurrentmodificationexception&quot;&gt;&lt;code&gt;ConcurrentModificationException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">如果在创建迭代器之后修改了集合，则除了通过调用迭代器自己的&lt;a href=&quot;../../util/iterator#remove--&quot;&gt; &lt;code&gt;remove&lt;/code&gt; &lt;/a&gt;方法之外，可以通过任何方式进行修改，然后将引发&lt;a href=&quot;../../util/concurrentmodificationexception&quot;&gt; &lt;code&gt;ConcurrentModificationException&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f6638fbdc996aa0e831fc1abcabd26d13939d37e" translate="yes" xml:space="preserve">
          <source>If the setting control represents a boolean condition and four recordings are running at the same time with the following values &lt;code&gt;&quot;true&quot;&lt;/code&gt;, &lt;code&gt;&quot;false&quot;&lt;/code&gt;, &lt;code&gt;&quot;false&quot;&lt;/code&gt;, and &lt;code&gt;&quot;incorrect&quot;&lt;/code&gt;, this method returns &lt;code&gt;&quot;true&quot;&lt;/code&gt;, because all recordings get at least all the requested data.</source>
          <target state="translated">如果设置控件表示布尔条件，并且四个记录同时运行，且具有以下值 &lt;code&gt;&quot;true&quot;&lt;/code&gt; ， &lt;code&gt;&quot;false&quot;&lt;/code&gt; ， &lt;code&gt;&quot;false&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;incorrect&quot;&lt;/code&gt; ，则此方法返回 &lt;code&gt;&quot;true&quot;&lt;/code&gt; ，因为所有记录都在至少所有请求的数据。</target>
        </trans-unit>
        <trans-unit id="f213e623005cb03ce8a996eda62ae9d104d49741" translate="yes" xml:space="preserve">
          <source>If the setting control represents a set of names and two recordings are running at the same time with the setting values &lt;code&gt;&quot;Smith, Jones&quot;&lt;/code&gt; and &lt;code&gt;&quot;Jones,
 Williams&quot;&lt;/code&gt; the returned value is &lt;code&gt;&quot;Smith, Jones, Williams&quot;&lt;/code&gt; because all names would be accepted.</source>
          <target state="translated">如果设置控件表示一组名称，并且两个记录同时使用设置值 &lt;code&gt;&quot;Smith, Jones&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;Jones, Williams&quot;&lt;/code&gt; 则返回值为 &lt;code&gt;&quot;Smith, Jones, Williams&quot;&lt;/code&gt; 因为将接受所有名称。</target>
        </trans-unit>
        <trans-unit id="abc7e4a8c7928920f09d0830931380727e4c575d" translate="yes" xml:space="preserve">
          <source>If the setting lacks a content type, the content type for the type that is associated with this setting is returned, or &lt;code&gt;null&lt;/code&gt; if not available.</source>
          <target state="translated">如果设置缺少内容类型，则返回与此设置关联的类型的内容类型；如果不可用，则返回 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3303157e26b918aa41092329e21abb66fb1b45ac" translate="yes" xml:space="preserve">
          <source>If the setting lacks a description, the description for the type that is associated with this setting is returned, or &lt;code&gt;null&lt;/code&gt; if doesn't exist.</source>
          <target state="translated">如果设置缺少描述，则返回与此设置关联的类型的描述；如果不存在，则返回 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1fe14664f5baaf914d6c2209b660139b1bf58f90" translate="yes" xml:space="preserve">
          <source>If the setting lacks a label, the label for the type that is associated with this setting is returned, or &lt;code&gt;null&lt;/code&gt; if doesn't exist</source>
          <target state="translated">如果设置缺少标签，则返回与此设置关联的类型的标签；如果不存在，则返回 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="41dd85f3f179642b62aec20efd62519a0e7d8ea5" translate="yes" xml:space="preserve">
          <source>If the setting value is not valid for this setting, this method does not throw an exception. Instead, the value is ignored.</source>
          <target state="translated">如果设置值对该设置无效,本方法不会抛出异常。相反,该值将被忽略。</target>
        </trans-unit>
        <trans-unit id="d6f544e9f4637d730c544f2df049efe3bc2241c9" translate="yes" xml:space="preserve">
          <source>If the signs of arguments are unknown and a positive modulus is needed it can be computed as &lt;code&gt;(floorMod(x, y) + abs(y)) % abs(y)&lt;/code&gt;.</source>
          <target state="translated">如果参数的符号未知，并且需要正模数，则可以将其计算为 &lt;code&gt;(floorMod(x, y) + abs(y)) % abs(y)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3d63f4df1fec01d153e077a0cd492720daea9604" translate="yes" xml:space="preserve">
          <source>If the signs of the arguments are different, the quotient is negative and &lt;code&gt;floorDiv&lt;/code&gt; returns the integer less than or equal to the quotient and the &lt;code&gt;/&lt;/code&gt; operator returns the integer closest to zero.</source>
          <target state="translated">如果参数的符号不同，则商为负，而 &lt;code&gt;floorDiv&lt;/code&gt; 返回小于或等于商的整数， &lt;code&gt;/&lt;/code&gt; 运算符返回最接近零的整数。</target>
        </trans-unit>
        <trans-unit id="8b3eddbc3f191c883b4734fcd232862a579d8785" translate="yes" xml:space="preserve">
          <source>If the signs of the arguments are different, the results differ from the &lt;code&gt;%&lt;/code&gt; operator.</source>
          <target state="translated">如果参数的符号不同，则结果与 &lt;code&gt;%&lt;/code&gt; 运算符不同。</target>
        </trans-unit>
        <trans-unit id="8893f46ae7c980fbb6e68ff03e7cfa2f4485e10e" translate="yes" xml:space="preserve">
          <source>If the signs of the arguments are the same, the results of &lt;code&gt;floorDiv&lt;/code&gt; and the &lt;code&gt;/&lt;/code&gt; operator are the same.</source>
          <target state="translated">如果参数的符号相同，则 &lt;code&gt;floorDiv&lt;/code&gt; 和 &lt;code&gt;/&lt;/code&gt; 运算符的结果相同。</target>
        </trans-unit>
        <trans-unit id="e7d5446141374acaa0bf3d68df3adaaf0963a7c6" translate="yes" xml:space="preserve">
          <source>If the signs of the arguments are the same, the results of &lt;code&gt;floorMod&lt;/code&gt; and the &lt;code&gt;%&lt;/code&gt; operator are the same.</source>
          <target state="translated">如果参数的符号相同，则 &lt;code&gt;floorMod&lt;/code&gt; 和 &lt;code&gt;%&lt;/code&gt; 运算符的结果相同。</target>
        </trans-unit>
        <trans-unit id="7c0c3191c882ae94e067ec4dbb9ae1efa5c18a6b" translate="yes" xml:space="preserve">
          <source>If the size of the map (the number of key-value mappings) sufficiently exceeds the expected maximum size, the number of buckets is increased. Increasing the number of buckets (&quot;rehashing&quot;) may be fairly expensive, so it pays to create identity hash maps with a sufficiently large expected maximum size. On the other hand, iteration over collection views requires time proportional to the number of buckets in the hash table, so it pays not to set the expected maximum size too high if you are especially concerned with iteration performance or memory usage.</source>
          <target state="translated">如果映射的大小(键值映射的数量)充分超过了预期的最大大小,则增加桶的数量。增加桶的数量(&quot;重洗&quot;)可能会相当昂贵,因此创建具有足够大的预期最大尺寸的身份哈希图是值得的。另一方面,在集合视图上进行迭代需要的时间与哈希表中的桶数成正比,因此,如果你特别关注迭代性能或内存使用情况,最好不要将预期最大大小设置得太高。</target>
        </trans-unit>
        <trans-unit id="49af0f5d2c34bab8d6d7bf3a55a636eed438a349" translate="yes" xml:space="preserve">
          <source>If the smaller index is outside the list's range of cells, this method returns &lt;code&gt;null&lt;/code&gt;. If the smaller index is valid, but the larger index is outside the list's range, the bounds of just the first index is returned. Otherwise, the bounds of the valid range is returned.</source>
          <target state="translated">如果较小的索引不在列表的单元格范围内，则此方法返回 &lt;code&gt;null&lt;/code&gt; 。如果较小的索引有效，但是较大的索引超出列表的范围，则仅返回第一个索引的范围。否则，将返回有效范围的边界。</target>
        </trans-unit>
        <trans-unit id="b48f7eb14ba4fe0ba8d12278087b9bd58de5fe30" translate="yes" xml:space="preserve">
          <source>If the socket was bound prior to being &lt;a href=&quot;#close()&quot;&gt;&lt;code&gt;closed&lt;/code&gt;&lt;/a&gt;, then this method will continue to return &lt;code&gt;true&lt;/code&gt; after the socket is closed.</source>
          <target state="translated">如果套接字在&lt;a href=&quot;#close()&quot;&gt; &lt;code&gt;closed&lt;/code&gt; &lt;/a&gt;之前已绑定，则在套接字关闭后，此方法将继续返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c08afa2dd83781248a8b6598b34ddd6bd609cd7b" translate="yes" xml:space="preserve">
          <source>If the socket was bound prior to being &lt;a href=&quot;#close()&quot;&gt;&lt;code&gt;closed&lt;/code&gt;&lt;/a&gt;, then this method will continue to return the address of the endpoint after the socket is closed.</source>
          <target state="translated">如果套接字在&lt;a href=&quot;#close()&quot;&gt; &lt;code&gt;closed&lt;/code&gt; &lt;/a&gt;之前已绑定，则此方法将在套接字关闭后继续返回端点的地址。</target>
        </trans-unit>
        <trans-unit id="8ef9dc97922014b6a635ad3f24d3c2f309797f78" translate="yes" xml:space="preserve">
          <source>If the socket was bound prior to being &lt;a href=&quot;#close()&quot;&gt;&lt;code&gt;closed&lt;/code&gt;&lt;/a&gt;, then this method will continue to return the local address after the socket is closed.</source>
          <target state="translated">如果套接字在&lt;a href=&quot;#close()&quot;&gt; &lt;code&gt;closed&lt;/code&gt; &lt;/a&gt;之前已绑定，则此方法将在套接字关闭后继续返回本地地址。</target>
        </trans-unit>
        <trans-unit id="795364986502a26fa06bf27ac780aeadecd43628" translate="yes" xml:space="preserve">
          <source>If the socket was bound prior to being &lt;a href=&quot;#close()&quot;&gt;&lt;code&gt;closed&lt;/code&gt;&lt;/a&gt;, then this method will continue to return the local port number after the socket is closed.</source>
          <target state="translated">如果套接字在&lt;a href=&quot;#close()&quot;&gt; &lt;code&gt;closed&lt;/code&gt; &lt;/a&gt;之前已绑定，则此方法将在套接字关闭后继续返回本地端口号。</target>
        </trans-unit>
        <trans-unit id="22d427b6f3e432eb55922847295296fb762a16b8" translate="yes" xml:space="preserve">
          <source>If the socket was bound prior to being &lt;a href=&quot;#close()&quot;&gt;&lt;code&gt;closed&lt;/code&gt;&lt;/a&gt;, then this method will continue to return the port number after the socket is closed.</source>
          <target state="translated">如果套接字在&lt;a href=&quot;#close()&quot;&gt; &lt;code&gt;closed&lt;/code&gt; &lt;/a&gt;之前已绑定，则此方法将在套接字关闭后继续返回端口号。</target>
        </trans-unit>
        <trans-unit id="1b4b4f804a6b1c8756d6a9edd0658d83fbd67c5c" translate="yes" xml:space="preserve">
          <source>If the socket was bound prior to being &lt;a href=&quot;#close()&quot;&gt;closed&lt;/a&gt;, then this method will continue to return &lt;code&gt;true&lt;/code&gt; after the socket is closed.</source>
          <target state="translated">如果套接字在&lt;a href=&quot;#close()&quot;&gt;关闭&lt;/a&gt;之前已绑定，则在套接字关闭后，此方法将继续返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0ca2d090f17022dd5e73b01197f1d6848c079ffd" translate="yes" xml:space="preserve">
          <source>If the socket was bound prior to being &lt;a href=&quot;datagramsocket#close--&quot;&gt;&lt;code&gt;closed&lt;/code&gt;&lt;/a&gt;, then this method will continue to return &lt;code&gt;true&lt;/code&gt; after the socket is closed.</source>
          <target state="translated">如果套接字在&lt;a href=&quot;datagramsocket#close--&quot;&gt; &lt;code&gt;closed&lt;/code&gt; &lt;/a&gt;之前已绑定，则在套接字关闭后，此方法将继续返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="59679157176f257978bbe9def3e0740bb5fb205a" translate="yes" xml:space="preserve">
          <source>If the socket was bound prior to being &lt;a href=&quot;serversocket#close--&quot;&gt;&lt;code&gt;closed&lt;/code&gt;&lt;/a&gt;, then this method will continue to return the address of the endpoint after the socket is closed.</source>
          <target state="translated">如果套接字在&lt;a href=&quot;serversocket#close--&quot;&gt; &lt;code&gt;closed&lt;/code&gt; &lt;/a&gt;之前已绑定，则此方法将在套接字关闭后继续返回端点的地址。</target>
        </trans-unit>
        <trans-unit id="0e21984f9cc07335c38e61e8524fe85a27b1d410" translate="yes" xml:space="preserve">
          <source>If the socket was bound prior to being &lt;a href=&quot;serversocket#close--&quot;&gt;&lt;code&gt;closed&lt;/code&gt;&lt;/a&gt;, then this method will continue to return the local address after the socket is closed.</source>
          <target state="translated">如果套接字在&lt;a href=&quot;serversocket#close--&quot;&gt; &lt;code&gt;closed&lt;/code&gt; &lt;/a&gt;之前已绑定，则此方法将在套接字关闭后继续返回本地地址。</target>
        </trans-unit>
        <trans-unit id="763b9cd171c3cff366fd68dad3b49caafc1fe527" translate="yes" xml:space="preserve">
          <source>If the socket was bound prior to being &lt;a href=&quot;serversocket#close--&quot;&gt;&lt;code&gt;closed&lt;/code&gt;&lt;/a&gt;, then this method will continue to return the port number after the socket is closed.</source>
          <target state="translated">如果套接字在&lt;a href=&quot;serversocket#close--&quot;&gt; &lt;code&gt;closed&lt;/code&gt; &lt;/a&gt;之前已绑定，则此方法将在套接字关闭后继续返回端口号。</target>
        </trans-unit>
        <trans-unit id="cd6141b5241054244025e22ff3d73a0248d5fc8c" translate="yes" xml:space="preserve">
          <source>If the socket was bound prior to being &lt;a href=&quot;socket#close--&quot;&gt;&lt;code&gt;closed&lt;/code&gt;&lt;/a&gt;, then this method will continue to return the local port number after the socket is closed.</source>
          <target state="translated">如果套接字在&lt;a href=&quot;socket#close--&quot;&gt; &lt;code&gt;closed&lt;/code&gt; &lt;/a&gt;之前已绑定，则此方法将在套接字关闭后继续返回本地端口号。</target>
        </trans-unit>
        <trans-unit id="6e9dae5be20db8da3e58f51cd7b51d1fb85b6fbf" translate="yes" xml:space="preserve">
          <source>If the socket was connected prior to being &lt;a href=&quot;#close()&quot;&gt;&lt;code&gt;closed&lt;/code&gt;&lt;/a&gt;, then this method will continue to return &lt;code&gt;true&lt;/code&gt; after the socket is closed.</source>
          <target state="translated">如果套接字在&lt;a href=&quot;#close()&quot;&gt; &lt;code&gt;closed&lt;/code&gt; &lt;/a&gt;之前已连接，则此方法在套接字关闭后将继续返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="917ebef9402f85a9edd81896ca3483affe543bd7" translate="yes" xml:space="preserve">
          <source>If the socket was connected prior to being &lt;a href=&quot;#close()&quot;&gt;&lt;code&gt;closed&lt;/code&gt;&lt;/a&gt;, then this method will continue to return the connected address after the socket is closed.</source>
          <target state="translated">如果套接字在&lt;a href=&quot;#close()&quot;&gt; &lt;code&gt;closed&lt;/code&gt; &lt;/a&gt;之前已连接，则此方法将在套接字关闭后继续返回连接的地址。</target>
        </trans-unit>
        <trans-unit id="1204ee019c4cde4f66441dc7934326b11df3ec43" translate="yes" xml:space="preserve">
          <source>If the socket was connected prior to being &lt;a href=&quot;#close()&quot;&gt;&lt;code&gt;closed&lt;/code&gt;&lt;/a&gt;, then this method will continue to return the connected port number after the socket is closed.</source>
          <target state="translated">如果套接字在&lt;a href=&quot;#close()&quot;&gt; &lt;code&gt;closed&lt;/code&gt; &lt;/a&gt;之前已连接，则在套接字关闭后，此方法将继续返回已连接的端口号。</target>
        </trans-unit>
        <trans-unit id="7fc8e1670126679859d5c660bcdcb0e5c4dce29e" translate="yes" xml:space="preserve">
          <source>If the socket was connected prior to being &lt;a href=&quot;datagramsocket#close--&quot;&gt;&lt;code&gt;closed&lt;/code&gt;&lt;/a&gt;, then this method will continue to return &lt;code&gt;true&lt;/code&gt; after the socket is closed.</source>
          <target state="translated">如果套接字在&lt;a href=&quot;datagramsocket#close--&quot;&gt; &lt;code&gt;closed&lt;/code&gt; &lt;/a&gt;之前已连接，则在套接字关闭后，此方法将继续返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eded3cce47a4f9690c31a1eee5141c639e63658a" translate="yes" xml:space="preserve">
          <source>If the socket was connected prior to being &lt;a href=&quot;datagramsocket#close--&quot;&gt;&lt;code&gt;closed&lt;/code&gt;&lt;/a&gt;, then this method will continue to return the connected address after the socket is closed.</source>
          <target state="translated">如果套接字在&lt;a href=&quot;datagramsocket#close--&quot;&gt; &lt;code&gt;closed&lt;/code&gt; &lt;/a&gt;之前已连接，则在套接字关闭后，此方法将继续返回连接的地址。</target>
        </trans-unit>
        <trans-unit id="d3d182eb3854cd39ce3f790ae76cf8abf4ec7f3e" translate="yes" xml:space="preserve">
          <source>If the socket was connected prior to being &lt;a href=&quot;datagramsocket#close--&quot;&gt;&lt;code&gt;closed&lt;/code&gt;&lt;/a&gt;, then this method will continue to return the connected port number after the socket is closed.</source>
          <target state="translated">如果套接字在&lt;a href=&quot;datagramsocket#close--&quot;&gt; &lt;code&gt;closed&lt;/code&gt; &lt;/a&gt;之前已连接，则此方法将在套接字关闭后继续返回已连接的端口号。</target>
        </trans-unit>
        <trans-unit id="ac6a556c1933db902b091802b19407a613fc41d9" translate="yes" xml:space="preserve">
          <source>If the socket was connected prior to being &lt;a href=&quot;socket#close--&quot;&gt;&lt;code&gt;closed&lt;/code&gt;&lt;/a&gt;, then this method will continue to return the connected address after the socket is closed.</source>
          <target state="translated">如果套接字在&lt;a href=&quot;socket#close--&quot;&gt; &lt;code&gt;closed&lt;/code&gt; &lt;/a&gt;之前已连接，则在套接字关闭后，此方法将继续返回连接的地址。</target>
        </trans-unit>
        <trans-unit id="abfab3eeb26c13c0835e0da8c32c95bf0e46c4ed" translate="yes" xml:space="preserve">
          <source>If the socket was connected prior to being &lt;a href=&quot;socket#close--&quot;&gt;&lt;code&gt;closed&lt;/code&gt;&lt;/a&gt;, then this method will continue to return the connected port number after the socket is closed.</source>
          <target state="translated">如果套接字在&lt;a href=&quot;socket#close--&quot;&gt; &lt;code&gt;closed&lt;/code&gt; &lt;/a&gt;之前已连接，则此方法将在套接字关闭后继续返回已连接的端口号。</target>
        </trans-unit>
        <trans-unit id="ca2d424b7fdfc2a79a2dfc6c0453d110b7859bc0" translate="yes" xml:space="preserve">
          <source>If the source is &lt;a href=&quot;processbuilder.redirect#PIPE&quot;&gt;&lt;code&gt;Redirect.PIPE&lt;/code&gt;&lt;/a&gt; (the initial value), then the standard input of a subprocess can be written to using the output stream returned by &lt;a href=&quot;process#getOutputStream()&quot;&gt;&lt;code&gt;Process.getOutputStream()&lt;/code&gt;&lt;/a&gt;. If the source is set to any other value, then &lt;a href=&quot;process#getOutputStream()&quot;&gt;&lt;code&gt;Process.getOutputStream()&lt;/code&gt;&lt;/a&gt; will return a &lt;a href=&quot;#redirect-input&quot;&gt;null output stream&lt;/a&gt;.</source>
          <target state="translated">如果源是&lt;a href=&quot;processbuilder.redirect#PIPE&quot;&gt; &lt;code&gt;Redirect.PIPE&lt;/code&gt; &lt;/a&gt;（初始值），则可以使用&lt;a href=&quot;process#getOutputStream()&quot;&gt; &lt;code&gt;Process.getOutputStream()&lt;/code&gt; &lt;/a&gt;返回的输出流来写入子流程的标准输入。如果将源设置为任何其他值，则&lt;a href=&quot;process#getOutputStream()&quot;&gt; &lt;code&gt;Process.getOutputStream()&lt;/code&gt; &lt;/a&gt;将返回&lt;a href=&quot;#redirect-input&quot;&gt;空输出流&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c74e08fa061f46bcfc74bd1ceb1c899db939f1d9" translate="yes" xml:space="preserve">
          <source>If the source is &lt;a href=&quot;processbuilder.redirect#PIPE&quot;&gt;&lt;code&gt;Redirect.PIPE&lt;/code&gt;&lt;/a&gt; (the initial value), then the standard input of a subprocess can be written to using the output stream returned by &lt;a href=&quot;process#getOutputStream--&quot;&gt;&lt;code&gt;Process.getOutputStream()&lt;/code&gt;&lt;/a&gt;. If the source is set to any other value, then &lt;a href=&quot;process#getOutputStream--&quot;&gt;&lt;code&gt;Process.getOutputStream()&lt;/code&gt;&lt;/a&gt; will return a &lt;a href=&quot;#redirect-input&quot;&gt;null output stream&lt;/a&gt;.</source>
          <target state="translated">如果源是&lt;a href=&quot;processbuilder.redirect#PIPE&quot;&gt; &lt;code&gt;Redirect.PIPE&lt;/code&gt; &lt;/a&gt;（初始值），则可以使用&lt;a href=&quot;process#getOutputStream--&quot;&gt; &lt;code&gt;Process.getOutputStream()&lt;/code&gt; &lt;/a&gt;返回的输出流来写入子流程的标准输入。如果将源设置为任何其他值，则&lt;a href=&quot;process#getOutputStream--&quot;&gt; &lt;code&gt;Process.getOutputStream()&lt;/code&gt; &lt;/a&gt;将返回&lt;a href=&quot;#redirect-input&quot;&gt;空输出流&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f6c84516f9aebb90d613c9f7eb26a5e9fd1dca09" translate="yes" xml:space="preserve">
          <source>If the source is a BufferedImage with premultiplied alpha, the color components are divided by the alpha component before color conversion. If the destination is a BufferedImage with premultiplied alpha, the color components are multiplied by the alpha component after conversion. Rasters are treated as having no alpha channel, i.e. all bands are color bands.</source>
          <target state="translated">如果源是带有预乘alpha的BufferedImage,在颜色转换前,颜色分量被alpha分量分割。如果目标是一个预乘alpha的BufferedImage,则转换后的颜色分量要乘以alpha分量。栅格被视为没有alpha通道,即所有的带都是颜色带。</target>
        </trans-unit>
        <trans-unit id="1c6d739298af4f4dfdbeb07ff847cfc9d3c6a7a7" translate="yes" xml:space="preserve">
          <source>If the source of the PropertyChangeEvent &lt;code&gt;e&lt;/code&gt; equals the optionPane and is one of the ICON_PROPERTY, MESSAGE_PROPERTY, OPTIONS_PROPERTY or INITIAL_VALUE_PROPERTY, validateComponent is invoked.</source>
          <target state="translated">如果PropertyChangeEvent &lt;code&gt;e&lt;/code&gt; 的来源等于optionPane并且是ICON_PROPERTY，MESSAGE_PROPERTY，OPTIONS_PROPERTY或INITIAL_VALUE_PROPERTY之一，则将调用validateComponent。</target>
        </trans-unit>
        <trans-unit id="661f6402b0c9208e67543bc3982626f5f2502c0a" translate="yes" xml:space="preserve">
          <source>If the source of the notification is a reference to an MBean object, the MBean server will replace it by that MBean's ObjectName. Otherwise the source is unchanged.</source>
          <target state="translated">如果通知的来源是对MBean对象的引用,MBean服务器将用该MBean的ObjectName替换它。否则,通知的来源就不会改变。</target>
        </trans-unit>
        <trans-unit id="bc0afb74deac5658d35d1df20daa373ddaf8091c" translate="yes" xml:space="preserve">
          <source>If the spec's path component begins with a slash character &quot;/&quot; then the path is treated as absolute and the spec path replaces the context path.</source>
          <target state="translated">如果规范的路径组件以斜杠字符&quot;/&quot;开头,那么该路径将被视为绝对路径,规范路径将取代上下文路径。</target>
        </trans-unit>
        <trans-unit id="9a4f4b68138d4550ce0ad6e021c29ead94a8e3ad" translate="yes" xml:space="preserve">
          <source>If the specified &lt;code&gt;DataFlavor&lt;/code&gt; is previously unknown to the data transfer subsystem and the data transfer subsystem is unable to translate this &lt;code&gt;DataFlavor&lt;/code&gt; to any existing native, then invoking this method will establish a mapping in both directions between the specified &lt;code&gt;DataFlavor&lt;/code&gt; and an encoded version of its MIME type as its native.</source>
          <target state="translated">如果指定的 &lt;code&gt;DataFlavor&lt;/code&gt; 以前是数据传输子系统未知的，并且数据传输子系统无法将该 &lt;code&gt;DataFlavor&lt;/code&gt; 转换为任何现有的本机，则调用此方法将在指定的 &lt;code&gt;DataFlavor&lt;/code&gt; 及其MIME的编码版本之间建立双向映射输入其本机。</target>
        </trans-unit>
        <trans-unit id="ec28138e6077c419b066b58918bda314e27771f9" translate="yes" xml:space="preserve">
          <source>If the specified &lt;code&gt;locale&lt;/code&gt; contains &quot;cu&quot; and/or &quot;rg&quot; &lt;a href=&quot;locale#def_locale_extension&quot;&gt;Unicode extensions&lt;/a&gt;, the instance returned from this method reflects the values specified with those extensions. If both &quot;cu&quot; and &quot;rg&quot; are specified, the currency from the &quot;cu&quot; extension supersedes the implicit one from the &quot;rg&quot; extension.</source>
          <target state="translated">如果指定的 &lt;code&gt;locale&lt;/code&gt; 包含&amp;ldquo; cu&amp;rdquo;和/或&amp;ldquo; rg&amp;rdquo; &lt;a href=&quot;locale#def_locale_extension&quot;&gt;Unicode扩展名&lt;/a&gt;，则从此方法返回的实例将反映使用这些扩展名指定的值。如果同时指定了&amp;ldquo; cu&amp;rdquo;和&amp;ldquo; rg&amp;rdquo;，则来自&amp;ldquo; cu&amp;rdquo;扩展名的货币将取代来自&amp;ldquo; rg&amp;rdquo;扩展名的隐含货币。</target>
        </trans-unit>
        <trans-unit id="e385849f938ca3e361afb2eab43ee21415cbd43e" translate="yes" xml:space="preserve">
          <source>If the specified &lt;code&gt;locale&lt;/code&gt; contains &quot;rg&quot; (region override) &lt;a href=&quot;locale#def_locale_extension&quot;&gt;Unicode extension&lt;/a&gt;, the symbol returned from this method reflects the value specified with that extension.</source>
          <target state="translated">如果指定的 &lt;code&gt;locale&lt;/code&gt; 包含&amp;ldquo; rg&amp;rdquo;（区域覆盖）&lt;a href=&quot;locale#def_locale_extension&quot;&gt;Unicode扩展名&lt;/a&gt;，则此方法返回的符号将反映该扩展名指定的值。</target>
        </trans-unit>
        <trans-unit id="257aba8bf323b9c1c989b22a9946ac7416be5538" translate="yes" xml:space="preserve">
          <source>If the specified &lt;code&gt;name&lt;/code&gt; begins with &quot;&lt;code&gt;java.&lt;/code&gt;&quot;, it can only be defined by the &lt;a href=&quot;#getPlatformClassLoader()&quot;&gt;platform class loader&lt;/a&gt; or its ancestors; otherwise &lt;code&gt;SecurityException&lt;/code&gt; will be thrown. If &lt;code&gt;name&lt;/code&gt; is not &lt;code&gt;null&lt;/code&gt;, it must be equal to the &lt;a href=&quot;#binary-name&quot;&gt;binary name&lt;/a&gt; of the class specified by the byte array &lt;code&gt;b&lt;/code&gt;, otherwise a &lt;a href=&quot;noclassdeffounderror&quot;&gt;&lt;code&gt;NoClassDefFoundError&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">如果指定的 &lt;code&gt;name&lt;/code&gt; 以&amp;ldquo; &lt;code&gt;java.&lt;/code&gt; &amp;rdquo;开头，则只能由&lt;a href=&quot;#getPlatformClassLoader()&quot;&gt;平台类加载器&lt;/a&gt;或其祖先定义；否则，请参见参考。否则将抛出 &lt;code&gt;SecurityException&lt;/code&gt; 。如果 &lt;code&gt;name&lt;/code&gt; 不为 &lt;code&gt;null&lt;/code&gt; ，则它必须等于字节数组 &lt;code&gt;b&lt;/code&gt; 指定的类的&lt;a href=&quot;#binary-name&quot;&gt;二进制名称&lt;/a&gt;，否则将抛出&lt;a href=&quot;noclassdeffounderror&quot;&gt; &lt;code&gt;NoClassDefFoundError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="97c03df7f79f779f19dbd94c565abdfcc104d7ca" translate="yes" xml:space="preserve">
          <source>If the specified IP address is bound to multiple network interfaces it is not defined which network interface is returned.</source>
          <target state="translated">如果指定的IP地址绑定到多个网络接口,则不定义返回哪个网络接口。</target>
        </trans-unit>
        <trans-unit id="96c68f935629df479cecc1daf2323805432c7c1f" translate="yes" xml:space="preserve">
          <source>If the specified amount is a &lt;code&gt;ChronoPeriod&lt;/code&gt; then it must have the same chronology as this period. Implementations may choose to accept or reject other &lt;code&gt;TemporalAmount&lt;/code&gt; implementations.</source>
          <target state="translated">如果指定的数量是一个 &lt;code&gt;ChronoPeriod&lt;/code&gt; ,则它必须与此时间段具有相同的年代。实现可以选择接受或拒绝其他 &lt;code&gt;TemporalAmount&lt;/code&gt; 实现。</target>
        </trans-unit>
        <trans-unit id="09cff20bf42b9ad1e7365bfddfe3a021913c702f" translate="yes" xml:space="preserve">
          <source>If the specified calendar doesn't support week dates, the &lt;a href=&quot;#build()&quot;&gt;&lt;code&gt;build&lt;/code&gt;&lt;/a&gt; method will throw an &lt;a href=&quot;../lang/illegalargumentexception&quot;&gt;&lt;code&gt;IllegalArgumentException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果指定的日历不支持星期几，则&lt;a href=&quot;#build()&quot;&gt; &lt;code&gt;build&lt;/code&gt; &lt;/a&gt;方法将抛出&lt;a href=&quot;../lang/illegalargumentexception&quot;&gt; &lt;code&gt;IllegalArgumentException&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="aeb138890341e49f448dcdb19a0436d6eccb12fa" translate="yes" xml:space="preserve">
          <source>If the specified calendar doesn't support week dates, the &lt;a href=&quot;calendar.builder#build--&quot;&gt;&lt;code&gt;build&lt;/code&gt;&lt;/a&gt; method will throw an &lt;a href=&quot;../lang/illegalargumentexception&quot;&gt;&lt;code&gt;IllegalArgumentException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果指定的日历不支持星期几，则&lt;a href=&quot;calendar.builder#build--&quot;&gt; &lt;code&gt;build&lt;/code&gt; &lt;/a&gt;方法将抛出&lt;a href=&quot;../lang/illegalargumentexception&quot;&gt; &lt;code&gt;IllegalArgumentException&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="21d5a2365b7e2ef9cdf719d377a83491e9b996d8" translate="yes" xml:space="preserve">
          <source>If the specified comment is &lt;code&gt;null&lt;/code&gt; then no comment will be stored in the document.</source>
          <target state="translated">如果指定的注释为 &lt;code&gt;null&lt;/code&gt; 则文档中不会存储任何注释。</target>
        </trans-unit>
        <trans-unit id="5c00aef2c14db555263f047e1c32a11c40196454" translate="yes" xml:space="preserve">
          <source>If the specified comparator is &lt;code&gt;null&lt;/code&gt; then all elements in this list must implement the &lt;a href=&quot;../../lang/comparable&quot;&gt;&lt;code&gt;Comparable&lt;/code&gt;&lt;/a&gt; interface and the elements' &lt;a href=&quot;../../lang/comparable&quot;&gt;natural ordering&lt;/a&gt; should be used.</source>
          <target state="translated">如果指定的比较器为 &lt;code&gt;null&lt;/code&gt; ,则此列表中的所有元素都必须实现&lt;a href=&quot;../../lang/comparable&quot;&gt; &lt;code&gt;Comparable&lt;/code&gt; &lt;/a&gt;接口，并且应使用元素的&lt;a href=&quot;../../lang/comparable&quot;&gt;自然顺序&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="aefe2d484ac87a9f75945af0a56cb6b62891cb32" translate="yes" xml:space="preserve">
          <source>If the specified comparator is &lt;code&gt;null&lt;/code&gt; then all elements in this list must implement the &lt;a href=&quot;../lang/comparable&quot;&gt;&lt;code&gt;Comparable&lt;/code&gt;&lt;/a&gt; interface and the elements' &lt;a href=&quot;../lang/comparable&quot;&gt;natural ordering&lt;/a&gt; should be used.</source>
          <target state="translated">如果指定的比较器为 &lt;code&gt;null&lt;/code&gt; ,则此列表中的所有元素都必须实现&lt;a href=&quot;../lang/comparable&quot;&gt; &lt;code&gt;Comparable&lt;/code&gt; &lt;/a&gt;接口，并且应使用元素的&lt;a href=&quot;../lang/comparable&quot;&gt;自然顺序&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2a543a9a4c58a21fee89ee30e3c66f4521a79acb" translate="yes" xml:space="preserve">
          <source>If the specified component is already a child of this then we don't bother doing anything - stacking order doesn't matter for cell renderer components (CellRendererPane doesn't paint anyway).</source>
          <target state="translated">如果指定的组件已经是这个组件的子代,那么我们就不用做任何事情了--堆叠顺序对于单元格渲染器组件来说并不重要(反正CellRendererPane不会画)。</target>
        </trans-unit>
        <trans-unit id="1142a4e571e7e45e0126c1fa376f4b7549ff134a" translate="yes" xml:space="preserve">
          <source>If the specified date-time has already passed, the job must be a candidate for processing immediately. Thus, one way to make the job immediately become a candidate for processing is to specify a &lt;code&gt;JobHoldUntil&lt;/code&gt; attribute constructed like this (denoting a date-time of January 1, 1970, 00:00:00 GMT):</source>
          <target state="translated">如果指定的日期时间已经过去，则该作业必须是立即处理的候选对象。因此，使作业立即成为要处理的候选者的一种方法是指定一个像这样构造的 &lt;code&gt;JobHoldUntil&lt;/code&gt; 属性（表示日期时间为格林尼治标准时间1970年1月1日00:00:00）：</target>
        </trans-unit>
        <trans-unit id="e90b9efbdd73e57fac8cf7dcbd6a9324c80a3a89" translate="yes" xml:space="preserve">
          <source>If the specified date-time has already passed, the job must be a candidate for processing immediately. Thus, one way to make the job immediately become a candidate for processing is to specify a JobHoldUntil attribute constructed like this (denoting a date-time of January 1, 1970, 00:00:00 GMT):</source>
          <target state="translated">如果指定的日期时间已经过去,该作业必须立即成为处理的候选者。因此,使作业立即成为处理候选者的一种方法是指定一个像这样构造的JobHoldUntil属性(表示日期时间为1970年1月1日00:00:00 GMT)。</target>
        </trans-unit>
        <trans-unit id="7cc62287dac9dd3318ff0227906bfc56c107c2f1" translate="yes" xml:space="preserve">
          <source>If the specified driver is not found in the list of registered drivers, then no action is taken. If the driver was found, it will be removed from the list of registered drivers.</source>
          <target state="translated">如果在注册司机名单中没有找到指定的司机,则不采取任何行动。如果找到了驱动程序,则会从注册驱动程序列表中删除。</target>
        </trans-unit>
        <trans-unit id="9579f0c52418214efdc0671f46a3ff5e4527ea42" translate="yes" xml:space="preserve">
          <source>If the specified field is present, this method returns a non-null non-negative &lt;a href=&quot;../../../../java.base/java/lang/number&quot;&gt;&lt;code&gt;Number&lt;/code&gt;&lt;/a&gt; object that represents its value. If it is not present, return null. For YEARS, MONTHS, DAYS, HOURS, and MINUTES, this method returns a &lt;a href=&quot;../../../../java.base/java/math/biginteger&quot;&gt;&lt;code&gt;BigInteger&lt;/code&gt;&lt;/a&gt; object. For SECONDS, this method returns a &lt;a href=&quot;../../../../java.base/java/math/bigdecimal&quot;&gt;&lt;code&gt;BigDecimal&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果存在指定的字段，则此方法返回一个表示其值的非null非负&lt;a href=&quot;../../../../java.base/java/lang/number&quot;&gt; &lt;code&gt;Number&lt;/code&gt; &lt;/a&gt;对象。如果不存在，则返回null。对于YEARS，MONTHS，DAYS，HOURS和MINUTES，此方法返回&lt;a href=&quot;../../../../java.base/java/math/biginteger&quot;&gt; &lt;code&gt;BigInteger&lt;/code&gt; &lt;/a&gt;对象。对于SECONDS，此方法返回一个&lt;a href=&quot;../../../../java.base/java/math/bigdecimal&quot;&gt; &lt;code&gt;BigDecimal&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ab27614aa1a1e159b8f3228af15f24fff13239ec" translate="yes" xml:space="preserve">
          <source>If the specified file is a directory, the file manager of the current platform is launched to open it.</source>
          <target state="translated">如果指定的文件是一个目录,则启动当前平台的文件管理器来打开它。</target>
        </trans-unit>
        <trans-unit id="6ddc595a62cbea355de55b31675b042692a29bee" translate="yes" xml:space="preserve">
          <source>If the specified host is &lt;code&gt;null&lt;/code&gt; it is the equivalent of specifying the address as &lt;a href=&quot;inetaddress#getByName(java.lang.String)&quot;&gt;&lt;code&gt;InetAddress.getByName&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(null)&lt;/code&gt;. In other words, it is equivalent to specifying an address of the loopback interface.</source>
          <target state="translated">如果指定的主机为 &lt;code&gt;null&lt;/code&gt; ，则等效于将地址指定为&lt;a href=&quot;inetaddress#getByName(java.lang.String)&quot;&gt; &lt;code&gt;InetAddress.getByName&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(null)&lt;/code&gt; 。换句话说，这等效于指定回送接口的地址。</target>
        </trans-unit>
        <trans-unit id="2496623a004f15dd4819ee54aa8493f7e338eba3" translate="yes" xml:space="preserve">
          <source>If the specified host is &lt;code&gt;null&lt;/code&gt; it is the equivalent of specifying the address as &lt;a href=&quot;inetaddress#getByName-java.lang.String-&quot;&gt;&lt;code&gt;InetAddress.getByName&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(null)&lt;/code&gt;. In other words, it is equivalent to specifying an address of the loopback interface.</source>
          <target state="translated">如果指定的主机为 &lt;code&gt;null&lt;/code&gt; ，则等效于将地址指定为&lt;a href=&quot;inetaddress#getByName-java.lang.String-&quot;&gt; &lt;code&gt;InetAddress.getByName&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(null)&lt;/code&gt; 。换句话说，这等效于指定回送接口的地址。</target>
        </trans-unit>
        <trans-unit id="c33d8531f7d2499b880c450b0b37d9ef3fa77c82" translate="yes" xml:space="preserve">
          <source>If the specified key is not already associated with a (non-null) value, associates it with the given value.</source>
          <target state="translated">如果指定的键没有与一个(非空)值关联,则将其与给定的值关联。</target>
        </trans-unit>
        <trans-unit id="900d04445ca5a80f48077470ed1101681577ef82" translate="yes" xml:space="preserve">
          <source>If the specified key is not already associated with a (non-null) value, associates it with the given value. Otherwise, replaces the value with the results of the given remapping function, or removes if &lt;code&gt;null&lt;/code&gt;. The entire method invocation is performed atomically. Some attempted update operations on this map by other threads may be blocked while computation is in progress, so the computation should be short and simple, and must not attempt to update any other mappings of this Map.</source>
          <target state="translated">如果指定的键尚未与（非空）值关联，请将其与给定值关联。否则，用给定的重映射函数的结果替换该值，如果为 &lt;code&gt;null&lt;/code&gt; ，则将其删除。整个方法调用是原子执行的。在计算进行过程中，可能会阻止其他线程对该映射进行的某些尝试的更新操作，因此计算应简短而简单，并且不得尝试更新此Map的任何其他映射。</target>
        </trans-unit>
        <trans-unit id="327e72df9ef84db72836c87a15ef8d4fb475f995" translate="yes" xml:space="preserve">
          <source>If the specified key is not already associated with a value (or is mapped to &lt;code&gt;null&lt;/code&gt;) associates it with the given value and returns &lt;code&gt;null&lt;/code&gt;, else returns the current value.</source>
          <target state="translated">如果指定键尚未与值关联（或映射为 &lt;code&gt;null&lt;/code&gt; ），则将其与给定值关联并返回 &lt;code&gt;null&lt;/code&gt; ，否则返回当前值。</target>
        </trans-unit>
        <trans-unit id="7b0beef1230b8f936ac0be883b146508d29a805b" translate="yes" xml:space="preserve">
          <source>If the specified key is not already associated with a value (or is mapped to &lt;code&gt;null&lt;/code&gt;), attempts to compute its value using the given mapping function and enters it into this map unless &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">如果指定的键尚未与值关联（或映射为 &lt;code&gt;null&lt;/code&gt; ），则尝试使用给定的映射函数计算其值，除非 &lt;code&gt;null&lt;/code&gt; ,否则将其输入此映射。</target>
        </trans-unit>
        <trans-unit id="59de12c4feb8699041392433808d90a4be2dd1b8" translate="yes" xml:space="preserve">
          <source>If the specified key is not already associated with a value or is associated with null, associates it with the given non-null value.</source>
          <target state="translated">如果指定的键还没有与值相关联或与null相关联,则将其与给定的非空值相关联。</target>
        </trans-unit>
        <trans-unit id="50fe8f5b029680a754d045deccf54d554f1ecb50" translate="yes" xml:space="preserve">
          <source>If the specified key is not already associated with a value or is associated with null, associates it with the given non-null value. Otherwise, replaces the associated value with the results of the given remapping function, or removes if the result is &lt;code&gt;null&lt;/code&gt;. This method may be of use when combining multiple mapped values for a key. For example, to either create or append a &lt;code&gt;String msg&lt;/code&gt; to a value mapping:</source>
          <target state="translated">如果指定的键尚未与值关联或与null关联，请将其与给定的非null值关联。否则，用给定的重映射函数的结果替换关联的值，或者如果结果为 &lt;code&gt;null&lt;/code&gt; ，则将其删除。当组合一个键的多个映射值时，此方法可能有用。例如，要将 &lt;code&gt;String msg&lt;/code&gt; 创建或附加到值映射：</target>
        </trans-unit>
        <trans-unit id="ec2236aaf5d6e4455671d55125f8980e4fa9768d" translate="yes" xml:space="preserve">
          <source>If the specified key is not already associated with a value or is associated with null, associates it with the given value.</source>
          <target state="translated">如果指定的键还没有与值相关联或者与null相关联,则将其与给定的值相关联。</target>
        </trans-unit>
        <trans-unit id="07aab8862177972b392beb8f0bf5c9cd52e38ac3" translate="yes" xml:space="preserve">
          <source>If the specified key is not already associated with a value or is associated with null, associates it with the given value. Otherwise, replaces the value with the results of the given remapping function, or removes if the result is null. This method may be of use when combining multiple mapped values for a key.</source>
          <target state="translated">如果指定的键还没有与一个值相关联,或者与空值相关联,则将其与给定的值相关联,否则,用给定的重映射函数的结果替换值,如果结果为空,则删除。否则,用给定的重映射函数的结果替换该值,如果结果为空,则删除。当组合一个键的多个映射值时,可以使用这个方法。</target>
        </trans-unit>
        <trans-unit id="f4925c79cda2f9aaf0050cbbfb1bd9cb1cde5984" translate="yes" xml:space="preserve">
          <source>If the specified key is not already associated with a value, associate it with the given value. This is equivalent to</source>
          <target state="translated">如果指定的键还没有与值关联,则将其与给定的值关联。这相当于</target>
        </trans-unit>
        <trans-unit id="d4876e55c0474ed2aee75208b622ba1f147600e9" translate="yes" xml:space="preserve">
          <source>If the specified key is not already associated with a value, associates it with the given value.</source>
          <target state="translated">如果指定的键没有与值关联,则将其与给定的值关联。</target>
        </trans-unit>
        <trans-unit id="df5a13cc298f2e36b4088599af2bf52a36c46112" translate="yes" xml:space="preserve">
          <source>If the specified key is not already associated with a value, associates it with the given value. Otherwise, replaces the value with the results of the given remapping function, or removes if &lt;code&gt;null&lt;/code&gt;. The function is &lt;em&gt;NOT&lt;/em&gt; guaranteed to be applied once atomically.</source>
          <target state="translated">如果指定的键尚未与值关联，则将其与给定的值关联。否则，用给定的重映射函数的结果替换该值，如果为 &lt;code&gt;null&lt;/code&gt; ，则将其删除。&lt;em&gt;不&lt;/em&gt;保证该功能可以原子应用一次。</target>
        </trans-unit>
        <trans-unit id="e0e2aa4c62a637c17a37f4738b005d30fd80554c" translate="yes" xml:space="preserve">
          <source>If the specified key is not already associated with a value, associates it with the given value. This is equivalent to, for this &lt;code&gt;map&lt;/code&gt;:</source>
          <target state="translated">如果指定的键尚未与值关联，则将其与给定的值关联。对于此 &lt;code&gt;map&lt;/code&gt; ，这等效于：</target>
        </trans-unit>
        <trans-unit id="6107b4d5266bf408264e8a734eb446c3449b2b14" translate="yes" xml:space="preserve">
          <source>If the specified key is not already associated with a value, attempts to compute its value using the given mapping function and enters it into this map unless &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">如果指定的键尚未与值相关联，则尝试使用给定的映射函数计算其值，除非 &lt;code&gt;null&lt;/code&gt; ,否则将其输入到此映射中。</target>
        </trans-unit>
        <trans-unit id="551c906c1bb44aa217c725bb3e6835b67419ea34" translate="yes" xml:space="preserve">
          <source>If the specified key is not already associated with a value, attempts to compute its value using the given mapping function and enters it into this map unless &lt;code&gt;null&lt;/code&gt;. The entire method invocation is performed atomically, so the function is applied at most once per key. Some attempted update operations on this map by other threads may be blocked while computation is in progress, so the computation should be short and simple, and must not attempt to update any other mappings of this map.</source>
          <target state="translated">如果指定的键尚未与值关联，则尝试使用给定的映射函数计算其值，除非 &lt;code&gt;null&lt;/code&gt; ,否则将其输入此映射。整个方法调用是原子执行的，因此每个键最多可应用一次该功能。在计算进行期间，可能会阻止其他线程在此映射上进行的某些尝试的更新操作，因此计算应简短而简单，并且不得尝试更新此映射的任何其他映射。</target>
        </trans-unit>
        <trans-unit id="a7ba2104811a8cc71437ff79090a01cae2c82bf2" translate="yes" xml:space="preserve">
          <source>If the specified key is not already associated with a value, attempts to compute its value using the given mapping function and enters it into this map unless &lt;code&gt;null&lt;/code&gt;. The entire method invocation is performed atomically. The supplied function is invoked exactly once per invocation of this method if the key is absent, else not at all. Some attempted update operations on this map by other threads may be blocked while computation is in progress, so the computation should be short and simple.</source>
          <target state="translated">如果指定的键尚未与值关联，则尝试使用给定的映射函数计算其值，除非 &lt;code&gt;null&lt;/code&gt; ,否则将其输入此映射。整个方法调用是原子执行的。如果不存在该键，则每次调用此方法时，所提供的函数将仅被调用一次，否则将完全不被调用。在计算进行过程中，可能会阻止其他线程对此映射进行的某些尝试的更新操作，因此计算应简短而简单。</target>
        </trans-unit>
        <trans-unit id="199aa69d5cf4c4d157c5d05ec7094035a1890fc8" translate="yes" xml:space="preserve">
          <source>If the specified key is not already associated with a value, attempts to compute its value using the given mapping function and enters it into this map unless &lt;code&gt;null&lt;/code&gt;. The function is &lt;em&gt;NOT&lt;/em&gt; guaranteed to be applied once atomically only if the value is not present.</source>
          <target state="translated">如果指定的键尚未与值关联，则尝试使用给定的映射函数计算其值，除非 &lt;code&gt;null&lt;/code&gt; ,否则将其输入此映射。仅当该值不存在时，才能保证该函数&lt;em&gt;不能&lt;/em&gt;自动应用一次。</target>
        </trans-unit>
        <trans-unit id="ac522be26b00567361a746d74b58f7524d15d7ee" translate="yes" xml:space="preserve">
          <source>If the specified language tag contains any ill-formed subtags, the first such subtag and all following subtags are ignored. Compare to &lt;a href=&quot;locale.builder#setLanguageTag(java.lang.String)&quot;&gt;&lt;code&gt;Locale.Builder.setLanguageTag(java.lang.String)&lt;/code&gt;&lt;/a&gt; which throws an exception in this case.</source>
          <target state="translated">如果指定的语言标签包含任何格式错误的子标签，则将忽略第一个此类子标签和所有后续子标签。与&lt;a href=&quot;locale.builder#setLanguageTag(java.lang.String)&quot;&gt; &lt;code&gt;Locale.Builder.setLanguageTag(java.lang.String)&lt;/code&gt; &lt;/a&gt;进行比较，后者在这种情况下会引发异常。</target>
        </trans-unit>
        <trans-unit id="74ec46a56735923288ea9182f5be9a7235b7c574" translate="yes" xml:space="preserve">
          <source>If the specified language tag contains any ill-formed subtags, the first such subtag and all following subtags are ignored. Compare to &lt;a href=&quot;locale.builder#setLanguageTag-java.lang.String-&quot;&gt;&lt;code&gt;Locale.Builder.setLanguageTag(java.lang.String)&lt;/code&gt;&lt;/a&gt; which throws an exception in this case.</source>
          <target state="translated">如果指定的语言标签包含任何格式错误的子标签，则将忽略第一个此类子标签和所有后续子标签。与&lt;a href=&quot;locale.builder#setLanguageTag-java.lang.String-&quot;&gt; &lt;code&gt;Locale.Builder.setLanguageTag(java.lang.String)&lt;/code&gt; &lt;/a&gt;进行比较，后者在这种情况下会引发异常。</target>
        </trans-unit>
        <trans-unit id="495384335ab36e262e909f5285ee42e18f9010ef" translate="yes" xml:space="preserve">
          <source>If the specified list is small or implements the &lt;a href=&quot;randomaccess&quot;&gt;&lt;code&gt;RandomAccess&lt;/code&gt;&lt;/a&gt; interface, this implementation exchanges the first element into the location it should go, and then repeatedly exchanges the displaced element into the location it should go until a displaced element is swapped into the first element. If necessary, the process is repeated on the second and successive elements, until the rotation is complete. If the specified list is large and doesn't implement the &lt;code&gt;RandomAccess&lt;/code&gt; interface, this implementation breaks the list into two sublist views around index &lt;code&gt;-distance mod size&lt;/code&gt;. Then the &lt;a href=&quot;#reverse(java.util.List)&quot;&gt;&lt;code&gt;reverse(List)&lt;/code&gt;&lt;/a&gt; method is invoked on each sublist view, and finally it is invoked on the entire list. For a more complete description of both algorithms, see Section 2.3 of Jon Bentley's</source>
          <target state="translated">如果指定的列表很小或实现了&lt;a href=&quot;randomaccess&quot;&gt; &lt;code&gt;RandomAccess&lt;/code&gt; &lt;/a&gt;接口，则此实现将第一个元素交换到它应该去的位置，然后反复将置换的元素交换到它应该去的位置，直到将置换的元素交换到第一个元素中。如有必要，在第二个和后续元素上重复此过程，直到完成旋转。如果指定的列表很大并且没有实现 &lt;code&gt;RandomAccess&lt;/code&gt; 接口，则此实现将列表分为两个围绕index- &lt;code&gt;-distance mod size&lt;/code&gt; 子列表视图。然后&lt;a href=&quot;#reverse(java.util.List)&quot;&gt; &lt;code&gt;reverse(List)&lt;/code&gt; &lt;/a&gt;方法在每个子列表视图上被调用，最后在整个列表上被调用。有关这两种算法的更完整说明，请参见乔恩&amp;middot;本特利（Jon Bentley）的第2.3节</target>
        </trans-unit>
        <trans-unit id="29e16cfca3f81f7f2c484ea21572aa935aba3557" translate="yes" xml:space="preserve">
          <source>If the specified list is small or implements the &lt;a href=&quot;randomaccess&quot;&gt;&lt;code&gt;RandomAccess&lt;/code&gt;&lt;/a&gt; interface, this implementation exchanges the first element into the location it should go, and then repeatedly exchanges the displaced element into the location it should go until a displaced element is swapped into the first element. If necessary, the process is repeated on the second and successive elements, until the rotation is complete. If the specified list is large and doesn't implement the &lt;code&gt;RandomAccess&lt;/code&gt; interface, this implementation breaks the list into two sublist views around index &lt;code&gt;-distance mod size&lt;/code&gt;. Then the &lt;a href=&quot;collections#reverse-java.util.List-&quot;&gt;&lt;code&gt;reverse(List)&lt;/code&gt;&lt;/a&gt; method is invoked on each sublist view, and finally it is invoked on the entire list. For a more complete description of both algorithms, see Section 2.3 of Jon Bentley's</source>
          <target state="translated">如果指定的列表很小或实现了&lt;a href=&quot;randomaccess&quot;&gt; &lt;code&gt;RandomAccess&lt;/code&gt; &lt;/a&gt;接口，则此实现将第一个元素交换到它应该去的位置，然后反复将置换的元素交换到它应该去的位置，直到将置换的元素交换到第一个元素中。如有必要，在第二个和后续元素上重复此过程，直到完成旋转。如果指定的列表很大，并且没有实现 &lt;code&gt;RandomAccess&lt;/code&gt; 接口，则此实现将列表分为两个围绕index- &lt;code&gt;-distance mod size&lt;/code&gt; 子列表视图。然后&lt;a href=&quot;collections#reverse-java.util.List-&quot;&gt; &lt;code&gt;reverse(List)&lt;/code&gt; &lt;/a&gt;方法在每个子列表视图上被调用，最后在整个列表上被调用。有关这两种算法的更完整说明，请参见乔恩&amp;middot;本特利（Jon Bentley）的第2.3节</target>
        </trans-unit>
        <trans-unit id="a34d2ff62cb9dee92bc87d570b5cda8f97027ea5" translate="yes" xml:space="preserve">
          <source>If the specified local address is &lt;code&gt;null&lt;/code&gt; it is the equivalent of specifying the address as the AnyLocal address (see &lt;a href=&quot;inetaddress#isAnyLocalAddress()&quot;&gt;&lt;code&gt;InetAddress.isAnyLocalAddress&lt;/code&gt;&lt;/a&gt;&lt;code&gt;()&lt;/code&gt;).</source>
          <target state="translated">如果指定的本地地址为 &lt;code&gt;null&lt;/code&gt; ，则等效于将地址指定为AnyLocal地址（请参见&lt;a href=&quot;inetaddress#isAnyLocalAddress()&quot;&gt; &lt;code&gt;InetAddress.isAnyLocalAddress&lt;/code&gt; &lt;/a&gt; &lt;code&gt;()&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="e207478f4c307f8daec04a1eb43edfa1b56c4337" translate="yes" xml:space="preserve">
          <source>If the specified local address is &lt;code&gt;null&lt;/code&gt; it is the equivalent of specifying the address as the AnyLocal address (see &lt;a href=&quot;inetaddress#isAnyLocalAddress--&quot;&gt;&lt;code&gt;InetAddress.isAnyLocalAddress&lt;/code&gt;&lt;/a&gt;&lt;code&gt;()&lt;/code&gt;).</source>
          <target state="translated">如果指定的本地地址为 &lt;code&gt;null&lt;/code&gt; ，则等效于将地址指定为AnyLocal地址（请参见&lt;a href=&quot;inetaddress#isAnyLocalAddress--&quot;&gt; &lt;code&gt;InetAddress.isAnyLocalAddress&lt;/code&gt; &lt;/a&gt; &lt;code&gt;()&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="e20d600ab6dd5dfc2718408c731259b979d97003" translate="yes" xml:space="preserve">
          <source>If the specified locale contains &quot;ca&quot; (calendar), &quot;rg&quot; (region override), and/or &quot;tz&quot; (timezone) &lt;a href=&quot;../util/locale#def_locale_extension&quot;&gt;Unicode extensions&lt;/a&gt;, the calendar, the country and/or the time zone for formatting are overridden. If both &quot;ca&quot; and &quot;rg&quot; are specified, the calendar from the &quot;ca&quot; extension supersedes the implicit one from the &quot;rg&quot; extension.</source>
          <target state="translated">如果指定的语言环境包含&amp;ldquo; ca&amp;rdquo;（日历），&amp;ldquo; rg&amp;rdquo;（区域替代）和/或&amp;ldquo; tz&amp;rdquo;（时区）&lt;a href=&quot;../util/locale#def_locale_extension&quot;&gt;Unicode扩展名&lt;/a&gt;，则日历，国家/地区和/或用于格式化的时区将被覆盖。如果同时指定了&amp;ldquo; ca&amp;rdquo;和&amp;ldquo; rg&amp;rdquo;，则来自&amp;ldquo; ca&amp;rdquo;扩展名的日历将取代来自&amp;ldquo; rg&amp;rdquo;扩展名的隐式日历。</target>
        </trans-unit>
        <trans-unit id="880a5d6295e66934e1af3a345f9a64565c2063d5" translate="yes" xml:space="preserve">
          <source>If the specified locale contains the &quot;&lt;code&gt;cf&lt;/code&gt;&quot; ( &lt;a href=&quot;https://www.unicode.org/reports/tr35/tr35.html#UnicodeCurrencyFormatIdentifier&quot;&gt; currency format style&lt;/a&gt;) &lt;a href=&quot;../util/locale#def_locale_extension&quot;&gt;Unicode extension&lt;/a&gt;, the returned currency format uses the style if it is available. Otherwise, the style uses the default &quot;&lt;code&gt;standard&lt;/code&gt;&quot; currency format. For example, if the style designates &quot;&lt;code&gt;account&lt;/code&gt;&quot;, negative currency amounts use a pair of parentheses in some locales.</source>
          <target state="translated">如果指定的语言环境包含&amp;ldquo; &lt;code&gt;cf&lt;/code&gt; &amp;rdquo;（&lt;a href=&quot;https://www.unicode.org/reports/tr35/tr35.html#UnicodeCurrencyFormatIdentifier&quot;&gt;货币格式样式&lt;/a&gt;）&lt;a href=&quot;../util/locale#def_locale_extension&quot;&gt;Unicode扩展名&lt;/a&gt;，则返回的货币格式将使用该样式（如果可用）。否则，样式将使用默认的&amp;ldquo; &lt;code&gt;standard&lt;/code&gt; &amp;rdquo;货币格式。例如，如果样式指定为&amp;ldquo; &lt;code&gt;account&lt;/code&gt; &amp;rdquo;，则负货币金额在某些语言环境中使用一对括号。</target>
        </trans-unit>
        <trans-unit id="3bb4277707fb1b363f377904ef8a00ae80162edc" translate="yes" xml:space="preserve">
          <source>If the specified name is already in the list of enabled attribute names, this method has no effect.</source>
          <target state="translated">如果指定的名称已经在启用的属性名列表中,本方法没有任何效果。</target>
        </trans-unit>
        <trans-unit id="5fdd0b3e89e1f58df16acb73daa9598c19a8c783" translate="yes" xml:space="preserve">
          <source>If the specified name is not in the list of enabled attribute names, this method has no effect.</source>
          <target state="translated">如果指定的名称不在启用的属性名列表中,本方法没有任何效果。</target>
        </trans-unit>
        <trans-unit id="06d84325d01c60c6779f1c995e33cf0b305c715d" translate="yes" xml:space="preserve">
          <source>If the specified native is not a properly encoded native and the mappings for this native have not been altered with &lt;code&gt;setFlavorsForNative&lt;/code&gt;, then the contents of the &lt;code&gt;List&lt;/code&gt; is platform dependent, but &lt;code&gt;null&lt;/code&gt; cannot be returned.</source>
          <target state="translated">如果指定的本机不是经过正确编码的本机，并且尚未使用 &lt;code&gt;setFlavorsForNative&lt;/code&gt; 更改此本机的映射，则 &lt;code&gt;List&lt;/code&gt; 的内容取决于平台，但不能返回 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="25d850bc5c8154fd5a609c44324b0fd903372382" translate="yes" xml:space="preserve">
          <source>If the specified native is previously unknown to the data transfer subsystem, and that native has been properly encoded, then invoking this method will establish a mapping in both directions between the specified native and a &lt;code&gt;DataFlavor&lt;/code&gt; whose MIME type is a decoded version of the native.</source>
          <target state="translated">如果指定的本机以前对于数据传输子系统是未知的，并且该本机已经正确编码，则调用此方法将在指定的本机与MIME类型是本机的解码版本的 &lt;code&gt;DataFlavor&lt;/code&gt; 之间建立双向映射。</target>
        </trans-unit>
        <trans-unit id="92b923f20f66bacef4d2ff1b575298d2082a6d3b" translate="yes" xml:space="preserve">
          <source>If the specified object is an instance of &lt;code&gt;Throwable&lt;/code&gt;, it becomes the</source>
          <target state="translated">如果指定的对象是 &lt;code&gt;Throwable&lt;/code&gt; 的实例，则它将成为</target>
        </trans-unit>
        <trans-unit id="f07c1a027ba244740b1e94181579aafe6b9799f7" translate="yes" xml:space="preserve">
          <source>If the specified prefix is already in the list of enabled notification types, this method has no effect.</source>
          <target state="translated">如果指定的前缀已经在已启用的通知类型列表中,本方法没有任何效果。</target>
        </trans-unit>
        <trans-unit id="35c19bfb0ddf95e53e5300c7d5d437ccd663d657" translate="yes" xml:space="preserve">
          <source>If the specified prefix is not in the list of enabled notification types, this method has no effect.</source>
          <target state="translated">如果指定的前缀不在已启用的通知类型列表中,则本方法没有效果。</target>
        </trans-unit>
        <trans-unit id="f43c50810daae04d0ace6639274dabc1168944f9" translate="yes" xml:space="preserve">
          <source>If the specified property is not defined for a particular file format, this method returns &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">如果未为特定文件格式定义指定的属性，则此方法返回 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0dde80edd4786d58af9002dd456373854e678d38" translate="yes" xml:space="preserve">
          <source>If the specified property is not found or cannot be parsed as an integer then the &lt;code&gt;Color&lt;/code&gt; specified by the second argument is returned instead.</source>
          <target state="translated">如果找不到指定的属性或无法将其解析为整数，则将返回第二个参数指定的 &lt;code&gt;Color&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bdabf1d6b2382f70866806891245d3b01a4f4527" translate="yes" xml:space="preserve">
          <source>If the specified property is not found or could not be parsed as an integer then &lt;code&gt;null&lt;/code&gt; is returned.</source>
          <target state="translated">如果找不到指定的属性或无法将其解析为整数，则返回 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3d802140ffd78fd804cf7b1fd2b7295c7e5afc88" translate="yes" xml:space="preserve">
          <source>If the specified property is not found or could not be parsed as an integer then the integer value &lt;code&gt;v&lt;/code&gt; is used instead, and is converted to a &lt;code&gt;Color&lt;/code&gt; object.</source>
          <target state="translated">如果找不到指定属性或无法将其解析为整数，则使用整数值 &lt;code&gt;v&lt;/code&gt; 并将其转换为 &lt;code&gt;Color&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="c4834c64d62740309c88f771524fdcb223e3fc7b" translate="yes" xml:space="preserve">
          <source>If the specified range of text does not fit into a &lt;code&gt;DOMString&lt;/code&gt;.</source>
          <target state="translated">如果指定的文本范围不适合 &lt;code&gt;DOMString&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="caa74ec04f197f8793bb6217e9a34e0badeccd71" translate="yes" xml:space="preserve">
          <source>If the specified system ID is a relative URI reference (see section 5 in [&lt;a href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;IETF RFC 2396&lt;/a&gt;]), the DOM implementation will attempt to resolve the relative URI with the &lt;code&gt;baseURI&lt;/code&gt; as the base, if that fails, the behavior is implementation dependent.</source>
          <target state="translated">如果指定的系统ID是相对URI引用（请参见[ &lt;a href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;IETF RFC 2396&lt;/a&gt; ]中的第5节），则DOM实现将尝试以 &lt;code&gt;baseURI&lt;/code&gt; 为基础来解析相对URI ，如果失败，则行为取决于实现。</target>
        </trans-unit>
        <trans-unit id="ccebe2f1442b09ad81733fcfdb75c424f50597a4" translate="yes" xml:space="preserve">
          <source>If the specified system ID is a relative URI reference (see section 5 in [&lt;a href=&quot;https://www.ietf.org/rfc/rfc2396.txt&quot;&gt;IETF RFC 2396&lt;/a&gt;]), the DOM implementation will attempt to resolve the relative URI with the &lt;code&gt;baseURI&lt;/code&gt; as the base, if that fails, the behavior is implementation dependent.</source>
          <target state="translated">如果指定的系统ID是相对URI引用（请参见[ &lt;a href=&quot;https://www.ietf.org/rfc/rfc2396.txt&quot;&gt;IETF RFC 2396&lt;/a&gt; ]中的第5节），则DOM实现将尝试以 &lt;code&gt;baseURI&lt;/code&gt; 为基础来解析相对URI ，如果失败，则行为取决于实现。</target>
        </trans-unit>
        <trans-unit id="1954d35e1a8126307e2b4392ca7004d2cfa54884" translate="yes" xml:space="preserve">
          <source>If the specified waiting time elapses then &lt;a href=&quot;timeoutexception&quot;&gt;&lt;code&gt;TimeoutException&lt;/code&gt;&lt;/a&gt; is thrown. If the time is less than or equal to zero, the method will not wait at all.</source>
          <target state="translated">如果经过了指定的等待时间，则抛出&lt;a href=&quot;timeoutexception&quot;&gt; &lt;code&gt;TimeoutException&lt;/code&gt; &lt;/a&gt;。如果时间小于或等于零，则该方法将根本不等待。</target>
        </trans-unit>
        <trans-unit id="310c63f9de70d34cca02c16171cb0b3c368911f0" translate="yes" xml:space="preserve">
          <source>If the specified waiting time elapses then the value &lt;code&gt;false&lt;/code&gt; is returned. If the time is less than or equal to zero, the method will not wait at all.</source>
          <target state="translated">如果经过了指定的等待时间，则返回值 &lt;code&gt;false&lt;/code&gt; 。如果时间小于或等于零，则该方法将根本不等待。</target>
        </trans-unit>
        <trans-unit id="9bdd6bad6b7c4c04adc8addbdd6baac39622961b" translate="yes" xml:space="preserve">
          <source>If the specified waiting time elapses then the value &lt;code&gt;false&lt;/code&gt; is returned. If the time is less than or equal to zero, the method will not wait at all. Any permits that were to be assigned to this thread, are instead assigned to other threads trying to acquire permits, as if the permits had been made available by a call to &lt;a href=&quot;#release()&quot;&gt;&lt;code&gt;release()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果经过了指定的等待时间，则返回值 &lt;code&gt;false&lt;/code&gt; 。如果时间小于或等于零，则该方法将根本不等待。相反，将要分配给该线程的所有许可，而是分配给其他尝试获取许可的线程，就好像通过调用&lt;a href=&quot;#release()&quot;&gt; &lt;code&gt;release()&lt;/code&gt; &lt;/a&gt;使许可可用。</target>
        </trans-unit>
        <trans-unit id="229ff9ac1c41d305f35a7c0608935889e0aaec6b" translate="yes" xml:space="preserve">
          <source>If the specified waiting time elapses then the value &lt;code&gt;false&lt;/code&gt; is returned. If the time is less than or equal to zero, the method will not wait at all. Any permits that were to be assigned to this thread, are instead assigned to other threads trying to acquire permits, as if the permits had been made available by a call to &lt;a href=&quot;semaphore#release--&quot;&gt;&lt;code&gt;release()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果经过了指定的等待时间，则返回值 &lt;code&gt;false&lt;/code&gt; 。如果时间小于或等于零，则该方法将根本不等待。相反，将要分配给该线程的所有许可，都分配给其他尝试获取许可的线程，就好像通过调用&lt;a href=&quot;semaphore#release--&quot;&gt; &lt;code&gt;release()&lt;/code&gt; &lt;/a&gt;使许可可用。</target>
        </trans-unit>
        <trans-unit id="6e9384353fa1c2365434f6e7663568dfb603f1c6" translate="yes" xml:space="preserve">
          <source>If the specified waiting time is zero or negative, the method does nothing. Otherwise, if the permit is available then it is consumed and the call returns immediately; otherwise the current thread becomes disabled for thread scheduling purposes and lies dormant until one of four things happens:</source>
          <target state="translated">如果指定的等待时间为零或负值,则该方法不做任何事情。否则,如果许可是可用的,那么它就会被消耗掉,并立即返回调用;否则当前线程就会为了线程调度的目的而被禁用,并处于休眠状态,直到四种情况之一发生。</target>
        </trans-unit>
        <trans-unit id="6d2fa8250cbec1b974164fdd92ff3bc201feb96b" translate="yes" xml:space="preserve">
          <source>If the stack trace of this &lt;code&gt;Throwable&lt;/code&gt;&lt;a href=&quot;#%3Cinit%3E(java.lang.String,java.lang.Throwable,boolean,boolean)&quot;&gt;is not writable&lt;/a&gt;, calling this method has no effect other than validating its argument.</source>
          <target state="translated">如果此 &lt;code&gt;Throwable&lt;/code&gt; 的堆栈跟踪&lt;a href=&quot;#%3Cinit%3E(java.lang.String,java.lang.Throwable,boolean,boolean)&quot;&gt;是不可写的&lt;/a&gt;，则调用此方法除了验证其参数外没有其他作用。</target>
        </trans-unit>
        <trans-unit id="6d793547d8065207a7a2a3b64f74bfbae2f70956" translate="yes" xml:space="preserve">
          <source>If the stack trace of this &lt;code&gt;Throwable&lt;/code&gt;&lt;a href=&quot;#%3Cinit%3E(java.lang.String,java.lang.Throwable,boolean,boolean)&quot;&gt;is not writable&lt;/a&gt;, calling this method has no effect.</source>
          <target state="translated">如果此 &lt;code&gt;Throwable&lt;/code&gt; 的堆栈跟踪&lt;a href=&quot;#%3Cinit%3E(java.lang.String,java.lang.Throwable,boolean,boolean)&quot;&gt;不可写&lt;/a&gt;，则调用此方法无效。</target>
        </trans-unit>
        <trans-unit id="3dda73785392b01747ad72630377e93ff7ebd123" translate="yes" xml:space="preserve">
          <source>If the stack trace of this &lt;code&gt;Throwable&lt;/code&gt;&lt;a href=&quot;throwable#Throwable-java.lang.String-java.lang.Throwable-boolean-boolean-&quot;&gt;is not writable&lt;/a&gt;, calling this method has no effect other than validating its argument.</source>
          <target state="translated">如果此 &lt;code&gt;Throwable&lt;/code&gt; 的堆栈跟踪&lt;a href=&quot;throwable#Throwable-java.lang.String-java.lang.Throwable-boolean-boolean-&quot;&gt;是不可写的&lt;/a&gt;，则调用此方法除了验证其参数外没有其他作用。</target>
        </trans-unit>
        <trans-unit id="f140d470f07fad292b66fc6ee306ae6d2a54ab2a" translate="yes" xml:space="preserve">
          <source>If the stack trace of this &lt;code&gt;Throwable&lt;/code&gt;&lt;a href=&quot;throwable#Throwable-java.lang.String-java.lang.Throwable-boolean-boolean-&quot;&gt;is not writable&lt;/a&gt;, calling this method has no effect.</source>
          <target state="translated">如果此 &lt;code&gt;Throwable&lt;/code&gt; 的堆栈跟踪&lt;a href=&quot;throwable#Throwable-java.lang.String-java.lang.Throwable-boolean-boolean-&quot;&gt;不是可写的&lt;/a&gt;，则调用此方法无效。</target>
        </trans-unit>
        <trans-unit id="4a0c7fbb44b44d8e097852c8b27b45e37f7b8b9c" translate="yes" xml:space="preserve">
          <source>If the standard error of the process has been redirected using &lt;a href=&quot;processbuilder#redirectError(java.lang.ProcessBuilder.Redirect)&quot;&gt;&lt;code&gt;ProcessBuilder.redirectError&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;processbuilder#redirectErrorStream(boolean)&quot;&gt;&lt;code&gt;ProcessBuilder.redirectErrorStream&lt;/code&gt;&lt;/a&gt; then this method will return a &lt;a href=&quot;processbuilder#redirect-output&quot;&gt;null input stream&lt;/a&gt;.</source>
          <target state="translated">如果已使用&lt;a href=&quot;processbuilder#redirectError(java.lang.ProcessBuilder.Redirect)&quot;&gt; &lt;code&gt;ProcessBuilder.redirectError&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;processbuilder#redirectErrorStream(boolean)&quot;&gt; &lt;code&gt;ProcessBuilder.redirectErrorStream&lt;/code&gt; &lt;/a&gt;重定向了流程的标准错误，则此方法将返回&lt;a href=&quot;processbuilder#redirect-output&quot;&gt;空输入流&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="077ba9a63c85f3c79b6472adbd6bd273ed829948" translate="yes" xml:space="preserve">
          <source>If the standard error of the subprocess has been redirected using &lt;a href=&quot;processbuilder#redirectError-java.lang.ProcessBuilder.Redirect-&quot;&gt;&lt;code&gt;ProcessBuilder.redirectError&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;processbuilder#redirectErrorStream-boolean-&quot;&gt;&lt;code&gt;ProcessBuilder.redirectErrorStream&lt;/code&gt;&lt;/a&gt; then this method will return a &lt;a href=&quot;processbuilder#redirect-output&quot;&gt;null input stream&lt;/a&gt;.</source>
          <target state="translated">如果已使用&lt;a href=&quot;processbuilder#redirectError-java.lang.ProcessBuilder.Redirect-&quot;&gt; &lt;code&gt;ProcessBuilder.redirectError&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;processbuilder#redirectErrorStream-boolean-&quot;&gt; &lt;code&gt;ProcessBuilder.redirectErrorStream&lt;/code&gt; &lt;/a&gt;重定向了子流程的标准错误，则此方法将返回&lt;a href=&quot;processbuilder#redirect-output&quot;&gt;空输入流&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="68b1b68d307d6ca1fc6a760c2ae878282f015b92" translate="yes" xml:space="preserve">
          <source>If the standard input of the process has been redirected using &lt;a href=&quot;processbuilder#redirectInput(java.lang.ProcessBuilder.Redirect)&quot;&gt;&lt;code&gt;ProcessBuilder.redirectInput&lt;/code&gt;&lt;/a&gt; then this method will return a &lt;a href=&quot;processbuilder#redirect-input&quot;&gt;null output stream&lt;/a&gt;.</source>
          <target state="translated">如果已使用&lt;a href=&quot;processbuilder#redirectInput(java.lang.ProcessBuilder.Redirect)&quot;&gt; &lt;code&gt;ProcessBuilder.redirectInput&lt;/code&gt; &lt;/a&gt;重定向了流程的标准输入，则此方法将返回&lt;a href=&quot;processbuilder#redirect-input&quot;&gt;空输出流&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="86430b03fbc71403519b5c3b7220021c3f6618a7" translate="yes" xml:space="preserve">
          <source>If the standard input of the subprocess has been redirected using &lt;a href=&quot;processbuilder#redirectInput-java.lang.ProcessBuilder.Redirect-&quot;&gt;&lt;code&gt;ProcessBuilder.redirectInput&lt;/code&gt;&lt;/a&gt; then this method will return a &lt;a href=&quot;processbuilder#redirect-input&quot;&gt;null output stream&lt;/a&gt;.</source>
          <target state="translated">如果已使用&lt;a href=&quot;processbuilder#redirectInput-java.lang.ProcessBuilder.Redirect-&quot;&gt; &lt;code&gt;ProcessBuilder.redirectInput&lt;/code&gt; &lt;/a&gt;重定向了子流程的标准输入，则此方法将返回&lt;a href=&quot;processbuilder#redirect-input&quot;&gt;空输出流&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3193a3f874d9883f06995425c57bb9f49f95c498" translate="yes" xml:space="preserve">
          <source>If the standard output of the process has been redirected using &lt;a href=&quot;processbuilder#redirectOutput(java.lang.ProcessBuilder.Redirect)&quot;&gt;&lt;code&gt;ProcessBuilder.redirectOutput&lt;/code&gt;&lt;/a&gt; then this method will return a &lt;a href=&quot;processbuilder#redirect-output&quot;&gt;null input stream&lt;/a&gt;.</source>
          <target state="translated">如果已使用&lt;a href=&quot;processbuilder#redirectOutput(java.lang.ProcessBuilder.Redirect)&quot;&gt; &lt;code&gt;ProcessBuilder.redirectOutput&lt;/code&gt; &lt;/a&gt;重定向了流程的标准输出，则此方法将返回&lt;a href=&quot;processbuilder#redirect-output&quot;&gt;空输入流&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7075f6432f67c8c99f417e3aed9f9abd4674447d" translate="yes" xml:space="preserve">
          <source>If the standard output of the subprocess has been redirected using &lt;a href=&quot;processbuilder#redirectOutput-java.lang.ProcessBuilder.Redirect-&quot;&gt;&lt;code&gt;ProcessBuilder.redirectOutput&lt;/code&gt;&lt;/a&gt; then this method will return a &lt;a href=&quot;processbuilder#redirect-output&quot;&gt;null input stream&lt;/a&gt;.</source>
          <target state="translated">如果已使用&lt;a href=&quot;processbuilder#redirectOutput-java.lang.ProcessBuilder.Redirect-&quot;&gt; &lt;code&gt;ProcessBuilder.redirectOutput&lt;/code&gt; &lt;/a&gt;重定向了子流程的标准输出，则此方法将返回&lt;a href=&quot;processbuilder#redirect-output&quot;&gt;空输入流&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ef7d1e9b0031ea83269d5adfbd99e3c687130e6f" translate="yes" xml:space="preserve">
          <source>If the state of this check box is &lt;code&gt;true&lt;/code&gt; and the new group already has a check box selected, this check box's state is changed to &lt;code&gt;false&lt;/code&gt;. If the state of this check box is &lt;code&gt;true&lt;/code&gt; and the new group has no check box selected, this check box becomes the selected checkbox for the new group and its state is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">如果此复选框的状态为 &lt;code&gt;true&lt;/code&gt; ，并且新组已经选择了一个复选框，则此复选框的状态将更改为 &lt;code&gt;false&lt;/code&gt; 。如果此复选框的状态为 &lt;code&gt;true&lt;/code&gt; ，而新组没有选中复选框，则此复选框将成为新组的选中复选框，并且其状态为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d366f3eb6bf9e4d636eed0b8ad01a318338322f7" translate="yes" xml:space="preserve">
          <source>If the stream argument is &lt;code&gt;true&lt;/code&gt;, this creates a stream socket. If the stream argument is &lt;code&gt;false&lt;/code&gt;, it creates a datagram socket.</source>
          <target state="translated">如果stream参数为 &lt;code&gt;true&lt;/code&gt; ，则创建一个流套接字。如果stream参数为 &lt;code&gt;false&lt;/code&gt; ，它将创建一个数据报套接字。</target>
        </trans-unit>
        <trans-unit id="99da69fcd16c1de3a48462f6d509743df4ef63c3" translate="yes" xml:space="preserve">
          <source>If the stream is already closed, invoking this method has no effect.</source>
          <target state="translated">如果流已经关闭,调用本方法没有任何效果。</target>
        </trans-unit>
        <trans-unit id="3eb34c7e224c2415946e3db9d58aac4984e092ef" translate="yes" xml:space="preserve">
          <source>If the stream is already closed, the action will be performed immediately in the current thread.</source>
          <target state="translated">如果流已经被关闭,该操作将在当前线程中立即执行。</target>
        </trans-unit>
        <trans-unit id="92109724254a6a952d63389232984fc4b39d101f" translate="yes" xml:space="preserve">
          <source>If the stream is parallel, and the &lt;code&gt;Collector&lt;/code&gt; is &lt;a href=&quot;collector.characteristics#CONCURRENT&quot;&gt;&lt;code&gt;concurrent&lt;/code&gt;&lt;/a&gt;, and either the stream is unordered or the collector is &lt;a href=&quot;collector.characteristics#UNORDERED&quot;&gt;&lt;code&gt;unordered&lt;/code&gt;&lt;/a&gt;, then a concurrent reduction will be performed (see &lt;a href=&quot;collector&quot;&gt;&lt;code&gt;Collector&lt;/code&gt;&lt;/a&gt; for details on concurrent reduction.)</source>
          <target state="translated">如果流是并行的，并且 &lt;code&gt;Collector&lt;/code&gt; 是&lt;a href=&quot;collector.characteristics#CONCURRENT&quot;&gt; &lt;code&gt;concurrent&lt;/code&gt; &lt;/a&gt;，或者该流是无序的，或者该收集器是&lt;a href=&quot;collector.characteristics#UNORDERED&quot;&gt; &lt;code&gt;unordered&lt;/code&gt; &lt;/a&gt;，那么将执行并发缩减（有关并发缩减的详细信息，请参见&lt;a href=&quot;collector&quot;&gt; &lt;code&gt;Collector&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="f3975bae6f8df00f0d259552436dae709c82b9db" translate="yes" xml:space="preserve">
          <source>If the style sheet is a linked style sheet, the value of its attribute is its location.</source>
          <target state="translated">如果样式表是一个链接的样式表,它的属性值就是它的位置。</target>
        </trans-unit>
        <trans-unit id="e8936505a02a28236a091f15ae37b5daf1c18699" translate="yes" xml:space="preserve">
          <source>If the style sheet is a linked style sheet, the value of its attribute is its location. For inline style sheets, the value of this attribute is &lt;code&gt;null&lt;/code&gt;. See the href attribute definition for the &lt;code&gt;LINK&lt;/code&gt; element in HTML 4.0, and the href pseudo-attribute for the XML style sheet processing instruction.</source>
          <target state="translated">如果样式表是链接的样式表，则其属性的值是其位置。对于内联样式表，此属性的值为 &lt;code&gt;null&lt;/code&gt; 。请参阅HTML 4.0中 &lt;code&gt;LINK&lt;/code&gt; 元素的href属性定义，以及XML样式表处理指令的href伪属性。</target>
        </trans-unit>
        <trans-unit id="649cf82f464f662aa965403c73cf99d556fea581" translate="yes" xml:space="preserve">
          <source>If the subprocess has already terminated then this method returns immediately with the value &lt;code&gt;true&lt;/code&gt;. If the process has not terminated and the timeout value is less than, or equal to, zero, then this method returns immediately with the value &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果子进程已经终止，则此方法立即返回 &lt;code&gt;true&lt;/code&gt; 值。如果进程尚未终止，并且超时值小于或等于零，则此方法将立即返回 &lt;code&gt;false&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="eadbeed59697fe559cad7872f812e28abf5d75a2" translate="yes" xml:space="preserve">
          <source>If the superclass is a parameterized type, the &lt;code&gt;Type&lt;/code&gt; object returned must accurately reflect the actual type arguments used in the source code. The parameterized type representing the superclass is created if it had not been created before. See the declaration of &lt;a href=&quot;reflect/parameterizedtype&quot;&gt;&lt;code&gt;ParameterizedType&lt;/code&gt;&lt;/a&gt; for the semantics of the creation process for parameterized types. If this &lt;code&gt;Class&lt;/code&gt; object represents either the &lt;code&gt;Object&lt;/code&gt; class, an interface, a primitive type, or void, then null is returned. If this &lt;code&gt;Class&lt;/code&gt; object represents an array class then the &lt;code&gt;Class&lt;/code&gt; object representing the &lt;code&gt;Object&lt;/code&gt; class is returned.</source>
          <target state="translated">如果超类是参数化类型，则返回的 &lt;code&gt;Type&lt;/code&gt; 对象必须准确反映源代码中使用的实际类型参数。如果以前没有创建过代表超级类的参数化类型，则会创建该参数化类型。有关参数化类型的创建过程的语义，请参见&lt;a href=&quot;reflect/parameterizedtype&quot;&gt; &lt;code&gt;ParameterizedType&lt;/code&gt; &lt;/a&gt;的声明。如果此 &lt;code&gt;Class&lt;/code&gt; 对象表示 &lt;code&gt;Object&lt;/code&gt; 类，接口，原始类型或void，则返回null。如果此 &lt;code&gt;Class&lt;/code&gt; 对象表示数组类，则返回代表 &lt;code&gt;Object&lt;/code&gt; 类的 &lt;code&gt;Class&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="1b0a8ba1234c9978531ae814a7cbb1dae0a3c230" translate="yes" xml:space="preserve">
          <source>If the superclass is a parameterized type, the &lt;code&gt;Type&lt;/code&gt; object returned must accurately reflect the actual type parameters used in the source code. The parameterized type representing the superclass is created if it had not been created before. See the declaration of &lt;a href=&quot;reflect/parameterizedtype&quot;&gt;&lt;code&gt;ParameterizedType&lt;/code&gt;&lt;/a&gt; for the semantics of the creation process for parameterized types. If this &lt;code&gt;Class&lt;/code&gt; represents either the &lt;code&gt;Object&lt;/code&gt; class, an interface, a primitive type, or void, then null is returned. If this object represents an array class then the &lt;code&gt;Class&lt;/code&gt; object representing the &lt;code&gt;Object&lt;/code&gt; class is returned.</source>
          <target state="translated">如果超类是参数化类型，则返回的 &lt;code&gt;Type&lt;/code&gt; 对象必须准确反映源代码中使用的实际类型参数。如果以前没有创建过代表超级类的参数化类型，则会创建该参数化类型。有关参数化类型的创建过程的语义，请参见&lt;a href=&quot;reflect/parameterizedtype&quot;&gt; &lt;code&gt;ParameterizedType&lt;/code&gt; &lt;/a&gt;的声明。如果该 &lt;code&gt;Class&lt;/code&gt; 表示 &lt;code&gt;Object&lt;/code&gt; 类，接口，原始类型或void，则返回null。如果此对象表示数组类，则返回表示 &lt;code&gt;Object&lt;/code&gt; 类的 &lt;code&gt;Class&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="702061aae71a7b0bc29035519b62837f0bf9ee3d" translate="yes" xml:space="preserve">
          <source>If the supplied &lt;code&gt;ImageReadParam&lt;/code&gt; contains optional setting values not supported by this reader (</source>
          <target state="translated">如果提供的 &lt;code&gt;ImageReadParam&lt;/code&gt; 包含此阅读器不支持的可选设置值（</target>
        </trans-unit>
        <trans-unit id="a6062faf5608aab9b4601cbc2c84f0f96e088fa9" translate="yes" xml:space="preserve">
          <source>If the supplied &lt;code&gt;ImageWriteParam&lt;/code&gt; contains optional setting values not supported by this writer (</source>
          <target state="translated">如果提供的 &lt;code&gt;ImageWriteParam&lt;/code&gt; 包含此编写器不支持的可选设置值（</target>
        </trans-unit>
        <trans-unit id="e0ec08c9bcf3ded436efba803a4101d1da6386d3" translate="yes" xml:space="preserve">
          <source>If the supplied &lt;code&gt;ImageWriteParam&lt;/code&gt; contains optional setting values not understood by this writer or transcoder, they will be ignored.</source>
          <target state="translated">如果提供的 &lt;code&gt;ImageWriteParam&lt;/code&gt; 包含此编写器或代码转换器无法理解的可选设置值，则将忽略它们。</target>
        </trans-unit>
        <trans-unit id="83332eaf39cb8bfd82ea83337e6eefff71ef19fb" translate="yes" xml:space="preserve">
          <source>If the support for extended mouse buttons is &lt;a href=&quot;toolkit#areExtraMouseButtonsEnabled()&quot;&gt;&lt;code&gt;disabled&lt;/code&gt;&lt;/a&gt; by Java then it is allowed to use only the following standard button masks: &lt;code&gt;InputEvent.BUTTON1_DOWN_MASK&lt;/code&gt;, &lt;code&gt;InputEvent.BUTTON2_DOWN_MASK&lt;/code&gt;, &lt;code&gt;InputEvent.BUTTON3_DOWN_MASK&lt;/code&gt;.</source>
          <target state="translated">如果Java&lt;a href=&quot;toolkit#areExtraMouseButtonsEnabled()&quot;&gt; &lt;code&gt;disabled&lt;/code&gt; &lt;/a&gt;了对扩展鼠标按钮的支持，则只允许使用以下标准按钮掩码： &lt;code&gt;InputEvent.BUTTON1_DOWN_MASK&lt;/code&gt; ， &lt;code&gt;InputEvent.BUTTON2_DOWN_MASK&lt;/code&gt; ， &lt;code&gt;InputEvent.BUTTON3_DOWN_MASK&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="96b9d55f1b2271749505c66ce5e0fd46a6ed130f" translate="yes" xml:space="preserve">
          <source>If the support for extended mouse buttons is &lt;a href=&quot;toolkit#areExtraMouseButtonsEnabled()&quot;&gt;&lt;code&gt;enabled&lt;/code&gt;&lt;/a&gt; by Java then it is allowed to use the standard button masks and masks for existing extended mouse buttons, if the mouse has more then three buttons. In that way, it is allowed to use the button masks corresponding to the buttons in the range from 1 to &lt;a href=&quot;mouseinfo#getNumberOfButtons()&quot;&gt;&lt;code&gt;MouseInfo.getNumberOfButtons()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果Java&lt;a href=&quot;toolkit#areExtraMouseButtonsEnabled()&quot;&gt; &lt;code&gt;enabled&lt;/code&gt; &lt;/a&gt;了对扩展鼠标按钮的支持，则允许使用标准按钮掩码和现有扩展鼠标按钮的掩码（如果鼠标具有三个以上的按钮）。这样，允许使用与按钮相对应的按钮掩码，范围从1到&lt;a href=&quot;mouseinfo#getNumberOfButtons()&quot;&gt; &lt;code&gt;MouseInfo.getNumberOfButtons()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4c7431ea9b95b75172bde5cfc89a8c0841e0ed59" translate="yes" xml:space="preserve">
          <source>If the system ID is a URL, it will be fully resolved.</source>
          <target state="translated">如果系统ID是一个URL,则会被完全解析。</target>
        </trans-unit>
        <trans-unit id="7b5818c71edba95dbdcbbbe03f31b7344a7f8756" translate="yes" xml:space="preserve">
          <source>If the system ID is a relative URI reference (see section 5 in [&lt;a href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;IETF RFC 2396&lt;/a&gt;]), the behavior is implementation dependent.</source>
          <target state="translated">如果系统ID是相对URI引用（请参见[ &lt;a href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;IETF RFC 2396&lt;/a&gt; ]中的第5节），则行为取决于实现。</target>
        </trans-unit>
        <trans-unit id="331d34dbe48eb64c17b2f5bc6cd336e62af8577b" translate="yes" xml:space="preserve">
          <source>If the system ID is a relative URI reference (see section 5 in [&lt;a href=&quot;https://www.ietf.org/rfc/rfc2396.txt&quot;&gt;IETF RFC 2396&lt;/a&gt;]), the behavior is implementation dependent.</source>
          <target state="translated">如果系统ID是相对URI引用（请参见[ &lt;a href=&quot;https://www.ietf.org/rfc/rfc2396.txt&quot;&gt;IETF RFC 2396&lt;/a&gt; ]中的第5节），则行为取决于实现。</target>
        </trans-unit>
        <trans-unit id="11c8152472d911028fe75c0272d12bdc08e6d5e4" translate="yes" xml:space="preserve">
          <source>If the system does not support environment variables, an empty map is returned.</source>
          <target state="translated">如果系统不支持环境变量,则返回一个空映射。</target>
        </trans-unit>
        <trans-unit id="06f52e1b071eac0948a9acca87880e3e4138c05f" translate="yes" xml:space="preserve">
          <source>If the system identifier is a URL, it must be fully resolved (it may not be a relative URL).</source>
          <target state="translated">如果系统标识符是一个URL,它必须是完全解析的(它可能不是一个相对的URL)。</target>
        </trans-unit>
        <trans-unit id="702582a6612c4020970698031381ca0b9cdc6250" translate="yes" xml:space="preserve">
          <source>If the system identifier is a URL, it must be fully resolved by the application before it is passed to the parser.</source>
          <target state="translated">如果系统标识符是一个URL,那么它必须在被传递给解析器之前被应用程序完全解析。</target>
        </trans-unit>
        <trans-unit id="e1141b9ff132e9f64996b3e44968c6f92596158e" translate="yes" xml:space="preserve">
          <source>If the system identifier is a URL, it will have been resolved fully.</source>
          <target state="translated">如果系统标识符是一个URL,它将已经被完全解析。</target>
        </trans-unit>
        <trans-unit id="69c62c9017d4450e514b7c2160989710e82b3ed0" translate="yes" xml:space="preserve">
          <source>If the system identifier is a URL, the SAX parser must resolve it fully before reporting it to the application.</source>
          <target state="translated">如果系统标识符是一个URL,SAX解析器必须在向应用程序报告之前完全解析它。</target>
        </trans-unit>
        <trans-unit id="84493bb7e50a00814aa34c277d5716aea3301f50" translate="yes" xml:space="preserve">
          <source>If the system identifier is a URL, the parser must resolve it fully before passing it to the application.</source>
          <target state="translated">如果系统标识符是一个URL,解析器必须在将其传递给应用程序之前将其完全解析。</target>
        </trans-unit>
        <trans-unit id="63e187f8aea2b4eaa14f670a85e3ec3f6d417906" translate="yes" xml:space="preserve">
          <source>If the system identifier is a URL, the parser must resolve it fully before passing it to the application. For example, a file name must always be provided as a &lt;em&gt;file:...&lt;/em&gt; URL, and other kinds of relative URI are also resolved against their bases.</source>
          <target state="translated">如果系统标识符是URL，则解析器必须将其完全解析，然后再将其传递给应用程序。例如，必须始终将文件名提供为&lt;em&gt;文件：...&lt;/em&gt; URL，并且其他种类的相对URI也会根据其基础进行解析。</target>
        </trans-unit>
        <trans-unit id="1d4775f63756839b1ddacbd6914b05abbe4f7038" translate="yes" xml:space="preserve">
          <source>If the system property &quot;&lt;code&gt;&lt;span id=&quot;java.system.class.loader&quot;&gt;java.system.class.loader&lt;/span&gt;&lt;/code&gt;&quot; is defined when this method is first invoked then the value of that property is taken to be the name of a class that will be returned as the system class loader. The class is loaded using the default system class loader and must define a public constructor that takes a single parameter of type &lt;code&gt;ClassLoader&lt;/code&gt; which is used as the delegation parent. An instance is then created using this constructor with the default system class loader as the parameter. The resulting class loader is defined to be the system class loader. During construction, the class loader should take great care to avoid calling &lt;code&gt;getSystemClassLoader()&lt;/code&gt;. If circular initialization of the system class loader is detected then an &lt;code&gt;IllegalStateException&lt;/code&gt; is thrown.</source>
          <target state="translated">如果在首次调用此方法时定义了系统属性&amp;ldquo; &lt;code&gt;&lt;span id=&quot;java.system.class.loader&quot;&gt;java.system.class.loader&lt;/span&gt;&lt;/code&gt; &amp;rdquo;，则该属性的值将作为要作为系统类加载器返回的类的名称。该类使用默认的系统类加载器加载，并且必须定义一个公共构造函数，该构造函数采用单个类型为 &lt;code&gt;ClassLoader&lt;/code&gt; 的参数作为委托父级。然后使用此构造函数创建一个实例，并使用默认系统类加载器作为参数。结果类加载器定义为系统类加载器。在构建过程中，类加载器应格外小心，以避免调用 &lt;code&gt;getSystemClassLoader()&lt;/code&gt; 。如果检测到系统类加载器的循环初始化，则 &lt;code&gt;IllegalStateException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="98fa5298bfbc9c3dc738e30b2cfbc794eda77505" translate="yes" xml:space="preserve">
          <source>If the system property &quot;&lt;code&gt;java.system.class.loader&lt;/code&gt;&quot; is defined when this method is first invoked then the value of that property is taken to be the name of a class that will be returned as the system class loader. The class is loaded using the default system class loader and must define a public constructor that takes a single parameter of type &lt;code&gt;ClassLoader&lt;/code&gt; which is used as the delegation parent. An instance is then created using this constructor with the default system class loader as the parameter. The resulting class loader is defined to be the system class loader.</source>
          <target state="translated">如果在首次调用此方法时定义了系统属性&amp;ldquo; &lt;code&gt;java.system.class.loader&lt;/code&gt; &amp;rdquo;，则该属性的值将作为要作为系统类加载器返回的类的名称。该类使用默认的系统类加载器加载，并且必须定义一个公共构造函数，该构造函数采用单个类型为 &lt;code&gt;ClassLoader&lt;/code&gt; 的参数作为委托父级。然后使用此构造函数创建一个实例，并使用默认系统类加载器作为参数。结果类加载器定义为系统类加载器。</target>
        </trans-unit>
        <trans-unit id="72daeec5943fe704e6b6f79f778edda5bb93a7be" translate="yes" xml:space="preserve">
          <source>If the system property &quot;&lt;code&gt;java.system.class.loader&lt;/code&gt;&quot; is defined when this method is first invoked then the value of that property is taken to be the name of a class that will be returned as the system class loader. The class is loaded using the default system class loader and must define a public constructor that takes a single parameter of type &lt;code&gt;ClassLoader&lt;/code&gt; which is used as the delegation parent. An instance is then created using this constructor with the default system class loader as the parameter. The resulting class loader is defined to be the system class loader. During construction, the class loader should take great care to avoid calling &lt;code&gt;getSystemClassLoader()&lt;/code&gt;. If circular initialization of the system class loader is detected then an &lt;code&gt;IllegalStateException&lt;/code&gt; is thrown.</source>
          <target state="translated">如果在首次调用此方法时定义了系统属性&amp;ldquo; &lt;code&gt;java.system.class.loader&lt;/code&gt; &amp;rdquo;，则该属性的值将作为要作为系统类加载器返回的类的名称。该类使用默认的系统类加载器加载，并且必须定义一个公共构造函数，该构造函数采用单个类型为 &lt;code&gt;ClassLoader&lt;/code&gt; 的参数作为委托父级。然后使用此构造函数创建一个实例，并使用默认系统类加载器作为参数。结果类加载器定义为系统类加载器。在构建过程中，类加载器应格外小心，以避免调用 &lt;code&gt;getSystemClassLoader()&lt;/code&gt; 。如果检测到系统类加载器的循环初始化，则 &lt;code&gt;IllegalStateException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b99d8bdd490b40a5b7b3869d55b18d0b463d68ae" translate="yes" xml:space="preserve">
          <source>If the system property &lt;a href=&quot;#DEFAULT_PROPERTY_NAME&quot;&gt;&lt;code&gt;DEFAULT_PROPERTY_NAME&lt;/code&gt;&lt;/a&gt; + &quot;:uri&quot; is present, where uri is the parameter to this method, then its value is read as a class name. The method will try to create a new instance of this class by using the class loader, and returns it if it is successfully created.</source>
          <target state="translated">如果存在系统属性&lt;a href=&quot;#DEFAULT_PROPERTY_NAME&quot;&gt; &lt;code&gt;DEFAULT_PROPERTY_NAME&lt;/code&gt; &lt;/a&gt; +&amp;ldquo;：uri&amp;rdquo;，其中uri是此方法的参数，则将其值读取为类名。该方法将尝试使用类加载器创建此类的新实例，并在成功创建后将其返回。</target>
        </trans-unit>
        <trans-unit id="07bb24fbcfd01038cb271accdc3621d725d60279" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;&quot;javax.xml.validation.SchemaFactory:&amp;lt;i&amp;gt;schemaLanguage&amp;lt;/i&amp;gt;&quot;&lt;/code&gt; is present (where</source>
          <target state="translated">如果存在系统属性 &lt;code&gt;&quot;javax.xml.validation.SchemaFactory:&amp;lt;i&amp;gt;schemaLanguage&amp;lt;/i&amp;gt;&quot;&lt;/code&gt; （其中</target>
        </trans-unit>
        <trans-unit id="7f7a9a303f9cb45f840f5c2ab595c9253722c6a7" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;&lt;span id=&quot;com.sun.net.httpserver.HttpServerProvider&quot;&gt;com.sun.net.httpserver.HttpServerProvider&lt;/span&gt;&lt;/code&gt; is defined then it is taken to be the fully-qualified name of a concrete provider class. The class is loaded and instantiated; if this process fails then an unspecified unchecked error or exception is thrown.</source>
          <target state="translated">如果定义了系统属性 &lt;code&gt;&lt;span id=&quot;com.sun.net.httpserver.HttpServerProvider&quot;&gt;com.sun.net.httpserver.HttpServerProvider&lt;/span&gt;&lt;/code&gt; ，则将其视为特定提供程序类的标准名称。该类已加载并实例化；如果此过程失败，则会引发未指定的未经检查的错误或异常。</target>
        </trans-unit>
        <trans-unit id="84e51147b8722cac897d95fae276f73bfae5bacd" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;&lt;span id=&quot;java.nio.channels.spi.AsynchronousChannelProvider&quot;&gt;java.nio.channels.spi.AsynchronousChannelProvider&lt;/span&gt;&lt;/code&gt; is defined then it is taken to be the fully-qualified name of a concrete provider class. The class is loaded and instantiated; if this process fails then an unspecified error is thrown.</source>
          <target state="translated">如果定义了系统属性 &lt;code&gt;&lt;span id=&quot;java.nio.channels.spi.AsynchronousChannelProvider&quot;&gt;java.nio.channels.spi.AsynchronousChannelProvider&lt;/span&gt;&lt;/code&gt; ，则将其视为具体提供程序类的标准名称。该类已加载并实例化；如果此过程失败，则会引发未指定的错误。</target>
        </trans-unit>
        <trans-unit id="ef75bfa5083a390acda97a096494d6c039249d74" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;&lt;span id=&quot;java.nio.channels.spi.SelectorProvider&quot;&gt;java.nio.channels.spi.SelectorProvider&lt;/span&gt;&lt;/code&gt; is defined then it is taken to be the fully-qualified name of a concrete provider class. The class is loaded and instantiated; if this process fails then an unspecified error is thrown.</source>
          <target state="translated">如果定义了系统属性 &lt;code&gt;&lt;span id=&quot;java.nio.channels.spi.SelectorProvider&quot;&gt;java.nio.channels.spi.SelectorProvider&lt;/span&gt;&lt;/code&gt; ，则将其视为特定提供程序类的标准名称。该类已加载并实例化；如果此过程失败，则会引发未指定的错误。</target>
        </trans-unit>
        <trans-unit id="7ae664d66a76b02b3110fa2464812b1011bc5ba9" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;&lt;span id=&quot;java.rmi.server.RMIClassLoaderSpi&quot;&gt;java.rmi.server.RMIClassLoaderSpi&lt;/span&gt;&lt;/code&gt; is defined, then if its value equals the string &lt;code&gt;&quot;default&quot;&lt;/code&gt;, the provider instance will be the value returned by an invocation of the &lt;a href=&quot;#getDefaultProviderInstance()&quot;&gt;&lt;code&gt;getDefaultProviderInstance()&lt;/code&gt;&lt;/a&gt; method, and for any other value, if a class named with the value of the property can be loaded by the system class loader (see &lt;a href=&quot;../../../../java.base/java/lang/classloader#getSystemClassLoader()&quot;&gt;&lt;code&gt;ClassLoader.getSystemClassLoader()&lt;/code&gt;&lt;/a&gt;) and that class is assignable to &lt;a href=&quot;rmiclassloaderspi&quot;&gt;&lt;code&gt;RMIClassLoaderSpi&lt;/code&gt;&lt;/a&gt; and has a public no-argument constructor, then that constructor will be invoked to create the provider instance. If the property is defined but any other of those conditions are not true, then an unspecified &lt;code&gt;Error&lt;/code&gt; will be thrown to code that attempts to use &lt;code&gt;RMIClassLoader&lt;/code&gt;, indicating the failure to obtain a provider instance.</source>
          <target state="translated">如果定义了系统属性 &lt;code&gt;&lt;span id=&quot;java.rmi.server.RMIClassLoaderSpi&quot;&gt;java.rmi.server.RMIClassLoaderSpi&lt;/span&gt;&lt;/code&gt; ，则如果其值等于字符串 &lt;code&gt;&quot;default&quot;&lt;/code&gt; ，则提供程序实例将是通过调用&lt;a href=&quot;#getDefaultProviderInstance()&quot;&gt; &lt;code&gt;getDefaultProviderInstance()&lt;/code&gt; &lt;/a&gt;方法返回的值，对于任何其他值，如果可以使用系统类加载器加载以属性值命名的类（请参见&lt;a href=&quot;../../../../java.base/java/lang/classloader#getSystemClassLoader()&quot;&gt; &lt;code&gt;ClassLoader.getSystemClassLoader()&lt;/code&gt; &lt;/a&gt;），并且该类可分配给&lt;a href=&quot;rmiclassloaderspi&quot;&gt; &lt;code&gt;RMIClassLoaderSpi&lt;/code&gt; &lt;/a&gt;并具有公共无参数构造函数，然后将调用该构造函数来创建提供程序实例。如果定义了属性，但其中任何其他条件都不为真，则将向尝试使用的代码抛出未指定的 &lt;code&gt;Error&lt;/code&gt; &lt;code&gt;RMIClassLoader&lt;/code&gt; ，指示获取提供程序实例失败。</target>
        </trans-unit>
        <trans-unit id="49ac08bfd515249091e7394a6ee49c9a2fed5e70" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;&lt;span id=&quot;java.rmi.server.randomIDs&quot;&gt;java.rmi.server.randomIDs&lt;/span&gt;&lt;/code&gt; is defined to equal the string &lt;code&gt;&quot;true&quot;&lt;/code&gt; (case insensitive), then the &lt;a href=&quot;#%3Cinit%3E()&quot;&gt;&lt;code&gt;ObjID()&lt;/code&gt;&lt;/a&gt; constructor will use a cryptographically strong random number generator to choose the object number of the returned &lt;code&gt;ObjID&lt;/code&gt;.</source>
          <target state="translated">如果将系统属性 &lt;code&gt;&lt;span id=&quot;java.rmi.server.randomIDs&quot;&gt;java.rmi.server.randomIDs&lt;/span&gt;&lt;/code&gt; 定义为等于字符串 &lt;code&gt;&quot;true&quot;&lt;/code&gt; （不区分大小写），则&lt;a href=&quot;#%3Cinit%3E()&quot;&gt; &lt;code&gt;ObjID()&lt;/code&gt; &lt;/a&gt;构造函数将使用加密强度高的随机数生成器来选择返回的 &lt;code&gt;ObjID&lt;/code&gt; 的对象号。</target>
        </trans-unit>
        <trans-unit id="16322c9765cf14a6f819de14a9ca0ba3b1b00413" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;&lt;span id=&quot;javax.rmi.ssl.client.enabledCipherSuites&quot;&gt;javax.rmi.ssl.client.enabledCipherSuites&lt;/span&gt;&lt;/code&gt; is specified, the &lt;a href=&quot;#createSocket(java.lang.String,int)&quot;&gt;&lt;code&gt;createSocket(String,int)&lt;/code&gt;&lt;/a&gt; method will call &lt;a href=&quot;../../../../java.base/javax/net/ssl/sslsocket#setEnabledCipherSuites(java.lang.String%5B%5D)&quot;&gt;&lt;code&gt;SSLSocket.setEnabledCipherSuites(String[])&lt;/code&gt;&lt;/a&gt; before returning the socket. The value of this system property is a string that is a comma-separated list of SSL/TLS cipher suites to enable.</source>
          <target state="translated">如果指定了系统属性 &lt;code&gt;&lt;span id=&quot;javax.rmi.ssl.client.enabledCipherSuites&quot;&gt;javax.rmi.ssl.client.enabledCipherSuites&lt;/span&gt;&lt;/code&gt; ，则&lt;a href=&quot;#createSocket(java.lang.String,int)&quot;&gt; &lt;code&gt;createSocket(String,int)&lt;/code&gt; &lt;/a&gt;方法将在返回套接字之前调用&lt;a href=&quot;../../../../java.base/javax/net/ssl/sslsocket#setEnabledCipherSuites(java.lang.String%5B%5D)&quot;&gt; &lt;code&gt;SSLSocket.setEnabledCipherSuites(String[])&lt;/code&gt; &lt;/a&gt;。此系统属性的值是一个字符串，该字符串是要启用的SSL / TLS密码套件的逗号分隔列表。</target>
        </trans-unit>
        <trans-unit id="596e2084ca2c577ef4c311446714119d3d18b3ee" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;&lt;span id=&quot;javax.rmi.ssl.client.enabledCipherSuites-1&quot;&gt;javax.rmi.ssl.client.enabledCipherSuites&lt;/span&gt;&lt;/code&gt; is specified, this method will call &lt;a href=&quot;../../../../java.base/javax/net/ssl/sslsocket#setEnabledCipherSuites(java.lang.String%5B%5D)&quot;&gt;&lt;code&gt;SSLSocket.setEnabledCipherSuites(String[])&lt;/code&gt;&lt;/a&gt; before returning the socket. The value of this system property is a string that is a comma-separated list of SSL/TLS cipher suites to enable.</source>
          <target state="translated">如果指定了系统属性 &lt;code&gt;&lt;span id=&quot;javax.rmi.ssl.client.enabledCipherSuites-1&quot;&gt;javax.rmi.ssl.client.enabledCipherSuites&lt;/span&gt;&lt;/code&gt; ，则此方法将在返回套接字之前调用&lt;a href=&quot;../../../../java.base/javax/net/ssl/sslsocket#setEnabledCipherSuites(java.lang.String%5B%5D)&quot;&gt; &lt;code&gt;SSLSocket.setEnabledCipherSuites(String[])&lt;/code&gt; &lt;/a&gt;。此系统属性的值是一个字符串，该字符串是要启用的SSL / TLS密码套件的逗号分隔列表。</target>
        </trans-unit>
        <trans-unit id="85e125dd8fdc5133e26429f181bd79c7949497ac" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;&lt;span id=&quot;javax.rmi.ssl.client.enabledProtocols&quot;&gt;javax.rmi.ssl.client.enabledProtocols&lt;/span&gt;&lt;/code&gt; is specified, the &lt;a href=&quot;#createSocket(java.lang.String,int)&quot;&gt;&lt;code&gt;createSocket(String,int)&lt;/code&gt;&lt;/a&gt; method will call &lt;a href=&quot;../../../../java.base/javax/net/ssl/sslsocket#setEnabledProtocols(java.lang.String%5B%5D)&quot;&gt;&lt;code&gt;SSLSocket.setEnabledProtocols(String[])&lt;/code&gt;&lt;/a&gt; before returning the socket. The value of this system property is a string that is a comma-separated list of SSL/TLS protocol versions to enable.</source>
          <target state="translated">如果指定了系统属性 &lt;code&gt;&lt;span id=&quot;javax.rmi.ssl.client.enabledProtocols&quot;&gt;javax.rmi.ssl.client.enabledProtocols&lt;/span&gt;&lt;/code&gt; ，则&lt;a href=&quot;#createSocket(java.lang.String,int)&quot;&gt; &lt;code&gt;createSocket(String,int)&lt;/code&gt; &lt;/a&gt;方法将在返回套接字之前调用&lt;a href=&quot;../../../../java.base/javax/net/ssl/sslsocket#setEnabledProtocols(java.lang.String%5B%5D)&quot;&gt; &lt;code&gt;SSLSocket.setEnabledProtocols(String[])&lt;/code&gt; &lt;/a&gt;。该系统属性的值是一个字符串，该字符串是要启用的SSL / TLS协议版本的逗号分隔列表。</target>
        </trans-unit>
        <trans-unit id="631a5d993700cbd8957a989d51b00a4545052b7d" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;&lt;span id=&quot;javax.rmi.ssl.client.enabledProtocols-1&quot;&gt;javax.rmi.ssl.client.enabledProtocols&lt;/span&gt;&lt;/code&gt; is specified, this method will call &lt;a href=&quot;../../../../java.base/javax/net/ssl/sslsocket#setEnabledProtocols(java.lang.String%5B%5D)&quot;&gt;&lt;code&gt;SSLSocket.setEnabledProtocols(String[])&lt;/code&gt;&lt;/a&gt; before returning the socket. The value of this system property is a string that is a comma-separated list of SSL/TLS protocol versions to enable.</source>
          <target state="translated">如果指定了系统属性 &lt;code&gt;&lt;span id=&quot;javax.rmi.ssl.client.enabledProtocols-1&quot;&gt;javax.rmi.ssl.client.enabledProtocols&lt;/span&gt;&lt;/code&gt; ，则此方法将在返回套接字之前调用&lt;a href=&quot;../../../../java.base/javax/net/ssl/sslsocket#setEnabledProtocols(java.lang.String%5B%5D)&quot;&gt; &lt;code&gt;SSLSocket.setEnabledProtocols(String[])&lt;/code&gt; &lt;/a&gt;。该系统属性的值是一个字符串，该字符串是要启用的SSL / TLS协议版本的逗号分隔列表。</target>
        </trans-unit>
        <trans-unit id="eecf6f38d2140ba1e50010cc6e9645ed8e47e5a9" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;awt.dnd.drag.threshold&lt;/code&gt; is set to a positive integer, this method returns the value of the system property; otherwise if a pertinent desktop property is available and supported by the implementation of the Java platform, this method returns the value of that property; otherwise this method returns some default value. The pertinent desktop property can be queried using &lt;code&gt;java.awt.Toolkit.getDesktopProperty(&quot;DnD.gestureMotionThreshold&quot;)&lt;/code&gt;.</source>
          <target state="translated">如果系统属性 &lt;code&gt;awt.dnd.drag.threshold&lt;/code&gt; 设置为正整数，则此方法将返回系统属性的值；否则，此方法将返回系统属性的值。否则，如果相关的桌面属性可用并且受Java平台的实现支持，则此方法将返回该属性的值；否则，此方法将返回该属性的值。否则，此方法将返回一些默认值。可以使用 &lt;code&gt;java.awt.Toolkit.getDesktopProperty(&quot;DnD.gestureMotionThreshold&quot;)&lt;/code&gt; 来查询相关的桌面属性。</target>
        </trans-unit>
        <trans-unit id="5504ea1f8b0b864e39c0da5d0938dff7d5fce0a6" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;awt.image.incrementaldraw&lt;/code&gt; is missing or has the value &lt;code&gt;true&lt;/code&gt;, the image is incrementally drawn. If the system property has any other value, then the image is not drawn until it has been completely loaded.</source>
          <target state="translated">如果缺少系统属性 &lt;code&gt;awt.image.incrementaldraw&lt;/code&gt; 或值为 &lt;code&gt;true&lt;/code&gt; ，则以增量方式绘制图像。如果系统属性具有任何其他值，则在完全加载图像之前不会绘制图像。</target>
        </trans-unit>
        <trans-unit id="3a82eebeff03c982f8a2c8e7b92fff81f4e06e38" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;java.nio.channels.spi.AsynchronousChannelProvider&lt;/code&gt; is defined then it is taken to be the fully-qualified name of a concrete provider class. The class is loaded and instantiated; if this process fails then an unspecified error is thrown.</source>
          <target state="translated">如果定义了系统属性 &lt;code&gt;java.nio.channels.spi.AsynchronousChannelProvider&lt;/code&gt; ，则将其视为特定提供程序类的标准名称。该类已加载并实例化；如果此过程失败，则会引发未指定的错误。</target>
        </trans-unit>
        <trans-unit id="52c1afd219c316bf40da492c932d1f909b2e0fe8" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;java.nio.channels.spi.SelectorProvider&lt;/code&gt; is defined then it is taken to be the fully-qualified name of a concrete provider class. The class is loaded and instantiated; if this process fails then an unspecified error is thrown.</source>
          <target state="translated">如果定义了系统属性 &lt;code&gt;java.nio.channels.spi.SelectorProvider&lt;/code&gt; ，则将其视为具体提供程序类的标准名称。该类已加载并实例化；如果此过程失败，则会引发未指定的错误。</target>
        </trans-unit>
        <trans-unit id="5093af58ccd31e98a4f37d4eff5d606412ea6ad9" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;java.nio.file.spi.DefaultFileSystemProvider&lt;/code&gt; is defined then it is taken to be a list of one or more fully-qualified names of concrete provider classes identified by the URI scheme &lt;code&gt;&quot;file&quot;&lt;/code&gt;. Where the property is a list of more than one name then the names are separated by a comma. Each class is loaded, using the system class loader, and instantiated by invoking a one argument constructor whose formal parameter type is &lt;code&gt;FileSystemProvider&lt;/code&gt;. The providers are loaded and instantiated in the order they are listed in the property. If this process fails or a provider's scheme is not equal to &lt;code&gt;&quot;file&quot;&lt;/code&gt; then an unspecified error is thrown. URI schemes are normally compared without regard to case but for the default provider, the scheme is required to be &lt;code&gt;&quot;file&quot;&lt;/code&gt;. The first provider class is instantiated by invoking it with a reference to the system-default provider. The second provider class is instantiated by invoking it with a reference to the first provider instance. The third provider class is instantiated by invoking it with a reference to the second instance, and so on. The last provider to be instantiated becomes the default provider; its &lt;code&gt;
 getFileSystem&lt;/code&gt; method is invoked with the URI &lt;code&gt;&quot;file:///&quot;&lt;/code&gt; to get a reference to the default file system.</source>
          <target state="translated">如果定义了系统属性 &lt;code&gt;java.nio.file.spi.DefaultFileSystemProvider&lt;/code&gt; ，则将其视为由URI方案 &lt;code&gt;&quot;file&quot;&lt;/code&gt; 标识的具体提供程序类的一个或多个完全限定名称的列表。如果属性是一个以上名称的列表，则名称之间用逗号分隔。每个类都使用系统类加载器加载，并通过调用一个形式参数类型为 &lt;code&gt;FileSystemProvider&lt;/code&gt; 的单参数构造函数实例化。将按属性中列出的顺序加载和实例化提供程序。如果此过程失败或提供者的方案不等于 &lt;code&gt;&quot;file&quot;&lt;/code&gt; 然后抛出未指定的错误。通常比较URI方案时不考虑大小写，但是对于默认提供程序，要求该方案为 &lt;code&gt;&quot;file&quot;&lt;/code&gt; 。通过引用对系统默认提供程序的引用来实例化第一个提供程序类。通过引用第一个提供程序实例的实例来实例化第二个提供程序类。通过引用第二个实例来调用它来实例化第三个提供程序类，依此类推。要实例化的最后一个提供程序将成为默认提供程序；其URI和 &lt;code&gt;&quot;file:///&quot;&lt;/code&gt; 调用了它的 &lt;code&gt; getFileSystem&lt;/code&gt; 方法，以获取对默认文件系统的引用。</target>
        </trans-unit>
        <trans-unit id="f3d062ab7060d9b3ee095375a8de4d829bd4225b" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;java.nio.file.spi.DefaultFileSystemProvider&lt;/code&gt; is defined then it is taken to be a list of one or more fully-qualified names of concrete provider classes identified by the URI scheme &lt;code&gt;&quot;file&quot;&lt;/code&gt;. Where the property is a list of more than one name then the names are separated by a comma. Each class is loaded, using the system class loader, and instantiated by invoking a one argument constructor whose formal parameter type is &lt;code&gt;FileSystemProvider&lt;/code&gt;. The providers are loaded and instantiated in the order they are listed in the property. If this process fails or a provider's scheme is not equal to &lt;code&gt;&quot;file&quot;&lt;/code&gt; then an unspecified error is thrown. URI schemes are normally compared without regard to case but for the default provider, the scheme is required to be &lt;code&gt;&quot;file&quot;&lt;/code&gt;. The first provider class is instantiated by invoking it with a reference to the system-default provider. The second provider class is instantiated by invoking it with a reference to the first provider instance. The third provider class is instantiated by invoking it with a reference to the second instance, and so on. The last provider to be instantiated becomes the default provider; its &lt;code&gt;getFileSystem&lt;/code&gt; method is invoked with the URI &lt;code&gt;&quot;file:///&quot;&lt;/code&gt; to get a reference to the default file system.</source>
          <target state="translated">如果定义了系统属性 &lt;code&gt;java.nio.file.spi.DefaultFileSystemProvider&lt;/code&gt; ，则将其视为由URI方案 &lt;code&gt;&quot;file&quot;&lt;/code&gt; 标识的具体提供程序类的一个或多个完全限定名称的列表。如果属性是一个以上名称的列表，则名称之间用逗号分隔。每个类都使用系统类加载器加载，并通过调用形式参数类型为 &lt;code&gt;FileSystemProvider&lt;/code&gt; 的一个参数构造函数实例化。将按属性中列出的顺序加载和实例化提供程序。如果此过程失败或提供者的方案不等于 &lt;code&gt;&quot;file&quot;&lt;/code&gt; 然后抛出未指定的错误。通常比较URI方案时不考虑大小写，但是对于默认提供程序，要求该方案为 &lt;code&gt;&quot;file&quot;&lt;/code&gt; 。通过引用对系统默认提供程序的引用来实例化第一个提供程序类。通过引用第一个提供程序实例的实例来实例化第二个提供程序类。通过引用第二个实例来调用它来实例化第三个提供程序类，依此类推。最后一个要实例化的提供程序将成为默认提供程序；它的 &lt;code&gt;getFileSystem&lt;/code&gt; 方法用URI &lt;code&gt;&quot;file:///&quot;&lt;/code&gt; 调用，以获取对默认文件系统的引用。</target>
        </trans-unit>
        <trans-unit id="46b65db3ac8212073211f72ace037edb568ab174" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;java.rmi.server.RMIClassLoaderSpi&lt;/code&gt; is defined, then if its value equals the string &lt;code&gt;&quot;default&quot;&lt;/code&gt;, the provider instance will be the value returned by an invocation of the &lt;a href=&quot;#getDefaultProviderInstance()&quot;&gt;&lt;code&gt;getDefaultProviderInstance()&lt;/code&gt;&lt;/a&gt; method, and for any other value, if a class named with the value of the property can be loaded by the system class loader (see &lt;a href=&quot;../../../../java.base/java/lang/classloader#getSystemClassLoader()&quot;&gt;&lt;code&gt;ClassLoader.getSystemClassLoader()&lt;/code&gt;&lt;/a&gt;) and that class is assignable to &lt;a href=&quot;rmiclassloaderspi&quot;&gt;&lt;code&gt;RMIClassLoaderSpi&lt;/code&gt;&lt;/a&gt; and has a public no-argument constructor, then that constructor will be invoked to create the provider instance. If the property is defined but any other of those conditions are not true, then an unspecified &lt;code&gt;Error&lt;/code&gt; will be thrown to code that attempts to use &lt;code&gt;RMIClassLoader&lt;/code&gt;, indicating the failure to obtain a provider instance.</source>
          <target state="translated">如果定义了系统属性 &lt;code&gt;java.rmi.server.RMIClassLoaderSpi&lt;/code&gt; ，则如果其值等于字符串 &lt;code&gt;&quot;default&quot;&lt;/code&gt; ，则提供程序实例将是通过调用&lt;a href=&quot;#getDefaultProviderInstance()&quot;&gt; &lt;code&gt;getDefaultProviderInstance()&lt;/code&gt; &lt;/a&gt;方法返回的值，对于任何其他值，如果可以使用系统类加载器加载以属性值命名的类（请参见&lt;a href=&quot;../../../../java.base/java/lang/classloader#getSystemClassLoader()&quot;&gt; &lt;code&gt;ClassLoader.getSystemClassLoader()&lt;/code&gt; &lt;/a&gt;），并且该类可分配给&lt;a href=&quot;rmiclassloaderspi&quot;&gt; &lt;code&gt;RMIClassLoaderSpi&lt;/code&gt; &lt;/a&gt;并具有公共无参数构造函数，然后将调用该构造函数来创建提供程序实例。如果定义了属性，但其中任何其他条件都不为真，则将向尝试使用的代码抛出未指定的 &lt;code&gt;Error&lt;/code&gt; &lt;code&gt;RMIClassLoader&lt;/code&gt; ，指示获取提供程序实例失败。</target>
        </trans-unit>
        <trans-unit id="3f46166d5f46be810080dff80c8423bab7a1101a" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;java.rmi.server.randomIDs&lt;/code&gt; is defined to equal the string &lt;code&gt;&quot;true&quot;&lt;/code&gt; (case insensitive), then the &lt;a href=&quot;#%3Cinit%3E()&quot;&gt;&lt;code&gt;ObjID()&lt;/code&gt;&lt;/a&gt; constructor will use a cryptographically strong random number generator to choose the object number of the returned &lt;code&gt;ObjID&lt;/code&gt;.</source>
          <target state="translated">如果将系统属性 &lt;code&gt;java.rmi.server.randomIDs&lt;/code&gt; 定义为等于字符串 &lt;code&gt;&quot;true&quot;&lt;/code&gt; （不区分大小写），则&lt;a href=&quot;#%3Cinit%3E()&quot;&gt; &lt;code&gt;ObjID()&lt;/code&gt; &lt;/a&gt;构造函数将使用加密强度高的随机数生成器来选择返回的 &lt;code&gt;ObjID&lt;/code&gt; 的对象号。</target>
        </trans-unit>
        <trans-unit id="8d2fee9a69da418ea608c03885c80bf1ca4b886c" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;java.rmi.server.randomIDs&lt;/code&gt; is defined to equal the string &lt;code&gt;&quot;true&quot;&lt;/code&gt; (case insensitive), then this constructor will use a cryptographically strong random number generator to choose the object number of the returned &lt;code&gt;ObjID&lt;/code&gt;.</source>
          <target state="translated">如果将系统属性 &lt;code&gt;java.rmi.server.randomIDs&lt;/code&gt; 定义为等于字符串 &lt;code&gt;&quot;true&quot;&lt;/code&gt; （不区分大小写），则此构造方法将使用加密强度高的随机数生成器来选择返回的 &lt;code&gt;ObjID&lt;/code&gt; 的对象编号。</target>
        </trans-unit>
        <trans-unit id="dd24e048fc15e059868d56f4f568438df6b0caf5" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;java.util.jar.Pack200.Packer&lt;/code&gt; is defined, then the value is taken to be the fully-qualified name of a concrete implementation class, which must implement Packer. This class is loaded and instantiated. If this process fails then an unspecified error is thrown.</source>
          <target state="translated">如果定义了系统属性 &lt;code&gt;java.util.jar.Pack200.Packer&lt;/code&gt; ，则该值将作为必须实现Packer的具体实现类的标准名称。此类已加载并实例化。如果此过程失败，则会引发未指定的错误。</target>
        </trans-unit>
        <trans-unit id="45a9607a9147c5f0b3360c97b95442bd171c997a" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;java.util.jar.Pack200.Unpacker&lt;/code&gt; is defined, then the value is taken to be the fully-qualified name of a concrete implementation class, which must implement Unpacker. The class is loaded and instantiated. If this process fails then an unspecified error is thrown.</source>
          <target state="translated">如果定义了系统属性 &lt;code&gt;java.util.jar.Pack200.Unpacker&lt;/code&gt; ，则该值将作为必须实现Unpacker的具体实现类的标准名称。该类已加载并实例化。如果此过程失败，则会引发未指定的错误。</target>
        </trans-unit>
        <trans-unit id="e75189cd7136093b1d6f408091c23d0de22eb446" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;java.util.prefs.PreferencesFactory&lt;/code&gt; is defined, then it is taken to be the fully-qualified name of a class implementing the &lt;code&gt;PreferencesFactory&lt;/code&gt; interface. The class is loaded and instantiated; if this process fails then an unspecified error is thrown.</source>
          <target state="translated">如果定义了系统属性 &lt;code&gt;java.util.prefs.PreferencesFactory&lt;/code&gt; ，则将其视为实现 &lt;code&gt;PreferencesFactory&lt;/code&gt; 接口的类的标准名称。该类已加载并实例化；如果此过程失败，则会引发未指定的错误。</target>
        </trans-unit>
        <trans-unit id="a7e27f744d6efd52e983b8075a0c2febcea34f65" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;javax.management.builder.initial&lt;/code&gt; is set, the platform &lt;code&gt;MBeanServer&lt;/code&gt; creation will be done by the specified &lt;a href=&quot;../../../javax/management/mbeanserverbuilder&quot;&gt;&lt;code&gt;MBeanServerBuilder&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果设置了系统属性 &lt;code&gt;javax.management.builder.initial&lt;/code&gt; ，则平台 &lt;code&gt;MBeanServer&lt;/code&gt; 的创建将由指定的&lt;a href=&quot;../../../javax/management/mbeanserverbuilder&quot;&gt; &lt;code&gt;MBeanServerBuilder&lt;/code&gt; 完成&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d066e5cdc048829a2f626bea353ff4aba240c230" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;javax.rmi.ssl.client.enabledCipherSuites&lt;/code&gt; is specified, the &lt;a href=&quot;#createSocket(java.lang.String,int)&quot;&gt;&lt;code&gt;createSocket(String,int)&lt;/code&gt;&lt;/a&gt; method will call &lt;a href=&quot;../../../../java.base/javax/net/ssl/sslsocket#setEnabledCipherSuites(java.lang.String%5B%5D)&quot;&gt;&lt;code&gt;SSLSocket.setEnabledCipherSuites(String[])&lt;/code&gt;&lt;/a&gt; before returning the socket. The value of this system property is a string that is a comma-separated list of SSL/TLS cipher suites to enable.</source>
          <target state="translated">如果指定了系统属性 &lt;code&gt;javax.rmi.ssl.client.enabledCipherSuites&lt;/code&gt; ，则&lt;a href=&quot;#createSocket(java.lang.String,int)&quot;&gt; &lt;code&gt;createSocket(String,int)&lt;/code&gt; &lt;/a&gt;方法将在返回套接字之前调用&lt;a href=&quot;../../../../java.base/javax/net/ssl/sslsocket#setEnabledCipherSuites(java.lang.String%5B%5D)&quot;&gt; &lt;code&gt;SSLSocket.setEnabledCipherSuites(String[])&lt;/code&gt; &lt;/a&gt;。此系统属性的值是一个字符串，该字符串是要启用的SSL / TLS密码套件的逗号分隔列表。</target>
        </trans-unit>
        <trans-unit id="9cdd13fa82f3ac48193dd93680807e448f9971c6" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;javax.rmi.ssl.client.enabledCipherSuites&lt;/code&gt; is specified, this method will call &lt;a href=&quot;../../../../java.base/javax/net/ssl/sslsocket#setEnabledCipherSuites(java.lang.String%5B%5D)&quot;&gt;&lt;code&gt;SSLSocket.setEnabledCipherSuites(String[])&lt;/code&gt;&lt;/a&gt; before returning the socket. The value of this system property is a string that is a comma-separated list of SSL/TLS cipher suites to enable.</source>
          <target state="translated">如果指定了系统属性 &lt;code&gt;javax.rmi.ssl.client.enabledCipherSuites&lt;/code&gt; ，则此方法将在返回套接字之前调用&lt;a href=&quot;../../../../java.base/javax/net/ssl/sslsocket#setEnabledCipherSuites(java.lang.String%5B%5D)&quot;&gt; &lt;code&gt;SSLSocket.setEnabledCipherSuites(String[])&lt;/code&gt; &lt;/a&gt;。此系统属性的值是一个字符串，该字符串是要启用的SSL / TLS密码套件的逗号分隔列表。</target>
        </trans-unit>
        <trans-unit id="e3beb140976a34dd92e43f005e5cdc896cbf0e59" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;javax.rmi.ssl.client.enabledProtocols&lt;/code&gt; is specified, the &lt;a href=&quot;#createSocket(java.lang.String,int)&quot;&gt;&lt;code&gt;createSocket(String,int)&lt;/code&gt;&lt;/a&gt; method will call &lt;a href=&quot;../../../../java.base/javax/net/ssl/sslsocket#setEnabledProtocols(java.lang.String%5B%5D)&quot;&gt;&lt;code&gt;SSLSocket.setEnabledProtocols(String[])&lt;/code&gt;&lt;/a&gt; before returning the socket. The value of this system property is a string that is a comma-separated list of SSL/TLS protocol versions to enable.</source>
          <target state="translated">如果指定了系统属性 &lt;code&gt;javax.rmi.ssl.client.enabledProtocols&lt;/code&gt; ，则&lt;a href=&quot;#createSocket(java.lang.String,int)&quot;&gt; &lt;code&gt;createSocket(String,int)&lt;/code&gt; &lt;/a&gt;方法将在返回套接字之前调用&lt;a href=&quot;../../../../java.base/javax/net/ssl/sslsocket#setEnabledProtocols(java.lang.String%5B%5D)&quot;&gt; &lt;code&gt;SSLSocket.setEnabledProtocols(String[])&lt;/code&gt; &lt;/a&gt;。该系统属性的值是一个字符串，该字符串是要启用的SSL / TLS协议版本的逗号分隔列表。</target>
        </trans-unit>
        <trans-unit id="2c1710dbf416654c2b07f01e4c116984afd32006" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;javax.rmi.ssl.client.enabledProtocols&lt;/code&gt; is specified, this method will call &lt;a href=&quot;../../../../java.base/javax/net/ssl/sslsocket#setEnabledProtocols(java.lang.String%5B%5D)&quot;&gt;&lt;code&gt;SSLSocket.setEnabledProtocols(String[])&lt;/code&gt;&lt;/a&gt; before returning the socket. The value of this system property is a string that is a comma-separated list of SSL/TLS protocol versions to enable.</source>
          <target state="translated">如果指定了系统属性 &lt;code&gt;javax.rmi.ssl.client.enabledProtocols&lt;/code&gt; ，则此方法将在返回套接字之前调用&lt;a href=&quot;../../../../java.base/javax/net/ssl/sslsocket#setEnabledProtocols(java.lang.String%5B%5D)&quot;&gt; &lt;code&gt;SSLSocket.setEnabledProtocols(String[])&lt;/code&gt; &lt;/a&gt;。该系统属性的值是一个字符串，该字符串是要启用的SSL / TLS协议版本的逗号分隔列表。</target>
        </trans-unit>
        <trans-unit id="d37a20fcf5fe426fc5b5a1c3bcefbc944d6b8689" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;javax.sound.midi.Receiver&lt;/code&gt; is defined or it is defined in the file &quot;sound.properties&quot;, it is used to identify the device that provides the default receiver. For details, refer to the &lt;a href=&quot;midisystem&quot;&gt;&lt;code&gt;class description&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果定义了系统属性 &lt;code&gt;javax.sound.midi.Receiver&lt;/code&gt; 或在文件&amp;ldquo; sound.properties&amp;rdquo;中定义了该属性，则该属性用于标识提供默认接收器的设备。有关详细信息，请参阅&lt;a href=&quot;midisystem&quot;&gt; &lt;code&gt;class description&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0cde7239c70f83bff85e4440c46d6384691316ad" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;javax.sound.midi.Receiver&lt;/code&gt; is defined or it is defined in the file &quot;sound.properties&quot;, it is used to identify the device that provides the default receiver. For details, refer to the &lt;a href=&quot;midisystem&quot;&gt;&lt;code&gt;class description&lt;/code&gt;&lt;/a&gt;. If a suitable MIDI port is not available, the Receiver is retrieved from an installed synthesizer.</source>
          <target state="translated">如果定义了系统属性 &lt;code&gt;javax.sound.midi.Receiver&lt;/code&gt; 或在文件&amp;ldquo; sound.properties&amp;rdquo;中定义了该属性，则该属性用于标识提供默认接收器的设备。有关详细信息，请参阅&lt;a href=&quot;midisystem&quot;&gt; &lt;code&gt;class description&lt;/code&gt; &lt;/a&gt;。如果没有合适的MIDI端口，则从已安装的合成器中检索接收器。</target>
        </trans-unit>
        <trans-unit id="91d3c314661dc26f163d797ffb58967de288f2ac" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;javax.sound.midi.Sequencer&lt;/code&gt; is defined or it is defined in the file &quot;sound.properties&quot;, it is used to identify the default sequencer. For details, refer to the &lt;a href=&quot;midisystem&quot;&gt;&lt;code&gt;class description&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果定义了系统属性 &lt;code&gt;javax.sound.midi.Sequencer&lt;/code&gt; 或在文件&amp;ldquo; sound.properties&amp;rdquo; 中定义了系统属性，那么它将用于标识默认音序器。有关详细信息，请参阅&lt;a href=&quot;midisystem&quot;&gt; &lt;code&gt;class description&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="00dcdd9d0bce1154db11492279afceeca3e08d7a" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;javax.sound.midi.Synthesizer&lt;/code&gt; is defined or it is defined in the file &quot;sound.properties&quot;, it is used to identify the default synthesizer. For details, refer to the &lt;a href=&quot;midisystem&quot;&gt;&lt;code&gt;class description&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果定义了系统属性 &lt;code&gt;javax.sound.midi.Synthesizer&lt;/code&gt; 或在文件&amp;ldquo; sound.properties&amp;rdquo;中定义了该属性，则该属性用于标识默认的合成器。有关详细信息，请参阅&lt;a href=&quot;midisystem&quot;&gt; &lt;code&gt;class description&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="30df19d74bec068b077f43c95c9174eacf908696" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;javax.sound.midi.Transmitter&lt;/code&gt; is defined or it is defined in the file &quot;sound.properties&quot;, it is used to identify the device that provides the default transmitter. For details, refer to the &lt;a href=&quot;midisystem&quot;&gt;&lt;code&gt;class description&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果定义了系统属性 &lt;code&gt;javax.sound.midi.Transmitter&lt;/code&gt; 或在文件&amp;ldquo; sound.properties&amp;rdquo;中定义了该属性，则该属性用于标识提供默认发送器的设备。有关详细信息，请参阅&lt;a href=&quot;midisystem&quot;&gt; &lt;code&gt;class description&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2db720e9cdab4ebfc9f02a35fbd8f738bb2171b1" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;javax.sound.sampled.Clip&lt;/code&gt; is defined or it is defined in the file &quot;sound.properties&quot;, it is used to retrieve the default clip. For details, refer to the &lt;a href=&quot;audiosystem&quot;&gt;&lt;code&gt;class description&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果定义了系统属性 &lt;code&gt;javax.sound.sampled.Clip&lt;/code&gt; 或在文件&amp;ldquo; sound.properties&amp;rdquo;中定义了该属性，则将其用于检索默认剪辑。有关详细信息，请参阅&lt;a href=&quot;audiosystem&quot;&gt; &lt;code&gt;class description&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="878cc5542428544d5bac13085b41e0430d054903" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;javax.sound.sampled.SourceDataLine&lt;/code&gt; is defined or it is defined in the file &quot;sound.properties&quot;, it is used to retrieve the default source data line. For details, refer to the &lt;a href=&quot;audiosystem&quot;&gt;&lt;code&gt;class description&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果定义了系统属性 &lt;code&gt;javax.sound.sampled.SourceDataLine&lt;/code&gt; 或在文件&amp;ldquo; sound.properties&amp;rdquo; 中定义了系统属性，那么它将用于检索默认的源数据行。有关详细信息，请参阅&lt;a href=&quot;audiosystem&quot;&gt; &lt;code&gt;class description&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b8d607cde38af381ba0dfdab64a53303e271b212" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;javax.sound.sampled.TargetDataLine&lt;/code&gt; is defined or it is defined in the file &quot;sound.properties&quot;, it is used to retrieve the default target data line. For details, refer to the &lt;a href=&quot;audiosystem&quot;&gt;&lt;code&gt;class description&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果定义了系统属性 &lt;code&gt;javax.sound.sampled.TargetDataLine&lt;/code&gt; 或在文件&amp;ldquo; sound.properties&amp;rdquo; 中定义了系统属性，则将其用于检索默认目标数据行。有关详细信息，请参阅&lt;a href=&quot;audiosystem&quot;&gt; &lt;code&gt;class description&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d07239e369381a0fb6e04b89573dbf0f8758c57d" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;org.xml.sax.driver&lt;/code&gt; has a value, that is used as an XMLReader class name.</source>
          <target state="translated">如果系统属性 &lt;code&gt;org.xml.sax.driver&lt;/code&gt; 具有一个值，则该值将用作XMLReader类名。</target>
        </trans-unit>
        <trans-unit id="7eb7d836f2f43aa70bd878289c523ee9226c1901" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;suppressSwingDropSupport&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; (the default) and the current drop target on this component is either &lt;code&gt;null&lt;/code&gt; or not a user-set drop target, this method will change the drop target as follows: If &lt;code&gt;newHandler&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; it will clear the drop target. If not &lt;code&gt;null&lt;/code&gt; it will install a new &lt;code&gt;DropTarget&lt;/code&gt;.</source>
          <target state="translated">如果系统属性 &lt;code&gt;suppressSwingDropSupport&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; （默认值），并且此组件上的当前放置目标为 &lt;code&gt;null&lt;/code&gt; 或不是用户设置的放置目标，则此方法将更改放置目标，如下所示：如果 &lt;code&gt;newHandler&lt;/code&gt; 为 &lt;code&gt;null&lt;/code&gt; ，则将清除放置目标。如果不为 &lt;code&gt;null&lt;/code&gt; ，它将安装新的 &lt;code&gt;DropTarget&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d7708124db0ebabf9cd252ce976d692ad91505f5" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;swing.defaultlaf&lt;/code&gt; is &lt;code&gt;non-null&lt;/code&gt;, use its value as the default look and feel class name.</source>
          <target state="translated">如果系统属性 &lt;code&gt;swing.defaultlaf&lt;/code&gt; 的 &lt;code&gt;non-null&lt;/code&gt; ，使用它作为默认的外观类的名称值。</target>
        </trans-unit>
        <trans-unit id="8ff71830cbe5c28d3e3792ef57a69165cfffa083" translate="yes" xml:space="preserve">
          <source>If the system property is not set or the getInstance() call fails for any reason, the system defaults to an implementation specific default type and TerminalFactory.</source>
          <target state="translated">如果系统属性没有设置或getInstance()调用因任何原因失败,系统会默认为特定实现的默认类型和TerminalFactory。</target>
        </trans-unit>
        <trans-unit id="de8593fcec2e6dbf96521d87b6c0f3273e22eb58" translate="yes" xml:space="preserve">
          <source>If the system property specified by &lt;a href=&quot;#DATATYPEFACTORY_PROPERTY&quot;&gt;&lt;code&gt;DATATYPEFACTORY_PROPERTY&lt;/code&gt;&lt;/a&gt;, &quot;&lt;code&gt;javax.xml.datatype.DatatypeFactory&lt;/code&gt;&quot;, exists, a class with the name of the property value is instantiated. Any Exception thrown during the instantiation process is wrapped as a &lt;a href=&quot;datatypeconfigurationexception&quot;&gt;&lt;code&gt;DatatypeConfigurationException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果存在由&lt;a href=&quot;#DATATYPEFACTORY_PROPERTY&quot;&gt; &lt;code&gt;DATATYPEFACTORY_PROPERTY&lt;/code&gt; &lt;/a&gt;指定的系统属性&amp;ldquo; &lt;code&gt;javax.xml.datatype.DatatypeFactory&lt;/code&gt; &amp;rdquo;，则实例化具有属性值名称的类。在实例化过程中抛出的所有Exception都包装为&lt;a href=&quot;datatypeconfigurationexception&quot;&gt; &lt;code&gt;DatatypeConfigurationException&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0de1cc0e4dda5fcc7e4aa252a0cbf64fbed0f628" translate="yes" xml:space="preserve">
          <source>If the target VM is disconnected during the invoke (for example, through &lt;a href=&quot;virtualmachine#dispose()&quot;&gt;&lt;code&gt;VirtualMachine.dispose()&lt;/code&gt;&lt;/a&gt;) the method invocation continues.</source>
          <target state="translated">如果在调用过程中断开了目标VM的连接（例如，通过&lt;a href=&quot;virtualmachine#dispose()&quot;&gt; &lt;code&gt;VirtualMachine.dispose()&lt;/code&gt; &lt;/a&gt;），则方法调用将继续。</target>
        </trans-unit>
        <trans-unit id="8886f362ca8263086eee9b95c52f35ec0d45cf61" translate="yes" xml:space="preserve">
          <source>If the target VM terminates before the disconnection, this event will be preceded by a &lt;a href=&quot;vmdeathevent&quot;&gt;&lt;code&gt;VMDeathEvent&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果目标VM在断开连接之前终止，则此事件之前将带有&lt;a href=&quot;vmdeathevent&quot;&gt; &lt;code&gt;VMDeathEvent&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6af05deaf58fe154a4b75ce321753672bae18f99" translate="yes" xml:space="preserve">
          <source>If the target file exists, then the target file is replaced if it is not a non-empty directory. If the target file exists and is a symbolic link, then the symbolic link itself, not the target of the link, is replaced.</source>
          <target state="translated">如果目标文件存在,那么如果目标文件不是一个非空目录,那么就会被替换。如果目标文件存在并且是一个符号链接,那么替换的是符号链接本身,而不是链接的目标。</target>
        </trans-unit>
        <trans-unit id="ac457e75b3f1b21e3f75382a66191d55b4a52e0f" translate="yes" xml:space="preserve">
          <source>If the target is _parent, then it deletes the parent element, which is a &amp;lt;FRAMESET&amp;gt; element, and inserts a new &amp;lt;FRAME&amp;gt; element, and sets its &lt;code&gt;HTML.Attribute.SRC&lt;/code&gt; attribute to have a value equal to the destination URL and fire a &lt;code&gt;RemovedUpdate&lt;/code&gt; and &lt;code&gt;InsertUpdate&lt;/code&gt;.</source>
          <target state="translated">如果目标是_parent，则它将删除父元素（即&amp;lt;FRAMESET&amp;gt;元素），并插入新的&amp;lt;FRAME&amp;gt;元素，并将其 &lt;code&gt;HTML.Attribute.SRC&lt;/code&gt; 属性设置为具有等于目标URL的值，然后a &lt;code&gt;RemovedUpdate&lt;/code&gt; 和 &lt;code&gt;InsertUpdate&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cf1de5041cbc9489101a1efbb3aa93f8e3747f64" translate="yes" xml:space="preserve">
          <source>If the target is _top, this method does nothing. In the implementation of the view for a frame, namely the &lt;code&gt;FrameView&lt;/code&gt;, the processing of _top is handled. Given that _top implies replacing the entire document, it made sense to handle this outside of the document that it will replace.</source>
          <target state="translated">如果目标是_top，则此方法不执行任何操作。在框架视图（即 &lt;code&gt;FrameView&lt;/code&gt; )的实现中，处理_top的处理。鉴于_top表示要替换整个文档，因此有必要在将要替换的文档之外进行处理。</target>
        </trans-unit>
        <trans-unit id="05419b4ed8480b175c0a67be127a4f47601c6536" translate="yes" xml:space="preserve">
          <source>If the target is a named frame, then the element hierarchy is searched for an element with a name equal to the target, its &lt;code&gt;HTML.Attribute.SRC&lt;/code&gt; attribute is updated and a &lt;code&gt;ChangedUpdate&lt;/code&gt; event is fired.</source>
          <target state="translated">如果目标是命名框架，则在元素层次结构中搜索名称等于目标的元素，并更新其 &lt;code&gt;HTML.Attribute.SRC&lt;/code&gt; 属性并触发 &lt;code&gt;ChangedUpdate&lt;/code&gt; 事件。</target>
        </trans-unit>
        <trans-unit id="3c180e88e82b133d4c219bf7bc995901410956a4" translate="yes" xml:space="preserve">
          <source>If the target method handle consumes no arguments besides than the result (if any) of the filter &lt;code&gt;coll&lt;/code&gt;, then &lt;code&gt;collectArguments(mh, 0, coll)&lt;/code&gt; is equivalent to &lt;code&gt;filterReturnValue(coll, mh)&lt;/code&gt;. If the filter method handle &lt;code&gt;coll&lt;/code&gt; consumes one argument and produces a non-void result, then &lt;code&gt;collectArguments(mh, N, coll)&lt;/code&gt; is equivalent to &lt;code&gt;filterArguments(mh, N, coll)&lt;/code&gt;. Other equivalences are possible but would require argument permutation.</source>
          <target state="translated">如果目标方法句柄除过滤器 &lt;code&gt;coll&lt;/code&gt; 的结果（如果有）之外不消耗任何参数，则 &lt;code&gt;collectArguments(mh, 0, coll)&lt;/code&gt; 等同于 &lt;code&gt;filterReturnValue(coll, mh)&lt;/code&gt; 。如果filter方法句柄 &lt;code&gt;coll&lt;/code&gt; 使用一个参数并产生非空结果，则 &lt;code&gt;collectArguments(mh, N, coll)&lt;/code&gt; 等同于 &lt;code&gt;filterArguments(mh, N, coll)&lt;/code&gt; 。其他等价也是可能的，但需要参数置换。</target>
        </trans-unit>
        <trans-unit id="458e499fec0b734951e6d53ad84671bd6e68d6c5" translate="yes" xml:space="preserve">
          <source>If the target method handle has variable arity, and the argument list is longer than that arity, the excess arguments, starting at the position of the trailing array argument, will be gathered (if possible, as if by &lt;code&gt;asType&lt;/code&gt; conversions) into an array of the appropriate type, and invocation will proceed on the shortened argument list. In this way, &lt;em&gt;jumbo argument lists&lt;/em&gt; which would spread into more than 254 slots can still be processed uniformly.</source>
          <target state="translated">如果目标方法句柄具有可变的arity，并且参数列表长于该arity， &lt;code&gt;asType&lt;/code&gt; 尾随数组参数的位置开始的多余参数将（如果可能，就像通过asType转换一样）收集到一个数组中适当的类型，并且调用将在缩短的参数列表上进行。这样，仍然可以统一处理将分散到254个以上插槽中的&lt;em&gt;巨型自变量列表&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="9a6410dfb8cfd393874164170a840502005c25ad" translate="yes" xml:space="preserve">
          <source>If the target returns a value, the filter must accept that value as its only argument. If the target returns void, the filter must accept no arguments.</source>
          <target state="translated">如果目标返回一个值,过滤器必须接受该值作为唯一的参数。如果目标返回void,则过滤器必须不接受任何参数。</target>
        </trans-unit>
        <trans-unit id="933efa6315f31837fd252efc9f236faa4bf2d497" translate="yes" xml:space="preserve">
          <source>If the target text component is specified as the source of the ActionEvent and there is a command string, the command string will be interpreted as an integer that should be one of the legal values for the &lt;code&gt;StyleConstants.Alignment&lt;/code&gt; attribute.</source>
          <target state="translated">如果将目标文本组件指定为ActionEvent的源，并且有命令字符串，则该命令字符串将被解释为一个整数，该整数应为 &lt;code&gt;StyleConstants.Alignment&lt;/code&gt; 属性的合法值之一。</target>
        </trans-unit>
        <trans-unit id="ad7689e60ae1c9939383833d9772f90e200fa26d" translate="yes" xml:space="preserve">
          <source>If the target text component is specified as the source of the ActionEvent and there is a command string, the command string will be interpreted as the foreground color. It will be interpreted by called &lt;code&gt;Color.decode&lt;/code&gt;, and should therefore be legal input for that method.</source>
          <target state="translated">如果将目标文本组件指定为ActionEvent的源，并且有命令字符串，则该命令字符串将被解释为前景色。它将通过称为 &lt;code&gt;Color.decode&lt;/code&gt; 进行解释，因此应该是该方法的合法输入。</target>
        </trans-unit>
        <trans-unit id="60ff5ddff7c5d899dfe402e4472a1b9b2a332d25" translate="yes" xml:space="preserve">
          <source>If the temporal object does not contain a date, but does contain one or more &lt;code&gt;ChronoField&lt;/code&gt; date fields, then a &lt;code&gt;DateTimeException&lt;/code&gt; is thrown. In all other cases, the override chronology is added to the temporal, replacing any previous chronology, but without changing the date/time.</source>
          <target state="translated">如果时间对象不包含日期，但是包含一个或多个 &lt;code&gt;ChronoField&lt;/code&gt; 日期字段，则将引发 &lt;code&gt;DateTimeException&lt;/code&gt; 。在所有其他情况下，替代时间顺序将添加到时间中，以替换任何先前的时间顺序，但不更改日期/时间。</target>
        </trans-unit>
        <trans-unit id="dd85e14ed75c47c84beea3f122d891fc9308e690" translate="yes" xml:space="preserve">
          <source>If the temporal object does not contain an instant, but does contain an offset then an additional check is made. If the normalized override zone is an offset that differs from the offset of the temporal, then a &lt;code&gt;DateTimeException&lt;/code&gt; is thrown. In all other cases, the override zone is added to the temporal, replacing any previous zone, but without changing the date/time.</source>
          <target state="translated">如果时间对象不包含瞬间，但是包含偏移量，则进行附加检查。如果规范化覆盖区域的偏移量与时间偏移量不同，则将引发 &lt;code&gt;DateTimeException&lt;/code&gt; 。在所有其他情况下，将覆盖区域添加到时态中，替换以前的任何区域，但不更改日期/时间。</target>
        </trans-unit>
        <trans-unit id="9c09abaae8508d70028ba67cefa61277b54360a6" translate="yes" xml:space="preserve">
          <source>If the thread argument is a system thread (belongs to the thread group with a &lt;code&gt;null&lt;/code&gt; parent) then this method calls &lt;code&gt;checkPermission&lt;/code&gt; with the &lt;code&gt;RuntimePermission(&quot;modifyThread&quot;)&lt;/code&gt; permission. If the thread argument is</source>
          <target state="translated">如果thread参数是系统线程（属于具有 &lt;code&gt;null&lt;/code&gt; 父级的线程组），则此方法将调用具有 &lt;code&gt;RuntimePermission(&quot;modifyThread&quot;)&lt;/code&gt; 权限的 &lt;code&gt;checkPermission&lt;/code&gt; 。如果线程参数是</target>
        </trans-unit>
        <trans-unit id="956a4caf473783d2c99b96d529421cc001582508" translate="yes" xml:space="preserve">
          <source>If the thread group argument is the system thread group ( has a &lt;code&gt;null&lt;/code&gt; parent) then this method calls &lt;code&gt;checkPermission&lt;/code&gt; with the &lt;code&gt;RuntimePermission(&quot;modifyThreadGroup&quot;)&lt;/code&gt; permission. If the thread group argument is</source>
          <target state="translated">如果线程组参数是系统线程组（父级为 &lt;code&gt;null&lt;/code&gt; ），则此方法使用 &lt;code&gt;RuntimePermission(&quot;modifyThreadGroup&quot;)&lt;/code&gt; 权限调用 &lt;code&gt;checkPermission&lt;/code&gt; 。如果线程组参数是</target>
        </trans-unit>
        <trans-unit id="2851f30724641ecca099288cb8621aaa00615fd6" translate="yes" xml:space="preserve">
          <source>If the thread is alive but suspended, it is resumed and is permitted to make progress in its execution.</source>
          <target state="translated">如果该线程还活着但被暂停,则恢复该线程并允许其执行进度。</target>
        </trans-unit>
        <trans-unit id="a8d129983d6e8dc28983c9eb2cd579ed898cf687" translate="yes" xml:space="preserve">
          <source>If the thread is alive, it is suspended and makes no further progress unless and until it is resumed.</source>
          <target state="translated">如果该线程还活着,它就会被暂停,并且不会有进一步的进展,除非并直到它被恢复。</target>
        </trans-unit>
        <trans-unit id="95f23b0ab1d9ecd54f0d7d1cfdcbc8a705f2c602" translate="yes" xml:space="preserve">
          <source>If the thread of the specified ID is not alive or does not exist, this method returns &lt;code&gt;-1&lt;/code&gt;. If CPU time measurement is disabled, this method returns &lt;code&gt;-1&lt;/code&gt;. A thread is alive if it has been started and has not yet died.</source>
          <target state="translated">如果指定ID的线程不存在或不存在，则此方法返回 &lt;code&gt;-1&lt;/code&gt; 。如果禁用了CPU时间测量，则此方法返回 &lt;code&gt;-1&lt;/code&gt; 。如果线程已经启动但尚未死亡，则该线程是活动的。</target>
        </trans-unit>
        <trans-unit id="2f1597e2b1b784b5b3de28848e78b8e4d92ff74b" translate="yes" xml:space="preserve">
          <source>If the thread with the specified ID is not alive or does not exist, this method returns &lt;code&gt;-1&lt;/code&gt;. If thread memory allocation measurement is disabled, this method returns &lt;code&gt;-1&lt;/code&gt;. A thread is alive if it has been started and has not yet died.</source>
          <target state="translated">如果具有指定ID的线程不存在或不存在，则此方法返回 &lt;code&gt;-1&lt;/code&gt; 。如果禁用了线程内存分配测量，则此方法返回 &lt;code&gt;-1&lt;/code&gt; 。如果线程已经启动但尚未死亡，则该线程是活动的。</target>
        </trans-unit>
        <trans-unit id="97aef73764a8b235d11df488cc792228726de005" translate="yes" xml:space="preserve">
          <source>If the time '23:59:60' is received, then a simple conversion is applied, replacing the second-of-minute of 60 with 59. This query can be used on the parse result to determine if the leap-second adjustment was made. The query will return &lt;code&gt;true&lt;/code&gt; if it did adjust to remove the leap-second, and &lt;code&gt;false&lt;/code&gt; if not. Note that applying a leap-second smoothing mechanism, such as UTC-SLS, is the responsibility of the application, as follows:</source>
          <target state="translated">如果收到时间&amp;ldquo; 23:59:60&amp;rdquo;，则将应用简单的转换，用59代替秒的60分钟。此查询可用于解析结果以确定the秒调整是否为制作。如果查询确实进行了调整以删除the秒，则查询将返回 &lt;code&gt;true&lt;/code&gt; ;否则返回 &lt;code&gt;false&lt;/code&gt; 。请注意，应用a秒平滑机制（例如UTC-SLS）是应用程序的责任，如下所示：</target>
        </trans-unit>
        <trans-unit id="6ae6878cfd3b1d0ceb5a94fe0301dc8e364dcc4f" translate="yes" xml:space="preserve">
          <source>If the timeout limit is set to 't' seconds, a session exceeds the timeout limit 't' seconds after its creation time. When the timeout limit is exceeded for a session, the &lt;code&gt;SSLSession&lt;/code&gt; object is invalidated and future connections cannot resume or rejoin the session. A check for sessions exceeding the timeout is made immediately whenever the timeout limit is changed for this &lt;code&gt;SSLSessionContext&lt;/code&gt;.</source>
          <target state="translated">如果超时限制设置为&amp;ldquo; t&amp;rdquo;秒，则会话在其创建时间之后超过超时限制&amp;ldquo; t&amp;rdquo;秒。如果会话超过了超时限制，则 &lt;code&gt;SSLSession&lt;/code&gt; 对象将失效，以后的连接将无法继续或重新加入该会话。每当更改此 &lt;code&gt;SSLSessionContext&lt;/code&gt; 的超时限制时，都会立即检查是否存在超时会话。</target>
        </trans-unit>
        <trans-unit id="ad1adddf8356c433278ef7cd10d12a5f2bd6c761" translate="yes" xml:space="preserve">
          <source>If the timeout limit is set to 't' seconds, a session exceeds the timeout limit 't' seconds after its creation time. When the timeout limit is exceeded for a session, the &lt;code&gt;SSLSession&lt;/code&gt; object is invalidated and future connections cannot resume or rejoin the session. A check for sessions exceeding the timeout limit is made immediately whenever the timeout limit is changed for this &lt;code&gt;SSLSessionContext&lt;/code&gt;.</source>
          <target state="translated">如果超时限制设置为&amp;ldquo; t&amp;rdquo;秒，则会话在其创建时间之后超过超时限制&amp;ldquo; t&amp;rdquo;秒。如果会话超过了超时限制，则 &lt;code&gt;SSLSession&lt;/code&gt; 对象将失效，以后的连接将无法继续或重新加入该会话。每当更改此 &lt;code&gt;SSLSessionContext&lt;/code&gt; 的超时限制时，都会立即检查是否有超过超时限制的会话。</target>
        </trans-unit>
        <trans-unit id="44775d676f01ccf28f57333e6fb89f1c12f0cfd6" translate="yes" xml:space="preserve">
          <source>If the timer notification to be inserted has a date that is before the current date, the method behaves as if the specified date were the current date and the notification is delivered immediately.</source>
          <target state="translated">如果要插入的定时器通知的日期在当前日期之前,则该方法的行为就像指定的日期是当前日期一样,通知会立即发送。</target>
        </trans-unit>
        <trans-unit id="8056b6ccedf3aca7fb9d63268e271ee88e090cd9" translate="yes" xml:space="preserve">
          <source>If the timer notification to be inserted has a date that is before the current date, the method behaves as if the specified date were the current date.</source>
          <target state="translated">如果要插入的定时器通知的日期在当前日期之前,则该方法的行为就像指定的日期是当前日期一样。</target>
        </trans-unit>
        <trans-unit id="f7ed1fef67b3c31fe3734b8ae38aa892bb880b72" translate="yes" xml:space="preserve">
          <source>If the timer notification to be inserted has a date that is before the current date, the method behaves as if the specified date were the current date. The first notification is delivered immediately and the subsequent ones are spaced as specified by the period parameter.</source>
          <target state="translated">如果要插入的定时器通知的日期在当前日期之前,则该方法的行为就像指定的日期是当前日期一样。第一条通知立即发送,随后的通知按周期参数指定的间隔发送。</target>
        </trans-unit>
        <trans-unit id="38b2e2e16267baf4e1e54405bd70137ca888e8ed" translate="yes" xml:space="preserve">
          <source>If the timer's task execution thread terminates unexpectedly, for example, because its &lt;code&gt;stop&lt;/code&gt; method is invoked, any further attempt to schedule a task on the timer will result in an &lt;code&gt;IllegalStateException&lt;/code&gt;, as if the timer's &lt;code&gt;cancel&lt;/code&gt; method had been invoked.</source>
          <target state="translated">如果计时器的任务执行线程意外终止，例如，由于调用了它的 &lt;code&gt;stop&lt;/code&gt; 方法，则在计时器上计划任务的任何进一步尝试都将导致 &lt;code&gt;IllegalStateException&lt;/code&gt; ，就好像计时器的 &lt;code&gt;cancel&lt;/code&gt; 方法已被调用一样。</target>
        </trans-unit>
        <trans-unit id="ac3591693d15d3e4209a0731ba617c073e32bb40" translate="yes" xml:space="preserve">
          <source>If the transformer throws an exception (which it doesn't catch), subsequent transformers will still be called and the load, redefine or retransform will still be attempted. Thus, throwing an exception has the same effect as returning &lt;code&gt;null&lt;/code&gt;. To prevent unexpected behavior when unchecked exceptions are generated in transformer code, a transformer can catch &lt;code&gt;Throwable&lt;/code&gt;. If the transformer believes the &lt;code&gt;classFileBuffer&lt;/code&gt; does not represent a validly formatted class file, it should throw an &lt;code&gt;IllegalClassFormatException&lt;/code&gt;; while this has the same effect as returning null. it facilitates the logging or debugging of format corruptions.</source>
          <target state="translated">如果转换器抛出异常（不捕获），则后续的转换器仍将被调用，并且仍将尝试进行负载，重新定义或重新转换。因此，抛出异常与返回 &lt;code&gt;null&lt;/code&gt; 具有相同的效果。为了防止在转换器代码中生成未经检查的异常时发生意外行为，转换器可以捕获 &lt;code&gt;Throwable&lt;/code&gt; 。如果转换器认为 &lt;code&gt;classFileBuffer&lt;/code&gt; 不代表有效格式化的类文件，则应抛出 &lt;code&gt;IllegalClassFormatException&lt;/code&gt; ；而这与返回null的效果相同。它有助于记录或调试格式损坏。</target>
        </trans-unit>
        <trans-unit id="b2202f39f213e519d8a6a914b9451df18b3b6cd6" translate="yes" xml:space="preserve">
          <source>If the traversal key has not been explicitly set for this Window, then this Window's parent's traversal key is returned. If the traversal key has not been explicitly set for any of this Window's ancestors, then the current KeyboardFocusManager's default traversal key is returned.</source>
          <target state="translated">如果没有为这个窗口明确设置遍历键,那么将返回这个窗口的父级遍历键。如果没有为这个窗口的任何一个祖先明确设置遍历键,那么返回当前KeyboardFocusManager的默认遍历键。</target>
        </trans-unit>
        <trans-unit id="10849c037dd8bc1c2fc1c741b858e266697ece21" translate="yes" xml:space="preserve">
          <source>If the two arrays share a common prefix then the lexicographic comparison is the result of comparing two elements of type &lt;code&gt;T&lt;/code&gt; at an index &lt;code&gt;i&lt;/code&gt; within the respective arrays that is the prefix length, as if by:</source>
          <target state="translated">如果两个数组共享一个共同的前缀，那么字典比较是在两个数组的前缀长度为 &lt;code&gt;i&lt;/code&gt; 的索引i处比较两个 &lt;code&gt;T&lt;/code&gt; 类型的元素的结果，就像这样：</target>
        </trans-unit>
        <trans-unit id="b155792f2e510e17ec8d253fc3a0fb59ca79f8dd" translate="yes" xml:space="preserve">
          <source>If the two arrays share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by &lt;a href=&quot;../lang/boolean#compare(boolean,boolean)&quot;&gt;&lt;code&gt;Boolean.compare(boolean, boolean)&lt;/code&gt;&lt;/a&gt;, at an index within the respective arrays that is the prefix length. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two array lengths. (See &lt;a href=&quot;#mismatch(boolean%5B%5D,boolean%5B%5D)&quot;&gt;&lt;code&gt;mismatch(boolean[], boolean[])&lt;/code&gt;&lt;/a&gt; for the definition of a common and proper prefix.)</source>
          <target state="translated">如果两个数组共享一个公共前缀，则字典比较是比较两个元素的结果，就像通过&lt;a href=&quot;../lang/boolean#compare(boolean,boolean)&quot;&gt; &lt;code&gt;Boolean.compare(boolean, boolean)&lt;/code&gt; &lt;/a&gt;在相应数组中的索引（即前缀长度）处进行比较。否则，一个数组是另一个数组的适当前缀，而字典比较是比较两个数组长度的结果。（有关通用和适当前缀的定义，请参见&lt;a href=&quot;#mismatch(boolean%5B%5D,boolean%5B%5D)&quot;&gt; &lt;code&gt;mismatch(boolean[], boolean[])&lt;/code&gt; &lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="57243fdb8f978c78fb76c986d30f96d7bf6d4774" translate="yes" xml:space="preserve">
          <source>If the two arrays share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by &lt;a href=&quot;../lang/byte#compare(byte,byte)&quot;&gt;&lt;code&gt;Byte.compare(byte, byte)&lt;/code&gt;&lt;/a&gt;, at an index within the respective arrays that is the prefix length. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two array lengths. (See &lt;a href=&quot;#mismatch(byte%5B%5D,byte%5B%5D)&quot;&gt;&lt;code&gt;mismatch(byte[], byte[])&lt;/code&gt;&lt;/a&gt; for the definition of a common and proper prefix.)</source>
          <target state="translated">如果两个数组共享一个公共前缀，则字典比较是比较两个元素的结果，就像通过&lt;a href=&quot;../lang/byte#compare(byte,byte)&quot;&gt; &lt;code&gt;Byte.compare(byte, byte)&lt;/code&gt; &lt;/a&gt;在相应数组中的索引（即前缀长度）处进行比较一样。否则，一个数组是另一个数组的适当前缀，而字典比较是比较两个数组长度的结果。（有关常见和适当前缀的定义，请参见&lt;a href=&quot;#mismatch(byte%5B%5D,byte%5B%5D)&quot;&gt; &lt;code&gt;mismatch(byte[], byte[])&lt;/code&gt; &lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="efbf4a94c94fc3222d7e00ab8ab0707b70f1d4e9" translate="yes" xml:space="preserve">
          <source>If the two arrays share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by &lt;a href=&quot;../lang/byte#compareUnsigned(byte,byte)&quot;&gt;&lt;code&gt;Byte.compareUnsigned(byte, byte)&lt;/code&gt;&lt;/a&gt;, at an index within the respective arrays that is the prefix length. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two array lengths. (See &lt;a href=&quot;#mismatch(byte%5B%5D,byte%5B%5D)&quot;&gt;&lt;code&gt;mismatch(byte[], byte[])&lt;/code&gt;&lt;/a&gt; for the definition of a common and proper prefix.)</source>
          <target state="translated">如果两个数组共享一个公共前缀，则字典比较是比较两个元素的结果，就像通过&lt;a href=&quot;../lang/byte#compareUnsigned(byte,byte)&quot;&gt; &lt;code&gt;Byte.compareUnsigned(byte, byte)&lt;/code&gt; &lt;/a&gt;在相应数组中的索引（即前缀长度）处进行比较一样。否则，一个数组是另一个数组的适当前缀，而字典比较是比较两个数组长度的结果。（有关常见和适当前缀的定义，请参见&lt;a href=&quot;#mismatch(byte%5B%5D,byte%5B%5D)&quot;&gt; &lt;code&gt;mismatch(byte[], byte[])&lt;/code&gt; &lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="4e8abaf672daa90f27c4a28744cf3bffbed58f1b" translate="yes" xml:space="preserve">
          <source>If the two arrays share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by &lt;a href=&quot;../lang/character#compare(char,char)&quot;&gt;&lt;code&gt;Character.compare(char, char)&lt;/code&gt;&lt;/a&gt;, at an index within the respective arrays that is the prefix length. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two array lengths. (See &lt;a href=&quot;#mismatch(char%5B%5D,char%5B%5D)&quot;&gt;&lt;code&gt;mismatch(char[], char[])&lt;/code&gt;&lt;/a&gt; for the definition of a common and proper prefix.)</source>
          <target state="translated">如果两个数组共享一个公共前缀，则字典比较是比较两个元素的结果，就像通过&lt;a href=&quot;../lang/character#compare(char,char)&quot;&gt; &lt;code&gt;Character.compare(char, char)&lt;/code&gt; &lt;/a&gt;，在作为前缀长度的各个数组的索引处进行比较。否则，一个数组是另一个数组的适当前缀，而字典比较是比较两个数组长度的结果。（有关通用和适当前缀的定义，请参见&lt;a href=&quot;#mismatch(char%5B%5D,char%5B%5D)&quot;&gt; &lt;code&gt;mismatch(char[], char[])&lt;/code&gt; &lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="a1fa6e3b313e74e85610c3d66b8ff693e012d72d" translate="yes" xml:space="preserve">
          <source>If the two arrays share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by &lt;a href=&quot;../lang/double#compare(double,double)&quot;&gt;&lt;code&gt;Double.compare(double, double)&lt;/code&gt;&lt;/a&gt;, at an index within the respective arrays that is the prefix length. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two array lengths. (See &lt;a href=&quot;#mismatch(double%5B%5D,double%5B%5D)&quot;&gt;&lt;code&gt;mismatch(double[], double[])&lt;/code&gt;&lt;/a&gt; for the definition of a common and proper prefix.)</source>
          <target state="translated">如果两个数组共享一个公共前缀，则字典比较是比较两个元素的结果，就像通过&lt;a href=&quot;../lang/double#compare(double,double)&quot;&gt; &lt;code&gt;Double.compare(double, double)&lt;/code&gt; &lt;/a&gt;，在相应数组中的索引（即前缀长度）处进行比较。否则，一个数组是另一个数组的适当前缀，而字典比较是比较两个数组长度的结果。（有关通用和适当前缀的定义，请参见&lt;a href=&quot;#mismatch(double%5B%5D,double%5B%5D)&quot;&gt; &lt;code&gt;mismatch(double[], double[])&lt;/code&gt; &lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="1c4f63f453b8509aa4d20ab07035dc58ee1cb446" translate="yes" xml:space="preserve">
          <source>If the two arrays share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by &lt;a href=&quot;../lang/float#compare(float,float)&quot;&gt;&lt;code&gt;Float.compare(float, float)&lt;/code&gt;&lt;/a&gt;, at an index within the respective arrays that is the prefix length. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two array lengths. (See &lt;a href=&quot;#mismatch(float%5B%5D,float%5B%5D)&quot;&gt;&lt;code&gt;mismatch(float[], float[])&lt;/code&gt;&lt;/a&gt; for the definition of a common and proper prefix.)</source>
          <target state="translated">如果两个数组共享一个公共前缀，那么字典比较是比较两个元素的结果，就像通过&lt;a href=&quot;../lang/float#compare(float,float)&quot;&gt; &lt;code&gt;Float.compare(float, float)&lt;/code&gt; &lt;/a&gt;，在相应数组中的索引处，即前缀长度。否则，一个数组是另一个数组的适当前缀，而字典比较是比较两个数组长度的结果。（有关通用和适当前缀的定义，请参见&lt;a href=&quot;#mismatch(float%5B%5D,float%5B%5D)&quot;&gt; &lt;code&gt;mismatch(float[], float[])&lt;/code&gt; &lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="3a6dc406fb7fd94c09e0c48b3ba97eeaadc82d2f" translate="yes" xml:space="preserve">
          <source>If the two arrays share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by &lt;a href=&quot;../lang/integer#compare(int,int)&quot;&gt;&lt;code&gt;Integer.compare(int, int)&lt;/code&gt;&lt;/a&gt;, at an index within the respective arrays that is the prefix length. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two array lengths. (See &lt;a href=&quot;#mismatch(int%5B%5D,int%5B%5D)&quot;&gt;&lt;code&gt;mismatch(int[], int[])&lt;/code&gt;&lt;/a&gt; for the definition of a common and proper prefix.)</source>
          <target state="translated">如果两个数组共享一个公共前缀，则字典比较是比较两个元素的结果，就像通过&lt;a href=&quot;../lang/integer#compare(int,int)&quot;&gt; &lt;code&gt;Integer.compare(int, int)&lt;/code&gt; &lt;/a&gt;在相应数组中的索引（即前缀长度）处进行比较一样。否则，一个数组是另一个数组的适当前缀，而字典比较是比较两个数组长度的结果。（有关通用和适当前缀的定义，请参见&lt;a href=&quot;#mismatch(int%5B%5D,int%5B%5D)&quot;&gt; &lt;code&gt;mismatch(int[], int[])&lt;/code&gt; &lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="f49296e451be67acc72ebac21d6d5d2ab335c399" translate="yes" xml:space="preserve">
          <source>If the two arrays share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by &lt;a href=&quot;../lang/integer#compareUnsigned(int,int)&quot;&gt;&lt;code&gt;Integer.compareUnsigned(int, int)&lt;/code&gt;&lt;/a&gt;, at an index within the respective arrays that is the prefix length. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two array lengths. (See &lt;a href=&quot;#mismatch(int%5B%5D,int%5B%5D)&quot;&gt;&lt;code&gt;mismatch(int[], int[])&lt;/code&gt;&lt;/a&gt; for the definition of a common and proper prefix.)</source>
          <target state="translated">如果两个数组共享一个公共前缀，则字典比较是比较两个元素的结果，就像&lt;a href=&quot;../lang/integer#compareUnsigned(int,int)&quot;&gt; &lt;code&gt;Integer.compareUnsigned(int, int)&lt;/code&gt; &lt;/a&gt;，在相应数组中的索引处（即前缀长度）进行比较。否则，一个数组是另一个数组的适当前缀，而字典比较是比较两个数组长度的结果。（有关通用和适当前缀的定义，请参见&lt;a href=&quot;#mismatch(int%5B%5D,int%5B%5D)&quot;&gt; &lt;code&gt;mismatch(int[], int[])&lt;/code&gt; &lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="b63db0f74eabd287280b9ce88e153dd64850efd0" translate="yes" xml:space="preserve">
          <source>If the two arrays share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by &lt;a href=&quot;../lang/long#compare(long,long)&quot;&gt;&lt;code&gt;Long.compare(long, long)&lt;/code&gt;&lt;/a&gt;, at an index within the respective arrays that is the prefix length. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two array lengths. (See &lt;a href=&quot;#mismatch(long%5B%5D,long%5B%5D)&quot;&gt;&lt;code&gt;mismatch(long[], long[])&lt;/code&gt;&lt;/a&gt; for the definition of a common and proper prefix.)</source>
          <target state="translated">如果两个数组共享一个共同的前缀，则字典比较是比较两个元素的结果，就像通过&lt;a href=&quot;../lang/long#compare(long,long)&quot;&gt; &lt;code&gt;Long.compare(long, long)&lt;/code&gt; &lt;/a&gt;，在相应数组中的索引（即前缀长度）处进行比较。否则，一个数组是另一个数组的适当前缀，而字典比较是比较两个数组长度的结果。（有关通用和适当前缀的定义，请参见&lt;a href=&quot;#mismatch(long%5B%5D,long%5B%5D)&quot;&gt; &lt;code&gt;mismatch(long[], long[])&lt;/code&gt; &lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="1bcb7cd8bec0f1fcffe21770a5583ac7e1aa23a1" translate="yes" xml:space="preserve">
          <source>If the two arrays share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by &lt;a href=&quot;../lang/long#compareUnsigned(long,long)&quot;&gt;&lt;code&gt;Long.compareUnsigned(long, long)&lt;/code&gt;&lt;/a&gt;, at an index within the respective arrays that is the prefix length. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two array lengths. (See &lt;a href=&quot;#mismatch(long%5B%5D,long%5B%5D)&quot;&gt;&lt;code&gt;mismatch(long[], long[])&lt;/code&gt;&lt;/a&gt; for the definition of a common and proper prefix.)</source>
          <target state="translated">如果两个数组共享一个公共前缀，则字典比较是比较两个元素的结果，就像通过&lt;a href=&quot;../lang/long#compareUnsigned(long,long)&quot;&gt; &lt;code&gt;Long.compareUnsigned(long, long)&lt;/code&gt; &lt;/a&gt;在相应数组中的索引（即前缀长度）处进行比较。否则，一个数组是另一个数组的适当前缀，而字典比较是比较两个数组长度的结果。（有关通用和适当前缀的定义，请参见&lt;a href=&quot;#mismatch(long%5B%5D,long%5B%5D)&quot;&gt; &lt;code&gt;mismatch(long[], long[])&lt;/code&gt; &lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="3d148b2dafd16e299cfcc608fd7bc9a2b486aed0" translate="yes" xml:space="preserve">
          <source>If the two arrays share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by &lt;a href=&quot;../lang/short#compare(short,short)&quot;&gt;&lt;code&gt;Short.compare(short, short)&lt;/code&gt;&lt;/a&gt;, at an index within the respective arrays that is the prefix length. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two array lengths. (See &lt;a href=&quot;#mismatch(short%5B%5D,short%5B%5D)&quot;&gt;&lt;code&gt;mismatch(short[], short[])&lt;/code&gt;&lt;/a&gt; for the definition of a common and proper prefix.)</source>
          <target state="translated">如果两个数组共享一个公共前缀，则字典比较是比较两个元素的结果，就像通过&lt;a href=&quot;../lang/short#compare(short,short)&quot;&gt; &lt;code&gt;Short.compare(short, short)&lt;/code&gt; &lt;/a&gt;，在相应数组中的索引（即前缀长度）处进行比较。否则，一个数组是另一个数组的适当前缀，而字典比较是比较两个数组长度的结果。（有关通用和适当前缀的定义，请参见&lt;a href=&quot;#mismatch(short%5B%5D,short%5B%5D)&quot;&gt; &lt;code&gt;mismatch(short[], short[])&lt;/code&gt; &lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="10bcf2ff1ce53653290b9af98721a6b69481041d" translate="yes" xml:space="preserve">
          <source>If the two arrays share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by &lt;a href=&quot;../lang/short#compareUnsigned(short,short)&quot;&gt;&lt;code&gt;Short.compareUnsigned(short, short)&lt;/code&gt;&lt;/a&gt;, at an index within the respective arrays that is the prefix length. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two array lengths. (See &lt;a href=&quot;#mismatch(short%5B%5D,short%5B%5D)&quot;&gt;&lt;code&gt;mismatch(short[], short[])&lt;/code&gt;&lt;/a&gt; for the definition of a common and proper prefix.)</source>
          <target state="translated">如果两个数组共享一个公共前缀，则字典比较是比较两个元素的结果，就像通过&lt;a href=&quot;../lang/short#compareUnsigned(short,short)&quot;&gt; &lt;code&gt;Short.compareUnsigned(short, short)&lt;/code&gt; &lt;/a&gt;在相应数组中的索引（即前缀长度）处进行比较。否则，一个数组是另一个数组的适当前缀，而字典比较是比较两个数组长度的结果。（有关通用和适当前缀的定义，请参见&lt;a href=&quot;#mismatch(short%5B%5D,short%5B%5D)&quot;&gt; &lt;code&gt;mismatch(short[], short[])&lt;/code&gt; &lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="9b48c79397e666c5c9e58c00b0300c3f32625780" translate="yes" xml:space="preserve">
          <source>If the two arrays share a common prefix then the lexicographic comparison is the result of comparing with the specified comparator two elements at an index within the respective arrays that is the prefix length. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two array lengths. (See &lt;a href=&quot;#mismatch(java.lang.Object%5B%5D,java.lang.Object%5B%5D)&quot;&gt;&lt;code&gt;mismatch(Object[], Object[])&lt;/code&gt;&lt;/a&gt; for the definition of a common and proper prefix.)</source>
          <target state="translated">如果两个数组共享一个公共前缀，则字典比较是与指定的比较器比较两个数组在各自数组的索引处（即前缀长度）进行比较的结果。否则，一个数组是另一个数组的适当前缀，而字典比较是比较两个数组长度的结果。（有关通用和适当前缀的定义，请参见&lt;a href=&quot;#mismatch(java.lang.Object%5B%5D,java.lang.Object%5B%5D)&quot;&gt; &lt;code&gt;mismatch(Object[], Object[])&lt;/code&gt; &lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="751f847fc7eff31ed05d5e61dc95a845161d2ad3" translate="yes" xml:space="preserve">
          <source>If the two arrays share a common prefix then the returned index is the length of the common prefix and it follows that there is a mismatch between the two elements at that index within the respective arrays. If one array is a proper prefix of the other then the returned index is the length of the smaller array and it follows that the index is only valid for the larger array. Otherwise, there is no mismatch.</source>
          <target state="translated">如果两个数组有一个共同的前缀,那么返回的索引就是共同前缀的长度,由此可见,在各自数组中,该索引处的两个元素是不匹配的。如果一个数组是另一个数组的前缀,那么返回的索引是较小数组的长度,由此可见,该索引只对较大数组有效。否则,就不存在不匹配。</target>
        </trans-unit>
        <trans-unit id="6e2839946586ddeda4b1002deade56dce2c14f22" translate="yes" xml:space="preserve">
          <source>If the two arrays, over the specified ranges, share a common prefix then the lexicographic comparison is the result of comparing two elements of type &lt;code&gt;T&lt;/code&gt; at a relative index &lt;code&gt;i&lt;/code&gt; within the respective arrays that is the prefix length, as if by:</source>
          <target state="translated">如果两个数组在指定范围内共享一个公共前缀，那么字典比较是比较两个类型 &lt;code&gt;T&lt;/code&gt; 的元素在相应数组中的相对索引 &lt;code&gt;i&lt;/code&gt; （即前缀长度）进行比较的结果，就像这样：</target>
        </trans-unit>
        <trans-unit id="f3f948cd0dc8d1832d6c7cda8991ab71dcb99b17" translate="yes" xml:space="preserve">
          <source>If the two arrays, over the specified ranges, share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by &lt;a href=&quot;../lang/boolean#compare(boolean,boolean)&quot;&gt;&lt;code&gt;Boolean.compare(boolean, boolean)&lt;/code&gt;&lt;/a&gt;, at a relative index within the respective arrays that is the length of the prefix. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two range lengths. (See &lt;a href=&quot;#mismatch(boolean%5B%5D,int,int,boolean%5B%5D,int,int)&quot;&gt;&lt;code&gt;mismatch(boolean[], int, int, boolean[], int, int)&lt;/code&gt;&lt;/a&gt; for the definition of a common and proper prefix.)</source>
          <target state="translated">如果两个数组在指定范围内共享一个公共前缀，则字典比较是比较两个元素的结果，就像通过&lt;a href=&quot;../lang/boolean#compare(boolean,boolean)&quot;&gt; &lt;code&gt;Boolean.compare(boolean, boolean)&lt;/code&gt; &lt;/a&gt;，在相应数组中的相对索引处，即长度前缀的。否则，一个数组是另一个数组的适当前缀，而字典比较是比较两个范围长度的结果。（有关通用和适当前缀的定义，请参见&lt;a href=&quot;#mismatch(boolean%5B%5D,int,int,boolean%5B%5D,int,int)&quot;&gt; &lt;code&gt;mismatch(boolean[], int, int, boolean[], int, int)&lt;/code&gt; &lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="a6e94f75faa2282739b4f3b904d2d252589549dd" translate="yes" xml:space="preserve">
          <source>If the two arrays, over the specified ranges, share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by &lt;a href=&quot;../lang/byte#compare(byte,byte)&quot;&gt;&lt;code&gt;Byte.compare(byte, byte)&lt;/code&gt;&lt;/a&gt;, at a relative index within the respective arrays that is the length of the prefix. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two range lengths. (See &lt;a href=&quot;#mismatch(byte%5B%5D,int,int,byte%5B%5D,int,int)&quot;&gt;&lt;code&gt;mismatch(byte[], int, int, byte[], int, int)&lt;/code&gt;&lt;/a&gt; for the definition of a common and proper prefix.)</source>
          <target state="translated">如果两个数组在指定范围内共享一个公共前缀，则字典比较是比较两个元素的结果，就像通过&lt;a href=&quot;../lang/byte#compare(byte,byte)&quot;&gt; &lt;code&gt;Byte.compare(byte, byte)&lt;/code&gt; &lt;/a&gt;在相应数组中的相对索引处（即长度）进行比较前缀的。否则，一个数组是另一个数组的适当前缀，而字典比较是比较两个范围长度的结果。（有关常见和适当前缀的定义，请参见&lt;a href=&quot;#mismatch(byte%5B%5D,int,int,byte%5B%5D,int,int)&quot;&gt; &lt;code&gt;mismatch(byte[], int, int, byte[], int, int)&lt;/code&gt; &lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="d99ad3f23655df7e4fbd277c7e8afb3093422df6" translate="yes" xml:space="preserve">
          <source>If the two arrays, over the specified ranges, share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by &lt;a href=&quot;../lang/byte#compareUnsigned(byte,byte)&quot;&gt;&lt;code&gt;Byte.compareUnsigned(byte, byte)&lt;/code&gt;&lt;/a&gt;, at a relative index within the respective arrays that is the length of the prefix. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two range lengths. (See &lt;a href=&quot;#mismatch(byte%5B%5D,int,int,byte%5B%5D,int,int)&quot;&gt;&lt;code&gt;mismatch(byte[], int, int, byte[], int, int)&lt;/code&gt;&lt;/a&gt; for the definition of a common and proper prefix.)</source>
          <target state="translated">如果两个数组在指定范围内共享一个公共前缀，则字典比较是比较两个元素的结果，就像通过&lt;a href=&quot;../lang/byte#compareUnsigned(byte,byte)&quot;&gt; &lt;code&gt;Byte.compareUnsigned(byte, byte)&lt;/code&gt; &lt;/a&gt;在相应数组中的相对索引处（即长度）进行比较前缀的。否则，一个数组是另一个数组的适当前缀，而字典比较是比较两个范围长度的结果。（有关常见和适当前缀的定义，请参见&lt;a href=&quot;#mismatch(byte%5B%5D,int,int,byte%5B%5D,int,int)&quot;&gt; &lt;code&gt;mismatch(byte[], int, int, byte[], int, int)&lt;/code&gt; &lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="689546c82dfde445df7cb6060f65882dc0abca33" translate="yes" xml:space="preserve">
          <source>If the two arrays, over the specified ranges, share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by &lt;a href=&quot;../lang/character#compare(char,char)&quot;&gt;&lt;code&gt;Character.compare(char, char)&lt;/code&gt;&lt;/a&gt;, at a relative index within the respective arrays that is the length of the prefix. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two range lengths. (See &lt;a href=&quot;#mismatch(char%5B%5D,int,int,char%5B%5D,int,int)&quot;&gt;&lt;code&gt;mismatch(char[], int, int, char[], int, int)&lt;/code&gt;&lt;/a&gt; for the definition of a common and proper prefix.)</source>
          <target state="translated">如果两个数组在指定范围内共享一个公共前缀，则字典比较是比较两个元素的结果，就像通过&lt;a href=&quot;../lang/character#compare(char,char)&quot;&gt; &lt;code&gt;Character.compare(char, char)&lt;/code&gt; &lt;/a&gt;，在相应数组中的相对索引处，即长度前缀的。否则，一个数组是另一个数组的适当前缀，而字典比较是比较两个范围长度的结果。（有关常见和适当前缀的定义，请参见&lt;a href=&quot;#mismatch(char%5B%5D,int,int,char%5B%5D,int,int)&quot;&gt; &lt;code&gt;mismatch(char[], int, int, char[], int, int)&lt;/code&gt; &lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="33f0cf3594f25f4cb36a42269d56adb60385fdc6" translate="yes" xml:space="preserve">
          <source>If the two arrays, over the specified ranges, share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by &lt;a href=&quot;../lang/double#compare(double,double)&quot;&gt;&lt;code&gt;Double.compare(double, double)&lt;/code&gt;&lt;/a&gt;, at a relative index within the respective arrays that is the length of the prefix. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two range lengths. (See &lt;a href=&quot;#mismatch(double%5B%5D,int,int,double%5B%5D,int,int)&quot;&gt;&lt;code&gt;mismatch(double[], int, int, double[], int, int)&lt;/code&gt;&lt;/a&gt; for the definition of a common and proper prefix.)</source>
          <target state="translated">如果两个数组在指定范围内共享一个公共前缀，则字典比较是比较两个元素的结果，就像通过&lt;a href=&quot;../lang/double#compare(double,double)&quot;&gt; &lt;code&gt;Double.compare(double, double)&lt;/code&gt; &lt;/a&gt;在相应数组中的相对索引处进行比较，该长度为length前缀的。否则，一个数组是另一个数组的适当前缀，而字典比较是比较两个范围长度的结果。（有关通用和适当前缀的定义，请参见&lt;a href=&quot;#mismatch(double%5B%5D,int,int,double%5B%5D,int,int)&quot;&gt; &lt;code&gt;mismatch(double[], int, int, double[], int, int)&lt;/code&gt; &lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="96dc20aff5dbee21053cf86a2f97932e6e113e17" translate="yes" xml:space="preserve">
          <source>If the two arrays, over the specified ranges, share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by &lt;a href=&quot;../lang/float#compare(float,float)&quot;&gt;&lt;code&gt;Float.compare(float, float)&lt;/code&gt;&lt;/a&gt;, at a relative index within the respective arrays that is the length of the prefix. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two range lengths. (See &lt;a href=&quot;#mismatch(float%5B%5D,int,int,float%5B%5D,int,int)&quot;&gt;&lt;code&gt;mismatch(float[], int, int, float[], int, int)&lt;/code&gt;&lt;/a&gt; for the definition of a common and proper prefix.)</source>
          <target state="translated">如果两个数组在指定范围内共享一个公共前缀，则字典比较是比较两个元素的结果，就像通过&lt;a href=&quot;../lang/float#compare(float,float)&quot;&gt; &lt;code&gt;Float.compare(float, float)&lt;/code&gt; &lt;/a&gt;，在相应数组中的相对索引处，即长度前缀的。否则，一个数组是另一个数组的适当前缀，而字典比较是比较两个范围长度的结果。（有关常见且适当的前缀的定义，请参见&lt;a href=&quot;#mismatch(float%5B%5D,int,int,float%5B%5D,int,int)&quot;&gt; &lt;code&gt;mismatch(float[], int, int, float[], int, int)&lt;/code&gt; &lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="efb772271b892ca76f0e7c60394b0c3288a55976" translate="yes" xml:space="preserve">
          <source>If the two arrays, over the specified ranges, share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by &lt;a href=&quot;../lang/integer#compare(int,int)&quot;&gt;&lt;code&gt;Integer.compare(int, int)&lt;/code&gt;&lt;/a&gt;, at a relative index within the respective arrays that is the length of the prefix. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two range lengths. (See &lt;a href=&quot;#mismatch(int%5B%5D,int,int,int%5B%5D,int,int)&quot;&gt;&lt;code&gt;mismatch(int[], int, int, int[], int, int)&lt;/code&gt;&lt;/a&gt; for the definition of a common and proper prefix.)</source>
          <target state="translated">如果两个数组在指定范围内共享一个公共前缀，则字典比较是比较两个元素的结果，就像通过&lt;a href=&quot;../lang/integer#compare(int,int)&quot;&gt; &lt;code&gt;Integer.compare(int, int)&lt;/code&gt; &lt;/a&gt;，在相应数组中的相对索引处，即长度前缀的。否则，一个数组是另一个数组的适当前缀，而字典比较是比较两个范围长度的结果。（有关通用和适当前缀的定义，请参见&lt;a href=&quot;#mismatch(int%5B%5D,int,int,int%5B%5D,int,int)&quot;&gt; &lt;code&gt;mismatch(int[], int, int, int[], int, int)&lt;/code&gt; &lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="fc1abfae5f6bec827afbe78092dd5076cbb73043" translate="yes" xml:space="preserve">
          <source>If the two arrays, over the specified ranges, share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by &lt;a href=&quot;../lang/integer#compareUnsigned(int,int)&quot;&gt;&lt;code&gt;Integer.compareUnsigned(int, int)&lt;/code&gt;&lt;/a&gt;, at a relative index within the respective arrays that is the length of the prefix. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two range lengths. (See &lt;a href=&quot;#mismatch(int%5B%5D,int,int,int%5B%5D,int,int)&quot;&gt;&lt;code&gt;mismatch(int[], int, int, int[], int, int)&lt;/code&gt;&lt;/a&gt; for the definition of a common and proper prefix.)</source>
          <target state="translated">如果两个数组在指定范围内共享一个公共前缀，则字典比较是比较两个元素的结果，就像通过&lt;a href=&quot;../lang/integer#compareUnsigned(int,int)&quot;&gt; &lt;code&gt;Integer.compareUnsigned(int, int)&lt;/code&gt; &lt;/a&gt;，在相应数组中的相对索引处，即长度前缀的。否则，一个数组是另一个数组的适当前缀，而字典比较是比较两个范围长度的结果。（有关通用和适当前缀的定义，请参见&lt;a href=&quot;#mismatch(int%5B%5D,int,int,int%5B%5D,int,int)&quot;&gt; &lt;code&gt;mismatch(int[], int, int, int[], int, int)&lt;/code&gt; &lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="3f390c1a0173f067f002963d99ec1e933697624f" translate="yes" xml:space="preserve">
          <source>If the two arrays, over the specified ranges, share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by &lt;a href=&quot;../lang/long#compare(long,long)&quot;&gt;&lt;code&gt;Long.compare(long, long)&lt;/code&gt;&lt;/a&gt;, at a relative index within the respective arrays that is the length of the prefix. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two range lengths. (See &lt;a href=&quot;#mismatch(long%5B%5D,int,int,long%5B%5D,int,int)&quot;&gt;&lt;code&gt;mismatch(long[], int, int, long[], int, int)&lt;/code&gt;&lt;/a&gt; for the definition of a common and proper prefix.)</source>
          <target state="translated">如果两个数组在指定范围内共享一个公共前缀，则字典比较是比较两个元素的结果，就像通过&lt;a href=&quot;../lang/long#compare(long,long)&quot;&gt; &lt;code&gt;Long.compare(long, long)&lt;/code&gt; &lt;/a&gt;，在相应数组中的相对索引处即长度前缀的。否则，一个数组是另一个数组的适当前缀，而字典比较是比较两个范围长度的结果。（有关常见且适当的前缀的定义，请参见&lt;a href=&quot;#mismatch(long%5B%5D,int,int,long%5B%5D,int,int)&quot;&gt; &lt;code&gt;mismatch(long[], int, int, long[], int, int)&lt;/code&gt; &lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="acdbd4d409077318826faeff1066f127d79d2e03" translate="yes" xml:space="preserve">
          <source>If the two arrays, over the specified ranges, share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by &lt;a href=&quot;../lang/long#compareUnsigned(long,long)&quot;&gt;&lt;code&gt;Long.compareUnsigned(long, long)&lt;/code&gt;&lt;/a&gt;, at a relative index within the respective arrays that is the length of the prefix. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two range lengths. (See &lt;a href=&quot;#mismatch(long%5B%5D,int,int,long%5B%5D,int,int)&quot;&gt;&lt;code&gt;mismatch(long[], int, int, long[], int, int)&lt;/code&gt;&lt;/a&gt; for the definition of a common and proper prefix.)</source>
          <target state="translated">如果两个数组在指定范围内共享一个公共前缀，则字典比较是比较两个元素的结果，就像通过&lt;a href=&quot;../lang/long#compareUnsigned(long,long)&quot;&gt; &lt;code&gt;Long.compareUnsigned(long, long)&lt;/code&gt; &lt;/a&gt;在相应数组内的相对索引处进行比较，该长度为length前缀的。否则，一个数组是另一个数组的适当前缀，而字典比较是比较两个范围长度的结果。（有关常见且适当的前缀的定义，请参见&lt;a href=&quot;#mismatch(long%5B%5D,int,int,long%5B%5D,int,int)&quot;&gt; &lt;code&gt;mismatch(long[], int, int, long[], int, int)&lt;/code&gt; &lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="165852849eadb60efdc65ee7e29e23a132211a7c" translate="yes" xml:space="preserve">
          <source>If the two arrays, over the specified ranges, share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by &lt;a href=&quot;../lang/short#compare(short,short)&quot;&gt;&lt;code&gt;Short.compare(short, short)&lt;/code&gt;&lt;/a&gt;, at a relative index within the respective arrays that is the length of the prefix. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two range lengths. (See &lt;a href=&quot;#mismatch(short%5B%5D,int,int,short%5B%5D,int,int)&quot;&gt;&lt;code&gt;mismatch(short[], int, int, short[], int, int)&lt;/code&gt;&lt;/a&gt; for the definition of a common and proper prefix.)</source>
          <target state="translated">如果两个数组在指定范围内共享一个公共前缀，则字典比较是比较两个元素的结果，就像通过&lt;a href=&quot;../lang/short#compare(short,short)&quot;&gt; &lt;code&gt;Short.compare(short, short)&lt;/code&gt; &lt;/a&gt;在相应数组中的相对索引处进行比较，该长度为length前缀的。否则，一个数组是另一个数组的适当前缀，而字典比较是比较两个范围长度的结果。（有关通用和适当前缀的定义，请参见&lt;a href=&quot;#mismatch(short%5B%5D,int,int,short%5B%5D,int,int)&quot;&gt; &lt;code&gt;mismatch(short[], int, int, short[], int, int)&lt;/code&gt; &lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="92a13ef6017334f61c5516d921592620158e34a6" translate="yes" xml:space="preserve">
          <source>If the two arrays, over the specified ranges, share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by &lt;a href=&quot;../lang/short#compareUnsigned(short,short)&quot;&gt;&lt;code&gt;Short.compareUnsigned(short, short)&lt;/code&gt;&lt;/a&gt;, at a relative index within the respective arrays that is the length of the prefix. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two range lengths. (See &lt;a href=&quot;#mismatch(short%5B%5D,int,int,short%5B%5D,int,int)&quot;&gt;&lt;code&gt;mismatch(short[], int, int, short[], int, int)&lt;/code&gt;&lt;/a&gt; for the definition of a common and proper prefix.)</source>
          <target state="translated">如果两个数组在指定范围内共享一个公共前缀，则字典比较是比较两个元素的结果，就像通过&lt;a href=&quot;../lang/short#compareUnsigned(short,short)&quot;&gt; &lt;code&gt;Short.compareUnsigned(short, short)&lt;/code&gt; &lt;/a&gt;在相应数组中的相对索引处（即长度）进行比较前缀的。否则，一个数组是另一个数组的适当前缀，而字典比较是比较两个范围长度的结果。（有关常见和适当前缀的定义，请参见&lt;a href=&quot;#mismatch(short%5B%5D,int,int,short%5B%5D,int,int)&quot;&gt; &lt;code&gt;mismatch(short[], int, int, short[], int, int)&lt;/code&gt; &lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="0adc08ed767ba5fcac736354cc12489898dcbc7c" translate="yes" xml:space="preserve">
          <source>If the two arrays, over the specified ranges, share a common prefix then the lexicographic comparison is the result of comparing with the specified comparator two elements at a relative index within the respective arrays that is the prefix length. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two range lengths. (See &lt;a href=&quot;#mismatch(java.lang.Object%5B%5D,int,int,java.lang.Object%5B%5D,int,int)&quot;&gt;&lt;code&gt;mismatch(Object[], int, int, Object[], int, int)&lt;/code&gt;&lt;/a&gt; for the definition of a common and proper prefix.)</source>
          <target state="translated">如果两个数组在指定范围内共享一个公共前缀，则字典比较是与指定比较器比较两个数组在相对数组中的相对索引（即前缀长度）的结果。否则，一个数组是另一个数组的适当前缀，而字典比较是比较两个范围长度的结果。（有关通用和适当前缀的定义，请参见&lt;a href=&quot;#mismatch(java.lang.Object%5B%5D,int,int,java.lang.Object%5B%5D,int,int)&quot;&gt; &lt;code&gt;mismatch(Object[], int, int, Object[], int, int)&lt;/code&gt; &lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="de179b6b61556777afe0f0139dc8277c77218327" translate="yes" xml:space="preserve">
          <source>If the two arrays, over the specified ranges, share a common prefix then the returned relative index is the length of the common prefix and it follows that there is a mismatch between the two elements at that relative index within the respective arrays. If one array is a proper prefix of the other, over the specified ranges, then the returned relative index is the length of the smaller range and it follows that the relative index is only valid for the array with the larger range. Otherwise, there is no mismatch.</source>
          <target state="translated">如果两个数组,在指定的范围内,共享一个共同的前缀,那么返回的相对索引是共同前缀的长度,由此可见,在各自数组内的相对索引处有两个元素不匹配。如果一个数组是另一个数组的合适前缀,在指定的范围内,那么返回的相对索引是较小范围的长度,由此可见,相对索引只对范围较大的数组有效。否则,不存在不匹配。</target>
        </trans-unit>
        <trans-unit id="3ff68f92a851855ba68fbc7ed3f7e692a3962b65" translate="yes" xml:space="preserve">
          <source>If the two buffers share a common prefix then the returned index is the length of the common prefix and it follows that there is a mismatch between the two buffers at that index within the respective buffers. If one buffer is a proper prefix of the other then the returned index is the smaller of the remaining elements in each buffer, and it follows that the index is only valid for the buffer with the larger number of remaining elements. Otherwise, there is no mismatch.</source>
          <target state="translated">如果两个缓冲区共享一个共同的前缀,那么返回的索引就是共同前缀的长度,由此可见,两个缓冲区在各自缓冲区内的该索引处是不匹配的。如果一个缓冲区是另一个缓冲区的合适前缀,那么返回的索引是每个缓冲区中剩余元素中较小的一个,由此可见,该索引只对剩余元素较多的缓冲区有效。否则,不存在不匹配。</target>
        </trans-unit>
        <trans-unit id="051c9daf6b939af50cb443665c610f27abeb1722" translate="yes" xml:space="preserve">
          <source>If the two interfaces are mixed (including serialization), Unicode range values are mapped to their counterparts where such mapping is possible, such as &lt;code&gt;NumericShaper.Range.ARABIC&lt;/code&gt; from/to &lt;code&gt;NumericShaper.ARABIC&lt;/code&gt;. If any unmappable range values are specified, such as &lt;code&gt;NumericShaper.Range.BALINESE&lt;/code&gt;, those ranges are ignored.</source>
          <target state="translated">如果两个接口被混合（包括序列），Unicode的范围值被映射到它们的对应，其中这样的映射是可能的，诸如 &lt;code&gt;NumericShaper.Range.ARABIC&lt;/code&gt; 从/到 &lt;code&gt;NumericShaper.ARABIC&lt;/code&gt; 。如果指定了任何不可映射的范围值，例如 &lt;code&gt;NumericShaper.Range.BALINESE&lt;/code&gt; ，那么将忽略这些范围。</target>
        </trans-unit>
        <trans-unit id="b2f14e6b9879b33cc948a3f23d891c8c9a5dfd45" translate="yes" xml:space="preserve">
          <source>If the two segments share a common prefix then the returned offset is the length of the common prefix and it follows that there is a mismatch between the two segments at that offset within the respective segments. If one segment is a proper prefix of the other then the returned offset is the smaller of the segment sizes, and it follows that the offset is only valid for the larger segment. Otherwise, there is no mismatch and &lt;code&gt;
 -1&lt;/code&gt; is returned.</source>
          <target state="translated">如果两个段共享一个公共前缀，则返回的偏移量是公共前缀的长度，因此，在两个段之间，在各个段中的那个偏移量处存在不匹配。如果一个段是另一段的适当前缀，则返回的偏移量是段大小中较小的，因此，该偏移仅对较大的段有效。否则，不存在不匹配，并返回 &lt;code&gt; -1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cac1823b4d109a58d8c15953a4c53e9282211329" translate="yes" xml:space="preserve">
          <source>If the type is &lt;code&gt;null&lt;/code&gt;, a shared internal persistence delegate is returned that encodes &lt;code&gt;null&lt;/code&gt; value.</source>
          <target state="translated">如果type为 &lt;code&gt;null&lt;/code&gt; ，则返回一个共享的内部持久性委托，该委托对 &lt;code&gt;null&lt;/code&gt; 值进行编码。</target>
        </trans-unit>
        <trans-unit id="24624d93ce0bd52bd62b61c2d340c4e06907a0dd" translate="yes" xml:space="preserve">
          <source>If the type is a &lt;code&gt;enum&lt;/code&gt; declaration, a shared internal persistence delegate is returned that encodes constants of this enumeration by their names.</source>
          <target state="translated">如果类型是 &lt;code&gt;enum&lt;/code&gt; 声明，则返回一个共享的内部持久性委托，该委托通过其名称对该枚举常量进行编码。</target>
        </trans-unit>
        <trans-unit id="17c7dfdd306d9dca345cd59fbb286fb56494c02b" translate="yes" xml:space="preserve">
          <source>If the type is a primitive type or the corresponding wrapper, a shared internal persistence delegate is returned that encodes values of the given type.</source>
          <target state="translated">如果类型是基元类型或相应的包装器,则返回一个共享的内部持久化委托,对给定类型的值进行编码。</target>
        </trans-unit>
        <trans-unit id="e83ddcadc497b3ac8c423eb1d1497d6d589d42af" translate="yes" xml:space="preserve">
          <source>If the type is a proxy, a shared internal persistence delegate is returned that encodes a proxy instance by using the &lt;a href=&quot;../../../java.base/java/lang/reflect/proxy#newProxyInstance(java.lang.ClassLoader,java.lang.Class%5B%5D,java.lang.reflect.InvocationHandler)&quot;&gt;&lt;code&gt;Proxy.newProxyInstance(java.lang.ClassLoader, java.lang.Class&amp;lt;?&amp;gt;[], java.lang.reflect.InvocationHandler)&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">如果类型是代理，则返回一个共享的内部持久性委托，该委托使用&lt;a href=&quot;../../../java.base/java/lang/reflect/proxy#newProxyInstance(java.lang.ClassLoader,java.lang.Class%5B%5D,java.lang.reflect.InvocationHandler)&quot;&gt; &lt;code&gt;Proxy.newProxyInstance(java.lang.ClassLoader, java.lang.Class&amp;lt;?&amp;gt;[], java.lang.reflect.InvocationHandler)&lt;/code&gt; &lt;/a&gt;对代理实例进行编码）方法。</target>
        </trans-unit>
        <trans-unit id="7266e7d4fe52b4f4bd2947e2022cc33489854699" translate="yes" xml:space="preserve">
          <source>If the type is a proxy, a shared internal persistence delegate is returned that encodes a proxy instance by using the &lt;a href=&quot;../lang/reflect/proxy#newProxyInstance-java.lang.ClassLoader-java.lang.Class:A-java.lang.reflect.InvocationHandler-&quot;&gt;&lt;code&gt;Proxy.newProxyInstance(java.lang.ClassLoader, java.lang.Class&amp;lt;?&amp;gt;[], java.lang.reflect.InvocationHandler)&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">如果类型是代理，则返回一个共享内部持久性委托，该委托使用&lt;a href=&quot;../lang/reflect/proxy#newProxyInstance-java.lang.ClassLoader-java.lang.Class:A-java.lang.reflect.InvocationHandler-&quot;&gt; &lt;code&gt;Proxy.newProxyInstance(java.lang.ClassLoader, java.lang.Class&amp;lt;?&amp;gt;[], java.lang.reflect.InvocationHandler)&lt;/code&gt; &lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="7d57cd67c4f9b115595d9ab402c68b98705b5fc3" translate="yes" xml:space="preserve">
          <source>If the type is an &lt;code&gt;enum&lt;/code&gt; declaration, a shared internal persistence delegate is returned that encodes constants of this enumeration by their names.</source>
          <target state="translated">如果类型是 &lt;code&gt;enum&lt;/code&gt; 声明，则返回一个共享的内部持久性委托，该委托通过其名称对该枚举常量进行编码。</target>
        </trans-unit>
        <trans-unit id="6d791c963ef8e6e2b0fde7ef89bca6d1754b00b4" translate="yes" xml:space="preserve">
          <source>If the type is an array, a shared internal persistence delegate is returned that encodes an array of the appropriate type and length, and each of its elements as if they are properties.</source>
          <target state="translated">如果类型是一个数组,则返回一个共享的内部持久化委托,该委托对适当类型和长度的数组以及它的每个元素进行编码,好像它们是属性一样。</target>
        </trans-unit>
        <trans-unit id="0b2e4d1a1790e1526fd1d7230bad3ff1e34601cd" translate="yes" xml:space="preserve">
          <source>If the type of an object is incompatible with the expected type of the parameter associated to the object.</source>
          <target state="translated">如果一个对象的类型与该对象相关联的参数的预期类型不一致。</target>
        </trans-unit>
        <trans-unit id="99f690abde7ac9507cafcabd4eb11b9f675436cc" translate="yes" xml:space="preserve">
          <source>If the type of the underlying field is a type variable or a parameterized type, it is created. Otherwise, it is resolved.</source>
          <target state="translated">如果底层字段的类型是类型变量或参数化类型,则创建它。否则,它将被解析。</target>
        </trans-unit>
        <trans-unit id="bba92f2510991dff47988d4605e2d098cf44722d" translate="yes" xml:space="preserve">
          <source>If the type of the underlying record component is a type variable or a parameterized type, it is created. Otherwise, it is resolved.</source>
          <target state="translated">如果底层记录组件的类型是类型变量或参数化类型,则创建该类型。否则,它将被解析。</target>
        </trans-unit>
        <trans-unit id="595e9b134500ae042fb86dbdf0154307a723dc06" translate="yes" xml:space="preserve">
          <source>If the underlying class is an array class, then its &lt;code&gt;public&lt;/code&gt;, &lt;code&gt;private&lt;/code&gt; and &lt;code&gt;protected&lt;/code&gt; modifiers are the same as those of its component type. If this &lt;code&gt;Class&lt;/code&gt; object represents a primitive type or void, its &lt;code&gt;public&lt;/code&gt; modifier is always &lt;code&gt;true&lt;/code&gt;, and its &lt;code&gt;protected&lt;/code&gt; and &lt;code&gt;private&lt;/code&gt; modifiers are always &lt;code&gt;false&lt;/code&gt;. If this &lt;code&gt;Class&lt;/code&gt; object represents an array class, a primitive type or void, then its &lt;code&gt;final&lt;/code&gt; modifier is always &lt;code&gt;true&lt;/code&gt; and its interface modifier is always &lt;code&gt;false&lt;/code&gt;. The values of its other modifiers are not determined by this specification.</source>
          <target state="translated">如果基础类是数组类，则其 &lt;code&gt;public&lt;/code&gt; ， &lt;code&gt;private&lt;/code&gt; 和 &lt;code&gt;protected&lt;/code&gt; 修饰符与其组件类型的修饰符相同。如果此 &lt;code&gt;Class&lt;/code&gt; 对象表示原始类型或void，则其 &lt;code&gt;public&lt;/code&gt; 修饰符始终为 &lt;code&gt;true&lt;/code&gt; ，而其 &lt;code&gt;protected&lt;/code&gt; 和 &lt;code&gt;private&lt;/code&gt; 修饰符始终为 &lt;code&gt;false&lt;/code&gt; 。如果此 &lt;code&gt;Class&lt;/code&gt; 对象表示数组类，原始类型或void，则其 &lt;code&gt;final&lt;/code&gt; 修饰符始终为 &lt;code&gt;true&lt;/code&gt; ，其interface修饰符始终为 &lt;code&gt;false&lt;/code&gt; 。其其他修饰符的值不由本规范确定。</target>
        </trans-unit>
        <trans-unit id="66b62dfc82fc14777b26e50687d5b79596a57206" translate="yes" xml:space="preserve">
          <source>If the underlying class is an array class, then its &lt;code&gt;public&lt;/code&gt;, &lt;code&gt;private&lt;/code&gt; and &lt;code&gt;protected&lt;/code&gt; modifiers are the same as those of its component type. If this &lt;code&gt;Class&lt;/code&gt; represents a primitive type or void, its &lt;code&gt;public&lt;/code&gt; modifier is always &lt;code&gt;true&lt;/code&gt;, and its &lt;code&gt;protected&lt;/code&gt; and &lt;code&gt;private&lt;/code&gt; modifiers are always &lt;code&gt;false&lt;/code&gt;. If this object represents an array class, a primitive type or void, then its &lt;code&gt;final&lt;/code&gt; modifier is always &lt;code&gt;true&lt;/code&gt; and its interface modifier is always &lt;code&gt;false&lt;/code&gt;. The values of its other modifiers are not determined by this specification.</source>
          <target state="translated">如果基础类是数组类，则其 &lt;code&gt;public&lt;/code&gt; ， &lt;code&gt;private&lt;/code&gt; 和 &lt;code&gt;protected&lt;/code&gt; 修饰符与其组件类型的修饰符相同。如果这个 &lt;code&gt;Class&lt;/code&gt; 表示一个基本类型或无效，其 &lt;code&gt;public&lt;/code&gt; 修饰符始终是 &lt;code&gt;true&lt;/code&gt; ，它的 &lt;code&gt;protected&lt;/code&gt; 和 &lt;code&gt;private&lt;/code&gt; 修饰符始终是 &lt;code&gt;false&lt;/code&gt; 。如果此对象表示数组类，原始类型或void，则其 &lt;code&gt;final&lt;/code&gt; 修饰符始终为 &lt;code&gt;true&lt;/code&gt; ，其接口修饰符始终为 &lt;code&gt;false&lt;/code&gt; 。其其他修饰符的值不由本规范确定。</target>
        </trans-unit>
        <trans-unit id="b6635d2c90407f220bf7ecba5d59930986096dac" translate="yes" xml:space="preserve">
          <source>If the underlying field is a static field, the &lt;code&gt;obj&lt;/code&gt; argument is ignored; it may be null.</source>
          <target state="translated">如果基础字段是静态字段，则 &lt;code&gt;obj&lt;/code&gt; 参数将被忽略；它可以为空。</target>
        </trans-unit>
        <trans-unit id="61e60b6593bad05aa260e774035853633abadd33" translate="yes" xml:space="preserve">
          <source>If the underlying field is final, the method throws an &lt;code&gt;IllegalAccessException&lt;/code&gt; unless &lt;code&gt;setAccessible(true)&lt;/code&gt; has succeeded for this &lt;code&gt;Field&lt;/code&gt; object and the field is non-static. Setting a final field in this way is meaningful only during deserialization or reconstruction of instances of classes with blank final fields, before they are made available for access by other parts of a program. Use in any other context may have unpredictable effects, including cases in which other parts of a program continue to use the original value of this field.</source>
          <target state="translated">如果基础字段是最终字段，则该方法将抛出 &lt;code&gt;IllegalAccessException&lt;/code&gt; ,除非对此 &lt;code&gt;Field&lt;/code&gt; 对象成功执行 &lt;code&gt;setAccessible(true)&lt;/code&gt; 且该字段是非静态的。以这种方式设置最终字段仅在反序列化或重构具有空白最终字段的类的实例时才有意义，然后才可以将它们用于程序的其他部分。在任何其他上下文中使用它可能会产生不可预测的影响，包括程序其他部分继续使用该字段的原始值的情况。</target>
        </trans-unit>
        <trans-unit id="269ef8898f71d5139fc6e4b1292850037573e45e" translate="yes" xml:space="preserve">
          <source>If the underlying field is final, this &lt;code&gt;Field&lt;/code&gt; object has &lt;em&gt;write&lt;/em&gt; access if and only if the following conditions are met:</source>
          <target state="translated">如果基础字段是最终 &lt;code&gt;Field&lt;/code&gt; 则当且仅当满足以下条件时，此Field对象才具有&lt;em&gt;写&lt;/em&gt;访问权限：</target>
        </trans-unit>
        <trans-unit id="f8ffdb31707c7c6f0d8ea54510f297f85f678ae3" translate="yes" xml:space="preserve">
          <source>If the underlying field is of a primitive type, an unwrapping conversion is attempted to convert the new value to a value of a primitive type. If this attempt fails, the method throws an &lt;code&gt;IllegalArgumentException&lt;/code&gt;.</source>
          <target state="translated">如果基础字段是原始类型，则尝试展开转换以将新值转换为原始类型的值。如果此尝试失败，则该方法将抛出 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="35c398b7568f2f6829527a1ee4e8ad05ab589757" translate="yes" xml:space="preserve">
          <source>If the underlying field is static, the &lt;code&gt;obj&lt;/code&gt; argument is ignored; it may be null.</source>
          <target state="translated">如果基础字段是静态的，则 &lt;code&gt;obj&lt;/code&gt; 参数被忽略；它可以为空。</target>
        </trans-unit>
        <trans-unit id="79473e9ad073a8c2b30d02714d81cdc8e02b2e5d" translate="yes" xml:space="preserve">
          <source>If the underlying field is static, the class that declared the field is initialized if it has not already been initialized.</source>
          <target state="translated">如果底层字段是静态的,那么声明该字段的类如果还没有被初始化,就会被初始化。</target>
        </trans-unit>
        <trans-unit id="884f8872373909a62519ac7ae071245b57ecb411" translate="yes" xml:space="preserve">
          <source>If the underlying method is &lt;a href=&quot;methodhandles.lookup#callsens&quot;&gt;caller sensitive&lt;/a&gt;, the direct method handle will have been &quot;bound&quot; to a particular caller class, the &lt;a href=&quot;methodhandles.lookup#lookupClass()&quot;&gt;lookup class&lt;/a&gt; of the lookup object used to create it. Cracking this method handle with a different lookup class will fail even if the underlying method is public (like &lt;code&gt;Class.forName&lt;/code&gt;).</source>
          <target state="translated">如果基础方法对&lt;a href=&quot;methodhandles.lookup#callsens&quot;&gt;调用者敏感&lt;/a&gt;，则直接方法句柄将被&amp;ldquo;绑定&amp;rdquo;到特定的调用者类，即用于创建它的查找对象的&lt;a href=&quot;methodhandles.lookup#lookupClass()&quot;&gt;查找类&lt;/a&gt;。即使基础方法是公共的（例如 &lt;code&gt;Class.forName&lt;/code&gt; ），使用不同的查找类破解该方法句柄也将失败。</target>
        </trans-unit>
        <trans-unit id="5c2e8ba35ddb7d491a4530be7e2d58c63b91b804" translate="yes" xml:space="preserve">
          <source>If the underlying method is &lt;a href=&quot;methodhandles.lookup#callsens&quot;&gt;caller sensitive&lt;/a&gt;, the direct method handle will have been &quot;bound&quot; to a particular caller class, the &lt;a href=&quot;methodhandles.lookup#lookupClass--&quot;&gt;lookup class&lt;/a&gt; of the lookup object used to create it. Cracking this method handle with a different lookup class will fail even if the underlying method is public (like &lt;code&gt;Class.forName&lt;/code&gt;).</source>
          <target state="translated">如果基础方法对&lt;a href=&quot;methodhandles.lookup#callsens&quot;&gt;调用者敏感&lt;/a&gt;，则直接方法句柄将&amp;ldquo;绑定&amp;rdquo;到特定的调用者类，即用于创建它的查找对象的&lt;a href=&quot;methodhandles.lookup#lookupClass--&quot;&gt;查找类&lt;/a&gt;。即使基础方法是公共的（例如 &lt;code&gt;Class.forName&lt;/code&gt; ），使用其他查找类破解此方法句柄也将失败。</target>
        </trans-unit>
        <trans-unit id="315e1d5687f0be0717ab38a86bf5bdc38d92fd67" translate="yes" xml:space="preserve">
          <source>If the underlying method is an instance method, it is invoked using dynamic method lookup as documented in The Java Language Specification, Second Edition, section 15.12.4.4; in particular, overriding based on the runtime type of the target object will occur.</source>
          <target state="translated">如果底层方法是实例方法,则使用动态方法查找来调用,如《Java语言规范》第二版第15.12.4.4节中所记载的那样;特别是,会发生基于目标对象的运行时类型的覆盖。</target>
        </trans-unit>
        <trans-unit id="5b1ed6ee8640dbbd801323bd87c98b861047134d" translate="yes" xml:space="preserve">
          <source>If the underlying method is an instance method, it is invoked using dynamic method lookup as documented in The Java Language Specification, section 15.12.4.4; in particular, overriding based on the runtime type of the target object may occur.</source>
          <target state="translated">如果底层方法是实例方法,则使用动态方法查找来调用,如《Java语言规范》第15.12.4.4节所述;特别是,可能会发生基于目标对象的运行时类型的覆盖。</target>
        </trans-unit>
        <trans-unit id="38f2cdfc3191616e303143bb27c18fb2f6e69964" translate="yes" xml:space="preserve">
          <source>If the underlying method is an instance method, it is invoked using dynamic method lookup as documented in The Java Language Specification, section &lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se15/html/jls-15.html#jls-15.12.4.4&quot;&gt;15.12.4.4&lt;/a&gt;; in particular, overriding based on the runtime type of the target object may occur.</source>
          <target state="translated">如果基础方法是实例方法，则使用《 Java语言规范》第&lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se15/html/jls-15.html#jls-15.12.4.4&quot;&gt;15.12.4.4&lt;/a&gt;节中记录的动态方法查找来调用该方法。特别是，可能会发生基于目标对象的运行时类型的覆盖。</target>
        </trans-unit>
        <trans-unit id="1fdc5865953923b940ef228e2839e6291e6d1529" translate="yes" xml:space="preserve">
          <source>If the underlying method is static, the class that declared the method is initialized if it has not already been initialized.</source>
          <target state="translated">如果底层方法是静态的,那么声明该方法的类如果还没有被初始化,就会被初始化。</target>
        </trans-unit>
        <trans-unit id="5417f1946175b0c601b43e5b5d82e2dfa1a39a1f" translate="yes" xml:space="preserve">
          <source>If the underlying method is static, then the specified &lt;code&gt;obj&lt;/code&gt; argument is ignored. It may be null.</source>
          <target state="translated">如果基础方法是静态的，则忽略指定的 &lt;code&gt;obj&lt;/code&gt; 参数。它可以为空。</target>
        </trans-unit>
        <trans-unit id="baee3bb7bafb1339b8300d582f80c05c628c3c7f" translate="yes" xml:space="preserve">
          <source>If the underlying model of the &lt;code&gt;RowSorter&lt;/code&gt; differs from that of this &lt;code&gt;JTable&lt;/code&gt; undefined behavior will result.</source>
          <target state="translated">如果 &lt;code&gt;RowSorter&lt;/code&gt; 的基础模型与此 &lt;code&gt;JTable&lt;/code&gt; 的基础模型不同，则将导致未定义的行为。</target>
        </trans-unit>
        <trans-unit id="dae88d15741d2fff1d10727455001428453c69fc" translate="yes" xml:space="preserve">
          <source>If the underlying model structure changes (the &lt;code&gt;modelStructureChanged&lt;/code&gt; method is invoked) the following are reset to their default values: &lt;code&gt;Comparator&lt;/code&gt;s by column, current sort order, and whether each column is sortable. The default sort order is natural (the same as the model), and columns are sortable by default.</source>
          <target state="translated">如果基础模型结构发生更改（调用了 &lt;code&gt;modelStructureChanged&lt;/code&gt; 方法），则以下各项将重置为其默认值： &lt;code&gt;Comparator&lt;/code&gt; （按列），当前排序顺序以及每个列是否可排序。默认排序顺序是自然的（与模型相同），默认情况下列是可排序的。</target>
        </trans-unit>
        <trans-unit id="9883703230204600dade0bca3c6ef6ed2362790c" translate="yes" xml:space="preserve">
          <source>If the underlying model structure changes (the &lt;code&gt;modelStructureChanged&lt;/code&gt; method is invoked) the following are reset to their default values: &lt;code&gt;Comparator&lt;/code&gt;s by column, current sort order, and whether each column is sortable. To find the default &lt;code&gt;Comparator&lt;/code&gt;s, see the concrete implementation (for example, &lt;a href=&quot;table/tablerowsorter&quot;&gt;&lt;code&gt;TableRowSorter&lt;/code&gt;&lt;/a&gt;). The default sort order is unsorted (the same as the model), and columns are sortable by default.</source>
          <target state="translated">如果基础模型结构发生更改（调用了 &lt;code&gt;modelStructureChanged&lt;/code&gt; 方法），则会将以下各项重置为其默认值：按列 &lt;code&gt;Comparator&lt;/code&gt; ，当前排序顺序以及每列是否可排序。要查找默认的 &lt;code&gt;Comparator&lt;/code&gt; ，请参见具体实现（例如&lt;a href=&quot;table/tablerowsorter&quot;&gt; &lt;code&gt;TableRowSorter&lt;/code&gt; &lt;/a&gt;）。默认的排序顺序是未排序的（与模型相同），并且列在默认情况下是可排序的。</target>
        </trans-unit>
        <trans-unit id="9921e56a78b932a99ec7c118f676e37975b2d1c9" translate="yes" xml:space="preserve">
          <source>If the underlying platform has a &quot;native&quot; look and feel, and this is an implementation of it, return &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">如果基础平台具有&amp;ldquo;本机&amp;rdquo;外观，并且这是其实现，则返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="afbbef7a28945de7e4c59f1f0a920532651223f3" translate="yes" xml:space="preserve">
          <source>If the underlying platform has a &quot;native&quot; look and feel, and this is an implementation of it, return &lt;code&gt;true&lt;/code&gt;. For example, when the underlying platform is Solaris running CDE a CDE/Motif look and feel implementation would return &lt;code&gt;
 true&lt;/code&gt;.</source>
          <target state="translated">如果基础平台具有&amp;ldquo;本机&amp;rdquo;外观，并且这是其实现，则返回 &lt;code&gt;true&lt;/code&gt; 。例如，当基础平台是运行CDE的Solaris时，CDE / Motif外观实现将返回 &lt;code&gt; true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2221ca8e8e96c757d1acb4e9dea9f2b5398db497" translate="yes" xml:space="preserve">
          <source>If the unit is a &lt;a href=&quot;temporal/chronounit&quot;&gt;&lt;code&gt;ChronoUnit&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The supported units are:</source>
          <target state="translated">如果单位是&lt;a href=&quot;temporal/chronounit&quot;&gt; &lt;code&gt;ChronoUnit&lt;/code&gt; ,&lt;/a&gt;则在此处执行查询。支持的单位是：</target>
        </trans-unit>
        <trans-unit id="cd8d281301aa1d20e9a67171d9933765d4124562" translate="yes" xml:space="preserve">
          <source>If the unit is not a &lt;code&gt;ChronoUnit&lt;/code&gt;, then the result of this method is obtained by invoking &lt;code&gt;TemporalUnit.addTo(Temporal, long)&lt;/code&gt; passing &lt;code&gt;this&lt;/code&gt; as the first argument.</source>
          <target state="translated">如果该单位不是 &lt;code&gt;ChronoUnit&lt;/code&gt; ，则通过调用 &lt;code&gt;TemporalUnit.addTo(Temporal, long)&lt;/code&gt; 并将 &lt;code&gt;this&lt;/code&gt; 作为第一个参数传递来获得此方法的结果。</target>
        </trans-unit>
        <trans-unit id="6f71bc9db5b6219e1ae283e954d88ba321dd8591" translate="yes" xml:space="preserve">
          <source>If the unit is not a &lt;code&gt;ChronoUnit&lt;/code&gt;, then the result of this method is obtained by invoking &lt;code&gt;TemporalUnit.between(Temporal, Temporal)&lt;/code&gt; passing &lt;code&gt;this&lt;/code&gt; as the first argument and the converted input temporal as the second argument.</source>
          <target state="translated">如果该单位不是 &lt;code&gt;ChronoUnit&lt;/code&gt; ，则通过调用 &lt;code&gt;TemporalUnit.between(Temporal, Temporal)&lt;/code&gt; 将 &lt;code&gt;this&lt;/code&gt; 作为第一个参数，并将转换后的输入时间作为第二个参数，来获得此方法的结果。</target>
        </trans-unit>
        <trans-unit id="66bc82b1dd235049a5511719d85e81950af05fd7" translate="yes" xml:space="preserve">
          <source>If the unit is not a &lt;code&gt;ChronoUnit&lt;/code&gt;, then the result of this method is obtained by invoking &lt;code&gt;TemporalUnit.isSupportedBy(Temporal)&lt;/code&gt; passing &lt;code&gt;this&lt;/code&gt; as the argument. Whether the unit is supported is determined by the unit.</source>
          <target state="translated">如果该单位不是 &lt;code&gt;ChronoUnit&lt;/code&gt; ，则通过调用 &lt;code&gt;TemporalUnit.isSupportedBy(Temporal)&lt;/code&gt; 并将 &lt;code&gt;this&lt;/code&gt; 作为参数来获取此方法的结果。是否支持该单元由该单元确定。</target>
        </trans-unit>
        <trans-unit id="906c58bb1f6e7950ac3b30334d2bb84e89a6b83b" translate="yes" xml:space="preserve">
          <source>If the unsigned magnitude is zero, it is represented by a single zero character &lt;code&gt;'0'&lt;/code&gt; (&lt;code&gt;'\u0030'&lt;/code&gt;); otherwise, the first character of the representation of the unsigned magnitude will not be the zero character. The characters &lt;code&gt;'0'&lt;/code&gt; (&lt;code&gt;'\u0030'&lt;/code&gt;) and &lt;code&gt;
 '1'&lt;/code&gt; (&lt;code&gt;'\u0031'&lt;/code&gt;) are used as binary digits.</source>
          <target state="translated">如果无符号大小为零，则用单个零字符 &lt;code&gt;'0'&lt;/code&gt; （ &lt;code&gt;'\u0030'&lt;/code&gt; ）表示；否则，无符号大小表示形式的第一个字符将不是零字符。字符 &lt;code&gt;'0'&lt;/code&gt; （ &lt;code&gt;'\u0030'&lt;/code&gt; ）和 &lt;code&gt; '1'&lt;/code&gt; （ &lt;code&gt;'\u0031'&lt;/code&gt; ）用作二进制数字。</target>
        </trans-unit>
        <trans-unit id="20661569ddc05848e0dfeb41e06e5676e4ccca6a" translate="yes" xml:space="preserve">
          <source>If the unsigned magnitude is zero, it is represented by a single zero character &lt;code&gt;'0'&lt;/code&gt; (&lt;code&gt;'\u0030'&lt;/code&gt;); otherwise, the first character of the representation of the unsigned magnitude will not be the zero character. The characters &lt;code&gt;'0'&lt;/code&gt; (&lt;code&gt;'\u0030'&lt;/code&gt;) and &lt;code&gt;'1'&lt;/code&gt; (&lt;code&gt;'\u0031'&lt;/code&gt;) are used as binary digits.</source>
          <target state="translated">如果无符号大小为零，则用单个零字符 &lt;code&gt;'0'&lt;/code&gt; （ &lt;code&gt;'\u0030'&lt;/code&gt; ）表示；否则，无符号大小表示形式的第一个字符将不是零字符。字符 &lt;code&gt;'0'&lt;/code&gt; （ &lt;code&gt;'\u0030'&lt;/code&gt; ）和 &lt;code&gt;'1'&lt;/code&gt; （ &lt;code&gt;'\u0031'&lt;/code&gt; ）用作二进制数字。</target>
        </trans-unit>
        <trans-unit id="c10c42689b734462a910f9cd90fb2d17103287f1" translate="yes" xml:space="preserve">
          <source>If the unsigned magnitude is zero, it is represented by a single zero character &lt;code&gt;'0'&lt;/code&gt; (&lt;code&gt;'\u0030'&lt;/code&gt;); otherwise, the first character of the representation of the unsigned magnitude will not be the zero character. The following characters are used as hexadecimal digits:</source>
          <target state="translated">如果无符号大小为零，则用单个零字符 &lt;code&gt;'0'&lt;/code&gt; （ &lt;code&gt;'\u0030'&lt;/code&gt; ）表示；否则，无符号大小表示形式的第一个字符将不是零字符。以下字符用作十六进制数字：</target>
        </trans-unit>
        <trans-unit id="f07ca050a4a81c4b683387f3c53d9089c379035d" translate="yes" xml:space="preserve">
          <source>If the unsigned magnitude is zero, it is represented by a single zero character &lt;code&gt;'0'&lt;/code&gt; (&lt;code&gt;'\u0030'&lt;/code&gt;); otherwise, the first character of the representation of the unsigned magnitude will not be the zero character. The following characters are used as octal digits:</source>
          <target state="translated">如果无符号大小为零，则用单个零字符 &lt;code&gt;'0'&lt;/code&gt; （ &lt;code&gt;'\u0030'&lt;/code&gt; ）表示；否则，无符号大小表示形式的第一个字符将不是零字符。以下字符用作八进制数字：</target>
        </trans-unit>
        <trans-unit id="ffd8f31b308ededd50592fa98b7b8942dd2be329" translate="yes" xml:space="preserve">
          <source>If the user cancels the dialog, the returned attributes will not reflect any changes made by the user.</source>
          <target state="translated">如果用户取消对话框,返回的属性将不会反映用户所做的任何更改。</target>
        </trans-unit>
        <trans-unit id="cb6714e942d1212dc9686ac25a627707c330ee39" translate="yes" xml:space="preserve">
          <source>If the user cancels the dialog, the returned attributes will not reflect any changes made by the user. A typical basic usage of this method may be :</source>
          <target state="translated">如果用户取消对话框,返回的属性将不会反映用户所做的任何更改。这个方法的典型基本用法是...。</target>
        </trans-unit>
        <trans-unit id="7208f9f9b8096f5bc1e213faa64052c112ef12fa" translate="yes" xml:space="preserve">
          <source>If the user cancels the file dialog, then the method returns an empty array.</source>
          <target state="translated">如果用户取消文件对话框,那么该方法返回一个空数组。</target>
        </trans-unit>
        <trans-unit id="de0b9944a16bfd19e85e0670561c553ba7b1eeb4" translate="yes" xml:space="preserve">
          <source>If the user doesn't select a drop action, the set of &lt;code&gt;DnDConstants&lt;/code&gt; that represents the set of drop actions supported by the drag source is searched for &lt;code&gt;DnDConstants.ACTION_MOVE&lt;/code&gt;, then for &lt;code&gt;DnDConstants.ACTION_COPY&lt;/code&gt;, then for &lt;code&gt;DnDConstants.ACTION_LINK&lt;/code&gt; and the</source>
          <target state="translated">如果用户没有选drop操作，该组 &lt;code&gt;DnDConstants&lt;/code&gt; 表示受drag源支持的放置动作中搜索 &lt;code&gt;DnDConstants.ACTION_MOVE&lt;/code&gt; ，然后 &lt;code&gt;DnDConstants.ACTION_COPY&lt;/code&gt; ，然后 &lt;code&gt;DnDConstants.ACTION_LINK&lt;/code&gt; 和</target>
        </trans-unit>
        <trans-unit id="93c5fdab4572abcb9f84bc6e6f772f374b7d5ea5" translate="yes" xml:space="preserve">
          <source>If the user has previously selected an input method or keyboard layout for the requested locale from the user interface, then the most recently selected such input method or keyboard layout is reselected.</source>
          <target state="translated">如果用户之前已经在用户界面上为所请求的语言选择了输入法或键盘布局,那么最近选择的这种输入法或键盘布局将被重新选择。</target>
        </trans-unit>
        <trans-unit id="0a3ff22bd71bfe0f9cb8dffa032e252c7a72a011" translate="yes" xml:space="preserve">
          <source>If the user provides an &lt;code&gt;RMIServerImpl&lt;/code&gt; rather than a &lt;code&gt;JMXServiceURL&lt;/code&gt;, then the generated &lt;code&gt;JMXServiceURL&lt;/code&gt; will have the local host name in its &lt;code&gt;&lt;em&gt;host&lt;/em&gt;&lt;/code&gt; part and no &lt;code&gt;&lt;em&gt;port&lt;/em&gt;&lt;/code&gt;.</source>
          <target state="translated">如果用户提供的是 &lt;code&gt;RMIServerImpl&lt;/code&gt; 而不是 &lt;code&gt;JMXServiceURL&lt;/code&gt; ，则生成的 &lt;code&gt;JMXServiceURL&lt;/code&gt; 的 &lt;code&gt;&lt;em&gt;host&lt;/em&gt;&lt;/code&gt; 部分将具有本地主机名，并且没有 &lt;code&gt;&lt;em&gt;port&lt;/em&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c751f889067dd8cb1ad34d217d14ea94b60a4ea0" translate="yes" xml:space="preserve">
          <source>If the user selects a drop action, the</source>
          <target state="translated">如果用户选择了放弃操作,则</target>
        </trans-unit>
        <trans-unit id="790177d5a2da0339061b07b0e2796a63d5c7bba4" translate="yes" xml:space="preserve">
          <source>If the user wants to represent more complex relations, involving properties and/or methods, he has to provide his own class implementing the Relation interface. This can be achieved either by inheriting from RelationSupport class, or by implementing the interface (fully or delegation to a RelationSupport object member).</source>
          <target state="translated">如果用户想表示更复杂的关系,包括属性和/或方法,他必须提供自己的类来实现Relation接口。这可以通过继承RelationSupport类,或通过实现该接口(完全或授权给RelationSupport对象成员)来实现。</target>
        </trans-unit>
        <trans-unit id="4e426a67bb1131fd615e1eb1f3e1e7dddce68bf0" translate="yes" xml:space="preserve">
          <source>If the value at the anchor index is not selected, do the same thing in reverse selecting values in the old range and deselecting values in the new one.</source>
          <target state="translated">如果锚点索引处的值没有被选中,则做同样的事情,反向选择旧范围内的值,取消选择新范围内的值。</target>
        </trans-unit>
        <trans-unit id="2d22c3736384d8f57852c160122995e97ee6f65b" translate="yes" xml:space="preserve">
          <source>If the value cannot be obtained then an exception will be thrown. If the value is negative an exception will be thrown. If the field does not have a fixed set of valid values then an exception will be thrown. If the field value in the date-time to be printed is invalid it cannot be printed and an exception will be thrown.</source>
          <target state="translated">如果无法获得该值,那么将抛出一个异常。如果值为负值,将抛出一个异常。如果该字段没有固定的有效值集,那么将抛出一个异常。如果要打印的日期-时间中的字段值无效,则不能打印,并抛出一个异常。</target>
        </trans-unit>
        <trans-unit id="3d99b539ed5fff0ea996e5c36ef46a4ab0d55246" translate="yes" xml:space="preserve">
          <source>If the value does not represent a valid &lt;a href=&quot;../java.base/java/lang/runtime.version&quot;&gt;Java SE Platform version number&lt;/a&gt;, an &lt;code&gt;IllegalArgumentException&lt;/code&gt; will be thrown.</source>
          <target state="translated">如果该值不代表有效的&lt;a href=&quot;../java.base/java/lang/runtime.version&quot;&gt;Java SE Platform版本号&lt;/a&gt;，则将抛出 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3ee0cd8b8e0f022dac140b1064202354f2993085" translate="yes" xml:space="preserve">
          <source>If the value for the specified key is present and non-null, attempts to compute a new mapping given the key and its current mapped value.</source>
          <target state="translated">如果指定键的值存在且非空,则尝试根据键及其当前映射值计算新的映射。</target>
        </trans-unit>
        <trans-unit id="ecdf413c04b1da892ae0fa943003fe90e373d5c1" translate="yes" xml:space="preserve">
          <source>If the value for the specified key is present, attempts to compute a new mapping given the key and its current mapped value.</source>
          <target state="translated">如果指定键的值存在,则尝试根据键及其当前映射值计算新的映射。</target>
        </trans-unit>
        <trans-unit id="4b761882d9981acf5026d5923e5e847a58120eb7" translate="yes" xml:space="preserve">
          <source>If the value for the specified key is present, attempts to compute a new mapping given the key and its current mapped value. The entire method invocation is performed atomically. Some attempted update operations on this map by other threads may be blocked while computation is in progress, so the computation should be short and simple, and must not attempt to update any other mappings of this map.</source>
          <target state="translated">如果指定键的值存在,则尝试计算一个新的映射,给定键及其当前映射值。整个方法的调用都是原子式执行的。在计算过程中,其他线程对该映射的一些尝试更新操作可能会被阻塞,所以计算应该是短而简单的,并且不能尝试更新该映射的任何其他映射。</target>
        </trans-unit>
        <trans-unit id="ab9247f09f8a914d5d3a273cd57f46206435c082" translate="yes" xml:space="preserve">
          <source>If the value for the specified key is present, attempts to compute a new mapping given the key and its current mapped value. The entire method invocation is performed atomically. The supplied function is invoked exactly once per invocation of this method if the key is present, else not at all. Some attempted update operations on this map by other threads may be blocked while computation is in progress, so the computation should be short and simple.</source>
          <target state="translated">如果指定键的值存在,则尝试计算一个新的映射,给定键及其当前映射值。整个方法的调用是以原子方式进行的。如果键存在,每次调用这个方法时,所提供的函数都会被准确地调用一次,否则完全不调用。在计算过程中,其他线程对该映射的一些尝试更新操作可能会被阻塞,所以计算应该是短而简单的。</target>
        </trans-unit>
        <trans-unit id="f3db5a9e74f7891f194526ea0f347239e63fa2ef" translate="yes" xml:space="preserve">
          <source>If the value for the specified key is present, attempts to compute a new mapping given the key and its current mapped value. The function is &lt;em&gt;NOT&lt;/em&gt; guaranteed to be applied once atomically.</source>
          <target state="translated">如果存在指定键的值，请尝试在给定键及其当前映射值的情况下计算新映射。&lt;em&gt;不&lt;/em&gt;保证该功能可以原子应用一次。</target>
        </trans-unit>
        <trans-unit id="c5e8a168b387e1a676dd90915381d221d843a6ab" translate="yes" xml:space="preserve">
          <source>If the value in the designated column has a custom mapping, this method returns the name of the class that implements &lt;code&gt;SQLData&lt;/code&gt;. When the method &lt;code&gt;ResultSet.getObject&lt;/code&gt; is called to retrieve a value from the designated column, it will create an instance of this class or one of its subclasses.</source>
          <target state="translated">如果指定列中的值具有自定义映射，则此方法返回实现 &lt;code&gt;SQLData&lt;/code&gt; 的类的名称。调用方法 &lt;code&gt;ResultSet.getObject&lt;/code&gt; 从指定的列中检索值时，它将创建该类或其子类之一的实例。</target>
        </trans-unit>
        <trans-unit id="76a62dcfb0cff96625fd935bd1e2f63de3a120f6" translate="yes" xml:space="preserve">
          <source>If the value is 0, this means to wait indefinitely.</source>
          <target state="translated">如果数值为0,则意味着无限期地等待。</target>
        </trans-unit>
        <trans-unit id="c7ba3202bd2d7e0d3d7e70603c207b47eb8a22d0" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;&quot;DEFLATED&quot;&lt;/code&gt; or the property is not set, the Zip file system provider will use data compression when writing entries to the Zip file system.</source>
          <target state="translated">如果值为 &lt;code&gt;&quot;DEFLATED&quot;&lt;/code&gt; 或未设置该属性，则在将条目写入Zip文件系统时，Zip文件系统提供程序将使用数据压缩。</target>
        </trans-unit>
        <trans-unit id="c4915503ed46018ca7714a4810995361ec058bdf" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;&quot;STORED&quot;&lt;/code&gt;, the Zip file system provider will not compress entries when writing to the Zip file system.</source>
          <target state="translated">如果值为 &lt;code&gt;&quot;STORED&quot;&lt;/code&gt; ，则Zip文件系统提供程序在写入Zip文件系统时将不会压缩条目。</target>
        </trans-unit>
        <trans-unit id="1da17a5162837fd71057188c7c8f9d55cafe8683" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;&quot;runtime&quot;&lt;/code&gt;, the version entry will be determined by invoking &lt;a href=&quot;../java.base/java/lang/runtime.version#feature()&quot;&gt;Runtime.Version.feature()&lt;/a&gt;.</source>
          <target state="translated">如果值为 &lt;code&gt;&quot;runtime&quot;&lt;/code&gt; ，则将通过调用&lt;a href=&quot;../java.base/java/lang/runtime.version#feature()&quot;&gt;Runtime.Version.feature（）&lt;/a&gt;来确定版本条目。</target>
        </trans-unit>
        <trans-unit id="0de4492c54d50e85bf0da62b3577996044c41c74" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;non-null&lt;/code&gt;, it is returned. If the value of the default &lt;code&gt;&quot;AuditoryCues.actionMap&quot;&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; and the value of the default &lt;code&gt;&quot;AuditoryCues.cueList&quot;&lt;/code&gt; is &lt;code&gt;non-null&lt;/code&gt;, an &lt;code&gt;ActionMapUIResource&lt;/code&gt; is created and populated. Population is done by iterating over each of the elements of the &lt;code&gt;&quot;AuditoryCues.cueList&quot;&lt;/code&gt; array, and invoking &lt;code&gt;createAudioAction()&lt;/code&gt; to create an &lt;code&gt;
 Action&lt;/code&gt; for each element. The resulting &lt;code&gt;Action&lt;/code&gt; is placed in the &lt;code&gt;ActionMapUIResource&lt;/code&gt;, using the array element as the key. For example, if the &lt;code&gt;
 &quot;AuditoryCues.cueList&quot;&lt;/code&gt; array contains a single-element, &lt;code&gt;
 &quot;audioKey&quot;&lt;/code&gt;, the &lt;code&gt;ActionMapUIResource&lt;/code&gt; is created, then populated by way of &lt;code&gt;actionMap.put(cueList[0],
 createAudioAction(cueList[0]))&lt;/code&gt;.</source>
          <target state="translated">如果该值 &lt;code&gt;non-null&lt;/code&gt; ，则将其返回。如果默认的 &lt;code&gt;&quot;AuditoryCues.actionMap&quot;&lt;/code&gt; 值为 &lt;code&gt;null&lt;/code&gt; ,并且默认的 &lt;code&gt;&quot;AuditoryCues.cueList&quot;&lt;/code&gt; 值为 &lt;code&gt;non-null&lt;/code&gt; ，则会创建并填充一个 &lt;code&gt;ActionMapUIResource&lt;/code&gt; 。通过遍历 &lt;code&gt;&quot;AuditoryCues.cueList&quot;&lt;/code&gt; 数组的每个元素并调用 &lt;code&gt;createAudioAction()&lt;/code&gt; 为每个元素创建一个 &lt;code&gt; Action&lt;/code&gt; 来完成填充。使用数组元素作为键，将生成的 &lt;code&gt;Action&lt;/code&gt; 放置在 &lt;code&gt;ActionMapUIResource&lt;/code&gt; 中。例如，如果 &lt;code&gt; &quot;AuditoryCues.cueList&quot;&lt;/code&gt; 包含单个元素 &lt;code&gt; &quot;audioKey&quot;&lt;/code&gt; 数组，将创建 &lt;code&gt;ActionMapUIResource&lt;/code&gt; ，然后通过 &lt;code&gt;actionMap.put(cueList[0], createAudioAction(cueList[0]))&lt;/code&gt; 进行填充。</target>
        </trans-unit>
        <trans-unit id="48f26593351b6f67f120030ffb29e742cf0e8005" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;null&lt;/code&gt; or the property is not set, then the JAR will be treated as an un-versioned JAR.</source>
          <target state="translated">如果该值为 &lt;code&gt;null&lt;/code&gt; 或未设置该属性，则该JAR将被视为未版本化的JAR。</target>
        </trans-unit>
        <trans-unit id="13f1ab8d6bcff2c595a675585e42d96731f03925" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, the Zip file system provider creates a new Zip or JAR file if it does not exist.</source>
          <target state="translated">如果值为 &lt;code&gt;true&lt;/code&gt; ，则Zip文件系统提供程序将创建一个新的Zip或JAR文件（如果不存在）。</target>
        </trans-unit>
        <trans-unit id="f7b9c97637681e9e7a63c9db0dc64ec2ca509020" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, the Zip file system will support the &lt;a href=&quot;../java.base/java/nio/file/attribute/posixfileattributeview&quot;&gt;&lt;code&gt;PosixFileAttributeView&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果该值为 &lt;code&gt;true&lt;/code&gt; ，则Zip文件系统将支持&lt;a href=&quot;../java.base/java/nio/file/attribute/posixfileattributeview&quot;&gt; &lt;code&gt;PosixFileAttributeView&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="301076cf0d84829c80ed3ada45bc0a362fb8a4d9" translate="yes" xml:space="preserve">
          <source>If the value is NaN or infinite, the literal strings &quot;NaN&quot; or &quot;Infinity&quot;, respectively, will be output.</source>
          <target state="translated">如果值是NaN或无限,将分别输出文字串 &quot;NaN &quot;或 &quot;Infinity&quot;。</target>
        </trans-unit>
        <trans-unit id="ab06ef8615a9271c661fe8e0122f8b8d95f1110e" translate="yes" xml:space="preserve">
          <source>If the value is NaN or positive infinity the literal strings &quot;NaN&quot; or &quot;Infinity&quot; respectively, will be output. If the value is negative infinity, then the output will be &quot;(Infinity)&quot; if the &lt;code&gt;'('&lt;/code&gt; flag is given otherwise the output will be &quot;-Infinity&quot;. These values are not localized.</source>
          <target state="translated">如果值为NaN或正无穷大，则分别输出文字字符串&amp;ldquo; NaN&amp;rdquo;或&amp;ldquo; Infinity&amp;rdquo;。如果值是负无穷大，那么如果给出 &lt;code&gt;'('&lt;/code&gt; 标志，则输出将是&amp;ldquo;（Infinity）&amp;rdquo;，否则输出将是&amp;ldquo; -Infinity&amp;rdquo;。这些值未本地化。</target>
        </trans-unit>
        <trans-unit id="0835f0832141e69a77792c43ed4cdb23fe77095b" translate="yes" xml:space="preserve">
          <source>If the value is a URN, the &lt;code&gt;href&lt;/code&gt; attribute is recognized as a &lt;code&gt;publicId&lt;/code&gt;, and used to search &lt;code&gt;public&lt;/code&gt; entries. If the value is a URI, it is taken as a &lt;code&gt;systemId&lt;/code&gt;, and used to search both &lt;code&gt;system&lt;/code&gt; and &lt;code&gt;uri&lt;/code&gt; entries.</source>
          <target state="translated">如果值为URN，则 &lt;code&gt;href&lt;/code&gt; 属性被识别为 &lt;code&gt;publicId&lt;/code&gt; ，并用于搜索 &lt;code&gt;public&lt;/code&gt; 条目。如果该值为URI，则将其视为 &lt;code&gt;systemId&lt;/code&gt; ，并用于搜索 &lt;code&gt;system&lt;/code&gt; 条目和 &lt;code&gt;uri&lt;/code&gt; 条目。</target>
        </trans-unit>
        <trans-unit id="a8386f5e063110a495ec4902ded50dbabab418fe" translate="yes" xml:space="preserve">
          <source>If the value is negative (or floating-point negative zero) and &lt;code&gt;'('&lt;/code&gt; flag is not given, then a &lt;code&gt;'-'&lt;/code&gt; (&lt;code&gt;'\u002d'&lt;/code&gt;) is prepended.</source>
          <target state="translated">如果该值是负数（或浮点负数为零）且未给出 &lt;code&gt;'('&lt;/code&gt; 标志，则在前面 &lt;code&gt;'\u002d'&lt;/code&gt; &lt;code&gt;'-'&lt;/code&gt; （'\ u002d'）。</target>
        </trans-unit>
        <trans-unit id="6f6d817a3f4c5b41b572c9b2e4daf5c4281d9fee" translate="yes" xml:space="preserve">
          <source>If the value is negative and the &lt;code&gt;'('&lt;/code&gt; flag is given, then a &lt;code&gt;'('&lt;/code&gt; (&lt;code&gt;'\u0028'&lt;/code&gt;) is prepended and a &lt;code&gt;')'&lt;/code&gt; (&lt;code&gt;'\u0029'&lt;/code&gt;) is appended.</source>
          <target state="translated">如果该值为负数并且给出了 &lt;code&gt;'('&lt;/code&gt; 标志，则在前面 &lt;code&gt;'\u0028'&lt;/code&gt; &lt;code&gt;'('&lt;/code&gt; （'\ u0028'），并在后面加上 &lt;code&gt;')'&lt;/code&gt; （ &lt;code&gt;'\u0029'&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="79c5db2353984efc6cb7e1c18940f5eb527e5ef9" translate="yes" xml:space="preserve">
          <source>If the value is negative, then it represents the number of days back from the end of the month where &lt;code&gt;-1&lt;/code&gt; is the last day of the month. In this case, the day identified is the latest possible date that the transition can be.</source>
          <target state="translated">如果该值为负，则表示从月末开始返回的天数，其中 &lt;code&gt;-1&lt;/code&gt; 是该月的最后一天。在这种情况下，标识的日期是转换可能的最晚日期。</target>
        </trans-unit>
        <trans-unit id="f585bd91e3b9e65403bebed531867a10e356498c" translate="yes" xml:space="preserve">
          <source>If the value is not &lt;code&gt;&quot;STORED&quot;&lt;/code&gt; or &lt;code&gt;&quot;DEFLATED&quot;&lt;/code&gt;, an &lt;code&gt;IllegalArgumentException&lt;/code&gt; will be thrown when the Zip filesystem is created.</source>
          <target state="translated">如果该值不是 &lt;code&gt;&quot;STORED&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;DEFLATED&quot;&lt;/code&gt; ，则在创建Zip文件系统时将抛出 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a221fc4de816cd6c7effceee4131da4c33e0f4df" translate="yes" xml:space="preserve">
          <source>If the value is not of the proper type, the attribute will be ignored.</source>
          <target state="translated">如果值不属于正确的类型,该属性将被忽略。</target>
        </trans-unit>
        <trans-unit id="a89c880bd0c92196eb9e203f110acd320c2580c9" translate="yes" xml:space="preserve">
          <source>If the value is positive, then it represents a normal day-of-month, and is the earliest possible date that the transition can be. The date may refer to 29th February which should be treated as 1st March in non-leap years.</source>
          <target state="translated">如果该值为正值,则代表正常的月日,也是过渡的最早日期。该日期可能指的是2月29日,在非闰年应视为3月1日。</target>
        </trans-unit>
        <trans-unit id="3334ef34b1cd3c138c012c02960e8363c7beb397" translate="yes" xml:space="preserve">
          <source>If the value is set to &lt;code&gt;true&lt;/code&gt;, then:</source>
          <target state="translated">如果该值设置为 &lt;code&gt;true&lt;/code&gt; ，则：</target>
        </trans-unit>
        <trans-unit id="e02310a0ea5559eabc6294ef56491025a14c4eb6" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;DISPLAYED_MNEMONIC_INDEX_KEY&lt;/code&gt; is beyond the bounds of the text, it is ignored. When &lt;code&gt;setAction&lt;/code&gt; is called, if the value from the &lt;code&gt;Action&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, the displayed mnemonic index is not updated. In any subsequent changes to &lt;code&gt;DISPLAYED_MNEMONIC_INDEX_KEY&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt; is treated as -1.</source>
          <target state="translated">如果 &lt;code&gt;DISPLAYED_MNEMONIC_INDEX_KEY&lt;/code&gt; 的值超出文本范围，则将其忽略。当 &lt;code&gt;setAction&lt;/code&gt; 命令被调用时，如果从价值 &lt;code&gt;Action&lt;/code&gt; 是 &lt;code&gt;null&lt;/code&gt; ，所显示的助记符索引没有更新。在对 &lt;code&gt;DISPLAYED_MNEMONIC_INDEX_KEY&lt;/code&gt; 的任何后续更改中， &lt;code&gt;null&lt;/code&gt; 都被视为-1。</target>
        </trans-unit>
        <trans-unit id="22c60f3a7542e4a41034dd5216a61c3aba7c36d9" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;key&lt;/code&gt; for the given &lt;code&gt;Locale&lt;/code&gt; is a &lt;code&gt;Border&lt;/code&gt; return it, otherwise return &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">如果给定 &lt;code&gt;Locale&lt;/code&gt; 的 &lt;code&gt;key&lt;/code&gt; 值是 &lt;code&gt;Border&lt;/code&gt; ，则返回它，否则返回 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eba252138c8090a37a788c71e19e8a3cb0276356" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;key&lt;/code&gt; for the given &lt;code&gt;Locale&lt;/code&gt; is a &lt;code&gt;Color&lt;/code&gt; return it, otherwise return &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">如果给定 &lt;code&gt;Locale&lt;/code&gt; 的 &lt;code&gt;key&lt;/code&gt; 值是 &lt;code&gt;Color&lt;/code&gt; ，则返回它，否则返回 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="367d8e2f0ca28a2ea644636137ef64c997bec18b" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;key&lt;/code&gt; for the given &lt;code&gt;Locale&lt;/code&gt; is a &lt;code&gt;Dimension&lt;/code&gt; return it, otherwise return &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">如果值 &lt;code&gt;key&lt;/code&gt; 为给定的 &lt;code&gt;Locale&lt;/code&gt; 是一个 &lt;code&gt;Dimension&lt;/code&gt; 返回它，否则返回 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2be0d9b17a5e47e7e93a2913690292ed9a69b7ff" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;key&lt;/code&gt; for the given &lt;code&gt;Locale&lt;/code&gt; is a &lt;code&gt;Font&lt;/code&gt; return it, otherwise return &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">如果给定 &lt;code&gt;Locale&lt;/code&gt; 的 &lt;code&gt;key&lt;/code&gt; 值是 &lt;code&gt;Font&lt;/code&gt; ，则返回它，否则返回 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c67916533b9dbb5dc83f598e1e6382427cd552f9" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;key&lt;/code&gt; for the given &lt;code&gt;Locale&lt;/code&gt; is a &lt;code&gt;String&lt;/code&gt; return it, otherwise return &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">如果值 &lt;code&gt;key&lt;/code&gt; 为给定的 &lt;code&gt;Locale&lt;/code&gt; 是一个 &lt;code&gt;String&lt;/code&gt; 返回它，否则返回 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8d2bfc7c723ba35a6fcf6c4b6137b4f780a0b3de" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;key&lt;/code&gt; for the given &lt;code&gt;Locale&lt;/code&gt; is an &lt;code&gt;Icon&lt;/code&gt; return it, otherwise return &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">如果给定 &lt;code&gt;Locale&lt;/code&gt; 的 &lt;code&gt;key&lt;/code&gt; 值是一个 &lt;code&gt;Icon&lt;/code&gt; ，则返回它，否则返回 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ab2d62c2054fc3fa0f8b523b4eab33e78eb557e0" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;key&lt;/code&gt; for the given &lt;code&gt;Locale&lt;/code&gt; is an &lt;code&gt;Insets&lt;/code&gt; return it, otherwise return &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">如果值 &lt;code&gt;key&lt;/code&gt; 为给定的 &lt;code&gt;Locale&lt;/code&gt; 是一个 &lt;code&gt;Insets&lt;/code&gt; 返回它，否则返回 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0260b2e58bbf30b3665cb0865cc9a91961481c68" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;key&lt;/code&gt; for the given &lt;code&gt;Locale&lt;/code&gt; is an &lt;code&gt;Integer&lt;/code&gt; return its integer value, otherwise return 0.</source>
          <target state="translated">如果值 &lt;code&gt;key&lt;/code&gt; 为给定的 &lt;code&gt;Locale&lt;/code&gt; 是一个 &lt;code&gt;Integer&lt;/code&gt; ，则返回其整数值，否则返回0。</target>
        </trans-unit>
        <trans-unit id="a6474e2edb69dbe8cb6a10bd386064bfd71534a0" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;key&lt;/code&gt; for the given &lt;code&gt;Locale&lt;/code&gt; is boolean, return the boolean value, otherwise return false.</source>
          <target state="translated">如果给定 &lt;code&gt;Locale&lt;/code&gt; 的 &lt;code&gt;key&lt;/code&gt; 值为boolean，则返回boolean值，否则返回false。</target>
        </trans-unit>
        <trans-unit id="1b6d5bd5fca8a25f1dd49217534639ed2ffe7fe4" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;key&lt;/code&gt; is a &lt;code&gt;Border&lt;/code&gt; return it, otherwise return &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;key&lt;/code&gt; 的值是 &lt;code&gt;Border&lt;/code&gt; ，则返回它，否则返回 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c3be018e83c846fe1b30aea1f6bf6ccf6c10c541" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;key&lt;/code&gt; is a &lt;code&gt;Color&lt;/code&gt; return it, otherwise return &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;key&lt;/code&gt; 的值是 &lt;code&gt;Color&lt;/code&gt; ，则返回它，否则返回 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6c8b42e483eff7d7568eb7eb3163a2f5cbbf4c96" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;key&lt;/code&gt; is a &lt;code&gt;Dimension&lt;/code&gt; return it, otherwise return &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;key&lt;/code&gt; 的值是 &lt;code&gt;Dimension&lt;/code&gt; ，则返回它，否则返回 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f5785760f42f1977942d08aa328b366f8fc0db0e" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;key&lt;/code&gt; is a &lt;code&gt;Font&lt;/code&gt; return it, otherwise return &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;key&lt;/code&gt; 的值是 &lt;code&gt;Font&lt;/code&gt; ，则返回它，否则返回 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4141012d327f30dfb544d88d4209e96defccecb8" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;key&lt;/code&gt; is a &lt;code&gt;String&lt;/code&gt; return it, otherwise return &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;key&lt;/code&gt; 的值为 &lt;code&gt;String&lt;/code&gt; ，则返回它，否则返回 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5ba848583bb0ce0d7c9675fd82c19e9dbc0309d4" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;key&lt;/code&gt; is an &lt;code&gt;Icon&lt;/code&gt; return it, otherwise return &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;key&lt;/code&gt; 的值是 &lt;code&gt;Icon&lt;/code&gt; ，则返回它，否则返回 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eba09aea4ed9d543ab5701573b6ee8091b5b8904" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;key&lt;/code&gt; is an &lt;code&gt;Insets&lt;/code&gt; return it, otherwise return &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;key&lt;/code&gt; 的值是 &lt;code&gt;Insets&lt;/code&gt; ，则返回它，否则返回 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5234ac47786667f30dde0ed0ff67d97ce01bff63" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;key&lt;/code&gt; is an &lt;code&gt;Integer&lt;/code&gt; return its integer value, otherwise return 0.</source>
          <target state="translated">如果 &lt;code&gt;key&lt;/code&gt; 的值是 &lt;code&gt;Integer&lt;/code&gt; ,则返回其整数值，否则返回0。</target>
        </trans-unit>
        <trans-unit id="f45a7d95af981044e17417d792efc75f1ad87858" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;key&lt;/code&gt; is boolean, return the boolean value, otherwise return false.</source>
          <target state="translated">如果 &lt;code&gt;key&lt;/code&gt; 的值为boolean，则返回boolean值，否则返回false。</target>
        </trans-unit>
        <trans-unit id="43c44811372338e5d89625fd7f4ec1fe65b36ee4" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;load&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, then this method starts loading any images that are not yet being loaded.</source>
          <target state="translated">如果 &lt;code&gt;load&lt;/code&gt; 的值为 &lt;code&gt;true&lt;/code&gt; ，则此方法开始加载所有尚未加载的图像。</target>
        </trans-unit>
        <trans-unit id="f6fe9c920cf87a3961283663010d0cc7faf04891" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;mode&lt;/code&gt; is &lt;code&gt;LOAD&lt;/code&gt;, then the file dialog is finding a file to read, and the files shown are those in the current directory. If the value of &lt;code&gt;mode&lt;/code&gt; is &lt;code&gt;SAVE&lt;/code&gt;, the file dialog is finding a place to write a file.</source>
          <target state="translated">如果 &lt;code&gt;mode&lt;/code&gt; 的值为 &lt;code&gt;LOAD&lt;/code&gt; ，则文件对话框正在查找要读取的文件，并且显示的文件是当前目录中的文件。如果 &lt;code&gt;mode&lt;/code&gt; 的值为 &lt;code&gt;SAVE&lt;/code&gt; ，则文件对话框正在寻找写入文件的位置。</target>
        </trans-unit>
        <trans-unit id="8a25b68c044cd0c1ec4edc8c60c29d6185e1c049" translate="yes" xml:space="preserve">
          <source>If the value of a field is not a String, then the toString() method will be called on it and the returned value, enclosed in parentheses, used as the value for the field in the returned array. If the value of a field is null, then the value of the field in the returned array will be empty. If the descriptor is empty, you will get an empty array.</source>
          <target state="translated">如果一个字段的值不是字符串,那么将调用toString()方法,并将返回的值用括号括起来,作为返回数组中字段的值。如果字段的值为空,那么返回数组中的字段值将为空。如果描述符为空,则会得到一个空数组。</target>
        </trans-unit>
        <trans-unit id="1efefa1818e57cc73d4ed09d390b1ca62795c0cf" translate="yes" xml:space="preserve">
          <source>If the value of a shorthand property can not be decomposed into its component longhand properties, as is the case for the &lt;code&gt;font&lt;/code&gt; property with a value of &quot;menu&quot;, querying for the values of the component longhand properties should return the empty string.</source>
          <target state="translated">如果不能将速记属性的值分解为其组件的longhand属性，例如对于具有&amp;ldquo; menu&amp;rdquo;值的 &lt;code&gt;font&lt;/code&gt; 属性，则查询组件的longhand属性的值应返回空字符串。</target>
        </trans-unit>
        <trans-unit id="3c88da9b0c956884891afc187b29ac9d1d3914af" translate="yes" xml:space="preserve">
          <source>If the value of that system property is not &lt;code&gt;null&lt;/code&gt;, it is interpreted as a list of packages separated by a vertical slash character '&lt;code&gt;|&lt;/code&gt;'. The constructor tries to load the class named:</source>
          <target state="translated">如果该系统属性的值不为 &lt;code&gt;null&lt;/code&gt; ，则将其解释为由垂直斜杠字符' &lt;code&gt;|&lt;/code&gt; 分隔的软件包列表。'。构造函数尝试加载名为的类：</target>
        </trans-unit>
        <trans-unit id="189b2a483106b850cb5a3377c0425a501b7adcff" translate="yes" xml:space="preserve">
          <source>If the value of the &lt;code&gt;len&lt;/code&gt; parameter is negative then no characters are written. This is contrary to the specification of this method in the &lt;a href=&quot;writer#write-java.lang.String-int-int-&quot;&gt;superclass&lt;/a&gt;, which requires that an &lt;a href=&quot;../lang/indexoutofboundsexception&quot;&gt;&lt;code&gt;IndexOutOfBoundsException&lt;/code&gt;&lt;/a&gt; be thrown.</source>
          <target state="translated">如果 &lt;code&gt;len&lt;/code&gt; 参数的值为负，则不会写入任何字符。这与&lt;a href=&quot;writer#write-java.lang.String-int-int-&quot;&gt;超类&lt;/a&gt;中此方法的规范相反，该规范要求抛出&lt;a href=&quot;../lang/indexoutofboundsexception&quot;&gt; &lt;code&gt;IndexOutOfBoundsException&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8a175ebc49437ed81722116dff77ef058a7b66c3" translate="yes" xml:space="preserve">
          <source>If the value of the &lt;code&gt;load&lt;/code&gt; flag is &lt;code&gt;true&lt;/code&gt;, then this method starts loading any images that are not yet being loaded.</source>
          <target state="translated">如果 &lt;code&gt;load&lt;/code&gt; 标志的值为 &lt;code&gt;true&lt;/code&gt; ，则此方法开始加载所有尚未加载的图像。</target>
        </trans-unit>
        <trans-unit id="b153c1760d762182820a11651725f26d981a5d3a" translate="yes" xml:space="preserve">
          <source>If the value of the &lt;code&gt;width&lt;/code&gt; or &lt;code&gt;preferredWidth&lt;/code&gt; property is less than the new minimum width, this method sets that property to the new minimum width.</source>
          <target state="translated">如果 &lt;code&gt;width&lt;/code&gt; 或 &lt;code&gt;preferredWidth&lt;/code&gt; 属性的值小于新的最小宽度，则此方法将该属性设置为新的最小宽度。</target>
        </trans-unit>
        <trans-unit id="d3222faa7f28cca7505e3db00febf3a73dfdf614" translate="yes" xml:space="preserve">
          <source>If the value of the &lt;code&gt;width&lt;/code&gt; or &lt;code&gt;preferredWidth&lt;/code&gt; property is more than the new maximum width, this method sets that property to the new maximum width.</source>
          <target state="translated">如果 &lt;code&gt;width&lt;/code&gt; 或 &lt;code&gt;preferredWidth&lt;/code&gt; 属性的值大于新的最大宽度，则此方法将该属性设置为新的最大宽度。</target>
        </trans-unit>
        <trans-unit id="1faf4afd4927c3eff93f389c43a673f5145f1898" translate="yes" xml:space="preserve">
          <source>If the value of the default &lt;code&gt;&quot;AuditoryCues.actionMap&quot;&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; and the value of the default &lt;code&gt;&quot;AuditoryCues.cueList&quot;&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, an empty &lt;code&gt;ActionMapUIResource&lt;/code&gt; is created.</source>
          <target state="translated">如果默认的 &lt;code&gt;&quot;AuditoryCues.actionMap&quot;&lt;/code&gt; 值为 &lt;code&gt;null&lt;/code&gt; 且默认的 &lt;code&gt;&quot;AuditoryCues.cueList&quot;&lt;/code&gt; 值为 &lt;code&gt;null&lt;/code&gt; ，则会创建一个空的 &lt;code&gt;ActionMapUIResource&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="677e23258402aae540c1aad5d995a866d4b392f9" translate="yes" xml:space="preserve">
          <source>If the value of the system property is set to &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;path&lt;/code&gt; is converted to a &lt;a href=&quot;../nio/file/path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt; object named &lt;code&gt;npath&lt;/code&gt; after &lt;a href=&quot;../nio/file/path#normalize()&quot;&gt;&lt;code&gt;normalization&lt;/code&gt;&lt;/a&gt;. No canonicalization is performed which means the underlying file system is not accessed. If an &lt;a href=&quot;../nio/file/invalidpathexception&quot;&gt;&lt;code&gt;InvalidPathException&lt;/code&gt;&lt;/a&gt; is thrown during the conversion, this &lt;code&gt;FilePermission&lt;/code&gt; will be labeled as invalid.</source>
          <target state="translated">如果将system属性的值设置为 &lt;code&gt;false&lt;/code&gt; ，则在&lt;a href=&quot;../nio/file/path#normalize()&quot;&gt; &lt;code&gt;normalization&lt;/code&gt; &lt;/a&gt;之后， &lt;code&gt;path&lt;/code&gt; 会转换为名为 &lt;code&gt;npath&lt;/code&gt; 的&lt;a href=&quot;../nio/file/path&quot;&gt; &lt;code&gt;Path&lt;/code&gt; &lt;/a&gt;对象。不执行规范化，这意味着不访问基础文件系统。如果在转换过程中抛出&lt;a href=&quot;../nio/file/invalidpathexception&quot;&gt; &lt;code&gt;InvalidPathException&lt;/code&gt; &lt;/a&gt;，则此 &lt;code&gt;FilePermission&lt;/code&gt; 将被标记为无效。</target>
        </trans-unit>
        <trans-unit id="9d3cf19c572562cc39301cdc9457c2f8ef2d7a44" translate="yes" xml:space="preserve">
          <source>If the value of the system property is set to &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;path&lt;/code&gt; is canonicalized and stored as a String object named &lt;code&gt;cpath&lt;/code&gt;. This means a relative path is converted to an absolute path, a Windows DOS-style 8.3 path is expanded to a long path, and a symbolic link is resolved to its target, etc.</source>
          <target state="translated">如果system属性的值设置为 &lt;code&gt;true&lt;/code&gt; ，则将规范化 &lt;code&gt;path&lt;/code&gt; 并将其存储为名为 &lt;code&gt;cpath&lt;/code&gt; 的String对象。这意味着将相对路径转换为绝对路径，将Windows DOS样式8.3路径扩展为长路径，并将符号链接解析为其目标，依此类推。</target>
        </trans-unit>
        <trans-unit id="9bbd078cde15abb1e52c1f5b43c7ab7eadad9320" translate="yes" xml:space="preserve">
          <source>If the value of this attribute specifies a date-time that is in the future, the printer should add the &lt;a href=&quot;jobstatereason&quot;&gt;&lt;code&gt;JobStateReason&lt;/code&gt;&lt;/a&gt; value of &lt;code&gt;JOB_HOLD_UNTIL_SPECIFIED&lt;/code&gt; to the job's &lt;a href=&quot;jobstatereasons&quot;&gt;&lt;code&gt;JobStateReasons&lt;/code&gt;&lt;/a&gt; attribute, must move the job to the &lt;code&gt;PENDING_HELD&lt;/code&gt; state, and must not schedule the job for printing until the specified date-time arrives.</source>
          <target state="translated">如果此属性的值指定了将来的日期时间，则打印机应将 &lt;code&gt;JOB_HOLD_UNTIL_SPECIFIED&lt;/code&gt; 的&lt;a href=&quot;jobstatereason&quot;&gt; &lt;code&gt;JobStateReason&lt;/code&gt; &lt;/a&gt;值添加到作业的&lt;a href=&quot;jobstatereasons&quot;&gt; &lt;code&gt;JobStateReasons&lt;/code&gt; &lt;/a&gt;属性中，必须将作业移到 &lt;code&gt;PENDING_HELD&lt;/code&gt; 状态，并且不得安排作业进行打印，直到指定的日期时间到来。</target>
        </trans-unit>
        <trans-unit id="3351a4cf5b5a7a09cdd906eb6fad0d706861c179" translate="yes" xml:space="preserve">
          <source>If the value of this attribute specifies a date-time that is in the future, the printer should add the &lt;a href=&quot;jobstatereason&quot;&gt;&lt;code&gt;JobStateReason&lt;/code&gt;&lt;/a&gt; value of JOB_HOLD_UNTIL_SPECIFIED to the job's &lt;a href=&quot;jobstatereasons&quot;&gt;&lt;code&gt;JobStateReasons&lt;/code&gt;&lt;/a&gt; attribute, must move the job to the PENDING_HELD state, and must not schedule the job for printing until the specified date-time arrives.</source>
          <target state="translated">如果此属性的值指定了将来的日期时间，则打印机应将JOB_HOLD_UNTIL_SPECIFIED 的&lt;a href=&quot;jobstatereason&quot;&gt; &lt;code&gt;JobStateReason&lt;/code&gt; &lt;/a&gt;值添加到作业的&lt;a href=&quot;jobstatereasons&quot;&gt; &lt;code&gt;JobStateReasons&lt;/code&gt; &lt;/a&gt;属性中，必须将作业移到PENDING_HELD状态，并且不得安排作业进行打印，直到指定的日期时间到来。</target>
        </trans-unit>
        <trans-unit id="48a7960d847d0c7897f06eee9795f35f60cafa1b" translate="yes" xml:space="preserve">
          <source>If the value property of this instance is not already set, this method dynamically finds the method with the specified methodName on this target with these arguments and calls it.</source>
          <target state="translated">如果这个实例的值属性还没有被设置,这个方法就会动态地在这个目标上找到带有这些参数的指定方法Name的方法并调用它。</target>
        </trans-unit>
        <trans-unit id="fa55bedef91ce7d9c1fec0b52fe91e9615e15668" translate="yes" xml:space="preserve">
          <source>If the value property of this instance is not already set, this method dynamically finds the method with the specified methodName on this target with these arguments and calls it. The result of the method invocation is first copied into the value property of this expression and then returned as the result of &lt;code&gt;getValue&lt;/code&gt;. If the value property was already set, either by a call to &lt;code&gt;setValue&lt;/code&gt; or a previous call to &lt;code&gt;getValue&lt;/code&gt; then the value property is returned without either looking up or calling the method.</source>
          <target state="translated">如果尚未设置此实例的value属性，则此方法使用这些参数在此目标上动态查找具有指定methodName的方法，然后调用它。方法调用的结果首先被复制到此表达式的value属性中，然后作为 &lt;code&gt;getValue&lt;/code&gt; 的结果返回。如果已经通过调用 &lt;code&gt;setValue&lt;/code&gt; 或先前调用 &lt;code&gt;getValue&lt;/code&gt; 设置了value属性，则将返回value属性，而无需查找或调用该方法。</target>
        </trans-unit>
        <trans-unit id="a6f8f305677180b918ee9ef198861d8afd741517" translate="yes" xml:space="preserve">
          <source>If the value returned is not &lt;code&gt;null&lt;/code&gt;, it is a &lt;code&gt;Collection&lt;/code&gt; of names. Each name is a &lt;code&gt;String&lt;/code&gt; or a byte array representing a distinguished name (in RFC 2253 or ASN.1 DER encoded form, respectively). Note that the &lt;code&gt;Collection&lt;/code&gt; returned may contain duplicate names.</source>
          <target state="translated">如果返回的值不为 &lt;code&gt;null&lt;/code&gt; ，则它是名称的 &lt;code&gt;Collection&lt;/code&gt; 。每个名称都是代表专有名称的 &lt;code&gt;String&lt;/code&gt; 或字节数组（分别以RFC 2253或ASN.1 DER编码的形式）。请注意，返回的 &lt;code&gt;Collection&lt;/code&gt; 可能包含重复的名称。</target>
        </trans-unit>
        <trans-unit id="d32dd70eeac4617e75643e7232c7906050d5b2bd" translate="yes" xml:space="preserve">
          <source>If the value returned is not &lt;code&gt;null&lt;/code&gt;, it is a &lt;code&gt;Collection&lt;/code&gt; with one entry for each name to be included in the pathToNames criterion. Each entry is a &lt;code&gt;List&lt;/code&gt; whose first entry is an &lt;code&gt;Integer&lt;/code&gt; (the name type, 0-8) and whose second entry is a &lt;code&gt;String&lt;/code&gt; or a byte array (the name, in string or ASN.1 DER encoded form, respectively). There can be multiple names of the same type. Note that the &lt;code&gt;Collection&lt;/code&gt; returned may contain duplicate names (same name and name type).</source>
          <target state="translated">如果返回的值不为 &lt;code&gt;null&lt;/code&gt; ，则它是一个 &lt;code&gt;Collection&lt;/code&gt; ，其中每个名称都有一个条目要包含在pathToNames条件中。每个条目都是一个 &lt;code&gt;List&lt;/code&gt; ,其第一个条目为 &lt;code&gt;Integer&lt;/code&gt; （名称类型，0-8），第二个条目为 &lt;code&gt;String&lt;/code&gt; 或字节数组（名称分别为字符串或ASN.1 DER编码形式）。可以有多个相同类型的名称。请注意，返回的 &lt;code&gt;Collection&lt;/code&gt; 可能包含重复的名称（相同的名称和名称类型）。</target>
        </trans-unit>
        <trans-unit id="d26bd3763c8755d23c2f1916d343c204ac5aaffe" translate="yes" xml:space="preserve">
          <source>If the value returned is not &lt;code&gt;null&lt;/code&gt;, it is a &lt;code&gt;Collection&lt;/code&gt; with one entry for each name to be included in the subject alternative name criterion. Each entry is a &lt;code&gt;List&lt;/code&gt; whose first entry is an &lt;code&gt;Integer&lt;/code&gt; (the name type, 0-8) and whose second entry is a &lt;code&gt;String&lt;/code&gt; or a byte array (the name, in string or ASN.1 DER encoded form, respectively). There can be multiple names of the same type. Note that the &lt;code&gt;Collection&lt;/code&gt; returned may contain duplicate names (same name and name type).</source>
          <target state="translated">如果返回的值不为 &lt;code&gt;null&lt;/code&gt; ，则它是一个 &lt;code&gt;Collection&lt;/code&gt; ，其中每个名称都包含一个条目，要包含在使用者备用名称标准中。每个条目都是一个 &lt;code&gt;List&lt;/code&gt; ,其第一个条目为 &lt;code&gt;Integer&lt;/code&gt; （名称类型，0-8），第二个条目为 &lt;code&gt;String&lt;/code&gt; 或字节数组（名称分别为字符串或ASN.1 DER编码形式）。可以有多个相同类型的名称。请注意，返回的 &lt;code&gt;Collection&lt;/code&gt; 可能包含重复的名称（相同的名称和名称类型）。</target>
        </trans-unit>
        <trans-unit id="174489e8b5c4498b78d97a375b5ea6bab3a43a71" translate="yes" xml:space="preserve">
          <source>If the value returned is not &lt;code&gt;null&lt;/code&gt;, it is a byte array containing a single DER encoded distinguished name, as defined in X.501. The ASN.1 notation for this structure is supplied in the documentation for &lt;a href=&quot;#setIssuer(byte%5B%5D)&quot;&gt;&lt;code&gt;setIssuer(byte [] issuerDN)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果返回的值不为 &lt;code&gt;null&lt;/code&gt; ，则它是一个字节数组，其中包含X.501中定义的单个DER编码的专有名称。&lt;a href=&quot;#setIssuer(byte%5B%5D)&quot;&gt; &lt;code&gt;setIssuer(byte [] issuerDN)&lt;/code&gt; &lt;/a&gt;的文档中提供了此结构的ASN.1表示法。</target>
        </trans-unit>
        <trans-unit id="06d0b31d05f2e63feb86aed4d9a330fd81f56f90" translate="yes" xml:space="preserve">
          <source>If the value returned is not &lt;code&gt;null&lt;/code&gt;, it is a byte array containing a single DER encoded distinguished name, as defined in X.501. The ASN.1 notation for this structure is supplied in the documentation for &lt;a href=&quot;#setSubject(byte%5B%5D)&quot;&gt;&lt;code&gt;setSubject(byte [] subjectDN)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果返回的值不为 &lt;code&gt;null&lt;/code&gt; ，则它是一个字节数组，其中包含X.501中定义的单个DER编码的专有名称。&lt;a href=&quot;#setSubject(byte%5B%5D)&quot;&gt; &lt;code&gt;setSubject(byte [] subjectDN)&lt;/code&gt; &lt;/a&gt;的文档中提供了此结构的ASN.1表示法。</target>
        </trans-unit>
        <trans-unit id="c2adc8f493111a0124aaa2df328143a9d50bda6b" translate="yes" xml:space="preserve">
          <source>If the value returned is not &lt;code&gt;null&lt;/code&gt;, it is a byte array containing a single DER encoded distinguished name, as defined in X.501. The ASN.1 notation for this structure is supplied in the documentation for &lt;a href=&quot;x509certselector#setIssuer-byte:A-&quot;&gt;&lt;code&gt;setIssuer(byte [] issuerDN)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果返回的值不为 &lt;code&gt;null&lt;/code&gt; ，则它是一个字节数组，其中包含X.501中定义的单个DER编码的专有名称。&lt;a href=&quot;x509certselector#setIssuer-byte:A-&quot;&gt; &lt;code&gt;setIssuer(byte [] issuerDN)&lt;/code&gt; &lt;/a&gt;的文档中提供了此结构的ASN.1表示法。</target>
        </trans-unit>
        <trans-unit id="b5bfe0070c603a52728ff84ece5362c0b7ddae9b" translate="yes" xml:space="preserve">
          <source>If the value returned is not &lt;code&gt;null&lt;/code&gt;, it is a byte array containing a single DER encoded distinguished name, as defined in X.501. The ASN.1 notation for this structure is supplied in the documentation for &lt;a href=&quot;x509certselector#setSubject-byte:A-&quot;&gt;&lt;code&gt;setSubject(byte [] subjectDN)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果返回的值不为 &lt;code&gt;null&lt;/code&gt; ，则它是一个字节数组，其中包含X.501中定义的单个DER编码的专有名称。&lt;a href=&quot;x509certselector#setSubject-byte:A-&quot;&gt; &lt;code&gt;setSubject(byte [] subjectDN)&lt;/code&gt; &lt;/a&gt;的文档中提供了此结构的ASN.1表示法。</target>
        </trans-unit>
        <trans-unit id="ce45de7cc21b8ac51cf0ba8fa224985e1d61a9e9" translate="yes" xml:space="preserve">
          <source>If the value returned is not &lt;code&gt;null&lt;/code&gt;, it is a distinguished name, in RFC 2253 format.</source>
          <target state="translated">如果返回的值不为 &lt;code&gt;null&lt;/code&gt; ，则为可分辨名称，格式为RFC 2253。</target>
        </trans-unit>
        <trans-unit id="5b8d5b4ce751bcbd27dc2db355066e723ecb44dc" translate="yes" xml:space="preserve">
          <source>If the value returned is not &lt;code&gt;null&lt;/code&gt;, it is a unmodifiable &lt;code&gt;Collection&lt;/code&gt; of &lt;code&gt;X500Principal&lt;/code&gt;s.</source>
          <target state="translated">如果返回的值不 &lt;code&gt;null&lt;/code&gt; ，这是一个不可修改的 &lt;code&gt;Collection&lt;/code&gt; 的 &lt;code&gt;X500Principal&lt;/code&gt; 的秒。</target>
        </trans-unit>
        <trans-unit id="6566f72aa07086a575c5856c5262b23d64492e56" translate="yes" xml:space="preserve">
          <source>If the value specified to this method is greater than the maximum length for the property the driver may either truncate the value and generate a warning or generate a &lt;code&gt;SQLClientInfoException&lt;/code&gt;. If the driver generates a &lt;code&gt;SQLClientInfoException&lt;/code&gt;, the value specified was not set on the connection.</source>
          <target state="translated">如果为此方法指定的值大于该属性的最大长度，则驱动程序可能会截断该值并生成警告或生成 &lt;code&gt;SQLClientInfoException&lt;/code&gt; 。如果驱动程序生成 &lt;code&gt;SQLClientInfoException&lt;/code&gt; ，则未在连接上设置指定的值。</target>
        </trans-unit>
        <trans-unit id="751e6d0216d0808c1e052a74a279b7c68e16f026" translate="yes" xml:space="preserve">
          <source>If the value supplied is less than the current &lt;code&gt;minimum&lt;/code&gt; or greater than the current &lt;code&gt;maximum - visibleAmount&lt;/code&gt;, then either &lt;code&gt;minimum&lt;/code&gt; or &lt;code&gt;maximum - visibleAmount&lt;/code&gt; is substituted, as appropriate.</source>
          <target state="translated">如果提供的值小于当前的 &lt;code&gt;minimum&lt;/code&gt; 或大于当前的 &lt;code&gt;maximum - visibleAmount&lt;/code&gt; ，那么将酌情替换 &lt;code&gt;minimum&lt;/code&gt; 或 &lt;code&gt;maximum - visibleAmount&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="12fe3656fcca79e989b3edac8aeb79cce5390758" translate="yes" xml:space="preserve">
          <source>If the value supplied is less than the current minimum or greater than the current maximum, then one of those values is substituted, as appropriate.</source>
          <target state="translated">如果所提供的数值小于当前的最小值或大于当前的最大值,则酌情用其中一个数值代替。</target>
        </trans-unit>
        <trans-unit id="0d365fd08bc1c9a61dd923fc4e345493754eacc1" translate="yes" xml:space="preserve">
          <source>If the values for all the longhand properties that compose a particular string are the initial values, then a string consisting of all the initial values should be returned (e.g. a &lt;code&gt;border-width&lt;/code&gt; value of &quot;medium&quot; should be returned as such, not as &quot;&quot;).</source>
          <target state="translated">如果组成一个特定字符串的所有longhand属性的值都是初始值，则应返回一个由所有初始值组成的字符串（例如，应这样返回 &lt;code&gt;border-width&lt;/code&gt; 值&amp;ldquo; medium&amp;rdquo;，而不是&amp;ldquo; &amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="ab17023ef639bf29e49c32902183016851239f29" translate="yes" xml:space="preserve">
          <source>If the values of the width and height arguments are both &lt;code&gt;-1&lt;/code&gt;, this method prepares the image for rendering on the default screen; otherwise, this method prepares an image for rendering on the default screen at the specified width and height.</source>
          <target state="translated">如果width和height参数的值都为 &lt;code&gt;-1&lt;/code&gt; ，则此方法准备在默认屏幕上渲染的图像；否则，此方法准备要在默认屏幕上以指定的宽度和高度呈现的图像。</target>
        </trans-unit>
        <trans-unit id="062fc19b785fff8baef488c9df986bc3034c7cd8" translate="yes" xml:space="preserve">
          <source>If the values of the width and height arguments are both &lt;code&gt;-1&lt;/code&gt;, this method returns the construction status of a screen representation of the specified image in this toolkit. Otherwise, this method returns the construction status of a scaled representation of the image at the specified width and height.</source>
          <target state="translated">如果width和height参数的值均为 &lt;code&gt;-1&lt;/code&gt; ，则此方法返回此工具包中指定图像的屏幕表示的构造状态。否则，此方法将返回指定宽度和高度的图像的缩放表示的构造状态。</target>
        </trans-unit>
        <trans-unit id="31962e30b961885e15e6a668db59bf31ea069bcf" translate="yes" xml:space="preserve">
          <source>If the variable type is &lt;code&gt;float&lt;/code&gt; or &lt;code&gt;double&lt;/code&gt; then atomic update access modes compare values using their bitwise representation (see &lt;a href=&quot;../float#floatToRawIntBits(float)&quot;&gt;&lt;code&gt;Float.floatToRawIntBits(float)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../double#doubleToRawLongBits(double)&quot;&gt;&lt;code&gt;Double.doubleToRawLongBits(double)&lt;/code&gt;&lt;/a&gt;, respectively).</source>
          <target state="translated">如果变量类型是 &lt;code&gt;float&lt;/code&gt; 或 &lt;code&gt;double&lt;/code&gt; ,则原子更新访问模式将使用它们的按位表示形式比较值（分别参见&lt;a href=&quot;../float#floatToRawIntBits(float)&quot;&gt; &lt;code&gt;Float.floatToRawIntBits(float)&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../double#doubleToRawLongBits(double)&quot;&gt; &lt;code&gt;Double.doubleToRawLongBits(double)&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="f203f0949cc7b918d1e2d216ac08216e57175fa4" translate="yes" xml:space="preserve">
          <source>If the variable type is the non-integral &lt;code&gt;boolean&lt;/code&gt; type then a logical AND is performed instead of a bitwise AND.</source>
          <target state="translated">如果变量类型是非整数 &lt;code&gt;boolean&lt;/code&gt; 类型，那么将执行逻辑与，而不是按位与。</target>
        </trans-unit>
        <trans-unit id="317918488b3cba82b42ec854abe818df328b4867" translate="yes" xml:space="preserve">
          <source>If the variable type is the non-integral &lt;code&gt;boolean&lt;/code&gt; type then a logical OR is performed instead of a bitwise OR.</source>
          <target state="translated">如果变量类型是非整数 &lt;code&gt;boolean&lt;/code&gt; 类型，那么将执行逻辑或运算，而不是按位或运算。</target>
        </trans-unit>
        <trans-unit id="8f69ebca5baf035e2d13b6c96c1a80a913bdc9ac" translate="yes" xml:space="preserve">
          <source>If the variable type is the non-integral &lt;code&gt;boolean&lt;/code&gt; type then a logical XOR is performed instead of a bitwise XOR.</source>
          <target state="translated">如果变量类型是非整数 &lt;code&gt;boolean&lt;/code&gt; 类型，那么将执行逻辑XOR而不是按位XOR。</target>
        </trans-unit>
        <trans-unit id="49f80850c03dac4ccd69fe704a52eb909e453d10" translate="yes" xml:space="preserve">
          <source>If the view component of this layer implements &lt;a href=&quot;scrollable&quot;&gt;&lt;code&gt;Scrollable&lt;/code&gt;&lt;/a&gt;, this method delegates its implementation to the view component.</source>
          <target state="translated">如果此层的视图组件实现&lt;a href=&quot;scrollable&quot;&gt; &lt;code&gt;Scrollable&lt;/code&gt; &lt;/a&gt;，则此方法将其实现委托给视图组件。</target>
        </trans-unit>
        <trans-unit id="e6056598d7fc6e1f9bab9fde45ff4e85d32b9431" translate="yes" xml:space="preserve">
          <source>If the view implements &lt;code&gt;Scrollable&lt;/code&gt; a combination of &lt;code&gt;getPreferredScrollableViewportSize&lt;/code&gt;, &lt;code&gt;getScrollableTracksViewportWidth&lt;/code&gt; and &lt;code&gt;getScrollableTracksViewportHeight&lt;/code&gt;is used, otherwise</source>
          <target state="translated">如果视图实现 &lt;code&gt;Scrollable&lt;/code&gt; ， &lt;code&gt;getScrollableTracksViewportWidth&lt;/code&gt; 使用 &lt;code&gt;getPreferredScrollableViewportSize&lt;/code&gt; ，getScrollableTracksViewportWidth和 &lt;code&gt;getScrollableTracksViewportHeight&lt;/code&gt; 的组合，否则使用</target>
        </trans-unit>
        <trans-unit id="6e8e8c7689ef325d78e889713b9aed6e71529da2" translate="yes" xml:space="preserve">
          <source>If the view's size hasn't been explicitly set, return the preferred size, otherwise return the view's current size.</source>
          <target state="translated">如果没有明确设置视图的大小,则返回首选大小,否则返回视图的当前大小。</target>
        </trans-unit>
        <trans-unit id="15a76a9f42e8b551caa02ec901e3cd32d7b99d18" translate="yes" xml:space="preserve">
          <source>If the view's size hasn't been explicitly set, return the preferred size, otherwise return the view's current size. If there is no view, return 0,0.</source>
          <target state="translated">如果没有明确设置视图的大小,返回首选大小,否则返回视图的当前大小。如果没有视图,返回0,0。</target>
        </trans-unit>
        <trans-unit id="80fb55d57fa2a3783b757491a0aafb1381a47c58" translate="yes" xml:space="preserve">
          <source>If the viewport is obscured by an ancestor, stop and repaint the whole viewport.</source>
          <target state="translated">如果视口被祖先遮挡,请停止并重新绘制整个视口。</target>
        </trans-unit>
        <trans-unit id="ac85a1b5c14ea33446482faac76a04c937a42f22" translate="yes" xml:space="preserve">
          <source>If the visible amount supplied is less than &lt;code&gt;one&lt;/code&gt; or greater than the current &lt;code&gt;maximum - minimum&lt;/code&gt;, then either &lt;code&gt;one&lt;/code&gt; or &lt;code&gt;maximum - minimum&lt;/code&gt; is substituted, as appropriate.</source>
          <target state="translated">如果提供的可见量小于 &lt;code&gt;one&lt;/code&gt; 或大于当前 &lt;code&gt;maximum - minimum&lt;/code&gt; ，然后或者 &lt;code&gt;one&lt;/code&gt; 或 &lt;code&gt;maximum - minimum&lt;/code&gt; 被取代时，适当。</target>
        </trans-unit>
        <trans-unit id="c974944a24bc22bfa54c303b025a9e590bd03f10" translate="yes" xml:space="preserve">
          <source>If the visible row count is &amp;lt;= 0, the preferred height is dictated by the number of columns, which will be as many as can fit in the width of the &lt;code&gt;JList&lt;/code&gt; (width / max cell width), with at least one column. The preferred height then becomes the model size / number of columns * maximum cell height. Max cell height is either the fixed cell height, or is determined by iterating through all the cells to find the maximum height from the ListCellRenderer.</source>
          <target state="translated">如果可见行计数&amp;lt;= 0，则首选高度由列数决定，列数将与具有至少一列的 &lt;code&gt;JList&lt;/code&gt; 的宽度（宽度/最大单元格宽度）相适应。然后，首选高度将变为模型大小/列数*最大像元高度。最大像元高度可以是固定像元高度，也可以通过迭代所有像元来确定ListCellRenderer的最大高度来确定。</target>
        </trans-unit>
        <trans-unit id="5f5fba29ff007e49901e18f55046f0713af8526d" translate="yes" xml:space="preserve">
          <source>If the visible row count is greater than zero, the preferredHeight is the maximum cell height * adjustedRowCount. Where visibleRowCount is used to determine the number of columns. Because this lays out horizontally the number of rows is then determined from the column count. For example, lets say you have a model with 10 items and the visible row count is 8. The number of columns needed to display this is 2, but you no longer need 8 rows to display this, you only need 5, thus the adjustedRowCount is 5.</source>
          <target state="translated">如果可见行数大于零,则首选高度(preferredHeight)为最大单元格高度*调整后的RowCount。其中可见行数(visibleRowCount)是用来确定列数的。因为这是在水平方向布局,所以行数是由列数决定的。例如,假设你有一个有10个项目的模型,可见行数是8,显示这个需要的列数是2,但是你不再需要8行来显示这个,你只需要5行,因此adjustedRowCount是5。</target>
        </trans-unit>
        <trans-unit id="af8f2aafa2c4ff83395f11d4e625de90952dbebf" translate="yes" xml:space="preserve">
          <source>If the visible row count is greater than zero, the preferredHeight is the maximum cell height * visibleRowCount. If the visible row count is &amp;lt;= 0, the preferred height is either the current height of the list, or the maximum cell height, whichever is bigger. The preferred width is than the maximum cell width * number of columns needed. Where the number of columns needs is list.height / max cell height. Max cell height is either the fixed cell height, or is determined by iterating through all the cells to find the maximum height from the ListCellRenderer.</source>
          <target state="translated">如果可见行计数大于零，则preferredHeight是最大单元格高度* visibleRowCount。如果可见行计数&amp;lt;= 0，则首选高度是列表的当前高度或最大单元格高度，以较大者为准。首选宽度大于最大单元格宽度*所需的列数。需要的列数是list.height /最大单元格高度。最大像元高度可以是固定像元高度，也可以通过迭代所有像元来确定ListCellRenderer的最大高度来确定。</target>
        </trans-unit>
        <trans-unit id="bde030a57b155127406abe290ea916c308394ff9" translate="yes" xml:space="preserve">
          <source>If the voice is not currently processing a MIDI note, it is considered inactive. A voice is inactive when it has been given no note-on commands, or when every note-on command received has been terminated by a corresponding note-off (or by an &quot;all notes off&quot; message). For example, this happens when a synthesizer capable of playing 16 simultaneous notes is told to play a four-note chord; only four voices are active in this case (assuming no earlier notes are still playing). Usually, a voice whose status is reported as active is producing audible sound, but this is not always true; it depends on the details of the instrument (that is, the synthesis algorithm) and how long the note has been going on. For example, a voice may be synthesizing the sound of a single hand-clap. Because this sound dies away so quickly, it may become inaudible before a note-off message is received. In such a situation, the voice is still considered active even though no sound is currently being produced.</source>
          <target state="translated">如果该声音当前没有处理一个 MIDI 音符,则被认为是不活动的。当一个声音没有收到任何音符开启的命令,或者每一个收到的音符开启的命令都被相应的音符关闭(或 &quot;所有音符关闭 &quot;信息)所终止时,该声音就处于非活动状态。例如,当一个能同时演奏16个音符的合成器被告知要演奏一个4个音符的和弦时,就会发生这种情况;在这种情况下,只有4个声音处于活动状态(假设没有先前的音符还在演奏)。通常,状态被报告为活跃的声音正在产生可听的声音,但这并不总是正确的;它取决于乐器的细节(即合成算法)和音符已经持续了多长时间。例如,一个声音可能正在合成一个单手拍打的声音。由于这个声音消失得很快,所以在收到音符关闭信息之前,可能就听不到了。在这种情况下,尽管目前没有声音产生,但语音仍然被认为是活跃的。</target>
        </trans-unit>
        <trans-unit id="f1b51ec0e550c0c529f4869085fbe1c6f15be1a3" translate="yes" xml:space="preserve">
          <source>If the waiting thread wakes up without dispatching the event, the &lt;code&gt;isDispatched()&lt;/code&gt; method returns &lt;code&gt;false&lt;/code&gt;, and the &lt;code&gt;while&lt;/code&gt; loop executes once more, thus, causing the awakened thread to revert to the waiting mode.</source>
          <target state="translated">如果等待线程在未调度事件的情况下唤醒，则 &lt;code&gt;isDispatched()&lt;/code&gt; 方法将返回 &lt;code&gt;false&lt;/code&gt; ，并且 &lt;code&gt;while&lt;/code&gt; 循环将再次执行，从而使唤醒的线程恢复为等待模式。</target>
        </trans-unit>
        <trans-unit id="eea99a16ca9472ba7577a6286f0c99175c71b6e9" translate="yes" xml:space="preserve">
          <source>If the window and/or its owner are not displayable yet, both of them are made displayable before calculating the preferred size. The Window is validated after its size is being calculated.</source>
          <target state="translated">如果窗口和/或其所有者还不能显示,则在计算首选尺寸之前,它们都将被显示。窗口在计算其大小后被验证。</target>
        </trans-unit>
        <trans-unit id="99602aee7fccb8c26815c6abd3610a017f32754c" translate="yes" xml:space="preserve">
          <source>If the window is secure, then &lt;code&gt;getWarningString&lt;/code&gt; returns &lt;code&gt;null&lt;/code&gt;. If the window is insecure, this method checks for the system property &lt;code&gt;awt.appletWarning&lt;/code&gt; and returns the string value of that property.</source>
          <target state="translated">如果窗口是安全的，则 &lt;code&gt;getWarningString&lt;/code&gt; 返回 &lt;code&gt;null&lt;/code&gt; 。如果窗口不安全，则此方法检查系统属性 &lt;code&gt;awt.appletWarning&lt;/code&gt; 并返回该属性的字符串值。</target>
        </trans-unit>
        <trans-unit id="5a7732dc7a32e7541fda0d87428f498a5f17066e" translate="yes" xml:space="preserve">
          <source>If the windowing system supports the &lt;a href=&quot;graphicsdevice.windowtranslucency#PERPIXEL_TRANSLUCENT&quot;&gt;&lt;code&gt;PERPIXEL_TRANSLUCENT&lt;/code&gt;&lt;/a&gt; translucency, the alpha component of the given background color may effect the mode of operation for this window: it indicates whether this window must be opaque (alpha equals &lt;code&gt;1.0f&lt;/code&gt;) or per-pixel translucent (alpha is less than &lt;code&gt;1.0f&lt;/code&gt;). If the given background color is &lt;code&gt;null&lt;/code&gt;, the window is considered completely opaque.</source>
          <target state="translated">如果窗口系统支持&lt;a href=&quot;graphicsdevice.windowtranslucency#PERPIXEL_TRANSLUCENT&quot;&gt; &lt;code&gt;PERPIXEL_TRANSLUCENT&lt;/code&gt; &lt;/a&gt;半透明，则给定背景色的alpha分量可能会影响该窗口的操作模式：它指示该窗口必须是不透明的（alpha等于 &lt;code&gt;1.0f&lt;/code&gt; ）还是每像素半透明的（alpha小于大于 &lt;code&gt;1.0f&lt;/code&gt; ）。如果给定的背景色为 &lt;code&gt;null&lt;/code&gt; ，则该窗口被视为完全不透明。</target>
        </trans-unit>
        <trans-unit id="653f1f40cfb615ca17661dd80259d388f697bee1" translate="yes" xml:space="preserve">
          <source>If the write lock is acquired by the current thread then the lock hold count is set to one.</source>
          <target state="translated">如果写锁被当前线程获取,那么锁的保持数就会被设置为1。</target>
        </trans-unit>
        <trans-unit id="0805140ae31a0f4050f9a4cfea06b4f470819eca" translate="yes" xml:space="preserve">
          <source>If the write lock is acquired then the value &lt;code&gt;true&lt;/code&gt; is returned and the write lock hold count is set to one.</source>
          <target state="translated">如果获取了写锁，则返回值 &lt;code&gt;true&lt;/code&gt; ，并且将写锁保持计数设置为1。</target>
        </trans-unit>
        <trans-unit id="a07048d034065274e4ede5c8a84bad27f47aabea" translate="yes" xml:space="preserve">
          <source>If the write lock is held by another thread then the current thread becomes disabled for thread scheduling purposes and lies dormant until one of three things happens:</source>
          <target state="translated">如果写锁被另一个线程持有,那么当前线程就会因为线程调度的目的而被禁用,并处于休眠状态,直到三种情况之一发生。</target>
        </trans-unit>
        <trans-unit id="74ef7c44b070eb1cc369e6589e8a1122f0468708" translate="yes" xml:space="preserve">
          <source>If the write lock is held by another thread then the current thread becomes disabled for thread scheduling purposes and lies dormant until one of two things happens:</source>
          <target state="translated">如果写锁被另一个线程持有,那么当前线程就会因为线程调度的目的而被禁用,并处于休眠状态,直到两种情况之一发生。</target>
        </trans-unit>
        <trans-unit id="4fbef50e47f6976d0537a04edb35c78320ba5006" translate="yes" xml:space="preserve">
          <source>If the write lock is held by another thread then the current thread becomes disabled for thread scheduling purposes and lies dormant until the read lock has been acquired.</source>
          <target state="translated">如果写锁被另一个线程持有,那么当前线程就会因为线程调度的目的而被禁用,并处于休眠状态,直到读锁被获取。</target>
        </trans-unit>
        <trans-unit id="30ab94fb63654ae631cd1d744ae39fbebb43dde7" translate="yes" xml:space="preserve">
          <source>If the write lock is held by another thread then this method will return immediately with the value &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果写锁由另一个线程持有，则此方法将立即返回 &lt;code&gt;false&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="7ef816b7e6153a6a58cc075b78ddfa153cbea13c" translate="yes" xml:space="preserve">
          <source>If the writer only offers a single, mandatory form of compression, it is not necessary to provide any named compression types. Named compression types should only be used where the user is able to make a meaningful choice between different schemes.</source>
          <target state="translated">如果编写者只提供单一的、强制性的压缩形式,则没有必要提供任何命名的压缩类型。只有在用户能够在不同的方案之间作出有意义的选择时,才应使用命名的压缩类型。</target>
        </trans-unit>
        <trans-unit id="3d7d2702baf6e372c2fd974b9ceb0e8765e0573d" translate="yes" xml:space="preserve">
          <source>If the years field is present, return its value as an &lt;code&gt;int&lt;/code&gt;, else return &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">如果存在years字段，则以 &lt;code&gt;int&lt;/code&gt; 形式返回其值，否则返回 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7cb2436b74f4b1b03e972c41f1699a7b257b5b16" translate="yes" xml:space="preserve">
          <source>If the zone ID consists of a single letter, the zone ID is invalid and &lt;code&gt;DateTimeException&lt;/code&gt; is thrown.</source>
          <target state="translated">如果区域ID由一个字母组成，则该区域ID无效，并引发 &lt;code&gt;DateTimeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="06d35c94a78d00be0bce80775b09f94dc2815e57" translate="yes" xml:space="preserve">
          <source>If the zone ID equals 'GMT', 'UTC' or 'UT' then the result is a &lt;code&gt;ZoneId&lt;/code&gt; with the same ID and rules equivalent to &lt;code&gt;ZoneOffset.UTC&lt;/code&gt;.</source>
          <target state="translated">如果区域ID等于'GMT'，'UTC'或'UT'，则结果是具有相同ID 的 &lt;code&gt;ZoneId&lt;/code&gt; 和等效于 &lt;code&gt;ZoneOffset.UTC&lt;/code&gt; 的规则。</target>
        </trans-unit>
        <trans-unit id="7be309d5b31d6d9fd94ee00c0bd12eacb646dab8" translate="yes" xml:space="preserve">
          <source>If the zone ID equals 'Z', the result is &lt;code&gt;ZoneOffset.UTC&lt;/code&gt;.</source>
          <target state="translated">如果区域ID等于&amp;ldquo; Z&amp;rdquo;，则结果为 &lt;code&gt;ZoneOffset.UTC&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="87e6092693d13cc8dfc7ff32db6b3e49ec91630a" translate="yes" xml:space="preserve">
          <source>If the zone ID is a &lt;a href=&quot;zoneoffset&quot;&gt;&lt;code&gt;ZoneOffset&lt;/code&gt;&lt;/a&gt;, then the result always has a time of midnight.</source>
          <target state="translated">如果区域ID是&lt;a href=&quot;zoneoffset&quot;&gt; &lt;code&gt;ZoneOffset&lt;/code&gt; &lt;/a&gt;，则结果始终为午夜时间。</target>
        </trans-unit>
        <trans-unit id="4b48da9c9e601217a4f5ae92f654428afda6e1aa" translate="yes" xml:space="preserve">
          <source>If the zone ID is not available or is a &lt;code&gt;ZoneOffset&lt;/code&gt; then the format is complete.</source>
          <target state="translated">如果区域ID不可用或为 &lt;code&gt;ZoneOffset&lt;/code&gt; ,则格式已完成。</target>
        </trans-unit>
        <trans-unit id="cb96bf777d809e7b3490ab730d9c70ee13ec5673" translate="yes" xml:space="preserve">
          <source>If the zone ID starts with '+' or '-', the ID is parsed as a &lt;code&gt;ZoneOffset&lt;/code&gt; using &lt;a href=&quot;zoneoffset#of(java.lang.String)&quot;&gt;&lt;code&gt;ZoneOffset.of(String)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果区域ID以'+'或'-' &lt;code&gt;ZoneOffset&lt;/code&gt; 使用&lt;a href=&quot;zoneoffset#of(java.lang.String)&quot;&gt; &lt;code&gt;ZoneOffset.of(String)&lt;/code&gt; &lt;/a&gt;将ID解析为ZoneOffset。</target>
        </trans-unit>
        <trans-unit id="87677aa24c82d7da48f53ccb0c5b3d24a805cbe9" translate="yes" xml:space="preserve">
          <source>If the zone ID starts with '+' or '-', the ID is parsed as a &lt;code&gt;ZoneOffset&lt;/code&gt; using &lt;a href=&quot;zoneoffset#of-java.lang.String-&quot;&gt;&lt;code&gt;ZoneOffset.of(String)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果区域ID以'+'或'-' &lt;code&gt;ZoneOffset&lt;/code&gt; 使用&lt;a href=&quot;zoneoffset#of-java.lang.String-&quot;&gt; &lt;code&gt;ZoneOffset.of(String)&lt;/code&gt; &lt;/a&gt;将ID解析为ZoneOffset。</target>
        </trans-unit>
        <trans-unit id="602223c8f8d238b617198cc90ea4b499d3a80171" translate="yes" xml:space="preserve">
          <source>If the zone ID starts with 'UTC+', 'UTC-', 'GMT+', 'GMT-', 'UT+' or 'UT-' then the ID is a prefixed offset-based ID. The ID is split in two, with a two or three letter prefix and a suffix starting with the sign. The suffix is parsed as a &lt;a href=&quot;zoneoffset#of(java.lang.String)&quot;&gt;&lt;code&gt;ZoneOffset&lt;/code&gt;&lt;/a&gt;. The result will be a &lt;code&gt;ZoneId&lt;/code&gt; with the specified UTC/GMT/UT prefix and the normalized offset ID as per &lt;a href=&quot;zoneoffset#getId()&quot;&gt;&lt;code&gt;ZoneOffset.getId()&lt;/code&gt;&lt;/a&gt;. The rules of the returned &lt;code&gt;ZoneId&lt;/code&gt; will be equivalent to the parsed &lt;code&gt;ZoneOffset&lt;/code&gt;.</source>
          <target state="translated">如果区域ID以'UTC +'，'UTC-'，'GMT +'，'GMT-'，'UT +'或'UT-'开头，则该ID为基于偏移的前缀ID。ID分为两部分，前缀为两个或三个字母，后缀以符号开头。后缀被解析为&lt;a href=&quot;zoneoffset#of(java.lang.String)&quot;&gt; &lt;code&gt;ZoneOffset&lt;/code&gt; &lt;/a&gt;。其结果将是一个 &lt;code&gt;ZoneId&lt;/code&gt; 与指定UTC / GMT / UT前缀和归一化偏置按照ID &lt;a href=&quot;zoneoffset#getId()&quot;&gt; &lt;code&gt;ZoneOffset.getId()&lt;/code&gt; &lt;/a&gt;。返回的 &lt;code&gt;ZoneId&lt;/code&gt; 的规则将等效于解析的 &lt;code&gt;ZoneOffset&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1780773eff7ca92ecd4ba03a3e8ea655fd0b8589" translate="yes" xml:space="preserve">
          <source>If the zone ID starts with 'UTC+', 'UTC-', 'GMT+', 'GMT-', 'UT+' or 'UT-' then the ID is a prefixed offset-based ID. The ID is split in two, with a two or three letter prefix and a suffix starting with the sign. The suffix is parsed as a &lt;a href=&quot;zoneoffset#of-java.lang.String-&quot;&gt;&lt;code&gt;ZoneOffset&lt;/code&gt;&lt;/a&gt;. The result will be a &lt;code&gt;ZoneId&lt;/code&gt; with the specified UTC/GMT/UT prefix and the normalized offset ID as per &lt;a href=&quot;zoneoffset#getId--&quot;&gt;&lt;code&gt;ZoneOffset.getId()&lt;/code&gt;&lt;/a&gt;. The rules of the returned &lt;code&gt;ZoneId&lt;/code&gt; will be equivalent to the parsed &lt;code&gt;ZoneOffset&lt;/code&gt;.</source>
          <target state="translated">如果区域ID以'UTC +'，'UTC-'，'GMT +'，'GMT-'，'UT +'或'UT-'开头，则该ID为基于偏移的前缀ID。 ID分为两部分，前缀为两个或三个字母，后缀以符号开头。后缀被解析为&lt;a href=&quot;zoneoffset#of-java.lang.String-&quot;&gt; &lt;code&gt;ZoneOffset&lt;/code&gt; &lt;/a&gt;。其结果将是一个 &lt;code&gt;ZoneId&lt;/code&gt; 与指定UTC / GMT / UT前缀和归一化偏置按照ID &lt;a href=&quot;zoneoffset#getId--&quot;&gt; &lt;code&gt;ZoneOffset.getId()&lt;/code&gt; &lt;/a&gt;。返回的 &lt;code&gt;ZoneId&lt;/code&gt; 的规则将等效于解析的 &lt;code&gt;ZoneOffset&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="41b8bc898e51c548630ae4313953f5a0179fbf8d" translate="yes" xml:space="preserve">
          <source>If the zone cannot be parsed then an exception is thrown unless the section of the formatter is optional.</source>
          <target state="translated">如果区域不能被解析,那么就会抛出一个异常,除非格式器的部分是可选的。</target>
        </trans-unit>
        <trans-unit id="716de69875ef09bdf51d065ceec30a6b7a11919e" translate="yes" xml:space="preserve">
          <source>If the zone defines daylight savings into the future, then the list will normally be of size two and hold information about entering and exiting daylight savings. If the zone does not have daylight savings, or information about future changes is uncertain, then the list will be empty.</source>
          <target state="translated">如果该区定义了未来的夏令时,那么列表的大小通常为 2,并保存有关进入和退出夏令时的信息。如果该区没有设置夏令时,或者有关未来变化的信息不确定,那么列表将为空。</target>
        </trans-unit>
        <trans-unit id="a223a21923ebbbeb7ae1d7b22472f2e489ded7a7" translate="yes" xml:space="preserve">
          <source>If there are any calendar fields whose values haven't been set in the selected field combination, &lt;code&gt;Calendar&lt;/code&gt; uses their default values. The default value of each field may vary by concrete calendar systems. For example, in &lt;code&gt;GregorianCalendar&lt;/code&gt;, the default of a field is the same as that of the start of the Epoch: i.e., &lt;code&gt;YEAR = 1970&lt;/code&gt;, &lt;code&gt;MONTH =
 JANUARY&lt;/code&gt;, &lt;code&gt;DAY_OF_MONTH = 1&lt;/code&gt;, etc.</source>
          <target state="translated">如果在所选字段组合中未设置任何日历字段，则&amp;ldquo; &lt;code&gt;Calendar&lt;/code&gt; 将使用其默认值。每个字段的默认值可能会因具体的日历系统而异。例如，在 &lt;code&gt;GregorianCalendar&lt;/code&gt; 中，字段的默认值与纪元开始的默认值相同：即 &lt;code&gt;YEAR = 1970&lt;/code&gt; ， &lt;code&gt;MONTH = JANUARY&lt;/code&gt; ， &lt;code&gt;DAY_OF_MONTH = 1&lt;/code&gt; 等。</target>
        </trans-unit>
        <trans-unit id="2f3668df86278c8a1e88d94210aa98ee6165c605" translate="yes" xml:space="preserve">
          <source>If there are any previously existing preferences that conflict with the preference being set here, then the GSSManager should ignore this request.</source>
          <target state="translated">如果有任何先前存在的偏好与这里设置的偏好冲突,那么GSSManager应该忽略这个请求。</target>
        </trans-unit>
        <trans-unit id="74ff37baa980c0a61132f301ce21852b4bc130d4" translate="yes" xml:space="preserve">
          <source>If there are bytes following the module descriptor then it is implementation specific as to whether those bytes are read, ignored, or reported as an &lt;code&gt;InvalidModuleDescriptorException&lt;/code&gt;. If this method fails with an &lt;code&gt;InvalidModuleDescriptorException&lt;/code&gt; or &lt;code&gt;
 IOException&lt;/code&gt; then it may do so after some, but not all, bytes have been read from the input stream. It is strongly recommended that the stream be promptly closed and discarded if an exception occurs.</source>
          <target state="translated">如果模块描述符后面有字节，则它是特定于实现的，这些字节是否被读取，忽略或报告为 &lt;code&gt;InvalidModuleDescriptorException&lt;/code&gt; 。如果此方法失败，并显示 &lt;code&gt;InvalidModuleDescriptorException&lt;/code&gt; 或 &lt;code&gt; IOException&lt;/code&gt; ,则在从输入流中读取了一些（但不是全部）字节之后，它可能会这样做。强烈建议在发生异常时立即关闭流并将其丢弃。</target>
        </trans-unit>
        <trans-unit id="92b113a4ce2494a131747fc911a67441d1d05a57" translate="yes" xml:space="preserve">
          <source>If there are bytes following the module descriptor then it is implementation specific as to whether those bytes are read, ignored, or reported as an &lt;code&gt;InvalidModuleDescriptorException&lt;/code&gt;. If this method fails with an &lt;code&gt;InvalidModuleDescriptorException&lt;/code&gt; then it may do so after some, but not all, bytes have been read.</source>
          <target state="translated">如果模块描述符后面有字节，则它是特定于实现的，这些字节是否被读取，忽略或报告为 &lt;code&gt;InvalidModuleDescriptorException&lt;/code&gt; 。如果此方法失败，并显示 &lt;code&gt;InvalidModuleDescriptorException&lt;/code&gt; ,则可能在读取了一些（但不是全部）字节之后这样做。</target>
        </trans-unit>
        <trans-unit id="e1f64fb5716e07724c0a7d48c0a02647c58da231" translate="yes" xml:space="preserve">
          <source>If there are conflicts or overlaps between the information provided by different &lt;code&gt;BeanInfo&lt;/code&gt; objects, the current &lt;code&gt;BeanInfo&lt;/code&gt; object takes priority over the additional &lt;code&gt;BeanInfo&lt;/code&gt; objects. Array elements with higher indices take priority over the elements with lower indices.</source>
          <target state="translated">如果不同的 &lt;code&gt;BeanInfo&lt;/code&gt; 对象提供的信息之间存在冲突或重叠，则当前 &lt;code&gt;BeanInfo&lt;/code&gt; 对象将优先于其他 &lt;code&gt;BeanInfo&lt;/code&gt; 对象。具有较高索引的数组元素优先于具有较低索引的元素。</target>
        </trans-unit>
        <trans-unit id="530a00d062bd6f003dc671b04ddaa979158f274f" translate="yes" xml:space="preserve">
          <source>If there are different resources for different countries, you can make specializations: for example, &quot;MyResources_de_CH&quot; contains objects for the German language (de) in Switzerland (CH). If you want to only modify some of the resources in the specialization, you can do so.</source>
          <target state="translated">如果不同的国家有不同的资源,您可以进行专门化:例如,&quot;MyResources_de_CH &quot;包含瑞士(CH)的德语(de)对象。如果您只想修改专业化中的某些资源,您可以这样做。</target>
        </trans-unit>
        <trans-unit id="43c5f52ef558689fc38e846808ccf12921cc7008" translate="yes" xml:space="preserve">
          <source>If there are mnemonic names to be associated with the legal data values for the tag, &lt;a href=&quot;#addValueName(int,java.lang.String)&quot;&gt;&lt;code&gt;addValueName()&lt;/code&gt;&lt;/a&gt; should be called on the new instance for each name. Mnemonic names apply only to tags which have integral data type.</source>
          <target state="translated">如果有助记符名称与标记的合法数据值相关联，则应在新实例上为每个名称调用&lt;a href=&quot;#addValueName(int,java.lang.String)&quot;&gt; &lt;code&gt;addValueName()&lt;/code&gt; &lt;/a&gt;。助记符名称仅适用于具有整数数据类型的标签。</target>
        </trans-unit>
        <trans-unit id="0a003779b8a649ef8cb40c3f51dd00ab52590b8c" translate="yes" xml:space="preserve">
          <source>If there are more arguments than format specifiers, the extra arguments are ignored.</source>
          <target state="translated">如果有比格式指定符更多的参数,额外的参数将被忽略。</target>
        </trans-unit>
        <trans-unit id="af82728ab0f3eefda7b3d99ca5d34ea41f8be9f9" translate="yes" xml:space="preserve">
          <source>If there are more than one node in the actual result, the single node returned might not be the first in document order.</source>
          <target state="translated">如果实际结果中有多个节点,返回的单个节点可能不是文档顺序中的第一个节点。</target>
        </trans-unit>
        <trans-unit id="f3bf8d2720860eb61e319f9623619d679a6a03d2" translate="yes" xml:space="preserve">
          <source>If there are more than one node in the actual result, the single node returned will be the first in document order.</source>
          <target state="translated">如果实际结果中有多个节点,则返回的单个节点将是文档顺序中的第一个节点。</target>
        </trans-unit>
        <trans-unit id="deb195b2b9fae2539cd1155fb241509f69b8a781" translate="yes" xml:space="preserve">
          <source>If there are multiple compression types but none has been set, an &lt;code&gt;IllegalStateException&lt;/code&gt; is thrown.</source>
          <target state="translated">如果有多种压缩类型但未设置任何压缩类型，则抛出 &lt;code&gt;IllegalStateException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="768dcb3e70295dbb108fd5dd725293766667ea22" translate="yes" xml:space="preserve">
          <source>If there are multiple runs of text, information about the runs can be accessed by indexing to get the start, limit, and level of a run. The level represents both the direction and the 'nesting level' of a directional run. Odd levels are right-to-left, while even levels are left-to-right. So for example level 0 represents left-to-right text, while level 1 represents right-to-left text, and level 2 represents left-to-right text embedded in a right-to-left run.</source>
          <target state="translated">如果有多个文本的运行,可以通过索引来获取运行的起始、极限和级别等信息。级别既代表方向,也代表定向运行的 &quot;嵌套级别&quot;。奇数级别是从右到左,而偶数级别是从左到右。所以例如0级代表从左到右的文本,而1级代表从右到左的文本,2级代表从左到右的文本嵌入到从右到左的运行中。</target>
        </trans-unit>
        <trans-unit id="95fa2c7c9d03744e4ab294e05332429d827cf658" translate="yes" xml:space="preserve">
          <source>If there are multiple text directions present in the associated document, a flag indicating the caret bias will be rendered. This will occur only if the associated document is a subclass of AbstractDocument and there are multiple bidi levels present in the bidi element structure (i.e. the text has multiple directions associated with it).</source>
          <target state="translated">如果关联的文档中存在多个文本方向,则会呈现一个标志,指示小节偏向。只有当关联的文档是AbstractDocument的子类,并且bidi元素结构中存在多个bidi级别时,才会出现这种情况(即文本有多个方向关联)。</target>
        </trans-unit>
        <trans-unit id="8a6ca385a1344a83e96b59363dfacd7ef2452f9f" translate="yes" xml:space="preserve">
          <source>If there are native methods in the call stack at the time of the exception, there are important restrictions to note about the returned catch location. In such cases, it is not possible to predict whether an exception will be handled by some native method on the call stack. Thus, it is possible that exceptions considered uncaught here will, in fact, be handled by a native method and not cause termination of the target VM. Furthermore, it cannot be assumed that the catch location returned here will ever be reached by the throwing thread. If there is a native frame between the current location and the catch location, the exception might be handled and cleared in that native method instead.</source>
          <target state="translated">如果在异常发生时,调用栈中存在本地方法,那么返回的捕获位置有重要的限制。在这种情况下,不可能预测异常是否会被调用栈中的某个本地方法处理。因此,这里认为未捕获的异常有可能事实上会被本地方法处理,而不会导致目标 VM 的终止。此外,不能假设这里返回的捕获位置会被抛出的线程到达。如果在当前位置和捕获位置之间有一个本地框架,那么异常可能会被该本地方法处理和清除。</target>
        </trans-unit>
        <trans-unit id="91aa0c8a84bbac8b5804b3100754fe9bb7d1dcbe" translate="yes" xml:space="preserve">
          <source>If there are no bytes buffered on the socket, and the socket has not been closed using &lt;a href=&quot;#close()&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;../io/inputstream#available()&quot;&gt;&lt;code&gt;available&lt;/code&gt;&lt;/a&gt; will return &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">如果套接字上没有缓冲字节，并且尚未使用&lt;a href=&quot;#close()&quot;&gt; &lt;code&gt;close&lt;/code&gt; &lt;/a&gt;关闭套接字，那么&lt;a href=&quot;../io/inputstream#available()&quot;&gt; &lt;code&gt;available&lt;/code&gt; &lt;/a&gt;将返回 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d3fd8782c948e6644afcfe2c7b88c23640ca646b" translate="yes" xml:space="preserve">
          <source>If there are no bytes buffered on the socket, and the socket has not been closed using &lt;a href=&quot;socket#close--&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;../io/inputstream#available--&quot;&gt;&lt;code&gt;available&lt;/code&gt;&lt;/a&gt; will return &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">如果套接字上没有缓冲字节，并且尚未使用&lt;a href=&quot;socket#close--&quot;&gt; &lt;code&gt;close&lt;/code&gt; &lt;/a&gt;关闭套接字，那么&lt;a href=&quot;../io/inputstream#available--&quot;&gt; &lt;code&gt;available&lt;/code&gt; &lt;/a&gt;将返回 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="899f5685138aa94e92de9d02a27528d96a112601" translate="yes" xml:space="preserve">
          <source>If there are no bytes buffered on the socket, or all buffered bytes have been consumed by &lt;a href=&quot;../io/inputstream#read()&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt;, then all subsequent calls to &lt;a href=&quot;../io/inputstream#read()&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; will throw an &lt;a href=&quot;../io/ioexception&quot;&gt;&lt;code&gt;IOException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果套接字上没有缓冲字节，或者&lt;a href=&quot;../io/inputstream#read()&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt;已使用所有缓冲字节，则随后的所有&lt;a href=&quot;../io/inputstream#read()&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt;调用都将抛出&lt;a href=&quot;../io/ioexception&quot;&gt; &lt;code&gt;IOException&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="70808ff13ea15a635fe9933aa430b40622465ff0" translate="yes" xml:space="preserve">
          <source>If there are no bytes buffered on the socket, or all buffered bytes have been consumed by &lt;a href=&quot;../io/inputstream#read--&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt;, then all subsequent calls to &lt;a href=&quot;../io/inputstream#read--&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; will throw an &lt;a href=&quot;../io/ioexception&quot;&gt;&lt;code&gt;IOException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果套接字上没有缓冲字节，或者所有缓冲字节都已被&lt;a href=&quot;../io/inputstream#read--&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt;占用，则所有后续的&lt;a href=&quot;../io/inputstream#read--&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt;调用都将抛出&lt;a href=&quot;../io/ioexception&quot;&gt; &lt;code&gt;IOException&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d97fea5e3b07fef354727bb8ea01358071cedc12" translate="yes" xml:space="preserve">
          <source>If there are no fields in the descriptor, then an empty String is returned.</source>
          <target state="translated">如果描述符中没有字段,则返回一个空字符串。</target>
        </trans-unit>
        <trans-unit id="a5d1f0a062afbc6cda49f87f90c8e9a1acb2dd5c" translate="yes" xml:space="preserve">
          <source>If there are no fini functions, the loop return type is &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">如果没有fini函数，则循环返回类型为 &lt;code&gt;void&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="452463b6bb8122e8d19b3e5165c3baa6dd891166" translate="yes" xml:space="preserve">
          <source>If there are no originating elements, none need to be passed. This information may be used in an incremental environment to determine the need to rerun processors or remove generated files. Non-incremental environments may ignore the originating element information.</source>
          <target state="translated">如果没有起源元素,则不需要传递任何元素。该信息可在增量环境中用于确定是否需要重新运行处理器或删除生成的文件。非增量环境可能会忽略起源元素信息。</target>
        </trans-unit>
        <trans-unit id="2d1b6e296a2b77ef070997fd74f624d1c0686a93" translate="yes" xml:space="preserve">
          <source>If there are no parameters, no formatter is used.</source>
          <target state="translated">如果没有参数,则不使用格式器。</target>
        </trans-unit>
        <trans-unit id="256816c6b5677c8691bdb94b6765ccbc5f24a09f" translate="yes" xml:space="preserve">
          <source>If there are several such threads, the bootstrap method may be invoked in several threads concurrently. Therefore, bootstrap methods which access global application data must take the usual precautions against race conditions. In any case, every &lt;code&gt;invokedynamic&lt;/code&gt; instruction is either unlinked or linked to a unique &lt;code&gt;CallSite&lt;/code&gt; object.</source>
          <target state="translated">如果有多个这样的线程，则可以在多个线程中同时调用bootstrap方法。因此，访问全局应用程序数据的引导方法必须采取通常的预防措施以防出现竞争状况。无论如何，每条 &lt;code&gt;invokedynamic&lt;/code&gt; 指令都是未链接的或链接到唯一的 &lt;code&gt;CallSite&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="19df7c3245481a0b870f8b690f97116f667d21a7" translate="yes" xml:space="preserve">
          <source>If there are specialization prefixes for all arguments, the arity prefix may be left out (as in &lt;a href=&quot;objintconsumer&quot;&gt;&lt;code&gt;ObjIntConsumer&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">如果所有参数都有专门化前缀，则可以省略arity前缀（如&lt;a href=&quot;objintconsumer&quot;&gt; &lt;code&gt;ObjIntConsumer&lt;/code&gt; 所示&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="5496a27b9238a94964b622c624cac4a711b3706d" translate="yes" xml:space="preserve">
          <source>If there are two sets of quotes, a specific begin-quote must be matched by its corresponding end-quote.</source>
          <target state="translated">如果有两组引号,特定的开始引号必须与其对应的结束引号相匹配。</target>
        </trans-unit>
        <trans-unit id="f6d2e2287b3f940a2108e0447a31bf2c4dae6c7e" translate="yes" xml:space="preserve">
          <source>If there is a &lt;a href=&quot;linkageerror&quot;&gt;linkage error&lt;/a&gt; accessing the nest host, or if this class or interface is not enumerated as a member of the nest by the nest host, then it is considered to belong to its own nest and &lt;code&gt;this&lt;/code&gt; is returned as the host.</source>
          <target state="translated">如果有一个&lt;a href=&quot;linkageerror&quot;&gt;链接错误&lt;/a&gt;访问巢主机，或者如果该类或接口不枚举由主机窝巢的一员，那么它被认为属于自己的窝和 &lt;code&gt;this&lt;/code&gt; 返回的主机。</target>
        </trans-unit>
        <trans-unit id="60fe5e1f14261b51420b2f4800ed45295f2b7b43" translate="yes" xml:space="preserve">
          <source>If there is a &lt;code&gt;Filter&lt;/code&gt;, its &lt;code&gt;isLoggable&lt;/code&gt; method is called to check if the given log record is loggable. If not we return. Otherwise the given record is copied into an internal circular buffer. Then the record's level property is compared with the &lt;code&gt;pushLevel&lt;/code&gt;. If the given level is greater than or equal to the &lt;code&gt;pushLevel&lt;/code&gt; then &lt;code&gt;push&lt;/code&gt; is called to write all buffered records to the target output &lt;code&gt;Handler&lt;/code&gt;.</source>
          <target state="translated">如果存在 &lt;code&gt;Filter&lt;/code&gt; ，则调用其 &lt;code&gt;isLoggable&lt;/code&gt; 方法以检查给定的日志记录是否可记录。如果没有，我们返回。否则，给定的记录将被复制到内部循环缓冲区中。然后将记录的level属性与 &lt;code&gt;pushLevel&lt;/code&gt; 进行比较。如果给定级别大于或等于 &lt;code&gt;pushLevel&lt;/code&gt; ,则调用 &lt;code&gt;push&lt;/code&gt; 将所有缓冲记录写入目标输出 &lt;code&gt;Handler&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c5dab46b4549ff2feda5be50fc66d249aaffc422" translate="yes" xml:space="preserve">
          <source>If there is a &lt;code&gt;ParseException&lt;/code&gt; in converting the current value to a String, this will set the text to an empty String, and mark the &lt;code&gt;JFormattedTextField&lt;/code&gt; as being in an invalid state.</source>
          <target state="translated">如果在将当前值转换为String时存在 &lt;code&gt;ParseException&lt;/code&gt; ，这会将文本设置为空String，并将 &lt;code&gt;JFormattedTextField&lt;/code&gt; 标记为处于无效状态。</target>
        </trans-unit>
        <trans-unit id="8264923428e93189de3d9488f3d02a8d83fd11ec" translate="yes" xml:space="preserve">
          <source>If there is a character stream specified, the SAX parser will ignore any byte stream and will not attempt to open a URI connection to the system identifier.</source>
          <target state="translated">如果指定了字符流,SAX解析器将忽略任何字节流,并且不会尝试打开与系统标识符的URI连接。</target>
        </trans-unit>
        <trans-unit id="41cf28f3b00327296b2da5a55e1ed9b510e74f92" translate="yes" xml:space="preserve">
          <source>If there is a charset definition specified as a parameter of the content type specification, it will be used when loading input streams using the associated &lt;code&gt;EditorKit&lt;/code&gt;. For example if the type is specified as &lt;code&gt;text/html; charset=EUC-JP&lt;/code&gt; the content will be loaded using the &lt;code&gt;EditorKit&lt;/code&gt; registered for &lt;code&gt;text/html&lt;/code&gt; and the Reader provided to the &lt;code&gt;EditorKit&lt;/code&gt; to load unicode into the document will use the &lt;code&gt;EUC-JP&lt;/code&gt; charset for translating to unicode. If the type is not recognized, the content will be loaded using the &lt;code&gt;EditorKit&lt;/code&gt; registered for plain text, &lt;code&gt;text/plain&lt;/code&gt;.</source>
          <target state="translated">如果指定了字符集定义作为内容类型规范的参数，则在使用关联的 &lt;code&gt;EditorKit&lt;/code&gt; 加载输入流时将使用它。例如，如果类型指定为 &lt;code&gt;text/html; charset=EUC-JP&lt;/code&gt; ，将使用为 &lt;code&gt;text/html&lt;/code&gt; 注册的 &lt;code&gt;EditorKit&lt;/code&gt; 加载内容，提供给 &lt;code&gt;EditorKit&lt;/code&gt; 的Reader将unicode加载到文档中，将使用 &lt;code&gt;EUC-JP&lt;/code&gt; charset转换为unicode。如果无法识别类型，将使用为纯文本 &lt;code&gt;text/plain&lt;/code&gt; 注册的 &lt;code&gt;EditorKit&lt;/code&gt; 加载内容。</target>
        </trans-unit>
        <trans-unit id="e0a6d33db9099e5da02b63b1c08b711314ed1070" translate="yes" xml:space="preserve">
          <source>If there is a current output stream then the &lt;code&gt;Formatter&lt;/code&gt;'s tail string is written and the stream is flushed and closed. Then the output stream is replaced with the new output stream.</source>
          <target state="translated">如果有当前输出流，那么将写入 &lt;code&gt;Formatter&lt;/code&gt; 的尾字符串，然后刷新并关闭该流。然后，将输出流替换为新的输出流。</target>
        </trans-unit>
        <trans-unit id="360eb0e694f70b9c0d8a6d2539b8b95168589f9b" translate="yes" xml:space="preserve">
          <source>If there is a language tag which matches completely to a language range above, the language tag is returned.</source>
          <target state="translated">如果有一个语言标签与上面的语言范围完全匹配,则返回语言标签。</target>
        </trans-unit>
        <trans-unit id="7fe9d5f4f323a99adea908fdeaf0c559a2234dc4" translate="yes" xml:space="preserve">
          <source>If there is a positive entry that grants a principal a particular permission, and a negative entry that denies the principal the same permission, the result is as though the permission was never granted or denied.</source>
          <target state="translated">如果有一个积极的条目授予委托人一个特定的许可,而一个消极的条目拒绝给予委托人同样的许可,结果就好像从未授予或拒绝过该许可一样。</target>
        </trans-unit>
        <trans-unit id="b820edb0cd4651acfa98bad6a1adbcc5b12aee0a" translate="yes" xml:space="preserve">
          <source>If there is a public subclass representing the type of &lt;code&gt;XMLStructure&lt;/code&gt;, it is returned as an instance of that class (ex: a &lt;code&gt;SignatureProperties&lt;/code&gt; element would be returned as an instance of &lt;a href=&quot;signatureproperties&quot;&gt;&lt;code&gt;SignatureProperties&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">如果存在一个表示 &lt;code&gt;XMLStructure&lt;/code&gt; 类型的公共子类，则将其作为该类的实例返回（例如： &lt;code&gt;SignatureProperties&lt;/code&gt; 元素将作为&lt;a href=&quot;signatureproperties&quot;&gt; &lt;code&gt;SignatureProperties&lt;/code&gt; &lt;/a&gt;的实例返回）。</target>
        </trans-unit>
        <trans-unit id="9a0ac9d4b223e6ba398b5c03bdbdea908d2e6008" translate="yes" xml:space="preserve">
          <source>If there is a public subclass representing the type of &lt;code&gt;XMLStructure&lt;/code&gt;, it is returned as an instance of that class (ex: an &lt;code&gt;X509Data&lt;/code&gt; element would be returned as an instance of &lt;a href=&quot;x509data&quot;&gt;&lt;code&gt;X509Data&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">如果存在表示 &lt;code&gt;XMLStructure&lt;/code&gt; 类型的公共子类，则将其作为该类的实例返回（例如： &lt;code&gt;X509Data&lt;/code&gt; 元素将作为&lt;a href=&quot;x509data&quot;&gt; &lt;code&gt;X509Data&lt;/code&gt; &lt;/a&gt;的实例返回）。</target>
        </trans-unit>
        <trans-unit id="7d2642219ae6689a90935a889cec5cc47e6b73a4" translate="yes" xml:space="preserve">
          <source>If there is a security manager already installed, this method first calls the security manager's &lt;code&gt;checkPermission&lt;/code&gt; method with a &lt;code&gt;RuntimePermission(&quot;setSecurityManager&quot;)&lt;/code&gt; permission to ensure it's ok to replace the existing security manager. This may result in throwing a &lt;code&gt;SecurityException&lt;/code&gt;.</source>
          <target state="translated">如果已经安装了安全管理器，则此方法首先使用 &lt;code&gt;RuntimePermission(&quot;setSecurityManager&quot;)&lt;/code&gt; 权限调用安全管理器的 &lt;code&gt;checkPermission&lt;/code&gt; 方法，以确保可以替换现有的安全管理器。这可能导致抛出 &lt;code&gt;SecurityException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="34d939280196d74fc1d1d34c5817d26280f87f75" translate="yes" xml:space="preserve">
          <source>If there is a security manager already installed, this method first calls the security manager's &lt;code&gt;checkPermission&lt;/code&gt; method with the &lt;code&gt;RuntimePermission(&quot;createSecurityManager&quot;)&lt;/code&gt; permission to ensure the calling thread has permission to create a new security manager. This may result in throwing a &lt;code&gt;SecurityException&lt;/code&gt;.</source>
          <target state="translated">如果已经安装了安全管理器，则此方法首先使用 &lt;code&gt;RuntimePermission(&quot;createSecurityManager&quot;)&lt;/code&gt; 权限调用安全管理器的 &lt;code&gt;checkPermission&lt;/code&gt; 方法，以确保调用线程具有创建新安全管理器的权限。这可能导致抛出 &lt;code&gt;SecurityException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5672428ce2d0310db13a3f85f67e993338e8598a" translate="yes" xml:space="preserve">
          <source>If there is a security manager and &lt;code&gt;host&lt;/code&gt; is not null and &lt;code&gt;host.length() &lt;/code&gt; is not equal to zero, the security manager's &lt;code&gt;checkConnect&lt;/code&gt; method is called with the hostname and &lt;code&gt;-1&lt;/code&gt; as its arguments to see if the operation is allowed.</source>
          <target state="translated">如果存在安全管理器且 &lt;code&gt;host&lt;/code&gt; 不为null且 &lt;code&gt;host.length() &lt;/code&gt; 不等于零，则以主机名和 &lt;code&gt;-1&lt;/code&gt; 作为其参数调用安全管理器的 &lt;code&gt;checkConnect&lt;/code&gt; 方法，以查看是否允许该操作。</target>
        </trans-unit>
        <trans-unit id="aa68b021538f0471826642ff3267e740630d422f" translate="yes" xml:space="preserve">
          <source>If there is a security manager and this lookup does not have &lt;a href=&quot;#hasFullPrivilegeAccess()&quot;&gt;full privilege access&lt;/a&gt;, its &lt;code&gt;checkPermission&lt;/code&gt; method is first called to check &lt;code&gt;RuntimePermission(&quot;defineClass&quot;)&lt;/code&gt;.</source>
          <target state="translated">如果存在安全管理器，并且此查找没有&lt;a href=&quot;#hasFullPrivilegeAccess()&quot;&gt;完全特权访问权&lt;/a&gt;，则首先调用其 &lt;code&gt;checkPermission&lt;/code&gt; 方法以检查 &lt;code&gt;RuntimePermission(&quot;defineClass&quot;)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fd5ff852f368770ab762748f1c19d1dda73aa1db" translate="yes" xml:space="preserve">
          <source>If there is a security manager installed, it can forbid the lookup on various grounds (&lt;a href=&quot;methodhandles.lookup#secmgr&quot;&gt;see below&lt;/a&gt;). By contrast, the &lt;code&gt;ldc&lt;/code&gt; instruction on a &lt;code&gt;CONSTANT_MethodHandle&lt;/code&gt; constant is not subject to security manager checks.</source>
          <target state="translated">如果安装了安全管理器，则可以出于各种原因禁止查找（&lt;a href=&quot;methodhandles.lookup#secmgr&quot;&gt;请参阅下文&lt;/a&gt;）。相反， &lt;code&gt;CONSTANT_MethodHandle&lt;/code&gt; 常量上的 &lt;code&gt;ldc&lt;/code&gt; 指令不受安全管理器检查。</target>
        </trans-unit>
        <trans-unit id="b156cc02a90506f8eb9b81ce87ad4e2f4f5e01f7" translate="yes" xml:space="preserve">
          <source>If there is a security manager installed, its &lt;code&gt;checkAccess&lt;/code&gt; method is called with &lt;code&gt;this&lt;/code&gt; as its argument. This may result in a &lt;code&gt;SecurityException&lt;/code&gt; being raised (in the current thread).</source>
          <target state="translated">如果安装了安全管理，它 &lt;code&gt;checkAccess&lt;/code&gt; 方法被调用 &lt;code&gt;this&lt;/code&gt; 作为其参数。这可能会导致引发 &lt;code&gt;SecurityException&lt;/code&gt; （在当前线程中）。</target>
        </trans-unit>
        <trans-unit id="5128105dcb411eeec7bd98eb31dc6c9f32f36396" translate="yes" xml:space="preserve">
          <source>If there is a security manager installed, this method first calls the security manager's &lt;code&gt;checkPermission&lt;/code&gt; method with a &lt;code&gt;SerializablePermission(&quot;enableSubclassImplementation&quot;)&lt;/code&gt; permission to ensure it's ok to enable subclassing.</source>
          <target state="translated">如果安装了安全管理器，则此方法首先使用 &lt;code&gt;SerializablePermission(&quot;enableSubclassImplementation&quot;)&lt;/code&gt; 权限调用安全管理器的 &lt;code&gt;checkPermission&lt;/code&gt; 方法，以确保可以启用子类。</target>
        </trans-unit>
        <trans-unit id="31761f6c70fa775cd9eb51012f53c8d7db6b5b68" translate="yes" xml:space="preserve">
          <source>If there is a security manager installed, this method first calls the security manager's &lt;code&gt;checkPermission&lt;/code&gt; method with the &lt;code&gt;SerializablePermission(&quot;enableSubclassImplementation&quot;)&lt;/code&gt; permission to ensure it's ok to enable subclassing.</source>
          <target state="translated">如果安装了安全管理器，则此方法首先使用 &lt;code&gt;SerializablePermission(&quot;enableSubclassImplementation&quot;)&lt;/code&gt; 权限调用安全管理器的 &lt;code&gt;checkPermission&lt;/code&gt; 方法，以确保可以启用子类化。</target>
        </trans-unit>
        <trans-unit id="d92f5c22aaa435017a22a7870a8799131bb3b4bf" translate="yes" xml:space="preserve">
          <source>If there is a security manager set then its &lt;a href=&quot;../../../java.base/java/lang/securitymanager#checkRead(java.io.FileDescriptor)&quot;&gt;&lt;code&gt;checkRead&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../../java.base/java/lang/securitymanager#checkWrite(java.io.FileDescriptor)&quot;&gt;&lt;code&gt;checkWrite&lt;/code&gt;&lt;/a&gt; methods are invoked to check that the caller has permission to both read from and write to the file descriptor.</source>
          <target state="translated">如果设置了安全管理器，&lt;a href=&quot;../../../java.base/java/lang/securitymanager#checkWrite(java.io.FileDescriptor)&quot;&gt; &lt;code&gt;checkWrite&lt;/code&gt; &lt;/a&gt;调用其&lt;a href=&quot;../../../java.base/java/lang/securitymanager#checkRead(java.io.FileDescriptor)&quot;&gt; &lt;code&gt;checkRead&lt;/code&gt; &lt;/a&gt;和checkWrite方法以检查调用方是否具有读取和写入文件描述符的权限。</target>
        </trans-unit>
        <trans-unit id="5e92b1005890b8e36b5a3e3ec1d22670527621dc" translate="yes" xml:space="preserve">
          <source>If there is a security manager set then its &lt;a href=&quot;../securitymanager#checkPermission(java.security.Permission)&quot;&gt;&lt;code&gt;checkPermission&lt;/code&gt;&lt;/a&gt; method is invoked to check that the caller has been granted &lt;a href=&quot;../runtimepermission&quot;&gt;&lt;code&gt;RuntimePermission(&quot;accessSystemModules&quot;)&lt;/code&gt;&lt;/a&gt; to access the system modules.</source>
          <target state="translated">如果设置了安全管理器，则将调用其&lt;a href=&quot;../securitymanager#checkPermission(java.security.Permission)&quot;&gt; &lt;code&gt;checkPermission&lt;/code&gt; &lt;/a&gt;方法来检查是否已授予调用方&lt;a href=&quot;../runtimepermission&quot;&gt; &lt;code&gt;RuntimePermission(&quot;accessSystemModules&quot;)&lt;/code&gt; &lt;/a&gt;以访问系统模块。</target>
        </trans-unit>
        <trans-unit id="3db3bf435e3205478cee741a5d2c93114bf55e60" translate="yes" xml:space="preserve">
          <source>If there is a security manager set, and this socket is &lt;a href=&quot;#isBound()&quot;&gt;bound&lt;/a&gt;, its &lt;code&gt;checkConnect&lt;/code&gt; method is called with the local address and &lt;code&gt;-1&lt;/code&gt; as its arguments to see if the operation is allowed. If the operation is not allowed, an &lt;code&gt;InetAddress&lt;/code&gt; representing the &lt;a href=&quot;inetaddress#getLoopbackAddress()&quot;&gt;&lt;code&gt;loopback&lt;/code&gt;&lt;/a&gt; address is returned as the implementation address.</source>
          <target state="translated">如果设置了安全管理器，并且&lt;a href=&quot;#isBound()&quot;&gt;绑定了&lt;/a&gt;此套接字，则将使用本地地址并以 &lt;code&gt;-1&lt;/code&gt; 作为其参数来调用其 &lt;code&gt;checkConnect&lt;/code&gt; 方法，以查看是否允许该操作。如果不允许该操作，则将表示&lt;a href=&quot;inetaddress#getLoopbackAddress()&quot;&gt; &lt;code&gt;loopback&lt;/code&gt; &lt;/a&gt;地址的 &lt;code&gt;InetAddress&lt;/code&gt; 作为实现地址返回。</target>
        </trans-unit>
        <trans-unit id="b86d00a2babbd52f7023cffa0fd1499e014ec134" translate="yes" xml:space="preserve">
          <source>If there is a security manager set, it is invoked to check &lt;code&gt;AWTPermission(&quot;showWindowWithoutWarningBanner&quot;)&lt;/code&gt;. If that check fails with a &lt;code&gt;SecurityException&lt;/code&gt; then a warning banner is created.</source>
          <target state="translated">如果设置了安全管理器，则会调用它来检查 &lt;code&gt;AWTPermission(&quot;showWindowWithoutWarningBanner&quot;)&lt;/code&gt; 。如果该检查失败并显示 &lt;code&gt;SecurityException&lt;/code&gt; ,则会创建一个警告标语。</target>
        </trans-unit>
        <trans-unit id="64d3f1b6faeb8fe10d38810363c8cc48f8921c9d" translate="yes" xml:space="preserve">
          <source>If there is a security manager set, its &lt;code&gt;checkConnect&lt;/code&gt; method is called with the local address and &lt;code&gt;-1&lt;/code&gt; as its arguments to see if the operation is allowed. If the operation is not allowed, a &lt;code&gt;SocketAddress&lt;/code&gt; representing the &lt;a href=&quot;../../net/inetaddress#getLoopbackAddress()&quot;&gt;&lt;code&gt;loopback&lt;/code&gt;&lt;/a&gt; address and the local port of the channel's socket is returned.</source>
          <target state="translated">如果设置了安全管理器，则使用本地地址并以 &lt;code&gt;-1&lt;/code&gt; 作为其参数来调用其 &lt;code&gt;checkConnect&lt;/code&gt; 方法，以查看是否允许该操作。如果不允许该操作，则返回表示&lt;a href=&quot;../../net/inetaddress#getLoopbackAddress()&quot;&gt; &lt;code&gt;loopback&lt;/code&gt; &lt;/a&gt;地址和通道套接字本地端口的 &lt;code&gt;SocketAddress&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="efeea28b8db5bdbdbe7665022456615ea9a2a02a" translate="yes" xml:space="preserve">
          <source>If there is a security manager set, its &lt;code&gt;checkConnect&lt;/code&gt; method is called with the local address and &lt;code&gt;-1&lt;/code&gt; as its arguments to see if the operation is allowed. If the operation is not allowed, a &lt;code&gt;SocketAddress&lt;/code&gt; representing the &lt;a href=&quot;../../net/inetaddress#getLoopbackAddress--&quot;&gt;&lt;code&gt;loopback&lt;/code&gt;&lt;/a&gt; address and the local port of the channel's socket is returned.</source>
          <target state="translated">如果设置了安全管理器，则使用本地地址并以 &lt;code&gt;-1&lt;/code&gt; 作为其参数来调用其 &lt;code&gt;checkConnect&lt;/code&gt; 方法，以查看是否允许该操作。如果不允许该操作，则返回表示&lt;a href=&quot;../../net/inetaddress#getLoopbackAddress--&quot;&gt; &lt;code&gt;loopback&lt;/code&gt; &lt;/a&gt;地址和通道套接字本地端口的 &lt;code&gt;SocketAddress&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="314e1e1967331821237d640541c5b0e1313b59bd" translate="yes" xml:space="preserve">
          <source>If there is a security manager set, its &lt;code&gt;checkConnect&lt;/code&gt; method is called with the local address and &lt;code&gt;-1&lt;/code&gt; as its arguments to see if the operation is allowed. If the operation is not allowed, a &lt;code&gt;SocketAddress&lt;/code&gt; representing the &lt;a href=&quot;inetaddress#getLoopbackAddress()&quot;&gt;&lt;code&gt;loopback&lt;/code&gt;&lt;/a&gt; address and the local port to which the socket is bound is returned.</source>
          <target state="translated">如果设置了安全管理器，则使用本地地址并以 &lt;code&gt;-1&lt;/code&gt; 作为其参数来调用其 &lt;code&gt;checkConnect&lt;/code&gt; 方法，以查看是否允许该操作。如果不允许该操作，则返回表示&lt;a href=&quot;inetaddress#getLoopbackAddress()&quot;&gt; &lt;code&gt;loopback&lt;/code&gt; &lt;/a&gt;地址和套接字绑定到的本地端口的 &lt;code&gt;SocketAddress&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c7de07e801ccd99c1e04407e222cb2fc9764b11a" translate="yes" xml:space="preserve">
          <source>If there is a security manager set, its &lt;code&gt;checkConnect&lt;/code&gt; method is called with the local address and &lt;code&gt;-1&lt;/code&gt; as its arguments to see if the operation is allowed. If the operation is not allowed, a &lt;code&gt;SocketAddress&lt;/code&gt; representing the &lt;a href=&quot;inetaddress#getLoopbackAddress()&quot;&gt;&lt;code&gt;loopback&lt;/code&gt;&lt;/a&gt; address and the local port to which this socket is bound is returned.</source>
          <target state="translated">如果设置了安全管理器，则使用本地地址并以 &lt;code&gt;-1&lt;/code&gt; 作为其参数来调用其 &lt;code&gt;checkConnect&lt;/code&gt; 方法，以查看是否允许该操作。如果不允许该操作，则返回一个表示&lt;a href=&quot;inetaddress#getLoopbackAddress()&quot;&gt; &lt;code&gt;loopback&lt;/code&gt; &lt;/a&gt;地址的 &lt;code&gt;SocketAddress&lt;/code&gt; 和此套接字绑定到的本地端口。</target>
        </trans-unit>
        <trans-unit id="bd4504e52760544f5802fe95b384c420e8994a88" translate="yes" xml:space="preserve">
          <source>If there is a security manager set, its &lt;code&gt;checkConnect&lt;/code&gt; method is called with the local address and &lt;code&gt;-1&lt;/code&gt; as its arguments to see if the operation is allowed. If the operation is not allowed, a &lt;code&gt;SocketAddress&lt;/code&gt; representing the &lt;a href=&quot;inetaddress#getLoopbackAddress--&quot;&gt;&lt;code&gt;loopback&lt;/code&gt;&lt;/a&gt; address and the local port to which the socket is bound is returned.</source>
          <target state="translated">如果设置了安全管理器，则使用本地地址并以 &lt;code&gt;-1&lt;/code&gt; 作为其参数来调用其 &lt;code&gt;checkConnect&lt;/code&gt; 方法，以查看是否允许该操作。如果不允许该操作，则返回表示&lt;a href=&quot;inetaddress#getLoopbackAddress--&quot;&gt; &lt;code&gt;loopback&lt;/code&gt; &lt;/a&gt;地址和套接字绑定到的本地端口的 &lt;code&gt;SocketAddress&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3e9d7c04bc4d0c36452207dc47930704ce6c96d6" translate="yes" xml:space="preserve">
          <source>If there is a security manager set, its &lt;code&gt;checkConnect&lt;/code&gt; method is called with the local address and &lt;code&gt;-1&lt;/code&gt; as its arguments to see if the operation is allowed. If the operation is not allowed, a &lt;code&gt;SocketAddress&lt;/code&gt; representing the &lt;a href=&quot;inetaddress#getLoopbackAddress--&quot;&gt;&lt;code&gt;loopback&lt;/code&gt;&lt;/a&gt; address and the local port to which this socket is bound is returned.</source>
          <target state="translated">如果设置了安全管理器，则使用本地地址并以 &lt;code&gt;-1&lt;/code&gt; 作为其参数来调用其 &lt;code&gt;checkConnect&lt;/code&gt; 方法，以查看是否允许该操作。如果不允许操作，一个 &lt;code&gt;SocketAddress&lt;/code&gt; 的代表&lt;a href=&quot;inetaddress#getLoopbackAddress--&quot;&gt; &lt;code&gt;loopback&lt;/code&gt; &lt;/a&gt;地址和其返回此套接字绑定到的本地端口。</target>
        </trans-unit>
        <trans-unit id="d707ade497c4fb2f188d76f169d44a01ba531e6e" translate="yes" xml:space="preserve">
          <source>If there is a security manager set, its &lt;code&gt;checkConnect&lt;/code&gt; method is called with the local address and &lt;code&gt;-1&lt;/code&gt; as its arguments to see if the operation is allowed. If the operation is not allowed, an &lt;code&gt;InetAddress&lt;/code&gt; representing the &lt;a href=&quot;inetaddress#getLoopbackAddress()&quot;&gt;&lt;code&gt;loopback&lt;/code&gt;&lt;/a&gt; address is returned as the implementation address.</source>
          <target state="translated">如果设置了安全管理器，则使用本地地址并以 &lt;code&gt;-1&lt;/code&gt; 作为其参数来调用其 &lt;code&gt;checkConnect&lt;/code&gt; 方法，以查看是否允许该操作。如果不允许该操作，则将表示&lt;a href=&quot;inetaddress#getLoopbackAddress()&quot;&gt; &lt;code&gt;loopback&lt;/code&gt; &lt;/a&gt;地址的 &lt;code&gt;InetAddress&lt;/code&gt; 作为实现地址返回。</target>
        </trans-unit>
        <trans-unit id="d2186903b27dd0e412d3c41bc56df02edfa54b96" translate="yes" xml:space="preserve">
          <source>If there is a security manager set, its &lt;code&gt;checkConnect&lt;/code&gt; method is called with the local address and &lt;code&gt;-1&lt;/code&gt; as its arguments to see if the operation is allowed. If the operation is not allowed, an &lt;code&gt;InetAddress&lt;/code&gt; representing the &lt;a href=&quot;inetaddress#getLoopbackAddress--&quot;&gt;&lt;code&gt;loopback&lt;/code&gt;&lt;/a&gt; address is returned as the implementation address.</source>
          <target state="translated">如果设置了安全管理器，则使用本地地址并以 &lt;code&gt;-1&lt;/code&gt; 作为其参数来调用其 &lt;code&gt;checkConnect&lt;/code&gt; 方法，以查看是否允许该操作。如果不允许该操作，则将表示&lt;a href=&quot;inetaddress#getLoopbackAddress--&quot;&gt; &lt;code&gt;loopback&lt;/code&gt; &lt;/a&gt;地址的 &lt;code&gt;InetAddress&lt;/code&gt; 作为实现地址返回。</target>
        </trans-unit>
        <trans-unit id="b7859548d6fe21c1371c700ba9e5a16a116554b8" translate="yes" xml:space="preserve">
          <source>If there is a security manager set, its &lt;code&gt;checkConnect&lt;/code&gt; method is called with the local address and &lt;code&gt;-1&lt;/code&gt; as its arguments to see if the operation is allowed. If the operation is not allowed, the &lt;a href=&quot;inetaddress#getLoopbackAddress()&quot;&gt;&lt;code&gt;loopback&lt;/code&gt;&lt;/a&gt; address is returned.</source>
          <target state="translated">如果设置了安全管理器，则使用本地地址并以 &lt;code&gt;-1&lt;/code&gt; 作为其参数来调用其 &lt;code&gt;checkConnect&lt;/code&gt; 方法，以查看是否允许该操作。如果不允许该操作，则返回&lt;a href=&quot;inetaddress#getLoopbackAddress()&quot;&gt; &lt;code&gt;loopback&lt;/code&gt; &lt;/a&gt;地址。</target>
        </trans-unit>
        <trans-unit id="e5eea39d0bafa27479de1740d6a3bd033e70cc0a" translate="yes" xml:space="preserve">
          <source>If there is a security manager set, its &lt;code&gt;checkConnect&lt;/code&gt; method is called with the local address and &lt;code&gt;-1&lt;/code&gt; as its arguments to see if the operation is allowed. If the operation is not allowed, the &lt;a href=&quot;inetaddress#getLoopbackAddress--&quot;&gt;&lt;code&gt;loopback&lt;/code&gt;&lt;/a&gt; address is returned.</source>
          <target state="translated">如果设置了安全管理器，则使用本地地址并以 &lt;code&gt;-1&lt;/code&gt; 作为其参数来调用其 &lt;code&gt;checkConnect&lt;/code&gt; 方法，以查看是否允许该操作。如果不允许该操作，则返回&lt;a href=&quot;inetaddress#getLoopbackAddress--&quot;&gt; &lt;code&gt;loopback&lt;/code&gt; &lt;/a&gt;地址。</target>
        </trans-unit>
        <trans-unit id="c4393236d40a93051b0ea6d79cd37ab06006e55e" translate="yes" xml:space="preserve">
          <source>If there is a security manager then its &lt;a href=&quot;../../../java.base/java/lang/securitymanager#checkPermission(java.security.Permission)&quot;&gt;&lt;code&gt;checkPermission&lt;/code&gt;&lt;/a&gt; method is called to check &lt;code&gt;AWTPermission(&quot;accessEventQueue&quot;)&lt;/code&gt;.</source>
          <target state="translated">如果存在安全管理器，则调用其&lt;a href=&quot;../../../java.base/java/lang/securitymanager#checkPermission(java.security.Permission)&quot;&gt; &lt;code&gt;checkPermission&lt;/code&gt; &lt;/a&gt;方法以检查 &lt;code&gt;AWTPermission(&quot;accessEventQueue&quot;)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bcd0ea8c723035f1f68d96d6ce02d00d5e694624" translate="yes" xml:space="preserve">
          <source>If there is a security manager then its &lt;code&gt;checkPermission&lt;/code&gt; method if first called with a &lt;code&gt;RuntimePermission(&quot;getClassLoader&quot;)&lt;/code&gt; permission to check that the caller is allowed to get access to the class loader.</source>
          <target state="translated">如果有安全管理器，则首先使用 &lt;code&gt;RuntimePermission(&quot;getClassLoader&quot;)&lt;/code&gt; 权限调用其 &lt;code&gt;checkPermission&lt;/code&gt; 方法，以检查是否允许调用者访问类加载器。</target>
        </trans-unit>
        <trans-unit id="975b403d7a17640c61b22b1fe12733ab70ac0406" translate="yes" xml:space="preserve">
          <source>If there is a security manager then its &lt;code&gt;checkPermission&lt;/code&gt; method is called with a &lt;code&gt;RuntimePermission(&quot;getClassLoader&quot;)&lt;/code&gt; permission to check that the caller is allowed to get access to the class loader.</source>
          <target state="translated">如果存在安全管理器，则使用 &lt;code&gt;RuntimePermission(&quot;getClassLoader&quot;)&lt;/code&gt; 权限调用其 &lt;code&gt;checkPermission&lt;/code&gt; 方法，以检查是否允许调用者访问类加载器。</target>
        </trans-unit>
        <trans-unit id="70274ada9a62f6bd34849b3ea45696f8033443f7" translate="yes" xml:space="preserve">
          <source>If there is a security manager then the class loader created by this method will load classes and resources with privileges that are restricted by the calling context of this method.</source>
          <target state="translated">如果有安全管理器,那么本方法创建的类加载器将加载具有被本方法调用上下文限制的权限的类和资源。</target>
        </trans-unit>
        <trans-unit id="f21f2cb00e18158e239acee5b75d0e9108e9c70d" translate="yes" xml:space="preserve">
          <source>If there is a security manager then the class loaders created by this method will load classes and resources with privileges that are restricted by the calling context of this method.</source>
          <target state="translated">如果有安全管理器,那么由该方法创建的类加载器将加载具有被该方法调用上下文限制的权限的类和资源。</target>
        </trans-unit>
        <trans-unit id="501526fb9b9e2e222246e9cd9786ee96d321d66c" translate="yes" xml:space="preserve">
          <source>If there is a security manager, a packet cannot be received if the security manager's &lt;code&gt;checkAccept&lt;/code&gt; method does not allow it.</source>
          <target state="translated">如果存在安全管理器，则在安全管理器的 &lt;code&gt;checkAccept&lt;/code&gt; 方法不允许的情况下无法接收数据包。</target>
        </trans-unit>
        <trans-unit id="8d8ccd4fade79b52387ca219cceec58d9c7bfd0d" translate="yes" xml:space="preserve">
          <source>If there is a security manager, an &lt;a href=&quot;inquireseccontextpermission&quot;&gt;&lt;code&gt;InquireSecContextPermission&lt;/code&gt;&lt;/a&gt; with the name &lt;code&gt;type.mech&lt;/code&gt; must be granted. Otherwise, this could result in a &lt;a href=&quot;../../../../../java.base/java/lang/securityexception&quot;&gt;&lt;code&gt;SecurityException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果有安全管理器，&lt;a href=&quot;inquireseccontextpermission&quot;&gt; &lt;code&gt;InquireSecContextPermission&lt;/code&gt; &lt;/a&gt;名为 &lt;code&gt;type.mech&lt;/code&gt; 必须被授予。否则，这可能会导致&lt;a href=&quot;../../../../../java.base/java/lang/securityexception&quot;&gt; &lt;code&gt;SecurityException&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dfbfad4dd09ad7ea7b2126cee4029ecba6ab2815" translate="yes" xml:space="preserve">
          <source>If there is a security manager, and &lt;code&gt;host&lt;/code&gt; is not &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;host.length() &lt;/code&gt; is not equal to zero, the security manager's &lt;code&gt;checkConnect&lt;/code&gt; method is called with the hostname and &lt;code&gt;-1&lt;/code&gt; as its arguments to determine if the operation is allowed.</source>
          <target state="translated">如果存在安全管理器，并且 &lt;code&gt;host&lt;/code&gt; 不为 &lt;code&gt;null&lt;/code&gt; 或 &lt;code&gt;host.length() &lt;/code&gt; 不等于零，那么将使用主机名和 &lt;code&gt;-1&lt;/code&gt; 作为其参数来调用安全管理器的 &lt;code&gt;checkConnect&lt;/code&gt; 方法，以确定是否允许该操作。</target>
        </trans-unit>
        <trans-unit id="9cc5fcc49e4c5f23df1182ea1b133caeed726d61" translate="yes" xml:space="preserve">
          <source>If there is a security manager, and the socket is not currently connected to a remote address, a packet cannot be received if the security manager's &lt;code&gt;checkAccept&lt;/code&gt; method does not allow it. Datagrams that are not permitted by the security manager are silently discarded.</source>
          <target state="translated">如果有安全管理器，并且套接字当前未连接到远程地址，则在安全管理器的 &lt;code&gt;checkAccept&lt;/code&gt; 方法不允许的情况下无法接收数据包。安全管理器不允许的数据报将被静默丢弃。</target>
        </trans-unit>
        <trans-unit id="78bc0f4a72c52e6defa54f26456df6b6bfdcd359" translate="yes" xml:space="preserve">
          <source>If there is a security manager, and the socket is not currently connected to a remote address, this method first performs some security checks. First, if &lt;code&gt;p.getAddress().isMulticastAddress()&lt;/code&gt; is true, this method calls the security manager's &lt;code&gt;checkMulticast&lt;/code&gt; method with &lt;code&gt;p.getAddress()&lt;/code&gt; as its argument. If the evaluation of that expression is false, this method instead calls the security manager's &lt;code&gt;checkConnect&lt;/code&gt; method with arguments &lt;code&gt;p.getAddress().getHostAddress()&lt;/code&gt; and &lt;code&gt;p.getPort()&lt;/code&gt;. Each call to a security manager method could result in a SecurityException if the operation is not allowed.</source>
          <target state="translated">如果有安全管理器，并且套接字当前未连接到远程地址，则此方法首先执行一些安全检查。首先，如果 &lt;code&gt;p.getAddress().isMulticastAddress()&lt;/code&gt; 是真实的，这个方法调用安全管理器的 &lt;code&gt;checkMulticast&lt;/code&gt; 方法与 &lt;code&gt;p.getAddress()&lt;/code&gt; 作为参数。如果对该表达式的求值为假，则此方法使用参数 &lt;code&gt;p.getAddress().getHostAddress()&lt;/code&gt; &lt;code&gt;p.getPort()&lt;/code&gt; 和p.getPort（）调用安全管理器的 &lt;code&gt;checkConnect&lt;/code&gt; 方法。如果不允许该操作，则对安全管理器方法的每次调用都可能导致SecurityException。</target>
        </trans-unit>
        <trans-unit id="5f2dc991bc054662c9aaf92a4f81920cc42b0299" translate="yes" xml:space="preserve">
          <source>If there is a security manager, and this thread is not the current thread, then the security manager's &lt;code&gt;checkPermission&lt;/code&gt; method is called with a &lt;code&gt;RuntimePermission(&quot;getStackTrace&quot;)&lt;/code&gt; permission to see if it's ok to get the stack trace.</source>
          <target state="translated">如果存在安全管理器，并且该线程不是当前线程，则使用 &lt;code&gt;RuntimePermission(&quot;getStackTrace&quot;)&lt;/code&gt; 权限调用安全管理器的 &lt;code&gt;checkPermission&lt;/code&gt; 方法，以查看是否可以获取堆栈跟踪。</target>
        </trans-unit>
        <trans-unit id="d1b98d766cc337fb9898419e46a662c7d8de062a" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;a href=&quot;securitymanager#checkAccess(java.lang.ThreadGroup)&quot;&gt;&lt;code&gt;checkAccess&lt;/code&gt;&lt;/a&gt; method is invoked with the ThreadGroup as its argument.</source>
          <target state="translated">如果存在安全管理器，则将其ThreadGroup作为其参数来调用其&lt;a href=&quot;securitymanager#checkAccess(java.lang.ThreadGroup)&quot;&gt; &lt;code&gt;checkAccess&lt;/code&gt; &lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="9414114a34df41ef68dcd065db4f4c005b486dbe" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;a href=&quot;securitymanager#checkAccess-java.lang.ThreadGroup-&quot;&gt;&lt;code&gt;checkAccess&lt;/code&gt;&lt;/a&gt; method is invoked with the ThreadGroup as its argument.</source>
          <target state="translated">如果存在安全管理器，则将其ThreadGroup作为其参数来调用其&lt;a href=&quot;securitymanager#checkAccess-java.lang.ThreadGroup-&quot;&gt; &lt;code&gt;checkAccess&lt;/code&gt; &lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="7fd4592e446f7faba341b06f36e03f193c3eabf7" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;a href=&quot;securitymanager#checkCreateClassLoader()&quot;&gt;&lt;code&gt;checkCreateClassLoader&lt;/code&gt;&lt;/a&gt; method is invoked. This may result in a security exception.</source>
          <target state="translated">如果有安全管理器，则调用其&lt;a href=&quot;securitymanager#checkCreateClassLoader()&quot;&gt; &lt;code&gt;checkCreateClassLoader&lt;/code&gt; &lt;/a&gt;方法。这可能会导致安全异常。</target>
        </trans-unit>
        <trans-unit id="3533ff6ee33a3d65c462d1050b52aa5438f30879" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;a href=&quot;securitymanager#checkCreateClassLoader--&quot;&gt;&lt;code&gt;&lt;code&gt;checkCreateClassLoader&lt;/code&gt;&lt;/code&gt;&lt;/a&gt; method is invoked. This may result in a security exception.</source>
          <target state="translated">如果有安全管理器，则调用其&lt;a href=&quot;securitymanager#checkCreateClassLoader--&quot;&gt; &lt;code&gt;&lt;code&gt;checkCreateClassLoader&lt;/code&gt;&lt;/code&gt; &lt;/a&gt;方法。这可能会导致安全异常。</target>
        </trans-unit>
        <trans-unit id="eab087ce5a6c8b2fb5dba3d7042957f448b206c1" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;a href=&quot;securitymanager#checkExec(java.lang.String)&quot;&gt;&lt;code&gt;checkExec&lt;/code&gt;&lt;/a&gt; method is called with the first component of each process builder's &lt;code&gt;command&lt;/code&gt; array as its argument. This may result in a &lt;a href=&quot;securityexception&quot;&gt;&lt;code&gt;SecurityException&lt;/code&gt;&lt;/a&gt; being thrown.</source>
          <target state="translated">如果有安全管理器，则使用每个流程生成器的 &lt;code&gt;command&lt;/code&gt; 数组的第一个组件作为参数来调用其&lt;a href=&quot;securitymanager#checkExec(java.lang.String)&quot;&gt; &lt;code&gt;checkExec&lt;/code&gt; &lt;/a&gt;方法。这可能会导致引发&lt;a href=&quot;securityexception&quot;&gt; &lt;code&gt;SecurityException&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6dd5e5d0112178d816deaa79996ddbde5d42d22e" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;a href=&quot;securitymanager#checkExec(java.lang.String)&quot;&gt;&lt;code&gt;checkExec&lt;/code&gt;&lt;/a&gt; method is called with the first component of this object's &lt;code&gt;command&lt;/code&gt; array as its argument. This may result in a &lt;a href=&quot;securityexception&quot;&gt;&lt;code&gt;SecurityException&lt;/code&gt;&lt;/a&gt; being thrown.</source>
          <target state="translated">如果有安全管理器，则使用该对象的 &lt;code&gt;command&lt;/code&gt; 数组的第一个组件作为参数来调用其&lt;a href=&quot;securitymanager#checkExec(java.lang.String)&quot;&gt; &lt;code&gt;checkExec&lt;/code&gt; &lt;/a&gt;方法。这可能会导致引发&lt;a href=&quot;securityexception&quot;&gt; &lt;code&gt;SecurityException&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="85a1e97c5d37987df52e3f2db8dd957eb6a2e0a1" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;a href=&quot;securitymanager#checkExec-java.lang.String-&quot;&gt;&lt;code&gt;checkExec&lt;/code&gt;&lt;/a&gt; method is called with the first component of this object's &lt;code&gt;command&lt;/code&gt; array as its argument. This may result in a &lt;a href=&quot;securityexception&quot;&gt;&lt;code&gt;SecurityException&lt;/code&gt;&lt;/a&gt; being thrown.</source>
          <target state="translated">如果有安全管理器，则使用该对象的 &lt;code&gt;command&lt;/code&gt; 数组的第一个组件作为参数来调用其&lt;a href=&quot;securitymanager#checkExec-java.lang.String-&quot;&gt; &lt;code&gt;checkExec&lt;/code&gt; &lt;/a&gt;方法。这可能会导致引发&lt;a href=&quot;securityexception&quot;&gt; &lt;code&gt;SecurityException&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9c30beb89be73a967106d6bb017cc3341325b7e4" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkAccess&lt;/code&gt; method is called with this thread as its argument. This may result in throwing a &lt;code&gt;SecurityException&lt;/code&gt;.</source>
          <target state="translated">如果有安全管理器，则以该线程为参数调用其 &lt;code&gt;checkAccess&lt;/code&gt; 方法。这可能导致抛出 &lt;code&gt;SecurityException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="959b09fe0d2c452907b0520da6e28a90c4ae65f9" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkAccess&lt;/code&gt; method is called with this thread group as its argument. This may result in throwing a &lt;code&gt;SecurityException&lt;/code&gt;.</source>
          <target state="translated">如果有安全管理器，则以该线程组为参数调用其 &lt;code&gt;checkAccess&lt;/code&gt; 方法。这可能导致抛出 &lt;code&gt;SecurityException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3c17150f3dc1fd1d9a170113f445867d696c2b24" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkConnect&lt;/code&gt; method is called for each InetAddress. Only InetAddresses where the &lt;code&gt;checkConnect&lt;/code&gt; doesn't throw a SecurityException will be returned in the Enumeration. However, if the caller has the &lt;a href=&quot;netpermission&quot;&gt;&lt;code&gt;NetPermission&lt;/code&gt;&lt;/a&gt;(&quot;getNetworkInformation&quot;) permission, then all InetAddresses are returned.</source>
          <target state="translated">如果有安全管理器，则为每个InetAddress调用其 &lt;code&gt;checkConnect&lt;/code&gt; 方法。在枚举中仅返回 &lt;code&gt;checkConnect&lt;/code&gt; 没有引发SecurityException的InetAddress 。但是，如果调用方具有&lt;a href=&quot;netpermission&quot;&gt; &lt;code&gt;NetPermission&lt;/code&gt; &lt;/a&gt;（&amp;ldquo; getNetworkInformation&amp;rdquo;）权限，则将返回所有InetAddress。</target>
        </trans-unit>
        <trans-unit id="58541a971b5c4b55ce89f0aa08744fea81192c9b" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkConnect&lt;/code&gt; method is called for each InetAddress. Only InetAddresses where the &lt;code&gt;checkConnect&lt;/code&gt; doesn't throw a SecurityException will be returned in the Stream. However, if the caller has the &lt;a href=&quot;netpermission&quot;&gt;&lt;code&gt;NetPermission&lt;/code&gt;&lt;/a&gt;(&quot;getNetworkInformation&quot;) permission, then all InetAddresses are returned.</source>
          <target state="translated">如果有安全管理器，则为每个InetAddress调用其 &lt;code&gt;checkConnect&lt;/code&gt; 方法。流中仅返回 &lt;code&gt;checkConnect&lt;/code&gt; 不会引发SecurityException的InetAddress 。但是，如果调用方具有&lt;a href=&quot;netpermission&quot;&gt; &lt;code&gt;NetPermission&lt;/code&gt; &lt;/a&gt;（&amp;ldquo; getNetworkInformation&amp;rdquo;）权限，则将返回所有InetAddress。</target>
        </trans-unit>
        <trans-unit id="16d27bea720609eee04166dfd76b88b456132798" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkConnect&lt;/code&gt; method is called with &lt;code&gt;host.getHostAddress()&lt;/code&gt; and &lt;code&gt;port&lt;/code&gt; as its arguments. This could result in a SecurityException.</source>
          <target state="translated">如果有安全管理器，则使用 &lt;code&gt;host.getHostAddress()&lt;/code&gt; 和 &lt;code&gt;port&lt;/code&gt; 作为其参数来调用其 &lt;code&gt;checkConnect&lt;/code&gt; 方法。这可能会导致SecurityException。</target>
        </trans-unit>
        <trans-unit id="43c71e671e00781339f5ba759f2bcd61a8b7a34b" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkConnect&lt;/code&gt; method is called with the InetAddress for each InterfaceAddress. Only InterfaceAddresses where the &lt;code&gt;checkConnect&lt;/code&gt; doesn't throw a SecurityException will be returned in the List.</source>
          <target state="translated">如果有安全管理器，则为每个InterfaceAddress的InetAddress调用其 &lt;code&gt;checkConnect&lt;/code&gt; 方法。列表中仅返回 &lt;code&gt;checkConnect&lt;/code&gt; 不会引发SecurityException的InterfaceAddresses 。</target>
        </trans-unit>
        <trans-unit id="78af07133b038dacb150089b40e78b0ca1d3d753" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkConnect&lt;/code&gt; method is called with the host address and &lt;code&gt;port&lt;/code&gt; as its arguments. This could result in a SecurityException.</source>
          <target state="translated">如果有安全管理器，则以主机地址和 &lt;code&gt;port&lt;/code&gt; 作为参数来调用其 &lt;code&gt;checkConnect&lt;/code&gt; 方法。这可能会导致SecurityException。</target>
        </trans-unit>
        <trans-unit id="2d2ddb66aff693ec81fe7a3cff9c33e416a967ed" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkConnect&lt;/code&gt; method is called with the host name as its argument to check the permission to resolve it. This could result in a SecurityException.</source>
          <target state="translated">如果有安全管理器，则以主机名作为参数调用其 &lt;code&gt;checkConnect&lt;/code&gt; 方法，以检查解决该问题的权限。这可能会导致SecurityException。</target>
        </trans-unit>
        <trans-unit id="01ae3cd02649f51bc3641c7c81a3016b88a1579b" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkConnect&lt;/code&gt; method is called with the local host name and &lt;code&gt;-1&lt;/code&gt; as its arguments to see if the operation is allowed. If the operation is not allowed, an InetAddress representing the loopback address is returned.</source>
          <target state="translated">如果有安全管理器，则使用本地主机名并以 &lt;code&gt;-1&lt;/code&gt; 作为其参数来调用其 &lt;code&gt;checkConnect&lt;/code&gt; 方法，以查看是否允许该操作。如果不允许该操作，则返回表示回送地址的InetAddress。</target>
        </trans-unit>
        <trans-unit id="4d128c55ea8e46338a04c172173181318ab739b7" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkConnect&lt;/code&gt; method is called with the proxy host address and port number as its arguments. This could result in a SecurityException.</source>
          <target state="translated">如果有安全管理器，则以代理主机地址和端口号作为参数来调用其 &lt;code&gt;checkConnect&lt;/code&gt; 方法。这可能会导致SecurityException。</target>
        </trans-unit>
        <trans-unit id="bca28a5046aedb2445dad871f1870c7cd86fe222" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkConnect&lt;/code&gt; method is first called with the host address and &lt;code&gt;-1&lt;/code&gt; as its arguments to see if the operation is allowed.</source>
          <target state="translated">如果存在安全管理器，则首先使用主机地址并以 &lt;code&gt;-1&lt;/code&gt; 作为其参数来调用其 &lt;code&gt;checkConnect&lt;/code&gt; 方法，以查看是否允许该操作。</target>
        </trans-unit>
        <trans-unit id="fd69bfacd3a48bd3c84ffe11c3502373bc1b717d" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkConnect&lt;/code&gt; method is first called with the hostname and &lt;code&gt;-1&lt;/code&gt; as its arguments to see if the operation is allowed. If the operation is not allowed, it will return the textual representation of the IP address.</source>
          <target state="translated">如果存在安全管理器，则首先使用主机名和 &lt;code&gt;-1&lt;/code&gt; 作为其参数来调用其 &lt;code&gt;checkConnect&lt;/code&gt; 方法，以查看是否允许该操作。如果不允许该操作，它将返回IP地址的文本表示。</target>
        </trans-unit>
        <trans-unit id="19b8451790374e638a897d576809e75ff26e4bdc" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkExit&lt;/code&gt; method is first called with 0 as its argument to ensure the exit is allowed. This could result in a SecurityException.</source>
          <target state="translated">如果有安全管理器，则首先使用0作为其参数来调用其 &lt;code&gt;checkExit&lt;/code&gt; 方法，以确保允许退出。这可能会导致SecurityException。</target>
        </trans-unit>
        <trans-unit id="3ad778e38f7a8fa1a04c66c84bec80348990751b" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkListen&lt;/code&gt; method is called with the &lt;code&gt;port&lt;/code&gt; argument as its argument to ensure the operation is allowed. This could result in a SecurityException.</source>
          <target state="translated">如果存在安全管理器，则以 &lt;code&gt;port&lt;/code&gt; 参数作为其参数来调用其 &lt;code&gt;checkListen&lt;/code&gt; 方法，以确保允许该操作。这可能会导致SecurityException。</target>
        </trans-unit>
        <trans-unit id="4275d6bc9ac0d95a70ff7bc44ead467a08203c23" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkListen&lt;/code&gt; method is called with the &lt;code&gt;port&lt;/code&gt; argument as its argument to ensure the operation is allowed. This could result in a SecurityException. The &lt;code&gt;backlog&lt;/code&gt; argument is the requested maximum number of pending connections on the socket. Its exact semantics are implementation specific. In particular, an implementation may impose a maximum length or may choose to ignore the parameter altogether. The value provided should be greater than &lt;code&gt;0&lt;/code&gt;. If it is less than or equal to &lt;code&gt;0&lt;/code&gt;, then an implementation specific default will be used.</source>
          <target state="translated">如果有安全管理器，其 &lt;code&gt;checkListen&lt;/code&gt; 方法被调用的 &lt;code&gt;port&lt;/code&gt; 作为其参数，以确保允许该操作。这可能会导致SecurityException。在 &lt;code&gt;backlog&lt;/code&gt; 参数是套接字上挂起连接的请求的最大数量。它的确切语义是特定于实现的。特别地，一种实现可以施加最大长度，或者可以选择完全忽略该参数。提供的值应大于 &lt;code&gt;0&lt;/code&gt; 。如果小于或等于 &lt;code&gt;0&lt;/code&gt; ，则将使用特定于实现的默认值。</target>
        </trans-unit>
        <trans-unit id="84eacac097d36c19fe75054afbaa3ba99bf8985e" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkListen&lt;/code&gt; method is called with the &lt;code&gt;port&lt;/code&gt; argument as its argument to ensure the operation is allowed. This could result in a SecurityException. The &lt;code&gt;backlog&lt;/code&gt; argument is the requested maximum number of pending connections on the socket. Its exact semantics are implementation specific. In particular, an implementation may impose a maximum length or may choose to ignore the parameter altogther. The value provided should be greater than &lt;code&gt;0&lt;/code&gt;. If it is less than or equal to &lt;code&gt;0&lt;/code&gt;, then an implementation specific default will be used.</source>
          <target state="translated">如果存在安全管理器，则以 &lt;code&gt;port&lt;/code&gt; 参数作为其参数来调用其 &lt;code&gt;checkListen&lt;/code&gt; 方法，以确保允许该操作。这可能会导致SecurityException。在 &lt;code&gt;backlog&lt;/code&gt; 参数是套接字上挂起连接的请求的最大数量。它的确切语义是特定于实现的。特别地，一种实现可以施加最大长度，或者可以选择完全忽略该参数。提供的值应大于 &lt;code&gt;0&lt;/code&gt; 。如果它小于或等于 &lt;code&gt;0&lt;/code&gt; ，那么将使用特定于实现的默认值。</target>
        </trans-unit>
        <trans-unit id="7696a640bf74fb64021433fe004320c4e69fec7e" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkListen&lt;/code&gt; method is first called with 0 as its argument to ensure the operation is allowed. This could result in a SecurityException.</source>
          <target state="translated">如果存在安全管理器，则首先使用0作为其参数来调用其 &lt;code&gt;checkListen&lt;/code&gt; 方法，以确保允许该操作。这可能会导致SecurityException。</target>
        </trans-unit>
        <trans-unit id="f7d8bb6cd4c61d496d648276b50f92f3feba88b5" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkListen&lt;/code&gt; method is first called with the &lt;code&gt;port&lt;/code&gt; argument as its argument to ensure the operation is allowed. This could result in a SecurityException.</source>
          <target state="translated">如果存在安全管理器，则首先使用 &lt;code&gt;port&lt;/code&gt; 参数作为其参数来调用其 &lt;code&gt;checkListen&lt;/code&gt; 方法，以确保允许该操作。这可能会导致SecurityException。</target>
        </trans-unit>
        <trans-unit id="2550b60768f930b8dee700df520c5f4176ce28d3" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkListen&lt;/code&gt; method is first called with the SocketAddress port as its argument to ensure the operation is allowed. This could result in a SecurityException.</source>
          <target state="translated">如果存在安全管理器，则首先使用SocketAddress端口作为其参数来调用其 &lt;code&gt;checkListen&lt;/code&gt; 方法，以确保允许该操作。这可能会导致SecurityException。</target>
        </trans-unit>
        <trans-unit id="a229539b4a28c2f5ec8ded7c3825ecf64243199f" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkListen&lt;/code&gt; method is first called with the port from the socket address as its argument to ensure the operation is allowed. This could result in a SecurityException.</source>
          <target state="translated">如果有安全管理器，则首先使用套接字地址中的端口作为参数来调用其 &lt;code&gt;checkListen&lt;/code&gt; 方法，以确保允许该操作。这可能会导致SecurityException。</target>
        </trans-unit>
        <trans-unit id="0a67ec5feda224ae64b8c4ed0abf118d7033d1c2" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkPermission&lt;/code&gt; method is called to check &lt;code&gt;ReflectPermission(&quot;suppressAccessChecks&quot;)&lt;/code&gt; and that must return normally.</source>
          <target state="translated">如果有安全管理器，则调用其 &lt;code&gt;checkPermission&lt;/code&gt; 方法以检查 &lt;code&gt;ReflectPermission(&quot;suppressAccessChecks&quot;)&lt;/code&gt; ，并且必须正常返回。</target>
        </trans-unit>
        <trans-unit id="526f451df552a77dd63ebe02272aee894aeec911" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkPermission&lt;/code&gt; method is called to check &lt;code&gt;ReflectPermission(&quot;suppressAccessChecks&quot;)&lt;/code&gt;.</source>
          <target state="translated">如果有安全管理器，则调用其 &lt;code&gt;checkPermission&lt;/code&gt; 方法以检查 &lt;code&gt;ReflectPermission(&quot;suppressAccessChecks&quot;)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1362fabcddab928d786a66dfafce71193c90bbd3" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkPermission&lt;/code&gt; method is called with a &lt;code&gt;PropertyPermission(&quot;user.language&quot;, &quot;write&quot;)&lt;/code&gt; permission before the default locale is changed.</source>
          <target state="translated">如果存在安全管理器，则在更改默认语言环境之前，将使用 &lt;code&gt;PropertyPermission(&quot;user.language&quot;, &quot;write&quot;)&lt;/code&gt; 权限调用其 &lt;code&gt;checkPermission&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="4a19d07ab57d6d32ab3bfc3854e57cbabaa6348e" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkPermission&lt;/code&gt; method is called with a &lt;code&gt;ReflectPermission(&quot;suppressAccessChecks&quot;)&lt;/code&gt; permission.</source>
          <target state="translated">如果存在安全管理器，则会使用 &lt;code&gt;ReflectPermission(&quot;suppressAccessChecks&quot;)&lt;/code&gt; 权限来调用其 &lt;code&gt;checkPermission&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="2046cd2160f064fcca12b8ed464d009e531b209f" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkPermission&lt;/code&gt; method is called with an &lt;code&gt;AWTPermission(&quot;watchMousePointer&quot;)&lt;/code&gt; permission before creating and returning a &lt;code&gt;PointerInfo&lt;/code&gt; object. This may result in a &lt;code&gt;SecurityException&lt;/code&gt;.</source>
          <target state="translated">如果存在安全管理器，则在创建和返回 &lt;code&gt;PointerInfo&lt;/code&gt; 对象之前，将使用 &lt;code&gt;AWTPermission(&quot;watchMousePointer&quot;)&lt;/code&gt; 权限调用其 &lt;code&gt;checkPermission&lt;/code&gt; 方法。这可能会导致 &lt;code&gt;SecurityException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="023c7b6fa6e64e85c534968cd82b886f189f68e0" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkPermission&lt;/code&gt; method is called with the &lt;code&gt;AWTPermission(&quot;setAppletStub&quot;)&lt;/code&gt; permission if a stub has already been set.</source>
          <target state="translated">如果存在安全管理器，则如果已经设置了存根，则将使用 &lt;code&gt;AWTPermission(&quot;setAppletStub&quot;)&lt;/code&gt; 权限调用其 &lt;code&gt;checkPermission&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="a5901e8f5f3e827f7dec190acb7b2c680e3d8a12" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkPermission&lt;/code&gt; method is first called to check &lt;code&gt;RuntimePermission(&quot;defineClass&quot;)&lt;/code&gt;.</source>
          <target state="translated">如果有安全管理器，则首先调用其 &lt;code&gt;checkPermission&lt;/code&gt; 方法以检查 &lt;code&gt;RuntimePermission(&quot;defineClass&quot;)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ba736daa95eab79c3e9ec30a15feed15b6f2153e" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkPermission&lt;/code&gt; method is first called with a &lt;code&gt;ReflectPermission(&quot;suppressAccessChecks&quot;)&lt;/code&gt; permission.</source>
          <target state="translated">如果存在安全管理器，则首先使用 &lt;code&gt;ReflectPermission(&quot;suppressAccessChecks&quot;)&lt;/code&gt; 权限调用其 &lt;code&gt;checkPermission&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="b73ff7cd0749e2fe69c0f2fcc0421edecf259b2d" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkPermission&lt;/code&gt; method will be invoked with a &lt;code&gt;RuntimePermission(&quot;setFactory&quot;)&lt;/code&gt; permission; this could result in a &lt;code&gt;SecurityException&lt;/code&gt;.</source>
          <target state="translated">如果有安全管理器，将使用 &lt;code&gt;RuntimePermission(&quot;setFactory&quot;)&lt;/code&gt; 权限调用其 &lt;code&gt;checkPermission&lt;/code&gt; 方法；这可能会导致 &lt;code&gt;SecurityException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4e19a3d6b18c7f288973d4faca480e353d3119ae" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkPermission&lt;/code&gt; method will be invoked with a &lt;code&gt;java.util.logging.LoggingPermission(&quot;control&quot;)&lt;/code&gt; permission; this could result in a &lt;code&gt;SecurityException&lt;/code&gt;.</source>
          <target state="translated">如果有安全管理器，将使用 &lt;code&gt;java.util.logging.LoggingPermission(&quot;control&quot;)&lt;/code&gt; 权限调用其 &lt;code&gt;checkPermission&lt;/code&gt; 方法；这可能会导致 &lt;code&gt;SecurityException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5cb05ace85aa7a9edcb040bdd423405912174b9c" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkPropertiesAccess&lt;/code&gt; method is called. This could result in a &lt;a href=&quot;../../../java.base/java/lang/securityexception&quot;&gt;SecurityException&lt;/a&gt;.</source>
          <target state="translated">如果有安全管理器，则调用其 &lt;code&gt;checkPropertiesAccess&lt;/code&gt; 方法。这可能会导致&lt;a href=&quot;../../../java.base/java/lang/securityexception&quot;&gt;SecurityException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b812e22f1f04741048de016813ab27b17900ad4d" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkPropertiesAccess&lt;/code&gt; method is called. This could result in a &lt;a href=&quot;../lang/securityexception&quot;&gt;SecurityException&lt;/a&gt;.</source>
          <target state="translated">如果有安全管理器，则调用其 &lt;code&gt;checkPropertiesAccess&lt;/code&gt; 方法。这可能会导致&lt;a href=&quot;../lang/securityexception&quot;&gt;SecurityException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="61ad58a3688694c18343d625b7add7843909f0fc" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkRead&lt;/code&gt; method is called with the &lt;code&gt;name&lt;/code&gt; argument as its argument to see if read access to the file is allowed. If the mode allows writing, the security manager's &lt;code&gt;checkWrite&lt;/code&gt; method is also called with the &lt;code&gt;name&lt;/code&gt; argument as its argument to see if write access to the file is allowed.</source>
          <target state="translated">如果有安全管理器，则使用 &lt;code&gt;name&lt;/code&gt; 参数作为其参数来调用其 &lt;code&gt;checkRead&lt;/code&gt; 方法，以查看是否允许对该文件进行读取访问。如果该模式允许写入，则还使用 &lt;code&gt;name&lt;/code&gt; 参数作为其参数调用安全管理器的 &lt;code&gt;checkWrite&lt;/code&gt; 方法，以查看是否允许对该文件进行写访问。</target>
        </trans-unit>
        <trans-unit id="e8440e06fb5641cd0bbb2e4e19fe4021dbf3d258" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkRead&lt;/code&gt; method is called with the file descriptor &lt;code&gt;fdObj&lt;/code&gt; as its argument to see if it's ok to read the file descriptor. If read access is denied to the file descriptor a &lt;code&gt;SecurityException&lt;/code&gt; is thrown.</source>
          <target state="translated">如果有安全管理器，则使用文件描述符 &lt;code&gt;fdObj&lt;/code&gt; 作为其参数来调用其 &lt;code&gt;checkRead&lt;/code&gt; 方法，以查看是否可以读取文件描述符。如果对文件描述符的读取访问被拒绝，则会抛出 &lt;code&gt;SecurityException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="07ece2acfb17b36150e2dd4f7e477c94e9f4a76d" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkRead&lt;/code&gt; method is called with the pathname of the &lt;code&gt;file&lt;/code&gt; argument as its argument to see if read access to the file is allowed. If the mode allows writing, the security manager's &lt;code&gt;checkWrite&lt;/code&gt; method is also called with the path argument to see if write access to the file is allowed.</source>
          <target state="translated">如果有安全管理器，则以 &lt;code&gt;file&lt;/code&gt; 参数的路径名作为参数来调用其 &lt;code&gt;checkRead&lt;/code&gt; 方法，以查看是否允许对文件的读取访问。如果该模式允许写入，则还会使用path参数调用安全管理器的 &lt;code&gt;checkWrite&lt;/code&gt; 方法，以查看是否允许对该文件进行写访问。</target>
        </trans-unit>
        <trans-unit id="31b66585dd5ded5b4cf8149540abcf6d797f5618" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its checkPermission method is called with a PropertyPermission(&quot;user.language&quot;, &quot;write&quot;) permission before the default locale is changed.</source>
          <target state="translated">如果有一个安全管理器,在改变默认的locale之前,它的checkPermission方法会被调用一个PropertyPermission(&quot;user.language&quot;,&quot;write&quot;)权限。</target>
        </trans-unit>
        <trans-unit id="8825d17638da814f3b0c11ec345292fdd5696887" translate="yes" xml:space="preserve">
          <source>If there is a security manager, the &lt;a href=&quot;../lang/securitymanager#checkSecurityAccess(java.lang.String)&quot;&gt;&lt;code&gt;SecurityManager.checkSecurityAccess(java.lang.String)&lt;/code&gt;&lt;/a&gt; method is called with the &lt;code&gt;&quot;insertProvider&quot;&lt;/code&gt; permission target name to see if it's ok to add a new provider. If this permission check is denied, &lt;code&gt;checkSecurityAccess&lt;/code&gt; is called again with the &lt;code&gt;&quot;insertProvider.&quot;+provider.getName()&lt;/code&gt; permission target name. If both checks are denied, a &lt;code&gt;SecurityException&lt;/code&gt; is thrown.</source>
          <target state="translated">如果存在安全管理器，则使用 &lt;code&gt;&quot;insertProvider&quot;&lt;/code&gt; 权限目标名称调用&lt;a href=&quot;../lang/securitymanager#checkSecurityAccess(java.lang.String)&quot;&gt; &lt;code&gt;SecurityManager.checkSecurityAccess(java.lang.String)&lt;/code&gt; &lt;/a&gt;方法，以查看是否可以添加新的提供程序。如果拒绝此权限检查，则使用 &lt;code&gt;&quot;insertProvider.&quot;+provider.getName()&lt;/code&gt; 权限目标名称再次调用 &lt;code&gt;checkSecurityAccess&lt;/code&gt; 。如果两个检查都被拒绝，则抛出 &lt;code&gt;SecurityException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bd97e3f8323cfe0de6530417bd6292cf0553996a" translate="yes" xml:space="preserve">
          <source>If there is a security manager, the &lt;a href=&quot;../lang/securitymanager#checkSecurityAccess-java.lang.String-&quot;&gt;&lt;code&gt;SecurityManager.checkSecurityAccess(java.lang.String)&lt;/code&gt;&lt;/a&gt; method is called with the &lt;code&gt;&quot;insertProvider&quot;&lt;/code&gt; permission target name to see if it's ok to add a new provider. If this permission check is denied, &lt;code&gt;checkSecurityAccess&lt;/code&gt; is called again with the &lt;code&gt;&quot;insertProvider.&quot;+provider.getName()&lt;/code&gt; permission target name. If both checks are denied, a &lt;code&gt;SecurityException&lt;/code&gt; is thrown.</source>
          <target state="translated">如果存在安全管理器，则使用 &lt;code&gt;&quot;insertProvider&quot;&lt;/code&gt; 权限目标名称调用&lt;a href=&quot;../lang/securitymanager#checkSecurityAccess-java.lang.String-&quot;&gt; &lt;code&gt;SecurityManager.checkSecurityAccess(java.lang.String)&lt;/code&gt; &lt;/a&gt;方法，以查看是否可以添加新的提供程序。如果此权限检查被拒绝，则使用 &lt;code&gt;&quot;insertProvider.&quot;+provider.getName()&lt;/code&gt; 权限目标名称再次调用 &lt;code&gt;checkSecurityAccess&lt;/code&gt; 。如果两个检查都被拒绝，则抛出 &lt;code&gt;SecurityException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9b31a15f0a361ace0e86d27297cb7544846a2131" translate="yes" xml:space="preserve">
          <source>If there is a security manager, then the security manager's &lt;code&gt;checkPermission&lt;/code&gt; method is called with a &lt;code&gt;RuntimePermission(&quot;getStackTrace&quot;)&lt;/code&gt; permission as well as &lt;code&gt;RuntimePermission(&quot;modifyThreadGroup&quot;)&lt;/code&gt; permission to see if it is ok to get the stack trace of all threads.</source>
          <target state="translated">如果有安全管理器，则使用 &lt;code&gt;RuntimePermission(&quot;getStackTrace&quot;)&lt;/code&gt; 权限和 &lt;code&gt;RuntimePermission(&quot;modifyThreadGroup&quot;)&lt;/code&gt; 权限调用安全管理器的 &lt;code&gt;checkPermission&lt;/code&gt; 方法，以查看是否可以获取所有线程的堆栈跟踪。</target>
        </trans-unit>
        <trans-unit id="372f832c98aee8a28f1bafce4413d10d1d87c33d" translate="yes" xml:space="preserve">
          <source>If there is a security manager, this method calls its &lt;code&gt;checkListen&lt;/code&gt; method with the &lt;code&gt;port&lt;/code&gt; argument as its argument to ensure the operation is allowed. This could result in a SecurityException. The &lt;code&gt;backlog&lt;/code&gt; argument is the requested maximum number of pending connections on the socket. Its exact semantics are implementation specific. In particular, an implementation may impose a maximum length or may choose to ignore the parameter altogether. The value provided should be greater than &lt;code&gt;0&lt;/code&gt;. If it is less than or equal to &lt;code&gt;0&lt;/code&gt;, then an implementation specific default will be used.</source>
          <target state="translated">如果存在安全管理器，则此方法使用 &lt;code&gt;port&lt;/code&gt; 参数作为其参数来调用其 &lt;code&gt;checkListen&lt;/code&gt; 方法，以确保允许该操作。这可能会导致SecurityException。在 &lt;code&gt;backlog&lt;/code&gt; 参数是套接字上挂起连接的请求的最大数量。它的确切语义是特定于实现的。特别地，一种实现可以施加最大长度，或者可以选择完全忽略该参数。提供的值应大于 &lt;code&gt;0&lt;/code&gt; 。如果小于或等于 &lt;code&gt;0&lt;/code&gt; ，则将使用特定于实现的默认值。</target>
        </trans-unit>
        <trans-unit id="3774f41cca13a332ee025b0313241e9bb0d0309d" translate="yes" xml:space="preserve">
          <source>If there is a security manager, this method calls its &lt;code&gt;checkListen&lt;/code&gt; method with the &lt;code&gt;port&lt;/code&gt; argument as its argument to ensure the operation is allowed. This could result in a SecurityException. The &lt;code&gt;backlog&lt;/code&gt; argument is the requested maximum number of pending connections on the socket. Its exact semantics are implementation specific. In particular, an implementation may impose a maximum length or may choose to ignore the parameter altogther. The value provided should be greater than &lt;code&gt;0&lt;/code&gt;. If it is less than or equal to &lt;code&gt;0&lt;/code&gt;, then an implementation specific default will be used.</source>
          <target state="translated">如果存在安全管理器，则此方法使用 &lt;code&gt;port&lt;/code&gt; 参数作为其参数来调用其 &lt;code&gt;checkListen&lt;/code&gt; 方法，以确保允许该操作。这可能会导致SecurityException。在 &lt;code&gt;backlog&lt;/code&gt; 参数是套接字上挂起连接的请求的最大数量。它的确切语义是特定于实现的。特别地，一种实现可以施加最大长度，或者可以选择完全忽略该参数。提供的值应大于 &lt;code&gt;0&lt;/code&gt; 。如果它小于或等于 &lt;code&gt;0&lt;/code&gt; ，那么将使用特定于实现的默认值。</target>
        </trans-unit>
        <trans-unit id="c49df9821bd54b67f07151d3efea906c51666fdf" translate="yes" xml:space="preserve">
          <source>If there is a security manager, this method first calls its &lt;code&gt;checkConnect&lt;/code&gt; method with the hostname and &lt;code&gt;-1&lt;/code&gt; as its arguments to see if the calling code is allowed to know the hostname for this IP address, i.e., to connect to the host. If the operation is not allowed, it will return the textual representation of the IP address.</source>
          <target state="translated">如果存在安全管理器，则此方法首先使用主机名和 &lt;code&gt;-1&lt;/code&gt; 作为其参数调用其 &lt;code&gt;checkConnect&lt;/code&gt; 方法，以查看是否允许调用代码知道此IP地址的主机名，即连接到主机。如果不允许该操作，它将返回IP地址的文本表示。</target>
        </trans-unit>
        <trans-unit id="999933e43cb5d7cfb6601989d19930a2a9186ce5" translate="yes" xml:space="preserve">
          <source>If there is a security manager, this method first calls its &lt;code&gt;checkMulticast&lt;/code&gt; method with the &lt;code&gt;mcastaddr&lt;/code&gt; argument as its argument.</source>
          <target state="translated">如果有安全管理器，此方法首先调用其 &lt;code&gt;checkMulticast&lt;/code&gt; 方法与 &lt;code&gt;mcastaddr&lt;/code&gt; 作为参数来。</target>
        </trans-unit>
        <trans-unit id="1e8e454b01623ff9ba56024fdcbb8a6e018247b0" translate="yes" xml:space="preserve">
          <source>If there is a security manager, this method first calls the security manager's &lt;code&gt;checkCreateClassLoader&lt;/code&gt; method to ensure creation of a class loader is allowed.</source>
          <target state="translated">如果有安全管理器，则此方法首先调用安全管理器的 &lt;code&gt;checkCreateClassLoader&lt;/code&gt; 方法，以确保允许创建类加载器。</target>
        </trans-unit>
        <trans-unit id="799f9e285d27c3aa5aa412489ee33ebf55b4583d" translate="yes" xml:space="preserve">
          <source>If there is a security manager, this method first calls the security manager's &lt;code&gt;checkSetFactory&lt;/code&gt; method to ensure the operation is allowed. This could result in a &lt;code&gt;SecurityException&lt;/code&gt;.</source>
          <target state="translated">如果存在安全管理器，则此方法首先调用安全管理器的 &lt;code&gt;checkSetFactory&lt;/code&gt; 方法以确保允许该操作。这可能会导致 &lt;code&gt;SecurityException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="532913bfc0592ca00219b6f161a58e7676757794" translate="yes" xml:space="preserve">
          <source>If there is a security manager, this method first calls the security manager's &lt;code&gt;checkSetFactory&lt;/code&gt; method to ensure the operation is allowed. This could result in a SecurityException.</source>
          <target state="translated">如果存在安全管理器，则此方法首先调用安全管理器的 &lt;code&gt;checkSetFactory&lt;/code&gt; 方法以确保允许该操作。这可能会导致SecurityException。</target>
        </trans-unit>
        <trans-unit id="b85ee089e6901857f30792e22767b9407897d233" translate="yes" xml:space="preserve">
          <source>If there is a security manager, this method first calls the security manager's &lt;code&gt;checkSetFactory&lt;/code&gt; method. This could result in a SecurityException.</source>
          <target state="translated">如果存在安全管理器，则此方法首先调用安全管理器的 &lt;code&gt;checkSetFactory&lt;/code&gt; 方法。这可能会导致SecurityException。</target>
        </trans-unit>
        <trans-unit id="d0319ca077ddde1bcf2e693ddcb559868dc66ee3" translate="yes" xml:space="preserve">
          <source>If there is a security manager, this method first performs some security checks. First, if &lt;code&gt;p.getAddress().isMulticastAddress()&lt;/code&gt; is true, this method calls the security manager's &lt;code&gt;checkMulticast&lt;/code&gt; method with &lt;code&gt;p.getAddress()&lt;/code&gt; and &lt;code&gt;ttl&lt;/code&gt; as its arguments. If the evaluation of that expression is false, this method instead calls the security manager's &lt;code&gt;checkConnect&lt;/code&gt; method with arguments &lt;code&gt;p.getAddress().getHostAddress()&lt;/code&gt; and &lt;code&gt;p.getPort()&lt;/code&gt;. Each call to a security manager method could result in a SecurityException if the operation is not allowed.</source>
          <target state="translated">如果有安全管理器，则此方法首先执行一些安全检查。首先，如果 &lt;code&gt;p.getAddress().isMulticastAddress()&lt;/code&gt; 是真实的，这个方法调用安全管理器的 &lt;code&gt;checkMulticast&lt;/code&gt; 方法与 &lt;code&gt;p.getAddress()&lt;/code&gt; 和 &lt;code&gt;ttl&lt;/code&gt; 作为参数。如果对该表达式的求值为假，则此方法使用参数 &lt;code&gt;p.getAddress().getHostAddress()&lt;/code&gt; &lt;code&gt;p.getPort()&lt;/code&gt; 和p.getPort（）调用安全管理器的 &lt;code&gt;checkConnect&lt;/code&gt; 方法。如果不允许该操作，则对安全管理器方法的每次调用都可能导致SecurityException。</target>
        </trans-unit>
        <trans-unit id="63982b929f4b12662afdfb3691962ff7e8ce5aaa" translate="yes" xml:space="preserve">
          <source>If there is a security manger, its &lt;code&gt;checkPermission&lt;/code&gt; method will be invoked with a &lt;code&gt;RuntimePermission(&quot;getClassLoader&quot;)&lt;/code&gt; permission; this could result in a &lt;code&gt;SecurityException&lt;/code&gt;. The implementation of this method may also perform further security checks to verify that the calling context has permission to connect to all of the URLs in the codebase URL path.</source>
          <target state="translated">如果存在安全管理器，将使用 &lt;code&gt;RuntimePermission(&quot;getClassLoader&quot;)&lt;/code&gt; 权限调用其 &lt;code&gt;checkPermission&lt;/code&gt; 方法；这可能会导致 &lt;code&gt;SecurityException&lt;/code&gt; 。此方法的实现还可以执行进一步的安全检查，以验证调用上下文是否有权连接到代码库URL路径中的所有URL。</target>
        </trans-unit>
        <trans-unit id="bf4410fbd9dbb3855c2a0c2fc2a80606e063a5a3" translate="yes" xml:space="preserve">
          <source>If there is a security manger, its &lt;code&gt;checkPermission&lt;/code&gt; method will be invoked with a &lt;code&gt;RuntimePermission(&quot;getClassLoader&quot;)&lt;/code&gt; permission; this could result in a &lt;code&gt;SecurityException&lt;/code&gt;. The provider implementation of this method may also perform further security checks to verify that the calling context has permission to connect to all of the URLs in the codebase URL path.</source>
          <target state="translated">如果存在安全管理器，将使用 &lt;code&gt;RuntimePermission(&quot;getClassLoader&quot;)&lt;/code&gt; 权限调用其 &lt;code&gt;checkPermission&lt;/code&gt; 方法；这可能会导致 &lt;code&gt;SecurityException&lt;/code&gt; 。此方法的提供程序实现也可以执行进一步的安全检查，以验证调用上下文是否具有连接到代码库URL路径中所有URL的权限。</target>
        </trans-unit>
        <trans-unit id="696cdd286fb1f9966bf04867ac93a074e1dded21" translate="yes" xml:space="preserve">
          <source>If there is a way to convert &lt;em&gt;opendata(J)&lt;/em&gt; back to &lt;em&gt;J&lt;/em&gt; then we say that &lt;em&gt;J&lt;/em&gt; is &lt;em&gt;reconstructible&lt;/em&gt;. All method parameters in an MXBean interface must be reconstructible, because when the MXBean framework is invoking a method it will need to convert those parameters from &lt;em&gt;opendata(J)&lt;/em&gt; to &lt;em&gt;J&lt;/em&gt;. In a proxy generated by &lt;a href=&quot;jmx#newMXBeanProxy(javax.management.MBeanServerConnection,javax.management.ObjectName,java.lang.Class)&quot;&gt;&lt;code&gt;JMX.newMXBeanProxy&lt;/code&gt;&lt;/a&gt;, it is the return values of the methods in the MXBean interface that must be reconstructible.</source>
          <target state="translated">如果有一种方法可以将&lt;em&gt;opendata（J）&lt;/em&gt;转换回&lt;em&gt;J，&lt;/em&gt;那么我们说&lt;em&gt;J&lt;/em&gt;是可&lt;em&gt;重构的&lt;/em&gt;。在MXBean接口所有方法参数必须是可重新，因为当MXBean框架调用一个方法，它需要将这些参数从转换&lt;em&gt;将opendata（J）&lt;/em&gt;至&lt;em&gt;Ĵ&lt;/em&gt;。在&lt;a href=&quot;jmx#newMXBeanProxy(javax.management.MBeanServerConnection,javax.management.ObjectName,java.lang.Class)&quot;&gt; &lt;code&gt;JMX.newMXBeanProxy&lt;/code&gt; &lt;/a&gt;生成的代理中，必须可重构的是MXBean接口中方法的返回值。</target>
        </trans-unit>
        <trans-unit id="f00389ed8595939dc871f12e3fcfe41a5531ae8a" translate="yes" xml:space="preserve">
          <source>If there is a way to convert &lt;em&gt;opendata(J)&lt;/em&gt; back to &lt;em&gt;J&lt;/em&gt; then we say that &lt;em&gt;J&lt;/em&gt; is &lt;em&gt;reconstructible&lt;/em&gt;. All method parameters in an MXBean interface must be reconstructible, because when the MXBean framework is invoking a method it will need to convert those parameters from &lt;em&gt;opendata(J)&lt;/em&gt; to &lt;em&gt;J&lt;/em&gt;. In a proxy generated by &lt;a href=&quot;jmx#newMXBeanProxy-javax.management.MBeanServerConnection-javax.management.ObjectName-java.lang.Class-&quot;&gt;&lt;code&gt;JMX.newMXBeanProxy&lt;/code&gt;&lt;/a&gt;, it is the return values of the methods in the MXBean interface that must be reconstructible.</source>
          <target state="translated">如果有一种方法可以将&lt;em&gt;opendata（J）&lt;/em&gt;转换回&lt;em&gt;J，&lt;/em&gt;那么我们说&lt;em&gt;J&lt;/em&gt;是可&lt;em&gt;重构的&lt;/em&gt;。在MXBean接口所有方法参数必须是可重新，因为当MXBean框架调用一个方法，它需要将这些参数从转换&lt;em&gt;将opendata（J）&lt;/em&gt;至&lt;em&gt;Ĵ&lt;/em&gt;。在&lt;a href=&quot;jmx#newMXBeanProxy-javax.management.MBeanServerConnection-javax.management.ObjectName-java.lang.Class-&quot;&gt; &lt;code&gt;JMX.newMXBeanProxy&lt;/code&gt; &lt;/a&gt;生成的代理中，必须可重构的是MXBean接口中方法的返回值。</target>
        </trans-unit>
        <trans-unit id="b80859daf00685681791770cf08af14640ed386a" translate="yes" xml:space="preserve">
          <source>If there is an embedded exception, and if the SAXException has no detail message of its own, this method will return the detail message from the embedded exception.</source>
          <target state="translated">如果有一个嵌入的异常,并且如果SAXException没有自己的细节消息,这个方法将返回嵌入异常的细节消息。</target>
        </trans-unit>
        <trans-unit id="d2e96a33766dec8129dace08a450401d0d9f28dc" translate="yes" xml:space="preserve">
          <source>If there is an error while loading or scaling an image, that image is considered to have finished loading. Use the &lt;code&gt;isErrorAny&lt;/code&gt; and &lt;code&gt;isErrorID&lt;/code&gt; methods to check for errors.</source>
          <target state="translated">如果在加载或缩放图像时出现错误，则认为该图像已完成加载。使用 &lt;code&gt;isErrorAny&lt;/code&gt; 和 &lt;code&gt;isErrorID&lt;/code&gt; 方法检查错误。</target>
        </trans-unit>
        <trans-unit id="a5644f977cf03bc3dcfd54d5e5282d96e0e8e7ab" translate="yes" xml:space="preserve">
          <source>If there is an error while loading or scaling an image, then that image is considered to have finished loading. Use the &lt;code&gt;isErrorAny&lt;/code&gt; and &lt;code&gt;isErrorID&lt;/code&gt; methods to check for errors.</source>
          <target state="translated">如果在加载或缩放图像时出现错误，则认为该图像已完成加载。使用 &lt;code&gt;isErrorAny&lt;/code&gt; 和 &lt;code&gt;isErrorID&lt;/code&gt; 方法检查错误。</target>
        </trans-unit>
        <trans-unit id="dac5311ab03433886854f19241b442e660113c11" translate="yes" xml:space="preserve">
          <source>If there is an error while loading or scaling an image, then that image is considered to have finished loading. Use the &lt;code&gt;isErrorAny&lt;/code&gt; or &lt;code&gt;isErrorID&lt;/code&gt; methods to check for errors.</source>
          <target state="translated">如果在加载或缩放图像时出现错误，则认为该图像已完成加载。使用 &lt;code&gt;isErrorAny&lt;/code&gt; 或 &lt;code&gt;isErrorID&lt;/code&gt; 方法检查错误。</target>
        </trans-unit>
        <trans-unit id="46881d0768f79ef8afcf68abaa71937fc7171ad1" translate="yes" xml:space="preserve">
          <source>If there is an error while loading or scaling an image, then that image is considered to have finished loading. Use the &lt;code&gt;statusID&lt;/code&gt;, &lt;code&gt;isErrorID&lt;/code&gt;, and &lt;code&gt;isErrorAny&lt;/code&gt; methods to check for errors.</source>
          <target state="translated">如果在加载或缩放图像时出现错误，则认为该图像已完成加载。使用 &lt;code&gt;statusID&lt;/code&gt; ， &lt;code&gt;isErrorID&lt;/code&gt; 和 &lt;code&gt;isErrorAny&lt;/code&gt; 方法检查错误。</target>
        </trans-unit>
        <trans-unit id="b8ec246e3bef63fa40b6bd7a53890c4d682a9eac" translate="yes" xml:space="preserve">
          <source>If there is an existing owner different from the argument &lt;code&gt;owner&lt;/code&gt;, that owner is notified that it no longer holds ownership of the clipboard contents via an invocation of &lt;code&gt;ClipboardOwner.lostOwnership()&lt;/code&gt; on that owner. An implementation of &lt;code&gt;setContents()&lt;/code&gt; is free not to invoke &lt;code&gt;lostOwnership()&lt;/code&gt; directly from this method. For example, &lt;code&gt;lostOwnership()&lt;/code&gt; may be invoked later on a different thread. The same applies to &lt;code&gt;FlavorListener&lt;/code&gt;s registered on this clipboard.</source>
          <target state="translated">如果从参数现有的所有者不同的 &lt;code&gt;owner&lt;/code&gt; ，该业主被告知不再通过的调用持有剪贴板内容的所有权 &lt;code&gt;ClipboardOwner.lostOwnership()&lt;/code&gt; 上的主人。 &lt;code&gt;setContents()&lt;/code&gt; 的实现可以自由地直接从此方法中调用 &lt;code&gt;lostOwnership()&lt;/code&gt; 。例如， &lt;code&gt;lostOwnership()&lt;/code&gt; 可以稍后在另一个线程上调用。这同样适用于在此剪贴板上注册的 &lt;code&gt;FlavorListener&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9bde7f17c2deabb0575bd222ed2f85f576a5ede8" translate="yes" xml:space="preserve">
          <source>If there is any error (say, I/O error or format error) during the reading process of the KeyTab file, a saved result should be returned. If there is no saved result (say, this is the first time this method is called, or, all previous read attempts failed), an empty array should be returned. This can make sure the result is not drastically changed during the (probably slow) update of the keytab file.</source>
          <target state="translated">如果在读取KeyTab文件的过程中出现了任何错误(比如,I/O错误或格式错误),那么应该返回一个保存的结果,如果没有保存的结果(比如,这是第一次调用这个方法,或者,之前所有的读取尝试都失败了),应该返回一个空数组。如果没有保存的结果(比如,这是第一次调用这个方法,或者,之前所有的读取尝试都失败了),应该返回一个空数组。这可以确保在更新keytab文件的过程中(很可能很慢),结果不会发生巨大的变化。</target>
        </trans-unit>
        <trans-unit id="20616256852615e42dbadb55ba5815746032d11a" translate="yes" xml:space="preserve">
          <source>If there is any error (say, I/O error or format error) during the reading process of the keytab file, a saved result should be returned. If there is no saved result (say, this is the first time this method is called, or, all previous read attempts failed), an empty array should be returned. This can make sure the result is not drastically changed during the (probably slow) update of the keytab file.</source>
          <target state="translated">如果在读取keytab文件的过程中出现任何错误(例如,I/O错误或格式错误),应该返回一个保存的结果。如果没有保存的结果(比如,这是第一次调用这个方法,或者,之前所有的读取尝试都失败了),应该返回一个空数组。这可以确保在更新keytab文件(可能很慢)的过程中,结果不会有大的变化。</target>
        </trans-unit>
        <trans-unit id="e2521f70370beeb7a65247f5ecdb6409da533aa1" translate="yes" xml:space="preserve">
          <source>If there is any inherited context, then it has already been copied into the &lt;code&gt;URL&lt;/code&gt; argument.</source>
          <target state="translated">如果存在任何继承的上下文，则它已经被复制到 &lt;code&gt;URL&lt;/code&gt; 参数中。</target>
        </trans-unit>
        <trans-unit id="1538c9e56cc4a72171a55abc846e5acdad6ad5c5" translate="yes" xml:space="preserve">
          <source>If there is at least one getter and every getter has a convertible type, then &lt;em&gt;opentype(J)&lt;/em&gt; is a &lt;code&gt;
      CompositeType&lt;/code&gt; with one item for every getter. If the getter is</source>
          <target state="translated">如果至少有一个吸气剂并且每个吸气剂都有一个可转换类型，则&lt;em&gt;opentype（J）&lt;/em&gt;是一个 &lt;code&gt; CompositeType&lt;/code&gt; ，每个吸气剂都有一个项目。如果吸气剂是</target>
        </trans-unit>
        <trans-unit id="ce492db546ed8f744751a5952cc84069d57cdf28" translate="yes" xml:space="preserve">
          <source>If there is at least one getter and every getter has a convertible type, then &lt;em&gt;opentype(J)&lt;/em&gt; is a &lt;code&gt;CompositeType&lt;/code&gt; with one item for every getter. If the getter is</source>
          <target state="translated">如果至少有一个吸气剂，并且每个吸气剂都有可转换的类型，则&lt;em&gt;opentype（J）&lt;/em&gt;是 &lt;code&gt;CompositeType&lt;/code&gt; ，每个吸气剂都有一个项目。如果吸气剂是</target>
        </trans-unit>
        <trans-unit id="f0a5ce38d1565c12f161531f62c2ed657aa770d3" translate="yes" xml:space="preserve">
          <source>If there is exactly one such interface, or if there is one such interface that is a subinterface of all the others, then the object is an MXBean. The interface in question is the &lt;em&gt;MXBean interface&lt;/em&gt;. In the example above, the MXBean interface is &lt;code&gt;MemoryPoolMXBean&lt;/code&gt;.</source>
          <target state="translated">如果恰好有一个这样的接口，或者如果有一个这样的接口是所有其他接口的子接口，则该对象是MXBean。有问题的接口是&lt;em&gt;MXBean接口&lt;/em&gt;。在上面的示例中，MXBean接口是 &lt;code&gt;MemoryPoolMXBean&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2719aa3eb5a7fffd1ca38e949931f67f1421af57" translate="yes" xml:space="preserve">
          <source>If there is no &lt;code&gt;serviceURL&lt;/code&gt;, there must be a user-provided &lt;code&gt;RMIServerImpl&lt;/code&gt;. If the &lt;a href=&quot;rmiserverimpl#toStub--&quot;&gt;&lt;code&gt;toStub&lt;/code&gt;&lt;/a&gt; method on this object returns an instance of &lt;a href=&quot;/openjdk~8_web/javax/rmi/corba/stub&quot;&gt;&lt;code&gt;Stub&lt;/code&gt;&lt;/a&gt;, then the connector server will generate a &lt;code&gt;JMXServiceURL&lt;/code&gt; using the &lt;code&gt;iiop&lt;/code&gt; form above. Otherwise, it will generate a &lt;code&gt;JMXServiceURL&lt;/code&gt; using the &lt;code&gt;rmi&lt;/code&gt; form.</source>
          <target state="translated">如果没有 &lt;code&gt;serviceURL&lt;/code&gt; ，则必须有一个用户提供的 &lt;code&gt;RMIServerImpl&lt;/code&gt; 。如果此对象上的&lt;a href=&quot;rmiserverimpl#toStub--&quot;&gt; &lt;code&gt;toStub&lt;/code&gt; &lt;/a&gt;方法返回&lt;a href=&quot;/openjdk~8_web/javax/rmi/corba/stub&quot;&gt; &lt;code&gt;Stub&lt;/code&gt; &lt;/a&gt;的实例，则连接器服务器将使用上面的 &lt;code&gt;iiop&lt;/code&gt; 形式生成 &lt;code&gt;JMXServiceURL&lt;/code&gt; 。否则，它将使用 &lt;code&gt;rmi&lt;/code&gt; 表单生成 &lt;code&gt;JMXServiceURL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8a2bf9ecdfc5d61123d9e4fc43dc1ffa56add6c1" translate="yes" xml:space="preserve">
          <source>If there is no &lt;code&gt;serviceURL&lt;/code&gt;, there must be a user-provided &lt;code&gt;RMIServerImpl&lt;/code&gt;. The connector server will generate a &lt;code&gt;JMXServiceURL&lt;/code&gt; using the &lt;code&gt;rmi&lt;/code&gt; form.</source>
          <target state="translated">如果没有 &lt;code&gt;serviceURL&lt;/code&gt; ，则必须有一个用户提供的 &lt;code&gt;RMIServerImpl&lt;/code&gt; 。连接器服务器将使用 &lt;code&gt;rmi&lt;/code&gt; 表单生成 &lt;code&gt;JMXServiceURL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f8c7ed9aa34be8bbca1c409e4e9d8af9947fac39" translate="yes" xml:space="preserve">
          <source>If there is no association existing between this channel's socket and the intended receiver, identified by the address in the given messageInfo, then one will be automatically setup to the intended receiver. This is considered to be Implicit Association Setup. Upon successful association setup, an &lt;a href=&quot;associationchangenotification&quot;&gt;&lt;code&gt;association changed&lt;/code&gt;&lt;/a&gt; notification will be put to the SCTP stack with its &lt;code&gt;event&lt;/code&gt; parameter set to &lt;a href=&quot;associationchangenotification.assocchangeevent#COMM_UP&quot;&gt;&lt;code&gt;COMM_UP&lt;/code&gt;&lt;/a&gt; . This notification can be received by invoking &lt;a href=&quot;#receive(java.nio.ByteBuffer,T,com.sun.nio.sctp.NotificationHandler)&quot;&gt;&lt;code&gt;receive&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果此通道的套接字与目标接收者之间不存在关联（由给定messageInfo中的地址标识），则将自动为目标接收者设置一个关联。这被认为是隐式关联设置。成功建立关联后，&lt;a href=&quot;associationchangenotification&quot;&gt; &lt;code&gt;association changed&lt;/code&gt; &lt;/a&gt;通知将被放入SCTP堆栈，其 &lt;code&gt;event&lt;/code&gt; 参数设置为&lt;a href=&quot;associationchangenotification.assocchangeevent#COMM_UP&quot;&gt; &lt;code&gt;COMM_UP&lt;/code&gt; &lt;/a&gt;。可以通过调用&lt;a href=&quot;#receive(java.nio.ByteBuffer,T,com.sun.nio.sctp.NotificationHandler)&quot;&gt; &lt;code&gt;receive&lt;/code&gt; &lt;/a&gt;来接收此通知。</target>
        </trans-unit>
        <trans-unit id="2cc3dec11f4378075a31721786189ded4db361d5" translate="yes" xml:space="preserve">
          <source>If there is no current set of system properties, a set of system properties is first created and initialized in the same manner as for the &lt;code&gt;getProperties&lt;/code&gt; method.</source>
          <target state="translated">如果没有当前的系统属性集，则首先以与 &lt;code&gt;getProperties&lt;/code&gt; 方法相同的方式创建和初始化一组系统属性。</target>
        </trans-unit>
        <trans-unit id="62385658f9c9d30f2326007c7be1947af3806233" translate="yes" xml:space="preserve">
          <source>If there is no display name for the locale then a suitable default must be returned.</source>
          <target state="translated">如果没有locale的显示名称,那么必须返回一个合适的默认值。</target>
        </trans-unit>
        <trans-unit id="14d757aed623c13896747a1cb10d2fafe0c24ef5" translate="yes" xml:space="preserve">
          <source>If there is no entry for a particular principal, then the principal is considered to have a null (empty) permission set.</source>
          <target state="translated">如果没有特定委托人的条目,则认为该委托人的权限集为空(空)。</target>
        </trans-unit>
        <trans-unit id="83cc3943509d49fbbe54f8e7d0348cb9ef645fa2" translate="yes" xml:space="preserve">
          <source>If there is no entry in this Access Control List for the specified principal, an empty permission set is returned.</source>
          <target state="translated">如果该访问控制列表中没有指定委托人的条目,则返回一个空权限集。</target>
        </trans-unit>
        <trans-unit id="97ef1aceb0bd9ccbc5a3e085bc385c17a96da05c" translate="yes" xml:space="preserve">
          <source>If there is no index position at which they differ, then the shorter string lexicographically precedes the longer string. In this case, &lt;code&gt;compareTo&lt;/code&gt; returns the difference of the lengths of the strings -- that is, the value:</source>
          <target state="translated">如果没有索引位置不同，则按字典顺序，较短的字符串在较长的字符串之前。在这种情况下， &lt;code&gt;compareTo&lt;/code&gt; 返回字符串长度的差-即值：</target>
        </trans-unit>
        <trans-unit id="a5b86c82cbb33ba85e2cf972377173b04ef65d60" translate="yes" xml:space="preserve">
          <source>If there is no input method or keyboard layout available that supports the requested locale, the current input method or keyboard layout remains selected.</source>
          <target state="translated">如果没有可用的输入法或键盘布局支持所要求的语言,则当前的输入法或键盘布局仍被选中。</target>
        </trans-unit>
        <trans-unit id="f38d945bc914e61ae40e4aad1f19fc041a605394" translate="yes" xml:space="preserve">
          <source>If there is no match, then either the first or last index is used, depending on whether the number (X) is too low or too high. If the limit array is not in ascending order, the results of formatting will be incorrect. ChoiceFormat also accepts &lt;code&gt;\u221E&lt;/code&gt; as equivalent to infinity(INF).</source>
          <target state="translated">如果不匹配，则根据数字（X）太低还是太高，使用第一个索引或最后一个索引。如果limit数组不是按升序排列，则格式化结果将不正确。ChoiceFormat也接受 &lt;code&gt;\u221E&lt;/code&gt; 等效于infinity（INF）。</target>
        </trans-unit>
        <trans-unit id="2648977b5bfdd7de94f30791f17e5163fa9fa3c2" translate="yes" xml:space="preserve">
          <source>If there is no parent reader set, any attempt to parse or to set or get a feature or property will fail.</source>
          <target state="translated">如果没有设置父读者,任何解析或设置或获取特征或属性的尝试都会失败。</target>
        </trans-unit>
        <trans-unit id="f3d0e4d2da1282aaec455fc4732cff1c598c3d7c" translate="yes" xml:space="preserve">
          <source>If there is no property with the specified name, if the specified name is empty or &lt;code&gt;null&lt;/code&gt;, or if the property does not have the correct numeric format, then &lt;code&gt;null&lt;/code&gt; is returned.</source>
          <target state="translated">如果没有具有指定名称的属性，如果指定名称为 &lt;code&gt;null&lt;/code&gt; 或null，或者该属性的格式不正确，则返回 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ebec043b114adf3a66c121103ae990378ebe9b9b" translate="yes" xml:space="preserve">
          <source>If there is no property with the specified name, or if the specified name is empty or null, then &lt;code&gt;false&lt;/code&gt; is returned.</source>
          <target state="translated">如果没有具有指定名称的属性，或者指定的名称为空或null，则返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="217c4e72fc9b4dd43cf1ac4eaa272b71123427a9" translate="yes" xml:space="preserve">
          <source>If there is no such parameter list, the external parameter list is taken to be the empty sequence.</source>
          <target state="translated">如果没有这样的参数列表,则外部参数列表取为空序列。</target>
        </trans-unit>
        <trans-unit id="62eecfe9a255148d750e0784a244f5d095566c9e" translate="yes" xml:space="preserve">
          <source>If there is one or more timer notifications before the time in the list of notifications, the notification is sent according to the &lt;code&gt;sendPastNotifications&lt;/code&gt; flag and then, updated according to its period and remaining number of occurrences. If the timer notification date remains earlier than the current date, this notification is just removed from the list of notifications.</source>
          <target state="translated">如果在通知列表中的时间之前有一个或多个计时器通知，则根据 &lt;code&gt;sendPastNotifications&lt;/code&gt; 标志发送该通知，然后根据其周期和剩余发生次数进行更新。如果计时器通知日期仍早于当前日期，则此通知将从通知列表中删除。</target>
        </trans-unit>
        <trans-unit id="b3edef51748fde1dc3cb9b0db38c74d836448067" translate="yes" xml:space="preserve">
          <source>If these fields have not been set, meaning that the &lt;code&gt;execute&lt;/code&gt; method has not executed successfully, no methods other than &lt;code&gt;execute&lt;/code&gt; and &lt;code&gt;close&lt;/code&gt; may be called on the rowset. All other public methods will throw an exception.</source>
          <target state="translated">如果未设置这些字段，则意味着 &lt;code&gt;execute&lt;/code&gt; 方法没有成功 &lt;code&gt;execute&lt;/code&gt; ，则行集上除了execute和 &lt;code&gt;close&lt;/code&gt; 之外的任何方法都不能调用。所有其他公共方法都将引发异常。</target>
        </trans-unit>
        <trans-unit id="da9dbbb1b206e8e0a44cdf5f294d39074c1d1013" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents a class or interface that implements no interfaces, the method returns an array of length 0.</source>
          <target state="translated">如果此 &lt;code&gt;Class&lt;/code&gt; 对象表示不实现任何接口的类或接口，则该方法返回长度为0的数组。</target>
        </trans-unit>
        <trans-unit id="bea1d12841642f06cd5c576dd8ad73a21f49fc5b" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents a class or interface whose declaration does not explicitly indicate any annotated superinterfaces, the return value is an array of length 0.</source>
          <target state="translated">如果此 &lt;code&gt;Class&lt;/code&gt; 对象表示其声明未明确指示任何带注释的超级接口的类或接口，则返回值为长度为0的数组。</target>
        </trans-unit>
        <trans-unit id="6e8416f8b31967b12db27ca7304aeef5569fa6c8" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents a class or interface with no accessible public fields, then this method returns an array of length 0.</source>
          <target state="translated">如果此 &lt;code&gt;Class&lt;/code&gt; 对象表示没有可访问公共字段的类或接口，则此方法返回长度为0的数组。</target>
        </trans-unit>
        <trans-unit id="94f6da01be13858770dcd2fbeb1c8376bf8f27d5" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents a class or interface with no declared fields, then this method returns an array of length 0.</source>
          <target state="translated">如果此 &lt;code&gt;Class&lt;/code&gt; 对象表示没有声明字段的类或接口，则此方法返回长度为0的数组。</target>
        </trans-unit>
        <trans-unit id="c5e526ec67c2b068f6813c00e0742ddec3d6151e" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents a class or interface with no declared methods, then the returned array has length 0.</source>
          <target state="translated">如果此 &lt;code&gt;Class&lt;/code&gt; 对象表示没有声明方法的类或接口，则返回的数组长度为0。</target>
        </trans-unit>
        <trans-unit id="d4ce471ae16ab801b2259a590ff7a0fee5c25fdb" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents a class or interface with no no accessible public fields, then this method returns an array of length 0.</source>
          <target state="translated">如果此 &lt;code&gt;Class&lt;/code&gt; 对象表示没有可访问的公共字段的类或接口，则此方法返回长度为0的数组。</target>
        </trans-unit>
        <trans-unit id="89bb69095909bff1e8994753820a646783cdac75" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents a class or interface, not an array class, then:</source>
          <target state="translated">如果此 &lt;code&gt;Class&lt;/code&gt; 对象表示一个类或接口，而不是一个数组类，则：</target>
        </trans-unit>
        <trans-unit id="c664406d0522e22c26f8aa4cf18c2f0c9efc994e" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents a class, the return value is an array containing objects representing all interfaces directly implemented by the class. The order of the interface objects in the array corresponds to the order of the interface names in the &lt;code&gt;implements&lt;/code&gt; clause of the declaration of the class represented by this &lt;code&gt;Class&lt;/code&gt; object.</source>
          <target state="translated">如果此 &lt;code&gt;Class&lt;/code&gt; 对象表示一个类，则返回值是一个包含对象的数组，这些对象表示该类直接实现的所有接口。数组中接口对象的顺序与该 &lt;code&gt;Class&lt;/code&gt; 对象表示的类的声明的 &lt;code&gt;implements&lt;/code&gt; 子句中接口名称的顺序相对应。</target>
        </trans-unit>
        <trans-unit id="db27714da382f703a913c7a11179d75442553bce" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents a class, the return value is an array containing objects representing all interfaces directly implemented by the class. The order of the interface objects in the array corresponds to the order of the interface names in the &lt;code&gt;implements&lt;/code&gt; clause of the declaration of the class represented by this &lt;code&gt;Class&lt;/code&gt; object. For example, given the declaration:</source>
          <target state="translated">如果此 &lt;code&gt;Class&lt;/code&gt; 对象表示一个类，则返回值是一个包含对象的数组，这些对象表示该类直接实现的所有接口。数组中接口对象的顺序与该 &lt;code&gt;Class&lt;/code&gt; 对象表示的类的声明的 &lt;code&gt;implements&lt;/code&gt; 子句中接口名称的顺序相对应。例如，给定声明：</target>
        </trans-unit>
        <trans-unit id="c9c0f2616e4b918558184c0ef2f121a34cc9b89a" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents a class, the return value is an array containing objects representing the uses of interface types to specify interfaces implemented by the class. The order of the objects in the array corresponds to the order of the interface types used in the 'implements' clause of the declaration of this &lt;code&gt;Class&lt;/code&gt; object.</source>
          <target state="translated">如果此 &lt;code&gt;Class&lt;/code&gt; 对象表示一个类，则返回值是一个包含对象的数组，这些对象表示使用接口类型指定由该类实现的接口。数组中对象的顺序与此 &lt;code&gt;Class&lt;/code&gt; 对象的声明的&amp;ldquo; implements&amp;rdquo;子句中使用的接口类型的顺序相对应。</target>
        </trans-unit>
        <trans-unit id="972bf4d56f599ffc46c00671b73ed210f8ab96fd" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents a class, then this method returns the public fields of the class and of all its superclasses and superinterfaces.</source>
          <target state="translated">如果此 &lt;code&gt;Class&lt;/code&gt; 对象表示一个类，则此方法返回该类及其所有超类和超接口的公共字段。</target>
        </trans-unit>
        <trans-unit id="8ea0225aadb3a9617c32673581f4007aea0f62a1" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents a class, then this method returns the public fields of the class and of all its superclasses.</source>
          <target state="translated">如果此 &lt;code&gt;Class&lt;/code&gt; 对象表示一个类，则此方法返回该类及其所有超类的公共字段。</target>
        </trans-unit>
        <trans-unit id="19efbdc41b97ce163692b9570014a1cf2d915716" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents a local or anonymous class within a constructor, returns a &lt;a href=&quot;reflect/constructor&quot;&gt;&lt;code&gt;Constructor&lt;/code&gt;&lt;/a&gt; object representing the immediately enclosing constructor of the underlying class.</source>
          <target state="translated">如果此 &lt;code&gt;Class&lt;/code&gt; 对象表示构造函数中的本地或匿名类，则返回一个&lt;a href=&quot;reflect/constructor&quot;&gt; &lt;code&gt;Constructor&lt;/code&gt; &lt;/a&gt;对象，该对象表示基础类的直接封闭的构造函数。</target>
        </trans-unit>
        <trans-unit id="42af070ad6a4d3648b309df9a277dd2d8e338352" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents a local or anonymous class within a constructor, returns a &lt;a href=&quot;reflect/constructor&quot;&gt;&lt;code&gt;Constructor&lt;/code&gt;&lt;/a&gt; object representing the immediately enclosing constructor of the underlying class. Returns &lt;code&gt;null&lt;/code&gt; otherwise. In particular, this method returns &lt;code&gt;null&lt;/code&gt; if the underlying class is a local or anonymous class immediately enclosed by a type declaration, instance initializer or static initializer.</source>
          <target state="translated">如果此 &lt;code&gt;Class&lt;/code&gt; 对象表示构造函数内的本地或匿名类，则返回一个&lt;a href=&quot;reflect/constructor&quot;&gt; &lt;code&gt;Constructor&lt;/code&gt; &lt;/a&gt;对象，该对象表示基础类的直接封闭的构造函数。否则返回 &lt;code&gt;null&lt;/code&gt; 。特别是，如果基础类是立即由类型声明，实例初始化器或静态初始化器包围的本地或匿名类，则此方法返回 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="97ef3bf0bcc99ac4678b3a68f5947eddd7c49a75" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents a local or anonymous class within a method, returns a &lt;a href=&quot;reflect/method&quot;&gt;&lt;code&gt;Method&lt;/code&gt;&lt;/a&gt; object representing the immediately enclosing method of the underlying class.</source>
          <target state="translated">如果此 &lt;code&gt;Class&lt;/code&gt; 对象表示方法中的本地或匿名类，则返回表示基础类的直接封闭方法的&lt;a href=&quot;reflect/method&quot;&gt; &lt;code&gt;Method&lt;/code&gt; &lt;/a&gt;对象。</target>
        </trans-unit>
        <trans-unit id="4477ae736ceef4ce368b1839297468a2918b1155" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents a local or anonymous class within a method, returns a &lt;a href=&quot;reflect/method&quot;&gt;&lt;code&gt;Method&lt;/code&gt;&lt;/a&gt; object representing the immediately enclosing method of the underlying class. Returns &lt;code&gt;null&lt;/code&gt; otherwise. In particular, this method returns &lt;code&gt;null&lt;/code&gt; if the underlying class is a local or anonymous class immediately enclosed by a type declaration, instance initializer or static initializer.</source>
          <target state="translated">如果此 &lt;code&gt;Class&lt;/code&gt; 对象表示方法中的本地或匿名类，则返回表示基础类的直接封闭方法的&lt;a href=&quot;reflect/method&quot;&gt; &lt;code&gt;Method&lt;/code&gt; &lt;/a&gt;对象。否则返回 &lt;code&gt;null&lt;/code&gt; 。特别是，如果基础类是由类型声明，实例初始化器或静态初始化器立即包围的本地或匿名类，则此方法返回 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2a3ae28f0cc9994a8418c1f25794acf0dba7ddbd" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents a primitive type or &lt;code&gt;void&lt;/code&gt;, then the result is a field descriptor string which is a one-letter code corresponding to a primitive type or &lt;code&gt;void&lt;/code&gt; (&lt;code&gt;&quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;F&quot;, &quot;I&quot;, &quot;J&quot;, &quot;S&quot;, &quot;Z&quot;, &quot;V&quot;&lt;/code&gt;) (JVMS &lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se15/html/jvms-4.html#jls-4.3.2&quot;&gt;4.3.2&lt;/a&gt;).</source>
          <target state="translated">如果此 &lt;code&gt;Class&lt;/code&gt; 对象表示原始类型或 &lt;code&gt;void&lt;/code&gt; ，则结果为字段描述符字符串，该字符串是与原始类型或 &lt;code&gt;void&lt;/code&gt; 对应的一个字母代码（ &lt;code&gt;&quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;F&quot;, &quot;I&quot;, &quot;J&quot;, &quot;S&quot;, &quot;Z&quot;, &quot;V&quot;&lt;/code&gt; ）（JVMS &lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se15/html/jvms-4.html#jls-4.3.2&quot;&gt;4.3.2&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="eddd017ac2fa648338a5adfef36719dffa6cd4a7" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents a primitive type or &lt;code&gt;void&lt;/code&gt;, then the result is a string with the same spelling as the Java language keyword which corresponds to the primitive type or &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">如果此 &lt;code&gt;Class&lt;/code&gt; 对象表示原始类型或 &lt;code&gt;void&lt;/code&gt; ，则结果是与原始语言类型或 &lt;code&gt;void&lt;/code&gt; 对应的字符串，其拼写与Java语言关键字相同。</target>
        </trans-unit>
        <trans-unit id="0ce8f59b51441dc3e0dfd4f500ca0b103d2aa378" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents a primitive type or void, null is returned.</source>
          <target state="translated">如果此 &lt;code&gt;Class&lt;/code&gt; 对象表示原始类型或void，则返回null。</target>
        </trans-unit>
        <trans-unit id="e7e1076c9609cebd2628d37243affd492d58bbb2" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents a primitive type or void, the method returns an array of length 0.</source>
          <target state="translated">如果此 &lt;code&gt;Class&lt;/code&gt; 对象表示原始类型或void，则该方法返回长度为0的数组。</target>
        </trans-unit>
        <trans-unit id="79bd7175460e43940d330fea2bc43e369e031bbb" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents a primitive type or void, then the returned array has length 0.</source>
          <target state="translated">如果此 &lt;code&gt;Class&lt;/code&gt; 对象表示原始类型或void，则返回的数组长度为0。</target>
        </trans-unit>
        <trans-unit id="3854e372a9cd1fcdc624d6d86e1f2d3b92f49c92" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents a primitive type, an array type, or &lt;code&gt;void&lt;/code&gt;, then this method returns &lt;code&gt;this&lt;/code&gt;, indicating that the represented entity belongs to the nest consisting only of itself, and is the nest host.</source>
          <target state="translated">如果此 &lt;code&gt;Class&lt;/code&gt; 对象表示原始类型，数组类型或 &lt;code&gt;void&lt;/code&gt; ，则此方法返回 &lt;code&gt;this&lt;/code&gt; ，指示表示的实体属于仅由其自身组成的嵌套，并且是嵌套宿主。</target>
        </trans-unit>
        <trans-unit id="acfe2652412126a5eafdde5443108fc5fd2020f2" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents a primitive type, an array type, or &lt;code&gt;void&lt;/code&gt;, then this method returns a single-element array containing &lt;code&gt;this&lt;/code&gt;.</source>
          <target state="translated">如果此 &lt;code&gt;Class&lt;/code&gt; 对象表示原始类型，数组类型或 &lt;code&gt;void&lt;/code&gt; ，则此方法返回包含 &lt;code&gt;this&lt;/code&gt; 的单元素数组。</target>
        </trans-unit>
        <trans-unit id="f02c0ed1f5bae30d0291b5a6aaf11110bd96f07d" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents a type that has a class initialization method &lt;code&gt;&amp;lt;clinit&amp;gt;&lt;/code&gt;, then the returned array does &lt;em&gt;not&lt;/em&gt; have a corresponding &lt;code&gt;Method&lt;/code&gt; object.</source>
          <target state="translated">如果此 &lt;code&gt;Class&lt;/code&gt; 对象表示具有类初始化方法的类型 &lt;code&gt;&amp;lt;clinit&amp;gt;&lt;/code&gt; ，则返回的数组并&lt;em&gt;不&lt;/em&gt;具有相应的 &lt;code&gt;Method&lt;/code&gt; 的对象。</target>
        </trans-unit>
        <trans-unit id="c4b86687e1e312e67b7460fddd5aed10106e1e53" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents a type that has multiple declared methods with the same name and parameter types, but different return types, then the returned array has a &lt;code&gt;Method&lt;/code&gt; object for each such method.</source>
          <target state="translated">如果此 &lt;code&gt;Class&lt;/code&gt; 对象表示一个类型，该类型具有多个声明的方法，这些方法具有相同的名称和参数类型，但返回类型不同，则对于每个此类方法，返回的数组都有一个 &lt;code&gt;Method&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="6a5139658d7d0116078759c8a142a520e5a7e171" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents a type that has multiple public methods with the same name and parameter types, but different return types, then the returned array has a &lt;code&gt;Method&lt;/code&gt; object for each such method.</source>
          <target state="translated">如果此 &lt;code&gt;Class&lt;/code&gt; 对象表示具有多个具有相同名称和参数类型但返回类型不同的公共方法的类型，则对于每个此类方法，返回的数组均具有 &lt;code&gt;Method&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="f9710c2aebb0499fff54a4c1fab48952630f8353" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents a type whose declaration does not explicitly indicate an annotated superclass, then the return value is an &lt;code&gt;AnnotatedType&lt;/code&gt; object representing an element with no annotations.</source>
          <target state="translated">如果此 &lt;code&gt;Class&lt;/code&gt; 对象表示其声明未明确指示带注释的超类的类型，则返回值为 &lt;code&gt;AnnotatedType&lt;/code&gt; 对象，该对象表示不带注释的元素。</target>
        </trans-unit>
        <trans-unit id="abacab4cf9b024f594f0b3f572123f051f06c2c5" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents a type with a class initialization method &lt;code&gt;&amp;lt;clinit&amp;gt;&lt;/code&gt;, then the returned array does &lt;em&gt;not&lt;/em&gt; have a corresponding &lt;code&gt;Method&lt;/code&gt; object.</source>
          <target state="translated">如果此 &lt;code&gt;Class&lt;/code&gt; 对象表示与类初始化方法的类型 &lt;code&gt;&amp;lt;clinit&amp;gt;&lt;/code&gt; ，则返回的数组并&lt;em&gt;不&lt;/em&gt;具有相应的 &lt;code&gt;Method&lt;/code&gt; 的对象。</target>
        </trans-unit>
        <trans-unit id="967e996b2092a0d523d490bc35ee89ac74138a79" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents an array class, then the result is a string consisting of one or more '&lt;code&gt;[&lt;/code&gt;' characters representing the depth of the array nesting, followed by the descriptor string of the element type.</source>
          <target state="translated">如果此 &lt;code&gt;Class&lt;/code&gt; 对象表示数组类，则结果是一个字符串，该字符串由一个或多个代表数组嵌套深度的' &lt;code&gt;[&lt;/code&gt; '字符组成，后跟元素类型的描述符字符串。</target>
        </trans-unit>
        <trans-unit id="f14a8b922cdce1119585c5f1a0795f16cbd6be65" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents an array class, then the result is a string consisting of one or more '&lt;code&gt;[&lt;/code&gt;' characters representing the depth of the array nesting, followed by the element type as encoded using the following table:</source>
          <target state="translated">如果此 &lt;code&gt;Class&lt;/code&gt; 对象表示数组类，则结果是一个字符串，该字符串由一个或多个代表数组嵌套深度的' &lt;code&gt;[&lt;/code&gt; '字符组成，后跟使用下表编码的元素类型：</target>
        </trans-unit>
        <trans-unit id="1bebb6eaefac5ae2ce6d923cc8da1eb725883029" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents an array type, a primitive type, or void, then the returned array has length 0.</source>
          <target state="translated">如果此 &lt;code&gt;Class&lt;/code&gt; 对象表示数组类型，原始类型或void，则返回的数组长度为0。</target>
        </trans-unit>
        <trans-unit id="70b797601062908da356817410150aa204020fc1" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents an array type, a primitive type, or void, then this method returns an array of length 0.</source>
          <target state="translated">如果此 &lt;code&gt;Class&lt;/code&gt; 对象表示数组类型，原始类型或void，则此方法返回长度为0的数组。</target>
        </trans-unit>
        <trans-unit id="20332c048f55b2154c66a445225edb4bdb3e274e" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents an array type, the interfaces &lt;code&gt;Cloneable&lt;/code&gt; and &lt;code&gt;java.io.Serializable&lt;/code&gt; are returned in that order.</source>
          <target state="translated">如果此 &lt;code&gt;Class&lt;/code&gt; 对象表示数组类型，则按此顺序返回接口 &lt;code&gt;Cloneable&lt;/code&gt; 和 &lt;code&gt;java.io.Serializable&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="348539037139d48e6387c9a62912e6564911c876" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents an array type, then the returned array has a &lt;code&gt;Method&lt;/code&gt; object for each of the public methods inherited by the array type from &lt;code&gt;Object&lt;/code&gt;. It does not contain a &lt;code&gt;Method&lt;/code&gt; object for &lt;code&gt;clone()&lt;/code&gt;.</source>
          <target state="translated">如果此 &lt;code&gt;Class&lt;/code&gt; 对象表示数组类型，则对于数组类型从 &lt;code&gt;Object&lt;/code&gt; 继承的每个公共方法，返回的数组都有一个 &lt;code&gt;Method&lt;/code&gt; 对象。它不包含 &lt;code&gt;clone()&lt;/code&gt; 的 &lt;code&gt;Method&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="29e81a940f259cfb7b07c0e245bb52be63c0dd30" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents an array type, then this method does not find the &lt;code&gt;clone()&lt;/code&gt; method.</source>
          <target state="translated">如果此 &lt;code&gt;Class&lt;/code&gt; 对象表示数组类型，则此方法找不到 &lt;code&gt;clone()&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="cb178a8f1871d07a34cdb3bb2de9a0c1fb20f2b9" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents an array type, then this method does not find the &lt;code&gt;length&lt;/code&gt; field of the array type.</source>
          <target state="translated">如果此 &lt;code&gt;Class&lt;/code&gt; 对象表示数组类型，则此方法找不到数组类型的 &lt;code&gt;length&lt;/code&gt; 字段。</target>
        </trans-unit>
        <trans-unit id="4bd7f84a076a4583d7107678dfa8e8e6a579b02f" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents an array type, then this method finds any public method inherited by the array type from &lt;code&gt;Object&lt;/code&gt; except method &lt;code&gt;clone()&lt;/code&gt;.</source>
          <target state="translated">如果此 &lt;code&gt;Class&lt;/code&gt; 对象表示数组类型，则此方法将查找 &lt;code&gt;Object&lt;/code&gt; 从该数组类型继承的任何公共方法，除了方法 &lt;code&gt;clone()&lt;/code&gt; 之外。</target>
        </trans-unit>
        <trans-unit id="3c4b35440106aa65e3bd6d1155d9e17869493181" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents an interface then the returned array does not contain any implicitly declared methods from &lt;code&gt;Object&lt;/code&gt;. Therefore, if no methods are explicitly declared in this interface or any of its superinterfaces then the returned array has length 0. (Note that a &lt;code&gt;Class&lt;/code&gt; object which represents a class always has public methods, inherited from &lt;code&gt;Object&lt;/code&gt;.)</source>
          <target state="translated">如果此 &lt;code&gt;Class&lt;/code&gt; 对象表示一个接口，则返回的数组不包含 &lt;code&gt;Object&lt;/code&gt; 的任何隐式声明的方法。因此，如果没有在此接口或其任何超级接口中显式声明任何方法，则返回的数组的长度为0。（请注意，表示类的 &lt;code&gt;Class&lt;/code&gt; 对象始终具有从 &lt;code&gt;Object&lt;/code&gt; 继承的公共方法）。</target>
        </trans-unit>
        <trans-unit id="50a58368b3e27e2351421689396e8aedc8df4704" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents an interface then this method does not find any implicitly declared method from &lt;code&gt;Object&lt;/code&gt;. Therefore, if no methods are explicitly declared in this interface or any of its superinterfaces, then this method does not find any method.</source>
          <target state="translated">如果此 &lt;code&gt;Class&lt;/code&gt; 对象表示一个接口，则此方法从 &lt;code&gt;Object&lt;/code&gt; 中找不到任何隐式声明的方法。因此，如果在此接口或其任何超级接口中未明确声明任何方法，则此方法将找不到任何方法。</target>
        </trans-unit>
        <trans-unit id="45c9a0ebbda8feb26f5e010d8c8f598fe0c99748" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents an interface, the array contains objects representing all interfaces directly extended by the interface. The order of the interface objects in the array corresponds to the order of the interface names in the &lt;code&gt;extends&lt;/code&gt; clause of the declaration of the interface represented by this &lt;code&gt;Class&lt;/code&gt; object.</source>
          <target state="translated">如果此 &lt;code&gt;Class&lt;/code&gt; 对象表示一个接口，则该数组包含的对象表示所有由该接口直接扩展的接口。数组中接口对象的顺序与此 &lt;code&gt;Class&lt;/code&gt; 对象表示的接口的声明的 &lt;code&gt;extends&lt;/code&gt; 子句中接口名称的顺序相对应。</target>
        </trans-unit>
        <trans-unit id="9d2d45c96fc82cd4f5045bb65c083bb3e36fa1de" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents an interface, the return value is an array containing objects representing the uses of interface types to specify interfaces directly extended by the interface. The order of the objects in the array corresponds to the order of the interface types used in the 'extends' clause of the declaration of this &lt;code&gt;Class&lt;/code&gt; object.</source>
          <target state="translated">如果此 &lt;code&gt;Class&lt;/code&gt; 对象表示一个接口，则返回值是一个包含对象的数组，这些对象表示使用接口类型来指定由接口直接扩展的接口。数组中对象的顺序与该 &lt;code&gt;Class&lt;/code&gt; 对象的声明的&amp;ldquo; extends&amp;rdquo;子句中使用的接口类型的顺序相对应。</target>
        </trans-unit>
        <trans-unit id="0f7aab31089775b3540a55de72ec8246707dca71" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents an interface, then this method returns the fields of the interface and of all its superinterfaces.</source>
          <target state="translated">如果此 &lt;code&gt;Class&lt;/code&gt; 对象表示一个接口，则此方法返回该接口及其所有超级接口的字段。</target>
        </trans-unit>
        <trans-unit id="24fcfbcd558d192b46d9d8daf24bd3361c63931e" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents either the &lt;code&gt;Object&lt;/code&gt; class, an array type, a primitive type, or void, the return value is an array of length 0.</source>
          <target state="translated">如果此 &lt;code&gt;Class&lt;/code&gt; 对象表示 &lt;code&gt;Object&lt;/code&gt; 类，数组类型，原始类型或void，则返回值为长度为0的数组。</target>
        </trans-unit>
        <trans-unit id="74ef85a38a3ffe3f10aa47e5d033acb048da33fd" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; represents either the &lt;code&gt;Object&lt;/code&gt; class, an interface type, an array type, a primitive type, or void, the return value is &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">如果此 &lt;code&gt;Class&lt;/code&gt; 表示 &lt;code&gt;Object&lt;/code&gt; 类，接口类型，数组类型，原始类型或void，则返回值为 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b79ca71cca6aeb6a7facb903fa697dd31da36756" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Container&lt;/code&gt; is not valid, this method invokes the &lt;code&gt;validateTree&lt;/code&gt; method and marks this &lt;code&gt;Container&lt;/code&gt; as valid. Otherwise, no action is performed.</source>
          <target state="translated">如果此 &lt;code&gt;Container&lt;/code&gt; 无效，则此方法将调用 &lt;code&gt;validateTree&lt;/code&gt; 方法并将此 &lt;code&gt;Container&lt;/code&gt; 标记为有效。否则，将不执行任何操作。</target>
        </trans-unit>
        <trans-unit id="d61b3bb217a8c25d2209158ddd28a60999b5d264" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Deflater&lt;/code&gt; has been subclassed and the &lt;code&gt;end&lt;/code&gt; method has been overridden, the &lt;code&gt;end&lt;/code&gt; method will be called by the finalization when the deflater is unreachable. But the subclasses should not depend on this specific implementation; the finalization is not reliable and the &lt;code&gt;finalize&lt;/code&gt; method is deprecated to be removed.</source>
          <target state="translated">如果这个 &lt;code&gt;Deflater&lt;/code&gt; 已经子类和 &lt;code&gt;end&lt;/code&gt; 方法已被重写，则 &lt;code&gt;end&lt;/code&gt; 方法将由最后定稿时调用的时候deflater不可达。但是子类不应依赖于此特定的实现。终结不可靠，并且不建议删除 &lt;code&gt;finalize&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="6c005c11b66aec51de31e87c510532c6a448273e" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Field&lt;/code&gt; object is enforcing Java language access control, and the underlying field is inaccessible, the method throws an &lt;code&gt;IllegalAccessException&lt;/code&gt;.</source>
          <target state="translated">如果此 &lt;code&gt;Field&lt;/code&gt; 对象正在实施Java语言访问控制，并且基础字段不可访问，则该方法将抛出 &lt;code&gt;IllegalAccessException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bfff6651d72785da15b50a35bc44c7be29e967f4" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Field&lt;/code&gt; object is enforcing Java language access control, and the underlying field is inaccessible, the method throws an &lt;code&gt;IllegalAccessException&lt;/code&gt;. If the underlying field is static, the class that declared the field is initialized if it has not already been initialized.</source>
          <target state="translated">如果此 &lt;code&gt;Field&lt;/code&gt; 对象正在实施Java语言访问控制，并且基础字段不可访问，则该方法将抛出 &lt;code&gt;IllegalAccessException&lt;/code&gt; 。如果基础字段是静态的，则声明该字段的类将被初始化（如果尚未初始化）。</target>
        </trans-unit>
        <trans-unit id="eb5b424e32b92ab7192512c0fc09ab99276ccc50" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Graphics2D&lt;/code&gt; context is drawing to a &lt;code&gt;Component&lt;/code&gt; on the display screen and the &lt;code&gt;Composite&lt;/code&gt; is a custom object rather than an instance of the &lt;code&gt;AlphaComposite&lt;/code&gt; class, and if there is a security manager, its &lt;code&gt;checkPermission&lt;/code&gt; method is called with an &lt;code&gt;AWTPermission(&quot;readDisplayPixels&quot;)&lt;/code&gt; permission.</source>
          <target state="translated">如果此 &lt;code&gt;Graphics2D&lt;/code&gt; 上下文正在绘制到显示屏上的 &lt;code&gt;Component&lt;/code&gt; ，并且 &lt;code&gt;Composite&lt;/code&gt; 是自定义对象而不是 &lt;code&gt;AlphaComposite&lt;/code&gt; 类的实例，并且如果存在安全管理器，则使用 &lt;code&gt;AWTPermission(&quot;readDisplayPixels&quot;)&lt;/code&gt; 调用其 &lt;code&gt;checkPermission&lt;/code&gt; 方法。允许。</target>
        </trans-unit>
        <trans-unit id="1dcd83e4433ffbc1ebbf7b8020d46089730ee740" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;HttpResponse&lt;/code&gt; was returned from an invocation of &lt;a href=&quot;#previousResponse()&quot;&gt;&lt;code&gt;previousResponse()&lt;/code&gt;&lt;/a&gt; then this method returns &lt;code&gt;null&lt;/code&gt;</source>
          <target state="translated">如果此 &lt;code&gt;HttpResponse&lt;/code&gt; 是从对&lt;a href=&quot;#previousResponse()&quot;&gt; &lt;code&gt;previousResponse()&lt;/code&gt; &lt;/a&gt;的调用返回的，则此方法返回 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6f7ccb08c5fb1d4a7665d31d16cc3af87c0f7a6b" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Inflater&lt;/code&gt; has been subclassed and the &lt;code&gt;end&lt;/code&gt; method has been overridden, the &lt;code&gt;end&lt;/code&gt; method will be called by the finalization when the inflater is unreachable. But the subclasses should not depend on this specific implementation; the finalization is not reliable and the &lt;code&gt;finalize&lt;/code&gt; method is deprecated to be removed.</source>
          <target state="translated">如果 &lt;code&gt;Inflater&lt;/code&gt; 已经子类和 &lt;code&gt;end&lt;/code&gt; 方法已被重写，则 &lt;code&gt;end&lt;/code&gt; 方法将被终结时调用充气不可达。但是子类不应依赖于此特定的实现。终结不可靠，并且不建议删除 &lt;code&gt;finalize&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="66c4254fec3d7e2e4edd4f26fd06d26cd6621cde" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Inflater&lt;/code&gt; has been subclassed and the &lt;code&gt;end&lt;/code&gt; method has been overridden, the &lt;code&gt;end&lt;/code&gt; method will be called when the inflater is unreachable.</source>
          <target state="translated">如果此 &lt;code&gt;Inflater&lt;/code&gt; 已被子类化，并且 &lt;code&gt;end&lt;/code&gt; 方法已被覆盖，则当inflater无法访问时，将调用 &lt;code&gt;end&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="c26daa984a3e23882bcf4505853a0f173ed21163" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;JInternalFrame&lt;/code&gt; is active, returns the child that has focus.</source>
          <target state="translated">如果此 &lt;code&gt;JInternalFrame&lt;/code&gt; 是活动的，则返回具有焦点的子级。</target>
        </trans-unit>
        <trans-unit id="bc9401f368e3758d3188ace75004f7819d77e1f2" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;JInternalFrame&lt;/code&gt; is active, returns the child that has focus. Otherwise, returns &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">如果此 &lt;code&gt;JInternalFrame&lt;/code&gt; 是活动的，则返回具有焦点的子级。否则，返回 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6828b57248dc55ee33f2d0f727d461ced903c7ae" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;JTable&lt;/code&gt; is the &lt;code&gt;viewportView&lt;/code&gt; of an enclosing &lt;code&gt;JScrollPane&lt;/code&gt; (the usual situation), configure this &lt;code&gt;ScrollPane&lt;/code&gt; by, amongst other things, installing the table's &lt;code&gt;tableHeader&lt;/code&gt; as the &lt;code&gt;columnHeaderView&lt;/code&gt; of the scroll pane.</source>
          <target state="translated">如果此 &lt;code&gt;JTable&lt;/code&gt; 是封闭的 &lt;code&gt;JScrollPane&lt;/code&gt; 的 &lt;code&gt;viewportView&lt;/code&gt; （通常情况），请通过安装表的 &lt;code&gt;tableHeader&lt;/code&gt; 作为滚动窗格的 &lt;code&gt;columnHeaderView&lt;/code&gt; 等方法来配置此 &lt;code&gt;ScrollPane&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="95bc5377a471ae3598176805da8df7dc9f63dc18" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;JTable&lt;/code&gt; is the &lt;code&gt;viewportView&lt;/code&gt; of an enclosing &lt;code&gt;JScrollPane&lt;/code&gt; (the usual situation), configure this &lt;code&gt;ScrollPane&lt;/code&gt; by, amongst other things, installing the table's &lt;code&gt;tableHeader&lt;/code&gt; as the &lt;code&gt;columnHeaderView&lt;/code&gt; of the scroll pane. When a &lt;code&gt;JTable&lt;/code&gt; is added to a &lt;code&gt;JScrollPane&lt;/code&gt; in the usual way, using &lt;code&gt;new JScrollPane(myTable)&lt;/code&gt;, &lt;code&gt;addNotify&lt;/code&gt; is called in the &lt;code&gt;JTable&lt;/code&gt; (when the table is added to the viewport). &lt;code&gt;JTable&lt;/code&gt;'s &lt;code&gt;addNotify&lt;/code&gt; method in turn calls this method, which is protected so that this default installation procedure can be overridden by a subclass.</source>
          <target state="translated">如果此 &lt;code&gt;JTable&lt;/code&gt; 是封闭的 &lt;code&gt;JScrollPane&lt;/code&gt; 的 &lt;code&gt;viewportView&lt;/code&gt; （通常情况），请通过安装表的 &lt;code&gt;tableHeader&lt;/code&gt; 作为滚动窗格的 &lt;code&gt;columnHeaderView&lt;/code&gt; 等方法来配置此 &lt;code&gt;ScrollPane&lt;/code&gt; 。当 &lt;code&gt;JTable&lt;/code&gt; 添加到 &lt;code&gt;JScrollPane&lt;/code&gt; 中以通常的方式，用 &lt;code&gt;new JScrollPane(myTable)&lt;/code&gt; ， &lt;code&gt;addNotify&lt;/code&gt; 被称为在 &lt;code&gt;JTable&lt;/code&gt; 中（当表被添加到视口）。 &lt;code&gt;JTable&lt;/code&gt; 的 &lt;code&gt;addNotify&lt;/code&gt; 方法依次调用此方法，该方法受到保护，因此子类可以覆盖此默认安装过程。</target>
        </trans-unit>
        <trans-unit id="971006a579f4cd386294bc03012306a545ec65dd" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;JarFile&lt;/code&gt; is a multi-release jar file and is configured to be processed as such, then a search is performed to find and return a &lt;code&gt;JarEntry&lt;/code&gt; that is the latest versioned entry associated with the given entry name. The returned &lt;code&gt;JarEntry&lt;/code&gt; is the versioned entry corresponding to the given base entry name prefixed with the string &lt;code&gt;&quot;META-INF/versions/{n}/&quot;&lt;/code&gt;, for the largest value of &lt;code&gt;n&lt;/code&gt; for which an entry exists. If such a versioned entry does not exist, then the &lt;code&gt;JarEntry&lt;/code&gt; for the base entry is returned, otherwise &lt;code&gt;null&lt;/code&gt; is returned if no entries are found. The initial value for the version &lt;code&gt;n&lt;/code&gt; is the maximum version as returned by the method &lt;a href=&quot;#getVersion()&quot;&gt;&lt;code&gt;getVersion()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果此 &lt;code&gt;JarFile&lt;/code&gt; 是多发行版jar文件，并且配置为可以进行这样的处理，则执行搜索以查找并返回 &lt;code&gt;JarEntry&lt;/code&gt; ，该JarEntry是与给定条目名称关联的最新版本的条目。返回的 &lt;code&gt;JarEntry&lt;/code&gt; 是与给定的基本条目名称相对应的版本化条目，前缀为字符串 &lt;code&gt;&quot;META-INF/versions/{n}/&quot;&lt;/code&gt; ，表示存在该条目的 &lt;code&gt;n&lt;/code&gt; 的最大值。如果不存在这样的版本化条目，则返回基本条目的 &lt;code&gt;JarEntry&lt;/code&gt; ，否则，如果未找到任何条目，则返回 &lt;code&gt;null&lt;/code&gt; 。版本 &lt;code&gt;n&lt;/code&gt; 的初始值是该方法返回的最大版本&lt;a href=&quot;#getVersion()&quot;&gt; &lt;code&gt;getVersion()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a42359b2547fcf0cced67f0b8abbfee7db30652b" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;JarFile&lt;/code&gt; is a multi-release jar file and is configured to be processed as such, then a search is performed to find and return a &lt;code&gt;ZipEntry&lt;/code&gt; that is the latest versioned entry associated with the given entry name. The returned &lt;code&gt;ZipEntry&lt;/code&gt; is the versioned entry corresponding to the given base entry name prefixed with the string &lt;code&gt;&quot;META-INF/versions/{n}/&quot;&lt;/code&gt;, for the largest value of &lt;code&gt;n&lt;/code&gt; for which an entry exists. If such a versioned entry does not exist, then the &lt;code&gt;ZipEntry&lt;/code&gt; for the base entry is returned, otherwise &lt;code&gt;null&lt;/code&gt; is returned if no entries are found. The initial value for the version &lt;code&gt;n&lt;/code&gt; is the maximum version as returned by the method &lt;a href=&quot;#getVersion()&quot;&gt;&lt;code&gt;getVersion()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果此 &lt;code&gt;JarFile&lt;/code&gt; 是一个多版本jar文件，并配置为可以进行处理，则执行搜索以查找并返回 &lt;code&gt;ZipEntry&lt;/code&gt; ，该ZipEntry是与给定条目名称关联的最新版本的条目。返回的 &lt;code&gt;ZipEntry&lt;/code&gt; 是与给定的基本条目名称相对应的版本化条目，前缀为字符串 &lt;code&gt;&quot;META-INF/versions/{n}/&quot;&lt;/code&gt; ，表示存在该条目的 &lt;code&gt;n&lt;/code&gt; 的最大值。如果不存在这样的版本化条目，则返回基本条目的 &lt;code&gt;ZipEntry&lt;/code&gt; ，否则，如果未找到任何条目，则返回 &lt;code&gt;null&lt;/code&gt; 。版本 &lt;code&gt;n&lt;/code&gt; 的初始值是该方法返回的最大版本&lt;a href=&quot;#getVersion()&quot;&gt; &lt;code&gt;getVersion()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4544200625ea70ebc9bce4110deacb71c8b2c125" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;JarFile&lt;/code&gt; is a multi-release jar file and is configured to be processed as such, then an entry in the stream is the latest versioned entry associated with the corresponding base entry name. The maximum version of the latest versioned entry is the version returned by &lt;a href=&quot;#getVersion()&quot;&gt;&lt;code&gt;getVersion()&lt;/code&gt;&lt;/a&gt;. The returned stream may include an entry that only exists as a versioned entry. If the jar file is not a multi-release jar file or the &lt;code&gt;JarFile&lt;/code&gt; is not configured for processing a multi-release jar file, this method returns the same stream that &lt;a href=&quot;#stream()&quot;&gt;&lt;code&gt;stream()&lt;/code&gt;&lt;/a&gt; returns.</source>
          <target state="translated">如果此 &lt;code&gt;JarFile&lt;/code&gt; 是多版本jar文件，并配置为按此方式进行处理，则流中的条目是与相应基本条目名称关联的最新版本的条目。最新版本条目的最大版本是&lt;a href=&quot;#getVersion()&quot;&gt; &lt;code&gt;getVersion()&lt;/code&gt; &lt;/a&gt;返回的版本。返回的流可以包括仅作为版本化条目存在的条目。如果jar文件不是多版本jar文件，或者 &lt;code&gt;JarFile&lt;/code&gt; 未配置为处理多版本jar文件，则此方法返回与&lt;a href=&quot;#stream()&quot;&gt; &lt;code&gt;stream()&lt;/code&gt; &lt;/a&gt;返回的流相同的流。</target>
        </trans-unit>
        <trans-unit id="8fc33555c25f80831c0628ad15a0ccf77251dea3" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;JarFile&lt;/code&gt; is not a multi-release jar file or is not configured to be processed as such, then the version returned will be the same as that returned from &lt;a href=&quot;#baseVersion()&quot;&gt;&lt;code&gt;baseVersion()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果此 &lt;code&gt;JarFile&lt;/code&gt; 不是多发行版本的jar文件，或者未配置为以这种方式处理，则返回的版本将与&lt;a href=&quot;#baseVersion()&quot;&gt; &lt;code&gt;baseVersion()&lt;/code&gt; &lt;/a&gt;返回的版本相同。</target>
        </trans-unit>
        <trans-unit id="8557e1e1be59bc05bf4e2df145cc3c316c6e80c0" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Locale&lt;/code&gt; has a language, country, or variant that does not satisfy the IETF BCP 47 language tag syntax requirements, this method handles these fields as described below:</source>
          <target state="translated">如果此 &lt;code&gt;Locale&lt;/code&gt; 的语言，国家/地区或变体不满足IETF BCP 47语言标签语法要求，则此方法将如下处理这些字段：</target>
        </trans-unit>
        <trans-unit id="f49a3fde11d5db0ed881977831e9e3ba3cc4fab5" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;PopupMenu&lt;/code&gt; is being used as a &lt;code&gt;Menu&lt;/code&gt; (i.e., it has a non-&lt;code&gt;Component&lt;/code&gt; parent), then you cannot call this method on the &lt;code&gt;PopupMenu&lt;/code&gt;.</source>
          <target state="translated">如果此 &lt;code&gt;PopupMenu&lt;/code&gt; 用作 &lt;code&gt;Menu&lt;/code&gt; （即，它具有非 &lt;code&gt;Component&lt;/code&gt; 父级），则无法在 &lt;code&gt;PopupMenu&lt;/code&gt; 上调用此方法。</target>
        </trans-unit>
        <trans-unit id="e7731e7aef77ad748710b57493f4b7ea47070b36" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Rectangle&lt;/code&gt; has any dimension less than zero, the rules for &lt;a href=&quot;#NonExistent&quot;&gt;non-existent&lt;/a&gt; rectangles apply. In that case, the new bounds of this &lt;code&gt;Rectangle&lt;/code&gt; will have a location equal to the coordinates of the specified &lt;code&gt;Point&lt;/code&gt; and width and height equal to zero.</source>
          <target state="translated">如果此 &lt;code&gt;Rectangle&lt;/code&gt; 的尺寸小于零，则不&lt;a href=&quot;#NonExistent&quot;&gt;存在的&lt;/a&gt;矩形的规则适用。在这种情况下，此 &lt;code&gt;Rectangle&lt;/code&gt; 的新边界将具有等于指定 &lt;code&gt;Point&lt;/code&gt; 的坐标且宽度和高度等于零的位置。</target>
        </trans-unit>
        <trans-unit id="1b8dc137f02a58d56274933aac40eb866926b6a8" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Rectangle&lt;/code&gt; has any dimension less than zero, the rules for &lt;a href=&quot;#NonExistent&quot;&gt;non-existent&lt;/a&gt; rectangles apply. In that case, the new bounds of this &lt;code&gt;Rectangle&lt;/code&gt; will have a location equal to the specified coordinates and width and height equal to zero.</source>
          <target state="translated">如果此 &lt;code&gt;Rectangle&lt;/code&gt; 的尺寸小于零，则不&lt;a href=&quot;#NonExistent&quot;&gt;存在的&lt;/a&gt;矩形的规则适用。在这种情况下，此 &lt;code&gt;Rectangle&lt;/code&gt; 的新边界将具有等于指定坐标的位置，并且其宽度和高度将为零。</target>
        </trans-unit>
        <trans-unit id="d37a0ebcc6085e0c5c10ef85dea41aa701353317" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;RowSet&lt;/code&gt; object does not maintain a continuous connection with its source of data, it may use a &lt;code&gt;Reader&lt;/code&gt; (a &lt;code&gt;RowSetReader&lt;/code&gt; object) to fill itself with data. In this case, a &lt;code&gt;Reader&lt;/code&gt; will have been registered with this &lt;code&gt;RowSet&lt;/code&gt; object, and the method &lt;code&gt;execute&lt;/code&gt; will call on the &lt;code&gt;Reader&lt;/code&gt;'s &lt;code&gt;readData&lt;/code&gt; method as part of its implementation.</source>
          <target state="translated">如果此 &lt;code&gt;RowSet&lt;/code&gt; 对象不与其数据源保持连续连接，则可以使用 &lt;code&gt;Reader&lt;/code&gt; （ &lt;code&gt;RowSetReader&lt;/code&gt; 对象）向自身填充数据。在这种情况下，将向该 &lt;code&gt;RowSet&lt;/code&gt; 对象注册一个 &lt;code&gt;Reader&lt;/code&gt; ，并且 &lt;code&gt;execute&lt;/code&gt; 方法将调用 &lt;code&gt;Reader&lt;/code&gt; 的 &lt;code&gt;readData&lt;/code&gt; 方法作为其实现的一部分。</target>
        </trans-unit>
        <trans-unit id="ae1424f53f74471f85637ef0b51790d77bcaf639" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;SSLEngine&lt;/code&gt; has not yet started its initial handshake, this method will automatically start the handshake.</source>
          <target state="translated">如果此 &lt;code&gt;SSLEngine&lt;/code&gt; 尚未开始其初始握手，则此方法将自动开始握手。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
