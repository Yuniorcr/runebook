<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="openjdk">
    <body>
      <group id="openjdk">
        <trans-unit id="431790292384e64efc177cdca9b3ed328240fae3" translate="yes" xml:space="preserve">
          <source>Whenever it is invoked on the same Permission object more than once during an execution of a Java application, the &lt;code&gt;hashCode&lt;/code&gt; method must consistently return the same integer. This integer need not remain consistent from one execution of an application to another execution of the same application.</source>
          <target state="translated">在Java应用程序执行期间，只要在同一个Permission对象上多次调用它， &lt;code&gt;hashCode&lt;/code&gt; 方法就必须一致地返回相同的整数。从一个应用程序的执行到同一应用程序的另一执行，此整数不必保持一致。</target>
        </trans-unit>
        <trans-unit id="588f7fe1bed2c7e664ebaf61ee198d0177166e9e" translate="yes" xml:space="preserve">
          <source>Whenever it is invoked on the same object more than once during an execution of a Java application, the &lt;code&gt;hashCode&lt;/code&gt; method must consistently return the same integer, provided no information used in &lt;code&gt;equals&lt;/code&gt; comparisons on the object is modified. This integer need not remain consistent from one execution of an application to another execution of the same application.</source>
          <target state="translated">在Java应用程序执行期间，只要在同一对象上多次调用它， &lt;code&gt;hashCode&lt;/code&gt; 方法就必须一致地返回相同的整数，前提是不修改该对象的 &lt;code&gt;equals&lt;/code&gt; 比较中使用的信息。从一个应用程序的执行到同一应用程序的另一执行，此整数不必保持一致。</target>
        </trans-unit>
        <trans-unit id="ffc62db80b67ec0b4098632184a3dc10efde0cdb" translate="yes" xml:space="preserve">
          <source>Whenever it succeeds, it calls the previously instantiated resource bundle's &lt;a href=&quot;#setParent(java.util.ResourceBundle)&quot;&gt;&lt;code&gt;setParent&lt;/code&gt;&lt;/a&gt; method with the new resource bundle. This continues until the list of names is exhausted or the current bundle already has a non-null parent.</source>
          <target state="translated">只要成功，它将使用新的资源束调用先前实例化的资源束的&lt;a href=&quot;#setParent(java.util.ResourceBundle)&quot;&gt; &lt;code&gt;setParent&lt;/code&gt; &lt;/a&gt;方法。这一直持续到名称列表用尽或当前捆绑包已经具有非空的父级为止。</target>
        </trans-unit>
        <trans-unit id="e5ded5fcd7a735ce98c847740a18c44d83d66cc2" translate="yes" xml:space="preserve">
          <source>Whenever it succeeds, it calls the previously instantiated resource bundle's &lt;a href=&quot;resourcebundle#setParent-java.util.ResourceBundle-&quot;&gt;&lt;code&gt;setParent&lt;/code&gt;&lt;/a&gt; method with the new resource bundle. This continues until the list of names is exhausted or the current bundle already has a non-null parent.</source>
          <target state="translated">只要成功，它将使用新的资源束调用先前实例化的资源束的&lt;a href=&quot;resourcebundle#setParent-java.util.ResourceBundle-&quot;&gt; &lt;code&gt;setParent&lt;/code&gt; &lt;/a&gt;方法。这一直持续到名称列表用尽或当前捆绑包已经具有非空的父级为止。</target>
        </trans-unit>
        <trans-unit id="57eb7967ad7144cde59c41a7d4448d0900ba0c25" translate="yes" xml:space="preserve">
          <source>Where 'name' is the &lt;code&gt;ExecutionControlProvider&lt;/code&gt;&lt;a href=&quot;executioncontrolprovider#name()&quot;&gt;name&lt;/a&gt;. Where 'param' is a Map key from &lt;a href=&quot;executioncontrolprovider#defaultParameters()&quot;&gt;&lt;code&gt;ExecutionControlProvider.defaultParameters()&lt;/code&gt;&lt;/a&gt; and the parenthesized value; See, for example, &lt;a href=&quot;../execution/jdiexecutioncontrolprovider&quot;&gt;&lt;code&gt;JdiExecutionControlProvider&lt;/code&gt;&lt;/a&gt;. Where 'identifier' is a sequence of &lt;a href=&quot;../../../../java.base/java/lang/character#isJavaIdentifierPart(int)&quot;&gt;Java identifier part characters&lt;/a&gt; from the Basic Multilingual Plane.</source>
          <target state="translated">其中'name'是 &lt;code&gt;ExecutionControlProvider&lt;/code&gt; &lt;a href=&quot;executioncontrolprovider#name()&quot;&gt;name&lt;/a&gt;。其中&amp;ldquo; param&amp;rdquo;是来自&lt;a href=&quot;executioncontrolprovider#defaultParameters()&quot;&gt; &lt;code&gt;ExecutionControlProvider.defaultParameters()&lt;/code&gt; &lt;/a&gt;和括号值的Map键；参见，例如，&lt;a href=&quot;../execution/jdiexecutioncontrolprovider&quot;&gt; &lt;code&gt;JdiExecutionControlProvider&lt;/code&gt; &lt;/a&gt;。其中&amp;ldquo;标识符&amp;rdquo;是基本多语言平面中的&lt;a href=&quot;../../../../java.base/java/lang/character#isJavaIdentifierPart(int)&quot;&gt;Java标识符部分字符&lt;/a&gt;的序列。</target>
        </trans-unit>
        <trans-unit id="f6905fb07fa47d960a6cc1c5c35a7ad900455a52" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;foo&lt;/code&gt; becomes a wrapper for the actual native method with the appended prefix &quot;wrapped_&quot;. Note that &quot;wrapped_&quot; would be a poor choice of prefix since it might conceivably form the name of an existing method thus something like &quot;$$$MyAgentWrapped$$$_&quot; would be better but would make these examples less readable.</source>
          <target state="translated">凡 &lt;code&gt;foo&lt;/code&gt; 成为与附加前缀&amp;ldquo;wrapped_&amp;rdquo;实际的本地方法的包装。请注意，&amp;ldquo; wrapped_&amp;rdquo;将是前缀的较差选择，因为它可能会形成现有方法的名称，因此&amp;ldquo; $$$ MyAgentWrapped $$$ _&amp;rdquo;之类的名称会更好，但会使这些示例的可读性降低。</target>
        </trans-unit>
        <trans-unit id="9fff88ed5ff71cb64ca036661748f73a8e3a0800" translate="yes" xml:space="preserve">
          <source>Where a file is registered with a watch service by means of a symbolic link then it is implementation specific if the watch continues to depend on the existence of the symbolic link after it is registered.</source>
          <target state="translated">当一个文件通过符号链接向手表服务注册时,那么如果手表在注册后继续依赖于符号链接的存在,则是特定的实现。</target>
        </trans-unit>
        <trans-unit id="d790f6a28291e56f379a271ae7232a655fb1d865" translate="yes" xml:space="preserve">
          <source>Where a membership key is not source-specific and the underlying operation system supports source filtering, then the &lt;a href=&quot;#block(java.net.InetAddress)&quot;&gt;&lt;code&gt;block&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#unblock(java.net.InetAddress)&quot;&gt;&lt;code&gt;unblock&lt;/code&gt;&lt;/a&gt; methods can be used to block or unblock multicast datagrams from particular source addresses.</source>
          <target state="translated">如果成员资格密钥不是特定于源的，并且底层操作系统支持源过滤，则可以使用&lt;a href=&quot;#block(java.net.InetAddress)&quot;&gt; &lt;code&gt;block&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#unblock(java.net.InetAddress)&quot;&gt; &lt;code&gt;unblock&lt;/code&gt; &lt;/a&gt;方法来阻止或取消阻止来自特定源地址的多播数据报。</target>
        </trans-unit>
        <trans-unit id="b4eef4e93d3c18e96b9b78253a20017e48bb542d" translate="yes" xml:space="preserve">
          <source>Where a membership key is not source-specific and the underlying operation system supports source filtering, then the &lt;a href=&quot;membershipkey#block-java.net.InetAddress-&quot;&gt;&lt;code&gt;block&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;membershipkey#unblock-java.net.InetAddress-&quot;&gt;&lt;code&gt;unblock&lt;/code&gt;&lt;/a&gt; methods can be used to block or unblock multicast datagrams from particular source addresses.</source>
          <target state="translated">如果成员资格密钥不是特定于源的，并且底层操作系统支持源过滤，则可以使用&lt;a href=&quot;membershipkey#block-java.net.InetAddress-&quot;&gt; &lt;code&gt;block&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;membershipkey#unblock-java.net.InetAddress-&quot;&gt; &lt;code&gt;unblock&lt;/code&gt; &lt;/a&gt;方法来阻止或取消阻止来自特定源地址的多播数据报。</target>
        </trans-unit>
        <trans-unit id="ef0ae8bbc1659706ac95235ca1ce689fe57f64b3" translate="yes" xml:space="preserve">
          <source>Where an I/O operation completes immediately, and the initiating thread is one of the pooled threads in the group then the completion handler may be invoked directly by the initiating thread. To avoid stack overflow, an implementation may impose a limit as to the number of activations on the thread stack. Some I/O operations may prohibit invoking the completion handler directly by the initiating thread (see &lt;a href=&quot;asynchronousserversocketchannel#accept(A,java.nio.channels.CompletionHandler)&quot;&gt;&lt;code&gt;accept&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">如果I / O操作立即完成，并且发起线程是该组中的池线程之一，则可以由发起线程直接调用完成处理程序。为了避免堆栈溢出，实现可以对线程堆栈上的激活次数施加限制。某些I / O操作可能禁止通过发起线程直接调用完成处理程序（请参见&lt;a href=&quot;asynchronousserversocketchannel#accept(A,java.nio.channels.CompletionHandler)&quot;&gt; &lt;code&gt;accept&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="8898ed0b51f593284e7f77a4f867cd2fc2e666cb" translate="yes" xml:space="preserve">
          <source>Where an I/O operation completes immediately, and the initiating thread is one of the pooled threads in the group then the completion handler may be invoked directly by the initiating thread. To avoid stack overflow, an implementation may impose a limit as to the number of activations on the thread stack. Some I/O operations may prohibit invoking the completion handler directly by the initiating thread (see &lt;a href=&quot;asynchronousserversocketchannel#accept-A-java.nio.channels.CompletionHandler-&quot;&gt;&lt;code&gt;accept&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">如果I / O操作立即完成，并且发起线程是该组中的池线程之一，则可以由发起线程直接调用完成处理程序。为了避免堆栈溢出，实现可以对线程堆栈上的激活次数施加限制。某些I / O操作可能禁止通过发起线程直接调用完成处理程序（请参见&lt;a href=&quot;asynchronousserversocketchannel#accept-A-java.nio.channels.CompletionHandler-&quot;&gt; &lt;code&gt;accept&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="66ce7e87d0492095ddc6703b1b7f0c7420f96474" translate="yes" xml:space="preserve">
          <source>Where an implementation does not support any notion of group then this method always throws &lt;a href=&quot;userprincipalnotfoundexception&quot;&gt;&lt;code&gt;UserPrincipalNotFoundException&lt;/code&gt;&lt;/a&gt;. Where the namespace for user accounts and groups is the same, then this method is identical to invoking &lt;a href=&quot;#lookupPrincipalByName(java.lang.String)&quot;&gt;&lt;code&gt;lookupPrincipalByName&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果实现不支持任何组概念，则此方法总是抛出&lt;a href=&quot;userprincipalnotfoundexception&quot;&gt; &lt;code&gt;UserPrincipalNotFoundException&lt;/code&gt; &lt;/a&gt;。如果用户帐户和组的名称空间相同，则此方法与调用&lt;a href=&quot;#lookupPrincipalByName(java.lang.String)&quot;&gt; &lt;code&gt;lookupPrincipalByName&lt;/code&gt; &lt;/a&gt;相同。</target>
        </trans-unit>
        <trans-unit id="f2bcdaf392a0bc8b6a2ade4e800476f90476c33e" translate="yes" xml:space="preserve">
          <source>Where an implementation does not support any notion of group then this method always throws &lt;a href=&quot;userprincipalnotfoundexception&quot;&gt;&lt;code&gt;UserPrincipalNotFoundException&lt;/code&gt;&lt;/a&gt;. Where the namespace for user accounts and groups is the same, then this method is identical to invoking &lt;a href=&quot;userprincipallookupservice#lookupPrincipalByName-java.lang.String-&quot;&gt;&lt;code&gt;lookupPrincipalByName&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果实现不支持任何组概念，则此方法总是抛出&lt;a href=&quot;userprincipalnotfoundexception&quot;&gt; &lt;code&gt;UserPrincipalNotFoundException&lt;/code&gt; &lt;/a&gt;。如果用户帐户和组的名称空间相同，则此方法与调用&lt;a href=&quot;userprincipallookupservice#lookupPrincipalByName-java.lang.String-&quot;&gt; &lt;code&gt;lookupPrincipalByName&lt;/code&gt; &lt;/a&gt;相同。</target>
        </trans-unit>
        <trans-unit id="cb723c111014ba92d8f87833b389ec9ea6719988" translate="yes" xml:space="preserve">
          <source>Where an implementation provides a means to start agents from the command-line interface, an agent is started by adding the following option to the command-line:</source>
          <target state="translated">如果一个实施例提供了从命令行接口启动代理的方法,则通过在命令行中添加以下选项来启动代理。</target>
        </trans-unit>
        <trans-unit id="c9f90c3240707b3d864205080111e67313bf0eee" translate="yes" xml:space="preserve">
          <source>Where an implementation supports an ACL model that differs from the NFSv4 defined ACL model then setting the initial ACL when creating the file must translate the ACL to the model supported by the file system. Methods that create a file should reject (by throwing &lt;a href=&quot;../../../io/ioexception&quot;&gt;&lt;code&gt;IOException&lt;/code&gt;&lt;/a&gt;) any attempt to create a file that would be less secure as a result of the translation.</source>
          <target state="translated">如果实现支持与NFSv4定义的ACL模型不同的ACL模型，则在创建文件时设置初始ACL必须将ACL转换为文件系统支持的模型。创建文件的方法应拒绝（通过抛出&lt;a href=&quot;../../../io/ioexception&quot;&gt; &lt;code&gt;IOException&lt;/code&gt; &lt;/a&gt;）任何尝试创建文件的尝试，而这些尝试由于翻译的结果而不太安全。</target>
        </trans-unit>
        <trans-unit id="8b05be389f68d5924db16624428d14d236ca56aa" translate="yes" xml:space="preserve">
          <source>Where desired, &lt;a href=&quot;processbuilder#redirect-input&quot;&gt; process I/O can also be redirected&lt;/a&gt; using methods of the &lt;a href=&quot;processbuilder&quot;&gt;&lt;code&gt;ProcessBuilder&lt;/code&gt;&lt;/a&gt; class.</source>
          <target state="translated">如果需要，&lt;a href=&quot;processbuilder#redirect-input&quot;&gt;也可以&lt;/a&gt;使用&lt;a href=&quot;processbuilder&quot;&gt; &lt;code&gt;ProcessBuilder&lt;/code&gt; &lt;/a&gt;类的方法来重定向进程I / O。</target>
        </trans-unit>
        <trans-unit id="3907849eb829645989d02022a9256583b35ccf13" translate="yes" xml:space="preserve">
          <source>Where desired, &lt;a href=&quot;processbuilder#redirect-input&quot;&gt; subprocess I/O can also be redirected&lt;/a&gt; using methods of the &lt;a href=&quot;processbuilder&quot;&gt;&lt;code&gt;ProcessBuilder&lt;/code&gt;&lt;/a&gt; class.</source>
          <target state="translated">如果需要，&lt;a href=&quot;processbuilder#redirect-input&quot;&gt;还可以&lt;/a&gt;使用&lt;a href=&quot;processbuilder&quot;&gt; &lt;code&gt;ProcessBuilder&lt;/code&gt; &lt;/a&gt;类的方法来重定向子流程I / O。</target>
        </trans-unit>
        <trans-unit id="d8cf0baa75731ca6a5102a9d1799ad35f096def7" translate="yes" xml:space="preserve">
          <source>Where dynamic access to file attributes is required, the &lt;a href=&quot;../files#getAttribute(java.nio.file.Path,java.lang.String,java.nio.file.LinkOption...)&quot;&gt;&lt;code&gt;getAttribute&lt;/code&gt;&lt;/a&gt; method may be used to read the attribute value. The attribute value is returned as a byte array (byte[]). The &lt;a href=&quot;../files#setAttribute(java.nio.file.Path,java.lang.String,java.lang.Object,java.nio.file.LinkOption...)&quot;&gt;&lt;code&gt;setAttribute&lt;/code&gt;&lt;/a&gt; method may be used to write the value of a user-defined attribute from a buffer (as if by invoking the &lt;a href=&quot;#write(java.lang.String,java.nio.ByteBuffer)&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; method), or byte array (byte[]).</source>
          <target state="translated">如果需要动态访问文件属性，则可以使用&lt;a href=&quot;../files#getAttribute(java.nio.file.Path,java.lang.String,java.nio.file.LinkOption...)&quot;&gt; &lt;code&gt;getAttribute&lt;/code&gt; &lt;/a&gt;方法读取属性值。属性值以字节数组（byte []）的形式返回。所述&lt;a href=&quot;../files#setAttribute(java.nio.file.Path,java.lang.String,java.lang.Object,java.nio.file.LinkOption...)&quot;&gt; &lt;code&gt;setAttribute&lt;/code&gt; &lt;/a&gt;方法可以用于（仿佛通过调用写一个用户定义的属性的从缓冲器的值&lt;a href=&quot;#write(java.lang.String,java.nio.ByteBuffer)&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt;法），或字节数组（byte []）。</target>
        </trans-unit>
        <trans-unit id="0fbeca4a7ecd10802c77529dde8b082e44d0dd19" translate="yes" xml:space="preserve">
          <source>Where dynamic access to file attributes is required, the &lt;a href=&quot;../files#getAttribute-java.nio.file.Path-java.lang.String-java.nio.file.LinkOption...-&quot;&gt;&lt;code&gt;getAttribute&lt;/code&gt;&lt;/a&gt; method may be used to read the attribute value. The attribute value is returned as a byte array (byte[]). The &lt;a href=&quot;../files#setAttribute-java.nio.file.Path-java.lang.String-java.lang.Object-java.nio.file.LinkOption...-&quot;&gt;&lt;code&gt;setAttribute&lt;/code&gt;&lt;/a&gt; method may be used to write the value of a user-defined attribute from a buffer (as if by invoking the &lt;a href=&quot;userdefinedfileattributeview#write-java.lang.String-java.nio.ByteBuffer-&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; method), or byte array (byte[]).</source>
          <target state="translated">需要动态访问文件属性的地方，可以使用&lt;a href=&quot;../files#getAttribute-java.nio.file.Path-java.lang.String-java.nio.file.LinkOption...-&quot;&gt; &lt;code&gt;getAttribute&lt;/code&gt; &lt;/a&gt;方法读取属性值。属性值以字节数组（byte []）的形式返回。所述&lt;a href=&quot;../files#setAttribute-java.nio.file.Path-java.lang.String-java.lang.Object-java.nio.file.LinkOption...-&quot;&gt; &lt;code&gt;setAttribute&lt;/code&gt; &lt;/a&gt;方法可以用于（仿佛通过调用写一个用户定义的属性的从缓冲器的值&lt;a href=&quot;userdefinedfileattributeview#write-java.lang.String-java.nio.ByteBuffer-&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt;法），或字节数组（byte []）。</target>
        </trans-unit>
        <trans-unit id="ebb78ae3ef6ed103a9eb1696cdee777cab788dee" translate="yes" xml:space="preserve">
          <source>Where dynamic access to file attributes is required, the attributes supported by this attribute view are as defined by &lt;a href=&quot;basicfileattributeview&quot;&gt;&lt;code&gt;BasicFileAttributeView&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;fileownerattributeview&quot;&gt;&lt;code&gt;FileOwnerAttributeView&lt;/code&gt;&lt;/a&gt;, and in addition, the following attributes are supported:</source>
          <target state="translated">在需要动态访问文件属性的情况下，此属性视图支持的属性由&lt;a href=&quot;basicfileattributeview&quot;&gt; &lt;code&gt;BasicFileAttributeView&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;fileownerattributeview&quot;&gt; &lt;code&gt;FileOwnerAttributeView&lt;/code&gt; &lt;/a&gt;定义，此外，还支持以下属性：</target>
        </trans-unit>
        <trans-unit id="4e8ebe996cadf7a3b2a8cb30caf8f69a0b7ddda3" translate="yes" xml:space="preserve">
          <source>Where dynamic access to file attributes is required, the attributes supported by this attribute view are as defined by &lt;code&gt;
 BasicFileAttributeView&lt;/code&gt;, and in addition, the following attributes are supported:</source>
          <target state="translated">在需要动态访问文件属性的情况下，此属性视图支持的属性由 &lt;code&gt; BasicFileAttributeView&lt;/code&gt; 定义，此外，还支持以下属性：</target>
        </trans-unit>
        <trans-unit id="277ea500a19bef26e680e53fb1654aac09fa83bc" translate="yes" xml:space="preserve">
          <source>Where dynamic access to file attributes is required, the attributes supported by this attribute view are as defined by &lt;code&gt;BasicFileAttributeView&lt;/code&gt;, and in addition, the following attributes are supported:</source>
          <target state="translated">在需要动态访问文件属性的情况下，此属性视图支持的属性由 &lt;code&gt;BasicFileAttributeView&lt;/code&gt; 定义，此外，还支持以下属性：</target>
        </trans-unit>
        <trans-unit id="cf674cc8cdf6492af75c97ec90cc9a040aea0c29" translate="yes" xml:space="preserve">
          <source>Where dynamic access to file attributes is required, the attributes supported by this attribute view are as follows:</source>
          <target state="translated">在需要动态访问文件属性的地方,该属性视图支持的属性如下。</target>
        </trans-unit>
        <trans-unit id="8d820fbab2fe6e4127e50646c4e71b92a8792a22" translate="yes" xml:space="preserve">
          <source>Where dynamic access to file attributes is required, the attributes supported by this attribute view have the following names and types:</source>
          <target state="translated">在需要动态访问文件属性的地方,该属性视图支持的属性名称和类型如下。</target>
        </trans-unit>
        <trans-unit id="1a3a8b24e5fea76a61408fffd2a003c38a23b39a" translate="yes" xml:space="preserve">
          <source>Where it is required to distinguish an I/O exception from the case that &lt;code&gt;0L&lt;/code&gt; is returned, or where several attributes of the same file are required at the same time, then the &lt;a href=&quot;../nio/file/files#readAttributes(java.nio.file.Path,java.lang.Class,java.nio.file.LinkOption...)&quot;&gt;&lt;code&gt;Files.readAttributes&lt;/code&gt;&lt;/a&gt; method may be used.</source>
          <target state="translated">如果需要将I / O异常与返回 &lt;code&gt;0L&lt;/code&gt; 的情况区分开，或者同时需要同一文件的多个属性，则可以使用&lt;a href=&quot;../nio/file/files#readAttributes(java.nio.file.Path,java.lang.Class,java.nio.file.LinkOption...)&quot;&gt; &lt;code&gt;Files.readAttributes&lt;/code&gt; &lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="43d91b56e88fa1a42f8c6d2adc7c084514e56e79" translate="yes" xml:space="preserve">
          <source>Where it is required to distinguish an I/O exception from the case that &lt;code&gt;0L&lt;/code&gt; is returned, or where several attributes of the same file are required at the same time, then the &lt;a href=&quot;../nio/file/files#readAttributes-java.nio.file.Path-java.lang.Class-java.nio.file.LinkOption...-&quot;&gt;&lt;code&gt;Files.readAttributes&lt;/code&gt;&lt;/a&gt; method may be used.</source>
          <target state="translated">如果需要将I / O异常与返回 &lt;code&gt;0L&lt;/code&gt; 的情况区分开，或者同时需要同一文件的多个属性，则可以使用&lt;a href=&quot;../nio/file/files#readAttributes-java.nio.file.Path-java.lang.Class-java.nio.file.LinkOption...-&quot;&gt; &lt;code&gt;Files.readAttributes&lt;/code&gt; &lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="7de0392e6d47b4862228ebe6d2a818b846d1aedb" translate="yes" xml:space="preserve">
          <source>Where it is required to distinguish an I/O exception from the case that the file is not a directory then the file attributes can be read with the &lt;a href=&quot;#readAttributes(java.nio.file.Path,java.lang.Class,java.nio.file.LinkOption...)&quot;&gt;&lt;code&gt;readAttributes&lt;/code&gt;&lt;/a&gt; method and the file type tested with the &lt;a href=&quot;attribute/basicfileattributes#isDirectory()&quot;&gt;&lt;code&gt;BasicFileAttributes.isDirectory()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">如果需要将I / O异常与文件不是目录区别开来，则可以使用&lt;a href=&quot;#readAttributes(java.nio.file.Path,java.lang.Class,java.nio.file.LinkOption...)&quot;&gt; &lt;code&gt;readAttributes&lt;/code&gt; &lt;/a&gt;方法读取文件属性，并使用&lt;a href=&quot;attribute/basicfileattributes#isDirectory()&quot;&gt; &lt;code&gt;BasicFileAttributes.isDirectory()&lt;/code&gt; &lt;/a&gt;方法测试文件类型。</target>
        </trans-unit>
        <trans-unit id="005cb3d94ffb0d26668ec1404f37b73b1ba29dc4" translate="yes" xml:space="preserve">
          <source>Where it is required to distinguish an I/O exception from the case that the file is not a directory then the file attributes can be read with the &lt;a href=&quot;files#readAttributes-java.nio.file.Path-java.lang.Class-java.nio.file.LinkOption...-&quot;&gt;&lt;code&gt;readAttributes&lt;/code&gt;&lt;/a&gt; method and the file type tested with the &lt;a href=&quot;attribute/basicfileattributes#isDirectory--&quot;&gt;&lt;code&gt;BasicFileAttributes.isDirectory()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">如果需要将I / O异常与文件不是目录的情况区分开，则可以使用&lt;a href=&quot;files#readAttributes-java.nio.file.Path-java.lang.Class-java.nio.file.LinkOption...-&quot;&gt; &lt;code&gt;readAttributes&lt;/code&gt; &lt;/a&gt;方法读取文件属性，并使用&lt;a href=&quot;attribute/basicfileattributes#isDirectory--&quot;&gt; &lt;code&gt;BasicFileAttributes.isDirectory()&lt;/code&gt; &lt;/a&gt;方法测试文件类型。</target>
        </trans-unit>
        <trans-unit id="007567199ff26eceed4a5f4b5e1dc57ccb4d5705" translate="yes" xml:space="preserve">
          <source>Where it is required to distinguish an I/O exception from the case that the file is not a directory, or where several attributes of the same file are required at the same time, then the &lt;a href=&quot;../nio/file/files#readAttributes(java.nio.file.Path,java.lang.Class,java.nio.file.LinkOption...)&quot;&gt;&lt;code&gt;Files.readAttributes&lt;/code&gt;&lt;/a&gt; method may be used.</source>
          <target state="translated">如果需要将I / O异常与文件不是目录的情况区分开，或者同时需要同一文件的多个属性，则可以使用&lt;a href=&quot;../nio/file/files#readAttributes(java.nio.file.Path,java.lang.Class,java.nio.file.LinkOption...)&quot;&gt; &lt;code&gt;Files.readAttributes&lt;/code&gt; &lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="2bbbcba21c28c4d8c2c4924803def9e4ddb35ba8" translate="yes" xml:space="preserve">
          <source>Where it is required to distinguish an I/O exception from the case that the file is not a directory, or where several attributes of the same file are required at the same time, then the &lt;a href=&quot;../nio/file/files#readAttributes-java.nio.file.Path-java.lang.Class-java.nio.file.LinkOption...-&quot;&gt;&lt;code&gt;Files.readAttributes&lt;/code&gt;&lt;/a&gt; method may be used.</source>
          <target state="translated">如果需要将I / O异常与文件不是目录的情况区分开，或者同时需要同一文件的多个属性，则可以使用&lt;a href=&quot;../nio/file/files#readAttributes-java.nio.file.Path-java.lang.Class-java.nio.file.LinkOption...-&quot;&gt; &lt;code&gt;Files.readAttributes&lt;/code&gt; &lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="74b9eef79be9b70ff82dc87b633ac874427f7ef1" translate="yes" xml:space="preserve">
          <source>Where it is required to distinguish an I/O exception from the case that the file is not a normal file, or where several attributes of the same file are required at the same time, then the &lt;a href=&quot;../nio/file/files#readAttributes(java.nio.file.Path,java.lang.Class,java.nio.file.LinkOption...)&quot;&gt;&lt;code&gt;Files.readAttributes&lt;/code&gt;&lt;/a&gt; method may be used.</source>
          <target state="translated">如果需要将I / O异常与文件不是普通文件的情况区分开，或者同时需要同一文件的多个属性，则可以使用&lt;a href=&quot;../nio/file/files#readAttributes(java.nio.file.Path,java.lang.Class,java.nio.file.LinkOption...)&quot;&gt; &lt;code&gt;Files.readAttributes&lt;/code&gt; &lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="298b25c773a1934ae542e41dcabec7d24973199b" translate="yes" xml:space="preserve">
          <source>Where it is required to distinguish an I/O exception from the case that the file is not a normal file, or where several attributes of the same file are required at the same time, then the &lt;a href=&quot;../nio/file/files#readAttributes-java.nio.file.Path-java.lang.Class-java.nio.file.LinkOption...-&quot;&gt;&lt;code&gt;Files.readAttributes&lt;/code&gt;&lt;/a&gt; method may be used.</source>
          <target state="translated">如果需要将I / O异常与文件不是普通文件的情况区分开，或者同时需要同一文件的多个属性，则可以使用&lt;a href=&quot;../nio/file/files#readAttributes-java.nio.file.Path-java.lang.Class-java.nio.file.LinkOption...-&quot;&gt; &lt;code&gt;Files.readAttributes&lt;/code&gt; &lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="21258737e247b6c14994cdb209414cffbf2cb58c" translate="yes" xml:space="preserve">
          <source>Where it is required to distinguish an I/O exception from the case that the file is not a regular file then the file attributes can be read with the &lt;a href=&quot;#readAttributes(java.nio.file.Path,java.lang.Class,java.nio.file.LinkOption...)&quot;&gt;&lt;code&gt;readAttributes&lt;/code&gt;&lt;/a&gt; method and the file type tested with the &lt;a href=&quot;attribute/basicfileattributes#isRegularFile()&quot;&gt;&lt;code&gt;BasicFileAttributes.isRegularFile()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">如果需要将I / O异常与文件不是常规文件区分开来，则可以使用&lt;a href=&quot;#readAttributes(java.nio.file.Path,java.lang.Class,java.nio.file.LinkOption...)&quot;&gt; &lt;code&gt;readAttributes&lt;/code&gt; &lt;/a&gt;方法读取文件属性，并使用&lt;a href=&quot;attribute/basicfileattributes#isRegularFile()&quot;&gt; &lt;code&gt;BasicFileAttributes.isRegularFile()&lt;/code&gt; &lt;/a&gt;方法测试文件类型。</target>
        </trans-unit>
        <trans-unit id="02f695b12ef8bb76e6aea55a25eeab17ff1669ac" translate="yes" xml:space="preserve">
          <source>Where it is required to distinguish an I/O exception from the case that the file is not a regular file then the file attributes can be read with the &lt;a href=&quot;files#readAttributes-java.nio.file.Path-java.lang.Class-java.nio.file.LinkOption...-&quot;&gt;&lt;code&gt;readAttributes&lt;/code&gt;&lt;/a&gt; method and the file type tested with the &lt;a href=&quot;attribute/basicfileattributes#isRegularFile--&quot;&gt;&lt;code&gt;BasicFileAttributes.isRegularFile()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">如果需要将I / O异常与文件不是常规文件区分开来，则可以使用&lt;a href=&quot;files#readAttributes-java.nio.file.Path-java.lang.Class-java.nio.file.LinkOption...-&quot;&gt; &lt;code&gt;readAttributes&lt;/code&gt; &lt;/a&gt;方法读取文件属性，并使用&lt;a href=&quot;attribute/basicfileattributes#isRegularFile--&quot;&gt; &lt;code&gt;BasicFileAttributes.isRegularFile()&lt;/code&gt; &lt;/a&gt;方法测试文件类型。</target>
        </trans-unit>
        <trans-unit id="b73ecca6efa6b0c0122ee193aadbfbbac0725868" translate="yes" xml:space="preserve">
          <source>Where it is required to distinguish an I/O exception from the case that the file is not a symbolic link then the file attributes can be read with the &lt;a href=&quot;#readAttributes(java.nio.file.Path,java.lang.Class,java.nio.file.LinkOption...)&quot;&gt;&lt;code&gt;readAttributes&lt;/code&gt;&lt;/a&gt; method and the file type tested with the &lt;a href=&quot;attribute/basicfileattributes#isSymbolicLink()&quot;&gt;&lt;code&gt;BasicFileAttributes.isSymbolicLink()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">如果需要将I / O异常与文件不是符号链接的情况区分开，则可以使用&lt;a href=&quot;#readAttributes(java.nio.file.Path,java.lang.Class,java.nio.file.LinkOption...)&quot;&gt; &lt;code&gt;readAttributes&lt;/code&gt; &lt;/a&gt;方法读取文件属性，并使用&lt;a href=&quot;attribute/basicfileattributes#isSymbolicLink()&quot;&gt; &lt;code&gt;BasicFileAttributes.isSymbolicLink()&lt;/code&gt; &lt;/a&gt;方法测试文件类型。</target>
        </trans-unit>
        <trans-unit id="3b99909cf143f334a41da20c3faff5347727a01c" translate="yes" xml:space="preserve">
          <source>Where it is required to distinguish an I/O exception from the case that the file is not a symbolic link then the file attributes can be read with the &lt;a href=&quot;files#readAttributes-java.nio.file.Path-java.lang.Class-java.nio.file.LinkOption...-&quot;&gt;&lt;code&gt;readAttributes&lt;/code&gt;&lt;/a&gt; method and the file type tested with the &lt;a href=&quot;attribute/basicfileattributes#isSymbolicLink--&quot;&gt;&lt;code&gt;BasicFileAttributes.isSymbolicLink()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">如果需要将I / O异常与文件不是符号链接的情况区分开，则可以使用&lt;a href=&quot;files#readAttributes-java.nio.file.Path-java.lang.Class-java.nio.file.LinkOption...-&quot;&gt; &lt;code&gt;readAttributes&lt;/code&gt; &lt;/a&gt;方法读取文件属性，并使用&lt;a href=&quot;attribute/basicfileattributes#isSymbolicLink--&quot;&gt; &lt;code&gt;BasicFileAttributes.isSymbolicLink()&lt;/code&gt; &lt;/a&gt;方法测试文件类型。</target>
        </trans-unit>
        <trans-unit id="0a3da2048af042507ba49cb66f0ec70eb628b60c" translate="yes" xml:space="preserve">
          <source>Where it is required to distinguish an I/O exception from the case where &lt;code&gt;0L&lt;/code&gt; is returned, or where several attributes of the same file are required at the same time, or where the time of last access or the creation time are required, then the &lt;a href=&quot;../nio/file/files#readAttributes(java.nio.file.Path,java.lang.Class,java.nio.file.LinkOption...)&quot;&gt;&lt;code&gt;Files.readAttributes&lt;/code&gt;&lt;/a&gt; method may be used. If however only the time of last modification is required, then the &lt;a href=&quot;../nio/file/files#getLastModifiedTime(java.nio.file.Path,java.nio.file.LinkOption...)&quot;&gt;&lt;code&gt;Files.getLastModifiedTime&lt;/code&gt;&lt;/a&gt; method may be used instead.</source>
          <target state="translated">如果需要将I / O异常与返回 &lt;code&gt;0L&lt;/code&gt; 的情况，需要同时访问同一文件的多个属性的情况，需要最后访问时间或创建时间的地方区分开，则可以使用&lt;a href=&quot;../nio/file/files#readAttributes(java.nio.file.Path,java.lang.Class,java.nio.file.LinkOption...)&quot;&gt; &lt;code&gt;Files.readAttributes&lt;/code&gt; &lt;/a&gt;方法。但是，如果仅需要最后一次修改的时间，则可以改用&lt;a href=&quot;../nio/file/files#getLastModifiedTime(java.nio.file.Path,java.nio.file.LinkOption...)&quot;&gt; &lt;code&gt;Files.getLastModifiedTime&lt;/code&gt; &lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="acaa3530ad31cc461c41f4ed0c962b27b0124c2a" translate="yes" xml:space="preserve">
          <source>Where it is required to distinguish an I/O exception from the case where &lt;code&gt;0L&lt;/code&gt; is returned, or where several attributes of the same file are required at the same time, or where the time of last access or the creation time are required, then the &lt;a href=&quot;../nio/file/files#readAttributes-java.nio.file.Path-java.lang.Class-java.nio.file.LinkOption...-&quot;&gt;&lt;code&gt;Files.readAttributes&lt;/code&gt;&lt;/a&gt; method may be used.</source>
          <target state="translated">如果需要将I / O异常与返回 &lt;code&gt;0L&lt;/code&gt; 的情况区分开，或者同时需要同一文件的多个属性，或者需要最后访问时间或创建时间，则需要可以使用&lt;a href=&quot;../nio/file/files#readAttributes-java.nio.file.Path-java.lang.Class-java.nio.file.LinkOption...-&quot;&gt; &lt;code&gt;Files.readAttributes&lt;/code&gt; &lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="15c805f474acebca2530400cb8d6a021d50edd5e" translate="yes" xml:space="preserve">
          <source>Where possible, a newly constructed &lt;code&gt;DatagramSocket&lt;/code&gt; has the &lt;a href=&quot;socketoptions#SO_BROADCAST&quot;&gt;&lt;code&gt;SO_BROADCAST&lt;/code&gt;&lt;/a&gt; socket option enabled so as to allow the transmission of broadcast datagrams. In order to receive broadcast packets a DatagramSocket should be bound to the wildcard address. In some implementations, broadcast packets may also be received when a DatagramSocket is bound to a more specific address.</source>
          <target state="translated">在可能的情况下，新构造的 &lt;code&gt;DatagramSocket&lt;/code&gt; 启用了&lt;a href=&quot;socketoptions#SO_BROADCAST&quot;&gt; &lt;code&gt;SO_BROADCAST&lt;/code&gt; &lt;/a&gt;套接字选项，以便允许传输广播数据报。为了接收广播数据包，应将DatagramSocket绑定到通配符地址。在一些实施方式中，当DatagramSocket绑定到更特定的地址时，也可以接收广播分组。</target>
        </trans-unit>
        <trans-unit id="75db673482e4c428800f7f45f472cc74cb1cd427" translate="yes" xml:space="preserve">
          <source>Where possible, a newly constructed &lt;code&gt;DatagramSocket&lt;/code&gt; has the &lt;a href=&quot;standardsocketoptions#SO_BROADCAST&quot;&gt;&lt;code&gt;SO_BROADCAST&lt;/code&gt;&lt;/a&gt; socket option enabled so as to allow the transmission of broadcast datagrams. In order to receive broadcast packets a DatagramSocket should be bound to the wildcard address. In some implementations, broadcast packets may also be received when a DatagramSocket is bound to a more specific address.</source>
          <target state="translated">在可能的情况下，新构造的 &lt;code&gt;DatagramSocket&lt;/code&gt; 启用了&lt;a href=&quot;standardsocketoptions#SO_BROADCAST&quot;&gt; &lt;code&gt;SO_BROADCAST&lt;/code&gt; &lt;/a&gt;套接字选项，以便允许传输广播数据报。为了接收广播数据包，应将DatagramSocket绑定到通配符地址。在一些实施方式中，当DatagramSocket绑定到更特定的地址时，也可以接收广播分组。</target>
        </trans-unit>
        <trans-unit id="ae2251eb2bdde2077099e46a23fa2296253a4452" translate="yes" xml:space="preserve">
          <source>Where possible, applications should use &lt;code&gt;LocalDate&lt;/code&gt;, &lt;code&gt;LocalTime&lt;/code&gt; and &lt;code&gt;LocalDateTime&lt;/code&gt; to better model the domain. For example, a birthday should be stored in a code &lt;code&gt;LocalDate&lt;/code&gt;. Bear in mind that any use of a &lt;a href=&quot;zoneid&quot;&gt;time-zone&lt;/a&gt;, such as 'Europe/Paris', adds considerable complexity to a calculation. Many applications can be written only using &lt;code&gt;LocalDate&lt;/code&gt;, &lt;code&gt;LocalTime&lt;/code&gt; and &lt;code&gt;Instant&lt;/code&gt;, with the time-zone added at the user interface (UI) layer.</source>
          <target state="translated">在可能的情况下，应用程序应使用 &lt;code&gt;LocalDate&lt;/code&gt; ， &lt;code&gt;LocalTime&lt;/code&gt; 和 &lt;code&gt;LocalDateTime&lt;/code&gt; 更好地为域建模。例如，生日应该存储在代码 &lt;code&gt;LocalDate&lt;/code&gt; 中。请记住，任何&lt;a href=&quot;zoneid&quot;&gt;时区的使用&lt;/a&gt;（例如&amp;ldquo;欧洲/巴黎&amp;rdquo;）都会增加计算的复杂性。只能使用 &lt;code&gt;LocalDate&lt;/code&gt; ， &lt;code&gt;LocalTime&lt;/code&gt; 和 &lt;code&gt;Instant&lt;/code&gt; 编写许多应用程序，并在用户界面（UI）层添加时区。</target>
        </trans-unit>
        <trans-unit id="91b2e2e10f69ab09824cf8a20764fb8ed9c2bb88" translate="yes" xml:space="preserve">
          <source>Where several modules are defined to the same class loader, and where more than one module contains a resource with the given name, then the ordering is not specified and may be very unpredictable. When overriding this method it is recommended that an implementation ensures that any delegation is consistent with the &lt;a href=&quot;#getResource(java.lang.String)&quot;&gt;&lt;code&gt;getResource(String)&lt;/code&gt;&lt;/a&gt; method. This should ensure that the first element returned by the Enumeration's &lt;code&gt;nextElement&lt;/code&gt; method is the same resource that the &lt;code&gt;getResource(String)&lt;/code&gt; method would return.</source>
          <target state="translated">如果为同一个类加载器定义了多个模块，并且有多个模块包含具有给定名称的资源，则未指定顺序，并且顺序可能非常不可预测。重写此方法时，建议实现确保任何委托与&lt;a href=&quot;#getResource(java.lang.String)&quot;&gt; &lt;code&gt;getResource(String)&lt;/code&gt; &lt;/a&gt;方法一致。这应该确保Enumeration的 &lt;code&gt;nextElement&lt;/code&gt; 方法返回的第一个元素与 &lt;code&gt;getResource(String)&lt;/code&gt; 方法将返回的资源相同。</target>
        </trans-unit>
        <trans-unit id="30feb1a1deb63d86d797b59fc10ebf6c8ef8b081" translate="yes" xml:space="preserve">
          <source>Where several modules are defined to the same class loader, and where more than one module contains a resource with the given name, then the ordering that modules are searched is not specified and may be very unpredictable. When overriding this method it is recommended that an implementation ensures that any delegation is consistent with the &lt;a href=&quot;#getResources(java.lang.String)&quot;&gt;&lt;code&gt;getResources(String)&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">如果为同一个类加载器定义了多个模块，并且多个模块包含具有给定名称的资源，则未指定搜索模块的顺序，并且可能是非常不可预测的。重写此方法时，建议实现确保所有委托与&lt;a href=&quot;#getResources(java.lang.String)&quot;&gt; &lt;code&gt;getResources(String)&lt;/code&gt; &lt;/a&gt;方法一致。</target>
        </trans-unit>
        <trans-unit id="87e0bb7fc901d05afac4326d164f35bed3f81996" translate="yes" xml:space="preserve">
          <source>Where symbolic links are supported, but the underlying &lt;a href=&quot;filestore&quot;&gt;&lt;code&gt;FileStore&lt;/code&gt;&lt;/a&gt; does not support symbolic links, then this may fail with an &lt;a href=&quot;../../io/ioexception&quot;&gt;&lt;code&gt;IOException&lt;/code&gt;&lt;/a&gt;. Additionally, some operating systems may require that the Java virtual machine be started with implementation specific privileges to create symbolic links, in which case this method may throw &lt;code&gt;IOException&lt;/code&gt;.</source>
          <target state="translated">如果支持符号链接，但基础&lt;a href=&quot;filestore&quot;&gt; &lt;code&gt;FileStore&lt;/code&gt; &lt;/a&gt;不支持符号链接，则可能会失败，并出现&lt;a href=&quot;../../io/ioexception&quot;&gt; &lt;code&gt;IOException&lt;/code&gt; &lt;/a&gt;。此外，某些操作系统可能要求Java虚拟机以实现特定的特权启动以创建符号链接，在这种情况下，此方法可能会抛出 &lt;code&gt;IOException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aff3ccdb832b941a77362ca0a3153b1ed7d1a9da" translate="yes" xml:space="preserve">
          <source>Where syntactically malformed entries are encountered, the entry is ignored and the remainder of entries in file are processed. For instances where duplicate country code entries exist, the behavior of the Currency information for that &lt;code&gt;Currency&lt;/code&gt; is undefined and the remainder of entries in file are processed.</source>
          <target state="translated">如果遇到语法错误的条目，则将忽略该条目，并处理文件中的其余条目。对于那些重复的国家代码项存在的情况下，对于该货币信息的行为 &lt;code&gt;Currency&lt;/code&gt; 是未定义的条目在文件中的其余部分进行处理。</target>
        </trans-unit>
        <trans-unit id="645bad2c04254cc2a6d121dc714e9825c14fd591" translate="yes" xml:space="preserve">
          <source>Where the &lt;a href=&quot;../../util/concurrent/future#cancel(boolean)&quot;&gt;&lt;code&gt;cancel&lt;/code&gt;&lt;/a&gt; method is invoked with the &lt;code&gt;
 mayInterruptIfRunning&lt;/code&gt; parameter set to &lt;code&gt;true&lt;/code&gt; then the I/O operation may be interrupted by closing the channel. In that case all threads waiting on the result of the I/O operation throw &lt;code&gt;CancellationException&lt;/code&gt; and any other I/O operations outstanding on the channel complete with the exception &lt;a href=&quot;asynchronouscloseexception&quot;&gt;&lt;code&gt;AsynchronousCloseException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果在 &lt;code&gt; mayInterruptIfRunning&lt;/code&gt; 参数设置为 &lt;code&gt;true&lt;/code&gt; 的情况下调用&lt;a href=&quot;../../util/concurrent/future#cancel(boolean)&quot;&gt; &lt;code&gt;cancel&lt;/code&gt; &lt;/a&gt;方法，则可以通过关闭通道来中断I / O操作。在这种情况下，所有等待I / O操作结果的线程都将引发 &lt;code&gt;CancellationException&lt;/code&gt; 和通道上所有其他未完成的I / O操作，并带有&lt;a href=&quot;asynchronouscloseexception&quot;&gt; &lt;code&gt;AsynchronousCloseException&lt;/code&gt; &lt;/a&gt;异常。</target>
        </trans-unit>
        <trans-unit id="c0bfb8c567532e837621aeea501dc3f1ddcd12e2" translate="yes" xml:space="preserve">
          <source>Where the &lt;a href=&quot;../../util/concurrent/future#cancel-boolean-&quot;&gt;&lt;code&gt;cancel&lt;/code&gt;&lt;/a&gt; method is invoked with the &lt;code&gt;mayInterruptIfRunning&lt;/code&gt; parameter set to &lt;code&gt;true&lt;/code&gt; then the I/O operation may be interrupted by closing the channel. In that case all threads waiting on the result of the I/O operation throw &lt;code&gt;CancellationException&lt;/code&gt; and any other I/O operations outstanding on the channel complete with the exception &lt;a href=&quot;asynchronouscloseexception&quot;&gt;&lt;code&gt;AsynchronousCloseException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果在 &lt;code&gt;mayInterruptIfRunning&lt;/code&gt; 参数设置为 &lt;code&gt;true&lt;/code&gt; 的情况下调用&lt;a href=&quot;../../util/concurrent/future#cancel-boolean-&quot;&gt; &lt;code&gt;cancel&lt;/code&gt; &lt;/a&gt;方法，则可以通过关闭通道来中断I / O操作。在那种情况下，所有等待I / O操作结果的线程都将引发 &lt;code&gt;CancellationException&lt;/code&gt; 和通道上所有其他未完成的I / O操作，并带有&lt;a href=&quot;asynchronouscloseexception&quot;&gt; &lt;code&gt;AsynchronousCloseException&lt;/code&gt; &lt;/a&gt;异常。</target>
        </trans-unit>
        <trans-unit id="c6c5daf70ef6f15c107a25281f6a04621e811b36" translate="yes" xml:space="preserve">
          <source>Where the &lt;code&gt;cancel&lt;/code&gt; method is invoked to cancel read or write operations then it is recommended that all buffers used in the I/O operations be discarded or care taken to ensure that the buffers are not accessed while the channel remains open.</source>
          <target state="translated">在调用 &lt;code&gt;cancel&lt;/code&gt; 方法取消读取或写入操作的情况下，建议丢弃I / O操作中使用的所有缓冲区，或者注意确保在通道保持打开状态时不访问这些缓冲区。</target>
        </trans-unit>
        <trans-unit id="9d8305902030508a453b89974c5e0784154948cf" translate="yes" xml:space="preserve">
          <source>Where the &lt;code&gt;modified_package_name&lt;/code&gt; is the package name of this object with &lt;code&gt;'/'&lt;/code&gt; substituted for &lt;code&gt;'.'&lt;/code&gt; (&lt;code&gt;'\u002e'&lt;/code&gt;).</source>
          <target state="translated">其中 &lt;code&gt;modified_package_name&lt;/code&gt; 是此对象的软件包名称，用 &lt;code&gt;'/'&lt;/code&gt; 代替 &lt;code&gt;'.'&lt;/code&gt; （ &lt;code&gt;'\u002e'&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="20aa13f386a65b9aa665ab0dd65397813225275a" translate="yes" xml:space="preserve">
          <source>Where the channel is &lt;a href=&quot;#bind(java.net.SocketAddress)&quot;&gt;&lt;code&gt;bound&lt;/code&gt;&lt;/a&gt; to an Internet Protocol socket address then the return value from this method is of type &lt;a href=&quot;../../net/inetsocketaddress&quot;&gt;&lt;code&gt;InetSocketAddress&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果通道&lt;a href=&quot;#bind(java.net.SocketAddress)&quot;&gt; &lt;code&gt;bound&lt;/code&gt; &lt;/a&gt;到Internet协议套接字地址，则此方法的返回值是&lt;a href=&quot;../../net/inetsocketaddress&quot;&gt; &lt;code&gt;InetSocketAddress&lt;/code&gt; &lt;/a&gt;类型。</target>
        </trans-unit>
        <trans-unit id="4b1d4e9876a115d289cc3d3d89044c6ff716cd4b" translate="yes" xml:space="preserve">
          <source>Where the channel is &lt;a href=&quot;networkchannel#bind(java.net.SocketAddress)&quot;&gt;&lt;code&gt;bound&lt;/code&gt;&lt;/a&gt; to an Internet Protocol socket address then the return value from this method is of type &lt;a href=&quot;../../net/inetsocketaddress&quot;&gt;&lt;code&gt;InetSocketAddress&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果通道&lt;a href=&quot;networkchannel#bind(java.net.SocketAddress)&quot;&gt; &lt;code&gt;bound&lt;/code&gt; &lt;/a&gt;到Internet协议套接字地址，则此方法的返回值是&lt;a href=&quot;../../net/inetsocketaddress&quot;&gt; &lt;code&gt;InetSocketAddress&lt;/code&gt; &lt;/a&gt;类型。</target>
        </trans-unit>
        <trans-unit id="5776a8c2e2eb012135f9b2f791b325011a696da1" translate="yes" xml:space="preserve">
          <source>Where the channel is &lt;a href=&quot;networkchannel#bind-java.net.SocketAddress-&quot;&gt;&lt;code&gt;bound&lt;/code&gt;&lt;/a&gt; to an Internet Protocol socket address then the return value from this method is of type &lt;a href=&quot;../../net/inetsocketaddress&quot;&gt;&lt;code&gt;InetSocketAddress&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果通道&lt;a href=&quot;networkchannel#bind-java.net.SocketAddress-&quot;&gt; &lt;code&gt;bound&lt;/code&gt; &lt;/a&gt;到Internet协议套接字地址，则此方法的返回值是&lt;a href=&quot;../../net/inetsocketaddress&quot;&gt; &lt;code&gt;InetSocketAddress&lt;/code&gt; &lt;/a&gt;类型。</target>
        </trans-unit>
        <trans-unit id="2b5a252c98def07c02e37f2ec2055c98d16f0a55" translate="yes" xml:space="preserve">
          <source>Where the channel is bound and connected to an Internet Protocol socket address then the return value from this method is of type &lt;a href=&quot;../../net/inetsocketaddress&quot;&gt;&lt;code&gt;InetSocketAddress&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在绑定通道并将其连接到Internet协议套接字地址的位置，此方法的返回值是&lt;a href=&quot;../../net/inetsocketaddress&quot;&gt; &lt;code&gt;InetSocketAddress&lt;/code&gt; &lt;/a&gt;类型。</target>
        </trans-unit>
        <trans-unit id="f3d56641ee7619e7defb7d614564f85e1460565f" translate="yes" xml:space="preserve">
          <source>Where the directory is opened successfully, then the entries in the directory, and their &lt;em&gt;descendants&lt;/em&gt; are visited. When all entries have been visited, or an I/O error occurs during iteration of the directory, then the directory is closed and the visitor's &lt;a href=&quot;filevisitor#postVisitDirectory(T,java.io.IOException)&quot;&gt;&lt;code&gt;postVisitDirectory&lt;/code&gt;&lt;/a&gt; method is invoked. The file tree walk then continues, by default, at the next &lt;em&gt;sibling&lt;/em&gt; of the directory.</source>
          <target state="translated">成功打开目录的位置，然后访问目录中的条目及其&lt;em&gt;后代&lt;/em&gt;。当所有条目都已被访问或目录的迭代过程中发生I / O错误时，将关闭目录并调用访问者的&lt;a href=&quot;filevisitor#postVisitDirectory(T,java.io.IOException)&quot;&gt; &lt;code&gt;postVisitDirectory&lt;/code&gt; &lt;/a&gt;方法。然后，默认情况下，在目录的下一个&lt;em&gt;同级&lt;/em&gt;目录中继续文件树遍历。</target>
        </trans-unit>
        <trans-unit id="ddadcdbdf7fecb97856976200f59b9dff77b97ca" translate="yes" xml:space="preserve">
          <source>Where the directory is opened successfully, then the entries in the directory, and their &lt;em&gt;descendants&lt;/em&gt; are visited. When all entries have been visited, or an I/O error occurs during iteration of the directory, then the directory is closed and the visitor's &lt;a href=&quot;filevisitor#postVisitDirectory-T-java.io.IOException-&quot;&gt;&lt;code&gt;postVisitDirectory&lt;/code&gt;&lt;/a&gt; method is invoked. The file tree walk then continues, by default, at the next &lt;em&gt;sibling&lt;/em&gt; of the directory.</source>
          <target state="translated">成功打开目录的位置，然后访问目录中的条目及其&lt;em&gt;后代&lt;/em&gt;。当所有条目都已被访问或目录的迭代过程中发生I / O错误时，将关闭目录并调用访问者的&lt;a href=&quot;filevisitor#postVisitDirectory-T-java.io.IOException-&quot;&gt; &lt;code&gt;postVisitDirectory&lt;/code&gt; &lt;/a&gt;方法。然后，默认情况下，在目录的下一个&lt;em&gt;同级&lt;/em&gt;目录中继续文件树遍历。</target>
        </trans-unit>
        <trans-unit id="f20fbb77d5a28e0705439af43dcf961b9abb6e04" translate="yes" xml:space="preserve">
          <source>Where the file is a directory, and the directory could not be opened, then the &lt;code&gt;visitFileFailed&lt;/code&gt; method is invoked with the I/O exception, after which, the file tree walk continues, by default, at the next &lt;em&gt;sibling&lt;/em&gt; of the directory.</source>
          <target state="translated">如果文件是目录，并且无法打开目录，则将使用I / O异常调用 &lt;code&gt;visitFileFailed&lt;/code&gt; 方法，此后，默认情况下，在目录的下一个&lt;em&gt;同级&lt;/em&gt;目录下继续进行文件树遍历。</target>
        </trans-unit>
        <trans-unit id="813178800981aaf7228102a5aacbe600959c9826" translate="yes" xml:space="preserve">
          <source>Where the file system supports Access Control Lists, and it uses an ACL model that differs from the NFSv4 defined ACL model, then this method must translate the ACL to the model supported by the file system. This method should reject (by throwing &lt;a href=&quot;../../../io/ioexception&quot;&gt;&lt;code&gt;IOException&lt;/code&gt;&lt;/a&gt;) any attempt to write an ACL that would appear to make the file more secure than would be the case if the ACL were updated. Where an implementation does not support a mapping of &lt;a href=&quot;aclentrytype#AUDIT&quot;&gt;&lt;code&gt;AclEntryType.AUDIT&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;aclentrytype#ALARM&quot;&gt;&lt;code&gt;AclEntryType.ALARM&lt;/code&gt;&lt;/a&gt; entries, then this method ignores these entries when writing the ACL.</source>
          <target state="translated">如果文件系统支持访问控制列表，并且使用的ACL模型与NFSv4定义的ACL模型不同，则此方法必须将ACL转换为文件系统支持的模型。此方法应拒绝（通过抛出&lt;a href=&quot;../../../io/ioexception&quot;&gt; &lt;code&gt;IOException&lt;/code&gt; &lt;/a&gt;）任何试图写ACL的尝试，该尝试似乎使文件比更新ACL的情况更安全。如果实现不支持&lt;a href=&quot;aclentrytype#AUDIT&quot;&gt; &lt;code&gt;AclEntryType.AUDIT&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;aclentrytype#ALARM&quot;&gt; &lt;code&gt;AclEntryType.ALARM&lt;/code&gt; &lt;/a&gt;条目的映射，则此方法在编写ACL时将忽略这些条目。</target>
        </trans-unit>
        <trans-unit id="1bf3aa721e02b8abb961e05d45c9ccdfa7286d66" translate="yes" xml:space="preserve">
          <source>Where the filter terminates due to an uncaught error or runtime exception then it is propagated to the &lt;a href=&quot;../../util/iterator#hasNext()&quot;&gt;&lt;code&gt;hasNext&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../util/iterator#next()&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; method. Where an &lt;code&gt;
 IOException&lt;/code&gt; is thrown, it results in the &lt;code&gt;hasNext&lt;/code&gt; or &lt;code&gt;
 next&lt;/code&gt; method throwing a &lt;a href=&quot;directoryiteratorexception&quot;&gt;&lt;code&gt;DirectoryIteratorException&lt;/code&gt;&lt;/a&gt; with the &lt;code&gt;IOException&lt;/code&gt; as the cause.</source>
          <target state="translated">如果过滤器由于未捕获的错误或运行时异常而终止，则将其传播到&lt;a href=&quot;../../util/iterator#hasNext()&quot;&gt; &lt;code&gt;hasNext&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../../util/iterator#next()&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt;方法。引发 &lt;code&gt; IOException&lt;/code&gt; 的地方，它会导致 &lt;code&gt;hasNext&lt;/code&gt; 或 &lt;code&gt; next&lt;/code&gt; 方法引发以 &lt;code&gt;IOException&lt;/code&gt; 为原因的&lt;a href=&quot;directoryiteratorexception&quot;&gt; &lt;code&gt;DirectoryIteratorException&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8251e33247a11466c53d88af669cedf9a7c9b244" translate="yes" xml:space="preserve">
          <source>Where the filter terminates due to an uncaught error or runtime exception then it is propagated to the &lt;a href=&quot;../../util/iterator#hasNext--&quot;&gt;&lt;code&gt;hasNext&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../util/iterator#next--&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; method. Where an &lt;code&gt;IOException&lt;/code&gt; is thrown, it results in the &lt;code&gt;hasNext&lt;/code&gt; or &lt;code&gt;next&lt;/code&gt; method throwing a &lt;a href=&quot;directoryiteratorexception&quot;&gt;&lt;code&gt;DirectoryIteratorException&lt;/code&gt;&lt;/a&gt; with the &lt;code&gt;IOException&lt;/code&gt; as the cause.</source>
          <target state="translated">如果过滤器由于未捕获的错误或运行时异常而终止，则将其传播到&lt;a href=&quot;../../util/iterator#hasNext--&quot;&gt; &lt;code&gt;hasNext&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../../util/iterator#next--&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt;方法。引发 &lt;code&gt;IOException&lt;/code&gt; 的地方，它会导致 &lt;code&gt;hasNext&lt;/code&gt; 或 &lt;code&gt;next&lt;/code&gt; 方法引发以 &lt;code&gt;IOException&lt;/code&gt; 为原因的&lt;a href=&quot;directoryiteratorexception&quot;&gt; &lt;code&gt;DirectoryIteratorException&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6af0ee5404f0be6ffe44935c032e92267f7c81e1" translate="yes" xml:space="preserve">
          <source>Where the impact lies, however, is in constructing and showing a Swing application. Calls to an application's &lt;code&gt;main&lt;/code&gt; method, or methods in &lt;code&gt;Applet&lt;/code&gt;, are not invoked on the event dispatching thread. As such, care must be taken to transfer control to the event dispatching thread when constructing and showing an application or applet. The preferred way to transfer control and begin working with Swing is to use &lt;code&gt;invokeLater&lt;/code&gt;. The &lt;code&gt;invokeLater&lt;/code&gt; method schedules a &lt;code&gt;Runnable&lt;/code&gt; to be processed on the event dispatching thread. The following two examples work equally well for transferring control and starting up a Swing application:</source>
          <target state="translated">但是，影响所在在于构建和显示Swing应用程序。在事件分派线程上不会调用对应用程序的 &lt;code&gt;main&lt;/code&gt; 方法或 &lt;code&gt;Applet&lt;/code&gt; 中的方法的调用。因此，在构造和显示应用程序或小程序时，必须注意将控制权转移到事件分发线程。转移控制权并开始使用Swing的首选方法是使用 &lt;code&gt;invokeLater&lt;/code&gt; 。所述 &lt;code&gt;invokeLater&lt;/code&gt; 方法调度一个 &lt;code&gt;Runnable&lt;/code&gt; 要在事件调度线程上处理。以下两个示例对于转移控制权和启动Swing应用程序同样有效：</target>
        </trans-unit>
        <trans-unit id="c51f5961597e3abbd7cbd8e36154eb7f8ad2d5be" translate="yes" xml:space="preserve">
          <source>Where the nodes to be removed are read-only descendants of an &lt;code&gt;EntityReference&lt;/code&gt;, the &lt;code&gt;EntityReference&lt;/code&gt; must be removed instead of the read-only nodes. If any &lt;code&gt;EntityReference&lt;/code&gt; to be removed has descendants that are not &lt;code&gt;EntityReference&lt;/code&gt;, &lt;code&gt;Text&lt;/code&gt;, or &lt;code&gt;CDATASection&lt;/code&gt; nodes, the &lt;code&gt;replaceWholeText&lt;/code&gt; method must fail before performing any modification of the document, raising a &lt;code&gt;DOMException&lt;/code&gt; with the code &lt;code&gt;NO_MODIFICATION_ALLOWED_ERR&lt;/code&gt;.</source>
          <target state="translated">如果要删除的节点是 &lt;code&gt;EntityReference&lt;/code&gt; 的只读后代，则必须删除 &lt;code&gt;EntityReference&lt;/code&gt; 而不是只读节点。如果要删除的任何 &lt;code&gt;EntityReference&lt;/code&gt; 具有不是 &lt;code&gt;EntityReference&lt;/code&gt; ， &lt;code&gt;Text&lt;/code&gt; 或 &lt;code&gt;CDATASection&lt;/code&gt; 节点的 &lt;code&gt;replaceWholeText&lt;/code&gt; ，则replaceWholeText方法必须失败才能执行对文档的任何修改，并使用代码 &lt;code&gt;NO_MODIFICATION_ALLOWED_ERR&lt;/code&gt; 引发 &lt;code&gt;DOMException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e9e95719d37b90a01bb50bb0f34cef6a4524dc4a" translate="yes" xml:space="preserve">
          <source>Where the tabs are placed.</source>
          <target state="translated">标签的位置。</target>
        </trans-unit>
        <trans-unit id="312f35b21c5541d25fef137d0c9ff3c37934f56a" translate="yes" xml:space="preserve">
          <source>Where there is insufficient space to store the attribute, or the attribute name or value exceed an implementation specific maximum size then an &lt;code&gt;IOException&lt;/code&gt; is thrown.</source>
          <target state="translated">如果没有足够的空间来存储属性，或者属性名称或值超过实现特定的最大大小，则将引发 &lt;code&gt;IOException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="78177395926d156536f0c1ac9740391b9dc6422e" translate="yes" xml:space="preserve">
          <source>Where this method returns &lt;code&gt;true&lt;/code&gt;, then the associated thread pool has also &lt;a href=&quot;../../util/concurrent/executorservice#isTerminated()&quot;&gt;&lt;code&gt;terminated&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果此方法返回 &lt;code&gt;true&lt;/code&gt; ，则关联的线程池也已&lt;a href=&quot;../../util/concurrent/executorservice#isTerminated()&quot;&gt; &lt;code&gt;terminated&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e3596c9771db04fbff45896ebd877c1d02f0912e" translate="yes" xml:space="preserve">
          <source>Where this method returns &lt;code&gt;true&lt;/code&gt;, then the associated thread pool has also &lt;a href=&quot;../../util/concurrent/executorservice#isTerminated--&quot;&gt;&lt;code&gt;terminated&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果此方法返回 &lt;code&gt;true&lt;/code&gt; ，则关联的线程池也已&lt;a href=&quot;../../util/concurrent/executorservice#isTerminated--&quot;&gt; &lt;code&gt;terminated&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ca7c18078eeeb8440182461deea920927988a9b5" translate="yes" xml:space="preserve">
          <source>Where two scroll bars meet, the row header meets the column header, or a scroll bar meets one of the headers, both components stop short of the corner, leaving a rectangular space which is, by default, empty. These spaces can potentially exist in any number of the four corners. In the previous diagram, the top right space is present and identified by the label &quot;corner component&quot;.</source>
          <target state="translated">在两个滚动条相接的地方,行标题与列标题相接的地方,或者滚动条与其中一个标题相接的地方,两个组件都会在拐角处停下,留下一个矩形空间,默认情况下,这个空间是空的。这些空间可能存在于四个角的任意数量。在上一张图中,右上角的空间是存在的,并以 &quot;角组件 &quot;标签来标识。</target>
        </trans-unit>
        <trans-unit id="f85fba4d6258a50067fbdc6fb4924687e3519a29" translate="yes" xml:space="preserve">
          <source>Where value limitations are given, any value outside of that set is reserved for future use; the value will be treated as the default.</source>
          <target state="translated">在给定值限制的情况下,该集合之外的任何值都保留给将来使用;该值将被视为默认值。</target>
        </trans-unit>
        <trans-unit id="b93b49aca4151b6c139adc0aa283a778340da4f0" translate="yes" xml:space="preserve">
          <source>Where, in this case, the method handle is bound to the VarHandle instance.</source>
          <target state="translated">其中,在这种情况下,方法句柄被绑定到VarHandle实例上。</target>
        </trans-unit>
        <trans-unit id="70c9d617c105e0ab6aed38dbb10fa98dbb5056d6" translate="yes" xml:space="preserve">
          <source>Whereas a &lt;code&gt;PrintService&lt;/code&gt; connected to a physical printer can be reused, a &lt;code&gt;StreamPrintService&lt;/code&gt; connected to a stream cannot. The underlying &lt;code&gt;StreamPrintService&lt;/code&gt; may be disposed by the print system with the &lt;a href=&quot;streamprintservice#dispose()&quot;&gt;&lt;code&gt;dispose&lt;/code&gt;&lt;/a&gt; method before returning from the &lt;a href=&quot;docprintjob#print(javax.print.Doc,javax.print.attribute.PrintRequestAttributeSet)&quot;&gt;&lt;code&gt;print&lt;/code&gt;&lt;/a&gt; method of &lt;code&gt;DocPrintJob&lt;/code&gt; so that the print system knows this printer is no longer usable. This is equivalent to a physical printer going offline - permanently. Applications may supply a &lt;code&gt;null&lt;/code&gt; print stream to create a queryable service. It is not valid to create a &lt;code&gt;PrintJob&lt;/code&gt; for such a stream. Implementations which allocate resources on construction should examine the stream and may wish to only allocate resources if the stream is &lt;code&gt;non-null&lt;/code&gt;.</source>
          <target state="translated">连接到物理打印机的 &lt;code&gt;PrintService&lt;/code&gt; 可以重复使用，而连接到流的 &lt;code&gt;StreamPrintService&lt;/code&gt; 不能重复使用。在从 &lt;code&gt;DocPrintJob&lt;/code&gt; 的&lt;a href=&quot;docprintjob#print(javax.print.Doc,javax.print.attribute.PrintRequestAttributeSet)&quot;&gt; &lt;code&gt;print&lt;/code&gt; &lt;/a&gt;方法返回之前，底层的 &lt;code&gt;StreamPrintService&lt;/code&gt; 可以由打印系统使用&lt;a href=&quot;streamprintservice#dispose()&quot;&gt; &lt;code&gt;dispose&lt;/code&gt; &lt;/a&gt;方法进行处理，以使打印系统知道该打印机不再可用。这等效于物理打印机永久脱机。应用程序可以提供 &lt;code&gt;null&lt;/code&gt; 打印流以创建可查询的服务。创建 &lt;code&gt;PrintJob&lt;/code&gt; 是无效的对于这样的流。在构造上分配资源的实现应检查流，并且可能希望仅在流 &lt;code&gt;non-null&lt;/code&gt; 下分配资源。</target>
        </trans-unit>
        <trans-unit id="7b6a9723c6d2f9343f85c6d8af60801d7b7682ec" translate="yes" xml:space="preserve">
          <source>Whereas a &lt;code&gt;PrintService&lt;/code&gt; connected to a physical printer can be reused, a &lt;code&gt;StreamPrintService&lt;/code&gt; connected to a stream cannot. The underlying &lt;code&gt;StreamPrintService&lt;/code&gt; may be disposed by the print system with the &lt;a href=&quot;streamprintservice#dispose--&quot;&gt;&lt;code&gt;dispose&lt;/code&gt;&lt;/a&gt; method before returning from the &lt;a href=&quot;docprintjob#print-javax.print.Doc-javax.print.attribute.PrintRequestAttributeSet-&quot;&gt;&lt;code&gt;print&lt;/code&gt;&lt;/a&gt; method of &lt;code&gt;DocPrintJob&lt;/code&gt; so that the print system knows this printer is no longer usable. This is equivalent to a physical printer going offline - permanently. Applications may supply a null print stream to create a queryable service. It is not valid to create a PrintJob for such a stream. Implementations which allocate resources on construction should examine the stream and may wish to only allocate resources if the stream is non-null.</source>
          <target state="translated">连接到物理打印机的 &lt;code&gt;PrintService&lt;/code&gt; 可以重复使用，而连接到流的 &lt;code&gt;StreamPrintService&lt;/code&gt; 不能重复使用。在从 &lt;code&gt;DocPrintJob&lt;/code&gt; 的&lt;a href=&quot;docprintjob#print-javax.print.Doc-javax.print.attribute.PrintRequestAttributeSet-&quot;&gt; &lt;code&gt;print&lt;/code&gt; &lt;/a&gt;方法返回之前，底层的 &lt;code&gt;StreamPrintService&lt;/code&gt; 可以由打印系统使用&lt;a href=&quot;streamprintservice#dispose--&quot;&gt; &lt;code&gt;dispose&lt;/code&gt; &lt;/a&gt;方法进行处理，以使打印系统知道该打印机不再可用。这等效于物理打印机永久脱机。应用程序可以提供空打印流以创建可查询的服务。为此流创建PrintJob是无效的。在构造上分配资源的实现应检查流，并且可能希望仅在流为非null时分配资源。</target>
        </trans-unit>
        <trans-unit id="68dfcf4573839943af330771499a40761c894968" translate="yes" xml:space="preserve">
          <source>Whereas these are not (reason in parentheses):</source>
          <target state="translated">而这些都不是(原因在括号里)。</target>
        </trans-unit>
        <trans-unit id="034389c570341c477b986ed7aab5d2ac27118931" translate="yes" xml:space="preserve">
          <source>Whether &lt;code&gt;waitForIdle&lt;/code&gt; is automatically called</source>
          <target state="translated">是否自动调用 &lt;code&gt;waitForIdle&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0787c7934fdfd663c379d9463c168a4a31331bbd" translate="yes" xml:space="preserve">
          <source>Whether C++-style comments are to be recognized and skipped.</source>
          <target state="translated">是否要识别和跳过C++风格的注释。</target>
        </trans-unit>
        <trans-unit id="e0848da24388d28c1afb73d61f7a7588fee7e498" translate="yes" xml:space="preserve">
          <source>Whether C-style comments are to be recognized and skipped.</source>
          <target state="translated">是否要识别和跳过C式注释。</target>
        </trans-unit>
        <trans-unit id="3ce96c4b92120512de6ee705be9cc10faccd0e37" translate="yes" xml:space="preserve">
          <source>Whether a &lt;a href=&quot;tifftag&quot;&gt;&lt;code&gt;TIFFTag&lt;/code&gt;&lt;/a&gt; with tag number equal to &lt;code&gt;tagNumber&lt;/code&gt; is present in this &lt;code&gt;TIFFDirectory&lt;/code&gt;.</source>
          <target state="translated">是否一个&lt;a href=&quot;tifftag&quot;&gt; &lt;code&gt;TIFFTag&lt;/code&gt; &lt;/a&gt;与标签号码等于 &lt;code&gt;tagNumber&lt;/code&gt; 是存在于该 &lt;code&gt;TIFFDirectory&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="368fda18947ddfae823fba3ad12c0006e725b91a" translate="yes" xml:space="preserve">
          <source>Whether a byte buffer is direct or non-direct may be determined by invoking its &lt;a href=&quot;#isDirect()&quot;&gt;&lt;code&gt;isDirect&lt;/code&gt;&lt;/a&gt; method. This method is provided so that explicit buffer management can be done in performance-critical code.</source>
          <target state="translated">字节缓冲区是直接还是非直接缓冲区可以通过调用其&lt;a href=&quot;#isDirect()&quot;&gt; &lt;code&gt;isDirect&lt;/code&gt; &lt;/a&gt;方法来确定。提供此方法是为了可以在对性能有严格要求的代码中进行显式缓冲区管理。</target>
        </trans-unit>
        <trans-unit id="51a1385dc9a39d4da44928c4400ff21a87209713" translate="yes" xml:space="preserve">
          <source>Whether a byte buffer is direct or non-direct may be determined by invoking its &lt;a href=&quot;bytebuffer#isDirect--&quot;&gt;&lt;code&gt;isDirect&lt;/code&gt;&lt;/a&gt; method. This method is provided so that explicit buffer management can be done in performance-critical code.</source>
          <target state="translated">字节缓冲区是直接还是非直接缓冲区可以通过调用其&lt;a href=&quot;bytebuffer#isDirect--&quot;&gt; &lt;code&gt;isDirect&lt;/code&gt; &lt;/a&gt;方法来确定。提供此方法是为了可以在性能关键代码中完成显式缓冲区管理。</target>
        </trans-unit>
        <trans-unit id="76ac3d7ca9570e219636389efe4d99114c39fbb9" translate="yes" xml:space="preserve">
          <source>Whether a lock is exclusive or shared may be determined by invoking its &lt;a href=&quot;#isShared()&quot;&gt;&lt;code&gt;isShared&lt;/code&gt;&lt;/a&gt; method. Some platforms do not support shared locks, in which case a request for a shared lock is automatically converted into a request for an exclusive lock.</source>
          <target state="translated">锁是排他锁还是共享锁可以通过调用其&lt;a href=&quot;#isShared()&quot;&gt; &lt;code&gt;isShared&lt;/code&gt; &lt;/a&gt;方法来确定。某些平台不支持共享锁，在这种情况下，对共享锁的请求会自动转换为对独占锁的请求。</target>
        </trans-unit>
        <trans-unit id="059d74aa74a1f70698c412f2b1b1fb68c363877d" translate="yes" xml:space="preserve">
          <source>Whether a lock is exclusive or shared may be determined by invoking its &lt;a href=&quot;filelock#isShared--&quot;&gt;&lt;code&gt;isShared&lt;/code&gt;&lt;/a&gt; method. Some platforms do not support shared locks, in which case a request for a shared lock is automatically converted into a request for an exclusive lock.</source>
          <target state="translated">锁是排他锁还是共享锁可以通过调用其&lt;a href=&quot;filelock#isShared--&quot;&gt; &lt;code&gt;isShared&lt;/code&gt; &lt;/a&gt;方法确定。某些平台不支持共享锁，在这种情况下，对共享锁的请求会自动转换为对独占锁的请求。</target>
        </trans-unit>
        <trans-unit id="ca6533c544c3a0529e57beea5f901c658d036545" translate="yes" xml:space="preserve">
          <source>Whether a particular component is or is not defined in an instance depends upon the type of the URI being represented. An absolute URI has a scheme component. An opaque URI has a scheme, a scheme-specific part, and possibly a fragment, but has no other components. A hierarchical URI always has a path (though it may be empty) and a scheme-specific-part (which at least contains the path), and may have any of the other components. If the authority component is present and is server-based then the host component will be defined and the user-information and port components may be defined.</source>
          <target state="translated">在一个实例中是否定义了一个特定的组件,取决于所代表的URI的类型。一个绝对的URI有一个方案组件。一个不透明的URI有一个方案,一个方案特定的部分,可能还有一个片段,但没有其他组件。一个分层的URI总是有一个路径(尽管它可能是空的)和一个方案特定的部分(至少包含路径),并且可能有任何其他的组件。如果权限组件存在并且是基于服务器的,那么主机组件将被定义,用户信息和端口组件也可以被定义。</target>
        </trans-unit>
        <trans-unit id="b7b45add21d97d6f92bb3c58b9dd4adb30ed79cd" translate="yes" xml:space="preserve">
          <source>Whether a thread is a daemon thread</source>
          <target state="translated">线程是否为守护进程线程</target>
        </trans-unit>
        <trans-unit id="d404f71e4894750c15b6981c1f6ed118e11a813d" translate="yes" xml:space="preserve">
          <source>Whether a virtual machine has a console is dependent upon the underlying platform and also upon the manner in which the virtual machine is invoked. If the virtual machine is started from an interactive command line without redirecting the standard input and output streams then its console will exist and will typically be connected to the keyboard and display from which the virtual machine was launched. If the virtual machine is started automatically, for example by a background job scheduler, then it will typically not have a console.</source>
          <target state="translated">一个虚拟机是否有控制台取决于底层平台,也取决于虚拟机被调用的方式。如果虚拟机是通过交互式命令行启动的,而没有重定向标准输入和输出流,那么它的控制台就会存在,并且通常会连接到启动虚拟机的键盘和显示器。如果虚拟机是自动启动的,例如由后台作业调度程序启动,那么它通常不会有控制台。</target>
        </trans-unit>
        <trans-unit id="7b2f8d65d541d32da6ac4db35fde558abe5bba9b" translate="yes" xml:space="preserve">
          <source>Whether aliases are case sensitive is implementation dependent. In order to avoid problems, it is recommended not to use aliases in a KeyStore that only differ in case.</source>
          <target state="translated">别名是否区分大小写取决于实现。为了避免问题,建议不要在KeyStore中使用只区分大小写的别名。</target>
        </trans-unit>
        <trans-unit id="e459ddcf8add7fb4f45be0659b059f816d4f3a8a" translate="yes" xml:space="preserve">
          <source>Whether keystores are persistent, and the mechanisms used by the keystore if it is persistent, are not specified here. This allows use of a variety of techniques for protecting sensitive (e.g., private or secret) keys. Smart cards or other integrated cryptographic engines (SafeKeyper) are one option, and simpler mechanisms such as files may also be used (in a variety of formats).</source>
          <target state="translated">钥匙存储是否是持久性的,以及如果是持久性的,钥匙存储所使用的机制,在此不作规定。这就允许使用各种技术来保护敏感(如私人或秘密)密钥。智能卡或其他集成加密引擎(SafeKeyper)是一种选择,也可以使用更简单的机制,如文件(以各种格式)。</target>
        </trans-unit>
        <trans-unit id="839575dd0da2dbc62283eccad2a293850044e605" translate="yes" xml:space="preserve">
          <source>Whether line terminators are to be returned as tokens or treated as white space that merely separates tokens.</source>
          <target state="translated">行终止符是作为标记返回,还是作为仅仅分隔标记的白色空间处理。</target>
        </trans-unit>
        <trans-unit id="64009d2c9b3c4d0e007e474d4b10457e969ea24e" translate="yes" xml:space="preserve">
          <source>Whether new values can be written to the attribute.</source>
          <target state="translated">是否可以向属性写入新的值。</target>
        </trans-unit>
        <trans-unit id="b03220d01de6d75c311d805bed01816711949222" translate="yes" xml:space="preserve">
          <source>Whether or not a channel is registered with one or more selectors may be determined by invoking the &lt;a href=&quot;#isRegistered()&quot;&gt;&lt;code&gt;isRegistered&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">可以通过调用&lt;a href=&quot;#isRegistered()&quot;&gt; &lt;code&gt;isRegistered&lt;/code&gt; &lt;/a&gt;方法来确定是否向一个或多个选择器注册了通道。</target>
        </trans-unit>
        <trans-unit id="ed0c61cf2fb7a55d68d476b3cbe4799a77c242a1" translate="yes" xml:space="preserve">
          <source>Whether or not a channel is registered with one or more selectors may be determined by invoking the &lt;a href=&quot;selectablechannel#isRegistered--&quot;&gt;&lt;code&gt;isRegistered&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">可以通过调用&lt;a href=&quot;selectablechannel#isRegistered--&quot;&gt; &lt;code&gt;isRegistered&lt;/code&gt; &lt;/a&gt;方法来确定是否向一个或多个选择器注册了通道。</target>
        </trans-unit>
        <trans-unit id="0d4e0c74b1ca2cffb49ee764de91039c786dd2b9" translate="yes" xml:space="preserve">
          <source>Whether or not a file is available or may be created depends upon the underlying platform. Some platforms, in particular, allow a file to be opened for writing by only one &lt;code&gt;FileWriter&lt;/code&gt; (or other file-writing object) at a time. In such situations the constructors in this class will fail if the file involved is already open.</source>
          <target state="translated">文件是否可用或是否可以创建取决于底层平台。特别是某些平台，一次只允许一个 &lt;code&gt;FileWriter&lt;/code&gt; （或其他文件写入对象）打开一个文件进行写入。在这种情况下，如果所涉及的文件已经打开，则此类中的构造函数将失败。</target>
        </trans-unit>
        <trans-unit id="ea35fdbb197a6d4bef3ff403fa57d76ec3b52a58" translate="yes" xml:space="preserve">
          <source>Whether or not a lock actually prevents another program from accessing the content of the locked region is system-dependent and therefore unspecified. The native file-locking facilities of some systems are merely</source>
          <target state="translated">锁定是否真的能阻止另一个程序访问被锁定的区域的内容,是取决于系统的,因此没有说明。一些系统的原生文件锁定设施仅仅是</target>
        </trans-unit>
        <trans-unit id="5484541c29643b9a5f36af7eafe3c332aef64933" translate="yes" xml:space="preserve">
          <source>Whether or not a read-write lock will improve performance over the use of a mutual exclusion lock depends on the frequency that the data is read compared to being modified, the duration of the read and write operations, and the contention for the data - that is, the number of threads that will try to read or write the data at the same time. For example, a collection that is initially populated with data and thereafter infrequently modified, while being frequently searched (such as a directory of some kind) is an ideal candidate for the use of a read-write lock. However, if updates become frequent then the data spends most of its time being exclusively locked and there is little, if any increase in concurrency. Further, if the read operations are too short the overhead of the read-write lock implementation (which is inherently more complex than a mutual exclusion lock) can dominate the execution cost, particularly as many read-write lock implementations still serialize all threads through a small section of code. Ultimately, only profiling and measurement will establish whether the use of a read-write lock is suitable for your application.</source>
          <target state="translated">读写锁是否会比使用互斥锁提高性能,取决于数据被读取与被修改的频率,读写操作的持续时间,以及对数据的争夺--即同时尝试读取或写入数据的线程数量。例如,一个最初被数据填充,此后不经常被修改,同时又经常被搜索的集合(如某种目录)是使用读写锁的理想候选者。然而,如果更新变得频繁,那么数据的大部分时间都被专门锁定,并发性几乎没有增加,甚至没有增加。此外,如果读操作时间太短,读写锁实现的开销(本质上比互斥锁更复杂)会支配执行成本,特别是许多读写锁实现仍然通过一小段代码将所有线程序列化。最终,只有通过剖析和测量才能确定使用读写锁是否适合你的应用。</target>
        </trans-unit>
        <trans-unit id="ab8f019130320385026e5dab14b4180991ab8cbe" translate="yes" xml:space="preserve">
          <source>Whether or not a selection operation blocks to wait for one or more channels to become ready, and if so for how long, is the only essential difference between the three selection methods.</source>
          <target state="translated">一个选择操作是否阻止等待一个或多个通道准备就绪,如果是,等待多长时间,是三种选择方法唯一的本质区别。</target>
        </trans-unit>
        <trans-unit id="41ee46a746e75b2c44835c6bb604f840669e2531" translate="yes" xml:space="preserve">
          <source>Whether or not a thread writing bytes to a pipe will block until another thread reads those bytes, or some previously-written bytes, from the pipe is system-dependent and therefore unspecified. Many pipe implementations will buffer up to a certain number of bytes between the sink and source channels, but such buffering should not be assumed.</source>
          <target state="translated">向管道写入字节的线程是否会阻塞,直到另一个线程从管道中读取这些字节或一些先前写入的字节,这是系统依赖性的,因此没有说明。许多管道实现会在汇流通道和源通道之间缓冲到一定数量的字节,但不应该假定这种缓冲。</target>
        </trans-unit>
        <trans-unit id="f1753321a954e7b513350ab852758250afb77bcc" translate="yes" xml:space="preserve">
          <source>Whether or not the border has rounded corners.</source>
          <target state="translated">边框是否有圆角。</target>
        </trans-unit>
        <trans-unit id="fefaa51af10ff6b34610a73fe360a147bd71b1e4" translate="yes" xml:space="preserve">
          <source>Whether or not the drawing buffer has been recently restored from a lost state.</source>
          <target state="translated">绘图缓冲区最近是否已从丢失状态恢复。</target>
        </trans-unit>
        <trans-unit id="4d74f9e48a7c981d657e06b3f4e62aa762abfdf7" translate="yes" xml:space="preserve">
          <source>Whether or not the drawing buffer was lost since the last call to &lt;code&gt;getDrawGraphics&lt;/code&gt;.</source>
          <target state="translated">自从上次调用 &lt;code&gt;getDrawGraphics&lt;/code&gt; 以来，绘图缓冲区是否丢失。</target>
        </trans-unit>
        <trans-unit id="b46af6682380966e3f1a4318992d86f116b4966b" translate="yes" xml:space="preserve">
          <source>Whether or not the drawing buffer was restored since the last call to &lt;code&gt;getDrawGraphics&lt;/code&gt;.</source>
          <target state="translated">自上次调用 &lt;code&gt;getDrawGraphics&lt;/code&gt; 以来，是否已还原绘图缓冲区。</target>
        </trans-unit>
        <trans-unit id="dfcdb3967632f01437df753633766fd60adb3757" translate="yes" xml:space="preserve">
          <source>Whether or not the lead anchor notification is enabled.</source>
          <target state="translated">是否启用引导锚通知。</target>
        </trans-unit>
        <trans-unit id="b67aae029276f7596e2d6a2c6bdefef7f78062c8" translate="yes" xml:space="preserve">
          <source>Whether or not the returned key is trusted and the mechanisms used to determine that is implementation-specific.</source>
          <target state="translated">返回的密钥是否可信,以及用于确定的机制是具体实施的。</target>
        </trans-unit>
        <trans-unit id="882147ddaf8db0c13715bcfc2446b83df5e1174d" translate="yes" xml:space="preserve">
          <source>Whether or not the root component of this path starts with the root component of the given path is file system specific. If this path does not have a root component and the given path has a root component then this path does not start with the given path.</source>
          <target state="translated">这个路径的根组件是否从给定路径的根组件开始,是根据文件系统而定的,如果这个路径没有根组件,而给定路径有根组件,那么这个路径就不会从给定路径开始。如果这个路径没有根目录,而给定的路径有根目录,那么这个路径就不从给定的路径开始。</target>
        </trans-unit>
        <trans-unit id="5561b885c61970439f8e8ab1f7452ebbd54f6012" translate="yes" xml:space="preserve">
          <source>Whether or not the views are continuously redisplayed while resizing.</source>
          <target state="translated">在调整大小时是否连续重新显示视图。</target>
        </trans-unit>
        <trans-unit id="8d8dadabe9f784b22272f65c7af34baa4ecf3fe7" translate="yes" xml:space="preserve">
          <source>Whether or not this is equal to the argument.</source>
          <target state="translated">是否等于论证。</target>
        </trans-unit>
        <trans-unit id="2c8782dc43c139a892cf9eca05fb5d76826e3adf" translate="yes" xml:space="preserve">
          <source>Whether or not two path are equal depends on the file system implementation. In some cases the paths are compared without regard to case, and others are case sensitive. This method does not access the file system and the file is not required to exist. Where required, the &lt;a href=&quot;files#isSameFile(java.nio.file.Path,java.nio.file.Path)&quot;&gt;&lt;code&gt;isSameFile&lt;/code&gt;&lt;/a&gt; method may be used to check if two paths locate the same file.</source>
          <target state="translated">两个路径是否相等取决于文件系统的实现。在某些情况下，比较路径时不考虑大小写，其他情况下则区分大小写。此方法不访问文件系统，并且不需要文件存在。如果需要，可以使用&lt;a href=&quot;files#isSameFile(java.nio.file.Path,java.nio.file.Path)&quot;&gt; &lt;code&gt;isSameFile&lt;/code&gt; &lt;/a&gt;方法检查两个路径是否位于同一文件中。</target>
        </trans-unit>
        <trans-unit id="8370dbb2c98105665a87fe7a4451e4d08277efed" translate="yes" xml:space="preserve">
          <source>Whether or not two path are equal depends on the file system implementation. In some cases the paths are compared without regard to case, and others are case sensitive. This method does not access the file system and the file is not required to exist. Where required, the &lt;a href=&quot;files#isSameFile-java.nio.file.Path-java.nio.file.Path-&quot;&gt;&lt;code&gt;isSameFile&lt;/code&gt;&lt;/a&gt; method may be used to check if two paths locate the same file.</source>
          <target state="translated">两个路径是否相等取决于文件系统的实现。在某些情况下，比较路径时不考虑大小写，其他情况下则区分大小写。此方法不访问文件系统，并且不需要文件存在。在需要的地方，可以使用&lt;a href=&quot;files#isSameFile-java.nio.file.Path-java.nio.file.Path-&quot;&gt; &lt;code&gt;isSameFile&lt;/code&gt; &lt;/a&gt;方法检查两个路径是否位于同一文件中。</target>
        </trans-unit>
        <trans-unit id="8284d3a1a8d812ad6669b46283821c095c0da402" translate="yes" xml:space="preserve">
          <source>Whether the characters of identifiers are converted to lowercase.</source>
          <target state="translated">是否将标识符的字符转换为小写。</target>
        </trans-unit>
        <trans-unit id="8cb35ed334e6abf3cc5d46cfafbdff505f970f2b" translate="yes" xml:space="preserve">
          <source>Whether the checks for Java language access control can be suppressed (and thus, whether access can be enabled) depends on whether the reflected object corresponds to a member in an exported or open package (see &lt;a href=&quot;#setAccessible(boolean)&quot;&gt;&lt;code&gt;setAccessible(boolean)&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">是否可以抑制对Java语言访问控制的检查（因此是否可以启用访问）取决于所反映的对象是否对应于已导出或打开的包中的成员（请参见&lt;a href=&quot;#setAccessible(boolean)&quot;&gt; &lt;code&gt;setAccessible(boolean)&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="abed7ebf656d855109885e2ad219cda0e430ff8f" translate="yes" xml:space="preserve">
          <source>Whether the directory is traversable or not.</source>
          <target state="translated">目录是否可以遍历。</target>
        </trans-unit>
        <trans-unit id="9f7b655899be35706a060ba063ac17985c822863" translate="yes" xml:space="preserve">
          <source>Whether the directory is traversable or not. This might be useful, for example, if you want a directory to represent a compound document and don't want the user to descend into it.</source>
          <target state="translated">该目录是否可遍历。这可能很有用,例如,如果你想让一个目录代表一个复合文档,而不希望用户进入它。</target>
        </trans-unit>
        <trans-unit id="72bdf44965cf1882a7b82e577ba831bb4aa3aad8" translate="yes" xml:space="preserve">
          <source>Whether the effect of sheet collation is achieved by placing copies of a document in multiple output bins or in the same output bin with implementation defined document separation is implementation dependent. Also whether it is achieved by making multiple passes over the job or by using an output sorter is implementation dependent.</source>
          <target state="translated">单张整理的效果是通过将文档的副本放在多个输出仓中,还是放在同一个输出仓中,并采用执行定义的文档分隔来实现,这取决于执行情况。另外,是通过在作业上进行多次传递还是使用输出分拣机来实现,也取决于实施情况。</target>
        </trans-unit>
        <trans-unit id="80415a2402a1eeb4d1614afdc0790cc2cd751eb2" translate="yes" xml:space="preserve">
          <source>Whether the field type is integral.</source>
          <target state="translated">字段类型是否为积分。</target>
        </trans-unit>
        <trans-unit id="0d0d9b917bd4457293707b233fdfaf38f800ca2f" translate="yes" xml:space="preserve">
          <source>Whether the given file is accepted by this filter.</source>
          <target state="translated">该过滤器是否接受给定文件。</target>
        </trans-unit>
        <trans-unit id="0b221a5fcef637ecf18d19b895618107e0ec7d34" translate="yes" xml:space="preserve">
          <source>Whether the progress bar is horizontal or vertical.</source>
          <target state="translated">进度条是水平还是垂直。</target>
        </trans-unit>
        <trans-unit id="a6d6a865c13d64eec6f0217eba676663f0999299" translate="yes" xml:space="preserve">
          <source>Whether the progress bar is horizontal or vertical. The default is &lt;code&gt;HORIZONTAL&lt;/code&gt;.</source>
          <target state="translated">进度条是水平还是垂直。默认值为 &lt;code&gt;HORIZONTAL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d07e8763f02114da7e0c71037a504961880c1abb" translate="yes" xml:space="preserve">
          <source>Whether the slider is horizontal or vertical The default is horizontal.</source>
          <target state="translated">滑块是水平还是垂直,默认为水平。</target>
        </trans-unit>
        <trans-unit id="b500b42f712219c24a8bd54914f1fa1b4e445284" translate="yes" xml:space="preserve">
          <source>Whether the value of the attribute can be read.</source>
          <target state="translated">是否可以读取该属性的值。</target>
        </trans-unit>
        <trans-unit id="d7db98311d27050f8bbb866412a5ea00983c801f" translate="yes" xml:space="preserve">
          <source>Whether to display a border around the progress bar.</source>
          <target state="translated">是否在进度条周围显示边框。</target>
        </trans-unit>
        <trans-unit id="0d7eb02de3d8787df6eadd74e0b934899bf8467f" translate="yes" xml:space="preserve">
          <source>Whether to display a border around the progress bar. The default is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">是否在进度条周围显示边框。默认值为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7bb449420de50b1f70b9cf8aa6735bcb426d5e7f" translate="yes" xml:space="preserve">
          <source>Whether to display a string of text on the progress bar.</source>
          <target state="translated">是否在进度条上显示一串文字。</target>
        </trans-unit>
        <trans-unit id="6ce38cd557d077996b81c259fa55fc8d873bb920" translate="yes" xml:space="preserve">
          <source>Whether to display a string of text on the progress bar. The default is &lt;code&gt;false&lt;/code&gt;. Setting this to &lt;code&gt;true&lt;/code&gt; causes a textual display of the progress to be rendered on the progress bar. If the &lt;code&gt;progressString&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, the percentage of completion is displayed on the progress bar. Otherwise, the &lt;code&gt;progressString&lt;/code&gt; is rendered on the progress bar.</source>
          <target state="translated">是否在进度条上显示文本字符串。默认值为 &lt;code&gt;false&lt;/code&gt; 。将此设置为 &lt;code&gt;true&lt;/code&gt; 会导致在进度条上呈现进度的文本显示。如果 &lt;code&gt;progressString&lt;/code&gt; 为 &lt;code&gt;null&lt;/code&gt; ，则完成百分比将显示在进度条上。否则， &lt;code&gt;progressString&lt;/code&gt; 呈现在进度条上。</target>
        </trans-unit>
        <trans-unit id="49449561f235eb64ebabd8dfba321eb0bf01fd39" translate="yes" xml:space="preserve">
          <source>Whether to read fields of unrecognized tags</source>
          <target state="translated">是否读取未识别标签的字段。</target>
        </trans-unit>
        <trans-unit id="610c7400d727b3d0294243a02c10a7e75f931042" translate="yes" xml:space="preserve">
          <source>Which is equivalent to:</source>
          <target state="translated">这就相当于:</target>
        </trans-unit>
        <trans-unit id="b31b01303e594ceee1ff860c123b19192ba02c04" translate="yes" xml:space="preserve">
          <source>While &lt;a href=&quot;../java.base/java/lang/invoke/package-summary&quot;&gt;&lt;code&gt;java.lang.invoke&lt;/code&gt;&lt;/a&gt; provides a low level API for dynamic linking of &lt;code&gt;invokedynamic&lt;/code&gt; call sites, it does not provide a way to express higher level operations on objects, nor methods that implement them. These operations are the usual ones in object-oriented environments: property access, access of elements of collections, invocation of methods and constructors (potentially with multiple dispatch, e.g. link- and run-time equivalents of Java overloaded method resolution). These are all functions that are normally desired in a language on the JVM. If a language is statically typed and its type system matches that of the JVM, it can accomplish this with use of the usual invocation, field access, etc. instructions (e.g. &lt;code&gt;invokevirtual&lt;/code&gt;, &lt;code&gt;getfield&lt;/code&gt;). However, if the language is dynamic (hence, types of some expressions are not known until evaluated at run time), or its object model or type system don't match closely that of the JVM, then it should use &lt;code&gt;invokedynamic&lt;/code&gt; call sites instead and let Dynalink manage them.</source>
          <target state="translated">尽管&lt;a href=&quot;../java.base/java/lang/invoke/package-summary&quot;&gt; &lt;code&gt;java.lang.invoke&lt;/code&gt; &lt;/a&gt;提供了用于动态链接 &lt;code&gt;invokedynamic&lt;/code&gt; 调用站点的低级API ，但它没有提供表达对象上的高级操作的方法，也没有提供实现它们的方法的方法。这些操作是面向对象环境中的常见操作：属性访问，集合元素的访问，方法和构造函数的调用（可能具有多个分派，例如Java重载方法解析的链接和运行时等效项）。这些都是JVM上的一种语言通常需要的功能。如果一种语言是静态类型的，并且其类型系统与JVM的类型系统匹配，则可以使用通常的调用，字段访问等指令（例如 &lt;code&gt;invokevirtual&lt;/code&gt; ， &lt;code&gt;getfield&lt;/code&gt; )来实现此目的。）。但是，如果语言是动态的（因此，某些表达式的类型直到运行时才知道），或者其对象模型或类型系统与JVM的匹配程度不高，则应使用 &lt;code&gt;invokedynamic&lt;/code&gt; 调用站点来代替，让Dynalink管理它们。</target>
        </trans-unit>
        <trans-unit id="2f2f17106f12b2db4361609c9dfa05eb46f32c85" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;CompositeView&lt;/code&gt; does not impose a layout policy on its child &lt;code&gt;View&lt;/code&gt;s, it does allow for inseting the child &lt;code&gt;View&lt;/code&gt;s it will contain. The insets can be set by either &lt;a href=&quot;#setInsets(short,short,short,short)&quot;&gt;&lt;code&gt;setInsets(short, short, short, short)&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#setParagraphInsets(javax.swing.text.AttributeSet)&quot;&gt;&lt;code&gt;setParagraphInsets(javax.swing.text.AttributeSet)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">虽然 &lt;code&gt;CompositeView&lt;/code&gt; 并未对其子 &lt;code&gt;View&lt;/code&gt; 强加布局策略，但它允许插入将包含的子 &lt;code&gt;View&lt;/code&gt; 。可以通过&lt;a href=&quot;#setInsets(short,short,short,short)&quot;&gt; &lt;code&gt;setInsets(short, short, short, short)&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#setParagraphInsets(javax.swing.text.AttributeSet)&quot;&gt; &lt;code&gt;setParagraphInsets(javax.swing.text.AttributeSet)&lt;/code&gt; &lt;/a&gt;来设置插图。</target>
        </trans-unit>
        <trans-unit id="1c42976582ea88cec97c24e4c0d10841777ac466" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;Deque&lt;/code&gt; implementations are not strictly required to prohibit the insertion of null elements, they are strongly encouraged to do so. Users of any &lt;code&gt;Deque&lt;/code&gt; implementations that do allow null elements are strongly encouraged</source>
          <target state="translated">尽管严格不要求 &lt;code&gt;Deque&lt;/code&gt; 实现禁止插入null元素，但是强烈建议这样做。强烈建议使用任何允许空元素的 &lt;code&gt;Deque&lt;/code&gt; 实现的用户</target>
        </trans-unit>
        <trans-unit id="fb58b702756ba42a1d313a2e0f860c7578277589" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;NamedOperation&lt;/code&gt; can be constructed directly, it is often convenient to use the &lt;a href=&quot;operation#named(java.lang.Object)&quot;&gt;&lt;code&gt;Operation.named(Object)&lt;/code&gt;&lt;/a&gt; factory method instead, e.g.:</source>
          <target state="translated">尽管可以直接构造 &lt;code&gt;NamedOperation&lt;/code&gt; ，但通常使用&lt;a href=&quot;operation#named(java.lang.Object)&quot;&gt; &lt;code&gt;Operation.named(Object)&lt;/code&gt; &lt;/a&gt;工厂方法比较方便，例如：</target>
        </trans-unit>
        <trans-unit id="a5eb5618aa0f45c146e1471d0e208b60c8075087" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;NamespaceOperation&lt;/code&gt; can be constructed directly, it is often convenient to use the &lt;a href=&quot;operation#withNamespace(jdk.dynalink.Namespace)&quot;&gt;&lt;code&gt;Operation.withNamespace(Namespace)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;operation#withNamespaces(jdk.dynalink.Namespace...)&quot;&gt;&lt;code&gt;Operation.withNamespaces(Namespace...)&lt;/code&gt;&lt;/a&gt; factory methods instead, e.g.:</source>
          <target state="translated">尽管可以直接构造 &lt;code&gt;NamespaceOperation&lt;/code&gt; ，但通常使用&lt;a href=&quot;operation#withNamespace(jdk.dynalink.Namespace)&quot;&gt; &lt;code&gt;Operation.withNamespace(Namespace)&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;operation#withNamespaces(jdk.dynalink.Namespace...)&quot;&gt; &lt;code&gt;Operation.withNamespaces(Namespace...)&lt;/code&gt; &lt;/a&gt;工厂方法通常比较方便，例如：</target>
        </trans-unit>
        <trans-unit id="3d6ef8f821513dcce4a530375fb519e3029c0687" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;TreePath&lt;/code&gt; is serializable, a &lt;code&gt;
 NotSerializableException&lt;/code&gt; is thrown if any elements of the path are not serializable.</source>
          <target state="translated">虽然 &lt;code&gt;TreePath&lt;/code&gt; 可序列化， &lt;code&gt; NotSerializableException&lt;/code&gt; 如果路径的任何元素不可序列化，则抛出NotSerializableException。</target>
        </trans-unit>
        <trans-unit id="51c173ac8703a05aa36fea05d64c73f4930ea483" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;dropWhile()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, since the operation is constrained to return not just any valid prefix, but the longest prefix of elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;#generate(java.util.function.DoubleSupplier)&quot;&gt;&lt;code&gt;generate(DoubleSupplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered()&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;dropWhile()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;dropWhile()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;basestream#sequential()&quot;&gt;&lt;code&gt;BaseStream.sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">虽然 &lt;code&gt;dropWhile()&lt;/code&gt; 通常在顺序流管道上是便宜的操作，但是在有序并行管道上它可能会非常昂贵，因为该操作被约束为不仅返回任何有效前缀，而且返回遇到顺序中元素的最长前缀。如果情况的语义允许，则使用无序流源（例如&lt;a href=&quot;#generate(java.util.function.DoubleSupplier)&quot;&gt; &lt;code&gt;generate(DoubleSupplier)&lt;/code&gt; &lt;/a&gt;）或使用&lt;a href=&quot;basestream#unordered()&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; &lt;/a&gt;除去排序约束可能会导致并行管道中 &lt;code&gt;dropWhile()&lt;/code&gt; 的显着加速。如果需要与遇到顺序保持一致，并且在并行管道中使用 &lt;code&gt;dropWhile()&lt;/code&gt; 遇到性能低下或内存使用不足的情况，请使用以下命令切换到顺序执行&lt;a href=&quot;basestream#sequential()&quot;&gt; &lt;code&gt;BaseStream.sequential()&lt;/code&gt; &lt;/a&gt;可以提高性能。</target>
        </trans-unit>
        <trans-unit id="dd08eb3b81d66f20546d1029c826ea0fbe16bd34" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;dropWhile()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, since the operation is constrained to return not just any valid prefix, but the longest prefix of elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;#generate(java.util.function.IntSupplier)&quot;&gt;&lt;code&gt;generate(IntSupplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered()&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;dropWhile()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;dropWhile()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;basestream#sequential()&quot;&gt;&lt;code&gt;BaseStream.sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">虽然 &lt;code&gt;dropWhile()&lt;/code&gt; 通常在顺序流管道上是便宜的操作，但是在有序并行管道上它可能会非常昂贵，因为该操作被约束为不仅返回任何有效前缀，而且返回遇到顺序中元素的最长前缀。如果情况的语义允许，则使用无序流源（例如&lt;a href=&quot;#generate(java.util.function.IntSupplier)&quot;&gt; &lt;code&gt;generate(IntSupplier)&lt;/code&gt; &lt;/a&gt;）或使用&lt;a href=&quot;basestream#unordered()&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; &lt;/a&gt;删除排序约束可能会导致并行管道中 &lt;code&gt;dropWhile()&lt;/code&gt; 的显着加速。如果需要与遇到顺序保持一致，并且在并行管道中使用 &lt;code&gt;dropWhile()&lt;/code&gt; 遇到性能低下或内存使用不足的情况，请使用以下命令切换到顺序执行&lt;a href=&quot;basestream#sequential()&quot;&gt; &lt;code&gt;BaseStream.sequential()&lt;/code&gt; &lt;/a&gt;可以提高性能。</target>
        </trans-unit>
        <trans-unit id="58a60decffcb60cd8818f4e94cb70dfd3ab19008" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;dropWhile()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, since the operation is constrained to return not just any valid prefix, but the longest prefix of elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;#generate(java.util.function.LongSupplier)&quot;&gt;&lt;code&gt;generate(LongSupplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered()&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;dropWhile()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;dropWhile()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;basestream#sequential()&quot;&gt;&lt;code&gt;BaseStream.sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">虽然 &lt;code&gt;dropWhile()&lt;/code&gt; 通常在顺序流管道上是便宜的操作，但是在有序并行管道上它可能会非常昂贵，因为该操作被约束为不仅返回任何有效前缀，而且返回遇到顺序中元素的最长前缀。如果情况的语义允许，则使用无序流源（例如&lt;a href=&quot;#generate(java.util.function.LongSupplier)&quot;&gt; &lt;code&gt;generate(LongSupplier)&lt;/code&gt; &lt;/a&gt;）或使用&lt;a href=&quot;basestream#unordered()&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; &lt;/a&gt;删除排序约束可能会导致并行管道中 &lt;code&gt;dropWhile()&lt;/code&gt; 的显着加速。如果需要与遇到顺序保持一致，并且在并行管道中使用 &lt;code&gt;dropWhile()&lt;/code&gt; 遇到性能低下或内存使用不足的情况，请使用以下命令切换到顺序执行&lt;a href=&quot;basestream#sequential()&quot;&gt; &lt;code&gt;BaseStream.sequential()&lt;/code&gt; &lt;/a&gt;可以提高性能。</target>
        </trans-unit>
        <trans-unit id="15a29b609ce06935cf71396d9bc3de52f946081d" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;dropWhile()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, since the operation is constrained to return not just any valid prefix, but the longest prefix of elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;#generate(java.util.function.Supplier)&quot;&gt;&lt;code&gt;generate(Supplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered()&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;dropWhile()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;dropWhile()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;basestream#sequential()&quot;&gt;&lt;code&gt;BaseStream.sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">虽然 &lt;code&gt;dropWhile()&lt;/code&gt; 通常在顺序流管道上是便宜的操作，但是在有序并行管道上它可能会非常昂贵，因为该操作被约束为不仅返回任何有效前缀，而且返回遇到顺序中元素的最长前缀。如果情况的语义允许，则使用无序流源（例如&lt;a href=&quot;#generate(java.util.function.Supplier)&quot;&gt; &lt;code&gt;generate(Supplier)&lt;/code&gt; &lt;/a&gt;）或使用&lt;a href=&quot;basestream#unordered()&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; &lt;/a&gt;删除排序约束可能会导致并行管道中 &lt;code&gt;dropWhile()&lt;/code&gt; 的显着加速。如果需要与遇到顺序保持一致，并且在并行管道中使用 &lt;code&gt;dropWhile()&lt;/code&gt; 遇到性能低下或内存使用不足的情况，请使用以下命令切换到顺序执行&lt;a href=&quot;basestream#sequential()&quot;&gt; &lt;code&gt;BaseStream.sequential()&lt;/code&gt; &lt;/a&gt;可以提高性能。</target>
        </trans-unit>
        <trans-unit id="f8bebbe990bf762b2089ef58b873ffcb3559acbd" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;limit()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, especially for large values of &lt;code&gt;maxSize&lt;/code&gt;, since &lt;code&gt;limit(n)&lt;/code&gt; is constrained to return not just any &lt;em&gt;n&lt;/em&gt; elements, but the &lt;em&gt;first n&lt;/em&gt; elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;#generate(java.util.function.DoubleSupplier)&quot;&gt;&lt;code&gt;generate(DoubleSupplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered()&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;limit()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;limit()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;basestream#sequential()&quot;&gt;&lt;code&gt;BaseStream.sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">虽然 &lt;code&gt;limit()&lt;/code&gt; 通常在顺序流管道上是便宜的操作，但在有序并行管道上它可能会非常昂贵，尤其是对于 &lt;code&gt;maxSize&lt;/code&gt; 大的情况，因为 &lt;code&gt;limit(n)&lt;/code&gt; 不仅要返回任何&lt;em&gt;n个&lt;/em&gt;元素，而且还必须返回&lt;em&gt;第一个n&lt;/em&gt;&lt;em&gt;个&lt;/em&gt;元素遇到顺序中的元素。使用无序流源（例如&lt;a href=&quot;#generate(java.util.function.DoubleSupplier)&quot;&gt; &lt;code&gt;generate(DoubleSupplier)&lt;/code&gt; &lt;/a&gt;）或使用&lt;a href=&quot;basestream#unordered()&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; &lt;/a&gt;删除排序约束可能会导致 &lt;code&gt;limit()&lt;/code&gt; 的明显加速。如果您的情况的语义允许，请在并行管道中使用。如果需要与遇到顺序保持一致，并且您在并行管道中使用 &lt;code&gt;limit()&lt;/code&gt; 遇到性能低下或内存使用率不足的情况，则切换为使用&lt;a href=&quot;basestream#sequential()&quot;&gt; &lt;code&gt;BaseStream.sequential()&lt;/code&gt; &lt;/a&gt;顺序执行可能会提高性能。</target>
        </trans-unit>
        <trans-unit id="fae011e82778ef6bc326d638878e4e4eb7c86dc3" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;limit()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, especially for large values of &lt;code&gt;maxSize&lt;/code&gt;, since &lt;code&gt;limit(n)&lt;/code&gt; is constrained to return not just any &lt;em&gt;n&lt;/em&gt; elements, but the &lt;em&gt;first n&lt;/em&gt; elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;#generate(java.util.function.IntSupplier)&quot;&gt;&lt;code&gt;generate(IntSupplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered()&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;limit()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;limit()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;basestream#sequential()&quot;&gt;&lt;code&gt;BaseStream.sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">虽然 &lt;code&gt;limit()&lt;/code&gt; 在顺序流管道上通常是便宜的操作，但在有序并行管道上可能会非常昂贵，尤其是对于 &lt;code&gt;maxSize&lt;/code&gt; 大的值，因为 &lt;code&gt;limit(n)&lt;/code&gt; 不仅要返回任何&lt;em&gt;n个&lt;/em&gt;元素，而且要返回&lt;em&gt;第一个n&lt;/em&gt;&lt;em&gt;个&lt;/em&gt;元素遇到顺序中的元素。使用无序流源（例如&lt;a href=&quot;#generate(java.util.function.IntSupplier)&quot;&gt; &lt;code&gt;generate(IntSupplier)&lt;/code&gt; &lt;/a&gt;）或使用&lt;a href=&quot;basestream#unordered()&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; &lt;/a&gt;删除排序约束可能会导致 &lt;code&gt;limit()&lt;/code&gt; 的显着加速。如果您的情况的语义允许，请在并行管道中使用。如果需要与遇到顺序保持一致，并且您在并行管道中使用 &lt;code&gt;limit()&lt;/code&gt; 遇到性能低下或内存使用率不足的情况，则切换为使用&lt;a href=&quot;basestream#sequential()&quot;&gt; &lt;code&gt;BaseStream.sequential()&lt;/code&gt; &lt;/a&gt;顺序执行可能会提高性能。</target>
        </trans-unit>
        <trans-unit id="52357540a609522f143b04a6d7f5344f0cb8965b" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;limit()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, especially for large values of &lt;code&gt;maxSize&lt;/code&gt;, since &lt;code&gt;limit(n)&lt;/code&gt; is constrained to return not just any &lt;em&gt;n&lt;/em&gt; elements, but the &lt;em&gt;first n&lt;/em&gt; elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;#generate(java.util.function.LongSupplier)&quot;&gt;&lt;code&gt;generate(LongSupplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered()&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;limit()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;limit()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;basestream#sequential()&quot;&gt;&lt;code&gt;BaseStream.sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">虽然 &lt;code&gt;limit()&lt;/code&gt; 在顺序流管道上通常是便宜的操作，但在有序并行管道上可能会非常昂贵，尤其是对于 &lt;code&gt;maxSize&lt;/code&gt; 大的值，因为 &lt;code&gt;limit(n)&lt;/code&gt; 不仅要返回任何&lt;em&gt;n个&lt;/em&gt;元素，而且要返回&lt;em&gt;第一个n&lt;/em&gt;&lt;em&gt;个&lt;/em&gt;元素遇到顺序中的元素。使用无序流源（例如&lt;a href=&quot;#generate(java.util.function.LongSupplier)&quot;&gt; &lt;code&gt;generate(LongSupplier)&lt;/code&gt; &lt;/a&gt;）或使用&lt;a href=&quot;basestream#unordered()&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; &lt;/a&gt;删除排序约束可能会导致 &lt;code&gt;limit()&lt;/code&gt; 的明显加速。如果您的情况的语义允许，请在并行管道中使用。如果需要与遇到顺序保持一致，并且您在并行管道中使用 &lt;code&gt;limit()&lt;/code&gt; 遇到性能低下或内存使用率不足的情况，则切换为使用&lt;a href=&quot;basestream#sequential()&quot;&gt; &lt;code&gt;BaseStream.sequential()&lt;/code&gt; &lt;/a&gt;顺序执行可能会提高性能。</target>
        </trans-unit>
        <trans-unit id="5292e16f7d0f56673e81e44acea4610d6162687f" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;limit()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, especially for large values of &lt;code&gt;maxSize&lt;/code&gt;, since &lt;code&gt;limit(n)&lt;/code&gt; is constrained to return not just any &lt;em&gt;n&lt;/em&gt; elements, but the &lt;em&gt;first n&lt;/em&gt; elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;#generate(java.util.function.Supplier)&quot;&gt;&lt;code&gt;generate(Supplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered()&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;limit()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;limit()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;basestream#sequential()&quot;&gt;&lt;code&gt;BaseStream.sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">虽然 &lt;code&gt;limit()&lt;/code&gt; 在顺序流管道上通常是便宜的操作，但在有序并行管道上可能会非常昂贵，尤其是对于 &lt;code&gt;maxSize&lt;/code&gt; 大的值，因为 &lt;code&gt;limit(n)&lt;/code&gt; 不仅要返回任何&lt;em&gt;n个&lt;/em&gt;元素，而且要返回&lt;em&gt;第一个n&lt;/em&gt;&lt;em&gt;个&lt;/em&gt;元素遇到顺序中的元素。使用无序流源（例如&lt;a href=&quot;#generate(java.util.function.Supplier)&quot;&gt; &lt;code&gt;generate(Supplier)&lt;/code&gt; &lt;/a&gt;）或使用&lt;a href=&quot;basestream#unordered()&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; &lt;/a&gt;删除排序约束可能会导致 &lt;code&gt;limit()&lt;/code&gt; 的明显加速。如果您的情况的语义允许，请在并行管道中使用。如果需要与遇到顺序保持一致，并且您在并行管道中使用 &lt;code&gt;limit()&lt;/code&gt; 遇到性能低下或内存使用率不足的情况，则切换为使用&lt;a href=&quot;basestream#sequential()&quot;&gt; &lt;code&gt;BaseStream.sequential()&lt;/code&gt; &lt;/a&gt;顺序执行可能会提高性能。</target>
        </trans-unit>
        <trans-unit id="c116ddf414b394a7666553a5a6b566a1451776ab" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;limit()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, especially for large values of &lt;code&gt;maxSize&lt;/code&gt;, since &lt;code&gt;limit(n)&lt;/code&gt; is constrained to return not just any &lt;em&gt;n&lt;/em&gt; elements, but the &lt;em&gt;first n&lt;/em&gt; elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;doublestream#generate-java.util.function.DoubleSupplier-&quot;&gt;&lt;code&gt;generate(DoubleSupplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered--&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;limit()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;limit()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;doublestream#sequential--&quot;&gt;&lt;code&gt;sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">虽然 &lt;code&gt;limit()&lt;/code&gt; 通常在顺序流管道上是便宜的操作，但在有序并行管道上可能会非常昂贵，尤其是对于 &lt;code&gt;maxSize&lt;/code&gt; 大的情况，因为 &lt;code&gt;limit(n)&lt;/code&gt; 不仅要返回任何&lt;em&gt;n个&lt;/em&gt;元素，而且要返回&lt;em&gt;前n &lt;/em&gt;&lt;em&gt;个&lt;/em&gt;元素遇到顺序中的元素。使用无序流源（例如&lt;a href=&quot;doublestream#generate-java.util.function.DoubleSupplier-&quot;&gt; &lt;code&gt;generate(DoubleSupplier)&lt;/code&gt; &lt;/a&gt;）或使用&lt;a href=&quot;basestream#unordered--&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; &lt;/a&gt;删除排序约束可能会导致 &lt;code&gt;limit()&lt;/code&gt; 的大幅加速如果情况允许，请在并行管道中使用。如果需要与遇到顺序保持一致，并且在并行管道中使用 &lt;code&gt;limit()&lt;/code&gt; 遇到性能低下或内存使用率不足的情况，则切换为使用&lt;a href=&quot;doublestream#sequential--&quot;&gt; &lt;code&gt;sequential()&lt;/code&gt; &lt;/a&gt;顺序执行可能会提高性能。</target>
        </trans-unit>
        <trans-unit id="07ed1f5d7e24e0c78296347da906a9d60feefd38" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;limit()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, especially for large values of &lt;code&gt;maxSize&lt;/code&gt;, since &lt;code&gt;limit(n)&lt;/code&gt; is constrained to return not just any &lt;em&gt;n&lt;/em&gt; elements, but the &lt;em&gt;first n&lt;/em&gt; elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;intstream#generate-java.util.function.IntSupplier-&quot;&gt;&lt;code&gt;generate(IntSupplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered--&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;limit()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;limit()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;intstream#sequential--&quot;&gt;&lt;code&gt;sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">虽然 &lt;code&gt;limit()&lt;/code&gt; 通常在顺序流管道上是便宜的操作，但在有序并行管道上可能会非常昂贵，尤其是对于 &lt;code&gt;maxSize&lt;/code&gt; 大的情况，因为 &lt;code&gt;limit(n)&lt;/code&gt; 不仅要返回任何&lt;em&gt;n个&lt;/em&gt;元素，而且要返回&lt;em&gt;前n &lt;/em&gt;&lt;em&gt;个&lt;/em&gt;元素遇到顺序中的元素。使用无序流源（例如&lt;a href=&quot;intstream#generate-java.util.function.IntSupplier-&quot;&gt; &lt;code&gt;generate(IntSupplier)&lt;/code&gt; &lt;/a&gt;）或使用&lt;a href=&quot;basestream#unordered--&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; &lt;/a&gt;删除排序约束可能会导致 &lt;code&gt;limit()&lt;/code&gt; 的大幅加速如果情况允许，请在并行管道中使用。如果需要与遇到顺序保持一致，并且在并行管道中使用 &lt;code&gt;limit()&lt;/code&gt; 遇到性能低下或内存使用率不足的情况，则切换为使用&lt;a href=&quot;intstream#sequential--&quot;&gt; &lt;code&gt;sequential()&lt;/code&gt; &lt;/a&gt;顺序执行可能会提高性能。</target>
        </trans-unit>
        <trans-unit id="50f1dd72f901eaef160af7e84d23600d1ebf7971" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;limit()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, especially for large values of &lt;code&gt;maxSize&lt;/code&gt;, since &lt;code&gt;limit(n)&lt;/code&gt; is constrained to return not just any &lt;em&gt;n&lt;/em&gt; elements, but the &lt;em&gt;first n&lt;/em&gt; elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;longstream#generate-java.util.function.LongSupplier-&quot;&gt;&lt;code&gt;generate(LongSupplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered--&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;limit()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;limit()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;longstream#sequential--&quot;&gt;&lt;code&gt;sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">虽然 &lt;code&gt;limit()&lt;/code&gt; 通常在顺序流管道上是便宜的操作，但在有序并行管道上可能会非常昂贵，尤其是对于 &lt;code&gt;maxSize&lt;/code&gt; 大的情况，因为 &lt;code&gt;limit(n)&lt;/code&gt; 不仅要返回任何&lt;em&gt;n个&lt;/em&gt;元素，而且要返回&lt;em&gt;前n &lt;/em&gt;&lt;em&gt;个&lt;/em&gt;元素遇到顺序中的元素。使用无序流源（例如&lt;a href=&quot;longstream#generate-java.util.function.LongSupplier-&quot;&gt; &lt;code&gt;generate(LongSupplier)&lt;/code&gt; &lt;/a&gt;）或使用&lt;a href=&quot;basestream#unordered--&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; &lt;/a&gt;删除排序约束可能会导致 &lt;code&gt;limit()&lt;/code&gt; 的大幅加速如果情况允许，请在并行管道中使用。如果需要与遇到顺序保持一致，并且在并行管道中使用 &lt;code&gt;limit()&lt;/code&gt; 遇到性能低下或内存使用率不足的情况，则切换为使用&lt;a href=&quot;longstream#sequential--&quot;&gt; &lt;code&gt;sequential()&lt;/code&gt; &lt;/a&gt;顺序执行可能会提高性能。</target>
        </trans-unit>
        <trans-unit id="e7b022b1174615a655ebcf28b81dbf48a9f1556b" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;limit()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, especially for large values of &lt;code&gt;maxSize&lt;/code&gt;, since &lt;code&gt;limit(n)&lt;/code&gt; is constrained to return not just any &lt;em&gt;n&lt;/em&gt; elements, but the &lt;em&gt;first n&lt;/em&gt; elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;stream#generate-java.util.function.Supplier-&quot;&gt;&lt;code&gt;generate(Supplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered--&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;limit()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;limit()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;basestream#sequential--&quot;&gt;&lt;code&gt;BaseStream.sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">虽然 &lt;code&gt;limit()&lt;/code&gt; 通常在顺序流管道上是便宜的操作，但在有序并行管道上可能会非常昂贵，尤其是对于 &lt;code&gt;maxSize&lt;/code&gt; 大的情况，因为 &lt;code&gt;limit(n)&lt;/code&gt; 不仅要返回任何&lt;em&gt;n个&lt;/em&gt;元素，而且要返回&lt;em&gt;前n &lt;/em&gt;&lt;em&gt;个&lt;/em&gt;元素遇到顺序中的元素。使用无序流源（例如&lt;a href=&quot;stream#generate-java.util.function.Supplier-&quot;&gt; &lt;code&gt;generate(Supplier)&lt;/code&gt; &lt;/a&gt;）或使用&lt;a href=&quot;basestream#unordered--&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; &lt;/a&gt;删除排序约束可能会导致 &lt;code&gt;limit()&lt;/code&gt; 的明显加速。如果情况允许，请在并行管道中使用。如果需要与遇到顺序保持一致，并且在并行管道中使用 &lt;code&gt;limit()&lt;/code&gt; 遇到性能低下或内存使用率不足的情况，则切换为使用&lt;a href=&quot;basestream#sequential--&quot;&gt; &lt;code&gt;BaseStream.sequential()&lt;/code&gt; &lt;/a&gt;顺序执行可能会提高性能。</target>
        </trans-unit>
        <trans-unit id="7b87dc7fad8d14aab16d4ddc4f41ded925891b0e" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;skip()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, especially for large values of &lt;code&gt;n&lt;/code&gt;, since &lt;code&gt;skip(n)&lt;/code&gt; is constrained to skip not just any &lt;em&gt;n&lt;/em&gt; elements, but the &lt;em&gt;first n&lt;/em&gt; elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;#generate(java.util.function.DoubleSupplier)&quot;&gt;&lt;code&gt;generate(DoubleSupplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered()&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;skip()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;skip()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;basestream#sequential()&quot;&gt;&lt;code&gt;BaseStream.sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">尽管 &lt;code&gt;skip()&lt;/code&gt; 在顺序流管道上通常是便宜的操作，但在有序并行管道上可能是相当昂贵的，尤其是对于 &lt;code&gt;n&lt;/code&gt; 较大的值，因为 &lt;code&gt;skip(n)&lt;/code&gt; 不仅被限制为不仅可以跳过任何&lt;em&gt;n个&lt;/em&gt;元素，而且还可以跳过&lt;em&gt;前n&lt;/em&gt;&lt;em&gt;个&lt;/em&gt;元素遇到顺序中的元素。如果情况的语义允许，则使用无序流源（例如&lt;a href=&quot;#generate(java.util.function.DoubleSupplier)&quot;&gt; &lt;code&gt;generate(DoubleSupplier)&lt;/code&gt; &lt;/a&gt;）或使用&lt;a href=&quot;basestream#unordered()&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; &lt;/a&gt;删除排序约束可能会导致并行管道中 &lt;code&gt;skip()&lt;/code&gt; 的显着加速。如果需要与相遇顺序保持一致，并且您遇到了性能不佳或内存利用率低下的问题， &lt;code&gt;skip()&lt;/code&gt; 在并行管道中使用skip（），切换为使用&lt;a href=&quot;basestream#sequential()&quot;&gt; &lt;code&gt;BaseStream.sequential()&lt;/code&gt; &lt;/a&gt;顺序执行可能会提高性能。</target>
        </trans-unit>
        <trans-unit id="fd851600c5d344782f73398b78b6e28503994a09" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;skip()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, especially for large values of &lt;code&gt;n&lt;/code&gt;, since &lt;code&gt;skip(n)&lt;/code&gt; is constrained to skip not just any &lt;em&gt;n&lt;/em&gt; elements, but the &lt;em&gt;first n&lt;/em&gt; elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;#generate(java.util.function.IntSupplier)&quot;&gt;&lt;code&gt;generate(IntSupplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered()&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;skip()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;skip()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;basestream#sequential()&quot;&gt;&lt;code&gt;BaseStream.sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">尽管 &lt;code&gt;skip()&lt;/code&gt; 在顺序流管道上通常是便宜的操作，但在有序并行管道上可能是相当昂贵的，尤其是对于 &lt;code&gt;n&lt;/code&gt; 较大的值，因为 &lt;code&gt;skip(n)&lt;/code&gt; 不仅被限制为不仅可以跳过任何&lt;em&gt;n个&lt;/em&gt;元素，而且还可以跳过&lt;em&gt;前n&lt;/em&gt;&lt;em&gt;个&lt;/em&gt;元素遇到顺序中的元素。如果情况的语义允许，则使用无序流源（例如&lt;a href=&quot;#generate(java.util.function.IntSupplier)&quot;&gt; &lt;code&gt;generate(IntSupplier)&lt;/code&gt; &lt;/a&gt;）或使用&lt;a href=&quot;basestream#unordered()&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; &lt;/a&gt;删除排序约束可能会导致并行管道中 &lt;code&gt;skip()&lt;/code&gt; 的显着加速。如果需要与相遇顺序保持一致，并且您遇到了性能不佳或内存利用率低下的问题， &lt;code&gt;skip()&lt;/code&gt; 在并行管道中使用skip（），切换为使用&lt;a href=&quot;basestream#sequential()&quot;&gt; &lt;code&gt;BaseStream.sequential()&lt;/code&gt; &lt;/a&gt;顺序执行可能会提高性能。</target>
        </trans-unit>
        <trans-unit id="a33a9aba4905d83925c9ee06f4fa960c35c02c78" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;skip()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, especially for large values of &lt;code&gt;n&lt;/code&gt;, since &lt;code&gt;skip(n)&lt;/code&gt; is constrained to skip not just any &lt;em&gt;n&lt;/em&gt; elements, but the &lt;em&gt;first n&lt;/em&gt; elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;#generate(java.util.function.LongSupplier)&quot;&gt;&lt;code&gt;generate(LongSupplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered()&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;skip()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;skip()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;basestream#sequential()&quot;&gt;&lt;code&gt;BaseStream.sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">尽管 &lt;code&gt;skip()&lt;/code&gt; 在顺序流管道上通常是便宜的操作，但在有序并行管道上可能是相当昂贵的，尤其是对于 &lt;code&gt;n&lt;/code&gt; 较大的值，因为 &lt;code&gt;skip(n)&lt;/code&gt; 不仅被限制为不仅可以跳过任何&lt;em&gt;n个&lt;/em&gt;元素，而且还可以跳过&lt;em&gt;前n&lt;/em&gt;&lt;em&gt;个&lt;/em&gt;元素遇到顺序中的元素。如果情况的语义允许，则使用无序流源（例如&lt;a href=&quot;#generate(java.util.function.LongSupplier)&quot;&gt; &lt;code&gt;generate(LongSupplier)&lt;/code&gt; &lt;/a&gt;）或使用&lt;a href=&quot;basestream#unordered()&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; &lt;/a&gt;删除排序约束可能会导致并行管道中 &lt;code&gt;skip()&lt;/code&gt; 的显着加速。如果需要与相遇顺序保持一致，并且您遇到了性能不佳或内存利用率低下的问题， &lt;code&gt;skip()&lt;/code&gt; 在并行管道中使用skip（），切换为使用&lt;a href=&quot;basestream#sequential()&quot;&gt; &lt;code&gt;BaseStream.sequential()&lt;/code&gt; &lt;/a&gt;顺序执行可能会提高性能。</target>
        </trans-unit>
        <trans-unit id="2b0b2ed9d6a481a9b272dda6c65ea3e9ae7c5297" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;skip()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, especially for large values of &lt;code&gt;n&lt;/code&gt;, since &lt;code&gt;skip(n)&lt;/code&gt; is constrained to skip not just any &lt;em&gt;n&lt;/em&gt; elements, but the &lt;em&gt;first n&lt;/em&gt; elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;#generate(java.util.function.Supplier)&quot;&gt;&lt;code&gt;generate(Supplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered()&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;skip()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;skip()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;basestream#sequential()&quot;&gt;&lt;code&gt;BaseStream.sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">尽管 &lt;code&gt;skip()&lt;/code&gt; 在顺序流管道上通常是便宜的操作，但在有序并行管道上可能是相当昂贵的，尤其是对于 &lt;code&gt;n&lt;/code&gt; 较大的值，因为 &lt;code&gt;skip(n)&lt;/code&gt; 不仅被限制为不仅可以跳过任何&lt;em&gt;n个&lt;/em&gt;元素，而且还可以跳过&lt;em&gt;前n&lt;/em&gt;&lt;em&gt;个&lt;/em&gt;元素遇到顺序中的元素。如果情况的语义允许，则使用无序流源（例如&lt;a href=&quot;#generate(java.util.function.Supplier)&quot;&gt; &lt;code&gt;generate(Supplier)&lt;/code&gt; &lt;/a&gt;）或使用&lt;a href=&quot;basestream#unordered()&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; &lt;/a&gt;删除排序约束可能会导致并行管道中 &lt;code&gt;skip()&lt;/code&gt; 的显着加速。如果需要与相遇顺序保持一致，并且您遇到了性能不佳或内存利用率低下的问题， &lt;code&gt;skip()&lt;/code&gt; 在并行管道中使用skip（），切换为使用&lt;a href=&quot;basestream#sequential()&quot;&gt; &lt;code&gt;BaseStream.sequential()&lt;/code&gt; &lt;/a&gt;顺序执行可能会提高性能。</target>
        </trans-unit>
        <trans-unit id="74d731aa21902009fd224b6c3c7d21287ffacde8" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;skip()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, especially for large values of &lt;code&gt;n&lt;/code&gt;, since &lt;code&gt;skip(n)&lt;/code&gt; is constrained to skip not just any &lt;em&gt;n&lt;/em&gt; elements, but the &lt;em&gt;first n&lt;/em&gt; elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;doublestream#generate-java.util.function.DoubleSupplier-&quot;&gt;&lt;code&gt;generate(DoubleSupplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered--&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;skip()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;skip()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;doublestream#sequential--&quot;&gt;&lt;code&gt;sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">尽管 &lt;code&gt;skip()&lt;/code&gt; 在顺序流管道上通常是便宜的操作，但在有序并行管道上可能是非常昂贵的，尤其是对于 &lt;code&gt;n&lt;/code&gt; 较大的值，因为 &lt;code&gt;skip(n)&lt;/code&gt; 不仅被限制为不仅可以跳过任何&lt;em&gt;n个&lt;/em&gt;元素，而且还可以跳过&lt;em&gt;前n &lt;/em&gt;&lt;em&gt;个&lt;/em&gt;元素遇到顺序中的元素。如果情况的语义允许，则使用无序流源（例如&lt;a href=&quot;doublestream#generate-java.util.function.DoubleSupplier-&quot;&gt; &lt;code&gt;generate(DoubleSupplier)&lt;/code&gt; &lt;/a&gt;）或使用&lt;a href=&quot;basestream#unordered--&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; &lt;/a&gt;删除排序约束可能会导致并行管道中 &lt;code&gt;skip()&lt;/code&gt; 的显着加速。如果需要与遇到顺序保持一致，并且您遇到了性能较差或内存利用率不足的情况， &lt;code&gt;skip()&lt;/code&gt; 在并行管道中使用skip（）时，切换到使用&lt;a href=&quot;doublestream#sequential--&quot;&gt; &lt;code&gt;sequential()&lt;/code&gt; &lt;/a&gt;顺序执行可以提高性能。</target>
        </trans-unit>
        <trans-unit id="8b6aed4201bbc532174a6b1ac759cb47bf878a52" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;skip()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, especially for large values of &lt;code&gt;n&lt;/code&gt;, since &lt;code&gt;skip(n)&lt;/code&gt; is constrained to skip not just any &lt;em&gt;n&lt;/em&gt; elements, but the &lt;em&gt;first n&lt;/em&gt; elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;intstream#generate-java.util.function.IntSupplier-&quot;&gt;&lt;code&gt;generate(IntSupplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered--&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;skip()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;skip()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;intstream#sequential--&quot;&gt;&lt;code&gt;sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">尽管 &lt;code&gt;skip()&lt;/code&gt; 在顺序流管道上通常是便宜的操作，但在有序并行管道上可能是非常昂贵的，尤其是对于 &lt;code&gt;n&lt;/code&gt; 较大的值，因为 &lt;code&gt;skip(n)&lt;/code&gt; 不仅被限制为不仅可以跳过任何&lt;em&gt;n个&lt;/em&gt;元素，而且还可以跳过&lt;em&gt;前n &lt;/em&gt;&lt;em&gt;个&lt;/em&gt;元素遇到顺序中的元素。如果情况的语义允许，则使用无序流源（例如&lt;a href=&quot;intstream#generate-java.util.function.IntSupplier-&quot;&gt; &lt;code&gt;generate(IntSupplier)&lt;/code&gt; &lt;/a&gt;）或使用&lt;a href=&quot;basestream#unordered--&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; &lt;/a&gt;删除排序约束可能会导致并行管道中 &lt;code&gt;skip()&lt;/code&gt; 的显着加速。如果需要与遇到顺序保持一致，并且您遇到了性能较差或内存利用率不足的情况， &lt;code&gt;skip()&lt;/code&gt; 在并行管道中使用skip（）时，切换到使用&lt;a href=&quot;intstream#sequential--&quot;&gt; &lt;code&gt;sequential()&lt;/code&gt; &lt;/a&gt;顺序执行可以提高性能。</target>
        </trans-unit>
        <trans-unit id="08e49b292a5f6675c12e6e8084622cb9a1123c41" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;skip()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, especially for large values of &lt;code&gt;n&lt;/code&gt;, since &lt;code&gt;skip(n)&lt;/code&gt; is constrained to skip not just any &lt;em&gt;n&lt;/em&gt; elements, but the &lt;em&gt;first n&lt;/em&gt; elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;longstream#generate-java.util.function.LongSupplier-&quot;&gt;&lt;code&gt;generate(LongSupplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered--&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;skip()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;skip()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;longstream#sequential--&quot;&gt;&lt;code&gt;sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">尽管 &lt;code&gt;skip()&lt;/code&gt; 在顺序流管道上通常是便宜的操作，但在有序并行管道上可能是非常昂贵的，尤其是对于 &lt;code&gt;n&lt;/code&gt; 较大的值，因为 &lt;code&gt;skip(n)&lt;/code&gt; 不仅被限制为不仅可以跳过任何&lt;em&gt;n个&lt;/em&gt;元素，而且还可以跳过&lt;em&gt;前n &lt;/em&gt;&lt;em&gt;个&lt;/em&gt;元素遇到顺序中的元素。如果您的情况允许，使用无序流源（例如&lt;a href=&quot;longstream#generate-java.util.function.LongSupplier-&quot;&gt; &lt;code&gt;generate(LongSupplier)&lt;/code&gt; &lt;/a&gt;）或使用&lt;a href=&quot;basestream#unordered--&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; &lt;/a&gt;删除排序约束可能会导致并行管道中 &lt;code&gt;skip()&lt;/code&gt; 的大量加速。如果需要与遇到顺序保持一致，并且您遇到了性能较差或内存利用率不足的情况， &lt;code&gt;skip()&lt;/code&gt; 在并行管道中使用skip（）时，切换到使用&lt;a href=&quot;longstream#sequential--&quot;&gt; &lt;code&gt;sequential()&lt;/code&gt; &lt;/a&gt;顺序执行可以提高性能。</target>
        </trans-unit>
        <trans-unit id="e1b922a638d8b7b0bf464d0b07da3f9937acce8a" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;skip()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, especially for large values of &lt;code&gt;n&lt;/code&gt;, since &lt;code&gt;skip(n)&lt;/code&gt; is constrained to skip not just any &lt;em&gt;n&lt;/em&gt; elements, but the &lt;em&gt;first n&lt;/em&gt; elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;stream#generate-java.util.function.Supplier-&quot;&gt;&lt;code&gt;generate(Supplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered--&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;skip()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;skip()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;basestream#sequential--&quot;&gt;&lt;code&gt;BaseStream.sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">尽管 &lt;code&gt;skip()&lt;/code&gt; 在顺序流管道上通常是便宜的操作，但在有序并行管道上可能是非常昂贵的，尤其是对于 &lt;code&gt;n&lt;/code&gt; 较大的值，因为 &lt;code&gt;skip(n)&lt;/code&gt; 不仅被限制为不仅可以跳过任何&lt;em&gt;n个&lt;/em&gt;元素，而且还可以跳过&lt;em&gt;前n &lt;/em&gt;&lt;em&gt;个&lt;/em&gt;元素遇到顺序中的元素。如果情况的语义允许，则使用无序流源（例如&lt;a href=&quot;stream#generate-java.util.function.Supplier-&quot;&gt; &lt;code&gt;generate(Supplier)&lt;/code&gt; &lt;/a&gt;）或使用&lt;a href=&quot;basestream#unordered--&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; &lt;/a&gt;删除排序约束可能会导致并行管道中 &lt;code&gt;skip()&lt;/code&gt; 的显着加速。如果需要与遇到顺序保持一致，并且您遇到了性能较差或内存利用率不足的情况， &lt;code&gt;skip()&lt;/code&gt; 在并行管道中使用skip（），切换为使用&lt;a href=&quot;basestream#sequential--&quot;&gt; &lt;code&gt;BaseStream.sequential()&lt;/code&gt; &lt;/a&gt;顺序执行可以提高性能。</target>
        </trans-unit>
        <trans-unit id="f11e1ce2eaeeb9a61aafb14bbaaa04b134c253c4" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;takeWhile()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, since the operation is constrained to return not just any valid prefix, but the longest prefix of elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;#generate(java.util.function.DoubleSupplier)&quot;&gt;&lt;code&gt;generate(DoubleSupplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered()&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;takeWhile()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;takeWhile()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;basestream#sequential()&quot;&gt;&lt;code&gt;BaseStream.sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">尽管 &lt;code&gt;takeWhile()&lt;/code&gt; 通常在顺序流管道上是便宜的操作，但是在有序并行管道上它可能会非常昂贵，因为该操作被约束为不仅返回任何有效前缀，而且返回遇到顺序中元素的最长前缀。如果情况的语义允许，则使用无序流源（例如&lt;a href=&quot;#generate(java.util.function.DoubleSupplier)&quot;&gt; &lt;code&gt;generate(DoubleSupplier)&lt;/code&gt; &lt;/a&gt;）或使用&lt;a href=&quot;basestream#unordered()&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; &lt;/a&gt;除去排序约束可能会导致并行管道中 &lt;code&gt;takeWhile()&lt;/code&gt; 的显着加速。如果需要与遇到顺序保持一致，并且在并行管道中使用 &lt;code&gt;takeWhile()&lt;/code&gt; 遇到性能低下或内存使用不足的情况，请使用&lt;a href=&quot;basestream#sequential()&quot;&gt; &lt;code&gt;BaseStream.sequential()&lt;/code&gt; &lt;/a&gt;可以提高性能。</target>
        </trans-unit>
        <trans-unit id="536720f4d6e048e3bfc2daf23b8be0d5f28b62ff" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;takeWhile()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, since the operation is constrained to return not just any valid prefix, but the longest prefix of elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;#generate(java.util.function.IntSupplier)&quot;&gt;&lt;code&gt;generate(IntSupplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered()&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;takeWhile()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;takeWhile()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;basestream#sequential()&quot;&gt;&lt;code&gt;BaseStream.sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">尽管 &lt;code&gt;takeWhile()&lt;/code&gt; 通常在顺序流管道上是便宜的操作，但是在有序并行管道上它可能会非常昂贵，因为该操作被约束为不仅返回任何有效前缀，而且返回遇到顺序中元素的最长前缀。如果情况的语义允许，则使用无序流源（例如&lt;a href=&quot;#generate(java.util.function.IntSupplier)&quot;&gt; &lt;code&gt;generate(IntSupplier)&lt;/code&gt; &lt;/a&gt;）或使用&lt;a href=&quot;basestream#unordered()&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; &lt;/a&gt;删除排序约束可能会导致并行管道中 &lt;code&gt;takeWhile()&lt;/code&gt; 的显着加速。如果需要与遇到顺序保持一致，并且在并行管道中使用 &lt;code&gt;takeWhile()&lt;/code&gt; 遇到性能低下或内存使用不足的情况，请使用&lt;a href=&quot;basestream#sequential()&quot;&gt; &lt;code&gt;BaseStream.sequential()&lt;/code&gt; &lt;/a&gt;可以提高性能。</target>
        </trans-unit>
        <trans-unit id="996949649b893c1211f1e5529c0828c15fa967ef" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;takeWhile()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, since the operation is constrained to return not just any valid prefix, but the longest prefix of elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;#generate(java.util.function.LongSupplier)&quot;&gt;&lt;code&gt;generate(LongSupplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered()&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;takeWhile()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;takeWhile()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;basestream#sequential()&quot;&gt;&lt;code&gt;BaseStream.sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">尽管 &lt;code&gt;takeWhile()&lt;/code&gt; 通常在顺序流管道上是便宜的操作，但是在有序并行管道上它可能会非常昂贵，因为该操作被约束为不仅返回任何有效前缀，而且返回遇到顺序中元素的最长前缀。如果情况的语义允许，则使用无序流源（例如&lt;a href=&quot;#generate(java.util.function.LongSupplier)&quot;&gt; &lt;code&gt;generate(LongSupplier)&lt;/code&gt; &lt;/a&gt;）或使用&lt;a href=&quot;basestream#unordered()&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; &lt;/a&gt;除去排序约束可能会导致并行管道中 &lt;code&gt;takeWhile()&lt;/code&gt; 的显着加速。如果需要与遇到顺序保持一致，并且在并行管道中使用 &lt;code&gt;takeWhile()&lt;/code&gt; 遇到性能低下或内存使用不足的情况，请使用&lt;a href=&quot;basestream#sequential()&quot;&gt; &lt;code&gt;BaseStream.sequential()&lt;/code&gt; &lt;/a&gt;可以提高性能。</target>
        </trans-unit>
        <trans-unit id="6e8939e26489616f38385fb9a8f6b0914d6faecc" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;takeWhile()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, since the operation is constrained to return not just any valid prefix, but the longest prefix of elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;#generate(java.util.function.Supplier)&quot;&gt;&lt;code&gt;generate(Supplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered()&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;takeWhile()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;takeWhile()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;basestream#sequential()&quot;&gt;&lt;code&gt;BaseStream.sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">尽管 &lt;code&gt;takeWhile()&lt;/code&gt; 通常在顺序流管道上是便宜的操作，但是在有序并行管道上它可能会非常昂贵，因为该操作被约束为不仅返回任何有效前缀，而且返回遇到顺序中元素的最长前缀。如果情况的语义允许，则使用无序流源（例如&lt;a href=&quot;#generate(java.util.function.Supplier)&quot;&gt; &lt;code&gt;generate(Supplier)&lt;/code&gt; &lt;/a&gt;）或使用&lt;a href=&quot;basestream#unordered()&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; &lt;/a&gt;除去排序约束可能会导致并行管道中 &lt;code&gt;takeWhile()&lt;/code&gt; 的显着加速。如果需要与遇到顺序保持一致，并且在并行管道中使用 &lt;code&gt;takeWhile()&lt;/code&gt; 遇到性能低下或内存使用不足的情况，请使用&lt;a href=&quot;basestream#sequential()&quot;&gt; &lt;code&gt;BaseStream.sequential()&lt;/code&gt; &lt;/a&gt;可以提高性能。</target>
        </trans-unit>
        <trans-unit id="f44ebb750484feed7acd90b248717e6c6a220783" translate="yes" xml:space="preserve">
          <source>While DefaultMutableTreeNode implements the MutableTreeNode interface and will allow you to add in any implementation of MutableTreeNode not all of the methods in DefaultMutableTreeNode will be applicable to all MutableTreeNodes implementations. Especially with some of the enumerations that are provided, using some of these methods assumes the DefaultMutableTreeNode contains only DefaultMutableNode instances. All of the TreeNode/MutableTreeNode methods will behave as defined no matter what implementations are added.</source>
          <target state="translated">虽然DefaultMutableTreeNode实现了MutableTreeNode接口,并允许你添加任何MutableTreeNode的实现,但DefaultMutableTreeNode中的所有方法并不适用于所有MutableTreeNodes的实现。特别是对于一些被提供的枚举,使用这些方法中的一些方法假设DefaultMutableTreeNode只包含DefaultMutableNode实例。无论添加了什么实现,所有的TreeNode/MutableTreeNode方法都将按照定义的方式运行。</target>
        </trans-unit>
        <trans-unit id="4167a99521bae55a855564642cb10cb92285c449" translate="yes" xml:space="preserve">
          <source>While JAXP supports validation as a feature of an XML parser, represented by either a &lt;a href=&quot;../parsers/saxparser&quot;&gt;&lt;code&gt;SAXParser&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../parsers/documentbuilder&quot;&gt;&lt;code&gt;DocumentBuilder&lt;/code&gt;&lt;/a&gt; instance, the &lt;code&gt;Validation&lt;/code&gt; API is preferred.</source>
          <target state="translated">虽然JAXP将验证作为XML解析器的功能（由&lt;a href=&quot;../parsers/saxparser&quot;&gt; &lt;code&gt;SAXParser&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../parsers/documentbuilder&quot;&gt; &lt;code&gt;DocumentBuilder&lt;/code&gt; &lt;/a&gt;实例表示）支持，但首选使用 &lt;code&gt;Validation&lt;/code&gt; API。</target>
        </trans-unit>
        <trans-unit id="a21ea13fd41327eba1978d9dc59ed4e742694b36" translate="yes" xml:space="preserve">
          <source>While XPath expressions select nodes in the XML document, the XPath API allows the selected nodes to be coalesced into one of the following data types:</source>
          <target state="translated">当XPath表达式选择XML文档中的节点时,XPath API允许将所选节点凝聚成以下数据类型之一。</target>
        </trans-unit>
        <trans-unit id="d1c1d5877bbdead7eaf0421be72e2ef20db6441f" translate="yes" xml:space="preserve">
          <source>While a &lt;code id=&quot;ELEM_VS_TYPE&quot;&gt;TypeElement&lt;/code&gt; represents a class or interface</source>
          <target state="translated">虽然 &lt;code id=&quot;ELEM_VS_TYPE&quot;&gt;TypeElement&lt;/code&gt; 表示类或接口</target>
        </trans-unit>
        <trans-unit id="9231d9bdcc9f4e1959e5ee9d3a56a9d2a170bb99" translate="yes" xml:space="preserve">
          <source>While a &lt;code&gt;CachedRowSet&lt;/code&gt; object is disconnected, it can be much leaner than a &lt;code&gt;ResultSet&lt;/code&gt; object with the same data. As a result, it can be especially suitable for sending data to a thin client such as a PDA, where it would be inappropriate to use a JDBC driver due to resource limitations or security considerations. Thus, a &lt;code&gt;CachedRowSet&lt;/code&gt; object provides a means to &quot;get rows in&quot; without the need to implement the full JDBC API.</source>
          <target state="translated">当 &lt;code&gt;CachedRowSet&lt;/code&gt; 对象断开连接时，它比具有相同数据的 &lt;code&gt;ResultSet&lt;/code&gt; 对象要精简得多。结果，它特别适合于将数据发送到诸如PDA之类的瘦客户机，由于资源限制或安全考虑，使用JDBC驱动程序是不合适的。因此， &lt;code&gt;CachedRowSet&lt;/code&gt; 对象提供了一种&amp;ldquo;获取行&amp;rdquo;的方法，而无需实现完整的JDBC API。</target>
        </trans-unit>
        <trans-unit id="30e4f165db1002fe6fbf12ff195d30f7e4cff77b" translate="yes" xml:space="preserve">
          <source>While a &lt;code&gt;Chronology&lt;/code&gt; object typically uses &lt;code&gt;ChronoField&lt;/code&gt; and is based on an era, year-of-era, month-of-year, day-of-month model of a date, this is not required. A &lt;code&gt;Chronology&lt;/code&gt; instance may represent a totally different kind of calendar system, such as the Mayan.</source>
          <target state="translated">虽然&amp;ldquo; &lt;code&gt;Chronology&lt;/code&gt; 对象通常使用&amp;ldquo; &lt;code&gt;ChronoField&lt;/code&gt; &amp;rdquo;，并且基于日期的时代，年代，年份，月份和日期模型，但这不是必需的。甲 &lt;code&gt;Chronology&lt;/code&gt; 实例可以代表一种完全不同的日历系统，诸如玛雅。</target>
        </trans-unit>
        <trans-unit id="9784eeccfaf1f4a4f0da131846253a9ef6b0027f" translate="yes" xml:space="preserve">
          <source>While a &lt;code&gt;TypeElement&lt;/code&gt; represents a class or interface</source>
          <target state="translated">虽然 &lt;code&gt;TypeElement&lt;/code&gt; 表示类或接口</target>
        </trans-unit>
        <trans-unit id="b1518d4c45f16c46674f0f206ccd4613201a8ad4" translate="yes" xml:space="preserve">
          <source>While all three of the &lt;code&gt;prototypeCellValue&lt;/code&gt;, &lt;code&gt;fixedCellHeight&lt;/code&gt;, and &lt;code&gt;fixedCellWidth&lt;/code&gt; properties may be modified by this method, &lt;code&gt;PropertyChangeEvent&lt;/code&gt; notifications are only sent when the &lt;code&gt;prototypeCellValue&lt;/code&gt; property changes.</source>
          <target state="translated">尽管可以通过此方法修改 &lt;code&gt;prototypeCellValue&lt;/code&gt; ， &lt;code&gt;fixedCellHeight&lt;/code&gt; 和 &lt;code&gt;fixedCellWidth&lt;/code&gt; 这三个属性，但是只有在 &lt;code&gt;prototypeCellValue&lt;/code&gt; 属性发生更改时才发送 &lt;code&gt;PropertyChangeEvent&lt;/code&gt; 通知。</target>
        </trans-unit>
        <trans-unit id="19ace92ef3bab3caea4c0ffa2acf86708693deef" translate="yes" xml:space="preserve">
          <source>While an implementation may not recognize all CSS properties within a CSS declaration block, it is expected to provide access to all specified properties in the style sheet through the &lt;code&gt;CSSStyleDeclaration&lt;/code&gt; interface. Furthermore, implementations that support a specific level of CSS should correctly handle CSS shorthand properties for that level. For a further discussion of shorthand properties, see the &lt;code&gt;CSS2Properties&lt;/code&gt; interface.</source>
          <target state="translated">尽管实现可能无法识别CSS声明块中的所有CSS属性，但是它有望通过 &lt;code&gt;CSSStyleDeclaration&lt;/code&gt; 接口提供对样式表中所有指定属性的访问。此外，支持特定级别CSS的实现应正确处理该级别的CSS速记属性。有关速记属性的进一步讨论，请参见 &lt;code&gt;CSS2Properties&lt;/code&gt; 接口。</target>
        </trans-unit>
        <trans-unit id="3b017d1c42ec1554655bf855dc44af27a7a96ca5" translate="yes" xml:space="preserve">
          <source>While applications write to the &lt;code&gt;LoginContext&lt;/code&gt; API, authentication technology providers implement the &lt;code&gt;LoginModule&lt;/code&gt; interface. A &lt;code&gt;Configuration&lt;/code&gt; specifies the LoginModule(s) to be used with a particular login application. Therefore different LoginModules can be plugged in under the application without requiring any modifications to the application itself.</source>
          <target state="translated">当应用程序写入 &lt;code&gt;LoginContext&lt;/code&gt; API时，身份验证技术提供程序将实现 &lt;code&gt;LoginModule&lt;/code&gt; 接口。甲 &lt;code&gt;Configuration&lt;/code&gt; 指定与特定登录应用程序一起使用的LoginModule（一个或多个）。因此，可以在应用程序下插入不同的LoginModule，而无需对应用程序本身进行任何修改。</target>
        </trans-unit>
        <trans-unit id="2406ab2abac29e951c9626f9ef877429a290fa9c" translate="yes" xml:space="preserve">
          <source>While building the MBeanInfo, this method calls the customization hooks that make it possible for subclasses to supply their custom descriptions, parameter names, etc...</source>
          <target state="translated">在构建MBeanInfo的同时,该方法调用自定义钩子,使子类可以提供它们的自定义描述、参数名等。</target>
        </trans-unit>
        <trans-unit id="73b5f4ac2141a2818394c1e963ca8d4434b78746" translate="yes" xml:space="preserve">
          <source>While callers may invoke &lt;code&gt;login&lt;/code&gt; directly, the provider may also invoke &lt;code&gt;login&lt;/code&gt; on behalf of callers if it determines that a login must be performed prior to certain operations.</source>
          <target state="translated">尽管呼叫者可以直接调用 &lt;code&gt;login&lt;/code&gt; ，但是如果提供者确定必须在某些操作之前执行登录，则提供者也可以代表呼叫者调用 &lt;code&gt;login&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="498a5c4d7f0598c6bbc42679f4696f06bbc47c30" translate="yes" xml:space="preserve">
          <source>While for case 2, it defines 4 URI Entries:</source>
          <target state="translated">而对于案例2,它定义了4个URI Entries。</target>
        </trans-unit>
        <trans-unit id="868ad264cb55aef3c8dd9f1593aca303b1f31c60" translate="yes" xml:space="preserve">
          <source>While iterating through the &lt;code&gt;Set&lt;/code&gt;, a &lt;code&gt;SecurityException&lt;/code&gt; is thrown if a security manager is installed and the caller does not have a &lt;a href=&quot;privatecredentialpermission&quot;&gt;&lt;code&gt;PrivateCredentialPermission&lt;/code&gt;&lt;/a&gt; to access a particular Credential. The &lt;code&gt;Iterator&lt;/code&gt; is nevertheless advanced to the next element in the &lt;code&gt;Set&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;Set&lt;/code&gt; 上进行迭代时，如果安装了安全管理器并且调用方没有访问特定证书的&lt;a href=&quot;privatecredentialpermission&quot;&gt; &lt;code&gt;PrivateCredentialPermission&lt;/code&gt; &lt;/a&gt;，则抛出 &lt;code&gt;SecurityException&lt;/code&gt; 。尽管如此， &lt;code&gt;Iterator&lt;/code&gt; 仍前进到 &lt;code&gt;Set&lt;/code&gt; 中的下一个元素。</target>
        </trans-unit>
        <trans-unit id="6354a2a3180a9378c7eb02538eb193186e5effba" translate="yes" xml:space="preserve">
          <source>While iterating through the &lt;code&gt;Set&lt;/code&gt;, a &lt;code&gt;SecurityException&lt;/code&gt; is thrown if the caller does not have permission to access a particular Credential. The &lt;code&gt;Iterator&lt;/code&gt; is nevertheless advanced to next element in the &lt;code&gt;Set&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;Set&lt;/code&gt; 上进行迭代时，如果调用者没有访问特定证书的权限，则抛出 &lt;code&gt;SecurityException&lt;/code&gt; 。尽管如此， &lt;code&gt;Iterator&lt;/code&gt; 仍前进到 &lt;code&gt;Set&lt;/code&gt; 中的下一个元素。</target>
        </trans-unit>
        <trans-unit id="0fa2ee2232311c188a194a08d7481eaf402f451e" translate="yes" xml:space="preserve">
          <source>While parsing an input source, errors are reported to the application through the error handler (&lt;code&gt;LSParser.domConfig&lt;/code&gt;'s &quot;&lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#parameter-error-handler&quot;&gt;error-handler&lt;/a&gt;&quot; parameter). This specification does in no way try to define all possible errors that can occur while parsing XML, or any other markup, but some common error cases are defined. The types (&lt;code&gt;DOMError.type&lt;/code&gt;) of errors and warnings defined by this specification are:</source>
          <target state="translated">解析输入源时，错误会通过错误处理程序（ &lt;code&gt;LSParser.domConfig&lt;/code&gt; 的&amp;ldquo;&lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#parameter-error-handler&quot;&gt;错误处理程序&lt;/a&gt;&amp;rdquo;参数）报告给应用程序。该规范绝不尝试定义在解析XML或任何其他标记时可能发生的所有可能的错误，但是定义了一些常见的错误情况。本规范定义的错误和警告的类型（ &lt;code&gt;DOMError.type&lt;/code&gt; ）为：</target>
        </trans-unit>
        <trans-unit id="86165e5f29fc9b9137f2a5569a7128b787a2ddbb" translate="yes" xml:space="preserve">
          <source>While serializing a document, the parameter &quot;discard-default-content&quot; controls whether or not non-specified data is serialized.</source>
          <target state="translated">在序列化文档时,&quot;discard-default-content &quot;参数控制非指定数据是否被序列化。</target>
        </trans-unit>
        <trans-unit id="cf4536abd5f3f04b1e2ed476be040c60ab02acb7" translate="yes" xml:space="preserve">
          <source>While serializing, errors and warnings are reported to the application through the error handler (&lt;code&gt;LSSerializer.domConfig&lt;/code&gt;'s &quot;&lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#parameter-error-handler&quot;&gt;error-handler&lt;/a&gt;&quot; parameter). This specification does in no way try to define all possible errors and warnings that can occur while serializing a DOM node, but some common error and warning cases are defined. The types ( &lt;code&gt;DOMError.type&lt;/code&gt;) of errors and warnings defined by this specification are:</source>
          <target state="translated">序列化时，错误和警告通过错误处理程序（ &lt;code&gt;LSSerializer.domConfig&lt;/code&gt; 的&amp;ldquo;&lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#parameter-error-handler&quot;&gt;错误处理程序&lt;/a&gt;&amp;rdquo;参数）报告给应用程序。该规范绝不尝试定义序列化DOM节点时可能发生的所有可能的错误和警告，但是定义了一些常见的错误和警告情况。本规范定义的错误和警告的类型（ &lt;code&gt;DOMError.type&lt;/code&gt; ）为：</target>
        </trans-unit>
        <trans-unit id="ddbca553bfbbeff28515b4164ea76df1af2bbd56" translate="yes" xml:space="preserve">
          <source>While some programs will choose to dedicate a thread to removing reference objects from one or more queues and processing them, this is by no means necessary. A tactic that often works well is to examine a reference queue in the course of performing some other fairly-frequent action. For example, a hashtable that uses weak references to implement weak keys could poll its reference queue each time the table is accessed. This is how the &lt;a href=&quot;../../util/weakhashmap&quot;&gt;&lt;code&gt;WeakHashMap&lt;/code&gt;&lt;/a&gt; class works. Because the &lt;a href=&quot;referencequeue#poll()&quot;&gt;&lt;code&gt;ReferenceQueue.poll&lt;/code&gt;&lt;/a&gt; method simply checks an internal data structure, this check will add little overhead to the hashtable access methods.</source>
          <target state="translated">尽管某些程序会选择专用于从一个或多个队列中删除引用对象并对其进行处理的线程，但这绝不是必需的。一种经常有效的策略是在执行其他一些相当频繁的操作的过程中检查参考队列。例如，使用弱引用实现弱键的哈希表可以在每次访问表时轮询其引用队列。这就是&lt;a href=&quot;../../util/weakhashmap&quot;&gt; &lt;code&gt;WeakHashMap&lt;/code&gt; &lt;/a&gt;类的工作方式。由于&lt;a href=&quot;referencequeue#poll()&quot;&gt; &lt;code&gt;ReferenceQueue.poll&lt;/code&gt; &lt;/a&gt;方法仅检查内部数据结构，因此此检查将为哈希表访问方法增加很少的开销。</target>
        </trans-unit>
        <trans-unit id="c239e1b59a3047897d29f5e117079370e9edd962" translate="yes" xml:space="preserve">
          <source>While tables for abbreviated streams are often obtained by first reading another abbreviated stream containing only the tables, in some applications the tables are fixed ahead of time. This class allows the tables to be specified directly from client code. If no tables are specified either in the stream or in a &lt;code&gt;JPEGImageReadParam&lt;/code&gt;, then the stream is presumed to use the &quot;standard&quot; visually lossless tables. See &lt;a href=&quot;jpegqtable&quot;&gt;&lt;code&gt;JPEGQTable&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;jpeghuffmantable&quot;&gt;&lt;code&gt;JPEGHuffmanTable&lt;/code&gt;&lt;/a&gt; for more information on the default tables.</source>
          <target state="translated">虽然通常首先通过读取仅包含表的另一个缩写流来获得缩写流的表，但是在某些应用程序中，表是提前固定的。此类允许直接从客户端代码指定表。如果在流或 &lt;code&gt;JPEGImageReadParam&lt;/code&gt; 中未指定任何表，则假定该流使用&amp;ldquo;标准&amp;rdquo;视觉无损表。有关默认表的更多信息，请参见&lt;a href=&quot;jpegqtable&quot;&gt; &lt;code&gt;JPEGQTable&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;jpeghuffmantable&quot;&gt; &lt;code&gt;JPEGHuffmanTable&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1b216501bc1079107fcb46b023f11ebfbbaf13fc" translate="yes" xml:space="preserve">
          <source>While tables for abbreviated streams are often specified by first writing an abbreviated stream containing only the tables, in some applications the tables are fixed ahead of time. This class allows the tables to be specified directly from client code.</source>
          <target state="translated">虽然缩略流的表格通常是通过先写一个只包含表格的缩略流来指定的,但在某些应用中,表格是提前固定的。这个类允许从客户端代码中直接指定表格。</target>
        </trans-unit>
        <trans-unit id="f55e7baa234a92f09d11651aeeb34c78f17b723e" translate="yes" xml:space="preserve">
          <source>While the &lt;code&gt;Collection&lt;/code&gt; interface adds no stipulations to the general contract for the &lt;code&gt;Object.equals&lt;/code&gt;, programmers who implement the &lt;code&gt;Collection&lt;/code&gt; interface &quot;directly&quot; (in other words, create a class that is a &lt;code&gt;Collection&lt;/code&gt; but is not a &lt;code&gt;Set&lt;/code&gt; or a &lt;code&gt;List&lt;/code&gt;) must exercise care if they choose to override the &lt;code&gt;Object.equals&lt;/code&gt;. It is not necessary to do so, and the simplest course of action is to rely on &lt;code&gt;Object&lt;/code&gt;'s implementation, but the implementor may wish to implement a &quot;value comparison&quot; in place of the default &quot;reference comparison.&quot; (The &lt;code&gt;List&lt;/code&gt; and &lt;code&gt;Set&lt;/code&gt; interfaces mandate such value comparisons.)</source>
          <target state="translated">尽管 &lt;code&gt;Collection&lt;/code&gt; 接口没有为 &lt;code&gt;Object.equals&lt;/code&gt; 的常规合同增加任何规定，但是&amp;ldquo;直接&amp;rdquo; 实现 &lt;code&gt;Collection&lt;/code&gt; 接口（换句话说，创建一个不是 &lt;code&gt;Collection&lt;/code&gt; 而不是 &lt;code&gt;Set&lt;/code&gt; 或 &lt;code&gt;List&lt;/code&gt; 的类）的程序员必须小心如果他们选择覆盖 &lt;code&gt;Object.equals&lt;/code&gt; 。不必这样做，最简单的方法是依靠 &lt;code&gt;Object&lt;/code&gt; 的实现，但是实现者可能希望实现&amp;ldquo;值比较&amp;rdquo;来代替默认的&amp;ldquo;引用比较&amp;rdquo;。 （ &lt;code&gt;List&lt;/code&gt; 和 &lt;code&gt;Set&lt;/code&gt; 接口要求进行这种值比较。）</target>
        </trans-unit>
        <trans-unit id="f5d22b4fafaee2e3b5d5f3ee0154553c12123ed3" translate="yes" xml:space="preserve">
          <source>While the &lt;code&gt;Externalizable&lt;/code&gt; interface extends &lt;code&gt;
 Serializable&lt;/code&gt;, the three methods and one field above are &lt;em&gt;not&lt;/em&gt; used for externalizable classes.</source>
          <target state="translated">尽管 &lt;code&gt;Externalizable&lt;/code&gt; 接口扩展了 &lt;code&gt; Serializable&lt;/code&gt; ，但上面的三种方法和一个字段&lt;em&gt;未&lt;/em&gt;用于可外部化的类。</target>
        </trans-unit>
        <trans-unit id="d9b34ed17b895b7570e58dbe128c1061764f2836" translate="yes" xml:space="preserve">
          <source>While the &lt;code&gt;JOptionPane&lt;/code&gt; class may appear complex because of the large number of methods, almost all uses of this class are one-line calls to one of the static &lt;code&gt;showXxxDialog&lt;/code&gt; methods shown below:</source>
          <target state="translated">尽管 &lt;code&gt;JOptionPane&lt;/code&gt; 类由于大量的方法而显得复杂，但此类的几乎所有用法都是对以下所示的静态 &lt;code&gt;showXxxDialog&lt;/code&gt; 方法之一的单行调用：</target>
        </trans-unit>
        <trans-unit id="f05e95138eee0f8263aaeecdb23d34bbf507f801" translate="yes" xml:space="preserve">
          <source>While the child view is being accessed a read lock is acquired on the associated document so that the model is stable while being accessed.</source>
          <target state="translated">当子视图被访问时,相关文档上会获得一个读锁,这样模型在被访问时是稳定的。</target>
        </trans-unit>
        <trans-unit id="18005f1749c0380a1dd553fb852a3af3b6131165" translate="yes" xml:space="preserve">
          <source>While the drag and drop implementation calls &lt;code&gt;canImport&lt;/code&gt; to determine the suitability of a transfer before calling this method, the implementation of paste does not. As such, it cannot be assumed that the transfer is acceptable upon a call to this method for paste. It is recommended that &lt;code&gt;canImport&lt;/code&gt; be explicitly called to cover this case.</source>
          <target state="translated">尽管拖放实现在调用此方法之前会调用 &lt;code&gt;canImport&lt;/code&gt; 来确定传输的适用性，但粘贴实现并不会。因此，不能假定调用此方法进行粘贴时可以接受转移。建议明确地调用 &lt;code&gt;canImport&lt;/code&gt; 来解决这种情况。</target>
        </trans-unit>
        <trans-unit id="4efe8fc428299599c701c1333f6be7122c0cee74" translate="yes" xml:space="preserve">
          <source>While the hook is being called, the new &lt;code&gt;ConstantCallSite&lt;/code&gt; object is in a partially constructed state. In this state, a call to &lt;code&gt;getTarget&lt;/code&gt;, or any other attempt to use the target, will result in an &lt;code&gt;IllegalStateException&lt;/code&gt;. It is legal at all times to obtain the call site's type using the &lt;code&gt;type&lt;/code&gt; method.</source>
          <target state="translated">在调用该挂钩时，新的 &lt;code&gt;ConstantCallSite&lt;/code&gt; 对象处于部分构造的状态。在这种状态下，对 &lt;code&gt;getTarget&lt;/code&gt; 的调用或任何其他使用该目标的尝试将导致 &lt;code&gt;IllegalStateException&lt;/code&gt; 。在任何时候使用 &lt;code&gt;type&lt;/code&gt; 方法获取呼叫站点的类型都是合法的。</target>
        </trans-unit>
        <trans-unit id="e64de2c787d87b6255db69fb316860954d89cac4" translate="yes" xml:space="preserve">
          <source>While the scoping mechanism for &lt;code&gt;synchronized&lt;/code&gt; methods and statements makes it much easier to program with monitor locks, and helps avoid many common programming errors involving locks, there are occasions where you need to work with locks in a more flexible way. For example, some algorithms for traversing concurrently accessed data structures require the use of &quot;hand-over-hand&quot; or &quot;chain locking&quot;: you acquire the lock of node A, then node B, then release A and acquire C, then release B and acquire D and so on. Implementations of the &lt;code&gt;Lock&lt;/code&gt; interface enable the use of such techniques by allowing a lock to be acquired and released in different scopes, and allowing multiple locks to be acquired and released in any order.</source>
          <target state="translated">尽管用于 &lt;code&gt;synchronized&lt;/code&gt; 方法和语句的作用域机制使使用监视器锁的编程变得更加容易，并且有助于避免许多常见的涉及锁的编程错误，但在某些情况下，您需要以更灵活的方式使用锁。例如，某些用于遍历并发访问的数据结构的算法需要使用&amp;ldquo;移交&amp;rdquo;或&amp;ldquo;链锁&amp;rdquo;：您获取节点A的锁，然后获取节点B的锁，然后释放A并获取C，然后释放B并获得D等。所述的实施方式中 &lt;code&gt;Lock&lt;/code&gt; 接口通过允许获得并在不同的范围释放的锁，并允许获得并以任何顺序释放多个锁使得能够使用这样的技术。</target>
        </trans-unit>
        <trans-unit id="e4da0d73a5a72455f5512b34b17d391abf383ff0" translate="yes" xml:space="preserve">
          <source>While the specification of this method in the &lt;a href=&quot;writer#write(java.lang.String,int,int)&quot;&gt;superclass&lt;/a&gt; recommends that an &lt;a href=&quot;../lang/indexoutofboundsexception&quot;&gt;&lt;code&gt;IndexOutOfBoundsException&lt;/code&gt;&lt;/a&gt; be thrown if &lt;code&gt;len&lt;/code&gt; is negative or &lt;code&gt;off + len&lt;/code&gt; is negative, the implementation in this class does not throw such an exception in these cases but instead simply writes no characters.</source>
          <target state="translated">尽管&lt;a href=&quot;writer#write(java.lang.String,int,int)&quot;&gt;超类&lt;/a&gt;中此方法的规范建议，如果 &lt;code&gt;len&lt;/code&gt; 为负或 &lt;code&gt;off + len&lt;/code&gt; 为负，则抛出&lt;a href=&quot;../lang/indexoutofboundsexception&quot;&gt; &lt;code&gt;IndexOutOfBoundsException&lt;/code&gt; &lt;/a&gt;，但是此类中的实现在这些情况下不会引发此类异常，而只是不写任何字符。</target>
        </trans-unit>
        <trans-unit id="2fa594a26798c1bce1231654fe91cf1056a98394" translate="yes" xml:space="preserve">
          <source>While the stream is open, the &lt;code&gt;append(char)&lt;/code&gt;, &lt;code&gt;
 append(CharSequence)&lt;/code&gt;, &lt;code&gt;append(CharSequence, int, int)&lt;/code&gt;, &lt;code&gt;flush()&lt;/code&gt;, &lt;code&gt;write(int)&lt;/code&gt;, &lt;code&gt;write(char[])&lt;/code&gt;, and &lt;code&gt;write(char[], int, int)&lt;/code&gt; methods do nothing. After the stream has been closed, these methods all throw &lt;code&gt;IOException&lt;/code&gt;.</source>
          <target state="translated">当流打开时， &lt;code&gt;append(char)&lt;/code&gt; ， &lt;code&gt; append(CharSequence)&lt;/code&gt; ， &lt;code&gt;append(CharSequence, int, int)&lt;/code&gt; ， &lt;code&gt;flush()&lt;/code&gt; ， &lt;code&gt;write(int)&lt;/code&gt; ， &lt;code&gt;write(char[])&lt;/code&gt; 和 &lt;code&gt;write(char[], int, int)&lt;/code&gt; 方法什么也不做。在关闭流之后，这些方法都将抛出 &lt;code&gt;IOException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d7b18e67ae96f95fb89082471b6693cb13e2e148" translate="yes" xml:space="preserve">
          <source>While the stream is open, the &lt;code&gt;available()&lt;/code&gt;, &lt;code&gt;read()&lt;/code&gt;, &lt;code&gt;read(byte[])&lt;/code&gt;, &lt;code&gt;read(byte[], int, int)&lt;/code&gt;, &lt;code&gt;readAllBytes()&lt;/code&gt;, &lt;code&gt;readNBytes(byte[], int, int)&lt;/code&gt;, &lt;code&gt;readNBytes(int)&lt;/code&gt;, &lt;code&gt;skip(long)&lt;/code&gt;, &lt;code&gt;skipNBytes(long)&lt;/code&gt;, and &lt;code&gt;transferTo()&lt;/code&gt; methods all behave as if end of stream has been reached. After the stream has been closed, these methods all throw &lt;code&gt;IOException&lt;/code&gt;.</source>
          <target state="translated">当流打开时， &lt;code&gt;available()&lt;/code&gt; ， &lt;code&gt;read()&lt;/code&gt; ， &lt;code&gt;read(byte[])&lt;/code&gt; ， &lt;code&gt;read(byte[], int, int)&lt;/code&gt; ， &lt;code&gt;readAllBytes()&lt;/code&gt; ， &lt;code&gt;readNBytes(byte[], int, int)&lt;/code&gt; ， &lt;code&gt;readNBytes(int)&lt;/code&gt; ， &lt;code&gt;skip(long)&lt;/code&gt; ， &lt;code&gt;skipNBytes(long)&lt;/code&gt; 和 &lt;code&gt;transferTo()&lt;/code&gt; 方法的行为都好像已到达流的末尾。在关闭流之后，这些方法都将抛出 &lt;code&gt;IOException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9f27c207d45817eb6f9a257c7c530eb9bfcf4665" translate="yes" xml:space="preserve">
          <source>While the stream is open, the &lt;code&gt;available()&lt;/code&gt;, &lt;code&gt;read()&lt;/code&gt;, &lt;code&gt;read(byte[])&lt;/code&gt;, &lt;code&gt;read(byte[], int, int)&lt;/code&gt;, &lt;code&gt;readAllBytes()&lt;/code&gt;, &lt;code&gt;readNBytes(byte[], int, int)&lt;/code&gt;, &lt;code&gt;readNBytes(int)&lt;/code&gt;, &lt;code&gt;skip(long)&lt;/code&gt;, and &lt;code&gt;transferTo()&lt;/code&gt; methods all behave as if end of stream has been reached. After the stream has been closed, these methods all throw &lt;code&gt;IOException&lt;/code&gt;.</source>
          <target state="translated">当流打开时， &lt;code&gt;available()&lt;/code&gt; ， &lt;code&gt;read()&lt;/code&gt; ， &lt;code&gt;read(byte[])&lt;/code&gt; ， &lt;code&gt;read(byte[], int, int)&lt;/code&gt; ， &lt;code&gt;readAllBytes()&lt;/code&gt; ， &lt;code&gt;readNBytes(byte[], int, int)&lt;/code&gt; ， &lt;code&gt;readNBytes(int)&lt;/code&gt; ， &lt;code&gt;skip(long)&lt;/code&gt; 和 &lt;code&gt;transferTo()&lt;/code&gt; 方法的行为都好像已到达流的末尾。在关闭流之后，这些方法都将抛出 &lt;code&gt;IOException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="915add191b3db03099891be3aeb321c9cad7cf68" translate="yes" xml:space="preserve">
          <source>While the stream is open, the &lt;code&gt;read()&lt;/code&gt;, &lt;code&gt;read(char[])&lt;/code&gt;, &lt;code&gt;read(char[], int, int)&lt;/code&gt;, &lt;code&gt;read(CharBuffer)&lt;/code&gt;, &lt;code&gt;
 ready()&lt;/code&gt;, &lt;code&gt;skip(long)&lt;/code&gt;, and &lt;code&gt;transferTo()&lt;/code&gt; methods all behave as if end of stream has been reached. After the stream has been closed, these methods all throw &lt;code&gt;IOException&lt;/code&gt;.</source>
          <target state="translated">当流打开时， &lt;code&gt;read()&lt;/code&gt; ， &lt;code&gt;read(char[])&lt;/code&gt; ， &lt;code&gt;read(char[], int, int)&lt;/code&gt; ， &lt;code&gt;read(CharBuffer)&lt;/code&gt; ， &lt;code&gt; ready()&lt;/code&gt; ， &lt;code&gt;skip(long)&lt;/code&gt; 和 &lt;code&gt;transferTo()&lt;/code&gt; 方法都起作用好像已经到达流的尽头了。在关闭流之后，这些方法都将抛出 &lt;code&gt;IOException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="354a3e678c0afc6d9c995cad19836af2c60e94bf" translate="yes" xml:space="preserve">
          <source>While the stream is open, the &lt;code&gt;read()&lt;/code&gt;, &lt;code&gt;read(char[])&lt;/code&gt;, &lt;code&gt;read(char[], int, int)&lt;/code&gt;, &lt;code&gt;read(Charbuffer)&lt;/code&gt;, &lt;code&gt;
 ready()&lt;/code&gt;, &lt;code&gt;skip(long)&lt;/code&gt;, and &lt;code&gt;transferTo()&lt;/code&gt; methods all behave as if end of stream has been reached. After the stream has been closed, these methods all throw &lt;code&gt;IOException&lt;/code&gt;.</source>
          <target state="translated">当流打开时， &lt;code&gt;read()&lt;/code&gt; ， &lt;code&gt;read(char[])&lt;/code&gt; ， &lt;code&gt;read(char[], int, int)&lt;/code&gt; ， &lt;code&gt;read(Charbuffer)&lt;/code&gt; ， &lt;code&gt; ready()&lt;/code&gt; ， &lt;code&gt;skip(long)&lt;/code&gt; 和 &lt;code&gt;transferTo()&lt;/code&gt; 方法都起作用好像已经到达流的尽头了。在关闭流之后，这些方法都将抛出 &lt;code&gt;IOException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="38e5439eae991a55c97ddfd38870798ef229cbcd" translate="yes" xml:space="preserve">
          <source>While the stream is open, the &lt;code&gt;write(int)&lt;/code&gt;, &lt;code&gt;
 write(byte[])&lt;/code&gt;, and &lt;code&gt;write(byte[], int, int)&lt;/code&gt; methods do nothing. After the stream has been closed, these methods all throw &lt;code&gt;
 IOException&lt;/code&gt;.</source>
          <target state="translated">当流打开时， &lt;code&gt;write(int)&lt;/code&gt; ， &lt;code&gt; write(byte[])&lt;/code&gt; 和 &lt;code&gt;write(byte[], int, int)&lt;/code&gt; 方法什么都不做。在关闭流之后，这些方法都将抛出 &lt;code&gt; IOException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dc1904d24dfdb2dc325b56134c9dce9b4ddaba55" translate="yes" xml:space="preserve">
          <source>While the unit of time of the return value is milliseconds, the granularity of the value depends on the underlying file system and may be larger. For example, some file systems use time stamps in units of seconds.</source>
          <target state="translated">虽然返回值的时间单位是毫秒,但该值的粒度取决于底层文件系统,可能会更大。例如,一些文件系统使用以秒为单位的时间戳。</target>
        </trans-unit>
        <trans-unit id="71a236fbeded33e61e30714b2af91dd5dfd1beff" translate="yes" xml:space="preserve">
          <source>While this class has been part of swing for a while now, it is public as of 1.4.</source>
          <target state="translated">虽然这个类已经成为swing的一部分有一段时间了,但它在1.4时已经公开了。</target>
        </trans-unit>
        <trans-unit id="6ebba50ef7f7692c7039eeb694af9a571417cf59" translate="yes" xml:space="preserve">
          <source>While this class inherits from &lt;a href=&quot;threadpoolexecutor&quot;&gt;&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;&lt;/a&gt;, a few of the inherited tuning methods are not useful for it. In particular, because it acts as a fixed-sized pool using &lt;code&gt;corePoolSize&lt;/code&gt; threads and an unbounded queue, adjustments to &lt;code&gt;maximumPoolSize&lt;/code&gt; have no useful effect. Additionally, it is almost never a good idea to set &lt;code&gt;corePoolSize&lt;/code&gt; to zero or use &lt;code&gt;allowCoreThreadTimeOut&lt;/code&gt; because this may leave the pool without threads to handle tasks once they become eligible to run.</source>
          <target state="translated">尽管此类从&lt;a href=&quot;threadpoolexecutor&quot;&gt; &lt;code&gt;ThreadPoolExecutor&lt;/code&gt; &lt;/a&gt;继承，但是一些继承的调整方法对此没有用。特别是，由于它使用 &lt;code&gt;corePoolSize&lt;/code&gt; 线程和无限制队列充当固定大小的池，因此对 &lt;code&gt;maximumPoolSize&lt;/code&gt; 的调整没有任何作用。此外，将 &lt;code&gt;corePoolSize&lt;/code&gt; 设置为零或使用 &lt;code&gt;allowCoreThreadTimeOut&lt;/code&gt; 几乎不是一个好主意，因为一旦有资格运行任务，这可能会使池中没有线程来处理任务。</target>
        </trans-unit>
        <trans-unit id="37f43590d9884fbad9cdec8f02f0705df36bced7" translate="yes" xml:space="preserve">
          <source>While this interface method is declared to throw &lt;code&gt;
 Exception&lt;/code&gt;, implementers are &lt;em&gt;strongly&lt;/em&gt; encouraged to declare concrete implementations of the &lt;code&gt;close&lt;/code&gt; method to throw more specific exceptions, or to throw no exception at all if the close operation cannot fail.</source>
          <target state="translated">虽然声明此接口方法抛出 &lt;code&gt; Exception&lt;/code&gt; ，但&lt;em&gt;强烈&lt;/em&gt;建议实现者声明 &lt;code&gt;close&lt;/code&gt; 方法的具体实现以抛出更具体的异常，或者如果close操作不会失败，则根本不抛出任何异常。</target>
        </trans-unit>
        <trans-unit id="1c294c7b4d4f86f3493751e198f59f458ef4183c" translate="yes" xml:space="preserve">
          <source>While this interface method is declared to throw &lt;code&gt;Exception&lt;/code&gt;, implementers are &lt;em&gt;strongly&lt;/em&gt; encouraged to declare concrete implementations of the &lt;code&gt;close&lt;/code&gt; method to throw more specific exceptions, or to throw no exception at all if the close operation cannot fail.</source>
          <target state="translated">尽管声明此接口方法抛出 &lt;code&gt;Exception&lt;/code&gt; ，但&lt;em&gt;强烈&lt;/em&gt;建议实现者声明 &lt;code&gt;close&lt;/code&gt; 方法的具体实现以抛出更具体的异常，或者如果close操作不会失败，则根本不抛出任何异常。</target>
        </trans-unit>
        <trans-unit id="5aafec2ecc872a5e693872afd5344f871ab06e7e" translate="yes" xml:space="preserve">
          <source>While this is a public method, this is typically only useful for subclassers of &lt;code&gt;JFormattedTextField&lt;/code&gt;. &lt;code&gt;JFormattedTextField&lt;/code&gt; will invoke this method at the appropriate times when the value changes, or its internal state changes.</source>
          <target state="translated">尽管这是一个公共方法，但通常仅对 &lt;code&gt;JFormattedTextField&lt;/code&gt; 的子类有用。当值更改或其内部状态更改时， &lt;code&gt;JFormattedTextField&lt;/code&gt; 将在适当的时间调用此方法。</target>
        </trans-unit>
        <trans-unit id="79111a912067f71a2c429865902e2e2dfdb6357a" translate="yes" xml:space="preserve">
          <source>While this is a public method, this is typically only useful for subclassers of &lt;code&gt;JFormattedTextField&lt;/code&gt;. &lt;code&gt;JFormattedTextField&lt;/code&gt; will invoke this method at the appropriate times when the value changes, or its internal state changes. You will only need to invoke this yourself if you are subclassing &lt;code&gt;JFormattedTextField&lt;/code&gt; and installing/uninstalling &lt;code&gt;AbstractFormatter&lt;/code&gt; at a different time than &lt;code&gt;JFormattedTextField&lt;/code&gt; does.</source>
          <target state="translated">尽管这是一个公共方法，但通常仅对 &lt;code&gt;JFormattedTextField&lt;/code&gt; 的子类有用。当值更改或其内部状态更改时， &lt;code&gt;JFormattedTextField&lt;/code&gt; 将在适当的时间调用此方法。仅当您 &lt;code&gt;JFormattedTextField&lt;/code&gt; 的子类并在与 &lt;code&gt;JFormattedTextField&lt;/code&gt; 不同的时间安装/卸载 &lt;code&gt;AbstractFormatter&lt;/code&gt; 时，才需要自己调用此方法。</target>
        </trans-unit>
        <trans-unit id="a8962e33fe4ae692b6f0669c0b0060997d23406a" translate="yes" xml:space="preserve">
          <source>While this may seem a more roundabout way to perform an aggregation compared to simply mutating a running total in a loop, reduction operations parallelize more gracefully, without needing additional synchronization and with greatly reduced risk of data races.</source>
          <target state="translated">虽然与简单地在循环中突变一个运行的总量相比,这似乎是一种更迂回的执行聚合的方式,但还原操作的并行化更加优雅,不需要额外的同步,而且大大降低了数据竞赛的风险。</target>
        </trans-unit>
        <trans-unit id="a47a2652b0c502dd1c763501db1290a29367490b" translate="yes" xml:space="preserve">
          <source>While this method is public, it should only be invoked by the &lt;code&gt;UIManager&lt;/code&gt; when the look and feel is set as the current look and feel and after &lt;code&gt;initialize&lt;/code&gt; has been invoked.</source>
          <target state="translated">尽管此方法是公共的，但只有在将外观设置为当前外观并在调用了 &lt;code&gt;initialize&lt;/code&gt; 之后，才应由 &lt;code&gt;UIManager&lt;/code&gt; 调用它。</target>
        </trans-unit>
        <trans-unit id="80a95185dab9cb4d4601e61790a61c53f8e58816" translate="yes" xml:space="preserve">
          <source>While this method returns an array of &lt;code&gt;
 Constructor&amp;lt;T&amp;gt;&lt;/code&gt; objects (that is an array of constructors from this class), the return type of this method is &lt;code&gt;
 Constructor&amp;lt;?&amp;gt;[]&lt;/code&gt; and &lt;em&gt;not&lt;/em&gt;&lt;code&gt;Constructor&amp;lt;T&amp;gt;[]&lt;/code&gt; as might be expected. This less informative return type is necessary since after being returned from this method, the array could be modified to hold &lt;code&gt;Constructor&lt;/code&gt; objects for different classes, which would violate the type guarantees of &lt;code&gt;Constructor&amp;lt;T&amp;gt;[]&lt;/code&gt;.</source>
          <target state="translated">虽然此方法返回一个 &lt;code&gt; Constructor&amp;lt;T&amp;gt;&lt;/code&gt; 对象的数组（也就是此类的构造函数的数组），但此方法的返回类型为 &lt;code&gt; Constructor&amp;lt;?&amp;gt;[]&lt;/code&gt; 而&lt;em&gt;不是&lt;/em&gt;预期的&lt;em&gt;不是&lt;/em&gt; &lt;code&gt;Constructor&amp;lt;T&amp;gt;[]&lt;/code&gt; 。这种信息量较少的返回类型是必需的，因为从此方法返回后，可以修改该数组以容纳不同类的 &lt;code&gt;Constructor&lt;/code&gt; 对象，这将违反 &lt;code&gt;Constructor&amp;lt;T&amp;gt;[]&lt;/code&gt; 的类型保证。</target>
        </trans-unit>
        <trans-unit id="c581298e75ef5bf15df9b06bf2c664ea73c5c346" translate="yes" xml:space="preserve">
          <source>While writing an object via writeUnshared does not in itself guarantee a unique reference to the object when it is deserialized, it allows a single object to be defined multiple times in a stream, so that multiple calls to readUnshared by the receiver will not conflict. Note that the rules described above only apply to the base-level object written with writeUnshared, and not to any transitively referenced sub-objects in the object graph to be serialized.</source>
          <target state="translated">虽然通过writeUnshared写入对象本身并不能保证在反序列化时对该对象的唯一引用,但它允许一个对象在一个流中被多次定义,这样接收器对readUnshared的多次调用就不会发生冲突。需要注意的是,上述规则只适用于用writeUnshared写入的基级对象,而不适用于对象图中任何要序列化的中转引用的子对象。</target>
        </trans-unit>
        <trans-unit id="6b0d3c4f0480a5e74d5383ac9ba2edc90d882c39" translate="yes" xml:space="preserve">
          <source>WhileLoopTree</source>
          <target state="translated">WhileLoopTree</target>
        </trans-unit>
        <trans-unit id="5da2d68669a03b947051233558b6ce56e6780f0a" translate="yes" xml:space="preserve">
          <source>White_Space</source>
          <target state="translated">White_Space</target>
        </trans-unit>
        <trans-unit id="325016380fb9842b99430cbb0b7cb06becabcdfe" translate="yes" xml:space="preserve">
          <source>Whitespace is allowed on either side of ',', ';', '=', and '+'. Such whitespace is accepted but not generated by this code, and is ignored when comparing names.</source>
          <target state="translated">',',';','=',和'+'两边都允许使用空格。这种空白是被接受的,但不是由这段代码产生的,在比较名字时被忽略。</target>
        </trans-unit>
        <trans-unit id="3ef5e18e6403c342fcf6ad4db4c278abb2cb9d38" translate="yes" xml:space="preserve">
          <source>Whitespace is not significant in the above regular expressions.</source>
          <target state="translated">在上述正则表达式中,空格并不重要。</target>
        </trans-unit>
        <trans-unit id="6d620fb7a85a0616f4a4e6e9dda029e04472a323" translate="yes" xml:space="preserve">
          <source>Wide Area Information Server (WAIS) protocol.</source>
          <target state="translated">广域信息服务器(WAIS)协议。</target>
        </trans-unit>
        <trans-unit id="4088f5317f57ea6f119849410abea3f8143240d0" translate="yes" xml:space="preserve">
          <source>Widget for user to</source>
          <target state="translated">供用户使用的小工具</target>
        </trans-unit>
        <trans-unit id="a58ddf50c5ea5c03802da919dd5953bbf82ebd74" translate="yes" xml:space="preserve">
          <source>Width</source>
          <target state="translated">Width</target>
        </trans-unit>
        <trans-unit id="969d00f2cb9efe3539d44d8c60c74f5ad9d4d231" translate="yes" xml:space="preserve">
          <source>Width in pixels of the region of image data that this SampleModel describes.</source>
          <target state="translated">该SampleModel描述的图像数据区域的宽度,以像素为单位。</target>
        </trans-unit>
        <trans-unit id="ad438ebb7fecc02d85771ba7a5e164704291d2aa" translate="yes" xml:space="preserve">
          <source>Width margin between each column</source>
          <target state="translated">每列之间的宽度边距</target>
        </trans-unit>
        <trans-unit id="2b1391aceba26f92ebfa3692913a873cad2e88d4" translate="yes" xml:space="preserve">
          <source>Width of border around image.</source>
          <target state="translated">图像周围边框的宽度。</target>
        </trans-unit>
        <trans-unit id="1962f060f9fe9059e9a8a6c80aa4a55652760749" translate="yes" xml:space="preserve">
          <source>Width of border around image. See the border attribute definition in HTML 4.0. This attribute is deprecated in HTML 4.0.</source>
          <target state="translated">图片周围边框的宽度。参见HTML 4.0中border属性的定义。这个属性在HTML 4.0中已被废弃。</target>
        </trans-unit>
        <trans-unit id="25d4e6ae97de9d8e0668c4d723b13f4d0fb48f3e" translate="yes" xml:space="preserve">
          <source>Width of border around the object.</source>
          <target state="translated">对象周围的边框宽度。</target>
        </trans-unit>
        <trans-unit id="da0c6f8902b918d8abe553b58cfd7895baa25253" translate="yes" xml:space="preserve">
          <source>Width of border around the object. See the border attribute definition in HTML 4.0. This attribute is deprecated in HTML 4.0.</source>
          <target state="translated">对象周围的边框宽度。参见HTML 4.0中border属性的定义。此属性在HTML 4.0中已被废弃。</target>
        </trans-unit>
        <trans-unit id="a0e3d6c9d2f09610830e5f522f7dc3562cd09301" translate="yes" xml:space="preserve">
          <source>Width of control (in characters).</source>
          <target state="translated">控制的宽度(字符)。</target>
        </trans-unit>
        <trans-unit id="1fff79d676a28a0dd3d706794781c8d39249359f" translate="yes" xml:space="preserve">
          <source>Width of control (in characters). See the cols attribute definition in HTML 4.0.</source>
          <target state="translated">控件的宽度(单位:字符)。参见HTML 4.0中cols属性的定义。</target>
        </trans-unit>
        <trans-unit id="50794f4688ae96bdb4341321c3ffa61a405c19eb" translate="yes" xml:space="preserve">
          <source>Width of the back buffers</source>
          <target state="translated">后置缓冲器的宽度</target>
        </trans-unit>
        <trans-unit id="9c249f6d47c523ac145af2ace67f2b7577b5b942" translate="yes" xml:space="preserve">
          <source>Width or height of the divider based on orientation &lt;code&gt;BasicSplitPaneUI&lt;/code&gt; adds two to this.</source>
          <target state="translated">基于方向 &lt;code&gt;BasicSplitPaneUI&lt;/code&gt; 的分隔线的宽度或高度为此添加了两个。</target>
        </trans-unit>
        <trans-unit id="c3145705b3544273fd612b777459ce0a3125581a" translate="yes" xml:space="preserve">
          <source>WildcardTree</source>
          <target state="translated">WildcardTree</target>
        </trans-unit>
        <trans-unit id="d5208bbe059aa1046c3f08361ea1e178ca24d291" translate="yes" xml:space="preserve">
          <source>WildcardType</source>
          <target state="translated">WildcardType</target>
        </trans-unit>
        <trans-unit id="66c44a9ca081e2d89075ec9d49d2689c74584a8a" translate="yes" xml:space="preserve">
          <source>WildcardType represents a wildcard type expression, such as &lt;code&gt;?&lt;/code&gt;, &lt;code&gt;? extends Number&lt;/code&gt;, or &lt;code&gt;? super Integer&lt;/code&gt;.</source>
          <target state="translated">WildcardType表示通配符类型表达式，例如 &lt;code&gt;?&lt;/code&gt; ， &lt;code&gt;? extends Number&lt;/code&gt; 还是 &lt;code&gt;? super Integer&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ce867c4c796e6dbe1d3e38766feb789822009ee1" translate="yes" xml:space="preserve">
          <source>WildcardType.getExtendsBound()</source>
          <target state="translated">WildcardType.getExtendsBound()</target>
        </trans-unit>
        <trans-unit id="330bde92db69c2198109194787e6c21b7478f2c0" translate="yes" xml:space="preserve">
          <source>WildcardType.getLowerBounds()</source>
          <target state="translated">WildcardType.getLowerBounds()</target>
        </trans-unit>
        <trans-unit id="f81da7284909bf43711682454467244f68db18a0" translate="yes" xml:space="preserve">
          <source>WildcardType.getSuperBound()</source>
          <target state="translated">WildcardType.getSuperBound()</target>
        </trans-unit>
        <trans-unit id="97172c5abf520854245e039ae23bd4e64bc5422f" translate="yes" xml:space="preserve">
          <source>WildcardType.getUpperBounds()</source>
          <target state="translated">WildcardType.getUpperBounds()</target>
        </trans-unit>
        <trans-unit id="521d06dd779ba79ee4cea678dbe14d70dbe38387" translate="yes" xml:space="preserve">
          <source>Will be &lt;code&gt;null&lt;/code&gt; if &lt;code&gt;java.awt.Image&lt;/code&gt; is not visible, the &lt;code&gt;java.desktop&lt;/code&gt; module is not loaded, or the &lt;code&gt;java.desktop&lt;/code&gt; module is not in the run-time image.</source>
          <target state="translated">将 &lt;code&gt;null&lt;/code&gt; 如果 &lt;code&gt;java.awt.Image&lt;/code&gt; 中是不可见的，在 &lt;code&gt;java.desktop&lt;/code&gt; 模块没有加载，或者 &lt;code&gt;java.desktop&lt;/code&gt; 模块不运行时映像中。</target>
        </trans-unit>
        <trans-unit id="d33509e2ec308e6546857b8da6aba57cee35ab90" translate="yes" xml:space="preserve">
          <source>Will be called to see whether or not this cookie should be accepted.</source>
          <target state="translated">将被调用,以确定是否应该接受这个cookie。</target>
        </trans-unit>
        <trans-unit id="37fa7a262702fe582d3a1dccfa6ad0f9944b59d4" translate="yes" xml:space="preserve">
          <source>Will check the role according to its corresponding role definition provided in relation's relation type</source>
          <target state="translated">将根据关系类型中提供的相应角色定义检查角色。</target>
        </trans-unit>
        <trans-unit id="6ccf06bf2935ecc384eb6df2769fb29a28f7bd2b" translate="yes" xml:space="preserve">
          <source>Will not always find a match (or the correct match) if some part of the parse is ambiguous. For example, if the pattern &quot;{1},{2}&quot; is used with the string arguments {&quot;a,b&quot;, &quot;c&quot;}, it will format as &quot;a,b,c&quot;. When the result is parsed, it will return {&quot;a&quot;, &quot;b,c&quot;}.</source>
          <target state="translated">如果解析的某些部分含糊不清,将不一定能找到匹配(或正确的匹配)。例如,如果模式&quot;{1},{2}&quot;与字符串参数{&quot;a,b&quot;,&quot;c&quot;}一起使用,它将格式化为 &quot;a,b,c&quot;。当解析结果时,它将返回{&quot;a&quot;,&quot;b,c&quot;}。</target>
        </trans-unit>
        <trans-unit id="c58deb92d1c5c729de051dba7b43a35ac3101b21" translate="yes" xml:space="preserve">
          <source>Will not see uncommitted data (make &quot;dirty&quot; reads).</source>
          <target state="translated">不会看到未提交的数据(进行 &quot;脏 &quot;读)。</target>
        </trans-unit>
        <trans-unit id="d669a272be58163914a204bccea56c09fa69e531" translate="yes" xml:space="preserve">
          <source>Will send a notification (RelationNotification with type RELATION_BASIC_UPDATE or RELATION_MBEAN_UPDATE, depending if the relation is a MBean or not).</source>
          <target state="translated">将发送一个通知(RelationNotification,类型为Relation_BASIC_UPDATE或Relation_MBEAN_UPDATE,取决于关系是否是MBean)。</target>
        </trans-unit>
        <trans-unit id="c456f440fcf296338c58bf917ef98c5c5d7bac84" translate="yes" xml:space="preserve">
          <source>Will send one notification (RelationNotification with type RELATION_BASIC_UPDATE or RELATION_MBEAN_UPDATE, depending if the relation is a MBean or not) per updated role.</source>
          <target state="translated">将为每个更新的角色发送一个通知(类型为Relation_BASIC_UPDATE或Relation_MBEAN_UPDATE的RelationNotification,取决于关系是否是MBean)。</target>
        </trans-unit>
        <trans-unit id="af60309eed9f0f92d76603dc55ac020d8599207d" translate="yes" xml:space="preserve">
          <source>Will start editing for node if there is a &lt;code&gt;cellEditor&lt;/code&gt; and &lt;code&gt;shouldSelectCell&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">如果存在 &lt;code&gt;cellEditor&lt;/code&gt; 且 &lt;code&gt;shouldSelectCell&lt;/code&gt; 返回 &lt;code&gt;true&lt;/code&gt; ，则将开始为节点进行编辑。</target>
        </trans-unit>
        <trans-unit id="c95d75c28c35065fc1c57b0e876887193f122021" translate="yes" xml:space="preserve">
          <source>WinListener</source>
          <target state="translated">WinListener</target>
        </trans-unit>
        <trans-unit id="41dfc0a6c92707948578891c51d98c6443be63cc" translate="yes" xml:space="preserve">
          <source>Window</source>
          <target state="translated">Window</target>
        </trans-unit>
        <trans-unit id="5084a061070a3f1aa4d1ecab3a00df323a3b610e" translate="yes" xml:space="preserve">
          <source>Window events are enabled via &lt;code&gt;enableEvents&lt;/code&gt;</source>
          <target state="translated">窗口事件通过 &lt;code&gt;enableEvents&lt;/code&gt; 启用</target>
        </trans-unit>
        <trans-unit id="652b21379200b4ccc460b4492fe0d5374614171a" translate="yes" xml:space="preserve">
          <source>Window focus events are enabled via &lt;code&gt;enableEvents&lt;/code&gt;</source>
          <target state="translated">窗口焦点事件通过 &lt;code&gt;enableEvents&lt;/code&gt; 启用</target>
        </trans-unit>
        <trans-unit id="8ac26c71e069b6eaa7e969b40aec9f9b5620310d" translate="yes" xml:space="preserve">
          <source>Window.AccessibleAWTWindow</source>
          <target state="translated">Window.AccessibleAWTWindow</target>
        </trans-unit>
        <trans-unit id="507611730a02b402edd6e7ba76a6fcebba9f788e" translate="yes" xml:space="preserve">
          <source>Window.Type</source>
          <target state="translated">Window.Type</target>
        </trans-unit>
        <trans-unit id="5dca9b99152803aee06162ae5e180ed80d355a7c" translate="yes" xml:space="preserve">
          <source>WindowAdapter</source>
          <target state="translated">WindowAdapter</target>
        </trans-unit>
        <trans-unit id="d30877c43152fe36a3fd859538a40a5cdaf9bfe2" translate="yes" xml:space="preserve">
          <source>WindowConstants</source>
          <target state="translated">WindowConstants</target>
        </trans-unit>
        <trans-unit id="506bdfc6c0c9e73aacc009ccc59240f421dee55e" translate="yes" xml:space="preserve">
          <source>WindowEvent</source>
          <target state="translated">WindowEvent</target>
        </trans-unit>
        <trans-unit id="389aeec541bb01caf058a1c61a1a55c203773d3c" translate="yes" xml:space="preserve">
          <source>WindowFocusListener</source>
          <target state="translated">WindowFocusListener</target>
        </trans-unit>
        <trans-unit id="d1e4bbe2f756a9e07443c61cb2a25527b3f01627" translate="yes" xml:space="preserve">
          <source>WindowListener</source>
          <target state="translated">WindowListener</target>
        </trans-unit>
        <trans-unit id="36d800c05ccdf96a77f664405b24b1d515a7dcaa" translate="yes" xml:space="preserve">
          <source>WindowStateListener</source>
          <target state="translated">WindowStateListener</target>
        </trans-unit>
        <trans-unit id="b23f002c02bd817e7699352ab74ddf1956672a1c" translate="yes" xml:space="preserve">
          <source>Windows NT chooses to represent users, groups and realms (or domains) with not only common names, but also relatively unique numbers. These numbers are called Security IDentifiers, or SIDs. Windows NT also provides services that render these SIDs into string forms. This class represents these string forms.</source>
          <target state="translated">Windows NT选择用用户、组和域(或域)来表示用户、组和域,不仅有通用的名称,还有相对独特的数字。这些数字被称为安全IDentifiers,或SIDs。Windows NT 还提供了将这些 SID 呈现为字符串形式的服务。这个类表示这些字符串形式。</target>
        </trans-unit>
        <trans-unit id="a4ec586bd67aec6c5c53fd30fb990d116b2bc3ae" translate="yes" xml:space="preserve">
          <source>Windows are capable of generating the following WindowEvents: WindowOpened, WindowClosed, WindowGainedFocus, WindowLostFocus.</source>
          <target state="translated">窗口能够产生以下WindowEvents。WindowOpened、WindowClosed、WindowGainedFocus、WindowLostFocus。</target>
        </trans-unit>
        <trans-unit id="e736d7e9cd07fdd5619eb22e9d6ea04daf0e51ae" translate="yes" xml:space="preserve">
          <source>Windows cannot overlap the full-screen window. All other application windows will always appear beneath the full-screen window in the Z-order.</source>
          <target state="translated">窗口不能与全屏窗口重叠。所有其他应用程序窗口将始终按Z顺序出现在全屏窗口的下方。</target>
        </trans-unit>
        <trans-unit id="593ac35fa2bd24a666d120e3789447fbf9c25e2a" translate="yes" xml:space="preserve">
          <source>WindowsNT/x86/4.0/lib/stat.dll</source>
          <target state="translated">WindowsNT/x86/4.0/lib/stat.dll</target>
        </trans-unit>
        <trans-unit id="564f8c6e76fbd512be2e38dabdfdd61550d0c3cc" translate="yes" xml:space="preserve">
          <source>With</source>
          <target state="translated">With</target>
        </trans-unit>
        <trans-unit id="de916a95a394d60b5970c72c8e49b95595c376f5" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;SEPARATE_DOCUMENTS_UNCOLLATED_COPIES&lt;/code&gt; and &lt;code&gt;SEPARATE_DOCUMENTS_COLLATED_COPIES&lt;/code&gt;, documents &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are stapled separately.</source>
          <target state="translated">使用 &lt;code&gt;SEPARATE_DOCUMENTS_UNCOLLATED_COPIES&lt;/code&gt; 和 &lt;code&gt;SEPARATE_DOCUMENTS_COLLATED_COPIES&lt;/code&gt; ，文档 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 分别装订。</target>
        </trans-unit>
        <trans-unit id="ce065a2774362ea1c0b4b2a9c6d578002c87fa95" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;SINGLE_DOCUMENT&lt;/code&gt;, documents &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are stapled together as a single document with no regard to new sheets.</source>
          <target state="translated">使用 &lt;code&gt;SINGLE_DOCUMENT&lt;/code&gt; ，文档 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 被装订在一起作为单个文档，而与新工作表无关。</target>
        </trans-unit>
        <trans-unit id="000a0d000df5c6984649ddbd1ee6d53891ba7395" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;SINGLE_DOCUMENT_NEW_SHEET&lt;/code&gt;, documents &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are stapled together as a single document, but document &lt;code&gt;b&lt;/code&gt; starts on a new sheet.</source>
          <target state="translated">使用 &lt;code&gt;SINGLE_DOCUMENT_NEW_SHEET&lt;/code&gt; ，将文档 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 装订在一起作为一个文档，但是文档 &lt;code&gt;b&lt;/code&gt; 从新的纸张开始。</target>
        </trans-unit>
        <trans-unit id="702bb02b91946be2e7d1e7c71af340e7112b4fc2" translate="yes" xml:space="preserve">
          <source>With SEPARATE_DOCUMENTS_UNCOLLATED_COPIES and SEPARATE_DOCUMENTS_COLLATED_COPIES, documents &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are stapled separately.</source>
          <target state="translated">对于SEPARATE_DOCUMENTS_UNCOLLATED_COPIES和SEPARATE_DOCUMENTS_COLLATED_COPIES，文档 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 分别装订。</target>
        </trans-unit>
        <trans-unit id="c6940d372bef23c372a894b2611764845d087573" translate="yes" xml:space="preserve">
          <source>With SINGLE_DOCUMENT, documents &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are stapled together as a single document with no regard to new sheets.</source>
          <target state="translated">使用SINGLE_DOCUMENT，文档 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 装订在一起成为单个文档，而与新图纸无关。</target>
        </trans-unit>
        <trans-unit id="6aea5edd4595a1343229324f4788e3637ab7593b" translate="yes" xml:space="preserve">
          <source>With SINGLE_DOCUMENT_NEW_SHEET, documents &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are stapled together as a single document, but document &lt;code&gt;b&lt;/code&gt; starts on a new sheet.</source>
          <target state="translated">使用SINGLE_DOCUMENT_NEW_SHEET，文档 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 装订在一起成为一个文档，但是文档 &lt;code&gt;b&lt;/code&gt; 从新的纸张开始。</target>
        </trans-unit>
        <trans-unit id="7a7f0a9b6a27b5ea272b2faa2111b50312da5684" translate="yes" xml:space="preserve">
          <source>With Version 0 cookies, values should not contain white space, brackets, parentheses, equals signs, commas, double quotes, slashes, question marks, at signs, colons, and semicolons. Empty values may not behave the same way on all browsers.</source>
          <target state="translated">对于版本0的cookie,值不应包含空格、括号、小括号、等号、逗号、双引号、斜杠、问号、顿号、冒号和分号。空值在所有浏览器上的表现可能并不相同。</target>
        </trans-unit>
        <trans-unit id="bf66f17ae2780078f9fea48695737926c268f057" translate="yes" xml:space="preserve">
          <source>With a PermissionCollection, you can:</source>
          <target state="translated">通过一个PermissionCollection,你可以。</target>
        </trans-unit>
        <trans-unit id="ddf292b706b0ea961ebe157c83d2d5ff0fdfda77" translate="yes" xml:space="preserve">
          <source>With a reference to the &lt;code&gt;&amp;lt;widget&amp;gt;&lt;/code&gt; element, a relative XPath expression can be written to select the &lt;code&gt;&amp;lt;manufacturer&amp;gt;&lt;/code&gt; child element:</source>
          <target state="translated">通过引用 &lt;code&gt;&amp;lt;widget&amp;gt;&lt;/code&gt; 元素，可以编写一个相对的XPath表达式来选择 &lt;code&gt;&amp;lt;manufacturer&amp;gt;&lt;/code&gt; 子元素：</target>
        </trans-unit>
        <trans-unit id="7921a6a2bd87af6e70cb7478096f1f706c0eed48" translate="yes" xml:space="preserve">
          <source>With attribute type synonyms, a directory can assign multiple names to the same attribute. For example, &quot;cn&quot; and &quot;commonName&quot; might both refer to the same attribute. Asking for &quot;cn&quot; might return the &quot;commonName&quot; attribute.</source>
          <target state="translated">有了属性类型同义词,一个目录可以为同一个属性分配多个名称。例如,&quot;cn &quot;和 &quot;commonName &quot;可能都是指同一个属性。询问 &quot;cn &quot;可能会返回 &quot;commonName &quot;属性。</target>
        </trans-unit>
        <trans-unit id="342174bb35309e577ba49df9b6a0136aab3a5327" translate="yes" xml:space="preserve">
          <source>With both intervals and &lt;code&gt;Spring&lt;/code&gt;s we can define &quot;-&quot; and &lt;em&gt;min&lt;/em&gt; in terms of negation:</source>
          <target state="translated">通过interval和 &lt;code&gt;Spring&lt;/code&gt; ,我们可以根据否定定义&amp;ldquo;-&amp;rdquo;和&lt;em&gt;min&lt;/em&gt;：</target>
        </trans-unit>
        <trans-unit id="4b146947ce59686776207df75fa9d667325f9863" translate="yes" xml:space="preserve">
          <source>With most look and feels, the user can drag out a tool bar into a separate window (unless the &lt;code&gt;floatable&lt;/code&gt; property is set to &lt;code&gt;false&lt;/code&gt;). For drag-out to work correctly, it is recommended that you add &lt;code&gt;JToolBar&lt;/code&gt; instances to one of the four &quot;sides&quot; of a container whose layout manager is a &lt;code&gt;BorderLayout&lt;/code&gt;, and do not add children to any of the other four &quot;sides&quot;.</source>
          <target state="translated">通过大多数外观，用户可以将工具栏拖出到单独的窗口中（除非 &lt;code&gt;floatable&lt;/code&gt; 属性设置为 &lt;code&gt;false&lt;/code&gt; ）。为了使拖出正常工作，建议您将 &lt;code&gt;JToolBar&lt;/code&gt; 实例添加到其布局管理器是 &lt;code&gt;BorderLayout&lt;/code&gt; 的容器的四个&amp;ldquo;边&amp;rdquo;之一，并且不要将子对象添加到其他四个&amp;ldquo;边&amp;rdquo;中的任何一个。</target>
        </trans-unit>
        <trans-unit id="0aee19fea36c937253e601d256a319bb86142c5d" translate="yes" xml:space="preserve">
          <source>With some complex reduction operations, for example a &lt;code&gt;collect()&lt;/code&gt; that produces a &lt;code&gt;Map&lt;/code&gt;, such as:</source>
          <target state="translated">通过一些复杂的归约操作，例如产生 &lt;code&gt;Map&lt;/code&gt; 的 &lt;code&gt;collect()&lt;/code&gt; ，例如：</target>
        </trans-unit>
        <trans-unit id="5e5f811ed587d929e889b7d29ba9d4370ee0e985" translate="yes" xml:space="preserve">
          <source>With the above code, the health status is collected unnecessarily even when the log level FINER is disabled. With the Supplier-accepting version as below, the status will only be collected when the log level FINER is enabled.</source>
          <target state="translated">如果使用上述代码,即使禁用日志级别FINER,也会不必要地收集健康状态。在以下的供应商接受版本中,只有在启用日志级别FINER时才会收集状态。</target>
        </trans-unit>
        <trans-unit id="dc2156a4e2b3c1c33c618ec6f586c7ea7f4199d8" translate="yes" xml:space="preserve">
          <source>With the exception of re-imaging an entire document for multiple collated copies, the increasing page index order means that when page N is requested if a client needs to calculate page break position, it may safely discard any state related to pages &amp;lt; N, and make current that for page N. &quot;State&quot; usually is just the calculated position in the document that corresponds to the start of the page.</source>
          <target state="translated">除了为多个分页副本重新成像整个文档外，递增的页面索引顺序意味着如果客户端需要计算分页符位置时请求页面N时，它可以安全地丢弃与页面&amp;lt;N有关的任何状态，并且使当前状态为页面N。&amp;ldquo;状态&amp;rdquo;通常只是文档中与页面开头相对应的计算位置。</target>
        </trans-unit>
        <trans-unit id="2024497e2bf2f02b354dda9dd14a083e17ac2ff2" translate="yes" xml:space="preserve">
          <source>With the exception of selected printer, the PrinterJob state is not updated to reflect the user's changes. For the selections to affect a printer job, the attributes must be specified in the call to the &lt;code&gt;print(PrintRequestAttributeSet)&lt;/code&gt; method. If using the Pageable interface, clients which intend to use media selected by the user must create a PageFormat derived from the user's selections. If the user cancels the dialog, the attributes will not reflect any changes made by the user.</source>
          <target state="translated">除选定的打印机外，PrinterJob状态不会更新以反映用户的更改。为了使选择影响打印机作业，必须在对 &lt;code&gt;print(PrintRequestAttributeSet)&lt;/code&gt; 方法的调用中指定属性。如果使用Pageable接口，则打算使用用户选择的媒体的客户端必须创建从用户的选择派生的PageFormat。如果用户取消对话框，则属性将不会反映用户所做的任何更改。</target>
        </trans-unit>
        <trans-unit id="e344a6ab10b8325512c520c0690b8d3e445352c1" translate="yes" xml:space="preserve">
          <source>With the following HTML content:</source>
          <target state="translated">有以下HTML内容。</target>
        </trans-unit>
        <trans-unit id="618b01eeb003ee4b1ffdf3f6106417f6de534070" translate="yes" xml:space="preserve">
          <source>With the information retrieved from the methods &lt;code&gt;getStatus&lt;/code&gt; and &lt;code&gt;getConflictValue&lt;/code&gt;, the application may make a determination as to which value should be persisted in the data source. The application then calls the &lt;code&gt;SyncResolver&lt;/code&gt; method &lt;code&gt;setResolvedValue&lt;/code&gt;, which sets the value to be persisted in the &lt;code&gt;RowSet&lt;/code&gt; object and also in the data source.</source>
          <target state="translated">利用从方法 &lt;code&gt;getStatus&lt;/code&gt; 和 &lt;code&gt;getConflictValue&lt;/code&gt; 中检索到的信息，应用程序可以确定应在数据源中保留哪个值。然后，应用程序调用 &lt;code&gt;SyncResolver&lt;/code&gt; 方法 &lt;code&gt;setResolvedValue&lt;/code&gt; ，该方法设置要保留在 &lt;code&gt;RowSet&lt;/code&gt; 对象以及数据源中的值。</target>
        </trans-unit>
        <trans-unit id="c20e7358b9286868d2d9a41c8b600c7c286dd9b1" translate="yes" xml:space="preserve">
          <source>With this addition of a semicolon the input is a complete source snippet.</source>
          <target state="translated">加上这个分号后,输入就是一个完整的源码片段。</target>
        </trans-unit>
        <trans-unit id="9fa5906aa1c7ed8368080a25444cc18e3529411d" translate="yes" xml:space="preserve">
          <source>With this addition of a semicolon the input is a complete source snippet. This will only be returned when the end of input is encountered.</source>
          <target state="translated">这样加上分号后,输入就是一个完整的源码片段。只有在遇到输入结束的时候才会返回。</target>
        </trans-unit>
        <trans-unit id="e8ff6037d8867d2b3d47892d80515cedec13ebae" translate="yes" xml:space="preserve">
          <source>With this increased flexibility comes additional responsibility. The absence of block-structured locking removes the automatic release of locks that occurs with &lt;code&gt;synchronized&lt;/code&gt; methods and statements. In most cases, the following idiom should be used:</source>
          <target state="translated">灵活性的提高带来了额外的责任。缺少块结构锁定将消除 &lt;code&gt;synchronized&lt;/code&gt; 方法和语句发生的自动锁定释放。在大多数情况下，应使用以下惯用法：</target>
        </trans-unit>
        <trans-unit id="d3c389bbd15c03f9dd881098991d518ed6f3894d" translate="yes" xml:space="preserve">
          <source>Within a</source>
          <target state="translated">在一个</target>
        </trans-unit>
        <trans-unit id="eaa46bf4774a02d445fea7fa33dbb744f6506eaa" translate="yes" xml:space="preserve">
          <source>Within a &lt;code&gt;Document&lt;/code&gt;, &lt;code&gt;DocumentFragment&lt;/code&gt;, or &lt;code&gt;Entity&lt;/code&gt; being serialized, &lt;code&gt;Nodes&lt;/code&gt; are processed as follows</source>
          <target state="translated">在要序列化的 &lt;code&gt;Document&lt;/code&gt; ， &lt;code&gt;DocumentFragment&lt;/code&gt; 或 &lt;code&gt;Entity&lt;/code&gt; 内，按以下方式处理 &lt;code&gt;Nodes&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0d2a1649d264fff3b41ff1e86e92590c9426695c" translate="yes" xml:space="preserve">
          <source>Within a bracket expression the &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;?&lt;/code&gt; and &lt;code&gt;\&lt;/code&gt; characters match themselves. The (&lt;code&gt;-&lt;/code&gt;) character matches itself if it is the first character within the brackets, or the first character after the &lt;code&gt;!&lt;/code&gt; if negating.</source>
          <target state="translated">在括号表达式中的 &lt;code&gt;*&lt;/code&gt; ， &lt;code&gt;?&lt;/code&gt; 和 &lt;code&gt;\&lt;/code&gt; 字符匹配。如果（ &lt;code&gt;-&lt;/code&gt; ）字符是括号内的第一个字符，或者是 &lt;code&gt;!&lt;/code&gt; 之后的第一个字符，则该字符与之匹配。如果否定。</target>
        </trans-unit>
        <trans-unit id="83d916c5bbfc33ee16ea209e9686d45596a9c2ac" translate="yes" xml:space="preserve">
          <source>Within each &lt;code&gt;ClassLoader&lt;/code&gt; instance all classes from the same java package have the same Package object. The static methods allow a package to be found by name or the set of all packages known to the current class loader to be found.</source>
          <target state="translated">在每个 &lt;code&gt;ClassLoader&lt;/code&gt; 实例中，同一java包中的所有类都具有相同的Package对象。静态方法允许按名称查找软件包，或者查找当前类加载器已知的所有软件包的集合。</target>
        </trans-unit>
        <trans-unit id="0668371fa9b725d274f510f8d695c661c8f6c217" translate="yes" xml:space="preserve">
          <source>Within each such subset only the most specific methods are selected. Let method M be a method from a set of methods with same VM signature (return type, name, parameter types). M is most specific if there is no such method N != M from the same set, such that N is more specific than M. N is more specific than M if:</source>
          <target state="translated">在每个这样的子集中,只选择最具体的方法。让方法M从具有相同VM签名(返回类型、名称、参数类型)的方法集合中选出一个方法。如果在同一集合中没有这样的方法N !=M,那么M是最具体的,这样N比M更具体。</target>
        </trans-unit>
        <trans-unit id="ed5391ea4c2aede0070693a361a2994f5e4a6a05" translate="yes" xml:space="preserve">
          <source>Within each such subset only the most specific methods are selected. Let method M be a method from a set of methods with same signature and return type. M is most specific if there is no such method N != M from the same set, such that N is more specific than M. N is more specific than M if:</source>
          <target state="translated">在每个这样的子集中,只选择最具体的方法。让方法M从一组具有相同签名和返回类型的方法中选出一个方法。如果在同一集合中没有这样的方法N !=M,那么M是最具体的,这样N比M更具体。</target>
        </trans-unit>
        <trans-unit id="8f444b6815c4d0578f6ec1b24cacc82f1de3a985" translate="yes" xml:space="preserve">
          <source>Within markup, but outside of attributes, any occurrence of a character that cannot be represented in the output character encoding is reported as a &lt;code&gt;DOMError&lt;/code&gt; fatal error. An example would be serializing the element &amp;lt;LaCa&amp;ntilde;ada/&amp;gt; with &lt;code&gt;encoding=&quot;us-ascii&quot;&lt;/code&gt;. This will result with a generation of a &lt;code&gt;DOMError&lt;/code&gt; &quot;wf-invalid-character-in-node-name&quot; (as proposed in &quot;&lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#parameter-well-formed&quot;&gt;well-formed&lt;/a&gt;&quot;).</source>
          <target state="translated">在标记内，但在属性外，任何无法在输出字符编码中表示的字符的出现都报告为 &lt;code&gt;DOMError&lt;/code&gt; 致命错误。一个示例是将元素&amp;lt;LaCa&amp;ntilde;ada/&amp;gt;序列化为 &lt;code&gt;encoding=&quot;us-ascii&quot;&lt;/code&gt; 。这将导致生成 &lt;code&gt;DOMError&lt;/code&gt; &amp;ldquo; wf-invalid-character-in-node-name&amp;rdquo;（如&amp;ldquo;&lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#parameter-well-formed&quot;&gt;格式正确&lt;/a&gt;&amp;rdquo;中所建议的）。</target>
        </trans-unit>
        <trans-unit id="e65be46b0d82a65208f681b65c6b6af3ea153929" translate="yes" xml:space="preserve">
          <source>Within the &lt;code&gt;activate&lt;/code&gt; method, a controller obtains initial values by querying the &lt;code&gt;IIOMetadata&lt;/code&gt; object's settings, either using the XML DOM tree or a plug-in specific interface, modifies values by whatever means, then modifies the &lt;code&gt;IIOMetadata&lt;/code&gt; object's settings, using either the &lt;code&gt;setFromTree&lt;/code&gt; or &lt;code&gt;mergeTree&lt;/code&gt; methods, or a plug-in specific interface. In general, applications may expect that when the &lt;code&gt;activate&lt;/code&gt; method returns &lt;code&gt;true&lt;/code&gt;, the &lt;code&gt;IIOMetadata&lt;/code&gt; object is ready for use in a write operation.</source>
          <target state="translated">在 &lt;code&gt;activate&lt;/code&gt; 方法中，控制器通过使用XML DOM树或特定于插件的接口查询 &lt;code&gt;IIOMetadata&lt;/code&gt; 对象的设置来获取初始值，通过任何方式修改值，然后使用 &lt;code&gt;setFromTree&lt;/code&gt; 或 &lt;code&gt;mergeTree&lt;/code&gt; 修改 &lt;code&gt;IIOMetadata&lt;/code&gt; 对象的设置方法或特定于插件的接口。通常，应用程序可能期望，当 &lt;code&gt;activate&lt;/code&gt; 方法返回 &lt;code&gt;true&lt;/code&gt; 时， &lt;code&gt;IIOMetadata&lt;/code&gt; 对象已准备好用于写操作。</target>
        </trans-unit>
        <trans-unit id="83029e44e09a5ba0623249885430579f4267be4f" translate="yes" xml:space="preserve">
          <source>Within the &lt;code&gt;activate&lt;/code&gt; method, a controller obtains initial values by querying the &lt;code&gt;IIOParam&lt;/code&gt; object's &lt;code&gt;get&lt;/code&gt; methods, modifies values by whatever means, then invokes the &lt;code&gt;IIOParam&lt;/code&gt; object's &lt;code&gt;set&lt;/code&gt; methods to modify the appropriate settings. Normally, these &lt;code&gt;set&lt;/code&gt; methods will be invoked all at once at a final commit in order that a cancel operation not disturb existing values. In general, applications may expect that when the &lt;code&gt;activate&lt;/code&gt; method returns &lt;code&gt;true&lt;/code&gt;, the &lt;code&gt;IIOParam&lt;/code&gt; object is ready for use in a read or write operation.</source>
          <target state="translated">在 &lt;code&gt;activate&lt;/code&gt; 方法内，控制器通过查询 &lt;code&gt;IIOParam&lt;/code&gt; 对象的 &lt;code&gt;get&lt;/code&gt; 方法来获取初始值，通过任何方式修改值，然后调用 &lt;code&gt;IIOParam&lt;/code&gt; 对象的 &lt;code&gt;set&lt;/code&gt; 方法来修改适当的设置。通常，这些 &lt;code&gt;set&lt;/code&gt; 方法将在最终提交时立即全部调用，以使取消操作不会干扰现有值。通常，应用程序可能期望，当 &lt;code&gt;activate&lt;/code&gt; 方法返回 &lt;code&gt;true&lt;/code&gt; 时， &lt;code&gt;IIOParam&lt;/code&gt; 对象已准备就绪，可以在读取或写入操作中使用。</target>
        </trans-unit>
        <trans-unit id="76c301b37038720275724c001f96646390680990" translate="yes" xml:space="preserve">
          <source>Within the character data of a document (outside of markup), any characters that cannot be represented directly are replaced with character references. Occurrences of '&amp;lt;' and '&amp;amp;' are replaced by the predefined entities &amp;amp;lt; and &amp;amp;amp;. The other predefined entities (&amp;amp;gt;, &amp;amp;apos;, and &amp;amp;quot;) might not be used, except where needed (e.g. using &amp;amp;gt; in cases such as ']]&amp;gt;'). Any characters that cannot be represented directly in the output character encoding are serialized as numeric character references (and since character encoding standards commonly use hexadecimal representations of characters, using the hexadecimal representation when serializing character references is encouraged).</source>
          <target state="translated">在文档的字符数据中（标记之外），任何无法直接表示的字符都将替换为字符引用。出现的&amp;lt;&amp;lt;和'＆'被预定义的实体＆lt;替换。和＆amp;。除非需要，否则可能不使用其他预定义的实体（&amp;ldquo;，&amp;rdquo;和&amp;ldquo;）&amp;rdquo;（例如，在诸如&amp;ldquo;] &amp;gt;&amp;gt;的情况下使用&amp;ldquo;&amp;gt;&amp;rdquo;）。无法在输出字符编码中直接表示的任何字符都将序列化为数字字符引用（并且由于字符编码标准通常使用字符的十六进制表示形式，因此在鼓励序列化字符引用时使用十六进制表示形式）。</target>
        </trans-unit>
        <trans-unit id="1759a0ebe8a5e5c04ff2fdb42ee3e41043aa418f" translate="yes" xml:space="preserve">
          <source>Without anchoring bounds, the boundaries of this matcher's region will not match anchors such as ^ and $.</source>
          <target state="translated">如果没有锚定边界,这个匹配器区域的边界将无法匹配^和$等锚。</target>
        </trans-unit>
        <trans-unit id="d683f7eface7d10e82e3f102080ec5410bd6835c" translate="yes" xml:space="preserve">
          <source>Without this warning, an applet may pop up windows without the user knowing that they belong to an applet. Since users may make security-sensitive decisions based on whether or not the window belongs to an applet (entering a username and password into a dialog box, for example), disabling this warning banner may allow applets to trick the user into entering such information.</source>
          <target state="translated">如果没有这个警告,小程序可能会在用户不知道它们属于小程序的情况下弹出窗口。由于用户可能会根据窗口是否属于小程序而做出安全敏感的决定(例如,在对话框中输入用户名和密码),禁用该警告横幅可能会让小程序欺骗用户输入此类信息。</target>
        </trans-unit>
        <trans-unit id="6fd52a68c735f034b00232a476c8c2e710db36a9" translate="yes" xml:space="preserve">
          <source>Word boundary analysis is used by search and replace functions, as well as within text editing applications that allow the user to select words with a double click. Word selection provides correct interpretation of punctuation marks within and following words. Characters that are not part of a word, such as symbols or punctuation marks, have word-breaks on both sides.</source>
          <target state="translated">字词边界分析用于搜索和替换功能,以及在文本编辑应用程序中,允许用户双击选择单词。选词提供对词内和词后标点符号的正确解释。不属于单词的字符,如符号或标点符号,在两边都有单词断句。</target>
        </trans-unit>
        <trans-unit id="99edd8c8e615e373739d2cdd38a8942b8a573113" translate="yes" xml:space="preserve">
          <source>Worker</source>
          <target state="translated">Worker</target>
        </trans-unit>
        <trans-unit id="6e99a8e4272c2db9e95f06a1f314a0f285a61837" translate="yes" xml:space="preserve">
          <source>Would result in the string '123-____'. If &lt;code&gt;setPlaceholder(&quot;555-1212&quot;)&lt;/code&gt; was invoked '123-1212' would result. The placeholder String is only used on the initial format, on subsequent formats only the placeholder character will be used.</source>
          <target state="translated">将导致字符串&amp;ldquo; 123 -____&amp;rdquo;。如果 &lt;code&gt;setPlaceholder(&quot;555-1212&quot;)&lt;/code&gt; 则结果为'123-1212'。占位符字符串仅用于初始格式，在后续格式中仅将使用占位符。</target>
        </trans-unit>
        <trans-unit id="642d596b44e19ab47c9e267aa3cf4a6030e0380b" translate="yes" xml:space="preserve">
          <source>Wrap a key.</source>
          <target state="translated">缠住一把钥匙。</target>
        </trans-unit>
        <trans-unit id="3bcf468a4c3b40978bdee293e80fc65249f9482b" translate="yes" xml:space="preserve">
          <source>Wrap an existing exception in a SAXParseException.</source>
          <target state="translated">在SAXParseException中封装一个现有的异常。</target>
        </trans-unit>
        <trans-unit id="b0b650cb303bad45cc633704145a571455dd7664" translate="yes" xml:space="preserve">
          <source>Wrap an existing exception in a TransformerConfigurationException.</source>
          <target state="translated">在TransformerConfigurationException中包装一个现有的异常。</target>
        </trans-unit>
        <trans-unit id="9b39d6715671bdb2580af79800238414d13f1fd7" translate="yes" xml:space="preserve">
          <source>Wrap an existing exception in a TransformerException.</source>
          <target state="translated">在TransformerException中包装一个现有的异常。</target>
        </trans-unit>
        <trans-unit id="0c3ecd9442f9e1b1059ee6690619be457c11839a" translate="yes" xml:space="preserve">
          <source>Wrapped value (&lt;code&gt;Integer.valueOf(5)&lt;/code&gt;, &lt;code&gt;Boolean.FALSE&lt;/code&gt;, etc)</source>
          <target state="translated">包装值（ &lt;code&gt;Integer.valueOf(5)&lt;/code&gt; ， &lt;code&gt;Boolean.FALSE&lt;/code&gt; 等）</target>
        </trans-unit>
        <trans-unit id="adbbb2fc6c4f8e1a93cb3431a12402bc3b7237ec" translate="yes" xml:space="preserve">
          <source>WrappedPlainView</source>
          <target state="translated">WrappedPlainView</target>
        </trans-unit>
        <trans-unit id="a9ebad9ce612c251b607a54c6d2d4842c89b63b2" translate="yes" xml:space="preserve">
          <source>Wrapper</source>
          <target state="translated">Wrapper</target>
        </trans-unit>
        <trans-unit id="2dbad62d494925b0cc5a9b12acb2cba9f5175ae5" translate="yes" xml:space="preserve">
          <source>Wrapper for primitive graphics calls.</source>
          <target state="translated">原始图形调用的封装器。</target>
        </trans-unit>
        <trans-unit id="ff0316ad77425467f6a86336f0b3c23b4f8eb43e" translate="yes" xml:space="preserve">
          <source>Wrapper information for malformed and incomplete snippets also generate wrappers. The list is in snippet encounter order. The wrapper changes as the environment changes, so calls to this method at different times may yield different results.</source>
          <target state="translated">畸形和不完整的片段的包装器信息也会生成包装器。该列表是按照代码段遭遇顺序排列的。包装器会随着环境的变化而变化,因此在不同时间调用该方法可能会产生不同的结果。</target>
        </trans-unit>
        <trans-unit id="92704fc2036355b575a4c4fbf65bd7b09813a44e" translate="yes" xml:space="preserve">
          <source>Wrapping the attribute value into an Annotation object guarantees that adjacent text runs don't get merged even if the attribute values are equal, and indicates to text containers that the attribute should be discarded if the underlying text is modified.</source>
          <target state="translated">将属性值封装到Annotation对象中,保证即使属性值相等,相邻的文本运行也不会被合并,并向文本容器表明,如果底层文本被修改,该属性应该被丢弃。</target>
        </trans-unit>
        <trans-unit id="cca5fcd7b5b7c14fbea5ee4fc3296a93d35e1da8" translate="yes" xml:space="preserve">
          <source>Wraps a byte array into a buffer.</source>
          <target state="translated">将一个字节数组打包成一个缓冲区。</target>
        </trans-unit>
        <trans-unit id="3e43b98c51021b6537868fda39974c26611122c5" translate="yes" xml:space="preserve">
          <source>Wraps a byte array to be sent to the client.</source>
          <target state="translated">包裹一个要发送给客户端的字节数组。</target>
        </trans-unit>
        <trans-unit id="64cfb840ede8be7ea7901c7dfd0a6e52d56476fa" translate="yes" xml:space="preserve">
          <source>Wraps a byte array to be sent to the client. This method can be called only after the authentication exchange has completed (i.e., when &lt;code&gt;isComplete()&lt;/code&gt; returns true) and only if the authentication exchange has negotiated integrity and/or privacy as the quality of protection; otherwise, a &lt;code&gt;SaslException&lt;/code&gt; is thrown.</source>
          <target state="translated">包装要发送给客户端的字节数组。仅当身份验证交换完成后（即 &lt;code&gt;isComplete()&lt;/code&gt; 返回true时），并且仅当身份验证交换已协商完整性和/或隐私作为保护质量时，才可以调用此方法；否则，抛出 &lt;code&gt;SaslException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b1be73d2494fd5ecf63ee8bc9278f31e2926d14e" translate="yes" xml:space="preserve">
          <source>Wraps a byte array to be sent to the server.</source>
          <target state="translated">包裹一个要发送到服务器的字节数组。</target>
        </trans-unit>
        <trans-unit id="c58ede29ff7ee729e1131d3a1d2647f530332ea4" translate="yes" xml:space="preserve">
          <source>Wraps a byte array to be sent to the server. This method can be called only after the authentication exchange has completed (i.e., when &lt;code&gt;isComplete()&lt;/code&gt; returns true) and only if the authentication exchange has negotiated integrity and/or privacy as the quality of protection; otherwise, an &lt;code&gt;IllegalStateException&lt;/code&gt; is thrown.</source>
          <target state="translated">包装要发送到服务器的字节数组。仅当身份验证交换完成后（即 &lt;code&gt;isComplete()&lt;/code&gt; 返回true时），并且仅当身份验证交换已协商完整性和/或隐私作为保护质量时，才可以调用此方法；否则，将 &lt;code&gt;IllegalStateException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="67b1374ef549a7e954a05b9ec7009fb8bc41734f" translate="yes" xml:space="preserve">
          <source>Wraps a char array into a buffer.</source>
          <target state="translated">将一个char数组打包成一个缓冲区。</target>
        </trans-unit>
        <trans-unit id="f7b95771a9ecdaf8c4f0c45b0a3050463bc0fb11" translate="yes" xml:space="preserve">
          <source>Wraps a character sequence into a buffer.</source>
          <target state="translated">将一个字符序列包入缓冲区。</target>
        </trans-unit>
        <trans-unit id="9cf8f103948e6b6d2a2e2dcbd8e83ddda5dcdf8e" translate="yes" xml:space="preserve">
          <source>Wraps a double array into a buffer.</source>
          <target state="translated">将一个双数组打包成一个缓冲区。</target>
        </trans-unit>
        <trans-unit id="7c38a95681b8bf75718f777dc7681e478936ebe7" translate="yes" xml:space="preserve">
          <source>Wraps a float array into a buffer.</source>
          <target state="translated">将一个浮动数组打包成一个缓冲区。</target>
        </trans-unit>
        <trans-unit id="e875d8d4d7f1a26ef5338640a04b767dbb14b0fd" translate="yes" xml:space="preserve">
          <source>Wraps a long array into a buffer.</source>
          <target state="translated">将一个长的数组打包成一个缓冲区。</target>
        </trans-unit>
        <trans-unit id="7a45b9eefe39a4cdc4f096f2050c4639eeae92e4" translate="yes" xml:space="preserve">
          <source>Wraps a short array into a buffer.</source>
          <target state="translated">将一个短数组打包成一个缓冲区。</target>
        </trans-unit>
        <trans-unit id="35438f1499f1a894d95345e3941ad2b29de6319a" translate="yes" xml:space="preserve">
          <source>Wraps an &lt;a href=&quot;../../../../java.base/java/lang/illegalargumentexception&quot;&gt;&lt;code&gt;IllegalArgumentException&lt;/code&gt;&lt;/a&gt; if the MBeanInfo passed in parameter is null.</source>
          <target state="translated">如果传入的MBeanInfo参数为null，则包装&lt;a href=&quot;../../../../java.base/java/lang/illegalargumentexception&quot;&gt; &lt;code&gt;IllegalArgumentException&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c1d32f710973f4fd61bdd696efd70daf69bd5b7d" translate="yes" xml:space="preserve">
          <source>Wraps an &lt;a href=&quot;../../../../java.base/java/lang/illegalstateexception&quot;&gt;&lt;code&gt;IllegalStateException&lt;/code&gt;&lt;/a&gt; if the ModelMBean is currently registered in the MBeanServer.</source>
          <target state="translated">如果ModelMBean当前在MBeanServer中注册，则包装一个&lt;a href=&quot;../../../../java.base/java/lang/illegalstateexception&quot;&gt; &lt;code&gt;IllegalStateException&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="526e84458ea6e6f011221fcab33932da84f5ba1d" translate="yes" xml:space="preserve">
          <source>Wraps an &lt;a href=&quot;../../../java/lang/illegalargumentexception&quot;&gt;&lt;code&gt;IllegalArgumentException&lt;/code&gt;&lt;/a&gt; if the MBeanInfo passed in parameter is null.</source>
          <target state="translated">如果传入的MBeanInfo参数为null，则包装&lt;a href=&quot;../../../java/lang/illegalargumentexception&quot;&gt; &lt;code&gt;IllegalArgumentException&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5b976fffcdb3184f30e314babf43e006ea0f5ad5" translate="yes" xml:space="preserve">
          <source>Wraps an &lt;a href=&quot;../../../java/lang/illegalstateexception&quot;&gt;&lt;code&gt;IllegalStateException&lt;/code&gt;&lt;/a&gt; if the ModelMBean is currently registered in the MBeanServer.</source>
          <target state="translated">如果ModelMBean当前在MBeanServer中注册，则包装一个&lt;a href=&quot;../../../java/lang/illegalstateexception&quot;&gt; &lt;code&gt;IllegalStateException&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0edf81e480b4a49c11c2dbafe5b84b7869d1aa13" translate="yes" xml:space="preserve">
          <source>Wraps an &lt;a href=&quot;ioexception&quot;&gt;&lt;code&gt;IOException&lt;/code&gt;&lt;/a&gt; with an unchecked exception.</source>
          <target state="translated">用未检查的异常包装&lt;a href=&quot;ioexception&quot;&gt; &lt;code&gt;IOException&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6afb0fee856f2866c314288124d5fc7949a1696a" translate="yes" xml:space="preserve">
          <source>Wraps an int array into a buffer.</source>
          <target state="translated">将一个int数组打包成一个缓冲区。</target>
        </trans-unit>
        <trans-unit id="f46c77a2dce440c1be651d2cef94b153c69cfdb1" translate="yes" xml:space="preserve">
          <source>Wraps an output stream for encoding byte data using the &lt;a href=&quot;base64&quot;&gt;&lt;code&gt;Base64&lt;/code&gt;&lt;/a&gt; encoding scheme.</source>
          <target state="translated">包装输出流以使用&lt;a href=&quot;base64&quot;&gt; &lt;code&gt;Base64&lt;/code&gt; &lt;/a&gt;编码方案对字节数据进行编码。</target>
        </trans-unit>
        <trans-unit id="484e8635160ff209f16a26350fd86bb6ec73ccc2" translate="yes" xml:space="preserve">
          <source>Wraps an throwable thrown in the executing client.</source>
          <target state="translated">在执行客户端中封装一个可抛出的抛物。</target>
        </trans-unit>
        <trans-unit id="cd0bad816dddec56a1fb6f782b800ce84060f392" translate="yes" xml:space="preserve">
          <source>Wraps an throwable thrown in the executing client. An instance of &lt;code&gt;EvalException&lt;/code&gt; can be returned in the &lt;a href=&quot;snippetevent#exception()&quot;&gt;&lt;code&gt;SnippetEvent.exception()&lt;/code&gt;&lt;/a&gt; query. The name of the throwable thrown is available from &lt;a href=&quot;#getExceptionClassName()&quot;&gt;&lt;code&gt;getExceptionClassName()&lt;/code&gt;&lt;/a&gt;. Message and stack can be queried by methods on &lt;code&gt;Exception&lt;/code&gt;.</source>
          <target state="translated">包装正在执行的客户端中抛出的throwable。可以在&lt;a href=&quot;snippetevent#exception()&quot;&gt; &lt;code&gt;SnippetEvent.exception()&lt;/code&gt; &lt;/a&gt;查询中返回 &lt;code&gt;EvalException&lt;/code&gt; 的实例。可从&lt;a href=&quot;#getExceptionClassName()&quot;&gt; &lt;code&gt;getExceptionClassName()&lt;/code&gt; &lt;/a&gt;获得抛出的对象的名称。可以通过 &lt;code&gt;Exception&lt;/code&gt; 上的方法查询消息和堆栈。</target>
        </trans-unit>
        <trans-unit id="12b5eee30743d96f3a2465542a9df99878df7b23" translate="yes" xml:space="preserve">
          <source>Wraps exceptions thrown by the preRegister(), preDeregister() methods of the &lt;code&gt;MBeanRegistration&lt;/code&gt; interface.</source>
          <target state="translated">包装由 &lt;code&gt;MBeanRegistration&lt;/code&gt; 接口的preRegister（）和preDeregister（）方法引发的异常。</target>
        </trans-unit>
        <trans-unit id="ac820c6009b39e20e5ac984441a6a70e50be36a4" translate="yes" xml:space="preserve">
          <source>Wraps the result of &lt;a href=&quot;#getCharContent(boolean)&quot;&gt;getCharContent(boolean)&lt;/a&gt; in a Reader.</source>
          <target state="translated">在阅读器中&lt;a href=&quot;#getCharContent(boolean)&quot;&gt;包装getCharContent（boolean）&lt;/a&gt;的结果。</target>
        </trans-unit>
        <trans-unit id="4a990b08c589c006db4f034d5b0f85b8c7bd9875" translate="yes" xml:space="preserve">
          <source>Wraps the result of &lt;a href=&quot;#getCharContent(boolean)&quot;&gt;getCharContent(boolean)&lt;/a&gt; in a Reader. Subclasses can change this behavior as long as the contract of &lt;a href=&quot;fileobject&quot;&gt;&lt;code&gt;FileObject&lt;/code&gt;&lt;/a&gt; is obeyed.</source>
          <target state="translated">在阅读器中&lt;a href=&quot;#getCharContent(boolean)&quot;&gt;包装getCharContent（boolean）&lt;/a&gt;的结果。只要遵守&lt;a href=&quot;fileobject&quot;&gt; &lt;code&gt;FileObject&lt;/code&gt; &lt;/a&gt;的约定，子类就可以更改此行为。</target>
        </trans-unit>
        <trans-unit id="8a2449189a10e5f2a06487a9d1438073749161da" translate="yes" xml:space="preserve">
          <source>Wraps the result of &lt;a href=&quot;simplejavafileobject#getCharContent-boolean-&quot;&gt;getCharContent(boolean)&lt;/a&gt; in a Reader. Subclasses can change this behavior as long as the contract of &lt;a href=&quot;fileobject&quot;&gt;&lt;code&gt;FileObject&lt;/code&gt;&lt;/a&gt; is obeyed.</source>
          <target state="translated">将&lt;a href=&quot;simplejavafileobject#getCharContent-boolean-&quot;&gt;getCharContent（boolean）&lt;/a&gt;的结果包装在Reader中。只要遵守&lt;a href=&quot;fileobject&quot;&gt; &lt;code&gt;FileObject&lt;/code&gt; &lt;/a&gt;的约定，子类就可以更改此行为。</target>
        </trans-unit>
        <trans-unit id="ab924b7847e5e470bb4f8f381c5b7f772f8b220f" translate="yes" xml:space="preserve">
          <source>Wraps the result of openOutputStream in a Writer.</source>
          <target state="translated">将openOutputStream的结果封装在一个Writer中。</target>
        </trans-unit>
        <trans-unit id="18643b36bb23e1c01a06054ba0da36eec75ea0b6" translate="yes" xml:space="preserve">
          <source>Wraps the result of openOutputStream in a Writer. Subclasses can change this behavior as long as the contract of &lt;a href=&quot;fileobject&quot;&gt;&lt;code&gt;FileObject&lt;/code&gt;&lt;/a&gt; is obeyed.</source>
          <target state="translated">将openOutputStream的结果包装在Writer中。只要遵守&lt;a href=&quot;fileobject&quot;&gt; &lt;code&gt;FileObject&lt;/code&gt; &lt;/a&gt;的约定，子类就可以更改此行为。</target>
        </trans-unit>
        <trans-unit id="d5c0446c81d41ca1fdd8fea8cfadd9a744960cb5" translate="yes" xml:space="preserve">
          <source>Wraps the specified transform.</source>
          <target state="translated">包裹指定的变换。</target>
        </trans-unit>
        <trans-unit id="18aba0f6a8421686c79cd18305b44edb5756ae50" translate="yes" xml:space="preserve">
          <source>Wraps the specified transform. The transform is cloned and a reference to the clone is kept. The original transform is unchanged. If null is passed as the argument, this constructor behaves as though it were the identity transform. (Note that it is preferable to use &lt;a href=&quot;#IDENTITY&quot;&gt;&lt;code&gt;IDENTITY&lt;/code&gt;&lt;/a&gt; in this case.)</source>
          <target state="translated">包装指定的转换。克隆转换并保留对克隆的引用。原始变换未更改。如果将null作为参数传递，则此构造方法的行为就好像是身份转换一样。（请注意，在这种情况下，最好使用&lt;a href=&quot;#IDENTITY&quot;&gt; &lt;code&gt;IDENTITY&lt;/code&gt; &lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="6da588377e328486ae18afd15219a2649754d3c0" translate="yes" xml:space="preserve">
          <source>Wraps this segment in a &lt;a href=&quot;../../../../java.base/java/nio/bytebuffer&quot;&gt;&lt;code&gt;ByteBuffer&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">将此段包装在&lt;a href=&quot;../../../../java.base/java/nio/bytebuffer&quot;&gt; &lt;code&gt;ByteBuffer&lt;/code&gt; 中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e8ef84101ba37aa05699837c391abecc35bc93c2" translate="yes" xml:space="preserve">
          <source>Wraps this segment in a &lt;a href=&quot;../../../../java.base/java/nio/bytebuffer&quot;&gt;&lt;code&gt;ByteBuffer&lt;/code&gt;&lt;/a&gt;. Some of the properties of the returned buffer are linked to the properties of this segment. For instance, if this segment is &lt;em&gt;immutable&lt;/em&gt; (e.g. the segment has access mode &lt;a href=&quot;#READ&quot;&gt;&lt;code&gt;READ&lt;/code&gt;&lt;/a&gt; but not &lt;a href=&quot;#WRITE&quot;&gt;&lt;code&gt;WRITE&lt;/code&gt;&lt;/a&gt;), then the resulting buffer is &lt;em&gt;read-only&lt;/em&gt; (see &lt;a href=&quot;../../../../java.base/java/nio/buffer#isReadOnly()&quot;&gt;&lt;code&gt;Buffer.isReadOnly()&lt;/code&gt;&lt;/a&gt;. Additionally, if this is a native memory segment, the resulting buffer is &lt;em&gt;direct&lt;/em&gt; (see &lt;a href=&quot;../../../../java.base/java/nio/bytebuffer#isDirect()&quot;&gt;&lt;code&gt;ByteBuffer.isDirect()&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">将此段包装在&lt;a href=&quot;../../../../java.base/java/nio/bytebuffer&quot;&gt; &lt;code&gt;ByteBuffer&lt;/code&gt; 中&lt;/a&gt;。返回缓冲区的某些属性链接到该段的属性。例如，如果该段是&lt;em&gt;不可变的&lt;/em&gt;（例如，该段具有访问模式&lt;a href=&quot;#READ&quot;&gt; &lt;code&gt;READ&lt;/code&gt; &lt;/a&gt;而不是&lt;a href=&quot;#WRITE&quot;&gt; &lt;code&gt;WRITE&lt;/code&gt; &lt;/a&gt;），则结果缓冲区是&lt;em&gt;只读的&lt;/em&gt;（请参见&lt;a href=&quot;../../../../java.base/java/nio/buffer#isReadOnly()&quot;&gt; &lt;code&gt;Buffer.isReadOnly()&lt;/code&gt; &lt;/a&gt;。此外，如果这是本机内存段，则结果缓冲区是&lt;em&gt;直接的&lt;/em&gt;（请参见&lt;a href=&quot;../../../../java.base/java/nio/bytebuffer#isDirect()&quot;&gt; &lt;code&gt;ByteBuffer.isDirect()&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="b8f27a22b91fffa5fca45a36aaea975d25f5a8b2" translate="yes" xml:space="preserve">
          <source>WritableByteChannel</source>
          <target state="translated">WritableByteChannel</target>
        </trans-unit>
        <trans-unit id="232d2eb15dd5a8e6d5b8d3468d075c115e7d592c" translate="yes" xml:space="preserve">
          <source>WritableByteChannel.write()</source>
          <target state="translated">WritableByteChannel.write()</target>
        </trans-unit>
        <trans-unit id="8df121d40ab265ffb282618abaddabf62bf4b394" translate="yes" xml:space="preserve">
          <source>WritableRaster</source>
          <target state="translated">WritableRaster</target>
        </trans-unit>
        <trans-unit id="d89b72e5d40182fe2b3219c24a22ac87a1fc4964" translate="yes" xml:space="preserve">
          <source>WritableRenderedImage</source>
          <target state="translated">WritableRenderedImage</target>
        </trans-unit>
        <trans-unit id="028b998a60e46208ce0ede4aa3a7013db3bcb901" translate="yes" xml:space="preserve">
          <source>WritableRenderedImage is a common interface for objects which contain or can produce image data in the form of Rasters and which can be modified and/or written over.</source>
          <target state="translated">WritableRenderedImage是一个通用的接口,用于包含或可以产生Rasters形式的图像数据的对象,这些数据可以被修改和/或写入。</target>
        </trans-unit>
        <trans-unit id="b356fedb82416c4bf9703a0aa4ef5cd0e33afc43" translate="yes" xml:space="preserve">
          <source>WritableRenderedImage is a common interface for objects which contain or can produce image data in the form of Rasters and which can be modified and/or written over. The image data may be stored/produced as a single tile or a regular array of tiles.</source>
          <target state="translated">WritableRenderedImage是一个通用的接口,用于包含或可以生成栅格形式的图像数据的对象,这些数据可以被修改和/或写入。图像数据可以以单个磁贴或常规磁贴阵列的形式存储/生产。</target>
        </trans-unit>
        <trans-unit id="c22974bfb92e8c252f00719977a7781037b8ef4a" translate="yes" xml:space="preserve">
          <source>WritableRenderedImage provides notification to other interested objects when a tile is checked out for writing (via the getWritableTile method) and when the last writer of a particular tile relinquishes its access (via a call to releaseWritableTile). Additionally, it allows any caller to determine whether any tiles are currently checked out (via hasTileWriters), and to obtain a list of such tiles (via getWritableTileIndices, in the form of a Vector of Point objects).</source>
          <target state="translated">WritableRenderedImage提供了一个通知给其他感兴趣的对象,当一个磁贴被签出以供写入(通过getWritableTile方法),以及当一个特定磁贴的最后一个写入者放弃其访问(通过调用releaseWritableTile)。此外,它允许任何调用者确定当前是否有任何磁贴被签出(通过hasTileWriters),并获得这些磁贴的列表(通过getWritableTileIndices,以Point对象的Vector形式)。</target>
        </trans-unit>
        <trans-unit id="5da714036977cab66b8b81ed578fe655c485e622" translate="yes" xml:space="preserve">
          <source>Write a &lt;a href=&quot;../../lang/charsequence&quot;&gt;CharSequence&lt;/a&gt; to a file.</source>
          <target state="translated">将&lt;a href=&quot;../../lang/charsequence&quot;&gt;CharSequence&lt;/a&gt;写入文件。</target>
        </trans-unit>
        <trans-unit id="4c9ce4be9f1bfb0073774626ee67a785eab41413" translate="yes" xml:space="preserve">
          <source>Write a &lt;a href=&quot;../../lang/charsequence&quot;&gt;CharSequence&lt;/a&gt; to a file. Characters are encoded into bytes using the &lt;a href=&quot;../charset/standardcharsets#UTF_8&quot;&gt;&lt;code&gt;UTF-8&lt;/code&gt;&lt;/a&gt;&lt;a href=&quot;../charset/charset&quot;&gt;&lt;code&gt;charset&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">将&lt;a href=&quot;../../lang/charsequence&quot;&gt;CharSequence&lt;/a&gt;写入文件。使用&lt;a href=&quot;../charset/standardcharsets#UTF_8&quot;&gt; &lt;code&gt;UTF-8&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;../charset/charset&quot;&gt; &lt;code&gt;charset&lt;/code&gt; &lt;/a&gt;编码为字节。</target>
        </trans-unit>
        <trans-unit id="792c5eb24bd75a6c8f430ef046aca72eecc461f1" translate="yes" xml:space="preserve">
          <source>Write a &lt;a href=&quot;../../lang/charsequence&quot;&gt;CharSequence&lt;/a&gt; to a file. Characters are encoded into bytes using the specified &lt;a href=&quot;../charset/charset&quot;&gt;charset&lt;/a&gt;.</source>
          <target state="translated">将&lt;a href=&quot;../../lang/charsequence&quot;&gt;CharSequence&lt;/a&gt;写入文件。使用指定的&lt;a href=&quot;../charset/charset&quot;&gt;字符集将字符&lt;/a&gt;编码为字节。</target>
        </trans-unit>
        <trans-unit id="294afe002c539f61c1c0ee3dcb972c7d74bf355b" translate="yes" xml:space="preserve">
          <source>Write a DTD section.</source>
          <target state="translated">写一个DTD部分。</target>
        </trans-unit>
        <trans-unit id="59ffb7b91778bf9267476f98e09dcacd6f27df3d" translate="yes" xml:space="preserve">
          <source>Write a DTD section. This string represents the entire doctypedecl production from the XML 1.0 specification.</source>
          <target state="translated">写一个DTD部分。这个字符串代表了XML 1.0规范中的整个doctypedecl制作。</target>
        </trans-unit>
        <trans-unit id="1fc0bd7118775692ac86213afd1d0d2701cb9b4d" translate="yes" xml:space="preserve">
          <source>Write a byte of data to the stream. If it is not a newline, then the byte is appended to the internal buffer. If it is a newline, then the currently buffered line is sent to the log's output stream, prefixed with the appropriate logging information.</source>
          <target state="translated">向流中写入一个字节的数据。如果不是换行,则将该字节附加到内部缓冲区。如果是换行,那么当前缓冲区的行将被发送到日志的输出流中,并在前缀上适当的日志信息。</target>
        </trans-unit>
        <trans-unit id="98c22110dc7ee6d680da89d0b08efd62d28b6ef7" translate="yes" xml:space="preserve">
          <source>Write a portion of a string to the buffer.</source>
          <target state="translated">将字符串的一部分写入缓冲区。</target>
        </trans-unit>
        <trans-unit id="4652631a628afd8a3f8a588fd0dbd737d2146884" translate="yes" xml:space="preserve">
          <source>Write a portion of a string.</source>
          <target state="translated">写一个字符串的一部分。</target>
        </trans-unit>
        <trans-unit id="354cde68fb6c2f936b7c59bf670319ba0dcf0ab7" translate="yes" xml:space="preserve">
          <source>Write a portion of an array of characters.</source>
          <target state="translated">写出一个数组中的部分字符。</target>
        </trans-unit>
        <trans-unit id="330fefb058de9e90d4a9120ede2b9e5d7c7923ca" translate="yes" xml:space="preserve">
          <source>Write a single character.</source>
          <target state="translated">写一个单字。</target>
        </trans-unit>
        <trans-unit id="994c1ba05bfadf4cef0d6733c4c98bd025355fa4" translate="yes" xml:space="preserve">
          <source>Write a string of text followed by a newline character to a document stream opened by &lt;code&gt;open()&lt;/code&gt; .</source>
          <target state="translated">在 &lt;code&gt;open()&lt;/code&gt; 打开的文档流中写入文本字符串，后跟换行符。</target>
        </trans-unit>
        <trans-unit id="498783f0999ed7eb8d0d11df50117632250e49f4" translate="yes" xml:space="preserve">
          <source>Write a string of text followed by a newline character to a document stream opened by &lt;code&gt;open()&lt;/code&gt; . The text is parsed into the document's structure model.</source>
          <target state="translated">在 &lt;code&gt;open()&lt;/code&gt; 打开的文档流中写入文本字符串，后跟换行符。文本被解析为文档的结构模型。</target>
        </trans-unit>
        <trans-unit id="d4cdad9bf95a1d8bc5e861dbd1d5513d4131edf9" translate="yes" xml:space="preserve">
          <source>Write a string of text to a document stream opened by &lt;code&gt;open()&lt;/code&gt; .</source>
          <target state="translated">将文本字符串写入由 &lt;code&gt;open()&lt;/code&gt; 打开的文档流中。</target>
        </trans-unit>
        <trans-unit id="6cf4f5d1c6394d5c94d488c2922b7aae5b015b7a" translate="yes" xml:space="preserve">
          <source>Write a string of text to a document stream opened by &lt;code&gt;open()&lt;/code&gt; . The text is parsed into the document's structure model.</source>
          <target state="translated">将文本字符串写入由 &lt;code&gt;open()&lt;/code&gt; 打开的文档流中。文本被解析为文档的结构模型。</target>
        </trans-unit>
        <trans-unit id="f6e749d40ff493a236a023d30fb9fbee8148a6ef" translate="yes" xml:space="preserve">
          <source>Write a string.</source>
          <target state="translated">写一个字符串。</target>
        </trans-unit>
        <trans-unit id="0556df9723ab76c236dd36201ca6d8bc8762ef74" translate="yes" xml:space="preserve">
          <source>Write a subarray of bytes. Pass each through write byte method.</source>
          <target state="translated">写一个子数组的字节。通过写字节的方法来传递每个。</target>
        </trans-unit>
        <trans-unit id="fa4bcd6ffc98fa169157314d2485ef4b0ffb5451" translate="yes" xml:space="preserve">
          <source>Write access mode; write operations are supported by a segment which supports this access mode.</source>
          <target state="translated">写入访问模式;支持该访问模式的段支持写操作。</target>
        </trans-unit>
        <trans-unit id="0669d7506d09ace8cad4d0f0e36010749d28970c" translate="yes" xml:space="preserve">
          <source>Write accesses to the segment's content &lt;a href=&quot;../../../java/util/concurrent/package-summary#MemoryVisibility&quot;&gt;&lt;i&gt;happens-before&lt;/i&gt;&lt;/a&gt; hand-over from the current owner thread to the new owner thread, which in turn</source>
          <target state="translated">对段内容的写访问&lt;a href=&quot;../../../java/util/concurrent/package-summary#MemoryVisibility&quot;&gt;&lt;i&gt;发生&lt;/i&gt;&lt;/a&gt;在从当前所有者线程切换到新所有者线程之前，后者又依次</target>
        </trans-unit>
        <trans-unit id="20a06ba0fb5f245b45c41b384d2689f6921e992d" translate="yes" xml:space="preserve">
          <source>Write an XML representation of the specified object to the output.</source>
          <target state="translated">将指定对象的XML表示写到输出中。</target>
        </trans-unit>
        <trans-unit id="be7a56a69ad18401ec15997f7d4e84d91cfc1967" translate="yes" xml:space="preserve">
          <source>Write an object to the underlying storage or stream.</source>
          <target state="translated">向底层存储或流写入对象。</target>
        </trans-unit>
        <trans-unit id="edf1d95422469a4ca47028cba75c57280225b87b" translate="yes" xml:space="preserve">
          <source>Write an object to the underlying storage or stream. The class that implements this interface defines how the object is written.</source>
          <target state="translated">将对象写入底层存储或流。实现该接口的类定义了对象的写入方式。</target>
        </trans-unit>
        <trans-unit id="1f519448d10b81232efe702c1adf54399740a1e6" translate="yes" xml:space="preserve">
          <source>Write any cached data to the underlying output mechanism.</source>
          <target state="translated">将任何缓存数据写入底层输出机制。</target>
        </trans-unit>
        <trans-unit id="e1449e213dd3fcab37865b1ea7eed0c6a6eda03c" translate="yes" xml:space="preserve">
          <source>Write content from a document to the given stream as plain text.</source>
          <target state="translated">将文档中的内容以纯文本的形式写入给定的流。</target>
        </trans-unit>
        <trans-unit id="47582b3fc1fd1ce73fc7f30356e130a469fc033d" translate="yes" xml:space="preserve">
          <source>Write content from a document to the given stream in a format appropriate for this kind of content handler.</source>
          <target state="translated">将文档中的内容以适合这种内容处理程序的格式写入给定流。</target>
        </trans-unit>
        <trans-unit id="81829db29a2fbd204bf7a7893714606039435c4e" translate="yes" xml:space="preserve">
          <source>Write lines of text to a file.</source>
          <target state="translated">将文本行写入文件。</target>
        </trans-unit>
        <trans-unit id="5f04a37c7592d94e8a688b1e22ea47eb19aaa578" translate="yes" xml:space="preserve">
          <source>Write lines of text to a file. Characters are encoded into bytes using the &lt;a href=&quot;../charset/standardcharsets#UTF_8&quot;&gt;&lt;code&gt;UTF-8&lt;/code&gt;&lt;/a&gt;&lt;a href=&quot;../charset/charset&quot;&gt;&lt;code&gt;charset&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">将多行文字写入文件。使用&lt;a href=&quot;../charset/standardcharsets#UTF_8&quot;&gt; &lt;code&gt;UTF-8&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;../charset/charset&quot;&gt; &lt;code&gt;charset&lt;/code&gt; &lt;/a&gt;编码为字节。</target>
        </trans-unit>
        <trans-unit id="cc7e0443ea36cc424ea3c38e6c6339b26fa90a65" translate="yes" xml:space="preserve">
          <source>Write lines of text to a file. Each line is a char sequence and is written to the file in sequence with each line terminated by the platform's line separator, as defined by the system property &lt;code&gt;
 line.separator&lt;/code&gt;. Characters are encoded into bytes using the specified charset.</source>
          <target state="translated">将几行文字写入文件。每行是一个char序列，并按顺序写入文件，每行由平台的行分隔符终止，如系统属性 &lt;code&gt; line.separator&lt;/code&gt; 所定义。使用指定的字符集将字符编码为字节。</target>
        </trans-unit>
        <trans-unit id="422a884c7d36bcb6e46158dea6218bc82e12cb81" translate="yes" xml:space="preserve">
          <source>Write lines of text to a file. Each line is a char sequence and is written to the file in sequence with each line terminated by the platform's line separator, as defined by the system property &lt;code&gt;line.separator&lt;/code&gt;. Characters are encoded into bytes using the specified charset.</source>
          <target state="translated">将多行文字写入文件。每行都是一个char序列，并按顺序写入文件，每行由平台的行分隔符终止，如系统属性 &lt;code&gt;line.separator&lt;/code&gt; 所定义。使用指定的字符集将字符编码为字节。</target>
        </trans-unit>
        <trans-unit id="deab5959d8a2b2e287acf5a1e8d177d50eebcbfc" translate="yes" xml:space="preserve">
          <source>Write permission, group.</source>
          <target state="translated">写权限,嵽。</target>
        </trans-unit>
        <trans-unit id="ded98708196db3375d703bc829781b7516b5d82b" translate="yes" xml:space="preserve">
          <source>Write permission, others.</source>
          <target state="translated">写权限,其他。</target>
        </trans-unit>
        <trans-unit id="b5122274cf00f9236d161b83cf0b1959eac868b3" translate="yes" xml:space="preserve">
          <source>Write permission, owner.</source>
          <target state="translated">写允许,业主。</target>
        </trans-unit>
        <trans-unit id="dc4ca2f6cd629c41dd78f0c1bd4a77413a6ba272" translate="yes" xml:space="preserve">
          <source>Write text to the output</source>
          <target state="translated">将文本写入输出</target>
        </trans-unit>
        <trans-unit id="c27677af8097cdc9a850db19aa4fc10ea237786a" translate="yes" xml:space="preserve">
          <source>Write the XML Declaration.</source>
          <target state="translated">编写XML声明。</target>
        </trans-unit>
        <trans-unit id="34ae6a769a32d1c96d1a4d08e0485664c6f49728" translate="yes" xml:space="preserve">
          <source>Write the XML Declaration. Defaults the XML version to 1.0</source>
          <target state="translated">编写XML声明。默认XML版本为1.0。</target>
        </trans-unit>
        <trans-unit id="d8fdef7127a3c69001637df99c66003fee11b2af" translate="yes" xml:space="preserve">
          <source>Write the XML Declaration. Defaults the XML version to 1.0, and the encoding to utf-8</source>
          <target state="translated">编写XML声明。默认XML版本为1.0,编码为utf-8。</target>
        </trans-unit>
        <trans-unit id="ab1b062ab03bc27d496ac4ab537a5eded352d293" translate="yes" xml:space="preserve">
          <source>Write the XML Declaration. Note that the encoding parameter does not set the actual encoding of the underlying output. That must be set when the instance of the XMLStreamWriter is created using the XMLOutputFactory</source>
          <target state="translated">编写XML声明。请注意,编码参数并不能设置底层输出的实际编码。这必须在使用 XMLOutputFactory 创建 XMLStreamWriter 实例时设置。</target>
        </trans-unit>
        <trans-unit id="9895c1ecb033c87ffe0c615c065d32dfcc621b1a" translate="yes" xml:space="preserve">
          <source>Write the buffered fields to the stream.</source>
          <target state="translated">将缓冲字段写到流中。</target>
        </trans-unit>
        <trans-unit id="f155bd1e4a1fbf0d9f77f04b5cf3659190cb7a16" translate="yes" xml:space="preserve">
          <source>Write the data and fields to the specified ObjectOutput stream, which must be the same stream that produced this &lt;code&gt;PutField&lt;/code&gt; object.</source>
          <target state="translated">将数据和字段写入指定的ObjectOutput流，该流必须与产生此 &lt;code&gt;PutField&lt;/code&gt; 对象的流相同。</target>
        </trans-unit>
        <trans-unit id="2d78cda2a78c150de7205e7faea5f60ac062cf74" translate="yes" xml:space="preserve">
          <source>Write the new values to the data source if there is no conflict</source>
          <target state="translated">如果没有冲突,将新的值写入数据源。</target>
        </trans-unit>
        <trans-unit id="0eb67d8d108ef50bcb4d3a9affa038eaff061a85" translate="yes" xml:space="preserve">
          <source>Write the non-static and non-transient fields of the current class to this stream.</source>
          <target state="translated">将当前类的非静态和非瞬态字段写入此流。</target>
        </trans-unit>
        <trans-unit id="ab3c2de8de514c7b931148e12444f33c0c77a32e" translate="yes" xml:space="preserve">
          <source>Write the non-static and non-transient fields of the current class to this stream. This may only be called from the writeObject method of the class being serialized. It will throw the NotActiveException if it is called otherwise.</source>
          <target state="translated">将当前类的非静态和非瞬态字段写入这个流。这只能从被序列化的类的writeObject方法中调用,否则将抛出NotActiveException。如果不这样做,它将抛出NotActiveException。</target>
        </trans-unit>
        <trans-unit id="2edab8000ccaace4ff203cc13300679ac4b1d96b" translate="yes" xml:space="preserve">
          <source>Write the specified class descriptor to the ObjectOutputStream.</source>
          <target state="translated">将指定的类描述符写入ObjectOutputStream。</target>
        </trans-unit>
        <trans-unit id="c8f5b81bb83d33a942ae2cbeb1415c3a0749b149" translate="yes" xml:space="preserve">
          <source>Write the specified class descriptor to the ObjectOutputStream. Class descriptors are used to identify the classes of objects written to the stream. Subclasses of ObjectOutputStream may override this method to customize the way in which class descriptors are written to the serialization stream. The corresponding method in ObjectInputStream, &lt;code&gt;readClassDescriptor&lt;/code&gt;, should then be overridden to reconstitute the class descriptor from its custom stream representation. By default, this method writes class descriptors according to the format defined in the Object Serialization specification.</source>
          <target state="translated">将指定的类描述符写入ObjectOutputStream。类描述符用于标识写入流的对象的类。ObjectOutputStream的子类可以重写此方法，以自定义将类描述符写入序列化流的方式。然后，应重写ObjectInputStream中的相应方法 &lt;code&gt;readClassDescriptor&lt;/code&gt; ，以从其自定义流表示形式重新构造类描述符。默认情况下，此方法根据对象序列化规范中定义的格式编写类描述符。</target>
        </trans-unit>
        <trans-unit id="561471854d9e617fefb6f5e631dd834e2f7a127c" translate="yes" xml:space="preserve">
          <source>Write the specified object to the ObjectOutputStream.</source>
          <target state="translated">将指定的对象写入ObjectOutputStream。</target>
        </trans-unit>
        <trans-unit id="677457df7e5bc80c0b6feefc69e3beb6b15a7123" translate="yes" xml:space="preserve">
          <source>Write the specified object to the ObjectOutputStream. The class of the object, the signature of the class, and the values of the non-transient and non-static fields of the class and all of its supertypes are written. Default serialization for a class can be overridden using the writeObject and the readObject methods. Objects referenced by this object are written transitively so that a complete equivalent graph of objects can be reconstructed by an ObjectInputStream.</source>
          <target state="translated">将指定的对象写入ObjectOutputStream。对象的类、类的签名、类的非瞬态和非静态字段的值以及它的所有超类型都被写入。类的默认序列化可以使用writeObject和readObject方法重写。该对象所引用的对象被中转地写入,这样就可以通过ObjectInputStream重建一个完整的对象等价图。</target>
        </trans-unit>
        <trans-unit id="d8c20a4b40326e735cd9da6418440d4414b1a4ab" translate="yes" xml:space="preserve">
          <source>Write the specified object to the output stream.</source>
          <target state="translated">将指定的对象写入输出流。</target>
        </trans-unit>
        <trans-unit id="625c55deeb63764ede0c1729277f79d569d6d1fa" translate="yes" xml:space="preserve">
          <source>Write the specified object to the output stream. The serialized form will denote a series of expressions, the combined effect of which will create an equivalent object when the input stream is read. By default, the object is assumed to be a &lt;em&gt;JavaBean&lt;/em&gt; with a nullary constructor, whose state is defined by the matching pairs of &quot;setter&quot; and &quot;getter&quot; methods returned by the Introspector.</source>
          <target state="translated">将指定的对象写入输出流。序列化的形式将表示一系列表达式，当读取输入流时，其组合效果将创建一个等效的对象。默认情况下，该对象假定为具有null 构造函数的&lt;em&gt;JavaBean&lt;/em&gt;，其状态由Introspector返回的匹配对&amp;ldquo; setter&amp;rdquo;和&amp;ldquo; getter&amp;rdquo;方法定义。</target>
        </trans-unit>
        <trans-unit id="a0f768933c7776774b2478fd947d9ef03d2ebe96" translate="yes" xml:space="preserve">
          <source>Write this &lt;code&gt;ICC_Profile&lt;/code&gt; to a file.</source>
          <target state="translated">将此 &lt;code&gt;ICC_Profile&lt;/code&gt; 写入文件。</target>
        </trans-unit>
        <trans-unit id="278995a53b7c0304511a3172b13a3a18f1b7e97c" translate="yes" xml:space="preserve">
          <source>Write this &lt;code&gt;ICC_Profile&lt;/code&gt; to an &lt;code&gt;OutputStream&lt;/code&gt;.</source>
          <target state="translated">写这篇文章 &lt;code&gt;ICC_Profile&lt;/code&gt; 到 &lt;code&gt;OutputStream&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="35fe4c369854ef11a28df02657f28c0c907503a3" translate="yes" xml:space="preserve">
          <source>Write this ICC_Profile to a file.</source>
          <target state="translated">将此ICC_Profile写入一个文件。</target>
        </trans-unit>
        <trans-unit id="e1d9c07bfd2efb9ad99f30ea021931a574f4f6d6" translate="yes" xml:space="preserve">
          <source>Write this ICC_Profile to an OutputStream.</source>
          <target state="translated">将此ICC_Profile写入一个输出流。</target>
        </trans-unit>
        <trans-unit id="936da01feb2f096577e8365b734cb08599ce6a37" translate="yes" xml:space="preserve">
          <source>WriteAbortedException</source>
          <target state="translated">WriteAbortedException</target>
        </trans-unit>
        <trans-unit id="6248c802937f8babd7f472dab3a9ccaa3cd8ca1e" translate="yes" xml:space="preserve">
          <source>WriteAbortedException.getCause()</source>
          <target state="translated">WriteAbortedException.getCause()</target>
        </trans-unit>
        <trans-unit id="d927b7d3922dccb6d4373916a1a508a5f9825f5b" translate="yes" xml:space="preserve">
          <source>WriteAbortedException.getMessage()</source>
          <target state="translated">WriteAbortedException.getMessage()</target>
        </trans-unit>
        <trans-unit id="9ee45a046a695fc62952355259c464d3782298a5" translate="yes" xml:space="preserve">
          <source>WriteLock</source>
          <target state="translated">WriteLock</target>
        </trans-unit>
        <trans-unit id="7c5510f1ed33e3b93fd55caec8daa43bd1ce2d2f" translate="yes" xml:space="preserve">
          <source>WritePendingException</source>
          <target state="translated">WritePendingException</target>
        </trans-unit>
        <trans-unit id="5f435830a7c07f19c4072a88821b38028c3f69e6" translate="yes" xml:space="preserve">
          <source>Writer</source>
          <target state="translated">Writer</target>
        </trans-unit>
        <trans-unit id="3a612b47fe0eec805b37e580fcd5618c583e4cf4" translate="yes" xml:space="preserve">
          <source>Writer.append()</source>
          <target state="translated">Writer.append()</target>
        </trans-unit>
        <trans-unit id="b91c0ca8400fde6125b0c11f2497f37000c08a06" translate="yes" xml:space="preserve">
          <source>Writer.close()</source>
          <target state="translated">Writer.close()</target>
        </trans-unit>
        <trans-unit id="e0c57d77abf55ac12872750811814a29d64dcbfe" translate="yes" xml:space="preserve">
          <source>Writer.flush()</source>
          <target state="translated">Writer.flush()</target>
        </trans-unit>
        <trans-unit id="6b58bc364a56f8d61ed239ce03e81a9366cf0f8e" translate="yes" xml:space="preserve">
          <source>Writer.write()</source>
          <target state="translated">Writer.write()</target>
        </trans-unit>
        <trans-unit id="b2be28b744c30e1c5c5fb3a3d946aee604890aab" translate="yes" xml:space="preserve">
          <source>Writers should call &lt;code&gt;clearAbortRequest&lt;/code&gt; at the beginning of each write operation, and poll the value of &lt;code&gt;abortRequested&lt;/code&gt; regularly during the write.</source>
          <target state="translated">编写者应在每次写操作开始时调用 &lt;code&gt;clearAbortRequest&lt;/code&gt; ,并在写操作期间定期轮询 &lt;code&gt;abortRequested&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="aecde5df091918dfeffcca27e002a97115f41c8d" translate="yes" xml:space="preserve">
          <source>Writers that do not make use of stream metadata (</source>
          <target state="translated">不使用流元数据的编写者(</target>
        </trans-unit>
        <trans-unit id="2005d7caf2832e9b66c2ea6efe4c5aa8727e0190" translate="yes" xml:space="preserve">
          <source>Writes &lt;code&gt;b.length&lt;/code&gt; bytes from the specified byte array to this file output stream.</source>
          <target state="translated">将指定字节数组中的 &lt;code&gt;b.length&lt;/code&gt; 个字节写入此文件输出流。</target>
        </trans-unit>
        <trans-unit id="475a7013d71b2530ccf213898f664fa5353bdd4f" translate="yes" xml:space="preserve">
          <source>Writes &lt;code&gt;b.length&lt;/code&gt; bytes from the specified byte array to this file, starting at the current file pointer.</source>
          <target state="translated">从当前文件指针开始，将 &lt;code&gt;b.length&lt;/code&gt; 个字节从指定的字节数组写入此文件。</target>
        </trans-unit>
        <trans-unit id="94ad317d7b0ac67a67357470a8dfe034c14d2f1b" translate="yes" xml:space="preserve">
          <source>Writes &lt;code&gt;b.length&lt;/code&gt; bytes from the specified byte array to this output stream.</source>
          <target state="translated">将指定字节数组中的 &lt;code&gt;b.length&lt;/code&gt; 个字节写入此输出流。</target>
        </trans-unit>
        <trans-unit id="e624a17a648a4933d0e79844ab18e51cf30d0121" translate="yes" xml:space="preserve">
          <source>Writes &lt;code&gt;b.length&lt;/code&gt; bytes from the specified byte array to this output stream. The general contract for &lt;code&gt;write(b)&lt;/code&gt; is that it should have exactly the same effect as the call &lt;code&gt;write(b, 0, b.length)&lt;/code&gt;.</source>
          <target state="translated">将指定字节数组中的 &lt;code&gt;b.length&lt;/code&gt; 个字节写入此输出流。 &lt;code&gt;write(b)&lt;/code&gt; 的一般约定是，它应具有与调用 &lt;code&gt;write(b, 0, b.length)&lt;/code&gt; 完全相同的效果。</target>
        </trans-unit>
        <trans-unit id="5534222ccd82110cbb41a1dc6f9a045112f429c8" translate="yes" xml:space="preserve">
          <source>Writes &lt;code&gt;b.length&lt;/code&gt; bytes to this output stream.</source>
          <target state="translated">将 &lt;code&gt;b.length&lt;/code&gt; 个字节写入此输出流。</target>
        </trans-unit>
        <trans-unit id="c1d0bdd8cec5ae9557cd3f32c364cea21614290d" translate="yes" xml:space="preserve">
          <source>Writes &lt;code&gt;len&lt;/code&gt; bytes from array &lt;code&gt;b&lt;/code&gt;, in order, to the output stream.</source>
          <target state="translated">将数组 &lt;code&gt;b&lt;/code&gt; 中的 &lt;code&gt;len&lt;/code&gt; 个字节依次写入输出流。</target>
        </trans-unit>
        <trans-unit id="9f0e3c34e35200d337717f421eb2f8500aba265d" translate="yes" xml:space="preserve">
          <source>Writes &lt;code&gt;len&lt;/code&gt; bytes from array &lt;code&gt;b&lt;/code&gt;, in order, to the output stream. If &lt;code&gt;b&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, a &lt;code&gt;NullPointerException&lt;/code&gt; is thrown. If &lt;code&gt;off&lt;/code&gt; is negative, or &lt;code&gt;len&lt;/code&gt; is negative, or &lt;code&gt;off+len&lt;/code&gt; is greater than the length of the array &lt;code&gt;b&lt;/code&gt;, then an &lt;code&gt;IndexOutOfBoundsException&lt;/code&gt; is thrown. If &lt;code&gt;len&lt;/code&gt; is zero, then no bytes are written. Otherwise, the byte &lt;code&gt;b[off]&lt;/code&gt; is written first, then &lt;code&gt;b[off+1]&lt;/code&gt;, and so on; the last byte written is &lt;code&gt;b[off+len-1]&lt;/code&gt;.</source>
          <target state="translated">将数组 &lt;code&gt;b&lt;/code&gt; 中的 &lt;code&gt;len&lt;/code&gt; 个字节依次写入输出流。如果 &lt;code&gt;b&lt;/code&gt; 为 &lt;code&gt;null&lt;/code&gt; ，则抛出 &lt;code&gt;NullPointerException&lt;/code&gt; 。如果 &lt;code&gt;off&lt;/code&gt; 为负，或者 &lt;code&gt;len&lt;/code&gt; 为负，或者 &lt;code&gt;off+len&lt;/code&gt; 大于数组 &lt;code&gt;b&lt;/code&gt; 的长度，则抛出 &lt;code&gt;IndexOutOfBoundsException&lt;/code&gt; 。如果 &lt;code&gt;len&lt;/code&gt; 为零，则不写入任何字节。否则，首先写入字节 &lt;code&gt;b[off]&lt;/code&gt; ，然后写入 &lt;code&gt;b[off+1]&lt;/code&gt; ，依此类推；最后写入的字节是 &lt;code&gt;b[off+len-1]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b7493c7432d9d918d61b6c3585fce1581bbd60fd" translate="yes" xml:space="preserve">
          <source>Writes &lt;code&gt;len&lt;/code&gt; bytes from the specified &lt;code&gt;byte&lt;/code&gt; array starting at offset &lt;code&gt;off&lt;/code&gt; to this output stream.</source>
          <target state="translated">写入 &lt;code&gt;len&lt;/code&gt; 个从指定的字节 &lt;code&gt;byte&lt;/code&gt; 数组以抵消 &lt;code&gt;off&lt;/code&gt; 该输出流。</target>
        </trans-unit>
        <trans-unit id="f7ed92cd5964e41ce5935be590a970273e849d1d" translate="yes" xml:space="preserve">
          <source>Writes &lt;code&gt;len&lt;/code&gt; bytes from the specified byte array starting at offset &lt;code&gt;off&lt;/code&gt; to the underlying output stream.</source>
          <target state="translated">写入 &lt;code&gt;len&lt;/code&gt; 个从指定的字节数组起始于偏移 &lt;code&gt;off&lt;/code&gt; 基础输出流。</target>
        </trans-unit>
        <trans-unit id="b90204d909dc82fb7e5d3bbd0045ef72ec9d3faa" translate="yes" xml:space="preserve">
          <source>Writes &lt;code&gt;len&lt;/code&gt; bytes from the specified byte array starting at offset &lt;code&gt;off&lt;/code&gt; to the underlying output stream. If no exception is thrown, the counter &lt;code&gt;written&lt;/code&gt; is incremented by &lt;code&gt;len&lt;/code&gt;.</source>
          <target state="translated">写入 &lt;code&gt;len&lt;/code&gt; 个从指定的字节数组起始于偏移 &lt;code&gt;off&lt;/code&gt; 基础输出流。如果未引发异常，则 &lt;code&gt;written&lt;/code&gt; 的计数器将增加 &lt;code&gt;len&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2a8058c4fe448481ba9f9667cd3950b5d1ac6e95" translate="yes" xml:space="preserve">
          <source>Writes &lt;code&gt;len&lt;/code&gt; bytes from the specified byte array starting at offset &lt;code&gt;off&lt;/code&gt; to this &lt;code&gt;ByteArrayOutputStream&lt;/code&gt;.</source>
          <target state="translated">将指定字节数组中从offset &lt;code&gt;off&lt;/code&gt; 开始的 &lt;code&gt;len&lt;/code&gt; 个字节写入此 &lt;code&gt;ByteArrayOutputStream&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="59c2ffa0a4decb3975339af3e1141064e1cf801f" translate="yes" xml:space="preserve">
          <source>Writes &lt;code&gt;len&lt;/code&gt; bytes from the specified byte array starting at offset &lt;code&gt;off&lt;/code&gt; to this buffered output stream.</source>
          <target state="translated">写入 &lt;code&gt;len&lt;/code&gt; 个从指定的字节数组字节开始偏移量为 &lt;code&gt;off&lt;/code&gt; 此缓冲的输出流。</target>
        </trans-unit>
        <trans-unit id="df6022a3c457bef633289c3b1eea0afc7d2501d2" translate="yes" xml:space="preserve">
          <source>Writes &lt;code&gt;len&lt;/code&gt; bytes from the specified byte array starting at offset &lt;code&gt;off&lt;/code&gt; to this byte array output stream.</source>
          <target state="translated">从指定的字节数组开始将 &lt;code&gt;len&lt;/code&gt; 个字节从offset &lt;code&gt;off&lt;/code&gt; 写入此字节数组输出流。</target>
        </trans-unit>
        <trans-unit id="f47416c1bae43204d3ed0a20b6c785b1c8477de5" translate="yes" xml:space="preserve">
          <source>Writes &lt;code&gt;len&lt;/code&gt; bytes from the specified byte array starting at offset &lt;code&gt;off&lt;/code&gt; to this file output stream.</source>
          <target state="translated">写入 &lt;code&gt;len&lt;/code&gt; 个从指定的字节数组起始于偏移 &lt;code&gt;off&lt;/code&gt; 此文件输出流。</target>
        </trans-unit>
        <trans-unit id="7c910c38a8bd891a83fe0ebe30f88a0297205886" translate="yes" xml:space="preserve">
          <source>Writes &lt;code&gt;len&lt;/code&gt; bytes from the specified byte array starting at offset &lt;code&gt;off&lt;/code&gt; to this file.</source>
          <target state="translated">从指定的字节数组开始将 &lt;code&gt;len&lt;/code&gt; 个字节从offset &lt;code&gt;off&lt;/code&gt; 写入此文件。</target>
        </trans-unit>
        <trans-unit id="38c566418d538790a5eeae487d789010f4523286" translate="yes" xml:space="preserve">
          <source>Writes &lt;code&gt;len&lt;/code&gt; bytes from the specified byte array starting at offset &lt;code&gt;off&lt;/code&gt; to this output stream.</source>
          <target state="translated">写入 &lt;code&gt;len&lt;/code&gt; 个从指定的字节数组起始于偏移 &lt;code&gt;off&lt;/code&gt; 此输出流。</target>
        </trans-unit>
        <trans-unit id="4f851862b3139a3a60a822bd0fb6f38f95f98ef1" translate="yes" xml:space="preserve">
          <source>Writes &lt;code&gt;len&lt;/code&gt; bytes from the specified byte array starting at offset &lt;code&gt;off&lt;/code&gt; to this output stream. The general contract for &lt;code&gt;write(b, off, len)&lt;/code&gt; is that some of the bytes in the array &lt;code&gt;b&lt;/code&gt; are written to the output stream in order; element &lt;code&gt;b[off]&lt;/code&gt; is the first byte written and &lt;code&gt;b[off+len-1]&lt;/code&gt; is the last byte written by this operation.</source>
          <target state="translated">写入 &lt;code&gt;len&lt;/code&gt; 个从指定的字节数组起始于偏移 &lt;code&gt;off&lt;/code&gt; 此输出流。 &lt;code&gt;write(b, off, len)&lt;/code&gt; 的一般约定是数组 &lt;code&gt;b&lt;/code&gt; 中的某些字节按顺序写入输出流；元素 &lt;code&gt;b[off]&lt;/code&gt; 是此操作写入的第一个字节， &lt;code&gt;b[off+len-1]&lt;/code&gt; 是此操作写入的最后一个字节。</target>
        </trans-unit>
        <trans-unit id="c116a4517eaa68fb9db4dc9686e30823cb0481f2" translate="yes" xml:space="preserve">
          <source>Writes &lt;code&gt;len&lt;/code&gt; bytes from the specified byte array starting at offset &lt;code&gt;off&lt;/code&gt; to this piped output stream.</source>
          <target state="translated">写入 &lt;code&gt;len&lt;/code&gt; 个从指定的字节数组起始于偏移 &lt;code&gt;off&lt;/code&gt; 此传送输出流。</target>
        </trans-unit>
        <trans-unit id="131be3d9bd6c996bc02177007f5a10d152efcafd" translate="yes" xml:space="preserve">
          <source>Writes &lt;code&gt;len&lt;/code&gt; bytes from the specified byte array starting at offset &lt;code&gt;off&lt;/code&gt; to this piped output stream. This method blocks until all the bytes are written to the output stream.</source>
          <target state="translated">写入 &lt;code&gt;len&lt;/code&gt; 个从指定的字节数组起始于偏移 &lt;code&gt;off&lt;/code&gt; 此传送输出流。该方法将阻塞，直到将所有字节写入输出流为止。</target>
        </trans-unit>
        <trans-unit id="629af15734b4e0f5ce6696e3b16a10fcb7aa816f" translate="yes" xml:space="preserve">
          <source>Writes &lt;code&gt;len&lt;/code&gt; bytes from the specified byte array starting at offset &lt;code&gt;off&lt;/code&gt; to this stream.</source>
          <target state="translated">写入 &lt;code&gt;len&lt;/code&gt; 个从指定的字节数组字节开始偏移量为 &lt;code&gt;off&lt;/code&gt; 此流。</target>
        </trans-unit>
        <trans-unit id="1cf544354bc9caf492bbe86ef1abd2a2a4934186" translate="yes" xml:space="preserve">
          <source>Writes &lt;code&gt;len&lt;/code&gt; bytes from the specified byte array starting at offset &lt;code&gt;off&lt;/code&gt; to this stream. If automatic flushing is enabled then the &lt;code&gt;flush&lt;/code&gt; method will be invoked.</source>
          <target state="translated">从指定的字节数组开始将 &lt;code&gt;len&lt;/code&gt; 个字节从offset &lt;code&gt;off&lt;/code&gt; 开始写入此流。如果启用了自动刷新，则将调用 &lt;code&gt;flush&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="0325a3c22e720aad80e29d337fb29a1216024c8d" translate="yes" xml:space="preserve">
          <source>Writes &lt;code&gt;len&lt;/code&gt; characters from the specified character array starting at offset &lt;code&gt;off&lt;/code&gt; to this piped output stream.</source>
          <target state="translated">将指定字符数组中的 &lt;code&gt;len&lt;/code&gt; 个字符从偏移量 &lt;code&gt;off&lt;/code&gt; 写入此管道输出流。</target>
        </trans-unit>
        <trans-unit id="f574fcc90500ee21973d3a8593ee72900cccc153" translate="yes" xml:space="preserve">
          <source>Writes &lt;code&gt;len&lt;/code&gt; characters from the specified character array starting at offset &lt;code&gt;off&lt;/code&gt; to this piped output stream. This method blocks until all the characters are written to the output stream. If a thread was reading data characters from the connected piped input stream, but the thread is no longer alive, then an &lt;code&gt;IOException&lt;/code&gt; is thrown.</source>
          <target state="translated">将指定字符数组中的 &lt;code&gt;len&lt;/code&gt; 个字符从offset &lt;code&gt;off&lt;/code&gt; 开始写入此管道输出流。在所有字符都写入输出流之前，此方法将阻塞。如果线程正在从连接的管道输入流中读取数据字符，但是该线程不再活动，则将引发 &lt;code&gt;IOException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f01163c247ccac36f98237d94dc0b5ab8aaa2406" translate="yes" xml:space="preserve">
          <source>Writes &lt;code&gt;len&lt;/code&gt; characters of &lt;code&gt;str&lt;/code&gt;, starting at character &lt;code&gt;offset&lt;/code&gt;, to the &lt;code&gt;CLOB&lt;/code&gt; value that this &lt;code&gt;Clob&lt;/code&gt; represents.</source>
          <target state="translated">将 &lt;code&gt;str&lt;/code&gt; 的 &lt;code&gt;len&lt;/code&gt; 个字符（从字符 &lt;code&gt;offset&lt;/code&gt; 开始）写入此 &lt;code&gt;Clob&lt;/code&gt; 表示的 &lt;code&gt;CLOB&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="89daa9fc4ab3d15a77384b157392739823e5c257" translate="yes" xml:space="preserve">
          <source>Writes &lt;code&gt;len&lt;/code&gt; characters of &lt;code&gt;str&lt;/code&gt;, starting at character &lt;code&gt;offset&lt;/code&gt;, to the &lt;code&gt;CLOB&lt;/code&gt; value that this &lt;code&gt;Clob&lt;/code&gt; represents. The string will overwrite the existing characters in the &lt;code&gt;Clob&lt;/code&gt; object starting at the position &lt;code&gt;pos&lt;/code&gt;. If the end of the &lt;code&gt;Clob&lt;/code&gt; value is reached while writing the given string, then the length of the &lt;code&gt;Clob&lt;/code&gt; value will be increased to accommodate the extra characters.</source>
          <target state="translated">将 &lt;code&gt;str&lt;/code&gt; 的 &lt;code&gt;len&lt;/code&gt; 个字符（从字符 &lt;code&gt;offset&lt;/code&gt; 开始）写入此 &lt;code&gt;Clob&lt;/code&gt; 表示的 &lt;code&gt;CLOB&lt;/code&gt; 值。该字符串将从位置 &lt;code&gt;pos&lt;/code&gt; 开始覆盖 &lt;code&gt;Clob&lt;/code&gt; 对象中的现有字符。如果年底 &lt;code&gt;Clob&lt;/code&gt; 一边写定的字符串是否达到了值，则长度 &lt;code&gt;Clob&lt;/code&gt; 值将增加以容纳额外的字符。</target>
        </trans-unit>
        <trans-unit id="851de5604a486c60e5125c7a29a7e550895176b8" translate="yes" xml:space="preserve">
          <source>Writes A Portion of an array of characters.</source>
          <target state="translated">写入一个字符数组的一部分。</target>
        </trans-unit>
        <trans-unit id="a283b0703eab7e9782450eee6c79c7aaaa9c7957" translate="yes" xml:space="preserve">
          <source>Writes a 16 bit char.</source>
          <target state="translated">写一个16位的字符。</target>
        </trans-unit>
        <trans-unit id="ca54d5eb5995c8bab76c02647925ee1f9521c712" translate="yes" xml:space="preserve">
          <source>Writes a 16 bit short.</source>
          <target state="translated">写一个16位的短。</target>
        </trans-unit>
        <trans-unit id="057353e65922065a994b45703b910bf34047ab73" translate="yes" xml:space="preserve">
          <source>Writes a 32 bit float.</source>
          <target state="translated">写一个32位的浮点数。</target>
        </trans-unit>
        <trans-unit id="c587a1942eeaf8dca64d6b527fb861b258ae3eb4" translate="yes" xml:space="preserve">
          <source>Writes a 32 bit int.</source>
          <target state="translated">写一个32位的int。</target>
        </trans-unit>
        <trans-unit id="6071f86794e94e93ef2903e2a285a17fb6ff2270" translate="yes" xml:space="preserve">
          <source>Writes a 64 bit double.</source>
          <target state="translated">写一个64位的双。</target>
        </trans-unit>
        <trans-unit id="ff1fe9b0868e3a400b0850e8cb5d3afef880236e" translate="yes" xml:space="preserve">
          <source>Writes a 64 bit long.</source>
          <target state="translated">写一个64位的长。</target>
        </trans-unit>
        <trans-unit id="144135fe6a8176a2fd809e5dce65a41b9d674878" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;Blob&lt;/code&gt; object in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object.</source>
          <target state="translated">将Java编程语言中的 &lt;code&gt;Blob&lt;/code&gt; 对象写入此 &lt;code&gt;SQLOutputImpl&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="c56efcb35978d3f06a812ffb670b34f94389cacc" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;Blob&lt;/code&gt; object in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object. The driver converts it to a serializable &lt;code&gt;SerialBlob&lt;/code&gt; SQL &lt;code&gt;BLOB&lt;/code&gt; value before returning it to the database.</source>
          <target state="translated">将Java编程语言中的 &lt;code&gt;Blob&lt;/code&gt; 对象写入此 &lt;code&gt;SQLOutputImpl&lt;/code&gt; 对象。驱动程序在将其返回数据库之前将其转换为可序列化的 &lt;code&gt;SerialBlob&lt;/code&gt; SQL &lt;code&gt;BLOB&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="27ea08fa6afe5ea479439001df19499ba21a8430" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;Clob&lt;/code&gt; object in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object.</source>
          <target state="translated">用Java编程语言将 &lt;code&gt;Clob&lt;/code&gt; 对象写入此 &lt;code&gt;SQLOutputImpl&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="f08e5c41b2c35f3a884d25f9d8a8bfb34ced6103" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;Clob&lt;/code&gt; object in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object. The driver converts it to a serializable &lt;code&gt;SerialClob&lt;/code&gt; SQL &lt;code&gt;CLOB&lt;/code&gt; value before returning it to the database.</source>
          <target state="translated">用Java编程语言将 &lt;code&gt;Clob&lt;/code&gt; 对象写入此 &lt;code&gt;SQLOutputImpl&lt;/code&gt; 对象。驱动程序将其转换为可序列化的 &lt;code&gt;SerialClob&lt;/code&gt; SQL &lt;code&gt;CLOB&lt;/code&gt; 值，然后再将其返回数据库。</target>
        </trans-unit>
        <trans-unit id="798be35dcc4f07fd6b0ae715272f89610fd64df1" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;Ref&lt;/code&gt; object in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object.</source>
          <target state="translated">用Java编程语言将 &lt;code&gt;Ref&lt;/code&gt; 对象写入此 &lt;code&gt;SQLOutputImpl&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="636814d8cf3b67bf23c99b7f771ee075f88a3374" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;Ref&lt;/code&gt; object in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object. The driver converts it to a serializable &lt;code&gt;SerialRef&lt;/code&gt; SQL &lt;code&gt;REF&lt;/code&gt; value before returning it to the database.</source>
          <target state="translated">用Java编程语言将 &lt;code&gt;Ref&lt;/code&gt; 对象写入此 &lt;code&gt;SQLOutputImpl&lt;/code&gt; 对象。驱动程序 &lt;code&gt;SerialRef&lt;/code&gt; 其转换为可序列化的SerialRef SQL &lt;code&gt;REF&lt;/code&gt; 值，然后再将其返回数据库。</target>
        </trans-unit>
        <trans-unit id="7f8faba2a0fd1366ce7b8632168b17391d486b5e" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;String&lt;/code&gt; in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object.</source>
          <target state="translated">用Java编程语言将 &lt;code&gt;String&lt;/code&gt; 写入此 &lt;code&gt;SQLOutputImpl&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="1d363669fd2b9a7fa973904d4dc302d0c14ca56c" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;String&lt;/code&gt; in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object. The driver converts it to an SQL &lt;code&gt;CHAR&lt;/code&gt;, &lt;code&gt;VARCHAR&lt;/code&gt;, or &lt;code&gt;LONGVARCHAR&lt;/code&gt; before returning it to the database.</source>
          <target state="translated">用Java编程语言将 &lt;code&gt;String&lt;/code&gt; 写入此 &lt;code&gt;SQLOutputImpl&lt;/code&gt; 对象。驱动程序在将其返回数据库之前将其转换为SQL &lt;code&gt;CHAR&lt;/code&gt; ， &lt;code&gt;VARCHAR&lt;/code&gt; 或 &lt;code&gt;LONGVARCHAR&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a3c82abcc2a6031cf5de89c3f40ed0c7b95e4503" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;Struct&lt;/code&gt; object in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object.</source>
          <target state="translated">用Java编程语言将 &lt;code&gt;Struct&lt;/code&gt; 对象写入此 &lt;code&gt;SQLOutputImpl&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="35bce86c88fab81328de73526546c89a47a0e4b2" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;Struct&lt;/code&gt; object in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object. The driver converts this value to an SQL structured type before returning it to the database.</source>
          <target state="translated">用Java编程语言将 &lt;code&gt;Struct&lt;/code&gt; 对象写入此 &lt;code&gt;SQLOutputImpl&lt;/code&gt; 对象。驱动程序将此值转换为SQL结构类型，然后再将其返回数据库。</target>
        </trans-unit>
        <trans-unit id="1fa37549b16c8a2519ce9a3687936f0f07666745" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;boolean&lt;/code&gt; in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object.</source>
          <target state="translated">用Java编程语言向此 &lt;code&gt;SQLOutputImpl&lt;/code&gt; 对象写入一个 &lt;code&gt;boolean&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="61ea925b355afa858794bc3e803f693c259afae1" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;boolean&lt;/code&gt; in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object. The driver converts it to an SQL &lt;code&gt;BIT&lt;/code&gt; before returning it to the database.</source>
          <target state="translated">用Java编程语言向此 &lt;code&gt;SQLOutputImpl&lt;/code&gt; 对象写入一个 &lt;code&gt;boolean&lt;/code&gt; 。驱动程序在将其返回数据库之前将其转换为SQL &lt;code&gt;BIT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="155670a01232f738dceb009105519f94cd2248c1" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;boolean&lt;/code&gt; to the file as a one-byte value.</source>
          <target state="translated">将 &lt;code&gt;boolean&lt;/code&gt; 作为一个字节的值写入文件。</target>
        </trans-unit>
        <trans-unit id="6349876fc09182b7513e2eb1fd4bd3e55d4b98d6" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;boolean&lt;/code&gt; to the file as a one-byte value. The value &lt;code&gt;true&lt;/code&gt; is written out as the value &lt;code&gt;(byte)1&lt;/code&gt;; the value &lt;code&gt;false&lt;/code&gt; is written out as the value &lt;code&gt;(byte)0&lt;/code&gt;. The write starts at the current position of the file pointer.</source>
          <target state="translated">将 &lt;code&gt;boolean&lt;/code&gt; 作为一个字节的值写入文件。值 &lt;code&gt;true&lt;/code&gt; 被写为值 &lt;code&gt;(byte)1&lt;/code&gt; ；值 &lt;code&gt;false&lt;/code&gt; 被写为值 &lt;code&gt;(byte)0&lt;/code&gt; 。写入从文件指针的当前位置开始。</target>
        </trans-unit>
        <trans-unit id="12b530b90dc8d6c34bfe7ce905c795548bb350b9" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;boolean&lt;/code&gt; to the underlying output stream as a 1-byte value.</source>
          <target state="translated">将 &lt;code&gt;boolean&lt;/code&gt; 作为1字节的值写入基础输出流。</target>
        </trans-unit>
        <trans-unit id="0cf2d9ed9e1c02ddbe3d89c723dcba2e53e42da9" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;boolean&lt;/code&gt; to the underlying output stream as a 1-byte value. The value &lt;code&gt;true&lt;/code&gt; is written out as the value &lt;code&gt;(byte)1&lt;/code&gt;; the value &lt;code&gt;false&lt;/code&gt; is written out as the value &lt;code&gt;(byte)0&lt;/code&gt;. If no exception is thrown, the counter &lt;code&gt;written&lt;/code&gt; is incremented by &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;boolean&lt;/code&gt; 作为1字节的值写入基础输出流。值 &lt;code&gt;true&lt;/code&gt; 被写为值 &lt;code&gt;(byte)1&lt;/code&gt; ；值 &lt;code&gt;false&lt;/code&gt; 被写为值 &lt;code&gt;(byte)0&lt;/code&gt; 。如果未引发异常，则 &lt;code&gt;written&lt;/code&gt; 的计数器将增加 &lt;code&gt;1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ccab39520060070dde762a951b5e9f4cef217922" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;boolean&lt;/code&gt; value to the stream.</source>
          <target state="translated">将 &lt;code&gt;boolean&lt;/code&gt; 值写入流。</target>
        </trans-unit>
        <trans-unit id="95726257c14b22438de24b52e49b6a02de7eab08" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;boolean&lt;/code&gt; value to the stream. If &lt;code&gt;v&lt;/code&gt; is true, the value &lt;code&gt;(byte)1&lt;/code&gt; is written; if &lt;code&gt;v&lt;/code&gt; is false, the value &lt;code&gt;(byte)0&lt;/code&gt; is written.</source>
          <target state="translated">将 &lt;code&gt;boolean&lt;/code&gt; 值写入流。如果 &lt;code&gt;v&lt;/code&gt; 为true，则写入值 &lt;code&gt;(byte)1&lt;/code&gt; ；否则为0。如果 &lt;code&gt;v&lt;/code&gt; 为假，则写入值 &lt;code&gt;(byte)0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7954ffaaa34e2883ad4a1325fb8863bb017aa172" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;boolean&lt;/code&gt; value to this output stream.</source>
          <target state="translated">将 &lt;code&gt;boolean&lt;/code&gt; 值写入此输出流。</target>
        </trans-unit>
        <trans-unit id="ab4b1822b1f04ea72708cfe5295251a6c88b3464" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;boolean&lt;/code&gt; value to this output stream. If the argument &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the value &lt;code&gt;(byte)1&lt;/code&gt; is written; if &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, the value &lt;code&gt;(byte)0&lt;/code&gt; is written. The byte written by this method may be read by the &lt;code&gt;readBoolean&lt;/code&gt; method of interface &lt;code&gt;DataInput&lt;/code&gt;, which will then return a &lt;code&gt;boolean&lt;/code&gt; equal to &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;boolean&lt;/code&gt; 值写入此输出流。如果参数 &lt;code&gt;v&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ，则写入值 &lt;code&gt;(byte)1&lt;/code&gt; ；如果 &lt;code&gt;v&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; ，则写入值 &lt;code&gt;(byte)0&lt;/code&gt; 。可以通过 &lt;code&gt;DataInput&lt;/code&gt; 接口的 &lt;code&gt;readBoolean&lt;/code&gt; 方法读取此方法写入的字节，该方法将返回一个等于 &lt;code&gt;v&lt;/code&gt; 的 &lt;code&gt;boolean&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cc0bdbc304ed1a878f530d104ecb981483b8abc6" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;byte&lt;/code&gt; in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object.</source>
          <target state="translated">用Java编程语言向此 &lt;code&gt;SQLOutputImpl&lt;/code&gt; 对象写入一个 &lt;code&gt;byte&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d24a0d82e4ec0d4586e61016d6bb4cb55ac02d93" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;byte&lt;/code&gt; in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object. The driver converts it to an SQL &lt;code&gt;BIT&lt;/code&gt; before returning it to the database.</source>
          <target state="translated">用Java编程语言向此 &lt;code&gt;SQLOutputImpl&lt;/code&gt; 对象写入一个 &lt;code&gt;byte&lt;/code&gt; 。驱动程序在将其返回数据库之前将其转换为SQL &lt;code&gt;BIT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="226b956afa02c16af4e38b4a4db3a94bf6b32311" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;byte&lt;/code&gt; to the file as a one-byte value.</source>
          <target state="translated">将一个 &lt;code&gt;byte&lt;/code&gt; 作为一个字节的值写入文件。</target>
        </trans-unit>
        <trans-unit id="f2a444c3352131269a2014fd441028ab3058f1b7" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;byte&lt;/code&gt; to the file as a one-byte value. The write starts at the current position of the file pointer.</source>
          <target state="translated">将一个 &lt;code&gt;byte&lt;/code&gt; 作为一个字节的值写入文件。写入从文件指针的当前位置开始。</target>
        </trans-unit>
        <trans-unit id="a939e11e65fc3a32a69989756481896e92055cac" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;char&lt;/code&gt; to the file as a two-byte value, high byte first.</source>
          <target state="translated">将 &lt;code&gt;char&lt;/code&gt; 作为两个字节的值写入文件，高字节在前。</target>
        </trans-unit>
        <trans-unit id="09a398562bfe5665a5c3cb088f44ff93b0c13218" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;char&lt;/code&gt; to the file as a two-byte value, high byte first. The write starts at the current position of the file pointer.</source>
          <target state="translated">将 &lt;code&gt;char&lt;/code&gt; 作为两个字节的值写入文件，高字节在前。写入从文件指针的当前位置开始。</target>
        </trans-unit>
        <trans-unit id="7a8024ee2d733a5dde0d484821170eb30275a356" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;char&lt;/code&gt; to the underlying output stream as a 2-byte value, high byte first.</source>
          <target state="translated">将 &lt;code&gt;char&lt;/code&gt; 作为2字节的值写入底层输出流，高字节在前。</target>
        </trans-unit>
        <trans-unit id="b0f1c2dfbde644fbb6c4c155f32906af8e2ee5c6" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;char&lt;/code&gt; to the underlying output stream as a 2-byte value, high byte first. If no exception is thrown, the counter &lt;code&gt;written&lt;/code&gt; is incremented by &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;char&lt;/code&gt; 作为2字节的值写入基础输出流，高字节在前。如果未引发异常，则 &lt;code&gt;written&lt;/code&gt; 的计数器将增加 &lt;code&gt;2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1bbc6d917ff455c037781056578d00e4f4b388cd" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;char&lt;/code&gt; value, which is comprised of two bytes, to the output stream.</source>
          <target state="translated">将由两个字节组成的 &lt;code&gt;char&lt;/code&gt; 值写入输出流。</target>
        </trans-unit>
        <trans-unit id="e93587e1f09c65fb748c39e365179e015b1c4a2e" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;char&lt;/code&gt; value, which is comprised of two bytes, to the output stream. The byte values to be written, in the order shown, are:</source>
          <target state="translated">将由两个字节组成的 &lt;code&gt;char&lt;/code&gt; 值写入输出流。按照所示顺序，要写入的字节值是：</target>
        </trans-unit>
        <trans-unit id="5da554cad4ed11876c2f538fc7a916a28ed5a347" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;double&lt;/code&gt; in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object.</source>
          <target state="translated">用Java编程语言向此 &lt;code&gt;SQLOutputImpl&lt;/code&gt; 对象写入一个 &lt;code&gt;double&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="90b842735b4381060da9c4b5e14aac5d144420c4" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;double&lt;/code&gt; in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object. The driver converts it to an SQL &lt;code&gt;DOUBLE&lt;/code&gt; before returning it to the database.</source>
          <target state="translated">用Java编程语言向此 &lt;code&gt;SQLOutputImpl&lt;/code&gt; 对象写入一个 &lt;code&gt;double&lt;/code&gt; 。驱动程序在将其返回数据库之前将其转换为SQL &lt;code&gt;DOUBLE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6bbd7c92457324520d422019ae1f2be3d912115c" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;double&lt;/code&gt; value, which is comprised of eight bytes, to the output stream.</source>
          <target state="translated">将由八个字节组成的 &lt;code&gt;double&lt;/code&gt; 精度值写入输出流。</target>
        </trans-unit>
        <trans-unit id="f9cf095e7c43223f0750c5a4985360abd3124032" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;double&lt;/code&gt; value, which is comprised of eight bytes, to the output stream. It does this as if it first converts this &lt;code&gt;double&lt;/code&gt; value to a &lt;code&gt;long&lt;/code&gt; in exactly the manner of the &lt;code&gt;Double.doubleToLongBits&lt;/code&gt; method and then writes the &lt;code&gt;long&lt;/code&gt; value in exactly the manner of the &lt;code&gt;writeLong&lt;/code&gt; method. The bytes written by this method may be read by the &lt;code&gt;readDouble&lt;/code&gt; method of interface &lt;code&gt;DataInput&lt;/code&gt;, which will then return a &lt;code&gt;double&lt;/code&gt; equal to &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">将由八个字节组成的 &lt;code&gt;double&lt;/code&gt; 精度值写入输出流。这样做的方式就好像首先按照 &lt;code&gt;Double.doubleToLongBits&lt;/code&gt; 方法的确切方式将这个 &lt;code&gt;double&lt;/code&gt; 值转换为 &lt;code&gt;long&lt;/code&gt; ，然后完全按照 &lt;code&gt;writeLong&lt;/code&gt; 方法的方式写入了 &lt;code&gt;long&lt;/code&gt; 值一样。可以通过 &lt;code&gt;DataInput&lt;/code&gt; 接口的 &lt;code&gt;readDouble&lt;/code&gt; 方法读取此方法写入的字节，然后该方法将返回一个等于 &lt;code&gt;v&lt;/code&gt; 的 &lt;code&gt;double&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a947a1cfaafe404e203be28b1b2303e0b7c673d7" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;double&lt;/code&gt; value, which is comprised of four bytes, to the output stream.</source>
          <target state="translated">将由四个字节组成的 &lt;code&gt;double&lt;/code&gt; 精度值写入输出流。</target>
        </trans-unit>
        <trans-unit id="a4d147e0e0d772cce4f1c826771d88ee33f93033" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;double&lt;/code&gt; value, which is comprised of four bytes, to the output stream. It does this as if it first converts this &lt;code&gt;double&lt;/code&gt; value to a &lt;code&gt;long&lt;/code&gt; in exactly the manner of the &lt;code&gt;Double.doubleToLongBits&lt;/code&gt; method and then writes the long value in exactly the manner of the &lt;code&gt;writeLong&lt;/code&gt; method.</source>
          <target state="translated">将由四个字节组成的 &lt;code&gt;double&lt;/code&gt; 精度值写入输出流。这样做的方式就好像首先按照 &lt;code&gt;Double.doubleToLongBits&lt;/code&gt; 方法的确切方式将这个 &lt;code&gt;double&lt;/code&gt; 值转换为 &lt;code&gt;long&lt;/code&gt; ，然后按照 &lt;code&gt;writeLong&lt;/code&gt; 方法的完全方式写入了long值一样。</target>
        </trans-unit>
        <trans-unit id="74c74f862659641ca760a0b4f5dbfe586ef1a16a" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;double&lt;/code&gt; value, which is comprised of four bytes, to the output stream. It does this as if it first converts this &lt;code&gt;double&lt;/code&gt; value to an &lt;code&gt;long&lt;/code&gt; in exactly the manner of the &lt;code&gt;Double.doubleToLongBits&lt;/code&gt; method and then writes the long value in exactly the manner of the &lt;code&gt;writeLong&lt;/code&gt; method.</source>
          <target state="translated">将由四个字节组成的 &lt;code&gt;double&lt;/code&gt; 值写入输出流。这样做就像是先按照 &lt;code&gt;Double.doubleToLongBits&lt;/code&gt; 方法的完全方式将这个 &lt;code&gt;double&lt;/code&gt; 值转换为 &lt;code&gt;long&lt;/code&gt; ，然后以 &lt;code&gt;writeLong&lt;/code&gt; 方法的完全方式写入long值一样。</target>
        </trans-unit>
        <trans-unit id="696fcd25e8c07d56053db6ad276a63ec4ce34071" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;float&lt;/code&gt; in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object.</source>
          <target state="translated">将Java编程语言的 &lt;code&gt;float&lt;/code&gt; 写入此 &lt;code&gt;SQLOutputImpl&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="e425d4085560efb681f434759145902b95c308e1" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;float&lt;/code&gt; in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object. The driver converts it to an SQL &lt;code&gt;REAL&lt;/code&gt; before returning it to the database.</source>
          <target state="translated">将Java编程语言的 &lt;code&gt;float&lt;/code&gt; 写入此 &lt;code&gt;SQLOutputImpl&lt;/code&gt; 对象。驱动程序在将其返回数据库之前将其转换为SQL &lt;code&gt;REAL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b46ad218b9afdb0674da63775c5ae864b605f115" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;float&lt;/code&gt; value, which is comprised of four bytes, to the output stream.</source>
          <target state="translated">将由四个字节组成的 &lt;code&gt;float&lt;/code&gt; 值写入输出流。</target>
        </trans-unit>
        <trans-unit id="de7505d5b28cd6dc24eb7936640d871233ddd0a4" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;float&lt;/code&gt; value, which is comprised of four bytes, to the output stream. It does this as if it first converts this &lt;code&gt;float&lt;/code&gt; value to an &lt;code&gt;int&lt;/code&gt; in exactly the manner of the &lt;code&gt;Float.floatToIntBits&lt;/code&gt; method and then writes the &lt;code&gt;int&lt;/code&gt; value in exactly the manner of the &lt;code&gt;writeInt&lt;/code&gt; method. The bytes written by this method may be read by the &lt;code&gt;readFloat&lt;/code&gt; method of interface &lt;code&gt;DataInput&lt;/code&gt;, which will then return a &lt;code&gt;float&lt;/code&gt; equal to &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">将由四个字节组成的 &lt;code&gt;float&lt;/code&gt; 值写入输出流。这样做的方式就像是先按照 &lt;code&gt;Float.floatToIntBits&lt;/code&gt; 方法的确切方式将此 &lt;code&gt;float&lt;/code&gt; 值转换为 &lt;code&gt;int&lt;/code&gt; ，然后按照 &lt;code&gt;writeInt&lt;/code&gt; 方法的方式完全写入 &lt;code&gt;int&lt;/code&gt; 值。可以通过 &lt;code&gt;DataInput&lt;/code&gt; 接口的 &lt;code&gt;readFloat&lt;/code&gt; 方法读取此方法写入的字节，该方法将返回一个等于 &lt;code&gt;v&lt;/code&gt; 的 &lt;code&gt;float&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a5bc045873743c0ed400214abeb97588134df17b" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;float&lt;/code&gt; value, which is comprised of four bytes, to the output stream. It does this as if it first converts this &lt;code&gt;float&lt;/code&gt; value to an &lt;code&gt;int&lt;/code&gt; in exactly the manner of the &lt;code&gt;Float.floatToIntBits&lt;/code&gt; method and then writes the int value in exactly the manner of the &lt;code&gt;writeInt&lt;/code&gt; method.</source>
          <target state="translated">将由四个字节组成的 &lt;code&gt;float&lt;/code&gt; 值写入输出流。这样做的方式就像是先按照 &lt;code&gt;Float.floatToIntBits&lt;/code&gt; 方法的完全方式将此 &lt;code&gt;float&lt;/code&gt; 值转换为 &lt;code&gt;int&lt;/code&gt; ，然后按照 &lt;code&gt;writeInt&lt;/code&gt; 方法的方式完全写入int值。</target>
        </trans-unit>
        <trans-unit id="c83ea96896ae8f5436a6aaa4859236c2aaf1ffec" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;java.math.BigDecimal&lt;/code&gt; object in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object.</source>
          <target state="translated">将Java编程语言中的 &lt;code&gt;java.math.BigDecimal&lt;/code&gt; 对象写入此 &lt;code&gt;SQLOutputImpl&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="c4b017c54fe11f7471c30be1a56fe857dd74f0f6" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;java.math.BigDecimal&lt;/code&gt; object in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object. The driver converts it to an SQL &lt;code&gt;NUMERIC&lt;/code&gt; before returning it to the database.</source>
          <target state="translated">将Java编程语言中的 &lt;code&gt;java.math.BigDecimal&lt;/code&gt; 对象写入此 &lt;code&gt;SQLOutputImpl&lt;/code&gt; 对象。驱动程序在将其返回数据库之前将其转换为SQL &lt;code&gt;NUMERIC&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="452031f5ee72921a288236c0b6a26e63a6a7bbc9" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;java.sql.Date&lt;/code&gt; object in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object.</source>
          <target state="translated">将Java编程语言中的 &lt;code&gt;java.sql.Date&lt;/code&gt; 对象写入此 &lt;code&gt;SQLOutputImpl&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="53464c77dc827a0b2303547abdc64eec0dc61db6" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;java.sql.Date&lt;/code&gt; object in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object. The driver converts it to an SQL &lt;code&gt;DATE&lt;/code&gt; before returning it to the database.</source>
          <target state="translated">将Java编程语言中的 &lt;code&gt;java.sql.Date&lt;/code&gt; 对象写入此 &lt;code&gt;SQLOutputImpl&lt;/code&gt; 对象。驱动程序在将其返回数据库之前将其转换为SQL &lt;code&gt;DATE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b620918c71921bd543a3ee3ac81b3d78236ed1eb" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;java.sql.Time&lt;/code&gt; object in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object.</source>
          <target state="translated">将Java编程语言中的 &lt;code&gt;java.sql.Time&lt;/code&gt; 对象写入此 &lt;code&gt;SQLOutputImpl&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="55188659110941d98ac08fcc76d1a090d472b2c1" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;java.sql.Time&lt;/code&gt; object in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object. The driver converts it to an SQL &lt;code&gt;TIME&lt;/code&gt; before returning it to the database.</source>
          <target state="translated">将Java编程语言中的 &lt;code&gt;java.sql.Time&lt;/code&gt; 对象写入此 &lt;code&gt;SQLOutputImpl&lt;/code&gt; 对象。驱动程序在将其返回数据库之前将其转换为SQL &lt;code&gt;TIME&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="10c24d5b17a0e026c5d7d374aa2559609ace759c" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;java.sql.Timestamp&lt;/code&gt; object in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object.</source>
          <target state="translated">将Java编程语言中的 &lt;code&gt;java.sql.Timestamp&lt;/code&gt; 对象写入此 &lt;code&gt;SQLOutputImpl&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="a591b58703a67375938736a34ac6cdf53113b82d" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;java.sql.Timestamp&lt;/code&gt; object in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object. The driver converts it to an SQL &lt;code&gt;TIMESTAMP&lt;/code&gt; before returning it to the database.</source>
          <target state="translated">将Java编程语言中的 &lt;code&gt;java.sql.Timestamp&lt;/code&gt; 对象写入此 &lt;code&gt;SQLOutputImpl&lt;/code&gt; 对象。驱动程序在将其返回数据库之前将其转换为SQL &lt;code&gt;TIMESTAMP&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a7a6c04ca4913bbb6d71dcdb430bdadb44602d6f" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;long&lt;/code&gt; in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object.</source>
          <target state="translated">用Java编程语言将 &lt;code&gt;long&lt;/code&gt; 写入此 &lt;code&gt;SQLOutputImpl&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="a5e41834abe596a0f73b3cafbac1894059f99cb6" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;long&lt;/code&gt; in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object. The driver converts it to an SQL &lt;code&gt;BIGINT&lt;/code&gt; before returning it to the database.</source>
          <target state="translated">用Java编程语言将 &lt;code&gt;long&lt;/code&gt; 写入此 &lt;code&gt;SQLOutputImpl&lt;/code&gt; 对象。驱动程序在将其返回数据库之前将其转换为SQL &lt;code&gt;BIGINT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8895918fb39b48000205955fa45fde016f0c3d15" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;long&lt;/code&gt; to the file as eight bytes, high byte first.</source>
          <target state="translated">将一个 &lt;code&gt;long&lt;/code&gt; 写入八个字节，高字节在前。</target>
        </trans-unit>
        <trans-unit id="55c528963d4d2b5dc906130b6855614969aa9489" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;long&lt;/code&gt; to the file as eight bytes, high byte first. The write starts at the current position of the file pointer.</source>
          <target state="translated">将一个 &lt;code&gt;long&lt;/code&gt; 写入八个字节，高字节在前。写入从文件指针的当前位置开始。</target>
        </trans-unit>
        <trans-unit id="611eb1e8ef355d7f42537bc6bae8d758ff6c8171" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;long&lt;/code&gt; to the underlying output stream as eight bytes, high byte first.</source>
          <target state="translated">将一个 &lt;code&gt;long&lt;/code&gt; 数据以8个字节的形式写入基础输出流，高字节在前。</target>
        </trans-unit>
        <trans-unit id="bc6accb6c7c3e908a144c301fc776e1a0598feb1" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;long&lt;/code&gt; to the underlying output stream as eight bytes, high byte first. In no exception is thrown, the counter &lt;code&gt;written&lt;/code&gt; is incremented by &lt;code&gt;8&lt;/code&gt;.</source>
          <target state="translated">将一个 &lt;code&gt;long&lt;/code&gt; 数据以八个字节的形式写入基础输出流，高字节在前。不会抛出异常，所 &lt;code&gt;written&lt;/code&gt; 的计数器将增加 &lt;code&gt;8&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6c456969b969a70b0bafd0d849d8758576665b3e" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;long&lt;/code&gt; value, which is comprised of eight bytes, to the output stream.</source>
          <target state="translated">将由八个字节组成的 &lt;code&gt;long&lt;/code&gt; 值写入输出流。</target>
        </trans-unit>
        <trans-unit id="90977f382f90c1a5eef7e30f250984dbbf685fc0" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;long&lt;/code&gt; value, which is comprised of eight bytes, to the output stream. The byte values to be written, in the order shown, are:</source>
          <target state="translated">将由八个字节组成的 &lt;code&gt;long&lt;/code&gt; 值写入输出流。按照所示顺序，要写入的字节值是：</target>
        </trans-unit>
        <trans-unit id="1b73432a8b187a60ddbd8f3ea3cfe32efefece8a" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;short&lt;/code&gt; in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object.</source>
          <target state="translated">将Java编程语言的 &lt;code&gt;short&lt;/code&gt; 写入此 &lt;code&gt;SQLOutputImpl&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="c54483bbc01a1757da60b9e15f662ba88b52cf5f" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;short&lt;/code&gt; in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object. The driver converts it to an SQL &lt;code&gt;SMALLINT&lt;/code&gt; before returning it to the database.</source>
          <target state="translated">将Java编程语言的 &lt;code&gt;short&lt;/code&gt; 写入此 &lt;code&gt;SQLOutputImpl&lt;/code&gt; 对象。驱动程序在将其返回数据库之前将其转换为SQL &lt;code&gt;SMALLINT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="88192947ad3bae1375cd61982af7c10dfe7bf288" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;short&lt;/code&gt; to the file as two bytes, high byte first.</source>
          <target state="translated">将一个 &lt;code&gt;short&lt;/code&gt; 作为两个字节写入文件，高字节在前。</target>
        </trans-unit>
        <trans-unit id="08c5c0b7c3097cdebd2722567ae9d781529b69f1" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;short&lt;/code&gt; to the file as two bytes, high byte first. The write starts at the current position of the file pointer.</source>
          <target state="translated">将一个 &lt;code&gt;short&lt;/code&gt; 作为两个字节写入文件，高字节在前。写入从文件指针的当前位置开始。</target>
        </trans-unit>
        <trans-unit id="95148813e930a56ec7f9ba7cf377c3af425484b9" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;short&lt;/code&gt; to the underlying output stream as two bytes, high byte first.</source>
          <target state="translated">将 &lt;code&gt;short&lt;/code&gt; 作为两个字节写入基础输出流，高字节在前。</target>
        </trans-unit>
        <trans-unit id="02db58dd011e754f2707096b88fe2f8be9f657ed" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;short&lt;/code&gt; to the underlying output stream as two bytes, high byte first. If no exception is thrown, the counter &lt;code&gt;written&lt;/code&gt; is incremented by &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;short&lt;/code&gt; 作为两个字节写入基础输出流，高字节在前。如果未引发异常，则 &lt;code&gt;written&lt;/code&gt; 的计数器将增加 &lt;code&gt;2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a90364be6749249db375cff460e3c17c03c9bbd9" translate="yes" xml:space="preserve">
          <source>Writes a CData section</source>
          <target state="translated">写一个CD数据部分</target>
        </trans-unit>
        <trans-unit id="df3d8a106b37266209385784427f6dc8189f1133" translate="yes" xml:space="preserve">
          <source>Writes a SQL &lt;code&gt;DATALINK&lt;/code&gt; value to the stream.</source>
          <target state="translated">将SQL &lt;code&gt;DATALINK&lt;/code&gt; 值写入流。</target>
        </trans-unit>
        <trans-unit id="b458ebbec899f10fb20f20b8b4375124ea3e7e52" translate="yes" xml:space="preserve">
          <source>Writes a String as a sequence of bytes.</source>
          <target state="translated">将一个字符串写成一个字节序列。</target>
        </trans-unit>
        <trans-unit id="afc7866c1825e9380b11088c400178f95a95cdbc" translate="yes" xml:space="preserve">
          <source>Writes a String as a sequence of chars.</source>
          <target state="translated">将一个字符串写成一个字符串序列。</target>
        </trans-unit>
        <trans-unit id="c2392262bb2e4275d7538e0294036fdf89687e24" translate="yes" xml:space="preserve">
          <source>Writes a boolean.</source>
          <target state="translated">写一个布尔值。</target>
        </trans-unit>
        <trans-unit id="f0dab3f9cfd243fc6ebe7043ee7a66237ab74a99" translate="yes" xml:space="preserve">
          <source>Writes a byte to the compressed output stream.</source>
          <target state="translated">向压缩输出流写入一个字节。</target>
        </trans-unit>
        <trans-unit id="c0da5fee9a3c6b16bf35955f5f5c35dce130ca60" translate="yes" xml:space="preserve">
          <source>Writes a byte to the compressed output stream. This method will block until the byte can be written.</source>
          <target state="translated">向压缩输出流写入一个字节。本方法将被阻塞,直到可以写入字节。</target>
        </trans-unit>
        <trans-unit id="9cf89ed21330c27e5aa3cc0f34d382c423419609" translate="yes" xml:space="preserve">
          <source>Writes a byte to the uncompressed output stream.</source>
          <target state="translated">向未压缩的输出流写入一个字节。</target>
        </trans-unit>
        <trans-unit id="3d47656c06088ca641ef1044e64c889463161b7a" translate="yes" xml:space="preserve">
          <source>Writes a byte.</source>
          <target state="translated">写一个字节。</target>
        </trans-unit>
        <trans-unit id="311374422e4c207200ae10ac5f074fff7eabacab" translate="yes" xml:space="preserve">
          <source>Writes a byte. This method will block until the byte is actually written.</source>
          <target state="translated">写一个字节。本方法会阻塞,直到字节被实际写入。</target>
        </trans-unit>
        <trans-unit id="4f8553b815db13b6c88e3d97f9c0023965b0af9c" translate="yes" xml:space="preserve">
          <source>Writes a byte. Will block until the byte is actually written.</source>
          <target state="translated">写一个字节。在实际写入字节之前会被阻止。</target>
        </trans-unit>
        <trans-unit id="5447f774a2ec3a7588ab7fffc585fd0847e17bfa" translate="yes" xml:space="preserve">
          <source>Writes a character to the buffer.</source>
          <target state="translated">将一个字符写入缓冲区。</target>
        </trans-unit>
        <trans-unit id="e7ba7473a4f82684254953fa98bca6d77362c61b" translate="yes" xml:space="preserve">
          <source>Writes a datagram to this channel.</source>
          <target state="translated">向该通道写入数据报。</target>
        </trans-unit>
        <trans-unit id="5efe0d1f19523d7334f9c488613efaa72bee6fd2" translate="yes" xml:space="preserve">
          <source>Writes a formatted string to this console's output stream using the specified format string and arguments.</source>
          <target state="translated">使用指定的格式字符串和参数将一个格式化的字符串写入这个控制台的输出流。</target>
        </trans-unit>
        <trans-unit id="508af09289f72e03d16ae1e4dd4b7e1a9e501d48" translate="yes" xml:space="preserve">
          <source>Writes a formatted string to this object's destination using the specified format string and arguments.</source>
          <target state="translated">使用指定的格式字符串和参数将一个格式化的字符串写入此对象的目的地。</target>
        </trans-unit>
        <trans-unit id="0a45e7a61a42a1faa620f3d8e59e1e8f0e6e5cc2" translate="yes" xml:space="preserve">
          <source>Writes a formatted string to this object's destination using the specified format string and arguments. The locale used is the one defined during the construction of this formatter.</source>
          <target state="translated">使用指定的格式字符串和参数将格式化的字符串写入此对象的目的地。所使用的locale是在构建此formatter时定义的locale。</target>
        </trans-unit>
        <trans-unit id="b64a4a6ece44814969f921375d7b1535d8bf355a" translate="yes" xml:space="preserve">
          <source>Writes a formatted string to this object's destination using the specified locale, format string, and arguments.</source>
          <target state="translated">使用指定的locale、format string和参数将一个格式化的字符串写入此对象的目的地。</target>
        </trans-unit>
        <trans-unit id="ff42503cbe9f3786576fcf934db44ca1703f1239" translate="yes" xml:space="preserve">
          <source>Writes a formatted string to this output stream using the specified format string and arguments.</source>
          <target state="translated">使用指定的格式字符串和参数将一个格式化的字符串写入这个输出流。</target>
        </trans-unit>
        <trans-unit id="684abf86f0ae0bf9ca4893fa8d75709f881ea701" translate="yes" xml:space="preserve">
          <source>Writes a formatted string to this writer using the specified format string and arguments.</source>
          <target state="translated">使用指定的格式字符串和参数将一个格式化的字符串写入这个写入器。</target>
        </trans-unit>
        <trans-unit id="df82bdd3d3608dc3ca77522fb3a2ccea02508a72" translate="yes" xml:space="preserve">
          <source>Writes a formatted string to this writer using the specified format string and arguments. If automatic flushing is enabled, calls to this method will flush the output buffer.</source>
          <target state="translated">使用指定的格式字符串和参数将一个格式化的字符串写入该写入器。如果启用了自动刷新功能,对该方法的调用将刷新输出缓冲区。</target>
        </trans-unit>
        <trans-unit id="17ff8b03f28f8652982d3549e1d470d8e0fa7304" translate="yes" xml:space="preserve">
          <source>Writes a line separator.</source>
          <target state="translated">写一个分线符。</target>
        </trans-unit>
        <trans-unit id="e2cc625afc6e32e0218832c9bab473756248e92a" translate="yes" xml:space="preserve">
          <source>Writes a line separator. The line separator string is defined by the system property &lt;code&gt;line.separator&lt;/code&gt;, and is not necessarily a single newline ('\n') character.</source>
          <target state="translated">写一个行分隔符。行分隔符字符串由系统属性 &lt;code&gt;line.separator&lt;/code&gt; 定义，不一定是单个换行符（'\ n'）。</target>
        </trans-unit>
        <trans-unit id="27e81462b6e6b65223f5d2486f4dfbf626128a46" translate="yes" xml:space="preserve">
          <source>Writes a namespace to the output stream If the prefix argument to this method is the empty string, &quot;xmlns&quot;, or null this method will delegate to writeDefaultNamespace</source>
          <target state="translated">写一个命名空间到输出流 如果本方法的前缀参数是空字符串 &quot;xmlns &quot;或null,本方法将委托writeDefaultNamespace完成。</target>
        </trans-unit>
        <trans-unit id="3ea473561fce7d15d0a8632a6efe064700e72fc5" translate="yes" xml:space="preserve">
          <source>Writes a packet to the target VM.</source>
          <target state="translated">向目标虚拟机写入一个数据包。</target>
        </trans-unit>
        <trans-unit id="e06d1baf2766748f705a9ec924d45f761ff2e183" translate="yes" xml:space="preserve">
          <source>Writes a portion of a String.</source>
          <target state="translated">写入一个字符串的一部分。</target>
        </trans-unit>
        <trans-unit id="f72fbef395487327da1536d1995e28bc5cf9fb4c" translate="yes" xml:space="preserve">
          <source>Writes a portion of a string.</source>
          <target state="translated">写入字符串的一部分。</target>
        </trans-unit>
        <trans-unit id="56b0793b26c4a0f3cdcde22d46d24b35623bc380" translate="yes" xml:space="preserve">
          <source>Writes a portion of an array of characters.</source>
          <target state="translated">写出一个数组中的部分字符。</target>
        </trans-unit>
        <trans-unit id="07fcbd7544ddeccee9b06f0cd837cd28b8435c95" translate="yes" xml:space="preserve">
          <source>Writes a processing instruction</source>
          <target state="translated">编写处理指令</target>
        </trans-unit>
        <trans-unit id="502ed5705e51254c59ad06919f6929d8c661179e" translate="yes" xml:space="preserve">
          <source>Writes a sequence of bits, given by the &lt;code&gt;numBits&lt;/code&gt; least significant bits of the &lt;code&gt;bits&lt;/code&gt; argument in left-to-right order, to the stream at the current bit offset within the current byte position.</source>
          <target state="translated">将由 &lt;code&gt;bits&lt;/code&gt; 参数的 &lt;code&gt;numBits&lt;/code&gt; 最低有效位以从左到右的顺序给定的一系列位写入当前流中当前字节位置内的当前位偏移量处。</target>
        </trans-unit>
        <trans-unit id="7238cdbf395d0c16e058e39542beedf0196e6462" translate="yes" xml:space="preserve">
          <source>Writes a sequence of bits, given by the &lt;code&gt;numBits&lt;/code&gt; least significant bits of the &lt;code&gt;bits&lt;/code&gt; argument in left-to-right order, to the stream at the current bit offset within the current byte position. The upper &lt;code&gt;64 - numBits&lt;/code&gt; bits of the argument are ignored. The bit offset is advanced by &lt;code&gt;numBits&lt;/code&gt; and reduced modulo 8. Note that a bit offset of 0 always indicates the most-significant bit of the byte, and bytes of bits are written out in sequence as they are encountered. Thus bit writes are always effectively in network byte order. The actual stream byte order setting is ignored.</source>
          <target state="translated">将由 &lt;code&gt;bits&lt;/code&gt; 参数的 &lt;code&gt;numBits&lt;/code&gt; 最低有效位按从左到右的顺序给定的一系列位写入当前字节位置内当前位偏移量的流。参数的高 &lt;code&gt;64 - numBits&lt;/code&gt; 位-numBits位将被忽略。位偏移量增加 &lt;code&gt;numBits&lt;/code&gt; 并减少模8。请注意，位偏移量0始终表示字节的最高有效位，并且在遇到位字节时，它们按顺序写出。因此，位写入总是有效地按网络字节顺序进行。实际的流字节顺序设置将被忽略。</target>
        </trans-unit>
        <trans-unit id="314d6e211d9795052649ceb03da878a72709c282" translate="yes" xml:space="preserve">
          <source>Writes a sequence of bytes to the stream at the current position.</source>
          <target state="translated">在当前位置向流中写入一串字节。</target>
        </trans-unit>
        <trans-unit id="190c55636cfdf74b2ffb6a71ed2f57d50aeccf84" translate="yes" xml:space="preserve">
          <source>Writes a sequence of bytes to the stream at the current position. If &lt;code&gt;b.length&lt;/code&gt; is 0, nothing is written. The byte &lt;code&gt;b[0]&lt;/code&gt; is written first, then the byte &lt;code&gt;b[1]&lt;/code&gt;, and so on.</source>
          <target state="translated">将字节序列写入流中的当前位置。如果 &lt;code&gt;b.length&lt;/code&gt; 为0，则不写入任何内容。首先写入字节 &lt;code&gt;b[0]&lt;/code&gt; ，然后写入字节 &lt;code&gt;b[1]&lt;/code&gt; ，依此类推。</target>
        </trans-unit>
        <trans-unit id="2235f3a78e2b1cb2ccd3a4168c479386e4f14d39" translate="yes" xml:space="preserve">
          <source>Writes a sequence of bytes to the stream at the current position. If &lt;code&gt;len&lt;/code&gt; is 0, nothing is written. The byte &lt;code&gt;b[off]&lt;/code&gt; is written first, then the byte &lt;code&gt;b[off + 1]&lt;/code&gt;, and so on.</source>
          <target state="translated">将字节序列写入流中的当前位置。如果 &lt;code&gt;len&lt;/code&gt; 为0，则不写入任何内容。首先写入字节 &lt;code&gt;b[off]&lt;/code&gt; ，然后写入字节 &lt;code&gt;b[off + 1]&lt;/code&gt; ，依此类推。</target>
        </trans-unit>
        <trans-unit id="998e981037032866593747f4cad33ac3eb0066f8" translate="yes" xml:space="preserve">
          <source>Writes a sequence of bytes to this channel from a subsequence of the given buffers.</source>
          <target state="translated">从给定的缓冲区的子序列中写入一个字节序列到这个通道。</target>
        </trans-unit>
        <trans-unit id="df42d642ba05e494d2cc831543ce9f23be20461b" translate="yes" xml:space="preserve">
          <source>Writes a sequence of bytes to this channel from a subsequence of the given buffers. This operation, sometimes called a &lt;em&gt;gathering write&lt;/em&gt;, is often useful when implementing network protocols that group data into segments consisting of one or more fixed-length headers followed by a variable-length body. The &lt;code&gt;handler&lt;/code&gt; parameter is a completion handler that is invoked when the write operation completes (or fails). The result passed to the completion handler is the number of bytes written.</source>
          <target state="translated">从给定缓冲区的子序列向该通道写入字节序列。在实施将数据分组为由一个或多个固定长度报头和一个可变长度主体组成的段的网络协议时，此操作有时称为&lt;em&gt;收集写入&lt;/em&gt;，通常很有用。该 &lt;code&gt;handler&lt;/code&gt; 参数是完成处理程序，在写操作完成（或失败）时调用。传递给完成处理程序的结果是写入的字节数。</target>
        </trans-unit>
        <trans-unit id="02441dac40077efefece8a0e55188a3959f39c79" translate="yes" xml:space="preserve">
          <source>Writes a sequence of bytes to this channel from the given buffer, starting at the given file position.</source>
          <target state="translated">从给定的缓冲区开始,从给定的文件位置开始,向这个通道写入一串字节。</target>
        </trans-unit>
        <trans-unit id="4b2b6d5918fe10f4267a0ae46ec7f71362fad27f" translate="yes" xml:space="preserve">
          <source>Writes a sequence of bytes to this channel from the given buffer.</source>
          <target state="translated">从给定的缓冲区向这个通道写入一串字节。</target>
        </trans-unit>
        <trans-unit id="41853481b79dd7251b056000a101757ebc59a7f7" translate="yes" xml:space="preserve">
          <source>Writes a sequence of bytes to this channel from the given buffers.</source>
          <target state="translated">从给定的缓冲区向这个通道写入一串字节。</target>
        </trans-unit>
        <trans-unit id="59c5ccb857f9bc25462065a57d0ce514fa8bf281" translate="yes" xml:space="preserve">
          <source>Writes a sequence of chars to the stream at the current position.</source>
          <target state="translated">在当前位置向流中写入一串字符。</target>
        </trans-unit>
        <trans-unit id="25372ececa06540883487ffc569630583f3356c4" translate="yes" xml:space="preserve">
          <source>Writes a sequence of chars to the stream at the current position. If &lt;code&gt;len&lt;/code&gt; is 0, nothing is written. The char &lt;code&gt;c[off]&lt;/code&gt; is written first, then the char &lt;code&gt;c[off + 1]&lt;/code&gt;, and so on. The byte order of the stream is used to determine the order in which the individual bytes are written.</source>
          <target state="translated">将char序列写入当前位置的流中。如果 &lt;code&gt;len&lt;/code&gt; 为0，则不写入任何内容。首先写入char &lt;code&gt;c[off]&lt;/code&gt; ，然后写入char &lt;code&gt;c[off + 1]&lt;/code&gt; ，依此类推。流的字节顺序用于确定写入各个字节的顺序。</target>
        </trans-unit>
        <trans-unit id="7a3d4937205bb517a2764876ca8d0ce3625add0c" translate="yes" xml:space="preserve">
          <source>Writes a sequence of doubles to the stream at the current position.</source>
          <target state="translated">将当前位置的双倍数序列写入流。</target>
        </trans-unit>
        <trans-unit id="b8d73713479b20f3c0e88b9a7d06d7681fdd8c40" translate="yes" xml:space="preserve">
          <source>Writes a sequence of doubles to the stream at the current position. If &lt;code&gt;len&lt;/code&gt; is 0, nothing is written. The double &lt;code&gt;d[off]&lt;/code&gt; is written first, then the double &lt;code&gt;d[off + 1]&lt;/code&gt;, and so on. The byte order of the stream is used to determine the order in which the individual bytes are written.</source>
          <target state="translated">将双打序列写入当前位置的流中。如果 &lt;code&gt;len&lt;/code&gt; 为0，则不写入任何内容。首先写入double &lt;code&gt;d[off]&lt;/code&gt; ，然后写入double &lt;code&gt;d[off + 1]&lt;/code&gt; ，依此类推。流的字节顺序用于确定写入各个字节的顺序。</target>
        </trans-unit>
        <trans-unit id="446789ef076930615fe1f5c41aac52f13cc1cee0" translate="yes" xml:space="preserve">
          <source>Writes a sequence of floats to the stream at the current position.</source>
          <target state="translated">将当前位置的浮动序列写入流中。</target>
        </trans-unit>
        <trans-unit id="ee5692e375b6806782e1c51563426dd418bee68f" translate="yes" xml:space="preserve">
          <source>Writes a sequence of floats to the stream at the current position. If &lt;code&gt;len&lt;/code&gt; is 0, nothing is written. The float &lt;code&gt;f[off]&lt;/code&gt; is written first, then the float &lt;code&gt;f[off + 1]&lt;/code&gt;, and so on. The byte order of the stream is used to determine the order in which the individual bytes are written.</source>
          <target state="translated">将浮点序列写入当前位置的流中。如果 &lt;code&gt;len&lt;/code&gt; 为0，则不写入任何内容。首先写浮点数 &lt;code&gt;f[off]&lt;/code&gt; ，然后写浮点数 &lt;code&gt;f[off + 1]&lt;/code&gt; ，依此类推。流的字节顺序用于确定写入各个字节的顺序。</target>
        </trans-unit>
        <trans-unit id="de705ba6a174586a9c837cd917c5bd44f25429f8" translate="yes" xml:space="preserve">
          <source>Writes a sequence of ints to the stream at the current position.</source>
          <target state="translated">在当前位置向流中写入一个ints序列。</target>
        </trans-unit>
        <trans-unit id="2e22e143b7aa537e10aa473bc7180b02b29a9e27" translate="yes" xml:space="preserve">
          <source>Writes a sequence of ints to the stream at the current position. If &lt;code&gt;len&lt;/code&gt; is 0, nothing is written. The int &lt;code&gt;i[off]&lt;/code&gt; is written first, then the int &lt;code&gt;i[off + 1]&lt;/code&gt;, and so on. The byte order of the stream is used to determine the order in which the individual bytes are written.</source>
          <target state="translated">将int序列写入当前位置的流中。如果 &lt;code&gt;len&lt;/code&gt; 为0，则不写入任何内容。首先写入int &lt;code&gt;i[off]&lt;/code&gt; ，然后再写入int &lt;code&gt;i[off + 1]&lt;/code&gt; ，依此类推。流的字节顺序用于确定写入各个字节的顺序。</target>
        </trans-unit>
        <trans-unit id="69c5aaa383ce6ea26910c68605710771e3d57380" translate="yes" xml:space="preserve">
          <source>Writes a sequence of longs to the stream at the current position.</source>
          <target state="translated">在当前位置向流中写入一串长字符串。</target>
        </trans-unit>
        <trans-unit id="8f619dc03c935ddbc5713f176006c9051deaeab8" translate="yes" xml:space="preserve">
          <source>Writes a sequence of longs to the stream at the current position. If &lt;code&gt;len&lt;/code&gt; is 0, nothing is written. The long &lt;code&gt;l[off]&lt;/code&gt; is written first, then the long &lt;code&gt;l[off + 1]&lt;/code&gt;, and so on. The byte order of the stream is used to determine the order in which the individual bytes are written.</source>
          <target state="translated">将long序列写入当前位置的流中。如果 &lt;code&gt;len&lt;/code&gt; 为0，则不写入任何内容。先写入长 &lt;code&gt;l[off]&lt;/code&gt; ，然后再写入长 &lt;code&gt;l[off + 1]&lt;/code&gt; ，依此类推。流的字节顺序用于确定写入各个字节的顺序。</target>
        </trans-unit>
        <trans-unit id="4e2827725195f2c36013b35ab2dccbe6663b69f6" translate="yes" xml:space="preserve">
          <source>Writes a sequence of shorts to the stream at the current position.</source>
          <target state="translated">在当前位置向流中写入一连串的空头。</target>
        </trans-unit>
        <trans-unit id="b21ca2f4d5f95b31acfd2f5bbc0ce005cc3a5fb6" translate="yes" xml:space="preserve">
          <source>Writes a sequence of shorts to the stream at the current position. If &lt;code&gt;len&lt;/code&gt; is 0, nothing is written. The short &lt;code&gt;s[off]&lt;/code&gt; is written first, then the short &lt;code&gt;s[off + 1]&lt;/code&gt;, and so on. The byte order of the stream is used to determine the order in which the individual bytes are written.</source>
          <target state="translated">将短裤序列写入当前位置的流中。如果 &lt;code&gt;len&lt;/code&gt; 为0，则不写入任何内容。首先写入short &lt;code&gt;s[off]&lt;/code&gt; ，然后写入short &lt;code&gt;s[off + 1]&lt;/code&gt; ，依此类推。流的字节顺序用于确定写入各个字节的顺序。</target>
        </trans-unit>
        <trans-unit id="9e25011a9c8fdafeb10663081e9d168f9a6cefb9" translate="yes" xml:space="preserve">
          <source>Writes a set of attributes to the given object stream for the purpose of serialization.</source>
          <target state="translated">将一组属性写入给定的对象流,以实现序列化。</target>
        </trans-unit>
        <trans-unit id="9b3b3b853ce10c9f53ce13bee2be516282c111c7" translate="yes" xml:space="preserve">
          <source>Writes a set of attributes to the given object stream for the purpose of serialization. This will take special care to deal with static attribute keys that have been registered wit the &lt;code&gt;registerStaticAttributeKey&lt;/code&gt; method. Any attribute key not registered as a static key will be serialized directly. All values are expected to be serializable.</source>
          <target state="translated">将一组属性写入给定的对象流以进行序列化。这将特别注意处理已通过 &lt;code&gt;registerStaticAttributeKey&lt;/code&gt; 方法注册的静态属性密钥。任何未注册为静态键的属性键都将直接序列化。所有值均应可序列化。</target>
        </trans-unit>
        <trans-unit id="e3cbf0c42aabe7ea4836e02acdffa16497650e0c" translate="yes" xml:space="preserve">
          <source>Writes a single bit, given by the least significant bit of the argument, to the stream at the current bit offset within the current byte position.</source>
          <target state="translated">在当前字节位置的当前位偏移处,将参数的最小有效位写入流。</target>
        </trans-unit>
        <trans-unit id="7b943c58e32fcea952a5a176b2b64b74481ec8ac" translate="yes" xml:space="preserve">
          <source>Writes a single bit, given by the least significant bit of the argument, to the stream at the current bit offset within the current byte position. The upper 31 bits of the argument are ignored. The given bit replaces the previous bit at that position. The bit offset is advanced by one and reduced modulo 8.</source>
          <target state="translated">在当前字节位置的当前位偏移量处,将参数中的最小有效位写入流。参数的上31位被忽略。给定的位将取代该位置的前一个位。位偏移量前进1,并以8为模数减少。</target>
        </trans-unit>
        <trans-unit id="001052a859bb1446c0fd19a7d0140fd8e78c87da" translate="yes" xml:space="preserve">
          <source>Writes a single byte to the stream at the current position.</source>
          <target state="translated">在当前位置向流中写入一个字节。</target>
        </trans-unit>
        <trans-unit id="4d25d450c91f1b954e5d3226b5eb0d63eb9f3de1" translate="yes" xml:space="preserve">
          <source>Writes a single byte to the stream at the current position. The 24 high-order bits of &lt;code&gt;b&lt;/code&gt; are ignored.</source>
          <target state="translated">将单个字节写入流中的当前位置。 &lt;code&gt;b&lt;/code&gt; 的24个高阶位被忽略。</target>
        </trans-unit>
        <trans-unit id="664dba2ff2df999d8a27b0049a85c61d9db7e29f" translate="yes" xml:space="preserve">
          <source>Writes a single character.</source>
          <target state="translated">写的是一个字。</target>
        </trans-unit>
        <trans-unit id="f933296edffab5638d15f828802522dc84897cf3" translate="yes" xml:space="preserve">
          <source>Writes a single character. The character to be written is contained in the 16 low-order bits of the given integer value; the 16 high-order bits are ignored.</source>
          <target state="translated">写入一个字符。要写的字符包含在给定整数值的16个低阶位中;16个高阶位被忽略。</target>
        </trans-unit>
        <trans-unit id="358e1ae6ec30a51046bb824cdc45a4602b363152" translate="yes" xml:space="preserve">
          <source>Writes a start tag to the output</source>
          <target state="translated">将起始标签写入输出</target>
        </trans-unit>
        <trans-unit id="49bd4c043b641203f67a25a8faaedf06ff7164e9" translate="yes" xml:space="preserve">
          <source>Writes a start tag to the output.</source>
          <target state="translated">将起始标签写入输出。</target>
        </trans-unit>
        <trans-unit id="75052e90a50a88eddb0c2fcd32eec44274289114" translate="yes" xml:space="preserve">
          <source>Writes a start tag to the output. All writeStartElement methods open a new scope in the internal namespace context. Writing the corresponding EndElement causes the scope to be closed.</source>
          <target state="translated">将起始标记写入输出。所有writeStartElement方法都会在内部命名空间上下文中打开一个新的作用域。写入相应的 EndElement 会导致作用域被关闭。</target>
        </trans-unit>
        <trans-unit id="8e408c44ea4aa78ea372d668a61e9a79e9878cfa" translate="yes" xml:space="preserve">
          <source>Writes a stream of ASCII characters to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object.</source>
          <target state="translated">将ASCII字符流写入此 &lt;code&gt;SQLOutputImpl&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="0c35566fb936fe3c434bc325013cef4ac2fd2d64" translate="yes" xml:space="preserve">
          <source>Writes a stream of ASCII characters to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object. The driver will do any necessary conversion from ASCII to the database &lt;code&gt;CHAR&lt;/code&gt; format.</source>
          <target state="translated">将ASCII字符流写入此 &lt;code&gt;SQLOutputImpl&lt;/code&gt; 对象。驱动程序将进行任何必要的从ASCII到数据库 &lt;code&gt;CHAR&lt;/code&gt; 格式的转换。</target>
        </trans-unit>
        <trans-unit id="a8d35bd84279b6609e622d6ab06f4beb72906404" translate="yes" xml:space="preserve">
          <source>Writes a stream of Unicode characters to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object.</source>
          <target state="translated">将Unicode字符流写入此 &lt;code&gt;SQLOutputImpl&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="103c70c642901a5a9a51a3605fe74dc57e1fabd2" translate="yes" xml:space="preserve">
          <source>Writes a stream of Unicode characters to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object. The driver will do any necessary conversion from Unicode to the database &lt;code&gt;CHAR&lt;/code&gt; format.</source>
          <target state="translated">将Unicode字符流写入此 &lt;code&gt;SQLOutputImpl&lt;/code&gt; 对象。驱动程序将执行从Unicode到数据库 &lt;code&gt;CHAR&lt;/code&gt; 格式的所有必要转换。</target>
        </trans-unit>
        <trans-unit id="df213335179c5ed8ca6afe71e0677d7424da6195" translate="yes" xml:space="preserve">
          <source>Writes a stream of bytes representing a MIDI file of the file type indicated to the external file provided.</source>
          <target state="translated">将代表文件类型的MIDI文件的字节流写入所提供的外部文件。</target>
        </trans-unit>
        <trans-unit id="e8a5f176816806a6fbca88570a3f6372ece24192" translate="yes" xml:space="preserve">
          <source>Writes a stream of bytes representing a MIDI file of the file type indicated to the output stream provided.</source>
          <target state="translated">将代表文件类型的MIDI文件的字节流写入提供的输出流中。</target>
        </trans-unit>
        <trans-unit id="d0e751b02c4917e9384d9893ee2785bf31c7eb4d" translate="yes" xml:space="preserve">
          <source>Writes a stream of bytes representing a file of the MIDI file type indicated to the external file provided.</source>
          <target state="translated">将代表MIDI文件类型的字节流写入所提供的外部文件。</target>
        </trans-unit>
        <trans-unit id="68b7db83aee7a60d72e213514b372c08156d7b87" translate="yes" xml:space="preserve">
          <source>Writes a stream of bytes representing a file of the MIDI file type indicated to the output stream provided.</source>
          <target state="translated">将代表MIDI文件类型的字节流写入所提供的输出流中。</target>
        </trans-unit>
        <trans-unit id="9036acda052c4911938040861a1e300f1ef2410e" translate="yes" xml:space="preserve">
          <source>Writes a stream of bytes representing an audio file of the file format indicated to the external file provided.</source>
          <target state="translated">将代表文件格式的音频文件的字节流写入所提供的外部文件。</target>
        </trans-unit>
        <trans-unit id="6fb88014c7ccd9861b8e71915804360144829a00" translate="yes" xml:space="preserve">
          <source>Writes a stream of bytes representing an audio file of the file type indicated to the output stream provided.</source>
          <target state="translated">将代表文件类型的音频文件的字节流写入提供的输出流。</target>
        </trans-unit>
        <trans-unit id="9ddecea0d160b45426ce4e501d8df92507ba73a8" translate="yes" xml:space="preserve">
          <source>Writes a stream of bytes representing an audio file of the file type indicated to the output stream provided. Some file types require that the length be written into the file header, and cannot be written from start to finish unless the length is known in advance. An attempt to write such a file type will fail with an &lt;code&gt;IOException&lt;/code&gt; if the length in the audio file format is &lt;a href=&quot;../audiosystem#NOT_SPECIFIED&quot;&gt;&lt;code&gt;AudioSystem.NOT_SPECIFIED&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">将表示音频文件的字节流写入提供的输出流，该音频文件具有指示的文件类型。某些文件类型要求将长度写到文件头中，除非事先知道长度，否则不能从头到尾写。如果音频文件格式的长度为&lt;a href=&quot;../audiosystem#NOT_SPECIFIED&quot;&gt; &lt;code&gt;AudioSystem.NOT_SPECIFIED&lt;/code&gt; &lt;/a&gt;，则尝试写入此类文件的尝试将失败，并出现 &lt;code&gt;IOException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b61ebe87fae82a3f3e78f56158a3a4c202901a7e" translate="yes" xml:space="preserve">
          <source>Writes a stream of bytes representing an audio file of the file type indicated to the output stream provided. Some file types require that the length be written into the file header, and cannot be written from start to finish unless the length is known in advance. An attempt to write such a file type will fail with an IOException if the length in the audio file format is &lt;a href=&quot;../audiosystem#NOT_SPECIFIED&quot;&gt;&lt;code&gt;AudioSystem.NOT_SPECIFIED&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">将表示音频文件的字节流写入提供的输出流，该音频文件具有指示的文件类型。某些文件类型要求将长度写到文件头中，除非事先知道长度，否则不能从头到尾写。如果音频文件格式的长度为&lt;a href=&quot;../audiosystem#NOT_SPECIFIED&quot;&gt; &lt;code&gt;AudioSystem.NOT_SPECIFIED&lt;/code&gt; &lt;/a&gt;，则尝试写入此类文件的尝试将失败，并出现IOException 。</target>
        </trans-unit>
        <trans-unit id="c8f0adc20f1af94af22a8e4d67c6778209fd2469" translate="yes" xml:space="preserve">
          <source>Writes a stream of bytes representing an audio file of the specified file type to the external file provided.</source>
          <target state="translated">将代表指定文件类型的音频文件的字节流写入提供的外部文件。</target>
        </trans-unit>
        <trans-unit id="5347af5a0d11f28a81ca89b06b58fba3a2384a75" translate="yes" xml:space="preserve">
          <source>Writes a stream of bytes representing an audio file of the specified file type to the output stream provided.</source>
          <target state="translated">将代表指定文件类型的音频文件的字节流写入提供的输出流。</target>
        </trans-unit>
        <trans-unit id="6c3e579ee5254986120d6bd885e12ecea3e2510c" translate="yes" xml:space="preserve">
          <source>Writes a stream of bytes representing an audio file of the specified file type to the output stream provided. Some file types require that the length be written into the file header; such files cannot be written from start to finish unless the length is known in advance. An attempt to write a file of such a type will fail with an &lt;code&gt;IOException&lt;/code&gt; if the length in the audio file type is &lt;code&gt;AudioSystem.NOT_SPECIFIED&lt;/code&gt;.</source>
          <target state="translated">将表示指定文件类型的音频文件的字节流写入提供的输出流。某些文件类型要求将长度写到文件头中。除非事先知道长度，否则无法从头到尾写入此类文件。如果音频文件类型的长度为 &lt;code&gt;AudioSystem.NOT_SPECIFIED&lt;/code&gt; ，则尝试写入此类文件将失败，并出现 &lt;code&gt;IOException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="457626ec7057ea1509e697c0d5f9754010afd06b" translate="yes" xml:space="preserve">
          <source>Writes a stream of bytes representing an audio file of the specified file type to the output stream provided. Some file types require that the length be written into the file header; such files cannot be written from start to finish unless the length is known in advance. An attempt to write a file of such a type will fail with an IOException if the length in the audio file type is &lt;code&gt;AudioSystem.NOT_SPECIFIED&lt;/code&gt;.</source>
          <target state="translated">将表示指定文件类型的音频文件的字节流写入提供的输出流。某些文件类型要求将长度写到文件头中。除非事先知道长度，否则无法从头到尾写入此类文件。如果音频文件类型的长度为 &lt;code&gt;AudioSystem.NOT_SPECIFIED&lt;/code&gt; ，则尝试写入此类文件将失败，并出现IOException 。</target>
        </trans-unit>
        <trans-unit id="d764e9d1a1cb8b672089bc62810766169a891d6b" translate="yes" xml:space="preserve">
          <source>Writes a stream of uninterpreted bytes to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object.</source>
          <target state="translated">将未解释的字节流写入此 &lt;code&gt;SQLOutputImpl&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="0603b3d486c3582197330dfc0883ac877fa7af38" translate="yes" xml:space="preserve">
          <source>Writes a string to the file as a sequence of characters.</source>
          <target state="translated">将一个字符串作为字符序列写入文件。</target>
        </trans-unit>
        <trans-unit id="cbfebbe442291a3e8e465b80272932906f7ed4fb" translate="yes" xml:space="preserve">
          <source>Writes a string to the file as a sequence of characters. Each character is written to the data output stream as if by the &lt;code&gt;writeChar&lt;/code&gt; method. The write starts at the current position of the file pointer.</source>
          <target state="translated">将字符串作为字符序列写入文件。每个字符就像通过 &lt;code&gt;writeChar&lt;/code&gt; 方法写入数据输出流。写入从文件指针的当前位置开始。</target>
        </trans-unit>
        <trans-unit id="b63ac37afa3c7e30a7ec3f4bba3342bb93883711" translate="yes" xml:space="preserve">
          <source>Writes a string to the file using &lt;a href=&quot;datainput#modified-utf-8&quot;&gt;modified UTF-8&lt;/a&gt; encoding in a machine-independent manner.</source>
          <target state="translated">使用&lt;a href=&quot;datainput#modified-utf-8&quot;&gt;修改后的UTF-8&lt;/a&gt;编码以独立于机器的方式将字符串写入文件。</target>
        </trans-unit>
        <trans-unit id="b0ca487aa3c16ea83ab86aed17493dcc33edb03f" translate="yes" xml:space="preserve">
          <source>Writes a string to the output stream.</source>
          <target state="translated">将一个字符串写入输出流。</target>
        </trans-unit>
        <trans-unit id="2d6f810066617d11d6cb068e9ebc2b6257515d4f" translate="yes" xml:space="preserve">
          <source>Writes a string to the output stream. For every character in the string &lt;code&gt;s&lt;/code&gt;, taken in order, one byte is written to the output stream. If &lt;code&gt;s&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, a &lt;code&gt;NullPointerException&lt;/code&gt; is thrown.</source>
          <target state="translated">将字符串写入输出流。对于字符串 &lt;code&gt;s&lt;/code&gt; 中的每个字符，按顺序将一个字节写入输出流。如果 &lt;code&gt;s&lt;/code&gt; 为 &lt;code&gt;null&lt;/code&gt; ，则抛出 &lt;code&gt;NullPointerException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bc2a7fd94389452a3c96d490dbd418c7fc0f9085" translate="yes" xml:space="preserve">
          <source>Writes a string to the output stream. For every character in the string &lt;code&gt;s&lt;/code&gt;, taken in order, two bytes are written to the output stream, ordered according to the current byte order setting. If network byte order is being used, the high-order byte is written first; the order is reversed otherwise. If &lt;code&gt;s&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, a &lt;code&gt;NullPointerException&lt;/code&gt; is thrown.</source>
          <target state="translated">将字符串写入输出流。对于按顺序获取的字符串 &lt;code&gt;s&lt;/code&gt; 中的每个字符，将根据当前字节顺序设置将两个字节写入输出流。如果使用网络字节顺序，则先写入高位字节；否则使用高位字节。否则顺序相反。如果 &lt;code&gt;s&lt;/code&gt; 为 &lt;code&gt;null&lt;/code&gt; ，则抛出 &lt;code&gt;NullPointerException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0718eb4fd31a016094bf9fb2c14b92e5e34e810c" translate="yes" xml:space="preserve">
          <source>Writes a string to the underlying output stream as a sequence of characters.</source>
          <target state="translated">将一个字符串作为字符序列写入底层输出流。</target>
        </trans-unit>
        <trans-unit id="ea2333de6bb14f6753c8467ddb361808ddce3a17" translate="yes" xml:space="preserve">
          <source>Writes a string to the underlying output stream as a sequence of characters. Each character is written to the data output stream as if by the &lt;code&gt;writeChar&lt;/code&gt; method. If no exception is thrown, the counter &lt;code&gt;written&lt;/code&gt; is incremented by twice the length of &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">将字符串作为字符序列写入底层输出流。每个字符就像通过 &lt;code&gt;writeChar&lt;/code&gt; 方法写入数据输出流。如果未引发异常，则 &lt;code&gt;written&lt;/code&gt; 的计数器将增加 &lt;code&gt;s&lt;/code&gt; 长度的两倍。</target>
        </trans-unit>
        <trans-unit id="d1f60a0c985ee3c99884db52d5d00830332832d9" translate="yes" xml:space="preserve">
          <source>Writes a string to the underlying output stream using &lt;a href=&quot;datainput#modified-utf-8&quot;&gt;modified UTF-8&lt;/a&gt; encoding in a machine-independent manner.</source>
          <target state="translated">使用&lt;a href=&quot;datainput#modified-utf-8&quot;&gt;修改后的UTF-8&lt;/a&gt;编码以独立于机器的方式将字符串写入基础输出流。</target>
        </trans-unit>
        <trans-unit id="11a73af4769d2fa84714761c91018f9161b700b9" translate="yes" xml:space="preserve">
          <source>Writes a string.</source>
          <target state="translated">写一个字符串。</target>
        </trans-unit>
        <trans-unit id="5a1953b8b9d27d19a7b5afed0358700c0f0015e7" translate="yes" xml:space="preserve">
          <source>Writes a string. This method cannot be inherited from the Writer class because it must suppress I/O exceptions.</source>
          <target state="translated">写一个字符串。这个方法不能从Writer类继承,因为它必须抑制I/O异常。</target>
        </trans-unit>
        <trans-unit id="eb6ba0073288a7f37d493353625aab60dc1fed80" translate="yes" xml:space="preserve">
          <source>Writes a sub array of bytes.</source>
          <target state="translated">写一个子数组的字节。</target>
        </trans-unit>
        <trans-unit id="f22826c17e01b8bd59b4c5796200d64c603fcf1a" translate="yes" xml:space="preserve">
          <source>Writes all bytes from the specified byte array to this stream.</source>
          <target state="translated">将指定字节数组中的所有字节写入这个流。</target>
        </trans-unit>
        <trans-unit id="8803c2d78bed399e9ad588006376c473344e3347" translate="yes" xml:space="preserve">
          <source>Writes all bytes from the specified byte array to this stream. If automatic flushing is enabled then the &lt;code&gt;flush&lt;/code&gt; method will be invoked.</source>
          <target state="translated">将指定字节数组中的所有字节写入此流。如果启用了自动刷新，则将调用 &lt;code&gt;flush&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="a0df9dc457ff568fd4c4f2c296551eeed0d5de99" translate="yes" xml:space="preserve">
          <source>Writes all or part of the given &lt;code&gt;byte&lt;/code&gt; array to the &lt;code&gt;BLOB&lt;/code&gt; value that this &lt;code&gt;Blob&lt;/code&gt; object represents and returns the number of bytes written.</source>
          <target state="translated">将给定 &lt;code&gt;byte&lt;/code&gt; 数组的全部或部分写入此 &lt;code&gt;Blob&lt;/code&gt; 对象表示的 &lt;code&gt;BLOB&lt;/code&gt; 值，并返回写入的字节数。</target>
        </trans-unit>
        <trans-unit id="e3916c44b0f32a0be157b07e40b36b95460d2286" translate="yes" xml:space="preserve">
          <source>Writes all or part of the given &lt;code&gt;byte&lt;/code&gt; array to the &lt;code&gt;BLOB&lt;/code&gt; value that this &lt;code&gt;Blob&lt;/code&gt; object represents and returns the number of bytes written. Writing starts at position &lt;code&gt;pos&lt;/code&gt; in the &lt;code&gt;BLOB&lt;/code&gt; value;</source>
          <target state="translated">将给定 &lt;code&gt;byte&lt;/code&gt; 数组的全部或部分写入此 &lt;code&gt;Blob&lt;/code&gt; 对象表示的 &lt;code&gt;BLOB&lt;/code&gt; 值，并返回写入的字节数。写入从 &lt;code&gt;BLOB&lt;/code&gt; 值中的位置 &lt;code&gt;pos&lt;/code&gt; 开始；</target>
        </trans-unit>
        <trans-unit id="9ba3884f1c2a43aa01130052e714b962961fe375" translate="yes" xml:space="preserve">
          <source>Writes all or part of the given &lt;code&gt;byte&lt;/code&gt; array to the &lt;code&gt;BLOB&lt;/code&gt; value that this &lt;code&gt;Blob&lt;/code&gt; object represents and returns the number of bytes written. Writing starts at position &lt;code&gt;pos&lt;/code&gt; in the &lt;code&gt;BLOB&lt;/code&gt; value; &lt;code&gt;len&lt;/code&gt; bytes from the given byte array are written. The array of bytes will overwrite the existing bytes in the &lt;code&gt;Blob&lt;/code&gt; object starting at the position &lt;code&gt;pos&lt;/code&gt;. If the end of the &lt;code&gt;Blob&lt;/code&gt; value is reached while writing the array of bytes, then the length of the &lt;code&gt;Blob&lt;/code&gt; value will be increased to accommodate the extra bytes.</source>
          <target state="translated">将给定 &lt;code&gt;byte&lt;/code&gt; 数组的全部或部分写入此 &lt;code&gt;Blob&lt;/code&gt; 对象表示的 &lt;code&gt;BLOB&lt;/code&gt; 值，并返回写入的字节数。写入从 &lt;code&gt;BLOB&lt;/code&gt; 值中的位置 &lt;code&gt;pos&lt;/code&gt; 开始；写入给定字节数组中的 &lt;code&gt;len&lt;/code&gt; 个字节。字节数组将覆盖 &lt;code&gt;Blob&lt;/code&gt; 对象中从位置 &lt;code&gt;pos&lt;/code&gt; 开始的现有字节。如果的端 &lt;code&gt;Blob&lt;/code&gt; 而写入的字节的阵列达到值，则长度 &lt;code&gt;Blob&lt;/code&gt; 值将增加以容纳额外的字节。</target>
        </trans-unit>
        <trans-unit id="8600843172fc5ab2a734a9e588ad884c7079c4af" translate="yes" xml:space="preserve">
          <source>Writes an &quot;unshared&quot; object to the ObjectOutputStream.</source>
          <target state="translated">将一个 &quot;未共享的 &quot;对象写入ObjectOutputStream。</target>
        </trans-unit>
        <trans-unit id="3f4a23d3b350bf5bfadf2b639abb0bdae3bb550b" translate="yes" xml:space="preserve">
          <source>Writes an &quot;unshared&quot; object to the ObjectOutputStream. This method is identical to writeObject, except that it always writes the given object as a new, unique object in the stream (as opposed to a back-reference pointing to a previously serialized instance). Specifically:</source>
          <target state="translated">将一个 &quot;非共享 &quot;对象写入ObjectOutputStream。这个方法与writeObject相同,只是它总是将给定的对象作为一个新的、唯一的对象写入流中(而不是指向先前序列化实例的反向引用)。具体来说。</target>
        </trans-unit>
        <trans-unit id="1740f6f71c4cd03887821da91243ca075fe07b7b" translate="yes" xml:space="preserve">
          <source>Writes an 8 bit byte.</source>
          <target state="translated">写一个8位字节。</target>
        </trans-unit>
        <trans-unit id="6c180c959eabf9437bdf6b923f53cbff4e46e305" translate="yes" xml:space="preserve">
          <source>Writes an &lt;code&gt;Array&lt;/code&gt; object in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object.</source>
          <target state="translated">用Java编程语言将 &lt;code&gt;Array&lt;/code&gt; 对象写入此 &lt;code&gt;SQLOutputImpl&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="25811b29146a7e96216cf995ac952bf827c6c7d1" translate="yes" xml:space="preserve">
          <source>Writes an &lt;code&gt;Array&lt;/code&gt; object in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object. The driver converts this value to a serializable &lt;code&gt;SerialArray&lt;/code&gt; SQL &lt;code&gt;ARRAY&lt;/code&gt; value before returning it to the database.</source>
          <target state="translated">用Java编程语言将 &lt;code&gt;Array&lt;/code&gt; 对象写入此 &lt;code&gt;SQLOutputImpl&lt;/code&gt; 对象。驱动程序将此值转换为可序列化的 &lt;code&gt;SerialArray&lt;/code&gt; SQL &lt;code&gt;ARRAY&lt;/code&gt; 值，然后再将其返回数据库。</target>
        </trans-unit>
        <trans-unit id="63e4a51e27dbbb2d1fa9e791eaa83fc6e7d81bc8" translate="yes" xml:space="preserve">
          <source>Writes an &lt;code&gt;int&lt;/code&gt; in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object.</source>
          <target state="translated">用Java编程语言将 &lt;code&gt;int&lt;/code&gt; 写入此 &lt;code&gt;SQLOutputImpl&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="672c9a7f2d0d068e3cb4e8d6a9ddf3485c9df6a4" translate="yes" xml:space="preserve">
          <source>Writes an &lt;code&gt;int&lt;/code&gt; in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object. The driver converts it to an SQL &lt;code&gt;INTEGER&lt;/code&gt; before returning it to the database.</source>
          <target state="translated">用Java编程语言将 &lt;code&gt;int&lt;/code&gt; 写入此 &lt;code&gt;SQLOutputImpl&lt;/code&gt; 对象。驱动程序在将其返回数据库之前将其转换为SQL &lt;code&gt;INTEGER&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a3bfe788ce31762630ef5185bd75a500a0052987" translate="yes" xml:space="preserve">
          <source>Writes an &lt;code&gt;int&lt;/code&gt; to the file as four bytes, high byte first.</source>
          <target state="translated">将 &lt;code&gt;int&lt;/code&gt; 作为四个字节写入文件，高字节在前。</target>
        </trans-unit>
        <trans-unit id="1e21e726eeab5953cd125b7495eec89ed335d609" translate="yes" xml:space="preserve">
          <source>Writes an &lt;code&gt;int&lt;/code&gt; to the file as four bytes, high byte first. The write starts at the current position of the file pointer.</source>
          <target state="translated">将 &lt;code&gt;int&lt;/code&gt; 作为四个字节写入文件，高字节在前。写入从文件指针的当前位置开始。</target>
        </trans-unit>
        <trans-unit id="f4a4ba08cd12771cf8e041f1c2a9ab0bc67ead61" translate="yes" xml:space="preserve">
          <source>Writes an &lt;code&gt;int&lt;/code&gt; to the underlying output stream as four bytes, high byte first.</source>
          <target state="translated">将 &lt;code&gt;int&lt;/code&gt; 作为四个字节（高字节在前）写入基础输出流。</target>
        </trans-unit>
        <trans-unit id="9fc8ec8c439b095c865cb112354e78c579eab601" translate="yes" xml:space="preserve">
          <source>Writes an &lt;code&gt;int&lt;/code&gt; to the underlying output stream as four bytes, high byte first. If no exception is thrown, the counter &lt;code&gt;written&lt;/code&gt; is incremented by &lt;code&gt;4&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;int&lt;/code&gt; 作为四个字节（高字节在前）写入基础输出流。如果未引发异常，则 &lt;code&gt;written&lt;/code&gt; 的计数器将增加 &lt;code&gt;4&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="21fd77840911adcb012148e0dd277d71fbc9f872" translate="yes" xml:space="preserve">
          <source>Writes an &lt;code&gt;int&lt;/code&gt; value, which is comprised of four bytes, to the output stream.</source>
          <target state="translated">将一个包含四个字节的 &lt;code&gt;int&lt;/code&gt; 值写入输出流。</target>
        </trans-unit>
        <trans-unit id="e04bb9fdd6e28e1e95affa5629a2ce9b0aeb2c1d" translate="yes" xml:space="preserve">
          <source>Writes an &lt;code&gt;int&lt;/code&gt; value, which is comprised of four bytes, to the output stream. The byte values to be written, in the order shown, are:</source>
          <target state="translated">将一个包含四个字节的 &lt;code&gt;int&lt;/code&gt; 值写入输出流。按照所示顺序，要写入的字节值是：</target>
        </trans-unit>
        <trans-unit id="6564ff5174255cf0e7122d7fc5cb299aea6bc492" translate="yes" xml:space="preserve">
          <source>Writes an &lt;code&gt;java.sql.Type.DATALINK&lt;/code&gt; object in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object.</source>
          <target state="translated">将Java编程语言中的 &lt;code&gt;java.sql.Type.DATALINK&lt;/code&gt; 对象写入此 &lt;code&gt;SQLOutputImpl&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="6f372b9f15bffd1cd7326fb3b4792b5cc954e159" translate="yes" xml:space="preserve">
          <source>Writes an &lt;code&gt;java.sql.Type.DATALINK&lt;/code&gt; object in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object. The driver converts this value to a serializable &lt;code&gt;SerialDatalink&lt;/code&gt; SQL &lt;code&gt;DATALINK&lt;/code&gt; value before return it to the database.</source>
          <target state="translated">将Java编程语言中的 &lt;code&gt;java.sql.Type.DATALINK&lt;/code&gt; 对象写入此 &lt;code&gt;SQLOutputImpl&lt;/code&gt; 对象。驱动程序将此值转换为可序列化的 &lt;code&gt;SerialDatalink&lt;/code&gt; SQL &lt;code&gt;DATALINK&lt;/code&gt; 值，然后再将其返回数据库。</target>
        </trans-unit>
        <trans-unit id="5e8354c8cfe9f0d9932569289c2573c78614272a" translate="yes" xml:space="preserve">
          <source>Writes an SQL &lt;code&gt;ARRAY&lt;/code&gt; value to the stream.</source>
          <target state="translated">将SQL &lt;code&gt;ARRAY&lt;/code&gt; 值写入流。</target>
        </trans-unit>
        <trans-unit id="2b88fbfeb3285de8f20dc32999b639f985e8827e" translate="yes" xml:space="preserve">
          <source>Writes an SQL &lt;code&gt;BLOB&lt;/code&gt; value to the stream.</source>
          <target state="translated">将SQL &lt;code&gt;BLOB&lt;/code&gt; 值写入流中。</target>
        </trans-unit>
        <trans-unit id="e5cc9a2762874135cdf783e5ef59bd592db783ab" translate="yes" xml:space="preserve">
          <source>Writes an SQL &lt;code&gt;CLOB&lt;/code&gt; value to the stream.</source>
          <target state="translated">将SQL &lt;code&gt;CLOB&lt;/code&gt; 值写入流中。</target>
        </trans-unit>
        <trans-unit id="7ac466542da1fd570e1cd8a85e10a89c5a0478d3" translate="yes" xml:space="preserve">
          <source>Writes an SQL &lt;code&gt;NCLOB&lt;/code&gt; value to the stream.</source>
          <target state="translated">将SQL &lt;code&gt;NCLOB&lt;/code&gt; 值写入流。</target>
        </trans-unit>
        <trans-unit id="7b0bab43ec185e7755ca9c724c82dd497e3a75ed" translate="yes" xml:space="preserve">
          <source>Writes an SQL &lt;code&gt;REF&lt;/code&gt; value to the stream.</source>
          <target state="translated">将SQL &lt;code&gt;REF&lt;/code&gt; 值写入流。</target>
        </trans-unit>
        <trans-unit id="a32b75a2ac4c35b2bd936894dad35a1a6f742c74" translate="yes" xml:space="preserve">
          <source>Writes an SQL &lt;code&gt;ROWID&lt;/code&gt; value to the stream.</source>
          <target state="translated">将SQL &lt;code&gt;ROWID&lt;/code&gt; 值写入流。</target>
        </trans-unit>
        <trans-unit id="afc969edfce1a8e9fcd57215da43efe7e17bb98e" translate="yes" xml:space="preserve">
          <source>Writes an SQL &lt;code&gt;XML&lt;/code&gt; value to the stream.</source>
          <target state="translated">将SQL &lt;code&gt;XML&lt;/code&gt; 值写入流。</target>
        </trans-unit>
        <trans-unit id="7240a87818ff11b59c7bd527a158977756f9198d" translate="yes" xml:space="preserve">
          <source>Writes an SQL structured type value to the stream.</source>
          <target state="translated">将一个SQL结构类型的值写入流中。</target>
        </trans-unit>
        <trans-unit id="c44ca6e735d840ae66abcebcaf5b0d7cfe24713f" translate="yes" xml:space="preserve">
          <source>Writes an array of &lt;code&gt;bytes&lt;/code&gt; in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object.</source>
          <target state="translated">将Java编程语言中的 &lt;code&gt;bytes&lt;/code&gt; 数组写入此 &lt;code&gt;SQLOutputImpl&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="b474a9b337ecaac54d234baeb045aa62283d0dc8" translate="yes" xml:space="preserve">
          <source>Writes an array of &lt;code&gt;bytes&lt;/code&gt; in the Java programming language to this &lt;code&gt;SQLOutputImpl&lt;/code&gt; object. The driver converts it to an SQL &lt;code&gt;VARBINARY&lt;/code&gt; or &lt;code&gt;LONGVARBINARY&lt;/code&gt; before returning it to the database.</source>
          <target state="translated">将Java编程语言中的 &lt;code&gt;bytes&lt;/code&gt; 数组写入此 &lt;code&gt;SQLOutputImpl&lt;/code&gt; 对象。驱动程序在将其返回数据库之前将其转换为SQL &lt;code&gt;VARBINARY&lt;/code&gt; 或 &lt;code&gt;LONGVARBINARY&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5217c0bfa237688fd5947f4b90ec0cc289c0ec25" translate="yes" xml:space="preserve">
          <source>Writes an array of bytes to the compressed output stream.</source>
          <target state="translated">将一个字节数组写入压缩输出流。</target>
        </trans-unit>
        <trans-unit id="91391ca01713b61e3a68471e88e1a2ec74a5e484" translate="yes" xml:space="preserve">
          <source>Writes an array of bytes to the compressed output stream. This method will block until all the bytes are written.</source>
          <target state="translated">将一个字节数组写入压缩输出流。本方法将被阻塞,直到所有字节被写入。</target>
        </trans-unit>
        <trans-unit id="6dce90598d23fb38220959b230e17daa56e43c23" translate="yes" xml:space="preserve">
          <source>Writes an array of bytes to the current ZIP entry data.</source>
          <target state="translated">将一个字节数组写入当前ZIP条目数据。</target>
        </trans-unit>
        <trans-unit id="5bcc78bbe57b6ce8a96809d5c51d5bdd7eb8d10e" translate="yes" xml:space="preserve">
          <source>Writes an array of bytes to the current ZIP entry data. This method will block until all the bytes are written.</source>
          <target state="translated">将一个字节数组写入当前ZIP条目数据。本方法将被阻塞,直到所有字节被写入。</target>
        </trans-unit>
        <trans-unit id="b65fd57256c0433acff32087a2d8da5eaf47411f" translate="yes" xml:space="preserve">
          <source>Writes an array of bytes to the uncompressed output stream.</source>
          <target state="translated">将一个字节数组写入未压缩的输出流。</target>
        </trans-unit>
        <trans-unit id="197c4236f7ff27946de3d127438d615e38302ed3" translate="yes" xml:space="preserve">
          <source>Writes an array of bytes.</source>
          <target state="translated">写一个字节数组。</target>
        </trans-unit>
        <trans-unit id="184076d4a82e468a9041fc00d661d8b7d8f621bd" translate="yes" xml:space="preserve">
          <source>Writes an array of bytes. This method will block until the bytes are actually written.</source>
          <target state="translated">写入一个字节数组。本方法会阻塞,直到字节被实际写入。</target>
        </trans-unit>
        <trans-unit id="8dd5aee302b286670386d8cc0bc1e852dfd89da5" translate="yes" xml:space="preserve">
          <source>Writes an array of bytes. Will block until the bytes are actually written.</source>
          <target state="translated">写入一个字节数组。在实际写入字节之前会被阻塞。</target>
        </trans-unit>
        <trans-unit id="ea42af8fd102a5d23675fcd8f7e1a21accb34a84" translate="yes" xml:space="preserve">
          <source>Writes an array of characters.</source>
          <target state="translated">编写一个字符数组。</target>
        </trans-unit>
        <trans-unit id="928868e95fe6511cf01eeb699debe02725148a7f" translate="yes" xml:space="preserve">
          <source>Writes an array of characters. This method cannot be inherited from the Writer class because it must suppress I/O exceptions.</source>
          <target state="translated">写一个字符数组。这个方法不能从Writer类继承,因为它必须抑制I/O异常。</target>
        </trans-unit>
        <trans-unit id="52aa56d648776d9495d9366408ffa13186bb65ce" translate="yes" xml:space="preserve">
          <source>Writes an attribute to the output stream</source>
          <target state="translated">将一个属性写入输出流</target>
        </trans-unit>
        <trans-unit id="d2be112208b86261986a1ae461b3c896dc388e6c" translate="yes" xml:space="preserve">
          <source>Writes an attribute to the output stream without a prefix.</source>
          <target state="translated">将一个属性写入没有前缀的输出流。</target>
        </trans-unit>
        <trans-unit id="fff7d6a6f1bfe9778737c1fd78975331a3f83b47" translate="yes" xml:space="preserve">
          <source>Writes an empty element tag to the output</source>
          <target state="translated">将空元素标签写入输出</target>
        </trans-unit>
        <trans-unit id="f365dd8923cf096a9c9ae1d8063f6577f24f28f0" translate="yes" xml:space="preserve">
          <source>Writes an end tag to the output relying on the internal state of the writer to determine the prefix and local name of the event.</source>
          <target state="translated">依靠写入者的内部状态来确定事件的前缀和本地名称,将结束标签写入输出。</target>
        </trans-unit>
        <trans-unit id="2f6c2c4a372fcf8e32fba62c76c2b54b46f82b19" translate="yes" xml:space="preserve">
          <source>Writes an entity reference</source>
          <target state="translated">写一个实体引用</target>
        </trans-unit>
        <trans-unit id="845ca9715bac35ef1947ecff1b01781b98b923f3" translate="yes" xml:space="preserve">
          <source>Writes an image using an arbitrary &lt;code&gt;ImageWriter&lt;/code&gt; that supports the given format to a &lt;code&gt;File&lt;/code&gt;.</source>
          <target state="translated">使用支持给定格式的任意 &lt;code&gt;ImageWriter&lt;/code&gt; 将图像写入 &lt;code&gt;File&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ab7e466b9e9f6735bac5eb62165c0f91b84b2869" translate="yes" xml:space="preserve">
          <source>Writes an image using an arbitrary &lt;code&gt;ImageWriter&lt;/code&gt; that supports the given format to a &lt;code&gt;File&lt;/code&gt;. If there is already a &lt;code&gt;File&lt;/code&gt; present, its contents are discarded.</source>
          <target state="translated">使用支持给定格式的任意 &lt;code&gt;ImageWriter&lt;/code&gt; 将图像写入 &lt;code&gt;File&lt;/code&gt; 。如果已经存在 &lt;code&gt;File&lt;/code&gt; ，则将其内容丢弃。</target>
        </trans-unit>
        <trans-unit id="c33f9616c13e7b7edbad66a907a09cd89959adef" translate="yes" xml:space="preserve">
          <source>Writes an image using an arbitrary &lt;code&gt;ImageWriter&lt;/code&gt; that supports the given format to an &lt;code&gt;OutputStream&lt;/code&gt;.</source>
          <target state="translated">使用支持给定格式的任意 &lt;code&gt;ImageWriter&lt;/code&gt; 将图像写入 &lt;code&gt;OutputStream&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="029b27106448a88b4763369b511ecf056a37b60f" translate="yes" xml:space="preserve">
          <source>Writes an image using the an arbitrary &lt;code&gt;ImageWriter&lt;/code&gt; that supports the given format to an &lt;code&gt;ImageOutputStream&lt;/code&gt;.</source>
          <target state="translated">使用支持给定格式的任意 &lt;code&gt;ImageWriter&lt;/code&gt; 将图像写入 &lt;code&gt;ImageOutputStream&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="50e3dd58b633ef56e1113523580bcc40cd8f5260" translate="yes" xml:space="preserve">
          <source>Writes an image using the an arbitrary &lt;code&gt;ImageWriter&lt;/code&gt; that supports the given format to an &lt;code&gt;ImageOutputStream&lt;/code&gt;. The image is written to the &lt;code&gt;ImageOutputStream&lt;/code&gt; starting at the current stream pointer, overwriting existing stream data from that point forward, if present.</source>
          <target state="translated">使用支持给定格式的任意 &lt;code&gt;ImageWriter&lt;/code&gt; 将图像写入 &lt;code&gt;ImageOutputStream&lt;/code&gt; 。图像从当前流指针开始写入 &lt;code&gt;ImageOutputStream&lt;/code&gt; ，从该点开始覆盖现有流数据（如果存在）。</target>
        </trans-unit>
        <trans-unit id="90f8a005a0e018089c9a966aa619c33c07892546" translate="yes" xml:space="preserve">
          <source>Writes an xml comment with the data enclosed</source>
          <target state="translated">写一个包含数据的xml注释。</target>
        </trans-unit>
        <trans-unit id="5de95ba3e3608236749217a0c7e571c0056a27af" translate="yes" xml:space="preserve">
          <source>Writes any cached events to the underlying output mechanism</source>
          <target state="translated">将任何缓存的事件写入底层输出机制。</target>
        </trans-unit>
        <trans-unit id="ab24f3dcbe1fa930ff321e8116207af7e2609aeb" translate="yes" xml:space="preserve">
          <source>Writes any remaining uncompressed data to the output stream and closes the underlying output stream.</source>
          <target state="translated">将任何剩余的未压缩数据写入输出流,并关闭底层输出流。</target>
        </trans-unit>
        <trans-unit id="ea812aceedf14d0e6ad904b2cb8f433e4915a909" translate="yes" xml:space="preserve">
          <source>Writes array of bytes to the compressed output stream.</source>
          <target state="translated">将字节数组写入压缩输出流。</target>
        </trans-unit>
        <trans-unit id="bf35ba162e8457e73f54882a5c5184fa9e4fc908" translate="yes" xml:space="preserve">
          <source>Writes array of bytes to the compressed output stream. This method will block until all the bytes are written.</source>
          <target state="translated">将字节数组写入压缩输出流。本方法会阻塞,直到所有字节被写入。</target>
        </trans-unit>
        <trans-unit id="37ced05917aa020878d79b8932701d27f22098fc" translate="yes" xml:space="preserve">
          <source>Writes audio data to the mixer via this source data line.</source>
          <target state="translated">通过该源数据线向混音器写入音频数据。</target>
        </trans-unit>
        <trans-unit id="f8a4f11dbea6b299c527b750b72fea853ce19352" translate="yes" xml:space="preserve">
          <source>Writes audio data to the mixer via this source data line. The requested number of bytes of data are read from the specified array, starting at the given offset into the array, and written to the data line's buffer. If the caller attempts to write more data than can currently be written (see &lt;a href=&quot;dataline#available()&quot;&gt;&lt;code&gt;available&lt;/code&gt;&lt;/a&gt;), this method blocks until the requested amount of data has been written. This applies even if the requested amount of data to write is greater than the data line's buffer size. However, if the data line is closed, stopped, or flushed before the requested amount has been written, the method no longer blocks, but returns the number of bytes written thus far.</source>
          <target state="translated">通过此源数据线将音频数据写入混音器。从指定数组中读取请求的数据字节数，从指定的偏移量开始到数组中，然后将其写入数据线的缓冲区。如果调用方尝试写入的数据量超过当前写入的数据量（请参阅&lt;a href=&quot;dataline#available()&quot;&gt; &lt;code&gt;available&lt;/code&gt; &lt;/a&gt;），则此方法将阻塞，直到已写入请求的数据量为止。即使请求写入的数据量大于数据行的缓冲区大小，这也适用。但是，如果在写入请求的数量之前关闭，停止或刷新了数据线，则该方法不再阻塞，而是返回到目前为止已写入的字节数。</target>
        </trans-unit>
        <trans-unit id="9f542e25c7d41a9ed23b80d6673b5442bf3f0be9" translate="yes" xml:space="preserve">
          <source>Writes audio data to the mixer via this source data line. The requested number of bytes of data are read from the specified array, starting at the given offset into the array, and written to the data line's buffer. If the caller attempts to write more data than can currently be written (see &lt;code&gt;&lt;a href=&quot;dataline#available--&quot;&gt;&lt;code&gt;available&lt;/code&gt;&lt;/a&gt;&lt;/code&gt;), this method blocks until the requested amount of data has been written. This applies even if the requested amount of data to write is greater than the data line's buffer size. However, if the data line is closed, stopped, or flushed before the requested amount has been written, the method no longer blocks, but returns the number of bytes written thus far.</source>
          <target state="translated">通过此源数据线将音频数据写入混音器。从指定数组中读取请求的数据字节数，从给定的偏移量开始到数组中，然后将其写入数据线的缓冲区。如果调用方尝试写入的数据量超过当前写入的数据量（请参阅 &lt;code&gt;&lt;a href=&quot;dataline#available--&quot;&gt;&lt;code&gt;available&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; ），则此方法将阻塞，直到已写入请求的数据量为止。即使请求写入的数据量大于数据行的缓冲区大小，这也适用。但是，如果在写入请求的数量之前关闭，停止或刷新了数据线，则该方法不再阻塞，而是返回到目前为止已写入的字节数。</target>
        </trans-unit>
        <trans-unit id="70af5ea88b88ac39f37fa0e6431e3587c4947620" translate="yes" xml:space="preserve">
          <source>Writes bytes to a file.</source>
          <target state="translated">将字节写入文件。</target>
        </trans-unit>
        <trans-unit id="539e94f80819f8addfe61f29f8d0c0095d59f44a" translate="yes" xml:space="preserve">
          <source>Writes bytes to a file. The &lt;code&gt;options&lt;/code&gt; parameter specifies how the file is created or opened. If no options are present then this method works as if the &lt;a href=&quot;standardopenoption#CREATE&quot;&gt;&lt;code&gt;CREATE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;standardopenoption#TRUNCATE_EXISTING&quot;&gt;&lt;code&gt;TRUNCATE_EXISTING&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;standardopenoption#WRITE&quot;&gt;&lt;code&gt;WRITE&lt;/code&gt;&lt;/a&gt; options are present. In other words, it opens the file for writing, creating the file if it doesn't exist, or initially truncating an existing &lt;a href=&quot;#isRegularFile(java.nio.file.Path,java.nio.file.LinkOption...)&quot;&gt;&lt;code&gt;regular-file&lt;/code&gt;&lt;/a&gt; to a size of &lt;code&gt;0&lt;/code&gt;. All bytes in the byte array are written to the file. The method ensures that the file is closed when all bytes have been written (or an I/O error or other runtime exception is thrown). If an I/O error occurs then it may do so after the file has been created or truncated, or after some bytes have been written to the file.</source>
          <target state="translated">将字节写入文件。该 &lt;code&gt;options&lt;/code&gt; 参数指定如何创建或打开该文件。如果不存在任何选项，则此方法就像存在&lt;a href=&quot;standardopenoption#CREATE&quot;&gt; &lt;code&gt;CREATE&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;standardopenoption#TRUNCATE_EXISTING&quot;&gt; &lt;code&gt;TRUNCATE_EXISTING&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;standardopenoption#WRITE&quot;&gt; &lt;code&gt;WRITE&lt;/code&gt; &lt;/a&gt;选项一样工作。换句话说，它打开文件进行写入，如果不存在则创建文件，或者首先将现有的&lt;a href=&quot;#isRegularFile(java.nio.file.Path,java.nio.file.LinkOption...)&quot;&gt; &lt;code&gt;regular-file&lt;/code&gt; &lt;/a&gt;截断为 &lt;code&gt;0&lt;/code&gt; 。字节数组中的所有字节均写入文件。该方法可确保在写入所有字节后（或者引发I / O错误或其他运行时异常）关闭文件。如果发生I / O错误，则可以在创建或截断文件后或在将某些字节写入文件后执行此操作。</target>
        </trans-unit>
        <trans-unit id="87e219a2917354808d12478e2ed7441db173e738" translate="yes" xml:space="preserve">
          <source>Writes bytes to a file. The &lt;code&gt;options&lt;/code&gt; parameter specifies how the the file is created or opened. If no options are present then this method works as if the &lt;a href=&quot;standardopenoption#CREATE&quot;&gt;&lt;code&gt;CREATE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;standardopenoption#TRUNCATE_EXISTING&quot;&gt;&lt;code&gt;TRUNCATE_EXISTING&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;standardopenoption#WRITE&quot;&gt;&lt;code&gt;WRITE&lt;/code&gt;&lt;/a&gt; options are present. In other words, it opens the file for writing, creating the file if it doesn't exist, or initially truncating an existing &lt;a href=&quot;files#isRegularFile-java.nio.file.Path-java.nio.file.LinkOption...-&quot;&gt;&lt;code&gt;regular-file&lt;/code&gt;&lt;/a&gt; to a size of &lt;code&gt;0&lt;/code&gt;. All bytes in the byte array are written to the file. The method ensures that the file is closed when all bytes have been written (or an I/O error or other runtime exception is thrown). If an I/O error occurs then it may do so after the file has created or truncated, or after some bytes have been written to the file.</source>
          <target state="translated">将字节写入文件。该 &lt;code&gt;options&lt;/code&gt; 参数指定如何创建或打开该文件。如果不存在任何选项，则此方法将像存在&lt;a href=&quot;standardopenoption#CREATE&quot;&gt; &lt;code&gt;CREATE&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;standardopenoption#TRUNCATE_EXISTING&quot;&gt; &lt;code&gt;TRUNCATE_EXISTING&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;standardopenoption#WRITE&quot;&gt; &lt;code&gt;WRITE&lt;/code&gt; &lt;/a&gt;选项一样工作。换句话说，它将打开文件进行写入，如果不存在则创建文件，或者首先将现有的&lt;a href=&quot;files#isRegularFile-java.nio.file.Path-java.nio.file.LinkOption...-&quot;&gt; &lt;code&gt;regular-file&lt;/code&gt; &lt;/a&gt;截断为 &lt;code&gt;0&lt;/code&gt; 。字节数组中的所有字节均写入文件。该方法可确保在写入所有字节后（或者引发I / O错误或其他运行时异常）关闭文件。如果发生I / O错误，则可以在创建或截断文件后，或者在将某些字节写入文件后执行此操作。</target>
        </trans-unit>
        <trans-unit id="3aa9eb435ce66122fd3b1fbb9683dc6f39b12396" translate="yes" xml:space="preserve">
          <source>Writes characters to the buffer.</source>
          <target state="translated">将字符写入缓冲区。</target>
        </trans-unit>
        <trans-unit id="7d60a1b7a1a3d14a49cb496536b68fe0e5783720" translate="yes" xml:space="preserve">
          <source>Writes content from a document to the given stream as plain text.</source>
          <target state="translated">将文档中的内容以纯文本的形式写入给定的流。</target>
        </trans-unit>
        <trans-unit id="d97477c205ceea09c92c5946659e274241b1ae36" translate="yes" xml:space="preserve">
          <source>Writes content from a document to the given stream in a format appropriate for this kind of content handler.</source>
          <target state="translated">将文档中的内容以适合这种内容处理程序的格式写入给定的流。</target>
        </trans-unit>
        <trans-unit id="b26649091ef7b5d2a209d730bd88924f12963e9c" translate="yes" xml:space="preserve">
          <source>Writes eight bytes containing the given double value, in the current byte order, into this buffer at the current position, and then increments the position by eight.</source>
          <target state="translated">将包含给定双倍值的8个字节按当前字节顺序写入当前位置的缓冲区,然后将该位置递增8个字节。</target>
        </trans-unit>
        <trans-unit id="29fc7be2d2fa2a9838cc38ff4c3934f5c3f3655d" translate="yes" xml:space="preserve">
          <source>Writes eight bytes containing the given double value, in the current byte order, into this buffer at the given index.</source>
          <target state="translated">将包含给定双倍值的8个字节以当前字节顺序写入给定索引的缓冲区。</target>
        </trans-unit>
        <trans-unit id="cc89b642bf8674896232f688adbc8ebc5d1dfdc8" translate="yes" xml:space="preserve">
          <source>Writes eight bytes containing the given long value, in the current byte order, into this buffer at the current position, and then increments the position by eight.</source>
          <target state="translated">将包含给定长值的8个字节按当前字节顺序写入当前位置的缓冲区,然后将该位置递增8个字节。</target>
        </trans-unit>
        <trans-unit id="2bb4a200c6266d5b89a3ab96d32530f2a49d3e59" translate="yes" xml:space="preserve">
          <source>Writes eight bytes containing the given long value, in the current byte order, into this buffer at the given index.</source>
          <target state="translated">将包含给定长值的8个字节以当前字节顺序写入给定索引的缓冲区。</target>
        </trans-unit>
        <trans-unit id="2487fee69be7365dce9130ceec028a6bb7fc07e9" translate="yes" xml:space="preserve">
          <source>Writes every character in the string &lt;code&gt;s&lt;/code&gt;, to the output stream, in order, two bytes per character.</source>
          <target state="translated">依次将字符串 &lt;code&gt;s&lt;/code&gt; 中的每个字符写入输出流，每个字符两个字节。</target>
        </trans-unit>
        <trans-unit id="b9d0787a90c45f72d95f7e055e81599ca892dbaf" translate="yes" xml:space="preserve">
          <source>Writes every character in the string &lt;code&gt;s&lt;/code&gt;, to the output stream, in order, two bytes per character. If &lt;code&gt;s&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, a &lt;code&gt;NullPointerException&lt;/code&gt; is thrown. If &lt;code&gt;s.length&lt;/code&gt; is zero, then no characters are written. Otherwise, the character &lt;code&gt;s[0]&lt;/code&gt; is written first, then &lt;code&gt;s[1]&lt;/code&gt;, and so on; the last character written is &lt;code&gt;s[s.length-1]&lt;/code&gt;. For each character, two bytes are actually written, high-order byte first, in exactly the manner of the &lt;code&gt;writeChar&lt;/code&gt; method.</source>
          <target state="translated">依次将字符串 &lt;code&gt;s&lt;/code&gt; 中的每个字符写入输出流，每个字符两个字节。如果 &lt;code&gt;s&lt;/code&gt; 为 &lt;code&gt;null&lt;/code&gt; ，则抛出 &lt;code&gt;NullPointerException&lt;/code&gt; 。如果 &lt;code&gt;s.length&lt;/code&gt; 为零，则不写入任何字符。否则，先写字符 &lt;code&gt;s[0]&lt;/code&gt; ，然后写 &lt;code&gt;s[1]&lt;/code&gt; ，依此类推；最后写入 &lt;code&gt;s[s.length-1]&lt;/code&gt; 字符是s [s.length-1]。对于每个字符，实际上完全按照 &lt;code&gt;writeChar&lt;/code&gt; 方法的方式写入两个字节，首先写入高位字节。</target>
        </trans-unit>
        <trans-unit id="3b4e00ea7b401f90dc90c64677abaf47d2170156" translate="yes" xml:space="preserve">
          <source>Writes four bytes containing the given float value, in the current byte order, into this buffer at the current position, and then increments the position by four.</source>
          <target state="translated">将包含给定浮点数的4个字节以当前字节顺序写入当前位置的缓冲区,然后将该位置增加4个字节。</target>
        </trans-unit>
        <trans-unit id="5d979f53ff93d5b35a5d4de9156c84a797cd1d5a" translate="yes" xml:space="preserve">
          <source>Writes four bytes containing the given float value, in the current byte order, into this buffer at the given index.</source>
          <target state="translated">将包含给定float值的4个字节按当前字节顺序写入给定索引的缓冲区。</target>
        </trans-unit>
        <trans-unit id="d8eac6d4c7237a86bdd435eec454a1165fa276c0" translate="yes" xml:space="preserve">
          <source>Writes four bytes containing the given int value, in the current byte order, into this buffer at the current position, and then increments the position by four.</source>
          <target state="translated">将包含给定int值的4个字节按当前字节顺序写入当前位置的缓冲区,然后将位置增加4个字节。</target>
        </trans-unit>
        <trans-unit id="5cf0746092fdb63187e2dce0e857024f58099778" translate="yes" xml:space="preserve">
          <source>Writes four bytes containing the given int value, in the current byte order, into this buffer at the given index.</source>
          <target state="translated">将包含给定int值的4个字节以当前字节顺序写入给定索引的缓冲区。</target>
        </trans-unit>
        <trans-unit id="ceb6f95baf23beaeef39ebca1fb801718774f47c" translate="yes" xml:space="preserve">
          <source>Writes next block of compressed data to the output stream.</source>
          <target state="translated">将下一个压缩数据块写入输出流。</target>
        </trans-unit>
        <trans-unit id="f716150ad2b59e1e2c39f51e686b6112c9516c37" translate="yes" xml:space="preserve">
          <source>Writes out a &lt;code&gt;byte&lt;/code&gt; to the underlying output stream as a 1-byte value.</source>
          <target state="translated">将 &lt;code&gt;byte&lt;/code&gt; 作为1字节的值写到基础输出流。</target>
        </trans-unit>
        <trans-unit id="793d3092c9065640c3553038c363272625fcd2c4" translate="yes" xml:space="preserve">
          <source>Writes out a &lt;code&gt;byte&lt;/code&gt; to the underlying output stream as a 1-byte value. If no exception is thrown, the counter &lt;code&gt;written&lt;/code&gt; is incremented by &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;byte&lt;/code&gt; 作为1字节的值写到基础输出流。如果未引发异常，则 &lt;code&gt;written&lt;/code&gt; 的计数器将增加 &lt;code&gt;1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d781a8fad1ddbd48d34b00f1d27f845c18c1752a" translate="yes" xml:space="preserve">
          <source>Writes out a character.</source>
          <target state="translated">写出了一个人物。</target>
        </trans-unit>
        <trans-unit id="a4149ecfaf0a53ba4649ab673e88332a5ee9da18" translate="yes" xml:space="preserve">
          <source>Writes out a character. This is implemented to invoke the &lt;code&gt;write&lt;/code&gt; method that takes a char[].</source>
          <target state="translated">写出一个字符。实现此方法以调用采用char []的 &lt;code&gt;write&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="b140b7ef352adc85171d5601e6a4059a8beb9ddb" translate="yes" xml:space="preserve">
          <source>Writes out a start tag appropriately indented.</source>
          <target state="translated">写出一个适当缩进的起始标签。</target>
        </trans-unit>
        <trans-unit id="59cd99484ad8b2ddeeb11187543a4b9e32ee97be" translate="yes" xml:space="preserve">
          <source>Writes out a start tag appropriately indented. Also increments the indent level.</source>
          <target state="translated">写出一个适当缩进的起始标签。同时递增缩进级别。</target>
        </trans-unit>
        <trans-unit id="3adc971c51b7b35d342948b59ee6c8ece76c15bf" translate="yes" xml:space="preserve">
          <source>Writes out a start tag for the &amp;lt;font&amp;gt; tag. Because font tags cannot be nested, this method closes out any enclosing font tag before writing out a new start tag.</source>
          <target state="translated">写出&amp;lt;font&amp;gt;标记的开始标记。因为字体标签不能嵌套，所以此方法在写出新的开始标签之前会关闭所有封闭的字体标签。</target>
        </trans-unit>
        <trans-unit id="79f42a920e1137b6f79fa6f072c0a5db14d2ce25" translate="yes" xml:space="preserve">
          <source>Writes out a start tag for the element.</source>
          <target state="translated">写出元素的起始标签。</target>
        </trans-unit>
        <trans-unit id="356d987d07c2b42cce555e735e5353fcf20d7274" translate="yes" xml:space="preserve">
          <source>Writes out a start tag for the element. Ignores all synthesized elements.</source>
          <target state="translated">为元素写出一个起始标签。忽略所有合成的元素。</target>
        </trans-unit>
        <trans-unit id="32e7980350f2d5d345b80613927c3a10708d9d12" translate="yes" xml:space="preserve">
          <source>Writes out a string.</source>
          <target state="translated">写出一个字符串。</target>
        </trans-unit>
        <trans-unit id="493534febd569e8eefd0de76e69315ffc098581b" translate="yes" xml:space="preserve">
          <source>Writes out a string. This is implemented to invoke the &lt;code&gt;write&lt;/code&gt; method that takes a char[].</source>
          <target state="translated">写出一个字符串。实现此方法以调用采用char []的 &lt;code&gt;write&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="242b41b748966187939dd514ce8f221ecfb52196" translate="yes" xml:space="preserve">
          <source>Writes out all empty elements (all tags that have no corresponding end tag).</source>
          <target state="translated">写出所有空元素(所有没有对应结束标签的标签)。</target>
        </trans-unit>
        <trans-unit id="45fd8d7e498fa017170b717aede40700f6694fc2" translate="yes" xml:space="preserve">
          <source>Writes out all the attributes for the following types: StyleConstants.ParagraphConstants, StyleConstants.CharacterConstants, StyleConstants.FontConstants, StyleConstants.ColorConstants.</source>
          <target state="translated">写出以下类型的所有属性。StyleConstants.ParagraphConstants,StyleConstants.CharacterConstants,StyleConstants.FontConstants,StyleConstants.ColorConstants.</target>
        </trans-unit>
        <trans-unit id="b15c5c0d66618d9399589ac1eea1921ed967d0f6" translate="yes" xml:space="preserve">
          <source>Writes out all the attributes for the following types: StyleConstants.ParagraphConstants, StyleConstants.CharacterConstants, StyleConstants.FontConstants, StyleConstants.ColorConstants. The attribute name and value are separated by a colon. Each pair is separated by a semicolon.</source>
          <target state="translated">写出以下类型的所有属性。StyleConstants.ParagraphConstants,StyleConstants.CharacterConstants,StyleConstants.FontConstants,StyleConstants.ColorConstants。属性名和值用冒号隔开。每对属性之间用分号隔开。</target>
        </trans-unit>
        <trans-unit id="3ea000abebf3e796c2231c4084f5c3ec51fda40e" translate="yes" xml:space="preserve">
          <source>Writes out all the named styles as the content of the &amp;lt;style&amp;gt; tag.</source>
          <target state="translated">写出所有命名的样式作为&amp;lt;style&amp;gt;标记的内容。</target>
        </trans-unit>
        <trans-unit id="95aa7506da86487c9d8a3dd4aad789dffcf726cb" translate="yes" xml:space="preserve">
          <source>Writes out an end tag appropriately indented.</source>
          <target state="translated">写出一个适当缩进的结束标签。</target>
        </trans-unit>
        <trans-unit id="f8a3e8b63a7d7db5de505123b83e2632e59b6f4a" translate="yes" xml:space="preserve">
          <source>Writes out an end tag appropriately indented. Also decrements the indent level.</source>
          <target state="translated">写出适当缩进的结束标签。还可以减少缩进程度。</target>
        </trans-unit>
        <trans-unit id="91e658fa4cec6ec79dc0e2ffcd3905fbdaf669c0" translate="yes" xml:space="preserve">
          <source>Writes out an end tag for the &amp;lt;font&amp;gt; tag.</source>
          <target state="translated">写出&amp;lt;font&amp;gt;标签的结束标签。</target>
        </trans-unit>
        <trans-unit id="3d31826423dc7c1e67f148ff784ac0beacea46fe" translate="yes" xml:space="preserve">
          <source>Writes out an end tag for the element.</source>
          <target state="translated">写出元素的结束标签。</target>
        </trans-unit>
        <trans-unit id="3a070bf3f90011012888b6f65043e51f7be1db04" translate="yes" xml:space="preserve">
          <source>Writes out comments.</source>
          <target state="translated">写出评论。</target>
        </trans-unit>
        <trans-unit id="2e3bee8704d332f162a00133a136ad93991e1fcd" translate="yes" xml:space="preserve">
          <source>Writes out text that is contained in a TEXTAREA form element.</source>
          <target state="translated">写出包含在TEXTAREA表格元素中的文本。</target>
        </trans-unit>
        <trans-unit id="d8271b9150a2c67ce97fd91c10873bb46909d357" translate="yes" xml:space="preserve">
          <source>Writes out text.</source>
          <target state="translated">写出文字。</target>
        </trans-unit>
        <trans-unit id="abc7bcf64efcb93db19ad0308ad3a28eed435488" translate="yes" xml:space="preserve">
          <source>Writes out text. If a range is specified when the constructor is invoked, then only the appropriate range of text is written out.</source>
          <target state="translated">写出文本。如果在调用构造函数时指定了一个范围,那么只写出相应范围的文本。</target>
        </trans-unit>
        <trans-unit id="1a2feb0ee03b2fb37577d2683165471850570c57" translate="yes" xml:space="preserve">
          <source>Writes out the &amp;lt;head&amp;gt; and &amp;lt;style&amp;gt; tags, and then invokes writeStyles() to write out all the named styles as the content of the &amp;lt;style&amp;gt; tag.</source>
          <target state="translated">写出&amp;lt;head&amp;gt;和&amp;lt;style&amp;gt;标记，然后调用writeStyles（）以写出所有命名的样式作为&amp;lt;style&amp;gt;标记的内容。</target>
        </trans-unit>
        <trans-unit id="1d67167a503faefc3b4e96ac0d49dfd64c919c5a" translate="yes" xml:space="preserve">
          <source>Writes out the &amp;lt;head&amp;gt; and &amp;lt;style&amp;gt; tags, and then invokes writeStyles() to write out all the named styles as the content of the &amp;lt;style&amp;gt; tag. The content is surrounded by valid HTML comment markers to ensure that the document is viewable in applications/browsers that do not support the tag.</source>
          <target state="translated">写出&amp;lt;head&amp;gt;和&amp;lt;style&amp;gt;标记，然后调用writeStyles（）以写出所有命名的样式作为&amp;lt;style&amp;gt;标记的内容。内容被有效的HTML注释标记包围，以确保可在不支持该标记的应用程序/浏览器中查看该文档。</target>
        </trans-unit>
        <trans-unit id="cb594e7c2614c3f26268fa1d6f121a7690ffbc18" translate="yes" xml:space="preserve">
          <source>Writes out the attribute set in an HTML-compliant manner.</source>
          <target state="translated">以符合HTML的方式写出属性集。</target>
        </trans-unit>
        <trans-unit id="50df6d6c3b3e39b2b4d38cb825b404ff3b15a69f" translate="yes" xml:space="preserve">
          <source>Writes out the attribute set.</source>
          <target state="translated">写出属性集。</target>
        </trans-unit>
        <trans-unit id="3bbd16063a5b5b4cb118131679e17c07f900bc85" translate="yes" xml:space="preserve">
          <source>Writes out the attribute set. Ignores all attributes with a key of type HTML.Tag, attributes with a key of type StyleConstants, and attributes with a key of type HTML.Attribute.ENDTAG.</source>
          <target state="translated">写出属性集。忽略所有键值为HTML.Tag的属性、键值为StyleConstants的属性和键值为HTML.Attribute.ENDTAG的属性。</target>
        </trans-unit>
        <trans-unit id="1b012971e329c1b5642a4a72d93bbe2b77837d70" translate="yes" xml:space="preserve">
          <source>Writes out the content of the Option form element.</source>
          <target state="translated">写出 Option form 元素的内容。</target>
        </trans-unit>
        <trans-unit id="522f62e68017f3dd760479be9b0d3f17baeb3def" translate="yes" xml:space="preserve">
          <source>Writes out the content of the SELECT form element.</source>
          <target state="translated">写出SELECT表格元素的内容。</target>
        </trans-unit>
        <trans-unit id="4d59bf0b74e182fe97baa2f628898aa78e036aba" translate="yes" xml:space="preserve">
          <source>Writes out the remaining character-level attributes (attributes other than bold, italic, and underline) in an HTML-compliant way.</source>
          <target state="translated">以符合HTML的方式写出剩余的字符级属性(除了粗体、斜体和下划线以外的属性)。</target>
        </trans-unit>
        <trans-unit id="aab68f7962761ed64910659bf2f1f7f92a40c4d4" translate="yes" xml:space="preserve">
          <source>Writes out the remaining character-level attributes (attributes other than bold, italic, and underline) in an HTML-compliant way. Given that attributes such as font family and font size have no direct mapping to HTML tags, a &amp;lt;span&amp;gt; tag is generated and its style attribute is set to contain the list of remaining attributes just like inline styles.</source>
          <target state="translated">以符合HTML的方式写出剩余的字符级属性（粗体，斜体和下划线以外的属性）。假定诸如字体系列和字体大小之类的属性没有直接映射到HTML标记，则会生成一个&amp;lt;span&amp;gt;标记，并将其样式属性设置为包含其余属性的列表，就像内联样式一样。</target>
        </trans-unit>
        <trans-unit id="f1da4ae2350b8ea9bf6c7b5422ed8adaeef31d8e" translate="yes" xml:space="preserve">
          <source>Writes out the set of attributes as &quot; &amp;lt;name&amp;gt;=&amp;lt;value&amp;gt;&quot; pairs.</source>
          <target state="translated">将属性集写为&amp;ldquo; &amp;lt;name&amp;gt; = &amp;lt;value&amp;gt;&amp;rdquo;对。</target>
        </trans-unit>
        <trans-unit id="8a0f5a5f07a705ce87b430d9d69b03ff6c74cbfc" translate="yes" xml:space="preserve">
          <source>Writes out the set of attributes as &quot; &amp;lt;name&amp;gt;=&amp;lt;value&amp;gt;&quot; pairs. It throws an IOException when encountered.</source>
          <target state="translated">将属性集写为&amp;ldquo; &amp;lt;name&amp;gt; = &amp;lt;value&amp;gt;&amp;rdquo;对。遇到时将引发IOException。</target>
        </trans-unit>
        <trans-unit id="88fb3884fdd7120949e40123aff7eb69222dd291" translate="yes" xml:space="preserve">
          <source>Writes out the string to the underlying output stream as a sequence of bytes.</source>
          <target state="translated">将字符串作为字节序列写入底层输出流。</target>
        </trans-unit>
        <trans-unit id="b05d15e021ce2f4dcac9e9d78114869b4a50f886" translate="yes" xml:space="preserve">
          <source>Writes out the string to the underlying output stream as a sequence of bytes. Each character in the string is written out, in sequence, by discarding its high eight bits. If no exception is thrown, the counter &lt;code&gt;written&lt;/code&gt; is incremented by the length of &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">将字符串作为字节序列写出到基础输出流中。字符串中的每个字符通过丢弃高八位来依次写出。如果未引发异常，则 &lt;code&gt;written&lt;/code&gt; 的计数器将增加 &lt;code&gt;s&lt;/code&gt; 的长度。</target>
        </trans-unit>
        <trans-unit id="d426192659256406de28eda44669a9ce5d358062" translate="yes" xml:space="preserve">
          <source>Writes recording data to a file.</source>
          <target state="translated">将记录数据写入文件。</target>
        </trans-unit>
        <trans-unit id="37980950b6bfa72a356d0cb2c6fe45c994849d35" translate="yes" xml:space="preserve">
          <source>Writes recording data to the specified file.</source>
          <target state="translated">将记录数据写入指定的文件。</target>
        </trans-unit>
        <trans-unit id="6a3054c268468152f2a8887eea01d971616cbb74" translate="yes" xml:space="preserve">
          <source>Writes remaining compressed data to the output stream and closes the underlying stream.</source>
          <target state="translated">将剩余的压缩数据写入输出流并关闭底层流。</target>
        </trans-unit>
        <trans-unit id="28f3ab69dea5b395ecbb033c1f9e3a56f4abd902" translate="yes" xml:space="preserve">
          <source>Writes statement &lt;code&gt;oldStm&lt;/code&gt; to the stream.</source>
          <target state="translated">将语句 &lt;code&gt;oldStm&lt;/code&gt; 写入流中。</target>
        </trans-unit>
        <trans-unit id="61581676dc1ea35473d6a783082bf72e9c80ceec" translate="yes" xml:space="preserve">
          <source>Writes statement &lt;code&gt;oldStm&lt;/code&gt; to the stream. The &lt;code&gt;oldStm&lt;/code&gt; should be written entirely in terms of the callers environment, i.e. the target and all arguments should be part of the object graph being written. These expressions represent a series of &quot;what happened&quot; expressions which tell the output stream how to produce an object graph like the original.</source>
          <target state="translated">将语句 &lt;code&gt;oldStm&lt;/code&gt; 写入流中。所述 &lt;code&gt;oldStm&lt;/code&gt; 应完全在呼叫者环境方面被写入，即，在目标和所有参数应是对象图的一部分被写入。这些表达式表示一系列&amp;ldquo;发生的事情&amp;rdquo;表达式，这些表达式告诉输出流如何生成类似于原始图形的对象图。</target>
        </trans-unit>
        <trans-unit id="f052f35920dd89a7054c35d1df3b6bfb93d13930" translate="yes" xml:space="preserve">
          <source>Writes text to a character-output stream, buffering characters so as to provide for the efficient writing of single characters, arrays, and strings.</source>
          <target state="translated">将文本写入字符输出流,对字符进行缓冲,以便高效地写入单个字符、数组和字符串。</target>
        </trans-unit>
        <trans-unit id="597dfd2df5025e0ac661bb05d062c2aa056c141e" translate="yes" xml:space="preserve">
          <source>Writes text to character files using a default buffer size.</source>
          <target state="translated">使用默认的缓冲区大小将文本写入字符文件。</target>
        </trans-unit>
        <trans-unit id="6167d657904cfcab0dbb9315dd6a6ecb18ddf064" translate="yes" xml:space="preserve">
          <source>Writes text to character files using a default buffer size. Encoding from characters to bytes uses either a specified &lt;a href=&quot;../nio/charset/charset&quot;&gt;charset&lt;/a&gt; or the platform's &lt;a href=&quot;../nio/charset/charset#defaultCharset()&quot;&gt;default charset&lt;/a&gt;.</source>
          <target state="translated">使用默认缓冲区大小将文本写入字符文件。从字符到字节的编码使用指定的&lt;a href=&quot;../nio/charset/charset&quot;&gt;字符集&lt;/a&gt;或平台的&lt;a href=&quot;../nio/charset/charset#defaultCharset()&quot;&gt;默认字符集&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="862b19d4b6ff1b6eff3c4ad6b6bdab89231c477b" translate="yes" xml:space="preserve">
          <source>Writes the 16 low-order bits of &lt;code&gt;v&lt;/code&gt; to the stream.</source>
          <target state="translated">将 &lt;code&gt;v&lt;/code&gt; 的16个低位位写入流中。</target>
        </trans-unit>
        <trans-unit id="46f7ffb3816bb380e3513417982c2f71b9fe2e32" translate="yes" xml:space="preserve">
          <source>Writes the 16 low-order bits of &lt;code&gt;v&lt;/code&gt; to the stream. The 16 high-order bits of &lt;code&gt;v&lt;/code&gt; are ignored. If the stream uses network byte order, the bytes written, in order, will be:</source>
          <target state="translated">将 &lt;code&gt;v&lt;/code&gt; 的16个低阶位写入流中。 &lt;code&gt;v&lt;/code&gt; 的16个高阶位被忽略。如果流使用网络字节顺序，则按顺序写入的字节将是：</target>
        </trans-unit>
        <trans-unit id="2285f29a0b24000b5b0b1f1f80d441c9b5148486" translate="yes" xml:space="preserve">
          <source>Writes the 32 bits of &lt;code&gt;v&lt;/code&gt; to the stream.</source>
          <target state="translated">将 &lt;code&gt;v&lt;/code&gt; 的32位写入流中。</target>
        </trans-unit>
        <trans-unit id="1695f3633211b76ec7f857f5454ea6a247025c8d" translate="yes" xml:space="preserve">
          <source>Writes the 32 bits of &lt;code&gt;v&lt;/code&gt; to the stream. If the stream uses network byte order, the bytes written, in order, will be:</source>
          <target state="translated">将 &lt;code&gt;v&lt;/code&gt; 的32位写入流中。如果流使用网络字节顺序，则按顺序写入的字节将是：</target>
        </trans-unit>
        <trans-unit id="12bdda69ade361eb7dbeae8003665e8a3eff12fb" translate="yes" xml:space="preserve">
          <source>Writes the 64 bits of &lt;code&gt;v&lt;/code&gt; to the stream.</source>
          <target state="translated">将 &lt;code&gt;v&lt;/code&gt; 的64位写入流中。</target>
        </trans-unit>
        <trans-unit id="1ad02fac0fe368119ddb18c395ff897d2d58089f" translate="yes" xml:space="preserve">
          <source>Writes the 64 bits of &lt;code&gt;v&lt;/code&gt; to the stream. If the stream uses network byte order, the bytes written, in order, will be:</source>
          <target state="translated">将 &lt;code&gt;v&lt;/code&gt; 的64位写入流中。如果流使用网络字节顺序，则按顺序写入的字节将是：</target>
        </trans-unit>
        <trans-unit id="d1e7aaab26c2b74832628edc0bc5c54f2c2b6383" translate="yes" xml:space="preserve">
          <source>Writes the 8 low-order bits of &lt;code&gt;v&lt;/code&gt; to the stream.</source>
          <target state="translated">将 &lt;code&gt;v&lt;/code&gt; 的低8位写入流中。</target>
        </trans-unit>
        <trans-unit id="1804455e9da4aaf420e36d129972367ec781e360" translate="yes" xml:space="preserve">
          <source>Writes the 8 low-order bits of &lt;code&gt;v&lt;/code&gt; to the stream. The 24 high-order bits of &lt;code&gt;v&lt;/code&gt; are ignored. (This means that &lt;code&gt;writeByte&lt;/code&gt; does exactly the same thing as &lt;code&gt;write&lt;/code&gt; for an integer argument.)</source>
          <target state="translated">将 &lt;code&gt;v&lt;/code&gt; 的低8位写入流中。 &lt;code&gt;v&lt;/code&gt; 的24个高阶位被忽略。（这意味着 &lt;code&gt;writeByte&lt;/code&gt; 与 &lt;code&gt;write&lt;/code&gt; 整数参数完全一样。）</target>
        </trans-unit>
        <trans-unit id="19e78fdb1971c9362622f784b86e72a51fdd9069" translate="yes" xml:space="preserve">
          <source>Writes the Manifest to the specified OutputStream.</source>
          <target state="translated">将Manifest写入指定的OutputStream。</target>
        </trans-unit>
        <trans-unit id="89cd571628123202a3823b52aeb30a696038cb43" translate="yes" xml:space="preserve">
          <source>Writes the Manifest to the specified OutputStream. Attributes.Name.MANIFEST_VERSION must be set in MainAttributes prior to invoking this method.</source>
          <target state="translated">将Manifest写入指定的OutputStream。在调用本方法之前,必须在MainAttributes中设置Attributes.Name.MANIFEST_VERSION。</target>
        </trans-unit>
        <trans-unit id="56a6e43f8f49e535184e69201b1785713f290620" translate="yes" xml:space="preserve">
          <source>Writes the changes in this &lt;code&gt;RowSetWriter&lt;/code&gt; object's rowset back to the data source from which it got its data.</source>
          <target state="translated">将此 &lt;code&gt;RowSetWriter&lt;/code&gt; 对象的行集中的更改写回到从其获取数据的数据源。</target>
        </trans-unit>
        <trans-unit id="ed35cca7d83e05daee22aa9a3f126d06b836d5a5" translate="yes" xml:space="preserve">
          <source>Writes the complete contents of the specified byte array to this &lt;code&gt;ByteArrayOutputStream&lt;/code&gt;.</source>
          <target state="translated">将指定字节数组的完整内容写入此 &lt;code&gt;ByteArrayOutputStream&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="c9e9501319b3d34bbec70c3333e794fa37a6d454" translate="yes" xml:space="preserve">
          <source>Writes the complete contents of this &lt;code&gt;ByteArrayOutputStream&lt;/code&gt; to the specified output stream argument, as if by calling the output stream's write method using &lt;code&gt;out.write(buf, 0, count)&lt;/code&gt;.</source>
          <target state="translated">将此 &lt;code&gt;ByteArrayOutputStream&lt;/code&gt; 的完整内容写入指定的输出流参数，就像使用 &lt;code&gt;out.write(buf, 0, count)&lt;/code&gt; 调用输出流的write方法一样。</target>
        </trans-unit>
        <trans-unit id="c24338bb5d1fb51bd9cbd3d86a25bb4355deba24" translate="yes" xml:space="preserve">
          <source>Writes the complete contents of this byte array output stream to the specified output stream argument, as if by calling the output stream's write method using &lt;code&gt;out.write(buf, 0, count)&lt;/code&gt;.</source>
          <target state="translated">将此字节数组输出流的完整内容写入指定的输出流参数，就像通过使用 &lt;code&gt;out.write(buf, 0, count)&lt;/code&gt; 调用输出流的write方法一样。</target>
        </trans-unit>
        <trans-unit id="ff4dae149c1ce83c7a6b820b14212cbe3bbf93f1" translate="yes" xml:space="preserve">
          <source>Writes the contents of the buffer to another character stream.</source>
          <target state="translated">将缓冲区的内容写入另一个字符流。</target>
        </trans-unit>
        <trans-unit id="625df89357bdd2344ade2b496e40fd50120f1e3a" translate="yes" xml:space="preserve">
          <source>Writes the data, properties, and metadata for this &lt;code&gt;WebRowSet&lt;/code&gt; object to the given &lt;code&gt;OutputStream&lt;/code&gt; object in XML format.</source>
          <target state="translated">将此 &lt;code&gt;WebRowSet&lt;/code&gt; 对象的数据，属性和元数据以XML格式写入给定的 &lt;code&gt;OutputStream&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="5c40001a80f650ccea2798916fa3dc59bfca35b4" translate="yes" xml:space="preserve">
          <source>Writes the data, properties, and metadata for this &lt;code&gt;WebRowSet&lt;/code&gt; object to the given &lt;code&gt;Writer&lt;/code&gt; object in XML format.</source>
          <target state="translated">将此 &lt;code&gt;WebRowSet&lt;/code&gt; 对象的数据，属性和元数据以XML格式 &lt;code&gt;Writer&lt;/code&gt; 给定的Writer对象。</target>
        </trans-unit>
        <trans-unit id="def01038d2b375e9be7d7c972c662a60bf85f6ed" translate="yes" xml:space="preserve">
          <source>Writes the default namespace to the stream</source>
          <target state="translated">将默认的命名空间写入流</target>
        </trans-unit>
        <trans-unit id="8b1da37e0b3c109b19027e60ce196dfcfe9d6bb8" translate="yes" xml:space="preserve">
          <source>Writes the field values, time stamp, and event duration to the Flight Recorder system.</source>
          <target state="translated">将字段值、时间戳和事件持续时间写入飞行记录仪系统。</target>
        </trans-unit>
        <trans-unit id="f79062814f665166b5bf8b4fbf187fc654014a55" translate="yes" xml:space="preserve">
          <source>Writes the given &lt;code&gt;WebRowSet&lt;/code&gt; object to the specified &lt;code&gt;java.io.Writer&lt;/code&gt; output stream as an XML document.</source>
          <target state="translated">将给定的 &lt;code&gt;WebRowSet&lt;/code&gt; 对象作为XML文档写入指定的 &lt;code&gt;java.io.Writer&lt;/code&gt; 输出流。</target>
        </trans-unit>
        <trans-unit id="c53959f7ef1e7a69156e9085d95064c77f4d010b" translate="yes" xml:space="preserve">
          <source>Writes the given &lt;code&gt;WebRowSet&lt;/code&gt; object to the specified &lt;code&gt;java.io.Writer&lt;/code&gt; output stream as an XML document. This document includes the rowset's data, metadata, and properties plus the appropriate XML tags.</source>
          <target state="translated">将给定的 &lt;code&gt;WebRowSet&lt;/code&gt; 对象作为XML文档写入指定的 &lt;code&gt;java.io.Writer&lt;/code&gt; 输出流。该文档包括行集的数据，元数据和属性，以及适当的XML标记。</target>
        </trans-unit>
        <trans-unit id="2fc66b6ae43cb5f22e10fbdc9f01c80ebb40e0aa" translate="yes" xml:space="preserve">
          <source>Writes the given Java &lt;code&gt;String&lt;/code&gt; to the &lt;code&gt;CLOB&lt;/code&gt; value that this &lt;code&gt;Clob&lt;/code&gt; object designates at the position &lt;code&gt;pos&lt;/code&gt;.</source>
          <target state="translated">将给定的Java &lt;code&gt;String&lt;/code&gt; 写入此 &lt;code&gt;Clob&lt;/code&gt; 对象在位置 &lt;code&gt;pos&lt;/code&gt; 处指定的 &lt;code&gt;CLOB&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="7d16b2514bafe679b47004e8cd89d3c68d61aebc" translate="yes" xml:space="preserve">
          <source>Writes the given Java &lt;code&gt;String&lt;/code&gt; to the &lt;code&gt;CLOB&lt;/code&gt; value that this &lt;code&gt;Clob&lt;/code&gt; object designates at the position &lt;code&gt;pos&lt;/code&gt;. The string will overwrite the existing characters in the &lt;code&gt;Clob&lt;/code&gt; object starting at the position &lt;code&gt;pos&lt;/code&gt;. If the end of the &lt;code&gt;Clob&lt;/code&gt; value is reached while writing the given string, then the length of the &lt;code&gt;Clob&lt;/code&gt; value will be increased to accommodate the extra characters.</source>
          <target state="translated">将给定的Java &lt;code&gt;String&lt;/code&gt; 写入此 &lt;code&gt;Clob&lt;/code&gt; 对象在位置 &lt;code&gt;pos&lt;/code&gt; 处指定的 &lt;code&gt;CLOB&lt;/code&gt; 值。该字符串将从位置 &lt;code&gt;pos&lt;/code&gt; 开始覆盖 &lt;code&gt;Clob&lt;/code&gt; 对象中的现有字符。如果年底 &lt;code&gt;Clob&lt;/code&gt; 一边写定的字符串是否达到了值，则长度 &lt;code&gt;Clob&lt;/code&gt; 值将增加以容纳额外的字符。</target>
        </trans-unit>
        <trans-unit id="57a742d5137a159149b8c8b646d025117a64f0e3" translate="yes" xml:space="preserve">
          <source>Writes the given Java &lt;code&gt;String&lt;/code&gt; to the &lt;code&gt;CLOB&lt;/code&gt; value that this &lt;code&gt;SerialClob&lt;/code&gt; object represents, at the position &lt;code&gt;pos&lt;/code&gt;.</source>
          <target state="translated">将给定的Java &lt;code&gt;String&lt;/code&gt; 写入此 &lt;code&gt;SerialClob&lt;/code&gt; 对象表示的 &lt;code&gt;CLOB&lt;/code&gt; 值（位置 &lt;code&gt;pos&lt;/code&gt; 处)。</target>
        </trans-unit>
        <trans-unit id="4a11fbed6e0f0c000e7ac73c751f5706337ffea4" translate="yes" xml:space="preserve">
          <source>Writes the given array of bytes to the &lt;code&gt;BLOB&lt;/code&gt; value that this &lt;code&gt;Blob&lt;/code&gt; object represents, starting at position &lt;code&gt;pos&lt;/code&gt;, and returns the number of bytes written.</source>
          <target state="translated">从位置 &lt;code&gt;pos&lt;/code&gt; 开始，将给定的字节数组写入此 &lt;code&gt;Blob&lt;/code&gt; 对象表示的 &lt;code&gt;BLOB&lt;/code&gt; 值，并返回写入的字节数。</target>
        </trans-unit>
        <trans-unit id="de7a837912d2ada585ea670a18a22c40ee3566d8" translate="yes" xml:space="preserve">
          <source>Writes the given array of bytes to the &lt;code&gt;BLOB&lt;/code&gt; value that this &lt;code&gt;Blob&lt;/code&gt; object represents, starting at position &lt;code&gt;pos&lt;/code&gt;, and returns the number of bytes written. The array of bytes will overwrite the existing bytes in the &lt;code&gt;Blob&lt;/code&gt; object starting at the position &lt;code&gt;pos&lt;/code&gt;. If the end of the &lt;code&gt;Blob&lt;/code&gt; value is reached while writing the array of bytes, then the length of the &lt;code&gt;Blob&lt;/code&gt; value will be increased to accommodate the extra bytes.</source>
          <target state="translated">从位置 &lt;code&gt;pos&lt;/code&gt; 开始，将给定的字节数组写入此 &lt;code&gt;Blob&lt;/code&gt; 对象表示的 &lt;code&gt;BLOB&lt;/code&gt; 值，并返回写入的字节数。字节数组将覆盖 &lt;code&gt;Blob&lt;/code&gt; 对象中从位置 &lt;code&gt;pos&lt;/code&gt; 开始的现有字节。如果的端 &lt;code&gt;Blob&lt;/code&gt; 而写入的字节的阵列达到值，则长度 &lt;code&gt;Blob&lt;/code&gt; 值将增加以容纳额外的字节。</target>
        </trans-unit>
        <trans-unit id="d1d0f592eeac5c796ea935b5d994096745d157f7" translate="yes" xml:space="preserve">
          <source>Writes the given byte into this buffer at the current position, and then increments the position.</source>
          <target state="translated">在当前位置将给定的字节写入缓冲区,然后递增位置。</target>
        </trans-unit>
        <trans-unit id="dd7b88652ec60af74a840f947c7b86d252782b34" translate="yes" xml:space="preserve">
          <source>Writes the given byte into this buffer at the given index.</source>
          <target state="translated">将给定的字节写入给定索引的缓冲区。</target>
        </trans-unit>
        <trans-unit id="6a61149f23f16decaac4eae92463c7ef12672ae5" translate="yes" xml:space="preserve">
          <source>Writes the given char into this buffer at the current position, and then increments the position.</source>
          <target state="translated">在当前位置将给定的字符写入缓冲区,然后递增位置。</target>
        </trans-unit>
        <trans-unit id="4f770fa38d98aec466fccb25555cc99c0b9ddbaf" translate="yes" xml:space="preserve">
          <source>Writes the given char into this buffer at the given index.</source>
          <target state="translated">将给定的char写入给定索引的缓冲区。</target>
        </trans-unit>
        <trans-unit id="f2d1506e6de2b9485d5e760430b8d8a6e992441f" translate="yes" xml:space="preserve">
          <source>Writes the given double into this buffer at the current position, and then increments the position.</source>
          <target state="translated">将给定的双数写入当前位置的缓冲区,然后递增位置。</target>
        </trans-unit>
        <trans-unit id="68ee8a87d76de1cd2a770b8396c4ab7cf9175f3b" translate="yes" xml:space="preserve">
          <source>Writes the given double into this buffer at the given index.</source>
          <target state="translated">将给定的双数写入给定索引的缓冲区。</target>
        </trans-unit>
        <trans-unit id="370abd73ada65b5904921d209602fcc69611ebec" translate="yes" xml:space="preserve">
          <source>Writes the given float into this buffer at the current position, and then increments the position.</source>
          <target state="translated">在当前位置将给定的float写入缓冲区,然后递增该位置。</target>
        </trans-unit>
        <trans-unit id="07eaa541d5c0633efea85fbc2ae9bba6c20a12a6" translate="yes" xml:space="preserve">
          <source>Writes the given float into this buffer at the given index.</source>
          <target state="translated">在给定的索引处将给定的float写入这个缓冲区。</target>
        </trans-unit>
        <trans-unit id="19e622dee348636b8ed78c68d535a1074887c524" translate="yes" xml:space="preserve">
          <source>Writes the given int into this buffer at the current position, and then increments the position.</source>
          <target state="translated">在当前位置将给定的int写入缓冲区,然后递增位置。</target>
        </trans-unit>
        <trans-unit id="b845c5f27efaa6c518dc0d967f43b3a146bebef9" translate="yes" xml:space="preserve">
          <source>Writes the given int into this buffer at the given index.</source>
          <target state="translated">在给定的索引处将给定的int写入这个缓冲区。</target>
        </trans-unit>
        <trans-unit id="712fe7e7e38b5fd24f11498bd179d0ff8bdc747b" translate="yes" xml:space="preserve">
          <source>Writes the given long into this buffer at the current position, and then increments the position.</source>
          <target state="translated">在当前位置将给定的多头写入缓冲区,然后递增该位置。</target>
        </trans-unit>
        <trans-unit id="fabaa8aff4aa813be322673a9965363c8f76cba7" translate="yes" xml:space="preserve">
          <source>Writes the given long into this buffer at the given index.</source>
          <target state="translated">将给定的long写入给定索引的缓冲区。</target>
        </trans-unit>
        <trans-unit id="9495203bcfa27d90ba40a65bedf36e96cec6cc11" translate="yes" xml:space="preserve">
          <source>Writes the given short into this buffer at the current position, and then increments the position.</source>
          <target state="translated">在当前位置将给定的空头写入该缓冲区,然后增加该位置。</target>
        </trans-unit>
        <trans-unit id="10ed6376a80a004d623217c1faeb7c99a1dda8a2" translate="yes" xml:space="preserve">
          <source>Writes the given short into this buffer at the given index.</source>
          <target state="translated">在给定的索引处将给定的短信息写入缓冲区。</target>
        </trans-unit>
        <trans-unit id="0d58e1f54ac285ebe48be0cf8a78bf6938ac3d49" translate="yes" xml:space="preserve">
          <source>Writes the line separator.</source>
          <target state="translated">编写分线器。</target>
        </trans-unit>
        <trans-unit id="0f1871aeccc02c9dbbfa7844c873c3486c323372" translate="yes" xml:space="preserve">
          <source>Writes the line separator. This invokes &lt;code&gt;output&lt;/code&gt; directly as well as setting the &lt;code&gt;lineLength&lt;/code&gt; to 0.</source>
          <target state="translated">写入行分隔符。这将直接调用 &lt;code&gt;output&lt;/code&gt; ，并将 &lt;code&gt;lineLength&lt;/code&gt; 设置为0。</target>
        </trans-unit>
        <trans-unit id="a9b3e59953847a43bcec280307207b82f61a7fe6" translate="yes" xml:space="preserve">
          <source>Writes the line separator. This is overriden to make sure we don't replace the newline content in case it is outside normal ascii.</source>
          <target state="translated">编写行的分隔符。这是被覆盖的,以确保我们不会替换新行的内容,如果它是在正常的ascii之外。</target>
        </trans-unit>
        <trans-unit id="24d0b6fd544532d6da39d30f6b008384dfc920fd" translate="yes" xml:space="preserve">
          <source>Writes the next attribute to the stream as a &lt;code&gt;String&lt;/code&gt; in the Java programming language.</source>
          <target state="translated">使用Java编程语言，将下一个属性作为 &lt;code&gt;String&lt;/code&gt; 写入流中。</target>
        </trans-unit>
        <trans-unit id="340f6324944e39f9ec811cc3204c298ba8e22898" translate="yes" xml:space="preserve">
          <source>Writes the next attribute to the stream as a &lt;code&gt;String&lt;/code&gt; in the Java programming language. The driver converts this to a SQL &lt;code&gt;NCHAR&lt;/code&gt; or &lt;code&gt;NVARCHAR&lt;/code&gt; or &lt;code&gt;LONGNVARCHAR&lt;/code&gt; value (depending on the argument's size relative to the driver's limits on &lt;code&gt;NVARCHAR&lt;/code&gt; values) when it sends it to the stream.</source>
          <target state="translated">使用Java编程语言，将下一个属性作为 &lt;code&gt;String&lt;/code&gt; 写入流中。驱动程序将其发送到流时，将其转换为SQL &lt;code&gt;NCHAR&lt;/code&gt; 或 &lt;code&gt;NVARCHAR&lt;/code&gt; 或 &lt;code&gt;LONGNVARCHAR&lt;/code&gt; 值（取决于参数的大小，相对于驱动程序对 &lt;code&gt;NVARCHAR&lt;/code&gt; 值的限制）。</target>
        </trans-unit>
        <trans-unit id="2d1f3589491c7e59f4409b383151d9dbaea50dfd" translate="yes" xml:space="preserve">
          <source>Writes the next attribute to the stream as a Java boolean.</source>
          <target state="translated">将下一个属性作为Java布尔值写入流。</target>
        </trans-unit>
        <trans-unit id="be7661a9ba802f0f8404dcff2f25d0e79592926c" translate="yes" xml:space="preserve">
          <source>Writes the next attribute to the stream as a Java boolean. Writes the next attribute to the stream as a &lt;code&gt;String&lt;/code&gt; in the Java programming language.</source>
          <target state="translated">将下一个属性作为Java布尔值写入流中。使用Java编程语言，将下一个属性作为 &lt;code&gt;String&lt;/code&gt; 写入流中。</target>
        </trans-unit>
        <trans-unit id="ac60e91c51e05c39515073eaf54895db2613b6e4" translate="yes" xml:space="preserve">
          <source>Writes the next attribute to the stream as a Java byte.</source>
          <target state="translated">将下一个属性作为Java字节写入流。</target>
        </trans-unit>
        <trans-unit id="0a639b1d5b4b69d9459220fd2461435c95a20fc2" translate="yes" xml:space="preserve">
          <source>Writes the next attribute to the stream as a Java byte. Writes the next attribute to the stream as a &lt;code&gt;String&lt;/code&gt; in the Java programming language.</source>
          <target state="translated">将下一个属性作为Java字节写入流中。使用Java编程语言，将下一个属性作为 &lt;code&gt;String&lt;/code&gt; 写入流中。</target>
        </trans-unit>
        <trans-unit id="9593bde4bf357c583e7328e5ea9018696aabeee7" translate="yes" xml:space="preserve">
          <source>Writes the next attribute to the stream as a Java double.</source>
          <target state="translated">将下一个属性作为Java双倍写入流。</target>
        </trans-unit>
        <trans-unit id="0f6bfb271a92d8c8e21181c42abe87ecff6afb06" translate="yes" xml:space="preserve">
          <source>Writes the next attribute to the stream as a Java double. Writes the next attribute to the stream as a &lt;code&gt;String&lt;/code&gt; in the Java programming language.</source>
          <target state="translated">将下一个属性作为Java double写入流中。使用Java编程语言，将下一个属性作为 &lt;code&gt;String&lt;/code&gt; 写入流中。</target>
        </trans-unit>
        <trans-unit id="da9b1e5fa972f78972b24c6e7825131d395a8ccc" translate="yes" xml:space="preserve">
          <source>Writes the next attribute to the stream as a Java float.</source>
          <target state="translated">将下一个属性以Java float的形式写入流中。</target>
        </trans-unit>
        <trans-unit id="eb4c3c391c1b9901ee09ed26e81a11b12b2b70d4" translate="yes" xml:space="preserve">
          <source>Writes the next attribute to the stream as a Java float. Writes the next attribute to the stream as a &lt;code&gt;String&lt;/code&gt; in the Java programming language.</source>
          <target state="translated">将下一个属性作为Java浮点数写入流中。使用Java编程语言，将下一个属性作为 &lt;code&gt;String&lt;/code&gt; 写入流中。</target>
        </trans-unit>
        <trans-unit id="a8dec4054e8f37abc1c891b14916680cd86d65a1" translate="yes" xml:space="preserve">
          <source>Writes the next attribute to the stream as a Java int.</source>
          <target state="translated">将下一个属性以Java int的形式写入流中。</target>
        </trans-unit>
        <trans-unit id="ab6ffa745bb17cb2125b60fa279c0798e5670e2f" translate="yes" xml:space="preserve">
          <source>Writes the next attribute to the stream as a Java int. Writes the next attribute to the stream as a &lt;code&gt;String&lt;/code&gt; in the Java programming language.</source>
          <target state="translated">将下一个属性作为Java int写入流中。使用Java编程语言，将下一个属性作为 &lt;code&gt;String&lt;/code&gt; 写入流中。</target>
        </trans-unit>
        <trans-unit id="47790b3016da43b530a0ad20df6ae1300b2e0e29" translate="yes" xml:space="preserve">
          <source>Writes the next attribute to the stream as a Java long.</source>
          <target state="translated">将下一个属性以Java长写到流中。</target>
        </trans-unit>
        <trans-unit id="1612f1a47c6ca7a2deed650adf88239bc52b77a1" translate="yes" xml:space="preserve">
          <source>Writes the next attribute to the stream as a Java long. Writes the next attribute to the stream as a &lt;code&gt;String&lt;/code&gt; in the Java programming language.</source>
          <target state="translated">将下一个属性作为Java long写入流。使用Java编程语言，将下一个属性作为 &lt;code&gt;String&lt;/code&gt; 写入流中。</target>
        </trans-unit>
        <trans-unit id="7f9e25e8282f094090e93103d929b57bc1dae11f" translate="yes" xml:space="preserve">
          <source>Writes the next attribute to the stream as a Java short.</source>
          <target state="translated">将下一个属性作为Java短信息写入流中。</target>
        </trans-unit>
        <trans-unit id="2d7c5fcc6f952395e88a8fee07a40dc57357b4ce" translate="yes" xml:space="preserve">
          <source>Writes the next attribute to the stream as a Java short. Writes the next attribute to the stream as a &lt;code&gt;String&lt;/code&gt; in the Java programming language.</source>
          <target state="translated">将下一个属性作为Java short写入流中。使用Java编程语言，将下一个属性作为 &lt;code&gt;String&lt;/code&gt; 写入流中。</target>
        </trans-unit>
        <trans-unit id="ae795241e4d0dbed163c78ace2898ad64a209d95" translate="yes" xml:space="preserve">
          <source>Writes the next attribute to the stream as a java.math.BigDecimal object.</source>
          <target state="translated">将下一个属性以java.math.BigDecimal对象的形式写入流。</target>
        </trans-unit>
        <trans-unit id="966a161abb638bc66e062577c6601a2f0243654b" translate="yes" xml:space="preserve">
          <source>Writes the next attribute to the stream as a java.math.BigDecimal object. Writes the next attribute to the stream as a &lt;code&gt;String&lt;/code&gt; in the Java programming language.</source>
          <target state="translated">将下一个属性作为java.math.BigDecimal对象写入流中。使用Java编程语言，将下一个属性作为 &lt;code&gt;String&lt;/code&gt; 写入流中。</target>
        </trans-unit>
        <trans-unit id="84b6f38a64127bc13fe0460d5ba6bb6f767b58c8" translate="yes" xml:space="preserve">
          <source>Writes the next attribute to the stream as a java.sql.Date object.</source>
          <target state="translated">将下一个属性作为java.sql.Date对象写入流。</target>
        </trans-unit>
        <trans-unit id="94c8593503581612e5c62a36c73e3be22c143d60" translate="yes" xml:space="preserve">
          <source>Writes the next attribute to the stream as a java.sql.Date object. Writes the next attribute to the stream as a &lt;code&gt;java.sql.Date&lt;/code&gt; object in the Java programming language.</source>
          <target state="translated">将下一个属性作为java.sql.Date对象写入流中。将下一个属性作为Java编程语言中的 &lt;code&gt;java.sql.Date&lt;/code&gt; 对象写入流中。</target>
        </trans-unit>
        <trans-unit id="fc86fddad392435fe68b386370732f81602fca4f" translate="yes" xml:space="preserve">
          <source>Writes the next attribute to the stream as a java.sql.Time object.</source>
          <target state="translated">将下一个属性以java.sql.Time对象的形式写入流。</target>
        </trans-unit>
        <trans-unit id="65f27154a6884b242089f59999a75bc40f12eefa" translate="yes" xml:space="preserve">
          <source>Writes the next attribute to the stream as a java.sql.Time object. Writes the next attribute to the stream as a &lt;code&gt;java.sql.Date&lt;/code&gt; object in the Java programming language.</source>
          <target state="translated">将下一个属性作为java.sql.Time对象写入流中。将下一个属性作为Java编程语言中的 &lt;code&gt;java.sql.Date&lt;/code&gt; 对象写入流中。</target>
        </trans-unit>
        <trans-unit id="b22105b1215f732b1187e26860f8ed1a36976e32" translate="yes" xml:space="preserve">
          <source>Writes the next attribute to the stream as a java.sql.Timestamp object.</source>
          <target state="translated">将下一个属性作为java.sql.Timestamp对象写入流。</target>
        </trans-unit>
        <trans-unit id="5e422e5fae800f499fb8e1d4969f89024012858c" translate="yes" xml:space="preserve">
          <source>Writes the next attribute to the stream as a java.sql.Timestamp object. Writes the next attribute to the stream as a &lt;code&gt;java.sql.Date&lt;/code&gt; object in the Java programming language.</source>
          <target state="translated">将下一个属性作为java.sql.Timestamp对象写入流中。将下一个属性作为Java编程语言中的 &lt;code&gt;java.sql.Date&lt;/code&gt; 对象写入流中。</target>
        </trans-unit>
        <trans-unit id="cf6ba5d83a2992ff0d3a302518dd1dd97f407273" translate="yes" xml:space="preserve">
          <source>Writes the next attribute to the stream as a stream of ASCII characters.</source>
          <target state="translated">将下一个属性以ASCII字符流的形式写入流中。</target>
        </trans-unit>
        <trans-unit id="a38ae5c63be734084b684282016282bc8c0a5985" translate="yes" xml:space="preserve">
          <source>Writes the next attribute to the stream as a stream of Unicode characters.</source>
          <target state="translated">将下一个属性以Unicode字符流的形式写入流。</target>
        </trans-unit>
        <trans-unit id="0970c547d7936b50ee00426701f83ff57fde3cfa" translate="yes" xml:space="preserve">
          <source>Writes the next attribute to the stream as a stream of uninterpreted bytes.</source>
          <target state="translated">将下一个属性作为未解释的字节流写入流。</target>
        </trans-unit>
        <trans-unit id="7f36f131f8ab34500af50462c7eadd92c2b76022" translate="yes" xml:space="preserve">
          <source>Writes the next attribute to the stream as an array of bytes.</source>
          <target state="translated">将下一个属性作为一个字节数组写入流。</target>
        </trans-unit>
        <trans-unit id="7e61a033c461fb7dcfbfdeeada45e9ae7b6869b0" translate="yes" xml:space="preserve">
          <source>Writes the next attribute to the stream as an array of bytes. Writes the next attribute to the stream as a &lt;code&gt;String&lt;/code&gt; in the Java programming language.</source>
          <target state="translated">将下一个属性作为字节数组写入流中。使用Java编程语言，将下一个属性作为 &lt;code&gt;String&lt;/code&gt; 写入流中。</target>
        </trans-unit>
        <trans-unit id="8d975120559c26edf427658d3a3c3d0ebc4d2550" translate="yes" xml:space="preserve">
          <source>Writes the specified &lt;code&gt;byte&lt;/code&gt; to the piped output stream.</source>
          <target state="translated">将指定的 &lt;code&gt;byte&lt;/code&gt; 写入管道输出流。</target>
        </trans-unit>
        <trans-unit id="5f14d6eee88508e464e25626a9203ab46c7ae8c1" translate="yes" xml:space="preserve">
          <source>Writes the specified &lt;code&gt;byte&lt;/code&gt; to this output stream.</source>
          <target state="translated">将指定的 &lt;code&gt;byte&lt;/code&gt; 写入此输出流。</target>
        </trans-unit>
        <trans-unit id="2ded1a3671d9de0d3963eef8e96f5518c65ec142" translate="yes" xml:space="preserve">
          <source>Writes the specified &lt;code&gt;char&lt;/code&gt; to the piped output stream.</source>
          <target state="translated">将指定的 &lt;code&gt;char&lt;/code&gt; 写入管道输出流。</target>
        </trans-unit>
        <trans-unit id="fc8ccadb9cba29bd2eb5a6b400b75de445d2099d" translate="yes" xml:space="preserve">
          <source>Writes the specified &lt;code&gt;char&lt;/code&gt; to the piped output stream. If a thread was reading data characters from the connected piped input stream, but the thread is no longer alive, then an &lt;code&gt;IOException&lt;/code&gt; is thrown.</source>
          <target state="translated">将指定的 &lt;code&gt;char&lt;/code&gt; 写入管道输出流。如果线程正在从连接的管道输入流中读取数据字符，但是该线程不再活动，则将引发 &lt;code&gt;IOException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1ab111c3fb2ece34959961ef2a47f24f69db4b45" translate="yes" xml:space="preserve">
          <source>Writes the specified byte (the low eight bits of the argument &lt;code&gt;b&lt;/code&gt;) to the underlying output stream.</source>
          <target state="translated">将指定的字节（参数 &lt;code&gt;b&lt;/code&gt; 的低八位）写入基础输出流。</target>
        </trans-unit>
        <trans-unit id="6a361965d78596b1ec164e036366e12d2c75bb2c" translate="yes" xml:space="preserve">
          <source>Writes the specified byte (the low eight bits of the argument &lt;code&gt;b&lt;/code&gt;) to the underlying output stream. If no exception is thrown, the counter &lt;code&gt;written&lt;/code&gt; is incremented by &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">将指定的字节（参数 &lt;code&gt;b&lt;/code&gt; 的低八位）写入基础输出流。如果未引发异常，则 &lt;code&gt;written&lt;/code&gt; 的计数器将增加 &lt;code&gt;1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f395fe152479fa6fe3982d50f757a564445e03a3" translate="yes" xml:space="preserve">
          <source>Writes the specified byte to this &lt;code&gt;ByteArrayOutputStream&lt;/code&gt;.</source>
          <target state="translated">将指定的字节写入此 &lt;code&gt;ByteArrayOutputStream&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="112760f7a5bd1088e95174f743f77e6540d54a2b" translate="yes" xml:space="preserve">
          <source>Writes the specified byte to this buffered output stream.</source>
          <target state="translated">将指定的字节写入这个缓冲的输出流。</target>
        </trans-unit>
        <trans-unit id="7609567d3c31861f0c015f22b9e866c66abef6ef" translate="yes" xml:space="preserve">
          <source>Writes the specified byte to this byte array output stream.</source>
          <target state="translated">将指定的字节写入这个字节数组输出流。</target>
        </trans-unit>
        <trans-unit id="f7ca3263ecdf5bfa2fcb28af4f0f50c9aa5238d5" translate="yes" xml:space="preserve">
          <source>Writes the specified byte to this file output stream.</source>
          <target state="translated">将指定的字节写入这个文件输出流。</target>
        </trans-unit>
        <trans-unit id="2b4802f7b977b1bf85147c28f9685965b5454afa" translate="yes" xml:space="preserve">
          <source>Writes the specified byte to this file output stream. Implements the &lt;code&gt;write&lt;/code&gt; method of &lt;code&gt;OutputStream&lt;/code&gt;.</source>
          <target state="translated">将指定的字节写入此文件输出流。实现 &lt;code&gt;OutputStream&lt;/code&gt; 的 &lt;code&gt;write&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="aef8e765886b82ee496b736f4dd9d04b5b58c2cb" translate="yes" xml:space="preserve">
          <source>Writes the specified byte to this file.</source>
          <target state="translated">将指定的字节写入该文件。</target>
        </trans-unit>
        <trans-unit id="b729d9dffaa8a1f4157fef1e1ce618b624909b04" translate="yes" xml:space="preserve">
          <source>Writes the specified byte to this file. The write starts at the current file pointer.</source>
          <target state="translated">将指定的字节写入该文件。写入从当前文件指针开始。</target>
        </trans-unit>
        <trans-unit id="ba3a4edd85917756c50fa03243093621eed1d538" translate="yes" xml:space="preserve">
          <source>Writes the specified byte to this output stream.</source>
          <target state="translated">将指定的字节写入这个输出流。</target>
        </trans-unit>
        <trans-unit id="b599b1fa291253a78c3e88600501e421edb1c042" translate="yes" xml:space="preserve">
          <source>Writes the specified byte to this output stream. The general contract for &lt;code&gt;write&lt;/code&gt; is that one byte is written to the output stream. The byte to be written is the eight low-order bits of the argument &lt;code&gt;b&lt;/code&gt;. The 24 high-order bits of &lt;code&gt;b&lt;/code&gt; are ignored.</source>
          <target state="translated">将指定的字节写入此输出流。 &lt;code&gt;write&lt;/code&gt; 的一般约定是将一个字节写入输出流。要写入的字节是参数 &lt;code&gt;b&lt;/code&gt; 的八个低阶位。 &lt;code&gt;b&lt;/code&gt; 的24个高阶位被忽略。</target>
        </trans-unit>
        <trans-unit id="8971c513647c69b909bf210695c94f545ca38243" translate="yes" xml:space="preserve">
          <source>Writes the specified byte to this stream.</source>
          <target state="translated">将指定的字节写入这个流。</target>
        </trans-unit>
        <trans-unit id="e958c00a95c755222bae929710882f0ef7598984" translate="yes" xml:space="preserve">
          <source>Writes the specified byte to this stream. If the byte is a newline and automatic flushing is enabled then the &lt;code&gt;flush&lt;/code&gt; method will be invoked.</source>
          <target state="translated">将指定的字节写入此流。如果字节是换行符并且启用了自动刷新，则将调用 &lt;code&gt;flush&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="b17cdee8b1cf493966a1e22479e14f7926cbdbfb" translate="yes" xml:space="preserve">
          <source>Writes the string to the file as a sequence of bytes.</source>
          <target state="translated">将字符串作为一个字节序列写入文件。</target>
        </trans-unit>
        <trans-unit id="8a7ff01c245c6e87c2ac4ef96cf3070915dfcaaf" translate="yes" xml:space="preserve">
          <source>Writes the string to the file as a sequence of bytes. Each character in the string is written out, in sequence, by discarding its high eight bits. The write starts at the current position of the file pointer.</source>
          <target state="translated">将字符串作为字节序列写入文件。字符串中的每一个字符都会按顺序写出,并丢弃其高八位。写入从文件指针的当前位置开始。</target>
        </trans-unit>
        <trans-unit id="d0a5af43cf06c929a83885e6406856a92aa5cc38" translate="yes" xml:space="preserve">
          <source>Writes the value of a user-defined attribute from a buffer.</source>
          <target state="translated">从缓冲区中写入一个用户定义的属性值。</target>
        </trans-unit>
        <trans-unit id="6de7b1d847ae56079e54f185e80246ad8ca6539e" translate="yes" xml:space="preserve">
          <source>Writes this object to the given SQL data stream, converting it back to its SQL value in the data source.</source>
          <target state="translated">将此对象写入给定的SQL数据流,将其转换回数据源中的SQL值。</target>
        </trans-unit>
        <trans-unit id="d10aa40878b44a62bd75f37a923af2794ac38513" translate="yes" xml:space="preserve">
          <source>Writes this object to the given SQL data stream, converting it back to its SQL value in the data source. The implementation of the method must follow this protocol:</source>
          <target state="translated">将此对象写入给定的SQL数据流,将其转换回数据源中的SQL值。该方法的实现必须遵循这个协议。</target>
        </trans-unit>
        <trans-unit id="207b013c329390f09844c66437576494a2852d98" translate="yes" xml:space="preserve">
          <source>Writes this property list (key and element pairs) in this &lt;code&gt;Properties&lt;/code&gt; table to the output character stream in a format suitable for using the &lt;a href=&quot;#load(java.io.Reader)&quot;&gt;&lt;code&gt;load(Reader)&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">以适合于使用&lt;a href=&quot;#load(java.io.Reader)&quot;&gt; &lt;code&gt;load(Reader)&lt;/code&gt; &lt;/a&gt;方法的格式，将此 &lt;code&gt;Properties&lt;/code&gt; 表中的此属性列表（键和元素对）写入输出字符流。</target>
        </trans-unit>
        <trans-unit id="51e35b34ff21aa3824ad435b3d42b717ac1044a7" translate="yes" xml:space="preserve">
          <source>Writes this property list (key and element pairs) in this &lt;code&gt;Properties&lt;/code&gt; table to the output character stream in a format suitable for using the &lt;a href=&quot;properties#load-java.io.Reader-&quot;&gt;&lt;code&gt;load(Reader)&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">以适合于使用&lt;a href=&quot;properties#load-java.io.Reader-&quot;&gt; &lt;code&gt;load(Reader)&lt;/code&gt; &lt;/a&gt;方法的格式，将此 &lt;code&gt;Properties&lt;/code&gt; 表中的此属性列表（键和元素对）写入输出字符流。</target>
        </trans-unit>
        <trans-unit id="e495c69a1b37a4ce090a0f61eb84303001e2f066" translate="yes" xml:space="preserve">
          <source>Writes this property list (key and element pairs) in this &lt;code&gt;Properties&lt;/code&gt; table to the output stream in a format suitable for loading into a &lt;code&gt;Properties&lt;/code&gt; table using the &lt;a href=&quot;#load(java.io.InputStream)&quot;&gt;&lt;code&gt;load(InputStream)&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">以适合于使用&lt;a href=&quot;#load(java.io.InputStream)&quot;&gt; &lt;code&gt;load(InputStream)&lt;/code&gt; &lt;/a&gt;方法加载到 &lt;code&gt;Properties&lt;/code&gt; 表中的格式，将此 &lt;code&gt;Properties&lt;/code&gt; 表中的此属性列表（键和元素对）写入输出流。</target>
        </trans-unit>
        <trans-unit id="51b4a7c90bf5626fec9c9f129aa1374ad6737d2c" translate="yes" xml:space="preserve">
          <source>Writes this property list (key and element pairs) in this &lt;code&gt;Properties&lt;/code&gt; table to the output stream in a format suitable for loading into a &lt;code&gt;Properties&lt;/code&gt; table using the &lt;a href=&quot;properties#load-java.io.InputStream-&quot;&gt;&lt;code&gt;load(InputStream)&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">以适合于使用&lt;a href=&quot;properties#load-java.io.InputStream-&quot;&gt; &lt;code&gt;load(InputStream)&lt;/code&gt; &lt;/a&gt;方法加载到 &lt;code&gt;Properties&lt;/code&gt; 表中的格式，将此 &lt;code&gt;Properties&lt;/code&gt; 表中的此属性列表（键和元素对）写入输出流。</target>
        </trans-unit>
        <trans-unit id="5d1e33d407f7be7c57261888fc679ef1b7584671" translate="yes" xml:space="preserve">
          <source>Writes to the output stream all the bytes in array &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">将数组 &lt;code&gt;b&lt;/code&gt; 中的所有字节写入输出流。</target>
        </trans-unit>
        <trans-unit id="f13a505bf6f1163d15ecf793f7208b545f326a38" translate="yes" xml:space="preserve">
          <source>Writes to the output stream all the bytes in array &lt;code&gt;b&lt;/code&gt;. If &lt;code&gt;b&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, a &lt;code&gt;NullPointerException&lt;/code&gt; is thrown. If &lt;code&gt;b.length&lt;/code&gt; is zero, then no bytes are written. Otherwise, the byte &lt;code&gt;b[0]&lt;/code&gt; is written first, then &lt;code&gt;b[1]&lt;/code&gt;, and so on; the last byte written is &lt;code&gt;b[b.length-1]&lt;/code&gt;.</source>
          <target state="translated">将数组 &lt;code&gt;b&lt;/code&gt; 中的所有字节写入输出流。如果 &lt;code&gt;b&lt;/code&gt; 为 &lt;code&gt;null&lt;/code&gt; ，则抛出 &lt;code&gt;NullPointerException&lt;/code&gt; 。如果 &lt;code&gt;b.length&lt;/code&gt; 为零，则不写入任何字节。否则，首先写入字节 &lt;code&gt;b[0]&lt;/code&gt; ，然后写入 &lt;code&gt;b[1]&lt;/code&gt; ，依此类推；最后写入的字节是 &lt;code&gt;b[b.length-1]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8514d628233a1a6ce1964bd5fc5b29aeaa728dad" translate="yes" xml:space="preserve">
          <source>Writes to the output stream the eight low- order bits of the argument &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">将参数 &lt;code&gt;v&lt;/code&gt; 的八个低阶位写入输出流。</target>
        </trans-unit>
        <trans-unit id="3634369cc0a70228335b7c0d1b3ea2b4c26bb08d" translate="yes" xml:space="preserve">
          <source>Writes to the output stream the eight low- order bits of the argument &lt;code&gt;v&lt;/code&gt;. The 24 high-order bits of &lt;code&gt;v&lt;/code&gt; are ignored. (This means that &lt;code&gt;writeByte&lt;/code&gt; does exactly the same thing as &lt;code&gt;write&lt;/code&gt; for an integer argument.) The byte written by this method may be read by the &lt;code&gt;readByte&lt;/code&gt; method of interface &lt;code&gt;DataInput&lt;/code&gt;, which will then return a &lt;code&gt;byte&lt;/code&gt; equal to &lt;code&gt;(byte)v&lt;/code&gt;.</source>
          <target state="translated">将参数 &lt;code&gt;v&lt;/code&gt; 的八个低阶位写入输出流。 &lt;code&gt;v&lt;/code&gt; 的24个高阶位被忽略。（这意味着 &lt;code&gt;writeByte&lt;/code&gt; 不完全一样的东西作为 &lt;code&gt;write&lt;/code&gt; 为一个整数参数。）此方法写入的字节可以由读取 &lt;code&gt;readByte&lt;/code&gt; 接口的方法 &lt;code&gt;DataInput&lt;/code&gt; ，然后将返回一个 &lt;code&gt;byte&lt;/code&gt; 等于 &lt;code&gt;(byte)v&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a0cf69d6c69bcf0faa8baab0cbc731ba085221ea" translate="yes" xml:space="preserve">
          <source>Writes to the output stream the eight low-order bits of the argument &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">将参数 &lt;code&gt;b&lt;/code&gt; 的八个低位写入输出流。</target>
        </trans-unit>
        <trans-unit id="94e71f080b530ff97228da57a38da0da555e275b" translate="yes" xml:space="preserve">
          <source>Writes to the output stream the eight low-order bits of the argument &lt;code&gt;b&lt;/code&gt;. The 24 high-order bits of &lt;code&gt;b&lt;/code&gt; are ignored.</source>
          <target state="translated">将参数 &lt;code&gt;b&lt;/code&gt; 的八个低位写入输出流。 &lt;code&gt;b&lt;/code&gt; 的24个高阶位被忽略。</target>
        </trans-unit>
        <trans-unit id="2c65468e87575c6e9fa9a826657a87e56933e290" translate="yes" xml:space="preserve">
          <source>Writes to the output stream the eight low-order bits of the argument &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">将参数 &lt;code&gt;v&lt;/code&gt; 的八个低位写入输出流。</target>
        </trans-unit>
        <trans-unit id="54f0fe973a856a893d528e0a57e3fd8c6d66f0de" translate="yes" xml:space="preserve">
          <source>Writes to the output stream the eight low-order bits of the argument &lt;code&gt;v&lt;/code&gt;. The 24 high-order bits of &lt;code&gt;v&lt;/code&gt; are ignored. (This means that &lt;code&gt;writeByte&lt;/code&gt; does exactly the same thing as &lt;code&gt;write&lt;/code&gt; for an integer argument.) The byte written by this method may be read by the &lt;code&gt;readByte&lt;/code&gt; method of interface &lt;code&gt;DataInput&lt;/code&gt;, which will then return a &lt;code&gt;byte&lt;/code&gt; equal to &lt;code&gt;(byte)v&lt;/code&gt;.</source>
          <target state="translated">将参数 &lt;code&gt;v&lt;/code&gt; 的八个低位写入输出流。 &lt;code&gt;v&lt;/code&gt; 的24个高阶位被忽略。（这意味着 &lt;code&gt;writeByte&lt;/code&gt; 不完全一样的东西作为 &lt;code&gt;write&lt;/code&gt; 为一个整数参数。）此方法写入的字节可以由读取 &lt;code&gt;readByte&lt;/code&gt; 接口的方法 &lt;code&gt;DataInput&lt;/code&gt; ，然后将返回一个 &lt;code&gt;byte&lt;/code&gt; 等于 &lt;code&gt;(byte)v&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bf32e90bca78d37e28d45fb95b94078d84950f46" translate="yes" xml:space="preserve">
          <source>Writes to the stream the data contained in the given &lt;code&gt;SQLData&lt;/code&gt; object.</source>
          <target state="translated">将包含在给定 &lt;code&gt;SQLData&lt;/code&gt; 对象中的数据写入流中。</target>
        </trans-unit>
        <trans-unit id="1839e48f3104f8ae0db661096310023645bcf7d2" translate="yes" xml:space="preserve">
          <source>Writes to the stream the data contained in the given &lt;code&gt;SQLData&lt;/code&gt; object. When the &lt;code&gt;SQLData&lt;/code&gt; object is &lt;code&gt;null&lt;/code&gt;, this method writes an SQL &lt;code&gt;NULL&lt;/code&gt; to the stream. Otherwise, it calls the &lt;code&gt;SQLData.writeSQL&lt;/code&gt; method of the given object, which writes the object's attributes to the stream.</source>
          <target state="translated">将包含在给定 &lt;code&gt;SQLData&lt;/code&gt; 对象中的数据写入流中。当 &lt;code&gt;SQLData&lt;/code&gt; 对象为 &lt;code&gt;null&lt;/code&gt; 时，此方法将SQL &lt;code&gt;NULL&lt;/code&gt; 写入流。否则，它将调用给定对象的 &lt;code&gt;SQLData.writeSQL&lt;/code&gt; 方法，该方法会将对象的属性写入流。</target>
        </trans-unit>
        <trans-unit id="363c2b77917ba97ed7dfdca74cae97621fbdddc4" translate="yes" xml:space="preserve">
          <source>Writes to the stream the data contained in the given &lt;code&gt;SQLData&lt;/code&gt; object. When the &lt;code&gt;SQLData&lt;/code&gt; object is &lt;code&gt;null&lt;/code&gt;, this method writes an SQL &lt;code&gt;NULL&lt;/code&gt; to the stream. Otherwise, it calls the &lt;code&gt;SQLData.writeSQL&lt;/code&gt; method of the given object, which writes the object's attributes to the stream. The implementation of the method &lt;code&gt;SQLData.writeSQL&lt;/code&gt; calls the appropriate &lt;code&gt;SQLOutput&lt;/code&gt; writer method(s) for writing each of the object's attributes in order. The attributes must be read from an &lt;code&gt;SQLInput&lt;/code&gt; input stream and written to an &lt;code&gt;SQLOutput&lt;/code&gt; output stream in the same order in which they were listed in the SQL definition of the user-defined type.</source>
          <target state="translated">将包含在给定 &lt;code&gt;SQLData&lt;/code&gt; 对象中的数据写入流中。当 &lt;code&gt;SQLData&lt;/code&gt; 对象为 &lt;code&gt;null&lt;/code&gt; 时，此方法将SQL &lt;code&gt;NULL&lt;/code&gt; 写入流。否则，它将调用给定对象的 &lt;code&gt;SQLData.writeSQL&lt;/code&gt; 方法，该方法会将对象的属性写入流。方法 &lt;code&gt;SQLData.writeSQL&lt;/code&gt; 的实现调用适当的 &lt;code&gt;SQLOutput&lt;/code&gt; writer方法，以按顺序写入每个对象的属性。必须从 &lt;code&gt;SQLInput&lt;/code&gt; 输入流中读取属性，并以用户定义类型的SQL定义中列出属性的顺序将其 &lt;code&gt;SQLOutput&lt;/code&gt; 输出流。</target>
        </trans-unit>
        <trans-unit id="8e830ac9520dde8effa90ef42b6c3c7f73f65364" translate="yes" xml:space="preserve">
          <source>Writes to the stream the data contained in the given object.</source>
          <target state="translated">将给定对象中的数据写入流。</target>
        </trans-unit>
        <trans-unit id="8873fa76c2f527781970d368373d33a03dbd6d75" translate="yes" xml:space="preserve">
          <source>Writes to the stream the data contained in the given object. The object will be converted to the specified targetSqlType before being sent to the stream.</source>
          <target state="translated">将给定对象中的数据写入流。在发送到流之前,该对象将被转换为指定的targetSqlType。</target>
        </trans-unit>
        <trans-unit id="1dcbd1fcd9c20910e4d19c79a6908b0180531555" translate="yes" xml:space="preserve">
          <source>Writes two bytes containing the given char value, in the current byte order, into this buffer at the current position, and then increments the position by two.</source>
          <target state="translated">将包含给定char值的两个字节按当前字节顺序写入当前位置的缓冲区,然后将该位置增量为2。</target>
        </trans-unit>
        <trans-unit id="e978de920f972d75d95f1255bab54910641e5e61" translate="yes" xml:space="preserve">
          <source>Writes two bytes containing the given char value, in the current byte order, into this buffer at the given index.</source>
          <target state="translated">将包含给定char值的两个字节以当前字节顺序写入给定索引的缓冲区。</target>
        </trans-unit>
        <trans-unit id="6fc0c682093f02b665c23020bba01582a4b98e28" translate="yes" xml:space="preserve">
          <source>Writes two bytes containing the given short value, in the current byte order, into this buffer at the current position, and then increments the position by two.</source>
          <target state="translated">将包含给定短值的两个字节按当前字节顺序写入当前位置的缓冲区,然后将该位置增量为2。</target>
        </trans-unit>
        <trans-unit id="0f419b1c9cfcd70b38af34a51aebf7df8b86f76e" translate="yes" xml:space="preserve">
          <source>Writes two bytes containing the given short value, in the current byte order, into this buffer at the given index.</source>
          <target state="translated">将包含给定短值的两个字节按当前字节顺序写入给定索引的缓冲区。</target>
        </trans-unit>
        <trans-unit id="e6d8fbbfcfd69eef504dcac6d1ae51eb79ffbc5f" translate="yes" xml:space="preserve">
          <source>Writes two bytes of length information to the output stream in network byte order, followed by the &lt;a href=&quot;../../../../java.base/java/io/datainput#modified-utf-8&quot;&gt; modified UTF-8&lt;/a&gt; representation of every character in the string &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">以网络字节顺序将两个字节的长度信息写入输出流，然后是字符串 &lt;code&gt;s&lt;/code&gt; 中每个字符的&lt;a href=&quot;../../../../java.base/java/io/datainput#modified-utf-8&quot;&gt;修改后的UTF-8&lt;/a&gt;表示形式。</target>
        </trans-unit>
        <trans-unit id="11f8bb9bf8b8a3b9415c961461d6b9561351459f" translate="yes" xml:space="preserve">
          <source>Writes two bytes of length information to the output stream in network byte order, followed by the &lt;a href=&quot;../../../../java.base/java/io/datainput#modified-utf-8&quot;&gt; modified UTF-8&lt;/a&gt; representation of every character in the string &lt;code&gt;s&lt;/code&gt;. If &lt;code&gt;s&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, a &lt;code&gt;NullPointerException&lt;/code&gt; is thrown. Each character in the string &lt;code&gt;s&lt;/code&gt; is converted to a group of one, two, or three bytes, depending on the value of the character.</source>
          <target state="translated">以网络字节顺序将两个字节的长度信息写入输出流，然后是字符串 &lt;code&gt;s&lt;/code&gt; 中每个字符的&lt;a href=&quot;../../../../java.base/java/io/datainput#modified-utf-8&quot;&gt;修改后的UTF-8&lt;/a&gt;表示形式。如果 &lt;code&gt;s&lt;/code&gt; 为 &lt;code&gt;null&lt;/code&gt; ，则抛出 &lt;code&gt;NullPointerException&lt;/code&gt; 。字符串 &lt;code&gt;s&lt;/code&gt; 中的每个字符都将转换为一个，两个或三个字节的组，具体取决于字符的值。</target>
        </trans-unit>
        <trans-unit id="ee80091edbeade9265ab307086b86eb4ae01dddf" translate="yes" xml:space="preserve">
          <source>Writes two bytes of length information to the output stream in network byte order, followed by the &lt;a href=&quot;../../../java/io/datainput#modified-utf-8&quot;&gt;modified UTF-8&lt;/a&gt; representation of every character in the string &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">以网络字节顺序将两个字节的长度信息写入输出流，然后是字符串 &lt;code&gt;s&lt;/code&gt; 中每个字符的&lt;a href=&quot;../../../java/io/datainput#modified-utf-8&quot;&gt;修改后的UTF-8&lt;/a&gt;表示形式。</target>
        </trans-unit>
        <trans-unit id="4b6256eb9d0d72cbe71b13a3c7e9f7676978fe16" translate="yes" xml:space="preserve">
          <source>Writes two bytes of length information to the output stream in network byte order, followed by the &lt;a href=&quot;../../../java/io/datainput#modified-utf-8&quot;&gt;modified UTF-8&lt;/a&gt; representation of every character in the string &lt;code&gt;s&lt;/code&gt;. If &lt;code&gt;s&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, a &lt;code&gt;NullPointerException&lt;/code&gt; is thrown. Each character in the string &lt;code&gt;s&lt;/code&gt; is converted to a group of one, two, or three bytes, depending on the value of the character.</source>
          <target state="translated">以网络字节顺序将两个字节的长度信息写入输出流，然后是字符串 &lt;code&gt;s&lt;/code&gt; 中每个字符的&lt;a href=&quot;../../../java/io/datainput#modified-utf-8&quot;&gt;修改后的UTF-8&lt;/a&gt;表示形式。如果 &lt;code&gt;s&lt;/code&gt; 为 &lt;code&gt;null&lt;/code&gt; ，则抛出 &lt;code&gt;NullPointerException&lt;/code&gt; 。字符串 &lt;code&gt;s&lt;/code&gt; 中的每个字符都将转换为一个，两个或三个字节的组，具体取决于字符的值。</target>
        </trans-unit>
        <trans-unit id="61fed0fe63590aa8fe08508149b0ac07f0edb001" translate="yes" xml:space="preserve">
          <source>Writes two bytes of length information to the output stream, followed by the &lt;a href=&quot;datainput#modified-utf-8&quot;&gt;modified UTF-8&lt;/a&gt; representation of every character in the string &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">将两个字节的长度信息写入输出流，然后是字符串 &lt;code&gt;s&lt;/code&gt; 中每个字符的&lt;a href=&quot;datainput#modified-utf-8&quot;&gt;修改后的UTF-8&lt;/a&gt;表示形式。</target>
        </trans-unit>
        <trans-unit id="acb381ca0baa70d627eb89fc91539d21b5b1970f" translate="yes" xml:space="preserve">
          <source>Writes two bytes of length information to the output stream, followed by the &lt;a href=&quot;datainput#modified-utf-8&quot;&gt;modified UTF-8&lt;/a&gt; representation of every character in the string &lt;code&gt;s&lt;/code&gt;. If &lt;code&gt;s&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, a &lt;code&gt;NullPointerException&lt;/code&gt; is thrown. Each character in the string &lt;code&gt;s&lt;/code&gt; is converted to a group of one, two, or three bytes, depending on the value of the character.</source>
          <target state="translated">将两个字节的长度信息写入输出流，然后将字符串 &lt;code&gt;s&lt;/code&gt; 中的每个字符&lt;a href=&quot;datainput#modified-utf-8&quot;&gt;修改后的UTF-8&lt;/a&gt;表示形式写入。如果 &lt;code&gt;s&lt;/code&gt; 为 &lt;code&gt;null&lt;/code&gt; ，则抛出 &lt;code&gt;NullPointerException&lt;/code&gt; 。字符串 &lt;code&gt;s&lt;/code&gt; 中的每个字符都将转换为一个，两个或三个字节的组，具体取决于字符的值。</target>
        </trans-unit>
        <trans-unit id="11a7c7a4a4b01ec9ba0d240cb1a9682883bcf927" translate="yes" xml:space="preserve">
          <source>Writes two bytes to the output stream to represent the value of the argument.</source>
          <target state="translated">将两个字节写入输出流,代表参数的值。</target>
        </trans-unit>
        <trans-unit id="840baa9d6bfa2b29f18593baa6d5a15f4137eaeb" translate="yes" xml:space="preserve">
          <source>Writes two bytes to the output stream to represent the value of the argument. The byte values to be written, in the order shown, are:</source>
          <target state="translated">将两个字节写入输出流,代表参数的值。要写入的字节值,按所示顺序为:</target>
        </trans-unit>
        <trans-unit id="2dabb8334b6cbbc19635a160f00032f11eeb9962" translate="yes" xml:space="preserve">
          <source>Writing</source>
          <target state="translated">Writing</target>
        </trans-unit>
        <trans-unit id="95ad111c35bebeafa25fe06efdef5f08bcb7e909" translate="yes" xml:space="preserve">
          <source>Writing GIF images</source>
          <target state="translated">编写GIF图片</target>
        </trans-unit>
        <trans-unit id="424422e9c1df6af363f8dd1c46652e8af0cdb465" translate="yes" xml:space="preserve">
          <source>Writing a &lt;code&gt;WebRowSet&lt;/code&gt; object includes printing the rowset's data, metadata, and properties, all with the appropriate XML tags.</source>
          <target state="translated">编写 &lt;code&gt;WebRowSet&lt;/code&gt; 对象包括打印行集的数据，元数据和属性，所有这些都带有适当的XML标记。</target>
        </trans-unit>
        <trans-unit id="dddf90dcfc18cbf45f914c903cf3587716a02561" translate="yes" xml:space="preserve">
          <source>Writing a packet does not do any integrity checking on the packet aside from checking the packet length. Checking the packet length requires checking that the value of the &lt;code&gt;length&lt;/code&gt; field (as indicated by the first four bytes of the packet) is 11 or greater. Consequently the length of the byte array provided to this method, that is &lt;code&gt;pkt.length&lt;/code&gt;, must be 11 or more, and must be equal or greater than the value of the &lt;code&gt;length&lt;/code&gt; field. If the length of the byte array is greater than the value of the &lt;code&gt;length&lt;/code&gt; field then all bytes from element &lt;code&gt;pkt[length]&lt;/code&gt; onwards are ignored. In other words, any additional bytes that follow the packet in the byte array are ignored and will not be transmitted to the target VM.</source>
          <target state="translated">除了检查数据包长度之外，写入数据包不会对数据包进行任何完整性检查。检查数据包长度需要检查 &lt;code&gt;length&lt;/code&gt; 字段的值（如数据包的前四个字节所示）为11或更大。因此，为此方法提供的字节数组的长度 &lt;code&gt;pkt.length&lt;/code&gt; 必须为11或更大，并且必须等于或大于 &lt;code&gt;length&lt;/code&gt; 字段的值。如果字节数组的长度大于 &lt;code&gt;length&lt;/code&gt; 字段的值，则将忽略从元素 &lt;code&gt;pkt[length]&lt;/code&gt; 开始的所有字节。换句话说，字节数组中位于数据包之后的任何其他字节都将被忽略，并且不会传输到目标VM。</target>
        </trans-unit>
        <trans-unit id="9cd3c35e027988d3e72acc1181f58b176b562470" translate="yes" xml:space="preserve">
          <source>Writing out a bean, on the other hand, sometimes requires special knowledge of the bean's type. If the bean's state can be expressed using only the no-argument constructor and public getter and setter methods for properties, no special knowledge is required. Otherwise, the bean requires a custom &lt;em&gt;persistence delegate&lt;/em&gt; -- an object that is in charge of writing out beans of a particular type. All classes provided in the JDK that descend from &lt;code&gt;java.awt.Component&lt;/code&gt;, as well as all their properties, automatically have persistence delegates.</source>
          <target state="translated">另一方面，写出bean有时需要有关bean类型的特殊知识。如果可以仅使用无参数构造函数以及属性的公共getter和setter方法来表示Bean的状态，则不需要特殊知识。否则，Bean需要一个自定义的&lt;em&gt;持久性委托&lt;/em&gt; -一个负责写出特定类型Bean的对象。JDK中提供的所有派生自 &lt;code&gt;java.awt.Component&lt;/code&gt; 的类及其所有属性都自动具有持久性委托。</target>
        </trans-unit>
        <trans-unit id="2aca6c8bd10dab33a4eec99abb3e68b55ac1f71c" translate="yes" xml:space="preserve">
          <source>Writing to file descriptors</source>
          <target state="translated">写入文件描述符</target>
        </trans-unit>
        <trans-unit id="087742bd2a01740eeb022cb23d5b57ca20a16d8d" translate="yes" xml:space="preserve">
          <source>WrongMethodTypeException</source>
          <target state="translated">WrongMethodTypeException</target>
        </trans-unit>
        <trans-unit id="c032adc1ff629c9b66f22749ad667e6beadf144b" translate="yes" xml:space="preserve">
          <source>X</source>
          <target state="translated">X</target>
        </trans-unit>
        <trans-unit id="db449d7dc04f973b1ad97228d3cd5fa1f5225e0b" translate="yes" xml:space="preserve">
          <source>X be the MBean named by &lt;code&gt;name&lt;/code&gt;,</source>
          <target state="translated">X是按 &lt;code&gt;name&lt;/code&gt; 命名的MBean ，</target>
        </trans-unit>
        <trans-unit id="04d117bbef4a6bcdcdff089df98755d8aa7b99de" translate="yes" xml:space="preserve">
          <source>X coordinate the control point</source>
          <target state="translated">X坐标控制点</target>
        </trans-unit>
        <trans-unit id="d6eed17085cd961824e6cc026bad4e1f6bbfdf9a" translate="yes" xml:space="preserve">
          <source>X dimension (&amp;micro;m).</source>
          <target state="translated">X尺寸（&amp;micro;m）。</target>
        </trans-unit>
        <trans-unit id="7f266332102748822354cc0a5aa107093c35ebbd" translate="yes" xml:space="preserve">
          <source>X dimension.</source>
          <target state="translated">X维:</target>
        </trans-unit>
        <trans-unit id="b5610424b8a02ba2abc09a2e8508cc30ad10e2b3" translate="yes" xml:space="preserve">
          <source>X,</source>
          <target state="translated">X,</target>
        </trans-unit>
        <trans-unit id="34826acc1a06fc5b72d40097770b09d8e5c62652" translate="yes" xml:space="preserve">
          <source>X, as a &lt;a href=&quot;#cg&quot;&gt;capturing group&lt;/a&gt;</source>
          <target state="translated">X，作为&lt;a href=&quot;#cg&quot;&gt;捕获组&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="153bf828911a9b26f94f5e8da8f2fb9bb7b28fe4" translate="yes" xml:space="preserve">
          <source>X.509, PGP, and SDSI certificates can all be implemented by subclassing the Certificate class, even though they contain different sets of information, and they store and retrieve the information in different ways.</source>
          <target state="translated">X.509、PGP和SDSI证书都可以通过子类Certificate类来实现,尽管它们包含不同的信息集,并且它们以不同的方式存储和检索信息。</target>
        </trans-unit>
        <trans-unit id="4590145268458005ff818a940acd5d70ab872d49" translate="yes" xml:space="preserve">
          <source>X25519</source>
          <target state="translated">X25519</target>
        </trans-unit>
        <trans-unit id="1c1a210cdcf74ff605ceeee78ea3b4156161eddf" translate="yes" xml:space="preserve">
          <source>X448</source>
          <target state="translated">X448</target>
        </trans-unit>
        <trans-unit id="1bd269c56dd4b87ce14015ee8fa37115311520bf" translate="yes" xml:space="preserve">
          <source>X500Principal</source>
          <target state="translated">X500Principal</target>
        </trans-unit>
        <trans-unit id="ebe07aff1a5d06134e103668254133e47ebed3d3" translate="yes" xml:space="preserve">
          <source>X500Principal.equals()</source>
          <target state="translated">X500Principal.equals()</target>
        </trans-unit>
        <trans-unit id="44f531c8910ef1690c5414e940f95622b4b29dac" translate="yes" xml:space="preserve">
          <source>X500Principal.getEncoded()</source>
          <target state="translated">X500Principal.getEncoded()</target>
        </trans-unit>
        <trans-unit id="08dc2bb2b748578a12935a031ae247bdbc506c92" translate="yes" xml:space="preserve">
          <source>X500Principal.getName()</source>
          <target state="translated">X500Principal.getName()</target>
        </trans-unit>
        <trans-unit id="85e52a880efe4b288d45c41cedbc91debb817b34" translate="yes" xml:space="preserve">
          <source>X500Principal.hashCode()</source>
          <target state="translated">X500Principal.hashCode()</target>
        </trans-unit>
        <trans-unit id="f6d4ed090724f259caa864b84485151a2f5ed2a6" translate="yes" xml:space="preserve">
          <source>X500Principal.toString()</source>
          <target state="translated">X500Principal.toString()</target>
        </trans-unit>
        <trans-unit id="aa7c4644ed192385ca463ead0261d1728512dd3b" translate="yes" xml:space="preserve">
          <source>X500PrivateCredential</source>
          <target state="translated">X500PrivateCredential</target>
        </trans-unit>
        <trans-unit id="d034f128505231d7ac518742ffbbed3e97e6e481" translate="yes" xml:space="preserve">
          <source>X500PrivateCredential.destroy()</source>
          <target state="translated">X500PrivateCredential.destroy()</target>
        </trans-unit>
        <trans-unit id="a6e9eecb44deb79c51837aacde9e046aa902e33a" translate="yes" xml:space="preserve">
          <source>X500PrivateCredential.getAlias()</source>
          <target state="translated">X500PrivateCredential.getAlias()</target>
        </trans-unit>
        <trans-unit id="9f750adea9e5263dff3d30eb16f0098cfb5c1a5b" translate="yes" xml:space="preserve">
          <source>X500PrivateCredential.getCertificate()</source>
          <target state="translated">X500PrivateCredential.getCertificate()</target>
        </trans-unit>
        <trans-unit id="6ad4479421ed09f884c8c3e0c36adabeee8170df" translate="yes" xml:space="preserve">
          <source>X500PrivateCredential.getPrivateKey()</source>
          <target state="translated">X500PrivateCredential.getPrivateKey()</target>
        </trans-unit>
        <trans-unit id="ef0ff1d8b5787f71f3646c30049b1d7a2bca631f" translate="yes" xml:space="preserve">
          <source>X500PrivateCredential.isDestroyed()</source>
          <target state="translated">X500PrivateCredential.isDestroyed()</target>
        </trans-unit>
        <trans-unit id="686dd940cc8227b0aa2cd69ee1f44cfa6d1e893f" translate="yes" xml:space="preserve">
          <source>X509CRL</source>
          <target state="translated">X509CRL</target>
        </trans-unit>
        <trans-unit id="7110aa0404043c957aa839aa47f0f0c0a235d814" translate="yes" xml:space="preserve">
          <source>X509CRL.equals()</source>
          <target state="translated">X509CRL.equals()</target>
        </trans-unit>
        <trans-unit id="a8d0f2a8e61792cb750521d01ae1c425200eee29" translate="yes" xml:space="preserve">
          <source>X509CRL.getEncoded()</source>
          <target state="translated">X509CRL.getEncoded()</target>
        </trans-unit>
        <trans-unit id="2f2c2d9ad2feed06f68886e5534e5a1725acf6f0" translate="yes" xml:space="preserve">
          <source>X509CRL.getIssuerDN()</source>
          <target state="translated">X509CRL.getIssuerDN()</target>
        </trans-unit>
        <trans-unit id="d5041e1c7a5b762dee37a31bfd82a14e09c5c33e" translate="yes" xml:space="preserve">
          <source>X509CRL.getIssuerX500Principal()</source>
          <target state="translated">X509CRL.getIssuerX500Principal()</target>
        </trans-unit>
        <trans-unit id="b2723672bad69076cb03b2b1698dc03f59d0ea09" translate="yes" xml:space="preserve">
          <source>X509CRL.getNextUpdate()</source>
          <target state="translated">X509CRL.getNextUpdate()</target>
        </trans-unit>
        <trans-unit id="406fe17fe2408adebb3de6191ff98d0aae6574e7" translate="yes" xml:space="preserve">
          <source>X509CRL.getRevokedCertificate()</source>
          <target state="translated">X509CRL.getRevokedCertificate()</target>
        </trans-unit>
        <trans-unit id="c282b03b35ba6133d7f69263475d3e79c4c96d18" translate="yes" xml:space="preserve">
          <source>X509CRL.getRevokedCertificates()</source>
          <target state="translated">X509CRL.getRevokedCertificates()</target>
        </trans-unit>
        <trans-unit id="676975bb590ac24ff50fbec531440b871beceedb" translate="yes" xml:space="preserve">
          <source>X509CRL.getSigAlgName()</source>
          <target state="translated">X509CRL.getSigAlgName()</target>
        </trans-unit>
        <trans-unit id="cca79e74cc8ba51fac9fb5484e66124607d369d9" translate="yes" xml:space="preserve">
          <source>X509CRL.getSigAlgOID()</source>
          <target state="translated">X509CRL.getSigAlgOID()</target>
        </trans-unit>
        <trans-unit id="28c2198822dff08b6100d64abef2998ea91df931" translate="yes" xml:space="preserve">
          <source>X509CRL.getSigAlgParams()</source>
          <target state="translated">X509CRL.getSigAlgParams()</target>
        </trans-unit>
        <trans-unit id="817097db4f4524b7475ee9a94624753adaeec91b" translate="yes" xml:space="preserve">
          <source>X509CRL.getSignature()</source>
          <target state="translated">X509CRL.getSignature()</target>
        </trans-unit>
        <trans-unit id="a6853b01102efc16cd41b4f21b2c2403aa88fbec" translate="yes" xml:space="preserve">
          <source>X509CRL.getTBSCertList()</source>
          <target state="translated">X509CRL.getTBSCertList()</target>
        </trans-unit>
        <trans-unit id="859688e6f0f0d21f0915e65120c504f1568c0fa0" translate="yes" xml:space="preserve">
          <source>X509CRL.getThisUpdate()</source>
          <target state="translated">X509CRL.getThisUpdate()</target>
        </trans-unit>
        <trans-unit id="666eba5f3eb0836f485542f2b3612b3740a26658" translate="yes" xml:space="preserve">
          <source>X509CRL.getVersion()</source>
          <target state="translated">X509CRL.getVersion()</target>
        </trans-unit>
        <trans-unit id="ef777faf32e00157c932d26e4a91ee3ec2d48f1e" translate="yes" xml:space="preserve">
          <source>X509CRL.hashCode()</source>
          <target state="translated">X509CRL.hashCode()</target>
        </trans-unit>
        <trans-unit id="7df628731cfd156631b4a6dde9d8100f8bf13d59" translate="yes" xml:space="preserve">
          <source>X509CRL.verify()</source>
          <target state="translated">X509CRL.verify()</target>
        </trans-unit>
        <trans-unit id="4929c310370b1f2c4432d741b376aa8796d6daa6" translate="yes" xml:space="preserve">
          <source>X509CRLEntry</source>
          <target state="translated">X509CRLEntry</target>
        </trans-unit>
        <trans-unit id="6f506b182e9c3e2ee873d77a6b41722c00ad04f0" translate="yes" xml:space="preserve">
          <source>X509CRLEntry.equals()</source>
          <target state="translated">X509CRLEntry.equals()</target>
        </trans-unit>
        <trans-unit id="4ea40e3fc5a6e22b9ad4abfb207a580ed449dd38" translate="yes" xml:space="preserve">
          <source>X509CRLEntry.getCertificateIssuer()</source>
          <target state="translated">X509CRLEntry.getCertificateIssuer()</target>
        </trans-unit>
        <trans-unit id="236c0633cfcd4437299c5cfa51b69a58189686f3" translate="yes" xml:space="preserve">
          <source>X509CRLEntry.getEncoded()</source>
          <target state="translated">X509CRLEntry.getEncoded()</target>
        </trans-unit>
        <trans-unit id="dc242325ee95b283e2bce2346034bb12bd0bfcec" translate="yes" xml:space="preserve">
          <source>X509CRLEntry.getRevocationDate()</source>
          <target state="translated">X509CRLEntry.getRevocationDate()</target>
        </trans-unit>
        <trans-unit id="c8deeea3d6af56508cad742a99121e62126d0753" translate="yes" xml:space="preserve">
          <source>X509CRLEntry.getRevocationReason()</source>
          <target state="translated">X509CRLEntry.getRevocationReason()</target>
        </trans-unit>
        <trans-unit id="70dc85fba9f70a00f5b5be5375f4f46bd97ff72f" translate="yes" xml:space="preserve">
          <source>X509CRLEntry.getSerialNumber()</source>
          <target state="translated">X509CRLEntry.getSerialNumber()</target>
        </trans-unit>
        <trans-unit id="82ac9fc56fd26a520483391d1fc255e7a65ad123" translate="yes" xml:space="preserve">
          <source>X509CRLEntry.hasExtensions()</source>
          <target state="translated">X509CRLEntry.hasExtensions()</target>
        </trans-unit>
        <trans-unit id="e49e98981f178c407f6c206c52398697a35c2131" translate="yes" xml:space="preserve">
          <source>X509CRLEntry.hashCode()</source>
          <target state="translated">X509CRLEntry.hashCode()</target>
        </trans-unit>
        <trans-unit id="002a4ee189ce5a952707a0330d74fddbc21248bf" translate="yes" xml:space="preserve">
          <source>X509CRLEntry.toString()</source>
          <target state="translated">X509CRLEntry.toString()</target>
        </trans-unit>
        <trans-unit id="0537cdb42327ff3a67d3ea83f714032cba724024" translate="yes" xml:space="preserve">
          <source>X509CRLSelector</source>
          <target state="translated">X509CRLSelector</target>
        </trans-unit>
        <trans-unit id="005121bdf2647a03921558ab963894a107961c75" translate="yes" xml:space="preserve">
          <source>X509CRLSelector.addIssuer()</source>
          <target state="translated">X509CRLSelector.addIssuer()</target>
        </trans-unit>
        <trans-unit id="7aceb5d988f24a52dd02f464ca3d9494b9babed9" translate="yes" xml:space="preserve">
          <source>X509CRLSelector.addIssuerName()</source>
          <target state="translated">X509CRLSelector.addIssuerName()</target>
        </trans-unit>
        <trans-unit id="8284e8efc69ac3a83307e2cafdf63753734cc0c4" translate="yes" xml:space="preserve">
          <source>X509CRLSelector.clone()</source>
          <target state="translated">X509CRLSelector.clone()</target>
        </trans-unit>
        <trans-unit id="db9deb73c56072075cef0974014cbfa6b6abb260" translate="yes" xml:space="preserve">
          <source>X509CRLSelector.getCertificateChecking()</source>
          <target state="translated">X509CRLSelector.getCertificateChecking()</target>
        </trans-unit>
        <trans-unit id="6ab4ca2011fa8c661e4158060a00d8943b99ef0e" translate="yes" xml:space="preserve">
          <source>X509CRLSelector.getDateAndTime()</source>
          <target state="translated">X509CRLSelector.getDateAndTime()</target>
        </trans-unit>
        <trans-unit id="5532ca5d6569c1cbe8f868920ffc31a6e9707b99" translate="yes" xml:space="preserve">
          <source>X509CRLSelector.getIssuerNames()</source>
          <target state="translated">X509CRLSelector.getIssuerNames()</target>
        </trans-unit>
        <trans-unit id="032e18f3ad4222c7bc737794768e950215da9b65" translate="yes" xml:space="preserve">
          <source>X509CRLSelector.getIssuers()</source>
          <target state="translated">X509CRLSelector.getIssuers()</target>
        </trans-unit>
        <trans-unit id="07343df6a607c3fccbbf96fd3aa6b9b3a4fc4ef9" translate="yes" xml:space="preserve">
          <source>X509CRLSelector.getMaxCRL()</source>
          <target state="translated">X509CRLSelector.getMaxCRL()</target>
        </trans-unit>
        <trans-unit id="5caa7704f0fbf71e8eda99020577a4f32ed3aec7" translate="yes" xml:space="preserve">
          <source>X509CRLSelector.getMinCRL()</source>
          <target state="translated">X509CRLSelector.getMinCRL()</target>
        </trans-unit>
        <trans-unit id="cd016510ad0b64a2934299f67f11e5252571bb4c" translate="yes" xml:space="preserve">
          <source>X509CRLSelector.match()</source>
          <target state="translated">X509CRLSelector.match()</target>
        </trans-unit>
        <trans-unit id="258d0b9571e5a2fda60a3574315cefbabaa4dd5a" translate="yes" xml:space="preserve">
          <source>X509CRLSelector.setCertificateChecking()</source>
          <target state="translated">X509CRLSelector.setCertificateChecking()</target>
        </trans-unit>
        <trans-unit id="d500c0b9ab0836602fbfeff49c264f434688fe8b" translate="yes" xml:space="preserve">
          <source>X509CRLSelector.setDateAndTime()</source>
          <target state="translated">X509CRLSelector.setDateAndTime()</target>
        </trans-unit>
        <trans-unit id="96a92cb7a8b71831980d1424a5364d676285b68d" translate="yes" xml:space="preserve">
          <source>X509CRLSelector.setIssuerNames()</source>
          <target state="translated">X509CRLSelector.setIssuerNames()</target>
        </trans-unit>
        <trans-unit id="90cfbcab2db3279ddd6db3561807d714cfdd0713" translate="yes" xml:space="preserve">
          <source>X509CRLSelector.setIssuers()</source>
          <target state="translated">X509CRLSelector.setIssuers()</target>
        </trans-unit>
        <trans-unit id="bf06aacef9a3be1a9ced4a10cbdd678a2f274350" translate="yes" xml:space="preserve">
          <source>X509CRLSelector.setMaxCRLNumber()</source>
          <target state="translated">X509CRLSelector.setMaxCRLNumber()</target>
        </trans-unit>
        <trans-unit id="86a0b242f3cd5aa3f58de645180e4a240a5db1f7" translate="yes" xml:space="preserve">
          <source>X509CRLSelector.setMinCRLNumber()</source>
          <target state="translated">X509CRLSelector.setMinCRLNumber()</target>
        </trans-unit>
        <trans-unit id="4321c653c660b241a08140ff511b46a70156446e" translate="yes" xml:space="preserve">
          <source>X509CRLSelector.toString()</source>
          <target state="translated">X509CRLSelector.toString()</target>
        </trans-unit>
        <trans-unit id="94342e1781dc9c33a70ca21cb6357db0b0b9dd67" translate="yes" xml:space="preserve">
          <source>X509CertSelector</source>
          <target state="translated">X509CertSelector</target>
        </trans-unit>
        <trans-unit id="849c98616043746f73f4de24a5afbac1d44d1497" translate="yes" xml:space="preserve">
          <source>X509CertSelector.addPathToName()</source>
          <target state="translated">X509CertSelector.addPathToName()</target>
        </trans-unit>
        <trans-unit id="6278349d36bb944f429eb415b0b2f5653f53be35" translate="yes" xml:space="preserve">
          <source>X509CertSelector.addSubjectAlternativeName()</source>
          <target state="translated">X509CertSelector.addSubjectAlternativeName()</target>
        </trans-unit>
        <trans-unit id="ed2ee8251ff17d4037102b86a0eb818ed7b9158b" translate="yes" xml:space="preserve">
          <source>X509CertSelector.clone()</source>
          <target state="translated">X509CertSelector.clone()</target>
        </trans-unit>
        <trans-unit id="4f7c0218aa9ee861a280f2a8a3d681319af44dc2" translate="yes" xml:space="preserve">
          <source>X509CertSelector.getAuthorityKeyIdentifier()</source>
          <target state="translated">X509CertSelector.getAuthorityKeyIdentifier()</target>
        </trans-unit>
        <trans-unit id="40d694ea6a0a9eae7c98a82ec7b08ba8c6e7d8c0" translate="yes" xml:space="preserve">
          <source>X509CertSelector.getBasicConstraints()</source>
          <target state="translated">X509CertSelector.getBasicConstraints()</target>
        </trans-unit>
        <trans-unit id="489a03ee864e5186cbe7e408a9342a09b16aa78a" translate="yes" xml:space="preserve">
          <source>X509CertSelector.getCertificate()</source>
          <target state="translated">X509CertSelector.getCertificate()</target>
        </trans-unit>
        <trans-unit id="bdaabe014d6ad8fd33d855ee9bb1f16ef2b29b42" translate="yes" xml:space="preserve">
          <source>X509CertSelector.getCertificateValid()</source>
          <target state="translated">X509CertSelector.getCertificateValid()</target>
        </trans-unit>
        <trans-unit id="e0b06dfa030eecee34ff0d43f2bf88f7c677a1f8" translate="yes" xml:space="preserve">
          <source>X509CertSelector.getExtendedKeyUsage()</source>
          <target state="translated">X509CertSelector.getExtendedKeyUsage()</target>
        </trans-unit>
        <trans-unit id="df6a6707a1f1e6b86730e8d99239277ba12cc213" translate="yes" xml:space="preserve">
          <source>X509CertSelector.getIssuer()</source>
          <target state="translated">X509CertSelector.getIssuer()</target>
        </trans-unit>
        <trans-unit id="ae7e401dc377f554ece71569312befdac83a6d76" translate="yes" xml:space="preserve">
          <source>X509CertSelector.getIssuerAsBytes()</source>
          <target state="translated">X509CertSelector.getIssuerAsBytes()</target>
        </trans-unit>
        <trans-unit id="fff1dd584edf03c78d3f48961f0068ee33aec9fd" translate="yes" xml:space="preserve">
          <source>X509CertSelector.getIssuerAsString()</source>
          <target state="translated">X509CertSelector.getIssuerAsString()</target>
        </trans-unit>
        <trans-unit id="fb95fd548f3274ae1629644c5d7f19e3399b95b9" translate="yes" xml:space="preserve">
          <source>X509CertSelector.getKeyUsage()</source>
          <target state="translated">X509CertSelector.getKeyUsage()</target>
        </trans-unit>
        <trans-unit id="201ecc89e49a111d0b388bd6788c96cf2da4cfe1" translate="yes" xml:space="preserve">
          <source>X509CertSelector.getMatchAllSubjectAltNames()</source>
          <target state="translated">X509CertSelector.getMatchAllSubjectAltNames()</target>
        </trans-unit>
        <trans-unit id="d832903d93a4fa039be163837346386802abfb52" translate="yes" xml:space="preserve">
          <source>X509CertSelector.getNameConstraints()</source>
          <target state="translated">X509CertSelector.getNameConstraints()</target>
        </trans-unit>
        <trans-unit id="c963901b33f3f86f39cdd1dd2864b23d5088719e" translate="yes" xml:space="preserve">
          <source>X509CertSelector.getPathToNames()</source>
          <target state="translated">X509CertSelector.getPathToNames()</target>
        </trans-unit>
        <trans-unit id="781ef4d399e43252f203c8dc4b5efd48a663b7ac" translate="yes" xml:space="preserve">
          <source>X509CertSelector.getPolicy()</source>
          <target state="translated">X509CertSelector.getPolicy()</target>
        </trans-unit>
        <trans-unit id="28ebd04b297719d66e00f58a120d42c627462c32" translate="yes" xml:space="preserve">
          <source>X509CertSelector.getPrivateKeyValid()</source>
          <target state="translated">X509CertSelector.getPrivateKeyValid()</target>
        </trans-unit>
        <trans-unit id="299d03b8810ccbde189382f778e1e69a9edf5518" translate="yes" xml:space="preserve">
          <source>X509CertSelector.getSerialNumber()</source>
          <target state="translated">X509CertSelector.getSerialNumber()</target>
        </trans-unit>
        <trans-unit id="30fadb44582a38c2c581267a782a13ef48ce3f8c" translate="yes" xml:space="preserve">
          <source>X509CertSelector.getSubject()</source>
          <target state="translated">X509CertSelector.getSubject()</target>
        </trans-unit>
        <trans-unit id="8fe339cc206ef73ed54a20b13ef60192e178f844" translate="yes" xml:space="preserve">
          <source>X509CertSelector.getSubjectAlternativeNames()</source>
          <target state="translated">X509CertSelector.getSubjectAlternativeNames()</target>
        </trans-unit>
        <trans-unit id="ca470a951b9db1a85e008465b33f7f0025fd4ed7" translate="yes" xml:space="preserve">
          <source>X509CertSelector.getSubjectAsBytes()</source>
          <target state="translated">X509CertSelector.getSubjectAsBytes()</target>
        </trans-unit>
        <trans-unit id="aed8aae80b16c67e2bd98bedd10564828eed6a02" translate="yes" xml:space="preserve">
          <source>X509CertSelector.getSubjectAsString()</source>
          <target state="translated">X509CertSelector.getSubjectAsString()</target>
        </trans-unit>
        <trans-unit id="024358cc8426c59dad8537730df35ef69e5374a4" translate="yes" xml:space="preserve">
          <source>X509CertSelector.getSubjectKeyIdentifier()</source>
          <target state="translated">X509CertSelector.getSubjectKeyIdentifier()</target>
        </trans-unit>
        <trans-unit id="f5738e2b6e6f38f47f261f937e072b25f4ec2eb5" translate="yes" xml:space="preserve">
          <source>X509CertSelector.getSubjectPublicKey()</source>
          <target state="translated">X509CertSelector.getSubjectPublicKey()</target>
        </trans-unit>
        <trans-unit id="650c289d16e4fd83b1e95660cbfed07706bb9286" translate="yes" xml:space="preserve">
          <source>X509CertSelector.getSubjectPublicKeyAlgID()</source>
          <target state="translated">X509CertSelector.getSubjectPublicKeyAlgID()</target>
        </trans-unit>
        <trans-unit id="227c01cacf995c323f3ba2ddda72a8c1d03e6e30" translate="yes" xml:space="preserve">
          <source>X509CertSelector.match()</source>
          <target state="translated">X509CertSelector.match()</target>
        </trans-unit>
        <trans-unit id="68c0f28130a6bf8d3c2abd14522f6c6c9688eb02" translate="yes" xml:space="preserve">
          <source>X509CertSelector.setAuthorityKeyIdentifier()</source>
          <target state="translated">X509CertSelector.setAuthorityKeyIdentifier()</target>
        </trans-unit>
        <trans-unit id="0743dae5d1f40b69fc2ed7f9f8063b882e1c6506" translate="yes" xml:space="preserve">
          <source>X509CertSelector.setBasicConstraints()</source>
          <target state="translated">X509CertSelector.setBasicConstraints()</target>
        </trans-unit>
        <trans-unit id="3f91236f46d4c1ca997bb1dd60eaa6480e178eac" translate="yes" xml:space="preserve">
          <source>X509CertSelector.setCertificate()</source>
          <target state="translated">X509CertSelector.setCertificate()</target>
        </trans-unit>
        <trans-unit id="f753e79d07d1c7ff8e7766426c9008f7d741f947" translate="yes" xml:space="preserve">
          <source>X509CertSelector.setCertificateValid()</source>
          <target state="translated">X509CertSelector.setCertificateValid()</target>
        </trans-unit>
        <trans-unit id="357a71aae1cd2f35c6a80fb733aa1088092c6474" translate="yes" xml:space="preserve">
          <source>X509CertSelector.setExtendedKeyUsage()</source>
          <target state="translated">X509CertSelector.setExtendedKeyUsage()</target>
        </trans-unit>
        <trans-unit id="9ea83d746002bc0aa736e6f65afa241bdcc775dc" translate="yes" xml:space="preserve">
          <source>X509CertSelector.setIssuer()</source>
          <target state="translated">X509CertSelector.setIssuer()</target>
        </trans-unit>
        <trans-unit id="c56e1298bc77fda9dd1a56fdf04575b296fc14b7" translate="yes" xml:space="preserve">
          <source>X509CertSelector.setKeyUsage()</source>
          <target state="translated">X509CertSelector.setKeyUsage()</target>
        </trans-unit>
        <trans-unit id="b486a38a689304e6df785424134afd125d8d5032" translate="yes" xml:space="preserve">
          <source>X509CertSelector.setMatchAllSubjectAltNames()</source>
          <target state="translated">X509CertSelector.setMatchAllSubjectAltNames()</target>
        </trans-unit>
        <trans-unit id="b48400dc4f916de3cc95f9337e25d568a2a1c742" translate="yes" xml:space="preserve">
          <source>X509CertSelector.setNameConstraints()</source>
          <target state="translated">X509CertSelector.setNameConstraints()</target>
        </trans-unit>
        <trans-unit id="fe470ccac7aaaa2979faf49d5584f5491d1c6565" translate="yes" xml:space="preserve">
          <source>X509CertSelector.setPathToNames()</source>
          <target state="translated">X509CertSelector.setPathToNames()</target>
        </trans-unit>
        <trans-unit id="dfaf5c753f0e41d22b63a535d3937b53aae07e5f" translate="yes" xml:space="preserve">
          <source>X509CertSelector.setPolicy()</source>
          <target state="translated">X509CertSelector.setPolicy()</target>
        </trans-unit>
        <trans-unit id="6d0c7877f10fc09b324ca3d3047400411f1c6ea4" translate="yes" xml:space="preserve">
          <source>X509CertSelector.setPrivateKeyValid()</source>
          <target state="translated">X509CertSelector.setPrivateKeyValid()</target>
        </trans-unit>
        <trans-unit id="86af9d1edb45e22a2903875dd9b2971784e2c8d1" translate="yes" xml:space="preserve">
          <source>X509CertSelector.setSerialNumber()</source>
          <target state="translated">X509CertSelector.setSerialNumber()</target>
        </trans-unit>
        <trans-unit id="ec33f3cc9bc744f7b4f027680c1da2ad2b108a48" translate="yes" xml:space="preserve">
          <source>X509CertSelector.setSubject()</source>
          <target state="translated">X509CertSelector.setSubject()</target>
        </trans-unit>
        <trans-unit id="7424eda4b963ea374a5ffa98029c541ca2d056a1" translate="yes" xml:space="preserve">
          <source>X509CertSelector.setSubjectAlternativeNames()</source>
          <target state="translated">X509CertSelector.setSubjectAlternativeNames()</target>
        </trans-unit>
        <trans-unit id="ac907bb460f67c33f513b32cdf50d78c639a3427" translate="yes" xml:space="preserve">
          <source>X509CertSelector.setSubjectKeyIdentifier()</source>
          <target state="translated">X509CertSelector.setSubjectKeyIdentifier()</target>
        </trans-unit>
        <trans-unit id="e6a4ccb21547f2a34b70f98ec9ba1b1eaeb60dd0" translate="yes" xml:space="preserve">
          <source>X509CertSelector.setSubjectPublicKey()</source>
          <target state="translated">X509CertSelector.setSubjectPublicKey()</target>
        </trans-unit>
        <trans-unit id="1e9218b693cd7e79257d7ae26d7276128e5c3b2b" translate="yes" xml:space="preserve">
          <source>X509CertSelector.setSubjectPublicKeyAlgID()</source>
          <target state="translated">X509CertSelector.setSubjectPublicKeyAlgID()</target>
        </trans-unit>
        <trans-unit id="c5a923a527dc9c62dba9aebf1122462312f07cc2" translate="yes" xml:space="preserve">
          <source>X509CertSelector.toString()</source>
          <target state="translated">X509CertSelector.toString()</target>
        </trans-unit>
        <trans-unit id="f6f0e8b60112f1c3be8ebabdeb6d7e48d60d9d02" translate="yes" xml:space="preserve">
          <source>X509Certificate</source>
          <target state="translated">X509Certificate</target>
        </trans-unit>
        <trans-unit id="7d60e0e197d0c0d506aa9dca6d156b869f512905" translate="yes" xml:space="preserve">
          <source>X509Certificate.checkValidity()</source>
          <target state="translated">X509Certificate.checkValidity()</target>
        </trans-unit>
        <trans-unit id="5f9840aac5626ba3ca82b57ed531cd3d3f4c15d3" translate="yes" xml:space="preserve">
          <source>X509Certificate.getBasicConstraints()</source>
          <target state="translated">X509Certificate.getBasicConstraints()</target>
        </trans-unit>
        <trans-unit id="8647c6b8afd81e28f330459dec8c7e3ccd121504" translate="yes" xml:space="preserve">
          <source>X509Certificate.getExtendedKeyUsage()</source>
          <target state="translated">X509Certificate.getExtendedKeyUsage()</target>
        </trans-unit>
        <trans-unit id="008ce5566e57c20d1a7ef32f815136c72bee066c" translate="yes" xml:space="preserve">
          <source>X509Certificate.getInstance()</source>
          <target state="translated">X509Certificate.getInstance()</target>
        </trans-unit>
        <trans-unit id="ac9c7d03b54b6ef087068f76feb5ca6ca90487ea" translate="yes" xml:space="preserve">
          <source>X509Certificate.getIssuerAlternativeNames()</source>
          <target state="translated">X509Certificate.getIssuerAlternativeNames()</target>
        </trans-unit>
        <trans-unit id="7ceb0ae93b0e59134baf7b2cea3a9b450c9ddc10" translate="yes" xml:space="preserve">
          <source>X509Certificate.getIssuerDN()</source>
          <target state="translated">X509Certificate.getIssuerDN()</target>
        </trans-unit>
        <trans-unit id="2a45c4d375bea0212b9380afe65c7359177ff695" translate="yes" xml:space="preserve">
          <source>X509Certificate.getIssuerUniqueID()</source>
          <target state="translated">X509Certificate.getIssuerUniqueID()</target>
        </trans-unit>
        <trans-unit id="81b58aa8abdd44a650146b3a19b6a2755b7ceddf" translate="yes" xml:space="preserve">
          <source>X509Certificate.getIssuerX500Principal()</source>
          <target state="translated">X509Certificate.getIssuerX500Principal()</target>
        </trans-unit>
        <trans-unit id="e6633e0189c761013fb963894756a20bd053a6c4" translate="yes" xml:space="preserve">
          <source>X509Certificate.getKeyUsage()</source>
          <target state="translated">X509Certificate.getKeyUsage()</target>
        </trans-unit>
        <trans-unit id="12e70fdfd017b4e91263c6b022d715a90fce8f33" translate="yes" xml:space="preserve">
          <source>X509Certificate.getNotAfter()</source>
          <target state="translated">X509Certificate.getNotAfter()</target>
        </trans-unit>
        <trans-unit id="9a92edc1a9f8a4fd9110f3acb8fda4b1b3c6ab4e" translate="yes" xml:space="preserve">
          <source>X509Certificate.getNotBefore()</source>
          <target state="translated">X509Certificate.getNotBefore()</target>
        </trans-unit>
        <trans-unit id="27da78eb87b805e2444b1f82afb90e9bc7835b4c" translate="yes" xml:space="preserve">
          <source>X509Certificate.getSerialNumber()</source>
          <target state="translated">X509Certificate.getSerialNumber()</target>
        </trans-unit>
        <trans-unit id="6f8af08573e408c5a6b7bc75cb80ecc6b451cb9e" translate="yes" xml:space="preserve">
          <source>X509Certificate.getSigAlgName()</source>
          <target state="translated">X509Certificate.getSigAlgName()</target>
        </trans-unit>
        <trans-unit id="607a3a0749c8b1dab746e512d28d69eda4f25849" translate="yes" xml:space="preserve">
          <source>X509Certificate.getSigAlgOID()</source>
          <target state="translated">X509Certificate.getSigAlgOID()</target>
        </trans-unit>
        <trans-unit id="02b5c5e5de572fff22a8a962331d8bfb41d52abc" translate="yes" xml:space="preserve">
          <source>X509Certificate.getSigAlgParams()</source>
          <target state="translated">X509Certificate.getSigAlgParams()</target>
        </trans-unit>
        <trans-unit id="abf0378af3325f51ffce60cc5e76863d6e64cb7c" translate="yes" xml:space="preserve">
          <source>X509Certificate.getSignature()</source>
          <target state="translated">X509Certificate.getSignature()</target>
        </trans-unit>
        <trans-unit id="63ea54ab328cdf2e3ffeca94bf86dcb1fc3ba3b2" translate="yes" xml:space="preserve">
          <source>X509Certificate.getSubjectAlternativeNames()</source>
          <target state="translated">X509Certificate.getSubjectAlternativeNames()</target>
        </trans-unit>
        <trans-unit id="db892dc548dadaea8e72280046ee97a7d31aff5e" translate="yes" xml:space="preserve">
          <source>X509Certificate.getSubjectDN()</source>
          <target state="translated">X509Certificate.getSubjectDN()</target>
        </trans-unit>
        <trans-unit id="2efa2a18e43e940888c9b04b569ccc74f02ab50b" translate="yes" xml:space="preserve">
          <source>X509Certificate.getSubjectUniqueID()</source>
          <target state="translated">X509Certificate.getSubjectUniqueID()</target>
        </trans-unit>
        <trans-unit id="28cd8f5a485793a0f7cad8c499296d29e2ac48d4" translate="yes" xml:space="preserve">
          <source>X509Certificate.getSubjectX500Principal()</source>
          <target state="translated">X509Certificate.getSubjectX500Principal()</target>
        </trans-unit>
        <trans-unit id="33d127567465109550abfdba854639b9080179ac" translate="yes" xml:space="preserve">
          <source>X509Certificate.getTBSCertificate()</source>
          <target state="translated">X509Certificate.getTBSCertificate()</target>
        </trans-unit>
        <trans-unit id="cfdd8cbb40490d2380f820a508eb536dc1f316f5" translate="yes" xml:space="preserve">
          <source>X509Certificate.getVersion()</source>
          <target state="translated">X509Certificate.getVersion()</target>
        </trans-unit>
        <trans-unit id="06976b95a9323811dcf9535aa216a7ec252ae43d" translate="yes" xml:space="preserve">
          <source>X509Certificate.verify()</source>
          <target state="translated">X509Certificate.verify()</target>
        </trans-unit>
        <trans-unit id="cc2e615ba7cbd040c10d3be3571d5078c66f8b54" translate="yes" xml:space="preserve">
          <source>X509Data</source>
          <target state="translated">X509Data</target>
        </trans-unit>
        <trans-unit id="ae8f17ee616d8138bab4d4f0e4737dd1f9da13cc" translate="yes" xml:space="preserve">
          <source>X509EncodedKeySpec</source>
          <target state="translated">X509EncodedKeySpec</target>
        </trans-unit>
        <trans-unit id="626dd44a2314d53b33d369a1f08f07026b41ff51" translate="yes" xml:space="preserve">
          <source>X509EncodedKeySpec.getEncoded()</source>
          <target state="translated">X509EncodedKeySpec.getEncoded()</target>
        </trans-unit>
        <trans-unit id="5839e3e80e77157ebc8b17529536f8d4a0941fd3" translate="yes" xml:space="preserve">
          <source>X509EncodedKeySpec.getFormat()</source>
          <target state="translated">X509EncodedKeySpec.getFormat()</target>
        </trans-unit>
        <trans-unit id="d234842c0789a795b12742b8d823eef9ed978f36" translate="yes" xml:space="preserve">
          <source>X509ExtendedKeyManager</source>
          <target state="translated">X509ExtendedKeyManager</target>
        </trans-unit>
        <trans-unit id="b493b829ae35b2377354cbba6507ba8b89557e66" translate="yes" xml:space="preserve">
          <source>X509ExtendedKeyManager.chooseEngineClientAlias()</source>
          <target state="translated">X509ExtendedKeyManager.chooseEngineClientAlias()</target>
        </trans-unit>
        <trans-unit id="268c5e4bfe9daff1d0c54174fb32327af88ecc99" translate="yes" xml:space="preserve">
          <source>X509ExtendedKeyManager.chooseEngineServerAlias()</source>
          <target state="translated">X509ExtendedKeyManager.chooseEngineServerAlias()</target>
        </trans-unit>
        <trans-unit id="4ab0984afa85cd2e8f19d0156d09d7aef547baaf" translate="yes" xml:space="preserve">
          <source>X509ExtendedTrustManager</source>
          <target state="translated">X509ExtendedTrustManager</target>
        </trans-unit>
        <trans-unit id="308fba37a669971bdf5c83e790461904ac757d89" translate="yes" xml:space="preserve">
          <source>X509ExtendedTrustManager.checkClientTrusted()</source>
          <target state="translated">X509ExtendedTrustManager.checkClientTrusted()</target>
        </trans-unit>
        <trans-unit id="2339dd435d457b4c465d46b8f4645892098fa99f" translate="yes" xml:space="preserve">
          <source>X509ExtendedTrustManager.checkServerTrusted()</source>
          <target state="translated">X509ExtendedTrustManager.checkServerTrusted()</target>
        </trans-unit>
        <trans-unit id="80b51310f31ac6afeea08769e4d4b9f50226c664" translate="yes" xml:space="preserve">
          <source>X509Extension</source>
          <target state="translated">X509Extension</target>
        </trans-unit>
        <trans-unit id="e5f5dadf1208209f33dc58be405a7eb9ebcb5d0d" translate="yes" xml:space="preserve">
          <source>X509Extension.getCriticalExtensionOIDs()</source>
          <target state="translated">X509Extension.getCriticalExtensionOIDs()</target>
        </trans-unit>
        <trans-unit id="71bb077b1f322fd963fa780ed45ada48fbd41624" translate="yes" xml:space="preserve">
          <source>X509Extension.getExtensionValue()</source>
          <target state="translated">X509Extension.getExtensionValue()</target>
        </trans-unit>
        <trans-unit id="3e4a2928f4c2275aeba3a445dda0561efd55c7f5" translate="yes" xml:space="preserve">
          <source>X509Extension.getNonCriticalExtensionOIDs()</source>
          <target state="translated">X509Extension.getNonCriticalExtensionOIDs()</target>
        </trans-unit>
        <trans-unit id="5d5e4a7a3f7e1ee7a5fb70fc335737e9208f5abe" translate="yes" xml:space="preserve">
          <source>X509Extension.hasUnsupportedCriticalExtension()</source>
          <target state="translated">X509Extension.hasUnsupportedCriticalExtension()</target>
        </trans-unit>
        <trans-unit id="6220cf77d0d34cae0d597adcdf425c3abce279b5" translate="yes" xml:space="preserve">
          <source>X509IssuerSerial</source>
          <target state="translated">X509IssuerSerial</target>
        </trans-unit>
        <trans-unit id="dd3d3c5c395ab8f86b05f638bc2e2f70a0b2cf27" translate="yes" xml:space="preserve">
          <source>X509KeyManager</source>
          <target state="translated">X509KeyManager</target>
        </trans-unit>
        <trans-unit id="beab63b45c7665300d68a9a410348592b8d02385" translate="yes" xml:space="preserve">
          <source>X509KeyManager.chooseClientAlias()</source>
          <target state="translated">X509KeyManager.chooseClientAlias()</target>
        </trans-unit>
        <trans-unit id="e2ed5257aee8f84943c3c5175c5720366da48e31" translate="yes" xml:space="preserve">
          <source>X509KeyManager.chooseServerAlias()</source>
          <target state="translated">X509KeyManager.chooseServerAlias()</target>
        </trans-unit>
        <trans-unit id="546a546e5697acf8b86342e95b6031173171bf16" translate="yes" xml:space="preserve">
          <source>X509KeyManager.getCertificateChain()</source>
          <target state="translated">X509KeyManager.getCertificateChain()</target>
        </trans-unit>
        <trans-unit id="360d2a2870aa288733c777b743cf1e807d032144" translate="yes" xml:space="preserve">
          <source>X509KeyManager.getClientAliases()</source>
          <target state="translated">X509KeyManager.getClientAliases()</target>
        </trans-unit>
        <trans-unit id="aac579d7db0dfe6ca743f44f435647577da385a7" translate="yes" xml:space="preserve">
          <source>X509KeyManager.getPrivateKey()</source>
          <target state="translated">X509KeyManager.getPrivateKey()</target>
        </trans-unit>
        <trans-unit id="e3ca12c81385c04439e1e70f0e10117530ced15d" translate="yes" xml:space="preserve">
          <source>X509KeyManager.getServerAliases()</source>
          <target state="translated">X509KeyManager.getServerAliases()</target>
        </trans-unit>
        <trans-unit id="3398eab6590ac27408e569fc599faf599df3542b" translate="yes" xml:space="preserve">
          <source>X509TrustManager</source>
          <target state="translated">X509TrustManager</target>
        </trans-unit>
        <trans-unit id="b49a3c450c79104083adf3bf74cf91b3b48f5e5d" translate="yes" xml:space="preserve">
          <source>X509TrustManager.checkClientTrusted()</source>
          <target state="translated">X509TrustManager.checkClientTrusted()</target>
        </trans-unit>
        <trans-unit id="629ebeabcce436e9b7c77948c6913d0dc0dcf13a" translate="yes" xml:space="preserve">
          <source>X509TrustManager.checkServerTrusted()</source>
          <target state="translated">X509TrustManager.checkServerTrusted()</target>
        </trans-unit>
        <trans-unit id="c6144704bd36cad2146f534a13d9f8f6ba6eaabf" translate="yes" xml:space="preserve">
          <source>X509TrustManager.getAcceptedIssuers()</source>
          <target state="translated">X509TrustManager.getAcceptedIssuers()</target>
        </trans-unit>
        <trans-unit id="76c2edae465246aa26b0ff1bee9fd3b755611967" translate="yes" xml:space="preserve">
          <source>XAConnection</source>
          <target state="translated">XAConnection</target>
        </trans-unit>
        <trans-unit id="6787db011941d44e2a8b3eab70c087e56129c431" translate="yes" xml:space="preserve">
          <source>XAConnectionBuilder</source>
          <target state="translated">XAConnectionBuilder</target>
        </trans-unit>
        <trans-unit id="f0523ae2f59dd9e2c59e420113c94bae314feb13" translate="yes" xml:space="preserve">
          <source>XADataSource</source>
          <target state="translated">XADataSource</target>
        </trans-unit>
        <trans-unit id="bb284274415eb83f5f2baa08b5fc1d9f2a6efa61" translate="yes" xml:space="preserve">
          <source>XAER_ASYNC</source>
          <target state="translated">XAER_ASYNC</target>
        </trans-unit>
        <trans-unit id="dadbb855e925668e84ee8a8ef3783fc2c8d1de90" translate="yes" xml:space="preserve">
          <source>XAER_DUPID</source>
          <target state="translated">XAER_DUPID</target>
        </trans-unit>
        <trans-unit id="5b22cf5171ebbc5232aa6b8051b43cd1ff53c18a" translate="yes" xml:space="preserve">
          <source>XAER_INVAL</source>
          <target state="translated">XAER_INVAL</target>
        </trans-unit>
        <trans-unit id="fbf0ba17d7abb15669590db0ad5a834ef16539cd" translate="yes" xml:space="preserve">
          <source>XAER_NOTA</source>
          <target state="translated">XAER_NOTA</target>
        </trans-unit>
        <trans-unit id="3241a99d17fea78a9a97d02a84b4f7a1f0dee77d" translate="yes" xml:space="preserve">
          <source>XAER_OUTSIDE</source>
          <target state="translated">XAER_OUTSIDE</target>
        </trans-unit>
        <trans-unit id="5cb21154c19010904ddcbce89b38ae6fcf3b497d" translate="yes" xml:space="preserve">
          <source>XAER_PROTO</source>
          <target state="translated">XAER_PROTO</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
