<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="phoenix">
    <body>
      <group id="phoenix">
        <trans-unit id="250e5a7518c50a847597afadb1487eab6b2f819d" translate="yes" xml:space="preserve">
          <source>For example, this schema specification</source>
          <target state="translated">例如,这个模式规范</target>
        </trans-unit>
        <trans-unit id="33fc1b541955c11c7a3a376c9e4b58f9c57708b1" translate="yes" xml:space="preserve">
          <source>For example, to avoid validating an email until the field is blurred, while validating the username at most every 2 seconds after a user changes the field:</source>
          <target state="translated">例如,为了避免在字段模糊之前验证电子邮件,而在用户更改字段后最多每2秒验证一次用户名。</target>
        </trans-unit>
        <trans-unit id="10a90aa8783fdb171b94edeeedb9421523ade4a7" translate="yes" xml:space="preserve">
          <source>For example, to get all posts while running the &quot;lower(?)&quot; function in the database where &lt;code&gt;p.title&lt;/code&gt; is interpolated in place of &lt;code&gt;?&lt;/code&gt;, one can write:</source>
          <target state="translated">例如，要在数据库中运行&amp;ldquo; lower（？）&amp;rdquo;功能时获取所有帖子，在数据库中插入了 &lt;code&gt;p.title&lt;/code&gt; 而不是 &lt;code&gt;?&lt;/code&gt; 。，可以这样写：</target>
        </trans-unit>
        <trans-unit id="c268739f07b40440ff73d328a7a5b1783a45e413" translate="yes" xml:space="preserve">
          <source>For example, to get all posts while running the &amp;ldquo;lower(?)&amp;rdquo; function in the database where &lt;code&gt;p.title&lt;/code&gt; is interpolated in place of &lt;code&gt;?&lt;/code&gt;, one can write:</source>
          <target state="translated">例如，要在数据库中运行&amp;ldquo; lower（？）&amp;rdquo;功能时获取所有帖子，在数据库中插入了 &lt;code&gt;p.title&lt;/code&gt; 而不是 &lt;code&gt;?&lt;/code&gt; 。，可以这样写：</target>
        </trans-unit>
        <trans-unit id="712a75ed27773b36d6dab2e762ed7d44810db42c" translate="yes" xml:space="preserve">
          <source>For example, to handle &quot;phx_leave&quot; messages, which is recommended to be handled by all channel implementations, one may do:</source>
          <target state="translated">例如,要处理 &quot;phx_leave &quot;消息,建议由所有通道实现来处理,可以这样做。</target>
        </trans-unit>
        <trans-unit id="5ed93477deaeccf8f807f263aeb1aa8094e246a0" translate="yes" xml:space="preserve">
          <source>For example, to implement infinite scrolling, one might do:</source>
          <target state="translated">例如,要实现无限滚动,可以这样做。</target>
        </trans-unit>
        <trans-unit id="aaa80c213499c1e4e2ebabd1a68490863d99b23c" translate="yes" xml:space="preserve">
          <source>For example, to run &lt;code&gt;phoenix.server&lt;/code&gt; without checking dependencies:</source>
          <target state="translated">例如，要运行 &lt;code&gt;phoenix.server&lt;/code&gt; 而不检查依赖关系：</target>
        </trans-unit>
        <trans-unit id="52d1730d810a3213b8ae35feb4a46172562acd1e" translate="yes" xml:space="preserve">
          <source>For example, to run &lt;code&gt;phx.server&lt;/code&gt; without checking dependencies:</source>
          <target state="translated">例如，运行 &lt;code&gt;phx.server&lt;/code&gt; 而不检查依赖项：</target>
        </trans-unit>
        <trans-unit id="eb24d75387baa2ce86c09393fcd13aa1468c60e5" translate="yes" xml:space="preserve">
          <source>For example, to run &lt;code&gt;phx.server&lt;/code&gt; without recompiling:</source>
          <target state="translated">例如，要运行 &lt;code&gt;phx.server&lt;/code&gt; 而无需重新编译：</target>
        </trans-unit>
        <trans-unit id="ee191307a2caef15a68ebec9dbfb940793de8194" translate="yes" xml:space="preserve">
          <source>For example, we can use the &lt;a href=&quot;#push/3&quot;&gt;&lt;code&gt;push/3&lt;/code&gt;&lt;/a&gt; function in the test to push messages to the channel (it will invoke &lt;code&gt;handle_in/3&lt;/code&gt;):</source>
          <target state="translated">例如，我们可以在测试中使用&lt;a href=&quot;#push/3&quot;&gt; &lt;code&gt;push/3&lt;/code&gt; &lt;/a&gt;函数将消息推送到通道（它将调用 &lt;code&gt;handle_in/3&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="f8d98d4e6c4113b73111361aa0eeba5ba04454b2" translate="yes" xml:space="preserve">
          <source>For example, you can define a new &lt;code&gt;live.html.leex&lt;/code&gt; layout with dynamic content. You must use &lt;code&gt;@inner_content&lt;/code&gt; where the output of the actual template will be placed at:</source>
          <target state="translated">例如，您可以定义一个包含动态内容的新 &lt;code&gt;live.html.leex&lt;/code&gt; 布局。您必须使用 &lt;code&gt;@inner_content&lt;/code&gt; ，将实际模板的输出放置在以下位置：</target>
        </trans-unit>
        <trans-unit id="a9c7054e90670cbc4ed17910aed6f38d7ea04bcd" translate="yes" xml:space="preserve">
          <source>For example, you may define it as:</source>
          <target state="translated">例如,你可以将其定义为:</target>
        </trans-unit>
        <trans-unit id="48f038621e4427f7e69c128ca2c67366fe95857d" translate="yes" xml:space="preserve">
          <source>For example, you may way to generate an https URL from an http request. You could define a function like the following:</source>
          <target state="translated">例如,你可以从一个http请求中生成一个https URL。你可以定义一个类似下面的函数。</target>
        </trans-unit>
        <trans-unit id="d0d6a26a7fdf008c2173a9711decbd13ce937b5b" translate="yes" xml:space="preserve">
          <source>For example, your &lt;code&gt;MyAppWeb.ErrorHelpers&lt;/code&gt; may use this function:</source>
          <target state="translated">例如，您的 &lt;code&gt;MyAppWeb.ErrorHelpers&lt;/code&gt; 可以使用以下功能：</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="011fbae011e4f284a1bc4a3f9f03b9f3860ee774" translate="yes" xml:space="preserve">
          <source>For further details refer to &lt;a href=&quot;plug.rewriteon&quot;&gt;&lt;code&gt;Plug.RewriteOn&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有关更多详细信息，请参见&lt;a href=&quot;plug.rewriteon&quot;&gt; &lt;code&gt;Plug.RewriteOn&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2ed904b738db7c4a3075c6e430608f75222bb23b" translate="yes" xml:space="preserve">
          <source>For graceful exits, the channel will notify the transort it is gracefully terminating via the following message:</source>
          <target state="translated">对于优雅的退出,通道将通过以下消息通知transort它正在优雅地终止。</target>
        </trans-unit>
        <trans-unit id="92926b5f41b64990dae4306af8842a9e143deef7" translate="yes" xml:space="preserve">
          <source>For instance, here is how you would pass the SSL options to the Cowboy adapter:</source>
          <target state="translated">例如,这里是你如何将SSL选项传递给Cowboy适配器。</target>
        </trans-unit>
        <trans-unit id="29be4bc5c201dd9ca580d6ef9202fab40016be15" translate="yes" xml:space="preserve">
          <source>For instance, imagine you wrote:</source>
          <target state="translated">例如,想象你写道:</target>
        </trans-unit>
        <trans-unit id="c93a52e328a78cb6709c141ab080c4cb225cf8de" translate="yes" xml:space="preserve">
          <source>For instance, to receive all query events published by a repository called &lt;code&gt;MyApp.Repo&lt;/code&gt;, one would define a module:</source>
          <target state="translated">例如，要接收由名为 &lt;code&gt;MyApp.Repo&lt;/code&gt; 的存储库发布的所有查询事件，可以定义一个模块：</target>
        </trans-unit>
        <trans-unit id="0b013b3f06f541fc367f235e64b28c47860501ef" translate="yes" xml:space="preserve">
          <source>For integration with client-side libraries which require a broader access to full DOM management, the &lt;code&gt;LiveSocket&lt;/code&gt; constructor accepts a &lt;code&gt;dom&lt;/code&gt; option with an &lt;code&gt;onBeforeElUpdated&lt;/code&gt; callback. The &lt;code&gt;fromEl&lt;/code&gt; and &lt;code&gt;toEl&lt;/code&gt; DOM nodes are passed to the function just before the DOM patch operations occurs in LiveView. This allows external libraries to (re)initialize DOM elements or copy attributes as necessary as LiveView performs its own patch operations. The update operation cannot be cancelled or deferred, and the return value is ignored. For example, the following option could be used to add &lt;a href=&quot;https://github.com/alpinejs/alpine&quot;&gt;Alpine.js&lt;/a&gt; support to your project:</source>
          <target state="translated">为了与需要更广泛访问完整DOM管理的客户端库集成， &lt;code&gt;LiveSocket&lt;/code&gt; 构造函数接受带有 &lt;code&gt;onBeforeElUpdated&lt;/code&gt; 回调的 &lt;code&gt;dom&lt;/code&gt; 选项。该 &lt;code&gt;fromEl&lt;/code&gt; 和 &lt;code&gt;toEl&lt;/code&gt; DOM节点传递到发生在实时查看之前的DOM修补程序操作的功能。这样，当LiveView执行自己的修补程序操作时，外部库就可以（重新）初始化DOM元素或根据需要复制属性。无法取消或推迟更新操作，并且忽略返回值。例如，以下选项可用于将&lt;a href=&quot;https://github.com/alpinejs/alpine&quot;&gt;Alpine.js&lt;/a&gt;支持添加到您的项目中：</target>
        </trans-unit>
        <trans-unit id="6efb74f6dd168bb1337862be11f36c1c678d8fed" translate="yes" xml:space="preserve">
          <source>For internationalization with &lt;a href=&quot;https://hexdocs.pm/gettext/Gettext.html&quot;&gt;gettext&lt;/a&gt;, the locale used within your Plug pipeline can be stored in the Plug session and restored within your LiveView mount. For example, after user signs in or preference changes, you can write the locale to the session:</source>
          <target state="translated">为了使用&lt;a href=&quot;https://hexdocs.pm/gettext/Gettext.html&quot;&gt;gettext&lt;/a&gt;进行国际化，可以将您在Plug管道中使用的语言环境存储在Plug会话中，并在LiveView挂载中进行还原。例如，在用户登录或首选项更改后，您可以将语言环境写入会话：</target>
        </trans-unit>
        <trans-unit id="46b6a50a25c3fab8c56cff540874a439588e5f9c" translate="yes" xml:space="preserve">
          <source>For larger templates, you can place them in a file in the same directory and same name as the LiveView. For example, if the file above is placed at &lt;code&gt;lib/my_app_web/live/thermostat_live.ex&lt;/code&gt;, you can also remove the &lt;a href=&quot;#c:render/1&quot;&gt;&lt;code&gt;render/1&lt;/code&gt;&lt;/a&gt; definition above and instead put the template code at &lt;code&gt;lib/my_app_web/live/thermostat_live.html.leex&lt;/code&gt;.</source>
          <target state="translated">对于较大的模板，您可以将它们放置在与LiveView相同目录和名称的文件中。例如，如果上面的文件位于 &lt;code&gt;lib/my_app_web/live/thermostat_live.ex&lt;/code&gt; ，则您也可以删除上面的&lt;a href=&quot;#c:render/1&quot;&gt; &lt;code&gt;render/1&lt;/code&gt; &lt;/a&gt;定义，而将模板代码放在 &lt;code&gt;lib/my_app_web/live/thermostat_live.html.leex&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d8cfc16e6569e0061a6e7eac0c582cf092d25b4b" translate="yes" xml:space="preserve">
          <source>For live page navigation via &lt;code&gt;live_redirect&lt;/code&gt; and &lt;code&gt;live_patch&lt;/code&gt;, as well as form submits via &lt;code&gt;phx-submit&lt;/code&gt;, the JavaScript events &lt;code&gt;&quot;phx:page-loading-start&quot;&lt;/code&gt; and &lt;code&gt;&quot;phx:page-loading-stop&quot;&lt;/code&gt; are dispatched on window. Additionally, any &lt;code&gt;phx-&lt;/code&gt; event may dispatch page loading events by annotating the DOM element with &lt;code&gt;phx-page-loading&lt;/code&gt;. This is useful for showing main page loading status, for example:</source>
          <target state="translated">对于通过 &lt;code&gt;live_redirect&lt;/code&gt; 和 &lt;code&gt;live_patch&lt;/code&gt; 进行实时页面导航，以及通过 &lt;code&gt;phx-submit&lt;/code&gt; 提交表单，JavaScript事件 &lt;code&gt;&quot;phx:page-loading-start&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;phx:page-loading-stop&quot;&lt;/code&gt; 会在窗口上调度。另外，任何 &lt;code&gt;phx-&lt;/code&gt; 事件都可以通过用 &lt;code&gt;phx-page-loading&lt;/code&gt; 注释DOM元素来调度页面加载事件。这对于显示主页加载状态很有用，例如：</target>
        </trans-unit>
        <trans-unit id="fa8555f356953d9e411a255f6f895244740945a0" translate="yes" xml:space="preserve">
          <source>For logging out, we simply defined a form that sends the &lt;code&gt;DELETE&lt;/code&gt; HTTP method to server's session delete path. Now if you visit the sign-in page at &lt;a href=&quot;http://localhost:4000/sessions/new&quot;&gt;http://localhost:4000/sessions/new&lt;/a&gt; and enter a bad email address, you should be greeted with your flash message. Entering a valid email address will redirect to the home page with a success flash notice.</source>
          <target state="translated">为了注销，我们仅定义了一个表单，该表单将 &lt;code&gt;DELETE&lt;/code&gt; HTTP方法发送到服务器的会话删除路径。现在，如果您访问位于&lt;a href=&quot;http://localhost:4000/sessions/new&quot;&gt;http：// localhost：4000 / sessions / new&lt;/a&gt;的登录页面并输入错误的电子邮件地址，则应该收到Flash消息。输入有效的电子邮件地址将重定向到主页，并带有成功的Flash通知。</target>
        </trans-unit>
        <trans-unit id="d9022c5a0c8964d6ea0f8ae4b3dab94f265d3706" translate="yes" xml:space="preserve">
          <source>For maps to work in such databases, Ecto will need a JSON library. By default Ecto will use &lt;a href=&quot;http://github.com/michalmuskala/jason&quot;&gt;Jason&lt;/a&gt; which needs to be added to your deps in &lt;code&gt;mix.exs&lt;/code&gt;:</source>
          <target state="translated">为了使地图在这样的数据库中工作，Ecto将需要一个JSON库。默认情况下，Ecto将使用&lt;a href=&quot;http://github.com/michalmuskala/jason&quot;&gt;Jason&lt;/a&gt;，需要将其添加到 &lt;code&gt;mix.exs&lt;/code&gt; 中的dep中：</target>
        </trans-unit>
        <trans-unit id="aabcef1b6cb1a82809871c7e4c5c1fbeeb64b061" translate="yes" xml:space="preserve">
          <source>For maps to work in such databases, Ecto will need a JSON library. By default Ecto will use &lt;a href=&quot;https://github.com/michalmuskala/jason&quot;&gt;Jason&lt;/a&gt; which needs to be added to your deps in &lt;code&gt;mix.exs&lt;/code&gt;:</source>
          <target state="translated">为了使地图在这样的数据库中工作，Ecto将需要一个JSON库。默认情况下，Ecto将使用&lt;a href=&quot;https://github.com/michalmuskala/jason&quot;&gt;Jason&lt;/a&gt;，需要将其添加到 &lt;code&gt;mix.exs&lt;/code&gt; 中的dep中：</target>
        </trans-unit>
        <trans-unit id="ad179f69fed4d39adf90ca8b668b0dcf60ff8610" translate="yes" xml:space="preserve">
          <source>For more information on ETS tables, visit the Erlang documentation at &lt;a href=&quot;http://www.erlang.org/doc/man/ets.html.&quot;&gt;http://www.erlang.org/doc/man/ets.html.&lt;/a&gt;</source>
          <target state="translated">有关ETS表的更多信息，请访问&lt;a href=&quot;http://www.erlang.org/doc/man/ets.html.&quot;&gt;http://www.erlang.org/doc/man/ets.html上&lt;/a&gt;的Erlang文档。</target>
        </trans-unit>
        <trans-unit id="8aba17a165f8cb7c095fcd429f135914d9b29c38" translate="yes" xml:space="preserve">
          <source>For more information on ETS tables, visit the Erlang documentation at http://www.erlang.org/doc/man/ets.html.</source>
          <target state="translated">关于ETS表的更多信息,请访问Erlang文档:http://www.erlang.org/doc/man/ets.html。</target>
        </trans-unit>
        <trans-unit id="1a5b5eefc79a13a3a9a181a1c7ba5819905b9c98" translate="yes" xml:space="preserve">
          <source>For more information on casting, see &lt;a href=&quot;ecto.type#c:cast/1&quot;&gt;&lt;code&gt;Ecto.Type.cast/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有关转换的更多信息，请参见&lt;a href=&quot;ecto.type#c:cast/1&quot;&gt; &lt;code&gt;Ecto.Type.cast/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="959df3fd0cfdc74970dc2d4527558d71775f58df" translate="yes" xml:space="preserve">
          <source>For more information on dumping, see &lt;a href=&quot;ecto.type#c:dump/1&quot;&gt;&lt;code&gt;Ecto.Type.dump/1&lt;/code&gt;&lt;/a&gt;. Note that this callback &lt;em&gt;will&lt;/em&gt; be called when dumping a &lt;code&gt;nil&lt;/code&gt; value, unlike &lt;a href=&quot;ecto.type#c:dump/1&quot;&gt;&lt;code&gt;Ecto.Type.dump/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有关转储的更多信息，请参见&lt;a href=&quot;ecto.type#c:dump/1&quot;&gt; &lt;code&gt;Ecto.Type.dump/1&lt;/code&gt; &lt;/a&gt;。请注意，转储 &lt;code&gt;nil&lt;/code&gt; 值时&lt;em&gt;将&lt;/em&gt;调用此回调，这与&lt;a href=&quot;ecto.type#c:dump/1&quot;&gt; &lt;code&gt;Ecto.Type.dump/1&lt;/code&gt; &lt;/a&gt;不同。</target>
        </trans-unit>
        <trans-unit id="39c5c587c188573e903e09204ede4dad88b83c93" translate="yes" xml:space="preserve">
          <source>For more information on embedding, see &lt;a href=&quot;ecto.type#c:embed_as/1&quot;&gt;&lt;code&gt;Ecto.Type.embed_as/1&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">有关嵌入的更多信息，请参见&lt;a href=&quot;ecto.type#c:embed_as/1&quot;&gt; &lt;code&gt;Ecto.Type.embed_as/1&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="aaf3cc1f04b722de715fcdda4f43335a0fa29ca2" translate="yes" xml:space="preserve">
          <source>For more information on how to modify your database schema please refer to the ecto's migration dsl &lt;a href=&quot;https://hexdocs.pm/ecto_sql/Ecto.Migration.html&quot;&gt;ecto migration docs&lt;/a&gt;. For example, to alter an existing schema see the documentation on ecto&amp;rsquo;s &lt;a href=&quot;https://hexdocs.pm/ecto_sql/Ecto.Migration.html#alter/2&quot;&gt;&lt;code&gt;alter/2&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">有关如何修改数据库架构的更多信息，请参考ecto的迁移dsl &lt;a href=&quot;https://hexdocs.pm/ecto_sql/Ecto.Migration.html&quot;&gt;ecto迁移文档&lt;/a&gt;。例如，要更改现有模式，请参见ecto的&lt;a href=&quot;https://hexdocs.pm/ecto_sql/Ecto.Migration.html#alter/2&quot;&gt; &lt;code&gt;alter/2&lt;/code&gt; &lt;/a&gt;函数的文档。</target>
        </trans-unit>
        <trans-unit id="d5fe3d8e56fdc17686d2e30d6867234c608125eb" translate="yes" xml:space="preserve">
          <source>For more information on loading, see &lt;a href=&quot;ecto.type#c:load/1&quot;&gt;&lt;code&gt;Ecto.Type.load/1&lt;/code&gt;&lt;/a&gt;. Note that this callback &lt;em&gt;will&lt;/em&gt; be called when loading a &lt;code&gt;nil&lt;/code&gt; value, unlike &lt;a href=&quot;ecto.type#c:load/1&quot;&gt;&lt;code&gt;Ecto.Type.load/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有关加载的更多信息，请参见&lt;a href=&quot;ecto.type#c:load/1&quot;&gt; &lt;code&gt;Ecto.Type.load/1&lt;/code&gt; &lt;/a&gt;。请注意，与&lt;a href=&quot;ecto.type#c:load/1&quot;&gt; &lt;code&gt;Ecto.Type.load/1&lt;/code&gt; &lt;/a&gt;不同，加载 &lt;code&gt;nil&lt;/code&gt; 值时&lt;em&gt;将&lt;/em&gt;调用此回调。</target>
        </trans-unit>
        <trans-unit id="7497a10d07df46f2b4b817a1e9655c0d2b08b83d" translate="yes" xml:space="preserve">
          <source>For more information on named bindings see &quot;Named bindings&quot; in this module doc.</source>
          <target state="translated">关于命名绑定的更多信息请参见本模块文档中的 &quot;命名绑定&quot;。</target>
        </trans-unit>
        <trans-unit id="86dc89db4b6ce2937afc00f7c25bd37c98b90786" translate="yes" xml:space="preserve">
          <source>For more information on named bindings see &amp;ldquo;Named bindings&amp;rdquo; in this module doc.</source>
          <target state="translated">有关命名绑定的更多信息，请参见本模块文档中的&amp;ldquo;命名绑定&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="f575930ba40732ed5321d4dfc902877f97a260e8" translate="yes" xml:space="preserve">
          <source>For more information on schema types, see &lt;a href=&quot;ecto.type#c:type/0&quot;&gt;&lt;code&gt;Ecto.Type.type/0&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">有关架构类型的更多信息，请参见&lt;a href=&quot;ecto.type#c:type/0&quot;&gt; &lt;code&gt;Ecto.Type.type/0&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4afd6eff44c1ca0a8cddb75ff5a6a8d39a20181b" translate="yes" xml:space="preserve">
          <source>For most use cases, this is all you need and form recovery will happen without consideration. In some cases, where forms are built step-by-step in a stateful fashion, it may require extra recovery handling on the server outside of your existing &lt;code&gt;phx-change&lt;/code&gt; callback code. To enable specialized recovery, provide a &lt;code&gt;phx-auto-recover&lt;/code&gt; binding on the form to specify a different event to trigger for recovery, which will receive the form params as usual. For example, imagine a LiveView wizard form where the form is stateful and built based on what step the user is on and by prior selections:</source>
          <target state="translated">对于大多数用例，这就是您所需要的，并且无需考虑就可以进行表单恢复。在某些情况下，以有状态的方式逐步构建表单时，可能需要在现有 &lt;code&gt;phx-change&lt;/code&gt; 回调代码之外的服务器上进行额外的恢复处理。要启用专业恢复，请在表单上提供 &lt;code&gt;phx-auto-recover&lt;/code&gt; 绑定以指定触发恢复的其他事件，该事件将照常接收表单参数。例如，想象一下一个LiveView向导表单，其中该表单是有状态的，并根据用户所处的步骤以及先前的选择来构建：</target>
        </trans-unit>
        <trans-unit id="e7028da18781b4d884d99f3ee7b8c02bf1245d37" translate="yes" xml:space="preserve">
          <source>For new applications, the ErrorView looks like this:</source>
          <target state="translated">对于新的应用程序,ErrorView看起来像这样。</target>
        </trans-unit>
        <trans-unit id="282464bf76622e75b3765b0efb4b281d44c1c143" translate="yes" xml:space="preserve">
          <source>For now it doesn't matter that we don't actually have a &lt;code&gt;HelloWeb.UserController&lt;/code&gt;.</source>
          <target state="translated">现在，我们实际上没有 &lt;code&gt;HelloWeb.UserController&lt;/code&gt; 没关系。</target>
        </trans-unit>
        <trans-unit id="a56f6e0fcb2fe492fc12d986fac6e6954793e6c8" translate="yes" xml:space="preserve">
          <source>For now, it suffices to say that each Plug defines a slice of request processing. In the endpoint you will find a skeleton roughly like this:</source>
          <target state="translated">现在,只要说每个Plug定义了一个请求处理的片断就够了。在端点中,你会发现一个骨架大致是这样的。</target>
        </trans-unit>
        <trans-unit id="886bdd0ff64c15f2da68e1f96f4b3b6b7cac28a4" translate="yes" xml:space="preserve">
          <source>For now, user credentials will contain only email information. Our first order of business is to decide where credentials live in the application. We have our &lt;code&gt;Accounts&lt;/code&gt; context, which manages user accounts. User credentials is a natural fit here. Phoenix is also smart enough to generate code inside an existing context, which makes adding new resources to a context a breeze. Run the following command at your project root:</source>
          <target state="translated">目前，用户凭据将仅包含电子邮件信息。我们的首要任务是确定凭据在应用程序中的何处。我们拥有&amp;ldquo; &lt;code&gt;Accounts&lt;/code&gt; 上下文，该上下文管理用户帐户。用户凭据在这里很自然。Phoenix还足够聪明，可以在现有上下文中生成代码，从而轻松地向上下文添加新资源。在您的项目根目录下运行以下命令：</target>
        </trans-unit>
        <trans-unit id="0e16e993fd473ea76243c2fdc4e544518d69c0e0" translate="yes" xml:space="preserve">
          <source>For now, we'll ignore the pipelines and the use of &lt;code&gt;scope&lt;/code&gt; here and just focus on adding a route. We will discuss those in &lt;a href=&quot;routing&quot;&gt;the Routing guide&lt;/a&gt;.</source>
          <target state="translated">现在，我们将在此处忽略管道和 &lt;code&gt;scope&lt;/code&gt; 的使用，仅关注添加路由。我们将在&lt;a href=&quot;routing&quot;&gt;&amp;ldquo;路由指南&amp;rdquo;中进行&lt;/a&gt;讨论。</target>
        </trans-unit>
        <trans-unit id="47623288c6f7e25e0286078a9bc973202790385a" translate="yes" xml:space="preserve">
          <source>For options and examples see documentation of &lt;a href=&quot;#embeds_many/3&quot;&gt;&lt;code&gt;embeds_many/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有关选项和示例，请参见&lt;a href=&quot;#embeds_many/3&quot;&gt; &lt;code&gt;embeds_many/3&lt;/code&gt; 的&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="5fa05355f3967ad546f604ed6817bb6dc2f2810a" translate="yes" xml:space="preserve">
          <source>For options and examples see documentation of &lt;a href=&quot;#embeds_one/3&quot;&gt;&lt;code&gt;embeds_one/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有关选项和示例，请参见&lt;a href=&quot;#embeds_one/3&quot;&gt; &lt;code&gt;embeds_one/3&lt;/code&gt; 的&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="4f762b81db42047b1f8e5c705f799a2c497f5c89" translate="yes" xml:space="preserve">
          <source>For preloads, the selected fields may be specified from the parent:</source>
          <target state="translated">对于预加载,可从父版中指定所选字段。</target>
        </trans-unit>
        <trans-unit id="99b2911ab549294cdbf33bc1636f3d5c92514f4c" translate="yes" xml:space="preserve">
          <source>For proper form error tag updates, the error tag must specify which input it belongs to. This is accomplished with the &lt;code&gt;phx-feedback-for&lt;/code&gt; attribute. Failing to add the &lt;code&gt;phx-feedback-for&lt;/code&gt; attribute will result in displaying error messages for form fields that the user has not changed yet (e.g. required fields further down on the page).</source>
          <target state="translated">为了正确更新表单错误标签，错误标签必须指定其属于哪个输入。这是通过 &lt;code&gt;phx-feedback-for&lt;/code&gt; 属性完成的。未能添加 &lt;code&gt;phx-feedback-for&lt;/code&gt; 属性将导致显示用户尚未更改的表单字段的错误消息（例如，页面下方的必填字段）。</target>
        </trans-unit>
        <trans-unit id="a741dc08e6f8380624e48ef2c45211a0061c62e0" translate="yes" xml:space="preserve">
          <source>For relational databases, this means the RETURNING option of those statements is used. For this reason, MySQL does not support this option and will raise an error if a schema is inserted/updated with read after writes fields.</source>
          <target state="translated">对于关系型数据库,这意味着使用了这些语句的RETURNING选项。出于这个原因,MySQL不支持这个选项,如果一个模式被插入/更新了读后写字段,会引发一个错误。</target>
        </trans-unit>
        <trans-unit id="00597a349fb6a62ad730ce7a374a1fd3fdf60dfa" translate="yes" xml:space="preserve">
          <source>For relations, these functions will return the changeset data with changes applied. To retrieve raw changesets, please use &lt;a href=&quot;#get_change/3&quot;&gt;&lt;code&gt;get_change/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">对于关系，这些函数将返回已应用更改的变更集数据。要检索原始变更集，请使用&lt;a href=&quot;#get_change/3&quot;&gt; &lt;code&gt;get_change/3&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7a48c0cb962716952cf875975eac6007455ad2f0" translate="yes" xml:space="preserve">
          <source>For relations, these functions will return the changeset original data with changes applied. To retrieve raw changesets, please use &lt;a href=&quot;#fetch_change/2&quot;&gt;&lt;code&gt;fetch_change/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">对于关系，这些函数将返回已应用更改的变更集原始数据。要检索原始变更集，请使用&lt;a href=&quot;#fetch_change/2&quot;&gt; &lt;code&gt;fetch_change/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1e438c72243585ad24059c796c9627a8dd79cb75" translate="yes" xml:space="preserve">
          <source>For requests with a different request method, this plug will only fetch the query params.</source>
          <target state="translated">对于采用不同请求方式的请求,这个插件将只获取查询参数。</target>
        </trans-unit>
        <trans-unit id="9e5eaa2ebb08d285e2d07000eb79f966c0f46f7d" translate="yes" xml:space="preserve">
          <source>For responsive images, pass a map, list or string through &lt;code&gt;:srcset&lt;/code&gt;.</source>
          <target state="translated">对于响应式图像，请通过 &lt;code&gt;:srcset&lt;/code&gt; 传递地图，列表或字符串。</target>
        </trans-unit>
        <trans-unit id="fd8f14bec39884e1bac29f6af6c015070597aa14" translate="yes" xml:space="preserve">
          <source>For security reasons, the form data and parameter values are never re-used in &lt;a href=&quot;#password_input/3&quot;&gt;&lt;code&gt;password_input/3&lt;/code&gt;&lt;/a&gt;. Pass the value explicitly if you would like to set one.</source>
          <target state="translated">出于安全原因，永远不会在&lt;a href=&quot;#password_input/3&quot;&gt; &lt;code&gt;password_input/3&lt;/code&gt; 中&lt;/a&gt;重复使用表单数据和参数值。如果要设置一个，则显式传递该值。</target>
        </trans-unit>
        <trans-unit id="0c9c55ef99a1b85442974d55919cef61666635f0" translate="yes" xml:space="preserve">
          <source>For security, &lt;code&gt;:to&lt;/code&gt; only accepts paths. Use the &lt;code&gt;:external&lt;/code&gt; option to redirect to any URL.</source>
          <target state="translated">为了安全起见， &lt;code&gt;:to&lt;/code&gt; 只接受路径。使用 &lt;code&gt;:external&lt;/code&gt; 选项重定向到任何URL。</target>
        </trans-unit>
        <trans-unit id="c3bb42014432d8496efa23344529a842fdecd850" translate="yes" xml:space="preserve">
          <source>For solutions that operate below the HTTP layer, e.g. using HAProxy, the client IP address can sometimes be passed through the 'PROXY protocol'. Extracting this information must be handled by the Plug adapter. Please refer to the Plug adapter documentation for further information.</source>
          <target state="translated">对于在HTTP层以下操作的解决方案,例如使用HAProxy,客户端IP地址有时可以通过 &quot;PROXY协议 &quot;传递。提取这些信息必须由Plug适配器来处理。更多信息请参考Plug适配器文档。</target>
        </trans-unit>
        <trans-unit id="d04c64cf7b36c911c0f825bd502b4d9dcf238921" translate="yes" xml:space="preserve">
          <source>For staging and production it is necessary to obtain a CA-signed certificate from a trusted Certificate Authority, such as &lt;a href=&quot;https://letsencrypt.org&quot;&gt;Let's Encrypt&lt;/a&gt;. Certificates issued by a CA usually come with an additional file containing one or more certificates that make up the 'CA chain'.</source>
          <target state="translated">为了进行登台和生产，必须从受信任的证书颁发机构（例如&lt;a href=&quot;https://letsencrypt.org&quot;&gt;Let's Encrypt）&lt;/a&gt;获取CA签名的证书。由CA颁发的证书通常带有一个附加文件，其中包含一个或多个构成&amp;ldquo; CA链&amp;rdquo;的证书。</target>
        </trans-unit>
        <trans-unit id="fff536d187e3538d188ab49aed8a72744fd84f9c" translate="yes" xml:space="preserve">
          <source>For stylesheet files found under the given path, Phoenix will replace asset references with the digested paths, as long as the asset exists in the generated cache manifest.</source>
          <target state="translated">对于在给定路径下找到的样式表文件,只要资产存在于生成的缓存清单中,Phoenix将用消化后的路径替换资产引用。</target>
        </trans-unit>
        <trans-unit id="8c36fe9b2a7c749e8571085eb2af112fd9083639" translate="yes" xml:space="preserve">
          <source>For such cases, just pass an atom representing the action to dispatch:</source>
          <target state="translated">对于这种情况,只需传递一个代表动作的原子来调度即可。</target>
        </trans-unit>
        <trans-unit id="3e369afedac592425ec8d8e891860e0bbe16c64c" translate="yes" xml:space="preserve">
          <source>For such cases, you need to set the &lt;code&gt;@endpoint&lt;/code&gt; attribute to your controller and pass an atom representing the action to dispatch:</source>
          <target state="translated">在这种情况下，您需要为控制器设置 &lt;code&gt;@endpoint&lt;/code&gt; 属性，并传递一个表示要分派的动作的原子：</target>
        </trans-unit>
        <trans-unit id="c0c25469cbfa8dfe50c32adf8947d072adc5da07" translate="yes" xml:space="preserve">
          <source>For testing purposes it may be sufficient to use a self-signed certificate. Such certificates generally result in warnings in browsers and failed connections from other tools, but these can be overridden to enable HTTPS testing. This is especially useful for local testing of HTTP 2, which is only specified over TLS.</source>
          <target state="translated">为了测试的目的,使用自签名的证书可能就足够了。这样的证书通常会导致浏览器的警告和其他工具的连接失败,但这些都可以被覆盖以实现HTTPS测试。这对于HTTP 2的本地测试特别有用,因为HTTP 2只在TLS上指定。</target>
        </trans-unit>
        <trans-unit id="20a1f9c6c25c59a377c89a60f258c5d3b208854e" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;:decimal&lt;/code&gt; type, &lt;code&gt;+Infinity&lt;/code&gt;, &lt;code&gt;-Infinity&lt;/code&gt;, and &lt;code&gt;NaN&lt;/code&gt; values are not supported, even though the &lt;a href=&quot;https://hexdocs.pm/decimal/1.5.0/Decimal.html&quot;&gt;&lt;code&gt;Decimal&lt;/code&gt;&lt;/a&gt; library handles them. To support them, you can create a custom type.</source>
          <target state="translated">对于 &lt;code&gt;:decimal&lt;/code&gt; 类型，即使&lt;a href=&quot;https://hexdocs.pm/decimal/1.5.0/Decimal.html&quot;&gt; &lt;code&gt;Decimal&lt;/code&gt; &lt;/a&gt;库可以处理它们，也不支持 &lt;code&gt;+Infinity&lt;/code&gt; ， &lt;code&gt;-Infinity&lt;/code&gt; 和 &lt;code&gt;NaN&lt;/code&gt; 值。为了支持它们，您可以创建一个自定义类型。</target>
        </trans-unit>
        <trans-unit id="d601251c886cf09d8df301039ddd66e5410dddf0" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;:decimal&lt;/code&gt; type, &lt;code&gt;+Infinity&lt;/code&gt;, &lt;code&gt;-Infinity&lt;/code&gt;, and &lt;code&gt;NaN&lt;/code&gt; values are not supported, even though the &lt;a href=&quot;https://hexdocs.pm/decimal/1.6.0/Decimal.html&quot;&gt;&lt;code&gt;Decimal&lt;/code&gt;&lt;/a&gt; library handles them. To support them, you can create a custom type.</source>
          <target state="translated">对于 &lt;code&gt;:decimal&lt;/code&gt; 类型，即使&lt;a href=&quot;https://hexdocs.pm/decimal/1.6.0/Decimal.html&quot;&gt; &lt;code&gt;Decimal&lt;/code&gt; &lt;/a&gt;库处理它们，也不支持 &lt;code&gt;+Infinity&lt;/code&gt; ， &lt;code&gt;-Infinity&lt;/code&gt; 和 &lt;code&gt;NaN&lt;/code&gt; 值。为了支持它们，您可以创建一个自定义类型。</target>
        </trans-unit>
        <trans-unit id="780c2570702e69db99f32922ce1d16997b165979" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;{:array, inner_type}&lt;/code&gt; and &lt;code&gt;{:map, inner_type}&lt;/code&gt; type, replace &lt;code&gt;inner_type&lt;/code&gt; with one of the valid types, such as &lt;code&gt;:string&lt;/code&gt;.</source>
          <target state="translated">对于 &lt;code&gt;{:array, inner_type}&lt;/code&gt; 和 &lt;code&gt;{:map, inner_type}&lt;/code&gt; 类型，将 &lt;code&gt;inner_type&lt;/code&gt; 替换为有效类型之一，例如 &lt;code&gt;:string&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1b121a5201e5fe9abd71ff02499c57b1592c223e" translate="yes" xml:space="preserve">
          <source>For the endpoint:</source>
          <target state="translated">对于端点:</target>
        </trans-unit>
        <trans-unit id="b1f1151b7b2d1e19979f082133ff2e9a94a228d5" translate="yes" xml:space="preserve">
          <source>For the last piece of this puzzle, we'll need a new template. Since it is for the &lt;code&gt;show&lt;/code&gt; action of the &lt;code&gt;HelloController&lt;/code&gt;, it will go into the &lt;code&gt;lib/hello_web/templates/hello&lt;/code&gt; directory and be called &lt;code&gt;show.html.eex&lt;/code&gt;. It will look surprisingly like our &lt;code&gt;index.html.eex&lt;/code&gt; template, except that we will need to display the name of our messenger.</source>
          <target state="translated">对于这个难题的最后一部分，我们需要一个新的模板。由于它是用于 &lt;code&gt;HelloController&lt;/code&gt; 的 &lt;code&gt;show&lt;/code&gt; 动作的，因此它将进入 &lt;code&gt;lib/hello_web/templates/hello&lt;/code&gt; 目录，并称为 &lt;code&gt;show.html.eex&lt;/code&gt; 。它看起来令人惊讶地类似于我们的 &lt;code&gt;index.html.eex&lt;/code&gt; 模板，除了我们需要显示Messenger的名称。</target>
        </trans-unit>
        <trans-unit id="d19fd3691f7d4d31387de8d41929bd14c258e795" translate="yes" xml:space="preserve">
          <source>For the live-reload websocket:</source>
          <target state="translated">对于实时重装网络插座。</target>
        </trans-unit>
        <trans-unit id="81005f9cec33e8f78401fbfd630c9003c91a58e8" translate="yes" xml:space="preserve">
          <source>For these use cases, the &lt;code&gt;phx-change&lt;/code&gt; input does not concern itself with disabling input editing while an event to the server is in flight. When a &lt;code&gt;phx-change&lt;/code&gt; event is sent to the server, the input tag and parent form tag receive the &lt;code&gt;phx-change-loading&lt;/code&gt; css class, then the payload is pushed to the server with a &lt;code&gt;&quot;_target&quot;&lt;/code&gt; param in the root payload containing the keyspace of the input name which triggered the change event.</source>
          <target state="translated">对于这些用例，在发生服务器事件时， &lt;code&gt;phx-change&lt;/code&gt; 输入与禁用输入编辑无关。当向服务器发送 &lt;code&gt;phx-change&lt;/code&gt; 事件时，输入标记和父表单标记接收到 &lt;code&gt;phx-change-loading&lt;/code&gt; css类，然后将有效负载与包含密钥空间的根有效负载中的 &lt;code&gt;&quot;_target&quot;&lt;/code&gt; 参数一起推送到服务器触发更改事件的输入名称的名称。</target>
        </trans-unit>
        <trans-unit id="c7fe2c0bee48cd8643f3d8a46b8a6fe43bb8e581" translate="yes" xml:space="preserve">
          <source>For this exercise, we're going to re-use the &lt;code&gt;HelloController&lt;/code&gt; we just created and just add a new &lt;code&gt;show&lt;/code&gt; action. We'll add a line just below our last route, like this:</source>
          <target state="translated">在本练习中，我们将重复使用刚刚创建的 &lt;code&gt;HelloController&lt;/code&gt; 并添加一个新的 &lt;code&gt;show&lt;/code&gt; 动作。我们将在最后一条路线的下方添加一条线，如下所示：</target>
        </trans-unit>
        <trans-unit id="b6cc26f40ba25b58fe4ceb1492cc4ebe433ed3db" translate="yes" xml:space="preserve">
          <source>For this plug to work, it expects a session to have been previously fetched. It will then compare the plug stored in the session with the one sent by the request to determine the validity of the request. For an invalid request the action taken is based on the &lt;code&gt;:with&lt;/code&gt; option.</source>
          <target state="translated">为了使该插件正常工作，它希望先前已获取了会话。然后，它将存储在会话中的插头与请求发送的插头进行比较，以确定请求的有效性。对于无效的请求，采取的措施基于 &lt;code&gt;:with&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="c19aeef5835b8730002052f32c829b18a9a1b368" translate="yes" xml:space="preserve">
          <source>For this plug to work, it expects a session to have been previously fetched. It will then compare the token stored in the session with the one sent by the request to determine the validity of the request. For an invalid request the action taken is based on the &lt;code&gt;:with&lt;/code&gt; option.</source>
          <target state="translated">为了使该插件正常工作，它希望先前已获取了会话。然后，它将会话中存储的令牌与请求发送的令牌进行比较，以确定请求的有效性。对于无效的请求，采取的措施基于 &lt;code&gt;:with&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="acbd3da24abf12ae2ee4b4dbe388f7d784a60abf" translate="yes" xml:space="preserve">
          <source>For this reason, Phoenix automatically includes a &amp;ldquo;_utf8=✓&amp;rdquo; parameter in your forms, to force those browsers to send the data in the proper encoding. This technique has been seen in the Rails web framework and reproduced here.</source>
          <target state="translated">因此，Phoenix会在您的表单中自动包含&amp;ldquo; _utf8 =✓&amp;rdquo;参数，以强制这些浏览器以正确的编码发送数据。该技术已在Rails Web框架中看到，并在此处复制。</target>
        </trans-unit>
        <trans-unit id="93af13c5fc0bdc9bd0b9d349f954f83799c8aaa8" translate="yes" xml:space="preserve">
          <source>For this reason, we will use schemas on the remaining examples but remember Ecto does not require them in order to write queries.</source>
          <target state="translated">出于这个原因,我们将在其余的例子上使用模式,但记住Ecto不需要它们来编写查询。</target>
        </trans-unit>
        <trans-unit id="4eee2cf416e710c5d41ff3bd324c67e1310cb64b" translate="yes" xml:space="preserve">
          <source>For use with Plug the certificates and key should be stored in PEM format, containing Base64-encoded data between 'BEGIN' and 'END' markers. Some useful OpenSSL commands for converting certificates/keys from other formats can be found at &lt;a href=&quot;#converting-certificates-and-keys&quot;&gt;the end of this document&lt;/a&gt;.</source>
          <target state="translated">与插头一起使用时，证书和密钥应以PEM格式存储，在'BEGIN'和'END'标记之间包含Base64编码的数据。在&lt;a href=&quot;#converting-certificates-and-keys&quot;&gt;本文档的结尾&lt;/a&gt;可以找到一些有用的OpenSSL命令，用于从其他格式转换证书/密钥。</target>
        </trans-unit>
        <trans-unit id="c7e5ab937cf7dceafaad92974cb027e2587d7a76" translate="yes" xml:space="preserve">
          <source>Force table clean up because the given pid is down asynchronously</source>
          <target state="translated">因为给定的pid异步宕机,所以强制清理表。</target>
        </trans-unit>
        <trans-unit id="8297c64e60d581b16d4f160782d093bba37f69c8" translate="yes" xml:space="preserve">
          <source>Force table clean up because the given pid is down asynchronously.</source>
          <target state="translated">因为给定的pid异步下线,所以强制清理表。</target>
        </trans-unit>
        <trans-unit id="9376e40f7dd57bd0a80a45f4b597decef3430bb5" translate="yes" xml:space="preserve">
          <source>Forces SSL in the socket connection</source>
          <target state="translated">在套接字连接中强制使用SSL</target>
        </trans-unit>
        <trans-unit id="f2f36ba3d6535af9ad03fa2741c09ec0c941cf53" translate="yes" xml:space="preserve">
          <source>Forces SSL in the socket connection.</source>
          <target state="translated">在套接字连接中强制使用SSL。</target>
        </trans-unit>
        <trans-unit id="a94803f581b82f9ba5bdaf6f21212ed730ebfce9" translate="yes" xml:space="preserve">
          <source>Forces a change on the given &lt;code&gt;key&lt;/code&gt; with &lt;code&gt;value&lt;/code&gt;</source>
          <target state="translated">用 &lt;code&gt;value&lt;/code&gt; 强制更改给定 &lt;code&gt;key&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ba1f8f66627e0e0f8fe7b916b77edc9622c220fc" translate="yes" xml:space="preserve">
          <source>Forces a change on the given &lt;code&gt;key&lt;/code&gt; with &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">强制使用 &lt;code&gt;value&lt;/code&gt; 对给定 &lt;code&gt;key&lt;/code&gt; 进行更改。</target>
        </trans-unit>
        <trans-unit id="7d30ae53e81b25bd47a3ef79f6270bb2aee0a4b4" translate="yes" xml:space="preserve">
          <source>Form Events</source>
          <target state="translated">活动形式</target>
        </trans-unit>
        <trans-unit id="cfc11712b7350cabf491f94f3c35d6b7b4841ba2" translate="yes" xml:space="preserve">
          <source>Form bindings</source>
          <target state="translated">表格装订</target>
        </trans-unit>
        <trans-unit id="d59e0684db2c7234ae793772920708c7ec986309" translate="yes" xml:space="preserve">
          <source>Format encoders</source>
          <target state="translated">格式编码器</target>
        </trans-unit>
        <trans-unit id="c97fca207ecbaf116ba6ca44368cce3e0a305b92" translate="yes" xml:space="preserve">
          <source>Fortunately that&amp;rsquo;s easily solvable by simply rewriting it to:</source>
          <target state="translated">幸运的是，只需将其重写为以下内容即可轻松解决：</target>
        </trans-unit>
        <trans-unit id="ce0ce27512362c06a1b5491aeb75239f7f72fd68" translate="yes" xml:space="preserve">
          <source>Fortunately that's easily solvable by simply rewriting it to:</source>
          <target state="translated">幸运的是,这很容易解决,只要将其改写成。</target>
        </trans-unit>
        <trans-unit id="5e135da21707dbf32a06679cd1c1f36d2117cbc6" translate="yes" xml:space="preserve">
          <source>Fortunately, &lt;a href=&quot;https://hexdocs.pm/telemetry_metrics/Telemetry.Metrics.html&quot;&gt;&lt;code&gt;Telemetry.Metrics&lt;/code&gt;&lt;/a&gt; provides the following options to help you classify your events:</source>
          <target state="translated">幸运的是，&lt;a href=&quot;https://hexdocs.pm/telemetry_metrics/Telemetry.Metrics.html&quot;&gt; &lt;code&gt;Telemetry.Metrics&lt;/code&gt; &lt;/a&gt;提供了以下选项来帮助您对事件进行分类：</target>
        </trans-unit>
        <trans-unit id="0dd153d2c6179415e41d49146fab6f4c5d3731e1" translate="yes" xml:space="preserve">
          <source>Fortunately, our application layout, &lt;code&gt;lib/hello_web/templates/layout/app.html.eex&lt;/code&gt;, already has markup for displaying flash messages.</source>
          <target state="translated">幸运的是，我们的应用程序布局 &lt;code&gt;lib/hello_web/templates/layout/app.html.eex&lt;/code&gt; 已经具有用于显示Flash消息的标记。</target>
        </trans-unit>
        <trans-unit id="ba4e72261283258434788542ba397135c10f39d8" translate="yes" xml:space="preserve">
          <source>Forward</source>
          <target state="translated">Forward</target>
        </trans-unit>
        <trans-unit id="243792f59615d8e2d372bd2223d968fccda687be" translate="yes" xml:space="preserve">
          <source>Forwards a request at the given path to a plug</source>
          <target state="translated">将给定路径上的请求转发到一个插件。</target>
        </trans-unit>
        <trans-unit id="16e33ad48d9a60b2973610a401cef5c85f913f57" translate="yes" xml:space="preserve">
          <source>Forwards a request at the given path to a plug.</source>
          <target state="translated">将给定路径的请求转发到一个插件。</target>
        </trans-unit>
        <trans-unit id="b32cf12685ca5dc27b473a969f37f02beef213d2" translate="yes" xml:space="preserve">
          <source>Forwards requests to another Plug. The &lt;code&gt;path_info&lt;/code&gt; of the forwarded connection will exclude the portion of the path specified in the call to &lt;code&gt;forward&lt;/code&gt;. If the path contains any parameters, those will be available in the target Plug in &lt;code&gt;conn.params&lt;/code&gt; and &lt;code&gt;conn.path_params&lt;/code&gt;</source>
          <target state="translated">将请求转发到另一个插件。转发连接的 &lt;code&gt;path_info&lt;/code&gt; 将排除对 &lt;code&gt;forward&lt;/code&gt; 的调用中指定的路径部分。如果路径包含任何参数，则这些参数将在目标插件中 &lt;code&gt;conn.params&lt;/code&gt; 和 &lt;code&gt;conn.path_params&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a2b6fd862c663433fb18b8d94573b799a0d0c715" translate="yes" xml:space="preserve">
          <source>Forwards requests to another Plug. The &lt;code&gt;path_info&lt;/code&gt; of the forwarded connection will exclude the portion of the path specified in the call to &lt;code&gt;forward&lt;/code&gt;. If the path contains any parameters, those will be available in the target Plug in &lt;code&gt;conn.params&lt;/code&gt; and &lt;code&gt;conn.path_params&lt;/code&gt;.</source>
          <target state="translated">将请求转发到另一个插件。转发连接的 &lt;code&gt;path_info&lt;/code&gt; 将排除对 &lt;code&gt;forward&lt;/code&gt; 的调用中指定的路径部分。如果路径包含任何参数，则这些参数将在目标插件 &lt;code&gt;conn.params&lt;/code&gt; 和 &lt;code&gt;conn.path_params&lt;/code&gt; 中可用。</target>
        </trans-unit>
        <trans-unit id="676ca63eda9f110339bc4562d41c4087d1f58d05" translate="yes" xml:space="preserve">
          <source>Four different datetime primitive types are available:</source>
          <target state="translated">有四种不同的日期时间基元类型可供选择。</target>
        </trans-unit>
        <trans-unit id="d45089940ca38bf48726ea01710791bffa1dee6e" translate="yes" xml:space="preserve">
          <source>Fragments</source>
          <target state="translated">Fragments</target>
        </trans-unit>
        <trans-unit id="24ecc99e6f92d07b027a8f31eee228f80d919122" translate="yes" xml:space="preserve">
          <source>From DER to PEM</source>
          <target state="translated">从DER到PEM</target>
        </trans-unit>
        <trans-unit id="a3351c1a0bc423227fbc6658fde3c845ebb20e75" translate="yes" xml:space="preserve">
          <source>From Erlang/OTP 20, channels automatically hibernate to save memory after 15_000 milliseconds of inactivity. This can be customized by passing the &lt;code&gt;:hibernate_after&lt;/code&gt; option to &lt;code&gt;use Phoenix.Channel&lt;/code&gt;:</source>
          <target state="translated">在15_000毫秒的非活动状态后，通道会从Erlang / OTP 20自动休眠以节省内存。可以通过传递 &lt;code&gt;:hibernate_after&lt;/code&gt; 选项来 &lt;code&gt;use Phoenix.Channel&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="5ea65443ee14e0c13f251a23f3960e33cefea03e" translate="yes" xml:space="preserve">
          <source>From PKCS#12 to PEM</source>
          <target state="translated">从PKCS#12到PEM</target>
        </trans-unit>
        <trans-unit id="78e393595a2078a0309f19323b539709581858c3" translate="yes" xml:space="preserve">
          <source>From endpoint to views</source>
          <target state="translated">从端点到视图</target>
        </trans-unit>
        <trans-unit id="e148084f6ad05655c1539a8c5e852e406d1b752b" translate="yes" xml:space="preserve">
          <source>From the client - this is done by replacing &lt;a href=&quot;../phoenix_html/phoenix.html.link#link/2&quot;&gt;&lt;code&gt;Phoenix.HTML.Link.link/2&lt;/code&gt;&lt;/a&gt; by &lt;a href=&quot;phoenix.liveview.helpers#live_patch/2&quot;&gt;&lt;code&gt;Phoenix.LiveView.Helpers.live_patch/2&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;phoenix.liveview.helpers#live_redirect/2&quot;&gt;&lt;code&gt;Phoenix.LiveView.Helpers.live_redirect/2&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">从客户端-这是通过将&lt;a href=&quot;../phoenix_html/phoenix.html.link#link/2&quot;&gt; &lt;code&gt;Phoenix.HTML.Link.link/2&lt;/code&gt; &lt;/a&gt;替换为&lt;a href=&quot;phoenix.liveview.helpers#live_patch/2&quot;&gt; &lt;code&gt;Phoenix.LiveView.Helpers.live_patch/2&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;phoenix.liveview.helpers#live_redirect/2&quot;&gt; &lt;code&gt;Phoenix.LiveView.Helpers.live_redirect/2&lt;/code&gt; 来完成的&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c883c0cead87878c13107898743ee64b746f1b75" translate="yes" xml:space="preserve">
          <source>From the description, it's clear we need a &lt;code&gt;Page&lt;/code&gt; resource for storing page information. What about our author information? While we could extend our existing &lt;code&gt;Accounts.User&lt;/code&gt; schema to include information such as bio and role, that would violate the responsibilities we've set up for our contexts. Why should our Account system now be aware of author information? Worse, with a field like &quot;role&quot;, the CMS role in the system will likely conflict or be confused with other account roles for our application. There's a better way.</source>
          <target state="translated">从描述中很明显，我们需要一个用于存储页面信息的 &lt;code&gt;Page&lt;/code&gt; 资源。那我们的作者信息呢？虽然我们可以扩展现有的 &lt;code&gt;Accounts.User&lt;/code&gt; 模式以包含诸如履历和角色之类的信息，但这会违反我们为上下文设置的职责。为什么我们的帐户系统现在应该知道作者信息？更糟糕的是，使用&amp;ldquo;角色&amp;rdquo;之类的字段，系统中的CMS角色可能会与我们应用程序的其他帐户角色发生冲突或混淆。有更好的方法。</target>
        </trans-unit>
        <trans-unit id="09c42ad7be67b12c5ded49ac88365867cded7985" translate="yes" xml:space="preserve">
          <source>From the server - this is done by replacing &lt;a href=&quot;../phoenix/phoenix.controller#redirect/2&quot;&gt;&lt;code&gt;Phoenix.Controller.redirect/2&lt;/code&gt;&lt;/a&gt; calls by &lt;a href=&quot;phoenix.liveview#push_patch/2&quot;&gt;&lt;code&gt;Phoenix.LiveView.push_patch/2&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;phoenix.liveview#push_redirect/2&quot;&gt;&lt;code&gt;Phoenix.LiveView.push_redirect/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">从服务器-通过将&lt;a href=&quot;../phoenix/phoenix.controller#redirect/2&quot;&gt; &lt;code&gt;Phoenix.Controller.redirect/2&lt;/code&gt; &lt;/a&gt;调用替换为&lt;a href=&quot;phoenix.liveview#push_patch/2&quot;&gt; &lt;code&gt;Phoenix.LiveView.push_patch/2&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;phoenix.liveview#push_redirect/2&quot;&gt; &lt;code&gt;Phoenix.LiveView.push_redirect/2&lt;/code&gt; 来完成&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5d57ff449f79bf9c5a7e5e0c8035c5660c71a840" translate="yes" xml:space="preserve">
          <source>From this moment on, all future queries done by the current process will run on &lt;code&gt;:tenant_foo&lt;/code&gt;.</source>
          <target state="translated">从这一刻起，当前进程完成的所有将来查询都将在 &lt;code&gt;:tenant_foo&lt;/code&gt; 上运行。</target>
        </trans-unit>
        <trans-unit id="7091d22a2b4d23609cc93c591d186ab2886edba6" translate="yes" xml:space="preserve">
          <source>Front-end to Phoenix pubsub layer.</source>
          <target state="translated">前端到凤凰网pubsub层。</target>
        </trans-unit>
        <trans-unit id="9a3dd8d119f213e54043ceb85ba50067487df91c" translate="yes" xml:space="preserve">
          <source>Function Plugs</source>
          <target state="translated">功能插头</target>
        </trans-unit>
        <trans-unit id="9bf236d048ccab1956dd5420be9ebe7d7c44331e" translate="yes" xml:space="preserve">
          <source>Function plugs</source>
          <target state="translated">功能插头</target>
        </trans-unit>
        <trans-unit id="2dd4a4a3d83639ed1b8ee2c403652e8e1564593e" translate="yes" xml:space="preserve">
          <source>Function plugs are plugged by passing the function name as an atom. To try the Plug out, go back to your browser and fetch &quot;http://localhost:4000&quot;. You should see something like this printed in your terminal:</source>
          <target state="translated">函数Plug是通过传递函数名作为原子来插入的。要试用Plug,请回到浏览器,并获取 &quot;http://localhost:4000&quot;。你应该会看到在你的终端中打印出这样的东西。</target>
        </trans-unit>
        <trans-unit id="c52ba62be465c21dfd3bd9843b5875f996364af7" translate="yes" xml:space="preserve">
          <source>Functional Web Development with Elixir, OTP, and Phoenix Rethink the Modern Web App (by Lance Halvorsen - 2017)</source>
          <target state="translated">用Elixir、OTP和Phoenix进行功能性Web开发 重新思考现代Web应用(作者:Lance Halvorsen-2017年</target>
        </trans-unit>
        <trans-unit id="8578c4e152b3c9315bc17a094d58da8a5fe7bd6e" translate="yes" xml:space="preserve">
          <source>Functionality for providing Basic HTTP authentication.</source>
          <target state="translated">提供基本HTTP认证的功能。</target>
        </trans-unit>
        <trans-unit id="2b961dea1dc0c60ddf9a2c8e9d090f6f7d082483" translate="yes" xml:space="preserve">
          <source>Functions</source>
          <target state="translated">Functions</target>
        </trans-unit>
        <trans-unit id="1442301406adda1b4f88b555bb39bb4cb9e30ff1" translate="yes" xml:space="preserve">
          <source>Furthermore an array type can also be given if it is supported by your database, although it requires the type of the underlying array element to be given too:</source>
          <target state="translated">此外,如果你的数据库支持数组类型,也可以给出数组类型,尽管这也需要给出底层数组元素的类型。</target>
        </trans-unit>
        <trans-unit id="45c1f2b55dcf3303d32f38fbac65ddded9bd404b" translate="yes" xml:space="preserve">
          <source>Furthermore, both &lt;code&gt;__struct__&lt;/code&gt; and &lt;code&gt;__changeset__&lt;/code&gt; functions are defined so structs and changeset functionalities are available.</source>
          <target state="translated">此外，同时定义了 &lt;code&gt;__struct__&lt;/code&gt; 和 &lt;code&gt;__changeset__&lt;/code&gt; 函数，因此可以使用结构和变更集功能。</target>
        </trans-unit>
        <trans-unit id="dc4cf7a9112b1823e7922465dba21cf009cbc323" translate="yes" xml:space="preserve">
          <source>Furthermore, it is very important to not access the same parameters on both &lt;a href=&quot;phoenix.liveview#c:mount/3&quot;&gt;&lt;code&gt;mount/3&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;phoenix.liveview#c:handle_params/3&quot;&gt;&lt;code&gt;handle_params/3&lt;/code&gt;&lt;/a&gt;. For example, do NOT do this:</source>
          <target state="translated">此外，在&lt;a href=&quot;phoenix.liveview#c:mount/3&quot;&gt; &lt;code&gt;mount/3&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;phoenix.liveview#c:handle_params/3&quot;&gt; &lt;code&gt;handle_params/3&lt;/code&gt; &lt;/a&gt;上不要访问相同的参数非常重要。例如，不要这样做：</target>
        </trans-unit>
        <trans-unit id="5d2ace48935ec9ca13c146a4d739dd039753a23f" translate="yes" xml:space="preserve">
          <source>Furthermore, it sets the following defaults:</source>
          <target state="translated">此外,它还设置了以下默认值。</target>
        </trans-unit>
        <trans-unit id="9c9cc3e69d5248baac17979dd85069ab7aa035bd" translate="yes" xml:space="preserve">
          <source>Furthermore, since the tag information is given as structs read directly from the database, Ecto will treat the data as correct and only do the minimum necessary to guarantee that posts and tags are associated, without trying to update or diff any of the fields in the tag struct.</source>
          <target state="translated">此外,由于标签信息是从数据库中直接读取的结构,Ecto会将数据视为正确的,并且只做最低限度的必要工作,以保证帖子和标签的关联,而不会试图更新或差异标签结构中的任何字段。</target>
        </trans-unit>
        <trans-unit id="c338ceb5b7adaaa50f38c347f2349c53389ff49c" translate="yes" xml:space="preserve">
          <source>Furthermore, the &lt;code&gt;before_send&lt;/code&gt; field stores callbacks that are invoked before the connection is sent. Callbacks are invoked in the reverse order they are registered (callbacks registered first are invoked last) in order to reproduce a pipeline ordering.</source>
          <target state="translated">此外， &lt;code&gt;before_send&lt;/code&gt; 字段存储在发送连接之前调用的回调。回调以注册时的相反顺序调用（首先注册的回调先调用），以便重现管道顺序。</target>
        </trans-unit>
        <trans-unit id="70e2803f5997f8434e1e14d79b67bf417331f761" translate="yes" xml:space="preserve">
          <source>Furthermore, this protocol relies on iodata, which provides better performance when sending or streaming data to the client.</source>
          <target state="translated">此外,该协议依赖于碘数据,在向客户端发送或流式传输数据时,碘数据的性能更好。</target>
        </trans-unit>
        <trans-unit id="f030bbbd32966cde41037b98a8849c46b76e4bc1" translate="yes" xml:space="preserve">
          <source>GET</source>
          <target state="translated">GET</target>
        </trans-unit>
        <trans-unit id="98281856e51de8bb0669d3ab3f5d42120b606d43" translate="yes" xml:space="preserve">
          <source>GET requests are not protected, as they should not have any side-effect or change your application state. JavaScript requests are an exception: by using a script tag, external websites can embed server-side generated JavaScript, which can leak information. For this reason, this plug also forbids any GET JavaScript request that is not XHR (or AJAX).</source>
          <target state="translated">GET请求不受保护,因为它们不应该有任何副作用或改变你的应用程序状态。JavaScript请求是一个例外:通过使用脚本标签,外部网站可以嵌入服务器端生成的JavaScript,这可能会泄露信息。出于这个原因,这个插件也禁止任何非XHR(或AJAX)的GET JavaScript请求。</target>
        </trans-unit>
        <trans-unit id="84841ccacb20efbdee1996b961b9cb5573918289" translate="yes" xml:space="preserve">
          <source>Garbage collection</source>
          <target state="translated">垃圾收集</target>
        </trans-unit>
        <trans-unit id="a96be0a4f608d9678cf95140fc6762e7fff0a137" translate="yes" xml:space="preserve">
          <source>Geerates the static URL without any path information</source>
          <target state="translated">读取没有任何路径信息的静态URL。</target>
        </trans-unit>
        <trans-unit id="18fd8d6947881e76a9476c5cc3ade9f03cb51e63" translate="yes" xml:space="preserve">
          <source>Geerates the static URL without any path information.</source>
          <target state="translated">读取没有任何路径信息的静态URL。</target>
        </trans-unit>
        <trans-unit id="81d73279e9d50f0e75f19715870b45b2edcc66d2" translate="yes" xml:space="preserve">
          <source>General: &lt;a href=&quot;#fragment/1&quot;&gt;&lt;code&gt;fragment/1&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#field/2&quot;&gt;&lt;code&gt;field/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#type/2&quot;&gt;&lt;code&gt;type/2&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">常规：&lt;a href=&quot;#fragment/1&quot;&gt; &lt;code&gt;fragment/1&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#field/2&quot;&gt; &lt;code&gt;field/2&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#type/2&quot;&gt; &lt;code&gt;type/2&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ff7162efc456a290918a3e5ee7fb1cdec59b3096" translate="yes" xml:space="preserve">
          <source>General: &lt;a href=&quot;#fragment/1&quot;&gt;&lt;code&gt;fragment/1&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#field/2&quot;&gt;&lt;code&gt;field/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#type/2&quot;&gt;&lt;code&gt;type/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#as/1&quot;&gt;&lt;code&gt;as/1&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#parent_as/1&quot;&gt;&lt;code&gt;parent_as/1&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">常规：&lt;a href=&quot;#fragment/1&quot;&gt; &lt;code&gt;fragment/1&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#field/2&quot;&gt; &lt;code&gt;field/2&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#type/2&quot;&gt; &lt;code&gt;type/2&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#as/1&quot;&gt; &lt;code&gt;as/1&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#parent_as/1&quot;&gt; &lt;code&gt;parent_as/1&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="89915973deb8400c76aef3230f3bef302eb16934" translate="yes" xml:space="preserve">
          <source>Generally speaking, &lt;strong&gt;data loading should never happen inside the template&lt;/strong&gt;, regardless if you are using LiveView or not. The difference is that LiveView enforces this best practice.</source>
          <target state="translated">一般而言，无论是否使用LiveView，都不&lt;strong&gt;应在模板内部进行数据加载&lt;/strong&gt;。区别在于，LiveView强制执行此最佳实践。</target>
        </trans-unit>
        <trans-unit id="14a9eeb3344bae3449699429e539fd4fa8761f40" translate="yes" xml:space="preserve">
          <source>Generally speaking, avoid accessing variables inside LiveViews. This also applies to the &lt;code&gt;assigns&lt;/code&gt; variable, except when rendering another &lt;code&gt;.leex&lt;/code&gt; template. In such cases, it is ok to pass the whole assigns, as LiveView will continue to perform change tracking in the called template:</source>
          <target state="translated">一般来说，请避免访问LiveViews内部的变量。这也适用于 &lt;code&gt;assigns&lt;/code&gt; 变量，呈现另一种情况除外 &lt;code&gt;.leex&lt;/code&gt; 模板。在这种情况下，可以传递整个分配，因为LiveView将继续在被调用的模板中执行更改跟踪：</target>
        </trans-unit>
        <trans-unit id="a3bcf392d6ffb2ecf8e6673b16608e3a7f45a1a5" translate="yes" xml:space="preserve">
          <source>Generally speaking, once all assigns are configured, we invoke the View layer. The View layer then renders &quot;show.html&quot; alongside the layout and a response is sent back to the browser.</source>
          <target state="translated">一般来说,一旦所有的赋值都配置好了,我们就会调用View层,然后View层就会在布局旁边渲染 &quot;show.html&quot;,并向浏览器发送响应。然后,View层会在布局旁边渲染 &quot;show.html&quot;,并向浏览器发送响应。</target>
        </trans-unit>
        <trans-unit id="c6326d5e8e870450f20952d282dad90d36072ad9" translate="yes" xml:space="preserve">
          <source>Generally speaking, the simplest and safest approach is to perform authorization whenever there is an action. For example, imagine that you have a LiveView for a &quot;Blog&quot;, and only editors can edit posts. Therefore, it is best to validate the user is an editor on mount and on every event:</source>
          <target state="translated">一般来说,最简单、最安全的方法是只要有操作就执行授权。例如,设想你有一个 &quot;博客 &quot;的LiveView,只有编辑才能编辑文章。因此,最好在挂载时和每个事件中都验证用户是编辑。</target>
        </trans-unit>
        <trans-unit id="02048f2e9cef3e709a6a4f29484a15537a595bf8" translate="yes" xml:space="preserve">
          <source>Generally speaking, you want to avoid both the parent LiveView and the LiveComponent working on two different copies of the state. Instead, you should assume only one of them to be the source of truth. Let's discuss the two different approaches in detail.</source>
          <target state="translated">一般来说,你要避免父LiveView和LiveComponent同时工作在状态的两个不同副本上。相反,你应该假设其中只有一个是真实的来源。让我们详细讨论一下这两种不同的方法。</target>
        </trans-unit>
        <trans-unit id="dbf039f3463a6192dcedbf378221d86ccce25ca4" translate="yes" xml:space="preserve">
          <source>Generate a new form builder for the given parameter in form</source>
          <target state="translated">为表单中的给定参数生成一个新的表单生成器。</target>
        </trans-unit>
        <trans-unit id="2809e45ea67772c9b7701d8d849d6d2e451fe427" translate="yes" xml:space="preserve">
          <source>Generate a new form builder for the given parameter in form &lt;strong&gt;without&lt;/strong&gt; an anonymous function.</source>
          <target state="translated">为表单中的给定参数生成一个新的表单生成器，&lt;strong&gt;而无需&lt;/strong&gt;匿名函数。</target>
        </trans-unit>
        <trans-unit id="15e52a102d3768bc19eacc2abb7f4194a20be07e" translate="yes" xml:space="preserve">
          <source>Generate a new form builder for the given parameter in form.</source>
          <target state="translated">为表单中给定的参数生成一个新的表单生成器。</target>
        </trans-unit>
        <trans-unit id="bc292ee42a9b81099735fa47e66e355172cc4c20" translate="yes" xml:space="preserve">
          <source>Generated migration can use &lt;code&gt;binary_id&lt;/code&gt; for schema&amp;rsquo;s primary key and its references with option &lt;code&gt;--binary-id&lt;/code&gt;.</source>
          <target state="translated">生成的迁移可以使用 &lt;code&gt;binary_id&lt;/code&gt; 作为模式的主键及其带有选项 &lt;code&gt;--binary-id&lt;/code&gt; 的引用。</target>
        </trans-unit>
        <trans-unit id="de509ead052a1d21c5bec58e9e137546f9fbc245" translate="yes" xml:space="preserve">
          <source>Generated migration can use &lt;code&gt;binary_id&lt;/code&gt; for schema's primary key and its references with option &lt;code&gt;--binary-id&lt;/code&gt;.</source>
          <target state="translated">生成的迁移可以使用 &lt;code&gt;binary_id&lt;/code&gt; 作为模式的主键及其带有选项 &lt;code&gt;--binary-id&lt;/code&gt; 的引用。</target>
        </trans-unit>
        <trans-unit id="f64a5913edebccd654a6fcbe563ded9895c73182" translate="yes" xml:space="preserve">
          <source>Generates &lt;code&gt;:inserted_at&lt;/code&gt; and &lt;code&gt;:updated_at&lt;/code&gt; timestamp fields</source>
          <target state="translated">生成 &lt;code&gt;:inserted_at&lt;/code&gt; 和 &lt;code&gt;:updated_at&lt;/code&gt; 时间戳字段</target>
        </trans-unit>
        <trans-unit id="6e6bf2fc4b7fa7784ba0393c92ca08b83b688b33" translate="yes" xml:space="preserve">
          <source>Generates &lt;code&gt;:inserted_at&lt;/code&gt; and &lt;code&gt;:updated_at&lt;/code&gt; timestamp fields.</source>
          <target state="translated">生成 &lt;code&gt;:inserted_at&lt;/code&gt; 和 &lt;code&gt;:updated_at&lt;/code&gt; 时间戳字段。</target>
        </trans-unit>
        <trans-unit id="f543054b72a2d883e856cf6feb6ce5419c2d27c6" translate="yes" xml:space="preserve">
          <source>Generates LiveView, templates, and context for a resource.</source>
          <target state="translated">为资源生成LiveView、模板和上下文。</target>
        </trans-unit>
        <trans-unit id="46ec673256a5e76ef7c069fc676e2f5aef51009e" translate="yes" xml:space="preserve">
          <source>Generates a &lt;code&gt;socket_ref&lt;/code&gt; for an async reply</source>
          <target state="translated">为异步回复生成一个 &lt;code&gt;socket_ref&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="89363898c56d89d0dc4865b93a5f0b41e2cb4d20" translate="yes" xml:space="preserve">
          <source>Generates a &lt;code&gt;socket_ref&lt;/code&gt; for an async reply.</source>
          <target state="translated">生成用于异步回复的 &lt;code&gt;socket_ref&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7254b9e30fd4dcd56334ce2310a46519a11db327" translate="yes" xml:space="preserve">
          <source>Generates a Phoenix channel.</source>
          <target state="translated">生成凤凰频道。</target>
        </trans-unit>
        <trans-unit id="dbbfe88a5e9c28bee33e4a7709d25c7578b13712" translate="yes" xml:space="preserve">
          <source>Generates a Phoenix resource.</source>
          <target state="translated">生成凤凰资源。</target>
        </trans-unit>
        <trans-unit id="396e5bd6ba3cdeb590c49ec0bbf4116674cec309" translate="yes" xml:space="preserve">
          <source>Generates a Presence tracker for your application.</source>
          <target state="translated">为您的应用程序生成一个存在跟踪器。</target>
        </trans-unit>
        <trans-unit id="e050d4cb2d11258492bf32d26abe466db5793c12" translate="yes" xml:space="preserve">
          <source>Generates a Presence tracker.</source>
          <target state="translated">生成存在跟踪器。</target>
        </trans-unit>
        <trans-unit id="5b57a23b25adcd3dfb1b05de10692fcac4b0c0a7" translate="yes" xml:space="preserve">
          <source>Generates a button that uses a regular HTML form to submit to the given URL</source>
          <target state="translated">生成一个按钮,该按钮使用常规的HTML表单提交到给定的URL。</target>
        </trans-unit>
        <trans-unit id="6dc6b7e0d06c3c7fac4214ca839f28cb452a6270" translate="yes" xml:space="preserve">
          <source>Generates a button that uses a regular HTML form to submit to the given URL.</source>
          <target state="translated">生成一个按钮,使用常规的HTML表单提交到给定的URL。</target>
        </trans-unit>
        <trans-unit id="64561f910e36802f2f2af6c0eeef79ae9959a53a" translate="yes" xml:space="preserve">
          <source>Generates a checkbox</source>
          <target state="translated">生成一个复选框</target>
        </trans-unit>
        <trans-unit id="9c402930c245037de584689931bc5f98cb925246" translate="yes" xml:space="preserve">
          <source>Generates a checkbox.</source>
          <target state="translated">生成一个复选框。</target>
        </trans-unit>
        <trans-unit id="e758b3646d387941fe43bb7c638a89c7ddd9d4c8" translate="yes" xml:space="preserve">
          <source>Generates a childspec to be used in the supervision tree</source>
          <target state="translated">生成一个用于监督树的childspec。</target>
        </trans-unit>
        <trans-unit id="084a356e3603b2d7d3058ec01dbce1827e553b3a" translate="yes" xml:space="preserve">
          <source>Generates a childspec to be used in the supervision tree.</source>
          <target state="translated">生成一个用于监督树的childspec。</target>
        </trans-unit>
        <trans-unit id="c63422f792595ace635012713e2e3ec5fdcfe7c7" translate="yes" xml:space="preserve">
          <source>Generates a color input</source>
          <target state="translated">生成颜色输入</target>
        </trans-unit>
        <trans-unit id="45606cc48a2c148438a5b2a691378a779e9d8307" translate="yes" xml:space="preserve">
          <source>Generates a color input.</source>
          <target state="translated">生成颜色输入。</target>
        </trans-unit>
        <trans-unit id="f79dfad3ee4eee79404d483203748cd197bfb509" translate="yes" xml:space="preserve">
          <source>Generates a context with functions around an Ecto schema.</source>
          <target state="translated">围绕Ecto模式生成一个带有功能的上下文。</target>
        </trans-unit>
        <trans-unit id="171627640dc242b4213e2f665007e56c741ce2ff" translate="yes" xml:space="preserve">
          <source>Generates a date input</source>
          <target state="translated">生成日期输入</target>
        </trans-unit>
        <trans-unit id="1fcc6c8cae144832ffc98dcd40c8eac478e1a7da" translate="yes" xml:space="preserve">
          <source>Generates a date input.</source>
          <target state="translated">生成日期输入。</target>
        </trans-unit>
        <trans-unit id="67502aa3ceeeceb276d924590c8fa7dd9b0a9b11" translate="yes" xml:space="preserve">
          <source>Generates a datetime-local input</source>
          <target state="translated">生成日期时间的本地输入。</target>
        </trans-unit>
        <trans-unit id="ef3ed161bccd6158e836dadcf99ca1633c739273" translate="yes" xml:space="preserve">
          <source>Generates a datetime-local input.</source>
          <target state="translated">生成日期时间-本地输入。</target>
        </trans-unit>
        <trans-unit id="9e84d239e416d559f3c0bccab74b22cff072a5a3" translate="yes" xml:space="preserve">
          <source>Generates a file input</source>
          <target state="translated">生成一个文件输入</target>
        </trans-unit>
        <trans-unit id="39fb04074dabbb624cbc620ccf147d69b2a45061" translate="yes" xml:space="preserve">
          <source>Generates a file input.</source>
          <target state="translated">生成一个文件输入。</target>
        </trans-unit>
        <trans-unit id="ab3c6b9191c757e18e68646ddc1874ca970de62b" translate="yes" xml:space="preserve">
          <source>Generates a form tag</source>
          <target state="translated">生成一个表格标签</target>
        </trans-unit>
        <trans-unit id="b412e1f99156deb9e91f69f6b5ac9155bb03b9cf" translate="yes" xml:space="preserve">
          <source>Generates a form tag with a form builder</source>
          <target state="translated">用表单生成器生成一个表单标签。</target>
        </trans-unit>
        <trans-unit id="15171feee1ac42a2cb8b455685e4d0d0b906602c" translate="yes" xml:space="preserve">
          <source>Generates a form tag with a form builder &lt;strong&gt;without&lt;/strong&gt; an anonymous function.</source>
          <target state="translated">使用&lt;strong&gt;不&lt;/strong&gt;带匿名函数的表单生成器生成表单标签。</target>
        </trans-unit>
        <trans-unit id="b83bd97bb3e9ba2d575b33b43cdc2a09ecc53c26" translate="yes" xml:space="preserve">
          <source>Generates a form tag with a form builder &lt;strong&gt;without&lt;/strong&gt; options or an anonymous function.</source>
          <target state="translated">使用&lt;strong&gt;不带&lt;/strong&gt;选项或匿名函数的表单构建器生成表单标签。</target>
        </trans-unit>
        <trans-unit id="b2e62cb449bf1bc7de104a5c6a894843c62b8273" translate="yes" xml:space="preserve">
          <source>Generates a form tag with a form builder and an anonymous function.</source>
          <target state="translated">生成一个带有表单生成器和匿名函数的表单标签。</target>
        </trans-unit>
        <trans-unit id="5867e479588e031d9af73f4e26e2f4bb755d993f" translate="yes" xml:space="preserve">
          <source>Generates a form tag with a form builder.</source>
          <target state="translated">用表单生成器生成一个表单标签。</target>
        </trans-unit>
        <trans-unit id="1fcf6d502cbed8c6774cbd71cd67cb0475fb8d97" translate="yes" xml:space="preserve">
          <source>Generates a form tag with the given contents</source>
          <target state="translated">生成一个包含给定内容的表单标签。</target>
        </trans-unit>
        <trans-unit id="73a7ae0251a3209970edcca52c92641cb83828a7" translate="yes" xml:space="preserve">
          <source>Generates a form tag with the given contents.</source>
          <target state="translated">生成一个包含给定内容的表单标签。</target>
        </trans-unit>
        <trans-unit id="6fb768c7b9543e92cc3420ccd02e97e5655cfdc3" translate="yes" xml:space="preserve">
          <source>Generates a form tag.</source>
          <target state="translated">生成一个表格标签。</target>
        </trans-unit>
        <trans-unit id="20996193071a0905fdf25cb5c613758dc8b93878" translate="yes" xml:space="preserve">
          <source>Generates a hidden input</source>
          <target state="translated">生成一个隐藏的输入</target>
        </trans-unit>
        <trans-unit id="5b13e8707f3e8f0d576e0f2751dda4df911730a0" translate="yes" xml:space="preserve">
          <source>Generates a hidden input.</source>
          <target state="translated">生成一个隐藏的输入。</target>
        </trans-unit>
        <trans-unit id="abfeb23072c3a06d67ccfbf879bf2eeab96d5b0f" translate="yes" xml:space="preserve">
          <source>Generates a label tag</source>
          <target state="translated">生成一个标签</target>
        </trans-unit>
        <trans-unit id="ce9ab90073232b80839e14e4bbe7f7a803a34eae" translate="yes" xml:space="preserve">
          <source>Generates a label tag for the given field</source>
          <target state="translated">为给定字段生成一个标签。</target>
        </trans-unit>
        <trans-unit id="ab3ca2bbbbcd12eb651c2e27c2a279e192ff3c15" translate="yes" xml:space="preserve">
          <source>Generates a label tag for the given field.</source>
          <target state="translated">为给定字段生成一个标签。</target>
        </trans-unit>
        <trans-unit id="28a6fc00166a8c669fa44ea65f62685493aa2310" translate="yes" xml:space="preserve">
          <source>Generates a label tag.</source>
          <target state="translated">生成一个标签。</target>
        </trans-unit>
        <trans-unit id="ba5c47606513e6f4c9932f97cff5edb31a7e4352" translate="yes" xml:space="preserve">
          <source>Generates a link that will patch the current LiveView.</source>
          <target state="translated">生成一个将修补当前LiveView的链接。</target>
        </trans-unit>
        <trans-unit id="64cb73e3623bbaa3ca07f4ea3ebd7ddcfb72cbbe" translate="yes" xml:space="preserve">
          <source>Generates a link that will redirect to a new LiveView.</source>
          <target state="translated">生成一个链接,将重定向到一个新的LiveView。</target>
        </trans-unit>
        <trans-unit id="a50123897c2b44bec513e431ba7cb02309189fef" translate="yes" xml:space="preserve">
          <source>Generates a link to the given URL</source>
          <target state="translated">生成一个指向给定URL的链接</target>
        </trans-unit>
        <trans-unit id="c1f404e8a3f775cd18f3aa5b04a6353a8bd3eb26" translate="yes" xml:space="preserve">
          <source>Generates a link to the given URL.</source>
          <target state="translated">生成一个指向给定URL的链接。</target>
        </trans-unit>
        <trans-unit id="6ea02c48fa1a1a43ce66c3cf13791ad70aa1639c" translate="yes" xml:space="preserve">
          <source>Generates a loaded version of the data.</source>
          <target state="translated">生成数据的加载版本。</target>
        </trans-unit>
        <trans-unit id="dbc6ea3e0e5e175a0282431e58e112038aaa09c9" translate="yes" xml:space="preserve">
          <source>Generates a meta tag with CSRF information</source>
          <target state="translated">生成一个包含CSRF信息的元标签。</target>
        </trans-unit>
        <trans-unit id="2219f0cedebbcfc4a9097edd34a767a497cb1274" translate="yes" xml:space="preserve">
          <source>Generates a meta tag with CSRF information.</source>
          <target state="translated">生成一个包含CSRF信息的元标签。</target>
        </trans-unit>
        <trans-unit id="3aee4fdfd218c8ef8af1764ebe197ddee57e21b5" translate="yes" xml:space="preserve">
          <source>Generates a new file, &lt;code&gt;lib/my_app_web/channels/my_presence.ex&lt;/code&gt;, where &lt;code&gt;my_presence&lt;/code&gt; is the snake-cased version of the provided module name.</source>
          <target state="translated">生成一个新文件 &lt;code&gt;lib/my_app_web/channels/my_presence.ex&lt;/code&gt; ，其中 &lt;code&gt;my_presence&lt;/code&gt; 是所提供模块名称的蛇形版本。</target>
        </trans-unit>
        <trans-unit id="02411617ad03187efe4d79ddc98c3934f98cab53" translate="yes" xml:space="preserve">
          <source>Generates a new repository.</source>
          <target state="translated">生成一个新的存储库。</target>
        </trans-unit>
        <trans-unit id="ec4e73c7a7527a111588dbb3ab99814034f1ef6f" translate="yes" xml:space="preserve">
          <source>Generates a number input</source>
          <target state="translated">产生一个数字输入</target>
        </trans-unit>
        <trans-unit id="11f48eeb86c1ee3d50fe2a5731642a36708b06b0" translate="yes" xml:space="preserve">
          <source>Generates a number input.</source>
          <target state="translated">产生一个数字输入。</target>
        </trans-unit>
        <trans-unit id="47709e3ef4238d15f86dbf2ee76f58d705224d78" translate="yes" xml:space="preserve">
          <source>Generates a password input</source>
          <target state="translated">生成密码输入</target>
        </trans-unit>
        <trans-unit id="6d0d9edbf1971f56f1a0efb9364b266914f7db45" translate="yes" xml:space="preserve">
          <source>Generates a password input.</source>
          <target state="translated">生成密码输入。</target>
        </trans-unit>
        <trans-unit id="3f4172380d2e87d78dec42dfbd35c80f932ab725" translate="yes" xml:space="preserve">
          <source>Generates a radio button</source>
          <target state="translated">生成一个单选按钮</target>
        </trans-unit>
        <trans-unit id="54d925054bfa8df9816df148a94806ed340b7d20" translate="yes" xml:space="preserve">
          <source>Generates a radio button.</source>
          <target state="translated">生成一个单选按钮。</target>
        </trans-unit>
        <trans-unit id="4211b9345387b675b9be0fc4617dcd0837432193" translate="yes" xml:space="preserve">
          <source>Generates a range input</source>
          <target state="translated">产生一个范围输入</target>
        </trans-unit>
        <trans-unit id="f1d665b37d2ee2aaaf57abb73a773d37fb5632a4" translate="yes" xml:space="preserve">
          <source>Generates a range input.</source>
          <target state="translated">产生一个范围输入。</target>
        </trans-unit>
        <trans-unit id="42b02a853b6591ae8dcaaf9e2b0f271bae8897d8" translate="yes" xml:space="preserve">
          <source>Generates a reset input to reset all the form fields to their original state</source>
          <target state="translated">生成一个重置输入,将所有的表格字段重置为原始状态。</target>
        </trans-unit>
        <trans-unit id="5f9c5b5c3c6b4005d0ded69c44513c4c93741343" translate="yes" xml:space="preserve">
          <source>Generates a reset input to reset all the form fields to their original state.</source>
          <target state="translated">生成一个重置输入,将所有的表格字段重置为原始状态。</target>
        </trans-unit>
        <trans-unit id="c9376cf87944d2c7638464200c033426a186aa76" translate="yes" xml:space="preserve">
          <source>Generates a route match based on an arbitrary HTTP method</source>
          <target state="translated">根据任意的HTTP方法生成路由匹配。</target>
        </trans-unit>
        <trans-unit id="cc5394e9f36a89d2ae9bb46e099d38573bd6b481" translate="yes" xml:space="preserve">
          <source>Generates a route match based on an arbitrary HTTP method.</source>
          <target state="translated">根据任意的HTTP方法生成路由匹配。</target>
        </trans-unit>
        <trans-unit id="897983719926fe4ff3d98b2bae0351ca40ad6096" translate="yes" xml:space="preserve">
          <source>Generates a route to a static file in &lt;code&gt;priv/static&lt;/code&gt;</source>
          <target state="translated">生成到 &lt;code&gt;priv/static&lt;/code&gt; 中的静态文件的路由</target>
        </trans-unit>
        <trans-unit id="bf0351ad82e221297ee7764e10c9555e6b0f6dea" translate="yes" xml:space="preserve">
          <source>Generates a route to a static file in &lt;code&gt;priv/static&lt;/code&gt;.</source>
          <target state="translated">生成到 &lt;code&gt;priv/static&lt;/code&gt; 中的静态文件的路由。</target>
        </trans-unit>
        <trans-unit id="894b7547e38d381fd5440a4e9164d424f886e4e7" translate="yes" xml:space="preserve">
          <source>Generates a route to handle a connect request to the given path</source>
          <target state="translated">生成一个路由,用于处理向指定路径发出的连接请求。</target>
        </trans-unit>
        <trans-unit id="574b4ca741e3f439c47b28cd49adf25fd2f68c1b" translate="yes" xml:space="preserve">
          <source>Generates a route to handle a connect request to the given path.</source>
          <target state="translated">生成一个路由,用于处理连接到指定路径的请求。</target>
        </trans-unit>
        <trans-unit id="378f585ff9da2c90adf66dd182b6c07d40c0b410" translate="yes" xml:space="preserve">
          <source>Generates a route to handle a delete request to the given path</source>
          <target state="translated">生成一条路径,用于处理对指定路径的删除请求。</target>
        </trans-unit>
        <trans-unit id="2e5a45bd26b667751489c9867bc4ac2e1ad5f415" translate="yes" xml:space="preserve">
          <source>Generates a route to handle a delete request to the given path.</source>
          <target state="translated">生成一条路径,用于处理对指定路径的删除请求。</target>
        </trans-unit>
        <trans-unit id="9b7eea3e2812a3a9f1485a0bf4b06ac9322cb592" translate="yes" xml:space="preserve">
          <source>Generates a route to handle a get request to the given path</source>
          <target state="translated">生成一个路由,用于处理向给定路径发出的get请求。</target>
        </trans-unit>
        <trans-unit id="57d3a2a07eedb652e1be011b09d407612fa940d1" translate="yes" xml:space="preserve">
          <source>Generates a route to handle a get request to the given path.</source>
          <target state="translated">生成一条路由,用于处理向指定路径发出的获取请求。</target>
        </trans-unit>
        <trans-unit id="ad76b05490559045cdfdb8bde3bf7f1fbb5c58a4" translate="yes" xml:space="preserve">
          <source>Generates a route to handle a head request to the given path</source>
          <target state="translated">生成一条路由,用于处理向指定路径发出的头部请求。</target>
        </trans-unit>
        <trans-unit id="90093949144eba1a5fb435edb853256751817dc8" translate="yes" xml:space="preserve">
          <source>Generates a route to handle a head request to the given path.</source>
          <target state="translated">生成一条路由,用于处理指向指定路径的头部请求。</target>
        </trans-unit>
        <trans-unit id="e24375171478c89552863fcfeadc3ce58f2e5bca" translate="yes" xml:space="preserve">
          <source>Generates a route to handle a options request to the given path</source>
          <target state="translated">生成一个路由,用于处理向给定路径提出的选项请求。</target>
        </trans-unit>
        <trans-unit id="77c88cce859e3f038ecdbff85d2d730cb2bf13d0" translate="yes" xml:space="preserve">
          <source>Generates a route to handle a options request to the given path.</source>
          <target state="translated">生成一条路径,用于处理向给定路径发出的选项请求。</target>
        </trans-unit>
        <trans-unit id="80ed50be25df94aebc7db8a8ad0804d3342708c1" translate="yes" xml:space="preserve">
          <source>Generates a route to handle a patch request to the given path</source>
          <target state="translated">生成一个路由,用于处理向给定路径发出的补丁请求。</target>
        </trans-unit>
        <trans-unit id="cca725a12cd24948f36b9ede692ae61a76c694e0" translate="yes" xml:space="preserve">
          <source>Generates a route to handle a patch request to the given path.</source>
          <target state="translated">生成一个路由,用于处理向指定路径发出的补丁请求。</target>
        </trans-unit>
        <trans-unit id="1ac815ff5f9cdaae6a2df79818543d53e1f2f23f" translate="yes" xml:space="preserve">
          <source>Generates a route to handle a post request to the given path</source>
          <target state="translated">生成一个路由,用于处理向指定路径发出的post请求。</target>
        </trans-unit>
        <trans-unit id="6fd5d431492f5f17891de85401d2c1290f388443" translate="yes" xml:space="preserve">
          <source>Generates a route to handle a post request to the given path.</source>
          <target state="translated">生成一个路由,用于处理向指定路径发出的post请求。</target>
        </trans-unit>
        <trans-unit id="2a9d46c0f90d8dd7ffb2914e6f3104c626432be2" translate="yes" xml:space="preserve">
          <source>Generates a route to handle a put request to the given path</source>
          <target state="translated">生成一个路由,用于处理向指定路径发出的put请求。</target>
        </trans-unit>
        <trans-unit id="f9ffc6392b8fbd3db7cb9e0d3dc9186949c8f8b7" translate="yes" xml:space="preserve">
          <source>Generates a route to handle a put request to the given path.</source>
          <target state="translated">生成一个路由,用于处理向指定路径发出的put请求。</target>
        </trans-unit>
        <trans-unit id="e0b014c7fd0d0d1d83b5a70fa8d6fe074e0f3052" translate="yes" xml:space="preserve">
          <source>Generates a route to handle a trace request to the given path</source>
          <target state="translated">生成一条路由来处理指向给定路径的跟踪请求。</target>
        </trans-unit>
        <trans-unit id="221bae031a3004d5c2045808e65d68d8c217bcd4" translate="yes" xml:space="preserve">
          <source>Generates a route to handle a trace request to the given path.</source>
          <target state="translated">生成一条路由,用于处理指向指定路径的跟踪请求。</target>
        </trans-unit>
        <trans-unit id="a62a15cee984de5f9b1d155a86ae8b908ee45da6" translate="yes" xml:space="preserve">
          <source>Generates a search input</source>
          <target state="translated">生成一个搜索输入</target>
        </trans-unit>
        <trans-unit id="9a485964d5b7b8267fbecbe17ff5ca372d19bb8a" translate="yes" xml:space="preserve">
          <source>Generates a search input.</source>
          <target state="translated">生成一个搜索输入。</target>
        </trans-unit>
        <trans-unit id="e8a0342fc5c68fc8986011bb012bd0c39bcd4083" translate="yes" xml:space="preserve">
          <source>Generates a secret and prints it to the terminal.</source>
          <target state="translated">生成一个秘密并打印到终端。</target>
        </trans-unit>
        <trans-unit id="67e63e20fe6b5c241bb9891340bbc4e7f9f2e977" translate="yes" xml:space="preserve">
          <source>Generates a select tag with the given &lt;code&gt;options&lt;/code&gt;</source>
          <target state="translated">生成带有给定 &lt;code&gt;options&lt;/code&gt; 的选择标签</target>
        </trans-unit>
        <trans-unit id="8387b222b8a18961d9656292381976a0bb723ec4" translate="yes" xml:space="preserve">
          <source>Generates a select tag with the given &lt;code&gt;options&lt;/code&gt;.</source>
          <target state="translated">用给定的 &lt;code&gt;options&lt;/code&gt; 生成一个选择标签。</target>
        </trans-unit>
        <trans-unit id="2eb9a468a2e248674c486507b7bdb6b1eceae235" translate="yes" xml:space="preserve">
          <source>Generates a self-signed certificate for HTTPS testing.</source>
          <target state="translated">生成用于HTTPS测试的自签名证书。</target>
        </trans-unit>
        <trans-unit id="af0d06afeae9859b4f3fd6e9e412d3a718e92c81" translate="yes" xml:space="preserve">
          <source>Generates a status message from the template name</source>
          <target state="translated">从模板名称中生成一个状态信息</target>
        </trans-unit>
        <trans-unit id="7454d06c3dd95214098294a1b0310dac0b7a4878" translate="yes" xml:space="preserve">
          <source>Generates a status message from the template name.</source>
          <target state="translated">根据模板名称生成状态信息。</target>
        </trans-unit>
        <trans-unit id="067fc3be22bab148f6c9165e5da91f0df3fa5da9" translate="yes" xml:space="preserve">
          <source>Generates a submit button to send the form</source>
          <target state="translated">生成一个提交按钮来发送表格</target>
        </trans-unit>
        <trans-unit id="312f705dccca8c086547117e4724c8592db5695d" translate="yes" xml:space="preserve">
          <source>Generates a submit button to send the form.</source>
          <target state="translated">生成一个提交按钮来发送表格。</target>
        </trans-unit>
        <trans-unit id="f4ea648663e608eaa4d4758ecd78961c842e565e" translate="yes" xml:space="preserve">
          <source>Generates a telephone input</source>
          <target state="translated">产生一个电话输入</target>
        </trans-unit>
        <trans-unit id="912392aacff0f7188b964ec552a88e06572c1c85" translate="yes" xml:space="preserve">
          <source>Generates a telephone input.</source>
          <target state="translated">产生一个电话输入。</target>
        </trans-unit>
        <trans-unit id="54aa2d4862224e6c0fb69837326cc7b97ce5c66a" translate="yes" xml:space="preserve">
          <source>Generates a text input</source>
          <target state="translated">生成一个文本输入</target>
        </trans-unit>
        <trans-unit id="73f0bd438fee7c9707ed766a9afb23c407583846" translate="yes" xml:space="preserve">
          <source>Generates a text input.</source>
          <target state="translated">生成一个文本输入。</target>
        </trans-unit>
        <trans-unit id="45397941ecf32426955313a201964be41c43f1da" translate="yes" xml:space="preserve">
          <source>Generates a textarea input</source>
          <target state="translated">生成一个文本区域输入</target>
        </trans-unit>
        <trans-unit id="126b50f201a72f4c020abacab8f934f9f30a6581" translate="yes" xml:space="preserve">
          <source>Generates a textarea input.</source>
          <target state="translated">生成一个文本区域的输入。</target>
        </trans-unit>
        <trans-unit id="eceb224d2682e883c41b426e06844bbc0bb1dbfb" translate="yes" xml:space="preserve">
          <source>Generates a time input</source>
          <target state="translated">产生一个时间输入</target>
        </trans-unit>
        <trans-unit id="6248af3237dc2fb4fd35ad1108d254199730ac1e" translate="yes" xml:space="preserve">
          <source>Generates a time input.</source>
          <target state="translated">产生一个时间输入。</target>
        </trans-unit>
        <trans-unit id="0ae030fe064e790de454fd16af4f1f68f22484a3" translate="yes" xml:space="preserve">
          <source>Generates a token and stores it in the process dictionary if one does not exist.</source>
          <target state="translated">生成一个令牌,并将其存储在进程字典中,如果不存在的话。</target>
        </trans-unit>
        <trans-unit id="e9144aebe51b655f2f4bb9bb809ff17899371d44" translate="yes" xml:space="preserve">
          <source>Generates a two item tuple containing the &lt;code&gt;static_path&lt;/code&gt; and &lt;code&gt;static_integrity&lt;/code&gt;.</source>
          <target state="translated">生成包含两个元素的元组 &lt;code&gt;static_path&lt;/code&gt; 和 &lt;code&gt;static_integrity&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e07857e5bb53d01eb1dafeb1352fa46eae3a116c" translate="yes" xml:space="preserve">
          <source>Generates a version 4 (random) UUID</source>
          <target state="translated">生成一个版本4(随机)的UUID。</target>
        </trans-unit>
        <trans-unit id="21e2aa08f9efa85d22010347be63b109be8c5a02" translate="yes" xml:space="preserve">
          <source>Generates a version 4 (random) UUID in the binary format</source>
          <target state="translated">生成二进制格式的第4版(随机)UUID。</target>
        </trans-unit>
        <trans-unit id="a0e42f792fb874b4044bce2c20dbf1af12c49012" translate="yes" xml:space="preserve">
          <source>Generates a version 4 (random) UUID in the binary format.</source>
          <target state="translated">生成二进制格式的第4版(随机)UUID。</target>
        </trans-unit>
        <trans-unit id="0f3d3d0bf68951efc2ef0156a57ac19451a2154c" translate="yes" xml:space="preserve">
          <source>Generates a version 4 (random) UUID.</source>
          <target state="translated">生成一个版本4(随机)的UUID。</target>
        </trans-unit>
        <trans-unit id="7f629d614bd57112e09d421f86237a37bc2fa9a5" translate="yes" xml:space="preserve">
          <source>Generates an Ecto model in your Phoenix application.</source>
          <target state="translated">在您的Phoenix应用程序中生成一个Ecto模型。</target>
        </trans-unit>
        <trans-unit id="192881be6736fea74c466100ba43922580a0b06b" translate="yes" xml:space="preserve">
          <source>Generates an Ecto schema and migration.</source>
          <target state="translated">生成Ecto模式和迁移。</target>
        </trans-unit>
        <trans-unit id="3c003e1e5dc81ee91cde965669c00912afc2b27c" translate="yes" xml:space="preserve">
          <source>Generates an email input</source>
          <target state="translated">生成一个电子邮件输入</target>
        </trans-unit>
        <trans-unit id="c7bd255992aaeef9602f0be4b666b7be9fe3a2ba" translate="yes" xml:space="preserve">
          <source>Generates an email input.</source>
          <target state="translated">生成一个电子邮件输入。</target>
        </trans-unit>
        <trans-unit id="6504cdfcb718565b5576fc2158cd57efe4825bb4" translate="yes" xml:space="preserve">
          <source>Generates an embedded Ecto schema for casting/validating data outside the DB.</source>
          <target state="translated">生成一个嵌入式的Ecto模式,用于在DB外部进行数据的转换/验证。</target>
        </trans-unit>
        <trans-unit id="2cad790430badca14ec8c02cc664082faed9f493" translate="yes" xml:space="preserve">
          <source>Generates an img tag with a src</source>
          <target state="translated">生成一个带有 src 的 img 标签。</target>
        </trans-unit>
        <trans-unit id="9b6859233f63365d7a32da180d650f35004ce39e" translate="yes" xml:space="preserve">
          <source>Generates an img tag with a src.</source>
          <target state="translated">生成一个带有 src 的 img 标签。</target>
        </trans-unit>
        <trans-unit id="31a11500f500d76442b5a7660ff34e1c46e8aaa8" translate="yes" xml:space="preserve">
          <source>Generates an integrity hash to a static file in &lt;code&gt;priv/static&lt;/code&gt;.</source>
          <target state="translated">生成完整性哈希到 &lt;code&gt;priv/static&lt;/code&gt; 中的静态文件。</target>
        </trans-unit>
        <trans-unit id="94584e370048710080737b7da1191363a53d9074" translate="yes" xml:space="preserve">
          <source>Generates an url input</source>
          <target state="translated">生成一个网址输入</target>
        </trans-unit>
        <trans-unit id="41f536102076cb368a63c9729925c85b108feb67" translate="yes" xml:space="preserve">
          <source>Generates an url input.</source>
          <target state="translated">生成一个url输入。</target>
        </trans-unit>
        <trans-unit id="3eaee8e36f647786a53b9f964255fe72cc821f1a" translate="yes" xml:space="preserve">
          <source>Generates controller, views, and context for a JSON resource.</source>
          <target state="translated">为JSON资源生成控制器、视图和上下文。</target>
        </trans-unit>
        <trans-unit id="822515dec0a67435114ec101cc230428d2840774" translate="yes" xml:space="preserve">
          <source>Generates controller, views, and context for an HTML resource.</source>
          <target state="translated">为一个HTML资源生成控制器、视图和上下文。</target>
        </trans-unit>
        <trans-unit id="be50e5d315403c8a6e5ed901af8b36c1c04a5c95" translate="yes" xml:space="preserve">
          <source>Generates controller, views, and context for an JSON resource.</source>
          <target state="translated">为JSON资源生成控制器、视图和上下文。</target>
        </trans-unit>
        <trans-unit id="e78eb34839e1acd728f57541f822721b2b3ba7cc" translate="yes" xml:space="preserve">
          <source>Generates hidden inputs for the given form.</source>
          <target state="translated">生成给定表格的隐藏输入。</target>
        </trans-unit>
        <trans-unit id="f8b426df53681f88f2110c30af8bf84dbae2dbb1" translate="yes" xml:space="preserve">
          <source>Generates select tags for date</source>
          <target state="translated">生成日期的选择标签</target>
        </trans-unit>
        <trans-unit id="900feb5d8076251ce1c88b1c50c88ed36d4df204" translate="yes" xml:space="preserve">
          <source>Generates select tags for date.</source>
          <target state="translated">生成日期的选择标签。</target>
        </trans-unit>
        <trans-unit id="33944458ee24e52c6f57b54406929743c95d1e0f" translate="yes" xml:space="preserve">
          <source>Generates select tags for datetime</source>
          <target state="translated">生成日期时间的选择标签</target>
        </trans-unit>
        <trans-unit id="b91c0777babdf510129bdd926e272571b56c507a" translate="yes" xml:space="preserve">
          <source>Generates select tags for datetime.</source>
          <target state="translated">生成日期时间的选择标签。</target>
        </trans-unit>
        <trans-unit id="2989d503428e011977ec7d2d26ea57f0cd501ff1" translate="yes" xml:space="preserve">
          <source>Generates select tags for time</source>
          <target state="translated">生成时间的选择标签</target>
        </trans-unit>
        <trans-unit id="44c3290708cfe98a895d3932d31b3028cf656029" translate="yes" xml:space="preserve">
          <source>Generates select tags for time.</source>
          <target state="translated">生成时间的选择标签。</target>
        </trans-unit>
        <trans-unit id="06abc3fc049f6aeb29e4374ef7a511dc801188d0" translate="yes" xml:space="preserve">
          <source>Generates the endpoint base URL without any path information</source>
          <target state="translated">生成不含任何路径信息的端点基本URL。</target>
        </trans-unit>
        <trans-unit id="0c54d53d2a725dae194fd5931fc6e94b42a7bafb" translate="yes" xml:space="preserve">
          <source>Generates the endpoint base URL without any path information.</source>
          <target state="translated">生成没有任何路径信息的端点基本URL。</target>
        </trans-unit>
        <trans-unit id="566783b0db0c0900209be301c7fb5794061562a0" translate="yes" xml:space="preserve">
          <source>Generates the endpoint base URL, but as a &lt;a href=&quot;https://hexdocs.pm/elixir/URI.html&quot;&gt;&lt;code&gt;URI&lt;/code&gt;&lt;/a&gt; struct</source>
          <target state="translated">生成端点基本URL，但作为&lt;a href=&quot;https://hexdocs.pm/elixir/URI.html&quot;&gt; &lt;code&gt;URI&lt;/code&gt; &lt;/a&gt;结构</target>
        </trans-unit>
        <trans-unit id="a457480f3b7970598a96e97a308a2c57be1d9d62" translate="yes" xml:space="preserve">
          <source>Generates the endpoint base URL, but as a &lt;a href=&quot;https://hexdocs.pm/elixir/URI.html&quot;&gt;&lt;code&gt;URI&lt;/code&gt;&lt;/a&gt; struct.</source>
          <target state="translated">生成端点基本URL，但作为&lt;a href=&quot;https://hexdocs.pm/elixir/URI.html&quot;&gt; &lt;code&gt;URI&lt;/code&gt; &lt;/a&gt;结构。</target>
        </trans-unit>
        <trans-unit id="a56e0e8f6c89e5bcd6f332dfe4a7f18f1d712206" translate="yes" xml:space="preserve">
          <source>Generates the path information when routing to this endpoint</source>
          <target state="translated">当路由到该端点时,生成路径信息。</target>
        </trans-unit>
        <trans-unit id="9de6c6bdf8366eaa60f44b75556d6710e9111768" translate="yes" xml:space="preserve">
          <source>Generates the path information when routing to this endpoint.</source>
          <target state="translated">当路由到这个端点时,生成路径信息。</target>
        </trans-unit>
        <trans-unit id="92831dcf10942016c97191fd271c8140a6105d73" translate="yes" xml:space="preserve">
          <source>Generates the static URL without any path information.</source>
          <target state="translated">生成没有任何路径信息的静态URL。</target>
        </trans-unit>
        <trans-unit id="d336eb35990be39ada49eb89ccf7bc531bbf8d59" translate="yes" xml:space="preserve">
          <source>Generating typespecs for schemas is out of the scope of &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Ecto.Schema&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">为模式生成typespec不在Ecto.Schema的范围之&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Ecto.Schema&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c7afc8fed6ae07096bcda43b2c180de120f70394" translate="yes" xml:space="preserve">
          <source>Generating without a schema</source>
          <target state="translated">无模式生成</target>
        </trans-unit>
        <trans-unit id="3b22374ca8da32cfe346b6ca99bea860d67b2484" translate="yes" xml:space="preserve">
          <source>Generating without a schema or context file</source>
          <target state="translated">在没有模式或上下文文件的情况下生成</target>
        </trans-unit>
        <trans-unit id="24e7830f821b426f5a51f69a462e899b6faff3ad" translate="yes" xml:space="preserve">
          <source>Gets a change or returns a default value</source>
          <target state="translated">获取一个变化或返回一个默认值</target>
        </trans-unit>
        <trans-unit id="20c69fc2d13ee5ae1e5c766de8168c5e86eac703" translate="yes" xml:space="preserve">
          <source>Gets a change or returns a default value.</source>
          <target state="translated">获取一个变化或返回一个默认值。</target>
        </trans-unit>
        <trans-unit id="ae896285359a3676cf6a8e84fe64f02a1009d1d3" translate="yes" xml:space="preserve">
          <source>Gets a field from changes or from the data</source>
          <target state="translated">从变化或数据中获取字段</target>
        </trans-unit>
        <trans-unit id="bd5eebfdc41b8efa306222262683e1e2cb53f629" translate="yes" xml:space="preserve">
          <source>Gets a field from changes or from the data.</source>
          <target state="translated">从变化或数据中获取一个字段。</target>
        </trans-unit>
        <trans-unit id="f0ad8554cfab9a4c20a7b61ea4176e67168e383d" translate="yes" xml:space="preserve">
          <source>Gets a path relative to the application path</source>
          <target state="translated">获取一个相对于应用程序路径的路径</target>
        </trans-unit>
        <trans-unit id="54e09b22dc0bfd8c0d4977361cbe415e92fbad7a" translate="yes" xml:space="preserve">
          <source>Gets a path relative to the application path.</source>
          <target state="translated">获取一个相对于应用程序路径的路径。</target>
        </trans-unit>
        <trans-unit id="988d679daebf10d001e25c095b5b9e286e6bc11c" translate="yes" xml:space="preserve">
          <source>Gets how the type is treated inside embeds for the given format.</source>
          <target state="translated">获取在给定格式的嵌入中如何处理类型。</target>
        </trans-unit>
        <trans-unit id="df3ff2dbf500da7f3bca6907ee8045b12c112c08" translate="yes" xml:space="preserve">
          <source>Gets or generates a CSRF token.</source>
          <target state="translated">获取或生成一个CSRF令牌。</target>
        </trans-unit>
        <trans-unit id="997af9359b0274152d5976f8e8ca9230b5813c54" translate="yes" xml:space="preserve">
          <source>Gets presences tracked under a given topic and key pair</source>
          <target state="translated">获取给定主题和密钥对下的出席率跟踪。</target>
        </trans-unit>
        <trans-unit id="48f0745d124d4e83473eebb47a6d31ab2415d144" translate="yes" xml:space="preserve">
          <source>Gets presences tracked under a given topic and key pair.</source>
          <target state="translated">获取给定主题和密钥对下的出席情况跟踪。</target>
        </trans-unit>
        <trans-unit id="97e4290574c5ed51caafb10b2de1e172c163410b" translate="yes" xml:space="preserve">
          <source>Gets the CSRF token</source>
          <target state="translated">获取CSRF令牌</target>
        </trans-unit>
        <trans-unit id="08349fa609238bb75520280fb127235024b0eb68" translate="yes" xml:space="preserve">
          <source>Gets the CSRF token for the associated URL (as a string or a URI struct)</source>
          <target state="translated">获取相关URL的CSRF标记(字符串或URI结构)。</target>
        </trans-unit>
        <trans-unit id="ff08f49db7e1265b7a0948738482fffe83f058a7" translate="yes" xml:space="preserve">
          <source>Gets the CSRF token for the associated URL (as a string or a URI struct).</source>
          <target state="translated">获取相关URL的CSRF标记(字符串或URI结构)。</target>
        </trans-unit>
        <trans-unit id="8d4fe3f1095bcbf480568f707f0f32660bfed495" translate="yes" xml:space="preserve">
          <source>Gets the CSRF token.</source>
          <target state="translated">获取CSRF令牌。</target>
        </trans-unit>
        <trans-unit id="cacf574b487bbebb0a08dffbbbde22c3caa9dd7c" translate="yes" xml:space="preserve">
          <source>Gets the given key from the flash storage</source>
          <target state="translated">从闪存中获取给定的密钥。</target>
        </trans-unit>
        <trans-unit id="39a3c0f8225971cc340f65e20abcd3cfd296785c" translate="yes" xml:space="preserve">
          <source>Gets the given key from the flash storage.</source>
          <target state="translated">从闪存中获取给定的密钥。</target>
        </trans-unit>
        <trans-unit id="96a62524d2bf17765eab415eae3c27d04f1cdf6a" translate="yes" xml:space="preserve">
          <source>Gets the input type for a given field</source>
          <target state="translated">获取给定字段的输入类型。</target>
        </trans-unit>
        <trans-unit id="66f52ba2db0eb578cab960fd32bdb155e164ce6a" translate="yes" xml:space="preserve">
          <source>Gets the input type for a given field.</source>
          <target state="translated">获取指定字段的输入类型。</target>
        </trans-unit>
        <trans-unit id="b27071d61374355defa4f7ba87856a1483070f41" translate="yes" xml:space="preserve">
          <source>Gets the metadata from the given struct</source>
          <target state="translated">从给定结构中获取元数据。</target>
        </trans-unit>
        <trans-unit id="678baa7f889b181e04ecd1461201171108459f0b" translate="yes" xml:space="preserve">
          <source>Gets the metadata from the given struct.</source>
          <target state="translated">从给定结构中获取元数据。</target>
        </trans-unit>
        <trans-unit id="3304a8905eb384bf8c92d54b81cce4e1c7c19f8b" translate="yes" xml:space="preserve">
          <source>Gets the nested LiveView child by &lt;code&gt;child_id&lt;/code&gt; from the &lt;code&gt;parent&lt;/code&gt; LiveView.</source>
          <target state="translated">通过获取实时查看嵌套子 &lt;code&gt;child_id&lt;/code&gt; 从 &lt;code&gt;parent&lt;/code&gt; 实时查看。</target>
        </trans-unit>
        <trans-unit id="4aa65e24dc6d0d5c51eaeaf4bdd4b579ff2fe71c" translate="yes" xml:space="preserve">
          <source>Gets the store name from an atom or a module.</source>
          <target state="translated">从原子或模块中获取存储名称。</target>
        </trans-unit>
        <trans-unit id="1baad63621d111aecd80381a2421d2b880bc0a22" translate="yes" xml:space="preserve">
          <source>Gets the whole flash storage</source>
          <target state="translated">获取整个闪存</target>
        </trans-unit>
        <trans-unit id="64814fa71bd4c722ebaa70f584d80370c84fe56a" translate="yes" xml:space="preserve">
          <source>Gets the whole flash storage.</source>
          <target state="translated">获取整个闪存。</target>
        </trans-unit>
        <trans-unit id="010b85ad56b34c34c7c2a3b2436c740e30428ed5" translate="yes" xml:space="preserve">
          <source>Getting Started</source>
          <target state="translated">入门</target>
        </trans-unit>
        <trans-unit id="6e3f22a652c385048db92eec4f86769df4e6a06f" translate="yes" xml:space="preserve">
          <source>Getting Started with Phoenix (by Pluralsight - 2017)</source>
          <target state="translated">凤凰城入门(由Pluralsight--2017年)。</target>
        </trans-unit>
        <trans-unit id="76e7a3a3f9c225fe820ba7e9cff10ea2a73b79a1" translate="yes" xml:space="preserve">
          <source>Getting started</source>
          <target state="translated">开始</target>
        </trans-unit>
        <trans-unit id="c058929c7d291e4d62d960baf0a6197123595989" translate="yes" xml:space="preserve">
          <source>Give the Erlang/OTP runtime (that is, the BEAM VM executable) permission to bind to privileged ports using 'setcap', e.g. &lt;code&gt;sudo setcap 'cap_net_bind_service=+ep' /usr/lib/erlang/erts-10.1/bin/beam.smp&lt;/code&gt;; update the path as necessary, and remember to run the command again after Erlang upgrades</source>
          <target state="translated">授予Erlang / OTP运行时（即BEAM VM可执行文件）使用'setcap'绑定到特权端口的权限，例如 &lt;code&gt;sudo setcap 'cap_net_bind_service=+ep' /usr/lib/erlang/erts-10.1/bin/beam.smp&lt;/code&gt; ; 根据需要更新路径，并记住在Erlang升级后再次运行该命令</target>
        </trans-unit>
        <trans-unit id="7f8730e43ab24e7c728fed006e4af4c853f6327c" translate="yes" xml:space="preserve">
          <source>Given almost all &lt;a href=&quot;phoenix.liveview#c:mount/3&quot;&gt;&lt;code&gt;mount/3&lt;/code&gt;&lt;/a&gt; actions in your application will have to perform these exact steps, we recommend creating a function called &lt;code&gt;assign_defaults/2&lt;/code&gt; or similar, putting it in a new module like &lt;code&gt;MyAppWeb.LiveHelpers&lt;/code&gt;, and modifying &lt;code&gt;lib/my_app_web.ex&lt;/code&gt; so all LiveViews automatically import it:</source>
          <target state="translated">鉴于应用程序中几乎所有的&lt;a href=&quot;phoenix.liveview#c:mount/3&quot;&gt; &lt;code&gt;mount/3&lt;/code&gt; &lt;/a&gt;操作都必须执行这些确切的步骤，我们建议创建一个名为 &lt;code&gt;assign_defaults/2&lt;/code&gt; 或类似函数，将其放入 &lt;code&gt;MyAppWeb.LiveHelpers&lt;/code&gt; 等新模块中，并修改 &lt;code&gt;lib/my_app_web.ex&lt;/code&gt; ,以便所有LiveViews自动将其导入：</target>
        </trans-unit>
        <trans-unit id="1a4181efd0f5aa1fb39a060e1a478e56b7d07cbd" translate="yes" xml:space="preserve">
          <source>Given components compartmentalize markup on the server, they are also rendered in isolation on the client, which provides great performance benefits on the client too.</source>
          <target state="translated">鉴于组件在服务器上对标记进行了分门别类,它们在客户端上也是孤立呈现的,这在客户端上也提供了很大的性能优势。</target>
        </trans-unit>
        <trans-unit id="47b0c7375e98f73f52e1b737eb418a247d1da8fd" translate="yes" xml:space="preserve">
          <source>Given that a LiveView runs on its own process, it is an excellent tool for creating completely isolated UI elements, but it is a slightly expensive abstraction if all you want is to compartmentalize markup and events. For example, if you are showing a table with all users in the system, and you want to compartmentalize this logic, rendering a separate &lt;code&gt;LiveView&lt;/code&gt; for each user, then using a process per user would likely be too expensive. For these cases, LiveView provides &lt;a href=&quot;phoenix.livecomponent&quot;&gt;&lt;code&gt;Phoenix.LiveComponent&lt;/code&gt;&lt;/a&gt;, which are rendered using &lt;code&gt;live_component/3&lt;/code&gt;:</source>
          <target state="translated">鉴于LiveView在其自己的进程上运行，它是用于创建完全隔离的UI元素的出色工具，但是如果您只想分隔标记和事件，则它是一个稍微昂贵的抽象。例如，如果要显示一个包含系统中所有用户的表，并且要划分此逻辑，为每个用户呈现一个单独的 &lt;code&gt;LiveView&lt;/code&gt; ，则每个用户使用一个进程可能会太昂贵。对于这些情况，LiveView提供&lt;a href=&quot;phoenix.livecomponent&quot;&gt; &lt;code&gt;Phoenix.LiveComponent&lt;/code&gt; &lt;/a&gt;，它们使用 &lt;code&gt;live_component/3&lt;/code&gt; 呈现：</target>
        </trans-unit>
        <trans-unit id="b50f484d78e3b110b11618fae5e4f8de3a3ef714" translate="yes" xml:space="preserve">
          <source>Given the button does not appear in the UI, triggering the &quot;leave&quot; when the organization has now only one member is an unexpected scenario. This means we can probably rewrite the code above to:</source>
          <target state="translated">鉴于该按钮没有出现在UI中,当组织现在只有一个成员时,触发 &quot;离开 &quot;是一个意想不到的情况。这意味着我们或许可以将上面的代码重写为:。</target>
        </trans-unit>
        <trans-unit id="eaafd2714d8805ff67c29755c6b072c4bffa71a8" translate="yes" xml:space="preserve">
          <source>Given the code on mount runs both on the initial disconnected render and the connected render, an exception on mount will trigger the following events:</source>
          <target state="translated">鉴于挂载上的代码同时在初始断开的渲染和连接的渲染上运行,挂载上的异常将触发以下事件。</target>
        </trans-unit>
        <trans-unit id="f418c387ce0535243c1ffc04f850d20578d8ccef" translate="yes" xml:space="preserve">
          <source>Globs can match segments partially too. The difference is the whole segment is captured along with the trailing segments.</source>
          <target state="translated">Globs也可以部分匹配段。不同的是,整个片段与尾部的片段一起被捕获。</target>
        </trans-unit>
        <trans-unit id="2a88c991df04bd6fcf2fb3f005a3c9207b89cc95" translate="yes" xml:space="preserve">
          <source>Go to &quot;&lt;a href=&quot;http://localhost:4000/%22&quot;&gt;http://localhost:4000/&quot;&lt;/a&gt; and you should see the locale exhibited. Visit &quot;&lt;a href=&quot;http://localhost:4000/?locale=fr%22&quot;&gt;http://localhost:4000/?locale=fr&quot;&lt;/a&gt; and you should see the assign changed to &quot;fr&quot;. Someone can use this information alongside &lt;a href=&quot;https://hexdocs.pm/gettext/Gettext.html&quot;&gt;Gettext&lt;/a&gt; to provide a fully internationalized web application.</source>
          <target state="translated">转到&amp;ldquo; &lt;a href=&quot;http://localhost:4000/%22&quot;&gt;http：// localhost：4000 /&amp;rdquo;&lt;/a&gt;，您应该看到显示的语言环境。访问&amp;ldquo; &lt;a href=&quot;http://localhost:4000/?locale=fr%22&quot;&gt;http：// localhost：4000 /？locale = fr&amp;rdquo;&lt;/a&gt;，您应该看到分配已更改为&amp;ldquo; fr&amp;rdquo;。有人可以将这些信息与&lt;a href=&quot;https://hexdocs.pm/gettext/Gettext.html&quot;&gt;Gettext&lt;/a&gt;一起使用，以提供完全国际化的Web应用程序。</target>
        </trans-unit>
        <trans-unit id="085bd772dd72f1ee66df662034a18b6fef587590" translate="yes" xml:space="preserve">
          <source>Good work!</source>
          <target state="translated">干得好!</target>
        </trans-unit>
        <trans-unit id="f179b6f36465b5aac2f67605586252775def9c70" translate="yes" xml:space="preserve">
          <source>Good:</source>
          <target state="translated">Good:</target>
        </trans-unit>
        <trans-unit id="eef0115acb31caa0fbd5afc01384c4545e7d44b5" translate="yes" xml:space="preserve">
          <source>Gracefully shuts down by broadcasting permdown to all replicas</source>
          <target state="translated">通过向所有副本广播permdown来优雅地关闭。</target>
        </trans-unit>
        <trans-unit id="37401107a71883efc56c3d07974d72873ad8f857" translate="yes" xml:space="preserve">
          <source>Gracefully shuts down by broadcasting permdown to all replicas.</source>
          <target state="translated">通过向所有副本广播permdown来优雅地关闭。</target>
        </trans-unit>
        <trans-unit id="96c55d61787ebd67d87c36f604142bfa3949dd6e" translate="yes" xml:space="preserve">
          <source>Great, so we have this &lt;code&gt;template_not_found/2&lt;/code&gt; function that takes a template and an &lt;code&gt;assigns&lt;/code&gt; map, which we ignore. The &lt;code&gt;template_not_found/2&lt;/code&gt; is invoked whenever a Phoenix.View attempts to render a template but no template is found.</source>
          <target state="translated">太好了，所以我们有这个 &lt;code&gt;template_not_found/2&lt;/code&gt; 函数，它接受一个模板和一个 &lt;code&gt;assigns&lt;/code&gt; 映射，我们将其忽略。该 &lt;code&gt;template_not_found/2&lt;/code&gt; 被调用每当Phoenix.View试图呈现一个模板，但没有模板发现。</target>
        </trans-unit>
        <trans-unit id="7b2bb758deee9a18063c4c798fcdec3e64196126" translate="yes" xml:space="preserve">
          <source>Groups are also supported:</source>
          <target state="translated">还支持组。</target>
        </trans-unit>
        <trans-unit id="d16fde456fa6a9274b8f28cf87784f0670263c64" translate="yes" xml:space="preserve">
          <source>Groups together rows from the schema that have the same values in the given fields. Using &lt;code&gt;group_by&lt;/code&gt; &quot;groups&quot; the query giving it different semantics in the &lt;code&gt;select&lt;/code&gt; expression. If a query is grouped, only fields that were referenced in the &lt;code&gt;group_by&lt;/code&gt; can be used in the &lt;code&gt;select&lt;/code&gt; or if the field is given as an argument to an aggregate function.</source>
          <target state="translated">将模式中在给定字段中具有相同值的行分组在一起。使用 &lt;code&gt;group_by&lt;/code&gt; 将查询&amp;ldquo;分组&amp;rdquo;，使查询在 &lt;code&gt;select&lt;/code&gt; 表达式中具有不同的语义。如果将查询分组，则只能在 &lt;code&gt;select&lt;/code&gt; 中使用在 &lt;code&gt;group_by&lt;/code&gt; 中引用的字段，或者如果该字段是作为聚合函数的参数给出的。</target>
        </trans-unit>
        <trans-unit id="573359f98da0f46d93ce375944dfc230b3eb131f" translate="yes" xml:space="preserve">
          <source>Groups together rows from the schema that have the same values in the given fields. Using &lt;code&gt;group_by&lt;/code&gt; &amp;ldquo;groups&amp;rdquo; the query giving it different semantics in the &lt;code&gt;select&lt;/code&gt; expression. If a query is grouped, only fields that were referenced in the &lt;code&gt;group_by&lt;/code&gt; can be used in the &lt;code&gt;select&lt;/code&gt; or if the field is given as an argument to an aggregate function.</source>
          <target state="translated">将模式中在给定字段中具有相同值的行分组在一起。使用 &lt;code&gt;group_by&lt;/code&gt; 将查询&amp;ldquo;分组&amp;rdquo;，使查询在 &lt;code&gt;select&lt;/code&gt; 表达式中具有不同的语义。如果将查询分组，则只能在 &lt;code&gt;select&lt;/code&gt; 中使用 &lt;code&gt;group_by&lt;/code&gt; 中引用的字段，或者该字段作为聚合函数的参数提供。</target>
        </trans-unit>
        <trans-unit id="0d28e5466fe7edf9be0a19b777c6efbf4fc0f1b9" translate="yes" xml:space="preserve">
          <source>Groxio LiveView: Self Study Program (by Bruce Tate - 2020)</source>
          <target state="translated">Groxio LiveView。自学计划(由Bruce Tate编写-2020年</target>
        </trans-unit>
        <trans-unit id="9de813d4a22ea43705b2409ca317c4ad7be16554" translate="yes" xml:space="preserve">
          <source>Guaranteed to be safe</source>
          <target state="translated">保证安全</target>
        </trans-unit>
        <trans-unit id="67de3c63a9bd94b74bfc86944368ab7bcdf6d849" translate="yes" xml:space="preserve">
          <source>Guards</source>
          <target state="translated">Guards</target>
        </trans-unit>
        <trans-unit id="929a28d261428029e61c0f81c6161fd71ba0b2fe" translate="yes" xml:space="preserve">
          <source>Guides</source>
          <target state="translated">Guides</target>
        </trans-unit>
        <trans-unit id="d7240b32bd4fb13ad180c29bf544480d25f32149" translate="yes" xml:space="preserve">
          <source>Guides - in-depth guides covering the main components in Phoenix and Phoenix applications</source>
          <target state="translated">指南--深度指南,涵盖凤凰城和凤凰城应用中的主要组件。</target>
        </trans-unit>
        <trans-unit id="43ec996853ae990b117722b3dedca88ce5b8b0cb" translate="yes" xml:space="preserve">
          <source>HTML Safe</source>
          <target state="translated">HTML安全</target>
        </trans-unit>
        <trans-unit id="92b092172a89d9cb7710c23a35bcf58905e6ddfd" translate="yes" xml:space="preserve">
          <source>HTTP Strict Transport Security (HSTS)</source>
          <target state="translated">HTTP严格传输安全(HSTS)</target>
        </trans-unit>
        <trans-unit id="c41e81014d243f2d8875ff68c15a184a372a6901" translate="yes" xml:space="preserve">
          <source>HTTP/2 does not support chunking and will instead stream the response without a transfer encoding. When using HTTP/1.1, the Cowboy adapter will stream the response instead of emitting chunks if the &lt;code&gt;content-length&lt;/code&gt; header has been set before calling &lt;a href=&quot;#send_chunked/2&quot;&gt;&lt;code&gt;send_chunked/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">HTTP / 2不支持分块，而是在没有传输编码的情况下流式传输响应。使用HTTP / 1.1时，如果在调用&lt;a href=&quot;#send_chunked/2&quot;&gt; &lt;code&gt;send_chunked/2&lt;/code&gt; &lt;/a&gt;之前已设置了 &lt;code&gt;content-length&lt;/code&gt; 标头，则Cowboy适配器将流式传输响应，而不发出块。</target>
        </trans-unit>
        <trans-unit id="f52698c28f0d2036450e02a85451ee4f5be02442" translate="yes" xml:space="preserve">
          <source>HTTPS</source>
          <target state="translated">HTTPS</target>
        </trans-unit>
        <trans-unit id="657152afda0bee08d931b261408d17d0b6e96e52" translate="yes" xml:space="preserve">
          <source>Halting a plug pipeline</source>
          <target state="translated">停止堵塞管道</target>
        </trans-unit>
        <trans-unit id="1da643070952e956d86d49f8c58821c92fb71c6e" translate="yes" xml:space="preserve">
          <source>Halts the Plug pipeline by preventing further plugs downstream from being invoked. See the docs for &lt;a href=&quot;plug.builder&quot;&gt;&lt;code&gt;Plug.Builder&lt;/code&gt;&lt;/a&gt; for more information on halting a Plug pipeline</source>
          <target state="translated">通过防止进一步调用下游插件来停止插件管道。有关停止Plug管道的更多信息，请参见&lt;a href=&quot;plug.builder&quot;&gt; &lt;code&gt;Plug.Builder&lt;/code&gt; &lt;/a&gt;的文档。</target>
        </trans-unit>
        <trans-unit id="d9755cdf0347f99433eabcbc87b332485d5af95e" translate="yes" xml:space="preserve">
          <source>Halts the Plug pipeline by preventing further plugs downstream from being invoked. See the docs for &lt;a href=&quot;plug.builder&quot;&gt;&lt;code&gt;Plug.Builder&lt;/code&gt;&lt;/a&gt; for more information on halting a Plug pipeline.</source>
          <target state="translated">通过防止进一步调用下游插件来停止插件管道。有关停止Plug管道的更多信息，请参见&lt;a href=&quot;plug.builder&quot;&gt; &lt;code&gt;Plug.Builder&lt;/code&gt; &lt;/a&gt;的文档。</target>
        </trans-unit>
        <trans-unit id="1ccd69770e67bfc169e02509f802dfa9b974fafd" translate="yes" xml:space="preserve">
          <source>Halts the Plug pipeline by preventing further plugs downstream from being invoked. See the docs for &lt;a href=&quot;plug.builder&quot;&gt;&lt;code&gt;Plug.Builder&lt;/code&gt;&lt;/a&gt; for more information on halting a plug pipeline</source>
          <target state="translated">通过防止进一步调用下游插件来停止插件管道。有关停止插件管道的更多信息，请参见&lt;a href=&quot;plug.builder&quot;&gt; &lt;code&gt;Plug.Builder&lt;/code&gt; &lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="eb6de5553592ef40a29a33d8a4f534ccdca762c0" translate="yes" xml:space="preserve">
          <source>Halts the Plug pipeline by preventing further plugs downstream from being invoked. See the docs for &lt;a href=&quot;plug.builder&quot;&gt;&lt;code&gt;Plug.Builder&lt;/code&gt;&lt;/a&gt; for more information on halting a plug pipeline.</source>
          <target state="translated">通过防止进一步调用下游插件来停止插件管道。有关停止插件管道的更多信息，请参见&lt;a href=&quot;plug.builder&quot;&gt; &lt;code&gt;Plug.Builder&lt;/code&gt; &lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="1179f95ead9bf0b9717da1e2ecfd57e128a47608" translate="yes" xml:space="preserve">
          <source>Handle channel joins by &lt;code&gt;topic&lt;/code&gt;.</source>
          <target state="translated">按 &lt;code&gt;topic&lt;/code&gt; 处理频道加入。</target>
        </trans-unit>
        <trans-unit id="c751925f47985ead2c5d331b34495a279ea3f7ba" translate="yes" xml:space="preserve">
          <source>Handle incoming &lt;code&gt;event&lt;/code&gt;s.</source>
          <target state="translated">处理传入 &lt;code&gt;event&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="82f1e20c501a3974e2888a65dd307415f027f8bd" translate="yes" xml:space="preserve">
          <source>Handle regular Elixir process messages.</source>
          <target state="translated">处理常规的Elixir进程消息。</target>
        </trans-unit>
        <trans-unit id="34e4b67d91a6a5a47ead00c473556ef12172e644" translate="yes" xml:space="preserve">
          <source>Handle regular GenServer call messages.</source>
          <target state="translated">处理常规的GenServer呼叫信息。</target>
        </trans-unit>
        <trans-unit id="0bdffc90c861d354d82cfba6f42150171080724c" translate="yes" xml:space="preserve">
          <source>Handle regular GenServer cast messages.</source>
          <target state="translated">处理常规的GenServer投递信息。</target>
        </trans-unit>
        <trans-unit id="f294e1b14ab763746b32a9cdc98d993760a810d1" translate="yes" xml:space="preserve">
          <source>Handles incoming control frames.</source>
          <target state="translated">处理传入的控制帧。</target>
        </trans-unit>
        <trans-unit id="7d31dbed02487ad3b79dcccdca1c4517c3e304c7" translate="yes" xml:space="preserve">
          <source>Handles incoming socket messages.</source>
          <target state="translated">处理传入的套接字消息。</target>
        </trans-unit>
        <trans-unit id="0ad1d4d7277dfbcb95f451d9d6d7bfc9124cb930" translate="yes" xml:space="preserve">
          <source>Handles info messages.</source>
          <target state="translated">处理信息消息。</target>
        </trans-unit>
        <trans-unit id="5af19f504ed390f3616fe54d71be3c982a36fb0f" translate="yes" xml:space="preserve">
          <source>Handles the socket connection</source>
          <target state="translated">处理插座连接</target>
        </trans-unit>
        <trans-unit id="5b3b8d6bf0e0ed4f6147a59b927ffe862e49bdc4" translate="yes" xml:space="preserve">
          <source>Handles the socket connection.</source>
          <target state="translated">处理插座的连接。</target>
        </trans-unit>
        <trans-unit id="58514a1474cd3c04b6d7d45448e942f451571bf2" translate="yes" xml:space="preserve">
          <source>Handling of incoming messages</source>
          <target state="translated">处理收到的信息</target>
        </trans-unit>
        <trans-unit id="2b9f4508a5e4fc2c2b5ef7294940c248c8c75fd4" translate="yes" xml:space="preserve">
          <source>Handling of outgoing messages</source>
          <target state="translated">处理发出的信息</target>
        </trans-unit>
        <trans-unit id="5827156e9f14bdd8a3697b80209b3e3c181665d5" translate="yes" xml:space="preserve">
          <source>Handling of user interaction and inputs, buttons, and forms - such as input validation, dynamic forms, autocomplete, etc;</source>
          <target state="translated">处理用户交互和输入、按钮和表单--如输入验证、动态表单、自动完成等。</target>
        </trans-unit>
        <trans-unit id="791b3d718f251049300fc903f9b075211bce25f5" translate="yes" xml:space="preserve">
          <source>Handling request data can be done through the &lt;a href=&quot;../plug.parsers#content&quot;&gt;&lt;code&gt;Plug.Parsers&lt;/code&gt;&lt;/a&gt; plug. It provides support for parsing URL-encoded, form-data, and JSON data as well as providing a behaviour that others parsers can adopt.</source>
          <target state="translated">可以通过&lt;a href=&quot;../plug.parsers#content&quot;&gt; &lt;code&gt;Plug.Parsers&lt;/code&gt; &lt;/a&gt;插件处理请求数据。它支持解析URL编码，表单数据和JSON数据，并提供其他解析器可以采用的行为。</target>
        </trans-unit>
        <trans-unit id="b5824e50c0788d6515b063060ac394cb11876c16" translate="yes" xml:space="preserve">
          <source>Handling request data can be done through the &lt;a href=&quot;plug.parsers#content&quot;&gt;&lt;code&gt;Plug.Parsers&lt;/code&gt;&lt;/a&gt; plug. It provides support for parsing URL-encoded, form-data, and JSON data as well as providing a behaviour that others parsers can adopt.</source>
          <target state="translated">可以通过&lt;a href=&quot;plug.parsers#content&quot;&gt; &lt;code&gt;Plug.Parsers&lt;/code&gt; &lt;/a&gt;插件处理请求数据。它支持解析URL编码，表单数据和JSON数据，并提供其他解析器可以采用的行为。</target>
        </trans-unit>
        <trans-unit id="c698c3591147b68316110c515f5214cf7d5b3183" translate="yes" xml:space="preserve">
          <source>Having different precisions allows developers to choose a type that will be compatible with the database and your project's precision requirements. For example, some older versions of MySQL do not support microseconds in datetime fields.</source>
          <target state="translated">拥有不同的精度可以让开发人员选择一种与数据库和你的项目精度要求兼容的类型。例如,一些旧版本的MySQL不支持日期时间字段中的微秒。</target>
        </trans-unit>
        <trans-unit id="87609125a9917f1d1304583fa33c13ec60b69a2f" translate="yes" xml:space="preserve">
          <source>Having these different types allows developers to choose a type that will be compatible with the database and your project&amp;rsquo;s precision requirements. For example, some older versions of MySQL do not support microseconds in datetime fields.</source>
          <target state="translated">具有这些不同的类型使开发人员可以选择与数据库和项目的精度要求兼容的类型。例如，某些旧版本的MySQL在日期时间字段中不支持微秒。</target>
        </trans-unit>
        <trans-unit id="3c9b3433e6f225e4ae00ef2041d44d91bfbf7113" translate="yes" xml:space="preserve">
          <source>Helpers</source>
          <target state="translated">Helpers</target>
        </trans-unit>
        <trans-unit id="2a35b8be1233091ad5332bbf56f5dc2f7b98ac70" translate="yes" xml:space="preserve">
          <source>Helpers are automatically generated based on the controller name. For example, the route:</source>
          <target state="translated">助手是根据控制器名称自动生成的。例如,路由。</target>
        </trans-unit>
        <trans-unit id="ea3deafd82332a10202987c8c0e45b4f54638c37" translate="yes" xml:space="preserve">
          <source>Helpers for working with HTML strings and templates.</source>
          <target state="translated">用于处理HTML字符串和模板的助手。</target>
        </trans-unit>
        <trans-unit id="42e29e501e0e0abe2c6edb0ec3f800ed7c669e6a" translate="yes" xml:space="preserve">
          <source>Helpers related to formatting text.</source>
          <target state="translated">与格式化文本相关的助手。</target>
        </trans-unit>
        <trans-unit id="0d4c3aa7d2de3e04c2fa70e9a23a0cc750641d4a" translate="yes" xml:space="preserve">
          <source>Helpers related to producing HTML forms.</source>
          <target state="translated">与制作HTML表格相关的助手。</target>
        </trans-unit>
        <trans-unit id="8d3f6ca83c967080b0bd89bc34ea0c0450fad6f1" translate="yes" xml:space="preserve">
          <source>Helpers related to producing HTML tags within templates.</source>
          <target state="translated">在模板中生成HTML标签的相关帮助。</target>
        </trans-unit>
        <trans-unit id="1ae61dee0e45488052c0b40f12b8925406d54456" translate="yes" xml:space="preserve">
          <source>Here is a quick introduction into Phoenix templates terms:</source>
          <target state="translated">下面就来介绍一下凤凰模板的术语。</target>
        </trans-unit>
        <trans-unit id="c1764c5d537b9f3a319ae1d976d0b1ca9635f544" translate="yes" xml:space="preserve">
          <source>Here is a simple echo socket implementation:</source>
          <target state="translated">这里是一个简单的echo socket实现。</target>
        </trans-unit>
        <trans-unit id="9a0608a11c75facb6614fa80af338062303f83e9" translate="yes" xml:space="preserve">
          <source>Here is an example of &lt;a href=&quot;plug.parsers&quot;&gt;&lt;code&gt;Plug.Parsers&lt;/code&gt;&lt;/a&gt; can be used in a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Plug.Router&lt;/code&gt;&lt;/a&gt; router to parse the JSON-encoded body of a POST request:</source>
          <target state="translated">这是一个&lt;a href=&quot;plug.parsers&quot;&gt; &lt;code&gt;Plug.Parsers&lt;/code&gt; &lt;/a&gt;示例，可以在&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Plug.Router&lt;/code&gt; &lt;/a&gt;路由器中使用它来解析POST请求的JSON编码主体：</target>
        </trans-unit>
        <trans-unit id="9cdd2430bc9221c06b037fdb8209b829394de4f3" translate="yes" xml:space="preserve">
          <source>Here is an example of &lt;a href=&quot;plug.parsers&quot;&gt;&lt;code&gt;Plug.Parsers&lt;/code&gt;&lt;/a&gt; can be used in a &lt;a href=&quot;plug.router#content&quot;&gt;&lt;code&gt;Plug.Router&lt;/code&gt;&lt;/a&gt; router to parse the JSON-encoded body of a POST request:</source>
          <target state="translated">这是一个&lt;a href=&quot;plug.parsers&quot;&gt; &lt;code&gt;Plug.Parsers&lt;/code&gt; &lt;/a&gt;示例，可以在&lt;a href=&quot;plug.router#content&quot;&gt; &lt;code&gt;Plug.Router&lt;/code&gt; &lt;/a&gt;路由器中使用它来解析POST请求的JSON编码主体：</target>
        </trans-unit>
        <trans-unit id="4bb01d7dff1af36b16e25ff091cce99986ce848e" translate="yes" xml:space="preserve">
          <source>Here is an example of a Telemetry event executed by Ecto when an Ecto repository starts:</source>
          <target state="translated">下面是Ecto在Ecto仓库启动时执行Telemetry事件的一个例子。</target>
        </trans-unit>
        <trans-unit id="f1d2656a4085eae8f685d5ef408efb43bf4ea75b" translate="yes" xml:space="preserve">
          <source>Here is an example of a simple GenServer that emits telemetry events. Create this file in your app at &lt;code&gt;lib/my_app/my_server.ex&lt;/code&gt;:</source>
          <target state="translated">这是一个发出遥测事件的简单GenServer的示例。在您的应用程序 &lt;code&gt;lib/my_app/my_server.ex&lt;/code&gt; 中创建此文件：</target>
        </trans-unit>
        <trans-unit id="7f637f171cd30b36c18ce6cc1ef0b78a381b7d5b" translate="yes" xml:space="preserve">
          <source>Here is an example of an event from your endpoint:</source>
          <target state="translated">下面是一个来自你的端点的事件的例子。</target>
        </trans-unit>
        <trans-unit id="cf8a0f224b439f3a7c58360fbb55ef423905c7d4" translate="yes" xml:space="preserve">
          <source>Here is an example of how both modules could be used in an application:</source>
          <target state="translated">下面是一个如何在应用程序中使用这两个模块的例子。</target>
        </trans-unit>
        <trans-unit id="514a051b8ea91a8358dacf4b2fa3b9efa3ab46e1" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of a function plug:</source>
          <target state="translated">这是一个功能插件的示例：</target>
        </trans-unit>
        <trans-unit id="afa6cca227f184cb839f4bb2a488e237e45cbd46" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of a module plug:</source>
          <target state="translated">这是模块插件的示例：</target>
        </trans-unit>
        <trans-unit id="294bc9dc3de330e00af0c679783e2c3ab4b482ed" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of receiving an incoming &lt;code&gt;&quot;new_msg&quot;&lt;/code&gt; event from one client, and broadcasting the message to all topic subscribers for this socket.</source>
          <target state="translated">这是一个示例，该示例从一个客户端接收传入的 &lt;code&gt;&quot;new_msg&quot;&lt;/code&gt; 事件，并将消息广播到此套接字的所有主题订户。</target>
        </trans-unit>
        <trans-unit id="2010f6be3cd1e0728d571d7959a93b42f107f411" translate="yes" xml:space="preserve">
          <source>Here's an example of receiving an incoming &lt;code&gt;&quot;new_msg&quot;&lt;/code&gt; event from one client, and broadcasting the message to all topic subscribers for this socket.</source>
          <target state="translated">这是一个示例，该示例从一个客户端接收传入的 &lt;code&gt;&quot;new_msg&quot;&lt;/code&gt; 事件，并将消息广播到此套接字的所有主题订户。</target>
        </trans-unit>
        <trans-unit id="fc198632123680a802368b24b34a90c40b9cc3b8" translate="yes" xml:space="preserve">
          <source>Here's another example with two scopes that have different pipelines:</source>
          <target state="translated">这里还有一个例子,两个范围有不同的管道。</target>
        </trans-unit>
        <trans-unit id="293f9c83de18b696d985a3e2757964adfcf31355" translate="yes" xml:space="preserve">
          <source>Here's another look at the router from a newly generated Phoenix application, this time with the api scope uncommented back in and a route added.</source>
          <target state="translated">下面是新生成的Phoenix应用中的路由器的另一个样子,这次是将api scope未加注释的回车,并添加了一条路由。</target>
        </trans-unit>
        <trans-unit id="a396acbc7494836afa8330130078d54d9f2ca540" translate="yes" xml:space="preserve">
          <source>Here's the &lt;code&gt;User&lt;/code&gt; schema that Phoenix generated for us.</source>
          <target state="translated">这是Phoenix为我们生成的 &lt;code&gt;User&lt;/code&gt; 架构。</target>
        </trans-unit>
        <trans-unit id="3e18ca3472a7c2b730d0f1353c2a5e4284080d21" translate="yes" xml:space="preserve">
          <source>Here's the command to install Hex (If you have Hex already installed, it will upgrade Hex to the latest version):</source>
          <target state="translated">下面是安装Hex的命令(如果你已经安装了Hex,它会将Hex升级到最新版本)。</target>
        </trans-unit>
        <trans-unit id="292aca9f06e84483c4664a721bd0d8e611812da1" translate="yes" xml:space="preserve">
          <source>Here's what &lt;a href=&quot;mix.tasks.phx.routes&quot;&gt;&lt;code&gt;mix phx.routes&lt;/code&gt;&lt;/a&gt; tells us:</source>
          <target state="translated">这是&lt;a href=&quot;mix.tasks.phx.routes&quot;&gt; &lt;code&gt;mix phx.routes&lt;/code&gt; &lt;/a&gt;告诉我们的内容：</target>
        </trans-unit>
        <trans-unit id="433ad4cccaa6f7157e6164318c9efb4b55c0cd17" translate="yes" xml:space="preserve">
          <source>Here's what it looks like in action.</source>
          <target state="translated">下面是它的实际情况。</target>
        </trans-unit>
        <trans-unit id="f0b2af54aadfd78a646e888ac25a3cea0e36a97c" translate="yes" xml:space="preserve">
          <source>Here's what the &lt;code&gt;schema_migrations&lt;/code&gt; table looks like.</source>
          <target state="translated">这是 &lt;code&gt;schema_migrations&lt;/code&gt; 表的外观。</target>
        </trans-unit>
        <trans-unit id="172de218d867931358663fe72b49811c80d28ce7" translate="yes" xml:space="preserve">
          <source>Here, a request to &lt;code&gt;/foo/BAZ/qux&lt;/code&gt; will be forwarded to the &lt;code&gt;FooPlug&lt;/code&gt; plug, which will receive what it will see as a request to &lt;code&gt;/&lt;/code&gt;, and &lt;code&gt;conn.params[&quot;bar&quot;]&lt;/code&gt; will be set to &lt;code&gt;&quot;BAZ&quot;&lt;/code&gt;.</source>
          <target state="translated">在这里，对 &lt;code&gt;/foo/BAZ/qux&lt;/code&gt; 的请求将转发到 &lt;code&gt;FooPlug&lt;/code&gt; 插件，该插件将接收对 &lt;code&gt;/&lt;/code&gt; 的请求，并且 &lt;code&gt;conn.params[&quot;bar&quot;]&lt;/code&gt; 将设置为 &lt;code&gt;&quot;BAZ&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="47a188e1572f453ec9eb4d25af8bec31919581b6" translate="yes" xml:space="preserve">
          <source>Here, we have our &lt;code&gt;show/2&lt;/code&gt; and &lt;code&gt;index/2&lt;/code&gt; actions returning static page data. Instead of passing in &lt;code&gt;&quot;show.html&quot;&lt;/code&gt; to &lt;code&gt;render/3&lt;/code&gt; as the template name, we pass &lt;code&gt;&quot;show.json&quot;&lt;/code&gt;. This way, we can have views that are responsible for rendering HTML as well as JSON by pattern matching on different file types.</source>
          <target state="translated">在这里，我们有 &lt;code&gt;show/2&lt;/code&gt; 和 &lt;code&gt;index/2&lt;/code&gt; 操作返回静态页面数据。而不是将 &lt;code&gt;&quot;show.html&quot;&lt;/code&gt; 传递给 &lt;code&gt;render/3&lt;/code&gt; 作为模板名称，我们传递 &lt;code&gt;&quot;show.json&quot;&lt;/code&gt; 。这样，我们就可以通过不同文件类型上的模式匹配来拥有负责呈现HTML和JSON的视图。</target>
        </trans-unit>
        <trans-unit id="04c8c2a15da73762b448647b48304e5984318bb6" translate="yes" xml:space="preserve">
          <source>Here, we start by using the familiar &lt;a href=&quot;../phoenix/phoenix.conntest&quot;&gt;&lt;code&gt;Phoenix.ConnTest&lt;/code&gt;&lt;/a&gt; function, &lt;code&gt;get/2&lt;/code&gt; to test the regular HTTP GET request which invokes mount with a disconnected socket. Next, &lt;a href=&quot;#live/1&quot;&gt;&lt;code&gt;live/1&lt;/code&gt;&lt;/a&gt; is called with our sent connection to mount the view in a connected state, which starts our stateful LiveView process.</source>
          <target state="translated">在这里，我们首先使用熟悉的&lt;a href=&quot;../phoenix/phoenix.conntest&quot;&gt; &lt;code&gt;Phoenix.ConnTest&lt;/code&gt; &lt;/a&gt;函数 &lt;code&gt;get/2&lt;/code&gt; 来测试常规HTTP GET请求，该请求通过断开的套接字调用mount。接下来，使用我们的已发送连接调用&lt;a href=&quot;#live/1&quot;&gt; &lt;code&gt;live/1&lt;/code&gt; &lt;/a&gt;，以将视图装入连接状态，这将启动我们的有状态LiveView进程。</target>
        </trans-unit>
        <trans-unit id="e78f354796364ef7c67c1020994e22a118885793" translate="yes" xml:space="preserve">
          <source>Hibernation</source>
          <target state="translated">Hibernation</target>
        </trans-unit>
        <trans-unit id="5b3268c27e7d59601c440ed37c24688618bcf6ca" translate="yes" xml:space="preserve">
          <source>Hidden fields</source>
          <target state="translated">隐藏领域</target>
        </trans-unit>
        <trans-unit id="5d18d2a7d4a536a77cc5f61568a124ea48c4b54e" translate="yes" xml:space="preserve">
          <source>Higher level usage of Basic HTTP auth.</source>
          <target state="translated">基本HTTP auth的高级用法。</target>
        </trans-unit>
        <trans-unit id="eef8e89aeb708a408921fec1b9e87c4d04faaced" translate="yes" xml:space="preserve">
          <source>Hints</source>
          <target state="translated">Hints</target>
        </trans-unit>
        <trans-unit id="82b440b8be7666b0f091da72ba57b990af92adad" translate="yes" xml:space="preserve">
          <source>Hitting &lt;code&gt;/hello/Frank&lt;/code&gt; now renders the HTML string we defined in the &lt;code&gt;show&lt;/code&gt; action. Note that what we wrote in the action is not an &lt;code&gt;eex&lt;/code&gt; template. It's a multi-line string, so we interpolate the &lt;code&gt;messenger&lt;/code&gt; variable like this &lt;code&gt;#{Plug.HTML.html_escape(messenger)}&lt;/code&gt;, instead of this &lt;code&gt;&amp;lt;%= messenger %&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">现在，点击 &lt;code&gt;/hello/Frank&lt;/code&gt; 会呈现我们在 &lt;code&gt;show&lt;/code&gt; 操作中定义的HTML字符串。请注意，我们在操作中编写的不是 &lt;code&gt;eex&lt;/code&gt; 模板。它是多行字符串，因此我们像这样 &lt;code&gt;#{Plug.HTML.html_escape(messenger)}&lt;/code&gt; 插值 &lt;code&gt;messenger&lt;/code&gt; 变量，而不是 &lt;code&gt;&amp;lt;%= messenger %&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="18c930f4814c253272b3742e31b9b46cf3f29406" translate="yes" xml:space="preserve">
          <source>Hopefully, this gives you some inspiration on how to use the &lt;code&gt;:tag_values&lt;/code&gt; option. Just remember to keep this function fast since it is called on every event.</source>
          <target state="translated">希望这对您如何使用 &lt;code&gt;:tag_values&lt;/code&gt; 选项有所启发。只需记住要保持此函数的速度快，因为在每个事件上都会调用它。</target>
        </trans-unit>
        <trans-unit id="7da670a6c868ee6474dd213010439fdc6c17c884" translate="yes" xml:space="preserve">
          <source>How to read this guide: Using the context generators is a great way for beginners and intermediate Elixir programmers alike to get up and running quickly while thoughtfully designing their applications. This guide focuses on those readers. On the other hand, experienced developers may get more mileage from nuanced discussions around application design. For those readers, we include a frequently asked questions (FAQ) section at the end of the guide which brings different perspectives to some design decisions made throughout the guide. Beginners can safely skip the FAQ sections and return later when they're ready to dig deeper.</source>
          <target state="translated">如何阅读本指南。对于初学者和中级Elixir程序员来说,使用上下文生成器是一种很好的方式,可以让他们在深思熟虑地设计应用程序的同时,快速上手并运行。本指南主要针对这些读者。另一方面,有经验的开发人员可能会从围绕应用程序设计的细微讨论中获得更多的好处。对于这些读者,我们在指南的最后加入了常见问题(FAQ)部分,它为整个指南中的一些设计决策带来了不同的观点。初学者可以安全地跳过FAQ部分,当他们准备好深入研究时再回来。</target>
        </trans-unit>
        <trans-unit id="c9bd403a4e9a302e8f2ed9f94925a54db8a68b9f" translate="yes" xml:space="preserve">
          <source>How your migration should be structured depends on the value you pass in &lt;code&gt;:join_through&lt;/code&gt;. If &lt;code&gt;:join_through&lt;/code&gt; is simply a string, representing a table, you may define a table without primary keys and you must not include any further columns, as those values won&amp;rsquo;t be set by Ecto:</source>
          <target state="translated">迁移的结构如何取决于您在 &lt;code&gt;:join_through&lt;/code&gt; 中传递的值。如果 &lt;code&gt;:join_through&lt;/code&gt; 仅是表示表的字符串，则可以定义没有主键的表，并且不能再包含任何其他列，因为Ecto不会设置这些值：</target>
        </trans-unit>
        <trans-unit id="e772dd16864f540c21adae4eff7d05aac5466700" translate="yes" xml:space="preserve">
          <source>How your migration should be structured depends on the value you pass in &lt;code&gt;:join_through&lt;/code&gt;. If &lt;code&gt;:join_through&lt;/code&gt; is simply a string, representing a table, you may define a table without primary keys and you must not include any further columns, as those values won't be set by Ecto:</source>
          <target state="translated">迁移的结构方式取决于您在 &lt;code&gt;:join_through&lt;/code&gt; 中传递的值。如果 &lt;code&gt;:join_through&lt;/code&gt; 仅是表示表的字符串，则可以定义不带主键的表，并且不能再包含任何其他列，因为Ecto不会设置这些值：</target>
        </trans-unit>
        <trans-unit id="758c04f8f966638d8323796933d71c2022e6d322" translate="yes" xml:space="preserve">
          <source>How-to's - a collection of articles on how to achieve certain things with Phoenix</source>
          <target state="translated">How-to's-关于如何使用Phoenix实现某些事情的文章集。</target>
        </trans-unit>
        <trans-unit id="fde9c228238451fde38808e6b71a5f4e8db27470" translate="yes" xml:space="preserve">
          <source>However, &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Plug.Static&lt;/code&gt;&lt;/a&gt; also supports direct cache control by using versioned query strings. If the request query string starts with &quot;?vsn=&quot;, &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Plug.Static&lt;/code&gt;&lt;/a&gt; assumes the application is versioning assets and does not set the &lt;code&gt;ETag&lt;/code&gt; header, meaning the cache behaviour will be specified solely by the &lt;code&gt;cache_control_for_vsn_requests&lt;/code&gt; config, which defaults to &lt;code&gt;&quot;public, max-age=31536000&quot;&lt;/code&gt;.</source>
          <target state="translated">但是，&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Plug.Static&lt;/code&gt; &lt;/a&gt;还通过使用版本化的查询字符串来支持直接缓存控制。如果请求查询字符串以&amp;ldquo;？vsn =&amp;ldquo;&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Plug.Static&lt;/code&gt; &lt;/a&gt;，则Plug.Static假定应用程序正在版本控制资产，并且未设置 &lt;code&gt;ETag&lt;/code&gt; 标头，这意味着缓存行为将仅由 &lt;code&gt;cache_control_for_vsn_requests&lt;/code&gt; 配置指定，默认配置为 &lt;code&gt;&quot;public, max-age=31536000&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7ca34d2ca00362f79bd18266ad0ec21713be1edf" translate="yes" xml:space="preserve">
          <source>However, &lt;a href=&quot;plug.static#content&quot;&gt;&lt;code&gt;Plug.Static&lt;/code&gt;&lt;/a&gt; also supports direct cache control by using versioned query strings. If the request query string starts with &amp;ldquo;?vsn=&amp;rdquo;, &lt;a href=&quot;plug.static#content&quot;&gt;&lt;code&gt;Plug.Static&lt;/code&gt;&lt;/a&gt; assumes the application is versioning assets and does not set the &lt;code&gt;ETag&lt;/code&gt; header, meaning the cache behaviour will be specified solely by the &lt;code&gt;cache_control_for_vsn_requests&lt;/code&gt; config, which defaults to &lt;code&gt;&quot;public, max-age=31536000&quot;&lt;/code&gt;.</source>
          <target state="translated">但是，&lt;a href=&quot;plug.static#content&quot;&gt; &lt;code&gt;Plug.Static&lt;/code&gt; &lt;/a&gt;还通过使用版本化查询字符串来支持直接缓存控制。如果请求查询字符串以&amp;ldquo;？vsn =&amp;rdquo; &lt;a href=&quot;plug.static#content&quot;&gt; &lt;code&gt;Plug.Static&lt;/code&gt; &lt;/a&gt;，则Plug.Static会假定该应用程序正在版本控制资产，并且未设置 &lt;code&gt;ETag&lt;/code&gt; 标头，这意味着缓存行为将仅由 &lt;code&gt;cache_control_for_vsn_requests&lt;/code&gt; 配置指定，默认配置为 &lt;code&gt;&quot;public, max-age=31536000&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d3c783df751e11e9f0f2d6bc647f8e24682a2b66" translate="yes" xml:space="preserve">
          <source>However, any component can be made stateful by passing an &lt;code&gt;:id&lt;/code&gt; assign.</source>
          <target state="translated">但是，可以通过传递 &lt;code&gt;:id&lt;/code&gt; 赋值使任何组件变为有状态。</target>
        </trans-unit>
        <trans-unit id="92b6ba6983e86cfb8b7f8a1c8aa387837993e78b" translate="yes" xml:space="preserve">
          <source>However, because constraints are only checked if all validations succeed, this function can be used as an early check to provide early feedback to users, since most conflicting data will have been inserted prior to the current validation phase.</source>
          <target state="translated">然而,由于只有在所有验证成功的情况下才会对约束条件进行检查,因此该函数可以作为早期检查,以向用户提供早期反馈,因为大多数冲突数据将在当前验证阶段之前被插入。</target>
        </trans-unit>
        <trans-unit id="c576a7810279fa0ef0181e729be5d3e33896301c" translate="yes" xml:space="preserve">
          <source>However, because the rendering of live templates can be dynamic in itself, it is important to distinguish which &lt;code&gt;.leex&lt;/code&gt; template was rendered. For example, imagine this code:</source>
          <target state="translated">但是，由于实时模板的呈现本身可以是动态的，因此区分呈现哪个 &lt;code&gt;.leex&lt;/code&gt; 模板很重要。例如，假设以下代码：</target>
        </trans-unit>
        <trans-unit id="e8b56ea8eef111a454a3af358d1c8df493c3834e" translate="yes" xml:space="preserve">
          <source>However, changesets can also be used with &quot;regular&quot; structs too by passing a tuple with the data and its types:</source>
          <target state="translated">然而,变化集也可以通过传递一个包含数据及其类型的元组来用于 &quot;常规 &quot;结构。</target>
        </trans-unit>
        <trans-unit id="92d4b9ddb4851e5cb9caec7c806e9ed043982b19" translate="yes" xml:space="preserve">
          <source>However, changesets can also be used with &amp;ldquo;regular&amp;rdquo; structs too by passing a tuple with the data and its types:</source>
          <target state="translated">但是，变更集也可以通过向元组传递数据及其类型来与&amp;ldquo;常规&amp;rdquo;结构一起使用：</target>
        </trans-unit>
        <trans-unit id="9c75a911a92357bb55a72a4f5cda6890aa2fa06e" translate="yes" xml:space="preserve">
          <source>However, developers can use the preload functionality in queries to automatically pre-populate the field:</source>
          <target state="translated">但是,开发人员可以在查询中使用预加载功能来自动预填充字段。</target>
        </trans-unit>
        <trans-unit id="e072c9f502e82c76107b9c680016ea26f2459bff" translate="yes" xml:space="preserve">
          <source>However, for convenience, this protocol can also be derivable. For example:</source>
          <target state="translated">但是,为了方便起见,这个协议也是可以派生的。例如:</target>
        </trans-unit>
        <trans-unit id="d2e281662c4868a83f42fe2d3a37e4b42a7ba94d" translate="yes" xml:space="preserve">
          <source>However, if the client had sent an expired or otherwise invalid token &lt;a href=&quot;#verify/4&quot;&gt;&lt;code&gt;verify/4&lt;/code&gt;&lt;/a&gt; would have returned an error instead:</source>
          <target state="translated">但是，如果客户端发送了过期的令牌或无效的令牌，那么&lt;a href=&quot;#verify/4&quot;&gt; &lt;code&gt;verify/4&lt;/code&gt; &lt;/a&gt;将返回错误：</target>
        </trans-unit>
        <trans-unit id="efbb0f8348e6d519f60b96367c6b25b0ab58981a" translate="yes" xml:space="preserve">
          <source>However, if you are just getting started with Phoenix, we recommend you to install PostgreSQL and make sure it is running. The PostgreSQL wiki has &lt;a href=&quot;https://wiki.postgresql.org/wiki/Detailed_installation_guides&quot;&gt;installation guides&lt;/a&gt; for a number of different systems.</source>
          <target state="translated">但是，如果刚开始使用Phoenix，我们建议您安装PostgreSQL并确保它正在运行。PostgreSQL Wiki提供了许多不同系统的&lt;a href=&quot;https://wiki.postgresql.org/wiki/Detailed_installation_guides&quot;&gt;安装指南&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="06e4154438c600a0964d2ae325cad0bcb77711e5" translate="yes" xml:space="preserve">
          <source>However, if you attempt to persist the struct above, an error will be raised since Ecto validates the types when sending them to the adapter/database.</source>
          <target state="translated">但是,如果你试图持久化上面的结构,就会出现一个错误,因为Ecto在向适配器/数据库发送类型时,会对它们进行验证。</target>
        </trans-unit>
        <trans-unit id="6beb14dbb92a9c5566dff520724cf6035e375bf3" translate="yes" xml:space="preserve">
          <source>However, if you want all generated URLs to always have a certain schema, host, etc, you may use &lt;a href=&quot;#put_router_url/2&quot;&gt;&lt;code&gt;put_router_url/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">但是，如果希望所有生成的URL始终具有特定的架构，主机等，则可以使用&lt;a href=&quot;#put_router_url/2&quot;&gt; &lt;code&gt;put_router_url/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e5f38c3f3c2dea225784564c84cad08b3961c4cb" translate="yes" xml:space="preserve">
          <source>However, if you're adding &lt;code&gt;phoenix_live_view&lt;/code&gt; to an umbrella project, the dependency paths should be modified appropriately:</source>
          <target state="translated">但是，如果要将 &lt;code&gt;phoenix_live_view&lt;/code&gt; 添加到一个伞项目中，则应适当修改依赖项路径：</target>
        </trans-unit>
        <trans-unit id="92a0deea3d522aed6c2af612ee37d11179610223" translate="yes" xml:space="preserve">
          <source>However, if your &lt;code&gt;:join_through&lt;/code&gt; is a schema, like &lt;code&gt;MyApp.PostTag&lt;/code&gt;, your join table may be structured as any other table in your codebase, including timestamps:</source>
          <target state="translated">但是，如果 &lt;code&gt;:join_through&lt;/code&gt; 是MyApp.PostTag之类的架构，则 &lt;code&gt;MyApp.PostTag&lt;/code&gt; 表的结构可以与代码库中的任何其他表一样，包括时间戳：</target>
        </trans-unit>
        <trans-unit id="61c4ba54704b1e88b02567334a74ea38f7fe843d" translate="yes" xml:space="preserve">
          <source>However, implementing the &lt;a href=&quot;../plug/plug.exception&quot;&gt;&lt;code&gt;Plug.Exception&lt;/code&gt;&lt;/a&gt; protocol by hand can be convenient in certain occasions, such as when providing Actionable ERrors.</source>
          <target state="translated">但是，在某些情况下，例如提供Actioner ERror时，手动实现&lt;a href=&quot;../plug/plug.exception&quot;&gt; &lt;code&gt;Plug.Exception&lt;/code&gt; &lt;/a&gt;协议可能会很方便。</target>
        </trans-unit>
        <trans-unit id="5054280086d854890f69bc24ac26fee32ed61037" translate="yes" xml:space="preserve">
          <source>However, keep in mind that if a join is removed and its bindings were referenced elsewhere, the bindings won&amp;rsquo;t be removed, leading to a query that won&amp;rsquo;t compile.</source>
          <target state="translated">但是，请记住，如果删除了一个连接并且在其他地方引用了它的绑定，则绑定不会被删除，从而导致查询无法编译。</target>
        </trans-unit>
        <trans-unit id="96c145dbff75201402ee148458f35b3b4df8ec98" translate="yes" xml:space="preserve">
          <source>However, keep in mind that if a join is removed and its bindings were referenced elsewhere, the bindings won't be removed, leading to a query that won't compile.</source>
          <target state="translated">然而,请记住,如果一个连接被删除,而它的绑定被引用到其他地方,绑定就不会被删除,导致查询无法编译。</target>
        </trans-unit>
        <trans-unit id="418e05e8a16e7c15648cf7bdddb205991c4f4a14" translate="yes" xml:space="preserve">
          <source>However, most commonly, structs are cast, validated and manipulated with the &lt;a href=&quot;ecto.changeset&quot;&gt;&lt;code&gt;Ecto.Changeset&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">但是，最常见的是，使用&lt;a href=&quot;ecto.changeset&quot;&gt; &lt;code&gt;Ecto.Changeset&lt;/code&gt; &lt;/a&gt;模块对结构进行强制转换，验证和操作。</target>
        </trans-unit>
        <trans-unit id="b4a5fc9cf571b09944b8a527ce63cf79c0416fc0" translate="yes" xml:space="preserve">
          <source>However, note that components do not have a &lt;code&gt;handle_info/2&lt;/code&gt; callback. Therefore, if you want to track distributed changes on a card, you must have the parent LiveView receive those events and redirect them to the appropriate card. For example, assuming card updates are sent to the &quot;board:ID&quot; topic, and that the board LiveView is subscribed to said topic, one could do:</source>
          <target state="translated">但是，请注意，组件没有 &lt;code&gt;handle_info/2&lt;/code&gt; 回调。因此，如果要跟踪卡上的分布式更改，则必须让父LiveView接收这些事件并将它们重定向到适当的卡上。例如，假设卡片更新发送到&amp;ldquo; board：ID&amp;rdquo;主题，并且LiveView订阅了该主题，则可以执行以下操作：</target>
        </trans-unit>
        <trans-unit id="c15cb8377f6937f642e813f984385d51f7b4176e" translate="yes" xml:space="preserve">
          <source>However, note that defining a window is not necessary, as the window definition can be given as the second argument to &lt;code&gt;over&lt;/code&gt;:</source>
          <target state="translated">但是，请注意，不必定义窗口，因为可以将窗口定义作为 &lt;code&gt;over&lt;/code&gt; 的第二个参数给出：</target>
        </trans-unit>
        <trans-unit id="089510bf5810bca9d96388384533d0538018252e" translate="yes" xml:space="preserve">
          <source>However, once the repository is started, you can't directly interact with it, since all operations in &lt;code&gt;MyApp.Repo&lt;/code&gt; are sent by default to the repository named &lt;code&gt;MyApp.Repo&lt;/code&gt;. You can change the default repo at compile time with:</source>
          <target state="translated">但是，一旦启动存储库，您将无法直接与其进行交互，因为默认情况下， &lt;code&gt;MyApp.Repo&lt;/code&gt; 中的所有操作都会发送到名为 &lt;code&gt;MyApp.Repo&lt;/code&gt; 的存储库中。您可以在编译时使用以下命令更改默认存储库：</target>
        </trans-unit>
        <trans-unit id="9fcb1b6a8bd9d33f8942cfd45c40fa04ca503d0c" translate="yes" xml:space="preserve">
          <source>However, one may argue that, if the last member of an organization cannot leave it, it may be better to not even show the &quot;Leave&quot; button in the UI when the organization has only one member.</source>
          <target state="translated">然而,有人可能会说,如果一个组织的最后一个成员不能离开该组织,那么当该组织只有一个成员时,甚至不在UI中显示 &quot;离开 &quot;按钮可能会更好。</target>
        </trans-unit>
        <trans-unit id="c85984fa1288966d45078f191d19bcd6b0fa6962" translate="yes" xml:space="preserve">
          <source>However, parameterized types are also more complex. Therefore, if everything you need to achieve can be done with basic types, they should be preferred to parameterized ones.</source>
          <target state="translated">但是,参数化类型也比较复杂。因此,如果你需要实现的一切都可以用基本类型来完成,那么应该优先选择基本类型而不是参数化类型。</target>
        </trans-unit>
        <trans-unit id="80b14f53aaf9b70f512fe7b2db28dcdb79978b4a" translate="yes" xml:space="preserve">
          <source>However, the issue with said approach is that, if you are rendering multiple user components in the same page, you have a N+1 query problem. The &lt;a href=&quot;#c:preload/1&quot;&gt;&lt;code&gt;preload/1&lt;/code&gt;&lt;/a&gt; callback helps address this problem as it is invoked with a list of assigns for all components of the same type. For example, instead of implementing &lt;a href=&quot;#c:update/2&quot;&gt;&lt;code&gt;update/2&lt;/code&gt;&lt;/a&gt; as above, one could implement:</source>
          <target state="translated">但是，上述方法的问题在于，如果要在同一页面中呈现多个用户组件，则会遇到N + 1查询问题。该&lt;a href=&quot;#c:preload/1&quot;&gt; &lt;code&gt;preload/1&lt;/code&gt; &lt;/a&gt;回调帮助，因为它是与相同类型的所有组件受让人名单调用解决这个问题。例如，除了实现上述的&lt;a href=&quot;#c:update/2&quot;&gt; &lt;code&gt;update/2&lt;/code&gt; &lt;/a&gt;之外，还可以实现：</target>
        </trans-unit>
        <trans-unit id="94de3aba560958a631f7ce9430b591344ccd7fee" translate="yes" xml:space="preserve">
          <source>However, we don't advise forwarding to another endpoint. The reason is that plugs defined by your app and the forwarded endpoint would be invoked twice, which may lead to errors.</source>
          <target state="translated">但是,我们不建议转发到另一个端点。原因是您的应用程序和转发的端点所定义的插件将被调用两次,这可能会导致错误。</target>
        </trans-unit>
        <trans-unit id="7cabde0cd7b6db0d68f058c5459d05317cac58e4" translate="yes" xml:space="preserve">
          <source>However, what will happen with a LiveView in case of exceptions? Let's talk about unexpected scenarios.</source>
          <target state="translated">然而,万一出现异常情况,LiveView会怎么样呢?我们来谈谈意外情况。</target>
        </trans-unit>
        <trans-unit id="5fc8ebeaefd55fb22bf6d7071b4fcd39b701a518" translate="yes" xml:space="preserve">
          <source>However, when rendering components on the client, the client needs to choose the mime type of the component contents, which defaults to HTML. This is the best default but in some cases it may lead to unexpected results.</source>
          <target state="translated">但是,在客户端渲染组件时,客户端需要选择组件内容的mime类型,默认为HTML。这是最好的默认值,但在某些情况下可能会导致意外的结果。</target>
        </trans-unit>
        <trans-unit id="9669e5305e15cb7f2d41b7ba261dd4a25e92989e" translate="yes" xml:space="preserve">
          <source>However, when rendering these metrics in LiveDashboard, the value label is output as &lt;code&gt;&quot;Elixir.Phoenix.LiveDashboard.MetricsLive true&quot;&lt;/code&gt;.</source>
          <target state="translated">但是，在LiveDashboard中呈现这些指标时，值标签将输出为 &lt;code&gt;&quot;Elixir.Phoenix.LiveDashboard.MetricsLive true&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="404d7e0f0a82ca0536563d8523263ae188890052" translate="yes" xml:space="preserve">
          <source>Identifies the Phoenix.Socket for a LiveView client.</source>
          <target state="translated">识别LiveView客户端的Phoenix.Socket。</target>
        </trans-unit>
        <trans-unit id="69818f21f7d2e8e3d4c95d045561623815bfdb97" translate="yes" xml:space="preserve">
          <source>Identifies the socket connection</source>
          <target state="translated">识别插座连接</target>
        </trans-unit>
        <trans-unit id="a1248f63e6d463c737ae4f281ae99a7acd6c280d" translate="yes" xml:space="preserve">
          <source>Identifies the socket connection.</source>
          <target state="translated">识别插座连接。</target>
        </trans-unit>
        <trans-unit id="c2b9e9831550c1277fc0f8c66e430ed4b934322f" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#c:transaction/2&quot;&gt;&lt;code&gt;transaction/2&lt;/code&gt;&lt;/a&gt; is called inside another transaction, the function is simply executed, without wrapping the new transaction call in any way. If there is an error in the inner transaction and the error is rescued, or the inner transaction is rolled back, the whole outer transaction is marked as tainted, guaranteeing nothing will be committed.</source>
          <target state="translated">如果&lt;a href=&quot;#c:transaction/2&quot;&gt; &lt;code&gt;transaction/2&lt;/code&gt; &lt;/a&gt;在另一个事务中被调用，则该函数将被简单执行，而不会以任何方式包装新的事务调用。如果内部事务中存在错误并且可以挽救该错误，或​​者内部事务被回滚，则整个外部事务都将标记为已污染，从而确保不进行任何处理。</target>
        </trans-unit>
        <trans-unit id="48bb3facdf6a618d730a68a131d48750e21adc3a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;:init_opts&lt;/code&gt; is undefined, then all remaining options are passed to the target plug.</source>
          <target state="translated">如果 &lt;code&gt;:init_opts&lt;/code&gt; 未定义，则所有其余选项都将传递到目标插件。</target>
        </trans-unit>
        <trans-unit id="d7b518d769ddb0e8a385ef70577decbd4185956c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;:select_merge&lt;/code&gt; is called and there is no value selected previously, it will default to the source, &lt;code&gt;p&lt;/code&gt; in the example above.</source>
          <target state="translated">如果调用 &lt;code&gt;:select_merge&lt;/code&gt; ，并且以前没有选择任何值，它将默认为源，即上例中的 &lt;code&gt;p&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="39bb4cb75be5b52a2198bb0576f54f0e0ede32c4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;charset&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt;, the value of the &lt;code&gt;&quot;content-type&quot;&lt;/code&gt; response header won&amp;rsquo;t specify a charset.</source>
          <target state="translated">如果 &lt;code&gt;charset&lt;/code&gt; 为 &lt;code&gt;nil&lt;/code&gt; ，则 &lt;code&gt;&quot;content-type&quot;&lt;/code&gt; 响应标头的值将不指定字符集。</target>
        </trans-unit>
        <trans-unit id="0675b7cae7347e027b29d7d61cb63f9f1413731c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;charset&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt;, the value of the &lt;code&gt;&quot;content-type&quot;&lt;/code&gt; response header won't specify a charset.</source>
          <target state="translated">如果 &lt;code&gt;charset&lt;/code&gt; 为 &lt;code&gt;nil&lt;/code&gt; ，则 &lt;code&gt;&quot;content-type&quot;&lt;/code&gt; 响应标头的值将不指定字符集。</target>
        </trans-unit>
        <trans-unit id="c771220878c1cca3211d6dc54b16db5f2b01acdb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;leave&lt;/code&gt; fails and returns &lt;code&gt;false&lt;/code&gt;, an exception is raised. It is common for Elixir developers to use exceptions for unexpected scenarios in their Phoenix applications.</source>
          <target state="translated">如果 &lt;code&gt;leave&lt;/code&gt; 失败并返回 &lt;code&gt;false&lt;/code&gt; ，则会引发异常。对于Elixir开发人员，通常在其Phoenix应用程序中对意外情况使用例外。</target>
        </trans-unit>
        <trans-unit id="5b63bc1203c3dac71786c2dfe06d19a828803701" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;leave&lt;/code&gt; returns false by any chance, it will just raise. Or you can even provide a &lt;code&gt;leave!&lt;/code&gt; function that raises a specific exception:</source>
          <target state="translated">如果 &lt;code&gt;leave&lt;/code&gt; 偶然返回假，它将增加。或者，您甚至可以 &lt;code&gt;leave!&lt;/code&gt; 引发特定异常的函数：</target>
        </trans-unit>
        <trans-unit id="a05c265ccb7acfd4d24ba0e20a24a92a6ce9889f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;limit&lt;/code&gt; is given twice, it overrides the previous value.</source>
          <target state="translated">如果给定 &lt;code&gt;limit&lt;/code&gt; 两次，它将覆盖先前的值。</target>
        </trans-unit>
        <trans-unit id="e957bc885302ec7685e98cd24a82719aa373a888" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;lock&lt;/code&gt; is used more than once, the last one used takes precedence.</source>
          <target state="translated">如果多次使用 &lt;code&gt;lock&lt;/code&gt; ，则最后使用的锁优先。</target>
        </trans-unit>
        <trans-unit id="90da74aa2f941149e52e2553f73747df1e9ff078" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;nil&lt;/code&gt; is given as id, a new session id should be generated and returned.</source>
          <target state="translated">如果将 &lt;code&gt;nil&lt;/code&gt; 作为ID给出，则应生成并返回一个新的会话ID。</target>
        </trans-unit>
        <trans-unit id="7d493634e419d6aa39da5fc4a5f636e40e36f305" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;offset&lt;/code&gt; is given twice, it overrides the previous value.</source>
          <target state="translated">如果给定 &lt;code&gt;offset&lt;/code&gt; 两次，它将覆盖先前的值。</target>
        </trans-unit>
        <trans-unit id="972e323b8fae502f4935411636b7be015afc29ef" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;options&lt;/code&gt; is map or keyword list where the first element is a string, atom or integer and the second element is a list or a map, it is assumed the key will be wrapped in an &lt;code&gt;&amp;lt;optgroup&amp;gt;&lt;/code&gt; and the value will be used to generate &lt;code&gt;&amp;lt;options&amp;gt;&lt;/code&gt; nested under the group.</source>
          <target state="translated">如果 &lt;code&gt;options&lt;/code&gt; 是map或keyword list，其中第一个元素是字符串，原子或整数，第二个元素是列表或map，则假定键将包装在 &lt;code&gt;&amp;lt;optgroup&amp;gt;&lt;/code&gt; 中,并且该值将用于生成 &lt;code&gt;&amp;lt;options&amp;gt;&lt;/code&gt; 嵌套在组下。</target>
        </trans-unit>
        <trans-unit id="a3421dda344b70b936418fb88ce89a791460b02d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path_or_action&lt;/code&gt; is a string, it is considered to be the request path and stored as so in the connection. If an atom, it is assumed to be an action and the connection is dispatched to the given action.</source>
          <target state="translated">如果 &lt;code&gt;path_or_action&lt;/code&gt; 是字符串，则将其视为请求路径并将其存储在连接中。如果是原子，则假定它是一个动作，并且将连接分配给给定的动作。</target>
        </trans-unit>
        <trans-unit id="b9c8f702bb6c0810a48712a7631f4ec240983313" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;reason&lt;/code&gt; is &lt;code&gt;:closed&lt;/code&gt;, it means the client closed the socket. This is considered a &lt;code&gt;:normal&lt;/code&gt; exit signal, so linked process will not automatically exit. See &lt;a href=&quot;https://hexdocs.pm/elixir/Process.html#exit/2&quot;&gt;&lt;code&gt;Process.exit/2&lt;/code&gt;&lt;/a&gt; for more details on exit signals.</source>
          <target state="translated">如果 &lt;code&gt;reason&lt;/code&gt; 是 &lt;code&gt;:closed&lt;/code&gt; ，则表示客户端关闭了套接字。这被认为是 &lt;code&gt;:normal&lt;/code&gt; 退出信号，因此链接的过程不会自动退出。有关退出信号的更多详细信息，请参见&lt;a href=&quot;https://hexdocs.pm/elixir/Process.html#exit/2&quot;&gt; &lt;code&gt;Process.exit/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="11e582e3374d4e382af5d6f29d1086454023de04" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, the header is checked against &lt;code&gt;:host&lt;/code&gt; in &lt;code&gt;YourApp.Endpoint.config(:url)[:host]&lt;/code&gt;. If &lt;code&gt;false&lt;/code&gt;, your app is vulnerable to Cross-Site WebSocket Hijacking (CSWSH) attacks. Only use in development, when the host is truly unknown or when serving clients that do not send the &lt;code&gt;origin&lt;/code&gt; header, such as mobile apps. You can also specify a list of explicitly allowed origins. Wildcards are supported.</source>
          <target state="translated">如果 &lt;code&gt;true&lt;/code&gt; ，头部抵靠检查 &lt;code&gt;:host&lt;/code&gt; 在 &lt;code&gt;YourApp.Endpoint.config(:url)[:host]&lt;/code&gt; 。如果为 &lt;code&gt;false&lt;/code&gt; ，则您的应用程序容易受到跨站点WebSocket劫持（CSWSH）攻击。仅在主机真正未知或为不发送 &lt;code&gt;origin&lt;/code&gt; 标头的客户端（例如移动应用程序）提供服务时，才可用于开发中。您还可以指定一个明确允许的来源列表。支持通配符。</target>
        </trans-unit>
        <trans-unit id="abf67ea57ee4ce23434afd8c43be52701544068b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{:cache, cache_function, prepared}&lt;/code&gt; is given, it means the query can be cached and it must be cached by calling the &lt;code&gt;cache_function&lt;/code&gt; function with the cache entry of your choice. Once &lt;code&gt;cache_function&lt;/code&gt; is called, the next time the same query is given to &lt;a href=&quot;#c:execute/5&quot;&gt;&lt;code&gt;execute/5&lt;/code&gt;&lt;/a&gt;, it will receive the &lt;code&gt;:cached&lt;/code&gt; tuple.</source>
          <target state="translated">如果给出了 &lt;code&gt;{:cache, cache_function, prepared}&lt;/code&gt; ，则表示可以缓存查询，必须通过使用 &lt;code&gt;cache_function&lt;/code&gt; 的缓存条目调用cache_function函数来缓存查询。一旦 &lt;code&gt;cache_function&lt;/code&gt; ，下一次将相同查询提供给&lt;a href=&quot;#c:execute/5&quot;&gt; &lt;code&gt;execute/5&lt;/code&gt; 时&lt;/a&gt;，它将收到 &lt;code&gt;:cached&lt;/code&gt; 元组。</target>
        </trans-unit>
        <trans-unit id="1309c121da20f5187a51a6961ffb575f0b7cff39" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{:cached, update_function, reset_function, cached}&lt;/code&gt; is given, it means the query has been cached. You may call &lt;code&gt;update_function/1&lt;/code&gt; if you want to update the cached result. Or you may call &lt;code&gt;reset_function/1&lt;/code&gt;, with a new prepared query, to force the query to be cached again. If &lt;code&gt;reset_function/1&lt;/code&gt; is called, the next time the same query is given to &lt;a href=&quot;#c:execute/5&quot;&gt;&lt;code&gt;execute/5&lt;/code&gt;&lt;/a&gt;, it will receive the &lt;code&gt;:cache&lt;/code&gt; tuple.</source>
          <target state="translated">如果给出 &lt;code&gt;{:cached, update_function, reset_function, cached}&lt;/code&gt; ，则表示查询已被缓存。如果要更新缓存的结果，可以调用 &lt;code&gt;update_function/1&lt;/code&gt; 。或者，您可以使用一个新的准备好的查询调用 &lt;code&gt;reset_function/1&lt;/code&gt; ，以强制再次缓存该查询。如果 &lt;code&gt;reset_function/1&lt;/code&gt; ，则下一次对&lt;a href=&quot;#c:execute/5&quot;&gt; &lt;code&gt;execute/5&lt;/code&gt; &lt;/a&gt;给出相同的查询时，它将收到 &lt;code&gt;:cache&lt;/code&gt; 元组。</target>
        </trans-unit>
        <trans-unit id="e417833516d635fb72f5c63c1ffab31f552e12db" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{:nocache, prepared}&lt;/code&gt; is given, it means the query was not and cannot be cached. The &lt;code&gt;prepared&lt;/code&gt; value is the value returned by &lt;a href=&quot;#c:prepare/2&quot;&gt;&lt;code&gt;prepare/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果给出 &lt;code&gt;{:nocache, prepared}&lt;/code&gt; ，则表示该查询没有并且不能被缓存。所述 &lt;code&gt;prepared&lt;/code&gt; 值是由返回的值&lt;a href=&quot;#c:prepare/2&quot;&gt; &lt;code&gt;prepare/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="98796a5ac95043dc0bbdaf9869321de0caf5c9b9" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;PLUG_EDITOR&lt;/code&gt; environment variable is set, &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Plug.Debugger&lt;/code&gt;&lt;/a&gt; will use it to generate links to your text editor. The variable should be set with &lt;code&gt;__FILE__&lt;/code&gt; and &lt;code&gt;__LINE__&lt;/code&gt; placeholders which will be correctly replaced. For example (with the &lt;a href=&quot;http://macromates.com&quot;&gt;TextMate&lt;/a&gt; editor):</source>
          <target state="translated">如果设置了 &lt;code&gt;PLUG_EDITOR&lt;/code&gt; 环境变量，&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Plug.Debugger&lt;/code&gt; &lt;/a&gt;将使用它来生成指向您的文本编辑器的链接。该变量应使用 &lt;code&gt;__FILE__&lt;/code&gt; 和 &lt;code&gt;__LINE__&lt;/code&gt; 占位符进行设置，这些占位符将被正确替换。例如（使用&lt;a href=&quot;http://macromates.com&quot;&gt;TextMate&lt;/a&gt;编辑器）：</target>
        </trans-unit>
        <trans-unit id="a65af891627aefc80920df2e764b5156cab6de22" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;PLUG_EDITOR&lt;/code&gt; environment variable is set, &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Plug.Debugger&lt;/code&gt;&lt;/a&gt; will use it to generate links to your text editor. The variable should be set with &lt;code&gt;__FILE__&lt;/code&gt; and &lt;code&gt;__LINE__&lt;/code&gt; placeholders which will be correctly replaced. For example (with the &lt;a href=&quot;https://macromates.com&quot;&gt;TextMate&lt;/a&gt; editor):</source>
          <target state="translated">如果设置了 &lt;code&gt;PLUG_EDITOR&lt;/code&gt; 环境变量，&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Plug.Debugger&lt;/code&gt; &lt;/a&gt;将使用它来生成指向您的文本编辑器的链接。该变量应使用 &lt;code&gt;__FILE__&lt;/code&gt; 和 &lt;code&gt;__LINE__&lt;/code&gt; 占位符进行设置，这些占位符将被正确替换。例如（使用&lt;a href=&quot;https://macromates.com&quot;&gt;TextMate&lt;/a&gt;编辑器）：</target>
        </trans-unit>
        <trans-unit id="3917143de35bdf1d2e86820a8a552e7dc5784eb2" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;PLUG_EDITOR&lt;/code&gt; environment variable is set, &lt;a href=&quot;plug.debugger#content&quot;&gt;&lt;code&gt;Plug.Debugger&lt;/code&gt;&lt;/a&gt; will use it to generate links to your text editor. The variable should be set with &lt;code&gt;__FILE__&lt;/code&gt; and &lt;code&gt;__LINE__&lt;/code&gt; placeholders which will be correctly replaced. For example (with the &lt;a href=&quot;http://macromates.com&quot;&gt;TextMate&lt;/a&gt; editor):</source>
          <target state="translated">如果设置了 &lt;code&gt;PLUG_EDITOR&lt;/code&gt; 环境变量，&lt;a href=&quot;plug.debugger#content&quot;&gt; &lt;code&gt;Plug.Debugger&lt;/code&gt; &lt;/a&gt;将使用它来生成指向您的文本编辑器的链接。该变量应使用 &lt;code&gt;__FILE__&lt;/code&gt; 和 &lt;code&gt;__LINE__&lt;/code&gt; 占位符设置，并将其正确替换。例如（使用&lt;a href=&quot;http://macromates.com&quot;&gt;TextMate&lt;/a&gt;编辑器）：</target>
        </trans-unit>
        <trans-unit id="49d8918a29c80a70a37b7994f33277bbc4930397" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;PLUG_EDITOR&lt;/code&gt; environment variable is set, &lt;a href=&quot;plug.debugger#content&quot;&gt;&lt;code&gt;Plug.Debugger&lt;/code&gt;&lt;/a&gt; will use it to generate links to your text editor. The variable should be set with &lt;code&gt;__FILE__&lt;/code&gt; and &lt;code&gt;__LINE__&lt;/code&gt; placeholders which will be correctly replaced. For example (with the &lt;a href=&quot;https://macromates.com&quot;&gt;TextMate&lt;/a&gt; editor):</source>
          <target state="translated">如果设置了 &lt;code&gt;PLUG_EDITOR&lt;/code&gt; 环境变量，&lt;a href=&quot;plug.debugger#content&quot;&gt; &lt;code&gt;Plug.Debugger&lt;/code&gt; &lt;/a&gt;将使用它来生成指向您的文本编辑器的链接。该变量应使用 &lt;code&gt;__FILE__&lt;/code&gt; 和 &lt;code&gt;__LINE__&lt;/code&gt; 占位符进行设置，这些占位符将被正确替换。例如（使用&lt;a href=&quot;https://macromates.com&quot;&gt;TextMate&lt;/a&gt;编辑器）：</target>
        </trans-unit>
        <trans-unit id="b8438373db0bb704311f615a6503d58ee84b3d61" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;path&lt;/code&gt; is given, then a regular &lt;code&gt;get(conn, path)&lt;/code&gt; is done and the page is upgraded to a &lt;code&gt;LiveView&lt;/code&gt;. If no path is given, it assumes a previously rendered &lt;code&gt;%Plug.Conn{}&lt;/code&gt; is given, which will be converted to a &lt;code&gt;LiveView&lt;/code&gt; immediately.</source>
          <target state="translated">如果给出了 &lt;code&gt;path&lt;/code&gt; ，则完成常规的 &lt;code&gt;get(conn, path)&lt;/code&gt; 并将页面升级到 &lt;code&gt;LiveView&lt;/code&gt; 。如果没有给出路径，则假定给出了先前渲染的 &lt;code&gt;%Plug.Conn{}&lt;/code&gt; ，它将立即转换为 &lt;code&gt;LiveView&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f871e965d2407597bc5715cea4f0ab94f714d6e5" translate="yes" xml:space="preserve">
          <source>If a control frame doesn't have a payload, then the payload value will be &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">如果控制帧没有有效负载，则有效负载值为 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eb554a564dd3cf44251ab909d1682e6cddc415a6" translate="yes" xml:space="preserve">
          <source>If a cookie is invalid, it is automatically discarded from the result.</source>
          <target state="translated">如果一个cookie无效,则会从结果中自动丢弃。</target>
        </trans-unit>
        <trans-unit id="3710000536ae0ecb682a86fbf651cc12761ba83e" translate="yes" xml:space="preserve">
          <source>If a field is given to &lt;a href=&quot;#validate_required/3&quot;&gt;&lt;code&gt;validate_required/3&lt;/code&gt;&lt;/a&gt; but it has not been passed as parameter during &lt;a href=&quot;#cast/3&quot;&gt;&lt;code&gt;cast/3&lt;/code&gt;&lt;/a&gt; (i.e. it has not been changed), then &lt;a href=&quot;#validate_required/3&quot;&gt;&lt;code&gt;validate_required/3&lt;/code&gt;&lt;/a&gt; will check for its current value in the data. If the data contains an non-empty value for the field, then no error is added. This allows developers to use &lt;a href=&quot;#validate_required/3&quot;&gt;&lt;code&gt;validate_required/3&lt;/code&gt;&lt;/a&gt; to perform partial updates. For example, on &lt;code&gt;insert&lt;/code&gt; all fields would be required, because their default values on the data are all &lt;code&gt;nil&lt;/code&gt;, but on &lt;code&gt;update&lt;/code&gt;, if you don't want to change a field that has been previously set, you are not required to pass it as a paramater, since &lt;a href=&quot;#validate_required/3&quot;&gt;&lt;code&gt;validate_required/3&lt;/code&gt;&lt;/a&gt; won't add an error for missing changes as long as the value in the data given to the &lt;code&gt;changeset&lt;/code&gt; is not empty.</source>
          <target state="translated">如果将字段提供给&lt;a href=&quot;#validate_required/3&quot;&gt; &lt;code&gt;validate_required/3&lt;/code&gt; ,&lt;/a&gt;但在&lt;a href=&quot;#cast/3&quot;&gt; &lt;code&gt;cast/3&lt;/code&gt; &lt;/a&gt;期间未将其作为参数传递（即未更改），则&lt;a href=&quot;#validate_required/3&quot;&gt; &lt;code&gt;validate_required/3&lt;/code&gt; &lt;/a&gt;将在数据中检查其当前值。如果数据包含该字段的非空值，则不会添加错误。这使开发人员可以使用&lt;a href=&quot;#validate_required/3&quot;&gt; &lt;code&gt;validate_required/3&lt;/code&gt; &lt;/a&gt;执行部分更新。例如，在 &lt;code&gt;insert&lt;/code&gt; 将需要所有字段，因为它们在数据上的默认值均为 &lt;code&gt;nil&lt;/code&gt; ，但是在 &lt;code&gt;update&lt;/code&gt; 上，如果您不想更改先前设置的字段，则不需要将其传递为参数，因为&lt;a href=&quot;#validate_required/3&quot;&gt; &lt;code&gt;validate_required/3&lt;/code&gt; &lt;/a&gt;只要提供给 &lt;code&gt;changeset&lt;/code&gt; 的数据中的值不为空，就不会为缺少变更而添加错误。</target>
        </trans-unit>
        <trans-unit id="0bd4733e62d747fd2dc1933eb4482e62fe11f653" translate="yes" xml:space="preserve">
          <source>If a field is unchanged and &lt;code&gt;.leex&lt;/code&gt; believes a dynamic expression no longer needs to be computed, its value in the &lt;code&gt;dynamic&lt;/code&gt; list will be &lt;code&gt;nil&lt;/code&gt;. This information can be leveraged to avoid sending data to the client.</source>
          <target state="translated">如果字段未更改，并且 &lt;code&gt;.leex&lt;/code&gt; 认为不再需要计算动态表达式，则其在 &lt;code&gt;dynamic&lt;/code&gt; 列表中的值为 &lt;code&gt;nil&lt;/code&gt; 。可以利用此信息来避免将数据发送到客户端。</target>
        </trans-unit>
        <trans-unit id="6b5748e7fd13f50e04ab4f92ee369e7bef4e0182" translate="yes" xml:space="preserve">
          <source>If a file is uploaded via any of the parsers, Plug will stream the uploaded contents to a file in a temporary directory in order to avoid loading the whole file into memory. For such, the &lt;code&gt;:plug&lt;/code&gt; application needs to be started in order for file uploads to work. More details on how the uploaded file is handled can be found in the documentation for &lt;a href=&quot;plug.upload&quot;&gt;&lt;code&gt;Plug.Upload&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果文件是通过任何解析器上传的，则Plug会将上传的内容流式传输到临时目录中的文件中，以避免将整个文件加载到内存中。为此， &lt;code&gt;:plug&lt;/code&gt; 应用程序需要启动才能使文件上传生效。有关如何处理上传文件的更多详细信息，请参见&lt;a href=&quot;plug.upload&quot;&gt; &lt;code&gt;Plug.Upload&lt;/code&gt; &lt;/a&gt;的文档。</target>
        </trans-unit>
        <trans-unit id="b9a66f3d4a76267cf3daa797fca21dffb2926bba" translate="yes" xml:space="preserve">
          <source>If a request id already exists as the &quot;x-request-id&quot; HTTP request header, then that value will be used assuming it is between 20 and 200 characters. If it is not, a new request id will be generated.</source>
          <target state="translated">如果一个请求id已经作为 &quot;x-request-id &quot;HTTP请求头存在,那么这个值将被使用,假设它在20到200个字符之间。如果不存在,则会生成一个新的请求id。</target>
        </trans-unit>
        <trans-unit id="ff4d7c53872729839a77bd5a96d38cb274491289" translate="yes" xml:space="preserve">
          <source>If a request id already exists as the &amp;ldquo;x-request-id&amp;rdquo; HTTP request header, then that value will be used assuming it is between 20 and 200 characters. If it is not, a new request id will be generated.</source>
          <target state="translated">如果一个请求ID已经作为&amp;ldquo; x-request-id&amp;rdquo; HTTP请求标头存在，则将使用该值（假定它介于20到200个字符之间）。如果不是，将生成一个新的请求ID。</target>
        </trans-unit>
        <trans-unit id="0a43716c3aaf07a4683f32a558be906bc63cdf44" translate="yes" xml:space="preserve">
          <source>If a source is given, without a schema module, the given fields are passed as is to the adapter.</source>
          <target state="translated">如果给定一个源,没有模式模块,给定的字段会原封不动地传递给适配器。</target>
        </trans-unit>
        <trans-unit id="e0fcc0fd0de1b3c59c0bc9f15d6ba587aeb25386" translate="yes" xml:space="preserve">
          <source>If a static asset cannot be found, &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Plug.Static&lt;/code&gt;&lt;/a&gt; simply forwards the connection to the rest of the pipeline.</source>
          <target state="translated">如果找不到静态资产，&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Plug.Static&lt;/code&gt; &lt;/a&gt;只会将连接转发到管道的其余部分。</target>
        </trans-unit>
        <trans-unit id="43529dcc9122748af804be0c58edc57e0c307b24" translate="yes" xml:space="preserve">
          <source>If a static asset cannot be found, &lt;a href=&quot;plug.static#content&quot;&gt;&lt;code&gt;Plug.Static&lt;/code&gt;&lt;/a&gt; simply forwards the connection to the rest of the pipeline.</source>
          <target state="translated">如果找不到静态资产，则&lt;a href=&quot;plug.static#content&quot;&gt; &lt;code&gt;Plug.Static&lt;/code&gt; &lt;/a&gt;会将连接转发到其余管道。</target>
        </trans-unit>
        <trans-unit id="5ad05d6344b5d56c40d9d05868bbe0fc447a1ebc" translate="yes" xml:space="preserve">
          <source>If a subquery is given, returns the subquery itself. If any other value is given, it is converted to a query via &lt;a href=&quot;ecto.queryable&quot;&gt;&lt;code&gt;Ecto.Queryable&lt;/code&gt;&lt;/a&gt; and wrapped in the &lt;a href=&quot;ecto.subquery&quot;&gt;&lt;code&gt;Ecto.SubQuery&lt;/code&gt;&lt;/a&gt; struct.</source>
          <target state="translated">如果给出了子查询，则返回子查询本身。如果提供了其他任何值，则它将通过&lt;a href=&quot;ecto.queryable&quot;&gt; &lt;code&gt;Ecto.Queryable&lt;/code&gt; &lt;/a&gt;转换为查询并包装在&lt;a href=&quot;ecto.subquery&quot;&gt; &lt;code&gt;Ecto.SubQuery&lt;/code&gt; &lt;/a&gt;结构中。</target>
        </trans-unit>
        <trans-unit id="d48ba6ea6ec7ffa263a8d1a43b7dcdf2efa2753d" translate="yes" xml:space="preserve">
          <source>If a token exists, it is returned, otherwise it is generated and stored in the process dictionary.</source>
          <target state="translated">如果一个标记存在,就会被返回,否则就会生成并存储在进程字典中。</target>
        </trans-unit>
        <trans-unit id="9b893693b1726f40ddda25b9dd0c70ab3cfa2216" translate="yes" xml:space="preserve">
          <source>If a value is given more than once, the last value takes precedence:</source>
          <target state="translated">如果一个值被赋予多个,则以最后一个值为准。</target>
        </trans-unit>
        <trans-unit id="c72db962fcdc4941c8aba4d0408a0a707016fe8b" translate="yes" xml:space="preserve">
          <source>If a view is provided, the entire LiveView is rendered. If an element is provided, only that element is rendered.</source>
          <target state="translated">如果提供了一个视图,则渲染整个LiveView。如果提供了一个元素,则只渲染该元素。</target>
        </trans-unit>
        <trans-unit id="eaddcc5aa1077f7a26eab071fe7684352cdb0d24" translate="yes" xml:space="preserve">
          <source>If an unhandled error occurs the transaction will be rolled back and the error will bubble up from the transaction function. If no error occurred the transaction will be committed when the function returns. A transaction can be explicitly rolled back by calling &lt;a href=&quot;#c:rollback/1&quot;&gt;&lt;code&gt;rollback/1&lt;/code&gt;&lt;/a&gt;, this will immediately leave the function and return the value given to &lt;code&gt;rollback&lt;/code&gt; as &lt;code&gt;{:error, value}&lt;/code&gt;.</source>
          <target state="translated">如果发生未处理的错误，则事务将回滚，并且错误将从事务功能冒泡。如果未发生错误，则函数返回时将提交事务。可以通过调用&lt;a href=&quot;#c:rollback/1&quot;&gt; &lt;code&gt;rollback/1&lt;/code&gt; &lt;/a&gt;显式地回滚事务，这将立即离开该函数并以 &lt;code&gt;{:error, value}&lt;/code&gt; 返回给 &lt;code&gt;rollback&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="153b8768ac116a6059a08945ee6b26d18eec128a" translate="yes" xml:space="preserve">
          <source>If any of the callbacks return a &lt;code&gt;:stop&lt;/code&gt; tuple, it will also trigger terminate with the reason given in the tuple.</source>
          <target state="translated">如果任何回调返回 &lt;code&gt;:stop&lt;/code&gt; 元组，它也将根据元组中给出的原因触发终止。</target>
        </trans-unit>
        <trans-unit id="a8b20d463cde7b903560b17334ed7d36242c5f45" translate="yes" xml:space="preserve">
          <source>If available, the file is sent directly over the socket using the operating system &lt;code&gt;sendfile&lt;/code&gt; operation.</source>
          <target state="translated">如果可用，则使用操作系统 &lt;code&gt;sendfile&lt;/code&gt; 操作直接通过套接字发送文件。</target>
        </trans-unit>
        <trans-unit id="82f8819da3536b2ff1e621e91a5108e31f33c3f5" translate="yes" xml:space="preserve">
          <source>If casting of all fields is successful, the changeset is returned as valid.</source>
          <target state="translated">如果所有字段的投递成功,那么改变集将被返回为有效。</target>
        </trans-unit>
        <trans-unit id="8943a6555280626edd3a71e646c2c513ffe092f9" translate="yes" xml:space="preserve">
          <source>If changing the JSON library, remember to recompile the adapter afterwards by cleaning the current build:</source>
          <target state="translated">如果更改JSON库,记得之后要通过清理当前的构建来重新编译适配器。</target>
        </trans-unit>
        <trans-unit id="9d661e3bc80c3727f4d8b3225ce99bc171f66095" translate="yes" xml:space="preserve">
          <source>If for some reason your database does not support case insensitive columns, you can explicitly downcase values before inserting/updating them:</source>
          <target state="translated">如果出于某种原因,你的数据库不支持不区分大小写的列,你可以在插入/更新它们之前明确地将值降大写。</target>
        </trans-unit>
        <trans-unit id="14be184c345c7f9dea111444b78e1f2cb754b1fe" translate="yes" xml:space="preserve">
          <source>If installing from Hex, use the latest version from there:</source>
          <target state="translated">如果从Hex安装,请使用那里的最新版本。</target>
        </trans-unit>
        <trans-unit id="95a9f7927001d081a57717076667b9d7a6f459c0" translate="yes" xml:space="preserve">
          <source>If interpolating keyword lists, the keyword list entries are combined using ANDs and joined to any existing expression with an OR:</source>
          <target state="translated">如果插值关键词列表,则使用ANDs将关键词列表条目合并,并用OR加入到任何现有的表达式中。</target>
        </trans-unit>
        <trans-unit id="76cef5435664170ccd219b3f7c9c0adfb90f5be5" translate="yes" xml:space="preserve">
          <source>If it is a keyword query the first argument must be either an &lt;code&gt;in&lt;/code&gt; expression, or a value that implements the &lt;a href=&quot;ecto.queryable&quot;&gt;&lt;code&gt;Ecto.Queryable&lt;/code&gt;&lt;/a&gt; protocol. If the query needs a reference to the data source in any other part of the expression, then an &lt;code&gt;in&lt;/code&gt; must be used to create a reference variable. The second argument should be a keyword query where the keys are expression types and the values are expressions.</source>
          <target state="translated">如果它是关键字查询，则第一个参数必须是 &lt;code&gt;in&lt;/code&gt; 表达式或实现&lt;a href=&quot;ecto.queryable&quot;&gt; &lt;code&gt;Ecto.Queryable&lt;/code&gt; &lt;/a&gt;协议的值。如果查询需要在表达式的任何其他部分中引用数据源，则必须使用 &lt;code&gt;in&lt;/code&gt; 来创建引用变量。第二个参数应该是关键字查询，其中键是表达式类型，而值是表达式。</target>
        </trans-unit>
        <trans-unit id="e167dc3c73586f0621a46fd98ad4b4b1f1bc7e6b" translate="yes" xml:space="preserve">
          <source>If it is a query expression the first argument must be a value that implements the &lt;a href=&quot;ecto.queryable&quot;&gt;&lt;code&gt;Ecto.Queryable&lt;/code&gt;&lt;/a&gt; protocol and the second argument the expression.</source>
          <target state="translated">如果它是查询表达式，则第一个参数必须是实现&lt;a href=&quot;ecto.queryable&quot;&gt; &lt;code&gt;Ecto.Queryable&lt;/code&gt; &lt;/a&gt;协议的值，第二个参数是表达式。</target>
        </trans-unit>
        <trans-unit id="c6ade3c42f4b46404eaab263d289e45dd9fd2097" translate="yes" xml:space="preserve">
          <source>If it is your first time with Phoenix, you don't need to worry about the details right now. For now, suffice it to say our application starts a database repository, a pubsub system for sharing messages across processes and nodes, and the application endpoint, which effectively serves HTTP requests. These services are started in the order they are defined and, whenever shutting down your application, they are stopped in the reverse order.</source>
          <target state="translated">如果你是第一次使用Phoenix,你现在不需要担心细节。现在,只需说我们的应用程序启动了一个数据库存储库,一个用于在进程和节点之间共享消息的pubsub系统,以及有效服务于HTTP请求的应用程序端点。这些服务是按照它们所定义的顺序启动的,而且,无论何时关闭应用程序,它们都会按照相反的顺序停止。</target>
        </trans-unit>
        <trans-unit id="f2004e501e574e9ee412f8a4a483f6b11c68baa6" translate="yes" xml:space="preserve">
          <source>If multi contains operations that accept changesets (like &lt;a href=&quot;#insert/4&quot;&gt;&lt;code&gt;insert/4&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#update/4&quot;&gt;&lt;code&gt;update/4&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#delete/4&quot;&gt;&lt;code&gt;delete/4&lt;/code&gt;&lt;/a&gt;) they will be checked before starting the transaction. If any changeset has errors, the transaction won&amp;rsquo;t even be started and the error will be immediately returned.</source>
          <target state="translated">如果multi包含接受变更集的操作（例如&lt;a href=&quot;#insert/4&quot;&gt; &lt;code&gt;insert/4&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#update/4&quot;&gt; &lt;code&gt;update/4&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#delete/4&quot;&gt; &lt;code&gt;delete/4&lt;/code&gt; &lt;/a&gt;），则将在开始事务之前对其进行检查。如果任何变更集有错误，则事务甚至都不会启动，并且错误将立即返回。</target>
        </trans-unit>
        <trans-unit id="63d39ee63729141787866693d23e5982b3dfbe19" translate="yes" xml:space="preserve">
          <source>If multi contains operations that accept changesets (like &lt;a href=&quot;#insert/4&quot;&gt;&lt;code&gt;insert/4&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#update/4&quot;&gt;&lt;code&gt;update/4&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#delete/4&quot;&gt;&lt;code&gt;delete/4&lt;/code&gt;&lt;/a&gt;) they will be checked before starting the transaction. If any changeset has errors, the transaction won't even be started and the error will be immediately returned.</source>
          <target state="translated">如果multi包含接受变更集的操作（例如&lt;a href=&quot;#insert/4&quot;&gt; &lt;code&gt;insert/4&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#update/4&quot;&gt; &lt;code&gt;update/4&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#delete/4&quot;&gt; &lt;code&gt;delete/4&lt;/code&gt; &lt;/a&gt;），则将在开始事务之前对其进行检查。如果任何变更集有错误，则事务甚至都不会启动，并且错误将立即返回。</target>
        </trans-unit>
        <trans-unit id="636fecfc6c19833110f980b78af43a7ddc1683cf" translate="yes" xml:space="preserve">
          <source>If no action has been applied to the changeset or action was set to &lt;code&gt;:ignore&lt;/code&gt;, no errors are shown on the form object even if the changeset has a non-empty &lt;code&gt;:errors&lt;/code&gt; value.</source>
          <target state="translated">如果没有将任何操作应用于变更集或将动作设置为 &lt;code&gt;:ignore&lt;/code&gt; ，即使变更集具有非空的 &lt;code&gt;:errors&lt;/code&gt; 值，也不会在表单对象上显示任何错误。</target>
        </trans-unit>
        <trans-unit id="cf26fadc638285a0643bc477b2beb4a0a2ba425c" translate="yes" xml:space="preserve">
          <source>If no channel module is provided, the socket&amp;rsquo;s handler is used to lookup the matching channel for the given topic.</source>
          <target state="translated">如果没有提供通道模块，则使用套接字的处理程序查找给定主题的匹配通道。</target>
        </trans-unit>
        <trans-unit id="1a628119141d05e629bf0a8766bdd3134096279c" translate="yes" xml:space="preserve">
          <source>If no channel module is provided, the socket's handler is used to lookup the matching channel for the given topic.</source>
          <target state="translated">如果没有提供通道模块,则使用socket的处理程序为给定的主题查找匹配的通道。</target>
        </trans-unit>
        <trans-unit id="b2947103d7b79f0495b72a656cc81700719a03f4" translate="yes" xml:space="preserve">
          <source>If no custom parameters are specified, Erlang&amp;rsquo;s &lt;code&gt;ssl&lt;/code&gt; uses its built-in defaults. Since OTP 19 this has been the 2048-bit &amp;lsquo;group 14&amp;rsquo; from RFC 3526.</source>
          <target state="translated">如果未指定自定义参数，则Erlang的 &lt;code&gt;ssl&lt;/code&gt; 使用其内置默认值。从OTP 19开始，这就是RFC 3526中的2048位&amp;ldquo;组14&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="ff06cd66143c9798bef49db90969d1d02260d4a5" translate="yes" xml:space="preserve">
          <source>If no custom parameters are specified, Erlang's &lt;code&gt;:ssl&lt;/code&gt; uses its built-in defaults. Since OTP 19 this has been the 2048-bit 'group 14' from RFC3526.</source>
          <target state="translated">如果未指定自定义参数，则Erlang的 &lt;code&gt;:ssl&lt;/code&gt; 使用其内置默认值。从OTP 19开始，这已成为RFC3526中的2048位&amp;ldquo;组14&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="030bd22aca683fa25d2f90bbb7143785a15622d3" translate="yes" xml:space="preserve">
          <source>If no data type is given, it defaults to a string.</source>
          <target state="translated">如果没有给出数据类型,则默认为字符串。</target>
        </trans-unit>
        <trans-unit id="ad19118a3e502181cda3b94015f8e221a2d0b2b8" translate="yes" xml:space="preserve">
          <source>If no path is given, it will use &lt;code&gt;priv/static&lt;/code&gt; as the input and output path.</source>
          <target state="translated">如果没有给出路径，它将使用 &lt;code&gt;priv/static&lt;/code&gt; 作为输入和输出路径。</target>
        </trans-unit>
        <trans-unit id="8d9d3c05f3dd12de1de5d07c7780f6542cae6c1f" translate="yes" xml:space="preserve">
          <source>If no repo option is given, it is retrieved from the application environment.</source>
          <target state="translated">如果没有给出repo选项,则从应用环境中检索。</target>
        </trans-unit>
        <trans-unit id="3ee5c6147c3838216862db0b62414741e83ebcaf" translate="yes" xml:space="preserve">
          <source>If no route matches, no pipeline is invoked and a 404 error is raised.</source>
          <target state="translated">如果没有路径匹配,则不调用管道,并引发404错误。</target>
        </trans-unit>
        <trans-unit id="8d0b5d32c7f6f93cc1778a67587e008602e3131c" translate="yes" xml:space="preserve">
          <source>If no text filter is given, then the query selector itself must return a single element.</source>
          <target state="translated">如果没有给定文本过滤器,那么查询选择器本身必须返回一个单一元素。</target>
        </trans-unit>
        <trans-unit id="c3a1b6ad904f99f371f35324f835d274f96ca690" translate="yes" xml:space="preserve">
          <source>If none of the rendering options above quite fits our needs, we can compose our own using some of the functions that Plug gives us. Let's say we want to send a response with a status of &quot;201&quot; and no body whatsoever. We can easily do that with the &lt;a href=&quot;../plug/plug.conn#send_resp/3&quot;&gt;&lt;code&gt;Plug.Conn.send_resp/3&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">如果以上渲染选项均不能完全满足我们的需求，则可以使用Plug提供的一些功能来编写自己的渲染选项。假设我们要发送状态为&amp;ldquo; 201&amp;rdquo;且没有任何正文的响应。我们可以使用&lt;a href=&quot;../plug/plug.conn#send_resp/3&quot;&gt; &lt;code&gt;Plug.Conn.send_resp/3&lt;/code&gt; &lt;/a&gt;函数轻松地做到这一点。</target>
        </trans-unit>
        <trans-unit id="6adbbb0c65b31d1f51c0020589f3eb9907222ef9" translate="yes" xml:space="preserve">
          <source>If one of the goals of our context is to encapsulate Ecto Repo access, why does &lt;code&gt;create_user/1&lt;/code&gt; return an &lt;code&gt;Ecto.Changeset&lt;/code&gt; struct when we fail to create a user?</source>
          <target state="translated">如果我们上下文的目标之一是封装Ecto Repo访问，那么当我们无法创建用户时，为什么 &lt;code&gt;create_user/1&lt;/code&gt; 返回 &lt;code&gt;Ecto.Changeset&lt;/code&gt; 结构？</target>
        </trans-unit>
        <trans-unit id="ac423aab6755d9973153fe985b209449ba726adf" translate="yes" xml:space="preserve">
          <source>If supported by your database, you can also pass query expressions to distinct and it will generate a query with DISTINCT ON. In such cases, &lt;code&gt;distinct&lt;/code&gt; accepts exactly the same expressions as &lt;code&gt;order_by&lt;/code&gt; and any &lt;code&gt;distinct&lt;/code&gt; expression will be automatically prepended to the &lt;code&gt;order_by&lt;/code&gt; expressions in case there is any &lt;code&gt;order_by&lt;/code&gt; expression.</source>
          <target state="translated">如果数据库支持，还可以将查询表达式传递给distinct，它将在DISTINCT ON的情况下生成查询。在这种情况下， &lt;code&gt;distinct&lt;/code&gt; 接受与 &lt;code&gt;order_by&lt;/code&gt; 完全相同的表达式，并且在有 &lt;code&gt;order_by&lt;/code&gt; 表达式的情况下，任何 &lt;code&gt;distinct&lt;/code&gt; 表达式都会自动添加到 &lt;code&gt;order_by&lt;/code&gt; 表达式之前。</target>
        </trans-unit>
        <trans-unit id="0223af7ed3699eca63dea1d94efb960cd2c51cb2" translate="yes" xml:space="preserve">
          <source>If the &quot;postgres&quot; role does not have permission to create a database, we'll get this error.</source>
          <target state="translated">如果 &quot;postgres &quot;角色没有创建数据库的权限,我们会得到这个错误。</target>
        </trans-unit>
        <trans-unit id="ce73e85073d9175d4905b8efcee9aa421bd12fc3" translate="yes" xml:space="preserve">
          <source>If the &quot;postgres&quot; role does not have permission to log in to the application, we'll get this error.</source>
          <target state="translated">如果 &quot;postgres &quot;角色没有登录应用程序的权限,我们会得到这个错误。</target>
        </trans-unit>
        <trans-unit id="de209264f46473a4d55a8d354b626de4aafb07b2" translate="yes" xml:space="preserve">
          <source>If the &quot;postgres&quot; role is using a password different from the default &quot;postgres&quot;, we'll get this error.</source>
          <target state="translated">如果 &quot;postgres &quot;角色使用的密码与默认的 &quot;postgres &quot;不同,我们就会得到这个错误。</target>
        </trans-unit>
        <trans-unit id="70216b8d4897b8cf4c5ab39916317d1da5fb0d73" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#c:init/2&quot;&gt;&lt;code&gt;init/2&lt;/code&gt;&lt;/a&gt; callback is implemented in the repository, it will be invoked with the first argument set to &lt;code&gt;:runtime&lt;/code&gt;.</source>
          <target state="translated">如果在存储库中实现了&lt;a href=&quot;#c:init/2&quot;&gt; &lt;code&gt;init/2&lt;/code&gt; &lt;/a&gt;回调，则将在第一个参数设置为 &lt;code&gt;:runtime&lt;/code&gt; 的情况下调用它。</target>
        </trans-unit>
        <trans-unit id="bbad62ac0f0e10ca6a55f7468a042cab7daca496" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;:sign&lt;/code&gt; or &lt;code&gt;:encrypt&lt;/code&gt; flag are given, then the cookie value can be any term.</source>
          <target state="translated">如果给出了 &lt;code&gt;:sign&lt;/code&gt; 或 &lt;code&gt;:encrypt&lt;/code&gt; 标志，则cookie值可以是任何术语。</target>
        </trans-unit>
        <trans-unit id="bda9d4cb892d2093b03ae139bdc1a11671af1389" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;@title&lt;/code&gt; assign changes, then LiveView will execute &lt;code&gt;expand_title(@title)&lt;/code&gt; and send the new content. If &lt;code&gt;@title&lt;/code&gt; is the same, nothing is executed and nothing is sent.</source>
          <target state="translated">如果 &lt;code&gt;@title&lt;/code&gt; 分配更改，则LiveView将执行 &lt;code&gt;expand_title(@title)&lt;/code&gt; 并发送新内容。如果 &lt;code&gt;@title&lt;/code&gt; 相同，则不执行任何操作，也不发送任何内容。</target>
        </trans-unit>
        <trans-unit id="3de200e7c0ff094d2c2c6dcf0b8963fe5d0947ef" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;@user.name&lt;/code&gt; changes but &lt;code&gt;@user.id&lt;/code&gt; doesn't, then LiveView will re-render only &lt;code&gt;@user.name&lt;/code&gt; and it will not execute or resend &lt;code&gt;@user.id&lt;/code&gt; at all.</source>
          <target state="translated">如果 &lt;code&gt;@user.name&lt;/code&gt; 的变化，但 &lt;code&gt;@user.id&lt;/code&gt; 没有，那么实时查看将重新渲染只有 &lt;code&gt;@user.name&lt;/code&gt; ，也不会执行或重发 &lt;code&gt;@user.id&lt;/code&gt; 可言。</target>
        </trans-unit>
        <trans-unit id="20375713da5b5d68c5268d482ffb338724366ce5" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;phx-value-&lt;/code&gt; prefix is used, the server payload will also contain a &lt;code&gt;&quot;value&quot;&lt;/code&gt; if the element's value attribute exists.</source>
          <target state="translated">如果使用 &lt;code&gt;phx-value-&lt;/code&gt; 前缀，则在元素的value属性存在的情况下，服务器有效负载还将包含 &lt;code&gt;&quot;value&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9712dc6b620700aa8412aa4754ed6dd3e600a162" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;required_key&lt;/code&gt; is not present, it will raise &lt;a href=&quot;phoenix.missingparamerror&quot;&gt;&lt;code&gt;Phoenix.MissingParamError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;required_key&lt;/code&gt; 不存在，它将引发&lt;a href=&quot;phoenix.missingparamerror&quot;&gt; &lt;code&gt;Phoenix.MissingParamError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5cd227aadd17ccc0cdbbbf544e1a39ccbddc874c" translate="yes" xml:space="preserve">
          <source>If the LiveView is the source of truth, it will be responsible for fetching all of the cards in a board. Then it will call &lt;code&gt;live_component/3&lt;/code&gt; for each card, passing the card struct as argument to CardComponent:</source>
          <target state="translated">如果LiveView是真相的来源，它将负责获取板上的所有卡。然后它将为每张卡调用 &lt;code&gt;live_component/3&lt;/code&gt; ，将卡结构作为参数传递给CardComponent：</target>
        </trans-unit>
        <trans-unit id="b677401fc03b5a40d9088383358e9a2bc2639670" translate="yes" xml:space="preserve">
          <source>If the LiveView redirects with a live redirect, this macro returns &lt;code&gt;{:ok, live_view, disconnected_html}&lt;/code&gt; with the content of the new LiveView, the same as the &lt;code&gt;live/3&lt;/code&gt; macro. If the LiveView redirects with a regular redirect, this macro returns &lt;code&gt;{:ok, conn}&lt;/code&gt; with the rendered redirected page. In any other case, this macro raises.</source>
          <target state="translated">如果LiveView使用实时重定向进行重定向，则此宏将返回带有新LiveView内容的 &lt;code&gt;{:ok, live_view, disconnected_html}&lt;/code&gt; 与 &lt;code&gt;live/3&lt;/code&gt; 宏相同。如果LiveView使用常规重定向进行重定向，则此宏将与呈现的重定向页面一起返回 &lt;code&gt;{:ok, conn}&lt;/code&gt; 。在任何其他情况下，此宏都会引发。</target>
        </trans-unit>
        <trans-unit id="774625820d7d0ec4e795fa8c9c6c08379f522851" translate="yes" xml:space="preserve">
          <source>If the URL has a host, a CSRF token that is tied to that host will be generated. If it is a relative path URL, a simple token emitted with &lt;a href=&quot;#get_csrf_token/0&quot;&gt;&lt;code&gt;get_csrf_token/0&lt;/code&gt;&lt;/a&gt; will be used.</source>
          <target state="translated">如果URL具有主机，则将生成与该主机绑定的CSRF令牌。如果它是相对路径URL，则将使用与&lt;a href=&quot;#get_csrf_token/0&quot;&gt; &lt;code&gt;get_csrf_token/0&lt;/code&gt; &lt;/a&gt;一起发出的简单令牌。</target>
        </trans-unit>
        <trans-unit id="5e46e2e7ec4df9676257eca653e07b09f347fb52" translate="yes" xml:space="preserve">
          <source>If the adapter does not provide a pool, just calling the passed function and returning its result are enough.</source>
          <target state="translated">如果适配器没有提供一个池,只需调用传递的函数并返回其结果即可。</target>
        </trans-unit>
        <trans-unit id="c467ebfb28c3769c0f60d1ed5192b127c4f129d1" translate="yes" xml:space="preserve">
          <source>If the adapter does not support inform, then &lt;code&gt;{:error, :not_supported}&lt;/code&gt; should be returned.</source>
          <target state="translated">如果适配器不支持通知，则应返回 &lt;code&gt;{:error, :not_supported}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b83fa861079f61f5349df999d4ab77d5e9dd2d46" translate="yes" xml:space="preserve">
          <source>If the adapter does not support informational responses then this is a noop.</source>
          <target state="translated">如果适配器不支持信息响应,那么这是一个noop。</target>
        </trans-unit>
        <trans-unit id="abd9faa09d21bdad382cd8d73f3c1cd6edf98fe0" translate="yes" xml:space="preserve">
          <source>If the adapter does not support server push then &lt;code&gt;{:error, :not_supported}&lt;/code&gt; should be returned.</source>
          <target state="translated">如果适配器不支持服务器推送 &lt;code&gt;{:error, :not_supported}&lt;/code&gt; 则应返回{：error，：not_supported}。</target>
        </trans-unit>
        <trans-unit id="03a7adb38fe4fd08405bbe2e59b1dc64945ce1ee" translate="yes" xml:space="preserve">
          <source>If the adapter does not support server push then this is a noop.</source>
          <target state="translated">如果适配器不支持服务器推送,那么这是一个noop。</target>
        </trans-unit>
        <trans-unit id="e1ab595daecbe8219ab31d6ce1dc0b9d4bd3ff2d" translate="yes" xml:space="preserve">
          <source>If the adapter provides a pool, it is supposed to &quot;check out&quot; one of the pool connections for the duration of the function call. Which connection is checked out is not passed to the calling function, so it should be done using a stateful method like using the current process' dictionary, process tracking, or some kind of other lookup method. Make sure that this stored connection is then used in the other callbacks implementations, such as &lt;a href=&quot;ecto.adapter.queryable&quot;&gt;&lt;code&gt;Ecto.Adapter.Queryable&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;ecto.adapter.schema&quot;&gt;&lt;code&gt;Ecto.Adapter.Schema&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果适配器提供了一个池，则应该在函数调用期间&amp;ldquo;检出&amp;rdquo;其中一个池连接。检出的连接不会传递给调用函数，因此应使用有状态方法（例如使用当前进程的字典，进程跟踪或某种其他查找方法）来完成。确保此存储的连接随后在其他回调实现中使用，例如&lt;a href=&quot;ecto.adapter.queryable&quot;&gt; &lt;code&gt;Ecto.Adapter.Queryable&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;ecto.adapter.schema&quot;&gt; &lt;code&gt;Ecto.Adapter.Schema&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="67e30f305c8d388d84dacb2f22a8db0505392601" translate="yes" xml:space="preserve">
          <source>If the argument to &lt;code&gt;:select_merge&lt;/code&gt; is a constructed struct (&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#struct/2&quot;&gt;&lt;code&gt;struct/2&lt;/code&gt;&lt;/a&gt;) or map (&lt;code&gt;map/2&lt;/code&gt;) where the source to &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#struct/2&quot;&gt;&lt;code&gt;struct/2&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;map/2&lt;/code&gt; may be a &lt;code&gt;nil&lt;/code&gt; value (as in an outer join), the source will be returned unmodified.</source>
          <target state="translated">如果 &lt;code&gt;:select_merge&lt;/code&gt; 的参数是构造的struct（&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#struct/2&quot;&gt; &lt;code&gt;struct/2&lt;/code&gt; &lt;/a&gt;）或map（ &lt;code&gt;map/2&lt;/code&gt; ），其中&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#struct/2&quot;&gt; &lt;code&gt;struct/2&lt;/code&gt; &lt;/a&gt;或 &lt;code&gt;map/2&lt;/code&gt; 的源可能是 &lt;code&gt;nil&lt;/code&gt; 值（如在外部联接中），则源将是返回未修改的。</target>
        </trans-unit>
        <trans-unit id="c1c015b3bdb8e3e97eeb9a475ec46483a71e9b1c" translate="yes" xml:space="preserve">
          <source>If the association has no changes, it will be skipped. If the association is invalid, the changeset will be marked as invalid. If the given value is not any of values below, it will raise.</source>
          <target state="translated">如果关联没有变化,将被跳过。如果关联无效,变化集将被标记为无效。如果给定的值不是下面的任何一个值,它将引发。</target>
        </trans-unit>
        <trans-unit id="6943cbcbf6b1af61a1ee6167ddcf2f6551e4192a" translate="yes" xml:space="preserve">
          <source>If the body of the action needs access to the full map of parameters bound to the params variable in addition to the bound messenger variable, we could define &lt;code&gt;show/2&lt;/code&gt; like this:</source>
          <target state="translated">如果动作的主体除了需要绑定的Messenger变量之外，还需要访问绑定到params变量的参数的完整映射，我们可以这样定义 &lt;code&gt;show/2&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="9f7bac3c27469f7d4914ccb40eab78a149fc9bfe" translate="yes" xml:space="preserve">
          <source>If the change is already present, it is overridden with the new value.</source>
          <target state="translated">如果变化已经存在,则用新值覆盖。</target>
        </trans-unit>
        <trans-unit id="b0a698e1cab1f6f678660aa4dfb67045d6928daa" translate="yes" xml:space="preserve">
          <source>If the change is already present, it is overridden with the new value. If the change has the same value as in the changeset data, it is not added to the list of changes.</source>
          <target state="translated">如果变化已经存在,它将被新的值覆盖。如果更改的值与更改集数据中的值相同,则不会将其添加到更改列表中。</target>
        </trans-unit>
        <trans-unit id="d643dc985a9051bacd04e1a9f62548fd0e65c8a1" translate="yes" xml:space="preserve">
          <source>If the changes are valid, all changes are applied to the changeset data. If the changes are invalid, no changes are applied, and an error tuple is returned with the changeset containing the action that was attempted to be applied.</source>
          <target state="translated">如果更改有效,所有的更改都被应用到更改集数据中。如果更改无效,则不应用任何更改,并返回一个错误元组,其中包含试图应用的更改集的操作。</target>
        </trans-unit>
        <trans-unit id="2757319b7d7f37a81751b87f0ba7d4b5be8070c7" translate="yes" xml:space="preserve">
          <source>If the changeset given to the repository is valid, the function given to &lt;a href=&quot;#prepare_changes/2&quot;&gt;&lt;code&gt;prepare_changes/2&lt;/code&gt;&lt;/a&gt; will be called with the changeset and must return a changeset, allowing developers to do final adjustments to the changeset or to issue data consistency commands. The repository itself can be accessed inside the function under the &lt;code&gt;repo&lt;/code&gt; field in the changeset. If the changeset given to the repository is invalid, the function will not be invoked.</source>
          <target state="translated">如果提供给存储库的变更集有效，则将使用变更集调用为&lt;a href=&quot;#prepare_changes/2&quot;&gt; &lt;code&gt;prepare_changes/2&lt;/code&gt; &lt;/a&gt;提供的函数，并且该函数必须返回变更集，从而允许开发人员对变更集进行最终调整或发出数据一致性命令。可以在更改集中的 &lt;code&gt;repo&lt;/code&gt; 字段下的函数内部访问存储库本身。如果提供给存储库的变更集无效，则不会调用该函数。</target>
        </trans-unit>
        <trans-unit id="bdfa9dbe95ded2efddb01ada6c9e4b572e2c816b" translate="yes" xml:space="preserve">
          <source>If the component is the source of truth, then the LiveView must no longer fetch all of the cards structs from the database. Instead, the view must only fetch all of the card ids and render the component only by passing the IDs:</source>
          <target state="translated">如果该组件是真理的来源,那么LiveView必须不再从数据库中获取所有的卡结构。取而代之的是,视图必须只获取所有的卡片id,并且只通过传递ID来渲染组件。</target>
        </trans-unit>
        <trans-unit id="67aa5ebe70fe8f05417258db1eb3c5975b93dd2a" translate="yes" xml:space="preserve">
          <source>If the component uses the &lt;code&gt;@myself&lt;/code&gt; assigns, then an &lt;code&gt;id&lt;/code&gt; must be given to it is marked as stateful.</source>
          <target state="translated">如果组件使用 &lt;code&gt;@myself&lt;/code&gt; 分配，则必须为其提供一个 &lt;code&gt;id&lt;/code&gt; 将其标记为有状态。</target>
        </trans-unit>
        <trans-unit id="344cb03738b4c3ad68a22abc027e74afa335c15c" translate="yes" xml:space="preserve">
          <source>If the connection is accepted, the transport can move the connection to another process, if so desires, or keep using the same process. The process responsible for managing the socket should then call &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果接受了连接，则传输程序可以将连接移到另一个进程（如果需要），或者继续使用相同的进程。然后，负责管理套接字的进程应调用&lt;a href=&quot;#c:init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5d577ab6f6374c6d9db1620ec48bb72e49c4e5c2" translate="yes" xml:space="preserve">
          <source>If the connection was successful, generates &lt;a href=&quot;../phoenix_pubsub/1.0.2/phoenix.pubsub&quot;&gt;&lt;code&gt;Phoenix.PubSub&lt;/code&gt;&lt;/a&gt; topic from the &lt;code&gt;id/1&lt;/code&gt; callback.</source>
          <target state="translated">如果连接成功，则从 &lt;code&gt;id/1&lt;/code&gt; 回调生成&lt;a href=&quot;../phoenix_pubsub/1.0.2/phoenix.pubsub&quot;&gt; &lt;code&gt;Phoenix.PubSub&lt;/code&gt; &lt;/a&gt;主题。</target>
        </trans-unit>
        <trans-unit id="14c0b3c8ee8241e593e8ad60d75f84e2457bdc6b" translate="yes" xml:space="preserve">
          <source>If the cookie is not signed nor encrypted, then the value must be a binary. Note the value is not automatically escaped. Therefore if you want to store values with non-alphanumeric characters, you must either sign or encrypt the cookie or consider explicitly escaping the cookie value by using a function such as &lt;code&gt;Base.encode64(value, padding: false)&lt;/code&gt; when writing and &lt;code&gt;Base.decode64(encoded, padding: false)&lt;/code&gt; when reading the cookie. It is important for padding to be disabled since &lt;code&gt;=&lt;/code&gt; is not a valid character in cookie values.</source>
          <target state="translated">如果未对cookie进行签名或加密，则该值必须为二进制。请注意，该值不会自动转义。因此，如果要存储非字母数字字符的值，则必须签名或加密cookie，或者考虑在编写和使用 &lt;code&gt;Base.decode64(encoded, padding: false)&lt;/code&gt; 时使用诸如 &lt;code&gt;Base.encode64(value, padding: false)&lt;/code&gt; 类的函数显式转义cookie值。（编码，填充：false）在读取Cookie时。禁用填充非常重要，因为 &lt;code&gt;=&lt;/code&gt; 在cookie值中不是有效字符。</target>
        </trans-unit>
        <trans-unit id="864bd00ea3a957445c805b9ef45d85dcecd562f1" translate="yes" xml:space="preserve">
          <source>If the element is does not have a &lt;code&gt;phx-click&lt;/code&gt; attribute but it is a link (the &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; tag), the link will be followed accordingly:</source>
          <target state="translated">如果该元素没有 &lt;code&gt;phx-click&lt;/code&gt; 属性，但它是一个链接（ &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; 标记），则将相应地跟随该链接：</target>
        </trans-unit>
        <trans-unit id="3a5834bc3acf73c8335beda9b2b7bbaf51ee3a6e" translate="yes" xml:space="preserve">
          <source>If the embed has no changes, it will be skipped. If the embed is invalid, the changeset will be marked as invalid.</source>
          <target state="translated">如果嵌入的内容没有变化,将被跳过。如果嵌入的内容无效,则改变集将被标记为无效。</target>
        </trans-unit>
        <trans-unit id="077370f1bc31b993e443236f4c6f4806ca2f3eaa" translate="yes" xml:space="preserve">
          <source>If the error happens during an event, the LiveView process will crash. The client will notice the error and remount the LiveView - without reloading the page. This is enough to update the page and show the user the latest information.</source>
          <target state="translated">如果错误发生在事件期间,LiveView进程将崩溃。客户端会注意到这个错误,并重新挂载LiveView--无需重新加载页面。这足以更新页面并向用户展示最新信息。</target>
        </trans-unit>
        <trans-unit id="100887b9de3b56af079f0a72491a4382d1396bb0" translate="yes" xml:space="preserve">
          <source>If the map on the left side is a struct, Ecto will check all of the field on the right previously exist on the left before merging.</source>
          <target state="translated">如果左边的地图是一个结构体,Ecto会在合并前检查右边所有的字段是否在左边存在。</target>
        </trans-unit>
        <trans-unit id="67cfc2cb3e12875af3e1ba6a2973b3dbd4bbf5ad" translate="yes" xml:space="preserve">
          <source>If the parameter contains an ID and there is an associated child with such ID, the parameter data will be passed to &lt;code&gt;MyApp.Address.changeset/2&lt;/code&gt; with the existing struct and become an update operation</source>
          <target state="translated">如果参数包含一个ID并且有一个与此ID关联的子代，则参数数据将与现有结构一起传递到 &lt;code&gt;MyApp.Address.changeset/2&lt;/code&gt; ，并成为更新操作</target>
        </trans-unit>
        <trans-unit id="5b235bb233a3f3d355503c030abb877188e1fb03" translate="yes" xml:space="preserve">
          <source>If the parameter contains an ID and there is no associated child with such ID, the parameter data will be passed to &lt;code&gt;MyApp.Address.changeset/2&lt;/code&gt; with a new struct and become an insert operation</source>
          <target state="translated">如果参数包含一个ID并且没有与此ID关联的子代，则参数数据将使用新结构传递到 &lt;code&gt;MyApp.Address.changeset/2&lt;/code&gt; 并成为插入操作</target>
        </trans-unit>
        <trans-unit id="4c2858b55ac4015434edf3d00d6d984a1e7af01d" translate="yes" xml:space="preserve">
          <source>If the parameter does not contain an ID, the parameter data will be passed to &lt;code&gt;MyApp.Address.changeset/2&lt;/code&gt; with a new struct and become an insert operation</source>
          <target state="translated">如果参数不包含ID，则参数数据将使用新结构传递到 &lt;code&gt;MyApp.Address.changeset/2&lt;/code&gt; 并成为插入操作</target>
        </trans-unit>
        <trans-unit id="78ee41955dbd956392d43e790282ee7ecabd02d3" translate="yes" xml:space="preserve">
          <source>If the parameterized type is also a composite type, the inner type can be cast by calling &lt;a href=&quot;ecto.type#cast/2&quot;&gt;&lt;code&gt;Ecto.Type.cast/2&lt;/code&gt;&lt;/a&gt; directly.</source>
          <target state="translated">如果参数化类型也是复合类型，则可以通过直接调用&lt;a href=&quot;ecto.type#cast/2&quot;&gt; &lt;code&gt;Ecto.Type.cast/2&lt;/code&gt; &lt;/a&gt;来强制转换内部类型。</target>
        </trans-unit>
        <trans-unit id="6e14dbb4189c408fd4ca75086bfd71c426f435db" translate="yes" xml:space="preserve">
          <source>If the passed function returns &lt;code&gt;:pop&lt;/code&gt;, the return value of this callback must be &lt;code&gt;{value, new_data}&lt;/code&gt; where &lt;code&gt;value&lt;/code&gt; is the value under &lt;code&gt;key&lt;/code&gt; (or &lt;code&gt;nil&lt;/code&gt; if not present) and &lt;code&gt;new_data&lt;/code&gt; is &lt;code&gt;data&lt;/code&gt; without &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">如果传递的函数返回 &lt;code&gt;:pop&lt;/code&gt; ，则此回调的返回值必须为 &lt;code&gt;{value, new_data}&lt;/code&gt; ，其中 &lt;code&gt;value&lt;/code&gt; 是 &lt;code&gt;key&lt;/code&gt; 下的值（如果不存在，则为 &lt;code&gt;nil&lt;/code&gt; ），而 &lt;code&gt;new_data&lt;/code&gt; 是没有 &lt;code&gt;key&lt;/code&gt; 的 &lt;code&gt;data&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ff09001e9ce2d8278137d1ce993917e82be4cb26" translate="yes" xml:space="preserve">
          <source>If the passed function returns &lt;code&gt;{get_value, update_value}&lt;/code&gt;, the return value of this callback should be &lt;code&gt;{get_value, new_data}&lt;/code&gt;, where:</source>
          <target state="translated">如果传递的函数返回 &lt;code&gt;{get_value, update_value}&lt;/code&gt; ，则此回调的返回值应为 &lt;code&gt;{get_value, new_data}&lt;/code&gt; ，其中：</target>
        </trans-unit>
        <trans-unit id="a2143e7239fbfa87b876c6cf2de6756de08ffc64" translate="yes" xml:space="preserve">
          <source>If the query has a limit, offset or distinct set, it will be automatically wrapped in a subquery in order to return the proper result.</source>
          <target state="translated">如果查询有限制、偏移或独特的集合,它将被自动包裹在一个子查询中,以返回适当的结果。</target>
        </trans-unit>
        <trans-unit id="7d2bddb6cc8d18143b43f8bbafcae7867ac58bcf" translate="yes" xml:space="preserve">
          <source>If the relationship is a &lt;code&gt;has_one&lt;/code&gt; or &lt;code&gt;has_many&lt;/code&gt; and the key is set in the given struct, the key will automatically be set in the built association:</source>
          <target state="translated">如果关系是 &lt;code&gt;has_one&lt;/code&gt; 或 &lt;code&gt;has_many&lt;/code&gt; ,并且在给定的struct中设置了密钥，则将在构建的关联中自动设置密钥：</target>
        </trans-unit>
        <trans-unit id="fc8c910d7e1f4a7ca500d332206b3b56b62dcdd3" translate="yes" xml:space="preserve">
          <source>If the relationship is a &lt;code&gt;has_one&lt;/code&gt; or &lt;code&gt;has_many&lt;/code&gt; and the primary key is set in the parent struct, the key will automatically be set in the built association:</source>
          <target state="translated">如果关系是 &lt;code&gt;has_one&lt;/code&gt; 或 &lt;code&gt;has_many&lt;/code&gt; 并且主键是在父结构中设置的，则该键将自动在已建立的关联中设置：</target>
        </trans-unit>
        <trans-unit id="c0ab972c154c21dacb18a792e2b9de9b778294e4" translate="yes" xml:space="preserve">
          <source>If the request contains a &quot;_format&quot; parameter, it is considered to be the format desired by the client. If no &quot;_format&quot; parameter is available, this function will parse the &quot;accept&quot; header and find a matching format accordingly.</source>
          <target state="translated">如果请求中包含&quot;_format &quot;参数,则被认为是客户端所需的格式,如果没有&quot;_format &quot;参数,该函数将解析 &quot;accept &quot;头,并找到相应的格式。如果没有&quot;_format &quot;参数,这个函数将解析 &quot;accept &quot;头,并找到相应的匹配格式。</target>
        </trans-unit>
        <trans-unit id="589c270364db1b0108ce43960e91be264009debe" translate="yes" xml:space="preserve">
          <source>If the request contains a &amp;ldquo;_format&amp;rdquo; parameter, it is considered to be the format desired by the client. If no &amp;ldquo;_format&amp;rdquo; parameter is available, this function will parse the &amp;ldquo;accept&amp;rdquo; header and find a matching format accordingly.</source>
          <target state="translated">如果请求包含&amp;ldquo; _format&amp;rdquo;参数，则将其视为客户端所需的格式。如果没有&amp;ldquo; _format&amp;rdquo;参数可用，则此函数将解析&amp;ldquo; accept&amp;rdquo;标头并相应地找到匹配的格式。</target>
        </trans-unit>
        <trans-unit id="c173a238b103f05715b98fa0448f517f74ccec4e" translate="yes" xml:space="preserve">
          <source>If the request has method &lt;code&gt;&quot;HEAD&quot;&lt;/code&gt;, the adapter should not send the response to the client.</source>
          <target state="translated">如果请求的方法为 &lt;code&gt;&quot;HEAD&quot;&lt;/code&gt; ，则适配器不应将响应发送给客户端。</target>
        </trans-unit>
        <trans-unit id="d45df81e2caa272cbf84dfebf38c8aa28609010e" translate="yes" xml:space="preserve">
          <source>If the route contains glob-like patterns, parameters for those have to be given as list:</source>
          <target state="translated">如果路由中包含 glob-like 模式,那么这些模式的参数必须以 list 的形式给出。</target>
        </trans-unit>
        <trans-unit id="2bf5da11b58dcf3690804466cd69ea5e5e4dca07" translate="yes" xml:space="preserve">
          <source>If the same source is selected multiple times with a &lt;code&gt;map&lt;/code&gt;, the fields are merged in order to avoid fetching multiple copies from the database. In other words, the expression below:</source>
          <target state="translated">如果使用 &lt;code&gt;map&lt;/code&gt; 多次选择了同一源，则将合并字段，以避免从数据库中获取多个副本。换句话说，下面的表达式：</target>
        </trans-unit>
        <trans-unit id="652e9d42a43e2b8d5dcd0218df8782089064b141" translate="yes" xml:space="preserve">
          <source>If the same source is selected multiple times with a &lt;code&gt;struct&lt;/code&gt;, the fields are merged in order to avoid fetching multiple copies from the database. In other words, the expression below:</source>
          <target state="translated">如果使用 &lt;code&gt;struct&lt;/code&gt; 多次选择同一源，则将合并字段，以避免从数据库中获取多个副本。换句话说，下面的表达式：</target>
        </trans-unit>
        <trans-unit id="52eb3cdb7cd07fea24cf8899ccfeee45fa44e2fe" translate="yes" xml:space="preserve">
          <source>If the scheme of a request is &lt;code&gt;https&lt;/code&gt;, it&amp;rsquo;ll add a &lt;code&gt;strict-transport-security&lt;/code&gt; header to enable HTTP Strict Transport Security by default.</source>
          <target state="translated">如果请求的方案为 &lt;code&gt;https&lt;/code&gt; ，它将添加一个 &lt;code&gt;strict-transport-security&lt;/code&gt; 标头，以默认情况下启用HTTP Strict Transport Security。</target>
        </trans-unit>
        <trans-unit id="564b33d47ddc46edcbbb5f1d39d5ab6ae21f5998" translate="yes" xml:space="preserve">
          <source>If the scheme of a request is &lt;code&gt;https&lt;/code&gt;, it&amp;rsquo;ll add a &lt;code&gt;strict-transport-security&lt;/code&gt; header to enable HTTP Strict Transport Security.</source>
          <target state="translated">如果请求的方案是 &lt;code&gt;https&lt;/code&gt; ，它将添加一个 &lt;code&gt;strict-transport-security&lt;/code&gt; 标头以启用HTTP Strict Transport Security。</target>
        </trans-unit>
        <trans-unit id="8ce0178df9065e1071126bd4051a90d7aa5fa061" translate="yes" xml:space="preserve">
          <source>If the scheme of a request is &lt;code&gt;https&lt;/code&gt;, it'll add a &lt;code&gt;strict-transport-security&lt;/code&gt; header to enable HTTP Strict Transport Security by default.</source>
          <target state="translated">如果请求的方案为 &lt;code&gt;https&lt;/code&gt; ，它将添加一个 &lt;code&gt;strict-transport-security&lt;/code&gt; 标头，以默认情况下启用HTTP Strict Transport Security。</target>
        </trans-unit>
        <trans-unit id="1e40997d2cab9139afd7b3e62e6c58a9b6923fe9" translate="yes" xml:space="preserve">
          <source>If the session has already been initialized, the new contents will be merged with the previous ones.</source>
          <target state="translated">如果会话已经被初始化,新的内容将与之前的内容合并。</target>
        </trans-unit>
        <trans-unit id="187932693c763b03306b32e57e7c13cda06351fc" translate="yes" xml:space="preserve">
          <source>If the struct cannot be found, &lt;a href=&quot;ecto.staleentryerror&quot;&gt;&lt;code&gt;Ecto.StaleEntryError&lt;/code&gt;&lt;/a&gt; will be raised.</source>
          <target state="translated">如果找不到该结构，则将引发&lt;a href=&quot;ecto.staleentryerror&quot;&gt; &lt;code&gt;Ecto.StaleEntryError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="62ac87da8864e486a5dadb087a7c2632f82b5234" translate="yes" xml:space="preserve">
          <source>If the struct has no primary key, &lt;a href=&quot;ecto.noprimarykeyfielderror&quot;&gt;&lt;code&gt;Ecto.NoPrimaryKeyFieldError&lt;/code&gt;&lt;/a&gt; will be raised.</source>
          <target state="translated">如果该结构没有主键，则将引发&lt;a href=&quot;ecto.noprimarykeyfielderror&quot;&gt; &lt;code&gt;Ecto.NoPrimaryKeyFieldError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a8767938851ade63a15afc91119604f0839e7344" translate="yes" xml:space="preserve">
          <source>If the struct has no primary key, &lt;a href=&quot;ecto.noprimarykeyfielderror&quot;&gt;&lt;code&gt;Ecto.NoPrimaryKeyFieldError&lt;/code&gt;&lt;/a&gt; will be raised. If the struct has been removed from db prior to call, &lt;a href=&quot;ecto.staleentryerror&quot;&gt;&lt;code&gt;Ecto.StaleEntryError&lt;/code&gt;&lt;/a&gt; will be raised.</source>
          <target state="translated">如果该结构没有主键，则将引发&lt;a href=&quot;ecto.noprimarykeyfielderror&quot;&gt; &lt;code&gt;Ecto.NoPrimaryKeyFieldError&lt;/code&gt; &lt;/a&gt;。如果在调用之前已从db中删除了该结构，则将引发&lt;a href=&quot;ecto.staleentryerror&quot;&gt; &lt;code&gt;Ecto.StaleEntryError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e5578acf03166a21322dd600d9a66efef5d73e58" translate="yes" xml:space="preserve">
          <source>If the underlying input type is a &lt;code&gt;:text_field&lt;/code&gt;, a mapping could be given to further inflect the input type based solely on the field name. The default mapping is:</source>
          <target state="translated">如果基础输入类型是 &lt;code&gt;:text_field&lt;/code&gt; ，则可以给出一个映射以仅基于字段名称进一步改变输入类型。默认映射为：</target>
        </trans-unit>
        <trans-unit id="41a1e50f02aaf223bea1728ac3e4f595a0d0fbc9" translate="yes" xml:space="preserve">
          <source>If the value of a field is &lt;code&gt;nil&lt;/code&gt; or a string made only of whitespace, the changeset is marked as invalid, the field is removed from the changeset&amp;rsquo;s changes, and an error is added. Note the error won&amp;rsquo;t be added though if the field already has an error.</source>
          <target state="translated">如果字段的值为 &lt;code&gt;nil&lt;/code&gt; 或仅由空格组成的字符串，则更改集被标记为无效，将该字段从更改集的更改中删除，并添加错误。请注意，如果该字段已经有错误，则不会添加该错误。</target>
        </trans-unit>
        <trans-unit id="b51a8cfa4d0487afe8257855e71b56a122faf53b" translate="yes" xml:space="preserve">
          <source>If the value of a field is &lt;code&gt;nil&lt;/code&gt; or a string made only of whitespace, the changeset is marked as invalid, the field is removed from the changeset's changes, and an error is added. An error won't be added if the field already has an error.</source>
          <target state="translated">如果字段的值为 &lt;code&gt;nil&lt;/code&gt; 或仅由空格组成的字符串，则更改集将标记为无效，将该字段从更改集的更改中删除，并添加错误。如果该字段已经有错误，则不会添加错误。</target>
        </trans-unit>
        <trans-unit id="ccfc8db638f1f1620ef7b8abebc9015b4310b64a" translate="yes" xml:space="preserve">
          <source>If there is an associated child with an ID and its ID is not given as parameter, the &lt;code&gt;:on_replace&lt;/code&gt; callback for that association will be invoked (see the &quot;On replace&quot; section on the module documentation)</source>
          <target state="translated">如果存在一个具有ID的关联子代，并且未将其ID作为参数给出， &lt;code&gt;:on_replace&lt;/code&gt; 调用该关联的：on_replace回调（请参见模块文档中的&amp;ldquo;替换时&amp;rdquo;部分）</target>
        </trans-unit>
        <trans-unit id="5bc5b56a27b8e1d0d4212e390ddd5e71de7e4d2d" translate="yes" xml:space="preserve">
          <source>If there is an associated child with an ID and its ID is not given as parameter, the &lt;code&gt;:on_replace&lt;/code&gt; callback for that association will be invoked (see the &amp;ldquo;On replace&amp;rdquo; section on the module documentation)</source>
          <target state="translated">如果存在一个具有ID的关联子代，并且未将其ID作为参数给出， &lt;code&gt;:on_replace&lt;/code&gt; 调用该关联的：on_replace回调（请参见模块文档中的&amp;ldquo;替换时&amp;rdquo;部分）</target>
        </trans-unit>
        <trans-unit id="3027f8dce56af2e1b89a3dcdf3f1ecf46fe576f2" translate="yes" xml:space="preserve">
          <source>If there is no English translation for the post, the untranslated post &lt;code&gt;title&lt;/code&gt; will be returned and &lt;code&gt;summary&lt;/code&gt; will be &lt;code&gt;nil&lt;/code&gt;. If there is, both &lt;code&gt;title&lt;/code&gt; and &lt;code&gt;summary&lt;/code&gt; will be the value from &lt;code&gt;Post.Translation&lt;/code&gt;.</source>
          <target state="translated">如果该帖子没有英文翻译，则将返回未翻译的帖子 &lt;code&gt;title&lt;/code&gt; ， &lt;code&gt;summary&lt;/code&gt; 将为 &lt;code&gt;nil&lt;/code&gt; 。如果存在，则 &lt;code&gt;title&lt;/code&gt; 和 &lt;code&gt;summary&lt;/code&gt; 都将是 &lt;code&gt;Post.Translation&lt;/code&gt; 中的值。</target>
        </trans-unit>
        <trans-unit id="1a1a377354e3a0de11df4acec5746a31c120d5d3" translate="yes" xml:space="preserve">
          <source>If there is no such row, instead return default (which must be of the same type as value). Both offset and default are evaluated with respect to the current row. If omitted, offset defaults to 1 and default to &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">如果没有这样的行，则返回default（必须与value具有相同的类型）。偏移量和默认值都针对当前行进行评估。如果省略，则offset默认为1，默认为 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="71d83351b5a78845c987b433bc2606bd08dbd349" translate="yes" xml:space="preserve">
          <source>If we again visit &lt;code&gt;/hello/Frank&lt;/code&gt; in the browser, we should see a block of JSON with the key &lt;code&gt;id&lt;/code&gt; mapped to the string &lt;code&gt;&quot;Frank&quot;&lt;/code&gt;.</source>
          <target state="translated">如果再次在浏览器中访问 &lt;code&gt;/hello/Frank&lt;/code&gt; ，我们应该看到一个JSON块，其键 &lt;code&gt;id&lt;/code&gt; 映射到字符串 &lt;code&gt;&quot;Frank&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a55899f5bba3bae6ddb4b8c3a53a4536e1c0110c" translate="yes" xml:space="preserve">
          <source>If we also have a requirement for the maximum length that a bio can have, we can simply add another validation.</source>
          <target state="translated">如果我们对生物的最大长度也有要求,我们可以简单地添加另一个验证。</target>
        </trans-unit>
        <trans-unit id="c43f96c979a225b950bb4dfa9a208756fcb9cd93" translate="yes" xml:space="preserve">
          <source>If we are about to create a new application, configuring our application to use MySQL is easy. We can simply pass the &lt;code&gt;--database mysql&lt;/code&gt; flag to &lt;code&gt;phx.new&lt;/code&gt; and everything will be configured correctly.</source>
          <target state="translated">如果我们要创建一个新应用程序，则配置我们的应用程序以使用MySQL很容易。我们可以简单地将 &lt;code&gt;--database mysql&lt;/code&gt; 标志传递给 &lt;code&gt;phx.new&lt;/code&gt; ，一切都将正确配置。</target>
        </trans-unit>
        <trans-unit id="fcbca676064b2672228b8d404db61ea01e7b418d" translate="yes" xml:space="preserve">
          <source>If we are terminating because the client left, the reason will be &lt;code&gt;{:shutdown, :left}&lt;/code&gt;. Similarly, if we are terminating because the client connection was closed, the reason will be &lt;code&gt;{:shutdown, :closed}&lt;/code&gt;.</source>
          <target state="translated">如果我们由于客户离开而终止，原因将是 &lt;code&gt;{:shutdown, :left}&lt;/code&gt; 。同样，如果由于客户端连接已关闭而终止，则原因将是 &lt;code&gt;{:shutdown, :closed}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9f294c1cc2eca5e08e950254d2b15770ecc60ce6" translate="yes" xml:space="preserve">
          <source>If we care to, we can open up our developer tools, click on the network tab, and visit our root route again. We see two main requests for this page - a get to &lt;code&gt;/&lt;/code&gt; with a status of &lt;code&gt;302&lt;/code&gt;, and a get to &lt;code&gt;/redirect_test&lt;/code&gt; with a status of &lt;code&gt;200&lt;/code&gt;.</source>
          <target state="translated">如果需要的话，我们可以打开我们的开发人员工具，单击&amp;ldquo;网络&amp;rdquo;选项卡，然后再次访问我们的根路径。我们看到此页面的两个主要请求-进入 &lt;code&gt;/&lt;/code&gt; 的状态为 &lt;code&gt;302&lt;/code&gt; 和进入 &lt;code&gt;/redirect_test&lt;/code&gt; 的状态为 &lt;code&gt;200&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3ef5847801c77dfd9829f943c4a44ef415cbf4af" translate="yes" xml:space="preserve">
          <source>If we choose not to have Phoenix install our dependencies when we generate a new application, the &lt;a href=&quot;mix.tasks.phx.new&quot;&gt;&lt;code&gt;mix phx.new&lt;/code&gt;&lt;/a&gt; task will prompt us to take the necessary steps when we do want to install them.</source>
          <target state="translated">如果我们选择在生成新应用程序时不让Phoenix安装依赖项，那么&lt;a href=&quot;mix.tasks.phx.new&quot;&gt; &lt;code&gt;mix phx.new&lt;/code&gt; &lt;/a&gt;任务将提示我们在确实要安装依赖项时采取必要的步骤。</target>
        </trans-unit>
        <trans-unit id="083bd2611232c5afdab8b58c40dae911b3992cc4" translate="yes" xml:space="preserve">
          <source>If we do duplicate a route, we'll get this familiar warning.</source>
          <target state="translated">如果我们真的重复了一条路线,我们会得到这个熟悉的警告。</target>
        </trans-unit>
        <trans-unit id="18c2a428049c971561e33683903cb91fda071a38" translate="yes" xml:space="preserve">
          <source>If we don't feel that we need all of these routes, we can be selective using the &lt;code&gt;:only&lt;/code&gt; and &lt;code&gt;:except&lt;/code&gt; options to filter certain actions.</source>
          <target state="translated">如果我们不需要所有这些路由，则可以使用 &lt;code&gt;:only&lt;/code&gt; 和 &lt;code&gt;:except&lt;/code&gt; 选项来选择性地过滤某些操作。</target>
        </trans-unit>
        <trans-unit id="b148b617e87c3d7cf1bf0c454fb60e53b8088cca" translate="yes" xml:space="preserve">
          <source>If we don't have any static assets, or we want to use another build tool, we can pass the &lt;code&gt;--no-webpack&lt;/code&gt; flag when creating a new application and node won't be required at all.</source>
          <target state="translated">如果我们没有任何静态资产，或者想使用其他构建工具，则可以在创建新应用程序时传递 &lt;code&gt;--no-webpack&lt;/code&gt; 标志，并且根本不需要节点。</target>
        </trans-unit>
        <trans-unit id="6ce90215702773251bdd42373866333197e1b5cb" translate="yes" xml:space="preserve">
          <source>If we don't need a complete HTML/JSON resource and are not interested in generating or altering a context we can use the &lt;a href=&quot;mix.tasks.phx.gen.schema&quot;&gt;&lt;code&gt;mix phx.gen.schema&lt;/code&gt;&lt;/a&gt; task. It will generate a schema, and a migration.</source>
          <target state="translated">如果我们不需要完整的HTML / JSON资源并且对生成或更改上下文不感兴趣，则可以使用&lt;a href=&quot;mix.tasks.phx.gen.schema&quot;&gt; &lt;code&gt;mix phx.gen.schema&lt;/code&gt; &lt;/a&gt;任务。它将生成一个架构，并进行迁移。</target>
        </trans-unit>
        <trans-unit id="391120460ffbf26e5eb0e6249f59b60800a1272f" translate="yes" xml:space="preserve">
          <source>If we don't need a complete HTML/JSON resource and instead are only interested in a context, we can use the &lt;a href=&quot;mix.tasks.phx.gen.context&quot;&gt;&lt;code&gt;mix phx.gen.context&lt;/code&gt;&lt;/a&gt; task. It will generate a context, a schema, a migration and a test case.</source>
          <target state="translated">如果我们不需要完整的HTML / JSON资源，而只对上下文感兴趣，则可以使用&lt;a href=&quot;mix.tasks.phx.gen.context&quot;&gt; &lt;code&gt;mix phx.gen.context&lt;/code&gt; &lt;/a&gt;任务。它将生成一个上下文，一个模式，一个迁移和一个测试用例。</target>
        </trans-unit>
        <trans-unit id="0325343ecff8ab2b1c281d1f5eb03e5e5a1f542c" translate="yes" xml:space="preserve">
          <source>If we don't specify a router for this task, it will default to the router Phoenix generated for us.</source>
          <target state="translated">如果我们没有为这个任务指定路由器,它将默认为Phoenix为我们生成的路由器。</target>
        </trans-unit>
        <trans-unit id="2bbc243df3c98e3ec94e3d2cceb1fad20c911551" translate="yes" xml:space="preserve">
          <source>If we don't want to create a context or schema for our resource we can use the &lt;code&gt;--no-context&lt;/code&gt; flag. Note that this still requires a context module name as a parameter.</source>
          <target state="translated">如果我们不想为资源创建上下文或架构，则可以使用 &lt;code&gt;--no-context&lt;/code&gt; 标志。请注意，这仍然需要上下文模块名称作为参数。</target>
        </trans-unit>
        <trans-unit id="202b483bde361859fe3d989c4fc41024ae857693" translate="yes" xml:space="preserve">
          <source>If we follow the &quot;Back&quot; link, we get a list of all users, which should contain the one we just created. Likewise, we can update this record or delete it. Now that we've seen how it works in the browser, it's time to take a look at the generated code.</source>
          <target state="translated">如果我们按照 &quot;返回 &quot;的链接,我们会得到一个所有用户的列表,其中应该包含我们刚刚创建的用户。同样,我们也可以更新这条记录或者删除它。现在我们已经看到了它在浏览器中的工作原理,是时候看看生成的代码了。</target>
        </trans-unit>
        <trans-unit id="e8cdc4c30930a9f92ef3229c041981125e1295ee" translate="yes" xml:space="preserve">
          <source>If we go to &lt;a href=&quot;http://localhost:4000/?_format=text&quot;&gt;&lt;code&gt;http://localhost:4000/?_format=text&lt;/code&gt;&lt;/a&gt;, we will see &quot;OMG, this is actually some text.&quot;.</source>
          <target state="translated">如果转到&lt;a href=&quot;http://localhost:4000/?_format=text&quot;&gt; &lt;code&gt;http://localhost:4000/?_format=text&lt;/code&gt; &lt;/a&gt;，我们将看到&amp;ldquo; OMG，这实际上是一些文本。&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="3cbeea3cdf6c8b4aae44fc28787ce47be0b89ac2" translate="yes" xml:space="preserve">
          <source>If we had aliased the &lt;code&gt;Helpers&lt;/code&gt; module as before (it is only automatically aliased for views, templates and controllers, in this case, since we're inside &lt;code&gt;iex&lt;/code&gt; we need to do it ourselves), we could instead do:</source>
          <target state="translated">如果我们像以前一样使用了 &lt;code&gt;Helpers&lt;/code&gt; 模块的别名（在这种情况下，它仅自动为视图，模板和控制器提供别名），因为我们位于 &lt;code&gt;iex&lt;/code&gt; 内部，因此我们需要自己进行处理），我们可以改为：</target>
        </trans-unit>
        <trans-unit id="0dd17028a95f476ab737ed8720e1d0211a3a7561" translate="yes" xml:space="preserve">
          <source>If we happen to have another repo that we want to drop the database for, we can specify it with the &lt;code&gt;-r&lt;/code&gt; flag.</source>
          <target state="translated">如果碰巧有另一个要删除数据库的存储库，则可以使用 &lt;code&gt;-r&lt;/code&gt; 标志指定它。</target>
        </trans-unit>
        <trans-unit id="0e7e68839f0a87f7d3b692b54aa39ae82f91218c" translate="yes" xml:space="preserve">
          <source>If we have an existing application, all we need to do is switch adapters and make some small configuration changes.</source>
          <target state="translated">如果我们有一个现有的应用程序,我们需要做的是切换适配器,并进行一些小的配置更改。</target>
        </trans-unit>
        <trans-unit id="658d3ae57e71f3341641eb3949711018592d2d1b" translate="yes" xml:space="preserve">
          <source>If we have an existing configuration block for our &lt;code&gt;HelloPhoenix.Repo&lt;/code&gt;, we can simply change the values to match our new ones. You also need to configure the correct values in the &lt;code&gt;config/test.exs&lt;/code&gt; and &lt;code&gt;config/prod.secret.exs&lt;/code&gt; files as well.</source>
          <target state="translated">如果我们已有 &lt;code&gt;HelloPhoenix.Repo&lt;/code&gt; 的配置块，则只需更改值以匹配新值即可。您还需要在 &lt;code&gt;config/test.exs&lt;/code&gt; 和 &lt;code&gt;config/prod.secret.exs&lt;/code&gt; 文件中配置正确的值。</target>
        </trans-unit>
        <trans-unit id="963fb6aba8a7d7a559054bec03ba9d17da20b6ff" translate="yes" xml:space="preserve">
          <source>If we have just installed Elixir for the first time, we will need to install the Hex package manager as well. Hex is necessary to get a Phoenix app running (by installing dependencies) and to install any extra dependencies we might need along the way.</source>
          <target state="translated">如果我们是第一次安装Elixir,我们还需要安装Hex包管理器。Hex对于让Phoenix应用运行(通过安装依赖关系)以及安装我们可能需要的任何额外的依赖关系是必要的。</target>
        </trans-unit>
        <trans-unit id="5daa84ed51f538f1246f7583c53daad14892bab5" translate="yes" xml:space="preserve">
          <source>If we log in to our database server, and connect to our &lt;code&gt;hello_dev&lt;/code&gt; database, we should see our &lt;code&gt;users&lt;/code&gt; table. Ecto assumes that we want an integer column called &lt;code&gt;id&lt;/code&gt; as our primary key, so we should see a sequence generated for that as well.</source>
          <target state="translated">如果我们登录到数据库服务器并连接到 &lt;code&gt;hello_dev&lt;/code&gt; 数据库，则应该看到 &lt;code&gt;users&lt;/code&gt; 表。Ecto假定我们想要一个称为 &lt;code&gt;id&lt;/code&gt; 的整数列作为主键，因此我们也应该看到为此生成的序列。</target>
        </trans-unit>
        <trans-unit id="0ad55a2d89bb2b694326401b2e1b3ac0d3a25512" translate="yes" xml:space="preserve">
          <source>If we name our repo &lt;code&gt;OurCustom.Repo&lt;/code&gt;, this task will create it here &lt;code&gt;lib/our_custom/repo.ex&lt;/code&gt;.</source>
          <target state="translated">如果我们将 &lt;code&gt;OurCustom.Repo&lt;/code&gt; 命名为OurCustom.Repo，则此任务将在此处 &lt;code&gt;lib/our_custom/repo.ex&lt;/code&gt; 中创建它。</target>
        </trans-unit>
        <trans-unit id="410aa46a3f58fdfb55c933dc63ac4ff7560f52cf" translate="yes" xml:space="preserve">
          <source>If we need only the rendered string, without the whole tuple, we can use &lt;code&gt;render_to_string/3&lt;/code&gt;.</source>
          <target state="translated">如果只需要渲染的字符串，而不需要整个元组，则可以使用 &lt;code&gt;render_to_string/3&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c67cebfdb55f59c0c40bdafd0841173e71de24d6" translate="yes" xml:space="preserve">
          <source>If we need to pass values into the template when using &lt;code&gt;render&lt;/code&gt;, that's easy. We can pass a keyword like we've seen with &lt;code&gt;messenger: messenger&lt;/code&gt;, or we can use &lt;a href=&quot;../plug/plug.conn#assign/3&quot;&gt;&lt;code&gt;Plug.Conn.assign/3&lt;/code&gt;&lt;/a&gt;, which conveniently returns &lt;code&gt;conn&lt;/code&gt;.</source>
          <target state="translated">如果在使用 &lt;code&gt;render&lt;/code&gt; 时需要将值传递到模板中，那很简单。我们可以像使用 &lt;code&gt;messenger: messenger&lt;/code&gt; 一样传递一个关键字：messenger，也可以使用&lt;a href=&quot;../plug/plug.conn#assign/3&quot;&gt; &lt;code&gt;Plug.Conn.assign/3&lt;/code&gt; &lt;/a&gt;，它方便地返回 &lt;code&gt;conn&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0a0c2ddb5903057e2b6c4bf63e6d7df23b45687f" translate="yes" xml:space="preserve">
          <source>If we open up the &lt;code&gt;User&lt;/code&gt; schema in &lt;code&gt;lib/hello/accounts/user.ex&lt;/code&gt;, it will look immediately familiar:</source>
          <target state="translated">如果我们在 &lt;code&gt;lib/hello/accounts/user.ex&lt;/code&gt; 中打开 &lt;code&gt;User&lt;/code&gt; 模式，将立即看起来很熟悉：</target>
        </trans-unit>
        <trans-unit id="4c00f799ed099e309e29da91ee4bd50186d484b2" translate="yes" xml:space="preserve">
          <source>If we require a &lt;code&gt;CMS.Author&lt;/code&gt; to exist every time an &lt;code&gt;Accounts.User&lt;/code&gt; is created, we have to think carefully where to place this dependency. We know our &lt;code&gt;CMS&lt;/code&gt; context depends on the &lt;code&gt;Accounts&lt;/code&gt; context, but it's important to avoid cyclic dependencies across our contexts. For example, imagine we changed our &lt;code&gt;Accounts.create_user&lt;/code&gt; function to:</source>
          <target state="translated">如果每次创建 &lt;code&gt;Accounts.User&lt;/code&gt; 时都要求存在 &lt;code&gt;CMS.Author&lt;/code&gt; ，则必须仔细考虑将此依赖项放在何处。我们知道 &lt;code&gt;CMS&lt;/code&gt; 上下文取决于 &lt;code&gt;Accounts&lt;/code&gt; 上下文，但重要的是要避免整个上下文之间存在循环依赖性。例如，假设我们将 &lt;code&gt;Accounts.create_user&lt;/code&gt; 函数更改为：</target>
        </trans-unit>
        <trans-unit id="cccbba4146b36292bb913e1fd8ea1a975c343691" translate="yes" xml:space="preserve">
          <source>If we take a look at the migration generated by &lt;code&gt;phx.gen.schema&lt;/code&gt; in &lt;code&gt;priv/repo/migrations&lt;/code&gt;, we'll see that it will add the columns we specified. It will also add timestamp columns for &lt;code&gt;inserted_at&lt;/code&gt; and &lt;code&gt;updated_at&lt;/code&gt; which come from the &lt;code&gt;timestamps/0&lt;/code&gt; function.</source>
          <target state="translated">如果我们看一下 &lt;code&gt;phx.gen.schema&lt;/code&gt; 在 &lt;code&gt;priv/repo/migrations&lt;/code&gt; migrations中生成的迁移，我们会看到它将添加我们指定的列。它还将增加时间戳列 &lt;code&gt;inserted_at&lt;/code&gt; 和 &lt;code&gt;updated_at&lt;/code&gt; 其中来自 &lt;code&gt;timestamps/0&lt;/code&gt; 功能。</target>
        </trans-unit>
        <trans-unit id="fed57a6e9786d7b1c5f997cd519a04906343aa29" translate="yes" xml:space="preserve">
          <source>If we try to cast a user with an email of &quot;example.com&quot;, we should see an error message like the following.</source>
          <target state="translated">如果我们尝试用 &quot;example.com &quot;的电子邮件投递一个用户,我们应该看到一个类似于下面的错误信息。</target>
        </trans-unit>
        <trans-unit id="1ffce6ccf0c01a85d91a8e6ee8f35c6af010a9b1" translate="yes" xml:space="preserve">
          <source>If we wanted to render an xml version of our &lt;code&gt;index&lt;/code&gt; action, we might implement the action like this in &lt;code&gt;lib/hello_web/page_controller.ex&lt;/code&gt;.</source>
          <target state="translated">如果我们要呈现 &lt;code&gt;index&lt;/code&gt; 操作的xml版本，则可以在 &lt;code&gt;lib/hello_web/page_controller.ex&lt;/code&gt; 中实现这样的操作。</target>
        </trans-unit>
        <trans-unit id="091f04a57770ee0cadc0f3ebc7f970845f788a49" translate="yes" xml:space="preserve">
          <source>If we wanted to return some actions for an &lt;code&gt;MyApp.SomethingNotFoundError&lt;/code&gt; we would implement &lt;a href=&quot;../plug/plug.exception&quot;&gt;&lt;code&gt;Plug.Exception&lt;/code&gt;&lt;/a&gt; like this:</source>
          <target state="translated">如果我们想为 &lt;code&gt;MyApp.SomethingNotFoundError&lt;/code&gt; 返回一些动作，我们将实现&lt;a href=&quot;../plug/plug.exception&quot;&gt; &lt;code&gt;Plug.Exception&lt;/code&gt; ,&lt;/a&gt;如下所示：</target>
        </trans-unit>
        <trans-unit id="e3edc855d2066cbc7b5c91623476090fb897ebf1" translate="yes" xml:space="preserve">
          <source>If we wanted to supply a status of 404 for an &lt;code&gt;MyApp.SomethingNotFoundError&lt;/code&gt;, we could do it by defining an implementation for the &lt;a href=&quot;../plug/plug.exception&quot;&gt;&lt;code&gt;Plug.Exception&lt;/code&gt;&lt;/a&gt; protocol like this:</source>
          <target state="translated">如果我们想为 &lt;code&gt;MyApp.SomethingNotFoundError&lt;/code&gt; 提供404状态，我们可以通过定义&lt;a href=&quot;../plug/plug.exception&quot;&gt; &lt;code&gt;Plug.Exception&lt;/code&gt; &lt;/a&gt;协议的实现来做到这一点，如下所示：</target>
        </trans-unit>
        <trans-unit id="87783d963f44ae589c50340ce6d86a8678d3af09" translate="yes" xml:space="preserve">
          <source>If we would like to be really specific about the content type, we can use &lt;code&gt;put_resp_content_type/2&lt;/code&gt; in conjunction with &lt;code&gt;send_resp/3&lt;/code&gt;.</source>
          <target state="translated">如果我们真的想具体说明内容类型，可以将 &lt;code&gt;put_resp_content_type/2&lt;/code&gt; 与 &lt;code&gt;send_resp/3&lt;/code&gt; 结合使用。</target>
        </trans-unit>
        <trans-unit id="4f54692a2228f2c183323a64714165cbc33696b0" translate="yes" xml:space="preserve">
          <source>If we would like to start our application and also have an &lt;code&gt;iex&lt;/code&gt; session open to it, we can run the mix task within &lt;code&gt;iex&lt;/code&gt; like this, &lt;code&gt;iex -S mix phx.server&lt;/code&gt;.</source>
          <target state="translated">如果我们想启动我们的应用程序并且也要打开一个 &lt;code&gt;iex&lt;/code&gt; 会话，我们可以在 &lt;code&gt;iex&lt;/code&gt; 中运行混合任务，例如 &lt;code&gt;iex -S mix phx.server&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f56a37255e0b43c2392f533494036f18e8e066b4" translate="yes" xml:space="preserve">
          <source>If you access these fields before fetching them, they will be returned as &lt;a href=&quot;plug.conn.unfetched&quot;&gt;&lt;code&gt;Plug.Conn.Unfetched&lt;/code&gt;&lt;/a&gt; structs.</source>
          <target state="translated">如果在获取它们之前访问这些字段，它们将作为&lt;a href=&quot;plug.conn.unfetched&quot;&gt; &lt;code&gt;Plug.Conn.Unfetched&lt;/code&gt; &lt;/a&gt;结构返回。</target>
        </trans-unit>
        <trans-unit id="b68cb6ad948ac353881b8951cfd579c0c0ee1df4" translate="yes" xml:space="preserve">
          <source>If you already have a model, the generated model can be skipped with &lt;code&gt;--no-model&lt;/code&gt;. Read the documentation for &lt;code&gt;phoenix.gen.model&lt;/code&gt; for more information on attributes and namespaced resources.</source>
          <target state="translated">如果您已有模型，则可以使用 &lt;code&gt;--no-model&lt;/code&gt; 跳过生成的模型。阅读 &lt;code&gt;phoenix.gen.model&lt;/code&gt; 的文档，以获取有关属性和命名空间资源的更多信息。</target>
        </trans-unit>
        <trans-unit id="7ff739bec2c4393b5a6029990ea9ff518a68f23c" translate="yes" xml:space="preserve">
          <source>If you also want to send the response, use &lt;a href=&quot;#send_resp/1&quot;&gt;&lt;code&gt;send_resp/1&lt;/code&gt;&lt;/a&gt; after this or use &lt;a href=&quot;#send_resp/3&quot;&gt;&lt;code&gt;send_resp/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果您还想发送响应，请在此之后使用&lt;a href=&quot;#send_resp/1&quot;&gt; &lt;code&gt;send_resp/1&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#send_resp/3&quot;&gt; &lt;code&gt;send_resp/3&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="87f449e6752144346e8d0a47354146bcb5ebd1b4" translate="yes" xml:space="preserve">
          <source>If you are already familiar with Elixir, great! If not, there are a number of places to learn. The &lt;a href=&quot;https://elixir-lang.org/getting-started/introduction.html&quot;&gt;Elixir guides&lt;/a&gt; and the &lt;a href=&quot;https://elixir-lang.org/learning.html&quot;&gt;Elixir learning resources page&lt;/a&gt; are two great places to start.</source>
          <target state="translated">如果您已经熟悉Elixir，那就太好了！如果没有，有很多地方可以学习。该&lt;a href=&quot;https://elixir-lang.org/getting-started/introduction.html&quot;&gt;药剂引导&lt;/a&gt;和&lt;a href=&quot;https://elixir-lang.org/learning.html&quot;&gt;药剂学习资源页面&lt;/a&gt;是两个伟大的地方开始。</target>
        </trans-unit>
        <trans-unit id="a15c68af7f32e113d1ad81becc24e17ccf8d3c73" translate="yes" xml:space="preserve">
          <source>If you are coming from an older version of Phoenix, install the &lt;code&gt;:telemetry_metrics&lt;/code&gt; and &lt;code&gt;:telemetry_poller&lt;/code&gt; packages:</source>
          <target state="translated">如果您来自旧版本的Phoenix，请安装 &lt;code&gt;:telemetry_metrics&lt;/code&gt; 和 &lt;code&gt;:telemetry_poller&lt;/code&gt; 软件包：</target>
        </trans-unit>
        <trans-unit id="195b289a7ef348736fb993f011aeccf45570b4ce" translate="yes" xml:space="preserve">
          <source>If you are comparing the username and password with existing strings, do not use &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#==/2&quot;&gt;&lt;code&gt;==/2&lt;/code&gt;&lt;/a&gt;. Use &lt;a href=&quot;https://hexdocs.pm/plug_crypto/Plug.Crypto.html#secure_compare/2&quot;&gt;&lt;code&gt;Plug.Crypto.secure_compare/2&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">如果将用户名和密码与现有字符串进行比较，请不要使用&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#==/2&quot;&gt; &lt;code&gt;==/2&lt;/code&gt; &lt;/a&gt;。请改用&lt;a href=&quot;https://hexdocs.pm/plug_crypto/Plug.Crypto.html#secure_compare/2&quot;&gt; &lt;code&gt;Plug.Crypto.secure_compare/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="660ef0380c716ac22c9348212079d101dfdf7227" translate="yes" xml:space="preserve">
          <source>If you are pushing events from a hook to a component, then you must pass an &lt;code&gt;element&lt;/code&gt;, created with &lt;a href=&quot;#element/3&quot;&gt;&lt;code&gt;element/3&lt;/code&gt;&lt;/a&gt;, as first argument and it must point to a single element on the page with a &lt;code&gt;phx-target&lt;/code&gt; attribute in it:</source>
          <target state="translated">如果要从一个钩到组件推事件，则必须通过一个 &lt;code&gt;element&lt;/code&gt; ，以创建&lt;a href=&quot;#element/3&quot;&gt; &lt;code&gt;element/3&lt;/code&gt; &lt;/a&gt;，作为第一个参数，它必须指向与在页面上的单个元件 &lt;code&gt;phx-target&lt;/code&gt; 在它的属性：</target>
        </trans-unit>
        <trans-unit id="c1445ed0a8505a52f1fc2ab343b225750d1c7d54" translate="yes" xml:space="preserve">
          <source>If you are seeing this error, you should check if you are listing the desired formats in your &lt;code&gt;:accepts&lt;/code&gt; plug or if you are setting the proper accept header in the client. The exception contains the acceptable mime types in the &lt;code&gt;accepts&lt;/code&gt; field.</source>
          <target state="translated">如果看到此错误，则应检查是否在 &lt;code&gt;:accepts&lt;/code&gt; 插件中列出了所需的格式，或者是否在客户端中设置了正确的accept标头。异常在 &lt;code&gt;accepts&lt;/code&gt; 字段中包含可接受的mime类型。</target>
        </trans-unit>
        <trans-unit id="8befb119931680b815f371783bc72db7f010ea28" translate="yes" xml:space="preserve">
          <source>If you are seeing this error, you should handle the error and surface it to the end user. It means that there is a parameter missing from the request.</source>
          <target state="translated">如果你看到这个错误,你应该处理这个错误,并把它浮现给最终用户。这意味着请求中缺少一个参数。</target>
        </trans-unit>
        <trans-unit id="8281d3b702b25fc319af701ce0fe42f100d16669" translate="yes" xml:space="preserve">
          <source>If you are sending data to a full URI, such as &lt;code&gt;//subdomain.host.com/path&lt;/code&gt; or &lt;code&gt;//external.com/path&lt;/code&gt;, instead of a simple path such as &lt;code&gt;/path&lt;/code&gt;, you may want to consider using &lt;a href=&quot;#get_csrf_token_for/1&quot;&gt;&lt;code&gt;get_csrf_token_for/1&lt;/code&gt;&lt;/a&gt;, as that will encode the host in the CSRF token. Once received, Plug will only consider the CSRF token to be valid if the &lt;code&gt;host&lt;/code&gt; encoded in the token is the same as the one in &lt;code&gt;conn.host&lt;/code&gt;.</source>
          <target state="translated">如果要将数据发送到完整的URI（例如 &lt;code&gt;//subdomain.host.com/path&lt;/code&gt; 或 &lt;code&gt;//external.com/path&lt;/code&gt; )，而不是简单的路径（例如 &lt;code&gt;/path&lt;/code&gt; )，则可以考虑使用&lt;a href=&quot;#get_csrf_token_for/1&quot;&gt; &lt;code&gt;get_csrf_token_for/1&lt;/code&gt; &lt;/a&gt;，因为它将以CSRF令牌对主机进行编码。一旦收到，Plug仅在令牌中编码的 &lt;code&gt;host&lt;/code&gt; 与 &lt;code&gt;conn.host&lt;/code&gt; 中的主机相同时才认为CSRF令牌有效。</target>
        </trans-unit>
        <trans-unit id="2860b8a98014af24457d97de2b8635d54397f121" translate="yes" xml:space="preserve">
          <source>If you are trying to debug transaction-related code while using &lt;code&gt;Ecto.Adapters.SQL.Sandbox&lt;/code&gt;, it may be more helpful to configure the database to log all statements and consult those logs.</source>
          <target state="translated">如果您尝试使用 &lt;code&gt;Ecto.Adapters.SQL.Sandbox&lt;/code&gt; 调试与事务相关的代码，将数据库配置为记录所有语句并查阅这些日志可能会更有用。</target>
        </trans-unit>
        <trans-unit id="f57bf68c621982c91acd9cc4e5332c480370b66a" translate="yes" xml:space="preserve">
          <source>If you are using Phoenix v1.5, the layout is automatically set when generating apps with the &lt;code&gt;mix phx.new --live&lt;/code&gt; flag.</source>
          <target state="translated">如果您使用的是Phoenix v1.5，则在使用 &lt;code&gt;mix phx.new --live&lt;/code&gt; 标志生成应用程序时会自动设置布局。</target>
        </trans-unit>
        <trans-unit id="1d8aab708f551e6ce45eaa04e632f244694f2e5f" translate="yes" xml:space="preserve">
          <source>If you are using the &lt;code&gt;Ecto.Adapters.SQL.Sandbox&lt;/code&gt; in tests, note that even though each test is inside a transaction, &lt;code&gt;in_transaction?/0&lt;/code&gt; will only return true inside transactions explicitly created with &lt;code&gt;transaction/2&lt;/code&gt;. This is done so the test environment mimics dev and prod.</source>
          <target state="translated">如果在测试中使用 &lt;code&gt;Ecto.Adapters.SQL.Sandbox&lt;/code&gt; ，请注意，即使每个测试都在事务内部， &lt;code&gt;in_transaction?/0&lt;/code&gt; 只会在由 &lt;code&gt;transaction/2&lt;/code&gt; 显式创建的事务中返回true 。这样做是为了使测试环境模仿dev和prod。</target>
        </trans-unit>
        <trans-unit id="942638ba1572b805045a6efb9c529e7e1a50d20b" translate="yes" xml:space="preserve">
          <source>If you attempt to remove associated &lt;code&gt;many_to_many&lt;/code&gt; data, &lt;strong&gt;Ecto will always remove data from the join schema and never from the target associations&lt;/strong&gt; be it by setting &lt;code&gt;:on_replace&lt;/code&gt; to &lt;code&gt;:delete&lt;/code&gt;, &lt;code&gt;:on_delete&lt;/code&gt; to &lt;code&gt;:delete_all&lt;/code&gt; or by using changeset functions such as &lt;a href=&quot;ecto.changeset#put_assoc/3&quot;&gt;&lt;code&gt;Ecto.Changeset.put_assoc/3&lt;/code&gt;&lt;/a&gt;. For example, if a &lt;code&gt;Post&lt;/code&gt; has a many to many relationship with &lt;code&gt;Tag&lt;/code&gt;, setting &lt;code&gt;:on_delete&lt;/code&gt; to &lt;code&gt;:delete_all&lt;/code&gt; will only delete entries from the &quot;posts_tags&quot; table in case &lt;code&gt;Post&lt;/code&gt; is deleted.</source>
          <target state="translated">如果尝试删除关联的 &lt;code&gt;many_to_many&lt;/code&gt; 数据，则&lt;strong&gt;Ecto始终会从联接模式中删除数据，而永远不会从目标关联中删除数据，&lt;/strong&gt;无论是通过将 &lt;code&gt;:on_replace&lt;/code&gt; 设置为 &lt;code&gt;:delete&lt;/code&gt; ， &lt;code&gt;:on_delete&lt;/code&gt; 设置为 &lt;code&gt;:delete_all&lt;/code&gt; 还是使用更改集功能（例如&lt;a href=&quot;ecto.changeset#put_assoc/3&quot;&gt; &lt;code&gt;Ecto.Changeset.put_assoc/3&lt;/code&gt; &lt;/a&gt;。例如，如果一个 &lt;code&gt;Post&lt;/code&gt; 有许多与许多关系 &lt;code&gt;Tag&lt;/code&gt; ，设置 &lt;code&gt;:on_delete&lt;/code&gt; 到 &lt;code&gt;:delete_all&lt;/code&gt; 将从&amp;ldquo;posts_tags&amp;rdquo;表只能删除条目的情况下， &lt;code&gt;Post&lt;/code&gt; 被删除。</target>
        </trans-unit>
        <trans-unit id="2c3cbaa656dba938c685add2656722d0e125f277" translate="yes" xml:space="preserve">
          <source>If you attempt to remove associated &lt;code&gt;many_to_many&lt;/code&gt; data, &lt;strong&gt;Ecto will always remove data from the join schema and never from the target associations&lt;/strong&gt; be it by setting &lt;code&gt;:on_replace&lt;/code&gt; to &lt;code&gt;:delete&lt;/code&gt;, &lt;code&gt;:on_delete&lt;/code&gt; to &lt;code&gt;:delete_all&lt;/code&gt; or by using changeset functions such as &lt;a href=&quot;ecto.changeset#put_assoc/3&quot;&gt;&lt;code&gt;Ecto.Changeset.put_assoc/3&lt;/code&gt;&lt;/a&gt;. For example, if a &lt;code&gt;Post&lt;/code&gt; has a many to many relationship with &lt;code&gt;Tag&lt;/code&gt;, setting &lt;code&gt;:on_delete&lt;/code&gt; to &lt;code&gt;:delete_all&lt;/code&gt; will only delete entries from the &amp;ldquo;posts_tags&amp;rdquo; table in case &lt;code&gt;Post&lt;/code&gt; is deleted.</source>
          <target state="translated">如果您尝试删除关联的 &lt;code&gt;many_to_many&lt;/code&gt; 数据，则&lt;strong&gt;Ecto始终会从联接模式中删除数据，而永远不会从目标关联中删除数据，&lt;/strong&gt;无论是通过将 &lt;code&gt;:on_replace&lt;/code&gt; 设置为 &lt;code&gt;:delete&lt;/code&gt; ， &lt;code&gt;:on_delete&lt;/code&gt; 设置为 &lt;code&gt;:delete_all&lt;/code&gt; 还是使用更改集功能（例如&lt;a href=&quot;ecto.changeset#put_assoc/3&quot;&gt; &lt;code&gt;Ecto.Changeset.put_assoc/3&lt;/code&gt; &lt;/a&gt;。例如，如果一个 &lt;code&gt;Post&lt;/code&gt; 与 &lt;code&gt;Tag&lt;/code&gt; 有多对多的关系，将 &lt;code&gt;:on_delete&lt;/code&gt; 设置为 &lt;code&gt;:delete_all&lt;/code&gt; 只会从&amp;ldquo; posts_tags&amp;rdquo;表中删除条目，以防删除 &lt;code&gt;Post&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="33aeade4ec4114f6d64f05c0e4ded54c69c06049" translate="yes" xml:space="preserve">
          <source>If you attempt to write it as &lt;code&gt;where: p.id in ^subquery(foo)&lt;/code&gt;, Ecto won&amp;rsquo;t accept such query. However, the subquery above can be written as a JOIN, which is supported by Ecto. The final Ecto query will look like this:</source>
          <target state="translated">如果您尝试将其写为以下 &lt;code&gt;where: p.id in ^subquery(foo)&lt;/code&gt; 中的p.id，Ecto将不​​接受此类查询。但是，上面的子查询可以写为JOIN，Ecto支持。最终的Ecto查询将如下所示：</target>
        </trans-unit>
        <trans-unit id="8aa7e8b7dfaa8e37915423085e7692433a23800a" translate="yes" xml:space="preserve">
          <source>If you decide to include the live-reload websocket, you should disable it when building for production.</source>
          <target state="translated">如果您决定包含实时重载 websocket,您应该在为生产构建时禁用它。</target>
        </trans-unit>
        <trans-unit id="de03b9d15dfe67c307158582293c4bcac372860e" translate="yes" xml:space="preserve">
          <source>If you do that, because &lt;a href=&quot;phoenix.liveview#c:mount/3&quot;&gt;&lt;code&gt;mount/3&lt;/code&gt;&lt;/a&gt; is called once and &lt;a href=&quot;phoenix.liveview#c:handle_params/3&quot;&gt;&lt;code&gt;handle_params/3&lt;/code&gt;&lt;/a&gt; multiple times, the &quot;post_id&quot; read on mount can get out of sync with the one in &lt;a href=&quot;phoenix.liveview#c:handle_params/3&quot;&gt;&lt;code&gt;handle_params/3&lt;/code&gt;&lt;/a&gt;. So once a parameter is read on mount, it should not be read elsewhere. Instead, do this:</source>
          <target state="translated">如果这样做，由于一次调用&lt;a href=&quot;phoenix.liveview#c:mount/3&quot;&gt; &lt;code&gt;mount/3&lt;/code&gt; &lt;/a&gt;并&lt;a href=&quot;phoenix.liveview#c:handle_params/3&quot;&gt; &lt;code&gt;handle_params/3&lt;/code&gt; &lt;/a&gt;调用handle_params / 3，因此在mount上读取的&amp;ldquo; post_id&amp;rdquo;可能与&lt;a href=&quot;phoenix.liveview#c:handle_params/3&quot;&gt; &lt;code&gt;handle_params/3&lt;/code&gt; &lt;/a&gt;中的那个不同步。因此，一旦在挂载上读取了参数，就不应在其他位置读取该参数。相反，请执行以下操作：</target>
        </trans-unit>
        <trans-unit id="09cb3a84985c7f8fa4e8edcaba166f48f945bf96" translate="yes" xml:space="preserve">
          <source>If you don't have any Ecto schema pointing to the CTE table, you can pass a tuple with the CTE table name as first element and an Ecto schema as second element. This will cast the result rows to Ecto structs as long as the Ecto schema maps to the same fields in the CTE table:</source>
          <target state="translated">如果你没有任何指向CTE表的Ecto模式,你可以传递一个以CTE表名为第一元素,以Ecto模式为第二元素的元组。只要Ecto模式映射到CTE表中的相同字段,就会将结果行投向Ecto结构。</target>
        </trans-unit>
        <trans-unit id="ae9c05c4fa4c6e476b09d8bdf327b4c5f082461f" translate="yes" xml:space="preserve">
          <source>If you find yourself in similar situations where you feel your use case is requiring you to create circular dependencies across contexts, it's a sign you need a new context in the system to handle these application requirements. In our case, what we really want is an interface that handles all requirements when a user is created or registers in our application. To handle this, we could create a &lt;code&gt;UserRegistration&lt;/code&gt; context, which calls into both the &lt;code&gt;Accounts&lt;/code&gt; and &lt;code&gt;CMS&lt;/code&gt; APIs to create a user, then associate a CMS author. Not only would this allow our Accounts to remain as isolated as possible, it gives us a clear, obvious API to handle &lt;code&gt;UserRegistration&lt;/code&gt; needs in the system. If you take this approach, you can also use tools like &lt;code&gt;Ecto.Multi&lt;/code&gt; to handle transactions across different context operations without deeply coupling the internal database calls. Part of our &lt;code&gt;UserRegistration&lt;/code&gt; API could look something like this:</source>
          <target state="translated">如果您发现自己处在类似的情况下，即您认为用例需要您跨上下文创建循环依赖关系，则表明您需要在系统中使用新的上下文来处理这些应用程序需求。在我们的案例中，我们真正想要的是一个接口，该接口可在创建用户或在我们的应用程序中注册时处理所有要求。为了解决这个问题，我们可以创建一个 &lt;code&gt;UserRegistration&lt;/code&gt; 上下文，该上下文同时调用 &lt;code&gt;Accounts&lt;/code&gt; 和 &lt;code&gt;CMS&lt;/code&gt; API来创建用户，然后关联CMS作者。这不仅可以使我们的帐户保持尽可能的隔离，还为我们提供了清晰，明显的API来处理系统中的 &lt;code&gt;UserRegistration&lt;/code&gt; 需求。如果您采用这种方法，还可以使用以下工具 &lt;code&gt;Ecto.Multi&lt;/code&gt; 用于处理不同上下文操作之间的事务，而无需深入耦合内部数据库调用。我们的 &lt;code&gt;UserRegistration&lt;/code&gt; API的一部分可能看起来像这样：</target>
        </trans-unit>
        <trans-unit id="6574eccc770115f525bad9e622976b6b343b2538" translate="yes" xml:space="preserve">
          <source>If you followed the &lt;a href=&quot;installation&quot;&gt;Installation Guide&lt;/a&gt; and opted to add &lt;code&gt;{:cowboy, &quot;~&amp;gt; 2.7.0&quot;}&lt;/code&gt; to your mix.exs, go ahead and do that now and run &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Deps.Get.html&quot;&gt;&lt;code&gt;mix deps.get&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果您遵循《&lt;a href=&quot;installation&quot;&gt;安装指南》&lt;/a&gt;并选择将 &lt;code&gt;{:cowboy, &quot;~&amp;gt; 2.7.0&quot;}&lt;/code&gt; 到您的mix.exs中，请立即进行操作并运行&lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Deps.Get.html&quot;&gt; &lt;code&gt;mix deps.get&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5a9d40fe35c9851f255cc70728d792053cc95002" translate="yes" xml:space="preserve">
          <source>If you had previously installed &lt;code&gt;phoenix_live_view&lt;/code&gt; and want to get the latest javascript, then force an install with:</source>
          <target state="translated">如果您以前安装了 &lt;code&gt;phoenix_live_view&lt;/code&gt; 并想获取最新的javascript，请使用以下命令强制安装：</target>
        </trans-unit>
        <trans-unit id="415aa01085c0f6d5805f0753fe7636a79914ccaf" translate="yes" xml:space="preserve">
          <source>If you have a session but the CSRF state was not loaded into the current process, you can dump the state from the session:</source>
          <target state="translated">如果你有一个会话,但CSRF状态没有加载到当前进程中,你可以从该会话中转储状态。</target>
        </trans-unit>
        <trans-unit id="1e22a5ad3894018fe1345caf74da853417ec2369" translate="yes" xml:space="preserve">
          <source>If you have a single username and password, you can use the &lt;a href=&quot;#basic_auth/2&quot;&gt;&lt;code&gt;basic_auth/2&lt;/code&gt;&lt;/a&gt; plug:</source>
          <target state="translated">如果您只有一个用户名和密码，则可以使用&lt;a href=&quot;#basic_auth/2&quot;&gt; &lt;code&gt;basic_auth/2&lt;/code&gt; &lt;/a&gt;插件：</target>
        </trans-unit>
        <trans-unit id="cce78534925c37d789d5976c765183ee7b5d0b56" translate="yes" xml:space="preserve">
          <source>If you keep components mostly as an application concern with only the necessary assigns, it is unlikely you will run into issues related to stateful components.</source>
          <target state="translated">如果你把组件主要作为一个应用关注,只进行必要的赋值,那么你不太可能会遇到与有状态组件相关的问题。</target>
        </trans-unit>
        <trans-unit id="a8c0fdbca7cff696f9dab2f2e658e9f4fc49ebd8" translate="yes" xml:space="preserve">
          <source>If you need an escape hatch, Ecto provides fragments (see &lt;a href=&quot;ecto.query.api#fragment/1&quot;&gt;&lt;code&gt;Ecto.Query.API.fragment/1&lt;/code&gt;&lt;/a&gt;) to inject SQL (and non-SQL) fragments into queries.</source>
          <target state="translated">如果需要逃生舱口，则Ecto提供片段（请参阅&lt;a href=&quot;ecto.query.api#fragment/1&quot;&gt; &lt;code&gt;Ecto.Query.API.fragment/1&lt;/code&gt; &lt;/a&gt;），以将SQL（和非SQL）片段注入查询中。</target>
        </trans-unit>
        <trans-unit id="cf93aee615b214a79ea7379cb001c9b4d45fa541" translate="yes" xml:space="preserve">
          <source>If you need custom metrics and instrumentation in your application, you can utilize the &lt;code&gt;:telemetry&lt;/code&gt; package (&lt;a href=&quot;https://hexdocs.pm/telemetry&quot;&gt;https://hexdocs.pm/telemetry&lt;/a&gt;) just like your favorite frameworks and libraries.</source>
          <target state="translated">如果您在应用程序中需要自定义指标和工具，则可以使用 &lt;code&gt;:telemetry&lt;/code&gt; 包（&lt;a href=&quot;https://hexdocs.pm/telemetry&quot;&gt;https://hexdocs.pm/telemetry&lt;/a&gt;），就像您喜欢的框架和库一样。</target>
        </trans-unit>
        <trans-unit id="43ecb1e3f8dbc11e08115c78cf6e2d60dbd4aefe" translate="yes" xml:space="preserve">
          <source>If you need custom options on the underlying field, you can define the field explicitly and then pass &lt;code&gt;define_field: false&lt;/code&gt; to &lt;code&gt;belongs_to&lt;/code&gt;:</source>
          <target state="translated">如果需要在基础字段上使用自定义选项，则可以显式定义该字段，然后将 &lt;code&gt;define_field: false&lt;/code&gt; 传递给 &lt;code&gt;belongs_to&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="bd51ff6183de690e100505fa4969b12d1551fa2a" translate="yes" xml:space="preserve">
          <source>If you need to dynamically configure how &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Plug.Parsers.MULTIPART&lt;/code&gt;&lt;/a&gt; behave, for example, based on the connection or another system parameter, one option is to create your own parser that wraps it:</source>
          <target state="translated">例如，如果您需要动态配置&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Plug.Parsers.MULTIPART&lt;/code&gt; 的&lt;/a&gt;行为方式，例如基于连接或另一个系统参数，则一个选择是创建自己的解析器来包装它：</target>
        </trans-unit>
        <trans-unit id="109f5082f2f1b912050b16bb98f4693eba354f1f" translate="yes" xml:space="preserve">
          <source>If you need to guarantee the data in the returned struct mirrors the database, you have three options:</source>
          <target state="translated">如果你需要保证返回的结构体中的数据是数据库的镜像,你有三个选项。</target>
        </trans-unit>
        <trans-unit id="2e2431436833d547a4e531dda09290f8abafed68" translate="yes" xml:space="preserve">
          <source>If you need to pass any extra values or metadata, such as the &quot;_target&quot; parameter, you can do so by giving a map under the &lt;code&gt;value&lt;/code&gt; argument.</source>
          <target state="translated">如果您需要传递任何额外的值或元数据，例如&amp;ldquo; _target&amp;rdquo;参数，则可以通过在 &lt;code&gt;value&lt;/code&gt; 参数下提供一个映射来实现。</target>
        </trans-unit>
        <trans-unit id="e668d17ae58bad2b61910c084478c158d0fe3170" translate="yes" xml:space="preserve">
          <source>If you prefer, you can also send a JavaScript script that immediately reloads the page.</source>
          <target state="translated">如果你愿意,你也可以发送一个JavaScript脚本,立即重新加载页面。</target>
        </trans-unit>
        <trans-unit id="1afadb98b6e75520436d2c696ca1b6f38804339a" translate="yes" xml:space="preserve">
          <source>If you visit the Welcome page, you should see the message from the layout.</source>
          <target state="translated">如果你访问欢迎页面,你应该看到布局的信息。</target>
        </trans-unit>
        <trans-unit id="6194c95c25393c1533f24ca690885ddce3de29a4" translate="yes" xml:space="preserve">
          <source>If you want a map with only the selected fields to be returned. For more information, read the docs for &lt;a href=&quot;ecto.query.api#struct/2&quot;&gt;&lt;code&gt;Ecto.Query.API.struct/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;ecto.query.api#map/2&quot;&gt;&lt;code&gt;Ecto.Query.API.map/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果要返回仅包含选定字段的地图。有关更多信息，请阅读&lt;a href=&quot;ecto.query.api#struct/2&quot;&gt; &lt;code&gt;Ecto.Query.API.struct/2&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;ecto.query.api#map/2&quot;&gt; &lt;code&gt;Ecto.Query.API.map/2&lt;/code&gt; &lt;/a&gt;的文档。</target>
        </trans-unit>
        <trans-unit id="b56c7f334ac00fd6eb86d51a4d425fe63a22845f" translate="yes" xml:space="preserve">
          <source>If you want the boolean attribute to be sent as is, you can explicitly convert it to a string before.</source>
          <target state="translated">如果你想让布尔属性按原样发送,你可以在之前明确地将其转换为字符串。</target>
        </trans-unit>
        <trans-unit id="9a8b342259d40c75d399fa621d7ba14972e56c66" translate="yes" xml:space="preserve">
          <source>If you want the latest features, install from GitHub:</source>
          <target state="translated">如果你想要最新的功能,请从GitHub上安装。</target>
        </trans-unit>
        <trans-unit id="71958648bc2ee1d3c516f077771f912b56470ab5" translate="yes" xml:space="preserve">
          <source>If you want to configure the years range:</source>
          <target state="translated">如果你想配置年限范围。</target>
        </trans-unit>
        <trans-unit id="eaaf4a6e48637b0f1ace60064563e26ec60604dd" translate="yes" xml:space="preserve">
          <source>If you want to do so in a case-by-case basis, you can define a custom function that gets the endpoint URI configuration and changes it accordingly. For example, to get the current URL always in HTTPS format:</source>
          <target state="translated">如果你想根据具体情况,可以定义一个自定义函数,获取端点URI配置,并进行相应修改。例如,要获取当前的URL总是HTTPS格式。</target>
        </trans-unit>
        <trans-unit id="3267ec97b69bd134a5f100a8b20b7af9c4d6bdb9" translate="yes" xml:space="preserve">
          <source>If you want to have functions that manipulate the connection without fully implementing the controller, you can import both modules directly instead of &lt;code&gt;use Phoenix.Controller&lt;/code&gt;.</source>
          <target state="translated">如果要具有在不完全实现控制器的情况下操纵连接的功能，则可以直接导入两个模块，而不必 &lt;code&gt;use Phoenix.Controller&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e505240a0d781b16ebb52afdcfed3cf74a91017d" translate="yes" xml:space="preserve">
          <source>If you want to include the seconds field (hidden by default), pass &lt;code&gt;second: []&lt;/code&gt;:</source>
          <target state="translated">如果要包括秒字段（默认情况下是隐藏的），请传递 &lt;code&gt;second: []&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="1ebd7ac9e06dec198b102f467e0d5a2146add7ac" translate="yes" xml:space="preserve">
          <source>If you want to instrument a piece of code, but the endpoint that should instrument it (the one that contains the &lt;a href=&quot;#c:instrument/3&quot;&gt;&lt;code&gt;instrument/3&lt;/code&gt;&lt;/a&gt; macro you want to use) is not known at compile time, only at runtime, you can use the &lt;a href=&quot;phoenix.endpoint#instrument/4&quot;&gt;&lt;code&gt;Phoenix.Endpoint.instrument/4&lt;/code&gt;&lt;/a&gt; macro. Refer to its documentation for more information.</source>
          <target state="translated">如果要检测一段代码，但是应该在其上进行检测的端点（包含要使用的&lt;a href=&quot;#c:instrument/3&quot;&gt; &lt;code&gt;instrument/3&lt;/code&gt; &lt;/a&gt;宏的端点）在编译时未知，只有在运行时才可以使用&lt;a href=&quot;phoenix.endpoint#instrument/4&quot;&gt; &lt;code&gt;Phoenix.Endpoint.instrument/4&lt;/code&gt; &lt;/a&gt;宏。有关更多信息，请参阅其文档。</target>
        </trans-unit>
        <trans-unit id="49cb9f6ec274ce3774fca3bdf01b6ff3edaab5ff" translate="yes" xml:space="preserve">
          <source>If you want to make your new mix task to use your application's infrastructure, you need to make sure the application is started when mix task is being executed. This is particularly useful if you need to access your database from within the mix task. Thankfully, mix makes it really easy for us:</source>
          <target state="translated">如果你想让你的新混合任务使用你的应用程序的基础结构,你需要确保应用程序在混合任务执行时被启动。如果你需要在mix任务中访问你的数据库,这一点尤其有用。值得庆幸的是,mix为我们提供了一个非常简单的方法。</target>
        </trans-unit>
        <trans-unit id="f18f35976119bb4fe304e144acc1ed9a4b56600a" translate="yes" xml:space="preserve">
          <source>If you want to provide your own authentication logic on top of Basic HTTP auth, you can use the low-level functions. As an example, we define &lt;code&gt;:auth&lt;/code&gt; plug that extracts username and password from the request headers, compares them against the database, and either assigns a &lt;code&gt;:current_user&lt;/code&gt; on success or responds with an error on failure.</source>
          <target state="translated">如果要在基本HTTP身份验证的基础上提供自己的身份验证逻辑，则可以使用低级功能。例如，我们定义 &lt;code&gt;:auth&lt;/code&gt; 插件，该插件从请求标头中提取用户名和密码，将其与数据库进行比较，并在成功时分配 &lt;code&gt;:current_user&lt;/code&gt; ，或者在失败时返回错误。</target>
        </trans-unit>
        <trans-unit id="0ec5f40c77fd66ea84bc6ba36f0c2a7c3fe56b0a" translate="yes" xml:space="preserve">
          <source>If you want to quickly check a sample application using Ecto, please check the &lt;a href=&quot;http://hexdocs.pm/ecto/getting-started.html&quot;&gt;getting started guide&lt;/a&gt; and the accompanying sample application.</source>
          <target state="translated">如果您想使用Ecto快速检查示例应用程序，请检查&lt;a href=&quot;http://hexdocs.pm/ecto/getting-started.html&quot;&gt;入门指南&lt;/a&gt;和随附的示例应用程序。</target>
        </trans-unit>
        <trans-unit id="c4123984bcd758a7753f404a92fb713daeb010c8" translate="yes" xml:space="preserve">
          <source>If you want to quickly check a sample application using Ecto, please check the &lt;a href=&quot;http://hexdocs.pm/ecto/getting-started.html&quot;&gt;getting started guide&lt;/a&gt; and the accompanying sample application. &lt;a href=&quot;https://github.com/elixir-ecto/ecto&quot;&gt;Ecto's README&lt;/a&gt; also links to other resources.</source>
          <target state="translated">如果要使用Ecto快速检查示例应用程序，请检查&lt;a href=&quot;http://hexdocs.pm/ecto/getting-started.html&quot;&gt;入门指南&lt;/a&gt;和随附的示例应用程序。&lt;a href=&quot;https://github.com/elixir-ecto/ecto&quot;&gt;Ecto的自述文件&lt;/a&gt;也链接到其他资源。</target>
        </trans-unit>
        <trans-unit id="5268cb204fe6237fdb4702e54e332bbb4778e707" translate="yes" xml:space="preserve">
          <source>If you want to render a template within the same view, you can skip the view name, and simply call &lt;code&gt;render(&quot;test.html&quot;, message: &quot;Hello from sibling template!&quot;)&lt;/code&gt; instead. For example, open up &lt;code&gt;lib/hello_web/templates/page/index.html.eex&lt;/code&gt; and add this at the top:</source>
          <target state="translated">如果要在同一视图中呈现模板，则可以跳过视图名称，而只需调用 &lt;code&gt;render(&quot;test.html&quot;, message: &quot;Hello from sibling template!&quot;)&lt;/code&gt; 。例如，打开 &lt;code&gt;lib/hello_web/templates/page/index.html.eex&lt;/code&gt; 并将其添加到顶部：</target>
        </trans-unit>
        <trans-unit id="78c050fecd9ef681ce1f0f4d13cfe35bf4a562b4" translate="yes" xml:space="preserve">
          <source>If you want to select an option that comes from the database, such as a manager for a given project, you may write:</source>
          <target state="translated">如果你想从数据库中选择一个选项,比如某个项目的经理,你可以写。</target>
        </trans-unit>
        <trans-unit id="752842436fbd52f5e0a837820a12e2cf6d06f8ef" translate="yes" xml:space="preserve">
          <source>If you want to show a progress bar as users perform live actions, we recommend using &lt;a href=&quot;https://github.com/rstacruz/nprogress&quot;&gt;&lt;code&gt;nprogress&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果要在用户执行实时操作时显示进度条，建议使用&lt;a href=&quot;https://github.com/rstacruz/nprogress&quot;&gt; &lt;code&gt;nprogress&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="da18100304362b3e3927019df152258ff3ba53bb" translate="yes" xml:space="preserve">
          <source>If you want to start a separate LiveView from within a LiveView, then you can call &lt;code&gt;live_render/3&lt;/code&gt; instead of &lt;code&gt;render/3&lt;/code&gt;. This child LiveView runs in a separate process than the parent, with its own &lt;code&gt;mount&lt;/code&gt; and &lt;code&gt;handle_event&lt;/code&gt; callbacks. If a child LiveView crashes, it won't affect the parent. If the parent crashes, all children are terminated.</source>
          <target state="translated">如果要从LiveView中启动单独的LiveView，则可以调用 &lt;code&gt;live_render/3&lt;/code&gt; 而不是 &lt;code&gt;render/3&lt;/code&gt; 。此子LiveView在与父项不同的单独进程中运行，并具有自己的 &lt;code&gt;mount&lt;/code&gt; 和 &lt;code&gt;handle_event&lt;/code&gt; 回调。如果子LiveView崩溃，则不会影响父级。如果父母崩溃了，所有的孩子都会被解雇。</target>
        </trans-unit>
        <trans-unit id="e2240497996f5c5fe18575f06718f0c34d8a4556" translate="yes" xml:space="preserve">
          <source>If you want to support a given engine only on a certain template, you can pass it as an option on &lt;code&gt;use Phoenix.Template&lt;/code&gt;:</source>
          <target state="translated">如果只想在特定模板上支持给定引擎，则可以在 &lt;code&gt;use Phoenix.Template&lt;/code&gt; 将其作为选项传递：</target>
        </trans-unit>
        <trans-unit id="1cdb64fa51ca4fb8866fc361686b367dbcbe98f6" translate="yes" xml:space="preserve">
          <source>If you want to target another component, you can also pass an ID or a class selector to any element inside the targeted component. For example, if there is a &lt;code&gt;UserComponent&lt;/code&gt; with the DOM ID of &lt;code&gt;user-13&lt;/code&gt;, using a query selector, we can send an event to it with:</source>
          <target state="translated">如果要定位另一个组件，则还可以将ID或类选择器传递给定位的组件内的任何元素。例如，如果有一个使用 &lt;code&gt;user-13&lt;/code&gt; 选择器的DOM ID为User-13的 &lt;code&gt;UserComponent&lt;/code&gt; ，我们可以使用以下命令向其发送事件：</target>
        </trans-unit>
        <trans-unit id="86e59309dd05a76fcd32896400f87305ec18e206" translate="yes" xml:space="preserve">
          <source>If you want to test how components are mounted by a LiveView and interact with DOM events, you can use the regular &lt;a href=&quot;#live/2&quot;&gt;&lt;code&gt;live/2&lt;/code&gt;&lt;/a&gt; macro to build the LiveView with the component and then scope events by passing the view and a &lt;strong&gt;DOM selector&lt;/strong&gt; in a list:</source>
          <target state="translated">如果要测试LiveView如何安装组件以及如何与DOM事件交互，可以使用常规&lt;a href=&quot;#live/2&quot;&gt; &lt;code&gt;live/2&lt;/code&gt; &lt;/a&gt;宏来构建带有该组件的LiveView，然后通过在列表中传递视图和&lt;strong&gt;DOM选择器&lt;/strong&gt;来对事件进行范围界定：</target>
        </trans-unit>
        <trans-unit id="d0f98f30cf1d08e9178e85581a80a56cb8d7d157" translate="yes" xml:space="preserve">
          <source>If you would prefer to read these guides as an EPUB &lt;a href=&quot;phoenix.epub&quot;&gt;click here!&lt;/a&gt;</source>
          <target state="translated">如果您希望以EPUB的形式阅读这些指南，&lt;a href=&quot;phoenix.epub&quot;&gt;请点击此处！&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6906d4bf644df48b3f0c419b3abf27f44bf197a2" translate="yes" xml:space="preserve">
          <source>If you would prefer to simply merge two multis together, see &lt;a href=&quot;#append/2&quot;&gt;&lt;code&gt;append/2&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#prepend/2&quot;&gt;&lt;code&gt;prepend/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果您想简单地将两个多重合并在一起，请参阅&lt;a href=&quot;#append/2&quot;&gt; &lt;code&gt;append/2&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#prepend/2&quot;&gt; &lt;code&gt;prepend/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2467d576cbf855c8ae9348c4a47fdcb13145270e" translate="yes" xml:space="preserve">
          <source>If your Plug application is behind a proxy that handles HTTPS, you may need to tell Plug to parse the proper protocol from the &lt;code&gt;x-forwarded-*&lt;/code&gt; header.</source>
          <target state="translated">如果您的Plug应用程序位于处理HTTPS的代理后面，则可能需要告诉Plug从 &lt;code&gt;x-forwarded-*&lt;/code&gt; 标头中解析适当的协议。</target>
        </trans-unit>
        <trans-unit id="906016b8afe13d5670e52576993026f7d29c208a" translate="yes" xml:space="preserve">
          <source>If your Plug application is behind a proxy that handles HTTPS, you may need to tell Plug to parse the proper protocol from the &lt;code&gt;x-forwarded-*&lt;/code&gt; header. This can be done using the &lt;code&gt;:rewrite_on&lt;/code&gt; option:</source>
          <target state="translated">如果您的Plug应用程序位于处理HTTPS的代理后面，则可能需要告诉Plug从 &lt;code&gt;x-forwarded-*&lt;/code&gt; 标头中解析适当的协议。可以使用 &lt;code&gt;:rewrite_on&lt;/code&gt; 选项来完成：</target>
        </trans-unit>
        <trans-unit id="ffa6a80acbf97635e0ac507b93d5063cd5b0d16a" translate="yes" xml:space="preserve">
          <source>If your Plug application is behind a proxy that handles HTTPS, you will need to tell Plug to parse the proper protocol from the &lt;code&gt;x-forwarded-proto&lt;/code&gt; header. This can be done using the &lt;code&gt;:rewrite_on&lt;/code&gt; option:</source>
          <target state="translated">如果您的Plug应用程序在处理HTTPS的代理后面，则需要告诉Plug从 &lt;code&gt;x-forwarded-proto&lt;/code&gt; 标头解析正确的协议。可以使用 &lt;code&gt;:rewrite_on&lt;/code&gt; 选项来完成：</target>
        </trans-unit>
        <trans-unit id="4ee22e439b0d72c012e013a54bdd332f454b15e8" translate="yes" xml:space="preserve">
          <source>If your adapter is only able to respond to one or a couple of the query functions, add custom implementations of those functions directly to the Repo by using &lt;a href=&quot;ecto.adapter#c:__before_compile__/1&quot;&gt;&lt;code&gt;Ecto.Adapter.__before_compile__/1&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">如果您的适配器只能响应一个或几个查询功能，请改用&lt;a href=&quot;ecto.adapter#c:__before_compile__/1&quot;&gt; &lt;code&gt;Ecto.Adapter.__before_compile__/1&lt;/code&gt; &lt;/a&gt;将这些功能的自定义实现直接添加到Repo中。</target>
        </trans-unit>
        <trans-unit id="a4ea11ef400e8f5b84f516d039032b014e672598" translate="yes" xml:space="preserve">
          <source>If your application was generated with a supervisor (by passing &lt;code&gt;--sup&lt;/code&gt; to &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.New.html&quot;&gt;&lt;code&gt;mix new&lt;/code&gt;&lt;/a&gt;) you will have a &lt;code&gt;lib/my_app/application.ex&lt;/code&gt; file containing the application start callback that defines and starts your supervisor. You just need to edit the &lt;code&gt;start/2&lt;/code&gt; function to start the repo as a supervisor on your application's supervisor:</source>
          <target state="translated">如果您的应用程序是由主管生成的（通过传递 &lt;code&gt;--sup&lt;/code&gt; 来&lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.New.html&quot;&gt; &lt;code&gt;mix new&lt;/code&gt; &lt;/a&gt;），您将拥有一个 &lt;code&gt;lib/my_app/application.ex&lt;/code&gt; 文件，其中包含定义和启动主管的应用程序启动回调。您只需要编辑 &lt;code&gt;start/2&lt;/code&gt; 函数即可以应用程序的主管作为主管启动存储库：</target>
        </trans-unit>
        <trans-unit id="e64da7625aab0af6dfae19c9bbd8cef653814d79" translate="yes" xml:space="preserve">
          <source>If your application was generated with a supervisor (by passing &lt;code&gt;--sup&lt;/code&gt; to &lt;code&gt;mix new&lt;/code&gt;) you will have a &lt;code&gt;lib/my_app/application.ex&lt;/code&gt; file containing the application start callback that defines and starts your supervisor. You just need to edit the &lt;code&gt;start/2&lt;/code&gt; function to start the repo as a supervisor on your application&amp;rsquo;s supervisor:</source>
          <target state="translated">如果您的应用程序是由主管生成的（通过传递 &lt;code&gt;--sup&lt;/code&gt; 来 &lt;code&gt;mix new&lt;/code&gt; ），您将拥有一个 &lt;code&gt;lib/my_app/application.ex&lt;/code&gt; 文件，其中包含定义和启动主管的应用程序启动回调。您只需要编辑 &lt;code&gt;start/2&lt;/code&gt; 函数即可以应用程序的主管作为主管启动存储库：</target>
        </trans-unit>
        <trans-unit id="9963b98e0a632c06b03f38938368cd7af1095618" translate="yes" xml:space="preserve">
          <source>If your data layer supports embedding or nested associations, you can use &lt;code&gt;inputs_for&lt;/code&gt; to attach nested data to the form.</source>
          <target state="translated">如果数据层支持嵌入或嵌套关联，则可以使用 &lt;code&gt;inputs_for&lt;/code&gt; 将嵌套数据附加到表单。</target>
        </trans-unit>
        <trans-unit id="cc3f651a489e53e22ef5bfd5ad5ccb20a85f41ce" translate="yes" xml:space="preserve">
          <source>If your primary key is not named &amp;ldquo;id&amp;rdquo; (e.g. if you are working with a legacy database), you can use the &lt;code&gt;@primary_key&lt;/code&gt; attribute to configure your key name using the &lt;code&gt;source&lt;/code&gt; option. For example, the following attribute defines an integer primary key named &lt;code&gt;legacy_id&lt;/code&gt; which is automatically incremented by the database:</source>
          <target state="translated">如果您的主键未命名为&amp;ldquo; id&amp;rdquo;（例如，如果您使用的是旧数据库），则可以使用 &lt;code&gt;@primary_key&lt;/code&gt; 属性使用 &lt;code&gt;source&lt;/code&gt; 选项配置键名。例如，以下属性定义了一个名为 &lt;code&gt;legacy_id&lt;/code&gt; 的整数主键，该主键将由数据库自动递增：</target>
        </trans-unit>
        <trans-unit id="f30aa9bbf518465faa2ed1f37bfe76b59f3c62b2" translate="yes" xml:space="preserve">
          <source>If your screen looks like the image above, congratulations! You now have a working Phoenix application. In case you can't see the page above, try accessing it via &lt;a href=&quot;http://127.0.0.1:4000&quot;&gt;http://127.0.0.1:4000&lt;/a&gt; and later make sure your OS has defined &quot;localhost&quot; as &quot;127.0.0.1&quot;.</source>
          <target state="translated">如果您的屏幕看起来像上面的图片，那么恭喜！您现在有一个正在运行的Phoenix应用程序。如果您看不到上面的页面，请尝试通过&lt;a href=&quot;http://127.0.0.1:4000&quot;&gt;http://127.0.0.1:4000&lt;/a&gt;访问它，然后确保您的操作系统已将&amp;ldquo; localhost&amp;rdquo;定义为&amp;ldquo; 127.0.0.1&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="c262a06dde1c92c1b642e458f52da921424c961b" translate="yes" xml:space="preserve">
          <source>If your socket is implemented using &lt;a href=&quot;phoenix.socket&quot;&gt;&lt;code&gt;Phoenix.Socket&lt;/code&gt;&lt;/a&gt;, you can also pass to each transport above all options accepted on &lt;code&gt;use Phoenix.Socket&lt;/code&gt;. An option given here will override the value in &lt;code&gt;use Phoenix.Socket&lt;/code&gt;.</source>
          <target state="translated">如果您的套接字是使用&lt;a href=&quot;phoenix.socket&quot;&gt; &lt;code&gt;Phoenix.Socket&lt;/code&gt; &lt;/a&gt;实现的，则还可以将 &lt;code&gt;use Phoenix.Socket&lt;/code&gt; 接受的所有选项传递给每个传输。此处给出的选项将覆盖 &lt;code&gt;use Phoenix.Socket&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="a7f718c136252a6132fe7a1aa2ed7beedb600c13" translate="yes" xml:space="preserve">
          <source>If your table is partitioned, then your unique index might look different per partition, e.g. Postgres adds p&amp;lt;number&amp;gt; to the middle of your key, like:</source>
          <target state="translated">如果表已分区，则每个分区的唯一索引可能会有所不同，例如Postgres将p &amp;lt;number&amp;gt;添加到键的中间，例如：</target>
        </trans-unit>
        <trans-unit id="0a69fedcf99422ab483c859e4efba05a441aa355" translate="yes" xml:space="preserve">
          <source>Imagine a relationship where Post has many comments and you want to add a new comment to an existing post. While it is possible to use &lt;a href=&quot;#put_assoc/4&quot;&gt;&lt;code&gt;put_assoc/4&lt;/code&gt;&lt;/a&gt; for this, it would be unecessarily complex. Let&amp;rsquo;s see an example.</source>
          <target state="translated">想象一下一个关系，其中&amp;ldquo;帖子&amp;rdquo;有很多评论，而您想向现有帖子添加新评论。尽管可以为此使用&lt;a href=&quot;#put_assoc/4&quot;&gt; &lt;code&gt;put_assoc/4&lt;/code&gt; &lt;/a&gt;，但这将不必要地复杂。让我们来看一个例子。</target>
        </trans-unit>
        <trans-unit id="b9e00b21da4725e0255aeee1974fcbd6702ec96c" translate="yes" xml:space="preserve">
          <source>Imagine a relationship where Post has many comments and you want to add a new comment to an existing post. While it is possible to use &lt;a href=&quot;#put_assoc/4&quot;&gt;&lt;code&gt;put_assoc/4&lt;/code&gt;&lt;/a&gt; for this, it would be unnecessarily complex. Let's see an example.</source>
          <target state="translated">想象一下一个关系，其中&amp;ldquo;帖子&amp;rdquo;有很多评论，而您想向现有帖子添加新评论。尽管可以为此使用&lt;a href=&quot;#put_assoc/4&quot;&gt; &lt;code&gt;put_assoc/4&lt;/code&gt; &lt;/a&gt;，但这将不必要地复杂。让我们来看一个例子。</target>
        </trans-unit>
        <trans-unit id="eab9f45cd5235d2ab5cef0f88fd7c2ff360cc9db" translate="yes" xml:space="preserve">
          <source>Imagine a scenario where LiveView represents a board with each card in it as a separate component. Each card has a form that allows to update its title directly in the component. We will see how to organize the data flow keeping either the view or the component as the source of truth.</source>
          <target state="translated">想象一下,LiveView表示一个板块,板块中的每个卡片都是一个独立的组件。每张卡片都有一个表单,可以直接在组件中更新其标题。我们将看到如何组织数据流,将视图或组件作为真相的来源。</target>
        </trans-unit>
        <trans-unit id="a9a80fa7e20b6ec638558d87fd5e8f1b2c820f57" translate="yes" xml:space="preserve">
          <source>Imagine the following &lt;code&gt;handle_in/3&lt;/code&gt; inside a channel:</source>
          <target state="translated">想象一下通道中的以下 &lt;code&gt;handle_in/3&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="d7eaef0786d3c2d56724df9325bdf3c6d03a3696" translate="yes" xml:space="preserve">
          <source>Imagine the following Ecto schemas:</source>
          <target state="translated">设想以下Ecto模式。</target>
        </trans-unit>
        <trans-unit id="69ed1238c0e40ec582e839a9be87906ea6d1bb56" translate="yes" xml:space="preserve">
          <source>Imagine the following plug:</source>
          <target state="translated">想象一下下面的插头。</target>
        </trans-unit>
        <trans-unit id="6ca34da07d3e254b51321106a99af217f3cef8f8" translate="yes" xml:space="preserve">
          <source>Imagine you are receiving a set of tags you want to associate to a post. Let&amp;rsquo;s imagine that those tags exist upfront and are all persisted to the database. Imagine we get the data in this format:</source>
          <target state="translated">想象一下，您收到了一组要关联到帖子的标签。让我们想象一下，这些标记预先存在并且全部持久化到数据库中。假设我们以以下格式获取数据：</target>
        </trans-unit>
        <trans-unit id="07174bed3e1206960783f2a30e60773792599d44" translate="yes" xml:space="preserve">
          <source>Imagine you are receiving a set of tags you want to associate to a post. Let's imagine that those tags exist upfront and are all persisted to the database. Imagine we get the data in this format:</source>
          <target state="translated">想象一下,你收到了一组你想要关联到一篇文章的标签。让我们想象一下,这些标签在前期就已经存在,并且全部持久化到数据库中。想象一下,我们得到的数据是这样的格式。</target>
        </trans-unit>
        <trans-unit id="626b97593e67500eea59fda38eaa3e41d970c5ff" translate="yes" xml:space="preserve">
          <source>Imagine you have a LiveView that redirects on a &lt;code&gt;render_click&lt;/code&gt; event. You can make it sure it immediately redirects after the &lt;code&gt;render_click&lt;/code&gt; action by calling &lt;a href=&quot;#follow_redirect/3&quot;&gt;&lt;code&gt;follow_redirect/3&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">假设您有一个LiveView可以在 &lt;code&gt;render_click&lt;/code&gt; 事件上重定向。您可以通过调用&lt;a href=&quot;#follow_redirect/3&quot;&gt; &lt;code&gt;follow_redirect/3&lt;/code&gt; &lt;/a&gt;来确保它在 &lt;code&gt;render_click&lt;/code&gt; 操作之后立即重定向：</target>
        </trans-unit>
        <trans-unit id="224f74e1875d15da71996dc37aae640fe78641d1" translate="yes" xml:space="preserve">
          <source>Imagine you have a schema &lt;code&gt;Post&lt;/code&gt; with a &lt;code&gt;has_many :comments&lt;/code&gt; association and you execute the following query:</source>
          <target state="translated">假设您有一个具有 &lt;code&gt;has_many :comments&lt;/code&gt; 关联的架构 &lt;code&gt;Post&lt;/code&gt; ，然后执行以下查询：</target>
        </trans-unit>
        <trans-unit id="37ae5ef9b11c014505c58d928130e9d937a57895" translate="yes" xml:space="preserve">
          <source>Imagine you have an schema &lt;code&gt;Post&lt;/code&gt; with a &lt;code&gt;has_many :comments&lt;/code&gt; association and you execute the following query:</source>
          <target state="translated">假设您有一个具有 &lt;code&gt;has_many :comments&lt;/code&gt; 关联的架构 &lt;code&gt;Post&lt;/code&gt; ，然后执行以下查询：</target>
        </trans-unit>
        <trans-unit id="911d5cbc4bd74830db2cf2e8c805fa896d8b4ab3" translate="yes" xml:space="preserve">
          <source>Imagine you have the following action in your controller:</source>
          <target state="translated">想象一下,在你的控制器中,你有以下操作。</target>
        </trans-unit>
        <trans-unit id="c3bcbecb37fb60e6f6b4d98aea0398cac118f78f" translate="yes" xml:space="preserve">
          <source>Imagine you want to encode the ID so they cannot enumerate the content in your application. An Ecto type could handle the conversion between the encoded version of the id and its representation in the database. For the sake of simplicity we'll use base64 encoding in this example:</source>
          <target state="translated">想象一下,你想对ID进行编码,这样他们就不能在你的应用程序中枚举内容。一个Ecto类型可以处理id的编码版本和它在数据库中的表示之间的转换。为了简单起见,我们将在这个例子中使用base64编码。</target>
        </trans-unit>
        <trans-unit id="d1656f1d578045bfea05e6c6a2237b5d6e0a2f9f" translate="yes" xml:space="preserve">
          <source>Imagine you want to implement a chat application with LiveView. You could render each message like this:</source>
          <target state="translated">想象一下,你想用LiveView实现一个聊天应用程序。你可以像这样渲染每条消息。</target>
        </trans-unit>
        <trans-unit id="15e74fb2e9144b4fc1c6e2f7edb9692fba7939fe" translate="yes" xml:space="preserve">
          <source>Imagine you want to store an URI struct as part of a schema in an url-shortening service. There isn&amp;rsquo;t an Ecto field type to support that value at runtime, therefore a custom one is needed.</source>
          <target state="translated">假设您想将URI结构作为架构的一部分存储在URL缩短服务中。在运行时没有支持该值的Ecto字段类型，因此需要自定义类型。</target>
        </trans-unit>
        <trans-unit id="172eb5a1f40be1a000419ab4add75a6dc3be204b" translate="yes" xml:space="preserve">
          <source>Imagine you want to store an URI struct as part of a schema in an url-shortening service. There isn't an Ecto field type to support that value at runtime, therefore a custom one is needed.</source>
          <target state="translated">想象一下,你想存储一个URI结构作为一个url缩短服务中模式的一部分。没有一个Ecto字段类型在运行时支持这个值,因此需要一个自定义的字段类型。</target>
        </trans-unit>
        <trans-unit id="1e1dad2bc8d9075bbf5f98838633808ebc9eb469" translate="yes" xml:space="preserve">
          <source>Imagine your application is configured to run on &quot;example.com&quot; but after the user signs in, you want all links to use &quot;some_user.example.com&quot;. You can do so by setting the proper router url configuration:</source>
          <target state="translated">想象一下,你的应用程序被配置为在 &quot;example.com &quot;上运行,但在用户登录后,你希望所有的链接都使用 &quot;some_user.example.com&quot;。你可以通过设置正确的路由器url配置来实现。</target>
        </trans-unit>
        <trans-unit id="dd83f3829baa0b9a2d40da3d590f7c9d0db3a5ca" translate="yes" xml:space="preserve">
          <source>Implementing a Tracker</source>
          <target state="translated">实施一个跟踪器</target>
        </trans-unit>
        <trans-unit id="3d6c2a38d322d3d763e854f7651b3495dd090632" translate="yes" xml:space="preserve">
          <source>Implementing the transport behaviour</source>
          <target state="translated">实施运输行为</target>
        </trans-unit>
        <trans-unit id="058fd7ed1c45697b86ef3cd0718d7bbfbe7580e9" translate="yes" xml:space="preserve">
          <source>Implementing your own adapter</source>
          <target state="translated">实现自己的适配器</target>
        </trans-unit>
        <trans-unit id="eeaf0d0aa80addf9bcd22d809311b4d22bbca34c" translate="yes" xml:space="preserve">
          <source>Important: If we don't do this, we will see the following warnings in our logs, and our application will error when trying to execute the function.</source>
          <target state="translated">重要的是:如果我们不这样做,我们将在日志中看到以下警告,并且我们的应用程序将在尝试执行函数时出错。</target>
        </trans-unit>
        <trans-unit id="0de9ddaf0c21afc63217f2c5ffe75bfdc4b6cd3c" translate="yes" xml:space="preserve">
          <source>Important: If we don't do this, we'll get the following warning in our logs and the application will error when attempting to load the page:</source>
          <target state="translated">重要的是:如果我们不这样做,我们将在日志中得到以下警告,应用程序将在尝试加载页面时出错。</target>
        </trans-unit>
        <trans-unit id="b0c929d75f4d94fd8fe1c260cbfd2b081155e7fe" translate="yes" xml:space="preserve">
          <source>In Ecto, we have three ways to solve this issue. The simplest is to define multiple fields in the Comment schema, one for each association:</source>
          <target state="translated">在Ecto中,我们有三种方法来解决这个问题。最简单的是在Comment模式中定义多个字段,每个关联都有一个。</target>
        </trans-unit>
        <trans-unit id="2da5549fe6372ba474a6b84ff8f0aa9b971f280a" translate="yes" xml:space="preserve">
          <source>In LiveView tests, we interact with views via process communication in substitution of a browser. Like a browser, our test process receives messages about the rendered updates from the view which can be asserted against to test the life-cycle and behavior of LiveViews and their children.</source>
          <target state="translated">在LiveView测试中,我们通过进程通信代替浏览器与视图进行交互。像浏览器一样,我们的测试进程从视图中接收关于渲染更新的消息,这些消息可以被断言,以测试LiveViews及其子代的生命周期和行为。</target>
        </trans-unit>
        <trans-unit id="382006685c4bc65202ab7101130f82fd90eb1bb5" translate="yes" xml:space="preserve">
          <source>In SQL, COALESCE takes any number of arguments, but in ecto it only takes two, so it must be chained to achieve the same effect.</source>
          <target state="translated">在SQL中,COALESCE可以接受任意数量的参数,但在ecto中,它只接受两个参数,所以必须通过链式来达到同样的效果。</target>
        </trans-unit>
        <trans-unit id="8ae8d00a4f35aea9b1e600a76e95f40be1762a98" translate="yes" xml:space="preserve">
          <source>In a nutshell, &lt;code&gt;builder_opts()&lt;/code&gt; allows us to pass the options given when initializing the router to a &lt;code&gt;dispatch&lt;/code&gt;.</source>
          <target state="translated">简而言之， &lt;code&gt;builder_opts()&lt;/code&gt; 允许我们将初始化路由器时使用的选项传递给 &lt;code&gt;dispatch&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b09256d570841fbfb45d7851451305f20a0625cb" translate="yes" xml:space="preserve">
          <source>In addition to a certificate, an HTTPS server needs a secure TLS protocol configuration. &lt;a href=&quot;plug.ssl&quot;&gt;&lt;code&gt;Plug.SSL&lt;/code&gt;&lt;/a&gt; always sets the following options:</source>
          <target state="translated">除证书外，HTTPS服务器还需要安全的TLS协议配置。&lt;a href=&quot;plug.ssl&quot;&gt; &lt;code&gt;Plug.SSL&lt;/code&gt; &lt;/a&gt;始终设置以下选项：</target>
        </trans-unit>
        <trans-unit id="0a6f8049b39704e81ebed2652617e08d77f57235" translate="yes" xml:space="preserve">
          <source>In addition to inserts, we can also perform updates and deletes with &lt;code&gt;Repo.update/1&lt;/code&gt; and &lt;code&gt;Repo.delete/1&lt;/code&gt; to update or delete a single schema. Ecto also supports bulk persistence with the &lt;code&gt;Repo.insert_all&lt;/code&gt;, &lt;code&gt;Repo.update_all&lt;/code&gt;, and &lt;code&gt;Repo.delete_all&lt;/code&gt; functions.</source>
          <target state="translated">除了插入之外，我们还可以使用 &lt;code&gt;Repo.update/1&lt;/code&gt; 和 &lt;code&gt;Repo.delete/1&lt;/code&gt; 进行更新和删除，以更新或删除单个模式。Ecto还使用 &lt;code&gt;Repo.insert_all&lt;/code&gt; ， &lt;code&gt;Repo.update_all&lt;/code&gt; 和 &lt;code&gt;Repo.delete_all&lt;/code&gt; 函数支持批量持久性。</target>
        </trans-unit>
        <trans-unit id="9ac9085e5b012c8583c70779624f050d5eb103a2" translate="yes" xml:space="preserve">
          <source>In addition to pushing messages out when you receive a &lt;code&gt;handle_in&lt;/code&gt; event, you can also reply directly to a client event for request/response style messaging. This is useful when a client must know the result of an operation or to simply ack messages.</source>
          <target state="translated">除了在收到 &lt;code&gt;handle_in&lt;/code&gt; 事件时将消息推出，您还可以直接回复客户端事件以进行请求/响应样式消息传递。当客户端必须知道操作结果或仅确认消息时，此功能很有用。</target>
        </trans-unit>
        <trans-unit id="a42c2c570e4795fcc36b32e73f177e0d5b29e6e2" translate="yes" xml:space="preserve">
          <source>In addition to selecting a group of ciphers, selecting a cipher suite will also disable client renegotiation and force the client to honor the server specified cipher order.</source>
          <target state="translated">除了选择一组密码外,选择密码套件还将禁用客户端重新协商,并强制客户端尊重服务器指定的密码顺序。</target>
        </trans-unit>
        <trans-unit id="01ea8672f27177207c552fb1a1c80ac011412a23" translate="yes" xml:space="preserve">
          <source>In addition, both profiles:</source>
          <target state="translated">此外,这两份资料。</target>
        </trans-unit>
        <trans-unit id="14f7eb8892415ea0c1aacaa32e064c3934506b5b" translate="yes" xml:space="preserve">
          <source>In all cases, each assign in the template will be accessible as &lt;code&gt;@assign&lt;/code&gt;. You can learn more about &lt;a href=&quot;assigns-eex&quot;&gt;assigns and LiveEEx templates in their own guide&lt;/a&gt;.</source>
          <target state="translated">在所有情况下，模板中的每个assign都可以通过 &lt;code&gt;@assign&lt;/code&gt; 进行访问。您可以&lt;a href=&quot;assigns-eex&quot;&gt;在各自的指南中&lt;/a&gt;了解有关分配和LiveEEx模板的更多信息。</target>
        </trans-unit>
        <trans-unit id="e048396b52227039210be32cd7f7739a9bd6e4a9" translate="yes" xml:space="preserve">
          <source>In all examples so far we have used the &lt;strong&gt;keywords query syntax&lt;/strong&gt; to create a query:</source>
          <target state="translated">到目前为止，在所有示例中，我们都使用&lt;strong&gt;关键字query语法&lt;/strong&gt;创建查询：</target>
        </trans-unit>
        <trans-unit id="39c6142f3ef45ee877e9c272f4bb4ce3244f2b98" translate="yes" xml:space="preserve">
          <source>In any case, regardless if a schema has been given or not, Ecto queries are always composable thanks to its binding system.</source>
          <target state="translated">在任何情况下,无论是否给定了模式,Ecto查询总是可以合成的,这要归功于它的绑定系统。</target>
        </trans-unit>
        <trans-unit id="a15d51ecf5a44207426a5880570278383d07dd49" translate="yes" xml:space="preserve">
          <source>In both cases, &lt;a href=&quot;#c:handle_event/3&quot;&gt;&lt;code&gt;handle_event/3&lt;/code&gt;&lt;/a&gt; will be called with the &quot;say_hello&quot; event. When &lt;a href=&quot;#c:handle_event/3&quot;&gt;&lt;code&gt;handle_event/3&lt;/code&gt;&lt;/a&gt; is called for a component, only the diff of the component is sent to the client, making them extremely efficient.</source>
          <target state="translated">在这两种情况下，都将通过&amp;ldquo; say_hello&amp;rdquo;事件来调用handle_event &lt;a href=&quot;#c:handle_event/3&quot;&gt; &lt;code&gt;handle_event/3&lt;/code&gt; &lt;/a&gt;。当为组件调用&lt;a href=&quot;#c:handle_event/3&quot;&gt; &lt;code&gt;handle_event/3&lt;/code&gt; 时&lt;/a&gt;，仅将组件的差异发送到客户端，这使它们非常高效。</target>
        </trans-unit>
        <trans-unit id="d5f38f557b90ac2d42e6a751598f4d8bbba9025c" translate="yes" xml:space="preserve">
          <source>In both cases, both types have their semantics specified by the underlying adapter/database. If you use the &lt;code&gt;:id&lt;/code&gt; type with &lt;code&gt;:autogenerate&lt;/code&gt;, it means the database will be responsible for auto-generation of the id. This is often the case for primary keys in relational databases which are auto-incremented.</source>
          <target state="translated">在这两种情况下，两种类型的语义都由基础适配器/数据库指定。如果将 &lt;code&gt;:id&lt;/code&gt; 类型与 &lt;code&gt;:autogenerate&lt;/code&gt; 一起使用，则意味着数据库将负责自动生成ID。对于自动递增的关系数据库中的主键，通常是这种情况。</target>
        </trans-unit>
        <trans-unit id="c8e64dc292736835c5a534ec38dce0f0304db068" translate="yes" xml:space="preserve">
          <source>In case a JSON response is returned, it will be converted to a JSONP as long as the callback field is present in the query string. The callback field itself defaults to &quot;callback&quot;, but may be configured with the callback option.</source>
          <target state="translated">如果返回的是JSON响应,只要查询字符串中存在回调字段,它就会被转换为JSONP。回调字段本身默认为 &quot;callback&quot;,但可以通过回调选项进行配置。</target>
        </trans-unit>
        <trans-unit id="82af51d52f0d5e198a5e7d698f02d79e495b27b9" translate="yes" xml:space="preserve">
          <source>In case a JSON response is returned, it will be converted to a JSONP as long as the callback field is present in the query string. The callback field itself defaults to &amp;ldquo;callback&amp;rdquo;, but may be configured with the callback option.</source>
          <target state="translated">如果返回了JSON响应，只要查询字符串中存在回调字段，它将被转换为JSONP。回调字段本身默认为&amp;ldquo;回调&amp;rdquo;，但可以使用回调选项进行配置。</target>
        </trans-unit>
        <trans-unit id="cce9be04157216a7cdb190a3b918523e8aca6731" translate="yes" xml:space="preserve">
          <source>In case a changeset is given, the changes in the changeset are merged with the struct fields, and all of them are sent to the database.</source>
          <target state="translated">如果给定一个变化集,变化集中的变化将与结构字段合并,并全部发送到数据库中。</target>
        </trans-unit>
        <trans-unit id="83a2e40171803838a9ad2e6d9d64ac8dc619d36d" translate="yes" xml:space="preserve">
          <source>In case a previous layout is set, &lt;code&gt;put_root_layout&lt;/code&gt; also accepts the layout name to be given as a string or as an atom. If a string, it must contain the format. Passing an atom means the layout format will be found at rendering time, similar to the template in &lt;a href=&quot;#render/3&quot;&gt;&lt;code&gt;render/3&lt;/code&gt;&lt;/a&gt;. It can also be set to &lt;code&gt;false&lt;/code&gt;. In this case, no layout would be used.</source>
          <target state="translated">如果设置了先前的布局， &lt;code&gt;put_root_layout&lt;/code&gt; 也接受以字符串或原子形式给出的布局名称。如果是字符串，则必须包含格式。传递原子意味着在渲染时将找到布局格式，类似于&lt;a href=&quot;#render/3&quot;&gt; &lt;code&gt;render/3&lt;/code&gt; 中&lt;/a&gt;的模板。也可以将其设置为 &lt;code&gt;false&lt;/code&gt; 。在这种情况下，将不使用任何布局。</target>
        </trans-unit>
        <trans-unit id="e804f9ad9af0ffc381cba4d6aa6307ec8f5528fa" translate="yes" xml:space="preserve">
          <source>In case a struct is given, the struct is converted into a changeset with all non-nil fields as part of the changeset.</source>
          <target state="translated">如果给定了一个结构体,该结构体会被转换为一个变化集,所有非零字段都是变化集的一部分。</target>
        </trans-unit>
        <trans-unit id="c3cb35e3a5542760b8bd73c40248a0ad353cdacc" translate="yes" xml:space="preserve">
          <source>In case an &lt;a href=&quot;ecto.query&quot;&gt;&lt;code&gt;Ecto.Query&lt;/code&gt;&lt;/a&gt; given as any of the field values by the user, it will be sent to the adapter as a tuple with in the shape of &lt;code&gt;{query, params}&lt;/code&gt;.</source>
          <target state="translated">如果用户将&lt;a href=&quot;ecto.query&quot;&gt; &lt;code&gt;Ecto.Query&lt;/code&gt; &lt;/a&gt;作为任何字段值给出，它将作为元组发送到适配器，其形式为 &lt;code&gt;{query, params}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="24b15538982d59e2053fe7e9d8eaeadd4eb2e39f" translate="yes" xml:space="preserve">
          <source>In case an attribute contains a boolean value, its key is repeated when it is true, as expected in HTML, or the attribute is completely removed if it is false:</source>
          <target state="translated">如果一个属性包含一个布尔值,当它为真时,它的键会被重复,就像HTML中所期望的那样,如果属性为假,则会被完全删除。</target>
        </trans-unit>
        <trans-unit id="8e575af2759774fa079f44025ceaa854182a1885" translate="yes" xml:space="preserve">
          <source>In case something goes wrong in a request, the router by default will crash, without returning any response to the client. This behaviour can be configured in two ways, by using two different modules:</source>
          <target state="translated">如果在请求中出了问题,路由器默认会崩溃,不返回任何响应给客户端。这种行为可以通过两种方式配置,使用两个不同的模块。</target>
        </trans-unit>
        <trans-unit id="9df0afcd7e029ed4180d102a2ae98dc593f2ffcd" translate="yes" xml:space="preserve">
          <source>In case the URL needs to be dynamically configured, for example by reading a system environment variable, such can be done via the &lt;a href=&quot;#c:init/2&quot;&gt;&lt;code&gt;init/2&lt;/code&gt;&lt;/a&gt; repository callback:</source>
          <target state="translated">如果需要动态配置URL（例如，通过读取系统环境变量），则可以通过&lt;a href=&quot;#c:init/2&quot;&gt; &lt;code&gt;init/2&lt;/code&gt; &lt;/a&gt;存储库回调来完成：</target>
        </trans-unit>
        <trans-unit id="c933f8035c349bb985fc09533544e811593ba38d" translate="yes" xml:space="preserve">
          <source>In case the adapter provides a pool, this guarantees all of the code inside the given &lt;code&gt;fun&lt;/code&gt; runs against the same connection, which might improve performance by for instance allowing multiple related calls to the datastore to share cache information:</source>
          <target state="translated">如果适配器提供了一个池，则可以保证给定 &lt;code&gt;fun&lt;/code&gt; 内的所有代码都在同一连接上运行，这可以通过例如允许对数据存储的多个相关调用来共享缓存信息来提高性能：</target>
        </trans-unit>
        <trans-unit id="30bf9e264bce9cb321b7053883e7d31f611e7f05" translate="yes" xml:space="preserve">
          <source>In case the adapter provides a pool, this guarantees all of the code inside the given &lt;code&gt;fun&lt;/code&gt; runs against the same connection.</source>
          <target state="translated">如果适配器提供了一个池，则可以保证给定 &lt;code&gt;fun&lt;/code&gt; 中的所有代码都针对同一连接运行。</target>
        </trans-unit>
        <trans-unit id="ff857d8a1955260dd298b9e239a24e36bf3592fa" translate="yes" xml:space="preserve">
          <source>In case the association was already loaded, preload won&amp;rsquo;t attempt to reload it.</source>
          <target state="translated">如果关联已加载，则预加载不会尝试重新加载它。</target>
        </trans-unit>
        <trans-unit id="cafa8aa062d6ef4942117b66127dc03a39128b32" translate="yes" xml:space="preserve">
          <source>In case the association was already loaded, preload won't attempt to reload it.</source>
          <target state="translated">如果关联已经被加载,预加载不会尝试重新加载它。</target>
        </trans-unit>
        <trans-unit id="9be12295c8a6d2df07eacd1bb351f53d2c1496b9" translate="yes" xml:space="preserve">
          <source>In case the database could not be created, see the guides for the &lt;a href=&quot;mix_tasks#mix-ecto-create&quot;&gt;&lt;code&gt;mix ecto.create&lt;/code&gt;&lt;/a&gt; for general trouble-shooting.</source>
          <target state="translated">如果无法创建数据库，请参阅&lt;a href=&quot;mix_tasks#mix-ecto-create&quot;&gt; &lt;code&gt;mix ecto.create&lt;/code&gt; &lt;/a&gt;指南以进行一般故障排除。</target>
        </trans-unit>
        <trans-unit id="606100f3e421118140c48c97a79e6b2bfcdaf803" translate="yes" xml:space="preserve">
          <source>In case there is no callback or the response is not encoded in JSON format, it is a no-op.</source>
          <target state="translated">如果没有回调或者响应不是JSON格式的编码,那就是没有操作。</target>
        </trans-unit>
        <trans-unit id="8a4c0d85054f4f0cfaba6ef317dc6eb61be6e95d" translate="yes" xml:space="preserve">
          <source>In case there&amp;rsquo;s at least one error, the list of errors will be appended to the &lt;code&gt;:errors&lt;/code&gt; field of the changeset and the &lt;code&gt;:valid?&lt;/code&gt; flag will be set to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果存在至少一个错误，则错误列表将附加到变更集的 &lt;code&gt;:errors&lt;/code&gt; 字段和 &lt;code&gt;:valid?&lt;/code&gt; 后面。标志将设置为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8802f9aee3cd3d44f383509389bf5a3ee709a5f4" translate="yes" xml:space="preserve">
          <source>In case there's at least one error, the list of errors will be appended to the &lt;code&gt;:errors&lt;/code&gt; field of the changeset and the &lt;code&gt;:valid?&lt;/code&gt; flag will be set to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果存在至少一个错误，则错误列表将附加到变更集的 &lt;code&gt;:errors&lt;/code&gt; 字段和 &lt;code&gt;:valid?&lt;/code&gt; 后面。标志将设置为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4d961c79d7700abcfdd8ac118b7d6649979a32d5" translate="yes" xml:space="preserve">
          <source>In case you want to use only a subset of the functionality provided by &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Phoenix.Presence&lt;/code&gt;&lt;/a&gt;, such as tracking processes but without broadcasting updates, we recommend that you look at the &lt;a href=&quot;../phoenix_pubsub/phoenix.tracker&quot;&gt;&lt;code&gt;Phoenix.Tracker&lt;/code&gt;&lt;/a&gt; functionality from the &lt;code&gt;phoenix_pubsub&lt;/code&gt; project.</source>
          <target state="translated">如果您只想使用&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Phoenix.Presence&lt;/code&gt; &lt;/a&gt;提供的功能的子集（例如跟踪过程，但不广播更新），建议您查看 &lt;code&gt;phoenix_pubsub&lt;/code&gt; 项目中的&lt;a href=&quot;../phoenix_pubsub/phoenix.tracker&quot;&gt; &lt;code&gt;Phoenix.Tracker&lt;/code&gt; &lt;/a&gt;功能。</target>
        </trans-unit>
        <trans-unit id="e55c4e4ce95987e0fe79dc9dcc20ddcd0ebdbe7f" translate="yes" xml:space="preserve">
          <source>In cases like above, when you want to work only on a single entry, it is much easier to simply work on the associated directly. For example, we could instead set the &lt;code&gt;post&lt;/code&gt; association in the comment:</source>
          <target state="translated">在上述情况下，当您只想处理单个条目时，简单地直接处理关联项要容易得多。例如，我们可以在注释中设置 &lt;code&gt;post&lt;/code&gt; 关联：</target>
        </trans-unit>
        <trans-unit id="1a433a57ec454997093ca88ba782e60cd40611d5" translate="yes" xml:space="preserve">
          <source>In channel tests, we interact with channels via process communication, sending and receiving messages. It is also common to subscribe to the same topic the channel subscribes to, allowing us to assert if a given message was broadcast or not.</source>
          <target state="translated">在渠道测试中,我们经由过程通信与渠道进行交互,发送和接收消息。也常见的是订阅渠道所订阅的同一主题,让我们可以断定某条消息是否被广播。</target>
        </trans-unit>
        <trans-unit id="6d0afdb19d32b80bba27b9edef3ebd1dd1cf2d1d" translate="yes" xml:space="preserve">
          <source>In complex cases, instead of relying on name inference, it may be best to set the constraint name explicitly:</source>
          <target state="translated">在复杂的情况下,与其依赖名称推理,不如明确设置约束名称。</target>
        </trans-unit>
        <trans-unit id="77c8d6fd181489a2dd77e9ab68ac22f7bd4b22c2" translate="yes" xml:space="preserve">
          <source>In fact, given &lt;code&gt;:through&lt;/code&gt; associations are read-only, &lt;strong&gt;using the &lt;a href=&quot;ecto#assoc/2&quot;&gt;&lt;code&gt;Ecto.assoc/2&lt;/code&gt;&lt;/a&gt; format is the preferred mechanism for working with through associations&lt;/strong&gt;. Use the schema-based one only if you need to store the through data alongside of the parent struct, in specific cases such as preloading.</source>
          <target state="translated">实际上，给定 &lt;code&gt;:through&lt;/code&gt; 关联是只读的，&lt;strong&gt;使用&lt;a href=&quot;ecto#assoc/2&quot;&gt; &lt;code&gt;Ecto.assoc/2&lt;/code&gt; &lt;/a&gt;格式是使用through关联的首选机制&lt;/strong&gt;。仅在需要在特定情况下（例如预加载）将父数据与直通数据一起存储时，才使用基于模式的数据。</target>
        </trans-unit>
        <trans-unit id="e209e8446b46f8896bce3d2476eaddc91e35939f" translate="yes" xml:space="preserve">
          <source>In fact, when you invoke this macro, a field with the name of foreign key is automatically defined in the schema for you.</source>
          <target state="translated">事实上,当你调用这个宏时,模式中会自动为你定义一个以外键为名的字段。</target>
        </trans-unit>
        <trans-unit id="c7989d85bf0c7a46c11c45022e7b193d7c4745ef" translate="yes" xml:space="preserve">
          <source>In general, &lt;code&gt;camelize&lt;/code&gt; can be thought of as the reverse of &lt;code&gt;underscore&lt;/code&gt;, however, in some cases formatting may be lost:</source>
          <target state="translated">通常， &lt;code&gt;camelize&lt;/code&gt; 可以被认为是 &lt;code&gt;underscore&lt;/code&gt; 的反义，但是，在某些情况下，格式化可能会丢失：</target>
        </trans-unit>
        <trans-unit id="be090f2c7b49fa10f6982f61cbff56e2c1ea6990" translate="yes" xml:space="preserve">
          <source>In general, &lt;code&gt;underscore&lt;/code&gt; can be thought of as the reverse of &lt;code&gt;camelize&lt;/code&gt;, however, in some cases formatting may be lost:</source>
          <target state="translated">通常， &lt;code&gt;underscore&lt;/code&gt; 可以被认为是 &lt;code&gt;camelize&lt;/code&gt; 的反义词，但是，在某些情况下，格式可能会丢失：</target>
        </trans-unit>
        <trans-unit id="b7a08909ab028a2dad7ca28f19e7788d3cd3e512" translate="yes" xml:space="preserve">
          <source>In general, it's often more convenient to test the mounting of a view in a single step, provided you don't need the result of the stateless HTTP render. This is done with a single call to &lt;a href=&quot;#live/2&quot;&gt;&lt;code&gt;live/2&lt;/code&gt;&lt;/a&gt;, which performs the &lt;code&gt;get&lt;/code&gt; step for us:</source>
          <target state="translated">通常，如果您不需要无状态HTTP渲染的结果，则在一个步骤中测试视图的安装通常会更方便。只需调用&lt;a href=&quot;#live/2&quot;&gt; &lt;code&gt;live/2&lt;/code&gt; &lt;/a&gt;即可完成此操作，该调用将为我们执行 &lt;code&gt;get&lt;/code&gt; 步骤：</target>
        </trans-unit>
        <trans-unit id="364f40e20dd4114a4cbee3580c6cbdd7d7379b01" translate="yes" xml:space="preserve">
          <source>In general, the scoping rules for pipelines behave as you might expect. In this example, all routes will pipe through the &lt;code&gt;:browser&lt;/code&gt; pipeline. However, only the &lt;code&gt;reviews&lt;/code&gt; resources routes will pipe through the &lt;code&gt;:review_checks&lt;/code&gt; pipeline. Since we declared both pipes &lt;code&gt;pipe_through [:browser, :review_checks]&lt;/code&gt; in a list of pipelines, Phoenix will &lt;code&gt;pipe_through&lt;/code&gt; each of them as it invokes them in order.</source>
          <target state="translated">通常，管道的作用域规则表现出预期的效果。在此示例中，所有路由都将通过 &lt;code&gt;:browser&lt;/code&gt; 管道进行管道传输。但是，只有 &lt;code&gt;reviews&lt;/code&gt; 资源路由会通过 &lt;code&gt;:review_checks&lt;/code&gt; 管道传递。由于我们在管道 &lt;code&gt;pipe_through [:browser, :review_checks]&lt;/code&gt; 声明了两个管道pipe_through [：browser，：review_checks]，因此Phoenix会按顺序调用它们， &lt;code&gt;pipe_through&lt;/code&gt; 每个管道进行pipe_through。</target>
        </trans-unit>
        <trans-unit id="dc684728adbd2c911a4a018ef11d85bc94e422b3" translate="yes" xml:space="preserve">
          <source>In many cases, you may want the template format to be set dynamically based on the request. To do so, you can pass the template name as an atom (without the extension):</source>
          <target state="translated">在许多情况下,你可能希望根据请求动态地设置模板格式。要做到这一点,你可以将模板名称作为一个原子传递(不含扩展名)。</target>
        </trans-unit>
        <trans-unit id="7b97ae63daf6461e1b56637fd89a1f07f62a49cf" translate="yes" xml:space="preserve">
          <source>In order for the &lt;code&gt;render/3&lt;/code&gt; function to work correctly, the controller and view must have the same root name, which must also have the same root name as the template directory where the &lt;code&gt;show.html.eex&lt;/code&gt; template lives. In other words, the &lt;code&gt;HelloController&lt;/code&gt; requires &lt;code&gt;HelloView&lt;/code&gt;, and &lt;code&gt;HelloView&lt;/code&gt; requires the existence of the &lt;code&gt;lib/hello_web/templates/hello&lt;/code&gt; directory, which must contain the &lt;code&gt;show.html.eex&lt;/code&gt; template.</source>
          <target state="translated">为了使 &lt;code&gt;render/3&lt;/code&gt; 函数正常工作，控制器和视图必须具有相同的根名称，该根名称也必须与 &lt;code&gt;show.html.eex&lt;/code&gt; 模板所在的模板目录具有相同的根名称。换句话说， &lt;code&gt;HelloController&lt;/code&gt; 需要 &lt;code&gt;HelloView&lt;/code&gt; ，而 &lt;code&gt;HelloView&lt;/code&gt; 需要存在 &lt;code&gt;lib/hello_web/templates/hello&lt;/code&gt; 目录，该目录必须包含 &lt;code&gt;show.html.eex&lt;/code&gt; 模板。</target>
        </trans-unit>
        <trans-unit id="e42e4abc355dbe4c074a8c669e3ce458db628eaf" translate="yes" xml:space="preserve">
          <source>In order for the example above to work, we need to do content negotiation with the accepts plug before rendering. You can do so by adding the following to your pipeline (in the router):</source>
          <target state="translated">为了使上面的例子能够正常工作,我们需要在渲染前与accepts插件进行内容协商。你可以通过在你的管道中添加以下内容来实现(在路由器中)。</target>
        </trans-unit>
        <trans-unit id="85a3f7a925a56f5571d26cd839de4ab3fe0a021b" translate="yes" xml:space="preserve">
          <source>In order to act as a Plug, a function needs to accept a connection struct (&lt;code&gt;%Plug.Conn{}&lt;/code&gt;) and options. It also needs to return a connection struct. Any function that meets those criteria will do. Here's an example.</source>
          <target state="translated">为了充当插件，函数需要接受连接结构（ &lt;code&gt;%Plug.Conn{}&lt;/code&gt; ）和选项。它还需要返回一个连接结构。满足这些条件的任何功能都可以。这是一个例子。</target>
        </trans-unit>
        <trans-unit id="12a19ac64c369cd3aa389e69a402bc23919589b6" translate="yes" xml:space="preserve">
          <source>In order to add custom data attributes you need to pass a tuple containing :data atom and a keyword list with data attributes&amp;rsquo; names and values as the first element in the tag&amp;rsquo;s attributes keyword list:</source>
          <target state="translated">为了添加自定义数据属性，您需要传递一个包含：data原子和带有数据属性名称和值的关键字列表的元组，作为标签属性关键字列表中的第一个元素：</target>
        </trans-unit>
        <trans-unit id="ac088c628be1832c3337855895315bec677904de" translate="yes" xml:space="preserve">
          <source>In order to add custom data attributes you need to pass a tuple containing :data atom and a keyword list with data attributes' names and values as the first element in the tag's attributes keyword list:</source>
          <target state="translated">为了添加自定义数据属性,您需要传递一个包含 :data atom 的元组和一个关键字列表,将数据属性的名称和值作为标签的属性关键字列表中的第一个元素。</target>
        </trans-unit>
        <trans-unit id="4945c44b05e04ace755224f66c5d74d324ac27b2" translate="yes" xml:space="preserve">
          <source>In order to be able to use types such as &lt;code&gt;User.t()&lt;/code&gt;, &lt;code&gt;t/0&lt;/code&gt; has to be defined manually:</source>
          <target state="translated">为了能够使用类型诸如 &lt;code&gt;User.t()&lt;/code&gt; ， &lt;code&gt;t/0&lt;/code&gt; 必须被手动定义：</target>
        </trans-unit>
        <trans-unit id="4fb780465e4f134e43bf1e5f6d0a97198b166675" translate="yes" xml:space="preserve">
          <source>In order to build a Phoenix application, we will need a few dependencies installed in our Operating System:</source>
          <target state="translated">为了构建Phoenix应用程序,我们需要在操作系统中安装一些依赖关系。</target>
        </trans-unit>
        <trans-unit id="3606aa169919759c5ce830a7a86020dbd731405c" translate="yes" xml:space="preserve">
          <source>In order to create a custom exception, we need to define a new module. Conventionally this will have &quot;Error&quot; in the name. Inside of that module, we need to define a new exception with &lt;code&gt;defexception&lt;/code&gt;.</source>
          <target state="translated">为了创建自定义异常，我们需要定义一个新模块。按照惯例，这将在名称中包含&amp;ldquo;错误&amp;rdquo;。在该模块内部，我们需要使用 &lt;code&gt;defexception&lt;/code&gt; 定义一个新异常。</target>
        </trans-unit>
        <trans-unit id="f4270d5af79d57d387989112f1ca66b128244614" translate="yes" xml:space="preserve">
          <source>In order to customize the parameter for any struct, one can simply implement this protocol.</source>
          <target state="translated">为了自定义任何结构的参数,我们可以简单地实现这个协议。</target>
        </trans-unit>
        <trans-unit id="8cea46f6957dacee9307e778c55b234fb7f0b614" translate="yes" xml:space="preserve">
          <source>In order to make it easier to recognize the current &quot;action&quot; your LiveView is on, you can pass the action option when defining LiveViews too:</source>
          <target state="translated">为了更容易识别你的LiveView当前的 &quot;动作&quot;,你也可以在定义LiveViews时传递动作选项。</target>
        </trans-unit>
        <trans-unit id="7fb086d6d7d0263ec8c536ef5b195313198d32a9" translate="yes" xml:space="preserve">
          <source>In order to promote HTML safety, Phoenix templates do not use &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#to_string/1&quot;&gt;&lt;code&gt;Kernel.to_string/1&lt;/code&gt;&lt;/a&gt; to convert data types to strings in templates. Instead, Phoenix uses this protocol which must be implemented by data structures and guarantee that a HTML safe representation is returned.</source>
          <target state="translated">为了提高HTML的安全性，Phoenix模板不使用&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#to_string/1&quot;&gt; &lt;code&gt;Kernel.to_string/1&lt;/code&gt; &lt;/a&gt;将数据类型转换为模板中的字符串。相反，Phoenix使用此协议，该协议必须由数据结构实现，并确保返回HTML安全表示。</target>
        </trans-unit>
        <trans-unit id="a9ca8acf13c91e783afefe3396f6e1d2849afbe0" translate="yes" xml:space="preserve">
          <source>In order to provide better security, this function also enables &lt;code&gt;:reuse_sessions&lt;/code&gt; and &lt;code&gt;:secure_renegotiate&lt;/code&gt; by default, to instruct clients to reuse sessions and enforce secure renegotiation according to RFC 5746 respectively</source>
          <target state="translated">为了提供更好的安全性，此功能还默认启用 &lt;code&gt;:reuse_sessions&lt;/code&gt; 和 &lt;code&gt;:secure_renegotiate&lt;/code&gt; ，以指示客户端重用会话并分别根据RFC 5746强制执行安全重新协商</target>
        </trans-unit>
        <trans-unit id="e5e3499f6e463ee690fd83cb4842e911f3133362" translate="yes" xml:space="preserve">
          <source>In order to run the context generators, we need to come up with a module name that groups the related functionality that we're building. In the &lt;a href=&quot;ecto&quot;&gt;Ecto guide&lt;/a&gt;, we saw how we can use Changesets and Repos to validate and persist user schemas, but we didn't integrate this with our application at large. In fact, we didn't think about where a &quot;user&quot; in our application should live at all. Let's take a step back and think about the different parts of our system. We know that we'll have users of our product. Along with users comes things like account login credentials and user registration. An &lt;code&gt;Accounts&lt;/code&gt; context in our system is a natural place for our user functionality to live.</source>
          <target state="translated">为了运行上下文生成器，我们需要提供一个模块名称，该模块名称将我们正在构建的相关功能分组在一起。在&lt;a href=&quot;ecto&quot;&gt;Ecto指南中&lt;/a&gt;，我们看到了如何使用变更集和Repos来验证和持久化用户模式，但是我们并未将其与整个应用程序集成。实际上，我们根本没有考虑过应用程序中的&amp;ldquo;用户&amp;rdquo;应该放在哪里。让我们退后一步，思考系统的不同部分。我们知道我们将有我们产品的用户。与用户一同出现的还有帐户登录凭据和用户注册之类的东西。我们系统中的 &lt;code&gt;Accounts&lt;/code&gt; 上下文对于我们的用户功能来说是很自然的地方。</target>
        </trans-unit>
        <trans-unit id="e1a30ed29655614d78d7122594af4684bbed32e0" translate="yes" xml:space="preserve">
          <source>In order to see our flash messages, we need to be able to retrieve them and display them in a template/layout. One way to do the first part is with &lt;code&gt;get_flash/2&lt;/code&gt; which takes &lt;code&gt;conn&lt;/code&gt; and the key we care about. It then returns the value for that key.</source>
          <target state="translated">为了查看Flash消息，我们需要能够检索它们并将其显示在模板/布局中。第一部分的一种方法是使用 &lt;code&gt;get_flash/2&lt;/code&gt; ，它使用 &lt;code&gt;conn&lt;/code&gt; 和我们关心的键。然后，它返回该键的值。</target>
        </trans-unit>
        <trans-unit id="2acba69363e13d3b2d19cde17064bc6e54ca91a5" translate="yes" xml:space="preserve">
          <source>In order to support databases that do not have string-based queries, like MongoDB, fragments also allow keywords to be given:</source>
          <target state="translated">为了支持像MongoDB这样没有基于字符串查询的数据库,碎片还允许给出关键字。</target>
        </trans-unit>
        <trans-unit id="62935c8ccc784ab4effb4cd884f492638a038713" translate="yes" xml:space="preserve">
          <source>In order to support links where &lt;code&gt;:method&lt;/code&gt; is not &lt;code&gt;:get&lt;/code&gt; or use the above data attributes, &lt;a href=&quot;phoenix.html&quot;&gt;&lt;code&gt;Phoenix.HTML&lt;/code&gt;&lt;/a&gt; relies on JavaScript. You can load &lt;code&gt;priv/static/phoenix_html.js&lt;/code&gt; into your build tool.</source>
          <target state="translated">为了支持 &lt;code&gt;:method&lt;/code&gt; 不是 &lt;code&gt;:get&lt;/code&gt; 或使用上述数据属性的链接，&lt;a href=&quot;phoenix.html&quot;&gt; &lt;code&gt;Phoenix.HTML&lt;/code&gt; &lt;/a&gt;依赖JavaScript。您可以将 &lt;code&gt;priv/static/phoenix_html.js&lt;/code&gt; 加载到构建工具中。</target>
        </trans-unit>
        <trans-unit id="ac2a23cefe6dc405ba7cba0e86c91036507b2c2a" translate="yes" xml:space="preserve">
          <source>In order to support maps, different databases may employ different techniques. For example, PostgreSQL will store those values in jsonb fields, allowing you to just query parts of it. MSSQL, on the other hand, does not yet provide a JSON type, so the value will be stored in a text field.</source>
          <target state="translated">为了支持地图,不同的数据库可能采用不同的技术。例如,PostgreSQL会将这些值存储在jsonb字段中,允许你只查询其中的一部分。另一方面,MSSQL还没有提供json类型,所以值将被存储在文本字段中。</target>
        </trans-unit>
        <trans-unit id="0cfbb9e0b757e4a7c387f1a89548e61c769c0468" translate="yes" xml:space="preserve">
          <source>In order to support maps, different databases may employ different techniques. For example, PostgreSQL will store those values in jsonb fields, allowing you to just query parts of it. MySQL and MSSQL, on the other hand, do not yet provide a JSON type, so the value will be stored in a text field.</source>
          <target state="translated">为了支持地图,不同的数据库可能采用不同的技术。例如,PostgreSQL会将这些值存储在jsonb字段中,允许你只查询其中的一部分。另一方面,MySQL和MSSQL还没有提供json类型,所以值将被存储在文本字段中。</target>
        </trans-unit>
        <trans-unit id="9cc67ce09af6e2cd4c1b2d88a0add79d7ebdcbc4" translate="yes" xml:space="preserve">
          <source>In order to talk to databases, Phoenix applications use another Elixir package, called &lt;a href=&quot;https://github.com/elixir-ecto/ecto&quot;&gt;Ecto&lt;/a&gt;. If you don't plan to use databases in your application, you can pass the &lt;code&gt;--no-ecto&lt;/code&gt; flag.</source>
          <target state="translated">为了与数据库对话，Phoenix应用程序使用了另一个Elixir软件包，称为&lt;a href=&quot;https://github.com/elixir-ecto/ecto&quot;&gt;Ecto&lt;/a&gt;。如果您不打算在应用程序中使用数据库，则可以传递 &lt;code&gt;--no-ecto&lt;/code&gt; 标志。</target>
        </trans-unit>
        <trans-unit id="58a4eecdb1cbcbbac6d6309d8353c385746bf41f" translate="yes" xml:space="preserve">
          <source>In order to try out &lt;code&gt;redirect/2&lt;/code&gt;, let's create a new route in &lt;code&gt;lib/hello_web/router.ex&lt;/code&gt;.</source>
          <target state="translated">为了尝试 &lt;code&gt;redirect/2&lt;/code&gt; ，让我们在 &lt;code&gt;lib/hello_web/router.ex&lt;/code&gt; 中创建一个新路由。</target>
        </trans-unit>
        <trans-unit id="52e29e7cb4d222c076586aa6d2efe1e067b45ad8" translate="yes" xml:space="preserve">
          <source>In order to use the check constraint, the first step is to define the check constraint in a migration:</source>
          <target state="translated">为了使用检查约束,首先要在迁移中定义检查约束。</target>
        </trans-unit>
        <trans-unit id="631c78b05b032bf7a4bc9563b17081acddc1f9da" translate="yes" xml:space="preserve">
          <source>In order to use the foreign key constraint the first step is to define the foreign key in a migration. This is often done with references. For example, imagine you are creating a comments table that belongs to posts. One would have:</source>
          <target state="translated">为了使用外键约束,第一步是在迁移中定义外键。这通常是通过引用来完成的。例如,想象你正在创建一个属于帖子的评论表。人们会有。</target>
        </trans-unit>
        <trans-unit id="b25785fbeb7db9f5fe5792dc95bd9802bce1df6e" translate="yes" xml:space="preserve">
          <source>In order to use the uniqueness constraint, the first step is to define the unique index in a migration:</source>
          <target state="translated">为了使用唯一性约束,第一步是定义迁移中的唯一索引。</target>
        </trans-unit>
        <trans-unit id="d32962e066707989deb6579a1bef99dfb02fd652" translate="yes" xml:space="preserve">
          <source>In order to, for instance, support slower clients you can tune the &lt;code&gt;:read_length&lt;/code&gt; and &lt;code&gt;:read_timeout&lt;/code&gt; options. These specify how much time should be allowed to pass for each read from the underlying socket.</source>
          <target state="translated">例如，为了支持速度较慢的客户端，您可以调整 &lt;code&gt;:read_length&lt;/code&gt; 和 &lt;code&gt;:read_timeout&lt;/code&gt; read_timeout选项。这些参数指定应允许从底层套接字读取的每次传递多少时间。</target>
        </trans-unit>
        <trans-unit id="f369074781af4e45339cc323b1a66a51339ef0e7" translate="yes" xml:space="preserve">
          <source>In order words, to provide custom error pages, we could simply define a the proper &lt;code&gt;render/2&lt;/code&gt; function clause in &lt;code&gt;HelloWeb.ErrorView&lt;/code&gt;.</source>
          <target state="translated">为了提供自定义错误页面，我们可以简单地在 &lt;code&gt;HelloWeb.ErrorView&lt;/code&gt; 中定义适当的 &lt;code&gt;render/2&lt;/code&gt; 函数子句。</target>
        </trans-unit>
        <trans-unit id="0ee12c14d9ca00e6cf48da215974e95f0c7e5650" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;...&lt;/code&gt; will include all the binding between the first and the last, which may be no binding at all, one or many.</source>
          <target state="translated">换句话说， &lt;code&gt;...&lt;/code&gt; 将包括第一个和最后一个之间的所有绑定，可能根本没有任何一个或多个绑定。</target>
        </trans-unit>
        <trans-unit id="5e53d1f0b2def4882c8f42cb4dd37f4b59fc07c1" translate="yes" xml:space="preserve">
          <source>In other words, LiveView will reload the page in case of errors, making it fail as if LiveView was not involved in the rendering in the first place.</source>
          <target state="translated">换句话说,LiveView会在出现错误的情况下重新加载页面,使其失败,就像LiveView一开始没有参与渲染一样。</target>
        </trans-unit>
        <trans-unit id="e51f1325a0c1718983754df036a306b6fd8fe04b" translate="yes" xml:space="preserve">
          <source>In other words, the inner template is placed in the &lt;code&gt;@inner_content&lt;/code&gt; assign. You can also find which module and template where used to render the inner content by introspecting the &lt;code&gt;@view_module&lt;/code&gt; and &lt;code&gt;@view_template&lt;/code&gt; assigns.</source>
          <target state="translated">换句话说，内部模板放置在 &lt;code&gt;@inner_content&lt;/code&gt; 分配中。您还可以通过内省 &lt;code&gt;@view_module&lt;/code&gt; 和 &lt;code&gt;@view_template&lt;/code&gt; 分配，找到用于渲染内部内容的模块和模板。</target>
        </trans-unit>
        <trans-unit id="8d505d82f389daac5da4c66b35201ad586113ff0" translate="yes" xml:space="preserve">
          <source>In other words, when you find yourself wanting to work only with a subset of the data, then using &lt;a href=&quot;#put_assoc/4&quot;&gt;&lt;code&gt;put_assoc/4&lt;/code&gt;&lt;/a&gt; is most likely unnecessary. Instead, you want to work on the other side of the association.</source>
          <target state="translated">换句话说，当您发现自己只希望处理数据的一个子集时，则很可能不需要使用&lt;a href=&quot;#put_assoc/4&quot;&gt; &lt;code&gt;put_assoc/4&lt;/code&gt; &lt;/a&gt;。相反，您想在关联的另一端工作。</target>
        </trans-unit>
        <trans-unit id="9c973e733faa5d3147a98906879b3bd69d7b92ef" translate="yes" xml:space="preserve">
          <source>In our &lt;a href=&quot;contexts&quot;&gt;context guide&lt;/a&gt;, we'll find out how to wrap up our Ecto access and business logic behind modules that group related functionality. We'll see how Phoenix helps us design maintainable applications, and we'll find out about other neat Ecto features along the way.</source>
          <target state="translated">在&lt;a href=&quot;contexts&quot;&gt;上下文指南中&lt;/a&gt;，我们将找到如何在组合相关功能的模块后面包装Ecto访问和业务逻辑。我们将了解Phoenix是如何帮助我们设计可维护的应用程序的，并在此过程中了解其他整洁的Ecto功能。</target>
        </trans-unit>
        <trans-unit id="6bbbdd02796e8c750180d95d224e10d5ba7f72ee" translate="yes" xml:space="preserve">
          <source>In our example, a &lt;code&gt;User&lt;/code&gt; has and belongs to many &lt;code&gt;Organization&lt;/code&gt;s:</source>
          <target state="translated">在我们的示例中，一个 &lt;code&gt;User&lt;/code&gt; 拥有并属于许多 &lt;code&gt;Organization&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="41ab6ab1980a050c36b66959ba9f3fe938f26932" translate="yes" xml:space="preserve">
          <source>In our example, a User has and belongs to many Organizations</source>
          <target state="translated">在我们的例子中,一个用户拥有并属于许多组织。</target>
        </trans-unit>
        <trans-unit id="0fbfe06d33d66e813a10defbfd79ae7b1d15c17b" translate="yes" xml:space="preserve">
          <source>In particular, controller plugs provide a feature that allows us to execute plugs only within certain actions. For example, you can do:</source>
          <target state="translated">特别是,控制器插头提供了一个功能,允许我们只在某些动作中执行插头。例如,你可以这样做。</target>
        </trans-unit>
        <trans-unit id="b939b666f3565b6620c702bbdd16fc9969fa1e4b" translate="yes" xml:space="preserve">
          <source>In practice, developers rarely use &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Phoenix.Template&lt;/code&gt;&lt;/a&gt; directly. Instead they use &lt;a href=&quot;phoenix.view&quot;&gt;&lt;code&gt;Phoenix.View&lt;/code&gt;&lt;/a&gt; which wraps the template functionality and adds some extra conveniences.</source>
          <target state="translated">实际上，开发人员很少直接使用&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Phoenix.Template&lt;/code&gt; &lt;/a&gt;。相反，他们使用&lt;a href=&quot;phoenix.view&quot;&gt; &lt;code&gt;Phoenix.View&lt;/code&gt; &lt;/a&gt;封装了模板功能并增加了一些额外的便利。</target>
        </trans-unit>
        <trans-unit id="24a1a86627169c9301c553095fe386a37b9ae377" translate="yes" xml:space="preserve">
          <source>In practice, we recommend you to create your own helper with your default builder:</source>
          <target state="translated">在实践中,我们建议你使用默认的构建器创建自己的帮助程序。</target>
        </trans-unit>
        <trans-unit id="e23fb277659a1ad68bfb10ebf634617c8f5908ca" translate="yes" xml:space="preserve">
          <source>In some cases - often in &lt;code&gt;index&lt;/code&gt; actions, for instance - we don't care about parameters because our behavior doesn't depend on them. In those cases, we don't use the incoming params, and simply prepend the variable name with an underscore, &lt;code&gt;_params&lt;/code&gt;. This will keep the compiler from complaining about the unused variable while still keeping the correct arity.</source>
          <target state="translated">在某些情况下（例如，通常在 &lt;code&gt;index&lt;/code&gt; 操作中），我们不在乎参数，因为我们的行为不依赖于参数。在这种情况下，我们不使用传入的参数，而只是在变量名前加上下划线 &lt;code&gt;_params&lt;/code&gt; 。这将使编译器不会抱怨未使用的变量，同时仍保持正确的Arity。</target>
        </trans-unit>
        <trans-unit id="993fe331f8eff395e53c329f899a97ba23a0a92b" translate="yes" xml:space="preserve">
          <source>In some cases, you may wish to boostrap the context module and tests, but leave internal implementation of the context and schema to yourself. Use the &lt;code&gt;--no-schema&lt;/code&gt; flags to accomplish this.</source>
          <target state="translated">在某些情况下，您可能希望加强上下文模块和测试，但将上下文和架构的内部实现留给自己。使用 &lt;code&gt;--no-schema&lt;/code&gt; 标志可完成此操作。</target>
        </trans-unit>
        <trans-unit id="7cd22eb2e0cd9838b3868b47d0fdae86fdaf59c8" translate="yes" xml:space="preserve">
          <source>In some cases, you may wish to bootstrap HTML templates, LiveViews, and tests, but leave internal implementation of the context or schema to yourself. You can use the &lt;code&gt;--no-context&lt;/code&gt; and &lt;code&gt;--no-schema&lt;/code&gt; flags for file generation control.</source>
          <target state="translated">在某些情况下，您可能希望引导HTML模板，LiveView和测试，但是将上下文或架构的内部实现留给自己。您可以使用 &lt;code&gt;--no-context&lt;/code&gt; 和 &lt;code&gt;--no-schema&lt;/code&gt; 标志进行文件生成控制。</target>
        </trans-unit>
        <trans-unit id="35ee16ec6c8361255e6bb80285b427eaac9246a7" translate="yes" xml:space="preserve">
          <source>In some cases, you may wish to bootstrap HTML templates, controllers, and controller tests, but leave internal implementation of the context or schema to yourself. You can use the &lt;code&gt;--no-context&lt;/code&gt; and &lt;code&gt;--no-schema&lt;/code&gt; flags for file generation control.</source>
          <target state="translated">在某些情况下，您可能希望引导HTML模板，控制器和控制器测试，但是将上下文或架构的内部实现留给您自己。您可以使用 &lt;code&gt;--no-context&lt;/code&gt; 和 &lt;code&gt;--no-schema&lt;/code&gt; 标志进行文件生成控制。</target>
        </trans-unit>
        <trans-unit id="ade3a11fcd46e0424822bf48a04573731b62fbef" translate="yes" xml:space="preserve">
          <source>In some cases, you may wish to bootstrap JSON views, controllers, and controller tests, but leave internal implementation of the context or schema to yourself. You can use the &lt;code&gt;--no-context&lt;/code&gt; and &lt;code&gt;--no-schema&lt;/code&gt; flags for file generation control.</source>
          <target state="translated">在某些情况下，您可能希望引导JSON视图，控制器和控制器测试，但是将上下文或架构的内部实现留给自己。您可以使用 &lt;code&gt;--no-context&lt;/code&gt; 和 &lt;code&gt;--no-schema&lt;/code&gt; 标志进行文件生成控制。</target>
        </trans-unit>
        <trans-unit id="f55011b0377dd613950bd33fc87827f221a7e3b5" translate="yes" xml:space="preserve">
          <source>In some cases, you may wish to bootstrap the context module and tests, but leave internal implementation of the context and schema to yourself. Use the &lt;code&gt;--no-schema&lt;/code&gt; flags to accomplish this.</source>
          <target state="translated">在某些情况下，您可能希望引导上下文模块和测试，但是将上下文和架构的内部实现留给自己。使用 &lt;code&gt;--no-schema&lt;/code&gt; 标志可完成此操作。</target>
        </trans-unit>
        <trans-unit id="24c4866aacf268fba081667d7687cebfe5f62ff4" translate="yes" xml:space="preserve">
          <source>In some cases, you might need to render based on the template. For these cases, &lt;code&gt;@view_template&lt;/code&gt; can pair with &lt;a href=&quot;#render_existing/3&quot;&gt;&lt;code&gt;render_existing/3&lt;/code&gt;&lt;/a&gt; for per-template based content, ie:</source>
          <target state="translated">在某些情况下，您可能需要根据模板进行渲染。对于这些情况， &lt;code&gt;@view_template&lt;/code&gt; 可以与&lt;a href=&quot;#render_existing/3&quot;&gt; &lt;code&gt;render_existing/3&lt;/code&gt; &lt;/a&gt;配对以获取基于每个模板的内容，即：</target>
        </trans-unit>
        <trans-unit id="9b384998377753d90d4408512efaa31439cf25f8" translate="yes" xml:space="preserve">
          <source>In some cases, you will want to broadcast messages without the context of a &lt;code&gt;socket&lt;/code&gt;. This could be for broadcasting from within your channel to an external topic, or broadcasting from elsewhere in your application like a controller or another process. Such can be done via your endpoint:</source>
          <target state="translated">在某些情况下，您可能想在没有 &lt;code&gt;socket&lt;/code&gt; 上下文的情况下广播消息。这可能是为了从您的频道内部广播到外部主题，或者是从应用程序中的其他位置（例如控制器或其他进程）广播。这可以通过您的端点来完成：</target>
        </trans-unit>
        <trans-unit id="556542b6153a0a9877d7ad7e8e95684ac07433c4" translate="yes" xml:space="preserve">
          <source>In some cases, you&amp;rsquo;ll need to generate a request&amp;rsquo;s URL, but using a different scheme, different host, etc. This can be accomplished by concatentating the request path with a custom built URL from your Router helpers, another Endpoint, mix config, or a hand-built string.</source>
          <target state="translated">在某些情况下，您需要生成请求的URL，但是使用不同的方案，不同的主机等。这可以通过将请求路径与来自路由器助手，另一个端点，混合配置，或手工制作的字符串。</target>
        </trans-unit>
        <trans-unit id="5d135b52253ea1f76dc118e79a5ba5024dc31ed9" translate="yes" xml:space="preserve">
          <source>In some cases, you'll need to generate a request's URL, but using a different scheme, different host, etc. This can be accomplished in two ways.</source>
          <target state="translated">在某些情况下,你需要生成一个请求的URL,但使用不同的方案、不同的主机等。这可以通过两种方式来实现。</target>
        </trans-unit>
        <trans-unit id="925f7c8aaf0732c9cba3eed658f8290b2a10f60a" translate="yes" xml:space="preserve">
          <source>In stateful components, &lt;a href=&quot;#c:mount/1&quot;&gt;&lt;code&gt;mount/1&lt;/code&gt;&lt;/a&gt; is called only once, when the component is first rendered. For each rendering, the optional &lt;a href=&quot;#c:preload/1&quot;&gt;&lt;code&gt;preload/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#c:update/2&quot;&gt;&lt;code&gt;update/2&lt;/code&gt;&lt;/a&gt; callbacks are called before &lt;a href=&quot;#c:render/1&quot;&gt;&lt;code&gt;render/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在有状态组件中，第一次渲染该组件时，&lt;a href=&quot;#c:mount/1&quot;&gt; &lt;code&gt;mount/1&lt;/code&gt; &lt;/a&gt;仅被调用一次。对于每个渲染，在&lt;a href=&quot;#c:render/1&quot;&gt; &lt;code&gt;render/1&lt;/code&gt; &lt;/a&gt;之前调用可选的&lt;a href=&quot;#c:preload/1&quot;&gt; &lt;code&gt;preload/1&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#c:update/2&quot;&gt; &lt;code&gt;update/2&lt;/code&gt; &lt;/a&gt;回调。</target>
        </trans-unit>
        <trans-unit id="ac3f1efde90130546f23b2c2f904814fe3e8fcab" translate="yes" xml:space="preserve">
          <source>In such cases it is possible to pass the private key directly, using the &lt;code&gt;:key&lt;/code&gt; parameter. For example, assuming an RSA private key is available in the PRIVKEY environment variable in Base64 encoded DER format, the key may be set as follows:</source>
          <target state="translated">在这种情况下，可以使用 &lt;code&gt;:key&lt;/code&gt; 参数直接传递私钥。例如，假设RSAIV私钥在BaseIV编码的DER格式的PRIVKEY环境变量中可用，则可以如下设置私钥：</target>
        </trans-unit>
        <trans-unit id="68280495d51817872c43fe92d60a5737a8f25c18" translate="yes" xml:space="preserve">
          <source>In that example we have a user&amp;rsquo;s id, we generate a token and verify it using the secret key base configured in the given &lt;code&gt;endpoint&lt;/code&gt;. We guarantee the token will only be valid for one day by setting a max age (recommended).</source>
          <target state="translated">在该示例中，我们有一个用户ID，我们生成一个令牌，并使用给定 &lt;code&gt;endpoint&lt;/code&gt; 配置的密钥库对其进行验证。我们通过设置最长期限来保证令牌仅在一天内有效（建议）。</target>
        </trans-unit>
        <trans-unit id="1f41f3118259de0c9215a6b06e0067217d596aea" translate="yes" xml:space="preserve">
          <source>In that example we have a user's id, we generate a token and verify it using the secret key base configured in the given &lt;code&gt;endpoint&lt;/code&gt;. We guarantee the token will only be valid for one day by setting a max age (recommended).</source>
          <target state="translated">在该示例中，我们有一个用户ID，我们生成一个令牌，并使用给定 &lt;code&gt;endpoint&lt;/code&gt; 配置的密钥库对其进行验证。我们通过设置最长期限来保证令牌仅在一天内有效（建议）。</target>
        </trans-unit>
        <trans-unit id="fd49de9316bf15faaf745aa97193e59f4c5ce77a" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;changeset/2&lt;/code&gt; function above, we define three validations. They check that &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;email&lt;/code&gt; fields are present in the changeset, the e-mail is of the specified format, and the age is between 18 and 100 - as well as a unique constraint in the email field.</source>
          <target state="translated">在上面的 &lt;code&gt;changeset/2&lt;/code&gt; 函数中，我们定义了三个验证。他们检查更改集中是否存在 &lt;code&gt;name&lt;/code&gt; 和 &lt;code&gt;email&lt;/code&gt; 字段，电子邮件是否具有指定的格式以及年龄在18到100之间-以及电子邮件字段中的唯一约束。</target>
        </trans-unit>
        <trans-unit id="2beaddf1dc1af0a0afed02b2665a4c614e8c9fe1" translate="yes" xml:space="preserve">
          <source>In the CTE query itself use the same table name to leverage recursion that has been passed to the &lt;code&gt;name&lt;/code&gt; argument. Make sure to write a stop condition to avoid infinite recursion loop. Generally speaking, you should only use CTEs in Ecto for writing recursive queries.</source>
          <target state="translated">在CTE查询本身中，使用相同的表名来利用已传递给 &lt;code&gt;name&lt;/code&gt; 参数的递归。确保编写停止条件，以避免无限递归循环。一般来说，您仅应在Ecto中使用CTE编写递归查询。</target>
        </trans-unit>
        <trans-unit id="3ea091611015f8ec7cc9dd9fea5d96ed83e209c4" translate="yes" xml:space="preserve">
          <source>In the above example, &lt;code&gt;with&lt;/code&gt; is used to match only a successful post fetch, followed by valid authorization for the current user. In the event either of those fail to match, &lt;code&gt;with&lt;/code&gt; will not invoke the render block and instead return the unmatched value. In this case, imagine &lt;code&gt;Blog.fetch_post/2&lt;/code&gt; returned &lt;code&gt;{:error, :not_found}&lt;/code&gt; or &lt;code&gt;Authorizer.authorize/3&lt;/code&gt; returned &lt;code&gt;{:error, :unauthorized}&lt;/code&gt;. For cases where these data structures serve as return values across multiple boundaries in our domain, a single fallback module can be used to translate the value into a valid response. For example, you could write the following fallback controller to handle the above values:</source>
          <target state="translated">在上面的示例中， &lt;code&gt;with&lt;/code&gt; 用于仅匹配成功的后提取，后跟当前用户的有效授权。如果其中任何一个都不匹配，则 &lt;code&gt;with&lt;/code&gt; 不会调用render块，而是返回不匹配的值。在这种情况下，假设 &lt;code&gt;Blog.fetch_post/2&lt;/code&gt; 返回 &lt;code&gt;{:error, :not_found}&lt;/code&gt; 或 &lt;code&gt;Authorizer.authorize/3&lt;/code&gt; 返回 &lt;code&gt;{:error, :unauthorized}&lt;/code&gt; 。对于这些数据结构充当我们域中多个边界的返回值的情况，可以使用单个后备模块将值转换为有效响应。例如，您可以编写以下后备控制器来处理上述值：</target>
        </trans-unit>
        <trans-unit id="5795255717d6356ac87649a6472e670f2673298a" translate="yes" xml:space="preserve">
          <source>In the above example, &lt;code&gt;with&lt;/code&gt; is used to match only a successful post fetch, followed by valid authorization for the current user. In the event either of those fail to match, &lt;code&gt;with&lt;/code&gt; will not invoke the render block and instead return the unmatched value. In this case, imagine &lt;code&gt;Blog.fetch_post/2&lt;/code&gt; returned &lt;code&gt;{:error, :not_found}&lt;/code&gt; or &lt;code&gt;Authorizer.authorize/3&lt;/code&gt; returned &lt;code&gt;{:error, :unauthorized}&lt;/code&gt;. For cases where these datastructures serve as return values across multiple boundaries in our domain, a single fallback module can be used to translate the value into a valid response. For example, you could write the following fallback controller to handle the above values:</source>
          <target state="translated">在上面的示例中， &lt;code&gt;with&lt;/code&gt; 用于仅匹配成功的后提取，后跟当前用户的有效授权。如果两者都不匹配，则 &lt;code&gt;with&lt;/code&gt; 不会调用render块，而是返回不匹配的值。在这种情况下，假设 &lt;code&gt;Blog.fetch_post/2&lt;/code&gt; 返回 &lt;code&gt;{:error, :not_found}&lt;/code&gt; 或 &lt;code&gt;Authorizer.authorize/3&lt;/code&gt; 返回 &lt;code&gt;{:error, :unauthorized}&lt;/code&gt; 。对于这些数据结构充当我们域中多个边界的返回值的情况，可以使用单个后备模块将值转换为有效响应。例如，您可以编写以下后备控制器来处理上述值：</target>
        </trans-unit>
        <trans-unit id="3b1b0c0a37a5ad734fd8c9a63cf167f822b9d6d7" translate="yes" xml:space="preserve">
          <source>In the assertion above, we don&amp;rsquo;t particularly care about the data being sent, as long as something was replied.</source>
          <target state="translated">在上面的断言中，只要有响应，我们就不会特别在意发送的数据。</target>
        </trans-unit>
        <trans-unit id="687f064f0b397a245fd7efdac2c169e020ea3fe3" translate="yes" xml:space="preserve">
          <source>In the assertion above, we don&amp;rsquo;t particularly care about the data being sent, as long as something was sent.</source>
          <target state="translated">在上面的断言中，只要发送了某些内容，我们就不会特别在乎发送的数据。</target>
        </trans-unit>
        <trans-unit id="1ed97cc0df14884c8ffa3bce15edcee614a81a95" translate="yes" xml:space="preserve">
          <source>In the assertion above, we don't particularly care about the data being sent, as long as something was replied.</source>
          <target state="translated">在上面的论断中,我们并不是特别在意数据的发送,只要有东西被回复就可以了。</target>
        </trans-unit>
        <trans-unit id="bfd5bb81c813b68dd4c64063dd42225fe58dd0c8" translate="yes" xml:space="preserve">
          <source>In the assertion above, we don't particularly care about the data being sent, as long as something was sent.</source>
          <target state="translated">在上面的论断中,我们并不是特别在意数据的发送,只要发送了一些东西就可以了。</target>
        </trans-unit>
        <trans-unit id="7dbfb137b25284ebef7ca3ab66b80ac42b70e667" translate="yes" xml:space="preserve">
          <source>In the case of an &lt;code&gt;&quot;element&quot;&lt;/code&gt; page loading event, the info will contain a &lt;code&gt;&quot;target&quot;&lt;/code&gt; key containing the DOM element which triggered the page loading state.</source>
          <target state="translated">在发生 &lt;code&gt;&quot;element&quot;&lt;/code&gt; 页面加载事件的情况下，该信息将包含一个 &lt;code&gt;&quot;target&quot;&lt;/code&gt; 键，该键包含触发页面加载状态的DOM元素。</target>
        </trans-unit>
        <trans-unit id="5f28e9a6e41b204ed7eb1de0dc4ea78da2108aed" translate="yes" xml:space="preserve">
          <source>In the case of forms, when a &lt;code&gt;phx-change&lt;/code&gt; is sent to the server, the input element which emitted the change receives the &lt;code&gt;phx-change-loading&lt;/code&gt; class, along with the parent form tag. The following events receive css loading classes:</source>
          <target state="translated">对于表单，将 &lt;code&gt;phx-change&lt;/code&gt; 发送到服务器时，发出更改的输入元素将接收 &lt;code&gt;phx-change-loading&lt;/code&gt; 类以及父表单标签。以下事件接收css加载类：</target>
        </trans-unit>
        <trans-unit id="19c0702d49a6fa9644c129eb1cbc189ec43c7c1d" translate="yes" xml:space="preserve">
          <source>In the case of our &lt;code&gt;create&lt;/code&gt; action, when we successfully create a user, we use &lt;a href=&quot;phoenix.controller#put_flash/3&quot;&gt;&lt;code&gt;Phoenix.Controller.put_flash/3&lt;/code&gt;&lt;/a&gt; to show a success message, and then we redirect to the &lt;code&gt;user_path&lt;/code&gt;'s show page. Conversely, if &lt;code&gt;Accounts.create_user/1&lt;/code&gt; fails, we render our &lt;code&gt;&quot;new.html&quot;&lt;/code&gt; template and pass along the Ecto changeset for the template to lift error messages from.</source>
          <target state="translated">对于 &lt;code&gt;create&lt;/code&gt; 动作，当我们成功创建用户时，我们使用&lt;a href=&quot;phoenix.controller#put_flash/3&quot;&gt; &lt;code&gt;Phoenix.Controller.put_flash/3&lt;/code&gt; &lt;/a&gt;显示成功消息，然后重定向到 &lt;code&gt;user_path&lt;/code&gt; 的show页面。相反，如果 &lt;code&gt;Accounts.create_user/1&lt;/code&gt; 失败，我们将呈现 &lt;code&gt;&quot;new.html&quot;&lt;/code&gt; 模板，并传递该模板的Ecto变更集以从中提取错误消息。</target>
        </trans-unit>
        <trans-unit id="6084cacdb41ec7942b3031f9f8713fcd0287545b" translate="yes" xml:space="preserve">
          <source>In the changeset examples so far, we have always used changesets to validate and cast data contained in a struct defined by an Ecto schema, such as the &lt;code&gt;%User{}&lt;/code&gt; struct defined by the &lt;code&gt;User&lt;/code&gt; module.</source>
          <target state="translated">到目前为止，在变更集示例中，我们始终使用变更集来验证和转换包含在Ecto模式定义的结构中的数据，例如 &lt;code&gt;User&lt;/code&gt; 模块定义的 &lt;code&gt;%User{}&lt;/code&gt; 结构。</target>
        </trans-unit>
        <trans-unit id="6967baeb41fe4aaf65135be1a86f7b7f51cb74b8" translate="yes" xml:space="preserve">
          <source>In the default &lt;a href=&quot;phoenix.socket&quot;&gt;&lt;code&gt;Phoenix.Socket&lt;/code&gt;&lt;/a&gt; implementation, the metadata expects the following keys:</source>
          <target state="translated">在默认的&lt;a href=&quot;phoenix.socket&quot;&gt; &lt;code&gt;Phoenix.Socket&lt;/code&gt; &lt;/a&gt;实现中，元数据需要以下键：</target>
        </trans-unit>
        <trans-unit id="de678a4f657d9a0b14e4ad6c02a818dd6a2f267d" translate="yes" xml:space="preserve">
          <source>In the documentation below, we will explain how it works internally. For user-facing documentation, see &lt;a href=&quot;phoenix.liveview&quot;&gt;&lt;code&gt;Phoenix.LiveView&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在下面的文档中，我们将解释其内部工作方式。有关面向用户的文档，请参见&lt;a href=&quot;phoenix.liveview&quot;&gt; &lt;code&gt;Phoenix.LiveView&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c05024d1d5f114eed84c10173ddb5b0423ed6df3" translate="yes" xml:space="preserve">
          <source>In the example above we relied on our schema but queries can also be made directly against a table by giving the table name as a string. In such cases, the data to be fetched must be explicitly outlined:</source>
          <target state="translated">在上面的例子中,我们依靠我们的模式,但也可以直接对一个表进行查询,将表名作为一个字符串。在这种情况下,必须明确概述要获取的数据。</target>
        </trans-unit>
        <trans-unit id="77e215827ec3fbaaba50e0c67d6aa3a380c28048" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;a href=&quot;#build_assoc/3&quot;&gt;&lt;code&gt;Ecto.build_assoc/3&lt;/code&gt;&lt;/a&gt; is equivalent to:</source>
          <target state="translated">在上面的示例中，&lt;a href=&quot;#build_assoc/3&quot;&gt; &lt;code&gt;Ecto.build_assoc/3&lt;/code&gt; &lt;/a&gt;等效于：</target>
        </trans-unit>
        <trans-unit id="6980dcf932f4756073eec7951985832bf4ffdbc2" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;a href=&quot;ecto#build_assoc/3&quot;&gt;&lt;code&gt;Ecto.build_assoc/3&lt;/code&gt;&lt;/a&gt; is equivalent to:</source>
          <target state="translated">在上面的示例中，&lt;a href=&quot;ecto#build_assoc/3&quot;&gt; &lt;code&gt;Ecto.build_assoc/3&lt;/code&gt; &lt;/a&gt;等效于：</target>
        </trans-unit>
        <trans-unit id="c0efaf4e38ac06de9330c96ca3071c0aa49d7d17" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;code&gt;conn.assigns[:an_option]&lt;/code&gt; will be available to all plugs invoked after &lt;code&gt;:match&lt;/code&gt;. Such plugs can read from &lt;code&gt;conn.assigns&lt;/code&gt; (or &lt;code&gt;conn.private&lt;/code&gt;) to configure their behaviour based on the matched route.</source>
          <target state="translated">在上面的示例中， &lt;code&gt;conn.assigns[:an_option]&lt;/code&gt; 将可用于 &lt;code&gt;:match&lt;/code&gt; 之后调用的所有插头。可以从 &lt;code&gt;conn.assigns&lt;/code&gt; （或 &lt;code&gt;conn.private&lt;/code&gt; ）中读取此类插件，以根据匹配的路由配置其行为。</target>
        </trans-unit>
        <trans-unit id="12b582e24c785d7e528d91beeaeb2094948f8201" translate="yes" xml:space="preserve">
          <source>In the example above, Ecto will cast the age to type integer. When a value cannot be cast, &lt;a href=&quot;ecto.query.casterror&quot;&gt;&lt;code&gt;Ecto.Query.CastError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">在上面的示例中，Ecto将把年龄强制转换为整数类型。当无法&lt;a href=&quot;ecto.query.casterror&quot;&gt; &lt;code&gt;Ecto.Query.CastError&lt;/code&gt; &lt;/a&gt;值时，将引发Ecto.Query.CastError。</target>
        </trans-unit>
        <trans-unit id="952705a8404ece781d990a44fb37e80f3335cc68" translate="yes" xml:space="preserve">
          <source>In the example above, LiveView will lookup for an element with ID=user-13 and retrieve its &lt;code&gt;phx-target&lt;/code&gt;. If &lt;code&gt;phx-target&lt;/code&gt; points to a component, that will be the component used, otherwise it will fallback to the view.</source>
          <target state="translated">在上面的示例中，LiveView将查找ID = user-13的元素并检索其 &lt;code&gt;phx-target&lt;/code&gt; 。如果 &lt;code&gt;phx-target&lt;/code&gt; 指向一个组件，则它将是所使用的组件，否则它将回退到视图。</target>
        </trans-unit>
        <trans-unit id="38da296833b2b1ef41965ac27af71cead65925f5" translate="yes" xml:space="preserve">
          <source>In the example above, a request will only match if it is a &lt;code&gt;GET&lt;/code&gt; request and the route is &quot;/hello&quot;. The supported HTTP methods are &lt;code&gt;get&lt;/code&gt;, &lt;code&gt;post&lt;/code&gt;, &lt;code&gt;put&lt;/code&gt;, &lt;code&gt;patch&lt;/code&gt;, &lt;code&gt;delete&lt;/code&gt; and &lt;code&gt;options&lt;/code&gt;.</source>
          <target state="translated">在上面的示例中，仅当请求是 &lt;code&gt;GET&lt;/code&gt; 请求且路由为&amp;ldquo; / hello&amp;rdquo;时，该请求才匹配。支持的HTTP方法是 &lt;code&gt;get&lt;/code&gt; ， &lt;code&gt;post&lt;/code&gt; ， &lt;code&gt;put&lt;/code&gt; ， &lt;code&gt;patch&lt;/code&gt; ， &lt;code&gt;delete&lt;/code&gt; 和 &lt;code&gt;options&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8a6032006ee3190bfba008183ef22c7724958741" translate="yes" xml:space="preserve">
          <source>In the example above, a request will only match if it is a &lt;code&gt;GET&lt;/code&gt; request and the route is &amp;ldquo;/hello&amp;rdquo;. The supported HTTP methods are &lt;code&gt;get&lt;/code&gt;, &lt;code&gt;post&lt;/code&gt;, &lt;code&gt;put&lt;/code&gt;, &lt;code&gt;patch&lt;/code&gt;, &lt;code&gt;delete&lt;/code&gt; and &lt;code&gt;options&lt;/code&gt;.</source>
          <target state="translated">在上面的示例中，仅当请求是 &lt;code&gt;GET&lt;/code&gt; 请求且路由为&amp;ldquo; / hello&amp;rdquo;时，该请求才匹配。支持的HTTP方法是 &lt;code&gt;get&lt;/code&gt; ， &lt;code&gt;post&lt;/code&gt; ， &lt;code&gt;put&lt;/code&gt; ， &lt;code&gt;patch&lt;/code&gt; ， &lt;code&gt;delete&lt;/code&gt; 和 &lt;code&gt;options&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cbb4d85bfa68b487dba755bf14be4d94f034f1c7" translate="yes" xml:space="preserve">
          <source>In the example above, both &lt;code&gt;at_least_four(:doors)&lt;/code&gt; and &lt;code&gt;at_least_four(:tires)&lt;/code&gt; would be valid calls as the field is dynamically generated.</source>
          <target state="translated">在上面的示例中，由于该字段是动态生成的，所以 &lt;code&gt;at_least_four(:doors)&lt;/code&gt; 和 &lt;code&gt;at_least_four(:tires)&lt;/code&gt; 都是有效的调用。</target>
        </trans-unit>
        <trans-unit id="f151d0619adc353362eafc28e0ed90d66415139d" translate="yes" xml:space="preserve">
          <source>In the example above, instead of issuing a separate query to fetch comments, Ecto will fetch posts and comments in a single query and then do a separate pass associating each comment to its parent post. Therefore, instead of returning &lt;code&gt;number_of_posts * number_of_comments&lt;/code&gt; results, like a &lt;code&gt;join&lt;/code&gt; would, it returns only posts with the &lt;code&gt;comments&lt;/code&gt; fields properly filled in.</source>
          <target state="translated">在上面的示例中，Ecto不会发出单独的查询来获取评论，而是会在单个查询中获取帖子和评论，然后进行单独的传递，将每个评论与其父帖子相关联。因此，而不是返回 &lt;code&gt;number_of_posts * number_of_comments&lt;/code&gt; 结果，就像一个 &lt;code&gt;join&lt;/code&gt; 会，它返回一个唯一的帖子 &lt;code&gt;comments&lt;/code&gt; 正确填写领域。</target>
        </trans-unit>
        <trans-unit id="b8024bb268a6b569b23e03a0cc2bbfe6ea4b6c5f" translate="yes" xml:space="preserve">
          <source>In the example above, the Blog context receives the user on both &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;update&lt;/code&gt; operations, and always validates accordingly that the user has access, raising an error otherwise.</source>
          <target state="translated">在上面的示例中，Blog上下文在 &lt;code&gt;get&lt;/code&gt; 和 &lt;code&gt;update&lt;/code&gt; 操作上都接收用户，并始终相应地验证用户具有访问权限，否则会引发错误。</target>
        </trans-unit>
        <trans-unit id="c4efbfdb8b81848fa5c5be65d29714905c426ad1" translate="yes" xml:space="preserve">
          <source>In the example above, the current presence information for the socket&amp;rsquo;s topic is pushed to the client as a &lt;code&gt;&quot;presence_state&quot;&lt;/code&gt; event. Next, &lt;code&gt;Presence.track&lt;/code&gt; is used to register this channel&amp;rsquo;s process as a presence for the socket&amp;rsquo;s user ID, with a map of metadata.</source>
          <target state="translated">在上面的示例中，套接字主题的当前状态信息作为 &lt;code&gt;&quot;presence_state&quot;&lt;/code&gt; 事件被推送到客户端。接下来， &lt;code&gt;Presence.track&lt;/code&gt; 用于通过元数据映射将该通道的过程注册为套接字用户ID的存在。</target>
        </trans-unit>
        <trans-unit id="b93b04f9b48d20bfebf57013a4e3bc857f160f52" translate="yes" xml:space="preserve">
          <source>In the example above, the current presence information for the socket's topic is pushed to the client as a &lt;code&gt;&quot;presence_state&quot;&lt;/code&gt; event. Next, &lt;code&gt;Presence.track&lt;/code&gt; is used to register this channel's process as a presence for the socket's user ID, with a map of metadata.</source>
          <target state="translated">在上面的示例中，套接字主题的当前状态信息作为 &lt;code&gt;&quot;presence_state&quot;&lt;/code&gt; 事件被推送到客户端。接下来， &lt;code&gt;Presence.track&lt;/code&gt; 用于使用元数据映射将该通道的过程注册为套接字用户ID的存在。</target>
        </trans-unit>
        <trans-unit id="0c5fb7697f09cc5ff0d4a520eb43540e86b99510" translate="yes" xml:space="preserve">
          <source>In the example above, the query is built little by little by merging into a final map. If both conditions above are true, the final query would be equivalent to:</source>
          <target state="translated">在上面的例子中,查询是通过合并成最终的地图一点一点建立起来的。如果上述两个条件都为真,那么最终的查询就相当于。</target>
        </trans-unit>
        <trans-unit id="d450f61126463b7084c0897c03bca594be4602a6" translate="yes" xml:space="preserve">
          <source>In the example above, two events will be emitted:</source>
          <target state="translated">在上面的例子中,将发出两个事件。</target>
        </trans-unit>
        <trans-unit id="d58aedac2b16ebd09d651ee588fbf1ba5cf17edd" translate="yes" xml:space="preserve">
          <source>In the example above, we are directly querying the &quot;users&quot; table from the database.</source>
          <target state="translated">在上面的例子中,我们直接从数据库中查询 &quot;用户 &quot;表。</target>
        </trans-unit>
        <trans-unit id="925feb16ac76c5d3be11e92f48d4338c9def7879" translate="yes" xml:space="preserve">
          <source>In the example above, we are directly querying the &amp;ldquo;users&amp;rdquo; table from the database.</source>
          <target state="translated">在上面的示例中，我们直接从数据库中查询&amp;ldquo;用户&amp;rdquo;表。</target>
        </trans-unit>
        <trans-unit id="0bdcc56455db35f7ec8e6aad2349adff0d37f04a" translate="yes" xml:space="preserve">
          <source>In the example above, we are using the lower procedure in the database to downcase the title column.</source>
          <target state="translated">在上面的例子中,我们使用数据库中的下级过程来下调标题列。</target>
        </trans-unit>
        <trans-unit id="6d69428195f2828f8a6f3b10d5d7bcaad49a7a54" translate="yes" xml:space="preserve">
          <source>In the example above, we get the average salary per department. &lt;code&gt;:department&lt;/code&gt; is the window name, partitioned by &lt;code&gt;e.depname&lt;/code&gt; and &lt;a href=&quot;#avg/1&quot;&gt;&lt;code&gt;avg/1&lt;/code&gt;&lt;/a&gt; is the window function.</source>
          <target state="translated">在上面的示例中，我们获得了每个部门的平均工资。 &lt;code&gt;:department&lt;/code&gt; 是窗口名称，按 &lt;code&gt;e.depname&lt;/code&gt; 进行分区，而&lt;a href=&quot;#avg/1&quot;&gt; &lt;code&gt;avg/1&lt;/code&gt; &lt;/a&gt;是窗口函数。</target>
        </trans-unit>
        <trans-unit id="e6d3d727bce6283546ba164b37335f9c8037c441" translate="yes" xml:space="preserve">
          <source>In the example above, we get the average salary per department. &lt;code&gt;:department&lt;/code&gt; is the window name, partitioned by &lt;code&gt;e.depname&lt;/code&gt; and &lt;code&gt;avg/1&lt;/code&gt; is the window function. For more information on windows functions, see &lt;a href=&quot;ecto.query.windowapi&quot;&gt;&lt;code&gt;Ecto.Query.WindowAPI&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在上面的示例中，我们获得了每个部门的平均工资。 &lt;code&gt;:department&lt;/code&gt; 是窗口名称，按 &lt;code&gt;e.depname&lt;/code&gt; 进行分区，而 &lt;code&gt;avg/1&lt;/code&gt; 是窗口函数。有关Windows函数的更多信息，请参见&lt;a href=&quot;ecto.query.windowapi&quot;&gt; &lt;code&gt;Ecto.Query.WindowAPI&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9b237c8ca61ef3e508aa687be188e40ca4adf22f" translate="yes" xml:space="preserve">
          <source>In the example above, we have defined a &lt;code&gt;has_many :through&lt;/code&gt; association named &lt;code&gt;:comments_authors&lt;/code&gt;. A &lt;code&gt;:through&lt;/code&gt; association always expects a list and the first element of the list must be a previously defined association in the current module. For example, &lt;code&gt;:comments_authors&lt;/code&gt; first points to &lt;code&gt;:comments&lt;/code&gt; in the same module (Post), which then points to &lt;code&gt;:author&lt;/code&gt; in the next schema, &lt;code&gt;Comment&lt;/code&gt;.</source>
          <target state="translated">在上面的示例中，我们定义了一个 &lt;code&gt;has_many :through&lt;/code&gt; 关联，其名称为 &lt;code&gt;:comments_authors&lt;/code&gt; 。甲 &lt;code&gt;:through&lt;/code&gt; 关联总是期望列表，并且该列表的第一个元素必须是当前模块中的先前定义的关联。例如， &lt;code&gt;:comments_authors&lt;/code&gt; 首先指向同一模块（Post）中的 &lt;code&gt;:comments&lt;/code&gt; ，然后指向下一个模式 &lt;code&gt;Comment&lt;/code&gt; 中的 &lt;code&gt;:author&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="85ec2ea6c6ded12b6166febab5316f612414d722" translate="yes" xml:space="preserve">
          <source>In the example above, we used &lt;a href=&quot;#datetime_add/3&quot;&gt;&lt;code&gt;datetime_add/3&lt;/code&gt;&lt;/a&gt; to subtract one month from the current datetime and compared it with the &lt;code&gt;p.published_at&lt;/code&gt;. If you want to perform operations on date, &lt;a href=&quot;#date_add/3&quot;&gt;&lt;code&gt;date_add/3&lt;/code&gt;&lt;/a&gt; could be used.</source>
          <target state="translated">在上面的示例中，我们使用&lt;a href=&quot;#datetime_add/3&quot;&gt; &lt;code&gt;datetime_add/3&lt;/code&gt; &lt;/a&gt;从当前日期时间中减去一个月，并将其与 &lt;code&gt;p.published_at&lt;/code&gt; 进行比较。如果&lt;a href=&quot;#date_add/3&quot;&gt; &lt;code&gt;date_add/3&lt;/code&gt; &lt;/a&gt;日期执行操作，则可以使用date_add / 3。</target>
        </trans-unit>
        <trans-unit id="a77b1f6b12d8b7d6c0db0b804a8d03a2387d7fc2" translate="yes" xml:space="preserve">
          <source>In the example above, we were able to build the query expressions bit by bit, using different bindings, and later interpolate it all at once inside the query.</source>
          <target state="translated">在上面的例子中,我们能够使用不同的绑定,一点一点地建立查询表达式,之后在查询里面一次性插值。</target>
        </trans-unit>
        <trans-unit id="b3cc98d911ffe36e25f191353a2c3e1efd5e9454" translate="yes" xml:space="preserve">
          <source>In the example below, we get all comments associated to the given post:</source>
          <target state="translated">在下面的例子中,我们得到了与给定文章相关的所有评论。</target>
        </trans-unit>
        <trans-unit id="113fef9616300cb9b03a9842f0b9a69b0c3665e7" translate="yes" xml:space="preserve">
          <source>In the examples above, even though it returned &lt;code&gt;:ok&lt;/code&gt;, we do not know if we inserted new data or if we updated only the &lt;code&gt;:on_conflict&lt;/code&gt; fields. In case an update happened, the data in the struct most likely does not match the data in the database. For example, autogenerated fields such as &lt;code&gt;inserted_at&lt;/code&gt; will point to now rather than the time the struct was actually inserted.</source>
          <target state="translated">在上面的示例中，即使它返回了 &lt;code&gt;:ok&lt;/code&gt; ，我们也不知道是否插入了新数据，还是仅更新了 &lt;code&gt;:on_conflict&lt;/code&gt; 字段。如果发生更新，则结构中的数据很可能与数据库中的数据不匹配。例如，自动生成的领域，如 &lt;code&gt;inserted_at&lt;/code&gt; 将指向到现在，而不是结构实际上是插入的时间。</target>
        </trans-unit>
        <trans-unit id="2930af812f0bb54659d607398b6c6757367b573d" translate="yes" xml:space="preserve">
          <source>In the examples above, we have placed the template directly inside the LiveView:</source>
          <target state="translated">在上面的例子中,我们把模板直接放在LiveView里面。</target>
        </trans-unit>
        <trans-unit id="2f37c0e9a5a67e4ea92ceac140f3ed765f58b555" translate="yes" xml:space="preserve">
          <source>In the following sections, we will provide an overview of those components and how they interact with each other. Feel free to access their respective module documentation for more specific examples, options and configuration.</source>
          <target state="translated">在下面的章节中,我们将提供这些组件的概述以及它们如何相互作用。请随时访问它们各自的模块文档,以获得更多具体的示例、选项和配置。</target>
        </trans-unit>
        <trans-unit id="05a430899144f4642991576f8481a69501d20d42" translate="yes" xml:space="preserve">
          <source>In the form, you now can:</source>
          <target state="translated">在表格中,你现在可以。</target>
        </trans-unit>
        <trans-unit id="b94cd064e93fa734125c2fd704a901c1c0fcb707" translate="yes" xml:space="preserve">
          <source>In the keyword query syntax, those options must be given immediately after the join. In the expression syntax, the options are given as the fifth argument.</source>
          <target state="translated">在关键字查询语法中,这些选项必须在连接之后立即给出。在表达式语法中,选项是作为第五个参数给出的。</target>
        </trans-unit>
        <trans-unit id="e90e585267bb28783e5461ed42cba84a357ddee0" translate="yes" xml:space="preserve">
          <source>In the middle of the endpoint, there is also a conditional block:</source>
          <target state="translated">在终端的中间,还有一个条件块。</target>
        </trans-unit>
        <trans-unit id="925384cf40775541bef0fdb371ddd4f6902ee2ec" translate="yes" xml:space="preserve">
          <source>In the previous section, we have used the &lt;a href=&quot;#c:config/2&quot;&gt;&lt;code&gt;config/2&lt;/code&gt;&lt;/a&gt; function that is automatically generated in your endpoint. Here&amp;rsquo;s a list of all the functions that are automatically defined in your endpoint:</source>
          <target state="translated">在上一节中，我们使用了在端点中自动生成的&lt;a href=&quot;#c:config/2&quot;&gt; &lt;code&gt;config/2&lt;/code&gt; &lt;/a&gt;函数。这是在端点中自动定义的所有功能的列表：</target>
        </trans-unit>
        <trans-unit id="9f3c7ddaf3d4a8950203ba5460188209b699de98" translate="yes" xml:space="preserve">
          <source>In the previous section, we have used the &lt;a href=&quot;#c:config/2&quot;&gt;&lt;code&gt;config/2&lt;/code&gt;&lt;/a&gt; function that is automatically generated in your endpoint. Here's a list of all the functions that are automatically defined in your endpoint:</source>
          <target state="translated">在上一节中，我们使用了在端点中自动生成的&lt;a href=&quot;#c:config/2&quot;&gt; &lt;code&gt;config/2&lt;/code&gt; &lt;/a&gt;函数。这是在端点中自动定义的所有功能的列表：</target>
        </trans-unit>
        <trans-unit id="4db5d6dd9e9298f5fcdd31235b789e1443c4ca39" translate="yes" xml:space="preserve">
          <source>In the router, we can declare plugs inside pipelines:</source>
          <target state="translated">在路由器中,我们可以在管道内声明插头。</target>
        </trans-unit>
        <trans-unit id="c9a8e520a230c0312a84d780ae929ea961272701" translate="yes" xml:space="preserve">
          <source>In the same &lt;code&gt;lib/hello&lt;/code&gt; directory, we will find a &lt;code&gt;lib/hello/repo.ex&lt;/code&gt;. It defines a &lt;code&gt;Hello.Repo&lt;/code&gt; module which is our main interface to the database. If you are using Postgres (the default), you will see something like this:</source>
          <target state="translated">在相同 &lt;code&gt;lib/hello&lt;/code&gt; 目录，我们会发现一个 &lt;code&gt;lib/hello/repo.ex&lt;/code&gt; 。它定义了一个 &lt;code&gt;Hello.Repo&lt;/code&gt; 模块，它是我们与数据库的主要接口。如果您使用的是Postgres（默认设置），则会看到以下内容：</target>
        </trans-unit>
        <trans-unit id="e4a55cc79b6410f0afe6d205affc7d1b1d385b5c" translate="yes" xml:space="preserve">
          <source>In the second case, the &lt;code&gt;form_for&lt;/code&gt; emits only the opening of the &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; tag, which then needs to be closed explicitly in HTML. Since the anonymous function has been removed, &lt;code&gt;Phoenix.LiveView&lt;/code&gt; is able to optimize forms too. Although outside of live views, we recommend using the first construct.</source>
          <target state="translated">在第二种情况下， &lt;code&gt;form_for&lt;/code&gt; 仅发出 &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; 标记的开头，然后需要在HTML中显式关闭该标记。由于匿名功能已被删除， &lt;code&gt;Phoenix.LiveView&lt;/code&gt; 也能够优化表单。尽管不在实时视图中，但我们建议使用第一种构造。</target>
        </trans-unit>
        <trans-unit id="610bcbb3b9e32217be658737635c218a337cd80c" translate="yes" xml:space="preserve">
          <source>In the template, we want to wrap all of the messages in a container and tag this content with &lt;code&gt;phx-update&lt;/code&gt;. Remember, we must add an ID to the container as well as to each child:</source>
          <target state="translated">在模板中，我们希望将所有消息包装在一个容器中，并使用 &lt;code&gt;phx-update&lt;/code&gt; 标记此内容。请记住，我们必须为容器以及每个子代添加一个ID：</target>
        </trans-unit>
        <trans-unit id="5900cdb36ee6d103dd2e36b10be0e4e6213e6863" translate="yes" xml:space="preserve">
          <source>In the view we see our &lt;code&gt;render/2&lt;/code&gt; function pattern matching on &lt;code&gt;&quot;index.json&quot;&lt;/code&gt;, &lt;code&gt;&quot;show.json&quot;&lt;/code&gt;, and &lt;code&gt;&quot;page.json&quot;&lt;/code&gt;. The &quot;index.json&quot; and &quot;show.json&quot; are the ones requested directly from the controller. They also match on the assigns sent by the controller. &lt;code&gt;&quot;index.json&quot;&lt;/code&gt; will respond with JSON like this:</source>
          <target state="translated">在视图中，我们看到在 &lt;code&gt;&quot;index.json&quot;&lt;/code&gt; ， &lt;code&gt;&quot;show.json&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;page.json&quot;&lt;/code&gt; 上匹配的 &lt;code&gt;render/2&lt;/code&gt; 函数模式。&amp;ldquo; index.json&amp;rdquo;和&amp;ldquo; show.json&amp;rdquo;是直接从控制器请求的。它们还与控制器发送的分配相匹配。 &lt;code&gt;&quot;index.json&quot;&lt;/code&gt; 将使用JSON进行响应，如下所示：</target>
        </trans-unit>
        <trans-unit id="7e2c6811152e546fda2c29bf344f22b16249e04d" translate="yes" xml:space="preserve">
          <source>In this case you can use the name and suffix options together to match on these dynamic indexes, like:</source>
          <target state="translated">在这种情况下,你可以在这些动态索引上同时使用名称和后缀选项进行匹配,比如。</target>
        </trans-unit>
        <trans-unit id="b521e7acb6fef7a8f7e4316ef4bab85906fb67cf" translate="yes" xml:space="preserve">
          <source>In this case, the solution is to not use &lt;code&gt;content_tag&lt;/code&gt; and rely on LiveEEx to build the markup.</source>
          <target state="translated">在这种情况下，解决方案是不使用 &lt;code&gt;content_tag&lt;/code&gt; 而是依靠LiveEEx来构建标记。</target>
        </trans-unit>
        <trans-unit id="c678eccca5ec57c1ed60e620ac17c9a5a18d705b" translate="yes" xml:space="preserve">
          <source>In this case, we haven&amp;rsquo;t checked the unique constraint in the e-mail field because the data did not validate. Let&amp;rsquo;s fix the age and assume, however, that the e-mail already exists in the database:</source>
          <target state="translated">在这种情况下，我们没有检查电子邮件字段中的唯一约束，因为数据没有验证。让我们确定年龄并假设该电子邮件已存在于数据库中：</target>
        </trans-unit>
        <trans-unit id="50bf56697ce917a335edfd2bed8c62011c485096" translate="yes" xml:space="preserve">
          <source>In this case, we haven't checked the unique constraint in the e-mail field because the data did not validate. Let's fix the age and the name, and assume that the e-mail already exists in the database:</source>
          <target state="translated">在这种情况下,我们没有检查电子邮件字段中的唯一约束,因为数据没有验证。让我们修正年龄和姓名,并假设电子邮件已经存在于数据库中。</target>
        </trans-unit>
        <trans-unit id="f94f214e683bc0e00a7e39c7767a3430885c51b2" translate="yes" xml:space="preserve">
          <source>In this example, the phoenix.js client will send the token in the &lt;code&gt;connect&lt;/code&gt; command which is then validated by the server.</source>
          <target state="translated">在此示例中，phoenix.js客户端将在 &lt;code&gt;connect&lt;/code&gt; 命令中发送令牌，然后服务器会对其进行验证。</target>
        </trans-unit>
        <trans-unit id="84d8d37df15e10105e708f89127c2b3fd59110cd" translate="yes" xml:space="preserve">
          <source>In this example, the stop event's &lt;code&gt;duration&lt;/code&gt; includes the time it takes to parse the request, dispatch it to the correct handler, and execute the handler. The events are not emitted for requests not matching any handlers, since the plug is placed after the match plug.</source>
          <target state="translated">在此示例中，停止事件的 &lt;code&gt;duration&lt;/code&gt; 包括解析请求，将请求分派到正确的处理程序并执行处理程序所花费的时间。对于不匹配任何处理程序的请求，不会发出事件，因为该插件放置在match插件之后。</target>
        </trans-unit>
        <trans-unit id="b1c87280301ac2f9d889847d9370825348892494" translate="yes" xml:space="preserve">
          <source>In this example, we know the client sent a valid token because &lt;a href=&quot;#verify/4&quot;&gt;&lt;code&gt;verify/4&lt;/code&gt;&lt;/a&gt; returned a tuple of type &lt;code&gt;{:ok, user_id}&lt;/code&gt;. The server can now proceed with the request.</source>
          <target state="translated">在此示例中，我们知道客户端发送了有效令牌，因为&lt;a href=&quot;#verify/4&quot;&gt; &lt;code&gt;verify/4&lt;/code&gt; &lt;/a&gt;返回了类型为 &lt;code&gt;{:ok, user_id}&lt;/code&gt; 的元组。服务器现在可以继续请求。</target>
        </trans-unit>
        <trans-unit id="71e6a35d1eff7b2aab276040bac56ef6b66ab6ad" translate="yes" xml:space="preserve">
          <source>In this example, we prepend the new comment to the list of existing comments. Ecto will diff the list of comments currently in &lt;code&gt;post&lt;/code&gt; with the list of comments given, and correctly insert the new comment to the database. Note, however, Ecto is doing a lot of work just to figure out something we knew since the beginning, which is that there is only one new comment.</source>
          <target state="translated">在此示例中，我们将新注释放在现有注释列表的前面。Ecto会将当前 &lt;code&gt;post&lt;/code&gt; 的评论列表与给定的评论列表进行比较，然后将新评论正确插入数据库中。但是请注意，Ecto正在做很多工作，只是为了弄清我们从一开始就知道的事情，那就是只有一条新评论。</target>
        </trans-unit>
        <trans-unit id="705c5880cd57ceb565562d6750a24d58f8d72145" translate="yes" xml:space="preserve">
          <source>In this guide, we will show you how to instrument and report on &lt;code&gt;:telemetry&lt;/code&gt; events in your Phoenix application.</source>
          <target state="translated">在本指南中，我们将向您展示如何在Phoenix应用程序中检测和报告 &lt;code&gt;:telemetry&lt;/code&gt; 事件。</target>
        </trans-unit>
        <trans-unit id="41b71b3e3675710388f0fdbf100ae1a0951ac128" translate="yes" xml:space="preserve">
          <source>In this particular case, this can be addressed by using the &lt;code&gt;form_for&lt;/code&gt; variant without anonymous functions:</source>
          <target state="translated">在这种特殊情况下，可以使用没有匿名函数的 &lt;code&gt;form_for&lt;/code&gt; 变量来解决：</target>
        </trans-unit>
        <trans-unit id="094b03b8c08ae8f0aca1e1b64e1f6fdead91e39c" translate="yes" xml:space="preserve">
          <source>In this scenario we will create a token, sign it, then provide it to a client application. The client will then use this token to authenticate requests for resources from the server. (See &lt;a href=&quot;phoenix.token#content&quot;&gt;&lt;code&gt;Phoenix.Token&lt;/code&gt;&lt;/a&gt; summary for more info about creating tokens.)</source>
          <target state="translated">在这种情况下，我们将创建一个令牌，对其进行签名，然后将其提供给客户端应用程序。然后，客户端将使用此令牌来验证来自服务器的资源请求。（有关创建令牌的更多信息，请参见&lt;a href=&quot;phoenix.token#content&quot;&gt; &lt;code&gt;Phoenix.Token&lt;/code&gt; &lt;/a&gt;摘要。）</target>
        </trans-unit>
        <trans-unit id="5d2ca7cf6666758e66d70fb72bd2c17d8cc12775" translate="yes" xml:space="preserve">
          <source>In this scenario we will create a token, sign it, then provide it to a client application. The client will then use this token to authenticate requests for resources from the server. See &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Phoenix.Token&lt;/code&gt;&lt;/a&gt; summary for more info about creating tokens.</source>
          <target state="translated">在这种情况下，我们将创建一个令牌，对其进行签名，然后将其提供给客户端应用程序。然后，客户端将使用此令牌来验证来自服务器的资源请求。有关创建令牌的更多信息，请参见&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Phoenix.Token&lt;/code&gt; &lt;/a&gt;摘要。</target>
        </trans-unit>
        <trans-unit id="8e2b36f6be4273c12b1bf0870e80c1f54e8ebe01" translate="yes" xml:space="preserve">
          <source>In this section, we will talk about error cases that you expect to happen within your application. For example, a user filling in a form with invalid data is expected. In a LiveView, we typically handle those cases by storing a change in the LiveView state, which causes the LiveView to be re-rendered with the error message.</source>
          <target state="translated">在本节中,我们将讨论您期望在应用程序中发生的错误情况。例如,用户用无效数据填写表单是预期的。在LiveView中,我们通常通过在LiveView状态中存储一个变化来处理这些情况,这将导致LiveView被重新渲染并显示错误信息。</target>
        </trans-unit>
        <trans-unit id="534f0da6f14534e0120bbc0f42df3e9cafe2ef69" translate="yes" xml:space="preserve">
          <source>In your posts and tasks:</source>
          <target state="translated">在你的岗位和任务中。</target>
        </trans-unit>
        <trans-unit id="c3b933e481b11d1bde53fbfb5da0612030cd36c5" translate="yes" xml:space="preserve">
          <source>In your test, you can assert that the close happened by:</source>
          <target state="translated">在你的测试中,你可以断言接近的发生由。</target>
        </trans-unit>
        <trans-unit id="b483120f0deedef678421bd74a9a810fadf217f8" translate="yes" xml:space="preserve">
          <source>In-context Relationships</source>
          <target state="translated">语境中的关系</target>
        </trans-unit>
        <trans-unit id="2145377aa10484f7a6a7e6838ef07513b94b08f3" translate="yes" xml:space="preserve">
          <source>Inclusion operator: &lt;a href=&quot;#in/2&quot;&gt;&lt;code&gt;in/2&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">包含运算符：&lt;a href=&quot;#in/2&quot;&gt; &lt;code&gt;in/2&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="60fb63493844a1ddd4abed4ae031ad06a61ed43a" translate="yes" xml:space="preserve">
          <source>Incoming Events</source>
          <target state="translated">最新活动</target>
        </trans-unit>
        <trans-unit id="f330c4ccc52c7952a156d5b90f9e2cb96c8ebbb4" translate="yes" xml:space="preserve">
          <source>Incoming messages</source>
          <target state="translated">收到的信息</target>
        </trans-unit>
        <trans-unit id="615a09426a8930c611cc2c8dba4ed06391710162" translate="yes" xml:space="preserve">
          <source>Incoming messages are encoded in whatever way the transport chooses. Those messages must be decoded in the transport into a &lt;a href=&quot;phoenix.socket.message&quot;&gt;&lt;code&gt;Phoenix.Socket.Message&lt;/code&gt;&lt;/a&gt; before being forwarded to a channel.</source>
          <target state="translated">传入消息以传输方式选择的任何方式进行编码。这些消息必须在传输中解码为&lt;a href=&quot;phoenix.socket.message&quot;&gt; &lt;code&gt;Phoenix.Socket.Message&lt;/code&gt; ,&lt;/a&gt;然后再转发到通道。</target>
        </trans-unit>
        <trans-unit id="1020e5877fce98955e2ab68a32a4bcc5456449fd" translate="yes" xml:space="preserve">
          <source>Indeed it does.</source>
          <target state="translated">确实如此。</target>
        </trans-unit>
        <trans-unit id="2668d897f3e5655c92b0200386d6b654d95aaf3e" translate="yes" xml:space="preserve">
          <source>Indicates a many-to-many association with another schema</source>
          <target state="translated">表示与另一个模式的多对多关联。</target>
        </trans-unit>
        <trans-unit id="6aedb251e3f9159172c6827ec8ede269c15554c5" translate="yes" xml:space="preserve">
          <source>Indicates a many-to-many association with another schema.</source>
          <target state="translated">表示与另一个模式的多对多关联。</target>
        </trans-unit>
        <trans-unit id="135ecd7103630379591db4bff96d8d8045c40ee5" translate="yes" xml:space="preserve">
          <source>Indicates a one-to-many association with another schema</source>
          <target state="translated">表示与另一个模式的一对多关联。</target>
        </trans-unit>
        <trans-unit id="13d6cb61c10dc318568f2defc7bea984f223dba4" translate="yes" xml:space="preserve">
          <source>Indicates a one-to-many association with another schema.</source>
          <target state="translated">表示与另一个模式的一对多关联。</target>
        </trans-unit>
        <trans-unit id="1708cc604ed2771df21bc2d718401a60ab2cc1f0" translate="yes" xml:space="preserve">
          <source>Indicates a one-to-one association with another schema</source>
          <target state="translated">表示与另一个模式的一对一关联。</target>
        </trans-unit>
        <trans-unit id="0ae09be75f38bd6a2f7c1a338f1fea359b869e83" translate="yes" xml:space="preserve">
          <source>Indicates a one-to-one association with another schema.</source>
          <target state="translated">表示与另一个模式的一对一关联。</target>
        </trans-unit>
        <trans-unit id="2c438499b0af025a1043798095c70140d1dfd657" translate="yes" xml:space="preserve">
          <source>Indicates a one-to-one or many-to-one association with another schema</source>
          <target state="translated">表示与另一个模式一对一或多对一的关联。</target>
        </trans-unit>
        <trans-unit id="3745614dbe3129d4f977d563860dba9c8231878f" translate="yes" xml:space="preserve">
          <source>Indicates a one-to-one or many-to-one association with another schema.</source>
          <target state="translated">表示与另一个模式的一对一或多对一关联。</target>
        </trans-unit>
        <trans-unit id="aba2438ae1e81b9920197c224065413b7671c158" translate="yes" xml:space="preserve">
          <source>Indicates an embedding of a schema</source>
          <target state="translated">表示一个模式的嵌入</target>
        </trans-unit>
        <trans-unit id="b12568554ff04c1842f8599807aa79f64173a10b" translate="yes" xml:space="preserve">
          <source>Indicates an embedding of a schema.</source>
          <target state="translated">表示一个模式的嵌入。</target>
        </trans-unit>
        <trans-unit id="0754ccd3beda4c7eb864f57ffbfc33fd61e455d7" translate="yes" xml:space="preserve">
          <source>Indicates an embedding of many schemas</source>
          <target state="translated">表示多个模式的嵌入</target>
        </trans-unit>
        <trans-unit id="99fc922b999b45aabf4ebb20cd1ef3dfc6c0a01f" translate="yes" xml:space="preserve">
          <source>Indicates an embedding of many schemas.</source>
          <target state="translated">表示许多模式的嵌入。</target>
        </trans-unit>
        <trans-unit id="4d6143e57414f523ba3e39d5fe528429bec73741" translate="yes" xml:space="preserve">
          <source>Initialize the endpoint configuration</source>
          <target state="translated">初始化端点配置</target>
        </trans-unit>
        <trans-unit id="5feacf6897a98bceba39f5f4a774ab74aa83f3be" translate="yes" xml:space="preserve">
          <source>Initialize the endpoint configuration.</source>
          <target state="translated">初始化端点配置。</target>
        </trans-unit>
        <trans-unit id="3397476eb797456dd549685d4d13875789ff5bea" translate="yes" xml:space="preserve">
          <source>Initializes the adapter supervision tree by returning the children and adapter metadata</source>
          <target state="translated">通过返回子节点和适配器元数据来初始化适配器监管树。</target>
        </trans-unit>
        <trans-unit id="c798c674e519bc2029ac452c4e9259668434c74d" translate="yes" xml:space="preserve">
          <source>Initializes the adapter supervision tree by returning the children and adapter metadata.</source>
          <target state="translated">通过返回子节点和适配器元数据来初始化适配器监管树。</target>
        </trans-unit>
        <trans-unit id="2a5ae207d4c7ad36e0e12a08bb38366c31c50683" translate="yes" xml:space="preserve">
          <source>Initializes the session with the given contents</source>
          <target state="translated">用给定的内容初始化会话</target>
        </trans-unit>
        <trans-unit id="3e313d7032fb8b49aa12e688ee30e31dff8431ca" translate="yes" xml:space="preserve">
          <source>Initializes the session with the given contents.</source>
          <target state="translated">用给定的内容初始化会话。</target>
        </trans-unit>
        <trans-unit id="869617ee9409bb26ae162b9333128e6d4f2497b3" translate="yes" xml:space="preserve">
          <source>Initializes the socket state.</source>
          <target state="translated">初始化套接字状态。</target>
        </trans-unit>
        <trans-unit id="fc723255ce4cbc0ec464d52fcc972a1cff32563d" translate="yes" xml:space="preserve">
          <source>Initializes the store</source>
          <target state="translated">初始化存储</target>
        </trans-unit>
        <trans-unit id="1948daa5ef81efb1f6ec1462ab9c9c66bafc872e" translate="yes" xml:space="preserve">
          <source>Initializes the store.</source>
          <target state="translated">初始化商店。</target>
        </trans-unit>
        <trans-unit id="0a32892f65c6f195d4bdaf7f60b3ed037aaaf563" translate="yes" xml:space="preserve">
          <source>Initiates a transport connection for the socket handler</source>
          <target state="translated">为套接字处理程序启动一个传输连接</target>
        </trans-unit>
        <trans-unit id="aa4d0a4055c28858395d1bfeafcca50d2acb136f" translate="yes" xml:space="preserve">
          <source>Initiates a transport connection for the socket handler.</source>
          <target state="translated">启动套接字处理程序的传输连接。</target>
        </trans-unit>
        <trans-unit id="6966f2c2b0c652d66d13404f26dd54080032e919" translate="yes" xml:space="preserve">
          <source>Inits a session used exclusively for testing.</source>
          <target state="translated">输入一个专门用于测试的环节。</target>
        </trans-unit>
        <trans-unit id="da5d892e49eb5ac8b64c4d52c39e57d5d2b08b77" translate="yes" xml:space="preserve">
          <source>Inline embedded schema</source>
          <target state="translated">内嵌式模式</target>
        </trans-unit>
        <trans-unit id="569dafe164ae502c9b87c69bc2eeb16d3ac20cb7" translate="yes" xml:space="preserve">
          <source>Inserts a single new struct in the data store</source>
          <target state="translated">在数据存储中插入一个新的结构。</target>
        </trans-unit>
        <trans-unit id="3a1317498687c5894a20801ea9661a9689ed2d87" translate="yes" xml:space="preserve">
          <source>Inserts a single new struct in the data store.</source>
          <target state="translated">在数据存储中插入一个新结构。</target>
        </trans-unit>
        <trans-unit id="86c1d2240ae2916c99327d1f3c4590ec880385b2" translate="yes" xml:space="preserve">
          <source>Inserts a struct defined via &lt;a href=&quot;ecto.schema&quot;&gt;&lt;code&gt;Ecto.Schema&lt;/code&gt;&lt;/a&gt; or a changeset</source>
          <target state="translated">插入通过&lt;a href=&quot;ecto.schema&quot;&gt; &lt;code&gt;Ecto.Schema&lt;/code&gt; &lt;/a&gt;或变更集定义的结构</target>
        </trans-unit>
        <trans-unit id="a079a1b2f8984d465d9779ce849f02a429912d56" translate="yes" xml:space="preserve">
          <source>Inserts a struct defined via &lt;a href=&quot;ecto.schema&quot;&gt;&lt;code&gt;Ecto.Schema&lt;/code&gt;&lt;/a&gt; or a changeset.</source>
          <target state="translated">插入通过&lt;a href=&quot;ecto.schema&quot;&gt; &lt;code&gt;Ecto.Schema&lt;/code&gt; &lt;/a&gt;或变更集定义的结构。</target>
        </trans-unit>
        <trans-unit id="2181d458ad9deb4e6f83faf70ff675628bae0f26" translate="yes" xml:space="preserve">
          <source>Inserts all entries into the repository</source>
          <target state="translated">将所有条目插入到存储库中</target>
        </trans-unit>
        <trans-unit id="bc00e3feeb02479984623c1097211a4ee34ffd3d" translate="yes" xml:space="preserve">
          <source>Inserts all entries into the repository.</source>
          <target state="translated">将所有条目插入到存储库中。</target>
        </trans-unit>
        <trans-unit id="9a37ef1a0e51e4ac96d292248e7c141eccd65b5f" translate="yes" xml:space="preserve">
          <source>Inserts multiple entries into the data store</source>
          <target state="translated">将多个条目插入数据存储中</target>
        </trans-unit>
        <trans-unit id="45c0d55451df6034857c16938433e2842f295184" translate="yes" xml:space="preserve">
          <source>Inserts multiple entries into the data store.</source>
          <target state="translated">在数据存储中插入多个条目。</target>
        </trans-unit>
        <trans-unit id="a7003a167a94b7bd8fae5279ac09697a6145d12e" translate="yes" xml:space="preserve">
          <source>Inserts or updates a changeset depending on whether the changeset was persisted or not</source>
          <target state="translated">根据变化集是否被坚持,插入或更新变化集。</target>
        </trans-unit>
        <trans-unit id="dcd7179acaea39cd9930239b8c9b516c75b3f0b6" translate="yes" xml:space="preserve">
          <source>Inserts or updates a changeset depending on whether the changeset was persisted or not.</source>
          <target state="translated">根据变化集是否被坚持,插入或更新变化集。</target>
        </trans-unit>
        <trans-unit id="9eeac09af2f2cedab574e42a13a327495bc47759" translate="yes" xml:space="preserve">
          <source>Inserts or updates a changeset depending on whether the struct is persisted or not</source>
          <target state="translated">根据结构体是否被持久化,插入或更新一个变化集</target>
        </trans-unit>
        <trans-unit id="518a7ab088e5ce8ed019df775d78816d42febbe1" translate="yes" xml:space="preserve">
          <source>Inserts or updates a changeset depending on whether the struct is persisted or not.</source>
          <target state="translated">根据结构体是否被持久化,插入或更新一个变化集。</target>
        </trans-unit>
        <trans-unit id="c6d1a59fa5a20ec26ebff17adad30561c03cb5fa" translate="yes" xml:space="preserve">
          <source>Inside &lt;code&gt;select&lt;/code&gt;, &lt;a href=&quot;#type/2&quot;&gt;&lt;code&gt;type/2&lt;/code&gt;&lt;/a&gt; can also be used to cast fragments:</source>
          <target state="translated">在 &lt;code&gt;select&lt;/code&gt; 里面，&lt;a href=&quot;#type/2&quot;&gt; &lt;code&gt;type/2&lt;/code&gt; &lt;/a&gt;也可以用来转换片段：</target>
        </trans-unit>
        <trans-unit id="1a47e2355f236a87370793356f456cedb8eb6e91" translate="yes" xml:space="preserve">
          <source>Inside our existing IEx shell, let's create a &lt;code&gt;params&lt;/code&gt; map with valid values plus an extra &lt;code&gt;random_key: &quot;random value&quot;&lt;/code&gt;.</source>
          <target state="translated">在我们现有的IEx Shell中，创建一个带有有效值和一个额外的 &lt;code&gt;random_key: &quot;random value&quot;&lt;/code&gt; 的 &lt;code&gt;params&lt;/code&gt; 映射：&amp;ldquo; random value&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="bd5d902a671eb6810031f5357cbe6027ed13c2f5" translate="yes" xml:space="preserve">
          <source>Inside select: &lt;a href=&quot;#struct/2&quot;&gt;&lt;code&gt;struct/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#map/2&quot;&gt;&lt;code&gt;map/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#merge/2&quot;&gt;&lt;code&gt;merge/2&lt;/code&gt;&lt;/a&gt; and literals (map, tuples, lists, etc)</source>
          <target state="translated">内部选择：&lt;a href=&quot;#struct/2&quot;&gt; &lt;code&gt;struct/2&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#map/2&quot;&gt; &lt;code&gt;map/2&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#merge/2&quot;&gt; &lt;code&gt;merge/2&lt;/code&gt; &lt;/a&gt;和文字（map，tuple，list等）</target>
        </trans-unit>
        <trans-unit id="0bcbada89fa45431c089dbafc4a9e45958d6ebde" translate="yes" xml:space="preserve">
          <source>Inside that directory, let's create a new file, &lt;code&gt;hello.greeting.ex&lt;/code&gt;, that looks like this.</source>
          <target state="translated">在该目录内，让我们创建一个新文件 &lt;code&gt;hello.greeting.ex&lt;/code&gt; ，如下所示。</target>
        </trans-unit>
        <trans-unit id="54208a58823ef0a76c1b1a086d542dde6d472630" translate="yes" xml:space="preserve">
          <source>Inside the scope block, however, we have our first actual route:</source>
          <target state="translated">然而,在范围块内,我们有了第一个实际的路径。</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Installation</target>
        </trans-unit>
        <trans-unit id="5017ef1ca24c2a0d39b26c970ff7ebac50e027e8" translate="yes" xml:space="preserve">
          <source>Instead do this:</source>
          <target state="translated">而是这样做。</target>
        </trans-unit>
        <trans-unit id="82733e655d9772ce9cd06c72fcb7075dc4b7fc14" translate="yes" xml:space="preserve">
          <source>Instead explicitly precompute the assign in your LiveView, outside of render:</source>
          <target state="translated">相反,在渲染之外的LiveView中明确地预先计算赋值。</target>
        </trans-unit>
        <trans-unit id="17c3011cfb0b3891c2ccfb6fb06de6931b311efd" translate="yes" xml:space="preserve">
          <source>Instead of rendering all points with both static and dynamic parts, it returns a &lt;a href=&quot;phoenix.liveview.comprehension&quot;&gt;&lt;code&gt;Phoenix.LiveView.Comprehension&lt;/code&gt;&lt;/a&gt; struct with the static parts, that are shared across all points, and a list of dynamics to be interpolated inside the static parts. If &lt;code&gt;@points&lt;/code&gt; is a list with &lt;code&gt;%{x: 1, y: 2}&lt;/code&gt; and &lt;code&gt;%{x: 3, y: 4}&lt;/code&gt;, the above expression would return:</source>
          <target state="translated">它不使用静态零件和动态零件同时渲染所有点，而是返回带有静态零件的&lt;a href=&quot;phoenix.liveview.comprehension&quot;&gt; &lt;code&gt;Phoenix.LiveView.Comprehension&lt;/code&gt; &lt;/a&gt;结构（在所有点之间共享），以及要在静态零件内插值的动力学列表。如果 &lt;code&gt;@points&lt;/code&gt; 是具有 &lt;code&gt;%{x: 1, y: 2}&lt;/code&gt; 和 &lt;code&gt;%{x: 3, y: 4}&lt;/code&gt; ，则上述表达式将返回：</target>
        </trans-unit>
        <trans-unit id="53f49b4a03d02b3492955bbf412c1bec4c46145a" translate="yes" xml:space="preserve">
          <source>Instead of setting the action manually, you may use &lt;a href=&quot;#apply_action/2&quot;&gt;&lt;code&gt;apply_action/2&lt;/code&gt;&lt;/a&gt; that emulates operations such as &lt;code&gt;Repo.insert&lt;/code&gt;. &lt;a href=&quot;#apply_action/2&quot;&gt;&lt;code&gt;apply_action/2&lt;/code&gt;&lt;/a&gt; will return &lt;code&gt;{:ok, changes}&lt;/code&gt; if the changeset is valid or &lt;code&gt;{:error, changeset}&lt;/code&gt;, with the given &lt;code&gt;action&lt;/code&gt; set in the changeset in case of errors.</source>
          <target state="translated">您可以使用&lt;a href=&quot;#apply_action/2&quot;&gt; &lt;code&gt;apply_action/2&lt;/code&gt; &lt;/a&gt;来模拟操作，例如 &lt;code&gt;Repo.insert&lt;/code&gt; ，而不是手动设置操作。如果变更集有效 &lt;code&gt;{:ok, changes}&lt;/code&gt; &lt;a href=&quot;#apply_action/2&quot;&gt; &lt;code&gt;apply_action/2&lt;/code&gt; &lt;/a&gt;将返回{：ok，changes}或 &lt;code&gt;{:error, changeset}&lt;/code&gt; ，并在变更集中设置给定的 &lt;code&gt;action&lt;/code&gt; ，以防出现错误。</target>
        </trans-unit>
        <trans-unit id="dc625090b0eb339994af40957b6fb0d89ad3361f" translate="yes" xml:space="preserve">
          <source>Instead pass only the keys that you need:</source>
          <target state="translated">而不是只传你需要的钥匙。</target>
        </trans-unit>
        <trans-unit id="0e7be3c09bff9978d92d18ecc6c00bb68ff1fa61" translate="yes" xml:space="preserve">
          <source>Instead we can define a Module Plug which knows how to handle these error cases specifically. Since controllers are Module Plugs, let's define our Plug as a controller:</source>
          <target state="translated">相反,我们可以定义一个模块Plug,它知道如何具体处理这些错误情况。既然控制器是模块插件,那么我们就把我们的Plug定义为控制器。</target>
        </trans-unit>
        <trans-unit id="39b20dbf47e354f9fd0db114ae3112acc37f568e" translate="yes" xml:space="preserve">
          <source>Instead, it is much simpler to create a function:</source>
          <target state="translated">相反,创建一个函数就简单多了。</target>
        </trans-unit>
        <trans-unit id="3849a580f55e6b3b71f03e8f33c8ec65f16bcdd1" translate="yes" xml:space="preserve">
          <source>Instead, use a function:</source>
          <target state="translated">相反,使用一个函数。</target>
        </trans-unit>
        <trans-unit id="4ab4eded4494d51c420236d3c9dde1cb217c024c" translate="yes" xml:space="preserve">
          <source>Instead, you can see the valid options for ciphers in the Erlang SSL documentation: http://erlang.org/doc/man/ssl.html</source>
          <target state="translated">相反,你可以在Erlang SSL文档中看到密码的有效选项:http://erlang.org/doc/man/ssl.html。</target>
        </trans-unit>
        <trans-unit id="cb49b30bf89c4f1a8a29b63caa0a66ed1c9abce4" translate="yes" xml:space="preserve">
          <source>Instrumentation</source>
          <target state="translated">Instrumentation</target>
        </trans-unit>
        <trans-unit id="e963ac54f9b90e504ad8b5131dedaa40800f87bf" translate="yes" xml:space="preserve">
          <source>Instrumenter to handle logging of various instrumentation events.</source>
          <target state="translated">Instrumenter用于处理各种仪器事件的记录。</target>
        </trans-unit>
        <trans-unit id="0a977fa7c155d5db26b9805f1ed5ecb306366925" translate="yes" xml:space="preserve">
          <source>Instruments the given function using the instrumentation provided by the given endpoint</source>
          <target state="translated">使用给定的端点提供的仪器对给定的函数进行仪器化。</target>
        </trans-unit>
        <trans-unit id="040ea1fc514e828951fb8bd3d4e6583bf2dab63c" translate="yes" xml:space="preserve">
          <source>Instruments the given function using the instrumentation provided by the given endpoint.</source>
          <target state="translated">使用给定的端点提供的仪器对给定的函数进行检测。</target>
        </trans-unit>
        <trans-unit id="a4c71d7db6768276e995bf083955f4cf532a2661" translate="yes" xml:space="preserve">
          <source>Integers: &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt;, &lt;code&gt;3&lt;/code&gt;</source>
          <target state="translated">整数： &lt;code&gt;1&lt;/code&gt; ， &lt;code&gt;2&lt;/code&gt; ， &lt;code&gt;3&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="199cf4a624177d7b6a2189975011d8cf1553a6ea" translate="yes" xml:space="preserve">
          <source>Intercepting Outgoing Events</source>
          <target state="translated">拦截外发事件</target>
        </trans-unit>
        <trans-unit id="e70cfbd4ab25034bd13454c2505b73098457ac1c" translate="yes" xml:space="preserve">
          <source>Intercepts outgoing &lt;code&gt;event&lt;/code&gt;s.</source>
          <target state="translated">拦截传出 &lt;code&gt;event&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="280e1b21a8fbf76997de6dc3b8694bbd51187d4e" translate="yes" xml:space="preserve">
          <source>Interestingly, we can use multiple scopes with the same path as long as we are careful not to duplicate routes. This router is perfectly fine with two scopes defined for the same path.</source>
          <target state="translated">有趣的是,只要我们注意不要重复路由,我们可以用同一个路径使用多个scopes。这个路由器完全可以在同一个路径上定义两个作用域。</target>
        </trans-unit>
        <trans-unit id="352256d32ca814a08dd6fb42ea6e24113694d807" translate="yes" xml:space="preserve">
          <source>Internal function for integrating associations into schemas</source>
          <target state="translated">将关联整合到模式的内部功能</target>
        </trans-unit>
        <trans-unit id="eb704a4d49662206b6263bee9e3a6a682a47856e" translate="yes" xml:space="preserve">
          <source>Internal function for integrating associations into schemas.</source>
          <target state="translated">内部功能,用于将关联整合到模式中。</target>
        </trans-unit>
        <trans-unit id="60fcb5d998d297a0c11dd2b6af2c754859e11297" translate="yes" xml:space="preserve">
          <source>Internally, &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Plug.Builder&lt;/code&gt;&lt;/a&gt; implements the &lt;a href=&quot;plug&quot;&gt;&lt;code&gt;Plug&lt;/code&gt;&lt;/a&gt; behaviour, which means both the &lt;code&gt;init/1&lt;/code&gt; and &lt;code&gt;call/2&lt;/code&gt; functions are defined.</source>
          <target state="translated">在内部，&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Plug.Builder&lt;/code&gt; &lt;/a&gt;实现了&lt;a href=&quot;plug&quot;&gt; &lt;code&gt;Plug&lt;/code&gt; &lt;/a&gt;行为，这意味着同时定义了 &lt;code&gt;init/1&lt;/code&gt; 和 &lt;code&gt;call/2&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="2cd342be42586a26dea11e10d4f2f734d1e7b515" translate="yes" xml:space="preserve">
          <source>Internally, &lt;a href=&quot;plug.builder#content&quot;&gt;&lt;code&gt;Plug.Builder&lt;/code&gt;&lt;/a&gt; implements the &lt;a href=&quot;plug&quot;&gt;&lt;code&gt;Plug&lt;/code&gt;&lt;/a&gt; behaviour, which means both the &lt;code&gt;init/1&lt;/code&gt; and &lt;code&gt;call/2&lt;/code&gt; functions are defined.</source>
          <target state="translated">在内部，&lt;a href=&quot;plug.builder#content&quot;&gt; &lt;code&gt;Plug.Builder&lt;/code&gt; &lt;/a&gt;实现了&lt;a href=&quot;plug&quot;&gt; &lt;code&gt;Plug&lt;/code&gt; &lt;/a&gt;行为，这意味着同时定义了 &lt;code&gt;init/1&lt;/code&gt; 和 &lt;code&gt;call/2&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="6a9858c9bf3149456595f98943cf88e41039822e" translate="yes" xml:space="preserve">
          <source>Interpolation</source>
          <target state="translated">Interpolation</target>
        </trans-unit>
        <trans-unit id="9e19e8e52d010a3380d2cbbab62c90af63b8d211" translate="yes" xml:space="preserve">
          <source>Interpolation and casting</source>
          <target state="translated">内插和铸造</target>
        </trans-unit>
        <trans-unit id="28f682fd32feb69dea4dd4ff7adfaeaa1d1cf34e" translate="yes" xml:space="preserve">
          <source>Intersect expression returns only unique rows as if each query returned distinct results. This may cause performance penalty. If you need just to take the intersection of multiple result sets without removing duplicate rows consider using &lt;a href=&quot;#intersect_all/2&quot;&gt;&lt;code&gt;intersect_all/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">相交表达式仅返回唯一的行，就像每个查询返回不同的结果一样。这可能会导致性能下降。如果只需要采用多个结果集的交集而不删除重复的行，请考虑使用&lt;a href=&quot;#intersect_all/2&quot;&gt; &lt;code&gt;intersect_all/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="99267cc8937fb84d59bd60cc8326f8d752393db1" translate="yes" xml:space="preserve">
          <source>Intervals</source>
          <target state="translated">Intervals</target>
        </trans-unit>
        <trans-unit id="39fc639ab5236d70b6020dbbd7562331428b523c" translate="yes" xml:space="preserve">
          <source>Introduction - the guides you are currently reading. They will cover how to get your first application up and running</source>
          <target state="translated">简介-您目前正在阅读的指南。它们将涵盖如何让你的第一个应用程序启动和运行。</target>
        </trans-unit>
        <trans-unit id="8f4f328eabc744329e26e1140102953b7cc0083e" translate="yes" xml:space="preserve">
          <source>Intuitively, you would assume the following events:</source>
          <target state="translated">直觉上,你会假设以下事件。</target>
        </trans-unit>
        <trans-unit id="f5ee41c074ac477895b057c2f41a57f16a778949" translate="yes" xml:space="preserve">
          <source>Invoke this function for each possible value you want to be sent to the server.</source>
          <target state="translated">对每一个你想发送到服务器的可能的值调用这个函数。</target>
        </trans-unit>
        <trans-unit id="619c9c50996959b8e8f2beefe6dce08a85ac4c47" translate="yes" xml:space="preserve">
          <source>Invoked in order to access the value stored under &lt;code&gt;key&lt;/code&gt; in the given term &lt;code&gt;term&lt;/code&gt;</source>
          <target state="translated">为了访问给定条件 &lt;code&gt;term&lt;/code&gt; &lt;code&gt;key&lt;/code&gt; 下存储的值而调用</target>
        </trans-unit>
        <trans-unit id="3131af8070d80cb4438964eca7dde39215d4a38c" translate="yes" xml:space="preserve">
          <source>Invoked in order to access the value stored under &lt;code&gt;key&lt;/code&gt; in the given term &lt;code&gt;term&lt;/code&gt;.</source>
          <target state="translated">为了访问给定术语 &lt;code&gt;term&lt;/code&gt; 中存储在 &lt;code&gt;key&lt;/code&gt; 下的值而调用。</target>
        </trans-unit>
        <trans-unit id="f3cf9b446c97f792217c895b34619fd73d2391b8" translate="yes" xml:space="preserve">
          <source>Invoked in order to access the value under &lt;code&gt;key&lt;/code&gt; and update it at the same time</source>
          <target state="translated">为了访问 &lt;code&gt;key&lt;/code&gt; 下的值并同时更新它而调用</target>
        </trans-unit>
        <trans-unit id="b22a1f1a89dd3f3bab30cb805e59f8edfe29b611" translate="yes" xml:space="preserve">
          <source>Invoked in order to access the value under &lt;code&gt;key&lt;/code&gt; and update it at the same time.</source>
          <target state="translated">为了访问 &lt;code&gt;key&lt;/code&gt; 下的值并同时更新它而调用。</target>
        </trans-unit>
        <trans-unit id="36dca7d832107fe8c35259472cc9700cfe1e2dbf" translate="yes" xml:space="preserve">
          <source>Invoked on termination.</source>
          <target state="translated">终止时调用。</target>
        </trans-unit>
        <trans-unit id="733a4970520b6a464600ddd46a5ea64dba2a7375" translate="yes" xml:space="preserve">
          <source>Invoked to &amp;ldquo;pop&amp;rdquo; the value under &lt;code&gt;key&lt;/code&gt; out of the given data structure</source>
          <target state="translated">调用以从给定的数据结构中&amp;ldquo;弹出&amp;rdquo; &lt;code&gt;key&lt;/code&gt; 下的值</target>
        </trans-unit>
        <trans-unit id="742607736cb1addcde99f49aeedd51a191858b29" translate="yes" xml:space="preserve">
          <source>Invoked to &amp;ldquo;pop&amp;rdquo; the value under &lt;code&gt;key&lt;/code&gt; out of the given data structure.</source>
          <target state="translated">调用以从给定的数据结构中&amp;ldquo;弹出&amp;rdquo; &lt;code&gt;key&lt;/code&gt; 下的值。</target>
        </trans-unit>
        <trans-unit id="f35bf2a44d8213b1a251a0c82fa8bd2d26bc1736" translate="yes" xml:space="preserve">
          <source>Invoked when the channel process is about to exit.</source>
          <target state="translated">当通道进程即将退出时调用。</target>
        </trans-unit>
        <trans-unit id="61f50a5fe51f51ed7bfe665e624200109386cacc" translate="yes" xml:space="preserve">
          <source>Invoked when the endpoint supervisor starts, allows dynamically configuring the endpoint from system environment or other runtime sources.</source>
          <target state="translated">在端点监督器启动时调用,允许从系统环境或其他运行时源动态配置端点。</target>
        </trans-unit>
        <trans-unit id="dadda151ad04d6534ebf813dc99705a1a1d25aa9" translate="yes" xml:space="preserve">
          <source>Invoked when the server is started. &lt;a href=&quot;#start_link/3&quot;&gt;&lt;code&gt;start_link/3&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;start/3&lt;/code&gt; will block until it returns</source>
          <target state="translated">启动服务器时调用。&lt;a href=&quot;#start_link/3&quot;&gt; &lt;code&gt;start_link/3&lt;/code&gt; &lt;/a&gt;或 &lt;code&gt;start/3&lt;/code&gt; 将阻塞直到返回</target>
        </trans-unit>
        <trans-unit id="fe65c1df5bce54718f5a6ea6e98b5d9c1a779a60" translate="yes" xml:space="preserve">
          <source>Invoked when the server is started. &lt;a href=&quot;#start_link/3&quot;&gt;&lt;code&gt;start_link/3&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;start/3&lt;/code&gt; will block until it returns.</source>
          <target state="translated">启动服务器时调用。&lt;a href=&quot;#start_link/3&quot;&gt; &lt;code&gt;start_link/3&lt;/code&gt; &lt;/a&gt;或 &lt;code&gt;start/3&lt;/code&gt; 将阻塞直到返回。</target>
        </trans-unit>
        <trans-unit id="1a0516c7f6572d24052272cc4f229ec6f77d29e2" translate="yes" xml:space="preserve">
          <source>Invoked when the server is started. &lt;code&gt;start_link/3&lt;/code&gt; or &lt;code&gt;start/3&lt;/code&gt; will block until it returns</source>
          <target state="translated">启动服务器时调用。 &lt;code&gt;start_link/3&lt;/code&gt; 或 &lt;code&gt;start/3&lt;/code&gt; 将阻塞直到返回</target>
        </trans-unit>
        <trans-unit id="092a9376001bb69648a2c2cf84aeeda23d64be60" translate="yes" xml:space="preserve">
          <source>Invoked when the server is started. &lt;code&gt;start_link/3&lt;/code&gt; or &lt;code&gt;start/3&lt;/code&gt; will block until it returns.</source>
          <target state="translated">启动服务器时调用。 &lt;code&gt;start_link/3&lt;/code&gt; 或 &lt;code&gt;start/3&lt;/code&gt; 将阻塞直到返回。</target>
        </trans-unit>
        <trans-unit id="b0eda3fd7457c0fb4308b75d0bf6df3d4719aced" translate="yes" xml:space="preserve">
          <source>Is equivalent to:</source>
          <target state="translated">相当于:</target>
        </trans-unit>
        <trans-unit id="0c22586bb54f63849624411c842f2723bc94a4ec" translate="yes" xml:space="preserve">
          <source>It accepts an expression representing the path and many options allowing the match to be configured.</source>
          <target state="translated">它接受一个代表路径的表达式和许多允许配置匹配的选项。</target>
        </trans-unit>
        <trans-unit id="e9e7a6e5fc7e8d490f61f816d70fa682574386e8" translate="yes" xml:space="preserve">
          <source>It accepts the same options as &lt;a href=&quot;#read_body/2&quot;&gt;&lt;code&gt;read_body/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">它接受与&lt;a href=&quot;#read_body/2&quot;&gt; &lt;code&gt;read_body/2&lt;/code&gt; &lt;/a&gt;相同的选项。</target>
        </trans-unit>
        <trans-unit id="09ea74617913e32e5cdeb3c90a896c1320876968" translate="yes" xml:space="preserve">
          <source>It also supports custom adapter configuration:</source>
          <target state="translated">它还支持自定义适配器配置。</target>
        </trans-unit>
        <trans-unit id="bed9aed2b3feb53ce6e2576687d31f3c4e20815c" translate="yes" xml:space="preserve">
          <source>It always returns &lt;code&gt;:ok&lt;/code&gt;. To assert on the flash message, you can assert on the result of the rendered LiveView.</source>
          <target state="translated">它总是返回 &lt;code&gt;:ok&lt;/code&gt; 。要对Flash消息进行声明，可以对渲染的LiveView的结果进行声明。</target>
        </trans-unit>
        <trans-unit id="595822e1d20d7f428a3ef05e5d7b881101ea3807" translate="yes" xml:space="preserve">
          <source>It begins by configuring our &lt;code&gt;otp_app&lt;/code&gt; name and repo module. Then it sets the adapter &amp;ndash; Postgres, in our case. It also sets our login credentials. Of course, you can change these to match your actual credentials if they are different.</source>
          <target state="translated">首先配置 &lt;code&gt;otp_app&lt;/code&gt; 名称和回购模块。然后设置适配器&amp;ndash;在我们的例子中是Postgres。它还设置了我们的登录凭据。当然，如果它们不同，您可以更改这些以匹配您的实际凭据。</target>
        </trans-unit>
        <trans-unit id="726bf51434f75d8acf5e951711360513b2a0f6e9" translate="yes" xml:space="preserve">
          <source>It builds a new &lt;a href=&quot;phoenix.socket&quot;&gt;&lt;code&gt;Phoenix.Socket&lt;/code&gt;&lt;/a&gt;, invokes the handler &lt;code&gt;connect/2&lt;/code&gt; callback and returns the result.</source>
          <target state="translated">它构建一个新的&lt;a href=&quot;phoenix.socket&quot;&gt; &lt;code&gt;Phoenix.Socket&lt;/code&gt; &lt;/a&gt;，调用处理程序 &lt;code&gt;connect/2&lt;/code&gt; 回调并返回结果。</target>
        </trans-unit>
        <trans-unit id="a2cee1f656545c050d15a435216908ba321f2198" translate="yes" xml:space="preserve">
          <source>It can be mounted in your endpoint like any other socket:</source>
          <target state="translated">它可以像其他插座一样安装在你的端点上。</target>
        </trans-unit>
        <trans-unit id="c8b86f00ae4f81180f207fb516f99df0d0c9b931" translate="yes" xml:space="preserve">
          <source>It can be used to derive a number of keys for various purposes from a given secret. This lets applications have a single secure secret, but avoid reusing that key in multiple incompatible contexts.</source>
          <target state="translated">它可以用来从一个给定的秘密中衍生出许多用于各种目的的密钥。这让应用程序拥有一个单一的安全秘密,但避免在多个不兼容的情况下重复使用该密钥。</target>
        </trans-unit>
        <trans-unit id="23758d8b77b97b076e10f03ba6b30fb6fdbbbd09" translate="yes" xml:space="preserve">
          <source>It can either be a keyword query or a query expression.</source>
          <target state="translated">它可以是关键字查询,也可以是查询表达式。</target>
        </trans-unit>
        <trans-unit id="186c38e14a6722baf34f425fa70665e109fc23a0" translate="yes" xml:space="preserve">
          <source>It can reset many fields except the query source (&lt;code&gt;from&lt;/code&gt;). When excluding a &lt;code&gt;:join&lt;/code&gt;, it will remove &lt;em&gt;all&lt;/em&gt; types of joins. If you prefer to remove a single type of join, please see paragraph below.</source>
          <target state="translated">除了查询源（ &lt;code&gt;from&lt;/code&gt; ），它可以重置许多字段。当排除 &lt;code&gt;:join&lt;/code&gt; 时，它将删除&lt;em&gt;所有&lt;/em&gt;类型的联接。如果您希望删除单一类型的联接，请参见下面的段落。</target>
        </trans-unit>
        <trans-unit id="19ab39633586fe70e0d92fb43a531d87dd58c9ee" translate="yes" xml:space="preserve">
          <source>It defaults to 5_000.</source>
          <target state="translated">它的默认值是5_000。</target>
        </trans-unit>
        <trans-unit id="dc3f06b0deaf4213087d2af935c667afca3512ce" translate="yes" xml:space="preserve">
          <source>It escapes quotes (double and single), double backslashes and others.</source>
          <target state="translated">它可以逃避引号(双引号和单引号)、双反斜杠等。</target>
        </trans-unit>
        <trans-unit id="452abe794374c8a4220fd3958f7c982cbc75a77b" translate="yes" xml:space="preserve">
          <source>It expects &lt;code&gt;{:safe, body}&lt;/code&gt; as a safe response or body as a string which will be HTML escaped.</source>
          <target state="translated">它期望 &lt;code&gt;{:safe, body}&lt;/code&gt; 作为安全响应，或者将body作为字符串，将HTML进行转义。</target>
        </trans-unit>
        <trans-unit id="8540fa79ebeeb04321b6937468baa86cf4bdc0a6" translate="yes" xml:space="preserve">
          <source>It expects a connection that has not been &lt;code&gt;:sent&lt;/code&gt; yet and sets its state to &lt;code&gt;:chunked&lt;/code&gt; afterwards. Otherwise raises &lt;a href=&quot;plug.conn.alreadysenterror&quot;&gt;&lt;code&gt;Plug.Conn.AlreadySentError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">它期望尚未 &lt;code&gt;:sent&lt;/code&gt; 的连接，然后将其状态设置为 &lt;code&gt;:chunked&lt;/code&gt; 。否则引发&lt;a href=&quot;plug.conn.alreadysenterror&quot;&gt; &lt;code&gt;Plug.Conn.AlreadySentError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="acabec8dab50a30917f688b209245a29971cc577" translate="yes" xml:space="preserve">
          <source>It expects a connection that has not been &lt;code&gt;:sent&lt;/code&gt; yet and sets its state to &lt;code&gt;:chunked&lt;/code&gt; afterwards. Otherwise, raises &lt;a href=&quot;plug.conn.alreadysenterror&quot;&gt;&lt;code&gt;Plug.Conn.AlreadySentError&lt;/code&gt;&lt;/a&gt;. After &lt;a href=&quot;#send_chunked/2&quot;&gt;&lt;code&gt;send_chunked/2&lt;/code&gt;&lt;/a&gt; is called, chunks can be sent to the client via the &lt;a href=&quot;#chunk/2&quot;&gt;&lt;code&gt;chunk/2&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">它期望尚未 &lt;code&gt;:sent&lt;/code&gt; 的连接，然后将其状态设置为 &lt;code&gt;:chunked&lt;/code&gt; 。否则，引发&lt;a href=&quot;plug.conn.alreadysenterror&quot;&gt; &lt;code&gt;Plug.Conn.AlreadySentError&lt;/code&gt; &lt;/a&gt;。调用&lt;a href=&quot;#send_chunked/2&quot;&gt; &lt;code&gt;send_chunked/2&lt;/code&gt; &lt;/a&gt;之后，可以通过&lt;a href=&quot;#chunk/2&quot;&gt; &lt;code&gt;chunk/2&lt;/code&gt; &lt;/a&gt;函数将块发送到客户端。</target>
        </trans-unit>
        <trans-unit id="90c8ac9c1aa8ddc9982ee763c945c57e9b9465d7" translate="yes" xml:space="preserve">
          <source>It expects a connection that has not been &lt;code&gt;:sent&lt;/code&gt; yet and sets its state to &lt;code&gt;:file&lt;/code&gt; afterwards. Otherwise raises &lt;a href=&quot;plug.conn.alreadysenterror&quot;&gt;&lt;code&gt;Plug.Conn.AlreadySentError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">它期望尚未 &lt;code&gt;:sent&lt;/code&gt; 的连接，然后将其状态设置为 &lt;code&gt;:file&lt;/code&gt; 。否则引发&lt;a href=&quot;plug.conn.alreadysenterror&quot;&gt; &lt;code&gt;Plug.Conn.AlreadySentError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1fe68caa8735b3dcb8f4a5c0b34b1b868f77311e" translate="yes" xml:space="preserve">
          <source>It expects a connection with state &lt;code&gt;:chunked&lt;/code&gt; as set by &lt;a href=&quot;#send_chunked/2&quot;&gt;&lt;code&gt;send_chunked/2&lt;/code&gt;&lt;/a&gt;. It returns &lt;code&gt;{:ok, conn}&lt;/code&gt; in case of success, otherwise &lt;code&gt;{:error, reason}&lt;/code&gt;.</source>
          <target state="translated">它期望通过&lt;a href=&quot;#send_chunked/2&quot;&gt; &lt;code&gt;send_chunked/2&lt;/code&gt; &lt;/a&gt;设置与状态 &lt;code&gt;:chunked&lt;/code&gt; chunked的连接。如果成功，它将返回 &lt;code&gt;{:ok, conn}&lt;/code&gt; ，否则返回 &lt;code&gt;{:error, reason}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a89874718d53663a7182056d1005a29e9ce37ec6" translate="yes" xml:space="preserve">
          <source>It expects a name or a PID representing a repo.</source>
          <target state="translated">它期待一个代表repo的名称或PID。</target>
        </trans-unit>
        <trans-unit id="acb7e336ed29d294c4566b6d952ca3d23d9cfb62" translate="yes" xml:space="preserve">
          <source>It expects a schema module (&lt;code&gt;MyApp.User&lt;/code&gt;) or a source (&lt;code&gt;&quot;users&quot;&lt;/code&gt;) or both (&lt;code&gt;{&quot;users&quot;, MyApp.User}&lt;/code&gt;) as the first argument. The second argument is a list of entries to be inserted, either as keyword lists or as maps.</source>
          <target state="translated">它期望将模式模块（ &lt;code&gt;MyApp.User&lt;/code&gt; ）或源（ &lt;code&gt;&quot;users&quot;&lt;/code&gt; ）或两者（ &lt;code&gt;{&quot;users&quot;, MyApp.User}&lt;/code&gt; ）作为第一个参数。第二个参数是要插入的条目列表，可以是关键字列表或映射。</target>
        </trans-unit>
        <trans-unit id="e373615ede0cb68b0ddc4b7d19e01255f7ceb5ec" translate="yes" xml:space="preserve">
          <source>It expects a schema module (&lt;code&gt;MyApp.User&lt;/code&gt;) or a source (&lt;code&gt;&quot;users&quot;&lt;/code&gt;) or both (&lt;code&gt;{&quot;users&quot;, MyApp.User}&lt;/code&gt;) as the first argument. The second argument is a list of entries to be inserted, either as keyword lists or as maps. The keys of the entries are the field names as atoms and the value should be the respective value for the field type or, optionally, an &lt;a href=&quot;ecto.query&quot;&gt;&lt;code&gt;Ecto.Query&lt;/code&gt;&lt;/a&gt; that returns a single entry with a single value.</source>
          <target state="translated">它期望将模式模块（ &lt;code&gt;MyApp.User&lt;/code&gt; ）或源（ &lt;code&gt;&quot;users&quot;&lt;/code&gt; ）或两者（ &lt;code&gt;{&quot;users&quot;, MyApp.User}&lt;/code&gt; ）作为第一个参数。第二个参数是要插入的条目列表，可以作为关键字列表或作为映射。条目的键是作为原子的字段名称，其值应为字段类型的相应值，或者（可选）返回一个带有单个值的单个条目的&lt;a href=&quot;ecto.query&quot;&gt; &lt;code&gt;Ecto.Query&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="833cf1288bb8a29f6137f917618b60a72a57a732" translate="yes" xml:space="preserve">
          <source>It expects the connection state to be &lt;code&gt;:set&lt;/code&gt;, otherwise raises an &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; for &lt;code&gt;:unset&lt;/code&gt; connections or a &lt;a href=&quot;plug.conn.alreadysenterror&quot;&gt;&lt;code&gt;Plug.Conn.AlreadySentError&lt;/code&gt;&lt;/a&gt; for already &lt;code&gt;:sent&lt;/code&gt; connections.</source>
          <target state="translated">它期望连接状态为 &lt;code&gt;:set&lt;/code&gt; ，否则为 &lt;code&gt;:unset&lt;/code&gt; 连接引发&lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt;，为已经 &lt;code&gt;:sent&lt;/code&gt; 连接产生&lt;a href=&quot;plug.conn.alreadysenterror&quot;&gt; &lt;code&gt;Plug.Conn.AlreadySentError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0a5b52d3a097156da96dfb9a0fc91d7fc8826359" translate="yes" xml:space="preserve">
          <source>It expects the current LiveView, a query selector, and a text filter.</source>
          <target state="translated">它期望当前的LiveView,一个查询选择器和一个文本过滤器。</target>
        </trans-unit>
        <trans-unit id="eeb5bf8f84e63e5c41f8e19268de1412b7da7891" translate="yes" xml:space="preserve">
          <source>It expects the current LiveView, a query selector, and the form data. The query selector must return a single element.</source>
          <target state="translated">它需要当前的LiveView、一个查询选择器和表单数据。查询选择器必须返回一个单一元素。</target>
        </trans-unit>
        <trans-unit id="13049f4b2fe95fa18841a16d72fe416ecdcdc085" translate="yes" xml:space="preserve">
          <source>It expects the name of the otp app as the first argument and for the command to be run inside your umbrella application's apps directory:</source>
          <target state="translated">它希望以 otp 应用程序的名称作为第一个参数,并希望该命令在 umbrella 应用程序的应用程序目录中运行。</target>
        </trans-unit>
        <trans-unit id="6924324cbc62c482292289a444954ec7291d8685" translate="yes" xml:space="preserve">
          <source>It expects the name of the project as an argument.</source>
          <target state="translated">它希望用项目名称作为参数。</target>
        </trans-unit>
        <trans-unit id="4fca821bf0466e51b6ba5d79e2a1aa5f069282af" translate="yes" xml:space="preserve">
          <source>It expects the path of the project as an argument.</source>
          <target state="translated">它期望项目的路径作为一个参数。</target>
        </trans-unit>
        <trans-unit id="08038ecbe054a873bb08a6b11a9614856a8f9ff2" translate="yes" xml:space="preserve">
          <source>It expects the value of &lt;code&gt;get_session(conn, &quot;_csrf_token&quot;)&lt;/code&gt;. It returns &lt;code&gt;nil&lt;/code&gt; if there is no state in the session.</source>
          <target state="translated">它期望 &lt;code&gt;get_session(conn, &quot;_csrf_token&quot;)&lt;/code&gt; 。如果会话中没有任何状态，则返回 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="66c2fa1bb2a3b72c645dc3842e1b860a47918db6" translate="yes" xml:space="preserve">
          <source>It expects the view module, the template as a string, and a set of assigns.</source>
          <target state="translated">它期待视图模块、模板作为一个字符串,以及一组赋值。</target>
        </trans-unit>
        <trans-unit id="31903f698d3d42eef26a2983ba701e0cade71b54" translate="yes" xml:space="preserve">
          <source>It expects three parameters:</source>
          <target state="translated">它需要三个参数。</target>
        </trans-unit>
        <trans-unit id="7f16d994b67422cffaafcda9f7a4a44b5dac9b6a" translate="yes" xml:space="preserve">
          <source>It has to return a supervisor child specification.</source>
          <target state="translated">它必须返回一个主管孩子的规格。</target>
        </trans-unit>
        <trans-unit id="4b418dc1717675b2c364bf1025422ff35a375736" translate="yes" xml:space="preserve">
          <source>It implements the required &lt;a href=&quot;#child_spec/3&quot;&gt;&lt;code&gt;child_spec/3&lt;/code&gt;&lt;/a&gt; function as well as the handler for the WebSocket transport.</source>
          <target state="translated">它实现了必需的&lt;a href=&quot;#child_spec/3&quot;&gt; &lt;code&gt;child_spec/3&lt;/code&gt; &lt;/a&gt;函数以及WebSocket传输的处理程序。</target>
        </trans-unit>
        <trans-unit id="7050d3a8bafe3360f1738cb2135b721856f7ed7b" translate="yes" xml:space="preserve">
          <source>It implements the required &lt;code&gt;child_spec/3&lt;/code&gt; function as well as the handler for the WebSocket transport.</source>
          <target state="translated">它实现了必需的 &lt;code&gt;child_spec/3&lt;/code&gt; 函数以及WebSocket传输的处理程序。</target>
        </trans-unit>
        <trans-unit id="078983c5e35a9c8a686a6ae53ccec194f56ab546" translate="yes" xml:space="preserve">
          <source>It invokes the &lt;code&gt;validator&lt;/code&gt; function to perform the validation only if a change for the given &lt;code&gt;field&lt;/code&gt; exists and the change value is not &lt;code&gt;nil&lt;/code&gt;. The function must return a list of errors (with an empty list meaning no errors).</source>
          <target state="translated">仅当给定 &lt;code&gt;field&lt;/code&gt; 存在更改且更改值不为 &lt;code&gt;nil&lt;/code&gt; 时，它才调用 &lt;code&gt;validator&lt;/code&gt; 函数执行验证。该函数必须返回错误列表（列表为空表示没有错误）。</target>
        </trans-unit>
        <trans-unit id="b32bb8330646b67711708edabee82d77ea1330ee" translate="yes" xml:space="preserve">
          <source>It is advised to do as little work as possible when handling errors and avoid accessing data like parameters and session, as the parsing of those is what could have led the error to trigger in the first place.</source>
          <target state="translated">建议在处理错误时尽量少做工作,避免访问参数和session等数据,因为这些数据的解析是可能导致错误首先触发的。</target>
        </trans-unit>
        <trans-unit id="a9bfb318603777a6353f70162343fdb59351cda5" translate="yes" xml:space="preserve">
          <source>It is also important not to confuse &lt;a href=&quot;#render/3&quot;&gt;&lt;code&gt;Phoenix.Controller.render/3&lt;/code&gt;&lt;/a&gt; with &lt;a href=&quot;phoenix.view#render/3&quot;&gt;&lt;code&gt;Phoenix.View.render/3&lt;/code&gt;&lt;/a&gt;. The former expects a connection and relies on content negotiation while the latter is connection-agnostic and typically invoked from your views.</source>
          <target state="translated">同样重要的是不要将&lt;a href=&quot;#render/3&quot;&gt; &lt;code&gt;Phoenix.Controller.render/3&lt;/code&gt; &lt;/a&gt;与&lt;a href=&quot;phoenix.view#render/3&quot;&gt; &lt;code&gt;Phoenix.View.render/3&lt;/code&gt; &lt;/a&gt;混淆。前者希望建立连接并依赖于内容协商，而后者则是与连接无关的，通常是从您的视图中调用的。</target>
        </trans-unit>
        <trans-unit id="c2327b2734d4abd79bc9e71baaac2419dacff235" translate="yes" xml:space="preserve">
          <source>It is also important not to confuse &lt;a href=&quot;phoenix.controller#render/3&quot;&gt;&lt;code&gt;Phoenix.Controller.render/3&lt;/code&gt;&lt;/a&gt; with &lt;a href=&quot;phoenix.view#render/3&quot;&gt;&lt;code&gt;Phoenix.View.render/3&lt;/code&gt;&lt;/a&gt;. The former expects a connection and relies on content negotiation while the latter is connection-agnostic and typically invoked from your views.</source>
          <target state="translated">同样重要的是不要将&lt;a href=&quot;phoenix.controller#render/3&quot;&gt; &lt;code&gt;Phoenix.Controller.render/3&lt;/code&gt; &lt;/a&gt;与&lt;a href=&quot;phoenix.view#render/3&quot;&gt; &lt;code&gt;Phoenix.View.render/3&lt;/code&gt; &lt;/a&gt;混淆。前者希望建立连接并依赖于内容协商，而后者则是与连接无关的，通常是从您的视图中调用的。</target>
        </trans-unit>
        <trans-unit id="6a11a5417c769069994d2708a4c685591dad9818" translate="yes" xml:space="preserve">
          <source>It is also important to keep in mind that LiveViews are stateful. Therefore, if you load any data on &lt;a href=&quot;phoenix.liveview#c:mount/3&quot;&gt;&lt;code&gt;mount/3&lt;/code&gt;&lt;/a&gt; and the data itself changes, the data won't be automatically propagated to the LiveView, unless you broadcast those events with &lt;a href=&quot;../phoenix_pubsub/phoenix.pubsub&quot;&gt;&lt;code&gt;Phoenix.PubSub&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">记住LiveView是有状态的，这一点也很重要。因此，如果您在&lt;a href=&quot;phoenix.liveview#c:mount/3&quot;&gt; &lt;code&gt;mount/3&lt;/code&gt; &lt;/a&gt;上加载任何数据并且数据本身发生更改，那么除非您使用&lt;a href=&quot;../phoenix_pubsub/phoenix.pubsub&quot;&gt; &lt;code&gt;Phoenix.PubSub&lt;/code&gt; &lt;/a&gt;广播这些事件，否则数据不会自动传播到LiveView 。</target>
        </trans-unit>
        <trans-unit id="6a635280fb829c46f3ffad5a5d1753b1e733763d" translate="yes" xml:space="preserve">
          <source>It is also important to specify your handlers first, otherwise Phoenix will intercept the requests before they get to your handler.</source>
          <target state="translated">同样重要的是先指定你的处理程序,否则Phoenix会在请求到达你的处理程序之前拦截这些请求。</target>
        </trans-unit>
        <trans-unit id="30055e2131468401399af6d6f093161c25f60030" translate="yes" xml:space="preserve">
          <source>It is also not possible to use &lt;code&gt;insert_all&lt;/code&gt; to insert across multiple tables, therefore associations are not supported.</source>
          <target state="translated">也不能使用 &lt;code&gt;insert_all&lt;/code&gt; 在多个表中插入，因此不支持关联。</target>
        </trans-unit>
        <trans-unit id="5881689e685ad3746b2176daf7ae680c41d23de2" translate="yes" xml:space="preserve">
          <source>It is also possible to assign data to the &lt;a href=&quot;plug.conn&quot;&gt;&lt;code&gt;Plug.Conn&lt;/code&gt;&lt;/a&gt; that will be available to any plug invoked after the &lt;code&gt;:match&lt;/code&gt; plug. This is very useful if you want a matched route to customize how later plugs will behave.</source>
          <target state="translated">也可以将数据分配给&lt;a href=&quot;plug.conn&quot;&gt; &lt;code&gt;Plug.Conn&lt;/code&gt; &lt;/a&gt;，该数据可用于 &lt;code&gt;:match&lt;/code&gt; 插件之后调用的任何插件。如果您希望匹配的路由自定义以后插头的行为，这将非常有用。</target>
        </trans-unit>
        <trans-unit id="a8b8d8d53d8d8d7bd2e2cb61ea0c656280b0dd19" translate="yes" xml:space="preserve">
          <source>It is also possible to interpolate an Ecto query on the right side of &lt;code&gt;in&lt;/code&gt;. For example, the query above can also be written as:</source>
          <target state="translated">也可以 &lt;code&gt;in&lt;/code&gt; 的右侧插入Ecto查询。例如，上面的查询也可以写成：</target>
        </trans-unit>
        <trans-unit id="f21ad6a95ad909158ac71de812586e3b7701491a" translate="yes" xml:space="preserve">
          <source>It is also possible to interpolate the whole keyword list, allowing you to dynamically filter the source:</source>
          <target state="translated">也可以对整个关键词列表进行插值,允许你动态过滤源。</target>
        </trans-unit>
        <trans-unit id="42a3ef7d36b21828db375bf831fd19d83692ffc6" translate="yes" xml:space="preserve">
          <source>It is also possible to nest resources in a Phoenix router. Let's say we also have a &lt;code&gt;posts&lt;/code&gt; resource which has a many-to-one relationship with &lt;code&gt;users&lt;/code&gt;. That is to say, a user can create many posts, and an individual post belongs to only one user. We can represent that by adding a nested route in &lt;code&gt;lib/hello_web/router.ex&lt;/code&gt; like this:</source>
          <target state="translated">也可以将资源嵌套在Phoenix路由器中。假设我们还有一个 &lt;code&gt;posts&lt;/code&gt; 资源，它与 &lt;code&gt;users&lt;/code&gt; 之间存在多对一的关系。也就是说，一个用户可以创建许多帖子，而单个帖子仅属于一个用户。我们可以这样表示，方法是在 &lt;code&gt;lib/hello_web/router.ex&lt;/code&gt; 中添加一个嵌套路由，如下所示：</target>
        </trans-unit>
        <trans-unit id="767bbb26545ab7a71781118c61665b361ea9b2c7" translate="yes" xml:space="preserve">
          <source>It is also possible to pass additional session information to the LiveView through a session parameter:</source>
          <target state="translated">也可以通过会话参数向LiveView传递额外的会话信息。</target>
        </trans-unit>
        <trans-unit id="2d5529f115beed361dd6ff5307741dbc9a975d8d" translate="yes" xml:space="preserve">
          <source>It is also possible to say the type must match the same of a column:</source>
          <target state="translated">也可以说类型必须与列的相同。</target>
        </trans-unit>
        <trans-unit id="731c24ca319f444e53ad6c345b4820aa7c05979b" translate="yes" xml:space="preserve">
          <source>It is also possible to select a struct and limit the returned fields at the same time:</source>
          <target state="translated">也可以选择一个结构体,同时限制返回的字段。</target>
        </trans-unit>
        <trans-unit id="70a7d66c051591aae4846e19708e277358bb5702" translate="yes" xml:space="preserve">
          <source>It is also possible to use &lt;a href=&quot;phoenix.pubsub#content&quot;&gt;&lt;code&gt;Phoenix.PubSub&lt;/code&gt;&lt;/a&gt; directly or even run your own pubsub backends outside of an Endpoint.</source>
          <target state="translated">也可以直接使用&lt;a href=&quot;phoenix.pubsub#content&quot;&gt; &lt;code&gt;Phoenix.PubSub&lt;/code&gt; &lt;/a&gt;，甚至可以在Endpoint外部运行自己的pubsub后端。</target>
        </trans-unit>
        <trans-unit id="a80ee5c83f90af2cbd062b219e7dd0adf9de15c1" translate="yes" xml:space="preserve">
          <source>It is common for a LiveView to have multiple states and multiple URLs. For example, you can have a single LiveView that lists all articles on your web app. For each article there is an &quot;Edit&quot; button which, when pressed, opens up a modal on the same page to edit the article. It is a best practice to use live navigation in those cases, so when you click edit, the URL changes to &quot;/articles/1/edit&quot;, even though you are still within the same LiveView. Similarly, you may also want to show a &quot;New&quot; button, which opens up the modal to create new entries, and you want this to be reflected in the URL as &quot;/articles/new&quot;.</source>
          <target state="translated">一个LiveView拥有多个状态和多个URL是很常见的。例如,您可以有一个单一的LiveView,它列出了您的Web应用程序上的所有文章。对于每篇文章,都有一个 &quot;编辑 &quot;按钮,当按下这个按钮时,就会在同一页面上打开一个模态来编辑文章。在这些情况下,最好的做法是使用实时导航,所以当你点击编辑时,URL会改变为&quot;/articles/1/edit&quot;,即使你仍然在同一个LiveView中。同样,你可能也想显示一个 &quot;新建 &quot;按钮,打开模式来创建新条目,你希望这在URL中反映为&quot;/articles/new&quot;。</target>
        </trans-unit>
        <trans-unit id="8a719d875929b73a5f638e46b11bc306d0aaee72" translate="yes" xml:space="preserve">
          <source>It is compiled to:</source>
          <target state="translated">它的编制目的是:</target>
        </trans-unit>
        <trans-unit id="5f416c91fdafe72dbbea13ab378ff98cfdfba3e1" translate="yes" xml:space="preserve">
          <source>It is composed of the following fields:</source>
          <target state="translated">它由以下领域组成:</target>
        </trans-unit>
        <trans-unit id="92a07cde7a7c28b24072256a01215dba443d5ba7" translate="yes" xml:space="preserve">
          <source>It is important that &lt;a href=&quot;plug.parsers&quot;&gt;&lt;code&gt;Plug.Parsers&lt;/code&gt;&lt;/a&gt; is placed before the &lt;code&gt;:dispatch&lt;/code&gt; plug in the pipeline, otherwise the matched clause route will not receive the parsed body in its &lt;a href=&quot;plug.conn&quot;&gt;&lt;code&gt;Plug.Conn&lt;/code&gt;&lt;/a&gt; argument when dispatched.</source>
          <target state="translated">重要的是，将&lt;a href=&quot;plug.parsers&quot;&gt; &lt;code&gt;Plug.Parsers&lt;/code&gt; &lt;/a&gt;放置在管道中的 &lt;code&gt;:dispatch&lt;/code&gt; 插件之前，否则，匹配的子句路由在分派时将不会在其&lt;a href=&quot;plug.conn&quot;&gt; &lt;code&gt;Plug.Conn&lt;/code&gt; &lt;/a&gt;参数中接收已解析的主体。</target>
        </trans-unit>
        <trans-unit id="a2e2246bf2f06464052843a1b73d10ceadd7820b" translate="yes" xml:space="preserve">
          <source>It is important to notice that browsers have historically sent bad accept headers. For this reason, this function will default to &quot;html&quot; format whenever:</source>
          <target state="translated">需要注意的是,浏览器历史上曾发送过不良的接受头。因此,这个函数在任何时候都会默认为 &quot;html &quot;格式。</target>
        </trans-unit>
        <trans-unit id="d959bc56d3f9eacdf442d02254dff9bed2d3a24c" translate="yes" xml:space="preserve">
          <source>It is important to notice that browsers have historically sent bad accept headers. For this reason, this function will default to &amp;ldquo;html&amp;rdquo; format whenever:</source>
          <target state="translated">重要的是要注意，浏览器过去一直发送错误的接受标头。因此，无论何时，此函数将默认为&amp;ldquo; html&amp;rdquo;格式：</target>
        </trans-unit>
        <trans-unit id="afc85cab7e33f056d309bd20e21206dd571d1b09" translate="yes" xml:space="preserve">
          <source>It is not possible to directly configure the port in &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Plug.SSL&lt;/code&gt;&lt;/a&gt; because HSTS expects the port to be 443 for SSL. If you are not using HSTS and want to redirect to HTTPS on another port, you can sneak it alongside the host, for example: &lt;code&gt;host: &quot;example.com:443&quot;&lt;/code&gt;.</source>
          <target state="translated">无法直接在&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Plug.SSL&lt;/code&gt; 中&lt;/a&gt;配置端口，因为HSTS期望SSL的端口为443。如果您不使用HSTS并想重定向到另一个端口上的HTTPS，则可以将其与主机并排，例如： &lt;code&gt;host: &quot;example.com:443&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8df7a21de3fad9373d1e80d0a68fb9c2af463623" translate="yes" xml:space="preserve">
          <source>It is not possible to directly configure the port in &lt;a href=&quot;plug.ssl#content&quot;&gt;&lt;code&gt;Plug.SSL&lt;/code&gt;&lt;/a&gt; because HSTS expects the port to be 443 for SSL. If you are not using HSTS and wants to redirect to HTTPS on another port, you can sneak it alongside the host, for example: &lt;code&gt;host: &quot;example.com:443&quot;&lt;/code&gt;.</source>
          <target state="translated">无法直接在&lt;a href=&quot;plug.ssl#content&quot;&gt; &lt;code&gt;Plug.SSL&lt;/code&gt; 中&lt;/a&gt;配置端口，因为HSTS要求SSL的端口为443。如果您不使用HSTS并想重定向到另一个端口上的HTTPS，则可以将其与主机并排，例如： &lt;code&gt;host: &quot;example.com:443&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cb866ba422c5f8373a8e029337285f653ad8d5ad" translate="yes" xml:space="preserve">
          <source>It is not possible to represent all possible database queries using Ecto&amp;rsquo;s query syntax. When such is required, it is possible to use fragments to send any expression to the database:</source>
          <target state="translated">无法使用Ecto的查询语法表示所有可能的数据库查询。需要时，可以使用片段将任何表达式发送到数据库：</target>
        </trans-unit>
        <trans-unit id="c1ce5ae4e3f70bf7bcfc04fd5cadb18e0b1c097f" translate="yes" xml:space="preserve">
          <source>It is not possible to represent all possible database queries using Ecto's query syntax. When such is required, it is possible to use fragments to send any expression to the database:</source>
          <target state="translated">使用Ecto的查询语法不可能代表所有可能的数据库查询。当需要这样做时,可以使用碎片向数据库发送任何表达式。</target>
        </trans-unit>
        <trans-unit id="94f6c0d9ff724f7de2dd203438fa29365111d1aa" translate="yes" xml:space="preserve">
          <source>It is possible to add custom media types to your Phoenix application. The first step is to teach Plug about those new media types in your &lt;code&gt;config/config.exs&lt;/code&gt; file:</source>
          <target state="translated">可以向您的Phoenix应用程序添加自定义媒体类型。第一步是教plug关于 &lt;code&gt;config/config.exs&lt;/code&gt; 文件中的那些新媒体类型的信息：</target>
        </trans-unit>
        <trans-unit id="aa42a2a034d292f94558a8e07cc5079c64f6d273" translate="yes" xml:space="preserve">
          <source>It is possible to bundle the certificate files with the application, possibly for packaging into a release. In this case the files must be stored under the application's 'priv' directory. The &lt;code&gt;otp_app&lt;/code&gt; option must be set to the name of the OTP application that contains the files, in order to correctly resolve the relative paths:</source>
          <target state="translated">可以将证书文件与应用程序捆绑在一起，可能用于打包到发行版中。在这种情况下，文件必须存储在应用程序的&amp;ldquo; priv&amp;rdquo;目录下。该 &lt;code&gt;otp_app&lt;/code&gt; 选项必须设置为包含文件的OTP应用程序的名称，以便正确解析相对路径：</target>
        </trans-unit>
        <trans-unit id="c6fa08a29b74dfb5f5b32afcba99b61a22649c51" translate="yes" xml:space="preserve">
          <source>It is possible to include variables in the path, these will be available in the &lt;code&gt;params&lt;/code&gt; that are passed to the socket.</source>
          <target state="translated">可以在路径中包含变量，这些变量将在传递给套接字的 &lt;code&gt;params&lt;/code&gt; 中可用。</target>
        </trans-unit>
        <trans-unit id="2e2d8626fbe4ef6e2589dce4fc2dd6762fe2a1b8" translate="yes" xml:space="preserve">
          <source>It is possible to make use of PostgreSQL&amp;rsquo;s JSON/JSONB data type with fragments, as well:</source>
          <target state="translated">也可以将PostgreSQL的JSON / JSONB数据类型与片段一起使用：</target>
        </trans-unit>
        <trans-unit id="5ef6e9ed5dbdf5b36ce6e79f0b64c7e18c4f11c1" translate="yes" xml:space="preserve">
          <source>It is possible to set a prefix for the queries. For Postgres users, this will specify the schema where the table is located, while for MySQL users this will specify the database where the table is located. When no prefix is set, Postgres queries are assumed to be in the public schema, while MySQL queries are assumed to be in the database set in the config for the repo.</source>
          <target state="translated">可以为查询设置一个前缀。对于Postgres用户,将指定表所在的模式,而对于MySQL用户,将指定表所在的数据库。当没有设置前缀时,Postgres查询被认为是在公共模式中,而MySQL查询被认为是在配置中为repo设置的数据库中。</target>
        </trans-unit>
        <trans-unit id="700c0f421fd3cd0dfcac1f7b125e6e262daac824" translate="yes" xml:space="preserve">
          <source>It is possible to set:</source>
          <target state="translated">可以设置。</target>
        </trans-unit>
        <trans-unit id="90c2522cafce21dec34e2ada4a5ef033ed999c16" translate="yes" xml:space="preserve">
          <source>It is possible to specify a &lt;code&gt;:where&lt;/code&gt; option that will filter the records returned by the association. Querying, joining or preloading the association will use the given conditions as shown next:</source>
          <target state="translated">可以指定 &lt;code&gt;:where&lt;/code&gt; 选项，该选项将过滤关联返回的记录。查询，加入或预加载关联将使用给定条件，如下所示：</target>
        </trans-unit>
        <trans-unit id="29ec728a65755ba3d79cf56f0945ca98b6fece30" translate="yes" xml:space="preserve">
          <source>It is recommended for header keys to be in lower-case, to avoid sending duplicate keys in a request. As a convenience, this is validated during testing which raises a &lt;a href=&quot;plug.conn.invalidheadererror&quot;&gt;&lt;code&gt;Plug.Conn.InvalidHeaderError&lt;/code&gt;&lt;/a&gt; if the header key is not lowercase.</source>
          <target state="translated">建议将标头键设置为小写，以避免在请求中发送重复的键。为方便起见，在测试过程中对此进行了验证，如果标头键不是小写字母，则会引发&lt;a href=&quot;plug.conn.invalidheadererror&quot;&gt; &lt;code&gt;Plug.Conn.InvalidHeaderError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b406934b6940f484ccb4f4e12d7de52338c19b17" translate="yes" xml:space="preserve">
          <source>It is recommended for header keys to be in lowercase, to avoid sending duplicate keys in a request. Additionally, responses with mixed-case headers served over HTTP/2 are not considered valid by common clients, resulting in dropped responses. As a convenience, when using the &lt;code&gt;Plug.Adapters.Conn.Test&lt;/code&gt; adapter, any headers that aren't lowercase will raise a &lt;a href=&quot;plug.conn.invalidheadererror&quot;&gt;&lt;code&gt;Plug.Conn.InvalidHeaderError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">建议将标头键设置为小写，以避免在请求中发送重复的键。此外，普通客户端不认为具有通过HTTP / 2提供的大小写混合的标头的响应是有效的，从而导致响应丢失。为方便起见，在使用 &lt;code&gt;Plug.Adapters.Conn.Test&lt;/code&gt; 适配器时，所有不小写的标头都将引发&lt;a href=&quot;plug.conn.invalidheadererror&quot;&gt; &lt;code&gt;Plug.Conn.InvalidHeaderError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="40511b3383ca8f06336921afea27344c64c63c88" translate="yes" xml:space="preserve">
          <source>It is recommended for header keys to be in lowercase, to avoid sending duplicate keys in a request. As a convenience, when using the &lt;code&gt;Plug.Adapters.Conn.Test&lt;/code&gt; adapter, any headers that aren&amp;rsquo;t lowercase will raise a &lt;a href=&quot;plug.conn.invalidheadererror&quot;&gt;&lt;code&gt;Plug.Conn.InvalidHeaderError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">建议标头键使用小写字母，以避免在请求中发送重复的键。为了方便起见，在使用 &lt;code&gt;Plug.Adapters.Conn.Test&lt;/code&gt; 适配器时，所有不小写的标头都将引发&lt;a href=&quot;plug.conn.invalidheadererror&quot;&gt; &lt;code&gt;Plug.Conn.InvalidHeaderError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e835d630e658a66295e09f0cfb72bb2ca5635f8b" translate="yes" xml:space="preserve">
          <source>It is recommended to declare your &lt;a href=&quot;#embeds_many/3&quot;&gt;&lt;code&gt;embeds_many/3&lt;/code&gt;&lt;/a&gt; field with type &lt;code&gt;:map&lt;/code&gt; and a default of &lt;code&gt;&quot;[]&quot;&lt;/code&gt; (although Ecto will also automatically translate &lt;code&gt;nil&lt;/code&gt; values from the database into empty lists).</source>
          <target state="translated">建议声明您的&lt;a href=&quot;#embeds_many/3&quot;&gt; &lt;code&gt;embeds_many/3&lt;/code&gt; &lt;/a&gt;字段，其类型为 &lt;code&gt;:map&lt;/code&gt; 且默认值为 &lt;code&gt;&quot;[]&quot;&lt;/code&gt; （尽管Ecto还将自动将数据库中的 &lt;code&gt;nil&lt;/code&gt; 值转换为空列表）。</target>
        </trans-unit>
        <trans-unit id="06eb543ba97430c42676fb74fc38e6d03236b950" translate="yes" xml:space="preserve">
          <source>It is recommended to declare your &lt;a href=&quot;#embeds_many/3&quot;&gt;&lt;code&gt;embeds_many/3&lt;/code&gt;&lt;/a&gt; field with type &lt;code&gt;:map&lt;/code&gt; in your migrations, instead of using &lt;code&gt;{:array, :map}&lt;/code&gt;. Ecto can work with both maps and arrays as the container for embeds (and in most databases map are represented as JSON which allows Ecto to choose what works best).</source>
          <target state="translated">建议在迁移过程中使用类型 &lt;code&gt;:map&lt;/code&gt; 声明您的&lt;a href=&quot;#embeds_many/3&quot;&gt; &lt;code&gt;embeds_many/3&lt;/code&gt; &lt;/a&gt;字段，而不要使用 &lt;code&gt;{:array, :map}&lt;/code&gt; 。Ecto可以将地图和数组都用作嵌入的容器（在大多数数据库中，地图均以JSON表示，这使Ecto可以选择最适合的方式）。</target>
        </trans-unit>
        <trans-unit id="9795c1abaf982033b2c0ed19994a9b57e226ca48" translate="yes" xml:space="preserve">
          <source>It is recommended to generate a custom set of Diffie Hellman parameters, to be used for the DHE key exchange. Use the following OpenSSL CLI command to create a &amp;lsquo;dhparam.pem&amp;rsquo; file:</source>
          <target state="translated">建议生成一组自定义的Diffie Hellman参数，以用于DHE密钥交换。使用以下OpenSSL CLI命令创建&amp;ldquo; dhparam.pem&amp;rdquo;文件：</target>
        </trans-unit>
        <trans-unit id="b6125fd22c0937a1706898816d0d97050f844cc0" translate="yes" xml:space="preserve">
          <source>It is recommended to generate a custom set of Diffie-Hellman parameters, to be used for the DHE key exchange. Use the following OpenSSL CLI command to create a &lt;code&gt;dhparam.pem&lt;/code&gt; file:</source>
          <target state="translated">建议生成一组自定义的Diffie-Hellman参数，以用于DHE密钥交换。使用以下OpenSSL CLI命令创建 &lt;code&gt;dhparam.pem&lt;/code&gt; 文件：</target>
        </trans-unit>
        <trans-unit id="1ed21c543268df4242ce9c821e6a091cd15a3cd4" translate="yes" xml:space="preserve">
          <source>It is recommended to include this metadata configuration in your production configuration file.</source>
          <target state="translated">建议在你的生产配置文件中包含这个元数据配置。</target>
        </trans-unit>
        <trans-unit id="ee450f18792f77e7f28caa695a4e8a21ae132da1" translate="yes" xml:space="preserve">
          <source>It is recommended to only use this module in production if SSL is enabled and enforced. See &lt;a href=&quot;plug.ssl&quot;&gt;&lt;code&gt;Plug.SSL&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">如果启用并强制使用SSL，建议仅在生产中使用此模块。有关更多信息，请参见&lt;a href=&quot;plug.ssl&quot;&gt; &lt;code&gt;Plug.SSL&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="21f5e912f003026e9540afe4bf51bf871b3398c0" translate="yes" xml:space="preserve">
          <source>It is rendered in the error page as a collection of buttons and follows the format of: &lt;code&gt;[%{label: String.t(), handler: {module(), function :: atom(), args :: []}}]&lt;/code&gt;.</source>
          <target state="translated">它在错误页面中以按钮集合的形式呈现，并遵循以下格式： &lt;code&gt;[%{label: String.t(), handler: {module(), function :: atom(), args :: []}}]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3ce90e2d8912f1f2f7b4ea1417a8fb3575961cda" translate="yes" xml:space="preserve">
          <source>It is similar to &lt;a href=&quot;#media_type/1&quot;&gt;&lt;code&gt;media_type/1&lt;/code&gt;&lt;/a&gt; except wildcards are not accepted in the type nor in the subtype.</source>
          <target state="translated">它与&lt;a href=&quot;#media_type/1&quot;&gt; &lt;code&gt;media_type/1&lt;/code&gt; &lt;/a&gt;相似，除了在类型和子类型中均不接受通配符。</target>
        </trans-unit>
        <trans-unit id="ed4b71fb3d52453bbf4aa28da6905ada01f52ccb" translate="yes" xml:space="preserve">
          <source>It is used on &lt;a href=&quot;ecto.repo#c:all/2&quot;&gt;&lt;code&gt;Ecto.Repo.all/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;ecto.repo#c:update_all/3&quot;&gt;&lt;code&gt;Ecto.Repo.update_all/3&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;ecto.repo#c:delete_all/2&quot;&gt;&lt;code&gt;Ecto.Repo.delete_all/2&lt;/code&gt;&lt;/a&gt;. If returns a tuple, saying if this query can be cached or not, and the &lt;code&gt;prepared&lt;/code&gt; query. The &lt;code&gt;prepared&lt;/code&gt; query is any term that will be passed to the adapter's &lt;a href=&quot;#c:execute/5&quot;&gt;&lt;code&gt;execute/5&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">它在&lt;a href=&quot;ecto.repo#c:all/2&quot;&gt; &lt;code&gt;Ecto.Repo.all/2&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;ecto.repo#c:update_all/3&quot;&gt; &lt;code&gt;Ecto.Repo.update_all/3&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;ecto.repo#c:delete_all/2&quot;&gt; &lt;code&gt;Ecto.Repo.delete_all/2&lt;/code&gt; 上使用&lt;/a&gt;。如果返回一个元组，则说明该查询是否可以缓存，以及 &lt;code&gt;prepared&lt;/code&gt; 查询。该 &lt;code&gt;prepared&lt;/code&gt; 查询将被传递到适配器的任何条款&lt;a href=&quot;#c:execute/5&quot;&gt; &lt;code&gt;execute/5&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7d8b235293c3fd441987efade8483fcf5a50bbd4" translate="yes" xml:space="preserve">
          <source>It is very common in Phoenix applications to namespace all of your routes under the application scope:</source>
          <target state="translated">在Phoenix应用中,将所有的路由都命名为应用范围下的空间是非常常见的。</target>
        </trans-unit>
        <trans-unit id="511755381ec8f835711d51bfe3c71d347d8afc8e" translate="yes" xml:space="preserve">
          <source>It is very important to keep in mind that Ecto is unable to do any type casting described above when fragments are used. You can however use the &lt;a href=&quot;#type/2&quot;&gt;&lt;code&gt;type/2&lt;/code&gt;&lt;/a&gt; function to give Ecto some hints:</source>
          <target state="translated">请记住，使用片段时Ecto无法执行上述任何类型转换，这一点非常重要。但是，您可以使用&lt;a href=&quot;#type/2&quot;&gt; &lt;code&gt;type/2&lt;/code&gt; &lt;/a&gt;函数为Ecto提供一些提示：</target>
        </trans-unit>
        <trans-unit id="03eb895c6aaf845d553a17cb55cfa9b526d9cdd9" translate="yes" xml:space="preserve">
          <source>It is worth noting that the &lt;code&gt;text/2&lt;/code&gt;, &lt;code&gt;json/2&lt;/code&gt;, and &lt;code&gt;html/2&lt;/code&gt; functions require neither a Phoenix view, nor a template to render.</source>
          <target state="translated">值得注意的是， &lt;code&gt;text/2&lt;/code&gt; ， &lt;code&gt;json/2&lt;/code&gt; 和 &lt;code&gt;html/2&lt;/code&gt; 函数既不需要Phoenix视图，也不需要模板来呈现。</target>
        </trans-unit>
        <trans-unit id="2c89a89c57953342eddacd89ee3ae33933dbb8c2" translate="yes" xml:space="preserve">
          <source>It is worth noting that the cipher lists and TLS protocol versions selected by the profiles are whitelists. If a new Erlang/OTP release introduces new TLS protocol versions or ciphers that are not included in the profile definition, they would have to be enabled explicitly by overriding the &lt;code&gt;:ciphers&lt;/code&gt; and/or &lt;code&gt;:versions&lt;/code&gt; options, until such time as they are added to the &lt;a href=&quot;plug.ssl&quot;&gt;&lt;code&gt;Plug.SSL&lt;/code&gt;&lt;/a&gt; profiles.</source>
          <target state="translated">值得注意的是，配置文件选择的密码列表和TLS协议版本为白名单。如果新的Erlang / OTP版本引入了新的TLS协议版本或未包含在配置文件定义中的密码，则必须通过覆盖 &lt;code&gt;:ciphers&lt;/code&gt; 和/或 &lt;code&gt;:versions&lt;/code&gt; 选项来显式启用它们，直到将其添加到该&lt;a href=&quot;plug.ssl&quot;&gt; &lt;code&gt;Plug.SSL&lt;/code&gt; &lt;/a&gt;配置文件。</target>
        </trans-unit>
        <trans-unit id="3f8bd155fb3b264871458601bfe98b34947ef8af" translate="yes" xml:space="preserve">
          <source>It must be a map and Ecto itself will always inject two keys into the meta:</source>
          <target state="translated">它必须是一张地图,Ecto本身总是会向meta注入两个键。</target>
        </trans-unit>
        <trans-unit id="d812a176eca481ceed3aeedcb084d96bdf1cfa9d" translate="yes" xml:space="preserve">
          <source>It must return a tuple containing the number of entries and the result set as a list of lists. The entries in the actual list will depend on what has been selected by the query. The result set may also be &lt;code&gt;nil&lt;/code&gt;, if no value is being selected.</source>
          <target state="translated">它必须返回一个包含条目数和结果集（作为列表列表）的元组。实际列表中的条目将取决于查询所选择的内容。如果未选择任何值，则结果集也可以为 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6c7bf550d2dd91e3eb7f4d8ba8c5d8e72098cb71" translate="yes" xml:space="preserve">
          <source>It must return a tuple containing the number of entries and the result set as a list of lists. The result set may also be &lt;code&gt;nil&lt;/code&gt; if a particular operation does not support them.</source>
          <target state="translated">它必须返回一个包含条目数和结果集（作为列表列表）的元组。如果特定操作不支持结果集，则结果集也可能为 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="64d6ad431d01d7158a8dd5f4441d9f4c19873287" translate="yes" xml:space="preserve">
          <source>It must return either &lt;code&gt;{:ok, socket}&lt;/code&gt; or &lt;code&gt;{:ok, socket, options}&lt;/code&gt;, where &lt;code&gt;options&lt;/code&gt; is one of:</source>
          <target state="translated">它必须返回 &lt;code&gt;{:ok, socket}&lt;/code&gt; 或 &lt;code&gt;{:ok, socket, options}&lt;/code&gt; ，其中 &lt;code&gt;options&lt;/code&gt; 是以下之一：</target>
        </trans-unit>
        <trans-unit id="c372464cefb3e13bb0538ac72ed0e91a45083451" translate="yes" xml:space="preserve">
          <source>It parses the key and stores the value into the current accumulator. The keys and values are not assumed to be encoded in &quot;x-www-form-urlencoded&quot;.</source>
          <target state="translated">它解析密钥并将值存储到当前的累加器中。密钥和值不假定为 &quot;x-www-form-urlencoded &quot;编码。</target>
        </trans-unit>
        <trans-unit id="314f1d4137cff9c77fcca4b6566e917e92565ed8" translate="yes" xml:space="preserve">
          <source>It prints some connection information to the terminal</source>
          <target state="translated">它打印一些连接信息到终端</target>
        </trans-unit>
        <trans-unit id="f49388dc41541c5a93c112295bb0bf75921390c9" translate="yes" xml:space="preserve">
          <source>It provides a set of macros to generate routes. For example:</source>
          <target state="translated">它提供了一组宏来生成路由。例如:</target>
        </trans-unit>
        <trans-unit id="c755bbbfc1da5a9d523689127fd834eafd36c41a" translate="yes" xml:space="preserve">
          <source>It receives a &lt;code&gt;dumper&lt;/code&gt; function in case the parameterized type is also a composite type. In order to dump the inner type, the &lt;code&gt;dumper&lt;/code&gt; must be called with the inner type and the inner value as argument.</source>
          <target state="translated">如果参数化类型也是复合类型，则它将接收 &lt;code&gt;dumper&lt;/code&gt; 函数。为了转储内类型， &lt;code&gt;dumper&lt;/code&gt; 必须与内型和内值作为参数来调用。</target>
        </trans-unit>
        <trans-unit id="5f17d561fdc66ef79304d69e078c0e5c0312c23e" translate="yes" xml:space="preserve">
          <source>It receives a &lt;code&gt;loader&lt;/code&gt; function in case the parameterized type is also a composite type. In order to load the inner type, the &lt;code&gt;loader&lt;/code&gt; must be called with the inner type and the inner value as argument.</source>
          <target state="translated">如果参数化类型也是复合类型，则它将接收 &lt;code&gt;loader&lt;/code&gt; 功能。为了加载内部类型，必须使用内部类型和内部值作为参数来调用 &lt;code&gt;loader&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="328d30d44e29c2cd6e3dd38f65d5cb32fb69e161" translate="yes" xml:space="preserve">
          <source>It receives a connection and options (that we do not use)</source>
          <target state="translated">它接收一个连接和选项(我们不使用)。</target>
        </trans-unit>
        <trans-unit id="aeb6380d88e1271819dcb40ba83ee9babe0b5d5c" translate="yes" xml:space="preserve">
          <source>It receives a connection, a list of formats that the server is capable of rendering and then proceeds to perform content negotiation based on the request information. If the client accepts any of the given formats, the request proceeds.</source>
          <target state="translated">它接收到一个连接,一个服务器能够渲染的格式列表,然后根据请求信息进行内容协商。如果客户端接受任何一种给定的格式,请求就会继续进行。</target>
        </trans-unit>
        <trans-unit id="a632a124b740ee3ecfe4c66cfbe50a9b8a5330c6" translate="yes" xml:space="preserve">
          <source>It receives the primitive type and the Ecto type (which may be primitive as well). It returns a list of dumpers with the given type usually at the beginning.</source>
          <target state="translated">它接收基元类型和Ecto类型(也可能是基元类型)。它返回一个通常在开头给定类型的转储器列表。</target>
        </trans-unit>
        <trans-unit id="c5336dd4112321d4cfb426214c2399ecd75a7e8c" translate="yes" xml:space="preserve">
          <source>It receives the primitive type and the Ecto type (which may be primitive as well). It returns a list of loaders with the given type usually at the end.</source>
          <target state="translated">它接收基元类型和Ecto类型(也可能是基元类型)。它返回一个通常在最后给定类型的加载器列表。</target>
        </trans-unit>
        <trans-unit id="8d567de13218d83676c9bf848a612d0dcb63a942" translate="yes" xml:space="preserve">
          <source>It receives the socket options from the endpoint, for example:</source>
          <target state="translated">例如,它从端点接收套接字选项。</target>
        </trans-unit>
        <trans-unit id="eead6f123b731bd151755a8d6351651f60a5cb89" translate="yes" xml:space="preserve">
          <source>It requires the given form to be configured with &lt;code&gt;multipart: true&lt;/code&gt; when invoking &lt;a href=&quot;#form_for/4&quot;&gt;&lt;code&gt;form_for/4&lt;/code&gt;&lt;/a&gt;, otherwise it fails with &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">它要求给定的表单配置成 &lt;code&gt;multipart: true&lt;/code&gt; 在调用&lt;a href=&quot;#form_for/4&quot;&gt; &lt;code&gt;form_for/4&lt;/code&gt; &lt;/a&gt;时为true，否则会失败，并出现&lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b444a758782f3e5a243723f32117b04bcd1193d7" translate="yes" xml:space="preserve">
          <source>It requires two options:</source>
          <target state="translated">它需要两个选项。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
