<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="phoenix">
    <body>
      <group id="phoenix">
        <trans-unit id="8dbd5bf505a906190aaecf44ee8fc72561677242" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;endpoint&lt;/code&gt; - The endpoint module, for example &lt;code&gt;MyApp.Endpoint&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;endpoint&lt;/code&gt; -端点模块，例如 &lt;code&gt;MyApp.Endpoint&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d9edaabc945a49faf042447eabee463458415d2f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;errors&lt;/code&gt; - All errors from validations</source>
          <target state="translated">&lt;code&gt;errors&lt;/code&gt; -验证中的所有错误</target>
        </trans-unit>
        <trans-unit id="59b58aaaab5203cea8b44f2fbc67a701acda2a6b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;errors&lt;/code&gt; and &lt;code&gt;validations&lt;/code&gt; - they are simply concatenated.</source>
          <target state="translated">&lt;code&gt;errors&lt;/code&gt; 和 &lt;code&gt;validations&lt;/code&gt; -它们只是串联在一起。</target>
        </trans-unit>
        <trans-unit id="8f3f00b87b9c8454bc078c02c62011828df10aa7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;event&lt;/code&gt;- The string event name, for example &amp;ldquo;phx_join&amp;rdquo;</source>
          <target state="translated">&lt;code&gt;event&lt;/code&gt; -字符串事件名称，例如&amp;ldquo;phx_join&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="668c87f2a5869478320481db801806d9e77f78c6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;field&lt;/code&gt; - The name of the association field on the schema</source>
          <target state="translated">&lt;code&gt;field&lt;/code&gt; -联想场对架构名称</target>
        </trans-unit>
        <trans-unit id="4a91378666385a214e2ba31bed3572337c0ff59b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;forward&lt;/code&gt; accepts the following options:</source>
          <target state="translated">&lt;code&gt;forward&lt;/code&gt; 接受以下选项：</target>
        </trans-unit>
        <trans-unit id="44fdddd9aec385a0927980e479f82a27a6485358" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;from&lt;/code&gt; and &lt;code&gt;join&lt;/code&gt; also support index hints, as found in databases such as &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/index-hints.html&quot;&gt;MySQL&lt;/a&gt; and &lt;a href=&quot;https://docs.microsoft.com/en-us/sql/t-sql/queries/hints-transact-sql-table?view=sql-server-2017&quot;&gt;MSSQL&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;from&lt;/code&gt; 和 &lt;code&gt;join&lt;/code&gt; 还支持索引提示，如&lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/index-hints.html&quot;&gt;MySQL&lt;/a&gt;和&lt;a href=&quot;https://docs.microsoft.com/en-us/sql/t-sql/queries/hints-transact-sql-table?view=sql-server-2017&quot;&gt;MSSQL&lt;/a&gt;这样的数据库中的索引提示。</target>
        </trans-unit>
        <trans-unit id="cba3ce899573666d281b9ff444ae82b36f411003" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gc_server&lt;/code&gt; - The registered server name or pid</source>
          <target state="translated">&lt;code&gt;gc_server&lt;/code&gt; -注册的服务器名称或pid</target>
        </trans-unit>
        <trans-unit id="05eaf59bb6cde2c9fd3f75d19d83116a1f08a5d6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;get&lt;/code&gt; is a Phoenix macro that corresponds to the HTTP verb GET. Similar macros exist for other HTTP verbs including POST, PUT, PATCH, DELETE, OPTIONS, CONNECT, TRACE and HEAD.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c657f7e7c4efa726387b5bca016ed8175980cdb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;get&lt;/code&gt;, &lt;code&gt;post&lt;/code&gt;, &lt;code&gt;put&lt;/code&gt;, &lt;code&gt;patch&lt;/code&gt;, &lt;code&gt;delete&lt;/code&gt;, &lt;code&gt;options&lt;/code&gt;, &lt;code&gt;connect&lt;/code&gt;, &lt;code&gt;trace&lt;/code&gt;, &lt;code&gt;head&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;get&lt;/code&gt; ， &lt;code&gt;post&lt;/code&gt; ， &lt;code&gt;put&lt;/code&gt; ， &lt;code&gt;patch&lt;/code&gt; ， &lt;code&gt;delete&lt;/code&gt; ， &lt;code&gt;options&lt;/code&gt; ， &lt;code&gt;connect&lt;/code&gt; ， &lt;code&gt;trace&lt;/code&gt; ， &lt;code&gt;head&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="98e52e06e0331479a62ea10bc00f303f3f507f2c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;get_value&lt;/code&gt; is the retrieved value (which can be operated on before being returned)</source>
          <target state="translated">&lt;code&gt;get_value&lt;/code&gt; 是检索到的值（可以在返回之前对其进行操作）</target>
        </trans-unit>
        <trans-unit id="50ec8f6c4a4f0f0d84457bf3294f81154d218c3b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;group_by&lt;/code&gt; also accepts a list of atoms where each atom refers to a field in source. For more complicated queries you can access fields directly instead of atoms.</source>
          <target state="translated">&lt;code&gt;group_by&lt;/code&gt; 还接受原子列表，其中每个原子都指源中的一个字段。对于更复杂的查询，您可以直接访问字段而不是原子。</target>
        </trans-unit>
        <trans-unit id="a10d6c2d72038d70bb97861d2206068620bead68" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;halted&lt;/code&gt; - the boolean status on whether the pipeline was halted</source>
          <target state="translated">&lt;code&gt;halted&lt;/code&gt; -管道是否暂停的布尔状态</target>
        </trans-unit>
        <trans-unit id="df11e0f777caddadd28752850c0ea1c11432e553" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;handleEvent(event, (payload) =&amp;gt; ...)&lt;/code&gt; - method to handle an event pushed from the server</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4600c41d3365badfa7e4209327292730b13256cb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;handle_out/3&lt;/code&gt; callbacks must return one of:</source>
          <target state="translated">&lt;code&gt;handle_out/3&lt;/code&gt; 回调必须返回以下之一：</target>
        </trans-unit>
        <trans-unit id="d0128554f32d386f4289598774287e4e88d7412d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;handler&lt;/code&gt; - The socket module where this socket originated, for example: &lt;code&gt;MyApp.UserSocket&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;handler&lt;/code&gt; -插座模块，其中该插座起源，例如： &lt;code&gt;MyApp.UserSocket&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7e46b883edcd4081fc95cc313d38c36152a77636" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;handler&lt;/code&gt; a MFArgs that will be executed when this action is triggered</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="524f7e30658816b4fd6a4b55651f92f65c49b7d1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;has_many&lt;/code&gt; can be used to define hierarchical relationships within a single schema, for example threaded comments.</source>
          <target state="translated">&lt;code&gt;has_many&lt;/code&gt; 可用于定义单个架构内的层次关系，例如线程注释。</target>
        </trans-unit>
        <trans-unit id="bdeb6930f3287707d3e196bf9ad5e2e53ad7094a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hooks&lt;/code&gt; &amp;ndash; a reference to a user-defined hooks namespace, containing client callbacks for server/client interop. See the interop section below for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b077bbf122963118bf4bd9a4e8595f7482dbeb98" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;host&lt;/code&gt; - the requested host as a binary, example: &lt;code&gt;&quot;www.example.com&quot;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;host&lt;/code&gt; -以二进制形式请求的主机，例如： &lt;code&gt;&quot;www.example.com&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="02b1f40fbd54a788648bfdb46a54042d80f2234b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;id/1&lt;/code&gt; - receives the socket returned by &lt;code&gt;connect/2&lt;/code&gt; and returns the id of this connection as a string. The &lt;code&gt;id&lt;/code&gt; is used to identify socket connections, often to a particular user, allowing us to force disconnections. For sockets requiring no authentication, &lt;code&gt;nil&lt;/code&gt; can be returned.</source>
          <target state="translated">&lt;code&gt;id/1&lt;/code&gt; -接收由 &lt;code&gt;connect/2&lt;/code&gt; 返回的套接字，并以字符串形式返回此连接的ID。该 &lt;code&gt;id&lt;/code&gt; 是用来标识套接字连接，经常到一个特定的用户，让我们来强制断开。对于不需要身份验证的套接字，可以返回 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a083637f878534b4f996b95618db816a2068b3e0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;id/1&lt;/code&gt; - receives the socket returned by &lt;code&gt;connect/3&lt;/code&gt; and returns the id of this connection as a string. The &lt;code&gt;id&lt;/code&gt; is used to identify socket connections, often to a particular user, allowing us to force disconnections. For sockets requiring no authentication, &lt;code&gt;nil&lt;/code&gt; can be returned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8760f24908d1cc31e129470b0c3921f1006f2be5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;id&lt;/code&gt; - The DOM id of the LiveView</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0f36b342982b9967c866bd37637dac595318f8f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;id&lt;/code&gt; - The string id of the socket</source>
          <target state="translated">&lt;code&gt;id&lt;/code&gt; -套接字的字符串ID</target>
        </trans-unit>
        <trans-unit id="3b7899c38049ecfa25c353f9e0684db46c9045e2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ignore&lt;/code&gt; - ignores updates to the DOM regardless of new content changes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b1d9bad82657262f6d8fa3e6465e57b2815237a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;inc&lt;/code&gt; - increments (or decrements if the value is negative) the given field in the table by the given value</source>
          <target state="translated">&lt;code&gt;inc&lt;/code&gt; -将表中的给定字段增加（或减小，如果值是负数）</target>
        </trans-unit>
        <trans-unit id="8a4163994855fbc15bd391cf9497da10628839eb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;init/1&lt;/code&gt; which initializes any arguments or options to be passed to &lt;code&gt;call/2&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef0c6a6de6ca13024ac4a294bfc40896fc29eea9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;init_arg&lt;/code&gt; is the argument term (second argument) passed to &lt;a href=&quot;#start_link/3&quot;&gt;&lt;code&gt;start_link/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9dff694619e6e23269799d025b46fd57d376dce" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;input_path&lt;/code&gt; - The path where the assets are located</source>
          <target state="translated">&lt;code&gt;input_path&lt;/code&gt; -资产所在的路径</target>
        </trans-unit>
        <trans-unit id="c5ae964f45075d85a78e2dea260e5b094dfe3d80" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;join_defaults&lt;/code&gt; - A list of defaults for join associations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72e4ee4913f961c9a4b7c29d32492f68e19f6e4b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;join_keys&lt;/code&gt; - The keyword list with many to many join keys</source>
          <target state="translated">&lt;code&gt;join_keys&lt;/code&gt; -包含许多对联键的关键字列表</target>
        </trans-unit>
        <trans-unit id="4475cd0a0d4fef0b5617f1e177a632cda8408a74" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;join_ref&lt;/code&gt; - The ref sent by the client when joining</source>
          <target state="translated">&lt;code&gt;join_ref&lt;/code&gt; -客户端加入时发送的参考</target>
        </trans-unit>
        <trans-unit id="033042548c899de9336607002781cabe646ba3ee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;join_through&lt;/code&gt; - Atom (representing a schema) or a string (representing a table) for many to many associations</source>
          <target state="translated">&lt;code&gt;join_through&lt;/code&gt; -多对多关联的 Atom（表示架构）或字符串（表示表）</target>
        </trans-unit>
        <trans-unit id="4ff2cd1f26d7677d1ea7be8a102c57a144123171" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;joined&lt;/code&gt; - If the socket has effectively joined the channel</source>
          <target state="translated">&lt;code&gt;joined&lt;/code&gt; -如果套接字已有效加入频道</target>
        </trans-unit>
        <trans-unit id="ba377f67ecee40301795593b5845f36339a1c83d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;keep&lt;/code&gt; - The number of old versions to keep</source>
          <target state="translated">&lt;code&gt;keep&lt;/code&gt; -旧版本的数量，以保持</target>
        </trans-unit>
        <trans-unit id="aa2a4d88e36458095a07be41cda1bef97c2d53cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;key&lt;/code&gt; - The key identifying this presence</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; -标识此存在的键</target>
        </trans-unit>
        <trans-unit id="0783a714f2079cf68176ecedddab548909d2517d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;key&lt;/code&gt; - The key of the presence</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; -存在的键</target>
        </trans-unit>
        <trans-unit id="74dee47697a859176e1ea99bc7d001624d5b6176" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;key&lt;/code&gt; is an atom that represents any field, embed or association in the changeset. Note the &lt;code&gt;value&lt;/code&gt; is directly stored in the changeset with no validation whatsoever. For this reason, this function is meant for working with data internal to the application.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 是表示变更集中任何字段，嵌入或关联的原子。请注意，该 &lt;code&gt;value&lt;/code&gt; 直接存储在变更集中，而无需进行任何验证。因此，此功能用于处理应用程序内部的数据。</target>
        </trans-unit>
        <trans-unit id="fec2c01dfd33d8ea1494f964482b06773fd44184" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;label&lt;/code&gt; a string/binary that names this action</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23a54cc6f718e22576f0892705f452d338d0f519" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lib&lt;/code&gt; - a directory that holds your application source code. This directory is broken into two subdirectories, &lt;code&gt;lib/hello&lt;/code&gt; and &lt;code&gt;lib/hello_web&lt;/code&gt;. The &lt;code&gt;lib/hello&lt;/code&gt; directory will be responsible to host all of your business logic and business domain. It typically interacts directly with the database - it is the &quot;Model&quot; in Model-View-Controller (MVC) architecture. &lt;code&gt;lib/hello_web&lt;/code&gt; is responsible for exposing your business domain to the world, in this case, through a web application. It holds both the View and Controller from MVC. We will discuss the contents of these directories with more detail in the next sections</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bbea57c14a5631a6b8d6992eb1b336e0649deb3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;live_component&lt;/code&gt; - compartmentalizes state, markup, and events</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cb29cafab5d3a6fd4e5e13463c75a3c8614561a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;live_render&lt;/code&gt; - compartmentalizes state, markup, events, and error isolation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3532c1a568b33337de71436794ff90d6697591a9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lv:clear-flash&lt;/code&gt; &amp;ndash; clears the flash when sent to the server. If a &lt;code&gt;phx-value-key&lt;/code&gt; is provided, the specific key will be removed from the flash.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6efc4486225466bcb4bb3a50a9925455d3cba9d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max_delta_sizes&lt;/code&gt; - The list of delta generation sizes to keep before falling back to sending entire state. Defaults &lt;code&gt;[100, 1000, 10_000]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;max_delta_sizes&lt;/code&gt; -在退回到发送整个状态之前要保留的增量生成大小的列表。默认值 &lt;code&gt;[100, 1000, 10_000]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="987ff9001ecd494c25e6ef563e17f3fe60fc42da" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max_silent_periods&lt;/code&gt; - The max integer of broadcast periods for which no delta broadcasts have been sent. Defaults &lt;code&gt;10&lt;/code&gt; (15s heartbeat)</source>
          <target state="translated">&lt;code&gt;max_silent_periods&lt;/code&gt; -未发送增量广播的广播周期的最大整数。默认值 &lt;code&gt;10&lt;/code&gt; （15s心跳）</target>
        </trans-unit>
        <trans-unit id="492c66a3f6bfa5477a4c651d837532e7ec419a56" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;measurements&lt;/code&gt; - A map of atom keys (e.g. &lt;code&gt;:duration&lt;/code&gt;) and numeric values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3de05497aed68e61231371d7fde7ad036371310b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;message&lt;/code&gt; - The payload of the broadcast</source>
          <target state="translated">&lt;code&gt;message&lt;/code&gt; -广播的有效负载</target>
        </trans-unit>
        <trans-unit id="a98979d797e9cd1b3df09361e9856e1361a9f82f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;meta&lt;/code&gt; - Either a new map of metadata to attach to this presence, or a function. The function will receive the current metadata as input and the return value will be used as the new metadata</source>
          <target state="translated">&lt;code&gt;meta&lt;/code&gt; -要附加到此状态的新的元数据映射或函数。该函数将接收当前的元数据作为输入，并且返回值将用作新的元数据</target>
        </trans-unit>
        <trans-unit id="dd95b5eeb5bcdf67736b6285795ac639e6b3439b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;meta&lt;/code&gt; - The map of metadata to attach to this presence</source>
          <target state="translated">&lt;code&gt;meta&lt;/code&gt; -附加到此状态的元数据映射</target>
        </trans-unit>
        <trans-unit id="463053aaa0c8f9b257e3fbd97f8167c647fff086" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;metadata&lt;/code&gt; - A map of key/value pairs that can be used for tagging metrics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f1cfc9235e334bda47946b04d8e6153452ac028" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;method-param&lt;/code&gt; - a request parameter where expected a custom HTTP method</source>
          <target state="translated">&lt;code&gt;method-param&lt;/code&gt; -一个期望自定义HTTP方法的请求参数</target>
        </trans-unit>
        <trans-unit id="073a7768fad0def734e63a744eb526e08585ef4e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;method&lt;/code&gt; - the request method as a binary, example: &lt;code&gt;&quot;GET&quot;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;method&lt;/code&gt; -以二进制形式的请求方法，例如： &lt;code&gt;&quot;GET&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="aafb8a58dea8783be5dbf5934648d694c596e504" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;module&lt;/code&gt; - The channel module handler, for example &lt;code&gt;MyApp.RoomChannel&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;module&lt;/code&gt; -信道模块的处理程序，例如 &lt;code&gt;MyApp.RoomChannel&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="07716c12c4ba76513695593e8b1f76d9cbb8f36d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;module&lt;/code&gt; - The channel module handler, for example &lt;code&gt;MyAppWeb.RoomChannel&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dad28da3c44d59a50496cb192cbac75bc618c3d5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;module&lt;/code&gt; - The module of the running LiveView</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50ffe6d07d8740ddcb2d86532bc91a2f75d71e50" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mounted&lt;/code&gt; - the element has been added to the DOM and its server LiveView has finished mounting</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2eaf9afb0b18cfd6c31c3c8e4486386b57c6369" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mssql&lt;/code&gt; - via &lt;a href=&quot;https://github.com/livehelpnow/tds&quot;&gt;https://github.com/livehelpnow/tds&lt;/a&gt; Please check the driver docs for more information and requirements. Defaults to &quot;postgres&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf3781c5f33126b6b5a463a7271b48a2e2f4458c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mysql&lt;/code&gt; - via &lt;a href=&quot;https://github.com/elixir-ecto/myxql&quot;&gt;https://github.com/elixir-ecto/myxql&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88ae990434cd3c2bf55e963d5908aec7e902bf32" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;naive_datetime&lt;/code&gt; - has a precision of seconds and casts values to Elixir&amp;rsquo;s &lt;a href=&quot;https://hexdocs.pm/elixir/NaiveDateTime.html&quot;&gt;&lt;code&gt;NaiveDateTime&lt;/code&gt;&lt;/a&gt; struct which has no timezone information.</source>
          <target state="translated">&lt;code&gt;naive_datetime&lt;/code&gt; -具有秒精度，并将值强制转换为Elixir的&lt;a href=&quot;https://hexdocs.pm/elixir/NaiveDateTime.html&quot;&gt; &lt;code&gt;NaiveDateTime&lt;/code&gt; &lt;/a&gt;结构，该结构没有时区信息。</target>
        </trans-unit>
        <trans-unit id="72190aad3be538b4ccd471924a62f1cbc3d0c5ea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;naive_datetime&lt;/code&gt; - has a precision of seconds and casts values to Elixir's &lt;a href=&quot;https://hexdocs.pm/elixir/NaiveDateTime.html&quot;&gt;&lt;code&gt;NaiveDateTime&lt;/code&gt;&lt;/a&gt; struct which has no timezone information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ea7a90df3b84001b80cc2821e898e38884aab0a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;naive_datetime_usec&lt;/code&gt; - has a default precision of microseconds and also casts values to &lt;a href=&quot;https://hexdocs.pm/elixir/NaiveDateTime.html&quot;&gt;&lt;code&gt;NaiveDateTime&lt;/code&gt;&lt;/a&gt; with no timezone information.</source>
          <target state="translated">&lt;code&gt;naive_datetime_usec&lt;/code&gt; -具有默认的微秒精度，并且还将没有时区信息的值强制转换为&lt;a href=&quot;https://hexdocs.pm/elixir/NaiveDateTime.html&quot;&gt; &lt;code&gt;NaiveDateTime&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="51dbf7e5041587314a31577e6618e8e0b3f71e3d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;name&lt;/code&gt; - A string (e.g. &lt;code&gt;&quot;my_app.worker.stop&quot;&lt;/code&gt;) or a list of atoms that uniquely identifies the event.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92e5ba0cc31bfe12a2a673e8b795bd8b531755e0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;name&lt;/code&gt; must be a compile-time literal string that is being used as the table name to join the CTE in the main query or in the recursive CTE.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="301f84b74fc20491f743cd765b9febdae2256dd4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;new_data&lt;/code&gt; is &lt;code&gt;data&lt;/code&gt; after updating the value of &lt;code&gt;key&lt;/code&gt; with &lt;code&gt;update_value&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;new_data&lt;/code&gt; 是使用 &lt;code&gt;update_value&lt;/code&gt; 更新 &lt;code&gt;key&lt;/code&gt; 的值之后的 &lt;code&gt;data&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="071b5d9e60612b566cae9b30348f283cff64086a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nil&lt;/code&gt; - meaning there is no body</source>
          <target state="translated">&lt;code&gt;nil&lt;/code&gt; -表示没有身体</target>
        </trans-unit>
        <trans-unit id="7b257868b5b9b8cea561cf9f4b32865bee4efdd0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nil&lt;/code&gt; - meaning there is no body;</source>
          <target state="translated">&lt;code&gt;nil&lt;/code&gt; -表示没有身体；</target>
        </trans-unit>
        <trans-unit id="68dababfbb700643426a41acecf9015e6b58146f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nil&lt;/code&gt; - which specifies the field must be nil</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee8c2088dd46a5d35247fd24c0dc0bd6022b5a49" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nil&lt;/code&gt; comparison</source>
          <target state="translated">&lt;code&gt;nil&lt;/code&gt; 比较</target>
        </trans-unit>
        <trans-unit id="cc683e64d5f1778f0dbc56cc4b9ca496abe8bff8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nil&lt;/code&gt; comparison in filters, such as where and having, is forbidden and it will raise an error:</source>
          <target state="translated">&lt;code&gt;nil&lt;/code&gt; 禁止在过滤器中进行零比较，例如where和have，这将引发错误：</target>
        </trans-unit>
        <trans-unit id="71fa2cf56455786b265a7233aef687e50babc74b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;node&lt;/code&gt; - The name of the node to broadcast the message on</source>
          <target state="translated">&lt;code&gt;node&lt;/code&gt; -在其上广播消息的节点的名称</target>
        </trans-unit>
        <trans-unit id="07e06948f26eebc207946c1a1321c20825534155" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;node_name&lt;/code&gt; - The target node name</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b73bbef6c9ffd1b91b3deb04a55da27fe4ecd4a1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;on_delete&lt;/code&gt; - The action taken on associations when schema is deleted</source>
          <target state="translated">&lt;code&gt;on_delete&lt;/code&gt; -删除架构时对关联采取的操作</target>
        </trans-unit>
        <trans-unit id="923388859240c359e51473bac2954f8deb1180cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;on_replace&lt;/code&gt; - The action taken on associations when schema is replaced</source>
          <target state="translated">&lt;code&gt;on_replace&lt;/code&gt; -替换架构时对关联采取的操作</target>
        </trans-unit>
        <trans-unit id="c61e57c28cd8a177ef5ec74fa6da524fb7e6252d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;options&lt;/code&gt; are expected to be an enumerable which will be used to generate each respective &lt;code&gt;option&lt;/code&gt;. The enumerable may have:</source>
          <target state="translated">&lt;code&gt;options&lt;/code&gt; 应该是可枚举的，将用于生成每个相应的 &lt;code&gt;option&lt;/code&gt; 。枚举数可能具有：</target>
        </trans-unit>
        <trans-unit id="85a80a03019e5358fdaba91b26dbe5cc34797b1c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;opts&lt;/code&gt; - The optional list of options, see below</source>
          <target state="translated">&lt;code&gt;opts&lt;/code&gt; -选项的可选列表，请参见下文</target>
        </trans-unit>
        <trans-unit id="127c528cc267bb9f764ed45f5d305d3765aa7530" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;opts&lt;/code&gt; - The optional list of options. See below.</source>
          <target state="translated">&lt;code&gt;opts&lt;/code&gt; -选项的可选列表。见下文。</target>
        </trans-unit>
        <trans-unit id="4ae92590e66d6da2ffacaab3f46c3815c5a0a917" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;opts&lt;/code&gt; - The optional list of options. Supported options only include &lt;code&gt;:link&lt;/code&gt; to link the subscriber to local</source>
          <target state="translated">&lt;code&gt;opts&lt;/code&gt; -选项的可选列表。支持的选项仅包括 &lt;code&gt;:link&lt;/code&gt; link将订户链接到本地</target>
        </trans-unit>
        <trans-unit id="f89598295ec5406306e8e4e687fc49c58df5335e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;or_where&lt;/code&gt; also accepts a keyword list where each key is a field to be compared with the given value. Each key-value pair will be combined using &lt;code&gt;AND&lt;/code&gt;, exactly as in &lt;code&gt;where&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;or_where&lt;/code&gt; 还接受关键字列表，其中每个关键字都是要与给定值进行比较的字段。每个键值对将使用 &lt;code&gt;AND&lt;/code&gt; 进行组合，与 &lt;code&gt;where&lt;/code&gt; 完全相同。</target>
        </trans-unit>
        <trans-unit id="fe0427ecfac7944aecab028a79f8e4a7d29bde93" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;order_by&lt;/code&gt; also accepts a list of atoms where each atom refers to a field in source or a keyword list where the direction is given as key and the field to order as value.</source>
          <target state="translated">&lt;code&gt;order_by&lt;/code&gt; 还接受一个原子列表，其中每个原子都指源中的一个字段或关键字列表，其中方向作为键给出，而要排序的字段作为值。</target>
        </trans-unit>
        <trans-unit id="d3da5895b3011962cca4dbc711f49b48d9c3e8b6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;order_by&lt;/code&gt; may be invoked or listed in a query many times. New expressions are always appended to the previous ones.</source>
          <target state="translated">&lt;code&gt;order_by&lt;/code&gt; 可以多次调用或在查询中列出。新表达式始终附加在以前的表达式之后。</target>
        </trans-unit>
        <trans-unit id="f58a2cf9edd237804c53fa379e1e5635d41834e5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;otp_app&lt;/code&gt; - The OTP app running the endpoint, for example &lt;code&gt;:my_app&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2deb7e032d83f08bd7758501f0932a6aa9918387" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;otp_app&lt;/code&gt; - The otp app running the endpoint, for example &lt;code&gt;:my_app&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;otp_app&lt;/code&gt; -运行端点的otp应用程序，例如 &lt;code&gt;:my_app&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="12fb980e7f3f48b6f24141c40027c59c1d0184e2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;output_path&lt;/code&gt; - The path where the compiled/compressed files will be saved</source>
          <target state="translated">&lt;code&gt;output_path&lt;/code&gt; -编译/压缩文件的保存路径</target>
        </trans-unit>
        <trans-unit id="68edc15d932ff45243dead20fabfe1070fcdf0bb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;owner&lt;/code&gt; - The schema where the association was defined</source>
          <target state="translated">&lt;code&gt;owner&lt;/code&gt; -定义关联的架构</target>
        </trans-unit>
        <trans-unit id="901d6a0f8edb0eb1c7c9bedf21edaf1d45c558f8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;owner&lt;/code&gt; - the Elixir process that owns the connection</source>
          <target state="translated">&lt;code&gt;owner&lt;/code&gt; -长生不老药的过程，拥有连接</target>
        </trans-unit>
        <trans-unit id="90512376c1abfde667c0a6f445cf21b920c60e38" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;owner_key&lt;/code&gt; - The key on the &lt;code&gt;owner&lt;/code&gt; schema used for the association</source>
          <target state="translated">&lt;code&gt;owner_key&lt;/code&gt; -用于关联的 &lt;code&gt;owner&lt;/code&gt; 架构上的键</target>
        </trans-unit>
        <trans-unit id="448ea9b0456e88e43b6a224745193e838be17490" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;page_path&lt;/code&gt; is an example of what Phoenix calls a path helper, and we'll talk about those very soon.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c9bfe1f54ef877ded2b8eead583711db874095f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;params&lt;/code&gt; - The parameters as given on changeset creation</source>
          <target state="translated">&lt;code&gt;params&lt;/code&gt; -在变更集创建时给出的参数</target>
        </trans-unit>
        <trans-unit id="ec7aaecc40dfea835f8b0490814983d1101ded9a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;params&lt;/code&gt; - a map of string keys which contain public information that can be set by the user. The map contains the query params as well as any router path parameter. If the LiveView was not mounted at the router, this argument is the atom &lt;code&gt;:not_mounted_at_router&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36f0ddf7ae31b39a6199cc3eab0b4eeab1477d7f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;params&lt;/code&gt; - params are merged (not deep-merged) giving precedence to the params of &lt;code&gt;changeset2&lt;/code&gt; in case of a conflict. If both changesets have their &lt;code&gt;:params&lt;/code&gt; fields set to &lt;code&gt;nil&lt;/code&gt;, the resulting changeset will have its params set to &lt;code&gt;nil&lt;/code&gt; too.</source>
          <target state="translated">&lt;code&gt;params&lt;/code&gt; -参数数量被合并（未深合并）优先权给予的PARAMS &lt;code&gt;changeset2&lt;/code&gt; 在冲突的情况下。如果两个变更集的 &lt;code&gt;:params&lt;/code&gt; 字段都设置为 &lt;code&gt;nil&lt;/code&gt; ，则结果变更集的参数也将设置为 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b04c7f2e5980a1aab79664ac4aefb583b8812ee6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;params&lt;/code&gt; - the &lt;code&gt;connect_params&lt;/code&gt; to pass to the view's mount callback. May be a literal object or closure returning an object. When a closure is provided, the function receives the view's phx-view name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b8c4501335fa225540f5cac4229b077861a1d11" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;params&lt;/code&gt; - the request params, the result of merging the &lt;code&gt;:body_params&lt;/code&gt; and &lt;code&gt;:query_params&lt;/code&gt; with &lt;code&gt;:path_params&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;params&lt;/code&gt; -的请求参数，合并的结果 &lt;code&gt;:body_params&lt;/code&gt; 和 &lt;code&gt;:query_params&lt;/code&gt; 用 &lt;code&gt;:path_params&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9deea4976a44c1b62c166b6685aa8d76a27998d9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;params&lt;/code&gt; - the request params, the result of merging the &lt;code&gt;:path_params&lt;/code&gt; on top of &lt;code&gt;:body_params&lt;/code&gt; on top of &lt;code&gt;:query_params&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b29b71eb92ce43b45fbe014e176fdd74366bad17" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;params&lt;/code&gt;, the content-type parameters (e.g., &lt;code&gt;%{&quot;foo&quot; =&amp;gt; &quot;bar&quot;}&lt;/code&gt; for the &lt;code&gt;&quot;text/plain; foo=bar&quot;&lt;/code&gt; content-type)</source>
          <target state="translated">&lt;code&gt;params&lt;/code&gt; ，内容类型参数（例如， &lt;code&gt;%{&quot;foo&quot; =&amp;gt; &quot;bar&quot;}&lt;/code&gt; 表示 &lt;code&gt;&quot;text/plain; foo=bar&quot;&lt;/code&gt; 内容类型）</target>
        </trans-unit>
        <trans-unit id="3cb54fa84580a04ac3087492a8f37a5807040416" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;path_info&lt;/code&gt; - the path split into segments, example: &lt;code&gt;[&quot;hello&quot;, &quot;world&quot;]&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;path_info&lt;/code&gt; -路径分为多个段，例如： &lt;code&gt;[&quot;hello&quot;, &quot;world&quot;]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8cee62762965ac6c4625c3e275f4efb6eadb01d8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;path_params&lt;/code&gt; - the request path params, populated by routers such as &lt;a href=&quot;plug.router&quot;&gt;&lt;code&gt;Plug.Router&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;path_params&lt;/code&gt; -由路由器（如&lt;a href=&quot;plug.router&quot;&gt; &lt;code&gt;Plug.Router&lt;/code&gt; )&lt;/a&gt;填充的请求路径参数</target>
        </trans-unit>
        <trans-unit id="1223e490ecfc7361507926c307a8089c528e37a9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;payload&lt;/code&gt; - The message payload</source>
          <target state="translated">&lt;code&gt;payload&lt;/code&gt; -消息有效负载</target>
        </trans-unit>
        <trans-unit id="2933a2b21e8195530e82cab1b95856032107cd6d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;payload&lt;/code&gt; - The reply payload</source>
          <target state="translated">&lt;code&gt;payload&lt;/code&gt; -回复有效负载</target>
        </trans-unit>
        <trans-unit id="d114dfeb57999b3181c1ba3d704b9dbb5aaba20f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;peer&lt;/code&gt; - the actual TCP peer that connected, example: &lt;code&gt;{{127, 0, 0, 1}, 12345}&lt;/code&gt;. Often this is not the actual IP and port of the client, but rather of a load-balancer or request-router.</source>
          <target state="translated">&lt;code&gt;peer&lt;/code&gt; -连接的实际TCP对等方，例如： &lt;code&gt;{{127, 0, 0, 1}, 12345}&lt;/code&gt; 。通常，这不是客户端的实际IP和端口，而是负载平衡器或请求路由器。</target>
        </trans-unit>
        <trans-unit id="aeafb991ec912a189e0a0ffc11b88e8bd6c91af9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;permdown_period&lt;/code&gt; - The interval in milliseconds to flag a replica as permanently down, and discard its state. Note: This must be at least greater than the &lt;code&gt;down_period&lt;/code&gt;. Default &lt;code&gt;1_200_000&lt;/code&gt; (20 minutes)</source>
          <target state="translated">&lt;code&gt;permdown_period&lt;/code&gt; -将副本标记为永久关闭并丢弃其状态的间隔（以毫秒为单位）。注意：该值必须至少大于 &lt;code&gt;down_period&lt;/code&gt; 。默认值 &lt;code&gt;1_200_000&lt;/code&gt; （20分钟）</target>
        </trans-unit>
        <trans-unit id="5e2c9759cd69952e44c050ca670bb66efc3ea2da" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;phoenix_html.js&lt;/code&gt; does trigger a custom event &lt;code&gt;phoenix.link.click&lt;/code&gt; on the clicked DOM element when a click happened. This allows you to intercept the event on it&amp;rsquo;s way bubbling up to &lt;code&gt;window&lt;/code&gt; and do your own custom logic to enhance or replace how the &lt;code&gt;data-confirm&lt;/code&gt; attribute is handled.</source>
          <target state="translated">&lt;code&gt;phoenix_html.js&lt;/code&gt; 当发生点击时，phoenix_html.js会触发自定义事件 &lt;code&gt;phoenix.link.click&lt;/code&gt; 在被点击的DOM元素上。这使您可以通过冒泡到 &lt;code&gt;window&lt;/code&gt; 的方式来拦截事件，并执行自己的自定义逻辑来增强或替换 &lt;code&gt;data-confirm&lt;/code&gt; 属性的处理方式。</target>
        </trans-unit>
        <trans-unit id="48d4d1773633b82236f1ba6658e7610cf2d44d59" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;phoenix_html.js&lt;/code&gt; does trigger a custom event &lt;code&gt;phoenix.link.click&lt;/code&gt; on the clicked DOM element when a click happened. This allows you to intercept the event on it's way bubbling up to &lt;code&gt;window&lt;/code&gt; and do your own custom logic to enhance or replace how the &lt;code&gt;data-confirm&lt;/code&gt; attribute is handled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2cbb3c82f5b4f60d943d241eaea8f1aa261da0f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;phx-auto-recover&lt;/code&gt;, &lt;code&gt;phx-trigger-action&lt;/code&gt;, &lt;code&gt;phx-disable-with&lt;/code&gt;, &lt;code&gt;phx-feedback-for&lt;/code&gt;, &lt;code&gt;phx-submit&lt;/code&gt;, &lt;code&gt;phx-change&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8fb312adabbf0552b622da3a94886b994ae0557" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;phx-blur&lt;/code&gt; - &lt;code&gt;phx-blur-loading&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28c8714e6386f77ac2f374db06544246b2c3e2ea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;phx-capture-click&lt;/code&gt;, &lt;code&gt;phx-click&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db92fccb3c46c996463982244f8313ef5ed26001" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;phx-change&lt;/code&gt; - &lt;code&gt;phx-change-loading&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58832a55f5df7de9d0edee81cdea089d029717b8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;phx-click&lt;/code&gt; - &lt;code&gt;phx-click-loading&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffabb8a70f8c2052ceafff296c2944bcbf4ddcbf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;phx-debounce&lt;/code&gt; - Accepts either an integer timeout value (in milliseconds), or &lt;code&gt;&quot;blur&quot;&lt;/code&gt;. When an integer is provided, emitting the event is delayed by the specified milliseconds. When &lt;code&gt;&quot;blur&quot;&lt;/code&gt; is provided, emitting the event is delayed until the field is blurred by the user. Debouncing is typically used for input elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efc515e4bbf9f4beb0c78793ecdf190bca028bf9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;phx-focus&lt;/code&gt; - &lt;code&gt;phx-focus-loading&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c8b11d12c014ad087525d80e98e6e2ac34f0a8a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;phx-submit&lt;/code&gt; - &lt;code&gt;phx-submit-loading&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ddd7d8809d3fd3b369b8d58f482947aa6744858" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;phx-throttle&lt;/code&gt; - Accepts an integer timeout value to throttle the event in milliseconds. Unlike debounce, throttle will immediately emit the event, then rate limit it at once per provided timeout. Throttling is typically used to rate limit clicks, mouse and keyboard actions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c34079b1868e1438698e4b0a09c3f2eddfe88a09" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;phx-throttle&lt;/code&gt;, &lt;code&gt;phx-debounce&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90c5c10c097847e447c713015924e37964201781" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;phx-window-focus&lt;/code&gt;, &lt;code&gt;phx-window-blur&lt;/code&gt;, &lt;code&gt;phx-focus&lt;/code&gt;, &lt;code&gt;phx-blur&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac1eabb5acd1dc8417f8dcd42f26a83420e77b50" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;phx-window-keydown&lt;/code&gt; - &lt;code&gt;phx-keydown-loading&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8f608ad2c2460764db8454f7cdbd5d10ee51ed2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;phx-window-keyup&lt;/code&gt; - &lt;code&gt;phx-keyup-loading&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="933466f1d2e5d315646e7d6410e2de5331a36b6a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;phx-window-keyup&lt;/code&gt;, &lt;code&gt;phx-window-keydown&lt;/code&gt;, &lt;code&gt;phx-keyup&lt;/code&gt;, &lt;code&gt;phx-keydown&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fc052edab4778366aac1a8c1777d16fd4fa1606" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pid&lt;/code&gt; - The Pid being tracked</source>
          <target state="translated">&lt;code&gt;pid&lt;/code&gt; - PID是追踪</target>
        </trans-unit>
        <trans-unit id="586a289164baf27b93ba186d6aca8f2bbfd353c4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pid&lt;/code&gt; - The Pid of the running LiveView</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71e9584b12c52b8df2b4881e4ff2e2ed55a1cde3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pid&lt;/code&gt; - The Pid to track</source>
          <target state="translated">&lt;code&gt;pid&lt;/code&gt; - PID号来追踪</target>
        </trans-unit>
        <trans-unit id="c090d4cd50b9fad51b3912b2fcc9a9ee21ce65cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pid&lt;/code&gt; - The Pid to untrack</source>
          <target state="translated">&lt;code&gt;pid&lt;/code&gt; - PID号来untrack</target>
        </trans-unit>
        <trans-unit id="9608880e65f853fe83ad37569b04353c3f3d0a08" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pid&lt;/code&gt; - The subscriber pid</source>
          <target state="translated">&lt;code&gt;pid&lt;/code&gt; -订户pid</target>
        </trans-unit>
        <trans-unit id="8e03e5969b840a9d6cc0769b7c9d98e82792440c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;plug/2&lt;/code&gt; in controllers supports guards, allowing a developer to configure a plug to only run in some particular action:</source>
          <target state="translated">&lt;code&gt;plug/2&lt;/code&gt; 控制器中的plug / 2支持防护，允许开发人员将插件配置为仅在某些特定操作中运行：</target>
        </trans-unit>
        <trans-unit id="1e1b930a5728103fb2750c42096186fa075ef60a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pool_opts&lt;/code&gt; - The list of options used to construct the shard pool</source>
          <target state="translated">&lt;code&gt;pool_opts&lt;/code&gt; -用于构建分片池的选项列表</target>
        </trans-unit>
        <trans-unit id="0d6e683099195f6ef8b283b6de0568c9060a1743" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pool_size&lt;/code&gt; - The size of the pool</source>
          <target state="translated">&lt;code&gt;pool_size&lt;/code&gt; -池的大小</target>
        </trans-unit>
        <trans-unit id="c14c92366576b23bc218cbaefd053999dbcbf2a6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;port&lt;/code&gt; - the requested port as an integer, example: &lt;code&gt;80&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;port&lt;/code&gt; -请求的端口，为整数，例如： &lt;code&gt;80&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a833ed8b631b0d4e3cca3dea77a48882349e72f2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;postgres&lt;/code&gt; - via &lt;a href=&quot;https://github.com/elixir-ecto/postgrex&quot;&gt;https://github.com/elixir-ecto/postgrex&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b4a7fc3ad2ee71ab8ddde9cda3989ffcecae263" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;prepend&lt;/code&gt; - prepend the new DOM contents instead of replacing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5e949a29563c28dc3145cea09f4a341fe859328" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;priv&lt;/code&gt; - a directory that keeps all assets that are necessary in production but are not directly part of your source code. You typically keep database scripts, translation files, and more in here</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1619e19e8a919eba5757593d3f3ea0464a6ea0a2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;private&lt;/code&gt; - shared library data as a map</source>
          <target state="translated">&lt;code&gt;private&lt;/code&gt; -共享库数据作为地图</target>
        </trans-unit>
        <trans-unit id="48930653af2def94bfc00bd03545f2774cbc49af" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pubsub&lt;/code&gt; - The name of the pubsub system</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5638e2e4c33a393548e5181a434030d0bec9df77" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pubsub_server&lt;/code&gt; - The registered name of the socket&amp;rsquo;s pubsub server</source>
          <target state="translated">&lt;code&gt;pubsub_server&lt;/code&gt; -套接字的pubsub服务器的注册名称</target>
        </trans-unit>
        <trans-unit id="6ba478ff86a260e4f4a3986bd24b579a4a76140f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pubsub_server&lt;/code&gt; - The registered server name</source>
          <target state="translated">&lt;code&gt;pubsub_server&lt;/code&gt; -注册的服务器名称</target>
        </trans-unit>
        <trans-unit id="e5b8312e520039e95e40ce565fc676c1dd6888a9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pubsub_server&lt;/code&gt; - The registered server name or pid</source>
          <target state="translated">&lt;code&gt;pubsub_server&lt;/code&gt; -注册的服务器名称或pid</target>
        </trans-unit>
        <trans-unit id="da15f0e5a718ccd0e3cdfc6dc7d068b211ab29a3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pull&lt;/code&gt; - pulls (removes) the given value from the array field</source>
          <target state="translated">&lt;code&gt;pull&lt;/code&gt; -拉（去除）从阵列字段与给定值</target>
        </trans-unit>
        <trans-unit id="a629837f9a57aeca3ef555b09707eb8a125f0e34" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;push&lt;/code&gt; - pushes (appends) the given value to the end of the array field</source>
          <target state="translated">&lt;code&gt;push&lt;/code&gt; -推（追加）给定值到阵列字段的末尾</target>
        </trans-unit>
        <trans-unit id="d4bac5180c1f87eeb0a942ed84909c3e9891e00a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pushEvent(event, payload, (reply, ref) =&amp;gt; ...)&lt;/code&gt; - method to push an event from the client to the LiveView server</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90b4b8171837e2dc29aa5afe04beb00844882268" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pushEventTo(selectorOrTarget, event, payload, (reply, ref) =&amp;gt; ...)&lt;/code&gt; - method to push targeted events from the client to LiveViews and LiveComponents.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09ee3eefa1290ef7ade7849d1d1b89bc1caa9806" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;query_params&lt;/code&gt; - the request query params, populated through &lt;a href=&quot;#fetch_query_params/2&quot;&gt;&lt;code&gt;fetch_query_params/2&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;query_params&lt;/code&gt; -通过&lt;a href=&quot;#fetch_query_params/2&quot;&gt; &lt;code&gt;fetch_query_params/2&lt;/code&gt; &lt;/a&gt;填充的请求查询参数</target>
        </trans-unit>
        <trans-unit id="9519c1e0b9c58949cef4772842762ba75e426893" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;query_string&lt;/code&gt; - the request query string as a binary, example: &lt;code&gt;&quot;foo=bar&quot;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;query_string&lt;/code&gt; -请求查询字符串，为二进制，例如： &lt;code&gt;&quot;foo=bar&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e30e87edb2f79ee96ef8e4bc145a697cb7884a77" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;queryable&lt;/code&gt; - The real query to use for querying association</source>
          <target state="translated">&lt;code&gt;queryable&lt;/code&gt; -用于查询关联的实际查询</target>
        </trans-unit>
        <trans-unit id="ab4d545de4c74d29b7d4594beef12c9708c3ec1b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reconnected&lt;/code&gt; - the element's parent LiveView has reconnected to the server</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="101a37bd418688184ba7c148e37dcab0e247c271" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ref&lt;/code&gt; - The latest ref sent by the client</source>
          <target state="translated">&lt;code&gt;ref&lt;/code&gt; -客户端发送的最新参考</target>
        </trans-unit>
        <trans-unit id="0d768cd7ea6b9ee7c2188696db754b59cc3bbd21" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ref&lt;/code&gt; - The unique string ref</source>
          <target state="translated">&lt;code&gt;ref&lt;/code&gt; -唯一字符串ref</target>
        </trans-unit>
        <trans-unit id="efadf3dccf2973d05a0309e7bc7fbef284eaf334" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;related&lt;/code&gt; - The schema that is associated</source>
          <target state="translated">&lt;code&gt;related&lt;/code&gt; -关联的架构</target>
        </trans-unit>
        <trans-unit id="a44d2751224113b596d5778ef410d8589b2d6dd2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;related_key&lt;/code&gt; - The key on the &lt;code&gt;related&lt;/code&gt; schema used for the association</source>
          <target state="translated">&lt;code&gt;related_key&lt;/code&gt; -用于关联的 &lt;code&gt;related&lt;/code&gt; 架构上的键</target>
        </trans-unit>
        <trans-unit id="21aa5e4e1c5e0396872c7f763922a2a86c66a71c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;relationship&lt;/code&gt; - The relationship to the specified schema, default &lt;code&gt;:child&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;relationship&lt;/code&gt; -与指定架构的关系，默认为 &lt;code&gt;:child&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d24603a5755dc5590959ca98e117b0fdb5753358" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;relationship&lt;/code&gt; - The relationship to the specified schema, default &lt;code&gt;:parent&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;relationship&lt;/code&gt; -与指定架构的关系，默认为 &lt;code&gt;:parent&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d8198e35a26fb1610134ff582a4d568c1a3ee0aa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;relationship&lt;/code&gt; - The relationship to the specified schema, default is &lt;code&gt;:child&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;relationship&lt;/code&gt; -与指定架构的关系，默认为 &lt;code&gt;:child&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="279bbb4744ce1c8638d5e66399287c26b08925bd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remote_ip&lt;/code&gt; - the IP of the client, example: &lt;code&gt;{151, 236, 219, 228}&lt;/code&gt;. This field is meant to be overwritten by plugs that understand e.g. the &lt;code&gt;X-Forwarded-For&lt;/code&gt; header or HAProxy&amp;rsquo;s PROXY protocol. It defaults to peer&amp;rsquo;s IP</source>
          <target state="translated">&lt;code&gt;remote_ip&lt;/code&gt; -客户端的IP，例如： &lt;code&gt;{151, 236, 219, 228}&lt;/code&gt; 。该字段将被了解 &lt;code&gt;X-Forwarded-For&lt;/code&gt; 标头或HAProxy的PROXY协议的插头覆盖。默认为对等方的IP</target>
        </trans-unit>
        <trans-unit id="4de8b9c8e0d2f8c562549e4e7f2c9bc3c5a6ac7d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remote_ip&lt;/code&gt; - the IP of the client, example: &lt;code&gt;{151, 236, 219, 228}&lt;/code&gt;. This field is meant to be overwritten by plugs that understand e.g. the &lt;code&gt;X-Forwarded-For&lt;/code&gt; header or HAProxy&amp;rsquo;s PROXY protocol. It defaults to peer&amp;rsquo;s IP.</source>
          <target state="translated">&lt;code&gt;remote_ip&lt;/code&gt; -客户端的IP，例如： &lt;code&gt;{151, 236, 219, 228}&lt;/code&gt; 。该字段将被了解 &lt;code&gt;X-Forwarded-For&lt;/code&gt; 标头或HAProxy的PROXY协议的插头覆盖。默认为对等方的IP。</target>
        </trans-unit>
        <trans-unit id="d391b4a2bae0547b91d55585b723536c915fce93" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remote_ip&lt;/code&gt; - the IP of the client, example: &lt;code&gt;{151, 236, 219, 228}&lt;/code&gt;. This field is meant to be overwritten by plugs that understand e.g. the &lt;code&gt;X-Forwarded-For&lt;/code&gt; header or HAProxy's PROXY protocol. It defaults to peer's IP</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f3a9a7f5d67913708e29f87d0f54930fb38c904" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;render/3&lt;/code&gt; will also pass the value which the &lt;code&gt;show&lt;/code&gt; action received for &lt;code&gt;messenger&lt;/code&gt; from the params as an assign.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f9fb90b69be1b28020d819ca38f79d243383186" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;render&lt;/code&gt; - compartmentalizes markup</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0e87dd1de9614cad2d1a3977d5ef0ced83abf44" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;replace&lt;/code&gt; - the default operation. Replaces the element with the contents</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ca491a5efb3da72b88c1921230f0a8746f71dc7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;repo&lt;/code&gt; - The repository applying the changeset (only set after a Repo function is called)</source>
          <target state="translated">&lt;code&gt;repo&lt;/code&gt; -应用变更集的存储库（仅在调用Repo函数之后设置）</target>
        </trans-unit>
        <trans-unit id="e4763165fcbf61ace38314ad898960d8ea1af421" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;repo_opts&lt;/code&gt; - A keyword list of options given to the underlying repository operation</source>
          <target state="translated">&lt;code&gt;repo_opts&lt;/code&gt; -赋予基础存储库操作的选项的关键字列表</target>
        </trans-unit>
        <trans-unit id="3d51ec606413cad00064814387679d26c89e472a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;req_cookies&lt;/code&gt; - the request cookies (without the response ones)</source>
          <target state="translated">&lt;code&gt;req_cookies&lt;/code&gt; -请求cookie（无响应）</target>
        </trans-unit>
        <trans-unit id="24588e6a6d03b7a536204372ff6992859cb63f43" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;req_headers&lt;/code&gt; - the request headers as a list, example: &lt;code&gt;[{&quot;content-type&quot;, &quot;text/plain&quot;}]&lt;/code&gt;. Note all headers will be downcased</source>
          <target state="translated">&lt;code&gt;req_headers&lt;/code&gt; -请求标头作为列表，例如： &lt;code&gt;[{&quot;content-type&quot;, &quot;text/plain&quot;}]&lt;/code&gt; 。请注意，所有标头均会小写</target>
        </trans-unit>
        <trans-unit id="e9dcff9717db7374944b01dee18a077c6626c196" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;req_headers&lt;/code&gt; - the request headers as a list, example: &lt;code&gt;[{&quot;content-type&quot;, &quot;text/plain&quot;}]&lt;/code&gt;. Note all headers will be downcased.</source>
          <target state="translated">&lt;code&gt;req_headers&lt;/code&gt; -请求标头作为列表，例如： &lt;code&gt;[{&quot;content-type&quot;, &quot;text/plain&quot;}]&lt;/code&gt; 。请注意所有标头将被小写。</target>
        </trans-unit>
        <trans-unit id="a05778542387a94ac620874443a90c1b1b661817" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;request_path&lt;/code&gt; - the requested path, example: &lt;code&gt;/trailing/and//double//slashes/&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;request_path&lt;/code&gt; -请求的路径，例如： &lt;code&gt;/trailing/and//double//slashes/&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="52dfa603921109f668d5806807de9b5f0ebc41b1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;required&lt;/code&gt; - All required fields as a list of atoms</source>
          <target state="translated">&lt;code&gt;required&lt;/code&gt; -所有必填字段为原子列表</target>
        </trans-unit>
        <trans-unit id="0dd7d96519c5250b3619288d0042ef4be36b771b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;required&lt;/code&gt; - required fields are merged; all the fields that appear in the required list of both changesets are moved to the required list of the resulting changeset.</source>
          <target state="translated">&lt;code&gt;required&lt;/code&gt; -必填字段已合并；出现在两个变更集的必需列表中的所有字段都将移到结果变更集的必需列表中。</target>
        </trans-unit>
        <trans-unit id="4ecc2849315302f2f8781193df1f4160a26ba41b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;resp_body&lt;/code&gt; - the response body, by default is an empty string. It is set to nil after the response is sent, except for test connections.</source>
          <target state="translated">&lt;code&gt;resp_body&lt;/code&gt; -响应正文，默认情况下为空字符串。发送响应后，将其设置为nil（测试连接除外）。</target>
        </trans-unit>
        <trans-unit id="63874ea7f11075ada6462ede5978c14d61267a16" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;resp_body&lt;/code&gt; - the response body, by default is an empty string. It is set to nil after the response is sent, except for test connections. The response charset used defaults to &quot;utf-8&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="378c18fb5b006d3619383e311eee70821aa6bc49" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;resp_charset&lt;/code&gt; - the response charset, defaults to &amp;ldquo;utf-8&amp;rdquo;</source>
          <target state="translated">&lt;code&gt;resp_charset&lt;/code&gt; -响应字符集，默认为&amp;ldquo; utf-8&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="33c05281c7d9417a2d6c473d0d303bb3b857bab9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;resp_cookies&lt;/code&gt; - the response cookies with their name and options</source>
          <target state="translated">&lt;code&gt;resp_cookies&lt;/code&gt; -响应cookie及其名称和选项</target>
        </trans-unit>
        <trans-unit id="bdbe3bcda2074df88c297579fe6592ff06d9a359" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;resp_headers&lt;/code&gt; - the response headers as a list of tuples, by default &lt;code&gt;cache-control&lt;/code&gt; is set to &lt;code&gt;&quot;max-age=0, private, must-revalidate&quot;&lt;/code&gt;. Note, response headers are expected to have lower-case keys.</source>
          <target state="translated">&lt;code&gt;resp_headers&lt;/code&gt; -作为元组列表的响应头，默认情况下将 &lt;code&gt;cache-control&lt;/code&gt; 设置为 &lt;code&gt;&quot;max-age=0, private, must-revalidate&quot;&lt;/code&gt; 。请注意，响应头应具有小写字母的键。</target>
        </trans-unit>
        <trans-unit id="66d3cbf3d421d453d7089fda11411d601070c4ce" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;resp_headers&lt;/code&gt; - the response headers as a list of tuples, by default &lt;code&gt;cache-control&lt;/code&gt; is set to &lt;code&gt;&quot;max-age=0, private, must-revalidate&quot;&lt;/code&gt;. Note, response headers are expected to have lowercase keys.</source>
          <target state="translated">&lt;code&gt;resp_headers&lt;/code&gt; -作为元组列表的响应头，默认情况下将 &lt;code&gt;cache-control&lt;/code&gt; 设置为 &lt;code&gt;&quot;max-age=0, private, must-revalidate&quot;&lt;/code&gt; 。请注意，响应头应该具有小写字母。</target>
        </trans-unit>
        <trans-unit id="22c688d476534e17678a3cbf023f13d36df40ede" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;result_of_before_callback&lt;/code&gt; is the return value of the &amp;ldquo;before&amp;rdquo; clause of the same &lt;code&gt;event_callback&lt;/code&gt;. This is a means of passing data from the &amp;ldquo;before&amp;rdquo; clause to the &amp;ldquo;after&amp;rdquo; clause when instrumenting.</source>
          <target state="translated">&lt;code&gt;result_of_before_callback&lt;/code&gt; 是同一 &lt;code&gt;event_callback&lt;/code&gt; 的&amp;ldquo; before&amp;rdquo;子句的返回值。这是在进行检测时将数据从&amp;ldquo; before&amp;rdquo;子句传递到&amp;ldquo; after&amp;rdquo;子句的一种方法。</target>
        </trans-unit>
        <trans-unit id="889001db9546bb8ae5d1b4c1e9819dcaefa903d7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reuse_sessions: true&lt;/code&gt; - for improved handshake performance of recurring connections</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="103b1466ccea7577fc2a4b9b0c2aa6b7c282417e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;runtime_metadata&lt;/code&gt; is a map of runtime data that the instrumentation passes to the callbacks. This can be used for any purposes: for example, when instrumenting the rendering of a view, the name of the view could be passed in these runtime data so that instrumenters know which view is being rendered (&lt;code&gt;instrument(:view_render, %{view: &quot;index.html&quot;}, fn
...)&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;runtime_metadata&lt;/code&gt; 是工具传递给回调的运行时数据的映射。这可以用于任何目的：例如，在检测视图的呈现时，可以在这些运行时数据中传递视图的名称，以便检测器知道正在呈现哪个视图（ &lt;code&gt;instrument(:view_render, %{view: &quot;index.html&quot;}, fn ...)&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="246a6e125a6cf67c0c1df577f1bce26aa4280292" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;runtime_metadata&lt;/code&gt; may be omitted and defaults to &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;runtime_metadata&lt;/code&gt; 可以省略，默认为 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="36b7f3342f55b56b6b713d16862546295104a9d4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;scheme&lt;/code&gt; - the request scheme as an atom, example: &lt;code&gt;:http&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;scheme&lt;/code&gt; -作为原子的请求方案，例如 &lt;code&gt;:http&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="980eef85fef584aef6bf3226e97f3b0808c7379f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;script_name&lt;/code&gt; - the initial portion of the URL&amp;rsquo;s path that corresponds to the application routing, as segments, example: &lt;code&gt;[&quot;sub&quot;,&quot;app&quot;]&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;script_name&lt;/code&gt; -URL路径的初始部分，与应用程序路由相对应，以段为单位，例如： &lt;code&gt;[&quot;sub&quot;,&quot;app&quot;]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cab0fd37e630576ecdaeed217e5a0c392005a958" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;script_name&lt;/code&gt; - the initial portion of the URL&amp;rsquo;s path that corresponds to the application routing, as segments, example: [&amp;ldquo;sub&amp;rdquo;,&amp;rdquo;app&amp;rdquo;].</source>
          <target state="translated">&lt;code&gt;script_name&lt;/code&gt; -URL路径的初始部分，与应用程序路由相对应，以段为例，例如：[&amp;ldquo; sub&amp;rdquo;，&amp;ldquo; app&amp;rdquo;]。</target>
        </trans-unit>
        <trans-unit id="7afeaf635368e4ff1b981a38f4e9d5045170e061" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;script_name&lt;/code&gt; - the initial portion of the URL's path that corresponds to the application routing, as segments, example: &lt;code&gt;[&quot;sub&quot;,&quot;app&quot;]&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd76c23ddceb864d0c5a514fe4c77eddb9a07c4f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;secret_key_base&lt;/code&gt; - a secret key used to verify and encrypt cookies. the field must be set manually whenever one of those features are used. This data must be kept in the connection and never used directly, always use &lt;a href=&quot;https://hexdocs.pm/plug_crypto/1.0.0/Plug.Crypto.KeyGenerator.html#generate/3&quot;&gt;&lt;code&gt;Plug.Crypto.KeyGenerator.generate/3&lt;/code&gt;&lt;/a&gt; to derive keys from it</source>
          <target state="translated">&lt;code&gt;secret_key_base&lt;/code&gt; -用于验证和加密cookie的秘密密钥。无论何时使用这些功能之一，都必须手动设置该字段。此数据必须保留在连接中，切勿直接使用，请始终使用&lt;a href=&quot;https://hexdocs.pm/plug_crypto/1.0.0/Plug.Crypto.KeyGenerator.html#generate/3&quot;&gt; &lt;code&gt;Plug.Crypto.KeyGenerator.generate/3&lt;/code&gt; &lt;/a&gt;从中获取密钥</target>
        </trans-unit>
        <trans-unit id="4bcf6de75da5881e20edb522c80c5be8e712788e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;secret_key_base&lt;/code&gt; - a secret key used to verify and encrypt cookies. the field must be set manually whenever one of those features are used. This data must be kept in the connection and never used directly, always use &lt;a href=&quot;https://hexdocs.pm/plug_crypto/Plug.Crypto.KeyGenerator.html#generate/3&quot;&gt;&lt;code&gt;Plug.Crypto.KeyGenerator.generate/3&lt;/code&gt;&lt;/a&gt; to derive keys from it</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1253f664065a2d62b14b6ef67f605e6b39aaddd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;secret_key_base&lt;/code&gt; - a secret key used to verify and encrypt cookies. the field must be set manually whenever one of those features are used. This data must be kept in the connection and never used directly, always use &lt;a href=&quot;plug.crypto.keygenerator#generate/3&quot;&gt;&lt;code&gt;Plug.Crypto.KeyGenerator.generate/3&lt;/code&gt;&lt;/a&gt; to derive keys from it</source>
          <target state="translated">&lt;code&gt;secret_key_base&lt;/code&gt; -用于验证和加密cookie的秘密密钥。无论何时使用这些功能之一，都必须手动设置该字段。此数据必须保留在连接中，切勿直接使用，请始终使用&lt;a href=&quot;plug.crypto.keygenerator#generate/3&quot;&gt; &lt;code&gt;Plug.Crypto.KeyGenerator.generate/3&lt;/code&gt; &lt;/a&gt;从中获取密钥</target>
        </trans-unit>
        <trans-unit id="15c7700e939b6aee43091eff79c04cb08f48d4e5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;secure_renegotiate: true&lt;/code&gt; - to avoid certain types of man-in-the-middle attacks</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f29f5db6bf5d13386e17da68d405842a111c081d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;select&lt;/code&gt; also accepts a list of atoms where each atom refers to a field in the source to be selected.</source>
          <target state="translated">&lt;code&gt;select&lt;/code&gt; 还接受一个原子列表，其中每个原子都指向要选择的源中的一个字段。</target>
        </trans-unit>
        <trans-unit id="6eb899148e2dbea005f987b933cbbd3fc701448e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;select_merge&lt;/code&gt; cannot be used to set fields in associations, as associations are always loaded later, overriding any previous value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1288249154ccf26ed1bd0af1917adbe00c8851c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;selector&lt;/code&gt; - The query selector</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="296aa6876fe50d49e496600ad420f7a74bc5f953" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;serializer&lt;/code&gt; - The serializer for socket messages, for example: &lt;code&gt;Phoenix.Transports.WebSocketSerializer&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;serializer&lt;/code&gt; -套接字消息的序列化器，例如： &lt;code&gt;Phoenix.Transports.WebSocketSerializer&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f182d3c71f466a802a29f20fd63a50cc07f0725a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;server&lt;/code&gt; - The Pid or registered server name and optional node to scope the broadcast, for example: &lt;code&gt;MyApp.PubSub&lt;/code&gt;, &lt;code&gt;{MyApp.PubSub, :a@node}&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;server&lt;/code&gt; -Pid或注册的服务器名称和可选节点，以限制广播的范围，例如： &lt;code&gt;MyApp.PubSub&lt;/code&gt; ， &lt;code&gt;{MyApp.PubSub, :a@node}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c6ba97119409938a372ed07abe79b4f2a78dc862" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;server&lt;/code&gt; - The Pid registered name of the server</source>
          <target state="translated">&lt;code&gt;server&lt;/code&gt; - 服务器的Pid注册名称</target>
        </trans-unit>
        <trans-unit id="8ba0c0aa20ef9eae031396a7362b2436588887b4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;server_name&lt;/code&gt; - The name to register the server under</source>
          <target state="translated">&lt;code&gt;server_name&lt;/code&gt; -在其下注册服务器的名称</target>
        </trans-unit>
        <trans-unit id="3c518eea11ddca7b2d680df360f5d8403cda7a85" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;server_name&lt;/code&gt; - The registered name of the tracker server</source>
          <target state="translated">&lt;code&gt;server_name&lt;/code&gt; -跟踪服务器的注册名称</target>
        </trans-unit>
        <trans-unit id="468a0024f46153b84f2646395de16c5687b51120" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;server_opts&lt;/code&gt; - The list of options to pass to the tracker server</source>
          <target state="translated">&lt;code&gt;server_opts&lt;/code&gt; -传递给跟踪服务器的选项列表</target>
        </trans-unit>
        <trans-unit id="9f99c928fdd62c94778f35581da024c947615843" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;session&lt;/code&gt; - the connection session</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c2caff887e3641f298e723dd4b4026ae8a72bbb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;set&lt;/code&gt; - sets the given field in the table to the given value</source>
          <target state="translated">&lt;code&gt;set&lt;/code&gt; -设置指定字段在表中给定值</target>
        </trans-unit>
        <trans-unit id="969589494be74cc19063eaeaf82923ad34fa3b86" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;shard&lt;/code&gt; - The shard, for example &lt;code&gt;1&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;shard&lt;/code&gt; -碎片，例如 &lt;code&gt;1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8c60ab2092a1e2475588b6f411dda59ca6bb30a7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;socket&lt;/code&gt; - the LiveView socket</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9161cde7817a029486e4390329e091bf1151d940" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;start_args&lt;/code&gt; are the arguments passed to the application in the &lt;code&gt;:mod&lt;/code&gt; specification key (e.g., &lt;code&gt;mod: {MyApp, [:my_args]}&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;start_args&lt;/code&gt; 是在 &lt;code&gt;:mod&lt;/code&gt; 规范密钥（例如， &lt;code&gt;mod: {MyApp, [:my_args]}&lt;/code&gt; ）中传递给应用程序的参数。</target>
        </trans-unit>
        <trans-unit id="1befc5d39644d1bc3134d4c35ea706fb5258286c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;start_args&lt;/code&gt; are the arguments passed to the application in the &lt;code&gt;:mod&lt;/code&gt; specification key (for example, &lt;code&gt;mod: {MyApp, [:my_args]}&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e7dcff739bcad8d1857be2bedb467d433c4d61c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;start_type&lt;/code&gt; defines how the application is started:</source>
          <target state="translated">&lt;code&gt;start_type&lt;/code&gt; 定义如何启动应用程序：</target>
        </trans-unit>
        <trans-unit id="35fa3a8f992225f09ede7699a77894f22bf1e585" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;state&lt;/code&gt; - the connection state</source>
          <target state="translated">&lt;code&gt;state&lt;/code&gt; -连接状态</target>
        </trans-unit>
        <trans-unit id="93d5d93af48ac493f86cb5c0f186995d526d56ee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;status&lt;/code&gt; - The reply status as an atom</source>
          <target state="translated">&lt;code&gt;status&lt;/code&gt; -如一个原子的应答状态</target>
        </trans-unit>
        <trans-unit id="a653ee9b901321d4e0e464e5acafb89c9db427ee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;status&lt;/code&gt; - the response status</source>
          <target state="translated">&lt;code&gt;status&lt;/code&gt; -响应状态</target>
        </trans-unit>
        <trans-unit id="9a9c2fbae62d06a0662539678563891fb5ef99c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string()&lt;/code&gt; (as a UUID)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="705f2e4e2e1ae4604f80f8a3ab30c307d1eed659" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;subquery&lt;/code&gt; is supported in &lt;code&gt;from&lt;/code&gt;, &lt;code&gt;join&lt;/code&gt;, and &lt;code&gt;where&lt;/code&gt;, in the form &lt;code&gt;p.x in subquery(q)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb525b4942d6766e450faa45994038bf3ca03dbd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;subscribe&lt;/code&gt; - subscribes the given pid to the given topic sends: &lt;code&gt;{:subscribe, pid, topic, opts}&lt;/code&gt; respond with: &lt;code&gt;:ok | {:error, reason} | {:perform, {m, f, a}}&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;subscribe&lt;/code&gt; 将给定的pid订阅给定的主题发送： &lt;code&gt;{:subscribe, pid, topic, opts}&lt;/code&gt; 响应 &lt;code&gt;:ok | {:error, reason} | {:perform, {m, f, a}}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="025234015f846a4668be839441d90c3e0c97f6f8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;subtype&lt;/code&gt;, the content-type subtype (e.g., &lt;code&gt;&quot;json&quot;&lt;/code&gt; for the &lt;code&gt;&quot;x-sample/json&quot;&lt;/code&gt; content-type)</source>
          <target state="translated">&lt;code&gt;subtype&lt;/code&gt; ，内容类型亚型（例如， &lt;code&gt;&quot;json&quot;&lt;/code&gt; 为 &lt;code&gt;&quot;x-sample/json&quot;&lt;/code&gt; 内容类型）</target>
        </trans-unit>
        <trans-unit id="b1edaa577016afa1a9b706807612a7bc094252dc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;table_name&lt;/code&gt; - The name of the local table</source>
          <target state="translated">&lt;code&gt;table_name&lt;/code&gt; -本地表的名称</target>
        </trans-unit>
        <trans-unit id="4be0315f043e8f1fa9b565bd0abe60e158adf0ff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;te&amp;middot;lem&amp;middot;e&amp;middot;try&lt;/code&gt; - the process of recording and transmitting the readings of an instrument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e29cca9cee2573fbb090c7741c42c557985c4cb7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;template&lt;/code&gt; - which may be an atom or a string. If an atom, like &lt;code&gt;:index&lt;/code&gt;, it will render a template with the same format as the one returned by &lt;a href=&quot;#get_format/1&quot;&gt;&lt;code&gt;get_format/1&lt;/code&gt;&lt;/a&gt;. For example, for an HTML request, it will render the &quot;index.html&quot; template. If the template is a string, it must contain the extension too, like &quot;index.json&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24f5c9dcbba2baa8247f22c33896313396653b23" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;template&lt;/code&gt; - which may be an atom or a string. If an atom, like &lt;code&gt;:index&lt;/code&gt;, it will render a template with the same format as the one returned by &lt;a href=&quot;#get_format/1&quot;&gt;&lt;code&gt;get_format/1&lt;/code&gt;&lt;/a&gt;. For example, for an HTML request, it will render the &amp;ldquo;index.html&amp;rdquo; template. If the template is a string, it must contain the extension too, like &amp;ldquo;index.json&amp;rdquo;</source>
          <target state="translated">&lt;code&gt;template&lt;/code&gt; -可以是原子或字符串。如果像 &lt;code&gt;:index&lt;/code&gt; 这样的原子，它将以与&lt;a href=&quot;#get_format/1&quot;&gt; &lt;code&gt;get_format/1&lt;/code&gt; &lt;/a&gt;返回的格式相同的格式呈现模板。例如，对于HTML请求，它将呈现&amp;ldquo; index.html&amp;rdquo;模板。如果模板是字符串，则它也必须包含扩展名，例如&amp;ldquo; index.json&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="40617c48abbb67b22a917287876283c98cda5471" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;terminate/2&lt;/code&gt;, however, won&amp;rsquo;t be invoked in case of errors nor in case of exits. This is the same behaviour as you find in Elixir abstractions like &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; and others. Typically speaking, if you want to clean something up, it is better to monitor your channel process and do the clean up from another process. Similar to GenServer, it would also be possible &lt;code&gt;:trap_exit&lt;/code&gt; to guarantee that &lt;code&gt;terminate/2&lt;/code&gt; is invoked. This practice is not encouraged though.</source>
          <target state="translated">&lt;code&gt;terminate/2&lt;/code&gt; 但是，如果发生错误或退出，则不会调用终止/ 2。这与在&lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;等Elixir抽象中发现的行为相同。通常来说，如果您要清理某些内容，最好监视您的通道进程并从另一个进程中进行清理。与GenServer相似， &lt;code&gt;:trap_exit&lt;/code&gt; 也可以保证调用Terminate &lt;code&gt;terminate/2&lt;/code&gt; 。但是不鼓励这种做法。</target>
        </trans-unit>
        <trans-unit id="36a680d7091b1ca241f6dce63dff5aa660ef11d7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;terminate/2&lt;/code&gt;, however, won't be invoked in case of errors nor in case of exits. This is the same behaviour as you find in Elixir abstractions like &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; and others. Typically speaking, if you want to clean something up, it is better to monitor your channel process and do the clean up from another process. Similar to GenServer, it would also be possible &lt;code&gt;:trap_exit&lt;/code&gt; to guarantee that &lt;code&gt;terminate/2&lt;/code&gt; is invoked. This practice is not encouraged though.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bad0009e8b2606979a22152f77f7f53217f2b95" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;test&lt;/code&gt; - a directory with all of our application tests. It often mirrors the same structure found in &lt;code&gt;lib&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67950da0b6afe6e6fe65e5fd50ec29a1f1b09807" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;text_filter&lt;/code&gt; - The text to further filter the element</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e855ced77c34f3098976240974358faddd93281" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;through&lt;/code&gt; - The through associations</source>
          <target state="translated">&lt;code&gt;through&lt;/code&gt; -通过关联</target>
        </trans-unit>
        <trans-unit id="03b0edaaf74d039e9dba4da8b7f2b59a45942944" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;time_diff&lt;/code&gt; is an integer representing the time it took to execute the instrumented function &lt;strong&gt;in native units&lt;/strong&gt;.</source>
          <target state="translated">&lt;code&gt;time_diff&lt;/code&gt; 是一个整数，表示&lt;strong&gt;以本机单位&lt;/strong&gt;执行检测功能所花费的时间。</target>
        </trans-unit>
        <trans-unit id="1ee719ca0cf2a2f8c0cf5080f44ff4dbd99aeb9e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;topic&lt;/code&gt; - The &lt;a href=&quot;phoenix.pubsub&quot;&gt;&lt;code&gt;Phoenix.PubSub&lt;/code&gt;&lt;/a&gt; topic</source>
          <target state="translated">&lt;code&gt;topic&lt;/code&gt; -该&lt;a href=&quot;phoenix.pubsub&quot;&gt; &lt;code&gt;Phoenix.PubSub&lt;/code&gt; &lt;/a&gt;话题</target>
        </trans-unit>
        <trans-unit id="513bfa6e57effcfca4a3772c43a797cf30762ccc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;topic&lt;/code&gt; - The &lt;a href=&quot;phoenix.pubsub&quot;&gt;&lt;code&gt;Phoenix.PubSub&lt;/code&gt;&lt;/a&gt; topic for this presence</source>
          <target state="translated">&lt;code&gt;topic&lt;/code&gt; - 此状态的&lt;a href=&quot;phoenix.pubsub&quot;&gt; &lt;code&gt;Phoenix.PubSub&lt;/code&gt; &lt;/a&gt;主题</target>
        </trans-unit>
        <trans-unit id="b4e43962e773022e68cf2010c40617e7736b0193" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;topic&lt;/code&gt; - The &lt;a href=&quot;phoenix.pubsub&quot;&gt;&lt;code&gt;Phoenix.PubSub&lt;/code&gt;&lt;/a&gt; topic to untrack for this presence</source>
          <target state="translated">&lt;code&gt;topic&lt;/code&gt; -该&lt;a href=&quot;phoenix.pubsub&quot;&gt; &lt;code&gt;Phoenix.PubSub&lt;/code&gt; &lt;/a&gt;话题untrack此存在</target>
        </trans-unit>
        <trans-unit id="f650123c92c7ad8edc76f65a3e935e24ebc774ef" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;topic&lt;/code&gt; - The &lt;a href=&quot;phoenix.pubsub&quot;&gt;&lt;code&gt;Phoenix.PubSub&lt;/code&gt;&lt;/a&gt; topic to update for this presence</source>
          <target state="translated">&lt;code&gt;topic&lt;/code&gt; -该&lt;a href=&quot;phoenix.pubsub&quot;&gt; &lt;code&gt;Phoenix.PubSub&lt;/code&gt; &lt;/a&gt;主题，以更新此存在</target>
        </trans-unit>
        <trans-unit id="b56ea91d6b7462453b3977d65c982fb652cd6ceb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;topic&lt;/code&gt; - The string topic or topic:subtopic pair namespace, for example &amp;ldquo;messages&amp;rdquo;, &amp;ldquo;messages:123&amp;rdquo;</source>
          <target state="translated">&lt;code&gt;topic&lt;/code&gt; -字符串topic或topic：subtopic对命名空间，例如&amp;ldquo; messages&amp;rdquo;，&amp;ldquo; messages：123&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="62ca51cf60a4e7f5b9da63e0397a88e8ad88609c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;topic&lt;/code&gt; - The string topic, for example &amp;ldquo;users:123&amp;rdquo;</source>
          <target state="translated">&lt;code&gt;topic&lt;/code&gt; -字符串主题，例如&amp;ldquo; users：123&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="e2064db7041ede42a88b29d1726530a1b5b8d6ff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;topic&lt;/code&gt; - The string topic, for example &lt;code&gt;&quot;room:123&quot;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;topic&lt;/code&gt; -字符串主题，例如 &lt;code&gt;&quot;room:123&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="edf299c5dbeef14f8b8c536496bbd0431d856fc4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;topic&lt;/code&gt; - The topic to broadcast to, ie: &lt;code&gt;&quot;users:123&quot;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;topic&lt;/code&gt; -要广播的主题，即： &lt;code&gt;&quot;users:123&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="894ba3ea473520823628d4e2116154bf7205e0f3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;topic&lt;/code&gt; - The topic to subscribe to, for example: &lt;code&gt;&quot;users:123&quot;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;topic&lt;/code&gt; -要订阅的主题，例如： &lt;code&gt;&quot;users:123&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f027e260bd6880e4c8d9c4ea1a35a185186f4f8e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;topic_pattern&lt;/code&gt; - The string pattern, for example &amp;ldquo;room:&lt;em&gt;&amp;ldquo;, &amp;ldquo;users:&lt;/em&gt;&amp;rdquo;, &amp;ldquo;system&amp;rdquo;</source>
          <target state="translated">&lt;code&gt;topic_pattern&lt;/code&gt; -字符串模式，例如&amp;ldquo; room：&lt;em&gt;&amp;rdquo;，&amp;ldquo; users：&lt;/em&gt; &amp;rdquo;，&amp;ldquo; system&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="2b0455a9d341c92f8f02bcd81fcde1839f019225" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;topic_pattern&lt;/code&gt; - The string pattern, for example &lt;code&gt;&quot;room:*&quot;&lt;/code&gt;, &lt;code&gt;&quot;users:*&quot;&lt;/code&gt;, or &lt;code&gt;&quot;system&quot;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bf1f400268378a94a0377161a93e52059884fd6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tracker&lt;/code&gt; - The name of the tracker handler module implementing the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Phoenix.Tracker&lt;/code&gt;&lt;/a&gt; behaviour</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51127dc0e8ed50c2e4ac714b42eb9545ead7bc45" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tracker&lt;/code&gt; - The name of the tracker handler module implementing the &lt;a href=&quot;phoenix.tracker#content&quot;&gt;&lt;code&gt;Phoenix.Tracker&lt;/code&gt;&lt;/a&gt; behaviour</source>
          <target state="translated">&lt;code&gt;tracker&lt;/code&gt; -实施跟踪处理模块的名称&lt;a href=&quot;phoenix.tracker#content&quot;&gt; &lt;code&gt;Phoenix.Tracker&lt;/code&gt; &lt;/a&gt;行为</target>
        </trans-unit>
        <trans-unit id="77cebe9e072f836bf905c4ed2b9563d461835f10" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tracker_opts&lt;/code&gt; - The list of options to pass to the tracker handler</source>
          <target state="translated">&lt;code&gt;tracker_opts&lt;/code&gt; -传递给跟踪器处理程序的选项列表</target>
        </trans-unit>
        <trans-unit id="fe9158957cb6b89c0989ca69bb67857bd1251d8f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;transport&lt;/code&gt; - The socket&amp;rsquo;s transport, for example: &lt;a href=&quot;phoenix.transports.websocket&quot;&gt;&lt;code&gt;Phoenix.Transports.WebSocket&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;transport&lt;/code&gt; -套接字的传输，例如：&lt;a href=&quot;phoenix.transports.websocket&quot;&gt; &lt;code&gt;Phoenix.Transports.WebSocket&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="52c7d5d6612d5c389b1ae03d18193b2b2c4a4a63" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;transport_name&lt;/code&gt; - The socket&amp;rsquo;s transport, for example: &lt;code&gt;:websocket&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;transport_name&lt;/code&gt; -套接字的传输方式，例如 &lt;code&gt;:websocket&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d4e0128be65ba382ba951e0aeb79f0f7de5fa4b3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;transport_pid&lt;/code&gt; - The pid of the socket&amp;rsquo;s transport process</source>
          <target state="translated">&lt;code&gt;transport_pid&lt;/code&gt; -套接字传输过程的pid</target>
        </trans-unit>
        <trans-unit id="a4f127cc373d7b32f78f8038b43cccc790509f01" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;type&lt;/code&gt;, the content-type type (e.g., &lt;code&gt;&quot;x-sample&quot;&lt;/code&gt; for the &lt;code&gt;&quot;x-sample/json&quot;&lt;/code&gt; content-type)</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; ，内容类型类型（例如， &lt;code&gt;&quot;x-sample&quot;&lt;/code&gt; 为 &lt;code&gt;&quot;x-sample/json&quot;&lt;/code&gt; 内容类型）</target>
        </trans-unit>
        <trans-unit id="062d04ecaa276f6909e2313139f4ce94130c6e0b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;types&lt;/code&gt; - Cache of the data&amp;rsquo;s field types</source>
          <target state="translated">&lt;code&gt;types&lt;/code&gt; -数据的字段类型的缓存</target>
        </trans-unit>
        <trans-unit id="c8b50124a73354ee02cfe1c5ba6e0f181090027f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;types&lt;/code&gt; - Cache of the data's field types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="713f014d797ed832327c6a83bf5c270ceefef5a9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;unsubscribe&lt;/code&gt; - unsubscribes the given pid from the given topic sends: &lt;code&gt;{:unsubscribe, pid, topic}&lt;/code&gt; respond with: &lt;code&gt;:ok | {:error, reason} | {:perform, {m, f, a}}&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;unsubscribe&lt;/code&gt; -退订给定主题的给定pid发送： &lt;code&gt;{:unsubscribe, pid, topic}&lt;/code&gt; 响应 &lt;code&gt;:ok | {:error, reason} | {:perform, {m, f, a}}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bbc231aa855ba6f7ffb1640e13a6665c3a71931f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;update_value&lt;/code&gt; is the new value to be stored under &lt;code&gt;key&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;update_value&lt;/code&gt; 是要存储在 &lt;code&gt;key&lt;/code&gt; 下的新值</target>
        </trans-unit>
        <trans-unit id="d5c8c2d6ab1b22d38f2b49bfcf2e2126f69250a4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;updated&lt;/code&gt; - the element has been updated in the DOM by the server</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f521f271795fce8731ff9d935e42ca1131f1873" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;use Application&lt;/code&gt; provides no default implementation for the &lt;a href=&quot;#start/2&quot;&gt;&lt;code&gt;start/2&lt;/code&gt;&lt;/a&gt; callback.</source>
          <target state="translated">&lt;code&gt;use Application&lt;/code&gt; 没有为&lt;a href=&quot;#start/2&quot;&gt; &lt;code&gt;start/2&lt;/code&gt; &lt;/a&gt;回调提供默认实现。</target>
        </trans-unit>
        <trans-unit id="f029332e3f810fd92d38f3083e897e8184ebdd7d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;utc_datetime&lt;/code&gt; - has a precision of seconds and casts values to Elixir's &lt;a href=&quot;https://hexdocs.pm/elixir/DateTime.html&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; struct and expects the time zone to be set to UTC.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9f39c1df4afb4b9ab024f8cb6f1c062713a2335" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;utc_datetime&lt;/code&gt; - has a precision of seconds and casts values to to Elixir&amp;rsquo;s &lt;a href=&quot;https://hexdocs.pm/elixir/DateTime.html&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; struct and expects the time zone to be set to UTC.</source>
          <target state="translated">&lt;code&gt;utc_datetime&lt;/code&gt; -具有秒的精度，并将值强制转换为Elixir的&lt;a href=&quot;https://hexdocs.pm/elixir/DateTime.html&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;结构，并期望将时区设置为UTC。</target>
        </trans-unit>
        <trans-unit id="e9e1e45943bf4766719c1bda7724db4c7eb55ac0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;utc_datetime_usec&lt;/code&gt; has a default precision of microseconds and also casts values to &lt;a href=&quot;https://hexdocs.pm/elixir/DateTime.html&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; expecting the time zone be set to UTC.</source>
          <target state="translated">&lt;code&gt;utc_datetime_usec&lt;/code&gt; 的默认精度为微秒，并且还会将值强制转换为&lt;a href=&quot;https://hexdocs.pm/elixir/DateTime.html&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; 并&lt;/a&gt;期望将时区设置为UTC。</target>
        </trans-unit>
        <trans-unit id="6428f4d916f7c3da2df5ccc59cbddf4233c65f59" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;valid?&lt;/code&gt; - Stores if the changeset is valid</source>
          <target state="translated">&lt;code&gt;valid?&lt;/code&gt; -存储更改集是否有效</target>
        </trans-unit>
        <trans-unit id="5a9362538e127041a217667b8c0f8856c71d7d0f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;viewName&lt;/code&gt; - attribute matching the DOM node's phx-view value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="800dbbe2d2fe1d80d14941fd47d688d0a838a2e5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;vsn&lt;/code&gt; - The protocol version of the client, for example: &amp;ldquo;2.0.0&amp;rdquo;</source>
          <target state="translated">&lt;code&gt;vsn&lt;/code&gt; -客户端的协议版本，例如：&amp;ldquo; 2.0.0&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="bec0997386133df0de916bdcffadd8ddf31241c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;where&lt;/code&gt; also accepts a keyword list where the field given as key is going to be compared with the given value. The fields will always refer to the source given in &lt;code&gt;from&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;where&lt;/code&gt; 也接受关键字列表，其中将作为键给出的字段与给定值进行比较。这些字段将始终引用 &lt;code&gt;from&lt;/code&gt; 中给出的来源。</target>
        </trans-unit>
        <trans-unit id="e963437caf7417e9123875fd4e9fceb427d7fad7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;where&lt;/code&gt; expressions are used to filter the result set. If there is more than one where expression, they are combined with an &lt;code&gt;and&lt;/code&gt; operator. All where expressions have to evaluate to a boolean value.</source>
          <target state="translated">&lt;code&gt;where&lt;/code&gt; 表达式来过滤结果集。如果where表达式不止一个，则将它们与 &lt;code&gt;and&lt;/code&gt; 运算符组合在一起。所有表达式必须计算为布尔值。</target>
        </trans-unit>
        <trans-unit id="c5bdcde824f497b1ae0d2fe1777d38d65f7add27" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;where&lt;/code&gt;, &lt;code&gt;having&lt;/code&gt; and a &lt;code&gt;join&lt;/code&gt;&amp;rsquo;s `on&amp;rsquo;</source>
          <target state="translated">&lt;code&gt;where&lt;/code&gt; ， &lt;code&gt;having&lt;/code&gt; 和 &lt;code&gt;join&lt;/code&gt; 的'上&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="713294ed2c5afa2c740c2785661ab1cfeb397890" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;where&lt;/code&gt;, &lt;code&gt;having&lt;/code&gt; and a &lt;code&gt;join&lt;/code&gt;'s `on'</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c607056e1afb24aa096d965e0f605e009e055a4d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x-content-type-options&lt;/code&gt; - set to nosniff. This requires script and style tags to be sent with proper content type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a091a58cd8a1c6400461dafc74edd2c7171ea32" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x-download-options&lt;/code&gt; - set to noopen to instruct the browser not to open a download directly in the browser, to avoid HTML files rendering inline and accessing the security context of the application (like critical domain cookies)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d50fef96676e9c72ddc82a4a9d7987f6ee849c5a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x-frame-options&lt;/code&gt; - set to SAMEORIGIN to avoid clickjacking through iframes unless in the same origin</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0031b6ee0f819de850592207a859181426da60b0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x-permitted-cross-domain-policies&lt;/code&gt; - set to none to restrict Adobe Flash Player&amp;rsquo;s access to data</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7892c834608e4e5db30616a441a1a0aa13e72d8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x-xss-protection&lt;/code&gt; - set to &quot;1; mode=block&quot; to improve XSS protection on both Chrome and IE</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6011c602d9c8c976b96c14f349f4591db71f2bf6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:error, :too_large, conn}&lt;/code&gt; if the request goes over the given limit</source>
          <target state="translated">&lt;code&gt;{:error, :too_large, conn}&lt;/code&gt; 如果请求超出给定限制</target>
        </trans-unit>
        <trans-unit id="ff1cb34c75e3cf8ae6970e904169f2b701f48c51" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:error, reason, reply}&lt;/code&gt; - An error occurred and the reply must be sent as result</source>
          <target state="translated">&lt;code&gt;{:error, reason, reply}&lt;/code&gt; -发生错误，必须将回复作为结果发送</target>
        </trans-unit>
        <trans-unit id="c382ab89c3746807c841484e4b211c5a497ce846" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:failover, node}&lt;/code&gt; - used if the application is distributed and is started on the current node because of a failover on node &lt;code&gt;node&lt;/code&gt;, and the application specification key &lt;code&gt;:start_phases&lt;/code&gt; is not &lt;code&gt;:undefined&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;{:failover, node}&lt;/code&gt; -如果由于节点 &lt;code&gt;node&lt;/code&gt; 上的故障转移而将应用程序分发并在当前节点上启动，并且应用程序规范键 &lt;code&gt;:start_phases&lt;/code&gt; 不是 &lt;code&gt;:undefined&lt;/code&gt; 时使用。</target>
        </trans-unit>
        <trans-unit id="7c84184adc130a442aeee883a22d84dae1d9d3a1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:fragment, expr}&lt;/code&gt; - which specifies a fragment string as the filter (see &lt;a href=&quot;ecto.query.api#fragment/1&quot;&gt;&lt;code&gt;Ecto.Query.API.fragment/1&lt;/code&gt;&lt;/a&gt;) with the field's value given to it as the only argument</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb3a98608ab0606cfccacc4b8d59a3aa25d84052" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:in, list}&lt;/code&gt; - which specifies the field must be one of the values in a list</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="062660b1e65ffc26be85526ef4749cafef267adf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:joined, channel_pid, reply}&lt;/code&gt; - The channel was joined and the reply must be sent as result</source>
          <target state="translated">&lt;code&gt;{:joined, channel_pid, reply}&lt;/code&gt; -频道已加入，并且回复必须作为结果发送</target>
        </trans-unit>
        <trans-unit id="905c7b552a0a3f84ecae4b26e5f03fcfdb35c892" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:next, conn}&lt;/code&gt; if the next parser should be invoked</source>
          <target state="translated">&lt;code&gt;{:next, conn}&lt;/code&gt; 是否应调用下一个解析器</target>
        </trans-unit>
        <trans-unit id="17faa2644282a117df8deb0b5b5b5e18fcfd3222" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:not, nil}&lt;/code&gt; - which specifies the field must not be nil</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9f3a07e7cb34d66220a5536ba35d5dfd70ba87b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:ok, body_params, conn}&lt;/code&gt; if the parser is able to handle the given content-type; &lt;code&gt;body_params&lt;/code&gt; should be a map</source>
          <target state="translated">&lt;code&gt;{:ok, body_params, conn}&lt;/code&gt; 如果解析器能够处理给定的内容类型； &lt;code&gt;body_params&lt;/code&gt; 应该是一张地图</target>
        </trans-unit>
        <trans-unit id="1113731703331bd1d15a150da69e718c748007c7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:ok, state}&lt;/code&gt; - continues the socket with no reply</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af57bcf2b2958150c93d64000a61a51313730a9a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:ok, type, subtype, map_of_params}&lt;/code&gt; if everything goes fine</source>
          <target state="translated">&lt;code&gt;{:ok, type, subtype, map_of_params}&lt;/code&gt; 如果一切正常</target>
        </trans-unit>
        <trans-unit id="4ec082e3567953282fbd04048fb57421c37cee80" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:push, reply, state}&lt;/code&gt; - continues the socket with reply</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09123fe74ae8c7bd7d51f4f56a6c5fae42afdbaa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:replace, fields}&lt;/code&gt; - replace only specific columns. This option requires &lt;code&gt;:conflict_target&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b215e61c191074394dbf923bb41775a8fa5ada4e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:replace, fields}&lt;/code&gt; - replace only specific columns. This option requires conflict_target</source>
          <target state="translated">&lt;code&gt;{:replace, fields}&lt;/code&gt; -仅替换特定的列。此选项需要冲突目标</target>
        </trans-unit>
        <trans-unit id="2423076ca328831d0e7e9294dc0b46567732aed9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:replace_all_except, fields}&lt;/code&gt; - same as above except the given fields are not replaced. This option requires a schema</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b48052644bac2fb11ba3eccfa5fdff9e19af9e1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:reply, reply}&lt;/code&gt; - The reply to be sent to the client</source>
          <target state="translated">&lt;code&gt;{:reply, reply}&lt;/code&gt; -要发送给客户端的回复</target>
        </trans-unit>
        <trans-unit id="c60dbc36cfe28a4ec203e872e06ba60411705be9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:reply, status, reply, state}&lt;/code&gt; - continues the socket with reply</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c33ebebf91abd6f69c095b828bb5a73be4ab23ea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:session, session_config}&lt;/code&gt; - the session information from &lt;a href=&quot;../plug/plug.conn&quot;&gt;&lt;code&gt;Plug.Conn&lt;/code&gt;&lt;/a&gt;. The &lt;code&gt;session_config&lt;/code&gt; is an exact copy of the arguments given to &lt;a href=&quot;../plug/plug.session&quot;&gt;&lt;code&gt;Plug.Session&lt;/code&gt;&lt;/a&gt;. This requires the &quot;_csrf_token&quot; to be given as request parameter with the value of &lt;code&gt;URI.encode_www_form(Plug.CSRFProtection.get_csrf_token())&lt;/code&gt; when connecting to the socket. It can also be a MFA to allow loading config in runtime &lt;code&gt;{MyAppWeb.Auth, :get_session_config, []}&lt;/code&gt;. Otherwise the session will be &lt;code&gt;nil&lt;/code&gt;. Arbitrary keywords may also appear following the above valid keys, which is useful for passing custom connection information to the socket. For example: socket &quot;/socket&quot;, AppWeb.UserSocket, websocket: [</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28f6d0aa05a90f073bac9010871ba07c79ec5ed5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:stop, reason, state}&lt;/code&gt; - stops the socket</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1573672f3d270a166ee722ed200846e37ef9cf60" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:takeover, node}&lt;/code&gt; - used if the application is distributed and is started on the current node because of a failover on the node &lt;code&gt;node&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;{:takeover, node}&lt;/code&gt; -如果应用程序是分布式的，并且由于节点 &lt;code&gt;node&lt;/code&gt; 上的故障转移而在当前节点上启动，则使用它。</target>
        </trans-unit>
        <trans-unit id="94add01753d5f0af3e82d4a2cf547589069cba4a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;NOTE:&lt;/em&gt; Make sure you've read the &lt;a href=&quot;assigns-eex&quot;&gt;Assigns and LiveEEx templates&lt;/a&gt; guide before moving forward.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27bbd69bf6fe8a187def7224a56685257b153244" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;NOTE&lt;/em&gt;: This feature depends on the internals of Cowboy 1.0 API and how it integrates with Phoenix. Those may change at &lt;em&gt;any time&lt;/em&gt;, without backwards compatibility, specifically when Cowboy 2.0 is released.</source>
          <target state="translated">&lt;em&gt;注意&lt;/em&gt;：此功能取决于Cowboy 1.0 API的内部以及它与Phoenix的集成方式。那些可以在改变&lt;em&gt;的任何时间&lt;/em&gt;，而不会向后兼容性，牛仔2.0被释放特别是当。</target>
        </trans-unit>
        <trans-unit id="0f88b0db28d31a4e9cf8dfc8eb5f3b6931d4a763" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;NOTE&lt;/em&gt;: This feature depends on the internals of Cowboy 1.0 API and how it integrates with Phoenix. Those may change at &lt;em&gt;any time&lt;/em&gt;, without backwards compatibility.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbe2088f6f79d4966a5e5be72bf95f44681f6fd4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; the above assumes there is &lt;code&gt;plug :put_root_layout&lt;/code&gt; call in your router that configures the LiveView layout. This call is automatically included by &lt;code&gt;mix phx.new --live&lt;/code&gt; and described in the installation guide. If you don't want to configure a root layout, you must pass &lt;code&gt;layout: {MyAppWeb.LayoutView, &quot;app.html&quot;}&lt;/code&gt; as an option to the &lt;code&gt;live&lt;/code&gt; macro above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c5eb8339e35e619d28e1600159a8638879a94c3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note&lt;/em&gt;: If you find yourself needing to dynamically patch other parts of the base layout, such as injecting new scripts or styles into the &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; during live navigation, &lt;em&gt;then a regular, non-live, page navigation should be used instead&lt;/em&gt;. Assigning the &lt;code&gt;@page_title&lt;/code&gt; updates the &lt;code&gt;document.title&lt;/code&gt; directly, and therefore cannot be used to update any other part of the base layout.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2808c210a7f7d14573dceaa04938aca641e0452d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note&lt;/em&gt;: In such cases, a &lt;code&gt;socket_ref&lt;/code&gt; should be generated and passed to the external process, so the &lt;code&gt;socket&lt;/code&gt; itself is not leaked outside the channel. The &lt;code&gt;socket&lt;/code&gt; holds information such as assigns and transport configuration, so it&amp;rsquo;s important to not copy this information outside of the channel that owns it.</source>
          <target state="translated">&lt;em&gt;注意&lt;/em&gt;：在这种情况下，应该生成一个 &lt;code&gt;socket_ref&lt;/code&gt; 并将其传递给外部进程，这样 &lt;code&gt;socket&lt;/code&gt; 本身就不会泄漏到通道之外。该 &lt;code&gt;socket&lt;/code&gt; 包含诸如分配和传输配置，所以它的重要的不可复制拥有它的信道的信息之外。</target>
        </trans-unit>
        <trans-unit id="13d6b2e1abd760c9dc2a4bb9d197a15886553be1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note&lt;/em&gt;: In such cases, a &lt;code&gt;socket_ref&lt;/code&gt; should be generated and passed to the external process, so the &lt;code&gt;socket&lt;/code&gt; itself is not leaked outside the channel. The &lt;code&gt;socket&lt;/code&gt; holds information such as assigns and transport configuration, so it's important to not copy this information outside of the channel that owns it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="416a2feb44d7d80ca93d06445e0f0d6695814482" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note&lt;/em&gt;: LiveView redirects rely on instructing client to perform a &lt;code&gt;window.location&lt;/code&gt; update on the provided redirect location. The whole page will be reloaded and all state will be discarded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="689867568d0b83836769c6639adde50a32fff317" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note&lt;/em&gt;: The live layout is always wrapped by the LiveView's &lt;code&gt;:container&lt;/code&gt; tag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9f18d44220f56045e84bb12ec592e03d17051f8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note&lt;/em&gt;: The token is deleted only after a response has been sent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c83f347ad9b455d3ad455e2be7b3168749ae9553" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note&lt;/em&gt;: While you can use &lt;a href=&quot;#put_flash/3&quot;&gt;&lt;code&gt;put_flash/3&lt;/code&gt;&lt;/a&gt; inside a &lt;a href=&quot;phoenix.livecomponent&quot;&gt;&lt;code&gt;Phoenix.LiveComponent&lt;/code&gt;&lt;/a&gt;, components have their own &lt;code&gt;@flash&lt;/code&gt; assigns. The &lt;code&gt;@flash&lt;/code&gt; assign in a component is only copied to its parent LiveView if the component calls &lt;a href=&quot;#push_redirect/2&quot;&gt;&lt;code&gt;push_redirect/2&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#push_patch/2&quot;&gt;&lt;code&gt;push_patch/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51c66fe47c0b7a6becc905dbb63cc3eec67f4303" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note&lt;/em&gt;: You must also place the &lt;a href=&quot;phoenix.liveview.router#fetch_live_flash/2&quot;&gt;&lt;code&gt;Phoenix.LiveView.Router.fetch_live_flash/2&lt;/code&gt;&lt;/a&gt; plug in your browser's pipeline in place of &lt;code&gt;fetch_flash&lt;/code&gt; to be supported, for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="425130fd13ec208a7e979100759f959622e8601b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note&lt;/em&gt;: events pushed from the server via &lt;code&gt;push_event&lt;/code&gt; are global and will be dispatched to all active hooks on the client who are handling that event.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0b652c457ecb4e96144d6d341db4cccb9992577" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note&lt;/em&gt;: events will be dispatched to all active hooks on the client who are handling the given &lt;code&gt;event&lt;/code&gt;. Scoped events can be achieved by namespacing your event names.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b3a3429c330d8a5bc256900671e64cce2552d03" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note&lt;/em&gt;: intercepting events can introduce significantly more overhead if a large number of subscribers must customize a message since the broadcast will be encoded N times instead of a single shared encoding across all subscribers.</source>
          <target state="translated">&lt;em&gt;注意&lt;/em&gt;：如果大量订户必须自定义消息，则拦截事件可能会带来更多的开销，因为广播将被编码N次，而不是在所有订户之间共享编码。</target>
        </trans-unit>
        <trans-unit id="85c693c0d232226e41f03629572986788a6d71a4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note&lt;/em&gt;: when using &lt;code&gt;phx-hook&lt;/code&gt;, a unique DOM ID must always be set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76786bc8f27ef8b9694e60a85180adc54c43e8c4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Reminder&lt;/em&gt;: &lt;a href=&quot;../phoenix_html/phoenix.html.form#form_for/3&quot;&gt;&lt;code&gt;form_for/3&lt;/code&gt;&lt;/a&gt; is a &lt;a href=&quot;../phoenix_html/phoenix.html&quot;&gt;&lt;code&gt;Phoenix.HTML&lt;/code&gt;&lt;/a&gt; helper. Don't forget to include &lt;code&gt;use Phoenix.HTML&lt;/code&gt; at the top of your LiveView, if using &lt;a href=&quot;../phoenix_html/phoenix.html&quot;&gt;&lt;code&gt;Phoenix.HTML&lt;/code&gt;&lt;/a&gt; helpers. Also, if using &lt;code&gt;error_tag/2&lt;/code&gt;, don't forget to &lt;code&gt;import MyAppWeb.ErrorHelpers&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0635c4e59f4ac617f91b3e1be5ccfef68e754d43" translate="yes" xml:space="preserve">
          <source>&lt;small&gt;Plug v1.7.1&lt;/small&gt; Plug &lt;small&gt;behaviour&lt;/small&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4da554e7fe1ec57273ea1d33e2f985b69b05a763" translate="yes" xml:space="preserve">
          <source>&lt;small&gt;Plug v1.7.1&lt;/small&gt; Plug.Builder</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa42a1adde8a113e02082dae9533f8561225479f" translate="yes" xml:space="preserve">
          <source>&lt;small&gt;Plug v1.7.1&lt;/small&gt; Plug.CSRFProtection</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="264d7cf86d36ea1be2d233f002d900f20b56006f" translate="yes" xml:space="preserve">
          <source>&lt;small&gt;Plug v1.7.1&lt;/small&gt; Plug.CSRFProtection.InvalidCSRFTokenError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fe748d2262322cb6cbbd6a03a57b51dcad38f37" translate="yes" xml:space="preserve">
          <source>&lt;small&gt;Plug v1.7.1&lt;/small&gt; Plug.Conn</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80fcb6333504bf0e1c7f39339725ea605e61734a" translate="yes" xml:space="preserve">
          <source>&lt;small&gt;Plug v1.7.1&lt;/small&gt; Plug.Conn.Adapter &lt;small&gt;behaviour&lt;/small&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55c898df50a7c928eda926b82ee44dddd7399876" translate="yes" xml:space="preserve">
          <source>&lt;small&gt;Plug v1.7.1&lt;/small&gt; Plug.Conn.AlreadySentError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e57bd4797c634a8b9dcf71208edb3d67d104ebaa" translate="yes" xml:space="preserve">
          <source>&lt;small&gt;Plug v1.7.1&lt;/small&gt; Plug.Conn.InvalidHeaderError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63331bcc1835611faf672f2959fdecfd4d5c1daf" translate="yes" xml:space="preserve">
          <source>&lt;small&gt;Plug v1.7.1&lt;/small&gt; Plug.Conn.Status</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="905f6e7e3b764e49f9967706b405db035388994e" translate="yes" xml:space="preserve">
          <source>&lt;small&gt;Plug v1.7.1&lt;/small&gt; Plug.Conn.Unfetched</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc9f8cb59dacff68156a99ef05d7414dbe6e373e" translate="yes" xml:space="preserve">
          <source>&lt;small&gt;Plug v1.7.1&lt;/small&gt; Plug.Debugger</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60949a24623a399ffc2370b8da9591869ed80c75" translate="yes" xml:space="preserve">
          <source>&lt;small&gt;Plug v1.7.1&lt;/small&gt; Plug.ErrorHandler</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbbe09eb8f97d63b6fb2a2e21735d0d6f60d70f2" translate="yes" xml:space="preserve">
          <source>&lt;small&gt;Plug v1.7.1&lt;/small&gt; Plug.Logger</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d57575107f5b55d343939df8f1e7eca100ff5c53" translate="yes" xml:space="preserve">
          <source>&lt;small&gt;Plug v1.7.1&lt;/small&gt; Plug.Parsers &lt;small&gt;behaviour&lt;/small&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55a10e3ffa87078e1efb41a31b592e500583e202" translate="yes" xml:space="preserve">
          <source>&lt;small&gt;Plug v1.7.1&lt;/small&gt; Plug.Parsers.JSON</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f47a6c54600a9ee120ba5e2ba162b895bda1e8bd" translate="yes" xml:space="preserve">
          <source>&lt;small&gt;Plug v1.7.1&lt;/small&gt; Plug.Parsers.MULTIPART</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d4b80fe55addaa628fa41bbda2b51fd8a5fb4ff" translate="yes" xml:space="preserve">
          <source>&lt;small&gt;Plug v1.7.1&lt;/small&gt; Plug.Parsers.ParseError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8643c6cc94e9185394ccd9f5c37bfaa0cdee2a4" translate="yes" xml:space="preserve">
          <source>&lt;small&gt;Plug v1.7.1&lt;/small&gt; Plug.Parsers.RequestTooLargeError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8a390ef6b10c8e069846b17065d5b6fa0054039" translate="yes" xml:space="preserve">
          <source>&lt;small&gt;Plug v1.7.1&lt;/small&gt; Plug.Parsers.URLENCODED</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15e5ec3b84994d33f555bd33d4116ed203a3649c" translate="yes" xml:space="preserve">
          <source>&lt;small&gt;Plug v1.7.1&lt;/small&gt; Plug.Parsers.UnsupportedMediaTypeError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0c2f15abfc84dbe3965a6fc4b9842b962090e1b" translate="yes" xml:space="preserve">
          <source>&lt;small&gt;Plug v1.7.1&lt;/small&gt; Plug.Router</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="432cb22acb7925383544c23b6916eb4d5c0aabab" translate="yes" xml:space="preserve">
          <source>&lt;small&gt;Plug v1.7.1&lt;/small&gt; Plug.Upload</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e9d66999fd6756aa9f9cb7d7324b3476d436574" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;DO NOT&lt;/strong&gt; use this function if you wish to broadcast to the current node, as it is always serialized, use &lt;a href=&quot;#local_broadcast/4&quot;&gt;&lt;code&gt;local_broadcast/4&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41f23e5535e3c18658aa43bcf9d416b91c4733a0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;IMPORTANT!&lt;/strong&gt; Beware of using CTEs. In raw SQL, CTEs can be used as a mechanism to organize queries, but said mechanism has no purpose in Ecto since Ecto queries are composable by definition. In other words, if you need to break a large query into parts, use all of the functionality in Elixir and in this module to structure your code. Furthermore, breaking a query into CTEs can negatively impact performance, as the database may not optimize efficiently across CTEs. The main use case for CTEs in Ecto is to provide recursive definitions, which we outline in the following section. Non-recursive CTEs can often be written as joins or subqueries, which provide better performance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b589139db6d88819986a51bc3d02ac436a6272ff" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;IMPORTANT&lt;/strong&gt;: When filtering fields for associations, you MUST include the foreign keys used in the relationship, otherwise Ecto will be unable to find associated records.</source>
          <target state="translated">&lt;strong&gt;重要说明&lt;/strong&gt;：过滤关联字段时，必须包括关系中使用的外键，否则Ecto将无法找到关联的记录。</target>
        </trans-unit>
        <trans-unit id="4b2ad0477449f7a71e16e1afcd84ee9487948a91" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Important!&lt;/strong&gt; Please use this feature only when strictly necessary, otherwise it is very easy to end-up with large schemas with dozens of different associations polluting your schema and affecting your application performance. For instance, if you are using associations only for different querying purposes, then it is preferable to build and compose queries, rather than defining multiple associations:</source>
          <target state="translated">&lt;strong&gt;重要！&lt;/strong&gt;请仅在绝对必要的情况下使用此功能，否则最终很容易遇到具有数十种不同关联的大型架构，这些关联会污染您的架构并影响应用程序性能。例如，如果您仅将关联用于不同的查询目的，则最好构建和组成查询，而不是定义多个关联：</target>
        </trans-unit>
        <trans-unit id="16620b5f139013681ae6f8a76df54fbcb3c0fa41" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE:&lt;/strong&gt; Because event and payload are patterns, they will be matched. This means that if you wish to assert that the received payload is equivalent to an existing variable, you need to pin the variable in the assertion expression.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;因为事件和有效负载是模式，所以它们将被匹配。这意味着，如果您想断言所接收的有效载荷等效于现有变量，则需要将该变量固定在断言表达式中。</target>
        </trans-unit>
        <trans-unit id="4d9ae0b945e7e9fc678fd551239242d252c19116" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note this feature is experimental and may be changed or removed in future releases.&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfb26765a6c5a896b8cc0fa69110abf657471932" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; If this module is used with &lt;a href=&quot;plug.debugger&quot;&gt;&lt;code&gt;Plug.Debugger&lt;/code&gt;&lt;/a&gt;, it must be used after &lt;a href=&quot;plug.debugger&quot;&gt;&lt;code&gt;Plug.Debugger&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;如果此模块与&lt;a href=&quot;plug.debugger&quot;&gt; &lt;code&gt;Plug.Debugger&lt;/code&gt; &lt;/a&gt;一起使用，则必须在&lt;a href=&quot;plug.debugger&quot;&gt; &lt;code&gt;Plug.Debugger&lt;/code&gt; &lt;/a&gt;之后使用。</target>
        </trans-unit>
        <trans-unit id="3d8f6162f9e88d04385e9a8ead3a5bb4dcbdec4b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; If this module is used with &lt;a href=&quot;plug.errorhandler&quot;&gt;&lt;code&gt;Plug.ErrorHandler&lt;/code&gt;&lt;/a&gt;, only one of them will effectively handle errors. For this reason, it is recommended that &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Plug.Debugger&lt;/code&gt;&lt;/a&gt; is used before &lt;a href=&quot;plug.errorhandler&quot;&gt;&lt;code&gt;Plug.ErrorHandler&lt;/code&gt;&lt;/a&gt; and only in particular environments, like &lt;code&gt;:dev&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="712668559f0783d4307835ecbfbbb87be49ac12c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; If this module is used with &lt;a href=&quot;plug.errorhandler&quot;&gt;&lt;code&gt;Plug.ErrorHandler&lt;/code&gt;&lt;/a&gt;, only one of them will effectively handle errors. For this reason, it is recommended that &lt;a href=&quot;plug.debugger#content&quot;&gt;&lt;code&gt;Plug.Debugger&lt;/code&gt;&lt;/a&gt; is used before &lt;a href=&quot;plug.errorhandler&quot;&gt;&lt;code&gt;Plug.ErrorHandler&lt;/code&gt;&lt;/a&gt; and only in particular environments, like &lt;code&gt;:dev&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;如果此模块与&lt;a href=&quot;plug.errorhandler&quot;&gt; &lt;code&gt;Plug.ErrorHandler&lt;/code&gt; &lt;/a&gt;一起使用，则只有其中一个可以有效地处理错误。出于这个原因，建议在&lt;a href=&quot;plug.debugger#content&quot;&gt; &lt;code&gt;Plug.Debugger&lt;/code&gt; &lt;/a&gt;之前使用&lt;a href=&quot;plug.errorhandler&quot;&gt; &lt;code&gt;Plug.ErrorHandler&lt;/code&gt; &lt;/a&gt;并且仅在诸如 &lt;code&gt;:dev&lt;/code&gt; 的特定环境中使用。</target>
        </trans-unit>
        <trans-unit id="9482570896b7c3cca1137460db7a742f49634771" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Phoenix v1.5 comes with built-in support for LiveView apps. Just create your application with &lt;code&gt;mix phx.new my_app --live&lt;/code&gt;. If you are using earlier Phoenix versions or your app already exists, keep on reading.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb4ad858b8596ea7eba578880589b13173617f56" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; if you want to see form recovery working in development, please make sure to disable live reloading in development by commenting out the LiveReload plug in your &lt;code&gt;endpoint.ex&lt;/code&gt; file or by setting &lt;code&gt;code_reloader: false&lt;/code&gt; in your &lt;code&gt;config/dev.exs&lt;/code&gt;. Otherwise live reloading may cause the current page to be reloaded whenever you restart the server, which will discard all form state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf568569e74e68cdba50c82d5b1db96640507dd3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; only set &lt;code&gt;phx-track-static&lt;/code&gt; on your own assets. For example, do not set it in external JavaScript files:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0d91c61e9d56f0fdcdc183a40c90744c633d092" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; this functionality requires Phoenix v1.5.2 or later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f296ef2f03398d2799d4e2d331b80c16fad3e8fe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt;&lt;a href=&quot;#send_update/2&quot;&gt;&lt;code&gt;send_update/2&lt;/code&gt;&lt;/a&gt; cannot update a LiveComponent that is mounted in a different LiveView. To update a component in a different LiveView you must send a message to the LiveView process that the LiveComponent is mounted within (often via &lt;a href=&quot;../phoenix_pubsub/phoenix.pubsub&quot;&gt;&lt;code&gt;Phoenix.PubSub&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0767479b021c0de0f302fe86039d02c2ae1fb455" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: as mentioned in the documentation for &lt;a href=&quot;plug.parsers&quot;&gt;&lt;code&gt;Plug.Parsers&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;:plug&lt;/code&gt; application has to be started in order to upload files and use the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Plug.Upload&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7aa3026c84902e7be059c21f940d107febb0b3d9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: as mentioned in the documentation for &lt;a href=&quot;plug.parsers&quot;&gt;&lt;code&gt;Plug.Parsers&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;:plug&lt;/code&gt; application has to be started in order to upload files and use the &lt;a href=&quot;plug.upload#content&quot;&gt;&lt;code&gt;Plug.Upload&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：如&lt;a href=&quot;plug.parsers&quot;&gt; &lt;code&gt;Plug.Parsers&lt;/code&gt; &lt;/a&gt;文档中所述，必须启动 &lt;code&gt;:plug&lt;/code&gt; 应用程序才能上传文件并使用&lt;a href=&quot;plug.upload#content&quot;&gt; &lt;code&gt;Plug.Upload&lt;/code&gt; &lt;/a&gt;模块。</target>
        </trans-unit>
        <trans-unit id="ef937726101d6bbf1ea792d981c362dd127505c0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Notes:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Notes:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="59391d7d5398eb304cc656f88d0830c5d1c30f8d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Requirement&lt;/strong&gt;: This guide expects that you have gone through &lt;a href=&quot;ecto&quot;&gt;the Ecto guide&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7d6a920b2ee73611590d57c0146b8b0d0874e5b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Requirement&lt;/strong&gt;: This guide expects that you have gone through &lt;a href=&quot;request_lifecycle&quot;&gt;the Request life-cycle guide&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d751ca8d591ad6c6735e33aa779071b43fabe4a5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Requirement&lt;/strong&gt;: This guide expects that you have gone through the introductory guides and got a Phoenix application up and running.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84ad9da37360c471418cbd7a4f6532031cedec2b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The cipher suites were last updated on 2018-JUN-14.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;密码套件的最新更新时间为2018年6月14日。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ec27dad402bd53d8520685e4f8f307f07ab67066" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: ensure that clients cannot spoof their IP address by including this header in their original request, by filtering such headers in the proxy!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23f83bb1796aaae4c795a3fe999b12c9e63b618a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: it is very difficult, if not impossible, to revert the effect of HSTS before the entry stored in the browser expires! Consider using a short &lt;code&gt;:expires&lt;/code&gt; value initially, and increasing it to a large value (e.g. 31536000 seconds for 1 year) after testing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="977713adc75f83a5b3473a95460185fd112627aa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: use self-signed certificates only for local testing, and do not mark such test certificates as globally trusted in browsers or operating system!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cad69f4d5c0cf72c96c3c5640bf1b9c6d65b2cd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;You can use Ecto schemas and changesets to cast and validate any kind of data, regardless if the data will be persisted to an Ecto repository or not&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;您可以使用Ecto模式和变更集来投射和验证任何类型的数据，而不管数据是否持久化到Ecto存储库中&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="e8d365a24b2c40cbaa5529ec29ec24dafb15a83e" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;match&lt;/code&gt; will match any route regardless of the HTTP method. Check &lt;a href=&quot;#match/3&quot;&gt;&lt;code&gt;match/3&lt;/code&gt;&lt;/a&gt; for more information on how route compilation works and a list of supported options.</source>
          <target state="translated">甲 &lt;code&gt;match&lt;/code&gt; 无论HTTP方法的将匹配的任何途径。选中&lt;a href=&quot;#match/3&quot;&gt; &lt;code&gt;match/3&lt;/code&gt; &lt;/a&gt;，以获取有关路由编译如何工作的更多信息以及支持的选项的列表。</target>
        </trans-unit>
        <trans-unit id="c5d6ab7944440e9f874b849eecf02f234b32e425" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;phx-keydown&lt;/code&gt; binding is only throttled for key repeats. Unique keypresses back-to-back will dispatch the pressed key events.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19e294d8f5196b8fffae61a23b79786066eff46e" translate="yes" xml:space="preserve">
          <source>A DELETE request to &lt;code&gt;/users/:id&lt;/code&gt; will invoke the &lt;code&gt;delete&lt;/code&gt; action with an ID to remove the individual user from the data store.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1f89e5b3085312297a30ccdec8fedb775a68739" translate="yes" xml:space="preserve">
          <source>A DSL to define a routing algorithm that works with Plug.</source>
          <target state="translated">一个DSL来定义一个与Plug一起工作的路由算法。</target>
        </trans-unit>
        <trans-unit id="40955228103fb4a3febe39027046c4264cc8b9f8" translate="yes" xml:space="preserve">
          <source>A GET request to &lt;code&gt;/users/:id/edit&lt;/code&gt; will invoke the &lt;code&gt;edit&lt;/code&gt; action with an ID to retrieve an individual user from the data store and present the information in a form for editing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="305f1f3765fad844b78b2517312b9a7447803d28" translate="yes" xml:space="preserve">
          <source>A GET request to &lt;code&gt;/users/:id&lt;/code&gt; will invoke the &lt;code&gt;show&lt;/code&gt; action with an id to show an individual user identified by that ID.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdad7d2c9029b1baf5442355eaea158e595e28dc" translate="yes" xml:space="preserve">
          <source>A GET request to &lt;code&gt;/users/new&lt;/code&gt; will invoke the &lt;code&gt;new&lt;/code&gt; action to present a form for creating a new user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d6b6c89ab31051a71f9f3a18c63c71e0147e1b3" translate="yes" xml:space="preserve">
          <source>A GET request to &lt;code&gt;/users&lt;/code&gt; will invoke the &lt;code&gt;index&lt;/code&gt; action to show all the users.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="184bae6e7ea63ef87415e22542b422c2059fed96" translate="yes" xml:space="preserve">
          <source>A LiveView begins as a regular HTTP request and HTML response, and then upgrades to a stateful view on client connect, guaranteeing a regular HTML page even if JavaScript is disabled. Any time a stateful view changes or updates its socket assigns, it is automatically re-rendered and the updates are pushed to the client.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c9c9a794022eb65022923b31e317a5956253d4b" translate="yes" xml:space="preserve">
          <source>A LiveView can be routed to by using the &lt;code&gt;live&lt;/code&gt; macro with a path and the name of the LiveView:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd9145e78df8bb2fbf84cd52bb65185ee2bd1af3" translate="yes" xml:space="preserve">
          <source>A LiveView is a simple module that requires two callbacks: &lt;a href=&quot;#c:mount/3&quot;&gt;&lt;code&gt;mount/3&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#c:render/1&quot;&gt;&lt;code&gt;render/1&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da0c1cf567abac8b773c1074de7eb911fb691dcc" translate="yes" xml:space="preserve">
          <source>A PATCH request to &lt;code&gt;/users/:id&lt;/code&gt; will invoke the &lt;code&gt;update&lt;/code&gt; action with an ID to save the updated user to the data store.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec262fd36b04c39661285e3a619dc48715cd927f" translate="yes" xml:space="preserve">
          <source>A POST request to &lt;code&gt;/users&lt;/code&gt; will invoke the &lt;code&gt;create&lt;/code&gt; action to save a new user to the data store.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10210c3154f0f0fe1d9cae3fedb5f1315b683380" translate="yes" xml:space="preserve">
          <source>A PUT request to &lt;code&gt;/users/:id&lt;/code&gt; will also invoke the &lt;code&gt;update&lt;/code&gt; action with an ID to save the updated user to the data store.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11d464647b1c302ddfced5ce15ec52a3a34c1b76" translate="yes" xml:space="preserve">
          <source>A Phoenix Example</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ae1a7e1a27cda948880c8475e2814e96b706399" translate="yes" xml:space="preserve">
          <source>A Plug Adapter that supports HTTPS, e.g. &lt;a href=&quot;https://hex.pm/packages/plug_cowboy&quot;&gt;Plug.Cowboy&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56ae008b2dbb8e2c8b9d49a21483781040acd885" translate="yes" xml:space="preserve">
          <source>A Plug to convert &lt;code&gt;HEAD&lt;/code&gt; requests to &lt;code&gt;GET&lt;/code&gt; requests.</source>
          <target state="translated">一个将 &lt;code&gt;HEAD&lt;/code&gt; 请求转换为 &lt;code&gt;GET&lt;/code&gt; 请求的插件。</target>
        </trans-unit>
        <trans-unit id="d9c9bd80e3aec4eb14e3119b821163e1e2ebc9cd" translate="yes" xml:space="preserve">
          <source>A Telemetry event is made up of the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9212b48251284e0caf9388416e943cd719c4abfa" translate="yes" xml:space="preserve">
          <source>A behaviour that serializes incoming and outgoing socket messages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b010a98e050eb10dc2e5f1b11c9caa3386cee439" translate="yes" xml:space="preserve">
          <source>A callback executed when the repo starts or when configuration is read</source>
          <target state="translated">当启动repo或读取配置时执行的回调。</target>
        </trans-unit>
        <trans-unit id="fcc767a7e430e354ff1bfd81d0d475cdd63612f4" translate="yes" xml:space="preserve">
          <source>A callback executed when the repo starts or when configuration is read.</source>
          <target state="translated">当回购启动或读取配置时执行的回调。</target>
        </trans-unit>
        <trans-unit id="7eb7511e858848219f54b95873996b4e099e5689" translate="yes" xml:space="preserve">
          <source>A changeset is required as it is the only mechanism for tracking dirty changes. Only the fields present in the &lt;code&gt;changes&lt;/code&gt; part of the changeset are sent to the database. Any other, in-memory changes done to the schema are ignored.</source>
          <target state="translated">变更集是必需的，因为它是跟踪脏变更的唯一机制。仅将变更集的 &lt;code&gt;changes&lt;/code&gt; 部分中存在的字段发送到数据库。对架构所做的任何其他内存中更改都将被忽略。</target>
        </trans-unit>
        <trans-unit id="388bae3344dc49c248c086da49078f3c9a747194" translate="yes" xml:space="preserve">
          <source>A changeset is supplied along with a function to apply to each error message as the changeset is traversed. The error message function receives an error tuple &lt;code&gt;{msg, opts}&lt;/code&gt;, for example:</source>
          <target state="translated">提供了变更集以及在遍历变更集时应用于每个错误消息的功能。错误消息函数接收错误元组 &lt;code&gt;{msg, opts}&lt;/code&gt; ，例如：</target>
        </trans-unit>
        <trans-unit id="bbc0ed247dabdd047db8fd7f074aba54c53f0214" translate="yes" xml:space="preserve">
          <source>A collection is any enumerable of structs. This function returns the rendered collection in a list:</source>
          <target state="translated">一个集合是任何结构的枚举。这个函数以列表的形式返回渲染后的集合。</target>
        </trans-unit>
        <trans-unit id="9f2e0d0c42f6c749eef59802dc33214c5b12f1eb" translate="yes" xml:space="preserve">
          <source>A collection of helpers to be imported into your views.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="620ac80b98e2b486fda0b863dfdd7ce97f8761ec" translate="yes" xml:space="preserve">
          <source>A common table expression (CTE) also known as WITH expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c608908c246ab16423c148e6fa64ef056979bdbb" translate="yes" xml:space="preserve">
          <source>A common use case is updating a counter cache, in this case updating a post&amp;rsquo;s comment count when a comment is created:</source>
          <target state="translated">一个常见的用例是更新计数器缓存，在这种情况下，创建评论时会更新帖子的评论计数：</target>
        </trans-unit>
        <trans-unit id="eb98855a0c95e34d029258a274731d0384744968" translate="yes" xml:space="preserve">
          <source>A common use case is updating a counter cache, in this case updating a post's comment count when a comment is created:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d16b4ddf57438100c6143c5af9cff2f6af21dff5" translate="yes" xml:space="preserve">
          <source>A constraint is a map with the following fields:</source>
          <target state="translated">一个约束是一个具有以下字段的地图:</target>
        </trans-unit>
        <trans-unit id="025d095189152f316c790811b01d5dd5842fe730" translate="yes" xml:space="preserve">
          <source>A container can be marked with &lt;code&gt;phx-update&lt;/code&gt;, allowing the DOM patch operations to avoid updating or removing portions of the LiveView, or to append or prepend the updates rather than replacing the existing contents. This is useful for client-side interop with existing libraries that do their own DOM operations. The following &lt;code&gt;phx-update&lt;/code&gt; values are supported:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57963828a8668feeba8780dca8ee7c47104fb07a" translate="yes" xml:space="preserve">
          <source>A controller by default provides many convenience functions for manipulating the connection, rendering templates, and more.</source>
          <target state="translated">默认的控制器提供了许多方便的功能,用于操作连接、渲染模板等。</target>
        </trans-unit>
        <trans-unit id="6b5a1b658082aeefd7644070c78660f46428db9d" translate="yes" xml:space="preserve">
          <source>A couple of files were generated with this task. First, we have a &lt;code&gt;user.ex&lt;/code&gt; file, containing our Ecto schema with our schema definition of the fields we passed to the task. Next, a migration file was generated inside &lt;code&gt;priv/repo/migrations&lt;/code&gt; which will create our database table that our schema maps to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa6f9752dd3b6d0d7372c3ed36166a0a7f66b682" translate="yes" xml:space="preserve">
          <source>A custom channel implementation MUST invoke &lt;code&gt;GenServer.reply(from, {:ok | :error, reply_payload})&lt;/code&gt; during its initialization with a custom &lt;code&gt;reply_payload&lt;/code&gt; that will be sent as a reply to the client. Failing to do so will block the socket forever.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ca58df44db6ae9f0299d01c621c3b42cefdf8aa" translate="yes" xml:space="preserve">
          <source>A custom channel receives &lt;a href=&quot;phoenix.socket.message&quot;&gt;&lt;code&gt;Phoenix.Socket.Message&lt;/code&gt;&lt;/a&gt; structs as regular messages from the transport. Replies to those messages and custom messages can be sent to the socket at any moment by building an appropriate &lt;a href=&quot;phoenix.socket.reply&quot;&gt;&lt;code&gt;Phoenix.Socket.Reply&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;phoenix.socket.message&quot;&gt;&lt;code&gt;Phoenix.Socket.Message&lt;/code&gt;&lt;/a&gt; structs, encoding them with the serializer and dispatching the serialized result to the transport.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82dd2f5d8c41c25be625b40823e37d6a67414f02" translate="yes" xml:space="preserve">
          <source>A custom dispatcher may also be given as a fifth, optional argument. See the &quot;Custom dispatching&quot; section in the module documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3cb5897eb86fc23c7e36c4eb41697d2fd081125" translate="yes" xml:space="preserve">
          <source>A custom dispatcher may also be given as a fourth, optional argument. See the &quot;Custom dispatching&quot; section in the module documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10349bdecbe830d7172782cfe20d007bc64bc5ed" translate="yes" xml:space="preserve">
          <source>A custom headers map may also be given to be merged with defaults.</source>
          <target state="translated">也可以给出一个自定义的头图与默认值合并。</target>
        </trans-unit>
        <trans-unit id="1e063bc35d1255698a1fa0aa80b8b85e8b4cd7b5" translate="yes" xml:space="preserve">
          <source>A custom headers map may also be given to be merged with defaults. It is recommended for custom header keys to be in lowercase, to avoid sending duplicate keys in a request. Additionally, responses with mixed-case headers served over HTTP/2 are not considered valid by common clients, resulting in dropped responses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d48a1d706334ebdad1d7db287b9b4c843bc42eb" translate="yes" xml:space="preserve">
          <source>A custom type expects 4 functions to be implemented, all documented and described below. We also provide two examples of how custom types can be used in Ecto to augment existing types or providing your own types.</source>
          <target state="translated">一个自定义类型需要实现4个功能,所有这些功能都在下面进行了记录和描述。我们还提供了两个例子,说明如何在Ecto中使用自定义类型来增强现有类型或提供你自己的类型。</target>
        </trans-unit>
        <trans-unit id="d94ac0cca4c4677f5902badcf2266800aa7d904e" translate="yes" xml:space="preserve">
          <source>A custom type is a module that implements one of the &lt;a href=&quot;ecto.type&quot;&gt;&lt;code&gt;Ecto.Type&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;ecto.parameterizedtype&quot;&gt;&lt;code&gt;Ecto.ParameterizedType&lt;/code&gt;&lt;/a&gt; behaviours. By default, Ecto provides the following custom types:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d0900a0ddd633e5ba8eb37fff9e014676868d66" translate="yes" xml:space="preserve">
          <source>A custom type is a module that implements the &lt;a href=&quot;ecto.type&quot;&gt;&lt;code&gt;Ecto.Type&lt;/code&gt;&lt;/a&gt; behaviour. By default, Ecto provides the following custom types:</source>
          <target state="translated">自定义类型是实现&lt;a href=&quot;ecto.type&quot;&gt; &lt;code&gt;Ecto.Type&lt;/code&gt; &lt;/a&gt;行为的模块。默认情况下，Ecto提供以下自定义类型：</target>
        </trans-unit>
        <trans-unit id="32ecdd8fd7b37025f58b39a7dfbbcc8988a24674" translate="yes" xml:space="preserve">
          <source>A custom type that maps atoms to strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a747bda5fdf562428478cd022242ed593cda1f33" translate="yes" xml:space="preserve">
          <source>A distinct query expression</source>
          <target state="translated">一个独特的查询表达式</target>
        </trans-unit>
        <trans-unit id="684e1d79ed9b5db07cdfaeb906b9f0d3ebe6eb5a" translate="yes" xml:space="preserve">
          <source>A distinct query expression.</source>
          <target state="translated">一个独特的查询表达式。</target>
        </trans-unit>
        <trans-unit id="a1950dd57a002a1593df01e1817a7cc274948fc4" translate="yes" xml:space="preserve">
          <source>A dynamic expression can always be interpolated inside another dynamic expression and into the constructs described below.</source>
          <target state="translated">一个动态表达式总是可以在另一个动态表达式内部进行插值,并进入下面描述的构造。</target>
        </trans-unit>
        <trans-unit id="95d7b4b4305750e4d404e970af1ab7cae58df9eb" translate="yes" xml:space="preserve">
          <source>A fallback plug is useful to translate common domain data structures into a valid &lt;code&gt;%Plug.Conn{}&lt;/code&gt; response. If the controller action fails to return a &lt;code&gt;%Plug.Conn{}&lt;/code&gt;, the provided plug will be called and receive the controller&amp;rsquo;s &lt;code&gt;%Plug.Conn{}&lt;/code&gt; as it was before the action was invoked along with the value returned from the controller action.</source>
          <target state="translated">后备插件对于将通用域数据结构转换为有效的 &lt;code&gt;%Plug.Conn{}&lt;/code&gt; 响应非常有用。如果控制器动作未能返回 &lt;code&gt;%Plug.Conn{}&lt;/code&gt; ，则将调用提供的插件，并接收与调用动作之前一样的控制器的 &lt;code&gt;%Plug.Conn{}&lt;/code&gt; 以及从控制器动作返回的值。</target>
        </trans-unit>
        <trans-unit id="d6555cacc367409b90fbe3e36d37ce1f09e91f5c" translate="yes" xml:space="preserve">
          <source>A fallback plug is useful to translate common domain data structures into a valid &lt;code&gt;%Plug.Conn{}&lt;/code&gt; response. If the controller action fails to return a &lt;code&gt;%Plug.Conn{}&lt;/code&gt;, the provided plug will be called and receive the controller's &lt;code&gt;%Plug.Conn{}&lt;/code&gt; as it was before the action was invoked along with the value returned from the controller action.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d23f8d08ce26c75baca863635b315ac840b822e" translate="yes" xml:space="preserve">
          <source>A field marked with &lt;code&gt;redact: true&lt;/code&gt; will display a value of &lt;code&gt;**redacted**&lt;/code&gt; when inspected in changes inside a &lt;a href=&quot;ecto.changeset&quot;&gt;&lt;code&gt;Ecto.Changeset&lt;/code&gt;&lt;/a&gt; and be excluded from inspect on the schema unless the schema module is tagged with the option &lt;code&gt;@ecto_derive_inspect_for_redacted_fields false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="508aa6b4e12f81428e50ac3d49c96bbbcea5e73e" translate="yes" xml:space="preserve">
          <source>A format encoder must export a function called &lt;code&gt;encode_to_iodata!/1&lt;/code&gt; which receives the rendering artifact and returns iodata.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a13566eef334c9b65766da05ab4d4d43827f5f6" translate="yes" xml:space="preserve">
          <source>A fragment can also be used:</source>
          <target state="translated">也可以使用碎片。</target>
        </trans-unit>
        <trans-unit id="ae51f9dac9d7c54bb8170a15411f44df70ca2084" translate="yes" xml:space="preserve">
          <source>A fragment which defines the frame for window functions.</source>
          <target state="translated">一个定义窗口功能框架的片段。</target>
        </trans-unit>
        <trans-unit id="611554aaafb2bfcecee33fba1d8e4c075165ef62" translate="yes" xml:space="preserve">
          <source>A full list of all Phoenix telemetry events can be found in &lt;a href=&quot;phoenix.logger&quot;&gt;&lt;code&gt;Phoenix.Logger&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3323426ad17b0c275178d48cb6477e1d9c4b9815" translate="yes" xml:space="preserve">
          <source>A function plug is any function that receives a connection and a set of options and returns a connection. Its type signature must be:</source>
          <target state="translated">函数插件是接收一个连接和一组选项并返回一个连接的任何函数。其类型签名必须是:</target>
        </trans-unit>
        <trans-unit id="41b63ea3ad4c061f35ede93ceeae9bcd925674fe" translate="yes" xml:space="preserve">
          <source>A garbage collector process that cleans up the table used by &lt;a href=&quot;phoenix.pubsub.local&quot;&gt;&lt;code&gt;Phoenix.PubSub.Local&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">一个垃圾收集器进程，用于清理&lt;a href=&quot;phoenix.pubsub.local&quot;&gt; &lt;code&gt;Phoenix.PubSub.Local&lt;/code&gt; &lt;/a&gt;使用的表。</target>
        </trans-unit>
        <trans-unit id="8e2bc2fa7d983a2e362056403cedaf0dcf21134b" translate="yes" xml:space="preserve">
          <source>A group by query expression</source>
          <target state="translated">按查询表达式分组</target>
        </trans-unit>
        <trans-unit id="fbf7205eb24f77046d9fe35fbd00e1a311c37da6" translate="yes" xml:space="preserve">
          <source>A group by query expression.</source>
          <target state="translated">按查询表达式进行分组。</target>
        </trans-unit>
        <trans-unit id="9a0412ffa16bcb7f7b88bbbe0e9a5d658142fc6a" translate="yes" xml:space="preserve">
          <source>A handler will need to implement a &lt;code&gt;child_spec/3&lt;/code&gt; function which takes:</source>
          <target state="translated">处理程序将需要实现 &lt;code&gt;child_spec/3&lt;/code&gt; 函数，该函数需要：</target>
        </trans-unit>
        <trans-unit id="e98770d454075eda4766670bca1c8638c4ddaf13" translate="yes" xml:space="preserve">
          <source>A hex-encoded UUID string</source>
          <target state="translated">一个十六进制的UUID字符串</target>
        </trans-unit>
        <trans-unit id="1e5d0b6bf037b68f0ab5247229dfbbf297cc5801" translate="yes" xml:space="preserve">
          <source>A hex-encoded UUID string.</source>
          <target state="translated">一个十六进制的UUID字符串。</target>
        </trans-unit>
        <trans-unit id="94b525fd40b558cf7c5cb8a17c62318c0f7519cc" translate="yes" xml:space="preserve">
          <source>A join query expression</source>
          <target state="translated">连接查询表达式</target>
        </trans-unit>
        <trans-unit id="5ac8a34ba321b659953392223945bc3aec2d71a5" translate="yes" xml:space="preserve">
          <source>A join query expression.</source>
          <target state="translated">一个连接查询表达式。</target>
        </trans-unit>
        <trans-unit id="fc626b639569e14ed38b80e4cfe297a5eee2e775" translate="yes" xml:space="preserve">
          <source>A keyword list can also be interpolated:</source>
          <target state="translated">也可以插手关键词列表。</target>
        </trans-unit>
        <trans-unit id="f98c43a93fb2b8df9b43baa37305537ee03813e9" translate="yes" xml:space="preserve">
          <source>A limit query expression</source>
          <target state="translated">限额查询表达式</target>
        </trans-unit>
        <trans-unit id="3a42a9b46de5122ad916b07756c8c98239bd5464" translate="yes" xml:space="preserve">
          <source>A limit query expression.</source>
          <target state="translated">一个极限查询表达式。</target>
        </trans-unit>
        <trans-unit id="9326a99d5f5cbfad236b420591e04582f7a5b112" translate="yes" xml:space="preserve">
          <source>A list of atoms can also be interpolated for dynamic partitioning:</source>
          <target state="translated">原子列表也可以进行动态分区插值。</target>
        </trans-unit>
        <trans-unit id="548895d9732aa70eb4ec1302a1c7dc3677eeb752" translate="yes" xml:space="preserve">
          <source>A list of fields to order the window by, for example:</source>
          <target state="translated">例如,窗口排序的字段列表。</target>
        </trans-unit>
        <trans-unit id="211d256aebc6a4475a22f354ec17c5858108776e" translate="yes" xml:space="preserve">
          <source>A list of fields to partition the window by, for example:</source>
          <target state="translated">例如,用于分割窗口的字段列表。</target>
        </trans-unit>
        <trans-unit id="d0b5bde25a22d39b8961db0c9a86938d6ab92eea" translate="yes" xml:space="preserve">
          <source>A lock query expression</source>
          <target state="translated">一个锁的查询表达式</target>
        </trans-unit>
        <trans-unit id="af0f90fc01dd0405acd985a97f28893c9c38969e" translate="yes" xml:space="preserve">
          <source>A lock query expression.</source>
          <target state="translated">一个锁的查询表达式。</target>
        </trans-unit>
        <trans-unit id="8a37515c314028cb265ffc9da11d9cb1972f95a3" translate="yes" xml:space="preserve">
          <source>A macro that stores a new plug. &lt;code&gt;opts&lt;/code&gt; will be passed unchanged to the new plug</source>
          <target state="translated">存储新插件的宏。 &lt;code&gt;opts&lt;/code&gt; 将原样传递给新插件</target>
        </trans-unit>
        <trans-unit id="1492bad3d66e2fb22babef1faa31465bcbf67766" translate="yes" xml:space="preserve">
          <source>A macro that stores a new plug. &lt;code&gt;opts&lt;/code&gt; will be passed unchanged to the new plug.</source>
          <target state="translated">存储新插件的宏。 &lt;code&gt;opts&lt;/code&gt; 将原样传递给新插件。</target>
        </trans-unit>
        <trans-unit id="9669ce760ff0d6134d348fbea236193aa5997022" translate="yes" xml:space="preserve">
          <source>A map of metadata is returned with the following keys:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d5636e85e1ef2bad613229d74bc0e9b119b4eb8" translate="yes" xml:space="preserve">
          <source>A migration file for the repository and test files for the context and controller features will also be generated.</source>
          <target state="translated">仓库的迁移文件以及上下文和控制器功能的测试文件也将被生成。</target>
        </trans-unit>
        <trans-unit id="220aa5b54ca715c2d2f9fb2d1024b813114578fe" translate="yes" xml:space="preserve">
          <source>A migration file for the repository and test files for the context will also be generated.</source>
          <target state="translated">仓库的迁移文件和上下文的测试文件也将被生成。</target>
        </trans-unit>
        <trans-unit id="a3495195f1b2b7fec8c8882cb005197b94803116" translate="yes" xml:space="preserve">
          <source>A minimal HTTPS listener, using Plug.Cowboy, might be defined as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a7ad10c915de9107d9847304f90f45300a717e2" translate="yes" xml:space="preserve">
          <source>A module (&lt;strong&gt;not a plug&lt;/strong&gt;) for debugging in development.</source>
          <target state="translated">用于开发中调试的模块（&lt;strong&gt;不是插件&lt;/strong&gt;）。</target>
        </trans-unit>
        <trans-unit id="bb7b6f80c2f49bcca36ea5f27d90c322f347cbf7" translate="yes" xml:space="preserve">
          <source>A module plug is an extension of the function plug. It is a module that must export:</source>
          <target state="translated">模块插件是功能插件的扩展。它是一个必须导出的模块。</target>
        </trans-unit>
        <trans-unit id="1f14577898ec9c27ef3bf73631758c3ef60637ef" translate="yes" xml:space="preserve">
          <source>A module to be used in your existing plugs in order to provide error handling.</source>
          <target state="translated">一个用于现有插头的模块,以提供错误处理。</target>
        </trans-unit>
        <trans-unit id="67a9117a71efdc61533ad05c49c69886601f4a9c" translate="yes" xml:space="preserve">
          <source>A new Controller</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c07076627092ae2d0bfa89573bd3a550b3b1b0df" translate="yes" xml:space="preserve">
          <source>A new View</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ae6beb758947fcfcf89be24aca92bbc2e9b06a7" translate="yes" xml:space="preserve">
          <source>A new file will be generated in:</source>
          <target state="translated">一个新的文件将生成在。</target>
        </trans-unit>
        <trans-unit id="3ddc1a83cdb6a8f6d2ed02bae29d0825caa1c372" translate="yes" xml:space="preserve">
          <source>A new route</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6884c72d6fc3447702cd7e913579b82af22ac1e6" translate="yes" xml:space="preserve">
          <source>A newly generated Phoenix app will have a single controller, the &lt;code&gt;PageController&lt;/code&gt;, which can be found at &lt;code&gt;lib/hello_web/controllers/page_controller.ex&lt;/code&gt; and looks like this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16c226a26e1ad46c351166c932b41f1d8b22e2f6" translate="yes" xml:space="preserve">
          <source>A newly generated Phoenix application has three view modules - &lt;code&gt;ErrorView&lt;/code&gt;, &lt;code&gt;LayoutView&lt;/code&gt;, and &lt;code&gt;PageView&lt;/code&gt; - which are all in the, &lt;code&gt;lib/hello_web/views&lt;/code&gt; directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4048094f5a6bb946c03a21815ec3a451989dff82" translate="yes" xml:space="preserve">
          <source>A note about &lt;a href=&quot;ecto&quot;&gt;Ecto&lt;/a&gt;: Ecto allows our Phoenix application to communicate with a data store, such as PostgreSQL, MySQL, and others. If our application will not require this component we can skip this dependency by passing the &lt;code&gt;--no-ecto&lt;/code&gt; flag to &lt;a href=&quot;mix.tasks.phx.new&quot;&gt;&lt;code&gt;mix phx.new&lt;/code&gt;&lt;/a&gt;. This flag may also be combined with &lt;code&gt;--no-webpack&lt;/code&gt; to create a skeleton application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="342e293abf9ffaccbc624dc414e0fbdda464fb47" translate="yes" xml:space="preserve">
          <source>A note about &lt;a href=&quot;https://webpack.js.org/&quot;&gt;webpack&lt;/a&gt; before we begin: Phoenix will use webpack for asset management by default. Webpack's dependencies are installed via the node package manager, not mix. Phoenix will prompt us to install them at the end of the &lt;a href=&quot;mix.tasks.phx.new&quot;&gt;&lt;code&gt;mix phx.new&lt;/code&gt;&lt;/a&gt; task. If we say &quot;no&quot; at that point, and if we don't install those dependencies later with &lt;code&gt;npm install&lt;/code&gt;, our application will raise errors when we try to start it, and our assets may not load properly. If we don't want to use webpack at all, we can simply pass &lt;code&gt;--no-webpack&lt;/code&gt; to &lt;a href=&quot;mix.tasks.phx.new&quot;&gt;&lt;code&gt;mix phx.new&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c6f9a6dd1d438af7a0c3c1923a719b2d5b36b31" translate="yes" xml:space="preserve">
          <source>A note about Erlang and Phoenix: while Phoenix itself only requires Erlang 20 or later, one of Phoenix's dependencies, &lt;a href=&quot;https://github.com/ninenines/cowboy&quot;&gt;cowboy&lt;/a&gt;, depends on Erlang 22 or later since cowboy 2.8.0. It is recommended to either install Erlang 22 or add &lt;code&gt;{:cowboy, &quot;~&amp;gt; 2.7.0&quot;}&lt;/code&gt; to your mix.exs once your app has been created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9e5ef5ae95a7e3c031bedf9b8401adb9938c8ce" translate="yes" xml:space="preserve">
          <source>A note on &lt;code&gt;:errors&lt;/code&gt;</source>
          <target state="translated">关于 &lt;code&gt;:errors&lt;/code&gt; 的注释</target>
        </trans-unit>
        <trans-unit id="a57d03ff9e283e3ddf26983d0193c0170612bd7a" translate="yes" xml:space="preserve">
          <source>A note on hot code reloading: Some editors with their automatic linters may prevent hot code reloading from working. If it's not working for you, please see the discussion in &lt;a href=&quot;https://github.com/phoenixframework/phoenix/issues/1165&quot;&gt;this issue&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="247b0c48eb92d7683ad37a2e4faf194583434289" translate="yes" xml:space="preserve">
          <source>A plug and module to handle automatic code reloading.</source>
          <target state="translated">一个处理自动代码重装的插件和模块。</target>
        </trans-unit>
        <trans-unit id="a3bfffaf045864dc467604253ad832210e0baa2d" translate="yes" xml:space="preserve">
          <source>A plug for generating a unique request id for each request.</source>
          <target state="translated">一个为每个请求生成唯一请求ID的插件。</target>
        </trans-unit>
        <trans-unit id="6446fa6bdbded8c6574e97c1eed133777cab6564" translate="yes" xml:space="preserve">
          <source>A plug for logging basic request information in the format:</source>
          <target state="translated">一个用于记录基本请求信息的插件,格式为:。</target>
        </trans-unit>
        <trans-unit id="c8c318dc543ea007fb59d22f6b41bb1242501ed2" translate="yes" xml:space="preserve">
          <source>A plug for parsing the request body.</source>
          <target state="translated">一个解析请求体的插件。</target>
        </trans-unit>
        <trans-unit id="2e570b41fcca81d0056177ea2ef5b9015a670923" translate="yes" xml:space="preserve">
          <source>A plug for serving static assets.</source>
          <target state="translated">一个用于服务静态资产的插件。</target>
        </trans-unit>
        <trans-unit id="fa0549f72da9c53f30cb36c6df15f5ac9aabf768" translate="yes" xml:space="preserve">
          <source>A plug pipeline can be halted with &lt;a href=&quot;plug.conn#halt/1&quot;&gt;&lt;code&gt;Plug.Conn.halt/1&lt;/code&gt;&lt;/a&gt;. The builder will prevent further plugs downstream from being invoked and return the current connection. In the following example, the &lt;a href=&quot;plug.logger&quot;&gt;&lt;code&gt;Plug.Logger&lt;/code&gt;&lt;/a&gt; plug never gets called:</source>
          <target state="translated">可以使用&lt;a href=&quot;plug.conn#halt/1&quot;&gt; &lt;code&gt;Plug.Conn.halt/1&lt;/code&gt; &lt;/a&gt;停止插入管道。构建器将阻止进一步的下游插件被调用并返回当前连接。在以下示例中，从未调用&lt;a href=&quot;plug.logger&quot;&gt; &lt;code&gt;Plug.Logger&lt;/code&gt; &lt;/a&gt;插件：</target>
        </trans-unit>
        <trans-unit id="1886091b6bf7d12212133283469ad01791c28906" translate="yes" xml:space="preserve">
          <source>A plug that may convert a JSON response into a JSONP one</source>
          <target state="translated">一个可以将JSON响应转换为JSONP的插件。</target>
        </trans-unit>
        <trans-unit id="27cc908ac178d8d6210d66299d0d2aa753f4c446" translate="yes" xml:space="preserve">
          <source>A plug that may convert a JSON response into a JSONP one.</source>
          <target state="translated">一个可以将JSON响应转换为JSONP响应的插件。</target>
        </trans-unit>
        <trans-unit id="d140e1ea5763f3091fa07f469fc491efe441881f" translate="yes" xml:space="preserve">
          <source>A plug to force SSL connections and enable HSTS.</source>
          <target state="translated">一个强制SSL连接和启用HSTS的插件。</target>
        </trans-unit>
        <trans-unit id="7067fa076310914c5a187337eb8e079351e6240a" translate="yes" xml:space="preserve">
          <source>A plug to force SSL connections.</source>
          <target state="translated">一个强制SSL连接的插件。</target>
        </trans-unit>
        <trans-unit id="602566e61299332b20ef3537013b8af7450cd0d2" translate="yes" xml:space="preserve">
          <source>A plug to handle session cookies and session stores.</source>
          <target state="translated">一个处理会话cookies和会话存储的插件。</target>
        </trans-unit>
        <trans-unit id="8471dd87a69a9fbbd3f9a4c22829ffc8050ef8ee" translate="yes" xml:space="preserve">
          <source>A plug to instrument the pipeline with &lt;code&gt;:telemetry&lt;/code&gt; events.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fc44f87aaffe938c4a1ae5d714f1c364e1ed200" translate="yes" xml:space="preserve">
          <source>A plug to rewrite the request's host/port/protocol from &lt;code&gt;x-forwarded-*&lt;/code&gt; headers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="590c592f611c77a032618a2af7a44e9550877726" translate="yes" xml:space="preserve">
          <source>A possible implementation would be to load the user on the &lt;a href=&quot;#c:update/2&quot;&gt;&lt;code&gt;update/2&lt;/code&gt;&lt;/a&gt; callback:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a113601eea84699381389fc145edb16d078c8038" translate="yes" xml:space="preserve">
          <source>A prefix can be specified for a subquery, similar to standard repo operations:</source>
          <target state="translated">可以为一个子查询指定一个前缀,类似于标准的repo操作。</target>
        </trans-unit>
        <trans-unit id="da6161e51728ffed7549eff7d59573edeb482aec" translate="yes" xml:space="preserve">
          <source>A process may be tracked multiple times, provided the topic and key pair are unique for any prior calls for the given process.</source>
          <target state="translated">一个进程可以被多次跟踪,只要主题和密钥对之前对该进程的任何调用都是唯一的。</target>
        </trans-unit>
        <trans-unit id="ecd7cda5bcf7d72985a664f3c9340020d656a7d1" translate="yes" xml:space="preserve">
          <source>A process may be tracked multipled times, provided the topic and key pair are unique for any prior calls for the given process.</source>
          <target state="translated">一个进程可以被多次跟踪,但前提是主题和密钥对对于给定进程的任何先前调用都是唯一的。</target>
        </trans-unit>
        <trans-unit id="d6fce133c9e9afd0fc76959bbab1a15ebc56c715" translate="yes" xml:space="preserve">
          <source>A product matches in the above example if a line item was created since the provided date where the customer purchased at least 10 units.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a15dac21b7bcee2c91dfe8f35a5617aa5f6ee9e6" translate="yes" xml:space="preserve">
          <source>A project at the given APP directory will be created. The application name and module name will be retrieved from the application name, unless &lt;code&gt;--module&lt;/code&gt; or &lt;code&gt;--app&lt;/code&gt; is given.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b7c7e3dbab6f551e809bcd37eae034f6b3551ed" translate="yes" xml:space="preserve">
          <source>A project at the given PATH will be created. The application name and module name will be retrieved from the path, unless &lt;code&gt;--module&lt;/code&gt; or &lt;code&gt;--app&lt;/code&gt; is given.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb11d08c12532805958b64aa7f5232d9f8361526" translate="yes" xml:space="preserve">
          <source>A protocol that converts data structures into URL parameters.</source>
          <target state="translated">一个将数据结构转换为URL参数的协议。</target>
        </trans-unit>
        <trans-unit id="a810227ea598a60f15fb0d07a9b08121f6023fee" translate="yes" xml:space="preserve">
          <source>A protocol that extends exceptions to be status-code aware.</source>
          <target state="translated">一个将异常扩展为状态码感知的协议。</target>
        </trans-unit>
        <trans-unit id="9b55f92a72a93f9b4051d36f398e4e4e4e15aa6c" translate="yes" xml:space="preserve">
          <source>A query can also be given instead of a schema, both for the join_through and the destination. Querying, joining or preloading the association will use the given query. Currently only where clauses can be provided in queries. Let&amp;rsquo;s see an example:</source>
          <target state="translated">对于join_through和目标，也可以提供查询而不是模式。查询，加入或预加载关联将使用给定的查询。当前仅在查询中可以提供where子句。让我们来看一个例子：</target>
        </trans-unit>
        <trans-unit id="57b3d5d222f71f480afb39c6c01de765a7a9d056" translate="yes" xml:space="preserve">
          <source>A query can also be given instead of a schema. Querying, joining or preloading the association will use the given query. Currently only where clauses can be provided in queries. Let&amp;rsquo;s see an example:</source>
          <target state="translated">也可以给出查询而不是模式。查询，加入或预加载关联将使用给定的查询。当前仅在查询中可以提供where子句。让我们来看一个例子：</target>
        </trans-unit>
        <trans-unit id="fa830660e15cdaa4dc6eab8c330789488fe7bf9d" translate="yes" xml:space="preserve">
          <source>A query can also be given instead of a schema. Querying, joining or preloading the association will use the given query. Currently only where clauses can be provided in queries. Let&amp;rsquo;s see some examples:</source>
          <target state="translated">也可以给出查询而不是模式。查询，加入或预加载关联将使用给定的查询。当前仅在查询中可以提供where子句。让我们看一些例子：</target>
        </trans-unit>
        <trans-unit id="6c16c5a7a0e6e3bd5d7267cbb006505cc93761f6" translate="yes" xml:space="preserve">
          <source>A raw binary representation of a UUID</source>
          <target state="translated">UUID的原始二进制表示。</target>
        </trans-unit>
        <trans-unit id="f6365cf3f64e3ca89e5511ac308a4440b906f106" translate="yes" xml:space="preserve">
          <source>A raw binary representation of a UUID.</source>
          <target state="translated">UUID的原始二进制表示。</target>
        </trans-unit>
        <trans-unit id="17d99d2006e78017bdc0cb317ef24f2c49c0675d" translate="yes" xml:space="preserve">
          <source>A repository maps to an underlying data store, controlled by the adapter. For example, Ecto ships with a Postgres adapter that stores data into a PostgreSQL database.</source>
          <target state="translated">存储库映射到底层数据存储,由适配器控制。例如,Ecto提供了一个Postgres适配器,将数据存储到PostgreSQL数据库中。</target>
        </trans-unit>
        <trans-unit id="cd4bdfc36fdfdd2bc045633b2cc0a5938d44cd56" translate="yes" xml:space="preserve">
          <source>A route can also specify parameters which will then be available in the function body:</source>
          <target state="translated">途径还可以指定参数,这些参数将在函数体中可用。</target>
        </trans-unit>
        <trans-unit id="be5953e95ef0d7bf21d698beeb476b75a6419062" translate="yes" xml:space="preserve">
          <source>A route should specify only one of &lt;code&gt;:do&lt;/code&gt; or &lt;code&gt;:to&lt;/code&gt; options.</source>
          <target state="translated">路由应仅指定 &lt;code&gt;:do&lt;/code&gt; 或 &lt;code&gt;:to&lt;/code&gt; 选项之一。</target>
        </trans-unit>
        <trans-unit id="c8be751a044d822045b1eaba342f9baa71ee2a42" translate="yes" xml:space="preserve">
          <source>A scope may then use this pipeline as:</source>
          <target state="translated">然后,一个范围可以使用这个管道作为。</target>
        </trans-unit>
        <trans-unit id="64707c17a82fafbfa181761a4306f357e5402b6f" translate="yes" xml:space="preserve">
          <source>A select query expression</source>
          <target state="translated">一个选择查询表达式</target>
        </trans-unit>
        <trans-unit id="52159915deda5630e0d675da42a0327fd8ad0a83" translate="yes" xml:space="preserve">
          <source>A select query expression.</source>
          <target state="translated">一个选择查询表达式。</target>
        </trans-unit>
        <trans-unit id="d15a1414e1dabc4b77e0578af24e25bba1b64638" translate="yes" xml:space="preserve">
          <source>A server (a &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; specifically) that manages uploaded files.</source>
          <target state="translated">一台服务器（专门用于&lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;），用于管理上载的文件。</target>
        </trans-unit>
        <trans-unit id="5eb2282eff957c7edee6fbf213e15ead022d6693" translate="yes" xml:space="preserve">
          <source>A shortcut for &lt;code&gt;form_for(changeset, url, [])&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="679ddb5ec5c04f2352ccd686eb689981aa0578a3" translate="yes" xml:space="preserve">
          <source>A shortcut that renders the given template in the given view</source>
          <target state="translated">在给定视图中渲染给定模板的快捷方式。</target>
        </trans-unit>
        <trans-unit id="360b1f0139a93d8cac8e04f96457dacccd4755ad" translate="yes" xml:space="preserve">
          <source>A shortcut that renders the given template in the given view.</source>
          <target state="translated">一个在给定视图中渲染给定模板的快捷方式。</target>
        </trans-unit>
        <trans-unit id="a3bd2deed4cd1a4e3f23be9ce997e4465341c885" translate="yes" xml:space="preserve">
          <source>A single key value pair may be passed, a keyword list or map of assigns may be provided to be merged into existing socket assigns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="281877018fb4680e1f3e3563380eab9840f150e5" translate="yes" xml:space="preserve">
          <source>A single key value pair may be passed, or a keyword list or a map of assigns may be provided to be merged into existing socket assigns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="203df8270968063b9a7a2981211a19746083887a" translate="yes" xml:space="preserve">
          <source>A socket implementation that multiplexes messages over channels.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6ceabc6982edc10020bcc03fa4510f767f1ce7d" translate="yes" xml:space="preserve">
          <source>A stateful component is a component that receives an &lt;code&gt;:id&lt;/code&gt; on &lt;code&gt;live_component/3&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6653d758e2b31f0c35929242f95f2ed71bb3c02" translate="yes" xml:space="preserve">
          <source>A stateless component is always mounted, updated, and rendered whenever the parent template changes. That's why they are stateless: no state is kept after the component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aeeadfaeb332d1926c6944d870d58481661e7138" translate="yes" xml:space="preserve">
          <source>A step beyond this is rendering pure JSON with the &lt;code&gt;json/2&lt;/code&gt; function. We need to pass it something that the &lt;a href=&quot;https://github.com/michalmuskala/jason&quot;&gt;Jason library&lt;/a&gt; can decode into JSON, such as a map. (Jason is one of Phoenix's dependencies.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4fdf6155a375fda05bd4126f4ac1b93d003da78" translate="yes" xml:space="preserve">
          <source>A struct representing subqueries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f89fcb81d2ce506035c4ee187c02c8467c2a257" translate="yes" xml:space="preserve">
          <source>A struct used as default on unfetched fields.</source>
          <target state="translated">一个结构,作为默认情况下对未提取的字段使用。</target>
        </trans-unit>
        <trans-unit id="1f61bdf60f93bab8b9e6b0fb5866d4197adbd5c1" translate="yes" xml:space="preserve">
          <source>A successful transaction returns the value returned by the function wrapped in a tuple as &lt;code&gt;{:ok, value}&lt;/code&gt;.</source>
          <target state="translated">成功的事务返回由包装在元组中的函数返回的值，例如 &lt;code&gt;{:ok, value}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ad64c20203140b06d2f22b694f40b5efa96b9519" translate="yes" xml:space="preserve">
          <source>A telemetry &lt;code&gt;:metadata&lt;/code&gt; map including the following fields. Each database adapter may emit different information here. For Ecto.SQL databases, it will look like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dc4724ee93112728013257157e88358eda90382" translate="yes" xml:space="preserve">
          <source>A template file has the following structure: &lt;code&gt;NAME.FORMAT.TEMPLATING_LANGUAGE&lt;/code&gt;. In our case, we will create a &quot;index.html.eex&quot; file at &quot;lib/hello_web/templates/hello/index.html.eex&quot;. &quot;.eex&quot; stands for &lt;a href=&quot;https://hexdocs.pm/eex/EEx.html&quot;&gt;&lt;code&gt;EEx&lt;/code&gt;&lt;/a&gt;, which is a library for embedding Elixir that ships as part of Elixir itself. Phoenix enhances EEx to include automatic escaping of values. This protects you from security vulnerabilities like Cross-Site-Scripting with no extra work on your part.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3a3f96eb8d57f2d8f5d346f69678cc061505ef5" translate="yes" xml:space="preserve">
          <source>A template has a name, which also contains a format. For example, in the previous section we have rendered the &quot;index.html&quot; template:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ddd2b27cf9e32e87fad09c73b095d8e9c8a4457" translate="yes" xml:space="preserve">
          <source>A template has a name, which also contains a format. For example, in the previous section we have rendered the &amp;ldquo;index.html&amp;rdquo; template:</source>
          <target state="translated">模板具有名称，其中还包含格式。例如，在上一节中，我们呈现了&amp;ldquo; index.html&amp;rdquo;模板：</target>
        </trans-unit>
        <trans-unit id="b87af6c93e951760a8f8005aa61e60d4437a4d31" translate="yes" xml:space="preserve">
          <source>A template rendered inside a component can use &lt;code&gt;live_patch&lt;/code&gt; and &lt;code&gt;live_redirect&lt;/code&gt; calls. The &lt;code&gt;live_patch&lt;/code&gt; is always handled by the parent &lt;code&gt;LiveView&lt;/code&gt;, as components do not provide &lt;code&gt;handle_params&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e660c6a6ee5d0e8ffddf28c0fa00526d5a8e3c6" translate="yes" xml:space="preserve">
          <source>A transport is responsible for:</source>
          <target state="translated">某运输公司负责:</target>
        </trans-unit>
        <trans-unit id="946470e01e91e9929c4d53bc6f328c1d76bbc84a" translate="yes" xml:space="preserve">
          <source>A typical example is calling &lt;code&gt;MyRepo.insert/1&lt;/code&gt; with a struct and acting on the return value:</source>
          <target state="translated">一个典型的示例是使用结构调用 &lt;code&gt;MyRepo.insert/1&lt;/code&gt; 并作用于返回值：</target>
        </trans-unit>
        <trans-unit id="cb5d317cfc71e83a7571c5f18c2490db22159483" translate="yes" xml:space="preserve">
          <source>A union all query expression</source>
          <target state="translated">一个联合所有的查询表达式</target>
        </trans-unit>
        <trans-unit id="25362305321b57a805c92a0acf72bc0d06d1a7dc" translate="yes" xml:space="preserve">
          <source>A union all query expression.</source>
          <target state="translated">一个联合所有的查询表达式。</target>
        </trans-unit>
        <trans-unit id="d5b99cd9b0922c56851d9e0469e48511c48aeeee" translate="yes" xml:space="preserve">
          <source>A union query expression</source>
          <target state="translated">联合查询表达式</target>
        </trans-unit>
        <trans-unit id="4a920618e68127f219a3396142a47a00705a7fad" translate="yes" xml:space="preserve">
          <source>A union query expression.</source>
          <target state="translated">一个联合查询表达式。</target>
        </trans-unit>
        <trans-unit id="679419f70975d183c742f7e11403ca44939004d4" translate="yes" xml:space="preserve">
          <source>A user customizable callback invoked for query-based operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44888c14caef36bb9c69024eae824ef0f11b9228" translate="yes" xml:space="preserve">
          <source>A user customizable callback invoked to retrieve default options for operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70b82fdaa5a10d034891a006719cc0e0a60994bc" translate="yes" xml:space="preserve">
          <source>A valid certificate and associated private key</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd7c2aef5660b74e939eea17604c8c896f7fa67b" translate="yes" xml:space="preserve">
          <source>API for building transports.</source>
          <target state="translated">构建运输的API。</target>
        </trans-unit>
        <trans-unit id="86e6e8774db247384ff44f8f11bcef9d757da165" translate="yes" xml:space="preserve">
          <source>API for exporting a webserver.</source>
          <target state="translated">用于导出网络服务器的API。</target>
        </trans-unit>
        <trans-unit id="ed58cd8a2d9a5daa39ac65e4c3c4492641a76fb5" translate="yes" xml:space="preserve">
          <source>API used by Plug to invoke the code reloader on every request</source>
          <target state="translated">Plug在每次请求时调用代码重载器的API。</target>
        </trans-unit>
        <trans-unit id="4542405f0cabd3872e11baabdbce2401445cdbd7" translate="yes" xml:space="preserve">
          <source>API used by Plug to invoke the code reloader on every request.</source>
          <target state="translated">Plug在每次请求时调用代码重载器的API。</target>
        </trans-unit>
        <trans-unit id="b79e3df9bbb0579360a4e4a0a03f1496f2475c10" translate="yes" xml:space="preserve">
          <source>API used by Plug to start the code reloader</source>
          <target state="translated">Plug用来启动代码重载器的API。</target>
        </trans-unit>
        <trans-unit id="7396c45721b461084efb7c8093672b44804d5ca9" translate="yes" xml:space="preserve">
          <source>API used by Plug to start the code reloader.</source>
          <target state="translated">Plug用来启动代码重载器的API。</target>
        </trans-unit>
        <trans-unit id="70229b697d877c060248372885d62cc0b19c248b" translate="yes" xml:space="preserve">
          <source>ASC columns become DESC columns (and vice-versa). If the query has no order_bys, it orders by the inverse of the primary key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89ef021e223e176e371690ff7d78917f2535be99" translate="yes" xml:space="preserve">
          <source>About the arithmetic operators</source>
          <target state="translated">关于算术运算符</target>
        </trans-unit>
        <trans-unit id="1adb4622e0cea24e2bb59e45a0fa949aa9cd4487" translate="yes" xml:space="preserve">
          <source>Accepts the module name for the channel</source>
          <target state="translated">接受通道的模块名称</target>
        </trans-unit>
        <trans-unit id="9ea67e607d24763f974e3d47b4034a46471d7ec5" translate="yes" xml:space="preserve">
          <source>Accepts the same arguments and options as &lt;a href=&quot;ecto.repo#c:delete/2&quot;&gt;&lt;code&gt;Ecto.Repo.delete/2&lt;/code&gt;&lt;/a&gt; does.</source>
          <target state="translated">接受与&lt;a href=&quot;ecto.repo#c:delete/2&quot;&gt; &lt;code&gt;Ecto.Repo.delete/2&lt;/code&gt; &lt;/a&gt;相同的参数和选项。</target>
        </trans-unit>
        <trans-unit id="789dafed93ccbf4c05b49e24fc1da0571474c267" translate="yes" xml:space="preserve">
          <source>Accepts the same arguments and options as &lt;a href=&quot;ecto.repo#c:delete_all/2&quot;&gt;&lt;code&gt;Ecto.Repo.delete_all/2&lt;/code&gt;&lt;/a&gt; does.</source>
          <target state="translated">接受与&lt;a href=&quot;ecto.repo#c:delete_all/2&quot;&gt; &lt;code&gt;Ecto.Repo.delete_all/2&lt;/code&gt; &lt;/a&gt;相同的参数和选项。</target>
        </trans-unit>
        <trans-unit id="8c9553ee56bf0e31f097af5dc4f874d1c0bb310b" translate="yes" xml:space="preserve">
          <source>Accepts the same arguments and options as &lt;a href=&quot;ecto.repo#c:insert/2&quot;&gt;&lt;code&gt;Ecto.Repo.insert/2&lt;/code&gt;&lt;/a&gt; does.</source>
          <target state="translated">接受与&lt;a href=&quot;ecto.repo#c:insert/2&quot;&gt; &lt;code&gt;Ecto.Repo.insert/2&lt;/code&gt; &lt;/a&gt;相同的参数和选项。</target>
        </trans-unit>
        <trans-unit id="c752d4234a4cb721c1653ecd6f90b58c69994dcd" translate="yes" xml:space="preserve">
          <source>Accepts the same arguments and options as &lt;a href=&quot;ecto.repo#c:insert_all/3&quot;&gt;&lt;code&gt;Ecto.Repo.insert_all/3&lt;/code&gt;&lt;/a&gt; does.</source>
          <target state="translated">接受与&lt;a href=&quot;ecto.repo#c:insert_all/3&quot;&gt; &lt;code&gt;Ecto.Repo.insert_all/3&lt;/code&gt; &lt;/a&gt;相同的参数和选项。</target>
        </trans-unit>
        <trans-unit id="b6480d325c63afe5877a0e30d3f5c75205c3ad50" translate="yes" xml:space="preserve">
          <source>Accepts the same arguments and options as &lt;a href=&quot;ecto.repo#c:insert_or_update/2&quot;&gt;&lt;code&gt;Ecto.Repo.insert_or_update/2&lt;/code&gt;&lt;/a&gt; does.</source>
          <target state="translated">接受与&lt;a href=&quot;ecto.repo#c:insert_or_update/2&quot;&gt; &lt;code&gt;Ecto.Repo.insert_or_update/2&lt;/code&gt; &lt;/a&gt;相同的参数和选项。</target>
        </trans-unit>
        <trans-unit id="8614a768a0a859c086c15abf0c73d40064b5fd00" translate="yes" xml:space="preserve">
          <source>Accepts the same arguments and options as &lt;a href=&quot;ecto.repo#c:update/2&quot;&gt;&lt;code&gt;Ecto.Repo.update/2&lt;/code&gt;&lt;/a&gt; does.</source>
          <target state="translated">接受与&lt;a href=&quot;ecto.repo#c:update/2&quot;&gt; &lt;code&gt;Ecto.Repo.update/2&lt;/code&gt; &lt;/a&gt;相同的参数和选项。</target>
        </trans-unit>
        <trans-unit id="1bc7635d2d0b3f661ed3f03cc2b0aef2100ccbd1" translate="yes" xml:space="preserve">
          <source>Accepts the same arguments and options as &lt;a href=&quot;ecto.repo#c:update_all/3&quot;&gt;&lt;code&gt;Ecto.Repo.update_all/3&lt;/code&gt;&lt;/a&gt; does.</source>
          <target state="translated">接受与&lt;a href=&quot;ecto.repo#c:update_all/3&quot;&gt; &lt;code&gt;Ecto.Repo.update_all/3&lt;/code&gt; &lt;/a&gt;相同的参数和选项。</target>
        </trans-unit>
        <trans-unit id="5950487ce2abf21dfb3acc6f897accc6cb91d221" translate="yes" xml:space="preserve">
          <source>Accepts the same command line options as &lt;code&gt;archive.install hex phx_new&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adf777534a81a3c2426b5193f04a57a4b66913e5" translate="yes" xml:space="preserve">
          <source>Access the endpoint configuration given by key</source>
          <target state="translated">访问由钥匙给出的端点配置</target>
        </trans-unit>
        <trans-unit id="7b547055b41922089c3f74a93f478751d56aeb74" translate="yes" xml:space="preserve">
          <source>Access the endpoint configuration given by key.</source>
          <target state="translated">访问键所给的端点配置。</target>
        </trans-unit>
        <trans-unit id="81fae5657d85417ee15ec92ce63c4c0103a12a5b" translate="yes" xml:space="preserve">
          <source>Accesses the connect info from the socket to use on connected mount.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7652d1e0348eb900dba83366501f144c1dbfefb5" translate="yes" xml:space="preserve">
          <source>Accesses the connect params sent by the client for use on connected mount.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a4a92cf9a0b562797569d10e9e6816e10751772" translate="yes" xml:space="preserve">
          <source>According to the SQL standard it affects all CTEs in the query, not individual ones.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db4130792628ddb7da8b596a88089ecd9ac10945" translate="yes" xml:space="preserve">
          <source>Action Fallback</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cc7108ee58aa53d3b12f9e7023ebf5b27bb71f5" translate="yes" xml:space="preserve">
          <source>Action Fallback allows us to centralize error handling code in plugs which are called when a controller action fails to return a &lt;code&gt;%Plug.Conn{}&lt;/code&gt; struct. These plugs receive both the &lt;code&gt;conn&lt;/code&gt; which was originally passed to the controller action along with the return value of the action.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca491b8098405012c835e8927dd9ce64ef76acc0" translate="yes" xml:space="preserve">
          <source>Actionable Errors</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3cd636a585b20c40ac2df5ffb403e83cb2eef51" translate="yes" xml:space="preserve">
          <source>Actions</source>
          <target state="translated">Actions</target>
        </trans-unit>
        <trans-unit id="b263592eb8439a9f7f436a2911c2b555ca40cdcc" translate="yes" xml:space="preserve">
          <source>Actions and live navigation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fd09e68bf55b280210825b15b236e9e13c1e3cf" translate="yes" xml:space="preserve">
          <source>Adapter configuration</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3287c69d8ddb53d15fe6cf2d9da75fd606c69c5d" translate="yes" xml:space="preserve">
          <source>Adapter-specific events</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e07a4acdd5cdd3ab645fd0d90270662d13ac1718" translate="yes" xml:space="preserve">
          <source>Adapters</source>
          <target state="translated">Adapters</target>
        </trans-unit>
        <trans-unit id="7617cde4f91c3e1cfebf93bcdb04619e2cac150e" translate="yes" xml:space="preserve">
          <source>Add LiveView NPM dependencies to your &lt;code&gt;assets/package.json&lt;/code&gt;. For a regular project, do:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57ac10db42fa6a0dcda32f077ad04482a86c9281" translate="yes" xml:space="preserve">
          <source>Add the following private function to your Telemetry module to lift the &lt;code&gt;:method&lt;/code&gt; value from the &lt;a href=&quot;../plug/plug.conn&quot;&gt;&lt;code&gt;Plug.Conn&lt;/code&gt;&lt;/a&gt; struct:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7e559fadb1d3b3cb4b5f949ab9c4a18973eab8f" translate="yes" xml:space="preserve">
          <source>Add the following to the list in your Telemetry supervisor's &lt;code&gt;periodic_measurements/0&lt;/code&gt; function, which is a private function that returns a list of measurements to take on a specified interval.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7784ef3802e7b67bed0bf4318177efcf145c0392" translate="yes" xml:space="preserve">
          <source>Add the resulting file to your application&amp;rsquo;s &lt;code&gt;priv&lt;/code&gt; directory and pass the path using the &lt;code&gt;:dhfile&lt;/code&gt; key. It is best practice to rotate the file periodically.</source>
          <target state="translated">将结果文件添加到应用程序的 &lt;code&gt;priv&lt;/code&gt; 目录中，然后使用 &lt;code&gt;:dhfile&lt;/code&gt; 键传递路径。最佳做法是定期旋转文件。</target>
        </trans-unit>
        <trans-unit id="0e8440557f2a0d433179d94e6804cfc69e836a1c" translate="yes" xml:space="preserve">
          <source>Adding Account functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c43c6cb1972e14253bb3b093d2ecce3b5ea8e551" translate="yes" xml:space="preserve">
          <source>Adding CMS functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b75b9f09dd7f1c4f62971b222b73c1de85d0d0b" translate="yes" xml:space="preserve">
          <source>Adding a new page</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d76d5b975035c940f1eedd666a63b0716ce4514a" translate="yes" xml:space="preserve">
          <source>Adding an Accounts Context</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f55dbe5531ad6865c67ed95836c2557b5aeb8ba" translate="yes" xml:space="preserve">
          <source>Adding and removal of embeds can only be done via the &lt;a href=&quot;ecto.changeset&quot;&gt;&lt;code&gt;Ecto.Changeset&lt;/code&gt;&lt;/a&gt; API so Ecto can properly track the embed life-cycle:</source>
          <target state="translated">只能通过&lt;a href=&quot;ecto.changeset&quot;&gt; &lt;code&gt;Ecto.Changeset&lt;/code&gt; &lt;/a&gt; API 完成嵌入的添加和删除，因此Ecto可以正确跟踪嵌入的生命周期：</target>
        </trans-unit>
        <trans-unit id="e54b958439b49e646480d341aff1a59341fcaef9" translate="yes" xml:space="preserve">
          <source>Additional Telemetry events are executed by Ecto adapters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f67e21d45717d2e7d5f6b8d4a9516ab30653948c" translate="yes" xml:space="preserve">
          <source>Additional options can be given to the session store, see the store&amp;rsquo;s documentation for the options it accepts.</source>
          <target state="translated">可以为会话存储提供其他选项，有关其接受的选项，请参见存储的文档。</target>
        </trans-unit>
        <trans-unit id="5cec8513a17ee4ace1a1b38c87e62e48714bde0d" translate="yes" xml:space="preserve">
          <source>Additional options can be given to the session store, see the store's documentation for the options it accepts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae72c3e10c537af193c1abb9885797bdd492a3bb" translate="yes" xml:space="preserve">
          <source>Additional options can be set by selecting a predefined profile or by setting &lt;code&gt;:ssl&lt;/code&gt; options individually.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a6f7fc13964d1c28a7b6f4385efa1513289c0ae" translate="yes" xml:space="preserve">
          <source>Additionally, the right side may also be a subquery:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5633402537e80588fb2bf8033dabfd8b24d78124" translate="yes" xml:space="preserve">
          <source>Additionally, we strongly recommend including a unique HTML &quot;id&quot; attribute on the form. When DOM siblings change, elements without an ID will be replaced rather than moved, which can cause issues such as form fields losing focus.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b46698b76037699bcd1a6db8f4d893bf0a0f099e" translate="yes" xml:space="preserve">
          <source>Adds a delete operation to the multi</source>
          <target state="translated">为多用户添加一个删除操作。</target>
        </trans-unit>
        <trans-unit id="9ee3d694f5156d312afd606d349abf63df55f685" translate="yes" xml:space="preserve">
          <source>Adds a delete operation to the multi.</source>
          <target state="translated">给多人添加删除操作。</target>
        </trans-unit>
        <trans-unit id="769fbcf8531ada2965f956c88b8bab5fa2107391" translate="yes" xml:space="preserve">
          <source>Adds a delete_all operation to the multi</source>
          <target state="translated">为多用户添加一个delete_all操作。</target>
        </trans-unit>
        <trans-unit id="cbe4492b83cbb0046f04cfc470e840e81af8e8f2" translate="yes" xml:space="preserve">
          <source>Adds a delete_all operation to the multi.</source>
          <target state="translated">给多人组添加一个delete_all操作。</target>
        </trans-unit>
        <trans-unit id="5fef906b63f89a8348bcb81845ee544aab475f05" translate="yes" xml:space="preserve">
          <source>Adds a flash message to the socket to be displayed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58349070033bbd9b9269bd6e6931b771e8a71bc2" translate="yes" xml:space="preserve">
          <source>Adds a function to run as part of the multi</source>
          <target state="translated">添加了一个函数,作为多机版的一部分运行。</target>
        </trans-unit>
        <trans-unit id="1bec869c3e831e0a6c85e17cba5a4af86ccc6ec3" translate="yes" xml:space="preserve">
          <source>Adds a function to run as part of the multi.</source>
          <target state="translated">添加一个函数,作为多函数的一部分运行。</target>
        </trans-unit>
        <trans-unit id="34e192fedbb4eabab58579f23b6132b3af1a3750" translate="yes" xml:space="preserve">
          <source>Adds a given interval to a date</source>
          <target state="translated">在日期上添加一个给定的间隔。</target>
        </trans-unit>
        <trans-unit id="6d007da43a8bd9b39162829b023c276b326e5dbc" translate="yes" xml:space="preserve">
          <source>Adds a given interval to a date.</source>
          <target state="translated">在日期上添加一个给定的间隔。</target>
        </trans-unit>
        <trans-unit id="194676ec87039fc824f39013dabad1414b7f21a3" translate="yes" xml:space="preserve">
          <source>Adds a given interval to a datetime</source>
          <target state="translated">将指定的时间间隔添加到日期时间中。</target>
        </trans-unit>
        <trans-unit id="ed19d9c7db347a5112a39c5dddd3a119f1642683" translate="yes" xml:space="preserve">
          <source>Adds a given interval to a datetime.</source>
          <target state="translated">给日期时间添加一个给定的时间间隔。</target>
        </trans-unit>
        <trans-unit id="f176eb799f6d0e21b8db3090cb17b0b1910d9fd4" translate="yes" xml:space="preserve">
          <source>Adds a new element to the set</source>
          <target state="translated">在集合中添加一个新元素</target>
        </trans-unit>
        <trans-unit id="cea99954f15fe72a878575aafe645073a0bcb4b1" translate="yes" xml:space="preserve">
          <source>Adds a new element to the set.</source>
          <target state="translated">在集合中添加一个新元素。</target>
        </trans-unit>
        <trans-unit id="5137472dd63745ac60a833c182654bc64ff4bd48" translate="yes" xml:space="preserve">
          <source>Adds a new request header (&lt;code&gt;key&lt;/code&gt;) if not present, otherwise replaces the previous value of that header with &lt;code&gt;value&lt;/code&gt;</source>
          <target state="translated">添加一个新的请求标头（ &lt;code&gt;key&lt;/code&gt; ）（如果不存在），否则将该标头的先前值替换为 &lt;code&gt;value&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0c4e9e3bae320c79d590690ad5143c1c8375375b" translate="yes" xml:space="preserve">
          <source>Adds a new request header (&lt;code&gt;key&lt;/code&gt;) if not present, otherwise replaces the previous value of that header with &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">添加一个新的请求标头（ &lt;code&gt;key&lt;/code&gt; ）（如果不存在），否则用value替换该标头的先前 &lt;code&gt;value&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7c2bf518fb38cf26c49db68d29cada83da6c1888" translate="yes" xml:space="preserve">
          <source>Adds a new response header (&lt;code&gt;key&lt;/code&gt;) if not present, otherwise replaces the previous value of that header with &lt;code&gt;value&lt;/code&gt;</source>
          <target state="translated">添加一个新的响应头（ &lt;code&gt;key&lt;/code&gt; ）（如果不存在），否则用value替换该头的先前 &lt;code&gt;value&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3dea66064c01516ce1ce2f232671c9e6df2d28b6" translate="yes" xml:space="preserve">
          <source>Adds a new response header (&lt;code&gt;key&lt;/code&gt;) if not present, otherwise replaces the previous value of that header with &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">如果不存在，则添加新的响应标头（ &lt;code&gt;key&lt;/code&gt; ），否则将其替换为 &lt;code&gt;value&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7384ebe47a1b17e11afd5a17b7481276360f53a4" translate="yes" xml:space="preserve">
          <source>Adds an error to the changeset</source>
          <target state="translated">在更改集中添加一个错误</target>
        </trans-unit>
        <trans-unit id="8fd325b36f13567a54758748114ef41ca1fff6fb" translate="yes" xml:space="preserve">
          <source>Adds an error to the changeset.</source>
          <target state="translated">在变更集上添加一个错误。</target>
        </trans-unit>
        <trans-unit id="d1f9282c9f061f154b56dad9390ad5d59a06b52c" translate="yes" xml:space="preserve">
          <source>Adds an insert operation to the multi</source>
          <target state="translated">将插入操作添加到多组数据中。</target>
        </trans-unit>
        <trans-unit id="5a732255ac22c5c6065191d204bc188d1d7d11f9" translate="yes" xml:space="preserve">
          <source>Adds an insert operation to the multi.</source>
          <target state="translated">在多头中添加插入操作。</target>
        </trans-unit>
        <trans-unit id="6f1d356ee7af97c290a0983fcc393be6d69fc9fe" translate="yes" xml:space="preserve">
          <source>Adds an insert_all operation to the multi</source>
          <target state="translated">在多条信息中添加insert_all操作。</target>
        </trans-unit>
        <trans-unit id="18fb34baf7a00ef35058866f1cd06182f6556828" translate="yes" xml:space="preserve">
          <source>Adds an insert_all operation to the multi.</source>
          <target state="translated">为multi添加insert_all操作。</target>
        </trans-unit>
        <trans-unit id="4fea338f938382b22df2ad7873e19fba67b7dc02" translate="yes" xml:space="preserve">
          <source>Adds an update operation to the multi</source>
          <target state="translated">为多用户添加更新操作。</target>
        </trans-unit>
        <trans-unit id="c3cc5c39ec6abb44d01e956bf112b8e5cfa6f1f5" translate="yes" xml:space="preserve">
          <source>Adds an update operation to the multi.</source>
          <target state="translated">为多人添加更新操作。</target>
        </trans-unit>
        <trans-unit id="2dab70e220b97494a706a2a537167adfafecc13d" translate="yes" xml:space="preserve">
          <source>Adds an update_all operation to the multi</source>
          <target state="translated">为多用户添加一个 update_all 操作。</target>
        </trans-unit>
        <trans-unit id="427f83a0359dd0e43a3da4e151a7253d8e9a4062" translate="yes" xml:space="preserve">
          <source>Adds an update_all operation to the multi.</source>
          <target state="translated">为multi添加一个update_all操作。</target>
        </trans-unit>
        <trans-unit id="9cc89a0814520555ed99c796dba3165d5cca397a" translate="yes" xml:space="preserve">
          <source>Adds key value pairs to socket assigns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77d8ef9e9593e05de16fcb185362ded29dbcdd47" translate="yes" xml:space="preserve">
          <source>Adds key/value pair to socket assigns</source>
          <target state="translated">添加键/值对到插座上分配</target>
        </trans-unit>
        <trans-unit id="0d847ebf435901217a855c2d3a9bd63d85d34c23" translate="yes" xml:space="preserve">
          <source>Adds key/value pair to socket assigns.</source>
          <target state="translated">为插座分配添加键/值对。</target>
        </trans-unit>
        <trans-unit id="2ebb729e6f4563c0b483c5ecfc0f09681da14fb9" translate="yes" xml:space="preserve">
          <source>Adds the given interval to the current time in UTC</source>
          <target state="translated">将给定的时间间隔添加到当前时间(UTC)中。</target>
        </trans-unit>
        <trans-unit id="042bc7077804c2ab95f410b2330b189b5fef8ec7" translate="yes" xml:space="preserve">
          <source>Adds the given interval to the current time in UTC.</source>
          <target state="translated">将给定的时间间隔添加到当前时间(UTC)中。</target>
        </trans-unit>
        <trans-unit id="3b5a0d13c97aaad5ec8dba3e8924ba9778eb0ba4" translate="yes" xml:space="preserve">
          <source>After a client has successfully joined a channel, incoming events from the client are routed through the channel&amp;rsquo;s &lt;code&gt;handle_in/3&lt;/code&gt; callbacks. Within these callbacks, you can perform any action. Typically you&amp;rsquo;ll either forward a message to all listeners with &lt;a href=&quot;#broadcast!/3&quot;&gt;&lt;code&gt;broadcast!/3&lt;/code&gt;&lt;/a&gt;, or push a message directly down the socket with &lt;a href=&quot;#push/3&quot;&gt;&lt;code&gt;push/3&lt;/code&gt;&lt;/a&gt;. Incoming callbacks must return the &lt;code&gt;socket&lt;/code&gt; to maintain ephemeral state.</source>
          <target state="translated">客户端成功加入通道后，来自客户端的传入事件将通过通道的 &lt;code&gt;handle_in/3&lt;/code&gt; 回调进行路由。在这些回调中，您可以执行任何操作。通常，您可以使用&lt;a href=&quot;#broadcast!/3&quot;&gt; &lt;code&gt;broadcast!/3&lt;/code&gt; &lt;/a&gt;将消息转发给所有侦听器，或者使用&lt;a href=&quot;#push/3&quot;&gt; &lt;code&gt;push/3&lt;/code&gt; &lt;/a&gt;将消息直接推入套接字。传入的回调必须返回 &lt;code&gt;socket&lt;/code&gt; 以保持短暂状态。</target>
        </trans-unit>
        <trans-unit id="e4108bb7b421c03ddfde669d012f6caf3a8a55f8" translate="yes" xml:space="preserve">
          <source>After a client has successfully joined a channel, incoming events from the client are routed through the channel's &lt;code&gt;handle_in/3&lt;/code&gt; callbacks. Within these callbacks, you can perform any action. Typically you'll either forward a message to all listeners with &lt;a href=&quot;#broadcast!/3&quot;&gt;&lt;code&gt;broadcast!/3&lt;/code&gt;&lt;/a&gt;, or push a message directly down the socket with &lt;a href=&quot;#push/3&quot;&gt;&lt;code&gt;push/3&lt;/code&gt;&lt;/a&gt;. Incoming callbacks must return the &lt;code&gt;socket&lt;/code&gt; to maintain ephemeral state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4903a2f13a8bc80aa4ddc4c8cfc092578f620745" translate="yes" xml:space="preserve">
          <source>After a match is found, the block given as &lt;code&gt;do/end&lt;/code&gt; is stored as a function in the connection. This function is then retrieved and invoked in the &lt;code&gt;dispatch&lt;/code&gt; plug.</source>
          <target state="translated">找到匹配项后，作为 &lt;code&gt;do/end&lt;/code&gt; 给出的块将作为函数存储在连接中。然后在 &lt;code&gt;dispatch&lt;/code&gt; 插件中检索并调用此函数。</target>
        </trans-unit>
        <trans-unit id="26032b36670746e3434c695506614fe60aeea546" translate="yes" xml:space="preserve">
          <source>After casting, the changeset is given to many &lt;code&gt;Ecto.Changeset.validate_*&lt;/code&gt; functions that validate only the &lt;strong&gt;changed fields&lt;/strong&gt;. In other words: if a field was not given as a parameter, it won&amp;rsquo;t be validated at all. For example, if the params map contain only the &amp;ldquo;name&amp;rdquo; and &amp;ldquo;email&amp;rdquo; keys, the &amp;ldquo;age&amp;rdquo; validation won&amp;rsquo;t run.</source>
          <target state="translated">强制转换后，将变更集提供给许多 &lt;code&gt;Ecto.Changeset.validate_*&lt;/code&gt; 函数，这些函数仅验证&lt;strong&gt;更改的字段&lt;/strong&gt;。换句话说：如果没有将字段作为参数给出，则将完全不会对其进行验证。例如，如果参数映射仅包含&amp;ldquo;名称&amp;rdquo;和&amp;ldquo;电子邮件&amp;rdquo;键，则&amp;ldquo;年龄&amp;rdquo;验证将不会运行。</target>
        </trans-unit>
        <trans-unit id="bf0e063e152ca973c9a117163e8a4b6bc3228047" translate="yes" xml:space="preserve">
          <source>After casting, the changeset is given to many &lt;code&gt;Ecto.Changeset.validate_*&lt;/code&gt; functions that validate only the &lt;strong&gt;changed fields&lt;/strong&gt;. In other words: if a field was not given as a parameter, it won't be validated at all. For example, if the params map contain only the &quot;name&quot; and &quot;email&quot; keys, the &quot;age&quot; validation won't run.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6aa70809ce1014ac0c0f588a1a20ec2a8f93b3c" translate="yes" xml:space="preserve">
          <source>After exploring the documentation and guides, consider checking out the &lt;a href=&quot;http://pages.plataformatec.com.br/ebook-whats-new-in-ecto-2-0&quot;&gt;&amp;ldquo;What&amp;rsquo;s new in Ecto 2.1&amp;rdquo;&lt;/a&gt; free ebook to learn more about many features in Ecto 2.1 such as &lt;code&gt;many_to_many&lt;/code&gt;, schemaless queries, concurrent testing and more. Note the book still largely applies to Ecto 3.0 as the major change in Ecto 3.0 was the removal of the outdated Ecto datetime types in favor of Elixir&amp;rsquo;s Calendar types.</source>
          <target state="translated">浏览了文档和指南之后，请考虑阅读&lt;a href=&quot;http://pages.plataformatec.com.br/ebook-whats-new-in-ecto-2-0&quot;&gt;&amp;ldquo; Ecto 2.1的新功能&amp;rdquo;&lt;/a&gt;免费电子书，以详细了解Ecto 2.1的许多功能，例如 &lt;code&gt;many_to_many&lt;/code&gt; ，无模式查询，并发测试等。请注意，该书在很大程度上仍适用于Ecto 3.0，因为Ecto 3.0的主要变化是为了支持Elixir的Calendar类型而删除了过时的Ecto日期时间类型。</target>
        </trans-unit>
        <trans-unit id="2cc99a9383f7a49a0f5304d5703304af8b357577" translate="yes" xml:space="preserve">
          <source>After modifying our config file, we need to restart our server in order for this change to take effect. After restarting the server, let's go to &lt;a href=&quot;http://localhost:4000/such/a/wrong/path&quot;&gt;http://localhost:4000/such/a/wrong/path&lt;/a&gt; for a running local application and see what we get.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdea6ffdf38afdd8a0ea1ddf12cc241f602f9239" translate="yes" xml:space="preserve">
          <source>After persisting &lt;code&gt;weather&lt;/code&gt; to the database, it will return a new copy of &lt;code&gt;%Weather{}&lt;/code&gt; with the primary key (the &lt;code&gt;id&lt;/code&gt;) set. We can use this value to read a struct back from the repository:</source>
          <target state="translated">将 &lt;code&gt;weather&lt;/code&gt; 持久保存到数据库后，它将返回已设置主键（ &lt;code&gt;id&lt;/code&gt; ）的 &lt;code&gt;%Weather{}&lt;/code&gt; 的新副本。我们可以使用此值从存储库中读回一个结构：</target>
        </trans-unit>
        <trans-unit id="eda22db6835aca19ce8bec03b7cbe8f1e16ab622" translate="yes" xml:space="preserve">
          <source>After reloading &lt;a href=&quot;http://localhost:4000/&quot;&gt;http://localhost:4000/&lt;/a&gt;, we should see a very different page, one with no title, logo image, or css styling at all.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c66edcfc2858cc5138aa21b5e8f79ef414cd14b3" translate="yes" xml:space="preserve">
          <source>After rendering the static page, LiveView connects from the client to the server where stateful views are spawned to push rendered updates to the browser, and receive client events via &lt;code&gt;phx-&lt;/code&gt; bindings. Just like the first rendering, &lt;a href=&quot;#c:mount/3&quot;&gt;&lt;code&gt;mount/3&lt;/code&gt;&lt;/a&gt; is invoked with params, session, and socket state, where mount assigns values for rendering. However in the connected client case, a LiveView process is spawned on the server, pushes the result of &lt;a href=&quot;#c:render/1&quot;&gt;&lt;code&gt;render/1&lt;/code&gt;&lt;/a&gt; to the client and continues on for the duration of the connection. If at any point during the stateful life-cycle a crash is encountered, or the client connection drops, the client gracefully reconnects to the server, calling &lt;a href=&quot;#c:mount/3&quot;&gt;&lt;code&gt;mount/3&lt;/code&gt;&lt;/a&gt; once again.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afc8a3c116cb06fd08163a570db09643a9c02a4b" translate="yes" xml:space="preserve">
          <source>After the callback is invoked, the error is re-raised.</source>
          <target state="translated">回调被调用后,会重新引发错误。</target>
        </trans-unit>
        <trans-unit id="eb9d6f19b212137313eaa3e9853e9ac315788ddf" translate="yes" xml:space="preserve">
          <source>After the client connects, &lt;a href=&quot;#c:mount/3&quot;&gt;&lt;code&gt;mount/3&lt;/code&gt;&lt;/a&gt; will be invoked inside a spawned LiveView process. At this point, you can use &lt;a href=&quot;#connected?/1&quot;&gt;&lt;code&gt;connected?/1&lt;/code&gt;&lt;/a&gt; to conditionally perform stateful work, such as subscribing to pubsub topics, sending messages, etc. For example, you can periodically update a LiveView with a timer:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1de59739d4d270b220874ec766f302986a4a91d4" translate="yes" xml:space="preserve">
          <source>After this change, you must recompile plug:</source>
          <target state="translated">更改后,你必须重新编译插件。</target>
        </trans-unit>
        <trans-unit id="a23f504d0f093acbbb6fce5be9ab673b58ff415c" translate="yes" xml:space="preserve">
          <source>Again, if we add a key/value pair to the end of the function call, it is added to the query string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f26115df05290ceff8e59ff5a98695a4781e050a" translate="yes" xml:space="preserve">
          <source>Again, let's think of a function name that describes what we want to accomplish.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7959cb53fcd6fb73c38fe9b93d515c18a416d2d0" translate="yes" xml:space="preserve">
          <source>Again, we can run this task with the &lt;code&gt;-r&lt;/code&gt; flag and another repo if we need to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="252ef139af6f0fdc730b089eed9232ba35c0bc13" translate="yes" xml:space="preserve">
          <source>Aggregates: &lt;a href=&quot;#count/0&quot;&gt;&lt;code&gt;count/0&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#count/1&quot;&gt;&lt;code&gt;count/1&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#avg/1&quot;&gt;&lt;code&gt;avg/1&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#sum/1&quot;&gt;&lt;code&gt;sum/1&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#min/1&quot;&gt;&lt;code&gt;min/1&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#max/1&quot;&gt;&lt;code&gt;max/1&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">聚合：&lt;a href=&quot;#count/0&quot;&gt; &lt;code&gt;count/0&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#count/1&quot;&gt; &lt;code&gt;count/1&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#avg/1&quot;&gt; &lt;code&gt;avg/1&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#sum/1&quot;&gt; &lt;code&gt;sum/1&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#min/1&quot;&gt; &lt;code&gt;min/1&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#max/1&quot;&gt; &lt;code&gt;max/1&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8e8415fa4e4b7fad95b1c595d45c2c52cfcfe2c3" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;phx-&lt;/code&gt; event bindings apply their own css classes when pushed. For example the following markup:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4d268907b39f21873cee1e69528e4ae39983cee" translate="yes" xml:space="preserve">
          <source>All HTTP requests start in our application endpoint. You can find it as a module named &lt;code&gt;HelloWeb.Endpoint&lt;/code&gt; in &lt;code&gt;lib/hello_web/endpoint.ex&lt;/code&gt;. Once you open up the endpoint file, you will see that, similar to the router, the endpoint has many calls to &lt;code&gt;plug&lt;/code&gt;. &lt;a href=&quot;../plug/plug&quot;&gt;&lt;code&gt;Plug&lt;/code&gt;&lt;/a&gt; is a library and specification for stitching web applications together. It is an essential part of how Phoenix handles requests and we will discuss it in detail &lt;a href=&quot;plug&quot;&gt;in the Plug guide&lt;/a&gt; coming next.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c172a0bad59b89ef6d9a76d5ce1da6b2bf7d1af3" translate="yes" xml:space="preserve">
          <source>All adapters are required to implement a clause for :binary_id types, since they are adapter specific. If your adapter does not provide binary ids, you may simply use &lt;a href=&quot;ecto.uuid&quot;&gt;&lt;code&gt;Ecto.UUID&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">所有适配器都必须为：binary_id类型实现子句，因为它们是特定于适配器的。如果您的适配器不提供二进制ID，则可以简单地使用&lt;a href=&quot;ecto.uuid&quot;&gt; &lt;code&gt;Ecto.UUID&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="69c12b3b6c00c84ec71486ef08e3c19bbae79e25" translate="yes" xml:space="preserve">
          <source>All adapters are required to implement a clause for &lt;code&gt;:binary_id&lt;/code&gt; types, since they are adapter specific. If your adapter does not provide binary ids, you may simply use &lt;a href=&quot;ecto.uuid&quot;&gt;&lt;code&gt;Ecto.UUID&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">所有适配器都必须为 &lt;code&gt;:binary_id&lt;/code&gt; 类型实现子句，因为它们是特定于适配器的。如果您的适配器不提供二进制ID，则可以简单地使用&lt;a href=&quot;ecto.uuid&quot;&gt; &lt;code&gt;Ecto.UUID&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="0ab4c8d0ec0fc810d465b494368a4623df96ffed" translate="yes" xml:space="preserve">
          <source>All controller actions take two arguments. The first is &lt;code&gt;conn&lt;/code&gt;, a struct which holds a ton of data about the request. The second is &lt;code&gt;params&lt;/code&gt;, which are the request parameters. Here, we are not using &lt;code&gt;params&lt;/code&gt;, and we avoid compiler warnings by adding the leading &lt;code&gt;_&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d45225e1467161970b40e45c5803f0dbfd88ffa" translate="yes" xml:space="preserve">
          <source>All endpoints are configured in your application environment. For example:</source>
          <target state="translated">所有的端点都是在你的应用环境中配置的。比如说,你可以在应用环境中配置所有端点。</target>
        </trans-unit>
        <trans-unit id="4b09c1ec9758d43f4962774adb6d17753fba520f" translate="yes" xml:space="preserve">
          <source>All event callbacks are run in the same process that calls the &lt;a href=&quot;#c:instrument/3&quot;&gt;&lt;code&gt;instrument/3&lt;/code&gt;&lt;/a&gt; macro; hence, instrumenters should be careful to avoid performing blocking actions. If an event callback fails in any way (exits, throws, or raises), it won&amp;rsquo;t affect anything as the error is caught, but the failure will be logged. Note that &amp;ldquo;after&amp;rdquo; callbacks are not guaranteed to be called as, for example, a link may break before they&amp;rsquo;ve been called.</source>
          <target state="translated">所有事件回调均在调用&lt;a href=&quot;#c:instrument/3&quot;&gt; &lt;code&gt;instrument/3&lt;/code&gt; &lt;/a&gt;宏的同一过程中运行；因此，仪器人员应小心避免执行阻塞动作。如果事件回调以任何方式（退出，抛出或引发）失败，则由于捕获了错误，它不会影响任何事情，但是将记录失败。请注意，不能保证调用&amp;ldquo;之后&amp;rdquo;回调，例如，链接可能在调用之前中断。</target>
        </trans-unit>
        <trans-unit id="c602e54c21759c3a3e81e03de5c0cba22e852a4f" translate="yes" xml:space="preserve">
          <source>All events can be rate-limited on the client by using the &lt;code&gt;phx-debounce&lt;/code&gt; and &lt;code&gt;phx-throttle&lt;/code&gt; bindings, with the following behavior:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad7544f2dd291d98846f1fadb6ce98ab43a5d856" translate="yes" xml:space="preserve">
          <source>All given options are forwarded to the underlying input, default values are provided for id, name and textarea content if possible.</source>
          <target state="translated">所有给定的选项都会被转发到底层输入,如果可能的话,id、name和textarea内容都会提供默认值。</target>
        </trans-unit>
        <trans-unit id="813dc7e9919c783a01744c6de9aa6e536e1981be" translate="yes" xml:space="preserve">
          <source>All given options are forwarded to the underlying input, default values are provided for id, name and value if possible.</source>
          <target state="translated">所有给定的选项都会转发到底层输入,如果可能的话,id、name和value都会提供默认值。</target>
        </trans-unit>
        <trans-unit id="9f5563600902eea5e57e862ead255e4eba991ece" translate="yes" xml:space="preserve">
          <source>All given options are forwarded to the underlying tag. A default value is provided for &lt;code&gt;for&lt;/code&gt; attribute but can be overriden if you pass a value to the &lt;code&gt;for&lt;/code&gt; option. Text content would be inferred from &lt;code&gt;field&lt;/code&gt; if not specified.</source>
          <target state="translated">所有给定的选项都转发到基础标签。为 &lt;code&gt;for&lt;/code&gt; 属性提供了默认值，但是如果您将值传递给 &lt;code&gt;for&lt;/code&gt; 选项，则可以覆盖默认值。如果未指定，将从 &lt;code&gt;field&lt;/code&gt; 推断出文本内容。</target>
        </trans-unit>
        <trans-unit id="9e1d5f62ff32c78721a5a9fe3e9145cb94c0df7f" translate="yes" xml:space="preserve">
          <source>All layouts must call &lt;code&gt;&amp;lt;%= @inner_content %&amp;gt;&lt;/code&gt; to inject the content rendered by the layout.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e79ca9879a7fed3a2fbfd722b280d01bd7565c08" translate="yes" xml:space="preserve">
          <source>All measurements are given in the &lt;code&gt;:native&lt;/code&gt; time unit. You can read more about it in the docs for &lt;a href=&quot;https://hexdocs.pm/elixir/System.html#convert_time_unit/3&quot;&gt;&lt;code&gt;System.convert_time_unit/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="499393acc73825c4c36e7d2c38f112f85ee41bf0" translate="yes" xml:space="preserve">
          <source>All names must be unique between both structures.</source>
          <target state="translated">所有名称在两个结构之间必须是唯一的。</target>
        </trans-unit>
        <trans-unit id="8db0c93c2441d2db62c9efdff79f4e349d222d42" translate="yes" xml:space="preserve">
          <source>All of Phoenix configuration, except the Compile-time configuration below can be set dynamically from the &lt;a href=&quot;#c:init/2&quot;&gt;&lt;code&gt;init/2&lt;/code&gt;&lt;/a&gt; callback.</source>
          <target state="translated">除下面的编译时配置外，所有Phoenix配置都可以从&lt;a href=&quot;#c:init/2&quot;&gt; &lt;code&gt;init/2&lt;/code&gt; &lt;/a&gt;回调中动态设置。</target>
        </trans-unit>
        <trans-unit id="0d326ac593831af17363500f0a14d30fbbe28b9a" translate="yes" xml:space="preserve">
          <source>All of the &lt;code&gt;assigns&lt;/code&gt; given are forwarded directly to the &lt;code&gt;live_component&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb9f406d1a62409ed175f5228b87871665950184" translate="yes" xml:space="preserve">
          <source>All of the data in a LiveView is stored in the socket as assigns. The &lt;a href=&quot;phoenix.liveview#assign/2&quot;&gt;&lt;code&gt;Phoenix.LiveView.assign/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;phoenix.liveview#assign/3&quot;&gt;&lt;code&gt;Phoenix.LiveView.assign/3&lt;/code&gt;&lt;/a&gt; functions help store those values. Those values can be accessed in the LiveView as &lt;code&gt;socket.assigns.name&lt;/code&gt; but they are accessed inside LiveView templates as &lt;code&gt;@name&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9361d164562daf4b061c64bab712118835ec777" translate="yes" xml:space="preserve">
          <source>All of the files which are currently in the &lt;code&gt;controllers&lt;/code&gt;, &lt;code&gt;templates&lt;/code&gt;, and &lt;code&gt;views&lt;/code&gt; directories are there to create the &quot;Welcome to Phoenix!&quot; page we saw in the &quot;Up and running&quot; guide. The &lt;code&gt;channels&lt;/code&gt; directory is where we will add code related to building real-time Phoenix applications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d51449954d7b0982db1a36b8fd5c9a56660ab117" translate="yes" xml:space="preserve">
          <source>All of the imports and aliases we make in our view will also be available in our templates. That's because templates are effectively compiled into functions inside their respective views. For example, if you define a function in your view, you will be able to invoke it directly from the template. Let's see this in practice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c19589522633ca77d3991d5f5b28ef40ee94b972" translate="yes" xml:space="preserve">
          <source>All of these files are our static assets. Now let's run the &lt;a href=&quot;mix.tasks.phx.digest&quot;&gt;&lt;code&gt;mix phx.digest&lt;/code&gt;&lt;/a&gt; task.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10b993f627ba62806b1f8752d0a4bbd00b261025" translate="yes" xml:space="preserve">
          <source>All of those types are represented by the same timestamp/datetime in the underlying data storage, the difference are in their precision and how the data is loaded into Elixir.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5e2d3cafbf3b1257c66222879054524fa83042b" translate="yes" xml:space="preserve">
          <source>All operations will be executed in the order they were added.</source>
          <target state="translated">所有的操作都将按照添加的顺序执行。</target>
        </trans-unit>
        <trans-unit id="bdcf9cd3751eb31bdc1527fb2f1dc7715bab71c1" translate="yes" xml:space="preserve">
          <source>All options are forwarded to the underlying button tag.</source>
          <target state="translated">所有的选项都会转发到底层的按钮标签。</target>
        </trans-unit>
        <trans-unit id="422eebfcbf3c24c00aab6148bd4fb9a777d80147" translate="yes" xml:space="preserve">
          <source>All options are forwarded to the underlying button tag. When called with a &lt;code&gt;do:&lt;/code&gt; block, the button tag options come first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="522ddbe1f1dfe285f4aa9236aba2fc9ba59e6950" translate="yes" xml:space="preserve">
          <source>All options are forwarded to the underlying input tag.</source>
          <target state="translated">所有的选项都会转发到底层的输入标签。</target>
        </trans-unit>
        <trans-unit id="ea466da3a996e67a1497fcb65a8eac06f270b70a" translate="yes" xml:space="preserve">
          <source>All options are passed directly to the &lt;a href=&quot;../phoenix/phoenix.socket&quot;&gt;&lt;code&gt;Phoenix.Socket&lt;/code&gt;&lt;/a&gt; constructor, except for the following LiveView specific options:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7009b3da1def9b1ee6d1bd825e69020e72baee8d" translate="yes" xml:space="preserve">
          <source>All options are simply forwarded to the underlying HTML tag.</source>
          <target state="translated">所有的选项都只是转发到底层的HTML标签。</target>
        </trans-unit>
        <trans-unit id="558de1b31a7f35b365da32ef41bf2e958a244056" translate="yes" xml:space="preserve">
          <source>All options can be pre-configured by setting &lt;code&gt;@timestamps_opts&lt;/code&gt;.</source>
          <target state="translated">可以通过设置 &lt;code&gt;@timestamps_opts&lt;/code&gt; 来预先配置所有选项。</target>
        </trans-unit>
        <trans-unit id="28bc82a547f8d0a9365fca95f1387101711c40f1" translate="yes" xml:space="preserve">
          <source>All options supported by &lt;a href=&quot;plug.conn#read_body/2&quot;&gt;&lt;code&gt;Plug.Conn.read_body/2&lt;/code&gt;&lt;/a&gt; are also supported here. They are repeated here for convenience:</source>
          <target state="translated">这里也支持&lt;a href=&quot;plug.conn#read_body/2&quot;&gt; &lt;code&gt;Plug.Conn.read_body/2&lt;/code&gt; &lt;/a&gt;支持的所有选项。为了方便起见，在此重复它们：</target>
        </trans-unit>
        <trans-unit id="26fa0e94a406535f7bfd860c9bddab30dd1bbfc7" translate="yes" xml:space="preserve">
          <source>All other options are forwarded to the LiveView for rendering. Refer to &lt;a href=&quot;phoenix.liveview.helpers#live_render/3&quot;&gt;&lt;code&gt;Phoenix.LiveView.Helpers.live_render/3&lt;/code&gt;&lt;/a&gt; for a list of supported render options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c88f2411e8c83ee2c14ec0b1738ea5968198922f" translate="yes" xml:space="preserve">
          <source>All other options are forwarded to the anchor tag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45cc7909dee625c35daed3413858b850ca7b70cf" translate="yes" xml:space="preserve">
          <source>All other options are forwarded to the underlying &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; tag.</source>
          <target state="translated">所有其他选项都转发到基础 &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; 标记。</target>
        </trans-unit>
        <trans-unit id="0de8e7fa31635bbc8b9cb09d4c14202e448a3833" translate="yes" xml:space="preserve">
          <source>All other options are forwarded to the underlying HTML tag.</source>
          <target state="translated">所有其他选项都会转发到底层的HTML标签。</target>
        </trans-unit>
        <trans-unit id="6f0461c97a5f7c04f3543b8d31b32467f48a927a" translate="yes" xml:space="preserve">
          <source>All other options are forwarded to the underlying button input.</source>
          <target state="translated">所有其他选项都转发到底层按钮输入。</target>
        </trans-unit>
        <trans-unit id="d3cdbef73beb37bb98e96f11d133934f74a806ca" translate="yes" xml:space="preserve">
          <source>All other options are forwarded. See &lt;a href=&quot;#text_input/3&quot;&gt;&lt;code&gt;text_input/3&lt;/code&gt;&lt;/a&gt; for example and docs.</source>
          <target state="translated">所有其他选项均被转发。有关示例和文档，请参见&lt;a href=&quot;#text_input/3&quot;&gt; &lt;code&gt;text_input/3&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e5ce54eed717637497450620d027b4dc6f39dc64" translate="yes" xml:space="preserve">
          <source>All other options are passed to the underlying HTML tag.</source>
          <target state="translated">所有其他的选项都传递给底层的HTML标签。</target>
        </trans-unit>
        <trans-unit id="f06429df7c982138e6fece80594cc2823997c039" translate="yes" xml:space="preserve">
          <source>All other types and dynamic values must be passed as a parameter using interpolation as explained below.</source>
          <target state="translated">所有其他类型和动态值必须使用插值作为参数传递,如下所述。</target>
        </trans-unit>
        <trans-unit id="8e0ed724d9fd7f66ef5b095b68eed5927f535ac7" translate="yes" xml:space="preserve">
          <source>All paths that match the forwarded prefix will be sent to the forwarded plug. This is useful for sharing a router between applications or even breaking a big router into smaller ones. The router pipelines will be invoked prior to forwarding the connection.</source>
          <target state="translated">所有与转发前缀相匹配的路径都将被发送到转发插件上。这对于在应用程序之间共享一个路由器,甚至将一个大的路由器分解成更小的路由器是很有用的。路由器管道将在转发连接之前被调用。</target>
        </trans-unit>
        <trans-unit id="62b34ea36e859428b611c71d81b082ea47b9c097" translate="yes" xml:space="preserve">
          <source>All presences for a given Pid can be untracked by calling the &lt;a href=&quot;phoenix.tracker#untrack/2&quot;&gt;&lt;code&gt;Phoenix.Tracker.untrack/2&lt;/code&gt;&lt;/a&gt; signature of this function.</source>
          <target state="translated">通过调用此函数的&lt;a href=&quot;phoenix.tracker#untrack/2&quot;&gt; &lt;code&gt;Phoenix.Tracker.untrack/2&lt;/code&gt; &lt;/a&gt;签名，可以取消跟踪给定Pid的所有状态。</target>
        </trans-unit>
        <trans-unit id="6a339d2d44001129cb1c12faf11686559a271e99" translate="yes" xml:space="preserve">
          <source>All routes are compiled to a match function that receives three arguments: the method, the request path split on &lt;code&gt;/&lt;/code&gt; and the connection. Consider this example:</source>
          <target state="translated">所有路由都被编译为一个匹配函数，该函数接收三个参数：方法，在 &lt;code&gt;/&lt;/code&gt; 上拆分的请求路径和连接。考虑以下示例：</target>
        </trans-unit>
        <trans-unit id="d12952e472708b80423f06432a2383dee2f914b2" translate="yes" xml:space="preserve">
          <source>All serialized, remote client messages should be deserialized and forwarded through this function by adapters.</source>
          <target state="translated">所有序列化的远程客户端报文都应通过适配器反序列化,并通过此功能转发。</target>
        </trans-unit>
        <trans-unit id="93047db332d3fa7598466b439197809e8a9cb06e" translate="yes" xml:space="preserve">
          <source>All the instrumenter modules that export a &lt;code&gt;render_view/3&lt;/code&gt; function will be notified of the event so that they can perform their respective actions.</source>
          <target state="translated">将向事件通知所有导出 &lt;code&gt;render_view/3&lt;/code&gt; 函数的工具模块，以便它们可以执行各自的操作。</target>
        </trans-unit>
        <trans-unit id="cb13a27a6b2fabbab41cab0702575683d1146342" translate="yes" xml:space="preserve">
          <source>All these parameters, including the global defaults mentioned above, can be overridden by specifying custom &lt;code&gt;:ssl&lt;/code&gt; configuration options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bee5dcdc1845852a6cf857d54a045b05a91fe4b6" translate="yes" xml:space="preserve">
          <source>Allows a field to be dynamically accessed</source>
          <target state="translated">允许动态访问一个字段。</target>
        </trans-unit>
        <trans-unit id="500d682f2e570192910057021d322d492c7d8b70" translate="yes" xml:space="preserve">
          <source>Allows a field to be dynamically accessed.</source>
          <target state="translated">允许动态访问一个字段。</target>
        </trans-unit>
        <trans-unit id="0feeacfc10a32e5cfe789e8b160f86661a34f0f9" translate="yes" xml:space="preserve">
          <source>Allows instrumenting operation defined by &lt;code&gt;function&lt;/code&gt;</source>
          <target state="translated">允许按 &lt;code&gt;function&lt;/code&gt; 定义仪器操作</target>
        </trans-unit>
        <trans-unit id="a267a50bfe0914d97c375bc375ed4341bebf430f" translate="yes" xml:space="preserve">
          <source>Allows instrumenting operation defined by &lt;code&gt;function&lt;/code&gt;.</source>
          <target state="translated">允许通过 &lt;code&gt;function&lt;/code&gt; 定义的检测操作。</target>
        </trans-unit>
        <trans-unit id="e9d7b7bbf93231434f82632551b53bdeb2d392f3" translate="yes" xml:space="preserve">
          <source>Almost all of the repository functions outlined in this module accept the following options:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="008d76871a9d79cfc587210844bce1eeecbd67bd" translate="yes" xml:space="preserve">
          <source>Almost all of the repository operations below accept the following options:</source>
          <target state="translated">下面几乎所有的存储库操作都接受以下选项。</target>
        </trans-unit>
        <trans-unit id="11b63d2e626bbf29994f29ed30f1ba4744b7a184" translate="yes" xml:space="preserve">
          <source>Also note that if &lt;code&gt;:on_conflict&lt;/code&gt; is a query, MySQL will return the number of attempted entries plus the number of entries modified by the UPDATE query.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81baec4d7ec64823c1289f28fd5d3c4cb6bd701b" translate="yes" xml:space="preserve">
          <source>Also note the given &lt;code&gt;:id&lt;/code&gt; is not necessarily used as the DOM ID. If you want to set a DOM ID, it is your responsibility to set it when rendering:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b9be8e8ffe8be69521563d9ef94e7723bf5a909" translate="yes" xml:space="preserve">
          <source>Also notice that these pages are going to be shown in production. If you are looking for error handling to help during development, consider using &lt;a href=&quot;plug.debugger&quot;&gt;&lt;code&gt;Plug.Debugger&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">还要注意，这些页面将在生产中显示。如果要在开发过程中寻求错误处理帮助，请考虑使用&lt;a href=&quot;plug.debugger&quot;&gt; &lt;code&gt;Plug.Debugger&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="22cd88359c4a50b92411312b68b7a8bbbdb9b33f" translate="yes" xml:space="preserve">
          <source>Also, change &lt;code&gt;lib/hello/cms/page.ex&lt;/code&gt; to remove &lt;code&gt;:views&lt;/code&gt; from the permitted params:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a173642ed7a4ddf0000bbbe1795e679a521c855" translate="yes" xml:space="preserve">
          <source>Also, most adapters provide direct APIs for queries, like &lt;code&gt;Ecto.Adapters.SQL.query/4&lt;/code&gt;, allowing developers to completely bypass Ecto queries.</source>
          <target state="translated">此外，大多数适配器都为查询提供直接API，例如 &lt;code&gt;Ecto.Adapters.SQL.query/4&lt;/code&gt; ，从而使开发人员可以完全绕过Ecto查询。</target>
        </trans-unit>
        <trans-unit id="dd52f213e28e01580c031fd88b310e77b168c916" translate="yes" xml:space="preserve">
          <source>Also, since the store is in-memory, it means sessions are not shared between servers. If you deploy to more than one machine, using this store is again not recommended.</source>
          <target state="translated">另外,由于该存储是在内存中的,这意味着服务器之间不会共享会话。如果你部署在多台机器上,又不建议使用这个存储。</target>
        </trans-unit>
        <trans-unit id="6a8cf34f26d13a0056310f2520c841766dc8c37c" translate="yes" xml:space="preserve">
          <source>Alternatively, because Ecto does not tie a schema to a given table, we can use separate tables for each association. Let&amp;rsquo;s start over and define a new Comment schema:</source>
          <target state="translated">另外，由于Ecto不会将架构绑定到给定的表，因此我们可以为每个关联使用单独的表。让我们重新开始并定义一个新的Comment模式：</target>
        </trans-unit>
        <trans-unit id="f304a61eac0b8370145fa3e55918d747117ffe93" translate="yes" xml:space="preserve">
          <source>Alternatively, because Ecto does not tie a schema to a given table, we can use separate tables for each association. Let's start over and define a new Comment schema:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="321dd6338631d0cf6375c9af526cc1849ab8b29e" translate="yes" xml:space="preserve">
          <source>Alternatively, if you don't have a connection, you can pass &lt;code&gt;:foo&lt;/code&gt; as the form data source and explicitly pass the value for every input:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb5169095178c6c8c94640863a129d86d2a2dae9" translate="yes" xml:space="preserve">
          <source>Alternatively, instead of having the component directly send a message to the parent, the component could broadcast the update using &lt;a href=&quot;../phoenix_pubsub/phoenix.pubsub&quot;&gt;&lt;code&gt;Phoenix.PubSub&lt;/code&gt;&lt;/a&gt;. Such as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d9e91e29aab7f205ddafcbe7467410ed8756db7" translate="yes" xml:space="preserve">
          <source>Alternatively, read the data again from the database in a separate query. This option requires the primary key to be generated by the database:</source>
          <target state="translated">或者,在单独的查询中再次从数据库中读取数据。该选项要求主键由数据库生成。</target>
        </trans-unit>
        <trans-unit id="96b57a7146f6ce2d246b6a8f8a80250e9febe6b8" translate="yes" xml:space="preserve">
          <source>Alternatively, the &lt;code&gt;--context-app&lt;/code&gt; option may be supplied to the generator:</source>
          <target state="translated">或者，可以将 &lt;code&gt;--context-app&lt;/code&gt; 选项提供给生成器：</target>
        </trans-unit>
        <trans-unit id="6614e2051b53d4085816bb5cbdd8196885f12ba0" translate="yes" xml:space="preserve">
          <source>Alternatively, the OpenSSL CLI or other utilities can be used to generate a self-signed certificate. Instructions are widely available online.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="910b77d9dd831282aea4711919085610ee3b22d6" translate="yes" xml:space="preserve">
          <source>Alternatively, the root layout can be passed individually to the &lt;code&gt;live&lt;/code&gt; macro of your &lt;strong&gt;live routes&lt;/strong&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9acd6358ace335206d78edde3fec71a9150e3da0" translate="yes" xml:space="preserve">
          <source>Alternatively, we can make sure that when we create a comment, it is already associated to the post:</source>
          <target state="translated">或者,我们可以确保当我们创建一个评论时,它已经与帖子相关联。</target>
        </trans-unit>
        <trans-unit id="dc05913dcdaaade0ac224b9471c84283def29199" translate="yes" xml:space="preserve">
          <source>Alternatively, you can &lt;code&gt;live_render&lt;/code&gt; from any template:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3dcc6126e45a81167622b0e7f1ed0c26c4277a3" translate="yes" xml:space="preserve">
          <source>Alternatively, you can continue reading these guides to have a quick introduction into all the parts that make your Phoenix application. If that's the case, you can read the guides in any order or start with our guide that explains the &lt;a href=&quot;directory_structure&quot;&gt;Phoenix directory structure&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f69c752723942f38a03a10f6c3ef30bc5e097d42" translate="yes" xml:space="preserve">
          <source>Alternatively, you can give both &lt;code&gt;unique_index&lt;/code&gt; and &lt;code&gt;unique_constraint&lt;/code&gt; the same name:</source>
          <target state="translated">另外，您可以为 &lt;code&gt;unique_index&lt;/code&gt; 和 &lt;code&gt;unique_constraint&lt;/code&gt; 赋予相同的名称：</target>
        </trans-unit>
        <trans-unit id="6efb46ef343f6ed0e3216dfe518786d8f03f09e1" translate="yes" xml:space="preserve">
          <source>Alternatively, you can keep the &lt;a href=&quot;#c:render/1&quot;&gt;&lt;code&gt;render/1&lt;/code&gt;&lt;/a&gt; callback but delegate to an existing &lt;a href=&quot;../phoenix/phoenix.view&quot;&gt;&lt;code&gt;Phoenix.View&lt;/code&gt;&lt;/a&gt; module in your application. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="155429fd793002e8c29430c2e209cabe0d391fe9" translate="yes" xml:space="preserve">
          <source>Alternatively, you can set &lt;code&gt;@foreign_key_type EncodedId&lt;/code&gt; after &lt;code&gt;@primary_key&lt;/code&gt; to automatically configure the type of all &lt;code&gt;belongs_to&lt;/code&gt; fields.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93e785a14001e49c9b84753b2825d9f6cb5b13bb" translate="yes" xml:space="preserve">
          <source>Alternatively, you could define a &lt;code&gt;plug_status&lt;/code&gt; field directly in the exception struct:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91a4516cb4d9630fe735eff5b37d5a2a87dbfc11" translate="yes" xml:space="preserve">
          <source>Alternatively, you could invoke only the Endpoint, and Router:</source>
          <target state="translated">另外,你也可以只调用Endpoint,和Router。</target>
        </trans-unit>
        <trans-unit id="d8738df28b370bcf5efa3bfda949331ffc50808f" translate="yes" xml:space="preserve">
          <source>Alternatively, you could only invoke the Endpoint's plugs:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54b850ace8350ffbceab4c0b79db20ea808bef7c" translate="yes" xml:space="preserve">
          <source>Alternatively, you may just want to ack the status of the operation:</source>
          <target state="translated">或者,你可能只是想ck一下操作的状态。</target>
        </trans-unit>
        <trans-unit id="e34317bebd405610c93dc7524d10be7d18f71d8c" translate="yes" xml:space="preserve">
          <source>Although &lt;a href=&quot;#get_session/2&quot;&gt;&lt;code&gt;get_session/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#put_session/3&quot;&gt;&lt;code&gt;put_session/3&lt;/code&gt;&lt;/a&gt; allow atom keys, they are always normalized to strings. So this function always returns a map with string keys.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b82e0c2efff897466ba5c521ebd48ecd4d5d5b5" translate="yes" xml:space="preserve">
          <source>Although bindings are extremely useful when working with joins, they are not necessary when the query has only the &lt;code&gt;from&lt;/code&gt; clause. For such cases, Ecto supports a way for building queries without specifying the binding:</source>
          <target state="translated">尽管绑定在使用联接时非常有用，但是当查询仅具有 &lt;code&gt;from&lt;/code&gt; 子句时，绑定就没有必要。在这种情况下，Ecto支持一种无需指定绑定即可构建查询的方法：</target>
        </trans-unit>
        <trans-unit id="1f64f45f378a0ba87745eec7c28990a06414ce18" translate="yes" xml:space="preserve">
          <source>Although forms provide the &lt;code&gt;accept-charset&lt;/code&gt; attribute, which we set to UTF-8, Internet Explorer 5 up to 8 may ignore the value of this attribute if the user chooses their browser to do so. This ends up triggering the browser to send data in a format that is not understandable by the server.</source>
          <target state="translated">尽管表单提供了 &lt;code&gt;accept-charset&lt;/code&gt; 属性（我们将其设置为UTF-8），但如果用户选择浏览器这样做，则Internet Explorer 5（最多8个）可能会忽略此属性的值。最终触发浏览器以服务器无法理解的格式发送数据。</target>
        </trans-unit>
        <trans-unit id="17d3aa2c2d04f2fcc928e33bb2ddcbcbfc203565" translate="yes" xml:space="preserve">
          <source>Although in the example above we have directly inserted and deleted the struct in the repository, operations on top of schemas are done through changesets so Ecto can efficiently track changes.</source>
          <target state="translated">虽然在上面的例子中,我们直接在仓库中插入和删除了结构体,但对模式上面的操作是通过变化集来完成的,所以Ecto可以有效地跟踪变化。</target>
        </trans-unit>
        <trans-unit id="aa9d520b19f1b97df56a3c0d2d0343f82052d807" translate="yes" xml:space="preserve">
          <source>Although it accepts an &lt;code&gt;opts&lt;/code&gt; argument, there are no options currently supported by &lt;a href=&quot;#put_assoc/4&quot;&gt;&lt;code&gt;put_assoc/4&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9be422a570b817ed3d855feb6098dce936d8989" translate="yes" xml:space="preserve">
          <source>Although subqueries are not allowed in WHERE expressions, most subqueries in WHERE expression can be rewritten as JOINs. Imagine you want to write this query:</source>
          <target state="translated">虽然WHERE表达式中不允许使用子查询,但WHERE表达式中的大多数子查询都可以改写为JOIN。想象一下,你想写这个查询。</target>
        </trans-unit>
        <trans-unit id="38d0db682914b6a090cc5cf3303e1cf56459aa19" translate="yes" xml:space="preserve">
          <source>Although the root layout is not updated by LiveView, by simply assigning to &lt;code&gt;page_title&lt;/code&gt;, LiveView knows you want the title to be updated:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f2a66e6d0030e1b4305c62e74a0858c305811a6" translate="yes" xml:space="preserve">
          <source>Although this function accepts an &lt;code&gt;opts&lt;/code&gt; argument, there are no options currently supported by &lt;a href=&quot;#put_embed/4&quot;&gt;&lt;code&gt;put_embed/4&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">尽管此函数接受 &lt;code&gt;opts&lt;/code&gt; 参数，但是&lt;a href=&quot;#put_embed/4&quot;&gt; &lt;code&gt;put_embed/4&lt;/code&gt; &lt;/a&gt;当前不支持任何选项。</target>
        </trans-unit>
        <trans-unit id="0641530ad7e78210b89579523486c166e2b46440" translate="yes" xml:space="preserve">
          <source>Although using fragments in joins is discouraged in favor of Ecto Query syntax, they are necessary when writing lateral joins as lateral joins require a subquery that refer to previous bindings:</source>
          <target state="translated">虽然不鼓励在连接中使用片段,而倾向于使用Ecto Query语法,但在编写横向连接时,它们是必要的,因为横向连接需要一个引用之前绑定的子查询。</target>
        </trans-unit>
        <trans-unit id="55d091c50c4e2abce0a3176b2d62d4cfb4bd4e84" translate="yes" xml:space="preserve">
          <source>Although we have passed empty lists as options (they are required), you could pass any option there and it would be given to the underlying select input.</source>
          <target state="translated">虽然我们已经传递了空列表作为选项(它们是必需的),但你可以在那里传递任何选项,它将被赋予底层选择输入。</target>
        </trans-unit>
        <trans-unit id="140149a20a6971f6d5a40d50bec976229608679d" translate="yes" xml:space="preserve">
          <source>Although we used the &lt;code&gt;:through&lt;/code&gt; association in the example above, Ecto also allows developers to dynamically build the through associations using the &lt;a href=&quot;ecto#assoc/2&quot;&gt;&lt;code&gt;Ecto.assoc/2&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">尽管在上面的示例中使用了 &lt;code&gt;:through&lt;/code&gt; 关联，但是Ecto还允许开发人员使用&lt;a href=&quot;ecto#assoc/2&quot;&gt; &lt;code&gt;Ecto.assoc/2&lt;/code&gt; &lt;/a&gt;函数动态构建通过关联：</target>
        </trans-unit>
        <trans-unit id="aeef3747bb3efd51e4e60eff7db9a330f2778ae5" translate="yes" xml:space="preserve">
          <source>Always use this function when you need to access the operations you have defined in &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Ecto.Multi&lt;/code&gt;&lt;/a&gt;. Inspecting the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Ecto.Multi&lt;/code&gt;&lt;/a&gt; struct internals directly is discouraged.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24fba89e4fce0a2ce2702abaf702532a39ce135c" translate="yes" xml:space="preserve">
          <source>Always use this function when you need to access the operations you have defined in &lt;a href=&quot;ecto.multi#content&quot;&gt;&lt;code&gt;Ecto.Multi&lt;/code&gt;&lt;/a&gt;. Inspecting the &lt;a href=&quot;ecto.multi#content&quot;&gt;&lt;code&gt;Ecto.Multi&lt;/code&gt;&lt;/a&gt; struct internals directly is discouraged.</source>
          <target state="translated">当需要访问在&lt;a href=&quot;ecto.multi#content&quot;&gt; &lt;code&gt;Ecto.Multi&lt;/code&gt; 中&lt;/a&gt;定义的操作时，请始终使用此功能。不建议直接检查&lt;a href=&quot;ecto.multi#content&quot;&gt; &lt;code&gt;Ecto.Multi&lt;/code&gt; &lt;/a&gt;结构内部。</target>
        </trans-unit>
        <trans-unit id="6e5e6980a6207bfda1df7d8524d322c342c91585" translate="yes" xml:space="preserve">
          <source>An AND having query expression</source>
          <target state="translated">具有查询表达式的AND</target>
        </trans-unit>
        <trans-unit id="ff58307b231d1a6631bb29744d6ded1a8700a2d2" translate="yes" xml:space="preserve">
          <source>An AND having query expression.</source>
          <target state="translated">一个具有查询表达式的AND。</target>
        </trans-unit>
        <trans-unit id="d7200124991255eec599c4a84169b97fd56a8907" translate="yes" xml:space="preserve">
          <source>An AND where query expression</source>
          <target state="translated">一个AND,其中查询表达式</target>
        </trans-unit>
        <trans-unit id="8369e04976e5489b84e7a49a7bab27b831a68025" translate="yes" xml:space="preserve">
          <source>An AND where query expression.</source>
          <target state="translated">一个AND where查询表达式。</target>
        </trans-unit>
        <trans-unit id="118c95ad3087fa9270f38101f192fcebb74c98f7" translate="yes" xml:space="preserve">
          <source>An Ecto Example</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85f6b794368cf376b191f2b1a8caf6b0c1cae948" translate="yes" xml:space="preserve">
          <source>An Ecto schema is used to map any data source into an Elixir struct. The definition of the schema is possible through two main APIs: &lt;a href=&quot;#schema/2&quot;&gt;&lt;code&gt;schema/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#embedded_schema/1&quot;&gt;&lt;code&gt;embedded_schema/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Ecto模式用于将任何数据源映射到Elixir结构中。可以通过两个主要API定义模式：&lt;a href=&quot;#schema/2&quot;&gt; &lt;code&gt;schema/2&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#embedded_schema/1&quot;&gt; &lt;code&gt;embedded_schema/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9a78c7a83d38ff7d46dcb4af94da86b3e6249f86" translate="yes" xml:space="preserve">
          <source>An Ecto type for UUIDs strings.</source>
          <target state="translated">一个用于UUIDs字符串的Ecto类型。</target>
        </trans-unit>
        <trans-unit id="ee46e7344e9c28c8dc0c8ffba9e6f569b7f50779" translate="yes" xml:space="preserve">
          <source>An Ecto type, primitive or custom</source>
          <target state="translated">一个Ecto类型,原始的或自定义的。</target>
        </trans-unit>
        <trans-unit id="8753ca89d3033960625e32cacf9b8fa1380573d9" translate="yes" xml:space="preserve">
          <source>An Ecto type, primitive or custom.</source>
          <target state="translated">一个Ecto类型,原始的或自定义的。</target>
        </trans-unit>
        <trans-unit id="1499f024456d3f29759e8d864a77949d738934a4" translate="yes" xml:space="preserve">
          <source>An OR having query expression</source>
          <target state="translated">具有查询表达式的OR</target>
        </trans-unit>
        <trans-unit id="ba50741815527d5b973e074417869ccab912f791" translate="yes" xml:space="preserve">
          <source>An OR having query expression.</source>
          <target state="translated">一个具有查询表达式的OR。</target>
        </trans-unit>
        <trans-unit id="23272f9f7cc78f869c4f93ecdc53976c326941ef" translate="yes" xml:space="preserve">
          <source>An OR where query expression</source>
          <target state="translated">查询表达式的OR</target>
        </trans-unit>
        <trans-unit id="6eb1fef5cd61957f88210544d0ec10e50372df50" translate="yes" xml:space="preserve">
          <source>An OR where query expression.</source>
          <target state="translated">一个OR的查询表达式。</target>
        </trans-unit>
        <trans-unit id="6a2d43b1af1e0b2dcdb60baef14605ef1b374ed9" translate="yes" xml:space="preserve">
          <source>An action is a regular function that receives the connection and the request parameters as arguments. The connection is a &lt;a href=&quot;../plug/1.5.1/plug.conn&quot;&gt;&lt;code&gt;Plug.Conn&lt;/code&gt;&lt;/a&gt; struct, as specified by the Plug library.</source>
          <target state="translated">动作是一个常规函数，它接收连接和请求参数作为参数。该连接是由Plug库指定的&lt;a href=&quot;../plug/1.5.1/plug.conn&quot;&gt; &lt;code&gt;Plug.Conn&lt;/code&gt; &lt;/a&gt;结构。</target>
        </trans-unit>
        <trans-unit id="40ac62949b4ea3b0d9e9b75feb023914d2fa707d" translate="yes" xml:space="preserve">
          <source>An action is a regular function that receives the connection and the request parameters as arguments. The connection is a &lt;a href=&quot;../plug/plug.conn&quot;&gt;&lt;code&gt;Plug.Conn&lt;/code&gt;&lt;/a&gt; struct, as specified by the Plug library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bddff83f0e69da582ee7c2d814251936eff28fb7" translate="yes" xml:space="preserve">
          <source>An additional field called &lt;code&gt;__meta__&lt;/code&gt; is added to the struct for storing internal Ecto state. This field always has a &lt;a href=&quot;ecto.schema.metadata&quot;&gt;&lt;code&gt;Ecto.Schema.Metadata&lt;/code&gt;&lt;/a&gt; struct as value and can be manipulated with the &lt;a href=&quot;ecto#put_meta/2&quot;&gt;&lt;code&gt;Ecto.put_meta/2&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">名为 &lt;code&gt;__meta__&lt;/code&gt; 的附加字段已添加到该结构中，用于存储内部Ecto状态。此字段始终将&lt;a href=&quot;ecto.schema.metadata&quot;&gt; &lt;code&gt;Ecto.Schema.Metadata&lt;/code&gt; &lt;/a&gt;结构作为值，并且可以使用&lt;a href=&quot;ecto#put_meta/2&quot;&gt; &lt;code&gt;Ecto.put_meta/2&lt;/code&gt; &lt;/a&gt;函数进行操作。</target>
        </trans-unit>
        <trans-unit id="fae9eb87297abc7420a4adb2f4971432ff909c98" translate="yes" xml:space="preserve">
          <source>An additional keyword list &lt;code&gt;keys&lt;/code&gt; can be passed to provide additional contextual information for the error. This is useful when using &lt;a href=&quot;#traverse_errors/2&quot;&gt;&lt;code&gt;traverse_errors/2&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">可以传递其他关键字列表 &lt;code&gt;keys&lt;/code&gt; 以提供有关错误的其他上下文信息。当使用&lt;a href=&quot;#traverse_errors/2&quot;&gt; &lt;code&gt;traverse_errors/2&lt;/code&gt; &lt;/a&gt;时，这很有用</target>
        </trans-unit>
        <trans-unit id="938db368635dcd9641d56cee87115aa027d219f1" translate="yes" xml:space="preserve">
          <source>An easy rule of thumb is to stick with &lt;a href=&quot;phoenix.liveview.helpers#live_redirect/2&quot;&gt;&lt;code&gt;live_redirect/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;phoenix.liveview#push_redirect/2&quot;&gt;&lt;code&gt;push_redirect/2&lt;/code&gt;&lt;/a&gt; and use the patch helpers only in the cases where you want to minimize the amount of data sent when navigating within the same LiveView (for example, if you want to change the sorting of a table while also updating the URL).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cbecaa468000b1cd8e9438a0f21c36bad5b7afb" translate="yes" xml:space="preserve">
          <source>An embedded schema is either embedded into another schema or kept exclusively in memory. For this reason, an embedded schema does not require a source name and it does not include a metadata field.</source>
          <target state="translated">嵌入模式要么嵌入到另一个模式中,要么只保存在内存中。因此,嵌入式模式不需要源名称,也不包括元数据字段。</target>
        </trans-unit>
        <trans-unit id="7ab7ad8e3a3ea01a0e010a1f3d78b1a31b131365" translate="yes" xml:space="preserve">
          <source>An empty request body is parsed as an empty map.</source>
          <target state="translated">一个空的请求体被解析为一个空的地图。</target>
        </trans-unit>
        <trans-unit id="e437d69f5b4b7cd7366f20508cb7cc728cfa22eb" translate="yes" xml:space="preserve">
          <source>An endpoint is simply a module defined with the help of &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Phoenix.Endpoint&lt;/code&gt;&lt;/a&gt;. If you have used the &lt;a href=&quot;mix.tasks.phx.new&quot;&gt;&lt;code&gt;mix phx.new&lt;/code&gt;&lt;/a&gt; generator, an endpoint was automatically generated as part of your application:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b4b6b176041a548d4533de816c409382e35bce6" translate="yes" xml:space="preserve">
          <source>An endpoint is simply a module defined with the help of &lt;a href=&quot;phoenix.endpoint#content&quot;&gt;&lt;code&gt;Phoenix.Endpoint&lt;/code&gt;&lt;/a&gt;. If you have used the &lt;code&gt;mix phx.new&lt;/code&gt; generator, an endpoint was automatically generated as part of your application:</source>
          <target state="translated">端点只是在&lt;a href=&quot;phoenix.endpoint#content&quot;&gt; &lt;code&gt;Phoenix.Endpoint&lt;/code&gt; &lt;/a&gt;的帮助下定义的模块。如果您使用过 &lt;code&gt;mix phx.new&lt;/code&gt; 生成器，那么端点将作为应用程序的一部分自动生成：</target>
        </trans-unit>
        <trans-unit id="cde03332fee4ff115f16002c9f108e996e9a75a6" translate="yes" xml:space="preserve">
          <source>An error occurred and it will be handled by a different mechanism than the &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt;. Likely this approach involves calling &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html#restart_child/2&quot;&gt;&lt;code&gt;Supervisor.restart_child/2&lt;/code&gt;&lt;/a&gt; after a delay to attempt a restart.</source>
          <target state="translated">发生错误，将通过与&lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt;不同的机制来处理。这种方法可能涉及延迟尝试重新启动后调用&lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html#restart_child/2&quot;&gt; &lt;code&gt;Supervisor.restart_child/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b7551c55fc80ae2c95b1ad1165031ff791674af5" translate="yes" xml:space="preserve">
          <source>An example configuration with custom &lt;code&gt;:ssl&lt;/code&gt; options might look like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85d6ba7886e5493304a69c583a7b939934f2bf94" translate="yes" xml:space="preserve">
          <source>An except (set difference) query expression</source>
          <target state="translated">一个except(集差)查询表达式</target>
        </trans-unit>
        <trans-unit id="a5b26fb8a6cee45d37102dcd6e34101d2586040f" translate="yes" xml:space="preserve">
          <source>An except (set difference) query expression.</source>
          <target state="translated">一个except(集差)查询表达式。</target>
        </trans-unit>
        <trans-unit id="c13e83a84aa2694371b1a8ed1723cbe11eddc1f1" translate="yes" xml:space="preserve">
          <source>An exception on mount is caught and converted to an exception page by Phoenix error views - pretty much like the way it works with controllers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcade1f1ea3d0a589e1111aff1e48bf248c48b6c" translate="yes" xml:space="preserve">
          <source>An exception on mount will crash the LiveView process - which will be logged</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2a86c97233377ac8c34017ea9c780741efcd5ce" translate="yes" xml:space="preserve">
          <source>An informational response, such as an early hint, must happen prior to a response being sent. If an informational request is attempted after a response is sent then a &lt;a href=&quot;plug.conn.alreadysenterror&quot;&gt;&lt;code&gt;Plug.Conn.AlreadySentError&lt;/code&gt;&lt;/a&gt; will be raised. Only status codes from 100-199 are valid.</source>
          <target state="translated">信息响应（例如早期提示）必须在发送响应之前发生。如果在发送响应后尝试执行信息请求，则将引发&lt;a href=&quot;plug.conn.alreadysenterror&quot;&gt; &lt;code&gt;Plug.Conn.AlreadySentError&lt;/code&gt; &lt;/a&gt;。仅100-199的状态代码有效。</target>
        </trans-unit>
        <trans-unit id="c082ed6b2def64ed72b5ea45a1fc1293aa16df24" translate="yes" xml:space="preserve">
          <source>An intersect query expression</source>
          <target state="translated">交叉查询表达式</target>
        </trans-unit>
        <trans-unit id="f37d10b2a22904ef45fb94fc0d7c0dcd59a32a4d" translate="yes" xml:space="preserve">
          <source>An intersect query expression.</source>
          <target state="translated">交叉查询表达式。</target>
        </trans-unit>
        <trans-unit id="869fb8b610e0b6bb65e566732a732a81015cf3d5" translate="yes" xml:space="preserve">
          <source>An offset query expression</source>
          <target state="translated">偏移查询表达式</target>
        </trans-unit>
        <trans-unit id="165b52f75af17c46b4b3fa96c13c255f0bde19ed" translate="yes" xml:space="preserve">
          <source>An offset query expression.</source>
          <target state="translated">一个偏移的查询表达式。</target>
        </trans-unit>
        <trans-unit id="15e5c0ffc706898d12d9ae95b7fc36283bd41e5e" translate="yes" xml:space="preserve">
          <source>An optional text filter may be given to filter the results by the query selector. If the text filter is a string or a regex, it will match any element that contains the string or matches the regex. After the text filter is applied, only one element must remain, otherwise an error is raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79928e4dd3b57a8c42acb325b5879c6056476cbb" translate="yes" xml:space="preserve">
          <source>An order by query expression</source>
          <target state="translated">按查询表达式排序</target>
        </trans-unit>
        <trans-unit id="10e6e45231ed552f934b7c86d653cb891f6f2153" translate="yes" xml:space="preserve">
          <source>An order by query expression.</source>
          <target state="translated">按查询表达式排序。</target>
        </trans-unit>
        <trans-unit id="22439862de76cde9fbf60016e20e02131f76032d" translate="yes" xml:space="preserve">
          <source>An update query expression</source>
          <target state="translated">更新查询表达式</target>
        </trans-unit>
        <trans-unit id="ffcb9217c46e5f5eaa187819e15623ec94356a15" translate="yes" xml:space="preserve">
          <source>An update query expression.</source>
          <target state="translated">一个更新查询表达式。</target>
        </trans-unit>
        <trans-unit id="31ab765f91aa6f68439ffd097dd31b46e4c842ad" translate="yes" xml:space="preserve">
          <source>Analogous to the &lt;code&gt;_format&lt;/code&gt; query string param, we can render any sort of format we want by modifying the HTTP Content-Type Header and providing the appropriate template.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06802c5d56fe2d8e7757449833a3c7492e6642fb" translate="yes" xml:space="preserve">
          <source>And finally, we'll start the Phoenix server:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ffc9401405c31a1f9423d595d2efa929141b0ab" translate="yes" xml:space="preserve">
          <source>And here's what that translates to in the actual &lt;code&gt;users&lt;/code&gt; table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ab1249bd2abffa87777da45f6ab25d5772ddde1" translate="yes" xml:space="preserve">
          <source>And it works! We now have two isolated contexts responsible for user accounts and content management. We coupled the content management system to accounts where necessary, while keeping each system isolated wherever possible. This gives us a great base to grow our application from.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d32de79e50a18b2c10b2499fb3ad6f596ca4c0db" translate="yes" xml:space="preserve">
          <source>And now we want to make sure to return both the post title and the comment body. Although we may not know how many bindings there are in the query, we are sure posts is the first binding and comments are the last one, so we can write:</source>
          <target state="translated">而现在我们要确保同时返回帖子标题和评论正文。虽然我们可能不知道查询中有多少个绑定,但我们确信post是第一个绑定,而comment是最后一个绑定,所以我们可以这样写。</target>
        </trans-unit>
        <trans-unit id="86e9bcc3bf6ef74ce2cfbfff9b59b847e7893f8f" translate="yes" xml:space="preserve">
          <source>And now you can simply use it from your controller:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50fb2f2cee17d104e440238643e1e3cbf6bf874f" translate="yes" xml:space="preserve">
          <source>And now you can use it in accepts too:</source>
          <target state="translated">现在你也可以在accepts中使用它。</target>
        </trans-unit>
        <trans-unit id="2c4e72f0d50cebdec0f44072c0eaeb395f418357" translate="yes" xml:space="preserve">
          <source>And that's it for now. As you work on your project, we will add files and modules to this directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6096a937df9489c331022496b40ed0add88510d4" translate="yes" xml:space="preserve">
          <source>And the &lt;code&gt;render/2&lt;/code&gt; matching &lt;code&gt;&quot;show.json&quot;&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3d95105c6d043f42a186cb1cb95338bb3b8c9e5" translate="yes" xml:space="preserve">
          <source>And the plug will only be executed for the &lt;code&gt;index&lt;/code&gt; action.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="991f232167df9cd3bdbc26decca8e97ad1a93963" translate="yes" xml:space="preserve">
          <source>And then &lt;code&gt;assets/&lt;/code&gt; which should look similar to this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56ec252cb1d699087781a4616d1dc2ca2a889473" translate="yes" xml:space="preserve">
          <source>And then execute the query:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93eedaeceafc99ad0e82d5139f6dd534c247a1f9" translate="yes" xml:space="preserve">
          <source>And then in the client:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="472517d2f4a0e418d297e5ec5530acd44bec9147" translate="yes" xml:space="preserve">
          <source>And then in your views:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea31ee587d02a91a451bbdb640b8acd677a970c2" translate="yes" xml:space="preserve">
          <source>And then on the client:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd2adc164cca27fb8f1d47278c4947b99b757d83" translate="yes" xml:space="preserve">
          <source>And this is what the template should look like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f54c39fdeca73300d3e081fb2d149c7d1f6d5e7b" translate="yes" xml:space="preserve">
          <source>And to rate limit a volume up click to once every second:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bda7ca64d6a7be94ce39c9e370ab0974be1dea51" translate="yes" xml:space="preserve">
          <source>Animations - animations, menus, and general events that do not need the server in the first place are a bad fit for LiveView, as they can be achieved purely with CSS and/or CSS transitions;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="858ad2f63ffc7c337c04d12219e741685eb346ff" translate="yes" xml:space="preserve">
          <source>Annotates a plug will receive the options given to the current module itself as arguments</source>
          <target state="translated">注释一个插件将收到当前模块本身的选项作为参数。</target>
        </trans-unit>
        <trans-unit id="3ca7c7d5899dadd1120e30c45c0410c89a0f196d" translate="yes" xml:space="preserve">
          <source>Annotates a plug will receive the options given to the current module itself as arguments.</source>
          <target state="translated">注释一个插件将接收当前模块本身给出的选项作为参数。</target>
        </trans-unit>
        <trans-unit id="103998d4eb32a89668e537c98c324cc30584871c" translate="yes" xml:space="preserve">
          <source>Annotates the socket for navigation to another LiveView.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="892c24fb11c5b7e93791a977b684fdf1ceafbe45" translate="yes" xml:space="preserve">
          <source>Annotates the socket for navigation within the current LiveView.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8e5aa94673f39ee4dbbc53f7778394852216425" translate="yes" xml:space="preserve">
          <source>Annotates the socket for redirect to a destination path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="965a5d9407e704c6a66f6a80235a06c707d5d61f" translate="yes" xml:space="preserve">
          <source>Another New Page</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c7f32ee11fa615e66a13dec2e34a0dfb1c524e9" translate="yes" xml:space="preserve">
          <source>Another advantage of using schemas is that we no longer need to specify the select option in queries, as by default Ecto will retrieve all fields specified in the schema:</source>
          <target state="translated">使用模式的另一个好处是,我们不再需要在查询中指定选择选项,因为默认情况下Ecto会检索模式中指定的所有字段。</target>
        </trans-unit>
        <trans-unit id="d1c86f6d10d0bf2429514d920bb8250e03a07332" translate="yes" xml:space="preserve">
          <source>Another function in &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Ecto&lt;/code&gt;&lt;/a&gt; is &lt;a href=&quot;#build_assoc/3&quot;&gt;&lt;code&gt;build_assoc/3&lt;/code&gt;&lt;/a&gt;, which allows someone to build an associated struct with the proper fields:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3aef06e4e0539721c1ea8108e13b3694b5a7fb56" translate="yes" xml:space="preserve">
          <source>Another function in &lt;a href=&quot;ecto#content&quot;&gt;&lt;code&gt;Ecto&lt;/code&gt;&lt;/a&gt; is &lt;a href=&quot;#build_assoc/3&quot;&gt;&lt;code&gt;build_assoc/3&lt;/code&gt;&lt;/a&gt;, which allows someone to build an associated struct with the proper fields:</source>
          <target state="translated">&lt;a href=&quot;ecto#content&quot;&gt; &lt;code&gt;Ecto&lt;/code&gt; 中的&lt;/a&gt;另一个功能是&lt;a href=&quot;#build_assoc/3&quot;&gt; &lt;code&gt;build_assoc/3&lt;/code&gt; &lt;/a&gt;，它允许某人使用适当的字段构建关联的结构：</target>
        </trans-unit>
        <trans-unit id="3c094452b606f1027780eff1ec7f357c6e158a2c" translate="yes" xml:space="preserve">
          <source>Another limitation of components is that they must always be change tracked. For example, if you render a component inside &lt;code&gt;form_for&lt;/code&gt;, like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35452525e55bd9ad296aa31292df28fe37e9cef6" translate="yes" xml:space="preserve">
          <source>Another new Action</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87e0d97d55cdf75cee079b931b92c6f9771aa51e" translate="yes" xml:space="preserve">
          <source>Another new Route</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7c58fe3aff941a0ae5866b804e7906a16f18837" translate="yes" xml:space="preserve">
          <source>Another new Template</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed128006347c8b2ccd955b95f618e9b540afdae3" translate="yes" xml:space="preserve">
          <source>Another optimization done by &lt;code&gt;.leex&lt;/code&gt; templates is to track comprehensions. If your code has this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd51eafaf130785ca495e1b2d9c65d26d8d92ea8" translate="yes" xml:space="preserve">
          <source>Another option for flexibly building queries with joins are named bindings. Coming back to the previous example, provided we bind a join to a concrete name:</source>
          <target state="translated">另一种用join灵活构建查询的选择是命名绑定。回到前面的例子,只要我们将一个join绑定到一个具体的名称上。</target>
        </trans-unit>
        <trans-unit id="200acbdf3a75ec17dbadb3ee966de0aa5a5aec87" translate="yes" xml:space="preserve">
          <source>Another pitfall of &lt;code&gt;.leex&lt;/code&gt; templates is related to variables. Due to the scope of variables, LiveView has to disable change tracking whenever variables are used in the template, with the exception of variables introduced by Elixir basic &lt;code&gt;case&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt;, and other block constructs. Therefore, you &lt;strong&gt;must avoid&lt;/strong&gt; code like this in your LiveEEx:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73617edc1beeb9766f6f3e5570ec94af54a71244" translate="yes" xml:space="preserve">
          <source>Another security consideration is how to disconnect all instances of a given live user. For example, imagine the user logs outs, its account is terminated, or any other reason.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71a1d2bae841fd6d3cbb64b750fa8f6aa10792f8" translate="yes" xml:space="preserve">
          <source>Any element of the path can be dynamic:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="446a599b7f56e42924adcc359314759564aef04a" translate="yes" xml:space="preserve">
          <source>Any key in &lt;code&gt;on&lt;/code&gt; will apply to the currently joined expression.</source>
          <target state="translated">在任意键 &lt;code&gt;on&lt;/code&gt; 都会应用到当前加入表达。</target>
        </trans-unit>
        <trans-unit id="b582ea3bb7814c5e356182d52bb73802a875238e" translate="yes" xml:space="preserve">
          <source>Any number of optional &lt;code&gt;phx-value-&lt;/code&gt; prefixed attributes, such as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42fff788290a25f5f8125c374d15463e517d9097" translate="yes" xml:space="preserve">
          <source>Any of these routes may be nested.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="560e74426a5a7adb796c4d5bc65d55748987b23c" translate="yes" xml:space="preserve">
          <source>Any of these routes may be scoped to a given path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7975e28c47c5f1c7d5d84990d36a6f61381c95cb" translate="yes" xml:space="preserve">
          <source>Any of those choices can be disabled on a per choice basis by specifying the equivalent SSL option alongside the cipher suite.</source>
          <target state="translated">通过在密码套件旁边指定等效的SSL选项,可以在每个选择的基础上禁用其中任何一个选项。</target>
        </trans-unit>
        <trans-unit id="75f75593bfe3c7c9fa04ff0433e00417f5df7957" translate="yes" xml:space="preserve">
          <source>Any parameter that was not explicitly listed in the fields list will be ignored.</source>
          <target state="translated">任何没有在字段列表中明确列出的参数将被忽略。</target>
        </trans-unit>
        <trans-unit id="41770eb3e1ebe73b5cee06e82ee72c33af97f4d3" translate="yes" xml:space="preserve">
          <source>Any preload or select in the query will be ignored in favor of the column being aggregated.</source>
          <target state="translated">查询中的任何预加载或选择都将被忽略,以支持被聚合的列。</target>
        </trans-unit>
        <trans-unit id="4f8003575824cb241e72db8ad63398a3ff6314ed" translate="yes" xml:space="preserve">
          <source>Any process exit is treated as an error by the socket layer unless a &lt;code&gt;{:socket_close, pid, reason}&lt;/code&gt; message is sent to the socket before shutdown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="300cfabfd4866cec4228fbe86fd289ab17ee02d3" translate="yes" xml:space="preserve">
          <source>Any schema module will generate the &lt;code&gt;__schema__&lt;/code&gt; function that can be used for runtime introspection of the schema:</source>
          <target state="translated">任何模式模块都会生成 &lt;code&gt;__schema__&lt;/code&gt; 函数，该函数可用于模式的运行时自省：</target>
        </trans-unit>
        <trans-unit id="6e3a58d59ec917c307d1a1fb3de7a558a9eaf30c" translate="yes" xml:space="preserve">
          <source>Any schemas using &lt;code&gt;MyApp.Schema&lt;/code&gt; will get the &lt;code&gt;:id&lt;/code&gt; field with type &lt;code&gt;:binary_id&lt;/code&gt; as the primary key. We explain what the &lt;code&gt;:binary_id&lt;/code&gt; type entails in the next section.</source>
          <target state="translated">使用 &lt;code&gt;MyApp.Schema&lt;/code&gt; 的任何模式都将获取 &lt;code&gt;:id&lt;/code&gt; 字段，其类型为 &lt;code&gt;:binary_id&lt;/code&gt; 作为主键。在 &lt;code&gt;:binary_id&lt;/code&gt; 我们将说明：binary_id类型的含义。</target>
        </trans-unit>
        <trans-unit id="e0ebb8325f89e8834d39e539dc55c7e384f4c218" translate="yes" xml:space="preserve">
          <source>Any submit button on the form is disabled</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a47721bdd6f49dc71fd1d1d556d93aeac0052dc" translate="yes" xml:space="preserve">
          <source>Any topic coming into the router with the &lt;code&gt;&quot;room:&quot;&lt;/code&gt; prefix would dispatch to &lt;code&gt;MyApp.RoomChannel&lt;/code&gt; in the above example. Topics can also be pattern matched in your channels&amp;rsquo; &lt;code&gt;join/3&lt;/code&gt; callback to pluck out the scoped pattern:</source>
          <target state="translated">在上面的示例中，任何带有 &lt;code&gt;&quot;room:&quot;&lt;/code&gt; 前缀的路由器主题都将分派到 &lt;code&gt;MyApp.RoomChannel&lt;/code&gt; 。您还可以在频道的 &lt;code&gt;join/3&lt;/code&gt; 回调中对主题进行模式匹配，以获取范围限定的模式：</target>
        </trans-unit>
        <trans-unit id="c78b7ad84b8b92a86b6384a17069d524569aa3d2" translate="yes" xml:space="preserve">
          <source>Any topic coming into the router with the &lt;code&gt;&quot;room:&quot;&lt;/code&gt; prefix would dispatch to &lt;code&gt;MyApp.RoomChannel&lt;/code&gt; in the above example. Topics can also be pattern matched in your channels' &lt;code&gt;join/3&lt;/code&gt; callback to pluck out the scoped pattern:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7499220bee9b9eb7645271f804030e1f15a440df" translate="yes" xml:space="preserve">
          <source>Any valid query selector for &lt;code&gt;phx-target&lt;/code&gt; is supported, provided that the matched nodes are children of a LiveView or LiveComponent, for example to send the &lt;code&gt;close&lt;/code&gt; event to multiple components:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="380633ac14a276ca3da8d636824d32f161eeaebb" translate="yes" xml:space="preserve">
          <source>Any value can be used on the right-side of &lt;code&gt;in&lt;/code&gt; as long as it implements the &lt;a href=&quot;ecto.queryable&quot;&gt;&lt;code&gt;Ecto.Queryable&lt;/code&gt;&lt;/a&gt; protocol. For now, we know the protocol is implemented for both atoms (like &lt;code&gt;User&lt;/code&gt;) and strings (like &quot;users&quot;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f22fd2991e728e7d7b2e3f805e73ae5fa52bfbf" translate="yes" xml:space="preserve">
          <source>Any value can be used on the right-side of &lt;code&gt;in&lt;/code&gt; as long as it implements the &lt;a href=&quot;ecto.queryable&quot;&gt;&lt;code&gt;Ecto.Queryable&lt;/code&gt;&lt;/a&gt; protocol. For now, we know the protocol is implemented for both atoms (like &lt;code&gt;User&lt;/code&gt;) and strings (like &amp;ldquo;users&amp;rdquo;).</source>
          <target state="translated">只要实现&lt;a href=&quot;ecto.queryable&quot;&gt; &lt;code&gt;Ecto.Queryable&lt;/code&gt; &lt;/a&gt;协议，任何值都可以在 &lt;code&gt;in&lt;/code&gt; 的右侧使用。目前，我们知道该协议已针对原子（如 &lt;code&gt;User&lt;/code&gt; ）和字符串（如&amp;ldquo; users&amp;rdquo;）实现。</target>
        </trans-unit>
        <trans-unit id="b887cbd7add6f099fb444c6f2429533dcfaf8283" translate="yes" xml:space="preserve">
          <source>Appends the second multi to the first one</source>
          <target state="translated">将第二个倍数加到第一个倍数上</target>
        </trans-unit>
        <trans-unit id="b9edef6586142e33c6c60f9e0c8390125159a8a7" translate="yes" xml:space="preserve">
          <source>Appends the second multi to the first one.</source>
          <target state="translated">将第二个倍数加到第一个倍数上。</target>
        </trans-unit>
        <trans-unit id="1b1ea95f65514cccb0b50f920b09136d8b861a77" translate="yes" xml:space="preserve">
          <source>Applications with &quot;users&quot; are naturally heavily user driven. After all, our software is typically designed to be used by human end-users one way or another. Instead of extending our &lt;code&gt;Accounts.User&lt;/code&gt; struct to track every field and responsibility of our entire platform, it's better to keep those responsibilities with the modules who own that functionality. In our case, we can create a &lt;code&gt;CMS.Author&lt;/code&gt; struct that holds author specific fields as it relates to a CMS. Now we can place fields like &quot;role&quot; and &quot;bio&quot; here, where they naturally live. Likewise, we also gain specialized datastructures in our application that are suited to the domain that we are operating in, rather than a single &lt;code&gt;%User{}&lt;/code&gt; in the system that has to be everything to everyone.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="334894d99b92fe73d7e7aa140d76f7f561fafb65" translate="yes" xml:space="preserve">
          <source>Applies optimistic locking to the changeset</source>
          <target state="translated">对变更集进行优化锁定。</target>
        </trans-unit>
        <trans-unit id="4361b172649775394dfd72f667908efc6452872f" translate="yes" xml:space="preserve">
          <source>Applies optimistic locking to the changeset.</source>
          <target state="translated">对变化集进行优化锁定。</target>
        </trans-unit>
        <trans-unit id="09556e7e4517fe9725dfbd42cbf5a36cc2e87d68" translate="yes" xml:space="preserve">
          <source>Applies the changeset action if the changes are valid or raises an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="031274fb912bb51836441a5c22085b2001b18f45" translate="yes" xml:space="preserve">
          <source>Applies the changeset action only if the changes are valid</source>
          <target state="translated">只有在更改有效的情况下,才会应用更改集动作。</target>
        </trans-unit>
        <trans-unit id="b050c53ebe07c3d28361a411d8cbd7b0f72b7844" translate="yes" xml:space="preserve">
          <source>Applies the changeset action only if the changes are valid.</source>
          <target state="translated">只有在更改有效的情况下才会应用更改集动作。</target>
        </trans-unit>
        <trans-unit id="2761b7d6b04d3d8fdfdb82fe84e797e17b5c434a" translate="yes" xml:space="preserve">
          <source>Applies the changeset changes to the changeset data</source>
          <target state="translated">将变更集的变更应用到变更集数据上。</target>
        </trans-unit>
        <trans-unit id="58edcf307fce02ffe026656721ed37ef1c218b4f" translate="yes" xml:space="preserve">
          <source>Applies the changeset changes to the changeset data.</source>
          <target state="translated">将变更集的变更应用于变更集数据。</target>
        </trans-unit>
        <trans-unit id="f1c024b9973dc724f6ab98ed916d0ccb4c1312df" translate="yes" xml:space="preserve">
          <source>Applies the given &lt;code&gt;params&lt;/code&gt; as changes for the given &lt;code&gt;data&lt;/code&gt; according to the given set of &lt;code&gt;permitted&lt;/code&gt; keys. Returns a changeset</source>
          <target state="translated">根据给定的 &lt;code&gt;permitted&lt;/code&gt; 键集将给定的 &lt;code&gt;params&lt;/code&gt; 作为给定 &lt;code&gt;data&lt;/code&gt; 更改。返回变更集</target>
        </trans-unit>
        <trans-unit id="f1c1d0d5bec454128305edccd7c51e64e4e6fa92" translate="yes" xml:space="preserve">
          <source>Applies the given &lt;code&gt;params&lt;/code&gt; as changes for the given &lt;code&gt;data&lt;/code&gt; according to the given set of &lt;code&gt;permitted&lt;/code&gt; keys. Returns a changeset.</source>
          <target state="translated">根据给定的 &lt;code&gt;permitted&lt;/code&gt; 键集将给定的 &lt;code&gt;params&lt;/code&gt; 作为给定 &lt;code&gt;data&lt;/code&gt; 更改。返回一个变更集。</target>
        </trans-unit>
        <trans-unit id="86680b93bfe5f3d5e136ea751760d9739bc9e99c" translate="yes" xml:space="preserve">
          <source>Applies the given expression as a FILTER clause against an aggregate. This is currently only supported by Postgres</source>
          <target state="translated">将给定的表达式作为FILTER子句应用于一个集合。目前只有Postgres支持。</target>
        </trans-unit>
        <trans-unit id="0ea218082f0918b6c6d6196ff4808dba4c0ad11c" translate="yes" xml:space="preserve">
          <source>Applies the given expression as a FILTER clause against an aggregate. This is currently only supported by Postgres.</source>
          <target state="translated">将给定的表达式作为FILTER子句应用于一个集合。目前只有Postgres支持这个功能。</target>
        </trans-unit>
        <trans-unit id="4400f576bc0c89e7f88b6372000ac8456cf2427f" translate="yes" xml:space="preserve">
          <source>Applying a limit to the association can be achieved with &lt;code&gt;inner_lateral_join&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbb9fa252e60809efa55a7ad83aea5438ef56753" translate="yes" xml:space="preserve">
          <source>Arguments</source>
          <target state="translated">Arguments</target>
        </trans-unit>
        <trans-unit id="12ba74c0de8af933a3a3f56bbea3b38757e06f95" translate="yes" xml:space="preserve">
          <source>Arithmetic operators: &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;</source>
          <target state="translated">算术运算符： &lt;code&gt;+&lt;/code&gt; ， &lt;code&gt;-&lt;/code&gt; ， &lt;code&gt;*&lt;/code&gt; ， &lt;code&gt;/&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7aee5aacb98321221728d086e57edc8138d0ba9b" translate="yes" xml:space="preserve">
          <source>Arrays: &lt;code&gt;[1, 2, 3]&lt;/code&gt;, &lt;code&gt;~w(interpolate words)&lt;/code&gt;</source>
          <target state="translated">数组： &lt;code&gt;[1, 2, 3]&lt;/code&gt; ， &lt;code&gt;~w(interpolate words)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b1a93145914c19a817e2f83d25abe14b25ed5208" translate="yes" xml:space="preserve">
          <source>As a convenience, &lt;code&gt;select&lt;/code&gt; allows developers to take fields without an explicit call to &lt;a href=&quot;#struct/2&quot;&gt;&lt;code&gt;struct/2&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">为方便起见， &lt;code&gt;select&lt;/code&gt; 允许开发人员采用字段而无需显式调用&lt;a href=&quot;#struct/2&quot;&gt; &lt;code&gt;struct/2&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="c498ddcfc7c00342094648686289bc00b3b0dc5c" translate="yes" xml:space="preserve">
          <source>As an example, imagine &lt;code&gt;:title&lt;/code&gt; is marked as a unique column in the database:</source>
          <target state="translated">例如，假设 &lt;code&gt;:title&lt;/code&gt; 被标记为数据库中的唯一列：</target>
        </trans-unit>
        <trans-unit id="79d5d9b16bafc29af957487e6b081f397b4bee65" translate="yes" xml:space="preserve">
          <source>As an example, let's take the &lt;code&gt;PageController&lt;/code&gt; index action from a newly generated app. Out of the box, this has the right view, &lt;code&gt;PageView&lt;/code&gt;, the right templates directory, &lt;code&gt;lib/hello_web/templates/page&lt;/code&gt;, and the right template for rendering HTML, &lt;code&gt;index.html.eex&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3ac25f18fe082956a1b5832c11ba04b5460ef65" translate="yes" xml:space="preserve">
          <source>As an umbrella:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ede5a74258fd5fb816fbcfefa32286c05d2157f3" translate="yes" xml:space="preserve">
          <source>As any other Plug, we can use the &lt;code&gt;basic_auth&lt;/code&gt; at runtime by simply wrapping it in a function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a23b6d0328db4bd7b84c97eaea8ba3456c0bd022" translate="yes" xml:space="preserve">
          <source>As are the variables matched defined in a &lt;code&gt;case&lt;/code&gt; or &lt;code&gt;cond&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fddced341e63f42b257c605c248116bc9912aea3" translate="yes" xml:space="preserve">
          <source>As controllers are plugs, they implement both &lt;code&gt;init/1&lt;/code&gt; and &lt;code&gt;call/2&lt;/code&gt;, and it also provides a function named &lt;code&gt;action/2&lt;/code&gt; which is responsible for dispatching the appropriate action after the plug stack (and is also overridable).</source>
          <target state="translated">由于控制器是插件，因此它们同时实现 &lt;code&gt;init/1&lt;/code&gt; 和 &lt;code&gt;call/2&lt;/code&gt; ，并且还提供一个名为 &lt;code&gt;action/2&lt;/code&gt; 的函数，该函数负责在插件堆栈之后分派适当的操作（并且也是可重写的）。</target>
        </trans-unit>
        <trans-unit id="2f2c06fb780697e369f25f7c87ee7118c0b20715" translate="yes" xml:space="preserve">
          <source>As in your application, the connection is also the main abstraction in testing. &lt;code&gt;build_conn()&lt;/code&gt; returns a new connection and functions in this module can be used to manipulate the connection before dispatching to the endpoint.</source>
          <target state="translated">与您的应用程序一样，连接也是测试中的主要抽象。 &lt;code&gt;build_conn()&lt;/code&gt; 返回一个新的连接，此模块中的函数可在分派给端点之前用于操纵该连接。</target>
        </trans-unit>
        <trans-unit id="b210531fbb3bd27c9f7aaf52afc8d05c910d1cc5" translate="yes" xml:space="preserve">
          <source>As in your router and controllers, the connection is the main abstraction in testing. &lt;code&gt;build_conn()&lt;/code&gt; returns a new connection and functions in this module can be used to manipulate the connection before dispatching to the endpoint.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c796c7f3ac16197066e697bf71c6c72770c4ba4d" translate="yes" xml:space="preserve">
          <source>As long as the parent LiveView subscribes to the &quot;board:ID&quot; topic, it will receive updates. The advantage of using PubSub is that we get distributed updates out of the box. Now, if any user connected to the board changes a card, all other users will see the change.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="808d46d3e3e0f6f7f131fef1fd1b60fe8faaf80e" translate="yes" xml:space="preserve">
          <source>As long as we change the action name in the &lt;code&gt;PageController&lt;/code&gt; to &lt;code&gt;test&lt;/code&gt; as well, the welcome page will load as before.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cff517968c1c330a71aa1134978cf184158a1dc9" translate="yes" xml:space="preserve">
          <source>As of early 2020, the following avoids these pitfalls and will likely serve your application's needs and users much better. According to &lt;a href=&quot;https://caniuse.com/#search=inputmode&quot;&gt;https://caniuse.com/#search=inputmode&lt;/a&gt;, the following is supported by 90% of the global mobile market with Firefox yet to implement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c0636dd8dd5611c756ba959ee083d5a9473b102" translate="yes" xml:space="preserve">
          <source>As seen earlier, you start by instantiating a single LiveSocket to enable LiveView client/server interaction, for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="229436c1260793d8c0dc3e318e1138522f1fb3f4" translate="yes" xml:space="preserve">
          <source>As the list of cards in the parent socket was updated, the parent will be re-rendered, sending the updated card to the component. So in the end, the component does get the updated card, but always driven from the parent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9152bca7977631eb6dcbaafbab88915d2ad4c4e4" translate="yes" xml:space="preserve">
          <source>As the name says, a constraint is required in the database for this function to work. Such constraint is often added as a reference to the child table:</source>
          <target state="translated">顾名思义,这个函数的工作需要数据库中的一个约束。这种约束条件通常是作为对子表的引用添加的。</target>
        </trans-unit>
        <trans-unit id="ba940f8fbd73fccb95624e24614ba319a8d87947" translate="yes" xml:space="preserve">
          <source>As their names suggest, the &lt;code&gt;:browser&lt;/code&gt; pipeline prepares for routes which render requests for a browser. The &lt;code&gt;:api&lt;/code&gt; pipeline prepares for routes which produce data for an api.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16ef7ec7284c632cb98296deb90a681d81b3ec19" translate="yes" xml:space="preserve">
          <source>As this configuration is Plug specific, Plug will need to be recompiled for the changes to take place: this will not happen automatically as dependencies are not automatically recompiled when their configuration changes. To recompile Plug:</source>
          <target state="translated">由于该配置是特定于Plug的,因此需要重新编译Plug以实现更改:这不会自动发生,因为当依赖关系的配置发生变化时,不会自动重新编译。要重新编译Plug。</target>
        </trans-unit>
        <trans-unit id="3aa8f57e35993de6767035bb3d069ba1ccc735ac" translate="yes" xml:space="preserve">
          <source>As we built our first page, we could start to understand how the request life-cycle is put together. Now let's take a more holistic look at it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="334d7e352cb7a7f766913827757bcf8b0f35ec8d" translate="yes" xml:space="preserve">
          <source>As we can see, we're calling &lt;code&gt;render/3&lt;/code&gt; with the individual view responsible for our test template, the name of our test template, and an empty map representing any assigns we might have wanted to pass in. The return value is a tuple beginning with the atom &lt;code&gt;:safe&lt;/code&gt; and the resultant io list of the interpolated template. &quot;Safe&quot; here means that Phoenix has escaped the contents of our rendered template to avoid XSS injection attacks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="429b7898d95292088a6a9ba5f3da7941b7fe802e" translate="yes" xml:space="preserve">
          <source>As we did last time, the first thing we'll do is create a new route.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9b4bd0b6a2cd5027da43fb01f182776ca3485b6" translate="yes" xml:space="preserve">
          <source>As we explored the context API, you might have wondered:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7457e7f50b46549cb637fd1cddab7ebcad06d948" translate="yes" xml:space="preserve">
          <source>As we have seen, LiveView begins its life-cycle as a regular HTTP request. Then a stateful connection is established. Both the HTTP request and the stateful connection receives the client data via parameters and session. This means that any session validation must happen both in the HTTP request and the stateful connection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c0bcd2ed6f294fc4464e5815ba90d6d66fe1e74" translate="yes" xml:space="preserve">
          <source>As we will see in &lt;a href=&quot;routing&quot;&gt;the Routing guide&lt;/a&gt;, the pipelines themselves are plugs. There we will also discuss all plugs in the &lt;code&gt;:browser&lt;/code&gt; pipeline.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec4b354848c4c238d7f3d05ba632a1e321221959" translate="yes" xml:space="preserve">
          <source>As we've seen throughout this guide, both mix itself and the dependencies we bring in to our application provide a number of really useful tasks for free. Since neither of these could possibly anticipate all our individual application's needs, mix allows us to create our own custom tasks. That's exactly what we are going to do now.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="871be10c0f7df0592f19a11a6e110ad51e1ddfdc" translate="yes" xml:space="preserve">
          <source>As we've seen, designing with contexts gives you a solid foundation to grow your application from. Using discrete, well-defined APIs that expose the intent of your system allows you to write more maintainable applications with reusable code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60ff1bbd92ceef868ed8e4680400f13d86c1a3bc" translate="yes" xml:space="preserve">
          <source>As we've seen, your context modules are dedicated modules that expose and group related functionality. Phoenix generates generic functions, such as &lt;code&gt;list_users&lt;/code&gt; and &lt;code&gt;update_user&lt;/code&gt;, but they only serve as a basis for you to grow your business logic and application from. To begin extending our &lt;code&gt;Accounts&lt;/code&gt; context with real features, let's address an obvious issue of our application &amp;ndash; we can create users with credentials in our system, but they have no way of signing in with those credentials. Building a complete user authentication system is beyond the scope of this guide, but let's get started with a basic email-only sign-in page that allows us to track a current user's session. This will let us focus on extending our &lt;code&gt;Accounts&lt;/code&gt; context while giving you a good start to grow a complete authentication solution from.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d28976d77d0ac5ae799851b8fa02ff44a5eea6d9" translate="yes" xml:space="preserve">
          <source>As with &lt;a href=&quot;#render_submit/2&quot;&gt;&lt;code&gt;render_submit/2&lt;/code&gt;&lt;/a&gt;, hidden input field values can be provided like so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a063bfa11fd130bfec49f4aa0ff0c57a16e8ade9" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;where&lt;/code&gt; and friends, it is not possible to pass dynamics outside of a root. For example, this won't work:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ef18598d1271d2d73abb69726ba544c972e24be" translate="yes" xml:space="preserve">
          <source>As with any other Elixir code, exceptions may happen during the LiveView life-cycle. In this section we will describe how LiveView reacts to errors at different stages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9df39041001cb183a32f86f88c0a2f7d5beaded" translate="yes" xml:space="preserve">
          <source>As with other &lt;code&gt;handle_*&lt;/code&gt; callback, changes to the state inside &lt;a href=&quot;phoenix.liveview#c:handle_params/3&quot;&gt;&lt;code&gt;handle_params/3&lt;/code&gt;&lt;/a&gt; will trigger a server render.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="868db82198436ae137106ae18a1c27c3628d32a7" translate="yes" xml:space="preserve">
          <source>As with routers, controllers also have their own plug pipeline. However, different from routers, controllers have a single pipeline:</source>
          <target state="translated">与路由器一样,控制器也有自己的插件管道。但与路由器不同的是,控制器的管道只有一条。</target>
        </trans-unit>
        <trans-unit id="a13b8d369d8e5d9d561d4e6a9af6e49bd6113fb8" translate="yes" xml:space="preserve">
          <source>As you follow along with this guide, we will introduce you to the core concepts of Telemetry, you will initialize a reporter to capture your application's events as they occur, and we will guide you through the steps to properly instrument your own functions using &lt;code&gt;:telemetry&lt;/code&gt;. Let's take a closer look at how Telemetry works in your application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58211b3a044ad9d59816ab93e7995e3ad07c0dae" translate="yes" xml:space="preserve">
          <source>As you may recall, Elixir templates use Embedded Elixir, known as &lt;a href=&quot;https://hexdocs.pm/eex/EEx.html&quot;&gt;&lt;code&gt;EEx&lt;/code&gt;&lt;/a&gt;. We use &lt;code&gt;&amp;lt;%= expression %&amp;gt;&lt;/code&gt; to execute Elixir expressions. The result of the expression is interpolated into the template. You can use pretty much any Elixir expression. For example, in order to have conditionals:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71076af94cd1aff015f5fde9464389c381fb4d31" translate="yes" xml:space="preserve">
          <source>As you may suspect, keeping the whole chat conversation in memory and resending it on every update would be too expensive, even with LiveView smart change tracking. By using temporary assigns and phx-update, we don't need to keep any messages in memory, and send messages to be appended to the UI only when there are new ones.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f633ddebff9318c264a20f27c58016efb19bd167" translate="yes" xml:space="preserve">
          <source>Ask or answer questions about Phoenix on &lt;a href=&quot;https://elixirforum.com/c/phoenix-forum&quot;&gt;Elixir Forum&lt;/a&gt; or &lt;a href=&quot;http://stackoverflow.com/questions/tagged/phoenix-framework&quot;&gt;Stack Overflow&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="475b9e09b92d98b6d96cb1e2b9b95148e9c2b0c7" translate="yes" xml:space="preserve">
          <source>Asks if the user wants to open a file based on ECTO_EDITOR</source>
          <target state="translated">询问用户是否要打开一个基于ECTO_EDITOR的文件。</target>
        </trans-unit>
        <trans-unit id="006f6f8b5cb840127d26d2d28ee9849be1f8d9fc" translate="yes" xml:space="preserve">
          <source>Asks if the user wants to open a file based on ECTO_EDITOR.</source>
          <target state="translated">询问用户是否要打开一个基于ECTO_EDITOR的文件。</target>
        </trans-unit>
        <trans-unit id="6dc21f6456de8c94602f412eaba76e77b8fa179d" translate="yes" xml:space="preserve">
          <source>Asserts a hook reply was returned from a &lt;code&gt;handle_event&lt;/code&gt; callback.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adaf4cf4c61a7303edd08b21684c8eab128ddeed" translate="yes" xml:space="preserve">
          <source>Asserts a live patch was performed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="969492330997b420ecd871d0cc0056d6d9e9bf2e" translate="yes" xml:space="preserve">
          <source>Asserts a live patch will happen within &lt;code&gt;timeout&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="812a6202573bcb920f610b23008af522ed8d26cc" translate="yes" xml:space="preserve">
          <source>Asserts a redirect was performed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23de39b8a1ad126d48631687777de4468b1fcbce" translate="yes" xml:space="preserve">
          <source>Asserts a redirect will happen within &lt;code&gt;timeout&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb8d826fc68bb29920fcc1466f25e2e36d3d47b6" translate="yes" xml:space="preserve">
          <source>Asserts an error was wrapped and sent with the given status</source>
          <target state="translated">断言一个错误被包装并以给定的状态发送。</target>
        </trans-unit>
        <trans-unit id="14dacb2eaf39d88a53c805aade746d59005bd40d" translate="yes" xml:space="preserve">
          <source>Asserts an error was wrapped and sent with the given status.</source>
          <target state="translated">断言一个错误被包装并以给定的状态发送。</target>
        </trans-unit>
        <trans-unit id="6dab300ce3e8854ad3067c32d62ed6ade4f7b216" translate="yes" xml:space="preserve">
          <source>Asserts an event will be pushed within &lt;code&gt;timeout&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f561847fbcc30ef099c2fdb4d7f9ecbb769368b9" translate="yes" xml:space="preserve">
          <source>Asserts the channel has broadcast a message within &lt;code&gt;timeout&lt;/code&gt;</source>
          <target state="translated">断言通道已在 &lt;code&gt;timeout&lt;/code&gt; 内广播消息</target>
        </trans-unit>
        <trans-unit id="69c1aafea3e15d75f9b8e5e7f4b7ee180908fa25" translate="yes" xml:space="preserve">
          <source>Asserts the channel has broadcast a message within &lt;code&gt;timeout&lt;/code&gt;.</source>
          <target state="translated">断言该频道已在 &lt;code&gt;timeout&lt;/code&gt; 内广播了一条消息。</target>
        </trans-unit>
        <trans-unit id="c1e0c079e28ea0e490465ee00c1b2e6b15935463" translate="yes" xml:space="preserve">
          <source>Asserts the channel has not broadcast a message within &lt;code&gt;timeout&lt;/code&gt;</source>
          <target state="translated">断言通道未在 &lt;code&gt;timeout&lt;/code&gt; 内广播消息</target>
        </trans-unit>
        <trans-unit id="c140d2f9a5c6e70b4bddb0b29be0b82e3d7034fa" translate="yes" xml:space="preserve">
          <source>Asserts the channel has not broadcast a message within &lt;code&gt;timeout&lt;/code&gt;.</source>
          <target state="translated">断言通道未在 &lt;code&gt;timeout&lt;/code&gt; 内广播消息。</target>
        </trans-unit>
        <trans-unit id="d424205c41f2118eb9fd5a7f0610874508d900e3" translate="yes" xml:space="preserve">
          <source>Asserts the channel has not pushed a message to the client matching the given event and payload within &lt;code&gt;timeout&lt;/code&gt;</source>
          <target state="translated">断言通道未在 &lt;code&gt;timeout&lt;/code&gt; 内将与给定事件和有效负载匹配的消息推送到客户端</target>
        </trans-unit>
        <trans-unit id="dd195750fce0de0311eeab0dd8758295106faf6a" translate="yes" xml:space="preserve">
          <source>Asserts the channel has not pushed a message to the client matching the given event and payload within &lt;code&gt;timeout&lt;/code&gt;.</source>
          <target state="translated">断言通道未在 &lt;code&gt;timeout&lt;/code&gt; 内将与给定事件和有效负载匹配的消息推送到客户端。</target>
        </trans-unit>
        <trans-unit id="f37dd31b07d6e30495dbce12a320ab6f115b7072" translate="yes" xml:space="preserve">
          <source>Asserts the channel has not replied with a matching payload within &lt;code&gt;timeout&lt;/code&gt;</source>
          <target state="translated">断言通道未在 &lt;code&gt;timeout&lt;/code&gt; 内回复匹配的有效负载</target>
        </trans-unit>
        <trans-unit id="f543c3267625ded4bf34a8f8595eb6f80560c8b7" translate="yes" xml:space="preserve">
          <source>Asserts the channel has not replied with a matching payload within &lt;code&gt;timeout&lt;/code&gt;.</source>
          <target state="translated">断言该通道未在 &lt;code&gt;timeout&lt;/code&gt; 内回复匹配的有效负载。</target>
        </trans-unit>
        <trans-unit id="fb8e710870c1e8f2ae11881ad6a7b9f893cf92f6" translate="yes" xml:space="preserve">
          <source>Asserts the channel has pushed a message back to the client with the given event and payload within &lt;code&gt;timeout&lt;/code&gt;</source>
          <target state="translated">断言通道已将消息与 &lt;code&gt;timeout&lt;/code&gt; 内的给定事件和有效负载推回客户端</target>
        </trans-unit>
        <trans-unit id="6fb7f0ad50740a6b05d2126fa477ce96ef0a8211" translate="yes" xml:space="preserve">
          <source>Asserts the channel has pushed a message back to the client with the given event and payload within &lt;code&gt;timeout&lt;/code&gt;.</source>
          <target state="translated">断言通道已将消息与 &lt;code&gt;timeout&lt;/code&gt; 内的给定事件和有效负载推回给客户端。</target>
        </trans-unit>
        <trans-unit id="c887a57a1301c3376a8b187b83da77d3b9304d5f" translate="yes" xml:space="preserve">
          <source>Asserts the channel has replied to the given message within &lt;code&gt;timeout&lt;/code&gt;</source>
          <target state="translated">断言通道已在 &lt;code&gt;timeout&lt;/code&gt; 内回复给定消息</target>
        </trans-unit>
        <trans-unit id="6ddf47c3c727b5b98212842dc153fb9ef73dfb67" translate="yes" xml:space="preserve">
          <source>Asserts the channel has replied to the given message within &lt;code&gt;timeout&lt;/code&gt;.</source>
          <target state="translated">断言通道已在 &lt;code&gt;timeout&lt;/code&gt; 内回复给定消息。</target>
        </trans-unit>
        <trans-unit id="ea30be74b1b6dfeafbc74b5278e93a1ef8635f78" translate="yes" xml:space="preserve">
          <source>Asserts the given status code and returns the response body if one was set or sent</source>
          <target state="translated">断言给定的状态码,如果设置或发送了状态码,则返回响应体。</target>
        </trans-unit>
        <trans-unit id="40aec7b844428bccf332b76d4a7cea4d73c9f80b" translate="yes" xml:space="preserve">
          <source>Asserts the given status code and returns the response body if one was set or sent.</source>
          <target state="translated">断言给定的状态码,如果设置或发送了状态码,则返回响应体。</target>
        </trans-unit>
        <trans-unit id="92eed7d512a2ff5c15049fbde292f3357c386ba4" translate="yes" xml:space="preserve">
          <source>Asserts the given status code, that we have a json response and returns the decoded JSON response if one was set or sent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="519c68c331196b4f0042ee79374fcbf0eb6379f0" translate="yes" xml:space="preserve">
          <source>Asserts the given status code, that we have a text response and returns the response body if one was set or sent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4361d343642668ab91330760dcb1e9daf427439b" translate="yes" xml:space="preserve">
          <source>Asserts the given status code, that we have an html response and returns the response body if one was set or sent</source>
          <target state="translated">断言给定的状态码,我们有一个html响应,并返回响应体(如果有设置或发送)。</target>
        </trans-unit>
        <trans-unit id="01ce9d8e19df4acc7484e73368b791392c2f5b64" translate="yes" xml:space="preserve">
          <source>Asserts the given status code, that we have an html response and returns the response body if one was set or sent.</source>
          <target state="translated">断言给定的状态码,我们有一个html响应,并返回响应体,如果一个响应体被设置或发送。</target>
        </trans-unit>
        <trans-unit id="94ee684deb18054648b499b661eaeadc364ac50c" translate="yes" xml:space="preserve">
          <source>Asserts the given status code, that we have an json response and returns the decoded JSON response if one was set or sent</source>
          <target state="translated">断言给定的状态码,我们有一个json响应,并返回解码后的JSON响应,如果设置或发送了JSON响应的话</target>
        </trans-unit>
        <trans-unit id="ad672702a882d944ba4089007ddd2cb6a47abb2f" translate="yes" xml:space="preserve">
          <source>Asserts the given status code, that we have an json response and returns the decoded JSON response if one was set or sent.</source>
          <target state="translated">断言给定的状态码,我们有一个json响应,并返回解码的JSON响应,如果一个被设置或发送。</target>
        </trans-unit>
        <trans-unit id="0b22bfbfa6302d6cc628263305e33e5e5b9d808c" translate="yes" xml:space="preserve">
          <source>Asserts the given status code, that we have an text response and returns the response body if one was set or sent</source>
          <target state="translated">断言给定的状态码,我们有一个文本响应,并返回响应体,如果设置或发送了一个响应体</target>
        </trans-unit>
        <trans-unit id="d7d64fc3c8c80b2f0927ca8acf2d9a14e5e45982" translate="yes" xml:space="preserve">
          <source>Asserts the given status code, that we have an text response and returns the response body if one was set or sent.</source>
          <target state="translated">断言给定的状态码,我们有一个文本响应,并返回响应体,如果有一个设置或发送。</target>
        </trans-unit>
        <trans-unit id="9cdf03c483d1adf4976212ba47ed8fb5319fbdac" translate="yes" xml:space="preserve">
          <source>Assigning Layouts</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f2a0cc5f167ef3113974a9fe34af5506e805041" translate="yes" xml:space="preserve">
          <source>Assigns</source>
          <target state="translated">Assigns</target>
        </trans-unit>
        <trans-unit id="574364eee69f68c55eb9dcc71dd468285d889db6" translate="yes" xml:space="preserve">
          <source>Assigns a new &lt;strong&gt;private&lt;/strong&gt; key and value in the connection</source>
          <target state="translated">在连接中分配新的&lt;strong&gt;私钥&lt;/strong&gt;和值</target>
        </trans-unit>
        <trans-unit id="bd83d5499e834c53bd79fb4fa56ff025df78093c" translate="yes" xml:space="preserve">
          <source>Assigns a new &lt;strong&gt;private&lt;/strong&gt; key and value in the connection.</source>
          <target state="translated">在连接中分配新的&lt;strong&gt;私钥&lt;/strong&gt;和值。</target>
        </trans-unit>
        <trans-unit id="7a78ed34e6eee12d271b969d452bf691c6a1c3b5" translate="yes" xml:space="preserve">
          <source>Assigns a value into the socket only if it does not exist.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee9efccff63c64323b5a4f98fca8d2c724142663" translate="yes" xml:space="preserve">
          <source>Assigns a value to a key in the connection</source>
          <target state="translated">为连接中的键赋值。</target>
        </trans-unit>
        <trans-unit id="da5add16ce8a8cf627204ed4d5648a3d1ca3a351" translate="yes" xml:space="preserve">
          <source>Assigns a value to a key in the connection.</source>
          <target state="translated">为连接中的键赋值。</target>
        </trans-unit>
        <trans-unit id="ad133374d6d5235b0b1fd7164e56e8711c4ef530" translate="yes" xml:space="preserve">
          <source>Assigns and LiveEEx</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbe95ee0ca00c4adc99619cc358095693451bc12" translate="yes" xml:space="preserve">
          <source>Assigns and LiveEEx templates</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c6b589d013aaba3d63ab9b088addc693226eaa6" translate="yes" xml:space="preserve">
          <source>Assigns are meant to be user data that will be available in templates. However, there are keys under assigns that are specially handled by Phoenix, they are:</source>
          <target state="translated">赋值的本意是用户数据,在模板中会有。但是,在assigns下有一些键是由Phoenix特别处理的,它们是。</target>
        </trans-unit>
        <trans-unit id="147d0c86a092ea030ef3bda841fe74477ec9e5a7" translate="yes" xml:space="preserve">
          <source>Assigns multiple &lt;strong&gt;private&lt;/strong&gt; keys and values in the connection</source>
          <target state="translated">在连接中分配多个&lt;strong&gt;私钥&lt;/strong&gt;和值</target>
        </trans-unit>
        <trans-unit id="757ea09ed7848c39bfeb25a79e148f85064a7e1a" translate="yes" xml:space="preserve">
          <source>Assigns multiple &lt;strong&gt;private&lt;/strong&gt; keys and values in the connection.</source>
          <target state="translated">在连接中分配多个&lt;strong&gt;私钥&lt;/strong&gt;和值。</target>
        </trans-unit>
        <trans-unit id="a6dddc082668f89921e5bc9a19c53fadbba95e74" translate="yes" xml:space="preserve">
          <source>Assigns multiple values to keys in the connection</source>
          <target state="translated">为连接中的键分配多个值</target>
        </trans-unit>
        <trans-unit id="6cc9a184a076e8b32ad317761089937067633e4a" translate="yes" xml:space="preserve">
          <source>Assigns multiple values to keys in the connection.</source>
          <target state="translated">为连接中的键分配多个值。</target>
        </trans-unit>
        <trans-unit id="134d6b41e63f8d58f043111b94e89dcdbcc5edb8" translate="yes" xml:space="preserve">
          <source>Associations</source>
          <target state="translated">Associations</target>
        </trans-unit>
        <trans-unit id="b802e5b1cff34526d856a0a100a2dbbb152b074d" translate="yes" xml:space="preserve">
          <source>Associations, embeds and on replace</source>
          <target state="translated">关联、嵌入和替换</target>
        </trans-unit>
        <trans-unit id="56f8a2dd87419ea091ce075611de251ffc698b80" translate="yes" xml:space="preserve">
          <source>Assuming the above code, a request to &lt;code&gt;/users/sign_in&lt;/code&gt; will be forwarded to the &lt;code&gt;UserRouter&lt;/code&gt; plug, which will receive what it will see as a request to &lt;code&gt;/sign_in&lt;/code&gt;.</source>
          <target state="translated">假设上面的代码，对 &lt;code&gt;/users/sign_in&lt;/code&gt; 的请求将转发到 &lt;code&gt;UserRouter&lt;/code&gt; 插件，后者将收到对 &lt;code&gt;/sign_in&lt;/code&gt; 的请求。</target>
        </trans-unit>
        <trans-unit id="c804cad0774fdc88933e3e582b28b80f3857c48a" translate="yes" xml:space="preserve">
          <source>Assuming we have a &lt;code&gt;Post&lt;/code&gt; schema (stored in the &lt;code&gt;posts&lt;/code&gt; table), the first step is to add a version column to the &lt;code&gt;posts&lt;/code&gt; table:</source>
          <target state="translated">假设我们有一个 &lt;code&gt;Post&lt;/code&gt; 模式（存储在 &lt;code&gt;posts&lt;/code&gt; 表中），第一步是将一个version列添加到 &lt;code&gt;posts&lt;/code&gt; 表中：</target>
        </trans-unit>
        <trans-unit id="86c8bfff0642e8f1e006970ab9967dd6f94624c9" translate="yes" xml:space="preserve">
          <source>Asynchronously updates a &lt;a href=&quot;phoenix.livecomponent&quot;&gt;&lt;code&gt;Phoenix.LiveComponent&lt;/code&gt;&lt;/a&gt; with new assigns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="730f20a52e86a944cd13ad339e3ca66cf8875996" translate="yes" xml:space="preserve">
          <source>At the end of the day, a LiveView is nothing more than a process that receives events as messages and updates its state. The state itself is nothing more than functional and immutable Elixir data structures. The events are either internal application messages (usually emitted by &lt;a href=&quot;../phoenix_pubsub/phoenix.pubsub&quot;&gt;&lt;code&gt;Phoenix.PubSub&lt;/code&gt;&lt;/a&gt;) or sent by the client/browser.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5aebdf401ce4f348f998b1ebf4d450c362241ea4" translate="yes" xml:space="preserve">
          <source>At the end of the day, by replacing the nested blocks of code with a flattened series of plug transformations, we are able to achieve the same functionality in a much more composable, clear, and reusable way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5af8f720335af4138486691722f60532c39d648f" translate="yes" xml:space="preserve">
          <source>At the end of the day, our templates are always compiled into Elixir code. Let's learn more about this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14e654e0b50eb6a926a4d9b3a00a855ad5876525" translate="yes" xml:space="preserve">
          <source>At the end of the day, regardless if you invoke &lt;a href=&quot;../phoenix_html/phoenix.html.link#link/2&quot;&gt;&lt;code&gt;link/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;phoenix.liveview.helpers#live_patch/2&quot;&gt;&lt;code&gt;live_patch/2&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;phoenix.liveview.helpers#live_redirect/2&quot;&gt;&lt;code&gt;live_redirect/2&lt;/code&gt;&lt;/a&gt; from the client, or &lt;a href=&quot;../phoenix/phoenix.controller#redirect/2&quot;&gt;&lt;code&gt;redirect/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;phoenix.liveview#push_patch/2&quot;&gt;&lt;code&gt;push_patch/2&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;phoenix.liveview#push_redirect/2&quot;&gt;&lt;code&gt;push_redirect/2&lt;/code&gt;&lt;/a&gt; from the server, the user will end-up on the same page. The difference between those is mostly the amount of data sent over the wire:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56b36c55a19e26ff96a0b6dd23511c3329ef78c0" translate="yes" xml:space="preserve">
          <source>At the end of this section, you must have installed Elixir, Hex, Phoenix, PostgreSQL and node.js. Now that we have everything installed, let's create our first Phoenix application and get &lt;a href=&quot;up_and_running&quot;&gt;up and running&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed0b9aa74251acf133476dd7a1fb25e39fd253e6" translate="yes" xml:space="preserve">
          <source>At the end sets the connection state to &lt;code&gt;:sent&lt;/code&gt;.</source>
          <target state="translated">最后，将连接状态设置为 &lt;code&gt;:sent&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c5c2f85717edc27497c79c08aabb877d7e0f9cec" translate="yes" xml:space="preserve">
          <source>At the moment, using a schema with source fields in CTE may emit invalid queries. If you are running into such scenarios, your best option is to use a fragment as your CTE.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="475bdea221d93e5676e928712140b57516957c55" translate="yes" xml:space="preserve">
          <source>At the simplest level, the Plug specification comes in two flavors: &lt;em&gt;function plugs&lt;/em&gt; and &lt;em&gt;module plugs&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7efd02772e9aae7a884306c7395cc454402ec969" translate="yes" xml:space="preserve">
          <source>At this moment, you may be thinking this can be a lot of steps to simply render a page. However, as our application grows in complexity, we will see that each layer serves a distinct purpose:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4927c7da0be48fa0923cc88982ae3b251f69456" translate="yes" xml:space="preserve">
          <source>Atoms (other than booleans and &lt;code&gt;nil&lt;/code&gt;): &lt;code&gt;:foo&lt;/code&gt;, &lt;code&gt;:bar&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4272dc1f3f36ae0db4df38f283b5fe8748a6ff3" translate="yes" xml:space="preserve">
          <source>Attempts to parse the connection&amp;rsquo;s request body given the content-type type, subtype, and its parameters</source>
          <target state="translated">给定内容类型，子类型及其参数，尝试解析连接的请求主体</target>
        </trans-unit>
        <trans-unit id="5adb472163a6582271e0a7f045107d9d435aeb4d" translate="yes" xml:space="preserve">
          <source>Attempts to parse the connection&amp;rsquo;s request body given the content-type type, subtype, and its parameters.</source>
          <target state="translated">给定内容类型，子类型及其参数，尝试解析连接的请求主体。</target>
        </trans-unit>
        <trans-unit id="2d090490f8273f292dfbf2b46b5622e07c157083" translate="yes" xml:space="preserve">
          <source>Attempts to parse the connection's request body given the content-type type, subtype, and its parameters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6652617f2c799eb11ee727b16c5646c48af6905" translate="yes" xml:space="preserve">
          <source>Attributes</source>
          <target state="translated">Attributes</target>
        </trans-unit>
        <trans-unit id="37f1e388727dba012ec8b58b5511aeea7f852344" translate="yes" xml:space="preserve">
          <source>Author information should appear with the page, and include information such as author bio and role within the CMS, such as &lt;code&gt;&quot;editor&quot;&lt;/code&gt;, &lt;code&gt;&quot;writer&quot;&lt;/code&gt;, or &lt;code&gt;&quot;intern&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e25ce007aa95ea2ea8b158aee9c630a32ea5616" translate="yes" xml:space="preserve">
          <source>Authorization</source>
          <target state="translated">Authorization</target>
        </trans-unit>
        <trans-unit id="7dd6dabb0c5ff27d14867c7a0d5f7ad8c0d3dd31" translate="yes" xml:space="preserve">
          <source>Autogenerate</source>
          <target state="translated">Autogenerate</target>
        </trans-unit>
        <trans-unit id="03dcefaf5fdafcdcee4b084ba846e764fc47771f" translate="yes" xml:space="preserve">
          <source>Available for transports that generate a connection.</source>
          <target state="translated">可用于产生连接的传输。</target>
        </trans-unit>
        <trans-unit id="8c754fb0802b948868dd2247860ee54e3521f8dc" translate="yes" xml:space="preserve">
          <source>Avoid defining local variables, except within &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;case&lt;/code&gt;, and friends</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c0f599c56667a33df59b19c4fa8286c2b38c862" translate="yes" xml:space="preserve">
          <source>Avoid passing block expressions to library and custom functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8faf407e50cfbddaaa8c6b940974389bbb77f58e" translate="yes" xml:space="preserve">
          <source>Awaits the completion of an async assign</source>
          <target state="translated">等待异步赋值的完成。</target>
        </trans-unit>
        <trans-unit id="2168f4814ee9c5fe1b06e3b972eb6f903c518991" translate="yes" xml:space="preserve">
          <source>Awaits the completion of an async assign.</source>
          <target state="translated">等待异步赋值的完成。</target>
        </trans-unit>
        <trans-unit id="b1ff57d696aa3ec09bd76c88944e1a7097ee37a3" translate="yes" xml:space="preserve">
          <source>Bad:</source>
          <target state="translated">Bad:</target>
        </trans-unit>
        <trans-unit id="6f69f815f19f72bb41c1c4436ba66d01cf0d77fa" translate="yes" xml:space="preserve">
          <source>Be aware that a &lt;code&gt;:multiple&lt;/code&gt; option will not generate a correctly functioning multiple select element. Use &lt;a href=&quot;#multiple_select/4&quot;&gt;&lt;code&gt;multiple_select/4&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">请注意， &lt;code&gt;:multiple&lt;/code&gt; 选项不会生成功能正常的多重选择元素。请改用&lt;a href=&quot;#multiple_select/4&quot;&gt; &lt;code&gt;multiple_select/4&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0b7cf944c5f95100a7935a4fa47e890840645b9d" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;:join_through&lt;/code&gt; contains a schema, in such cases, autogenerated values and primary keys will be automatically handled by Ecto.</source>
          <target state="translated">因为 &lt;code&gt;:join_through&lt;/code&gt; 包含模式，在这种情况下，自动生成的值和主键将由Ecto自动处理。</target>
        </trans-unit>
        <trans-unit id="2842d72449f72f76dd6436b34b221777bfc86a74" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;Phoenix.LiveView&lt;/code&gt; is unable to compute diffs inside anonymous functions, Phoenix.HTML provides &lt;a href=&quot;#form_for/3&quot;&gt;&lt;code&gt;form_for/3&lt;/code&gt;&lt;/a&gt; that works without passing an anonymous function. Inside live views, instead of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9262b037e2212c6d03d3d7d5fb577f82e1400995" translate="yes" xml:space="preserve">
          <source>Because an unchecked checkbox is not sent to the server, Phoenix automatically generates a hidden field with the unchecked_value &lt;em&gt;before&lt;/em&gt; the checkbox field to ensure the &lt;code&gt;unchecked_value&lt;/code&gt; is sent when the checkbox is not marked.</source>
          <target state="translated">由于未选中的复选框未发送到服务器，因此Phoenix会自动在复选框字段&lt;em&gt;之前&lt;/em&gt;生成一个带有unchecked_value的隐藏字段，以确保在 &lt;code&gt;unchecked_value&lt;/code&gt; 该复选框时发送unchecked_value。</target>
        </trans-unit>
        <trans-unit id="3e6dd93facd60dadc7922885b15c8f608eb6e973" translate="yes" xml:space="preserve">
          <source>Because an unchecked checkbox is not sent to the server, Phoenix automatically generates a hidden field with the unchecked_value &lt;em&gt;before&lt;/em&gt; the checkbox field to ensure the &lt;code&gt;unchecked_value&lt;/code&gt; is sent when the checkbox is not marked. Set &lt;code&gt;hidden_input&lt;/code&gt; to false If you don't want to send values from unchecked checkbox to the server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdb9a6e7bde3ab5a7bc1495dec9bb0e16986001a" translate="yes" xml:space="preserve">
          <source>Because channels are spawned from the transport process, transports must trap exits and correctly handle the &lt;code&gt;{:EXIT, _, _}&lt;/code&gt; messages arriving from channels, relaying the proper response to the client.</source>
          <target state="translated">由于通道是从传输过程中产生的，因此传输必须捕获出口并正确处理从通道到达的 &lt;code&gt;{:EXIT, _, _}&lt;/code&gt; 消息，并将适当的响应中继给客户端。</target>
        </trans-unit>
        <trans-unit id="075cd0e73f7ec163ee1bd17ac66ecb22aea6420b" translate="yes" xml:space="preserve">
          <source>Because header keys are case-insensitive in both HTTP/1.1 and HTTP/2, it is recommended for header keys to be in lowercase, to avoid sending duplicate keys in a request. Additionally, requests with mixed-case headers served over HTTP/2 are not considered valid by common clients, resulting in dropped requests. As a convenience, when using the &lt;code&gt;Plug.Adapters.Conn.Test&lt;/code&gt; adapter, any headers that aren't lowercase will raise a &lt;a href=&quot;plug.conn.invalidheadererror&quot;&gt;&lt;code&gt;Plug.Conn.InvalidHeaderError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ffd1482ad9b039cd9a1b7189da93b88ba55a74b" translate="yes" xml:space="preserve">
          <source>Because header keys are case-insensitive in both HTTP/1.1 and HTTP/2, it is recommended for header keys to be in lowercase, to avoid sending duplicate keys in a request. Additionally, responses with mixed-case headers served over HTTP/2 are not considered valid by common clients, resulting in dropped responses. As a convenience, when using the &lt;code&gt;Plug.Adapters.Conn.Test&lt;/code&gt; adapter, any headers that aren't lowercase will raise a &lt;a href=&quot;plug.conn.invalidheadererror&quot;&gt;&lt;code&gt;Plug.Conn.InvalidHeaderError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efbb223e1e0205999506019f53282716fca5c16e" translate="yes" xml:space="preserve">
          <source>Because many databases do not support direct encoding and decoding of embeds, it is often emulated by Ecto by using specific encoding and decoding rules.</source>
          <target state="translated">由于很多数据库不支持直接对嵌入进行编码和解码,所以往往由Ecto通过使用特定的编码和解码规则进行仿真。</target>
        </trans-unit>
        <trans-unit id="ff3b261bdf6330bac84251a0b0895a163e937f12" translate="yes" xml:space="preserve">
          <source>Because of the inability to know if the struct is up to date or not, inserting a struct with associations and using the &lt;code&gt;:on_conflict&lt;/code&gt; option at the same time is not recommended, as Ecto will be unable to actually track the proper status of the association.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe0d51764665fe5a0cca90e95e7b401430abc9ea" translate="yes" xml:space="preserve">
          <source>Because of the inability to know if the struct is up to date or not, using associations with the &lt;code&gt;:on_conflict&lt;/code&gt; option is not recommended. For instance, Ecto may even trigger constraint violations when associations are used with &lt;code&gt;on_conflict: :nothing&lt;/code&gt;, as no ID will be available in the case the record already exists, and it is not possible for Ecto to detect such cases reliably.</source>
          <target state="translated">由于无法知道该结构是否最新，因此不建议将其与 &lt;code&gt;:on_conflict&lt;/code&gt; 选项一起使用。例如，当关联与 &lt;code&gt;on_conflict: :nothing&lt;/code&gt; 一起使用时，Ecto甚至可能触发约束冲突，因为在记录已经存在的情况下，没有ID可用，并且Ecto无法可靠地检测到这种情况。</target>
        </trans-unit>
        <trans-unit id="8aff02a4110b82074d8c12773ef5ce6582b3ab82" translate="yes" xml:space="preserve">
          <source>Because such indexes have usually more complex names, we need to explicitly tell the changeset which constraint name to use (here we&amp;rsquo;re using the naming convention that &lt;code&gt;unique_index&lt;/code&gt; uses):</source>
          <target state="translated">因为此类索引通常具有更复杂的名称，所以我们需要显式告诉更改集要使用哪个约束名称（这里我们使用的是 &lt;code&gt;unique_index&lt;/code&gt; 使用的命名约定）：</target>
        </trans-unit>
        <trans-unit id="224c09d9b7dd7d9d454778c8be5dd88e43a0c6ad" translate="yes" xml:space="preserve">
          <source>Because the constraint logic is in the database, we can leverage all the database functionality when defining them. For example, let&amp;rsquo;s suppose the e-mails are scoped by company id. We would write in a migration:</source>
          <target state="translated">由于约束逻辑位于数据库中，因此在定义它们时我们可以利用所有数据库功能。例如，假设电子邮件由公司ID限定范围。我们将在迁移中编写：</target>
        </trans-unit>
        <trans-unit id="29fa3508631dd99aed1ca4933a5f561d0c8393e8" translate="yes" xml:space="preserve">
          <source>Because the constraint logic is in the database, we can leverage all the database functionality when defining them. For example, let's suppose the e-mails are scoped by company id:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6739a5ab828592734049508a18dd56e17882475" translate="yes" xml:space="preserve">
          <source>Because the request body can be of any size, reading the body will only work once, as Plug will not cache the result of these operations. If you need to access the body multiple times, it is your responsibility to store it. Finally keep in mind some plugs like &lt;a href=&quot;plug.parsers&quot;&gt;&lt;code&gt;Plug.Parsers&lt;/code&gt;&lt;/a&gt; may read the body, so the body may be unavailable after being accessed by such plugs.</source>
          <target state="translated">由于请求主体可以是任意大小，因此读取主体将只工作一次，因为Plug不会缓存这些操作的结果。如果您需要多次访问主体，则有责任对其进行存储。最后，请记住一些插件，例如&lt;a href=&quot;plug.parsers&quot;&gt; &lt;code&gt;Plug.Parsers&lt;/code&gt; &lt;/a&gt;可能会读取主体，因此在被此类插件访问之后主体可能不可用。</target>
        </trans-unit>
        <trans-unit id="fd52c1c8179fc7e4ac27700b9459684e52d30867" translate="yes" xml:space="preserve">
          <source>Because the root layout from the Plug pipeline is rendered outside of LiveView, the contents cannot be dynamically changed. The one exception is the &lt;code&gt;&amp;lt;title&amp;gt;&lt;/code&gt; of the HTML document. Phoenix LiveView special cases the &lt;code&gt;@page_title&lt;/code&gt; assign to allow dynamically updating the title of the page, which is useful when using live navigation, or annotating the browser tab with a notification. For example, to update the user's notification count in the browser's title bar, first set the &lt;code&gt;page_title&lt;/code&gt; assign on mount:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8d5b0de0d771e3732a5b80433909083879a3d87" translate="yes" xml:space="preserve">
          <source>Because the whole communication is asynchronous, the following test would be very brittle:</source>
          <target state="translated">因为整个通信都是异步的,所以下面的测试会很脆。</target>
        </trans-unit>
        <trans-unit id="15004b08989be5acc9e143193d78d8c2df3ea58b" translate="yes" xml:space="preserve">
          <source>Because we have defined the template root to be &quot;lib/your_app_web/templates&quot;, &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Phoenix.View&lt;/code&gt;&lt;/a&gt; will automatically load all templates at &quot;your_app_web/templates/user&quot; and include them in the &lt;code&gt;YourApp.UserView&lt;/code&gt;. For example, imagine we have the template:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e845000c50c1ebb2862affdc57cdca9446402dc" translate="yes" xml:space="preserve">
          <source>Because we have defined the template root to be &amp;ldquo;lib/web/templates&amp;rdquo;, &lt;a href=&quot;phoenix.view#content&quot;&gt;&lt;code&gt;Phoenix.View&lt;/code&gt;&lt;/a&gt; will automatically load all templates at &amp;ldquo;web/templates/user&amp;rdquo; and include them in the &lt;code&gt;YourApp.UserView&lt;/code&gt;. For example, imagine we have the template:</source>
          <target state="translated">由于我们已将模板根目录定义为&amp;ldquo; lib / web / templates&amp;rdquo;，因此&lt;a href=&quot;phoenix.view#content&quot;&gt; &lt;code&gt;Phoenix.View&lt;/code&gt; &lt;/a&gt;会自动将所有模板加载到&amp;ldquo; web / templates / user&amp;rdquo;，并将其包含在 &lt;code&gt;YourApp.UserView&lt;/code&gt; 中。例如，假设我们有模板：</target>
        </trans-unit>
        <trans-unit id="39f7cc114f2fc6cf106968527a393ef7ef7dc2da" translate="yes" xml:space="preserve">
          <source>Because we used &lt;code&gt;on_conflict: :nothing&lt;/code&gt;, instead of getting an error, we got &lt;code&gt;{:ok, struct}&lt;/code&gt;. However the returned struct does not reflect the data in the database. One possible mechanism to detect if an insert or nothing happened in case of &lt;code&gt;on_conflict: :nothing&lt;/code&gt; is by checking the &lt;code&gt;id&lt;/code&gt; field. &lt;code&gt;id&lt;/code&gt; will be nil if the field is autogenerated by the database and no insert happened.</source>
          <target state="translated">因为我们使用了 &lt;code&gt;on_conflict: :nothing&lt;/code&gt; ，所以没有得到错误，而是得到了 &lt;code&gt;{:ok, struct}&lt;/code&gt; 。但是，返回的结构不会反映数据库中的数据。在 &lt;code&gt;on_conflict: :nothing&lt;/code&gt; 情况下，检测插入是否未发生的一种可能机制是检查 &lt;code&gt;id&lt;/code&gt; 字段。如果该字段由数据库自动生成并且没有发生插入，则 &lt;code&gt;id&lt;/code&gt; 将为nil。</target>
        </trans-unit>
        <trans-unit id="cec01231d5cf7fe423826e9f5aced9fc26335180" translate="yes" xml:space="preserve">
          <source>Because you don't actually serve the file above, LiveView will interpret the static above as missing, and this function will return true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cd2824c40cb6a858f71c571b7a9552c3251a948" translate="yes" xml:space="preserve">
          <source>Before asserting anything was broadcast, we must first subscribe to the topic of the channel in the test process:</source>
          <target state="translated">在断言任何东西被播出之前,我们必须先在测试过程中订阅该频道的主题。</target>
        </trans-unit>
        <trans-unit id="10e2a276b7b8a66e21797960dc92a40e33aa0198" translate="yes" xml:space="preserve">
          <source>Before rendering, the &lt;code&gt;@live_module&lt;/code&gt; assign will be added to the connection assigns for reference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48f2cdc0c1b8ff7cade454fbcf03343ddac9bcb5" translate="yes" xml:space="preserve">
          <source>Before we begin, please take a minute to read the &lt;a href=&quot;installation&quot;&gt;Installation Guide&lt;/a&gt;. By installing any necessary dependencies beforehand, we'll be able to get our application up and running smoothly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f320c637a311d1fd877641dfa2301a8e1bd919b" translate="yes" xml:space="preserve">
          <source>Before we continue, we have a final migration to generate. Now that we have an authors table, we can associate pages and authors. Let's add an &lt;code&gt;author_id&lt;/code&gt; field to the pages table. Run the following command to generate a new migration:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="053f49277ab135f6aca7d45e3e5dfbf937a0ab6f" translate="yes" xml:space="preserve">
          <source>Before we create a new layout, though, let's do the simplest possible thing and render a template with no layout at all.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a5e4791b3b4e3bca9c0730f7fbb4694921315ec" translate="yes" xml:space="preserve">
          <source>Before we create any pages, we need page authors. Let's run the &lt;a href=&quot;mix.tasks.phx.gen.context&quot;&gt;&lt;code&gt;mix phx.gen.context&lt;/code&gt;&lt;/a&gt; generator to generate an &lt;code&gt;Author&lt;/code&gt; schema along with injected context functions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d001e489410b0ef02cdf34a9be0452fe9a980231" translate="yes" xml:space="preserve">
          <source>Before we dive into this, let's see what the rendered &lt;code&gt;404 not found&lt;/code&gt; message looks like in a browser. In the development environment, Phoenix will debug errors by default, showing us a very informative debugging page. What we want here, however, is to see what page the application would serve in production. In order to do that we need to set &lt;code&gt;debug_errors: false&lt;/code&gt; in &lt;code&gt;config/dev.exs&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acbb8816a2938865e0801c384dbfe24d5f743c61" translate="yes" xml:space="preserve">
          <source>Before we integrate credentials in the web layer, we need to let our context know how to associate users and credentials. First, open up &lt;code&gt;lib/hello/accounts/user.ex&lt;/code&gt; and add the following association:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85c3afb52167376c3a01845b237a79d4a27d5dd3" translate="yes" xml:space="preserve">
          <source>Before we jump into the generated code, let's start the server with &lt;a href=&quot;mix.tasks.phx.server&quot;&gt;&lt;code&gt;mix phx.server&lt;/code&gt;&lt;/a&gt; and visit &lt;a href=&quot;http://localhost:4000/users&quot;&gt;http://localhost:4000/users&lt;/a&gt;. Let's follow the &quot;New User&quot; link and click the &quot;Submit&quot; button without providing any input. We should be greeted with the following output:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66ac6cd1d9b12dabda154c745aa7c9d4026165e8" translate="yes" xml:space="preserve">
          <source>Before we migrate our database, we need to handle data integrity once again in the newly generated &lt;code&gt;*_create_authors.exs&lt;/code&gt; migration. Open up the new file in &lt;code&gt;priv/repo/migrations&lt;/code&gt; and make the following change to the foreign key constraint:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25d9f6c13b631445db64e327c46b4dbb16706aa1" translate="yes" xml:space="preserve">
          <source>Before we run our migrations, we need to make one change to the generated migration to enforce data integrity of user account credentials. In our case, we want a user's credentials to be deleted when the parent user is removed. Make the following change to your &lt;code&gt;*_create_credentials.exs&lt;/code&gt; migration file in &lt;code&gt;priv/repo/migrations/&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6563eb04be423b3a4271c47271a162e1bfb1daf" translate="yes" xml:space="preserve">
          <source>Before we run this task let's inspect the contents of two directories in our hello application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed0aeef3ce1f1355fb7dd0f793d3f8076fad30cd" translate="yes" xml:space="preserve">
          <source>Before we use the generators, we need to undo the changes we made in the Ecto guide, so we can give our user schema a proper home. Run these commands to undo our previous work:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fcc2b3eb968342e0c6f964691dd598210edfa61" translate="yes" xml:space="preserve">
          <source>Before writing your first example, make sure that Phoenix LiveView is properly installed. If you are just getting started, this can be easily done by running &lt;code&gt;mix phx.new my_app --live&lt;/code&gt;. The &lt;code&gt;phx.new&lt;/code&gt; command with the &lt;code&gt;--live&lt;/code&gt; flag will create a new project with LiveView installed and configured. Otherwise, please follow the steps in the &lt;a href=&quot;installation&quot;&gt;installation guide&lt;/a&gt; before continuing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4041ca44c3c741eba05c3336903154a869e43ff0" translate="yes" xml:space="preserve">
          <source>Behaves exactly the same as &lt;code&gt;where&lt;/code&gt; except it combines with any previous expression by using an &lt;code&gt;OR&lt;/code&gt;. All expressions have to evaluate to a boolean value.</source>
          <target state="translated">行为与 &lt;code&gt;where&lt;/code&gt; 完全相同，不同之处在于它使用 &lt;code&gt;OR&lt;/code&gt; 结合任何先前的表达式。所有表达式都必须求值为布尔值。</target>
        </trans-unit>
        <trans-unit id="69bb93f8733104d33c3d36e7e5b282df9df17548" translate="yes" xml:space="preserve">
          <source>Behind the scenes, it uses &lt;a href=&quot;https://hexdocs.pm/elixir/Task.html#async/1&quot;&gt;&lt;code&gt;Task.async/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在后台，它使用&lt;a href=&quot;https://hexdocs.pm/elixir/Task.html#async/1&quot;&gt; &lt;code&gt;Task.async/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d35a0bd824cc8e4b8d193117df8ed871a26f82ac" translate="yes" xml:space="preserve">
          <source>Behind the scenes, it uses &lt;a href=&quot;https://hexdocs.pm/elixir/Task.html#await/2&quot;&gt;&lt;code&gt;Task.await/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在后台，它使用&lt;a href=&quot;https://hexdocs.pm/elixir/Task.html#await/2&quot;&gt; &lt;code&gt;Task.await/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e403e0ae9721d5783b70c50d5880748cf9f3c38e" translate="yes" xml:space="preserve">
          <source>Below we list all events developers should expect from Ecto. All examples below consider a repository named &lt;code&gt;MyApp.Repo&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6ad3316378f3ecae2aa5789e6ae98417f0d92ae" translate="yes" xml:space="preserve">
          <source>Besides &lt;code&gt;:id&lt;/code&gt; and &lt;code&gt;:binary_id&lt;/code&gt;, which are often used by primary and foreign keys, Ecto provides a huge variety of types to be used by any column.</source>
          <target state="translated">除了 &lt;code&gt;:id&lt;/code&gt; 和 &lt;code&gt;:binary_id&lt;/code&gt; （它们通常由主键和外键使用）之外，Ecto还提供了可供任何列使用的多种类型。</target>
        </trans-unit>
        <trans-unit id="b5608ffc54f8eb63f27799f6ae50c2cfc29178f8" translate="yes" xml:space="preserve">
          <source>Besides &lt;code&gt;:id&lt;/code&gt; and &lt;code&gt;:binary_id&lt;/code&gt;, which are often used by primary and foreign keys, Ecto provides a huge variety of types to be used by any field.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e1489eea1b6f3bbd4b7bfb5da234da05e74fa76" translate="yes" xml:space="preserve">
          <source>Besides &lt;code&gt;Repo.all/1&lt;/code&gt; which returns all entries, repositories also provide &lt;code&gt;Repo.one/1&lt;/code&gt; which returns one entry or nil, &lt;code&gt;Repo.one!/1&lt;/code&gt; which returns one entry or raises, &lt;code&gt;Repo.get/2&lt;/code&gt; which fetches entries for a particular ID and more.</source>
          <target state="translated">除了返回所有条目的 &lt;code&gt;Repo.all/1&lt;/code&gt; ，存储库还提供 &lt;code&gt;Repo.one/1&lt;/code&gt; (它返回一个条目或为nil）， &lt;code&gt;Repo.one!/1&lt;/code&gt; (它返回一个条目或加注）， &lt;code&gt;Repo.get/2&lt;/code&gt; (它为特定条目获取条目）。 ID等。</target>
        </trans-unit>
        <trans-unit id="6437183553c7f4ee91c137266b2ec8a881ba0341" translate="yes" xml:space="preserve">
          <source>Besides &lt;code&gt;put_flash/3&lt;/code&gt; and &lt;code&gt;get_flash/2&lt;/code&gt;, the &lt;a href=&quot;phoenix.controller&quot;&gt;&lt;code&gt;Phoenix.Controller&lt;/code&gt;&lt;/a&gt; module has another useful function worth knowing about. &lt;code&gt;clear_flash/1&lt;/code&gt; takes only &lt;code&gt;conn&lt;/code&gt; and removes any flash messages which might be stored in the session.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4db60d335ebdbdc7119cfd198fa9382586d6f219" translate="yes" xml:space="preserve">
          <source>Besides being a Plug, this module also provides conveniences for configuring SSL. See &lt;a href=&quot;#configure/1&quot;&gt;&lt;code&gt;configure/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">除了作为插件外，该模块还为配置SSL提供了便利。参见&lt;a href=&quot;#configure/1&quot;&gt; &lt;code&gt;configure/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="89f5e6bc915be700f158a6ce56ae0826017ba369" translate="yes" xml:space="preserve">
          <source>Besides functions transaction can be used with an Ecto.Multi struct. Transaction will be started, all operations applied and in case of success committed returning &lt;code&gt;{:ok, changes}&lt;/code&gt;. In case of any errors the transaction will be rolled back and &lt;code&gt;{:error, failed_operation, failed_value, changes_so_far}&lt;/code&gt; will be returned.</source>
          <target state="translated">除了函数事务外，还可以与Ecto.Multi结构一起使用。事务将开始，将应用所有操作，并在提交成功的情况下返回 &lt;code&gt;{:ok, changes}&lt;/code&gt; 。如果发生任何错误，事务将被回退，并返回 &lt;code&gt;{:error, failed_operation, failed_value, changes_so_far}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="318f727872b2ac407eed6b2cc5b760e863528d41" translate="yes" xml:space="preserve">
          <source>Besides functions, transactions can be used with an &lt;a href=&quot;ecto.multi&quot;&gt;&lt;code&gt;Ecto.Multi&lt;/code&gt;&lt;/a&gt; struct. A transaction will be started, all operations applied and in case of success committed returning &lt;code&gt;{:ok, changes}&lt;/code&gt;. In case of any errors the transaction will be rolled back and &lt;code&gt;{:error, failed_operation, failed_value, changes_so_far}&lt;/code&gt; will be returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6eb623724b9e9c7ad93a2b376a13191ce506c435" translate="yes" xml:space="preserve">
          <source>Besides providing primitive types, Ecto allows custom types to be implemented by developers, allowing Ecto behaviour to be extended.</source>
          <target state="translated">除了提供基元类型外,Ecto还允许开发者实现自定义类型,使Ecto行为得以扩展。</target>
        </trans-unit>
        <trans-unit id="76cc7d58981a3e9ddfb52f7f3e74c5fabe82b2f6" translate="yes" xml:space="preserve">
          <source>Besides template engines, Phoenix has the concept of format encoders. Format encoders work per format and are responsible for encoding a given format to string once the view layer finishes processing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95f14d33b401893a277d4f99cbdd9eff770e0035" translate="yes" xml:space="preserve">
          <source>Besides the &amp;ldquo;Shared options&amp;rdquo; section at the module documentation, it accepts:</source>
          <target state="translated">除了模块文档中的&amp;ldquo;共享选项&amp;rdquo;部分外，它还接受：</target>
        </trans-unit>
        <trans-unit id="6dddd5d4e0ebfe01e4b2b072c831bf0ff01a10bb" translate="yes" xml:space="preserve">
          <source>Besides the directories mentioned, &lt;code&gt;lib/hello_web&lt;/code&gt; has four files at its root. &lt;code&gt;lib/hello_web/endpoint.ex&lt;/code&gt; is the entry-point for HTTP requests. Once the browser accesses &lt;code&gt;http://localhost:4000&lt;/code&gt;, the endpoint starts processing the data, eventually leading to the router, which is defined in &lt;code&gt;lib/hello_web/router.ex&lt;/code&gt;. The router defines the rules to dispatch requests to &quot;controllers&quot;, which then uses &quot;views&quot; and &quot;templates&quot; to render HTML pages back to clients. We explore these layers in length in other guides, starting with the &quot;Request life-cycle&quot; guide coming next.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5b702522385247fe472a44b3b7dab0d4a04a627" translate="yes" xml:space="preserve">
          <source>Besides the four components above, most developers use Ecto to interact with SQL databases, such as Postgres and MySQL via the &lt;a href=&quot;http://hexdocs.pm/ecto_sql&quot;&gt;&lt;code&gt;ecto_sql&lt;/code&gt;&lt;/a&gt; project. &lt;code&gt;ecto_sql&lt;/code&gt; provides many conveniences for working with SQL databases as well as the ability to version how your database changes through time via &lt;a href=&quot;https://hexdocs.pm/ecto_sql/Ecto.Adapters.SQL.html#module-migrations&quot;&gt;database migrations&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3db8569d9e6815ffe5de50966c22aaf56621ce54" translate="yes" xml:space="preserve">
          <source>Besides the options from &lt;code&gt;:ssl&lt;/code&gt;, this function adds on extra option:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30337ca422dc9c9379566c110b3f0dab3fec92a6" translate="yes" xml:space="preserve">
          <source>Besides the options supported by &lt;a href=&quot;plug.conn#read_body/2&quot;&gt;&lt;code&gt;Plug.Conn.read_body/2&lt;/code&gt;&lt;/a&gt;, the multipart parser also checks for &lt;code&gt;:headers&lt;/code&gt; option that contains the same &lt;code&gt;:length&lt;/code&gt;, &lt;code&gt;:read_length&lt;/code&gt; and &lt;code&gt;:read_timeout&lt;/code&gt; options which are used explicitly for parsing multipart headers.</source>
          <target state="translated">除了&lt;a href=&quot;plug.conn#read_body/2&quot;&gt; &lt;code&gt;Plug.Conn.read_body/2&lt;/code&gt; &lt;/a&gt;支持的选项之外，多部分解析器还会检查 &lt;code&gt;:headers&lt;/code&gt; 选项，该选项包含相同的 &lt;code&gt;:length&lt;/code&gt; ， &lt;code&gt;:read_length&lt;/code&gt; 和 &lt;code&gt;:read_timeout&lt;/code&gt; read_timeout选项，这些选项明确用于解析多部分标题。</target>
        </trans-unit>
        <trans-unit id="15b3f19a233cd9d8ebad91d3ec8ed466fb101712" translate="yes" xml:space="preserve">
          <source>Besides the options supported by &lt;a href=&quot;plug.conn#read_body/2&quot;&gt;&lt;code&gt;Plug.Conn.read_body/2&lt;/code&gt;&lt;/a&gt;, the multipart parser also checks for:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97011ba97fa273b21e33aa944bda2e2a278636f0" translate="yes" xml:space="preserve">
          <source>Besides working as data mappers, &lt;a href=&quot;#embedded_schema/1&quot;&gt;&lt;code&gt;embedded_schema/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#schema/2&quot;&gt;&lt;code&gt;schema/2&lt;/code&gt;&lt;/a&gt; can also be used together to decouple how the data is represented in your applications from the database. Let&amp;rsquo;s see some examples.</source>
          <target state="translated">除了用作数据映射器之外，&lt;a href=&quot;#embedded_schema/1&quot;&gt; &lt;code&gt;embedded_schema/1&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#schema/2&quot;&gt; &lt;code&gt;schema/2&lt;/code&gt; &lt;/a&gt;还可一起使用，以将数据在应用程序中的表示方式与数据库分离。让我们看一些例子。</target>
        </trans-unit>
        <trans-unit id="89bd0a3cbaf58f8c800ca549b4e25ac38a02f8ca" translate="yes" xml:space="preserve">
          <source>Besides working as data mappers, &lt;a href=&quot;#embedded_schema/1&quot;&gt;&lt;code&gt;embedded_schema/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#schema/2&quot;&gt;&lt;code&gt;schema/2&lt;/code&gt;&lt;/a&gt; can also be used together to decouple how the data is represented in your applications from the database. Let's see some examples.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3962ea5600f34c37c915cbc046d82c04df4d77b4" translate="yes" xml:space="preserve">
          <source>Binaries: &lt;code&gt;&amp;lt;&amp;lt;1, 2, 3&amp;gt;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">二进制： &lt;code&gt;&amp;lt;&amp;lt;1, 2, 3&amp;gt;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a1aad9799a97fc162affbf249838fba4245ed1b2" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;!=&lt;/code&gt; operation</source>
          <target state="translated">二进制 &lt;code&gt;!=&lt;/code&gt; 操作</target>
        </trans-unit>
        <trans-unit id="aab4967633fa340878f5b6ff0fac9275456b4095" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;!=&lt;/code&gt; operation.</source>
          <target state="translated">二进制 &lt;code&gt;!=&lt;/code&gt; 操作。</target>
        </trans-unit>
        <trans-unit id="e5506cd20d34fa992131eae37a4118f8df942d59" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&amp;gt;&lt;/code&gt; operation</source>
          <target state="translated">二进制 &lt;code&gt;&amp;gt;&lt;/code&gt; 操作</target>
        </trans-unit>
        <trans-unit id="dfa1236ca139dea1e736031c6c010136c1156745" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&amp;gt;&lt;/code&gt; operation.</source>
          <target state="translated">二进制 &lt;code&gt;&amp;gt;&lt;/code&gt; 操作。</target>
        </trans-unit>
        <trans-unit id="68b8b7e6a0cafe89fe9d42b45a144301795984d6" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&amp;gt;=&lt;/code&gt; operation</source>
          <target state="translated">二进制 &lt;code&gt;&amp;gt;=&lt;/code&gt; 操作</target>
        </trans-unit>
        <trans-unit id="9fff762f48965b1b90e231f1c2e9b7b77d9c0279" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&amp;gt;=&lt;/code&gt; operation.</source>
          <target state="translated">二进制 &lt;code&gt;&amp;gt;=&lt;/code&gt; 操作。</target>
        </trans-unit>
        <trans-unit id="897a4bf146dd662af8918814f6299d5d45bc9385" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&amp;lt;&lt;/code&gt; operation</source>
          <target state="translated">二进制 &lt;code&gt;&amp;lt;&lt;/code&gt; 运算</target>
        </trans-unit>
        <trans-unit id="516964b86b828e773af99b35b730166419b08ee0" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&amp;lt;&lt;/code&gt; operation.</source>
          <target state="translated">二进制 &lt;code&gt;&amp;lt;&lt;/code&gt; 操作。</target>
        </trans-unit>
        <trans-unit id="55d4095acf2b6cfdaf2462ee0715df5c7aac35c1" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&amp;lt;=&lt;/code&gt; operation</source>
          <target state="translated">二进制 &lt;code&gt;&amp;lt;=&lt;/code&gt; 操作</target>
        </trans-unit>
        <trans-unit id="0be463179ad26307edb01739fad99fe4901b5a8f" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&amp;lt;=&lt;/code&gt; operation.</source>
          <target state="translated">二进制 &lt;code&gt;&amp;lt;=&lt;/code&gt; 操作。</target>
        </trans-unit>
        <trans-unit id="ed4b8e4fd8d9b29d992761dfa2dd4c4489e1ed65" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;*&lt;/code&gt; operation</source>
          <target state="translated">二进制 &lt;code&gt;*&lt;/code&gt; 运算</target>
        </trans-unit>
        <trans-unit id="37acde5499dd91e7f0cda6308db090f03a77b072" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;*&lt;/code&gt; operation.</source>
          <target state="translated">二进制 &lt;code&gt;*&lt;/code&gt; 操作。</target>
        </trans-unit>
        <trans-unit id="d333c5e55aa960b56f8ce9b2461bef92b1d3519a" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;+&lt;/code&gt; operation</source>
          <target state="translated">二进制 &lt;code&gt;+&lt;/code&gt; 运算</target>
        </trans-unit>
        <trans-unit id="becb3295fec718a8db321dbab17c20c240047390" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;+&lt;/code&gt; operation.</source>
          <target state="translated">二进制 &lt;code&gt;+&lt;/code&gt; 运算。</target>
        </trans-unit>
        <trans-unit id="04e6fcacb4fa7beb340b0fd4aebae3a486fae794" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;-&lt;/code&gt; operation</source>
          <target state="translated">二进制 &lt;code&gt;-&lt;/code&gt; 操作</target>
        </trans-unit>
        <trans-unit id="98d8ffdbb4452da8517c3805068ed9208643de11" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;-&lt;/code&gt; operation.</source>
          <target state="translated">二进制 &lt;code&gt;-&lt;/code&gt; 操作。</target>
        </trans-unit>
        <trans-unit id="e6178994dd1feef09124c4590ccdad76e17713e2" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;/&lt;/code&gt; operation</source>
          <target state="translated">二进制 &lt;code&gt;/&lt;/code&gt; 运算</target>
        </trans-unit>
        <trans-unit id="09212b0697d203478dadb5e24a3aa03f5d34b600" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;/&lt;/code&gt; operation.</source>
          <target state="translated">二进制 &lt;code&gt;/&lt;/code&gt; 运算。</target>
        </trans-unit>
        <trans-unit id="ccbea1b86603234afe1e75963168f22d91c68d0f" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;==&lt;/code&gt; operation</source>
          <target state="translated">二进制 &lt;code&gt;==&lt;/code&gt; 操作</target>
        </trans-unit>
        <trans-unit id="59b65609ffb053adfebf42fcdef021d829543b4b" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;==&lt;/code&gt; operation.</source>
          <target state="translated">二进制 &lt;code&gt;==&lt;/code&gt; 操作。</target>
        </trans-unit>
        <trans-unit id="4248aa7253f6eb7de8c22a0d449b4507ceab3e76" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;and&lt;/code&gt; operation</source>
          <target state="translated">二进制 &lt;code&gt;and&lt;/code&gt; 运算</target>
        </trans-unit>
        <trans-unit id="679d74c0e77d203b30ac50ea095340b58793e663" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;and&lt;/code&gt; operation.</source>
          <target state="translated">二进制 &lt;code&gt;and&lt;/code&gt; 运算。</target>
        </trans-unit>
        <trans-unit id="56942b29b92b3a8bc97ce0aee7ae63719e0afac4" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;or&lt;/code&gt; operation</source>
          <target state="translated">二进制 &lt;code&gt;or&lt;/code&gt; 运算</target>
        </trans-unit>
        <trans-unit id="1efbf5460110f2b42e9a177b65ee9dbf7064f3f6" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;or&lt;/code&gt; operation.</source>
          <target state="translated">二进制 &lt;code&gt;or&lt;/code&gt; 运算。</target>
        </trans-unit>
        <trans-unit id="7f0043e684cc2e548822e45bee14ea4c4673e262" translate="yes" xml:space="preserve">
          <source>Binding</source>
          <target state="translated">Binding</target>
        </trans-unit>
        <trans-unit id="34c54b1df07d242138e07a00276cdb9c596ce135" translate="yes" xml:space="preserve">
          <source>Bindingless operations</source>
          <target state="translated">无绑定操作</target>
        </trans-unit>
        <trans-unit id="967382f86044b6efc91dfee8f4e2b4ed941211cd" translate="yes" xml:space="preserve">
          <source>Bindings</source>
          <target state="translated">Bindings</target>
        </trans-unit>
        <trans-unit id="b7d81cd1aa76a8c75003ee4db6d6aa59eab833b5" translate="yes" xml:space="preserve">
          <source>Bindings are not exposed from the query. When composing queries you must specify bindings again for each refinement query. For example to further narrow-down above query we again need to tell Ecto what bindings to expect:</source>
          <target state="translated">绑定不会从查询中暴露出来。当组成查询时,你必须为每个精炼查询再次指定绑定。例如,为了进一步缩小上述查询的范围,我们需要再次告诉Ecto期望什么绑定。</target>
        </trans-unit>
        <trans-unit id="6bbf6933797073c25a6cfb9a9635145f3caa2e87" translate="yes" xml:space="preserve">
          <source>Bindings are not exposed from the query. When composing queries, you must specify bindings again for each refinement query. For example, to further narrow down the above query, we again need to tell Ecto what bindings to expect:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a768c2cec7b7bc8e20929e8467fb8b1cdbcd4ee" translate="yes" xml:space="preserve">
          <source>Bindings in Ecto are positional, and the names do not have to be consistent between input and refinement queries. For example, the query above could also be written as:</source>
          <target state="translated">Ecto中的绑定是位置性的,输入查询和细化查询之间的名称不必一致。例如,上面的查询也可以写成。</target>
        </trans-unit>
        <trans-unit id="4a7fdd8c17425252332ea0e89a35722b72d83135" translate="yes" xml:space="preserve">
          <source>Books</source>
          <target state="translated">Books</target>
        </trans-unit>
        <trans-unit id="e7785ac12e9b48c7d8da92df06d805c335db37ed" translate="yes" xml:space="preserve">
          <source>Boolean operators: &lt;code&gt;and&lt;/code&gt;, &lt;code&gt;or&lt;/code&gt;, &lt;code&gt;not&lt;/code&gt;</source>
          <target state="translated">布尔运算符： &lt;code&gt;and&lt;/code&gt; ， &lt;code&gt;or&lt;/code&gt; ， &lt;code&gt;not&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7133f12719661511054ab5e011b7efd42eff73c9" translate="yes" xml:space="preserve">
          <source>Boolean values</source>
          <target state="translated">布尔值</target>
        </trans-unit>
        <trans-unit id="2984126e4505fef2ec09b8e1991aadd393d7b750" translate="yes" xml:space="preserve">
          <source>Booleans: &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt;</source>
          <target state="translated">布尔值： &lt;code&gt;true&lt;/code&gt; ， &lt;code&gt;false&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b765af8d436cfcf6ee0928b70c18c8a282ae2484" translate="yes" xml:space="preserve">
          <source>Booting sockets</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="072691eed4da8ad84159768206095389395590ea" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;any&lt;/code&gt; and &lt;code&gt;all&lt;/code&gt; must be given a subquery as an argument, and theyu must be used on the right hand side of a comparison. Both can be used with every comparison operator: &lt;code&gt;==&lt;/code&gt;, &lt;code&gt;!=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="138dbeb06701882a099e2f68d3e08d5ed686d058" translate="yes" xml:space="preserve">
          <source>Both JSON and HTML formats will be encoded only when passing the data to the controller via the &lt;a href=&quot;#render_to_iodata/3&quot;&gt;&lt;code&gt;render_to_iodata/3&lt;/code&gt;&lt;/a&gt; function. The &lt;a href=&quot;#render_to_iodata/3&quot;&gt;&lt;code&gt;render_to_iodata/3&lt;/code&gt;&lt;/a&gt; function uses the notion of format encoders to convert a particular format to its string/iodata representation.</source>
          <target state="translated">仅当通过&lt;a href=&quot;#render_to_iodata/3&quot;&gt; &lt;code&gt;render_to_iodata/3&lt;/code&gt; &lt;/a&gt;函数将数据传递到控制器时，才会对JSON和HTML格式进行编码。所述&lt;a href=&quot;#render_to_iodata/3&quot;&gt; &lt;code&gt;render_to_iodata/3&lt;/code&gt; &lt;/a&gt;函数使用格式编码器的概念到特定的格式转换为它的串/ iodata表示。</target>
        </trans-unit>
        <trans-unit id="bf5e5abefed5cab48db50ba6d9ed06bb2b3bd7c7" translate="yes" xml:space="preserve">
          <source>Both approaches shown above rely on static configuration. Let's see alternatives.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f7a07162f18c4dab6556ad58150d663a794593d" translate="yes" xml:space="preserve">
          <source>Both queries are equivalent. However, if you are using the same partitioning over and over again, defining a window will reduce the query size. See &lt;a href=&quot;ecto.query#windows/3&quot;&gt;&lt;code&gt;Ecto.Query.windows/3&lt;/code&gt;&lt;/a&gt; for all possible window expressions, such as &lt;code&gt;:partition_by&lt;/code&gt; and &lt;code&gt;:order_by&lt;/code&gt;.</source>
          <target state="translated">这两个查询是等效的。但是，如果您一次又一次使用相同的分区，则定义窗口将减小查询大小。有关所有可能的窗口表达式，请参阅&lt;a href=&quot;ecto.query#windows/3&quot;&gt; &lt;code&gt;Ecto.Query.windows/3&lt;/code&gt; &lt;/a&gt;，例如 &lt;code&gt;:partition_by&lt;/code&gt; 和 &lt;code&gt;:order_by&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f53a37385676a460a743f3f86e272723cbe6eceb" translate="yes" xml:space="preserve">
          <source>Both the &lt;code&gt;init/1&lt;/code&gt; and &lt;code&gt;call/2&lt;/code&gt; functions defined by &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Plug.Builder&lt;/code&gt;&lt;/a&gt; can be manually overridden. For example, the &lt;code&gt;init/1&lt;/code&gt; function provided by &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Plug.Builder&lt;/code&gt;&lt;/a&gt; returns the options that it receives as an argument, but its behaviour can be customized:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9841089641d10cbb68ba9932954832d08f20b29e" translate="yes" xml:space="preserve">
          <source>Both the &lt;code&gt;init/1&lt;/code&gt; and &lt;code&gt;call/2&lt;/code&gt; functions defined by &lt;a href=&quot;plug.builder#content&quot;&gt;&lt;code&gt;Plug.Builder&lt;/code&gt;&lt;/a&gt; can be manually overridden. For example, the &lt;code&gt;init/1&lt;/code&gt; function provided by &lt;a href=&quot;plug.builder#content&quot;&gt;&lt;code&gt;Plug.Builder&lt;/code&gt;&lt;/a&gt; returns the options that it receives as an argument, but its behaviour can be customized:</source>
          <target state="translated">&lt;a href=&quot;plug.builder#content&quot;&gt; &lt;code&gt;Plug.Builder&lt;/code&gt; &lt;/a&gt;定义的 &lt;code&gt;init/1&lt;/code&gt; 和 &lt;code&gt;call/2&lt;/code&gt; 函数都可以手动覆盖。例如，&lt;a href=&quot;plug.builder#content&quot;&gt; &lt;code&gt;Plug.Builder&lt;/code&gt; &lt;/a&gt;提供的 &lt;code&gt;init/1&lt;/code&gt; 函数返回它作为参数接收的选项，但是可以自定义其行为：</target>
        </trans-unit>
        <trans-unit id="ef5922fa8013b702194c2f1e7cc36353301a4e8b" translate="yes" xml:space="preserve">
          <source>Both the router and controller module names will be prefixed with the name you gave your application instead of &lt;code&gt;HelloWeb&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b13a8d60d1d3de64ef4fd72fc97d6965aae27f8" translate="yes" xml:space="preserve">
          <source>Broadcast an event to all subscribers of the socket topic</source>
          <target state="translated">向套接字主题的所有订阅者广播事件。</target>
        </trans-unit>
        <trans-unit id="bad0a78dd2fd78e872af83332fe02ca2f663da8e" translate="yes" xml:space="preserve">
          <source>Broadcast an event to all subscribers of the socket topic.</source>
          <target state="translated">向socket主题的所有订阅者广播一个事件。</target>
        </trans-unit>
        <trans-unit id="846b5dd1c1f901604c81013a76597f6f855e2d20" translate="yes" xml:space="preserve">
          <source>Broadcast event from pid to all subscribers of the socket topic</source>
          <target state="translated">将事件从pid广播到socket主题的所有订阅者。</target>
        </trans-unit>
        <trans-unit id="851a8a80337ee20b89c3d123943d6ad3318e4e3c" translate="yes" xml:space="preserve">
          <source>Broadcast event from pid to all subscribers of the socket topic.</source>
          <target state="translated">将事件从pid广播到socket主题的所有订阅者。</target>
        </trans-unit>
        <trans-unit id="7459c0c85fb18346d48a15ecd0ee62798126c617" translate="yes" xml:space="preserve">
          <source>Broadcasting to an external topic</source>
          <target state="translated">向外部主题广播</target>
        </trans-unit>
        <trans-unit id="430c9f20aa06eb11805b71cdf9305b868b70a06a" translate="yes" xml:space="preserve">
          <source>Broadcasts a &lt;code&gt;msg&lt;/code&gt; as &lt;code&gt;event&lt;/code&gt; in the given &lt;code&gt;topic&lt;/code&gt;</source>
          <target state="translated">在给定 &lt;code&gt;topic&lt;/code&gt; 广播 &lt;code&gt;msg&lt;/code&gt; 作为 &lt;code&gt;event&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="41d4a918d7ada7063a5d54f173d1fb2b78ec2966" translate="yes" xml:space="preserve">
          <source>Broadcasts a &lt;code&gt;msg&lt;/code&gt; as &lt;code&gt;event&lt;/code&gt; in the given &lt;code&gt;topic&lt;/code&gt; to all nodes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ad30a6e73447865104d74a754edbdbb847221a5" translate="yes" xml:space="preserve">
          <source>Broadcasts a &lt;code&gt;msg&lt;/code&gt; as &lt;code&gt;event&lt;/code&gt; in the given &lt;code&gt;topic&lt;/code&gt; within the current node.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9be84a5fac4b66af00295240a8a9fd8406098ea3" translate="yes" xml:space="preserve">
          <source>Broadcasts a &lt;code&gt;msg&lt;/code&gt; as &lt;code&gt;event&lt;/code&gt; in the given &lt;code&gt;topic&lt;/code&gt;.</source>
          <target state="translated">在给定 &lt;code&gt;topic&lt;/code&gt; 广播 &lt;code&gt;msg&lt;/code&gt; 作为 &lt;code&gt;event&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2a381d4f84303afe830a779813c8ff51ca44d964" translate="yes" xml:space="preserve">
          <source>Broadcasts a &lt;code&gt;msg&lt;/code&gt; from the given &lt;code&gt;from&lt;/code&gt; as &lt;code&gt;event&lt;/code&gt; in the given &lt;code&gt;topic&lt;/code&gt;</source>
          <target state="translated">在给定 &lt;code&gt;topic&lt;/code&gt; 广播来自给定 &lt;code&gt;from&lt;/code&gt; 的 &lt;code&gt;msg&lt;/code&gt; ，作为 &lt;code&gt;event&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4f5bcc1aac9a59de4ee2320d6d3de3b015ff24b6" translate="yes" xml:space="preserve">
          <source>Broadcasts a &lt;code&gt;msg&lt;/code&gt; from the given &lt;code&gt;from&lt;/code&gt; as &lt;code&gt;event&lt;/code&gt; in the given &lt;code&gt;topic&lt;/code&gt; to all nodes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9dcc5aa9001938c0fa121a5a07fb5cb71c8216ac" translate="yes" xml:space="preserve">
          <source>Broadcasts a &lt;code&gt;msg&lt;/code&gt; from the given &lt;code&gt;from&lt;/code&gt; as &lt;code&gt;event&lt;/code&gt; in the given &lt;code&gt;topic&lt;/code&gt; within the current node.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da547b962c3b435f39e695241e267c345324e49f" translate="yes" xml:space="preserve">
          <source>Broadcasts a &lt;code&gt;msg&lt;/code&gt; from the given &lt;code&gt;from&lt;/code&gt; as &lt;code&gt;event&lt;/code&gt; in the given &lt;code&gt;topic&lt;/code&gt;.</source>
          <target state="translated">从给定 &lt;code&gt;from&lt;/code&gt; 的给定 &lt;code&gt;topic&lt;/code&gt; 广播 &lt;code&gt;msg&lt;/code&gt; 作为 &lt;code&gt;event&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2128b2a68ac127e87f9c6c480329ff8af263ea9f" translate="yes" xml:space="preserve">
          <source>Broadcasts message on given topic</source>
          <target state="translated">广播指定主题的信息</target>
        </trans-unit>
        <trans-unit id="3e575d0da9aea600efd895513bb1b0d422de8ace" translate="yes" xml:space="preserve">
          <source>Broadcasts message on given topic across the whole cluster.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a8ed8128ad3266a3e3ed17060b3688cd98d5484" translate="yes" xml:space="preserve">
          <source>Broadcasts message on given topic from a given process only for the current node.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc32e492fe1951ff9c5a65a298a35717bdab0d23" translate="yes" xml:space="preserve">
          <source>Broadcasts message on given topic from the given process across the whole cluster.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6cf1d8af5af2a25fd80f311ae513c176bc7fe41" translate="yes" xml:space="preserve">
          <source>Broadcasts message on given topic only for the current node.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7502e5d44055067546fa115fcbb0ed4dfdcfae02" translate="yes" xml:space="preserve">
          <source>Broadcasts message on given topic to a given node.</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
