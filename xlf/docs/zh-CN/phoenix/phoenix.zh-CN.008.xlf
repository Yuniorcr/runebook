<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="phoenix">
    <body>
      <group id="phoenix">
        <trans-unit id="58fb745a2e57967c454ef61e37a343c8af7ac169" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;ecto.multi#content&quot;&gt;&lt;code&gt;Ecto.Multi&lt;/code&gt;&lt;/a&gt; structure should be considered opaque. You can use &lt;code&gt;%Ecto.Multi{}&lt;/code&gt; to pattern match the type, but accessing fields or directly modifying them is not advised.</source>
          <target state="translated">该&lt;a href=&quot;ecto.multi#content&quot;&gt; &lt;code&gt;Ecto.Multi&lt;/code&gt; &lt;/a&gt;结构应被视为是不透明的。您可以使用 &lt;code&gt;%Ecto.Multi{}&lt;/code&gt; 模式匹配类型，但是不建议访问字段或直接修改它们。</target>
        </trans-unit>
        <trans-unit id="fa9514b9adddb69475024589cdb99afc99238dbf" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; is disabled by configuration but might be enabled later.</source>
          <target state="translated">该&lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;由配置来禁用，但可能在以后启用。</target>
        </trans-unit>
        <trans-unit id="ba6f27f85d7ce239b979057471cc92f95d3ac7cb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://phoenixframework.org/&quot;&gt;Phoenix&lt;/a&gt; project includes a Mix task &lt;code&gt;mix phx.gen.cert&lt;/code&gt; that generates the necessary files and places them in the application's 'priv' directory. The &lt;a href=&quot;https://hex.pm/packages/x509&quot;&gt;X509&lt;/a&gt; package can be used as a dev-only dependency to add a similar &lt;code&gt;mix x509.gen.selfsigned&lt;/code&gt; task to non-Phoenix projects.</source>
          <target state="translated">在&lt;a href=&quot;https://phoenixframework.org/&quot;&gt;凤凰城&lt;/a&gt;项目包括一个混合任务 &lt;code&gt;mix phx.gen.cert&lt;/code&gt; ，在应用程序的&amp;ldquo;私法&amp;rdquo;目录生成所需的文件，并把它们。该&lt;a href=&quot;https://hex.pm/packages/x509&quot;&gt;X509&lt;/a&gt;包可作为一个唯一的DEV-依赖于类似的添加 &lt;code&gt;mix x509.gen.selfsigned&lt;/code&gt; 任务非凤凰项目。</target>
        </trans-unit>
        <trans-unit id="d7dffb7977e667629020dcfd800d63da4bfbb976" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;mix.tasks.phx.gen.context&quot;&gt;&lt;code&gt;mix phx.gen.context&lt;/code&gt;&lt;/a&gt; task takes a number of arguments, the module name of the context, the module name of the schema, the resource name, and a list of column_name:type attributes.</source>
          <target state="translated">该&lt;a href=&quot;mix.tasks.phx.gen.context&quot;&gt; &lt;code&gt;mix phx.gen.context&lt;/code&gt; &lt;/a&gt;任务需要多个参数，上下文的模块名称，架构的模块名称，资源名称，和列名的列表：类型的属性。</target>
        </trans-unit>
        <trans-unit id="ed6566219635bf8a60afebbde390a8f984b47e1e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;mix.tasks.phx.gen.html&quot;&gt;&lt;code&gt;mix phx.gen.html&lt;/code&gt;&lt;/a&gt; task takes a number of arguments, the module name of the context, the module name of the schema, the resource name, and a list of column_name:type attributes. The module name we pass in must conform to the Elixir rules of module naming, following proper capitalization.</source>
          <target state="translated">该&lt;a href=&quot;mix.tasks.phx.gen.html&quot;&gt; &lt;code&gt;mix phx.gen.html&lt;/code&gt; &lt;/a&gt;任务需要多个参数，上下文的模块名称，架构的模块名称，资源名称，和列名的列表：类型的属性。我们传入的模块名称必须遵循正确的大小写，并符合Elixir的模块命名规则。</target>
        </trans-unit>
        <trans-unit id="753bc2e1d97fded3410ce3a6fc1fbd5a8326f374" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;mix.tasks.phx.gen.json&quot;&gt;&lt;code&gt;mix phx.gen.json&lt;/code&gt;&lt;/a&gt; task takes a number of arguments, the module name of the context, the module name of the schema, the resource name, and a list of column_name:type attributes. The module name we pass in must conform to the Elixir rules of module naming, following proper capitalization.</source>
          <target state="translated">该&lt;a href=&quot;mix.tasks.phx.gen.json&quot;&gt; &lt;code&gt;mix phx.gen.json&lt;/code&gt; &lt;/a&gt;任务需要多个参数，上下文的模块名称，架构的模块名称，资源名称，和列名的列表：类型的属性。我们传入的模块名称必须遵循正确的大小写，并符合Elixir的模块命名规则。</target>
        </trans-unit>
        <trans-unit id="eb0caef39b907649b24a2d0e495927e96ee71869" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;mix.tasks.phx.gen.schema&quot;&gt;&lt;code&gt;mix phx.gen.schema&lt;/code&gt;&lt;/a&gt; task takes a number of arguments, the module name of the schema (which may be namespaced), the resource name, and a list of column_name:type attributes.</source>
          <target state="translated">该&lt;a href=&quot;mix.tasks.phx.gen.schema&quot;&gt; &lt;code&gt;mix phx.gen.schema&lt;/code&gt; &lt;/a&gt;任务需要多个参数，模式（可以是命名空间）的模块名称，资源名称，和列名的列表：类型的属性。</target>
        </trans-unit>
        <trans-unit id="a05ece4440acf4d8599acde999876382edcbff28" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;phoenix.controller&quot;&gt;&lt;code&gt;Phoenix.Controller&lt;/code&gt;&lt;/a&gt; module provides the &lt;code&gt;put_flash/3&lt;/code&gt; and &lt;code&gt;get_flash/2&lt;/code&gt; functions to help us set and retrieve flash messages as a key value pair. Let's set two flash messages in our &lt;code&gt;HelloWeb.PageController&lt;/code&gt; to try this out.</source>
          <target state="translated">所述&lt;a href=&quot;phoenix.controller&quot;&gt; &lt;code&gt;Phoenix.Controller&lt;/code&gt; &lt;/a&gt;模块提供 &lt;code&gt;put_flash/3&lt;/code&gt; 和 &lt;code&gt;get_flash/2&lt;/code&gt; 的功能，以帮助我们设置和检索闪光消息作为关键值对。让我们在 &lt;code&gt;HelloWeb.PageController&lt;/code&gt; 中设置两个Flash消息来尝试一下。</target>
        </trans-unit>
        <trans-unit id="3f1d6571352636299c2a638ffac8ee18e017790a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;phoenix.controller&quot;&gt;&lt;code&gt;Phoenix.Controller&lt;/code&gt;&lt;/a&gt; module provides the &lt;code&gt;put_layout/2&lt;/code&gt; function for us to switch layouts. This takes &lt;code&gt;conn&lt;/code&gt; as its first argument and a string for the basename of the layout we want to render. It also accepts &lt;code&gt;false&lt;/code&gt; to disable the layout altogether.</source>
          <target state="translated">所述&lt;a href=&quot;phoenix.controller&quot;&gt; &lt;code&gt;Phoenix.Controller&lt;/code&gt; &lt;/a&gt;模块提供 &lt;code&gt;put_layout/2&lt;/code&gt; 功能为我们开关布局。这将 &lt;code&gt;conn&lt;/code&gt; 作为第一个参数，并使用一个字符串表示我们要呈现的布局的基本名称。它还接受 &lt;code&gt;false&lt;/code&gt; 以完全禁用布局。</target>
        </trans-unit>
        <trans-unit id="207e43d957b25557eabcceb34d7699aa7a77e89f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;phoenix.liveview#c:handle_params/3&quot;&gt;&lt;code&gt;handle_params/3&lt;/code&gt;&lt;/a&gt; callback is invoked after &lt;a href=&quot;phoenix.liveview#c:mount/3&quot;&gt;&lt;code&gt;mount/3&lt;/code&gt;&lt;/a&gt; and before the initial render. It is also invoked every time &lt;a href=&quot;phoenix.liveview.helpers#live_patch/2&quot;&gt;&lt;code&gt;live_patch/2&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;phoenix.liveview#push_patch/2&quot;&gt;&lt;code&gt;push_patch/2&lt;/code&gt;&lt;/a&gt; are used. It receives the request parameters as first argument, the url as second, and the socket as third.</source>
          <target state="translated">所述&lt;a href=&quot;phoenix.liveview#c:handle_params/3&quot;&gt; &lt;code&gt;handle_params/3&lt;/code&gt; &lt;/a&gt;回调之后调用&lt;a href=&quot;phoenix.liveview#c:mount/3&quot;&gt; &lt;code&gt;mount/3&lt;/code&gt; &lt;/a&gt;和之前的初始呈现。每当使用&lt;a href=&quot;phoenix.liveview.helpers#live_patch/2&quot;&gt; &lt;code&gt;live_patch/2&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;phoenix.liveview#push_patch/2&quot;&gt; &lt;code&gt;push_patch/2&lt;/code&gt; &lt;/a&gt;时，也会调用它。它接收请求参数作为第一个参数，URL作为第二个参数，以及套接字作为第三个参数。</target>
        </trans-unit>
        <trans-unit id="a3ab5765089e37fe00cdc982a6c6127904496f5f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;phoenix.pubsub#content&quot;&gt;&lt;code&gt;Phoenix.PubSub&lt;/code&gt;&lt;/a&gt; API allows any of its functions to handle a response from the adapter matching &lt;code&gt;{:perform, {m, f, a}}&lt;/code&gt;. The PubSub client will recursively invoke all MFA responses until a result is returned. This is useful for offloading work to clients without blocking your PubSub adapter. See &lt;a href=&quot;phoenix.pubsub.pg2&quot;&gt;&lt;code&gt;Phoenix.PubSub.PG2&lt;/code&gt;&lt;/a&gt; implementation for examples.</source>
          <target state="translated">所述&lt;a href=&quot;phoenix.pubsub#content&quot;&gt; &lt;code&gt;Phoenix.PubSub&lt;/code&gt; &lt;/a&gt; API允许其任何函数来处理从适配器匹配的响应 &lt;code&gt;{:perform, {m, f, a}}&lt;/code&gt; 。PubSub客户端将递归调用所有MFA响应，直到返回结果。这对于将工作卸载到客户端而不会阻塞PubSub适配器很有用。有关示例，请参见&lt;a href=&quot;phoenix.pubsub.pg2&quot;&gt; &lt;code&gt;Phoenix.PubSub.PG2&lt;/code&gt; &lt;/a&gt;实现。</target>
        </trans-unit>
        <trans-unit id="1b0c9e11a76593a12fc7ec6f78afc56ab4d36aaf" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;phoenix.pubsub#content&quot;&gt;&lt;code&gt;Phoenix.PubSub&lt;/code&gt;&lt;/a&gt; API allows any of its functions to handle a response from the adapter matching &lt;code&gt;{:perform, {m, f, a}}&lt;/code&gt;. The PubSub client will recursively invoke all MFA responses until a result is returned. This is useful for offloading work to clients without blocking your PubSub adapter. See &lt;code&gt;Phoenix.PubSub.PG2&lt;/code&gt; implementation for examples.</source>
          <target state="translated">所述&lt;a href=&quot;phoenix.pubsub#content&quot;&gt; &lt;code&gt;Phoenix.PubSub&lt;/code&gt; &lt;/a&gt; API允许其任何函数来处理从适配器匹配的响应 &lt;code&gt;{:perform, {m, f, a}}&lt;/code&gt; 。PubSub客户端将递归调用所有MFA响应，直到返回结果。这对于将工作卸载到客户端而不会阻塞PubSub适配器很有用。有关示例，请参见 &lt;code&gt;Phoenix.PubSub.PG2&lt;/code&gt; 实现。</target>
        </trans-unit>
        <trans-unit id="5f059f03c50e25491e9ade11affa506a5c85827c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;phoenix.router#forward/4&quot;&gt;&lt;code&gt;Phoenix.Router.forward/4&lt;/code&gt;&lt;/a&gt; macro can be used to send all requests that start with a particular path to a particular plug. Let's say we have a part of our system that is responsible (it could even be a separate application or library) for running jobs in the background, it could have its own web interface for checking the status of the jobs. We can forward to this admin interface using:</source>
          <target state="translated">该&lt;a href=&quot;phoenix.router#forward/4&quot;&gt; &lt;code&gt;Phoenix.Router.forward/4&lt;/code&gt; &lt;/a&gt;宏可用于发送与特定路径，特定插件启动的所有请求。假设我们有一部分系统负责在后台运行作业（甚至可以是一个单独的应用程序或库），它可以具有自己的Web界面来检查作业的状态。我们可以使用以下命令转发到该管理界面：</target>
        </trans-unit>
        <trans-unit id="cf89a86a0eb3ec72901bbad36238d748fb754a69" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;phoenix.router#resources/4&quot;&gt;&lt;code&gt;Phoenix.Router.resources/4&lt;/code&gt;&lt;/a&gt; macro describes additional options for customizing resource routes.</source>
          <target state="translated">该&lt;a href=&quot;phoenix.router#resources/4&quot;&gt; &lt;code&gt;Phoenix.Router.resources/4&lt;/code&gt; &lt;/a&gt;的宏介绍自定义资源路径的附加选项。</target>
        </trans-unit>
        <trans-unit id="f32ca35c51fcd8b2c79b98aed4633cc99e6aea64" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;plug.builder&quot;&gt;&lt;code&gt;Plug.Builder&lt;/code&gt;&lt;/a&gt; module provides conveniences for building plug pipelines.</source>
          <target state="translated">该&lt;a href=&quot;plug.builder&quot;&gt; &lt;code&gt;Plug.Builder&lt;/code&gt; &lt;/a&gt;模块提供了便利的环境建设塞管道。</target>
        </trans-unit>
        <trans-unit id="d6e79dbadb31903b9f92905b4723d4810b1bea76" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;phx_error&quot;&lt;/code&gt; event is sent by the transport when a channel exits, and represents the channel terminating against its will. The &lt;a href=&quot;#on_exit_message/3&quot;&gt;&lt;code&gt;on_exit_message/3&lt;/code&gt;&lt;/a&gt; function aids in constructing the &lt;code&gt;&quot;phx_error&quot;&lt;/code&gt; message.</source>
          <target state="translated">所述 &lt;code&gt;&quot;phx_error&quot;&lt;/code&gt; 事件是由当信道退出所述传输方式发送，并且表示针对其意愿信道终止。所述&lt;a href=&quot;#on_exit_message/3&quot;&gt; &lt;code&gt;on_exit_message/3&lt;/code&gt; &lt;/a&gt;功能助剂在构建 &lt;code&gt;&quot;phx_error&quot;&lt;/code&gt; 消息。</target>
        </trans-unit>
        <trans-unit id="6e450e02e99e9729245c2971a0f234ed37f3b636" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;%Phoenix.Socket.Message{}&lt;/code&gt; is the leave message for the transport to relay to the client.</source>
          <target state="translated">所述 &lt;code&gt;%Phoenix.Socket.Message{}&lt;/code&gt; 是对于传输中继到客户端的离开消息。</target>
        </trans-unit>
        <trans-unit id="bd539ef4a22e6b8ce30fc264d95352ee8a15cefe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;*_nulls_first&lt;/code&gt; and &lt;code&gt;*_nulls_last&lt;/code&gt; variants are not supported by all databases. While all databases default to ascending order, the choice of &quot;nulls first&quot; or &quot;nulls last&quot; is specific to each database implementation.</source>
          <target state="translated">在 &lt;code&gt;*_nulls_first&lt;/code&gt; 和 &lt;code&gt;*_nulls_last&lt;/code&gt; 变种并非所有的数据库支持。尽管所有数据库默认都按升序排列，但是&amp;ldquo;空首&amp;rdquo;或&amp;ldquo;后空&amp;rdquo;的选择特定于每种数据库实现。</target>
        </trans-unit>
        <trans-unit id="6d85a8224c78cbfc81cbb854cdafc632fe561a38" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;*_nulls_first&lt;/code&gt; and &lt;code&gt;*_nulls_last&lt;/code&gt; variants are not supported by all databases. While all databases default to ascending order, the choice of &amp;ldquo;nulls first&amp;rdquo; or &amp;ldquo;nulls last&amp;rdquo; is specific to each database implementation.</source>
          <target state="translated">在 &lt;code&gt;*_nulls_first&lt;/code&gt; 和 &lt;code&gt;*_nulls_last&lt;/code&gt; 变种并非所有的数据库支持。尽管所有数据库默认都按升序排列，但&amp;ldquo;空为首&amp;rdquo;或&amp;ldquo;空为最后&amp;rdquo;的选择特定于每个数据库实现。</target>
        </trans-unit>
        <trans-unit id="5adb9f7effcd9a92a5c3394cf706464a50f8e854" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--no-halt&lt;/code&gt; flag is automatically added.</source>
          <target state="translated">该 &lt;code&gt;--no-halt&lt;/code&gt; 标志被自动添加。</target>
        </trans-unit>
        <trans-unit id="23ed4ea9af36661b5bef1c1c6ac364a14dd0fd25" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--step&lt;/code&gt; option will behave the same way.</source>
          <target state="translated">该 &lt;code&gt;--step&lt;/code&gt; 选项行为相同的方式。</target>
        </trans-unit>
        <trans-unit id="4d285d5d2d694c280d2af59d2b72a39d127833e3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--to&lt;/code&gt; option will run all migrations up to and including given version.</source>
          <target state="translated">该 &lt;code&gt;--to&lt;/code&gt; 选项将运行所有迁移直至并包括特定版本。</target>
        </trans-unit>
        <trans-unit id="6ea39d3cb35a084383c1603b0beb3c4727483b5f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.eex&lt;/code&gt; extension maps to a template engine which tells Phoenix how to compile the code in the file into Elixir source code. After it is compiled, the template can be rendered as:</source>
          <target state="translated">该 &lt;code&gt;.eex&lt;/code&gt; 扩展映射到一个模板引擎，它告诉凤凰如何编译代码的文件到药剂源代码英寸 编译后，可以将模板呈现为：</target>
        </trans-unit>
        <trans-unit id="2663c4b667ff4ea7906e8eff89a8ab26b4176847" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.leex&lt;/code&gt; (Live EEx) template engine that tracks changes.</source>
          <target state="translated">跟踪更改的 &lt;code&gt;.leex&lt;/code&gt; （Live EEx）模板引擎。</target>
        </trans-unit>
        <trans-unit id="8d2cbe3b530a3545de3248339706a75f4da234de" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:aspect&lt;/code&gt; key of the struct specifies what field is still unfetched.</source>
          <target state="translated">结构的 &lt;code&gt;:aspect&lt;/code&gt; 键指定仍未获取的字段。</target>
        </trans-unit>
        <trans-unit id="ef67b3c2738d0f830da956da57f8a9d7ab9878ac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:authenticate&lt;/code&gt; plug will be invoked before the action. If the plug calls &lt;a href=&quot;../plug/1.5.1/plug.conn#halt/1&quot;&gt;&lt;code&gt;Plug.Conn.halt/1&lt;/code&gt;&lt;/a&gt; (which is by default imported into controllers), it will halt the pipeline and won&amp;rsquo;t inoke the action.</source>
          <target state="translated">的 &lt;code&gt;:authenticate&lt;/code&gt; 插件将在行动之前被调用。如果该插件调用&lt;a href=&quot;../plug/1.5.1/plug.conn#halt/1&quot;&gt; &lt;code&gt;Plug.Conn.halt/1&lt;/code&gt; &lt;/a&gt;（默认情况下已导入到控制器中），它将停止管道，并且不会调用该操作。</target>
        </trans-unit>
        <trans-unit id="2a2077bbe0dc1df2c551ae2d5305040e0b043053" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:authenticate&lt;/code&gt; plug will be invoked before the action. If the plug calls &lt;a href=&quot;../plug/plug.conn#halt/1&quot;&gt;&lt;code&gt;Plug.Conn.halt/1&lt;/code&gt;&lt;/a&gt; (which is by default imported into controllers), it will halt the pipeline and won't invoke the action.</source>
          <target state="translated">的 &lt;code&gt;:authenticate&lt;/code&gt; 插件将在行动之前被调用。如果插件调用&lt;a href=&quot;../plug/plug.conn#halt/1&quot;&gt; &lt;code&gt;Plug.Conn.halt/1&lt;/code&gt; &lt;/a&gt;（默认情况下已导入控制器），它将停止管道，并且不会调用该操作。</target>
        </trans-unit>
        <trans-unit id="18fe4cf95d7fab8a497960c08951af855a55d8a8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:browser&lt;/code&gt; and &lt;code&gt;:api&lt;/code&gt; Pipelines</source>
          <target state="translated">的 &lt;code&gt;:browser&lt;/code&gt; 和 &lt;code&gt;:api&lt;/code&gt; 管线</target>
        </trans-unit>
        <trans-unit id="c70cf91a624862bdabdacfdc0d7521b33d8e86b3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:browser&lt;/code&gt; pipeline has five plugs: &lt;code&gt;plug :accepts, [&quot;html&quot;]&lt;/code&gt; which defines the request format or formats which will be accepted, &lt;code&gt;:fetch_session&lt;/code&gt;, which, naturally, fetches the session data and makes it available in the connection, &lt;code&gt;:fetch_flash&lt;/code&gt; which retrieves any flash messages which may have been set, as well as &lt;code&gt;:protect_from_forgery&lt;/code&gt; and &lt;code&gt;:put_secure_browser_headers&lt;/code&gt;, which protects form posts from cross site forgery.</source>
          <target state="translated">的 &lt;code&gt;:browser&lt;/code&gt; 管道具有五个插头： &lt;code&gt;plug :accepts, [&quot;html&quot;]&lt;/code&gt; ，它定义请求格式或格式，其将被接受， &lt;code&gt;:fetch_session&lt;/code&gt; ，其中，自然，获取所述会话数据，并使其在所述连接可用， &lt;code&gt;:fetch_flash&lt;/code&gt; 它会检索可能已设置的所有Flash消息，以及 &lt;code&gt;:protect_from_forgery&lt;/code&gt; 和 &lt;code&gt;:put_secure_browser_headers&lt;/code&gt; ，从而保护表单帖子免受跨站点伪造。</target>
        </trans-unit>
        <trans-unit id="731f4c8f6efafb89aa6c584007065c777c291143" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:cd&lt;/code&gt; option can be used on a watcher to override the folder from which the watcher will run. By default this will be the project&amp;rsquo;s root: &lt;code&gt;File.cwd!()&lt;/code&gt;</source>
          <target state="translated">的 &lt;code&gt;:cd&lt;/code&gt; 选项可以在观察者可以用来覆盖从观察者将要运行的文件夹中。默认情况下，这将是项目的根目录： &lt;code&gt;File.cwd!()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0ae21bdba03584c806666010e52a2cb28db8be56" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:cd&lt;/code&gt; option can be used on a watcher to override the folder from which the watcher will run. By default this will be the project's root: &lt;code&gt;File.cwd!()&lt;/code&gt;</source>
          <target state="translated">的 &lt;code&gt;:cd&lt;/code&gt; 选项可以在观察者可以用来覆盖从观察者将要运行的文件夹中。默认情况下，这将是项目的根目录： &lt;code&gt;File.cwd!()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f7bc6b309b1a0d5dcb1c973131cf2999c439c9de" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:cipher_suite&lt;/code&gt; option provides &lt;code&gt;:strong&lt;/code&gt; and &lt;code&gt;:compatible&lt;/code&gt; options for setting up better cipher and version defaults according to the OWASP recommendations. See the &amp;ldquo;Cipher Suites&amp;rdquo; section below</source>
          <target state="translated">的 &lt;code&gt;:cipher_suite&lt;/code&gt; 选项提供 &lt;code&gt;:strong&lt;/code&gt; 和 &lt;code&gt;:compatible&lt;/code&gt; 用于根据OWASP建议建立更好的密码和版本默认选项。请参阅下面的&amp;ldquo;密码套件&amp;rdquo;部分</target>
        </trans-unit>
        <trans-unit id="1e4e2c269f3978f76ff199356c975a07324ab155" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:compatible&lt;/code&gt; profile additionally enables AES-CBC ciphers, as well as TLS versions 1.1 and 1.0. Use this configuration to allow connections from older clients, such as older PC or mobile operating systems. Note that RSA key exchange is not enabled by this configuration, due to known weaknesses, so to support clients that do not support ECDHE or DHE it is necessary specify the ciphers explicitly (see &lt;a href=&quot;#manual-configuration&quot;&gt;below&lt;/a&gt;).</source>
          <target state="translated">的 &lt;code&gt;:compatible&lt;/code&gt; 简档还使得AES-CBC加密，以及TLS版本1.1和1.0。使用此配置可​​以允许来自旧客户端（例如旧PC或移动操作系统）的连接。请注意，由于已知的弱点，此配置未启用RSA密钥交换，因此，要支持不支持ECDHE或DHE的客户端，必须明确指定密码（请参见&lt;a href=&quot;#manual-configuration&quot;&gt;下文&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="918f4e83de0e618dc7aa4875d78f6492629319c5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:content_type&lt;/code&gt; and &lt;code&gt;:filename&lt;/code&gt; fields in the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Plug.Upload&lt;/code&gt;&lt;/a&gt; struct are client-controlled. These values should be validated, via file content inspection or similar, before being trusted.</source>
          <target state="translated">&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Plug.Upload&lt;/code&gt; &lt;/a&gt;结构中的 &lt;code&gt;:content_type&lt;/code&gt; 和 &lt;code&gt;:filename&lt;/code&gt; 字段由客户端控制。在信任之前，应通过文件内容检查或类似方法验证这些值。</target>
        </trans-unit>
        <trans-unit id="3fb2b2f7e9b4811efb97cc3c2e5e5c07ea928f93" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:context&lt;/code&gt; field represents additional state some databases require for proper updates of data. It is not used by the built-in adapters of &lt;code&gt;Ecto.Adapters.Postgres&lt;/code&gt; and &lt;code&gt;Ecto.Adapters.MySQL&lt;/code&gt;.</source>
          <target state="translated">的 &lt;code&gt;:context&lt;/code&gt; 字段表示附加的状态有些数据库需要数据的适当的更新。 &lt;code&gt;Ecto.Adapters.Postgres&lt;/code&gt; 和 &lt;code&gt;Ecto.Adapters.MySQL&lt;/code&gt; 的内置适配器不使用它。</target>
        </trans-unit>
        <trans-unit id="ea6213d9c5c2d60d6a2f351db0efbb41962d6d16" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:context&lt;/code&gt; field represents additional state some databases require for proper updates of data. It is not used by the built-in adapters of &lt;code&gt;Ecto.Adapters.Postres&lt;/code&gt; and &lt;code&gt;Ecto.Adapters.MySQL&lt;/code&gt;.</source>
          <target state="translated">的 &lt;code&gt;:context&lt;/code&gt; 字段表示附加的状态有些数据库需要数据的适当的更新。 &lt;code&gt;Ecto.Adapters.Postres&lt;/code&gt; 和 &lt;code&gt;Ecto.Adapters.MySQL&lt;/code&gt; 的内置适配器不使用它。</target>
        </trans-unit>
        <trans-unit id="16a1d1418e35d766234890bac5372c3fa8aab917" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:delete&lt;/code&gt; option in particular must be used carefully as it would allow users to delete any associated data by simply not sending any data for a given field. If you need deletion, it is often preferred to manually mark the changeset for deletion if a &lt;code&gt;delete&lt;/code&gt; field is set in the params, as in the example below:</source>
          <target state="translated">的 &lt;code&gt;:delete&lt;/code&gt; 在特定选项必须小心使用，因为这将允许用户通过简单地不发送任何数据在指定字段，删除任何相关的数据。如果需要删除，通常最好手动设置更改集以进行删除（如果在参数中设置了 &lt;code&gt;delete&lt;/code&gt; 字段），如下例所示：</target>
        </trans-unit>
        <trans-unit id="5acd2290f1eeb3bc214ec527b315e41481bcb38d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:delete&lt;/code&gt; option in particular must be used carefully as it would allow users to delete any associated data. If you need deletion, it is often preferred to add a separate boolean virtual field to the changeset function that will allow you to manually mark it for deletion, as in the example below:</source>
          <target state="translated">的 &lt;code&gt;:delete&lt;/code&gt; 在特定选项必须小心使用，因为这将允许用户删除任何相关的数据。如果需要删除，通常最好将一个单独的布尔虚拟字段添加到changeset函数，该字段允许您手动将其标记为删除，如以下示例所示：</target>
        </trans-unit>
        <trans-unit id="c252a1b7d9e6defcdc7e6e2741931b5df0cd03a3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:duration&lt;/code&gt; measurements are presented in the &lt;code&gt;:native&lt;/code&gt; time unit. You can read more about it in the docs for &lt;a href=&quot;https://hexdocs.pm/elixir/System.html#convert_time_unit/3&quot;&gt;&lt;code&gt;System.convert_time_unit/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">本 &lt;code&gt;:duration&lt;/code&gt; 测量所呈现的 &lt;code&gt;:native&lt;/code&gt; 时间单位。您可以在&lt;a href=&quot;https://hexdocs.pm/elixir/System.html#convert_time_unit/3&quot;&gt; &lt;code&gt;System.convert_time_unit/3&lt;/code&gt; &lt;/a&gt;的文档中阅读有关它的更多信息。</target>
        </trans-unit>
        <trans-unit id="f0cb6c08b188d0d4ef6ec2d55ff0640a7a5a562f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:dynamic&lt;/code&gt; field contains a function that takes a boolean argument (see &quot;Tracking changes&quot; below), and returns a list of dynamic content. Each element in the list is either one of:</source>
          <target state="translated">的 &lt;code&gt;:dynamic&lt;/code&gt; 字段包含一个函数，一个布尔参数（请参阅&amp;ldquo;跟踪更改&amp;rdquo;下方），并返回动态内容的列表。列表中的每个元素都是以下之一：</target>
        </trans-unit>
        <trans-unit id="d742e4a33ea1296a531ccca07c5ea7b18db14083" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:host&lt;/code&gt; option requires a string or &lt;code&gt;{:system, &quot;ENV_VAR&quot;}&lt;/code&gt;. Similar to &lt;code&gt;:port&lt;/code&gt;, when given a tuple like &lt;code&gt;{:system, &quot;HOST&quot;}&lt;/code&gt;, the host will be referenced from &lt;code&gt;System.get_env(&quot;HOST&quot;)&lt;/code&gt; at runtime.</source>
          <target state="translated">的 &lt;code&gt;:host&lt;/code&gt; 选项需要一个字符串或 &lt;code&gt;{:system, &quot;ENV_VAR&quot;}&lt;/code&gt; 。类似于 &lt;code&gt;:port&lt;/code&gt; ，当给一个类似 &lt;code&gt;{:system, &quot;HOST&quot;}&lt;/code&gt; 的元组时，将在运行时从 &lt;code&gt;System.get_env(&quot;HOST&quot;)&lt;/code&gt; 引用主机。</target>
        </trans-unit>
        <trans-unit id="dd99d05cad94c87bb280dd5d83fd4ec31d3e120f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:id&lt;/code&gt; type is used when the primary key is an integer while the &lt;code&gt;:binary_id&lt;/code&gt; is used for primary keys in particular binary formats, which may be &lt;a href=&quot;ecto.uuid&quot;&gt;&lt;code&gt;Ecto.UUID&lt;/code&gt;&lt;/a&gt; for databases like PostgreSQL and MySQL, or some specific ObjectID or RecordID often imposed by NoSQL databases.</source>
          <target state="translated">的 &lt;code&gt;:id&lt;/code&gt; ，当主键是一个整数，而类型用于 &lt;code&gt;:binary_id&lt;/code&gt; 用于特别的二进制格式的主键，其可以是&lt;a href=&quot;ecto.uuid&quot;&gt; &lt;code&gt;Ecto.UUID&lt;/code&gt; &lt;/a&gt;像PostgreSQL和MySQL，或某些特定的ObjectID或的recordId经常通过的NoSQL强加数据库数据库。</target>
        </trans-unit>
        <trans-unit id="03335948c65fcf829d6e89720eb38d3cb4ea9a0c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:layout&lt;/code&gt; option on &lt;code&gt;use&lt;/code&gt; does not apply to LiveViews rendered within other LiveViews. If you want to render child live views or opt-in to a layout, use &lt;code&gt;:layout&lt;/code&gt; as an option in mount:</source>
          <target state="translated">的 &lt;code&gt;:layout&lt;/code&gt; 上选择 &lt;code&gt;use&lt;/code&gt; 不适用于其他LiveViews内呈现LiveViews。如果要渲染子实时视图或选择加入布局，请在挂载中使用 &lt;code&gt;:layout&lt;/code&gt; 作为选项：</target>
        </trans-unit>
        <trans-unit id="8d0a17946500299e7ee12b6af3689a1c4c43f8f8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:logo&lt;/code&gt; is preferred to be a base64-encoded data URI so not to make any external requests, though external URLs (eg, &lt;code&gt;https://...&lt;/code&gt;) are supported.</source>
          <target state="translated">在 &lt;code&gt;:logo&lt;/code&gt; 最好是一个base64编码的数据URI所以不作任何外部请求，但外部URL（例如， &lt;code&gt;https://...&lt;/code&gt; ）的支持。</target>
        </trans-unit>
        <trans-unit id="c3992bb8a6efd8a4bd3e7e1767377cc30d96b760" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:measurements&lt;/code&gt; map will include the following, all given in the &lt;code&gt;:native&lt;/code&gt; time unit:</source>
          <target state="translated">的 &lt;code&gt;:measurements&lt;/code&gt; 地图将包括以下内容，在所有给定 &lt;code&gt;:native&lt;/code&gt; 时间单位：</target>
        </trans-unit>
        <trans-unit id="25110dc298c23b6bcca6b66d8becb6c3ab0252e8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:name&lt;/code&gt; is required as part of &lt;code&gt;options&lt;/code&gt;. The remaining options are described below.</source>
          <target state="translated">的 &lt;code&gt;:name&lt;/code&gt; 被要求作为一部分 &lt;code&gt;options&lt;/code&gt; 。其余选项如下所述。</target>
        </trans-unit>
        <trans-unit id="4a144d9bf2ce178155262a9bed21600765bd913d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:name&lt;/code&gt; parameter will also be available in the function body as &lt;code&gt;conn.params[&quot;name&quot;]&lt;/code&gt; and &lt;code&gt;conn.path_params[&quot;name&quot;]&lt;/code&gt;.</source>
          <target state="translated">的 &lt;code&gt;:name&lt;/code&gt; 参数也将在函数体可作为 &lt;code&gt;conn.params[&quot;name&quot;]&lt;/code&gt; 和 &lt;code&gt;conn.path_params[&quot;name&quot;]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6c6a9f8fae8b3f03bb8da33b0dd63ade9e7c2388" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:namespace&lt;/code&gt; and &lt;code&gt;:path&lt;/code&gt; options are used to calculate template lookup paths. For example, if you are in &lt;code&gt;MyApp.UserView&lt;/code&gt; and the namespace is &lt;code&gt;MyApp&lt;/code&gt;, templates are expected at &lt;code&gt;Path.join(root, &quot;user&quot;)&lt;/code&gt;. On the other hand, if the view is &lt;code&gt;MyApp.Admin.UserView&lt;/code&gt;, the path will be &lt;code&gt;Path.join(root, &quot;admin/user&quot;)&lt;/code&gt; and so on. For explicit root path locations, the &lt;code&gt;:path&lt;/code&gt; option can be provided instead. The &lt;code&gt;:root&lt;/code&gt; and &lt;code&gt;:path&lt;/code&gt; are joined to form the final lookup path. A blank string may be provided to use the &lt;code&gt;:root&lt;/code&gt; path directly as the template lookup path.</source>
          <target state="translated">在 &lt;code&gt;:namespace&lt;/code&gt; 和 &lt;code&gt;:path&lt;/code&gt; 选项用来计算模板的查找路径。例如，如果您位于 &lt;code&gt;MyApp.UserView&lt;/code&gt; 中，并且名称空间为 &lt;code&gt;MyApp&lt;/code&gt; ，则模板应位于 &lt;code&gt;Path.join(root, &quot;user&quot;)&lt;/code&gt; 。另一方面，如果视图为 &lt;code&gt;MyApp.Admin.UserView&lt;/code&gt; ，则路径为 &lt;code&gt;Path.join(root, &quot;admin/user&quot;)&lt;/code&gt; ，依此类推。对于显式的根路径位置，可以提供 &lt;code&gt;:path&lt;/code&gt; 选项。的 &lt;code&gt;:root&lt;/code&gt; 和 &lt;code&gt;:path&lt;/code&gt; 被连接以形成最终的查找路径。可以提供一个空白字符串以将 &lt;code&gt;:root&lt;/code&gt; 路径直接用作模板查找路径。</target>
        </trans-unit>
        <trans-unit id="65a1f032809b2a80ee05ed26deb3f2fce84671c3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:namespace&lt;/code&gt; and &lt;code&gt;:path&lt;/code&gt; options are used to calculate template lookup paths. For example, if you are in &lt;code&gt;MyApp.UserView&lt;/code&gt; and the namespace is &lt;code&gt;MyApp&lt;/code&gt;, templates are expected at &lt;code&gt;Path.join(root, &quot;user&quot;)&lt;/code&gt;. On the other hand, if the view is &lt;code&gt;MyApp.Admin.UserView&lt;/code&gt;, the path will be &lt;code&gt;Path.join(root, &quot;admin/user&quot;)&lt;/code&gt; and so on. For explicit root path locations, the &lt;code&gt;:path&lt;/code&gt; option can instead be provided. The &lt;code&gt;:root&lt;/code&gt; and &lt;code&gt;:path&lt;/code&gt; are joined to form the final lookup path. A blank string may be provided to use the &lt;code&gt;:root&lt;/code&gt; path directly as the template lookup path.</source>
          <target state="translated">在 &lt;code&gt;:namespace&lt;/code&gt; 和 &lt;code&gt;:path&lt;/code&gt; 选项用来计算模板的查找路径。例如，如果您位于 &lt;code&gt;MyApp.UserView&lt;/code&gt; 中，且名称空间为 &lt;code&gt;MyApp&lt;/code&gt; ，则模板应位于 &lt;code&gt;Path.join(root, &quot;user&quot;)&lt;/code&gt; 。另一方面，如果视图为 &lt;code&gt;MyApp.Admin.UserView&lt;/code&gt; ，则路径将为 &lt;code&gt;Path.join(root, &quot;admin/user&quot;)&lt;/code&gt; ，依此类推。对于显式的根路径位置，可以改用 &lt;code&gt;:path&lt;/code&gt; 选项。的 &lt;code&gt;:root&lt;/code&gt; 和 &lt;code&gt;:path&lt;/code&gt; 被连接以形成最终的查找路径。可以提供一个空白字符串以将 &lt;code&gt;:root&lt;/code&gt; 路径直接用作模板查找路径。</target>
        </trans-unit>
        <trans-unit id="895c2ddd40cf8e3567de42e9bf12420974e19653" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:on_replace&lt;/code&gt; option</source>
          <target state="translated">的 &lt;code&gt;:on_replace&lt;/code&gt; 选项</target>
        </trans-unit>
        <trans-unit id="36d82b1b3e9c0c28b3952588185c19ae211245b0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:port&lt;/code&gt; option requires either an integer or string. The &lt;code&gt;:host&lt;/code&gt; option requires a string. The &lt;code&gt;:scheme&lt;/code&gt; option accepts &lt;code&gt;&quot;http&quot;&lt;/code&gt; and &lt;code&gt;&quot;https&quot;&lt;/code&gt; values. Default value is inferred from top level &lt;code&gt;:http&lt;/code&gt; or &lt;code&gt;:https&lt;/code&gt; option. It is useful when hosting Phoenix behind a load balancer or reverse proxy and terminating SSL there. The &lt;code&gt;:path&lt;/code&gt; option can be used to override root path. Useful when hosting Phoenix behind a reverse proxy with URL rewrite rules</source>
          <target state="translated">的 &lt;code&gt;:port&lt;/code&gt; 选项需要一个整数或字符串。的 &lt;code&gt;:host&lt;/code&gt; 选项需要一个字符串。的 &lt;code&gt;:scheme&lt;/code&gt; 选项接受 &lt;code&gt;&quot;http&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;https&quot;&lt;/code&gt; 的值。默认值是从顶级 &lt;code&gt;:http&lt;/code&gt; 或 &lt;code&gt;:https&lt;/code&gt; 选项推断出来的。在将Phoenix托管在负载平衡器或反向代理之后并在那里终止SSL时，此功能很有用。的 &lt;code&gt;:path&lt;/code&gt; 选项可用于覆盖根路径。在将Phoenix托管在具有URL重写规则的反向代理后面时很有用</target>
        </trans-unit>
        <trans-unit id="6168b39090f584c85cff0cc128125156fba6b515" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:port&lt;/code&gt; option requires either an integer, string, or &lt;code&gt;{:system, &quot;ENV_VAR&quot;}&lt;/code&gt;. When given a tuple like &lt;code&gt;{:system, &quot;PORT&quot;}&lt;/code&gt;, the port will be referenced from &lt;code&gt;System.get_env(&quot;PORT&quot;)&lt;/code&gt; at runtime as a workaround for releases where environment specific information is loaded only at compile-time.</source>
          <target state="translated">的 &lt;code&gt;:port&lt;/code&gt; 选项要求任一的整数，字符串或 &lt;code&gt;{:system, &quot;ENV_VAR&quot;}&lt;/code&gt; 。当给定类似 &lt;code&gt;{:system, &quot;PORT&quot;}&lt;/code&gt; 的元组时，将在运行时从 &lt;code&gt;System.get_env(&quot;PORT&quot;)&lt;/code&gt; 引用该端口，作为仅在编译时加载特定于环境的信息的发行版的解决方法。</target>
        </trans-unit>
        <trans-unit id="92d07421660bd7c638d8258897864e4a9cf3e6ef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:prefix&lt;/code&gt; option given to &lt;code&gt;from&lt;/code&gt;/&lt;code&gt;join&lt;/code&gt; has the highest precedence</source>
          <target state="translated">的 &lt;code&gt;:prefix&lt;/code&gt; 给选项 &lt;code&gt;from&lt;/code&gt; / &lt;code&gt;join&lt;/code&gt; 具有最高的优先级</target>
        </trans-unit>
        <trans-unit id="54e1957e79c6b007c7f23224e0a1670cbbc75677" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:pubsub_server&lt;/code&gt; must point to an existing pubsub server running in your application, which is included by default as &lt;code&gt;MyApp.PubSub&lt;/code&gt; for new applications.</source>
          <target state="translated">的 &lt;code&gt;:pubsub_server&lt;/code&gt; 必须指向你的应用程序，它在默认情况下为包括运行的现有服务器订阅协议 &lt;code&gt;MyApp.PubSub&lt;/code&gt; 新的应用程序。</target>
        </trans-unit>
        <trans-unit id="5cda43ef4ff3376cfc2c7af75979f3ba0d7ed620" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:reloadable_apps&lt;/code&gt; defaults to &lt;code&gt;nil&lt;/code&gt;. In such case default behaviour is to reload current project if it consists of single app, or all applications within umbrella project. You can set &lt;code&gt;:reloadable_apps&lt;/code&gt; to subset of default applications to reload only some of them, empty list - to effectively disable code reloader, or include external applications from library dependencies.</source>
          <target state="translated">的 &lt;code&gt;:reloadable_apps&lt;/code&gt; 默认 &lt;code&gt;nil&lt;/code&gt; 。在这种情况下，默认行为是重新加载当前项目（如果它包含单个应用程序或伞项目中的所有应用程序）。您可以将 &lt;code&gt;:reloadable_apps&lt;/code&gt; 设置为默认应用程序的子集，以仅重新加载其中的一部分（空列表），以有效地禁用代码重新加载器，或从库依赖项中包含外部应用程序。</target>
        </trans-unit>
        <trans-unit id="baa4db1aa422d9779d3b8729775b268f6c7f02de" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:remote_ip&lt;/code&gt; field in the &lt;a href=&quot;plug.conn&quot;&gt;&lt;code&gt;Plug.Conn&lt;/code&gt;&lt;/a&gt; struct by default contains the network peer IP address. Terminating TLS in a separate process or network element typically masks the actual client IP address from the Elixir application. If proxying is done at the HTTP layer, the original client IP address is often inserted into an HTTP header, e.g. 'X-Forwarded-For'. There are Plug packages available to extract the client IP from such a header and update the &lt;code&gt;:remote_ip&lt;/code&gt; field.</source>
          <target state="translated">默认情况下，&lt;a href=&quot;plug.conn&quot;&gt; &lt;code&gt;Plug.Conn&lt;/code&gt; &lt;/a&gt;结构中的 &lt;code&gt;:remote_ip&lt;/code&gt; 字段包含网络对等IP地址。在单独的进程或网络元素中终止TLS通常会掩盖Elixir应用程序中的实际客户端IP地址。如果代理是在HTTP层完成的，则通常将原始客户端IP地址插入HTTP标头中，例如&amp;ldquo; X-Forwarded-For&amp;rdquo;。有插件程序包可用于从此类报头中提取客户端IP并更新 &lt;code&gt;:remote_ip&lt;/code&gt; 字段。</target>
        </trans-unit>
        <trans-unit id="ed05e3737398b3c2beccb1cfaf10e740d96858b4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:root&lt;/code&gt; option is required while the &lt;code&gt;:namespace&lt;/code&gt; defaults to the first nesting in the module name. For instance, both &lt;code&gt;MyApp.UserView&lt;/code&gt; and &lt;code&gt;MyApp.Admin.UserView&lt;/code&gt; have namespace &lt;code&gt;MyApp&lt;/code&gt;.</source>
          <target state="translated">的 &lt;code&gt;:root&lt;/code&gt; 选项是必需的，而 &lt;code&gt;:namespace&lt;/code&gt; 将默认为模块名称的第一个嵌套。例如， &lt;code&gt;MyApp.UserView&lt;/code&gt; 和 &lt;code&gt;MyApp.Admin.UserView&lt;/code&gt; 都具有名称空间 &lt;code&gt;MyApp&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1a3296e1c3da0ddff618bfd191c05b175ff0cb1b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:schema&lt;/code&gt; field refers the module name for the schema this metadata belongs to.</source>
          <target state="translated">的 &lt;code&gt;:schema&lt;/code&gt; 领域指的模块名称为元数据属于该模式。</target>
        </trans-unit>
        <trans-unit id="e2763632c3bc8d8b6f69e916c553e100096271d4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:selected&lt;/code&gt; option will mark the given IDs as selected unless the form is being resubmitted. When resubmitted, it uses the form params as values.</source>
          <target state="translated">的 &lt;code&gt;:selected&lt;/code&gt; 作为选择，除非窗体被重新提交选项将标志着给定的ID。重新提交时，它将使用形式参数作为值。</target>
        </trans-unit>
        <trans-unit id="0cea6902bf81cf806e2e2ff5a1334ab75f6b0054" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:source&lt;/code&gt; tracks the (table or collection) where the struct is or should be persisted to.</source>
          <target state="translated">的 &lt;code&gt;:source&lt;/code&gt; 跟踪（表或集合），其中结构是或应该被保存到。</target>
        </trans-unit>
        <trans-unit id="c67eef75ef4d15947c1d4d035bc00669b3f024ef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:static&lt;/code&gt; field is a list of literal strings. This allows the Elixir compiler to optimize this list and avoid allocating its strings on every render.</source>
          <target state="translated">的 &lt;code&gt;:static&lt;/code&gt; 字段是文字字符串列表。这使Elixir编译器可以优化此列表，并避免在每个渲染器上分配其字符串。</target>
        </trans-unit>
        <trans-unit id="77ec232b6cfcdbc23d88179e41f0fb0e88f686fe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:strong&lt;/code&gt; profile enables AES-GCM ciphers with ECDHE or DHE key exchange, and TLS version 1.2 only. It is intended for typical installations with support for browsers and other modern clients.</source>
          <target state="translated">的 &lt;code&gt;:strong&lt;/code&gt; 轮廓使得与ECDHE或DHE密钥交换和TLS 1.2版本仅AES-GCM密码。它旨在用于支持浏览器和其他现代客户端的典型安装。</target>
        </trans-unit>
        <trans-unit id="81e4f3969fca2a0c0bce3d4dfbb896188d5e6e36" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:where&lt;/code&gt; option expects a keyword list where the key is an atom representing the field and the value is either:</source>
          <target state="translated">的 &lt;code&gt;:where&lt;/code&gt; 选项期望一个关键字列表，其中键是表示字段和值的原子可以是：</target>
        </trans-unit>
        <trans-unit id="3d6613c6ae5cafc810769cb60c6e62f072ba58bc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:where&lt;/code&gt; option may receive a dynamic query, a keyword list or a MFA (a tuple with a module, function and args to invoke). The MFA is especially useful to avoid duplication in those definitions:</source>
          <target state="translated">的 &lt;code&gt;:where&lt;/code&gt; 选项可以接收动态查询，关键字列表或MFA（带的模块，功能和args调用元组）。MFA对于避免重复这些定义特别有用：</target>
        </trans-unit>
        <trans-unit id="cdf5ea7cc064d3fd02c24e10f92c4d06b0296467" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@endpoint&lt;/code&gt; module attribute contains the endpoint under testing, most commonly your application endpoint itself. If you are using the MyApp.ConnCase generated by Phoenix, it is automatically set for you.</source>
          <target state="translated">该 &lt;code&gt;@endpoint&lt;/code&gt; 模块属性包含在测试终点，最常用的应用程序端点本身。如果您使用的是Phoenix生成的MyApp.ConnCase，则会自动为您设置。</target>
        </trans-unit>
        <trans-unit id="fbb7111fae5bbf19a11fce2dbdf8ba880cacae4e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@primary_key&lt;/code&gt; attribute will tell ecto which type to use for the id.</source>
          <target state="translated">该 &lt;code&gt;@primary_key&lt;/code&gt; 属性会告诉外生使用的ID哪种类型。</target>
        </trans-unit>
        <trans-unit id="010ab761c017e85e79712afcc13c2e028e60df3a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@shortdoc&lt;/code&gt; module attribute holds a string which will describe our task when users invoke &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Help.html&quot;&gt;&lt;code&gt;mix help&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该 &lt;code&gt;@shortdoc&lt;/code&gt; 模块属性包含一个字符串，将介绍我们的任务，当用户调用&lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Help.html&quot;&gt; &lt;code&gt;mix help&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8e515ce695757264b1c2dae6b68e6bbfbc7f198c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;POST&lt;/code&gt; method can be overridden only by these HTTP methods:</source>
          <target state="translated">该 &lt;code&gt;POST&lt;/code&gt; 方法只能通过这些HTTP方法被覆盖：</target>
        </trans-unit>
        <trans-unit id="ef584d71c526b4b7d03dc94f80f6e8f1d6008b5c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PageController&lt;/code&gt; gives us the &lt;code&gt;index&lt;/code&gt; action to display the Phoenix welcome page associated with the default route Phoenix defines in the router.</source>
          <target state="translated">该 &lt;code&gt;PageController&lt;/code&gt; 给我们的 &lt;code&gt;index&lt;/code&gt; 动作，以显示与默认路由凤凰定义了路由器相关的凤凰欢迎页面。</target>
        </trans-unit>
        <trans-unit id="65f0d0f4bd596df0232f105e5e46a46047747cd7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SignUp&lt;/code&gt; schema can be cast and validated with the help of the &lt;a href=&quot;ecto.changeset&quot;&gt;&lt;code&gt;Ecto.Changeset&lt;/code&gt;&lt;/a&gt; module, and afterwards, you can copy its data to the &lt;code&gt;Profile&lt;/code&gt; and &lt;code&gt;Account&lt;/code&gt; structs that will be persisted to the database with the help of &lt;a href=&quot;ecto.repo&quot;&gt;&lt;code&gt;Ecto.Repo&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该 &lt;code&gt;SignUp&lt;/code&gt; 模式可投，并与的帮助验证&lt;a href=&quot;ecto.changeset&quot;&gt; &lt;code&gt;Ecto.Changeset&lt;/code&gt; &lt;/a&gt;模块，事后，你可以将其数据复制到 &lt;code&gt;Profile&lt;/code&gt; 和 &lt;code&gt;Account&lt;/code&gt; 将被保存到数据库的帮助下结构&lt;a href=&quot;ecto.repo&quot;&gt; &lt;code&gt;Ecto.Repo&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0027e32d65973e3996206f15f8d2bc1ec48ab7bb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Tracker&lt;/code&gt; API is used as a facade for a pool of &lt;a href=&quot;phoenix.tracker.shard&quot;&gt;&lt;code&gt;Phoenix.Tracker.Shard&lt;/code&gt;&lt;/a&gt;s. The responsibility of which calls go to which &lt;code&gt;Shard&lt;/code&gt; is determined based on the topic, on which a given function is called.</source>
          <target state="translated">该 &lt;code&gt;Tracker&lt;/code&gt; API被用作池门面&lt;a href=&quot;phoenix.tracker.shard&quot;&gt; &lt;code&gt;Phoenix.Tracker.Shard&lt;/code&gt; &lt;/a&gt;秒。根据主题确定调用哪个 &lt;code&gt;Shard&lt;/code&gt; 的责任，并根据该主题调用给定的函数。</target>
        </trans-unit>
        <trans-unit id="e5479c3d20fe1168228ba562f220f909f384e32e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;UserRegistration&lt;/code&gt; setup is likely simpler to implement than the dynamic author system we built &amp;ndash; we decided to take the harder path exactly because those are decisions developers take on their applications every day.</source>
          <target state="translated">该 &lt;code&gt;UserRegistration&lt;/code&gt; 设置可能比简单我们建立了动态笔者的系统来实现-我们决定采取较硬的路径正是因为这些都是决定开发商他们的应用程序每天服用。</target>
        </trans-unit>
        <trans-unit id="65dac19423140ef75ddacc313c1b338418cdd245" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;[:telemetry]&lt;/code&gt; library allows you to emit events at various stages of an application's lifecycle. You can then respond to these events by, among other things, aggregating them as metrics and sending the metrics data to a reporting destination.</source>
          <target state="translated">在 &lt;code&gt;[:telemetry]&lt;/code&gt; 库允许你在发出一个应用程序生命周期的各个阶段的活动。然后，您可以通过将这些事件汇总为度量标准并将度量标准数据发送到报告目标等方式来响应这些事件。</target>
        </trans-unit>
        <trans-unit id="a0004743ff2da907b7bfb6253848e44f110fc051" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;_url&lt;/code&gt; functions will get the host, port, proxy port, and SSL information needed to construct the full URL from the configuration parameters set for each environment. We'll talk about configuration in more detail in its own guide. For now, you can take a look at &lt;code&gt;config/dev.exs&lt;/code&gt; file in your own project to see those values.</source>
          <target state="translated">该 &lt;code&gt;_url&lt;/code&gt; 功能将得到主机，端口，代理端口和SSL信息来构建从每个环境设置配置参数的完整URL需要。我们将在其自己的指南中更详细地讨论配置。现在，您可以在自己的项目中查看 &lt;code&gt;config/dev.exs&lt;/code&gt; 文件，以查看这些值。</target>
        </trans-unit>
        <trans-unit id="9380732d83d99aa3ef7e1ee94986487b7d7501fc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;adapter_meta&lt;/code&gt; field is a map containing some of the fields found in the &lt;a href=&quot;ecto.query&quot;&gt;&lt;code&gt;Ecto.Query&lt;/code&gt;&lt;/a&gt; struct.</source>
          <target state="translated">所述 &lt;code&gt;adapter_meta&lt;/code&gt; 字段是包含一些在发现的字段的地图&lt;a href=&quot;ecto.query&quot;&gt; &lt;code&gt;Ecto.Query&lt;/code&gt; &lt;/a&gt;结构。</target>
        </trans-unit>
        <trans-unit id="1f72cda2deb8565937044253265942493bf6aa90" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;belongs_to&lt;/code&gt; association on &lt;code&gt;MyApp.Comment&lt;/code&gt; will also define a &lt;code&gt;:post_id&lt;/code&gt; field with &lt;code&gt;:binary_id&lt;/code&gt; type that references the &lt;code&gt;:id&lt;/code&gt; field of the &lt;code&gt;MyApp.Post&lt;/code&gt; schema.</source>
          <target state="translated">&lt;code&gt;MyApp.Comment&lt;/code&gt; 上的 &lt;code&gt;belongs_to&lt;/code&gt; 关联还将定义一个类型为 &lt;code&gt;:binary_id&lt;/code&gt; 的 &lt;code&gt;:post_id&lt;/code&gt; 字段，该类型引用 &lt;code&gt;MyApp.Post&lt;/code&gt; 模式的 &lt;code&gt;:id&lt;/code&gt; 字段。</target>
        </trans-unit>
        <trans-unit id="87e3861a73f975bf0651f08b600e6e3ad95f45d6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cacertfile&lt;/code&gt; option is not needed when using a self-signed certificate, or when the file pointed to by &lt;code&gt;certfile&lt;/code&gt; contains both the server certificate and all necessary CA chain certificates:</source>
          <target state="translated">该 &lt;code&gt;cacertfile&lt;/code&gt; 使用自签名证书时，或当指向的文件不需要选项 &lt;code&gt;certfile&lt;/code&gt; 既包含了服务器证书和所有必要的CA证书链：</target>
        </trans-unit>
        <trans-unit id="778cb135fc988ae8195d411110c29d421206d37f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;call/2&lt;/code&gt; function that &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Plug.Builder&lt;/code&gt;&lt;/a&gt; provides is used internally to execute all the plugs listed using the &lt;code&gt;plug&lt;/code&gt; macro, so overriding the &lt;code&gt;call/2&lt;/code&gt; function generally implies using &lt;code&gt;super&lt;/code&gt; in order to still call the plug chain:</source>
          <target state="translated">&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Plug.Builder&lt;/code&gt; &lt;/a&gt;提供的 &lt;code&gt;call/2&lt;/code&gt; 函数在内部用于执行使用 &lt;code&gt;plug&lt;/code&gt; 宏列出的所有插件，因此，覆盖 &lt;code&gt;call/2&lt;/code&gt; 函数通常意味着使用 &lt;code&gt;super&lt;/code&gt; 以便仍然调用插件链：</target>
        </trans-unit>
        <trans-unit id="6752d9d305fe4dabd6e9f7e8abc5275de174456b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;call/2&lt;/code&gt; function that &lt;a href=&quot;plug.builder#content&quot;&gt;&lt;code&gt;Plug.Builder&lt;/code&gt;&lt;/a&gt; provides is used internally to execute all the plugs listed using the &lt;code&gt;plug&lt;/code&gt; macro, so overriding the &lt;code&gt;call/2&lt;/code&gt; function generally implies using &lt;code&gt;super&lt;/code&gt; in order to still call the plug chain:</source>
          <target state="translated">&lt;a href=&quot;plug.builder#content&quot;&gt; &lt;code&gt;Plug.Builder&lt;/code&gt; &lt;/a&gt;提供的 &lt;code&gt;call/2&lt;/code&gt; 函数在内部用于执行使用 &lt;code&gt;plug&lt;/code&gt; 宏列出的所有插件，因此，覆盖 &lt;code&gt;call/2&lt;/code&gt; 函数通常意味着使用 &lt;code&gt;super&lt;/code&gt; 以便仍然调用插件链：</target>
        </trans-unit>
        <trans-unit id="59369e81ae4c82531a9066b2b16f4703c7464cfc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;changeset/2&lt;/code&gt; function first invokes &lt;a href=&quot;ecto.changeset#cast/4&quot;&gt;&lt;code&gt;Ecto.Changeset.cast/4&lt;/code&gt;&lt;/a&gt; with the struct, the parameters and a list of allowed fields; this returns a changeset. The parameters is a map with binary keys and values that will be cast based on the type defined on the schema.</source>
          <target state="translated">的 &lt;code&gt;changeset/2&lt;/code&gt; 函数首先调用&lt;a href=&quot;ecto.changeset#cast/4&quot;&gt; &lt;code&gt;Ecto.Changeset.cast/4&lt;/code&gt; &lt;/a&gt;与结构，参数和允许字段的列表; 这将返回一个变更集。参数是一个具有二进制键和值的映射，这些键和值将根据模式上定义的类型进行转换。</target>
        </trans-unit>
        <trans-unit id="fcd29f0f3ca38c03e6a05f563bf7684e923be86d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;channel&lt;/code&gt; macro accepts topic patterns in two flavors. A splat (the &lt;code&gt;*&lt;/code&gt; character) argument can be provided as the last character to indicate a &lt;code&gt;&quot;topic:subtopic&quot;&lt;/code&gt; match. If a plain string is provided, only that topic will match the channel handler. Most use-cases will use the &lt;code&gt;&quot;topic:*&quot;&lt;/code&gt; pattern to allow more versatile topic scoping.</source>
          <target state="translated">该 &lt;code&gt;channel&lt;/code&gt; 宏接受两个版本的主题模式。可以使用splat（ &lt;code&gt;*&lt;/code&gt; 字符）参数作为最后一个字符，以表示 &lt;code&gt;&quot;topic:subtopic&quot;&lt;/code&gt; 匹配。如果提供了纯字符串，则仅该主题将与通道处理程序匹配。大多数用例将使用 &lt;code&gt;&quot;topic:*&quot;&lt;/code&gt; 模式来允许更广泛的主题作用域。</target>
        </trans-unit>
        <trans-unit id="2294206fb3a150cd9c224614317f9aee05e6f3e3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;channel&lt;/code&gt; macro accepts topic patterns in two flavors. A splat argument can be provided as the last character to indicate a &amp;ldquo;topic:subtopic&amp;rdquo; match. If a plain string is provided, only that topic will match the channel handler. Most use-cases will use the &amp;ldquo;topic:*&amp;rdquo; pattern to allow more versatile topic scoping.</source>
          <target state="translated">该 &lt;code&gt;channel&lt;/code&gt; 宏接受两个版本的主题模式。可以提供splat参数作为最后一个字符，以指示&amp;ldquo; topic：subtopic&amp;rdquo;匹配。如果提供了纯字符串，则仅该主题将与通道处理程序匹配。大多数用例将使用&amp;ldquo; topic：*&amp;rdquo;模式来进行更多用途的主题范围界定。</target>
        </trans-unit>
        <trans-unit id="6fd75bfb56e80fb59c39a66cbca5dfc544043958" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;do/end&lt;/code&gt; will be available as an anonymous function in an assign named &lt;code&gt;@inner_content&lt;/code&gt;. The anonymous function must be invoked passing a new set of assigns that will be merged into the user assigns. For example, the grid component above could be implemented as:</source>
          <target state="translated">该 &lt;code&gt;do/end&lt;/code&gt; 将作为在分配名为匿名函数 &lt;code&gt;@inner_content&lt;/code&gt; 。必须调用匿名函数，并传递一组新的分配，这些分配将合并到用户分配中。例如，上面的网格组件可以实现为：</target>
        </trans-unit>
        <trans-unit id="0566567c74373795b6261b3892abb0503ed0e625" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dynamic&lt;/code&gt; macro can be interpolated at the root of a &lt;code&gt;where&lt;/code&gt;, &lt;code&gt;having&lt;/code&gt; or a &lt;code&gt;join&lt;/code&gt;'s &lt;code&gt;on&lt;/code&gt;.</source>
          <target state="translated">的 &lt;code&gt;dynamic&lt;/code&gt; 宏可以在的根被内插 &lt;code&gt;where&lt;/code&gt; ， &lt;code&gt;having&lt;/code&gt; 或 &lt;code&gt;join&lt;/code&gt; 的 &lt;code&gt;on&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="077b06b43fe5cab3947b5c73d7e014aabfed4b80" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ecto.rollback&lt;/code&gt; task will reverse the last migration we have run, undoing the schema changes. &lt;code&gt;ecto.migrate&lt;/code&gt; and &lt;code&gt;ecto.rollback&lt;/code&gt; are mirror images of each other.</source>
          <target state="translated">该 &lt;code&gt;ecto.rollback&lt;/code&gt; 任务将扭转我们已经运行了最后的迁移，撤消架构更改。 &lt;code&gt;ecto.migrate&lt;/code&gt; 和 &lt;code&gt;ecto.rollback&lt;/code&gt; 是彼此的镜像。</target>
        </trans-unit>
        <trans-unit id="b47faccb75d970d09e733fcef42fb4e981d00af8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;element&lt;/code&gt; is created with &lt;a href=&quot;#element/3&quot;&gt;&lt;code&gt;element/3&lt;/code&gt;&lt;/a&gt; and must point to a single element on the page with a &lt;code&gt;phx-blur&lt;/code&gt; attribute in it. The event name given set on &lt;code&gt;phx-blur&lt;/code&gt; is then sent to the appropriate LiveView (or component if &lt;code&gt;phx-target&lt;/code&gt; is set accordingly). All &lt;code&gt;phx-value-*&lt;/code&gt; entries in the element are sent as values. Extra values can be given with the &lt;code&gt;value&lt;/code&gt; argument.</source>
          <target state="translated">该 &lt;code&gt;element&lt;/code&gt; 是使用&lt;a href=&quot;#element/3&quot;&gt; &lt;code&gt;element/3&lt;/code&gt; &lt;/a&gt;创建的，并且必须指向页面中具有 &lt;code&gt;phx-blur&lt;/code&gt; 属性的单个元素。然后，将在 &lt;code&gt;phx-blur&lt;/code&gt; 上设置的事件名称给定发送到适当的LiveView（或组件，如果已相应设置 &lt;code&gt;phx-target&lt;/code&gt; ）。元素中的所有 &lt;code&gt;phx-value-*&lt;/code&gt; 条目均作为值发送。可以使用 &lt;code&gt;value&lt;/code&gt; 参数指定额外的值。</target>
        </trans-unit>
        <trans-unit id="5019576176da0a0182ad14b8fd3ae5734cc494eb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;element&lt;/code&gt; is created with &lt;a href=&quot;#element/3&quot;&gt;&lt;code&gt;element/3&lt;/code&gt;&lt;/a&gt; and must point to a single element on the page with a &lt;code&gt;phx-change&lt;/code&gt; attribute in it. The event name given set on &lt;code&gt;phx-change&lt;/code&gt; is then sent to the appropriate LiveView (or component if &lt;code&gt;phx-target&lt;/code&gt; is set accordingly). All &lt;code&gt;phx-value-*&lt;/code&gt; entries in the element are sent as values.</source>
          <target state="translated">该 &lt;code&gt;element&lt;/code&gt; 是使用&lt;a href=&quot;#element/3&quot;&gt; &lt;code&gt;element/3&lt;/code&gt; &lt;/a&gt;创建的，并且必须指向页面中具有 &lt;code&gt;phx-change&lt;/code&gt; 属性的单个元素。然后，将在 &lt;code&gt;phx-change&lt;/code&gt; 上设置的事件名称给定发送到适当的LiveView（或组件，如果已相应设置 &lt;code&gt;phx-target&lt;/code&gt; ）。元素中的所有 &lt;code&gt;phx-value-*&lt;/code&gt; 条目均作为值发送。</target>
        </trans-unit>
        <trans-unit id="d153088b0ac1c3ab072462dcfc030a49a5bb2603" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;element&lt;/code&gt; is created with &lt;a href=&quot;#element/3&quot;&gt;&lt;code&gt;element/3&lt;/code&gt;&lt;/a&gt; and must point to a single element on the page with a &lt;code&gt;phx-click&lt;/code&gt; attribute in it. The event name given set on &lt;code&gt;phx-click&lt;/code&gt; is then sent to the appropriate LiveView (or component if &lt;code&gt;phx-target&lt;/code&gt; is set accordingly). All &lt;code&gt;phx-value-*&lt;/code&gt; entries in the element are sent as values. Extra values can be given with the &lt;code&gt;value&lt;/code&gt; argument.</source>
          <target state="translated">该 &lt;code&gt;element&lt;/code&gt; 是使用&lt;a href=&quot;#element/3&quot;&gt; &lt;code&gt;element/3&lt;/code&gt; &lt;/a&gt;创建的，并且必须指向页面中具有 &lt;code&gt;phx-click&lt;/code&gt; 属性的单个元素。然后将在 &lt;code&gt;phx-click&lt;/code&gt; 上设置的给定事件名称发送到适当的LiveView（或组件，如果已相应设置 &lt;code&gt;phx-target&lt;/code&gt; ）。元素中的所有 &lt;code&gt;phx-value-*&lt;/code&gt; 条目均作为值发送。可以使用 &lt;code&gt;value&lt;/code&gt; 参数指定额外的值。</target>
        </trans-unit>
        <trans-unit id="7cc050be15922cc83544181133c115aeaf56c9ea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;element&lt;/code&gt; is created with &lt;a href=&quot;#element/3&quot;&gt;&lt;code&gt;element/3&lt;/code&gt;&lt;/a&gt; and must point to a single element on the page with a &lt;code&gt;phx-focus&lt;/code&gt; attribute in it. The event name given set on &lt;code&gt;phx-focus&lt;/code&gt; is then sent to the appropriate LiveView (or component if &lt;code&gt;phx-target&lt;/code&gt; is set accordingly). All &lt;code&gt;phx-value-*&lt;/code&gt; entries in the element are sent as values. Extra values can be given with the &lt;code&gt;value&lt;/code&gt; argument.</source>
          <target state="translated">该 &lt;code&gt;element&lt;/code&gt; 是使用&lt;a href=&quot;#element/3&quot;&gt; &lt;code&gt;element/3&lt;/code&gt; &lt;/a&gt;创建的，并且必须指向页面中具有 &lt;code&gt;phx-focus&lt;/code&gt; 属性的单个元素。然后，将在 &lt;code&gt;phx-focus&lt;/code&gt; 上设置的给定事件名称发送到适当的LiveView（如果已相应设置 &lt;code&gt;phx-target&lt;/code&gt; ,则将其发送到组件）。元素中的所有 &lt;code&gt;phx-value-*&lt;/code&gt; 条目均作为值发送。可以使用 &lt;code&gt;value&lt;/code&gt; 参数指定额外的值。</target>
        </trans-unit>
        <trans-unit id="3a8552f5bca94ee3cd7fe7fd6d2f0771c726944d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;element&lt;/code&gt; is created with &lt;a href=&quot;#element/3&quot;&gt;&lt;code&gt;element/3&lt;/code&gt;&lt;/a&gt; and must point to a single element on the page with a &lt;code&gt;phx-keydown&lt;/code&gt; or &lt;code&gt;phx-window-keydown&lt;/code&gt; attribute in it. The event name given set on &lt;code&gt;phx-keydown&lt;/code&gt; is then sent to the appropriate LiveView (or component if &lt;code&gt;phx-target&lt;/code&gt; is set accordingly). All &lt;code&gt;phx-value-*&lt;/code&gt; entries in the element are sent as values. Extra values can be given with the &lt;code&gt;value&lt;/code&gt; argument.</source>
          <target state="translated">该 &lt;code&gt;element&lt;/code&gt; 是使用&lt;a href=&quot;#element/3&quot;&gt; &lt;code&gt;element/3&lt;/code&gt; &lt;/a&gt;创建的，并且必须指向页面中具有 &lt;code&gt;phx-keydown&lt;/code&gt; 或 &lt;code&gt;phx-window-keydown&lt;/code&gt; 属性的单个元素。然后，将在 &lt;code&gt;phx-keydown&lt;/code&gt; 上设置的事件名称给定发送到适当的LiveView（或组件（如果已相应设置 &lt;code&gt;phx-target&lt;/code&gt; ））。元素中的所有 &lt;code&gt;phx-value-*&lt;/code&gt; 条目均作为值发送。可以使用 &lt;code&gt;value&lt;/code&gt; 参数指定额外的值。</target>
        </trans-unit>
        <trans-unit id="346fe7c5d882669468106690d1f552e7e73c91d2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;element&lt;/code&gt; is created with &lt;a href=&quot;#element/3&quot;&gt;&lt;code&gt;element/3&lt;/code&gt;&lt;/a&gt; and must point to a single element on the page with a &lt;code&gt;phx-keyup&lt;/code&gt; or &lt;code&gt;phx-window-keyup&lt;/code&gt; attribute in it. The event name given set on &lt;code&gt;phx-keyup&lt;/code&gt; is then sent to the appropriate LiveView (or component if &lt;code&gt;phx-target&lt;/code&gt; is set accordingly). All &lt;code&gt;phx-value-*&lt;/code&gt; entries in the element are sent as values. Extra values can be given with the &lt;code&gt;value&lt;/code&gt; argument.</source>
          <target state="translated">该 &lt;code&gt;element&lt;/code&gt; 是使用&lt;a href=&quot;#element/3&quot;&gt; &lt;code&gt;element/3&lt;/code&gt; &lt;/a&gt;创建的，并且必须指向页面中具有 &lt;code&gt;phx-keyup&lt;/code&gt; 或 &lt;code&gt;phx-window-keyup&lt;/code&gt; 属性的单个元素。然后，将在 &lt;code&gt;phx-keyup&lt;/code&gt; 上设置的事件名称给定发送到适当的LiveView（或组件，如果已相应设置 &lt;code&gt;phx-target&lt;/code&gt; ）。元素中的所有 &lt;code&gt;phx-value-*&lt;/code&gt; 条目均作为值发送。可以使用 &lt;code&gt;value&lt;/code&gt; 参数指定额外的值。</target>
        </trans-unit>
        <trans-unit id="8a298b368b8d58666332ac5fd98b74d5ced7a849" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;element&lt;/code&gt; is created with &lt;a href=&quot;#element/3&quot;&gt;&lt;code&gt;element/3&lt;/code&gt;&lt;/a&gt; and must point to a single element on the page with a &lt;code&gt;phx-submit&lt;/code&gt; attribute in it. The event name given set on &lt;code&gt;phx-submit&lt;/code&gt; is then sent to the appropriate LiveView (or component if &lt;code&gt;phx-target&lt;/code&gt; is set accordingly). All &lt;code&gt;phx-value-*&lt;/code&gt; entries in the element are sent as values. Extra values, including hidden input fields, can be given with the &lt;code&gt;value&lt;/code&gt; argument.</source>
          <target state="translated">该 &lt;code&gt;element&lt;/code&gt; 是使用&lt;a href=&quot;#element/3&quot;&gt; &lt;code&gt;element/3&lt;/code&gt; &lt;/a&gt;创建的，并且必须指向页面中具有 &lt;code&gt;phx-submit&lt;/code&gt; 属性的单个元素。然后，将在 &lt;code&gt;phx-submit&lt;/code&gt; 上设置的给定事件名称发送到适当的LiveView（或组件，如果已相应设置 &lt;code&gt;phx-target&lt;/code&gt; ）。元素中的所有 &lt;code&gt;phx-value-*&lt;/code&gt; 条目均作为值发送。额外的值，包括隐藏的输入字段，可以通过 &lt;code&gt;value&lt;/code&gt; 参数给出。</target>
        </trans-unit>
        <trans-unit id="cfbf0996b2b7c1661988ea246da6fcdfd58f43b5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;encode!/1&lt;/code&gt; function must return a tuple in the format &lt;code&gt;{:socket_push, :text | :binary, String.t | binary}&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;encode!/1&lt;/code&gt; 函数必须在格式返回一个元组 &lt;code&gt;{:socket_push, :text | :binary, String.t | binary}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="055209e601ab76424461a3d24cfbe4383896ba1b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fetch/2&lt;/code&gt; function above fetches all users from the database who have registered presences for the given topic. The presences information is then extended with a &lt;code&gt;:user&lt;/code&gt; key of the user's information, while maintaining the required &lt;code&gt;:metas&lt;/code&gt; field from the original presence data.</source>
          <target state="translated">上面的 &lt;code&gt;fetch/2&lt;/code&gt; 函数从数据库中获取已注册给定主题的状态的所有用户。然后使用 &lt;code&gt;:user&lt;/code&gt; 信息的：user键扩展状态信息，同时从原始状态数据中保留所需的 &lt;code&gt;:metas&lt;/code&gt; 字段。</target>
        </trans-unit>
        <trans-unit id="6a64f3256798e6a70350cf3a635b234e379dcbdc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;form&lt;/code&gt; should either be a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Phoenix.HTML.Form&lt;/code&gt;&lt;/a&gt; emitted by &lt;code&gt;form_for&lt;/code&gt; or an atom.</source>
          <target state="translated">该 &lt;code&gt;form&lt;/code&gt; 应该是由 &lt;code&gt;form_for&lt;/code&gt; 发出的&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Phoenix.HTML.Form&lt;/code&gt; &lt;/a&gt;或一个原子。</target>
        </trans-unit>
        <trans-unit id="503560113ad63b1bbf6a1ce7a1a79895b311563a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;form&lt;/code&gt; should either be a &lt;a href=&quot;phoenix.html.form#content&quot;&gt;&lt;code&gt;Phoenix.HTML.Form&lt;/code&gt;&lt;/a&gt; emitted by &lt;code&gt;form_for&lt;/code&gt; or an atom.</source>
          <target state="translated">该 &lt;code&gt;form&lt;/code&gt; 应该是 &lt;code&gt;form_for&lt;/code&gt; 发出的&lt;a href=&quot;phoenix.html.form#content&quot;&gt; &lt;code&gt;Phoenix.HTML.Form&lt;/code&gt; &lt;/a&gt;或一个原子。</target>
        </trans-unit>
        <trans-unit id="bd226e25354c107d2906f0cbea19295e4d882cd8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;json/2&lt;/code&gt; function is obviously useful for writing APIs, and the other two may come in handy, but most of the times we use Phoenix views to build our responses. For this, Phoenix provides the &lt;code&gt;render/3&lt;/code&gt; function.</source>
          <target state="translated">该 &lt;code&gt;json/2&lt;/code&gt; 的功能是用于编写的API显然是有用的，其他两个可以派上用场，但大多数时候我们用凤凰的观点来建立我们的反应。为此，Phoenix提供了 &lt;code&gt;render/3&lt;/code&gt; 功能。</target>
        </trans-unit>
        <trans-unit id="a3d0728771ec4d2ea3c901f60ad19db7fa2a8d0a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lib/hello/application.ex&lt;/code&gt; file defines an Elixir application named &lt;code&gt;Hello.Application&lt;/code&gt;. That's because at the end of the day Phoenix applications are simply Elixir applications. The &lt;code&gt;Hello.Application&lt;/code&gt; module defines which services are part of our application:</source>
          <target state="translated">该 &lt;code&gt;lib/hello/application.ex&lt;/code&gt; 文件定义了一个名为药剂应用 &lt;code&gt;Hello.Application&lt;/code&gt; 。那是因为，最终，Phoenix应用程序只是Elixir应用程序。该 &lt;code&gt;Hello.Application&lt;/code&gt; 模块定义哪些服务是我们的应用程序的一部分：</target>
        </trans-unit>
        <trans-unit id="4b44c23c2835aabf2b8a0d71d119e8487fdff8fa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lib/hello&lt;/code&gt; directory hosts all of your business domain. Since our project does not have any business logic yet, the directory is mostly empty. You will only find two files:</source>
          <target state="translated">该 &lt;code&gt;lib/hello&lt;/code&gt; 目录主机的所有业务领域。由于我们的项目还没有任何业务逻辑，因此该目录通常为空。您只会找到两个文件：</target>
        </trans-unit>
        <trans-unit id="c968f45c63fd13191f1cd53260d0ffe8f31d44b4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lib/hello_web&lt;/code&gt; directory holds the web-related parts of our application. It looks like this when expanded:</source>
          <target state="translated">该 &lt;code&gt;lib/hello_web&lt;/code&gt; 目录保存我们的应用程序的Web相关的部分。展开后看起来像这样：</target>
        </trans-unit>
        <trans-unit id="c2252012c87ac27460a9e7188fe0a3ff365ab835" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lv:&lt;/code&gt; event prefix supports LiveView specific features that are handled by LiveView without calling the user's &lt;code&gt;handle_event/3&lt;/code&gt; callbacks. Today, the following events are supported:</source>
          <target state="translated">在 &lt;code&gt;lv:&lt;/code&gt; 由实时查看，而不调用用户的处理事件的前缀支持实时查看特定功能 &lt;code&gt;handle_event/3&lt;/code&gt; 回调。今天，支持以下事件：</target>
        </trans-unit>
        <trans-unit id="3dd5c68b341c68e39c0234d83212f3aebd4c77c5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;onkeydown&lt;/code&gt;, and &lt;code&gt;onkeyup&lt;/code&gt; events are supported via the &lt;code&gt;phx-keydown&lt;/code&gt;, and &lt;code&gt;phx-keyup&lt;/code&gt; bindings. Each binding supports a &lt;code&gt;phx-key&lt;/code&gt; attribute, which triggers the event for the specific key press. If no &lt;code&gt;phx-key&lt;/code&gt; is provided, the event is triggered for any key press. When pushed, the value sent to the server will contain the &lt;code&gt;&quot;key&quot;&lt;/code&gt; that was pressed, plus any user-defined metadata. For example, pressing the Escape key looks like this:</source>
          <target state="translated">该 &lt;code&gt;onkeydown&lt;/code&gt; 事件，和 &lt;code&gt;onkeyup&lt;/code&gt; 事件通过支持 &lt;code&gt;phx-keydown&lt;/code&gt; ，和 &lt;code&gt;phx-keyup&lt;/code&gt; 绑定。每个绑定都支持 &lt;code&gt;phx-key&lt;/code&gt; 属性，该属性会触发特定按键的事件。如果没有提供 &lt;code&gt;phx-key&lt;/code&gt; ，则任何按键按下都会触发该事件。按下后，发送到服务器的值将包含按下的 &lt;code&gt;&quot;key&quot;&lt;/code&gt; 以及任何用户定义的元数据。例如，按Escape键如下所示：</target>
        </trans-unit>
        <trans-unit id="0f4280e53fd7de2d333eac4e3efda660422aeb8d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;options&lt;/code&gt; contains an &lt;code&gt;opcode&lt;/code&gt; key, this will be either &lt;code&gt;:ping&lt;/code&gt; or &lt;code&gt;:pong&lt;/code&gt;.</source>
          <target state="translated">这些 &lt;code&gt;options&lt;/code&gt; 包含一个 &lt;code&gt;opcode&lt;/code&gt; 密钥，该密钥将是 &lt;code&gt;:ping&lt;/code&gt; 或 &lt;code&gt;:pong&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="70b7c6ea8c001315dd26a0ae19bec5c510733707" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;opts&lt;/code&gt; that are received in the &lt;code&gt;init/1&lt;/code&gt; callback of the Module Plug can be passed as a 3rd argument. For example, maybe the background job lets you set the name of your application to be displayed on the page. This could be passed with:</source>
          <target state="translated">在模块插件的 &lt;code&gt;init/1&lt;/code&gt; 回调中收到的 &lt;code&gt;opts&lt;/code&gt; 可以作为第3个参数传递。例如，也许后台作业可让您设置要在页面上显示的应用程序的名称。可以通过以下方式传递：</target>
        </trans-unit>
        <trans-unit id="a30635ea371ab0a08e396d17ab555117f5134b4e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;params&lt;/code&gt; is the list of query parameters. For example, for a query such as &lt;code&gt;from Post, where: [id: ^123]&lt;/code&gt;, &lt;code&gt;params&lt;/code&gt; will be &lt;code&gt;[123]&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;params&lt;/code&gt; 是查询参数列表。例如，对于诸如 &lt;code&gt;from Post, where: [id: ^123]&lt;/code&gt; 的查询，其中：[id：^ 123]， &lt;code&gt;params&lt;/code&gt; 将为 &lt;code&gt;[123]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cc799acb99c7c5e0571705aabef686e2a9bc106f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;params_or_body&lt;/code&gt; field must be one of:</source>
          <target state="translated">该 &lt;code&gt;params_or_body&lt;/code&gt; 场必须是一个：</target>
        </trans-unit>
        <trans-unit id="ba32a6b84a77473cde79076160c7d25a5500e027" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;path&lt;/code&gt; can be either a string or the &lt;code&gt;path_info&lt;/code&gt; segments.</source>
          <target state="translated">该 &lt;code&gt;path&lt;/code&gt; 可以是字符串或 &lt;code&gt;path_info&lt;/code&gt; 段。</target>
        </trans-unit>
        <trans-unit id="6557be94c3b172806d0d806c90f7d5a409872519" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;path&lt;/code&gt; is commonly the request path with optional query string but it may also be a complete URI. When a URI is given, the host and schema will be used as part of the request too.</source>
          <target state="translated">该 &lt;code&gt;path&lt;/code&gt; 通常是带有可选查询字符串的请求路径，但也可以是完整的URI。给出URI后，主机和架构也将用作请求的一部分。</target>
        </trans-unit>
        <trans-unit id="2d55c3d00bf1f0ceaa729d7da79f6e3d8341ed27" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;phx-capture-click&lt;/code&gt; event is just like &lt;code&gt;phx-click&lt;/code&gt;, but instead of the click event being dispatched to the closest &lt;code&gt;phx-click&lt;/code&gt; element as it bubbles up through the DOM, the event is dispatched as it propagates from the top of the DOM tree down to the target element. This is useful when wanting to bind click events without receiving bubbled events from child UI elements. Since capturing happens before bubbling, this can also be important for preparing or preventing behaviour that will be applied during the bubbling phase.</source>
          <target state="translated">在 &lt;code&gt;phx-capture-click&lt;/code&gt; 事件就像 &lt;code&gt;phx-click&lt;/code&gt; ，但不是click事件被调度到最近的 &lt;code&gt;phx-click&lt;/code&gt; 因为它通过DOM冒泡要素，因为它从DOM的顶部传播分派的事件树到目标元素。当希望绑定单击事件而不接收来自子UI元素的冒泡事件时，此功能很有用。由于捕获是在冒泡之前发生的，因此这对于准备或防止在冒泡阶段将要应用的行为也很重要。</target>
        </trans-unit>
        <trans-unit id="701ba5efe9283602358bbbeacee6d8120c0fe72a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;phx-click&lt;/code&gt; binding is used to send click events to the server. When any client event, such as a &lt;code&gt;phx-click&lt;/code&gt; click is pushed, the value sent to the server will be chosen with the following priority:</source>
          <target state="translated">在 &lt;code&gt;phx-click&lt;/code&gt; 绑定用于发送点击事件，给服务器。推送任何客户端事件（例如 &lt;code&gt;phx-click&lt;/code&gt; 单击）时，将选择具有以下优先级的发送到服务器的值：</target>
        </trans-unit>
        <trans-unit id="aecbede8f9d2cd80586f2666e7832e30ea05d175" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;phx-submit&lt;/code&gt; event is used for form submissions where major side effects typically happen, such as rendering new containers, calling an external service, or redirecting to a new page.</source>
          <target state="translated">在 &lt;code&gt;phx-submit&lt;/code&gt; 事件被用于表单提交，其中主要的副作用通常发生，如呈现新的容器，调用外部服务，或重定向到一个新的一页。</target>
        </trans-unit>
        <trans-unit id="5f3fdb35b1ba87d8758c4c7f6b8c9c83d6077ee9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;phx-trigger-action&lt;/code&gt; attribute can be added to a form to trigger a standard form submit on DOM patch to the URL specified in the form's standard &lt;code&gt;action&lt;/code&gt; attribute. This is useful to perform pre-final validation of a LiveView form submit before posting to a controller route for operations that require Plug session mutation. For example, in your LiveView template you can annotate the &lt;code&gt;phx-trigger-action&lt;/code&gt; with a boolean assign:</source>
          <target state="translated">可以将 &lt;code&gt;phx-trigger-action&lt;/code&gt; 属性添加到表单，以触发在DOM修补程序上向表单的标准 &lt;code&gt;action&lt;/code&gt; 属性中指定的URL提交标准表单。在将LiveView表单提交到需要进行Plug-session突变的操作的控制器路由上发布之前，这对于执行LiveView表单提交的预评估验证很有用。例如，在您的LiveView模板中，您可以使用布尔分配来注释 &lt;code&gt;phx-trigger-action&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="7722c1018aa1c3f5818dfe70fb8f2d0e854f196c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;query_cache&lt;/code&gt; and its state is documented in &lt;a href=&quot;#t:query_cache/0&quot;&gt;&lt;code&gt;query_cache/0&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">的 &lt;code&gt;query_cache&lt;/code&gt; 和它的状态中记录&lt;a href=&quot;#t:query_cache/0&quot;&gt; &lt;code&gt;query_cache/0&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cfd929735613a63a87936d342dcfc378113b7e06" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;query_meta&lt;/code&gt; field is a map containing some of the fields found in the &lt;a href=&quot;ecto.query&quot;&gt;&lt;code&gt;Ecto.Query&lt;/code&gt;&lt;/a&gt; struct, after they have been normalized. For example, the values &lt;code&gt;selected&lt;/code&gt; by the query, which then have to be returned, can be found in &lt;code&gt;query_meta&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;query_meta&lt;/code&gt; 字段是包含一些在发现场的地图&lt;a href=&quot;ecto.query&quot;&gt; &lt;code&gt;Ecto.Query&lt;/code&gt; &lt;/a&gt;结构，他们已经正常化之后。例如，可以在 &lt;code&gt;query_meta&lt;/code&gt; 中找到查询所 &lt;code&gt;selected&lt;/code&gt; 的值，然后必须返回这些值。</target>
        </trans-unit>
        <trans-unit id="5c3070b126b1c8e20df8236ea7fbdbd8a762f348" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;render_many/3&lt;/code&gt; function takes the data we want to respond with (&lt;code&gt;pages&lt;/code&gt;), a view, and a string to pattern match on the &lt;code&gt;render/2&lt;/code&gt; function defined on view. It will map over each item in &lt;code&gt;pages&lt;/code&gt;, and call &lt;code&gt;PageView.render(&quot;page.json&quot;, %{page: page})&lt;/code&gt;. &lt;code&gt;render_one/3&lt;/code&gt; follows, the same signature, ultimately using the &lt;code&gt;render/2&lt;/code&gt; matching &lt;code&gt;page.json&lt;/code&gt; to specify what each &lt;code&gt;page&lt;/code&gt; looks like.</source>
          <target state="translated">所述 &lt;code&gt;render_many/3&lt;/code&gt; 函数需要我们想要与（响应数据 &lt;code&gt;pages&lt;/code&gt; ），的图，一个字符串上的图案匹配 &lt;code&gt;render/2&lt;/code&gt; 上视图定义的函数。它将映射 &lt;code&gt;pages&lt;/code&gt; 每个项目，并调用 &lt;code&gt;PageView.render(&quot;page.json&quot;, %{page: page})&lt;/code&gt; 。 &lt;code&gt;render_one/3&lt;/code&gt; ，具有相同的签名，最终使用了 &lt;code&gt;render/2&lt;/code&gt; 匹配的 &lt;code&gt;page.json&lt;/code&gt; 来指定每个 &lt;code&gt;page&lt;/code&gt; 外观。</target>
        </trans-unit>
        <trans-unit id="e4f45984330c354b062f13b6711532673248bd5f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;reply&lt;/code&gt; is a tuple contain an &lt;code&gt;opcode&lt;/code&gt; atom and a message that can be any term. The built-in websocket transport supports both &lt;code&gt;:text&lt;/code&gt; and &lt;code&gt;:binary&lt;/code&gt; opcode and the message must be always iodata. Long polling only supports text opcode.</source>
          <target state="translated">的 &lt;code&gt;reply&lt;/code&gt; 是一个元组包含一个 &lt;code&gt;opcode&lt;/code&gt; 原子并且可以是任何术语的消息。内置的websocket传输同时支持 &lt;code&gt;:text&lt;/code&gt; 和 &lt;code&gt;:binary&lt;/code&gt; 操作码，并且消息必须始终为iodata。长轮询仅支持文本操作码。</target>
        </trans-unit>
        <trans-unit id="e9961db9b5232c882c065bf97a578f4c214483a3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;run/1&lt;/code&gt; function is the critical heart of any Mix task. It's the function that does all the work when users invoke our task. In ours, all we do is send a greeting from our app, but we can implement our &lt;code&gt;run/1&lt;/code&gt; function to do whatever we need it to. Note that &lt;code&gt;Mix.shell().info/1&lt;/code&gt; is the preferred way to print text back out to the user.</source>
          <target state="translated">该 &lt;code&gt;run/1&lt;/code&gt; 功能是任何混合任务的关键心脏。当用户调用我们的任务时，此功能可以完成所有工作。在我们这里，我们要做的就是从应用程序发送问候语，但是我们可以实现 &lt;code&gt;run/1&lt;/code&gt; 函数来完成我们需要做的任何事情。请注意， &lt;code&gt;Mix.shell().info/1&lt;/code&gt; 是将文本打印回用户的首选方法。</target>
        </trans-unit>
        <trans-unit id="2b70572d736ea97cd893ae8c7a89f40d35ac5c3a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;use Mix.Task&lt;/code&gt; line brings in functionality from Mix that makes this module behave as a mix task.</source>
          <target state="translated">在 &lt;code&gt;use Mix.Task&lt;/code&gt; 线带来的混音功能，使该模块表现为混合任务。</target>
        </trans-unit>
        <trans-unit id="a21cb29773a5a21a0cd8e43940897e0aec855c3a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;views&lt;/code&gt; attribute on the pages will not be updated directly by the user, so let's remove it from the generated form. Open &lt;code&gt;lib/hello_web/templates/cms/page/form.html.eex&lt;/code&gt; and remove this part:</source>
          <target state="translated">该 &lt;code&gt;views&lt;/code&gt; 在页面属性不会被用户直接更新，让我们从生成的形式将其删除。打开 &lt;code&gt;lib/hello_web/templates/cms/page/form.html.eex&lt;/code&gt; 并删除此部分：</target>
        </trans-unit>
        <trans-unit id="7162959016edba78d69180b52bd5f5a794f9abb9" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Compatible&lt;/strong&gt; cipher suite supports tlsv1, tlsv1.1 and tlsv1.2. Ciphers were based on the OWASP Group B and includes support for RSA or ECDSA certificates. The intention of this configuration is to provide as secure as possible defaults that still maintain support for older browsers and Android versions 4.3 and earlier</source>
          <target state="translated">在&lt;strong&gt;兼容的&lt;/strong&gt;密码套件支持TLSV1，tlsv1.1和TLSv1.2工作。密码基于OWASP B组，并包括对RSA或ECDSA证书的支持。此配置的目的是提供尽可能安全的默认设置，这些默认设置仍保持对旧版浏览器和Android 4.3及更低版本的支持</target>
        </trans-unit>
        <trans-unit id="99eef0b8032d9eb66bdd6211a81ce1aa7ab072a6" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Strong&lt;/strong&gt; cipher suite only supports tlsv1.2. Ciphers were based on the OWASP Group A+ and includes support for RSA or ECDSA certificates. The intention of this configuration is to provide as secure as possible defaults knowing that it will not be fully compatible with older browsers and operating systems.</source>
          <target state="translated">在&lt;strong&gt;强大&lt;/strong&gt;的加密套件只支持TLSv1.2工作。密码基于OWASP Group A +，并包括对RSA或ECDSA证书的支持。这种配置的目的是提供尽可能安全的默认值，因为它会与较旧的浏览器和操作系统不完全兼容。</target>
        </trans-unit>
        <trans-unit id="1229266af5aeb7323a3edd251846a9e31826c75c" translate="yes" xml:space="preserve">
          <source>The API expected by a module plug is defined as a behaviour by the &lt;a href=&quot;plug#content&quot;&gt;&lt;code&gt;Plug&lt;/code&gt;&lt;/a&gt; module (this module).</source>
          <target state="translated">模块插件期望的API被定义为&lt;a href=&quot;plug#content&quot;&gt; &lt;code&gt;Plug&lt;/code&gt; &lt;/a&gt;模块（此模块）的行为。</target>
        </trans-unit>
        <trans-unit id="397359192255c3cbb30eaefb0a5026e948b7ee90" translate="yes" xml:space="preserve">
          <source>The Complete Elixir and Phoenix Bootcamp Master Functional Programming Techniques with Elixir and Phoenix while Learning to Build Compelling Web Applications (by Stephen Grider - 2017)</source>
          <target state="translated">完整的Elixir和Phoenix Bootcamp 掌握Elixir和Phoenix的功能编程技术,同时学习构建令人信服的Web应用(Stephen Grider著--2017)。</target>
        </trans-unit>
        <trans-unit id="6ca090ddc59b8746edad3d668cd414cb0c01b50e" translate="yes" xml:space="preserve">
          <source>The Controller for LiveView rendering.</source>
          <target state="translated">用于LiveView渲染的控制器。</target>
        </trans-unit>
        <trans-unit id="42a37edfcc20d368aed11372ea5e77be1563e669" translate="yes" xml:space="preserve">
          <source>The Cowboy adapter for Phoenix.</source>
          <target state="translated">凤凰的牛仔适配器。</target>
        </trans-unit>
        <trans-unit id="5a9ef2f700440dbe5deb29ded8f4c846809f867a" translate="yes" xml:space="preserve">
          <source>The Cowboy2 adapter for Phoenix.</source>
          <target state="translated">凤凰城的Cowboy2适配器。</target>
        </trans-unit>
        <trans-unit id="b46e58ab01f0b48b2315edfcf8b2bd6c7e2b3937" translate="yes" xml:space="preserve">
          <source>The Ecto implementation of these operators provide only a thin layer above the adapters. So if your adapter allows you to use them in a certain way (like adding a date and an interval in PostgreSQL), it should work just fine in Ecto queries.</source>
          <target state="translated">Ecto对这些操作符的实现只提供了适配器之上的薄层。因此,如果你的适配器允许你以某种方式使用它们(比如在PostgreSQL中添加日期和间隔),那么在Ecto查询中应该可以正常工作。</target>
        </trans-unit>
        <trans-unit id="5fc206f389e6b83e4a0d3d847f1852857f161e08" translate="yes" xml:space="preserve">
          <source>The Ecto type</source>
          <target state="translated">Ecto型</target>
        </trans-unit>
        <trans-unit id="dfd71c1d2df0567450285bf90b77cd7746d88f5d" translate="yes" xml:space="preserve">
          <source>The Ecto type.</source>
          <target state="translated">Ecto型。</target>
        </trans-unit>
        <trans-unit id="8af11c43a109763d817fe84ffba10efa53664805" translate="yes" xml:space="preserve">
          <source>The Ecto.Changeset struct</source>
          <target state="translated">Ecto.Changeset结构</target>
        </trans-unit>
        <trans-unit id="22799cdc97ac8d9ad98ed9959054ca073ced3180" translate="yes" xml:space="preserve">
          <source>The Elixir and Phoenix communities are friendly and welcoming. All questions and comments are valuable, so please come join the discussion!</source>
          <target state="translated">伊莱克斯和凤凰社区是友好的,欢迎大家的到来。所有的问题和评论都是宝贵的,所以请来参加讨论!</target>
        </trans-unit>
        <trans-unit id="2df24cb6684bccd3bc7f1741ada3cd48d84d2739" translate="yes" xml:space="preserve">
          <source>The Elixir compiler would infer that the router depends directly on &lt;code&gt;MyApp.PageController&lt;/code&gt;, which is not true. By using scopes, Phoenix can properly hint to the Elixir compiler the controller is not an actual dependency of the router. This provides more efficient compilation times.</source>
          <target state="translated">Elixir编译器会推断出路由器直接取决于 &lt;code&gt;MyApp.PageController&lt;/code&gt; ，这是不正确的。通过使用作用域，Phoenix可以正确地向Elixir编译器提示控制器不是路由器的实际依赖项。这提供了更有效的编译时间。</target>
        </trans-unit>
        <trans-unit id="91a790f106411de498ef0d34631c0e826c9311e7" translate="yes" xml:space="preserve">
          <source>The Elixir compiler would infer that the router depends directly on &lt;code&gt;MyAppWeb.PageController&lt;/code&gt;, which is not true. By using scopes, Phoenix can properly hint to the Elixir compiler the controller is not an actual dependency of the router. This provides more efficient compilation times.</source>
          <target state="translated">Elixir编译器会推断出路由器直接取决于 &lt;code&gt;MyAppWeb.PageController&lt;/code&gt; ，这是不正确的。通过使用作用域，Phoenix可以正确地向Elixir编译器提示控制器不是路由器的实际依赖项。这提供了更有效的编译时间。</target>
        </trans-unit>
        <trans-unit id="91f2df3ac4e5339357f53ff3d7998fcb1bc9dcf6" translate="yes" xml:space="preserve">
          <source>The Erlang/OTP runtime, with OpenSSL bindings; run &lt;code&gt;:crypto.info_lib()&lt;/code&gt; in an IEx session to verify</source>
          <target state="translated">具有OpenSSL绑定的Erlang / OTP运行时；在IEx会话中运行 &lt;code&gt;:crypto.info_lib()&lt;/code&gt; 进行验证</target>
        </trans-unit>
        <trans-unit id="a64bf2211a83bfb2580975f065ce021d849dded2" translate="yes" xml:space="preserve">
          <source>The ErrorView</source>
          <target state="translated">错误视图</target>
        </trans-unit>
        <trans-unit id="7dcdec73ad8cfefe7c01cd059a8be75e6642807e" translate="yes" xml:space="preserve">
          <source>The JavaScript client is always the source of truth for current input values. For any given input with focus, LiveView will never overwrite the input's current value, even if it deviates from the server's rendered updates. This works well for updates where major side effects are not expected, such as form validation errors, or additive UX around the user's input values as they fill out a form.</source>
          <target state="translated">JavaScript客户端始终是当前输入值的真实来源。对于任何给定的具有焦点的输入,LiveView永远不会覆盖输入的当前值,即使它偏离了服务器的渲染更新。这对于那些不希望出现重大副作用的更新很有效,比如表单验证错误,或者在用户填写表单时围绕用户输入值的附加UX。</target>
        </trans-unit>
        <trans-unit id="831c44469432e217932a773e59cba3396570b870" translate="yes" xml:space="preserve">
          <source>The LiveView entry-point.</source>
          <target state="translated">的LiveView入口点。</target>
        </trans-unit>
        <trans-unit id="84226f67c848aa70d2bc109fe1a02c277fbf9624" translate="yes" xml:space="preserve">
          <source>The LiveView programming model is declarative: instead of saying &quot;once event X happens, change Y on the page&quot;, events in LiveView are regular messages which may cause changes to its state. Once the state changes, LiveView will re-render the relevant parts of its HTML template and push it to the browser, which updates itself in the most efficient manner. This means developers write LiveView templates as any other server-rendered HTML and LiveView does the hard work of tracking changes and sending the relevant diffs to the browser.</source>
          <target state="translated">LiveView的编程模型是声明式的:LiveView中的事件不是说 &quot;一旦事件X发生,就改变页面上的Y&quot;,而是有规律的消息,可能会引起其状态的变化。一旦状态发生变化,LiveView将重新渲染其HTML模板的相关部分,并推送给浏览器,浏览器以最有效的方式进行自我更新。这意味着开发者编写LiveView模板就像编写其他服务器渲染的HTML一样,LiveView负责跟踪变化并将相关的差异发送给浏览器的艰苦工作。</target>
        </trans-unit>
        <trans-unit id="1cabc4988a5643640cd777c24c4e10db6bb7accd" translate="yes" xml:space="preserve">
          <source>The LiveView socket for Phoenix Endpoints.</source>
          <target state="translated">凤凰端点的LiveView插座。</target>
        </trans-unit>
        <trans-unit id="e596187a19062dc70866323907923d83b3869a8b" translate="yes" xml:space="preserve">
          <source>The LiveView then receives this event using &lt;code&gt;handle_info&lt;/code&gt;:</source>
          <target state="translated">然后，LiveView使用 &lt;code&gt;handle_info&lt;/code&gt; 接收此事件：</target>
        </trans-unit>
        <trans-unit id="5341cef174c7e030180c57e14cc0a67dcaa4ae50" translate="yes" xml:space="preserve">
          <source>The MFA is invoked with the request &lt;code&gt;%URI{}&lt;/code&gt; as the first argument, followed by arguments in the MFA list.</source>
          <target state="translated">使用请求 &lt;code&gt;%URI{}&lt;/code&gt; 作为第一个参数，然后是MFA列表中的参数，来调用MFA。</target>
        </trans-unit>
        <trans-unit id="270a37f0365dba4dfda17bef61d0b68ede5a7a86" translate="yes" xml:space="preserve">
          <source>The PKCS#12 format is a container format containing one or more certificates and/or encrypted keys. Such files typically have a &lt;code&gt;.p12&lt;/code&gt; extension.</source>
          <target state="translated">PKCS＃12格式是一种包含一个或多个证书和/或加密密钥的容器格式。此类文件通常具有 &lt;code&gt;.p12&lt;/code&gt; 扩展名。</target>
        </trans-unit>
        <trans-unit id="3f1e3a1bf73da067cc61947c8f82ff5aabd55c0a" translate="yes" xml:space="preserve">
          <source>The Phoenix engine that handles the &lt;code&gt;.eex&lt;/code&gt; extension.</source>
          <target state="translated">Phoenix引擎处理 &lt;code&gt;.eex&lt;/code&gt; 扩展名。</target>
        </trans-unit>
        <trans-unit id="97f5600c69f57f57eb8f0eebfbf4c79da16ad178" translate="yes" xml:space="preserve">
          <source>The Phoenix engine that handles the &lt;code&gt;.exs&lt;/code&gt; extension.</source>
          <target state="translated">Phoenix引擎处理 &lt;code&gt;.exs&lt;/code&gt; 扩展名。</target>
        </trans-unit>
        <trans-unit id="7c893ff0c14a28253d63b6b6ebed042b7d8d1529" translate="yes" xml:space="preserve">
          <source>The Plug connection.</source>
          <target state="translated">插头连接。</target>
        </trans-unit>
        <trans-unit id="922dcb442d54e2eb649f3edaeaaef6847fb03b26" translate="yes" xml:space="preserve">
          <source>The Plug pipeline</source>
          <target state="translated">Plug管道</target>
        </trans-unit>
        <trans-unit id="6a8a63036ac108e3e027fabac2b118fd6784c36b" translate="yes" xml:space="preserve">
          <source>The Schema</source>
          <target state="translated">模式</target>
        </trans-unit>
        <trans-unit id="c4c6b8de891ce76973a55d8788f25b02282a6500" translate="yes" xml:space="preserve">
          <source>The Strict-Transport-Security header can be disabled altogether by setting &lt;code&gt;hsts: false&lt;/code&gt; in the &lt;a href=&quot;plug.ssl&quot;&gt;&lt;code&gt;Plug.SSL&lt;/code&gt;&lt;/a&gt; options.</source>
          <target state="translated">通过在&lt;a href=&quot;plug.ssl&quot;&gt; &lt;code&gt;Plug.SSL&lt;/code&gt; &lt;/a&gt;选项中设置 &lt;code&gt;hsts: false&lt;/code&gt; ，可以完全禁用Strict-Transport-Security标头。</target>
        </trans-unit>
        <trans-unit id="e7c9c578a9e075a767d2efcef454f02f30cab843" translate="yes" xml:space="preserve">
          <source>The Telemetry supervisor</source>
          <target state="translated">遥测主管</target>
        </trans-unit>
        <trans-unit id="75bea59495492e66c838d460fdfd553076619980" translate="yes" xml:space="preserve">
          <source>The Telemetry.Metrics package provides a common interface for defining metrics. It exposes a set of &lt;a href=&quot;https://hexdocs.pm/telemetry_metrics/Telemetry.Metrics.html#module-metrics&quot;&gt;five metric type functions&lt;/a&gt; that are responsible for structuring a given Telemetry event as a particular measurement.</source>
          <target state="translated">Telemetry.Metrics软件包提供了用于定义指标的通用接口。它公开了一组&lt;a href=&quot;https://hexdocs.pm/telemetry_metrics/Telemetry.Metrics.html#module-metrics&quot;&gt;五个度量标准类型的函数&lt;/a&gt;，这些函数负责将给定的Telemetry事件构造为特定的度量。</target>
        </trans-unit>
        <trans-unit id="44b0c7e1640a8c7aaaeec212113c4828dc9f200b" translate="yes" xml:space="preserve">
          <source>The URL generated in the named URL helpers is based on the configuration for &lt;code&gt;:url&lt;/code&gt;, &lt;code&gt;:http&lt;/code&gt; and &lt;code&gt;:https&lt;/code&gt;. However, if for some reason you need to manually control the URL generation, the url helpers also allow you to pass in a &lt;a href=&quot;https://hexdocs.pm/elixir/URI.html&quot;&gt;&lt;code&gt;URI&lt;/code&gt;&lt;/a&gt; struct:</source>
          <target state="translated">在命名的URL帮助器中生成的URL基于 &lt;code&gt;:url&lt;/code&gt; ， &lt;code&gt;:http&lt;/code&gt; 和 &lt;code&gt;:https&lt;/code&gt; 的配置。但是，如果由于某些原因需要手动控制URL的生成，则url帮助器还允许您传递&lt;a href=&quot;https://hexdocs.pm/elixir/URI.html&quot;&gt; &lt;code&gt;URI&lt;/code&gt; &lt;/a&gt;结构：</target>
        </trans-unit>
        <trans-unit id="01f10584ffce5babefcdc2a0a4a9fa67e62fc824" translate="yes" xml:space="preserve">
          <source>The above approach is the preferred one when passing blocks to &lt;code&gt;do/end&lt;/code&gt;. However, if you are outside of a .leex template and you want to invoke a component passing a &lt;code&gt;do/end&lt;/code&gt; block, you will have to explicitly handle the assigns by giving it a &lt;code&gt;-&amp;gt;&lt;/code&gt; clause:</source>
          <target state="translated">当将代码块传递给 &lt;code&gt;do/end&lt;/code&gt; 时，上述方法是首选方法。但是，如果您不在.leex模板之外，并且想要调用传递 &lt;code&gt;do/end&lt;/code&gt; 块的组件，则必须通过给它一个 &lt;code&gt;-&amp;gt;&lt;/code&gt; 子句来显式处理分配：</target>
        </trans-unit>
        <trans-unit id="439164b882483574280fd7b6ddd89690e34cb2f9" translate="yes" xml:space="preserve">
          <source>The above example matches all the posts which are tied for being the most visited.</source>
          <target state="translated">上面的例子匹配了所有并列访问量最大的帖子。</target>
        </trans-unit>
        <trans-unit id="90e2cd8ec0b373e2a840d10a660fde9ed74b82f4" translate="yes" xml:space="preserve">
          <source>The above is specially useful to dynamically join on existing queries, for example, to dynamically choose a source, or by choosing between public posts or posts that have been recently published:</source>
          <target state="translated">以上对现有的查询动态加入特别有用,比如动态选择来源,或者在公众号或最近发布的帖子中选择。</target>
        </trans-unit>
        <trans-unit id="ba48186478fa2045834150142a3421eea75c78b0" translate="yes" xml:space="preserve">
          <source>The above life-cycle callbacks have in-scope access to the following attributes:</source>
          <target state="translated">上述生命周期的回调可以在范围内访问以下属性。</target>
        </trans-unit>
        <trans-unit id="04796d750e2caa373bfdeb6b87607dcbc4363014" translate="yes" xml:space="preserve">
          <source>The action may be any atom.</source>
          <target state="translated">动作可以是任何原子。</target>
        </trans-unit>
        <trans-unit id="88e8e7c6d83aa7057d13eecb45b68bd52baf600f" translate="yes" xml:space="preserve">
          <source>The action may be one of &lt;code&gt;:insert&lt;/code&gt;, &lt;code&gt;:update&lt;/code&gt;, &lt;code&gt;:delete&lt;/code&gt;, &lt;code&gt;:replace&lt;/code&gt;.</source>
          <target state="translated">该动作可以是 &lt;code&gt;:insert&lt;/code&gt; ， &lt;code&gt;:update&lt;/code&gt; ， &lt;code&gt;:delete&lt;/code&gt; ， &lt;code&gt;:replace&lt;/code&gt; 之一。</target>
        </trans-unit>
        <trans-unit id="99e3ae0551db581b86eb9b59e1bc23af5b2492a7" translate="yes" xml:space="preserve">
          <source>The actual routes we get all look right, except for the path helper &lt;code&gt;review_path&lt;/code&gt; at the beginning of each line. We are getting the same helper for both the user facing review routes and the admin ones, which is not correct.</source>
          <target state="translated">除了每行开头的路径帮助程序 &lt;code&gt;review_path&lt;/code&gt; 之外，我们所有的实际路线都看起来正确。我们为面对审阅路线的用户和管理员获得了相同的帮助者，这是不正确的。</target>
        </trans-unit>
        <trans-unit id="9fa523a4ad5df57fc1402bd4a02afcabbc3fd16b" translate="yes" xml:space="preserve">
          <source>The admin review paths could be prefixed with &lt;code&gt;/admin&lt;/code&gt;.</source>
          <target state="translated">管理员查看路径可以以 &lt;code&gt;/admin&lt;/code&gt; 为前缀。</target>
        </trans-unit>
        <trans-unit id="568c1593cd6ebf7435ec1fe16f10bd8ce0b59776" translate="yes" xml:space="preserve">
          <source>The advantage of configuring the schema via those attributes is that they can be set with a macro to configure application wide defaults.</source>
          <target state="translated">通过这些属性配置模式的好处是,它们可以通过宏来配置应用程序范围的默认值。</target>
        </trans-unit>
        <trans-unit id="12424a03c3ce8ae50505e2f4d39be7ede0456bb6" translate="yes" xml:space="preserve">
          <source>The aggregation will fail if any &lt;code&gt;group_by&lt;/code&gt; field is set.</source>
          <target state="translated">如果设置了任何 &lt;code&gt;group_by&lt;/code&gt; 字段，则聚合将失败。</target>
        </trans-unit>
        <trans-unit id="fd3788421c7ea60194ff0b67a68304eebb16c4a2" translate="yes" xml:space="preserve">
          <source>The allowed values are:</source>
          <target state="translated">允许的值是:</target>
        </trans-unit>
        <trans-unit id="ea72cf622646db7be3f6fbd8024e8493b451ac92" translate="yes" xml:space="preserve">
          <source>The answer is we've decided to expose &lt;code&gt;%Ecto.Changeset{}&lt;/code&gt; as a public &lt;em&gt;data-structure&lt;/em&gt; in our application. We saw before how changesets allow us to track field changes, perform validations, and generate error messages. Its use here is decoupled from the private Repo access and Ecto changeset API internals. We're exposing a data structure that the caller understands which contains the rich information like field errors. Conveniently for us, the &lt;code&gt;phoenix_ecto&lt;/code&gt; project implements the necessary &lt;a href=&quot;phoenix.param&quot;&gt;&lt;code&gt;Phoenix.Param&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../phoenix_html/phoenix.html.formdata&quot;&gt;&lt;code&gt;Phoenix.HTML.FormData&lt;/code&gt;&lt;/a&gt; protocols which know how to handle &lt;code&gt;%Ecto.Changeset{}&lt;/code&gt;'s for things like form generation and error messages. You can also think about it as being as if you had defined your own &lt;code&gt;%Accounts.Changes{}&lt;/code&gt; struct for the same purpose and implemented the Phoenix protocols for the web-layer integration.</source>
          <target state="translated">答案是我们决定在应用程序 &lt;code&gt;%Ecto.Changeset{}&lt;/code&gt; 公开为公共&lt;em&gt;数据结构&lt;/em&gt;。我们之前看到了变更集如何使我们能够跟踪字段变更，执行验证并生成错误消息。在这里，它的使用与私有Repo访问和Ecto changeset API内部结构分离。我们正在公开一个调用者可以理解的数据结构，其中包含诸如字段错误之类的丰富信息。对我们来说， &lt;code&gt;phoenix_ecto&lt;/code&gt; 项目方便地实现了必要的&lt;a href=&quot;phoenix.param&quot;&gt; &lt;code&gt;Phoenix.Param&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../phoenix_html/phoenix.html.formdata&quot;&gt; &lt;code&gt;Phoenix.HTML.FormData&lt;/code&gt; &lt;/a&gt;协议，这些协议知道如何处理 &lt;code&gt;%Ecto.Changeset{}&lt;/code&gt; 用于表单生成和错误消息之类的东西。您也可以将其视为就好像您已出于相同目的定义了自己的 &lt;code&gt;%Accounts.Changes{}&lt;/code&gt; 结构，并为网络层集成实现了Phoenix协议一样。</target>
        </trans-unit>
        <trans-unit id="84bd30260d2ce05fc55d7e66349743b933c0b4f2" translate="yes" xml:space="preserve">
          <source>The argument given to &lt;code&gt;:select_merge&lt;/code&gt; must always be a map. The value being merged on must be a struct or a map. If it is a struct, the fields merged later on must be part of the struct, otherwise an error is raised.</source>
          <target state="translated">指定给 &lt;code&gt;:select_merge&lt;/code&gt; 的参数必须始终是一个映射。要合并的值必须是结构或映射。如果是结构，则稍后合并的字段必须是该结构的一部分，否则会引发错误。</target>
        </trans-unit>
        <trans-unit id="21c3223c139377b3829c552e343068576edd50ef" translate="yes" xml:space="preserve">
          <source>The argument, which defaults to &lt;code&gt;Presence&lt;/code&gt;, defines the module name of the Presence tracker.</source>
          <target state="translated">默认为 &lt;code&gt;Presence&lt;/code&gt; 的参数定义Presence跟踪器的模块名称。</target>
        </trans-unit>
        <trans-unit id="629bfd4051da2fa1a32d9993713c3423b906b41a" translate="yes" xml:space="preserve">
          <source>The arguments are:</source>
          <target state="translated">这些论点是:</target>
        </trans-unit>
        <trans-unit id="4fde4255a8dc0fcc4b0ec76dc711d0f44d251bab" translate="yes" xml:space="preserve">
          <source>The assign tracking feature also implies that you MUST avoid performing direct operations in the template. For example, if you perform a database query in your template:</source>
          <target state="translated">分配跟踪功能也意味着你必须避免在模板中直接执行操作。例如,如果你在模板中执行数据库查询。</target>
        </trans-unit>
        <trans-unit id="2a43c3065c3f85e925ab838ea91589ca677d687c" translate="yes" xml:space="preserve">
          <source>The associated data may be given in different formats:</source>
          <target state="translated">相关数据可以用不同的格式给出。</target>
        </trans-unit>
        <trans-unit id="8af98cf8faab35d0cae464cb5a1cd4f56217e0ba" translate="yes" xml:space="preserve">
          <source>The association happens through a join schema or source, containing foreign keys to the associated schemas. For example, the association below:</source>
          <target state="translated">关联是通过连接模式或源发生的,包含关联模式的外键。例如,下面的关联。</target>
        </trans-unit>
        <trans-unit id="888fd6b9696e2737394550f497e91b80c4256ba5" translate="yes" xml:space="preserve">
          <source>The association struct for &lt;code&gt;has_one&lt;/code&gt; and &lt;code&gt;has_many&lt;/code&gt; associations.</source>
          <target state="translated">&lt;code&gt;has_one&lt;/code&gt; 和 &lt;code&gt;has_many&lt;/code&gt; 关联的关联结构。</target>
        </trans-unit>
        <trans-unit id="c3f2a2472baf2138a4d294eca1e823e09180b2a8" translate="yes" xml:space="preserve">
          <source>The association struct for &lt;code&gt;has_one&lt;/code&gt; and &lt;code&gt;has_many&lt;/code&gt; through associations.</source>
          <target state="translated">&lt;code&gt;has_one&lt;/code&gt; 和 &lt;code&gt;has_many&lt;/code&gt; 的关联结构通过关联。</target>
        </trans-unit>
        <trans-unit id="581a7057c4a1b009249b52b9b19b5e74771aaf2a" translate="yes" xml:space="preserve">
          <source>The association struct for &lt;code&gt;many_to_many&lt;/code&gt; associations.</source>
          <target state="translated">&lt;code&gt;many_to_many&lt;/code&gt; 关联的关联结构。</target>
        </trans-unit>
        <trans-unit id="66e6c87098b4230d834f2d5a056760f88cae1720" translate="yes" xml:space="preserve">
          <source>The association struct for a &lt;code&gt;belongs_to&lt;/code&gt; association.</source>
          <target state="translated">&lt;code&gt;belongs_to&lt;/code&gt; 关系的关联结构。</target>
        </trans-unit>
        <trans-unit id="5205f046f1668f8df50e1a7dbf5d13e856ecfbab" translate="yes" xml:space="preserve">
          <source>The atoms that can be used in place of the status code in many functions are inflected from the reason phrase of the status code. With the above configuration, the following will all work:</source>
          <target state="translated">在很多函数中,可以用来代替状态码的原子是由状态码的原因短语引申出来的。有了上面的配置,下面的都可以用。</target>
        </trans-unit>
        <trans-unit id="480698b107c5364224299e11120625edd4811333" translate="yes" xml:space="preserve">
          <source>The behaviour above is by design to keep the changes between &lt;code&gt;where&lt;/code&gt; and &lt;code&gt;or_where&lt;/code&gt; minimal. Plus, if you have a keyword list and you would like each pair to be combined using &lt;code&gt;or&lt;/code&gt;, it can be easily done with &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html#reduce/3&quot;&gt;&lt;code&gt;Enum.reduce/3&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">上面的行为是设计使要在 &lt;code&gt;where&lt;/code&gt; 和 &lt;code&gt;or_where&lt;/code&gt; 之间保持最小的更改。另外，如果您有一个关键字列表，并且希望使用 &lt;code&gt;or&lt;/code&gt; 将每对组合在一起，则可以使用&lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html#reduce/3&quot;&gt; &lt;code&gt;Enum.reduce/3&lt;/code&gt; &lt;/a&gt;轻松完成：</target>
        </trans-unit>
        <trans-unit id="3bc279bd4a05a0f1e2ea5d2a5959b414a345411f" translate="yes" xml:space="preserve">
          <source>The benefit of having explicit changesets is that we can easily provide different changesets for different use cases. For example, one could easily provide specific changesets for registering and updating users:</source>
          <target state="translated">拥有显式变化集的好处是,我们可以很容易地为不同的用例提供不同的变化集。例如,我们可以很容易地为注册和更新用户提供特定的变更集。</target>
        </trans-unit>
        <trans-unit id="a33976fda84cd70626bac12299c44a1b4814775d" translate="yes" xml:space="preserve">
          <source>The binary is assumed to be encoded in &quot;x-www-form-urlencoded&quot; format. The format is decoded and then validated for proper UTF-8 encoding.</source>
          <target state="translated">二进制被假定为以 &quot;x-www-form-urlencoded &quot;格式编码。该格式经过解码后,会被验证为正确的UTF-8编码。</target>
        </trans-unit>
        <trans-unit id="0833558fe12b0d9b2e81768ddbb74f8c8021373c" translate="yes" xml:space="preserve">
          <source>The browser can send a variety of events to a LiveView via &lt;code&gt;phx-&lt;/code&gt; bindings, which are sent to the &lt;code&gt;handle_event/3&lt;/code&gt; callback. To test events sent by the browser and assert on the rendered side effect of the event, use the &lt;code&gt;render_*&lt;/code&gt; functions:</source>
          <target state="translated">浏览器可以通过 &lt;code&gt;phx-&lt;/code&gt; 绑定将各种事件发送到LiveView ，这些事件被发送到 &lt;code&gt;handle_event/3&lt;/code&gt; 回调。要测试浏览器发送的事件并断言事件的渲染副作用，请使用 &lt;code&gt;render_*&lt;/code&gt; 函数：</target>
        </trans-unit>
        <trans-unit id="47dd120170d17aa1d0f259374abed03b66d4f7d7" translate="yes" xml:space="preserve">
          <source>The cache can be in 3 states, documented below.</source>
          <target state="translated">缓存可以有3种状态,记录如下。</target>
        </trans-unit>
        <trans-unit id="8af03881748bd2064e8f807b0d417c42f2bf8b4b" translate="yes" xml:space="preserve">
          <source>The callback invoked in case the adapter needs to inject code</source>
          <target state="translated">在适配器需要注入代码时调用的回调。</target>
        </trans-unit>
        <trans-unit id="67ef6fb0196e40fee0ed0f4b18726aa52ce6c746" translate="yes" xml:space="preserve">
          <source>The callback invoked in case the adapter needs to inject code.</source>
          <target state="translated">在适配器需要注入代码时调用的回调。</target>
        </trans-unit>
        <trans-unit id="5bbfddd88f74a0c053e76f91efe40fb552ccd1a5" translate="yes" xml:space="preserve">
          <source>The callback will be invoked for all queries, including queries made from associations and preloads. It is not invoked for each individual join inside a query.</source>
          <target state="translated">该回调将被调用于所有查询,包括从关联和预加载中进行的查询。它不会对查询中的每个单独连接被调用。</target>
        </trans-unit>
        <trans-unit id="465bc3533bd128c95cfecfc17237e61c1f085130" translate="yes" xml:space="preserve">
          <source>The catch-all verb, &lt;code&gt;:*&lt;/code&gt;, may also be used to match all HTTP methods.</source>
          <target state="translated">包罗万象的动词 &lt;code&gt;:*&lt;/code&gt; 也可以用来匹配所有HTTP方法。</target>
        </trans-unit>
        <trans-unit id="a92f849f6522a2c3db6efb9017fed09736bbac71" translate="yes" xml:space="preserve">
          <source>The certificate and CA chain can also be specified using DER binaries, using the &lt;code&gt;:cert&lt;/code&gt; and &lt;code&gt;:cacerts&lt;/code&gt; options, but this is best avoided. The use of PEM files has been tested much more thoroughly with the Erlang/OTP &lt;code&gt;:ssl&lt;/code&gt; application, and there have been a number of issues with DER binary certificates in the past.</source>
          <target state="translated">也可以使用DER二进制文件（使用 &lt;code&gt;:cert&lt;/code&gt; 和 &lt;code&gt;:cacerts&lt;/code&gt; 选项）指定证书和CA链，但是最好避免这样做。PEM文件的使用已经通过Erlang / OTP &lt;code&gt;:ssl&lt;/code&gt; 应用程序进行了更彻底的测试，并且过去使用DER二进制证书存在许多问题。</target>
        </trans-unit>
        <trans-unit id="abd434dfdfacea66c9516a4ae4981484c3f005f5" translate="yes" xml:space="preserve">
          <source>The certificate files, like keyfile, certfile, cacertfile, dhfile can be given as a relative path. For such, the &lt;code&gt;:otp_app&lt;/code&gt; option must also be given and certificates will be looked from the priv directory of the given application</source>
          <target state="translated">可以将证书文件（例如密钥文件，certfile，cacertfile，dhfile）指定为相对路径。为此，还必须给出 &lt;code&gt;:otp_app&lt;/code&gt; 选项，并且将从给定应用程序的priv目录中查找证书。</target>
        </trans-unit>
        <trans-unit id="5c4d811c59379111f1c1ff93c837d9da4b33e1af" translate="yes" xml:space="preserve">
          <source>The change is to define the &lt;code&gt;live_view&lt;/code&gt; and &lt;code&gt;live_component&lt;/code&gt; functions in your &lt;code&gt;my_app_web.ex&lt;/code&gt; file, while refactoring the &lt;code&gt;view&lt;/code&gt; function. At the end, they will look like this:</source>
          <target state="translated">&lt;code&gt;live_view&lt;/code&gt; 的更改是在重构 &lt;code&gt;view&lt;/code&gt; 函数的同时，在 &lt;code&gt;my_app_web.ex&lt;/code&gt; 文件中定义live_view和 &lt;code&gt;live_component&lt;/code&gt; 函数。最后，它们将如下所示：</target>
        </trans-unit>
        <trans-unit id="7f895ed3a5a29fab28a57c67512d9e78fea0303d" translate="yes" xml:space="preserve">
          <source>The change tracking also works when rendering other templates as long as they are also &lt;code&gt;.leex&lt;/code&gt; templates:</source>
          <target state="translated">呈现其他模板时，更改跟踪也适用，只要它们也是 &lt;code&gt;.leex&lt;/code&gt; 模板即可：</target>
        </trans-unit>
        <trans-unit id="a8048a4c70c26c609930c982d23c8e90c3c74914" translate="yes" xml:space="preserve">
          <source>The changeset must have been previously &lt;code&gt;cast&lt;/code&gt; using &lt;a href=&quot;#cast/4&quot;&gt;&lt;code&gt;cast/4&lt;/code&gt;&lt;/a&gt; before this function is invoked.</source>
          <target state="translated">该变更必须事先 &lt;code&gt;cast&lt;/code&gt; 用&lt;a href=&quot;#cast/4&quot;&gt; &lt;code&gt;cast/4&lt;/code&gt; &lt;/a&gt;调用此函数之前。</target>
        </trans-unit>
        <trans-unit id="160a4bd88e21d5ca169655a091e64a1bf7eb4d1d" translate="yes" xml:space="preserve">
          <source>The channel that owns the socket will not receive the published message. The event&amp;rsquo;s message must be a serializable map.</source>
          <target state="translated">拥有套接字的通道将不会收到已发布的消息。事件的消息必须是可序列化的映射。</target>
        </trans-unit>
        <trans-unit id="14225c93c28bf8ec888fac6e844921cc19f40df5" translate="yes" xml:space="preserve">
          <source>The channel that owns the socket will not receive the published message. The event's message must be a serializable map.</source>
          <target state="translated">拥有套接字的通道将不会收到发布的消息。事件的消息必须是一个可序列化的映射。</target>
        </trans-unit>
        <trans-unit id="a87a04668a71cfebe522dc33304dfa1bb9aafa32" translate="yes" xml:space="preserve">
          <source>The check constraint works by relying on the database to check if the check constraint has been violated or not and, if so, Ecto converts it into a changeset error.</source>
          <target state="translated">检查约束的工作原理是依靠数据库来检查是否违反了检查约束,如果违反了,Ecto会将其转换为变化集错误。</target>
        </trans-unit>
        <trans-unit id="189a91a56422abe5ad6f16e83079ee9147df5171" translate="yes" xml:space="preserve">
          <source>The ciphers chosen and related configuration are based on &lt;a href=&quot;https://www.owasp.org/index.php/TLS_Cipher_String_Cheat_Sheet&quot;&gt;OWASP recommendations&lt;/a&gt;, with some modifications as described in the &lt;a href=&quot;plug.ssl#configure/1&quot;&gt;&lt;code&gt;Plug.SSL.configure/1&lt;/code&gt;&lt;/a&gt; documentation.</source>
          <target state="translated">选择的密码和相关配置基于&lt;a href=&quot;https://www.owasp.org/index.php/TLS_Cipher_String_Cheat_Sheet&quot;&gt;OWASP建议&lt;/a&gt;，并进行了一些修改，如&lt;a href=&quot;plug.ssl#configure/1&quot;&gt; &lt;code&gt;Plug.SSL.configure/1&lt;/code&gt; &lt;/a&gt;文档中所述。</target>
        </trans-unit>
        <trans-unit id="cb2140aa521991d539b4e2e897df286c32583783" translate="yes" xml:space="preserve">
          <source>The code above builds a query that returns all organizations that belongs to the current user and then validates that the given &quot;org_id&quot; belongs to the user. If there is no such &quot;org_id&quot; or if the user has no access to it, an &lt;code&gt;Ecto.NotFoundError&lt;/code&gt; exception is raised.</source>
          <target state="translated">上面的代码构建一个查询，该查询返回属于当前用户的所有组织，然后验证给定的&amp;ldquo; org_id&amp;rdquo;是否属于该用户。如果没有这样的&amp;ldquo; org_id&amp;rdquo;，或者用户无法访问它，则会 &lt;code&gt;Ecto.NotFoundError&lt;/code&gt; 异常。</target>
        </trans-unit>
        <trans-unit id="e55ac05c44eebe5ced7773b3f09d70f633a77d33" translate="yes" xml:space="preserve">
          <source>The column name is arbitrary and doesn&amp;rsquo;t need to be &lt;code&gt;:lock_version&lt;/code&gt;. Now add a field to the schema too:</source>
          <target state="translated">列名是任意的，不需要是 &lt;code&gt;:lock_version&lt;/code&gt; 。现在也将字段添加到架构中：</target>
        </trans-unit>
        <trans-unit id="22ce43d9dab9ba680dd79938365e5a367bde9ba9" translate="yes" xml:space="preserve">
          <source>The column name is arbitrary and doesn't need to be &lt;code&gt;:lock_version&lt;/code&gt;. Now add a field to the schema too:</source>
          <target state="translated">列名是任意的，不需要是 &lt;code&gt;:lock_version&lt;/code&gt; 。现在也将一个字段添加到架构中：</target>
        </trans-unit>
        <trans-unit id="75c1a428d5c10266245cfaf3fb20fc81b6b19a29" translate="yes" xml:space="preserve">
          <source>The command above means incoming socket connections can be made via a WebSocket connection. Events are routed by topic to channels:</source>
          <target state="translated">上面的命令意味着可以通过WebSocket连接进行传入的套接字连接。事件按主题路由到通道。</target>
        </trans-unit>
        <trans-unit id="c5d46c8827dfa162c3fc24d840406076f113e566" translate="yes" xml:space="preserve">
          <source>The command above means incoming socket connections can be made via the WebSocket transport. Events are routed by topic to channels:</source>
          <target state="translated">上面的命令意味着可以通过WebSocket传输进行传入的套接字连接。事件按主题路由到通道。</target>
        </trans-unit>
        <trans-unit id="a6bed204f25946a181bf872deafb93e1b8f811e4" translate="yes" xml:space="preserve">
          <source>The command above will effectively change the value of &lt;code&gt;conn.scheme&lt;/code&gt; by the one sent in &lt;code&gt;x-forwarded-proto&lt;/code&gt;.</source>
          <target state="translated">上面的命令将有效地通过 &lt;code&gt;x-forwarded-proto&lt;/code&gt; 中发送的 &lt;code&gt;conn.scheme&lt;/code&gt; 的值进行更改。</target>
        </trans-unit>
        <trans-unit id="06d3e38d14906c69fe67c98e93d6ea14a4bb8bfd" translate="yes" xml:space="preserve">
          <source>The component ends up enclosed by the form markup, where LiveView cannot track it. In such cases, you may receive an error such as:</source>
          <target state="translated">组件最终被表单标记所包围,而LiveView无法跟踪它。在这种情况下,你可能会收到一个错误,如:。</target>
        </trans-unit>
        <trans-unit id="e4afae376b75b4be5f358115a2f298594ed796ab" translate="yes" xml:space="preserve">
          <source>The component that is updated must be stateful (the &lt;code&gt;:id&lt;/code&gt; in the assigns must match the &lt;code&gt;:id&lt;/code&gt; associated with the component) and the component must be mounted within the current LiveView.</source>
          <target state="translated">要更新的部件必须是有状态（所述 &lt;code&gt;:id&lt;/code&gt; 在受让人必须匹配 &lt;code&gt;:id&lt;/code&gt; 和部件必须安装在当前实时查看内与组件相关联）。</target>
        </trans-unit>
        <trans-unit id="7ac44c98f163a9b266d4abe83ee653c46374e382" translate="yes" xml:space="preserve">
          <source>The configuration above takes care of starting the pubsub backend and exposing its functions via the endpoint module. If no adapter but a name is given, nothing will be started, but the pubsub system will work by sending events and subscribing to the given name.</source>
          <target state="translated">上面的配置负责启动pubsub后台,并通过端点模块暴露其功能。如果没有给定适配器,而是给定名称,则不会启动任何东西,但pubsub系统将通过发送事件和订阅给定名称来工作。</target>
        </trans-unit>
        <trans-unit id="8b296a52b4ef4041ccbced6b08d102098ca424ae" translate="yes" xml:space="preserve">
          <source>The configuration above will start a Redis pubsub and register it with name &lt;code&gt;:my_pubsub&lt;/code&gt;.</source>
          <target state="translated">上面的配置将启动Redis pubsub并将其注册为名称 &lt;code&gt;:my_pubsub&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0c3243504e5d91d9054ed22ddbd7d15078c0b7c3" translate="yes" xml:space="preserve">
          <source>The configuration below can be given to both &lt;code&gt;:websocket&lt;/code&gt; and &lt;code&gt;:longpoll&lt;/code&gt; keys:</source>
          <target state="translated">下面的配置可以同时给 &lt;code&gt;:websocket&lt;/code&gt; 和 &lt;code&gt;:longpoll&lt;/code&gt; 键：</target>
        </trans-unit>
        <trans-unit id="468fbe7bf04f16c5040863a52f0d55b418c094c8" translate="yes" xml:space="preserve">
          <source>The connection state is used to track the connection lifecycle. It starts as &lt;code&gt;:unset&lt;/code&gt; but is changed to &lt;code&gt;:set&lt;/code&gt; (via &lt;a href=&quot;#resp/3&quot;&gt;&lt;code&gt;resp/3&lt;/code&gt;&lt;/a&gt;) or &lt;code&gt;:set_chunked&lt;/code&gt; (used only for &lt;code&gt;before_send&lt;/code&gt; callbacks by &lt;a href=&quot;#send_chunked/2&quot;&gt;&lt;code&gt;send_chunked/2&lt;/code&gt;&lt;/a&gt;) or &lt;code&gt;:file&lt;/code&gt; (when invoked via &lt;a href=&quot;#send_file/3&quot;&gt;&lt;code&gt;send_file/3&lt;/code&gt;&lt;/a&gt;). Its final result is &lt;code&gt;:sent&lt;/code&gt;, &lt;code&gt;:file&lt;/code&gt; or &lt;code&gt;:chunked&lt;/code&gt; depending on the response model.</source>
          <target state="translated">连接状态用于跟踪连接生命周期。它以 &lt;code&gt;:unset&lt;/code&gt; 开始，但更改为 &lt;code&gt;:set&lt;/code&gt; （通过&lt;a href=&quot;#resp/3&quot;&gt; &lt;code&gt;resp/3&lt;/code&gt; &lt;/a&gt;）或 &lt;code&gt;:set_chunked&lt;/code&gt; （仅用于&lt;a href=&quot;#send_chunked/2&quot;&gt; &lt;code&gt;send_chunked/2&lt;/code&gt; 的&lt;/a&gt; &lt;code&gt;before_send&lt;/code&gt; 回调）或 &lt;code&gt;:file&lt;/code&gt; （通过&lt;a href=&quot;#send_file/3&quot;&gt; &lt;code&gt;send_file/3&lt;/code&gt; &lt;/a&gt;调用时）。根据响应模型，其最终结果是 &lt;code&gt;:sent&lt;/code&gt; ， &lt;code&gt;:file&lt;/code&gt; 或 &lt;code&gt;:chunked&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="48566362cafe346914c5a6f03d80d57d5efcb820" translate="yes" xml:space="preserve">
          <source>The connection will be configured with the given &lt;code&gt;method&lt;/code&gt;, &lt;code&gt;path_or_action&lt;/code&gt; and &lt;code&gt;params_or_body&lt;/code&gt;.</source>
          <target state="translated">连接将与给定的配置 &lt;code&gt;method&lt;/code&gt; ， &lt;code&gt;path_or_action&lt;/code&gt; 和 &lt;code&gt;params_or_body&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5d448c7ac90d83c40db5bfb1c89d1edee4438350" translate="yes" xml:space="preserve">
          <source>The connection&amp;rsquo;s endpoint will be used for URL generation. See &lt;a href=&quot;#current_path/1&quot;&gt;&lt;code&gt;current_path/1&lt;/code&gt;&lt;/a&gt; for details on how the request path is generated.</source>
          <target state="translated">连接的端点将用于URL生成。有关如何生成请求路径的详细信息，请参见&lt;a href=&quot;#current_path/1&quot;&gt; &lt;code&gt;current_path/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d40469a6ab597b422ee4f68bd557b30e3be2a9ae" translate="yes" xml:space="preserve">
          <source>The container can be customized in different ways:</source>
          <target state="translated">容器可以以不同的方式进行定制。</target>
        </trans-unit>
        <trans-unit id="c7d4bab9d56a81796bac83a3ef42018e650c34ee" translate="yes" xml:space="preserve">
          <source>The context app</source>
          <target state="translated">语境应用</target>
        </trans-unit>
        <trans-unit id="0facde72bd2ec18fe66926da4d93236d6aff0bce" translate="yes" xml:space="preserve">
          <source>The context is an Elixir module that serves as an API boundary for the given resource. A context often holds many related resources. Therefore, if the context already exists, it will be augmented with functions for the given resource.</source>
          <target state="translated">上下文是一个Elixir模块,作为给定资源的API边界。一个上下文通常包含许多相关资源。因此,如果上下文已经存在,则将用给定资源的函数对其进行扩充。</target>
        </trans-unit>
        <trans-unit id="f31946d1aec3ffc473697b735314efcde461c192" translate="yes" xml:space="preserve">
          <source>The context is an Elixir module that serves as an API boundary for the given resource. A context often holds many related resources. Therefore, if the context already exists, it will be augmented with functions for the given resource. Note a resource may also be split over distinct contexts (such as Accounts.User and Payments.User).</source>
          <target state="translated">上下文是一个Elixir模块,作为给定资源的API边界。一个上下文通常包含许多相关资源。因此,如果上下文已经存在,那么它将被赋予给定资源的功能。请注意,一个资源也可能被拆分在不同的上下文中(如 Accounts.User 和 Payments.User)。</target>
        </trans-unit>
        <trans-unit id="6ef96e1551a038d10e050b366a6393c8066aa195" translate="yes" xml:space="preserve">
          <source>The cookie value is not automatically escaped. Therefore, if you want to store values with comma, quotes, and so on, you need to explicitly escape them or use a function such as &lt;code&gt;Base.encode64(value, padding: false)&lt;/code&gt; when writing and &lt;code&gt;Base.decode64(encoded, padding: false)&lt;/code&gt; when reading the cookie. Padding needs to be disabled since &lt;code&gt;=&lt;/code&gt; is not a valid character in cookie values.</source>
          <target state="translated">cookie值不会自动转义。因此，如果要使用逗号，引号等存储值，则需要在编写时显式转义它们或使用诸如 &lt;code&gt;Base.encode64(value, padding: false)&lt;/code&gt; 和 &lt;code&gt;Base.decode64(encoded, padding: false)&lt;/code&gt; ）之类的函数： false）。由于 &lt;code&gt;=&lt;/code&gt; 在Cookie值中不是有效字符，因此需要禁用填充。</target>
        </trans-unit>
        <trans-unit id="0b75f4c0b3e543c026233950dd58d233dabc0916" translate="yes" xml:space="preserve">
          <source>The cookie value is not automatically escaped. Therefore, if you want to store values with comma, quotes, etc, you need to explicitly escape them or use a function such as &lt;code&gt;Base.encode64(value, padding: false)&lt;/code&gt; when writing and &lt;code&gt;Base.decode64(encoded, padding: false)&lt;/code&gt; when reading the cookie. Padding needs to be disabled since &lt;code&gt;=&lt;/code&gt; is not a valid character in cookie values.</source>
          <target state="translated">cookie值不会自动转义。因此，如果要使用逗号，引号等存储值，则需要在编写时显式转义它们或使用诸如 &lt;code&gt;Base.encode64(value, padding: false)&lt;/code&gt; 和 &lt;code&gt;Base.decode64(encoded, padding: false)&lt;/code&gt; 读取Cookie时。由于 &lt;code&gt;=&lt;/code&gt; 在Cookie值中不是有效字符，因此需要禁用填充。</target>
        </trans-unit>
        <trans-unit id="bc170b7df02149d4f1b41d395782c4bf6a42233e" translate="yes" xml:space="preserve">
          <source>The cookie value that will be sent in cookie headers. This value should be base64 encoded to avoid security issues</source>
          <target state="translated">将在cookie头中发送的cookie值。这个值应该是base64编码,以避免安全问题。</target>
        </trans-unit>
        <trans-unit id="4ed8e930bd798b7f59e1b3906dae0c5ae18ae5f5" translate="yes" xml:space="preserve">
          <source>The cookie value that will be sent in cookie headers. This value should be base64 encoded to avoid security issues.</source>
          <target state="translated">将在cookie头中发送的cookie值。这个值应该是base64编码,以避免安全问题。</target>
        </trans-unit>
        <trans-unit id="6e2028fc8c0e6e2d2a17c2988205cfc1a48f5c7d" translate="yes" xml:space="preserve">
          <source>The core of this action is &lt;code&gt;render(conn, &quot;index.html&quot;)&lt;/code&gt;. It tells Phoenix to render &quot;index.html&quot;. The modules responsible for rendering are views. By default, Phoenix views are named after the controller, so Phoenix is expecting a &lt;code&gt;HelloWeb.HelloView&lt;/code&gt; to exist and handle &quot;index.html&quot; for us.</source>
          <target state="translated">该操作的核心是 &lt;code&gt;render(conn, &quot;index.html&quot;)&lt;/code&gt; 。它告诉Phoenix渲染&amp;ldquo; index.html&amp;rdquo;。负责渲染的模块是视图。默认情况下，Phoenix视图是以控制器命名的，因此Phoenix希望存在一个 &lt;code&gt;HelloWeb.HelloView&lt;/code&gt; 并为我们处理&amp;ldquo; index.html&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="0fdf691245b570b56fac13fe863e01499ed9c09b" translate="yes" xml:space="preserve">
          <source>The current LiveView will be shut down and a new one will be mounted in its place, without reloading the whole page. This can also be used to remount the same LiveView, in case you want to start fresh. If you want to navigate to the same LiveView without remounting it, use &lt;a href=&quot;#live_patch/2&quot;&gt;&lt;code&gt;live_patch/2&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">当前的LiveView将关闭，并在其位置安装一个新的LiveView，而无需重新加载整个页面。如果您想重新启动，也可以使用它重新安装相同的LiveView。如果要导航到相同的LiveView而不重新安装它，请改用&lt;a href=&quot;#live_patch/2&quot;&gt; &lt;code&gt;live_patch/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fe0cdcbf70ae3305c8dd93ccd61f868d5e436588" translate="yes" xml:space="preserve">
          <source>The current LiveView will be shutdown and a new one will be mounted in its place, without reloading the whole page. This can also be used to remount the same LiveView, in case you want to start fresh. If you want to navigate to the same LiveView without remounting it, use &lt;a href=&quot;#push_patch/2&quot;&gt;&lt;code&gt;push_patch/2&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">当前的LiveView将关闭，并在其位置安装一个新的LiveView，而无需重新加载整个页面。如果您想重新启动，也可以使用它重新安装相同的LiveView。如果要导航到相同的LiveView而不重新安装它，请改用&lt;a href=&quot;#push_patch/2&quot;&gt; &lt;code&gt;push_patch/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b9b1fd62f16ed364400554fa3c072cfdd758b718" translate="yes" xml:space="preserve">
          <source>The current action will always be available inside the LiveView as the &lt;code&gt;@live_action&lt;/code&gt; assign, that can be used to render a LiveComponent:</source>
          <target state="translated">当前动作将始终在LiveView中作为 &lt;code&gt;@live_action&lt;/code&gt; 分配可用，可用于呈现LiveComponent：</target>
        </trans-unit>
        <trans-unit id="a8e46ad87d3469e7e9f3187e46155cee02aaf64d" translate="yes" xml:space="preserve">
          <source>The current schema belongs to zero or one records of the other schema. The other schema often has a &lt;code&gt;has_one&lt;/code&gt; or a &lt;code&gt;has_many&lt;/code&gt; field with the reverse association.</source>
          <target state="translated">当前模式属于另一个模式的零个或一个记录。另一个模式通常具有带有反向关联的 &lt;code&gt;has_one&lt;/code&gt; 或 &lt;code&gt;has_many&lt;/code&gt; 字段。</target>
        </trans-unit>
        <trans-unit id="37f668c1bd4c3e820e33a15f5f380f812917f51d" translate="yes" xml:space="preserve">
          <source>The current schema has zero or more records of the other schema embedded inside of it. Embeds have all the things regular schemas have.</source>
          <target state="translated">当前模式有零条或更多其他模式的记录嵌入其中。嵌入模式具有常规模式所具有的所有内容。</target>
        </trans-unit>
        <trans-unit id="bb6532e1cfbc40c65e0d70c093c2d84b8c13c97c" translate="yes" xml:space="preserve">
          <source>The current schema has zero or more records of the other schema. The other schema often has a &lt;code&gt;belongs_to&lt;/code&gt; field with the reverse association.</source>
          <target state="translated">当前架构具有零个或多个其他架构的记录。另一个模式通常具有带有反向关联的 &lt;code&gt;belongs_to&lt;/code&gt; 字段。</target>
        </trans-unit>
        <trans-unit id="a2400e9bff3b3fcf167090fc4f9675aa1dafa03a" translate="yes" xml:space="preserve">
          <source>The current schema has zero or one records of the other schema embedded inside of it. It uses a field similar to the &lt;code&gt;:map&lt;/code&gt; type for storage, but allows embeds to have all the things regular schema can.</source>
          <target state="translated">当前模式中嵌入了另一个模式的零个或一个记录。它使用类似于 &lt;code&gt;:map&lt;/code&gt; 类型的字段进行存储，但允许嵌入具有常规模式可以完成的所有工作。</target>
        </trans-unit>
        <trans-unit id="543e48ecf9a036c8c3265d90420f7f54855d1f07" translate="yes" xml:space="preserve">
          <source>The current schema has zero or one records of the other schema. The other schema often has a &lt;code&gt;belongs_to&lt;/code&gt; field with the reverse association.</source>
          <target state="translated">当前模式具有另一个模式的零个或一个记录。另一个模式通常具有带有反向关联的 &lt;code&gt;belongs_to&lt;/code&gt; 字段。</target>
        </trans-unit>
        <trans-unit id="a89c1ce17f89437f89ff113dd237432b1779e13f" translate="yes" xml:space="preserve">
          <source>The current time in UTC is retrieved from Elixir and not from the database.</source>
          <target state="translated">当前的UTC时间是从Elixir获取的,而不是从数据库获取的。</target>
        </trans-unit>
        <trans-unit id="b052c5d0d8705bd378272066bfc771be8f95160c" translate="yes" xml:space="preserve">
          <source>The data is stored in ETS in the following format:</source>
          <target state="translated">数据以下列格式存储在ETS中:</target>
        </trans-unit>
        <trans-unit id="1acda630ba32f073701a386f5cfe162756e7c372" translate="yes" xml:space="preserve">
          <source>The data stored in the token is signed to prevent tampering but not encrypted. This means it is safe to store identification information (such as user IDs) but should not be used to store confidential information (such as credit card numbers).</source>
          <target state="translated">存储在令牌中的数据经过签名以防止篡改,但没有加密。这意味着存储身份信息(如用户ID)是安全的,但不应该用来存储机密信息(如信用卡号码)。</target>
        </trans-unit>
        <trans-unit id="f7d8e9c428788f4e316259dfd396beb63eed3450" translate="yes" xml:space="preserve">
          <source>The data world is your oyster, but we won't be covering these options in these guides.</source>
          <target state="translated">数据世界是你的牡蛎,但我们不会在这些指南中涵盖这些选项。</target>
        </trans-unit>
        <trans-unit id="c9e3f4c1170977052f6619c9eadd4414d82a1869" translate="yes" xml:space="preserve">
          <source>The database for HelloPhoenix.repo has been created. We're also ready to run any migrations, or do anything else with Ecto that we might choose.</source>
          <target state="translated">HelloPhoenix.repo的数据库已经创建。我们也已经准备好运行任何迁移,或者做任何我们可能选择的Ecto的其他事情。</target>
        </trans-unit>
        <trans-unit id="25b03cf10e6fc6af894d1777f43a9e4564e801a7" translate="yes" xml:space="preserve">
          <source>The datetime types</source>
          <target state="translated">日期时间类型</target>
        </trans-unit>
        <trans-unit id="57585ba4de2b044b0be68355ad35a6afa2297af3" translate="yes" xml:space="preserve">
          <source>The debug state uses the browser's built-in &lt;code&gt;sessionStorage&lt;/code&gt;, so it will remain in effect for as long as your browser session lasts.</source>
          <target state="translated">调试状态使用浏览器的内置 &lt;code&gt;sessionStorage&lt;/code&gt; ，因此只要您的浏览器会话持续，它将保持有效。</target>
        </trans-unit>
        <trans-unit id="d91240847c4c0b4e5c86209a80fab1b682a0b72d" translate="yes" xml:space="preserve">
          <source>The default Endpoint plugs do quite a lot of work. Here they are in order:</source>
          <target state="translated">默认的端点插件做了相当多的工作。以下是它们的顺序。</target>
        </trans-unit>
        <trans-unit id="01d063536b5fd16a46117b63d1178dfcad16b720" translate="yes" xml:space="preserve">
          <source>The default HTML encoder that ships with Phoenix.</source>
          <target state="translated">Phoenix默认的HTML编码器。</target>
        </trans-unit>
        <trans-unit id="b6a5014904611a0144837aa761a0d9c7ac17de4a" translate="yes" xml:space="preserve">
          <source>The default format is used when none is set in the connection</source>
          <target state="translated">当连接中没有设置任何格式时,使用默认格式。</target>
        </trans-unit>
        <trans-unit id="eb15ee34b6e76bea7879309e5d7b64c6bf0dee90" translate="yes" xml:space="preserve">
          <source>The default format is used when none is set in the connection.</source>
          <target state="translated">当连接中没有设置时,使用默认格式。</target>
        </trans-unit>
        <trans-unit id="565d3288130af0242285fb747529bfd66f40c7d5" translate="yes" xml:space="preserve">
          <source>The default implementation simply passes &lt;code&gt;presences&lt;/code&gt; through unchanged.</source>
          <target state="translated">默认实现只是通过不变的方式传递 &lt;code&gt;presences&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6676a691528a06988caceda0bdea8ffb85ace6e8" translate="yes" xml:space="preserve">
          <source>The default option can be given to populate the fields if none is given:</source>
          <target state="translated">如果没有给定字段,可以给定默认选项来填充。</target>
        </trans-unit>
        <trans-unit id="2c66e666e4d64f7851485bf4d02d2f008e867eb1" translate="yes" xml:space="preserve">
          <source>The default router is inflected from the application name unless a configuration named &lt;code&gt;:namespace&lt;/code&gt; is set inside your application configuration. For example, the configuration:</source>
          <target state="translated">除非在应用程序配置中设置了名为 &lt;code&gt;:namespace&lt;/code&gt; 的配置，否则默认路由器将从应用程序名称变形。例如，配置：</target>
        </trans-unit>
        <trans-unit id="bef1bc8ef401a761e7d8eba7f4227945005b964c" translate="yes" xml:space="preserve">
          <source>The definition of basic custom types and all of its callbacks is available in this module. You can learn more about parameterized types in &lt;a href=&quot;ecto.parameterizedtype&quot;&gt;&lt;code&gt;Ecto.ParameterizedType&lt;/code&gt;&lt;/a&gt;. If in doubt, prefer to use basic custom types and rely on parameterized types if you need the extra functionality.</source>
          <target state="translated">基本自定义类型及其所有回调的定义在此模块中可用。您可以在&lt;a href=&quot;ecto.parameterizedtype&quot;&gt; &lt;code&gt;Ecto.ParameterizedType&lt;/code&gt; 中&lt;/a&gt;了解有关参数化类型的更多信息。如有疑问，请使用基本的自定义类型，并在需要其他功能时依赖于参数化类型。</target>
        </trans-unit>
        <trans-unit id="c9bea1b5faf766b56d93add1c5f07efe92cf9dfa" translate="yes" xml:space="preserve">
          <source>The difference between them is that most validations can be executed without a need to interact with the database and, therefore, are always executed before attempting to insert or update the entry in the database. Some validations may happen against the database but they are inherently unsafe. Those validations start with a &lt;code&gt;unsafe_&lt;/code&gt; prefix, such as &lt;a href=&quot;#unsafe_validate_unique/3&quot;&gt;&lt;code&gt;unsafe_validate_unique/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">它们之间的区别在于，大多数验证可以在不需要与数据库交互的情况下执行，因此总是在尝试在数据库中插入或更新条目之前执行。可能会对数据库进行某些验证，但是它们本质上是不安全的。这些验证以 &lt;code&gt;unsafe_&lt;/code&gt; 前缀开头，例如&lt;a href=&quot;#unsafe_validate_unique/3&quot;&gt; &lt;code&gt;unsafe_validate_unique/3&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b905a6abee1408a861b937e78adce0825322527a" translate="yes" xml:space="preserve">
          <source>The dispatcher must be available on all nodes running the PubSub system. The &lt;code&gt;dispatch/3&lt;/code&gt; function of the given module will be invoked with the subscriptions entries, the broadcaster identifier (either a pid or &lt;code&gt;:none&lt;/code&gt;), and the message to broadcast.</source>
          <target state="translated">调度程序必须在运行PubSub系统的所有节点上都可用。给定模块的 &lt;code&gt;dispatch/3&lt;/code&gt; 函数将与订阅条目，广播者标识符（pid或 &lt;code&gt;:none&lt;/code&gt; ）以及要广播的消息一起调用。</target>
        </trans-unit>
        <trans-unit id="90a466df0e05cd07db8216347664891ea2d6f388" translate="yes" xml:space="preserve">
          <source>The distinction whether to insert or update will be made on the &lt;a href=&quot;ecto.schema.metadata&quot;&gt;&lt;code&gt;Ecto.Schema.Metadata&lt;/code&gt;&lt;/a&gt; field &lt;code&gt;:state&lt;/code&gt;. The &lt;code&gt;:state&lt;/code&gt; is automatically set by Ecto when loading or building a schema.</source>
          <target state="translated">插入还是更新的区别将在&lt;a href=&quot;ecto.schema.metadata&quot;&gt; &lt;code&gt;Ecto.Schema.Metadata&lt;/code&gt; &lt;/a&gt;字段 &lt;code&gt;:state&lt;/code&gt; 上进行。的 &lt;code&gt;:state&lt;/code&gt; 是由外生加载或建立一个架构时自动设置。</target>
        </trans-unit>
        <trans-unit id="98110b4f952a325165904e437acdb05dceca3afb" translate="yes" xml:space="preserve">
          <source>The download is achieved by setting &quot;content-disposition&quot; to attachment. The &quot;content-type&quot; will also be set based on the extension of the given filename but can be customized via the &lt;code&gt;:content_type&lt;/code&gt; and &lt;code&gt;:charset&lt;/code&gt; options.</source>
          <target state="translated">通过将&amp;ldquo;内容处置&amp;rdquo;设置为附件来实现下载。&amp;ldquo;内容类型&amp;rdquo;也将基于给定文件名的扩展名进行设置，但可以通过 &lt;code&gt;:content_type&lt;/code&gt; 和 &lt;code&gt;:charset&lt;/code&gt; 选项进行自定义。</target>
        </trans-unit>
        <trans-unit id="2bea122452a37ef030f627235ed1844a3ddfe593" translate="yes" xml:space="preserve">
          <source>The download is achieved by setting &amp;ldquo;content-disposition&amp;rdquo; to attachment. The &amp;ldquo;content-type&amp;rdquo; will also be set based on the extension of the given filename but can be customized via the &lt;code&gt;:content_type&lt;/code&gt; and &lt;code&gt;:charset&lt;/code&gt; options.</source>
          <target state="translated">通过将&amp;ldquo;内容处置&amp;rdquo;设置为附件来实现下载。&amp;ldquo; content-type&amp;rdquo;也将基于给定文件名的扩展名进行设置，但可以通过 &lt;code&gt;:content_type&lt;/code&gt; 和 &lt;code&gt;:charset&lt;/code&gt; 选项自定义。</target>
        </trans-unit>
        <trans-unit id="305f411cb067461e7008b3366143db8315830828" translate="yes" xml:space="preserve">
          <source>The embedded may or may not have a primary key. Ecto use the primary keys to detect if an embed is being updated or not. If a primary is not present and you still want the list of embeds to be updated, &lt;code&gt;:on_replace&lt;/code&gt; must be set to &lt;code&gt;:delete&lt;/code&gt;, forcing all current embeds to be deleted and replaced by new ones whenever a new list of embeds is set.</source>
          <target state="translated">嵌入式可能具有主键，也可能没有主键。Ecto使用主键来检测嵌入是否正在更新。如果不存在主嵌入，并且您仍希望更新嵌入列表，则 &lt;code&gt;:on_replace&lt;/code&gt; 必须设置为 &lt;code&gt;:delete&lt;/code&gt; ，无论何时设置新的嵌入列表，都必须删除所有当前嵌入，并用新的嵌入替换。</target>
        </trans-unit>
        <trans-unit id="9851fea47b9bbc161a06c36308d9e5222d41ca5d" translate="yes" xml:space="preserve">
          <source>The embedded may or may not have a primary key. Ecto use the primary keys to detect if an embed is being updated or not. If a primary is not present, &lt;code&gt;:on_replace&lt;/code&gt; should be set to either &lt;code&gt;:update&lt;/code&gt; or &lt;code&gt;:delete&lt;/code&gt; if there is a desire to either update or delete the current embed when a new one is set.</source>
          <target state="translated">嵌入式可能具有主键，也可能没有主键。Ecto使用主键来检测嵌入是否正在更新。如果不存在主嵌入，则如果希望在设置新嵌入时更新或删除当前嵌入，则应将 &lt;code&gt;:on_replace&lt;/code&gt; 设置为 &lt;code&gt;:update&lt;/code&gt; 或 &lt;code&gt;:delete&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1949ed7b2d6dffd9e7c7748d7bd6bc3abd5dcf0c" translate="yes" xml:space="preserve">
          <source>The embedded may or may not have a primary key. Ecto uses the primary keys to detect if an embed is being updated or not. If a primary is not present and you still want the list of embeds to be updated, &lt;code&gt;:on_replace&lt;/code&gt; must be set to &lt;code&gt;:delete&lt;/code&gt;, forcing all current embeds to be deleted and replaced by new ones whenever a new list of embeds is set.</source>
          <target state="translated">嵌入式可能具有主键，也可能没有主键。Ecto使用主键来检测嵌入是否正在更新。如果不存在主嵌入，并且您仍希望更新嵌入列表，则 &lt;code&gt;:on_replace&lt;/code&gt; 必须设置为 &lt;code&gt;:delete&lt;/code&gt; ，无论何时设置新的嵌入列表，都必须删除所有当前嵌入，并用新的嵌入替换。</target>
        </trans-unit>
        <trans-unit id="af9a17476a78a7a92bdf8fb962890959f1ad1049" translate="yes" xml:space="preserve">
          <source>The embedded may or may not have a primary key. Ecto uses the primary keys to detect if an embed is being updated or not. If a primary key is not present, &lt;code&gt;:on_replace&lt;/code&gt; should be set to either &lt;code&gt;:update&lt;/code&gt; or &lt;code&gt;:delete&lt;/code&gt; if there is a desire to either update or delete the current embed when a new one is set.</source>
          <target state="translated">嵌入式可能具有主键，也可能没有主键。Ecto使用主键来检测嵌入是否正在更新。如果主键不存在， &lt;code&gt;:on_replace&lt;/code&gt; 在设置新主键时，如果希望更新或删除当前嵌入，则：on_replace应该设置为 &lt;code&gt;:update&lt;/code&gt; 或 &lt;code&gt;:delete&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="240ba5b0f9226d65d40a221b0aaca6577ac67121" translate="yes" xml:space="preserve">
          <source>The encoding of server data and the decoding of client data is done according to a serializer, defined in &lt;a href=&quot;phoenix.socket.serializer&quot;&gt;&lt;code&gt;Phoenix.Socket.Serializer&lt;/code&gt;&lt;/a&gt;. By default, JSON encoding is used to broker messages to and from clients with &lt;code&gt;Phoenix.Socket.V2.JSONSerializer&lt;/code&gt;.</source>
          <target state="translated">服务器数据的编码和客户端数据的解码是根据&lt;a href=&quot;phoenix.socket.serializer&quot;&gt; &lt;code&gt;Phoenix.Socket.Serializer&lt;/code&gt; 中&lt;/a&gt;定义的序列化器完成的。默认情况下，JSON编码用于通过 &lt;code&gt;Phoenix.Socket.V2.JSONSerializer&lt;/code&gt; 与客户端之间来回传递消息。</target>
        </trans-unit>
        <trans-unit id="ffc586997cb9ff4e598fbaf2d150c17e623488e6" translate="yes" xml:space="preserve">
          <source>The endpoint being tested is accessed via the &lt;code&gt;@endpoint&lt;/code&gt; module attribute.</source>
          <target state="translated">通过 &lt;code&gt;@endpoint&lt;/code&gt; 模块属性访问正在测试的端点。</target>
        </trans-unit>
        <trans-unit id="1085ea34a986c448fabcc15a67e4b94b2cb117ef" translate="yes" xml:space="preserve">
          <source>The endpoint is the boundary where all requests to your web application start. It is also the interface your application provides to the underlying web servers.</source>
          <target state="translated">端点是所有对网络应用的请求开始的边界。它也是你的应用程序提供给底层网络服务器的接口。</target>
        </trans-unit>
        <trans-unit id="74811601480966246292b2b910ca967ac18caf00" translate="yes" xml:space="preserve">
          <source>The endpoint, router, and controllers in Phoenix accept plugs.</source>
          <target state="translated">凤凰城的端点、路由器、控制器都接受插。</target>
        </trans-unit>
        <trans-unit id="a71e0101c0d6d0c31084c2c74654c8ab5ada1e0f" translate="yes" xml:space="preserve">
          <source>The entry point for defining forms in Phoenix is with the &lt;a href=&quot;#form_for/4&quot;&gt;&lt;code&gt;form_for/4&lt;/code&gt;&lt;/a&gt; function. For this example, we will use &lt;code&gt;Ecto.Changeset&lt;/code&gt;, which integrates nicely with Phoenix forms via the &lt;code&gt;phoenix_ecto&lt;/code&gt; package.</source>
          <target state="translated">在Phoenix中定义表单的入口点是&lt;a href=&quot;#form_for/4&quot;&gt; &lt;code&gt;form_for/4&lt;/code&gt; &lt;/a&gt;函数。在此示例中，我们将使用 &lt;code&gt;Ecto.Changeset&lt;/code&gt; ，它通过 &lt;code&gt;phoenix_ecto&lt;/code&gt; 软件包与Phoenix表单很好地集成在一起。</target>
        </trans-unit>
        <trans-unit id="04c6d1a307f90ddcd28dacda1e19147d95f5924b" translate="yes" xml:space="preserve">
          <source>The event callback is called &lt;em&gt;before&lt;/em&gt; the event happens (in this case, before the view is rendered) with the atom &lt;code&gt;:start&lt;/code&gt; as the first argument; see the &amp;ldquo;Before clause&amp;rdquo; section below.</source>
          <target state="translated">事件回调在事件发生&lt;em&gt;之前&lt;/em&gt;（在这种情况下，在渲染视图之前）以原子 &lt;code&gt;:start&lt;/code&gt; 作为第一个参数被调用；请参阅下面的&amp;ldquo; Before子句&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="757e085e21ddd74789de7bdb0bbe8f07bed88c4b" translate="yes" xml:space="preserve">
          <source>The event callback sequence is:</source>
          <target state="translated">事件回调序列为:</target>
        </trans-unit>
        <trans-unit id="8146ea0120720d389e5e641e32fe81e0949316e4" translate="yes" xml:space="preserve">
          <source>The event occurs (in this case, the view is rendered).</source>
          <target state="translated">事件发生(在这种情况下,视图被渲染)。</target>
        </trans-unit>
        <trans-unit id="ae116b624d5b59052eb64f10c8d76ec7dd431042" translate="yes" xml:space="preserve">
          <source>The event&amp;rsquo;s message must be a serializable map.</source>
          <target state="translated">事件的消息必须是可序列化的映射。</target>
        </trans-unit>
        <trans-unit id="59c29c61995ac6adc27d72e58769a2befdbcb1f2" translate="yes" xml:space="preserve">
          <source>The event's message must be a serializable map.</source>
          <target state="translated">该事件的消息必须是一个可序列化的地图。</target>
        </trans-unit>
        <trans-unit id="c6f8e9a757d63677055c9099b13a0e178eebb865" translate="yes" xml:space="preserve">
          <source>The example above does not use &lt;code&gt;in&lt;/code&gt; because &lt;code&gt;limit&lt;/code&gt; and &lt;code&gt;offset&lt;/code&gt; do not require a reference to the data source. However, extending the query with a where expression would require the use of &lt;code&gt;in&lt;/code&gt;:</source>
          <target state="translated">上面的示例未用于 &lt;code&gt;in&lt;/code&gt; 因为 &lt;code&gt;limit&lt;/code&gt; 和 &lt;code&gt;offset&lt;/code&gt; 不需要引用数据源。但是，使用where表达式扩展查询将需要使用 &lt;code&gt;in&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="2a68a419c4788a627e1c523a21aa9c289200ba77" translate="yes" xml:space="preserve">
          <source>The example above renders a template &quot;show.html&quot; from the &lt;code&gt;MyAppWeb.UserView&lt;/code&gt; and sets the response content type to &quot;text/html&quot;.</source>
          <target state="translated">上面的示例从 &lt;code&gt;MyAppWeb.UserView&lt;/code&gt; 呈现模板&amp;ldquo; show.html&amp;rdquo;，并将响应内容类型设置为&amp;ldquo; text / html&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="323718568a794b79b80b9c7f90d47fc0dddb0e78" translate="yes" xml:space="preserve">
          <source>The example above renders a template &amp;ldquo;show.html&amp;rdquo; from the &lt;code&gt;MyApp.UserView&lt;/code&gt; and sets the response content type to &amp;ldquo;text/html&amp;rdquo;.</source>
          <target state="translated">上面的示例从 &lt;code&gt;MyApp.UserView&lt;/code&gt; 渲染模板&amp;ldquo; show.html&amp;rdquo;，并将响应内容类型设置为&amp;ldquo; text / html&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="263bcd680d02d0dedd523e55597569bfc7eb4085" translate="yes" xml:space="preserve">
          <source>The example above will fetch all posts from the database and then do a separate query returning all comments associated with the given posts. The comments are then processed and associated to each returned &lt;code&gt;post&lt;/code&gt; under the &lt;code&gt;comments&lt;/code&gt; field.</source>
          <target state="translated">上面的示例将从数据库中获取所有帖子，然后执行单独的查询，以返回与给定帖子关联的所有注释。然后处理评论，并将其与 &lt;code&gt;comments&lt;/code&gt; 字段下的每个返回 &lt;code&gt;post&lt;/code&gt; 相关联。</target>
        </trans-unit>
        <trans-unit id="b71e88e7ed588cf8386d56a8b902c449be09cbf4" translate="yes" xml:space="preserve">
          <source>The example above will issue two queries, one for loading posts and then another for loading the comments associated with the posts. Comments will be ordered by &lt;code&gt;published_at&lt;/code&gt;.</source>
          <target state="translated">上面的示例将发出两个查询，一个查询用于加载帖子，然后另一个查询用于加载与帖子关联的评论。评论将按 &lt;code&gt;published_at&lt;/code&gt; 排序。</target>
        </trans-unit>
        <trans-unit id="924e9a6b17eb83d28266379ce64871ee77dfc336" translate="yes" xml:space="preserve">
          <source>The example above will work if the input query has 1 or 10 bindings. As long as the number of bindings is less than the number of from + joins, Ecto will match only what you have specified. The first binding always matches the source given in &lt;code&gt;from&lt;/code&gt;.</source>
          <target state="translated">如果输入查询具有1或10个绑定，则上面的示例将起作用。只要绑定数少于from +联接数，Ecto将仅匹配您指定的内容。第一个绑定始终与 &lt;code&gt;from&lt;/code&gt; 中给定的源匹配。</target>
        </trans-unit>
        <trans-unit id="597f52cde33ea3d40cd216eeff98f0f27574f4d6" translate="yes" xml:space="preserve">
          <source>The exclusion constraint works by relying on the database to check if the exclusion constraint has been violated or not and, if so, Ecto converts it into a changeset error.</source>
          <target state="translated">排除约束的工作原理是依靠数据库来检查是否违反了排除约束,如果违反了,Ecto会将其转换为变化集错误。</target>
        </trans-unit>
        <trans-unit id="77dfbd136a0c7b400c0e6cf8e244d45dcfb4c0ae" translate="yes" xml:space="preserve">
          <source>The field name will be used as is to read and write to the database by all of the built-in adapters unless overridden with the &lt;code&gt;:source&lt;/code&gt; option.</source>
          <target state="translated">除非使用 &lt;code&gt;:source&lt;/code&gt; 选项覆盖，否则所有内置适配器都将按原样使用字段名来读写数据库。</target>
        </trans-unit>
        <trans-unit id="28d67d8abd4a4854029b14119fba01291b055159" translate="yes" xml:space="preserve">
          <source>The fields are:</source>
          <target state="translated">这些领域是:</target>
        </trans-unit>
        <trans-unit id="23e99979ef97808c907b0384c23bb476163e1c89" translate="yes" xml:space="preserve">
          <source>The fields generated by this macro will automatically be set to the current time when inserting and updating values in a repository.</source>
          <target state="translated">在版本库中插入和更新值时,该宏生成的字段将自动设置为当前时间。</target>
        </trans-unit>
        <trans-unit id="b3a7c7070bdd1da6f37c5437d705a4f71db3064c" translate="yes" xml:space="preserve">
          <source>The first argument can also be a &lt;code&gt;types&lt;/code&gt; map:</source>
          <target state="translated">第一个参数也可以是 &lt;code&gt;types&lt;/code&gt; 映射：</target>
        </trans-unit>
        <trans-unit id="49bed0abeb1db58200a4ef0db4c5da86c91aa45c" translate="yes" xml:space="preserve">
          <source>The first argument can be a a schema module, or a map (of types) and determines the return value: a struct or a map, respectively.</source>
          <target state="translated">第一个参数可以是一个模式模块,也可以是一个映射(类型),并确定返回值:分别是一个结构或一个映射。</target>
        </trans-unit>
        <trans-unit id="ec0251c98fcdc3180f663f2d434e28c1ff287694" translate="yes" xml:space="preserve">
          <source>The first argument can be a an embedded schema module, or a map (of types) and determines the return value: a struct or a map, respectively.</source>
          <target state="translated">第一个参数可以是一个内嵌的模式模块,也可以是一个映射(类型),并确定返回值:分别是一个结构或一个映射。</target>
        </trans-unit>
        <trans-unit id="500f8521003b9bf543828ad835d40f5eeb6af0a7" translate="yes" xml:space="preserve">
          <source>The first argument is a &lt;code&gt;datetime&lt;/code&gt;, the second one is the count for the interval, which may be either positive or negative and the interval value:</source>
          <target state="translated">第一个参数是 &lt;code&gt;datetime&lt;/code&gt; ，第二个参数是间隔的计数，它可以是正数或负数以及间隔值：</target>
        </trans-unit>
        <trans-unit id="c0e54dc181af943e0b3cceca923e134cbcf1e0c6" translate="yes" xml:space="preserve">
          <source>The first argument is the context module followed by the schema module and its plural name (used as the schema table name).</source>
          <target state="translated">第一个参数是上下文模块,后面是模式模块及其复数名称(用作模式表名)。</target>
        </trans-unit>
        <trans-unit id="4865c8fae49bc4316a74325ea7181643af770fb4" translate="yes" xml:space="preserve">
          <source>The first argument is the context the callback is being invoked. If it is called because the Repo supervisor is starting, it will be &lt;code&gt;:supervisor&lt;/code&gt;. It will be &lt;code&gt;:runtime&lt;/code&gt; if it is called for reading configuration without actually starting a process.</source>
          <target state="translated">第一个参数是调用回调的上下文。如果由于Repo主管正在启动而被调用，它将是 &lt;code&gt;:supervisor&lt;/code&gt; 。这将是 &lt;code&gt;:runtime&lt;/code&gt; ，如果它被称为读取配置而不真正开始的一种方法。</target>
        </trans-unit>
        <trans-unit id="abeed1d3f6ef43117d9c456048712438c831279a" translate="yes" xml:space="preserve">
          <source>The first argument is the module name followed by its plural name (used for resources and schema).</source>
          <target state="translated">第一个参数是模块名称,后面是它的复数名称(用于资源和模式)。</target>
        </trans-unit>
        <trans-unit id="964c9cb93e956fb751ffeb1617eb35e4e1dd5ef8" translate="yes" xml:space="preserve">
          <source>The first argument is the module name followed by its plural name (used for the schema).</source>
          <target state="translated">第一个参数是模块名称,后面是它的复数名称(用于模式)。</target>
        </trans-unit>
        <trans-unit id="35f70a15e0108aa4e4b74899ee54723e2a713861" translate="yes" xml:space="preserve">
          <source>The first argument is the path where the static files are located. The &lt;code&gt;-o&lt;/code&gt; option indicates the path that will be used to save the digested and compressed files.</source>
          <target state="translated">第一个参数是静态文件所在的路径。该 &lt;code&gt;-o&lt;/code&gt; 选项表示将用来保存消化和压缩文件的路径。</target>
        </trans-unit>
        <trans-unit id="2fe4f44a0f785ff10de251522a37c07e0b5ab7bb" translate="yes" xml:space="preserve">
          <source>The first argument is the schema module followed by its plural name (used as the table name).</source>
          <target state="translated">第一个参数是模式模块,后面是它的复数名称(作为表名使用)。</target>
        </trans-unit>
        <trans-unit id="e4b02077d7ac802cfee0627d193ca5cd0a9be149" translate="yes" xml:space="preserve">
          <source>The first argument is the schema module followed by the schema attributes</source>
          <target state="translated">第一个参数是模式模块,后面是模式属性。</target>
        </trans-unit>
        <trans-unit id="d11a276567643357f029e74ffc86b05f8be866b2" translate="yes" xml:space="preserve">
          <source>The first argument is the schema module followed by the schema attributes.</source>
          <target state="translated">第一个参数是模式模块,后面是模式属性。</target>
        </trans-unit>
        <trans-unit id="85394c0d9cf1f3bd97ab6925f698c432e75e0ba3" translate="yes" xml:space="preserve">
          <source>The first argument should either be a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Phoenix.HTML.Form&lt;/code&gt;&lt;/a&gt; emitted by &lt;code&gt;form_for&lt;/code&gt; or an atom.</source>
          <target state="translated">第一个参数应该是 &lt;code&gt;form_for&lt;/code&gt; 发出的&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Phoenix.HTML.Form&lt;/code&gt; &lt;/a&gt;或一个原子。</target>
        </trans-unit>
        <trans-unit id="4d5565085e0846e63bdeb7de3b6914b3e5d53f51" translate="yes" xml:space="preserve">
          <source>The first argument to both &lt;a href=&quot;#sign/4&quot;&gt;&lt;code&gt;sign/4&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#verify/4&quot;&gt;&lt;code&gt;verify/4&lt;/code&gt;&lt;/a&gt; can be one of:</source>
          <target state="translated">&lt;a href=&quot;#sign/4&quot;&gt; &lt;code&gt;sign/4&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#verify/4&quot;&gt; &lt;code&gt;verify/4&lt;/code&gt; &lt;/a&gt;的第一个参数可以是以下之一：</target>
        </trans-unit>
        <trans-unit id="d49a3d210dbcdc92bf9475253ce66aa64aa7725b" translate="yes" xml:space="preserve">
          <source>The first field name, &lt;code&gt;:email&lt;/code&gt; in this case, will be used as the error key to the changeset errors keyword list. For example, the above &lt;a href=&quot;#unique_constraint/3&quot;&gt;&lt;code&gt;unique_constraint/3&lt;/code&gt;&lt;/a&gt; would generate something like:</source>
          <target state="translated">在这种情况下，第一个字段名称 &lt;code&gt;:email&lt;/code&gt; 将用作changeset errors关键字列表的错误关键字。例如，上面的&lt;a href=&quot;#unique_constraint/3&quot;&gt; &lt;code&gt;unique_constraint/3&lt;/code&gt; &lt;/a&gt;将生成如下内容：</target>
        </trans-unit>
        <trans-unit id="14c98ababa7076deb4b23e215e725e5dcc321dec" translate="yes" xml:space="preserve">
          <source>The first line below the module definition invokes the &lt;code&gt;__using__/1&lt;/code&gt; macro of the &lt;code&gt;HelloWeb&lt;/code&gt; module, which imports some useful modules.</source>
          <target state="translated">模块定义下面的第一行调用 &lt;code&gt;HelloWeb&lt;/code&gt; 模块的 &lt;code&gt;__using__/1&lt;/code&gt; 宏，该宏会导入一些有用的模块。</target>
        </trans-unit>
        <trans-unit id="79d9874d0b09b5d634a9bffe5a01fb056e0e669b" translate="yes" xml:space="preserve">
          <source>The first line of this module, &lt;code&gt;use HelloWeb, :router&lt;/code&gt;, simply makes Phoenix router functions available in our particular router.</source>
          <target state="translated">该模块的第一行 &lt;code&gt;use HelloWeb, :router&lt;/code&gt; ，仅使Phoenix路由器功能在我们的特定路由器中可用。</target>
        </trans-unit>
        <trans-unit id="5b536e4964b55b3a608e3b733d3258cc0956029a" translate="yes" xml:space="preserve">
          <source>The first parameter is always &lt;code&gt;conn&lt;/code&gt;, a struct which holds information about the request such as the host, path elements, port, query string, and much more. &lt;code&gt;conn&lt;/code&gt;, comes to Phoenix via Elixir's Plug middleware framework. More detailed info about &lt;code&gt;conn&lt;/code&gt; can be found in &lt;a href=&quot;../plug/plug.conn&quot;&gt;plug's documentation&lt;/a&gt;.</source>
          <target state="translated">第一个参数始终为 &lt;code&gt;conn&lt;/code&gt; ，该结构保存有关请求的信息，例如主机，路径元素，端口，查询字符串等。 &lt;code&gt;conn&lt;/code&gt; ，通过Elixir的Plug中间件框架进入Phoenix。有关 &lt;code&gt;conn&lt;/code&gt; 的更多详细信息，请参见&lt;a href=&quot;../plug/plug.conn&quot;&gt;插件的文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2cb52f0181ac504af2d274804ae227768df1b3b4" translate="yes" xml:space="preserve">
          <source>The first plug will run only when action is show or edit. The second plug will always run, except for the index action.</source>
          <target state="translated">第一个插件只有在操作为显示或编辑时才会运行,第二个插件会一直运行,除了索引操作。第二个插件会一直运行,除了索引操作。</target>
        </trans-unit>
        <trans-unit id="a7a085c723aa2725f1a835b9fa686c2f8a3dbb9f" translate="yes" xml:space="preserve">
          <source>The first question is, where does that error string come from? The answer is right in the &lt;code&gt;ErrorView&lt;/code&gt;.</source>
          <target state="translated">第一个问题是，错误字符串从何而来？答案是正确的 &lt;code&gt;ErrorView&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="87cb90ded997365e136d73bbbbeaa6912dce9a57" translate="yes" xml:space="preserve">
          <source>The first step is to start the adapter of choice in your supervision tree:</source>
          <target state="translated">第一步是在你的监督树上启动选择的适配器。</target>
        </trans-unit>
        <trans-unit id="ce8e7b83d95aab3d7102e7f0e03f87b4868c2329" translate="yes" xml:space="preserve">
          <source>The first thing we need to do is create a &lt;code&gt;mix/tasks&lt;/code&gt; directory inside of &lt;code&gt;lib&lt;/code&gt;. This is where any of our application specific mix tasks will go.</source>
          <target state="translated">我们需要做的第一件事是在 &lt;code&gt;lib&lt;/code&gt; 内部创建一个 &lt;code&gt;mix/tasks&lt;/code&gt; 目录。这是我们任何特定于应用程序的混合任务将要去的地方。</target>
        </trans-unit>
        <trans-unit id="e521b29a1418c4c03c1262013a47617e674a9abe" translate="yes" xml:space="preserve">
          <source>The first thing we need to do is name our module. All tasks must be defined in &lt;code&gt;Mix.Tasks&lt;/code&gt; namespace. We'd like to invoke this as &lt;code&gt;mix hello.greeting&lt;/code&gt;, so we complete the module name with &lt;code&gt;Hello.Greeting&lt;/code&gt;.</source>
          <target state="translated">我们需要做的第一件事是为我们的模块命名。必须在 &lt;code&gt;Mix.Tasks&lt;/code&gt; 命名空间中定义所有任务。我们想把它作为 &lt;code&gt;mix hello.greeting&lt;/code&gt; 来调用，所以我们用 &lt;code&gt;Hello.Greeting&lt;/code&gt; 完成模块名称。</target>
        </trans-unit>
        <trans-unit id="29f463e217a7cb3a4cb33031b1d1ba5fe4bbd808" translate="yes" xml:space="preserve">
          <source>The first thing we need to do to create that page is define a route for it. Let's open up &lt;code&gt;lib/hello_web/router.ex&lt;/code&gt; in a text editor. For a brand new application, it looks like this:</source>
          <target state="translated">创建该页面所需要做的第一件事是为其定义路由。让我们在文本编辑器中打开 &lt;code&gt;lib/hello_web/router.ex&lt;/code&gt; 。对于全新的应用程序，它看起来像这样：</target>
        </trans-unit>
        <trans-unit id="f8101d8208169439cea8beb089d2fd5b7d5aeff5" translate="yes" xml:space="preserve">
          <source>The flash functionality is handy when mixed with redirects. Perhaps you want to redirect to a page with some extra information. If we re-use the redirect action from the previous section, we can do:</source>
          <target state="translated">当与重定向混合使用时,flash功能非常方便。也许你想重定向到一个有一些额外信息的页面。如果我们重新使用上一节的重定向动作,我们可以这样做。</target>
        </trans-unit>
        <trans-unit id="23dbc44cf8fcb8401ecac56fad2056f3e27fd632" translate="yes" xml:space="preserve">
          <source>The following approach is &lt;strong&gt;wrong&lt;/strong&gt;:</source>
          <target state="translated">以下方法是&lt;strong&gt;错误的&lt;/strong&gt;：</target>
        </trans-unit>
        <trans-unit id="27f0532927f5dfde2ed38eb7adc999b8682a2ebd" translate="yes" xml:space="preserve">
          <source>The following assigns are reserved, and cannot be set directly:</source>
          <target state="translated">以下赋值是保留的,不能直接设置。</target>
        </trans-unit>
        <trans-unit id="96a9598d7d5639506795473ffa8dad0e7b28cb27" translate="yes" xml:space="preserve">
          <source>The following configuration applies only to &lt;code&gt;:longpoll&lt;/code&gt;:</source>
          <target state="translated">以下配置仅适用于 &lt;code&gt;:longpoll&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="2c9626abcad38b5d2ad7be4a47ee7034e64d5860" translate="yes" xml:space="preserve">
          <source>The following configuration applies only to &lt;code&gt;:websocket&lt;/code&gt;.</source>
          <target state="translated">以下配置仅适用于 &lt;code&gt;:websocket&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="13779d40c7bd0138f604faeb9ae943fd9630bdfd" translate="yes" xml:space="preserve">
          <source>The following events are emitted by all Ecto repositories:</source>
          <target state="translated">所有Ecto存储库都会发出以下事件。</target>
        </trans-unit>
        <trans-unit id="697b7462029e6e23c15a3021022337813a16f040" translate="yes" xml:space="preserve">
          <source>The following fields are private and must not be accessed directly.</source>
          <target state="translated">以下字段为私人领域,不得直接访问。</target>
        </trans-unit>
        <trans-unit id="baaf66ee23187b5f5ad09e6055f8ea194c2622bf" translate="yes" xml:space="preserve">
          <source>The following function lifts &lt;code&gt;metadata.socket.view&lt;/code&gt; and &lt;code&gt;metadata.socket.connected?&lt;/code&gt; to be top-level keys on &lt;code&gt;metadata&lt;/code&gt;, as we did in the previous example.</source>
          <target state="translated">以下功能可解除 &lt;code&gt;metadata.socket.view&lt;/code&gt; 和 &lt;code&gt;metadata.socket.connected?&lt;/code&gt; 就像在上一个示例中一样，是 &lt;code&gt;metadata&lt;/code&gt; 顶级键。</target>
        </trans-unit>
        <trans-unit id="b34d9298df0cbb61838280284087d26545c45a26" translate="yes" xml:space="preserve">
          <source>The following intervals are supported: year, month, week, day, hour, minute, second, millisecond and microsecond.</source>
          <target state="translated">支持以下间隔:年、月、周、日、时、分、秒、毫秒和微秒。</target>
        </trans-unit>
        <trans-unit id="1ff93af922ef6535f32352b2b639755a01dafeb3" translate="yes" xml:space="preserve">
          <source>The following keys are allowed when specifying a window.</source>
          <target state="translated">在指定窗口时,允许使用以下键。</target>
        </trans-unit>
        <trans-unit id="59c9c3a965c72c26e14a2014331e87cf4bda5729" translate="yes" xml:space="preserve">
          <source>The following keys are available:</source>
          <target state="translated">以下是可用的钥匙:</target>
        </trans-unit>
        <trans-unit id="fdd2468c439eb11013c816be656d524ad7f23e6f" translate="yes" xml:space="preserve">
          <source>The following params have special meaning in LiveView:</source>
          <target state="translated">以下参数在LiveView中具有特殊意义。</target>
        </trans-unit>
        <trans-unit id="aebca73a523dda1e7ab387256d00be6cee49a026" translate="yes" xml:space="preserve">
          <source>The following public fields represent the LiveView:</source>
          <target state="translated">以下公共字段代表LiveView。</target>
        </trans-unit>
        <trans-unit id="a77ca9c2bc454b722bf0d3007090b822823c3ad6" translate="yes" xml:space="preserve">
          <source>The following public fields represent the element:</source>
          <target state="translated">以下公共字段代表该元素。</target>
        </trans-unit>
        <trans-unit id="71d94986edc28d20eb6e61b59ed0d6b150611abc" translate="yes" xml:space="preserve">
          <source>The following returns must be handled by transports:</source>
          <target state="translated">下面的返回必须由运输工具来处理。</target>
        </trans-unit>
        <trans-unit id="cc0e8fdffd8fa1f0de767e3b482f423a5a285a50" translate="yes" xml:space="preserve">
          <source>The following specialized behavior is performed for forms and keydown bindings:</source>
          <target state="translated">对于表单和键入绑定,会有以下专门的行为。</target>
        </trans-unit>
        <trans-unit id="7450f3bbf7bebc0ac2b8dc21e3fc9b6d5613f466" translate="yes" xml:space="preserve">
          <source>The following status codes can be given as atoms with their respective value shown next:</source>
          <target state="translated">以下状态码可以作为原子给出,其各自的值如下所示。</target>
        </trans-unit>
        <trans-unit id="c734167c81ee7d5e27dd0815c6c9a86a53980591" translate="yes" xml:space="preserve">
          <source>The following types are supported:</source>
          <target state="translated">支持以下类型:</target>
        </trans-unit>
        <trans-unit id="2047e7bdd4c73fd0eee9eccb4cbf4a0fb4bc1b07" translate="yes" xml:space="preserve">
          <source>The following validations may be included in the result. The list is not necessarily exhaustive. For example, custom validations written by the developer will also appear in our return value.</source>
          <target state="translated">结果中可能包括以下验证。这个列表不一定是详尽的。例如,开发者编写的自定义验证也会出现在我们的返回值中。</target>
        </trans-unit>
        <trans-unit id="cba133f413c5a544cc032d45c75d5ce55c737264" translate="yes" xml:space="preserve">
          <source>The following values are supported as date:</source>
          <target state="translated">支持以下数值作为日期。</target>
        </trans-unit>
        <trans-unit id="5bfa84ecf1155190787c1f7e94a11fe721e17de4" translate="yes" xml:space="preserve">
          <source>The following values are supported as time:</source>
          <target state="translated">支持以下数值作为时间。</target>
        </trans-unit>
        <trans-unit id="a481ccb6962d389f9f787ae8a2a1fafb0d321119" translate="yes" xml:space="preserve">
          <source>The following window-level bindings are supported:</source>
          <target state="translated">支持以下窗口级绑定。</target>
        </trans-unit>
        <trans-unit id="9ce20518f56534bcc1118c0bf986d78eef528c90" translate="yes" xml:space="preserve">
          <source>The following:</source>
          <target state="translated">以下是:</target>
        </trans-unit>
        <trans-unit id="4117df297cda8bdfcd48daa253e21cdf1ba31860" translate="yes" xml:space="preserve">
          <source>The foreign key constraint works by relying on the database to check if the associated data exists or not. This is useful to guarantee that a child will only be created if the parent exists in the database too.</source>
          <target state="translated">外键约束的作用是依靠数据库来检查相关数据是否存在。这对于保证只有当父数据也存在于数据库中时才会创建子数据是很有用的。</target>
        </trans-unit>
        <trans-unit id="9abddf5cdee83822dd2471a1c84adfa00e2761db" translate="yes" xml:space="preserve">
          <source>The form data will be validated directly against the form markup and make sure the data you are changing/submitting actually exists, failing otherwise.</source>
          <target state="translated">表单数据将直接与表单标记进行验证,并确保你所更改/提交的数据确实存在,否则失败。</target>
        </trans-unit>
        <trans-unit id="e8fa4eb4ae0982343eb1b5d21fa657d106b56303" translate="yes" xml:space="preserve">
          <source>The form generates a CSRF token by default. Your application should check this token on the server to avoid attackers from making requests on your server in behalf of other users. Phoenix by default checks this token.</source>
          <target state="translated">表单默认会生成一个CSRF令牌,您的应用程序应该在服务器上检查这个令牌,避免攻击者代表其他用户向您的服务器发出请求。您的应用程序应该在服务器上检查这个标记,以避免攻击者代表其他用户向您的服务器发出请求。Phoenix 默认情况下会检查这个标记。</target>
        </trans-unit>
        <trans-unit id="a1ba555c0e57f112db7c92095d012a43d52db5ee" translate="yes" xml:space="preserve">
          <source>The form receives the &lt;code&gt;&quot;phx-submit-loading&quot;&lt;/code&gt; class</source>
          <target state="translated">该表单接收 &lt;code&gt;&quot;phx-submit-loading&quot;&lt;/code&gt; 类</target>
        </trans-unit>
        <trans-unit id="f83c045b60690e0951f0d613211981e82b773a3a" translate="yes" xml:space="preserve">
          <source>The form should either be a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Phoenix.HTML.Form&lt;/code&gt;&lt;/a&gt; emitted by &lt;code&gt;form_for&lt;/code&gt; or an atom.</source>
          <target state="translated">该表单应该是由 &lt;code&gt;form_for&lt;/code&gt; 发出的&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Phoenix.HTML.Form&lt;/code&gt; &lt;/a&gt;或一个原子。</target>
        </trans-unit>
        <trans-unit id="8d01992897ad728050b4b855767bf08df37caba2" translate="yes" xml:space="preserve">
          <source>The form should either be a &lt;a href=&quot;phoenix.html.form#content&quot;&gt;&lt;code&gt;Phoenix.HTML.Form&lt;/code&gt;&lt;/a&gt; emitted by &lt;code&gt;form_for&lt;/code&gt; or an atom.</source>
          <target state="translated">该表单应该是 &lt;code&gt;form_for&lt;/code&gt; 发出的&lt;a href=&quot;phoenix.html.form#content&quot;&gt; &lt;code&gt;Phoenix.HTML.Form&lt;/code&gt; &lt;/a&gt;或一个原子。</target>
        </trans-unit>
        <trans-unit id="7a6fd6898aaadbc26c2bf3b5a891b41542112f89" translate="yes" xml:space="preserve">
          <source>The form's inputs are set to &lt;code&gt;readonly&lt;/code&gt;</source>
          <target state="translated">表单的输入设置为 &lt;code&gt;readonly&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f1af6d5bfd7bd7fb64c73cbb0bcf39cb8cf169f9" translate="yes" xml:space="preserve">
          <source>The format has to be expressed as a regular expression.</source>
          <target state="translated">格式必须用正则表达式来表示。</target>
        </trans-unit>
        <trans-unit id="489cb5dcb56120d97d2c8e93ec7af5be88c2a077" translate="yes" xml:space="preserve">
          <source>The forwarded plug will be initialized at compile time.</source>
          <target state="translated">转发的插件将在编译时被初始化。</target>
        </trans-unit>
        <trans-unit id="77d021b8d46e32208156e088e01303ca1c12d18a" translate="yes" xml:space="preserve">
          <source>The full list of &lt;code&gt;:telemetry&lt;/code&gt; events emitted from Phoenix, along with their measurements and metadata, is available in the &quot;Instrumentation&quot; section of the &lt;a href=&quot;phoenix.logger&quot;&gt;&lt;code&gt;Phoenix.Logger&lt;/code&gt;&lt;/a&gt; module documentation.</source>
          <target state="translated">&lt;a href=&quot;phoenix.logger&quot;&gt; &lt;code&gt;Phoenix.Logger&lt;/code&gt; &lt;/a&gt;模块文档的&amp;ldquo;仪器&amp;rdquo;部分提供了Phoenix发出的 &lt;code&gt;:telemetry&lt;/code&gt; 事件的完整列表以及它们的测量值和元数据。</target>
        </trans-unit>
        <trans-unit id="6f475ae2afee4e174380adc1703f946251ee406f" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;#dispatch/3&quot;&gt;&lt;code&gt;dispatch/3&lt;/code&gt;&lt;/a&gt; can be used to handle these messages.</source>
          <target state="translated">函数&lt;a href=&quot;#dispatch/3&quot;&gt; &lt;code&gt;dispatch/3&lt;/code&gt; &lt;/a&gt;可用于处理这些消息。</target>
        </trans-unit>
        <trans-unit id="b2ef8c5833d6215f90102ad8553d89a6b62ac7bf" translate="yes" xml:space="preserve">
          <source>The function above fetches all users from the database who have registered presences for the given topic. The fetched information is then extended with a &lt;code&gt;:user&lt;/code&gt; key of the user&amp;rsquo;s information, while maintaining the required &lt;code&gt;:metas&lt;/code&gt; field from the original presence data.</source>
          <target state="translated">上面的函数从数据库中获取已注册给定主题的状态的所有用户。然后使用 &lt;code&gt;:user&lt;/code&gt; 信息的：user键扩展获取的信息，同时从原始状态数据中保留所需的 &lt;code&gt;:metas&lt;/code&gt; 字段。</target>
        </trans-unit>
        <trans-unit id="3bb5d899f787348b0861709cf9aa7599e25a199f" translate="yes" xml:space="preserve">
          <source>The function accepts a status either as an integer HTTP status or atom, such as &lt;code&gt;404&lt;/code&gt; or &lt;code&gt;:not_found&lt;/code&gt;. If an error is raised, a 3-tuple of the wrapped response is returned matching the status, headers, and body of the response:</source>
          <target state="translated">该函数接受状态为整数HTTP状态或原子，例如 &lt;code&gt;404&lt;/code&gt; 或 &lt;code&gt;:not_found&lt;/code&gt; 。如果引发错误，则返回三元组的已包装响应，与响应的状态，标头和正文匹配：</target>
        </trans-unit>
        <trans-unit id="7a00d6812bf7a0419f2a6f9124c6b63f43006264" translate="yes" xml:space="preserve">
          <source>The function accepts a status either as an integer HTTP status or atom, such as &lt;code&gt;404&lt;/code&gt; or &lt;code&gt;:not_found&lt;/code&gt;. The list of allowed atoms is available in &lt;a href=&quot;../plug/plug.conn.status&quot;&gt;&lt;code&gt;Plug.Conn.Status&lt;/code&gt;&lt;/a&gt;. If an error is raised, a 3-tuple of the wrapped response is returned matching the status, headers, and body of the response:</source>
          <target state="translated">该函数接受状态为整数HTTP状态或原子，例如 &lt;code&gt;404&lt;/code&gt; 或 &lt;code&gt;:not_found&lt;/code&gt; 。允许的原子列表在&lt;a href=&quot;../plug/plug.conn.status&quot;&gt; &lt;code&gt;Plug.Conn.Status&lt;/code&gt; 中&lt;/a&gt;可用。如果引发错误，则返回三元组的已包装响应，与响应的状态，标头和正文匹配：</target>
        </trans-unit>
        <trans-unit id="34f7c94fd7748f67cd09813bdd7706a2edb3046e" translate="yes" xml:space="preserve">
          <source>The function given to &lt;code&gt;run&lt;/code&gt; must return &lt;code&gt;{:ok, value}&lt;/code&gt; or &lt;code&gt;{:error, value}&lt;/code&gt; as its result. Returning an error will abort any further operations and make the whole multi fail.</source>
          <target state="translated">赋予 &lt;code&gt;run&lt;/code&gt; 的功能必须返回 &lt;code&gt;{:ok, value}&lt;/code&gt; 或 &lt;code&gt;{:error, value}&lt;/code&gt; 作为结果。返回错误将中止任何进一步的操作，并使整个多重失败。</target>
        </trans-unit>
        <trans-unit id="2a481723c76058903ea9cbe576e12efab982d90c" translate="yes" xml:space="preserve">
          <source>The function must return a map of data matching the outlined Presence data structure, including the &lt;code&gt;:metas&lt;/code&gt; key, but can extend the map of information to include any additional information. For example:</source>
          <target state="translated">该函数必须返回与概述的Presence数据结构匹配的数据映射，包括 &lt;code&gt;:metas&lt;/code&gt; 键，但可以扩展信息映射以包括任何其他信息。例如：</target>
        </trans-unit>
        <trans-unit id="fa901f9a75974fd4d90e6889c130fadce04c365a" translate="yes" xml:space="preserve">
          <source>The function returns a tuple with the first element being a quoted reference to the connection and the second element being the compiled quoted pipeline.</source>
          <target state="translated">该函数返回一个元组,第一个元素是对连接的引用,第二个元素是编译后的引用管道。</target>
        </trans-unit>
        <trans-unit id="153b2df483884d8b989e308df19cc7b9893a9689" translate="yes" xml:space="preserve">
          <source>The function should return either &lt;code&gt;{:ok, value}&lt;/code&gt; or &lt;code&gt;{:error, value}&lt;/code&gt;, and receives the repo as the first argument, and the changes so far as the second argument.</source>
          <target state="translated">该函数应返回 &lt;code&gt;{:ok, value}&lt;/code&gt; 或 &lt;code&gt;{:error, value}&lt;/code&gt; ，并接收回购作为第一个参数，而更改则作为第二个参数。</target>
        </trans-unit>
        <trans-unit id="a67c783032e2a201537e306cf6f097d5365e66b6" translate="yes" xml:space="preserve">
          <source>The functionality provided by this module helps in performing &quot;origin&quot; header checks and ensuring only SSL connections are allowed.</source>
          <target state="translated">该模块提供的功能有助于执行 &quot;原点 &quot;头检查,确保只允许SSL连接。</target>
        </trans-unit>
        <trans-unit id="d040f9e18e02bf1e9b7b5a6b1124e1c1c9357436" translate="yes" xml:space="preserve">
          <source>The functionality provided by this module helps in performing &amp;ldquo;origin&amp;rdquo; header checks and ensuring only SSL connections are allowed.</source>
          <target state="translated">此模块提供的功能有助于执行&amp;ldquo;原始&amp;rdquo;标头检查，并确保仅允许SSL连接。</target>
        </trans-unit>
        <trans-unit id="f3caf5d490d3889e61dbe8db689ddbc1dc882729" translate="yes" xml:space="preserve">
          <source>The functions in this module can also be used for controller testing. While endpoint testing is preferred over controller testing as a controller often depends on the pipelines invoked in the router and before, unit testing controllers may be helpful in some situations.</source>
          <target state="translated">该模块中的功能也可以用于控制器测试。虽然端点测试优于控制器测试,因为控制器往往取决于在路由器和之前调用的管道,但在某些情况下,单元测试控制器可能会有所帮助。</target>
        </trans-unit>
        <trans-unit id="5e080e3a5969a0dfe51e38a130fc2af62050c352" translate="yes" xml:space="preserve">
          <source>The functions in this module can also be used for controller testing. While endpoint testing is preferred over controller testing, especially since the controller in Phoenix plays an integration role between your domain and your views, unit testing controllers may be helpful in some situations.</source>
          <target state="translated">该模块中的功能也可用于控制器测试。虽然端点测试优于控制器测试,特别是由于Phoenix中的控制器在您的域和视图之间扮演着集成角色,但在某些情况下,单元测试控制器可能会有所帮助。</target>
        </trans-unit>
        <trans-unit id="d3dd86f90d5374c8aba9a2543470a122fcff086c" translate="yes" xml:space="preserve">
          <source>The functions in this module can be used in three distinct scenarios:</source>
          <target state="translated">本模块中的功能可以在三个不同的场景下使用。</target>
        </trans-unit>
        <trans-unit id="ca241d49313e0782ffcc88432a8a2d858c13e8e9" translate="yes" xml:space="preserve">
          <source>The generated datetime_select can be customized at will by providing a builder option. Here is an example from EEx:</source>
          <target state="translated">生成的datetime_select可以通过提供一个生成器选项随意定制。下面是EEx的一个例子。</target>
        </trans-unit>
        <trans-unit id="a05e320bee1a84e2ffca470cb7c31539b99e85c1" translate="yes" xml:space="preserve">
          <source>The generated files will contain:</source>
          <target state="translated">生成的文件将包含:</target>
        </trans-unit>
        <trans-unit id="958104172477f9b5a43c314b73c9b38aabb7fb31" translate="yes" xml:space="preserve">
          <source>The generated migration can be skipped with &lt;code&gt;--no-migration&lt;/code&gt;.</source>
          <target state="translated">可以使用 &lt;code&gt;--no-migration&lt;/code&gt; 跳过生成的迁移。</target>
        </trans-unit>
        <trans-unit id="2360bfab30a1d9a0770994aab3da68e5eb2150e6" translate="yes" xml:space="preserve">
          <source>The generated model will contain:</source>
          <target state="translated">生成的模型将包含:</target>
        </trans-unit>
        <trans-unit id="c2fafd8b72db2fda76555b5c3231ac455bc8d91f" translate="yes" xml:space="preserve">
          <source>The generated request id will be in the format &quot;uq8hs30oafhj5vve8ji5pmp7mtopc08f&quot;.</source>
          <target state="translated">生成的请求id将以 &quot;uq8hs30oafhj5vve8ji5pmp7mtopc08f &quot;的格式。</target>
        </trans-unit>
        <trans-unit id="9e5668b35e826d6b7f7128c9281d2999702c5951" translate="yes" xml:space="preserve">
          <source>The generated request id will be in the format &amp;ldquo;uq8hs30oafhj5vve8ji5pmp7mtopc08f&amp;rdquo;.</source>
          <target state="translated">生成的请求ID的格式为&amp;ldquo; uq8hs30oafhj5vve8ji5pmp7mtopc08f&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="3f6f61987271b75470a17cf53dff2fe262f3c6a6" translate="yes" xml:space="preserve">
          <source>The generated resource will contain:</source>
          <target state="translated">生成的资源将包含:</target>
        </trans-unit>
        <trans-unit id="07a1ec291d930976c73c9d45dd66aa61e5c367bd" translate="yes" xml:space="preserve">
          <source>The generated route above will match on the path &lt;code&gt;&quot;/api/v1/pages/:id&quot;&lt;/code&gt; and will dispatch to &lt;code&gt;:show&lt;/code&gt; action in &lt;code&gt;API.V1.PageController&lt;/code&gt;. A named helper &lt;code&gt;api_v1_page_path&lt;/code&gt; will also be generated.</source>
          <target state="translated">上面生成的路由将在路径 &lt;code&gt;&quot;/api/v1/pages/:id&quot;&lt;/code&gt; 上匹配，并将分派到 &lt;code&gt;API.V1.PageController&lt;/code&gt; 中的 &lt;code&gt;:show&lt;/code&gt; 操作。还将生成一个名为helper &lt;code&gt;api_v1_page_path&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8eb6914d64c4e5b2458e4e1b429f8d5623fada37" translate="yes" xml:space="preserve">
          <source>The generated schema above will contain:</source>
          <target state="translated">上面生成的模式将包含:</target>
        </trans-unit>
        <trans-unit id="b0fe9476efd56f82a1ea6f2439a7dfb5f439d397" translate="yes" xml:space="preserve">
          <source>The generator also supports &lt;code&gt;belongs_to&lt;/code&gt; associations via references:</source>
          <target state="translated">生成器还通过引用支持 &lt;code&gt;belongs_to&lt;/code&gt; 关联：</target>
        </trans-unit>
        <trans-unit id="a584765639065a0e41059878bfc54d658311e358" translate="yes" xml:space="preserve">
          <source>The generator also supports references, which we will properly associate the given column to the primary key column of the referenced table:</source>
          <target state="translated">生成器还支持引用,我们会将给定的列与引用表的主键列正确关联。</target>
        </trans-unit>
        <trans-unit id="8ae78460b27964100f540d3c51518f56de1ae5d6" translate="yes" xml:space="preserve">
          <source>The given &lt;code&gt;data&lt;/code&gt; may be either a changeset, a schema struct or a &lt;code&gt;{data, types}&lt;/code&gt; tuple. The second argument is a map of &lt;code&gt;params&lt;/code&gt; that are cast according to the type information from &lt;code&gt;data&lt;/code&gt;. &lt;code&gt;params&lt;/code&gt; is a map with string keys or a map with atom keys containing potentially invalid data.</source>
          <target state="translated">给定的 &lt;code&gt;data&lt;/code&gt; 可以是一个变更集，一个模式结构或一个 &lt;code&gt;{data, types}&lt;/code&gt; 元组。第二个参数是根据 &lt;code&gt;data&lt;/code&gt; 的类型信息 &lt;code&gt;params&lt;/code&gt; 参数映射。 &lt;code&gt;params&lt;/code&gt; 是具有字符串键的映射或具有包含潜在无效数据的原子键的映射。</target>
        </trans-unit>
        <trans-unit id="ed7aeeaafe6c3bad4cfce08f957a5bf97bc013c4" translate="yes" xml:space="preserve">
          <source>The given &lt;code&gt;function&lt;/code&gt; is invoked with the change value only if there is a change for the given &lt;code&gt;key&lt;/code&gt;. Note that the value of the change can still be &lt;code&gt;nil&lt;/code&gt; (unless the field was marked as required on &lt;a href=&quot;#validate_required/3&quot;&gt;&lt;code&gt;validate_required/3&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">仅当给定 &lt;code&gt;key&lt;/code&gt; 发生更改时，才使用更改值调用给定 &lt;code&gt;function&lt;/code&gt; 。请注意，更改的值仍可以为 &lt;code&gt;nil&lt;/code&gt; （除非在&lt;a href=&quot;#validate_required/3&quot;&gt; &lt;code&gt;validate_required/3&lt;/code&gt; &lt;/a&gt;上将该字段标记为必填字段）。</target>
        </trans-unit>
        <trans-unit id="12ae3f1712df00636f70321070eb45b1efc012c4" translate="yes" xml:space="preserve">
          <source>The given attributes are expected to be structured data. If you want to build an association with external data, such as a request parameters, you can use &lt;a href=&quot;ecto.changeset#cast/3&quot;&gt;&lt;code&gt;Ecto.Changeset.cast/3&lt;/code&gt;&lt;/a&gt; after &lt;a href=&quot;#build_assoc/3&quot;&gt;&lt;code&gt;build_assoc/3&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">给定的属性应为结构化数据。如果要与外部数据（例如请求参数）建立关联，则可以在&lt;a href=&quot;ecto.changeset#cast/3&quot;&gt; &lt;code&gt;Ecto.Changeset.cast/3&lt;/code&gt; &lt;/a&gt;之后使用&lt;a href=&quot;#build_assoc/3&quot;&gt; &lt;code&gt;build_assoc/3&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="c33d234c4ff95f48de07c57959d603389ff704eb" translate="yes" xml:space="preserve">
          <source>The given channel is joined in a separate process which is linked to the test process.</source>
          <target state="translated">给定的通道是在一个单独的过程中加入的,它与测试过程相联系。</target>
        </trans-unit>
        <trans-unit id="d4c5415cdd429b8d05fbc81af9046db394117d84" translate="yes" xml:space="preserve">
          <source>The given definition:</source>
          <target state="translated">给定的定义:</target>
        </trans-unit>
        <trans-unit id="7187a5e81ba59fd9a2b763b67226ecb68e6f3832" translate="yes" xml:space="preserve">
          <source>The given function is guaranteed to run inside the same transaction as the changeset operation for databases that do support transactions.</source>
          <target state="translated">对于支持事务的数据库来说,给定的函数可以保证在同一个事务中运行,与改变集操作一样。</target>
        </trans-unit>
        <trans-unit id="2c8584e031d70f2ab97e4e82d41f8a6fb76ac929" translate="yes" xml:space="preserve">
          <source>The goal of this guide is to talk about Phoenix's request life-cycle. This guide will take a practical approach where we will learn by doing: we will add two new pages to our Phoenix project and comment on how the pieces fit together along the way.</source>
          <target state="translated">本指南的目标是谈论Phoenix的请求生命周期。本指南将采取一种实用的方法,我们将在实践中学习:我们将为我们的Phoenix项目添加两个新的页面,并评论各部分是如何沿途结合在一起的。</target>
        </trans-unit>
        <trans-unit id="3c29577b9a3f39ac89098a852612cb04bd74935b" translate="yes" xml:space="preserve">
          <source>The guides that you are currently looking at provide an overview of all parts that make Phoenix. Here is a rundown of what they provide:</source>
          <target state="translated">您目前正在查看的指南提供了凤凰城所有部件的概述。以下是它们提供的概要。</target>
        </trans-unit>
        <trans-unit id="4310f0789aac7f01d7f849f6e0aa96ec026f81a0" translate="yes" xml:space="preserve">
          <source>The helper function &lt;a href=&quot;#values/2&quot;&gt;&lt;code&gt;values/2&lt;/code&gt;&lt;/a&gt; returns the values for a given schema and field, which can be used in places like form drop-downs. For example, given the following schema:</source>
          <target state="translated">辅助函数&lt;a href=&quot;#values/2&quot;&gt; &lt;code&gt;values/2&lt;/code&gt; &lt;/a&gt;返回给定架构和字段的值，这些值可以在表单下拉列表等地方使用。例如，给定以下架构：</target>
        </trans-unit>
        <trans-unit id="cef55b811dca93ddd51b8b1f7019f7e4229080fe" translate="yes" xml:space="preserve">
          <source>The hook can push events to the LiveView by using the &lt;code&gt;pushEvent&lt;/code&gt; function and receive a reply from the server via a &lt;code&gt;{:reply, map, socket}&lt;/code&gt; return value. The reply payload will be passed to the optional &lt;code&gt;pushEvent&lt;/code&gt; response callback.</source>
          <target state="translated">挂钩可以使用 &lt;code&gt;pushEvent&lt;/code&gt; 函数将事件推送到LiveView，并通过 &lt;code&gt;{:reply, map, socket}&lt;/code&gt; 返回值从服务器接收答复。回复有效载荷将传递到可选的 &lt;code&gt;pushEvent&lt;/code&gt; 响应回调。</target>
        </trans-unit>
        <trans-unit id="a573a08337f6f0cf025ec9ae17d9092603c49c35" translate="yes" xml:space="preserve">
          <source>The implementation of this callback should invoke &lt;code&gt;fun&lt;/code&gt; with the value under &lt;code&gt;key&lt;/code&gt; in the passed structure &lt;code&gt;data&lt;/code&gt;, or with &lt;code&gt;nil&lt;/code&gt; if &lt;code&gt;key&lt;/code&gt; is not present in it. This function must return either &lt;code&gt;{get_value, update_value}&lt;/code&gt; or &lt;code&gt;:pop&lt;/code&gt;.</source>
          <target state="translated">这个回调的实现应该调用 &lt;code&gt;fun&lt;/code&gt; 与下的价值 &lt;code&gt;key&lt;/code&gt; 在通过结构 &lt;code&gt;data&lt;/code&gt; ，或 &lt;code&gt;nil&lt;/code&gt; ，如果 &lt;code&gt;key&lt;/code&gt; 是不存在的。此函数必须返回 &lt;code&gt;{get_value, update_value}&lt;/code&gt; 或 &lt;code&gt;:pop&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8d3c9aaa3512be3173ee88a5acfdcc5972b212b6" translate="yes" xml:space="preserve">
          <source>The instructions below will serve if you are installing the latest stable version from Hex. To start using LiveView, add one of the following dependencies to your &lt;code&gt;mix.exs&lt;/code&gt; and run &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Deps.Get.html&quot;&gt;&lt;code&gt;mix deps.get&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果您要从Hex安装最新的稳定版本，则可以使用以下说明。要开始使用LiveView，请将以下依赖项之一添加到 &lt;code&gt;mix.exs&lt;/code&gt; 并运行&lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Deps.Get.html&quot;&gt; &lt;code&gt;mix deps.get&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e46bc2ee246632c28439adb8036c4ec274b15b36" translate="yes" xml:space="preserve">
          <source>The internal infrastructure LiveView uses to keep track of stateful components is very lightweight. However, be aware that in order to provide change tracking and to send diffs over the wire, all of the components assigns are kept in memory - exactly as it is done in LiveViews themselves.</source>
          <target state="translated">LiveView用于跟踪有状态组件的内部基础设施是非常轻量级的。然而,要注意的是,为了提供变化跟踪和通过线缆发送差异,所有的组件分配都保存在内存中--就像在LiveViews中一样。</target>
        </trans-unit>
        <trans-unit id="897fcb552f1ed96e5b37d174da2e32ad713e210e" translate="yes" xml:space="preserve">
          <source>The internal reference to the session in the store</source>
          <target state="translated">商店中对会话的内部引用</target>
        </trans-unit>
        <trans-unit id="2b0fb080dc23dfd38867594f47439c384bd3fe00" translate="yes" xml:space="preserve">
          <source>The internal reference to the session in the store.</source>
          <target state="translated">商店中对会话的内部引用。</target>
        </trans-unit>
        <trans-unit id="75c017e0096c8191807383c0ba159f9238866e0c" translate="yes" xml:space="preserve">
          <source>The issue is that we have no guarantees the channel has done processing our message after calling &lt;a href=&quot;#push/3&quot;&gt;&lt;code&gt;push/3&lt;/code&gt;&lt;/a&gt;. The best solution is to assert the channel sent us a reply before doing any other assertion. First change the channel to send replies:</source>
          <target state="translated">问题是我们不能保证通道在调用&lt;a href=&quot;#push/3&quot;&gt; &lt;code&gt;push/3&lt;/code&gt; &lt;/a&gt;之后已经完成了对消息的处理。最好的解决方案是在执行其他任何声明之前声明该通道向我们发送的答复。首先更改发送回复的渠道：</target>
        </trans-unit>
        <trans-unit id="bf259ab2dd0402461d9104f43dc12dcf9a9184fd" translate="yes" xml:space="preserve">
          <source>The key can be a string or an atom, where atoms are automatically converted to strings.</source>
          <target state="translated">键可以是字符串,也可以是原子,其中原子会自动转换为字符串。</target>
        </trans-unit>
        <trans-unit id="f429352c0b3be43a54afc592d7a8110f87f053dd" translate="yes" xml:space="preserve">
          <source>The key can be a string or an atom, where atoms are automatically converted to strings. Can only be invoked on unsent &lt;code&gt;conn&lt;/code&gt;s. Will raise otherwise.</source>
          <target state="translated">键可以是字符串或原子，其中原子会自动转换为字符串。只能在未发送的 &lt;code&gt;conn&lt;/code&gt; 上调用。否则会提出。</target>
        </trans-unit>
        <trans-unit id="b090269894ef022087b95988c4c1c9ea6c329869" translate="yes" xml:space="preserve">
          <source>The key is the media type, the value is a list of formats the media type can be identified with. For example, by using &quot;json-api&quot;, you will be able to use templates with extension &quot;index.json-api&quot; or to force a particular format in a given URL by sending &quot;?_format=json-api&quot;.</source>
          <target state="translated">键是媒体类型,值是媒体类型可以识别的格式列表。例如,通过使用 &quot;json-api&quot;,你将能够使用扩展名为 &quot;index.json-api &quot;的模板,或者通过发送&quot;?_format=json-api &quot;在给定的URL中强制使用特定格式。</target>
        </trans-unit>
        <trans-unit id="4edcd6a27ee607492b3ce414639ce14b3b1badad" translate="yes" xml:space="preserve">
          <source>The key is the media type, the value is a list of formats the media type can be identified with. For example, by using &amp;ldquo;json-api&amp;rdquo;, you will be able to use templates with extension &amp;ldquo;index.json-api&amp;rdquo; or to force a particular format in a given URL by sending &amp;ldquo;?_format=json-api&amp;rdquo;.</source>
          <target state="translated">关键是媒体类型，值是可以识别媒体类型的格式列表。例如，通过使用&amp;ldquo; json-api&amp;rdquo;，您将能够使用扩展名为&amp;ldquo; index.json-api&amp;rdquo;的模板，或者通过发送&amp;ldquo;？_format = json-api&amp;rdquo;在给定的URL中强制使用特定格式。</target>
        </trans-unit>
        <trans-unit id="dc9dd9b6fe649ecbe85232c591304bd2bcb8a124" translate="yes" xml:space="preserve">
          <source>The keys in the list are the names of fields, and the values are a validation associated with the field. A field may occur multiple times in the list.</source>
          <target state="translated">列表中的键是字段的名称,值是与字段相关联的验证。一个字段可以在列表中出现多次。</target>
        </trans-unit>
        <trans-unit id="44118a922e99586055ff7e96b077e2626d08844b" translate="yes" xml:space="preserve">
          <source>The keys of the map will usually point to a resource ID. The value will contain a map with a &lt;code&gt;:metas&lt;/code&gt; key containing a list of metadata for each resource. Additionally, every metadata entry will contain a &lt;code&gt;:phx_ref&lt;/code&gt; key which can be used to uniquely identify metadata for a given key. In the event that the metadata was previously updated, a &lt;code&gt;:phx_ref_prev&lt;/code&gt; key will be present containing the previous &lt;code&gt;:phx_ref&lt;/code&gt; value.</source>
          <target state="translated">映射的键通常将指向资源ID。该值将包含一个带有 &lt;code&gt;:metas&lt;/code&gt; 键的映射，该键包含每个资源的元数据列表。此外，每个元数据条目都将包含 &lt;code&gt;:phx_ref&lt;/code&gt; 密钥，该密钥可用于唯一标识给定密钥的元数据。如果元数据先前已更新，则将显示 &lt;code&gt;:phx_ref_prev&lt;/code&gt; 密钥，其中包含先前的 &lt;code&gt;:phx_ref&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="cd07e57985bded643428c1ca83408a9f2015bf8e" translate="yes" xml:space="preserve">
          <source>The keyword options passed from the Schema's field macro into &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">关键字选项从模式的字段宏传递到&lt;a href=&quot;#c:init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3f06d5aeae7960e61046c9013e3025c273538aad" translate="yes" xml:space="preserve">
          <source>The keyword-based and pipe-based examples are equivalent. The downside of using macros is that the binding must be specified for every operation. However, since keyword-based and pipe-based examples are equivalent, the bindingless syntax also works for macros:</source>
          <target state="translated">基于关键字和基于管道的例子是等价的。使用宏的缺点是必须为每个操作指定绑定。然而,由于基于关键字的例子和基于管道的例子是等价的,无绑定语法也适用于宏。</target>
        </trans-unit>
        <trans-unit id="df5c4e04515501f7830b4c4bb804a178cc83618c" translate="yes" xml:space="preserve">
          <source>The last change is to open up &lt;code&gt;lib/hello_phoenix/repo.ex&lt;/code&gt; and make sure to set the &lt;code&gt;:adapter&lt;/code&gt; to &lt;code&gt;Ecto.Adapters.MyXQL&lt;/code&gt;.</source>
          <target state="translated">最后的更改是打开 &lt;code&gt;lib/hello_phoenix/repo.ex&lt;/code&gt; 并确保将 &lt;code&gt;:adapter&lt;/code&gt; 设置为 &lt;code&gt;Ecto.Adapters.MyXQL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1d08d545f1b896c36da46b4bc90528258f9af83a" translate="yes" xml:space="preserve">
          <source>The last input with focus is restored (unless another input has received focus)</source>
          <target state="translated">恢复最后一个有焦点的输入(除非另一个输入得到了焦点)。</target>
        </trans-unit>
        <trans-unit id="1f0f79f452d7d90593329a433992b7a7e7313371" translate="yes" xml:space="preserve">
          <source>The latter could also be bound to any &lt;code&gt;click&lt;/code&gt; event, but this way you can be sure your custom code is only executed when the code of &lt;code&gt;phoenix_html.js&lt;/code&gt; is run.</source>
          <target state="translated">后者也可以绑定到任何 &lt;code&gt;click&lt;/code&gt; 事件，但是通过这种方式，您可以确保仅在运行 &lt;code&gt;phoenix_html.js&lt;/code&gt; 的代码时才执行自定义代码。</target>
        </trans-unit>
        <trans-unit id="94ea7e500eb238ec30986cee0999cc9f163d089b" translate="yes" xml:space="preserve">
          <source>The layout given to &lt;code&gt;put_root_layout&lt;/code&gt; must use &lt;code&gt;&amp;lt;%= @inner_content %&amp;gt;&lt;/code&gt; instead of &lt;code&gt;&amp;lt;%= render(@view_module, @view_template, assigns) %&amp;gt;&lt;/code&gt;. It is typically very barebones, with mostly &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; tags. For example:</source>
          <target state="translated">给 &lt;code&gt;put_root_layout&lt;/code&gt; 的布局必须使用 &lt;code&gt;&amp;lt;%= @inner_content %&amp;gt;&lt;/code&gt; 而不是 &lt;code&gt;&amp;lt;%= render(@view_module, @view_template, assigns) %&amp;gt;&lt;/code&gt; 。它通常是非常准系统，主要带有 &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; 标签。例如：</target>
        </trans-unit>
        <trans-unit id="6744e96e72ecda721afea0237536fd66db392297" translate="yes" xml:space="preserve">
          <source>The layout must be a tuple, specifying the layout view and the layout name, or false. In case a previous layout is set, &lt;code&gt;put_layout&lt;/code&gt; also accepts the layout name to be given as a string or as an atom. If a string, it must contain the format. Passing an atom means the layout format will be found at rendering time, similar to the template in &lt;a href=&quot;#render/3&quot;&gt;&lt;code&gt;render/3&lt;/code&gt;&lt;/a&gt;. It can also be set to &lt;code&gt;false&lt;/code&gt;. In this case, no layout would be used.</source>
          <target state="translated">布局必须是一个元组，指定布局视图和布局名称，或者为false。如果设置了先前的布局，则 &lt;code&gt;put_layout&lt;/code&gt; 还接受以字符串或原子形式给出的布局名称。如果是字符串，则必须包含格式。传递原子意味着将在渲染时找到布局格式，类似于&lt;a href=&quot;#render/3&quot;&gt; &lt;code&gt;render/3&lt;/code&gt; 中&lt;/a&gt;的模板。也可以将其设置为 &lt;code&gt;false&lt;/code&gt; 。在这种情况下，将不使用任何布局。</target>
        </trans-unit>
        <trans-unit id="e7d67a564b0265425038298d81b7c53608deaa1e" translate="yes" xml:space="preserve">
          <source>The lib/hello directory</source>
          <target state="translated">lib/hello目录</target>
        </trans-unit>
        <trans-unit id="c5d2fa78d75d59a854f8844b73dfc72a968b6f84" translate="yes" xml:space="preserve">
          <source>The lib/hello_web directory</source>
          <target state="translated">lib/hello_web目录</target>
        </trans-unit>
        <trans-unit id="92154a1db347f64239f68f87cebd039161ceecac" translate="yes" xml:space="preserve">
          <source>The life-cycle of a LiveView as outlined in the &lt;a href=&quot;phoenix.liveview&quot;&gt;&lt;code&gt;Phoenix.LiveView&lt;/code&gt;&lt;/a&gt; docs details how a view starts as a stateless HTML render in a disconnected socket state. Once the browser receives the HTML, it connects to the server and a new LiveView process is started, remounted in a connected socket state, and the view continues statefully. The LiveView test functions support testing both disconnected and connected mounts separately, for example:</source>
          <target state="translated">&lt;a href=&quot;phoenix.liveview&quot;&gt; &lt;code&gt;Phoenix.LiveView&lt;/code&gt; &lt;/a&gt;文档中概述了LiveView的生命周期，其中详细介绍了视图如何在断开的套接字状态下以无状态HTML呈现方式启动。一旦浏览器接收到HTML，它将连接到服务器并启动新的LiveView进程，并在连接的套接字状态下重新安装它，并且视图将有状态地继续。 LiveView测试功能支持分别测试断开和已连接的安装座，例如：</target>
        </trans-unit>
        <trans-unit id="477d068a247e238de404418e92a5a9b81e34e717" translate="yes" xml:space="preserve">
          <source>The list of dynamics is always a list of iodatas or components, as we don't perform change tracking inside the comprehensions themselves. Similarly, comprehensions do not have fingerprints because they are only optimized at the root, so conditional evaluation, as the one seen in rendering, is not possible. The only possible outcome for a dynamic field that returns a comprehension is &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">动态列表始终是iodata或组件的列表，因为我们不会在理解本身内部执行更改跟踪。同样，理解没有指纹，因为它们仅在根部进行了优化，因此无法进行条件评估（如在渲染中看到的那样）。对于返回理解力的动态字段，唯一可能的结果是 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="30777b456b3f6e3c3a181cabf70cf5ee328a6f81" translate="yes" xml:space="preserve">
          <source>The list of hostnames, if none are specified, defaults to:</source>
          <target state="translated">主机名列表,如果没有指定,默认为。</target>
        </trans-unit>
        <trans-unit id="9089ed404a90b7ca8405732095979a8fb2093289" translate="yes" xml:space="preserve">
          <source>The list of supported values and their behaviour is described in &lt;a href=&quot;#put_assoc/4&quot;&gt;&lt;code&gt;put_assoc/4&lt;/code&gt;&lt;/a&gt;. If the given value is not any of values listed there, it will raise.</source>
          <target state="translated">支持的值及其行为的列表在&lt;a href=&quot;#put_assoc/4&quot;&gt; &lt;code&gt;put_assoc/4&lt;/code&gt; 中进行了&lt;/a&gt;描述。如果给定值不是那里列出的任何值，它将提高。</target>
        </trans-unit>
        <trans-unit id="1bf6687a8673fe4a0d29060ff11510670a6cb046" translate="yes" xml:space="preserve">
          <source>The location of the web files (LiveView's, views, templates, etc) in an umbrella application will vary based on the &lt;code&gt;:context_app&lt;/code&gt; config located in your applications &lt;code&gt;:generators&lt;/code&gt; configuration. When set, the Phoenix generators will generate web files directly in your lib and test folders since the application is assumed to be isolated to web specific functionality. If &lt;code&gt;:context_app&lt;/code&gt; is not set, the generators will place web related lib and test files in a &lt;code&gt;web/&lt;/code&gt; directory since the application is assumed to be handling both web and domain specific functionality. Example configuration:</source>
          <target state="translated">伞式应用程序中Web文件（LiveView，视图，模板等）的位置将根据应用程序 &lt;code&gt;:generators&lt;/code&gt; 配置中的 &lt;code&gt;:context_app&lt;/code&gt; 配置而有所不同。设置后，Phoenix生成器将直接在您的lib和test文件夹中生成Web文件，因为假定该应用程序与Web特定功能无关。如果未设置 &lt;code&gt;:context_app&lt;/code&gt; ，则生成器会将与Web相关的lib和测试文件放在 &lt;code&gt;web/&lt;/code&gt; 目录中，因为假定该应用程序正在处理Web和特定于域的功能。配置示例：</target>
        </trans-unit>
        <trans-unit id="ba10fe778e8a0ac2bdeed5623f9f0c72f2e97b50" translate="yes" xml:space="preserve">
          <source>The location of the web files (controllers, views, templates, etc) in an umbrella application will vary based on the &lt;code&gt;:context_app&lt;/code&gt; config located in your applications &lt;code&gt;:generators&lt;/code&gt; configuration. When set, the Phoenix generators will generate web files directly in your lib and test folders since the application is assumed to be isolated to web specific functionality. If &lt;code&gt;:context_app&lt;/code&gt; is not set, the generators will place web related lib and test files in a &lt;code&gt;web/&lt;/code&gt; directory since the application is assumed to be handling both web and domain specific functionality. Example configuration:</source>
          <target state="translated">伞式应用程序中Web文件（控制器，视图，模板等）的位置将根据应用程序 &lt;code&gt;:generators&lt;/code&gt; 配置中的 &lt;code&gt;:context_app&lt;/code&gt; 配置而有所不同。设置后，Phoenix生成器将直接在您的lib和test文件夹中生成Web文件，因为假定该应用程序与Web特定功能无关。如果未设置 &lt;code&gt;:context_app&lt;/code&gt; ，则生成器会将与Web相关的lib和测试文件放在 &lt;code&gt;web/&lt;/code&gt; 目录中，因为假定该应用程序正在处理Web和特定于域的功能。配置示例：</target>
        </trans-unit>
        <trans-unit id="9838c2015d6a31f43230056050bd48b08264c2d5" translate="yes" xml:space="preserve">
          <source>The log line for each request contains the specific route for that request. This is due to specifying the &lt;code&gt;:tags&lt;/code&gt; option for the summary metric, which takes care of our first requirement; we can use &lt;code&gt;:tags&lt;/code&gt; to group metrics by route. Note that reporters will necessarily handle tags differently depending on the underlying service in use.</source>
          <target state="translated">每个请求的日志行都包含该请求的特定路由。这是由于为摘要指标指定了 &lt;code&gt;:tags&lt;/code&gt; 选项，它满足了我们的第一个要求；我们可以使用 &lt;code&gt;:tags&lt;/code&gt; 按路线对指标进行分组。请注意，根据所使用的基础服务，报告者必须对标记进行不同的处理。</target>
        </trans-unit>
        <trans-unit id="5054ea19f1c0872ef56ffb5ac8d9cbaa2ee98017" translate="yes" xml:space="preserve">
          <source>The logger call won&amp;rsquo;t be removed at compile time as custom level is given.</source>
          <target state="translated">记录器调用不会在编译时被删除，因为给出了自定义级别。</target>
        </trans-unit>
        <trans-unit id="282bfec61ed3e63c6a621589fc9ff184bc2a5dc3" translate="yes" xml:space="preserve">
          <source>The long poll is configurable in your socket:</source>
          <target state="translated">在你的socket中可以配置长轮询。</target>
        </trans-unit>
        <trans-unit id="df55f8f757b374fd6d2aa5a71db086c2cfcd7c1d" translate="yes" xml:space="preserve">
          <source>The main responsibility of a view is to render a template.</source>
          <target state="translated">视图的主要职责是渲染模板。</target>
        </trans-unit>
        <trans-unit id="c3ad4277ebaf63c095045d7d65ae5d290329b067" translate="yes" xml:space="preserve">
          <source>The map type</source>
          <target state="translated">地图类型</target>
        </trans-unit>
        <trans-unit id="fd10459a12af6703afd7079ef61598c3879b0473" translate="yes" xml:space="preserve">
          <source>The map type allows developers to store an Elixir map directly in the database:</source>
          <target state="translated">该地图类型允许开发人员直接在数据库中存储Elixir地图。</target>
        </trans-unit>
        <trans-unit id="080be8664031b1a1bb94955949d3616301947b14" translate="yes" xml:space="preserve">
          <source>The mechanism for passing the token to the client is typically through a cookie, a JSON response body, or HTTP header. For now, assume the client has received a token it can use to validate requests for protected resources.</source>
          <target state="translated">将令牌传递给客户端的机制通常是通过cookie、JSON响应体或HTTP头。现在,假设客户端已经收到了一个令牌,它可以用来验证对受保护资源的请求。</target>
        </trans-unit>
        <trans-unit id="eb58fc9777d3607a5fbb10fc1f79ea8d98ec0269" translate="yes" xml:space="preserve">
          <source>The message format requires the following keys:</source>
          <target state="translated">消息格式需要以下键。</target>
        </trans-unit>
        <trans-unit id="52f5b43827ed9d61c35f578531a7d764f7e53199" translate="yes" xml:space="preserve">
          <source>The message is a term. It must return one of:</source>
          <target state="translated">该消息是一个术语。它必须返回下列之一:</target>
        </trans-unit>
        <trans-unit id="b0b210dad451da94f2501a9d8d7e918aa3958400" translate="yes" xml:space="preserve">
          <source>The message is represented as &lt;code&gt;{payload, options}&lt;/code&gt;. It must return one of:</source>
          <target state="translated">该消息表示为 &lt;code&gt;{payload, options}&lt;/code&gt; 。它必须返回以下之一：</target>
        </trans-unit>
        <trans-unit id="8368bb195a36e75b24e3aa2abd88acdf1b5b819f" translate="yes" xml:space="preserve">
          <source>The metadata returned by the adapter &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">适配器&lt;a href=&quot;#c:init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt;返回的元数据</target>
        </trans-unit>
        <trans-unit id="7b2acf0c1be2b4d18996e01c7970b3c30cc534ab" translate="yes" xml:space="preserve">
          <source>The metadata returned by the adapter &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">适配器&lt;a href=&quot;#c:init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt;返回的元数据。</target>
        </trans-unit>
        <trans-unit id="70bfd62abd8739763f40ffef575496a5c549d630" translate="yes" xml:space="preserve">
          <source>The minimum value for &lt;code&gt;length&lt;/code&gt; is 32.</source>
          <target state="translated">&lt;code&gt;length&lt;/code&gt; 的最小值是32。</target>
        </trans-unit>
        <trans-unit id="9634db4fa76e01e90a42b4c5e5f87e4ad4910fd5" translate="yes" xml:space="preserve">
          <source>The name of each operation does not have to be an atom. This can be particularly useful when you wish to update a collection of changesets at once, and track their errors individually:</source>
          <target state="translated">每个操作的名称不一定是一个原子。当你希望一次更新一个变化集的集合,并单独跟踪它们的错误时,这可能特别有用。</target>
        </trans-unit>
        <trans-unit id="0a3d293ea6bec7e5c5b00485c524e67b073803fb" translate="yes" xml:space="preserve">
          <source>The name used in assigns is determined from the view. For example the &lt;code&gt;PageView&lt;/code&gt; will use &lt;code&gt;%{page: page}&lt;/code&gt; and the &lt;code&gt;AuthorView&lt;/code&gt; will use &lt;code&gt;%{author: author}&lt;/code&gt;. This can be overridden with the &lt;code&gt;as&lt;/code&gt; option. Let's assume that the author view uses &lt;code&gt;%{writer: writer}&lt;/code&gt; instead of &lt;code&gt;%{author: author}&lt;/code&gt;:</source>
          <target state="translated">分配中使用的名称由视图确定。例如， &lt;code&gt;PageView&lt;/code&gt; 将使用 &lt;code&gt;%{page: page}&lt;/code&gt; ，而 &lt;code&gt;AuthorView&lt;/code&gt; 将使用 &lt;code&gt;%{author: author}&lt;/code&gt; 。可以使用 &lt;code&gt;as&lt;/code&gt; 选项覆盖它。假设作者视图使用 &lt;code&gt;%{writer: writer}&lt;/code&gt; 而不是 &lt;code&gt;%{author: author}&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="8eacf623a28c1145f1b59317f4cbac89d904671a" translate="yes" xml:space="preserve">
          <source>The named helper can also be customized with the &lt;code&gt;:as&lt;/code&gt; option. Given the route:</source>
          <target state="translated">也可以使用 &lt;code&gt;:as&lt;/code&gt; 选项来自定义命名的帮助程序。给定路线：</target>
        </trans-unit>
        <trans-unit id="ee9f556bb40887ceb71d128fe3a1686d36cd09f5" translate="yes" xml:space="preserve">
          <source>The only argument is the module name of the Presence tracker, which defaults to Presence.</source>
          <target state="translated">唯一的参数是Presence跟踪器的模块名称,默认为Presence。</target>
        </trans-unit>
        <trans-unit id="dd6daf265bd0ac4e906fd4bdd897c5919c6282da" translate="yes" xml:space="preserve">
          <source>The only downside is that it will show up as a fragment when inspecting the Elixir query. Other than that, it should be equivalent to a built-in Ecto query function.</source>
          <target state="translated">唯一的缺点是,在检查Elixir查询时,会显示为一个片段。除此之外,它应该相当于一个内置的Ecto查询函数。</target>
        </trans-unit>
        <trans-unit id="4f0266dcf90fe67afe6ef36bb73cebc07fd00eac" translate="yes" xml:space="preserve">
          <source>The options are passed to both &lt;code&gt;:http&lt;/code&gt; and &lt;code&gt;:https&lt;/code&gt; keys in the endpoint configuration. However, once you pass your custom dispatch options, you will need to manually wire all Phoenix endpoints, including the socket transports.</source>
          <target state="translated">这些选项同时传递给端点配置中的 &lt;code&gt;:http&lt;/code&gt; 和 &lt;code&gt;:https&lt;/code&gt; 键。但是，一旦传递了自定义的调度选项，您将需要手动连接所有Phoenix端点，包括套接字传输。</target>
        </trans-unit>
        <trans-unit id="81006dc93621cf7c03e17d32fa7ba38ff44285bc" translate="yes" xml:space="preserve">
          <source>The options are passed to both &lt;code&gt;:http&lt;/code&gt; and &lt;code&gt;:https&lt;/code&gt; keys in the endpoint configuration. However, once you pass your custom dispatch options, you will need to manually wire the Phoenix endpoint by adding the following rule:</source>
          <target state="translated">这些选项将同时传递给端点配置中的 &lt;code&gt;:http&lt;/code&gt; 和 &lt;code&gt;:https&lt;/code&gt; 键。但是，一旦传递了自定义调度选项，您将需要通过添加以下规则来手动连接Phoenix端点：</target>
        </trans-unit>
        <trans-unit id="f34a63fc2945e1d41d9507823f6312b0d54d5e85" translate="yes" xml:space="preserve">
          <source>The options are the same options given to &lt;code&gt;form_for/4&lt;/code&gt;. It can be used by implementations to configure their behaviour and it must be stored in the underlying struct, with any custom field removed.</source>
          <target state="translated">这些选项与给 &lt;code&gt;form_for/4&lt;/code&gt; 的选项相同。实现可以使用它来配置其行为，并且必须将其存储在基础结构中，并删除所有自定义字段。</target>
        </trans-unit>
        <trans-unit id="e94a4b1ffacdefb101fda0c3d483575fb46108fe" translate="yes" xml:space="preserve">
          <source>The options are the same options given to &lt;code&gt;inputs_for/4&lt;/code&gt;. It can be used by implementations to configure their behaviour and it must be stored in the underlying struct, with any custom field removed.</source>
          <target state="translated">这些选项与为 &lt;code&gt;inputs_for/4&lt;/code&gt; 提供的选项相同。实现可以使用它来配置其行为，并且必须将其存储在基础结构中，并删除所有自定义字段。</target>
        </trans-unit>
        <trans-unit id="cbbc72dee649cfd3da9099e3aaa4dd8de76df598" translate="yes" xml:space="preserve">
          <source>The options returned from this function will be given to &lt;a href=&quot;#get/3&quot;&gt;&lt;code&gt;get/3&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#put/4&quot;&gt;&lt;code&gt;put/4&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#delete/3&quot;&gt;&lt;code&gt;delete/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">从此函数返回的选项将被赋予&lt;a href=&quot;#get/3&quot;&gt; &lt;code&gt;get/3&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#put/4&quot;&gt; &lt;code&gt;put/4&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#delete/3&quot;&gt; &lt;code&gt;delete/3&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d384613558e77407526f0c5fbfadcc4a059844a9" translate="yes" xml:space="preserve">
          <source>The options returned from this function will be given to &lt;code&gt;get/3&lt;/code&gt;, &lt;code&gt;put/4&lt;/code&gt; and &lt;code&gt;delete/3&lt;/code&gt;.</source>
          <target state="translated">从此函数返回的选项将被赋予 &lt;code&gt;get/3&lt;/code&gt; ， &lt;code&gt;put/4&lt;/code&gt; 和 &lt;code&gt;delete/3&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f06bf866fed12855453f8d5f135a5f4e72431100" translate="yes" xml:space="preserve">
          <source>The other fields are merged with the following criteria:</source>
          <target state="translated">其他字段与下列标准合并:</target>
        </trans-unit>
        <trans-unit id="3462b00b6bda12e1014b4b6dc443fa44ae87853c" translate="yes" xml:space="preserve">
          <source>The other validators simply take a value:</source>
          <target state="translated">其他验证器只是取一个值。</target>
        </trans-unit>
        <trans-unit id="161c387bc2cd3fea40fa9d1d48103ca6f80cdb4b" translate="yes" xml:space="preserve">
          <source>The output folder will contain:</source>
          <target state="translated">输出文件夹将包含:</target>
        </trans-unit>
        <trans-unit id="9dc286e9190cffa49c47ed0399b1d38337f37d16" translate="yes" xml:space="preserve">
          <source>The package does not perform any aggregation of the measurements itself. Instead, it provides a reporter with the Telemetry event-as-measurement definition and the reporter uses that definition to perform aggregations and report them.</source>
          <target state="translated">该软件包本身并不对测量结果进行任何汇总。相反,它向报告人提供遥测事件即测量的定义,报告人利用该定义进行汇总和报告。</target>
        </trans-unit>
        <trans-unit id="bd020c2783347fc6755fe582b2d5c9e69b5635df" translate="yes" xml:space="preserve">
          <source>The page we are going to build will simply say &quot;Hello World, from Phoenix!&quot; when we point our browser to &lt;a href=&quot;http://localhost:4000/hello&quot;&gt;http://localhost:4000/hello&lt;/a&gt;.</source>
          <target state="translated">我们将要建立的页面只会说&amp;ldquo;你好，凤凰城！&amp;rdquo; 当我们将浏览器指向&lt;a href=&quot;http://localhost:4000/hello&quot;&gt;http：// localhost：4000 / hello时&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7b7216cd22ee3c8f81da71805d223b6947bf81bf" translate="yes" xml:space="preserve">
          <source>The parameters for the ParameterizedType</source>
          <target state="translated">ParameterizedType的参数</target>
        </trans-unit>
        <trans-unit id="f4662009e29483d0cc5077d2eabc424cdf07a6d6" translate="yes" xml:space="preserve">
          <source>The parameters for the given association will be retrieved from &lt;code&gt;changeset.params&lt;/code&gt;. Those parameters are expected to be a map with attributes, similar to the ones passed to &lt;a href=&quot;#cast/4&quot;&gt;&lt;code&gt;cast/4&lt;/code&gt;&lt;/a&gt;. Once parameters are retrieved, &lt;a href=&quot;#cast_assoc/3&quot;&gt;&lt;code&gt;cast_assoc/3&lt;/code&gt;&lt;/a&gt; will match those parameters with the associations already in the changeset record.</source>
          <target state="translated">给定关联的参数将从 &lt;code&gt;changeset.params&lt;/code&gt; 检索。这些参数应该是具有属性的映射，类似于传递给&lt;a href=&quot;#cast/4&quot;&gt; &lt;code&gt;cast/4&lt;/code&gt; 的&lt;/a&gt;属性。一旦检索到参数，&lt;a href=&quot;#cast_assoc/3&quot;&gt; &lt;code&gt;cast_assoc/3&lt;/code&gt; &lt;/a&gt;会将那些参数与变更集记录中已存在的关联进行匹配。</target>
        </trans-unit>
        <trans-unit id="f162dc3980f9534481973a5e2f3a8df458b6c531" translate="yes" xml:space="preserve">
          <source>The parameters for the given embed will be retrieved from &lt;code&gt;changeset.params&lt;/code&gt;. Those parameters are expected to be a map with attributes, similar to the ones passed to &lt;a href=&quot;#cast/4&quot;&gt;&lt;code&gt;cast/4&lt;/code&gt;&lt;/a&gt;. Once parameters are retrieved, &lt;a href=&quot;#cast_embed/3&quot;&gt;&lt;code&gt;cast_embed/3&lt;/code&gt;&lt;/a&gt; will match those parameters with the embeds already in the changeset record. See &lt;a href=&quot;#cast_assoc/3&quot;&gt;&lt;code&gt;cast_assoc/3&lt;/code&gt;&lt;/a&gt; for an example of working with casts and associations which would also apply for embeds.</source>
          <target state="translated">给定嵌入的参数将从 &lt;code&gt;changeset.params&lt;/code&gt; 检索。这些参数应该是具有属性的映射，类似于传递给&lt;a href=&quot;#cast/4&quot;&gt; &lt;code&gt;cast/4&lt;/code&gt; 的&lt;/a&gt;属性。一旦检索到参数，&lt;a href=&quot;#cast_embed/3&quot;&gt; &lt;code&gt;cast_embed/3&lt;/code&gt; &lt;/a&gt;将使这些参数与更改集记录中已存在的嵌入进行匹配。有关使用强制类型转换和关联的示例（请参见&lt;a href=&quot;#cast_assoc/3&quot;&gt; &lt;code&gt;cast_assoc/3&lt;/code&gt; )&lt;/a&gt;，该示例也适用于嵌入。</target>
        </trans-unit>
        <trans-unit id="6ccf766b41fe567d6380527225e5d0d0c1950285" translate="yes" xml:space="preserve">
          <source>The path helpers now return what we want them to as well. Run &lt;code&gt;iex -S mix&lt;/code&gt; and give it a try yourself.</source>
          <target state="translated">现在，路径助手也返回了我们希望他们返回的对象。运行 &lt;code&gt;iex -S mix&lt;/code&gt; 并自己尝试。</target>
        </trans-unit>
        <trans-unit id="e6d9d95ae05eb4ab7374f78f148d8ced664f6b15" translate="yes" xml:space="preserve">
          <source>The path will be retrieved from the currently requested path via &lt;a href=&quot;#current_path/1&quot;&gt;&lt;code&gt;current_path/1&lt;/code&gt;&lt;/a&gt;. The scheme, host and others will be received from the URL configuration in your Phoenix endpoint. The reason we don't use the host and scheme information in the request is because most applications are behind proxies and the host and scheme may not actually reflect the host and scheme accessed by the client. If you want to access the url precisely as requested by the client, see &lt;a href=&quot;../plug/plug.conn#request_url/1&quot;&gt;&lt;code&gt;Plug.Conn.request_url/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该路径将通过&lt;a href=&quot;#current_path/1&quot;&gt; &lt;code&gt;current_path/1&lt;/code&gt; &lt;/a&gt;从当前请求的路径中检索。该方案，主机和其他内容将从Phoenix端点中的URL配置中接收到。我们之所以不在请求中使用主机和方案信息，是因为大多数应用程序都位于代理之后，并且主机和方案可能实际上未反映客户端访问的主机和方案。如果要完全按照客户端的要求访问该URL，请参见&lt;a href=&quot;../plug/plug.conn#request_url/1&quot;&gt; &lt;code&gt;Plug.Conn.request_url/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a51d7ff1518f2fc26effb50af9e146b994aed2db" translate="yes" xml:space="preserve">
          <source>The paths to the user facing reviews would look like a standard resource.</source>
          <target state="translated">面对用户的评论的路径会像一个标准资源。</target>
        </trans-unit>
        <trans-unit id="8461b08dd0b39472d6e7cab05d0df7c89d7a56a5" translate="yes" xml:space="preserve">
          <source>The plug specification.</source>
          <target state="translated">插头规格。</target>
        </trans-unit>
        <trans-unit id="43d162b21236b659adf8d5bf3af141f3266eea3d" translate="yes" xml:space="preserve">
          <source>The preferred form is to use &lt;code&gt;:from&lt;/code&gt; with an atom or tuple, since it will make your application independent from the starting directory. For example, if you pass:</source>
          <target state="translated">首选形式是将 &lt;code&gt;:from&lt;/code&gt; 与原子或元组一起使用，因为它将使您的应用程序独立于起始目录。例如，如果您通过：</target>
        </trans-unit>
        <trans-unit id="50998ebe5bad0757359a407f8ec8b122a3958b71" translate="yes" xml:space="preserve">
          <source>The prefixes set in the query will be preserved when loading data.</source>
          <target state="translated">在加载数据时,查询中设置的前缀将被保留。</target>
        </trans-unit>
        <trans-unit id="867bac9d8d8d9b0a2e78aebeddd2b3b36f5a8853" translate="yes" xml:space="preserve">
          <source>The prerequisites for running an HTTPS server with Plug include:</source>
          <target state="translated">使用Plug运行HTTPS服务器的前提条件包括:。</target>
        </trans-unit>
        <trans-unit id="1526ebdce848190098bcbfdfb625b2e2ecb877e8" translate="yes" xml:space="preserve">
          <source>The presence information is returned as a map with presences grouped by key, cast as a string, and accumulated metadata, with the following form:</source>
          <target state="translated">存在信息以地图的形式返回,地图上的存在按键分组,以字符串的形式投递,并累积元数据,其形式如下。</target>
        </trans-unit>
        <trans-unit id="8e1834c7ca0296001b89ac9864e746de523a9361" translate="yes" xml:space="preserve">
          <source>The primary key will be automatically included in &lt;code&gt;returning&lt;/code&gt; if the field has type &lt;code&gt;:id&lt;/code&gt; or &lt;code&gt;:binary_id&lt;/code&gt; and no value was set by the developer or none was autogenerated by the adapter.</source>
          <target state="translated">如果字段的类型为 &lt;code&gt;:id&lt;/code&gt; 或 &lt;code&gt;:binary_id&lt;/code&gt; 并且开发人员未设置任何值或适配器未自动生成任何值，则主键将自动包含在 &lt;code&gt;returning&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f2afcc11c269b0c54b1b7ac0efcd7b569f223f2f" translate="yes" xml:space="preserve">
          <source>The primitive types are:</source>
          <target state="translated">原始类型是:</target>
        </trans-unit>
        <trans-unit id="5475cd442271dc875207326bb4064eeb96befb25" translate="yes" xml:space="preserve">
          <source>The problem with this approach is that it breaks references in the database. You can&amp;rsquo;t use foreign keys and it is very inefficient, both in terms of query time and storage.</source>
          <target state="translated">这种方法的问题是它破坏了数据库中的引用。在查询时间和存储方面，您不能使用外键，并且效率很低。</target>
        </trans-unit>
        <trans-unit id="7a3a4c7f6a78c9326c8ef25ce0f6c69a3f78f0d2" translate="yes" xml:space="preserve">
          <source>The problem with this approach is that it breaks references in the database. You can't use foreign keys and it is very inefficient, both in terms of query time and storage.</source>
          <target state="translated">这种方法的问题是,它破坏了数据库中的引用。你不能使用外键,而且无论在查询时间还是存储方面,效率都很低。</target>
        </trans-unit>
        <trans-unit id="8d89d344e6a03d17bab84b370769a6045fb37ec3" translate="yes" xml:space="preserve">
          <source>The public fields are:</source>
          <target state="translated">公共领域是:</target>
        </trans-unit>
        <trans-unit id="df908dd7366c676a05daf0e41f416b8dbf39971e" translate="yes" xml:space="preserve">
          <source>The query above will select all posts with category &quot;fresh and new&quot;, order by the most recently published, and return Post structs with only the id, title and body fields set. It is equivalent to:</source>
          <target state="translated">上面的查询将选择所有类别为 &quot;新鲜的和新的 &quot;的帖子,按最近发布的帖子排序,并返回只设置了id、标题和正文字段的帖子结构。这相当于:</target>
        </trans-unit>
        <trans-unit id="eff2eebe90fad772cf88b9e84a74f0fcaf7b64c1" translate="yes" xml:space="preserve">
          <source>The query above will select all posts with category &amp;ldquo;fresh and new&amp;rdquo;, order by the most recently published, and return Post structs with only the id, title and body fields set. It is equivalent to:</source>
          <target state="translated">上面的查询将选择所有类别为&amp;ldquo;新的和新的&amp;rdquo;的帖子，按最新发布的顺序排序，并返回仅设置了id，title和body字段的Post结构。它等效于：</target>
        </trans-unit>
        <trans-unit id="95ca27e8b5eba197d23e18f17cf9ec5d46b73887" translate="yes" xml:space="preserve">
          <source>The query can be also rewritten as:</source>
          <target state="translated">该查询也可以改写为。</target>
        </trans-unit>
        <trans-unit id="e0868e0ab6d1da07933f0f38d5ca3b2c0b98ed62" translate="yes" xml:space="preserve">
          <source>The query given to preload may also preload its own associations.</source>
          <target state="translated">给予预加载的查询也可以预加载自己的关联。</target>
        </trans-unit>
        <trans-unit id="5f6733486c5b72fc457e7eabc6d95cf5b2c0075a" translate="yes" xml:space="preserve">
          <source>The query ordering will be automatically reversed, with ASC columns becoming DESC columns (and vice-versa) and limit is set to 1. If there is no ordering, the query will be automatically ordered decreasingly by primary key.</source>
          <target state="translated">查询顺序会自动颠倒,ASC列变成DESC列(反之亦然),limit设置为1,如果没有排序,查询会自动按主键递减排序。</target>
        </trans-unit>
        <trans-unit id="0bac158f3c93347932c98c42dee10fb98d800771" translate="yes" xml:space="preserve">
          <source>The query prefix may be set either for the whole query or on each individual &lt;code&gt;from&lt;/code&gt; and &lt;code&gt;join&lt;/code&gt; expression. If a &lt;code&gt;prefix&lt;/code&gt; is not given to a &lt;code&gt;from&lt;/code&gt; or a &lt;code&gt;join&lt;/code&gt;, the prefix of the schema given to the &lt;code&gt;from&lt;/code&gt; or &lt;code&gt;join&lt;/code&gt; is used. The query prefix is used only if none of the above are declared.</source>
          <target state="translated">可以为整个查询设置查询前缀，也可以为 &lt;code&gt;from&lt;/code&gt; 和 &lt;code&gt;join&lt;/code&gt; 表达式的每个查询设置查询前缀。如果 &lt;code&gt;prefix&lt;/code&gt; 不给一个 &lt;code&gt;from&lt;/code&gt; 或 &lt;code&gt;join&lt;/code&gt; ，架构的前缀给予 &lt;code&gt;from&lt;/code&gt; 或 &lt;code&gt;join&lt;/code&gt; 使用。仅当未声明上述任何条件时，才使用查询前缀。</target>
        </trans-unit>
        <trans-unit id="bbd403c978b262ae86cb591bfb4e43647aaa3204" translate="yes" xml:space="preserve">
          <source>The query will be automatically ordered by the primary key unless &lt;code&gt;order_by&lt;/code&gt; is given or &lt;code&gt;order_by&lt;/code&gt; is set in the query. Limit is always set to 1.</source>
          <target state="translated">查询将除非自动按主键有序 &lt;code&gt;order_by&lt;/code&gt; 给予或 &lt;code&gt;order_by&lt;/code&gt; 在查询中设置。限制始终设置为1。</target>
        </trans-unit>
        <trans-unit id="7f356a4a7c8aa772e039cd5fb20e41a523131c1b" translate="yes" xml:space="preserve">
          <source>The race conditions would make this an unreliable way to update the existing table since multiple callers may be updating out of date view values. There's a better way.</source>
          <target state="translated">竞赛条件会使这种更新现有表的方式不可靠,因为多个调用者可能会更新过时的视图值。有一个更好的方法。</target>
        </trans-unit>
        <trans-unit id="bae279db8cc5013382df2f8f7a465a8ec13291a8" translate="yes" xml:space="preserve">
          <source>The reason we can use &lt;code&gt;Routes.page_path&lt;/code&gt; instead of the full &lt;code&gt;HelloWeb.Router.Helpers.page_path&lt;/code&gt; name is because &lt;code&gt;HelloWeb.Router.Helpers&lt;/code&gt; is aliased as &lt;code&gt;Routes&lt;/code&gt; by default in the &lt;code&gt;view/0&lt;/code&gt; block defined inside &lt;code&gt;lib/hello_web.ex&lt;/code&gt;. This definition is made available to our templates through &lt;code&gt;use HelloWeb, :view&lt;/code&gt;.</source>
          <target state="translated">之所以可以使用 &lt;code&gt;Routes.page_path&lt;/code&gt; 而不是完整的 &lt;code&gt;HelloWeb.Router.Helpers.page_path&lt;/code&gt; 名称，是因为默认情况下，在 &lt;code&gt;lib/hello_web.ex&lt;/code&gt; 内定义的 &lt;code&gt;view/0&lt;/code&gt; 块中， &lt;code&gt;HelloWeb.Router.Helpers&lt;/code&gt; 被别名为 &lt;code&gt;Routes&lt;/code&gt; 。通过 &lt;code&gt;use HelloWeb, :view&lt;/code&gt; 可以将定义用于我们的模板。</target>
        </trans-unit>
        <trans-unit id="6cfdedb0bfaec211bb278c06c452d42b9de504d0" translate="yes" xml:space="preserve">
          <source>The reason why the example above is wrong is because &lt;a href=&quot;#put_assoc/4&quot;&gt;&lt;code&gt;put_assoc/4&lt;/code&gt;&lt;/a&gt; always works with the &lt;strong&gt;full data&lt;/strong&gt;. So the example above will effectively &lt;strong&gt;erase all previous comments&lt;/strong&gt; and only keep the comment you are currently adding. Instead, you could try:</source>
          <target state="translated">上面的示例错误的原因是因为&lt;a href=&quot;#put_assoc/4&quot;&gt; &lt;code&gt;put_assoc/4&lt;/code&gt; &lt;/a&gt;始终对&lt;strong&gt;完整数据&lt;/strong&gt;起作用。因此，上面的示例将有效&lt;strong&gt;删除所有先前的注释，&lt;/strong&gt;并仅保留您当前添加的注释。相反，您可以尝试：</target>
        </trans-unit>
        <trans-unit id="87305add73fb47f8d721c5faef9fcb8523b1a68e" translate="yes" xml:space="preserve">
          <source>The remaining functions in this module, such as validations, constraints, association handling, are about manipulating changesets. Let&amp;rsquo;s discuss some of this extra functionality.</source>
          <target state="translated">该模块中的其余功能（如验证，约束，关联处理）与操纵变更集有关。让我们讨论一些额外的功能。</target>
        </trans-unit>
        <trans-unit id="2a63cf0d6104e4fb432f90b5c23167e7813b2aa2" translate="yes" xml:space="preserve">
          <source>The remaining functions in this module, such as validations, constraints, association handling, are about manipulating changesets. Let's discuss some of this extra functionality.</source>
          <target state="translated">这个模块中剩下的功能,比如验证、约束、关联处理,都是关于操作变化集的。我们来讨论一下这些额外的功能。</target>
        </trans-unit>
        <trans-unit id="8a0133540c725182eeb9cebba83044fb36adb332" translate="yes" xml:space="preserve">
          <source>The repositories to create are the ones specified under the &lt;code&gt;:ecto_repos&lt;/code&gt; option in the current app configuration. However, if the &lt;code&gt;-r&lt;/code&gt; option is given, it replaces the &lt;code&gt;:ecto_repos&lt;/code&gt; config.</source>
          <target state="translated">要创建的存储库是在当前应用程序配置的 &lt;code&gt;:ecto_repos&lt;/code&gt; 选项下指定的存储库。但是，如果给出 &lt;code&gt;-r&lt;/code&gt; 选项，它将替换 &lt;code&gt;:ecto_repos&lt;/code&gt; 配置。</target>
        </trans-unit>
        <trans-unit id="40dd881afbf4316e3498baa3ef462026d3e04aaa" translate="yes" xml:space="preserve">
          <source>The repositories to drop are the ones specified under the &lt;code&gt;:ecto_repos&lt;/code&gt; option in the current app configuration. However, if the &lt;code&gt;-r&lt;/code&gt; option is given, it replaces the &lt;code&gt;:ecto_repos&lt;/code&gt; config.</source>
          <target state="translated">要删除的存储库是当前应用程序配置中 &lt;code&gt;:ecto_repos&lt;/code&gt; 选项下指定的存储库。但是，如果给出 &lt;code&gt;-r&lt;/code&gt; 选项，它将替换 &lt;code&gt;:ecto_repos&lt;/code&gt; 配置。</target>
        </trans-unit>
        <trans-unit id="01f05ddc7ae85e61bdf357b4f9fe87ebe2fb186e" translate="yes" xml:space="preserve">
          <source>The repository will be placed in the &lt;code&gt;lib&lt;/code&gt; directory.</source>
          <target state="translated">该存储库将放置在 &lt;code&gt;lib&lt;/code&gt; 目录中。</target>
        </trans-unit>
        <trans-unit id="fed09d1158b42d77503d7a48e9346028a907f505" translate="yes" xml:space="preserve">
          <source>The request &lt;code&gt;method&lt;/code&gt; and &lt;code&gt;path&lt;/code&gt; are required arguments. &lt;code&gt;method&lt;/code&gt; may be any value that implements &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#to_string/1&quot;&gt;&lt;code&gt;to_string/1&lt;/code&gt;&lt;/a&gt; and it will properly converted and normalized (e.g., &lt;code&gt;:get&lt;/code&gt; or &lt;code&gt;&quot;post&quot;&lt;/code&gt;).</source>
          <target state="translated">请求 &lt;code&gt;method&lt;/code&gt; 和 &lt;code&gt;path&lt;/code&gt; 是必填参数。 &lt;code&gt;method&lt;/code&gt; 可以是实现&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#to_string/1&quot;&gt; &lt;code&gt;to_string/1&lt;/code&gt; 的&lt;/a&gt;任何值，并且可以正确转换和规范化（例如 &lt;code&gt;:get&lt;/code&gt; 或 &lt;code&gt;&quot;post&quot;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="e6553aee7958eb204e762483dc8ab5a0161d11fe" translate="yes" xml:space="preserve">
          <source>The request id is added to the Logger metadata as &lt;code&gt;:request_id&lt;/code&gt; and the response as the &quot;x-request-id&quot; HTTP header. To see the request id in your log output, configure your logger backends to include the &lt;code&gt;:request_id&lt;/code&gt; metadata:</source>
          <target state="translated">请求ID作为 &lt;code&gt;:request_id&lt;/code&gt; 添加到Logger元数据，响应作为&amp;ldquo; x-request-id&amp;rdquo; HTTP标头添加。要在日志输出中查看请求ID，请将记录器后端配置为包括 &lt;code&gt;:request_id&lt;/code&gt; 元数据：</target>
        </trans-unit>
        <trans-unit id="2c5f074e9b5c412ad29dd19562310620770be9f5" translate="yes" xml:space="preserve">
          <source>The request id is added to the Logger metadata as &lt;code&gt;:request_id&lt;/code&gt; and the response as the &amp;ldquo;x-request-id&amp;rdquo; HTTP header. To see the request id in your log output, configure your logger backends to include the &lt;code&gt;:request_id&lt;/code&gt; metadata:</source>
          <target state="translated">请求ID作为 &lt;code&gt;:request_id&lt;/code&gt; 添加到Logger元数据，响应作为&amp;ldquo; x-request-id&amp;rdquo; HTTP标头添加。要在日志输出中查看请求ID，请将记录器后端配置为包括 &lt;code&gt;:request_id&lt;/code&gt; 元数据：</target>
        </trans-unit>
        <trans-unit id="bb1a8693dbf7be806d104c7fe770e40145397d5f" translate="yes" xml:space="preserve">
          <source>The request information in these fields is not populated until it is fetched using the associated &lt;code&gt;fetch_&lt;/code&gt; function. For example, the &lt;code&gt;cookies&lt;/code&gt; field uses &lt;a href=&quot;#fetch_cookies/2&quot;&gt;&lt;code&gt;fetch_cookies/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">直到使用关联的 &lt;code&gt;fetch_&lt;/code&gt; 函数将其提取后，才会填充这些字段中的请求信息。例如， &lt;code&gt;cookies&lt;/code&gt; 字段使用&lt;a href=&quot;#fetch_cookies/2&quot;&gt; &lt;code&gt;fetch_cookies/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="42d5b6701eebdfc545f5a296c3ed4d4a66bb5d50" translate="yes" xml:space="preserve">
          <source>The request will not be processed due to a client error.</source>
          <target state="translated">由于客户端错误,该请求将不会被处理。</target>
        </trans-unit>
        <trans-unit id="4ca366dc222472a65071107117c79a6d7bda94b4" translate="yes" xml:space="preserve">
          <source>The resource fields are given using &lt;code&gt;name:type&lt;/code&gt; syntax where type are the types supported by Ecto. Omitting the type makes it default to &lt;code&gt;:string&lt;/code&gt;:</source>
          <target state="translated">资源字段使用 &lt;code&gt;name:type&lt;/code&gt; 语法给出，其中type是Ecto支持的类型。省略类型使其默认为 &lt;code&gt;:string&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="1097b0ddcaad963de9fecf51f90f2b6fa20570d6" translate="yes" xml:space="preserve">
          <source>The response will be sent with the status code defined within the connection, via &lt;a href=&quot;../plug/plug.conn#put_status/2&quot;&gt;&lt;code&gt;Plug.Conn.put_status/2&lt;/code&gt;&lt;/a&gt;. If no status code is set, a 302 response is sent.</source>
          <target state="translated">将通过&lt;a href=&quot;../plug/plug.conn#put_status/2&quot;&gt; &lt;code&gt;Plug.Conn.put_status/2&lt;/code&gt; &lt;/a&gt;将连接中定义的状态代码发送给响应。如果未设置状态码，则发送302响应。</target>
        </trans-unit>
        <trans-unit id="cde9dc4c4422fde222d1887d84b0d0b8e0065c5e" translate="yes" xml:space="preserve">
          <source>The result returned by &lt;code&gt;init/1&lt;/code&gt; is passed as second argument to &lt;code&gt;call/2&lt;/code&gt;. Note that &lt;code&gt;init/1&lt;/code&gt; may be called during compilation and as such it must not return pids, ports or values that are not specific to the runtime.</source>
          <target state="translated">由 &lt;code&gt;init/1&lt;/code&gt; 返回的结果作为第二个参数传递给 &lt;code&gt;call/2&lt;/code&gt; 。请注意， &lt;code&gt;init/1&lt;/code&gt; 可能在编译期间被调用，因此它不得返回非特定于运行时的pid，端口或值。</target>
        </trans-unit>
        <trans-unit id="c468a501cc213c281f4ebc6e80d77300fb92019e" translate="yes" xml:space="preserve">
          <source>The return value of each &amp;ldquo;before&amp;rdquo; event callback will be stored and passed to the corresponding &amp;ldquo;after&amp;rdquo; callback.</source>
          <target state="translated">每个&amp;ldquo;之前&amp;rdquo;事件回调的返回值将被存储并传递给相应的&amp;ldquo;之后&amp;rdquo;回调。</target>
        </trans-unit>
        <trans-unit id="bdebdedcaeb020e5415f8353d03e0b77bd7af755" translate="yes" xml:space="preserve">
          <source>The returned result is given to &lt;code&gt;execute/6&lt;/code&gt;.</source>
          <target state="translated">返回的结果被赋予 &lt;code&gt;execute/6&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aa37f4a12198ad1c63cc6b2c6592271817c66fee" translate="yes" xml:space="preserve">
          <source>The right side may either be a list, a literal list or even a column in the database with array type:</source>
          <target state="translated">右侧可以是一个列表,也可以是一个文字列表,甚至可以是数据库中一个数组类型的列。</target>
        </trans-unit>
        <trans-unit id="43a954d2682fa1c3ad1f60f5e9a5ca9d5b1fd15f" translate="yes" xml:space="preserve">
          <source>The route above tells us that any HTTP GET request for the root of the application will be handled by the &lt;code&gt;index&lt;/code&gt; action of the &lt;code&gt;HelloWeb.PageController&lt;/code&gt;.</source>
          <target state="translated">上面的路由告诉我们，对应用程序根目录的任何HTTP GET请求都将由 &lt;code&gt;HelloWeb.PageController&lt;/code&gt; 的 &lt;code&gt;index&lt;/code&gt; 操作处理。</target>
        </trans-unit>
        <trans-unit id="152177e9ac83ea80f027842928a7dd7f74f8ab54" translate="yes" xml:space="preserve">
          <source>The route above will dispatch to &lt;code&gt;MyApp.PageController&lt;/code&gt;. This syntax is not only convenient for developers, since we don&amp;rsquo;t have to repeat the &lt;code&gt;MyApp.&lt;/code&gt; prefix on all routes, but it also allows Phoenix to put less pressure in the Elixir compiler. If instead we had written:</source>
          <target state="translated">上面的路由将分派到 &lt;code&gt;MyApp.PageController&lt;/code&gt; 。此语法不仅对开发人员方便，因为我们不必重复 &lt;code&gt;MyApp.&lt;/code&gt; 在所有路由上添加前缀，但它也可以使Phoenix减轻Elixir编译器的压力。相反，如果我们写过：</target>
        </trans-unit>
        <trans-unit id="65e16ececbb9266a02583f54b94cf09861ee56a7" translate="yes" xml:space="preserve">
          <source>The route above will dispatch to &lt;code&gt;MyAppWeb.PageController&lt;/code&gt;. This syntax is not only convenient for developers, since we don't have to repeat the &lt;code&gt;MyAppWeb.&lt;/code&gt; prefix on all routes, but it also allows Phoenix to put less pressure on the Elixir compiler. If instead we had written:</source>
          <target state="translated">上面的路由将分派到 &lt;code&gt;MyAppWeb.PageController&lt;/code&gt; 。此语法不仅对开发人员方便，因为我们不必重复 &lt;code&gt;MyAppWeb.&lt;/code&gt; 在所有路径上添加前缀，但也可以使Phoenix减轻Elixir编译器的压力。相反，如果我们写过：</target>
        </trans-unit>
        <trans-unit id="49ffcfff6909dca94a4eae307d1f02ebefe5118b" translate="yes" xml:space="preserve">
          <source>The route can dispatch either to a function body or a Plug module.</source>
          <target state="translated">途径既可以派遣到函数体,也可以派遣到Plug模块。</target>
        </trans-unit>
        <trans-unit id="a585daba1ebd3d0d2a8f8b5826e4a49abe384c1d" translate="yes" xml:space="preserve">
          <source>The route for our &quot;Welcome to Phoenix!&quot; page from the previous Up And Running Guide looks like this.</source>
          <target state="translated">我们之前的《起跑指南》中的 &quot;欢迎来到凤凰!&quot;页面的路线是这样的。</target>
        </trans-unit>
        <trans-unit id="2939bacf3d39ca96536e1c8b322db4114aa2c1fe" translate="yes" xml:space="preserve">
          <source>The route:</source>
          <target state="translated">这条路线。</target>
        </trans-unit>
        <trans-unit id="b92d4396a601bd78f5174bee334d0b156a731866" translate="yes" xml:space="preserve">
          <source>The router emits the following telemetry events:</source>
          <target state="translated">路由器发出以下遥测事件。</target>
        </trans-unit>
        <trans-unit id="1d645c8dddca0a4767932b2d077924d41ae564a8" translate="yes" xml:space="preserve">
          <source>The router file that Phoenix generates, &lt;code&gt;lib/hello_web/router.ex&lt;/code&gt;, will look something like this one:</source>
          <target state="translated">Phoenix生成的路由器文件 &lt;code&gt;lib/hello_web/router.ex&lt;/code&gt; 如下所示：</target>
        </trans-unit>
        <trans-unit id="924f6def1ecc58fdee836524dd685a1ca8eb41c0" translate="yes" xml:space="preserve">
          <source>The router invokes a pipeline on a route defined within a scope. Routes outside of a scope have no pipelines. Although the use of nested scopes is discouraged (see above), if we call &lt;code&gt;pipe_through&lt;/code&gt; within a nested scope, the router will invoke all &lt;code&gt;pipe_through&lt;/code&gt;'s from parent scopes, followed by the nested one.</source>
          <target state="translated">路由器在范围内定义的路由上调用管道。范围之外的路由没有管道。尽管不鼓励使用嵌套作用域（请参见上文），但如果我们在嵌套作用域内调用 &lt;code&gt;pipe_through&lt;/code&gt; ，则路由器将调用父作用域中的所有 &lt;code&gt;pipe_through&lt;/code&gt; ，然后调用嵌套作用域。</target>
        </trans-unit>
        <trans-unit id="5e68c3ae1fbcab887151d89b16d2cba345f34fa8" translate="yes" xml:space="preserve">
          <source>The router is itself a plug, which means it can be invoked as:</source>
          <target state="translated">路由器本身就是一个插件,这意味着它可以被调用为。</target>
        </trans-unit>
        <trans-unit id="7cf405b6509f92f8990929f4ff6aee358761fa42" translate="yes" xml:space="preserve">
          <source>The router maps unique HTTP verb/path pairs to controller/action pairs which will handle them. Controllers in Phoenix are simply Elixir modules. Actions are functions that are defined within these controllers.</source>
          <target state="translated">路由器将唯一的HTTP动词/路径对映射到将处理它们的控制器/动作对。Phoenix中的控制器是简单的Elixir模块。Actions是在这些控制器中定义的功能。</target>
        </trans-unit>
        <trans-unit id="a54219a575937cd1ecc7766ae2a1627937d5863d" translate="yes" xml:space="preserve">
          <source>The router provides a set of macros for generating routes that dispatch to specific controllers and actions. Those macros are named after HTTP verbs. For example:</source>
          <target state="translated">路由器提供了一组宏,用于生成派发到特定控制器和动作的路由。这些宏以HTTP动词命名。例如</target>
        </trans-unit>
        <trans-unit id="e873990af1b506d9425de23745c1354e6b8b3c7a" translate="yes" xml:space="preserve">
          <source>The router supports other macros besides those for HTTP verbs like &lt;code&gt;get&lt;/code&gt;, &lt;code&gt;post&lt;/code&gt;, and &lt;code&gt;put&lt;/code&gt;. The most important among them is &lt;code&gt;resources&lt;/code&gt;. Let's add a resource to our &lt;code&gt;lib/hello_web/router.ex&lt;/code&gt; file like this:</source>
          <target state="translated">除了用于HTTP动词的那些宏（如 &lt;code&gt;get&lt;/code&gt; ， &lt;code&gt;post&lt;/code&gt; 和 &lt;code&gt;put&lt;/code&gt; )之外，该路由器还支持其他宏。其中最重要的是 &lt;code&gt;resources&lt;/code&gt; 。让我们将资源添加到我们的 &lt;code&gt;lib/hello_web/router.ex&lt;/code&gt; 文件中，如下所示：</target>
        </trans-unit>
        <trans-unit id="49855ec648da9ffc07970ba4da5777bc9db4c4b3" translate="yes" xml:space="preserve">
          <source>The same event callback is called again, this time with the atom &lt;code&gt;:stop&lt;/code&gt; as the first argument; see the &amp;ldquo;After clause&amp;rdquo; section below.</source>
          <target state="translated">再次调用相同的事件回调，这次使用原子 &lt;code&gt;:stop&lt;/code&gt; 作为第一个参数；请参阅下面的&amp;ldquo; After子句&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="65de666ef1e1e220f9c0d9372a51d104406e67a1" translate="yes" xml:space="preserve">
          <source>The schema also allows us to interact with a repository:</source>
          <target state="translated">该模式还允许我们与存储库进行交互。</target>
        </trans-unit>
        <trans-unit id="dc68d1c060a62f551303cd6da271796006c2c527" translate="yes" xml:space="preserve">
          <source>The schema can be of any value. The path represents the database name while options are simply merged in.</source>
          <target state="translated">模式可以是任何值。路径代表数据库名称,而选项只是简单地合并进去。</target>
        </trans-unit>
        <trans-unit id="f4534f8ae409e6a396fbbf9dca42834fd3a4a272" translate="yes" xml:space="preserve">
          <source>The schema is responsible for mapping the database fields into an Elixir struct.</source>
          <target state="translated">模式负责将数据库字段映射到Elixir结构中。</target>
        </trans-unit>
        <trans-unit id="f2c63087f504426ce8dc15eb5b941125dcbaa4ed" translate="yes" xml:space="preserve">
          <source>The schema is responsible for mapping the database fields into an Elixir struct. It is followed by an optional list of attributes, with their respective names and types. See &lt;a href=&quot;mix.tasks.phx.gen.schema&quot;&gt;&lt;code&gt;mix phx.gen.schema&lt;/code&gt;&lt;/a&gt; for more information on attributes.</source>
          <target state="translated">该模式负责将数据库字段映射到Elixir结构中。它后面是可选的属性列表，以及它们各自的名称和类型。有关属性的更多信息，请参见&lt;a href=&quot;mix.tasks.phx.gen.schema&quot;&gt; &lt;code&gt;mix phx.gen.schema&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e857c9bd7068c28cafcac14000408ae312ea8b02" translate="yes" xml:space="preserve">
          <source>The schema module can be defined inline in the parent schema in simple cases:</source>
          <target state="translated">在简单的情况下,模式模块可以在父模式中内联定义。</target>
        </trans-unit>
        <trans-unit id="35b62780b2378828f2f7ab21b8fde93c07ed6f06" translate="yes" xml:space="preserve">
          <source>The second and third argument that each event callback takes depends on the callback being an &amp;ldquo;after&amp;rdquo; or a &amp;ldquo;before&amp;rdquo; callback i.e. it depends on the value of the first argument, &lt;code&gt;:start&lt;/code&gt; or &lt;code&gt;:stop&lt;/code&gt;. For this reason, most of the time you will want to define (at least) two separate clauses for each event callback, one for the &amp;ldquo;before&amp;rdquo; and one for the &amp;ldquo;after&amp;rdquo; callbacks.</source>
          <target state="translated">每个事件回调采用的第二个和第三个参数取决于该回调是&amp;ldquo;之后&amp;rdquo;还是&amp;ldquo;之前&amp;rdquo;回调，即它取决于第一个参数 &lt;code&gt;:start&lt;/code&gt; 或 &lt;code&gt;:stop&lt;/code&gt; 的值。因此，大多数情况下，您将希望为每个事件回调定义（至少）两个单独的子句，一个为&amp;ldquo; before&amp;rdquo;回调，一个为&amp;ldquo; after&amp;rdquo;回调。</target>
        </trans-unit>
        <trans-unit id="8e57d6963dd7d705a901c4d4e7c1eb9745bf3c6f" translate="yes" xml:space="preserve">
          <source>The second argument &lt;code&gt;data&lt;/code&gt; specifies fields and values that are to be loaded. It can be a map, a keyword list, or a &lt;code&gt;{fields, values}&lt;/code&gt; tuple. Fields can be atoms or strings.</source>
          <target state="translated">第二个自变量 &lt;code&gt;data&lt;/code&gt; 指定要加载的字段和值。它可以是地图，关键字列表或 &lt;code&gt;{fields, values}&lt;/code&gt; 元组。字段可以是原子或字符串。</target>
        </trans-unit>
        <trans-unit id="8bdda78bcfbc0f79c0c506943ef025fc56fbcad4" translate="yes" xml:space="preserve">
          <source>The second argument is a &lt;a href=&quot;https://en.wikipedia.org/wiki/Salt_(cryptography)&quot;&gt;cryptographic salt&lt;/a&gt; which must be the same in both calls to &lt;a href=&quot;#sign/4&quot;&gt;&lt;code&gt;sign/4&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#verify/4&quot;&gt;&lt;code&gt;verify/4&lt;/code&gt;&lt;/a&gt;. For instance, it may be called &quot;user auth&quot; and treated as namespace when generating a token that will be used to authenticate users on channels or on your APIs.</source>
          <target state="translated">第二个参数是&lt;a href=&quot;https://en.wikipedia.org/wiki/Salt_(cryptography)&quot;&gt;加密盐&lt;/a&gt;，在对&lt;a href=&quot;#sign/4&quot;&gt; &lt;code&gt;sign/4&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#verify/4&quot;&gt; &lt;code&gt;verify/4&lt;/code&gt; 的&lt;/a&gt;两次调用中必须相同。例如，在生成用于对通道或API上的用户进行身份验证的令牌时，它可以称为&amp;ldquo;用户身份验证&amp;rdquo;，并被视为命名空间。</target>
        </trans-unit>
        <trans-unit id="8bbd999bbec42a3e7fb283772187deec6149dcdd" translate="yes" xml:space="preserve">
          <source>The second argument is a &lt;a href=&quot;https://en.wikipedia.org/wiki/Salt_(cryptography)&quot;&gt;cryptographic salt&lt;/a&gt; which must be the same in both calls to &lt;a href=&quot;#sign/4&quot;&gt;&lt;code&gt;sign/4&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#verify/4&quot;&gt;&lt;code&gt;verify/4&lt;/code&gt;&lt;/a&gt;. For instance, it may be called &amp;ldquo;user auth&amp;rdquo; when generating a token that will be used to authenticate users on channels or on your APIs.</source>
          <target state="translated">第二个参数是&lt;a href=&quot;https://en.wikipedia.org/wiki/Salt_(cryptography)&quot;&gt;加密盐&lt;/a&gt;，在对&lt;a href=&quot;#sign/4&quot;&gt; &lt;code&gt;sign/4&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#verify/4&quot;&gt; &lt;code&gt;verify/4&lt;/code&gt; 的&lt;/a&gt;两次调用中必须相同。例如，在生成用于对通道或API上的用户进行身份验证的令牌时，它可以称为&amp;ldquo;用户身份验证&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="0127918dc247714fd5e025d35570e68dd2593e39" translate="yes" xml:space="preserve">
          <source>The second argument is the repository configuration as stored in the application environment. It must return &lt;code&gt;{:ok, keyword}&lt;/code&gt; with the updated list of configuration or &lt;code&gt;:ignore&lt;/code&gt; (only in the &lt;code&gt;:supervisor&lt;/code&gt; case).</source>
          <target state="translated">第二个参数是存储在应用程序环境中的存储库配置。它必须返回 &lt;code&gt;{:ok, keyword}&lt;/code&gt; 以及更新的配置列表或 &lt;code&gt;:ignore&lt;/code&gt; （仅在 &lt;code&gt;:supervisor&lt;/code&gt; 情况下）。</target>
        </trans-unit>
        <trans-unit id="8ca2c1c0ef1b8f7a6c12e80c16925947b70511e2" translate="yes" xml:space="preserve">
          <source>The second argument must be &lt;code&gt;{:binary, contents}&lt;/code&gt;, where &lt;code&gt;contents&lt;/code&gt; will be sent as download, or&lt;code&gt;{:file, path}&lt;/code&gt;, where &lt;code&gt;path&lt;/code&gt; is the filesystem location of the file to be sent. Be careful to not interpolate the path from external parameters, as it could allow traversal of the filesystem.</source>
          <target state="translated">第二个参数必须是 &lt;code&gt;{:binary, contents}&lt;/code&gt; ，其中 &lt;code&gt;contents&lt;/code&gt; 将作为下载发送，或者是 &lt;code&gt;{:file, path}&lt;/code&gt; ，其中 &lt;code&gt;path&lt;/code&gt; 是要发送的文件的文件系统位置。注意不要从外部参数插入路径，因为它可能允许遍历文件系统。</target>
        </trans-unit>
        <trans-unit id="4644893fe8ba1bf1c5d0e81a9d6a3f7226fe628b" translate="yes" xml:space="preserve">
          <source>The second parameter is &lt;code&gt;params&lt;/code&gt;. Not surprisingly, this is a map which holds any parameters passed along in the HTTP request. It is a good practice to pattern match against params in the function signature to provide data in a simple package we can pass on to rendering. We saw this in the &lt;a href=&quot;request_lifecycle&quot;&gt;Request life-cycle guide&lt;/a&gt; when we added a messenger parameter to our &lt;code&gt;show&lt;/code&gt; route in &lt;code&gt;lib/hello_web/controllers/hello_controller.ex&lt;/code&gt;.</source>
          <target state="translated">第二个参数是 &lt;code&gt;params&lt;/code&gt; 。毫不奇怪，这是一个映射，其中包含HTTP请求中传递的所有参数。在功能签名中对参数进行模式匹配是一种很好的做法，以便在我们可以传递给渲染的简单包中提供数据。我们在 &lt;code&gt;lib/hello_web/controllers/hello_controller.ex&lt;/code&gt; 中的 &lt;code&gt;show&lt;/code&gt; 路由中添加了一个Messenger参数，从而在&amp;ldquo;&lt;a href=&quot;request_lifecycle&quot;&gt;请求生命周期&amp;rdquo;指南中&lt;/a&gt;看到了这一点。</target>
        </trans-unit>
        <trans-unit id="7f2d03f9984f042abc33381531414bedeec9588a" translate="yes" xml:space="preserve">
          <source>The serializer &lt;code&gt;decode!&lt;/code&gt; function must return a &lt;a href=&quot;phoenix.socket.message&quot;&gt;&lt;code&gt;Phoenix.Socket.Message&lt;/code&gt;&lt;/a&gt; which is forwarded to channels except:</source>
          <target state="translated">串行器 &lt;code&gt;decode!&lt;/code&gt; 函数必须返回&lt;a href=&quot;phoenix.socket.message&quot;&gt; &lt;code&gt;Phoenix.Socket.Message&lt;/code&gt; &lt;/a&gt;，该消息将转发到以下通道，但以下情况除外：</target>
        </trans-unit>
        <trans-unit id="d1d3f623b2642c248a3d2a66503afa329aff8fe9" translate="yes" xml:space="preserve">
          <source>The server may send messages or replies back. For messages, the ref uniquely identifies the message. For replies, the ref matches the original message. Both data-types also include a join_ref that uniquely identifies the currently joined channel.</source>
          <target state="translated">服务器可以发送消息或回复。对于消息,ref唯一标识消息。对于回复,ref匹配原始消息。这两种数据类型都包含一个join_ref,唯一标识当前加入的通道。</target>
        </trans-unit>
        <trans-unit id="25af858d19e12fa8099a294c660a40b18c7cf762" translate="yes" xml:space="preserve">
          <source>The server's &lt;code&gt;handle_event/3&lt;/code&gt; would receive a payload:</source>
          <target state="translated">服务器的 &lt;code&gt;handle_event/3&lt;/code&gt; 将收到有效负载：</target>
        </trans-unit>
        <trans-unit id="efdb100e8fb22edffbda4a2f9c62ff5b45f532b5" translate="yes" xml:space="preserve">
          <source>The session contents, the final data to be stored after it has been built with &lt;a href=&quot;plug.conn#put_session/3&quot;&gt;&lt;code&gt;Plug.Conn.put_session/3&lt;/code&gt;&lt;/a&gt; and the other session manipulating functions</source>
          <target state="translated">会话内容，使用&lt;a href=&quot;plug.conn#put_session/3&quot;&gt; &lt;code&gt;Plug.Conn.put_session/3&lt;/code&gt; &lt;/a&gt;和其他会话操作功能构建后要存储的最终数据</target>
        </trans-unit>
        <trans-unit id="8b95a016960327d8adfb4b2a4fa7945022268acb" translate="yes" xml:space="preserve">
          <source>The session contents, the final data to be stored after it has been built with &lt;a href=&quot;plug.conn#put_session/3&quot;&gt;&lt;code&gt;Plug.Conn.put_session/3&lt;/code&gt;&lt;/a&gt; and the other session manipulating functions.</source>
          <target state="translated">会话内容，使用&lt;a href=&quot;plug.conn#put_session/3&quot;&gt; &lt;code&gt;Plug.Conn.put_session/3&lt;/code&gt; &lt;/a&gt;和其他会话操作功能构建后要存储的最终数据。</target>
        </trans-unit>
        <trans-unit id="a534b349ad0dd4485a26018b51cb99468bc99b42" translate="yes" xml:space="preserve">
          <source>The session id may be nil in case the cookie does not identify any value in the store. The session contents must be a map.</source>
          <target state="translated">如果cookie不能识别存储中的任何值,session id可以是nil。会话内容必须是一个地图。</target>
        </trans-unit>
        <trans-unit id="45b3c50494949266d4502d1426e160d856709a04" translate="yes" xml:space="preserve">
          <source>The session is accessed via functions on &lt;a href=&quot;plug.conn&quot;&gt;&lt;code&gt;Plug.Conn&lt;/code&gt;&lt;/a&gt;. Cookies and session have to be fetched with &lt;a href=&quot;plug.conn#fetch_session/1&quot;&gt;&lt;code&gt;Plug.Conn.fetch_session/1&lt;/code&gt;&lt;/a&gt; before the session can be accessed.</source>
          <target state="translated">通过&lt;a href=&quot;plug.conn&quot;&gt; &lt;code&gt;Plug.Conn&lt;/code&gt; &lt;/a&gt;上的函数可以访问该会话。必须先使用&lt;a href=&quot;plug.conn#fetch_session/1&quot;&gt; &lt;code&gt;Plug.Conn.fetch_session/1&lt;/code&gt; &lt;/a&gt;提取Cookie和会话，然后才能访问该会话。</target>
        </trans-unit>
        <trans-unit id="ea6faaf4abb4d9eac550e7cdd062da8586b666dd" translate="yes" xml:space="preserve">
          <source>The session is also lazy. Once configured, a cookie header with the session will only be sent to the client if something is written to the session in the first place.</source>
          <target state="translated">会话也是懒惰的。一旦配置好,只有在第一时间向session写入了什么东西,才会向客户端发送带有session的cookie头。</target>
        </trans-unit>
        <trans-unit id="9ba204c596e34571bf913673b8b59a88885aaca5" translate="yes" xml:space="preserve">
          <source>The signing and encryption keys are derived from the connection's &lt;code&gt;secret_key_base&lt;/code&gt; using a salt that is built by appending &quot;_cookie&quot; to the cookie name. Care should be taken not to derive other keys using this value as the salt. Similarly do not use the same cookie name to store different values with distinct purposes.</source>
          <target state="translated">签名和加密密钥是从连接的 &lt;code&gt;secret_key_base&lt;/code&gt; 使用盐生成的，该盐是通过在cookie名称后附加&amp;ldquo; _cookie&amp;rdquo;而构建的。注意不要使用此值作为盐来派生其他密钥。同样，请勿使用相同的cookie名称来存储具有不同用途的不同值。</target>
        </trans-unit>
        <trans-unit id="e43c5d3c5ff242e45bb3d214b290a81d5f13d3bc" translate="yes" xml:space="preserve">
          <source>The simplest component only needs to define a &lt;code&gt;render&lt;/code&gt; function:</source>
          <target state="translated">最简单的组件只需要定义一个 &lt;code&gt;render&lt;/code&gt; 函数：</target>
        </trans-unit>
        <trans-unit id="76ed9ada6a0b3a3bc428852c33a8785e0c5e5e57" translate="yes" xml:space="preserve">
          <source>The socket assigns are available directly inside the template as LiveEEx &lt;code&gt;assigns&lt;/code&gt;, such as &lt;code&gt;@foo&lt;/code&gt; and &lt;code&gt;@bar&lt;/code&gt;. Any assign access should be done using the assigns in the template where proper change tracking takes place.</source>
          <target state="translated">套接字分配可以直接在模板内部使用，就像LiveEEx &lt;code&gt;assigns&lt;/code&gt; ，例如 &lt;code&gt;@foo&lt;/code&gt; 和 &lt;code&gt;@bar&lt;/code&gt; 。任何分配访问都应使用模板中发生适当更改跟踪的分配来完成。</target>
        </trans-unit>
        <trans-unit id="b42889c924bd9345b669263e4a09c0e69b581550" translate="yes" xml:space="preserve">
          <source>The socket endpoint is read from the &lt;code&gt;@endpoint&lt;/code&gt; variable.</source>
          <target state="translated">套接字端点是从 &lt;code&gt;@endpoint&lt;/code&gt; 变量读取的。</target>
        </trans-unit>
        <trans-unit id="e8353003894eb4918615880dd892b3fb26308d6c" translate="yes" xml:space="preserve">
          <source>The socket is then used to subscribe and join channels. Use this function when you want to create a blank socket to pass to functions like &lt;code&gt;UserSocket.connect/2&lt;/code&gt;.</source>
          <target state="translated">然后将套接字用于订阅和加入频道。当您要创建一个空白套接字传递给诸如 &lt;code&gt;UserSocket.connect/2&lt;/code&gt; 之类的函数时，请使用此函数。</target>
        </trans-unit>
        <trans-unit id="741b1725667e8d637e90c04ad708be61a6c67966" translate="yes" xml:space="preserve">
          <source>The socket is then used to subscribe and join channels. Use this function when you want to create a blank socket to pass to functions like &lt;code&gt;UserSocket.connect/3&lt;/code&gt;.</source>
          <target state="translated">然后，将套接字用于订阅和加入频道。当您要创建一个空白套接字传递给诸如 &lt;code&gt;UserSocket.connect/3&lt;/code&gt; 之类的函数时，请使用此函数。</target>
        </trans-unit>
        <trans-unit id="73c75fa9c265b104aea9db5e1b8d2884d15b3c1c" translate="yes" xml:space="preserve">
          <source>The source for these guides is &lt;a href=&quot;https://github.com/phoenixframework/phoenix/tree/master/guides&quot;&gt;on GitHub&lt;/a&gt;. To help improve the guides, please report an &lt;a href=&quot;https://github.com/phoenixframework/phoenix/issues&quot;&gt;issue&lt;/a&gt; or open a &lt;a href=&quot;https://github.com/phoenixframework/phoenix/pulls&quot;&gt;pull request&lt;/a&gt;.</source>
          <target state="translated">这些指南的源代码&lt;a href=&quot;https://github.com/phoenixframework/phoenix/tree/master/guides&quot;&gt;在GitHub上&lt;/a&gt;。为了帮助改进指南，请报告&lt;a href=&quot;https://github.com/phoenixframework/phoenix/issues&quot;&gt;问题&lt;/a&gt;或打开&lt;a href=&quot;https://github.com/phoenixframework/phoenix/pulls&quot;&gt;请求请求&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="df8020d63833291b1200da532130369857dd6057" translate="yes" xml:space="preserve">
          <source>The state of the schema is stored in the &lt;code&gt;:state&lt;/code&gt; field and allows following values:</source>
          <target state="translated">模式的状态存储在 &lt;code&gt;:state&lt;/code&gt; 字段中，并允许以下值：</target>
        </trans-unit>
        <trans-unit id="aa78ee5880f730e34341dec231106792a1c1612d" translate="yes" xml:space="preserve">
          <source>The status can be an integer, an atom, or &lt;code&gt;nil&lt;/code&gt;. See &lt;a href=&quot;plug.conn.status&quot;&gt;&lt;code&gt;Plug.Conn.Status&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">状态可以是整数，原子或 &lt;code&gt;nil&lt;/code&gt; 。有关更多信息，请参见&lt;a href=&quot;plug.conn.status&quot;&gt; &lt;code&gt;Plug.Conn.Status&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="549a0fdbf17866c901bbe69f809cf1df06203fc0" translate="yes" xml:space="preserve">
          <source>The status code can be &lt;code&gt;nil&lt;/code&gt;, an integer or an atom. The list of allowed atoms is available in &lt;a href=&quot;plug.conn.status&quot;&gt;&lt;code&gt;Plug.Conn.Status&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">状态码可以是 &lt;code&gt;nil&lt;/code&gt; ，整数或原子。允许的原子列表在&lt;a href=&quot;plug.conn.status&quot;&gt; &lt;code&gt;Plug.Conn.Status&lt;/code&gt; 中&lt;/a&gt;可用。</target>
        </trans-unit>
        <trans-unit id="3baf68608bb7edc0144295a9de68bd827a0c3d1c" translate="yes" xml:space="preserve">
          <source>The status code can be &lt;code&gt;nil&lt;/code&gt;, an integer, or an atom. The list of allowed atoms is available in &lt;a href=&quot;plug.conn.status&quot;&gt;&lt;code&gt;Plug.Conn.Status&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">状态码可以是 &lt;code&gt;nil&lt;/code&gt; ，整数或原子。允许的原子列表在&lt;a href=&quot;plug.conn.status&quot;&gt; &lt;code&gt;Plug.Conn.Status&lt;/code&gt; 中&lt;/a&gt;可用。</target>
        </trans-unit>
        <trans-unit id="5b85cd2f546627e7f8e771b8e4dacbd15919de6f" translate="yes" xml:space="preserve">
          <source>The status code we provide must be a valid number.</source>
          <target state="translated">我们提供的状态码必须是一个有效的数字。</target>
        </trans-unit>
        <trans-unit id="58d3fec1c36423b15af55e60202f9084e0860082" translate="yes" xml:space="preserve">
          <source>The struct for testing LiveViews.</source>
          <target state="translated">用于测试LiveViews的结构。</target>
        </trans-unit>
        <trans-unit id="b011117162e069e69fd96c3b54a5ab2de98fb369" translate="yes" xml:space="preserve">
          <source>The struct representing an internal unique reference to the component instance, available as the &lt;code&gt;@myself&lt;/code&gt; assign in stateful components.</source>
          <target state="translated">表示对组件实例的内部唯一引用的结构，可以作为有状态组件中的 &lt;code&gt;@myself&lt;/code&gt; 分配使用。</target>
        </trans-unit>
        <trans-unit id="1ffbb97758f6664c833c9c9e920b7aabfee8a286" translate="yes" xml:space="preserve">
          <source>The struct returned by .leex templates.</source>
          <target state="translated">.leex模板返回的结构。</target>
        </trans-unit>
        <trans-unit id="db12a53ec7a2451062d21b0ec8554b50bad078d6" translate="yes" xml:space="preserve">
          <source>The struct returned by &lt;a href=&quot;phoenix.liveviewtest#element/3&quot;&gt;&lt;code&gt;Phoenix.LiveViewTest.element/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;phoenix.liveviewtest#element/3&quot;&gt; &lt;code&gt;Phoenix.LiveViewTest.element/3&lt;/code&gt; &lt;/a&gt;返回的结构。</target>
        </trans-unit>
        <trans-unit id="336f100817cc09f943763c011543a225c024d68e" translate="yes" xml:space="preserve">
          <source>The struct returned by components in .leex templates.</source>
          <target state="translated">.leex模板中的组件返回的结构。</target>
        </trans-unit>
        <trans-unit id="d96032e1804462a375e61aa3becfddf682507fdb" translate="yes" xml:space="preserve">
          <source>The struct returned by for-comprehensions in .leex templates.</source>
          <target state="translated">.leex模板中for-comprehensions返回的结构。</target>
        </trans-unit>
        <trans-unit id="c2e71fa009e7b2e244d8ad3544b3e79a8a9bae1d" translate="yes" xml:space="preserve">
          <source>The submitted form is reactivated and loses the &lt;code&gt;&quot;phx-submit-loading&quot;&lt;/code&gt; class</source>
          <target state="translated">提交的表单被重新激活，并且丢失了 &lt;code&gt;&quot;phx-submit-loading&quot;&lt;/code&gt; 类</target>
        </trans-unit>
        <trans-unit id="44eb57fe50cca343fe8e2ef06f2524d5aeefcf45" translate="yes" xml:space="preserve">
          <source>The supplied &lt;code&gt;user&lt;/code&gt; and &lt;code&gt;pass&lt;/code&gt; may be empty strings;</source>
          <target state="translated">提供的 &lt;code&gt;user&lt;/code&gt; 和 &lt;code&gt;pass&lt;/code&gt; 可以为空字符串；</target>
        </trans-unit>
        <trans-unit id="9b7700abeab24f899ce4198c80479749838f3339" translate="yes" xml:space="preserve">
          <source>The supported keys are:</source>
          <target state="translated">支持的钥匙有:</target>
        </trans-unit>
        <trans-unit id="db2280a174b18020a2620736642518bf66a11dab" translate="yes" xml:space="preserve">
          <source>The supported options are:</source>
          <target state="translated">支持的选项有:</target>
        </trans-unit>
        <trans-unit id="9183fa9d80288d69edd242efa2830a2745f8ab1f" translate="yes" xml:space="preserve">
          <source>The supported values are:</source>
          <target state="translated">支持的数值是:</target>
        </trans-unit>
        <trans-unit id="01f20fe2845d2b1bdb9951b6a8d84f277b6b5d78" translate="yes" xml:space="preserve">
          <source>The syntax above is equivalent to:</source>
          <target state="translated">上述语法相当于:</target>
        </trans-unit>
        <trans-unit id="8a40be796b70fed45f015e64809fd60c04642951" translate="yes" xml:space="preserve">
          <source>The temporary directory where files are streamed to can be customized by setting the &lt;code&gt;PLUG_TMPDIR&lt;/code&gt; environment variable on the host system. If &lt;code&gt;PLUG_TMPDIR&lt;/code&gt; isn&amp;rsquo;t set, Plug will look at some environment variables which usually hold the value of the system&amp;rsquo;s temporary directory (like &lt;code&gt;TMPDIR&lt;/code&gt; or &lt;code&gt;TMP&lt;/code&gt;). If no value is found in any of those variables, &lt;code&gt;/tmp&lt;/code&gt; is used as a default.</source>
          <target state="translated">可以通过在主机系统上设置 &lt;code&gt;PLUG_TMPDIR&lt;/code&gt; 环境变量来定制将文件流传输到的临时目录。如果未设置 &lt;code&gt;PLUG_TMPDIR&lt;/code&gt; ，则Plug将查看一些环境变量，这些环境变量通常包含系统临时目录的值（如 &lt;code&gt;TMPDIR&lt;/code&gt; 或 &lt;code&gt;TMP&lt;/code&gt; ）。如果在任何这些变量中都没有找到值，则 &lt;code&gt;/tmp&lt;/code&gt; 用作默认值。</target>
        </trans-unit>
        <trans-unit id="abfd2e746ee341013e4cdbafc97dfddc04d08e71" translate="yes" xml:space="preserve">
          <source>The temporary directory where files are streamed to can be customized by setting the &lt;code&gt;PLUG_TMPDIR&lt;/code&gt; environment variable on the host system. If &lt;code&gt;PLUG_TMPDIR&lt;/code&gt; isn't set, Plug will look at some environment variables which usually hold the value of the system's temporary directory (like &lt;code&gt;TMPDIR&lt;/code&gt; or &lt;code&gt;TMP&lt;/code&gt;). If no value is found in any of those variables, &lt;code&gt;/tmp&lt;/code&gt; is used as a default.</source>
          <target state="translated">可以通过在主机系统上设置 &lt;code&gt;PLUG_TMPDIR&lt;/code&gt; 环境变量来定制将文件流传输到的临时目录。如果未设置 &lt;code&gt;PLUG_TMPDIR&lt;/code&gt; ，则Plug将查看一些环境变量，这些环境变量通常包含系统临时目录的值（如 &lt;code&gt;TMPDIR&lt;/code&gt; 或 &lt;code&gt;TMP&lt;/code&gt; ）。如果在任何这些变量中都没有找到值，则 &lt;code&gt;/tmp&lt;/code&gt; 用作默认值。</target>
        </trans-unit>
        <trans-unit id="6008af9872175b7be58ce5d3be6044dce8156ae7" translate="yes" xml:space="preserve">
          <source>The test process will not receive the published message. This triggers the &lt;code&gt;handle_out/3&lt;/code&gt; callback in the channel.</source>
          <target state="translated">测试过程将不会收到已发布的消息。这将触发通道中的 &lt;code&gt;handle_out/3&lt;/code&gt; 回调。</target>
        </trans-unit>
        <trans-unit id="96e4f76aa06de2592f470fd3dea7b0c4ef31375c" translate="yes" xml:space="preserve">
          <source>The third and final option is to use &lt;a href=&quot;#many_to_many/3&quot;&gt;&lt;code&gt;many_to_many/3&lt;/code&gt;&lt;/a&gt; to define the relationships between the resources. In this case, the comments table won&amp;rsquo;t have the foreign key, instead there is a intermediary table responsible for associating the entries:</source>
          <target state="translated">第三个也是最后一个选项是使用&lt;a href=&quot;#many_to_many/3&quot;&gt; &lt;code&gt;many_to_many/3&lt;/code&gt; &lt;/a&gt;定义资源之间的关系。在这种情况下，注释表将没有外键，而是有一个中间表负责将条目相关联：</target>
        </trans-unit>
        <trans-unit id="8de91f694a160eac98f8736952f2a3f88136e353" translate="yes" xml:space="preserve">
          <source>The third and final option is to use &lt;a href=&quot;#many_to_many/3&quot;&gt;&lt;code&gt;many_to_many/3&lt;/code&gt;&lt;/a&gt; to define the relationships between the resources. In this case, the comments table won't have the foreign key, instead there is an intermediary table responsible for associating the entries:</source>
          <target state="translated">第三个也是最后一个选项是使用&lt;a href=&quot;#many_to_many/3&quot;&gt; &lt;code&gt;many_to_many/3&lt;/code&gt; &lt;/a&gt;定义资源之间的关系。在这种情况下，注释表将没有外键，而是有一个中间表负责将条目相关联：</target>
        </trans-unit>
        <trans-unit id="aa9b72d684ded4fbc52b2db0fd313e2feea35d4f" translate="yes" xml:space="preserve">
          <source>The third argument &lt;code&gt;format&lt;/code&gt; is the format the data has been dumped as. For example, databases may dump embedded to &lt;code&gt;:json&lt;/code&gt;, this function allows such dumped data to be put back into the schemas.</source>
          <target state="translated">第三个参数 &lt;code&gt;format&lt;/code&gt; 是数据已转储为的格式。例如，数据库可能转储嵌入到 &lt;code&gt;:json&lt;/code&gt; ，此功能允许将这些转储的数据放回架构中。</target>
        </trans-unit>
        <trans-unit id="22dfe15ea505dc65004d52b00565b0529f3c5106" translate="yes" xml:space="preserve">
          <source>The third argument can be any term (string, int, list, etc.) that you wish to codify into the token. Upon valid verification, this same term will be extracted from the token.</source>
          <target state="translated">第三个参数可以是您希望编入令牌的任何术语(字符串、int、列表等)。经有效验证后,该术语将从令牌中提取。</target>
        </trans-unit>
        <trans-unit id="a1c2052b68df8425edb8d31ef1ad3c1921b372fa" translate="yes" xml:space="preserve">
          <source>The timeout is in milliseconds and defaults to 100ms.</source>
          <target state="translated">超时的单位是毫秒,默认为100ms。</target>
        </trans-unit>
        <trans-unit id="ecb554852eb06b5cfc5cc2ec1aa86dbe934028bb" translate="yes" xml:space="preserve">
          <source>The timeout is in milliseconds and defaults to 100ms. Keep in mind this macro will block the test by the timeout value, so use it only when necessary as overuse will certainly slow down your test suite.</source>
          <target state="translated">超时的单位是毫秒,默认为100ms。请记住这个宏会通过超时值来阻止测试,所以只有在必要的时候才使用它,因为过度使用肯定会拖慢你的测试套件。</target>
        </trans-unit>
        <trans-unit id="1304926df4500481102d8f6f3aa1797e91270270" translate="yes" xml:space="preserve">
          <source>The timeout is in milliseconds and defaults to the &lt;code&gt;:assert_receive_timeout&lt;/code&gt; set on the &lt;code&gt;:ex_unit&lt;/code&gt; application (which defaults to 100ms).</source>
          <target state="translated">超时是在毫秒，默认为 &lt;code&gt;:assert_receive_timeout&lt;/code&gt; 上设置 &lt;code&gt;:ex_unit&lt;/code&gt; 应用（默认为100毫秒）。</target>
        </trans-unit>
        <trans-unit id="b6a222ff7aa627d2ff58408f68862da0a0c1ac3d" translate="yes" xml:space="preserve">
          <source>The timeout is in milliseconds and defaults to the &lt;code&gt;:refute_receive_timeout&lt;/code&gt; set on the &lt;code&gt;:ex_unit&lt;/code&gt; application (which defaults to 100ms). Keep in mind this macro will block the test by the timeout value, so use it only when necessary as overuse will certainly slow down your test suite.</source>
          <target state="translated">超时是在毫秒，默认为 &lt;code&gt;:refute_receive_timeout&lt;/code&gt; 所设定的 &lt;code&gt;:ex_unit&lt;/code&gt; 应用（默认为100毫秒）。请记住，此宏将通过超时值来阻止测试，因此仅在必要时使用它，因为过度使用肯定会降低测试套件的速度。</target>
        </trans-unit>
        <trans-unit id="0b4fff6f531f38d34226e8259653e269c039cae2" translate="yes" xml:space="preserve">
          <source>The timestamp is updated whenever there is a read or write to the table and it may be used to detect if a session is still active.</source>
          <target state="translated">每当对表进行读或写时,时间戳就会更新,它可以用来检测会话是否仍然处于活动状态。</target>
        </trans-unit>
        <trans-unit id="81762c19246e6846b2e980ea04896a37c7853877" translate="yes" xml:space="preserve">
          <source>The token may be sent by the request either via the params with key &quot;_csrf_token&quot; or a header with name &quot;x-csrf-token&quot;.</source>
          <target state="translated">该令牌可以通过请求中的参数&quot;_csrf_token &quot;或名称为 &quot;x-csrf-token &quot;的头来发送。</target>
        </trans-unit>
        <trans-unit id="a5072feb3a5cec39cc2fc00a21cad324ac72eccb" translate="yes" xml:space="preserve">
          <source>The token may be sent by the request either via the params with key &amp;ldquo;_csrf_token&amp;rdquo; or a header with name &amp;ldquo;x-csrf-token&amp;rdquo;.</source>
          <target state="translated">令牌可以由请求通过带有键&amp;ldquo; _csrf_token&amp;rdquo;的参数或名为&amp;ldquo; x-csrf-token&amp;rdquo;的标头发送。</target>
        </trans-unit>
        <trans-unit id="2c49c933ccb1807a833e99f7dd1b49c2eb650bfa" translate="yes" xml:space="preserve">
          <source>The tracked statics on the client will match the ones on the server the huge majority of times. However, if there is a new deployment, those values may differ. You can use this function to detect those cases and show a banner to the user, asking them to reload the page. To do so, first set the assign on mount:</source>
          <target state="translated">客户端上的跟踪状态在绝大多数情况下都会与服务器上的状态一致。但是,如果有新的部署,这些值可能会有所不同。你可以使用这个功能来检测这些情况,并向用户显示一个横幅,要求他们重新加载页面。要做到这一点,首先在挂载时设置赋值。</target>
        </trans-unit>
        <trans-unit id="fec7f0c751853b58fb208600c6fd51e96a829e62" translate="yes" xml:space="preserve">
          <source>The tracking of changes is done via assigns. Imagine this template:</source>
          <target state="translated">变化的跟踪是通过assigns来完成的。想象一下这个模板。</target>
        </trans-unit>
        <trans-unit id="92ce00aada35b93b3fdf93d5a2e7544465e5a9ee" translate="yes" xml:space="preserve">
          <source>The transaction will return the value given as &lt;code&gt;{:error, value}&lt;/code&gt;.</source>
          <target state="translated">事务将返回给定的值为 &lt;code&gt;{:error, value}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="144f4cd1edb440f47f1246559392f7aed2405665" translate="yes" xml:space="preserve">
          <source>The transport behaviour</source>
          <target state="translated">运输行为</target>
        </trans-unit>
        <trans-unit id="ffde96e4790584145c12afb10941ddbcfe63b5c3" translate="yes" xml:space="preserve">
          <source>The transport passes a map of metadata and the socket returns &lt;code&gt;{:ok, state}&lt;/code&gt; or &lt;code&gt;:error&lt;/code&gt;. The state must be stored by the transport and returned in all future operations.</source>
          <target state="translated">传输传递元数据映射，套接字返回 &lt;code&gt;{:ok, state}&lt;/code&gt; 或 &lt;code&gt;:error&lt;/code&gt; 。状态必须由运输工具存储，并在以后的所有操作中返回。</target>
        </trans-unit>
        <trans-unit id="0618061b416a03f218c617e087e2e53df218e5c9" translate="yes" xml:space="preserve">
          <source>The transport requires one function:</source>
          <target state="translated">运输需要一个功能。</target>
        </trans-unit>
        <trans-unit id="2c0b95368d8ebf1cd3519374ade97eb4d383c66c" translate="yes" xml:space="preserve">
          <source>The triggers the &lt;code&gt;handle_in/3&lt;/code&gt; callback in the channel.</source>
          <target state="translated">触发器在通道中触发 &lt;code&gt;handle_in/3&lt;/code&gt; 回调。</target>
        </trans-unit>
        <trans-unit id="42337bbf47f302b6017a80123d119d2018afc1ba" translate="yes" xml:space="preserve">
          <source>The underlying data in the JSON column is returned without any additional decoding. This means &quot;null&quot; JSON values are not the same as SQL's &quot;null&quot;. For example, the &lt;code&gt;Repo.all&lt;/code&gt; operation below returns an empty list because &lt;code&gt;p.meta[&quot;author&quot;]&lt;/code&gt; returns JSON's null and therefore &lt;code&gt;is_nil&lt;/code&gt; does not succeed:</source>
          <target state="translated">返回JSON列中的基础数据，而无需任何其他解码。这意味着&amp;ldquo;空&amp;rdquo; JSON值与SQL的&amp;ldquo;空&amp;rdquo;不同。例如，下面的 &lt;code&gt;Repo.all&lt;/code&gt; 操作返回一个空列表，因为 &lt;code&gt;p.meta[&quot;author&quot;]&lt;/code&gt; 返回JSON的null，因此 &lt;code&gt;is_nil&lt;/code&gt; 不成功：</target>
        </trans-unit>
        <trans-unit id="18e53abaed4d2983226c3cac5079451da818bff2" translate="yes" xml:space="preserve">
          <source>The underlying user is passed to the view and template as &lt;code&gt;:user&lt;/code&gt;, which is inferred from the view name. The name of the key in assigns can be customized with the &lt;code&gt;:as&lt;/code&gt; option:</source>
          <target state="translated">基础用户作为 &lt;code&gt;:user&lt;/code&gt; 传递到视图和模板，这是从视图名称推断出来的。可以使用 &lt;code&gt;:as&lt;/code&gt; 选项自定义分配中键的名称：</target>
        </trans-unit>
        <trans-unit id="1dfd3b303d5fe2aedc67a0b4bc8aa60d95f14665" translate="yes" xml:space="preserve">
          <source>The underlying user is passed to the view and template as &lt;code&gt;:user&lt;/code&gt;, which is inflected from the view name. The name of the key in assigns can be customized with the &lt;code&gt;:as&lt;/code&gt; option:</source>
          <target state="translated">基础用户以 &lt;code&gt;:user&lt;/code&gt; 的身份传递到视图和模板，该名称从视图名称开始变化。可以使用 &lt;code&gt;:as&lt;/code&gt; 选项自定义分配中键的名称：</target>
        </trans-unit>
        <trans-unit id="ece19487ec4f9c9b42291fc4215172a12c3b8537" translate="yes" xml:space="preserve">
          <source>The unique constraint works by relying on the database to check if the unique constraint has been violated or not and, if so, Ecto converts it into a changeset error.</source>
          <target state="translated">唯一约束的工作原理是依靠数据库来检查是否违反了唯一约束,如果违反了,Ecto会将其转换为变化集错误。</target>
        </trans-unit>
        <trans-unit id="8f24025f778f23bb692d5c7e74205b6b4b984c73" translate="yes" xml:space="preserve">
          <source>The update expression in Ecto supports the following operators:</source>
          <target state="translated">Ecto中的更新表达式支持以下运算符。</target>
        </trans-unit>
        <trans-unit id="9e941c51bb22eea00a76220d6ae9f744a7be5afe" translate="yes" xml:space="preserve">
          <source>The update function receives the current key's value and returns the updated value. Raises if the key does not exist.</source>
          <target state="translated">更新函数接收当前键的值并返回更新后的值。如果键不存在,则发出警报。</target>
        </trans-unit>
        <trans-unit id="5b6d6cdb41018b373e7cfa4867802d99511b1902" translate="yes" xml:space="preserve">
          <source>The valid keys are:</source>
          <target state="translated">有效的钥匙是:</target>
        </trans-unit>
        <trans-unit id="d9ef4c02aad1666d20571d41d03ccfe5bdef87c8" translate="yes" xml:space="preserve">
          <source>The validate callback simply updates the changeset based on all form input values, then assigns the new changeset to the socket. If the changeset changes, such as generating new errors, &lt;a href=&quot;phoenix.liveview#c:render/1&quot;&gt;&lt;code&gt;render/1&lt;/code&gt;&lt;/a&gt; is invoked and the form is re-rendered.</source>
          <target state="translated">validate回调仅基于所有表单输入值更新更改集，然后将新的更改集分配给套接字。如果变更集发生更改（例如生成新错误），则将调用&lt;a href=&quot;phoenix.liveview#c:render/1&quot;&gt; &lt;code&gt;render/1&lt;/code&gt; &lt;/a&gt;并重新呈现表单。</target>
        </trans-unit>
        <trans-unit id="cb6cddd8de1840c96ca7fda0519b7a48fb8e1141" translate="yes" xml:space="preserve">
          <source>The values above are not meant to be exact. For example, setting the length to 8_000_000 may end up reading some hundred bytes more from the socket until we halt.</source>
          <target state="translated">上面的值并不意味着是精确的。例如,将长度设置为8_000_000,可能最终会从套接字中多读几百个字节,直到我们停止。</target>
        </trans-unit>
        <trans-unit id="f62c587734431028a6aa80f1e9be78246f2a1d3f" translate="yes" xml:space="preserve">
          <source>The values above are not meant to be exact. For example, setting the length to &lt;code&gt;8_000_000&lt;/code&gt; may end up reading some hundred bytes more from the socket until we halt.</source>
          <target state="translated">上面的值并不精确。例如，将长度设置为 &lt;code&gt;8_000_000&lt;/code&gt; 可能最终会从套接字读取数百个字节，直到我们停止。</target>
        </trans-unit>
        <trans-unit id="8ecaa2ac2dc3f10d3435db3d9b4bfce660d8e6fb" translate="yes" xml:space="preserve">
          <source>The view layer also contains conveniences for rendering templates, including support for layouts and encoders per format.</source>
          <target state="translated">视图层还包含了渲染模板的便利条件,包括支持每种格式的布局和编码器。</target>
        </trans-unit>
        <trans-unit id="60741f2b56ae9c96f4fb20a37607c7c8a04c0e31" translate="yes" xml:space="preserve">
          <source>The view's job is not only to render HTML templates. Views are about data presentation. Given a bag of data, the view's purpose is to present that in a meaningful way given some format, be it HTML, JSON, CSV, or others. Many web apps today return JSON to remote clients, and Phoenix Views are &lt;em&gt;great&lt;/em&gt; for JSON rendering.</source>
          <target state="translated">该视图的工作不仅是呈现HTML模板。视图是关于数据表示的。给定一袋数据，视图的目的是以有意义的方式呈现给定的某种格式，例如HTML，JSON，CSV或其他格式。如今，许多Web应用程序都将JSON返回到远程客户端，Phoenix Views&lt;em&gt;非常&lt;/em&gt;适合JSON呈现。</target>
        </trans-unit>
        <trans-unit id="91fa591ef2cba3e61fb437760238714eb628080e" translate="yes" xml:space="preserve">
          <source>The websocket is configurable in your socket:</source>
          <target state="translated">websocket在你的socket中是可以配置的。</target>
        </trans-unit>
        <trans-unit id="2b5a7e72a4fe9a475fcfc4b4359c0838c82db1da" translate="yes" xml:space="preserve">
          <source>Then Phoenix will never re-render the section above, even if the number of users in the database changes. Instead, you need to store the users as assigns in your LiveView before it renders the template:</source>
          <target state="translated">那么Phoenix将永远不会重新渲染上面的部分,即使数据库中的用户数量发生变化。相反,你需要在LiveView渲染模板之前,将用户存储为assigns。</target>
        </trans-unit>
        <trans-unit id="19af577dc0e0cc3e9e4137f355fc1af37d4a35b0" translate="yes" xml:space="preserve">
          <source>Then a hook callback object could be defined and passed to the socket:</source>
          <target state="translated">然后可以定义一个钩子回调对象并传递给socket。</target>
        </trans-unit>
        <trans-unit id="e364d2682313f21c0b364d5a1f63f57084ff3d81" translate="yes" xml:space="preserve">
          <source>Then access &lt;code&gt;@page_title&lt;/code&gt; in the root layout:</source>
          <target state="translated">然后在根布局中访问 &lt;code&gt;@page_title&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="7196b255ac3408de7a3c568b57c1148a6a5e5f86" translate="yes" xml:space="preserve">
          <source>Then add the &lt;a href=&quot;phoenix.liveview.router#fetch_live_flash/2&quot;&gt;&lt;code&gt;Phoenix.LiveView.Router.fetch_live_flash/2&lt;/code&gt;&lt;/a&gt; plug to your browser pipeline, in place of &lt;code&gt;:fetch_flash&lt;/code&gt;:</source>
          <target state="translated">然后将&lt;a href=&quot;phoenix.liveview.router#fetch_live_flash/2&quot;&gt; &lt;code&gt;Phoenix.LiveView.Router.fetch_live_flash/2&lt;/code&gt; &lt;/a&gt;插件添加到您的浏览器管道中，以代替 &lt;code&gt;:fetch_flash&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="75c95726962fecc66929136723a6281fa6affd6c" translate="yes" xml:space="preserve">
          <source>Then add to your main application's supervision tree (usually in &lt;code&gt;lib/my_app/application.ex&lt;/code&gt;):</source>
          <target state="translated">然后添加到主应用程序的监视树（通常在 &lt;code&gt;lib/my_app/application.ex&lt;/code&gt; 中）：</target>
        </trans-unit>
        <trans-unit id="dab777042c47d40f4805c33c94a1bf2e15d3974d" translate="yes" xml:space="preserve">
          <source>Then expect them in the test:</source>
          <target state="translated">那就期待他们在测试中。</target>
        </trans-unit>
        <trans-unit id="f64fa9df7a55832de8379999e187333ea71240ba" translate="yes" xml:space="preserve">
          <source>Then in your &lt;code&gt;assets/css/app.css&lt;/code&gt; file, import its style:</source>
          <target state="translated">然后在您的 &lt;code&gt;assets/css/app.css&lt;/code&gt; 文件中，导入其样式：</target>
        </trans-unit>
        <trans-unit id="b070171e3affccf770658d51e9a5a2feeee14f4d" translate="yes" xml:space="preserve">
          <source>Then in your LiveView &lt;code&gt;mount/3&lt;/code&gt;, you can restore the locale:</source>
          <target state="translated">然后在LiveView &lt;code&gt;mount/3&lt;/code&gt; 中，可以还原语言环境：</target>
        </trans-unit>
        <trans-unit id="f0c5001f8e7c44fc4729c6dbfba0bf39f72beb09" translate="yes" xml:space="preserve">
          <source>Then in your LiveView, you can toggle the assign to trigger the form with the current fields on next render:</source>
          <target state="translated">然后在你的LiveView中,你可以切换赋值,在下一次渲染时用当前字段触发表单。</target>
        </trans-unit>
        <trans-unit id="c527e6d510bb99f313314e80e90cb75cc1f4074f" translate="yes" xml:space="preserve">
          <source>Then install the new NPM dependency:</source>
          <target state="translated">然后安装新的NPM依赖关系。</target>
        </trans-unit>
        <trans-unit id="b44a39ccd5266edb2d9caad076b683f36a1762b6" translate="yes" xml:space="preserve">
          <source>Then it falls back to the &lt;code&gt;@schema_prefix&lt;/code&gt; attribute declared in the schema given to &lt;code&gt;from&lt;/code&gt;/&lt;code&gt;join&lt;/code&gt;</source>
          <target state="translated">然后回 &lt;code&gt;@schema_prefix&lt;/code&gt; 在 &lt;code&gt;from&lt;/code&gt; / &lt;code&gt;join&lt;/code&gt; 给定的模式中声明的@schema_prefix属性</target>
        </trans-unit>
        <trans-unit id="5fe6880ddcb09c2b177e0c20e50dae10169afeef" translate="yes" xml:space="preserve">
          <source>Then it falls back to the query prefix</source>
          <target state="translated">然后它又回到了查询前缀</target>
        </trans-unit>
        <trans-unit id="a1ac12656c2b3f79bd0a2050e3acbce5cba1ab83" translate="yes" xml:space="preserve">
          <source>Then make sure to call it in every LiveView's &lt;a href=&quot;phoenix.liveview#c:mount/3&quot;&gt;&lt;code&gt;mount/3&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">然后确保在每个LiveView的&lt;a href=&quot;phoenix.liveview#c:mount/3&quot;&gt; &lt;code&gt;mount/3&lt;/code&gt; 中&lt;/a&gt;调用它：</target>
        </trans-unit>
        <trans-unit id="1f55476a7acca9fcf01ed95bca9c169e12918f35" translate="yes" xml:space="preserve">
          <source>Then on the server, all LiveView bindings are handled with the &lt;code&gt;handle_event&lt;/code&gt; callback, for example:</source>
          <target state="translated">然后在服务器上，所有LiveView绑定都通过 &lt;code&gt;handle_event&lt;/code&gt; 回调进行处理，例如：</target>
        </trans-unit>
        <trans-unit id="0d9c975aa67ad159cfffc8aca53b0fcbfcf6e25a" translate="yes" xml:space="preserve">
          <source>Then the &lt;a href=&quot;phoenix.liveview#c:mount/3&quot;&gt;&lt;code&gt;mount/3&lt;/code&gt;&lt;/a&gt; callback of your LiveView should execute those same verifications:</source>
          <target state="translated">然后，LiveView的&lt;a href=&quot;phoenix.liveview#c:mount/3&quot;&gt; &lt;code&gt;mount/3&lt;/code&gt; &lt;/a&gt;回调应执行这些相同的验证：</target>
        </trans-unit>
        <trans-unit id="f0b91bece7078d6127399b4fede7285d49a284f5" translate="yes" xml:space="preserve">
          <source>Then the module for the &lt;code&gt;@view_module&lt;/code&gt; view can decide to provide scripts with either a precompiled template, or by implementing the function directly, ie:</source>
          <target state="translated">然后， &lt;code&gt;@view_module&lt;/code&gt; 视图的模块可以决定为脚本提供预编译的模板，还是直接实现该功能，即：</target>
        </trans-unit>
        <trans-unit id="f14d34a4f2c3d48f59e2e1b8b4a19a69ac94c3f8" translate="yes" xml:space="preserve">
          <source>Then the module under &lt;code&gt;view_module(@conn)&lt;/code&gt; can decide to provide scripts with either a precompiled template, or by implementing the function directly, ie:</source>
          <target state="translated">然后， &lt;code&gt;view_module(@conn)&lt;/code&gt; 下的模块可以决定为脚本提供预编译的模板，还是直接实现该功能，即：</target>
        </trans-unit>
        <trans-unit id="bd69831783581e277c0c694fce3ca0c8208fd7dc" translate="yes" xml:space="preserve">
          <source>Then the reporter will attach a listener for the &lt;code&gt;&quot;phoenix.endpoint.stop.duration&quot;&lt;/code&gt; event and will respond to this event by calculating a summary metric with the given event metadata and reporting on that metric to the appropriate source.</source>
          <target state="translated">然后，报告者将为 &lt;code&gt;&quot;phoenix.endpoint.stop.duration&quot;&lt;/code&gt; 事件附加一个侦听器，并将通过使用给定事件元数据计算摘要度量并将该度量报告给适当的源来对该事件做出响应。</target>
        </trans-unit>
        <trans-unit id="5a0b9d44aabce7da630f72c56a074c5f7a3f3085" translate="yes" xml:space="preserve">
          <source>Then we can reference our new controller as the &lt;code&gt;action_fallback&lt;/code&gt; and simply remove the &lt;code&gt;else&lt;/code&gt; block from our &lt;code&gt;with&lt;/code&gt;:</source>
          <target state="translated">然后，我们可以将新控制器引用为 &lt;code&gt;action_fallback&lt;/code&gt; ，只需 &lt;code&gt;with&lt;/code&gt; 以下命令从我们的 &lt;code&gt;else&lt;/code&gt; 块中删除：</target>
        </trans-unit>
        <trans-unit id="2b9c5f3948060b97e1164d834dab0e2986a1f273" translate="yes" xml:space="preserve">
          <source>Then we'll change the &lt;code&gt;index&lt;/code&gt; action to do nothing but redirect to our new route.</source>
          <target state="translated">然后，我们将更改 &lt;code&gt;index&lt;/code&gt; 操作，除了重定向到我们的新路由外，什么也不做。</target>
        </trans-unit>
        <trans-unit id="c0dafaeb0118a06673409561de14306159c50ceb" translate="yes" xml:space="preserve">
          <source>Then you are able to use your own datetime_select throughout your whole application.</source>
          <target state="translated">然后你就可以在整个应用程序中使用你自己的datetime_select。</target>
        </trans-unit>
        <trans-unit id="ceb5c8aab927695627e6a415525151e60cdf227b" translate="yes" xml:space="preserve">
          <source>Then you can directly create a socket and &lt;a href=&quot;#subscribe_and_join/4&quot;&gt;&lt;code&gt;subscribe_and_join/4&lt;/code&gt;&lt;/a&gt; topics and channels:</source>
          <target state="translated">然后，您可以直接创建一个套接字以及&lt;a href=&quot;#subscribe_and_join/4&quot;&gt; &lt;code&gt;subscribe_and_join/4&lt;/code&gt; &lt;/a&gt;主题和频道：</target>
        </trans-unit>
        <trans-unit id="584bf72a0acf37e4eddce0ef40e653d37e3153b8" translate="yes" xml:space="preserve">
          <source>Then, in the &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html#start/2&quot;&gt;&lt;code&gt;Application.start/2&lt;/code&gt;&lt;/a&gt; callback, attach the handler to this event using a unique handler id:</source>
          <target state="translated">然后，在&lt;a href=&quot;https://hexdocs.pm/elixir/Application.html#start/2&quot;&gt; &lt;code&gt;Application.start/2&lt;/code&gt; &lt;/a&gt;回调中，使用唯一的处理程序ID将处理程序附加到此事件：</target>
        </trans-unit>
        <trans-unit id="1745b5a982e4f76414fc6a64641255e30bd82f09" translate="yes" xml:space="preserve">
          <source>Then, pass the basename of the new layout into &lt;code&gt;put_layout/2&lt;/code&gt; in our &lt;code&gt;index&lt;/code&gt; action in &lt;code&gt;lib/hello_web/controllers/page_controller.ex&lt;/code&gt;.</source>
          <target state="translated">然后，在 &lt;code&gt;lib/hello_web/controllers/page_controller.ex&lt;/code&gt; 中的 &lt;code&gt;index&lt;/code&gt; 操作中，将新布局的基本名称传递到 &lt;code&gt;put_layout/2&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="4655c959b82e207027f846c0e96c80c6352c98fa" translate="yes" xml:space="preserve">
          <source>There are a couple of interesting things to notice about what we just did. We didn't need to stop and re-start the server while we made these changes. Yes, Phoenix has hot code reloading! Also, even though our &lt;code&gt;index.html.eex&lt;/code&gt; file consisted of only a single &lt;code&gt;div&lt;/code&gt; tag, the page we get is a full HTML document. Our index template is rendered into the application layout - &lt;code&gt;lib/hello_web/templates/layout/app.html.eex&lt;/code&gt;. If you open it, you'll see a line that looks like this:</source>
          <target state="translated">关于我们刚刚所做的事情，有几件有趣的事情需要注意。进行这些更改后，我们无需停止并重新启动服务器。是的，Phoenix有热代码重新加载！同样，即使我们的 &lt;code&gt;index.html.eex&lt;/code&gt; 文件仅包含一个 &lt;code&gt;div&lt;/code&gt; 标签，但我们获得的页面都是完整的HTML文档。我们的索引模板将呈现到应用程序布局中 &lt;code&gt;lib/hello_web/templates/layout/app.html.eex&lt;/code&gt; 。如果打开它，您将看到如下所示的一行：</target>
        </trans-unit>
        <trans-unit id="7cfb6706dad4ed0adea156a71a400336e56fc4b3" translate="yes" xml:space="preserve">
          <source>There are a few things that can go wrong with &lt;code&gt;ecto.create&lt;/code&gt;. If our Postgres database doesn't have a &quot;postgres&quot; role (user), we'll get an error like this one.</source>
          <target state="translated">&lt;code&gt;ecto.create&lt;/code&gt; 可能会出错。如果我们的Postgres数据库没有&amp;ldquo; postgres&amp;rdquo;角色（用户），我们将收到类似这样的错误。</target>
        </trans-unit>
        <trans-unit id="a0dcdee5113beb075e0f94cbe43ea0dc06f75667" translate="yes" xml:space="preserve">
          <source>There are a number of places to connect with community members at all experience levels.</source>
          <target state="translated">有许多地方可以与各种经验水平的社区成员联系。</target>
        </trans-unit>
        <trans-unit id="1c1b86b915cfde7a7368137f0a2e48d4add28c22" translate="yes" xml:space="preserve">
          <source>There are also optional packages depending on your configuration:</source>
          <target state="translated">根据您的配置,还可以选择套餐。</target>
        </trans-unit>
        <trans-unit id="48e7b53c5d965f68485b3ddac277b810c18b5b6b" translate="yes" xml:space="preserve">
          <source>There are also use cases which are a bad fit for LiveView:</source>
          <target state="translated">也有一些用例是不适合LiveView的。</target>
        </trans-unit>
        <trans-unit id="1b7d6ee807af67ee19de04b8ba6fe4bb0e14f07b" translate="yes" xml:space="preserve">
          <source>There are currently a number of built-in Phoenix-specific and Ecto-specific mix tasks available to us within a newly-generated application. We can also create our own application specific tasks.</source>
          <target state="translated">目前,在新生成的应用程序中,有许多内置的Phoenix特定和Ecto特定的混合任务供我们使用。我们也可以创建自己的应用程序专用任务。</target>
        </trans-unit>
        <trans-unit id="f4de1bab3bcb78d7de2f1a97fb1645a22d989827" translate="yes" xml:space="preserve">
          <source>There are just a few more things we need to do to make this work. We need to tell our router that it should accept the &lt;code&gt;text&lt;/code&gt; format. We do that by adding &lt;code&gt;text&lt;/code&gt; to the list of accepted formats in the &lt;code&gt;:browser&lt;/code&gt; pipeline. Let's open up &lt;code&gt;lib/hello_web/router.ex&lt;/code&gt; and change the &lt;code&gt;plug :accepts&lt;/code&gt; to include &lt;code&gt;text&lt;/code&gt; as well as &lt;code&gt;html&lt;/code&gt; like this.</source>
          <target state="translated">为了完成这项工作，我们还需要做几件事。我们需要告诉我们的路由器它应该接受 &lt;code&gt;text&lt;/code&gt; 格式。通过在 &lt;code&gt;:browser&lt;/code&gt; 管道中的可接受格式列表中添加 &lt;code&gt;text&lt;/code&gt; 可以做到这一点。让我们打开 &lt;code&gt;lib/hello_web/router.ex&lt;/code&gt; 并更改 &lt;code&gt;plug :accepts&lt;/code&gt; 以包含 &lt;code&gt;text&lt;/code&gt; 以及类似这样的 &lt;code&gt;html&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6f91d0d9ce57177167c4420ce8468f849e7c8d5c" translate="yes" xml:space="preserve">
          <source>There are many more validations and transformations we can perform in a changeset. Please see the &lt;a href=&quot;../ecto/ecto.changeset&quot;&gt;Ecto Changeset documentation&lt;/a&gt; for more information.</source>
          <target state="translated">我们可以在变更集中执行更多的验证和转换。请参阅&lt;a href=&quot;../ecto/ecto.changeset&quot;&gt;Ecto Changeset文档&lt;/a&gt;以获取更多信息。</target>
        </trans-unit>
        <trans-unit id="e051d2e913fcf9b1ffdbc95cb07006f322d1bf3e" translate="yes" xml:space="preserve">
          <source>There are many use cases where LiveView is an excellent fit right now:</source>
          <target state="translated">现在有很多用例,LiveView是非常合适的。</target>
        </trans-unit>
        <trans-unit id="d6aa20209cea63d81eee09d733072aab9dc644cb" translate="yes" xml:space="preserve">
          <source>There are numerous reporters available, for services like StatsD, Prometheus, and more. You can find them by searching for &quot;telemetry_metrics&quot; on &lt;a href=&quot;https://hex.pm/packages?search=telemetry_metrics&quot;&gt;hex.pm&lt;/a&gt;.</source>
          <target state="translated">有许多记者可以使用StatsD，Prometheus等服务。您可以通过在&lt;a href=&quot;https://hex.pm/packages?search=telemetry_metrics&quot;&gt;hex.pm&lt;/a&gt;上搜索&amp;ldquo; telemetry_metrics&amp;rdquo;来找到它们。</target>
        </trans-unit>
        <trans-unit id="ec9fd294c0e0edd78bdfd8fba29d9ae777edf871" translate="yes" xml:space="preserve">
          <source>There are other HTTP verbs. For example, submitting a form typically uses the POST verb.</source>
          <target state="translated">还有其他的HTTP动词。例如,提交表单通常使用POST动词。</target>
        </trans-unit>
        <trans-unit id="86d080ada9c12b95f9c19b53c77166860854b8a2" translate="yes" xml:space="preserve">
          <source>There are times when we need to communicate with users during the course of an action. Maybe there was an error updating a schema. Maybe we just want to welcome them back to the application. For this, we have flash messages.</source>
          <target state="translated">有的时候,我们需要在操作过程中与用户沟通。也许在更新一个模式时出现了错误。也许我们只是想欢迎他们回到应用程序。为此,我们有了Flash消息。</target>
        </trans-unit>
        <trans-unit id="eaa6f049cdcc785decf9d1331374c9b1898ba4cc" translate="yes" xml:space="preserve">
          <source>There are two common pitfalls to keep in mind when using the &lt;code&gt;~L&lt;/code&gt; sigil or &lt;code&gt;.leex&lt;/code&gt; templates.</source>
          <target state="translated">有两种常见的陷阱使用时，要牢记 &lt;code&gt;~L&lt;/code&gt; 印记或 &lt;code&gt;.leex&lt;/code&gt; 模板。</target>
        </trans-unit>
        <trans-unit id="6807336b45c24ae9dbef79351d2099a68159d0ed" translate="yes" xml:space="preserve">
          <source>There are two kind of plugs: function plugs and module plugs.</source>
          <target state="translated">有两种插头:功能插头和模块插头。</target>
        </trans-unit>
        <trans-unit id="bea848af2e953be99cd126902e2324fb347af163" translate="yes" xml:space="preserve">
          <source>There are two main mechanisms for testing components. To test stateless components or just a regular rendering of a component, one can use &lt;a href=&quot;#render_component/2&quot;&gt;&lt;code&gt;render_component/2&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">有两种主要的测试组件的机制。要测试无状态组件或仅对组件进行常规渲染，可以使用&lt;a href=&quot;#render_component/2&quot;&gt; &lt;code&gt;render_component/2&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="7e1dd6c129ab09fcb3871f141a18dd6dd0425035" translate="yes" xml:space="preserve">
          <source>There are two types of telemetry events. The ones emitted by Ecto and the ones that are adapter specific.</source>
          <target state="translated">有两种类型的遥测事件。由Ecto发出的事件和适配器特有的事件。</target>
        </trans-unit>
        <trans-unit id="0c3abfdacb3ac569bf8db5e65409f9dce9bb486d" translate="yes" xml:space="preserve">
          <source>There are two ways to define primary keys in Ecto: using the &lt;code&gt;@primary_key&lt;/code&gt; module attribute and using &lt;code&gt;primary_key: true&lt;/code&gt; as option for &lt;a href=&quot;#field/3&quot;&gt;&lt;code&gt;field/3&lt;/code&gt;&lt;/a&gt; in your schema definition. They are not mutually exclusive and can be used together.</source>
          <target state="translated">在Ecto中定义主键的方法有两种：使用 &lt;code&gt;@primary_key&lt;/code&gt; 模块属性和使用 &lt;code&gt;primary_key: true&lt;/code&gt; 作为模式定义中&lt;a href=&quot;#field/3&quot;&gt; &lt;code&gt;field/3&lt;/code&gt; 的&lt;/a&gt;选项。它们不是互斥的，可以一起使用。</target>
        </trans-unit>
        <trans-unit id="f9e7530f090b66e3b01b4d280637820412cb520f" translate="yes" xml:space="preserve">
          <source>There can only be one select expression in a query, if the select expression is omitted, the query will by default select the full schema. If select is given more than once, an error is raised. Use &lt;a href=&quot;#exclude/2&quot;&gt;&lt;code&gt;exclude/2&lt;/code&gt;&lt;/a&gt; if you would like to remove a previous select for overriding or see &lt;a href=&quot;#select_merge/3&quot;&gt;&lt;code&gt;select_merge/3&lt;/code&gt;&lt;/a&gt; for a limited version of &lt;code&gt;select&lt;/code&gt; that is composable and can be called multiple times.</source>
          <target state="translated">查询中只能有一个选择表达式，如果省略选择表达式，则查询将默认选择完整模式。如果多次选择，则会引发错误。如果要删除先前的选择以覆盖它，请使用&lt;a href=&quot;#exclude/2&quot;&gt; &lt;code&gt;exclude/2&lt;/code&gt; ;&lt;/a&gt;对于可组合且可以多次调用的限定版本的 &lt;code&gt;select&lt;/code&gt; ，请参见&lt;a href=&quot;#select_merge/3&quot;&gt; &lt;code&gt;select_merge/3&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1c88e179b2c1fdccf0ace5889abb511cec846bf3" translate="yes" xml:space="preserve">
          <source>There is a fourth &lt;code&gt;router_opts&lt;/code&gt; argument that can be passed. These options are outlined in the &lt;a href=&quot;phoenix.router#scope/2&quot;&gt;&lt;code&gt;Phoenix.Router.scope/2&lt;/code&gt;&lt;/a&gt; documentation.</source>
          <target state="translated">可以传递第四个 &lt;code&gt;router_opts&lt;/code&gt; 参数。这些选项在&lt;a href=&quot;phoenix.router#scope/2&quot;&gt; &lt;code&gt;Phoenix.Router.scope/2&lt;/code&gt; &lt;/a&gt;文档中概述。</target>
        </trans-unit>
        <trans-unit id="60774986335f094648654b82d018e24c6920015b" translate="yes" xml:space="preserve">
          <source>There is an example of working with changesets in the introductory documentation in the &lt;a href=&quot;ecto&quot;&gt;&lt;code&gt;Ecto&lt;/code&gt;&lt;/a&gt; module. The functions &lt;a href=&quot;#cast/4&quot;&gt;&lt;code&gt;cast/4&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#change/2&quot;&gt;&lt;code&gt;change/2&lt;/code&gt;&lt;/a&gt; are the usual entry points for creating changesets. The first one is used to cast and validate external parameters, such as parameters sent through a form, API, command line, etc. The second one is used to change data directly from your application.</source>
          <target state="translated">&lt;a href=&quot;ecto&quot;&gt; &lt;code&gt;Ecto&lt;/code&gt; &lt;/a&gt;模块的入门文档中有一个使用变更集的示例。函数&lt;a href=&quot;#cast/4&quot;&gt; &lt;code&gt;cast/4&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#change/2&quot;&gt; &lt;code&gt;change/2&lt;/code&gt; &lt;/a&gt;是创建变更集的常用入口点。第一个用于强制转换和验证外部参数，例如通过表单，API，命令行等发送的参数。第二个用于直接从应用程序更改数据。</target>
        </trans-unit>
        <trans-unit id="6c51bdfb925eab670614cd9390b950e516f949e0" translate="yes" xml:space="preserve">
          <source>There is quite a bit more that Ecto can do and we've only barely scratched the surface. With a solid Ecto foundation in place, we're now ready to continue building our app and integrate the web facing application with our backend persistence. Along the way, we'll expand our Ecto knowledge and learn how to properly isolate our web interface from the underlying details of our system. Please take a look at the &lt;a href=&quot;../ecto/index&quot;&gt;Ecto documentation&lt;/a&gt; for the rest of the story.</source>
          <target state="translated">Ecto可以做的事情还很多，而我们只是勉强完成了工作。有了坚实的Ecto基础，我们现在可以继续构建我们的应用程序，并将面向Web的应用程序与我们的后端持久性集成在一起。在此过程中，我们将扩展我们的Ecto知识，并学习如何正确地将Web界面与系统的基础细节隔离。请查看&lt;a href=&quot;../ecto/index&quot;&gt;Ecto文档&lt;/a&gt;中的其余部分。</target>
        </trans-unit>
        <trans-unit id="00efdd6792388b25c72cb1b0a5d138f97391c9b0" translate="yes" xml:space="preserve">
          <source>There's a bit of a code here, so let's break it down. First, we rewrote the &lt;code&gt;create_page&lt;/code&gt; function to require a &lt;code&gt;CMS.Author&lt;/code&gt; struct, which represents the author publishing the post. We then take our changeset and pass it to &lt;code&gt;Ecto.Changeset.put_change/2&lt;/code&gt; to place the &lt;code&gt;author_id&lt;/code&gt; association in the changeset. Next, we use &lt;code&gt;Repo.insert&lt;/code&gt; to insert the new page into the database, containing our associated &lt;code&gt;author_id&lt;/code&gt;.</source>
          <target state="translated">这里有一些代码，所以让我们分解一下。首先，我们重写 &lt;code&gt;create_page&lt;/code&gt; 函数，以要求使用 &lt;code&gt;CMS.Author&lt;/code&gt; 结构，该结构表示发布该帖子的作者。然后，我们获取变更集，并将其传递给 &lt;code&gt;Ecto.Changeset.put_change/2&lt;/code&gt; ,以将 &lt;code&gt;author_id&lt;/code&gt; 关联放入变更集中。接下来，我们使用 &lt;code&gt;Repo.insert&lt;/code&gt; 将新页面插入数据库，其中包含我们关联的 &lt;code&gt;author_id&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bd27e2a8e827fa726136e1148022cbcd8bbab3bf" translate="yes" xml:space="preserve">
          <source>There's more documentation than code here, but a couple of things are important to highlight. First, we can see again that our Ecto Repo is used under the hood for database access. You probably also noticed the call to &lt;code&gt;User.changeset/2&lt;/code&gt;. We talked about changesets before, and now we see them in action in our context.</source>
          <target state="translated">这里的文档比代码更多，但是有两点很重要。首先，我们可以再次看到我们的Ecto Repo在后台用于数据库访问。您可能还注意到了对 &lt;code&gt;User.changeset/2&lt;/code&gt; 的调用。之前我们讨论过变更集，现在我们在上下文中看到了它们的作用。</target>
        </trans-unit>
        <trans-unit id="100960a1d19b2df147cb0c67cb03d0ef859b8a72" translate="yes" xml:space="preserve">
          <source>Therefore it is your responsibility to keep only the assigns necessary in each component. For example, avoid passing all of LiveView components when rendering a component:</source>
          <target state="translated">因此,你有责任在每个组件中只保留必要的赋值。例如,在渲染一个组件时,避免传递所有的LiveView组件。</target>
        </trans-unit>
        <trans-unit id="bbbe69bd2d1d3f33a0989c0c7daf1e4f17426993" translate="yes" xml:space="preserve">
          <source>Therefore, if you get a warning that the host does not match, it is either because someone is attempting to steal CSRF tokens or because you have a misconfigured host configuration.</source>
          <target state="translated">因此,如果你收到主机不匹配的警告,要么是因为有人试图窃取CSRF令牌,要么是因为你的主机配置错误。</target>
        </trans-unit>
        <trans-unit id="3748dac854496bc8faac9591f1822a153d556a4a" translate="yes" xml:space="preserve">
          <source>Therefore, when working with and manipulating external data, it is recommended to use &lt;a href=&quot;ecto.changeset&quot;&gt;&lt;code&gt;Ecto.Changeset&lt;/code&gt;&lt;/a&gt;&amp;rsquo;s that are able to filter and properly cast external data:</source>
          <target state="translated">因此，在处理和处理外部数据时，建议使用能够过滤并正确转换外部数据的&lt;a href=&quot;ecto.changeset&quot;&gt; &lt;code&gt;Ecto.Changeset&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="7e8893d85340fc3862c12874dc8c0caa638bca11" translate="yes" xml:space="preserve">
          <source>Therefore, when working with and manipulating external data, it is recommended to use &lt;a href=&quot;ecto.changeset&quot;&gt;&lt;code&gt;Ecto.Changeset&lt;/code&gt;&lt;/a&gt;'s that are able to filter and properly cast external data:</source>
          <target state="translated">因此，在处理和操作外部数据时，建议使用能够过滤和正确转换外部数据的&lt;a href=&quot;ecto.changeset&quot;&gt; &lt;code&gt;Ecto.Changeset&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="d4b6dd62855c1cdb8d6d7226945af7408045cf45" translate="yes" xml:space="preserve">
          <source>These attributes are:</source>
          <target state="translated">这些属性是:</target>
        </trans-unit>
        <trans-unit id="dab402ac1558a423d6bfdf184cdcba60e59a9b1c" translate="yes" xml:space="preserve">
          <source>These fields are reserved for libraries/framework usage.</source>
          <target state="translated">这些字段是保留给图书馆/框架使用的。</target>
        </trans-unit>
        <trans-unit id="31125242793acf4be0a0cc8a21b6685bbae8a6a2" translate="yes" xml:space="preserve">
          <source>These fields contain request information:</source>
          <target state="translated">这些字段包含请求信息。</target>
        </trans-unit>
        <trans-unit id="9c58c3f5a32cf2cabf47af4ce6c2874bf3d0f839" translate="yes" xml:space="preserve">
          <source>These fields contain response information:</source>
          <target state="translated">这些字段包含响应信息。</target>
        </trans-unit>
        <trans-unit id="4bf47d1305fab6c065239130eb679be1db4d2859" translate="yes" xml:space="preserve">
          <source>These guides focus on LiveView bindings and client-side integration:</source>
          <target state="translated">这些指南侧重于LiveView绑定和客户端集成。</target>
        </trans-unit>
        <trans-unit id="e13968d858a6aa2228deefd19ee03e436119ab45" translate="yes" xml:space="preserve">
          <source>These guides focus on server-side functionality:</source>
          <target state="translated">这些指南侧重于服务器端功能。</target>
        </trans-unit>
        <trans-unit id="ef711a090a295d12005974a4d06b792bb140e9c3" translate="yes" xml:space="preserve">
          <source>These options are assigned to &lt;code&gt;:private&lt;/code&gt; in the call&amp;rsquo;s &lt;a href=&quot;plug.conn&quot;&gt;&lt;code&gt;Plug.Conn&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这些选项在呼叫的&lt;a href=&quot;plug.conn&quot;&gt; &lt;code&gt;Plug.Conn&lt;/code&gt; &lt;/a&gt;中分配给 &lt;code&gt;:private&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="24e9ee2f9ab53061b515ecbc4fb47faf1d9a6a50" translate="yes" xml:space="preserve">
          <source>Thinking about design</source>
          <target state="translated">对设计的思考</target>
        </trans-unit>
        <trans-unit id="59fd20a59fd71306464f90cbc93687125b053059" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;:through&lt;/code&gt; association will return all authors for all comments that belongs to that post:</source>
          <target state="translated">这个 &lt;code&gt;:through&lt;/code&gt; 关联将返回属于该帖子的所有评论的所有作者：</target>
        </trans-unit>
        <trans-unit id="4199b4f5db3f20ec0146877224956a5aadb69e6f" translate="yes" xml:space="preserve">
          <source>This ability to introspect HTTP requests is really powerful -- and this is but one of &lt;em&gt;many&lt;/em&gt; telemetry events emitted by the Phoenix framework! We'll discuss more of these events, as well as specific patterns for extracting valuable data from Phoenix/Plug events in the &lt;a href=&quot;#phoenix-metrics&quot;&gt;Phoenix Metrics&lt;/a&gt; section later in this guide.</source>
          <target state="translated">内省HTTP请求的能力确实非常强大-这只是Phoenix框架发出的&lt;em&gt;众多&lt;/em&gt;遥测事件之一！我们将在本指南后面的&amp;ldquo; &lt;a href=&quot;#phoenix-metrics&quot;&gt;Phoenix Metrics&amp;rdquo;&lt;/a&gt;部分中讨论更多此类事件，以及从Phoenix / Plug事件中提取有价值的数据的特定模式。</target>
        </trans-unit>
        <trans-unit id="007291854548be2f362800441309464462d301ce" translate="yes" xml:space="preserve">
          <source>This adapter uses the following endpoint configuration:</source>
          <target state="translated">该适配器使用以下端点配置。</target>
        </trans-unit>
        <trans-unit id="a0c1e7b1a6546a0da231a6c048940c7137b1d0c8" translate="yes" xml:space="preserve">
          <source>This allows &lt;code&gt;.leex&lt;/code&gt; templates to drastically optimize the data sent by comprehensions, as the static parts are emitted only once, regardless of the number of items.</source>
          <target state="translated">这使得 &lt;code&gt;.leex&lt;/code&gt; 模板可以极大地优化理解所发送的数据，因为静态零件仅发出一次，而与项目的数量无关。</target>
        </trans-unit>
        <trans-unit id="314e0a3a76540d899cae17754d71892826cfdce8" translate="yes" xml:space="preserve">
          <source>This allows developers to properly translate values coming from the Ecto into adapter ones. For example, if the database does not support booleans but instead returns 0 and 1 for them, you could add:</source>
          <target state="translated">这允许开发人员将来自Ecto的值正确地翻译成适配器的值。例如,如果数据库不支持booleans,而是返回0和1,你可以添加。</target>
        </trans-unit>
        <trans-unit id="c34b4dd019d2b68a7383ace93f2215401ec4cad3" translate="yes" xml:space="preserve">
          <source>This allows developers to properly translate values coming from the adapters into Ecto ones. For example, if the database does not support booleans but instead returns 0 and 1 for them, you could add:</source>
          <target state="translated">这允许开发人员将来自适配器的值正确地翻译成Ecto的值。例如,如果数据库不支持booleans,而是返回0和1,你可以添加。</target>
        </trans-unit>
        <trans-unit id="fb97fed7c5bb051af51293923cd1d414d840c2fd" translate="yes" xml:space="preserve">
          <source>This approach is useful when both username and password are specified upfront and available at runtime. However, you may also want to compute a different password for each different user. In those cases, we can use the low-level API.</source>
          <target state="translated">当用户名和密码都是预先指定的,并在运行时可用时,这种方法很有用。然而,你可能还想为每个不同的用户计算不同的密码。在这些情况下,我们可以使用低级 API。</target>
        </trans-unit>
        <trans-unit id="9069e4b8ffaf3bc20294b7bd6a863e30171a4d03" translate="yes" xml:space="preserve">
          <source>This approach lets us not worry about keeping track of the position of the bindings when composing the query.</source>
          <target state="translated">这种方法让我们在组成查询时不用担心跟踪绑定的位置。</target>
        </trans-unit>
        <trans-unit id="78e0d97646f179af897c91029155ab3de9f02b8b" translate="yes" xml:space="preserve">
          <source>This approach lets us not worry about keeping track of the position of the bindings when composing the query. The &lt;code&gt;:as&lt;/code&gt; option can be given both on joins and on &lt;code&gt;from&lt;/code&gt;:</source>
          <target state="translated">这种方法使我们不必担心在编写查询时跟踪绑定的位置。的 &lt;code&gt;:as&lt;/code&gt; 选项既可以在连接和上给出 &lt;code&gt;from&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="2f59bfe0a957636ece0be8bfd839e81d84f8f0ae" translate="yes" xml:space="preserve">
          <source>This behaviour provides presence features such as fetching presences for a given topic, as well as handling diffs of join and leave events as they occur in real-time. Using this module defines a supervisor and a module that implements the &lt;a href=&quot;../phoenix_pubsub/phoenix.tracker&quot;&gt;&lt;code&gt;Phoenix.Tracker&lt;/code&gt;&lt;/a&gt; behaviour that uses &lt;a href=&quot;../phoenix_pubsub/phoenix.pubsub&quot;&gt;&lt;code&gt;Phoenix.PubSub&lt;/code&gt;&lt;/a&gt; to broadcast presence updates.</source>
          <target state="translated">此行为提供了在线状态功能，例如获取给定主题的在线状态，以及实时处理加入和离开事件的差异。使用此模块定义一个主管和一个实现&lt;a href=&quot;../phoenix_pubsub/phoenix.tracker&quot;&gt; &lt;code&gt;Phoenix.Tracker&lt;/code&gt; &lt;/a&gt;行为的模块，该行为使用&lt;a href=&quot;../phoenix_pubsub/phoenix.pubsub&quot;&gt; &lt;code&gt;Phoenix.PubSub&lt;/code&gt; &lt;/a&gt;广播状态更新。</target>
        </trans-unit>
        <trans-unit id="6967adaf22d337178372537c6118e0d2b8a63bd3" translate="yes" xml:space="preserve">
          <source>This behaviour provides presence features such as fetching presences for a given topic, as well as handling diffs of join and leave events as they occur in real-time. Using this module defines a supervisor and allows the calling module to implement the &lt;a href=&quot;../phoenix_pubsub/1.0.2/phoenix.tracker&quot;&gt;&lt;code&gt;Phoenix.Tracker&lt;/code&gt;&lt;/a&gt; behaviour which starts a tracker process to handle presence information.</source>
          <target state="translated">这种行为提供了在线状态功能，例如获取给定主题的在线状态，以及实时处理加入和离开事件的差异。使用此模块可定义主管，并允许调用模块实现&lt;a href=&quot;../phoenix_pubsub/1.0.2/phoenix.tracker&quot;&gt; &lt;code&gt;Phoenix.Tracker&lt;/code&gt; &lt;/a&gt;行为，从而启动跟踪器进程以处理状态信息。</target>
        </trans-unit>
        <trans-unit id="e21363635aabca14d08079e73432c541e1ab7506" translate="yes" xml:space="preserve">
          <source>This block is only executed in development. It enables live reloading (if you change a CSS file, they are updated in-browser without refreshing the page), code reloading (so we can see changes to our application without restarting the server), and check repo status (which makes sure our database is up to date, raising readable and actionable error otherwise).</source>
          <target state="translated">这个块只在开发中执行。它可以实现实时重载(如果你改变了一个CSS文件,它们就会在浏览器中更新,而不需要刷新页面),代码重载(这样我们就可以在不重启服务器的情况下看到我们的应用程序的变化),以及检查repo状态(确保我们的数据库是最新的,否则会引发可读和可操作的错误)。</target>
        </trans-unit>
        <trans-unit id="e7556041936c271690740591770bfe1ea6222272" translate="yes" xml:space="preserve">
          <source>This callback can be used to further modify the query and options before it is transformed and sent to the database.</source>
          <target state="translated">这个回调可以用来进一步修改查询和选项,然后再将其转换并发送至数据库。</target>
        </trans-unit>
        <trans-unit id="9b5289f3895306f4a2bb2ce650d1609e9b79d9c7" translate="yes" xml:space="preserve">
          <source>This callback is called on external input and can return any type, as long as the &lt;code&gt;dump/1&lt;/code&gt; function is able to convert the returned value into an Ecto native type. There are two situations where this callback is called:</source>
          <target state="translated">只要 &lt;code&gt;dump/1&lt;/code&gt; 函数能够将返回的值转换为Ecto本机类型，就可以在外部输入上调用此回调，并且可以返回任何类型。在两种情况下会调用此回调：</target>
        </trans-unit>
        <trans-unit id="f6d40809f5928ded0783d1c5bde4c2ca0dacdca6" translate="yes" xml:space="preserve">
          <source>This callback is called when loading data from the database and receive an Ecto native type. It can return any type, as long as the &lt;code&gt;dump/1&lt;/code&gt; function is able to convert the returned value back into an Ecto native type.</source>
          <target state="translated">从数据库加载数据并接收Ecto本机类型时，将调用此回调。只要 &lt;code&gt;dump/1&lt;/code&gt; 函数能够将返回的值转换回Ecto本机类型，它就可以返回任何类型。</target>
        </trans-unit>
        <trans-unit id="5dba0f0e5df500a1e88b72d27d9b478ed2ccb47c" translate="yes" xml:space="preserve">
          <source>This callback is called when loading data from the database and receives an Ecto native type. It can return any type, as long as the &lt;code&gt;dump/1&lt;/code&gt; function is able to convert the returned value back into an Ecto native type.</source>
          <target state="translated">从数据库加载数据并接收Ecto本机类型时，将调用此回调。只要 &lt;code&gt;dump/1&lt;/code&gt; 函数能够将返回的值转换回Ecto本机类型，它就可以返回任何类型。</target>
        </trans-unit>
        <trans-unit id="8391fe8b307eb118c66a1224a190e367cf1e34a5" translate="yes" xml:space="preserve">
          <source>This callback is called with any term that was stored in the struct and it needs to validate them and convert it to an Ecto native type.</source>
          <target state="translated">任何存储在结构中的术语都会被调用这个回调,它需要验证它们并将其转换为Ecto本地类型。</target>
        </trans-unit>
        <trans-unit id="6bf00040ea79807475cd31c46b891cb8ded6c579" translate="yes" xml:space="preserve">
          <source>This callback is invoked as the entry point for all repository operations. For example, if you are executing a query with preloads, this callback will be invoked once at the beginning, but the options returned here will be passed to all following operations.</source>
          <target state="translated">这个回调是作为所有存储库操作的入口点被调用的。例如,如果你正在执行一个带有预加载的查询,这个回调将在开始时被调用一次,但这里返回的选项将被传递给所有后续操作。</target>
        </trans-unit>
        <trans-unit id="79748d4f4c53c8b678eba754fd8a33ed0dc52111" translate="yes" xml:space="preserve">
          <source>This callback is invoked for all query APIs, including the &lt;code&gt;stream&lt;/code&gt; function, but it is not invoked for &lt;code&gt;insert_all&lt;/code&gt; nor any of the schema functions.</source>
          <target state="translated">对于所有查询API（包括 &lt;code&gt;stream&lt;/code&gt; 函数）都将调用此回调，但是对于 &lt;code&gt;insert_all&lt;/code&gt; 或任何模式函数都不会调用此回调。</target>
        </trans-unit>
        <trans-unit id="b997bebb99d88139d7659f0af87669f8dfb97d13" translate="yes" xml:space="preserve">
          <source>This can be used during tests:</source>
          <target state="translated">这在测试过程中可以使用。</target>
        </trans-unit>
        <trans-unit id="d3dd66370a2871bfe63d6fef51a35166fbee8602" translate="yes" xml:space="preserve">
          <source>This can be used to load CSRF state into another process. See &lt;a href=&quot;#dump_state/0&quot;&gt;&lt;code&gt;dump_state/0&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;dump_state_from_session/2&lt;/code&gt; for dumping it.</source>
          <target state="translated">这可用于将CSRF状态加载到另一个进程中。有关&lt;a href=&quot;#dump_state/0&quot;&gt; &lt;code&gt;dump_state/0&lt;/code&gt; &lt;/a&gt;请参见dump_state / 0和 &lt;code&gt;dump_state_from_session/2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9942f198e47ea544c82a2f3149eb4db211bc77f7" translate="yes" xml:space="preserve">
          <source>This can be used to provide default values per operation that have higher precedence than the values given on configuration or when starting the repository. It can also be used to set query specific options, such as &lt;code&gt;:prefix&lt;/code&gt;.</source>
          <target state="translated">这可用于为每个操作提供默认值，这些默认值的优先级高于配置时或启动存储库时给定的值。它也可以用来设置特定于查询的选项，例如 &lt;code&gt;:prefix&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7451f29af9970208fd48c0f77d572d71c9c6abab" translate="yes" xml:space="preserve">
          <source>This can be useful to implement nested layouts. For example, imagine you have an application layout like this:</source>
          <target state="translated">这对实现嵌套布局很有用。例如,想象你有一个这样的应用程序布局。</target>
        </trans-unit>
        <trans-unit id="04c8c29b8e1afac3fcab4f5358a3e87060ee714f" translate="yes" xml:space="preserve">
          <source>This component is never meant to be output directly into the template. It should always be handled by the diffing algorithm.</source>
          <target state="translated">这个组件永远不会被直接输出到模板中。它应该总是由diffing算法来处理。</target>
        </trans-unit>
        <trans-unit id="36cde890ab9fc7b08ed69780233aa5e8d306807f" translate="yes" xml:space="preserve">
          <source>This converts the given embedded schema to a map to be serialized with the given format. For example:</source>
          <target state="translated">这将给定的嵌入式模式转换为一个地图,并以给定的格式进行序列化。例如:</target>
        </trans-unit>
        <trans-unit id="fffb99485473cd5f2890d8e671445895fea64111" translate="yes" xml:space="preserve">
          <source>This cookie store is based on &lt;a href=&quot;https://hexdocs.pm/plug_crypto/1.0.0/Plug.Crypto.MessageVerifier.html&quot;&gt;&lt;code&gt;Plug.Crypto.MessageVerifier&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/plug_crypto/1.0.0/Plug.Crypto.MessageEncryptor.html&quot;&gt;&lt;code&gt;Plug.Crypto.MessageEncryptor&lt;/code&gt;&lt;/a&gt; which encrypts and signs each cookie to ensure they can&amp;rsquo;t be read nor tampered with.</source>
          <target state="translated">该cookie存储基于&lt;a href=&quot;https://hexdocs.pm/plug_crypto/1.0.0/Plug.Crypto.MessageVerifier.html&quot;&gt; &lt;code&gt;Plug.Crypto.MessageVerifier&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://hexdocs.pm/plug_crypto/1.0.0/Plug.Crypto.MessageEncryptor.html&quot;&gt; &lt;code&gt;Plug.Crypto.MessageEncryptor&lt;/code&gt; &lt;/a&gt;进行加密和签名，以确保每个cookie都不被读取或篡改。</target>
        </trans-unit>
        <trans-unit id="53b55df014db1d36aa928a0d1ab68e9498d7f04f" translate="yes" xml:space="preserve">
          <source>This cookie store is based on &lt;a href=&quot;https://hexdocs.pm/plug_crypto/Plug.Crypto.MessageVerifier.html&quot;&gt;&lt;code&gt;Plug.Crypto.MessageVerifier&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/plug_crypto/Plug.Crypto.MessageEncryptor.html&quot;&gt;&lt;code&gt;Plug.Crypto.MessageEncryptor&lt;/code&gt;&lt;/a&gt; which encrypts and signs each cookie to ensure they can't be read nor tampered with.</source>
          <target state="translated">该cookie存储基于&lt;a href=&quot;https://hexdocs.pm/plug_crypto/Plug.Crypto.MessageVerifier.html&quot;&gt; &lt;code&gt;Plug.Crypto.MessageVerifier&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://hexdocs.pm/plug_crypto/Plug.Crypto.MessageEncryptor.html&quot;&gt; &lt;code&gt;Plug.Crypto.MessageEncryptor&lt;/code&gt; &lt;/a&gt;进行加密和签名，以确保每个cookie都不被读取或篡改。</target>
        </trans-unit>
        <trans-unit id="88f415484d2416f0c9164e685095abeddba09475" translate="yes" xml:space="preserve">
          <source>This does not expect the repository and therefore does not leverage the cache.</source>
          <target state="translated">这并不期待版本库,因此不利用缓存。</target>
        </trans-unit>
        <trans-unit id="ee92ad563023f60c952d3ce1d1e4f1a71f755d06" translate="yes" xml:space="preserve">
          <source>This doesn't correspond to any action in our controller, which is fine. We'll exercise it in an &lt;code&gt;iex&lt;/code&gt; session. At the root of our project, we can run &lt;code&gt;iex -S mix&lt;/code&gt;, and then explicitly render our template.</source>
          <target state="translated">这与我们控制器中的任何操作都不对应，这很好。我们将在 &lt;code&gt;iex&lt;/code&gt; 会话中进行练习。在我们项目的根目录，我们可以运行 &lt;code&gt;iex -S mix&lt;/code&gt; ，然后显式呈现我们的模板。</target>
        </trans-unit>
        <trans-unit id="8358ce5c448165474c59ccb6634f95fedb0d2fb6" translate="yes" xml:space="preserve">
          <source>This emulates behaviour performed by browsers where cookies returned in the response are available in following requests.</source>
          <target state="translated">这模拟了浏览器执行的行为,在响应中返回的Cookie可用于以下请求。</target>
        </trans-unit>
        <trans-unit id="fa7d6e6dcda78ceca060025cce3f5837a513f835" translate="yes" xml:space="preserve">
          <source>This event should be invoked on every query sent to the adapter, including queries that are related to the transaction management.</source>
          <target state="translated">该事件应该在每次向适配器发送查询时被调用,包括与事务管理相关的查询。</target>
        </trans-unit>
        <trans-unit id="c0c41eb119619d93df37edc66780e62d9f72d4b1" translate="yes" xml:space="preserve">
          <source>This exception is commonly raised by &lt;a href=&quot;phoenix.controller#accepts/2&quot;&gt;&lt;code&gt;Phoenix.Controller.accepts/2&lt;/code&gt;&lt;/a&gt; which negotiates the media types the server is able to serve with the contents the client is able to render.</source>
          <target state="translated">&lt;a href=&quot;phoenix.controller#accepts/2&quot;&gt; &lt;code&gt;Phoenix.Controller.accepts/2&lt;/code&gt; &lt;/a&gt;通常会引发此异常，该异常会协商服务器能够提供的媒体类型与客户端能够呈现的内容。</target>
        </trans-unit>
        <trans-unit id="e27c88fc5d1a3d0121b169f096d2ac516c60e1ae" translate="yes" xml:space="preserve">
          <source>This exception is raised by &lt;a href=&quot;phoenix.controller#scrub_params/2&quot;&gt;&lt;code&gt;Phoenix.Controller.scrub_params/2&lt;/code&gt;&lt;/a&gt; which:</source>
          <target state="translated">&lt;a href=&quot;phoenix.controller#scrub_params/2&quot;&gt; &lt;code&gt;Phoenix.Controller.scrub_params/2&lt;/code&gt; &lt;/a&gt;引发了此异常：</target>
        </trans-unit>
        <trans-unit id="0fa6cbcebc05c777d1c7368f7969366f4e084a6c" translate="yes" xml:space="preserve">
          <source>This feature is very useful when queries need to be built based on some user input, like web search forms, CLIs and so on.</source>
          <target state="translated">当需要根据一些用户的输入建立查询时,这个功能非常有用,比如网络搜索表单、CLI等。</target>
        </trans-unit>
        <trans-unit id="736fb0a01b93ff59374b8773d572c0d61a1c4bf4" translate="yes" xml:space="preserve">
          <source>This first group contains validations that take a keyword list of validators, where the validators are shown immediately following the validation type. This list may also include a &lt;code&gt;message:&lt;/code&gt; key.</source>
          <target state="translated">第一组包含采用验证器关键字列表的验证，其中验证器紧随验证类型之后显示。此列表可能还包含一条 &lt;code&gt;message:&lt;/code&gt; 键。</target>
        </trans-unit>
        <trans-unit id="08a01cc9d2b834ac5065ca0c4859bc17a52873c2" translate="yes" xml:space="preserve">
          <source>This format is used when rendering a template as an atom. For example, &lt;code&gt;render(conn, :foo)&lt;/code&gt; will render &lt;code&gt;&quot;foo.FORMAT&quot;&lt;/code&gt; where the format is the one set here. The default format is typically set from the negotiation done in &lt;a href=&quot;#accepts/2&quot;&gt;&lt;code&gt;accepts/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">将模板渲染为原子时使用此格式。例如， &lt;code&gt;render(conn, :foo)&lt;/code&gt; 将呈现 &lt;code&gt;&quot;foo.FORMAT&quot;&lt;/code&gt; ，其中格式是此处设置的格式。通常通过在&lt;a href=&quot;#accepts/2&quot;&gt; &lt;code&gt;accepts/2&lt;/code&gt; 中&lt;/a&gt;进行的协商来设置默认格式。</target>
        </trans-unit>
        <trans-unit id="a654e5931463e5b13804f19ebe7438789fab9cac" translate="yes" xml:space="preserve">
          <source>This function accepts all options defined &lt;a href=&quot;http://erlang.org/doc/man/ssl.html&quot;&gt;in Erlang/OTP &lt;code&gt;:ssl&lt;/code&gt; documentation&lt;/a&gt;.</source>
          <target state="translated">该函数接受&lt;a href=&quot;http://erlang.org/doc/man/ssl.html&quot;&gt;Erlang / OTP &lt;code&gt;:ssl&lt;/code&gt; 文档中&lt;/a&gt;定义的所有选项。</target>
        </trans-unit>
        <trans-unit id="1b203fe59546a0ae658a9d0fdb623d409065b4b9" translate="yes" xml:space="preserve">
          <source>This function accepts and validates all options defined in &lt;a href=&quot;http://www.erlang.org/doc/man/ssl.html&quot;&gt;the &lt;code&gt;ssl&lt;/code&gt; erlang module&lt;/a&gt;. With the following additions:</source>
          <target state="translated">这个函数接受和验证中定义的所有选项&lt;a href=&quot;http://www.erlang.org/doc/man/ssl.html&quot;&gt;的 &lt;code&gt;ssl&lt;/code&gt; 二郎模块&lt;/a&gt;。加上以下内容：</target>
        </trans-unit>
        <trans-unit id="ff98681cd9fee831827f27fd0a9d833563a2d938" translate="yes" xml:space="preserve">
          <source>This function allows you to automatically sign and encrypt cookies. When signing or encryption is enabled, then any Elixir value can be stored in the cookie (except anonymous functions for security reasons). Once a value is signed or encrypted, you must also call &lt;a href=&quot;#fetch_cookies/2&quot;&gt;&lt;code&gt;fetch_cookies/2&lt;/code&gt;&lt;/a&gt; with the name of the cookies that are either signed or encrypted.</source>
          <target state="translated">此功能使您可以自动对cookie进行签名和加密。启用签名或加密后，任何Elixir值都可以存储在cookie中（出于安全原因，匿名函数除外）。对值进行签名或加密后，还必须使用签名或加密的cookie的名称调用&lt;a href=&quot;#fetch_cookies/2&quot;&gt; &lt;code&gt;fetch_cookies/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8560ae300306496e1e57a607297b4be5809ada0e" translate="yes" xml:space="preserve">
          <source>This function behaves the same as &lt;a href=&quot;#dump/2&quot;&gt;&lt;code&gt;dump/2&lt;/code&gt;&lt;/a&gt;, except for composite types the given &lt;code&gt;dumper&lt;/code&gt; function is used.</source>
          <target state="translated">此函数的行为与&lt;a href=&quot;#dump/2&quot;&gt; &lt;code&gt;dump/2&lt;/code&gt; &lt;/a&gt;相同，除了复合类型使用给定的 &lt;code&gt;dumper&lt;/code&gt; 函数外。</target>
        </trans-unit>
        <trans-unit id="6a586051ba535bcfaa3ec3caebe587edd887bffe" translate="yes" xml:space="preserve">
          <source>This function behaves the same as &lt;a href=&quot;#load/2&quot;&gt;&lt;code&gt;load/2&lt;/code&gt;&lt;/a&gt;, except for composite types the given &lt;code&gt;loader&lt;/code&gt; function is used.</source>
          <target state="translated">该函数的行为与&lt;a href=&quot;#load/2&quot;&gt; &lt;code&gt;load/2&lt;/code&gt; &lt;/a&gt;相同，除了复合类型使用给定的 &lt;code&gt;loader&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="e50d6767dc020a64e6d3d29750a6078f1a51289d" translate="yes" xml:space="preserve">
          <source>This function can also be used to dynamically load through associations by giving it a list. For example, to get all authors for all comments for the given posts, do:</source>
          <target state="translated">这个函数也可以通过给它一个列表来动态加载关联。例如,要获取给定帖子的所有评论的所有作者,可以这样做。</target>
        </trans-unit>
        <trans-unit id="b31679aebb0e8c28069688039b1fa1e4998948f2" translate="yes" xml:space="preserve">
          <source>This function copies the cookie information in &lt;code&gt;old_conn&lt;/code&gt; into &lt;code&gt;new_conn&lt;/code&gt;, emulating multiple requests done by clients where cookies are always passed forward, and returns the new version of &lt;code&gt;new_conn&lt;/code&gt;.</source>
          <target state="translated">此函数将 &lt;code&gt;old_conn&lt;/code&gt; 中的cookie信息复制到 &lt;code&gt;new_conn&lt;/code&gt; 中，以模拟客户端将cookie始终向前传递的多个请求，并返回 &lt;code&gt;new_conn&lt;/code&gt; 的新版本。</target>
        </trans-unit>
        <trans-unit id="1fe1674ac966f1e7e84fdd91a095f600ff50b42e" translate="yes" xml:space="preserve">
          <source>This function depends on gathering the messages sent by the test adapter when assets are pushed. Calling this function will clear the pushed message from the inbox for the process. To assert on multiple pushes, the result of the function should be stored in a variable.</source>
          <target state="translated">这个函数依赖于收集资产被推送时测试适配器发送的消息。调用此函数将从进程的收件箱中清除推送的消息。为了对多个推送进行断言,该函数的结果应该存储在一个变量中。</target>
        </trans-unit>
        <trans-unit id="1660cbe1db7037c9964f911ded4eb4f26591a176" translate="yes" xml:space="preserve">
          <source>This function depends on gathering the messages sent by the test adapter when informational messages, such as an early hint, are sent. Calling this function will clear the informational request messages from the inbox for the process. To assert on multiple informs, the result of the function should be stored in a variable.</source>
          <target state="translated">这个函数依赖于收集测试适配器在信息消息(如早期提示)被发送时发送的消息。调用此函数将清除进程收件箱中的信息性请求消息。要对多个信息报文进行断言,应将函数的结果存储在一个变量中。</target>
        </trans-unit>
        <trans-unit id="a9a8dbd1e103ae7949082890ccdcca71a8261b80" translate="yes" xml:space="preserve">
          <source>This function does not fetch parameters from the body. To fetch parameters from the body, use the &lt;a href=&quot;plug.parsers&quot;&gt;&lt;code&gt;Plug.Parsers&lt;/code&gt;&lt;/a&gt; plug.</source>
          <target state="translated">此函数不会从主体获取参数。要从主体获取参数，请使用&lt;a href=&quot;plug.parsers&quot;&gt; &lt;code&gt;Plug.Parsers&lt;/code&gt; &lt;/a&gt;插件。</target>
        </trans-unit>
        <trans-unit id="20ea2b75919a9c3dd8b26d94997fe49393523498" translate="yes" xml:space="preserve">
          <source>This function does the following:</source>
          <target state="translated">该功能的作用如下:</target>
        </trans-unit>
        <trans-unit id="c8689955a82c196a1de5806c3547594bd18663df" translate="yes" xml:space="preserve">
          <source>This function exists as an extension point for libraries to add new types of associations to Ecto. For the existing APIs, see &lt;a href=&quot;#belongs_to/3&quot;&gt;&lt;code&gt;belongs_to/3&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#has_many/3&quot;&gt;&lt;code&gt;has_many/3&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#has_one/3&quot;&gt;&lt;code&gt;has_one/3&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#many_to_many/3&quot;&gt;&lt;code&gt;many_to_many/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该功能作为库的扩展点存在，可以向Ecto添加新类型的关联。对于现有的API，请参阅&lt;a href=&quot;#belongs_to/3&quot;&gt; &lt;code&gt;belongs_to/3&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#has_many/3&quot;&gt; &lt;code&gt;has_many/3&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#has_one/3&quot;&gt; &lt;code&gt;has_one/3&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#many_to_many/3&quot;&gt; &lt;code&gt;many_to_many/3&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5b2304f76a58fd59e742ef62114c970eef992a68" translate="yes" xml:space="preserve">
          <source>This function exists to provide quick feedback to users of your application. It should not be relied on for any data guarantee as it has race conditions and is inherently unsafe. For example, if this check happens twice in the same time interval (because the user submitted a form twice), both checks may pass and you may end-up with duplicate entries in the database. Therefore, a &lt;a href=&quot;#unique_constraint/3&quot;&gt;&lt;code&gt;unique_constraint/3&lt;/code&gt;&lt;/a&gt; should also be used to ensure your data won&amp;rsquo;t get corrupted.</source>
          <target state="translated">存在此功能是为了向您的应用程序的用户提供快速反馈。由于它具有竞争条件并且本质上是不安全的，因此不应依赖任何数据保证。例如，如果此检查在相同的时间间隔内发生两次（因为用户两次提交了表单），则两项检查都可能通过，并且最终可能导致数据库中出现重复的条目。因此，还应该使用&lt;a href=&quot;#unique_constraint/3&quot;&gt; &lt;code&gt;unique_constraint/3&lt;/code&gt; &lt;/a&gt;来确保您的数据不会被破坏。</target>
        </trans-unit>
        <trans-unit id="dc2d67a85e75f44fb49399d03fb1c45ee6231022" translate="yes" xml:space="preserve">
          <source>This function exists to provide quick feedback to users of your application. It should not be relied on for any data guarantee as it has race conditions and is inherently unsafe. For example, if this check happens twice in the same time interval (because the user submitted a form twice), both checks may pass and you may end-up with duplicate entries in the database. Therefore, a &lt;a href=&quot;#unique_constraint/3&quot;&gt;&lt;code&gt;unique_constraint/3&lt;/code&gt;&lt;/a&gt; should also be used to ensure your data won't get corrupted.</source>
          <target state="translated">存在此功能是为了向您的应用程序的用户提供快速反馈。由于它具有竞争条件并且本质上是不安全的，因此不应作为任何数据保证的依据。例如，如果此检查在相同的时间间隔内发生两次（因为用户两次提交了表单），则两项检查都可能通过，并且您最终可能会在数据库中得到重复的条目。因此，还应该使用&lt;a href=&quot;#unique_constraint/3&quot;&gt; &lt;code&gt;unique_constraint/3&lt;/code&gt; &lt;/a&gt;来确保您的数据不会被破坏。</target>
        </trans-unit>
        <trans-unit id="73fef9a49538642527fff343bf96706313c19d33" translate="yes" xml:space="preserve">
          <source>This function expects the current schema, the association cardinality, the association name, the association module (that implements &lt;code&gt;Ecto.Association&lt;/code&gt; callbacks) and a keyword list of options.</source>
          <target state="translated">该函数需要当前模式，关联基数，关联名称，关联模块（实现 &lt;code&gt;Ecto.Association&lt;/code&gt; 回调）和选项的关键字列表。</target>
        </trans-unit>
        <trans-unit id="9dea39cef34defdfd207a8eb99802b8d948cd9f6" translate="yes" xml:space="preserve">
          <source>This function generates the &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; tag without its closing part. Check &lt;a href=&quot;#form_tag/3&quot;&gt;&lt;code&gt;form_tag/3&lt;/code&gt;&lt;/a&gt; for generating an enclosing tag.</source>
          <target state="translated">此函数生成 &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; 标记，但不包含其结尾部分。检查&lt;a href=&quot;#form_tag/3&quot;&gt; &lt;code&gt;form_tag/3&lt;/code&gt; &lt;/a&gt;以生成一个封闭标签。</target>
        </trans-unit>
        <trans-unit id="53f40e7f6118a94a757813a716439f649282ffc1" translate="yes" xml:space="preserve">
          <source>This function is a shortcut for:</source>
          <target state="translated">该功能是以下功能的快捷方式:</target>
        </trans-unit>
        <trans-unit id="6306e2e81e647cdb91b3f8a11699265b79a2778b" translate="yes" xml:space="preserve">
          <source>This function is able to handle both chunked and identity transfer-encoding by default.</source>
          <target state="translated">该函数默认能够处理分块编码和身份转移编码。</target>
        </trans-unit>
        <trans-unit id="d4b953f4ee21fe94d4050f234c2003683ae8f4ad" translate="yes" xml:space="preserve">
          <source>This function is called at compile time, and should raise if invalid values are specified. It is idiomatic that the parameters returned from this are a map. &lt;code&gt;field&lt;/code&gt; and &lt;code&gt;schema&lt;/code&gt; will be injected into the options automatically.</source>
          <target state="translated">该函数在编译时调用，如果指定了无效值，则应引发此函数。从中返回的参数是一个映射是很惯用的。 &lt;code&gt;field&lt;/code&gt; 和 &lt;code&gt;schema&lt;/code&gt; 将自动注入选项中。</target>
        </trans-unit>
        <trans-unit id="fe83ec596d61f20f781d548aba70cef9549cb117" translate="yes" xml:space="preserve">
          <source>This function is called when an application is started using &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html#start/2&quot;&gt;&lt;code&gt;Application.start/2&lt;/code&gt;&lt;/a&gt; (and functions on top of that, such as &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html#ensure_started/2&quot;&gt;&lt;code&gt;Application.ensure_started/2&lt;/code&gt;&lt;/a&gt;). This function should start the top-level process of the application (which should be the top supervisor of the application&amp;rsquo;s supervision tree if the application follows the OTP design principles around supervision).</source>
          <target state="translated">使用&lt;a href=&quot;https://hexdocs.pm/elixir/Application.html#start/2&quot;&gt; &lt;code&gt;Application.start/2&lt;/code&gt; &lt;/a&gt;启动应用程序时会调用此函数（以及位于此之上的函数，例如&lt;a href=&quot;https://hexdocs.pm/elixir/Application.html#ensure_started/2&quot;&gt; &lt;code&gt;Application.ensure_started/2&lt;/code&gt; &lt;/a&gt;）。该功能应启动应用程序的顶级过程（如果应用程序遵循围绕监督的OTP设计原则，则该功能应是应用程序的监督树的最高主管）。</target>
        </trans-unit>
        <trans-unit id="f40bd7c1cf4ae95315c3ffd80bd8b3a7c29506eb" translate="yes" xml:space="preserve">
          <source>This function is called when an application is started using &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html#start/2&quot;&gt;&lt;code&gt;Application.start/2&lt;/code&gt;&lt;/a&gt; (and functions on top of that, such as &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html#ensure_started/2&quot;&gt;&lt;code&gt;Application.ensure_started/2&lt;/code&gt;&lt;/a&gt;). This function should start the top-level process of the application (which should be the top supervisor of the application's supervision tree if the application follows the OTP design principles around supervision).</source>
          <target state="translated">使用&lt;a href=&quot;https://hexdocs.pm/elixir/Application.html#start/2&quot;&gt; &lt;code&gt;Application.start/2&lt;/code&gt; &lt;/a&gt;启动应用程序时会调用此函数（以及位于其之上的函数，例如&lt;a href=&quot;https://hexdocs.pm/elixir/Application.html#ensure_started/2&quot;&gt; &lt;code&gt;Application.ensure_started/2&lt;/code&gt; &lt;/a&gt;）。此功能应启动应用程序的顶层过程（如果应用程序遵循围绕监督的OTP设计原则，则该应用程序应是应用程序监督树的最高主管）。</target>
        </trans-unit>
        <trans-unit id="866cdfbc4d38507dc477d2b6e7b5a6b73c6d3bd8" translate="yes" xml:space="preserve">
          <source>This function is deprecated. Use reraise/1 or reraise/4 instead.</source>
          <target state="translated">此功能已被废弃,请使用reraise/1或reraise/4代替。使用reraise/1或reraise/4代替。</target>
        </trans-unit>
        <trans-unit id="889e6268cee5d42d732aa072ffb292fc6aa1faee" translate="yes" xml:space="preserve">
          <source>This function is especially useful when parsing raw query results:</source>
          <target state="translated">这个函数在解析原始查询结果时特别有用。</target>
        </trans-unit>
        <trans-unit id="1060a96b14370e1a1be3ad60f1c900dfde2028ca" translate="yes" xml:space="preserve">
          <source>This function is meant to mimic what the user can actually do, so you cannot set hidden input values. However, hidden values can be given when calling &lt;a href=&quot;#render_submit/2&quot;&gt;&lt;code&gt;render_submit/2&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#render_change/2&quot;&gt;&lt;code&gt;render_change/2&lt;/code&gt;&lt;/a&gt;, see their docs for examples.</source>
          <target state="translated">此功能旨在模仿用户的实际操作，因此您无法设置隐藏的输入值。但是，在调用&lt;a href=&quot;#render_submit/2&quot;&gt; &lt;code&gt;render_submit/2&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#render_change/2&quot;&gt; &lt;code&gt;render_change/2&lt;/code&gt; &lt;/a&gt;时可以提供隐藏值，有关示例，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="f2fbdc7b6be0d3c0040fc63965553cbf76fdb977" translate="yes" xml:space="preserve">
          <source>This function is often called internally by adapters, such as Cowboy, to validate and set reasonable defaults for SSL handling. Therefore Plug users are not expected to invoke it directly, rather you pass the relevant SSL options to your adapter which then invokes this.</source>
          <target state="translated">这个函数经常被Cowboy等适配器内部调用,以验证和设置SSL处理的合理默认值。因此Plug用户不需要直接调用它,而是将相关的SSL选项传递给你的适配器,然后由适配器调用这个函数。</target>
        </trans-unit>
        <trans-unit id="ce00aa1228b7b92a142997d61b397de721dd3451" translate="yes" xml:space="preserve">
          <source>This function is particularly useful when associations and embeds are cast in the changeset as it will traverse all associations and embeds and place all errors in a series of nested maps.</source>
          <target state="translated">当关联和嵌入被投在变化集中时,这个功能特别有用,因为它将遍历所有关联和嵌入,并将所有错误放在一系列嵌套地图中。</target>
        </trans-unit>
        <trans-unit id="9ea2792030796068ebee3771205dce320fb98fd5" translate="yes" xml:space="preserve">
          <source>This function is primarily used by &lt;a href=&quot;ecto.query#select_merge/3&quot;&gt;&lt;code&gt;Ecto.Query.select_merge/3&lt;/code&gt;&lt;/a&gt; to merge different select clauses.</source>
          <target state="translated">&lt;a href=&quot;ecto.query#select_merge/3&quot;&gt; &lt;code&gt;Ecto.Query.select_merge/3&lt;/code&gt; &lt;/a&gt;主要使用此函数来合并不同的select子句。</target>
        </trans-unit>
        <trans-unit id="95e4d0ba9a962e855d63d60b4fd26e982ea84569" translate="yes" xml:space="preserve">
          <source>This function is used for authorization purposes and it may be invoked outside of the process that effectively runs the socket.</source>
          <target state="translated">这个函数用于授权目的,它可以在有效运行套接字的进程之外被调用。</target>
        </trans-unit>
        <trans-unit id="b1f60f736835987ffe4d869279d98e0a0470fd3a" translate="yes" xml:space="preserve">
          <source>This function is used to work with associations as a whole. For example, if a Post has many Comments, it allows you to add, remove or change all comments at once. If your goal is to simply add a new comment to a post, then it is preferred to do so manually, as we will describe later in the &quot;Example: Adding a comment to a post&quot; section.</source>
          <target state="translated">这个功能是用来处理整体的关联。例如,如果一个帖子有许多评论,它允许您一次性添加、删除或更改所有评论。如果您的目标是简单地添加一个新的评论到一个帖子中,那么最好是手动操作,我们将在后面的 &quot;示例:我们将在后面的 &quot;示例:在帖子中添加评论 &quot;部分介绍。</target>
        </trans-unit>
        <trans-unit id="22adf8e4771dc77ddcc4249d7919749c29698a38" translate="yes" xml:space="preserve">
          <source>This function is used to work with associations as a whole. For example, if a Post has many Comments, it allows you to add, remove or change all comments at once. If your goal is to simply add a new comment to a post, then it is preferred to do so manually, as we will describe later in the &amp;ldquo;Example: Adding a comment to a post&amp;rdquo; section.</source>
          <target state="translated">此功能用于整体上处理关联。例如，如果一个帖子有很多评论，则它允许您一次添加，删除或更改所有评论。如果您的目标是简单地在帖子中添加新评论，则最好手动进行，这将在后面的&amp;ldquo;示例：在帖子中添加评论&amp;rdquo;部分中介绍。</target>
        </trans-unit>
        <trans-unit id="08eda1f3849525ce418b408dadef19a29c0b6f84" translate="yes" xml:space="preserve">
          <source>This function is used to work with embeds as a whole. For embeds with cardinality one, &lt;code&gt;nil&lt;/code&gt; can be used to remove the existing entry. For embeds with many entries, an empty list may be given instead.</source>
          <target state="translated">此功能用于整体嵌入。对于基数为1的嵌入，可以使用 &lt;code&gt;nil&lt;/code&gt; 删除现有条目。对于包含许多条目的嵌入，可能会给出一个空列表。</target>
        </trans-unit>
        <trans-unit id="3dd54b454514d325837202458e298d9589a1ceed" translate="yes" xml:space="preserve">
          <source>This function is useful for removing empty strings sent via HTML forms. If you are providing an API, there is likely no need to invoke &lt;a href=&quot;#scrub_params/2&quot;&gt;&lt;code&gt;scrub_params/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此功能对于删除通过HTML表单发送的空字符串很有用。如果提供API，则可能无需调用&lt;a href=&quot;#scrub_params/2&quot;&gt; &lt;code&gt;scrub_params/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="64ae2d3a9800574311ce709ebfa7b91aac472431" translate="yes" xml:space="preserve">
          <source>This function is useful for sending boolean values to the server.</source>
          <target state="translated">该函数用于向服务器发送布尔值。</target>
        </trans-unit>
        <trans-unit id="2e8d3ec5712ad07392b313c25f730d33813e39fc" translate="yes" xml:space="preserve">
          <source>This function is useful for:</source>
          <target state="translated">该功能可用于:</target>
        </trans-unit>
        <trans-unit id="0f8df1aeec38d6ef055f78ffe52b7fd809b11de3" translate="yes" xml:space="preserve">
          <source>This function is useful in JavaScript responses when there is a need to escape HTML rendered from other templates, like in the following:</source>
          <target state="translated">这个函数在JavaScript响应中很有用,当需要转义从其他模板渲染的HTML时,就像下面这样。</target>
        </trans-unit>
        <trans-unit id="8bd46d36363c15990125532c0d54d1cd70be4c83" translate="yes" xml:space="preserve">
          <source>This function is useful to detect if the client is running on an outdated version of the marked static files. It works by comparing the static paths sent by the client with the one on the server.</source>
          <target state="translated">这个功能可以用来检测客户端是否运行在标记的静态文件的过时版本上。它的工作原理是将客户端发送的静态路径与服务器上的路径进行比较。</target>
        </trans-unit>
        <trans-unit id="5f05751e977e06b61bae3058808ef7801122a3bf" translate="yes" xml:space="preserve">
          <source>This function is useful when the code being invoked crashes and there is a need to verify a particular response was sent even with the crash. It returns a tuple with &lt;code&gt;{status, headers, body}&lt;/code&gt;.</source>
          <target state="translated">当被调用的代码崩溃时，即使在崩溃时也需要验证是否发送了特定的响应，此功能很有用。它返回带有 &lt;code&gt;{status, headers, body}&lt;/code&gt; 的元组。</target>
        </trans-unit>
        <trans-unit id="feb7b5f249171806db774de8814da72fc6867cc9" translate="yes" xml:space="preserve">
          <source>This function is useful when the multi to be merged requires information from the original multi. Hence the second argument is an anonymous function that receives the multi changes so far. The anonymous function must return another multi.</source>
          <target state="translated">当要合并的multi需要原始multi的信息时,这个函数很有用。因此,第二个参数是一个匿名函数,接收到目前为止的多重变化。匿名函数必须返回另一个multi。</target>
        </trans-unit>
        <trans-unit id="ea36ab9cf50bba27fd6813a84418b75a89007160" translate="yes" xml:space="preserve">
          <source>This function is useful when you may want to serve different content-types (such as JSON and HTML) from the same routes. However, if you always have distinct routes, you can also disable content negotiation and simply hardcode your format of choice in your route pipelines:</source>
          <target state="translated">当你想从相同的路由中提供不同的内容类型(如JSON和HTML)时,这个功能很有用。但是,如果您总是有不同的路由,您也可以禁用内容协商,并在您的路由管道中简单地硬编码您选择的格式。</target>
        </trans-unit>
        <trans-unit id="51ef3241f414eaf2fb4a40b3c68e3fe5a7aa4417" translate="yes" xml:space="preserve">
          <source>This function merges two changesets provided they have been applied to the same data (their &lt;code&gt;:data&lt;/code&gt; field is equal); if the data differs, an &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; exception is raised. If one of the changesets has a &lt;code&gt;:repo&lt;/code&gt; field which is not &lt;code&gt;nil&lt;/code&gt;, then the value of that field is used as the &lt;code&gt;:repo&lt;/code&gt; field of the resulting changeset; if both changesets have a non-&lt;code&gt;nil&lt;/code&gt; and different &lt;code&gt;:repo&lt;/code&gt; field, an &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; exception is raised.</source>
          <target state="translated">如果已将两个变更集应用于相同的数据（它们的 &lt;code&gt;:data&lt;/code&gt; 字段相等），此函数将合并它们。如果数据不同，则会&lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt;异常。如果变更集之一的 &lt;code&gt;:repo&lt;/code&gt; 字段不为 &lt;code&gt;nil&lt;/code&gt; ，则该字段的值将用作结果变更集的 &lt;code&gt;:repo&lt;/code&gt; 字段；如果两个变更集具有非 &lt;code&gt;nil&lt;/code&gt; 和不同 &lt;code&gt;:repo&lt;/code&gt; 字段，&lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt;异常。</target>
        </trans-unit>
        <trans-unit id="dbc0dbbbaa75e1f372b0e07a9f6b951709ad2563" translate="yes" xml:space="preserve">
          <source>This function must be called after the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Plug.CSRFProtection&lt;/code&gt;&lt;/a&gt; plug is invoked. If a token was not yet computed, it will be.</source>
          <target state="translated">在调用&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Plug.CSRFProtection&lt;/code&gt; &lt;/a&gt;插件之后，必须调用此函数。如果尚未计算令牌，则将进行计算。</target>
        </trans-unit>
        <trans-unit id="47d374217596346a6c9bf2274712172feb075b08" translate="yes" xml:space="preserve">
          <source>This function only looks at the &lt;code&gt;:changes&lt;/code&gt; field of the given &lt;code&gt;changeset&lt;/code&gt; and returns &lt;code&gt;{:ok, value}&lt;/code&gt; if the change is present or &lt;code&gt;:error&lt;/code&gt; if it&amp;rsquo;s not.</source>
          <target state="translated">该函数仅查看给定 &lt;code&gt;changeset&lt;/code&gt; 的 &lt;code&gt;:changes&lt;/code&gt; 字段，如果存在更改，则返回 &lt;code&gt;{:ok, value}&lt;/code&gt; 否则，则返回 &lt;code&gt;:error&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5e1143e93cf32871e96d09b6d702308f61d09b3a" translate="yes" xml:space="preserve">
          <source>This function only looks at the &lt;code&gt;:changes&lt;/code&gt; field of the given &lt;code&gt;changeset&lt;/code&gt; and returns &lt;code&gt;{:ok, value}&lt;/code&gt; if the change is present or &lt;code&gt;:error&lt;/code&gt; if it's not.</source>
          <target state="translated">该函数仅查看给定 &lt;code&gt;changeset&lt;/code&gt; 的 &lt;code&gt;:changes&lt;/code&gt; 字段，如果存在更改，则返回 &lt;code&gt;{:ok, value}&lt;/code&gt; 否则，则返回 &lt;code&gt;:error&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7b8bed5158880c80ee8a08504ebf97b167b84dc1" translate="yes" xml:space="preserve">
          <source>This function overrides the default URL generation pulled from the &lt;code&gt;%Plug.Conn{}&lt;/code&gt;'s endpoint configuration.</source>
          <target state="translated">此函数将覆盖从 &lt;code&gt;%Plug.Conn{}&lt;/code&gt; 的端点配置中提取的默认URL生成。</target>
        </trans-unit>
        <trans-unit id="58cb08d9d2f1cf23b4f2a78d41b863c40f49073a" translate="yes" xml:space="preserve">
          <source>This function raises &lt;a href=&quot;phoenix.notacceptableerror&quot;&gt;&lt;code&gt;Phoenix.NotAcceptableError&lt;/code&gt;&lt;/a&gt;, which is rendered with status 406, whenever the server cannot serve a response in any of the formats expected by the client.</source>
          <target state="translated">每当服务器无法以客户端期望的任何格式提供响应时，此函数都会引发&lt;a href=&quot;phoenix.notacceptableerror&quot;&gt; &lt;code&gt;Phoenix.NotAcceptableError&lt;/code&gt; &lt;/a&gt;，并以状态406呈现。</target>
        </trans-unit>
        <trans-unit id="1c663a7b4ad2604d2adc9bea7e89c5bd791f16f9" translate="yes" xml:space="preserve">
          <source>This function reads a chunk of the request body up to a given &lt;code&gt;:length&lt;/code&gt;. If there is more data to be read, then &lt;code&gt;{:more, partial_body, conn}&lt;/code&gt; is returned. Otherwise &lt;code&gt;{:ok, body, conn}&lt;/code&gt; is returned. In case of an error reading the socket, &lt;code&gt;{:error, reason}&lt;/code&gt; is returned as per &lt;a href=&quot;http://www.erlang.org/doc/man/gen_tcp.html#recv-2&quot;&gt;&lt;code&gt;:gen_tcp.recv/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此函数读取请求正文的块，直到给定的 &lt;code&gt;:length&lt;/code&gt; 。如果还有更多数据要读取，则返回 &lt;code&gt;{:more, partial_body, conn}&lt;/code&gt; 。否则返回 &lt;code&gt;{:ok, body, conn}&lt;/code&gt; 。如果在读取套接字时 &lt;code&gt;{:error, reason}&lt;/code&gt; 则按照&lt;a href=&quot;http://www.erlang.org/doc/man/gen_tcp.html#recv-2&quot;&gt; &lt;code&gt;:gen_tcp.recv/2&lt;/code&gt; &lt;/a&gt;返回{：error，reason}。</target>
        </trans-unit>
        <trans-unit id="68ac965b424fbcfc28adb7e70510b4a5060b1986" translate="yes" xml:space="preserve">
          <source>This function reads a chunk of the request body up to a given length (specified by the &lt;code&gt;:length&lt;/code&gt; option). If there is more data to be read, then &lt;code&gt;{:more, partial_body, conn}&lt;/code&gt; is returned. Otherwise &lt;code&gt;{:ok, body, conn}&lt;/code&gt; is returned. In case of an error reading the socket, &lt;code&gt;{:error, reason}&lt;/code&gt; is returned as per &lt;a href=&quot;http://www.erlang.org/doc/man/gen_tcp.html#recv-2&quot;&gt;&lt;code&gt;:gen_tcp.recv/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该函数读取请求主体的块直到给定的长度（由 &lt;code&gt;:length&lt;/code&gt; 选项指定）。如果还有更多数据要读取，则返回 &lt;code&gt;{:more, partial_body, conn}&lt;/code&gt; 。否则返回 &lt;code&gt;{:ok, body, conn}&lt;/code&gt; 。如果在读取套接字时 &lt;code&gt;{:error, reason}&lt;/code&gt; 则按照&lt;a href=&quot;http://www.erlang.org/doc/man/gen_tcp.html#recv-2&quot;&gt; &lt;code&gt;:gen_tcp.recv/2&lt;/code&gt; &lt;/a&gt;返回{：error，reason}。</target>
        </trans-unit>
        <trans-unit id="d0c8691b7f9dfce0fa8e902a83efb3fb90903475" translate="yes" xml:space="preserve">
          <source>This function removes every key from the session, clearing the session.</source>
          <target state="translated">该功能从会话中删除每一个键,清除会话。</target>
        </trans-unit>
        <trans-unit id="23ea244127c3693a61fb279dd8a8823e78d495c2" translate="yes" xml:space="preserve">
          <source>This function requires the associated data to have been preloaded, except when the parent changeset has been newly build and not yet persisted. Missing data will invoke the &lt;code&gt;:on_replace&lt;/code&gt; behaviour defined on the association.</source>
          <target state="translated">此功能要求关联的数据已预加载，除非父变更集是新构建的但尚未持久。缺少数据将调用关联上定义的 &lt;code&gt;:on_replace&lt;/code&gt; 行为。</target>
        </trans-unit>
        <trans-unit id="508ff7af2c7302ba5ea60f62775c6f5a3c9b9900" translate="yes" xml:space="preserve">
          <source>This function requires the associated data to have been preloaded, except when the parent changeset has been newly built and not yet persisted. Missing data will invoke the &lt;code&gt;:on_replace&lt;/code&gt; behaviour defined on the association.</source>
          <target state="translated">此功能要求关联的数据已预先加载，除非父变更集是新生成的但尚未持久保存。缺少数据将调用关联上定义的 &lt;code&gt;:on_replace&lt;/code&gt; 行为。</target>
        </trans-unit>
        <trans-unit id="84382455309fc0aaf784468937d5e8642608c1e5" translate="yes" xml:space="preserve">
          <source>This function should be used when working with the entire association at once (and not a single element of a many-style association) and receiving data external to the application.</source>
          <target state="translated">当一次性处理整个关联(而不是多式关联的单个元素)并接收应用程序外部的数据时,应使用该函数。</target>
        </trans-unit>
        <trans-unit id="3736933a577a29ee24ad93a05c7c32aef1bea88b" translate="yes" xml:space="preserve">
          <source>This function should be used when working with the entire association at once (and not a single element of a many-style association) and using data external to the application.</source>
          <target state="translated">当一次性处理整个关联(而不是多式关联中的单个元素)并使用应用程序的外部数据时,应使用该函数。</target>
        </trans-unit>
        <trans-unit id="481b5ba0284c556ea198200d20cec067478414db" translate="yes" xml:space="preserve">
          <source>This function should either return &lt;code&gt;{:ok, pid}&lt;/code&gt; or &lt;code&gt;{:ok, pid, state}&lt;/code&gt; if startup is successful. &lt;code&gt;pid&lt;/code&gt; should be the PID of the top supervisor. &lt;code&gt;state&lt;/code&gt; can be an arbitrary term, and if omitted will default to &lt;code&gt;[]&lt;/code&gt;; if the application is later stopped, &lt;code&gt;state&lt;/code&gt; is passed to the &lt;code&gt;stop/1&lt;/code&gt; callback (see the documentation for the &lt;code&gt;c:stop/1&lt;/code&gt; callback for more information).</source>
          <target state="translated">如果启动成功 &lt;code&gt;{:ok, pid, state}&lt;/code&gt; 此函数应该返回 &lt;code&gt;{:ok, pid}&lt;/code&gt; 或{：ok，pid，state}。 &lt;code&gt;pid&lt;/code&gt; 应该是最高主管的PID。 &lt;code&gt;state&lt;/code&gt; 可以是任意项，如果省略，则默认为 &lt;code&gt;[]&lt;/code&gt; ；如果以后停止应用程序，则 &lt;code&gt;state&lt;/code&gt; 将传递给 &lt;code&gt;stop/1&lt;/code&gt; 回调（有关更多信息，请参见 &lt;code&gt;c:stop/1&lt;/code&gt; 回调的文档）。</target>
        </trans-unit>
        <trans-unit id="bf1fdd59778e871792165fd9cd597befae6dbe8a" translate="yes" xml:space="preserve">
          <source>This function should return &lt;code&gt;{:ok, value}&lt;/code&gt; where &lt;code&gt;value&lt;/code&gt; is the value under &lt;code&gt;key&lt;/code&gt; if the key exists in the term, or &lt;code&gt;:error&lt;/code&gt; if the key does not exist in the term.</source>
          <target state="translated">该函数应该返回 &lt;code&gt;{:ok, value}&lt;/code&gt; ，如果键中存在 &lt;code&gt;key&lt;/code&gt; 则 &lt;code&gt;value&lt;/code&gt; 是键下的值；如果键中不存在键，则为 &lt;code&gt;:error&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5ba272759196f5f4398bb53efebf29cecd454930" translate="yes" xml:space="preserve">
          <source>This function should return:</source>
          <target state="translated">这个函数应该返回:</target>
        </trans-unit>
        <trans-unit id="734b0856ba9ef7d3fe8e856bcb519a57b1180774" translate="yes" xml:space="preserve">
          <source>This function, as well as &lt;a href=&quot;#get/3&quot;&gt;&lt;code&gt;get/3&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#post/3&quot;&gt;&lt;code&gt;post/3&lt;/code&gt;&lt;/a&gt; and friends, accepts the request body or parameters as last argument:</source>
          <target state="translated">此函数以及&lt;a href=&quot;#get/3&quot;&gt; &lt;code&gt;get/3&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#post/3&quot;&gt; &lt;code&gt;post/3&lt;/code&gt; &lt;/a&gt;和friends都接受请求正文或参数作为最后一个参数：</target>
        </trans-unit>
        <trans-unit id="206f33c29b6ec02bb699170e45e3a167ce8f68a1" translate="yes" xml:space="preserve">
          <source>This functionality exists mostly for integration with &lt;code&gt;Phoenix.LiveView&lt;/code&gt; that replaces the anonymous function for explicit closing of the &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; tag:</source>
          <target state="translated">此功能主要存在于与 &lt;code&gt;Phoenix.LiveView&lt;/code&gt; 集成时，该集成替换了匿名函数以显式关闭 &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; 标记：</target>
        </trans-unit>
        <trans-unit id="5e501818f2a9b8d26ee849f92368c85b2aa84ace" translate="yes" xml:space="preserve">
          <source>This functionality exists mostly for integration with &lt;code&gt;Phoenix.LiveView&lt;/code&gt; that replaces the anonymous function for returning the generated forms instead.</source>
          <target state="translated">此功能主要存在于与 &lt;code&gt;Phoenix.LiveView&lt;/code&gt; 集成时，该功能代替了用于返回生成的表单的匿名函数。</target>
        </trans-unit>
        <trans-unit id="60a9005f28b867008de687c6b297116271dbe0ee" translate="yes" xml:space="preserve">
          <source>This generator uses default options provided in the &lt;code&gt;:generators&lt;/code&gt; configuration of the &lt;code&gt;:phoenix&lt;/code&gt; application. These are the defaults:</source>
          <target state="translated">该生成器使用 &lt;code&gt;:phoenix&lt;/code&gt; 应用程序的 &lt;code&gt;:generators&lt;/code&gt; 配置中提供的默认选项。这些是默认值：</target>
        </trans-unit>
        <trans-unit id="a8c79d64b76e704cc3305c267e9609ec954e0a9b" translate="yes" xml:space="preserve">
          <source>This generator uses default options provided in the &lt;code&gt;:generators&lt;/code&gt; configuration of your application. These are the defaults:</source>
          <target state="translated">该生成器使用应用程序 &lt;code&gt;:generators&lt;/code&gt; 配置中提供的默认选项。这些是默认值：</target>
        </trans-unit>
        <trans-unit id="ea9fd1bcd7395e4e765f0c8c83f634242ed59708" translate="yes" xml:space="preserve">
          <source>This generator will automatically open the config/config.exs after generation if you have &lt;code&gt;ECTO_EDITOR&lt;/code&gt; set in your environment variable.</source>
          <target state="translated">如果您在环境变量中设置了 &lt;code&gt;ECTO_EDITOR&lt;/code&gt; ,则该生成器将在生成后自动打开config / config.exs 。</target>
        </trans-unit>
        <trans-unit id="799bbac2299c4700ae113704fdd4823ec89feb26" translate="yes" xml:space="preserve">
          <source>This guide assumes that we have generated our new application with Ecto integration and that we will be using PostgreSQL. The introductory guides cover how to get your first application up and running. For instructions on switching to MySQL, please see the &lt;a href=&quot;#using-mysql&quot;&gt;Using MySQL&lt;/a&gt; section.</source>
          <target state="translated">本指南假定我们已经使用Ecto集成生成了新应用程序，并且将使用PostgreSQL。介绍性指南涵盖了如何启动和运行您的第一个应用程序。有关切换到MySQL的说明，请参见&amp;ldquo;&lt;a href=&quot;#using-mysql&quot;&gt;使用MySQL&amp;rdquo;&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="9beabe4b707e9a75951987e66a396037df415c99" translate="yes" xml:space="preserve">
          <source>This guide describes how to use these parameters to set up an HTTPS server with Plug, and documents some best-practices and potential pitfalls.</source>
          <target state="translated">本指南介绍了如何使用这些参数来设置Plug的HTTPS服务器,并记录了一些最佳实践和潜在的陷阱。</target>
        </trans-unit>
        <trans-unit id="351d79dff782082a2ce188e37bb0ce9252eef229" translate="yes" xml:space="preserve">
          <source>This inner representation allows us to render and compose templates easily. For example, if you want to render JSON data, we could do so by adding a &quot;show.json&quot; entry to &lt;code&gt;render/2&lt;/code&gt; in our view:</source>
          <target state="translated">这种内部表示形式使我们可以轻松地渲染和组成模板。例如，如果您要呈现JSON数据，我们可以通过在视图中向 &lt;code&gt;render/2&lt;/code&gt; 添加一个&amp;ldquo; show.json&amp;rdquo;条目来实现：</target>
        </trans-unit>
        <trans-unit id="0ef1c03d35aad86fcc35b135848f7173bd9a0fa9" translate="yes" xml:space="preserve">
          <source>This inner representation allows us to render and compose templates easily. For example, if you want to render JSON data, we could do so by adding a &amp;ldquo;show.json&amp;rdquo; entry to &lt;code&gt;render/2&lt;/code&gt; in our view:</source>
          <target state="translated">这种内部表示形式使我们可以轻松地渲染和组成模板。例如，如果您要呈现JSON数据，可以通过在视图中向 &lt;code&gt;render/2&lt;/code&gt; 添加一个&amp;ldquo; show.json&amp;rdquo;条目来实现：</target>
        </trans-unit>
        <trans-unit id="70ed772bfcabd3597901563673c3cda720c91986" translate="yes" xml:space="preserve">
          <source>This is also what calling &lt;a href=&quot;../phoenix_html/phoenix.html.safe#to_iodata/1&quot;&gt;&lt;code&gt;Phoenix.HTML.Safe.to_iodata/1&lt;/code&gt;&lt;/a&gt; with a &lt;a href=&quot;phoenix.liveview.rendered&quot;&gt;&lt;code&gt;Phoenix.LiveView.Rendered&lt;/code&gt;&lt;/a&gt; structure returns.</source>
          <target state="translated">这也是使用&lt;a href=&quot;phoenix.liveview.rendered&quot;&gt; &lt;code&gt;Phoenix.LiveView.Rendered&lt;/code&gt; &lt;/a&gt;结构调用&lt;a href=&quot;../phoenix_html/phoenix.html.safe#to_iodata/1&quot;&gt; &lt;code&gt;Phoenix.HTML.Safe.to_iodata/1&lt;/code&gt; 的&lt;/a&gt;结果。</target>
        </trans-unit>
        <trans-unit id="9df51736f8af300b7e83be2bba6d0538a65eaf19" translate="yes" xml:space="preserve">
          <source>This is an implementation of EEx.Engine that guarantees templates are HTML Safe.</source>
          <target state="translated">这是EEX.Engine的一个实现,保证模板是HTML安全的。</target>
        </trans-unit>
        <trans-unit id="22dfd0ec4ef3534510402dea1f9a067863780a64" translate="yes" xml:space="preserve">
          <source>This is available only inside subqueries.</source>
          <target state="translated">这只能在子查询中使用。</target>
        </trans-unit>
        <trans-unit id="5329254754bcb5b1518f7c46c55cd4246cdc7b2b" translate="yes" xml:space="preserve">
          <source>This is best used in conjunction with &lt;code&gt;parent_as&lt;/code&gt; to correlate the subquery with the parent query to test some condition on related rows in a different table. In the above example the query returns posts which have at least one comment that has more than 5 replies.</source>
          <target state="translated">最好与 &lt;code&gt;parent_as&lt;/code&gt; 结合使用，以使子查询与父查询相关联，以测试不同表中相关行上的某些条件。在上面的示例中，查询返回的帖子至少包含一条评论，且评论多于5条。</target>
        </trans-unit>
        <trans-unit id="dd363ee9be583e8940f3872abf411010d65f4b10" translate="yes" xml:space="preserve">
          <source>This is callback is invoked when a custom type is given to &lt;code&gt;field&lt;/code&gt; with the &lt;code&gt;:autogenerate&lt;/code&gt; flag.</source>
          <target state="translated">当使用 &lt;code&gt;:autogenerate&lt;/code&gt; 标志为 &lt;code&gt;field&lt;/code&gt; 指定自定义类型时，将调用此回调。</target>
        </trans-unit>
        <trans-unit id="1eb11a6027445daec6c09612ab24edc4bb15dc55" translate="yes" xml:space="preserve">
          <source>This is callback is invoked when a parameterized type is given to &lt;code&gt;field&lt;/code&gt; with the &lt;code&gt;:autogenerate&lt;/code&gt; flag.</source>
          <target state="translated">当通过 &lt;code&gt;:autogenerate&lt;/code&gt; 标志为 &lt;code&gt;field&lt;/code&gt; 指定参数化类型时，将调用此回调。</target>
        </trans-unit>
        <trans-unit id="7a6276fd1995acb9d422ef5b0fccedcd0f49f563" translate="yes" xml:space="preserve">
          <source>This is configured in your application environment like:</source>
          <target state="translated">这在你的应用环境中是这样配置的。</target>
        </trans-unit>
        <trans-unit id="543130ccea506a07596bda5da2eb43221176545d" translate="yes" xml:space="preserve">
          <source>This is done as a security measure to avoid attacks that attempt to traverse entries with nil columns. To check that value is &lt;code&gt;nil&lt;/code&gt;, use &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#is_nil/1&quot;&gt;&lt;code&gt;is_nil/1&lt;/code&gt;&lt;/a&gt; instead:</source>
          <target state="translated">这样做是一种安全措施，可以避免尝试遍历具有nil列的条目的攻击。要检查值是否为 &lt;code&gt;nil&lt;/code&gt; ，请改用&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#is_nil/1&quot;&gt; &lt;code&gt;is_nil/1&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="4067008cb24e88317e907e2f01cf3fea3ce7a290" translate="yes" xml:space="preserve">
          <source>This is done by regularly fetching the record from the database, then checking whether another user has made changes to the record &lt;em&gt;only when updating the record&lt;/em&gt;. This behaviour is ideal in situations where the chances of concurrent updates to the same record are low; if they&amp;rsquo;re not, pessimistic locking or other concurrency patterns may be more suited.</source>
          <target state="translated">这是通过定期从数据库中获取记录，然后&lt;em&gt;仅在更新记录时&lt;/em&gt;检查其他用户是否对记录进行了更改来完成的。在对同一记录进行并发更新的机会较低的情况下，此行为非常理想；如果不是，那么悲观锁定或其他并发模式可能更适合。</target>
        </trans-unit>
        <trans-unit id="823d31394ade33b7711fd9d9b5d40e1240503c08" translate="yes" xml:space="preserve">
          <source>This is done by regularly fetching the record from the database, then checking whether another user has made changes to the record &lt;em&gt;only when updating the record&lt;/em&gt;. This behaviour is ideal in situations where the chances of concurrent updates to the same record are low; if they're not, pessimistic locking or other concurrency patterns may be more suited.</source>
          <target state="translated">这是通过定期从数据库中获取记录，然后&lt;em&gt;仅在更新记录时&lt;/em&gt;检查其他用户是否对记录进行了更改来完成的。在对同一记录进行并发更新的机会较低的情况下，此行为是理想的。如果不是，那么悲观锁定或其他并发模式可能更适合。</target>
        </trans-unit>
        <trans-unit id="6e8026b3623dfa096a82605e21a4cd8c802a6f2c" translate="yes" xml:space="preserve">
          <source>This is equivalent to setting the status and the body and then calling &lt;a href=&quot;#send_resp/1&quot;&gt;&lt;code&gt;send_resp/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这等效于设置状态和主体，然后调用&lt;a href=&quot;#send_resp/1&quot;&gt; &lt;code&gt;send_resp/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d9ba82c91234fa5021cfb3b5cb56f8799ec54310" translate="yes" xml:space="preserve">
          <source>This is especially useful when working with subqueries, where you may need to refer to a parent binding with &lt;code&gt;parent_as&lt;/code&gt;, which is not known when writing the subquery:</source>
          <target state="translated">这在处理子查询时特别有用，在子查询中，您可能需要使用 &lt;code&gt;parent_as&lt;/code&gt; 引用父绑定，编写子查询时尚不知道：</target>
        </trans-unit>
        <trans-unit id="30cd495df7102722d59e1ffd84611b6001636dff" translate="yes" xml:space="preserve">
          <source>This is great, exactly what we want. Note how every route, path helper and controller is properly namespaced.</source>
          <target state="translated">这很好,正是我们想要的。请注意每条路由、路径帮助程序和控制器都有正确的命名间隔。</target>
        </trans-unit>
        <trans-unit id="66c9554f976f86ea7cfddef7a13a078b61322160" translate="yes" xml:space="preserve">
          <source>This is helpful when you are not testing joining the channel and just need the socket.</source>
          <target state="translated">当你不测试加入通道,只需要插座时,这很有帮助。</target>
        </trans-unit>
        <trans-unit id="e67b3c4ca838f0b073d784d2fa79097d1fe7dad2" translate="yes" xml:space="preserve">
          <source>This is invoked only once per socket regardless of the number of transports and should be responsible for setting up any process structure used exclusively by the socket regardless of transports.</source>
          <target state="translated">无论传输次数多少,每个套接字只调用一次,并且应该负责设置套接字专用的任何进程结构,无论传输次数多少。</target>
        </trans-unit>
        <trans-unit id="23ca0e35e10c4c620e6434a93de5f315f4cc8c3f" translate="yes" xml:space="preserve">
          <source>This is just what we saw before when we ran &lt;a href=&quot;mix.tasks.phx.gen.schema&quot;&gt;&lt;code&gt;mix phx.gen.schema&lt;/code&gt;&lt;/a&gt;, except here we see a &lt;code&gt;@doc false&lt;/code&gt; above our &lt;code&gt;changeset/2&lt;/code&gt; function. This tells us that while this function is publicly callable, it's not part of the public context API. Callers that build changesets do so via the context API. For example, &lt;code&gt;Accounts.create_user/1&lt;/code&gt; calls into our &lt;code&gt;User.changeset/2&lt;/code&gt; to build the changeset from user input. Callers, such as our controller actions, do not access &lt;code&gt;User.changeset/2&lt;/code&gt; directly. All interaction with our user changesets is done through the public &lt;code&gt;Accounts&lt;/code&gt; context.</source>
          <target state="translated">这就是我们运行&lt;a href=&quot;mix.tasks.phx.gen.schema&quot;&gt; &lt;code&gt;mix phx.gen.schema&lt;/code&gt; &lt;/a&gt;之前看到的内容，只是在这里我们在 &lt;code&gt;changeset/2&lt;/code&gt; 函数上方看到了 &lt;code&gt;@doc false&lt;/code&gt; 。这告诉我们，尽管此函数是可公共调用的，但它不是公共上下文API的一部分。构建变更集的调用者通过上下文API进行操作。例如， &lt;code&gt;Accounts.create_user/1&lt;/code&gt; 调用我们的 &lt;code&gt;User.changeset/2&lt;/code&gt; 以根据用户输入构建变更集。 &lt;code&gt;User.changeset/2&lt;/code&gt; 者（例如我们的控制器操作）不会直接访问User.changeset / 2。与我们的用户变更集的所有交互都是通过公共 &lt;code&gt;Accounts&lt;/code&gt; 上下文完成的。</target>
        </trans-unit>
        <trans-unit id="b7a657048e2c2cbfd50712010e238e2e21a97516" translate="yes" xml:space="preserve">
          <source>This is known to have a plethora of problems including accessibility, large numbers are converted to exponential notation and scrolling can accidentally increase or decrease the number.</source>
          <target state="translated">众所周知,这有大量的问题,包括无障碍性,大数转换为指数符号,滚动会意外增加或减少数字。</target>
        </trans-unit>
        <trans-unit id="575f8d14a96e0e9c2305203019fa9f1c1e03c389" translate="yes" xml:space="preserve">
          <source>This is not intended to be an exhaustive list, as this topic is actually a bit beyond the scope of the current document. The issue is a generic one, not specific to Erlang/Elixir, and further explanations can be found online.</source>
          <target state="translated">这并不是一个详尽的列表,因为这个话题其实有点超出了当前文档的范围。这个问题是一个通用的问题,不是Erlang/Elixir所特有的,进一步的解释可以在网上找到。</target>
        </trans-unit>
        <trans-unit id="2d0916f452cd067b42f99269461a6e8a22fcd085" translate="yes" xml:space="preserve">
          <source>This is particularly useful when used with &lt;a href=&quot;plug.builder#builder_opts/0&quot;&gt;&lt;code&gt;Plug.Builder.builder_opts/0&lt;/code&gt;&lt;/a&gt;. &lt;code&gt;builder_opts/0&lt;/code&gt; allows us to pass options received when initializing &lt;code&gt;AppRouter&lt;/code&gt; to a specific plug, such as dispatch itself. So if instead of:</source>
          <target state="translated">与&lt;a href=&quot;plug.builder#builder_opts/0&quot;&gt; &lt;code&gt;Plug.Builder.builder_opts/0&lt;/code&gt; &lt;/a&gt;一起使用时，此功能特别有用。 &lt;code&gt;builder_opts/0&lt;/code&gt; 允许我们将初始化 &lt;code&gt;AppRouter&lt;/code&gt; 时收到的选项传递给特定的插件，例如调度本身。因此，如果不是：</target>
        </trans-unit>
        <trans-unit id="0146f85b516e587e6b92b0b400db4374bf1c0f28" translate="yes" xml:space="preserve">
          <source>This is significant because we can use the &lt;code&gt;page_path&lt;/code&gt; function in a template to link to the root of our application. We can then use this helper in our templates:</source>
          <target state="translated">这很重要，因为我们可以在模板中使用 &lt;code&gt;page_path&lt;/code&gt; 函数来链接到应用程序的根目录。然后，我们可以在模板中使用此帮助程序：</target>
        </trans-unit>
        <trans-unit id="13e4b6dd8b33a2972a835278b18e46ff4920ac2a" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;a href=&quot;#foreign_key_constraint/3&quot;&gt;&lt;code&gt;foreign_key_constraint/3&lt;/code&gt;&lt;/a&gt; except that the field is inferred from the association definition. This is useful to guarantee that a child will only be created if the parent exists in the database too. Therefore, it only applies to &lt;code&gt;belongs_to&lt;/code&gt; associations.</source>
          <target state="translated">此字段与&lt;a href=&quot;#foreign_key_constraint/3&quot;&gt; &lt;code&gt;foreign_key_constraint/3&lt;/code&gt; &lt;/a&gt;相似，只是从关联定义中推断出该字段。这对于确保仅在数据库中也存在父项时才创建子项很有用。因此，它仅适用于 &lt;code&gt;belongs_to&lt;/code&gt; 关联。</target>
        </trans-unit>
        <trans-unit id="02210ecf6e704066e98f3f150578efab0c87344d" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;a href=&quot;#foreign_key_constraint/3&quot;&gt;&lt;code&gt;foreign_key_constraint/3&lt;/code&gt;&lt;/a&gt; except that the field is inferred from the association definition. This is useful to guarantee that parent can only be deleted (or have its primary key changed) if no child exists in the database. Therefore, it only applies to &lt;code&gt;has_*&lt;/code&gt; associations.</source>
          <target state="translated">此字段与&lt;a href=&quot;#foreign_key_constraint/3&quot;&gt; &lt;code&gt;foreign_key_constraint/3&lt;/code&gt; &lt;/a&gt;相似，只是从关联定义中推断出该字段。这对于确保仅在数据库中没有子代的情况下才可以删除父代（或更改其主键）是很有用的。因此，它仅适用于 &lt;code&gt;has_*&lt;/code&gt; 关联。</target>
        </trans-unit>
        <trans-unit id="246766b43ac065cf7a6813d58181faa7501710d2" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;a href=&quot;ecto.query#preload/3&quot;&gt;&lt;code&gt;Ecto.Query.preload/3&lt;/code&gt;&lt;/a&gt; except it allows you to preload structs after they have been fetched from the database.</source>
          <target state="translated">这类似于&lt;a href=&quot;ecto.query#preload/3&quot;&gt; &lt;code&gt;Ecto.Query.preload/3&lt;/code&gt; ,&lt;/a&gt;不同之处在于，它允许您在从数据库中获取结构后预加载结构。</target>
        </trans-unit>
        <trans-unit id="e4eed9ef50790eac0932b578ea9d27bff84cfd58" translate="yes" xml:space="preserve">
          <source>This is the documentation for the Phoenix project.</source>
          <target state="translated">这是凤凰城项目的文档。</target>
        </trans-unit>
        <trans-unit id="3ada68d07e24e1da189679d5236f1b2085cd8c85" translate="yes" xml:space="preserve">
          <source>This is the same mechanism provided by &lt;a href=&quot;../phoenix/phoenix.channel&quot;&gt;&lt;code&gt;Phoenix.Channel&lt;/code&gt;&lt;/a&gt;s. Therefore, if your application uses both channels and LiveViews, you can use the same technique to disconnect any stateful connection.</source>
          <target state="translated">这与&lt;a href=&quot;../phoenix/phoenix.channel&quot;&gt; &lt;code&gt;Phoenix.Channel&lt;/code&gt; &lt;/a&gt;提供的机制相同。因此，如果您的应用程序同时使用通道和LiveViews，则可以使用相同的技术来断开任何有状态的连接。</target>
        </trans-unit>
        <trans-unit id="646640f311b4826df55090d4281da13e20dd6b66" translate="yes" xml:space="preserve">
          <source>This is the standard matrix of HTTP verbs, paths, and controller actions. For a while, this was known as RESTful routes, but most consider this a misnomer nowadays. Let's look at them individually, in a slightly different order.</source>
          <target state="translated">这是HTTP动词、路径和控制器动作的标准矩阵。有一段时间,这被称为RESTful路由,但现在大多数人认为这是一个错误的名称。让我们分别看一下它们,顺序略有不同。</target>
        </trans-unit>
        <trans-unit id="d84197d638f69361b43dbeeee6fa00ab6538ceb9" translate="yes" xml:space="preserve">
          <source>This is the task we use to get our application running. It takes no arguments at all. If we pass any in, they will be silently ignored.</source>
          <target state="translated">这是我们用来让应用程序运行的任务。它不接受任何参数。如果我们传入任何参数,它们将被默默忽略。</target>
        </trans-unit>
        <trans-unit id="1287cce3e334f0bd268a0fbb70950d2bd00055a6" translate="yes" xml:space="preserve">
          <source>This is the value passed back from &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt; and subsequently passed as the last argument to all callbacks. Idiomatically it is a map.</source>
          <target state="translated">这是从&lt;a href=&quot;#c:init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt;传回并随后作为最后一个参数传递给所有回调的值。习惯上，它是一张地图。</target>
        </trans-unit>
        <trans-unit id="1871b378b5a1fb4c4012fd59a4ce5d038f416585" translate="yes" xml:space="preserve">
          <source>This is useful for things like validation hints on form fields, e.g. an empty changeset for a new form. That changeset isn&amp;rsquo;t valid, but we don&amp;rsquo;t want to show errors until an actual user action has been performed.</source>
          <target state="translated">这对于诸如表单字段上的验证提示之类的事情很有用，例如，新表单的空变更集。该变更集无效，但是在执行实际的用户操作之前，我们不希望显示错误。</target>
        </trans-unit>
        <trans-unit id="8eac94b23ec614fdc27f65b1253b4162ffa8a109" translate="yes" xml:space="preserve">
          <source>This is useful for things like validation hints on form fields, e.g. an empty changeset for a new form. That changeset isn't valid, but we don't want to show errors until an actual user action has been performed.</source>
          <target state="translated">这对于像表单字段的验证提示这样的事情是很有用的,比如一个新表单的空变化集,这个变化集是无效的,但我们不想在用户实际操作之前显示错误。这个变化集是无效的,但是我们不希望在用户实际操作之前显示错误。</target>
        </trans-unit>
        <trans-unit id="b547124ded5a56cf030283e1096472422e728527" translate="yes" xml:space="preserve">
          <source>This is useful when a specific connection is required for testing a plug or a particular function.</source>
          <target state="translated">当测试一个插头或一个特定功能需要特定的连接时,这很有用。</target>
        </trans-unit>
        <trans-unit id="967c2f65e325112d9e81267fb5e803aaad342521" translate="yes" xml:space="preserve">
          <source>This is useful when building the select by hand. It expects all options and one or more select values.</source>
          <target state="translated">这在手工建立选择时很有用。它要求所有选项和一个或多个选择值。</target>
        </trans-unit>
        <trans-unit id="cc164165494ed01035c2fea10f32c91cf135eaeb" translate="yes" xml:space="preserve">
          <source>This is useful when the whole dataset was already loaded or must be explicitly fetched from elsewhere. The IDs received by the preloading function and the result returned depends on the association type:</source>
          <target state="translated">当整个数据集已经被加载,或者必须明确地从其他地方获取时,这很有用。预加载函数接收的ID和返回的结果取决于关联类型。</target>
        </trans-unit>
        <trans-unit id="c1ee8628cd73b8b7149d50d393fe7c8fa56a351b" translate="yes" xml:space="preserve">
          <source>This is useful when you are creating forms that are not backed by any kind of data from the data layer, like a search form.</source>
          <target state="translated">当您创建的表单没有来自数据层的任何数据支持时,这很有用,比如搜索表单。</target>
        </trans-unit>
        <trans-unit id="0765c6b4474540e333d6f27c42f79680532d7ff2" translate="yes" xml:space="preserve">
          <source>This is useful when you are creating forms that are not backed by any kind of data layer. Let's assume that we're submitting a form to the &lt;code&gt;:new&lt;/code&gt; action in the &lt;code&gt;FooController&lt;/code&gt;:</source>
          <target state="translated">当您创建不受任何类型的数据层支持的表单时，这很有用。假设我们 &lt;code&gt;FooController&lt;/code&gt; 的 &lt;code&gt;:new&lt;/code&gt; 动作提交表单：</target>
        </trans-unit>
        <trans-unit id="557303ac218e1708373d1b4d8a6f4a9c23b313d1" translate="yes" xml:space="preserve">
          <source>This is useful, for example, to recompile modules that depend on external systems, such as directories, databases, etc. Note if you simply depend on external files, &lt;code&gt;@external_resource&lt;/code&gt; annotation should be used.</source>
          <target state="translated">例如，这对于重新编译依赖于外部系统（例如目录，数据库等）的模块很有用。请注意，如果仅依赖于外部文件，则应使用 &lt;code&gt;@external_resource&lt;/code&gt; 批注。</target>
        </trans-unit>
        <trans-unit id="cf23281d7b92a37b60472183249bb866a988f802" translate="yes" xml:space="preserve">
          <source>This issue can also happen with other helpers, such as &lt;code&gt;content_tag&lt;/code&gt;:</source>
          <target state="translated">其他帮助程序也可能发生此问题，例如 &lt;code&gt;content_tag&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="f798383afb7474b032be11f12e76fdd26cfd9f6b" translate="yes" xml:space="preserve">
          <source>This layout is used by many parts of your application. However, there is a subsection of your application that wants to also add a sidebar. Let's call it &quot;blog.html&quot;. You can build on top of the existing layout in two steps. First, define the blog layout:</source>
          <target state="translated">您的应用程序的许多部分都使用这种布局。然而,您的应用程序中有一个子程序也想添加一个侧栏。让我们称它为 &quot;blog.html&quot;。你可以在现有布局的基础上分两步进行构建。首先,定义博客布局。</target>
        </trans-unit>
        <trans-unit id="eede1c11892e1de751e301f0909a682510d53c2b" translate="yes" xml:space="preserve">
          <source>This looks good, but there is a problem here. Remember that we wanted both user facing reviews routes &lt;code&gt;/reviews&lt;/code&gt; as well as the admin ones &lt;code&gt;/admin/reviews&lt;/code&gt;. If we now include the user facing reviews in our router under the root scope like this:</source>
          <target state="translated">看起来不错，但是这里有问题。请记住，我们既要面向用户的评论路线 &lt;code&gt;/reviews&lt;/code&gt; ，又要让管理员的 &lt;code&gt;/admin/reviews&lt;/code&gt; 。如果我们现在将用户面临的评论包括在路由器的根范围内，如下所示：</target>
        </trans-unit>
        <trans-unit id="44a1ef9e37129dec0a33744ad55541c8ec1d1309" translate="yes" xml:space="preserve">
          <source>This macro accepts a set of options:</source>
          <target state="translated">这个宏接受一组选项。</target>
        </trans-unit>
        <trans-unit id="30cad0a3d348831413868904461ce3cb02695bb7" translate="yes" xml:space="preserve">
          <source>This macro also supports passing a nested block of route definitions. This is helpful for nesting children resources within their parents to generate nested routes.</source>
          <target state="translated">这个宏还支持传递一个嵌套的路由定义块。这对于在父资源中嵌套子资源以生成嵌套路由很有帮助。</target>
        </trans-unit>
        <trans-unit id="5272cc1708a897442f49d3861c8376d2c1684484" translate="yes" xml:space="preserve">
          <source>This macro doesn&amp;rsquo;t add any guards when adding the new plug to the pipeline; for more information about adding plugs with guards see &lt;code&gt;compile/1&lt;/code&gt;.</source>
          <target state="translated">在将新插件添加到管道中时，该宏不会添加任何保护措施。有关添加带有防护的插头的更多信息，请参见 &lt;code&gt;compile/1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="84875e3a7e5339034bbbeafae9696406ba8d0be0" translate="yes" xml:space="preserve">
          <source>This macro doesn't add any guards when adding the new plug to the pipeline; for more information about adding plugs with guards see &lt;a href=&quot;#compile/3&quot;&gt;&lt;code&gt;compile/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在将新插件添加到管道中时，该宏不会添加任何保护措施；有关添加带有防护的插头的更多信息，请参见&lt;a href=&quot;#compile/3&quot;&gt; &lt;code&gt;compile/3&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fa7e3fdecd39a60479ea64ca6e42ffb064952aa0" translate="yes" xml:space="preserve">
          <source>This macro is similar to &lt;a href=&quot;#select/3&quot;&gt;&lt;code&gt;select/3&lt;/code&gt;&lt;/a&gt; except it may be specified multiple times as long as every entry is a map. This is useful for merging and composing selects. For example:</source>
          <target state="translated">该宏与&lt;a href=&quot;#select/3&quot;&gt; &lt;code&gt;select/3&lt;/code&gt; &lt;/a&gt;相似，不同之处在于，只要每个条目都是一个映射，就可以多次指定它。这对于合并和组合选择很有用。例如：</target>
        </trans-unit>
        <trans-unit id="de8d8b58528e44c756543b77e46f1f172b9e7e02" translate="yes" xml:space="preserve">
          <source>This may accomplish what we want, but now we need to wire up the schema relationships in the &lt;code&gt;Accounts&lt;/code&gt; context to the &lt;code&gt;CMS&lt;/code&gt; author. Worse, we have now taken our isolated &lt;code&gt;Accounts&lt;/code&gt; context and required it to know about a content management system, which in turn knows about &lt;code&gt;Accounts&lt;/code&gt; too. With time, cyclic dependencies would blurry the lines between contexts, which is not what we want for isolated responsibilities in our application. There's a better way to handle these requirements.</source>
          <target state="translated">这可能会完成我们想要的，但是现在我们需要将 &lt;code&gt;Accounts&lt;/code&gt; 上下文中的架构关系连接到 &lt;code&gt;CMS&lt;/code&gt; 作者。更糟糕的是，我们现在已经采用了孤立的&amp;ldquo; &lt;code&gt;Accounts&lt;/code&gt; 上下文，并要求它了解内容管理系统，而内容管理系统也要了解&amp;ldquo; &lt;code&gt;Accounts&lt;/code&gt; 。随着时间的流逝，循环依赖关系将模糊上下文之间的界限，这不是我们想要的应用程序中独立职责所需要的。有一种更好的方法来处理这些要求。</target>
        </trans-unit>
        <trans-unit id="80844b87a747d5e664d2490ade69aea11936ad23" translate="yes" xml:space="preserve">
          <source>This may also happen on redirects. If you have a POST request to &lt;code&gt;foo.example.com&lt;/code&gt; that redirects to &lt;code&gt;bar.example.com&lt;/code&gt; with status 307, the token will contain a different host than the one in the request.</source>
          <target state="translated">这也可能在重定向上发生。如果您有对 &lt;code&gt;foo.example.com&lt;/code&gt; 的POST请求，其状态为307 重定向到 &lt;code&gt;bar.example.com&lt;/code&gt; ，则令牌将包含与请求中的主机不同的主机。</target>
        </trans-unit>
        <trans-unit id="45fff2b06c5bcdcfb6cfb7a314ec69dd932215c6" translate="yes" xml:space="preserve">
          <source>This means any HTML code inside the given string won't be escaped.</source>
          <target state="translated">这意味着给定字符串中的任何HTML代码都不会被转义。</target>
        </trans-unit>
        <trans-unit id="4a4f142c5563004d2613132e5bfe4d91c45a1a1d" translate="yes" xml:space="preserve">
          <source>This means guards can be given to &lt;code&gt;match&lt;/code&gt;:</source>
          <target state="translated">这意味着可以给守卫 &lt;code&gt;match&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="4e9c6ac4e3bf3b13fcd41f8b0bf87448b7d2126a" translate="yes" xml:space="preserve">
          <source>This means that after each request, &lt;a href=&quot;../plug/plug&quot;&gt;&lt;code&gt;Plug&lt;/code&gt;&lt;/a&gt;, via &lt;code&gt;:telemetry&lt;/code&gt;, will emit a &quot;stop&quot; event, with a measurement of how long it took to get the response:</source>
          <target state="translated">这意味着在每个请求之后，&lt;a href=&quot;../plug/plug&quot;&gt; &lt;code&gt;Plug&lt;/code&gt; 会&lt;/a&gt;通过 &lt;code&gt;:telemetry&lt;/code&gt; 发出一个&amp;ldquo;停止&amp;rdquo;事件，并测量获取响应所花费的时间：</target>
        </trans-unit>
        <trans-unit id="50ba0c978af1e21d1324664f02c106ebf9733164" translate="yes" xml:space="preserve">
          <source>This means that all routes starting with &lt;code&gt;/jobs&lt;/code&gt; will be sent to the &lt;code&gt;HelloWeb.BackgroundJob.Plug&lt;/code&gt; module. Inside the plug, you can match on subroutes, such as &lt;code&gt;/pending&lt;/code&gt; and &lt;code&gt;/active&lt;/code&gt; that shows the status of certain jobs.</source>
          <target state="translated">这意味着所有以 &lt;code&gt;/jobs&lt;/code&gt; 开头的路由都将发送到 &lt;code&gt;HelloWeb.BackgroundJob.Plug&lt;/code&gt; 模块。在插件内部，您可以匹配子路由，例如 &lt;code&gt;/pending&lt;/code&gt; 和 &lt;code&gt;/active&lt;/code&gt; ，以显示某些作业的状态。</target>
        </trans-unit>
        <trans-unit id="46fcd9b428f43bc3ceced700d0d499071542798d" translate="yes" xml:space="preserve">
          <source>This means that when working with changesets that are not meant to be persisted to the database, such as schemaless changesets, you may need to explicitly set the action to one specific value. Frameworks such as Phoenix use the action value to define how HTML forms should act.</source>
          <target state="translated">这意味着,当处理那些不打算被持久化到数据库中的变化集时,比如无模式变化集,你可能需要明确地将动作设置为一个特定的值。像Phoenix这样的框架使用动作值来定义HTML表单应该如何操作。</target>
        </trans-unit>
        <trans-unit id="202e52fe595d963585538547933f6a4e3cafd0a0" translate="yes" xml:space="preserve">
          <source>This means that whenever the &lt;code&gt;Ecto.Repo.Supervisor&lt;/code&gt; starts, it will emit an event, via &lt;code&gt;:telemetry&lt;/code&gt;, with a measurement of the time at start-up.</source>
          <target state="translated">这意味着每当 &lt;code&gt;Ecto.Repo.Supervisor&lt;/code&gt; 启动时，它都会通过 &lt;code&gt;:telemetry&lt;/code&gt; 发出一个事件，其中包含启动时间。</target>
        </trans-unit>
        <trans-unit id="07a058b3195ea17c39bf63ddac4c41f7f9ee1528" translate="yes" xml:space="preserve">
          <source>This means the plugs in the &lt;code&gt;authenticate_user&lt;/code&gt; and &lt;code&gt;ensure_admin&lt;/code&gt; pipelines will be called before the &lt;code&gt;BackgroundJob.Plug&lt;/code&gt; allowing them to send an appropriate response and halt the request accordingly.</source>
          <target state="translated">这意味着 &lt;code&gt;authenticate_user&lt;/code&gt; 和 &lt;code&gt;ensure_admin&lt;/code&gt; 管道中的插件将在 &lt;code&gt;BackgroundJob.Plug&lt;/code&gt; 之前调用，从而允许它们发送适当的响应并相应地暂停请求。</target>
        </trans-unit>
        <trans-unit id="ee54c80446b3760c6fb0a7486f59b47f284f3002" translate="yes" xml:space="preserve">
          <source>This mimics the behaviour existing in clients.</source>
          <target state="translated">这模仿了客户现有的行为。</target>
        </trans-unit>
        <trans-unit id="c496c6a2b0bd7dfb1281705f319360c782f54b15" translate="yes" xml:space="preserve">
          <source>This module also provides functions to enable a secure environment on transports that, at some point, have access to a &lt;a href=&quot;../plug/1.5.1/plug.conn&quot;&gt;&lt;code&gt;Plug.Conn&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此模块还提供了一些功能，以在传输器上启用安全的环境，该传输器在某些时候可以访问&lt;a href=&quot;../plug/1.5.1/plug.conn&quot;&gt; &lt;code&gt;Plug.Conn&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0f3ec12e95282c603be600f76b1efa0ba48fef74" translate="yes" xml:space="preserve">
          <source>This module also provides functions to enable a secure environment on transports that, at some point, have access to a &lt;a href=&quot;../plug/plug.conn&quot;&gt;&lt;code&gt;Plug.Conn&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此模块还提供了一些功能，以在传输器上启用安全的环境，该传输器在某些时候可以访问&lt;a href=&quot;../plug/plug.conn&quot;&gt; &lt;code&gt;Plug.Conn&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6ebb63837f361cbf03a3796451f4fe31cebbd7a9" translate="yes" xml:space="preserve">
          <source>This module also provides functions to simulate leaving and closing a channel. Once you leave or close a channel, because the channel is linked to the test process on join, it will crash the test process:</source>
          <target state="translated">该模块还提供了模拟离开和关闭通道的功能。一旦离开或关闭通道,由于通道在加入时与测试进程有关联,会使测试进程崩溃。</target>
        </trans-unit>
        <trans-unit id="85f9b5e0210ecd7fadc5d5b219e6eb2289448aaa" translate="yes" xml:space="preserve">
          <source>This module also specifies a behaviour that all the parsers to be used with Plug should adopt.</source>
          <target state="translated">这个模块还指定了所有与Plug一起使用的解析器应该采用的行为。</target>
        </trans-unit>
        <trans-unit id="d9c3143248084cc9c9ababd5b063a0b53a122a9b" translate="yes" xml:space="preserve">
          <source>This module can be &lt;code&gt;use&lt;/code&gt;-d into a module in order to build a plug pipeline:</source>
          <target state="translated">该模块可以 &lt;code&gt;use&lt;/code&gt; -d到一个模块，以建立一个插件管道：</target>
        </trans-unit>
        <trans-unit id="b51e359d7e48f146d0d1e937d9d0255d91dad914" translate="yes" xml:space="preserve">
          <source>This module can be used in your test cases, like this:</source>
          <target state="translated">这个模块可以用在你的测试用例中,像这样。</target>
        </trans-unit>
        <trans-unit id="29fc81812b5b90ffe59423aab0c8bc729d76484f" translate="yes" xml:space="preserve">
          <source>This module defines a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Plug.Conn&lt;/code&gt;&lt;/a&gt; struct and the main functions for working with Plug connections.</source>
          <target state="translated">该模块定义了一个&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Plug.Conn&lt;/code&gt; &lt;/a&gt;结构以及用于处理Plug连接的主要功能。</target>
        </trans-unit>
        <trans-unit id="070196252438bbce61c0f717094acdcf2e81b7f0" translate="yes" xml:space="preserve">
          <source>This module defines a &lt;a href=&quot;plug.conn#content&quot;&gt;&lt;code&gt;Plug.Conn&lt;/code&gt;&lt;/a&gt; struct and the main functions for working with Plug connections.</source>
          <target state="translated">该模块定义了一个&lt;a href=&quot;plug.conn#content&quot;&gt; &lt;code&gt;Plug.Conn&lt;/code&gt; &lt;/a&gt;结构以及使用Plug连接的主要功能。</target>
        </trans-unit>
        <trans-unit id="3a8c2c7d59b4c13115d6ac023bd8ac70e7f55fc3" translate="yes" xml:space="preserve">
          <source>This module describes what is required to build a Phoenix transport. The transport sits between the socket and channels, forwarding client messages to channels and vice-versa.</source>
          <target state="translated">本模块描述了构建Phoenix传输所需的内容。传输位于套接字和通道之间,将客户端消息转发到通道,反之亦然。</target>
        </trans-unit>
        <trans-unit id="1bf3d32030d6f8a66f143a02bbf8343a335a4b15" translate="yes" xml:space="preserve">
          <source>This module documents each of those macros, providing examples in both the keywords query and pipe expression formats.</source>
          <target state="translated">本模块记录了每一个宏,提供了关键字查询和管道表达格式的例子。</target>
        </trans-unit>
        <trans-unit id="a4abc0ee1ab071690365f6c903e68103b59a8146" translate="yes" xml:space="preserve">
          <source>This module is commonly used within a &lt;a href=&quot;plug.builder&quot;&gt;&lt;code&gt;Plug.Builder&lt;/code&gt;&lt;/a&gt; or a &lt;a href=&quot;plug.router&quot;&gt;&lt;code&gt;Plug.Router&lt;/code&gt;&lt;/a&gt; and it wraps the &lt;code&gt;call/2&lt;/code&gt; function.</source>
          <target state="translated">此模块通常在&lt;a href=&quot;plug.builder&quot;&gt; &lt;code&gt;Plug.Builder&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;plug.router&quot;&gt; &lt;code&gt;Plug.Router&lt;/code&gt; 中使用&lt;/a&gt;，并且包装 &lt;code&gt;call/2&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="bf931afdfdb9158aece8ce5e671b27951b8f8dc7" translate="yes" xml:space="preserve">
          <source>This module is deprecated. To use Cowboy 1 With Plug please include &lt;code&gt;plug_cowboy&lt;/code&gt; version 1.0 or above in your &lt;code&gt;mix.exs&lt;/code&gt; file. It is recommended that you use the &lt;code&gt;Plug.Cowboy&lt;/code&gt; module directly instead of Plug.Adapters.Cowboy.</source>
          <target state="translated">不建议使用此模块。要使用牛郎1插头请包括 &lt;code&gt;plug_cowboy&lt;/code&gt; 在版本1.0或以上 &lt;code&gt;mix.exs&lt;/code&gt; 文件。建议您直接使用 &lt;code&gt;Plug.Cowboy&lt;/code&gt; 模块而不是Plug.Adapters.Cowboy。</target>
        </trans-unit>
        <trans-unit id="4a03284231b4c9beab2d0b3147c2e873d6724e04" translate="yes" xml:space="preserve">
          <source>This module is deprecated. To use Cowboy 2 With Plug please include &lt;code&gt;plug_cowboy&lt;/code&gt; version 2.0 or above in your &lt;code&gt;mix.exs&lt;/code&gt; file. It is recommended that you use the &lt;code&gt;Plug.Cowboy&lt;/code&gt; module directly instead of Plug.Adapters.Cowboy2</source>
          <target state="translated">不建议使用此模块。要使用带插件的Cowboy 2，请在 &lt;code&gt;mix.exs&lt;/code&gt; 文件中包含 &lt;code&gt;plug_cowboy&lt;/code&gt; 版本2.0或更高版本。建议您直接使用 &lt;code&gt;Plug.Cowboy&lt;/code&gt; 模块而不是Plug.Adapters.Cowboy2</target>
        </trans-unit>
        <trans-unit id="b1128cd9517be1b80b829d37c77e14445123041b" translate="yes" xml:space="preserve">
          <source>This module is used by Phoenix pubsub adapters to handle their local node subscriptions and it is usually not accessed directly. See &lt;a href=&quot;phoenix.pubsub.pg2&quot;&gt;&lt;code&gt;Phoenix.PubSub.PG2&lt;/code&gt;&lt;/a&gt; for an example integration.</source>
          <target state="translated">Phoenix pubsub适配器使用此模块来处理其本地节点订阅，通常不直接访问它。有关集成示例，请参见&lt;a href=&quot;phoenix.pubsub.pg2&quot;&gt; &lt;code&gt;Phoenix.PubSub.PG2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="18749daab402c4f9221f76b108eba5a09277b12b" translate="yes" xml:space="preserve">
          <source>This module is used to define the application&amp;rsquo;s main view, which serves as the base for all other views and templates.</source>
          <target state="translated">此模块用于定义应用程序的主视图，该视图用作所有其他视图和模板的基础。</target>
        </trans-unit>
        <trans-unit id="6bfcb71b5835a83213d4dfa6ee58017a4845f8d7" translate="yes" xml:space="preserve">
          <source>This module is used to define the application's main view, which serves as the base for all other views and templates.</source>
          <target state="translated">该模块用于定义应用程序的主视图,它是所有其他视图和模板的基础。</target>
        </trans-unit>
        <trans-unit id="0cd0bbb57a64e46e86f20c8dc2b8b74868181cea" translate="yes" xml:space="preserve">
          <source>This module provides conveniences for reading all files from a particular directory and embedding them into a single module. Imagine you have a directory with templates:</source>
          <target state="translated">这个模块提供了从一个特定目录中读取所有文件并将其嵌入到一个模块中的便利。想象一下,你有一个带有模板的目录。</target>
        </trans-unit>
        <trans-unit id="4237a22f395fffa8c90b7f272130e1f9c638e3db" translate="yes" xml:space="preserve">
          <source>This module specifies a behaviour that all sockets must implement. &lt;a href=&quot;phoenix.socket&quot;&gt;&lt;code&gt;Phoenix.Socket&lt;/code&gt;&lt;/a&gt; is just one possible implementation of a socket that multiplexes events over multiple channels. Developers can implement their own sockets as long as they implement the behaviour outlined here.</source>
          <target state="translated">此模块指定所有套接字必须实现的行为。&lt;a href=&quot;phoenix.socket&quot;&gt; &lt;code&gt;Phoenix.Socket&lt;/code&gt; &lt;/a&gt;只是套接字的一种可能的实现，它可以在多个通道上多路复用事件。开发人员可以实现自己的套接字，只要他们实现此处概述的行为即可。</target>
        </trans-unit>
        <trans-unit id="6c536ba16d8fed4f4c995fae380610c356225909" translate="yes" xml:space="preserve">
          <source>This module will be the public API for all account functionality in our system. For example, in addition to user account management, we may also handle user login credentials, account preferences, and password reset generation. If we look at the &lt;code&gt;list_users/0&lt;/code&gt; function, we can see the private details of user fetching. And it's super simple. We have a call to &lt;code&gt;Repo.all(User)&lt;/code&gt;. We saw how Ecto repo queries worked in &lt;a href=&quot;ecto&quot;&gt;the Ecto guide&lt;/a&gt;, so this call should look familiar. Our &lt;code&gt;list_users&lt;/code&gt; function is a generalized function specifying the &lt;em&gt;intent&lt;/em&gt; of our code &amp;ndash; namely to list users. The details of that intent where we use our Repo to fetch the users from our PostgreSQL database is hidden from our callers. This is a common theme we'll see re-iterated as we use the Phoenix generators. Phoenix will push us to think about where we have different responsibilities in our application, and then to wrap up those different areas behind well-named modules and functions that make the intent of our code clear, while encapsulating the details.</source>
          <target state="translated">该模块将成为我们系统中所有帐户功能的公共API。例如，除了用户帐户管理外，我们还可以处理用户登录凭据，帐户首选项和密码重置生成。如果查看 &lt;code&gt;list_users/0&lt;/code&gt; 函数，则可以看到用户获取的私有详细信息。而且非常简单。我们有一个电话给 &lt;code&gt;Repo.all(User)&lt;/code&gt; 。我们在&lt;a href=&quot;ecto&quot;&gt;Ecto指南中&lt;/a&gt;看到了Ecto回购查询的工作原理，因此此调用看起来应该很熟悉。我们的 &lt;code&gt;list_users&lt;/code&gt; 函数是一个通用的函数，用于指定&lt;em&gt;意图&lt;/em&gt;我们的代码&amp;ndash;即列出用户。在调用者中隐藏了使用回购从PostgreSQL数据库中获取用户的意图的详细信息。这是我们使用Phoenix生成器时会再次重申的常见主题。Phoenix将促使我们考虑在应用程序中我们应该承担哪些责任，然后将这些不同的领域包装在命名模块和函数的后面，这些模块和函数使我们的代码意图清晰明了，同时又封装了细节。</target>
        </trans-unit>
        <trans-unit id="e1f8c7a704d8b281a05ab2c2ee94c670ce893f15" translate="yes" xml:space="preserve">
          <source>This must be executed from the process that will effectively operate the socket.</source>
          <target state="translated">这必须从有效操作套接字的进程中执行。</target>
        </trans-unit>
        <trans-unit id="a54461d29fcec4b636adb86f49d11ebedc8a4319" translate="yes" xml:space="preserve">
          <source>This operation uses the query cache if one is available.</source>
          <target state="translated">如果有查询缓存,该操作将使用查询缓存。</target>
        </trans-unit>
        <trans-unit id="2e6392283fe53096fd6723c6a52bb14c1fbe0eee" translate="yes" xml:space="preserve">
          <source>This operation will return the underlying data with changes regardless if the changeset is valid or not.</source>
          <target state="translated">无论更改集是否有效,这个操作都会返回带有更改的基础数据。</target>
        </trans-unit>
        <trans-unit id="049c09158996c650e55b8f1ec4561fa180509070" translate="yes" xml:space="preserve">
          <source>This option assumes the project was generated with the &lt;code&gt;--binary-id&lt;/code&gt; option, that sets up models to use &lt;code&gt;binary_id&lt;/code&gt; by default. If that&amp;rsquo;s not the case you can still set all your models to use &lt;code&gt;binary_id&lt;/code&gt; by default, by adding the following to your &lt;code&gt;model&lt;/code&gt; function in &lt;code&gt;web/web.ex&lt;/code&gt; or before the &lt;code&gt;schema&lt;/code&gt; declaration:</source>
          <target state="translated">该选项假定项目是使用 &lt;code&gt;--binary-id&lt;/code&gt; 选项生成的，默认情况下 &lt;code&gt;binary_id&lt;/code&gt; 模型设置为使用binary_id。如果不是这种情况，您仍然可以将所有模型默认设置为使用 &lt;code&gt;binary_id&lt;/code&gt; ，方法是在 &lt;code&gt;web/web.ex&lt;/code&gt; 中或在 &lt;code&gt;schema&lt;/code&gt; 声明之前在 &lt;code&gt;model&lt;/code&gt; 函数中添加以下内容：</target>
        </trans-unit>
        <trans-unit id="e0391ffae92290b282aabdcb9895807452f2bfe1" translate="yes" xml:space="preserve">
          <source>This option is passed as the &lt;code&gt;:init_mode&lt;/code&gt; to &lt;a href=&quot;plug/plug.builder#compile/3&quot;&gt;&lt;code&gt;Plug.Builder.compile/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该选项作为 &lt;code&gt;:init_mode&lt;/code&gt; 传递给&lt;a href=&quot;plug/plug.builder#compile/3&quot;&gt; &lt;code&gt;Plug.Builder.compile/3&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="60fcee5e8373c0151773e4d41d75fd04ea48fab0" translate="yes" xml:space="preserve">
          <source>This plug also fetches query params in the connection through &lt;a href=&quot;plug.conn#fetch_query_params/2&quot;&gt;&lt;code&gt;Plug.Conn.fetch_query_params/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该插件还通过&lt;a href=&quot;plug.conn#fetch_query_params/2&quot;&gt; &lt;code&gt;Plug.Conn.fetch_query_params/2&lt;/code&gt; &lt;/a&gt;获取连接中的查询参数。</target>
        </trans-unit>
        <trans-unit id="40a4f301d5fad92658d3d0724f2518201be2787a" translate="yes" xml:space="preserve">
          <source>This plug can be mounted in a &lt;a href=&quot;plug.builder&quot;&gt;&lt;code&gt;Plug.Builder&lt;/code&gt;&lt;/a&gt; pipeline as follows:</source>
          <target state="translated">该插件可以按如下方式安装在&lt;a href=&quot;plug.builder&quot;&gt; &lt;code&gt;Plug.Builder&lt;/code&gt; &lt;/a&gt;管道中：</target>
        </trans-unit>
        <trans-unit id="f6cd45326cadd9e10a4b5dcc83af5b2968ec6084" translate="yes" xml:space="preserve">
          <source>This plug doesn&amp;rsquo;t accept any options.</source>
          <target state="translated">该插件不接受任何选项。</target>
        </trans-unit>
        <trans-unit id="50cd1542f80ce2c27c4180007ab1670d825bb257" translate="yes" xml:space="preserve">
          <source>This plug doesn't accept any options.</source>
          <target state="translated">这个插件不接受任何选项。</target>
        </trans-unit>
        <trans-unit id="540542716621eaa96ff36e27e48730d06833088f" translate="yes" xml:space="preserve">
          <source>This plug expects the body parameters to be already parsed and fetched. Those can be fetched with &lt;a href=&quot;plug.parsers&quot;&gt;&lt;code&gt;Plug.Parsers&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该插件期望主体参数已被解析和获取。那些可以通过&lt;a href=&quot;plug.parsers&quot;&gt; &lt;code&gt;Plug.Parsers&lt;/code&gt; &lt;/a&gt;获取。</target>
        </trans-unit>
        <trans-unit id="01da79a8a81b2988c34c2c491464c98d17827644" translate="yes" xml:space="preserve">
          <source>This plug only parses the body if the request method is one of the following:</source>
          <target state="translated">这个插件只在请求方法为以下之一时才会解析body。</target>
        </trans-unit>
        <trans-unit id="dbc4a6cf27af703236d09b35d3f5b453a3411f43" translate="yes" xml:space="preserve">
          <source>This plug overrides the request&amp;rsquo;s &lt;code&gt;POST&lt;/code&gt; method with the method defined in the &lt;code&gt;_method&lt;/code&gt; request parameter.</source>
          <target state="translated">该插件使用 &lt;code&gt;_method&lt;/code&gt; request参数中定义的方法覆盖请求的 &lt;code&gt;POST&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="f9183cda5f0f143ddaa1b79b7dc207c527edb3d2" translate="yes" xml:space="preserve">
          <source>This plug overrides the request's &lt;code&gt;POST&lt;/code&gt; method with the method defined in the &lt;code&gt;_method&lt;/code&gt; request parameter.</source>
          <target state="translated">该插件使用 &lt;code&gt;_method&lt;/code&gt; request参数中定义的方法覆盖请求的 &lt;code&gt;POST&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="9cbb2239965b1d685814f5586def8ff4895965d5" translate="yes" xml:space="preserve">
          <source>This plug will raise &lt;a href=&quot;plug.parsers.unsupportedmediatypeerror&quot;&gt;&lt;code&gt;Plug.Parsers.UnsupportedMediaTypeError&lt;/code&gt;&lt;/a&gt; by default if the request cannot be parsed by any of the given types and the MIME type has not been explicitly accepted with the &lt;code&gt;:pass&lt;/code&gt; option.</source>
          <target state="translated">如果该请求无法通过任何给定类型进行解析，并且 &lt;code&gt;:pass&lt;/code&gt; 选项未明确接受MIME类型，则默认情况下，此插件将引发&lt;a href=&quot;plug.parsers.unsupportedmediatypeerror&quot;&gt; &lt;code&gt;Plug.Parsers.UnsupportedMediaTypeError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="662ed6e00ff1f8efa3e545b88277587544f54665" translate="yes" xml:space="preserve">
          <source>This plug will raise &lt;a href=&quot;plug.parsers.unsupportedmediatypeerror&quot;&gt;&lt;code&gt;Plug.Parsers.UnsupportedMediaTypeError&lt;/code&gt;&lt;/a&gt; by default if the request cannot be parsed by any of the given types and the MIME type has not been explicity accepted with the &lt;code&gt;:pass&lt;/code&gt; option.</source>
          <target state="translated">如果该请求无法通过任何给定类型进行解析，并且 &lt;code&gt;:pass&lt;/code&gt; 选项未明确接受MIME类型，则默认情况下，此插件将引发&lt;a href=&quot;plug.parsers.unsupportedmediatypeerror&quot;&gt; &lt;code&gt;Plug.Parsers.UnsupportedMediaTypeError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="20bad4ce825285978d82d9c5c3e6eb11442c40e0" translate="yes" xml:space="preserve">
          <source>This plug won&amp;rsquo;t generate tokens automatically. Instead, tokens will be generated only when required by calling &lt;a href=&quot;#get_csrf_token/0&quot;&gt;&lt;code&gt;get_csrf_token/0&lt;/code&gt;&lt;/a&gt;. In case you are generating the token for certain specific URL, you should use &lt;a href=&quot;#get_csrf_token_for/1&quot;&gt;&lt;code&gt;get_csrf_token_for/1&lt;/code&gt;&lt;/a&gt; as that will avoid tokens from being leaked to other applications.</source>
          <target state="translated">该插件不会自动生成令牌。而是仅在需要时通过调用&lt;a href=&quot;#get_csrf_token/0&quot;&gt; &lt;code&gt;get_csrf_token/0&lt;/code&gt; &lt;/a&gt;生成令牌。如果您要为某些特定的URL生成令牌，则应使用&lt;a href=&quot;#get_csrf_token_for/1&quot;&gt; &lt;code&gt;get_csrf_token_for/1&lt;/code&gt; ,&lt;/a&gt;因为这样可以避免令牌泄漏到其他应用程序。</target>
        </trans-unit>
        <trans-unit id="ebbff7ffc8f75e2adf94800f3c930587cc10fe90" translate="yes" xml:space="preserve">
          <source>This plug won't generate tokens automatically. Instead, tokens will be generated only when required by calling &lt;a href=&quot;#get_csrf_token/0&quot;&gt;&lt;code&gt;get_csrf_token/0&lt;/code&gt;&lt;/a&gt;. In case you are generating the token for certain specific URL, you should use &lt;a href=&quot;#get_csrf_token_for/1&quot;&gt;&lt;code&gt;get_csrf_token_for/1&lt;/code&gt;&lt;/a&gt; as that will avoid tokens from being leaked to other applications.</source>
          <target state="translated">该插件不会自动生成令牌。而是仅在需要时通过调用&lt;a href=&quot;#get_csrf_token/0&quot;&gt; &lt;code&gt;get_csrf_token/0&lt;/code&gt; &lt;/a&gt;生成令牌。如果您要为某些特定的URL生成令牌，则应使用&lt;a href=&quot;#get_csrf_token_for/1&quot;&gt; &lt;code&gt;get_csrf_token_for/1&lt;/code&gt; ,&lt;/a&gt;因为这样可以避免令牌泄漏到其他应用程序。</target>
        </trans-unit>
        <trans-unit id="e5c4c29b3d1afbe8ceed819dcb85452fb4b99844" translate="yes" xml:space="preserve">
          <source>This presents a problem, however: only privileged processes can bind to TCP port numbers under 1024, and it is bad idea to run the application as 'root'.</source>
          <target state="translated">但这带来了一个问题:只有特权进程才能绑定到1024以下的TCP端口号,而且以 &quot;root &quot;身份运行应用程序是个坏主意。</target>
        </trans-unit>
        <trans-unit id="9d38ed574d39239d3ce1ee54fa402c6b77436c31" translate="yes" xml:space="preserve">
          <source>This process is two-fold:</source>
          <target state="translated">这个过程有两个方面。</target>
        </trans-unit>
        <trans-unit id="a867af678f59d04d7a0076e28e130a1a90e313f4" translate="yes" xml:space="preserve">
          <source>This protocol is used by URL helpers and other parts of the Phoenix stack. For example, when you write:</source>
          <target state="translated">这个协议被URL助手和Phoenix栈的其他部分使用。例如,当你写。</target>
        </trans-unit>
        <trans-unit id="b21ceddd638e1843ee72cb36616db0e5a04aafff" translate="yes" xml:space="preserve">
          <source>This storage is meant to be used by libraries and frameworks to avoid writing to the user storage (the &lt;code&gt;:assigns&lt;/code&gt; field). It is recommended for libraries/frameworks to prefix the keys with the library name.</source>
          <target state="translated">库和框架将使用此存储来避免写入用户存储（ &lt;code&gt;:assigns&lt;/code&gt; 字段）。对于库/框架，建议在库名称之前添加键。</target>
        </trans-unit>
        <trans-unit id="bcee46e9d2a4acc15bb7cd9f93742faef542611d" translate="yes" xml:space="preserve">
          <source>This store does not create the ETS table; it expects that an existing named table with public properties is passed as an argument.</source>
          <target state="translated">这个存储并不创建ETS表;它期望将一个具有公共属性的现有命名表作为参数传递。</target>
        </trans-unit>
        <trans-unit id="625b9c2d872b70c5c1c2329e2373298bcd36763e" translate="yes" xml:space="preserve">
          <source>This store, however, can be used as an example for creating custom storages, based on Redis, Memcached, or a database itself.</source>
          <target state="translated">然而,这个存储可以作为创建自定义存储的例子,基于Redis、Memcached或数据库本身。</target>
        </trans-unit>
        <trans-unit id="caef9692752dfc364ac9616409959d533077b374" translate="yes" xml:space="preserve">
          <source>This task accepts the same command-line arguments as &lt;code&gt;run&lt;/code&gt;. For additional information, refer to the documentation for &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Run.html&quot;&gt;&lt;code&gt;Mix.Tasks.Run&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此任务接受与 &lt;code&gt;run&lt;/code&gt; 相同的命令行参数。有关更多信息，请参考&lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Run.html&quot;&gt; &lt;code&gt;Mix.Tasks.Run&lt;/code&gt; &lt;/a&gt;的文档。</target>
        </trans-unit>
        <trans-unit id="4685cbdc9dfbc82df635ef6b5492cf1beef5ab7b" translate="yes" xml:space="preserve">
          <source>This task does two things, it creates a digest for our static assets and then compresses them.</source>
          <target state="translated">这个任务要做两件事,它为我们的静态资产创建一个摘要,然后压缩它们。</target>
        </trans-unit>
        <trans-unit id="c3709bb1a06688cab88fd712fbb47b0071d18988" translate="yes" xml:space="preserve">
          <source>This task has a single purpose, to show us all the routes defined for a given router. We saw it used extensively in the &lt;a href=&quot;routing&quot;&gt;Routing Guide&lt;/a&gt;.</source>
          <target state="translated">该任务只有一个目的，向我们展示为给定路由器定义的所有路由。我们在&amp;ldquo;&lt;a href=&quot;routing&quot;&gt;路由指南&amp;rdquo;中&lt;/a&gt;看到了它的广泛使用。</target>
        </trans-unit>
        <trans-unit id="7ffde0bcebb123a904c4c4eeafe54e75892f6516" translate="yes" xml:space="preserve">
          <source>This task is intended to create a bare Ecto project without web integration, which serves as a core application of your domain for web applications and your greater umbrella platform to integrate with.</source>
          <target state="translated">这个任务的目的是创建一个没有Web集成的裸Ecto项目,它作为你的领域的核心应用,用于Web应用和你的大伞平台的集成。</target>
        </trans-unit>
        <trans-unit id="b654c66530201e2da733b3ab537a9860c5fdd5a9" translate="yes" xml:space="preserve">
          <source>This task is intended to create a bare Phoenix project without database integration, which interfaces with your greater umbrella application(s).</source>
          <target state="translated">该任务旨在创建一个没有数据库集成的裸Phoenix项目,该项目与您的大伞形应用程序接口。</target>
        </trans-unit>
        <trans-unit id="616b0415ae742d1d7d15218ab99e676b4a35f1b7" translate="yes" xml:space="preserve">
          <source>This task will create the database specified in our repo. By default it will look for the repo named after our application (the one generated with our app unless we opted out of ecto), but we can pass in another repo if we want.</source>
          <target state="translated">这个任务将创建我们repo中指定的数据库。默认情况下,它会寻找以我们的应用程序命名的 repo(除非我们选择退出 ecto),但如果我们想要的话,也可以传入其他 repo。</target>
        </trans-unit>
        <trans-unit id="8cc7b8c4356e5eb337a5225b8d22d082a6a6a76d" translate="yes" xml:space="preserve">
          <source>This task will drop the database specified in our repo. By default it will look for the repo named after our application (the one generated with our app unless we opted out of ecto). It will not prompt us to check if we're sure we want to drop the db, so do exercise caution.</source>
          <target state="translated">这个任务将删除我们的repo中指定的数据库。默认情况下,它会寻找以我们的应用程序命名的 repo(除非我们选择退出 ecto)。它不会提示我们检查我们是否确定要删除数据库,所以请谨慎行事。</target>
        </trans-unit>
        <trans-unit id="409b40ea015d00380841d68310ab0678da039272" translate="yes" xml:space="preserve">
          <source>This task will generate a Presence tracker. The module name can be passed as an argument, &lt;code&gt;Presence&lt;/code&gt; is used if no module name is passed.</source>
          <target state="translated">此任务将生成一个状态跟踪器。模块名称可以作为参数被传递， &lt;code&gt;Presence&lt;/code&gt; 如果没有模块名称被传递时使用。</target>
        </trans-unit>
        <trans-unit id="c6d1b8cbdd20775d05499dc18c230d380cd892e5" translate="yes" xml:space="preserve">
          <source>This task will generate a basic Phoenix channel as well a test case for it. It takes the module name for the channel as argument:</source>
          <target state="translated">这个任务将生成一个基本的Phoenix通道以及一个测试用例。它将通道的模块名称作为参数。</target>
        </trans-unit>
        <trans-unit id="890ecd7a0ef9885062476b818cf0b34cea8d84a4" translate="yes" xml:space="preserve">
          <source>This time around, we used &lt;a href=&quot;mix.tasks.phx.gen.context&quot;&gt;&lt;code&gt;mix phx.gen.context&lt;/code&gt;&lt;/a&gt;, which is just like &lt;a href=&quot;mix.tasks.phx.gen.html&quot;&gt;&lt;code&gt;mix phx.gen.html&lt;/code&gt;&lt;/a&gt;, except it doesn't generate the web files for us. Since we already have controllers and templates for managing users, we can integrate the new credential features into our existing web form.</source>
          <target state="translated">这次，我们使用&lt;a href=&quot;mix.tasks.phx.gen.context&quot;&gt; &lt;code&gt;mix phx.gen.context&lt;/code&gt; &lt;/a&gt;，就像&lt;a href=&quot;mix.tasks.phx.gen.html&quot;&gt; &lt;code&gt;mix phx.gen.html&lt;/code&gt; 一样&lt;/a&gt;，除了它不会为我们生成Web文件。由于我们已经具有用于管理用户的控制器和模板，因此我们可以将新的凭据功能集成到我们现有的Web表单中。</target>
        </trans-unit>
        <trans-unit id="db029b73bc27a4de904b6e1ad6e35f7d5b2ddda5" translate="yes" xml:space="preserve">
          <source>This time we passed the &lt;code&gt;--web&lt;/code&gt; option to the generator. This tells Phoenix what namespace to use for the web modules, such as controllers and views. This is useful when you have conflicting resources in the system, such as our existing &lt;code&gt;PageController&lt;/code&gt;, as well as a way to naturally namespace paths and functionality of different features, like a CMS system. Phoenix instructed us to add a new &lt;code&gt;scope&lt;/code&gt; to the router for a &lt;code&gt;&quot;/cms&quot;&lt;/code&gt; path prefix. Let's copy paste the following into our &lt;code&gt;lib/hello_web/router.ex&lt;/code&gt;, but we'll make one modification to the &lt;code&gt;pipe_through&lt;/code&gt; macro:</source>
          <target state="translated">这次我们将 &lt;code&gt;--web&lt;/code&gt; 选项传递给了生成器。这将告诉Phoenix用于Web模块（例如控制器和视图）的名称空间。当您在系统中有冲突的资源（例如我们现有的 &lt;code&gt;PageController&lt;/code&gt; ）以及自然地命名空间路径和其他功能（例如CMS系统）功能的方法时，此功能很有用。 Phoenix指示我们为路由器添加一个 &lt;code&gt;&quot;/cms&quot;&lt;/code&gt; 路径前缀的新 &lt;code&gt;scope&lt;/code&gt; 。让我们将以下内容复制粘贴到我们的 &lt;code&gt;lib/hello_web/router.ex&lt;/code&gt; 中，但是我们将对 &lt;code&gt;pipe_through&lt;/code&gt; 宏进行一次修改：</target>
        </trans-unit>
        <trans-unit id="d5878eb3c414b2f8b0bc85b921219b0b8c00c144" translate="yes" xml:space="preserve">
          <source>This validation is used to check for one specific parameter being true and as such does not require the field to effectively exist in the schema or the data being validated.</source>
          <target state="translated">这种验证用于检查一个特定的参数是否为真,因此不需要该字段在模式或被验证的数据中有效存在。</target>
        </trans-unit>
        <trans-unit id="d696deb31d0b50d9d5193d12918eed93ff0a69c5" translate="yes" xml:space="preserve">
          <source>This will allow you to cast and update only the association for the given country. The important point for partial changes is that any addresses, which were not preloaded won&amp;rsquo;t be changed.</source>
          <target state="translated">这样，您就可以仅投射和更新给定国家/地区的关联。进行部分更改的要点是，任何未预加载的地址都不会更改。</target>
        </trans-unit>
        <trans-unit id="a25d158d0047cb15049aa3798895382c7cd6f354" translate="yes" xml:space="preserve">
          <source>This will allow you to cast and update only the association for the given country. The important point for partial changes is that any addresses, which were not preloaded won't be changed.</source>
          <target state="translated">这将允许你只投递和更新给定国家的关联。部分更改的重要一点是,任何没有预装的地址都不会被更改。</target>
        </trans-unit>
        <trans-unit id="96c8ad2e97ff0533cdfdce33b58a986331978807" translate="yes" xml:space="preserve">
          <source>This will force the token to be deleted once the response is sent.</source>
          <target state="translated">这将在发送响应后强制删除令牌。</target>
        </trans-unit>
        <trans-unit id="c6845572f50f3240fbaa36674696b8cf400c3eda" translate="yes" xml:space="preserve">
          <source>This will result in a migration with an &lt;code&gt;:integer&lt;/code&gt; column of &lt;code&gt;:user_id&lt;/code&gt; and create an index.</source>
          <target state="translated">这将导致使用 &lt;code&gt;:user_id&lt;/code&gt; 的 &lt;code&gt;:integer&lt;/code&gt; 列进行迁移并创建索引。</target>
        </trans-unit>
        <trans-unit id="cde93bead76f590b8ac92f4411245903df6471af" translate="yes" xml:space="preserve">
          <source>This will result in a migration with an &lt;code&gt;:integer&lt;/code&gt; column of &lt;code&gt;:user_id&lt;/code&gt; and create an index. It will also generate the appropriate &lt;code&gt;belongs_to&lt;/code&gt; entry in the schema.</source>
          <target state="translated">这将导致使用 &lt;code&gt;:user_id&lt;/code&gt; 的 &lt;code&gt;:integer&lt;/code&gt; 列进行迁移并创建索引。它还将在模式中生成适当的 &lt;code&gt;belongs_to&lt;/code&gt; 条目。</target>
        </trans-unit>
        <trans-unit id="7e29ee867b8709dab14972a2f1549cbc060ff5db" translate="yes" xml:space="preserve">
          <source>This will set up all the correct dependencies and configuration for us automatically. Once we install those dependencies with &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Deps.Get.html&quot;&gt;&lt;code&gt;mix deps.get&lt;/code&gt;&lt;/a&gt;, we'll be ready to begin working with Ecto in our application.</source>
          <target state="translated">这将自动为我们设置所有正确的依赖关系和配置。一旦使用&lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Deps.Get.html&quot;&gt; &lt;code&gt;mix deps.get&lt;/code&gt; &lt;/a&gt;安装了这些依赖关系，就可以开始在应用程序中使用Ecto了。</target>
        </trans-unit>
        <trans-unit id="0c4b144557001b546396a316d80e5ba0955281ab" translate="yes" xml:space="preserve">
          <source>This works because both &quot;index.json&quot; and &quot;show.json&quot; builds themselves on top of an internal &quot;page.json&quot; clause.</source>
          <target state="translated">这是因为 &quot;index.json &quot;和 &quot;show.json &quot;都是在内部的 &quot;page.json &quot;子句上建立自己的。</target>
        </trans-unit>
        <trans-unit id="c5fe4ec7110a029f93aee2c49d16dd655e8fb777" translate="yes" xml:space="preserve">
          <source>Those are a lot of words bunched up together. Let's take a look at some examples to untangle their meaning.</source>
          <target state="translated">这几个字是很多字捆绑在一起的。我们来看看一些例子,解开它们的意思。</target>
        </trans-unit>
        <trans-unit id="36a1b1b32231c3e4ff53add950295c72883cbbfb" translate="yes" xml:space="preserve">
          <source>Those functions are imported from two modules:</source>
          <target state="translated">这些功能是从两个模块导入的。</target>
        </trans-unit>
        <trans-unit id="6208b0413cd71b1dcc6adedd2bd128dd9d87591a" translate="yes" xml:space="preserve">
          <source>Those guards work like regular Elixir guards and the only variables accessible in the guard are &lt;code&gt;conn&lt;/code&gt;, the &lt;code&gt;action&lt;/code&gt; as an atom and the &lt;code&gt;controller&lt;/code&gt; as an alias.</source>
          <target state="translated">这些守卫像常规的Elixir守卫一样工作，并且在守卫中唯一可访问的变量是 &lt;code&gt;conn&lt;/code&gt; ，作为原子的 &lt;code&gt;action&lt;/code&gt; 和作为别名的 &lt;code&gt;controller&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f149875499b6816d281bb93f8f7b7be48949a3a5" translate="yes" xml:space="preserve">
          <source>Those values can now be accessed on the connected mount as &lt;a href=&quot;#get_connect_info/1&quot;&gt;&lt;code&gt;get_connect_info/1&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">这些值现在可以作为&lt;a href=&quot;#get_connect_info/1&quot;&gt; &lt;code&gt;get_connect_info/1&lt;/code&gt; &lt;/a&gt;在连接的挂载上访问：</target>
        </trans-unit>
        <trans-unit id="c33c34b9d82c886b7a72a0d75a72202741c4d268" translate="yes" xml:space="preserve">
          <source>Through &lt;em&gt;telemetry&lt;/em&gt;, Phoenix is able to collect metrics and send monitoring events of your application. The &lt;code&gt;lib/hello_web/telemetry.ex&lt;/code&gt; file defines the supervisor responsible for managing the telemetry processes. You can find more information on this topic in the &lt;a href=&quot;telemetry&quot;&gt;Telemetry guide&lt;/a&gt;.</source>
          <target state="translated">通过&lt;em&gt;遥测&lt;/em&gt;，Phoenix能够收集指标并发送应用程序的监视事件。该 &lt;code&gt;lib/hello_web/telemetry.ex&lt;/code&gt; 文件定义负责管理遥测过程监事。您可以在&lt;a href=&quot;telemetry&quot;&gt;遥测指南中&lt;/a&gt;找到有关此主题的更多信息。</target>
        </trans-unit>
        <trans-unit id="a630c7d1a3b50b97144115174bddba022d807367" translate="yes" xml:space="preserve">
          <source>Time unit</source>
          <target state="translated">时间单位</target>
        </trans-unit>
        <trans-unit id="39d358d22755c113807898f4d747028acc84c714" translate="yes" xml:space="preserve">
          <source>Timeout while waiting for the request.</source>
          <target state="translated">等待请求时超时。</target>
        </trans-unit>
        <trans-unit id="e399371341816e13494a8f090bb6bc62bee13531" translate="yes" xml:space="preserve">
          <source>To aid debugging on the client when troubleshooting issues, the &lt;code&gt;enableDebug()&lt;/code&gt; and &lt;code&gt;disableDebug()&lt;/code&gt; functions are exposed on the &lt;code&gt;LiveSocket&lt;/code&gt; JavaScript instance. Calling &lt;code&gt;enableDebug()&lt;/code&gt; turns on debug logging which includes LiveView life-cycle and payload events as they come and go from client to server. In practice, you can expose your instance on &lt;code&gt;window&lt;/code&gt; for quick access in the browser's web console, for example:</source>
          <target state="translated">为了在对问题进行故障排除时帮助在客户端上进行调试，在 &lt;code&gt;LiveSocket&lt;/code&gt; JavaScript实例上公开了 &lt;code&gt;enableDebug()&lt;/code&gt; 和 &lt;code&gt;disableDebug()&lt;/code&gt; 函数。调用 &lt;code&gt;enableDebug()&lt;/code&gt; 会打开调试日志记录，其中包括LiveView生命周期和有效负载事件（从客户端到服务器的往返）。实际上，您可以在 &lt;code&gt;window&lt;/code&gt; 上显示您的实例以在浏览器的Web控制台中快速访问，例如：</target>
        </trans-unit>
        <trans-unit id="4909edd3c35b1902875bfd0c83e9c081850f71db" translate="yes" xml:space="preserve">
          <source>To allow the user to download contents that are in memory as a binary or string:</source>
          <target state="translated">允许用户下载内存中的二进制或字符串内容。</target>
        </trans-unit>
        <trans-unit id="e6a6975b062fa8a73779dc6d912719d7498131ee" translate="yes" xml:space="preserve">
          <source>To assert that your channel closes or errors asynchronously, you can monitor the channel process with the tools provided by Elixir, and wait for the &lt;code&gt;:DOWN&lt;/code&gt; message. Imagine an implementation of the &lt;code&gt;handle_info/2&lt;/code&gt; function that closes the channel when it receives &lt;code&gt;:some_message&lt;/code&gt;:</source>
          <target state="translated">要断言您的频道异步关闭或错误，可以使用Elixir提供的工具监视频道进程，并等待 &lt;code&gt;:DOWN&lt;/code&gt; 消息。想象一下 &lt;code&gt;handle_info/2&lt;/code&gt; 函数的实现，该函数在收到 &lt;code&gt;:some_message&lt;/code&gt; 时将其关闭：</target>
        </trans-unit>
        <trans-unit id="53a832ff355a8bff56d545715860a666b9283a42" translate="yes" xml:space="preserve">
          <source>To authorize a socket in &lt;code&gt;join/3&lt;/code&gt;, return &lt;code&gt;{:ok, socket}&lt;/code&gt;. To refuse authorization in &lt;code&gt;join/3&lt;/code&gt;, return &lt;code&gt;{:error, reply}&lt;/code&gt;.</source>
          <target state="translated">要在 &lt;code&gt;join/3&lt;/code&gt; 中授权套接字，请返回 &lt;code&gt;{:ok, socket}&lt;/code&gt; 。要拒绝 &lt;code&gt;join/3&lt;/code&gt; 中的授权，请返回 &lt;code&gt;{:error, reply}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="de3aa50e1fa13ab8540858290ff3bab5cc1ae7a1" translate="yes" xml:space="preserve">
          <source>To authorize a socket, return &lt;code&gt;{:ok, socket}&lt;/code&gt; or &lt;code&gt;{:ok, reply, socket}&lt;/code&gt;. To refuse authorization, return &lt;code&gt;{:error, reason}&lt;/code&gt;.</source>
          <target state="translated">要授权套接字，请返回 &lt;code&gt;{:ok, socket}&lt;/code&gt; 或 &lt;code&gt;{:ok, reply, socket}&lt;/code&gt; 。要拒绝授权，请返回 &lt;code&gt;{:error, reason}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="68caf8123fc9000c1892d49a830e2a777c1a2f79" translate="yes" xml:space="preserve">
          <source>To avoid race conditions, all code reloads are funneled through a sequential call operation.</source>
          <target state="translated">为了避免竞赛条件,所有的代码重载都是通过顺序调用操作来漏斗的。</target>
        </trans-unit>
        <trans-unit id="8adf099970e8f40f42c4a78cc8072bacf109f61f" translate="yes" xml:space="preserve">
          <source>To avoid the repetition of always specifying the types, you may define an &lt;a href=&quot;ecto.schema&quot;&gt;&lt;code&gt;Ecto.Schema&lt;/code&gt;&lt;/a&gt;. In such cases, Ecto will analyze your queries and automatically cast the interpolated &quot;age&quot; when compared to the &lt;code&gt;u.age&lt;/code&gt; field, as long as the age field is defined with type &lt;code&gt;:integer&lt;/code&gt; in your schema:</source>
          <target state="translated">为了避免总是指定类型的重复，可以定义&lt;a href=&quot;ecto.schema&quot;&gt; &lt;code&gt;Ecto.Schema&lt;/code&gt; &lt;/a&gt;。在这种情况下，外生会分析你的查询和自动投插值&amp;ldquo;年龄&amp;rdquo;时相比 &lt;code&gt;u.age&lt;/code&gt; 场，只要年龄字段类型定义 &lt;code&gt;:integer&lt;/code&gt; 模式中的：</target>
        </trans-unit>
        <trans-unit id="4da79393192b9d811f048b628589434c69cfc70f" translate="yes" xml:space="preserve">
          <source>To avoid the repetition of always specifying the types, you may define an &lt;a href=&quot;ecto.schema&quot;&gt;&lt;code&gt;Ecto.Schema&lt;/code&gt;&lt;/a&gt;. In such cases, Ecto will analyze your queries and automatically cast the interpolated &amp;ldquo;age&amp;rdquo; when compared to the &lt;code&gt;u.age&lt;/code&gt; field, as long as the age field is defined with type &lt;code&gt;:integer&lt;/code&gt; in your schema:</source>
          <target state="translated">为了避免总是指定类型的重复，可以定义&lt;a href=&quot;ecto.schema&quot;&gt; &lt;code&gt;Ecto.Schema&lt;/code&gt; &lt;/a&gt;。在这种情况下，外生会分析你的查询和自动投插值&amp;ldquo;年龄&amp;rdquo;时相比 &lt;code&gt;u.age&lt;/code&gt; 场，只要年龄字段类型定义 &lt;code&gt;:integer&lt;/code&gt; 模式中的：</target>
        </trans-unit>
        <trans-unit id="8207ca543301d2f877c271b7b261d6d50b3481d1" translate="yes" xml:space="preserve">
          <source>To capture additional user-defined metadata, the &lt;code&gt;metadata&lt;/code&gt; option for keydown events may be provided to the &lt;code&gt;LiveSocket&lt;/code&gt; constructor. For example:</source>
          <target state="translated">为了捕获其他用户定义的元数据，可以将用于 &lt;code&gt;LiveSocket&lt;/code&gt; 事件的 &lt;code&gt;metadata&lt;/code&gt; 选项提供给LiveSocket构造函数。例如：</target>
        </trans-unit>
        <trans-unit id="671a861e30e1350c320f440b81de252cf52633f6" translate="yes" xml:space="preserve">
          <source>To check if a given value is not nil use:</source>
          <target state="translated">要检查一个给定的值是否不是nil,使用。</target>
        </trans-unit>
        <trans-unit id="01fee11f0023eae7979272d215e7845252d7aad1" translate="yes" xml:space="preserve">
          <source>To check that we are on Elixir 1.6 and Erlang 20 or later, run:</source>
          <target state="translated">要检查我们是否使用Elixir 1.6和Erlang 20或更高版本,运行。</target>
        </trans-unit>
        <trans-unit id="79d31d5fab3f480e2385850ab0894e631ce9ef5d" translate="yes" xml:space="preserve">
          <source>To complete the web changes, let's display the author when showing a page. First, open up &lt;code&gt;lib/hello_web/views/cms/page_view.ex&lt;/code&gt; and add a helper function to handle formatting the author's name:</source>
          <target state="translated">要完成网络更改，请在显示页面时显示作者。首先，打开 &lt;code&gt;lib/hello_web/views/cms/page_view.ex&lt;/code&gt; 并添加一个辅助函数来处理作者姓名的格式：</target>
        </trans-unit>
        <trans-unit id="c397997817b65b5ed32d80d0da887e047de03d3c" translate="yes" xml:space="preserve">
          <source>To convert a single DER-encoded certificate to PEM format: &lt;code&gt;openssl x509 -in server.crt -inform der -out cert.pem&lt;/code&gt;</source>
          <target state="translated">要将单个DER编码的证书转换为PEM格式： &lt;code&gt;openssl x509 -in server.crt -inform der -out cert.pem&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="21c91ab4294a0c1228f999e655eeea2400a408db" translate="yes" xml:space="preserve">
          <source>To convert an RSA private key from DER to PEM format: &lt;code&gt;openssl rsa -in privkey.der -inform der -out privkey.pem&lt;/code&gt;. If the private key is a Elliptic Curve key, for use with an ECDSA certificate, replace &lt;code&gt;rsa&lt;/code&gt; with &lt;code&gt;ec&lt;/code&gt;. You may want to add the &lt;code&gt;-aes128&lt;/code&gt; argument to produce an encrypted, password protected PEM file.</source>
          <target state="translated">要将RSA私钥从DER转换为PEM格式，请执行以下操作： &lt;code&gt;openssl rsa -in privkey.der -inform der -out privkey.pem&lt;/code&gt; 。如果私钥是椭圆曲线密钥（用于ECDSA证书），则将 &lt;code&gt;rsa&lt;/code&gt; 替换为 &lt;code&gt;ec&lt;/code&gt; 。您可能需要添加 &lt;code&gt;-aes128&lt;/code&gt; 参数来生成加密的，受密码保护的PEM文件。</target>
        </trans-unit>
        <trans-unit id="5971dfca497a6c6184fac2256a6394332e77294b" translate="yes" xml:space="preserve">
          <source>To create a parameterized type, create a module as shown below:</source>
          <target state="translated">要创建一个参数化类型,请创建一个模块,如下图所示。</target>
        </trans-unit>
        <trans-unit id="32b59c202fb3d6f550fc3db4a98cf2a4a434dded" translate="yes" xml:space="preserve">
          <source>To customize the JSON library, including the following in your &lt;code&gt;config/config.exs&lt;/code&gt;:</source>
          <target state="translated">要自定义JSON库，包括 &lt;code&gt;config/config.exs&lt;/code&gt; 中的以下内容：</target>
        </trans-unit>
        <trans-unit id="bf7347e6fe2acbe195851637b64939807583f935" translate="yes" xml:space="preserve">
          <source>To deny connection, return &lt;code&gt;:error&lt;/code&gt;.</source>
          <target state="translated">要拒绝连接，请返回 &lt;code&gt;:error&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2be30a876faae18a5e22e23e0ff825ea8e07d2e2" translate="yes" xml:space="preserve">
          <source>To detect when the page itself has received focus or blur, &lt;code&gt;phx-window-focus&lt;/code&gt; and &lt;code&gt;phx-window-blur&lt;/code&gt; may be specified. These window level events may also be necessary if the element in consideration (most often a &lt;code&gt;div&lt;/code&gt; with no tabindex) cannot receive focus. Like other bindings, &lt;code&gt;phx-value-*&lt;/code&gt; can be provided on the bound element, and those values will be sent as part of the payload. For example:</source>
          <target state="translated">为了检测页面本身何时获得焦点或模糊，可以指定 &lt;code&gt;phx-window-focus&lt;/code&gt; 和 &lt;code&gt;phx-window-blur&lt;/code&gt; 。如果所考虑的元素（通常是没有tabindex的 &lt;code&gt;div&lt;/code&gt; ）无法获得焦点，则这些窗口级事件也可能是必需的。像其他绑定一样，可以在绑定元素上提供 &lt;code&gt;phx-value-*&lt;/code&gt; ，这些值将作为有效负载的一部分发送。例如：</target>
        </trans-unit>
        <trans-unit id="698f42b33364629b9c00b1979a5fc7ddebd7d515" translate="yes" xml:space="preserve">
          <source>To determine which key has been pressed you should use &lt;code&gt;key&lt;/code&gt; value. The available options can be found on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values&quot;&gt;MDN&lt;/a&gt; or via the &lt;a href=&quot;https://w3c.github.io/uievents/tools/key-event-viewer.html&quot;&gt;Key Event Viewer&lt;/a&gt;.</source>
          <target state="translated">要确定按下了哪个键，您应该使用 &lt;code&gt;key&lt;/code&gt; 。可用的选项可以在&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values&quot;&gt;MDN&lt;/a&gt;上找到，也可以通过&amp;ldquo;&lt;a href=&quot;https://w3c.github.io/uievents/tools/key-event-viewer.html&quot;&gt;按键事件查看器&amp;rdquo;找到&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9ee4e1597fac73b7cdbd9aafc8a4cfde3cac889d" translate="yes" xml:space="preserve">
          <source>To discuss new features in the framework, email the &lt;a href=&quot;https://groups.google.com/group/phoenix-core&quot;&gt;phoenix-core mailing list&lt;/a&gt;.</source>
          <target state="translated">要讨论该框架中的新功能，请发送电子邮件给&lt;a href=&quot;https://groups.google.com/group/phoenix-core&quot;&gt;phoenix-core邮件列表&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="50ac5d4ffcf89463b90bde0bceaf630200030aa1" translate="yes" xml:space="preserve">
          <source>To do so, the first step is to mark which assigns are temporary and what values they should be reset to on mount:</source>
          <target state="translated">要做到这一点,第一步是标记哪些赋值是临时性的,以及在挂载时应该重置为什么值。</target>
        </trans-unit>
        <trans-unit id="75f92de1c10aadb6a962f6da37154da77404e61e" translate="yes" xml:space="preserve">
          <source>To do that, we'll use the special EEx tags for executing Elixir expressions - &lt;code&gt;&amp;lt;%= %&amp;gt;&lt;/code&gt;. Notice that the initial tag has an equals sign like this: &lt;code&gt;&amp;lt;%=&lt;/code&gt; . That means that any Elixir code that goes between those tags will be executed, and the resulting value will replace the tag. If the equals sign were missing, the code would still be executed, but the value would not appear on the page.</source>
          <target state="translated">为此，我们将使用特殊的EEx标记执行Elixir表达式- &lt;code&gt;&amp;lt;%= %&amp;gt;&lt;/code&gt; 。请注意，初始标记具有等号，如下所示： &lt;code&gt;&amp;lt;%=&lt;/code&gt; 。这意味着将执行这些标签之间的所有Elixir代码，并且结果值将替换该标签。如果缺少等号，则仍将执行代码，但该值不会出现在页面上。</target>
        </trans-unit>
        <trans-unit id="7207faf406837a635de5a70263b6dfda70627f88" translate="yes" xml:space="preserve">
          <source>To do this we modify the &lt;code&gt;index&lt;/code&gt; action as follows:</source>
          <target state="translated">为此，我们修改 &lt;code&gt;index&lt;/code&gt; 操作，如下所示：</target>
        </trans-unit>
        <trans-unit id="9c26c7d45e6051c71e7fe3c380da3a4f17f88bda" translate="yes" xml:space="preserve">
          <source>To dump the state from the current process and load into another one:</source>
          <target state="translated">将当前进程中的状态转储到另一个进程中。</target>
        </trans-unit>
        <trans-unit id="1756faaf0ba51188a497e41da02799505ffedbc4" translate="yes" xml:space="preserve">
          <source>To emulate this behaviour, this module provides the idea of recycling. The &lt;a href=&quot;#recycle/1&quot;&gt;&lt;code&gt;recycle/1&lt;/code&gt;&lt;/a&gt; function receives a connection and returns a new connection, similar to the one returned by &lt;a href=&quot;#build_conn/0&quot;&gt;&lt;code&gt;build_conn/0&lt;/code&gt;&lt;/a&gt; with all the response cookies from the previous connection defined as request headers. This is useful when testing multiple routes that require cookies or session to work.</source>
          <target state="translated">为了模拟这种行为，此模块提供了回收的想法。的&lt;a href=&quot;#recycle/1&quot;&gt; &lt;code&gt;recycle/1&lt;/code&gt; &lt;/a&gt;功能接收到一个连接，并返回一个新的连接，类似于由返回的一个&lt;a href=&quot;#build_conn/0&quot;&gt; &lt;code&gt;build_conn/0&lt;/code&gt; &lt;/a&gt;与来自定义为请求头的先前的连接的所有响应的cookie。当测试需要cookie或会话才能工作的多个路由时，这很有用。</target>
        </trans-unit>
        <trans-unit id="384f423fceb68dce0e44059e7dc17f0229bd095a" translate="yes" xml:space="preserve">
          <source>To emulate this behaviour, this module provides the idea of recycling. The &lt;a href=&quot;#recycle/1&quot;&gt;&lt;code&gt;recycle/1&lt;/code&gt;&lt;/a&gt; function receives a connection and returns a new connection, similar to the one returned by &lt;a href=&quot;#conn/0&quot;&gt;&lt;code&gt;conn/0&lt;/code&gt;&lt;/a&gt; with all the response cookies from the previous connection defined as request headers. This is useful when testing multiple routes that require cookies or session to work.</source>
          <target state="translated">为了模拟这种行为，此模块提供了回收的想法。的&lt;a href=&quot;#recycle/1&quot;&gt; &lt;code&gt;recycle/1&lt;/code&gt; &lt;/a&gt;功能接收到一个连接，并返回一个新的连接，类似于由返回的一个&lt;a href=&quot;#conn/0&quot;&gt; &lt;code&gt;conn/0&lt;/code&gt; &lt;/a&gt;与来自定义为请求头的先前的连接的所有响应的cookie。当测试需要cookie或会话才能工作的多个路由时，这很有用。</target>
        </trans-unit>
        <trans-unit id="091d07c554f0a419f1e21a5c0aae91e5f028e992" translate="yes" xml:space="preserve">
          <source>To encrypt an existing PEM-encoded RSA key use the OpenSSL CLI: &lt;code&gt;openssl rsa -in privkey.pem -out privkey_aes.pem -aes128&lt;/code&gt;. Use &lt;code&gt;ec&lt;/code&gt; instead of &lt;code&gt;rsa&lt;/code&gt; when using an ECDSA certificate. Don't forget to securely erase the unencrypted copy afterwards! Best practice would be to encrypt the file immediately during initial key generation: please refer to the instructions provided by the CA.</source>
          <target state="translated">要加密现有的PEM编码的RSA密钥，请使用OpenSSL CLI： &lt;code&gt;openssl rsa -in privkey.pem -out privkey_aes.pem -aes128&lt;/code&gt; 。使用ECDSA证书时，请使用 &lt;code&gt;ec&lt;/code&gt; 而不是 &lt;code&gt;rsa&lt;/code&gt; 。别忘了之后安全删除未加密的副本！最佳做法是在初始密钥生成期间立即对文件进行加密：请参考CA提供的说明。</target>
        </trans-unit>
        <trans-unit id="ce8e7a44c764d649b22d4767dfb19181500bc611" translate="yes" xml:space="preserve">
          <source>To encrypt, you would do:</source>
          <target state="translated">要加密,你会做。</target>
        </trans-unit>
        <trans-unit id="df2c16aad4e09f5b6f276b143ea796814d9ed388" translate="yes" xml:space="preserve">
          <source>To extract a private key from a PKCS#12 file to a PEM file: &lt;code&gt;openssl pkcs12 -in server.p12 -nocerts -nodes -out privkey.pem&lt;/code&gt;. You may want to replace the &lt;code&gt;-nodes&lt;/code&gt; argument with &lt;code&gt;-aes128&lt;/code&gt; to produce an encrypted, password protected PEM file.</source>
          <target state="translated">要将私钥从PKCS＃12文件提取到PEM文件，请执行以下操作： &lt;code&gt;openssl pkcs12 -in server.p12 -nocerts -nodes -out privkey.pem&lt;/code&gt; 。您可能需要更换 &lt;code&gt;-nodes&lt;/code&gt; 与参数 &lt;code&gt;-aes128&lt;/code&gt; 以产生加密，密码保护的PEM文件。</target>
        </trans-unit>
        <trans-unit id="2808505a7c943eb2ca42f02d966df7c8298102af" translate="yes" xml:space="preserve">
          <source>To extract all certificates from a PKCS#12 file to a PEM file: &lt;code&gt;openssl pkcs12 -in server.p12 -nokeys -out fullchain.pem&lt;/code&gt;. The resulting file contains all certificates from the input file, typically the server certificate and any CA certificates that make up the CA chain. You can split the file into seperate &lt;code&gt;cert.pem&lt;/code&gt; and &lt;code&gt;chain.pem&lt;/code&gt; files using a text editor, or you can just pass &lt;code&gt;certfile: fullchain.pem&lt;/code&gt; to the HTTPS adapter.</source>
          <target state="translated">要将所有证书从PKCS＃12文件提取到PEM文件，请执行以下操作： &lt;code&gt;openssl pkcs12 -in server.p12 -nokeys -out fullchain.pem&lt;/code&gt; 。生成的文件包含输入文件中的所有证书，通常是服务器证书以及组成CA链的任何CA证书。您可以使用文本编辑器将文件拆分为单独的 &lt;code&gt;cert.pem&lt;/code&gt; 和 &lt;code&gt;chain.pem&lt;/code&gt; 文件，也可以仅将 &lt;code&gt;certfile: fullchain.pem&lt;/code&gt; 传递给HTTPS适配器。</target>
        </trans-unit>
        <trans-unit id="34840b98dd241bba5b79a7b5023d3157b2b9193b" translate="yes" xml:space="preserve">
          <source>To fix this, we can change the password in the environment specific configuration file. For the development environment the password used can be found at the bottom of the &lt;code&gt;config/dev.exs&lt;/code&gt; file.</source>
          <target state="translated">要解决此问题，我们可以在特定于环境的配置文件中更改密码。对于开发环境，可以在 &lt;code&gt;config/dev.exs&lt;/code&gt; 文件的底部找到使用的密码。</target>
        </trans-unit>
        <trans-unit id="4e7d714947644732e2d22535431e05bc99b95dad" translate="yes" xml:space="preserve">
          <source>To fix this, we need to change the permissions on our &quot;postgres&quot; user in the &lt;code&gt;psql&lt;/code&gt; console to allow database creation.</source>
          <target state="translated">要解决此问题，我们需要在 &lt;code&gt;psql&lt;/code&gt; 控制台中更改对&amp;ldquo; postgres&amp;rdquo;用户的权限，以允许创建数据库。</target>
        </trans-unit>
        <trans-unit id="b5820c90b7b57a2442e1e4a6a440c255446634ff" translate="yes" xml:space="preserve">
          <source>To fix this, we need to change the permissions on our &quot;postgres&quot; user to allow login.</source>
          <target state="translated">为了解决这个问题,我们需要改变 &quot;postgres &quot;用户的权限,允许登录。</target>
        </trans-unit>
        <trans-unit id="12f12d3a42e639e525547c376c3befad88231e53" translate="yes" xml:space="preserve">
          <source>To forgo automatic form recovery, set &lt;code&gt;phx-auto-recover=&quot;ignore&quot;&lt;/code&gt;.</source>
          <target state="translated">要放弃自动表单恢复，请设置 &lt;code&gt;phx-auto-recover=&quot;ignore&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9add98f21666a54716c50850567b90f96e0b16a8" translate="yes" xml:space="preserve">
          <source>To generate a path to an image hosted in your application &quot;priv/static&quot;, with the &lt;code&gt;@conn&lt;/code&gt; endpoint, use &lt;code&gt;static_path/2&lt;/code&gt; to get a URL with cache control parameters:</source>
          <target state="translated">要使用 &lt;code&gt;@conn&lt;/code&gt; 端点生成应用程序&amp;ldquo; priv / static&amp;rdquo;中托管的映像的路径，请使用static_path &lt;code&gt;static_path/2&lt;/code&gt; 来获取带有缓存控制参数的URL：</target>
        </trans-unit>
        <trans-unit id="b31df5e294e6f54107ca6b36caf70de5a703ae9d" translate="yes" xml:space="preserve">
          <source>To generate a path to an image hosted in your application &amp;ldquo;priv/static&amp;rdquo;, use &lt;code&gt;static_path/1&lt;/code&gt; to get a URL with cache control parameters:</source>
          <target state="translated">要生成应用程序&amp;ldquo; priv / static&amp;rdquo;中托管的映像的路径，请使用 &lt;code&gt;static_path/1&lt;/code&gt; 获取具有缓存控制参数的URL：</target>
        </trans-unit>
        <trans-unit id="166e05bfe8272abd2c663bb42e431b56b9c76ee6" translate="yes" xml:space="preserve">
          <source>To generate a path to an image hosted in your application &amp;ldquo;priv/static&amp;rdquo;, with the &lt;code&gt;@conn&lt;/code&gt; endpoint, use &lt;code&gt;static_path/2&lt;/code&gt; to get a URL with cache control parameters:</source>
          <target state="translated">要使用 &lt;code&gt;@conn&lt;/code&gt; 端点生成应用程序&amp;ldquo; priv / static&amp;rdquo;中托管的映像的路径，请使用static_path &lt;code&gt;static_path/2&lt;/code&gt; 获取具有缓存控制参数的URL：</target>
        </trans-unit>
        <trans-unit id="da5cf0c3b662f85cf689692d186e495d82685f37" translate="yes" xml:space="preserve">
          <source>To get started, define the module attribute &lt;code&gt;@endpoint&lt;/code&gt; in your test case pointing to your application endpoint.</source>
          <target state="translated">首先，在 &lt;code&gt;@endpoint&lt;/code&gt; 中定义模块属性@endpoint指向应用程序端点。</target>
        </trans-unit>
        <trans-unit id="0f00e2408e6e8f684d6ca6cbd6ebed088bfa8147" translate="yes" xml:space="preserve">
          <source>To get started, see our &lt;a href=&quot;phoenix/overview&quot;&gt;overview guides&lt;/a&gt;.</source>
          <target state="translated">首先，请参阅我们的&lt;a href=&quot;phoenix/overview&quot;&gt;概述指南&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7ba9a108051080537e0193e44354907bb5392a7d" translate="yes" xml:space="preserve">
          <source>To give it a try, let's add this plug to our router:</source>
          <target state="translated">为了给它一个尝试,让我们添加这个插头到我们的路由器。</target>
        </trans-unit>
        <trans-unit id="f52a3e3b8dd3d57e8b74bdd60fe023df58eda4ed" translate="yes" xml:space="preserve">
          <source>To handle custom client-side JavaScript when an element is added, updated, or removed by the server, a hook object may be provided with the following life-cycle callbacks:</source>
          <target state="translated">为了在服务器添加、更新或删除元素时处理自定义的客户端JavaScript,可以为钩子对象提供以下生命周期回调。</target>
        </trans-unit>
        <trans-unit id="30c9f6eff2338b6f7de44ce146c839d9e841d092" translate="yes" xml:space="preserve">
          <source>To handle form changes and submissions, use the &lt;code&gt;phx-change&lt;/code&gt; and &lt;code&gt;phx-submit&lt;/code&gt; events. In general, it is preferred to handle input changes at the form level, where all form fields are passed to the LiveView's callback given any single input change. For example, to handle real-time form validation and saving, your template would use both &lt;code&gt;phx_change&lt;/code&gt; and &lt;code&gt;phx_submit&lt;/code&gt; bindings:</source>
          <target state="translated">要处理表单更改和提交，请使用 &lt;code&gt;phx-change&lt;/code&gt; 和 &lt;code&gt;phx-submit&lt;/code&gt; 事件。通常，最好在表单级别处理输入更改，在这种情况下，任何单个输入更改都会将所有表单字段传递到LiveView的回调中。例如，要处理实时表单验证和保存，您的模板将同时使用 &lt;code&gt;phx_change&lt;/code&gt; 和 &lt;code&gt;phx_submit&lt;/code&gt; 绑定：</target>
        </trans-unit>
        <trans-unit id="267d7ad17f4eb697f730fe2dade15352df2b644f" translate="yes" xml:space="preserve">
          <source>To handle latent events, any HTML tag can be annotated with &lt;code&gt;phx-disable-with&lt;/code&gt;, which swaps the element's &lt;code&gt;innerText&lt;/code&gt; with the provided value during event submission. For example, the following code would change the &quot;Save&quot; button to &quot;Saving...&quot;, and restore it to &quot;Save&quot; on acknowledgment:</source>
          <target state="translated">要处理潜在事件，可以使用 &lt;code&gt;phx-disable-with&lt;/code&gt; 注释任何HTML标记，该标记在事件提交期间用提供的值交换元素的 &lt;code&gt;innerText&lt;/code&gt; 。例如，以下代码会将&amp;ldquo;保存&amp;rdquo;按钮更改为&amp;ldquo;正在保存...&amp;rdquo;，并在确认后将其恢复为&amp;ldquo;保存&amp;rdquo;：</target>
        </trans-unit>
        <trans-unit id="2c017a576254a552f3b45b37a156813727bf60fc" translate="yes" xml:space="preserve">
          <source>To have coalesce/2 available, just import the module that defines it.</source>
          <target state="translated">要让coalesce/2可用,只要导入定义它的模块即可。</target>
        </trans-unit>
        <trans-unit id="e75ef0e9c4fd7b13190431887d04db3dc76e0ef4" translate="yes" xml:space="preserve">
          <source>To hide a fields value from the inspect protocol of &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Ecto.Changeset&lt;/code&gt;&lt;/a&gt;, mark the field as &lt;code&gt;redact: true&lt;/code&gt; in the schema, and it will display with the value &lt;code&gt;**redacted**&lt;/code&gt;.</source>
          <target state="translated">要从&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Ecto.Changeset&lt;/code&gt; &lt;/a&gt;的检查协议中隐藏字段值，请在模式中将该字段标记为redact &lt;code&gt;redact: true&lt;/code&gt; ，它将显示为 &lt;code&gt;**redacted**&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="855cc0ad003d98da4f4ca9c2d54547a476da02d3" translate="yes" xml:space="preserve">
          <source>To keep things simple, we added both our sign-in and sign-out forms in this template. For our sign-in form, we pass the &lt;code&gt;@conn&lt;/code&gt; directly to &lt;code&gt;form_for&lt;/code&gt;, pointing our form action at &lt;code&gt;session_path(@conn, :create)&lt;/code&gt;. We also pass the &lt;code&gt;as: :user&lt;/code&gt; option which tells Phoenix to wrap the form parameters inside a &lt;code&gt;&quot;user&quot;&lt;/code&gt; key. Next, we used the &lt;code&gt;text_input&lt;/code&gt; and &lt;code&gt;password_input&lt;/code&gt; functions to send up an &lt;code&gt;&quot;email&quot;&lt;/code&gt; and &lt;code&gt;&quot;password&quot;&lt;/code&gt; parameter.</source>
          <target state="translated">为简单起见，我们在此模板中添加了登录和退出表单。对于我们的登录表单，我们将 &lt;code&gt;@conn&lt;/code&gt; 直接传递给 &lt;code&gt;form_for&lt;/code&gt; ，将表单动作指向 &lt;code&gt;session_path(@conn, :create)&lt;/code&gt; 。我们还传递了 &lt;code&gt;as: :user&lt;/code&gt; 选项，该选项告诉Phoenix将表单参数包装在 &lt;code&gt;&quot;user&quot;&lt;/code&gt; 键中。接下来，我们使用 &lt;code&gt;text_input&lt;/code&gt; 和 &lt;code&gt;password_input&lt;/code&gt; 函数发送 &lt;code&gt;&quot;email&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;password&quot;&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="41ef78913465515a398d685d02fba061196e4bdf" translate="yes" xml:space="preserve">
          <source>To learn more about &lt;a href=&quot;mix.tasks.phx.new&quot;&gt;&lt;code&gt;mix phx.new&lt;/code&gt;&lt;/a&gt; you can read the &lt;a href=&quot;mix_tasks#phoenix-specific-mix-tasks&quot;&gt;Mix Tasks Guide&lt;/a&gt;.</source>
          <target state="translated">要了解有关&lt;a href=&quot;mix.tasks.phx.new&quot;&gt; &lt;code&gt;mix phx.new&lt;/code&gt; 的&lt;/a&gt;更多信息，请阅读《&lt;a href=&quot;mix_tasks#phoenix-specific-mix-tasks&quot;&gt;混合任务指南》&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="41d3efd7490499ce0623a7738176753951ffa31a" translate="yes" xml:space="preserve">
          <source>To learn more about Plugs, see the documentation for &lt;a href=&quot;https://hexdocs.pm/plug&quot;&gt;the Plug project&lt;/a&gt;, which provides many built-in plugs and functionalities.</source>
          <target state="translated">要了解有关Plugs的更多信息，请参阅&lt;a href=&quot;https://hexdocs.pm/plug&quot;&gt;Plug项目&lt;/a&gt;的文档，该项目提供了许多内置的Plug和功能。</target>
        </trans-unit>
        <trans-unit id="07ecc754901c9b7b1612b2347516e5e86c89fd01" translate="yes" xml:space="preserve">
          <source>To load data from non-database sources, use &lt;a href=&quot;ecto#embedded_load/3&quot;&gt;&lt;code&gt;Ecto.embedded_load/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">要从非数据库源加载数据，请使用&lt;a href=&quot;ecto#embedded_load/3&quot;&gt; &lt;code&gt;Ecto.embedded_load/3&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b9c5bfde6fe357ce410561f8996b3ca30aa626e4" translate="yes" xml:space="preserve">
          <source>To log the status of requests being sent:</source>
          <target state="translated">记录申请的发送状态。</target>
        </trans-unit>
        <trans-unit id="ee680d8d89287bdbf31b386e8103c640bb092faa" translate="yes" xml:space="preserve">
          <source>To log the status of response being sent:</source>
          <target state="translated">记录发送中的响应状态。</target>
        </trans-unit>
        <trans-unit id="b84dbd8c1d5f506769b351fa5d09d5ae2afb79fe" translate="yes" xml:space="preserve">
          <source>To make that happen, let's create a new &lt;code&gt;lib/hello_web/controllers/hello_controller.ex&lt;/code&gt; file, and make it look like the following:</source>
          <target state="translated">为了实现这一点，让我们创建一个新的 &lt;code&gt;lib/hello_web/controllers/hello_controller.ex&lt;/code&gt; 文件，并使该文件如下所示：</target>
        </trans-unit>
        <trans-unit id="4ba9cdf779e09df433f92db1ffd43f9ee1c2b0dd" translate="yes" xml:space="preserve">
          <source>To make the value label easier to read, we can update our private function to generate more user friendly names. We'll run the value of the &lt;code&gt;:view&lt;/code&gt; through &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#inspect/1&quot;&gt;&lt;code&gt;inspect/1&lt;/code&gt;&lt;/a&gt; to remove the &lt;code&gt;Elixir.&lt;/code&gt; prefix and call another private function to convert the &lt;code&gt;connected?&lt;/code&gt; boolean into human readable text.</source>
          <target state="translated">为了使值标签更易于阅读，我们可以更新私有函数以生成更多用户友好名称。我们将通过&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#inspect/1&quot;&gt; &lt;code&gt;inspect/1&lt;/code&gt; &lt;/a&gt;运行 &lt;code&gt;:view&lt;/code&gt; 的值以删除 &lt;code&gt;Elixir.&lt;/code&gt; 前缀并调用另一个私有函数来转换所 &lt;code&gt;connected?&lt;/code&gt; 布尔值转换为人类可读的文本。</target>
        </trans-unit>
        <trans-unit id="67920df22e1378273bb126fe074d93ace6df9e19" translate="yes" xml:space="preserve">
          <source>To make this all work, we converted the nested blocks of code and used &lt;code&gt;halt(conn)&lt;/code&gt; whenever we reached a failure path. The &lt;code&gt;halt(conn)&lt;/code&gt; functionality is essential here: it tells Plug that the next plug should not be invoked.</source>
          <target state="translated">为了使所有这些工作正常进行，我们转换了嵌套的代码块，并在到达故障路径时使用了 &lt;code&gt;halt(conn)&lt;/code&gt; 。这里的 &lt;code&gt;halt(conn)&lt;/code&gt; 功能至关重要：它告诉Plug不应调用下一个Plug。</target>
        </trans-unit>
        <trans-unit id="8b981e8d2840a199b1a09b482f3875a4d2e4d12a" translate="yes" xml:space="preserve">
          <source>To prevent downgrade attacks, in which an attacker intercepts a plain HTTP request to the server before the redirect to HTTPS takes place, &lt;a href=&quot;plug.ssl&quot;&gt;&lt;code&gt;Plug.SSL&lt;/code&gt;&lt;/a&gt; by default sets the '&lt;a href=&quot;https://www.owasp.org/index.php/HTTP_Strict_Transport_Security_Cheat_Sheet&quot;&gt;Strict-Transport-Security&lt;/a&gt;' (HSTS) header. This informs the browser that the current site must only ever be accessed over HTTPS, even if the user typed or clicked a plain HTTP URL. This only works if the site is reachable on port 443 (see &lt;a href=&quot;#listening-on-port-443&quot;&gt;Listening on Port 443&lt;/a&gt;, below).</source>
          <target state="translated">为了防止降级攻击，在这种降级攻击中，攻击者在重定向到HTTPS之前会拦截对服务器的纯HTTP请求，默认情况下，&lt;a href=&quot;plug.ssl&quot;&gt; &lt;code&gt;Plug.SSL&lt;/code&gt; &lt;/a&gt;设置&amp;ldquo; &lt;a href=&quot;https://www.owasp.org/index.php/HTTP_Strict_Transport_Security_Cheat_Sheet&quot;&gt;Strict-Transport-Security&lt;/a&gt; &amp;rdquo;（HSTS）标头。这将通知浏览器，即使用户键入或单击纯HTTP URL，也只能通过HTTPS访问当前站点。仅当站点在端口443上可访问时，此方法才有效（请参阅下面的&lt;a href=&quot;#listening-on-port-443&quot;&gt;在端口443上侦听&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="4cc58fd422ebb28e73e66dcbc49fcc7dea92cf94" translate="yes" xml:space="preserve">
          <source>To print the Phoenix installer version, pass &lt;code&gt;-v&lt;/code&gt; or &lt;code&gt;--version&lt;/code&gt;, for example:</source>
          <target state="translated">要打印Phoenix安装程序版本，请传递 &lt;code&gt;-v&lt;/code&gt; 或 &lt;code&gt;--version&lt;/code&gt; ，例如：</target>
        </trans-unit>
        <trans-unit id="26c8218895c269e2f70bd1d662ea87120136ac06" translate="yes" xml:space="preserve">
          <source>To protect the private key on disk it is best stored in encrypted PEM format, protected by a password. When configuring a Plug server with an encrypted private key, specify the password using the &lt;code&gt;:password&lt;/code&gt; option:</source>
          <target state="translated">为了保护磁盘上的私钥，最好以加密的PEM格式存储并受密码保护。使用加密的私钥配置插件服务器时，请使用 &lt;code&gt;:password&lt;/code&gt; 选项指定密码：</target>
        </trans-unit>
        <trans-unit id="08f005693574383d47c51cc61b7ad7263f57b279" translate="yes" xml:space="preserve">
          <source>To push out-of-band events to the client, for example to render charting points, one could do:</source>
          <target state="translated">要将带外事件推送到客户端,例如要渲染图表点,可以这样做。</target>
        </trans-unit>
        <trans-unit id="fccb94c57dedc205e8813c5305e1507bc38c480d" translate="yes" xml:space="preserve">
          <source>To render the template within the layout, simply call &lt;a href=&quot;#render/3&quot;&gt;&lt;code&gt;render/3&lt;/code&gt;&lt;/a&gt; using the &lt;code&gt;@view_module&lt;/code&gt; and &lt;code&gt;@view_template&lt;/code&gt; assign:</source>
          <target state="translated">要在布局中渲染模板，只需使用 &lt;code&gt;@view_module&lt;/code&gt; 和 &lt;code&gt;@view_template&lt;/code&gt; Assign调用&lt;a href=&quot;#render/3&quot;&gt; &lt;code&gt;render/3&lt;/code&gt; &lt;/a&gt;即可：</target>
        </trans-unit>
        <trans-unit id="aa8723d880ffe7172650143b48a2d4553d915169" translate="yes" xml:space="preserve">
          <source>To run &lt;code&gt;phx.server&lt;/code&gt; without checking dependencies, you can run:</source>
          <target state="translated">要运行 &lt;code&gt;phx.server&lt;/code&gt; 而不检查依赖关系，可以运行：</target>
        </trans-unit>
        <trans-unit id="e1965798572eff34dbe863a6ecca7a38fdba4475" translate="yes" xml:space="preserve">
          <source>To see an example of how Phoenix LiveDashboard uses these events to create metrics, visit &lt;a href=&quot;https://hexdocs.pm/phoenix_live_dashboard/metrics.html&quot;&gt;https://hexdocs.pm/phoenix_live_dashboard/metrics.html&lt;/a&gt;.</source>
          <target state="translated">要查看有关Phoenix LiveDashboard如何使用这些事件创建指标的示例，请访问&lt;a href=&quot;https://hexdocs.pm/phoenix_live_dashboard/metrics.html&quot;&gt;https://hexdocs.pm/phoenix_live_dashboard/metrics.html&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="780f2579e6ee8b79fb5eebbb6a2bad044f0a1da4" translate="yes" xml:space="preserve">
          <source>To see the assign in action, go to the layout in &quot;lib/hello_web/templates/layout/app.html.eex&quot; and add the following close to the main container:</source>
          <target state="translated">要查看分配的操作,请转到 &quot;lib/hello_web/templates/layout/app.html.ex &quot;中的布局,并在主容器附近添加以下内容。</target>
        </trans-unit>
        <trans-unit id="ac659bbda0b5959d98ced3480e408112f77540e4" translate="yes" xml:space="preserve">
          <source>To see this in action, let's write a module plug that puts the &lt;code&gt;:locale&lt;/code&gt; key and value into the connection assign for downstream use in other plugs, controller actions, and our views. Put the contents above to a file named &quot;lib/hello_web/plugs/locale.ex&quot;:</source>
          <target state="translated">为了了解这一点，让我们编写一个模块插件，该插件将 &lt;code&gt;:locale&lt;/code&gt; 键和值放入连接分配中，以供其他插件，控制器操作和我们的视图中的下游使用。将以上内容放入名为&amp;ldquo; lib / hello_web / plugs / locale.ex&amp;rdquo;的文件中：</target>
        </trans-unit>
        <trans-unit id="52a700000692ac76dd990fc6ece3a9849d62392d" translate="yes" xml:space="preserve">
          <source>To send a file that is stored inside your application priv directory:</source>
          <target state="translated">要发送存储在你的应用程序priv目录下的文件。</target>
        </trans-unit>
        <trans-unit id="35a9af194f11f81b8d5034792059c6fe96098baa" translate="yes" xml:space="preserve">
          <source>To sign, you would do:</source>
          <target state="translated">要签名,你会做。</target>
        </trans-unit>
        <trans-unit id="44fd47beed516022715facac2a1ae8d92a4df5b5" translate="yes" xml:space="preserve">
          <source>To simplify configuration of TLS defaults Plug provides two preconfifured options: &lt;code&gt;cipher_suite: :strong&lt;/code&gt; and &lt;code&gt;cipher_suite: :compatible&lt;/code&gt;. The Ciphers chosen and related configuration come from the OWASP recommendations found here: https://www.owasp.org/index.php/TLS_Cipher_String_Cheat_Sheet</source>
          <target state="translated">为了简化TLS默认设置，Plug提供了两个预先配置的选项： &lt;code&gt;cipher_suite: :strong&lt;/code&gt; 和 &lt;code&gt;cipher_suite: :compatible&lt;/code&gt; 。所选的密码和相关配置来自以下位置的OWASP建议：https://www.owasp.org/index.php/TLS_Cipher_String_Cheat_Sheet</target>
        </trans-unit>
        <trans-unit id="0648eaf88db893b2046b349febdc511815782796" translate="yes" xml:space="preserve">
          <source>To simplify configuration of TLS defaults Plug provides two preconfigured options: &lt;code&gt;cipher_suite: :strong&lt;/code&gt; and &lt;code&gt;cipher_suite: :compatible&lt;/code&gt;.</source>
          <target state="translated">为了简化TLS默认设置，Plug提供了两个预配置的选项： &lt;code&gt;cipher_suite: :strong&lt;/code&gt; 和 &lt;code&gt;cipher_suite: :compatible&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9f0f28f03a276631d1d8cb8b076f6c25bc731344" translate="yes" xml:space="preserve">
          <source>To simplify configuration of TLS defaults, this function provides two preconfigured options: &lt;code&gt;cipher_suite: :strong&lt;/code&gt; and &lt;code&gt;cipher_suite: :compatible&lt;/code&gt;. The Ciphers chosen and related configuration come from the &lt;a href=&quot;https://www.owasp.org/index.php/TLS_Cipher_String_Cheat_Sheet&quot;&gt;OWASP Cipher String Cheat Sheet&lt;/a&gt;</source>
          <target state="translated">为了简化TLS默认设置，此功能提供了两个预配置的选项： &lt;code&gt;cipher_suite: :strong&lt;/code&gt; 和 &lt;code&gt;cipher_suite: :compatible&lt;/code&gt; 。选择的密码和相关配置来自&lt;a href=&quot;https://www.owasp.org/index.php/TLS_Cipher_String_Cheat_Sheet&quot;&gt;OWASP密码字符串备忘单&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="05cfddf3dfec406094311ddae72d16bd5088244a" translate="yes" xml:space="preserve">
          <source>To solve this, all &lt;a href=&quot;phoenix.liveview.rendered&quot;&gt;&lt;code&gt;Phoenix.LiveView.Rendered&lt;/code&gt;&lt;/a&gt; structs also contain a fingerprint field that uniquely identifies it. If the fingerprints are equal, you have the same template, and therefore it is possible to only transmit its changes.</source>
          <target state="translated">为了解决这个问题，所有&lt;a href=&quot;phoenix.liveview.rendered&quot;&gt; &lt;code&gt;Phoenix.LiveView.Rendered&lt;/code&gt; &lt;/a&gt;结构还包含一个唯一标识它的指纹字段。如果指纹相等，则您具有相同的模板，因此可以仅传输其更改。</target>
        </trans-unit>
        <trans-unit id="58fcf5b5fb3d94c82b9314b323af893477190f87" translate="yes" xml:space="preserve">
          <source>To specify private options on &lt;code&gt;match&lt;/code&gt; that can be used by plugs before &lt;code&gt;dispatch&lt;/code&gt; pass an option with key &lt;code&gt;:private&lt;/code&gt; containing a map. Example:</source>
          <target state="translated">要在 &lt;code&gt;match&lt;/code&gt; 之前指定私有选项，插头可以在 &lt;code&gt;dispatch&lt;/code&gt; 之前使用该私有选项，请传递一个包含地图的key &lt;code&gt;:private&lt;/code&gt; 选项。例：</target>
        </trans-unit>
        <trans-unit id="b3f3f98dc901f9abeb9304c536e620a40b09a54d" translate="yes" xml:space="preserve">
          <source>To specify the endpoint that will provide instrumentation, the first argument can be:</source>
          <target state="translated">要指定提供仪器的端点,第一个参数可以是:</target>
        </trans-unit>
        <trans-unit id="b1d40c54757f1d4613e7479119437d84155bd019" translate="yes" xml:space="preserve">
          <source>To start a tracker, first add the tracker to your supervision tree:</source>
          <target state="translated">要启动跟踪器,首先将跟踪器添加到您的监督树中。</target>
        </trans-unit>
        <trans-unit id="865274f6fae09ebe9585b2086ee27cd4cbdb840c" translate="yes" xml:space="preserve">
          <source>To start, let's think of a function name that describes what we want to accomplish. To authenticate a user by email address, we'll need a way to lookup that user and verify their entered credentials are valid. We can do this by exposing a single function on our &lt;code&gt;Accounts&lt;/code&gt; context.</source>
          <target state="translated">首先，让我们考虑一个描述我们要完成的功能的函数名称。要通过电子邮件地址对用户进行身份验证，我们需要一种方法来查找该用户并验证其输入的凭据是否有效。为此，我们可以在 &lt;code&gt;Accounts&lt;/code&gt; 上下文中公开一个功能。</target>
        </trans-unit>
        <trans-unit id="fe9098d8b92793a95404f15371666be5a41249f2" translate="yes" xml:space="preserve">
          <source>To stop it, we hit &lt;code&gt;ctrl-c&lt;/code&gt; twice.</source>
          <target state="translated">为了阻止它，我们按了 &lt;code&gt;ctrl-c&lt;/code&gt; 两次。</target>
        </trans-unit>
        <trans-unit id="d581dcb8a5c7aee4d296819c687a1a0e294823ae" translate="yes" xml:space="preserve">
          <source>To stream data use &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html#reduce_while/3&quot;&gt;&lt;code&gt;Enum.reduce_while/3&lt;/code&gt;&lt;/a&gt; instead of &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html#into/2&quot;&gt;&lt;code&gt;Enum.into/2&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html#reduce_while/3&quot;&gt;&lt;code&gt;Enum.reduce_while/3&lt;/code&gt;&lt;/a&gt; allows aborting the execution if &lt;a href=&quot;#chunk/2&quot;&gt;&lt;code&gt;chunk/2&lt;/code&gt;&lt;/a&gt; fails to deliver the chunk of data.</source>
          <target state="translated">要流式传输数据，请使用&lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html#reduce_while/3&quot;&gt; &lt;code&gt;Enum.reduce_while/3&lt;/code&gt; &lt;/a&gt;而不是&lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html#into/2&quot;&gt; &lt;code&gt;Enum.into/2&lt;/code&gt; &lt;/a&gt;。如果&lt;a href=&quot;#chunk/2&quot;&gt; &lt;code&gt;chunk/2&lt;/code&gt; &lt;/a&gt;无法传递数据块，则&lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html#reduce_while/3&quot;&gt; &lt;code&gt;Enum.reduce_while/3&lt;/code&gt; &lt;/a&gt;允许中止执行。</target>
        </trans-unit>
        <trans-unit id="9fa929e9e71e2e4dc6c3efe3b0fa423875bca234" translate="yes" xml:space="preserve">
          <source>To submit a form along with some with hidden input values:</source>
          <target state="translated">在提交表格的同时,也要提交一些带有隐藏输入值的表格。</target>
        </trans-unit>
        <trans-unit id="968cfb95ef76146b6409c3b657948cdd5f1f4f75" translate="yes" xml:space="preserve">
          <source>To sum it up:</source>
          <target state="translated">总结一下:</target>
        </trans-unit>
        <trans-unit id="102bc3a62eadfb6175b1787787fb41a6baa07e87" translate="yes" xml:space="preserve">
          <source>To sum up:</source>
          <target state="translated">综上所述:</target>
        </trans-unit>
        <trans-unit id="a410cd8f3e812852d23e13de76f2d28e929bd21f" translate="yes" xml:space="preserve">
          <source>To switch adapters, we need to remove the Postgrex dependency and add a new one for Mariaex instead.</source>
          <target state="translated">要切换适配器,我们需要删除Postgrex的依赖,并为Mariaex添加一个新的依赖。</target>
        </trans-unit>
        <trans-unit id="4a2ee59d6482fe8d57fcc8a0083e0c4366e7446c" translate="yes" xml:space="preserve">
          <source>To template that goes inside the layout will be placed in the &lt;code&gt;@inner_content&lt;/code&gt; assign:</source>
          <target state="translated">要将布局内的模板放置在 &lt;code&gt;@inner_content&lt;/code&gt; 中，请分配：</target>
        </trans-unit>
        <trans-unit id="80e061ad3871e4c5c14888dba30a6440671c5a6d" translate="yes" xml:space="preserve">
          <source>To test:</source>
          <target state="translated">为了测试。</target>
        </trans-unit>
        <trans-unit id="26b1ef54f7afb80af1f92d1a44fccf208e6f5b11" translate="yes" xml:space="preserve">
          <source>To use a precompiled template, create a &lt;code&gt;scripts.html.eex&lt;/code&gt; file in the &lt;code&gt;templates&lt;/code&gt; directory for the corresponding view you want it to render for. For example, for the &lt;code&gt;UserView&lt;/code&gt;, create the &lt;code&gt;scripts.html.eex&lt;/code&gt; file at &lt;code&gt;web/templates/user/&lt;/code&gt;.</source>
          <target state="translated">要使用预编译的模板，请在 &lt;code&gt;templates&lt;/code&gt; 目录中为您要为其渲染的相应视图创建 &lt;code&gt;scripts.html.eex&lt;/code&gt; 文件。例如，对于 &lt;code&gt;UserView&lt;/code&gt; ，在 &lt;code&gt;web/templates/user/&lt;/code&gt; 创建 &lt;code&gt;scripts.html.eex&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="f114bef104473c93c624dc15c134a2506e1bf712" translate="yes" xml:space="preserve">
          <source>To use a precompiled template, create a &lt;code&gt;scripts.html.eex&lt;/code&gt; file in the &lt;code&gt;templates&lt;/code&gt; directory for the corresponding view you want it to render for. For example, for the &lt;code&gt;UserView&lt;/code&gt;, create the &lt;code&gt;scripts.html.eex&lt;/code&gt; file at &lt;code&gt;your_app_web/templates/user/&lt;/code&gt;.</source>
          <target state="translated">要使用预编译的模板，请在 &lt;code&gt;templates&lt;/code&gt; 目录中为您要为其渲染的相应视图创建 &lt;code&gt;scripts.html.eex&lt;/code&gt; 文件。例如，对于 &lt;code&gt;UserView&lt;/code&gt; ，在 &lt;code&gt;your_app_web/templates/user/&lt;/code&gt; 创建 &lt;code&gt;scripts.html.eex&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="f17a125a5e6e8a005867e5e43c2e03a3bc9ba5a1" translate="yes" xml:space="preserve">
          <source>To use inform for early hints send one or more informs with a status of 103.</source>
          <target state="translated">要使用inform进行早期提示,发送一个或多个状态为103的inform。</target>
        </trans-unit>
        <trans-unit id="4c9225f6845b572057c82d533463516a01a74a81" translate="yes" xml:space="preserve">
          <source>To use it as the type for the id in our schema, we can use the &lt;code&gt;@primary_key&lt;/code&gt; module attribute:</source>
          <target state="translated">要将其用作我们架构中id的类型，我们可以使用 &lt;code&gt;@primary_key&lt;/code&gt; 模块属性：</target>
        </trans-unit>
        <trans-unit id="c71555f84c848ebd550b0b2837d6569d68c6e857" translate="yes" xml:space="preserve">
          <source>To use it as your PubSub adapter, simply add it to your Endpoint&amp;rsquo;s config:</source>
          <target state="translated">要将其用作PubSub适配器，只需将其添加到端点的配置中即可：</target>
        </trans-unit>
        <trans-unit id="187cfa2127b5960446298f89ad2cfe623ccc0476" translate="yes" xml:space="preserve">
          <source>To use it, just plug it into the desired module.</source>
          <target state="translated">使用时,只需将其插入所需模块即可。</target>
        </trans-unit>
        <trans-unit id="2e14f0d8d5504cedce23ae26e51fc49f968cc49d" translate="yes" xml:space="preserve">
          <source>To use it, just plug it into the desired module:</source>
          <target state="translated">使用时,只需将其插入所需模块即可。</target>
        </trans-unit>
        <trans-unit id="595e3caee2e048e5b6af233064a5c06aa1ae0dd2" translate="yes" xml:space="preserve">
          <source>To use the live layout, update your LiveView to pass the &lt;code&gt;:layout&lt;/code&gt; option to &lt;code&gt;use Phoenix.LiveView&lt;/code&gt;:</source>
          <target state="translated">要使用实时布局，请更新LiveView以传递 &lt;code&gt;:layout&lt;/code&gt; 选项以 &lt;code&gt;use Phoenix.LiveView&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="a467a95e3bae25f66e655cb0e95ae8997b92d46e" translate="yes" xml:space="preserve">
          <source>To use this adapter outside of Phoenix, you must start an instance of this module as part of your supervision tree:</source>
          <target state="translated">要在Phoenix之外使用此适配器,您必须启动此模块的实例作为您的监督树的一部分。</target>
        </trans-unit>
        <trans-unit id="c8cc58c102127e1478be2cb62bee842868d8e23c" translate="yes" xml:space="preserve">
          <source>To use this functionality, the first step is to annotate which static files you want to be tracked by LiveView, with the &lt;code&gt;phx-track-static&lt;/code&gt;. For example:</source>
          <target state="translated">要使用此功能，第一步是使用 &lt;code&gt;phx-track-static&lt;/code&gt; 注释LiveView要跟踪的静态文件。例如：</target>
        </trans-unit>
        <trans-unit id="117496c10ce2870a7a485406c87644c6a1d5cede" translate="yes" xml:space="preserve">
          <source>To use this plug, just plug it into the desired module:</source>
          <target state="translated">要使用此插头,只需将其插入所需模块即可。</target>
        </trans-unit>
        <trans-unit id="5ed35357476c8058b977ba69de2188d350955b6b" translate="yes" xml:space="preserve">
          <source>To use this type in a schema field, specify the type and parameters like this:</source>
          <target state="translated">要在模式字段中使用该类型,请像这样指定类型和参数。</target>
        </trans-unit>
        <trans-unit id="0be2552a6f37a24285cf8c9a4bbf18c028914ee4" translate="yes" xml:space="preserve">
          <source>To wrap a label around an input, see &lt;a href=&quot;#label/1&quot;&gt;&lt;code&gt;label/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">要将标签包裹在输入周围，请参见&lt;a href=&quot;#label/1&quot;&gt; &lt;code&gt;label/1&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d3ba8aacdac746a9e58d91fb33fc6cb9465a0339" translate="yes" xml:space="preserve">
          <source>Token generation</source>
          <target state="translated">代币生成</target>
        </trans-unit>
        <trans-unit id="f80aa637b7d7bc4574011a6f03ec544bfb7d8aa0" translate="yes" xml:space="preserve">
          <source>Tokens provide a way to generate and verify bearer tokens for use in Channels or API authentication.</source>
          <target state="translated">令牌提供了一种生成和验证不记名令牌的方式,用于Channel或API认证。</target>
        </trans-unit>
        <trans-unit id="20a6a1c796f4bedac7e31cb355e60cefd679db64" translate="yes" xml:space="preserve">
          <source>Topic Patterns</source>
          <target state="translated">主题模式</target>
        </trans-unit>
        <trans-unit id="7ab575de50dde2e85ca0c17176dc52fba2687bb2" translate="yes" xml:space="preserve">
          <source>Topics &amp;amp; Callbacks</source>
          <target state="translated">主题与回调</target>
        </trans-unit>
        <trans-unit id="c05de3133bb80093a252ef28feff7623186b061e" translate="yes" xml:space="preserve">
          <source>Track a channel's process as a presence.</source>
          <target state="translated">追踪一个渠道的进程,作为一个存在。</target>
        </trans-unit>
        <trans-unit id="261a0221d2b8ed7abd71a3e4620a5971130fd19b" translate="yes" xml:space="preserve">
          <source>Track an arbitrary process as a presence.</source>
          <target state="translated">追踪一个任意的过程作为存在。</target>
        </trans-unit>
        <trans-unit id="01ecb082b24a5ab812ebd962ccc4da0fcdfbcfae" translate="yes" xml:space="preserve">
          <source>Tracked presences are grouped by &lt;code&gt;key&lt;/code&gt;, cast as a string. For example, to group each user's channels together, use user IDs as keys. Each presence can be associated with a map of metadata to store small, emphemeral state, such as a user's online status. To store detailed information, see &lt;a href=&quot;#c:fetch/2&quot;&gt;&lt;code&gt;fetch/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">跟踪的在线状态根据 &lt;code&gt;key&lt;/code&gt; 分组，并转换为字符串。例如，要将每个用户的频道分组在一起，请使用用户ID作为键。每个状态都可以与元数据地图相关联，以存储较小的临时状态，例如用户的在线状态。要存储详细信息，请参阅&lt;a href=&quot;#c:fetch/2&quot;&gt; &lt;code&gt;fetch/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a1815ae87e1ed66b14331696c387c97e3da9eb63" translate="yes" xml:space="preserve">
          <source>Tracker servers use a heartbeat protocol and CRDT to replicate presence information across a cluster in an eventually consistent, conflict-free manner. Under this design, there is no single source of truth or global process. Instead, each node runs one or more &lt;a href=&quot;phoenix.tracker#content&quot;&gt;&lt;code&gt;Phoenix.Tracker&lt;/code&gt;&lt;/a&gt; servers and node-local changes are replicated across the cluster and handled locally as a diff of changes.</source>
          <target state="translated">跟踪服务器使用心跳协议和CRDT以最终一致，无冲突的方式跨集群复制状态信息。在这种设计下，没有真理或全球过程的单一来源。相反，每个节点都运行一个或多个&lt;a href=&quot;phoenix.tracker#content&quot;&gt; &lt;code&gt;Phoenix.Tracker&lt;/code&gt; &lt;/a&gt;服务器，并且本地节点的更改将在整个集群中复制并作为更改的差异在本地进行处理。</target>
        </trans-unit>
        <trans-unit id="e426db3c83832b5b1a9b212c38c2b26124ea17c3" translate="yes" xml:space="preserve">
          <source>Tracker shards use a heartbeat protocol and CRDT to replicate presence information across a cluster in an eventually consistent, conflict-free manner. Under this design, there is no single source of truth or global process. Each node runs a pool of &lt;a href=&quot;phoenix.tracker.shard&quot;&gt;&lt;code&gt;Phoenix.Tracker.Shard&lt;/code&gt;&lt;/a&gt;s and node-local changes are replicated across the cluster and handled locally as a diff of changes.</source>
          <target state="translated">跟踪程序分片使用心跳协议和CRDT以最终一致，无冲突的方式跨集群复制状态信息。在这种设计下，没有真理或全球过程的单一来源。每个节点都运行一个&lt;a href=&quot;phoenix.tracker.shard&quot;&gt; &lt;code&gt;Phoenix.Tracker.Shard&lt;/code&gt; &lt;/a&gt;池，节点本地更改将在整个集群中复制并作为更改的差异在本地进行处理。</target>
        </trans-unit>
        <trans-unit id="f1a6bb7d4cf7d24a007e92d554e3f03f18d78e05" translate="yes" xml:space="preserve">
          <source>Trackers must implement &lt;code&gt;start_link/1&lt;/code&gt;, &lt;a href=&quot;#init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt;, and &lt;code&gt;handle_diff/2&lt;/code&gt;. The &lt;a href=&quot;#init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt; callback allows the tracker to manage its own state when running within the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Phoenix.Tracker&lt;/code&gt;&lt;/a&gt; server. The &lt;code&gt;handle_diff&lt;/code&gt; callback is invoked with a diff of presence join and leave events, grouped by topic. As replicas heartbeat and replicate data, the local tracker state is merged with the remote data, and the diff is sent to the callback. The handler can use this information to notify subscribers of events, as done above.</source>
          <target state="translated">跟踪器必须实现 &lt;code&gt;start_link/1&lt;/code&gt; ，&lt;a href=&quot;#init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt;和 &lt;code&gt;handle_diff/2&lt;/code&gt; 。当在&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Phoenix.Tracker&lt;/code&gt; &lt;/a&gt;服务器中运行时，&lt;a href=&quot;#init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt;回调允许跟踪器管理其自己的状态。该 &lt;code&gt;handle_diff&lt;/code&gt; 函数调用时存在的差异加入和离开事件，按主题进行分组。在复制心跳和复制数据时，本地跟踪器状态将与远程数据合并，并且差异将发送到回调。处理程序可以使用此信息来通知订户事件，如上所述。</target>
        </trans-unit>
        <trans-unit id="386e43727163f9c18a619e32e79443e6e4a3c763" translate="yes" xml:space="preserve">
          <source>Trackers must implement &lt;code&gt;start_link/1&lt;/code&gt;, &lt;a href=&quot;#init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt;, and &lt;code&gt;handle_diff/2&lt;/code&gt;. The &lt;a href=&quot;#init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt; callback allows the tracker to manage its own state when running within the &lt;a href=&quot;phoenix.tracker#content&quot;&gt;&lt;code&gt;Phoenix.Tracker&lt;/code&gt;&lt;/a&gt; server. The &lt;code&gt;handle_diff&lt;/code&gt; callback is invoked with a diff of presence join and leave events, grouped by topic. As replicas heartbeat and replicate data, the local tracker state is merged with the remote data, and the diff is sent to the callback. The handler can use this information to notify subscribers of events, as done above.</source>
          <target state="translated">跟踪器必须实现 &lt;code&gt;start_link/1&lt;/code&gt; ，&lt;a href=&quot;#init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt;和 &lt;code&gt;handle_diff/2&lt;/code&gt; 。当在&lt;a href=&quot;phoenix.tracker#content&quot;&gt; &lt;code&gt;Phoenix.Tracker&lt;/code&gt; &lt;/a&gt;服务器中运行时，&lt;a href=&quot;#init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt;回调允许跟踪器管理其自己的状态。该 &lt;code&gt;handle_diff&lt;/code&gt; 函数调用时存在的差异加入和离开事件，按主题进行分组。在复制心跳和复制数据时，本地跟踪器状态将与远程数据合并，并且差异将发送到回调。处理程序可以使用此信息来通知订户事件，如上所述。</target>
        </trans-unit>
        <trans-unit id="3a1ce6393d7c243fe58a4abc442faa4d6b63e426" translate="yes" xml:space="preserve">
          <source>Trackers must implement &lt;code&gt;start_link/1&lt;/code&gt;, &lt;code&gt;init/1&lt;/code&gt;, and &lt;code&gt;handle_diff/2&lt;/code&gt;. The &lt;code&gt;init/1&lt;/code&gt; callback allows the tracker to manage its own state when running within the &lt;a href=&quot;phoenix.tracker#content&quot;&gt;&lt;code&gt;Phoenix.Tracker&lt;/code&gt;&lt;/a&gt; server. The &lt;code&gt;handle_diff&lt;/code&gt; callback is invoked with a diff of presence join and leave events, grouped by topic. As replicas heartbeat and replicate data, the local tracker state is merged with the remote data, and the diff is sent to the callback. The handler can use this information to notify subscribers of events, as done above.</source>
          <target state="translated">跟踪器必须实现 &lt;code&gt;start_link/1&lt;/code&gt; ， &lt;code&gt;init/1&lt;/code&gt; 和 &lt;code&gt;handle_diff/2&lt;/code&gt; 。当在&lt;a href=&quot;phoenix.tracker#content&quot;&gt; &lt;code&gt;Phoenix.Tracker&lt;/code&gt; &lt;/a&gt;服务器中运行时， &lt;code&gt;init/1&lt;/code&gt; 回调允许跟踪器管理其自己的状态。该 &lt;code&gt;handle_diff&lt;/code&gt; 函数调用时存在的差异加入和离开事件，按主题进行分组。在复制心跳和复制数据时，本地跟踪器状态将与远程数据合并，并且差异将发送到回调。处理程序可以使用此信息来通知订户事件，如上所述。</target>
        </trans-unit>
        <trans-unit id="ec88a8caf33e733f9f82eb74118f40a505db5749" translate="yes" xml:space="preserve">
          <source>Tracking changes</source>
          <target state="translated">跟踪变化</target>
        </trans-unit>
        <trans-unit id="bfd71a4b69dd23e4fec03cebbf6443963a3bb4f1" translate="yes" xml:space="preserve">
          <source>Tracks a presence</source>
          <target state="translated">追踪存在</target>
        </trans-unit>
        <trans-unit id="f77d00c25a6c8aa2f028ccd4ee433e0eac247ebb" translate="yes" xml:space="preserve">
          <source>Tracks a presence.</source>
          <target state="translated">追踪一个存在。</target>
        </trans-unit>
        <trans-unit id="4d967b73b508c2dfcc359e0a2212dfc6cf38b5f5" translate="yes" xml:space="preserve">
          <source>Tracks the source prefix in the data storage.</source>
          <target state="translated">追踪数据存储中的源前缀。</target>
        </trans-unit>
        <trans-unit id="04dbde923a480822fb49f6a9f57a11e1e45c2f34" translate="yes" xml:space="preserve">
          <source>Translates a &lt;a href=&quot;phoenix.socket.broadcast&quot;&gt;&lt;code&gt;Phoenix.Socket.Broadcast&lt;/code&gt;&lt;/a&gt; struct to fastlane format</source>
          <target state="translated">将&lt;a href=&quot;phoenix.socket.broadcast&quot;&gt; &lt;code&gt;Phoenix.Socket.Broadcast&lt;/code&gt; &lt;/a&gt;结构转换为fastlane格式</target>
        </trans-unit>
        <trans-unit id="fa2fb74c7c1ff29a1c97955f10736fc44d4c709e" translate="yes" xml:space="preserve">
          <source>Translates to the underlying SQL ILIKE query. This operation is only available on PostgreSQL.</source>
          <target state="translated">翻译成底层SQL ILIKE查询。此操作仅在PostgreSQL上可用。</target>
        </trans-unit>
        <trans-unit id="5e04600e3ea7e7907ea952ea71a5864369b3424b" translate="yes" xml:space="preserve">
          <source>Translates to the underlying SQL LIKE query, therefore its behaviour is dependent on the database. In particular, PostgreSQL will do a case-sensitive operation, while the majority of other databases will be case-insensitive. For performing a case-insensitive &lt;code&gt;like&lt;/code&gt; in PostgreSQL, see &lt;a href=&quot;#ilike/2&quot;&gt;&lt;code&gt;ilike/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">转换为基础SQL LIKE查询，因此其行为取决于数据库。特别是，PostgreSQL将执行区分大小写的操作，而其他大多数数据库将不区分大小写。要 &lt;code&gt;like&lt;/code&gt; 在PostgreSQL中那样执行不区分大小写的操作，请参阅&lt;a href=&quot;#ilike/2&quot;&gt; &lt;code&gt;ilike/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="892c52a641684add2f2c13d64228138e346b88e9" translate="yes" xml:space="preserve">
          <source>Transports can optionally implement &lt;a href=&quot;#c:handle_control/2&quot;&gt;&lt;code&gt;handle_control/2&lt;/code&gt;&lt;/a&gt; for handling control frames such as &lt;code&gt;:ping&lt;/code&gt; and &lt;code&gt;:pong&lt;/code&gt;.</source>
          <target state="translated">传输器可以选择实现&lt;a href=&quot;#c:handle_control/2&quot;&gt; &lt;code&gt;handle_control/2&lt;/code&gt; &lt;/a&gt;来处理诸如 &lt;code&gt;:ping&lt;/code&gt; 和 &lt;code&gt;:pong&lt;/code&gt; 之类的控制帧。</target>
        </trans-unit>
        <trans-unit id="50ec8431700d39c092c58101a53cd1456d35e7d7" translate="yes" xml:space="preserve">
          <source>Traverses changeset errors and applies the given function to error messages</source>
          <target state="translated">遍历变化集错误并将给定的函数应用于错误信息。</target>
        </trans-unit>
        <trans-unit id="8cbe92e33468200a0827118c7f3d01b4a4843741" translate="yes" xml:space="preserve">
          <source>Traverses changeset errors and applies the given function to error messages.</source>
          <target state="translated">遍历变化集错误,并将给定的函数应用于错误信息。</target>
        </trans-unit>
        <trans-unit id="0f6e81017aaf95b363450b6d7b0752a8fb3d2fef" translate="yes" xml:space="preserve">
          <source>Tuple &lt;code&gt;{module, function, args}&lt;/code&gt; can be passed to be invoked each time the plug is checking whether to redirect host. Provided function needs to receive at least one argument (&lt;code&gt;host&lt;/code&gt;).</source>
          <target state="translated">每次插件检查是否重定向主机时，都可以传递元组 &lt;code&gt;{module, function, args}&lt;/code&gt; 进行调用。提供的函数需要接收至少一个参数（ &lt;code&gt;host&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="98a6dbefab197c1c589aaa284bb9c90aca73a018" translate="yes" xml:space="preserve">
          <source>Two or more consecutive newlines &lt;code&gt;\n\n&lt;/code&gt; or &lt;code&gt;\r\n\r\n&lt;/code&gt; are considered as a paragraph and text between them is wrapped in &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; tags. One newline &lt;code&gt;\n&lt;/code&gt; or &lt;code&gt;\r\n&lt;/code&gt; is considered as a linebreak and a &lt;code&gt;&amp;lt;br&amp;gt;&lt;/code&gt; tag is inserted.</source>
          <target state="translated">两个或多个连续换行符 &lt;code&gt;\n\n&lt;/code&gt; 或 &lt;code&gt;\r\n\r\n&lt;/code&gt; 被视为一个段落，并且它们之间的文本被包装在 &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; 标记中。一个换行符 &lt;code&gt;\n&lt;/code&gt; 或 &lt;code&gt;\r\n&lt;/code&gt; 被视为换行符，并插入了 &lt;code&gt;&amp;lt;br&amp;gt;&lt;/code&gt; 标记。</target>
        </trans-unit>
        <trans-unit id="154308bd4c8a066d5d9c6258416a1b30f7bd6212" translate="yes" xml:space="preserve">
          <source>Type and subtype are case insensitive while the sensitiveness of params depends on their keys and therefore are not handled by this parser.</source>
          <target state="translated">类型和子类型是不区分大小写的,而参数的敏感性则取决于它们的键,因此这个解析器不处理。</target>
        </trans-unit>
        <trans-unit id="93b9e289e2842469d001eccf7ad5d79f3c302dc9" translate="yes" xml:space="preserve">
          <source>Types</source>
          <target state="translated">Types</target>
        </trans-unit>
        <trans-unit id="2b93aaf665984dcdc2d122fc68d22290dc98430f" translate="yes" xml:space="preserve">
          <source>Types and casting</source>
          <target state="translated">类型和铸造</target>
        </trans-unit>
        <trans-unit id="fccbdec63f1e673c35ac4ad2b3198a6d03985d97" translate="yes" xml:space="preserve">
          <source>URL can include query parameters to override shared and adapter-specific options &lt;code&gt;ssl&lt;/code&gt;, &lt;code&gt;timeout&lt;/code&gt;, &lt;code&gt;pool_timeout&lt;/code&gt;, &lt;code&gt;pool_size&lt;/code&gt;:</source>
          <target state="translated">URL可以包含查询参数，以覆盖共享的和适配器特定的选项 &lt;code&gt;ssl&lt;/code&gt; ， &lt;code&gt;timeout&lt;/code&gt; ， &lt;code&gt;pool_timeout&lt;/code&gt; ， &lt;code&gt;pool_size&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="2062e8d014f9cc3812946feab252c6f50a8a1a8d" translate="yes" xml:space="preserve">
          <source>URL can include query parameters to override shared and adapter-specific options, like &lt;code&gt;ssl&lt;/code&gt;, &lt;code&gt;timeout&lt;/code&gt; and &lt;code&gt;pool_size&lt;/code&gt;. The following example shows how to pass these configuration values:</source>
          <target state="translated">URL可以包含查询参数以覆盖共享的和适配器特定的选项，例如 &lt;code&gt;ssl&lt;/code&gt; ， &lt;code&gt;timeout&lt;/code&gt; 和 &lt;code&gt;pool_size&lt;/code&gt; 。以下示例显示如何传递这些配置值：</target>
        </trans-unit>
        <trans-unit id="01f03837323aab32409bb99c50d6c475179c49df" translate="yes" xml:space="preserve">
          <source>URLs</source>
          <target state="translated">URLs</target>
        </trans-unit>
        <trans-unit id="c936fe014fbf52d248e23e83c4f7c389f5578501" translate="yes" xml:space="preserve">
          <source>UTF-8 encoded &lt;code&gt;string&lt;/code&gt;</source>
          <target state="translated">UTF-8编码的 &lt;code&gt;string&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0541e2d015eef80c9c2da6778b6e2c6a68cb7f30" translate="yes" xml:space="preserve">
          <source>Umbrella projects do not have a default router and therefore always expect a router to be given.</source>
          <target state="translated">伞形项目没有默认的路由器,因此总是希望给一个路由器。</target>
        </trans-unit>
        <trans-unit id="8768d73251c0569d327c1e364eafb4d5ea1eb2da" translate="yes" xml:space="preserve">
          <source>Unary &lt;code&gt;not&lt;/code&gt; operation</source>
          <target state="translated">一元 &lt;code&gt;not&lt;/code&gt; 运算</target>
        </trans-unit>
        <trans-unit id="ae6d1341c40bcf85b2e3992e163df198136c8fe0" translate="yes" xml:space="preserve">
          <source>Unary &lt;code&gt;not&lt;/code&gt; operation.</source>
          <target state="translated">一元 &lt;code&gt;not&lt;/code&gt; 操作。</target>
        </trans-unit>
        <trans-unit id="8528d9a060404341b909c95a03193ce5217db1fb" translate="yes" xml:space="preserve">
          <source>Uncomment or add the following to this list of children in your Telemetry supervision tree (usually in &lt;code&gt;lib/my_app_web/telemetry.ex&lt;/code&gt;):</source>
          <target state="translated">在遥测监视树（通常在 &lt;code&gt;lib/my_app_web/telemetry.ex&lt;/code&gt; 中）中取消注释或将以下内容添加到此子级列表中：</target>
        </trans-unit>
        <trans-unit id="e20734e624a02ccb4b9b198469134b0f85370de0" translate="yes" xml:space="preserve">
          <source>Under other circumstances, you may be testing a view or another layer that requires a connection for processing. For such cases, a connection can be created using the &lt;a href=&quot;#build_conn/3&quot;&gt;&lt;code&gt;build_conn/3&lt;/code&gt;&lt;/a&gt; helper:</source>
          <target state="translated">在其他情况下，您可能正在测试需要连接进行处理的视图或其他层。在这种情况下，可以使用&lt;a href=&quot;#build_conn/3&quot;&gt; &lt;code&gt;build_conn/3&lt;/code&gt; &lt;/a&gt;帮助程序来创建连接：</target>
        </trans-unit>
        <trans-unit id="8b5c67037bf5470da236e2bdde573521f2424de5" translate="yes" xml:space="preserve">
          <source>Under other circumstances, you may be testing a view or another layer that requires a connection for processing. For such cases, a connection can be created using the &lt;a href=&quot;#conn/3&quot;&gt;&lt;code&gt;conn/3&lt;/code&gt;&lt;/a&gt; helper:</source>
          <target state="translated">在其他情况下，您可能正在测试需要连接进行处理的视图或其他层。对于这种情况，可以使用&lt;a href=&quot;#conn/3&quot;&gt; &lt;code&gt;conn/3&lt;/code&gt; &lt;/a&gt;帮助器创建连接：</target>
        </trans-unit>
        <trans-unit id="f1ff53ee2862d2d446a35b1e8111b19a37147a3a" translate="yes" xml:space="preserve">
          <source>Understanding template compilation</source>
          <target state="translated">了解模板汇编</target>
        </trans-unit>
        <trans-unit id="d3c65bf16f98fec621f47e764e587b2f2e1621e5" translate="yes" xml:space="preserve">
          <source>Unexpected scenarios</source>
          <target state="translated">意外情况</target>
        </trans-unit>
        <trans-unit id="03a6558018657fa99e805a8a68718f47b7b414d0" translate="yes" xml:space="preserve">
          <source>Unfortunately, different databases provide different guarantees when it comes to case-sensitiveness. For example, in MySQL, comparisons are case-insensitive by default. In Postgres, users can define case insensitive column by using the &lt;code&gt;:citext&lt;/code&gt; type/extension. In your migration:</source>
          <target state="translated">不幸的是，在区分大小写方面，不同的数据库提供了不同的保证。例如，在MySQL中，默认情况下，比较不区分大小写。在Postgres中，用户可以使用 &lt;code&gt;:citext&lt;/code&gt; 类型/扩展名定义不区分大小写的列。在您的迁移中：</target>
        </trans-unit>
        <trans-unit id="ebda784e9b2848ef9558c97ee4b8fa423fa74c91" translate="yes" xml:space="preserve">
          <source>Union expression returns only unique rows as if each query returned distinct results. This may cause performance penalty. If you need just to combine multiple result sets without removing duplicate rows consider using &lt;a href=&quot;#union_all/2&quot;&gt;&lt;code&gt;union_all/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">联合表达式仅返回唯一的行，就像每个查询返回不同的结果一样。这可能会导致性能下降。如果只需要合并多个结果集而不删除重复的行，请考虑使用&lt;a href=&quot;#union_all/2&quot;&gt; &lt;code&gt;union_all/2&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1b3223e5b025350dc7c873af657f6279cba89acf" translate="yes" xml:space="preserve">
          <source>Unique columns can be automatically generated by using:</source>
          <target state="translated">可以通过使用以下方法自动生成独特的列。</target>
        </trans-unit>
        <trans-unit id="31a9c9a9da9b4997ddb48f0c0710b0ce5b2a182a" translate="yes" xml:space="preserve">
          <source>Unless held-down keys are required, a better approach is generally to use &lt;code&gt;phx-keyup&lt;/code&gt; bindings which only trigger on key up, thereby being self-limiting. However, &lt;code&gt;phx-keydown&lt;/code&gt; is useful for games and other use cases where a constant press on a key is desired. In such cases, throttle should always be used.</source>
          <target state="translated">除非需要按下的键，否则更好的方法通常是使用仅在按下键时触发的 &lt;code&gt;phx-keyup&lt;/code&gt; 绑定，从而实现自我限制。但是， &lt;code&gt;phx-keydown&lt;/code&gt; 可用于游戏和其他需要不断按某个键的用例。在这种情况下，应始终使用节气门。</target>
        </trans-unit>
        <trans-unit id="364ff4689b83184f9cf200c53fb47d7dfe4a19d2" translate="yes" xml:space="preserve">
          <source>Unless you have dozens of columns, this is simpler for the developer, more DB friendly and more efficient in all aspects.</source>
          <target state="translated">除非你有几十列,否则对开发者来说,这样做更简单,对DB更友好,各方面效率更高。</target>
        </trans-unit>
        <trans-unit id="6dbbc01e9238f5b47a1c02fc53c7e8b555358fa3" translate="yes" xml:space="preserve">
          <source>Unsubscribes the caller from the PubSub adapter&amp;rsquo;s topic</source>
          <target state="translated">从PubSub适配器的主题退订呼叫者</target>
        </trans-unit>
        <trans-unit id="482cecc4861f7c77f0cec819a536c79e2d690881" translate="yes" xml:space="preserve">
          <source>Unsubscribes the caller from the PubSub adapter&amp;rsquo;s topic.</source>
          <target state="translated">从PubSub适配器的主题退订呼叫者。</target>
        </trans-unit>
        <trans-unit id="c4431f0ea76c1f1e2f3d65fe926de8de3246221b" translate="yes" xml:space="preserve">
          <source>Unsubscribes the caller from the PubSub adapter's topic.</source>
          <target state="translated">将调用者从PubSub适配器的主题中取消订阅。</target>
        </trans-unit>
        <trans-unit id="181cb46e23fe9bb176c35f8d9f9e02d873ba1397" translate="yes" xml:space="preserve">
          <source>Unsubscribes the caller from the given topic</source>
          <target state="translated">取消呼叫者对指定主题的订阅。</target>
        </trans-unit>
        <trans-unit id="dfb3c1161312f219c23d938f551cae6ab3a67d2a" translate="yes" xml:space="preserve">
          <source>Unsubscribes the caller from the given topic.</source>
          <target state="translated">取消呼叫者对指定主题的订阅。</target>
        </trans-unit>
        <trans-unit id="8e4d4756b56c5c2a38de9c36247d3bf735dff1a1" translate="yes" xml:space="preserve">
          <source>Unsubscribes the pid from the topic</source>
          <target state="translated">将pid从主题中取消订阅。</target>
        </trans-unit>
        <trans-unit id="937f4447c61b885d2272aeadbcc25a892061149c" translate="yes" xml:space="preserve">
          <source>Unsubscribes the pid from the topic.</source>
          <target state="translated">将pid从主题中取消订阅。</target>
        </trans-unit>
        <trans-unit id="f7f95de69369cee5491d0b2318e7e16ee32f3693" translate="yes" xml:space="preserve">
          <source>Untracks a presence</source>
          <target state="translated">解开一个存在</target>
        </trans-unit>
        <trans-unit id="00a3c6eca2c9c5467d7eda3ff19f2b3a3f0b9f13" translate="yes" xml:space="preserve">
          <source>Untracks a presence.</source>
          <target state="translated">解开了一个存在。</target>
        </trans-unit>
        <trans-unit id="f662645adc1966f7f57b2b2a62ac566f868b5e24" translate="yes" xml:space="preserve">
          <source>Up and Running</source>
          <target state="translated">启动和运行</target>
        </trans-unit>
        <trans-unit id="fb41bed7c754707f32bbce1dc683efccb4519d20" translate="yes" xml:space="preserve">
          <source>Update a channel presence's metadata.</source>
          <target state="translated">更新一个频道的元数据。</target>
        </trans-unit>
        <trans-unit id="d1e9810594beffedf05646229838b1d174fadeb7" translate="yes" xml:space="preserve">
          <source>Update a process presence's metadata.</source>
          <target state="translated">更新进程存在的元数据。</target>
        </trans-unit>
        <trans-unit id="c76d18079a076ee34ffc62b5b9bd0909da356dce" translate="yes" xml:space="preserve">
          <source>Updates</source>
          <target state="translated">Updates</target>
        </trans-unit>
        <trans-unit id="efde7464a7ffd43310a0d38ea8d45264ea41ceae" translate="yes" xml:space="preserve">
          <source>Updates a change</source>
          <target state="translated">更新变化</target>
        </trans-unit>
        <trans-unit id="4960f1d23ffd2b7d1ab51393bbb07ff03fb4eeb5" translate="yes" xml:space="preserve">
          <source>Updates a change.</source>
          <target state="translated">更新变化。</target>
        </trans-unit>
        <trans-unit id="9e3e9b085b2135f1f85213c1f86af920a1755f04" translate="yes" xml:space="preserve">
          <source>Updates a changeset using its primary key</source>
          <target state="translated">用它的主键更新一个变化集</target>
        </trans-unit>
        <trans-unit id="c93c04e332aa599946d58eaecaa78d3cdd5a2eb1" translate="yes" xml:space="preserve">
          <source>Updates a changeset using its primary key.</source>
          <target state="translated">使用它的主键更新一个变化集。</target>
        </trans-unit>
        <trans-unit id="3385b9dce3c90d599cae02d4653dbca93a29bcc4" translate="yes" xml:space="preserve">
          <source>Updates a presence&amp;rsquo;s metadata</source>
          <target state="translated">更新状态的元数据</target>
        </trans-unit>
        <trans-unit id="0acdc22a28ee11a8afdd3431b0315855715fa2bc" translate="yes" xml:space="preserve">
          <source>Updates a presence&amp;rsquo;s metadata.</source>
          <target state="translated">更新状态的元数据。</target>
        </trans-unit>
        <trans-unit id="132594d301d9e633427f4d91489bd56edf757c2c" translate="yes" xml:space="preserve">
          <source>Updates a presence's metadata.</source>
          <target state="translated">更新一个存在的元数据。</target>
        </trans-unit>
        <trans-unit id="c01320a0cc1e6fafc6bb2e70c6fddc03bae55710" translate="yes" xml:space="preserve">
          <source>Updates a request header if present, otherwise it sets it to an initial value</source>
          <target state="translated">如果存在,则更新请求头,否则将其设置为初始值。</target>
        </trans-unit>
        <trans-unit id="045227cef9e475014998b6e238302ad6bc1ea08b" translate="yes" xml:space="preserve">
          <source>Updates a request header if present, otherwise it sets it to an initial value.</source>
          <target state="translated">如果存在,则更新请求头,否则设置为初始值。</target>
        </trans-unit>
        <trans-unit id="0458896d317ccb81c30dba901118e2743e4a5416" translate="yes" xml:space="preserve">
          <source>Updates a response header if present, otherwise it sets it to an initial value</source>
          <target state="translated">如果存在,则更新响应头,否则将其设置为初始值。</target>
        </trans-unit>
        <trans-unit id="aca7d4e48cb32323eeef9d6da6338f24bc32a47f" translate="yes" xml:space="preserve">
          <source>Updates a response header if present, otherwise it sets it to an initial value.</source>
          <target state="translated">如果存在,则更新响应头,否则设置为初始值。</target>
        </trans-unit>
        <trans-unit id="607386542c3c782f031294b17742c0818b532a58" translate="yes" xml:space="preserve">
          <source>Updates a single struct with the given filters</source>
          <target state="translated">用给定的过滤器更新单个结构</target>
        </trans-unit>
        <trans-unit id="b883e138c47eee8bc7395bc0ee931698e3b1bac8" translate="yes" xml:space="preserve">
          <source>Updates a single struct with the given filters.</source>
          <target state="translated">用给定的过滤器更新单个结构。</target>
        </trans-unit>
        <trans-unit id="c6a6a639373c46aeccd5f9b2b8b38de4b2dae7bd" translate="yes" xml:space="preserve">
          <source>Updates all entries matching the given query with the given values</source>
          <target state="translated">用给定的值更新所有与给定查询匹配的条目。</target>
        </trans-unit>
        <trans-unit id="330ebb6cefd9ef9f1f8a72396cfd06403a7c55e1" translate="yes" xml:space="preserve">
          <source>Updates all entries matching the given query with the given values.</source>
          <target state="translated">用给定的值更新所有与给定查询匹配的条目。</target>
        </trans-unit>
        <trans-unit id="1c2e283ce7915c1bbb24433633c806a5a301b678" translate="yes" xml:space="preserve">
          <source>Updates an existing key in the socket assigns.</source>
          <target state="translated">更新套接字分配中的现有密钥。</target>
        </trans-unit>
        <trans-unit id="7762e945e6baaa0818bffbab49c2f32dcef1ea19" translate="yes" xml:space="preserve">
          <source>Updates are patched to the DOM as usual</source>
          <target state="translated">像往常一样对DOM进行更新</target>
        </trans-unit>
        <trans-unit id="9274df775f7c52402be32f42089e570c5a110dfe" translate="yes" xml:space="preserve">
          <source>Updates are used to update the filtered entries. In order for updates to be applied, &lt;a href=&quot;ecto.repo#c:update_all/3&quot;&gt;&lt;code&gt;Ecto.Repo.update_all/3&lt;/code&gt;&lt;/a&gt; must be invoked.</source>
          <target state="translated">更新用于更新过滤的条目。为了应用更新，必须调用&lt;a href=&quot;ecto.repo#c:update_all/3&quot;&gt; &lt;code&gt;Ecto.Repo.update_all/3&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="30d7abe8ce119c87145e38b618e0cb0eb1692bb6" translate="yes" xml:space="preserve">
          <source>Updates the Phoenix project generator locally.</source>
          <target state="translated">在本地更新凤凰项目生成器。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
