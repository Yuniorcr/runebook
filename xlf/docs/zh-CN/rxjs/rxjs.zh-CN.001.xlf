<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="rxjs">
    <body>
      <group id="rxjs">
        <trans-unit id="392ce755360743798adc6f37abf60a01a85dac13" translate="yes" xml:space="preserve">
          <source>&quot;Complete&quot; notification: does not send a value.</source>
          <target state="translated">&amp;ldquo;完成&amp;rdquo;通知：不发送值。</target>
        </trans-unit>
        <trans-unit id="c81d9f638ee0e1bf38fde281d7d0722e5ae02890" translate="yes" xml:space="preserve">
          <source>&quot;Creation&quot; operators The following operators have been moved from &lt;code&gt;rxjs/operators&lt;/code&gt; to &lt;code&gt;rxjs&lt;/code&gt;, and their usage has changed:</source>
          <target state="translated">&amp;ldquo;创建&amp;rdquo;运算符以下运算符已从 &lt;code&gt;rxjs/operators&lt;/code&gt; 移至 &lt;code&gt;rxjs&lt;/code&gt; ，并且它们的用法已更改：</target>
        </trans-unit>
        <trans-unit id="3e7d16b53c2fad1237d23976a605c79f1b13451d" translate="yes" xml:space="preserve">
          <source>&quot;Error&quot; notification: sends a JavaScript Error or exception.</source>
          <target state="translated">&amp;ldquo;错误&amp;rdquo;通知：发送JavaScript错误或异常。</target>
        </trans-unit>
        <trans-unit id="61ed1f5cc7d257c5a6fb114343a8ac81acd81a74" translate="yes" xml:space="preserve">
          <source>&quot;Marble Tests&quot; are tests that use a specialized VirtualScheduler called the &lt;code&gt;TestScheduler&lt;/code&gt;. They enable us to test asynchronous operations in a synchronous and dependable manner. The &quot;marble notation&quot; is something that's been adapted from many teachings and documents by people such as &lt;a href=&quot;https://twitter.com/jhusain&quot;&gt;@jhusain&lt;/a&gt;, &lt;a href=&quot;https://twitter.com/headinthebox&quot;&gt;@headinthebox&lt;/a&gt;, &lt;a href=&quot;https://twitter.com/mattpodwysocki&quot;&gt;@mattpodwysocki&lt;/a&gt; and &lt;a href=&quot;https://twitter.com/andrestaltz&quot;&gt;@andrestaltz&lt;/a&gt;. In fact, Andr&amp;eacute; Staltz first recommended this as a DSL for creating unit tests, and it has since been altered and adopted.</source>
          <target state="translated">&amp;ldquo;大理石测试&amp;rdquo;是使用称为 &lt;code&gt;TestScheduler&lt;/code&gt; 的专用VirtualScheduler的测试。它们使我们能够以同步且可靠的方式测试异步操作。&amp;ldquo;大理石符号&amp;rdquo;已被&lt;a href=&quot;https://twitter.com/jhusain&quot;&gt;@jhusain&lt;/a&gt;，&lt;a href=&quot;https://twitter.com/headinthebox&quot;&gt;@headinthebox&lt;/a&gt;，&lt;a href=&quot;https://twitter.com/mattpodwysocki&quot;&gt;@mattpodwysocki&lt;/a&gt;等人的许多教义和文档改编而成和&lt;a href=&quot;https://twitter.com/andrestaltz&quot;&gt;@andrestaltz之&lt;/a&gt;。实际上，Andr&amp;eacute;Staltz最初将其推荐为DSL以用于创建单元测试，并且此后对其进行了更改和采用。</target>
        </trans-unit>
        <trans-unit id="42a2c7dc9cd6a678723aae38fa9f03c7b8bf1f15" translate="yes" xml:space="preserve">
          <source>&quot;Next&quot; notification: sends a value such as a Number, a String, an Object, etc.</source>
          <target state="translated">&amp;ldquo;下一个&amp;rdquo;通知：发送一个值，例如数字，字符串，对象等。</target>
        </trans-unit>
        <trans-unit id="cd753dbdc17c8e8263d11f9f804dab829f01e73e" translate="yes" xml:space="preserve">
          <source>&quot;Next&quot; notifications are the most important and most common type: they represent actual data being delivered to an subscriber. &quot;Error&quot; and &quot;Complete&quot; notifications may happen only once during the Observable Execution, and there can only be either one of them.</source>
          <target state="translated">&amp;ldquo;下一个&amp;rdquo;通知是最重要和最常见的类型：它们表示正在传递给订户的实际数据。&amp;ldquo;错误&amp;rdquo;和&amp;ldquo;完成&amp;rdquo;通知在可观察的执行期间只能发生一次，并且只能有一个。</target>
        </trans-unit>
        <trans-unit id="346adb0427f466457992cab12b66149214b60148" translate="yes" xml:space="preserve">
          <source>&amp;copy; 2015&amp;ndash;2018 Google, Inc., Netflix, Inc., Microsoft Corp. and contributors.</source>
          <target state="translated">&amp;copy;2015&amp;ndash;2018 Google，Inc.，Netflix，Inc.，Microsoft Corp.和贡献者。</target>
        </trans-unit>
        <trans-unit id="ec83739778c86aaa8e3c14cb62c33740056380aa" translate="yes" xml:space="preserve">
          <source>(The &lt;code&gt;pipe()&lt;/code&gt; function is analogous to, but not the same thing as, the &lt;code&gt;.pipe()&lt;/code&gt; method on an Observable.)</source>
          <target state="translated">（ &lt;code&gt;pipe()&lt;/code&gt; 函数类似于Observable上的 &lt;code&gt;.pipe()&lt;/code&gt; 方法，但与之不同）。</target>
        </trans-unit>
        <trans-unit id="11fc77211983736b813c658ece601fdcc5bca5b3" translate="yes" xml:space="preserve">
          <source>// Logs: // 0 // 1 // 2 // &quot;Yo!&quot;</source>
          <target state="translated">//日志：// 0 // 1 // 2 //&amp;ldquo; Yo！&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="413662e05fbda8a75422816345471abce134f0b2" translate="yes" xml:space="preserve">
          <source>// Logs: // 0 // 1000 // 2000 // &quot;Yo!&quot;</source>
          <target state="translated">//日志：// 0 // 1000 // 2000 //&amp;ldquo; Yo！&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="4cf7b3b0689dc3d62e361b359129706be46007b9" translate="yes" xml:space="preserve">
          <source>// Logs: // 0 // 1000 // 2000 // 3000 // ...and never stops.</source>
          <target state="translated">//日志：// 0 // 1000 // 2000 // 3000 // ...并且永不停止。</target>
        </trans-unit>
        <trans-unit id="4932860fd63504b051ce368dbc339d987387b63a" translate="yes" xml:space="preserve">
          <source>1 frame is 10 virtual milliseconds by default. i.e. &lt;code&gt;TestScheduler.frameTimeFactor = 10&lt;/code&gt;</source>
          <target state="translated">默认情况下，一帧是10个虚拟毫秒。即 &lt;code&gt;TestScheduler.frameTimeFactor = 10&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d65e71651123d00f13f6a1dd9134124f96f272f3" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;../api/operators/exhaust&quot;&gt;&lt;code&gt;exhaust()&lt;/code&gt;&lt;/a&gt; &amp;mdash; subscribes to the first inner Observable when it arrives, and emits each value as it arrives, discarding all newly arriving inner Observables until that first one completes, then waits for the next inner Observable.</source>
          <target state="translated">&lt;a href=&quot;../api/operators/exhaust&quot;&gt; &lt;code&gt;exhaust()&lt;/code&gt; &lt;/a&gt; &amp;mdash;当第一个内部Observable到达时订阅它，并在到达时发出每个值，并丢弃所有新到达的内部Observable，直到第一个内部Observable完成，然后等待下一个内部Observable。</target>
        </trans-unit>
        <trans-unit id="7a7ea42cc6cca0849dbb1c78069f7e16487eadce" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;../api/operators/mergeall&quot;&gt;&lt;code&gt;mergeAll()&lt;/code&gt;&lt;/a&gt; &amp;mdash; subscribes to each inner Observable as it arrives, then emits each value as it arrives</source>
          <target state="translated">&lt;a href=&quot;../api/operators/mergeall&quot;&gt; &lt;code&gt;mergeAll()&lt;/code&gt; &lt;/a&gt; &amp;mdash;在每个内部Observable到达时订阅它，然后在到达每个内部值时发出每个值</target>
        </trans-unit>
        <trans-unit id="00d7dfe90d22907f84e2b9aa6d174c7093188de9" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;../api/operators/switchall&quot;&gt;&lt;code&gt;switchAll()&lt;/code&gt;&lt;/a&gt; &amp;mdash; subscribes to the first inner Observable when it arrives, and emits each value as it arrives, but when the next inner Observable arrives, unsubscribes to the previous one, and subscribes to the new one.</source>
          <target state="translated">&lt;a href=&quot;../api/operators/switchall&quot;&gt; &lt;code&gt;switchAll()&lt;/code&gt; &lt;/a&gt; &amp;mdash;在第一个内部Observable到达时订阅它，并在到达时发出每个值，但是在下一个内部Observable到达时，取消订阅上一个，并订阅新的。</target>
        </trans-unit>
        <trans-unit id="6a5210f0bf7d5b359aadf70cf0e45a3b962eba14" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;../index/class/subject&quot;&gt;&lt;code&gt;Subject&lt;/code&gt;&lt;/a&gt; that communicates with a server via WebSocket</source>
          <target state="translated">&lt;a href=&quot;../index/class/subject&quot;&gt; &lt;code&gt;Subject&lt;/code&gt; &lt;/a&gt;通过WebSocket与服务器通信的主题</target>
        </trans-unit>
        <trans-unit id="058d6b50d45cc928153edc804bde7133ba593471" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;!&quot;&lt;/code&gt; unsubscription point: shows the point in time at which a subscription is unsubscribed.</source>
          <target state="translated">&lt;code&gt;&quot;!&quot;&lt;/code&gt; 取消订阅点：显示取消订阅的时间点。</target>
        </trans-unit>
        <trans-unit id="81a3ce5520c5667d66bf855b46c44589a826a0d5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;#&quot;&lt;/code&gt; error: An error terminating the observable. This is the observable producer signaling &lt;code&gt;error()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&quot;#&quot;&lt;/code&gt; 错误：终止可观察的错误。这是可观察到的生产者信令 &lt;code&gt;error()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="107cfd640387781b75d0bb619e0d899ed5b34314" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;()&quot;&lt;/code&gt; sync groupings: When multiple events need to be in the same frame synchronously, parentheses are used to group those events. You can group nexted values, a completion or an error in this manner. The position of the initial &lt;code&gt;(&lt;/code&gt; determines the time at which its values are emitted.</source>
          <target state="translated">&lt;code&gt;&quot;()&quot;&lt;/code&gt; 同步分组：当多个事件需要同步在同一帧中时，使用括号将这些事件分组。您可以通过这种方式将下一个值，完成或错误分组。首字母的位置 &lt;code&gt;(&lt;/code&gt; 确定发出其值的时间。</target>
        </trans-unit>
        <trans-unit id="064762d55524c322feeaa267de2dba55cae25836" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;-&quot;&lt;/code&gt; time: 10 &quot;frames&quot; of the passage.</source>
          <target state="translated">&lt;code&gt;&quot;-&quot;&lt;/code&gt; 时间：段落的10个&amp;ldquo;帧&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="8e080bce20eb3fc6c4946b152fe200b8a369f991" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;-&quot;&lt;/code&gt; time: 10 &quot;frames&quot; of time passage.</source>
          <target state="translated">&lt;code&gt;&quot;-&quot;&lt;/code&gt; 时间：10个&amp;ldquo;帧&amp;rdquo;的时间流逝。</target>
        </trans-unit>
        <trans-unit id="48a3e4768e9a2314ab6c955d210fda5eee9e16ea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;^&quot;&lt;/code&gt; subscription point: (hot observables only) shows the point at which the tested observables will be subscribed to the hot observable. This is the &quot;zero frame&quot; for that observable, every frame before the &lt;code&gt;^&lt;/code&gt; will be negative.</source>
          <target state="translated">&lt;code&gt;&quot;^&quot;&lt;/code&gt; 订阅点：（仅热观测值）显示测试的可观测对象将被订阅到该热观测值的点。这是可观察到的&amp;ldquo;零帧&amp;rdquo;， &lt;code&gt;^&lt;/code&gt; 之前的每个帧都是负数。</target>
        </trans-unit>
        <trans-unit id="00e0999da09e1b7ac615beac5e032458d7eaeb8f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;^&quot;&lt;/code&gt; subscription point: shows the point in time at which a subscription happen.</source>
          <target state="translated">&lt;code&gt;&quot;^&quot;&lt;/code&gt; 订阅点：显示订阅发生的时间点。</target>
        </trans-unit>
        <trans-unit id="42596687beb2a6b5b9594c84cc181a1c419f8a34" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;a&quot;&lt;/code&gt; any character: All other characters represent a value being emitted by the producer signaling &lt;code&gt;next()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&quot;a&quot;&lt;/code&gt; 任何字符：所有其他字符表示生产者通过信号 &lt;code&gt;next()&lt;/code&gt; 发送的值</target>
        </trans-unit>
        <trans-unit id="d0f4e7bf26a0b7700ddaf9f8256bbac86b3539a0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;|&quot;&lt;/code&gt; complete: The successful completion of an observable. This is the observable producer signaling &lt;code&gt;complete()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&quot;|&quot;&lt;/code&gt; complete：成功完成一个可观察的对象。这是可观察到的生产者发出的信号 &lt;code&gt;complete()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="264671634e07abdf4534265024ab55c7443d1523" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;#&lt;/code&gt;: Equivalent to &lt;code&gt;Observable.throw()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;#&lt;/code&gt; ：相当于 &lt;code&gt;Observable.throw()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="826146bd4f6b3958dfa2716d8a103525afcd4809" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;#&lt;/code&gt;: Equivalent to &lt;code&gt;throwError()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;#&lt;/code&gt; ：等同于 &lt;code&gt;throwError()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="63834177a0d274bef046c96bd46b7d79ffa05fb0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;' '&lt;/code&gt; whitespace: horizontal whitespace is ignored, and can be used to help vertically align multiple marble diagrams.</source>
          <target state="translated">&lt;code&gt;' '&lt;/code&gt; 空白：水平空白将被忽略，可用于帮助垂直对齐多个大理石图。</target>
        </trans-unit>
        <trans-unit id="6954e21ca9dfaa3f0526fc31dd9bb1ea892618cf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'!'&lt;/code&gt; unsubscription point: shows the point in time at which a subscription is unsubscribed.</source>
          <target state="translated">&lt;code&gt;'!'&lt;/code&gt; 取消订阅点：显示取消订阅的时间点。</target>
        </trans-unit>
        <trans-unit id="494cfb16dcf327f243341a9829050b41fdaaafa7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'#'&lt;/code&gt; error: An error terminating the observable. This is the observable producer signaling &lt;code&gt;error()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;'#'&lt;/code&gt; 错误：终止可观察结果的错误。这是可观察到的生产者信令 &lt;code&gt;error()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="900db5e390475e30c0b02294da8a016b0ba83ca6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'()'&lt;/code&gt; sync groupings: When multiple events need to be in the same frame synchronously, parentheses are used to group those events. You can group next'd values, a completion, or an error in this manner. The position of the initial &lt;code&gt;(&lt;/code&gt; determines the time at which its values are emitted. While it can be unintuitive at first, after all the values have synchronously emitted time will progress a number of frames equal to the number of ASCII characters in the group, including the parentheses. e.g. &lt;code&gt;'(abc)'&lt;/code&gt; will emit the values of a, b, and c synchronously in the same frame and then advance virtual time by 5 frames, &lt;code&gt;'(abc)'.length === 5&lt;/code&gt;. This is done because it often helps you vertically align your marble diagrams, but it's a known pain point in real-world testing. &lt;a href=&quot;marble-testing#known-issues&quot;&gt;Learn more about known issues&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;'()'&lt;/code&gt; 同步分组：当多个事件需要同步在同一帧中时，使用括号将这些事件分组。您可以通过这种方式将下一个值，完成或错误分组。初始位置 &lt;code&gt;(&lt;/code&gt; 决定了其值发出的时间。起初它并不直观，但是在所有值同步发出之后，时间将经过的帧数等于该组中ASCII字符的数量，包括括号，例如 &lt;code&gt;'(abc)'&lt;/code&gt; 将在同一帧中同步发出a，b和c的值，然后将虚拟时间提前5帧 &lt;code&gt;'(abc)'.length === 5&lt;/code&gt; 。这样做是因为它通常可以帮助您垂直对齐大理石图，但这是实际测试中的已知痛点。&lt;a href=&quot;marble-testing#known-issues&quot;&gt;了解有关已知问题的更多信息&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dd0ed6d06b7c0c50d7f1ded02adc8d9c93dc954e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'-'&lt;/code&gt; frame: 1 &quot;frame&quot; of virtual time passing (see above description of frames).</source>
          <target state="translated">&lt;code&gt;'-'&lt;/code&gt; 帧：虚拟时间传递的1个&amp;ldquo;帧&amp;rdquo;（请参见帧的上述说明）。</target>
        </trans-unit>
        <trans-unit id="cd2274308e133d94aab4086c64348e0b9367d78f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'-'&lt;/code&gt; or &lt;code&gt;'------'&lt;/code&gt;: Equivalent to &lt;code&gt;Observable.never()&lt;/code&gt;, or an observable that never emits or completes</source>
          <target state="translated">&lt;code&gt;'-'&lt;/code&gt; 或 &lt;code&gt;'------'&lt;/code&gt; ：等效于 &lt;code&gt;Observable.never()&lt;/code&gt; ，或从不发出或完成的Observable</target>
        </trans-unit>
        <trans-unit id="b9ddd2753c7382111307878ff965226a99935b81" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'-'&lt;/code&gt; or &lt;code&gt;'------'&lt;/code&gt;: Equivalent to &lt;code&gt;never()&lt;/code&gt;, or an observable that never emits or completes</source>
          <target state="translated">&lt;code&gt;'-'&lt;/code&gt; 或 &lt;code&gt;'------'&lt;/code&gt; ：等效于 &lt;code&gt;never()&lt;/code&gt; ，或者是从不发出或完成的可观察对象</target>
        </trans-unit>
        <trans-unit id="e85ff3d8ea96e01ddc94347b9770c2baafc5a3f3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'-'&lt;/code&gt; or &lt;code&gt;'------'&lt;/code&gt;: no subscription ever happened.</source>
          <target state="translated">&lt;code&gt;'-'&lt;/code&gt; 或 &lt;code&gt;'------'&lt;/code&gt; ：从未发生过订阅。</target>
        </trans-unit>
        <trans-unit id="b2deb15be9de4e952591a988c11249d643af1ab1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'-'&lt;/code&gt; time: 1 frame time passing.</source>
          <target state="translated">&lt;code&gt;'-'&lt;/code&gt; 时间：经过1帧时间。</target>
        </trans-unit>
        <trans-unit id="90551104ab363bce845a980f30cb723fbc3d84ab" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'--(abc)-|'&lt;/code&gt;: on frame 2 emit &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, and &lt;code&gt;c&lt;/code&gt;, then on frame 8 &lt;code&gt;complete&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;'--(abc)-|'&lt;/code&gt; ：在第2帧发出 &lt;code&gt;a&lt;/code&gt; ， &lt;code&gt;b&lt;/code&gt; 和 &lt;code&gt;c&lt;/code&gt; ，然后在第8帧 &lt;code&gt;complete&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0a66914cc904a1616e408742fcf744c2669d43dc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'--(abc)-|'&lt;/code&gt;: on frame 20, emit &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, and &lt;code&gt;c&lt;/code&gt;, then on frame 80 &lt;code&gt;complete&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;'--(abc)-|'&lt;/code&gt; ：在第20帧上，发射 &lt;code&gt;a&lt;/code&gt; ， &lt;code&gt;b&lt;/code&gt; 和 &lt;code&gt;c&lt;/code&gt; ，然后在第80帧上 &lt;code&gt;complete&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7fe548a294627e814b17d903dab9561a209e6a12" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'-----(a|)'&lt;/code&gt;: on frame 5 emit &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;complete&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;'-----(a|)'&lt;/code&gt; ：在第5帧上发出 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;complete&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4fa0191fc2dbbdc24db47e31a6c21c2c4d99e31c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'-----(a|)'&lt;/code&gt;: on frame 50, emit &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;complete&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;'-----(a|)'&lt;/code&gt; ：在第50帧上，发出 &lt;code&gt;a&lt;/code&gt; 并 &lt;code&gt;complete&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="857d299688e4bc90586f9054240d4d4f9908447e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'--^--!-'&lt;/code&gt;: on frame 2 a subscription happened, and on frame 5 was unsubscribed.</source>
          <target state="translated">&lt;code&gt;'--^--!-'&lt;/code&gt; ：在第2帧发生了订阅，而在第5帧未订阅。</target>
        </trans-unit>
        <trans-unit id="f7eb2910a933490ae2e8679f6e15b0ea2a86e24c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'--^--!-'&lt;/code&gt;: on frame 20 a subscription happened, and on frame 50 was unsubscribed.</source>
          <target state="translated">&lt;code&gt;'--^--!-'&lt;/code&gt; ：在第20帧发生了订阅，而在第50帧未订阅。</target>
        </trans-unit>
        <trans-unit id="0006636d06083015f66b5db0ac8912f9ce320737" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'--^--'&lt;/code&gt;: a subscription happened after 2 &quot;frames&quot; of time passed, and the subscription was not unsubscribed.</source>
          <target state="translated">&lt;code&gt;'--^--'&lt;/code&gt; ：订阅在经过2个&amp;ldquo;帧&amp;rdquo;的时间后发生，并且该订阅并未取消订阅。</target>
        </trans-unit>
        <trans-unit id="1f35221f2edb5714d1b0dc2c10a61f6aa4d5ec78" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'--^--'&lt;/code&gt;: a subscription happened after 20 &quot;frames&quot; of time passed, and the subscription was not unsubscribed.</source>
          <target state="translated">&lt;code&gt;'--^--'&lt;/code&gt; ：订阅发生在20个&amp;ldquo;帧&amp;rdquo;的时间之后，并且该订阅并未取消订阅。</target>
        </trans-unit>
        <trans-unit id="5dc8c6bec3861c166b48135c76387c8aae72940a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'--a 2.5m b'&lt;/code&gt;: on frame 2 emit &lt;code&gt;a&lt;/code&gt;, on frame 150,003 emit &lt;code&gt;b&lt;/code&gt; and never complete.</source>
          <target state="translated">&lt;code&gt;'--a 2.5m b'&lt;/code&gt; ：在第2帧上发出 &lt;code&gt;a&lt;/code&gt; ，在第150,003帧上发出 &lt;code&gt;b&lt;/code&gt; ,并且永远不会完成。</target>
        </trans-unit>
        <trans-unit id="c518d60968c44900d3105e92d3ff56cbce420fb8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'--a--'&lt;/code&gt;: An observable that waits 2 &quot;frames&quot;, emits value &lt;code&gt;a&lt;/code&gt; and then never completes.</source>
          <target state="translated">&lt;code&gt;'--a--'&lt;/code&gt; ：一个等待2个&amp;ldquo;帧&amp;rdquo;的可观察对象，发出值 &lt;code&gt;a&lt;/code&gt; ，然后永不完成。</target>
        </trans-unit>
        <trans-unit id="e9a8a6bc5f8b8dc21df4a25f847e34ac915bf0ae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'--a--'&lt;/code&gt;: An observable that waits 20 &quot;frames&quot;, emits value &lt;code&gt;a&lt;/code&gt; and then never completes.</source>
          <target state="translated">&lt;code&gt;'--a--'&lt;/code&gt; ：一个等待20个&amp;ldquo;帧&amp;rdquo;的可观察对象，发出值 &lt;code&gt;a&lt;/code&gt; ，然后永不完成。</target>
        </trans-unit>
        <trans-unit id="558dc22b4c13f724e11da08b71a45c7a874aadbb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'--a--b--#'&lt;/code&gt;: On frame 2 emit &lt;code&gt;a&lt;/code&gt;, on frame 5 emit &lt;code&gt;b&lt;/code&gt;, and on frame 8, &lt;code&gt;error&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;'--a--b--#'&lt;/code&gt; ：在第2帧发出 &lt;code&gt;a&lt;/code&gt; ，在第5帧发出 &lt;code&gt;b&lt;/code&gt; ，在第8 帧发出 &lt;code&gt;error&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f66a0e5bb742deb080922072f07969bf8f5073f7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'--a--b--#'&lt;/code&gt;: On frame 20 emit &lt;code&gt;a&lt;/code&gt;, on frame 50 emit &lt;code&gt;b&lt;/code&gt;, and on frame 80, &lt;code&gt;error&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;'--a--b--#'&lt;/code&gt; ：在第20帧上发出 &lt;code&gt;a&lt;/code&gt; ，在第50帧上发出 &lt;code&gt;b&lt;/code&gt; ，在第80 帧上发出 &lt;code&gt;error&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e1fbec99faa34f8d8c6178c17bdba6a6c88e1bc7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'--a--b--|'&lt;/code&gt;: On frame 2 emit &lt;code&gt;a&lt;/code&gt;, on frame 5 emit &lt;code&gt;b&lt;/code&gt;, and on frame 8, &lt;code&gt;complete&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;'--a--b--|'&lt;/code&gt; ：在第2帧发出 &lt;code&gt;a&lt;/code&gt; ，在第5帧发出 &lt;code&gt;b&lt;/code&gt; ，在第8帧 &lt;code&gt;complete&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="011793c2617b3542600d252674d69a846c293e1d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'--a--b--|'&lt;/code&gt;: On frame 20 emit &lt;code&gt;a&lt;/code&gt;, on frame 50 emit &lt;code&gt;b&lt;/code&gt;, and on frame 80, &lt;code&gt;complete&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;'--a--b--|'&lt;/code&gt; ：在第20帧上发出 &lt;code&gt;a&lt;/code&gt; ，在第50帧上发出 &lt;code&gt;b&lt;/code&gt; ，在第80帧上 &lt;code&gt;complete&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d571db83420af98e9c5810ad493278bf7ed45756" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'-a-^-b--|'&lt;/code&gt;: In a hot observable, on frame -2 emit &lt;code&gt;a&lt;/code&gt;, then on frame 2 emit &lt;code&gt;b&lt;/code&gt;, and on frame 5, &lt;code&gt;complete&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;'-a-^-b--|'&lt;/code&gt; ：在热观测下，在-2帧上发射 &lt;code&gt;a&lt;/code&gt; ，然后在第2帧上发射 &lt;code&gt;b&lt;/code&gt; ，在第5帧上 &lt;code&gt;complete&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3c4be0daed0fe6a5f4a6444309f2485c8d7052a8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'-a-^-b--|'&lt;/code&gt;: In a hot observable, on frame -20 emit &lt;code&gt;a&lt;/code&gt;, then on frame 20 emit &lt;code&gt;b&lt;/code&gt;, and on frame 50, &lt;code&gt;complete&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;'-a-^-b--|'&lt;/code&gt; ：在热观测中，在-20帧上发射 &lt;code&gt;a&lt;/code&gt; ，然后在20帧上发射 &lt;code&gt;b&lt;/code&gt; ，在50帧上 &lt;code&gt;complete&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e08758a3a46525c399cbbae215e45c0d5e4f18d1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'500ms ^ 1s !'&lt;/code&gt;: on frame 500 a subscription happened, and on frame 1,501 was unsubscribed.</source>
          <target state="translated">&lt;code&gt;'500ms ^ 1s !'&lt;/code&gt; ：在第500帧发生了订阅，而在第1,501帧未订阅。</target>
        </trans-unit>
        <trans-unit id="3645e6c2789e746235dbb1a683c78f91316c0ff1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'^'&lt;/code&gt; subscription point: (hot observables only) shows the point at which the tested observables will be subscribed to the hot observable. This is the &quot;zero frame&quot; for that observable, every frame before the &lt;code&gt;^&lt;/code&gt; will be negative. Negative time might seem pointless, but there are in fact advanced cases where this is necessary, usually involving ReplaySubjects.</source>
          <target state="translated">&lt;code&gt;'^'&lt;/code&gt; 订阅点：（仅热观测值）显示测试的可观测物将被订阅到该热观测值的点。这是可观察到的&amp;ldquo;零帧&amp;rdquo;， &lt;code&gt;^&lt;/code&gt; 之前的每个帧都是负数。消极的时间似乎毫无意义，但实际上在某些高级情况下有必要这样做，通常涉及ReplaySubjects。</target>
        </trans-unit>
        <trans-unit id="e08ffcab1613e5d26675b9934c425ca2aeaeb774" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'^'&lt;/code&gt; subscription point: shows the point in time at which a subscription happen.</source>
          <target state="translated">&lt;code&gt;'^'&lt;/code&gt; 订阅点：显示订阅发生的时间点。</target>
        </trans-unit>
        <trans-unit id="c9eec6341670ec1c6b1e9b19d18fdf631feeedf6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'a 9ms b 9s c|'&lt;/code&gt;: on frame 0 emit &lt;code&gt;a&lt;/code&gt;, on frame 10 emit &lt;code&gt;b&lt;/code&gt;, on frame 10,012 emit &lt;code&gt;c&lt;/code&gt;, then on on frame 10,013 &lt;code&gt;complete&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;'a 9ms b 9s c|'&lt;/code&gt; ：在框架0上发出 &lt;code&gt;a&lt;/code&gt; ，在框架10上发出 &lt;code&gt;b&lt;/code&gt; ，在框架10,012上发出 &lt;code&gt;c&lt;/code&gt; ，然后在框架10,013上 &lt;code&gt;complete&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="52c23705b515df4c100f707c5889b869f7738d66" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'|'&lt;/code&gt; complete: The successful completion of an observable. This is the observable producer signaling &lt;code&gt;complete()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;'|'&lt;/code&gt; complete：成功完成一个可观察的对象。这是可观察到的生产者发出的信号 &lt;code&gt;complete()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8ed8289c6915557851ae2fc185944335fcceab94" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(...args: any[]) =&amp;gt; Observable&amp;lt;T&amp;gt;&lt;/code&gt;: A function which returns the Observable that delivers the same values the Node.js callback would deliver.</source>
          <target state="translated">&lt;code&gt;(...args: any[]) =&amp;gt; Observable&amp;lt;T&amp;gt;&lt;/code&gt; ：返回Observable的函数，该函数传递与Node.js回调传递的值相同的值。</target>
        </trans-unit>
        <trans-unit id="9af6c1ceaf17b75b780332cfb3ea76a28e668fd8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(...args: any[]) =&amp;gt; Observable&amp;lt;T&amp;gt;&lt;/code&gt;: A function which returns the Observable that delivers the same values the callback would deliver.</source>
          <target state="translated">&lt;code&gt;(...args: any[]) =&amp;gt; Observable&amp;lt;T&amp;gt;&lt;/code&gt; ：返回Observable的函数，该函数提供与回调传递的值相同的值。</target>
        </trans-unit>
        <trans-unit id="77f4a7aa096d066890cd4560eb8be8512c98b678" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ArgumentOutOfRangeError&lt;/code&gt; When using &lt;code&gt;elementAt(i)&lt;/code&gt;, it delivers an ArgumentOutOrRangeError to the Observer's &lt;code&gt;error&lt;/code&gt; callback if &lt;code&gt;i &amp;lt; 0&lt;/code&gt; or the Observable has completed before emitting the i-th &lt;code&gt;next&lt;/code&gt; notification.</source>
          <target state="translated">&lt;code&gt;ArgumentOutOfRangeError&lt;/code&gt; 使用 &lt;code&gt;elementAt(i)&lt;/code&gt; 时，如果 &lt;code&gt;i &amp;lt; 0&lt;/code&gt; 或Observable在发出第i个 &lt;code&gt;next&lt;/code&gt; 通知之前完成，则它将ArgumentOutOrRangeError传递给Observer的 &lt;code&gt;error&lt;/code&gt; 回调。</target>
        </trans-unit>
        <trans-unit id="440326ab0df253e9d1a2baf16e42ef22aea1f82d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ArgumentOutOfRangeError&lt;/code&gt; When using &lt;code&gt;skipLast(i)&lt;/code&gt;, it throws ArgumentOutOrRangeError if &lt;code&gt;i &amp;lt; 0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ArgumentOutOfRangeError&lt;/code&gt; 使用 &lt;code&gt;skipLast(i)&lt;/code&gt; 时，如果 &lt;code&gt;i &amp;lt; 0&lt;/code&gt; ，则抛出ArgumentOutOrRangeError 。</target>
        </trans-unit>
        <trans-unit id="ab36e17fb5757f8497903f935e1060283fd57611" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ArgumentOutOfRangeError&lt;/code&gt; When using &lt;code&gt;take(i)&lt;/code&gt;, it delivers an ArgumentOutOrRangeError to the Observer's &lt;code&gt;error&lt;/code&gt; callback if &lt;code&gt;i &amp;lt; 0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ArgumentOutOfRangeError&lt;/code&gt; 使用 &lt;code&gt;take(i)&lt;/code&gt; 时，如果 &lt;code&gt;i &amp;lt; 0&lt;/code&gt; ，它将ArgumentOutOrRangeError传递给观察者的 &lt;code&gt;error&lt;/code&gt; 回调。</target>
        </trans-unit>
        <trans-unit id="640ea84593ebfbf6d363bf5efc85c28283078a3d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ArgumentOutOfRangeError&lt;/code&gt; When using &lt;code&gt;takeLast(i)&lt;/code&gt;, it delivers an ArgumentOutOrRangeError to the Observer's &lt;code&gt;error&lt;/code&gt; callback if &lt;code&gt;i &amp;lt; 0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ArgumentOutOfRangeError&lt;/code&gt; 当使用 &lt;code&gt;takeLast(i)&lt;/code&gt; 时，如果 &lt;code&gt;i &amp;lt; 0&lt;/code&gt; ，它将ArgumentOutOrRangeError传递给观察者的 &lt;code&gt;error&lt;/code&gt; 回调。</target>
        </trans-unit>
        <trans-unit id="31e642c2f3e6b9f25cc4726681ae36498a69e080" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ConnectableObservable&lt;/code&gt; is hidden from direct use in v6 and is accessible only through operators &lt;code&gt;multicast&lt;/code&gt;, &lt;code&gt;publish&lt;/code&gt;, &lt;code&gt;publishReplay&lt;/code&gt;, and &lt;code&gt;publishLast&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ConnectableObservable&lt;/code&gt; 在v6中无法直接使用，并且只能通过操作员 &lt;code&gt;multicast&lt;/code&gt; ， &lt;code&gt;publish&lt;/code&gt; ， &lt;code&gt;publishReplay&lt;/code&gt; 和 &lt;code&gt;publishLast&lt;/code&gt; 进行访问。</target>
        </trans-unit>
        <trans-unit id="25628c7cfe20af88f31a364c509c719222e82f15" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;EmptyError&lt;/code&gt; Delivers an EmptyError to the Observer's &lt;code&gt;error&lt;/code&gt; callback if the Observable completes before any &lt;code&gt;next&lt;/code&gt; notification was sent.</source>
          <target state="translated">&lt;code&gt;EmptyError&lt;/code&gt; 提供了一个EmptyError观察者的 &lt;code&gt;error&lt;/code&gt; 回调，如果任何前可观察的完成 &lt;code&gt;next&lt;/code&gt; 通知被送往。</target>
        </trans-unit>
        <trans-unit id="cf43bc7be5b6a9f4eff2297551b22603dcce7470" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Error&lt;/code&gt; - Throws if no items that match the predicate are emitted by the source Observable.</source>
          <target state="translated">&lt;code&gt;Error&lt;/code&gt; -如果源Observable没有发出与谓词匹配的项，则抛出该错误。</target>
        </trans-unit>
        <trans-unit id="0c038e664cac7e678a7189ea519cc11210358a93" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;If&lt;/code&gt; statement for Observables.</source>
          <target state="translated">&lt;code&gt;If&lt;/code&gt; 为Observables语句。</target>
        </trans-unit>
        <trans-unit id="c8604585789c7f45b430d747e2826b514bd35187" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt; | OperatorFunction&amp;lt;T, R&amp;gt;&lt;/code&gt;: A ConnectableObservable that upon connection causes the source Observable to emit items to its Observers.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt; | OperatorFunction&amp;lt;T, R&amp;gt;&lt;/code&gt; ：一个ConnectableObservable，在连接时会导致源Observable向其Observer发射项目。</target>
        </trans-unit>
        <trans-unit id="0833ea0338f3e9c17cc9ca3e78e5ac2595518c59" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable identical to the source, but runs the specified Observer or callback(s) for each item.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; ：一个与源相同的Observable，但是为每个项目运行指定的Observer或callback。</target>
        </trans-unit>
        <trans-unit id="9a3ff938938e7f92083767cff963ec408bc72281" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable of values from the source that were allowed by the &lt;code&gt;predicate&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; ： &lt;code&gt;predicate&lt;/code&gt; 功能允许的源中值的可观察值。</target>
        </trans-unit>
        <trans-unit id="48b16d89a273649e6300bb81e302e25a4c761d4f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that begins emitting items emitted by the source Observable when the specified predicate becomes false.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; ：一个Observable，当指定的谓词变为false时，它开始发出由源Observable发出的项。</target>
        </trans-unit>
        <trans-unit id="9449ccb1f132a2fe147e056e41b27587341903fc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that delays the emissions of the source Observable by an amount of time specified by the Observable returned by &lt;code&gt;delayDurationSelector&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; ：一个Observable，它将源Observable的发射延迟了 &lt;code&gt;delayDurationSelector&lt;/code&gt; 返回的Observable指定的时间。</target>
        </trans-unit>
        <trans-unit id="38a02d0451e76caad26e6ddc73ce1e225241f99f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that delays the emissions of the source Observable by the specified &lt;code&gt;dueTime&lt;/code&gt;, and may drop some values if they occur too frequently.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; ：一个Observable，它将源Observable的发射延迟指定的 &lt;code&gt;dueTime&lt;/code&gt; ，并且如果它们出现得太频繁，则可能会丢弃某些值。</target>
        </trans-unit>
        <trans-unit id="ed3ec44e2afb8b4f0db7d022d34500a94284cdbc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that delays the emissions of the source Observable by the specified duration Observable returned by &lt;code&gt;durationSelector&lt;/code&gt;, and may drop some values if they occur too frequently.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; ：一个Observable，它将源Observable的发射延迟指定的 &lt;code&gt;durationSelector&lt;/code&gt; ，由durationSelector返回，并且如果它们发生得太频繁，可能会丢弃某些值。</target>
        </trans-unit>
        <trans-unit id="c1abab6fda2770b6bc76976f9a61742680f62d69" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that delays the emissions of the source Observable by the specified timeout or Date.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; ：一个Observable，它将源Observable的发射延迟指定的超时或日期。</target>
        </trans-unit>
        <trans-unit id="e889533f93eed35b01537d0147d0955ccb947ef4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that emits a single item, if it is found. Otherwise, will emit the default value if given. If not, then emits an error.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; ：一个Observable，发出单个项目（如果找到）。否则，将给出默认值。如果不是，则发出错误。</target>
        </trans-unit>
        <trans-unit id="6395d1a685b354afb5235c686fc8add7f341178f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that emits at most the last count values emitted by the source Observable.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; ：一个Observable，最多发出源Observable发出的最后一个计数值。</target>
        </trans-unit>
        <trans-unit id="b5d994a03ce94afe4026fa16bc1a7e336127fa8a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that emits item with the largest value.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; ：一个Observable，发出最大的值。</target>
        </trans-unit>
        <trans-unit id="b9d8c36ee2b5cd4623102825282d7ac16ed85f38" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that emits item with the smallest value.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; ：一个Observable，发出最小的项目。</target>
        </trans-unit>
        <trans-unit id="682f9f17153985c8d9995ecf01c83b22afc2f6ea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that emits items from the source Observable with distinct values based on the key specified.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; ：一个Observable，它根据指定的键从源Observable发射具有不同值的项目。</target>
        </trans-unit>
        <trans-unit id="3d6800c9e0f9ae6a14fbb6b44f0d6875055a3d0d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that emits items from the source Observable with distinct values.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; ：一个Observable，它从源Observable发射具有不同值的项。</target>
        </trans-unit>
        <trans-unit id="a5ae53fe7fc4ee976638967a24f49e925818d67f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that emits only the first &lt;code&gt;count&lt;/code&gt; values emitted by the source Observable, or all of the values from the source if the source emits fewer than &lt;code&gt;count&lt;/code&gt; values.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; ：一个Observable，仅发出源Observable 发出的第一个 &lt;code&gt;count&lt;/code&gt; 数值，或者如果源发出的 &lt;code&gt;count&lt;/code&gt; 数值少于计数值，则从源发出的所有值。</target>
        </trans-unit>
        <trans-unit id="b4a8c6ed88fd287a7fb8db2c7007184096326e4a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that emits the items emitted by the source Observable and then emits the items in the specified Iterable.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; ：一个Observable，它发出源Observable发出的项，然后发出指定的Iterable中的项。</target>
        </trans-unit>
        <trans-unit id="9c81ca47826ed80fc19d479ca6fdffc6d56f6a6d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that emits the results of sampling the values emitted by the source Observable at the specified time interval.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; ：一个Observable，它以指定的时间间隔发出对源Observable发射的值进行采样的结果。</target>
        </trans-unit>
        <trans-unit id="7cd751b89528c1671e4f80823e7b81bacc8aeec1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that emits the results of sampling the values emitted by the source Observable whenever the notifier Observable emits value or completes.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; ：一个Observable，当通知者Observable发出值或完成时，发出对源Observable发出的值进行采样的结果。</target>
        </trans-unit>
        <trans-unit id="a1a0b870de4e6611a1c770dfd589fb1187f9deae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that emits the single item emitted by the source Observable that matches the predicate or &lt;code&gt;undefined&lt;/code&gt; when no items match.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; ：一个Observable，它发射源Observable发出的与谓词匹配的单个项，或者在没有项匹配时 &lt;code&gt;undefined&lt;/code&gt; 项。</target>
        </trans-unit>
        <trans-unit id="d8e0addfb5015dbaa3535820ab93808a87b6e9c2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that emits the values from the source Observable so long as each value satisfies the condition defined by the &lt;code&gt;predicate&lt;/code&gt;, then completes.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; ：一个Observable，它从源Observable发出值，只要每个值都满足 &lt;code&gt;predicate&lt;/code&gt; 定义的条件，然后完成。</target>
        </trans-unit>
        <trans-unit id="e6261ccdbc462844fef242c6c04ab7ff1aa60d18" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that emits the values from the source Observable until such time as &lt;code&gt;notifier&lt;/code&gt; emits its first value.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; ：一个Observable，它从源Observable发出值，直到 &lt;code&gt;notifier&lt;/code&gt; 发出其第一个值为止。</target>
        </trans-unit>
        <trans-unit id="3c308d842f2d0d1867ca783e8dc73eaa380e9c04" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that mirrors the output of the first Observable to emit an item.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; ：一个Observable，它镜像第一个Observable的输出以发出一个项目。</target>
        </trans-unit>
        <trans-unit id="c1f86da4ab0846a743a7251a13b70c94c877b6f0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that mirrors the source, but will call the specified function on termination.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; ：一个可观察源的镜像，但将在终止时调用指定的函数。</target>
        </trans-unit>
        <trans-unit id="7e4710248cea691104373b5664ba6d261d7d8dc5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that performs rate-limiting of emissions from the source Observable.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; ：一个Observable，对来自源Observable的发射执行速率限制。</target>
        </trans-unit>
        <trans-unit id="946c0b65142202dabd849b9b61c4283b9dd08baf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that performs the throttle operation to limit the rate of emissions from the source.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; ：一个Observable，执行油门操作以限制来自源的排放率。</target>
        </trans-unit>
        <trans-unit id="602e1b382729f2ce251c1b92b443bbd937af3340" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that skips items from the source Observable until the second Observable emits an item, then emits the remaining items.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; ：一个Observable，它从源Observable跳过项目，直到第二个Observable发射一个项目，然后发射其余项目。</target>
        </trans-unit>
        <trans-unit id="1ef7f4cf892977bb212561f1a77acf132b290686" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that skips the last count values emitted by the source Observable.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; ：一个Observable，它跳过源Observable发出的最后一个计数值。</target>
        </trans-unit>
        <trans-unit id="d557c423d0245ce169be446a043cb268e1ca5ec5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that skips values emitted by the source Observable.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; ：一个Observable，它跳过源Observable发出的值。</target>
        </trans-unit>
        <trans-unit id="4cfa061328f40141206293f33fa4e67d138bc66a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that upon connection causes the source Observable to emit items to its Observers.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; ：一个Observable，在连接时会导致源Observable向其Observer发射项目。</target>
        </trans-unit>
        <trans-unit id="9c6d52f8ed9f46e4195b54356a66ccf875933728" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that will resubscribe to the source stream when the source stream completes , at most count times.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; ：一个Observable，它将在源流完成时最多计数一次重新订阅源流。</target>
        </trans-unit>
        <trans-unit id="0f22925542ce9ba6590bea06ee00f05160b4c25e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: Observable that emits the same notifications as the source Observable, but with provided scheduler.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; ：Observable发出与源Observable相同的通知，但具有提供的调度程序。</target>
        </trans-unit>
        <trans-unit id="58a671188d09f4f66f5a13afcd8af3a07fbd548d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: Observable that mirrors behaviour of source, unless timeout checks fail.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; ：可观察到的镜像源行为，除非超时检查失败。</target>
        </trans-unit>
        <trans-unit id="c6bf69d4f9d0ab23a12db778ab90b11d481273cb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: The source Observable modified so that its subscriptions happen on the specified &lt;a href=&quot;../index/interface/schedulerlike&quot;&gt;&lt;code&gt;SchedulerLike&lt;/code&gt;&lt;/a&gt;. .</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; ：修改了源Observable，以便其订阅发生在指定的&lt;a href=&quot;../index/interface/schedulerlike&quot;&gt; &lt;code&gt;SchedulerLike&lt;/code&gt; 上&lt;/a&gt;。。</target>
        </trans-unit>
        <trans-unit id="98eaeae8156b0d69ae687593c863bfb00f1b8b0d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: The source Observable modified with repeat logic.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; ：使用重复逻辑修改的源Observable。</target>
        </trans-unit>
        <trans-unit id="32b9e6769395cbfd746c2fd896e1edba7235d3c1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: The source Observable modified with retry logic.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; ：使用重试逻辑修改的源Observable。</target>
        </trans-unit>
        <trans-unit id="a06d6f1678091badb1098fdfbba9250008ad6ef3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: The source Observable modified with the retry logic.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; ：使用重试逻辑修改的源Observable。</target>
        </trans-unit>
        <trans-unit id="8763fb5889ab433a69024fe4938e084fc22037c8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Notification&amp;lt;T&amp;gt;&lt;/code&gt;: The &quot;error&quot; Notification representing the argument.</source>
          <target state="translated">&lt;code&gt;Notification&amp;lt;T&amp;gt;&lt;/code&gt; ：表示参数的&amp;ldquo;错误&amp;rdquo;通知。</target>
        </trans-unit>
        <trans-unit id="ef879440b9acd7b903b77c7ea86c552b00e297d3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Notification&amp;lt;T&amp;gt;&lt;/code&gt;: The &quot;next&quot; Notification representing the argument.</source>
          <target state="translated">&lt;code&gt;Notification&amp;lt;T&amp;gt;&lt;/code&gt; ：表示参数的&amp;ldquo;下一个&amp;rdquo;通知。</target>
        </trans-unit>
        <trans-unit id="38d464bb5af13abcb15464548a27988c4fe87d46" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Notification&amp;lt;any&amp;gt;&lt;/code&gt;: The valueless &quot;complete&quot; Notification.</source>
          <target state="translated">&lt;code&gt;Notification&amp;lt;any&amp;gt;&lt;/code&gt; ：无价值的&amp;ldquo;完整&amp;rdquo;通知。</target>
        </trans-unit>
        <trans-unit id="ee120528c9ab1715102554c9aa15756201b1fb7f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Observable&amp;lt;ObservedValueOf&amp;lt;O&amp;gt; | R&amp;gt;&lt;/code&gt;: All values of each passed Observable merged into a single Observable, in order, in serial fashion.</source>
          <target state="translated">&lt;code&gt;Observable&amp;lt;ObservedValueOf&amp;lt;O&amp;gt; | R&amp;gt;&lt;/code&gt; ：每个传递的Observable的所有值都以串行方式依次合并为一个Observable。</target>
        </trans-unit>
        <trans-unit id="bd0e1703773d09072a2fc9c6abfbab19b7184e3d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Observable&amp;lt;ObservedValueOf&amp;lt;O&amp;gt;[] | R&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;Observable&amp;lt;ObservedValueOf&amp;lt;O&amp;gt;[] | R&amp;gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="9fd71541e5d46e89663978e9c179e73d33d7f460" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Observable&amp;lt;ObservedValueOf&amp;lt;R&amp;gt;&amp;gt;&lt;/code&gt;: An Observable whose Observers' subscriptions trigger an invocation of the given Observable factory function.</source>
          <target state="translated">&lt;code&gt;Observable&amp;lt;ObservedValueOf&amp;lt;R&amp;gt;&amp;gt;&lt;/code&gt; ：一个Observable，其Observer的订阅触发对给定Observable工厂函数的调用。</target>
        </trans-unit>
        <trans-unit id="72ea18b738f13176716cd3530244cf48151fd843" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Observable&amp;lt;R&amp;gt;&lt;/code&gt;: An Observable of projected values from the most recent values from each input Observable, or an array of the most recent values from each input Observable.</source>
          <target state="translated">&lt;code&gt;Observable&amp;lt;R&amp;gt;&lt;/code&gt; ：来自每个输入Observable的最新值的投影值的Observable，或来自每个输入Observable的最新值的数组。</target>
        </trans-unit>
        <trans-unit id="669000de8f64c0f068e1e8d2b995d5ae4e1cd7e1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Observable&amp;lt;R&amp;gt;&lt;/code&gt;: An Observable that concatenates all sources, one after the other, ignoring all errors, such that any error causes it to move on to the next source.</source>
          <target state="translated">&lt;code&gt;Observable&amp;lt;R&amp;gt;&lt;/code&gt; ：一个可观察的对象，一个接一个地连接所有源，忽略所有错误，以便任何错误都会导致它继续移动到下一个源。</target>
        </trans-unit>
        <trans-unit id="5dd2c89285ed413ee73cb8ed373783a71556739e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Observable&amp;lt;R&amp;gt;&lt;/code&gt;: a new observable with the Operator applied</source>
          <target state="translated">&lt;code&gt;Observable&amp;lt;R&amp;gt;&lt;/code&gt; ：应用了运算符的新Observable</target>
        </trans-unit>
        <trans-unit id="546d4d5a898b2514cd733c7691edcbe22e343808" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Observable&amp;lt;R&amp;gt;&lt;/code&gt;: an Observable that emits items that are the result of every input Observable.</source>
          <target state="translated">&lt;code&gt;Observable&amp;lt;R&amp;gt;&lt;/code&gt; ：一个Observable，它发出作为每个输入Observable的结果的项。</target>
        </trans-unit>
        <trans-unit id="f246ffeb696ea044aea059a6547ab60ed97903e1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Observable&amp;lt;Response&amp;gt;&lt;/code&gt;: An Observable, that when subscribed to performs an HTTP request using the native &lt;code&gt;fetch&lt;/code&gt; function. The &lt;a href=&quot;../index/class/subscription&quot;&gt;&lt;code&gt;Subscription&lt;/code&gt;&lt;/a&gt; is tied to an &lt;code&gt;AbortController&lt;/code&gt; for the the fetch.</source>
          <target state="translated">&lt;code&gt;Observable&amp;lt;Response&amp;gt;&lt;/code&gt; ：一个Observable，在订阅时使用本机 &lt;code&gt;fetch&lt;/code&gt; 功能执行HTTP请求。该&lt;a href=&quot;../index/class/subscription&quot;&gt; &lt;code&gt;Subscription&lt;/code&gt; &lt;/a&gt;被绑定到 &lt;code&gt;AbortController&lt;/code&gt; 的抓取。</target>
        </trans-unit>
        <trans-unit id="12df656ce83de0d952270b74d9d36115ce231f71" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Observable&amp;lt;S&amp;gt;&lt;/code&gt;: The generated sequence.</source>
          <target state="translated">&lt;code&gt;Observable&amp;lt;S&amp;gt;&lt;/code&gt; ：生成的序列。</target>
        </trans-unit>
        <trans-unit id="1b8df8881cd223a6d99f276649bb495aa498b2e9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Observable&amp;lt;T | F&amp;gt;&lt;/code&gt;: Either first or second Observable, depending on condition.</source>
          <target state="translated">&lt;code&gt;Observable&amp;lt;T | F&amp;gt;&lt;/code&gt; ：根据情况，第一个或第二个可观察。</target>
        </trans-unit>
        <trans-unit id="09e76145a70f20853eb46f82588e140da99d594f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Observable&amp;lt;T | T[]&amp;gt;&lt;/code&gt;: Observable which, when an event happens, emits first parameter passed to registered event handler. Alternatively it emits whatever project function returns at that moment.</source>
          <target state="translated">&lt;code&gt;Observable&amp;lt;T | T[]&amp;gt;&lt;/code&gt; ：可观察的，当事件发生时，它发出传递给已注册事件处理程序的第一个参数。或者，它发出此时返回的任何项目函数。</target>
        </trans-unit>
        <trans-unit id="d7584ca661dd77ce664d3ff61f1e49b4909d87c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Observable&amp;lt;T&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;Observable&amp;lt;T&amp;gt;&lt;/code&gt;:</target>
        </trans-unit>
        <trans-unit id="1b80f12276d3a40a5fa937076c33adccf9646b17" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Observable&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that behaves the same as Observable returned by &lt;code&gt;observableFactory&lt;/code&gt;, but which - when completed, errored or unsubscribed - will also call &lt;code&gt;unsubscribe&lt;/code&gt; on created resource object.</source>
          <target state="translated">&lt;code&gt;Observable&amp;lt;T&amp;gt;&lt;/code&gt; ：一个Observable，其行为与 &lt;code&gt;observableFactory&lt;/code&gt; 返回的Observable相同，但是一旦完成，出错或取消订阅，该Observable 还将在创建的资源对象上调用 &lt;code&gt;unsubscribe&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8d9f59154e679519172ccff523d963b577c7ba52" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Observable&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that emits the arguments described above and then completes.</source>
          <target state="translated">&lt;code&gt;Observable&amp;lt;T&amp;gt;&lt;/code&gt; ：一个Observable，它发出上述参数，然后完成。</target>
        </trans-unit>
        <trans-unit id="5a17efa17d3475364890f0d3f49f8f8c5cd4a4d5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Observable&amp;lt;T&amp;gt;&lt;/code&gt;: Observable that the Subject casts to</source>
          <target state="translated">&lt;code&gt;Observable&amp;lt;T&amp;gt;&lt;/code&gt; ：对象转换为可观察到的</target>
        </trans-unit>
        <trans-unit id="a80ce4eeb36f3e609ba0293318360af2884d5e92" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Observable&amp;lt;T&amp;gt;&lt;/code&gt;: The generated sequence.</source>
          <target state="translated">&lt;code&gt;Observable&amp;lt;T&amp;gt;&lt;/code&gt; ：生成的序列。</target>
        </trans-unit>
        <trans-unit id="625771d790fd38d43439cefc89d792200861d6c4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Observable&amp;lt;T&amp;gt;&lt;/code&gt;: an Observable that mirrors the output of the first Observable to emit an item.</source>
          <target state="translated">&lt;code&gt;Observable&amp;lt;T&amp;gt;&lt;/code&gt; ：一个Observable，它镜像第一个Observable的输出以发出一个项目。</target>
        </trans-unit>
        <trans-unit id="3c402a0e4b6a9e65ebc0e3c78845b844e7e841a5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Observable&amp;lt;any&amp;gt;&lt;/code&gt;: Observable emitting either an array of last values emitted by passed Observables or value from project function.</source>
          <target state="translated">&lt;code&gt;Observable&amp;lt;any&amp;gt;&lt;/code&gt; ：Observable &amp;lt;any&amp;gt;，它发出由传递的Observable发出的最后一个值的数组或项目函数的值。</target>
        </trans-unit>
        <trans-unit id="d644633ca879cf0518e4252c5291db0c1473f62e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Observable&amp;lt;never&amp;gt;&lt;/code&gt;: An error Observable: emits only the error notification using the given error argument.</source>
          <target state="translated">&lt;code&gt;Observable&amp;lt;never&amp;gt;&lt;/code&gt; ：错误Observable：使用给定的error参数仅发出错误通知。</target>
        </trans-unit>
        <trans-unit id="4fd37309412eebab1af8b444e3494ff46307ad58" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Observable&amp;lt;number&amp;gt;&lt;/code&gt;: An Observable of numbers that emits a finite range of sequential integers.</source>
          <target state="translated">&lt;code&gt;Observable&amp;lt;number&amp;gt;&lt;/code&gt; ：一个数字的Observable，它发出有限范围的连续整数。</target>
        </trans-unit>
        <trans-unit id="5bafa5caf9714920c7d9794783daad8cb6cfe408" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Observable&amp;lt;number&amp;gt;&lt;/code&gt;: An Observable that emits a &lt;code&gt;0&lt;/code&gt; after the &lt;code&gt;dueTime&lt;/code&gt; and ever increasing numbers after each &lt;code&gt;period&lt;/code&gt; of time thereafter.</source>
          <target state="translated">&lt;code&gt;Observable&amp;lt;number&amp;gt;&lt;/code&gt; ：一个Observable，在 &lt;code&gt;dueTime&lt;/code&gt; 之后发出 &lt;code&gt;0&lt;/code&gt; ，此后在每个 &lt;code&gt;period&lt;/code&gt; 段之后不断增加的数字。</target>
        </trans-unit>
        <trans-unit id="18ef7a2d7b03b517f7cba00b53dce721410629dd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Observable&amp;lt;number&amp;gt;&lt;/code&gt;: An Observable that emits a sequential number each time interval.</source>
          <target state="translated">&lt;code&gt;Observable&amp;lt;number&amp;gt;&lt;/code&gt; ：一个Observable，它在每个时间间隔发出一个序列号。</target>
        </trans-unit>
        <trans-unit id="9c60d02600031a7c4e4077aaed375e92e7ce4c66" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Observable.if&lt;/code&gt; and &lt;code&gt;Observable.throw&lt;/code&gt; These methods have been replaced by the static &lt;code&gt;iif()&lt;/code&gt; and &lt;code&gt;throwError()&lt;/code&gt; functions. Use &lt;a href=&quot;https://github.com/reactivex/rxjs-tslint&quot;&gt;rxjs-tslint&lt;/a&gt; to convert method calls with function calls.</source>
          <target state="translated">&lt;code&gt;Observable.if&lt;/code&gt; 和 &lt;code&gt;Observable.throw&lt;/code&gt; 这些方法已由静态 &lt;code&gt;iif()&lt;/code&gt; 和 &lt;code&gt;throwError()&lt;/code&gt; 函数代替。使用&lt;a href=&quot;https://github.com/reactivex/rxjs-tslint&quot;&gt;rxjs-tslint&lt;/a&gt;将方法调用与函数调用转换。</target>
        </trans-unit>
        <trans-unit id="e8dd422c34dd6670e5820789a3935b0f8a163b30" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;Notification&amp;lt;T&amp;gt;, T&amp;gt;&lt;/code&gt;: An Observable that emits items and notifications embedded in Notification objects emitted by the source Observable.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;Notification&amp;lt;T&amp;gt;, T&amp;gt;&lt;/code&gt; ：一个Observable，它发出嵌入在由源Observable发出的Notification对象中的项目和通知。</target>
        </trans-unit>
        <trans-unit id="b943e1dff560a9b4731381e69c691f9f2663856d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;ObservableInput&amp;lt;T&amp;gt;, T&amp;gt;&lt;/code&gt;: An Observable emitting values from all the inner Observables concatenated.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;ObservableInput&amp;lt;T&amp;gt;, T&amp;gt;&lt;/code&gt; ：所有串联的内部Observable的Observable发射值。</target>
        </trans-unit>
        <trans-unit id="a9fbd53ce8c4ca4704991f6a4e6424efb51a3e50" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;ObservableInput&amp;lt;T&amp;gt;, T&amp;gt;&lt;/code&gt;: An Observable that emits values coming from all the inner Observables emitted by the source Observable.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;ObservableInput&amp;lt;T&amp;gt;, T&amp;gt;&lt;/code&gt; ：一个Observable，它发出的值来自源Observable发出的所有内部Observable。</target>
        </trans-unit>
        <trans-unit id="4e9e5b74e3d4c5968ec5aa65403ccf2f27d4ac10" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, GroupedObservable&amp;lt;K, R&amp;gt;&amp;gt;&lt;/code&gt;: An Observable that emits GroupedObservables, each of which corresponds to a unique key value and each of which emits those items from the source Observable that share that key value.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, GroupedObservable&amp;lt;K, R&amp;gt;&amp;gt;&lt;/code&gt; ：发出GroupedObservable的Observable，每个GroupedObservable对应于一个唯一的键值，并且每一个都从源Observable发出共享该键值的那些项。</target>
        </trans-unit>
        <trans-unit id="a31762e776d77c6f8116c3b05cba4d1b24ca6464" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, I | R&amp;gt;&lt;/code&gt;: An Observable that emits items from the given &lt;code&gt;innerObservable&lt;/code&gt; (and optionally transformed through the deprecated &lt;code&gt;resultSelector&lt;/code&gt;) every time a value is emitted on the source Observable, and taking only the values from the most recently projected inner Observable.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, I | R&amp;gt;&lt;/code&gt; ：一个Observable，它每次在源Observable上发射值时，都从给定的 &lt;code&gt;innerObservable&lt;/code&gt; 发出项目（并可选地通过不推荐使用的 &lt;code&gt;resultSelector&lt;/code&gt; 进行转换），并且仅从最近投影的内部Observable中获取值。</target>
        </trans-unit>
        <trans-unit id="8a4fd670838262d305edf3ffd88f8a75a09e6037" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, Notification&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;: An Observable that emits &lt;a href=&quot;../index/class/notification&quot;&gt;&lt;code&gt;Notification&lt;/code&gt;&lt;/a&gt; objects that wrap the original emissions from the source Observable with metadata.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, Notification&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; ：一个Observable，它发出&lt;a href=&quot;../index/class/notification&quot;&gt; &lt;code&gt;Notification&lt;/code&gt; &lt;/a&gt;对象，该对象包装来自带有Observable元数据的源Observable的原始发射。</target>
        </trans-unit>
        <trans-unit id="25fe863e956990570054cbe8f4a3ae938b4a7a37" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, Observable&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;: An Observable of windows, which are Observables emitting values of the source Observable.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, Observable&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; ：窗口的Observable，是可观察的，发出源Observable值的对象。</target>
        </trans-unit>
        <trans-unit id="0391947d88f4f7f42a95717260c28949831f0f0e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, Observable&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;: An Observable of windows, which in turn are Observable of values.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, Observable&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; ：窗口的Observable，而窗口又是值的Observable。</target>
        </trans-unit>
        <trans-unit id="2f931b53ceabcaf37290a1e173d5261898200497" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, Observable&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;: An observable of windows, which in turn are Observables.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, Observable&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; ：窗口的可观察对象，而窗口又是可观察的对象。</target>
        </trans-unit>
        <trans-unit id="36b665d4b96e8622df44bceaa15c3aef802424b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, ObservedValueOf&amp;lt;O&amp;gt; | R&amp;gt;&lt;/code&gt;: An Observable containing projected Observables of each item of the source, ignoring projected Observables that start before their preceding Observable has completed.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, ObservedValueOf&amp;lt;O&amp;gt; | R&amp;gt;&lt;/code&gt; ：一个Observable，其中包含源中每个项目的预计Observable，而忽略在其先前的Observable完成之前开始的预计Observable。</target>
        </trans-unit>
        <trans-unit id="ae05bfd16d5b0dc9ad579b88debdcb634355a5d6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, ObservedValueOf&amp;lt;O&amp;gt; | R&amp;gt;&lt;/code&gt;: An Observable that emits items from the given &lt;code&gt;innerObservable&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, ObservedValueOf&amp;lt;O&amp;gt; | R&amp;gt;&lt;/code&gt; ：一个Observable，它从给定的 &lt;code&gt;innerObservable&lt;/code&gt; 发出项目</target>
        </trans-unit>
        <trans-unit id="f1114fbae762bbcc842c75a346d50886aba62bd3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, ObservedValueOf&amp;lt;O&amp;gt; | R&amp;gt;&lt;/code&gt;: An Observable that emits the result of applying the projection function (and the optional deprecated &lt;code&gt;resultSelector&lt;/code&gt;) to each item emitted by the source Observable and merging the results of the Observables obtained from this transformation.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, ObservedValueOf&amp;lt;O&amp;gt; | R&amp;gt;&lt;/code&gt; ：一个Observable，其结果是将投影函数（和可选的不推荐使用的 &lt;code&gt;resultSelector&lt;/code&gt; ）应用于源Observable发出的每个项目，并合并从此转换获得的Observable的结果。</target>
        </trans-unit>
        <trans-unit id="4936e9ad8b47feae4057bfc06b74066ba9c2244e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, ObservedValueOf&amp;lt;O&amp;gt; | R&amp;gt;&lt;/code&gt;: An Observable that emits the result of applying the projection function (and the optional deprecated &lt;code&gt;resultSelector&lt;/code&gt;) to each item emitted by the source Observable and taking only the values from the most recently projected inner Observable.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, ObservedValueOf&amp;lt;O&amp;gt; | R&amp;gt;&lt;/code&gt; ：一个Observable，其结果是将投影函数（和可选的不推荐使用的 &lt;code&gt;resultSelector&lt;/code&gt; ）应用于源Observable发出的每个项目，并且仅从最近投影的内部Observable中获取值。</target>
        </trans-unit>
        <trans-unit id="2a802dcfd33b79856466fc5e35de71361bf29241" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, ObservedValueOf&amp;lt;O&amp;gt; | R&amp;gt;&lt;/code&gt;: An Observable that emits the result of applying the projection function (and the optional deprecated &lt;code&gt;resultSelector&lt;/code&gt;) to each item emitted by the source Observable and taking values from each projected inner Observable sequentially.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, ObservedValueOf&amp;lt;O&amp;gt; | R&amp;gt;&lt;/code&gt; ：一个Observable，其结果是将投影函数（和可选的不推荐使用的 &lt;code&gt;resultSelector&lt;/code&gt; ）应用于源Observable发出的每个项目，并依次从每个投影的内部Observable中获取值。</target>
        </trans-unit>
        <trans-unit id="92eec52d3a9e0aee0ab31663d93da5ec6a88327a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, ObservedValueOf&amp;lt;O&amp;gt; | R&amp;gt;&lt;/code&gt;: An observable of values merged together by joining the passed observable with itself, one after the other, for each value emitted from the source.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, ObservedValueOf&amp;lt;O&amp;gt; | R&amp;gt;&lt;/code&gt; ：对于一个从源发出的每个值，一个可观察的值通过将传递的可观察到的值与另一个自身连接在一起而合并在一起。</target>
        </trans-unit>
        <trans-unit id="6389b114b24798b556b201a37917cf23aa19a979" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, R&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, R&amp;gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="e8d1bd733bcb192dc0ef096871364d3d023737c8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, R&amp;gt;&lt;/code&gt;: A new Observable of property values from the source values.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, R&amp;gt;&lt;/code&gt; ：来自源值的新的属性值的Observable。</target>
        </trans-unit>
        <trans-unit id="e304529f59d93d3c25b21c0bd7fe17bed8f078ef" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, R&amp;gt;&lt;/code&gt;: An Observable of projected values from the most recent values from each input Observable, or an array of the most recent values from each input Observable.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, R&amp;gt;&lt;/code&gt; ：来自每个输入Observable的最新值的投影值的Observable，或来自每个输入Observable的最新值的数组。</target>
        </trans-unit>
        <trans-unit id="0c94ddce24cecab84d17bb4f8b35baa77d868ac0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, R&amp;gt;&lt;/code&gt;: An Observable that emits the given &lt;code&gt;value&lt;/code&gt; every time the source Observable emits something.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, R&amp;gt;&lt;/code&gt; ：每当源Observable发出某种东西时，它就会发出给定 &lt;code&gt;value&lt;/code&gt; 的Observable。</target>
        </trans-unit>
        <trans-unit id="fc79b7763d23cae388f6ab3337dcf1c4d68ce6b2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, R&amp;gt;&lt;/code&gt;: An Observable that emits the results of invoking the selector on the items emitted by a &lt;code&gt;ConnectableObservable&lt;/code&gt; that shares a single subscription to the underlying stream.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, R&amp;gt;&lt;/code&gt; ：一个Observable， &lt;code&gt;ConnectableObservable&lt;/code&gt; 在共享对基础流的单个预订的ConnectableObservable发出的项目上发出调用选择器的结果。</target>
        </trans-unit>
        <trans-unit id="83d1263ae27c17bb3433e47a18a1040160a7d6e3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, R&amp;gt;&lt;/code&gt;: An Observable that emits the source values and also result of applying the projection function to each value emitted on the output Observable and and merging the results of the Observables obtained from this transformation.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, R&amp;gt;&lt;/code&gt; ：发出源值的Observable，也将将投影函数应用于在输出Observable上发射的每个值，然后合并从此变换获得的Observable的结果。</target>
        </trans-unit>
        <trans-unit id="1e461258d10f81fe5813686fbc0c2bda14a219dc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, R&amp;gt;&lt;/code&gt;: An Observable that emits the values from the source Observable transformed by the given &lt;code&gt;project&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, R&amp;gt;&lt;/code&gt; ：一个Observable，它从给定 &lt;code&gt;project&lt;/code&gt; 函数转换后的源Observable发出值。</target>
        </trans-unit>
        <trans-unit id="936d1a67ca42c166a86a10148a49bde1e454fa75" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, R&amp;gt;&lt;/code&gt;: An Observable that emits values from source Observable, but - if it errors - subscribes to the next passed Observable and so on, until it completes or runs out of Observables.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, R&amp;gt;&lt;/code&gt; ：一个Observable，它从源Observable发出值，但是-如果出错-订阅下一个传递的Observable，依此类推，直到完成或用完Observables。</target>
        </trans-unit>
        <trans-unit id="99d2bff6a3704c559e008d5d0bc66fdcb9c51d50" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, R&amp;gt;&lt;/code&gt;: An observable of the accumulated values.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, R&amp;gt;&lt;/code&gt; ：可观察到的累积值。</target>
        </trans-unit>
        <trans-unit id="b40b1eb80ecabc355acb81f89cecbb6782e4906c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, T | D&amp;gt;&lt;/code&gt;: An Observable of the first item that matches the condition.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, T | D&amp;gt;&lt;/code&gt; ：符合条件的第一项的Observable。</target>
        </trans-unit>
        <trans-unit id="0da3914377c50370c3b653fe993f2deb3effae27" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, T | D&amp;gt;&lt;/code&gt;: An Observable that emits only the last item satisfying the given condition from the source, or an NoSuchElementException if no such items are emitted.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, T | D&amp;gt;&lt;/code&gt; ：一个Observable，仅从源中发出满足给定条件的最后一个项目，如果没有这样的项目被发出，则抛出NoSuchElementException。</target>
        </trans-unit>
        <trans-unit id="609691028cdab1ac2a82fd5eb880713da1a59fd9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, T | D&amp;gt;&lt;/code&gt;: An Observable that emits the items in the specified Iterable and then emits the items emitted by the source Observable.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, T | D&amp;gt;&lt;/code&gt; ：一个Observable，它发出指定的Iterable中的项目，然后发出由源Observable发出的项目。</target>
        </trans-unit>
        <trans-unit id="ed5d3fe82744ac00ef5f18025cfc4a819f2feec8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, T | ObservedValueOf&amp;lt;O&amp;gt;&amp;gt;&lt;/code&gt;: An observable that originates from either the source or the observable returned by the catch &lt;code&gt;selector&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, T | ObservedValueOf&amp;lt;O&amp;gt;&amp;gt;&lt;/code&gt; ：一个可观察值，它来自源或捕获 &lt;code&gt;selector&lt;/code&gt; 函数返回的可观察值。</target>
        </trans-unit>
        <trans-unit id="917e13a869d45f18bbb3fa233d195401c5881fc8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, T | R&amp;gt;&lt;/code&gt;: An Observable that emits a single value that is the result of accumulating the values emitted by the source Observable.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, T | R&amp;gt;&lt;/code&gt; ：一个Observable发出一个值，该值是对源Observable发出的值进行累加的结果。</target>
        </trans-unit>
        <trans-unit id="f3dbf8202edc720dbee99010f4de8c8d524a1654" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, T | R&amp;gt;&lt;/code&gt;: An Observable that emits either the specified &lt;code&gt;defaultValue&lt;/code&gt; if the source Observable emits no items, or the values emitted by the source Observable.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, T | R&amp;gt;&lt;/code&gt; ：一个Observable，如果源Observable不发射任何项目，则发射指定的 &lt;code&gt;defaultValue&lt;/code&gt; ，或者源Observable发射的值。</target>
        </trans-unit>
        <trans-unit id="529b798ac9b12565a4850db4ce7e7eedfdc11a0d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, T | R&amp;gt;&lt;/code&gt;: Observable that mirrors behaviour of source or, when timeout check fails, of an Observable passed as a second parameter.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, T | R&amp;gt;&lt;/code&gt; ：Observable，它反映源的行为，或者在超时检查失败时，作为第二个参数传递的Observable的行为。</target>
        </trans-unit>
        <trans-unit id="6ab6b4873dd13ed201c943f6c53cf2f2269d7d5c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, T | undefined&amp;gt;&lt;/code&gt;: An Observable of the first item that matches the condition.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, T | undefined&amp;gt;&lt;/code&gt; ：匹配条件的第一项的Observable。</target>
        </trans-unit>
        <trans-unit id="92b0d5ad575e28215f2190858c47eade8e16ab5f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, T[]&amp;gt;&lt;/code&gt;: An Observable of arrays of buffered values.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, T[]&amp;gt;&lt;/code&gt; ：可观察到的缓冲值数组。</target>
        </trans-unit>
        <trans-unit id="06e1a442a5978c8053196612fd140be99654a739" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, T[]&amp;gt;&lt;/code&gt;: An Observable of buffers, which are arrays of values.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, T[]&amp;gt;&lt;/code&gt; ：一个可观察的缓冲区，它是值的数组。</target>
        </trans-unit>
        <trans-unit id="963e1454f929c69a8e15356996340866e7328b0a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, T[]&amp;gt;&lt;/code&gt;: An array from an observable sequence.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, T[]&amp;gt;&lt;/code&gt; ：可观察序列中的数组。</target>
        </trans-unit>
        <trans-unit id="46031b573a888633ac1d11c7d0c5a75d253ba889" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, T[]&amp;gt;&lt;/code&gt;: An observable of arrays of buffered values.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, T[]&amp;gt;&lt;/code&gt; ：可观察到的缓冲值数组。</target>
        </trans-unit>
        <trans-unit id="95d772c65fa6e969daaef9c997413f7d78c99bab" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, TimeInterval&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;: Observable that emit infomation about value and interval</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, TimeInterval&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; ：可观察到的有关值和间隔的信息</target>
        </trans-unit>
        <trans-unit id="f01e99c7b50bfb9837a11c004da57eb915716d96" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, Timestamp&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, Timestamp&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="ac1c1912e9c531cf65e1edd68b325400d84e4c9e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, [T, T]&amp;gt;&lt;/code&gt;: An Observable of pairs (as arrays) of consecutive values from the source Observable.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, [T, T]&amp;gt;&lt;/code&gt; ：来自源Observable的成对的连续值对（作为数组）的Observable。</target>
        </trans-unit>
        <trans-unit id="1c706a87589545aacce9fc175adab0cfa04a67fc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, boolean&amp;gt;&lt;/code&gt;: An Observable of a boolean value indicating whether observable was empty or not</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, boolean&amp;gt;&lt;/code&gt; ：一个布尔值的Observable，它指示observable是否为空</target>
        </trans-unit>
        <trans-unit id="52c5f27dea5137ec37457b98a437e8a147c2012b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, boolean&amp;gt;&lt;/code&gt;: An Observable of a single boolean value representing whether or not the values emitted by both observables were equal in sequence.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, boolean&amp;gt;&lt;/code&gt; ：单个布尔值的Observable，表示两个可观察对象发出的值在顺序上是否相等。</target>
        </trans-unit>
        <trans-unit id="084491f279558c6a0089f3fafc3e046ac95017d4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, boolean&amp;gt;&lt;/code&gt;: An Observable of booleans that determines if all items of the source Observable meet the condition specified.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, boolean&amp;gt;&lt;/code&gt; ：一个布尔值的Observable，它确定源Observable的所有项是否满足指定的条件。</target>
        </trans-unit>
        <trans-unit id="9c8ab2999ba64eaf1d254ef445e315a3af05b9ba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, number&amp;gt;&lt;/code&gt;: An Observable of one number that represents the count as described above.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, number&amp;gt;&lt;/code&gt; ：一个数字的可观察值，表示如上所述的计数。</target>
        </trans-unit>
        <trans-unit id="21508cc91f2bf6aad48d4bf57db2587d1fdae434" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, number&amp;gt;&lt;/code&gt;: An Observable of the index of the first item that matches the condition.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, number&amp;gt;&lt;/code&gt; ：匹配条件的第一项的索引的可观察值。</target>
        </trans-unit>
        <trans-unit id="6e1666f9fe233ad327cda0b296e7fd550add86f5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;any, T&amp;gt;&lt;/code&gt;: An Observable that takes a source of Observables and propagates the first observable exclusively until it completes before subscribing to the next.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;any, T&amp;gt;&lt;/code&gt; ：一个Observable，它获取Observables的源，并专门传播第一个Observable，直到它完成，然后订阅下一个Observable。</target>
        </trans-unit>
        <trans-unit id="c6a5ca5378c9fcf666946deff36b36b6ae25600b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;any, never&amp;gt;&lt;/code&gt;: An empty Observable that only calls &lt;code&gt;complete&lt;/code&gt; or &lt;code&gt;error&lt;/code&gt;, based on which one is called by the source Observable.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;any, never&amp;gt;&lt;/code&gt; ：一个空的Observable，仅调用 &lt;code&gt;complete&lt;/code&gt; 或 &lt;code&gt;error&lt;/code&gt; ，源Observable调用此方法。</target>
        </trans-unit>
        <trans-unit id="6e58713c020d2f707061137552b408199b941f2d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Promise&amp;lt;void&amp;gt;&lt;/code&gt;: a promise that either resolves on observable completion or rejects with the handled error</source>
          <target state="translated">&lt;code&gt;Promise&amp;lt;void&amp;gt;&lt;/code&gt; ：一个承诺，可以在可观察的完成时解析，或者在处理的错误中拒绝</target>
        </trans-unit>
        <trans-unit id="cd50de8ad5bd5bb0c32bba750b39c2af3faa752d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SubscribeOnObservable&lt;/code&gt; is hidden from direct use in v6 and is accessible only through operator &lt;code&gt;subscribeOn&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;SubscribeOnObservable&lt;/code&gt; 是从V6直接使用隐藏的，只有通过运营商进行访问 &lt;code&gt;subscribeOn&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3d845fe57dde654307e9827b34a87ee47b1565c8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Subscriber&amp;lt;T&amp;gt;&lt;/code&gt;: A Subscriber wrapping the (partially defined) Observer represented by the given arguments.</source>
          <target state="translated">&lt;code&gt;Subscriber&amp;lt;T&amp;gt;&lt;/code&gt; ：包裹由给定参数表示的（部分定义的）观察者的订阅者。</target>
        </trans-unit>
        <trans-unit id="e9296bc5910b2bafe547429ecf483eeaf5e40ba8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Subscription&lt;/code&gt;: A subscription in order to be able to unsubscribe the scheduled work.</source>
          <target state="translated">&lt;code&gt;Subscription&lt;/code&gt; ：订阅，以便能够取消预定的工作。</target>
        </trans-unit>
        <trans-unit id="5eb8999b131bccb24bac0dc65dd7ee3184a724a9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Subscription&lt;/code&gt;: Returns the Subscription used or created to be added to the inner subscriptions list. This Subscription can be used with &lt;code&gt;remove()&lt;/code&gt; to remove the passed teardown logic from the inner subscriptions list.</source>
          <target state="translated">&lt;code&gt;Subscription&lt;/code&gt; ：返回用于或添加到内部订阅列表中的订阅。此订阅可以与 &lt;code&gt;remove()&lt;/code&gt; 一起使用，以从内部订阅列表中删除传递的拆解逻辑。</target>
        </trans-unit>
        <trans-unit id="9751fe552726353c3cf0acaa69371203468189b2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UnaryFunction&amp;lt;Observable&amp;lt;T&amp;gt;, ConnectableObservable&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;UnaryFunction&amp;lt;Observable&amp;lt;T&amp;gt;, ConnectableObservable&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="8caae40fe3d57bed9c2dba2b723525aef2fe63ec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UnaryFunction&amp;lt;Observable&amp;lt;T&amp;gt;, ConnectableObservable&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;: An observable sequence that contains the elements of a sequence produced by multicasting the source sequence.</source>
          <target state="translated">&lt;code&gt;UnaryFunction&amp;lt;Observable&amp;lt;T&amp;gt;, ConnectableObservable&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; ：一个可观察的序列，其中包含通过多播源序列而产生的序列的元素。</target>
        </trans-unit>
        <trans-unit id="0c0eb17bf7e6eda8feecbb427e767db2329c3198" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UnaryFunction&amp;lt;Observable&amp;lt;T&amp;gt;, [Observable&amp;lt;T&amp;gt;, Observable&amp;lt;T&amp;gt;]&amp;gt;&lt;/code&gt;: An array with two Observables: one with values that passed the predicate, and another with values that did not pass the predicate.</source>
          <target state="translated">&lt;code&gt;UnaryFunction&amp;lt;Observable&amp;lt;T&amp;gt;, [Observable&amp;lt;T&amp;gt;, Observable&amp;lt;T&amp;gt;]&amp;gt;&lt;/code&gt; ：具有两个Observable的数组：一个具有通过谓词的值，另一个具有未通过谓词的值。</target>
        </trans-unit>
        <trans-unit id="daa3594eaba6fa012b962e692bb34ebadc67452e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;WebSocketSubject&amp;lt;T&amp;gt;&lt;/code&gt;: Subject which allows to both send and receive messages via WebSocket connection.</source>
          <target state="translated">&lt;code&gt;WebSocketSubject&amp;lt;T&amp;gt;&lt;/code&gt; ：允许通过WebSocket连接发送和接收消息的主题。</target>
        </trans-unit>
        <trans-unit id="b48aa90627a1c9215b79016aecac86a4deb348c5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;WebSocketSubject&lt;/code&gt; has an additional operator, not found in other Subjects. It is called &lt;code&gt;multiplex&lt;/code&gt; and it is used to simulate opening several socket connections, while in reality maintaining only one. For example, an application has both chat panel and real-time notifications about sport news. Since these are two distinct functions, it would make sense to have two separate connections for each. Perhaps there could even be two separate services with WebSocket endpoints, running on separate machines with only GUI combining them together. Having a socket connection for each functionality could become too resource expensive. It is a common pattern to have single WebSocket endpoint that acts as a gateway for the other services (in this case chat and sport news services). Even though there is a single connection in a client app, having the ability to manipulate streams as if it were two separate sockets is desirable. This eliminates manually registering and unregistering in a gateway for given service and filter out messages of interest. This is exactly what &lt;code&gt;multiplex&lt;/code&gt; method is for.</source>
          <target state="translated">&lt;code&gt;WebSocketSubject&lt;/code&gt; 还有一个其他运算符，在其他主题中找不到。称为 &lt;code&gt;multiplex&lt;/code&gt; 它用于模拟打开多个套接字连接，而实际上仅维护一个。例如，一个应用程序同时具有聊天面板和有关体育新闻的实时通知。由于这些是两个不同的功能，因此每个都有两个单独的连接将是有意义的。甚至可能有两个带有WebSocket端点的单独服务，它们在单独的计算机上运行，​​只有GUI将它们组合在一起。为每个功能使用套接字连接可能会变得资源过于昂贵。具有单个WebSocket端点作为其他服务（在本例中为聊天和体育新闻服务）的网关的一种常见模式。即使客户端应用程序中只有一个连接，也希望能够像对待两个单独的套接字一样操作流。这消除了在给定服务的网关中手动注册和注销的麻烦，并过滤出感兴趣的消息。这正是 &lt;code&gt;multiplex&lt;/code&gt; 方法是针对的。</target>
        </trans-unit>
        <trans-unit id="69561978d6621715d34ad8aac9add39a6dd9bc48" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;[0-9]+[ms|s|m]&lt;/code&gt; time progression: the time progression syntax lets you progress virtual time by a specific amount. It's a number, followed by a time unit of &lt;code&gt;ms&lt;/code&gt; (milliseconds), &lt;code&gt;s&lt;/code&gt; (seconds), or &lt;code&gt;m&lt;/code&gt; (minutes) without any space between them, e.g. &lt;code&gt;a 10ms b&lt;/code&gt;. See &lt;a href=&quot;marble-testing#time-progression-syntax&quot;&gt;Time progression syntax&lt;/a&gt; for more details.</source>
          <target state="translated">&lt;code&gt;[0-9]+[ms|s|m]&lt;/code&gt; 时间进度：时间进度语法使您可以将虚拟时间进行特定量的调整。它是一个数字，后跟一个时间单位 &lt;code&gt;ms&lt;/code&gt; （毫秒）， &lt;code&gt;s&lt;/code&gt; （秒）或 &lt;code&gt;m&lt;/code&gt; （分钟），它们之间没有任何空格，例如 &lt;code&gt;a 10ms b&lt;/code&gt; 。有关更多详细信息，请参见&lt;a href=&quot;marble-testing#time-progression-syntax&quot;&gt;时间进度语法&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="06d76181f50eed2bda7f22c043e74fa2ae4d0f2a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;[Observable&amp;lt;T&amp;gt;, Observable&amp;lt;T&amp;gt;]&lt;/code&gt;: An array with two Observables: one with values that passed the predicate, and another with values that did not pass the predicate.</source>
          <target state="translated">&lt;code&gt;[Observable&amp;lt;T&amp;gt;, Observable&amp;lt;T&amp;gt;]&lt;/code&gt; ：具有两个Observable的数组：一个具有通过谓词的值，另一个具有未通过谓词的值。</target>
        </trans-unit>
        <trans-unit id="7be0d73ff95f971ce3d0ec056f20b5e78d2401a0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;[a-z0-9]&lt;/code&gt; e.g. &lt;code&gt;'a'&lt;/code&gt; any alphanumeric character: Represents a value being emitted by the producer signaling &lt;code&gt;next()&lt;/code&gt;. Also consider that you could map this into an object or an array like this:</source>
          <target state="translated">&lt;code&gt;[a-z0-9]&lt;/code&gt; 例如 &lt;code&gt;'a'&lt;/code&gt; 任何字母数字字符：表示生产者通过信号 &lt;code&gt;next()&lt;/code&gt; 发送的值。还请考虑您可以将其映射到这样的对象或数组中：</target>
        </trans-unit>
        <trans-unit id="76574adecd5f0112d1ef6e3dee5ffec9d1760f98" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;any&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;any&lt;/code&gt;:</target>
        </trans-unit>
        <trans-unit id="1d66416b13f1e69be3b9fe9168a34eccd8117317" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;asap&lt;/code&gt; scheduler behaves the same as &lt;a href=&quot;asyncscheduler&quot;&gt;&lt;code&gt;async&lt;/code&gt;&lt;/a&gt; scheduler when you use it to delay task in time. If however you set delay to &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;asap&lt;/code&gt; will wait for current synchronously executing code to end and then it will try to execute given task as fast as possible.</source>
          <target state="translated">&lt;code&gt;asap&lt;/code&gt; 当您使用asap计划程序延迟时间时，其行为与&lt;a href=&quot;asyncscheduler&quot;&gt; &lt;code&gt;async&lt;/code&gt; &lt;/a&gt;计划程序相同。但是，如果将delay设置为 &lt;code&gt;0&lt;/code&gt; ，则 &lt;code&gt;asap&lt;/code&gt; 将等待当前同步执行的代码结束，然后它将尝试尽快执行给定的任务。</target>
        </trans-unit>
        <trans-unit id="8d2f7871c278c3ff4f15d4e1797b46bd3a11325e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;asap&lt;/code&gt; scheduler will do its best to minimize time between end of currently executing code and start of scheduled task. This makes it best candidate for performing so called &quot;deferring&quot;. Traditionally this was achieved by calling &lt;code&gt;setTimeout(deferredTask, 0)&lt;/code&gt;, but that technique involves some (although minimal) unwanted delay.</source>
          <target state="translated">&lt;code&gt;asap&lt;/code&gt; 调度程序将尽最大努力减少当前执行代码结束与计划任务开始之间的时间。这使其成为执行所谓的&amp;ldquo;延期&amp;rdquo;的最佳人选。传统上，这是通过调用 &lt;code&gt;setTimeout(deferredTask, 0)&lt;/code&gt; ，但是该技术涉及一些（尽管最小）不必要的延迟。</target>
        </trans-unit>
        <trans-unit id="38282087e639f45cb81b714b183b93c266c618fb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;async&lt;/code&gt; scheduler schedules tasks asynchronously, by putting them on the JavaScript event loop queue. It is best used to delay tasks in time or to schedule tasks repeating in intervals.</source>
          <target state="translated">&lt;code&gt;async&lt;/code&gt; 调度程序通过将任务放在JavaScript事件循环队列中来异步调度任务。最好将其延迟时间或安排间隔重复的任务。</target>
        </trans-unit>
        <trans-unit id="5f3bfc256736a1a2b56372aad02d0143b55bdd10" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;audit&lt;/code&gt; is similar to &lt;code&gt;throttle&lt;/code&gt;, but emits the last value from the silenced time window, instead of the first value. &lt;code&gt;audit&lt;/code&gt; emits the most recent value from the source Observable on the output Observable as soon as its internal timer becomes disabled, and ignores source values while the timer is enabled. Initially, the timer is disabled. As soon as the first source value arrives, the timer is enabled by calling the &lt;code&gt;durationSelector&lt;/code&gt; function with the source value, which returns the &quot;duration&quot; Observable. When the duration Observable emits a value or completes, the timer is disabled, then the most recent source value is emitted on the output Observable, and this process repeats for the next source value.</source>
          <target state="translated">&lt;code&gt;audit&lt;/code&gt; 类似于 &lt;code&gt;throttle&lt;/code&gt; ，但是从静默时间窗口发出最后一个值，而不是第一个值。一旦内部计时器变为禁用状态， &lt;code&gt;audit&lt;/code&gt; 就会在输出Observable上从源Observable发出最新值，并在启用计时器后忽略源值。最初，计时器被禁用。第一个源值到达时，通过使用源值调用 &lt;code&gt;durationSelector&lt;/code&gt; 函数来启用计时器，该函数将返回&amp;ldquo; duration&amp;rdquo;可观察到的时间。当Observable持续时间发出值或完成时，禁用计时器，然后在输出Observable上发出最新的源值，并对下一个源值重复此过程。</target>
        </trans-unit>
        <trans-unit id="40805c639cd2c3fa224cf3a2a39ee4a56ef4f08e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;auditTime&lt;/code&gt; is similar to &lt;code&gt;throttleTime&lt;/code&gt;, but emits the last value from the silenced time window, instead of the first value. &lt;code&gt;auditTime&lt;/code&gt; emits the most recent value from the source Observable on the output Observable as soon as its internal timer becomes disabled, and ignores source values while the timer is enabled. Initially, the timer is disabled. As soon as the first source value arrives, the timer is enabled. After &lt;code&gt;duration&lt;/code&gt; milliseconds (or the time unit determined internally by the optional &lt;code&gt;scheduler&lt;/code&gt;) has passed, the timer is disabled, then the most recent source value is emitted on the output Observable, and this process repeats for the next source value. Optionally takes a &lt;a href=&quot;../index/interface/schedulerlike&quot;&gt;&lt;code&gt;SchedulerLike&lt;/code&gt;&lt;/a&gt; for managing timers.</source>
          <target state="translated">&lt;code&gt;auditTime&lt;/code&gt; 与 &lt;code&gt;throttleTime&lt;/code&gt; 时间类似，但是从静默时间窗口中发出最后一个值，而不是第一个值。一旦内部计时器禁用， &lt;code&gt;auditTime&lt;/code&gt; 就会在输出Observable上从源Observable发出最新值，并在启用计时器时忽略源值。最初，计时器被禁用。一旦第一个源值到达，计时器就会启用。经过 &lt;code&gt;duration&lt;/code&gt; 毫秒（或由可选 &lt;code&gt;scheduler&lt;/code&gt; 内部确定的时间单位）后，禁用计时器，然后在输出Observable上发出最新的源值，并对下一个源值重复此过程。（可选）参加&lt;a href=&quot;../index/interface/schedulerlike&quot;&gt; &lt;code&gt;SchedulerLike&lt;/code&gt; &lt;/a&gt; 用于管理计时器。</target>
        </trans-unit>
        <trans-unit id="0b2f0508ff5d8cf3b8a58819217df8e1f5a557ee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bindCallback&lt;/code&gt; is not an operator because its input and output are not Observables. The input is a function &lt;code&gt;func&lt;/code&gt; with some parameters. The last parameter must be a callback function that &lt;code&gt;func&lt;/code&gt; calls when it is done.</source>
          <target state="translated">&lt;code&gt;bindCallback&lt;/code&gt; 不是运算符，因为其输入和输出不是Observable。输入是带有某些参数的函数 &lt;code&gt;func&lt;/code&gt; 。最后一个参数必须是完成后 &lt;code&gt;func&lt;/code&gt; 调用的回调函数。</target>
        </trans-unit>
        <trans-unit id="9211f4b858fc968794a77bc7b1d03546135e6858" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bindNodeCallback&lt;/code&gt; is not an operator because its input and output are not Observables. The input is a function &lt;code&gt;func&lt;/code&gt; with some parameters, but the last parameter must be a callback function that &lt;code&gt;func&lt;/code&gt; calls when it is done. The callback function is expected to follow Node.js conventions, where the first argument to the callback is an error object, signaling whether call was successful. If that object is passed to callback, it means something went wrong.</source>
          <target state="translated">&lt;code&gt;bindNodeCallback&lt;/code&gt; 不是运算符，因为其输入和输出不是Observable。输入是带有某些参数的函数 &lt;code&gt;func&lt;/code&gt; ，但最后一个参数必须是 &lt;code&gt;func&lt;/code&gt; 完成后调用的回调函数。回调函数应遵循Node.js约定，其中回调的第一个参数是错误对象，表示调用是否成功。如果将该对象传递给回调，则表示出了点问题。</target>
        </trans-unit>
        <trans-unit id="b958fd92ecb9faf8ae58cd7ebc6f92725abe218c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;catch&lt;/code&gt; -&amp;gt; &lt;code&gt;catchError&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;catch&lt;/code&gt; - &amp;gt; &lt;code&gt;catchError&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="090112e53789f1e202cdc6c3e33483de9d1744a4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;class&lt;/code&gt;&lt;code&gt;deprecated&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;class&lt;/code&gt;&lt;code&gt;deprecated&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a862595a3c1548793957cd83ac96a6a641a31216" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;class&lt;/code&gt;&lt;code&gt;stable&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;class&lt;/code&gt;&lt;code&gt;stable&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="48fe30ff9e2a9d2bcaf4ee2c5d861788e26cdd20" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cold(marbleDiagram: string, values?: object, error?: any)&lt;/code&gt; - creates a &lt;a href=&quot;https://medium.com/@benlesh/hot-vs-cold-observables-f8094ed53339&quot;&gt;&quot;cold&quot; observable&lt;/a&gt; whose subscription starts when the test begins.</source>
          <target state="translated">&lt;code&gt;cold(marbleDiagram: string, values?: object, error?: any)&lt;/code&gt; -创建一个&lt;a href=&quot;https://medium.com/@benlesh/hot-vs-cold-observables-f8094ed53339&quot;&gt;&amp;ldquo;冷&amp;rdquo;可观察&lt;/a&gt;的对象，其订阅在测试开始时开始。</target>
        </trans-unit>
        <trans-unit id="86ed056620603316b0dd1656f24b1776a713dcee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cold(marbles: string, values?: object, error?: any)&lt;/code&gt; - creates a &quot;cold&quot; observable whose subscription starts when the test begins.</source>
          <target state="translated">&lt;code&gt;cold(marbles: string, values?: object, error?: any)&lt;/code&gt; -创建一个&amp;ldquo;冷&amp;rdquo;可观察的对象，其可在测试开始时开始订阅。</target>
        </trans-unit>
        <trans-unit id="f6b28dc7fe98921afceb99175e066d6a87d85a26" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;combineAll&lt;/code&gt; takes an Observable of Observables, and collects all Observables from it. Once the outer Observable completes, it subscribes to all collected Observables and combines their values using the &lt;a href=&quot;../index/function/combinelatest&quot;&gt;&lt;code&gt;combineLatest&lt;/code&gt;&lt;/a&gt; strategy, such that:</source>
          <target state="translated">&lt;code&gt;combineAll&lt;/code&gt; 接收一个Observable of Observables，并从中收集所有Observables。一旦外部Observable完成，它将订阅所有收集的Observable，并使用&lt;a href=&quot;../index/function/combinelatest&quot;&gt; &lt;code&gt;combineLatest&lt;/code&gt; &lt;/a&gt;策略合并其值，例如：</target>
        </trans-unit>
        <trans-unit id="c48c87a64f802358b3ec81f54db717377180b5f1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;combineLatest&lt;/code&gt; accepts as optional parameter &lt;code&gt;project&lt;/code&gt; function, which takes as arguments all values that would normally be emitted by resulting Observable. &lt;code&gt;project&lt;/code&gt; can return any kind of value, which will be then emitted by Observable instead of default array. Note that &lt;code&gt;project&lt;/code&gt; does not take as argument that array of values, but values themselves. That means default &lt;code&gt;project&lt;/code&gt; can be imagined as function that takes all its arguments and puts them into an array.</source>
          <target state="translated">&lt;code&gt;combineLatest&lt;/code&gt; 接受作为可选参数的 &lt;code&gt;project&lt;/code&gt; 函数，该函数接受通常由结果Observable发出的所有值作为参数。 &lt;code&gt;project&lt;/code&gt; 可以返回任何类型的值，然后由Observable发出而不是默认数组发出。请注意， &lt;code&gt;project&lt;/code&gt; 不会将值数组作为参数，而是值本身。这意味着可以将默认 &lt;code&gt;project&lt;/code&gt; 想象为采用所有参数并将其放入数组的函数。</target>
        </trans-unit>
        <trans-unit id="a0acc0a59cb9c4861d27d529a998d4109e7b2dd6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;combineLatest&lt;/code&gt; combines the values from all the Observables passed as arguments. This is done by subscribing to each Observable in order and, whenever any Observable emits, collecting an array of the most recent values from each Observable. So if you pass &lt;code&gt;n&lt;/code&gt; Observables to operator, returned Observable will always emit an array of &lt;code&gt;n&lt;/code&gt; values, in order corresponding to order of passed Observables (value from the first Observable on the first place and so on).</source>
          <target state="translated">&lt;code&gt;combineLatest&lt;/code&gt; 所有作为参数传递的Observable的值。这是通过按顺序订阅每个Observable来完成的，并且每当发出任何Observable时，就从每个Observable中收集最新值的数组。因此，如果将 &lt;code&gt;n&lt;/code&gt; 个 Observables 传递给operator，则返回的Observable将始终发出 &lt;code&gt;n&lt;/code&gt; 个值的数组，其顺序与传递的Observables的顺序相对应（第一个Observable的值排在第一位，依此类推）。</target>
        </trans-unit>
        <trans-unit id="01ad8a728f3323a7a044e430120e60f1ce5b8a98" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;concat&lt;/code&gt; joins multiple Observables together, by subscribing to them one at a time and merging their results into the output Observable. You can pass either an array of Observables, or put them directly as arguments. Passing an empty array will result in Observable that completes immediately.</source>
          <target state="translated">&lt;code&gt;concat&lt;/code&gt; 通过一次订阅一个并将它们的结果合并到输出Observable中，从而将多个Observable结合在一起。您可以传递一个Observable数组，也可以将它们直接作为参数。传递空数组将导致Observable立即完成。</target>
        </trans-unit>
        <trans-unit id="cd455e398737536791faa98b5aaf7d26b9064afe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;concat&lt;/code&gt; will subscribe to first input Observable and emit all its values, without changing or affecting them in any way. When that Observable completes, it will subscribe to then next Observable passed and, again, emit its values. This will be repeated, until the operator runs out of Observables. When last input Observable completes, &lt;code&gt;concat&lt;/code&gt; will complete as well. At any given moment only one Observable passed to operator emits values. If you would like to emit values from passed Observables concurrently, check out &lt;a href=&quot;merge&quot;&gt;&lt;code&gt;merge&lt;/code&gt;&lt;/a&gt; instead, especially with optional &lt;code&gt;concurrent&lt;/code&gt; parameter. As a matter of fact, &lt;code&gt;concat&lt;/code&gt; is an equivalent of &lt;code&gt;merge&lt;/code&gt; operator with &lt;code&gt;concurrent&lt;/code&gt; parameter set to &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;concat&lt;/code&gt; 将订阅第一个输入Observable并发出其所有值，而不会以任何方式更改或影响它们。当该Observable完成时，它将订阅然后传递的下一个Observable，并再次发出其值。将重复此操作，直到操作员用完Observable。当最后一个输入Observable完成时， &lt;code&gt;concat&lt;/code&gt; 也将完成。在任何给定时刻，只有一个传递给运算符的Observable会发出值。如果您希望同时从传递的Observable发出值，请改为检查&lt;a href=&quot;merge&quot;&gt; &lt;code&gt;merge&lt;/code&gt; &lt;/a&gt;，尤其是使用可选的 &lt;code&gt;concurrent&lt;/code&gt; 参数。作为事实上， &lt;code&gt;concat&lt;/code&gt; 是等效的 &lt;code&gt;merge&lt;/code&gt; 运营商， &lt;code&gt;concurrent&lt;/code&gt; 参数集 &lt;code&gt;1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="385581e593ae600c22359073bd8d84c8d9c69e58" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt;&lt;code&gt;stable&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt;&lt;code&gt;stable&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9a4d3fc4b7f98a5a344bac51798dbde83d943597" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;count&lt;/code&gt; transforms an Observable that emits values into an Observable that emits a single value that represents the number of values emitted by the source Observable. If the source Observable terminates with an error, &lt;code&gt;count&lt;/code&gt; will pass this error notification along without emitting a value first. If the source Observable does not terminate at all, &lt;code&gt;count&lt;/code&gt; will neither emit a value nor terminate. This operator takes an optional &lt;code&gt;predicate&lt;/code&gt; function as argument, in which case the output emission will represent the number of source values that matched &lt;code&gt;true&lt;/code&gt; with the &lt;code&gt;predicate&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;count&lt;/code&gt; 将发出值的Observable转换为发出表示源Observable发出的值数量的单个值的Observable。如果源Observable以错误终止，则 &lt;code&gt;count&lt;/code&gt; 将传递此错误通知，而无需先发出值。如果源Observable根本不终止，则 &lt;code&gt;count&lt;/code&gt; 既不发出值也不终止。这个操作者有一个可选的 &lt;code&gt;predicate&lt;/code&gt; 函数作为参数，在这种情况下，输出发射将表示匹配的源值的数量 &lt;code&gt;true&lt;/code&gt; 与 &lt;code&gt;predicate&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f0cdc1ef62ba04465e2f72df3b6dbbf436fe86ec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;debounce&lt;/code&gt; delays values emitted by the source Observable, but drops previous pending delayed emissions if a new value arrives on the source Observable. This operator keeps track of the most recent value from the source Observable, and spawns a duration Observable by calling the &lt;code&gt;durationSelector&lt;/code&gt; function. The value is emitted only when the duration Observable emits a value or completes, and if no other value was emitted on the source Observable since the duration Observable was spawned. If a new value appears before the duration Observable emits, the previous value will be dropped and will not be emitted on the output Observable.</source>
          <target state="translated">&lt;code&gt;debounce&lt;/code&gt; 延迟源Observable发出的值，但是如果有新值到达源Observable则丢弃以前的未决延迟发射。该运算符跟踪源Observable的最新值，并通过调用 &lt;code&gt;durationSelector&lt;/code&gt; 函数产生一个Observable 持续时间。仅当Observable持续时间发出值或完成时，并且自从产生Observable持续时间以来，在源Observable上未发出其他值时，才发出该值。如果在持续时间Observable发出之前出现了新值，则先前的值将被丢弃，并且不会在输出Observable上发出。</target>
        </trans-unit>
        <trans-unit id="37876e5463e7779e33fb2f769015b62934416edb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;debounceTime&lt;/code&gt; delays values emitted by the source Observable, but drops previous pending delayed emissions if a new value arrives on the source Observable. This operator keeps track of the most recent value from the source Observable, and emits that only when &lt;code&gt;dueTime&lt;/code&gt; enough time has passed without any other value appearing on the source Observable. If a new value appears before &lt;code&gt;dueTime&lt;/code&gt; silence occurs, the previous value will be dropped and will not be emitted on the output Observable.</source>
          <target state="translated">&lt;code&gt;debounceTime&lt;/code&gt; 延迟了源Observable发出的值，但是如果有新值到达源Observable则丢弃先前的未决延迟发射。此运算符跟踪源Observable的最新值，并仅在 &lt;code&gt;dueTime&lt;/code&gt; 足够的时间而没有其他值出现在源Observable上时发出该值。如果在 &lt;code&gt;dueTime&lt;/code&gt; 静音发生之前出现新值，则先前的值将被丢弃，并且不会在输出Observable上发出。</target>
        </trans-unit>
        <trans-unit id="c49335f81d19a51a43bd936b56c74ed6776fb327" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;defaultIfEmpty&lt;/code&gt; emits the values emitted by the source Observable or a specified default value if the source Observable is empty (completes without having emitted any &lt;code&gt;next&lt;/code&gt; value).</source>
          <target state="translated">&lt;code&gt;defaultIfEmpty&lt;/code&gt; 会发出源Observable发出的值，或者如果源Observable为空（完成而未发出任何 &lt;code&gt;next&lt;/code&gt; 值），则返回指定的默认值。</target>
        </trans-unit>
        <trans-unit id="b48bcd84068ffa0b67531f2cc7d97d7b8ddcc69e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;defer&lt;/code&gt; allows you to create the Observable only when the Observer subscribes, and create a fresh Observable for each Observer. It waits until an Observer subscribes to it, and then it generates an Observable, typically with an Observable factory function. It does this afresh for each subscriber, so although each subscriber may think it is subscribing to the same Observable, in fact each subscriber gets its own individual Observable.</source>
          <target state="translated">&lt;code&gt;defer&lt;/code&gt; 允许您仅在观察者订阅时创建观察者，并为每个观察者创建一个新的观察者。它等待直到Observer订阅它，然后生成通常具有Observable工厂功能的Observable。它为每个订户重新进行此操作，因此尽管每个订户可能认为自己正在订阅相同的Observable，但实际上每个订户都拥有自己的个人Observable。</target>
        </trans-unit>
        <trans-unit id="5eaa3f953343c295087c9f21c5472ac2c26f0955" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;delayWhen&lt;/code&gt; time shifts each emitted value from the source Observable by a time span determined by another Observable. When the source emits a value, the &lt;code&gt;delayDurationSelector&lt;/code&gt; function is called with the source value as argument, and should return an Observable, called the &quot;duration&quot; Observable. The source value is emitted on the output Observable only when the duration Observable emits a value or completes. The completion of the notifier triggering the emission of the source value is deprecated behavior and will be removed in future versions.</source>
          <target state="translated">&lt;code&gt;delayWhen&lt;/code&gt; 当时间从源Observable发出的每个值偏移另一个Observable确定的时间跨度时。当源发出值时， &lt;code&gt;delayDurationSelector&lt;/code&gt; 源值作为参数调用delayDurationSelector函数，并且应返回一个Observable，称为&amp;ldquo; duration&amp;rdquo; Observable。仅当Observable持续时间发出值或完成时，才在输出Observable上发出源值。触发发出源值的通知程序的完成是不建议使用的行为，在以后的版本中将被删除。</target>
        </trans-unit>
        <trans-unit id="263c061588410725a4756688a261e25ff539d88a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dematerialize&lt;/code&gt; is assumed to operate an Observable that only emits &lt;a href=&quot;../index/class/notification&quot;&gt;&lt;code&gt;Notification&lt;/code&gt;&lt;/a&gt; objects as &lt;code&gt;next&lt;/code&gt; emissions, and does not emit any &lt;code&gt;error&lt;/code&gt;. Such Observable is the output of a &lt;code&gt;materialize&lt;/code&gt; operation. Those notifications are then unwrapped using the metadata they contain, and emitted as &lt;code&gt;next&lt;/code&gt;, &lt;code&gt;error&lt;/code&gt;, and &lt;code&gt;complete&lt;/code&gt; on the output Observable.</source>
          <target state="translated">&lt;code&gt;dematerialize&lt;/code&gt; 假定非实现操作一个Observable，该Observable仅作为 &lt;code&gt;next&lt;/code&gt; 发出对象发出&lt;a href=&quot;../index/class/notification&quot;&gt; &lt;code&gt;Notification&lt;/code&gt; &lt;/a&gt;对象，并且不发出任何 &lt;code&gt;error&lt;/code&gt; 。这样的Observable是 &lt;code&gt;materialize&lt;/code&gt; 操作的输出。然后，这些通知将使用它们包含的元数据进行解包，并作为 &lt;code&gt;next&lt;/code&gt; ， &lt;code&gt;error&lt;/code&gt; 发出，并在输出Observable上 &lt;code&gt;complete&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="337f0156035bbe32cb1c65689f5ceaab1523241c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;distinctUntilKeyChanged&lt;/code&gt; emits all items of the source Observable, wich are distinct by comparison. The comparison checks if the previous item is distinct from the current item, using a &lt;code&gt;key&lt;/code&gt; to access a property. If a comparator function is provided, then it will be called for each item with the property key to test for whether or not that value should be emitted.</source>
          <target state="translated">&lt;code&gt;distinctUntilKeyChanged&lt;/code&gt; 发出源Observable的所有项目，通过比较它们是不同的。比较使用 &lt;code&gt;key&lt;/code&gt; 访问属性，检查前一项是否与当前项不同。如果提供了比较器功能，则将使用属性键为每个项目调用该比较器功能，以测试是否应发出该值。</target>
        </trans-unit>
        <trans-unit id="c68787b081b8a13ef3a2883757212c65f8a16510" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;do&lt;/code&gt; -&amp;gt; &lt;code&gt;tap&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;do&lt;/code&gt; -&amp;gt; &lt;code&gt;tap&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7709400aa46a908f912c42fdd85c31afe4bd334c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;elementAt&lt;/code&gt; returns an Observable that emits the item at the specified &lt;code&gt;index&lt;/code&gt; in the source Observable, or a default value if that &lt;code&gt;index&lt;/code&gt; is out of range and the &lt;code&gt;default&lt;/code&gt; argument is provided. If the &lt;code&gt;default&lt;/code&gt; argument is not given and the &lt;code&gt;index&lt;/code&gt; is out of range, the output Observable will emit an &lt;code&gt;ArgumentOutOfRangeError&lt;/code&gt; error.</source>
          <target state="translated">&lt;code&gt;elementAt&lt;/code&gt; 返回一个Observable，该对象在源Observable 中的指定 &lt;code&gt;index&lt;/code&gt; 处发射该项目，如果该 &lt;code&gt;index&lt;/code&gt; 超出范围并且提供了 &lt;code&gt;default&lt;/code&gt; 参数，则返回一个默认值。如果未提供 &lt;code&gt;default&lt;/code&gt; 参数并且 &lt;code&gt;index&lt;/code&gt; 超出范围，则输出Observable将发出 &lt;code&gt;ArgumentOutOfRangeError&lt;/code&gt; 错误。</target>
        </trans-unit>
        <trans-unit id="48cd8a1eb0de7b3c8ccb7d3f4b8f0aab446953b1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;enum&lt;/code&gt;&lt;code&gt;deprecated&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;enum&lt;/code&gt;&lt;code&gt;deprecated&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="76ad9b9d842a773470337752107150337d51fd75" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;exhaust&lt;/code&gt; subscribes to an Observable that emits Observables, also known as a higher-order Observable. Each time it observes one of these emitted inner Observables, the output Observable begins emitting the items emitted by that inner Observable. So far, it behaves like &lt;a href=&quot;mergeall&quot;&gt;&lt;code&gt;mergeAll&lt;/code&gt;&lt;/a&gt;. However, &lt;code&gt;exhaust&lt;/code&gt; ignores every new inner Observable if the previous Observable has not yet completed. Once that one completes, it will accept and flatten the next inner Observable and repeat this process.</source>
          <target state="translated">&lt;code&gt;exhaust&lt;/code&gt; 订阅一个可发射Observable的Observable，也称为高阶Observable。每次观察到这些内部可观察对象发射的一个时，输出Observable便开始发射该内部可观察对象发射的项目。到目前为止，它的行为类似于&lt;a href=&quot;mergeall&quot;&gt; &lt;code&gt;mergeAll&lt;/code&gt; &lt;/a&gt;。但是，如果先前的Observable尚未完成，则 &lt;code&gt;exhaust&lt;/code&gt; 忽略每个新的内部Observable。完成后，它将接受并展平下一个内部Observable，并重复此过程。</target>
        </trans-unit>
        <trans-unit id="40ffb7c8fd558d6f81aaa088689dbebae17d57a6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expectObservable(actual: Observable&amp;lt;T&amp;gt;).toBe(marbles: string, values?: object, error?: any)&lt;/code&gt; - schedules an assertion for when the TestScheduler flushes. The TestScheduler will automatically flush at the end of your jasmine &lt;code&gt;it&lt;/code&gt; block.</source>
          <target state="translated">&lt;code&gt;expectObservable(actual: Observable&amp;lt;T&amp;gt;).toBe(marbles: string, values?: object, error?: any)&lt;/code&gt; -计划断言TestScheduler何时刷新。该TestScheduler会自动冲水为您茉莉结束 &lt;code&gt;it&lt;/code&gt; 封锁。</target>
        </trans-unit>
        <trans-unit id="549efb9322293515e99c072f635c335f7dea77ce" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expectObservable(actual: Observable&amp;lt;T&amp;gt;, subscriptionMarbles?: string).toBe(marbleDiagram: string, values?: object, error?: any)&lt;/code&gt; - schedules an assertion for when the TestScheduler flushes. Give &lt;code&gt;subscriptionMarbles&lt;/code&gt; as parameter to change the schedule of subscription and unsubscription. If you don't provide the &lt;code&gt;subscriptionMarbles&lt;/code&gt; parameter it will subscribe at the beginning and never unsubscribe. Read below about subscription marble diagram.</source>
          <target state="translated">&lt;code&gt;expectObservable(actual: Observable&amp;lt;T&amp;gt;, subscriptionMarbles?: string).toBe(marbleDiagram: string, values?: object, error?: any)&lt;/code&gt; -为TestScheduler刷新时安排断言。将 &lt;code&gt;subscriptionMarbles&lt;/code&gt; 作为参数来更改订阅和取消订阅的时间表。如果不提供 &lt;code&gt;subscriptionMarbles&lt;/code&gt; 参数，它将在开始时进行订阅，并且永远不会取消订阅。阅读以下有关订阅大理石图的信息。</target>
        </trans-unit>
        <trans-unit id="b7e81cef1adea62fe9dabc7f8970e2ecbcee0d1b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expectSubscriptions(actualSubscriptionLogs: SubscriptionLog[]).toBe(subscriptionMarbles: string)&lt;/code&gt; - like &lt;code&gt;expectObservable&lt;/code&gt; schedules an assertion for when the testScheduler flushes. Both &lt;code&gt;cold()&lt;/code&gt; and &lt;code&gt;hot()&lt;/code&gt; return an observable with a property &lt;code&gt;subscriptions&lt;/code&gt; of type &lt;code&gt;SubscriptionLog[]&lt;/code&gt;. Give &lt;code&gt;subscriptions&lt;/code&gt; as parameter to &lt;code&gt;expectSubscriptions&lt;/code&gt; to assert whether it matches the &lt;code&gt;subscriptionsMarbles&lt;/code&gt; marble diagram given in &lt;code&gt;toBe()&lt;/code&gt;. Subscription marble diagrams are slightly different than Observable marble diagrams. Read more below.</source>
          <target state="translated">&lt;code&gt;expectSubscriptions(actualSubscriptionLogs: SubscriptionLog[]).toBe(subscriptionMarbles: string)&lt;/code&gt; -就像 &lt;code&gt;expectObservable&lt;/code&gt; 计划何时刷新testScheduler的声明。两 &lt;code&gt;cold()&lt;/code&gt; 和 &lt;code&gt;hot()&lt;/code&gt; 返回一个可观察到的与属性 &lt;code&gt;subscriptions&lt;/code&gt; 类型的 &lt;code&gt;SubscriptionLog[]&lt;/code&gt; 。将 &lt;code&gt;subscriptions&lt;/code&gt; 作为参数提供给 &lt;code&gt;expectSubscriptions&lt;/code&gt; 以断言它是否与 &lt;code&gt;toBe()&lt;/code&gt; 中给出的 &lt;code&gt;subscriptionsMarbles&lt;/code&gt; 大理石图匹配。订阅大理石图与可观察大理石图略有不同。在下面阅读更多内容。</target>
        </trans-unit>
        <trans-unit id="468eda33598bc9af7354a4a5ba445b8895a6ac71" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;finally&lt;/code&gt; -&amp;gt; &lt;code&gt;finalize&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;finally&lt;/code&gt; -&amp;gt; &lt;code&gt;finalize&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="513a86951178ed9972ed24317636bd2a20645e11" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;find&lt;/code&gt; searches for the first item in the source Observable that matches the specified condition embodied by the &lt;code&gt;predicate&lt;/code&gt;, and returns the first occurrence in the source. Unlike &lt;a href=&quot;first&quot;&gt;&lt;code&gt;first&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;predicate&lt;/code&gt; is required in &lt;code&gt;find&lt;/code&gt;, and does not emit an error if a valid value is not found.</source>
          <target state="translated">&lt;code&gt;find&lt;/code&gt; 在源Observable中搜索与 &lt;code&gt;predicate&lt;/code&gt; 所体现的指定条件匹配的第一项，并在源中返回第一个匹配项。与&lt;a href=&quot;first&quot;&gt; &lt;code&gt;first&lt;/code&gt; &lt;/a&gt;不同， &lt;code&gt;predicate&lt;/code&gt; 在 &lt;code&gt;find&lt;/code&gt; 中是必需的，如果找不到有效值，则不会发出错误。</target>
        </trans-unit>
        <trans-unit id="42f3c71e5ee0b7b93c06c1bd1e67828f7bee0200" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;findIndex&lt;/code&gt; searches for the first item in the source Observable that matches the specified condition embodied by the &lt;code&gt;predicate&lt;/code&gt;, and returns the (zero-based) index of the first occurrence in the source. Unlike &lt;a href=&quot;first&quot;&gt;&lt;code&gt;first&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;predicate&lt;/code&gt; is required in &lt;code&gt;findIndex&lt;/code&gt;, and does not emit an error if a valid value is not found.</source>
          <target state="translated">&lt;code&gt;findIndex&lt;/code&gt; 在源Observable中搜索与 &lt;code&gt;predicate&lt;/code&gt; 所体现的指定条件匹配的第一项，并返回源中第一个匹配项的（从零开始的）索引。与&lt;a href=&quot;first&quot;&gt; &lt;code&gt;first&lt;/code&gt; &lt;/a&gt;不同， &lt;code&gt;predicate&lt;/code&gt; 在 &lt;code&gt;findIndex&lt;/code&gt; 中是必需的，如果找不到有效值，则不会发出错误。</target>
        </trans-unit>
        <trans-unit id="bbafc7127363c7baba3b13392ba68a2794417a48" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;flush()&lt;/code&gt; - immediately starts virtual time. Not often used since &lt;code&gt;run()&lt;/code&gt; will automatically flush for you when your callback returns, but in some cases you may wish to flush more than once or otherwise have more control.</source>
          <target state="translated">&lt;code&gt;flush()&lt;/code&gt; -立即开始虚拟时间。很少使用，因为 &lt;code&gt;run()&lt;/code&gt; 会在您的回调返回时自动为您刷新，但是在某些情况下，您可能希望刷新多次或拥有更多控制权。</target>
        </trans-unit>
        <trans-unit id="7a725c42c24e4558c24a6dceba8ebb231a13bba5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;forkJoin&lt;/code&gt; is an operator that takes any number of input observables which can be passed either as an array or a dictionary of input observables. If no input observables are provided, resulting stream will complete immediately.</source>
          <target state="translated">&lt;code&gt;forkJoin&lt;/code&gt; 是一个运算符，它接受任意数量的输入可观察值，这些输入可观察值可以作为数组或输入可观察值的字典传递。如果没有提供可观察的输入，则结果流将立即完成。</target>
        </trans-unit>
        <trans-unit id="7d066c42163ed51de74c8d0a23c6fbe14edf715a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;forkJoin&lt;/code&gt; will wait for all passed observables to complete and then it will emit an array or an object with last values from corresponding observables.</source>
          <target state="translated">&lt;code&gt;forkJoin&lt;/code&gt; 将等待所有传递的可观察变量完成，然后它将发出一个数组或一个对象，该数组或对象具有来自相应可观察变量的最后一个值。</target>
        </trans-unit>
        <trans-unit id="701b8bcaf7f433faa8857e32bc6ab6cb78a529cb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;from&lt;/code&gt; converts various other objects and data types into Observables. It also converts a Promise, an array-like, or an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterable&quot;&gt;iterable&lt;/a&gt; object into an Observable that emits the items in that promise, array, or iterable. A String, in this context, is treated as an array of characters. Observable-like objects (contains a function named with the ES2015 Symbol for Observable) can also be converted through this operator.</source>
          <target state="translated">&lt;code&gt;from&lt;/code&gt; 将各种其他对象和数据类型转换为Observable。它还将Promise，类似数组的对象或&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterable&quot;&gt;可迭代的&lt;/a&gt;对象转换为Observable，该对象发出该Promise，数组或可迭代的项。在这种情况下，字符串被视为字符数组。类似可观察对象的对象（包含以ES2015 Symbol for Observable命名的函数）也可以通过此运算符进行转换。</target>
        </trans-unit>
        <trans-unit id="f6cd47e56e386e34dc898b3c2f75f66f676fe304" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fromEvent&lt;/code&gt; accepts as a first argument event target, which is an object with methods for registering event handler functions. As a second argument it takes string that indicates type of event we want to listen for. &lt;code&gt;fromEvent&lt;/code&gt; supports selected types of event targets, which are described in detail below. If your event target does not match any of the ones listed, you should use &lt;a href=&quot;fromeventpattern&quot;&gt;&lt;code&gt;fromEventPattern&lt;/code&gt;&lt;/a&gt;, which can be used on arbitrary APIs. When it comes to APIs supported by &lt;code&gt;fromEvent&lt;/code&gt;, their methods for adding and removing event handler functions have different names, but they all accept a string describing event type and function itself, which will be called whenever said event happens.</source>
          <target state="translated">&lt;code&gt;fromEvent&lt;/code&gt; 接受事件目标作为第一个参数，该目标是具有注册事件处理程序函数的方法的对象。作为第二个参数，它使用指示我们要侦听的事件类型的字符串。 &lt;code&gt;fromEvent&lt;/code&gt; 支持选定的事件目标类型，下面将对其进行详细描述。如果您的事件目标与列出的目标不匹配，则应使用&lt;a href=&quot;fromeventpattern&quot;&gt; &lt;code&gt;fromEventPattern&lt;/code&gt; &lt;/a&gt;，它可以在任意API上使用。对于 &lt;code&gt;fromEvent&lt;/code&gt; 支持的API ，它们用于添加和删除事件处理程序函数的方法具有不同的名称，但是它们都接受描述事件类型和函数本身的字符串，只要发生上述事件，就会调用该字符串。</target>
        </trans-unit>
        <trans-unit id="1462671f1cb00bce6cf0a828bb7679536e52712a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fromEvent&lt;/code&gt; supports following types of event targets:</source>
          <target state="translated">&lt;code&gt;fromEvent&lt;/code&gt; 支持以下类型的事件目标：</target>
        </trans-unit>
        <trans-unit id="63e874687188bf84e0cd65512816c5a08aed1deb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fromEventPattern&lt;/code&gt; allows you to convert into an Observable any API that supports registering handler functions for events. It is similar to &lt;a href=&quot;fromevent&quot;&gt;&lt;code&gt;fromEvent&lt;/code&gt;&lt;/a&gt;, but far more flexible. In fact, all use cases of &lt;a href=&quot;fromevent&quot;&gt;&lt;code&gt;fromEvent&lt;/code&gt;&lt;/a&gt; could be easily handled by &lt;code&gt;fromEventPattern&lt;/code&gt; (although in slightly more verbose way).</source>
          <target state="translated">&lt;code&gt;fromEventPattern&lt;/code&gt; 允许您将任何支持注册事件处理程序功能的API转换为Observable。它类似于&lt;a href=&quot;fromevent&quot;&gt; &lt;code&gt;fromEvent&lt;/code&gt; &lt;/a&gt;，但是更加灵活。实际上，&lt;a href=&quot;fromevent&quot;&gt; &lt;code&gt;fromEvent&lt;/code&gt; Pattern&lt;/a&gt;可以轻松地处理 &lt;code&gt;fromEventPattern&lt;/code&gt; 所有用例（尽管稍微有些冗长）。</target>
        </trans-unit>
        <trans-unit id="0e7665a15f690a6c0179b0183091da0c68190f5a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;func.call()&lt;/code&gt; means &quot;&lt;em&gt;give me one value synchronously&lt;/em&gt;&quot;</source>
          <target state="translated">&lt;code&gt;func.call()&lt;/code&gt; 的意思是&amp;ldquo; &lt;em&gt;同步给我一个值&lt;/em&gt; &amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="8fe45d23f684b15638587a600e466d7276009066" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;function&lt;/code&gt;&lt;code&gt;deprecated&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;function&lt;/code&gt;&lt;code&gt;deprecated&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="81fd3bab51295b9b61c59cc065e6349a7f240f69" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;function&lt;/code&gt;&lt;code&gt;stable&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;function&lt;/code&gt;&lt;code&gt;stable&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d3ba75bfe8b6d2f7dad160fa84807c8529ff10b0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;generate&lt;/code&gt; allows you to create stream of values generated with a loop very similar to traditional for loop. First argument of &lt;code&gt;generate&lt;/code&gt; is a beginning value. Second argument is a function that accepts this value and tests if some condition still holds. If it does, loop continues, if not, it stops. Third value is a function which takes previously defined value and modifies it in some way on each iteration. Note how these three parameters are direct equivalents of three expressions in regular for loop: first expression initializes some state (for example numeric index), second tests if loop can make next iteration (for example if index is lower than 10) and third states how defined value will be modified on every step (index will be incremented by one).</source>
          <target state="translated">&lt;code&gt;generate&lt;/code&gt; 允许您创建使用循环生成的值流，该循环非常类似于传统的for循环。 &lt;code&gt;generate&lt;/code&gt; 的第一个参数是一个起始值。第二个参数是一个接受该值并测试是否仍然存在某些条件的函数。如果是这样，则循环继续，否则，循环停止。第三个值是一个函数，它采用先前定义的值，并在每次迭代时以某种方式对其进行修改。请注意，这三个参数如何与正则for循环中三个表达式的直接等效项：第一个表达式初始化某个状态（例如，数字索引），第二个测试循环是否可以进行下一次迭代（例如，如果索引小于10），第三个状态如何测试定义的值将在每一步上修改（索引将增加一）。</target>
        </trans-unit>
        <trans-unit id="94c16493b674e13437dfb3fd79fcd0ea9dff5d88" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hot('---#')&lt;/code&gt; will emit error &lt;code&gt;&quot;error&quot;&lt;/code&gt; whereas</source>
          <target state="translated">&lt;code&gt;hot('---#')&lt;/code&gt; 将发出错误 &lt;code&gt;&quot;error&quot;&lt;/code&gt; 而</target>
        </trans-unit>
        <trans-unit id="d6a2e8fa0c13885a147ad8101a000224f75f5e84" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hot('---#', null, new SpecialError('test'))&lt;/code&gt; will emit &lt;code&gt;new SpecialError('test')&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;hot('---#', null, new SpecialError('test'))&lt;/code&gt; 将发出 &lt;code&gt;new SpecialError('test')&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2911c19e5e499272edbb90d648b992bf10bf1534" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hot('--a--b')&lt;/code&gt; will emit &lt;code&gt;&quot;a&quot;&lt;/code&gt; and &lt;code&gt;&quot;b&quot;&lt;/code&gt; whereas</source>
          <target state="translated">&lt;code&gt;hot('--a--b')&lt;/code&gt; 将发出 &lt;code&gt;&quot;a&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;b&quot;&lt;/code&gt; 而</target>
        </trans-unit>
        <trans-unit id="799d6476abc1d323a6766cadbdeb1eaebd8adc4c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hot('--a--b', { a: 1, b: 2 })&lt;/code&gt; will emit &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;hot('--a--b', { a: 1, b: 2 })&lt;/code&gt; 将发出 &lt;code&gt;1&lt;/code&gt; 和 &lt;code&gt;2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="767983367cb68219511d69bc8f1151ae9e35c771" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hot(marbleDiagram: string, values?: object, error?: any)&lt;/code&gt; - creates a &lt;a href=&quot;https://medium.com/@benlesh/hot-vs-cold-observables-f8094ed53339&quot;&gt;&quot;hot&quot; observable&lt;/a&gt; (like a subject) that will behave as though it's already &quot;running&quot; when the test begins. An interesting difference is that &lt;code&gt;hot&lt;/code&gt; marbles allow a &lt;code&gt;^&lt;/code&gt; character to signal where the &quot;zero frame&quot; is. This is the default point at which the subscription to observables being tested begins, (this can be configured - see &lt;code&gt;expectObservable&lt;/code&gt; below).</source>
          <target state="translated">&lt;code&gt;hot(marbleDiagram: string, values?: object, error?: any)&lt;/code&gt; -创建一个&lt;a href=&quot;https://medium.com/@benlesh/hot-vs-cold-observables-f8094ed53339&quot;&gt;&amp;ldquo;热&amp;rdquo;观察到的&lt;/a&gt;（如主题），将表现得好像它已经&amp;ldquo;跑&amp;rdquo;测试开始时。一个有趣的区别是， &lt;code&gt;hot&lt;/code&gt; 弹珠允许 &lt;code&gt;^&lt;/code&gt; 字符表示&amp;ldquo;零帧&amp;rdquo;的位置。这是开始对要测试的 &lt;code&gt;expectObservable&lt;/code&gt; 进行预订的默认点（可以配置-请参见下面的ExpectObservable）。</target>
        </trans-unit>
        <trans-unit id="5a7962e956269eb833ec362893ebed3b1638a063" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hot(marbles: string, values?: object, error?: any)&lt;/code&gt; - creates a &quot;hot&quot; observable (a subject) that will behave as though it's already &quot;running&quot; when the test begins. An interesting difference is that &lt;code&gt;hot&lt;/code&gt; marbles allow a &lt;code&gt;^&lt;/code&gt; character to signal where the &quot;zero frame&quot; is. That is the point at which the subscription to observables being tested begins.</source>
          <target state="translated">&lt;code&gt;hot(marbles: string, values?: object, error?: any)&lt;/code&gt; -创建一个&amp;ldquo;热&amp;rdquo;可观察的对象（主题），其行为就像测试开始时已经在&amp;ldquo;运行&amp;rdquo;。一个有趣的区别是， &lt;code&gt;hot&lt;/code&gt; 弹珠允许使用 &lt;code&gt;^&lt;/code&gt; 字符表示&amp;ldquo;零帧&amp;rdquo;的位置。这就是开始订阅要测试的可观察对象的时间。</target>
        </trans-unit>
        <trans-unit id="0690d36fbdcb56b4f242b89d13ab4d0c31ca0bc5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;http.get()&lt;/code&gt; returns an Observable (of string or string arrays probably) for each individual URL. Now you have an Observables &lt;em&gt;of&lt;/em&gt; Observables, a higher-order Observable.</source>
          <target state="translated">&lt;code&gt;http.get()&lt;/code&gt; 为每个单独的URL返回一个Observable（可能是字符串或字符串数​​组）。现在您有了一个Observables &lt;em&gt;的&lt;/em&gt; Observables，一个更高阶的Observable。</target>
        </trans-unit>
        <trans-unit id="981ee7c6f5b4848e80c872e42d57f19bc3938e4e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;iif&lt;/code&gt; accepts a condition function and two Observables. When an Observable returned by the operator is subscribed, condition function will be called. Based on what boolean it returns at that moment, consumer will subscribe either to the first Observable (if condition was true) or to the second (if condition was false). Condition function may also not return anything - in that case condition will be evaluated as false and second Observable will be subscribed.</source>
          <target state="translated">&lt;code&gt;iif&lt;/code&gt; 接受条件函数和两个Observable。订阅操作员返回的Observable时，将调用条件函数。根据该时刻返回的布尔值，使用者将订阅第一个Observable（如果条件为true）或第二个Observable（如果条件为false）。条件函数也可能不返回任何内容-在这种情况下，条件将被评估为false，并且第二个Observable将被订阅。</target>
        </trans-unit>
        <trans-unit id="ff917215158e324736c1491962076002ae2685e6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;index&lt;/code&gt;: the (zero-based) &quot;index&quot; of the value from the source Observable.</source>
          <target state="translated">&lt;code&gt;index&lt;/code&gt; ：来自源Observable的值的（从零开始的）&amp;ldquo;索引&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="da2c4ef43d82866aae3c09d679912b62685d5d30" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;interface&lt;/code&gt;&lt;code&gt;stable&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;interface&lt;/code&gt;&lt;code&gt;stable&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c06c8243829ec012b90429a487f7f9de74dfe132" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;interval&lt;/code&gt; returns an Observable that emits an infinite sequence of ascending integers, with a constant interval of time of your choosing between those emissions. The first emission is not sent immediately, but only after the first period has passed. By default, this operator uses the &lt;code&gt;async&lt;/code&gt;&lt;a href=&quot;../interface/schedulerlike&quot;&gt;&lt;code&gt;SchedulerLike&lt;/code&gt;&lt;/a&gt; to provide a notion of time, but you may pass any &lt;a href=&quot;../interface/schedulerlike&quot;&gt;&lt;code&gt;SchedulerLike&lt;/code&gt;&lt;/a&gt; to it.</source>
          <target state="translated">&lt;code&gt;interval&lt;/code&gt; 返回一个Observable，它发射无限个递增整数序列，并在这些发射之间选择一个固定的时间间隔。第一次发射不会立即发送，而只会在第一个周期过去之后发送。默认情况下，该运算符使用 &lt;code&gt;async&lt;/code&gt; &lt;a href=&quot;../interface/schedulerlike&quot;&gt; &lt;code&gt;SchedulerLike&lt;/code&gt; &lt;/a&gt;提供时间概念，但是您可以将任何&lt;a href=&quot;../interface/schedulerlike&quot;&gt; &lt;code&gt;SchedulerLike&lt;/code&gt; &lt;/a&gt;传递给它。</target>
        </trans-unit>
        <trans-unit id="7aec19d4438c03177ae60e77c76f1deda18e1f69" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;isEmpty&lt;/code&gt; transforms an Observable that emits values into an Observable that emits a single boolean value representing whether or not any values were emitted by the source Observable. As soon as the source Observable emits a value, &lt;code&gt;isEmpty&lt;/code&gt; will emit a &lt;code&gt;false&lt;/code&gt; and complete. If the source Observable completes having not emitted anything, &lt;code&gt;isEmpty&lt;/code&gt; will emit a &lt;code&gt;true&lt;/code&gt; and complete.</source>
          <target state="translated">&lt;code&gt;isEmpty&lt;/code&gt; 将发出值的Observable转换为发出单个布尔值的Observable，该布尔值表示源Observable是否发出了任何值。一旦源Observable发出一个值， &lt;code&gt;isEmpty&lt;/code&gt; 将发出一个 &lt;code&gt;false&lt;/code&gt; 且完整。如果源Observable完成未发出任何内容，则 &lt;code&gt;isEmpty&lt;/code&gt; 将发出 &lt;code&gt;true&lt;/code&gt; 和完成。</target>
        </trans-unit>
        <trans-unit id="c31771f17b1d50d97171a9c911e381ff4519dabb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;materialize&lt;/code&gt; returns an Observable that emits a &lt;code&gt;next&lt;/code&gt; notification for each &lt;code&gt;next&lt;/code&gt;, &lt;code&gt;error&lt;/code&gt;, or &lt;code&gt;complete&lt;/code&gt; emission of the source Observable. When the source Observable emits &lt;code&gt;complete&lt;/code&gt;, the output Observable will emit &lt;code&gt;next&lt;/code&gt; as a Notification of type &quot;complete&quot;, and then it will emit &lt;code&gt;complete&lt;/code&gt; as well. When the source Observable emits &lt;code&gt;error&lt;/code&gt;, the output will emit &lt;code&gt;next&lt;/code&gt; as a Notification of type &quot;error&quot;, and then &lt;code&gt;complete&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;materialize&lt;/code&gt; 实体化返回一个Observable，它对源Observable的每个 &lt;code&gt;next&lt;/code&gt; ， &lt;code&gt;error&lt;/code&gt; 或 &lt;code&gt;complete&lt;/code&gt; 发射均发出 &lt;code&gt;next&lt;/code&gt; 通知。当源Observable发出 &lt;code&gt;complete&lt;/code&gt; 时， &lt;code&gt;next&lt;/code&gt; 将输出Observable输出作为类型为&amp;ldquo; complete&amp;rdquo;的Notification，然后也将发出 &lt;code&gt;complete&lt;/code&gt; 。当源Observable发出 &lt;code&gt;error&lt;/code&gt; ， &lt;code&gt;next&lt;/code&gt; 将作为&amp;ldquo;错误&amp;rdquo;类型的Notification 发出输出，然后 &lt;code&gt;complete&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a620a1dab62832d7036c018e55f712758cba7539" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;merge&lt;/code&gt; subscribes to each given input Observable (as arguments), and simply forwards (without doing any transformation) all the values from all the input Observables to the output Observable. The output Observable only completes once all input Observables have completed. Any error delivered by an input Observable will be immediately emitted on the output Observable.</source>
          <target state="translated">&lt;code&gt;merge&lt;/code&gt; 订阅每个给定的输入Observable（作为参数），并简单地将所有值从所有输入Observable转发（不进行任何转换）到输出Observable。仅当所有输入Observable完成后，输出Observable才完成。输入Observable传递的任何错误将立即在输出Observable上发出。</target>
        </trans-unit>
        <trans-unit id="59410dc6a24fddd12fdff9f08ed905e09d08d34c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mergeAll&lt;/code&gt; subscribes to an Observable that emits Observables, also known as a higher-order Observable. Each time it observes one of these emitted inner Observables, it subscribes to that and delivers all the values from the inner Observable on the output Observable. The output Observable only completes once all inner Observables have completed. Any error delivered by a inner Observable will be immediately emitted on the output Observable.</source>
          <target state="translated">&lt;code&gt;mergeAll&lt;/code&gt; 订阅一个可发射Observable的Observable，也称为高阶Observable。每次观察这些发出的内部Observable之一时，它都订阅该订阅，并在输出Observable上传递来自内部Observable的所有值。仅当所有内部Observable完成后，输出Observable才完成。内部Observable传递的任何错误将立即在输出Observable上发出。</target>
        </trans-unit>
        <trans-unit id="777683b7cfdd5857d651bddab3fd9e125e6cb74e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;multicast&lt;/code&gt; returns an Observable that looks like a normal Observable, but works like a Subject when it comes to subscribing. &lt;code&gt;multicast&lt;/code&gt; returns a &lt;code&gt;ConnectableObservable&lt;/code&gt;, which is simply an Observable with the &lt;code&gt;connect()&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;multicast&lt;/code&gt; 返回的Observable看起来像普通的Observable，但是在订阅时却像Subject一样工作。 &lt;code&gt;multicast&lt;/code&gt; 返回一个 &lt;code&gt;ConnectableObservable&lt;/code&gt; ，使用 &lt;code&gt;connect()&lt;/code&gt; 方法只是一个Observable 。</target>
        </trans-unit>
        <trans-unit id="5f5b38c7d5c43ed1d44d70a0d42babaf3da2c27d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;observable.subscribe()&lt;/code&gt; means &quot;&lt;em&gt;give me any amount of values, either synchronously or asynchronously&lt;/em&gt;&quot;</source>
          <target state="translated">&lt;code&gt;observable.subscribe()&lt;/code&gt; 的意思是&amp;ldquo; &lt;em&gt;给我同步或异步提供的任意数量的值&lt;/em&gt; &amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="5a554e609492cca8c57b2a0aecc84d1057a5aac3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;observeOn&lt;/code&gt; is an operator that accepts a scheduler as a first parameter, which will be used to reschedule notifications emitted by the source Observable. It might be useful, if you do not have control over internal scheduler of a given Observable, but want to control when its values are emitted nevertheless.</source>
          <target state="translated">&lt;code&gt;observeOn&lt;/code&gt; 是一个接受调度程序作为第一个参数的运算符，它将用于重新调度源Observable发出的通知。如果您无法控制给定Observable的内部调度程序，但是想要控制何时发出其值，则这可能会很有用。</target>
        </trans-unit>
        <trans-unit id="d1994390fee01ea975c48bfe909a4072be3d883a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onErrorResumeNext&lt;/code&gt; Will subscribe to each observable source it is provided, in order. If the source it's subscribed to emits an error or completes, it will move to the next source without error.</source>
          <target state="translated">&lt;code&gt;onErrorResumeNext&lt;/code&gt; 将按顺序订阅提供的每个可观察源。如果其订阅的源发出错误或完成，它将无误地移至下一个源。</target>
        </trans-unit>
        <trans-unit id="ef16d58131c642abbfab0c592384eafb6f227b95" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onErrorResumeNext&lt;/code&gt; can be therefore thought of as version of &lt;a href=&quot;../index/function/concat&quot;&gt;&lt;code&gt;concat&lt;/code&gt;&lt;/a&gt; operator, which is more permissive when it comes to the errors emitted by its input Observables. While &lt;code&gt;concat&lt;/code&gt; subscribes to the next Observable in series only if previous one successfully completed, &lt;code&gt;onErrorResumeNext&lt;/code&gt; subscribes even if it ended with an error.</source>
          <target state="translated">&lt;code&gt;onErrorResumeNext&lt;/code&gt; 因此，可以将onErrorResumeNext视为&lt;a href=&quot;../index/function/concat&quot;&gt; &lt;code&gt;concat&lt;/code&gt; &lt;/a&gt;运算符的版本，当涉及其输入Observables发出的错误时，它更为宽松。虽然 &lt;code&gt;concat&lt;/code&gt; 仅在成功完成前一个Observable时才预订下一个Observable系列，但 &lt;code&gt;onErrorResumeNext&lt;/code&gt; 也会预订，即使它以错误结束。</target>
        </trans-unit>
        <trans-unit id="291e2549ced3cc796e330b6fc2231a429b9e5349" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onErrorResumeNext&lt;/code&gt; is an operator that accepts a series of Observables, provided either directly as arguments or as an array. If no single Observable is provided, returned Observable will simply behave the same as the source.</source>
          <target state="translated">&lt;code&gt;onErrorResumeNext&lt;/code&gt; 是一个运算符，它接受一系列Observable，它们直接作为参数或数组提供。如果没有提供单个Observable，则返回的Observable的行为将与源相同。</target>
        </trans-unit>
        <trans-unit id="1dd5ccaf3fba11c911848593b79d46ec1794b960" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onErrorResumeNext&lt;/code&gt; is basically &lt;a href=&quot;concat&quot;&gt;&lt;code&gt;concat&lt;/code&gt;&lt;/a&gt;, only it will continue, even if one of its sources emits an error.</source>
          <target state="translated">&lt;code&gt;onErrorResumeNext&lt;/code&gt; 基本上是&lt;a href=&quot;concat&quot;&gt; &lt;code&gt;concat&lt;/code&gt; &lt;/a&gt;，即使它的源之一发出错误，它也将继续。</target>
        </trans-unit>
        <trans-unit id="ff80ad62141e00cd2add9d085cf99cc33cc90177" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onErrorResumeNext&lt;/code&gt; returns an Observable that starts by subscribing and re-emitting values from the source Observable. When its stream of values ends - no matter if Observable completed or emitted an error - &lt;code&gt;onErrorResumeNext&lt;/code&gt; will subscribe to the first Observable that was passed as an argument to the method. It will start re-emitting its values as well and - again - when that stream ends, &lt;code&gt;onErrorResumeNext&lt;/code&gt; will proceed to subscribing yet another Observable in provided series, no matter if previous Observable completed or ended with an error. This will be happening until there is no more Observables left in the series, at which point returned Observable will complete - even if the last subscribed stream ended with an error.</source>
          <target state="translated">&lt;code&gt;onErrorResumeNext&lt;/code&gt; 返回一个Observable，该Observable首先从源Observable订阅并重新发送值。当其值流结束时-无论Observable完成还是发出错误 &lt;code&gt;onErrorResumeNext&lt;/code&gt; 都将订阅第一个作为参数传递给该方法的Observable。它也将开始重新发射其值，并且-再次-当该流结束时，无论先前的Observable是完成还是以错误结束， &lt;code&gt;onErrorResumeNext&lt;/code&gt; 将继续订阅所提供系列中的另一个Observable。这将一直发生，直到系列中没有更多的Observable为止，此时返回的Observable将完成-即使最后一个订阅的流以错误结尾。</target>
        </trans-unit>
        <trans-unit id="1c9b05342b9557c75c17b290cebc80a1b1e3220f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pairs&lt;/code&gt; takes an arbitrary object and returns an Observable that emits arrays. Each emitted array has exactly two elements - the first is a key from the object and the second is a value corresponding to that key. Keys are extracted from an object via &lt;code&gt;Object.keys&lt;/code&gt; function, which means that they will be only enumerable keys that are present on an object directly - not ones inherited via prototype chain.</source>
          <target state="translated">&lt;code&gt;pairs&lt;/code&gt; 可以接受任意对象，并返回发出数组的Observable。每个发出的数组都有正好两个元素-第一个是对象的键，第二个是与该键对应的值。密钥是通过 &lt;code&gt;Object.keys&lt;/code&gt; 函数从对象中提取的，这意味着它们将仅是直接存在于对象上的可枚举的密钥，而不是通过原型链继承的密钥。</target>
        </trans-unit>
        <trans-unit id="4f6fdfa42f667cfba7439d1f21478f14b5582463" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;partition&lt;/code&gt; outputs an array with two Observables that partition the values from the source Observable through the given &lt;code&gt;predicate&lt;/code&gt; function. The first Observable in that array emits source values for which the predicate argument returns true. The second Observable emits source values for which the predicate returns false. The first behaves like &lt;a href=&quot;../../operators/filter&quot;&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/a&gt; and the second behaves like &lt;a href=&quot;../../operators/filter&quot;&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/a&gt; with the predicate negated.</source>
          <target state="translated">&lt;code&gt;partition&lt;/code&gt; 输出带有两个Observable的数组，该数组通过给定的 &lt;code&gt;predicate&lt;/code&gt; 函数对源Observable中的值进行分区。该数组中的第一个Observable发出源值，谓词参数对其返回true。第二个Observable发出谓词返回false的源值。第一个行为类似于&lt;a href=&quot;../../operators/filter&quot;&gt; &lt;code&gt;filter&lt;/code&gt; &lt;/a&gt;，第二个行为类似于&lt;a href=&quot;../../operators/filter&quot;&gt; &lt;code&gt;filter&lt;/code&gt; &lt;/a&gt;，谓词为否定。</target>
        </trans-unit>
        <trans-unit id="29b0a69077ab704f04ffa917a9190d5c068cb61d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;partition&lt;/code&gt; outputs an array with two Observables that partition the values from the source Observable through the given &lt;code&gt;predicate&lt;/code&gt; function. The first Observable in that array emits source values for which the predicate argument returns true. The second Observable emits source values for which the predicate returns false. The first behaves like &lt;a href=&quot;filter&quot;&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/a&gt; and the second behaves like &lt;a href=&quot;filter&quot;&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/a&gt; with the predicate negated.</source>
          <target state="translated">&lt;code&gt;partition&lt;/code&gt; 输出带有两个Observable的数组，该数组通过给定的 &lt;code&gt;predicate&lt;/code&gt; 函数对源Observable中的值进行分区。该数组中的第一个Observable发出源值，谓词参数对其返回true。第二个Observable发出谓词返回false的源值。第一个行为类似于&lt;a href=&quot;filter&quot;&gt; &lt;code&gt;filter&lt;/code&gt; &lt;/a&gt;，第二个行为类似于&lt;a href=&quot;filter&quot;&gt; &lt;code&gt;filter&lt;/code&gt; &lt;/a&gt;，谓词为否定。</target>
        </trans-unit>
        <trans-unit id="d757360aa9c33465dd08a4b49ea5c09adbe8789e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;queue&lt;/code&gt; scheduler, when used with delay, behaves the same as &lt;a href=&quot;asyncscheduler&quot;&gt;&lt;code&gt;async&lt;/code&gt;&lt;/a&gt; scheduler.</source>
          <target state="translated">&lt;code&gt;queue&lt;/code&gt; 调度程序与延迟一起使用时，其行为与&lt;a href=&quot;asyncscheduler&quot;&gt; &lt;code&gt;async&lt;/code&gt; &lt;/a&gt;调度程序相同。</target>
        </trans-unit>
        <trans-unit id="17fdff06ac58fc951a7149d674b80a48d8ad8290" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;range&lt;/code&gt; operator emits a range of sequential integers, in order, where you select the &lt;code&gt;start&lt;/code&gt; of the range and its &lt;code&gt;length&lt;/code&gt;. By default, uses no &lt;a href=&quot;../interface/schedulerlike&quot;&gt;&lt;code&gt;SchedulerLike&lt;/code&gt;&lt;/a&gt; and just delivers the notifications synchronously, but may use an optional &lt;a href=&quot;../interface/schedulerlike&quot;&gt;&lt;code&gt;SchedulerLike&lt;/code&gt;&lt;/a&gt; to regulate those deliveries.</source>
          <target state="translated">&lt;code&gt;range&lt;/code&gt; 运算符按顺序发出一定范围的连续整数，您可以在其中选择范围的 &lt;code&gt;start&lt;/code&gt; 及其 &lt;code&gt;length&lt;/code&gt; 。默认情况下，不使用&lt;a href=&quot;../interface/schedulerlike&quot;&gt; &lt;code&gt;SchedulerLike&lt;/code&gt; ,&lt;/a&gt;而只是同步传递通知，但可以使用可选的&lt;a href=&quot;../interface/schedulerlike&quot;&gt; &lt;code&gt;SchedulerLike&lt;/code&gt; &lt;/a&gt;来调节这些传递。</target>
        </trans-unit>
        <trans-unit id="2e22b100da74aa12e2c1daa7b8100c2dbf04c3dd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;refCount&lt;/code&gt; makes the multicasted Observable automatically start executing when the first subscriber arrives, and stop executing when the last subscriber leaves.</source>
          <target state="translated">&lt;code&gt;refCount&lt;/code&gt; 使多播的Observable在第一个订户到达时自动开始执行，并在最后一个订户离开时停止执行。</target>
        </trans-unit>
        <trans-unit id="7dbccc612f4b41c939a27316ce2aa6e8a76a4022" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sampleTime&lt;/code&gt; periodically looks at the source Observable and emits whichever value it has most recently emitted since the previous sampling, unless the source has not emitted anything since the previous sampling. The sampling happens periodically in time every &lt;code&gt;period&lt;/code&gt; milliseconds (or the time unit defined by the optional &lt;code&gt;scheduler&lt;/code&gt; argument). The sampling starts as soon as the output Observable is subscribed.</source>
          <target state="translated">&lt;code&gt;sampleTime&lt;/code&gt; 定期查看源Observable 并发出自上一次采样以来其最近发出的值，除非该源自上次采样以来未发出任何东西。采样会在每个 &lt;code&gt;period&lt;/code&gt; 毫秒（或由可选 &lt;code&gt;scheduler&lt;/code&gt; 参数定义的时间单位）的时间周期内定期进行。订阅输出Observable后，便开始采样。</target>
        </trans-unit>
        <trans-unit id="d5980710dadf7c9ae58853275ba85eaf3881bd1e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sequenceEqual&lt;/code&gt; subscribes to two observables and buffers incoming values from each observable. Whenever either observable emits a value, the value is buffered and the buffers are shifted and compared from the bottom up; If any value pair doesn't match, the returned observable will emit &lt;code&gt;false&lt;/code&gt; and complete. If one of the observables completes, the operator will wait for the other observable to complete; If the other observable emits before completing, the returned observable will emit &lt;code&gt;false&lt;/code&gt; and complete. If one observable never completes or emits after the other complets, the returned observable will never complete.</source>
          <target state="translated">&lt;code&gt;sequenceEqual&lt;/code&gt; 订阅两个可观察变量，并缓冲每个可观察变量的传入值。只要可观察到的任何一个发出一个值，就对该值进行缓冲，并从下至上对缓冲区进行移位和比较；如果任何值对不匹配，则返回的observable将发出 &lt;code&gt;false&lt;/code&gt; 和complete。如果其中一个可观察物完成，操作员将等待另一个可观察物完成；如果另一个Observable在完成之前发出，则返回的Observable将发出 &lt;code&gt;false&lt;/code&gt; 和complete。如果一个可观测对象永远不会完成或在其他完成之后发出，则返回的可观测对象将永远不会完成。</target>
        </trans-unit>
        <trans-unit id="4f58d2f8563d7e3159c6ebb8ebafb1de8e6d7489" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;skipLast&lt;/code&gt; returns an Observable that accumulates a queue with a length enough to store the first &lt;code&gt;count&lt;/code&gt; values. As more values are received, values are taken from the front of the queue and produced on the result sequence. This causes values to be delayed.</source>
          <target state="translated">&lt;code&gt;skipLast&lt;/code&gt; 返回一个Observable，它累积一个长度足以存储第一个 &lt;code&gt;count&lt;/code&gt; 数值的队列。当接收到更多的值时，将从队列的前面获取值并在结果序列上产生这些值。这导致值被延迟。</target>
        </trans-unit>
        <trans-unit id="4dfa14c602b33dade952c18426ddaa9fa684801b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;source&lt;/code&gt;: the source Observable instance itself.</source>
          <target state="translated">&lt;code&gt;source&lt;/code&gt; ：源Observable实例本身。</target>
        </trans-unit>
        <trans-unit id="1b4b0818cfe231af3c058ff8b49a57db0d1c71e5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;subscribe&lt;/code&gt; is not a regular operator, but a method that calls Observable's internal &lt;code&gt;subscribe&lt;/code&gt; function. It might be for example a function that you passed to Observable's constructor, but most of the time it is a library implementation, which defines what will be emitted by an Observable, and when it be will emitted. This means that calling &lt;code&gt;subscribe&lt;/code&gt; is actually the moment when Observable starts its work, not when it is created, as it is often the thought.</source>
          <target state="translated">&lt;code&gt;subscribe&lt;/code&gt; 不是常规运算符，而是调用Observable的内部 &lt;code&gt;subscribe&lt;/code&gt; 函数的方法。例如，它可能是传递给Observable的构造函数的函数，但在大多数情况下，它是一个库实现，它定义了Observable将发出的内容以及何时发出。这意味着调用 &lt;code&gt;subscribe&lt;/code&gt; 实际上是Observable开始工作的时刻，而不是通常创建的时刻。</target>
        </trans-unit>
        <trans-unit id="7b11a8ddb4b29050c92924f7c707c9f383b4539d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;switch&lt;/code&gt; -&amp;gt; &lt;code&gt;switchAll&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;switch&lt;/code&gt; -&amp;gt; &lt;code&gt;switchAll&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="42f30fe54a88e73cf07d5e7dde80265a6018d9c1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;switchAll&lt;/code&gt; subscribes to a source that is an observable of observables, also known as a &quot;higher-order observable&quot; (or &lt;code&gt;Observable&amp;lt;Observable&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;). It subscribes to the most recently provided &quot;inner observable&quot; emitted by the source, unsubscribing from any previously subscribed to inner observable, such that only the most recent inner observable may be subscribed to at any point in time. The resulting observable returned by &lt;code&gt;switchAll&lt;/code&gt; will only complete if the source observable completes, &lt;em&gt;and&lt;/em&gt; any currently subscribed to inner observable also has completed, if there are any.</source>
          <target state="translated">&lt;code&gt;switchAll&lt;/code&gt; 订阅一个可观察的可观察对象的源，也称为&amp;ldquo;高阶可观察的对象&amp;rdquo;（或 &lt;code&gt;Observable&amp;lt;Observable&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; ）。它订阅源发出的最新提供的&amp;ldquo;内部可观察的&amp;rdquo;，取消订阅任何先前订阅的内部可观察的，因此在任何时间点只能订阅最新的内部可观察的。 &lt;code&gt;switchAll&lt;/code&gt; 返回的结果可观察对象只有在源可观察对象完成&lt;em&gt;并且&lt;/em&gt;当前订阅的内部可观察对象也已完成（如果有）的情况下才能完成。</target>
        </trans-unit>
        <trans-unit id="69dd20bf2331adf056c62cc0c41f4a92f233c680" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;take&lt;/code&gt; returns an Observable that emits only the first &lt;code&gt;count&lt;/code&gt; values emitted by the source Observable. If the source emits fewer than &lt;code&gt;count&lt;/code&gt; values then all of its values are emitted. After that, it completes, regardless if the source completes.</source>
          <target state="translated">&lt;code&gt;take&lt;/code&gt; 返回一个Observable，它仅发出源Observable 发出的第一个 &lt;code&gt;count&lt;/code&gt; 数值。如果源发出的 &lt;code&gt;count&lt;/code&gt; 数值少于计数值，则将发出其所有值。之后，无论源是否完成，它都会完成。</target>
        </trans-unit>
        <trans-unit id="e0d3558cc44022c2e8684d41349bf690ef45ad6d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;takeLast&lt;/code&gt; returns an Observable that emits at most the last &lt;code&gt;count&lt;/code&gt; values emitted by the source Observable. If the source emits fewer than &lt;code&gt;count&lt;/code&gt; values then all of its values are emitted. This operator must wait until the &lt;code&gt;complete&lt;/code&gt; notification emission from the source in order to emit the &lt;code&gt;next&lt;/code&gt; values on the output Observable, because otherwise it is impossible to know whether or not more values will be emitted on the source. For this reason, all values are emitted synchronously, followed by the complete notification.</source>
          <target state="translated">&lt;code&gt;takeLast&lt;/code&gt; 返回一个Observable，它最多发出源Observable发出的最后一个 &lt;code&gt;count&lt;/code&gt; 数值。如果源发出的 &lt;code&gt;count&lt;/code&gt; 数值少于计数值，则将发出其所有值。该操作员必须等到从源发出 &lt;code&gt;complete&lt;/code&gt; 通知后，才能在输出Observable上发出 &lt;code&gt;next&lt;/code&gt; 值，因为否则将无法知道是否将在源上发出更多的值。因此，所有值都将同步发出，然后发出完整的通知。</target>
        </trans-unit>
        <trans-unit id="a41e94110409f4ba43cb9c3758b60c921ba32bbd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;takeUntil&lt;/code&gt; subscribes and begins mirroring the source Observable. It also monitors a second Observable, &lt;code&gt;notifier&lt;/code&gt; that you provide. If the &lt;code&gt;notifier&lt;/code&gt; emits a value, the output Observable stops mirroring the source Observable and completes. If the &lt;code&gt;notifier&lt;/code&gt; doesn't emit any value and completes then &lt;code&gt;takeUntil&lt;/code&gt; will pass all values.</source>
          <target state="translated">&lt;code&gt;takeUntil&lt;/code&gt; 订阅并开始镜像源Observable。它还监视您提供的第二个Observable &lt;code&gt;notifier&lt;/code&gt; 程序。如果 &lt;code&gt;notifier&lt;/code&gt; 发出值，则输出Observable停止镜像源Observable并完成。如果 &lt;code&gt;notifier&lt;/code&gt; 未发出任何值并完成，则 &lt;code&gt;takeUntil&lt;/code&gt; 将传递所有值。</target>
        </trans-unit>
        <trans-unit id="4a230ff2a0b2808f0225be3b8c769a658194b52c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;takeWhile&lt;/code&gt; subscribes and begins mirroring the source Observable. Each value emitted on the source is given to the &lt;code&gt;predicate&lt;/code&gt; function which returns a boolean, representing a condition to be satisfied by the source values. The output Observable emits the source values until such time as the &lt;code&gt;predicate&lt;/code&gt; returns false, at which point &lt;code&gt;takeWhile&lt;/code&gt; stops mirroring the source Observable and completes the output Observable.</source>
          <target state="translated">&lt;code&gt;takeWhile&lt;/code&gt; 订阅并开始镜像源Observable。源上发出的每个值都给 &lt;code&gt;predicate&lt;/code&gt; 函数，该函数返回一个布尔值，表示源值要满足的条件。输出Observable发出源值，直到 &lt;code&gt;predicate&lt;/code&gt; 返回false 为止，此时 &lt;code&gt;takeWhile&lt;/code&gt; 停止镜像源Observable并完成输出Observable。</target>
        </trans-unit>
        <trans-unit id="893d4d7f1c2faad041677d314bbceaa20ca07709" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;throttle&lt;/code&gt; emits the source Observable values on the output Observable when its internal timer is disabled, and ignores source values when the timer is enabled. Initially, the timer is disabled. As soon as the first source value arrives, it is forwarded to the output Observable, and then the timer is enabled by calling the &lt;code&gt;durationSelector&lt;/code&gt; function with the source value, which returns the &quot;duration&quot; Observable. When the duration Observable emits a value or completes, the timer is disabled, and this process repeats for the next source value.</source>
          <target state="translated">&lt;code&gt;throttle&lt;/code&gt; 在禁用内部计时器时会在输出Observable上发出源Observable值，并在启用计时器时忽略源值。最初，计时器被禁用。第一个源值到达后，立即将其转发到输出Observable，然后通过使用源值调用 &lt;code&gt;durationSelector&lt;/code&gt; 函数来启用计时器，该函数将返回&amp;ldquo; duration&amp;rdquo; Observable。当Observable持续时间发出值或完成时，计时器将被禁用，并且此过程将为下一个源值重复。</target>
        </trans-unit>
        <trans-unit id="ed9390044a64b750cabefbab7627d762696a0957" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;throttleTime&lt;/code&gt; emits the source Observable values on the output Observable when its internal timer is disabled, and ignores source values when the timer is enabled. Initially, the timer is disabled. As soon as the first source value arrives, it is forwarded to the output Observable, and then the timer is enabled. After &lt;code&gt;duration&lt;/code&gt; milliseconds (or the time unit determined internally by the optional &lt;code&gt;scheduler&lt;/code&gt;) has passed, the timer is disabled, and this process repeats for the next source value. Optionally takes a &lt;a href=&quot;../index/interface/schedulerlike&quot;&gt;&lt;code&gt;SchedulerLike&lt;/code&gt;&lt;/a&gt; for managing timers.</source>
          <target state="translated">&lt;code&gt;throttleTime&lt;/code&gt; 发射源可观测值的输出可观察时其内部定时器被禁止，并且启用定时器时将忽略源值。最初，计时器被禁用。第一个源值到达后，立即将其转发到输出Observable，然后启用计时器。经过 &lt;code&gt;duration&lt;/code&gt; 毫秒（或由可选 &lt;code&gt;scheduler&lt;/code&gt; 内部确定的时间单位）后，计时器将被禁用，并且此过程将针对下一个源值重复进行。（可选）采用&lt;a href=&quot;../index/interface/schedulerlike&quot;&gt; &lt;code&gt;SchedulerLike&lt;/code&gt; &lt;/a&gt;来管理计时器。</target>
        </trans-unit>
        <trans-unit id="837bf2907a5094046aef9c509d4b9c80692617d0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timeout&lt;/code&gt; accepts also a Scheduler as a second parameter. It is used to schedule moment (or moments) when returned Observable will check if source stream emitted value or completed.</source>
          <target state="translated">&lt;code&gt;timeout&lt;/code&gt; 还接受调度程序作为第二个参数。它用于计划返回的时刻（或多个时刻）。Observable将检查源流是否发出了值或已完成。</target>
        </trans-unit>
        <trans-unit id="4a7dc88dd8ca560076bef8f42aecb45980ad1c4b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timeout&lt;/code&gt; operator accepts as an argument either a number or a Date.</source>
          <target state="translated">&lt;code&gt;timeout&lt;/code&gt; 运算符接受数字或日期作为参数。</target>
        </trans-unit>
        <trans-unit id="9434e63eff4482ecfbfd0ab90266a6145b5d0017" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timeoutWith&lt;/code&gt; is a variation of &lt;code&gt;timeout&lt;/code&gt; operator. It behaves exactly the same, still accepting as a first argument either a number or a Date, which control - respectively - when values of source Observable should be emitted or when it should complete.</source>
          <target state="translated">&lt;code&gt;timeoutWith&lt;/code&gt; 是 &lt;code&gt;timeout&lt;/code&gt; 运算符的一种变体。它的行为完全相同，仍然接受数字或日期作为第一个参数，它们分别控制何时应发出源Observable的值或何时完成。</target>
        </trans-unit>
        <trans-unit id="4710700c6f8e512d7c421a3fa66ab6a55bd22c59" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timer&lt;/code&gt; returns an Observable that emits an infinite sequence of ascending integers, with a constant interval of time, &lt;code&gt;period&lt;/code&gt; of your choosing between those emissions. The first emission happens after the specified &lt;code&gt;dueTime&lt;/code&gt;. The initial delay may be a &lt;code&gt;Date&lt;/code&gt;. By default, this operator uses the &lt;a href=&quot;../const/asyncscheduler&quot;&gt;&lt;code&gt;async&lt;/code&gt;&lt;/a&gt;&lt;a href=&quot;../interface/schedulerlike&quot;&gt;&lt;code&gt;SchedulerLike&lt;/code&gt;&lt;/a&gt; to provide a notion of time, but you may pass any &lt;a href=&quot;../interface/schedulerlike&quot;&gt;&lt;code&gt;SchedulerLike&lt;/code&gt;&lt;/a&gt; to it. If &lt;code&gt;period&lt;/code&gt; is not specified, the output Observable emits only one value, &lt;code&gt;0&lt;/code&gt;. Otherwise, it emits an infinite sequence.</source>
          <target state="translated">&lt;code&gt;timer&lt;/code&gt; 返回一个可观察发射升序的整数的无限序列，随时间以恒定的间隔， &lt;code&gt;period&lt;/code&gt; 这些排放之间的选择的。第一次发射发生在指定的 &lt;code&gt;dueTime&lt;/code&gt; 之后。初始延迟可能是 &lt;code&gt;Date&lt;/code&gt; 。默认情况下，该运算符使用&lt;a href=&quot;../const/asyncscheduler&quot;&gt; &lt;code&gt;async&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;../interface/schedulerlike&quot;&gt; &lt;code&gt;SchedulerLike&lt;/code&gt; &lt;/a&gt;提供时间概念，但是您可以将任何&lt;a href=&quot;../interface/schedulerlike&quot;&gt; &lt;code&gt;SchedulerLike&lt;/code&gt; &lt;/a&gt;传递给它。如果未指定 &lt;code&gt;period&lt;/code&gt; ，则输出Observable仅发出一个值 &lt;code&gt;0&lt;/code&gt; 。否则，它将发出无限序列。</target>
        </trans-unit>
        <trans-unit id="5d336ba47502080cf68f8a6221d7a484097c3e86" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toArray&lt;/code&gt; will wait until the source Observable completes before emitting the array containing all emissions. When the source Observable errors no array will be emitted.</source>
          <target state="translated">&lt;code&gt;toArray&lt;/code&gt; 将等到源Observable完成之前，才发出包含所有发射的数组。当源可观察到错误时，将不会发出任何数组。</target>
        </trans-unit>
        <trans-unit id="882041f58c61297d3bc52474672369483f237e67" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;type-alias&lt;/code&gt;&lt;code&gt;deprecated&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;type-alias&lt;/code&gt;&lt;code&gt;deprecated&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c1be2711a1aca94a2a1d5e62e346824e0545d42d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;type-alias&lt;/code&gt;&lt;code&gt;stable&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;type-alias&lt;/code&gt;&lt;code&gt;stable&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d345979c928da012a70daaf3ad24a52650157db4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;using&lt;/code&gt; is a factory operator, which accepts two functions. First function returns a disposable resource. It can be an arbitrary object that implements &lt;code&gt;unsubscribe&lt;/code&gt; method. Second function will be injected with that object and should return an Observable. That Observable can use resource object during its execution. Both functions passed to &lt;code&gt;using&lt;/code&gt; will be called every time someone subscribes - neither an Observable nor resource object will be shared in any way between subscriptions.</source>
          <target state="translated">&lt;code&gt;using&lt;/code&gt; 是工厂操作员，它接受两个功能。第一个函数返回一个一次性资源。它可以是实现 &lt;code&gt;unsubscribe&lt;/code&gt; 方法的任意对象。第二个函数将与该对象一起注入，并应返回一个Observable。该Observable可以在其执行期间使用资源对象。每当有人订阅时，传递给 &lt;code&gt;using&lt;/code&gt; 的这两个函数都会被调用-订阅之间不会以任何方式共享Observable对象或资源对象。</target>
        </trans-unit>
        <trans-unit id="61103ee33a8a3cb94239d307c3afbd3dc50159b4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;value&lt;/code&gt;: the value from the source Observable.</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; ：来自源Observable的值。</target>
        </trans-unit>
        <trans-unit id="9bd5b9326ee02528186bb1b60e87af552140ef37" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;void&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;void&lt;/code&gt;:</target>
        </trans-unit>
        <trans-unit id="31d672942033870f817236e058621cb34ad12098" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;webSocket&lt;/code&gt; is a factory function that produces a &lt;code&gt;WebSocketSubject&lt;/code&gt;, which can be used to make WebSocket connection with an arbitrary endpoint. &lt;code&gt;webSocket&lt;/code&gt; accepts as an argument either a string with url of WebSocket endpoint, or an &lt;a href=&quot;websocketsubjectconfig&quot;&gt;&lt;code&gt;WebSocketSubjectConfig&lt;/code&gt;&lt;/a&gt; object for providing additional configuration, as well as Observers for tracking lifecycle of WebSocket connection.</source>
          <target state="translated">&lt;code&gt;webSocket&lt;/code&gt; 是一个工厂函数，它生成 &lt;code&gt;WebSocketSubject&lt;/code&gt; ，可用于建立与任意端点的WebSocket连接。 &lt;code&gt;webSocket&lt;/code&gt; 接受带有WebSocket终结点的url的字符串或用于提供其他配置的&lt;a href=&quot;websocketsubjectconfig&quot;&gt; &lt;code&gt;WebSocketSubjectConfig&lt;/code&gt; &lt;/a&gt;对象以及用于跟踪WebSocket连接生命周期的观察器作为参数。</target>
        </trans-unit>
        <trans-unit id="42327b58fe89d4b9abe60f993e7061fb8c13cb90" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;withLatestFrom&lt;/code&gt; combines each value from the source Observable (the instance) with the latest values from the other input Observables only when the source emits a value, optionally using a &lt;code&gt;project&lt;/code&gt; function to determine the value to be emitted on the output Observable. All input Observables must emit at least one value before the output Observable will emit a value.</source>
          <target state="translated">&lt;code&gt;withLatestFrom&lt;/code&gt; 仅当源发出一个值时，withLatestFrom才会将源Observable（实例）中的每个值与其他输入Observables中的最新值组合在一起，可以选择使用 &lt;code&gt;project&lt;/code&gt; 函数来确定要在输出Observable上发出的值。所有输入Observable都必须至少发出一个值，然后输出Observable才发出值。</target>
        </trans-unit>
        <trans-unit id="1b728c16ebf18a54406f817875e31683e7bead01" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;|&lt;/code&gt;: Equivalent to &lt;code&gt;Observable.empty()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;|&lt;/code&gt; ：等效于 &lt;code&gt;Observable.empty()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9fc5c704c2f6cc2c0c5a80f700059819fe2e60c7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;|&lt;/code&gt;: Equivalent to &lt;code&gt;empty()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;|&lt;/code&gt; ：等同于 &lt;code&gt;empty()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="611ae3064b4a8437c9d8a8987b8edf4d63b802fc" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Pull&lt;/em&gt; and &lt;em&gt;Push&lt;/em&gt; are two different protocols that describe how a data &lt;em&gt;Producer&lt;/em&gt; can communicate with a data &lt;em&gt;Consumer&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;Pull&lt;/em&gt;和&lt;em&gt;Push&lt;/em&gt;是两种不同的协议，它们描述了数据&lt;em&gt;生产者&lt;/em&gt;如何与数据&lt;em&gt;使用者&lt;/em&gt;通信。</target>
        </trans-unit>
        <trans-unit id="b062cafef9329a689038f3f6bb0d6df3b1e17fc9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A Scheduler has a (virtual) clock.&lt;/strong&gt; It provides a notion of &quot;time&quot; by a getter method &lt;code&gt;now()&lt;/code&gt; on the scheduler. Tasks being scheduled on a particular scheduler will adhere only to the time denoted by that clock.</source>
          <target state="translated">&lt;strong&gt;调度程序具有（虚拟）时钟。&lt;/strong&gt;它通过调度程序上的getter方法 &lt;code&gt;now()&lt;/code&gt; 提供&amp;ldquo;时间&amp;rdquo;的概念。在特定的调度程序上调度的任务将仅遵守该时钟指示的时间。</target>
        </trans-unit>
        <trans-unit id="074b016986830a891feacbe88dcea585792b6754" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A Scheduler is a data structure.&lt;/strong&gt; It knows how to store and queue tasks based on priority or other criteria.</source>
          <target state="translated">&lt;strong&gt;调度程序是一种数据结构。&lt;/strong&gt;它知道如何根据优先级或其他条件存储和排队任务。</target>
        </trans-unit>
        <trans-unit id="d23e926a842ae9b7ec36083837a1300934aa0807" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A Scheduler is an execution context.&lt;/strong&gt; It denotes where and when the task is executed (e.g. immediately, or in another callback mechanism such as setTimeout or process.nextTick, or the animation frame).</source>
          <target state="translated">&lt;strong&gt;调度程序是一个执行上下文。&lt;/strong&gt;它表示执行任务的位置和时间（例如，立即执行或在其他回调机制中执行，例如setTimeout或process.nextTick或动画帧）。</target>
        </trans-unit>
        <trans-unit id="c2696dbc62b706589ef9271f2becbde4c0d86eb4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Active:&lt;/strong&gt; decides when data is requested.</source>
          <target state="translated">&lt;strong&gt;有效：&lt;/strong&gt;决定何时请求数据。</target>
        </trans-unit>
        <trans-unit id="40ad7c047bd1f3c45b24a8afae9c8e0660d7e1af" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Active:&lt;/strong&gt; produces data at its own pace.</source>
          <target state="translated">&lt;strong&gt;活动：按&lt;/strong&gt;自己的节奏生成数据。</target>
        </trans-unit>
        <trans-unit id="84179ebccd8aeb96d5d2a2ad2a67b59c7a558188" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Creating&lt;/strong&gt; Observables</source>
          <target state="translated">&lt;strong&gt;创建&lt;/strong&gt;可观察物</target>
        </trans-unit>
        <trans-unit id="2cbf914fb3e5f78e9d854a8a21e5a8003fab511a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Creation Operators&lt;/strong&gt; are the other kind of operator, which can be called as standalone functions to create a new Observable. For example: &lt;code&gt;of(1, 2, 3)&lt;/code&gt; creates an observable that will emit 1, 2, and 3, one right after another. Creation operators will be discussed in more detail in a later section.</source>
          <target state="translated">&lt;strong&gt;创建运算符&lt;/strong&gt;是另一种运算符，可以称为独立函数来创建新的Observable。例如： &lt;code&gt;of(1, 2, 3)&lt;/code&gt; 创建一个可观察对象，该对象将一个接一个地发射1、2和3。创建运算符将在后面的部分中详细讨论。</target>
        </trans-unit>
        <trans-unit id="ca200ee9bac7753c1984e93beda095c8fbb8031e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;DOM EventTarget&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;DOM EventTarget&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3e68420a4c7815b5f0c672698af4bf7843778d45" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;DOM HtmlCollection&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;DOM HtmlCollection&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8943c4167154d5069a0f8a5c2c3dd62af27cc3cc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;DOM NodeList&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;DOM节点列表&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a21f27d9b01b50a7b29f7fa2322b39771e0b7e35" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Disposing&lt;/strong&gt; Observables</source>
          <target state="translated">&lt;strong&gt;处置&lt;/strong&gt;可观察物</target>
        </trans-unit>
        <trans-unit id="cb151d1e02f000a2e2e7a787d5b9cd87bf237000" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Every Subject is an Observable.&lt;/strong&gt; Given a Subject, you can &lt;code&gt;subscribe&lt;/code&gt; to it, providing an Observer, which will start receiving values normally. From the perspective of the Observer, it cannot tell whether the Observable execution is coming from a plain unicast Observable or a Subject.</source>
          <target state="translated">&lt;strong&gt;每个主题都是可观察的。&lt;/strong&gt;给定一个主题，您可以 &lt;code&gt;subscribe&lt;/code&gt; 它，提供一个观察者，它将开始正常接收值。从观察者的角度来看，它无法确定观察到的执行是来自纯单播观察到的还是主题。</target>
        </trans-unit>
        <trans-unit id="5373b1d2caa00d50f019c34ecd9071bc9c038433" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Every Subject is an Observer.&lt;/strong&gt; It is an object with the methods &lt;code&gt;next(v)&lt;/code&gt;, &lt;code&gt;error(e)&lt;/code&gt;, and &lt;code&gt;complete()&lt;/code&gt;. To feed a new value to the Subject, just call &lt;code&gt;next(theValue)&lt;/code&gt;, and it will be multicasted to the Observers registered to listen to the Subject.</source>
          <target state="translated">&lt;strong&gt;每个主题都是观察者。&lt;/strong&gt;它是一个具有 &lt;code&gt;next(v)&lt;/code&gt; ， &lt;code&gt;error(e)&lt;/code&gt; 和 &lt;code&gt;complete()&lt;/code&gt; 方法的对象。要将新值提供给主题，只需调用 &lt;code&gt;next(theValue)&lt;/code&gt; ，它将被多播到注册以监听主题的观察者。</target>
        </trans-unit>
        <trans-unit id="183af49f4d960a43e78387ddc6ee3ed6f8e3ccf0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example.&lt;/strong&gt; The following is an Observable that pushes the values &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt;, &lt;code&gt;3&lt;/code&gt; immediately (synchronously) when subscribed, and the value &lt;code&gt;4&lt;/code&gt; after one second has passed since the subscribe call, then completes:</source>
          <target state="translated">&lt;strong&gt;例。&lt;/strong&gt;以下是可观察到的是推动的值 &lt;code&gt;1&lt;/code&gt; ， &lt;code&gt;2&lt;/code&gt; ， &lt;code&gt;3&lt;/code&gt; 立即（同步）时所订阅，并且该值 &lt;code&gt;4&lt;/code&gt; 在一秒之后自从订阅呼叫通过，则完成：</target>
        </trans-unit>
        <trans-unit id="dc8b1db7d6c863328921dd393ba3c393b762f959" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Executing&lt;/strong&gt; the Observable</source>
          <target state="translated">&lt;strong&gt;执行&lt;/strong&gt;可观察的</target>
        </trans-unit>
        <trans-unit id="a4048867ebc7d64b979ef3246ca49c44be92b16b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Instance operators may take a Scheduler as argument.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;实例运算符可以将Scheduler作为参数。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="96bab829a0c0f4399a5e75cee75d035f3056b17b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;JQuery-style event target&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;jQuery风格的事件目标&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="27bbb9b4010ebcf793220387d26bf7f0eb25cef0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Multiplexing&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Multiplexing&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4ed0d7836fa3fb4540d3c4bbd9ca9eb12e6e3e01" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: Using &lt;code&gt;rxjs&lt;/code&gt; or &lt;code&gt;rxjs/operators&lt;/code&gt; without making changes to your build process can result in larger bundles. See &lt;a href=&quot;pipeable-operators#known-issues&quot;&gt;Known Issues&lt;/a&gt; section below.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：在不更改构建过程的情况下使用 &lt;code&gt;rxjs&lt;/code&gt; 或 &lt;code&gt;rxjs/operators&lt;/code&gt; 可能会导致捆绑销售。请参阅下面的&amp;ldquo; &lt;a href=&quot;pipeable-operators#known-issues&quot;&gt;已知问题&amp;rdquo;&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="f105f3f8fa68751b4b8a425493ce2fc80d1fe5b9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: You may have to subtract 1 millisecond from the time you want to progress because the alphanumeric marbles (representing an actual emitted value) &lt;em&gt;advance time 1 virtual frame&lt;/em&gt; themselves already, after they emit. This can be very unintuitive and frustrating, but for now it is indeed correct.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：您可能需要从要进行的时间中减去1毫秒，因为字母数字大理石（代表实际的发射值）在发射之后已经&lt;em&gt;提前了1个虚拟帧&lt;/em&gt;本身。这可能是很不直观和令人沮丧的，但目前确实是正确的。</target>
        </trans-unit>
        <trans-unit id="1b82b6885d2ca4a917dedb922318618f04d40411" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Node.js EventEmitter&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Node.js EventEmitter&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1e6804a13811d1de6f399d6c72e02d791ca86aa0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Observable.error &amp;gt; throwError()&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Observable.error&amp;gt; throwError（）&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8bd3c9bb800e7f0fb7e366cf1c7b3e082bddc190" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Observable.if &amp;gt; iif()&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Observable.if&amp;gt; iif（）&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="00391a5b16891388706b4319b8c7649c5c3df177" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Observable:&lt;/strong&gt; represents the idea of an invokable collection of future values or events.</source>
          <target state="translated">&lt;strong&gt;可观察的：&lt;/strong&gt;表示将来的值或事件的可调用集合的想法。</target>
        </trans-unit>
        <trans-unit id="0acdf1a2141240d22bc99dc78cf3713da2737dcd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Observer:&lt;/strong&gt; is a collection of callbacks that knows how to listen to values delivered by the Observable.</source>
          <target state="translated">&lt;strong&gt;Observer：&lt;/strong&gt;是一组回调，它们知道如何侦听Observable传递的值。</target>
        </trans-unit>
        <trans-unit id="af427c5f339addc519da7767cdb1e6f5c930d89d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Operators:&lt;/strong&gt; are pure functions that enable a functional programming style of dealing with collections with operations like &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;filter&lt;/code&gt;, &lt;code&gt;concat&lt;/code&gt;, &lt;code&gt;reduce&lt;/code&gt;, etc.</source>
          <target state="translated">&lt;strong&gt;运算符：&lt;/strong&gt;是纯函数，可通过一种函数式编程样式来处理具有 &lt;code&gt;map&lt;/code&gt; ， &lt;code&gt;filter&lt;/code&gt; ， &lt;code&gt;concat&lt;/code&gt; ， &lt;code&gt;reduce&lt;/code&gt; 等操作的集合。</target>
        </trans-unit>
        <trans-unit id="903114a5875a76c7e7e738db8ee5670ecaffeb9f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Passive:&lt;/strong&gt; produces data when requested.</source>
          <target state="translated">&lt;strong&gt;被动：&lt;/strong&gt;在需要时产生数据。</target>
        </trans-unit>
        <trans-unit id="a9558477bc2631c7221403c490210bc959155791" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Passive:&lt;/strong&gt; reacts to received data.</source>
          <target state="translated">&lt;strong&gt;被动：&lt;/strong&gt;对收到的数据做出反应。</target>
        </trans-unit>
        <trans-unit id="3f0517560b9f6522d3ec876a649641ec26e37bec" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Pipeable Operators&lt;/strong&gt; are the kind that can be piped to Observables using the syntax &lt;code&gt;observableInstance.pipe(operator())&lt;/code&gt;. These include, &lt;a href=&quot;../api/operators/filter&quot;&gt;&lt;code&gt;filter(...)&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../api/operators/mergemap&quot;&gt;&lt;code&gt;mergeMap(...)&lt;/code&gt;&lt;/a&gt;. When called, they do not &lt;em&gt;change&lt;/em&gt; the existing Observable instance. Instead, they return a &lt;em&gt;new&lt;/em&gt; Observable, whose subscription logic is based on the first Observable.</source>
          <target state="translated">&lt;strong&gt;管道运算符&lt;/strong&gt;是可以使用语法 &lt;code&gt;observableInstance.pipe(operator())&lt;/code&gt; 传递给Observable的类型。这些包括&lt;a href=&quot;../api/operators/filter&quot;&gt; &lt;code&gt;filter(...)&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../api/operators/mergemap&quot;&gt; &lt;code&gt;mergeMap(...)&lt;/code&gt; &lt;/a&gt;。调用时，它们不会&lt;em&gt;更改&lt;/em&gt;现有的Observable实例。相反，它们返回一个&lt;em&gt;新的&lt;/em&gt; Observable，其订阅逻辑基于第一个Observable。</target>
        </trans-unit>
        <trans-unit id="dfcbd70cd68821b77e692cfdf2ea4926f7734a21" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Pull&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Pull&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="15f12ede62915f48b6ad83b8e92e23880f687ba9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Push&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Push&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3a3a338d979540294175612757b03b13e50907fb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Renamed Operators&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;重命名运营商&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d1f679c158b945669b0b1bcd8dcbe4cf80ff3e13" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Replacing synchronous error handling&lt;/strong&gt; The following example shows code that subscribes to an observable within a &lt;code&gt;try/catch&lt;/code&gt; block, in order to handle errors synchronously:</source>
          <target state="translated">&lt;strong&gt;替换同步错误处理&lt;/strong&gt;以下示例显示了在 &lt;code&gt;try/catch&lt;/code&gt; 块中预订可观察对象的代码，以便同步处理错误：</target>
        </trans-unit>
        <trans-unit id="657c2d83cff0ceff049ce2ce6e5ebce465c69192" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Schedulers:&lt;/strong&gt; are centralized dispatchers to control concurrency, allowing us to coordinate when computation happens on e.g. &lt;code&gt;setTimeout&lt;/code&gt; or &lt;code&gt;requestAnimationFrame&lt;/code&gt; or others.</source>
          <target state="translated">&lt;strong&gt;调度程序：&lt;/strong&gt;是集中式调度程序，用于控制并发性，使我们可以协调在 &lt;code&gt;setTimeout&lt;/code&gt; 或 &lt;code&gt;requestAnimationFrame&lt;/code&gt; 等发生计算时的情况。</target>
        </trans-unit>
        <trans-unit id="230aa9b6906a94c5dd268a2a57b8df69be5e6259" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Static creation operators usually take a Scheduler as argument.&lt;/strong&gt; For instance, &lt;code&gt;from(array, scheduler)&lt;/code&gt; lets you specify the Scheduler to use when delivering each notification converted from the &lt;code&gt;array&lt;/code&gt;. It is usually the last argument to the operator. The following static creation operators take a Scheduler argument:</source>
          <target state="translated">&lt;strong&gt;静态创建运算符通常将Scheduler作为参数。&lt;/strong&gt;例如， &lt;code&gt;from(array, scheduler)&lt;/code&gt; 使您可以指定传递从 &lt;code&gt;array&lt;/code&gt; 转换的每个通知时要使用的Scheduler 。它通常是运算符的最后一个参数。以下静态创建运算符采用Scheduler参数：</target>
        </trans-unit>
        <trans-unit id="4bc5912a19fdcb523a962180f2331e7ae3926205" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Subject:&lt;/strong&gt; is the equivalent to an EventEmitter, and the only way of multicasting a value or event to multiple Observers.</source>
          <target state="translated">&lt;strong&gt;Subject：&lt;/strong&gt;等效于EventEmitter，并且是将值或事件多播到多个Observer的唯一方法。</target>
        </trans-unit>
        <trans-unit id="428168244c9f05e1c6da25e04311afe32902b6a6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Subscribing&lt;/strong&gt; to Observables</source>
          <target state="translated">&lt;strong&gt;订阅&lt;/strong&gt;可观察物</target>
        </trans-unit>
        <trans-unit id="6c45e0a77d0dd75edd547e7bfbd17a13e9e46d91" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Subscription:&lt;/strong&gt; represents the execution of an Observable, is primarily useful for cancelling the execution.</source>
          <target state="translated">&lt;strong&gt;订阅：&lt;/strong&gt;表示Observable的执行，主要用于取消执行。</target>
        </trans-unit>
        <trans-unit id="e7223a3f6b3dd5ad4fd2f32718adaef606ac7aca" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;TS 2.3 and under&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;TS 2.3及以下&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7646ff7a27645ddbc2bb23a98cb8442f76858fe1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;TS 2.4 and up&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;TS 2.4以上&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8497eed474718bc72853151f790b74187f2c7fd4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The connection to the multicasted Observable is unsubscribed&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;与多播Observable的连接已取消订阅&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ed94109423adc7864e5311e1fc56286c608c0c06" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The multicasted Observable is connected&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;多播的Observable已连接&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="90bf18b1ad6ea31a02c0712a451768817863ff9b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;TypeScript user-defined prototype operators&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;TypeScript用户定义的原型运算符&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0fd6589a319070a0e7bfc47072abae83661199ed" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use &lt;code&gt;observeOn&lt;/code&gt; to schedule in what context will notifications be delivered.&lt;/strong&gt; As we saw in the examples above, instance operator &lt;code&gt;observeOn(scheduler)&lt;/code&gt; introduces a mediator Observer between the source Observable and the destination Observer, where the mediator schedules calls to the destination Observer using your given &lt;code&gt;scheduler&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;使用 &lt;code&gt;observeOn&lt;/code&gt; 计划在什么情况下发送通知。&lt;/strong&gt;正如我们在上面的示例中看到的那样，实例运算符 &lt;code&gt;observeOn(scheduler)&lt;/code&gt; 在源Observable和目标Observer之间引入了一个中介Observer，该中介使用您给定的 &lt;code&gt;scheduler&lt;/code&gt; 对目标Observer的调用。</target>
        </trans-unit>
        <trans-unit id="fc501f48fc8f14891b059480a7053bc23bc4bcf9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use &lt;code&gt;subscribeOn&lt;/code&gt; to schedule in what context will the &lt;code&gt;subscribe()&lt;/code&gt; call happen.&lt;/strong&gt; By default, a &lt;code&gt;subscribe()&lt;/code&gt; call on an Observable will happen synchronously and immediately. However, you may delay or schedule the actual subscription to happen on a given Scheduler, using the instance operator &lt;code&gt;subscribeOn(scheduler)&lt;/code&gt;, where &lt;code&gt;scheduler&lt;/code&gt; is an argument you provide.</source>
          <target state="translated">&lt;strong&gt;使用 &lt;code&gt;subscribeOn&lt;/code&gt; 计划在什么上下文中进行 &lt;code&gt;subscribe()&lt;/code&gt; 调用。&lt;/strong&gt;默认情况下，对Observable的subscription &lt;code&gt;subscribe()&lt;/code&gt; 调用将立即同步进行。但是，您可以使用实例运算符subscriptionOn &lt;code&gt;subscribeOn(scheduler)&lt;/code&gt; 延迟或调度实际订阅在给定Scheduler上发生的时间，其中 &lt;code&gt;scheduler&lt;/code&gt; 是您提供的参数。</target>
        </trans-unit>
        <trans-unit id="f02212ebedff47f3c2d37899d71ae6efdb50385f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;WARNING&lt;/strong&gt; Parts of the fetch API are still experimental. &lt;code&gt;AbortController&lt;/code&gt; is required for this implementation to work and use cancellation appropriately.</source>
          <target state="translated">&lt;strong&gt;警告&lt;/strong&gt;部分提取API仍处于试验阶段。该实现需要 &lt;code&gt;AbortController&lt;/code&gt; 才能正常工作并使用取消功能。</target>
        </trans-unit>
        <trans-unit id="1891fe62d5c1ffcfee45323d0789bc157a1b7e2d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; If the source Observable emits Observables quickly and endlessly, and the inner Observables it emits generally complete slower than the source emits, you can run into memory issues as the incoming Observables collect in an unbounded buffer.</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt;如果源Observable连续不断地发出Observable，并且内部Observable发出的速度通常比源Observable慢，则由于传入的Observable收集在无边界缓冲区中，您可能会遇到内存问题。</target>
        </trans-unit>
        <trans-unit id="7cb773da4994f4f259ae2f115254f536579e71cb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; if source values arrive endlessly and faster than their corresponding inner Observables can complete, it will result in memory issues as inner Observables amass in an unbounded buffer waiting for their turn to be subscribed to.</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt;如果源值无休止地到达并且比其相应的内部Observable可以完成的速度更快，则将导致内存问题，因为内部Observable聚集在一个无界缓冲区中，等待轮流被预订。</target>
        </trans-unit>
        <trans-unit id="16407a2f9afdb7f2ce60cdb22355e0487e064350" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What are creation operators?&lt;/strong&gt; Distinct from pipeable operators, creation operators are functions that can be used to create an Observable with some common predefined behavior or by joining other Observables.</source>
          <target state="translated">&lt;strong&gt;什么是创作运算符？&lt;/strong&gt;与管道运算符不同，创建运算符是可用于创建具有某些常见预定义行为或通过加入其他Observable的Observable的函数。</target>
        </trans-unit>
        <trans-unit id="a15df290a491ec301883de6ed75f191f29efc83f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What is Pull?&lt;/strong&gt; In Pull systems, the Consumer determines when it receives data from the data Producer. The Producer itself is unaware of when the data will be delivered to the Consumer.</source>
          <target state="translated">&lt;strong&gt;什么是拉力？&lt;/strong&gt;在Pull系统中，使用者确定何时从数据生产者接收数据。生产者本身并不知道何时将数据传递给消费者。</target>
        </trans-unit>
        <trans-unit id="712dfa59ac3cdd93a3d866043138aa70bec8cb8e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What is Push?&lt;/strong&gt; In Push systems, the Producer determines when to send data to the Consumer. The Consumer is unaware of when it will receive that data.</source>
          <target state="translated">&lt;strong&gt;什么是推？&lt;/strong&gt;在推送系统中，生产者确定何时将数据发送给消费者。消费者不知道何时接收该数据。</target>
        </trans-unit>
        <trans-unit id="6e4e1cb26de7af121d4d8d54dca402173b733a70" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What is a Scheduler?&lt;/strong&gt; A scheduler controls when a subscription starts and when notifications are delivered. It consists of three components.</source>
          <target state="translated">&lt;strong&gt;什么是调度程序？&lt;/strong&gt;调度程序控制何时开始订阅以及何时传递通知。它由三个部分组成。</target>
        </trans-unit>
        <trans-unit id="2d2a4d77a523e5f22052a30bccc030255bae1a0d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What is a Subject?&lt;/strong&gt; An RxJS Subject is a special type of Observable that allows values to be multicasted to many Observers. While plain Observables are unicast (each subscribed Observer owns an independent execution of the Observable), Subjects are multicast.</source>
          <target state="translated">&lt;strong&gt;什么是主题？&lt;/strong&gt;RxJS主题是一种特殊的Observable类型，它允许将值多播到许多Observer。普通的Observable是单播的（每个订阅的Observer拥有Observable的独立执行），而Subject是多播的。</target>
        </trans-unit>
        <trans-unit id="10d4a8daeb2d6cb88fe9a685eea5d8b32f44696b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What is a Subscription?&lt;/strong&gt; A Subscription is an object that represents a disposable resource, usually the execution of an Observable. A Subscription has one important method, &lt;code&gt;unsubscribe&lt;/code&gt;, that takes no argument and just disposes the resource held by the subscription. In previous versions of RxJS, Subscription was called &quot;Disposable&quot;.</source>
          <target state="translated">&lt;strong&gt;什么是订阅？&lt;/strong&gt;订阅是代表可抛弃资源的对象，通常是Observable的执行。订阅有一个重要的方法 &lt;code&gt;unsubscribe&lt;/code&gt; ，它不带任何参数，而只是处理该订阅所拥有的资源。在以前的RxJS版本中，订阅称为&amp;ldquo;一次性&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="3c08f2aa1b9f97e99a2ace9631fba523ce2fd5c0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;closeObserver&lt;/strong&gt; allows us to set a custom error when an error raise up.</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;当出现错误时，&lt;strong&gt;closeObserver&lt;/strong&gt;允许我们设置自定义错误。</target>
        </trans-unit>
        <trans-unit id="c9617eb95fe095e9c89063af41768f15e1a35cf1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;combineLatest()&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;combineLatest()&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0d99ba7b6ef9e2babf8c03e5482a1865fc0add46" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;combineLatest&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;combineLatest&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cb88dd148fb5f8fde2a56a840fd602c4b4bdd87e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;concat&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;concat&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="93b6911eb6bffc04528624a72bd00d9ce4d69501" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;concatMap()&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;concatMap()&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ee79ceed9ae5ea9c01c077904fc5aeebea2049a8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;concatMapTo()&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;concatMapTo()&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2dc0108ff4be926ab3398bb1da3b2169513a5b19" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;deserializer&lt;/strong&gt;, the default for this property is &lt;code&gt;JSON.parse&lt;/code&gt; but since there are just two options for incomming data, either be text or binarydata. We can apply a custom deserialization strategy or just simply skip the default behaviour.</source>
          <target state="translated">&lt;strong&gt;deserializer&lt;/strong&gt;，此属性的默认值为 &lt;code&gt;JSON.parse&lt;/code&gt; ,但是由于只有两个输入数据的选项，即text或binarydata。我们可以应用自定义反序列化策略，也可以仅跳过默认行为。</target>
        </trans-unit>
        <trans-unit id="88b721e1327ee5ca846cce316ea3831e2a114c03" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;exhaustMap()&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;exhaustMap()&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e64aa89b14e9f0fb930d801d1474b5a069471528" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;first()&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;first()&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="42e9b71b0c9f6abe41f5d21d7b89bce1bc5a1757" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;forkJoin()&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;forkJoin()&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="02f22409ce12dc5cd696a8b7770bb37378c4161b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;fromEvent()&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;fromEvent()&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e9e7f297cde0f3e57a576c156803f456f4db3232" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;last()&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;last()&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2f99c5d66faa95e388d7a91e5e6a1a931e1e9e04" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;merge&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;merge&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="be2ed258895844046061c6a16c4d7666a9c67e9f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;mergeMap()&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;mergeMap()&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="30a98a7c67095b1f9efa43fb3cf29683f8e7d437" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;mergeMapTo()&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;mergeMapTo()&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="df9761fa7db55227d364bae7412590b4a16c3a00" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;openObserver&lt;/strong&gt;, Let's say we need to make some kind of init task before sending/receiving msgs to the webSocket or sending notification that the connection was successful, this is when openObserver is usefull for.</source>
          <target state="translated">&lt;strong&gt;openObserver&lt;/strong&gt;，假设我们需要先执行某种初始化任务，然后再将消息发送/接收到webSocket或发送连接成功的通知，这是openObserver有用的时间。</target>
        </trans-unit>
        <trans-unit id="8538babf0df6e2488807caf11c32fb6442ea9a8e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;path-mapping&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;path-mapping&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a7a7c1c0408320eae8f251ee13416ba7fa8e9813" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;race&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;race&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8033164aedc67a47d9b741674b893e5df574ec71" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;rxjs/ajax&lt;/strong&gt;: The Rx ajax implementation</source>
          <target state="translated">&lt;strong&gt;rxjs / ajax&lt;/strong&gt;：Rx ajax实现</target>
        </trans-unit>
        <trans-unit id="ee249de4ff74839d7d59160e6fa42747ac6d1f64" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;rxjs/operators&lt;/strong&gt;: All pipeable operators:</source>
          <target state="translated">&lt;strong&gt;rxjs / operators&lt;/strong&gt;：所有可管道运算符：</target>
        </trans-unit>
        <trans-unit id="b77ea218deb17c3d483e367c8b5e926f7e94fd62" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;rxjs/testing&lt;/strong&gt;: The testing utilities</source>
          <target state="translated">&lt;strong&gt;rxjs / testing&lt;/strong&gt;：测试实用程序</target>
        </trans-unit>
        <trans-unit id="6f08d6ab32819c43824e650817b5cea7ae780d4d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;rxjs/webSocket:&lt;/strong&gt; The web socket subject implementation</source>
          <target state="translated">&lt;strong&gt;rxjs / webSocket：&lt;/strong&gt; Web套接字主题实现</target>
        </trans-unit>
        <trans-unit id="5b5978c6ff6549ebfd8d09317422f89f556f26bd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;rxjs:&lt;/strong&gt; Creation methods, types, schedulers and utilities</source>
          <target state="translated">&lt;strong&gt;rxjs：&lt;/strong&gt;创建方法，类型，调度程序和实用程序</target>
        </trans-unit>
        <trans-unit id="5a96c3978998d062f56f520209675d5ca2e3200e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;serializer&lt;/strong&gt; allows us tom apply custom serialization strategy but for the outgoing messages</source>
          <target state="translated">&lt;strong&gt;序列化程序&lt;/strong&gt;允许我们使用自定义序列化策略，但对于传出消息</target>
        </trans-unit>
        <trans-unit id="25d76e530dc6bddd9b5a2cbb5c4fc4417032db68" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;switchMap()&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;switchMap()&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e09ba85c76d585a9df1b1dcd098e925200d3fff8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;switchMapTo()&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;switchMapTo()&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f2d721ba21cdb4b4325c8bcbfaa215f9c4db0440" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;webpack.config.js&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;webpack.config.js&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="37c0839b8cdacbbaae239d4a9bad18c24e1f7e5c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;zip()&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;zip()&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="37b86f110b2db8e46463dee1f96085d7c7d8c7ad" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;zip&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;zip&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d9cbda34fcb1655f6eac22b4d8800b2f74463f70" translate="yes" xml:space="preserve">
          <source>@example</source>
          <target state="translated">@example</target>
        </trans-unit>
        <trans-unit id="7752616a2a7d9f9dad2611e86f931cdee6d7370c" translate="yes" xml:space="preserve">
          <source>@example Converts a javascript object to an Observable</source>
          <target state="translated">@example将javascript对象转换为Observable</target>
        </trans-unit>
        <trans-unit id="69554a23de0b45d4239ec533bf92361e87963547" translate="yes" xml:space="preserve">
          <source>@param {Object} obj The object to inspect and turn into an Observable sequence. @param {Scheduler} [scheduler] An optional IScheduler to schedule when resulting Observable will emit values. @returns {(Observable&amp;lt;Array&amp;lt;string|T&amp;gt;&amp;gt;)} An observable sequence of [key, value] pairs from the object.</source>
          <target state="translated">@param {Object} obj要检查并变成可观察序列的对象。@param {Scheduler} [scheduler]一个可选的IScheduler，用于调度结果Observable何时发出值。@returns {（Observable &amp;lt;Array &amp;lt;string | T &amp;gt;&amp;gt;）}来自对象的[key，value]对的可观察序列。</target>
        </trans-unit>
        <trans-unit id="aecffaccb00ca124ca2411785bcddae1a5614c86" translate="yes" xml:space="preserve">
          <source>@param {S} initialState Initial state. @param {function (state: S): boolean} condition Condition to terminate generation (upon returning false). @param {function (state: S): S} iterate Iteration step function. @param {function (state: S): T} [resultSelector] Selector function for results produced in the sequence. @param {Scheduler} [scheduler] A &lt;a href=&quot;../class/scheduler&quot;&gt;&lt;code&gt;Scheduler&lt;/code&gt;&lt;/a&gt; on which to run the generator loop. If not provided, defaults to emitting immediately. @return {Observable</source>
          <target state="translated">@param {S} initialState初始状态。@param {function（state：S）：boolean} condition终止生成的条件（返回false时）。@param {function（状态：S）：S}迭代迭代步骤函数。@param {功能（状态：S）：T} [resultSelector]选择器功能，用于序列中产生的结果。@param {Scheduler} [scheduler] 在其上运行生成器循环的&lt;a href=&quot;../class/scheduler&quot;&gt; &lt;code&gt;Scheduler&lt;/code&gt; &lt;/a&gt;。如果未提供，则默认为立即发射。@return {可观察</target>
        </trans-unit>
        <trans-unit id="a86b8f8b9392a35784c87db9c3a38fa906373730" translate="yes" xml:space="preserve">
          <source>@see &lt;a href=&quot;from&quot;&gt;&lt;code&gt;from&lt;/code&gt;&lt;/a&gt; @see &lt;a href=&quot;../class/observable#create&quot;&gt;&lt;code&gt;create&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">@see &lt;a href=&quot;from&quot;&gt; &lt;code&gt;from&lt;/code&gt; &lt;/a&gt; @see &lt;a href=&quot;../class/observable#create&quot;&gt; &lt;code&gt;create&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="df198b98a019b86cf56dbdbe15e6f3192da5358f" translate="yes" xml:space="preserve">
          <source>A &quot;multicasted Observable&quot; passes notifications through a Subject which may have many subscribers, whereas a plain &quot;unicast Observable&quot; only sends notifications to a single Observer.</source>
          <target state="translated">一个 &quot;多播Observable &quot;通过一个可能有许多订阅者的Subject传递通知,而一个普通的 &quot;单播Observable &quot;只向一个观察者发送通知。</target>
        </trans-unit>
        <trans-unit id="92b8313735e022c08e283746820b60689e84e023" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;../index/class/groupedobservable&quot;&gt;&lt;code&gt;GroupedObservable&lt;/code&gt;&lt;/a&gt; represents values belonging to the same group represented by a common key. The common key is available as the key field of a &lt;a href=&quot;../index/class/groupedobservable&quot;&gt;&lt;code&gt;GroupedObservable&lt;/code&gt;&lt;/a&gt; instance.</source>
          <target state="translated">甲&lt;a href=&quot;../index/class/groupedobservable&quot;&gt; &lt;code&gt;GroupedObservable&lt;/code&gt; &lt;/a&gt;表示属于通过一个公共密钥所表示的相同的基团的值。公用密钥可用作&lt;a href=&quot;../index/class/groupedobservable&quot;&gt; &lt;code&gt;GroupedObservable&lt;/code&gt; &lt;/a&gt;实例的密钥字段。</target>
        </trans-unit>
        <trans-unit id="d526b50bab2cb764a769f15056314286d65451b5" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;../interface/schedulerlike&quot;&gt;&lt;code&gt;SchedulerLike&lt;/code&gt;&lt;/a&gt; on which to run the generator loop. If not provided, defaults to emit immediately.</source>
          <target state="translated">一个&lt;a href=&quot;../interface/schedulerlike&quot;&gt; &lt;code&gt;SchedulerLike&lt;/code&gt; &lt;/a&gt;在其上运行的发电机循环。如果未提供，则默认为立即发出。</target>
        </trans-unit>
        <trans-unit id="b4ec8a1e9cab67d3465e14c22c1480c899232202" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;../interface/schedulerlike&quot;&gt;&lt;code&gt;SchedulerLike&lt;/code&gt;&lt;/a&gt; to use for scheduling the emission of the complete notification.</source>
          <target state="translated">一个&lt;a href=&quot;../interface/schedulerlike&quot;&gt; &lt;code&gt;SchedulerLike&lt;/code&gt; &lt;/a&gt;，用于调度完整通知的发出。</target>
        </trans-unit>
        <trans-unit id="e3502d4cd60420575855768df193717ce7af823c" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;../interface/schedulerlike&quot;&gt;&lt;code&gt;SchedulerLike&lt;/code&gt;&lt;/a&gt; to use for scheduling the emission of the error notification.</source>
          <target state="translated">甲&lt;a href=&quot;../interface/schedulerlike&quot;&gt; &lt;code&gt;SchedulerLike&lt;/code&gt; &lt;/a&gt;使用用于调度错误通知的发射。</target>
        </trans-unit>
        <trans-unit id="bfb45378875cd0dbee1204d3f1675469e0de052d" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;../interface/schedulerlike&quot;&gt;&lt;code&gt;SchedulerLike&lt;/code&gt;&lt;/a&gt; to use for scheduling the emissions of the notifications.</source>
          <target state="translated">甲&lt;a href=&quot;../interface/schedulerlike&quot;&gt; &lt;code&gt;SchedulerLike&lt;/code&gt; &lt;/a&gt;使用用于调度通知的排放。</target>
        </trans-unit>
        <trans-unit id="e45bc63b80ef36d258103d1502ec98c1bc283c44" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;ReplaySubject&lt;/code&gt; is similar to a &lt;code&gt;BehaviorSubject&lt;/code&gt; in that it can send old values to new subscribers, but it can also &lt;em&gt;record&lt;/em&gt; a part of the Observable execution.</source>
          <target state="translated">一个 &lt;code&gt;ReplaySubject&lt;/code&gt; 类似于 &lt;code&gt;BehaviorSubject&lt;/code&gt; ，它可以旧值发送给新用户，但它也可以&lt;em&gt;记录&lt;/em&gt;可观察的执行的一部分。</target>
        </trans-unit>
        <trans-unit id="9266d79d79e506e9015638a1e7fa25d05eed2d9a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;ReplaySubject&lt;/code&gt; records multiple values from the Observable execution and replays them to new subscribers.</source>
          <target state="translated">一个 &lt;code&gt;ReplaySubject&lt;/code&gt; 记录来自Observable执行的多个值，并将它们重播给新的订户。</target>
        </trans-unit>
        <trans-unit id="b627fb490427e84b2fb30afc924259f8c9213ca3" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;subscribe&lt;/code&gt; call is simply a way to start an &quot;Observable execution&quot; and deliver values or events to an Observer of that execution.</source>
          <target state="translated">一个 &lt;code&gt;subscribe&lt;/code&gt; 调用是简单地启动一个&amp;ldquo;可观察执行&amp;rdquo;，并提供价值或事件到执行的观测方式。</target>
        </trans-unit>
        <trans-unit id="efd0bc3590ad0e5cd305fc066f8858e79d9f944e" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;Function&lt;/strong&gt; is a lazily evaluated computation that synchronously returns a single value on invocation.</source>
          <target state="translated">甲&lt;strong&gt;函数&lt;/strong&gt;是一个懒惰地评估计算该同步返回上调用的单个值。</target>
        </trans-unit>
        <trans-unit id="3f042dfe09e5b8f66ba0f9c0ba654f1fd5be3a96" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;Promise&lt;/strong&gt; is a computation that may (or may not) eventually return a single value.</source>
          <target state="translated">一个&lt;strong&gt;承诺&lt;/strong&gt;是一个计算可能（也可能不会）最终返回一个值。</target>
        </trans-unit>
        <trans-unit id="65e785fe4afd3cb8b2772ccac68387742bbdc4b9" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;generator&lt;/strong&gt; is a lazily evaluated computation that synchronously returns zero to (potentially) infinite values on iteration.</source>
          <target state="translated">甲&lt;strong&gt;发生器&lt;/strong&gt;是一个懒惰地评估计算该同步返回零至（潜在地）无穷大的值上迭代。</target>
        </trans-unit>
        <trans-unit id="787a4416e61a830e0934a34a8528eaf6a5d6f8a0" translate="yes" xml:space="preserve">
          <source>A Pipeable Operator is a function that takes an Observable as its input and returns another Observable. It is a pure operation: the previous Observable stays unmodified.</source>
          <target state="translated">可管操作符是将一个Observable作为输入并返回另一个Observable的函数。它是一个纯粹的操作:前一个Observable不会被修改。</target>
        </trans-unit>
        <trans-unit id="ee8f5678bb76afe5dd5b02ced66fb1b0d0044586" translate="yes" xml:space="preserve">
          <source>A Pipeable Operator is essentially a pure function which takes one Observable as input and generates another Observable as output. Subscribing to the output Observable will also subscribe to the input Observable.</source>
          <target state="translated">Pipeable Operator本质上是一个纯函数,它将一个Observable作为输入,并生成另一个Observable作为输出。订阅输出Observable也会订阅输入Observable。</target>
        </trans-unit>
        <trans-unit id="8a8fb471411d33905e9737fbb68ea61b6feae34c" translate="yes" xml:space="preserve">
          <source>A Scheduler lets you define in what execution context will an Observable deliver notifications to its Observer.</source>
          <target state="translated">调度器可以让你定义一个Observable在什么样的执行环境下向它的Observer发送通知。</target>
        </trans-unit>
        <trans-unit id="1383655957399b6d6567929c08301e77b08501ae" translate="yes" xml:space="preserve">
          <source>A Subject is a special type of Observable that allows values to be multicasted to many Observers. Subjects are like EventEmitters.</source>
          <target state="translated">Subject是一种特殊类型的Observable,它允许将值多播到许多Observers。Subjects就像EventEmitters一样。</target>
        </trans-unit>
        <trans-unit id="595e5accf5017b8e9b3a26eab2f3945e3ee64ffd" translate="yes" xml:space="preserve">
          <source>A Subject is like an Observable, but can multicast to many Observers. Subjects are like EventEmitters: they maintain a registry of many listeners.</source>
          <target state="translated">一个Subject就像一个Observable,但可以多播给许多Observers。主体就像EventEmitters:它们维护着一个由许多监听者组成的注册表。</target>
        </trans-unit>
        <trans-unit id="59267fecd593def896e3fba4fd2bf602984d25ea" translate="yes" xml:space="preserve">
          <source>A Subscribable or Promise of notifications to start new buffers.</source>
          <target state="translated">一个可订阅或承诺的通知,开始新的缓冲区。</target>
        </trans-unit>
        <trans-unit id="7313d23b65818f64b6af3fe148cd41e7983c1394" translate="yes" xml:space="preserve">
          <source>A Subscription essentially just has an &lt;code&gt;unsubscribe()&lt;/code&gt; function to release resources or cancel Observable executions.</source>
          <target state="translated">订阅实际上仅具有 &lt;code&gt;unsubscribe()&lt;/code&gt; 函数以释放资源或取消可观察的执行。</target>
        </trans-unit>
        <trans-unit id="c63c60cba20643163ad3c75c34404680f19c072f" translate="yes" xml:space="preserve">
          <source>A WebSocket constructor to use. This is useful for situations like using a WebSocket impl in Node (WebSocket is a DOM API), or for mocking a WebSocket for testing purposes</source>
          <target state="translated">要使用的 WebSocket 构造函数。这对于在 Node 中使用 WebSocket impl(WebSocket 是一个 DOM API),或出于测试目的模拟 WebSocket 的情况非常有用。</target>
        </trans-unit>
        <trans-unit id="a9e61acb5afa79b453b4ba08613ae03fd867cf3a" translate="yes" xml:space="preserve">
          <source>A backward-compatibility layer eases the update process, allowing you to keep your apps working while you address most code changes at your own pace. The overall process can be carried out in stages:</source>
          <target state="translated">向后兼容层简化了更新过程,使您能够在以自己的速度处理大多数代码更改时保持应用程序的工作。整个过程可以分阶段进行。</target>
        </trans-unit>
        <trans-unit id="4bd800c7ab855f649fc2eab1b004a611c7c13886" translate="yes" xml:space="preserve">
          <source>A basic test might look as follows:</source>
          <target state="translated">一个基本的测试可能如下:</target>
        </trans-unit>
        <trans-unit id="eef697f1cf672e4d57623879c7156c74ecc95eec" translate="yes" xml:space="preserve">
          <source>A boolean function to select what values are to be counted. It is provided with arguments of:</source>
          <target state="translated">一个布尔函数,用于选择要计算的值。它的参数为:</target>
        </trans-unit>
        <trans-unit id="8f45c3c3413edfacde63e5866f13cd65204265d1" translate="yes" xml:space="preserve">
          <source>A configuration object for the fetch. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters&quot;&gt;See MDN for more details&lt;/a&gt;</source>
          <target state="translated">提取的配置对象。&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters&quot;&gt;有关更多详细信息，请参见MDN&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7c4de04a5af82cb23d096ab9e62b3870971781c1" translate="yes" xml:space="preserve">
          <source>A deserializer used for messages arriving on the socket from the server. Defaults to JSON.parse.</source>
          <target state="translated">用于处理从服务器发送到套接字上的消息的解串器。默认为JSON.parse。</target>
        </trans-unit>
        <trans-unit id="d167c96728eb69fa561194cbec15b9f0fe0d7285" translate="yes" xml:space="preserve">
          <source>A diagram in the marble DSL. Letters map to keys in &lt;code&gt;values&lt;/code&gt; if provided.</source>
          <target state="translated">大理石DSL中的示意图。字母映射到 &lt;code&gt;values&lt;/code&gt; 键（如果提供）。</target>
        </trans-unit>
        <trans-unit id="f009493c51fc2592cb8421af3d23ee4de3965f99" translate="yes" xml:space="preserve">
          <source>A factory function called to produce the error to be thrown when the source observable completes without emitting a value.</source>
          <target state="translated">一个工厂函数,当源观测值完成而没有发出一个值时,调用该函数来产生要抛出的错误。</target>
        </trans-unit>
        <trans-unit id="b40eaa47a4ae0d329a8fa61931721257cccf71cf" translate="yes" xml:space="preserve">
          <source>A flag to indicate whether this Subscription has already been unsubscribed.</source>
          <target state="translated">表示该订阅是否已被取消订阅的标志。</target>
        </trans-unit>
        <trans-unit id="02bee705142a9e998ed4143d3f997683135a4d25" translate="yes" xml:space="preserve">
          <source>A function called with each item to test for condition matching.</source>
          <target state="translated">与每个项目一起调用的函数,用于测试条件是否匹配。</target>
        </trans-unit>
        <trans-unit id="2ee4f743ea411d4ec9d0fd32831905e9c306b5b3" translate="yes" xml:space="preserve">
          <source>A function describing how to perform the disposal of resources when the &lt;code&gt;unsubscribe&lt;/code&gt; method is called.</source>
          <target state="translated">描述调用 &lt;code&gt;unsubscribe&lt;/code&gt; 方法时如何执行资源处置的功能。</target>
        </trans-unit>
        <trans-unit id="a174085e61b79f49711a9af69a212b61636f083c" translate="yes" xml:space="preserve">
          <source>A function for determining if an item meets a specified condition.</source>
          <target state="translated">用于判断一个项目是否符合指定条件的函数。</target>
        </trans-unit>
        <trans-unit id="8a7581bf977049768d2d00279073287d26391eb0" translate="yes" xml:space="preserve">
          <source>A function representing a task, or some unit of work to be executed by the Scheduler.</source>
          <target state="translated">代表任务的函数,或者是由调度器执行的某个工作单位。</target>
        </trans-unit>
        <trans-unit id="a7aff61d4e068dee4178bfa46d0c1c9fd8cd2470" translate="yes" xml:space="preserve">
          <source>A function that evaluates a value emitted by the source Observable and returns a boolean. Also takes the (zero-based) index as the second argument.</source>
          <target state="translated">评估源Observable发出的值并返回一个布尔值的函数。也接受(基于零的)索引作为第二个参数。</target>
        </trans-unit>
        <trans-unit id="f3ab69212cd1f782cb1df01a2c437c820bc7a64d" translate="yes" xml:space="preserve">
          <source>A function that evaluates each value emitted by the source Observable. If it returns &lt;code&gt;true&lt;/code&gt;, the value is emitted on the first Observable in the returned array, if &lt;code&gt;false&lt;/code&gt; the value is emitted on the second Observable in the array. The &lt;code&gt;index&lt;/code&gt; parameter is the number &lt;code&gt;i&lt;/code&gt; for the i-th source emission that has happened since the subscription, starting from the number &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">评估源Observable发出的每个值的函数。如果返回 &lt;code&gt;true&lt;/code&gt; ，则在返回的数组的第一个Observable 上发射该值，如果为 &lt;code&gt;false&lt;/code&gt; ，则在该数组的第二个Observable上发射该值。所述 &lt;code&gt;index&lt;/code&gt; 参数是数 &lt;code&gt;i&lt;/code&gt; 以来的订阅已经发生，从编号开始的第i个源发射 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9b06811fdd9e2d5cba0316a248e9cd4d70bbd164" translate="yes" xml:space="preserve">
          <source>A function that evaluates each value emitted by the source Observable. If it returns &lt;code&gt;true&lt;/code&gt;, the value is emitted, if &lt;code&gt;false&lt;/code&gt; the value is not passed to the output Observable. The &lt;code&gt;index&lt;/code&gt; parameter is the number &lt;code&gt;i&lt;/code&gt; for the i-th source emission that has happened since the subscription, starting from the number &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">评估源Observable发出的每个值的函数。如果返回 &lt;code&gt;true&lt;/code&gt; ，则发出该值；如果返回 &lt;code&gt;false&lt;/code&gt; ，则该值不会传递到输出Observable。所述 &lt;code&gt;index&lt;/code&gt; 参数是数 &lt;code&gt;i&lt;/code&gt; 以来的订阅已经发生，从编号开始的第i个源发射 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3e1cc55fd47812c320470c4debab0def8d7c31a3" translate="yes" xml:space="preserve">
          <source>A function that extracts the key for each item.</source>
          <target state="translated">为每个项目提取密钥的函数。</target>
        </trans-unit>
        <trans-unit id="3f20c2c55aa51748f5e336dd5f3cb99f33dbde47" translate="yes" xml:space="preserve">
          <source>A function that extracts the return element for each item.</source>
          <target state="translated">为每个项目提取返回元素的函数。</target>
        </trans-unit>
        <trans-unit id="a7a58224a8bd100ed0e485a88080137b3854b471" translate="yes" xml:space="preserve">
          <source>A function that receives a value from the source Observable, for computing the silencing duration for each source value, returned as an Observable or a Promise.</source>
          <target state="translated">从源Observable中接收一个值的函数,用于计算每个源值的沉默持续时间,以Observable或Promise的形式返回。</target>
        </trans-unit>
        <trans-unit id="1d7f24177fda0fadd63dbf54c962d5ab5af0557d" translate="yes" xml:space="preserve">
          <source>A function that receives a value from the source Observable, for computing the silencing duration, returned as an Observable or a Promise.</source>
          <target state="translated">从源Observable中接收一个值的函数,用于计算沉默持续时间,该值以Observable或Promise的形式返回。</target>
        </trans-unit>
        <trans-unit id="436e0ae8e52a3c1bd4ebac765d2258eba7bc6c87" translate="yes" xml:space="preserve">
          <source>A function that receives a value from the source Observable, for computing the timeout duration for each source value, returned as an Observable or a Promise.</source>
          <target state="translated">从源Observable中接收一个值的函数,用于计算每个源值的超时持续时间,以Observable或Promise形式返回。</target>
        </trans-unit>
        <trans-unit id="825ac0575211babe238f66911631d9f77c0e8aed" translate="yes" xml:space="preserve">
          <source>A function that returns an Observable for each value emitted by the source Observable, which is then used to delay the emission of that item on the output Observable until the Observable returned from this function emits a value.</source>
          <target state="translated">一个为源Observable发出的每个值返回一个Observable的函数,然后用它来延迟输出Observable上该项的发出,直到该函数返回的Observable发出一个值。</target>
        </trans-unit>
        <trans-unit id="181087b8926d4dacf4b94055e684261bebea38b7" translate="yes" xml:space="preserve">
          <source>A function that returns an Observable to determine how long each group should exist.</source>
          <target state="translated">一个返回Observable的函数,用来确定每个组应该存在多久。</target>
        </trans-unit>
        <trans-unit id="eac0f18ee26680057d8da59fa8a9a4494d446b1a" translate="yes" xml:space="preserve">
          <source>A function that takes a &lt;code&gt;handler&lt;/code&gt; function as an argument and removes it from the event source. If &lt;code&gt;addHandler&lt;/code&gt; returns some kind of token, &lt;code&gt;removeHandler&lt;/code&gt; function will have it as a second parameter.</source>
          <target state="translated">以 &lt;code&gt;handler&lt;/code&gt; 函数为参数并将其从事件源中删除的函数。如果 &lt;code&gt;addHandler&lt;/code&gt; 操作返回某种道理， &lt;code&gt;removeHandler&lt;/code&gt; 功能将它作为第二个参数。</target>
        </trans-unit>
        <trans-unit id="512d938ca2d5a7413ab46f41aee1ed8553649e96" translate="yes" xml:space="preserve">
          <source>A function that takes a &lt;code&gt;handler&lt;/code&gt; function as argument and attaches it somehow to the actual source of events.</source>
          <target state="translated">以 &lt;code&gt;handler&lt;/code&gt; 函数为参数并将其以某种方式附加到实际事件源的函数。</target>
        </trans-unit>
        <trans-unit id="3a61edb60f61f060a406dfa0442bbf11948b3169" translate="yes" xml:space="preserve">
          <source>A function that takes no arguments and returns an Observable that signals (on either &lt;code&gt;next&lt;/code&gt; or &lt;code&gt;complete&lt;/code&gt;) when to close the previous window and start a new one.</source>
          <target state="translated">一个不带任何参数并返回Observable的函数，该信号在关闭上一个窗口并开始新窗口时发出信号（在 &lt;code&gt;next&lt;/code&gt; 或 &lt;code&gt;complete&lt;/code&gt; 上）。</target>
        </trans-unit>
        <trans-unit id="b395dbcb5596f4c88f229c93db0ee664db88fae9" translate="yes" xml:space="preserve">
          <source>A function that takes no arguments and returns an Observable that signals buffer closure.</source>
          <target state="translated">一个不接受参数的函数,并返回一个Observable,作为缓冲区关闭的信号。</target>
        </trans-unit>
        <trans-unit id="eb8af6ffdd3fa19c6c972a4b39dd50cf5f5f1294" translate="yes" xml:space="preserve">
          <source>A function that takes the value emitted by the &lt;code&gt;openings&lt;/code&gt; observable and returns a Subscribable or Promise, which, when it emits, signals that the associated buffer should be emitted and cleared.</source>
          <target state="translated">一个函数，该函数接受可观察到的 &lt;code&gt;openings&lt;/code&gt; 值，并返回一个Subscribable或Promise，当其发出时，该信号表示应发出并清除关联的缓冲区。</target>
        </trans-unit>
        <trans-unit id="7d19cda655bdbba514c8fec7bdafdf3f88786fc2" translate="yes" xml:space="preserve">
          <source>A function that takes the value emitted by the &lt;code&gt;openings&lt;/code&gt; observable and returns an Observable, which, when it emits (either &lt;code&gt;next&lt;/code&gt; or &lt;code&gt;complete&lt;/code&gt;), signals that the associated window should complete.</source>
          <target state="translated">一个函数，它采用可观察的 &lt;code&gt;openings&lt;/code&gt; 发出的值并返回一个Observable，当它发出（ &lt;code&gt;next&lt;/code&gt; 或 &lt;code&gt;complete&lt;/code&gt; ）时，该信号指示关联窗口应该完成。</target>
        </trans-unit>
        <trans-unit id="9369aa3d687e421514195d33b42429aec008ddf9" translate="yes" xml:space="preserve">
          <source>A function that, when applied to an item emitted by the source Observable, returns an Observable.</source>
          <target state="translated">当应用于源Observable发出的项目时,返回一个Observable的函数。</target>
        </trans-unit>
        <trans-unit id="e4521e5c267ddc4bb538190c2ca06dc029d5330e" translate="yes" xml:space="preserve">
          <source>A function that, when applied to an item emitted by the source or the output Observable, returns an Observable.</source>
          <target state="translated">当应用于源或输出Observable发出的项目时,返回一个Observable的函数。</target>
        </trans-unit>
        <trans-unit id="a84e17a04254867664848fc07b92b50560da7d6a" translate="yes" xml:space="preserve">
          <source>A function to generate the subscription message to be sent to the server. This will still be processed by the serializer in the WebSocketSubject's config. (Which defaults to JSON serialization)</source>
          <target state="translated">生成要发送到服务器的订阅消息的函数。这仍将由 WebSocketSubject 配置中的序列化器处理。默认为JSON序列化)。</target>
        </trans-unit>
        <trans-unit id="a1d17233911c6a0e69dc28d400ccf5e8edbe8e23" translate="yes" xml:space="preserve">
          <source>A function to generate the unsubscription message to be sent to the server at teardown. This will still be processed by the serializer in the WebSocketSubject's config.</source>
          <target state="translated">一个用于生成退订消息的函数,该消息将在删除时发送给服务器。这仍将由 WebSocketSubject 配置中的序列器处理。</target>
        </trans-unit>
        <trans-unit id="345023669dea9569b5e96a5b0a04ffc52aedf25a" translate="yes" xml:space="preserve">
          <source>A function to test each item emitted from the source Observable.</source>
          <target state="translated">用于测试从源Observable发出的每个项目的函数。</target>
        </trans-unit>
        <trans-unit id="20ba5bd927254728b204da746dfd84abfc0c9fa2" translate="yes" xml:space="preserve">
          <source>A function which creates an Observable, that can use injected resource object.</source>
          <target state="translated">创建一个Observable的函数,可以使用注入的资源对象。</target>
        </trans-unit>
        <trans-unit id="9ec4c214ea4517113854529a01f2d0f71b7f9ef9" translate="yes" xml:space="preserve">
          <source>A function which creates any resource object that implements &lt;code&gt;unsubscribe&lt;/code&gt; method.</source>
          <target state="translated">创建任何实现 &lt;code&gt;unsubscribe&lt;/code&gt; 方法的资源对象的函数。</target>
        </trans-unit>
        <trans-unit id="085acb778c87b3d06d060ed301b6efeae7bf802c" translate="yes" xml:space="preserve">
          <source>A getter method that returns a number representing the current time (at the time this function was called) according to the scheduler's own internal clock.</source>
          <target state="translated">一个getter方法,根据调度器自己的内部时钟返回一个代表当前时间(在这个函数被调用时)的数字。</target>
        </trans-unit>
        <trans-unit id="06d29234ccfd4191ed3ffb325c080e536a830b43" translate="yes" xml:space="preserve">
          <source>A multicasted Observable uses a Subject under the hood to make multiple Observers see the same Observable execution.</source>
          <target state="translated">多播Observicable使用罩下的Subject使多个Observer看到同一个Observable的执行。</target>
        </trans-unit>
        <trans-unit id="f1c6692289c195d88b6f02552c67a2b7ecc0cfc2" translate="yes" xml:space="preserve">
          <source>A normal Observer object or a callback for &lt;code&gt;next&lt;/code&gt;.</source>
          <target state="translated">普通的Observer对象或 &lt;code&gt;next&lt;/code&gt; 的回调。</target>
        </trans-unit>
        <trans-unit id="0b14e10f14b46eb52564b107c3c18922d62e81ef" translate="yes" xml:space="preserve">
          <source>A normalized AJAX response.</source>
          <target state="translated">一个标准化的AJAX响应。</target>
        </trans-unit>
        <trans-unit id="832e857924dcf7ac90856d16c612abe5583d2e58" translate="yes" xml:space="preserve">
          <source>A partially defined Observer or a &lt;code&gt;next&lt;/code&gt; callback function.</source>
          <target state="translated">部分定义的Observer或 &lt;code&gt;next&lt;/code&gt; 回调函数。</target>
        </trans-unit>
        <trans-unit id="3e7fcb0ff2bd1ab1f5f2e0116a79bcfe7f2f9174" translate="yes" xml:space="preserve">
          <source>A predicate for selecting the appropriate messages from the server for the output stream.</source>
          <target state="translated">用于从服务器中选择适当的信息作为输出流的前提条件。</target>
        </trans-unit>
        <trans-unit id="69939066fee7c1a440ccb1dfd8dfbe76ef63e1ce" translate="yes" xml:space="preserve">
          <source>A predicate function to evaluate items emitted by the source Observable.</source>
          <target state="translated">用于评估源Observable发出的项目的谓词函数。</target>
        </trans-unit>
        <trans-unit id="ed983b10ec661fc781c33afc49596f31baaae0ee" translate="yes" xml:space="preserve">
          <source>A representation of any set of values over any amount of time. This is the most basic building block of RxJS.</source>
          <target state="translated">任意时间内的任意一组值的表示。这是RxJS最基本的构件。</target>
        </trans-unit>
        <trans-unit id="b9b66ed15a9a4e0c284c9afdfaeb0b0b176e9562" translate="yes" xml:space="preserve">
          <source>A serializer used to create messages from passed values before the messages are sent to the server. Defaults to JSON.stringify.</source>
          <target state="translated">一个序列化器,用于在消息被发送到服务器之前从传递的值中创建消息。默认为JSON.stringify。</target>
        </trans-unit>
        <trans-unit id="ff7eb2bf9dc197cd6db071463f78db0f65ad773e" translate="yes" xml:space="preserve">
          <source>A shortcut to create a Notification instance of the type &lt;code&gt;complete&lt;/code&gt;.</source>
          <target state="translated">创建类型为 &lt;code&gt;complete&lt;/code&gt; 的Notification实例的快捷方式。</target>
        </trans-unit>
        <trans-unit id="d81c5d3e349ae456b72b795ea3af164beb77755c" translate="yes" xml:space="preserve">
          <source>A shortcut to create a Notification instance of the type &lt;code&gt;error&lt;/code&gt; from a given error.</source>
          <target state="translated">从给定错误创建类型 &lt;code&gt;error&lt;/code&gt; 的Notification实例的快捷方式。</target>
        </trans-unit>
        <trans-unit id="dc2ac3c034182e80275264531f2481e8b5aa45f0" translate="yes" xml:space="preserve">
          <source>A shortcut to create a Notification instance of the type &lt;code&gt;next&lt;/code&gt; from a given value.</source>
          <target state="translated">快捷方式创建的类型的通知实例 &lt;code&gt;next&lt;/code&gt; 从给定值。</target>
        </trans-unit>
        <trans-unit id="c3d9971add316bca4c32c78db34ba1835fc86306" translate="yes" xml:space="preserve">
          <source>A similar effect could be achieved with &lt;a href=&quot;count&quot;&gt;&lt;code&gt;count&lt;/code&gt;&lt;/a&gt;, but &lt;code&gt;isEmpty&lt;/code&gt; can emit a &lt;code&gt;false&lt;/code&gt; value sooner.</source>
          <target state="translated">使用&lt;a href=&quot;count&quot;&gt; &lt;code&gt;count&lt;/code&gt; &lt;/a&gt;可以实现类似的效果，但是 &lt;code&gt;isEmpty&lt;/code&gt; 可以更快地发出 &lt;code&gt;false&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="58aead400ac5e5653e3f72ddc4177b36ea162b31" translate="yes" xml:space="preserve">
          <source>A simple Observable that emits neither values nor errors nor the completion notification. It can be used for testing purposes or for composing with other Observables. Please note that by never emitting a complete notification, this Observable keeps the subscription from being disposed automatically. Subscriptions need to be manually disposed.</source>
          <target state="translated">一个简单的Observable,既不发值,也不发错误,也不发完成通知。它可以用于测试目的或与其他Observable组合。请注意,通过从不发出完成通知,该Observable可以使订阅不被自动处理。订阅需要手动处理。</target>
        </trans-unit>
        <trans-unit id="daeebe20328b78c57c2965c3885cd4f9150827af" translate="yes" xml:space="preserve">
          <source>A simple example emitting true if all elements are less than 5, false otherwise</source>
          <target state="translated">一个简单的例子,如果所有元素小于5,则发射true,否则发射false。</target>
        </trans-unit>
        <trans-unit id="81e41a4a8e6d911462364fa9ad372501ccb3129c" translate="yes" xml:space="preserve">
          <source>A simple example with numbers</source>
          <target state="translated">一个简单的数字例子</target>
        </trans-unit>
        <trans-unit id="0017d7fc0455f54b0b0d3ac7b46d34bb31004b1b" translate="yes" xml:space="preserve">
          <source>A static factory for a Subscriber, given a (potentially partial) definition of an Observer.</source>
          <target state="translated">一个给定(可能是部分)Observer定义的Subscriber的静态工厂。</target>
        </trans-unit>
        <trans-unit id="1a80de59cfb7fce6af657c15200a9ea50fa95ff4" translate="yes" xml:space="preserve">
          <source>A test example with specified values:</source>
          <target state="translated">一个带有指定值的测试示例。</target>
        </trans-unit>
        <trans-unit id="5904f92e91374bb07f1b8a9b7cf799d0276598a4" translate="yes" xml:space="preserve">
          <source>A test example with subscription assertions:</source>
          <target state="translated">一个带有订阅断言的测试例子。</target>
        </trans-unit>
        <trans-unit id="6d05f99bacc1009f0378c940ffbdf08d8d33492a" translate="yes" xml:space="preserve">
          <source>A typical example of a creation operator would be the &lt;code&gt;interval&lt;/code&gt; function. It takes a number (not an Observable) as input argument, and produces an Observable as output:</source>
          <target state="translated">创建运算符的典型示例是 &lt;code&gt;interval&lt;/code&gt; 函数。它以数字（不是Observable）作为输入参数，并产生Observable作为输出：</target>
        </trans-unit>
        <trans-unit id="b3423f2e2a7685acbd8fc5ab4ba2ea70e1e221bb" translate="yes" xml:space="preserve">
          <source>A variant of Subject that &quot;replays&quot; or emits old values to new subscribers. It buffers a set number of values and will emit those values immediately to any new subscribers in addition to emitting new values to existing subscribers.</source>
          <target state="translated">Subject的一个变体,它可以 &quot;重播 &quot;或向新的订阅者发射旧的值。它缓冲了一定数量的值,除了向现有的订阅者发送新的值之外,还将立即向任何新的订阅者发送这些值。</target>
        </trans-unit>
        <trans-unit id="77bd200819e8216578aa6a20682297a4fcdf7791" translate="yes" xml:space="preserve">
          <source>A variant of Subject that only emits a value when it completes. It will emit its latest value to all its observers on completion.</source>
          <target state="translated">Subject的一个变体,只有在完成时才会发出一个值,它将在完成时向所有观察者发出它的最新值。它将在完成时向所有观察者发出最新值。</target>
        </trans-unit>
        <trans-unit id="ce13e7226e5fa3326a58386cbacfa231b35fc1b1" translate="yes" xml:space="preserve">
          <source>A variant of Subject that requires an initial value and emits its current value whenever it is subscribed to.</source>
          <target state="translated">Subject的一个变体,需要一个初始值,每当它被订阅时,就会发出它的当前值。</target>
        </trans-unit>
        <trans-unit id="d93d10ff0fbef1b4aa0ddc24e10e907746d3c85a" translate="yes" xml:space="preserve">
          <source>API</source>
          <target state="translated">API</target>
        </trans-unit>
        <trans-unit id="6970dba4e61b8a8291ad7482373472fd7ab1cb7e" translate="yes" xml:space="preserve">
          <source>Accepts an &lt;code&gt;Array&lt;/code&gt; of &lt;a href=&quot;../type-alias/observableinput&quot;&gt;&lt;code&gt;ObservableInput&lt;/code&gt;&lt;/a&gt; or a dictionary &lt;code&gt;Object&lt;/code&gt; of &lt;a href=&quot;../type-alias/observableinput&quot;&gt;&lt;code&gt;ObservableInput&lt;/code&gt;&lt;/a&gt; and returns an &lt;a href=&quot;../class/observable&quot;&gt;&lt;code&gt;Observable&lt;/code&gt;&lt;/a&gt; that emits either an array of values in the exact same order as the passed array, or a dictionary of values in the same shape as the passed dictionary.</source>
          <target state="translated">接受一个 &lt;code&gt;Array&lt;/code&gt; 的&lt;a href=&quot;../type-alias/observableinput&quot;&gt; &lt;code&gt;ObservableInput&lt;/code&gt; &lt;/a&gt;或字典 &lt;code&gt;Object&lt;/code&gt; 的&lt;a href=&quot;../type-alias/observableinput&quot;&gt; &lt;code&gt;ObservableInput&lt;/code&gt; &lt;/a&gt;并返回一个&lt;a href=&quot;../class/observable&quot;&gt; &lt;code&gt;Observable&lt;/code&gt; &lt;/a&gt;发射任一值的确切相同的顺序传递的数组，或值的相同的形状，所传递的辞典的辞典的阵列。</target>
        </trans-unit>
        <trans-unit id="f302cad0f3e21130c578083076708337124b26be" translate="yes" xml:space="preserve">
          <source>Add fallback observable</source>
          <target state="translated">增加后备观测设备</target>
        </trans-unit>
        <trans-unit id="04b3ddff5046a21c4d3de14d423344ef2017b089" translate="yes" xml:space="preserve">
          <source>Add type definition file included in tsconfig.json or CLI argument.</source>
          <target state="translated">添加包含在tsconfig.json中的类型定义文件或CLI参数。</target>
        </trans-unit>
        <trans-unit id="e96e9902a32c66c0b71790ad6985f9dd53265b5c" translate="yes" xml:space="preserve">
          <source>Additionally, subscriptions may be grouped together through the &lt;code&gt;add()&lt;/code&gt; method, which will attach a child Subscription to the current Subscription. When a Subscription is unsubscribed, all its children (and its grandchildren) will be unsubscribed as well.</source>
          <target state="translated">此外，可以通过 &lt;code&gt;add()&lt;/code&gt; 方法将订阅分组在一起，这会将子订阅附加到当前订阅。取消订阅后，其所有子项（及其子孙）也将被取消订阅。</target>
        </trans-unit>
        <trans-unit id="0aa18f6c9ead1c7ca1c22b5cfd3ff2341aea9ebe" translate="yes" xml:space="preserve">
          <source>Adds a tear down to be called during the unsubscribe() of this Subscription. Can also be used to add a child subscription.</source>
          <target state="translated">添加一个在该订阅的取消订阅()期间被调用的取消订阅。也可用于添加一个子订阅。</target>
        </trans-unit>
        <trans-unit id="fdd3e24e6fb92b8a42d2faa20d75b3f18d75c394" translate="yes" xml:space="preserve">
          <source>After Observable emits value, it will complete immediately. This means even if &lt;code&gt;func&lt;/code&gt; calls callback again, values from second and consecutive calls will never appear on the stream. If you need to handle functions that call callbacks multiple times, check out &lt;a href=&quot;fromevent&quot;&gt;&lt;code&gt;fromEvent&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;fromeventpattern&quot;&gt;&lt;code&gt;fromEventPattern&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">Observable发出值后，它将立即完成。这意味着即使 &lt;code&gt;func&lt;/code&gt; 再次调用回调，来自第二次和连续调用的值也将永远不会出现在流中。如果您需要处理多次调用回调的函数，请&lt;a href=&quot;fromevent&quot;&gt; &lt;code&gt;fromEvent&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;fromeventpattern&quot;&gt; &lt;code&gt;fromEventPattern&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="62e230c5906ba4af3b736e1edf79883437e056f5" translate="yes" xml:space="preserve">
          <source>After registration, every time an event that we listen to happens, Observable returned by &lt;code&gt;fromEventPattern&lt;/code&gt; will emit value that event handler function was called with. Note that if event handler was called with more then one argument, second and following arguments will not appear in the Observable.</source>
          <target state="translated">注册后，每次我们监听的事件发生时， &lt;code&gt;fromEventPattern&lt;/code&gt; 返回的Observable都会发出调用事件处理函数的值。请注意，如果事件处理程序被多个参数调用，则第二个及后续参数将不会出现在Observable中。</target>
        </trans-unit>
        <trans-unit id="01e81606a47771087aa940effff843c4b9eaabf0" translate="yes" xml:space="preserve">
          <source>After the source observable completes, appends an emission and then completes too.</source>
          <target state="translated">在源观测完成后,附加一个发射,然后也完成。</target>
        </trans-unit>
        <trans-unit id="812b4c6aa91173811b26dca0debd2d93641cd98c" translate="yes" xml:space="preserve">
          <source>AjaxError</source>
          <target state="translated">AjaxError</target>
        </trans-unit>
        <trans-unit id="e1175723771662904588d76a2118378edca8e6d8" translate="yes" xml:space="preserve">
          <source>AjaxRequest</source>
          <target state="translated">AjaxRequest</target>
        </trans-unit>
        <trans-unit id="b50c373483c8fcf45654d5d17af76c8e637c982d" translate="yes" xml:space="preserve">
          <source>AjaxResponse</source>
          <target state="translated">AjaxResponse</target>
        </trans-unit>
        <trans-unit id="9af59b49cf059f9d459db29a4d043d065589afb4" translate="yes" xml:space="preserve">
          <source>AjaxTimeoutError</source>
          <target state="translated">AjaxTimeoutError</target>
        </trans-unit>
        <trans-unit id="105cfe4477aacf8249d3536b4bf75dabe360f308" translate="yes" xml:space="preserve">
          <source>Align the start of &lt;code&gt;xsubs&lt;/code&gt; and &lt;code&gt;ysubs&lt;/code&gt; diagrams with &lt;code&gt;expected&lt;/code&gt; diagram.</source>
          <target state="translated">将 &lt;code&gt;xsubs&lt;/code&gt; 和 &lt;code&gt;ysubs&lt;/code&gt; 图的开始与 &lt;code&gt;expected&lt;/code&gt; 图对齐。</target>
        </trans-unit>
        <trans-unit id="6ef4c56f1f3170c1f08a8ed6c2e4fe9df4af5b0f" translate="yes" xml:space="preserve">
          <source>All Module Types (CJS/ES6/AMD/TypeScript) via npm</source>
          <target state="translated">所有模块类型(CJS/ES6/AMD/TypeScript)通过npm实现</target>
        </trans-unit>
        <trans-unit id="514510db8c4150ad0ec84a47308b42bde697ded1" translate="yes" xml:space="preserve">
          <source>All observable classes (&lt;a href=&quot;https://github.com/ReactiveX/rxjs/tree/5.5.8/src/observable&quot;&gt;https://github.com/ReactiveX/rxjs/tree/5.5.8/src/observable&lt;/a&gt;) have been removed from v6, in favor of existing or new operators that perform the same operations as the class methods. For example, &lt;code&gt;ArrayObservable.create(myArray)&lt;/code&gt; can be replaced by &lt;code&gt;from(myArray)&lt;/code&gt;, or the new operator &lt;code&gt;fromArray()&lt;/code&gt;.</source>
          <target state="translated">从v6中删除了所有可观察的类（&lt;a href=&quot;https://github.com/ReactiveX/rxjs/tree/5.5.8/src/observable&quot;&gt;https://github.com/ReactiveX/rxjs/tree/5.5.8/src/observable&lt;/a&gt;），以支持执行与类方法相同的操作的现有或新运算符。例如， &lt;code&gt;ArrayObservable.create(myArray)&lt;/code&gt; 可以由 &lt;code&gt;from(myArray)&lt;/code&gt; 或新的运算符 &lt;code&gt;fromArray()&lt;/code&gt; 代替。</target>
        </trans-unit>
        <trans-unit id="0570b2ca99e5e7005b25a7d91319eade51046745" translate="yes" xml:space="preserve">
          <source>Also see the &lt;a href=&quot;operators#join-creation-operators&quot;&gt;Join Creation Operators&lt;/a&gt; section above.</source>
          <target state="translated">另请参见上面的&amp;ldquo; &lt;a href=&quot;operators#join-creation-operators&quot;&gt;加入创建运算符&amp;rdquo;&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="ddc4de29faa4779f5e84f09b14c51796f6f1d9db" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;run()&lt;/code&gt; executes entirely synchronously, the helper functions inside your callback function do not! These functions &lt;strong&gt;schedule assertions&lt;/strong&gt; that will execute either when your callback completes or when you explicitly call &lt;code&gt;flush()&lt;/code&gt;. Be wary of calling synchronous assertions, for example &lt;code&gt;expect&lt;/code&gt; from your testing library of choice, from within the callback. See &lt;a href=&quot;marble-testing#synchronous-assertion&quot;&gt;Synchronous Assertion&lt;/a&gt; for more information on how to do this.</source>
          <target state="translated">尽管 &lt;code&gt;run()&lt;/code&gt; 完全同步执行，但回调函数中的帮助器函数却没有！这些函数&lt;strong&gt;计划&lt;/strong&gt;在回调完成或显式调用 &lt;code&gt;flush()&lt;/code&gt; 时执行的&lt;strong&gt;断言&lt;/strong&gt;。警惕调用同步断言，例如， &lt;code&gt;expect&lt;/code&gt; 从您选择的测试库中，从回调中调用。有关如何执行此操作的更多信息，请参见&lt;a href=&quot;marble-testing#synchronous-assertion&quot;&gt;同步声明&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7290a7b1e738919f1fad7cc0ff505aa61251a321" translate="yes" xml:space="preserve">
          <source>Although this collection is not event target in itself, &lt;code&gt;fromEvent&lt;/code&gt; will iterate over all Nodes it contains and install event handler function in every of them. When returned Observable is unsubscribed, function will be removed from all Nodes.</source>
          <target state="translated">尽管此集合本身并不是事件目标， &lt;code&gt;fromEvent&lt;/code&gt; 将遍历它包含的所有Node，并在每个Node中安装事件处理函数。返回的Observable取消订阅后，该功能将从所有Node中删除。</target>
        </trans-unit>
        <trans-unit id="2f3d96867ef3ae1b957b32b3ee78a80f323ec3df" translate="yes" xml:space="preserve">
          <source>An &lt;strong&gt;Observable&lt;/strong&gt; is a lazily evaluated computation that can synchronously or asynchronously return zero to (potentially) infinite values from the time it's invoked onwards.</source>
          <target state="translated">一个&lt;strong&gt;可观察&lt;/strong&gt;是懒洋洋地评估计算，并可以同步或异步从它开始被调用时返回零（潜在的）无限值。</target>
        </trans-unit>
        <trans-unit id="fdabd30359339d2f65c66d1635f6a6017447f842" translate="yes" xml:space="preserve">
          <source>An Observable representing values belonging to the same group represented by a common key. The values emitted by a GroupedObservable come from the source Observable. The common key is available as the field &lt;code&gt;key&lt;/code&gt; on a GroupedObservable instance.</source>
          <target state="translated">一个Observable表示值，该值属于由公共键表示的同一组。GroupedObservable发出的值来自源Observable。公用密钥可用作GroupedObservable实例上的字段 &lt;code&gt;key&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2126f07d8b41f5aaca35b6c0b56828a7558936a0" translate="yes" xml:space="preserve">
          <source>An Observable that completes the previous window and starts a new window.</source>
          <target state="translated">完成前一个窗口并启动新窗口的Observable。</target>
        </trans-unit>
        <trans-unit id="eef9d9f524886759c9f7f7b8471abe2dc0dbd650" translate="yes" xml:space="preserve">
          <source>An Observable that emits no items to the Observer and never completes.</source>
          <target state="translated">一个Observable,没有向Observer发出任何项目,并且永远不会完成。</target>
        </trans-unit>
        <trans-unit id="f5a1fcfb06b841150430ba58a7521f53ce01d9a1" translate="yes" xml:space="preserve">
          <source>An Observable that signals the buffer to be emitted on the output Observable.</source>
          <target state="translated">在输出Observable上发出缓冲区信号的Observable。</target>
        </trans-unit>
        <trans-unit id="a31b174ccd32d747b6510dfee065773758e2d469" translate="yes" xml:space="preserve">
          <source>An Observable that triggers the subscription to the source Observable once it emits any value.</source>
          <target state="translated">一个Observable,一旦源Observable发出任何值,就会触发对它的订阅。</target>
        </trans-unit>
        <trans-unit id="773261e3c36d88f960d0387c51370a6a26126228" translate="yes" xml:space="preserve">
          <source>An Observable to replace each value from the source Observable.</source>
          <target state="translated">一个Observable来替换源Observable的每个值。</target>
        </trans-unit>
        <trans-unit id="b6e7ad14921bdce569edd7b5b3ca7dca5e12aabd" translate="yes" xml:space="preserve">
          <source>An Observer &lt;code&gt;complete&lt;/code&gt; callback.</source>
          <target state="translated">观察者 &lt;code&gt;complete&lt;/code&gt; 回调。</target>
        </trans-unit>
        <trans-unit id="8d40920acd75345296d3a12fbe36dadd5106b59a" translate="yes" xml:space="preserve">
          <source>An Observer &lt;code&gt;error&lt;/code&gt; callback.</source>
          <target state="translated">观察者 &lt;code&gt;error&lt;/code&gt; 回调。</target>
        </trans-unit>
        <trans-unit id="d2e15da54f48a5ffa62a9bd03b8be8923ce3223c" translate="yes" xml:space="preserve">
          <source>An Observer &lt;code&gt;next&lt;/code&gt; callback.</source>
          <target state="translated">观察者的 &lt;code&gt;next&lt;/code&gt; 回调。</target>
        </trans-unit>
        <trans-unit id="290534edc14a92a2f20f67f00211fac900855530" translate="yes" xml:space="preserve">
          <source>An Observer or the &lt;code&gt;next&lt;/code&gt; callback.</source>
          <target state="translated">观察者或 &lt;code&gt;next&lt;/code&gt; 回调。</target>
        </trans-unit>
        <trans-unit id="8142d3c4512e5fc9ab5b382e6d48c2f2c070d795" translate="yes" xml:space="preserve">
          <source>An Observer than watches when close events occur on the underlying webSocket</source>
          <target state="translated">当底层webSocket上发生关闭事件时,观察者会观察该事件。</target>
        </trans-unit>
        <trans-unit id="7657d899f5aaec99147ebbd9f77e9b0e634b3882" translate="yes" xml:space="preserve">
          <source>An Observer that watches when a close is about to occur due to unsubscription.</source>
          <target state="translated">观察者,观察因退订而即将发生的平仓。</target>
        </trans-unit>
        <trans-unit id="3132b8e54e0ef31bfe72f5ff852390ecf6b3479f" translate="yes" xml:space="preserve">
          <source>An Observer that watches when open events occur on the underlying web socket.</source>
          <target state="translated">一个观察者,用于观察底层web套接字上何时发生打开事件。</target>
        </trans-unit>
        <trans-unit id="91c0a696b86c72c060aa4384dcb22d8de7a3a054" translate="yes" xml:space="preserve">
          <source>An error thrown when an Observable or a sequence was queried but has no elements.</source>
          <target state="translated">当查询到一个Observable或序列但没有元素时,就会产生错误。</target>
        </trans-unit>
        <trans-unit id="da13ad6095d69814a5801a7d120440a1d6cab007" translate="yes" xml:space="preserve">
          <source>An error thrown when an action is invalid because the object has been unsubscribed.</source>
          <target state="translated">当一个操作因对象被取消订阅而无效时抛出的错误。</target>
        </trans-unit>
        <trans-unit id="edcf9ad5deaa38ba68865544115b17e656d8234c" translate="yes" xml:space="preserve">
          <source>An error thrown when an element was queried at a certain index of an Observable, but no such index or position exists in that sequence.</source>
          <target state="translated">当一个元素在Observable的某个索引处被查询,但在该序列中不存在这样的索引或位置时,抛出的错误。</target>
        </trans-unit>
        <trans-unit id="e3bba335f950fd7f62a4632dd56239ddfb99ade9" translate="yes" xml:space="preserve">
          <source>An error thrown when duetime elapses.</source>
          <target state="translated">当duetime过期时,抛出一个错误。</target>
        </trans-unit>
        <trans-unit id="351c9f6fe481a21cfd383241cc681a6e67328aa7" translate="yes" xml:space="preserve">
          <source>An error thrown when one or more errors have occurred during the &lt;code&gt;unsubscribe&lt;/code&gt; of a &lt;a href=&quot;../class/subscription&quot;&gt;&lt;code&gt;Subscription&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">当在发生一个或多个错误所引发的错误 &lt;code&gt;unsubscribe&lt;/code&gt; 一个的&lt;a href=&quot;../class/subscription&quot;&gt; &lt;code&gt;Subscription&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9db7036f458eae0a4e55d2760ffc791aecceeada" translate="yes" xml:space="preserve">
          <source>An example comparing the first letters of the name</source>
          <target state="translated">比较名字的前几个字母的例子。</target>
        </trans-unit>
        <trans-unit id="e65a68f21295f409926b7be91cbe2fa484218580" translate="yes" xml:space="preserve">
          <source>An example comparing the name of persons</source>
          <target state="translated">比较人名的例子</target>
        </trans-unit>
        <trans-unit id="01e0a637d42f33d5f806ef0237a5736686d5cbad" translate="yes" xml:space="preserve">
          <source>An example using a compare function</source>
          <target state="translated">使用比较函数的例子</target>
        </trans-unit>
        <trans-unit id="97a9626aa65abda5d59774630093d7b017384c98" translate="yes" xml:space="preserve">
          <source>An example using a keySelector function</source>
          <target state="translated">一个使用keySelector函数的例子</target>
        </trans-unit>
        <trans-unit id="b56783c677e083451fb563ec7d3d0942623e25d6" translate="yes" xml:space="preserve">
          <source>An execution context and a data structure to order tasks and schedule their execution. Provides a notion of (potentially virtual) time, through the &lt;code&gt;now()&lt;/code&gt; getter method.</source>
          <target state="translated">执行上下文和数据结构，用于对任务进行排序并安排其执行时间。通过 &lt;code&gt;now()&lt;/code&gt; getter方法提供（可能是虚拟的）时间的概念。</target>
        </trans-unit>
        <trans-unit id="8dd554f8f53b0e7325a2a34d17ed08bf4a5f2f7b" translate="yes" xml:space="preserve">
          <source>An object with &lt;code&gt;addListener&lt;/code&gt; and &lt;code&gt;removeListener&lt;/code&gt; methods.</source>
          <target state="translated">具有 &lt;code&gt;addListener&lt;/code&gt; 和 &lt;code&gt;removeListener&lt;/code&gt; 方法的对象。</target>
        </trans-unit>
        <trans-unit id="8764ac07674a81492e4055cbd5febfdaa5d400ac" translate="yes" xml:space="preserve">
          <source>An object with &lt;code&gt;on&lt;/code&gt; and &lt;code&gt;off&lt;/code&gt; methods</source>
          <target state="translated">具有 &lt;code&gt;on&lt;/code&gt; 和 &lt;code&gt;off&lt;/code&gt; 方法的对象</target>
        </trans-unit>
        <trans-unit id="9e40e670213d473533cefd4270f561e8408dc324" translate="yes" xml:space="preserve">
          <source>An observable of notifications to start new windows.</source>
          <target state="translated">一个可观察到的启动新窗口的通知。</target>
        </trans-unit>
        <trans-unit id="4600b8f07b4000ea590f0835556e6c2afb8552ae" translate="yes" xml:space="preserve">
          <source>An optional argument to define what &lt;code&gt;this&lt;/code&gt; is in the &lt;code&gt;project&lt;/code&gt; function.</source>
          <target state="translated">一个可选的参数来定义什么 &lt;code&gt;this&lt;/code&gt; 是在 &lt;code&gt;project&lt;/code&gt; 功能。</target>
        </trans-unit>
        <trans-unit id="dcc798e4ed4023df36df2945f6d44acbe266748f" translate="yes" xml:space="preserve">
          <source>An optional argument to determine the value of &lt;code&gt;this&lt;/code&gt; in the &lt;code&gt;predicate&lt;/code&gt; function.</source>
          <target state="translated">一个可选的参数来确定的值， &lt;code&gt;this&lt;/code&gt; 在 &lt;code&gt;predicate&lt;/code&gt; 功能。</target>
        </trans-unit>
        <trans-unit id="0f8b9e0b704b92c65ddc070628f4835bbb78aeac" translate="yes" xml:space="preserve">
          <source>An optional default value to provide if last predicate isn't met or no values were emitted.</source>
          <target state="translated">如果最后一个谓词没有被满足或没有发出值,则提供一个可选的默认值。</target>
        </trans-unit>
        <trans-unit id="e052978179167326c8d61eac34c703447b1e61fb" translate="yes" xml:space="preserve">
          <source>An optional function called with each item to test for condition matching.</source>
          <target state="translated">一个可选函数,用于测试每个项目的条件匹配。</target>
        </trans-unit>
        <trans-unit id="11fde83a782627f966a91292359ee23e91c0e522" translate="yes" xml:space="preserve">
          <source>An optional function to compare each value pair</source>
          <target state="translated">一个可选的函数,用于比较每个值对</target>
        </trans-unit>
        <trans-unit id="44db2f22e6b5dff55846c4998171a7b720c141ea" translate="yes" xml:space="preserve">
          <source>Anatomy of a Test</source>
          <target state="translated">剖析测试</target>
        </trans-unit>
        <trans-unit id="d54c716cf2e4abcaf1f883f748f7d86e57c136a9" translate="yes" xml:space="preserve">
          <source>Anatomy of an Observable</source>
          <target state="translated">可观察的解剖学</target>
        </trans-unit>
        <trans-unit id="f5680c78958499a16c8fcf9016c85188d194ba63" translate="yes" xml:space="preserve">
          <source>And the output is the same:</source>
          <target state="translated">而输出是一样的。</target>
        </trans-unit>
        <trans-unit id="ef4d4c6fb57c79a8162041f226c5e4efb9e26af4" translate="yes" xml:space="preserve">
          <source>And the output is:</source>
          <target state="translated">而输出的是。</target>
        </trans-unit>
        <trans-unit id="2198b9b68b5a6618e09f564fa6fda9a820559da6" translate="yes" xml:space="preserve">
          <source>And this is the same behavior with Observables:</source>
          <target state="translated">而这也是Observables的行为。</target>
        </trans-unit>
        <trans-unit id="214aff037545c6d78b224ab75b946443ebeacca1" translate="yes" xml:space="preserve">
          <source>Animation Frame Scheduler</source>
          <target state="translated">动画帧调度器</target>
        </trans-unit>
        <trans-unit id="0dd0b75d03698b8df77f879fc79e7a964c400184" translate="yes" xml:space="preserve">
          <source>Any and all items emitted by the source Observable will be emitted by the resulting Observable, even those emitted during failed subscriptions. For example, if an Observable fails at first but emits [1, 2] then succeeds the second time and emits: [1, 2, 3, 4, 5] then the complete stream of emissions and notifications would be: [1, 2, 1, 2, 3, 4, 5, &lt;code&gt;complete&lt;/code&gt;].</source>
          <target state="translated">源Observable发出的所有项目都将由结果Observable发出，即使是在订阅失败期间发出的项目也是如此。例如，如果一个Observable首先失败，但发出[1，2]，然后第二次成功，并发出：[1,2,3,4,5]，则发出和通知的完整流将是：[1,2,3 ，1、2、3、4、5， &lt;code&gt;complete&lt;/code&gt; ]。</target>
        </trans-unit>
        <trans-unit id="d23ece9441868386248d50c2f4a407afa2b6ac2c" translate="yes" xml:space="preserve">
          <source>Any library that imports a patch operator will augment the &lt;code&gt;Observable.prototype&lt;/code&gt; for all consumers of that library, creating blind dependencies. If the library removes their usage, they unknowingly break everyone else. With pipeables, you have to import the operators you need into each file you use them in.</source>
          <target state="translated">导入修补程序运算符的任何库都将为该库的所有使用者扩展 &lt;code&gt;Observable.prototype&lt;/code&gt; ，从而创建盲目依赖。如果库删除了它们的用法，它们将在不知不觉中破坏其他所有人。使用pipeable，必须将所需的运算符导入使用它们的每个文件中。</target>
        </trans-unit>
        <trans-unit id="5a9be752cd40fb5aa6726b480b2cc085a184fb0b" translate="yes" xml:space="preserve">
          <source>Any number of Observables provided either as an array or as an arguments passed directly to the operator.</source>
          <target state="translated">任何数量的Observables都可以作为数组或直接传递给操作者的参数提供。</target>
        </trans-unit>
        <trans-unit id="7a81bf5d2d1e477c23e38f5412482a72481c13bc" translate="yes" xml:space="preserve">
          <source>Apart from starting the execution of an Observable, this method allows you to listen for values that an Observable emits, as well as for when it completes or errors. You can achieve this in two of the following ways.</source>
          <target state="translated">除了开始执行一个Observable之外,这个方法还允许您监听一个Observable发出的值,以及它何时完成或出错。您可以通过以下两种方式来实现这一点。</target>
        </trans-unit>
        <trans-unit id="ff7736e9905851cb4d03cef20435fde04d60ad18" translate="yes" xml:space="preserve">
          <source>Applies a given &lt;code&gt;project&lt;/code&gt; function to each value emitted by the source Observable, and emits the resulting values as an Observable.</source>
          <target state="translated">将给定的 &lt;code&gt;project&lt;/code&gt; 函数应用于源Observable发出的每个值，并将结果值作为Observable发出。</target>
        </trans-unit>
        <trans-unit id="fb6220c1b034dd6ba15056fd67c656e6ac8dbc7a" translate="yes" xml:space="preserve">
          <source>Applies an accumulator function over the source Observable where the accumulator function itself returns an Observable, then each intermediate Observable returned is merged into the output Observable.</source>
          <target state="translated">在源Observable上应用累加器函数,其中累加器函数本身返回一个Observable,然后将返回的每个中间Observable合并到输出Observable中。</target>
        </trans-unit>
        <trans-unit id="18af990d85065af126fe49df23d1000d8f9bea14" translate="yes" xml:space="preserve">
          <source>Applies an accumulator function over the source Observable, and returns each intermediate result, with an optional seed value.</source>
          <target state="translated">在源Observable上应用一个累加器函数,并返回每个中间结果,并附带一个可选的种子值。</target>
        </trans-unit>
        <trans-unit id="896a5a66d1584a3cd0b7ce73ba41aa2daa7bfdd6" translate="yes" xml:space="preserve">
          <source>Applies an accumulator function over the source Observable, and returns the accumulated result when the source completes, given an optional seed value.</source>
          <target state="translated">在源Observable上应用一个累加器函数,并在源完成时返回累加结果,给定一个可选的种子值。</target>
        </trans-unit>
        <trans-unit id="0cbc9507c24ae88b47a008f6d590f27d4404b1b6" translate="yes" xml:space="preserve">
          <source>ArgumentOutOfRangeError</source>
          <target state="translated">ArgumentOutOfRangeError</target>
        </trans-unit>
        <trans-unit id="d06d786204f911793c3c415d554d0f4e76454fb1" translate="yes" xml:space="preserve">
          <source>ArrayLikeObservable</source>
          <target state="translated">ArrayLikeObservable</target>
        </trans-unit>
        <trans-unit id="668878ff5d1e1cf54d4ec1d029de7b2fb934a432" translate="yes" xml:space="preserve">
          <source>ArrayObservable</source>
          <target state="translated">ArrayObservable</target>
        </trans-unit>
        <trans-unit id="66dcfefb4f4c7b689358e87ea28105b7823f1fa7" translate="yes" xml:space="preserve">
          <source>As a matter of fact, &lt;code&gt;observeOn&lt;/code&gt; accepts second parameter, which specifies in milliseconds with what delay notifications will be emitted. The main difference between &lt;a href=&quot;delay&quot;&gt;&lt;code&gt;delay&lt;/code&gt;&lt;/a&gt; operator and &lt;code&gt;observeOn&lt;/code&gt; is that &lt;code&gt;observeOn&lt;/code&gt; will delay all notifications - including error notifications - while &lt;code&gt;delay&lt;/code&gt; will pass through error from source Observable immediately when it is emitted. In general it is highly recommended to use &lt;code&gt;delay&lt;/code&gt; operator for any kind of delaying of values in the stream, while using &lt;code&gt;observeOn&lt;/code&gt; to specify which scheduler should be used for notification emissions in general.</source>
          <target state="translated">实际上， &lt;code&gt;observeOn&lt;/code&gt; 接受第二个参数，该参数以毫秒为单位指定将发出哪些延迟通知。&lt;a href=&quot;delay&quot;&gt; &lt;code&gt;delay&lt;/code&gt; &lt;/a&gt;运算符和 &lt;code&gt;observeOn&lt;/code&gt; 之间的主要区别是 &lt;code&gt;observeOn&lt;/code&gt; 将延迟所有通知（包括错误通知），而 &lt;code&gt;delay&lt;/code&gt; 将在发出时立即通过源Observable的错误传递。通常，强烈建议对流中的任何类型的值延迟使用 &lt;code&gt;delay&lt;/code&gt; 运算符，而 &lt;code&gt;observeOn&lt;/code&gt; 使用observeOn来指定应将哪个调度程序用于通知发射。</target>
        </trans-unit>
        <trans-unit id="3d5c716ac8bd96d9826faee7f9bc5e977aad794e" translate="yes" xml:space="preserve">
          <source>As a stylistic matter, &lt;code&gt;op()(obs)&lt;/code&gt; is never used, even if there is only one operator; &lt;code&gt;obs.pipe(op())&lt;/code&gt; is universally preferred.</source>
          <target state="translated">从风格 &lt;code&gt;op()(obs)&lt;/code&gt; ，即使只有一个运算符，也不会使用op（）（obs）。 &lt;code&gt;obs.pipe(op())&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="968f7565b22c962aa3c40415db42dac7b144a148" translate="yes" xml:space="preserve">
          <source>As in &lt;a href=&quot;bindcallback&quot;&gt;&lt;code&gt;bindCallback&lt;/code&gt;&lt;/a&gt;, context (&lt;code&gt;this&lt;/code&gt; property) of input function will be set to context of returned function, when it is called.</source>
          <target state="translated">与&lt;a href=&quot;bindcallback&quot;&gt; &lt;code&gt;bindCallback&lt;/code&gt; 中一样&lt;/a&gt;，输入函数的上下文（ &lt;code&gt;this&lt;/code&gt; 属性）在被调用时将设置为返回函数的上下文。</target>
        </trans-unit>
        <trans-unit id="54800d323d149aa9eb668c0c0768a97a0cc7370b" translate="yes" xml:space="preserve">
          <source>Asap Scheduler</source>
          <target state="translated">Asap Scheduler</target>
        </trans-unit>
        <trans-unit id="52a6e3d46a41f66b32f4c8d80361bb3892c5a671" translate="yes" xml:space="preserve">
          <source>Async Scheduler</source>
          <target state="translated">异步调度器</target>
        </trans-unit>
        <trans-unit id="81a3a332582f8b7c97ecac0a351df1689bfb7637" translate="yes" xml:space="preserve">
          <source>AsyncSubject</source>
          <target state="translated">AsyncSubject</target>
        </trans-unit>
        <trans-unit id="05e4550664a2860277fdca7625b41eb03e1da7ab" translate="yes" xml:space="preserve">
          <source>AsyncSubject._subscribe()</source>
          <target state="translated">AsyncSubject._subscribe()</target>
        </trans-unit>
        <trans-unit id="cdc3490a12008c174af711e0f3ece207778092a8" translate="yes" xml:space="preserve">
          <source>AsyncSubject.complete()</source>
          <target state="translated">AsyncSubject.complete()</target>
        </trans-unit>
        <trans-unit id="7ed8300fc48bbd3e79239add064fa42a036adee5" translate="yes" xml:space="preserve">
          <source>AsyncSubject.error()</source>
          <target state="translated">AsyncSubject.error()</target>
        </trans-unit>
        <trans-unit id="421d4487d1f2f065114b3871b83b0469818575a2" translate="yes" xml:space="preserve">
          <source>AsyncSubject.next()</source>
          <target state="translated">AsyncSubject.next()</target>
        </trans-unit>
        <trans-unit id="1f7d665c10ce012f074c9cbc8a3520a520d0e05d" translate="yes" xml:space="preserve">
          <source>Asynchronously subscribes Observers to this Observable on the specified &lt;a href=&quot;../index/interface/schedulerlike&quot;&gt;&lt;code&gt;SchedulerLike&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在指定的&lt;a href=&quot;../index/interface/schedulerlike&quot;&gt; &lt;code&gt;SchedulerLike&lt;/code&gt; &lt;/a&gt;上异步地使Observer订阅此Observable 。</target>
        </trans-unit>
        <trans-unit id="b422e2c59989bd1e00ff26b3cef6aec5666b0b25" translate="yes" xml:space="preserve">
          <source>At this time the TestScheduler can only be used to test code that uses timers, like delay/debounceTime/etc (i.e. it uses AsyncScheduler with delays &amp;gt; 1). If the code consumes a Promise or does scheduling with AsapScheduler/AnimationFrameScheduler/etc it cannot be reliably tested with TestScheduler, but instead should be tested more traditionally. See the &lt;a href=&quot;marble-testing#known-issues&quot;&gt;Known Issues&lt;/a&gt; section for more details.</source>
          <target state="translated">目前，TestScheduler仅可用于测试使用计时器的代码，例如delay / debounceTime / etc（即，它使用AsyncScheduler且延迟&amp;gt; 1）。如果代码占用Promise或使用AsapScheduler / AnimationFrameScheduler / etc进行调度，则无法使用TestScheduler对其进行可靠的测试，而应采用更传统的方式进行测试。有关更多详细信息，请参见&amp;ldquo; &lt;a href=&quot;marble-testing#known-issues&quot;&gt;已知问题&amp;rdquo;&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="068b119ae196b62a5a08d536ca924f4965b8125d" translate="yes" xml:space="preserve">
          <source>Attaches a timestamp to each item emitted by an observable indicating when it was emitted</source>
          <target state="translated">为观测到的每个项目附加一个时间戳,表明它是何时发出的。</target>
        </trans-unit>
        <trans-unit id="8fd78925dba59eef91afba0cdabe923520e5ee69" translate="yes" xml:space="preserve">
          <source>Backwards compatibility</source>
          <target state="translated">向后兼容性</target>
        </trans-unit>
        <trans-unit id="c8932006bc9fb215b4928a3cadf6c2845e613b82" translate="yes" xml:space="preserve">
          <source>Basic Use</source>
          <target state="translated">基本用途</target>
        </trans-unit>
        <trans-unit id="7308cb8418c068204c128968b5967fdf3606cc09" translate="yes" xml:space="preserve">
          <source>Basic methods</source>
          <target state="translated">基本方法</target>
        </trans-unit>
        <trans-unit id="59428be2e125d7f441079c691a9bbee761fe6cb1" translate="yes" xml:space="preserve">
          <source>Because Observable Executions may be infinite, and it's common for an Observer to want to abort execution in finite time, we need an API for canceling an execution. Since each execution is exclusive to one Observer only, once the Observer is done receiving values, it has to have a way to stop the execution, in order to avoid wasting computation power or memory resources.</source>
          <target state="translated">由于Observable Executions可能是无限的,而一个Observer想要在有限的时间内中止执行是很常见的,所以我们需要一个取消执行的API。由于每个执行只对一个Observer独占,所以一旦Observer接收完值,就必须有办法停止执行,以避免浪费计算能力或内存资源。</target>
        </trans-unit>
        <trans-unit id="3fe58a0f3e937be16a4d3adc3bbcdc21e755f616" translate="yes" xml:space="preserve">
          <source>Because RxJS uses the least concurrency scheduler, you can pick a different scheduler if you want to introduce concurrency for performance purpose. To specify a particular scheduler, you can use those operator methods that take a scheduler, e.g., &lt;code&gt;from([10, 20, 30], asyncScheduler)&lt;/code&gt;.</source>
          <target state="translated">由于RxJS使用最少的并发调度程序，因此如果您出于性能目的引入并发，则可以选择其他调度程序。要指定特定的调度程序，可以使用采用调度程序的那些运算符方法，例如 &lt;code&gt;from([10, 20, 30], asyncScheduler)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="86af633db829662420c6a9d8694edaad1afb49df" translate="yes" xml:space="preserve">
          <source>Before RxJS release v7, you will need to remove and replace all use of &lt;a href=&quot;migration#deprecations&quot;&gt;deprecated functionality&lt;/a&gt;.</source>
          <target state="translated">在RxJS v7发行版之前，您将需要删除和替换所有&lt;a href=&quot;migration#deprecations&quot;&gt;不推荐使用的功能&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6910ad273ef167a843b9c22fe90ab4067b73a2e7" translate="yes" xml:space="preserve">
          <source>Before RxJS releases v7, you will need to remove and replace all use of deprecated functionality. The following areas contain deprecated functionality:</source>
          <target state="translated">在RxJS发布v7之前,您需要删除和替换所有使用过的功能。以下区域包含废弃的功能。</target>
        </trans-unit>
        <trans-unit id="80a472e92e169440db08c5cb53e9880fe704c6ac" translate="yes" xml:space="preserve">
          <source>Before converting dot-chained operators to pipeable operators, make sure you import all operators used from &lt;code&gt;rxjs/operators&lt;/code&gt;. For example:</source>
          <target state="translated">在将点链运算符转换为可管道运算符之前，请确保从 &lt;code&gt;rxjs/operators&lt;/code&gt; 导入所有使用的运算符。例如：</target>
        </trans-unit>
        <trans-unit id="5427d9bbbb297506a892f764b0a10b1efb9ef3e2" translate="yes" xml:space="preserve">
          <source>Before you can remove the compatibility layer, you must refactor your code to use only pipeable operators. For Typescript, the &lt;code&gt;tslint&lt;/code&gt; tool automates the process to some extent, by applying the transform to well-typed code.</source>
          <target state="translated">在删除兼容性层之前，必须重构代码以仅使用可管道运算符。对于Typescript， &lt;code&gt;tslint&lt;/code&gt; 工具通过将转换应用于类型明确的代码来在某种程度上自动化该过程。</target>
        </trans-unit>
        <trans-unit id="5cb66fd20ca03a58764710f01cf907abc931d1ec" translate="yes" xml:space="preserve">
          <source>Behavior is different outside of &lt;code&gt;testScheduler.run(callback)&lt;/code&gt;</source>
          <target state="translated">在 &lt;code&gt;testScheduler.run(callback)&lt;/code&gt; 之外，行为是不同的</target>
        </trans-unit>
        <trans-unit id="368c978e94ba7ae5d0f5a362fef744af7dd7667e" translate="yes" xml:space="preserve">
          <source>BehaviorSubject</source>
          <target state="translated">BehaviorSubject</target>
        </trans-unit>
        <trans-unit id="09fcd7eca9f3082eeb05a34f8c6c349c912eacc6" translate="yes" xml:space="preserve">
          <source>BehaviorSubject._subscribe()</source>
          <target state="translated">BehaviorSubject._subscribe()</target>
        </trans-unit>
        <trans-unit id="656e17240ff3b7b269f8e9c364cfb41b688c27b5" translate="yes" xml:space="preserve">
          <source>BehaviorSubject.getValue()</source>
          <target state="translated">BehaviorSubject.getValue()</target>
        </trans-unit>
        <trans-unit id="2f226a2a37d46000d57385a4e6bc7b2abbb68c8b" translate="yes" xml:space="preserve">
          <source>BehaviorSubject.next()</source>
          <target state="translated">BehaviorSubject.next()</target>
        </trans-unit>
        <trans-unit id="df8979ce02d450847fa09bc10fa2a8741c7eea06" translate="yes" xml:space="preserve">
          <source>BehaviorSubjects are useful for representing &quot;values over time&quot;. For instance, an event stream of birthdays is a Subject, but the stream of a person's age would be a BehaviorSubject.</source>
          <target state="translated">BehaviorSubjects对于表示 &quot;随时间变化的值 &quot;很有用。例如,生日的事件流是一个Subject,但一个人的年龄流则是一个BehaviorSubject。</target>
        </trans-unit>
        <trans-unit id="3a70d04c1ef62c14933cff1c5df6d13ef6a06dc8" translate="yes" xml:space="preserve">
          <source>Below is an example:</source>
          <target state="translated">下面是一个例子。</target>
        </trans-unit>
        <trans-unit id="30731caf412562ba61e98248292d79cfc45fd636" translate="yes" xml:space="preserve">
          <source>Below you can see the anatomy of a marble diagram.</source>
          <target state="translated">下面你可以看到大理石的解剖图。</target>
        </trans-unit>
        <trans-unit id="ca1c302c34fc031ab37087b438ad1e0215b218b0" translate="yes" xml:space="preserve">
          <source>Both Observable &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; will emit their values directly and synchronously once they are subscribed to. This will result in the output of &lt;code&gt;1 2 3 4 5 6 7 8 9&lt;/code&gt;.</source>
          <target state="translated">一旦被观察，可观察的 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 都将直接且同步地发出它们的值。这将导致输出 &lt;code&gt;1 2 3 4 5 6 7 8 9&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9cb922bf8af8668272484b70ff6096a26125cc4f" translate="yes" xml:space="preserve">
          <source>Both forms of &lt;code&gt;generate&lt;/code&gt; can optionally accept a scheduler. In case of multi-parameter call, scheduler simply comes as a last argument (no matter if there is resultSelector function or not). In case of single-parameter call, you can provide it as a &lt;code&gt;scheduler&lt;/code&gt; property on object passed to the operator. In both cases scheduler decides when next iteration of the loop will happen and therefore when next value will be emitted by the Observable. For example to ensure that each value is pushed to the observer on separate task in event loop, you could use &lt;code&gt;async&lt;/code&gt; scheduler. Note that by default (when no scheduler is passed) values are simply emitted synchronously.</source>
          <target state="translated">这两种形式的 &lt;code&gt;generate&lt;/code&gt; 都可以选择接受调度程序。在多参数调用的情况下，调度程序只是作为最后一个参数出现（无论是否存在resultSelector函数）。如果是单参数调用，则可以将其作为传递给运算符的对象的 &lt;code&gt;scheduler&lt;/code&gt; 属性来提供。在这两种情况下，调度程序都会决定何时进行循环的下一次迭代，从而确定Observable何时发出下一个值。例如，要确保在事件循环中将每个值推送到单独任务上的观察者，可以使用 &lt;code&gt;async&lt;/code&gt; 调度程序。请注意，默认情况下（未传递调度程序时）将简单地同步发出值。</target>
        </trans-unit>
        <trans-unit id="5f36985eed9db6051e472734cab05c794944ca1d" translate="yes" xml:space="preserve">
          <source>BoundCallbackObservable</source>
          <target state="translated">BoundCallbackObservable</target>
        </trans-unit>
        <trans-unit id="7ed5f49381a89f00035a1e54c238c08417cd22c7" translate="yes" xml:space="preserve">
          <source>BoundNodeCallbackObservable</source>
          <target state="translated">BoundNodeCallbackObservable</target>
        </trans-unit>
        <trans-unit id="0d8754ad2d4f272c021b8a6de30806cf10b10891" translate="yes" xml:space="preserve">
          <source>Branch out the source Observable values as a nested Observable periodically in time.</source>
          <target state="translated">将源观测值作为一个嵌套的观测值周期性地分支出来。</target>
        </trans-unit>
        <trans-unit id="d5768cefc3dc6135e746fa10e7dc64978cd8c7d2" translate="yes" xml:space="preserve">
          <source>Branch out the source Observable values as a nested Observable starting from an emission from &lt;code&gt;openings&lt;/code&gt; and ending when the output of &lt;code&gt;closingSelector&lt;/code&gt; emits.</source>
          <target state="translated">将源Observable值分支为嵌套的Observable，该嵌套Observable值从 &lt;code&gt;openings&lt;/code&gt; 的发射开始，到 &lt;code&gt;closingSelector&lt;/code&gt; 的输出发出时结束。</target>
        </trans-unit>
        <trans-unit id="2f875199af965263013c9045ea52ec0e0f71c9b4" translate="yes" xml:space="preserve">
          <source>Branch out the source Observable values as a nested Observable using a factory function of closing Observables to determine when to start a new window.</source>
          <target state="translated">使用关闭Observables的工厂函数将源Observable值分支为一个嵌套的Observable,以决定何时启动一个新的窗口。</target>
        </trans-unit>
        <trans-unit id="d41ca8a818abab5874a4f5707cd8909fc3d690c8" translate="yes" xml:space="preserve">
          <source>Branch out the source Observable values as a nested Observable whenever &lt;code&gt;windowBoundaries&lt;/code&gt; emits.</source>
          <target state="translated">每当 &lt;code&gt;windowBoundaries&lt;/code&gt; 发出时，将源Observable值分支为嵌套的Observable 。</target>
        </trans-unit>
        <trans-unit id="5c9602d8a405448b7a2d3de72389356d74e29054" translate="yes" xml:space="preserve">
          <source>Branch out the source Observable values as a nested Observable with each nested Observable emitting at most &lt;code&gt;windowSize&lt;/code&gt; values.</source>
          <target state="translated">将源Observable值分支为嵌套的Observable，每个嵌套的Observable最多 &lt;code&gt;windowSize&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="a75f48b1b22b879f9c22d646edaa0759db697611" translate="yes" xml:space="preserve">
          <source>Breaking changes not covered by rxjs-compat</source>
          <target state="translated">rxjs-compat不包括的突破性变化。</target>
        </trans-unit>
        <trans-unit id="91726b714dab75ed3b7d092c95de02bacf38fad2" translate="yes" xml:space="preserve">
          <source>Buffers a number of values from the source Observable by &lt;code&gt;bufferSize&lt;/code&gt; then emits the buffer and clears it, and starts a new buffer each &lt;code&gt;startBufferEvery&lt;/code&gt; values. If &lt;code&gt;startBufferEvery&lt;/code&gt; is not provided or is &lt;code&gt;null&lt;/code&gt;, then new buffers are started immediately at the start of the source and when each buffer closes and is emitted.</source>
          <target state="translated">从source缓冲多个值，由 &lt;code&gt;bufferSize&lt;/code&gt; 观察，然后发出并清除该缓冲区，并为每个 &lt;code&gt;startBufferEvery&lt;/code&gt; 值启动一个新缓冲区。如果未提供 &lt;code&gt;startBufferEvery&lt;/code&gt; 或为 &lt;code&gt;null&lt;/code&gt; ，则新缓冲区将在源的开头以及每个缓冲区关闭并发出时立即启动。</target>
        </trans-unit>
        <trans-unit id="45860b887da4c0323bdef83a3c8f9aa2573f347f" translate="yes" xml:space="preserve">
          <source>Buffers the incoming Observable values until the given &lt;code&gt;closingNotifier&lt;/code&gt; Observable emits a value, at which point it emits the buffer on the output Observable and starts a new buffer internally, awaiting the next time &lt;code&gt;closingNotifier&lt;/code&gt; emits.</source>
          <target state="translated">缓冲传入的Observable值，直到给定的 &lt;code&gt;closingNotifier&lt;/code&gt; Observable发出一个值为止，这时它将在输出Observable上发出缓冲区，并在内部启动一个新的缓冲区，等待下一次 &lt;code&gt;closingNotifier&lt;/code&gt; 发出。</target>
        </trans-unit>
        <trans-unit id="15d7d3de47ff61c82d143794cb6ccfc5db3c977c" translate="yes" xml:space="preserve">
          <source>Buffers the source Observable values for a specific time period.</source>
          <target state="translated">缓冲特定时间段的源观测值。</target>
        </trans-unit>
        <trans-unit id="24cf8cc6ee5fcd728d08f9677bba84affa9b2ed5" translate="yes" xml:space="preserve">
          <source>Buffers the source Observable values starting from an emission from &lt;code&gt;openings&lt;/code&gt; and ending when the output of &lt;code&gt;closingSelector&lt;/code&gt; emits.</source>
          <target state="translated">缓冲源Observable值，该值从 &lt;code&gt;openings&lt;/code&gt; 的发射开始，到 &lt;code&gt;closingSelector&lt;/code&gt; 的输出发出时结束。</target>
        </trans-unit>
        <trans-unit id="5667b07dfc95ab11889cc351c1f1a6450c22be83" translate="yes" xml:space="preserve">
          <source>Buffers the source Observable values until &lt;code&gt;closingNotifier&lt;/code&gt; emits.</source>
          <target state="translated">缓冲源Observable值，直到发出 &lt;code&gt;closingNotifier&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aa0cc84b678395e32b914e69c26a7d621ee5a670" translate="yes" xml:space="preserve">
          <source>Buffers the source Observable values until the size hits the maximum &lt;code&gt;bufferSize&lt;/code&gt; given.</source>
          <target state="translated">缓冲源Observable值，直到大小达到给定的最大 &lt;code&gt;bufferSize&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="03884c4fb7d2e362201a4108c8ca60b6bfb2b71f" translate="yes" xml:space="preserve">
          <source>Buffers the source Observable values, using a factory function of closing Observables to determine when to close, emit, and reset the buffer.</source>
          <target state="translated">缓冲源Observable的值,使用关闭Observable的工厂功能来决定何时关闭、发射和重置缓冲区。</target>
        </trans-unit>
        <trans-unit id="eb04a2297b04b37862c0441dd71728bd5ba4a23a" translate="yes" xml:space="preserve">
          <source>Buffers values from the source by opening the buffer via signals from an Observable provided to &lt;code&gt;openings&lt;/code&gt;, and closing and sending the buffers when a Subscribable or Promise returned by the &lt;code&gt;closingSelector&lt;/code&gt; function emits.</source>
          <target state="translated">通过经由信号从设置到可观察打开缓冲器缓冲从所述源值 &lt;code&gt;openings&lt;/code&gt; ，和关闭及发送缓冲器当可订阅或无极返回由 &lt;code&gt;closingSelector&lt;/code&gt; 功能发射。</target>
        </trans-unit>
        <trans-unit id="12d7e4a57d8db25980df2b5e57d6a44630d2bef0" translate="yes" xml:space="preserve">
          <source>Buffers values from the source for a specific time duration &lt;code&gt;bufferTimeSpan&lt;/code&gt;. Unless the optional argument &lt;code&gt;bufferCreationInterval&lt;/code&gt; is given, it emits and resets the buffer every &lt;code&gt;bufferTimeSpan&lt;/code&gt; milliseconds. If &lt;code&gt;bufferCreationInterval&lt;/code&gt; is given, this operator opens the buffer every &lt;code&gt;bufferCreationInterval&lt;/code&gt; milliseconds and closes (emits and resets) the buffer every &lt;code&gt;bufferTimeSpan&lt;/code&gt; milliseconds. When the optional argument &lt;code&gt;maxBufferSize&lt;/code&gt; is specified, the buffer will be closed either after &lt;code&gt;bufferTimeSpan&lt;/code&gt; milliseconds or when it contains &lt;code&gt;maxBufferSize&lt;/code&gt; elements.</source>
          <target state="translated">在特定的持续时间 &lt;code&gt;bufferTimeSpan&lt;/code&gt; 中缓冲来自源的值。除非给出可选参数 &lt;code&gt;bufferCreationInterval&lt;/code&gt; ，否则它每隔 &lt;code&gt;bufferTimeSpan&lt;/code&gt; 毫秒发出并重置缓冲区。如果给定 &lt;code&gt;bufferCreationInterval&lt;/code&gt; ，则此运算符每隔 &lt;code&gt;bufferCreationInterval&lt;/code&gt; 毫秒打开一次缓冲区，并每隔 &lt;code&gt;bufferTimeSpan&lt;/code&gt; 毫秒关闭（退出并重置）该缓冲区。指定可选参数 &lt;code&gt;maxBufferSize&lt;/code&gt; 时，缓冲区将在 &lt;code&gt;bufferTimeSpan&lt;/code&gt; 毫秒后或包含 &lt;code&gt;maxBufferSize&lt;/code&gt; 元素时关闭。</target>
        </trans-unit>
        <trans-unit id="2ab13858e624370f0f64b6c332c7f2614bc328c2" translate="yes" xml:space="preserve">
          <source>Build Your Own Operators Easily</source>
          <target state="translated">轻松建立自己的操作器</target>
        </trans-unit>
        <trans-unit id="676f6ca72b7ceddfaefe05b718ec94fe4ee584db" translate="yes" xml:space="preserve">
          <source>Build and Treeshaking</source>
          <target state="translated">建造和摇树</target>
        </trans-unit>
        <trans-unit id="fbdb16ef0c14df9ae818c34fde6140cc17ebec29" translate="yes" xml:space="preserve">
          <source>But how do you work with a higher-order Observable? Typically, by &lt;em&gt;flattening&lt;/em&gt;: by (somehow) converting a higher-order Observable into an ordinary Observable. For example:</source>
          <target state="translated">但是如何处理高阶Observable？通常，通过展&lt;em&gt;平&lt;/em&gt;：通过（以某种方式）将高阶Observable转换为普通Observable。例如：</target>
        </trans-unit>
        <trans-unit id="81261945285e1f2fcd2cb9624774cb27067692f5" translate="yes" xml:space="preserve">
          <source>But if we instead us the &lt;code&gt;subscribeOn&lt;/code&gt; operator declaring that we want to use the &lt;a href=&quot;../index/const/asyncscheduler&quot;&gt;&lt;code&gt;async&lt;/code&gt;&lt;/a&gt; for values emited by Observable &lt;code&gt;a&lt;/code&gt;:</source>
          <target state="translated">但是，如果改为使用 &lt;code&gt;subscribeOn&lt;/code&gt; 运算符，则声明要对Observable &lt;code&gt;a&lt;/code&gt; 发出的值使用&lt;a href=&quot;../index/const/asyncscheduler&quot;&gt; &lt;code&gt;async&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="e6d6e0552657f23eb778d7b0e73b6e76e73ea9a7" translate="yes" xml:space="preserve">
          <source>But you can also &quot;return&quot; values asynchronously:</source>
          <target state="translated">但你也可以异步 &quot;返回 &quot;值。</target>
        </trans-unit>
        <trans-unit id="f90e5f831e73c22e973a350195d169a635741751" translate="yes" xml:space="preserve">
          <source>By default these arrays are emitted synchronously. To change that you can pass a &lt;a href=&quot;../interface/schedulerlike&quot;&gt;&lt;code&gt;SchedulerLike&lt;/code&gt;&lt;/a&gt; as a second argument to &lt;code&gt;pairs&lt;/code&gt;.</source>
          <target state="translated">默认情况下，这些数组是同步发出的。要改变这种状况，你可以通过一个&lt;a href=&quot;../interface/schedulerlike&quot;&gt; &lt;code&gt;SchedulerLike&lt;/code&gt; &lt;/a&gt;作为第二个参数 &lt;code&gt;pairs&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ab95b076b9a889a20adbe974f689337a0938a989" translate="yes" xml:space="preserve">
          <source>By default, results passed to the callback are emitted immediately after &lt;code&gt;func&lt;/code&gt; invokes the callback. In particular, if the callback is called synchronously, then the subscription of the resulting Observable will call the &lt;code&gt;next&lt;/code&gt; function synchronously as well. If you want to defer that call, you may use &lt;a href=&quot;../const/asyncscheduler&quot;&gt;&lt;code&gt;async&lt;/code&gt;&lt;/a&gt; just as before. This means that by using &lt;code&gt;Scheduler.async&lt;/code&gt; you can ensure that &lt;code&gt;func&lt;/code&gt; always calls its callback asynchronously, thus avoiding terrifying Zalgo.</source>
          <target state="translated">默认情况下， &lt;code&gt;func&lt;/code&gt; 调用回调后，会立即发出传递给回调的结果。特别是，如果回调是同步调用的，则生成的Observable的预订也将同步调用 &lt;code&gt;next&lt;/code&gt; 函数。如果您想推迟该呼叫，则可以像以前一样使用&lt;a href=&quot;../const/asyncscheduler&quot;&gt; &lt;code&gt;async&lt;/code&gt; &lt;/a&gt;。这意味着通过使用 &lt;code&gt;Scheduler.async&lt;/code&gt; ,您可以确保 &lt;code&gt;func&lt;/code&gt; 始终异步调用其回调，从而避免使Zalgo感到恐惧。</target>
        </trans-unit>
        <trans-unit id="2f3c24c0b8ca48e155030e9400fba049ed478537" translate="yes" xml:space="preserve">
          <source>By not passing any scheduler, notifications are delivered synchronously and recursively. Use this for constant-time operations or tail recursive operations.</source>
          <target state="translated">通过不传递任何调度器,同步和递归地传递通知。在恒定时间操作或尾部递归操作中使用此功能。</target>
        </trans-unit>
        <trans-unit id="511c31182dd5c650c4510a3c0301a11cadc8c586" translate="yes" xml:space="preserve">
          <source>By virtue of being a &lt;a href=&quot;../index/class/subject&quot;&gt;&lt;code&gt;Subject&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;WebSocketSubject&lt;/code&gt; allows for receiving and sending messages from the server. In order to communicate with a connected endpoint, use &lt;code&gt;next&lt;/code&gt;, &lt;code&gt;error&lt;/code&gt; and &lt;code&gt;complete&lt;/code&gt; methods. &lt;code&gt;next&lt;/code&gt; sends a value to the server, so bear in mind that this value will not be serialized beforehand. Because of This, &lt;code&gt;JSON.stringify&lt;/code&gt; will have to be called on a value by hand, before calling &lt;code&gt;next&lt;/code&gt; with a result. Note also that if at the moment of nexting value there is no socket connection (for example no one is subscribing), those values will be buffered, and sent when connection is finally established. &lt;code&gt;complete&lt;/code&gt; method closes socket connection. &lt;code&gt;error&lt;/code&gt; does the same, as well as notifying the server that something went wrong via status code and string with details of what happened. Since status code is required in WebSocket API, &lt;code&gt;WebSocketSubject&lt;/code&gt; does not allow, like regular &lt;code&gt;Subject&lt;/code&gt;, arbitrary values being passed to the &lt;code&gt;error&lt;/code&gt; method. It needs to be called with an object that has &lt;code&gt;code&lt;/code&gt; property with status code number and optional &lt;code&gt;reason&lt;/code&gt; property with string describing details of an error.</source>
          <target state="translated">通过成为&lt;a href=&quot;../index/class/subject&quot;&gt; &lt;code&gt;Subject&lt;/code&gt; &lt;/a&gt;， &lt;code&gt;WebSocketSubject&lt;/code&gt; 允许从服务器接收和发送消息。为了与连接的端点进行通信，请使用 &lt;code&gt;next&lt;/code&gt; ， &lt;code&gt;error&lt;/code&gt; 和 &lt;code&gt;complete&lt;/code&gt; 方法。 &lt;code&gt;next&lt;/code&gt; 将一个值发送到服务器，因此请记住，该值不会预先序列化。因此，必须先手动对一个值调用 &lt;code&gt;JSON.stringify&lt;/code&gt; ，然后再调用 &lt;code&gt;next&lt;/code&gt; 一个结果。还要注意，如果在下一个值的时刻没有套接字连接（例如，没有人在订阅），则这些值将被缓冲，并在最终建立连接时发送。 &lt;code&gt;complete&lt;/code&gt; 方法关闭套接字连接。 &lt;code&gt;error&lt;/code&gt; 作用相同，也通过状态代码和字符串通知服务器发生问题的详细信息。由于WebSocket API需要状态码，因此 &lt;code&gt;WebSocketSubject&lt;/code&gt; 不允许像常规 &lt;code&gt;Subject&lt;/code&gt; 一样将任意值传递给 &lt;code&gt;error&lt;/code&gt; 方法。需要使用一个对象来调用它，该对象的 &lt;code&gt;code&lt;/code&gt; 属性具有状态码编号，可选 &lt;code&gt;reason&lt;/code&gt; 属性具有描述错误详细信息的字符串。</target>
        </trans-unit>
        <trans-unit id="67b6c4b8addee6f0bec9b64fdc066f75fd594e81" translate="yes" xml:space="preserve">
          <source>CDN</source>
          <target state="translated">CDN</target>
        </trans-unit>
        <trans-unit id="2c85a73cd12db61768b9bb19ea9828e95032a59a" translate="yes" xml:space="preserve">
          <source>COMPLETE</source>
          <target state="translated">COMPLETE</target>
        </trans-unit>
        <trans-unit id="4590aa62874fd7b9a9997615d2263d8941afd9c2" translate="yes" xml:space="preserve">
          <source>Callback for errors in the source.</source>
          <target state="translated">回调源中的错误。</target>
        </trans-unit>
        <trans-unit id="2a398f7106ab8cbcc00f7e0b623031a44b27c4c0" translate="yes" xml:space="preserve">
          <source>Callback for the completion of the source.</source>
          <target state="translated">回调源的完成。</target>
        </trans-unit>
        <trans-unit id="6bc9d59a54f34bf3e88d0a22203ceafb349998a2" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;connect()&lt;/code&gt; manually and handling the Subscription is often cumbersome. Usually, we want to &lt;em&gt;automatically&lt;/em&gt; connect when the first Observer arrives, and automatically cancel the shared execution when the last Observer unsubscribes.</source>
          <target state="translated">手动调用 &lt;code&gt;connect()&lt;/code&gt; 并处理订阅通常很麻烦。通常，我们要在第一个观察者到达时&lt;em&gt;自动&lt;/em&gt;连接，并在最后一个观察者取消订阅时自动取消共享执行。</target>
        </trans-unit>
        <trans-unit id="cac74e4863ea82589bf37f274214232a2020fde7" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;next&lt;/code&gt; does not affect subscribers of &lt;code&gt;WebSocketSubject&lt;/code&gt; - they have no information that something was sent to the server (unless of course the server responds somehow to a message). On the other hand, since calling &lt;code&gt;complete&lt;/code&gt; triggers an attempt to close socket connection. If that connection is closed without any errors, stream will complete, thus notifying all subscribers. And since calling &lt;code&gt;error&lt;/code&gt; closes socket connection as well, just with a different status code for the server, if closing itself proceeds without errors, subscribed Observable will not error, as one might expect, but complete as usual. In both cases (calling &lt;code&gt;complete&lt;/code&gt; or &lt;code&gt;error&lt;/code&gt;), if process of closing socket connection results in some errors, &lt;em&gt;then&lt;/em&gt; stream will error.</source>
          <target state="translated">调用 &lt;code&gt;next&lt;/code&gt; 不会影响 &lt;code&gt;WebSocketSubject&lt;/code&gt; 的订阅者-他们不知道已向服务器发送了某些信息（除非服务器当然会对消息做出响应）。另一方面，由于调用 &lt;code&gt;complete&lt;/code&gt; 会触发尝试关闭套接字连接的尝试。如果该连接已关闭且没有任何错误，则流将完成，从而通知所有订户。而且由于调用 &lt;code&gt;error&lt;/code&gt; 也会关闭套接字连接，只是为服务器提供了不同的状态代码，如果关闭本身继续进行而没有错误，则已订阅的Observable不会出错，就像人们期望的那样，但是照常完成。在两种情况下（调用 &lt;code&gt;complete&lt;/code&gt; 还是 &lt;code&gt;error&lt;/code&gt; ），如果关闭套接字连接的过程导致某些错误，&lt;em&gt;则&lt;/em&gt;流将出错。</target>
        </trans-unit>
        <trans-unit id="935e0374fc62004171fd85c905965758a1891c08" translate="yes" xml:space="preserve">
          <source>Cancel a subscription</source>
          <target state="translated">取消订阅</target>
        </trans-unit>
        <trans-unit id="9d1e2f3e476609e344df33a8265f591eb579afca" translate="yes" xml:space="preserve">
          <source>Catches errors on the observable to be handled by returning a new observable or throwing an error.</source>
          <target state="translated">通过返回一个新的观测值或抛出一个错误来捕获观测值上的错误。</target>
        </trans-unit>
        <trans-unit id="40e6c757452db48cd925951cfe7eef7f22c5e862" translate="yes" xml:space="preserve">
          <source>Categories of operators</source>
          <target state="translated">经营者的类别</target>
        </trans-unit>
        <trans-unit id="bf247e16c63f07775f0becbb509d151d49677413" translate="yes" xml:space="preserve">
          <source>Change at runtime which Observable will be subscribed</source>
          <target state="translated">在运行时更改将被订阅的Observable。</target>
        </trans-unit>
        <trans-unit id="acddfe6e0f84690d12ae8d6dba931938820b0320" translate="yes" xml:space="preserve">
          <source>Check if ticks are emitted within certain timespan</source>
          <target state="translated">检查是否在一定时间段内发出蜱虫。</target>
        </trans-unit>
        <trans-unit id="4180596115cf7ecf0a22e17994523dc7e25709ef" translate="yes" xml:space="preserve">
          <source>Checks to see of all values emitted by both observables are equal, in order.</source>
          <target state="translated">检查两个观测值的所有数值是否依次相等。</target>
        </trans-unit>
        <trans-unit id="3c6f0a9d624ec81db524dbe06b9e088e944f553b" translate="yes" xml:space="preserve">
          <source>Child Interfaces</source>
          <target state="translated">儿童接口</target>
        </trans-unit>
        <trans-unit id="92a715716ffdf82ae0698aa576184e0fd68dee01" translate="yes" xml:space="preserve">
          <source>Class Implementations</source>
          <target state="translated">类实现</target>
        </trans-unit>
        <trans-unit id="92adf227123fe3164559c8b57554084d078adbb1" translate="yes" xml:space="preserve">
          <source>Classes that operate on observables have been replaced by functions.</source>
          <target state="translated">对观测值进行操作的类已经被函数所取代。</target>
        </trans-unit>
        <trans-unit id="f56986343e465f67e4ade9b4d5003bb79270d98a" translate="yes" xml:space="preserve">
          <source>Code licensed under an Apache-2.0 License. Documentation licensed under CC BY 4.0.</source>
          <target state="translated">代码采用Apache-2.0协议授权。文档采用CC BY 4.0授权。</target>
        </trans-unit>
        <trans-unit id="264398069882e7753347718021d0c9c51b7ce8fc" translate="yes" xml:space="preserve">
          <source>Code of Conduct</source>
          <target state="translated">行为守则</target>
        </trans-unit>
        <trans-unit id="bff53ee5bce91f6e48134eda698e59b8359d48bf" translate="yes" xml:space="preserve">
          <source>Collects all source emissions and emits them as an array when the source completes.</source>
          <target state="translated">收集所有源的排放,并在源完成后以数组形式排放。</target>
        </trans-unit>
        <trans-unit id="a87c4457cd65817173f42a58e3b056f94792975c" translate="yes" xml:space="preserve">
          <source>Collects values from the past as an array, and emits that array only when another Observable emits.</source>
          <target state="translated">将过去的值以数组的形式收集起来,只有在另一个Observable发出时才会发出该数组。</target>
        </trans-unit>
        <trans-unit id="84e5c2c56ccc76a9cf62fb80908721c69ede86cf" translate="yes" xml:space="preserve">
          <source>Collects values from the past as an array, and emits that array only when its size reaches &lt;code&gt;bufferSize&lt;/code&gt;.</source>
          <target state="translated">从过去收集值作为一个数组，并且仅在其大小达到 &lt;code&gt;bufferSize&lt;/code&gt; 时才发出该数组。</target>
        </trans-unit>
        <trans-unit id="dcb48d99f7461fdace8881995c945f640d453091" translate="yes" xml:space="preserve">
          <source>Collects values from the past as an array, and emits those arrays periodically in time.</source>
          <target state="translated">将过去的数值以数组的形式收集起来,并定期将这些数组发射出去。</target>
        </trans-unit>
        <trans-unit id="a28d40eb03d856d357a7a6d8bf9631fe8ab94554" translate="yes" xml:space="preserve">
          <source>Collects values from the past as an array. Starts collecting only when &lt;code&gt;opening&lt;/code&gt; emits, and calls the &lt;code&gt;closingSelector&lt;/code&gt; function to get an Observable that tells when to close the buffer.</source>
          <target state="translated">收集过去的值作为数组。开始收集只有当 &lt;code&gt;opening&lt;/code&gt; 发出，并调用 &lt;code&gt;closingSelector&lt;/code&gt; 函数来获得可观察到的，告诉何时关闭缓冲。</target>
        </trans-unit>
        <trans-unit id="4b8aa081fb705436429dff9d465de035e7e62f11" translate="yes" xml:space="preserve">
          <source>Collects values from the past as an array. When it starts collecting values, it calls a function that returns an Observable that tells when to close the buffer and restart collecting.</source>
          <target state="translated">以数组的形式收集过去的值,当它开始收集值时,会调用一个函数来返回一个Observable,告知何时关闭缓冲区并重新开始收集。当它开始收集值时,它调用一个函数,返回一个Observable,告诉何时关闭缓冲区并重新开始收集。</target>
        </trans-unit>
        <trans-unit id="16dc60a0adf13d9db9d55f345c909d25f48d7dd5" translate="yes" xml:space="preserve">
          <source>Combine age and name from different sources</source>
          <target state="translated">结合不同来源的年龄和姓名</target>
        </trans-unit>
        <trans-unit id="ddcd6864d0909fbc11124756a02fcda077e9eee9" translate="yes" xml:space="preserve">
          <source>Combine an array of Observables</source>
          <target state="translated">组合一个Observables数组</target>
        </trans-unit>
        <trans-unit id="3290c60aa41ac81295b37ea06bcc86ce998efa56" translate="yes" xml:space="preserve">
          <source>Combine two timer Observables</source>
          <target state="translated">结合两个定时器的可观察性</target>
        </trans-unit>
        <trans-unit id="d89a0d96a043bd7133e0dc51016f7f120ae0eaae" translate="yes" xml:space="preserve">
          <source>Combines multiple Observables to create an Observable whose values are calculated from the latest values of each of its input Observables.</source>
          <target state="translated">将多个Observables组合起来,创建一个Observable,其值由每个输入Observables的最新值计算得出。</target>
        </trans-unit>
        <trans-unit id="7db2a4e0664e1e1247e446b34d85228f39aa98c1" translate="yes" xml:space="preserve">
          <source>Combines multiple Observables to create an Observable whose values are calculated from the values, in order, of each of its input Observables.</source>
          <target state="translated">将多个Observable组合起来,创建一个Observable,其值由每个输入Observable的值按顺序计算。</target>
        </trans-unit>
        <trans-unit id="a94b90034171278929060f4c02c4d77ccd4193cc" translate="yes" xml:space="preserve">
          <source>Combines the source Observable with other Observables to create an Observable whose values are calculated from the latest values of each, only when the source emits.</source>
          <target state="translated">将源Observable和其他Observable结合起来,创建一个Observable,其值是由每个Observable的最新值计算出来的,只有当源发射时,才会计算出来。</target>
        </trans-unit>
        <trans-unit id="5b0baff3ec7a8c1314bf1adf98ac28a48a1e9524" translate="yes" xml:space="preserve">
          <source>Combines together all values emitted on the source, using an accumulator function that knows how to join a new source value into the accumulation from the past.</source>
          <target state="translated">将源上发出的所有值组合在一起,使用一个知道如何将一个新的源值加入到过去的积累中的积累器函数。</target>
        </trans-unit>
        <trans-unit id="b2cd10bda67f3c2a0db363c783f1be790f5f461a" translate="yes" xml:space="preserve">
          <source>Combines together all values emitted on the source, using an accumulator function that knows how to join a new source value into the accumulation from the past. Is similar to &lt;a href=&quot;reduce&quot;&gt;&lt;code&gt;reduce&lt;/code&gt;&lt;/a&gt;, but emits the intermediate accumulations.</source>
          <target state="translated">使用累加器函数将源上发出的所有值合并在一起，该函数知道如何将新的源值结合到过去的累加中。类似于&lt;a href=&quot;reduce&quot;&gt; &lt;code&gt;reduce&lt;/code&gt; &lt;/a&gt;，但发出中间积累。</target>
        </trans-unit>
        <trans-unit id="d9a3849cfa8277187bcfd6ad0b01e4f8005b9aaf" translate="yes" xml:space="preserve">
          <source>CommonJS via npm</source>
          <target state="translated">通过npm的CommonJS</target>
        </trans-unit>
        <trans-unit id="d4d22effb8cb3b670cec35ed783a128ce947ac0a" translate="yes" xml:space="preserve">
          <source>Compare async and asap scheduler&amp;lt;</source>
          <target state="translated">比较异步和尽快调度程序&amp;lt;</target>
        </trans-unit>
        <trans-unit id="7435cdb2b01945189354f363a0421a39f3cd8faa" translate="yes" xml:space="preserve">
          <source>Compare behaviour with and without async Scheduler</source>
          <target state="translated">比较使用和不使用异步调度器的行为</target>
        </trans-unit>
        <trans-unit id="ea2fd62aaac1214e57e275acea20cefc00fdc055" translate="yes" xml:space="preserve">
          <source>Compares all values of two observables in sequence using an optional comparator function and returns an observable of a single boolean value representing whether or not the two sequences are equal.</source>
          <target state="translated">使用一个可选的比较器函数比较两个观测值的所有值,并返回一个代表两个序列是否相等的单一布尔值的观测值。</target>
        </trans-unit>
        <trans-unit id="3a4a4ba8ed0c16db5d39596cb0488aad4649a436" translate="yes" xml:space="preserve">
          <source>CompletionObserver</source>
          <target state="translated">CompletionObserver</target>
        </trans-unit>
        <trans-unit id="d982b449859a628c84de4d2d6a5c484a7c842af0" translate="yes" xml:space="preserve">
          <source>Concatenate 3 Observables</source>
          <target state="translated">串联3个观测点</target>
        </trans-unit>
        <trans-unit id="63f84436a9e4551523680f6e33010bbd81eceb69" translate="yes" xml:space="preserve">
          <source>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</source>
          <target state="translated">将0到3的定时器计数与1到10的同步序列连接起来。</target>
        </trans-unit>
        <trans-unit id="d2f209d251c0e1e81cd1edf9ef7e4dd74fc1df55" translate="yes" xml:space="preserve">
          <source>Concatenate the same Observable to repeat it</source>
          <target state="translated">将相同的Observable连接起来重复使用。</target>
        </trans-unit>
        <trans-unit id="6ca2d7e68988508caae3db5f7e018aedff9b9fc9" translate="yes" xml:space="preserve">
          <source>Concatenates multiple Observables together by sequentially emitting their values, one Observable after the other.</source>
          <target state="translated">将多个Observable连接在一起,依次发出它们的值,一个Observable接一个。</target>
        </trans-unit>
        <trans-unit id="d0b35f2e80cf4078de3821051d01800d2a02ba30" translate="yes" xml:space="preserve">
          <source>Conclusion:</source>
          <target state="translated">Conclusion:</target>
        </trans-unit>
        <trans-unit id="0994f75274a8c52a8effb0dff41d86197463bb06" translate="yes" xml:space="preserve">
          <source>Condition to terminate generation (upon returning false).</source>
          <target state="translated">终止生成的条件(返回false时)。</target>
        </trans-unit>
        <trans-unit id="89e222ef595e95335f78cd2e3d813306054bc919" translate="yes" xml:space="preserve">
          <source>Condition which Observable should be chosen.</source>
          <target state="translated">应选择的观测条件:</target>
        </trans-unit>
        <trans-unit id="9b047f76f02c3292f835923209499db8eb35fdb8" translate="yes" xml:space="preserve">
          <source>Conditional and Boolean Operators</source>
          <target state="translated">条件和布尔运算符</target>
        </trans-unit>
        <trans-unit id="98fc062426c459824189a5ec2607ca8eff08cd75" translate="yes" xml:space="preserve">
          <source>ConnectableObservable</source>
          <target state="translated">ConnectableObservable</target>
        </trans-unit>
        <trans-unit id="227f6773256bb7ed0a8c8aef07706b2d613095e7" translate="yes" xml:space="preserve">
          <source>ConnectableObservable._subscribe()</source>
          <target state="translated">ConnectableObservable._subscribe()</target>
        </trans-unit>
        <trans-unit id="e4e83313fbffa48c823bbad63fe418da25e13b75" translate="yes" xml:space="preserve">
          <source>ConnectableObservable.connect()</source>
          <target state="translated">ConnectableObservable.connect()</target>
        </trans-unit>
        <trans-unit id="5b738b218b7aa49bf8395157e1f139e5d7314c3d" translate="yes" xml:space="preserve">
          <source>ConnectableObservable.getSubject()</source>
          <target state="translated">ConnectableObservable.getSubject()</target>
        </trans-unit>
        <trans-unit id="682ebb04b9bff65e60368de186fac3051021f642" translate="yes" xml:space="preserve">
          <source>ConnectableObservable.refCount()</source>
          <target state="translated">ConnectableObservable.refCount()</target>
        </trans-unit>
        <trans-unit id="a3613a775b8dd1ea901d700f28e65babb54cab38" translate="yes" xml:space="preserve">
          <source>Consider the following example where subscriptions occur as outlined by this list:</source>
          <target state="translated">请考虑以下例子,其中发生了本清单所概述的订阅。</target>
        </trans-unit>
        <trans-unit id="fc53f41d4c528eb43347a836891919335055512d" translate="yes" xml:space="preserve">
          <source>Consider the following:</source>
          <target state="translated">请考虑以下几点:</target>
        </trans-unit>
        <trans-unit id="edb7861f190be64ab7c7a39786a00727bb16847d" translate="yes" xml:space="preserve">
          <source>Constructor</source>
          <target state="translated">Constructor</target>
        </trans-unit>
        <trans-unit id="0c707f2781a489cf7e4ea7d11c190f8dfe3a0bf0" translate="yes" xml:space="preserve">
          <source>Consumer</source>
          <target state="translated">Consumer</target>
        </trans-unit>
        <trans-unit id="c98977bcb8208e29729ee8d1a4102b950f779678" translate="yes" xml:space="preserve">
          <source>Continues with a different Observable when there's an error</source>
          <target state="translated">当出现错误时,继续使用另一个Observable。</target>
        </trans-unit>
        <trans-unit id="7ada7cd7c5728485ea37e7e90c589b594cd34212" translate="yes" xml:space="preserve">
          <source>Contrary to popular claims, Observables are not like EventEmitters nor are they like Promises for multiple values. Observables &lt;em&gt;may act&lt;/em&gt; like EventEmitters in some cases, namely when they are multicasted using RxJS Subjects, but usually they don't act like EventEmitters.</source>
          <target state="translated">与流行的说法相反，Observables不像EventEmitters，也不像是多个值的Promises。在某些情况下，即使用RxJS主题对可观察对象进行多播时，可观察对象的&lt;em&gt;行为可能&lt;/em&gt;类似于EventEmitters，但通常它们并不类似于EventEmitters。</target>
        </trans-unit>
        <trans-unit id="0a49d6e404607e10a989271aec1f79d6ac8a2119" translate="yes" xml:space="preserve">
          <source>Control an access to an Observable</source>
          <target state="translated">控制对可观察对象的访问</target>
        </trans-unit>
        <trans-unit id="59cdbb05d9b9d2c325ba6cc70236d63b8806330c" translate="yes" xml:space="preserve">
          <source>Convert a faulty Observable to an Observable of Notifications</source>
          <target state="translated">将一个有问题的Observable转换为Observable of Notifications。</target>
        </trans-unit>
        <trans-unit id="c7a397319f2ad4db3ea562e9725ebd2ef8e801dc" translate="yes" xml:space="preserve">
          <source>Convert an Observable of Notifications to an actual Observable</source>
          <target state="translated">将通知的观测值转换为实际的观测值。</target>
        </trans-unit>
        <trans-unit id="a57ac9929f9075b8bad9951d6bf02471c724dcb8" translate="yes" xml:space="preserve">
          <source>Convert an Observable that emits items into one that emits indications of the amount of time elapsed between those emissions.</source>
          <target state="translated">将一个发出物品的Observable转换为发出这些物品之间所经过的时间量的指示。</target>
        </trans-unit>
        <trans-unit id="a364d3d6bb030d153b00d33ba8b033883901284b" translate="yes" xml:space="preserve">
          <source>Convert an infinite iterable (from a generator) to an Observable</source>
          <target state="translated">将一个无限迭代(来自生成器)转换为一个可观察的对象。</target>
        </trans-unit>
        <trans-unit id="ea2d5c2f9388b6f9038c0c700046b2170a04bde6" translate="yes" xml:space="preserve">
          <source>Convert an object into an Observable of &lt;code&gt;[key, value]&lt;/code&gt; pairs.</source>
          <target state="translated">将对象转换为 &lt;code&gt;[key, value]&lt;/code&gt; 对的Observable 。</target>
        </trans-unit>
        <trans-unit id="3288bcd2be86adb205c2a9df12810cd9003b7c8e" translate="yes" xml:space="preserve">
          <source>Convert jQuery's getJSON to an Observable API</source>
          <target state="translated">将jQuery的getJSON转换为Observable API。</target>
        </trans-unit>
        <trans-unit id="819a8ca76a22d542e92a562a9321de242bb32824" translate="yes" xml:space="preserve">
          <source>Converts a Node.js-style callback API to a function that returns an Observable.</source>
          <target state="translated">将一个Node.js风格的回调API转换为一个返回Observable的函数。</target>
        </trans-unit>
        <trans-unit id="0ca228dc00e3b500ab7c0c59f7db8fa3cc379cf4" translate="yes" xml:space="preserve">
          <source>Converts a callback API to a function that returns an Observable.</source>
          <target state="translated">将回调API转换为返回Observable的函数。</target>
        </trans-unit>
        <trans-unit id="d8bdbac484a550c5290dc0793186ded042951331" translate="yes" xml:space="preserve">
          <source>Converts a higher-order Observable into a first-order Observable by concatenating the inner Observables in order.</source>
          <target state="translated">将一个高阶的Observable转换为一阶的Observable,方法是将内部的Observable按顺序连接起来。</target>
        </trans-unit>
        <trans-unit id="512eb28280b7e03ca5f0d999e4ad906680f5cf55" translate="yes" xml:space="preserve">
          <source>Converts a higher-order Observable into a first-order Observable by dropping inner Observables while the previous inner Observable has not yet completed.</source>
          <target state="translated">在前一个内部观测值尚未完成时,通过放弃内部观测值,将一个高阶观测值转换为一阶观测值。</target>
        </trans-unit>
        <trans-unit id="0fc3a87abee50d7640e787cc66c96745d64bcdfe" translate="yes" xml:space="preserve">
          <source>Converts a higher-order Observable into a first-order Observable producing values only from the most recent observable sequence</source>
          <target state="translated">将一个高阶观测值转换为一阶观测值,只产生最近的观测序列的值。</target>
        </trans-unit>
        <trans-unit id="fc15afc5a3b5a5a5700f443e1064756e1aeb0ef1" translate="yes" xml:space="preserve">
          <source>Converts a higher-order Observable into a first-order Observable which concurrently delivers all values that are emitted on the inner Observables.</source>
          <target state="translated">将一个高阶Observable转换为一个一阶Observable,它同时提供内部Observable上发出的所有值。</target>
        </trans-unit>
        <trans-unit id="b51d3e7b3c8cccda64472b781a2fe516fd3c8d36" translate="yes" xml:space="preserve">
          <source>Converts almost anything to an Observable.</source>
          <target state="translated">几乎可以将任何东西转换为Observable。</target>
        </trans-unit>
        <trans-unit id="dcafce430dc29181daa478cf9c06fd80fd059a0f" translate="yes" xml:space="preserve">
          <source>Converts an Observable of &lt;a href=&quot;../index/class/notification&quot;&gt;&lt;code&gt;Notification&lt;/code&gt;&lt;/a&gt; objects into the emissions that they represent.</source>
          <target state="translated">将Observable of &lt;a href=&quot;../index/class/notification&quot;&gt; &lt;code&gt;Notification&lt;/code&gt; &lt;/a&gt;对象转换为它们表示的发射。</target>
        </trans-unit>
        <trans-unit id="90543f0ae59be2561cf130cfe357a2eb0d2f310c" translate="yes" xml:space="preserve">
          <source>Converts an array to an Observable</source>
          <target state="translated">将数组转换为Observable</target>
        </trans-unit>
        <trans-unit id="38d9b9c231b0641f88f17b35e4cd114dbaa6824b" translate="yes" xml:space="preserve">
          <source>Converts from a common &lt;a href=&quot;../type-alias/observableinput&quot;&gt;&lt;code&gt;ObservableInput&lt;/code&gt;&lt;/a&gt; type to an observable where subscription and emissions are scheduled on the provided scheduler.</source>
          <target state="translated">从常见的&lt;a href=&quot;../type-alias/observableinput&quot;&gt; &lt;code&gt;ObservableInput&lt;/code&gt; &lt;/a&gt;类型转换为在提供的调度程序上调度订阅和发射的observable。</target>
        </trans-unit>
        <trans-unit id="c8516852b5b3e129bf4cf88d8db27cd4db8ae7ec" translate="yes" xml:space="preserve">
          <source>Converts the arguments to an observable sequence.</source>
          <target state="translated">将参数转换为一个可观察的序列。</target>
        </trans-unit>
        <trans-unit id="cd9fea92083a870676e543be5c6771c16d35faf8" translate="yes" xml:space="preserve">
          <source>Core Observable concerns:</source>
          <target state="translated">可观察的核心问题:</target>
        </trans-unit>
        <trans-unit id="fc6c40245600e6f83559183f877fd23ea3ec4525" translate="yes" xml:space="preserve">
          <source>Count from 0 to 9 every second for each click, but only allow 2 concurrent timers</source>
          <target state="translated">每秒钟从0到9的点击计数,但只允许2个并发计时器</target>
        </trans-unit>
        <trans-unit id="8e4e16903b9c68e1a70feb9c1b12a2e432e40e13" translate="yes" xml:space="preserve">
          <source>Count the number of click events</source>
          <target state="translated">计算点击事件的数量</target>
        </trans-unit>
        <trans-unit id="76fe820e51c08ab2fdcfa79429ab0f2b55d0239b" translate="yes" xml:space="preserve">
          <source>Count the number of click events that happened in 5 seconds</source>
          <target state="translated">统计5秒内发生的点击事件的数量。</target>
        </trans-unit>
        <trans-unit id="38297b14fd834b687d5f9c6c0c377bc3a26611e7" translate="yes" xml:space="preserve">
          <source>Counts how many odd numbers are there between 1 and 7</source>
          <target state="translated">数出1到7之间有多少个奇数。</target>
        </trans-unit>
        <trans-unit id="6527ed3c67425451554706dd6e296b6b07cfda36" translate="yes" xml:space="preserve">
          <source>Counts how many seconds have passed before the first click happened</source>
          <target state="translated">计算第一次点击前已过去多少秒。</target>
        </trans-unit>
        <trans-unit id="491a828d8c53ae7db8b33fbcf030f25402cd90e8" translate="yes" xml:space="preserve">
          <source>Counts the number of emissions on the source and emits that number when the source completes.</source>
          <target state="translated">统计排放源上的排放数量,并在排放源完成后排放该数量。</target>
        </trans-unit>
        <trans-unit id="b7d8894a964a606855f76a9e1a3c256a85a77af3" translate="yes" xml:space="preserve">
          <source>Creates a new Observable with this Subject as the source. You can do this to create customize Observer-side logic of the Subject and conceal it from code that uses the Observable.</source>
          <target state="translated">以这个Subject为源创建一个新的Observable。您可以这样做来创建自定义的观察者端逻辑,并将其隐藏在使用观察者的代码中。</target>
        </trans-unit>
        <trans-unit id="efd43c4f17bae72263830052e23af52fd14ac204" translate="yes" xml:space="preserve">
          <source>Creates a new Observable, with this Observable as the source, and the passed operator defined as the new observable's operator.</source>
          <target state="translated">创建一个新的Observable,以这个Observable为源,传递的操作符定义为新的Observable的操作符。</target>
        </trans-unit>
        <trans-unit id="6c433e239b323f6366118477eb69a8b50b369846" translate="yes" xml:space="preserve">
          <source>Creates a new cold Observable by calling the Observable constructor</source>
          <target state="translated">通过调用Observable构造函数来创建一个新的冷的Observable。</target>
        </trans-unit>
        <trans-unit id="e42c4af5ccb591cb72c7f304fdf206bf4581acd1" translate="yes" xml:space="preserve">
          <source>Creates an &lt;a href=&quot;../index/class/observable&quot;&gt;&lt;code&gt;Observable&lt;/code&gt;&lt;/a&gt;, that when subscribed to, sends a message, defined by the &lt;code&gt;subMsg&lt;/code&gt; function, to the server over the socket to begin a subscription to data over that socket. Once data arrives, the &lt;code&gt;messageFilter&lt;/code&gt; argument will be used to select the appropriate data for the resulting Observable. When teardown occurs, either due to unsubscription, completion or error, a message defined by the &lt;code&gt;unsubMsg&lt;/code&gt; argument will be send to the server over the WebSocketSubject.</source>
          <target state="translated">创建一个&lt;a href=&quot;../index/class/observable&quot;&gt; &lt;code&gt;Observable&lt;/code&gt; &lt;/a&gt;，当订阅时，该消息将由 &lt;code&gt;subMsg&lt;/code&gt; 函数定义的消息通过套接字发送到服务器，以开始对该套接字上的数据进行订阅。数据到达后， &lt;code&gt;messageFilter&lt;/code&gt; 参数将用于为生成的Observable选择适当的数据。当由于取消订阅，完成或错误而发生拆卸时，由 &lt;code&gt;unsubMsg&lt;/code&gt; 参数定义的消息将通过WebSocketSubject发送到服务器。</target>
        </trans-unit>
        <trans-unit id="6ba57e20fce78b5dfa9aefcbbbb2225cbb2cd085" translate="yes" xml:space="preserve">
          <source>Creates an Observable from DOM events, or Node.js EventEmitter events or others.</source>
          <target state="translated">从DOM事件或Node.js EventEmitter事件或其他事件中创建一个Observable。</target>
        </trans-unit>
        <trans-unit id="30076be76739faf49c8bf250c9ce3b8582621a15" translate="yes" xml:space="preserve">
          <source>Creates an Observable from an Array, an array-like object, a Promise, an iterable object, or an Observable-like object.</source>
          <target state="translated">从一个数组、一个类数组对象、一个 Promise、一个可迭代对象或一个类观察对象创建一个观察对象。</target>
        </trans-unit>
        <trans-unit id="a4b1d654222d9d963587195913c2db77cd1b2ff3" translate="yes" xml:space="preserve">
          <source>Creates an Observable from an arbitrary API for registering event handlers.</source>
          <target state="translated">从任意API中创建一个Observable,用于注册事件处理程序。</target>
        </trans-unit>
        <trans-unit id="8733e65df876cdecf09a85905357f82185d6f2a9" translate="yes" xml:space="preserve">
          <source>Creates an Observable that emits a sequence of numbers within a specified range.</source>
          <target state="translated">创建一个Observable,该Observable在指定的范围内发出一个数字序列。</target>
        </trans-unit>
        <trans-unit id="8ee788397d60121f2a0cdbe5153d1f8ed70114d7" translate="yes" xml:space="preserve">
          <source>Creates an Observable that emits events of a specific type coming from the given event target.</source>
          <target state="translated">创建一个Observable,从给定的事件目标中发出特定类型的事件。</target>
        </trans-unit>
        <trans-unit id="b19f653638b964e69cc5d6d83f264b627db6396d" translate="yes" xml:space="preserve">
          <source>Creates an Observable that emits no items to the Observer and immediately emits a complete notification.</source>
          <target state="translated">创建一个Observable,该Observable不会向Observer发出任何项目,并立即发出一个完整的通知。</target>
        </trans-unit>
        <trans-unit id="9ecbdd7d8ebb055a77e819dc27b5b8e144ac8f76" translate="yes" xml:space="preserve">
          <source>Creates an Observable that emits no items to the Observer and immediately emits an error notification.</source>
          <target state="translated">创建一个Observable,该Observable不会向Observer发出任何项目,并立即发出错误通知。</target>
        </trans-unit>
        <trans-unit id="c834efdbaabe5e44921e2ec46f3ff1e6caa151a5" translate="yes" xml:space="preserve">
          <source>Creates an Observable that emits sequential numbers every specified interval of time, on a specified &lt;a href=&quot;../interface/schedulerlike&quot;&gt;&lt;code&gt;SchedulerLike&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">创建一个Observable，它在指定的&lt;a href=&quot;../interface/schedulerlike&quot;&gt; &lt;code&gt;SchedulerLike&lt;/code&gt; &lt;/a&gt;上每指定的时间间隔发出序号。</target>
        </trans-unit>
        <trans-unit id="c660a5a39524e13cbab144cbe8ab5e14563e2a40" translate="yes" xml:space="preserve">
          <source>Creates an Observable that starts emitting after an &lt;code&gt;dueTime&lt;/code&gt; and emits ever increasing numbers after each &lt;code&gt;period&lt;/code&gt; of time thereafter.</source>
          <target state="translated">创建一个Observable，该对象在 &lt;code&gt;dueTime&lt;/code&gt; 之后开始发射，并在此后的每个 &lt;code&gt;period&lt;/code&gt; 段之后发射越来越多的数字。</target>
        </trans-unit>
        <trans-unit id="ae9fed84cdc523c537f6047938e7614dfd90ce38" translate="yes" xml:space="preserve">
          <source>Creates an Observable that uses a resource which will be disposed at the same time as the Observable.</source>
          <target state="translated">创建一个使用资源的Observable,该资源将与Observable同时被处理。</target>
        </trans-unit>
        <trans-unit id="88400625480f529b5c6a9d3898751cae3e084fbf" translate="yes" xml:space="preserve">
          <source>Creates an Observable that, on subscribe, calls an Observable factory to make an Observable for each new Observer.</source>
          <target state="translated">创建一个Observable,在订阅时,调用Observable工厂为每个新的Observer创建一个Observable。</target>
        </trans-unit>
        <trans-unit id="0763a1a84734bc982d4480f3a3459456e835d5cd" translate="yes" xml:space="preserve">
          <source>Creates an output Observable which concurrently emits all values from every given input Observable.</source>
          <target state="translated">创建一个输出Observable,该Observable同时发出来自每个给定输入Observable的所有值。</target>
        </trans-unit>
        <trans-unit id="33b018d042209578a46cb7d33213ab03f281363d" translate="yes" xml:space="preserve">
          <source>Creates an output Observable which sequentially emits all values from given Observable and then moves on to the next.</source>
          <target state="translated">创建一个输出Observable,该Observable从给定的Observable中依次发出所有的值,然后转到下一个。</target>
        </trans-unit>
        <trans-unit id="70011ddbfcf5671aa0c05bf7fceff4d551c240d5" translate="yes" xml:space="preserve">
          <source>Creates the Observable lazily, that is, only when it is subscribed.</source>
          <target state="translated">懒惰地创建Observable,也就是说,只有当它被订阅时才会被创建。</target>
        </trans-unit>
        <trans-unit id="6ad6131d04bc2f8da39dba3829954ab817589a3f" translate="yes" xml:space="preserve">
          <source>Creating Observables</source>
          <target state="translated">创建观测值</target>
        </trans-unit>
        <trans-unit id="3b55e62a31cf0de003b499939010016bd026ad3c" translate="yes" xml:space="preserve">
          <source>Creating custom observables</source>
          <target state="translated">创建自定义的观测数据</target>
        </trans-unit>
        <trans-unit id="eb98788b461efb61b82601e6daec4642ab62fad1" translate="yes" xml:space="preserve">
          <source>Creating new operators from scratch</source>
          <target state="translated">从零开始创建新的运营商</target>
        </trans-unit>
        <trans-unit id="94397887885ac635c016bdd99861cf6ef324405b" translate="yes" xml:space="preserve">
          <source>Creation Operators</source>
          <target state="translated">创作操作者</target>
        </trans-unit>
        <trans-unit id="e10b82309ae23cd7af56714b5258dc6a40b2138f" translate="yes" xml:space="preserve">
          <source>Decides at subscription time which Observable will actually be subscribed.</source>
          <target state="translated">在订阅时决定哪个Observable将被实际订阅。</target>
        </trans-unit>
        <trans-unit id="4cf333763d14e699755bedabc5590efe13366f13" translate="yes" xml:space="preserve">
          <source>Declared in constructor.</source>
          <target state="translated">在构造函数中声明。</target>
        </trans-unit>
        <trans-unit id="23bcb0d403ca12abcc86f64467b703be68b8f8c7" translate="yes" xml:space="preserve">
          <source>DeferObservable</source>
          <target state="translated">DeferObservable</target>
        </trans-unit>
        <trans-unit id="621045d69c5be1f634a4e5bcc53ff0a6021d3950" translate="yes" xml:space="preserve">
          <source>Delay all clicks until a future date happens</source>
          <target state="translated">推迟所有的点击,直到未来的日期发生。</target>
        </trans-unit>
        <trans-unit id="fe5c6e39f63a2abb17033a49863d02e213157524" translate="yes" xml:space="preserve">
          <source>Delay each click by a random amount of time, between 0 and 5 seconds</source>
          <target state="translated">将每次点击的时间随机延迟0到5秒之间。</target>
        </trans-unit>
        <trans-unit id="8915b9cde2c4ef9b51fbce85255c288a61f24642" translate="yes" xml:space="preserve">
          <source>Delay each click by one second</source>
          <target state="translated">每次点击延迟一秒</target>
        </trans-unit>
        <trans-unit id="68662352061ba86d162c267de395269277632ba7" translate="yes" xml:space="preserve">
          <source>Delays the emission of items from the source Observable by a given time span determined by the emissions of another Observable.</source>
          <target state="translated">延迟从源头可观测项目的排放,其时间跨度由另一个可观测项目的排放决定。</target>
        </trans-unit>
        <trans-unit id="1ef659436a6c36a417cd112a0a121582339f99c4" translate="yes" xml:space="preserve">
          <source>Delays the emission of items from the source Observable by a given timeout or until a given Date.</source>
          <target state="translated">按给定的超时时间或直到给定的日期,延迟从可观测源发出项目。</target>
        </trans-unit>
        <trans-unit id="7e315272fd1a4207c99a387e25509471282803ef" translate="yes" xml:space="preserve">
          <source>Delivers to the given &lt;code&gt;observer&lt;/code&gt; the value wrapped by this Notification.</source>
          <target state="translated">向给定的 &lt;code&gt;observer&lt;/code&gt; 提供此Notification包装的值。</target>
        </trans-unit>
        <trans-unit id="1605f6c45747aafbe495b3876f2cf20e7b6fdd24" translate="yes" xml:space="preserve">
          <source>Deprecated in favor of static &lt;a href=&quot;../index/function/combinelatest&quot;&gt;&lt;code&gt;combineLatest&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">不建议使用static &lt;a href=&quot;../index/function/combinelatest&quot;&gt; &lt;code&gt;combineLatest&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6b14b595931fc098a11ef3100bdb2821b6ac22c6" translate="yes" xml:space="preserve">
          <source>Deprecated in favor of static &lt;a href=&quot;../index/function/concat&quot;&gt;&lt;code&gt;concat&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">不赞成使用static &lt;a href=&quot;../index/function/concat&quot;&gt; &lt;code&gt;concat&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bb891d216533ca453393f5560f216a593180a0c4" translate="yes" xml:space="preserve">
          <source>Deprecated in favor of static &lt;a href=&quot;../index/function/merge&quot;&gt;&lt;code&gt;merge&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">不赞成使用静态&lt;a href=&quot;../index/function/merge&quot;&gt; &lt;code&gt;merge&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4923b07923f47345827f9dbc43bdd9226f071ef1" translate="yes" xml:space="preserve">
          <source>Deprecated in favor of static &lt;a href=&quot;../index/function/race&quot;&gt;&lt;code&gt;race&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">不赞成使用静态&lt;a href=&quot;../index/function/race&quot;&gt; &lt;code&gt;race&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="65017388b7b5b653ed1176ea2721b4807d0aab75" translate="yes" xml:space="preserve">
          <source>Deprecated in favor of static &lt;a href=&quot;../index/function/zip&quot;&gt;&lt;code&gt;zip&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">不推荐使用静态&lt;a href=&quot;../index/function/zip&quot;&gt; &lt;code&gt;zip&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bd528af798c288f24a1995a90fcf7251b1fb384c" translate="yes" xml:space="preserve">
          <source>Deprecated in favor of using &lt;a href=&quot;../const/never&quot;&gt;&lt;code&gt;NEVER&lt;/code&gt;&lt;/a&gt; constant.</source>
          <target state="translated">不建议使用&lt;a href=&quot;../const/never&quot;&gt; &lt;code&gt;NEVER&lt;/code&gt; &lt;/a&gt;常量。</target>
        </trans-unit>
        <trans-unit id="22ecf0e4bb675b2432fe6ba41fe1a4c5f10d31ec" translate="yes" xml:space="preserve">
          <source>Deprecated in favor of using &lt;a href=&quot;empty&quot;&gt;EMPTY&lt;/a&gt; constant, or &lt;a href=&quot;scheduled&quot;&gt;&lt;code&gt;scheduled&lt;/code&gt;&lt;/a&gt; (e.g. &lt;code&gt;scheduled([], scheduler)&lt;/code&gt;)</source>
          <target state="translated">不推荐使用&lt;a href=&quot;empty&quot;&gt;EMPTY&lt;/a&gt;常量，也可以使用&lt;a href=&quot;scheduled&quot;&gt; &lt;code&gt;scheduled&lt;/code&gt; &lt;/a&gt;（例如， &lt;code&gt;scheduled([], scheduler)&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="463582ed19dfc58a87321a7b92cfba5549a9c5d0" translate="yes" xml:space="preserve">
          <source>Deprecation Notes</source>
          <target state="translated">弃用说明</target>
        </trans-unit>
        <trans-unit id="34730e9bbd5c0ba7b7655973316eed44e39da85f" translate="yes" xml:space="preserve">
          <source>Deprecations</source>
          <target state="translated">Deprecations</target>
        </trans-unit>
        <trans-unit id="55f8ebc805e65b5b71ddafdae390e3be2bcd69af" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>
        </trans-unit>
        <trans-unit id="2666820b5bb0173df8ddd17b764bde4b0f8b1b61" translate="yes" xml:space="preserve">
          <source>Disposes the resources held by the subscription. May, for instance, cancel an ongoing Observable execution or cancel any other type of work that started when the Subscription was created.</source>
          <target state="translated">处置订阅所持有的资源。例如,可以取消正在进行的Observable执行或取消订阅创建时开始的任何其他类型的工作。</target>
        </trans-unit>
        <trans-unit id="316644b959082a2cc487f06bf5876e8dcf368159" translate="yes" xml:space="preserve">
          <source>Disposing Observable Executions</source>
          <target state="translated">处置可观察的执行</target>
        </trans-unit>
        <trans-unit id="af481d033e3d6a89a0a00f12185b62203c7b5177" translate="yes" xml:space="preserve">
          <source>Double Click</source>
          <target state="translated">双击</target>
        </trans-unit>
        <trans-unit id="f04e90acad2440fd4a1e87ff19b6433cbce9b7c3" translate="yes" xml:space="preserve">
          <source>Dropping the compatibility layer</source>
          <target state="translated">放弃兼容性层</target>
        </trans-unit>
        <trans-unit id="52f444678c751856f9a1ce086837968f7c75e741" translate="yes" xml:space="preserve">
          <source>Due to having operators available independent of an Observable, operator names cannot conflict with JavaScript keyword restrictions. Therefore the names of the pipeable version of some operators have changed. These operators are:</source>
          <target state="translated">由于拥有独立于Observable的操作符,操作符名称不能与JavaScript关键字限制相冲突。因此,一些操作符的可管道版本的名称已经改变。这些运算符是:</target>
        </trans-unit>
        <trans-unit id="5bc604777adb22ae457a5473c397202e00689e23" translate="yes" xml:space="preserve">
          <source>EMPTY</source>
          <target state="translated">EMPTY</target>
        </trans-unit>
        <trans-unit id="0b99cebe565822c64ac5d84aecb00fe40e59cbd3" translate="yes" xml:space="preserve">
          <source>ERROR</source>
          <target state="translated">ERROR</target>
        </trans-unit>
        <trans-unit id="42e1bdd92a7f77d27b8d2717d5eeb1d59be288ff" translate="yes" xml:space="preserve">
          <source>ES2015 introduced &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*&quot;&gt;generator functions and iterators&lt;/a&gt; (&lt;code&gt;function*&lt;/code&gt;), another type of Pull system. Code that calls &lt;code&gt;iterator.next()&lt;/code&gt; is the Consumer, &quot;pulling&quot; out &lt;em&gt;multiple&lt;/em&gt; values from the iterator (the Producer).</source>
          <target state="translated">ES2015引入了&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*&quot;&gt;生成器函数和迭代器&lt;/a&gt;（ &lt;code&gt;function*&lt;/code&gt; ），这是另一种Pull系统。调用 &lt;code&gt;iterator.next()&lt;/code&gt; 的代码是使用者，从迭代器（生产者）中&amp;ldquo;抽出&amp;rdquo; &lt;em&gt;多个&lt;/em&gt;值。</target>
        </trans-unit>
        <trans-unit id="674227a972a4b55f0756d9b2d66199ac3bfe89e5" translate="yes" xml:space="preserve">
          <source>ES6 via npm</source>
          <target state="translated">ES6通过npm</target>
        </trans-unit>
        <trans-unit id="666ff450a66a4678df3ec36c42739caaec2c8c52" translate="yes" xml:space="preserve">
          <source>Each Observable must define how to dispose resources of that execution when we create the Observable using &lt;code&gt;create()&lt;/code&gt;. You can do that by returning a custom &lt;code&gt;unsubscribe&lt;/code&gt; function from within &lt;code&gt;function subscribe()&lt;/code&gt;.</source>
          <target state="translated">当我们使用 &lt;code&gt;create()&lt;/code&gt; 创建Observable时，每个Observable必须定义如何处置执行的资源。您可以通过从 &lt;code&gt;function subscribe()&lt;/code&gt; 函数中返回一个自定义的 &lt;code&gt;unsubscribe&lt;/code&gt; 函数来实现。</target>
        </trans-unit>
        <trans-unit id="f678d49cb58e833db6233feb20eeeaa4428483bb" translate="yes" xml:space="preserve">
          <source>Each argument becomes a &lt;code&gt;next&lt;/code&gt; notification.</source>
          <target state="translated">每个参数成为 &lt;code&gt;next&lt;/code&gt; 通知。</target>
        </trans-unit>
        <trans-unit id="058613ebc4c427459ecefefd3afa54ff8652eb4e" translate="yes" xml:space="preserve">
          <source>Each space  equals 1 frame, same as a hyphen &lt;code&gt;-&lt;/code&gt;.</source>
          <target state="translated">每个空格等于1帧，与连字符 &lt;code&gt;-&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="adf1a47a9d340f3325f9f83ae4bbd1be31b28aa3" translate="yes" xml:space="preserve">
          <source>Each unit of work in a Scheduler is called an &lt;code&gt;Action&lt;/code&gt;.</source>
          <target state="translated">调度程序中的每个工作单元都称为 &lt;code&gt;Action&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a38b3bf75f93d9975be6df57e4eea447fc05cb7b" translate="yes" xml:space="preserve">
          <source>Emit &lt;code&gt;false&lt;/code&gt; for a non-empty Observable</source>
          <target state="translated">为非空Observable 发出 &lt;code&gt;false&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="36595adf79029effea5aafbe0b33e1661d847cfa" translate="yes" xml:space="preserve">
          <source>Emit &lt;code&gt;true&lt;/code&gt; for an empty Observable</source>
          <target state="translated">为空的Observable 发出 &lt;code&gt;true&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9e45731f0c536caf528a3c80e03eb08e5adb47de" translate="yes" xml:space="preserve">
          <source>Emit an array of the last clicks every [1-5] random seconds</source>
          <target state="translated">每隔[1-5]秒随机发出最后一次点击的数组。</target>
        </trans-unit>
        <trans-unit id="cae1dc3d5bbad2305fd286cad6d208c19363eab7" translate="yes" xml:space="preserve">
          <source>Emit click events only while the clientX property is greater than 200</source>
          <target state="translated">只有当clientX属性大于200时,才会发出点击事件。</target>
        </trans-unit>
        <trans-unit id="dda0faf5498ca6dcf8ab28c43818f4feec0a0a42" translate="yes" xml:space="preserve">
          <source>Emit clicks at a rate of at most one click per second</source>
          <target state="translated">以每秒最多一次点击的速度发出点击。</target>
        </trans-unit>
        <trans-unit id="3c76a13f5ebea7e20bbf00f2c9d32b7c447120aa" translate="yes" xml:space="preserve">
          <source>Emit inteval between current value with the last value</source>
          <target state="translated">发出当前值与最后值之间的整数。</target>
        </trans-unit>
        <trans-unit id="84e59125f4895d959fba5383e8c9b85b6d26b42c" translate="yes" xml:space="preserve">
          <source>Emit only click events whose target was a DIV element</source>
          <target state="translated">只发送目标为DIV元素的点击事件。</target>
        </trans-unit>
        <trans-unit id="aca713a5446a034f7eb7ee7cfd82582714e0d9f0" translate="yes" xml:space="preserve">
          <source>Emit only the first click that happens on the DOM</source>
          <target state="translated">只发射DOM上发生的第一次点击。</target>
        </trans-unit>
        <trans-unit id="6b2725c4f577b99a3c281b978bc1da2e3d162a2d" translate="yes" xml:space="preserve">
          <source>Emit only the first two clicks events in every window of [1-5] random seconds</source>
          <target state="translated">在每一个[1-5]秒的随机窗口中只发出前两次点击事件。</target>
        </trans-unit>
        <trans-unit id="d4bf60f5d394bc9dce56c9746cc1455601173e04" translate="yes" xml:space="preserve">
          <source>Emit only the third click event</source>
          <target state="translated">只发射第三次点击事件</target>
        </trans-unit>
        <trans-unit id="be82a967776bd06b73a9ef958b479a7e772ebb46" translate="yes" xml:space="preserve">
          <source>Emit the array &lt;code&gt;[1,2,3]&lt;/code&gt;</source>
          <target state="translated">发出数组 &lt;code&gt;[1,2,3]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="258507901d76adefcf885e2d2ba14720064b4f43" translate="yes" xml:space="preserve">
          <source>Emit the index of first click that happens on a DIV element</source>
          <target state="translated">发出DIV元素上发生的第一次点击的索引。</target>
        </trans-unit>
        <trans-unit id="e999d3a97f2c47d682185359cbc062466b4ecaee" translate="yes" xml:space="preserve">
          <source>Emit the last two click events as an array</source>
          <target state="translated">将最后两次点击事件以数组的形式发射出去</target>
        </trans-unit>
        <trans-unit id="b06ea69b0090aa2950941eebc373f9ab08c43134" translate="yes" xml:space="preserve">
          <source>Emit the most recent click after a burst of clicks</source>
          <target state="translated">在一连串点击后发出最近一次点击</target>
        </trans-unit>
        <trans-unit id="2ea4407361558147d8a964707b8d5610dfeeb1ab" translate="yes" xml:space="preserve">
          <source>Emit the number 7, then complete</source>
          <target state="translated">发出数字7,然后完成</target>
        </trans-unit>
        <trans-unit id="08b53dacead1c62d68921ed8a27c7e6dd38496b0" translate="yes" xml:space="preserve">
          <source>Emit the number 7, then emit an error</source>
          <target state="translated">发出数字7,然后发出一个错误信息</target>
        </trans-unit>
        <trans-unit id="b6f544e32d0273819a571f258748d660fa3de0b5" translate="yes" xml:space="preserve">
          <source>Emit the number 7, then never emit anything else (not even complete)</source>
          <target state="translated">发出数字7,然后再也不发出其他任何东西(甚至不完整)。</target>
        </trans-unit>
        <trans-unit id="035524c755f99f7f39661d88482f9c247d60ae51" translate="yes" xml:space="preserve">
          <source>Emit the values &lt;code&gt;10, 20, 30&lt;/code&gt;</source>
          <target state="translated">发射值 &lt;code&gt;10, 20, 30&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="71a66df699b18ab8842ed8372fe230b4344398b0" translate="yes" xml:space="preserve">
          <source>Emits a given value if the source Observable completes without emitting any &lt;code&gt;next&lt;/code&gt; value, otherwise mirrors the source Observable.</source>
          <target state="translated">如果源Observable完成而不发出任何 &lt;code&gt;next&lt;/code&gt; 值，则发出给定值，否则镜像源Observable。</target>
        </trans-unit>
        <trans-unit id="f5936dfcfd0d7b376e741c1351e9508df5c31a94" translate="yes" xml:space="preserve">
          <source>Emits a sequence of numbers in a range.</source>
          <target state="translated">发射一个范围内的数字序列。</target>
        </trans-unit>
        <trans-unit id="3459aa8bde5600535a38bc29ec55520c8ffe5b3b" translate="yes" xml:space="preserve">
          <source>Emits a value from the source Observable only after a particular time span determined by another Observable has passed without another source emission.</source>
          <target state="translated">只有在另一个Observable确定的特定时间跨度过去后,没有另一个源的发射,才从源Observable发射一个值。</target>
        </trans-unit>
        <trans-unit id="796b34385a59e79b833e9d74db73634c2b0ff888" translate="yes" xml:space="preserve">
          <source>Emits a value from the source Observable only after a particular time span has passed without another source emission.</source>
          <target state="translated">只有在一个特定的时间跨度过后,没有另一个源的发射,才会从源可观察到一个值。</target>
        </trans-unit>
        <trans-unit id="1145fc21b2f2c2783c18b2286b6ba6d20b685d48" translate="yes" xml:space="preserve">
          <source>Emits a value from the source Observable, then ignores subsequent source values for &lt;code&gt;duration&lt;/code&gt; milliseconds, then repeats this process.</source>
          <target state="translated">从源Observable发出一个值，然后忽略 &lt;code&gt;duration&lt;/code&gt; 毫秒的后续源值，然后重复此过程。</target>
        </trans-unit>
        <trans-unit id="3ea9d1e82cdd52be474e2587516de6ae66e19bc8" translate="yes" xml:space="preserve">
          <source>Emits a value from the source Observable, then ignores subsequent source values for a duration determined by another Observable, then repeats this process.</source>
          <target state="translated">从源Observable发出一个值,然后在另一个Observable确定的持续时间内忽略后续的源值,然后重复这个过程。</target>
        </trans-unit>
        <trans-unit id="9362d35a79ede3aa7be38e1b31753d1ce5e19bfa" translate="yes" xml:space="preserve">
          <source>Emits an object containing the current value, and the time that has passed between emitting the current value and the previous value, which is calculated by using the provided &lt;code&gt;scheduler&lt;/code&gt;'s &lt;code&gt;now()&lt;/code&gt; method to retrieve the current time at each emission, then calculating the difference. The &lt;code&gt;scheduler&lt;/code&gt; defaults to &lt;a href=&quot;../index/const/asyncscheduler&quot;&gt;&lt;code&gt;async&lt;/code&gt;&lt;/a&gt;, so by default, the &lt;code&gt;interval&lt;/code&gt; will be in milliseconds.</source>
          <target state="translated">发出一个对象，该对象包含当前值，以及在发出当前值和先前值之间经过的时间，该时间是通过使用提供的 &lt;code&gt;scheduler&lt;/code&gt; 的 &lt;code&gt;now()&lt;/code&gt; 方法在每次发出时检索当前时间来计算的，然后计算区别。所述 &lt;code&gt;scheduler&lt;/code&gt; 默认为&lt;a href=&quot;../index/const/asyncscheduler&quot;&gt; &lt;code&gt;async&lt;/code&gt; &lt;/a&gt;，所以默认情况下， &lt;code&gt;interval&lt;/code&gt; 将在毫秒。</target>
        </trans-unit>
        <trans-unit id="a0bc548abaef51ec19270a209d925069b3deaf16" translate="yes" xml:space="preserve">
          <source>Emits ascending numbers, one every second (1000ms) up to the number 3</source>
          <target state="translated">发出升序数字,每秒钟(1000ms)一个,直到数字3。</target>
        </trans-unit>
        <trans-unit id="416f5c82d0c0c1e9c7bc782fe6a56560370e5e6d" translate="yes" xml:space="preserve">
          <source>Emits ascending numbers, one every second (1000ms), starting after 3 seconds</source>
          <target state="translated">发出升序数字,每秒钟(1000ms)一个,3秒后开始。</target>
        </trans-unit>
        <trans-unit id="987c87f4a4f4e45515380da71ea51604f2c31a4c" translate="yes" xml:space="preserve">
          <source>Emits clicks happening on the DOM document</source>
          <target state="translated">发出发生在DOM文档上的点击。</target>
        </trans-unit>
        <trans-unit id="fb68143f9c22c639fe4241870686be6e3443cf56" translate="yes" xml:space="preserve">
          <source>Emits false if the input observable emits any values, or emits true if the input observable completes without emitting any values.</source>
          <target state="translated">如果输入的观测值发出任何值,则发出false;如果输入的观测值完成而不发出任何值,则发出true。</target>
        </trans-unit>
        <trans-unit id="40866b2ae203c7bcd97be2c7b2bd3a74f920770b" translate="yes" xml:space="preserve">
          <source>Emits incremental numbers periodically in time.</source>
          <target state="translated">按时间周期性地发出递增的数字。</target>
        </trans-unit>
        <trans-unit id="dfc6629a60560428832a42a80e579e178deeedea" translate="yes" xml:space="preserve">
          <source>Emits one number after five seconds</source>
          <target state="translated">5秒后发出一个数字</target>
        </trans-unit>
        <trans-unit id="c8db73b5e36157de7f7351e274e9b9ff88a812aa" translate="yes" xml:space="preserve">
          <source>Emits only the first &lt;code&gt;count&lt;/code&gt; values emitted by the source Observable.</source>
          <target state="translated">只发射第一 &lt;code&gt;count&lt;/code&gt; 发出源Observable数值。</target>
        </trans-unit>
        <trans-unit id="8578296e355b5b8276c06eca98343ce699c77a41" translate="yes" xml:space="preserve">
          <source>Emits only the first value (or the first value that meets some condition) emitted by the source Observable.</source>
          <target state="translated">只发射源Observable发出的第一个值(或满足某种条件的第一个值)。</target>
        </trans-unit>
        <trans-unit id="ee4e2bb5f62bd3a3b6a3b8f9742dadbb7c8fd314" translate="yes" xml:space="preserve">
          <source>Emits only the first value emitted by the source Observable that meets some condition.</source>
          <target state="translated">只发射符合某种条件的源Observable发出的第一个值。</target>
        </trans-unit>
        <trans-unit id="d453139a17724a88567155f88992de9a43704fed" translate="yes" xml:space="preserve">
          <source>Emits only the first value. Or emits only the first value that passes some test.</source>
          <target state="translated">只发射第一个值。或者只发射通过某种测试的第一个值。</target>
        </trans-unit>
        <trans-unit id="47bb0a635fba06f7e64359ed31cd996b61370dd0" translate="yes" xml:space="preserve">
          <source>Emits only the i-th value, then completes.</source>
          <target state="translated">只发出第i个值,然后完成。</target>
        </trans-unit>
        <trans-unit id="ce3a6a1ffd4b5b5bdb5c7fe2a320ecee099869c6" translate="yes" xml:space="preserve">
          <source>Emits only the index of the first value emitted by the source Observable that meets some condition.</source>
          <target state="translated">只发射符合某种条件的源Observable发出的第一个值的索引。</target>
        </trans-unit>
        <trans-unit id="c942645033239d24b677fcb60f721a558bf5f73f" translate="yes" xml:space="preserve">
          <source>Emits only the last &lt;code&gt;count&lt;/code&gt; values emitted by the source Observable.</source>
          <target state="translated">仅发出最后一个 &lt;code&gt;count&lt;/code&gt; 发出源Observable数值。</target>
        </trans-unit>
        <trans-unit id="633638a649508aa1d7574551df6b44843d5c0978" translate="yes" xml:space="preserve">
          <source>Emits the first click that happens on a DIV</source>
          <target state="translated">发出DIV上发生的第一次点击。</target>
        </trans-unit>
        <trans-unit id="33baacac631afed4cb4748baf32b4a71bcb00d28" translate="yes" xml:space="preserve">
          <source>Emits the given constant value on the output Observable every time the source Observable emits a value.</source>
          <target state="translated">每当源Observable发出一个值时,在输出Observable上发出给定的常量。</target>
        </trans-unit>
        <trans-unit id="471a2baa629dc6681c52e99caccf2f18b0e2938c" translate="yes" xml:space="preserve">
          <source>Emits the most recently emitted value from the source Observable whenever another Observable, the &lt;code&gt;notifier&lt;/code&gt;, emits.</source>
          <target state="translated">每当另一个Observable（ &lt;code&gt;notifier&lt;/code&gt; 发出源Observable的最新发射值）发出。</target>
        </trans-unit>
        <trans-unit id="2254e36517076818c8f4383fb5e0ecdaf0d2521b" translate="yes" xml:space="preserve">
          <source>Emits the most recently emitted value from the source Observable within periodic time intervals.</source>
          <target state="translated">在周期性的时间间隔内,从源头观察到的最近发射的数值。</target>
        </trans-unit>
        <trans-unit id="c275f10e004389aaf9cbd780140b6f96348805dc" translate="yes" xml:space="preserve">
          <source>Emits the numbers 1 to 10</source>
          <target state="translated">发射数字1至10</target>
        </trans-unit>
        <trans-unit id="33e3a9ae3cb8e784f5aecfedde6103fba869fe5b" translate="yes" xml:space="preserve">
          <source>Emits the single value at the specified &lt;code&gt;index&lt;/code&gt; in a sequence of emissions from the source Observable.</source>
          <target state="translated">在指定的 &lt;code&gt;index&lt;/code&gt; 处发出单个值在来自源Observable的发射序列中。</target>
        </trans-unit>
        <trans-unit id="1a493989aa04d9a64a56db66249f73aafd987eda" translate="yes" xml:space="preserve">
          <source>Emits the values emitted by the source Observable until a &lt;code&gt;notifier&lt;/code&gt; Observable emits a value.</source>
          <target state="translated">发出由源Observable发出的值，直到 &lt;code&gt;notifier&lt;/code&gt; Observable发出一个值。</target>
        </trans-unit>
        <trans-unit id="3c7bee64498c2a7e9a5a73840f298dd4a0a008ee" translate="yes" xml:space="preserve">
          <source>Emits values emitted by the source Observable so long as each value satisfies the given &lt;code&gt;predicate&lt;/code&gt;, and then completes as soon as this &lt;code&gt;predicate&lt;/code&gt; is not satisfied.</source>
          <target state="translated">只要每个值满足给定 &lt;code&gt;predicate&lt;/code&gt; ，就发出源Observable发出的值，然后在不满足此 &lt;code&gt;predicate&lt;/code&gt; 立即完成。</target>
        </trans-unit>
        <trans-unit id="4a93d62619ac813564e9da8a4eebdc9e63296f52" translate="yes" xml:space="preserve">
          <source>EmptyError</source>
          <target state="translated">EmptyError</target>
        </trans-unit>
        <trans-unit id="c6a5baec1a656a6918482ae0a38e309a4e174ed7" translate="yes" xml:space="preserve">
          <source>EmptyObservable</source>
          <target state="translated">EmptyObservable</target>
        </trans-unit>
        <trans-unit id="c919a5ad2e7fdd8f109a1caa5d1715b51ed11664" translate="yes" xml:space="preserve">
          <source>Ensure a specific scheduler is used, from outside of an Observable.</source>
          <target state="translated">确保使用一个特定的调度器,从Observable之外。</target>
        </trans-unit>
        <trans-unit id="83c2c62e8479762708c16c7da93e27d58c64626d" translate="yes" xml:space="preserve">
          <source>Ensure values in subscribe are called just before browser repaint.</source>
          <target state="translated">确保在浏览器重绘前调用订阅中的值。</target>
        </trans-unit>
        <trans-unit id="c2e8a31728f0c93cb4c1c3ea370cd7225cf97657" translate="yes" xml:space="preserve">
          <source>Ergonomic defaults for &lt;code&gt;hot&lt;/code&gt; and &lt;code&gt;cold&lt;/code&gt;</source>
          <target state="translated">符合人体工程学的默认设置为 &lt;code&gt;hot&lt;/code&gt; 和 &lt;code&gt;cold&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b8a2a7f6e5c6d27ddebfed1897c207d4db559890" translate="yes" xml:space="preserve">
          <source>Error Handling Operators</source>
          <target state="translated">错误处理操作员</target>
        </trans-unit>
        <trans-unit id="9ceb71ac05eb7c0d4e0f71e59f027348742ea94e" translate="yes" xml:space="preserve">
          <source>ErrorObservable</source>
          <target state="translated">ErrorObservable</target>
        </trans-unit>
        <trans-unit id="459dd73e2f9690fb4438b0975a4b05b0ce7cfa81" translate="yes" xml:space="preserve">
          <source>ErrorObserver</source>
          <target state="translated">ErrorObserver</target>
        </trans-unit>
        <trans-unit id="5e34fb3687b1278339ee0d3379e624bb84cd98a9" translate="yes" xml:space="preserve">
          <source>Errors if Observable does not emit a value in given time span, in case of which subscribes to the second Observable.</source>
          <target state="translated">如果Observable在给定的时间跨度内没有发出一个值,则会发生错误,如果该值订阅了第二个Observable。</target>
        </trans-unit>
        <trans-unit id="6e5818bcafbec15ddf51911a2500238bc9d154f3" translate="yes" xml:space="preserve">
          <source>Errors if Observable does not emit a value in given time span.</source>
          <target state="translated">如果Observable在给定的时间跨度内没有发出一个值,则出现错误。</target>
        </trans-unit>
        <trans-unit id="38f019ec5a63549d3da60d25881b1179dbc406bc" translate="yes" xml:space="preserve">
          <source>Eventually, you will want to &lt;a href=&quot;migration#drop-compat&quot;&gt;drop the compatibility layer&lt;/a&gt; to complete the update to RxJS v6. Doing so will significantly decrease the size of your apps.</source>
          <target state="translated">最终，您将需要&lt;a href=&quot;migration#drop-compat&quot;&gt;删除兼容性层&lt;/a&gt;以完成对RxJS v6的更新。这样做将大大减小应用程序的大小。</target>
        </trans-unit>
        <trans-unit id="d18cb123476987ea913bfeca6bc87919f03bebfc" translate="yes" xml:space="preserve">
          <source>Every 5 seconds start a window 1 second long, and emit at most 2 click events per window</source>
          <target state="translated">每5秒启动一个1秒长的窗口,每个窗口最多发出2次点击事件。</target>
        </trans-unit>
        <trans-unit id="cb9905734da60c3cce52678ea5d32b0f08238cd2" translate="yes" xml:space="preserve">
          <source>Every 5 seconds, emit the click events from the next 2 seconds</source>
          <target state="translated">每隔5秒,发出接下来2秒的点击事件。</target>
        </trans-unit>
        <trans-unit id="90c6a7e49deda3f103b834960dca350177cc2e5b" translate="yes" xml:space="preserve">
          <source>Every JavaScript Function is a Pull system. The function is a Producer of data, and the code that calls the function is consuming it by &quot;pulling&quot; out a &lt;em&gt;single&lt;/em&gt; return value from its call.</source>
          <target state="translated">每个JavaScript函数都是一个Pull系统。该函数是数据的生产者，并且调用该函数的代码通过从调用中&amp;ldquo;拉出&amp;rdquo; &lt;em&gt;单个&lt;/em&gt;返回值来使用它。</target>
        </trans-unit>
        <trans-unit id="568b3d67354a5fa6ac1d4ef7693c00e90a54fb43" translate="yes" xml:space="preserve">
          <source>Every Subject is an Observable and an Observer. You can subscribe to a Subject, and you can call next to feed values as well as error and complete.</source>
          <target state="translated">每一个Subject都是一个Observable和一个Observer。你可以订阅一个Subject,你可以调用旁边的feed值以及错误和完成。</target>
        </trans-unit>
        <trans-unit id="1aa05f062d0202c71119ad89e743230455866b79" translate="yes" xml:space="preserve">
          <source>Every other second, emit the click events from the next 500ms</source>
          <target state="translated">每隔一秒,发出接下来500ms的点击事件。</target>
        </trans-unit>
        <trans-unit id="d7a66bf925858e2f45ba1914ac8b54a09fb42dc1" translate="yes" xml:space="preserve">
          <source>Every second, emit an array of the recent click events</source>
          <target state="translated">每隔一秒发出一个最近点击事件的数组。</target>
        </trans-unit>
        <trans-unit id="fe3c8aa86bdfe0f0edf5b8b63b533f703120c08f" translate="yes" xml:space="preserve">
          <source>Every second, emit the most recent click at most once</source>
          <target state="translated">每隔一秒,最多发出一次最近的点击。</target>
        </trans-unit>
        <trans-unit id="d33c52a1410cde2ffc8ffc9c4edd53ef14bdbed3" translate="yes" xml:space="preserve">
          <source>Every time an inner Observable emits, the output Observable emits</source>
          <target state="translated">每当一个内在的Observable发出来时,输出的Observable就会发出来。</target>
        </trans-unit>
        <trans-unit id="19ed07cf669163fd549db2eac802f1a0db6dcee4" translate="yes" xml:space="preserve">
          <source>Every time resulting Observable is subscribed, event handler function will be registered to event target on given event type. When that event fires, value passed as a first argument to registered function will be emitted by output Observable. When Observable is unsubscribed, function will be unregistered from event target.</source>
          <target state="translated">每当产生的Observable被订阅时,事件处理函数将被注册到指定事件类型的事件目标上。当该事件发生时,作为第一参数传递给注册函数的值将由输出Observable发出。当Observable被取消订阅时,函数将从事件目标上取消注册。</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="392fe123059b9042a525c45fd36c5654d0b87c0c" translate="yes" xml:space="preserve">
          <source>Execute series of Observables no matter what, even if it means swallowing errors.</source>
          <target state="translated">无论如何执行一系列的Observables,即使这意味着吞下错误。</target>
        </trans-unit>
        <trans-unit id="ffa0db8a0362fcc46cdb81bf76f1fdb699e21fa2" translate="yes" xml:space="preserve">
          <source>Executing Observables</source>
          <target state="translated">执行观测值</target>
        </trans-unit>
        <trans-unit id="71a576c62e540f89942e39482d77e573b45c5750" translate="yes" xml:space="preserve">
          <source>Factory function to create an intermediate subject through which the source sequence's elements will be multicast to the selector function or Subject to push source elements into.</source>
          <target state="translated">工厂函数,用于创建一个中间主体,通过这个中间主体,源序列的元素将被多播到选择器函数或主体中,以将源元素推入。</target>
        </trans-unit>
        <trans-unit id="49ebe28cd9d8a3b499e2ee48c4519d62f46db7ff" translate="yes" xml:space="preserve">
          <source>FactoryOrValue</source>
          <target state="translated">FactoryOrValue</target>
        </trans-unit>
        <trans-unit id="b2b3f280ebecac0f650af8442da0c28b812dc3a1" translate="yes" xml:space="preserve">
          <source>Filter items emitted by the source Observable by only emitting those that satisfy a specified predicate.</source>
          <target state="translated">过滤源Observable发出的项目,只发出满足指定前提条件的项目。</target>
        </trans-unit>
        <trans-unit id="40e34b6dd8be897316b63fbba02a18e6929f348e" translate="yes" xml:space="preserve">
          <source>Filtering Operators</source>
          <target state="translated">筛选器</target>
        </trans-unit>
        <trans-unit id="e8471e9cac7e3ccd5d662762dfc077ee68ce5fa5" translate="yes" xml:space="preserve">
          <source>Find and emit the first click that happens on a DIV element</source>
          <target state="translated">找到并发出DIV元素上发生的第一次点击。</target>
        </trans-unit>
        <trans-unit id="bdde1667c7637fa9e392561fe37a9129b5e37d35" translate="yes" xml:space="preserve">
          <source>Finds the first value that passes some test and emits that.</source>
          <target state="translated">找到第一个通过某个测试的值,并发出该值。</target>
        </trans-unit>
        <trans-unit id="e93ac40354ce3c02e55c7b9d6be7101043533708" translate="yes" xml:space="preserve">
          <source>First Observer subscribes to the multicasted Observable</source>
          <target state="translated">第一个观察者订阅多播的可观察对象</target>
        </trans-unit>
        <trans-unit id="9f43d22726f1db010faa50c5dad1f4baef24a307" translate="yes" xml:space="preserve">
          <source>First Observer unsubscribes from the multicasted Observable</source>
          <target state="translated">第一个观察者取消订阅多播的可观察信息。</target>
        </trans-unit>
        <trans-unit id="2c0a59b2a738934720a981af4caf0f2257febc5f" translate="yes" xml:space="preserve">
          <source>First emits its arguments in order, and then any emissions from the source.</source>
          <target state="translated">首先按顺序排放其参数,然后从源头排放任何。</target>
        </trans-unit>
        <trans-unit id="8447958c50fe14e1542bd2daf039b6f88aec1dcb" translate="yes" xml:space="preserve">
          <source>First examples</source>
          <target state="translated">第一个例子</target>
        </trans-unit>
        <trans-unit id="3e6017001d21808ecf90abeb0ea1829904c30600" translate="yes" xml:space="preserve">
          <source>Flattens an Observable-of-Observables by applying &lt;a href=&quot;../index/function/combinelatest&quot;&gt;&lt;code&gt;combineLatest&lt;/code&gt;&lt;/a&gt; when the Observable-of-Observables completes.</source>
          <target state="translated">当Observable-of-Observables完成时，通过应用&lt;a href=&quot;../index/function/combinelatest&quot;&gt; &lt;code&gt;combineLatest&lt;/code&gt; &lt;/a&gt;来展平Observable-of-Observables。</target>
        </trans-unit>
        <trans-unit id="04cfff7f117896451c5efe35700ad71de1b0e885" translate="yes" xml:space="preserve">
          <source>Flattens an Observable-of-Observables by dropping the next inner Observables while the current inner is still executing.</source>
          <target state="translated">扁平化一个Observables的Observable,当当前的内层Observable还在执行时,放弃下一个内层Observable。</target>
        </trans-unit>
        <trans-unit id="7c4a395e33ae8f3613262bc17d460166f11f9771" translate="yes" xml:space="preserve">
          <source>Flattens an Observable-of-Observables by putting one inner Observable after the other.</source>
          <target state="translated">将一个Observable中的Observable的内层Observable一个接一个地放平。</target>
        </trans-unit>
        <trans-unit id="6261077d2db4f0f01ad8b5805900564289137493" translate="yes" xml:space="preserve">
          <source>Flattens an Observable-of-Observables.</source>
          <target state="translated">扁平化一个Observables中的Observables。</target>
        </trans-unit>
        <trans-unit id="336fdc425e8fb1e80985b24a579f686f6a6e2009" translate="yes" xml:space="preserve">
          <source>Flattens multiple Observables together by blending their values into one Observable.</source>
          <target state="translated">通过将多个Observable的值混合成一个Observable,从而将多个Observable平铺在一起。</target>
        </trans-unit>
        <trans-unit id="86eff8eb789b097ddca83f2c9c4617ed23605105" translate="yes" xml:space="preserve">
          <source>Flow</source>
          <target state="translated">Flow</target>
        </trans-unit>
        <trans-unit id="3c706a96d542205f77531708a1c3b3097bd865a3" translate="yes" xml:space="preserve">
          <source>For CDN, you can use &lt;a href=&quot;https://unpkg.com/&quot;&gt;unpkg&lt;/a&gt;. Just replace version with the current version on the link below:</source>
          <target state="translated">对于CDN，可以使用&lt;a href=&quot;https://unpkg.com/&quot;&gt;unpkg&lt;/a&gt;。只需在下面的链接上用当前版本替换版本：</target>
        </trans-unit>
        <trans-unit id="4dfc618a631337e10398e7c78f1909641f8774de" translate="yes" xml:space="preserve">
          <source>For JavaScript developers, the general rule is as follows:</source>
          <target state="translated">对于JavaScript开发人员来说,一般规则如下。</target>
        </trans-unit>
        <trans-unit id="b93bc381a837cdd2e8f67790fd49b772a51d3702" translate="yes" xml:space="preserve">
          <source>For RxJS 5.0.0-beta.1 through beta.11: &lt;a href=&quot;https://unpkg.com/@reactivex/rxjs@version/dist/global/Rx.umd.js&quot;&gt;https://unpkg.com/@reactivex/rxjs@version/dist/global/Rx.umd.js&lt;/a&gt;</source>
          <target state="translated">对于RxJS 5.0.0-beta.1到beta.11：&lt;a href=&quot;https://unpkg.com/@reactivex/rxjs@version/dist/global/Rx.umd.js&quot;&gt;https&lt;/a&gt; ://unpkg.com/@reactivex/rxjs@version/dist/global/Rx.umd.js</target>
        </trans-unit>
        <trans-unit id="b2cc880d660c8400030b8519a180258b600db213" translate="yes" xml:space="preserve">
          <source>For RxJS 5.0.0-beta.12 and higher: &lt;a href=&quot;https://unpkg.com/@reactivex/rxjs@version/dist/global/Rx.js&quot;&gt;https://unpkg.com/@reactivex/rxjs@version/dist/global/Rx.js&lt;/a&gt;</source>
          <target state="translated">对于RxJS 5.0.0-beta.12及更高版本：&lt;a href=&quot;https://unpkg.com/@reactivex/rxjs@version/dist/global/Rx.js&quot;&gt;https&lt;/a&gt; ://unpkg.com/@reactivex/rxjs@version/dist/global/Rx.js</target>
        </trans-unit>
        <trans-unit id="30781bd7122d9317d92dfe60463848c929299e16" translate="yes" xml:space="preserve">
          <source>For RxJS 6.0.0 and higher: &lt;a href=&quot;https://unpkg.com/@reactivex/rxjs@version/dist/global/rxjs.umd.js&quot;&gt;https://unpkg.com/@reactivex/rxjs@version/dist/global/rxjs.umd.js&lt;/a&gt;</source>
          <target state="translated">对于RxJS 6.0.0及更高版本：&lt;a href=&quot;https://unpkg.com/@reactivex/rxjs@version/dist/global/rxjs.umd.js&quot;&gt;https&lt;/a&gt; ://unpkg.com/@reactivex/rxjs@version/dist/global/rxjs.umd.js</target>
        </trans-unit>
        <trans-unit id="3aacb38d3ba8f1eca27a7d04d08c9ec383211f28" translate="yes" xml:space="preserve">
          <source>For a complete overview, see the &lt;a href=&quot;https://rxjs.dev/api&quot;&gt;references page&lt;/a&gt;.</source>
          <target state="translated">有关完整概述，请参见&lt;a href=&quot;https://rxjs.dev/api&quot;&gt;参考页&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="71adf40f1b3801502c368d773ac928b5fff11968" translate="yes" xml:space="preserve">
          <source>For a full explanation of what you will have to update in order to remove &lt;code&gt;rxjs-compat&lt;/code&gt;, see &lt;a href=&quot;migration#drop-compat&quot;&gt;Dropping the compatibility layer&lt;/a&gt;. Note also that fully updating your application to v6 may expose existing type errors that were not previously shown.</source>
          <target state="translated">有关删除 &lt;code&gt;rxjs-compat&lt;/code&gt; 所必须更新的内容的完整说明，请参见&lt;a href=&quot;migration#drop-compat&quot;&gt;删除兼容性层&lt;/a&gt;。还要注意，将应用程序完全更新到v6可能会暴露以前未显示的现有类型错误。</target>
        </trans-unit>
        <trans-unit id="3075c8d5f2ddd9453495c23a6d3a85a860c95665" translate="yes" xml:space="preserve">
          <source>For details about this package, see &lt;a href=&quot;https://www.npmjs.com/package/rxjs-compat&quot;&gt;https://www.npmjs.com/package/rxjs-compat&lt;/a&gt;.</source>
          <target state="translated">有关此软件包的详细信息，请参见&lt;a href=&quot;https://www.npmjs.com/package/rxjs-compat&quot;&gt;https://www.npmjs.com/package/rxjs-compat&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cd428686c6c90545d8b2bcd91920f91a6a7f16b7" translate="yes" xml:space="preserve">
          <source>For each click event, start an interval Observable ticking every 1 second</source>
          <target state="translated">对于每一个点击事件,开始每隔1秒滴答一次的时间间隔Observable。</target>
        </trans-unit>
        <trans-unit id="9b5bd25151ae50ac80cb48151094fd9a522bc6b1" translate="yes" xml:space="preserve">
          <source>For each click event, tick every second from 0 to 3, with no concurrency</source>
          <target state="translated">对于每一个点击事件,从0到3每秒钟打一次勾,没有并发性。</target>
        </trans-unit>
        <trans-unit id="da73e6bc7c69579ce47d156493aaad13c78b9719" translate="yes" xml:space="preserve">
          <source>For example, the following code uses chaining:</source>
          <target state="translated">例如,下面的代码使用了链式。</target>
        </trans-unit>
        <trans-unit id="1390fdbdab4c48752843cc3d3c5e3771179171fc" translate="yes" xml:space="preserve">
          <source>For example, the operator called &lt;a href=&quot;../api/operators/map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt; is analogous to the Array method of the same name. Just as &lt;code&gt;[1, 2, 3].map(x =&amp;gt; x * x)&lt;/code&gt; will yield &lt;code&gt;[1, 4, 9]&lt;/code&gt;, the Observable created like this:</source>
          <target state="translated">例如，称为&lt;a href=&quot;../api/operators/map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt;的运算符类似于同名的Array方法。就像 &lt;code&gt;[1, 2, 3].map(x =&amp;gt; x * x)&lt;/code&gt; 将产生 &lt;code&gt;[1, 4, 9]&lt;/code&gt; 1、4、9 ]一样，创建的Observable如下所示：</target>
        </trans-unit>
        <trans-unit id="853b2727d71c0f828cbb891d5a55aed1ec783449" translate="yes" xml:space="preserve">
          <source>For example, you could make a function that discarded odd values and doubled even values like this:</source>
          <target state="translated">例如,你可以做一个丢弃奇数值并将偶数值加倍的函数,就像这样。</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="ec273ba7965ca090ef888c5ba8c99a2ff30f1dec" translate="yes" xml:space="preserve">
          <source>For instance, this is how we clear an interval execution set with &lt;code&gt;setInterval&lt;/code&gt;:</source>
          <target state="translated">例如，这就是我们使用 &lt;code&gt;setInterval&lt;/code&gt; 清除间隔执行集的方式：</target>
        </trans-unit>
        <trans-unit id="e26f23e8b0af8cdf983bb14b29d6d328a65014a9" translate="yes" xml:space="preserve">
          <source>For instance, with &lt;code&gt;zip&lt;/code&gt;, we would write</source>
          <target state="translated">例如，使用 &lt;code&gt;zip&lt;/code&gt; ，我们将编写</target>
        </trans-unit>
        <trans-unit id="838888620b40e19c6ff7033090befe975b7f38ac" translate="yes" xml:space="preserve">
          <source>For typings users:</source>
          <target state="translated">对于打字用户。</target>
        </trans-unit>
        <trans-unit id="0e64fe21f9689afc29ace240393c9a0373103b20" translate="yes" xml:space="preserve">
          <source>ForkJoinObservable</source>
          <target state="translated">ForkJoinObservable</target>
        </trans-unit>
        <trans-unit id="1c20ecad94bb21004fd90931f9cf9570a480d646" translate="yes" xml:space="preserve">
          <source>FromEventObservable</source>
          <target state="translated">FromEventObservable</target>
        </trans-unit>
        <trans-unit id="c3e704712cb43291834e2a5aa665ac60fe6ead64" translate="yes" xml:space="preserve">
          <source>FromEventPatternObservable</source>
          <target state="translated">FromEventPatternObservable</target>
        </trans-unit>
        <trans-unit id="ba952857f29ad095dbdd44119f64aee2803a96d9" translate="yes" xml:space="preserve">
          <source>FromObservable</source>
          <target state="translated">FromObservable</target>
        </trans-unit>
        <trans-unit id="621c78a2e74d2dc796c3b71647b55c0326ffa66c" translate="yes" xml:space="preserve">
          <source>Function to be called when source terminates.</source>
          <target state="translated">源终止时调用的函数。</target>
        </trans-unit>
        <trans-unit id="957c5944acd33361e7062dcad7a7a9a695d6b332" translate="yes" xml:space="preserve">
          <source>Functional composition is awesome. Building your own custom operators becomes much easier, and now they work and look just like all other operators in rxjs. You don't need to extend Observable or override &lt;code&gt;lift&lt;/code&gt; anymore.</source>
          <target state="translated">功能组成很棒。构建您自己的自定义运算符变得更加容易，现在它们可以正常工作，并且看起来就像rxjs中的所有其他运算符一样。您无需再扩展Observable或覆盖 &lt;code&gt;lift&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3889ea8611c26a725e8465c567a219fb5666a68d" translate="yes" xml:space="preserve">
          <source>Functions can only return one value. Observables, however, can do this:</source>
          <target state="translated">函数只能返回一个值。然而,可观察函数可以做到这一点。</target>
        </trans-unit>
        <trans-unit id="303e10207f177b23a328afb3ed7c795eb19ec395" translate="yes" xml:space="preserve">
          <source>Generate new Observable according to source Observable values</source>
          <target state="translated">根据源观测值生成新的观测值。</target>
        </trans-unit>
        <trans-unit id="5bc786743f08df2282eeb88bdd929373a66a5cbd" translate="yes" xml:space="preserve">
          <source>GenerateObservable</source>
          <target state="translated">GenerateObservable</target>
        </trans-unit>
        <trans-unit id="81c0c27865a5aabbe78b36634e674339ea12f03f" translate="yes" xml:space="preserve">
          <source>Generates an Observable by running a state-driven loop that emits an element on each iteration.</source>
          <target state="translated">通过运行一个状态驱动的循环来生成一个Observable,该循环在每次迭代时发出一个元素。</target>
        </trans-unit>
        <trans-unit id="54ff995c1db460f7d4ec8a43c9ff7df5b3307597" translate="yes" xml:space="preserve">
          <source>Generates an observable sequence by running a state-driven loop producing the sequence's elements, using the specified scheduler to send out observer messages.</source>
          <target state="translated">通过运行一个状态驱动的循环来生成一个可观察的序列,生成序列的元素,使用指定的调度器来发送观察者消息。</target>
        </trans-unit>
        <trans-unit id="98b825ac41b8397865bf35074f515a8f5e86edd2" translate="yes" xml:space="preserve">
          <source>Generates an observable sequence by running a state-driven loop producing the sequence's elements, using the specified scheduler to send out observer messages. The overload accepts options object that might contain initial state, iterate, condition and scheduler.</source>
          <target state="translated">通过运行一个状态驱动的循环来生成一个可观察的序列,生成序列的元素,使用指定的调度器来发送观察者消息。重载接受的选项对象可能包含初始状态、迭代、条件和调度器。</target>
        </trans-unit>
        <trans-unit id="ad90c1a944ee3fa6d5c7be853db7c58d15ddb878" translate="yes" xml:space="preserve">
          <source>Generates an observable sequence by running a state-driven loop producing the sequence's elements, using the specified scheduler to send out observer messages. The overload accepts options object that might contain initial state, iterate, condition, result selector and scheduler.</source>
          <target state="translated">通过运行一个状态驱动的循环来生成一个可观察的序列,产生序列的元素,使用指定的调度器来发送观察者消息。重载接受的选项对象可能包含初始状态、迭代、条件、结果选择器和调度器。</target>
        </trans-unit>
        <trans-unit id="57184ea89e0ad3d9688251dfe4bd88d9b6a4b24c" translate="yes" xml:space="preserve">
          <source>Generating PNG marble diagrams from tests</source>
          <target state="translated">从测试中生成PNG大理石图。</target>
        </trans-unit>
        <trans-unit id="551763240307b358e2541252c4ea9844aad40ac7" translate="yes" xml:space="preserve">
          <source>Get all values inside an array when the source completes</source>
          <target state="translated">当源完成时,获取一个数组中的所有值。</target>
        </trans-unit>
        <trans-unit id="6192885702ae8a6bc4b4e65f4064742ed47013e0" translate="yes" xml:space="preserve">
          <source>Get the maximal value of a series of numbers</source>
          <target state="translated">获取一个数列的最大值</target>
        </trans-unit>
        <trans-unit id="cd9b12ae584c39e58461f2d1c2bc7b2d2d918c83" translate="yes" xml:space="preserve">
          <source>Get the minimal value of a series of numbers</source>
          <target state="translated">获取一系列数字的最小值</target>
        </trans-unit>
        <trans-unit id="82645a0e54372b3bd69d16159415e8bede299b3c" translate="yes" xml:space="preserve">
          <source>Give it a function &lt;code&gt;f&lt;/code&gt; of type &lt;code&gt;f(x, callback)&lt;/code&gt; and it will return a function &lt;code&gt;g&lt;/code&gt; that when called as &lt;code&gt;g(x)&lt;/code&gt; will output an Observable.</source>
          <target state="translated">给它一个类型为 &lt;code&gt;f(x, callback)&lt;/code&gt; 的函数 &lt;code&gt;f&lt;/code&gt; ，它将返回一个函数 &lt;code&gt;g&lt;/code&gt; ，该函数在被称为 &lt;code&gt;g(x)&lt;/code&gt; 时将输出一个Observable。</target>
        </trans-unit>
        <trans-unit id="6f36b89b671804ed1110fb922788cc37c4a564fe" translate="yes" xml:space="preserve">
          <source>Given a hot source, test multiple subscribers that subscribe at different times:</source>
          <target state="translated">给定一个热源,测试多个在不同时间订阅的用户。</target>
        </trans-unit>
        <trans-unit id="39da52064d9093fec3f687f9ef3a311b61691213" translate="yes" xml:space="preserve">
          <source>Given a list of strings describing a path to an object property, retrieves the value of a specified nested property from all values in the source Observable. If a property can't be resolved, it will return &lt;code&gt;undefined&lt;/code&gt; for that value.</source>
          <target state="translated">给定描述对象属性路径的字符串列表，可从源Observable中的所有值中检索指定的嵌套属性的值。如果无法解析属性，则它将为该值返回 &lt;code&gt;undefined&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="07449bc0c82fd975877782bde1b7acc37ead6d3e" translate="yes" xml:space="preserve">
          <source>Given some &lt;a href=&quot;../interface/observer&quot;&gt;&lt;code&gt;Observer&lt;/code&gt;&lt;/a&gt; callbacks, deliver the value represented by the current Notification to the correctly corresponding callback.</source>
          <target state="translated">给定一些&lt;a href=&quot;../interface/observer&quot;&gt; &lt;code&gt;Observer&lt;/code&gt; &lt;/a&gt;回调，将当前Notification表示的值传递给正确对应的回调。</target>
        </trans-unit>
        <trans-unit id="54f2ff8a238acabb2079588d5c2033656ef069ee" translate="yes" xml:space="preserve">
          <source>Given the following code:</source>
          <target state="translated">鉴于以下代码:</target>
        </trans-unit>
        <trans-unit id="c124c9fdd71373efa4b6882f80c535df13098af6" translate="yes" xml:space="preserve">
          <source>Group objects by id and return as array</source>
          <target state="translated">按id分组并以数组形式返回</target>
        </trans-unit>
        <trans-unit id="dc85de0c8d1aa8d1842c6bc27349fd8488ab304a" translate="yes" xml:space="preserve">
          <source>GroupedObservable</source>
          <target state="translated">GroupedObservable</target>
        </trans-unit>
        <trans-unit id="29da1b8ea5e10bb6cee089501b380d1c22317b19" translate="yes" xml:space="preserve">
          <source>GroupedObservable._subscribe()</source>
          <target state="translated">GroupedObservable._subscribe()</target>
        </trans-unit>
        <trans-unit id="67a5ee349162f7ac679862e2cb19c477ef489ade" translate="yes" xml:space="preserve">
          <source>Groups pairs of consecutive emissions together and emits them as an array of two values.</source>
          <target state="translated">将一对连续的发射组合在一起,并将其作为两个值的数组发射。</target>
        </trans-unit>
        <trans-unit id="20050b3ab03e9f7ad2f940b4b5719c213555e0f0" translate="yes" xml:space="preserve">
          <source>Groups the items emitted by an Observable according to a specified criterion, and emits these grouped items as &lt;code&gt;GroupedObservables&lt;/code&gt;, one &lt;a href=&quot;../index/class/groupedobservable&quot;&gt;&lt;code&gt;GroupedObservable&lt;/code&gt;&lt;/a&gt; per group.</source>
          <target state="translated">根据指定的标准对Observable发出的项目进行分组，并将这些分组的项目作为 &lt;code&gt;GroupedObservables&lt;/code&gt; 发出，每组一个&lt;a href=&quot;../index/class/groupedobservable&quot;&gt; &lt;code&gt;GroupedObservable&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bf073fae640ded81eeb7a4cee70faff4a623c16c" translate="yes" xml:space="preserve">
          <source>Guide</source>
          <target state="translated">Guide</target>
        </trans-unit>
        <trans-unit id="1c928db5e3e6d1f30a2aed1390d012555c85e156" translate="yes" xml:space="preserve">
          <source>Here are different ways you can install RxJs:</source>
          <target state="translated">以下是你安装RxJs的不同方式。</target>
        </trans-unit>
        <trans-unit id="3a5385a2e5e53ebc1302f5ef2e06bfb489acf042" translate="yes" xml:space="preserve">
          <source>Here is an example of a user-defined prototype operator:</source>
          <target state="translated">这里是一个用户定义的原型操作员的例子。</target>
        </trans-unit>
        <trans-unit id="c07d60dcb84ebdbbf843c148434b505c3237d745" translate="yes" xml:space="preserve">
          <source>Here's how you can add the current mouse x position for every click, in plain JavaScript:</source>
          <target state="translated">下面是如何在每次点击时,用纯JavaScript添加当前鼠标x位置。</target>
        </trans-unit>
        <trans-unit id="7e8f1c39f2eee220aa407a7a27af05dd7e03a1ba" translate="yes" xml:space="preserve">
          <source>Higher-order Observables</source>
          <target state="translated">高阶观测数据</target>
        </trans-unit>
        <trans-unit id="03629c9d2b75927156ea1bbd28d4746b87641d9a" translate="yes" xml:space="preserve">
          <source>How many virtual milliseconds one frame represents depends on the value of &lt;code&gt;TestScheduler.frameTimeFactor&lt;/code&gt;. For legacy reasons the value of &lt;code&gt;frameTimeFactor&lt;/code&gt; is 1 &lt;em&gt;only&lt;/em&gt; when your code inside the &lt;code&gt;testScheduler.run(callback)&lt;/code&gt; callback is running. Outside of it, it's set to 10. This will likely change in a future version of RxJS so that it is always 1.</source>
          <target state="translated">一帧表示多少个虚拟毫秒取决于 &lt;code&gt;TestScheduler.frameTimeFactor&lt;/code&gt; 的值。由于遗留原因，&lt;em&gt;仅&lt;/em&gt;当您运行 &lt;code&gt;testScheduler.run(callback)&lt;/code&gt; 回调中的代码时， &lt;code&gt;frameTimeFactor&lt;/code&gt; 的值为1 。外部设置为10。在以后的RxJS版本中可能会更改，因此始终为1。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ac69cb6bdf7453f64d6f79219570637438301804" translate="yes" xml:space="preserve">
          <source>HowTo: Convert deprecated methods</source>
          <target state="translated">HowTo:转换过时的方法</target>
        </trans-unit>
        <trans-unit id="a70b4ef372737a8a66669faafec62818909ed3a7" translate="yes" xml:space="preserve">
          <source>HowTo: Convert to pipe syntax</source>
          <target state="translated">HowTo:转换为管道语法</target>
        </trans-unit>
        <trans-unit id="36e080fecbaabae929b5fc636275d5fc7eb5d6cc" translate="yes" xml:space="preserve">
          <source>HowTo: Result selector migration</source>
          <target state="translated">HowTo:结果选择器迁移</target>
        </trans-unit>
        <trans-unit id="8b929422af26da967f9b75d1aeabb1e1f639d189" translate="yes" xml:space="preserve">
          <source>IMPORTANT: This syntax guide refers to usage of marble diagrams when using the new &lt;code&gt;testScheduler.run(callback)&lt;/code&gt;. The semantics of marble diagrams when using the TestScheduler manually are different, and some features like the new time progression syntax are not supported.</source>
          <target state="translated">重要说明：本语法指南涉及使用新的 &lt;code&gt;testScheduler.run(callback)&lt;/code&gt; 时大理石图的用法。手动使用TestScheduler时，大理石图的语义不同，并且不支持某些功能，例如新的时间进度语法。</target>
        </trans-unit>
        <trans-unit id="40f0b7905e2da41f9e18c82b1b0614b2ffabfa2d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;func&lt;/code&gt; depends on some context (&lt;code&gt;this&lt;/code&gt; property) and is not already bound, the context of &lt;code&gt;func&lt;/code&gt; will be the context that the output function has at call time. In particular, if &lt;code&gt;func&lt;/code&gt; is called as a method of some objec and if &lt;code&gt;func&lt;/code&gt; is not already bound, in order to preserve the context it is recommended that the context of the output function is set to that object as well.</source>
          <target state="translated">如果 &lt;code&gt;func&lt;/code&gt; 依赖于某个上下文（ &lt;code&gt;this&lt;/code&gt; 属性）并且尚未绑定，则 &lt;code&gt;func&lt;/code&gt; 的上下文将是输出函数在调用时具有的上下文。特别是，如果 &lt;code&gt;func&lt;/code&gt; 被作为某些objec的方法调用，并且 &lt;code&gt;func&lt;/code&gt; 尚未绑定，则为了保留上下文，建议将输出函数的上下文也设置为该对象。</target>
        </trans-unit>
        <trans-unit id="07c92379e38482d3edbd155b04331dd9b3b02da3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;onErrorResumeNext&lt;/code&gt; is provided no arguments, or a single, empty array, it will return &lt;a href=&quot;../const/empty&quot;&gt;&lt;code&gt;EMPTY&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果没有提供 &lt;code&gt;onErrorResumeNext&lt;/code&gt; 参数，或者没有提供一个空数组，则它将返回&lt;a href=&quot;../const/empty&quot;&gt; &lt;code&gt;EMPTY&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b1c709af96b5325f3d70325ca645039104585d8e" translate="yes" xml:space="preserve">
          <source>If API you are using allows to unregister event handlers as well, you can pass to &lt;code&gt;fromEventPattern&lt;/code&gt; another function - &lt;code&gt;removeHandler&lt;/code&gt; - as a second parameter. It will be injected with the same handler function as before, which now you can use to unregister it from the API. &lt;code&gt;removeHandler&lt;/code&gt; will be called when consumer of resulting Observable unsubscribes from it.</source>
          <target state="translated">如果您使用的API也允许注销事件处理程序，则可以将另一个函数 &lt;code&gt;removeHandler&lt;/code&gt; 作为第二个参数传递给 &lt;code&gt;fromEventPattern&lt;/code&gt; 。它将注入与以前相同的处理函数，现在您可以使用该函数从API中取消注册。当由此产生的Observable的使用者取消订阅时，将调用 &lt;code&gt;removeHandler&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4af6c10fb1dd2648dc979da484b8a8053c819fb3" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;../index/class/groupedobservable&quot;&gt;&lt;code&gt;GroupedObservable&lt;/code&gt;&lt;/a&gt; for this key exists, this &lt;a href=&quot;../index/class/groupedobservable&quot;&gt;&lt;code&gt;GroupedObservable&lt;/code&gt;&lt;/a&gt; emits. Elsewhere, a new &lt;a href=&quot;../index/class/groupedobservable&quot;&gt;&lt;code&gt;GroupedObservable&lt;/code&gt;&lt;/a&gt; for this key is created and emits.</source>
          <target state="translated">如果&lt;a href=&quot;../index/class/groupedobservable&quot;&gt; &lt;code&gt;GroupedObservable&lt;/code&gt; &lt;/a&gt;此键存在，这&lt;a href=&quot;../index/class/groupedobservable&quot;&gt; &lt;code&gt;GroupedObservable&lt;/code&gt; &lt;/a&gt;发出。在其他地方，为此密钥创建一个新的&lt;a href=&quot;../index/class/groupedobservable&quot;&gt; &lt;code&gt;GroupedObservable&lt;/code&gt; &lt;/a&gt;并将其发出。</target>
        </trans-unit>
        <trans-unit id="df8b94facaadd3672b301652e68967bd50f31e88" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;project&lt;/code&gt; function is provided, it is called with each recent value from each inner Observable in whatever order they arrived, and the result of the &lt;code&gt;project&lt;/code&gt; function is what is emitted by the output Observable.</source>
          <target state="translated">如果提供了 &lt;code&gt;project&lt;/code&gt; 函数，则以每个内部Observable到达它们的顺序调用每个最近的值，并且该 &lt;code&gt;project&lt;/code&gt; 函数的结果就是输出Observable发出的结果。</target>
        </trans-unit>
        <trans-unit id="9a850724cf0766e1952f2eb5588d6e0108fae17b" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;signal&lt;/code&gt; is provided via the &lt;code&gt;init&lt;/code&gt; argument, it will behave like it usually does with &lt;code&gt;fetch&lt;/code&gt;. If the provided &lt;code&gt;signal&lt;/code&gt; aborts, the error that &lt;code&gt;fetch&lt;/code&gt; normally rejects with in that scenario will be emitted as an error from the observable.</source>
          <target state="translated">如果通过 &lt;code&gt;init&lt;/code&gt; 参数提供 &lt;code&gt;signal&lt;/code&gt; ，则其行为将与通常使用 &lt;code&gt;fetch&lt;/code&gt; 一样。如果所提供的 &lt;code&gt;signal&lt;/code&gt; 中止，使得误差 &lt;code&gt;fetch&lt;/code&gt; 与在该情况下通常将废品被发射以从可观察的误差。</target>
        </trans-unit>
        <trans-unit id="028415691a9845121c3a2af04d5b598c1f3893a8" translate="yes" xml:space="preserve">
          <source>If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted. If a comparator function is not provided, an equality check is used by default.</source>
          <target state="translated">如果提供了比较器函数,那么将对每个项目进行调用,以测试该值是否应该被发射。如果没有提供比较器函数,则默认使用平等检查。</target>
        </trans-unit>
        <trans-unit id="4b4b939b7eaab790925369773890c1bf7cf233c9" translate="yes" xml:space="preserve">
          <source>If a keySelector function is provided, then it will project each value from the source observable into a new value that it will check for equality with previously projected values. If a keySelector function is not provided, it will use each value from the source observable directly with an equality check against previous values.</source>
          <target state="translated">如果提供了keySelector函数,那么它将把源观测值中的每个值投射到一个新的值中,它将检查与之前投射的值是否相等。如果没有提供keySelector函数,它将直接使用来自源观测值的每个值,并与之前的值进行平等检查。</target>
        </trans-unit>
        <trans-unit id="f37cc6878132becb067139744ba3d260310d9d74" translate="yes" xml:space="preserve">
          <source>If any Observable in chain errors, instead of passing control to the next Observable, &lt;code&gt;concat&lt;/code&gt; will error immediately as well. Observables that would be subscribed after the one that emitted error, never will.</source>
          <target state="translated">如果链中有任何Observable错误，而不是将控制权传递给下一个Observable，则 &lt;code&gt;concat&lt;/code&gt; 也会立即发生错误。在发出错误的事件之后将被订阅的可观察对象永远不会。</target>
        </trans-unit>
        <trans-unit id="cb0b51e78db6718b4838278fc6306924448093f9" translate="yes" xml:space="preserve">
          <source>If any input observable errors at some point, &lt;code&gt;forkJoin&lt;/code&gt; will error as well and all other observables will be immediately unsubscribed.</source>
          <target state="translated">如果在某个时刻输入的任何可观察的错误， &lt;code&gt;forkJoin&lt;/code&gt; 也会发生错误，所有其他可观察的对象将立即取消订阅。</target>
        </trans-unit>
        <trans-unit id="b185bb62138ba5ed799cdcae2d55f53c229a1bb0" translate="yes" xml:space="preserve">
          <source>If at least one Observable was passed to &lt;code&gt;combineLatest&lt;/code&gt; and all passed Observables emitted something, resulting Observable will complete when all combined streams complete. So even if some Observable completes, result of &lt;code&gt;combineLatest&lt;/code&gt; will still emit values when other Observables do. In case of completed Observable, its value from now on will always be the last emitted value. On the other hand, if any Observable errors, &lt;code&gt;combineLatest&lt;/code&gt; will error immediately as well, and all other Observables will be unsubscribed.</source>
          <target state="translated">如果至少有一个Observable传递给 &lt;code&gt;combineLatest&lt;/code&gt; 并且所有传递的Observable都发出了某种东西，那么当所有组合流完成时，生成的Observable将完成。因此，即使某些Observable完成了，而其他Observable进行 &lt;code&gt;combineLatest&lt;/code&gt; 时，CombineLatest的结果仍将发出值。如果Observable已完成，则从现在开始其值将始终是最后发出的值。另一方面，如果有任何Observable错误， &lt;code&gt;combineLatest&lt;/code&gt; 也将立即错误，所有其他Observable都将被取消订阅。</target>
        </trans-unit>
        <trans-unit id="1e0c62fb072d51f0442df156d8425d45e8d5cf22" translate="yes" xml:space="preserve">
          <source>If called with no arguments, &lt;code&gt;first&lt;/code&gt; emits the first value of the source Observable, then completes. If called with a &lt;code&gt;predicate&lt;/code&gt; function, &lt;code&gt;first&lt;/code&gt; emits the first value of the source that matches the specified condition. It may also take a deprecated &lt;code&gt;resultSelector&lt;/code&gt; function to produce the output value from the input value, and a &lt;code&gt;defaultValue&lt;/code&gt; to emit in case the source completes before it is able to emit a valid value. Throws an error if &lt;code&gt;defaultValue&lt;/code&gt; was not provided and a matching element is not found.</source>
          <target state="translated">如果不带任何参数调用，则 &lt;code&gt;first&lt;/code&gt; 发出源Observable的第一个值，然后完成。如果使用 &lt;code&gt;predicate&lt;/code&gt; 函数调用，则 &lt;code&gt;first&lt;/code&gt; 发出与指定条件匹配的源的第一个值。还可能需要不赞成使用的 &lt;code&gt;resultSelector&lt;/code&gt; 函数从输入值生成输出值，并使用 &lt;code&gt;defaultValue&lt;/code&gt; 在源能够发出有效值之前完成的情况下发出。如果未提供 &lt;code&gt;defaultValue&lt;/code&gt; 且未找到匹配的元素，则会引发错误。</target>
        </trans-unit>
        <trans-unit id="3bcd9d37561bf68f49980616d1911338e805195a" translate="yes" xml:space="preserve">
          <source>If no clicks happen in 5 seconds, then emit &quot;no clicks&quot;</source>
          <target state="translated">如果5秒内没有点击,则发出 &quot;无点击&quot;。</target>
        </trans-unit>
        <trans-unit id="fe2f6c30c49a1d0418d15b8fce2ca69c14e338fe" translate="yes" xml:space="preserve">
          <source>If number was provided, it returns an Observable that behaves like a source Observable, unless there is a period of time where there is no value emitted. So if you provide &lt;code&gt;100&lt;/code&gt; as argument and first value comes after 50ms from the moment of subscription, this value will be simply re-emitted by the resulting Observable. If however after that 100ms passes without a second value being emitted, stream will end with an error and source Observable will be unsubscribed. These checks are performed throughout whole lifecycle of Observable - from the moment it was subscribed to, until it completes or errors itself. Thus every value must be emitted within specified period since previous value.</source>
          <target state="translated">如果提供了number，则它将返回行为类似于源Observable的Observable，除非在一段时间内没有发出任何值。因此，如果您提供 &lt;code&gt;100&lt;/code&gt; 作为自变量，并且第一个值在订阅后的50ms后出现，则此值将由结果Observable简单地重新发射。但是，如果经过100毫秒而没有发出第二个值，则流将以错误结束，并且源Observable将被取消订阅。这些检查在Observable的整个生命周期中执行-从订阅开始到完成或出错为止。因此，每个值必须在自上一个值以来的指定时间段内发出。</target>
        </trans-unit>
        <trans-unit id="9927bd26769cb903fed62e7a678f564c56dffc51" translate="yes" xml:space="preserve">
          <source>If provided argument was Date, returned Observable behaves differently. It throws if Observable did not complete before provided Date. This means that periods between emission of particular values do not matter in this case. If Observable did not complete before provided Date, source Observable will be unsubscribed. Other than that, resulting stream behaves just as source Observable.</source>
          <target state="translated">如果提供的参数是Date,那么返回的Observable会有不同的表现。如果Observable在所提供的Date之前没有完成,则会抛出。这意味着,在这种情况下,特定值之间的时间间隔并不重要。如果Observable在提供的Date之前没有完成,源Observable将被取消订阅。除此之外,产生的流和源Observable一样。</target>
        </trans-unit>
        <trans-unit id="f38eff0754b3ee76a87f735922543165f876702b" translate="yes" xml:space="preserve">
          <source>If the API you use is more callback then event handler oriented (subscribed callback function fires only once and thus there is no need to manually unregister it), you should use &lt;a href=&quot;bindcallback&quot;&gt;&lt;code&gt;bindCallback&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;bindnodecallback&quot;&gt;&lt;code&gt;bindNodeCallback&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">如果您使用的API更具回调性，则面向事件处理程序（预订的回调函数仅触发一次，因此无需手动注销它），应改用&lt;a href=&quot;bindcallback&quot;&gt; &lt;code&gt;bindCallback&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;bindnodecallback&quot;&gt; &lt;code&gt;bindNodeCallback&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d701a75284d0a6eaaaeb95b5a8f86ab1226adb0a" translate="yes" xml:space="preserve">
          <source>If the delay argument is a Date, this operator time shifts the start of the Observable execution until the given date occurs.</source>
          <target state="translated">如果延迟参数是Date,那么这个操作者会将Observable的执行开始时间移动到给定的日期。</target>
        </trans-unit>
        <trans-unit id="a35fe97591e295a1ffadb54ac04ce29d0914a39f" translate="yes" xml:space="preserve">
          <source>If the delay argument is a Number, this operator time shifts the source Observable by that amount of time expressed in milliseconds. The relative time intervals between the values are preserved.</source>
          <target state="translated">如果延迟参数是Number,则该运算符将源观测值的时间移动了以毫秒为单位的时间量。值之间的相对时间间隔被保留下来。</target>
        </trans-unit>
        <trans-unit id="1d0edea354d308cd425e5a8ad0f533ee55c07ab3" translate="yes" xml:space="preserve">
          <source>If the input function calls its callback in the &quot;node style&quot; (i.e. first argument to callback is optional error parameter signaling whether the call failed or not), &lt;a href=&quot;bindnodecallback&quot;&gt;&lt;code&gt;bindNodeCallback&lt;/code&gt;&lt;/a&gt; provides convenient error handling and probably is a better choice. &lt;code&gt;bindCallback&lt;/code&gt; will treat such functions the same as any other and error parameters (whether passed or not) will always be interpreted as regular callback argument.</source>
          <target state="translated">如果输入函数以&amp;ldquo;节点样式&amp;rdquo;调用其回调（即，回调的第一个参数是表示调用是否失败的可选错误参数），则&lt;a href=&quot;bindnodecallback&quot;&gt; &lt;code&gt;bindNodeCallback&lt;/code&gt; &lt;/a&gt;提供便利的错误处理，可能是更好的选择。 &lt;code&gt;bindCallback&lt;/code&gt; 会将此类函数与其他函数一样对待，并且错误参数（无论是否传递）将始终被解释为常规回调参数。</target>
        </trans-unit>
        <trans-unit id="0b21237624e24ba4cc805cfeee666fd31c53c5b0" translate="yes" xml:space="preserve">
          <source>If the last parameter is a function, this function is used to compute the created value from the input values. Otherwise, an array of the input values is returned.</source>
          <target state="translated">如果最后一个参数是一个函数,则该函数用于计算输入值的创建值。否则,将返回一个输入值的数组。</target>
        </trans-unit>
        <trans-unit id="704afffd75894b6709cab10f66bc542fc722f744" translate="yes" xml:space="preserve">
          <source>If the source Observable turns out to be empty, then this operator will emit a default value.</source>
          <target state="translated">如果源Observable是空的,那么这个操作符将发出一个默认值。</target>
        </trans-unit>
        <trans-unit id="65c66c04bc0bef2071226e606af604f4bb46432a" translate="yes" xml:space="preserve">
          <source>If the source observable completes without emitting a value, it will emit an error. The error will be created at that time by the optional &lt;code&gt;errorFactory&lt;/code&gt; argument, otherwise, the error will be &lt;a href=&quot;../index/interface/emptyerror&quot;&gt;&lt;code&gt;EmptyError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果源可观察者完成但没有发出值，则将发出错误。该错误将在那时由可选的 &lt;code&gt;errorFactory&lt;/code&gt; 参数创建，否则，该错误将为&lt;a href=&quot;../index/interface/emptyerror&quot;&gt; &lt;code&gt;EmptyError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b81b74a71c6eeb0509a7903617c743cf2e95798b" translate="yes" xml:space="preserve">
          <source>If the tear down being added is a subscription that is already unsubscribed, is the same reference &lt;code&gt;add&lt;/code&gt; is being called on, or is &lt;code&gt;Subscription.EMPTY&lt;/code&gt;, it will not be added.</source>
          <target state="translated">如果要添加的拆解是已经取消订阅的订阅，是正在调用相同的引用 &lt;code&gt;add&lt;/code&gt; 还是 &lt;code&gt;Subscription.EMPTY&lt;/code&gt; ，则不会添加。</target>
        </trans-unit>
        <trans-unit id="9540c042022e13c3a09c2d5bc7fab29748e20f12" translate="yes" xml:space="preserve">
          <source>If there is a commonly used sequence of operators in your code, use the &lt;code&gt;pipe()&lt;/code&gt; function to extract the sequence into a new operator. Even if a sequence is not that common, breaking it out into a single operator can improve readability.</source>
          <target state="translated">如果您的代码中有一个常用的运算符序列，请使用 &lt;code&gt;pipe()&lt;/code&gt; 函数将该序列提取到新的运算符中。即使序列不是那么常见，将其分解为单个运算符也可以提高可读性。</target>
        </trans-unit>
        <trans-unit id="120e2aa081d0d7d86f0ec952fbf8c0c6ba52c280" translate="yes" xml:space="preserve">
          <source>If there is no &lt;code&gt;project&lt;/code&gt; function, an array of all the most recent values is emitted by the output Observable.</source>
          <target state="translated">如果没有 &lt;code&gt;project&lt;/code&gt; 函数，则输出Observable会输出所有最新值的数组。</target>
        </trans-unit>
        <trans-unit id="2042c5f5108b1085d8f0cd4827f1b1647e843180" translate="yes" xml:space="preserve">
          <source>If this subscription is already in an &lt;code&gt;closed&lt;/code&gt; state, the passed tear down logic will be executed immediately.</source>
          <target state="translated">如果此订阅已处于 &lt;code&gt;closed&lt;/code&gt; 状态，则传递的拆卸逻辑将立即执行。</target>
        </trans-unit>
        <trans-unit id="617020e61af12a357bc2772c78eadc0453defeed" translate="yes" xml:space="preserve">
          <source>If we wish to avoid explicit calls to &lt;code&gt;connect()&lt;/code&gt;, we can use ConnectableObservable's &lt;code&gt;refCount()&lt;/code&gt; method (reference counting), which returns an Observable that keeps track of how many subscribers it has. When the number of subscribers increases from &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;1&lt;/code&gt;, it will call &lt;code&gt;connect()&lt;/code&gt; for us, which starts the shared execution. Only when the number of subscribers decreases from &lt;code&gt;1&lt;/code&gt; to &lt;code&gt;0&lt;/code&gt; will it be fully unsubscribed, stopping further execution.</source>
          <target state="translated">如果我们希望避免显式调用 &lt;code&gt;connect()&lt;/code&gt; ，则可以使用ConnectableObservable的 &lt;code&gt;refCount()&lt;/code&gt; 方法（引用计数），该方法返回一个Observable，以跟踪其拥有的订户数量。当订户数量从 &lt;code&gt;0&lt;/code&gt; 增加到 &lt;code&gt;1&lt;/code&gt; 时，它将为我们调用 &lt;code&gt;connect()&lt;/code&gt; ，这将启动共享执行。只有当订户数量从 &lt;code&gt;1&lt;/code&gt; 减少到 &lt;code&gt;0&lt;/code&gt; 时，它才会完全取消订阅，从而停止进一步执行。</target>
        </trans-unit>
        <trans-unit id="5439a31ba2d71bf365539528323ff6c90d45a470" translate="yes" xml:space="preserve">
          <source>If you &lt;code&gt;require('rxjs/_esm5/path-mapping')&lt;/code&gt;, you will receive a function that returns an object of key-value pairs mapping each input to it's file location on disk. Utilize this mapping as follows:</source>
          <target state="translated">如果 &lt;code&gt;require('rxjs/_esm5/path-mapping')&lt;/code&gt; ，您将收到一个函数，该函数返回一个键-值对对象，将每个输入映射到其在磁盘上的文件位置。如下使用此映射：</target>
        </trans-unit>
        <trans-unit id="38877b71d192590feabd1b186895b050de142d89" translate="yes" xml:space="preserve">
          <source>If you are defining your own prototype operators in TypeScript and modifying the &lt;code&gt;Observable&lt;/code&gt; namespace, you will need to change your operator code in order to get TypeScript to compile. See &lt;a href=&quot;migration#ex-2&quot;&gt;examples&lt;/a&gt;. This is a relatively rare case, likely to affect only advanced TypeScript developers.</source>
          <target state="translated">如果要在TypeScript中定义自己的原型运算符并修改 &lt;code&gt;Observable&lt;/code&gt; 命名空间，则需要更改运算符代码才能编译TypeScript。参见&lt;a href=&quot;migration#ex-2&quot;&gt;示例&lt;/a&gt;。这是一种相对罕见的情况，可能只影响高级TypeScript开发人员。</target>
        </trans-unit>
        <trans-unit id="77ad98badca810f45da78ca2f70f7bab1d886cbb" translate="yes" xml:space="preserve">
          <source>If you are using npm version 2 before this library has achieved a stable version, you need to specify the library version explicitly:</source>
          <target state="translated">如果你在使用npm版本2之前,这个库还没有达到稳定版本,你需要明确指定库的版本。</target>
        </trans-unit>
        <trans-unit id="844ad591748c8aca77e4dcdccf63c8692cdaaa4b" translate="yes" xml:space="preserve">
          <source>If you are using the parameter, you must update your code by moving your result-selection function out of the original operator call, and applying it to the results of the call.</source>
          <target state="translated">如果你使用的是参数,你必须更新你的代码,将你的结果选择函数从原来的运算符调用中移出,并应用于调用的结果。</target>
        </trans-unit>
        <trans-unit id="3978310b1cc85c905bb0eeaf6cf95815f8dd8096" translate="yes" xml:space="preserve">
          <source>If you enable the &lt;code&gt;leading&lt;/code&gt; parameter in this example, the output would be the primary click and the double click, but restricts additional clicks within 400ms.</source>
          <target state="translated">如果在此示例中启用 &lt;code&gt;leading&lt;/code&gt; 参数，则输出将是一次点击和两次点击，但会将额外的点击限制在400ms之内。</target>
        </trans-unit>
        <trans-unit id="8924e6022acb95d4b22dad3bc88d202b7faa16fd" translate="yes" xml:space="preserve">
          <source>If you find three anonymous functions in &lt;code&gt;generate&lt;/code&gt; call hard to read, you can provide single object to the operator instead. That object has properties: &lt;code&gt;initialState&lt;/code&gt;, &lt;code&gt;condition&lt;/code&gt;, &lt;code&gt;iterate&lt;/code&gt; and &lt;code&gt;resultSelector&lt;/code&gt;, which should have respective values that you would normally pass to &lt;code&gt;generate&lt;/code&gt;. &lt;code&gt;resultSelector&lt;/code&gt; is still optional, but that form of calling &lt;code&gt;generate&lt;/code&gt; allows you to omit &lt;code&gt;condition&lt;/code&gt; as well. If you omit it, that means condition always holds, so output Observable will never complete.</source>
          <target state="translated">如果在 &lt;code&gt;generate&lt;/code&gt; call中发现三个匿名函数难以理解，则可以向操作员提供单个对象。该对象具有以下属性： &lt;code&gt;initialState&lt;/code&gt; ， &lt;code&gt;condition&lt;/code&gt; ， &lt;code&gt;iterate&lt;/code&gt; 和 &lt;code&gt;resultSelector&lt;/code&gt; ，这些属性应具有通常传递给 &lt;code&gt;generate&lt;/code&gt; 的相应值。 &lt;code&gt;resultSelector&lt;/code&gt; 仍然是可选的，但是通过调用 &lt;code&gt;generate&lt;/code&gt; 的形式，您也可以省略 &lt;code&gt;condition&lt;/code&gt; 。如果省略它，则意味着条件始终成立，因此Observable输出将永远不会完成。</target>
        </trans-unit>
        <trans-unit id="6622080ade80659a6c5d1d8c040185d09d9ce150" translate="yes" xml:space="preserve">
          <source>If you have RxJS code that uses any other form of async scheduling other than AsyncScheduler, e.g. Promises, AsapScheduler, etc. you can't reliably use marble diagrams &lt;em&gt;for that particular code&lt;/em&gt;. This is because those other scheduling methods won't be virtualized or known to TestScheduler.</source>
          <target state="translated">如果您有RxJS代码使用AsyncScheduler以外的其他任何形式的异步调度，例如Promises，AsapScheduler等，则无法可靠地将大理石图&lt;em&gt;用于该特定代码&lt;/em&gt;。这是因为那些其他的调度方法不会被虚拟化或TestScheduler知道。</target>
        </trans-unit>
        <trans-unit id="e8f64885951634f31a84994c2ad579ee912cd26e" translate="yes" xml:space="preserve">
          <source>If you have installed &lt;code&gt;rxjs-compat&lt;/code&gt;, there are only two breaking changes that you might need to address immediately.</source>
          <target state="translated">如果已安装 &lt;code&gt;rxjs-compat&lt;/code&gt; ，则可能只需要立即解决两个重大更改。</target>
        </trans-unit>
        <trans-unit id="9392292c8ce329d2c59bb25843c4bd27a5cd47c1" translate="yes" xml:space="preserve">
          <source>If you have more complex logic that requires decision between more than two Observables, &lt;a href=&quot;defer&quot;&gt;&lt;code&gt;defer&lt;/code&gt;&lt;/a&gt; will probably be a better choice. Actually &lt;code&gt;iif&lt;/code&gt; can be easily implemented with &lt;a href=&quot;defer&quot;&gt;&lt;code&gt;defer&lt;/code&gt;&lt;/a&gt; and exists only for convenience and readability reasons.</source>
          <target state="translated">如果您有更复杂的逻辑，需要在两个以上的Observable之间进行决策，那么&lt;a href=&quot;defer&quot;&gt; &lt;code&gt;defer&lt;/code&gt; &lt;/a&gt;可能是一个更好的选择。实际上， &lt;code&gt;iif&lt;/code&gt; 可以通过&lt;a href=&quot;defer&quot;&gt; &lt;code&gt;defer&lt;/code&gt; &lt;/a&gt;轻松实现，并且仅出于方便和易读性的原因而存在。</target>
        </trans-unit>
        <trans-unit id="e5dd67de623021f1d498a36750dcf6c79d4e0143" translate="yes" xml:space="preserve">
          <source>If you just want to &quot;defer&quot; task, that is to perform it right after currently executing synchronous code ends (commonly achieved by &lt;code&gt;setTimeout(deferredTask, 0)&lt;/code&gt;), better choice will be the &lt;a href=&quot;asapscheduler&quot;&gt;&lt;code&gt;asap&lt;/code&gt;&lt;/a&gt; scheduler.</source>
          <target state="translated">如果您只想&amp;ldquo;推迟&amp;rdquo;任务，即在当前执行的同步代码结束后立即执行（通常由 &lt;code&gt;setTimeout(deferredTask, 0)&lt;/code&gt; ），那么更好的选择将是&lt;a href=&quot;asapscheduler&quot;&gt; &lt;code&gt;asap&lt;/code&gt; &lt;/a&gt;调度程序。</target>
        </trans-unit>
        <trans-unit id="5a9a1fa1312c35ddac86b41c30d41c3f5e594c2e" translate="yes" xml:space="preserve">
          <source>If you need access to all event handler parameters (not only the first one), or you need to transform them in any way, you can call &lt;code&gt;fromEventPattern&lt;/code&gt; with optional third parameter - project function which will accept all arguments passed to event handler when it is called. Whatever is returned from project function will appear on resulting stream instead of usual event handlers first argument. This means that default project can be thought of as function that takes its first parameter and ignores the rest.</source>
          <target state="translated">如果您需要访问所有事件处理程序参数（不仅是第一个），或者需要以任何方式对其进行转换，则可以使用可选的第三个参数 &lt;code&gt;fromEventPattern&lt;/code&gt; 函数调用fromEventPattern，该函数将接受事件处理程序传递给事件处理程序的所有参数。叫。从项目函数返回的所有内容都将出现在结果流上，而不是通常的事件处理程序的第一个参数。这意味着可以将默认项目视为具有第一个参数而忽略其余参数的函数。</target>
        </trans-unit>
        <trans-unit id="1bdbac235dd8a8f9129b495ef4e47c6d79c2d5d4" translate="yes" xml:space="preserve">
          <source>If you pass a dictionary of observables to the operator, resulting objects will have the same keys as the dictionary passed, with their last values they've emitted located at the corresponding key.</source>
          <target state="translated">如果你向操作者传递一个观测值的字典,产生的对象将具有与传递的字典相同的键,它们发出的最后一个值位于相应的键处。</target>
        </trans-unit>
        <trans-unit id="7d837f1f500cd898bebd92644c0fcb4ec5f7fcb7" translate="yes" xml:space="preserve">
          <source>If you pass an array of &lt;code&gt;n&lt;/code&gt; observables to the operator, resulting array will have &lt;code&gt;n&lt;/code&gt; values, where first value is the last thing emitted by the first observable, second value is the last thing emitted by the second observable and so on.</source>
          <target state="translated">如果将 &lt;code&gt;n&lt;/code&gt; 个可观察变量的数组传递给运算符，则结果数组将具有 &lt;code&gt;n&lt;/code&gt; 个值，其中第一个值是第一个可观察变量发出的最后一个值，第二个值是第二个可观察变量发出的最后一个值，依此类推。</target>
        </trans-unit>
        <trans-unit id="ee570c9f654defeedccb901085f0bb73f4226f34" translate="yes" xml:space="preserve">
          <source>If you pass to &lt;code&gt;concat&lt;/code&gt; the same Observable many times, its stream of values will be &quot;replayed&quot; on every subscription, which means you can repeat given Observable as many times as you like. If passing the same Observable to &lt;code&gt;concat&lt;/code&gt; 1000 times becomes tedious, you can always use &lt;a href=&quot;../../operators/repeat&quot;&gt;&lt;code&gt;repeat&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果您传递给 &lt;code&gt;concat&lt;/code&gt; 相同可观测多次，它的价值将是流&amp;ldquo;重播&amp;rdquo;在每一个订阅，这意味着你可以重复给定的观察为多次，你喜欢。如果将相同的Observable传递给 &lt;code&gt;concat&lt;/code&gt; 1000次变得乏味，则可以始终使用&lt;a href=&quot;../../operators/repeat&quot;&gt; &lt;code&gt;repeat&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d4a842ea19f74aaea650d3b005c684fa452f2f03" translate="yes" xml:space="preserve">
          <source>If you receive an error like error TS2304: Cannot find name 'Promise' or error TS2304: Cannot find name 'Iterable' when using RxJS you may need to install a supplemental set of typings.</source>
          <target state="translated">如果您在使用RxJS时收到类似错误TS2304:Cannot find name 'Promise'或错误TS2304:Cannot find name 'Iterable'的错误,您可能需要安装一套补充的输入法。</target>
        </trans-unit>
        <trans-unit id="bc2f69f01e85bf5d619a756550c3023d53f1eb41" translate="yes" xml:space="preserve">
          <source>If you use functionality that is removed from v6, but supported by the &lt;code&gt;rxjs-compat&lt;/code&gt; package, you must refactor or rewrite code to complete the update to v6. The following areas of functionality depend on the compatibility layer:</source>
          <target state="translated">如果使用从v6中删除但 &lt;code&gt;rxjs-compat&lt;/code&gt; 软件包支持的功能，则必须重构或重写代码以完成对v6的更新。以下功能区域取决于兼容性层：</target>
        </trans-unit>
        <trans-unit id="8115cc9902d10e9cbc721cbe7139de103776ba25" translate="yes" xml:space="preserve">
          <source>If you're a TypeScript developer, it's recommended that you use &lt;code&gt;rxjs-tslint&lt;/code&gt; to refactor your import paths.</source>
          <target state="translated">如果您是TypeScript开发人员，建议您使用 &lt;code&gt;rxjs-tslint&lt;/code&gt; 重构导入路径。</target>
        </trans-unit>
        <trans-unit id="6013f20fa65ee7b571375547cde18c11a11195b9" translate="yes" xml:space="preserve">
          <source>If you're not using typings the interfaces can be copied from /es6-shim/es6-shim.d.ts.</source>
          <target state="translated">如果你不使用typings,可以从/es6-shim/es6-shim.d.ts中复制接口。</target>
        </trans-unit>
        <trans-unit id="e55924f1e55081fa0d810b45171dfff9935a10b9" translate="yes" xml:space="preserve">
          <source>If your app is affected by the few &lt;a href=&quot;migration#breaking-changes&quot;&gt;breaking changes&lt;/a&gt; not covered by &lt;code&gt;rxjs-compat&lt;/code&gt;, update the affected code according to the instructions provided below.</source>
          <target state="translated">如果您的应用受到 &lt;code&gt;rxjs-compat&lt;/code&gt; 未涵盖的一些&lt;a href=&quot;migration#breaking-changes&quot;&gt;重大更改&lt;/a&gt;的影响，请根据以下提供的说明更新受影响的代码。</target>
        </trans-unit>
        <trans-unit id="a25eefd9034a0248cd7ddd31d1d8d721666b3a11" translate="yes" xml:space="preserve">
          <source>IfObservable</source>
          <target state="translated">IfObservable</target>
        </trans-unit>
        <trans-unit id="a71757c57da2855a990877a7134d7fa854f423d4" translate="yes" xml:space="preserve">
          <source>Ignore every 3rd click event, starting from the first one</source>
          <target state="translated">忽略第3次点击事件,从第1次开始。</target>
        </trans-unit>
        <trans-unit id="fa4d2cc45a3baa30509775b1cb451f0bae0f04ac" translate="yes" xml:space="preserve">
          <source>Ignore every 3rd click event, starting from the third one</source>
          <target state="translated">忽略第3次点击事件,从第3次开始。</target>
        </trans-unit>
        <trans-unit id="c30072d05b38673f5eb2d636804574de2101d7e1" translate="yes" xml:space="preserve">
          <source>Ignores all items emitted by the source Observable and only passes calls of &lt;code&gt;complete&lt;/code&gt; or &lt;code&gt;error&lt;/code&gt;.</source>
          <target state="translated">忽略源Observable发出的所有项目，仅传递 &lt;code&gt;complete&lt;/code&gt; 或 &lt;code&gt;error&lt;/code&gt; 调用。</target>
        </trans-unit>
        <trans-unit id="40e5987468ce7f856e1a72614ed4dc8bef08b57f" translate="yes" xml:space="preserve">
          <source>Ignores emitted values, reacts to observable's completion.</source>
          <target state="translated">忽略发射值,对观测值的完成作出反应。</target>
        </trans-unit>
        <trans-unit id="70355e794eb2aafb77d98edb0d89a6e944d813ad" translate="yes" xml:space="preserve">
          <source>Ignores source values for &lt;code&gt;duration&lt;/code&gt; milliseconds, then emits the most recent value from the source Observable, then repeats this process.</source>
          <target state="translated">忽略 &lt;code&gt;duration&lt;/code&gt; 源值毫秒的，然后从源Observable发出最新值，然后重复此过程。</target>
        </trans-unit>
        <trans-unit id="529d2ea415ea19d29423e03ad35a1b7fa6aec7f7" translate="yes" xml:space="preserve">
          <source>Ignores source values for a duration determined by another Observable, then emits the most recent value from the source Observable, then repeats this process.</source>
          <target state="translated">在另一个Observable确定的持续时间内忽略源值,然后从源Observable发出最新的值,然后重复这个过程。</target>
        </trans-unit>
        <trans-unit id="a40044f6794fce3bb8fd5737e1d66787d43844de" translate="yes" xml:space="preserve">
          <source>Implements the &lt;a href=&quot;../interface/observer&quot;&gt;&lt;code&gt;Observer&lt;/code&gt;&lt;/a&gt; interface and extends the &lt;a href=&quot;subscription&quot;&gt;&lt;code&gt;Subscription&lt;/code&gt;&lt;/a&gt; class. While the &lt;a href=&quot;../interface/observer&quot;&gt;&lt;code&gt;Observer&lt;/code&gt;&lt;/a&gt; is the public API for consuming the values of an &lt;a href=&quot;observable&quot;&gt;&lt;code&gt;Observable&lt;/code&gt;&lt;/a&gt;, all Observers get converted to a Subscriber, in order to provide Subscription-like capabilities such as &lt;code&gt;unsubscribe&lt;/code&gt;. Subscriber is a common type in RxJS, and crucial for implementing operators, but it is rarely used as a public API.</source>
          <target state="translated">实现&lt;a href=&quot;../interface/observer&quot;&gt; &lt;code&gt;Observer&lt;/code&gt; &lt;/a&gt;接口并扩展&lt;a href=&quot;subscription&quot;&gt; &lt;code&gt;Subscription&lt;/code&gt; &lt;/a&gt;类。虽然&lt;a href=&quot;../interface/observer&quot;&gt; &lt;code&gt;Observer&lt;/code&gt; &lt;/a&gt;是用于使用&lt;a href=&quot;observable&quot;&gt; &lt;code&gt;Observable&lt;/code&gt; &lt;/a&gt;值的公共API ，但所有Observer都会转换为Subscriber，以提供类似于Subscription的功能，例如 &lt;code&gt;unsubscribe&lt;/code&gt; 。订阅服务器是RxJS中的一种常见类型，对于实现操作符至关重要，但很少用作公共API。</target>
        </trans-unit>
        <trans-unit id="22a882e9f78320d3f6a26b70debc5504cfb608e8" translate="yes" xml:space="preserve">
          <source>Import paths</source>
          <target state="translated">导入路径</target>
        </trans-unit>
        <trans-unit id="d78821ba5d868d9a31095edd36e64f53ec95ec9b" translate="yes" xml:space="preserve">
          <source>Import paths have changed.</source>
          <target state="translated">进口路径已经改变。</target>
        </trans-unit>
        <trans-unit id="604c5adf7e512895ef3206a2a38925fde75adbf4" translate="yes" xml:space="preserve">
          <source>In JavaScript runtimes that support &lt;code&gt;Set&lt;/code&gt;, this operator will use a &lt;code&gt;Set&lt;/code&gt; to improve performance of the distinct value checking.</source>
          <target state="translated">在支持 &lt;code&gt;Set&lt;/code&gt; 的 JavaScript运行时中，此运算符将使用 &lt;code&gt;Set&lt;/code&gt; 来提高非重复值检查的性能。</target>
        </trans-unit>
        <trans-unit id="e5195133f63632cc13452c63ce186838089e5949" translate="yes" xml:space="preserve">
          <source>In RxJS v5.x, a number of operators have an optional resultSelector argument, in which you can pass a function for handling the result of the operations.</source>
          <target state="translated">在RxJS v5.x中,一些操作符有一个可选的resultSelector参数,在这个参数中,你可以传递一个处理操作结果的函数。</target>
        </trans-unit>
        <trans-unit id="9ed98d14e00fa6f78e3945d35bbdbe8132e2ecd9" translate="yes" xml:space="preserve">
          <source>In RxJS v6.x, UMD module name has been changed from Rx to rxjs so that it's align with other imports module name.</source>
          <target state="translated">在RxJS v6.x中,UMD模块的名称从Rx改为rxjs,以便与其他导入模块的名称一致。</target>
        </trans-unit>
        <trans-unit id="9f5e3817dd59d2b07ee7cbf50ed5e3af33894a40" translate="yes" xml:space="preserve">
          <source>In TypeScript 2.3 and lower, typings will need to be added to functions passed to operators, as types cannot be inferred prior to TypeScript 2.4. In TypeScript 2.4, types will infer via composition properly.</source>
          <target state="translated">在TypeScript 2.3和更低版本中,类型将需要被添加到传递给运算符的函数中,因为在TypeScript 2.4之前,类型不能被推断。在TypeScript 2.4中,类型将通过组成正确推断。</target>
        </trans-unit>
        <trans-unit id="09c23a7addb52527b7cdfb469f68066abf364c42" translate="yes" xml:space="preserve">
          <source>In a marble diagram, time flows to the right, and the diagram describes how values (&quot;marbles&quot;) are emitted on the Observable execution.</source>
          <target state="translated">在弹珠图中,时间流向右边,图中描述了值(&quot;弹珠&quot;)是如何在Observable执行时发出的。</target>
        </trans-unit>
        <trans-unit id="fb16cf9ddcefacd27292666512786e6449d62f05" translate="yes" xml:space="preserve">
          <source>In an Observable Execution, zero to infinite Next notifications may be delivered. If either an Error or Complete notification is delivered, then nothing else can be delivered afterwards.</source>
          <target state="translated">在一个可观察的执行中,可以传递零到无限个 &quot;下一步 &quot;通知。如果一个错误或完整的通知被发送,那么之后就不能再发送其他通知。</target>
        </trans-unit>
        <trans-unit id="6c035b77c3b045a395fde85eddc3bc476a772acf" translate="yes" xml:space="preserve">
          <source>In both &lt;code&gt;hot&lt;/code&gt; and &lt;code&gt;cold&lt;/code&gt; methods, value characters specified in marble diagrams are emitted as strings unless a &lt;code&gt;values&lt;/code&gt; argument is passed to the method. Therefor:</source>
          <target state="translated">在这两个 &lt;code&gt;hot&lt;/code&gt; 和 &lt;code&gt;cold&lt;/code&gt; 方法中，大理石图指定值的字符被发射作为字符串除非一个 &lt;code&gt;values&lt;/code&gt; 参数传递给该方法。为此：</target>
        </trans-unit>
        <trans-unit id="295e5d256d6bbe1d0869e05b595f7b24f349478f" translate="yes" xml:space="preserve">
          <source>In every window of 1 second each, emit at most 2 click events</source>
          <target state="translated">在每1秒的窗口中,最多发出2次点击事件。</target>
        </trans-unit>
        <trans-unit id="c49794905cd1728d46b3103a435edb3badc67155" translate="yes" xml:space="preserve">
          <source>In functions that have the resultSelector parameter, the parameters have been deprecated in most cases, and removed for two functions. The ones that have been removed must be updated before you can remove the compatibility layer.</source>
          <target state="translated">在有resultSelector参数的函数中,大多数情况下这些参数已经被废弃,有两个函数的参数已经被删除。被删除的必须更新后才能删除兼容层。</target>
        </trans-unit>
        <trans-unit id="e1fd85e3cd2bf300851eee6724b69f0c2ea88b01" translate="yes" xml:space="preserve">
          <source>In most tests it will be unnecessary to test subscription and unsubscription points, being either obvious or implied from the &lt;code&gt;expected&lt;/code&gt; diagram. In those cases do not write subscription assertions. In test cases that have inner subscriptions or cold observables with multiple subscribers, these subscription assertions can be useful.</source>
          <target state="translated">在大多数测试中，无需测试订阅点和取消订阅点，无论是 &lt;code&gt;expected&lt;/code&gt; 图中的明显还是暗含的。在那些情况下，请勿编写订阅声明。在具有内部订阅或具有多个订阅者的冷可观察性的测试用例中，这些订阅断言可能很有用。</target>
        </trans-unit>
        <trans-unit id="aec95503709d60cd6d6b2ee3ce1d30d30b825fd7" translate="yes" xml:space="preserve">
          <source>In order for resulting array to have the same length as the number of input observables, whenever any of that observables completes without emitting any value, &lt;code&gt;forkJoin&lt;/code&gt; will complete at that moment as well and it will not emit anything either, even if it already has some last values from other observables. Conversely, if there is an observable that never completes, &lt;code&gt;forkJoin&lt;/code&gt; will never complete as well, unless at any point some other observable completes without emitting value, which brings us back to the previous case. Overall, in order for &lt;code&gt;forkJoin&lt;/code&gt; to emit a value, all observables passed as arguments have to emit something at least once and complete.</source>
          <target state="translated">为了使结果数组的长度与输入可观察值的长度相同，每当任何一个可观察值完成而没有发出任何值时， &lt;code&gt;forkJoin&lt;/code&gt; 也会在那一刻完成，并且即使它已经有一些，也不会发出任何东西其他可观察值的最后一个值。相反，如果存在一个永远不会完成的可观察对象， &lt;code&gt;forkJoin&lt;/code&gt; 也将永远不会完成，除非在任何时候任何其他可观察的对象都完成而不释放价值，这使我们回到了前面的情况。总体而言，为了使 &lt;code&gt;forkJoin&lt;/code&gt; 发出值，作为参数传递的所有可观察对象必须至少发出一次并完成。</target>
        </trans-unit>
        <trans-unit id="a45eba608694af1c74ee2e9386099587189e2989" translate="yes" xml:space="preserve">
          <source>In order to minimize the impact of the upgrade, RxJS v6 releases with a sibling package, &lt;code&gt;rxjs-compat&lt;/code&gt;, which provides a compatibility layer between the v6 and v5 APIs. Most developers with existing applications should upgrade by installing both &lt;code&gt;rxjs&lt;/code&gt; and &lt;code&gt;rxjs-compat&lt;/code&gt; at ^6.0.0:</source>
          <target state="translated">为了最大程度地减少升级的影响，RxJS v6发行了一个同级软件包 &lt;code&gt;rxjs-compat&lt;/code&gt; ，该软件包提供了v6和v5 API之间的兼容性层。大多数具有现有应用程序的开发人员都应通过在^ 6.0.0处安装 &lt;code&gt;rxjs&lt;/code&gt; 和 &lt;code&gt;rxjs-compat&lt;/code&gt; 进行升级：</target>
        </trans-unit>
        <trans-unit id="fe403bd5e814fd0d03b717695065a0f083c8e78f" translate="yes" xml:space="preserve">
          <source>In order to use the new pipeable operators and not gain bundle size, you will need to change your Webpack configuration. This will only work with Webpack 3+ as it relies on the new &lt;code&gt;ModuleConcatenationPlugin&lt;/code&gt; from Webpack 3.</source>
          <target state="translated">为了使用新的管道运算符而不增加捆绑包的大小，您将需要更改Webpack配置。这只有在工作的WebPack 3+，因为它依赖于新 &lt;code&gt;ModuleConcatenationPlugin&lt;/code&gt; 从3的WebPack。</target>
        </trans-unit>
        <trans-unit id="3d435e3fa3d8d13c3292375c9df88ca4214ee5db" translate="yes" xml:space="preserve">
          <source>In other runtimes, this operator will use a minimal implementation of &lt;code&gt;Set&lt;/code&gt; that relies on an &lt;code&gt;Array&lt;/code&gt; and &lt;code&gt;indexOf&lt;/code&gt; under the hood, so performance will degrade as more values are checked for distinction. Even in newer browsers, a long-running &lt;code&gt;distinct&lt;/code&gt; use might result in memory leaks. To help alleviate this in some scenarios, an optional &lt;code&gt;flushes&lt;/code&gt; parameter is also provided so that the internal &lt;code&gt;Set&lt;/code&gt; can be &quot;flushed&quot;, basically clearing it of values.</source>
          <target state="translated">在其他运行时中，此运算符将使用 &lt;code&gt;Set&lt;/code&gt; 的最小实现，该实现依赖于 &lt;code&gt;indexOf&lt;/code&gt; 的 &lt;code&gt;Array&lt;/code&gt; 和indexOf，因此，当检查更多的值以区分时，性能将降低。即使在较新的浏览器中，长时间的 &lt;code&gt;distinct&lt;/code&gt; 使用也可能导致内存泄漏。为了在某​​些情况下缓解此问题，还提供了可选的 &lt;code&gt;flushes&lt;/code&gt; 参数，以便可以&amp;ldquo;清除&amp;rdquo; 内部 &lt;code&gt;Set&lt;/code&gt; ，基本上清除其值。</target>
        </trans-unit>
        <trans-unit id="768c1eec37c4aabe5ab384f41143b24385fc36f4" translate="yes" xml:space="preserve">
          <source>In some APIs unregistering is actually handled differently. Method registering an event handler returns some kind of token, which is later used to identify which function should be unregistered or it itself has method that unregisters event handler. If that is the case with your API, make sure token returned by registering method is returned by &lt;code&gt;addHandler&lt;/code&gt;. Then it will be passed as a second argument to &lt;code&gt;removeHandler&lt;/code&gt;, where you will be able to use it.</source>
          <target state="translated">在某些API中，注销的处理实际上是不同的。注册事件处理程序的方法返回某种令牌，该令牌稍后用于标识哪个函数应被注销，或者它本身具有注销事件处理程序的方法。如果这是你的API的情况下，确保令牌，通过注册方法返回由返回 &lt;code&gt;addHandler&lt;/code&gt; 操作。然后它将作为第二个参数传递给 &lt;code&gt;removeHandler&lt;/code&gt; ，您将可以在其中使用它。</target>
        </trans-unit>
        <trans-unit id="31cb9789c815a7a8a9b3a98df002734fb61392f8" translate="yes" xml:space="preserve">
          <source>In the above situation we need the observable stream to complete so that we can test the variable was set to the correct value. The TestScheduler runs in 'virtual time' (synchronously), but doesn't normally run (and complete) until the testScheduler callback returns. The flush() method manually triggers the virtual time so that we can test the local variable after the observable completes.</source>
          <target state="translated">在上面的情况下,我们需要观察流完成,这样我们就可以测试变量被设置为正确的值。TestScheduler在 &quot;虚拟时间&quot;(同步)中运行,但通常不会运行(并完成),直到testScheduler回调返回。flush()方法手动触发虚拟时间,这样我们就可以在observable完成后测试本地变量。</target>
        </trans-unit>
        <trans-unit id="d19c3b25e6f5d0f4dceb81b95a860d7b023fe387" translate="yes" xml:space="preserve">
          <source>In the browser, &lt;code&gt;addEventListener&lt;/code&gt; accepts - apart from event type string and event handler function arguments - optional third parameter, which is either an object or boolean, both used for additional configuration how and when passed function will be called. When &lt;code&gt;fromEvent&lt;/code&gt; is used with event target of that type, you can provide this values as third parameter as well.</source>
          <target state="translated">在浏览器中， &lt;code&gt;addEventListener&lt;/code&gt; 接受-除了事件类型字符串和事件处理程序函数参数外-可选的第三个参数，它是一个对象或布尔值，均用于附加配置如何以及何时调用传递的函数。当 &lt;code&gt;fromEvent&lt;/code&gt; 与该类型的事件目标一起使用时，您也可以将此值作为第三个参数来提供。</target>
        </trans-unit>
        <trans-unit id="d611fc72a1a0461578e38fb87221937cf83ac16c" translate="yes" xml:space="preserve">
          <source>In the context of TestScheduler, a marble diagram is a string containing special syntax representing events happening over virtual time. Time progresses by &lt;em&gt;frames&lt;/em&gt;. The first character of any marble string always represents the &lt;em&gt;zero frame&lt;/em&gt;, or the start of time. Inside of &lt;code&gt;testScheduler.run(callback)&lt;/code&gt; the frameTimeFactor is set to 1, which means one frame is equal to one virtual millisecond.</source>
          <target state="translated">在TestScheduler的上下文中，大理石图是一个字符串，其中包含表示虚拟时间发生的事件的特殊语法。时间按&lt;em&gt;帧&lt;/em&gt;前进。任何大理石弦的第一个字符始终代表&lt;em&gt;零帧&lt;/em&gt;或时间的开始。在 &lt;code&gt;testScheduler.run(callback)&lt;/code&gt; 内部，frameTimeFactor设置为1，这意味着一帧等于一个虚拟毫秒。</target>
        </trans-unit>
        <trans-unit id="9e61d0bd368bc24118ba8a711748b25b10256924" translate="yes" xml:space="preserve">
          <source>In the example above, the &lt;code&gt;subscribe&lt;/code&gt; function is the most important piece to describe the Observable. Let's look at what subscribing means.</source>
          <target state="translated">在上面的示例中， &lt;code&gt;subscribe&lt;/code&gt; 函数是描述Observable的最重要部分。让我们看看订阅的含义。</target>
        </trans-unit>
        <trans-unit id="2d66b1569870cda1caa7fda5b5781d96cf478a71" translate="yes" xml:space="preserve">
          <source>In the example below, we have two Observers attached to a Subject, and we feed some values to the Subject:</source>
          <target state="translated">在下面的例子中,我们有两个Observers连接到一个Subject上,我们向Subject提供一些值。</target>
        </trans-unit>
        <trans-unit id="ab82f1f7a93e0c1d53bf67dd2a2293a5337f6463" translate="yes" xml:space="preserve">
          <source>In the example below, we take the usual simple Observable that emits values &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt;, &lt;code&gt;3&lt;/code&gt; synchronously, and use the operator &lt;code&gt;observeOn&lt;/code&gt; to specify the &lt;code&gt;async&lt;/code&gt; scheduler to use for delivering those values.</source>
          <target state="translated">在下面的例子中，我们采取通常的简单可观察发射值 &lt;code&gt;1&lt;/code&gt; ， &lt;code&gt;2&lt;/code&gt; ， &lt;code&gt;3&lt;/code&gt; 同步，并使用操作 &lt;code&gt;observeOn&lt;/code&gt; 指定 &lt;code&gt;async&lt;/code&gt; 调度程序使用用于输送这些值。</target>
        </trans-unit>
        <trans-unit id="e820ca5df78d6c0c13eb499231cccdc5f101da8d" translate="yes" xml:space="preserve">
          <source>In the following example there are two intervals turned into connectable observables by using the &lt;em&gt;publish&lt;/em&gt; operator. The first one uses the &lt;em&gt;refCount&lt;/em&gt; operator, the second one does not use it. You will notice that a connectable observable does nothing until you call its connect function.</source>
          <target state="translated">在下面的示例中，使用&lt;em&gt;publish&lt;/em&gt;运算符将两个间隔变为可连接的可观察对象。第一个使用&lt;em&gt;refCount&lt;/em&gt;运算符，第二个不使用它。您会注意到，可连接可观察对象在调用其连接函数之前不会执行任何操作。</target>
        </trans-unit>
        <trans-unit id="0552027c5d9b9c65f728320bf4fafca352e42373" translate="yes" xml:space="preserve">
          <source>In the following example, all emitted values ​​of the interval observable are skipped until the user clicks anywhere within the page.</source>
          <target state="translated">在下面的例子中,间隔观测值的所有发射值都会被跳过,直到用户点击页面中的任何地方。</target>
        </trans-unit>
        <trans-unit id="efee9e2790f7d7f99cf98470cbc85b870bc2c30d" translate="yes" xml:space="preserve">
          <source>In the following example, the BehaviorSubject is initialized with the value &lt;code&gt;0&lt;/code&gt; which the first Observer receives when it subscribes. The second Observer receives the value &lt;code&gt;2&lt;/code&gt; even though it subscribed after the value &lt;code&gt;2&lt;/code&gt; was sent.</source>
          <target state="translated">在下面的示例中，BehaviorSubject初始化为第一个观察者订阅时收到的值 &lt;code&gt;0&lt;/code&gt; 。即使第二个观察者在发送值 &lt;code&gt;2&lt;/code&gt; 后进行了预订，也接收到值 &lt;code&gt;2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8ee442c5a6c2ae9c1636bfba12a54be8b0e91b7b" translate="yes" xml:space="preserve">
          <source>In this example there is a timestamp attached to the documents click event.</source>
          <target state="translated">在这个例子中,有一个时间戳附加到文档点击事件。</target>
        </trans-unit>
        <trans-unit id="7b43a6d6f344b089c30152a966852ef922f720b7" translate="yes" xml:space="preserve">
          <source>Initial state.</source>
          <target state="translated">初始状态。</target>
        </trans-unit>
        <trans-unit id="b2a80b44b4811d2384ef831fa8087b37898d084c" translate="yes" xml:space="preserve">
          <source>Input Observables to merge together.</source>
          <target state="translated">输入要合并的观测值。</target>
        </trans-unit>
        <trans-unit id="2f07bb68f696a1f9376f7eac1c90eada31549502" translate="yes" xml:space="preserve">
          <source>Install RxJS v6 along with the &lt;a href=&quot;migration#backwards-compatibility&quot;&gt;backward-compatibility&lt;/a&gt; package, &lt;code&gt;rxjs-compat&lt;/code&gt;.</source>
          <target state="translated">安装RxJS v6以及&lt;a href=&quot;migration#backwards-compatibility&quot;&gt;向后兼容&lt;/a&gt;软件包 &lt;code&gt;rxjs-compat&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="550c70d12638cfa6aa8f9e73e5ae88f8cbc4e453" translate="yes" xml:space="preserve">
          <source>Installation Instructions</source>
          <target state="translated">安装说明</target>
        </trans-unit>
        <trans-unit id="65ec13dada396444df2fea802736eaf9062f72a3" translate="yes" xml:space="preserve">
          <source>Intercepts each emission on the source and runs a function, but returns an output which is identical to the source as long as errors don't occur.</source>
          <target state="translated">拦截源上的每一次发射,并运行一个函数,但只要不发生错误,就会返回一个与源相同的输出。</target>
        </trans-unit>
        <trans-unit id="fb09c60d73f84a6357255306df1f745b4014fb6b" translate="yes" xml:space="preserve">
          <source>Internal implementation detail, do not use directly.</source>
          <target state="translated">内部实施细节,不要直接使用。</target>
        </trans-unit>
        <trans-unit id="05fd7d31eb579f2cd61b47be24e926bade2627fd" translate="yes" xml:space="preserve">
          <source>Internally it counts the subscriptions to the observable and subscribes (only once) to the source if the number of subscriptions is larger than 0. If the number of subscriptions is smaller than 1, it unsubscribes from the source. This way you can make sure that everything before the &lt;em&gt;published&lt;/em&gt; refCount has only a single subscription independently of the number of subscribers to the target observable.</source>
          <target state="translated">在内部，它对可观察对象的订阅进行计数，并且如果订阅数大于0，则订阅源（仅一次）。如果订阅数小于1，则取消订阅源。这样，您可以确保&lt;em&gt;发布的&lt;/em&gt; refCount 之前的所有内容仅具有单个订阅，而与目标可观察者的订阅者数量无关。</target>
        </trans-unit>
        <trans-unit id="aaa8e0fc940297bcdab02842e2a5147eec870040" translate="yes" xml:space="preserve">
          <source>Internally the &lt;code&gt;skipUntil&lt;/code&gt; operator subscribes to the passed in observable (in the following called &lt;em&gt;notifier&lt;/em&gt;) in order to recognize the emission of its first value. When this happens, the operator unsubscribes from the &lt;em&gt;notifier&lt;/em&gt; and starts emitting the values of the &lt;em&gt;source&lt;/em&gt; observable. It will never let the &lt;em&gt;source&lt;/em&gt; observable emit any values if the &lt;em&gt;notifier&lt;/em&gt; completes or throws an error without emitting a value before.</source>
          <target state="translated">内部的 &lt;code&gt;skipUntil&lt;/code&gt; 运算符订阅传入的observable（在下面称为&lt;em&gt;notifier&lt;/em&gt;），以便识别其第一个值的发出。发生这种情况时，操作员将取消订阅&lt;em&gt;通知程序，&lt;/em&gt;并开始发出可观察到的&lt;em&gt;源&lt;/em&gt;值。如果&lt;em&gt;通知程序&lt;/em&gt;完成或引发错误而之前未发出任何值，则它将永远不会让&lt;em&gt;源&lt;/em&gt;可观察的&lt;em&gt;源&lt;/em&gt;发出任何值。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8a7007ce84b08e270eeaa49d4929b8f2489cac28" translate="yes" xml:space="preserve">
          <source>Internally to the Subject, &lt;code&gt;subscribe&lt;/code&gt; does not invoke a new execution that delivers values. It simply registers the given Observer in a list of Observers, similarly to how &lt;code&gt;addListener&lt;/code&gt; usually works in other libraries and languages.</source>
          <target state="translated">在主题内部， &lt;code&gt;subscribe&lt;/code&gt; 不会调用传递值的新执行。它只是将给定的观察者注册在观察者列表中，类似于 &lt;code&gt;addListener&lt;/code&gt; 通常在其他库和语言中的工作方式。</target>
        </trans-unit>
        <trans-unit id="24accef6c599f78a54078eab954e8eaa64e50ddd" translate="yes" xml:space="preserve">
          <source>InteropObservable</source>
          <target state="translated">InteropObservable</target>
        </trans-unit>
        <trans-unit id="2137906387d8cc5b016d85b0a13be63dbc02c890" translate="yes" xml:space="preserve">
          <source>Interval at which to start a new buffer. For example if &lt;code&gt;startBufferEvery&lt;/code&gt; is &lt;code&gt;2&lt;/code&gt;, then a new buffer will be started on every other value from the source. A new buffer is started at the beginning of the source by default.</source>
          <target state="translated">开始新缓冲区的时间间隔。例如，如果 &lt;code&gt;startBufferEvery&lt;/code&gt; 为 &lt;code&gt;2&lt;/code&gt; ，则将对源中的每个其他值启动一个新缓冲区。默认情况下，新缓冲区从源的开头开始。</target>
        </trans-unit>
        <trans-unit id="099ee7f53a8b8a0c2b710920d86de6469411ddbb" translate="yes" xml:space="preserve">
          <source>Interval at which to start a new window. For example if &lt;code&gt;startWindowEvery&lt;/code&gt; is &lt;code&gt;2&lt;/code&gt;, then a new window will be started on every other value from the source. A new window is started at the beginning of the source by default.</source>
          <target state="translated">开始新窗口的时间间隔。例如，如果 &lt;code&gt;startWindowEvery&lt;/code&gt; 为 &lt;code&gt;2&lt;/code&gt; ，则将从源中的每个其他值开始一个新窗口。默认情况下，新窗口在源的开头启动。</target>
        </trans-unit>
        <trans-unit id="cf4da275720c283107736e8fa280351990f16a51" translate="yes" xml:space="preserve">
          <source>IntervalObservable</source>
          <target state="translated">IntervalObservable</target>
        </trans-unit>
        <trans-unit id="c36e44208f62181f22b4bcd7126f50a720e594e1" translate="yes" xml:space="preserve">
          <source>Invokes an execution of an Observable and registers Observer handlers for notifications it will emit.</source>
          <target state="translated">调用一个Observable的执行,并注册Observer处理程序以发出通知。</target>
        </trans-unit>
        <trans-unit id="9d3ed26be15137921010183c814a29d964162f2d" translate="yes" xml:space="preserve">
          <source>Is the number &lt;code&gt;i&lt;/code&gt; for the i-th source emission that has happened since the subscription, starting from the number &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">是自订阅以来发生的第i个源发射的数字 &lt;code&gt;i&lt;/code&gt; ，从数字 &lt;code&gt;0&lt;/code&gt; 开始。</target>
        </trans-unit>
        <trans-unit id="97ed0bfaa76c328255273846366b63dd8bec2bd0" translate="yes" xml:space="preserve">
          <source>It creates an observable for an Ajax request with either a request object with url, headers, etc or a string for a URL.</source>
          <target state="translated">它为一个Ajax请求创建一个观察对象,这个观察对象可以是一个包含url、headers等的请求对象,也可以是一个URL的字符串。</target>
        </trans-unit>
        <trans-unit id="0db1e53616a29e5e2b418755002a34b4586aae8c" translate="yes" xml:space="preserve">
          <source>It defines a set of properties to provide custom behavior in specific moments of the socket's lifecycle. When the connection opens we can use &lt;code&gt;openObserver&lt;/code&gt;, when the connection is closed &lt;code&gt;closeObserver&lt;/code&gt;, if we are interested in listening for data comming from server: &lt;code&gt;deserializer&lt;/code&gt;, which allows us to customize the deserialization strategy of data before passing it to the socket client. By default &lt;code&gt;deserializer&lt;/code&gt; is going to apply &lt;code&gt;JSON.parse&lt;/code&gt; to each message comming from the Server.</source>
          <target state="translated">它定义了一组属性，以在套接字生命周期的特定时刻提供自定义行为。当打开连接，我们可以使用 &lt;code&gt;openObserver&lt;/code&gt; ，当连接关闭 &lt;code&gt;closeObserver&lt;/code&gt; ，如果大家有兴趣听的数据从正在添加服务器： &lt;code&gt;deserializer&lt;/code&gt; ，这使得我们可以将它传递给套接字客户端之前自定义数据的反序列化战略。默认情况下， &lt;code&gt;deserializer&lt;/code&gt; 将 &lt;code&gt;JSON.parse&lt;/code&gt; 应用于从服务器发送的每条消息。</target>
        </trans-unit>
        <trans-unit id="bd607bfeb0a8c9ef7622b42ffa771561bde8a17d" translate="yes" xml:space="preserve">
          <source>It is &lt;strong&gt;very important&lt;/strong&gt; to remember that input function &lt;code&gt;func&lt;/code&gt; is not called when the output function is, but rather when the Observable returned by the output function is subscribed. This means if &lt;code&gt;func&lt;/code&gt; makes an AJAX request, that request will be made every time someone subscribes to the resulting Observable, but not before.</source>
          <target state="translated">这是&lt;strong&gt;非常重要的&lt;/strong&gt;是要记住，输入功能 &lt;code&gt;func&lt;/code&gt; 当输出功能是不叫，而是当由输出函数返回的可观测订阅。这意味着，如果 &lt;code&gt;func&lt;/code&gt; 发出AJAX请求，则该请求将在有人订阅结果Observable时（而不是在此之前）进行。</target>
        </trans-unit>
        <trans-unit id="38a279bd2826e12e3145c4d6fbc3b6abb46c6bdb" translate="yes" xml:space="preserve">
          <source>It is a good idea to wrap any code in &lt;code&gt;subscribe&lt;/code&gt; with &lt;code&gt;try&lt;/code&gt;/&lt;code&gt;catch&lt;/code&gt; block that will deliver an Error notification if it catches an exception:</source>
          <target state="translated">这是一个好主意，包装任何代码 &lt;code&gt;subscribe&lt;/code&gt; 与 &lt;code&gt;try&lt;/code&gt; / &lt;code&gt;catch&lt;/code&gt; 块，如果它捕获异常，将提供错误通知：</target>
        </trans-unit>
        <trans-unit id="b9794570cb14fba1d1e1d2d489f15060023fbee9" translate="yes" xml:space="preserve">
          <source>It is more complicated, but if you have to write an operator that cannot be made from a combination of existing operators (a rare occurrance), you can write an operator from scratch using the Observable constructor, like this:</source>
          <target state="translated">它比较复杂,但如果你必须写一个不能由现有的运算符组合而成的运算符(这是一种罕见的情况),你可以使用Observable构造函数从头开始写一个运算符,像这样。</target>
        </trans-unit>
        <trans-unit id="0cdb922439d8586a691049b40d1a49708c3bd2ec" translate="yes" xml:space="preserve">
          <source>It is not a coincidence that &lt;code&gt;observable.subscribe&lt;/code&gt; and &lt;code&gt;subscribe&lt;/code&gt; in &lt;code&gt;new Observable(function subscribe(subscriber) {...})&lt;/code&gt; have the same name. In the library, they are different, but for practical purposes you can consider them conceptually equal.</source>
          <target state="translated">这不是一个巧合， &lt;code&gt;observable.subscribe&lt;/code&gt; 和 &lt;code&gt;subscribe&lt;/code&gt; 的 &lt;code&gt;new Observable(function subscribe(subscriber) {...})&lt;/code&gt; 具有相同的名称。在库中，它们是不同的，但是出于实际目的，您可以在概念上将它们视为相等。</target>
        </trans-unit>
        <trans-unit id="1f49f2032f83866e5a41394fb7bdc366cf78bdb9" translate="yes" xml:space="preserve">
          <source>It's a version of &lt;code&gt;timeout&lt;/code&gt; operator that let's you specify fallback Observable.</source>
          <target state="translated">它是 &lt;code&gt;timeout&lt;/code&gt; 运算符的一个版本，可让您指定后备Observable。</target>
        </trans-unit>
        <trans-unit id="adba087c9c9e58ee773402b9f6f601d478443832" translate="yes" xml:space="preserve">
          <source>It's just like &lt;a href=&quot;bindcallback&quot;&gt;&lt;code&gt;bindCallback&lt;/code&gt;&lt;/a&gt;, but the callback is expected to be of type &lt;code&gt;callback(error, result)&lt;/code&gt;.</source>
          <target state="translated">就像&lt;a href=&quot;bindcallback&quot;&gt; &lt;code&gt;bindCallback&lt;/code&gt; &lt;/a&gt;一样，但是回调应该是 &lt;code&gt;callback(error, result)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8a949408305dcb2e7acb7e5b74339b4b8a9ea2f9" translate="yes" xml:space="preserve">
          <source>It's like &lt;a href=&quot;../../operators/filter&quot;&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/a&gt;, but returns two Observables: one like the output of &lt;a href=&quot;../../operators/filter&quot;&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/a&gt;, and the other with values that did not pass the condition.</source>
          <target state="translated">就像&lt;a href=&quot;../../operators/filter&quot;&gt; &lt;code&gt;filter&lt;/code&gt; &lt;/a&gt;一样，但是返回两个Observables：一个类似于&lt;a href=&quot;../../operators/filter&quot;&gt; &lt;code&gt;filter&lt;/code&gt; &lt;/a&gt;的输出，另一个则具有未通过条件的值。</target>
        </trans-unit>
        <trans-unit id="df2238ba3a95389559de5a8118b9e1b31e6870d1" translate="yes" xml:space="preserve">
          <source>It's like &lt;a href=&quot;audittime&quot;&gt;&lt;code&gt;auditTime&lt;/code&gt;&lt;/a&gt;, but the silencing duration is determined by a second Observable.</source>
          <target state="translated">就像&lt;a href=&quot;audittime&quot;&gt; &lt;code&gt;auditTime&lt;/code&gt; &lt;/a&gt;一样，但是沉默持续时间由第二个Observable决定。</target>
        </trans-unit>
        <trans-unit id="c6de2f5807f7a8f592a3f85530871d0646e8235f" translate="yes" xml:space="preserve">
          <source>It's like &lt;a href=&quot;buffer&quot;&gt;&lt;code&gt;buffer&lt;/code&gt;&lt;/a&gt;, but emits a nested Observable instead of an array.</source>
          <target state="translated">就像&lt;a href=&quot;buffer&quot;&gt; &lt;code&gt;buffer&lt;/code&gt; &lt;/a&gt;一样，但是发出嵌套的Observable而不是数组。</target>
        </trans-unit>
        <trans-unit id="bb360af1ed3cecf856ed4ee0d48cd7d85b7a8dbf" translate="yes" xml:space="preserve">
          <source>It's like &lt;a href=&quot;buffercount&quot;&gt;&lt;code&gt;bufferCount&lt;/code&gt;&lt;/a&gt;, but emits a nested Observable instead of an array.</source>
          <target state="translated">就像&lt;a href=&quot;buffercount&quot;&gt; &lt;code&gt;bufferCount&lt;/code&gt; &lt;/a&gt;一样，但是发出嵌套的Observable而不是数组。</target>
        </trans-unit>
        <trans-unit id="ea49a2ff2b8a6a7fb1a2e802f2a2482ba7e26405" translate="yes" xml:space="preserve">
          <source>It's like &lt;a href=&quot;buffertime&quot;&gt;&lt;code&gt;bufferTime&lt;/code&gt;&lt;/a&gt;, but emits a nested Observable instead of an array.</source>
          <target state="translated">就像&lt;a href=&quot;buffertime&quot;&gt; &lt;code&gt;bufferTime&lt;/code&gt; &lt;/a&gt;，但是发出嵌套的Observable而不是数组。</target>
        </trans-unit>
        <trans-unit id="706a3adc8ab410c897c16a98366204b1a5b1240e" translate="yes" xml:space="preserve">
          <source>It's like &lt;a href=&quot;buffertoggle&quot;&gt;&lt;code&gt;bufferToggle&lt;/code&gt;&lt;/a&gt;, but emits a nested Observable instead of an array.</source>
          <target state="translated">就像&lt;a href=&quot;buffertoggle&quot;&gt; &lt;code&gt;bufferToggle&lt;/code&gt; &lt;/a&gt;，但是发出嵌套的Observable而不是数组。</target>
        </trans-unit>
        <trans-unit id="c558f7f5e114dacdde1f0f95f96fa4b2c26413e6" translate="yes" xml:space="preserve">
          <source>It's like &lt;a href=&quot;bufferwhen&quot;&gt;&lt;code&gt;bufferWhen&lt;/code&gt;&lt;/a&gt;, but emits a nested Observable instead of an array.</source>
          <target state="translated">就像&lt;a href=&quot;bufferwhen&quot;&gt; &lt;code&gt;bufferWhen&lt;/code&gt; &lt;/a&gt;一样，但是发出嵌套的Observable而不是数组。</target>
        </trans-unit>
        <trans-unit id="11e12fef4db4958942dc505d6a8f8247a1770fb1" translate="yes" xml:space="preserve">
          <source>It's like &lt;a href=&quot;concatmap&quot;&gt;&lt;code&gt;concatMap&lt;/code&gt;&lt;/a&gt;, but maps each value always to the same inner Observable.</source>
          <target state="translated">就像&lt;a href=&quot;concatmap&quot;&gt; &lt;code&gt;concatMap&lt;/code&gt; &lt;/a&gt;一样，但是总是将每个值映射到相同的内部Observable。</target>
        </trans-unit>
        <trans-unit id="e3a867c904920532b682926d9570e66b6bd84a27" translate="yes" xml:space="preserve">
          <source>It's like &lt;a href=&quot;debouncetime&quot;&gt;&lt;code&gt;debounceTime&lt;/code&gt;&lt;/a&gt;, but the time span of emission silence is determined by a second Observable.</source>
          <target state="translated">就像&lt;a href=&quot;debouncetime&quot;&gt; &lt;code&gt;debounceTime&lt;/code&gt; &lt;/a&gt;一样，但是发射静音的时间跨度由第二个Observable确定。</target>
        </trans-unit>
        <trans-unit id="3275012c1bb12737fa3e7ae966dc46708b8e6efc" translate="yes" xml:space="preserve">
          <source>It's like &lt;a href=&quot;delay&quot;&gt;&lt;code&gt;delay&lt;/code&gt;&lt;/a&gt;, but passes only the most recent value from each burst of emissions.</source>
          <target state="translated">这就像&lt;a href=&quot;delay&quot;&gt; &lt;code&gt;delay&lt;/code&gt; &lt;/a&gt;，但仅传递每次排放突发中的最新值。</target>
        </trans-unit>
        <trans-unit id="d6cdbfb00c44af71004ef36133f0e226b40e866d" translate="yes" xml:space="preserve">
          <source>It's like &lt;a href=&quot;delay&quot;&gt;&lt;code&gt;delay&lt;/code&gt;&lt;/a&gt;, but the time span of the delay duration is determined by a second Observable.</source>
          <target state="translated">就像&lt;a href=&quot;delay&quot;&gt; &lt;code&gt;delay&lt;/code&gt; &lt;/a&gt;一样，但是延迟持续时间的时间跨度由第二个Observable决定。</target>
        </trans-unit>
        <trans-unit id="ce158c4252c2c44186bb2ae22b21fe949150e8db" translate="yes" xml:space="preserve">
          <source>It's like &lt;a href=&quot;distinctuntilchanged&quot;&gt;&lt;code&gt;distinctUntilChanged&lt;/code&gt;&lt;/a&gt;, but the distinct comparison uses a key to access a property.</source>
          <target state="translated">就像&lt;a href=&quot;distinctuntilchanged&quot;&gt; &lt;code&gt;distinctUntilChanged&lt;/code&gt; &lt;/a&gt;一样，但是独特的比较使用键来访问属性。</target>
        </trans-unit>
        <trans-unit id="5c0357dea7ccb925e323e6256fef87dc2aa65faa" translate="yes" xml:space="preserve">
          <source>It's like &lt;a href=&quot;filter&quot;&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/a&gt;, but just emits the values that are distinct from the previous.</source>
          <target state="translated">就像&lt;a href=&quot;filter&quot;&gt; &lt;code&gt;filter&lt;/code&gt; &lt;/a&gt;一样，但是只发出与前一个不同的值。</target>
        </trans-unit>
        <trans-unit id="99fd3844345480d4d64d317a7f5cce322d21307b" translate="yes" xml:space="preserve">
          <source>It's like &lt;a href=&quot;filter&quot;&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/a&gt;, but returns two Observables: one like the output of &lt;a href=&quot;filter&quot;&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/a&gt;, and the other with values that did not pass the condition.</source>
          <target state="translated">就像&lt;a href=&quot;filter&quot;&gt; &lt;code&gt;filter&lt;/code&gt; &lt;/a&gt;一样，但是返回两个Observables：一个类似于&lt;a href=&quot;filter&quot;&gt; &lt;code&gt;filter&lt;/code&gt; &lt;/a&gt;的输出，另一个则具有未通过条件的值。</target>
        </trans-unit>
        <trans-unit id="d3d241a8228a7878020999c61c552183637beb90" translate="yes" xml:space="preserve">
          <source>It's like &lt;a href=&quot;find&quot;&gt;&lt;code&gt;find&lt;/code&gt;&lt;/a&gt;, but emits the index of the found value, not the value itself.</source>
          <target state="translated">就像&lt;a href=&quot;find&quot;&gt; &lt;code&gt;find&lt;/code&gt; &lt;/a&gt;一样，但是发出找到的值的索引，而不是值本身。</target>
        </trans-unit>
        <trans-unit id="e351dca74c30132376a13304bc29d358d6a27d4a" translate="yes" xml:space="preserve">
          <source>It's like &lt;a href=&quot;mergemap&quot;&gt;&lt;code&gt;mergeMap&lt;/code&gt;&lt;/a&gt;, but maps each value always to the same inner Observable.</source>
          <target state="translated">就像&lt;a href=&quot;mergemap&quot;&gt; &lt;code&gt;mergeMap&lt;/code&gt; &lt;/a&gt;一样，但是总是将每个值映射到相同的内部Observable。</target>
        </trans-unit>
        <trans-unit id="5a2dae1b945020085aa1bdb445e10117bc9edf5c" translate="yes" xml:space="preserve">
          <source>It's like &lt;a href=&quot;reduce&quot;&gt;&lt;code&gt;reduce&lt;/code&gt;&lt;/a&gt;, but emits the current accumulation whenever the source emits a value.</source>
          <target state="translated">就像&lt;a href=&quot;reduce&quot;&gt; &lt;code&gt;reduce&lt;/code&gt; &lt;/a&gt;，但是只要源发出一个值，就发出电流累积。</target>
        </trans-unit>
        <trans-unit id="11335e7a911246f108a73bcdde65715b0a687052" translate="yes" xml:space="preserve">
          <source>It's like &lt;a href=&quot;sampletime&quot;&gt;&lt;code&gt;sampleTime&lt;/code&gt;&lt;/a&gt;, but samples whenever the &lt;code&gt;notifier&lt;/code&gt; Observable emits something.</source>
          <target state="translated">就像&lt;a href=&quot;sampletime&quot;&gt; &lt;code&gt;sampleTime&lt;/code&gt; &lt;/a&gt;一样，但是只要 &lt;code&gt;notifier&lt;/code&gt; Observable发出某种东西就进行采样。</target>
        </trans-unit>
        <trans-unit id="9c680229f70e56c617131cc1ad57ec227fad2968" translate="yes" xml:space="preserve">
          <source>It's like &lt;a href=&quot;scan&quot;&gt;&lt;code&gt;scan&lt;/code&gt;&lt;/a&gt;, but the Observables returned by the accumulator are merged into the outer Observable.</source>
          <target state="translated">这就像&lt;a href=&quot;scan&quot;&gt; &lt;code&gt;scan&lt;/code&gt; &lt;/a&gt;，但是累加器返回的Observable合并到外部Observable中。</target>
        </trans-unit>
        <trans-unit id="91c3e182197c6bbc8865c1e13f76ab49385127db" translate="yes" xml:space="preserve">
          <source>It's like &lt;a href=&quot;switchmap&quot;&gt;&lt;code&gt;switchMap&lt;/code&gt;&lt;/a&gt;, but maps each value always to the same inner Observable.</source>
          <target state="translated">就像&lt;a href=&quot;switchmap&quot;&gt; &lt;code&gt;switchMap&lt;/code&gt; &lt;/a&gt;一样，但是总是将每个值映射到相同的内部Observable。</target>
        </trans-unit>
        <trans-unit id="30b32b4febb6083279feeaff98ca0e142595e8ea" translate="yes" xml:space="preserve">
          <source>It's like &lt;a href=&quot;throttletime&quot;&gt;&lt;code&gt;throttleTime&lt;/code&gt;&lt;/a&gt;, but the silencing duration is determined by a second Observable.</source>
          <target state="translated">这就像&lt;a href=&quot;throttletime&quot;&gt; &lt;code&gt;throttleTime&lt;/code&gt; &lt;/a&gt;时间，但沉默持续时间由第二个Observable决定。</target>
        </trans-unit>
        <trans-unit id="8810900091c7ff83ffa55bebab9241df1287ca4d" translate="yes" xml:space="preserve">
          <source>It's similar to &lt;a href=&quot;mergemap&quot;&gt;&lt;code&gt;mergeMap&lt;/code&gt;&lt;/a&gt;, but applies the projection function to every source value as well as every output value. It's recursive.</source>
          <target state="translated">它类似于&lt;a href=&quot;mergemap&quot;&gt; &lt;code&gt;mergeMap&lt;/code&gt; &lt;/a&gt;，但将投影函数应用于每个源值以及每个输出值。它是递归的。</target>
        </trans-unit>
        <trans-unit id="dcf6717fe65da536a04da4f882bbdfa195868e09" translate="yes" xml:space="preserve">
          <source>Iteration step function.</source>
          <target state="translated">迭代步骤功能。</target>
        </trans-unit>
        <trans-unit id="2b22b7393382746b99d053013a324ab18c83302f" translate="yes" xml:space="preserve">
          <source>IteratorObservable</source>
          <target state="translated">IteratorObservable</target>
        </trans-unit>
        <trans-unit id="18774004fcf928104b67925a5470d3718ffd4dd1" translate="yes" xml:space="preserve">
          <source>Its like &lt;a href=&quot;interval&quot;&gt;&lt;code&gt;interval&lt;/code&gt;&lt;/a&gt;, but you can specify when should the emissions start.</source>
          <target state="translated">类似于&lt;a href=&quot;interval&quot;&gt; &lt;code&gt;interval&lt;/code&gt; &lt;/a&gt;，但您可以指定何时开始排放。</target>
        </trans-unit>
        <trans-unit id="1203b0749dc07175c4d76a73a84de4edcdb74c59" translate="yes" xml:space="preserve">
          <source>Join Creation Operators</source>
          <target state="translated">加入创造运营商</target>
        </trans-unit>
        <trans-unit id="63c003abaf20a9193778451d8079bc48f87ac911" translate="yes" xml:space="preserve">
          <source>Join Operators</source>
          <target state="translated">加入运营商</target>
        </trans-unit>
        <trans-unit id="84e488e39c2aaa417a3c3e76304c3db42f028475" translate="yes" xml:space="preserve">
          <source>Joins every Observable emitted by the source (a higher-order Observable), in a serial fashion. It subscribes to each inner Observable only after the previous inner Observable has completed, and merges all of their values into the returned observable.</source>
          <target state="translated">将源发出的每一个Observable(一个高阶Observable)以串行方式连接起来。只有在前一个内部Observable完成后,它才会订阅每个内部Observable,并将它们的所有值合并到返回的Observable中。</target>
        </trans-unit>
        <trans-unit id="3515b72ff2f6de015a4a8c6afbf292965ba26aa0" translate="yes" xml:space="preserve">
          <source>Just as in case of NodeList it is a collection of DOM nodes. Here as well event handler function is installed and removed in each of elements.</source>
          <target state="translated">就像NodeList一样,它是一个DOM节点的集合。在这里,事件处理函数也是在每个元素中安装和删除。</target>
        </trans-unit>
        <trans-unit id="404e85255f54d27c3b2cdce08ac4a990657b5eac" translate="yes" xml:space="preserve">
          <source>Just as many array library combine &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map&quot;&gt;&lt;code&gt;map()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/flat&quot;&gt;&lt;code&gt;flat()&lt;/code&gt;&lt;/a&gt; (or &lt;code&gt;flatten()&lt;/code&gt;) into a single &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/flatMap&quot;&gt;&lt;code&gt;flatMap()&lt;/code&gt;&lt;/a&gt;, there are mapping equivalents of all the RxJS flattening operators &lt;a href=&quot;../api/operators/concatmap&quot;&gt;&lt;code&gt;concatMap()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../api/operators/mergemap&quot;&gt;&lt;code&gt;mergeMap()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../api/operators/switchmap&quot;&gt;&lt;code&gt;switchMap()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../api/operators/exhaustmap&quot;&gt;&lt;code&gt;exhaustMap()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">正如许多数组库将&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map&quot;&gt; &lt;code&gt;map()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/flat&quot;&gt; &lt;code&gt;flat()&lt;/code&gt; &lt;/a&gt;（或 &lt;code&gt;flatten()&lt;/code&gt; ）合并为一个&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/flatMap&quot;&gt; &lt;code&gt;flatMap()&lt;/code&gt; 一样&lt;/a&gt;，所有RxJS展平运算符&lt;a href=&quot;../api/operators/concatmap&quot;&gt; &lt;code&gt;concatMap()&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../api/operators/mergemap&quot;&gt; &lt;code&gt;mergeMap()&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../api/operators/switchmap&quot;&gt; &lt;code&gt;switchMap()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../api/operators/exhaustmap&quot;&gt; &lt;code&gt;exhaustMap()&lt;/code&gt; &lt;/a&gt;映射等效项（）。</target>
        </trans-unit>
        <trans-unit id="6c1daef5575638ed8a0458933187be02bbdef946" translate="yes" xml:space="preserve">
          <source>Just emits 'complete', and nothing else.</source>
          <target state="translated">只是发出'完成',其他什么都没有。</target>
        </trans-unit>
        <trans-unit id="c3af46a19db3dcac82625d7bebe2770ee0d8fc0f" translate="yes" xml:space="preserve">
          <source>Just emits 'error', and nothing else.</source>
          <target state="translated">只是发出'错误',而不是其他。</target>
        </trans-unit>
        <trans-unit id="1b80e3c5bd407999419466edbb962c55711528d1" translate="yes" xml:space="preserve">
          <source>Just like &lt;code&gt;observable.subscribe&lt;/code&gt; resembles &lt;code&gt;new Observable(function subscribe() {...})&lt;/code&gt;, the &lt;code&gt;unsubscribe&lt;/code&gt; we return from &lt;code&gt;subscribe&lt;/code&gt; is conceptually equal to &lt;code&gt;subscription.unsubscribe&lt;/code&gt;. In fact, if we remove the ReactiveX types surrounding these concepts, we're left with rather straightforward JavaScript.</source>
          <target state="translated">就像 &lt;code&gt;observable.subscribe&lt;/code&gt; 类似于 &lt;code&gt;new Observable(function subscribe() {...})&lt;/code&gt; &lt;code&gt;subscription.unsubscribe&lt;/code&gt; （）{...}）一样，我们从subscription返回的 &lt;code&gt;unsubscribe&lt;/code&gt; &lt;code&gt;subscribe&lt;/code&gt; 在概念上也等于subscription.unsubscribe。实际上，如果删除围绕这些概念的ReactiveX类型，则会剩下相当简单的JavaScript。</target>
        </trans-unit>
        <trans-unit id="f5025143a89e9b224781aa62468c0e2c91c66496" translate="yes" xml:space="preserve">
          <source>Known Issues</source>
          <target state="translated">已知问题</target>
        </trans-unit>
        <trans-unit id="52fab7dcbdbdd2ead5469234d5dae4a2b47ad34c" translate="yes" xml:space="preserve">
          <source>Last argument to &lt;code&gt;multiplex&lt;/code&gt; is a &lt;code&gt;messageFilter&lt;/code&gt; function which should return a boolean. It is used to filter out messages sent by the server to only those that belong to simulated WebSocket stream. For example, server might mark these messages with some kind of string identifier on a message object and &lt;code&gt;messageFilter&lt;/code&gt; would return &lt;code&gt;true&lt;/code&gt; if there is such identifier on an object emitted by the socket. Messages which returns &lt;code&gt;false&lt;/code&gt; in &lt;code&gt;messageFilter&lt;/code&gt; are simply skipped, and are not passed down the stream.</source>
          <target state="translated">&lt;code&gt;multiplex&lt;/code&gt; 最后一个参数是 &lt;code&gt;messageFilter&lt;/code&gt; 函数，该函数应返回布尔值。它用于过滤服务器发送的消息，使其仅过滤出属于模拟WebSocket流的消息。例如，服务器可能在消息对象上用某种字符串标识符标记这些消息，并且 &lt;code&gt;messageFilter&lt;/code&gt; 将返回 &lt;code&gt;true&lt;/code&gt; 如果套接字发出的对象上存在此类标识符，则 true。在 &lt;code&gt;messageFilter&lt;/code&gt; 中返回 &lt;code&gt;false&lt;/code&gt; 的消息将被跳过，并且不会向下传递。</target>
        </trans-unit>
        <trans-unit id="ae3a986fdd0c26fe5d0e22d38167502d27e4db8f" translate="yes" xml:space="preserve">
          <source>Lets a value pass, then ignores source values for the next &lt;code&gt;duration&lt;/code&gt; milliseconds.</source>
          <target state="translated">让值传递，然后在下一个 &lt;code&gt;duration&lt;/code&gt; 毫秒）内忽略源值。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
