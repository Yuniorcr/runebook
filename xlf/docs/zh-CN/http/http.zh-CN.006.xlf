<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="http">
    <body>
      <group id="http">
        <trans-unit id="bf1f2785d8f6ee0235d694fd6179a1a3ebce5bba" translate="yes" xml:space="preserve">
          <source>RFC 5789, section 2: Patch method</source>
          <target state="translated">RFC 5789,第2节:补丁方法</target>
        </trans-unit>
        <trans-unit id="fcb38f9a6380d714f3aa4aa1f4201bc7bc90649d" translate="yes" xml:space="preserve">
          <source>RFC 5789: PATCH</source>
          <target state="translated">RFC 5789:PATCH</target>
        </trans-unit>
        <trans-unit id="435cdf88638b49c1ce4749b77a33a7b13603777d" translate="yes" xml:space="preserve">
          <source>RFC 5861</source>
          <target state="translated">RFC 5861</target>
        </trans-unit>
        <trans-unit id="226ff035a62a7f266b477b5175c0a96c8bb2165a" translate="yes" xml:space="preserve">
          <source>RFC 5861: HTTP Cache-Control Extensions for Stale Content</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48dc1f7525cc2cf74db930d6713d686f2df34d50" translate="yes" xml:space="preserve">
          <source>RFC 5988</source>
          <target state="translated">RFC 5988</target>
        </trans-unit>
        <trans-unit id="2b11e388477bae4eb7798fb62c83b47e1cbed253" translate="yes" xml:space="preserve">
          <source>RFC 6265</source>
          <target state="translated">RFC 6265</target>
        </trans-unit>
        <trans-unit id="b5eb31f373a0763462f319db509a52b6efca5715" translate="yes" xml:space="preserve">
          <source>RFC 6265, section 4.1: Set-Cookie</source>
          <target state="translated">RFC 6265,第4.1节:设置Cookie。</target>
        </trans-unit>
        <trans-unit id="15c9cf4fea3d42ffcec6eb1b94d408b0e19bb14e" translate="yes" xml:space="preserve">
          <source>RFC 6265, section 5.4: Cookie</source>
          <target state="translated">RFC 6265,第 5.4 节。Cookie</target>
        </trans-unit>
        <trans-unit id="613865a71a94220a6a1341819550a78bc1fc41ef" translate="yes" xml:space="preserve">
          <source>RFC 6266</source>
          <target state="translated">RFC 6266</target>
        </trans-unit>
        <trans-unit id="d3105d90012e53abd5db2c45d15c178159422497" translate="yes" xml:space="preserve">
          <source>RFC 6454</source>
          <target state="translated">RFC 6454</target>
        </trans-unit>
        <trans-unit id="fd51012d090b8c63c11d5dd6844e9f25685bef76" translate="yes" xml:space="preserve">
          <source>RFC 6454, section 7: Origin</source>
          <target state="translated">RFC 6454,第7节:起源</target>
        </trans-unit>
        <trans-unit id="2e1c3bd109055e3c75b85953fe0738a169565c42" translate="yes" xml:space="preserve">
          <source>RFC 6455</source>
          <target state="translated">RFC 6455</target>
        </trans-unit>
        <trans-unit id="86802f0623b9fab215ab4bcc599a1c003c37e0b7" translate="yes" xml:space="preserve">
          <source>RFC 6455, section 11.3.3: Sec-WebSocket-Accept</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19d36fc539eae3719343f4e94df0ac87431a15c5" translate="yes" xml:space="preserve">
          <source>RFC 6585</source>
          <target state="translated">RFC 6585</target>
        </trans-unit>
        <trans-unit id="45d634e5b12466ed4cc193d856d4e4c08256a283" translate="yes" xml:space="preserve">
          <source>RFC 6585, section 3: 428 Precondition Required</source>
          <target state="translated">RFC 6585,第3节:428要求的前提条件。</target>
        </trans-unit>
        <trans-unit id="07a86b3bb5912601c3ae8de2ec856a047e1a4207" translate="yes" xml:space="preserve">
          <source>RFC 6585, section 4: 429 Too Many Requests</source>
          <target state="translated">RFC 6585,第4节:429太多请求。</target>
        </trans-unit>
        <trans-unit id="bae288b759aab289a7b722340a6c68ada2a24664" translate="yes" xml:space="preserve">
          <source>RFC 6585, section 5: 431 Request Header Fields Too Large</source>
          <target state="translated">RFC 6585,第5节:431请求头字段过大。</target>
        </trans-unit>
        <trans-unit id="f0550ad6cfb7431d8de64660db24e5adfdd0f1cd" translate="yes" xml:space="preserve">
          <source>RFC 6585, section 6: 511 Network Authentication Required</source>
          <target state="translated">RFC 6585,第6节:511网络认证必填。</target>
        </trans-unit>
        <trans-unit id="f59f441f51a2a15aab903870156075198c21cdcd" translate="yes" xml:space="preserve">
          <source>RFC 6797</source>
          <target state="translated">RFC 6797</target>
        </trans-unit>
        <trans-unit id="0f65e4b9ea5170ccf77ae139b024de2922225370" translate="yes" xml:space="preserve">
          <source>RFC 7034</source>
          <target state="translated">RFC 7034</target>
        </trans-unit>
        <trans-unit id="6b67e7dae86a60ad1a1b1df8824dc9553710faf9" translate="yes" xml:space="preserve">
          <source>RFC 7168</source>
          <target state="translated">RFC 7168</target>
        </trans-unit>
        <trans-unit id="5462ffa212ed4302d0699e27c71e7418400fa7ad" translate="yes" xml:space="preserve">
          <source>RFC 7168, section 2.3.3: 418 I'm a teapot</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c5e351b2c4935f263fb4a48d2a5973b96f162c0" translate="yes" xml:space="preserve">
          <source>RFC 7230</source>
          <target state="translated">RFC 7230</target>
        </trans-unit>
        <trans-unit id="05085ef8bae59f857a83a325ca8b5cb7c95f7a86" translate="yes" xml:space="preserve">
          <source>RFC 7230, appendix A.1.2: Keep-Alive</source>
          <target state="translated">RFC 7230,附录A.1.2:Keep-Alive。</target>
        </trans-unit>
        <trans-unit id="0e5d3d164e7dba93b9411bbfb503f35bd97bc36f" translate="yes" xml:space="preserve">
          <source>RFC 7230, section 2.7: Uniform Resource Identifiers</source>
          <target state="translated">RFC 7230,第2.7节:统一资源标识符。</target>
        </trans-unit>
        <trans-unit id="747d53c19ff7b93c55d4b76ad86eb7700475d3b8" translate="yes" xml:space="preserve">
          <source>RFC 7230, section 3.3.1: Transfer-Encoding</source>
          <target state="translated">RFC 7230,第3.3.1节:传输编码。</target>
        </trans-unit>
        <trans-unit id="f0a41fabfd014b8b41ea52076f5ba499d7cab7cc" translate="yes" xml:space="preserve">
          <source>RFC 7230, section 3.3.2: Content-Length</source>
          <target state="translated">RFC 7230,第3.3.2节:内容长度。</target>
        </trans-unit>
        <trans-unit id="ce15bb0ced28e642094a4b2e10552a5a260c63c6" translate="yes" xml:space="preserve">
          <source>RFC 7230, section 4.1.2: Chunked trailer part</source>
          <target state="translated">RFC 7230,4.1.2节。分块拖车部分</target>
        </trans-unit>
        <trans-unit id="dc4a36d13fa8deb7e75049f8717535024790d01d" translate="yes" xml:space="preserve">
          <source>RFC 7230, section 4.3: TE</source>
          <target state="translated">RFC 7230,第4.3节:TE</target>
        </trans-unit>
        <trans-unit id="d01fd56ebeb831ef7c0ec347cc56581ef2c37a02" translate="yes" xml:space="preserve">
          <source>RFC 7230, section 4.4: Trailer</source>
          <target state="translated">RFC 7230,第4.4节:拖车</target>
        </trans-unit>
        <trans-unit id="ce720dca2d38fd8ebd182748949f09c36140d1ba" translate="yes" xml:space="preserve">
          <source>RFC 7230, section 5.4: Host</source>
          <target state="translated">RFC 7230,第5.4节:主机。</target>
        </trans-unit>
        <trans-unit id="72b7097053626ce619fadddb8fd07f185dcb00c0" translate="yes" xml:space="preserve">
          <source>RFC 7230, section 5.7.1: Via</source>
          <target state="translated">RFC 7230,5.7.1节:Via</target>
        </trans-unit>
        <trans-unit id="ce9e01aff0adf150803198bb232477284f281a17" translate="yes" xml:space="preserve">
          <source>RFC 7230: Message Syntax and Routing</source>
          <target state="translated">RFC 7230:消息语法和路由选择</target>
        </trans-unit>
        <trans-unit id="caea547a0cf9d64aba6043b091dc5eb22f58c313" translate="yes" xml:space="preserve">
          <source>RFC 7231</source>
          <target state="translated">RFC 7231</target>
        </trans-unit>
        <trans-unit id="08e4bb7d474ebf9b4dd37dbb5dfb6ad9f1018a66" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 3.1.1.5: Content-Type</source>
          <target state="translated">RFC 7231,第3.1.1.5节:内容类型。</target>
        </trans-unit>
        <trans-unit id="845eed76936a3d924d01b333e9f1eb88f65e9b0f" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 3.1.2.2: Content-Encoding</source>
          <target state="translated">RFC 7231,第3.1.2.2节:内容编码。</target>
        </trans-unit>
        <trans-unit id="ea53991de97033c504914c78c87f5ffed390f149" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 3.1.3.2: Content-Language</source>
          <target state="translated">RFC 7231,第3.1.3.2节:内容-语言。</target>
        </trans-unit>
        <trans-unit id="c63e7fc6e081defb92fe9ecf5164796bcbd6a746" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 3.1.4.2: Content-Location</source>
          <target state="translated">RFC 7231,第3.1.4.2节:内容-定位。</target>
        </trans-unit>
        <trans-unit id="d4fb8e8cb57094e1102d5ce3bdd8cff5312ab200" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 4.3.1: GET</source>
          <target state="translated">RFC 7231,第4.3.1节:TEG</target>
        </trans-unit>
        <trans-unit id="beb916c6c25dc7649f8c49842ab7dcda780a0246" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 4.3.2: HEAD</source>
          <target state="translated">RFC 7231,第4.3.2节:HEAD。</target>
        </trans-unit>
        <trans-unit id="396a77b857e79049fe6031ef49d21a0effb58e9a" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 4.3.3: POST</source>
          <target state="translated">RFC 7231,第4.3.3节:POST</target>
        </trans-unit>
        <trans-unit id="be438af5d1a292f596f21a801b7d9603f1cab40b" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 4.3.4: PUT</source>
          <target state="translated">RFC 7231,第4.3.4节:LUP。</target>
        </trans-unit>
        <trans-unit id="f107039cbadc5f826dae91dd218c725e9d18d841" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 4.3.5: DELETE</source>
          <target state="translated">RFC 7231,第4.3.5节:DELETE。</target>
        </trans-unit>
        <trans-unit id="1dc7248ccd888336bd82b884b087f4b3f4f4679d" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 4.3.6: CONNECT</source>
          <target state="translated">RFC 7231,4.3.6节:CONNECT</target>
        </trans-unit>
        <trans-unit id="5ef875b188d1b54f345842c090e95ae722453dbd" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 4.3.7: OPTIONS</source>
          <target state="translated">RFC 7231,第4.3.7节:选项。</target>
        </trans-unit>
        <trans-unit id="332f9c31f0f5c275ad307d53cca2499a9459de39" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 4.3.8: TRACE</source>
          <target state="translated">RFC 7231,第4.3.8节:TRACE</target>
        </trans-unit>
        <trans-unit id="23ec2e6bb03069a7e2356906fa0861e5c5f31298" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 4: Request methods</source>
          <target state="translated">RFC 7231,第4节:请求方法</target>
        </trans-unit>
        <trans-unit id="ca01a74d4319434dec806f81b435f5ef7fe00cac" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 5.1.1: Expect</source>
          <target state="translated">RFC 7231,5.1.1节。预期</target>
        </trans-unit>
        <trans-unit id="482924da4508aa7f733bf03dc780a68aae52445c" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 5.3.2: Accept</source>
          <target state="translated">RFC 7231,第5.3.2节:接受。</target>
        </trans-unit>
        <trans-unit id="35accde19d283e519f8ec1ed2362fcc85f24a93d" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 5.3.3: Accept-Charset</source>
          <target state="translated">RFC 7231,第5.3.3节:Accept-Charset。</target>
        </trans-unit>
        <trans-unit id="ad6e29ab51fd42d62fbcdb472acfb4ac84a2a268" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 5.3.4: Accept-Encoding</source>
          <target state="translated">RFC 7231,第5.3.4节:接受-编码。</target>
        </trans-unit>
        <trans-unit id="807a7c74e7037b7f5abd66cfb4a79ff6ae43d3b7" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 5.3.5: Accept-Language</source>
          <target state="translated">RFC 7231,第5.3.5节:接受语言。</target>
        </trans-unit>
        <trans-unit id="e193dba38f7e55035b47ef2c109569e16479cf69" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 5.5.1: From</source>
          <target state="translated">RFC 7231,第5.5.1节:从哪里来?</target>
        </trans-unit>
        <trans-unit id="b509df34815d389002b3401e3af6b97ec17a4637" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 5.5.2: Referer</source>
          <target state="translated">RFC 7231,5.5.2节。Referer</target>
        </trans-unit>
        <trans-unit id="1741ea24040d407102645a5261e3be49a42c9d36" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 5.5.3: User-Agent</source>
          <target state="translated">RFC 7231,第5.5.3节:用户代理。</target>
        </trans-unit>
        <trans-unit id="12fc41e4605afa8a835cf818819d37d8835a9501" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.2.1: 100 Continue</source>
          <target state="translated">RFC 7231,第6.2.1节。100 继续</target>
        </trans-unit>
        <trans-unit id="6153c15954bc862a70895fbc431bad2da954c971" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.2.2: 101 Switching Protocol</source>
          <target state="translated">RFC 7231,第6.2.2节:101交换协议。</target>
        </trans-unit>
        <trans-unit id="bbfde0e52731d4e9dc93932249da61bebf73a1a8" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.3.1: 200 OK</source>
          <target state="translated">RFC 7231,第6.3.1节:200确定。</target>
        </trans-unit>
        <trans-unit id="1fc7e03406eaa40d727064f1b1bc3e08b2b14fd4" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.3.2: 201 Created</source>
          <target state="translated">RFC 7231,第6.3.2节:201创建。</target>
        </trans-unit>
        <trans-unit id="c97971bcf5eac84ad103104d1e5f58bc875207a1" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.3.3: 202 Accepted</source>
          <target state="translated">RFC 7231,第6.3.3节:202接受。</target>
        </trans-unit>
        <trans-unit id="5429f5aaa896873c3bed767ca81e26df2c7d4715" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.3.4: 203 Non-Authoritative Information</source>
          <target state="translated">RFC 7231,第6.3.4节:203非授权信息。</target>
        </trans-unit>
        <trans-unit id="c87d7f32f1d541fc3b4a3f52e5b74b91132ee59a" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.3.5: 204 No Content</source>
          <target state="translated">RFC 7231,6.3.5节:204无内容。</target>
        </trans-unit>
        <trans-unit id="88a53ddfea1c8ca509da6b5a44b1c7abe59a44fd" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.3.6: 205 Reset Content</source>
          <target state="translated">RFC 7231,6.3.6节:205重置内容。</target>
        </trans-unit>
        <trans-unit id="4ccda537000db21782a1059815056fc5839e13c3" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.4.1: 300 Multiple Choices</source>
          <target state="translated">RFC 7231,第6.4.1节。300多项选择</target>
        </trans-unit>
        <trans-unit id="dceac5b474240f3b0b90d94b9503bf6ba6db86b0" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.4.2: 301 Moved Permanently</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d103f2e9ff04ca2a770ac0401e07c62e79f89aa" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.4.2: 301 Redirect Permanently</source>
          <target state="translated">RFC 7231,第6.4.2节:301永久重定向。</target>
        </trans-unit>
        <trans-unit id="80c5d21b755a5e2b263018667896cddc904c5323" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.4.3: 302 Found</source>
          <target state="translated">RFC 7231,第6.4.3节:302发现。</target>
        </trans-unit>
        <trans-unit id="23d636dfadbfc167109f5734f6597b0cef5487e5" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.4.4: 303 See Other</source>
          <target state="translated">RFC 7231,6.4.4节。303 见其他</target>
        </trans-unit>
        <trans-unit id="e5ee708c3ca4bdea3c8e87cba0d3aeae2df304a8" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.4.7: 307 Temporary Redirect</source>
          <target state="translated">RFC 7231,6.4.7节:307临时重定向。</target>
        </trans-unit>
        <trans-unit id="dee8c16141db46bb418511c175d2eec007fefeed" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.5.10: 411 Length Required</source>
          <target state="translated">RFC 7231,第6.5.10节:411所需长度。</target>
        </trans-unit>
        <trans-unit id="26171f5c8cb59ffc020457ea938b7ec236d9ea28" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.5.11: 413 Payload Too Large</source>
          <target state="translated">RFC 7231,6.5.11节:413有效载荷太大。</target>
        </trans-unit>
        <trans-unit id="cee9c7a8574968783fae740117c4c07af062c5f8" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.5.12: 414 URI Too Long</source>
          <target state="translated">RFC 7231,第6.5.12节:414 URI太长。</target>
        </trans-unit>
        <trans-unit id="58c6fc79debfdeea6e272e99df4c1743e620d756" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.5.13: 415 Unsupported Media Type</source>
          <target state="translated">RFC 7231,第6.5.13节:415不支持的媒体类型。</target>
        </trans-unit>
        <trans-unit id="0392d0e21a03c252a2bf41dd4d443c3d6b9104c7" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.5.14: 417 Expectation Failed</source>
          <target state="translated">RFC 7231,6.5.14节:417期望失败。</target>
        </trans-unit>
        <trans-unit id="57441c8550e44a304af1a569e4e597ea1887e91a" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.5.15: 426 Upgrade Required</source>
          <target state="translated">RFC 7231,第6.5.15节:426需要升级。</target>
        </trans-unit>
        <trans-unit id="6dd8faeaf11eb0bd52552958e7ae54b11b10b57f" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.5.1: 400 Bad Request</source>
          <target state="translated">RFC 7231,第6.5.1节:400坏请求。</target>
        </trans-unit>
        <trans-unit id="e163a78f9330d6741a5bd6e7cdbb8e3fec5ffe5f" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.5.3: 403 Forbidden</source>
          <target state="translated">RFC 7231,第 6.5.3 节。403 禁止</target>
        </trans-unit>
        <trans-unit id="b6bc1661f3cf5de1c14ac6be35b1910851cacaaf" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.5.4: 404 Not Found</source>
          <target state="translated">RFC 7231,第6.5.4节:404未找到。</target>
        </trans-unit>
        <trans-unit id="a9844f8c14db25ad38c4cfe8d0f0b736510c9fb5" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.5.5: 405 Method Not Allowed</source>
          <target state="translated">RFC 7231,第6.5.5节:405方法不允许。</target>
        </trans-unit>
        <trans-unit id="fc4efdb5f2dc5dc6d424604880e980cb82e94103" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.5.6: 406 Not Acceptable</source>
          <target state="translated">RFC 7231,第6.5.6节:406不可接受。</target>
        </trans-unit>
        <trans-unit id="43b35d1f584a1c0099592c15ae91827db7dc94b7" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.5.7: 408 Request Timeout</source>
          <target state="translated">RFC 7231,6.5.7节:408请求超时。</target>
        </trans-unit>
        <trans-unit id="1b0d3945f363c33827abe747256729c99c9037c6" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.5.8: 409 Conflict</source>
          <target state="translated">RFC 7231,第6.5.8节:409冲突</target>
        </trans-unit>
        <trans-unit id="fd998823588377f38984c686c556f3bcfc09dc66" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.5.9: 410 Gone</source>
          <target state="translated">RFC 7231,第6.5.9节:410 Gone。</target>
        </trans-unit>
        <trans-unit id="e020731d0df0b23d948c30ebaf118d17f15bafb5" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.6.1: 500 Internal Server Error</source>
          <target state="translated">RFC 7231,第6.6.1节:500内部服务器错误。</target>
        </trans-unit>
        <trans-unit id="0123b7de98a247141787a487b5e238ce6e98a7c2" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.6.2: 501 Not Implemented</source>
          <target state="translated">RFC 7231,第6.6.2节:501未实施。</target>
        </trans-unit>
        <trans-unit id="d8ade00b1145627ea23139c44dc6c9c4c9e6e5b1" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.6.3: 502 Bad Gateway</source>
          <target state="translated">RFC 7231,第6.6.3节:502坏网关。</target>
        </trans-unit>
        <trans-unit id="beb22556b06eef638a44ed63d5c6ad4adb9b6b33" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.6.4: 503 Service Unavailable</source>
          <target state="translated">RFC 7231,6.6.4节:503服务不可用。</target>
        </trans-unit>
        <trans-unit id="f08bdf6a75d66bf8a9bbf1045e44b8379123db51" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.6.4: 504 Gateway Timeout</source>
          <target state="translated">RFC 7231,6.6.4节:504网关超时。</target>
        </trans-unit>
        <trans-unit id="4cbd04babc221aadbb70a08f8f6b0cb23a89f952" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.6.5: 504 Gateway Timeout</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e6e09aea7bfdaaf0dd1e985137eee45520431d3" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.6.6: 505 HTTP Version Not Supported</source>
          <target state="translated">RFC 7231,第6.6.6节:不支持505 HTTP版本。</target>
        </trans-unit>
        <trans-unit id="b3ba7c2a99f80e2130967ae0193aa90dfc01cbe3" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 7.1.1.2: Date</source>
          <target state="translated">RFC 7231,第7.1.1.2节:日期。</target>
        </trans-unit>
        <trans-unit id="4cd70f93c86793f098a850ee9a15dfed514d641f" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 7.1.2: Location</source>
          <target state="translated">RFC 7231,第7.1.2节:租赁。</target>
        </trans-unit>
        <trans-unit id="b605ee3c8c03aa07e4aba2513a66cca3bddaa02a" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 7.1.3: Retry-After</source>
          <target state="translated">RFC 7231,第7.1.3节。重试之后</target>
        </trans-unit>
        <trans-unit id="453d48122df892243f46b4738824f126f915dd76" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 7.1.4: Vary</source>
          <target state="translated">RFC 7231,第7.1.4节:Vary------。</target>
        </trans-unit>
        <trans-unit id="7db55929216f08581bb0f9a961b79184aed41a16" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 7.4.1: Allow</source>
          <target state="translated">RFC 7231,第7.4.1节。允许</target>
        </trans-unit>
        <trans-unit id="9acad768df0dbe6c37cba16cbfd5595d6bc92ab0" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 7.4.2: Server</source>
          <target state="translated">RFC 7231,第7.4.2节:服务器。</target>
        </trans-unit>
        <trans-unit id="c13136120d6f8f6ddbce80914e170e5f5ba98e4e" translate="yes" xml:space="preserve">
          <source>RFC 7231: Semantics and Content</source>
          <target state="translated">RFC 7231:语义和内容</target>
        </trans-unit>
        <trans-unit id="a63def99ce2877d2732ea2cc7396d5f537db97a4" translate="yes" xml:space="preserve">
          <source>RFC 7232</source>
          <target state="translated">RFC 7232</target>
        </trans-unit>
        <trans-unit id="295d565b0fec0216825a3e8cb65a1446aa3ed8b2" translate="yes" xml:space="preserve">
          <source>RFC 7232, section 2.2: Last-Modified</source>
          <target state="translated">RFC 7232,第2.2节:最后修订版</target>
        </trans-unit>
        <trans-unit id="e2e4bc35caa4058f5fac16569cf63c21cb420386" translate="yes" xml:space="preserve">
          <source>RFC 7232, section 2.3: ETag</source>
          <target state="translated">RFC 7232,第 2.3 节:ETag</target>
        </trans-unit>
        <trans-unit id="9bcc0918bdc69773f66aa681a671407cbdd4b5bb" translate="yes" xml:space="preserve">
          <source>RFC 7232, section 3.1: If-Match</source>
          <target state="translated">RFC 7232,第3.1节:If-Match。</target>
        </trans-unit>
        <trans-unit id="73bd2578dcbed6d7d7505e11efb11c61cda96b36" translate="yes" xml:space="preserve">
          <source>RFC 7232, section 3.2: If-None-Match</source>
          <target state="translated">RFC 7232,第3.2节:If-None-Match。</target>
        </trans-unit>
        <trans-unit id="d0cfec8ff7070bfbde6decdb05c41ab3d5b5e60d" translate="yes" xml:space="preserve">
          <source>RFC 7232, section 3.3: If-Modified-Since</source>
          <target state="translated">RFC 7232,第3.3节:If-Modified-Since。</target>
        </trans-unit>
        <trans-unit id="83ababad8d137088ebfa02c4cfad17ffdbaa6cb9" translate="yes" xml:space="preserve">
          <source>RFC 7232, section 3.4: If-Unmodified-Since</source>
          <target state="translated">RFC 7232,第3.4节。If-Unmodified-Since</target>
        </trans-unit>
        <trans-unit id="8c6b803aef1ae0cbc7963494f52a6e2d1221aa72" translate="yes" xml:space="preserve">
          <source>RFC 7232, section 4.1: 304 Not Modified</source>
          <target state="translated">RFC 7232,第4.1节:304未修改。</target>
        </trans-unit>
        <trans-unit id="c6371edfa3fd6545f1ed9b50760abaa5432d23c6" translate="yes" xml:space="preserve">
          <source>RFC 7232, section 4.2: 412 Precondition Failed</source>
          <target state="translated">RFC 7232,第 4.2 节:412 前提条件失败。</target>
        </trans-unit>
        <trans-unit id="85fcffc8931e515561355807b30267e41fd6036c" translate="yes" xml:space="preserve">
          <source>RFC 7232: Conditional Requests</source>
          <target state="translated">RFC 7232:条件请求</target>
        </trans-unit>
        <trans-unit id="0220cee7fbe573d22b712a263403a869c71ee9dd" translate="yes" xml:space="preserve">
          <source>RFC 7233</source>
          <target state="translated">RFC 7233</target>
        </trans-unit>
        <trans-unit id="24b52ae865d6573f42daca9e9ba3d5d371687dd9" translate="yes" xml:space="preserve">
          <source>RFC 7233, section 2.3: Accept-Ranges</source>
          <target state="translated">RFC 7233,第2.3节:范围接受</target>
        </trans-unit>
        <trans-unit id="217e0bf69b2117ab58b4e0362c97f19fa1befd75" translate="yes" xml:space="preserve">
          <source>RFC 7233, section 3.1: Range</source>
          <target state="translated">RFC 7233,第3.1节:范围。</target>
        </trans-unit>
        <trans-unit id="60ffdc5927f45232551eeaf6f5b683a4c7108395" translate="yes" xml:space="preserve">
          <source>RFC 7233, section 3.2: If-Range</source>
          <target state="translated">RFC 7233,第3.2节:If-Range。</target>
        </trans-unit>
        <trans-unit id="60f87acc5e83708a238fe44d6d995662a04d25cb" translate="yes" xml:space="preserve">
          <source>RFC 7233, section 4.1: 206 Partial Content</source>
          <target state="translated">RFC 7233,第4.1节:206部分内容。</target>
        </trans-unit>
        <trans-unit id="c97dc325c5a2c56a80141bafdec4776ec6494289" translate="yes" xml:space="preserve">
          <source>RFC 7233, section 4.1: Content-Type in multipart</source>
          <target state="translated">RFC 7233,第4.1节。多部分的内容类型</target>
        </trans-unit>
        <trans-unit id="b2f0b42f9b254f4e75cc959dec9a41424191299d" translate="yes" xml:space="preserve">
          <source>RFC 7233, section 4.2: Content-Range</source>
          <target state="translated">RFC 7233,第4.2节:内容范围。</target>
        </trans-unit>
        <trans-unit id="17ab846647e11ad24dd7cae43b5b7ba50f8d5783" translate="yes" xml:space="preserve">
          <source>RFC 7233, section 4.4: 416 Request Not Satisfiable</source>
          <target state="translated">RFC 7233,第4.4节:416请求不能满足。</target>
        </trans-unit>
        <trans-unit id="39280b50b8604fb2c52645b83bb68d63d5aea084" translate="yes" xml:space="preserve">
          <source>RFC 7233: Range Requests</source>
          <target state="translated">RFC 7233:范围请求</target>
        </trans-unit>
        <trans-unit id="d73ca14480035f6afc269fff0b2cbd5e7a9d5226" translate="yes" xml:space="preserve">
          <source>RFC 7234</source>
          <target state="translated">RFC 7234</target>
        </trans-unit>
        <trans-unit id="b7b8fb4415d92cc12caa06d3116834044fd58735" translate="yes" xml:space="preserve">
          <source>RFC 7234, section 5.1: Age</source>
          <target state="translated">RFC 7234,第5.1节:年龄。</target>
        </trans-unit>
        <trans-unit id="8f0ec2babea29f2d75d8b6c1eeefe35f6783a262" translate="yes" xml:space="preserve">
          <source>RFC 7234, section 5.3: Expires</source>
          <target state="translated">RFC 7234,第5.3节:有效期</target>
        </trans-unit>
        <trans-unit id="b61069d359f94e29544f46f37732668c2e0dc488" translate="yes" xml:space="preserve">
          <source>RFC 7234, section 5.4: Pragma</source>
          <target state="translated">RFC 7234,第5.4节:Pragma。</target>
        </trans-unit>
        <trans-unit id="e5b281777a588dfebb9e4f33147f9393c44ff9d5" translate="yes" xml:space="preserve">
          <source>RFC 7234, section 5.5: Warning</source>
          <target state="translated">RFC 7234,第5.5节:警告。</target>
        </trans-unit>
        <trans-unit id="15c277735dd7ab9d554b55649227872a7a319b2e" translate="yes" xml:space="preserve">
          <source>RFC 7234: Caching</source>
          <target state="translated">RFC 7234:高速缓存</target>
        </trans-unit>
        <trans-unit id="95e2fdb4338d98c3460a6ba511c8317ede846646" translate="yes" xml:space="preserve">
          <source>RFC 7234: Hypertext Transfer Protocol (HTTP/1.1): Caching</source>
          <target state="translated">RFC 7234:超文本传输协议(HTTP/1.1):缓存。</target>
        </trans-unit>
        <trans-unit id="7f05efb06e3e1509abf29d93ad4e47416b9ccc82" translate="yes" xml:space="preserve">
          <source>RFC 7235</source>
          <target state="translated">RFC 7235</target>
        </trans-unit>
        <trans-unit id="11160b7b94c66c72e517d2361647cbfe55fa56cb" translate="yes" xml:space="preserve">
          <source>RFC 7235, section 3.1: 401 Unauthorized</source>
          <target state="translated">RFC 7235,第3.1节:401未经授权的。</target>
        </trans-unit>
        <trans-unit id="8d8532df2f09e49337c4c44dc682d4d79601e9b4" translate="yes" xml:space="preserve">
          <source>RFC 7235, section 3.2: 407 Proxy Authentication Required</source>
          <target state="translated">RFC 7235,第3.2节:407需要代理认证。</target>
        </trans-unit>
        <trans-unit id="614dc9841e719e4ac1a80ff45d19cd0f0c9471e6" translate="yes" xml:space="preserve">
          <source>RFC 7235, section 4.1: WWW-Authenticate</source>
          <target state="translated">RFC 7235,第4.1节:WWW-Authenticate。</target>
        </trans-unit>
        <trans-unit id="a2b8a63336dfcfbb148fd489dd97af9d7523c4c5" translate="yes" xml:space="preserve">
          <source>RFC 7235, section 4.2: Authorization</source>
          <target state="translated">RFC 7235,第4.2节:授权</target>
        </trans-unit>
        <trans-unit id="ad222d9356ff1738b54e88377024fa368f6aa997" translate="yes" xml:space="preserve">
          <source>RFC 7235, section 4.3: Proxy-Authenticate</source>
          <target state="translated">RFC 7235,第4.3节:代理-认证</target>
        </trans-unit>
        <trans-unit id="ce095e11e9ac5123f50e10205d7a968f6a419fbd" translate="yes" xml:space="preserve">
          <source>RFC 7235, section 4.4: Proxy-Authorization</source>
          <target state="translated">RFC 7235,第 4.4 节。代理-授权</target>
        </trans-unit>
        <trans-unit id="92acef83d821fd2467bc28bd2fd60d10ec1c7cc9" translate="yes" xml:space="preserve">
          <source>RFC 7235: Authentication</source>
          <target state="translated">RFC 7235:认证</target>
        </trans-unit>
        <trans-unit id="39253ac4ebddd236a15a85088849c6a80583c2fe" translate="yes" xml:space="preserve">
          <source>RFC 7239</source>
          <target state="translated">RFC 7239</target>
        </trans-unit>
        <trans-unit id="6123756e88cf4a45823e0759687abb9c00f566cc" translate="yes" xml:space="preserve">
          <source>RFC 7239, section 4: Forwarded</source>
          <target state="translated">RFC 7239,第4节:转发。</target>
        </trans-unit>
        <trans-unit id="2513b2cc7a8731819cb7304e73f8bd0c92970573" translate="yes" xml:space="preserve">
          <source>RFC 7301</source>
          <target state="translated">RFC 7301</target>
        </trans-unit>
        <trans-unit id="e53ba536932ce8bea18cc606f0e1b867a58004cf" translate="yes" xml:space="preserve">
          <source>RFC 7469, section 2.1: Public-Key-Pins</source>
          <target state="translated">RFC 7469,第2.1节:公钥引脚。</target>
        </trans-unit>
        <trans-unit id="f73866d0b27647fd51170d239bc52eb95cc3fa80" translate="yes" xml:space="preserve">
          <source>RFC 7469, section 2.1: Public-Key-Pins-Report-Only</source>
          <target state="translated">RFC 7469,第2.1节:仅公开密钥引脚-报告。</target>
        </trans-unit>
        <trans-unit id="7d33083b52d3c2f5c0c6e4555c83f4c7a93666d3" translate="yes" xml:space="preserve">
          <source>RFC 7538</source>
          <target state="translated">RFC 7538</target>
        </trans-unit>
        <trans-unit id="c18f1a9e84a66e50185533b4e1d6c5b801e53f75" translate="yes" xml:space="preserve">
          <source>RFC 7538, section 3: 308 Permanent Redirect</source>
          <target state="translated">RFC 7538,第3节:308永久重定向。</target>
        </trans-unit>
        <trans-unit id="381a51e0e8724bb0e7528dce36a046520ef83310" translate="yes" xml:space="preserve">
          <source>RFC 7540</source>
          <target state="translated">RFC 7540</target>
        </trans-unit>
        <trans-unit id="52f90fdebc595d706e0153547db03d37bcb956f4" translate="yes" xml:space="preserve">
          <source>RFC 7541</source>
          <target state="translated">RFC 7541</target>
        </trans-unit>
        <trans-unit id="16fe2f0e9c1d829ee3481e9a51d563391aac14b0" translate="yes" xml:space="preserve">
          <source>RFC 7578</source>
          <target state="translated">RFC 7578</target>
        </trans-unit>
        <trans-unit id="60d6f8ab48b07523a864373ca4d1105c601e0a56" translate="yes" xml:space="preserve">
          <source>RFC 7617</source>
          <target state="translated">RFC 7617</target>
        </trans-unit>
        <trans-unit id="16bb582fedfa8c1bed21cfd9a33eb35b67ce48ef" translate="yes" xml:space="preserve">
          <source>RFC 7725</source>
          <target state="translated">RFC 7725</target>
        </trans-unit>
        <trans-unit id="b3c12a54619425f8c7eeee0564e7f9c3445ee5e2" translate="yes" xml:space="preserve">
          <source>RFC 7725: 451 Unavailable For Legal Reasons</source>
          <target state="translated">RFC 7725:451因法律原因不可用。</target>
        </trans-unit>
        <trans-unit id="4c3ce0e7d6d5e6d33d64ba958f7a104cfc60ffd0" translate="yes" xml:space="preserve">
          <source>RFC 7838</source>
          <target state="translated">RFC 7838</target>
        </trans-unit>
        <trans-unit id="98a96516560a300a5745bcfe44d56d86a7703616" translate="yes" xml:space="preserve">
          <source>RFC 7932: Brotli Compressed Data Format</source>
          <target state="translated">RFC 7932:Brotli压缩数据格式</target>
        </trans-unit>
        <trans-unit id="72d8ba28c60c4ceca4316e723297a3f77d3efdaa" translate="yes" xml:space="preserve">
          <source>RFC 8246</source>
          <target state="translated">RFC 8246</target>
        </trans-unit>
        <trans-unit id="a45497157d8a3432246f536cdef9b1f416a32287" translate="yes" xml:space="preserve">
          <source>RFC 8246: HTTP Immutable Responses</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c259030985e8f0cd03404af04d74d18e09f0c5c5" translate="yes" xml:space="preserve">
          <source>RFC 8446</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f103f5fd279c09f20f0c5ca89184d4caecaccd28" translate="yes" xml:space="preserve">
          <source>RFC 8470, section 5.1: The Early-Data Header Field</source>
          <target state="translated">RFC 8470,第5.1节:早期数据头字段</target>
        </trans-unit>
        <trans-unit id="a0eebba627153a93ef3a322033c309ca579202f0" translate="yes" xml:space="preserve">
          <source>RFC 8470, section 5.2: 425: Early Data</source>
          <target state="translated">RFC 8470,第5.2节:425:早期数据</target>
        </trans-unit>
        <trans-unit id="a16c5bbe4bf996740f257aa1e81bd57e4c52c8dd" translate="yes" xml:space="preserve">
          <source>Range</source>
          <target state="translated">Range</target>
        </trans-unit>
        <trans-unit id="9b88ba0fe4aa1b0d39f03df49c05115f581fef09" translate="yes" xml:space="preserve">
          <source>Range (RFC 2616)</source>
          <target state="translated">范围(RFC 2616)</target>
        </trans-unit>
        <trans-unit id="5039997fc0613071590aceb1ddcbf09f19902112" translate="yes" xml:space="preserve">
          <source>Range (RFC 7233)</source>
          <target state="translated">范围(RFC 7233)</target>
        </trans-unit>
        <trans-unit id="75e5476d2fa33e515b99ac682187fa29b2de5aea" translate="yes" xml:space="preserve">
          <source>Range requests</source>
          <target state="translated">范围请求</target>
        </trans-unit>
        <trans-unit id="cbd19be28e80eee61c6befb6a6a0e0189a81e54b" translate="yes" xml:space="preserve">
          <source>Range units are intended to be extensible.  New range units ought to
   be registered with IANA, as defined in &lt;a href=&quot;#section-5.1&quot;&gt;Section 5.1&lt;/a&gt;.

     other-range-unit = token</source>
          <target state="translated">范围单位旨在可扩展。根据&lt;a href=&quot;#section-5.1&quot;&gt;第5.1节的&lt;/a&gt;定义，应向IANA注册新的范围单位。其他范围单位=令牌</target>
        </trans-unit>
        <trans-unit id="10022056ab083091adb5d812601237d60a879215" translate="yes" xml:space="preserve">
          <source>Read the response sent by the server, such as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed40b9d6cc0d0cb3ce7a7ad02dba7338812a8080" translate="yes" xml:space="preserve">
          <source>Read the response sent by the server:</source>
          <target state="translated">读取服务器发送的响应。</target>
        </trans-unit>
        <trans-unit id="7877f60e00a2d773f57c4014d0a738ad9861667e" translate="yes" xml:space="preserve">
          <source>Reading Do Not Track status from JavaScript</source>
          <target state="translated">从JavaScript中读取Do Not Track状态</target>
        </trans-unit>
        <trans-unit id="f219cc0614ae6860f43a3cd84b5cf31fc312cd9d" translate="yes" xml:space="preserve">
          <source>Reason</source>
          <target state="translated">Reason</target>
        </trans-unit>
        <trans-unit id="ed3274e667a68705864a7876442c08c9a0c89279" translate="yes" xml:space="preserve">
          <source>Reason: CORS disabled</source>
          <target state="translated">原因:CORS失效</target>
        </trans-unit>
        <trans-unit id="f5163ddcca584feb16b95fbbfa91c4d7d0260331" translate="yes" xml:space="preserve">
          <source>Reason: CORS header &amp;lsquo;Access-Control-Allow-Origin&amp;rsquo; does not match &amp;lsquo;xyz&amp;rsquo;</source>
          <target state="translated">原因：CORS标头&amp;ldquo; Access-Control-Allow-Origin&amp;rdquo;与&amp;ldquo; xyz&amp;rdquo;不匹配</target>
        </trans-unit>
        <trans-unit id="5bdd6c0c5118a6b13076b0be624dd329902e18ef" translate="yes" xml:space="preserve">
          <source>Reason: CORS header &amp;lsquo;Access-Control-Allow-Origin&amp;rsquo; missing</source>
          <target state="translated">原因：CORS标头&amp;ldquo; Access-Control-Allow-Origin&amp;rdquo;丢失</target>
        </trans-unit>
        <trans-unit id="1658865d36eb134fe7d46709a144c1d565865930" translate="yes" xml:space="preserve">
          <source>Reason: CORS header &amp;lsquo;Origin&amp;rsquo; cannot be added</source>
          <target state="translated">原因：无法添加CORS标头&amp;ldquo;来源&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="aef82a650f94d9766311469581926f1ed57a82f8" translate="yes" xml:space="preserve">
          <source>Reason: CORS preflight channel did not succeed</source>
          <target state="translated">原因:CORS飞行前通道不成功。CORS飞行前通道不成功</target>
        </trans-unit>
        <trans-unit id="07e1781531cc98f0e96de22d1192b8d4d3333825" translate="yes" xml:space="preserve">
          <source>Reason: CORS request did not succeed</source>
          <target state="translated">原因:CORS请求不成功</target>
        </trans-unit>
        <trans-unit id="09c9cb183a85be0b3b6cde7b88314ddcd37427b3" translate="yes" xml:space="preserve">
          <source>Reason: CORS request external redirect not allowed</source>
          <target state="translated">原因:CORS请求外部重定向不允许。CORS请求外部重定向不允许</target>
        </trans-unit>
        <trans-unit id="868608d4173aba486e510c1993aebd1346b28581" translate="yes" xml:space="preserve">
          <source>Reason: CORS request not http</source>
          <target state="translated">原因是 CORS请求不是http</target>
        </trans-unit>
        <trans-unit id="756ce5c83972090dfd18afc09136a9721594344b" translate="yes" xml:space="preserve">
          <source>Reason: Credential is not supported if the CORS header &amp;lsquo;Access-Control-Allow-Origin&amp;rsquo; is &amp;lsquo;*&amp;rsquo;</source>
          <target state="translated">原因：如果CORS标头&amp;ldquo; Access-Control-Allow-Origin&amp;rdquo;为&amp;ldquo; *&amp;rdquo;，则不支持凭据</target>
        </trans-unit>
        <trans-unit id="61897273348d9502ac4a9cbfc6912d021a1fdadc" translate="yes" xml:space="preserve">
          <source>Reason: Did not find method in CORS header &amp;lsquo;Access-Control-Allow-Methods&amp;rsquo;</source>
          <target state="translated">原因：在CORS标头&amp;ldquo; Access-Control-Allow-Methods&amp;rdquo;中找不到方法</target>
        </trans-unit>
        <trans-unit id="cde3fd2f65e458b45dfb439c839198bdc521c6f3" translate="yes" xml:space="preserve">
          <source>Reason: Multiple CORS header &amp;lsquo;Access-Control-Allow-Origin&amp;rsquo; not allowed</source>
          <target state="translated">原因：不允许使用多个CORS标头'Access-Control-Allow-Origin'</target>
        </trans-unit>
        <trans-unit id="2e8f5f20e78993baa10a1b749e10443f8fcd3944" translate="yes" xml:space="preserve">
          <source>Reason: expected &amp;lsquo;true&amp;rsquo; in CORS header &amp;lsquo;Access-Control-Allow-Credentials&amp;rsquo;</source>
          <target state="translated">原因：在CORS标头&amp;ldquo;访问控制允许凭据&amp;rdquo;中预期为&amp;ldquo;真&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="50a43b6e0fb5601d24499970d71432793694c9ad" translate="yes" xml:space="preserve">
          <source>Reason: invalid token &amp;lsquo;xyz&amp;rsquo; in CORS header &amp;lsquo;Access-Control-Allow-Headers&amp;rsquo;</source>
          <target state="translated">原因：CORS标头&amp;ldquo; Access-Control-Allow-Headers&amp;rdquo;中的令牌&amp;ldquo; xyz&amp;rdquo;无效</target>
        </trans-unit>
        <trans-unit id="b8cfc9f82a605294184410b4a2e649b6e93163c6" translate="yes" xml:space="preserve">
          <source>Reason: invalid token &amp;lsquo;xyz&amp;rsquo; in CORS header &amp;lsquo;Access-Control-Allow-Methods&amp;rsquo;</source>
          <target state="translated">原因：CORS标头&amp;ldquo; Access-Control-Allow-Methods&amp;rdquo;中的无效令牌&amp;ldquo; xyz&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="ceb18ef27a39563d15f30fc87ea5ec94ceb819ce" translate="yes" xml:space="preserve">
          <source>Reason: missing token &amp;lsquo;xyz&amp;rsquo; in CORS header &amp;lsquo;Access-Control-Allow-Headers&amp;rsquo; from CORS preflight channel</source>
          <target state="translated">原因：CORS预检通道中的CORS标头&amp;ldquo; Access-Control-Allow-Headers&amp;rdquo;中缺少令牌&amp;ldquo; xyz&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="ea166a8dce951acdcb755ee27ef556a370c2d19d" translate="yes" xml:space="preserve">
          <source>Recent versions of Firefox support as well:</source>
          <target state="translated">最近版本的Firefox也支持。</target>
        </trans-unit>
        <trans-unit id="6422fcc967f452634a501ffeeec039bbb50d3cbc" translate="yes" xml:space="preserve">
          <source>Recommendation</source>
          <target state="translated">Recommendation</target>
        </trans-unit>
        <trans-unit id="bd1aceb143f071d874bbc123b72264a36a503ab4" translate="yes" xml:space="preserve">
          <source>Recommendations on &lt;a href=&quot;https://developer.mozilla.org/en/Browser_Detection_and_Cross_Browser_Support&quot;&gt;sniffing the UA string for cross-browser support&lt;/a&gt;</source>
          <target state="translated">有关&lt;a href=&quot;https://developer.mozilla.org/en/Browser_Detection_and_Cross_Browser_Support&quot;&gt;嗅探UA字符串以进行跨浏览器支持的建议&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cfa5b8af1af0a8bb6eedbb724cbc97011a905b75" translate="yes" xml:space="preserve">
          <source>Recording and analyzing user behavior</source>
          <target state="translated">记录和分析用户行为</target>
        </trans-unit>
        <trans-unit id="7c8d8fc9cfc5aced3cb8d64bdef12d562b42debf" translate="yes" xml:space="preserve">
          <source>RedBot</source>
          <target state="translated">RedBot</target>
        </trans-unit>
        <trans-unit id="637dfb39d3c34e08850ea6f3b5b6369d2f7469e2" translate="yes" xml:space="preserve">
          <source>Redirect responses (300-303, 305, and 307) defined in HTTP 1.1
   normally take a Location header to indicate the new URI for the
   single resource redirected from the Request-URI.  Multi-Status
   responses contain many resource addresses, but the original
   definition in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC2518&lt;/a&gt;] did not have any place for the server to
   provide the new URI for redirected resources.  This specification
   does define a 'location' element for this information (see
   &lt;a href=&quot;#section-14.9&quot;&gt;Section 14.9&lt;/a&gt;).  Servers MUST use this new element with redirect
   responses in Multi-Status.

   Clients encountering redirected resources in Multi-Status MUST NOT
   rely on the 'location' element being present with a new URI.  If the
   element is not present, the client MAY reissue the request to the
   individual redirected resource, because the response to that request
   can be redirected with a Location header containing the new URI.</source>
          <target state="translated">HTTP 1.1中定义的重定向响应（300-303、305和307）通常采用Location标头，以指示从Request-URI重定向的单个资源的新URI。多状态响应包含许多资源地址，但是[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC2518&lt;/a&gt; ]中的原始定义没有任何位置让服务器为重定向的资源提供新的URI。本规范确实为此信息定义了&amp;ldquo;位置&amp;rdquo;元素（请参见 &lt;a href=&quot;#section-14.9&quot;&gt;第14.9节）&lt;/a&gt;）。服务器必须在Multi-Status中将此新元素与重定向响应一起使用。在多状态下遇到重定向资源的客户绝不能依赖带有新URI的'location'元素。如果该元素不存在，则客户端可以将请求重新发出到单独的重定向资源，因为可以使用包含新URI的Location标头重定向对该请求的响应。</target>
        </trans-unit>
        <trans-unit id="629ead9203c19213fba2446477411c8ec459423b" translate="yes" xml:space="preserve">
          <source>Redirection loops</source>
          <target state="translated">重定向环路</target>
        </trans-unit>
        <trans-unit id="aa6efcbd2100faec701e1149fee688eee318d476" translate="yes" xml:space="preserve">
          <source>Redirection loops happen when additional redirections follow the one that has already been followed. In other words, there is a loop that will never be finished and no page will ever be found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fb2905c36033fc913fb566ea3c5bcb1318a9e57" translate="yes" xml:space="preserve">
          <source>Redirection loops happen when successive redirections follow the one that has already been followed. In other words, there is a loop that will never be finished and no page will be found ultimately.</source>
          <target state="translated">当连续的重定向跟随已经被跟随的重定向时,就会发生重定向循环。换句话说,有一个循环永远不会结束,最终也找不到页面。</target>
        </trans-unit>
        <trans-unit id="c7dd5917ae785b261fda27b44b5ec5a2d680b36d" translate="yes" xml:space="preserve">
          <source>Redirection messages</source>
          <target state="translated">信息转发</target>
        </trans-unit>
        <trans-unit id="eeb9caefdf646c7a0ccceccdf48dd3a42d43224b" translate="yes" xml:space="preserve">
          <source>Redirections</source>
          <target state="translated">Redirections</target>
        </trans-unit>
        <trans-unit id="e3bba96caf77bd92cd7d8b0c96235d33da0b22c4" translate="yes" xml:space="preserve">
          <source>Redirections in JavaScript are created by setting a value to the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/location&quot;&gt;&lt;code&gt;window.location&lt;/code&gt;&lt;/a&gt; property and the new page is loaded.</source>
          <target state="translated">通过在&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/location&quot;&gt; &lt;code&gt;window.location&lt;/code&gt; &lt;/a&gt;属性中设置一个值来创建JavaScript中的重定向，并加载新页面。</target>
        </trans-unit>
        <trans-unit id="a86ef1a1aac68fc429a9d0da40fb0b69de3f66e5" translate="yes" xml:space="preserve">
          <source>Redirections in JavaScript are performed by setting a URL string to the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/location&quot;&gt;&lt;code&gt;window.location&lt;/code&gt;&lt;/a&gt; property, loading the new page:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcf937319f333e7df4ec12406025be63bde6549b" translate="yes" xml:space="preserve">
          <source>Redirects</source>
          <target state="translated">Redirects</target>
        </trans-unit>
        <trans-unit id="d7ea66c42cc0d823a76b460690e6ff6566141066" translate="yes" xml:space="preserve">
          <source>Redirects (&lt;code&gt;300&lt;/code&gt;&amp;ndash;&lt;code&gt;399&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a5a9e8fba61c9e52b17ff910bed1acecd687c48" translate="yes" xml:space="preserve">
          <source>Redirects accomplish numerous goals:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37dc3110ba191c2d77df0cde3470992c711d2947" translate="yes" xml:space="preserve">
          <source>Redirects can be set either in the server config file or in the &lt;code&gt;.htaccess&lt;/code&gt; of each directory.</source>
          <target state="translated">可以在服务器配置文件或每个目录的 &lt;code&gt;.htaccess&lt;/code&gt; 中设置重定向。</target>
        </trans-unit>
        <trans-unit id="db1c784524e1b54011a95823026161f7c8517fe0" translate="yes" xml:space="preserve">
          <source>Reference</source>
          <target state="translated">Reference</target>
        </trans-unit>
        <trans-unit id="5d20d0fee3b91643dd8d272ac33d01ca95179d82" translate="yes" xml:space="preserve">
          <source>References</source>
          <target state="translated">References</target>
        </trans-unit>
        <trans-unit id="699b2fb0910ccc7c0854d17a2041a907709ed3c1" translate="yes" xml:space="preserve">
          <source>Referer</source>
          <target state="translated">Referer</target>
        </trans-unit>
        <trans-unit id="7d600afde85bf128bed4081c176fe7edf403b856" translate="yes" xml:space="preserve">
          <source>Referer (RFC 2616)</source>
          <target state="translated">推荐人(RFC 2616)</target>
        </trans-unit>
        <trans-unit id="b1bb97f5316cdb3a06386f7cb3cc6564f44f772d" translate="yes" xml:space="preserve">
          <source>Referer (RFC 7231)</source>
          <target state="translated">推荐人(RFC 7231)</target>
        </trans-unit>
        <trans-unit id="548b0b909e2d1062b7de321059c220fba862be3b" translate="yes" xml:space="preserve">
          <source>Referrer</source>
          <target state="translated">Referrer</target>
        </trans-unit>
        <trans-unit id="e9085bde7a7780a48ca2a79ea2ef1b8e36c397ae" translate="yes" xml:space="preserve">
          <source>Referrer Policy</source>
          <target state="translated">推荐人政策</target>
        </trans-unit>
        <trans-unit id="56d6a82203aab19c5732c260c1b17608ee8ddd53" translate="yes" xml:space="preserve">
          <source>Referrer-Policy</source>
          <target state="translated">Referrer-Policy</target>
        </trans-unit>
        <trans-unit id="81812b5ae7e147b994882094bc1bfac513c944bc" translate="yes" xml:space="preserve">
          <source>Refers to the empty set; that is, no URLs match. The single quotes are required.</source>
          <target state="translated">指的是空集,即没有匹配的URL。单引号是必须的。</target>
        </trans-unit>
        <trans-unit id="5c14c5b41372e5f4d7d2284be0cef39d021c62d6" translate="yes" xml:space="preserve">
          <source>Refers to the origin from which the protected document is being served, including the same URL scheme and port number. You must include the single quotes. Some browsers specifically exclude &lt;code&gt;blob&lt;/code&gt; and &lt;code&gt;filesystem&lt;/code&gt; from source directives. Sites needing to allow these content types can specify them using the Data attribute.</source>
          <target state="translated">指提供受保护文档的来源，包括相同的URL方案和端口号。您必须包括单引号。一些浏览器专门从源指令中排除了 &lt;code&gt;blob&lt;/code&gt; 和 &lt;code&gt;filesystem&lt;/code&gt; 。需要允许这些内容类型的站点可以使用Data属性指定它们。</target>
        </trans-unit>
        <trans-unit id="666b2fc5e19b42683e17cd8e2c18048b27596c23" translate="yes" xml:space="preserve">
          <source>Registration of an HTTP Range Unit MUST include the following fields:

   o  Name

   o  Description

   o  Pointer to specification text

   Values to be added to this namespace require IETF Review (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc5226#section-4.1&quot;&gt;[RFC5226], Section&amp;nbsp;4.1&lt;/a&gt;).</source>
          <target state="translated">HTTP Range Unit的注册必须包括以下字段：o名称o描述o指向规范文本的指针要添加到此命名空间的值需要IETF审核（请参阅 &lt;a href=&quot;https://tools.ietf.org/html/rfc5226#section-4.1&quot;&gt;[RFC5226]，第4.1节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="072544a89921ea204166220b6ecbe57052aede21" translate="yes" xml:space="preserve">
          <source>Registrations MUST include the following fields:

   o  Authentication Scheme Name

   o  Pointer to specification text

   o  Notes (optional)

   Values to be added to this namespace require IETF Review (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc5226#section-4.1&quot;&gt;[RFC5226], Section&amp;nbsp;4.1&lt;/a&gt;).</source>
          <target state="translated">注册必须包括以下字段：o认证方案名称o规范文本的指针o注释（可选）要添加到此命名空间的值需要IETF审核（请参阅 &lt;a href=&quot;https://tools.ietf.org/html/rfc5226#section-4.1&quot;&gt;[RFC5226]，第4.1节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="3900f3dae5507cbea7f7a037aa9cc17206c5b409" translate="yes" xml:space="preserve">
          <source>Registrations MUST include the following fields:

   o  Name

   o  Description

   o  Pointer to specification text

   Names of transfer codings MUST NOT overlap with names of content
   codings (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-3.1.2.1&quot;&gt;Section&amp;nbsp;3.1.2.1 of [RFC7231]&lt;/a&gt;) unless the encoding
   transformation is identical, as is the case for the compression
   codings defined in &lt;a href=&quot;#section-4.2&quot;&gt;Section 4.2&lt;/a&gt;.

   Values to be added to this namespace require IETF Review (see &lt;a href=&quot;https://tools.ietf.org/html/rfc5226#section-4.1&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc5226#section-4.1&quot;&gt;4.1 of [RFC5226]&lt;/a&gt;), and MUST conform to the purpose of transfer coding
   defined in this specification.

   Use of program names for the identification of encoding formats is
   not desirable and is discouraged for future encodings.</source>
          <target state="translated">注册必须包括以下字段：o名称o描述o规范文本的指针传输编码的名称不得与内容编码的名称（&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-3.1.2.1&quot;&gt;[RFC7231]的3.1.2.1节）&lt;/a&gt;重叠，除非编码转换相同，例如&lt;a href=&quot;#section-4.2&quot;&gt;4.2节中&lt;/a&gt;定义的压缩编码。要添加到此命名空间的值需要进行IETF审核（请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc5226#section-4.1&quot;&gt;[RFC5226]的4.1 &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc5226#section-4.1&quot;&gt;节&lt;/a&gt;），并且必须符合本规范中定义的传输编码的目的。不希望将程序名称用于标识编码格式，并且不建议在以后的编码中使用。</target>
        </trans-unit>
        <trans-unit id="d151bc7b242db455dafecdde98d424a7fbe5826b" translate="yes" xml:space="preserve">
          <source>Related headers: &lt;a href=&quot;headers/accept-ranges&quot;&gt;&lt;code&gt;Accept-Ranges&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;headers/range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;headers/content-range&quot;&gt;&lt;code&gt;Content-Range&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;headers/if-range&quot;&gt;&lt;code&gt;If-Range&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;headers/transfer-encoding&quot;&gt;&lt;code&gt;Transfer-Encoding&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">相关标头：&lt;a href=&quot;headers/accept-ranges&quot;&gt; &lt;code&gt;Accept-Ranges&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;headers/range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;headers/content-range&quot;&gt; &lt;code&gt;Content-Range&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;headers/if-range&quot;&gt; &lt;code&gt;If-Range&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;headers/transfer-encoding&quot;&gt; &lt;code&gt;Transfer-Encoding&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3a02133d506baccd9607b7a86c4dbb504734c4a1" translate="yes" xml:space="preserve">
          <source>Related status codes &lt;a href=&quot;status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;status/206&quot;&gt;&lt;code&gt;206&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;status/416&quot;&gt;&lt;code&gt;416&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">相关状态码&lt;a href=&quot;status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;status/206&quot;&gt; &lt;code&gt;206&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;status/416&quot;&gt; &lt;code&gt;416&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2034c07c455dea528b5c044f32d891f3327323d4" translate="yes" xml:space="preserve">
          <source>Related utility functions</source>
          <target state="translated">相关实用功能</target>
        </trans-unit>
        <trans-unit id="e0239139fec07795176258d50edee26a1aa0c492" translate="yes" xml:space="preserve">
          <source>Relaxing the security-model of the Web</source>
          <target state="translated">放宽网络的安全模式。</target>
        </trans-unit>
        <trans-unit id="6924dcad4d5ebf6c89d8fdf2adb56994263c7fe3" translate="yes" xml:space="preserve">
          <source>Rendering engine</source>
          <target state="translated">渲染引擎</target>
        </trans-unit>
        <trans-unit id="048baaee6737f98c6e3617392ee0aa92a328acc5" translate="yes" xml:space="preserve">
          <source>Rendering engine version</source>
          <target state="translated">渲染引擎版本</target>
        </trans-unit>
        <trans-unit id="f5a55dcde49099910df9c704e7c97c70be2ccc80" translate="yes" xml:space="preserve">
          <source>Reorganization of a Web site, with non-GET links/operations.</source>
          <target state="translated">重组网站,非GET链接/操作。</target>
        </trans-unit>
        <trans-unit id="6069aff506484cfe4ca0e6dc53acad55e6682b1e" translate="yes" xml:space="preserve">
          <source>Reorganization of a Web site.</source>
          <target state="translated">重组网站。</target>
        </trans-unit>
        <trans-unit id="d67bc0e6c0c6dc1b32fa80aa1a759051dbd62d55" translate="yes" xml:space="preserve">
          <source>Report-Only header</source>
          <target state="translated">仅仅是报告头</target>
        </trans-unit>
        <trans-unit id="06d6c29bfb10b8b70b6c5a76ac8a545632073eb1" translate="yes" xml:space="preserve">
          <source>Reporting API</source>
          <target state="translated">报告API</target>
        </trans-unit>
        <trans-unit id="e0ff584859d7c7f3e165e23c136c2c4b65edc9dc" translate="yes" xml:space="preserve">
          <source>Reporting directive</source>
          <target state="translated">报告指令</target>
        </trans-unit>
        <trans-unit id="49734955482cddad14d7d6086f6396c10758c821" translate="yes" xml:space="preserve">
          <source>Reporting directives</source>
          <target state="translated">报告指令</target>
        </trans-unit>
        <trans-unit id="6e53788c8a0b65951ac470b7cdcba8ef12feb88d" translate="yes" xml:space="preserve">
          <source>Reporting directives control the reporting process of CSP violations. See also the &lt;a href=&quot;content-security-policy-report-only&quot;&gt;&lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">报告指令控制违反CSP的报告过程。另请参阅&lt;a href=&quot;content-security-policy-report-only&quot;&gt; &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; &lt;/a&gt;标头。</target>
        </trans-unit>
        <trans-unit id="faafcc65691f4495ef2dd9f54e8f8dbc76133274" translate="yes" xml:space="preserve">
          <source>Representation header fields provide metadata about the
   representation.  When a message includes a payload body, the
   representation header fields describe how to interpret the
   representation data enclosed in the payload body.  In a response to a
   HEAD request, the representation header fields describe the
   representation data that would have been enclosed in the payload body
   if the same request had been a GET.

   The following header fields convey representation metadata:

   +-------------------+-----------------+
   | Header Field Name | Defined in...   |
   +-------------------+-----------------+
   | Content-Type      | &lt;a href=&quot;#section-3.1.1.5&quot;&gt;Section 3.1.1.5&lt;/a&gt; |
   | Content-Encoding  | &lt;a href=&quot;#section-3.1.2.2&quot;&gt;Section 3.1.2.2&lt;/a&gt; |
   | Content-Language  | &lt;a href=&quot;#section-3.1.3.2&quot;&gt;Section 3.1.3.2&lt;/a&gt; |
   | Content-Location  | &lt;a href=&quot;#section-3.1.4.2&quot;&gt;Section 3.1.4.2&lt;/a&gt; |
   +-------------------+-----------------+</source>
          <target state="translated">表示形式标题字段提供有关表示形式的元数据。当消息包含有效载荷主体时，表示形式报头字段描述如何解释有效载荷主体中包含的表示形式数据。在对HEAD请求的响应中，表示形式标头字段描述了如果相同的请求是GET的情况下，将被封装在有效载荷主体中的表示形式数据。以下标头字段传达表示形式的元数据：+ ------------------- + ----------------- + |标头字段名称|定义于... | + ------------------- + ----------------- + |内容类型| &lt;a href=&quot;#section-3.1.1.5&quot;&gt;第3.1.1.5节&lt;/a&gt; | |内容编码| &lt;a href=&quot;#section-3.1.2.2&quot;&gt;第3.1.2.2节&lt;/a&gt; | |内容语言| &lt;a href=&quot;#section-3.1.3.2&quot;&gt;第3.1.3.2节&lt;/a&gt;| | 内容位置| &lt;a href=&quot;#section-3.1.4.2&quot;&gt;第3.1.4.2节&lt;/a&gt; | + ------------------- + ----------------- +</target>
        </trans-unit>
        <trans-unit id="e405e17158b8b239987e79f57e2f7771ef0097af" translate="yes" xml:space="preserve">
          <source>Representations (RFC 7231)</source>
          <target state="translated">表征(RFC 7231)</target>
        </trans-unit>
        <trans-unit id="4aed03cac49d5e43da4e855a967286931a4d621a" translate="yes" xml:space="preserve">
          <source>Request</source>
          <target state="translated">Request</target>
        </trans-unit>
        <trans-unit id="92f88e2c8e9bb975a09d205785b581b72223d69c" translate="yes" xml:space="preserve">
          <source>Request (RFC 2616)</source>
          <target state="translated">请求(RFC 2616)</target>
        </trans-unit>
        <trans-unit id="209107c4e6e87baa9562058df6689267d77f72ab" translate="yes" xml:space="preserve">
          <source>Request and Response messages MAY transfer an entity if not otherwise
   restricted by the request method or response status code. An entity
   consists of entity-header fields and an entity-body, although some
   responses will only include the entity-headers.

   In this section, both sender and recipient refer to either the client
   or the server, depending on who sends and who receives the entity.</source>
          <target state="translated">如果不受请求方法或响应状态码的限制,请求和响应消息可以传输实体。一个实体由实体头字段和实体主体组成,尽管有些响应只包括实体头。在本节中,发送者和接收者都指客户端或服务器,这取决于谁发送和谁接收实体。</target>
        </trans-unit>
        <trans-unit id="b4ccb0ae69ff9044ffa521ca4c16ab4e8a2bb624" translate="yes" xml:space="preserve">
          <source>Request context</source>
          <target state="translated">请求背景</target>
        </trans-unit>
        <trans-unit id="6ee7b5c7d1970d29bd49eb9d029bff7b4b9637c8" translate="yes" xml:space="preserve">
          <source>Request entity is larger than limits defined by server; the server might close the connection or return an &lt;code&gt;Retry-After&lt;/code&gt; header field.</source>
          <target state="translated">请求实体大于服务器定义的限制；服务器可能会关闭连接或返回 &lt;code&gt;Retry-After&lt;/code&gt; 标头字段。</target>
        </trans-unit>
        <trans-unit id="5b3e3eaae6a46abf6af6e09d0d998a3ceec713b2" translate="yes" xml:space="preserve">
          <source>Request has body</source>
          <target state="translated">请求有正文</target>
        </trans-unit>
        <trans-unit id="a9528878e11c1033e6bd63ba8721a8f88c91e374" translate="yes" xml:space="preserve">
          <source>Request header</source>
          <target state="translated">请求头</target>
        </trans-unit>
        <trans-unit id="30eaa32f64dd1274f348ded1be63b905756fabff" translate="yes" xml:space="preserve">
          <source>Request methods</source>
          <target state="translated">请求方法</target>
        </trans-unit>
        <trans-unit id="3437c4d523fcec9c5dbe6ca25b313e8b0c9faa07" translate="yes" xml:space="preserve">
          <source>Request methods are considered &quot;safe&quot; if their defined semantics are
   essentially read-only; i.e., the client does not request, and does
   not expect, any state change on the origin server as a result of
   applying a safe method to a target resource.  Likewise, reasonable
   use of a safe method is not expected to cause any harm, loss of
   property, or unusual burden on the origin server. 

   This definition of safe methods does not prevent an implementation
   from including behavior that is potentially harmful, that is not
   entirely read-only, or that causes side effects while invoking a safe
   method.  What is important, however, is that the client did not
   request that additional behavior and cannot be held accountable for
   it.  For example, most servers append request information to access
   log files at the completion of every response, regardless of the
   method, and that is considered safe even though the log storage might
   become full and crash the server.  Likewise, a safe request initiated
   by selecting an advertisement on the Web will often have the side
   effect of charging an advertising account.

   Of the request methods defined by this specification, the GET, HEAD,
   OPTIONS, and TRACE methods are defined to be safe.

   The purpose of distinguishing between safe and unsafe methods is to
   allow automated retrieval processes (spiders) and cache performance
   optimization (pre-fetching) to work without fear of causing harm.  In
   addition, it allows a user agent to apply appropriate constraints on
   the automated use of unsafe methods when processing potentially
   untrusted content.

   A user agent SHOULD distinguish between safe and unsafe methods when
   presenting potential actions to a user, such that the user can be
   made aware of an unsafe action before it is requested.

   When a resource is constructed such that parameters within the
   effective request URI have the effect of selecting an action, it is
   the resource owner's responsibility to ensure that the action is
   consistent with the request method semantics.  For example, it is
   common for Web-based content editing software to use actions within
   query parameters, such as &quot;page?do=delete&quot;.  If the purpose of such a
   resource is to perform an unsafe action, then the resource owner MUST
   disable or disallow that action when it is accessed using a safe
   request method.  Failure to do so will result in unfortunate side
   effects when automated processes perform a GET on every URI reference
   for the sake of link maintenance, pre-fetching, building a search
   index, etc.</source>
          <target state="translated">如果请求方法所定义的语义基本上是只读的,那么它们就被认为是 &quot;安全的&quot;;也就是说,客户机不会请求,也不会期望原服务器因对目标资源应用安全方法而发生任何状态变化。同样,合理使用安全方法也不会对源服务器造成任何伤害、财产损失或异常负担。安全方法的这个定义并不妨碍实现在调用安全方法时包含有潜在危害的行为、不完全只读的行为或会引起副作用的行为。然而,重要的是,客户端并没有请求该额外的行为,不能因此而承担责任。例如,大多数服务器在每次响应完成时都会附加请求信息来访问日志文件,而不管是什么方法,这被认为是安全的,即使日志存储可能会变得满,并使服务器崩溃。同样,在Web上选择广告发起的安全请求,往往会有收取广告账户费用的副作用。在本规范定义的请求方法中,GET、HEAD、OPTIONS和TRACE方法被定义为安全的。区分安全方法和不安全方法的目的是为了让自动检索过程(蜘蛛)和缓存性能优化(预取)工作时不必担心造成伤害。此外,它允许用户代理在处理潜在的不信任内容时,对不安全方法的自动使用施加适当的限制。用户代理在向用户呈现潜在的操作时,应该区分安全和不安全的方法,这样可以在请求不安全的操作之前让用户意识到它。当资源的构造使得有效请求URI中的参数具有选择动作的效果时,资源所有者有责任确保动作与请求方法语义一致。例如,基于Web的内容编辑软件通常在查询参数中使用动作,如 &quot;page?do=delete&quot;。如果这种资源的目的是执行不安全的操作,那么当使用安全请求方法访问该资源时,资源所有者必须禁用或禁止该操作。如果不这样做,当自动进程为了维护链接、预获取、建立搜索索引等原因对每个URI引用执行GET时,将导致不幸的副作用。</target>
        </trans-unit>
        <trans-unit id="e9b6ad5f3d071161c8b3a3dfe4a105628b443960" translate="yes" xml:space="preserve">
          <source>Request methods can be defined as &quot;cacheable&quot; to indicate that
   responses to them are allowed to be stored for future reuse; for
   specific requirements see [&lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC7234&lt;/a&gt;].  In general, safe methods that
   do not depend on a current or authoritative response are defined as
   cacheable; this specification defines GET, HEAD, and POST as
   cacheable, although the overwhelming majority of cache
   implementations only support GET and HEAD.</source>
          <target state="translated">可以将请求方法定义为&amp;ldquo;可缓存的&amp;rdquo;，以指示允许存储对它们的响应以供将来重用。有关特定要求，请参见[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC7234&lt;/a&gt; ]。通常，将不依赖于当前响应或权威响应的安全方法定义为可缓存；尽管绝大多数缓存实现仅支持GET和HEAD，但本规范将GET，HEAD和POST定义为可缓存的。</target>
        </trans-unit>
        <trans-unit id="0fe2385cde5e7e860a739c3f7a915be25d6759e0" translate="yes" xml:space="preserve">
          <source>Request requires preflight, which is disallowed to follow cross-origin redirect</source>
          <target state="translated">请求需要进行预检,不允许进行跨源重定向。</target>
        </trans-unit>
        <trans-unit id="503b534d1cc7a82dc13ef87bb3f5b88cfd30bfc5" translate="yes" xml:space="preserve">
          <source>Request smuggling ([&lt;a href=&quot;#ref-Linhart&quot;&gt;Linhart&lt;/a&gt;]) is a technique that exploits
   differences in protocol parsing among various recipients to hide
   additional requests (which might otherwise be blocked or disabled by
   policy) within an apparently harmless request.  Like response
   splitting, request smuggling can lead to a variety of attacks on HTTP
   usage.

   This specification has introduced new requirements on request
   parsing, particularly with regard to message framing in
   &lt;a href=&quot;#section-3.3.3&quot;&gt;Section 3.3.3&lt;/a&gt;, to reduce the effectiveness of request smuggling.</source>
          <target state="translated">请求走私（[ &lt;a href=&quot;#ref-Linhart&quot;&gt;Linhart&lt;/a&gt; ]）是一种利用各种收件人之间协议解析差异的技术，以将其他请求（否则可能被策略阻止或禁用）隐藏在表面上无害的请求中。像响应拆分一样，请求走私可能导致对HTTP使用的各种攻击。该规范引入了对请求解析的新要求，尤其是在&lt;a href=&quot;#section-3.3.3&quot;&gt;第3.3.3节中的&lt;/a&gt;消息框架方面 ，以降低请求走私的有效性。</target>
        </trans-unit>
        <trans-unit id="4f2b78b6c4f7e212360888da9e743888ae19dbfe" translate="yes" xml:space="preserve">
          <source>Requesting a specific range from a server</source>
          <target state="translated">从服务器请求一个特定的范围</target>
        </trans-unit>
        <trans-unit id="3e1c4325f552db0dd41e8ebaad689edea63a1814" translate="yes" xml:space="preserve">
          <source>Requesting data from a server in different formats</source>
          <target state="translated">以不同格式向服务器请求数据</target>
        </trans-unit>
        <trans-unit id="65f9d517e2876f465c9079ef7d58987b6d7133b5" translate="yes" xml:space="preserve">
          <source>Requesting the first 500 and last 500 bytes of the file. The request may be rejected by the server if the ranges overlap.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a63fe83db36a0c43261f124bbf4931e1feeed295" translate="yes" xml:space="preserve">
          <source>Requesting three ranges from the file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7194e6a0d0b838382b202853e7c198d693fbabc" translate="yes" xml:space="preserve">
          <source>Requests</source>
          <target state="translated">Requests</target>
        </trans-unit>
        <trans-unit id="42f2929bd33823bdf38ee7942319e10575f276bb" translate="yes" xml:space="preserve">
          <source>Requests consists of the following elements:</source>
          <target state="translated">请求由以下内容组成:</target>
        </trans-unit>
        <trans-unit id="407b9cd287af007f637b486aaa36862498225921" translate="yes" xml:space="preserve">
          <source>Requests to the &lt;code&gt;http://&lt;/code&gt; version of your site will redirect to the &lt;code&gt;https://&lt;/code&gt; version of your site.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e82d9e92edcff98536ce51f4852910ccc962b156" translate="yes" xml:space="preserve">
          <source>Requests with credentials</source>
          <target state="translated">有全权证书的请求</target>
        </trans-unit>
        <trans-unit id="9472781a408847ad355c057726227036836eb352" translate="yes" xml:space="preserve">
          <source>Require preflight for non-standard CORS-safelisted request headers Accept, Accept-Language, and Content-Language</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="896b8e09c2c51403430f397ed2a914d36c173299" translate="yes" xml:space="preserve">
          <source>Requirements for cookies across the EU are defined in &lt;a href=&quot;http://eur-lex.europa.eu/legal-content/EN/TXT/?uri=CELEX:32009L0136&quot;&gt;Directive 2009/136/EC&lt;/a&gt; of the European Parliament and came into effect on 25 May 2011. A directive is not a law by itself, but a requirement for EU member states to put laws in place that meet the requirements of the directive. The actual laws can differ from country to country.</source>
          <target state="translated">欧洲议会的&lt;a href=&quot;http://eur-lex.europa.eu/legal-content/EN/TXT/?uri=CELEX:32009L0136&quot;&gt;指令2009/136 / EC&lt;/a&gt;中定义了整个欧盟对Cookie的要求，该要求于2011年5月25日生效。指令本身并不是一项法律，而是要求欧盟成员国制定相应的法律，符合指令的要求。实际法律因国家/地区而异。</target>
        </trans-unit>
        <trans-unit id="58efddfc035f1f01ebc5a45ea6ef85eae9088fde" translate="yes" xml:space="preserve">
          <source>Requires &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/SRI&quot;&gt;SRI&lt;/a&gt; for both, scripts and style sheets.</source>
          <target state="translated">脚本和样式表都需要&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/SRI&quot;&gt;SRI&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="33eafda8cd41b807493e212a681cb068a92c17e4" translate="yes" xml:space="preserve">
          <source>Requires &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/SRI&quot;&gt;SRI&lt;/a&gt; for scripts.</source>
          <target state="translated">脚本需要&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/SRI&quot;&gt;SRI&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a71171ac0001f4cd89b14fa7a98d39f88be17a2d" translate="yes" xml:space="preserve">
          <source>Requires &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/SRI&quot;&gt;SRI&lt;/a&gt; for style sheets.</source>
          <target state="translated">样式表需要&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/SRI&quot;&gt;SRI&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1c018354f46e0590ba0dbb9b1c4723dd35f22f66" translate="yes" xml:space="preserve">
          <source>Requires a sample of the violating code to be included in the violation report.</source>
          <target state="translated">要求在违规报告中附上违规代码的样本。</target>
        </trans-unit>
        <trans-unit id="3a775f4a3f060d56b00223f3382dbb2cdc761a0e" translate="yes" xml:space="preserve">
          <source>Requires the use of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/SRI&quot;&gt;SRI&lt;/a&gt; for scripts or styles on the page.</source>
          <target state="translated">要求对页面上的脚本或样式使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/SRI&quot;&gt;SRI&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2a5e4228f9aa6fc13b0464eaaa4225d798aeffa9" translate="yes" xml:space="preserve">
          <source>Requiring revalidation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9991b4d153c5704ddc24858d8325cfbcfbf453af" translate="yes" xml:space="preserve">
          <source>Reserved for use as a placeholder in examples showing how to use MIME types. These should never be used outside of sample code listings and documentation. &lt;code&gt;example&lt;/code&gt; can also be used as a subtype; for instance, in an example related to working with audio on the web, the MIME type &lt;code&gt;audio/example&lt;/code&gt; can be used to indicate that the type is a placeholder and should be replaced with an appropriate one when using the code in the real world.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54f4777a2c07551392e54e261d880e24efe04a2b" translate="yes" xml:space="preserve">
          <source>Resolves the given DNS hostname into an IP address, and returns it in the dot-separated format as a string.</source>
          <target state="translated">将给定的DNS主机名解析为IP地址,并以点分隔格式返回为字符串。</target>
        </trans-unit>
        <trans-unit id="54d7b16d6f25ff228207d06007bc79d8c49dabb8" translate="yes" xml:space="preserve">
          <source>Resource Timing API</source>
          <target state="translated">资源定时API</target>
        </trans-unit>
        <trans-unit id="d64022b8c69b24949fe20baf510c31745fe844e9" translate="yes" xml:space="preserve">
          <source>Resource Timing Level 3&lt;br/&gt;&lt;small&gt;The definition of 'Timing-Allow-Origin' in that specification.&lt;/small&gt;</source>
          <target state="translated">资源计时级别3 &lt;br/&gt;&lt;small&gt;该规范中&amp;ldquo;计时允许来源&amp;rdquo;的定义。&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="798dcb46eb38b768887b1e2f745c95d93e85e984" translate="yes" xml:space="preserve">
          <source>Resource URLs</source>
          <target state="translated">资源URL</target>
        </trans-unit>
        <trans-unit id="7de6ba1f289521322fe08eee24de6e4e8832b3bf" translate="yes" xml:space="preserve">
          <source>Resource URLs are composed of two parts: a prefix (&lt;code&gt;resource:&lt;/code&gt;), and a URL pointing to the resource you want to load:</source>
          <target state="translated">资源URL由两部分组成：前缀（ &lt;code&gt;resource:&lt;/code&gt; ：）和指向您要加载的资源的URL：</target>
        </trans-unit>
        <trans-unit id="ad91d18e5dc789f46a10914125180d778fe1dd92" translate="yes" xml:space="preserve">
          <source>Resource URLs, URLs prefixed with the &lt;code&gt;resource:&lt;/code&gt; scheme, are used by Firefox and Firefox browser extensions to load resources internally, but some of the information is available to sites the browser connects to as well.</source>
          <target state="translated">Firefox和Firefox浏览器扩展使用资源URL（以 &lt;code&gt;resource:&lt;/code&gt; 方案为前缀的URL）在内部加载资源，但是某些信息也可用于浏览器连接的站点。</target>
        </trans-unit>
        <trans-unit id="2caf2a391127495a2a503e4c2574c5bbaee93687" translate="yes" xml:space="preserve">
          <source>Resource URLs, those prefixed with the &lt;code&gt;resource&lt;/code&gt; scheme are used by Firefox and Firefox browser extensions to load resources internally, but is also available to some sites the browser connects to as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f9dad94a76fa176febfa455dbb8cce0fd95a809" translate="yes" xml:space="preserve">
          <source>Resources and URIs</source>
          <target state="translated">资源和URI</target>
        </trans-unit>
        <trans-unit id="aeb4705a43eda0152e9211513d37d2ebc74577ed" translate="yes" xml:space="preserve">
          <source>Resources and specifications</source>
          <target state="translated">资源和规格</target>
        </trans-unit>
        <trans-unit id="6e617e4fc9da3de9693eac5990613543b86c63f9" translate="yes" xml:space="preserve">
          <source>Response</source>
          <target state="translated">Response</target>
        </trans-unit>
        <trans-unit id="b91c0a7d61c2a326eb2fb877b8d8d75077f4c7c5" translate="yes" xml:space="preserve">
          <source>Response (RFC 2616)</source>
          <target state="translated">响应(RFC 2616)</target>
        </trans-unit>
        <trans-unit id="62bca1e6a1a2f5863671a7fa9d7845857288f9e2" translate="yes" xml:space="preserve">
          <source>Response codes</source>
          <target state="translated">响应代码</target>
        </trans-unit>
        <trans-unit id="f84e739be38db39024655ad83fa5e6bb72e53942" translate="yes" xml:space="preserve">
          <source>Response context</source>
          <target state="translated">响应背景</target>
        </trans-unit>
        <trans-unit id="7b398df4add831e6b05ee4c0b368c39fd3f5bc77" translate="yes" xml:space="preserve">
          <source>Response header</source>
          <target state="translated">响应头</target>
        </trans-unit>
        <trans-unit id="9b7e02a5516eb784c59460a7b87383f30bdd1c7d" translate="yes" xml:space="preserve">
          <source>Response header fields can supply control data that supplements the
   status code, directs caching, or instructs the client where to go
   next.

   +-------------------+--------------------------+
   | Header Field Name | Defined in...            |
   +-------------------+--------------------------+
   | Age               | &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.1&quot;&gt;Section&amp;nbsp;5.1 of [RFC7234]&lt;/a&gt; |
   | Cache-Control     | &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2&quot;&gt;Section&amp;nbsp;5.2 of [RFC7234]&lt;/a&gt; |
   | Expires           | &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.3&quot;&gt;Section&amp;nbsp;5.3 of [RFC7234]&lt;/a&gt; |
   | Date              | &lt;a href=&quot;#section-7.1.1.2&quot;&gt;Section 7.1.1.2&lt;/a&gt;          |
   | Location          | &lt;a href=&quot;#section-7.1.2&quot;&gt;Section 7.1.2&lt;/a&gt;            |
   | Retry-After       | &lt;a href=&quot;#section-7.1.3&quot;&gt;Section 7.1.3&lt;/a&gt;            |
   | Vary              | &lt;a href=&quot;#section-7.1.4&quot;&gt;Section 7.1.4&lt;/a&gt;            |
   | Warning           | &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.5&quot;&gt;Section&amp;nbsp;5.5 of [RFC7234]&lt;/a&gt; |
   +-------------------+--------------------------+</source>
          <target state="translated">响应标头字段可以提供补充状态代码，控制缓存或指示客户端下一步操作的控制数据。 + ------------------- + -------------------------- + |标头字段名称|定义于... | + ------------------- + -------------------------- + |年龄| &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.1&quot;&gt;[RFC7234]的5.1节&lt;/a&gt; | |缓存控制| &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2&quot;&gt;[RFC7234]的5.2节&lt;/a&gt; | |过期| &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.3&quot;&gt;[RFC7234]的5.3节&lt;/a&gt; | |日期&lt;a href=&quot;#section-7.1.1.2&quot;&gt;第7.1.1.2节&lt;/a&gt; | |位置| &lt;a href=&quot;#section-7.1.2&quot;&gt;第7.1.2节&lt;/a&gt; | |重试后| &lt;a href=&quot;#section-7.1.3&quot;&gt;第7.1.3节&lt;/a&gt; | |变化| &lt;a href=&quot;#section-7.1.4&quot;&gt;第7.1.4节&lt;/a&gt; | | 警告| &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.5&quot;&gt;[RFC7234]第5.5节&lt;/a&gt; | + ------------------- + -------------------------- +</target>
        </trans-unit>
        <trans-unit id="c8aa6a36289563928821fce4669ae4ff1ccded70" translate="yes" xml:space="preserve">
          <source>Response is Stale</source>
          <target state="translated">响应是陈旧的</target>
        </trans-unit>
        <trans-unit id="5633194dd26604f7ddba594d72f55184513f1b60" translate="yes" xml:space="preserve">
          <source>Response splitting (a.k.a, CRLF injection) is a common technique,
   used in various attacks on Web usage, that exploits the line-based
   nature of HTTP message framing and the ordered association of
   requests to responses on persistent connections [&lt;a href=&quot;#ref-Klein&quot;&gt;Klein&lt;/a&gt;].  This
   technique can be particularly damaging when the requests pass through
   a shared cache.

   Response splitting exploits a vulnerability in servers (usually
   within an application server) where an attacker can send encoded data
   within some parameter of the request that is later decoded and echoed
   within any of the response header fields of the response.  If the
   decoded data is crafted to look like the response has ended and a 

   subsequent response has begun, the response has been split and the
   content within the apparent second response is controlled by the
   attacker.  The attacker can then make any other request on the same
   persistent connection and trick the recipients (including
   intermediaries) into believing that the second half of the split is
   an authoritative answer to the second request.

   For example, a parameter within the request-target might be read by
   an application server and reused within a redirect, resulting in the
   same parameter being echoed in the Location header field of the
   response.  If the parameter is decoded by the application and not
   properly encoded when placed in the response field, the attacker can
   send encoded CRLF octets and other content that will make the
   application's single response look like two or more responses.

   A common defense against response splitting is to filter requests for
   data that looks like encoded CR and LF (e.g., &quot;%0D&quot; and &quot;%0A&quot;).
   However, that assumes the application server is only performing URI
   decoding, rather than more obscure data transformations like charset
   transcoding, XML entity translation, base64 decoding, sprintf
   reformatting, etc.  A more effective mitigation is to prevent
   anything other than the server's core protocol libraries from sending
   a CR or LF within the header section, which means restricting the
   output of header fields to APIs that filter for bad octets and not
   allowing application servers to write directly to the protocol
   stream.</source>
          <target state="translated">响应拆分（也称为CRLF注入）是一种常见的技术，用于对Web使用的各种攻击中，它利用HTTP消息框架的基于行的本质以及对持久连接的响应与请求的有序关联[ &lt;a href=&quot;#ref-Klein&quot;&gt;Klein&lt;/a&gt;]。当请求通过共享缓存时，此技术可能尤其有害。响应拆分利用服务器中（通常是应用程序服务器中）的漏洞，攻击者可以在该漏洞中发送请求的某个参数内的编码数据，该数据随后在响应的任何响应头字段中解码并回显。如果将解码后的数据制作为看起来像响应已经结束，并且随后的响应已经开始，则响应已被拆分，攻击者控制明显的第二响应中的内容。然后，攻击者可以在相同的持久连接上发出任何其他请求，并欺骗接收者（包括中介），使他们相信拆分的后半部分是对第二个请求的权威性回答。例如，请求目标中的参数可能会被应用程序服务器读取并在重定向中重用，导致在响应的&amp;ldquo;位置&amp;rdquo;标头字段中回显相同的参数。如果参数由应用程序解码并且放在响应字段中时未正确编码，则攻击者可以发送已编码的CRLF八位位组和其他内容，这将使应用程序的单个响应看起来像两个或多个响应。防止响应拆分的常见防御措施是过滤对看起来像已编码的CR和LF的数据的请求（例如，&amp;ldquo;％0D&amp;rdquo;和&amp;ldquo;％0A&amp;rdquo;）。但是，这假设应用服务器仅执行URI解码，而不是进行字符集转码，XML实体翻译，base64解码，sprintf重新格式化等。更有效的缓解措施是防止服务器核心协议库以外的任何内容在标头部分中发送CR或LF，这意味着将标头字段的输出限制为可过滤错误八位位组且不允许应用程序使用的API服务器直接写入协议流。</target>
        </trans-unit>
        <trans-unit id="d4c531a6385991e6bb4b7c4878657728c7803131" translate="yes" xml:space="preserve">
          <source>Response status codes</source>
          <target state="translated">响应状态代码</target>
        </trans-unit>
        <trans-unit id="3de7a37046e38dd56ec505ba9650a90475b3ca79" translate="yes" xml:space="preserve">
          <source>Response status codes beginning with the digit &quot;5&quot; indicate cases in
   which the server is aware that it has erred or is incapable of
   performing the request. Except when responding to a HEAD request, the
   server SHOULD include an entity containing an explanation of the
   error situation, and whether it is a temporary or permanent
   condition. User agents SHOULD display any included entity to the
   user. These response codes are applicable to any request method.</source>
          <target state="translated">以数字 &quot;5 &quot;开头的响应状态码表示服务器知道自己出错或无法执行请求的情况。除了响应HEAD请求时,服务器应该包含一个实体,其中包含对错误情况的解释,以及它是暂时的还是永久的条件。用户代理应该向用户显示任何包含的实体。这些响应代码适用于任何请求方法。</target>
        </trans-unit>
        <trans-unit id="83bdd15fd3efbd39156bcb4a7d8c4cbc95551582" translate="yes" xml:space="preserve">
          <source>Response to an &lt;a href=&quot;methods/options&quot;&gt;&lt;code&gt;OPTIONS&lt;/code&gt;&lt;/a&gt; request (which is the preflight request), including sending necessary values with &lt;a href=&quot;headers/access-control-allow-methods&quot;&gt;&lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;headers/access-control-allow-headers&quot;&gt;&lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt;&lt;/a&gt; (if any additional headers are needed in order for the application to work), and, if credentials are necessary for this resource, &lt;a href=&quot;headers/access-control-allow-credentials&quot;&gt;&lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">对&lt;a href=&quot;methods/options&quot;&gt; &lt;code&gt;OPTIONS&lt;/code&gt; &lt;/a&gt;请求（即预检请求）的响应，包括使用&lt;a href=&quot;headers/access-control-allow-methods&quot;&gt; &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;headers/access-control-allow-headers&quot;&gt; &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; &lt;/a&gt;（如果需要任何其他头才能使应用程序正常工作）发送必要的值，以及，如果此资源需要凭据，则为&lt;a href=&quot;headers/access-control-allow-credentials&quot;&gt; &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dadf3ea7de46798a782a6a436390eec73bf559b0" translate="yes" xml:space="preserve">
          <source>Response to the actual request, including handling &lt;code&gt;POST&lt;/code&gt; data, etc.</source>
          <target state="translated">对实际请求的响应，包括处理 &lt;code&gt;POST&lt;/code&gt; 数据等</target>
        </trans-unit>
        <trans-unit id="eca3a297d123fc40900d58016705e489702b5ebd" translate="yes" xml:space="preserve">
          <source>Response-only headers</source>
          <target state="translated">纯响应的标题</target>
        </trans-unit>
        <trans-unit id="633f6e8b851aad01759e04e23cfe5188859a4d5b" translate="yes" xml:space="preserve">
          <source>Responses</source>
          <target state="translated">Responses</target>
        </trans-unit>
        <trans-unit id="d8af98670003f4df54578c7641a8970d7403de87" translate="yes" xml:space="preserve">
          <source>Responses consist of the following elements:</source>
          <target state="translated">答复包括以下内容:</target>
        </trans-unit>
        <trans-unit id="3b1f5e9b4019ed86ef95e3eb735acf435207ec4e" translate="yes" xml:space="preserve">
          <source>Responses other than &lt;a href=&quot;methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; if something suitable for use as a cache key is defined.</source>
          <target state="translated">如果定义了适合用作缓存键的内容，则返回的响应不是&lt;a href=&quot;methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="03a2ed7eea8ee322b3125e461709f17a765da78d" translate="yes" xml:space="preserve">
          <source>Restrict a site from using sensitive APIs like camera or microphone.</source>
          <target state="translated">限制网站使用敏感的API,如摄像头或麦克风。</target>
        </trans-unit>
        <trans-unit id="a7df26a7033a2ab83d3ca306e3a5d1318fad2e5a" translate="yes" xml:space="preserve">
          <source>Restrict access to certain URIs</source>
          <target state="translated">限制对某些URI的访问</target>
        </trans-unit>
        <trans-unit id="8918d7b0ef8cf023a0a02c7f4d3a7e80b8e0bd64" translate="yes" xml:space="preserve">
          <source>Restrict access to cookies</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4117c2bf4d89b600064f4f9d06f852ac1a3ae10f" translate="yes" xml:space="preserve">
          <source>Restricting access with Apache and basic authentication</source>
          <target state="translated">使用Apache和基本认证限制访问</target>
        </trans-unit>
        <trans-unit id="461bffebbe59da668a737629925f899f93ff2412" translate="yes" xml:space="preserve">
          <source>Restricting access with nginx and basic authentication</source>
          <target state="translated">使用nginx和基本认证限制访问。</target>
        </trans-unit>
        <trans-unit id="5e935b66a20bae038fe32dd13f6fc11359152943" translate="yes" xml:space="preserve">
          <source>Restricts the URLs to which a document can initiate navigation by any means, including &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form&quot;&gt;&lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt;&lt;/a&gt; (if &lt;a href=&quot;content-security-policy/form-action&quot;&gt;&lt;code&gt;form-action&lt;/code&gt;&lt;/a&gt; is not specified), &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a&quot;&gt;&lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/location&quot;&gt;&lt;code&gt;window.location&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/open&quot;&gt;&lt;code&gt;window.open&lt;/code&gt;&lt;/a&gt;, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="764a16b3f8fb29997b690d201939e38d6d70edd4" translate="yes" xml:space="preserve">
          <source>Restricts the URLs to which a document can navigate by any means (a, form, window.location, window.open, etc.)</source>
          <target state="translated">限制文档可以通过任何方式导航到的URL(a,form,window.location,window.open等)</target>
        </trans-unit>
        <trans-unit id="a6b9ea9002b18b6b31923bd6067c94ff74e5664b" translate="yes" xml:space="preserve">
          <source>Restricts the URLs which can be loaded using script interfaces</source>
          <target state="translated">限制可以使用脚本接口加载的URL。</target>
        </trans-unit>
        <trans-unit id="a088abbeea65fe12b4006ee4be76da1a0764ac75" translate="yes" xml:space="preserve">
          <source>Restricts the URLs which can be used as the target of a form submissions from a given context.</source>
          <target state="translated">限制在给定的上下文中可以作为表单提交目标的URL。</target>
        </trans-unit>
        <trans-unit id="4222ed3b88e187751d0f547eca5261acc886b9c0" translate="yes" xml:space="preserve">
          <source>Restricts the URLs which can be used in a document's &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base&quot;&gt;&lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt;&lt;/a&gt; element.</source>
          <target state="translated">限制可以在文档的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base&quot;&gt; &lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt; &lt;/a&gt;元素中使用的URL 。</target>
        </trans-unit>
        <trans-unit id="7afcc35a5e47466a95fb1a0c4cf65338cc5b6518" translate="yes" xml:space="preserve">
          <source>Restricts the set of plugins that can be embedded into a document by limiting the types of resources which can be loaded.</source>
          <target state="translated">通过限制可以加载的资源类型来限制可以嵌入到文档中的插件集。</target>
        </trans-unit>
        <trans-unit id="dedece9fd5695df933056cbe96d25f6b3069f79b" translate="yes" xml:space="preserve">
          <source>Retry-After</source>
          <target state="translated">Retry-After</target>
        </trans-unit>
        <trans-unit id="0c9f6f19959bb087b887f8153dbc882bf36b5be0" translate="yes" xml:space="preserve">
          <source>Retry-After (RFC 2616)</source>
          <target state="translated">重试后(RFC 2616)</target>
        </trans-unit>
        <trans-unit id="4bbd975267207d617ce8ac55243c4e2435f8d973" translate="yes" xml:space="preserve">
          <source>Retry-After (RFC 7231)</source>
          <target state="translated">重试后(RFC 7231)</target>
        </trans-unit>
        <trans-unit id="b3d51d173748120ed51dbedce115ff294ba9c89e" translate="yes" xml:space="preserve">
          <source>Return &quot;permission denied&quot; for JavaScript APIs that require user permission grants.</source>
          <target state="translated">对于需要用户权限授予的JavaScript API,返回 &quot;权限拒绝&quot;。</target>
        </trans-unit>
        <trans-unit id="927efd592a21c92cfe7587e9cfb7e85413562cbe" translate="yes" xml:space="preserve">
          <source>Return &lt;code&gt;false&lt;/code&gt; or error from an existing JavaScript API that provides access to feature.</source>
          <target state="translated">从提供功能访问权限的现有JavaScript API 返回 &lt;code&gt;false&lt;/code&gt; 或error。</target>
        </trans-unit>
        <trans-unit id="846e30137de34dc6b54690d1b47a21341be03ee6" translate="yes" xml:space="preserve">
          <source>Return value format</source>
          <target state="translated">返回值格式</target>
        </trans-unit>
        <trans-unit id="0ecdf9bf4172ac40a4c998cc081e4e01cca34349" translate="yes" xml:space="preserve">
          <source>Returning Values from Forms: multipart/form-data</source>
          <target state="translated">从表单中返回值:multipart/form-data。</target>
        </trans-unit>
        <trans-unit id="a5275c587d1874bd04ab3b907533a732dac13af3" translate="yes" xml:space="preserve">
          <source>Returns a string describing the configuration. The format of this string is defined in &lt;strong&gt;return value format&lt;/strong&gt; below.</source>
          <target state="translated">返回描述配置的字符串。该字符串的&lt;strong&gt;格式&lt;/strong&gt;在下面的&lt;strong&gt;返回值格式&lt;/strong&gt;中定义。</target>
        </trans-unit>
        <trans-unit id="779f1a52816d71bc238af2dd263cf807ba014f89" translate="yes" xml:space="preserve">
          <source>Returns the number (integer) of DNS domain levels (number of dots) in the hostname.</source>
          <target state="translated">返回主机名中DNS域名级别的数量(整数)(点数)。</target>
        </trans-unit>
        <trans-unit id="796056bd8233f1877d339efcb4a7fa1c33b0b3f3" translate="yes" xml:space="preserve">
          <source>Returns the server IP address of the machine Firefox is running on, as a string in the dot-separated integer format.</source>
          <target state="translated">返回Firefox所在机器的服务器IP地址,以点分隔的整数格式表示。</target>
        </trans-unit>
        <trans-unit id="bfcce7002a9eb058fd0c082f413c844164d4b026" translate="yes" xml:space="preserve">
          <source>Returns true if and only if the domain of hostname matches.</source>
          <target state="translated">如果且仅如果hostname的域名匹配,则返回true。</target>
        </trans-unit>
        <trans-unit id="6b72b7530ef6814ea7c835506c7a8c08546f1ec7" translate="yes" xml:space="preserve">
          <source>Returns true if the string matches the specified shell expression.</source>
          <target state="translated">如果字符串符合指定的shell表达式,则返回true。</target>
        </trans-unit>
        <trans-unit id="9249ca2743c193852a67d54d8e0ccd8dc000dc23" translate="yes" xml:space="preserve">
          <source>Revalidation Failed</source>
          <target state="translated">重新鉴定失败</target>
        </trans-unit>
        <trans-unit id="4129a88770ac061fd8f7b04f0aaf90217987ad97" translate="yes" xml:space="preserve">
          <source>Revalidation and reloading</source>
          <target state="translated">重新失效和重装</target>
        </trans-unit>
        <trans-unit id="df1c8fa3f601e8fda9ea5b4f0aa8ffdeb239e94f" translate="yes" xml:space="preserve">
          <source>Revalidation is triggered when the user presses the reload button. It is also triggered under normal browsing if the cached response includes the &quot;&lt;code&gt;Cache-Control: must-revalidate&lt;/code&gt;&quot; header. Another factor is the cache validation preferences in the &lt;code&gt;Advanced-&amp;gt;Cache&lt;/code&gt; preferences panel. There is an option to force a validation each time a document is loaded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6cc272c56bbafbde0f3dbd9f6482ab1d74f3f7f" translate="yes" xml:space="preserve">
          <source>Revalidation is triggered when the user presses the reload button. It is also triggered under normal browsing if the cached response includes the &quot;&lt;code&gt;Cache-control: must-revalidate&lt;/code&gt;&quot; header. Another factor is the cache validation preferences in the &lt;code&gt;Advanced-&amp;gt;Cache&lt;/code&gt; preferences panel. There is an option to force a validation each time a document is loaded.</source>
          <target state="translated">当用户按下重新加载按钮时，将触发重新验证。如果缓存的响应包含&amp;ldquo; &lt;code&gt;Cache-control: must-revalidate&lt;/code&gt; &amp;rdquo;标头，则在正常浏览下也会触发该事件。另一个因素是&amp;ldquo; &lt;code&gt;Advanced-&amp;gt;Cache&lt;/code&gt; 首选项&amp;rdquo;面板中的缓存验证首选项。有一个选项可在每次加载文档时强制进行验证。</target>
        </trans-unit>
        <trans-unit id="4c78cb0809c7ea82ab0ddb940bd222d197180540" translate="yes" xml:space="preserve">
          <source>Reverse proxies</source>
          <target state="translated">反向代理</target>
        </trans-unit>
        <trans-unit id="f23dd650ab0a4fd135ac0102e4263dfefabf8c25" translate="yes" xml:space="preserve">
          <source>Revved resources</source>
          <target state="translated">订正资源</target>
        </trans-unit>
        <trans-unit id="c53ad24c321bdfc1ea4aa408ce3ddb04feb1fadd" translate="yes" xml:space="preserve">
          <source>Rich Text Format (RTF)</source>
          <target state="translated">富文本格式(RTF)</target>
        </trans-unit>
        <trans-unit id="6e119a5751c88c7d53ad4f9a517a2b4fe5bf070c" translate="yes" xml:space="preserve">
          <source>Right after sending the &lt;code&gt;101&lt;/code&gt; status code, an eventual handshake for the new protocol happens, if the new protocol requires it, then the server sends the answer requested for the original request (the one that included the &lt;code&gt;&quot;Upgrade&quot;&lt;/code&gt; header), following the new protocol rules.</source>
          <target state="translated">在发送 &lt;code&gt;101&lt;/code&gt; 状态代码之后，新协议最终会发生握手，如果新协议需要它，则服务器会在新请求之后发送原始请求（包括 &lt;code&gt;&quot;Upgrade&quot;&lt;/code&gt; 标头的请求）的答案。协议规则。</target>
        </trans-unit>
        <trans-unit id="203ee3287248c92b0df850ac6b3eaa45b58ee5e9" translate="yes" xml:space="preserve">
          <source>Right after sending the &lt;code&gt;101&lt;/code&gt; status code, the server can begin speaking the new protocol, performing any additional protocol-specific handshakes as necessary. Effectively, the connection becomes a two-way pipe as soon as the upgraded response is complete, and the request that initiated the upgrade can be completed over the new protocol.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e01cad63d1dd1ba3037d248a230a0edc94073240" translate="yes" xml:space="preserve">
          <source>Root CAs manually added to the trust store override and suppress &lt;code&gt;Expect-CT&lt;/code&gt; reports/enforcement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cb54ee36d7572d85675120ff80c6f572b6e22f0" translate="yes" xml:space="preserve">
          <source>Roy T. Fielding
   Information and Computer Science
   University of California, Irvine
   Irvine, CA 92697-3425, USA

   Fax: +1 (949) 824-1715
   EMail: fielding@ics.uci.edu


   James Gettys
   World Wide Web Consortium
   MIT Laboratory for Computer Science
   545 Technology Square
   Cambridge, MA 02139, USA

   Fax: +1 (617) 258 8682
   EMail: jg@w3.org


   Jeffrey C. Mogul
   Western Research Laboratory
   Compaq Computer Corporation
   250 University Avenue
   Palo Alto, California, 94305, USA

   EMail: mogul@wrl.dec.com


   Henrik Frystyk Nielsen
   World Wide Web Consortium
   MIT Laboratory for Computer Science
   545 Technology Square
   Cambridge, MA 02139, USA

   Fax: +1 (617) 258 8682
   EMail: frystyk@w3.org


   Larry Masinter
   Xerox Corporation
   3333 Coyote Hill Road
   Palo Alto, CA 94034, USA

   EMail: masinter@parc.xerox.com 

   Paul J. Leach
   Microsoft Corporation
   1 Microsoft Way
   Redmond, WA 98052, USA

   EMail: paulle@microsoft.com


   Tim Berners-Lee
   Director, World Wide Web Consortium
   MIT Laboratory for Computer Science
   545 Technology Square
   Cambridge, MA 02139, USA

   Fax: +1 (617) 258 8682
   EMail: timbl@w3.org</source>
          <target state="translated">Roy T.Fielding Information and Computer Science University of California,Irvine Irvine,CA 92697-3425,USA Fax:+1 (949)824-1715 EMail:fielding@ics.uci.edu James Gettys World Wide Web Consortium MIT Laboratory for Computer Science 545 Technology Square Cambridge,MA 02139,USA Fax:+1 (617)258 8682 EMail:jg@w3.org Jeffrey C.Mogul Western Research Laboratory Compaq Computer Corporation 250 University Avenue Palo Alto,California,94305,USA EMail:mogul@wrl.dec.com Henrik Frystyk Nielsen World Wide Web Consortium MIT Laboratory for Computer Science 545 Technology Square Cambridge,MA 02139,USA Fax:+1 (617)258 8682 EMail:frystyk@w3.org Larry Masinter Xerox Corporation 3333 Coyote Hill Road Palo Alto,CA 94034,USA EMail:masinter@parc.xerox.com Paul J.Leach Microsoft Corporation 1 Microsoft Way Redmond,WA 98052,USA EMail:paulle@microsoft.com Tim Berners-Lee Director,World Wide Web Consortium MIT Laboratory for Computer Science 545 Technology Square Cambridge,MA 02139,USA Fax:+1 (617)258 8682 EMail:timbl@w3.org</target>
        </trans-unit>
        <trans-unit id="155381cbc7c74d0a3b58b7dec055fb15f9da1321" translate="yes" xml:space="preserve">
          <source>Ruby on Rails</source>
          <target state="translated">Ruby on Rails</target>
        </trans-unit>
        <trans-unit id="78e1790e29a5541b6d02348fc3f45f18445709f4" translate="yes" xml:space="preserve">
          <source>Rule</source>
          <target state="translated">Rule</target>
        </trans-unit>
        <trans-unit id="6e5110b99817ab97188b2fb5c0432e88694c5cb6" translate="yes" xml:space="preserve">
          <source>SAMEORIGIN</source>
          <target state="translated">SAMEORIGIN</target>
        </trans-unit>
        <trans-unit id="051b852d3e1434bf269741e55246b092c01b6d34" translate="yes" xml:space="preserve">
          <source>SOCKS &lt;em&gt;host:port&lt;/em&gt;</source>
          <target state="translated">SOCKS &lt;em&gt;主机：端口&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c1b9bb67b06df044e5b52d49df71e5762865e669" translate="yes" xml:space="preserve">
          <source>SOCKS4 &lt;em&gt;host:port&lt;/em&gt;</source>
          <target state="translated">SOCKS4 &lt;em&gt;主机：端口&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4d498327ded8eb1659cbddc3b98307c46f04e966" translate="yes" xml:space="preserve">
          <source>SOCKS5 &lt;em&gt;host:port&lt;/em&gt;</source>
          <target state="translated">SOCKS5 &lt;em&gt;主机：端口&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="50fce6d02899850101b1865a947b45128c5350eb" translate="yes" xml:space="preserve">
          <source>SVG</source>
          <target state="translated">SVG</target>
        </trans-unit>
        <trans-unit id="b8c3907fd9fbfd04403be1ea246413102cae5626" translate="yes" xml:space="preserve">
          <source>SVG images (vector images)</source>
          <target state="translated">SVG图像(矢量图像</target>
        </trans-unit>
        <trans-unit id="424dd4565e3b50faee0307759cb623a23456af2c" translate="yes" xml:space="preserve">
          <source>Safari</source>
          <target state="translated">Safari</target>
        </trans-unit>
        <trans-unit id="387d8081b96a43162142a7aed8adc8c5f1c9d7ea" translate="yes" xml:space="preserve">
          <source>Safari 13 on macOS 10.14 (Mojave), treats &lt;code&gt;SameSite=None&lt;/code&gt; and invalid values as &lt;code&gt;Strict&lt;/code&gt;. This is fixed in version 10.15 (Catalina) and later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23c032140d272311e29c5ca2687a75ad09e37d16" translate="yes" xml:space="preserve">
          <source>Safari 5</source>
          <target state="translated">Safari 5</target>
        </trans-unit>
        <trans-unit id="cd29382cb0678144991e40cb67f0f26309c178fe" translate="yes" xml:space="preserve">
          <source>Safari UA string</source>
          <target state="translated">Safari UA字符串</target>
        </trans-unit>
        <trans-unit id="914ddefb3bd0af36387638e5098a5bfccd9d2330" translate="yes" xml:space="preserve">
          <source>Safari gives two version number, one technical in the Safari/xyz token, one user-friendly in a Version/xyz token</source>
          <target state="translated">Safari给出了两个版本号,一个是Safari/xyz标记中的技术号,一个是Version/xyz标记中的用户友好号。</target>
        </trans-unit>
        <trans-unit id="d2132f3b26f679d8b13ddd4fd2c4b863d1dc41f1" translate="yes" xml:space="preserve">
          <source>Safari gives two version numbers: one technical in the Safari/xyz token, and one user-friendly in a Version/xyz token</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58150bf4bc81cb0b79b4789ca1d37338441d8ddb" translate="yes" xml:space="preserve">
          <source>Safari on iOS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3baae9bdafb1777b0a8c4b42ca014a3e672bf89a" translate="yes" xml:space="preserve">
          <source>Safari, Chrome</source>
          <target state="translated">Safari,Chrome</target>
        </trans-unit>
        <trans-unit id="56f9a9116285e2e1d5aefe02e9bf2490ed9cc219" translate="yes" xml:space="preserve">
          <source>Safari/xyz</source>
          <target state="translated">Safari/xyz</target>
        </trans-unit>
        <trans-unit id="9525ae1781bb71fc767a9bab4b6f299ac5cc8c5d" translate="yes" xml:space="preserve">
          <source>Safe</source>
          <target state="translated">Safe</target>
        </trans-unit>
        <trans-unit id="63a5b93ecc868de623f240bfbb9e61bbbc4b6c6f" translate="yes" xml:space="preserve">
          <source>Safe Methods (RFC 7231)</source>
          <target state="translated">安全方法(RFC 7231)</target>
        </trans-unit>
        <trans-unit id="5a9e598295fe6016bddfb7db200367d70f068e41" translate="yes" xml:space="preserve">
          <source>Same as 199, but indicating a persistent warning</source>
          <target state="translated">与199相同,但表示持续警告。</target>
        </trans-unit>
        <trans-unit id="6fd24bb83d525c0587904be6d9063b5b2f9040cb" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;Cache-Control: no-cache&lt;/code&gt;. Forces caches to submit the request to the origin server for validation before releasing a cached copy.</source>
          <target state="translated">与 &lt;code&gt;Cache-Control: no-cache&lt;/code&gt; 相同：no-cache。强制缓存在释放缓存的副本之前将请求提交到原始服务器进行验证。</target>
        </trans-unit>
        <trans-unit id="b26302dd3a3fa55489b0e7f786324aa2ecf9cc5c" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;must-revalidate&lt;/code&gt;, but it only applies to shared caches (e.g., proxies) and is ignored by a private cache.</source>
          <target state="translated">与 &lt;code&gt;must-revalidate&lt;/code&gt; 相同，但是它仅适用于共享缓存（例如代理），并且被私有缓存忽略。</target>
        </trans-unit>
        <trans-unit id="987997d0d6bfde96290ace26118012807c52f8f3" translate="yes" xml:space="preserve">
          <source>Same as above, but if both proxies go down, automatically start making direct connections. (In the first example above, Netscape will ask user confirmation about making direct connections; in this case, there is no user intervention.)</source>
          <target state="translated">同上,但如果两个代理服务器都瘫痪了,自动开始进行直接连接。在上面的第一个例子中,Netscape会要求用户确认是否进行直接连接;在这种情况下,没有用户干预)。</target>
        </trans-unit>
        <trans-unit id="ccf511a0061f086d955d97477343668d80c1a041" translate="yes" xml:space="preserve">
          <source>Same-Site Cookies</source>
          <target state="translated">同站Cookies</target>
        </trans-unit>
        <trans-unit id="bee25962095abc626fad400750f39f70602bb29d" translate="yes" xml:space="preserve">
          <source>Same-origin policy</source>
          <target state="translated">同源政策</target>
        </trans-unit>
        <trans-unit id="15119730c37e094987a0f56c39055afbf665b5f7" translate="yes" xml:space="preserve">
          <source>SameSite attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dccf8be165cd7e805358a12ead73def5ccd7ead" translate="yes" xml:space="preserve">
          <source>SameSite=Lax Optional</source>
          <target state="translated">SameSite=Lax 可选</target>
        </trans-unit>
        <trans-unit id="0cbd84ce60ee0f574919dfa4e0c7b76c8a94f8da" translate="yes" xml:space="preserve">
          <source>SameSite=Strict</source>
          <target state="translated">SameSite=Strict</target>
        </trans-unit>
        <trans-unit id="873f5bd8ca409a7986de0e5309bd3885c3eab798" translate="yes" xml:space="preserve">
          <source>Sample violation report</source>
          <target state="translated">违规报告样本</target>
        </trans-unit>
        <trans-unit id="da8abd7408a5aa336cbde8d4920f8da276e7b302" translate="yes" xml:space="preserve">
          <source>Samsung Internet</source>
          <target state="translated">三星互联网</target>
        </trans-unit>
        <trans-unit id="3a68f8a275363cb5dc0e990d5ee7f023559d8d8e" translate="yes" xml:space="preserve">
          <source>Say you have a &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form&quot;&gt;&amp;lt;form&amp;gt;&lt;/a&gt;&lt;/code&gt; for sending money to another user of a site.</source>
          <target state="translated">假设您有一个 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form&quot;&gt;&amp;lt;form&amp;gt;&lt;/a&gt;&lt;/code&gt; ,用于向站点的另一个用户汇款。</target>
        </trans-unit>
        <trans-unit id="d56d9c1ccf0bc0f33130fff7850c2e5871fca835" translate="yes" xml:space="preserve">
          <source>Say you're creating a new blog post through a site's API:</source>
          <target state="translated">假设你正在通过一个网站的API创建一个新的博客文章。</target>
        </trans-unit>
        <trans-unit id="4604d176d51353df986205d207f767ee691f148b" translate="yes" xml:space="preserve">
          <source>Scalable Vector Graphics</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16e6004376e3926149328610370037caae151443" translate="yes" xml:space="preserve">
          <source>Scalable Vector Graphics (SVG)</source>
          <target state="translated">可缩放矢量图形(SVG)</target>
        </trans-unit>
        <trans-unit id="990897a59f17d4deac662966307b456e376c6c6d" translate="yes" xml:space="preserve">
          <source>Scheme</source>
          <target state="translated">Scheme</target>
        </trans-unit>
        <trans-unit id="59731c699d056f30b458a35ac2e1c7b49f928594" translate="yes" xml:space="preserve">
          <source>Scheme or protocol</source>
          <target state="translated">方案或协议</target>
        </trans-unit>
        <trans-unit id="94231fed0cda7afbf08bbfc9ad6ef2692cc59645" translate="yes" xml:space="preserve">
          <source>Scope of cookies</source>
          <target state="translated">饼干的范围</target>
        </trans-unit>
        <trans-unit id="e4fcfa3d448d1651966e714eb22780b10c65cafa" translate="yes" xml:space="preserve">
          <source>Scripts can programatically query information about the feature policy via the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/FeaturePolicy&quot;&gt;&lt;code&gt;FeaturePolicy&lt;/code&gt;&lt;/a&gt; object located at either &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/featurePolicy&quot;&gt;&lt;code&gt;Document.featurePolicy&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLIFrameElement/featurePolicy&quot;&gt;&lt;code&gt;HTMLIFrameElement.featurePolicy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c3ca47c0105fab811cf07258c4b16efcfe40f19" translate="yes" xml:space="preserve">
          <source>Scripts inherit the policy of their browsing context, regardless of their origin. That means that top-level scripts inherit the policy from the main document.</source>
          <target state="translated">脚本继承了其浏览上下文的策略,而不管其来源如何。这意味着顶层脚本继承了主文档的策略。</target>
        </trans-unit>
        <trans-unit id="dfc1b60d94fdbf10534406b7762e8b6f2bae9145" translate="yes" xml:space="preserve">
          <source>SeaMonkey on Linux</source>
          <target state="translated">Linux上的SeaMonkey</target>
        </trans-unit>
        <trans-unit id="1a3b80710cd0d8991477261291ca25204ce328b9" translate="yes" xml:space="preserve">
          <source>SeaMonkey on Mac</source>
          <target state="translated">SeaMonkey在Mac上</target>
        </trans-unit>
        <trans-unit id="9c623420fdda2ac570aef52b55489d15c0471e7a" translate="yes" xml:space="preserve">
          <source>SeaMonkey on Windows</source>
          <target state="translated">SeaMonkey在Windows上</target>
        </trans-unit>
        <trans-unit id="011fd1651703d76cf60df261ca3f1fef579b6047" translate="yes" xml:space="preserve">
          <source>Seamonkey</source>
          <target state="translated">Seamonkey</target>
        </trans-unit>
        <trans-unit id="56f35b4502f3ec45082c5dc335c7795a1a7c26e3" translate="yes" xml:space="preserve">
          <source>Seamonkey/xyz</source>
          <target state="translated">Seamonkey/xyz</target>
        </trans-unit>
        <trans-unit id="1a0d5d5ec95e9687f95d15318308edd8b34ce1fb" translate="yes" xml:space="preserve">
          <source>Search engine robots and other crawlers don't memorize the new, temporary URL. Temporary redirections are also used when creating, updating, or deleting resources, to show temporary progress pages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7eca79871c6f6fc4c47ae676de3882a8679ff650" translate="yes" xml:space="preserve">
          <source>Sec-WebSocket-Accept</source>
          <target state="translated">Sec-WebSocket-Accept</target>
        </trans-unit>
        <trans-unit id="bb412cf0745496a29d28a7ea9c242da8e4682209" translate="yes" xml:space="preserve">
          <source>Seconds from 0 to 59.</source>
          <target state="translated">从0到59的秒数。</target>
        </trans-unit>
        <trans-unit id="306c19b887ddc8fe31f3651e18b08dc05bd8f651" translate="yes" xml:space="preserve">
          <source>Sections &lt;a href=&quot;#section-9.2.1&quot;&gt;9.2.1&lt;/a&gt;, &lt;a href=&quot;#section-9.1.2&quot;&gt;9.1.2&lt;/a&gt;, &lt;a href=&quot;#section-9.6.1&quot;&gt;9.6.1&lt;/a&gt;, &lt;a href=&quot;#section-9.8.3&quot;&gt;9.8.3&lt;/a&gt;, and &lt;a href=&quot;#section-9.9.2&quot;&gt;9.9.2&lt;/a&gt; define various status
   codes used in Multi-Status responses.  This specification does not
   define the meaning of other status codes that could appear in these
   responses.</source>
          <target state="translated">第&lt;a href=&quot;#section-9.2.1&quot;&gt;9.2.1&lt;/a&gt;，&lt;a href=&quot;#section-9.1.2&quot;&gt;9.1.2&lt;/a&gt;，&lt;a href=&quot;#section-9.6.1&quot;&gt;9.6.1&lt;/a&gt;，&lt;a href=&quot;#section-9.8.3&quot;&gt;9.8.3&lt;/a&gt;和&lt;a href=&quot;#section-9.9.2&quot;&gt;9.9.2&lt;/a&gt;定义多状态响应中使用的各种状态代码。本规范未定义可能在这些响应中出现的其他状态代码的含义。</target>
        </trans-unit>
        <trans-unit id="337cbd0bcbed8973159ebf2f991fe72b8939d1af" translate="yes" xml:space="preserve">
          <source>Secure Optional</source>
          <target state="translated">安全可选</target>
        </trans-unit>
        <trans-unit id="b506ddb82a08407cd1fd3be6e6ac4aedfd2cc08e" translate="yes" xml:space="preserve">
          <source>Secure shell</source>
          <target state="translated">安全壳</target>
        </trans-unit>
        <trans-unit id="10f90a995bf8c302b255a7f48b587d2f56e50772" translate="yes" xml:space="preserve">
          <source>SecureCorp Inc. wants to disable Microphone and Geolocation APIs in its application. It can do so by delivering the following HTTP response header to define a feature policy:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51fa0a986148790e5e39c3246996e0d27d164ab3" translate="yes" xml:space="preserve">
          <source>SecureCorp Inc. wants to disable Vibration and Geolocation APIs in their application. It can do so by delivering the following HTTP response header to define a feature policy:</source>
          <target state="translated">SecureCorp Inc.希望在其应用程序中禁用振动和地理位置API。它可以通过提供以下HTTP响应头来定义功能策略。</target>
        </trans-unit>
        <trans-unit id="be1ba146ec015129cdc87a6b6cda0c810fea5fc6" translate="yes" xml:space="preserve">
          <source>SecureCorp Inc. wants to disable the Fullscreen API within all browsing contexts except for its own origin and those whose origin is &lt;code&gt;https://example.com&lt;/code&gt;. It can do so by delivering the following HTTP response header to define a feature policy:</source>
          <target state="translated">SecureCorp Inc.希望在所有浏览上下文中禁用全屏API，但其自身来源以及来源为 &lt;code&gt;https://example.com&lt;/code&gt; 的来源除外。为此，可以提供以下HTTP响应标头以定义功能部件策略：</target>
        </trans-unit>
        <trans-unit id="a159b732490e876325bf141a42c816091555db2e" translate="yes" xml:space="preserve">
          <source>SecureCorp Inc. wants to disable the Geolocation API within all browsing contexts except for its own origin and those whose origin is &lt;code&gt;https://example.com&lt;/code&gt;. It can do so by delivering the following HTTP response header to define a feature policy:</source>
          <target state="translated">SecureCorp Inc.希望在所有浏览上下文中禁用Geolocation API，但其自身来源以及来源为 &lt;code&gt;https://example.com&lt;/code&gt; 的来源除外。为此，可以提供以下HTTP响应标头以定义功能部件策略：</target>
        </trans-unit>
        <trans-unit id="f25ce1b8a399bd8621a57427a20039b4b13935db" translate="yes" xml:space="preserve">
          <source>Security</source>
          <target state="translated">Security</target>
        </trans-unit>
        <trans-unit id="1dfc995fa62a8e188eccdd322ddb4edbdbfea306" translate="yes" xml:space="preserve">
          <source>Security Considerations (RFC 2616)</source>
          <target state="translated">安全考虑因素(RFC 2616)</target>
        </trans-unit>
        <trans-unit id="3b8fdb84152d7745f62dd2987944fe2bde984275" translate="yes" xml:space="preserve">
          <source>Security Considerations (RFC 7230)</source>
          <target state="translated">安全考虑因素(RFC 7230)</target>
        </trans-unit>
        <trans-unit id="45b64918d523e29e2ec840fd10d70a111ad02104" translate="yes" xml:space="preserve">
          <source>Security Considerations (RFC 7231)</source>
          <target state="translated">安全考虑因素(RFC 7231)</target>
        </trans-unit>
        <trans-unit id="d16e94f2024ae95fb74f63d4a34619f9aa28b96f" translate="yes" xml:space="preserve">
          <source>Security Considerations (RFC 7232)</source>
          <target state="translated">安全考虑因素(RFC 7232)</target>
        </trans-unit>
        <trans-unit id="ed09df6c082dc378c2be105d88f0f7c6b27744b3" translate="yes" xml:space="preserve">
          <source>Security Considerations (RFC 7233)</source>
          <target state="translated">安全考虑因素(RFC 7233)</target>
        </trans-unit>
        <trans-unit id="634a5436cba76ad187076b3442bdc2183b8a02c5" translate="yes" xml:space="preserve">
          <source>Security Considerations (RFC 7234)</source>
          <target state="translated">安全考虑因素(RFC 7234)</target>
        </trans-unit>
        <trans-unit id="a2965824c87409925878841116315b190450c0c6" translate="yes" xml:space="preserve">
          <source>Security Considerations (RFC 7235)</source>
          <target state="translated">安全考虑因素(RFC 7235)</target>
        </trans-unit>
        <trans-unit id="0b0a72a60bc2726643d7f43f73beedf4d9eedacc" translate="yes" xml:space="preserve">
          <source>Security issues</source>
          <target state="translated">安全问题</target>
        </trans-unit>
        <trans-unit id="45b4812d50d88e88b1448bd0da22f03283ec4833" translate="yes" xml:space="preserve">
          <source>Security of basic authentication</source>
          <target state="translated">基本认证的安全性</target>
        </trans-unit>
        <trans-unit id="1adc2d2821ca3f28bdeda8b691ca76c312913404" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#Preloading_Strict_Transport_Security&quot;&gt;Preloading Strict Transport Security&lt;/a&gt; for details. Not part of the specification.</source>
          <target state="translated">有关详细信息，请参见&lt;a href=&quot;#Preloading_Strict_Transport_Security&quot;&gt;预加载严格的传输安全性&lt;/a&gt;。不属于规范的一部分。</target>
        </trans-unit>
        <trans-unit id="ef97e870c01e8eaff7ad366cfd23acefa50ec984" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;../content-security-policy-report-only&quot;&gt;&lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt;&lt;/a&gt; for more information and examples.</source>
          <target state="translated">有关更多信息和示例，请参阅仅&lt;a href=&quot;../content-security-policy-report-only&quot;&gt; &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="412e3d00c269ec4cc7cc918810af03116020d0cd" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://blogs.msdn.com/b/fiddler/archive/2011/02/10/fiddler-is-better-with-internet-explorer-9.aspx&quot;&gt;Fiddler is better with Internet Explorer 9 (IEInternals' MSDN blog)&lt;/a&gt;</source>
          <target state="translated">看到&lt;a href=&quot;http://blogs.msdn.com/b/fiddler/archive/2011/02/10/fiddler-is-better-with-internet-explorer-9.aspx&quot;&gt;Fiddler使用Internet Explorer 9更好（IEInternals的MSDN博客）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e8eecda09ccd7acf7d1d416036629474295d0816" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://blogs.msdn.com/b/ieinternals/archive/2009/07/01/ie-and-the-accept-header.aspx&quot;&gt;IE and the Accept Header (IEInternals' MSDN blog)&lt;/a&gt;</source>
          <target state="translated">参见&lt;a href=&quot;http://blogs.msdn.com/b/ieinternals/archive/2009/07/01/ie-and-the-accept-header.aspx&quot;&gt;IE和&amp;ldquo;接受标头&amp;rdquo;（IEInternals的MSDN博客）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="99877507a4f0dfd21502cd193c8da53cfbacbaa8" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://blogs.msdn.com/b/ieinternals/archive/2009/07/01/ie-and-the-accept-header.aspx&quot;&gt;IE and the Accept Header (IEInternals' MSDN blog)&lt;/a&gt;.</source>
          <target state="translated">请参阅&lt;a href=&quot;http://blogs.msdn.com/b/ieinternals/archive/2009/07/01/ie-and-the-accept-header.aspx&quot;&gt;IE和&amp;ldquo;接受标头&amp;rdquo;（IEInternals的MSDN博客）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="51ff2f1ca438f05f13a6e4821ab222008067c937" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://docs.aws.amazon.com/AmazonS3/latest/API/sigv4-auth-using-authorization-header.html&quot;&gt;AWS docs&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71f12e2140ada9e4648ccf95079dbf16c469780e" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://feature-policy-demos.appspot.com/&quot;&gt;Feature Policy Demos&lt;/a&gt; for example usage of many policies.</source>
          <target state="translated">有关许多策略的示例用法，请参阅&lt;a href=&quot;http://feature-policy-demos.appspot.com/&quot;&gt;功能策略演示&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8c7daa470035fb38b92a42a6527e06b374c583b4" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://bugzil.la/1045899&quot;&gt;bug 1045899&lt;/a&gt;.</source>
          <target state="translated">参见&lt;a href=&quot;https://bugzil.la/1045899&quot;&gt;错误1045899&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f53727915d1a1596e99008ed6acb77d2dffba29b" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://bugzil.la/1091176&quot;&gt;bug 1091176&lt;/a&gt;.</source>
          <target state="translated">参见&lt;a href=&quot;https://bugzil.la/1091176&quot;&gt;错误1091176&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d2366d6aff36b6ca45b9473d29a4cbd2a60c64bd" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://bugzil.la/1091177&quot;&gt;bug 1091177&lt;/a&gt;.</source>
          <target state="translated">参见&lt;a href=&quot;https://bugzil.la/1091177&quot;&gt;错误1091177&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="318d2bb91bfdc58722dc4a7256e4271421ef8e93" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://bugzil.la/1343950&quot;&gt;bug 1343950&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="902701fdeea5da8c62c83a2049c53fd96838fbe5" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://bugzil.la/1457204&quot;&gt;bug 1457204&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87daf564ee99134b1171922777cd6d3e1630eccb" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://bugzil.la/1529337&quot;&gt;bug 1529337&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="476321e1a8bf06a66c253b2ca2611ab0f7550036" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://bugzil.la/1529338&quot;&gt;bug 1529338&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c90dfb9eb96a4f291cdf4c61516336af7ea3f56c" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://bugzil.la/230260&quot;&gt;bug 230260&lt;/a&gt;.</source>
          <target state="translated">参见&lt;a href=&quot;https://bugzil.la/230260&quot;&gt;错误230260&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="34a15d1f8d3edecfef3664e49f7ade5b2cde8cc0" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=1158011&quot;&gt;bug 1158011&lt;/a&gt; for implementation status in Firefox.</source>
          <target state="translated">有关Firefox中的实现状态，请参见&lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=1158011&quot;&gt;错误1158011&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9389f0b53643699ff8b3d81c472dfa931ebda59e" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=170789&quot;&gt;bug 170789&lt;/a&gt;</source>
          <target state="translated">看到&lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=170789&quot;&gt;错误170789&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4c022826199be858adbb57b661f330364fb2d979" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=170789&quot;&gt;bug 170789&lt;/a&gt;&lt;a href=&quot;https://hg.mozilla.org/mozilla-central/file/tip/layout/style/Loader.cpp#l1548&quot;&gt;source&lt;/a&gt;</source>
          <target state="translated">查看&lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=170789&quot;&gt;错误170789的&lt;/a&gt;&lt;a href=&quot;https://hg.mozilla.org/mozilla-central/file/tip/layout/style/Loader.cpp#l1548&quot;&gt;来源&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="828f60dc446fd652055bcdb734c92c3074411fad" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=489071&quot;&gt;bug 489071&lt;/a&gt;&lt;a href=&quot;https://hg.mozilla.org/mozilla-central/file/tip/dom/html/HTMLAudioElement.cpp#l81&quot;&gt;source&lt;/a&gt;</source>
          <target state="translated">查看&lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=489071&quot;&gt;错误489071 &lt;/a&gt;&lt;a href=&quot;https://hg.mozilla.org/mozilla-central/file/tip/dom/html/HTMLAudioElement.cpp#l81&quot;&gt;来源&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="03fd2bfeff3aff3c7b402bd3707da7d160456f52" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=489071&quot;&gt;bug 489071&lt;/a&gt;&lt;a href=&quot;https://hg.mozilla.org/mozilla-central/file/tip/dom/html/HTMLVideoElement.cpp#l136&quot;&gt;source&lt;/a&gt;</source>
          <target state="translated">查看&lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=489071&quot;&gt;错误489071 &lt;/a&gt;&lt;a href=&quot;https://hg.mozilla.org/mozilla-central/file/tip/dom/html/HTMLVideoElement.cpp#l136&quot;&gt;来源&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8ea6c6e1adea411a07c2320171cae96d403fec24" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://crbug.com/801561&quot;&gt;bug 801561&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b575def278021b7035d974c192a9dc908681908" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://crbug.com/898503&quot;&gt;bug 898503&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="395cd81c81660b7de954f329745ea35187280967" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://docs.microsoft.com/en-us/archive/blogs/fiddler/fiddler-and-the-ie9-release-candidate&quot;&gt;Fiddler is better with Internet Explorer 9 (IEInternals' MSDN blog)&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3af50720c1d91d4b3c6841644aebf66d7089956a" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://docs.microsoft.com/en-us/archive/blogs/ieinternals/ie-and-the-accept-header&quot;&gt;IE and the Accept Header (IEInternals' MSDN blog)&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="664ccabb23690aee9178706eae0a0c86aa28b4c8" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://docs.microsoft.com/en-us/archive/blogs/ieinternals/ie-and-the-accept-header&quot;&gt;IE and the Accept Header (IEInternals' MSDN blog)&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58088fac9fc484833ce2100e814b5988abb5c6b1" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://infosec.mozilla.org/guidelines/web_security#Examples_5&quot;&gt;Mozilla Web Security Guidelines&lt;/a&gt; for more examples.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc498c10fa74da481f3412943c8a08f7e748c919" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://tools.ietf.org/html/rfc6750&quot;&gt;RFC 6750&lt;/a&gt;, bearer tokens to access OAuth 2.0-protected resources</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="444cfb8c4f30e29f1714c2f9e4bf5ebdaa5c09ca" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-10&quot;&gt;Section&amp;nbsp;10 of [RFC7230]&lt;/a&gt;.</source>
          <target state="translated">参见&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-10&quot;&gt;[RFC7230]的第10节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a90058aa35b12499789f50b37ba9f575e8b618e3" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://tools.ietf.org/html/rfc7486&quot;&gt;RFC 7486&lt;/a&gt;, Section 3, &lt;strong&gt;H&lt;/strong&gt;TTP &lt;strong&gt;O&lt;/strong&gt;rigin-&lt;strong&gt;B&lt;/strong&gt;ound &lt;strong&gt;A&lt;/strong&gt;uthentication, digital-signature-based</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adce75b7621f55e2109a1ca207205e78afa08904" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://tools.ietf.org/html/rfc7616&quot;&gt;RFC 7616&lt;/a&gt;, only md5 hashing is supported in Firefox, see &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=472823&quot;&gt;bug 472823&lt;/a&gt; for SHA encryption support</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b350575ff9468b7e0a2d607edfffce21bcd5df92" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://tools.ietf.org/html/rfc7617&quot;&gt;RFC 7617&lt;/a&gt;, base64-encoded credentials. More information below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bedeae74dbfe5265c8dfe7958b7b7d8f49527c2" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://tools.ietf.org/html/rfc8120&quot;&gt;RFC 8120&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c48cf1cda37fbc574acc351d711734f071e0dc06" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://w3c.github.io/payment-request/#feature-policy&quot;&gt;Section 16. Feature Policy integration&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cf3b4b99a42a93e5a7a23ffac3b8b47738ee08f" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://webkit.org/b/185070&quot;&gt;bug 185070&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="291a54a8499dd01f0491fc82c8048f328a7ee51d" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://wiki.mozilla.org/Security/Guidelines/Web_Security#Examples_5&quot;&gt;Mozilla Web Security Guidelines&lt;/a&gt; for more examples.</source>
          <target state="translated">有关更多示例，请参见&lt;a href=&quot;https://wiki.mozilla.org/Security/Guidelines/Web_Security#Examples_5&quot;&gt;Mozilla Web安全准则&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7624f91831549a9940eddbb0f3488a2e93402df5" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;proxy_servers_and_tunneling/proxy_auto-configuration_(pac)_file&quot;&gt;Proxy Auto-Configuration (PAC)&lt;/a&gt; for more examples.</source>
          <target state="translated">有关更多示例，请参见&lt;a href=&quot;proxy_servers_and_tunneling/proxy_auto-configuration_(pac)_file&quot;&gt;代理自动配置（PAC）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="67373bb92cd7ecbf243edb9d60ad6f00f86a6052" translate="yes" xml:space="preserve">
          <source>See Also</source>
          <target state="translated">另见</target>
        </trans-unit>
        <trans-unit id="22264972bbdf21536a2e97676872b0fa23492f4e" translate="yes" xml:space="preserve">
          <source>See Bugzilla &lt;a href=&quot;https://bugzil.la/995651&quot;&gt;bug 995651&lt;/a&gt; comment 7.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a20b2ffdf62590791187b6d4381fc1759c9535a" translate="yes" xml:space="preserve">
          <source>See Bugzilla &lt;a href=&quot;https://bugzil.la/995651&quot;&gt;bug 995651&lt;/a&gt;.</source>
          <target state="translated">请参阅Bugzilla &lt;a href=&quot;https://bugzil.la/995651&quot;&gt;错误995651&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="719539956ee13b958d9391b4bf7cb27f3c489c59" translate="yes" xml:space="preserve">
          <source>See Chromium &lt;a href=&quot;https://code.google.com/p/chromium/issues/detail?id=348877&quot;&gt;bug 348877&lt;/a&gt;.</source>
          <target state="translated">请参阅铬&lt;a href=&quot;https://code.google.com/p/chromium/issues/detail?id=348877&quot;&gt;错误348877&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1fbf5c238b234a09b0bc9cc8a52ac8bd31daa0c5" translate="yes" xml:space="preserve">
          <source>See Chromium &lt;a href=&quot;https://crbug.com/348877&quot;&gt;bug 348877&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e290772b02b3e631f75a0bdaf76532057f004f69" translate="yes" xml:space="preserve">
          <source>See Chromium &lt;a href=&quot;https://crbug.com/611416&quot;&gt;bug 611416&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d8243a2c0e464492c9d563c4f92c56ae3421bcc" translate="yes" xml:space="preserve">
          <source>See also</source>
          <target state="translated">另见</target>
        </trans-unit>
        <trans-unit id="49924d02e7029d9a0991d61325a81804a8302916" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;../authentication&quot;&gt;HTTP authentication&lt;/a&gt; for examples on how to configure Apache or nginx servers to password protect your site with HTTP basic authentication.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c725ffcd1660304fd5bf29e747aa6869c6d886b" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;../authentication&quot;&gt;HTTP authentication&lt;/a&gt; for examples on how to configure Apache or nginx servers to password protect your site your HTTP basic authentication.</source>
          <target state="translated">另请参阅&lt;a href=&quot;../authentication&quot;&gt;HTTP身份验证，&lt;/a&gt;以获取有关如何配置Apache或Nginx服务器以使用HTTP基本身份验证密码保护您的站点的示例。</target>
        </trans-unit>
        <trans-unit id="42f531717be60bcfcad04f46fda0152e3247b29b" translate="yes" xml:space="preserve">
          <source>See also the &lt;a href=&quot;https://en.wikipedia.org/wiki/HTTP_tunnel&quot;&gt;HTTP tunnel article on Wikipedia&lt;/a&gt;.</source>
          <target state="translated">另请参阅&lt;a href=&quot;https://en.wikipedia.org/wiki/HTTP_tunnel&quot;&gt;Wikipedia上&lt;/a&gt;的HTTP隧道文章。</target>
        </trans-unit>
        <trans-unit id="068cb5dd6b484ffb5dd93633ccbdee24e3890f6b" translate="yes" xml:space="preserve">
          <source>See also the &lt;a href=&quot;transfer-encoding&quot;&gt;&lt;code&gt;Transfer-Encoding&lt;/code&gt;&lt;/a&gt; response header for more details on transfer encodings. Note that &lt;code&gt;chunked&lt;/code&gt; is always acceptable for HTTP/1.1 recipients and you don't have to specify &lt;code&gt;&quot;chunked&quot;&lt;/code&gt; using the &lt;code&gt;TE&lt;/code&gt; header. However, it is useful for setting if the client is accepting trailer fields in a chunked transfer coding using the &quot;trailers&quot; value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2355891f6471b5e6f9a15ded06e4a709c5b0c70" translate="yes" xml:space="preserve">
          <source>See also the &lt;a href=&quot;transfer-encoding&quot;&gt;&lt;code&gt;Transfer-Encoding&lt;/code&gt;&lt;/a&gt; response header for more details on transfer encodings. Note that &lt;code&gt;chunked&lt;/code&gt; is always acceptable for HTTP/1.1 recipients and you that don't have to specify &lt;code&gt;&quot;chunked&quot;&lt;/code&gt; using the &lt;code&gt;TE&lt;/code&gt; header. However, it is useful for setting if the client is accepting trailer fields in a chunked transfer coding using the &quot;trailers&quot; value.</source>
          <target state="translated">另请参见&lt;a href=&quot;transfer-encoding&quot;&gt; &lt;code&gt;Transfer-Encoding&lt;/code&gt; &lt;/a&gt;响应标头，以获取有关传输编码的更多详细信息。请注意，对于HTTP / 1.1收件人而言， &lt;code&gt;chunked&lt;/code&gt; 始终是可接受的，而您不必使用 &lt;code&gt;TE&lt;/code&gt; 标头指定 &lt;code&gt;&quot;chunked&quot;&lt;/code&gt; 。但是，这对于设置客户端是否使用&amp;ldquo; trailers&amp;rdquo;值以分块传输编码的形式接受尾部字段很有用。</target>
        </trans-unit>
        <trans-unit id="d355a7461d6831a917b2782c88db837671b7bc91" translate="yes" xml:space="preserve">
          <source>See also&lt;a href=&quot;../authentication&quot;&gt; HTTP authentication&lt;/a&gt; for examples on how to configure Apache or nginx servers to password protect your site with HTTP basic authentication.</source>
          <target state="translated">另请参阅&lt;a href=&quot;../authentication&quot;&gt;HTTP身份验证，&lt;/a&gt;以获取有关如何配置Apache或nginx服务器以使用HTTP基本身份验证对网站进行密码保护的示例。</target>
        </trans-unit>
        <trans-unit id="2e0b79753ca98622d76b2e5d4b5394a6888d631c" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;../headers/expect&quot;&gt;&lt;code&gt;Expect&lt;/code&gt;&lt;/a&gt; header for more details.</source>
          <target state="translated">有关更多详细信息，请参见&lt;a href=&quot;../headers/expect&quot;&gt; &lt;code&gt;Expect&lt;/code&gt; &lt;/a&gt;标头。</target>
        </trans-unit>
        <trans-unit id="2a2d69655ef270db2516384f7be4ebe39aca6629" translate="yes" xml:space="preserve">
          <source>Semi-colon separated list of service definitions in the format of &lt;code&gt;&lt;em&gt;&amp;lt;service-name&amp;gt;&lt;/em&gt;=&quot;&lt;em&gt;&amp;lt;host-name&amp;gt;&lt;/em&gt;:&lt;em&gt;&amp;lt;port-number&amp;gt;&lt;/em&gt;&quot;&lt;/code&gt;.</source>
          <target state="translated">以分号分隔的服务定义列表，格式为 &lt;code&gt;&lt;em&gt;&amp;lt;service-name&amp;gt;&lt;/em&gt;=&quot;&lt;em&gt;&amp;lt;host-name&amp;gt;&lt;/em&gt;:&lt;em&gt;&amp;lt;port-number&amp;gt;&lt;/em&gt;&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="62f118d4abc9935767d93c466a37b1b6575960d3" translate="yes" xml:space="preserve">
          <source>Send a full URL (stripped from parameters) when performing a a same-origin or cross-origin request. This policy will leak origins and paths from TLS-protected resources to insecure origins. Carefully consider the impact of this setting.</source>
          <target state="translated">当执行同源或跨源请求时,发送一个完整的URL(从参数中剥离)。这个策略会将TLS保护的资源的起源和路径泄露给不安全的起源。请仔细考虑这个设置的影响。</target>
        </trans-unit>
        <trans-unit id="e8de0238a1711f4357314e28bd455dfbdc081262" translate="yes" xml:space="preserve">
          <source>Send a full URL (stripped from parameters) when performing a same-origin or cross-origin request. This policy will leak origins and paths from TLS-protected resources to insecure origins. Carefully consider the impact of this setting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="114ceefa2c0a72367781ffc8a33b8cc5edfb2e16" translate="yes" xml:space="preserve">
          <source>Send a full URL when performing a same-origin or cross-origin request.</source>
          <target state="translated">在执行同源或跨源请求时,发送一个完整的URL。</target>
        </trans-unit>
        <trans-unit id="da546431c50ca7518407c8dd75000ab5f95b3605" translate="yes" xml:space="preserve">
          <source>Send a full URL when performing a same-origin request, but only send the origin of the document for other cases.</source>
          <target state="translated">执行同源请求时发送完整的URL,其他情况下只发送文档的原点。</target>
        </trans-unit>
        <trans-unit id="aae12fc53d3fc50d9faa00eec22cbfcdb054e1a7" translate="yes" xml:space="preserve">
          <source>Send a full URL when performing a same-origin request, only send the origin when the protocol security level stays the same (HTTPS&amp;rarr;HTTPS), and send no header to a less secure destination (HTTPS&amp;rarr;HTTP).</source>
          <target state="translated">在执行相同来源请求时发送完整的URL，仅在协议安全级别保持不变时发送来源（HTTPS&amp;rarr;HTTPS），不向安全性较低的目标发送任何头（HTTPS&amp;rarr;HTTP）。</target>
        </trans-unit>
        <trans-unit id="ca19fda9303b34183c6fc68556b76910f44fdefc" translate="yes" xml:space="preserve">
          <source>Send an HTTP message: HTTP messages (before HTTP/2) are human-readable. With HTTP/2, these simple messages are encapsulated in frames, making them impossible to read directly, but the principle remains the same.</source>
          <target state="translated">发送一个HTTP消息。HTTP消息(在HTTP/2之前)是可以被人读取的。有了HTTP/2,这些简单的消息被封装在帧中,使得它们无法直接读取,但原理还是一样的。</target>
        </trans-unit>
        <trans-unit id="8147dd4d6d30b20114ea16f4a3cf7fc6cf5e2c2a" translate="yes" xml:space="preserve">
          <source>Send an HTTP message: HTTP messages (before HTTP/2) are human-readable. With HTTP/2, these simple messages are encapsulated in frames, making them impossible to read directly, but the principle remains the same. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b5e6da1d334dfb11080a80304a4f099d91dc28f" translate="yes" xml:space="preserve">
          <source>Send cookies from the server to the user agent.</source>
          <target state="translated">从服务器向用户代理发送cookies。</target>
        </trans-unit>
        <trans-unit id="5dc95fd29fa92a67c8d108e8bb34078b6014f782" translate="yes" xml:space="preserve">
          <source>Send cookies from the server to the user-agent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c1a7617111c5a0b7fa3ff5d33aa9600f608b1ce" translate="yes" xml:space="preserve">
          <source>Send the following the HTTP header:</source>
          <target state="translated">发送以下HTTP头。</target>
        </trans-unit>
        <trans-unit id="bebd45056f35b854179a91d9f552f5c2cd11de2a" translate="yes" xml:space="preserve">
          <source>Send the origin, path, and query string when performing a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Same-origin_policy&quot;&gt;same-origin&lt;/a&gt; request, but only send the origin of the document for other cases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f34c728bc0dd859bfaefc074444b78bddd68cafd" translate="yes" xml:space="preserve">
          <source>Send the origin, path, and query string when performing any request, regardless of security.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77f459dc28c0cecc397bf3277fcada068aa8cb8c" translate="yes" xml:space="preserve">
          <source>Send the origin, path, and querystring when performing a same-origin request, only send the origin when the protocol security level stays the same while performing a cross-origin request (HTTPS&amp;rarr;HTTPS), and send no header to any less-secure destinations (HTTPS&amp;rarr;HTTP).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18b9f60168add4dcbe2cfa97830141467c596249" translate="yes" xml:space="preserve">
          <source>Sending a client request</source>
          <target state="translated">发送客户请求</target>
        </trans-unit>
        <trans-unit id="f042f0da173aa47e7ae908a0354193a6b152284d" translate="yes" xml:space="preserve">
          <source>Sends a signal to the server expressing the client&amp;rsquo;s preference for an encrypted and authenticated response, and that it can successfully handle the &lt;a href=&quot;headers/content-security-policy/upgrade-insecure-requests&quot;&gt;&lt;code&gt;upgrade-insecure-requests&lt;/code&gt;&lt;/a&gt; directive.</source>
          <target state="translated">向服务器发送信号，以表示客户端对加密和已认证响应的偏好，并且可以成功处理&lt;a href=&quot;headers/content-security-policy/upgrade-insecure-requests&quot;&gt; &lt;code&gt;upgrade-insecure-requests&lt;/code&gt; &lt;/a&gt;指令。</target>
        </trans-unit>
        <trans-unit id="66d200f88cfabb0afda59de995f94f1dd092532b" translate="yes" xml:space="preserve">
          <source>Sends cookies from the server to the user-agent, but has been &lt;strong&gt;obsoleted&lt;/strong&gt;. Use &lt;a href=&quot;headers/set-cookie&quot;&gt;&lt;code&gt;Set-Cookie&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8fbea665ea8f09e42b93cbe3fbddf6b3752bacf" translate="yes" xml:space="preserve">
          <source>Sends reports to the report-uri specified in the header and does still allow clients to connect to the server even if the pinning is violated.</source>
          <target state="translated">将报告发送到头中指定的report-uri,即使违反了pinning,也仍然允许客户端连接到服务器。</target>
        </trans-unit>
        <trans-unit id="2c37a6ca7548802cf34b6b1b6a53f217ac82b89c" translate="yes" xml:space="preserve">
          <source>Sent If a cache heuristically chose a freshness lifetime greater than 24 hours and the response's age is greater than 24 hours.</source>
          <target state="translated">发送 如果缓存启发式地选择了大于24小时的新鲜度寿命,且响应的年龄大于24小时。</target>
        </trans-unit>
        <trans-unit id="a53b6fa8202e4e843c3e7af369e3f2f101eea847" translate="yes" xml:space="preserve">
          <source>Sent for revalidated conditional requests. Indicates that the cached response is still fresh and can be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c462e8134588f6d1f23e364585abed05a09525c2" translate="yes" xml:space="preserve">
          <source>Sent with non-CORS requests since Fx59, unless they are &lt;code&gt;GET&lt;/code&gt; or &lt;code&gt;HEAD&lt;/code&gt;.</source>
          <target state="translated">从Fx59开始发送非CORS请求，除非它们是 &lt;code&gt;GET&lt;/code&gt; 或 &lt;code&gt;HEAD&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cc03231ded7efb481d5d56e5edae28e683b8d91a" translate="yes" xml:space="preserve">
          <source>Separating identity and location of a resource: The Alt-Svc HTTP header</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbc7c79d44a40669267832b336453bd4fee39146" translate="yes" xml:space="preserve">
          <source>Separating identity and location of a resource: the Alt-Svc HTTP header</source>
          <target state="translated">分离资源的身份和位置:Alt-Svc HTTP头。</target>
        </trans-unit>
        <trans-unit id="337c903d5597e6947298720f2bc9b6de433ca480" translate="yes" xml:space="preserve">
          <source>Separating identity and location of a resource: the Alt-Svc header</source>
          <target state="translated">分离资源的身份和位置:Alt-Svc头。</target>
        </trans-unit>
        <trans-unit id="cb0cb170d106f8e8d5af1e05bbdbd3a96a7de197" translate="yes" xml:space="preserve">
          <source>Server</source>
          <target state="translated">Server</target>
        </trans-unit>
        <trans-unit id="30407aa127bbc27f6c900a61dc59d209b7261df6" translate="yes" xml:space="preserve">
          <source>Server (RFC 2616)</source>
          <target state="translated">服务器(RFC 2616)</target>
        </trans-unit>
        <trans-unit id="067d8d46c7af148801a57e53fc8b7dfdc58619b7" translate="yes" xml:space="preserve">
          <source>Server (RFC 7231)</source>
          <target state="translated">服务器(RFC 7231)</target>
        </trans-unit>
        <trans-unit id="0c9b2a002adf639991e245e57e64715e0102f09f" translate="yes" xml:space="preserve">
          <source>Server Timing&lt;br/&gt;&lt;small&gt;The definition of 'Server-Timing Header Field' in that specification.&lt;/small&gt;</source>
          <target state="translated">服务器计时&lt;br/&gt;&lt;small&gt;在该规范中&amp;ldquo;服务器计时标题字段&amp;rdquo;的定义。&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="144c703ba42db111e61eac225abbe629b8a298f5" translate="yes" xml:space="preserve">
          <source>Server error responses</source>
          <target state="translated">服务器错误响应</target>
        </trans-unit>
        <trans-unit id="cbda107455833d7e22bb88728c50a3a16c6c4ec5" translate="yes" xml:space="preserve">
          <source>Server errors (&lt;code&gt;500&lt;/code&gt;&amp;ndash;&lt;code&gt;599&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4418c7f82dfa6a5eb45c872b1b4c3a9ec7ed04c" translate="yes" xml:space="preserve">
          <source>Server rejected the request because the &lt;code&gt;Content-Length&lt;/code&gt; header field is not defined and the server requires it.</source>
          <target state="translated">服务器拒绝了该请求，因为未定义 &lt;code&gt;Content-Length&lt;/code&gt; 头字段，并且服务器需要它。</target>
        </trans-unit>
        <trans-unit id="223a3cd967a61f2a3071650ced2def4903361d55" translate="yes" xml:space="preserve">
          <source>Server response</source>
          <target state="translated">服务器响应</target>
        </trans-unit>
        <trans-unit id="ca286c1254a3056614d73687d3f1ef4b4a44a8ec" translate="yes" xml:space="preserve">
          <source>Server-Side Access Control</source>
          <target state="translated">服务器端访问控制</target>
        </trans-unit>
        <trans-unit id="6792a77076aa3b8284916c74946cf72675363ce8" translate="yes" xml:space="preserve">
          <source>Server-Timing</source>
          <target state="translated">Server-Timing</target>
        </trans-unit>
        <trans-unit id="da6cf01a8ddc149fef30875f9a63615768b06254" translate="yes" xml:space="preserve">
          <source>Server-driven content negotiation</source>
          <target state="translated">服务器驱动的内容协商</target>
        </trans-unit>
        <trans-unit id="fd7b73c63b10788b6bed0cef0a6ec6764b254c1d" translate="yes" xml:space="preserve">
          <source>Server-driven negotiation suffers from a few downsides: it doesn't scale well. There is one header per feature used in the negotiation. If you want to use screen size, resolution or other dimensions, a new HTTP header must be created. Sending of the headers must be done on every request. This is not too problematic with few headers, but with the eventual multiplications of them, the message size would lead to a decrease in performance. The more precise headers are sent, the more entropy is sent, allowing for more HTTP fingerprinting and corresponding privacy concern.</source>
          <target state="translated">服务器驱动的协商存在一些缺点:它的扩展性不好。在协商中使用的每个功能都有一个头。如果你想使用屏幕尺寸、分辨率或其他尺寸,必须创建一个新的HTTP头。在每个请求中都必须发送头文件。这在头信息较少的情况下问题不大,但随着头信息的最终倍增,消息大小会导致性能下降。发送的头信息越精确,发送的熵就越大,这样就可以获得更多的HTTP指纹和相应的隐私问题。</target>
        </trans-unit>
        <trans-unit id="280ea515a8b112db582b1e7620e99f0f92dcb530" translate="yes" xml:space="preserve">
          <source>Server-initiated upgrade to TLS</source>
          <target state="translated">服务器主动升级到TLS</target>
        </trans-unit>
        <trans-unit id="79d9bb2304b19b76e2157ed20e7da4030dc91a26" translate="yes" xml:space="preserve">
          <source>Server-sent events</source>
          <target state="translated">服务器发送的事件</target>
        </trans-unit>
        <trans-unit id="67de8093f1524a9bccacf1c09f2b166b248d1aa6" translate="yes" xml:space="preserve">
          <source>Server-side CORS settings</source>
          <target state="translated">服务器端CORS设置</target>
        </trans-unit>
        <trans-unit id="8da24e9a194030de05562477bacb0f99c55e7dbd" translate="yes" xml:space="preserve">
          <source>Servers MUST return authorization errors in preference to other
   errors.  This avoids leaking information about protected resources
   (e.g., a client that finds that a hidden resource exists by seeing a
   423 Locked response to an anonymous request to the resource).</source>
          <target state="translated">服务器必须优先返回授权错误,而不是其他错误。这样可以避免泄露受保护资源的信息(例如,客户端通过看到对资源的匿名请求的423锁定响应而发现隐藏资源的存在)。</target>
        </trans-unit>
        <trans-unit id="f4c682d1668898494c7dc1297fbbd4673d8bc287" translate="yes" xml:space="preserve">
          <source>Servers and/or clients are often located on intranets and hide their true IP address to others. HTTP requests then go through proxies to cross this network barrier. Not all proxies are HTTP proxies. The SOCKS protocol, for example, operates at a lower level. Others, like ftp, can be handled by these proxies.</source>
          <target state="translated">服务器和/或客户机通常位于内部网络,并向他人隐藏其真实的IP地址。HTTP请求就会通过代理服务器来跨越这个网络障碍。并非所有的代理都是HTTP代理。例如,SOCKS协议就在较低的层次上运行。其他的协议,比如ftp,也可以由这些代理处理。</target>
        </trans-unit>
        <trans-unit id="3a801c2bb279262c7911502691c1290ae71c1452" translate="yes" xml:space="preserve">
          <source>Servers are given more leeway in how they respond to a range request,
   in order to mitigate abuse by malicious (or just greedy) clients.
   (&lt;a href=&quot;#section-3.1&quot;&gt;Section 3.1&lt;/a&gt;)

   A weak validator cannot be used in a 206 response.  (&lt;a href=&quot;#section-4.1&quot;&gt;Section 4.1&lt;/a&gt;)

   The Content-Range header field only has meaning when the status code
   explicitly defines its use.  (&lt;a href=&quot;#section-4.2&quot;&gt;Section 4.2&lt;/a&gt;)

   This specification introduces a Range Unit Registry.  (&lt;a href=&quot;#section-5.1&quot;&gt;Section 5.1&lt;/a&gt;)

   multipart/byteranges can consist of a single part.  (Appendix A)</source>
          <target state="translated">服务器在响应范围请求方面有更多的回旋余地，以减轻恶意（或贪婪）客户端的滥用。（&lt;a href=&quot;#section-3.1&quot;&gt;第3.1节&lt;/a&gt;）弱验证器不能用于206响应中。（&lt;a href=&quot;#section-4.1&quot;&gt;第4.1节&lt;/a&gt;）仅当状态代码明确定义其用途时，Content-Range标头字段才有意义。（&lt;a href=&quot;#section-4.2&quot;&gt;第4.2节&lt;/a&gt;）本规范介绍了范围单位注册表。（&lt;a href=&quot;#section-5.1&quot;&gt;第5.1节&lt;/a&gt;）multipart / byteranges可以由一个部分组成。（附录A）</target>
        </trans-unit>
        <trans-unit id="47775be948b90bc8bbdd930ee3d2d72f381c8caa" translate="yes" xml:space="preserve">
          <source>Servers can advertise support for Client Hints using the &lt;code&gt;Accept-CH&lt;/code&gt; header field or an equivalent HTML &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; element with &lt;code&gt;http-equiv&lt;/code&gt; attribute (&lt;a href=&quot;https://httpwg.org/http-extensions/client-hints.html#HTML5&quot;&gt;&lt;cite&gt;[HTML5]&lt;/cite&gt;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42dc7575a6f0aaa611ea0b0ef75203093bd26568" translate="yes" xml:space="preserve">
          <source>Servers can ask the client to remember the set of Client Hints that the server supports for a specified period of time, to enable delivery of Client Hints on subsequent requests to the server&amp;rsquo;s origin (&lt;a href=&quot;https://httpwg.org/http-extensions/client-hints.html#RFC6454&quot;&gt;&lt;cite&gt;[RFC6454]&lt;/cite&gt;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5515ad01f817b62958172ef2562f4725ed4c4587" translate="yes" xml:space="preserve">
          <source>Servers or clients are often located on intranets and hide their true IP address from other computers. HTTP requests then go through proxies to cross this network barrier. Not all proxies are HTTP proxies. The SOCKS protocol, for example, operates at a lower level. Other protocols, like ftp, can be handled by these proxies.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40104b8f8c1bae810fb11635b90972e11a6d19a7" translate="yes" xml:space="preserve">
          <source>Servers send the &quot;Retry-After&quot; header field to indicate how long the
   user agent ought to wait before making a follow-up request.  When
   sent with a 503 (Service Unavailable) response, Retry-After indicates
   how long the service is expected to be unavailable to the client.
   When sent with any 3xx (Redirection) response, Retry-After indicates
   the minimum time that the user agent is asked to wait before issuing
   the redirected request.

   The value of this field can be either an HTTP-date or a number of
   seconds to delay after the response is received.

     Retry-After = HTTP-date / delay-seconds

   A delay-seconds value is a non-negative decimal integer, representing
   time in seconds.

     delay-seconds  = 1*DIGIT 

   Two examples of its use are

     Retry-After: Fri, 31 Dec 1999 23:59:59 GMT
     Retry-After: 120

   In the latter example, the delay is 2 minutes.</source>
          <target state="translated">服务器发送 &quot;Retry-After &quot;头字段来指示用户代理在发出后续请求之前应该等待多长时间。当与503(服务不可用)响应一起发送时,Retry-After表示服务预计会在多长时间内对客户端不可用。当与任何3xx(重定向)响应一起发送时,Retry-After表示要求用户代理在发出重定向请求之前等待的最短时间。这个字段的值可以是HTTP-date,也可以是收到响应后延迟的秒数。Retry-After=HTTP-date/delay-seconds 延迟秒数的值是一个非负十进制的整数,以秒为单位表示时间,delay-seconds=1*DIGIT 它的两个使用实例是 Retry-After。Fri,31 Dec 1999 23:59:59 GMT Retry-After:120 在后一个例子中,延迟是2分钟。</target>
        </trans-unit>
        <trans-unit id="41025e145e89135a85498ba87ffb1a1e1b47fde8" translate="yes" xml:space="preserve">
          <source>Servers will often produce this status if:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b11bd40d94eed6743e5942032063a30b385e293b" translate="yes" xml:space="preserve">
          <source>Servers will usually have some time-out value beyond which they will
   no longer maintain an inactive connection. Proxy servers might make
   this a higher value since it is likely that the client will be making
   more connections through the same server. The use of persistent
   connections places no requirements on the length (or existence) of
   this time-out for either the client or the server. 

   When a client or server wishes to time-out it SHOULD issue a graceful
   close on the transport connection. Clients and servers SHOULD both
   constantly watch for the other side of the transport close, and
   respond to it as appropriate. If a client or server does not detect
   the other side's close promptly it could cause unnecessary resource
   drain on the network.

   A client, server, or proxy MAY close the transport connection at any
   time. For example, a client might have started to send a new request
   at the same time that the server has decided to close the &quot;idle&quot;
   connection. From the server's point of view, the connection is being
   closed while it was idle, but from the client's point of view, a
   request is in progress.

   This means that clients, servers, and proxies MUST be able to recover
   from asynchronous close events. Client software SHOULD reopen the
   transport connection and retransmit the aborted sequence of requests
   without user interaction so long as the request sequence is
   idempotent (see &lt;a href=&quot;#section-9.1.2&quot;&gt;section 9.1.2&lt;/a&gt;). Non-idempotent methods or sequences
   MUST NOT be automatically retried, although user agents MAY offer a
   human operator the choice of retrying the request(s). Confirmation by
   user-agent software with semantic understanding of the application
   MAY substitute for user confirmation. The automatic retry SHOULD NOT
   be repeated if the second sequence of requests fails.

   Servers SHOULD always respond to at least one request per connection,
   if at all possible. Servers SHOULD NOT close a connection in the
   middle of transmitting a response, unless a network or client failure
   is suspected.

   Clients that use persistent connections SHOULD limit the number of
   simultaneous connections that they maintain to a given server. A
   single-user client SHOULD NOT maintain more than 2 connections with
   any server or proxy. A proxy SHOULD use up to 2*N connections to
   another server or proxy, where N is the number of simultaneously
   active users. These guidelines are intended to improve HTTP response
   times and avoid congestion.</source>
          <target state="translated">服务器通常将具有一些超时值，超过该值它们将不再维护不活动的连接。代理服务器可能使此值更高，因为客户端可能会通过同一服务器建立更多连接。持久连接的使用对客户端或服务器的超时时间（或存在时间）没有要求。当客户端或服务器希望超时时，应该在传输连接上正常关闭。客户端和服务器都应经常监视传输的另一端，并做出适当的响应。如果客户端或服务器未及时检测到另一方的关闭，则可能导致网络上不必要的资源消耗。客户端，服务器，或代理可以随时关闭传输连接。例如，客户端可能已开始在服务器决定关闭&amp;ldquo;空闲&amp;rdquo;连接的同时发送新请求。从服务器的角度来看，连接在空闲时正在关闭，但是从客户端的角度来看，请求正在进行中。这意味着客户端，服务器和代理必须能够从异步关闭事件中恢复。客户端软件应该重新打开传输连接并重新发送中止的请求序列，而无需用户干预，只要请求序列是幂等的（请参见从角度来看，连接在空闲时正在关闭，但是从客户端的角度来看，请求正在进行中。这意味着客户端，服务器和代理必须能够从异步关闭事件中恢复。客户端软件应该重新打开传输连接并重新发送中止的请求序列，而无需用户干预，只要请求序列是幂等的（请参见从角度来看，连接在空闲时正在关闭，但是从客户端的角度来看，请求正在进行中。这意味着客户端，服务器和代理必须能够从异步关闭事件中恢复。客户端软件应该重新打开传输连接并重新发送中止的请求序列，而无需用户干预，只要请求序列是幂等的（请参见客户端软件应该重新打开传输连接并重新发送中止的请求序列，而无需用户干预，只要请求序列是幂等的（请参见客户端软件应该重新打开传输连接并重新发送中止的请求序列，而无需用户干预，只要请求序列是幂等的（请参见&lt;a href=&quot;#section-9.1.2&quot;&gt;第9.1.2节&lt;/a&gt;）。尽管用户代理可以为操作员提供重试请求的选择，但是绝对不能自动重试非幂等方法或序列。通过用户代理软件对应用程序进行语义理解的确认可以代替用户确认。如果第二个请求序列失败，则不应重复自动重试。如果可能，服务器应始终对每个连接至少响应一个请求。除非怀疑网络或客户端出现故障，否则服务器不应在传输响应的过程中关闭连接。使用持久性连接的客户端应该限制它们维持给定服务器的同时连接数。单用户客户端不应与任何服务器或代理保持2个以上的连接。代理最多应使用2 * N个连接到另一个服务器或代理的连接，其中N是同时活动用户的数量。这些准则旨在缩短HTTP响应时间并避免拥塞。</target>
        </trans-unit>
        <trans-unit id="7a64cc38406e1e6e386cf9a33c8c4a86744f295f" translate="yes" xml:space="preserve">
          <source>Servers will usually have some timeout value beyond which they will
   no longer maintain an inactive connection.  Proxy servers might make
   this a higher value since it is likely that the client will be making
   more connections through the same proxy server.  The use of
   persistent connections places no requirements on the length (or
   existence) of this timeout for either the client or the server.

   A client or server that wishes to time out SHOULD issue a graceful
   close on the connection.  Implementations SHOULD constantly monitor
   open connections for a received closure signal and respond to it as
   appropriate, since prompt closure of both sides of a connection
   enables allocated system resources to be reclaimed. 

   A client, server, or proxy MAY close the transport connection at any
   time.  For example, a client might have started to send a new request
   at the same time that the server has decided to close the &quot;idle&quot;
   connection.  From the server's point of view, the connection is being
   closed while it was idle, but from the client's point of view, a
   request is in progress.

   A server SHOULD sustain persistent connections, when possible, and
   allow the underlying transport's flow-control mechanisms to resolve
   temporary overloads, rather than terminate connections with the
   expectation that clients will retry.  The latter technique can
   exacerbate network congestion.

   A client sending a message body SHOULD monitor the network connection
   for an error response while it is transmitting the request.  If the
   client sees a response that indicates the server does not wish to
   receive the message body and is closing the connection, the client
   SHOULD immediately cease transmitting the body and close its side of
   the connection.</source>
          <target state="translated">服务器通常会有一些超时值,超过这个值就不会再维持不活动的连接。代理服务器可能会将这个值设置得更高,因为客户端可能会通过同一个代理服务器进行更多的连接。使用持久连接对客户端或服务器的超时长度(或存在)没有要求。希望超时的客户端或服务器应该在连接上发出一个优雅的关闭。实现应该持续监控开放的连接,以接收到关闭信号,并对其做出适当的响应,因为迅速关闭连接的两边可以使分配的系统资源被回收。客户端、服务器或代理可以在任何时候关闭传输连接。例如,在服务器决定关闭 &quot;空闲 &quot;连接的同时,客户端可能已经开始发送一个新请求。从服务器的角度看,连接在空闲时被关闭,但从客户端的角度看,请求正在进行中。在可能的情况下,服务器应该维持持久连接,并允许底层传输的流控制机制来解决暂时的过载问题,而不是终止连接,并期望客户端会重试。后一种技术会加剧网络拥堵。发送消息体的客户端在传输请求时,应该监控网络连接是否有错误响应。如果客户端看到响应表明服务器不希望接收消息体,并正在关闭连接,客户端应立即停止传输消息体,并关闭其一侧的连接。</target>
        </trans-unit>
        <trans-unit id="f5124c99e159587ebe507b56369f65760748f150" translate="yes" xml:space="preserve">
          <source>Serves as a fallback for the other &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Fetch_directive&quot;&gt;fetch directives&lt;/a&gt;.</source>
          <target state="translated">用作其他&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Fetch_directive&quot;&gt;fetch指令&lt;/a&gt;的备用。</target>
        </trans-unit>
        <trans-unit id="c993592eb184660ed131503e2e6e4c8ebc6710fd" translate="yes" xml:space="preserve">
          <source>Service worker registrations (for each service worker registration, execute &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerRegistration/unregister&quot;&gt;&lt;code&gt;ServiceWorkerRegistration.unregister&lt;/code&gt;&lt;/a&gt;),</source>
          <target state="translated">服务人员注册（对于每个服务人员注册，执行&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerRegistration/unregister&quot;&gt; &lt;code&gt;ServiceWorkerRegistration.unregister&lt;/code&gt; &lt;/a&gt;），</target>
        </trans-unit>
        <trans-unit id="53dfe70871da64dc7cc73082fd91fc0d67395965" translate="yes" xml:space="preserve">
          <source>Serving different Web pages or services to different browsers is usually a bad idea. The Web is meant to be accessible to everyone, regardless of which browser or device they're using. There are ways to develop your website to progressively enhance itself based on the availability of features rather than by targeting specific browsers.</source>
          <target state="translated">向不同的浏览器提供不同的网页或服务通常是个坏主意。网络是为了让每个人都能访问,无论他们使用的是哪种浏览器或设备。有一些方法可以开发你的网站,根据功能的可用性逐步增强自己,而不是针对特定的浏览器。</target>
        </trans-unit>
        <trans-unit id="61a0eba4a8c4bcb092cc3e5ed3ca481b331e2273" translate="yes" xml:space="preserve">
          <source>Servo: &lt;a href=&quot;https://github.com/servo/servo/issues/13283&quot;&gt;Issue 13283&lt;/a&gt;</source>
          <target state="translated">伺服：&lt;a href=&quot;https://github.com/servo/servo/issues/13283&quot;&gt;问题13283&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f7f1997c6cd1aa051279675742272a956e7db628" translate="yes" xml:space="preserve">
          <source>Session</source>
          <target state="translated">Session</target>
        </trans-unit>
        <trans-unit id="8fa2a80f7a4a01bb4a4049a65f2e8ab40639ca19" translate="yes" xml:space="preserve">
          <source>Session cookie</source>
          <target state="translated">会话cookie</target>
        </trans-unit>
        <trans-unit id="a5de7556cf7bd4f9692d5121762b926c377ffd0d" translate="yes" xml:space="preserve">
          <source>Session cookies</source>
          <target state="translated">会话cookies</target>
        </trans-unit>
        <trans-unit id="c22669a0c2011d70ebc816a2c115645d58f8ea3a" translate="yes" xml:space="preserve">
          <source>Session cookies will get removed when the client is shut down. They don't specify the &lt;code&gt;Expires&lt;/code&gt; or &lt;code&gt;Max-Age&lt;/code&gt; directives. Note that web browser have often enabled session restoring.</source>
          <target state="translated">客户端关闭时，会话cookie将被删除。他们没有指定 &lt;code&gt;Expires&lt;/code&gt; 或 &lt;code&gt;Max-Age&lt;/code&gt; 指令。请注意，Web浏览器通常启用了会话还原。</target>
        </trans-unit>
        <trans-unit id="0383ce6cf519828e20e353eff1d36e08f759636b" translate="yes" xml:space="preserve">
          <source>Session hijacking and XSS</source>
          <target state="translated">会话劫持和XSS</target>
        </trans-unit>
        <trans-unit id="4d1a0ebf42ea7726af9fc0d443c4219ad98f0b66" translate="yes" xml:space="preserve">
          <source>Session management</source>
          <target state="translated">会话管理</target>
        </trans-unit>
        <trans-unit id="74d939bd156bb2a40d27c5c067b218718f567be0" translate="yes" xml:space="preserve">
          <source>Set by the &lt;em&gt;client&lt;/em&gt; to indicate &quot;do not use the network&quot; for the response. The cache should either respond using a stored response, or respond with a &lt;a href=&quot;../status/504&quot;&gt;&lt;code&gt;504&lt;/code&gt;&lt;/a&gt; status code. Conditional headers such as &lt;code&gt;If-None-Match&lt;/code&gt; should not be set. There is no effect if &lt;code&gt;only-if-cached&lt;/code&gt; is set by a server as part of a response.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da18d02d9a384ec87b2924aa70bb99b190dfa12c" translate="yes" xml:space="preserve">
          <source>Set-Cookie</source>
          <target state="translated">Set-Cookie</target>
        </trans-unit>
        <trans-unit id="e9cace35e90b037b0140e79e5bff9090459aef6c" translate="yes" xml:space="preserve">
          <source>Set-Cookie2</source>
          <target state="translated">Set-Cookie2</target>
        </trans-unit>
        <trans-unit id="ca4cfc1c5db67629db097698126f262a8ff0efa4" translate="yes" xml:space="preserve">
          <source>Setting a proxy for a specific protocol</source>
          <target state="translated">为特定协议设置代理</target>
        </trans-unit>
        <trans-unit id="0a19969b97beb1798bb95f65f7732ae561c43ab8" translate="yes" xml:space="preserve">
          <source>Setting this directive to &lt;code&gt;'none'&lt;/code&gt; is similar to &lt;a href=&quot;../x-frame-options&quot;&gt;&lt;code&gt;X-Frame-Options&lt;/code&gt;&lt;/a&gt;&lt;code&gt;: DENY&lt;/code&gt; (which is also supported in older browers).</source>
          <target state="translated">将此指令设置为 &lt;code&gt;'none'&lt;/code&gt; 类似于&lt;a href=&quot;../x-frame-options&quot;&gt; &lt;code&gt;X-Frame-Options&lt;/code&gt; &lt;/a&gt; &lt;code&gt;: DENY&lt;/code&gt; （在较旧的浏览器中也受支持）。</target>
        </trans-unit>
        <trans-unit id="f20afb2ced2db52eedb85addd06480f621f4772b" translate="yes" xml:space="preserve">
          <source>Setting this directive to &lt;code&gt;'none'&lt;/code&gt; is similar to &lt;a href=&quot;../x-frame-options&quot;&gt;&lt;code&gt;X-Frame-Options&lt;/code&gt;&lt;/a&gt;&lt;code&gt;: deny&lt;/code&gt; (which is also supported in older browsers).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e21c065049ff05b60c6a9ac39caff520e04569d8" translate="yes" xml:space="preserve">
          <source>Setting up your webserver to include the HPKP header</source>
          <target state="translated">设置你的web服务器包含HPKP头文件。</target>
        </trans-unit>
        <trans-unit id="32a560a86e92c09f3625944269ea6a7159c1e2c8" translate="yes" xml:space="preserve">
          <source>Several HTTP headers, called conditional headers, lead to conditional requests. These are:</source>
          <target state="translated">有几个HTTP头信息,称为条件头信息,会导致有条件的请求。它们是:</target>
        </trans-unit>
        <trans-unit id="329eb594c20733b1f610e7cab58a3336e04332ce" translate="yes" xml:space="preserve">
          <source>Several features can be controlled at the same time by sending the HTTP header with a semicolon-separated list of policy directives, or by sending a separate header for each policy.</source>
          <target state="translated">通过发送带有分号分隔的策略指令列表的HTTP头,或者为每个策略发送单独的头,可以同时控制多个功能。</target>
        </trans-unit>
        <trans-unit id="81acc188ecb44fe2b0ca66c680ba970231e66c83" translate="yes" xml:space="preserve">
          <source>Shared proxy caches</source>
          <target state="translated">共享代理缓存</target>
        </trans-unit>
        <trans-unit id="78f6156a2ead82a3ca398616fa6f9e17dfb530a7" translate="yes" xml:space="preserve">
          <source>Short-lived connections</source>
          <target state="translated">短命的联系</target>
        </trans-unit>
        <trans-unit id="f47fe4cbc4ecdf7b89058813c34af535ace87ae1" translate="yes" xml:space="preserve">
          <source>Short-lived connections have two major hitches: the time taken to establish a new connection is significant, and performance of the underlying TCP connection gets better only when this connection has been in use for some time (warm connection). To ease these problems, the concept of a &lt;em&gt;persistent connection&lt;/em&gt; has been designed, even prior to HTTP/1.1. Alternatively this may be called a &lt;em&gt;keep-alive connection&lt;/em&gt;.</source>
          <target state="translated">短期连接有两个主要障碍：建立新连接所花费的时间很长，并且只有当该连接已经使用了一段时间（热连接）时，基础TCP连接的性能才会提高。为了缓解这些问题，甚至在HTTP / 1.1之前，就已经设计了&lt;em&gt;持久连接&lt;/em&gt;的概念。替代地，这可以被称为&lt;em&gt;保持连接&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="c537d8356fd7f996e8605aa03e51f47390d4d7a8" translate="yes" xml:space="preserve">
          <source>Shows and explains the flow of a usual HTTP session.</source>
          <target state="translated">显示并解释一个通常的HTTP会话的流程。</target>
        </trans-unit>
        <trans-unit id="b6521e0115890c1ed8f83a94f59102ecaefa0222" translate="yes" xml:space="preserve">
          <source>Sign out of web site</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41efbf8a181438e8fc19ee9def30f3ef38ba127a" translate="yes" xml:space="preserve">
          <source>Sign-out</source>
          <target state="translated">Sign-out</target>
        </trans-unit>
        <trans-unit id="49ea2b0538dc5d77e0f7d9a719fad7e94390af26" translate="yes" xml:space="preserve">
          <source>Signals to the user agent that compliance with the Certificate Transparency policy should be enforced (rather than only reporting compliance) and that the user agent should refuse future connections that violate its Certificate Transparency policy.</source>
          <target state="translated">向用户代理发出信号,表示应强制执行证书透明度策略的合规性(而不仅仅是报告合规性),用户代理应拒绝未来违反其证书透明度策略的连接。</target>
        </trans-unit>
        <trans-unit id="d8e8cee5872465deb3080e8822404564c2c7c96c" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;headers/if-match&quot;&gt;&lt;code&gt;If-Match&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;headers/if-unmodified-since&quot;&gt;&lt;code&gt;If-Unmodified-Since&lt;/code&gt;&lt;/a&gt;, but can have only one single etag, or one date. If it fails, the range request fails, and instead of a &lt;a href=&quot;status/206&quot;&gt;&lt;code&gt;206&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Partial Content&lt;/code&gt; response, a &lt;a href=&quot;status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt;&lt;code&gt;OK&lt;/code&gt; is sent with the complete resource.</source>
          <target state="translated">与&lt;a href=&quot;headers/if-match&quot;&gt; &lt;code&gt;If-Match&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;headers/if-unmodified-since&quot;&gt; &lt;code&gt;If-Unmodified-Since&lt;/code&gt; &lt;/a&gt;相似，但只能包含一个etag或一个日期。如果失败，则范围请求失败，并且发送&lt;a href=&quot;status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt; &lt;code&gt;OK&lt;/code&gt; 和完整的资源，而不是&lt;a href=&quot;status/206&quot;&gt; &lt;code&gt;206&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Partial Content&lt;/code&gt; 响应。</target>
        </trans-unit>
        <trans-unit id="e46dbd8cd6429badd706773975b6b00d0b709805" translate="yes" xml:space="preserve">
          <source>Similar to the HTTP header, several features can be controlled at the same time by specifying a semicolon-separated list of policy directives.</source>
          <target state="translated">与HTTP头类似,通过指定一个以分号分隔的策略指令列表,可以同时控制多个功能。</target>
        </trans-unit>
        <trans-unit id="1d1d80cfcc4676e37337cc4f5d6a84bedb5462d2" translate="yes" xml:space="preserve">
          <source>Similarly, for binary documents without a specific or known subtype, &lt;code&gt;application/octet-stream&lt;/code&gt; should be used.</source>
          <target state="translated">同样，对于没有特定或已知子类型的二进制文档，应使用 &lt;code&gt;application/octet-stream&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b0a5bca6adaca9564e0b94bdaad3a91197512ef9" translate="yes" xml:space="preserve">
          <source>Similarly, the link element can be used to resolve hostnames without providing a complete URL, but only, by preceding the hostname with two slashes:</source>
          <target state="translated">同样,链接元素也可以用来解析主机名,而不提供完整的URL,只是在主机名前加两个斜杠。</target>
        </trans-unit>
        <trans-unit id="3b3bdb2d208400327aac2b623589a8a18ecdfc8d" translate="yes" xml:space="preserve">
          <source>Simple cross-site requests</source>
          <target state="translated">简单的跨站点请求</target>
        </trans-unit>
        <trans-unit id="2c183543e074fb1a91056f30dcfaf12aabc8df68" translate="yes" xml:space="preserve">
          <source>Simple requests</source>
          <target state="translated">简单的请求</target>
        </trans-unit>
        <trans-unit id="8093dd58a33027a1dce2c902fa777fafd90c9a4e" translate="yes" xml:space="preserve">
          <source>Simple text/plain data</source>
          <target state="translated">简单的文本/普通数据</target>
        </trans-unit>
        <trans-unit id="0edf1fa8008779642e22dc0f34ef947c356e021c" translate="yes" xml:space="preserve">
          <source>Simple text/plain data. Note the use of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/percent-encoding&quot;&gt;percent-encoding&lt;/a&gt; (URL-encoding) for the quote and space characters. Also, for CSV data (MIME type &quot;text/csv&quot;), percent-encoding is needed to preserve the line endings that delimit rows of the spreadsheet.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28ea2b82bad9055a11bf6b84d9f7527a0f5e40f3" translate="yes" xml:space="preserve">
          <source>Simply put, the origin making the request does not match any of the origins permitted by the &lt;a href=&quot;../../headers/access-control-allow-origin&quot;&gt;&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">简而言之，发出请求的原点与&lt;a href=&quot;../../headers/access-control-allow-origin&quot;&gt; &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; &lt;/a&gt;标头允许的任何原点都不匹配。</target>
        </trans-unit>
        <trans-unit id="113900181c81db75435ae6243c0c7016d22cda73" translate="yes" xml:space="preserve">
          <source>Since 2005, the set of APIs available to Web pages greatly increased and several of these APIs created extensions, mostly new specific HTTP headers, to the HTTP protocol for specific purposes:</source>
          <target state="translated">自2005年以来,可用于Web页面的API集大大增加,其中有几个API为特定目的对HTTP协议进行了扩展,大多是新的特定HTTP头。</target>
        </trans-unit>
        <trans-unit id="38b3000a242aaf507c808ecf6b19d0bcb64c3ad2" translate="yes" xml:space="preserve">
          <source>Since HTTP/1.0, different types of content can be transmitted. This article explains how this is accomplished using the &lt;a href=&quot;headers/content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; header and the MIME standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99fb1a5dd25ea500036c8caefba3949cfbcb90c0" translate="yes" xml:space="preserve">
          <source>Since HTTP/1.0, different types of content can be transmitted. This article explains how this is done using the &lt;a href=&quot;headers/content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; header and the MIME standard.</source>
          <target state="translated">从HTTP / 1.0开始，可以传输不同类型的内容。本文介绍了如何使用&lt;a href=&quot;headers/content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt;标头和MIME标准完成此操作。</target>
        </trans-unit>
        <trans-unit id="6a1c0077fb81ec47c18951a65d81853f40257980" translate="yes" xml:space="preserve">
          <source>Since all HTTP entities are represented in HTTP messages as sequences
   of bytes, the concept of a byte range is meaningful for any HTTP
   entity. (However, not all clients and servers need to support byte-
   range operations.)

   Byte range specifications in HTTP apply to the sequence of bytes in
   the entity-body (not necessarily the same as the message-body).

   A byte range operation MAY specify a single range of bytes, or a set
   of ranges within a single entity.

       ranges-specifier = byte-ranges-specifier
       byte-ranges-specifier = bytes-unit &quot;=&quot; byte-range-set
       byte-range-set  = 1#( byte-range-spec | suffix-byte-range-spec )
       byte-range-spec = first-byte-pos &quot;-&quot; [last-byte-pos]
       first-byte-pos  = 1*DIGIT
       last-byte-pos   = 1*DIGIT

   The first-byte-pos value in a byte-range-spec gives the byte-offset
   of the first byte in a range. The last-byte-pos value gives the
   byte-offset of the last byte in the range; that is, the byte
   positions specified are inclusive. Byte offsets start at zero.

   If the last-byte-pos value is present, it MUST be greater than or
   equal to the first-byte-pos in that byte-range-spec, or the byte-
   range-spec is syntactically invalid. The recipient of a byte-range-
   set that includes one or more syntactically invalid byte-range-spec
   values MUST ignore the header field that includes that byte-range-
   set.

   If the last-byte-pos value is absent, or if the value is greater than
   or equal to the current length of the entity-body, last-byte-pos is
   taken to be equal to one less than the current length of the entity-
   body in bytes.

   By its choice of last-byte-pos, a client can limit the number of
   bytes retrieved without knowing the size of the entity. 

       suffix-byte-range-spec = &quot;-&quot; suffix-length
       suffix-length = 1*DIGIT

   A suffix-byte-range-spec is used to specify the suffix of the
   entity-body, of a length given by the suffix-length value. (That is,
   this form specifies the last N bytes of an entity-body.) If the
   entity is shorter than the specified suffix-length, the entire
   entity-body is used.

   If a syntactically valid byte-range-set includes at least one byte-
   range-spec whose first-byte-pos is less than the current length of
   the entity-body, or at least one suffix-byte-range-spec with a non-
   zero suffix-length, then the byte-range-set is satisfiable.
   Otherwise, the byte-range-set is unsatisfiable. If the byte-range-set
   is unsatisfiable, the server SHOULD return a response with a status
   of 416 (Requested range not satisfiable). Otherwise, the server
   SHOULD return a response with a status of 206 (Partial Content)
   containing the satisfiable ranges of the entity-body.

   Examples of byte-ranges-specifier values (assuming an entity-body of
   length 10000):

      - The first 500 bytes (byte offsets 0-499, inclusive):  bytes=0-
        499

      - The second 500 bytes (byte offsets 500-999, inclusive):
        bytes=500-999

      - The final 500 bytes (byte offsets 9500-9999, inclusive):
        bytes=-500

      - Or bytes=9500-

      - The first and last bytes only (bytes 0 and 9999):  bytes=0-0,-1

      - Several legal but not canonical specifications of the second 500
        bytes (byte offsets 500-999, inclusive):
         bytes=500-600,601-999
         bytes=500-700,601-999</source>
          <target state="translated">由于所有的HTTP实体在HTTP消息中都是以字节的序列来表示的,所以字节范围的概念对任何HTTP实体都是有意义的。然而,并不是所有的客户端和服务器都需要支持字节范围操作)。HTTP中的字节范围规范适用于实体主体中的字节序列(不一定与消息主体相同)。一个字节范围操作可以指定一个单一的字节范围,也可以指定一个实体中的一组范围。ranges-specifier=byte-ranges-specifier byte-ranges-specifier=bytes-unit &quot;=&quot; byte-range-set byte-range-set=1#(byte-range-spec | suffix-byte-range-spec)byte-range-spec=first-byte-range-sec byte-pos &quot;-&quot; [last-byte-pos]first-byte-pos=1*DIGIT last-byte-pos=1*DIGIT 字节范围规格中的 first-byte-pos 值给出了范围中第一个字节的字节偏移。最后一个字节-pos值给出了范围内最后一个字节的字节偏移,也就是说,指定的字节位置是包含的。字节偏移量以零开始。如果最后一个字节-pos的值存在,它必须大于或等于该字节范围-规格中的第一个字节-pos,否则字节范围-规格在语法上是无效的。包含一个或多个语法上无效的字节范围-规格值的字节范围-集的接收者必须忽略包含该字节范围-集的头字段。如果last-byte-pos值不存在,或者该值大于或等于实体体的当前长度,last-byte-pos被认为等于实体体的当前长度(以字节为单位)的一个小值。通过对last-byte-pos的选择,客户端可以在不知道实体大小的情况下限制检索的字节数。 suffix-byte-range-spec=&quot;-&quot; suffix-length suffix-length=1*DIGIT 后缀-byte-range-spec用于指定实体主体的后缀,其长度由后缀-length值给出。(也就是说,这种形式指定了实体主体的最后N个字节。)如果实体短于指定的后缀长度,则使用整个实体主体。如果一个语法上有效的字节范围集包括至少一个首字节-pos小于实体-主体当前长度的字节范围-规格,或者至少一个后缀字节-范围-规格的后缀长度非零,那么这个字节范围集是可满足的。否则,该字节范围集是不可满足的。如果字节范围集是不满意的,服务器应该返回一个状态为416(Required range not satisfiable)的响应。否则,服务器SHOULD返回一个状态为206(部分内容)的响应,其中包含实体主体的可满足范围。Byte-ranges-specifier值的例子(假设实体主体的长度为10000):-前500个字节(字节偏移量0-499,包括在内):bytes=0-499-第二个500个字节(字节偏移量500-999,包括在内):bytes=500-999-最后500个字节(字节偏移量9500-9999,包括在内)。bytes=-500-或者 bytes=9500--仅第一和最后一个字节(字节 0 和 9999):bytes=0-0,-1-第二个 500 字节(字节偏移量 500-999,包括在内)的几种合法但不规范的规格:bytes=500-600,601-999 bytes=500-700,601-999。</target>
        </trans-unit>
        <trans-unit id="6477522ed9958316dd956b0c178201d047372002" translate="yes" xml:space="preserve">
          <source>Since both origin servers and caches will compare two validators to
   decide if they represent the same or different entities, one normally
   would expect that if the entity (the entity-body or any entity-
   headers) changes in any way, then the associated validator would
   change as well. If this is true, then we call this validator a
   &quot;strong validator.&quot;

   However, there might be cases when a server prefers to change the
   validator only on semantically significant changes, and not when
   insignificant aspects of the entity change. A validator that does not
   always change when the resource changes is a &quot;weak validator.&quot;

   Entity tags are normally &quot;strong validators,&quot; but the protocol
   provides a mechanism to tag an entity tag as &quot;weak.&quot; One can think of
   a strong validator as one that changes whenever the bits of an entity
   changes, while a weak value changes whenever the meaning of an entity
   changes. Alternatively, one can think of a strong validator as part
   of an identifier for a specific entity, while a weak validator is
   part of an identifier for a set of semantically equivalent entities.

      Note: One example of a strong validator is an integer that is
      incremented in stable storage every time an entity is changed. 

      An entity's modification time, if represented with one-second
      resolution, could be a weak validator, since it is possible that
      the resource might be modified twice during a single second.

      Support for weak validators is optional. However, weak validators
      allow for more efficient caching of equivalent objects; for
      example, a hit counter on a site is probably good enough if it is
      updated every few days or weeks, and any value during that period
      is likely &quot;good enough&quot; to be equivalent.

   A &quot;use&quot; of a validator is either when a client generates a request
   and includes the validator in a validating header field, or when a
   server compares two validators.

   Strong validators are usable in any context. Weak validators are only
   usable in contexts that do not depend on exact equality of an entity.
   For example, either kind is usable for a conditional GET of a full
   entity. However, only a strong validator is usable for a sub-range
   retrieval, since otherwise the client might end up with an internally
   inconsistent entity.

   Clients MAY issue simple (non-subrange) GET requests with either weak
   validators or strong validators. Clients MUST NOT use weak validators
   in other forms of request.

   The only function that the HTTP/1.1 protocol defines on validators is
   comparison. There are two validator comparison functions, depending
   on whether the comparison context allows the use of weak validators
   or not:

      - The strong comparison function: in order to be considered equal,
        both validators MUST be identical in every way, and both MUST
        NOT be weak.

      - The weak comparison function: in order to be considered equal,
        both validators MUST be identical in every way, but either or
        both of them MAY be tagged as &quot;weak&quot; without affecting the
        result.

   An entity tag is strong unless it is explicitly tagged as weak.
   &lt;a href=&quot;#section-3.11&quot;&gt;Section 3.11&lt;/a&gt; gives the syntax for entity tags.

   A Last-Modified time, when used as a validator in a request, is
   implicitly weak unless it is possible to deduce that it is strong,
   using the following rules:

      - The validator is being compared by an origin server to the
        actual current validator for the entity and, 

      - That origin server reliably knows that the associated entity did
        not change twice during the second covered by the presented
        validator.

   or

      - The validator is about to be used by a client in an If-
        Modified-Since or If-Unmodified-Since header, because the client
        has a cache entry for the associated entity, and

      - That cache entry includes a Date value, which gives the time
        when the origin server sent the original response, and

      - The presented Last-Modified time is at least 60 seconds before
        the Date value.

   or

      - The validator is being compared by an intermediate cache to the
        validator stored in its cache entry for the entity, and

      - That cache entry includes a Date value, which gives the time
        when the origin server sent the original response, and

      - The presented Last-Modified time is at least 60 seconds before
        the Date value.

   This method relies on the fact that if two different responses were
   sent by the origin server during the same second, but both had the
   same Last-Modified time, then at least one of those responses would
   have a Date value equal to its Last-Modified time. The arbitrary 60-
   second limit guards against the possibility that the Date and Last-
   Modified values are generated from different clocks, or at somewhat
   different times during the preparation of the response. An
   implementation MAY use a value larger than 60 seconds, if it is
   believed that 60 seconds is too short.

   If a client wishes to perform a sub-range retrieval on a value for
   which it has only a Last-Modified time and no opaque validator, it
   MAY do this only if the Last-Modified time is strong in the sense
   described here.

   A cache or origin server receiving a conditional request, other than
   a full-body GET request, MUST use the strong comparison function to
   evaluate the condition.

   These rules allow HTTP/1.1 caches and clients to safely perform sub-
   range retrievals on values that have been obtained from HTTP/1.0 

   servers.</source>
          <target state="translated">由于原始服务器和缓存都将比较两个验证器来确定它们代表的是相同还是不同的实体，因此通常可以预期，如果实体（实体-主体或任何实体-标头）以任何方式发生变化，则关联的验证器将改变。如果是这样，则我们将此验证器称为&amp;ldquo;强验证器&amp;rdquo;。但是，在某些情况下，服务器可能只希望在语义上有意义的更改上更改验证器，而不是在实体的无关紧要的方面更改时才更改。资源更改时并不总是更改的验证器是&amp;ldquo;弱验证器&amp;rdquo;。实体标签通常是&amp;ldquo;强验证者&amp;rdquo;，但是协议提供了一种将实体标签标记为&amp;ldquo;弱&amp;rdquo;的机制。人们可以将一个强验证器视为一种随实体的位变化而变化的验证器，而一个弱值则随实体的含义变化而变化。备选地，可以将强验证器视为特定实体的标识符的一部分，而弱验证器则是一组语义上等效的实体的标识符的一部分。注意：强验证器的一个示例是一个整数，每次更改实体时，该整数都会在稳定存储中递增。如果实体的修改时间用一秒的分辨率表示，则它可能是一个较弱的验证器，因为有可能在一秒钟内对资源进行两次修改。对弱验证器的支持是可选的。但是，弱验证器可以更有效地缓存等效对象。例如，如果某个站点上的点击计数器每隔几天或几周更新一次，那么它可能就足够好了，并且在此期间内的任何值都可能&amp;ldquo;足够好&amp;rdquo;，可以等效。验证器的&amp;ldquo;使用&amp;rdquo;是在客户端生成请求并将验证器包括在验证头字段中时，或者在服务器比较两个验证器时。强大的验证器可在任何情况下使用。弱验证器仅在不依赖于实体的完全相等的上下文中可用。例如，任何一种都可用于完整实体的条件GET。但是，只有强大的验证器才能用于子范围检索，因为否则客户端可能会最终获得内部不一致的实体。客户可以用弱验证者或强验证者发出简单的（非子范围的）GET请求。客户不得在其他形式的请求中使用弱验证器。 HTTP / 1.1协议在验证器上定义的唯一功能是比较。有两个验证器比较函数，具体取决于比较上下文是否允许使用弱验证器：-强比较函数：为了被视为相等，两个验证器在每种方式上都必须相同，并且都不得弱。 -弱比较功能：为了被认为相等，两个验证器在每种方式上都必须相同，但是可以将其中一个或两个都标记为&amp;ldquo;弱&amp;rdquo;而不影响结果。除非将实体标记明确标记为弱，否则实体标记是强标记。 &lt;a href=&quot;#section-3.11&quot;&gt;第3.11节&lt;/a&gt;给出实体标签的语法。除非可以使用以下规则推断出Last-Modified时间是可靠的，否则Last-Modified时间在请求中用作隐式弱函数，除非可以通过以下规则推断出它是强壮的： -原始服务器可靠地知道关联实体在所提供的验证程序覆盖的第二秒内没有两次更改。或-客户端将在If-Modified-Since或If-Unified-Since标头中使用验证器，因为客户端具有关联实体的缓存条目，并且-该缓存条​​目包括Date值，该值给出原始服务器发送原始响应的时间，-所显示的&amp;ldquo;上次修改时间&amp;rdquo;至少在&amp;ldquo;日期&amp;rdquo;值之前60秒。或-中间缓存将验证器与存储在该实体的缓存项中的验证器进行比较，并且-该缓存项包含一个Date值，该值给出了原始服务器发送原始响应的时间，以及-最后修改时间至少是日期值之前的60秒。此方法依赖于以下事实：如果原始服务器在同一秒内发送了两个不同的响应，但是两者的Last-Modified时间相同，则这些响应中至少有一个Date值等于其Last-Modified。时间。任意的60秒限制可防止在准备响应期间从不同的时钟或在某些不同的时间生成Date和Last-Modified值的可能性。如果认为60秒太短，则实现可以使用大于60秒的值。如果客户希望对只有最后修改时间且没有不透明验证器的值执行子范围检索，则仅当此处所述意义上的最后修改时间强时，客户才可以执行此操作。接收到条件请求（而不是全身GET请求）的高速缓存或原始服务器必须使用强比较功能来评估条件。这些规则允许HTTP / 1。1个缓存和客户端可以安全地对从HTTP / 1.0服务器获得的值执行子范围检索。</target>
        </trans-unit>
        <trans-unit id="b5e7d8ecc2e2bfd0337480eba5175d544e816618" translate="yes" xml:space="preserve">
          <source>Since by definition the actual function performed by POST is
   determined by the server and often depends on the particular
   resource, the behavior of POST when applied to collections cannot be
   meaningfully modified because it is largely undefined.  Thus, the
   semantics of POST are unmodified when applied to a collection.</source>
          <target state="translated">由于根据定义,POST实际执行的功能是由服务器决定的,并且通常取决于特定的资源,所以当POST应用于集合时,其行为不能被有意义地修改,因为它在很大程度上没有被定义。因此,当应用于集合时,POST的语义是无法修改的。</target>
        </trans-unit>
        <trans-unit id="6b8845c337661637cd002489923ad6132dc450c6" translate="yes" xml:space="preserve">
          <source>Since origin servers do not always provide explicit expiration times,
   HTTP caches typically assign heuristic expiration times, employing
   algorithms that use other header values (such as the Last-Modified
   time) to estimate a plausible expiration time. The HTTP/1.1
   specification does not provide specific algorithms, but does impose
   worst-case constraints on their results. Since heuristic expiration
   times might compromise semantic transparency, they ought to used
   cautiously, and we encourage origin servers to provide explicit
   expiration times as much as possible.</source>
          <target state="translated">由于源服务器并不总是提供明确的过期时间,HTTP缓存通常会分配启发式的过期时间,采用使用其他头值(如Last-Modified时间)的算法来估计一个合理的过期时间。HTTP/1.1规范没有提供具体的算法,但对其结果施加了最坏情况的限制。由于启发式过期时间可能会影响语义的透明度,因此应该谨慎使用,我们鼓励源服务器尽可能提供明确的过期时间。</target>
        </trans-unit>
        <trans-unit id="28a6db603d3e3f168ecb1f550fddcf24914727e1" translate="yes" xml:space="preserve">
          <source>Since origin servers do not always provide explicit expiration times,
   a cache MAY assign a heuristic expiration time when an explicit time
   is not specified, employing algorithms that use other header field
   values (such as the Last-Modified time) to estimate a plausible
   expiration time.  This specification does not provide specific
   algorithms, but does impose worst-case constraints on their results.

   A cache MUST NOT use heuristics to determine freshness when an
   explicit expiration time is present in the stored response.  Because
   of the requirements in &lt;a href=&quot;#section-3&quot;&gt;Section 3&lt;/a&gt;, this means that, effectively,
   heuristics can only be used on responses without explicit freshness
   whose status codes are defined as cacheable by default (see &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6.1&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6.1&quot;&gt;6.1 of [RFC7231]&lt;/a&gt;), and those responses without explicit freshness
   that have been marked as explicitly cacheable (e.g., with a &quot;public&quot;
   response directive).

   If the response has a Last-Modified header field (&lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.2&quot;&gt;Section&amp;nbsp;2.2 of
   [RFC7232]&lt;/a&gt;), caches are encouraged to use a heuristic expiration value
   that is no more than some fraction of the interval since that time.
   A typical setting of this fraction might be 10%.

   When a heuristic is used to calculate freshness lifetime, a cache
   SHOULD generate a Warning header field with a 113 warn-code (see
   &lt;a href=&quot;#section-5.5.4&quot;&gt;Section 5.5.4&lt;/a&gt;) in the response if its current_age is more than 24
   hours and such a warning is not already present.

      Note: &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-13.9&quot;&gt;Section&amp;nbsp;13.9 of [RFC2616]&lt;/a&gt; prohibited caches from calculating
      heuristic freshness for URIs with query components (i.e., those
      containing '?').  In practice, this has not been widely
      implemented.  Therefore, origin servers are encouraged to send
      explicit directives (e.g., Cache-Control: no-cache) if they wish
      to preclude caching.</source>
          <target state="translated">由于原始服务器并不总是提供明确的到期时间，因此在未指定明确时间的情况下，缓存可以分配启发式到期时间，采用使用其他报头字段值（例如Last-Modified time）的算法来估计可能的到期时间。 。该规范未提供特定的算法，但对结果施加了最坏情况的约束。当存储的响应中存在明确的到期时间时，缓存不得使用启发式方法来确定新鲜度。由于&lt;a href=&quot;#section-3&quot;&gt;第3节&lt;/a&gt;中的要求，这意味着有效地，启发式方法只能用于没有明确新鲜度的响应，默认状态下状态定义为可缓存（见&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6.1&quot;&gt;[RFC7231] 6.1 &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6.1&quot;&gt;节&lt;/a&gt;）），而那些没有明确新鲜度的响应已被标记为可显式缓存（例如，使用&amp;ldquo; public&amp;rdquo;响应指令）。如果响应具有Last-Modified头字段（&lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.2&quot;&gt;[RFC7232]的2.2节&lt;/a&gt;），则鼓励缓存使用启发式到期值，该值不超过该时间间隔的一部分。该比例的典型设置可能是10％。当使用启发式方法来计算新鲜度寿命时，如果current_age超过24小时并且该警告尚不存在，则缓存应在响应中生成带有113警告代码的Warning标头字段（请参见 &lt;a href=&quot;#section-5.5.4&quot;&gt;5.5.4节&lt;/a&gt;）。 。注意：&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-13.9&quot;&gt;[RFC2616]的13.9节&lt;/a&gt;禁止缓存计算具有查询组件（即那些包含&amp;ldquo;？&amp;rdquo;的URI）的启发式新鲜度。实际上，这尚未得到广泛实施。因此，如果原始服务器希望避免缓存，则鼓励它们发送显式指令（例如，Cache-Control：no-cache）。</target>
        </trans-unit>
        <trans-unit id="509ec028b2372cca14a02773e4ddea3d5e0dcfb9" translate="yes" xml:space="preserve">
          <source>Since property values are typically used to hold information such as
   the author of a document, there is the possibility that privacy
   concerns could arise stemming from widespread access to a resource's
   property data.  To reduce the risk of inadvertent release of private
   information via properties, servers are encouraged to develop access
   control mechanisms that separate read access to the resource body and
   read access to the resource's properties.  This allows a user to
   control the dissemination of their property data without overly
   restricting access to the resource's contents.</source>
          <target state="translated">由于属性值通常用于保存文件作者等信息,因此,广泛访问资源的属性数据可能会引起隐私问题。为了降低通过属性无意中发布隐私信息的风险,我们鼓励服务器开发访问控制机制,将资源主体的读取访问和资源属性的读取访问分开。这样,用户就可以控制其属性数据的传播,而不会过分限制对资源内容的访问。</target>
        </trans-unit>
        <trans-unit id="cbc586157b2e078cf31d317a4f20a745527f123b" translate="yes" xml:space="preserve">
          <source>Since representation data is transferred in payloads as a sequence of
   octets, a byte range is a meaningful substructure for any
   representation transferable over HTTP (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-3&quot;&gt;Section&amp;nbsp;3 of [RFC7231]&lt;/a&gt;).  The
   &quot;bytes&quot; range unit is defined for expressing subranges of the data's
   octet sequence.

     bytes-unit       = &quot;bytes&quot;

   A byte-range request can specify a single range of bytes or a set of
   ranges within a single representation.

     byte-ranges-specifier = bytes-unit &quot;=&quot; byte-range-set
     byte-range-set  = 1#( byte-range-spec / suffix-byte-range-spec )
     byte-range-spec = first-byte-pos &quot;-&quot; [ last-byte-pos ]
     first-byte-pos  = 1*DIGIT
     last-byte-pos   = 1*DIGIT

   The first-byte-pos value in a byte-range-spec gives the byte-offset
   of the first byte in a range.  The last-byte-pos value gives the
   byte-offset of the last byte in the range; that is, the byte
   positions specified are inclusive.  Byte offsets start at zero.

   Examples of byte-ranges-specifier values:

   o  The first 500 bytes (byte offsets 0-499, inclusive):

        bytes=0-499

   o  The second 500 bytes (byte offsets 500-999, inclusive):

        bytes=500-999 

   A byte-range-spec is invalid if the last-byte-pos value is present
   and less than the first-byte-pos.

   A client can limit the number of bytes requested without knowing the
   size of the selected representation.  If the last-byte-pos value is
   absent, or if the value is greater than or equal to the current
   length of the representation data, the byte range is interpreted as
   the remainder of the representation (i.e., the server replaces the
   value of last-byte-pos with a value that is one less than the current
   length of the selected representation).

   A client can request the last N bytes of the selected representation
   using a suffix-byte-range-spec.

     suffix-byte-range-spec = &quot;-&quot; suffix-length
     suffix-length = 1*DIGIT

   If the selected representation is shorter than the specified
   suffix-length, the entire representation is used.

   Additional examples, assuming a representation of length 10000:

   o  The final 500 bytes (byte offsets 9500-9999, inclusive):

        bytes=-500

   Or:

        bytes=9500-

   o  The first and last bytes only (bytes 0 and 9999):

        bytes=0-0,-1

   o  Other valid (but not canonical) specifications of the second 500
      bytes (byte offsets 500-999, inclusive):

        bytes=500-600,601-999
        bytes=500-700,601-999

   If a valid byte-range-set includes at least one byte-range-spec with
   a first-byte-pos that is less than the current length of the
   representation, or at least one suffix-byte-range-spec with a
   non-zero suffix-length, then the byte-range-set is satisfiable.
   Otherwise, the byte-range-set is unsatisfiable. 

   In the byte-range syntax, first-byte-pos, last-byte-pos, and
   suffix-length are expressed as decimal number of octets.  Since there
   is no predefined limit to the length of a payload, recipients MUST
   anticipate potentially large decimal numerals and prevent parsing
   errors due to integer conversion overflows.</source>
          <target state="translated">由于表示形式的数据作为八位字节序列在有效载荷中传输，因此字节范围对于任何可通过HTTP传输的表示形式都是有意义的子结构（&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-3&quot;&gt;[RFC7231]第3节&lt;/a&gt;）。定义了&amp;ldquo;字节&amp;rdquo;范围单位，用于表示数据八位位组序列的子范围。 bytes-unit =&amp;ldquo; bytes&amp;rdquo;字节范围请求可以指定单个字节范围或单个表示形式内的一组范围。字节范围说明符=字节单位&amp;ldquo; =&amp;rdquo;字节范围设置字节范围设置= 1＃（字节范围说明/后缀字节范围说明）字节范围说明=第一个字节说明pos&amp;ldquo;-&amp;rdquo; [last-byte-pos] first-byte-pos = 1 * DIGIT last-byte-pos = 1 * DIGIT字节范围规范中的first-byte-pos值给出了字节偏移量范围中的第一个字节。 last-byte-pos值给出范围中最后一个字节的字节偏移量；也就是说，指定的字节位置包括在内。字节偏移量从零开始。字节范围指定符值的示例：o前500个字节（字节偏移量为0-499，含0和499）：bytes = 0-499 o后500个字节（字节偏移量为500-999，含两个字节）：bytes = 500-999如果字节范围规范无效存在last-byte-pos值，并且小于第一个byte-pos。客户端可以限制请求的字节数，而无需知道所选表示形式的大小。如果不存在last-byte-pos值，或者该值大于或等于表示形式数据的当前长度，则将字节范围解释为表示形式的其余部分（即，服务器替换last的值） -byte-pos，其值比所选表示形式的当前长度小1）。客户端可以使用后缀字节范围规范来请求所选表示形式的最后N个字节。suffix-byte-range-spec =&amp;ldquo;-&amp;rdquo;后缀长度suffix-length = 1 * DIGIT如果所选表示形式短于指定的后缀长度，则使用整个表示形式。其他示例，假设长度为10000：o最后的500个字节（字节偏移量9500-9999，包括端值）：bytes = -500或：bytes = 9500- o仅第一个和最后一个字节（字节0和9999）：字节= 0-0，-1 o第二个500字节的其他有效（但不是规范性的）规范（字节偏移500-999，包括端点）：bytes = 500-600,601-999 bytes = 500-700,601-999如果有效字节为- range-set包含至少一个byte-range-spec，且first-byte-pos小于表示形式的当前长度，或至少一个后缀长度范围不为零的后缀字节范围规范，则该字节范围集可满足要求。否则，字节范围设置将无法满足。在字节范围语法中，第一个字节位置，最后一个字节位置和后缀长度表示为八位字节的十进制数。由于有效载荷的长度没有预定义的限制，因此接收者必须预见潜在的大十进制数字，并防止由于整数转换溢出而引起的解析错误。接收者必须预料潜在的大十进制数字，并防止由于整数转换溢出而引起的解析错误。接收者必须预料潜在的大十进制数字，并防止由于整数转换溢出而引起的解析错误。</target>
        </trans-unit>
        <trans-unit id="774d5768b3cb89b1969b07ba3f6b81f799741b41" translate="yes" xml:space="preserve">
          <source>Since server lock support is optional, a client trying to lock a
   resource on a server can either try the lock and hope for the best,
   or perform some form of discovery to determine what lock capabilities
   the server supports.  This is known as lock capability discovery.  A
   client can determine what lock types the server supports by
   retrieving the DAV:supportedlock property.

   Any DAV-compliant resource that supports the LOCK method MUST support
   the DAV:supportedlock property.</source>
          <target state="translated">由于服务器锁的支持是可选的,因此,试图在服务器上锁定资源的客户端可以尝试锁定并希望得到最好的结果,或者执行某种形式的发现来确定服务器支持什么锁能力。这就是所谓的锁能力发现。客户端可以通过检索DAV:supportedlock属性来确定服务器支持的锁类型。任何支持LOCK方法的DAV兼容资源都必须支持DAV:supportedlock属性。</target>
        </trans-unit>
        <trans-unit id="94a8f31f5d75fba5bea69bbed106207fdc98fadf" translate="yes" xml:space="preserve">
          <source>Since the &quot;http&quot; and &quot;https&quot; schemes conform to the URI generic
   syntax, such URIs are normalized and compared according to the
   algorithm defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-6&quot;&gt;Section&amp;nbsp;6 of [RFC3986]&lt;/a&gt;, using the defaults
   described above for each scheme.

   If the port is equal to the default port for a scheme, the normal
   form is to omit the port subcomponent.  When not being used in
   absolute form as the request target of an OPTIONS request, an empty
   path component is equivalent to an absolute path of &quot;/&quot;, so the
   normal form is to provide a path of &quot;/&quot; instead.  The scheme and host
   are case-insensitive and normally provided in lowercase; all other
   components are compared in a case-sensitive manner.  Characters other
   than those in the &quot;reserved&quot; set are equivalent to their
   percent-encoded octets: the normal form is to not encode them (see
   Sections &lt;a href=&quot;#section-2.1&quot;&gt;2.1&lt;/a&gt; and &lt;a href=&quot;#section-2.2&quot;&gt;2.2&lt;/a&gt; of [&lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt;]).

   For example, the following three URIs are equivalent:

      &lt;a href=&quot;http://example.com:80/~smith/home.html&quot;&gt;http://example.com:80/~smith/home.html&lt;/a&gt;
      http://EXAMPLE.com/%7Esmith/home.html
      &lt;a href=&quot;http://EXAMPLE.com/%7esmith/home.html&quot;&gt;http://EXAMPLE.com:/%7esmith/home.html&lt;/a&gt;</source>
          <target state="translated">由于&amp;ldquo; http&amp;rdquo;和&amp;ldquo; https&amp;rdquo;方案符合URI通用语法，因此这些URI将根据&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-6&quot;&gt;[RFC3986]第6节中&lt;/a&gt;定义的算法进行规范化和比较，对每个方案使用上述默认值。如果端口等于方案的默认端口，则通常的形式是忽略端口子组件。当不以绝对形式将其用作OPTIONS请求的请求目标时，空路径组件等效于绝对路径&amp;ldquo; /&amp;rdquo;，因此通常的形式是提供路径&amp;ldquo; /&amp;rdquo;。方案和主机不区分大小写，通常以小写形式提供；所有其他组件都以区分大小写的方式进行比较。除&amp;ldquo;保留&amp;rdquo;集中的字符外的其他字符等效于其百分比编码的八位字节：正常形式是不对其进行编码（请参阅[ &lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986的&lt;/a&gt;&lt;a href=&quot;#section-2.1&quot;&gt;2.1&lt;/a&gt;和&lt;a href=&quot;#section-2.2&quot;&gt;2.2&lt;/a&gt;节]）。例如，以下三个URI是等效的：&lt;a href=&quot;http://example.com:80/~smith/home.html&quot;&gt;http&lt;/a&gt; : //example.com : 80/~ &lt;a href=&quot;http://EXAMPLE.com/%7esmith/home.html&quot;&gt;smith/&lt;/a&gt; home.html http://EXAMPLE.com/%7Esmith/home.html http://EXAMPLE.com:/% 7esmith / home.html</target>
        </trans-unit>
        <trans-unit id="3878be391d0341c64c35b2c3bb2ccfa884cc0a3f" translate="yes" xml:space="preserve">
          <source>Since the request-target often contains only part of the user agent's
   target URI, a server reconstructs the intended target as an
   &quot;effective request URI&quot; to properly service the request.  This
   reconstruction involves both the server's local configuration and
   information communicated in the request-target, Host header field,
   and connection context.

   For a user agent, the effective request URI is the target URI.

   If the request-target is in absolute-form, the effective request URI
   is the same as the request-target.  Otherwise, the effective request
   URI is constructed as follows:

      If the server's configuration (or outbound gateway) provides a
      fixed URI scheme, that scheme is used for the effective request
      URI.  Otherwise, if the request is received over a TLS-secured TCP
      connection, the effective request URI's scheme is &quot;https&quot;; if not,
      the scheme is &quot;http&quot;.

      If the server's configuration (or outbound gateway) provides a
      fixed URI authority component, that authority is used for the
      effective request URI.  If not, then if the request-target is in
      authority-form, the effective request URI's authority component is
      the same as the request-target.  If not, then if a Host header
      field is supplied with a non-empty field-value, the authority
      component is the same as the Host field-value.  Otherwise, the
      authority component is assigned the default name configured for
      the server and, if the connection's incoming TCP port number
      differs from the default port for the effective request URI's
      scheme, then a colon (&quot;:&quot;) and the incoming port number (in
      decimal form) are appended to the authority component.

      If the request-target is in authority-form or asterisk-form, the
      effective request URI's combined path and query component is
      empty.  Otherwise, the combined path and query component is the
      same as the request-target.

      The components of the effective request URI, once determined as
      above, can be combined into absolute-URI form by concatenating the
      scheme, &quot;://&quot;, authority, and combined path and query component. 

   Example 1: the following message received over an insecure TCP
   connection

     GET /pub/WWW/TheProject.html HTTP/1.1
     Host: www.example.org:8080

   has an effective request URI of

     &lt;a href=&quot;http://www.example.org:8080/pub/WWW/TheProject.html&quot;&gt;http://www.example.org:8080/pub/WWW/TheProject.html&lt;/a&gt;

   Example 2: the following message received over a TLS-secured TCP
   connection

     OPTIONS * HTTP/1.1
     Host: www.example.org

   has an effective request URI of

     https://www.example.org

   Recipients of an HTTP/1.0 request that lacks a Host header field
   might need to use heuristics (e.g., examination of the URI path for
   something unique to a particular host) in order to guess the
   effective request URI's authority component.

   Once the effective request URI has been constructed, an origin server
   needs to decide whether or not to provide service for that URI via
   the connection in which the request was received.  For example, the
   request might have been misdirected, deliberately or accidentally,
   such that the information within a received request-target or Host
   header field differs from the host or port upon which the connection
   has been made.  If the connection is from a trusted gateway, that
   inconsistency might be expected; otherwise, it might indicate an
   attempt to bypass security filters, trick the server into delivering
   non-public content, or poison a cache.  See &lt;a href=&quot;#section-9&quot;&gt;Section 9&lt;/a&gt; for security
   considerations regarding message routing.</source>
          <target state="translated">由于请求目标通常仅包含用户代理的目标URI的一部分，因此服务器会将预期目标重构为&amp;ldquo;有效请求URI&amp;rdquo;，以正确地为请求提供服务。这种重建涉及服务器的本地配置以及在请求目标，主机标头字段和连接上下文中传递的信息。对于用户代理，有效请求URI是目标URI。如果请求目标为绝对形式，则有效请求URI与请求目标相同。否则，有效请求URI的构造如下：如果服务器的配置（或出站网关）提供了固定的URI方案，则该方案将用于有效请求URI。除此以外，如果请求是通过TLS保护的TCP连接接收的，则有效请求URI的方案为&amp;ldquo; https&amp;rdquo;；如果不是，则方案为&amp;ldquo; http&amp;rdquo;。如果服务器的配置（或出站网关）提供了固定的URI权限组件，则该权限将用于有效的请求URI。如果不是，则如果请求目标为授权形式，则有效请求URI的授权组成部分与请求目标相同。如果不是，则如果为Host标头字段提供了非空字段值，则授权组件与Host字段值相同。否则，将为授权组件分配为服务器配置的默认名称，如果连接&amp;ldquo;s输入的TCP端口号与有效请求URI方案的默认端口不同，然后将冒号（&amp;ldquo;：&amp;rdquo;）和输入的端口号（以十进制形式）附加到权限组件。如果请求目标采用授权形式或星号形式，则有效请求URI的组合路径和查询组件为空。否则，组合的路径和查询组件与请求目标相同。一旦如上所述确定了有效请求URI的组件，就可以通过将方案，&amp;ldquo;：//&amp;rdquo;，权限以及组合的路径和查询组件串联起来，将其组合成绝对URI形式。示例1：通过不安全的TCP连接收到以下消息GET /pub/WWW/TheProject.html HTTP / 1.1主机：www.example。org：8080的有效请求URI为 &lt;a href=&quot;http://www.example.org:8080/pub/WWW/TheProject.html&quot;&gt;http://www.example.org:8080/pub/WWW/TheProject.html&lt;/a&gt; 示例2：通过TLS保护的TCP连接接收到以下消息选项* HTTP / 1.1主机：www.example.org的有效请求URI为https://www.example.org没有HTTP / 1.0请求的收件人主机头字段可能需要使用试探法（例如，检查URI路径中特定于特定主机的唯一内容），以便猜测有效请求URI的权限组件。构造有效请求URI后，源服务器需要决定是否通过接收请求的连接为该URI提供服务。例如，该请求可能是有意或无意中被误导了，这样，接收到的请求目标或主机标头字段中的信息就会与建立连接的主机或端口不同。如果连接来自受信任的网关，则可能会出现不一致的情况。否则，这可能表示企图绕过安全过滤器，诱骗服务器传递非公共内容或破坏高速缓存。看到&lt;a href=&quot;#section-9&quot;&gt;&lt;/a&gt;有关消息路由的安全注意事项，请参阅第9节。</target>
        </trans-unit>
        <trans-unit id="a531f36cb52973a36d35f55d654a8d428773bf1d" translate="yes" xml:space="preserve">
          <source>Since this document describes a set of extensions to the HTTP/1.1
   protocol, the augmented BNF used herein to describe protocol elements
   is exactly the same as described in &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-2.1&quot;&gt;Section&amp;nbsp;2.1 of [RFC2616]&lt;/a&gt;,
   including the rules about implied linear whitespace.  Since this
   augmented BNF uses the basic production rules provided in &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-2.2&quot;&gt;Section&amp;nbsp;2.2
   of [RFC2616]&lt;/a&gt;, these rules apply to this document as well.  Note this
   is not the standard BNF syntax used in other RFCs.

   The key words &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;,
   &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;MAY&quot;, and &quot;OPTIONAL&quot; in this
   document are to be interpreted as described in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC2119&lt;/a&gt;].

   Note that in natural language, a property like the &quot;creationdate&quot;
   property in the &quot;DAV:&quot; XML namespace is sometimes referred to as
   &quot;DAV:creationdate&quot; for brevity.</source>
          <target state="translated">由于该文档描述了HTTP / 1.1协议的一组扩展，因此本文中用于描述协议元素的增强BNF &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-2.1&quot;&gt;与[RFC2616]的2.1节中&lt;/a&gt;所描述的完全相同，包括有关隐含线性空白的规则。由于此增强的BNF使用&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-2.2&quot;&gt;[RFC2616]第2.2节中&lt;/a&gt;提供的基本生产规则，因此这些规则也适用于本文档。请注意，这不是其他RFC中使用的标准BNF语法。本文档中的关键字&amp;ldquo;必须&amp;rdquo;，&amp;ldquo;不得&amp;rdquo;，&amp;ldquo;必须&amp;rdquo;，&amp;ldquo;应&amp;rdquo;，&amp;ldquo;应禁止&amp;rdquo;，&amp;ldquo;应&amp;rdquo;，&amp;ldquo;不应&amp;rdquo;，&amp;ldquo;推荐&amp;rdquo;，&amp;ldquo;可以&amp;rdquo;和&amp;ldquo;可选&amp;rdquo;是如[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC2119中所述&lt;/a&gt;]。请注意，在自然语言中，为简洁起见，有时将诸如&amp;ldquo; DAV：&amp;rdquo; XML名称空间中的&amp;ldquo; creationdate&amp;rdquo;属性之类的属性称为&amp;ldquo; DAV：creationdate&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="6ed1ccbe5b50342757a2d3ea53224582ca419bad" translate="yes" xml:space="preserve">
          <source>Since version 4.1, Klar for Android uses the same UA string as &lt;a href=&quot;#Focus_for_Android&quot;&gt;Focus for Android&lt;/a&gt;. Before version 4.1, it sent a &lt;var&gt;Klar/&amp;lt;version&amp;gt;&lt;/var&gt;&lt;var&gt;product/version&lt;/var&gt; token.</source>
          <target state="translated">从4.1版开始，Android的Klar与Android的&lt;a href=&quot;#Focus_for_Android&quot;&gt;Focus&lt;/a&gt;使用相同的UA字符串。在4.1版之前，它发送了 &lt;var&gt;Klar/&amp;lt;version&amp;gt;&lt;/var&gt; &lt;var&gt;product/version&lt;/var&gt; 令牌。</target>
        </trans-unit>
        <trans-unit id="f2e4d9b56d7689a1ae584bddcddb038ff0772c38" translate="yes" xml:space="preserve">
          <source>Since your domain isn't &lt;code&gt;example.com&lt;/code&gt;, a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base&quot;&gt;&lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt;&lt;/a&gt; element with its &lt;code&gt;href&lt;/code&gt; set to &lt;code&gt;https://example.com&lt;/code&gt; will result in a CSP violation.</source>
          <target state="translated">由于您的域不是 &lt;code&gt;example.com&lt;/code&gt; ，其 &lt;code&gt;href&lt;/code&gt; 设置为 &lt;code&gt;https://example.com&lt;/code&gt; 的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base&quot;&gt; &lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt; &lt;/a&gt;元素将导致CSP违规。</target>
        </trans-unit>
        <trans-unit id="0a9315f35220268432d25d79a4154c7f1eccd789" translate="yes" xml:space="preserve">
          <source>Single part ranges</source>
          <target state="translated">单一部件范围</target>
        </trans-unit>
        <trans-unit id="6e08a5615f12f6057b7ff9d9ceecce7b3562aacc" translate="yes" xml:space="preserve">
          <source>Single-resource bodies, consisting of a single file of known length, defined by the two headers: &lt;a href=&quot;headers/content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;headers/content-length&quot;&gt;&lt;code&gt;Content-Length&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">单一资源主体，由两个长度分别为&lt;a href=&quot;headers/content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;headers/content-length&quot;&gt; &lt;code&gt;Content-Length&lt;/code&gt; 的&lt;/a&gt;标头定义，该文件由已知长度的单个文件组成。</target>
        </trans-unit>
        <trans-unit id="9f99f82fdece07fba6789c9308f7b0c3bc7a0e91" translate="yes" xml:space="preserve">
          <source>Single-resource bodies, consisting of a single file of unknown length, encoded by chunks with &lt;a href=&quot;headers/transfer-encoding&quot;&gt;&lt;code&gt;Transfer-Encoding&lt;/code&gt;&lt;/a&gt; set to &lt;code&gt;chunked&lt;/code&gt;.</source>
          <target state="translated">单资源主体，由长度未知的单个文件组成，由块编码，&lt;a href=&quot;headers/transfer-encoding&quot;&gt; &lt;code&gt;Transfer-Encoding&lt;/code&gt; &lt;/a&gt;设置为 &lt;code&gt;chunked&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d60483a13a434ebf8efec0b71ca52e651ce1040b" translate="yes" xml:space="preserve">
          <source>Single-resource bodies, consisting of one single file, defined by the two headers: &lt;a href=&quot;headers/content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;headers/content-length&quot;&gt;&lt;code&gt;Content-Length&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">单资源主体，由一个文件组成，由两个标头定义：&lt;a href=&quot;headers/content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;headers/content-length&quot;&gt; &lt;code&gt;Content-Length&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="762d05cd3ee1357a02893672cf750fd1659a4eed" translate="yes" xml:space="preserve">
          <source>Site security testers usually expect this header to be set.</source>
          <target state="translated">网站安全测试人员通常希望设置这个头。</target>
        </trans-unit>
        <trans-unit id="88a34e382ce47cacc14889b5eb99b2deb9447680" translate="yes" xml:space="preserve">
          <source>Slug is an HTTP entity-header whose presence in a POST to a
   Collection constitutes a request by the client to use the header's
   value as part of any URIs that would normally be used to retrieve the
   to-be-created Entry or Media Resources.

   Servers MAY use the value of the Slug header when creating the Member
   URI of the newly created Resource, for instance, by using some or all
   of the words in the value for the last URI segment.  Servers MAY also
   use the value when creating the atom:id, or as the title of a Media
   Link Entry (see &lt;a href=&quot;#section-9.6&quot;&gt;Section 9.6&lt;/a&gt;). 

   Servers MAY choose to ignore the Slug entity-header.  Servers MAY
   alter the header value before using it.  For instance, a server might
   filter out some characters or replace accented letters with non-
   accented ones, replace spaces with underscores, change case, and so
   on.</source>
          <target state="translated">Slug是一个HTTP实体标头，其存在于POST的Collection中构成了客户端的请求，要求将标头的值用作所有URI（通常用于检索要创建的条目或媒体资源）的一部分。当创建新创建的资源的成员URI时，服务器可以使用Slug标头的值，例如，通过使用最后URI段的值中的某些或全部单词。服务器在创建atom：id时也可以使用该值，或者用作媒体链接条目的标题（参见&lt;a href=&quot;#section-9.6&quot;&gt;9.6节）。&lt;/a&gt;）。服务器可以选择忽略Slug实体头。服务器可以在使用头信息之前改变头信息。例如，服务器可能会过滤掉某些字符或将重音字母替换为非重音字母，将空格替换为下划线，更改大小写等。</target>
        </trans-unit>
        <trans-unit id="bbc575596897043101f8f28bb8d15019ccb43ccd" translate="yes" xml:space="preserve">
          <source>So until all browsers catch up with the spec, you may be able to work around this limitation by doing one or both of the following:</source>
          <target state="translated">因此,在所有的浏览器跟上规范之前,你可以通过以下一个或两个方法来解决这个限制。</target>
        </trans-unit>
        <trans-unit id="037a3b178c5c3fa1e2c3af1bd926bf5f5c93704e" translate="yes" xml:space="preserve">
          <source>So, choose one of your domains as your canonical one! There are two techniques below to allow the non-canonical domain to work still.</source>
          <target state="translated">所以,选择其中一个域名作为你的正统域名吧! 下面有两种技术可以让非正统域名仍然可以工作。</target>
        </trans-unit>
        <trans-unit id="cd7373eebfb9bfd956b54104ec328820e66fdfe6" translate="yes" xml:space="preserve">
          <source>So, do I have to choose one or the other for my web site?</source>
          <target state="translated">那么,我的网站一定要选择一个或另一个吗?</target>
        </trans-unit>
        <trans-unit id="b4f91bdb0e1b0e40fff4debcd0fea22f1999f491" translate="yes" xml:space="preserve">
          <source>Solution</source>
          <target state="translated">Solution</target>
        </trans-unit>
        <trans-unit id="e0f0c555c38a97116b738fdc4ec2d35f3f2aa384" translate="yes" xml:space="preserve">
          <source>Some HTTP header fields allow a time value to be specified as an
   integer number of seconds, represented in decimal, after the time
   that the message was received.

       delta-seconds  = 1*DIGIT</source>
          <target state="translated">一些HTTP头字段允许在收到消息的时间后指定一个整数秒的时间值,用十进制表示。 delta-seconds=1*DIGIT。</target>
        </trans-unit>
        <trans-unit id="d62acecb772d2af811fb679ffb025605d29919d2" translate="yes" xml:space="preserve">
          <source>Some HTTP messages transfer a complete or partial representation as
   the message &quot;payload&quot;.  In some cases, a payload might contain only
   the associated representation's header fields (e.g., responses to
   HEAD) or only some part(s) of the representation data (e.g., the 206
   (Partial Content) status code).

   The purpose of a payload in a request is defined by the method
   semantics.  For example, a representation in the payload of a PUT
   request (&lt;a href=&quot;#section-4.3.4&quot;&gt;Section 4.3.4&lt;/a&gt;) represents the desired state of the target
   resource if the request is successfully applied, whereas a
   representation in the payload of a POST request (&lt;a href=&quot;#section-4.3.3&quot;&gt;Section 4.3.3&lt;/a&gt;)
   represents information to be processed by the target resource. 

   In a response, the payload's purpose is defined by both the request
   method and the response status code.  For example, the payload of a
   200 (OK) response to GET (&lt;a href=&quot;#section-4.3.1&quot;&gt;Section 4.3.1&lt;/a&gt;) represents the current state
   of the target resource, as observed at the time of the message
   origination date (&lt;a href=&quot;#section-7.1.1.2&quot;&gt;Section 7.1.1.2&lt;/a&gt;), whereas the payload of the same
   status code in a response to POST might represent either the
   processing result or the new state of the target resource after
   applying the processing.  Response messages with an error status code
   usually contain a payload that represents the error condition, such
   that it describes the error state and what next steps are suggested
   for resolving it.

   Header fields that specifically describe the payload, rather than the
   associated representation, are referred to as &quot;payload header
   fields&quot;.  Payload header fields are defined in other parts of this
   specification, due to their impact on message parsing.

   +-------------------+----------------------------+
   | Header Field Name | Defined in...              |
   +-------------------+----------------------------+
   | Content-Length    | &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.3.2&quot;&gt;Section&amp;nbsp;3.3.2 of [RFC7230]&lt;/a&gt; |
   | Content-Range     | &lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-4.2&quot;&gt;Section&amp;nbsp;4.2 of [RFC7233]&lt;/a&gt;   |
   | Trailer           | &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-4.4&quot;&gt;Section&amp;nbsp;4.4 of [RFC7230]&lt;/a&gt;   |
   | Transfer-Encoding | &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.3.1&quot;&gt;Section&amp;nbsp;3.3.1 of [RFC7230]&lt;/a&gt; |
   +-------------------+----------------------------+</source>
          <target state="translated">一些HTTP消息将完整或部分表示形式传递为消息&amp;ldquo;有效负载&amp;rdquo;。在某些情况下，有效负载可能仅包含关联的表示形式的标头字段（例如，对HEAD的响应），或者仅包含表示形式数据的某些部分（例如，206（部分内容）状态码）。请求中有效负载的目的由方法语义定义。例如，如果请求成功应用，则PUT请求的有效负载中的表示（&lt;a href=&quot;#section-4.3.4&quot;&gt;第4.3.4节&lt;/a&gt;）表示目标资源的期望状态，而POST请求的有效负载中的表示（&lt;a href=&quot;#section-4.3.3&quot;&gt;第4.3.3节）&lt;/a&gt;）代表目标资源要处理的信息。在响应中，有效载荷的用途由请求方法和响应状态代码共同定义。例如，对GET的200（OK）响应的有效负载（&lt;a href=&quot;#section-4.3.1&quot;&gt;第4.3.1节&lt;/a&gt;）表示目标资源的当前状态，如在消息生成日期（&lt;a href=&quot;#section-7.1.1.2&quot;&gt;第7.1.1.2节）&lt;/a&gt;时所观察到的那样。），而对POST的响应中具有相同状态码的有效负载可能表示处理结果或应用处理后目标资源的新状态。具有错误状态代码的响应消息通常包含表示错误情况的有效负载，以便描述错误状态以及建议采取哪些后续步骤来解决该错误状态。专门描述有效负载而不是相关表示的标头字段称为&amp;ldquo;有效载荷标头字段&amp;rdquo;。有效负载头字段在本规范的其他部分中定义，因为它们对消息解析有影响。 + ------------------- + ---------------------------- + |标头字段名称|定义于...| + ------------------- + ---------------------------- + |内容长度|&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.3.2&quot;&gt;[RFC7230]的3.3.2节&lt;/a&gt; | |内容范围| &lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-4.2&quot;&gt;[RFC7233]的第4.2节&lt;/a&gt; | |拖车| &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-4.4&quot;&gt;[RFC7230]的4.4节&lt;/a&gt; | |传输编码| &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.3.1&quot;&gt;[RFC7230]第3.3.1节&lt;/a&gt; | + ------------------- + ---------------------------- +</target>
        </trans-unit>
        <trans-unit id="96f4cfa3a2435470f520822a7a281fd09a7abe90" translate="yes" xml:space="preserve">
          <source>Some HTTP resources are dynamically generated by the server.  For
   these resources, there presumably exists source code somewhere
   governing how that resource is generated.  The relationship of source
   files to output HTTP resources may be one to one, one to many, many
   to one, or many to many.  There is no mechanism in HTTP to determine
   whether a resource is even dynamic, let alone where its source files
   exist or how to author them.  Although this problem would usefully be
   solved, interoperable WebDAV implementations have been widely
   deployed without actually solving this problem, by dealing only with
   static resources.  Thus, the source vs. output problem is not solved
   in this specification and has been deferred to a separate document.</source>
          <target state="translated">有些HTTP资源是由服务器动态生成的。对于这些资源,大概在某个地方存在着源代码,规定了该资源是如何生成的。源文件与输出的HTTP资源的关系可能是一对一,一对多,多对一,或者多对多。在HTTP中,没有任何机制来确定一个资源是否是动态的,更不用说它的源文件存在于哪里,或者如何编写它们。虽然这个问题会得到有用的解决,但可互操作的WebDAV实现在没有真正解决这个问题的情况下就被广泛部署,只处理静态资源。因此,本规范没有解决源文件与输出的问题,而是将其推迟到另一篇文档中解决。</target>
        </trans-unit>
        <trans-unit id="9edae38f81cc4e1676b63507df63fb416ecd279a" translate="yes" xml:space="preserve">
          <source>Some HTTP/1.0 software has interpreted a Content-Type header without
   charset parameter incorrectly to mean &quot;recipient should guess.&quot;
   Senders wishing to defeat this behavior MAY include a charset
   parameter even when the charset is ISO-8859-1 and SHOULD do so when
   it is known that it will not confuse the recipient.

   Unfortunately, some older HTTP/1.0 clients did not deal properly with
   an explicit charset parameter. HTTP/1.1 recipients MUST respect the
   charset label provided by the sender; and those user agents that have
   a provision to &quot;guess&quot; a charset MUST use the charset from the 

   content-type field if they support that charset, rather than the
   recipient's preference, when initially displaying a document. See
   &lt;a href=&quot;#section-3.7.1&quot;&gt;section 3.7.1&lt;/a&gt;.</source>
          <target state="translated">某些HTTP / 1.0软件错误地解释了没有charset参数的Content-Type标头，表示&amp;ldquo;收件人应该猜测&amp;rdquo;。希望消除这种行为的发送者即使在字符集为ISO-8859-1的情况下也可以包含一个字符集参数，并且在知道不会混淆接收者的情况下也应该这样做。不幸的是，某些较旧的HTTP / 1.0客户端无法正确处理显式的charset参数。 HTTP / 1.1接收者必须尊重发送者提供的字符集标签；如果提供&amp;ldquo;猜测&amp;rdquo;字符集的用户代理在最初显示文档时支持该字符集，而不是收件人的首选项，则必须使用content-type字段中的字符集。请参阅 &lt;a href=&quot;#section-3.7.1&quot;&gt;第3.7.1节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="76ff9a23340030e08177c96f6cd25b9e75cd64eb" translate="yes" xml:space="preserve">
          <source>Some clients and servers might wish to be compatible with some
   previous implementations of persistent connections in HTTP/1.0
   clients and servers. Persistent connections in HTTP/1.0 are
   explicitly negotiated as they are not the default behavior. HTTP/1.0
   experimental implementations of persistent connections are faulty,
   and the new facilities in HTTP/1.1 are designed to rectify these
   problems. The problem was that some existing 1.0 clients may be
   sending Keep-Alive to a proxy server that doesn't understand
   Connection, which would then erroneously forward it to the next
   inbound server, which would establish the Keep-Alive connection and
   result in a hung HTTP/1.0 proxy waiting for the close on the
   response. The result is that HTTP/1.0 clients must be prevented from
   using Keep-Alive when talking to proxies.

   However, talking to proxies is the most important use of persistent
   connections, so that prohibition is clearly unacceptable. Therefore,
   we need some other mechanism for indicating a persistent connection
   is desired, which is safe to use even when talking to an old proxy
   that ignores Connection. Persistent connections are the default for
   HTTP/1.1 messages; we introduce a new keyword (Connection: close) for
   declaring non-persistence. See &lt;a href=&quot;#section-14.10&quot;&gt;section 14.10&lt;/a&gt;.

   The original HTTP/1.0 form of persistent connections (the Connection:
   Keep-Alive and Keep-Alive header) is documented in &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt;. [&lt;a href=&quot;#ref-33&quot;&gt;33&lt;/a&gt;]</source>
          <target state="translated">一些客户端和服务器可能希望与HTTP / 1.0客户端和服务器中的持久连接的某些先前实现兼容。 HTTP / 1.0中的持久连接不是默认行为，因此已明确协商。持久连接的HTTP / 1.0实验性实现存在错误，HTTP / 1.1中的新功能旨在纠正这些问题。问题在于某些现有的1.0客户端可能正在将Keep-Alive发送到不了解Connection的代理服务器，然后该代理服务器错误地将其转发到下一个入站服务器，后者将建立Keep-Alive连接并导致挂起HTTP / 1.0代理等待响应结束。结果是在与代理交谈时必须禁止HTTP / 1.0客户端使用Keep-Alive。但是，与代理交谈是持久连接的最重要用途，因此禁止显然是不可接受的。因此，我们需要一些其他机制来指示需要一个持久连接，即使与忽略连接的旧代理通信时，也可以安全使用该机制。持久连接是HTTP / 1.1消息的默认设置；我们引入了一个新关键字（Connection：close）来声明非持久性。看到我们引入了一个新关键字（Connection：close）来声明非持久性。看到我们引入了一个新关键字（Connection：close）来声明非持久性。看到&lt;a href=&quot;#section-14.10&quot;&gt;第14.10条&lt;/a&gt;。持久连接的原始HTTP / 1.0形式（连接：Keep-Alive和Keep-Alive标头）记录在&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068中&lt;/a&gt;。 [ &lt;a href=&quot;#ref-33&quot;&gt;33&lt;/a&gt; ]</target>
        </trans-unit>
        <trans-unit id="66a43f342d6b50a7175f69c935c3406eba5914f1" translate="yes" xml:space="preserve">
          <source>Some common incorrect server configurations:</source>
          <target state="translated">一些常见的不正确的服务器配置。</target>
        </trans-unit>
        <trans-unit id="54f8a5332226dab76bfa931addcda81bcd89ad2c" translate="yes" xml:space="preserve">
          <source>Some content you find may have a &lt;code&gt;charset&lt;/code&gt; parameter at the end of the &lt;code&gt;text/javascript&lt;/code&gt; media type, to specify the character set used to represent the code's content. This is not valid, and in most cases will result in a script not being loaded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="089187292034968cbe876df352df70cc7166431a" translate="yes" xml:space="preserve">
          <source>Some directives have an optional argument, which can be either a &lt;em&gt;token&lt;/em&gt; or a &lt;em&gt;quoted-string&lt;/em&gt;. (See spec for definitions)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9270b0f5d6139d14ce495519a232664c8d2acd88" translate="yes" xml:space="preserve">
          <source>Some features of the HTTP/1.1 protocol, such as Digest
   Authentication, depend on the value of certain end-to-end headers. A
   transparent proxy SHOULD NOT modify an end-to-end header unless the
   definition of that header requires or specifically allows that. 

   A transparent proxy MUST NOT modify any of the following fields in a
   request or response, and it MUST NOT add any of these fields if not
   already present:

      - Content-Location

      - Content-MD5

      - ETag

      - Last-Modified

   A transparent proxy MUST NOT modify any of the following fields in a
   response:

      - Expires

   but it MAY add any of these fields if not already present. If an
   Expires header is added, it MUST be given a field-value identical to
   that of the Date header in that response.

   A  proxy MUST NOT modify or add any of the following fields in a
   message that contains the no-transform cache-control directive, or in
   any request:

      - Content-Encoding

      - Content-Range

      - Content-Type

   A non-transparent proxy MAY modify or add these fields to a message
   that does not include no-transform, but if it does so, it MUST add a
   Warning 214 (Transformation applied) if one does not already appear
   in the message (see &lt;a href=&quot;#section-14.46&quot;&gt;section 14.46&lt;/a&gt;).

      Warning: unnecessary modification of end-to-end headers might
      cause authentication failures if stronger authentication
      mechanisms are introduced in later versions of HTTP. Such
      authentication mechanisms MAY rely on the values of header fields
      not listed here.

   The Content-Length field of a request or response is added or deleted
   according to the rules in &lt;a href=&quot;#section-4.4&quot;&gt;section 4.4&lt;/a&gt;. A transparent proxy MUST
   preserve the entity-length (&lt;a href=&quot;#section-7.2.2&quot;&gt;section 7.2.2&lt;/a&gt;) of the entity-body,
   although it MAY change the transfer-length (&lt;a href=&quot;#section-4.4&quot;&gt;section 4.4&lt;/a&gt;).</source>
          <target state="translated">HTTP / 1.1协议的某些功能（例如摘要身份验证）取决于某些端到端标头的值。透明代理不应修改端到端头，除非该头的定义需要或明确允许。透明代理不得在请求或响应中修改以下任何字段，并且如果不存在，则不得添加以下任何字段：-内容位置-Content-MD5-ETag-最后修改透明代理不得修改响应中的以下任何字段：-到期，但如果尚不存在，则可以添加任何这些字段。如果添加了Expires标头，则必须为其提供与该响应中的Date标头相同的字段值。代理不得在包含无变换缓存控制指令的消息中或在任何请求中修改或添加以下任何字段：-内容编码-内容范围-内容类型非透明代理可以修改或将这些字段添加到不包含无变换的消息中，但如果这样做，则必须在消息中未出现警告214（已应用变换）的情况下添加警告214（已应用变换）（请参见如果消息中还没有出现警告，则必须添加警告214（已应用转换）（请参见如果消息中还没有出现警告，则必须添加警告214（已应用转换）（请参见&lt;a href=&quot;#section-14.46&quot;&gt;第14.46节&lt;/a&gt;）。警告：如果在更高版本的HTTP中引入了更强大的身份验证机制，则对端到端标头进行不必要的修改可能会导致身份验证失败。这样的认证机制可以依赖这里未列出的头域的值。根据&lt;a href=&quot;#section-4.4&quot;&gt;第4.4节中&lt;/a&gt;的规则，添加或删除请求或响应的Content-Length字段。透明代理必须保留实体主体的实体长度（&lt;a href=&quot;#section-7.2.2&quot;&gt;第7.2.2节&lt;/a&gt;），尽管它可以更改传输长度（&lt;a href=&quot;#section-4.4&quot;&gt;第4.4节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="08d40ce154c5b61338b36a1b4a7b8fc44f8f33e3" translate="yes" xml:space="preserve">
          <source>Some formats can be used for both loss-less or lossy compression, like &lt;code&gt;webp&lt;/code&gt;, and usually lossy algorithm can be configured to compress more or less, which then of course leads to less or more quality. For better performance of a Web site, it is ideal to compress as much as possible, while keeping an acceptable level of quality. For images, an image generated by a tool could be not optimized enough for the Web; it is recommended to use tools that will compress as much as possible with the required quality. There are &lt;a href=&quot;http://www.creativebloq.com/design/image-compression-tools-1132865&quot;&gt;numerous tools&lt;/a&gt; that are specialized for this.</source>
          <target state="translated">某些格式既可以用于无损压缩也可以用于有损压缩，例如 &lt;code&gt;webp&lt;/code&gt; ，并且通常可以将有损算法配置为或多或少地进行压缩，这当然会导致质量降低或提高。为了使网站具有更好的性能，理想的是尽可能地压缩，同时保持可接受的质量水平。对于图像，由工具生成的图像可能无法针对Web进行优化。建议使用可以按所需质量尽可能压缩的工具。有&lt;a href=&quot;http://www.creativebloq.com/design/image-compression-tools-1132865&quot;&gt;许多&lt;/a&gt;专用于此的工具。</target>
        </trans-unit>
        <trans-unit id="36517fc724d6e21ec48094bdd3611e8bc2aeefbc" translate="yes" xml:space="preserve">
          <source>Some formats can be used for both loss-less or lossy compression, like &lt;code&gt;webp&lt;/code&gt;, and usually lossy algorithm can be configured to compress more or less, which then of course leads to less or more quality. For better performance of a Web site, it is ideal to compress as much as possible, while keeping an acceptable level of quality. For images, an image generated by a tool could be not optimized enough for the Web; it is recommended to use tools that will compress as much as possible with the required quality. There are &lt;a href=&quot;https://www.creativebloq.com/design/image-compression-tools-1132865&quot;&gt;numerous tools&lt;/a&gt; that are specialized for this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65ac20f104a927276bcef1c71021955f476f1866" translate="yes" xml:space="preserve">
          <source>Some intermediaries include features for transforming messages and
   their payloads.  A proxy might, for example, convert between image
   formats in order to save cache space or to reduce the amount of
   traffic on a slow link.  However, operational problems might occur
   when these transformations are applied to payloads intended for
   critical applications, such as medical imaging or scientific data
   analysis, particularly when integrity checks or digital signatures
   are used to ensure that the payload received is identical to the
   original.

   An HTTP-to-HTTP proxy is called a &quot;transforming proxy&quot; if it is
   designed or configured to modify messages in a semantically
   meaningful way (i.e., modifications, beyond those required by normal
   HTTP processing, that change the message in a way that would be
   significant to the original sender or potentially significant to
   downstream recipients).  For example, a transforming proxy might be
   acting as a shared annotation server (modifying responses to include
   references to a local annotation database), a malware filter, a
   format transcoder, or a privacy filter.  Such transformations are
   presumed to be desired by whichever client (or client organization)
   selected the proxy.

   If a proxy receives a request-target with a host name that is not a
   fully qualified domain name, it MAY add its own domain to the host
   name it received when forwarding the request.  A proxy MUST NOT
   change the host name if the request-target contains a fully qualified
   domain name. 

   A proxy MUST NOT modify the &quot;absolute-path&quot; and &quot;query&quot; parts of the
   received request-target when forwarding it to the next inbound
   server, except as noted above to replace an empty path with &quot;/&quot; or
   &quot;*&quot;.

   A proxy MAY modify the message body through application or removal of
   a transfer coding (&lt;a href=&quot;#section-4&quot;&gt;Section 4&lt;/a&gt;).

   A proxy MUST NOT transform the payload (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-3.3&quot;&gt;Section&amp;nbsp;3.3 of [RFC7231]&lt;/a&gt;) of
   a message that contains a no-transform cache-control directive
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2&quot;&gt;Section&amp;nbsp;5.2 of [RFC7234]&lt;/a&gt;).

   A proxy MAY transform the payload of a message that does not contain
   a no-transform cache-control directive.  A proxy that transforms a
   payload MUST add a Warning header field with the warn-code of 214
   (&quot;Transformation Applied&quot;) if one is not already in the message (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.5&quot;&gt;Section&amp;nbsp;5.5 of [RFC7234]&lt;/a&gt;).  A proxy that transforms the payload of a
   200 (OK) response can further inform downstream recipients that a
   transformation has been applied by changing the response status code
   to 203 (Non-Authoritative Information) (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6.3.4&quot;&gt;Section&amp;nbsp;6.3.4 of [RFC7231]&lt;/a&gt;).

   A proxy SHOULD NOT modify header fields that provide information
   about the endpoints of the communication chain, the resource state,
   or the selected representation (other than the payload) unless the
   field's definition specifically allows such modification or the
   modification is deemed necessary for privacy or security.</source>
          <target state="translated">一些中介包括用于转换消息及其有效负载的功能。例如，代理可以在图像格式之间进行转换，以节省缓存空间或减少慢速链接上的通信量。但是，将这些转换应用于关键应用程序的有效载荷（例如医学成像或科学数据分析）时，尤其是在使用完整性检查或数字签名来确保接收到的有效载荷与原始载荷相同时，可能会出现操作问题。如果HTTP到HTTP代理被设计或配置为以语义上有意义的方式修改消息（即超出常规HTTP处理要求的修改，以一种对原始发件人有意义或对下游收件人重要的方式更改邮件）。例如，转换代理可能充当共享注释服务器（修改响应以包括对本地注释数据库的引用），恶意软件过滤器，格式转码器或隐私过滤器。假定无论哪个客户端（或客户端组织）选择了代理，都需要这种转换。如果代理收到的请求目标的主机名不是完全合格的域名，则它可以在转发请求时将自己的域添加到接收的主机名中。如果请求目标包含完全限定的域名，则代理不得更改主机名。代理不得修改&amp;ldquo;绝对路径&amp;rdquo;和&amp;ldquo;将请求的请求目标转发到下一个入站服务器时，查询&amp;ldquo;请求的目标&amp;rdquo;部分，除非如上所述，用&amp;ldquo; /&amp;rdquo;或&amp;ldquo; *&amp;rdquo;替换空路径。代理可以通过应用程序或删除传输来修改消息正文编码（&lt;a href=&quot;#section-4&quot;&gt;第4节&lt;/a&gt;）。代理不得转换包含无转换缓存控制指令（&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2&quot;&gt;[RFC7234]的5.2节&lt;/a&gt;）的消息的有效负载（&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-3.3&quot;&gt;[RFC7231]的3.3 &lt;/a&gt;节）。代理可以转换不包含无变换缓存控制指令的消息的有效载荷。如果消息中还没有，则转换有效负载的代理必须添加警告代码为214的警告标头字段（&amp;ldquo;已应用转换&amp;rdquo;）（请参阅 &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.5&quot;&gt;[RFC7234]第5.5节&lt;/a&gt;）。转换200（OK）响应的有效负载的代理可以通过将响应状态代码更改为203（非权威信息），进一步通知下游收件人已应用了转换（&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6.3.4&quot;&gt;[RFC7231]的6.3.4节&lt;/a&gt;）。代理不应修改提供有关通信链端点，资源状态或所选表示形式（有效载荷除外）端点信息的标头字段，除非该字段的定义明确允许进行此类修改，或者认为该修改对于隐私或安全性是必需的。</target>
        </trans-unit>
        <trans-unit id="eac57a1de8acde9c46e58fb564a5c63eef8c02df" translate="yes" xml:space="preserve">
          <source>Some of these new methods do not define bodies.  Servers MUST examine
   all requests for a body, even when a body was not expected.  In cases
   where a request body is present but would be ignored by a server, the
   server MUST reject the request with 415 (Unsupported Media Type).
   This informs the client (which may have been attempting to use an
   extension) that the body could not be processed as the client
   intended.</source>
          <target state="translated">其中一些新方法没有定义body。服务器必须检查所有的请求是否有body,即使是在不期望有body的情况下。在请求主体存在但服务器会忽略的情况下,服务器必须用415(Unsupported Media Type)拒绝请求。这将通知客户机(它可能一直在尝试使用扩展),主体不能按照客户机的意图进行处理。</target>
        </trans-unit>
        <trans-unit id="4e4cf2038e1894371084626084a37cd3855e9122" translate="yes" xml:space="preserve">
          <source>Some origin server implementations might not have a clock available.
   An origin server without a clock MUST NOT assign Expires or Last-
   Modified values to a response, unless these values were associated
   with the resource by a system or user with a reliable clock. It MAY
   assign an Expires value that is known, at or before server
   configuration time, to be in the past (this allows &quot;pre-expiration&quot;
   of responses without storing separate Expires values for each
   resource).</source>
          <target state="translated">一些原点服务器实现可能没有可用的时钟,没有时钟的原点服务器必须不给响应分配Expires或Last-Modified值,除非这些值是由具有可靠时钟的系统或用户与资源相关联的。没有时钟的原点服务器不得给响应分配过期值或最后修改值,除非这些值是由具有可靠时钟的系统或用户与资源关联的。它可以分配一个在服务器配置时间或之前已知的过期值(这允许响应的 &quot;预过期&quot;,而无需为每个资源存储单独的过期值)。</target>
        </trans-unit>
        <trans-unit id="03c3e50ec8cb12cf3acddc31b3a981323a1ddf6c" translate="yes" xml:space="preserve">
          <source>Some pages may be protected so only specific users can access it. Basic authentication may be provided by HTTP, either using the &lt;a href=&quot;headers/www-authenticate&quot;&gt;&lt;code&gt;WWW-Authenticate&lt;/code&gt;&lt;/a&gt; and similar headers, or by setting a specific session using &lt;a href=&quot;cookies&quot;&gt;HTTP cookies&lt;/a&gt;.</source>
          <target state="translated">某些页面可能受到保护，因此只有特定用户才能访问它。HTTP可以使用&lt;a href=&quot;headers/www-authenticate&quot;&gt; &lt;code&gt;WWW-Authenticate&lt;/code&gt; &lt;/a&gt;和类似的标头，或者通过使用&lt;a href=&quot;cookies&quot;&gt;HTTP cookie&lt;/a&gt;设置特定的会话，来提供基本身份验证。</target>
        </trans-unit>
        <trans-unit id="9d9fd2b2a9f9cc9b203fa68ab92a78cbe025ac65" translate="yes" xml:space="preserve">
          <source>Some pages may be protected so that only specific users can access them. Basic authentication may be provided by HTTP, either using the &lt;a href=&quot;headers/www-authenticate&quot;&gt;&lt;code&gt;WWW-Authenticate&lt;/code&gt;&lt;/a&gt; and similar headers, or by setting a specific session using &lt;a href=&quot;cookies&quot;&gt;HTTP cookies&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a7d1f4b13e76bd620feb3c514de20a064d7ef93" translate="yes" xml:space="preserve">
          <source>Some proxy servers might need authority to create a tunnel. See also the &lt;a href=&quot;../headers/proxy-authorization&quot;&gt;&lt;code&gt;Proxy-Authorization&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">某些代理服务器可能需要授权才能创建隧道。另请参见&amp;ldquo; &lt;a href=&quot;../headers/proxy-authorization&quot;&gt; &lt;code&gt;Proxy-Authorization&lt;/code&gt; &lt;/a&gt;标头。</target>
        </trans-unit>
        <trans-unit id="f0fe168232211ebb71557e7e371b951b8fb141f8" translate="yes" xml:space="preserve">
          <source>Some requests don&amp;rsquo;t trigger a &lt;a href=&quot;#Preflighted_requests&quot;&gt;CORS preflight&lt;/a&gt;. Those are called &amp;ldquo;simple requests&amp;rdquo; in this article, though the &lt;a href=&quot;https://fetch.spec.whatwg.org/&quot;&gt;Fetch&lt;/a&gt; spec (which defines CORS) doesn&amp;rsquo;t use that term. A request that doesn&amp;rsquo;t trigger a &lt;a href=&quot;#Preflighted_requests&quot;&gt;CORS preflight&lt;/a&gt;&amp;mdash;a so-called &amp;ldquo;simple request&amp;rdquo; &amp;mdash; is one that &lt;strong&gt;meets all the following conditions&lt;/strong&gt;:</source>
          <target state="translated">有些请求不会触发&lt;a href=&quot;#Preflighted_requests&quot;&gt;CORS的飞行前检查&lt;/a&gt;。尽管&lt;a href=&quot;https://fetch.spec.whatwg.org/&quot;&gt;Fetch&lt;/a&gt;规范（定义了CORS）没有使用该术语，但在本文中将这些称为&amp;ldquo;简单请求&amp;rdquo; 。不会触发&lt;a href=&quot;#Preflighted_requests&quot;&gt;CORS预检的&lt;/a&gt;请求（即所谓的&amp;ldquo;简单请求&amp;rdquo;）是&lt;strong&gt;满足以下所有条件的&lt;/strong&gt;请求：</target>
        </trans-unit>
        <trans-unit id="9dcff009cb4590f1396339dc97ee7e3c2dfd40fa" translate="yes" xml:space="preserve">
          <source>Some requests don&amp;rsquo;t trigger a &lt;a href=&quot;#Preflighted_requests&quot;&gt;CORS preflight&lt;/a&gt;. Those are called &lt;em&gt;&amp;ldquo;simple requests&amp;rdquo;&lt;/em&gt; in this article, though the &lt;a href=&quot;https://fetch.spec.whatwg.org/&quot;&gt;Fetch&lt;/a&gt; spec (which defines CORS) doesn&amp;rsquo;t use that term. A &amp;ldquo;simple request&amp;rdquo; is one that &lt;strong&gt;meets all the following conditions&lt;/strong&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b7772fe71270600ccf3a3236874e99cde15c3a7" translate="yes" xml:space="preserve">
          <source>Some requests may need more time on the server like sometimes &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/DELETE&quot;&gt;&lt;code&gt;DELETE&lt;/code&gt;&lt;/a&gt; requests that are scheduled for later processing. In this case, the response is a &lt;a href=&quot;status/303&quot;&gt;&lt;code&gt;303&lt;/code&gt;&lt;/a&gt; (See Other) redirect that links to a page indicating that the action has been scheduled, and eventually informs about the progress, or allows to cancel it.</source>
          <target state="translated">一些请求可能需要在服务器上花费更多的时间，例如有时将&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/DELETE&quot;&gt; &lt;code&gt;DELETE&lt;/code&gt; &lt;/a&gt;请求安排在以后的处理中。在这种情况下，响应是&lt;a href=&quot;status/303&quot;&gt; &lt;code&gt;303&lt;/code&gt; &lt;/a&gt;（请参阅其他）重定向，该链接链接到指示该操作已计划的页面，并最终通知进度或允许取消该进度。</target>
        </trans-unit>
        <trans-unit id="e69ac0ff78ca934a19fc41226c03d69cd112b823" translate="yes" xml:space="preserve">
          <source>Some requests may need more time on the server, like &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/DELETE&quot;&gt;&lt;code&gt;DELETE&lt;/code&gt;&lt;/a&gt; requests that are scheduled for later processing. In this case, the response is a &lt;a href=&quot;status/303&quot;&gt;&lt;code&gt;303&lt;/code&gt;&lt;/a&gt; (See Other) redirect that links to a page indicating that the action has been scheduled, and eventually informs about its progress, or allows to cancel it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="932d714aa9986fefde686199be3c38ba8d61e288" translate="yes" xml:space="preserve">
          <source>Some sections of this specification are illustrated with fragments of
   a non-normative RELAX NG Compact schema [&lt;a href=&quot;#ref-RNC&quot;&gt;RNC&lt;/a&gt;].  However, the text of
   this specification provides the definition of conformance.  Complete
   schemas appear in &lt;a href=&quot;#appendix-B&quot;&gt;Appendix B&lt;/a&gt;.</source>
          <target state="translated">本规范的某些部分以非规范RELAX NG Compact模式[ &lt;a href=&quot;#ref-RNC&quot;&gt;RNC&lt;/a&gt; ]的片段进行了说明。但是，本规范的文本提供了一致性的定义。完整的模式显示在&lt;a href=&quot;#appendix-B&quot;&gt;附录B中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cbcfbee9d39daa00061999fcaad831841c2ed71a" translate="yes" xml:space="preserve">
          <source>Some websites use this response for requests they do not wish to handle, such as automated queries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf1960a9dab8a69c52ce013a2615773d1727df49" translate="yes" xml:space="preserve">
          <source>Sometimes a user agent might want or need to insist that a cache
   revalidate its cache entry with the origin server (and not just with
   the next cache along the path to the origin server), or to reload its
   cache entry from the origin server. End-to-end revalidation might be
   necessary if either the cache or the origin server has overestimated
   the expiration time of the cached response. End-to-end reload may be
   necessary if the cache entry has become corrupted for some reason.

   End-to-end revalidation may be requested either when the client does
   not have its own local cached copy, in which case we call it
   &quot;unspecified end-to-end revalidation&quot;, or when the client does have a
   local cached copy, in which case we call it &quot;specific end-to-end
   revalidation.&quot;

   The client can specify these three kinds of action using Cache-
   Control request directives:

   End-to-end reload
      The request includes a &quot;no-cache&quot; cache-control directive or, for
      compatibility with HTTP/1.0 clients, &quot;Pragma: no-cache&quot;. Field
      names MUST NOT be included with the no-cache directive in a
      request. The server MUST NOT use a cached copy when responding to
      such a request.

   Specific end-to-end revalidation
      The request includes a &quot;max-age=0&quot; cache-control directive, which
      forces each cache along the path to the origin server to
      revalidate its own entry, if any, with the next cache or server.
      The initial request includes a cache-validating conditional with
      the client's current validator.

   Unspecified end-to-end revalidation
      The request includes &quot;max-age=0&quot; cache-control directive, which
      forces each cache along the path to the origin server to
      revalidate its own entry, if any, with the next cache or server.
      The initial request does not include a cache-validating 

      conditional; the first cache along the path (if any) that holds a
      cache entry for this resource includes a cache-validating
      conditional with its current validator.

   max-age
      When an intermediate cache is forced, by means of a max-age=0
      directive, to revalidate its own cache entry, and the client has
      supplied its own validator in the request, the supplied validator
      might differ from the validator currently stored with the cache
      entry. In this case, the cache MAY use either validator in making
      its own request without affecting semantic transparency.

      However, the choice of validator might affect performance. The
      best approach is for the intermediate cache to use its own
      validator when making its request. If the server replies with 304
      (Not Modified), then the cache can return its now validated copy
      to the client with a 200 (OK) response. If the server replies with
      a new entity and cache validator, however, the intermediate cache
      can compare the returned validator with the one provided in the
      client's request, using the strong comparison function. If the
      client's validator is equal to the origin server's, then the
      intermediate cache simply returns 304 (Not Modified). Otherwise,
      it returns the new entity with a 200 (OK) response.

      If a request includes the no-cache directive, it SHOULD NOT
      include min-fresh, max-stale, or max-age.

   only-if-cached
      In some cases, such as times of extremely poor network
      connectivity, a client may want a cache to return only those
      responses that it currently has stored, and not to reload or
      revalidate with the origin server. To do this, the client may
      include the only-if-cached directive in a request. If it receives
      this directive, a cache SHOULD either respond using a cached entry
      that is consistent with the other constraints of the request, or
      respond with a 504 (Gateway Timeout) status. However, if a group
      of caches is being operated as a unified system with good internal
      connectivity, such a request MAY be forwarded within that group of
      caches.

   must-revalidate
      Because a cache MAY be configured to ignore a server's specified
      expiration time, and because a client request MAY include a max-
      stale directive (which has a similar effect), the protocol also
      includes a mechanism for the origin server to require revalidation
      of a cache entry on any subsequent use. When the must-revalidate
      directive is present in a response received by a cache, that cache
      MUST NOT use the entry after it becomes stale to respond to a 

      subsequent request without first revalidating it with the origin
      server. (I.e., the cache MUST do an end-to-end revalidation every
      time, if, based solely on the origin server's Expires or max-age
      value, the cached response is stale.)

      The must-revalidate directive is necessary to support reliable
      operation for certain protocol features. In all circumstances an
      HTTP/1.1 cache MUST obey the must-revalidate directive; in
      particular, if the cache cannot reach the origin server for any
      reason, it MUST generate a 504 (Gateway Timeout) response.

      Servers SHOULD send the must-revalidate directive if and only if
      failure to revalidate a request on the entity could result in
      incorrect operation, such as a silently unexecuted financial
      transaction. Recipients MUST NOT take any automated action that
      violates this directive, and MUST NOT automatically provide an
      unvalidated copy of the entity if revalidation fails.

      Although this is not recommended, user agents operating under
      severe connectivity constraints MAY violate this directive but, if
      so, MUST explicitly warn the user that an unvalidated response has
      been provided. The warning MUST be provided on each unvalidated
      access, and SHOULD require explicit user confirmation.

   proxy-revalidate
      The proxy-revalidate directive has the same meaning as the must-
      revalidate directive, except that it does not apply to non-shared
      user agent caches. It can be used on a response to an
      authenticated request to permit the user's cache to store and
      later return the response without needing to revalidate it (since
      it has already been authenticated once by that user), while still
      requiring proxies that service many users to revalidate each time
      (in order to make sure that each user has been authenticated).
      Note that such authenticated responses also need the public cache
      control directive in order to allow them to be cached at all.</source>
          <target state="translated">有时,用户代理可能希望或需要坚持要求缓存与源服务器一起重新验证它的缓存条目(而不仅仅是与沿路径到源服务器的下一个缓存),或者从源服务器重新加载它的缓存条目。如果缓存或源服务器高估了缓存响应的到期时间,那么端到端重新验证可能是必要的。如果缓存条目因某种原因损坏,可能需要端到端重新加载。当客户端没有自己的本地缓存副本时,可以请求端到端重新验证,在这种情况下,我们称之为 &quot;未指定的端到端重新验证&quot;;当客户端有本地缓存副本时,我们称之为 &quot;特定的端到端重新验证&quot;。客户端可以使用Cache-控制请求指令指定这三种操作。端到端重载 请求中包含一个 &quot;no-cache &quot;缓存控制指令,或者为了与HTTP/1.0客户端兼容,可以使用 &quot;Pragma:no-cache&quot;。在请求中,字段名不得包含在no-cache指令中。当响应这样的请求时,服务器必须不使用缓存副本。特定的端到端重新验证 请求中包含一个 &quot;max-age=0 &quot;的缓存控制指令,该指令强制通往源服务器的路径上的每一个缓存对自己的条目进行重新验证,如果有的话,则与下一个缓存或服务器一起进行。初始请求中包含一个带有客户端当前验证器的缓存验证条件。未指定端到端重新验证 该请求包含 &quot;max-age=0 &quot;缓存控制指令,该指令强制沿路径到源服务器的每个缓存对自己的条目(如果有的话)与下一个缓存或服务器进行重新验证。初始请求不包含缓存验证条件;沿路径的第一个缓存(如果有的话),如果拥有这个资源的缓存条目,则包含一个当前验证器的缓存验证条件。 max-age 当一个中间缓存通过max-age=0指令被强制重新验证它自己的缓存条目,并且客户端在请求中提供了它自己的验证器时,所提供的验证器可能与缓存条目当前存储的验证器不同。在这种情况下,缓存可以在不影响语义透明度的情况下,使用其中一个验证器来进行自己的请求。然而,验证器的选择可能会影响性能。最好的方法是中间缓存在进行请求时使用自己的验证器。如果服务器用304(Not Modified)来回复,那么缓存就可以用200(OK)来回复它现在已经验证的副本给客户端。然而,如果服务器用新的实体和缓存验证器来回复,中间缓存可以使用强比较功能,将返回的验证器与客户端请求中提供的验证器进行比较。如果客户端的验证器与源服务器的验证器相同,那么中间缓存就会简单地返回304(未修改)。否则,它将返回新的实体,并给出200(OK)的响应。如果请求中包含no-cache指令,那么它不应该包含min-fresh、max-stale或max-age。 only-if-cached 在某些情况下,例如网络连接极差的时候,客户端可能希望缓存只返回它当前存储的响应,而不是重新加载或重新验证源服务器。要做到这一点,客户端可能会在请求中包含only-if-cached指令。如果它收到这个指令,缓存应该使用与请求的其他约束一致的缓存条目进行响应,或者用504(网关超时)状态进行响应。然而,如果一组缓存是作为一个统一的系统来操作的,具有良好的内部连接性,那么这样的请求可以在这组缓存中转发。 must-revalidate 因为缓存可以被配置为忽略服务器指定的过期时间,并且因为客户端请求可以包含一个max-stale指令(具有类似的效果),协议还包括一个机制,让源服务器要求在任何后续使用中重新验证缓存条目。当缓存接收到的响应中出现了must-revalidate指令时,缓存在没有与源服务器进行重新验证之前,必须不使用该条目在其变旧后响应后续请求。(也就是说,如果仅仅根据源服务器的Expires或max-age值,缓存的响应是陈旧的,那么缓存必须每次都进行端到端重新验证。)must-revalidate指令对于支持某些协议特性的可靠操作是必要的。在任何情况下,HTTP/1.1缓存都必须服从must-revalidate指令;特别是,如果缓存因为任何原因不能到达源服务器,它必须生成504(网关超时)响应。如果且仅当未能重新验证实体上的请求可能会导致不正确的操作,例如一个沉默的未执行的金融交易时,服务器才应该发送must-revalidate指令。收件人必须不采取任何自动操作。</target>
        </trans-unit>
        <trans-unit id="f28c6b808e20b5e65f433eb5b11613875d49c1a2" translate="yes" xml:space="preserve">
          <source>Sometimes the requested resource can't be accessed from its canonical location, but it can be accessed from another place. In this case, a temporary redirect can be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0f13543920ce2519c90532c2d9391d9d564cd65" translate="yes" xml:space="preserve">
          <source>Sometimes the requested resource cannot be accessed from its canonical location, but it can be accessed from another place. In this case, a temporary redirect can be used. Search engine robots don't memorize the new, temporary link. Temporary redirections are also used when creating, updating and deleting resources to present temporary progress pages.</source>
          <target state="translated">有时,所请求的资源无法从其规范位置访问,但可以从其他地方访问。在这种情况下,可以使用临时重定向。搜索引擎机器人不会记住新的临时链接。在创建、更新和删除资源时,也可以使用临时重定向来呈现临时进度页面。</target>
        </trans-unit>
        <trans-unit id="d332abe855c0a9991ccf162c5e9b1e9be151b36a" translate="yes" xml:space="preserve">
          <source>Sometimes, the server won't detect it: a redirection loop can spread over several servers which each don't have the full picture. In this case, browsers will detect it and display an error message. Firefox displays:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f8875e5296a70a5c55485d7837e9b58660f6869" translate="yes" xml:space="preserve">
          <source>Sometimes, the server won't detect it: a redirection loop can spread over several servers which each don't have the full picture. In this case, browsers will detect it and post an error message. Firefox will display:</source>
          <target state="translated">有时,服务器不会检测到它:重定向循环可能会蔓延到几个服务器上,而每个服务器都没有完整的情况。在这种情况下,浏览器会检测到它并发布一个错误信息。Firefox会显示。</target>
        </trans-unit>
        <trans-unit id="461f6249960b9f5e0adb518e83fe6728e5a1aa14" translate="yes" xml:space="preserve">
          <source>Source Map Revision 3 Proposal</source>
          <target state="translated">源地图修订3提案</target>
        </trans-unit>
        <trans-unit id="48a37d9cb6f83141d7762830d6d9b21396138f77" translate="yes" xml:space="preserve">
          <source>Source code of the resource</source>
          <target state="translated">资源的源代码</target>
        </trans-unit>
        <trans-unit id="eddadabaed64a1c9704679bf2c71541b37a9a200" translate="yes" xml:space="preserve">
          <source>SourceMap</source>
          <target state="translated">SourceMap</target>
        </trans-unit>
        <trans-unit id="2eb56be3c2d93cdab0c52e677e3167dfddb30ac5" translate="yes" xml:space="preserve">
          <source>Sources</source>
          <target state="translated">Sources</target>
        </trans-unit>
        <trans-unit id="7c23b0d99698b57c5cb21fafcb8a8daf127386c6" translate="yes" xml:space="preserve">
          <source>Speaker</source>
          <target state="translated">Speaker</target>
        </trans-unit>
        <trans-unit id="65fa5e6b8d558cde85a3a07a4e444c679377961e" translate="yes" xml:space="preserve">
          <source>Special redirections</source>
          <target state="translated">特别重定向</target>
        </trans-unit>
        <trans-unit id="1432da84229d762b613e72e68e00057a594449c8" translate="yes" xml:space="preserve">
          <source>Specific &lt;a href=&quot;headers&quot;&gt;HTTP headers&lt;/a&gt; by the client (&lt;em&gt;server-driven negotiation&lt;/em&gt; or &lt;em&gt;proactive negotiation&lt;/em&gt;), which is the standard way of negotiating a specific kind of resource.</source>
          <target state="translated">客户端的特定&lt;a href=&quot;headers&quot;&gt;HTTP标头&lt;/a&gt;（&lt;em&gt;服务器驱动协商&lt;/em&gt;或&lt;em&gt;主动协商&lt;/em&gt;），这是协商特定类型资源的标准方法。</target>
        </trans-unit>
        <trans-unit id="1ccf5d25dfedda0749e3abb6685b56a5fed8013a" translate="yes" xml:space="preserve">
          <source>Specification</source>
          <target state="translated">Specification</target>
        </trans-unit>
        <trans-unit id="0c709f9886c34419d95252da6707fd3dc704a220" translate="yes" xml:space="preserve">
          <source>Specifications</source>
          <target state="translated">Specifications</target>
        </trans-unit>
        <trans-unit id="30d32085a077fd1f486b08c98f4d346c5a6b17fc" translate="yes" xml:space="preserve">
          <source>Specifications and RFCs:</source>
          <target state="translated">规格和RFCs。</target>
        </trans-unit>
        <trans-unit id="07b2551feb0b78f2ae3f0674493bd2ba4c495576" translate="yes" xml:space="preserve">
          <source>Specifies GET, HEAD, POST, PUT, DELETE, CONNECT, OPTIONS, TRACE.</source>
          <target state="translated">指定GET、HEAD、POST、PUT、DELETE、CONNECT、OPTIONS、TRACE。</target>
        </trans-unit>
        <trans-unit id="c58c8c11265fc2163fd1c23b0043a730d6d564bd" translate="yes" xml:space="preserve">
          <source>Specifies PATCH.</source>
          <target state="translated">指定PATCH。</target>
        </trans-unit>
        <trans-unit id="99d3f27b2e59be204c52c5c9fc1e3fd32e5425f2" translate="yes" xml:space="preserve">
          <source>Specifies a URI that may see the timing resources. You can specify multiple origins, separated by commas.</source>
          <target state="translated">指定一个可能看到定时资源的URI。您可以指定多个起源,用逗号隔开。</target>
        </trans-unit>
        <trans-unit id="a3dc214da21e1ecdb977da6e15c1694d398e424b" translate="yes" xml:space="preserve">
          <source>Specifies an origin. Only a single origin can be specified.</source>
          <target state="translated">指定一个原点。只能指定一个原点。</target>
        </trans-unit>
        <trans-unit id="0e8dd4aed544a9115516fcba2b2e3d1772b43815" translate="yes" xml:space="preserve">
          <source>Specifies an origin. Only a single origin can be specified. If the server supports clients from multiple origins, it must return the origin for the specific client making the request.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08522ebb29d8c09aa8e3393f359476bbe00317a0" translate="yes" xml:space="preserve">
          <source>Specifies directives for caching mechanisms in both requests and responses.</source>
          <target state="translated">指定请求和响应中缓存机制的指令。</target>
        </trans-unit>
        <trans-unit id="149c7938c7e3b3f09b90de06c72ca9aaa91e52c2" translate="yes" xml:space="preserve">
          <source>Specifies if a cross-domain policy file (&lt;code&gt;crossdomain.xml&lt;/code&gt;) is allowed. The file may define a policy to grant clients, such as Adobe's Flash Player (now obsolete), Adobe Acrobat, Microsoft Silverlight (now obsolete), or Apache Flex, permission to handle data across domains that would otherwise be restricted due to the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy&quot;&gt;Same-Origin Policy&lt;/a&gt;. See the &lt;a href=&quot;https://www.adobe.com/devnet/articles/crossdomain_policy_file_spec.html&quot;&gt;Cross-domain Policy File Specification&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ac472e4fe7931170e92aa9f011df74fb8e68f3a" translate="yes" xml:space="preserve">
          <source>Specifies if a cross-domain policy-file (XML) is allowed. The file may define a policy to grant web clients, such as Adobe Flash Player or Adobe Acrobat (e.g. PDF), permission to handle data across domains.</source>
          <target state="translated">指定是否允许跨域策略文件(XML)。该文件可以定义一个策略,以授予Web客户端(如Adobe Flash Player或Adobe Acrobat(如PDF))跨域处理数据的权限。</target>
        </trans-unit>
        <trans-unit id="b9cbaf8eb79c9b8c4855be6b0eca34e758b86401" translate="yes" xml:space="preserve">
          <source>Specifies one or more protocol-level WebSocket extensions to ask the server to use. Using more than one &lt;code&gt;Sec-WebSocket-Extension&lt;/code&gt; header in a request is permitted; the result is the same as if you included all of the listed extensions in one such header.</source>
          <target state="translated">指定一个或多个协议级WebSocket扩展以要求服务器使用。允许在一个请求中使用多个 &lt;code&gt;Sec-WebSocket-Extension&lt;/code&gt; 标头；结果与将所有列出的扩展名包含在一个这样的标头中相同。</target>
        </trans-unit>
        <trans-unit id="e766075910421b2be9ca8f32bfa752ecb587b39f" translate="yes" xml:space="preserve">
          <source>Specifies origins that are allowed to see values of attributes retrieved via features of the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Resource_Timing_API&quot;&gt;Resource Timing API&lt;/a&gt;, which would otherwise be reported as zero due to cross-origin restrictions.</source>
          <target state="translated">指定允许查看通过&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Resource_Timing_API&quot;&gt;Resource Timing API&lt;/a&gt;功能检索的属性值的起源，否则，由于跨域限制，该属性将报告为零。</target>
        </trans-unit>
        <trans-unit id="c2ecb07bbcb3e1be14696f3f86b19336ccf2cfdc" translate="yes" xml:space="preserve">
          <source>Specifies the URI to which the user agent should report Expect-CT failures.</source>
          <target state="translated">指定用户代理应报告Expect-CT失败的URI。</target>
        </trans-unit>
        <trans-unit id="df8493e883fbdc515ef9ca1b5b0866d3e58f3660" translate="yes" xml:space="preserve">
          <source>Specifies the WebSocket protocol version the client wishes to use, so the server can confirm whether or not that version is supported on its end.</source>
          <target state="translated">指定客户端希望使用的 WebSocket 协议版本,以便服务器可以确认其终端是否支持该版本。</target>
        </trans-unit>
        <trans-unit id="6b4be09a1adcb38cab1a0e2686022154d066d8ba" translate="yes" xml:space="preserve">
          <source>Specifies the domain name of the server (for virtual hosting), and (optionally) the TCP port number on which the server is listening.</source>
          <target state="translated">指定服务器的域名(用于虚拟主机),以及(可选)服务器监听的TCP端口号。</target>
        </trans-unit>
        <trans-unit id="efd15c591f12965b47534e1779aff0b7120829dc" translate="yes" xml:space="preserve">
          <source>Specifies the form of encoding used to safely transfer the entity to the user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d52f387eaf11730a59df918d4e3a112a2d99212" translate="yes" xml:space="preserve">
          <source>Specifies the maximum amount of time a resource will be considered fresh. Contrary to &lt;code&gt;Expires&lt;/code&gt;, this directive is relative to the time of the request.</source>
          <target state="translated">指定将资源视为新鲜的最长时间。与 &lt;code&gt;Expires&lt;/code&gt; 相反，此指令是相对于请求时间的。</target>
        </trans-unit>
        <trans-unit id="6fef4478d76a150d6928212783b2ee9858bcd272" translate="yes" xml:space="preserve">
          <source>Specifies the method or methods allowed when accessing the resource in response to a preflight request.</source>
          <target state="translated">指定响应飞行前请求访问资源时允许使用的一种或多种方法。</target>
        </trans-unit>
        <trans-unit id="495731834481a81b8123951704e2abcb07625db8" translate="yes" xml:space="preserve">
          <source>Specifies the methods allowed when accessing the resource in response to a preflight request.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa52c5dd51b37dc7727111c50a8217213608ca08" translate="yes" xml:space="preserve">
          <source>Specifies the number of seconds after reception of the &lt;code&gt;Expect-CT&lt;/code&gt; header field during which the user agent should regard the host from whom the message was received as a known Expect-CT host.</source>
          <target state="translated">指定接收到 &lt;code&gt;Expect-CT&lt;/code&gt; 标头字段后的秒数，在此秒内，用户代理应将接收消息的主机视为已知的Expect-CT主机。</target>
        </trans-unit>
        <trans-unit id="7f43b9fd51101abb87a0368fc81d197d96a63735" translate="yes" xml:space="preserve">
          <source>Specifies the origin &quot;null&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ea81d80712300e661852f0c6af12a440f390050" translate="yes" xml:space="preserve">
          <source>Specifies the the form of encoding used to safely transfer the entity to the user.</source>
          <target state="translated">指定用于安全传输实体给用户的编码形式。</target>
        </trans-unit>
        <trans-unit id="835c2397154f468b4c8ef93ba4c3e1aa7f2607eb" translate="yes" xml:space="preserve">
          <source>Specifies the transfer encodings the user agent is willing to accept.</source>
          <target state="translated">指定用户代理愿意接受的传输编码。</target>
        </trans-unit>
        <trans-unit id="f30f059c03d4c3da1b77bd03fc6d7ad013fb12f4" translate="yes" xml:space="preserve">
          <source>Specifies those hosts to which the cookie will be sent. If not specified, defaults to the host portion of the current document location (but not including subdomains). Contrary to earlier specifications, leading dots in domain names are ignored. If a domain is specified, subdomains are always included.</source>
          <target state="translated">指定要发送cookie的主机。如果没有指定,默认为当前文档位置的主机部分(但不包括子域)。与之前的规范相反,域名中的前导点会被忽略。如果指定了域名,则子域总是包括在内。</target>
        </trans-unit>
        <trans-unit id="24167ab34816aa2157df161d6a2bd98aa1704455" translate="yes" xml:space="preserve">
          <source>Specifies valid parents that may embed a page using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt;&lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt;&lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">指定可以使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt; &lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt; &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt; &lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt; &lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt; &lt;/a&gt;嵌入页面的有效父级。</target>
        </trans-unit>
        <trans-unit id="3fa0df1c3795d4cdda9e9d0ae70ecf55400bafbc" translate="yes" xml:space="preserve">
          <source>Specifies valid sources for &lt;a href=&quot;https://developer.mozilla.org/docs/Web/API/WebRTC_API&quot;&gt;WebRTC&lt;/a&gt; connections.</source>
          <target state="translated">指定&lt;a href=&quot;https://developer.mozilla.org/docs/Web/API/WebRTC_API&quot;&gt;WebRTC&lt;/a&gt;连接的有效来源。</target>
        </trans-unit>
        <trans-unit id="2a90c719345e0d3bc78bace4ab1d3f64767f076c" translate="yes" xml:space="preserve">
          <source>Specifies valid sources for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Worker&quot;&gt;&lt;code&gt;Worker&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker&quot;&gt;&lt;code&gt;SharedWorker&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker&quot;&gt;&lt;code&gt;ServiceWorker&lt;/code&gt;&lt;/a&gt; scripts.</source>
          <target state="translated">为&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Worker&quot;&gt; &lt;code&gt;Worker&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker&quot;&gt; &lt;code&gt;SharedWorker&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker&quot;&gt; &lt;code&gt;ServiceWorker&lt;/code&gt; &lt;/a&gt;脚本指定有效的源。</target>
        </trans-unit>
        <trans-unit id="d098bd02b96b2bdcbdaec1bb10a529856955c4ce" translate="yes" xml:space="preserve">
          <source>Specifies valid sources for JavaScript &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt;&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;&lt;/a&gt; elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b6311b937bff61b4874ab442d4d9dbb9f3cc22f" translate="yes" xml:space="preserve">
          <source>Specifies valid sources for JavaScript inline event handlers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd49e94946949bc3d24a4291eb9f90caffd7e887" translate="yes" xml:space="preserve">
          <source>Specifies valid sources for JavaScript.</source>
          <target state="translated">指定JavaScript的有效来源。</target>
        </trans-unit>
        <trans-unit id="282bf5eae963adccbd6d47d68520fe0a5c79b871" translate="yes" xml:space="preserve">
          <source>Specifies valid sources for fonts loaded using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face&quot;&gt;&lt;code&gt;@font-face&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">指定使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face&quot;&gt; &lt;code&gt;@font-face&lt;/code&gt; &lt;/a&gt;加载的字体的有效来源。</target>
        </trans-unit>
        <trans-unit id="db33d91daba98ebe85d45f79cd3a62539127fa18" translate="yes" xml:space="preserve">
          <source>Specifies valid sources for inline styles applied to individual DOM elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42f23c7f28c98c835d7c0a52c0e41c358dd15a49" translate="yes" xml:space="preserve">
          <source>Specifies valid sources for loading media using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt;&lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt;&lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/track&quot;&gt;&lt;code&gt;&amp;lt;track&amp;gt;&lt;/code&gt;&lt;/a&gt; elements.</source>
          <target state="translated">使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt; &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt; &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/track&quot;&gt; &lt;code&gt;&amp;lt;track&amp;gt;&lt;/code&gt; &lt;/a&gt;元素指定用于加载媒体的有效源。</target>
        </trans-unit>
        <trans-unit id="9dc2e0e19fce72e5227e4ed05399840422564be0" translate="yes" xml:space="preserve">
          <source>Specifies valid sources for nested browsing contexts loading using elements such as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">指定使用诸如&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt; &lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; 之类的&lt;/a&gt;元素来加载嵌套浏览上下文的有效源。</target>
        </trans-unit>
        <trans-unit id="ae55d19529942a4f7114ca5f6d12086fa3126f81" translate="yes" xml:space="preserve">
          <source>Specifies valid sources for stylesheets &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/style&quot;&gt;&lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt;&lt;/a&gt; elements and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link&quot;&gt;&lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt;&lt;/a&gt; elements with &lt;code&gt;rel=&quot;stylesheet&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a04b49e22cf0a5230eea588841a8a2b455c0bc3e" translate="yes" xml:space="preserve">
          <source>Specifies valid sources for stylesheets.</source>
          <target state="translated">指定样式表的有效来源。</target>
        </trans-unit>
        <trans-unit id="c02deee0c3b25ce48a3b98b60fb3aad61652b709" translate="yes" xml:space="preserve">
          <source>Specifies valid sources for the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt;&lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt;&lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt;&lt;/a&gt; elements.</source>
          <target state="translated">指定&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt; &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt; &lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt; &lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt; &lt;/a&gt;元素的有效源。</target>
        </trans-unit>
        <trans-unit id="fb673b2f31b191ea53966ff7ae48df6affc89e62" translate="yes" xml:space="preserve">
          <source>Specifies valid sources of application manifest files.</source>
          <target state="translated">指定应用程序清单文件的有效来源。</target>
        </trans-unit>
        <trans-unit id="2eb2af79b8a1a437680d977178946925ebbf2f7f" translate="yes" xml:space="preserve">
          <source>Specifies valid sources of images and favicons.</source>
          <target state="translated">指定图像和图标的有效来源。</target>
        </trans-unit>
        <trans-unit id="70ea0caeb914719c42a473dfe61a551bfbb951e5" translate="yes" xml:space="preserve">
          <source>Specifies valid sources to be prefetched or prerendered.</source>
          <target state="translated">指定要预取或预投的有效来源。</target>
        </trans-unit>
        <trans-unit id="951baad47e3b7bd99fb8056c2485c87379c7b510" translate="yes" xml:space="preserve">
          <source>Specifying &lt;code&gt;no-cache&lt;/code&gt; or &lt;code&gt;max-age=0&lt;/code&gt; indicates that clients can cache a resource and must revalidate each time before using it. This means HTTP request occurs each time, but it can skip downloading HTTP body if the content is valid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e61777977f07fdafd61735735d76ae50997e152" translate="yes" xml:space="preserve">
          <source>Specifying a fallback policy</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3835c694b3a6ee97cfe71fb0cd1c9d794f4e48c3" translate="yes" xml:space="preserve">
          <source>Specifying legacy document modes*</source>
          <target state="translated">指定遗留文件模式*</target>
        </trans-unit>
        <trans-unit id="f65d134dfe7e03e4b9a14898c4ef7cc4877bc321" translate="yes" xml:space="preserve">
          <source>Specifying multiple values is only supported in the &lt;code&gt;Referrer-Policy&lt;/code&gt; HTTP header, and not in the &lt;code&gt;referrerpolicy&lt;/code&gt; attribute.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2bf4478d33594d8d9be5cf924dffa2d49ead910" translate="yes" xml:space="preserve">
          <source>Specifying your policy</source>
          <target state="translated">指定您的政策</target>
        </trans-unit>
        <trans-unit id="f8a58e6474d46ef9548c5cf3e20d0bdc3d838946" translate="yes" xml:space="preserve">
          <source>Standard &lt;code&gt;Cache-Control&lt;/code&gt; directives that can be used by the client in an HTTP request.</source>
          <target state="translated">客户端可以在HTTP请求中使用的标准 &lt;code&gt;Cache-Control&lt;/code&gt; 指令。</target>
        </trans-unit>
        <trans-unit id="fc62e8bea8948c4f2c38c80d531e6ec6bc0f979f" translate="yes" xml:space="preserve">
          <source>Standard &lt;code&gt;Cache-Control&lt;/code&gt; directives that can be used by the server in an HTTP response.</source>
          <target state="translated">服务器可以在HTTP响应中使用的标准 &lt;code&gt;Cache-Control&lt;/code&gt; 指令。</target>
        </trans-unit>
        <trans-unit id="7e4f48b87246ae2a22b36e2b02bbe847fa77f9da" translate="yes" xml:space="preserve">
          <source>Standardized methods are generic; that is, they are potentially
   applicable to any resource, not just one particular media type, kind
   of resource, or application.  As such, it is preferred that new
   methods be registered in a document that isn't specific to a single
   application or data format, since orthogonal technologies deserve
   orthogonal specification.

   Since message parsing (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.3&quot;&gt;Section&amp;nbsp;3.3 of [RFC7230]&lt;/a&gt;) needs to be
   independent of method semantics (aside from responses to HEAD),
   definitions of new methods cannot change the parsing algorithm or
   prohibit the presence of a message body on either the request or the
   response message.  Definitions of new methods can specify that only a
   zero-length message body is allowed by requiring a Content-Length
   header field with a value of &quot;0&quot;.

   A new method definition needs to indicate whether it is safe
   (&lt;a href=&quot;#section-4.2.1&quot;&gt;Section 4.2.1&lt;/a&gt;), idempotent (&lt;a href=&quot;#section-4.2.2&quot;&gt;Section 4.2.2&lt;/a&gt;), cacheable
   (&lt;a href=&quot;#section-4.2.3&quot;&gt;Section 4.2.3&lt;/a&gt;), what semantics are to be associated with the payload
   body if any is present in the request and what refinements the method
   makes to header field or status code semantics.  If the new method is
   cacheable, its definition ought to describe how, and under what
   conditions, a cache can store a response and use it to satisfy a
   subsequent request.  The new method ought to describe whether it can
   be made conditional (&lt;a href=&quot;#section-5.2&quot;&gt;Section 5.2&lt;/a&gt;) and, if so, how a server responds
   when the condition is false.  Likewise, if the new method might have
   some use for partial response semantics ([&lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC7233&lt;/a&gt;]), it ought to
   document this, too.

      Note: Avoid defining a method name that starts with &quot;M-&quot;, since
      that prefix might be misinterpreted as having the semantics
      assigned to it by [&lt;a href=&quot;https://tools.ietf.org/html/rfc2774&quot;&gt;RFC2774&lt;/a&gt;].</source>
          <target state="translated">标准化方法是通用的。也就是说，它们可能适用于任何资源，而不仅仅是一种特定的媒体类型，资源类型或应用程序。因此，最好将新方法注册到非特定于单个应用程序或数据格式的文档中，因为正交技术应遵循正交规范。自消息解析以来（&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.3&quot;&gt;[RFC7230]的3.3节&lt;/a&gt;）需要与方法语义无关（除了对HEAD的响应之外），新方法的定义不能更改解析算法或禁止在请求或响应消息上存在消息正文。新方法的定义可以通过要求Content-Length标头字段的值为&amp;ldquo; 0&amp;rdquo;来指定仅允许零长度的消息正文。一个新的方法定义需要指出它是否安全（&lt;a href=&quot;#section-4.2.1&quot;&gt;第4.2.1节&lt;/a&gt;），幂等（&lt;a href=&quot;#section-4.2.2&quot;&gt;第4.2.2节&lt;/a&gt;），可缓存（&lt;a href=&quot;#section-4.2.3&quot;&gt;第4.2.3 &lt;/a&gt;节）），如果请求中存在有效内容主体，则将与哪些语义相关联，以及该方法对标头字段或状态码语义进行哪些改进。如果新方法是可缓存的，则其定义应描述缓存如何以及在何种条件下存储响应并使用它来满足后续请求。新方法应该描述是否可以使其成为有条件的（&lt;a href=&quot;#section-5.2&quot;&gt;第5.2节&lt;/a&gt;），如果可以，则说明条件为假时服务器如何响应。同样，如果新方法可能对部分响应语义有一定作用（[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC7233&lt;/a&gt;]），它也应该记录下来。注意：避免定义以&amp;ldquo; M-&amp;rdquo;开头的方法名称，因为该前缀可能被误解为[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2774&quot;&gt;RFC2774&lt;/a&gt; ] 为其分配的语义。</target>
        </trans-unit>
        <trans-unit id="ec725f8ba620a293e9d02360be092dd295c3b54d" translate="yes" xml:space="preserve">
          <source>Start line</source>
          <target state="translated">起跑线</target>
        </trans-unit>
        <trans-unit id="e030402b999a37d4c6eb9f51e15b86c192ade5a6" translate="yes" xml:space="preserve">
          <source>Starting in Chrome 61, this applies to all of a frame's ancestors.</source>
          <target state="translated">从 Chrome 61 中开始,这适用于框架的所有祖先。</target>
        </trans-unit>
        <trans-unit id="47374f68a6da45b7e6165e2b0f9740a82e30b4ff" translate="yes" xml:space="preserve">
          <source>Starting in Firefox 59, this applies to all of a frame's ancestors.</source>
          <target state="translated">从Firefox 59开始,这适用于一个框架的所有祖先。</target>
        </trans-unit>
        <trans-unit id="6cbdee7a264558eb88d25ed8d267e476fca05cb7" translate="yes" xml:space="preserve">
          <source>Starting in Opera 48, this applies to all of a frame's ancestors.</source>
          <target state="translated">从Opera 48开始,这适用于一个框架的所有祖先。</target>
        </trans-unit>
        <trans-unit id="b6deb6ef9aab80647d8c2b91f6b9f8ab6cffc3c1" translate="yes" xml:space="preserve">
          <source>Starting in Version 6, users can opt into using a GeckoView-based Focus for Android with a hidden preference: it uses a GeckoView UA string to advertise Gecko compatibility.</source>
          <target state="translated">从第6版开始,用户可以选择使用基于GeckoView的Focus for Android,并有一个隐藏的偏好:它使用GeckoView UA字符串来宣传Gecko兼容性。</target>
        </trans-unit>
        <trans-unit id="2767241100a2bb66d29b7ccd151257fc78abe38a" translate="yes" xml:space="preserve">
          <source>Starting with Chrome 52 and Firefox 52, insecure sites (&lt;code&gt;http:&lt;/code&gt;) can't set cookies with the &quot;secure&quot; directive anymore.</source>
          <target state="translated">从Chrome 52和Firefox 52开始，不安全的网站（ &lt;code&gt;http:&lt;/code&gt; ：）不再可以使用&amp;ldquo;安全&amp;rdquo;指令设置cookie。</target>
        </trans-unit>
        <trans-unit id="2777fe7b39631e05febcca00592a28a86bb5182f" translate="yes" xml:space="preserve">
          <source>Starting with Chrome 52 and Firefox 52, insecure sites (&lt;code&gt;http:&lt;/code&gt;) can't set cookies with the &lt;code&gt;Secure&lt;/code&gt; attribute anymore.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb7d21aec22143da2cc4da25c435e7bb29874f8d" translate="yes" xml:space="preserve">
          <source>Starting with Firefox 72, the opting out of MIME sniffing is also applied to top-level documents if a &lt;a href=&quot;content-type&quot;&gt;&lt;code&gt;Content-type&lt;/code&gt;&lt;/a&gt; is provided. This can cause HTML web pages to be downloaded instead of being rendered when they are served with a MIME type other than &lt;code&gt;text/html&lt;/code&gt;. Make sure to set both headers correctly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bae7d5be70820ed56467bd9a63744e23b47bd711" translate="yes" xml:space="preserve">
          <source>Status</source>
          <target state="translated">Status</target>
        </trans-unit>
        <trans-unit id="f7b7abf0e2e9d417ae8391f4a4fe7d726ce87d19" translate="yes" xml:space="preserve">
          <source>Status Code Definitions (RFC 2616)</source>
          <target state="translated">状态码定义(RFC 2616)</target>
        </trans-unit>
        <trans-unit id="79f8bb09cc70b71ab1e11fda8d1499287de0d9e4" translate="yes" xml:space="preserve">
          <source>Status line</source>
          <target state="translated">状态线</target>
        </trans-unit>
        <trans-unit id="8f42525bc1bf257516b4843747d743c365504980" translate="yes" xml:space="preserve">
          <source>Status of This Memo

   This document specifies an Internet standards track protocol for the
   Internet community, and requests discussion and suggestions for
   improvements.  Please refer to the current edition of the &quot;Internet
   Official Protocol Standards&quot; (STD 1) for the standardization state
   and status of this protocol.  Distribution of this memo is unlimited.

Abstract

   The Atom Publishing Protocol (AtomPub) is an application-level
   protocol for publishing and editing Web resources.  The protocol is
   based on HTTP transfer of Atom-formatted representations.  The Atom
   format is documented in the Atom Syndication Format. 

Table of Contents

   &lt;a href=&quot;#section-1&quot;&gt;1&lt;/a&gt;. Introduction 
   &lt;a href=&quot;#section-2&quot;&gt;2&lt;/a&gt;. Notational Conventions 
      &lt;a href=&quot;#section-2.1&quot;&gt;2.1&lt;/a&gt;. XML-Related Conventions 
           &lt;a href=&quot;#section-2.1.1&quot;&gt;2.1.1&lt;/a&gt;. Referring to Information Items 
           &lt;a href=&quot;#section-2.1.2&quot;&gt;2.1.2&lt;/a&gt;. RELAX NG Schema 
           &lt;a href=&quot;#section-2.1.3&quot;&gt;2.1.3&lt;/a&gt;. Use of &quot;xml:base&quot; and &quot;xml:lang&quot; 
   &lt;a href=&quot;#section-3&quot;&gt;3&lt;/a&gt;. Terminology 
   &lt;a href=&quot;#section-4&quot;&gt;4&lt;/a&gt;. Protocol Model 
      &lt;a href=&quot;#section-4.1&quot;&gt;4.1&lt;/a&gt;. Identity and Naming 
      &lt;a href=&quot;#section-4.2&quot;&gt;4.2&lt;/a&gt;. Documents and Resource Classification 
      &lt;a href=&quot;#section-4.3&quot;&gt;4.3&lt;/a&gt;. Control and Publishing 
      &lt;a href=&quot;#section-4.4&quot;&gt;4.4&lt;/a&gt;. Client Implementation Considerations 
   &lt;a href=&quot;#section-5&quot;&gt;5&lt;/a&gt;. Protocol Operations 
      &lt;a href=&quot;#section-5.1&quot;&gt;5.1&lt;/a&gt;. Retrieving a Service Document 
      &lt;a href=&quot;#section-5.2&quot;&gt;5.2&lt;/a&gt;. Listing Collection Members 
      &lt;a href=&quot;#section-5.3&quot;&gt;5.3&lt;/a&gt;. Creating a Resource 
      &lt;a href=&quot;#section-5.4&quot;&gt;5.4&lt;/a&gt;. Editing a Resource 
           &lt;a href=&quot;#section-5.4.1&quot;&gt;5.4.1&lt;/a&gt;. Retrieving a Resource 
           &lt;a href=&quot;#section-5.4.2&quot;&gt;5.4.2&lt;/a&gt;. Editing a Resource 
           &lt;a href=&quot;#section-5.4.3&quot;&gt;5.4.3&lt;/a&gt;. Deleting a Resource 
      &lt;a href=&quot;#section-5.5&quot;&gt;5.5&lt;/a&gt;. Use of HTTP Response Codes 
   &lt;a href=&quot;#section-6&quot;&gt;6&lt;/a&gt;. Protocol Documents 
      &lt;a href=&quot;#section-6.1&quot;&gt;6.1&lt;/a&gt;. Document Types 
      &lt;a href=&quot;#section-6.2&quot;&gt;6.2&lt;/a&gt;. Document Extensibility 
   &lt;a href=&quot;#section-7&quot;&gt;7&lt;/a&gt;. Category Documents 
      &lt;a href=&quot;#section-7.1&quot;&gt;7.1&lt;/a&gt;. Example 
      &lt;a href=&quot;#section-7.2&quot;&gt;7.2&lt;/a&gt;. Element Definitions 
           &lt;a href=&quot;#section-7.2.1&quot;&gt;7.2.1&lt;/a&gt;. The &quot;app:categories&quot; Element 
   &lt;a href=&quot;#section-8&quot;&gt;8&lt;/a&gt;. Service Documents 
      &lt;a href=&quot;#section-8.1&quot;&gt;8.1&lt;/a&gt;. Workspaces 
      &lt;a href=&quot;#section-8.2&quot;&gt;8.2&lt;/a&gt;. Example 
      &lt;a href=&quot;#section-8.3&quot;&gt;8.3&lt;/a&gt;. Element Definitions 
           &lt;a href=&quot;#section-8.3.1&quot;&gt;8.3.1&lt;/a&gt;. The &quot;app:service&quot; Element 
           &lt;a href=&quot;#section-8.3.2&quot;&gt;8.3.2&lt;/a&gt;. The &quot;app:workspace&quot; Element 
           &lt;a href=&quot;#section-8.3.3&quot;&gt;8.3.3&lt;/a&gt;. The &quot;app:collection&quot; Element 
           &lt;a href=&quot;#section-8.3.4&quot;&gt;8.3.4&lt;/a&gt;. The &quot;app:accept&quot; Element 
           &lt;a href=&quot;#section-8.3.5&quot;&gt;8.3.5&lt;/a&gt;. Usage in Atom Feed Documents 
           &lt;a href=&quot;#section-8.3.6&quot;&gt;8.3.6&lt;/a&gt;. The &quot;app:categories&quot; Element 
   &lt;a href=&quot;#section-9&quot;&gt;9&lt;/a&gt;. Creating and Editing Resources 
      &lt;a href=&quot;#section-9.1&quot;&gt;9.1&lt;/a&gt;. Member URIs 
      &lt;a href=&quot;#section-9.2&quot;&gt;9.2&lt;/a&gt;. Creating Resources with POST 
           &lt;a href=&quot;#section-9.2.1&quot;&gt;9.2.1&lt;/a&gt;. Example 
      &lt;a href=&quot;#section-9.3&quot;&gt;9.3&lt;/a&gt;. Editing Resources with PUT 
      &lt;a href=&quot;#section-9.4&quot;&gt;9.4&lt;/a&gt;. Deleting Resources with DELETE 
      &lt;a href=&quot;#section-9.5&quot;&gt;9.5&lt;/a&gt;. Caching and Entity Tags 
           &lt;a href=&quot;#section-9.5.1&quot;&gt;9.5.1&lt;/a&gt;. Example ............................................ 

      &lt;a href=&quot;#section-9.6&quot;&gt;9.6&lt;/a&gt;. Media Resources and Media Link Entries 
           &lt;a href=&quot;#section-9.6.1&quot;&gt;9.6.1&lt;/a&gt;. Examples 
      &lt;a href=&quot;#section-9.7&quot;&gt;9.7&lt;/a&gt;. The Slug Header 
           &lt;a href=&quot;#section-9.7.1&quot;&gt;9.7.1&lt;/a&gt;. Slug Header Syntax 
           &lt;a href=&quot;#section-9.7.2&quot;&gt;9.7.2&lt;/a&gt;. Example 
   &lt;a href=&quot;#section-10&quot;&gt;10&lt;/a&gt;. Listing Collections 
      &lt;a href=&quot;#section-10.1&quot;&gt;10.1&lt;/a&gt;. Collection Partial Lists 
      &lt;a href=&quot;#section-10.2&quot;&gt;10.2&lt;/a&gt;. The &quot;app:edited&quot; Element 
   &lt;a href=&quot;#section-11&quot;&gt;11&lt;/a&gt;. Atom Format Link Relation Extensions 
      &lt;a href=&quot;#section-11.1&quot;&gt;11.1&lt;/a&gt;. The &quot;edit&quot; Link Relation 
      &lt;a href=&quot;#section-11.2&quot;&gt;11.2&lt;/a&gt;. The &quot;edit-media&quot; Link Relation 
   &lt;a href=&quot;#section-12&quot;&gt;12&lt;/a&gt;. The Atom Format Type Parameter 
      &lt;a href=&quot;#section-12.1&quot;&gt;12.1&lt;/a&gt;. The &quot;type&quot; parameter 
           &lt;a href=&quot;#section-12.1.1&quot;&gt;12.1.1&lt;/a&gt;. Conformance 
   &lt;a href=&quot;#section-13&quot;&gt;13&lt;/a&gt;. Atom Publishing Controls 
      &lt;a href=&quot;#section-13.1&quot;&gt;13.1&lt;/a&gt;. The &quot;app:control&quot; Element 
           &lt;a href=&quot;#section-13.1.1&quot;&gt;13.1.1&lt;/a&gt;. The &quot;app:draft&quot; Element 
   &lt;a href=&quot;#section-14&quot;&gt;14&lt;/a&gt;. Securing the Atom Publishing Protocol 
   &lt;a href=&quot;#section-15&quot;&gt;15&lt;/a&gt;. Security Considerations 
      &lt;a href=&quot;#section-15.1&quot;&gt;15.1&lt;/a&gt;. Denial of Service 
      &lt;a href=&quot;#section-15.2&quot;&gt;15.2&lt;/a&gt;. Replay Attacks 
      &lt;a href=&quot;#section-15.3&quot;&gt;15.3&lt;/a&gt;. Spoofing Attacks 
      &lt;a href=&quot;#section-15.4&quot;&gt;15.4&lt;/a&gt;. Linked Resources 
      &lt;a href=&quot;#section-15.5&quot;&gt;15.5&lt;/a&gt;. Digital Signatures and Encryption 
      &lt;a href=&quot;#section-15.6&quot;&gt;15.6&lt;/a&gt;. URIs and IRIs 
      &lt;a href=&quot;#section-15.7&quot;&gt;15.7&lt;/a&gt;. Code Injection and Cross Site Scripting 
   &lt;a href=&quot;#section-16&quot;&gt;16&lt;/a&gt;. IANA Considerations 
      &lt;a href=&quot;#section-16.1&quot;&gt;16.1&lt;/a&gt;. Content-Type Registration for 'application/atomcat+xml' ..39
      &lt;a href=&quot;#section-16.2&quot;&gt;16.2&lt;/a&gt;. Content-Type Registration for 'application/atomsvc+xml' ..40
      &lt;a href=&quot;#section-16.3&quot;&gt;16.3&lt;/a&gt;. Header Field Registration for 'SLUG' 
      &lt;a href=&quot;#section-16.4&quot;&gt;16.4&lt;/a&gt;. The Link Relation Registration &quot;edit&quot; 
      &lt;a href=&quot;#section-16.5&quot;&gt;16.5&lt;/a&gt;. The Link Relation Registration &quot;edit-media&quot; 
      &lt;a href=&quot;#section-16.6&quot;&gt;16.6&lt;/a&gt;. The Atom Format Media Type Parameter 
   &lt;a href=&quot;#section-17&quot;&gt;17&lt;/a&gt;. References 
      &lt;a href=&quot;#section-17.1&quot;&gt;17.1&lt;/a&gt;. Normative References 
      &lt;a href=&quot;#section-17.2&quot;&gt;17.2&lt;/a&gt;. Informative References 
   &lt;a href=&quot;#appendix-A&quot;&gt;Appendix A&lt;/a&gt;. Contributors 
   &lt;a href=&quot;#appendix-B&quot;&gt;Appendix B&lt;/a&gt;. RELAX NG Compact Schema ...............................</source>
          <target state="translated">本备忘录的状态本文档指定了Internet社区的Internet标准跟踪协议，并要求讨论和提出改进建议。请参阅当前版本的&amp;ldquo; Internet官方协议标准&amp;rdquo;（STD 1）了解此协议的标准化状态。该备忘录的分发是无限的。摘要Atom发布协议（AtomPub）是用于发布和编辑Web资源的应用程序级协议。该协议基于Atom格式表示形式的HTTP传输。 Atom格式以Atom联合格式记录。目录 &lt;a href=&quot;#section-1&quot;&gt;1&lt;/a&gt;。介绍 &lt;a href=&quot;#section-2&quot;&gt;2&lt;/a&gt;。符号约定 &lt;a href=&quot;#section-2.1&quot;&gt;2.1&lt;/a&gt;。与XML相关的约定 &lt;a href=&quot;#section-2.1.1&quot;&gt;2.1.1&lt;/a&gt;。参考信息项目 &lt;a href=&quot;#section-2.1.2&quot;&gt;2.1.2&lt;/a&gt;。放松NG模式 &lt;a href=&quot;#section-2.1.3&quot;&gt;2.1.3&lt;/a&gt;。使用&amp;ldquo; xml：base&amp;rdquo;和&amp;ldquo; xml：lang&amp;rdquo; &lt;a href=&quot;#section-3&quot;&gt;3&lt;/a&gt;。术语 &lt;a href=&quot;#section-4&quot;&gt;4&lt;/a&gt;。协议模型 &lt;a href=&quot;#section-4.1&quot;&gt;4.1&lt;/a&gt;。身份和命名 &lt;a href=&quot;#section-4.2&quot;&gt;4.2&lt;/a&gt;。文件和资源分类 &lt;a href=&quot;#section-4.3&quot;&gt;4.3&lt;/a&gt;。控制和发布 &lt;a href=&quot;#section-4.4&quot;&gt;4.4&lt;/a&gt;。客户实施注意事项 &lt;a href=&quot;#section-5&quot;&gt;5&lt;/a&gt;。协议操作 &lt;a href=&quot;#section-5.1&quot;&gt;5.1&lt;/a&gt;。检索服务文件 &lt;a href=&quot;#section-5.2&quot;&gt;5.2&lt;/a&gt;。列表集合成员 &lt;a href=&quot;#section-5.3&quot;&gt;5.3&lt;/a&gt;。创建资源 &lt;a href=&quot;#section-5.4&quot;&gt;5.4&lt;/a&gt;。编辑资源 &lt;a href=&quot;#section-5.4.1&quot;&gt;5.4.1&lt;/a&gt;。检索资源 &lt;a href=&quot;#section-5.4.2&quot;&gt;5.4.2&lt;/a&gt;。编辑资源 &lt;a href=&quot;#section-5.4.3&quot;&gt;5.4.3&lt;/a&gt;。删除资源 &lt;a href=&quot;#section-5.5&quot;&gt;5.5&lt;/a&gt;。 HTTP响应代码的使用 &lt;a href=&quot;#section-6&quot;&gt;6&lt;/a&gt;。议定书文件 &lt;a href=&quot;#section-6.1&quot;&gt;6.1&lt;/a&gt;。文件类型 &lt;a href=&quot;#section-6.2&quot;&gt;6.2&lt;/a&gt;。文件扩展性 &lt;a href=&quot;#section-7&quot;&gt;7&lt;/a&gt;。类别文件 &lt;a href=&quot;#section-7.1&quot;&gt;7.1&lt;/a&gt;。例子 &lt;a href=&quot;#section-7.2&quot;&gt;7.2&lt;/a&gt;。元素定义 &lt;a href=&quot;#section-7.2.1&quot;&gt;7.2.1&lt;/a&gt;。 &amp;ldquo; app：categories&amp;rdquo;元素 &lt;a href=&quot;#section-8&quot;&gt;8&lt;/a&gt;。服务文件 &lt;a href=&quot;#section-8.1&quot;&gt;8.1&lt;/a&gt;。工作区 &lt;a href=&quot;#section-8.2&quot;&gt;8.2&lt;/a&gt;。示例 &lt;a href=&quot;#section-8.3&quot;&gt;8.3&lt;/a&gt;。元素定义 &lt;a href=&quot;#section-8.3.1&quot;&gt;8.3.1&lt;/a&gt;。 &amp;ldquo; app：service&amp;rdquo;元素 &lt;a href=&quot;#section-8.3.2&quot;&gt;8.3.2&lt;/a&gt;。 &amp;ldquo; app：workspace&amp;rdquo;元素 &lt;a href=&quot;#section-8.3.3&quot;&gt;8.3.3&lt;/a&gt;。 &amp;ldquo; app：collection&amp;rdquo;元素 &lt;a href=&quot;#section-8.3.4&quot;&gt;8.3.4&lt;/a&gt;。 &amp;ldquo; app：accept&amp;rdquo;元素 &lt;a href=&quot;#section-8.3.5&quot;&gt;8.3.5&lt;/a&gt;。在Atom Feed文档中使用 &lt;a href=&quot;#section-8.3.6&quot;&gt;8.3.6&lt;/a&gt;。 &amp;ldquo; app：categories&amp;rdquo;元素 &lt;a href=&quot;#section-9&quot;&gt;9&lt;/a&gt;。创建和编辑资源 &lt;a href=&quot;#section-9.1&quot;&gt;9.1&lt;/a&gt;。成员URI &lt;a href=&quot;#section-9.2&quot;&gt;9.2&lt;/a&gt;。使用POST &lt;a href=&quot;#section-9.2.1&quot;&gt;9.2.1&lt;/a&gt;创建资源 。例子 &lt;a href=&quot;#section-9.3&quot;&gt;9.3&lt;/a&gt;。使用PUT &lt;a href=&quot;#section-9.4&quot;&gt;9.4&lt;/a&gt;编辑资源 。 使用DELETE删除资源&lt;a href=&quot;#section-9.5&quot;&gt;9.5&lt;/a&gt;。缓存和实体标签 &lt;a href=&quot;#section-9.5.1&quot;&gt;9.5.1&lt;/a&gt;。例如............................................ &lt;a href=&quot;#section-9.6&quot;&gt;9.6&lt;/a&gt;。媒体资源和媒体链接条目 &lt;a href=&quot;#section-9.6.1&quot;&gt;9.6.1&lt;/a&gt;。例子 &lt;a href=&quot;#section-9.7&quot;&gt;9.7&lt;/a&gt;。子弹头 &lt;a href=&quot;#section-9.7.1&quot;&gt;9.7.1&lt;/a&gt;。 Slug标头语法 &lt;a href=&quot;#section-9.7.2&quot;&gt;9.7.2&lt;/a&gt;。例子 &lt;a href=&quot;#section-10&quot;&gt;10&lt;/a&gt;。列表集合 &lt;a href=&quot;#section-10.1&quot;&gt;10.1&lt;/a&gt;。收集部分清单 &lt;a href=&quot;#section-10.2&quot;&gt;10.2&lt;/a&gt;。 &amp;ldquo; app：edited&amp;rdquo;元素 &lt;a href=&quot;#section-11&quot;&gt;11&lt;/a&gt;。原子格式链接关系扩展 &lt;a href=&quot;#section-11.1&quot;&gt;11.1&lt;/a&gt;。 &amp;ldquo;编辑&amp;rdquo;链接关系 &lt;a href=&quot;#section-11.2&quot;&gt;11.2&lt;/a&gt;。 &amp;ldquo;编辑媒体&amp;rdquo;链接关系 &lt;a href=&quot;#section-12&quot;&gt;12&lt;/a&gt;。 Atom格式类型参数 &lt;a href=&quot;#section-12.1&quot;&gt;12.1&lt;/a&gt;。 &amp;ldquo;类型&amp;rdquo;参数 &lt;a href=&quot;#section-12.1.1&quot;&gt;12.1.1&lt;/a&gt;。符合 &lt;a href=&quot;#section-13&quot;&gt;13&lt;/a&gt;。 Atom发布控件 &lt;a href=&quot;#section-13.1&quot;&gt;13.1&lt;/a&gt;。 &amp;ldquo; app：control&amp;rdquo;元素 &lt;a href=&quot;#section-13.1.1&quot;&gt;13.1.1&lt;/a&gt;。 &amp;ldquo; app：draft&amp;rdquo;元素 &lt;a href=&quot;#section-14&quot;&gt;14&lt;/a&gt;。保护Atom发布协议 &lt;a href=&quot;#section-15&quot;&gt;15&lt;/a&gt;。安全考虑因素 &lt;a href=&quot;#section-15.1&quot;&gt;15.1&lt;/a&gt;。拒绝服务 &lt;a href=&quot;#section-15.2&quot;&gt;15.2&lt;/a&gt;。重播攻击 &lt;a href=&quot;#section-15.3&quot;&gt;15.3&lt;/a&gt;。欺骗攻击 &lt;a href=&quot;#section-15.4&quot;&gt;15.4&lt;/a&gt;。链接资源 &lt;a href=&quot;#section-15.5&quot;&gt;15.5&lt;/a&gt;。数字签名和加密 &lt;a href=&quot;#section-15.6&quot;&gt;15.6&lt;/a&gt;。 URI和IRI &lt;a href=&quot;#section-15.7&quot;&gt;15.7&lt;/a&gt;。代码注入和跨站点脚本编写 &lt;a href=&quot;#section-16&quot;&gt;16&lt;/a&gt;。 IANA考虑因素 &lt;a href=&quot;#section-16.1&quot;&gt;16.1&lt;/a&gt;。 &amp;ldquo; application / atomcat + xml&amp;rdquo;的内容类型注册..39 &lt;a href=&quot;#section-16.2&quot;&gt;16.2&lt;/a&gt;。 &amp;ldquo; application / atomsvc​​ + xml&amp;rdquo;的内容类型注册..40 &lt;a href=&quot;#section-16.3&quot;&gt;16.3&lt;/a&gt;。 &amp;ldquo; SLUG&amp;rdquo;的报头字段注册 &lt;a href=&quot;#section-16.4&quot;&gt;16.4&lt;/a&gt;。链接关系注册&amp;ldquo;编辑&amp;rdquo; &lt;a href=&quot;#section-16.5&quot;&gt;16.5&lt;/a&gt;。链接关系注册&amp;ldquo;编辑媒体&amp;rdquo; &lt;a href=&quot;#section-16.6&quot;&gt;16.6&lt;/a&gt;。 Atom格式媒体类型参数 &lt;a href=&quot;#section-17&quot;&gt;17&lt;/a&gt;。参考文献 &lt;a href=&quot;#section-17.1&quot;&gt;17.1&lt;/a&gt;。规范性引用文件 &lt;a href=&quot;#section-17.2&quot;&gt;17.2&lt;/a&gt;。参考文献 &lt;a href=&quot;#appendix-A&quot;&gt;附录A&lt;/a&gt;。贡献者 &lt;a href=&quot;#appendix-B&quot;&gt;附录B&lt;/a&gt;。 RELAX NG Compact Schema ...............................</target>
        </trans-unit>
        <trans-unit id="bba4ada33d7f6d8a86341c33e255f61ec01eb34d" translate="yes" xml:space="preserve">
          <source>Status of This Memo

   This document specifies an Internet standards track protocol for the
   Internet community, and requests discussion and suggestions for
   improvements.  Please refer to the current edition of the &quot;Internet
   Official Protocol Standards&quot; (STD 1) for the standardization state
   and status of this protocol.  Distribution of this memo is unlimited.

Copyright Notice

   Copyright (C) The IETF Trust (2007).

Abstract

   Web Distributed Authoring and Versioning (WebDAV) consists of a set
   of methods, headers, and content-types ancillary to HTTP/1.1 for the
   management of resource properties, creation and management of
   resource collections, URL namespace manipulation, and resource
   locking (collision avoidance).

   &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518&lt;/a&gt; was published in February 1999, and this specification
   obsoletes &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518&lt;/a&gt; with minor revisions mostly due to
   interoperability experience. 

Table of Contents

   &lt;a href=&quot;#section-1&quot;&gt;1&lt;/a&gt;. Introduction 
   &lt;a href=&quot;#section-2&quot;&gt;2&lt;/a&gt;. Notational Conventions 
   &lt;a href=&quot;#section-3&quot;&gt;3&lt;/a&gt;. Terminology 
   &lt;a href=&quot;#section-4&quot;&gt;4&lt;/a&gt;. Data Model for Resource Properties 
      &lt;a href=&quot;#section-4.1&quot;&gt;4.1&lt;/a&gt;. The Resource Property Model 
      &lt;a href=&quot;#section-4.2&quot;&gt;4.2&lt;/a&gt;. Properties and HTTP Headers 
      &lt;a href=&quot;#section-4.3&quot;&gt;4.3&lt;/a&gt;. Property Values 
           &lt;a href=&quot;#section-4.3.1&quot;&gt;4.3.1&lt;/a&gt;. Example - Property with Mixed Content 
      &lt;a href=&quot;#section-4.4&quot;&gt;4.4&lt;/a&gt;. Property Names 
      &lt;a href=&quot;#section-4.5&quot;&gt;4.5&lt;/a&gt;. Source Resources and Output Resources 
   &lt;a href=&quot;#section-5&quot;&gt;5&lt;/a&gt;. Collections of Web Resources 
      &lt;a href=&quot;#section-5.1&quot;&gt;5.1&lt;/a&gt;. HTTP URL Namespace Model 
      &lt;a href=&quot;#section-5.2&quot;&gt;5.2&lt;/a&gt;. Collection Resources 
   &lt;a href=&quot;#section-6&quot;&gt;6&lt;/a&gt;. Locking 
      &lt;a href=&quot;#section-6.1&quot;&gt;6.1&lt;/a&gt;. Lock Model 
      &lt;a href=&quot;#section-6.2&quot;&gt;6.2&lt;/a&gt;. Exclusive vs. Shared Locks 
      &lt;a href=&quot;#section-6.3&quot;&gt;6.3&lt;/a&gt;. Required Support 
      &lt;a href=&quot;#section-6.4&quot;&gt;6.4&lt;/a&gt;. Lock Creator and Privileges 
      &lt;a href=&quot;#section-6.5&quot;&gt;6.5&lt;/a&gt;. Lock Tokens 
      &lt;a href=&quot;#section-6.6&quot;&gt;6.6&lt;/a&gt;. Lock Timeout 
      &lt;a href=&quot;#section-6.7&quot;&gt;6.7&lt;/a&gt;. Lock Capability Discovery 
      &lt;a href=&quot;#section-6.8&quot;&gt;6.8&lt;/a&gt;. Active Lock Discovery 
   &lt;a href=&quot;#section-7&quot;&gt;7&lt;/a&gt;. Write Lock 
      &lt;a href=&quot;#section-7.1&quot;&gt;7.1&lt;/a&gt;. Write Locks and Properties 
      &lt;a href=&quot;#section-7.2&quot;&gt;7.2&lt;/a&gt;. Avoiding Lost Updates 
      &lt;a href=&quot;#section-7.3&quot;&gt;7.3&lt;/a&gt;. Write Locks and Unmapped URLs 
      &lt;a href=&quot;#section-7.4&quot;&gt;7.4&lt;/a&gt;. Write Locks and Collections 
      &lt;a href=&quot;#section-7.5&quot;&gt;7.5&lt;/a&gt;. Write Locks and the If Request Header 
           &lt;a href=&quot;#section-7.5.1&quot;&gt;7.5.1&lt;/a&gt;. Example - Write Lock and COPY 
           7.5.2. Example - Deleting a Member of a Locked
                  Collection 
      &lt;a href=&quot;#section-7.6&quot;&gt;7.6&lt;/a&gt;. Write Locks and COPY/MOVE 
      &lt;a href=&quot;#section-7.7&quot;&gt;7.7&lt;/a&gt;. Refreshing Write Locks 
   &lt;a href=&quot;#section-8&quot;&gt;8&lt;/a&gt;. General Request and Response Handling 
      &lt;a href=&quot;#section-8.1&quot;&gt;8.1&lt;/a&gt;. Precedence in Error Handling 
      &lt;a href=&quot;#section-8.2&quot;&gt;8.2&lt;/a&gt;. Use of XML 
      &lt;a href=&quot;#section-8.3&quot;&gt;8.3&lt;/a&gt;. URL Handling 
           &lt;a href=&quot;#section-8.3.1&quot;&gt;8.3.1&lt;/a&gt;. Example - Correct URL Handling 
      &lt;a href=&quot;#section-8.4&quot;&gt;8.4&lt;/a&gt;. Required Bodies in Requests 
      &lt;a href=&quot;#section-8.5&quot;&gt;8.5&lt;/a&gt;. HTTP Headers for Use in WebDAV 
      &lt;a href=&quot;#section-8.6&quot;&gt;8.6&lt;/a&gt;. ETag 
      &lt;a href=&quot;#section-8.7&quot;&gt;8.7&lt;/a&gt;. Including Error Response Bodies 
      &lt;a href=&quot;#section-8.8&quot;&gt;8.8&lt;/a&gt;. Impact of Namespace Operations on Cache Validators 
   &lt;a href=&quot;#section-9&quot;&gt;9&lt;/a&gt;. HTTP Methods for Distributed Authoring 
      &lt;a href=&quot;#section-9.1&quot;&gt;9.1&lt;/a&gt;. PROPFIND Method 
           &lt;a href=&quot;#section-9.1.1&quot;&gt;9.1.1&lt;/a&gt;. PROPFIND Status Codes .............................. 

           &lt;a href=&quot;#section-9.1.2&quot;&gt;9.1.2&lt;/a&gt;. Status Codes for Use in 'propstat' Element 
           &lt;a href=&quot;#section-9.1.3&quot;&gt;9.1.3&lt;/a&gt;. Example - Retrieving Named Properties 
           9.1.4. Example - Using 'propname' to Retrieve All
                  Property Names 
           &lt;a href=&quot;#section-9.1.5&quot;&gt;9.1.5&lt;/a&gt;. Example - Using So-called 'allprop' 
           &lt;a href=&quot;#section-9.1.6&quot;&gt;9.1.6&lt;/a&gt;. Example - Using 'allprop' with 'include' 
      &lt;a href=&quot;#section-9.2&quot;&gt;9.2&lt;/a&gt;. PROPPATCH Method 
           &lt;a href=&quot;#section-9.2.1&quot;&gt;9.2.1&lt;/a&gt;. Status Codes for Use in 'propstat' Element 
           &lt;a href=&quot;#section-9.2.2&quot;&gt;9.2.2&lt;/a&gt;. Example - PROPPATCH 
      &lt;a href=&quot;#section-9.3&quot;&gt;9.3&lt;/a&gt;. MKCOL Method 
           &lt;a href=&quot;#section-9.3.1&quot;&gt;9.3.1&lt;/a&gt;. MKCOL Status Codes 
           &lt;a href=&quot;#section-9.3.2&quot;&gt;9.3.2&lt;/a&gt;. Example - MKCOL 
      &lt;a href=&quot;#section-9.4&quot;&gt;9.4&lt;/a&gt;. GET, HEAD for Collections 
      &lt;a href=&quot;#section-9.5&quot;&gt;9.5&lt;/a&gt;. POST for Collections 
      &lt;a href=&quot;#section-9.6&quot;&gt;9.6&lt;/a&gt;. DELETE Requirements 
           &lt;a href=&quot;#section-9.6.1&quot;&gt;9.6.1&lt;/a&gt;. DELETE for Collections 
           &lt;a href=&quot;#section-9.6.2&quot;&gt;9.6.2&lt;/a&gt;. Example - DELETE 
      &lt;a href=&quot;#section-9.7&quot;&gt;9.7&lt;/a&gt;. PUT Requirements 
           &lt;a href=&quot;#section-9.7.1&quot;&gt;9.7.1&lt;/a&gt;. PUT for Non-Collection Resources 
           &lt;a href=&quot;#section-9.7.2&quot;&gt;9.7.2&lt;/a&gt;. PUT for Collections 
      &lt;a href=&quot;#section-9.8&quot;&gt;9.8&lt;/a&gt;. COPY Method 
           &lt;a href=&quot;#section-9.8.1&quot;&gt;9.8.1&lt;/a&gt;. COPY for Non-collection Resources 
           &lt;a href=&quot;#section-9.8.2&quot;&gt;9.8.2&lt;/a&gt;. COPY for Properties 
           &lt;a href=&quot;#section-9.8.3&quot;&gt;9.8.3&lt;/a&gt;. COPY for Collections 
           &lt;a href=&quot;#section-9.8.4&quot;&gt;9.8.4&lt;/a&gt;. COPY and Overwriting Destination Resources 
           &lt;a href=&quot;#section-9.8.5&quot;&gt;9.8.5&lt;/a&gt;. Status Codes 
           &lt;a href=&quot;#section-9.8.6&quot;&gt;9.8.6&lt;/a&gt;. Example - COPY with Overwrite 
           &lt;a href=&quot;#section-9.8.7&quot;&gt;9.8.7&lt;/a&gt;. Example - COPY with No Overwrite 
           &lt;a href=&quot;#section-9.8.8&quot;&gt;9.8.8&lt;/a&gt;. Example - COPY of a Collection 
      &lt;a href=&quot;#section-9.9&quot;&gt;9.9&lt;/a&gt;. MOVE Method 
           &lt;a href=&quot;#section-9.9.1&quot;&gt;9.9.1&lt;/a&gt;. MOVE for Properties 
           &lt;a href=&quot;#section-9.9.2&quot;&gt;9.9.2&lt;/a&gt;. MOVE for Collections 
           &lt;a href=&quot;#section-9.9.3&quot;&gt;9.9.3&lt;/a&gt;. MOVE and the Overwrite Header 
           &lt;a href=&quot;#section-9.9.4&quot;&gt;9.9.4&lt;/a&gt;. Status Codes 
           &lt;a href=&quot;#section-9.9.5&quot;&gt;9.9.5&lt;/a&gt;. Example - MOVE of a Non-Collection 
           &lt;a href=&quot;#section-9.9.6&quot;&gt;9.9.6&lt;/a&gt;. Example - MOVE of a Collection 
      &lt;a href=&quot;#section-9.10&quot;&gt;9.10&lt;/a&gt;. LOCK Method 
           &lt;a href=&quot;#section-9.10.1&quot;&gt;9.10.1&lt;/a&gt;. Creating a Lock on an Existing Resource 
           &lt;a href=&quot;#section-9.10.2&quot;&gt;9.10.2&lt;/a&gt;. Refreshing Locks 
           &lt;a href=&quot;#section-9.10.3&quot;&gt;9.10.3&lt;/a&gt;. Depth and Locking 
           &lt;a href=&quot;#section-9.10.4&quot;&gt;9.10.4&lt;/a&gt;. Locking Unmapped URLs 
           &lt;a href=&quot;#section-9.10.5&quot;&gt;9.10.5&lt;/a&gt;. Lock Compatibility Table 
           &lt;a href=&quot;#section-9.10.6&quot;&gt;9.10.6&lt;/a&gt;. LOCK Responses 
           &lt;a href=&quot;#section-9.10.7&quot;&gt;9.10.7&lt;/a&gt;. Example - Simple Lock Request 
           &lt;a href=&quot;#section-9.10.8&quot;&gt;9.10.8&lt;/a&gt;. Example - Refreshing a Write Lock 
           &lt;a href=&quot;#section-9.10.9&quot;&gt;9.10.9&lt;/a&gt;. Example - Multi-Resource Lock Request 
      &lt;a href=&quot;#section-9.11&quot;&gt;9.11&lt;/a&gt;. UNLOCK Method 
           &lt;a href=&quot;#section-9.11.1&quot;&gt;9.11.1&lt;/a&gt;. Status Codes ...................................... 

           &lt;a href=&quot;#section-9.11.2&quot;&gt;9.11.2&lt;/a&gt;. Example - UNLOCK 
   &lt;a href=&quot;#section-10&quot;&gt;10&lt;/a&gt;. HTTP Headers for Distributed Authoring 
      &lt;a href=&quot;#section-10.1&quot;&gt;10.1&lt;/a&gt;. DAV Header 
      &lt;a href=&quot;#section-10.2&quot;&gt;10.2&lt;/a&gt;. Depth Header 
      &lt;a href=&quot;#section-10.3&quot;&gt;10.3&lt;/a&gt;. Destination Header 
      &lt;a href=&quot;#section-10.4&quot;&gt;10.4&lt;/a&gt;. If Header 
           &lt;a href=&quot;#section-10.4.1&quot;&gt;10.4.1&lt;/a&gt;. Purpose 
           &lt;a href=&quot;#section-10.4.2&quot;&gt;10.4.2&lt;/a&gt;. Syntax 
           &lt;a href=&quot;#section-10.4.3&quot;&gt;10.4.3&lt;/a&gt;. List Evaluation 
           &lt;a href=&quot;#section-10.4.4&quot;&gt;10.4.4&lt;/a&gt;. Matching State Tokens and ETags 
           &lt;a href=&quot;#section-10.4.5&quot;&gt;10.4.5&lt;/a&gt;. If Header and Non-DAV-Aware Proxies 
           &lt;a href=&quot;#section-10.4.6&quot;&gt;10.4.6&lt;/a&gt;. Example - No-tag Production 
           &lt;a href=&quot;#section-10.4.7&quot;&gt;10.4.7&lt;/a&gt;. Example - Using &quot;Not&quot; with No-tag Production 
           10.4.8. Example - Causing a Condition to Always
                   Evaluate to True 
           &lt;a href=&quot;#section-10.4.9&quot;&gt;10.4.9&lt;/a&gt;. Example - Tagged List If Header in COPY 
           10.4.10. Example - Matching Lock Tokens with
                    Collection Locks 
           &lt;a href=&quot;#section-10.4.11&quot;&gt;10.4.11&lt;/a&gt;. Example - Matching ETags on Unmapped URLs 
      &lt;a href=&quot;#section-10.5&quot;&gt;10.5&lt;/a&gt;. Lock-Token Header 
      &lt;a href=&quot;#section-10.6&quot;&gt;10.6&lt;/a&gt;. Overwrite Header 
      &lt;a href=&quot;#section-10.7&quot;&gt;10.7&lt;/a&gt;. Timeout Request Header 
   &lt;a href=&quot;#section-11&quot;&gt;11&lt;/a&gt;. Status Code Extensions to HTTP/1.1 
      &lt;a href=&quot;#section-11.1&quot;&gt;11.1&lt;/a&gt;. 207 Multi-Status 
      &lt;a href=&quot;#section-11.2&quot;&gt;11.2&lt;/a&gt;. 422 Unprocessable Entity 
      &lt;a href=&quot;#section-11.3&quot;&gt;11.3&lt;/a&gt;. 423 Locked 
      &lt;a href=&quot;#section-11.4&quot;&gt;11.4&lt;/a&gt;. 424 Failed Dependency 
      &lt;a href=&quot;#section-11.5&quot;&gt;11.5&lt;/a&gt;. 507 Insufficient Storage 
   &lt;a href=&quot;#section-12&quot;&gt;12&lt;/a&gt;. Use of HTTP Status Codes 
      &lt;a href=&quot;#section-12.1&quot;&gt;12.1&lt;/a&gt;. 412 Precondition Failed 
      &lt;a href=&quot;#section-12.2&quot;&gt;12.2&lt;/a&gt;. 414 Request-URI Too Long 
   &lt;a href=&quot;#section-13&quot;&gt;13&lt;/a&gt;. Multi-Status Response 
      &lt;a href=&quot;#section-13.1&quot;&gt;13.1&lt;/a&gt;. Response Headers 
      &lt;a href=&quot;#section-13.2&quot;&gt;13.2&lt;/a&gt;. Handling Redirected Child Resources 
      &lt;a href=&quot;#section-13.3&quot;&gt;13.3&lt;/a&gt;. Internal Status Codes 
   &lt;a href=&quot;#section-14&quot;&gt;14&lt;/a&gt;. XML Element Definitions 
      &lt;a href=&quot;#section-14.1&quot;&gt;14.1&lt;/a&gt;. activelock XML Element 
      &lt;a href=&quot;#section-14.2&quot;&gt;14.2&lt;/a&gt;. allprop XML Element 
      &lt;a href=&quot;#section-14.3&quot;&gt;14.3&lt;/a&gt;. collection XML Element 
      &lt;a href=&quot;#section-14.4&quot;&gt;14.4&lt;/a&gt;. depth XML Element 
      &lt;a href=&quot;#section-14.5&quot;&gt;14.5&lt;/a&gt;. error XML Element 
      &lt;a href=&quot;#section-14.6&quot;&gt;14.6&lt;/a&gt;. exclusive XML Element 
      &lt;a href=&quot;#section-14.7&quot;&gt;14.7&lt;/a&gt;. href XML Element 
      &lt;a href=&quot;#section-14.8&quot;&gt;14.8&lt;/a&gt;. include XML Element 
      &lt;a href=&quot;#section-14.9&quot;&gt;14.9&lt;/a&gt;. location XML Element 
      &lt;a href=&quot;#section-14.10&quot;&gt;14.10&lt;/a&gt;. lockentry XML Element 
      &lt;a href=&quot;#section-14.11&quot;&gt;14.11&lt;/a&gt;. lockinfo XML Element 
      &lt;a href=&quot;#section-14.12&quot;&gt;14.12&lt;/a&gt;. lockroot XML Element .................................... 

      &lt;a href=&quot;#section-14.13&quot;&gt;14.13&lt;/a&gt;. lockscope XML Element 
      &lt;a href=&quot;#section-14.14&quot;&gt;14.14&lt;/a&gt;. locktoken XML Element 
      &lt;a href=&quot;#section-14.15&quot;&gt;14.15&lt;/a&gt;. locktype XML Element 
      &lt;a href=&quot;#section-14.16&quot;&gt;14.16&lt;/a&gt;. multistatus XML Element 
      &lt;a href=&quot;#section-14.17&quot;&gt;14.17&lt;/a&gt;. owner XML Element 
      &lt;a href=&quot;#section-14.18&quot;&gt;14.18&lt;/a&gt;. prop XML Element 
      &lt;a href=&quot;#section-14.19&quot;&gt;14.19&lt;/a&gt;. propertyupdate XML Element 
      &lt;a href=&quot;#section-14.20&quot;&gt;14.20&lt;/a&gt;. propfind XML Element 
      &lt;a href=&quot;#section-14.21&quot;&gt;14.21&lt;/a&gt;. propname XML Element 
      &lt;a href=&quot;#section-14.22&quot;&gt;14.22&lt;/a&gt;. propstat XML Element 
      &lt;a href=&quot;#section-14.23&quot;&gt;14.23&lt;/a&gt;. remove XML Element 
      &lt;a href=&quot;#section-14.24&quot;&gt;14.24&lt;/a&gt;. response XML Element 
      &lt;a href=&quot;#section-14.25&quot;&gt;14.25&lt;/a&gt;. responsedescription XML Element 
      &lt;a href=&quot;#section-14.26&quot;&gt;14.26&lt;/a&gt;. set XML Element 
      &lt;a href=&quot;#section-14.27&quot;&gt;14.27&lt;/a&gt;. shared XML Element 
      &lt;a href=&quot;#section-14.28&quot;&gt;14.28&lt;/a&gt;. status XML Element 
      &lt;a href=&quot;#section-14.29&quot;&gt;14.29&lt;/a&gt;. timeout XML Element 
      &lt;a href=&quot;#section-14.30&quot;&gt;14.30&lt;/a&gt;. write XML Element 
   &lt;a href=&quot;#section-15&quot;&gt;15&lt;/a&gt;. DAV Properties 
   &lt;a href=&quot;#section-16&quot;&gt;16&lt;/a&gt;. Precondition/Postcondition XML Elements 
   &lt;a href=&quot;#section-17&quot;&gt;17&lt;/a&gt;. XML Extensibility in DAV 
   &lt;a href=&quot;#section-18&quot;&gt;18&lt;/a&gt;. DAV Compliance Classes 
      &lt;a href=&quot;#section-18.1&quot;&gt;18.1&lt;/a&gt;. Class 1 
      &lt;a href=&quot;#section-18.2&quot;&gt;18.2&lt;/a&gt;. Class 2 
      &lt;a href=&quot;#section-18.3&quot;&gt;18.3&lt;/a&gt;. Class 3 
   &lt;a href=&quot;#section-19&quot;&gt;19&lt;/a&gt;. Internationalization Considerations 
   &lt;a href=&quot;#section-20&quot;&gt;20&lt;/a&gt;. Security Considerations 
      &lt;a href=&quot;#section-20.1&quot;&gt;20.1&lt;/a&gt;. Authentication of Clients 
      &lt;a href=&quot;#section-20.2&quot;&gt;20.2&lt;/a&gt;. Denial of Service 
      &lt;a href=&quot;#section-20.3&quot;&gt;20.3&lt;/a&gt;. Security through Obscurity 
      &lt;a href=&quot;#section-20.4&quot;&gt;20.4&lt;/a&gt;. Privacy Issues Connected to Locks 
      &lt;a href=&quot;#section-20.5&quot;&gt;20.5&lt;/a&gt;. Privacy Issues Connected to Properties 
      &lt;a href=&quot;#section-20.6&quot;&gt;20.6&lt;/a&gt;. Implications of XML Entities 
      &lt;a href=&quot;#section-20.7&quot;&gt;20.7&lt;/a&gt;. Risks Connected with Lock Tokens 
      &lt;a href=&quot;#section-20.8&quot;&gt;20.8&lt;/a&gt;. Hosting Malicious Content 
   &lt;a href=&quot;#section-21&quot;&gt;21&lt;/a&gt;. IANA Considerations 
      &lt;a href=&quot;#section-21.1&quot;&gt;21.1&lt;/a&gt;. New URI Schemes 
      &lt;a href=&quot;#section-21.2&quot;&gt;21.2&lt;/a&gt;. XML Namespaces 
      &lt;a href=&quot;#section-21.3&quot;&gt;21.3&lt;/a&gt;. Message Header Fields 
           &lt;a href=&quot;#section-21.3.1&quot;&gt;21.3.1&lt;/a&gt;. DAV 
           &lt;a href=&quot;#section-21.3.2&quot;&gt;21.3.2&lt;/a&gt;. Depth 
           &lt;a href=&quot;#section-21.3.3&quot;&gt;21.3.3&lt;/a&gt;. Destination 
           &lt;a href=&quot;#section-21.3.4&quot;&gt;21.3.4&lt;/a&gt;. If 
           &lt;a href=&quot;#section-21.3.5&quot;&gt;21.3.5&lt;/a&gt;. Lock-Token 
           &lt;a href=&quot;#section-21.3.6&quot;&gt;21.3.6&lt;/a&gt;. Overwrite 
           &lt;a href=&quot;#section-21.3.7&quot;&gt;21.3.7&lt;/a&gt;. Timeout 
      &lt;a href=&quot;#section-21.4&quot;&gt;21.4&lt;/a&gt;. HTTP Status Codes 
   &lt;a href=&quot;#section-22&quot;&gt;22&lt;/a&gt;. Acknowledgements ............................................. 

   &lt;a href=&quot;#section-23&quot;&gt;23&lt;/a&gt;. Contributors to This Specification 
   &lt;a href=&quot;#section-24&quot;&gt;24&lt;/a&gt;. Authors of &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518&lt;/a&gt;&lt;a href=&quot;#section-25&quot;&gt;25&lt;/a&gt;. References 
      &lt;a href=&quot;#section-25.1&quot;&gt;25.1&lt;/a&gt;. Normative References
      &lt;a href=&quot;#section-25.2&quot;&gt;25.2&lt;/a&gt;. Informative References 
   &lt;a href=&quot;#appendix-A&quot;&gt;Appendix A&lt;/a&gt;.  Notes on Processing XML Elements 
      &lt;a href=&quot;#appendix-A.1&quot;&gt;A.1&lt;/a&gt;. Notes on Empty XML Elements 
      &lt;a href=&quot;#appendix-A.2&quot;&gt;A.2&lt;/a&gt;. Notes on Illegal XML Processing 
      &lt;a href=&quot;#appendix-A.3&quot;&gt;A.3&lt;/a&gt;. Example - XML Syntax Error 
      &lt;a href=&quot;#appendix-A.4&quot;&gt;A.4&lt;/a&gt;. Example - Unexpected XML Element 
   &lt;a href=&quot;#appendix-B&quot;&gt;Appendix B&lt;/a&gt;. Notes on HTTP Client Compatibility 
   &lt;a href=&quot;#appendix-C&quot;&gt;Appendix C&lt;/a&gt;. The 'opaquelocktoken' Scheme and URIs 
   &lt;a href=&quot;#appendix-D&quot;&gt;Appendix D&lt;/a&gt;. Lock-null Resources 
      &lt;a href=&quot;#appendix-D.1&quot;&gt;D.1&lt;/a&gt;. Guidance for Clients Using LOCK to Create Resources 
   &lt;a href=&quot;#appendix-E&quot;&gt;Appendix E&lt;/a&gt;. Guidance for Clients Desiring to Authenticate 
   &lt;a href=&quot;#appendix-F&quot;&gt;Appendix F&lt;/a&gt;. Summary of Changes from &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518&lt;/a&gt;&lt;a href=&quot;#appendix-F.1&quot;&gt;F.1&lt;/a&gt;. Changes for Both Client and Server Implementations 
      &lt;a href=&quot;#appendix-F.2&quot;&gt;F.2&lt;/a&gt;. Changes for Server Implementations 
      &lt;a href=&quot;#appendix-F.3&quot;&gt;F.3&lt;/a&gt;. Other Changes ............................................</source>
          <target state="translated">本备忘录的状态本文档指定了Internet社区的Internet标准跟踪协议，并要求讨论和提出改进建议。请参阅当前版本的&amp;ldquo; Internet官方协议标准&amp;rdquo;（STD 1）了解此协议的标准化状态。该备忘录的分发是无限的。版权声明版权所有（C）IETF信托（2007）。抽象Web分布式创作和版本控制（WebDAV）由HTTP / 1.1附带的一组方法，标头和内容类型组成，用于管理资源属性，创建和管理资源集合，URL名称空间操纵以及资源锁定（冲突）避免）。 &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518&lt;/a&gt;该规范于1999年2月发布，并且由于互操作性方面的经验，该规范使&lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518&lt;/a&gt;稍作修订就过时了。目录 &lt;a href=&quot;#section-1&quot;&gt;1&lt;/a&gt;。介绍 &lt;a href=&quot;#section-2&quot;&gt;2&lt;/a&gt;。符号约定 &lt;a href=&quot;#section-3&quot;&gt;3&lt;/a&gt;。术语 &lt;a href=&quot;#section-4&quot;&gt;4&lt;/a&gt;。资源属性的数据模型 &lt;a href=&quot;#section-4.1&quot;&gt;4.1&lt;/a&gt;。资源属性模型 &lt;a href=&quot;#section-4.2&quot;&gt;4.2&lt;/a&gt;。属性和HTTP标头 &lt;a href=&quot;#section-4.3&quot;&gt;4.3&lt;/a&gt;。属性值 &lt;a href=&quot;#section-4.3.1&quot;&gt;4.3.1&lt;/a&gt;。示例-具有混合内容的属性 &lt;a href=&quot;#section-4.4&quot;&gt;4.4&lt;/a&gt;。财产名称 &lt;a href=&quot;#section-4.5&quot;&gt;4.5&lt;/a&gt;。源资源和输出资源 &lt;a href=&quot;#section-5&quot;&gt;5&lt;/a&gt;。 Web资源的收集 &lt;a href=&quot;#section-5.1&quot;&gt;5.1&lt;/a&gt;。 HTTP URL命名空间模型 &lt;a href=&quot;#section-5.2&quot;&gt;5.2&lt;/a&gt;。收藏资源 &lt;a href=&quot;#section-6&quot;&gt;6&lt;/a&gt;。锁定 &lt;a href=&quot;#section-6.1&quot;&gt;6.1&lt;/a&gt;。锁模型 &lt;a href=&quot;#section-6.2&quot;&gt;6.2&lt;/a&gt;。排他锁与共享锁 &lt;a href=&quot;#section-6.3&quot;&gt;6.3&lt;/a&gt;。所需的支持 &lt;a href=&quot;#section-6.4&quot;&gt;6.4&lt;/a&gt;。锁定创建者和特权 &lt;a href=&quot;#section-6.5&quot;&gt;6.5&lt;/a&gt;。锁令牌 &lt;a href=&quot;#section-6.6&quot;&gt;6.6&lt;/a&gt;。锁定超时 &lt;a href=&quot;#section-6.7&quot;&gt;6.7&lt;/a&gt;。锁定功能发现 &lt;a href=&quot;#section-6.8&quot;&gt;6.8&lt;/a&gt;。主动锁发现 &lt;a href=&quot;#section-7&quot;&gt;7&lt;/a&gt;。写锁 &lt;a href=&quot;#section-7.1&quot;&gt;7.1&lt;/a&gt;。写锁和属性 &lt;a href=&quot;#section-7.2&quot;&gt;7.2&lt;/a&gt;。避免丢失的更新 &lt;a href=&quot;#section-7.3&quot;&gt;7.3&lt;/a&gt;。写锁和未映射的URL &lt;a href=&quot;#section-7.4&quot;&gt;7.4&lt;/a&gt;。写锁和收藏 &lt;a href=&quot;#section-7.5&quot;&gt;7.5&lt;/a&gt;。写锁和If Request标头 &lt;a href=&quot;#section-7.5.1&quot;&gt;7.5.1&lt;/a&gt;。示例-写锁和复制7.5.2。示例-删除锁定集合的成员 &lt;a href=&quot;#section-7.6&quot;&gt;7.6&lt;/a&gt;。写锁和COPY / MOVE &lt;a href=&quot;#section-7.7&quot;&gt;7.7&lt;/a&gt;。刷新写锁 &lt;a href=&quot;#section-8&quot;&gt;8&lt;/a&gt;。一般请求和响应处理 &lt;a href=&quot;#section-8.1&quot;&gt;8.1&lt;/a&gt;。错误处理的优先 &lt;a href=&quot;#section-8.2&quot;&gt;8.2&lt;/a&gt;。使用XML &lt;a href=&quot;#section-8.3&quot;&gt;8.3&lt;/a&gt;。 URL处理 &lt;a href=&quot;#section-8.3.1&quot;&gt;8.3.1&lt;/a&gt;。示例-正确的URL处理 &lt;a href=&quot;#section-8.4&quot;&gt;8.4&lt;/a&gt;。要求的机构 &lt;a href=&quot;#section-8.5&quot;&gt;8.5&lt;/a&gt;。 WebDAV &lt;a href=&quot;#section-8.6&quot;&gt;8.6中&lt;/a&gt;使用的HTTP标头 。 ETag &lt;a href=&quot;#section-8.7&quot;&gt;8.7&lt;/a&gt;。包括错误响应机构 &lt;a href=&quot;#section-8.8&quot;&gt;8.8&lt;/a&gt;。命名空间操作对缓存验证器的影响 &lt;a href=&quot;#section-9&quot;&gt;9&lt;/a&gt;。分布式创作的HTTP方法 &lt;a href=&quot;#section-9.1&quot;&gt;9.1&lt;/a&gt;。 PROPFIND方法 &lt;a href=&quot;#section-9.1.1&quot;&gt;9.1.1&lt;/a&gt;。 PROPFIND状态码.................................... &lt;a href=&quot;#section-9.1.2&quot;&gt;9.1.2&lt;/a&gt;。在&amp;ldquo; propstat&amp;rdquo;元素&lt;a href=&quot;#section-9.1.3&quot;&gt;9.1.3中&lt;/a&gt;使用的状态代码 。示例-检索命名属性9.1.4。示例-使用&amp;ldquo; propname&amp;rdquo;检索所有属性名称 &lt;a href=&quot;#section-9.1.5&quot;&gt;9.1.5&lt;/a&gt;。示例-使用所谓的&amp;ldquo;allprop&amp;rdquo; &lt;a href=&quot;#section-9.1.6&quot;&gt;9.1.6&lt;/a&gt;。示例-使用与&amp;ldquo;allprop&amp;rdquo;&amp;ldquo;包括&amp;rdquo; &lt;a href=&quot;#section-9.2&quot;&gt;9.2&lt;/a&gt;。 PROPPATCH方法 &lt;a href=&quot;#section-9.2.1&quot;&gt;9.2.1&lt;/a&gt;。在&amp;ldquo; propstat&amp;rdquo;元素&lt;a href=&quot;#section-9.2.2&quot;&gt;9.2.2中&lt;/a&gt;使用的状态代码 。示例-PROPPATCH &lt;a href=&quot;#section-9.3&quot;&gt;9.3&lt;/a&gt;。 MKCOL方法 &lt;a href=&quot;#section-9.3.1&quot;&gt;9.3.1&lt;/a&gt;。 MKCOL状态代码 &lt;a href=&quot;#section-9.3.2&quot;&gt;9.3.2&lt;/a&gt;。示例-MKCOL &lt;a href=&quot;#section-9.4&quot;&gt;9.4&lt;/a&gt;。 GET，HEAD到集合 &lt;a href=&quot;#section-9.5&quot;&gt;9.5&lt;/a&gt;。集合的POST &lt;a href=&quot;#section-9.6&quot;&gt;9.6&lt;/a&gt;。删除要求 &lt;a href=&quot;#section-9.6.1&quot;&gt;9.6.1&lt;/a&gt;。删除集合 &lt;a href=&quot;#section-9.6.2&quot;&gt;9.6.2&lt;/a&gt;。示例-删除 &lt;a href=&quot;#section-9.7&quot;&gt;9.7&lt;/a&gt;。 PUT要求 &lt;a href=&quot;#section-9.7.1&quot;&gt;9.7.1&lt;/a&gt;。非收集资源的PUT &lt;a href=&quot;#section-9.7.2&quot;&gt;9.7.2&lt;/a&gt;。收集 &lt;a href=&quot;#section-9.8&quot;&gt;9.8&lt;/a&gt;。 COPY方法 &lt;a href=&quot;#section-9.8.1&quot;&gt;9.8.1&lt;/a&gt;。 COPY非收集资源 &lt;a href=&quot;#section-9.8.2&quot;&gt;9.8.2&lt;/a&gt;。&lt;a href=&quot;#section-9.8.3&quot;&gt;9.8.3&lt;/a&gt;复制属性 。副本的收藏 &lt;a href=&quot;#section-9.8.4&quot;&gt;9.8.4&lt;/a&gt;。复制和覆盖目标资源 &lt;a href=&quot;#section-9.8.5&quot;&gt;9.8.5&lt;/a&gt;。状态码 &lt;a href=&quot;#section-9.8.6&quot;&gt;9.8.6&lt;/a&gt;。示例-覆盖&lt;a href=&quot;#section-9.8.7&quot;&gt;9.8.7的&lt;/a&gt; COPY 。示例&lt;a href=&quot;#section-9.8.8&quot;&gt;-COPY&lt;/a&gt;不覆盖 9.8.8。示例-复制 &lt;a href=&quot;#section-9.9&quot;&gt;9.9&lt;/a&gt;。移动方法 &lt;a href=&quot;#section-9.9.1&quot;&gt;9.9.1&lt;/a&gt;。移动属性 &lt;a href=&quot;#section-9.9.2&quot;&gt;9.9.2&lt;/a&gt;。移动集合 &lt;a href=&quot;#section-9.9.3&quot;&gt;9.9.3&lt;/a&gt;。 MOVE和覆盖标头 &lt;a href=&quot;#section-9.9.4&quot;&gt;9.9.4&lt;/a&gt;。状态码 &lt;a href=&quot;#section-9.9.5&quot;&gt;9.9.5&lt;/a&gt;。示例-非收藏&lt;a href=&quot;#section-9.9.6&quot;&gt;夹的&lt;/a&gt; MOVE 9.9.6。示例-集合的移动 &lt;a href=&quot;#section-9.10&quot;&gt;9.10&lt;/a&gt;。锁定方法 &lt;a href=&quot;#section-9.10.1&quot;&gt;9.10.1&lt;/a&gt;。在现有资源&lt;a href=&quot;#section-9.10.2&quot;&gt;9.10.2&lt;/a&gt;上创建锁 。刷新锁 &lt;a href=&quot;#section-9.10.3&quot;&gt;9.10.3&lt;/a&gt;。深度和锁定 &lt;a href=&quot;#section-9.10.4&quot;&gt;9.10.4&lt;/a&gt;。锁定未映射的URL &lt;a href=&quot;#section-9.10.5&quot;&gt;9.10.5&lt;/a&gt;。锁兼容性表 &lt;a href=&quot;#section-9.10.6&quot;&gt;9.10.6&lt;/a&gt;。锁响应 &lt;a href=&quot;#section-9.10.7&quot;&gt;9.10.7&lt;/a&gt;。示例-简单锁定请求 &lt;a href=&quot;#section-9.10.8&quot;&gt;9.10.8&lt;/a&gt;。示例-刷新写锁定 &lt;a href=&quot;#section-9.10.9&quot;&gt;9.10.9&lt;/a&gt;。示例-多资源锁定请求 &lt;a href=&quot;#section-9.11&quot;&gt;9.11&lt;/a&gt;。解锁方法 &lt;a href=&quot;#section-9.11.1&quot;&gt;9.11.1&lt;/a&gt;。状态码.......................................... &lt;a href=&quot;#section-9.11.2&quot;&gt;9.11.2&lt;/a&gt;。示例-解锁 &lt;a href=&quot;#section-10&quot;&gt;10&lt;/a&gt;。分布式创作的HTTP标头 &lt;a href=&quot;#section-10.1&quot;&gt;10.1&lt;/a&gt;。 DAV标头 &lt;a href=&quot;#section-10.2&quot;&gt;10.2&lt;/a&gt;。深度标题 &lt;a href=&quot;#section-10.3&quot;&gt;10.3&lt;/a&gt;。目标标题 &lt;a href=&quot;#section-10.4&quot;&gt;10.4&lt;/a&gt;。如果标题 &lt;a href=&quot;#section-10.4.1&quot;&gt;10.4.1&lt;/a&gt;。目的 &lt;a href=&quot;#section-10.4.2&quot;&gt;10.4.2&lt;/a&gt;。语法 &lt;a href=&quot;#section-10.4.3&quot;&gt;10.4.3&lt;/a&gt;。清单评估 &lt;a href=&quot;#section-10.4.4&quot;&gt;10.4.4&lt;/a&gt;。匹配状态令牌和ETag &lt;a href=&quot;#section-10.4.5&quot;&gt;10.4.5&lt;/a&gt;。如果标题和非DAV感知代理 &lt;a href=&quot;#section-10.4.6&quot;&gt;10.4.6&lt;/a&gt;。示例-无标签生产 &lt;a href=&quot;#section-10.4.7&quot;&gt;10.4.7&lt;/a&gt;。示例-在无标签生产中使用&amp;ldquo;不&amp;rdquo; 10.4.8。示例-使条件始终评估为True &lt;a href=&quot;#section-10.4.9&quot;&gt;10.4.9&lt;/a&gt;。示例-COPY 10.4.10中带标题的标记列表。示例-将锁令牌与集合锁匹配 &lt;a href=&quot;#section-10.4.11&quot;&gt;10.4.11&lt;/a&gt;。示例-在未映射的URL上匹配ETag &lt;a href=&quot;#section-10.5&quot;&gt;10.5&lt;/a&gt;。锁令牌头 &lt;a href=&quot;#section-10.6&quot;&gt;10.6&lt;/a&gt;。覆盖标题 &lt;a href=&quot;#section-10.7&quot;&gt;10.7&lt;/a&gt;。超时请求标头 &lt;a href=&quot;#section-11&quot;&gt;11&lt;/a&gt;。 HTTP / 1.1 &lt;a href=&quot;#section-11.1&quot;&gt;11.1的&lt;/a&gt;状态代码扩展 。 207多状态 &lt;a href=&quot;#section-11.2&quot;&gt;11.2&lt;/a&gt;。 422不可处理实体 &lt;a href=&quot;#section-11.3&quot;&gt;11.3&lt;/a&gt;。 423锁定 &lt;a href=&quot;#section-11.4&quot;&gt;11.4&lt;/a&gt;。 424依赖失败 &lt;a href=&quot;#section-11.5&quot;&gt;11.5&lt;/a&gt;。 507存储空间不足 &lt;a href=&quot;#section-12&quot;&gt;12&lt;/a&gt;。 HTTP状态代码的使用 &lt;a href=&quot;#section-12.1&quot;&gt;12.1&lt;/a&gt;。 412前提条件失败 &lt;a href=&quot;#section-12.2&quot;&gt;12.2&lt;/a&gt;。 414请求URI太长 &lt;a href=&quot;#section-13&quot;&gt;13&lt;/a&gt;。多状态响应 &lt;a href=&quot;#section-13.1&quot;&gt;13.1&lt;/a&gt;。响应标题 &lt;a href=&quot;#section-13.2&quot;&gt;13.2&lt;/a&gt;。处理重定向的子资源 &lt;a href=&quot;#section-13.3&quot;&gt;13.3&lt;/a&gt;。内部状态代码 &lt;a href=&quot;#section-14&quot;&gt;14&lt;/a&gt;。 XML元素定义 &lt;a href=&quot;#section-14.1&quot;&gt;14.1&lt;/a&gt;。 activelock XML元素 &lt;a href=&quot;#section-14.2&quot;&gt;14.2&lt;/a&gt;。 allprop XML元素 &lt;a href=&quot;#section-14.3&quot;&gt;14.3&lt;/a&gt;。集合XML元素 &lt;a href=&quot;#section-14.4&quot;&gt;14.4&lt;/a&gt;。深度XML元素 &lt;a href=&quot;#section-14.5&quot;&gt;14.5&lt;/a&gt;。错误XML元素 &lt;a href=&quot;#section-14.6&quot;&gt;14.6&lt;/a&gt;。独家XML元素 &lt;a href=&quot;#section-14.7&quot;&gt;14.7&lt;/a&gt;。 href XML元素 &lt;a href=&quot;#section-14.8&quot;&gt;14.8&lt;/a&gt;。包括XML元素 &lt;a href=&quot;#section-14.9&quot;&gt;14.9&lt;/a&gt;。位置XML元素 &lt;a href=&quot;#section-14.10&quot;&gt;14.10&lt;/a&gt;。 lockentry XML元素 &lt;a href=&quot;#section-14.11&quot;&gt;14.11&lt;/a&gt;。 lockinfo XML元素 &lt;a href=&quot;#section-14.12&quot;&gt;14.12&lt;/a&gt;。 lockroot XML元素.................................... &lt;a href=&quot;#section-14.13&quot;&gt;14.13&lt;/a&gt;。 lockscope XML元素 &lt;a href=&quot;#section-14.14&quot;&gt;14.14&lt;/a&gt;。锁令牌XML元素 &lt;a href=&quot;#section-14.15&quot;&gt;14.15&lt;/a&gt;。锁定类型XML元素 &lt;a href=&quot;#section-14.16&quot;&gt;14.16&lt;/a&gt;。多状态XML元素 &lt;a href=&quot;#section-14.17&quot;&gt;14.17&lt;/a&gt;。所有者XML元素 &lt;a href=&quot;#section-14.18&quot;&gt;14.18&lt;/a&gt;。道具XML元素 &lt;a href=&quot;#section-14.19&quot;&gt;14.19&lt;/a&gt;。 propertyupdate XML元素 &lt;a href=&quot;#section-14.20&quot;&gt;14.20&lt;/a&gt;。支持XML元素 &lt;a href=&quot;#section-14.21&quot;&gt;14.21&lt;/a&gt;。 propname XML元素 &lt;a href=&quot;#section-14.22&quot;&gt;14.22&lt;/a&gt;。 propstat XML元素 &lt;a href=&quot;#section-14.23&quot;&gt;14.23&lt;/a&gt;。删除XML元素 &lt;a href=&quot;#section-14.24&quot;&gt;14.24&lt;/a&gt;。响应XML元素 &lt;a href=&quot;#section-14.25&quot;&gt;14.25&lt;/a&gt;。 responsedescription XML元素 &lt;a href=&quot;#section-14.26&quot;&gt;14.26&lt;/a&gt;。设置XML元素 &lt;a href=&quot;#section-14.27&quot;&gt;14.27&lt;/a&gt;。共享XML元素 &lt;a href=&quot;#section-14.28&quot;&gt;14.28&lt;/a&gt;。状态XML元素 &lt;a href=&quot;#section-14.29&quot;&gt;14.29&lt;/a&gt;。超时XML元素 &lt;a href=&quot;#section-14.30&quot;&gt;14.30&lt;/a&gt;。编写XML元素 &lt;a href=&quot;#section-15&quot;&gt;15&lt;/a&gt;。 DAV属性 &lt;a href=&quot;#section-16&quot;&gt;16&lt;/a&gt;。前置条件/​​后置条件XML元素 &lt;a href=&quot;#section-17&quot;&gt;17&lt;/a&gt;。 DAV中的XML可扩展性 &lt;a href=&quot;#section-18&quot;&gt;18&lt;/a&gt;。 DAV符合性等级 &lt;a href=&quot;#section-18.1&quot;&gt;18.1&lt;/a&gt;。 1级 &lt;a href=&quot;#section-18.2&quot;&gt;18.2&lt;/a&gt;。 2级 &lt;a href=&quot;#section-18.3&quot;&gt;18.3&lt;/a&gt;。第3类 &lt;a href=&quot;#section-19&quot;&gt;19&lt;/a&gt;。国际化注意事项 &lt;a href=&quot;#section-20&quot;&gt;20&lt;/a&gt;。安全注意事项 &lt;a href=&quot;#section-20.1&quot;&gt;20.1&lt;/a&gt;。客户认证 &lt;a href=&quot;#section-20.2&quot;&gt;20.2&lt;/a&gt;。拒绝服务 &lt;a href=&quot;#section-20.3&quot;&gt;20.3&lt;/a&gt;。通过隐蔽性获得安全性 &lt;a href=&quot;#section-20.4&quot;&gt;20.4&lt;/a&gt;。与锁&lt;a href=&quot;#section-20.5&quot;&gt;20.5相关的&lt;/a&gt;隐私问题 。连接到属性的隐私问题 &lt;a href=&quot;#section-20.6&quot;&gt;20.6&lt;/a&gt;。 XML实体的含义 &lt;a href=&quot;#section-20.7&quot;&gt;20.7&lt;/a&gt;。与锁令牌相关的风险 &lt;a href=&quot;#section-20.8&quot;&gt;20.8&lt;/a&gt;。托管恶意内容 &lt;a href=&quot;#section-21&quot;&gt;21&lt;/a&gt;。 IANA注意事项 &lt;a href=&quot;#section-21.1&quot;&gt;21.1&lt;/a&gt;。新URI方案 &lt;a href=&quot;#section-21.2&quot;&gt;21.2&lt;/a&gt;。 XML命名空间 &lt;a href=&quot;#section-21.3&quot;&gt;21.3&lt;/a&gt;。消息头字段 &lt;a href=&quot;#section-21.3.1&quot;&gt;21.3.1&lt;/a&gt;。 DAV &lt;a href=&quot;#section-21.3.2&quot;&gt;21.3.2&lt;/a&gt;。深度 &lt;a href=&quot;#section-21.3.3&quot;&gt;21.3.3&lt;/a&gt;。目的地 &lt;a href=&quot;#section-21.3.4&quot;&gt;21.3.4&lt;/a&gt;。如果 &lt;a href=&quot;#section-21.3.5&quot;&gt;21.3.5&lt;/a&gt;。锁令牌 &lt;a href=&quot;#section-21.3.6&quot;&gt;21.3.6&lt;/a&gt;。覆盖 &lt;a href=&quot;#section-21.3.7&quot;&gt;21.3.7&lt;/a&gt;。超时 &lt;a href=&quot;#section-21.4&quot;&gt;21.4&lt;/a&gt;。 HTTP状态代码 &lt;a href=&quot;#section-22&quot;&gt;22&lt;/a&gt;。致谢............................................................ &lt;a href=&quot;#section-23&quot;&gt;23&lt;/a&gt;。本规范的贡献者 &lt;a href=&quot;#section-24&quot;&gt;24&lt;/a&gt;。&lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518的&lt;/a&gt;作者&lt;a href=&quot;#section-25&quot;&gt;25&lt;/a&gt;。参考文献 &lt;a href=&quot;#section-25.1&quot;&gt;25.1&lt;/a&gt;。规范性引用文件 &lt;a href=&quot;#section-25.2&quot;&gt;25.2&lt;/a&gt;。资料性参考 &lt;a href=&quot;#appendix-A&quot;&gt;附录A&lt;/a&gt;。有关处理XML元素 &lt;a href=&quot;#appendix-A.1&quot;&gt;A.1的说明&lt;/a&gt;。关于空XML元素的注释 &lt;a href=&quot;#appendix-A.2&quot;&gt;A.2&lt;/a&gt;。关于非法XML处理的注释 &lt;a href=&quot;#appendix-A.3&quot;&gt;A.3&lt;/a&gt;。示例&lt;a href=&quot;#appendix-A.4&quot;&gt;-XML&lt;/a&gt;语法错误 A.4。实施例-意外的XML元素 &lt;a href=&quot;#appendix-B&quot;&gt;附录B&lt;/a&gt;。在HTTP客户端兼容性说明 &lt;a href=&quot;#appendix-C&quot;&gt;附录C&lt;/a&gt;。该&amp;ldquo;opaquelocktoken&amp;rdquo;计划和URI &lt;a href=&quot;#appendix-D&quot;&gt;附录d&lt;/a&gt;。空锁资源 &lt;a href=&quot;#appendix-D.1&quot;&gt;D.1&lt;/a&gt;。指导客户使用LOCK创建资源 &lt;a href=&quot;#appendix-E&quot;&gt;附录E&lt;/a&gt;。要求认证&lt;a href=&quot;#appendix-F&quot;&gt;附录F的&lt;/a&gt;客户指南 。&lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518 &lt;/a&gt;&lt;a href=&quot;#appendix-F.1&quot;&gt;F.1&lt;/a&gt;的变更摘要。客户端和服务器实现&lt;a href=&quot;#appendix-F.2&quot;&gt;F.2的&lt;/a&gt;更改 。服务器实现的更改 &lt;a href=&quot;#appendix-F.3&quot;&gt;F.3&lt;/a&gt;。其他更改....................................................</target>
        </trans-unit>
        <trans-unit id="5314ebdcf29205bc56fbbcaea0c60b012d05ccf0" translate="yes" xml:space="preserve">
          <source>Status of responses including a &lt;code&gt;Location&lt;/code&gt; header: &lt;a href=&quot;../status/201&quot;&gt;&lt;code&gt;201&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../status/301&quot;&gt;&lt;code&gt;301&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../status/302&quot;&gt;&lt;code&gt;302&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../status/303&quot;&gt;&lt;code&gt;303&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../status/307&quot;&gt;&lt;code&gt;307&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../status/308&quot;&gt;&lt;code&gt;308&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">的反应，包括一个状态 &lt;code&gt;Location&lt;/code&gt; 标头：&lt;a href=&quot;../status/201&quot;&gt; &lt;code&gt;201&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../status/301&quot;&gt; &lt;code&gt;301&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../status/302&quot;&gt; &lt;code&gt;302&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../status/303&quot;&gt; &lt;code&gt;303&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../status/307&quot;&gt; &lt;code&gt;307&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../status/308&quot;&gt; &lt;code&gt;308&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d856fa610b4491baa384c8f7803b6e1e2fc35cdc" translate="yes" xml:space="preserve">
          <source>Status of this Memo

   This document specifies an Internet standards track protocol for the
   Internet community, and requests discussion and suggestions for
   improvements.  Please refer to the current edition of the &quot;Internet
   Official Protocol Standards&quot; (STD 1) for the standardization state
   and status of this protocol.  Distribution of this memo is unlimited.

Copyright Notice

   Copyright (C) The Internet Society (1999).  All Rights Reserved.

Abstract

   The Hypertext Transfer Protocol (HTTP) is an application-level
   protocol for distributed, collaborative, hypermedia information
   systems. It is a generic, stateless, protocol which can be used for
   many tasks beyond its use for hypertext, such as name servers and
   distributed object management systems, through extension of its
   request methods, error codes and headers [&lt;a href=&quot;#ref-47&quot;&gt;47&lt;/a&gt;]. A feature of HTTP is
   the typing and negotiation of data representation, allowing systems
   to be built independently of the data being transferred.

   HTTP has been in use by the World-Wide Web global information
   initiative since 1990. This specification defines the protocol
   referred to as &quot;HTTP/1.1&quot;, and is an update to &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt; [&lt;a href=&quot;#ref-33&quot;&gt;33&lt;/a&gt;]. 

Table of Contents

   &lt;a href=&quot;#section-1&quot;&gt;1&lt;/a&gt;   Introduction 
   &lt;a href=&quot;#section-1.1&quot;&gt;1.1&lt;/a&gt;    Purpose
   &lt;a href=&quot;#section-1.2&quot;&gt;1.2&lt;/a&gt;   Requirements 
   &lt;a href=&quot;#section-1.3&quot;&gt;1.3&lt;/a&gt;   Terminology 
   &lt;a href=&quot;#section-1.4&quot;&gt;1.4&lt;/a&gt;   Overall Operation 
   &lt;a href=&quot;#section-2&quot;&gt;2&lt;/a&gt;   Notational Conventions and Generic Grammar 
   &lt;a href=&quot;#section-2.1&quot;&gt;2.1&lt;/a&gt;   Augmented BNF 
   &lt;a href=&quot;#section-2.2&quot;&gt;2.2&lt;/a&gt;   Basic Rules 
   &lt;a href=&quot;#section-3&quot;&gt;3&lt;/a&gt;   Protocol Parameters 
   &lt;a href=&quot;#section-3.1&quot;&gt;3.1&lt;/a&gt;   HTTP Version 
   &lt;a href=&quot;#section-3.2&quot;&gt;3.2&lt;/a&gt;   Uniform Resource Identifiers 
   &lt;a href=&quot;#section-3.2.1&quot;&gt;3.2.1&lt;/a&gt;    General Syntax 
   &lt;a href=&quot;#section-3.2.2&quot;&gt;3.2.2&lt;/a&gt;    http URL 
   &lt;a href=&quot;#section-3.2.3&quot;&gt;3.2.3&lt;/a&gt;    URI Comparison 
   &lt;a href=&quot;#section-3.3&quot;&gt;3.3&lt;/a&gt;   Date/Time Formats 
   &lt;a href=&quot;#section-3.3.1&quot;&gt;3.3.1&lt;/a&gt;    Full Date 
   &lt;a href=&quot;#section-3.3.2&quot;&gt;3.3.2&lt;/a&gt;    Delta Seconds 
   &lt;a href=&quot;#section-3.4&quot;&gt;3.4&lt;/a&gt;   Character Sets 
   &lt;a href=&quot;#section-3.4.1&quot;&gt;3.4.1&lt;/a&gt;    Missing Charset 
   &lt;a href=&quot;#section-3.5&quot;&gt;3.5&lt;/a&gt;   Content Codings 
   &lt;a href=&quot;#section-3.6&quot;&gt;3.6&lt;/a&gt;   Transfer Codings 
   &lt;a href=&quot;#section-3.6.1&quot;&gt;3.6.1&lt;/a&gt;    Chunked Transfer Coding 
   &lt;a href=&quot;#section-3.7&quot;&gt;3.7&lt;/a&gt;   Media Types 
   &lt;a href=&quot;#section-3.7.1&quot;&gt;3.7.1&lt;/a&gt;    Canonicalization and Text Defaults 
   &lt;a href=&quot;#section-3.7.2&quot;&gt;3.7.2&lt;/a&gt;    Multipart Types 
   &lt;a href=&quot;#section-3.8&quot;&gt;3.8&lt;/a&gt;   Product Tokens 
   &lt;a href=&quot;#section-3.9&quot;&gt;3.9&lt;/a&gt;   Quality Values 
   &lt;a href=&quot;#section-3.10&quot;&gt;3.10&lt;/a&gt;  Language Tags 
   &lt;a href=&quot;#section-3.11&quot;&gt;3.11&lt;/a&gt;  Entity Tags 
   &lt;a href=&quot;#section-3.12&quot;&gt;3.12&lt;/a&gt;  Range Units 
   &lt;a href=&quot;#section-4&quot;&gt;4&lt;/a&gt;   HTTP Message 
   &lt;a href=&quot;#section-4.1&quot;&gt;4.1&lt;/a&gt;   Message Types 
   &lt;a href=&quot;#section-4.2&quot;&gt;4.2&lt;/a&gt;   Message Headers 
   &lt;a href=&quot;#section-4.3&quot;&gt;4.3&lt;/a&gt;   Message Body 
   &lt;a href=&quot;#section-4.4&quot;&gt;4.4&lt;/a&gt;   Message Length 
   &lt;a href=&quot;#section-4.5&quot;&gt;4.5&lt;/a&gt;   General Header Fields 
   &lt;a href=&quot;#section-5&quot;&gt;5&lt;/a&gt;   Request 
   &lt;a href=&quot;#section-5.1&quot;&gt;5.1&lt;/a&gt;   Request-Line 
   &lt;a href=&quot;#section-5.1.1&quot;&gt;5.1.1&lt;/a&gt;    Method 
   &lt;a href=&quot;#section-5.1.2&quot;&gt;5.1.2&lt;/a&gt;    Request-URI 
   &lt;a href=&quot;#section-5.2&quot;&gt;5.2&lt;/a&gt;   The Resource Identified by a Request 
   &lt;a href=&quot;#section-5.3&quot;&gt;5.3&lt;/a&gt;   Request Header Fields 
   &lt;a href=&quot;#section-6&quot;&gt;6&lt;/a&gt;   Response 
   &lt;a href=&quot;#section-6.1&quot;&gt;6.1&lt;/a&gt;   Status-Line 
   &lt;a href=&quot;#section-6.1.1&quot;&gt;6.1.1&lt;/a&gt;    Status Code and Reason Phrase 
   &lt;a href=&quot;#section-6.2&quot;&gt;6.2&lt;/a&gt;   Response Header Fields ...................................... 

   &lt;a href=&quot;#section-7&quot;&gt;7&lt;/a&gt;   Entity 
   &lt;a href=&quot;#section-7.1&quot;&gt;7.1&lt;/a&gt;   Entity Header Fields 
   &lt;a href=&quot;#section-7.2&quot;&gt;7.2&lt;/a&gt;   Entity Body 
   &lt;a href=&quot;#section-7.2.1&quot;&gt;7.2.1&lt;/a&gt;    Type 
   &lt;a href=&quot;#section-7.2.2&quot;&gt;7.2.2&lt;/a&gt;    Entity Length 
   &lt;a href=&quot;#section-8&quot;&gt;8&lt;/a&gt;   Connections 
   &lt;a href=&quot;#section-8.1&quot;&gt;8.1&lt;/a&gt;   Persistent Connections 
   &lt;a href=&quot;#section-8.1.1&quot;&gt;8.1.1&lt;/a&gt;    Purpose 
   &lt;a href=&quot;#section-8.1.2&quot;&gt;8.1.2&lt;/a&gt;    Overall Operation 
   &lt;a href=&quot;#section-8.1.3&quot;&gt;8.1.3&lt;/a&gt;    Proxy Servers 
   &lt;a href=&quot;#section-8.1.4&quot;&gt;8.1.4&lt;/a&gt;    Practical Considerations 
   &lt;a href=&quot;#section-8.2&quot;&gt;8.2&lt;/a&gt;   Message Transmission Requirements 
   &lt;a href=&quot;#section-8.2.1&quot;&gt;8.2.1&lt;/a&gt;    Persistent Connections and Flow Control 
   &lt;a href=&quot;#section-8.2.2&quot;&gt;8.2.2&lt;/a&gt;    Monitoring Connections for Error Status Messages 
   &lt;a href=&quot;#section-8.2.3&quot;&gt;8.2.3&lt;/a&gt;    Use of the 100 (Continue) Status 
   &lt;a href=&quot;#section-8.2.4&quot;&gt;8.2.4&lt;/a&gt;    Client Behavior if Server Prematurely Closes Connection ..50
   &lt;a href=&quot;#section-9&quot;&gt;9&lt;/a&gt;   Method Definitions 
   &lt;a href=&quot;#section-9.1&quot;&gt;9.1&lt;/a&gt;   Safe and Idempotent Methods 
   &lt;a href=&quot;#section-9.1.1&quot;&gt;9.1.1&lt;/a&gt;    Safe Methods 
   &lt;a href=&quot;#section-9.1.2&quot;&gt;9.1.2&lt;/a&gt;    Idempotent Methods 
   &lt;a href=&quot;#section-9.2&quot;&gt;9.2&lt;/a&gt;   OPTIONS 
   &lt;a href=&quot;#section-9.3&quot;&gt;9.3&lt;/a&gt;   GET 
   &lt;a href=&quot;#section-9.4&quot;&gt;9.4&lt;/a&gt;   HEAD 
   &lt;a href=&quot;#section-9.5&quot;&gt;9.5&lt;/a&gt;   POST 
   &lt;a href=&quot;#section-9.6&quot;&gt;9.6&lt;/a&gt;   PUT 
   &lt;a href=&quot;#section-9.7&quot;&gt;9.7&lt;/a&gt;   DELETE 
   &lt;a href=&quot;#section-9.8&quot;&gt;9.8&lt;/a&gt;   TRACE 
   &lt;a href=&quot;#section-9.9&quot;&gt;9.9&lt;/a&gt;   CONNECT 
   &lt;a href=&quot;#section-10&quot;&gt;10&lt;/a&gt;   Status Code Definitions 
   &lt;a href=&quot;#section-10.1&quot;&gt;10.1&lt;/a&gt;  Informational 1xx 
   &lt;a href=&quot;#section-10.1.1&quot;&gt;10.1.1&lt;/a&gt;   100 Continue 
   &lt;a href=&quot;#section-10.1.2&quot;&gt;10.1.2&lt;/a&gt;   101 Switching Protocols 
   &lt;a href=&quot;#section-10.2&quot;&gt;10.2&lt;/a&gt;  Successful 2xx 
   &lt;a href=&quot;#section-10.2.1&quot;&gt;10.2.1&lt;/a&gt;   200 OK 
   &lt;a href=&quot;#section-10.2.2&quot;&gt;10.2.2&lt;/a&gt;   201 Created 
   &lt;a href=&quot;#section-10.2.3&quot;&gt;10.2.3&lt;/a&gt;   202 Accepted 
   &lt;a href=&quot;#section-10.2.4&quot;&gt;10.2.4&lt;/a&gt;   203 Non-Authoritative Information 
   &lt;a href=&quot;#section-10.2.5&quot;&gt;10.2.5&lt;/a&gt;   204 No Content 
   &lt;a href=&quot;#section-10.2.6&quot;&gt;10.2.6&lt;/a&gt;   205 Reset Content 
   &lt;a href=&quot;#section-10.2.7&quot;&gt;10.2.7&lt;/a&gt;   206 Partial Content 
   &lt;a href=&quot;#section-10.3&quot;&gt;10.3&lt;/a&gt;  Redirection 3xx 
   &lt;a href=&quot;#section-10.3.1&quot;&gt;10.3.1&lt;/a&gt;   300 Multiple Choices 
   &lt;a href=&quot;#section-10.3.2&quot;&gt;10.3.2&lt;/a&gt;   301 Moved Permanently 
   &lt;a href=&quot;#section-10.3.3&quot;&gt;10.3.3&lt;/a&gt;   302 Found 
   &lt;a href=&quot;#section-10.3.4&quot;&gt;10.3.4&lt;/a&gt;   303 See Other 
   &lt;a href=&quot;#section-10.3.5&quot;&gt;10.3.5&lt;/a&gt;   304 Not Modified 
   &lt;a href=&quot;#section-10.3.6&quot;&gt;10.3.6&lt;/a&gt;   305 Use Proxy 
   &lt;a href=&quot;#section-10.3.7&quot;&gt;10.3.7&lt;/a&gt;   306 (Unused) ............................................. 

   &lt;a href=&quot;#section-10.3.8&quot;&gt;10.3.8&lt;/a&gt;   307 Temporary Redirect 
   &lt;a href=&quot;#section-10.4&quot;&gt;10.4&lt;/a&gt;  Client Error 4xx 
   &lt;a href=&quot;#section-10.4.1&quot;&gt;10.4.1&lt;/a&gt;    400 Bad Request 
   &lt;a href=&quot;#section-10.4.2&quot;&gt;10.4.2&lt;/a&gt;    401 Unauthorized 
   &lt;a href=&quot;#section-10.4.3&quot;&gt;10.4.3&lt;/a&gt;    402 Payment Required 
   &lt;a href=&quot;#section-10.4.4&quot;&gt;10.4.4&lt;/a&gt;    403 Forbidden 
   &lt;a href=&quot;#section-10.4.5&quot;&gt;10.4.5&lt;/a&gt;    404 Not Found 
   &lt;a href=&quot;#section-10.4.6&quot;&gt;10.4.6&lt;/a&gt;    405 Method Not Allowed 
   &lt;a href=&quot;#section-10.4.7&quot;&gt;10.4.7&lt;/a&gt;    406 Not Acceptable 
   &lt;a href=&quot;#section-10.4.8&quot;&gt;10.4.8&lt;/a&gt;    407 Proxy Authentication Required 
   &lt;a href=&quot;#section-10.4.9&quot;&gt;10.4.9&lt;/a&gt;    408 Request Timeout 
   &lt;a href=&quot;#section-10.4.10&quot;&gt;10.4.10&lt;/a&gt;   409 Conflict 
   &lt;a href=&quot;#section-10.4.11&quot;&gt;10.4.11&lt;/a&gt;   410 Gone 
   &lt;a href=&quot;#section-10.4.12&quot;&gt;10.4.12&lt;/a&gt;   411 Length Required 
   &lt;a href=&quot;#section-10.4.13&quot;&gt;10.4.13&lt;/a&gt;   412 Precondition Failed 
   &lt;a href=&quot;#section-10.4.14&quot;&gt;10.4.14&lt;/a&gt;   413 Request Entity Too Large 
   &lt;a href=&quot;#section-10.4.15&quot;&gt;10.4.15&lt;/a&gt;   414 Request-URI Too Long 
   &lt;a href=&quot;#section-10.4.16&quot;&gt;10.4.16&lt;/a&gt;   415 Unsupported Media Type 
   &lt;a href=&quot;#section-10.4.17&quot;&gt;10.4.17&lt;/a&gt;   416 Requested Range Not Satisfiable 
   &lt;a href=&quot;#section-10.4.18&quot;&gt;10.4.18&lt;/a&gt;   417 Expectation Failed 
   &lt;a href=&quot;#section-10.5&quot;&gt;10.5&lt;/a&gt;  Server Error 5xx 
   &lt;a href=&quot;#section-10.5.1&quot;&gt;10.5.1&lt;/a&gt;   500 Internal Server Error 
   &lt;a href=&quot;#section-10.5.2&quot;&gt;10.5.2&lt;/a&gt;   501 Not Implemented 
   &lt;a href=&quot;#section-10.5.3&quot;&gt;10.5.3&lt;/a&gt;   502 Bad Gateway 
   &lt;a href=&quot;#section-10.5.4&quot;&gt;10.5.4&lt;/a&gt;   503 Service Unavailable 
   &lt;a href=&quot;#section-10.5.5&quot;&gt;10.5.5&lt;/a&gt;   504 Gateway Timeout 
   &lt;a href=&quot;#section-10.5.6&quot;&gt;10.5.6&lt;/a&gt;   505 HTTP Version Not Supported 
   &lt;a href=&quot;#section-11&quot;&gt;11&lt;/a&gt;   Access Authentication 
   &lt;a href=&quot;#section-12&quot;&gt;12&lt;/a&gt;   Content Negotiation 
   &lt;a href=&quot;#section-12.1&quot;&gt;12.1&lt;/a&gt;  Server-driven Negotiation 
   &lt;a href=&quot;#section-12.2&quot;&gt;12.2&lt;/a&gt;  Agent-driven Negotiation 
   &lt;a href=&quot;#section-12.3&quot;&gt;12.3&lt;/a&gt;  Transparent Negotiation 
   &lt;a href=&quot;#section-13&quot;&gt;13&lt;/a&gt;   Caching in HTTP 
   &lt;a href=&quot;#section-13.1.1&quot;&gt;13.1.1&lt;/a&gt;   Cache Correctness 
   &lt;a href=&quot;#section-13.1.2&quot;&gt;13.1.2&lt;/a&gt;   Warnings 
   &lt;a href=&quot;#section-13.1.3&quot;&gt;13.1.3&lt;/a&gt;   Cache-control Mechanisms 
   &lt;a href=&quot;#section-13.1.4&quot;&gt;13.1.4&lt;/a&gt;   Explicit User Agent Warnings 
   &lt;a href=&quot;#section-13.1.5&quot;&gt;13.1.5&lt;/a&gt;   Exceptions to the Rules and Warnings 
   &lt;a href=&quot;#section-13.1.6&quot;&gt;13.1.6&lt;/a&gt;   Client-controlled Behavior 
   &lt;a href=&quot;#section-13.2&quot;&gt;13.2&lt;/a&gt;  Expiration Model 
   &lt;a href=&quot;#section-13.2.1&quot;&gt;13.2.1&lt;/a&gt;   Server-Specified Expiration 
   &lt;a href=&quot;#section-13.2.2&quot;&gt;13.2.2&lt;/a&gt;   Heuristic Expiration 
   &lt;a href=&quot;#section-13.2.3&quot;&gt;13.2.3&lt;/a&gt;   Age Calculations 
   &lt;a href=&quot;#section-13.2.4&quot;&gt;13.2.4&lt;/a&gt;   Expiration Calculations 
   &lt;a href=&quot;#section-13.2.5&quot;&gt;13.2.5&lt;/a&gt;   Disambiguating Expiration Values 
   &lt;a href=&quot;#section-13.2.6&quot;&gt;13.2.6&lt;/a&gt;   Disambiguating Multiple Responses 
   &lt;a href=&quot;#section-13.3&quot;&gt;13.3&lt;/a&gt;  Validation Model 
   &lt;a href=&quot;#section-13.3.1&quot;&gt;13.3.1&lt;/a&gt;   Last-Modified Dates ...................................... 

   &lt;a href=&quot;#section-13.3.2&quot;&gt;13.3.2&lt;/a&gt;   Entity Tag Cache Validators 
   &lt;a href=&quot;#section-13.3.3&quot;&gt;13.3.3&lt;/a&gt;   Weak and Strong Validators 
   13.3.4   Rules for When to Use Entity Tags and Last-Modified Dates.89
   &lt;a href=&quot;#section-13.3.5&quot;&gt;13.3.5&lt;/a&gt;   Non-validating Conditionals 
   &lt;a href=&quot;#section-13.4&quot;&gt;13.4&lt;/a&gt;  Response Cacheability 
   &lt;a href=&quot;#section-13.5&quot;&gt;13.5&lt;/a&gt;  Constructing Responses From Caches 
   &lt;a href=&quot;#section-13.5.1&quot;&gt;13.5.1&lt;/a&gt;   End-to-end and Hop-by-hop Headers 
   &lt;a href=&quot;#section-13.5.2&quot;&gt;13.5.2&lt;/a&gt;   Non-modifiable Headers 
   &lt;a href=&quot;#section-13.5.3&quot;&gt;13.5.3&lt;/a&gt;   Combining Headers 
   &lt;a href=&quot;#section-13.5.4&quot;&gt;13.5.4&lt;/a&gt;   Combining Byte Ranges 
   &lt;a href=&quot;#section-13.6&quot;&gt;13.6&lt;/a&gt;  Caching Negotiated Responses 
   &lt;a href=&quot;#section-13.7&quot;&gt;13.7&lt;/a&gt;  Shared and Non-Shared Caches 
   &lt;a href=&quot;#section-13.8&quot;&gt;13.8&lt;/a&gt;  Errors or Incomplete Response Cache Behavior 
   &lt;a href=&quot;#section-13.9&quot;&gt;13.9&lt;/a&gt;  Side Effects of GET and HEAD 
   &lt;a href=&quot;#section-13.10&quot;&gt;13.10&lt;/a&gt;   Invalidation After Updates or Deletions 
   &lt;a href=&quot;#section-13.11&quot;&gt;13.11&lt;/a&gt;   Write-Through Mandatory 
   &lt;a href=&quot;#section-13.12&quot;&gt;13.12&lt;/a&gt;   Cache Replacement 
   &lt;a href=&quot;#section-13.13&quot;&gt;13.13&lt;/a&gt;   History Lists 
   &lt;a href=&quot;#section-14&quot;&gt;14&lt;/a&gt;   Header Field Definitions 
   &lt;a href=&quot;#section-14.1&quot;&gt;14.1&lt;/a&gt;  Accept 
   &lt;a href=&quot;#section-14.2&quot;&gt;14.2&lt;/a&gt;  Accept-Charset 
   &lt;a href=&quot;#section-14.3&quot;&gt;14.3&lt;/a&gt;  Accept-Encoding 
   &lt;a href=&quot;#section-14.4&quot;&gt;14.4&lt;/a&gt;  Accept-Language 
   &lt;a href=&quot;#section-14.5&quot;&gt;14.5&lt;/a&gt;  Accept-Ranges 
   &lt;a href=&quot;#section-14.6&quot;&gt;14.6&lt;/a&gt;  Age 
   &lt;a href=&quot;#section-14.7&quot;&gt;14.7&lt;/a&gt;  Allow 
   &lt;a href=&quot;#section-14.8&quot;&gt;14.8&lt;/a&gt;  Authorization 
   &lt;a href=&quot;#section-14.9&quot;&gt;14.9&lt;/a&gt;  Cache-Control 
   &lt;a href=&quot;#section-14.9.1&quot;&gt;14.9.1&lt;/a&gt;   What is Cacheable 
   &lt;a href=&quot;#section-14.9.2&quot;&gt;14.9.2&lt;/a&gt;   What May be Stored by Caches 
   &lt;a href=&quot;#section-14.9.3&quot;&gt;14.9.3&lt;/a&gt;   Modifications of the Basic Expiration Mechanism 
   &lt;a href=&quot;#section-14.9.4&quot;&gt;14.9.4&lt;/a&gt;   Cache Revalidation and Reload Controls 
   &lt;a href=&quot;#section-14.9.5&quot;&gt;14.9.5&lt;/a&gt;   No-Transform Directive 
   &lt;a href=&quot;#section-14.9.6&quot;&gt;14.9.6&lt;/a&gt;   Cache Control Extensions 
   &lt;a href=&quot;#section-14.10&quot;&gt;14.10&lt;/a&gt;   Connection 
   &lt;a href=&quot;#section-14.11&quot;&gt;14.11&lt;/a&gt;   Content-Encoding 
   &lt;a href=&quot;#section-14.12&quot;&gt;14.12&lt;/a&gt;   Content-Language 
   &lt;a href=&quot;#section-14.13&quot;&gt;14.13&lt;/a&gt;   Content-Length 
   &lt;a href=&quot;#section-14.14&quot;&gt;14.14&lt;/a&gt;   Content-Location 
   &lt;a href=&quot;#section-14.15&quot;&gt;14.15&lt;/a&gt;   Content-MD5 
   &lt;a href=&quot;#section-14.16&quot;&gt;14.16&lt;/a&gt;   Content-Range 
   &lt;a href=&quot;#section-14.17&quot;&gt;14.17&lt;/a&gt;   Content-Type 
   &lt;a href=&quot;#section-14.18&quot;&gt;14.18&lt;/a&gt;   Date 
   &lt;a href=&quot;#section-14.18.1&quot;&gt;14.18.1&lt;/a&gt;   Clockless Origin Server Operation 
   &lt;a href=&quot;#section-14.19&quot;&gt;14.19&lt;/a&gt;   ETag 
   &lt;a href=&quot;#section-14.20&quot;&gt;14.20&lt;/a&gt;   Expect 
   &lt;a href=&quot;#section-14.21&quot;&gt;14.21&lt;/a&gt;   Expires 
   &lt;a href=&quot;#section-14.22&quot;&gt;14.22&lt;/a&gt;   From ..................................................... 

   &lt;a href=&quot;#section-14.23&quot;&gt;14.23&lt;/a&gt;   Host 
   &lt;a href=&quot;#section-14.24&quot;&gt;14.24&lt;/a&gt;   If-Match 
   &lt;a href=&quot;#section-14.25&quot;&gt;14.25&lt;/a&gt;   If-Modified-Since 
   &lt;a href=&quot;#section-14.26&quot;&gt;14.26&lt;/a&gt;   If-None-Match 
   &lt;a href=&quot;#section-14.27&quot;&gt;14.27&lt;/a&gt;   If-Range 
   &lt;a href=&quot;#section-14.28&quot;&gt;14.28&lt;/a&gt;   If-Unmodified-Since 
   &lt;a href=&quot;#section-14.29&quot;&gt;14.29&lt;/a&gt;   Last-Modified 
   &lt;a href=&quot;#section-14.30&quot;&gt;14.30&lt;/a&gt;   Location 
   &lt;a href=&quot;#section-14.31&quot;&gt;14.31&lt;/a&gt;   Max-Forwards 
   &lt;a href=&quot;#section-14.32&quot;&gt;14.32&lt;/a&gt;   Pragma 
   &lt;a href=&quot;#section-14.33&quot;&gt;14.33&lt;/a&gt;   Proxy-Authenticate 
   &lt;a href=&quot;#section-14.34&quot;&gt;14.34&lt;/a&gt;   Proxy-Authorization 
   &lt;a href=&quot;#section-14.35&quot;&gt;14.35&lt;/a&gt;   Range 
   &lt;a href=&quot;#section-14.35.1&quot;&gt;14.35.1&lt;/a&gt;    Byte Ranges 
   &lt;a href=&quot;#section-14.35.2&quot;&gt;14.35.2&lt;/a&gt;    Range Retrieval Requests 
   &lt;a href=&quot;#section-14.36&quot;&gt;14.36&lt;/a&gt;   Referer 
   &lt;a href=&quot;#section-14.37&quot;&gt;14.37&lt;/a&gt;   Retry-After 
   &lt;a href=&quot;#section-14.38&quot;&gt;14.38&lt;/a&gt;   Server 
   &lt;a href=&quot;#section-14.39&quot;&gt;14.39&lt;/a&gt;   TE 
   &lt;a href=&quot;#section-14.40&quot;&gt;14.40&lt;/a&gt;   Trailer 
   &lt;a href=&quot;#section-14.41&quot;&gt;14.41&lt;/a&gt;  Transfer-Encoding
   &lt;a href=&quot;#section-14.42&quot;&gt;14.42&lt;/a&gt;   Upgrade 
   &lt;a href=&quot;#section-14.43&quot;&gt;14.43&lt;/a&gt;   User-Agent 
   &lt;a href=&quot;#section-14.44&quot;&gt;14.44&lt;/a&gt;   Vary 
   &lt;a href=&quot;#section-14.45&quot;&gt;14.45&lt;/a&gt;   Via 
   &lt;a href=&quot;#section-14.46&quot;&gt;14.46&lt;/a&gt;   Warning 
   &lt;a href=&quot;#section-14.47&quot;&gt;14.47&lt;/a&gt;   WWW-Authenticate 
   &lt;a href=&quot;#section-15&quot;&gt;15&lt;/a&gt; Security Considerations 
   &lt;a href=&quot;#section-15.1&quot;&gt;15.1&lt;/a&gt;      Personal Information
   &lt;a href=&quot;#section-15.1.1&quot;&gt;15.1.1&lt;/a&gt;   Abuse of Server Log Information 
   &lt;a href=&quot;#section-15.1.2&quot;&gt;15.1.2&lt;/a&gt;   Transfer of Sensitive Information 
   &lt;a href=&quot;#section-15.1.3&quot;&gt;15.1.3&lt;/a&gt;   Encoding Sensitive Information in URI's 
   &lt;a href=&quot;#section-15.1.4&quot;&gt;15.1.4&lt;/a&gt;   Privacy Issues Connected to Accept Headers 
   &lt;a href=&quot;#section-15.2&quot;&gt;15.2&lt;/a&gt;  Attacks Based On File and Path Names 
   &lt;a href=&quot;#section-15.3&quot;&gt;15.3&lt;/a&gt;  DNS Spoofing 
   &lt;a href=&quot;#section-15.4&quot;&gt;15.4&lt;/a&gt;  Location Headers and Spoofing 
   &lt;a href=&quot;#section-15.5&quot;&gt;15.5&lt;/a&gt;  Content-Disposition Issues 
   &lt;a href=&quot;#section-15.6&quot;&gt;15.6&lt;/a&gt;  Authentication Credentials and Idle Clients 
   &lt;a href=&quot;#section-15.7&quot;&gt;15.7&lt;/a&gt;  Proxies and Caching 
   &lt;a href=&quot;#section-15.7.1&quot;&gt;15.7.1&lt;/a&gt;    Denial of Service Attacks on Proxies
   &lt;a href=&quot;#section-16&quot;&gt;16&lt;/a&gt;   Acknowledgments 
   &lt;a href=&quot;#section-17&quot;&gt;17&lt;/a&gt;   References 
   &lt;a href=&quot;#section-18&quot;&gt;18&lt;/a&gt;   Authors' Addresses 
   &lt;a href=&quot;#section-19&quot;&gt;19&lt;/a&gt;   Appendices 
   &lt;a href=&quot;#section-19.1&quot;&gt;19.1&lt;/a&gt;  Internet Media Type message/http and application/http 
   &lt;a href=&quot;#section-19.2&quot;&gt;19.2&lt;/a&gt;  Internet Media Type multipart/byteranges 
   &lt;a href=&quot;#section-19.3&quot;&gt;19.3&lt;/a&gt;  Tolerant Applications 
   &lt;a href=&quot;#section-19.4&quot;&gt;19.4&lt;/a&gt;  Differences Between HTTP Entities and &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC 2045&lt;/a&gt; Entities .... 

   &lt;a href=&quot;#section-19.4.1&quot;&gt;19.4.1&lt;/a&gt;   MIME-Version 
   &lt;a href=&quot;#section-19.4.2&quot;&gt;19.4.2&lt;/a&gt;   Conversion to Canonical Form 
   &lt;a href=&quot;#section-19.4.3&quot;&gt;19.4.3&lt;/a&gt;   Conversion of Date Formats 
   &lt;a href=&quot;#section-19.4.4&quot;&gt;19.4.4&lt;/a&gt;   Introduction of Content-Encoding 
   &lt;a href=&quot;#section-19.4.5&quot;&gt;19.4.5&lt;/a&gt;   No Content-Transfer-Encoding 
   &lt;a href=&quot;#section-19.4.6&quot;&gt;19.4.6&lt;/a&gt;   Introduction of Transfer-Encoding 
   &lt;a href=&quot;#section-19.4.7&quot;&gt;19.4.7&lt;/a&gt;   MHTML and Line Length Limitations 
   &lt;a href=&quot;#section-19.5&quot;&gt;19.5&lt;/a&gt;  Additional Features 
   &lt;a href=&quot;#section-19.5.1&quot;&gt;19.5.1&lt;/a&gt;   Content-Disposition 
   &lt;a href=&quot;#section-19.6&quot;&gt;19.6&lt;/a&gt;  Compatibility with Previous Versions 
   &lt;a href=&quot;#section-19.6.1&quot;&gt;19.6.1&lt;/a&gt;   Changes from HTTP/1.0 
   &lt;a href=&quot;#section-19.6.2&quot;&gt;19.6.2&lt;/a&gt;   Compatibility with HTTP/1.0 Persistent Connections 
   &lt;a href=&quot;#section-19.6.3&quot;&gt;19.6.3&lt;/a&gt;   Changes from &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt;&lt;a href=&quot;#section-20&quot;&gt;20&lt;/a&gt;   Index 
   &lt;a href=&quot;#section-21&quot;&gt;21&lt;/a&gt;   Full Copyright Statement</source>
          <target state="translated">本备忘录的状态本文档指定了Internet社区的Internet标准跟踪协议，并要求讨论和提出改进建议。请参阅当前版本的&amp;ldquo; Internet官方协议标准&amp;rdquo;（STD 1）了解此协议的标准化状态。该备忘录的分发是无限的。版权声明版权所有（C）互联网协会（1999）。版权所有。摘要超文本传输​​协议（HTTP）是分布式，协作，超媒体信息系统的应用程序级协议。它是一种通用的无状态协议，通过扩展其请求方法，它可以用于超文本之外的许多任务，例如名称服务器和分布式对象管理系统。错误代码和标头[&lt;a href=&quot;#ref-47&quot;&gt;47&lt;/a&gt; ]。 HTTP的一个功能是数据表示的键入和协商，允许独立于要传输的数据来构建系统。自1990年以来，HTTP已由全球Web全球信息倡议使用。此规范定义了称为&amp;ldquo; HTTP / 1.1&amp;rdquo;的协议，并且是&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt; [ &lt;a href=&quot;#ref-33&quot;&gt;33&lt;/a&gt; ] 的更新。目录 &lt;a href=&quot;#section-1&quot;&gt;1&lt;/a&gt; 简介 &lt;a href=&quot;#section-1.1&quot;&gt;1.1&lt;/a&gt; 目的 &lt;a href=&quot;#section-1.2&quot;&gt;1.2&lt;/a&gt; 要求 &lt;a href=&quot;#section-1.3&quot;&gt;1.3&lt;/a&gt; 术语 &lt;a href=&quot;#section-1.4&quot;&gt;1.4&lt;/a&gt; 总体操作 &lt;a href=&quot;#section-2&quot;&gt;2&lt;/a&gt; 符号约定和通用语法 &lt;a href=&quot;#section-2.1&quot;&gt;2.1&lt;/a&gt; 增强的BNF &lt;a href=&quot;#section-2.2&quot;&gt;2.2&lt;/a&gt; 基本规则 &lt;a href=&quot;#section-3&quot;&gt;3&lt;/a&gt; 协议参数 &lt;a href=&quot;#section-3.1&quot;&gt;3.1&lt;/a&gt; HTTP版本 &lt;a href=&quot;#section-3.2&quot;&gt;3.2&lt;/a&gt; 统一资源标识符 &lt;a href=&quot;#section-3.2.1&quot;&gt;3.2.1&lt;/a&gt; 常规语法 &lt;a href=&quot;#section-3.2.2&quot;&gt;3.2.2&lt;/a&gt; HTTP URL &lt;a href=&quot;#section-3.2.3&quot;&gt;3.2.3&lt;/a&gt; URI比较 &lt;a href=&quot;#section-3.3&quot;&gt;3.3&lt;/a&gt; 日期/时间格式 &lt;a href=&quot;#section-3.3.1&quot;&gt;3.3.1&lt;/a&gt; 完整日期 &lt;a href=&quot;#section-3.3.2&quot;&gt;3.3.2&lt;/a&gt; 三角洲秒 &lt;a href=&quot;#section-3.4&quot;&gt;3.4&lt;/a&gt; 字符集 &lt;a href=&quot;#section-3.4.1&quot;&gt;3.4.1&lt;/a&gt; 缺少字符集 &lt;a href=&quot;#section-3.5&quot;&gt;3.5&lt;/a&gt; 内容 编码&lt;a href=&quot;#section-3.6&quot;&gt;3.6&lt;/a&gt; 传输 编码&lt;a href=&quot;#section-3.6.1&quot;&gt;3.6.1分&lt;/a&gt;块传输编码 &lt;a href=&quot;#section-3.7&quot;&gt;3.7&lt;/a&gt; 媒体类型 &lt;a href=&quot;#section-3.7.1&quot;&gt;3.7.1&lt;/a&gt; 规范化和文本默认值 &lt;a href=&quot;#section-3.7.2&quot;&gt;3.7.2&lt;/a&gt; 多部分类型 &lt;a href=&quot;#section-3.8&quot;&gt;3.8&lt;/a&gt; 产品令牌 &lt;a href=&quot;#section-3.9&quot;&gt;3.9&lt;/a&gt; 质量值 &lt;a href=&quot;#section-3.10&quot;&gt;3.10&lt;/a&gt; 语言标签 &lt;a href=&quot;#section-3.11&quot;&gt;3.11&lt;/a&gt; 实体标签 &lt;a href=&quot;#section-3.12&quot;&gt;3.12&lt;/a&gt; 范围单位 &lt;a href=&quot;#section-4&quot;&gt;4&lt;/a&gt; HTTP消息 &lt;a href=&quot;#section-4.1&quot;&gt;4.1&lt;/a&gt; 消息类型 &lt;a href=&quot;#section-4.2&quot;&gt;4.2&lt;/a&gt; 消息标题 &lt;a href=&quot;#section-4.3&quot;&gt;4.3&lt;/a&gt; 消息正文 &lt;a href=&quot;#section-4.4&quot;&gt;4.4&lt;/a&gt; 消息长度 &lt;a href=&quot;#section-4.5&quot;&gt;4.5&lt;/a&gt; 常规标题字段 &lt;a href=&quot;#section-5&quot;&gt;5&lt;/a&gt; 请求 &lt;a href=&quot;#section-5.1&quot;&gt;5.1&lt;/a&gt; 请求行 &lt;a href=&quot;#section-5.1.1&quot;&gt;5.1 .1&lt;/a&gt; 方法 &lt;a href=&quot;#section-5.1.2&quot;&gt;5.1.2&lt;/a&gt; Request-URI &lt;a href=&quot;#section-5.2&quot;&gt;5.2&lt;/a&gt; 请求标识的资源 &lt;a href=&quot;#section-5.3&quot;&gt;5.3&lt;/a&gt; 请求标题字段 &lt;a href=&quot;#section-6&quot;&gt;6&lt;/a&gt; 响应 &lt;a href=&quot;#section-6.1&quot;&gt;6.1&lt;/a&gt; 状态行 &lt;a href=&quot;#section-6.1.1&quot;&gt;6.1.1&lt;/a&gt; 状态代码和原因短语 &lt;a href=&quot;#section-6.2&quot;&gt;6.2&lt;/a&gt; 响应标题字段..................... ................. &lt;a href=&quot;#section-7&quot;&gt;7&lt;/a&gt; 实体 &lt;a href=&quot;#section-7.1&quot;&gt;7.1&lt;/a&gt; 实体头字段 &lt;a href=&quot;#section-7.2&quot;&gt;7.2&lt;/a&gt; 实体主体 &lt;a href=&quot;#section-7.2.1&quot;&gt;7.2.1&lt;/a&gt; 类型 &lt;a href=&quot;#section-7.2.2&quot;&gt;7.2.2&lt;/a&gt; 实体长度 &lt;a href=&quot;#section-8&quot;&gt;8&lt;/a&gt; 连接 &lt;a href=&quot;#section-8.1&quot;&gt;8.1&lt;/a&gt; 持久连接 &lt;a href=&quot;#section-8.1.1&quot;&gt;8.1.1&lt;/a&gt; 目的 &lt;a href=&quot;#section-8.1.2&quot;&gt;8.1.2&lt;/a&gt; 总体操作 &lt;a href=&quot;#section-8.1.3&quot;&gt;8.1 .3&lt;/a&gt; 代理服务器 &lt;a href=&quot;#section-8.1.4&quot;&gt;8.1.4&lt;/a&gt; 实际考虑因素 &lt;a href=&quot;#section-8.2&quot;&gt;8.2&lt;/a&gt; 消息传输要求 &lt;a href=&quot;#section-8.2.1&quot;&gt;8.2.1&lt;/a&gt; 持久连接和流控制 &lt;a href=&quot;#section-8.2.2&quot;&gt;8.2.2&lt;/a&gt; 监视错误状态消息的连接 &lt;a href=&quot;#section-8.2.3&quot;&gt;8.2.3&lt;/a&gt; 使用100（继续）状态 &lt;a href=&quot;#section-8.2.4&quot;&gt;8.2.4&lt;/a&gt; 如果服务器过早关闭连接，则客户端行为。 .50 &lt;a href=&quot;#section-9&quot;&gt;9&lt;/a&gt; 方法定义 &lt;a href=&quot;#section-9.1&quot;&gt;9.1&lt;/a&gt; 安全和幂等方法 &lt;a href=&quot;#section-9.1.1&quot;&gt;9.1.1&lt;/a&gt; 安全方法 &lt;a href=&quot;#section-9.1.2&quot;&gt;9.1.2&lt;/a&gt; 幂等方法 &lt;a href=&quot;#section-9.2&quot;&gt;9.2&lt;/a&gt; 选项 &lt;a href=&quot;#section-9.3&quot;&gt;9.3&lt;/a&gt; 获取 &lt;a href=&quot;#section-9.4&quot;&gt;9.4&lt;/a&gt; HEAD &lt;a href=&quot;#section-9.5&quot;&gt;9.5&lt;/a&gt; POST &lt;a href=&quot;#section-9.6&quot;&gt;9.6&lt;/a&gt; PUT &lt;a href=&quot;#section-9.7&quot;&gt;9.7&lt;/a&gt; DELETE &lt;a href=&quot;#section-9.8&quot;&gt;9.8&lt;/a&gt; TRACE &lt;a href=&quot;#section-9.9&quot;&gt;9.9&lt;/a&gt; CONNECT &lt;a href=&quot;#section-10&quot;&gt;10个&lt;/a&gt; 状态代码定义 &lt;a href=&quot;#section-10.1&quot;&gt;10.1&lt;/a&gt; 信息化1XX &lt;a href=&quot;#section-10.1.1&quot;&gt;10.1.1&lt;/a&gt; 100继续 &lt;a href=&quot;#section-10.1.2&quot;&gt;10.1.2&lt;/a&gt; 101切换协议 &lt;a href=&quot;#section-10.2&quot;&gt;10.2&lt;/a&gt; 成功的2xx &lt;a href=&quot;#section-10.2.1&quot;&gt;10.2.1&lt;/a&gt; 200 OK &lt;a href=&quot;#section-10.2.2&quot;&gt;10.2.2&lt;/a&gt; 201创建 &lt;a href=&quot;#section-10.2.3&quot;&gt;10.2.3&lt;/a&gt; 202接受 &lt;a href=&quot;#section-10.2.4&quot;&gt;10.2.4&lt;/a&gt; 203非权威信息 &lt;a href=&quot;#section-10.2.5&quot;&gt;10.2.5&lt;/a&gt; 204无内容 &lt;a href=&quot;#section-10.2.6&quot;&gt;10.2.6&lt;/a&gt; 205重置内容 &lt;a href=&quot;#section-10.2.7&quot;&gt;10.2.7&lt;/a&gt; 206部分内容 &lt;a href=&quot;#section-10.3&quot;&gt;10.3&lt;/a&gt; 重定向3xx &lt;a href=&quot;#section-10.3.1&quot;&gt;10.3.1&lt;/a&gt; 300多个选择 &lt;a href=&quot;#section-10.3.2&quot;&gt;10.3.2&lt;/a&gt; 301永久移动 &lt;a href=&quot;#section-10.3.3&quot;&gt;10.3.3&lt;/a&gt; 302找到 &lt;a href=&quot;#section-10.3.4&quot;&gt;10.3.4&lt;/a&gt; 303请参阅其他 &lt;a href=&quot;#section-10.3.5&quot;&gt;10.3.5&lt;/a&gt; 304未修改 &lt;a href=&quot;#section-10.3.6&quot;&gt;10.3.6&lt;/a&gt; 305使用代理 &lt;a href=&quot;#section-10.3.7&quot;&gt;10.3.7&lt;/a&gt; 306（未使用）.. .................................................... &lt;a href=&quot;#section-10.3.8&quot;&gt;10.3.8&lt;/a&gt; 307临时重定向 &lt;a href=&quot;#section-10.4&quot;&gt;10.4&lt;/a&gt; 客户端错误4xx &lt;a href=&quot;#section-10.4.1&quot;&gt;10.4.1&lt;/a&gt; 400错误的请求 &lt;a href=&quot;#section-10.4.2&quot;&gt;10.4.2&lt;/a&gt; 401未经授权的 &lt;a href=&quot;#section-10.4.3&quot;&gt;10.4.3&lt;/a&gt; 402需要付款 &lt;a href=&quot;#section-10.4.4&quot;&gt;10.4.4&lt;/a&gt; 403禁止 &lt;a href=&quot;#section-10.4.5&quot;&gt;10.4.5&lt;/a&gt; 404未找到 &lt;a href=&quot;#section-10.4.6&quot;&gt;10.4.6&lt;/a&gt; 405方法不允许 &lt;a href=&quot;#section-10.4.7&quot;&gt;10.4.7&lt;/a&gt; 406不可接受 &lt;a href=&quot;#section-10.4.8&quot;&gt;10.4.8&lt;/a&gt; 407需要代理身份验证 &lt;a href=&quot;#section-10.4.9&quot;&gt;10.4.9&lt;/a&gt; 408请求超时 &lt;a href=&quot;#section-10.4.10&quot;&gt;10.4.10&lt;/a&gt; 409冲突 &lt;a href=&quot;#section-10.4.11&quot;&gt;10.4.11&lt;/a&gt; 410已消失 &lt;a href=&quot;#section-10.4.12&quot;&gt;10.4.12&lt;/a&gt; 411所需长度 &lt;a href=&quot;#section-10.4.13&quot;&gt;10.4.13&lt;/a&gt; 412前提条件失败 &lt;a href=&quot;#section-10.4.14&quot;&gt;10.4.14&lt;/a&gt; 413请求实体太大 &lt;a href=&quot;#section-10.4.15&quot;&gt;10.4.15&lt;/a&gt; 414请求URI太长 &lt;a href=&quot;#section-10.4.16&quot;&gt;10.4.16&lt;/a&gt; 415不支持的媒体类型 &lt;a href=&quot;#section-10.4.17&quot;&gt;10.4.17&lt;/a&gt; 416请求的范围 不满足&lt;a href=&quot;#section-10.4.18&quot;&gt;10.4.18&lt;/a&gt; 417预期失败 &lt;a href=&quot;#section-10.5&quot;&gt;10.5&lt;/a&gt; 服务器错误5xx &lt;a href=&quot;#section-10.5.1&quot;&gt;10.5.1&lt;/a&gt; 500内部服务器错误 &lt;a href=&quot;#section-10.5.2&quot;&gt;10.5.2&lt;/a&gt; 501未实现 &lt;a href=&quot;#section-10.5.3&quot;&gt;10.5.3&lt;/a&gt; 502网关错误 &lt;a href=&quot;#section-10.5.4&quot;&gt;10.5.4&lt;/a&gt; 503服务不可用 &lt;a href=&quot;#section-10.5.5&quot;&gt;10.5.5&lt;/a&gt; 504网关超时 &lt;a href=&quot;#section-10.5.6&quot;&gt;10.5.6&lt;/a&gt; 505 HTTP版本不受支持 &lt;a href=&quot;#section-11&quot;&gt;11&lt;/a&gt; 访问验证 &lt;a href=&quot;#section-12&quot;&gt;12&lt;/a&gt; 内容协商 &lt;a href=&quot;#section-12.1&quot;&gt;12.1&lt;/a&gt; 服务器驱动的协商 &lt;a href=&quot;#section-12.2&quot;&gt;12.2&lt;/a&gt; 代理驱动的协商 &lt;a href=&quot;#section-12.3&quot;&gt;12.3&lt;/a&gt; 透明协商 &lt;a href=&quot;#section-13&quot;&gt;13&lt;/a&gt; HTTP &lt;a href=&quot;#section-13.1.1&quot;&gt;13.1.1中的&lt;/a&gt;缓存 缓存正确性 &lt;a href=&quot;#section-13.1.2&quot;&gt;13.1.2&lt;/a&gt; 警告 &lt;a href=&quot;#section-13.1.3&quot;&gt;13.1.3&lt;/a&gt; 缓存控制机制 &lt;a href=&quot;#section-13.1.4&quot;&gt;13.1.4&lt;/a&gt; 明确的用户代理警告 &lt;a href=&quot;#section-13.1.5&quot;&gt;13.1.5&lt;/a&gt; 的例外规则和警告 &lt;a href=&quot;#section-13.1.6&quot;&gt;13.1.6&lt;/a&gt; 客户控制的行为 &lt;a href=&quot;#section-13.2&quot;&gt;13.2&lt;/a&gt; 过期模型在 &lt;a href=&quot;#section-13.2.1&quot;&gt;13.2.1&lt;/a&gt; 服务器指定过期 &lt;a href=&quot;#section-13.2.2&quot;&gt;13.2.2&lt;/a&gt; 启发式到期时间 &lt;a href=&quot;#section-13.2.3&quot;&gt;13.2.3&lt;/a&gt; 年龄计算 &lt;a href=&quot;#section-13.2.4&quot;&gt;13.2.4&lt;/a&gt; 到期时间计算 &lt;a href=&quot;#section-13.2.5&quot;&gt;13.2.5&lt;/a&gt; 消除到期值的 歧义&lt;a href=&quot;#section-13.2.6&quot;&gt;13.2.6&lt;/a&gt;消除多重响应的歧义 &lt;a href=&quot;#section-13.3&quot;&gt;13.3&lt;/a&gt; 验证模型 &lt;a href=&quot;#section-13.3.1&quot;&gt;13.3.1&lt;/a&gt; 上次修改日期............................................... &lt;a href=&quot;#section-13.3.2&quot;&gt;13.3.2&lt;/a&gt; 实体标签缓存验证器 &lt;a href=&quot;#section-13.3.3&quot;&gt;13.3.3&lt;/a&gt; 弱验证器13.3.4何时使用实体标签和最后修改日期的规则89 &lt;a href=&quot;#section-13.3.5&quot;&gt;13.3.5&lt;/a&gt; 非验证条件 &lt;a href=&quot;#section-13.4&quot;&gt;13.4&lt;/a&gt; 响应可缓存性 &lt;a href=&quot;#section-13.5&quot;&gt;13.5&lt;/a&gt; 从缓存构造响应 &lt;a href=&quot;#section-13.5.1&quot;&gt;13.5.1&lt;/a&gt; 端到端和逐跳标头 &lt;a href=&quot;#section-13.5.2&quot;&gt;13.5.2&lt;/a&gt; 不可修改标头 &lt;a href=&quot;#section-13.5.3&quot;&gt;13.5.3&lt;/a&gt; 组合标头 &lt;a href=&quot;#section-13.5.4&quot;&gt;13.5.4&lt;/a&gt; 组合字节范围 &lt;a href=&quot;#section-13.6&quot;&gt;13.6&lt;/a&gt; 缓存协商的响应 &lt;a href=&quot;#section-13.7&quot;&gt;13.7&lt;/a&gt; 共享和非共享缓存 &lt;a href=&quot;#section-13.8&quot;&gt;13.8&lt;/a&gt; 错误或响应缓存行为不完整 &lt;a href=&quot;#section-13.9&quot;&gt;13.9&lt;/a&gt; GET和HEAD的副作用 &lt;a href=&quot;#section-13.10&quot;&gt;13.10&lt;/a&gt; 更新或删除后失效 &lt;a href=&quot;#section-13.11&quot;&gt;13.11&lt;/a&gt; 直写式强制性 &lt;a href=&quot;#section-13.12&quot;&gt;13.12&lt;/a&gt; 缓存替换 &lt;a href=&quot;#section-13.13&quot;&gt;13.13&lt;/a&gt; 历史记录列表 &lt;a href=&quot;#section-14&quot;&gt;14&lt;/a&gt; 标头字段定义 &lt;a href=&quot;#section-14.1&quot;&gt;14.1&lt;/a&gt; 接受 &lt;a href=&quot;#section-14.2&quot;&gt;14.2&lt;/a&gt; 接受字符集 &lt;a href=&quot;#section-14.3&quot;&gt;14.3&lt;/a&gt; 接受编码 &lt;a href=&quot;#section-14.4&quot;&gt;14.4&lt;/a&gt; 接受语言 &lt;a href=&quot;#section-14.5&quot;&gt;14.5&lt;/a&gt; 接受范围， &lt;a href=&quot;#section-14.6&quot;&gt;14.6&lt;/a&gt; 年龄 &lt;a href=&quot;#section-14.7&quot;&gt;14.7&lt;/a&gt; 允许 &lt;a href=&quot;#section-14.8&quot;&gt;14.8&lt;/a&gt; 授权 &lt;a href=&quot;#section-14.9&quot;&gt;14.9&lt;/a&gt; 缓存控制 &lt;a href=&quot;#section-14.9.1&quot;&gt;14.9.1&lt;/a&gt; 什么是可缓存&lt;a href=&quot;#section-14.9.2&quot;&gt;14.9.2&lt;/a&gt;缓存 可以存储的内容 &lt;a href=&quot;#section-14.9.3&quot;&gt;14.9.3&lt;/a&gt; 基本过期机制的修改 &lt;a href=&quot;#section-14.9.4&quot;&gt;14.9.4&lt;/a&gt; 缓存重新验证和重载控件 &lt;a href=&quot;#section-14.9.5&quot;&gt;14.9.5&lt;/a&gt; 无变换指令 &lt;a href=&quot;#section-14.9.6&quot;&gt;14.9.6&lt;/a&gt; 缓存控制扩展 &lt;a href=&quot;#section-14.10&quot;&gt;14.10&lt;/a&gt; 连接 &lt;a href=&quot;#section-14.11&quot;&gt;14.11&lt;/a&gt; 内容编码 &lt;a href=&quot;#section-14.12&quot;&gt;14.12&lt;/a&gt; 内容语言 &lt;a href=&quot;#section-14.13&quot;&gt;14.13&lt;/a&gt; 内容长度 &lt;a href=&quot;#section-14.14&quot;&gt;14.14&lt;/a&gt; 内容位置 &lt;a href=&quot;#section-14.15&quot;&gt;14.15&lt;/a&gt; 内容MD5 &lt;a href=&quot;#section-14.16&quot;&gt;14.16&lt;/a&gt; 内容范围 &lt;a href=&quot;#section-14.17&quot;&gt;14.17&lt;/a&gt; Content-Type的 &lt;a href=&quot;#section-14.18&quot;&gt;14.18&lt;/a&gt; 日期 &lt;a href=&quot;#section-14.18.1&quot;&gt;14.18.1&lt;/a&gt; 无时钟源服务器运行 &lt;a href=&quot;#section-14.19&quot;&gt;14.19&lt;/a&gt; ETag的 &lt;a href=&quot;#section-14.20&quot;&gt;14.20&lt;/a&gt; 预计 &lt;a href=&quot;#section-14.21&quot;&gt;14.21&lt;/a&gt; 过期 &lt;a href=&quot;#section-14.22&quot;&gt;14.22&lt;/a&gt; 从.......................... .................................... &lt;a href=&quot;#section-14.23&quot;&gt;14.23&lt;/a&gt; 主机 &lt;a href=&quot;#section-14.24&quot;&gt;14.24&lt;/a&gt; If-Match &lt;a href=&quot;#section-14.25&quot;&gt;14.25&lt;/a&gt; If-Modified-Since &lt;a href=&quot;#section-14.26&quot;&gt;14.26&lt;/a&gt; If- &lt;a href=&quot;#section-14.27&quot;&gt;Non&lt;/a&gt; -Match 14.27 If-Range &lt;a href=&quot;#section-14.28&quot;&gt;14.28&lt;/a&gt; 如果未修改，自 &lt;a href=&quot;#section-14.29&quot;&gt;14.29开始&lt;/a&gt; 最后修改的 &lt;a href=&quot;#section-14.30&quot;&gt;14.30&lt;/a&gt; 位置 &lt;a href=&quot;#section-14.31&quot;&gt;14.31&lt;/a&gt; 最大转发 &lt;a href=&quot;#section-14.32&quot;&gt;14.32&lt;/a&gt; 语法 &lt;a href=&quot;#section-14.33&quot;&gt;14.33&lt;/a&gt; 代理身份验证 &lt;a href=&quot;#section-14.34&quot;&gt;14.34&lt;/a&gt; 代理授权 &lt;a href=&quot;#section-14.35&quot;&gt;14.35&lt;/a&gt; 范围 &lt;a href=&quot;#section-14.35.1&quot;&gt;14.35.1&lt;/a&gt; 字节范围 &lt;a href=&quot;#section-14.35.2&quot;&gt;14.35.2&lt;/a&gt; 范围检索请求 &lt;a href=&quot;#section-14.36&quot;&gt;14.36&lt;/a&gt; 引用程序 &lt;a href=&quot;#section-14.37&quot;&gt;14.37&lt;/a&gt; 重试 &lt;a href=&quot;#section-14.38&quot;&gt;14.38&lt;/a&gt; 服务器 &lt;a href=&quot;#section-14.39&quot;&gt;14.39&lt;/a&gt; TE &lt;a href=&quot;#section-14.40&quot;&gt;14.40&lt;/a&gt; 尾部 &lt;a href=&quot;#section-14.41&quot;&gt;14.41&lt;/a&gt; 传输编码 &lt;a href=&quot;#section-14.42&quot;&gt;14.42&lt;/a&gt; 升级 &lt;a href=&quot;#section-14.43&quot;&gt;14.43&lt;/a&gt; 用户代理 &lt;a href=&quot;#section-14.44&quot;&gt;14.44&lt;/a&gt; 可变 &lt;a href=&quot;#section-14.45&quot;&gt;14.45&lt;/a&gt; 通过 &lt;a href=&quot;#section-14.46&quot;&gt;14.46&lt;/a&gt; 警告 &lt;a href=&quot;#section-14.47&quot;&gt;14.47&lt;/a&gt; WWW-Authenticate &lt;a href=&quot;#section-15&quot;&gt;15&lt;/a&gt;安全注意事项 &lt;a href=&quot;#section-15.1&quot;&gt;15.1&lt;/a&gt; 个人信息 &lt;a href=&quot;#section-15.1.1&quot;&gt;15.1.1&lt;/a&gt; 服务器日志信息的滥用 &lt;a href=&quot;#section-15.1.2&quot;&gt;15.1.2&lt;/a&gt; 敏感信息的传输 &lt;a href=&quot;#section-15.1.3&quot;&gt;15.1.3&lt;/a&gt; 在URI的&lt;a href=&quot;#section-15.1.4&quot;&gt;15.1.4&lt;/a&gt; 隐私问题中编码以 连接到接受标头的隐私问题 &lt;a href=&quot;#section-15.2&quot;&gt;15.2&lt;/a&gt; 基于文件和路径的攻击名称 &lt;a href=&quot;#section-15.3&quot;&gt;15.3&lt;/a&gt; DNS欺骗 &lt;a href=&quot;#section-15.4&quot;&gt;15.4&lt;/a&gt; 位置标头和欺骗 &lt;a href=&quot;#section-15.5&quot;&gt;15.5&lt;/a&gt; 内容处置问题 &lt;a href=&quot;#section-15.6&quot;&gt;15.6&lt;/a&gt; 身份验证凭据和空闲客户端 &lt;a href=&quot;#section-15.7&quot;&gt;15.7&lt;/a&gt; 代理和缓存 &lt;a href=&quot;#section-15.7.1&quot;&gt;15.7.1&lt;/a&gt; 对代理的拒绝服务攻击 &lt;a href=&quot;#section-16&quot;&gt;16&lt;/a&gt; 致谢 &lt;a href=&quot;#section-17&quot;&gt;17&lt;/a&gt; 参考文献 &lt;a href=&quot;#section-18&quot;&gt;18&lt;/a&gt; 作者的地址 &lt;a href=&quot;#section-19&quot;&gt;19&lt;/a&gt; 附录 &lt;a href=&quot;#section-19.1&quot;&gt;19.1&lt;/a&gt; Internet媒体类型message / http和application / http &lt;a href=&quot;#section-19.2&quot;&gt;19.2&lt;/a&gt; Internet媒体类型multipart / byteranges &lt;a href=&quot;#section-19.3&quot;&gt;19.3&lt;/a&gt; 宽容的应用程序 &lt;a href=&quot;#section-19.4&quot;&gt;19.4&lt;/a&gt; HTTP实体和&lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC&lt;/a&gt;之间的差异2045实体.... &lt;a href=&quot;#section-19.4.1&quot;&gt;19.4.1&lt;/a&gt; MIME版本 &lt;a href=&quot;#section-19.4.2&quot;&gt;19.4.2&lt;/a&gt; 转换为规范形式 &lt;a href=&quot;#section-19.4.3&quot;&gt;19&lt;/a&gt; .4.3日期格式的转换 &lt;a href=&quot;#section-19.4.4&quot;&gt;19.4.4&lt;/a&gt; 内容编码的介绍 &lt;a href=&quot;#section-19.4.5&quot;&gt;19.4.5&lt;/a&gt; 无内容传输的编码&lt;a href=&quot;#section-19.4.6&quot;&gt;19.4.6&lt;/a&gt;传输编码的 介绍 &lt;a href=&quot;#section-19.4.7&quot;&gt;19.4.7&lt;/a&gt; MHTML和行长限制 &lt;a href=&quot;#section-19.5&quot;&gt;19.5&lt;/a&gt; 附加功能 &lt;a href=&quot;#section-19.5.1&quot;&gt;19.5.1&lt;/a&gt; 内容处置 &lt;a href=&quot;#section-19.6&quot;&gt;19.6&lt;/a&gt; 与先前版本的兼容性 &lt;a href=&quot;#section-19.6.1&quot;&gt;19.6.1&lt;/a&gt; 从HTTP / 1.0的变化 &lt;a href=&quot;#section-19.6.2&quot;&gt;19.6.2&lt;/a&gt; 兼容性与HTTP / 1.0持久连接 &lt;a href=&quot;#section-19.6.3&quot;&gt;19.6.3&lt;/a&gt; 变化从&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068 &lt;/a&gt;&lt;a href=&quot;#section-20&quot;&gt;20&lt;/a&gt; 指数 &lt;a href=&quot;#section-21&quot;&gt;21&lt;/a&gt; 完全版权声明</target>
        </trans-unit>
        <trans-unit id="d08c83f00b0f35b12328f45a668424f28ef4c379" translate="yes" xml:space="preserve">
          <source>Storing Responses in Caches (RFC 7234)</source>
          <target state="translated">在缓存中存储响应(RFC 7234)</target>
        </trans-unit>
        <trans-unit id="a1c0b3831b3706354655bc626dc41410ec27c9ee" translate="yes" xml:space="preserve">
          <source>Strict Transport Security resolves this problem; as long as you've accessed your bank's web site once using HTTPS, and the bank's web site uses Strict Transport Security, your browser will know to automatically use only HTTPS, which prevents hackers from performing this sort of man-in-the-middle attack.</source>
          <target state="translated">Strict Transport Security解决了这个问题,只要你使用HTTPS访问过一次银行的网站,而且银行的网站使用了Strict Transport Security,你的浏览器就会知道自动只使用HTTPS,这样就可以防止黑客进行这种中间人攻击。</target>
        </trans-unit>
        <trans-unit id="fc587e4b5dd9c8f2dabaee348836f36fc9073981" translate="yes" xml:space="preserve">
          <source>Strict-Transport-Security</source>
          <target state="translated">Strict-Transport-Security</target>
        </trans-unit>
        <trans-unit id="b47d9bc682e1c7c17d99058428f34fc877b82f8a" translate="yes" xml:space="preserve">
          <source>Strong validation</source>
          <target state="translated">强大的验证</target>
        </trans-unit>
        <trans-unit id="bce009dcd1fa74e08bb9b002217d1633ae7d181e" translate="yes" xml:space="preserve">
          <source>Strong validation consists of guaranteeing that the resource is, byte to byte, identical to the one it is compared too. This is mandatory for some conditional headers, and the default for the others. Strong validation is very strict and may be difficult to guarantee at the server level, but it does guarantee no data loss at any time, sometimes at the expense of performance.</source>
          <target state="translated">强验证包括保证资源与被比较的资源在字节上是相同的。这对于一些条件头来说是强制性的,而对于其他条件头来说是默认的。强验证是非常严格的,可能很难在服务器级别上保证,但它确实保证了在任何时候都不会丢失数据,有时是以牺牲性能为代价的。</target>
        </trans-unit>
        <trans-unit id="546f797f485e1c93debf33798738f22e2e2c71a9" translate="yes" xml:space="preserve">
          <source>Structure of a MIME type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a9b0645b4584767c896ce8933cbb6a249c16aa0" translate="yes" xml:space="preserve">
          <source>Structure of a server response</source>
          <target state="translated">服务器响应的结构</target>
        </trans-unit>
        <trans-unit id="87e09f53c79b7b9952020efdce6fce234ef5dd58" translate="yes" xml:space="preserve">
          <source>Subnet based decisions</source>
          <target state="translated">基于子网的决定</target>
        </trans-unit>
        <trans-unit id="d0b8ad91fc39a9beb48e35304c9f430f0a69862b" translate="yes" xml:space="preserve">
          <source>Subresource Integrity</source>
          <target state="translated">子资源完整性</target>
        </trans-unit>
        <trans-unit id="983f9ac400958792e64abc2d44401492ed778563" translate="yes" xml:space="preserve">
          <source>Subresource Integrity&lt;br/&gt;&lt;small&gt;The definition of 'require-sri-for' in that specification.&lt;/small&gt;</source>
          <target state="translated">子资源完整性&lt;small&gt;该&lt;/small&gt;规范&lt;br/&gt;&lt;small&gt;中&amp;ldquo; require-sri-for&amp;rdquo;的定义。&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="522495833932f57c0df7141327df306caf0e6ac3" translate="yes" xml:space="preserve">
          <source>Subsequent lines represent an HTTP header, giving the server information about what type of data is appropriate (e.g., what language, what MIME types), or other data altering its behavior (e.g., not sending an answer if it is already cached). These HTTP headers form a block which ends with an empty line.</source>
          <target state="translated">后面的行代表一个HTTP头,给服务器提供关于什么类型的数据是合适的(例如,什么语言,什么MIME类型),或者其他改变其行为的数据(例如,如果已经被缓存,就不发送应答)。这些HTTP头形成一个块,以空行结束。</target>
        </trans-unit>
        <trans-unit id="8d055925604926e85c70a546b297fe94724c7c5d" translate="yes" xml:space="preserve">
          <source>Subsequent lines represent specific HTTP headers, giving the client information about the data sent (e.g. type, data size, compression algorithm used, hints about caching). Similarly to the block of HTTP headers for a client request, these HTTP headers form a block ending with an empty line.</source>
          <target state="translated">后面的行代表特定的HTTP头信息,给客户端提供发送数据的信息(如类型、数据大小、使用的压缩算法、关于缓存的提示)。类似于客户端请求的HTTP头信息块,这些HTTP头信息形成一个以空行结束的块。</target>
        </trans-unit>
        <trans-unit id="56befc0f91be9db5dc24b49f4e5533e7ea0072f5" translate="yes" xml:space="preserve">
          <source>Subsequent sections discuss scenarios, as well as provide a breakdown of the HTTP headers used.</source>
          <target state="translated">随后的章节讨论了场景,并提供了所使用的HTTP头文件的分解。</target>
        </trans-unit>
        <trans-unit id="ff5c588e9523269ce3c84f63e9bd3897ebe63eec" translate="yes" xml:space="preserve">
          <source>Succeeds if the &lt;a href=&quot;headers/etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt; of the distant resource is different to each listed in this header. By default, unless the etag is prefixed with &lt;code&gt;'W/'&lt;/code&gt;, it performs a strong validation.</source>
          <target state="translated">如果远程资源的&lt;a href=&quot;headers/etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt;与此标头中列出的每个ETag不同，则成功。默认情况下，除非etag带有 &lt;code&gt;'W/'&lt;/code&gt; 前缀，否则它将执行严格的验证。</target>
        </trans-unit>
        <trans-unit id="aeef7e868363979461d6ea2ad7bf8c6358e365a2" translate="yes" xml:space="preserve">
          <source>Succeeds if the &lt;a href=&quot;headers/etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt; of the distant resource is equal to one listed in this header. By default, unless the etag is prefixed with &lt;code&gt;'W/'&lt;/code&gt;, it performs a strong validation.</source>
          <target state="translated">如果远程资源的&lt;a href=&quot;headers/etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt;等于此标头中列出的ETag，则成功。默认情况下，除非etag带有 &lt;code&gt;'W/'&lt;/code&gt; 前缀，否则它将执行严格的验证。</target>
        </trans-unit>
        <trans-unit id="2c3bd70cb1b0ac4e3f147078e58e04d441ea7e0e" translate="yes" xml:space="preserve">
          <source>Succeeds if the &lt;a href=&quot;headers/last-modified&quot;&gt;&lt;code&gt;Last-Modified&lt;/code&gt;&lt;/a&gt; date of the distant resource is more recent than the one given in this header.</source>
          <target state="translated">如果远程资源的&lt;a href=&quot;headers/last-modified&quot;&gt; &lt;code&gt;Last-Modified&lt;/code&gt; &lt;/a&gt;日期比此标头中指定的日期更新，则成功。</target>
        </trans-unit>
        <trans-unit id="54dce543ac7122114b0f1b25a6c18db4700a57c7" translate="yes" xml:space="preserve">
          <source>Succeeds if the &lt;a href=&quot;headers/last-modified&quot;&gt;&lt;code&gt;Last-Modified&lt;/code&gt;&lt;/a&gt; date of the distant resource is older or the same than the one given in this header.</source>
          <target state="translated">如果远程资源的&lt;a href=&quot;headers/last-modified&quot;&gt; &lt;code&gt;Last-Modified&lt;/code&gt; &lt;/a&gt;日期早于此标头中指定的日期或与该标头中指定的日期相同，则成功。</target>
        </trans-unit>
        <trans-unit id="1290a72cee06cf30f2b9582a53c05c695119f17b" translate="yes" xml:space="preserve">
          <source>Successful response has body</source>
          <target state="translated">成功的反应有机构</target>
        </trans-unit>
        <trans-unit id="d702cfd3f57a8cfe18b4f37a36bf15bc2c548094" translate="yes" xml:space="preserve">
          <source>Successful responses</source>
          <target state="translated">成功的答复</target>
        </trans-unit>
        <trans-unit id="47bd58ec264925cf6d2934f949144bd5b42d3e5b" translate="yes" xml:space="preserve">
          <source>Successful responses (&lt;code&gt;200&lt;/code&gt;&amp;ndash;&lt;code&gt;299&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e16e36ee4dff516de670a1cd0a9ef3f413ae5fb" translate="yes" xml:space="preserve">
          <source>Successful results of a retrieval request: a &lt;a href=&quot;status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt; (OK) response to a &lt;a href=&quot;methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; request containing a resource like HTML documents, images or files.</source>
          <target state="translated">检索请求的成功结果：对&lt;a href=&quot;methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;请求的&lt;a href=&quot;status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt;（确定）响应，其中包含HTML文档，图像或文件之类的资源。</target>
        </trans-unit>
        <trans-unit id="7cf7d910e383411b293ea5c44eeeb1c0a4a4a122" translate="yes" xml:space="preserve">
          <source>Successful web page response:</source>
          <target state="translated">网页回复成功。</target>
        </trans-unit>
        <trans-unit id="201d1d5e3d5c9d5de591a119116dd6b9386319e3" translate="yes" xml:space="preserve">
          <source>Supplants the &lt;code&gt;Origin&lt;/code&gt; header as defined in RFC6454.</source>
          <target state="translated">替换RFC6454 中定义的 &lt;code&gt;Origin&lt;/code&gt; 标头。</target>
        </trans-unit>
        <trans-unit id="216a84fbd27cb3b4473b824b61cc5de56085403b" translate="yes" xml:space="preserve">
          <source>Support for the &lt;code&gt;Retry-After&lt;/code&gt; header on both clients and servers is still inconsistent. However, some crawlers and spiders, like the Googlebot, honor the &lt;code&gt;Retry-After&lt;/code&gt; header. It is useful to send it along with a &lt;a href=&quot;../status/503&quot;&gt;&lt;code&gt;503&lt;/code&gt;&lt;/a&gt; (Service Unavailable) response, so that search engines will keep indexing your site when the downtime is over.</source>
          <target state="translated">客户端和服务器上对 &lt;code&gt;Retry-After&lt;/code&gt; 标头的支持仍然不一致。但是，某些爬虫和蜘蛛（例如Googlebot）会使用 &lt;code&gt;Retry-After&lt;/code&gt; 标头。将其与&lt;a href=&quot;../status/503&quot;&gt; &lt;code&gt;503&lt;/code&gt; &lt;/a&gt;（服务不可用）响应一起发送很有用，这样当停机时间结束时，搜索引擎将继续为您的站点编制索引。</target>
        </trans-unit>
        <trans-unit id="4c6167e7995d17c7bc37724de85e632d49fe0fd7" translate="yes" xml:space="preserve">
          <source>Support of &lt;a href=&quot;../headers/alt-svc&quot;&gt;&lt;code&gt;Alt-Svc&lt;/code&gt;&lt;/a&gt; allows the dissociation of the identification and the location of a given resource, allowing for a smarter &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CDN&quot;&gt;CDN&lt;/a&gt; caching mechanism.</source>
          <target state="translated">对&lt;a href=&quot;../headers/alt-svc&quot;&gt; &lt;code&gt;Alt-Svc&lt;/code&gt; 的&lt;/a&gt;支持允许分离标识和给定资源的位置，从而实现更智能的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CDN&quot;&gt;CDN&lt;/a&gt;缓存机制。</target>
        </trans-unit>
        <trans-unit id="9cf8d0d7c981d663797eeaca7523e977bed4ab51" translate="yes" xml:space="preserve">
          <source>Supporting OCSP stapling (that is, the &lt;code&gt;status_request&lt;/code&gt; TLS extension) and providing a &lt;code&gt;SignedCertificateTimestampList&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1d598d97e68fd3cf7ac8ec2441b332f10d641fc" translate="yes" xml:space="preserve">
          <source>Switch to a blacklist model for restricted Accept headers in simple CORS requests</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57ebc7fe25f3af6b8e76fe3b492c6dd20ec4df27" translate="yes" xml:space="preserve">
          <source>Switching protocols might be used with &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API&quot;&gt;WebSockets&lt;/a&gt;.</source>
          <target state="translated">切换协议可能与&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API&quot;&gt;WebSockets&lt;/a&gt;一起使用。</target>
        </trans-unit>
        <trans-unit id="00d7e2af1a23453b6e8dc5b63832fd4a645bc527" translate="yes" xml:space="preserve">
          <source>Synchronous XMLHTTPRequest</source>
          <target state="translated">同步的XMLHTTPRequest</target>
        </trans-unit>
        <trans-unit id="4103f0b31624fefeee3cf5f8642cc1c83ff9a978" translate="yes" xml:space="preserve">
          <source>Synchronous XMLHttpRequest</source>
          <target state="translated">同步的XMLHttpRequest</target>
        </trans-unit>
        <trans-unit id="be9208425b9c861fee1e1a67180b55dad01dafe7" translate="yes" xml:space="preserve">
          <source>Synchronous scripts</source>
          <target state="translated">同步脚本</target>
        </trans-unit>
        <trans-unit id="17c7ba7676ad1ad6dd1c4e6b997adcae910262c9" translate="yes" xml:space="preserve">
          <source>Syntax</source>
          <target state="translated">Syntax</target>
        </trans-unit>
        <trans-unit id="791a9bf2077653138c6b3912f9bf31ac1b906662" translate="yes" xml:space="preserve">
          <source>Syntax of Uniform Resource Identifiers (URIs)</source>
          <target state="translated">统一资源标识符(URI)的语法</target>
        </trans-unit>
        <trans-unit id="c2c53d66948214258a26ca9ca845d7ac0c17f8e7" translate="yes" xml:space="preserve">
          <source>T</source>
          <target state="translated">T</target>
        </trans-unit>
        <trans-unit id="5a056389515bd999bc97e7793f7c147c0b47eac3" translate="yes" xml:space="preserve">
          <source>TCP port number on which the server is listening.</source>
          <target state="translated">服务器正在监听的TCP端口号。</target>
        </trans-unit>
        <trans-unit id="49a198744d47717f2dedc61eda3abad936b310a2" translate="yes" xml:space="preserve">
          <source>TCP port number on which the server is listening. If no port is given, the default port for the service requested (e.g., &quot;80&quot; for an HTTP URL) is implied.</source>
          <target state="translated">服务器正在监听的TCP端口号,如果没有给定端口,则默认为请求服务的端口(例如,HTTP URL的 &quot;80&quot;)。如果没有给定端口,则暗示了请求服务的默认端口(例如,HTTP URL的 &quot;80&quot;)。</target>
        </trans-unit>
        <trans-unit id="1945ca5513cf77b8240e53495ba7a26e86acaca7" translate="yes" xml:space="preserve">
          <source>TE</source>
          <target state="translated">TE</target>
        </trans-unit>
        <trans-unit id="2dd200ebd9f2359780d12717e9c2166303c7a6d3" translate="yes" xml:space="preserve">
          <source>TE (RFC 2616)</source>
          <target state="translated">TE(RFC 2616)</target>
        </trans-unit>
        <trans-unit id="a775b64f2cd6a88a198986d46d44e0a021785125" translate="yes" xml:space="preserve">
          <source>TIFF</source>
          <target state="translated">TIFF</target>
        </trans-unit>
        <trans-unit id="ddf8a55c683ee58c6268b4264acb1d703195d588" translate="yes" xml:space="preserve">
          <source>TRACE</source>
          <target state="translated">TRACE</target>
        </trans-unit>
        <trans-unit id="0d5266ebda7b5b7ca016e3ecbf8bfe060fe9dd53" translate="yes" xml:space="preserve">
          <source>TRACE (RFC 7231)</source>
          <target state="translated">TRACE (RFC 7231)</target>
        </trans-unit>
        <trans-unit id="1223c0da5965757fa8d93336605832a0144596b6" translate="yes" xml:space="preserve">
          <source>TRACE: The message body contains the request message as received by the server</source>
          <target state="translated">TRACE:消息主体包含服务器收到的请求消息。</target>
        </trans-unit>
        <trans-unit id="56ab49a5c68f11cc45c651da6a3f339eff2853f8" translate="yes" xml:space="preserve">
          <source>TV</source>
          <target state="translated">TV</target>
        </trans-unit>
        <trans-unit id="fabcacd2a76a1a809975d60d7982c2a1035ab1c0" translate="yes" xml:space="preserve">
          <source>Tablet</source>
          <target state="translated">Tablet</target>
        </trans-unit>
        <trans-unit id="7193b142ed8cd6bae9bcd7f28df4d59bf30c7919" translate="yes" xml:space="preserve">
          <source>Tablet versions on WebView mirror mobile, but do not contain a &lt;code&gt;Mobile&lt;/code&gt; token.</source>
          <target state="translated">WebView上的平板电脑版本可镜像移动设备，但不包含 &lt;code&gt;Mobile&lt;/code&gt; 令牌。</target>
        </trans-unit>
        <trans-unit id="e63d48cf86b47f4a2e41a4c2480abd63617e07ff" translate="yes" xml:space="preserve">
          <source>Tagged Image File Format</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c352e4dbdd3d9d5e6127303b4e65a452119231a" translate="yes" xml:space="preserve">
          <source>Tagged Image File Format (TIFF)</source>
          <target state="translated">标签图像文件格式(TIFF)</target>
        </trans-unit>
        <trans-unit id="5c1a98fc42374c0534b21a7c408be88b0b460645" translate="yes" xml:space="preserve">
          <source>Tags and summary</source>
          <target state="translated">标签和摘要</target>
        </trans-unit>
        <trans-unit id="03b91e28fed7956fe56ed8f65fc65fd882bbb491" translate="yes" xml:space="preserve">
          <source>Tags for the Identification of Language</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40a1df0d175828bc0ac87d97cb74122c8c8d4d00" translate="yes" xml:space="preserve">
          <source>Takes precedence over &lt;code&gt;max-age&lt;/code&gt; or the &lt;code&gt;Expires&lt;/code&gt; header, but it only applies to shared caches (e.g., proxies) and is ignored by a private cache.</source>
          <target state="translated">优先于 &lt;code&gt;max-age&lt;/code&gt; 或 &lt;code&gt;Expires&lt;/code&gt; 标头，但它仅适用于共享缓存（例如代理），并且被私有缓存忽略。</target>
        </trans-unit>
        <trans-unit id="c149ac475d4a9b7fd2b15c7870c52269b0872366" translate="yes" xml:space="preserve">
          <source>Tape Archive (TAR)</source>
          <target state="translated">磁带档案 (TAR)</target>
        </trans-unit>
        <trans-unit id="a9bdde16c71950f9f0a80cbf4ce3915950ed2150" translate="yes" xml:space="preserve">
          <source>Targets of caching operations</source>
          <target state="translated">缓存操作的目标</target>
        </trans-unit>
        <trans-unit id="d9c7795d9a943127c5b4d89543f3db9a1ffaae49" translate="yes" xml:space="preserve">
          <source>Technically a part of Device Memory API, this header represents an approximate amount of RAM client has.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2313e8c800252c9ae07b4e97927a6d9cf9ac1b33" translate="yes" xml:space="preserve">
          <source>Techniques for canonical URLs</source>
          <target state="translated">规范URL的技术</target>
        </trans-unit>
        <trans-unit id="04e57122701fa97f61a068ec7bd222827a269a62" translate="yes" xml:space="preserve">
          <source>Tells the browser that the page being loaded is going to want to perform a large allocation.</source>
          <target state="translated">告诉浏览器,正在加载的页面要想进行大分配。</target>
        </trans-unit>
        <trans-unit id="c8c8d2a564da5b504842208aff51d3ccfc991895" translate="yes" xml:space="preserve">
          <source>Tells the client the server's prefered encoding scheme when submiting a username and password. The only allowed value is the case insensitive string &quot;UTF-8&quot;. This does not relate to the encoding of the realm string.</source>
          <target state="translated">当提交用户名和密码时,告诉客户端服务器的首选编码方案。唯一允许的值是不区分大小写的字符串 &quot;UTF-8&quot;。这与领域字符串的编码无关。</target>
        </trans-unit>
        <trans-unit id="3e310a9a1efd6f1548ce06a7ac2dc4748669f825" translate="yes" xml:space="preserve">
          <source>Tells the client the server's prefered encoding scheme when submitting a username and password. The only allowed value is the case insensitive string &quot;UTF-8&quot;. This does not relate to the encoding of the realm string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e58df9f49057b700376e3c8d719874a09fcdc736" translate="yes" xml:space="preserve">
          <source>Tells the user-agent to reset the document which sent this request.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86f4edbe4b69402bc32c890fe46456f6b42c2ad1" translate="yes" xml:space="preserve">
          <source>Temporary redirections</source>
          <target state="translated">临时改道</target>
        </trans-unit>
        <trans-unit id="7aefd5b2f288adc48ce6a117e81f357d1eed0b40" translate="yes" xml:space="preserve">
          <source>Temporary redirects during site maintenance or downtime</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b029c546a5b81b886574d6c63becc55db5c5c32" translate="yes" xml:space="preserve">
          <source>Temporary responses to long requests</source>
          <target state="translated">对长期请求的临时答复</target>
        </trans-unit>
        <trans-unit id="44729f34632c3c8c496e4f38b8037aa7c3dfb175" translate="yes" xml:space="preserve">
          <source>Temporary responses to unsafe requests</source>
          <target state="translated">对不安全请求的临时反应</target>
        </trans-unit>
        <trans-unit id="66ad9b49478e00d9521f776ed94bddcd7f501cea" translate="yes" xml:space="preserve">
          <source>Testing your policy</source>
          <target state="translated">测试您的政策</target>
        </trans-unit>
        <trans-unit id="c3328c39b0e29f78e9ff45db674248b1d245887d" translate="yes" xml:space="preserve">
          <source>Text</source>
          <target state="translated">Text</target>
        </trans-unit>
        <trans-unit id="9845ab8961b7e4a2e464fba53a5a9a896b568e17" translate="yes" xml:space="preserve">
          <source>Text, (generally ASCII or ISO 8859-&lt;em&gt;n&lt;/em&gt;)</source>
          <target state="translated">文本（通常为ASCII或ISO 8859- &lt;em&gt;n&lt;/em&gt;）</target>
        </trans-unit>
        <trans-unit id="dd0fe1624d9684bcb52e0cccdb484d7e2001e225" translate="yes" xml:space="preserve">
          <source>Text-only data including any human-readable content, source code, or textual data such as comma-separated value (CSV) formatted data. Examples include &lt;code&gt;text/plain&lt;/code&gt;, &lt;code&gt;text/csv&lt;/code&gt;, and &lt;code&gt;text/html&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41e7a7ed719d0daa7e0a2e3d48d3aa52fa318aae" translate="yes" xml:space="preserve">
          <source>Thanks to its extensibility &amp;ndash; creating new headers or methods is easy &amp;ndash; and even if the HTTP/1.1 protocol was refined over two revisions, &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt; published in June 1999 and the series of &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC 7230&lt;/a&gt;-&lt;a href=&quot;https://tools.ietf.org/html/rfc7235&quot;&gt;RFC 7235&lt;/a&gt; published in June 2014 in prevision of the release of HTTP/2, this protocol has been extremely stable over more than 15 years.</source>
          <target state="translated">由于其可扩展性-创建新的标头或方法很容易-即使HTTP / 1.1协议在两个修订版中进行了改进，1999年6月发布的&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt;和2014年6月发布的&lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC 7230&lt;/a&gt; - &lt;a href=&quot;https://tools.ietf.org/html/rfc7235&quot;&gt;RFC 7235&lt;/a&gt;系列，在发布HTTP / 2以来，该协议在15年多的时间内一直非常稳定。</target>
        </trans-unit>
        <trans-unit id="cd15a270847553d0286663fce338c3186c3904d8" translate="yes" xml:space="preserve">
          <source>Thanks to the &lt;a href=&quot;../headers/host&quot;&gt;&lt;code&gt;Host&lt;/code&gt;&lt;/a&gt; header, the ability to host different domains at the same IP address now allows server collocation.</source>
          <target state="translated">多亏了&lt;a href=&quot;../headers/host&quot;&gt; &lt;code&gt;Host&lt;/code&gt; &lt;/a&gt;标头，现在可以在同一IP地址上托管不同域的功能允许服务器并置。</target>
        </trans-unit>
        <trans-unit id="24cf3eddb29388191b3cd3ec808e71bc6c5fd48a" translate="yes" xml:space="preserve">
          <source>Thanks to the &lt;a href=&quot;../headers/host&quot;&gt;&lt;code&gt;Host&lt;/code&gt;&lt;/a&gt; header, the ability to host different domains at the same IP address now allows server colocation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c0b92cdd8e1ab117b52ae806f278493aef32784" translate="yes" xml:space="preserve">
          <source>That way, you still upgrade insecure requests on your secure site, but the only monitoring policy is violated and reports insecure resources to your endpoint.</source>
          <target state="translated">这样一来,你仍然会在安全网站上升级不安全的请求,但唯一的监控策略被违反,并向你的终端报告不安全的资源。</target>
        </trans-unit>
        <trans-unit id="93ef0dd827103681fcee453b78be2ff14e1a261d" translate="yes" xml:space="preserve">
          <source>The</source>
          <target state="translated">The</target>
        </trans-unit>
        <trans-unit id="30bedea71a5adc4d8f862982f2915b1068fb6576" translate="yes" xml:space="preserve">
          <source>The &quot;Accept&quot; header field can be used by user agents to specify
   response media types that are acceptable.  Accept header fields can
   be used to indicate that the request is specifically limited to a
   small set of desired types, as in the case of a request for an
   in-line image.

     Accept = #( media-range [ accept-params ] )

     media-range    = ( &quot;*/*&quot;
                      / ( type &quot;/&quot; &quot;*&quot; )
                      / ( type &quot;/&quot; subtype )
                      ) *( OWS &quot;;&quot; OWS parameter )
     accept-params  = weight *( accept-ext )
     accept-ext = OWS &quot;;&quot; OWS token [ &quot;=&quot; ( token / quoted-string ) ]

   The asterisk &quot;*&quot; character is used to group media types into ranges,
   with &quot;*/*&quot; indicating all media types and &quot;type/*&quot; indicating all
   subtypes of that type.  The media-range can include media type
   parameters that are applicable to that range.

   Each media-range might be followed by zero or more applicable media
   type parameters (e.g., charset), an optional &quot;q&quot; parameter for
   indicating a relative weight (&lt;a href=&quot;#section-5.3.1&quot;&gt;Section 5.3.1&lt;/a&gt;), and then zero or more
   extension parameters.  The &quot;q&quot; parameter is necessary if any
   extensions (accept-ext) are present, since it acts as a separator
   between the two parameter sets.

      Note: Use of the &quot;q&quot; parameter name to separate media type
      parameters from Accept extension parameters is due to historical
      practice.  Although this prevents any media type parameter named
      &quot;q&quot; from being used with a media range, such an event is believed
      to be unlikely given the lack of any &quot;q&quot; parameters in the IANA 

      media type registry and the rare usage of any media type
      parameters in Accept.  Future media types are discouraged from
      registering any parameter named &quot;q&quot;.

   The example

     Accept: audio/*; q=0.2, audio/basic

   is interpreted as &quot;I prefer audio/basic, but send me any audio type
   if it is the best available after an 80% markdown in quality&quot;.

   A request without any Accept header field implies that the user agent
   will accept any media type in response.  If the header field is
   present in a request and none of the available representations for
   the response have a media type that is listed as acceptable, the
   origin server can either honor the header field by sending a 406 (Not
   Acceptable) response or disregard the header field by treating the
   response as if it is not subject to content negotiation.

   A more elaborate example is

     Accept: text/plain; q=0.5, text/html,
             text/x-dvi; q=0.8, text/x-c

   Verbally, this would be interpreted as &quot;text/html and text/x-c are
   the equally preferred media types, but if they do not exist, then
   send the text/x-dvi representation, and if that does not exist, send
   the text/plain representation&quot;.

   Media ranges can be overridden by more specific media ranges or
   specific media types.  If more than one media range applies to a
   given type, the most specific reference has precedence.  For example,

     Accept: text/*, text/plain, text/plain;format=flowed, */*

   have the following precedence:

   1.  text/plain;format=flowed

   2.  text/plain

   3.  text/*

   4.  */*

   The media type quality factor associated with a given type is
   determined by finding the media range with the highest precedence
   that matches the type.  For example, 

     Accept: text/*;q=0.3, text/html;q=0.7, text/html;level=1,
             text/html;level=2;q=0.4, */*;q=0.5

   would cause the following values to be associated:

   +-------------------+---------------+
   | Media Type        | Quality Value |
   +-------------------+---------------+
   | text/html;level=1 | 1             |
   | text/html         | 0.7           |
   | text/plain        | 0.3           |
   | image/jpeg        | 0.5           |
   | text/html;level=2 | 0.4           |
   | text/html;level=3 | 0.7           |
   +-------------------+---------------+

   Note: A user agent might be provided with a default set of quality
   values for certain media ranges.  However, unless the user agent is a
   closed system that cannot interact with other rendering agents, this
   default set ought to be configurable by the user.</source>
          <target state="translated">用户代理可以使用&amp;ldquo;接受&amp;rdquo;标头字段来指定可接受的响应媒体类型。接受标头字段可用于指示该请求被特定地限制为一小组所需类型，例如在请求嵌入式图像的情况下。接受=＃（media-range [接受参数]）media-range =（&amp;ldquo; * / *&amp;rdquo; /（类型&amp;ldquo; /&amp;rdquo;&amp;ldquo; *&amp;rdquo;）/（类型&amp;ldquo; /&amp;rdquo;子类型））*（OWS&amp;ldquo;;&amp;rdquo; OWS参数）accept-params = weight *（accept-ext）accept-ext = OWS&amp;ldquo;;&amp;rdquo; OWS令牌[&amp;ldquo; =&amp;rdquo;（令牌/带引号的字符串）]星号&amp;ldquo; *&amp;rdquo;字符用于将媒体类型分组为范围，其中&amp;ldquo; * / *&amp;rdquo;表示所有媒体类型，&amp;ldquo; * / *&amp;rdquo;表示所有媒体类型指示该类型的所有子类型。媒体范围可以包括适用于该范围的媒体类型参数。每个媒体范围后面都可以跟随零个或更多个适用的媒体类型参数（例如，字符集），用于指示相对权重的可选&amp;ldquo; q&amp;rdquo;参数（&lt;a href=&quot;#section-5.3.1&quot;&gt;第5.3.1节&lt;/a&gt;），然后添加零个或多个扩展参数。如果存在任何扩展名（accept-ext），则&amp;ldquo; q&amp;rdquo;参数是必需的，因为它充当两个参数集之间的分隔符。注意：由于历史上的惯例，使用&amp;ldquo; q&amp;rdquo;参数名称将媒体类型参数与&amp;ldquo;接受&amp;rdquo;扩展参数分开。尽管这可以阻止任何名为&amp;ldquo; q&amp;rdquo;的媒体类型参数与媒体范围一起使用，但考虑到IANA媒体类型注册表中缺少任何&amp;ldquo; q&amp;rdquo;参数并且很少使用任何媒体类型，因此认为这种事件不太可能发生接受中的参数。不鼓励将来的媒体类型注册任何名为&amp;ldquo; q&amp;rdquo;的参数。该示例接受：audio / *; q = 0.2，音频/基本解释为&amp;ldquo;我更喜欢音频/基本音频，但如果质量下降80％之后，如果音频音频是最可用的，请向我发送任何音频类型。&amp;rdquo;没有任何&amp;ldquo;接受&amp;rdquo;标头字段的请求表示用户代理将接受任何媒体类型作为响应。字段存在于请求中，并且没有可用的响应表示形式具有被列为可接受的媒体类型，原始服务器可以通过发送406（不可接受）响应来遵守标头字段，也可以通过处理忽略标头字段更详细的示例是&amp;ldquo;接受&amp;rdquo;：文本/纯文本； q = 0.5，文本/ html，文本/x-dvi；q=0.8，文本/ xc从字面上看，这将被解释因为&amp;ldquo; text / html和text / xc是同等首选的媒体类型，但如果它们不存在，然后发送text / x-dvi表示形式，如果不存在，则发送text / plain表示形式。&amp;rdquo;媒体范围可以被更特定的媒体范围或特定的媒体类型覆盖。如果一个给定的媒体范围不止一个类型，最具体的引用优先。例如，Accept：text / *，text / plain，text / plain; format = flowed，* / *具有以下优先级：1. text / plain; format = flowed 2. text / plain 3. text / * 4. * / *与给定类型关联的媒体类型质量因子是通过查找与该类型相匹配的最高优先级的媒体范围来确定的，例如，Accept：text / *; q = 0.3 ，text / html; q = 0.7，text / html; level = 1，text / html; level = 2; q = 0.4，* / *; q = 0.5将导致关联以下值：+ ------------------- + --------------- + |媒体类型|质量价值| + ------------------- + --------------- + | text / html; level = 1 | 1 | |文字/ HTML | 0.7 | |文字/纯文字| 0.3 | |图片/ jpeg | 0.5 | | text / html; level = 2 | 0.4 | | text / html; level = 3 | 0.7 | + ------------------- + --------------- +注意：可能为用户代理提供了一组默认值：某些媒体范围的质量值。但是，除非用户代理是无法与其他呈现代理进行交互的封闭系统，否则此默认设置应可由用户配置。7 | |文字/纯文字| 0.3 | |图片/ jpeg | 0.5 | | text / html; level = 2 | 0.4 | | text / html; level = 3 | 0.7 | + ------------------- + --------------- +注意：可能为用户代理提供了一组默认值：某些媒体范围的质量值。但是，除非用户代理是不能与其他呈现代理进行交互的封闭系统，否则此默认设置应可由用户配置。7 | |文字/纯文字| 0.3 | |图片/ jpeg | 0.5 | | text / html; level = 2 | 0.4 | | text / html; level = 3 | 0.7 | + ------------------- + --------------- +注意：可能为用户代理提供了一组默认值：某些媒体范围的质量值。但是，除非用户代理是不能与其他呈现代理进行交互的封闭系统，否则此默认设置应可由用户配置。除非用户代理是不能与其他呈现代理交互的封闭系统，否则此默认设置应由用户配置。除非用户代理是不能与其他呈现代理交互的封闭系统，否则此默认设置应由用户配置。</target>
        </trans-unit>
        <trans-unit id="e190709d5dcd5319bdd81105d4e02470d1c77a57" translate="yes" xml:space="preserve">
          <source>The &quot;Accept-Charset&quot; header field can be sent by a user agent to
   indicate what charsets are acceptable in textual response content.
   This field allows user agents capable of understanding more
   comprehensive or special-purpose charsets to signal that capability
   to an origin server that is capable of representing information in
   those charsets.

     Accept-Charset = 1#( ( charset / &quot;*&quot; ) [ weight ] )

   Charset names are defined in &lt;a href=&quot;#section-3.1.1.2&quot;&gt;Section 3.1.1.2&lt;/a&gt;.  A user agent MAY
   associate a quality value with each charset to indicate the user's
   relative preference for that charset, as defined in &lt;a href=&quot;#section-5.3.1&quot;&gt;Section 5.3.1&lt;/a&gt;.
   An example is

     Accept-Charset: iso-8859-5, unicode-1-1;q=0.8

   The special value &quot;*&quot;, if present in the Accept-Charset field,
   matches every charset that is not mentioned elsewhere in the
   Accept-Charset field.  If no &quot;*&quot; is present in an Accept-Charset
   field, then any charsets not explicitly mentioned in the field are
   considered &quot;not acceptable&quot; to the client.

   A request without any Accept-Charset header field implies that the
   user agent will accept any charset in response.  Most general-purpose
   user agents do not send Accept-Charset, unless specifically 

   configured to do so, because a detailed list of supported charsets
   makes it easier for a server to identify an individual by virtue of
   the user agent's request characteristics (&lt;a href=&quot;#section-9.7&quot;&gt;Section 9.7&lt;/a&gt;).

   If an Accept-Charset header field is present in a request and none of
   the available representations for the response has a charset that is
   listed as acceptable, the origin server can either honor the header
   field, by sending a 406 (Not Acceptable) response, or disregard the
   header field by treating the resource as if it is not subject to
   content negotiation.</source>
          <target state="translated">用户代理可以发送&amp;ldquo; Accept-Charset&amp;rdquo;标头字段，以指示文本响应内容中可接受的字符集。该字段允许能够理解更全面或特殊用途的字符集的用户代理将这一功能发送给能够在那些字符集中表示信息的原始服务器。 Accept-Charset = 1＃（（charset /&amp;ldquo; *&amp;rdquo;）[weight]）字符集名称在&lt;a href=&quot;#section-3.1.1.2&quot;&gt;第3.1.1.2节&lt;/a&gt;中定义。用户代理可以将质量值与每个字符集相关联，以指示用户对该字符集的相对偏好，如&lt;a href=&quot;#section-5.3.1&quot;&gt;第5.3.1节中&lt;/a&gt;所定义。。例如：Accept-Charset：iso-8859-5，unicode-1-1; q = 0.8特殊值&amp;ldquo; *&amp;rdquo;（如果存在于Accept-Charset字段中）则与Accept-Charset字段中未提及的所有字符集匹配。字符集字段。如果Accept-Charset字段中不存在&amp;ldquo; *&amp;rdquo;，则该字段中未明确提及的任何字符集都将被客户端视为&amp;ldquo;不可接受&amp;rdquo;。没有任何Accept-Charset标头字段的请求表示用户代理将接受任何字符集作为响应。除非经过特殊配置，否则大多数通用用户代理都不会发送Accept-Charset，因为受支持的字符集的详细列表使服务器更容易根据用户代理的请求特征来识别个人（&lt;a href=&quot;#section-9.7&quot;&gt;第9.7节）&lt;/a&gt;）。如果请求中存在一个Accept-Charset标头字段，并且响应的任何可用表示形式都没有列出可接受的字符集，则原始服务器可以通过发送406（不可接受）响应来遵守标头字段，或通过将资源视为未经内容协商的方式来忽略标头字段。</target>
        </trans-unit>
        <trans-unit id="94c1a4ee49201e6addf548dc16982d985feb45ac" translate="yes" xml:space="preserve">
          <source>The &quot;Accept-Encoding&quot; header field can be used by user agents to
   indicate what response content-codings (&lt;a href=&quot;#section-3.1.2.1&quot;&gt;Section 3.1.2.1&lt;/a&gt;) are
   acceptable in the response.  An &quot;identity&quot; token is used as a synonym
   for &quot;no encoding&quot; in order to communicate when no encoding is
   preferred.

     Accept-Encoding  = #( codings [ weight ] )
     codings          = content-coding / &quot;identity&quot; / &quot;*&quot;

   Each codings value MAY be given an associated quality value
   representing the preference for that encoding, as defined in
   &lt;a href=&quot;#section-5.3.1&quot;&gt;Section 5.3.1&lt;/a&gt;.  The asterisk &quot;*&quot; symbol in an Accept-Encoding field
   matches any available content-coding not explicitly listed in the
   header field.

   For example,

     Accept-Encoding: compress, gzip
     Accept-Encoding:
     Accept-Encoding: *
     Accept-Encoding: compress;q=0.5, gzip;q=1.0
     Accept-Encoding: gzip;q=1.0, identity; q=0.5, *;q=0

   A request without an Accept-Encoding header field implies that the
   user agent has no preferences regarding content-codings.  Although
   this allows the server to use any content-coding in a response, it
   does not imply that the user agent will be able to correctly process
   all encodings.

   A server tests whether a content-coding for a given representation is
   acceptable using these rules:

   1.  If no Accept-Encoding field is in the request, any content-coding
       is considered acceptable by the user agent. 

   2.  If the representation has no content-coding, then it is
       acceptable by default unless specifically excluded by the
       Accept-Encoding field stating either &quot;identity;q=0&quot; or &quot;*;q=0&quot;
       without a more specific entry for &quot;identity&quot;.

   3.  If the representation's content-coding is one of the
       content-codings listed in the Accept-Encoding field, then it is
       acceptable unless it is accompanied by a qvalue of 0.  (As
       defined in &lt;a href=&quot;#section-5.3.1&quot;&gt;Section 5.3.1&lt;/a&gt;, a qvalue of 0 means &quot;not acceptable&quot;.)

   4.  If multiple content-codings are acceptable, then the acceptable
       content-coding with the highest non-zero qvalue is preferred.

   An Accept-Encoding header field with a combined field-value that is
   empty implies that the user agent does not want any content-coding in
   response.  If an Accept-Encoding header field is present in a request
   and none of the available representations for the response have a
   content-coding that is listed as acceptable, the origin server SHOULD
   send a response without any content-coding.

      Note: Most HTTP/1.0 applications do not recognize or obey qvalues
      associated with content-codings.  This means that qvalues might
      not work and are not permitted with x-gzip or x-compress.</source>
          <target state="translated">用户代理可以使用&amp;ldquo; Accept-Encoding&amp;rdquo;头域来指示响应中可接受的响应内容编码（&lt;a href=&quot;#section-3.1.2.1&quot;&gt;第3.1.2.1节&lt;/a&gt;）。 &amp;ldquo;身份&amp;rdquo;令牌用作&amp;ldquo;不编码&amp;rdquo;的同义词，以便在不希望编码时进行通信。接受编码=＃（编码[权重]）编码=内容编码/&amp;ldquo;身份&amp;rdquo; /&amp;ldquo; *&amp;rdquo;可以给每个编码值一个相关联的质量值，该质量值表示该编码的偏好，如&lt;a href=&quot;#section-5.3.1&quot;&gt;第5.3.1节中&lt;/a&gt;所定义 。接受编码字段中的星号&amp;ldquo; *&amp;rdquo;符号与标头字段中未明确列出的任何可用内容编码匹配。例如，Accept-Encoding：compress，gzip Accept-Encoding：Accept-Encoding：* Accept-Encoding：compress; q = 0.5，gzip; q = 1.0 Accept-Encoding：gzip; q = 1.0，identity; q = 0.5，*; q = 0没有请求Accept-Encoding头字段的请求意味着用户代理对内容编码没有任何偏好。尽管这允许服务器在响应中使用任何内容编码，但这并不意味着用户代理将能够正确处理所有编码。服务器使用以下规则测试给定表示形式的内容编码是否可接受：1.如果请求中没有&amp;ldquo;接受编码&amp;rdquo;字段，用户代理认为任何内容编码都是可接受的。 2.如果表示形式没有内容编码，则默认情况下可接受，除非&amp;ldquo;接受编码&amp;rdquo;字段明确指出&amp;ldquo; identity; q = 0&amp;rdquo;或&amp;ldquo; *; q = 0&amp;rdquo;，而没有为&amp;ldquo;身份&amp;rdquo;。 3.如果表示的内容编码是&amp;ldquo;接受编码&amp;rdquo;字段中列出的内容编码之一，则可以接受，除非它带有q值0。（如没有&amp;ldquo;身份&amp;rdquo;的更具体条目。 3.如果表示的内容编码是&amp;ldquo;接受编码&amp;rdquo;字段中列出的内容编码之一，则可以接受，除非它带有q值0。（如没有&amp;ldquo;身份&amp;rdquo;的更具体条目。 3.如果表示的内容编码是&amp;ldquo;接受编码&amp;rdquo;字段中列出的内容编码之一，则可以接受，除非它带有q值0。（如&lt;a href=&quot;#section-5.3.1&quot;&gt;在5.3.1节中&lt;/a&gt;，q值为0表示&amp;ldquo;不可接受&amp;rdquo;。）4.如果可以接受多个内容编码，则首选具有最高非零q值的可接受内容编码。组合字段值为空的Accept-Encoding标头字段表示用户代理不希望任何内容编码作为响应。如果请求中存在一个Accept-Encoding头域，并且响应的任何可用表示都没有列出可接受的内容编码，则源服务器应该发送没有任何内容编码的响应。注意：大多数HTTP / 1.0应用程序不识别或遵循与内容编码关联的q值。这意味着qvalue可能不起作用，并且x-gzip或x-compress不允许使用。</target>
        </trans-unit>
        <trans-unit id="e583c40d3f3281ace1211bd3a8c4c5127953cb55" translate="yes" xml:space="preserve">
          <source>The &quot;Accept-Language&quot; header field can be used by user agents to
   indicate the set of natural languages that are preferred in the
   response.  Language tags are defined in &lt;a href=&quot;#section-3.1.3.1&quot;&gt;Section 3.1.3.1&lt;/a&gt;.

     Accept-Language = 1#( language-range [ weight ] )
     language-range  =
               &amp;lt;language-range, see &lt;a href=&quot;https://tools.ietf.org/html/rfc4647#section-2.1&quot;&gt;[RFC4647], Section&amp;nbsp;2.1&lt;/a&gt;&amp;gt;

   Each language-range can be given an associated quality value
   representing an estimate of the user's preference for the languages
   specified by that range, as defined in &lt;a href=&quot;#section-5.3.1&quot;&gt;Section 5.3.1&lt;/a&gt;.  For example,

     Accept-Language: da, en-gb;q=0.8, en;q=0.7

   would mean: &quot;I prefer Danish, but will accept British English and
   other types of English&quot;.

   A request without any Accept-Language header field implies that the
   user agent will accept any language in response.  If the header field
   is present in a request and none of the available representations for
   the response have a matching language tag, the origin server can
   either disregard the header field by treating the response as if it 

   is not subject to content negotiation or honor the header field by
   sending a 406 (Not Acceptable) response.  However, the latter is not
   encouraged, as doing so can prevent users from accessing content that
   they might be able to use (with translation software, for example).

   Note that some recipients treat the order in which language tags are
   listed as an indication of descending priority, particularly for tags
   that are assigned equal quality values (no value is the same as q=1).
   However, this behavior cannot be relied upon.  For consistency and to
   maximize interoperability, many user agents assign each language tag
   a unique quality value while also listing them in order of decreasing
   quality.  Additional discussion of language priority lists can be
   found in &lt;a href=&quot;https://tools.ietf.org/html/rfc4647#section-2.3&quot;&gt;Section&amp;nbsp;2.3 of [RFC4647]&lt;/a&gt;.

   For matching, &lt;a href=&quot;https://tools.ietf.org/html/rfc4647#section-3&quot;&gt;Section&amp;nbsp;3 of [RFC4647]&lt;/a&gt; defines several matching
   schemes.  Implementations can offer the most appropriate matching
   scheme for their requirements.  The &quot;Basic Filtering&quot; scheme
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc4647#section-3.3.1&quot;&gt;[RFC4647], Section&amp;nbsp;3.3.1&lt;/a&gt;) is identical to the matching scheme that
   was previously defined for HTTP in &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-14.4&quot;&gt;Section&amp;nbsp;14.4 of [RFC2616]&lt;/a&gt;.

   It might be contrary to the privacy expectations of the user to send
   an Accept-Language header field with the complete linguistic
   preferences of the user in every request (&lt;a href=&quot;#section-9.7&quot;&gt;Section 9.7&lt;/a&gt;).

   Since intelligibility is highly dependent on the individual user,
   user agents need to allow user control over the linguistic preference
   (either through configuration of the user agent itself or by
   defaulting to a user controllable system setting).  A user agent that
   does not provide such control to the user MUST NOT send an
   Accept-Language header field.

      Note: User agents ought to provide guidance to users when setting
      a preference, since users are rarely familiar with the details of
      language matching as described above.  For example, users might
      assume that on selecting &quot;en-gb&quot;, they will be served any kind of
      English document if British English is not available.  A user
      agent might suggest, in such a case, to add &quot;en&quot; to the list for
      better matching behavior.</source>
          <target state="translated">用户代理可以使用&amp;ldquo; Accept-Language&amp;rdquo;标头字段指示响应中首选的自然语言集。语言标签在&lt;a href=&quot;#section-3.1.3.1&quot;&gt;第3.1.3.1节&lt;/a&gt;中定义。 Accept-Language = 1＃（language-range [weight]）language-range = &amp;lt;language-range，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc4647#section-2.1&quot;&gt;[RFC4647]，第2.1节&lt;/a&gt; &amp;gt;可以为每个语言范围分配一个相关的质量值，该值表示用户对... ...的偏爱估计根据&lt;a href=&quot;#section-5.3.1&quot;&gt;第5.3.1节的&lt;/a&gt;定义，由该范围指定的语言。例如，Accept-Language：da，en-gb; q = 0.8，en; q = 0.7表示：&amp;ldquo;我更喜欢丹麦语，但会接受英式英语和其他类型的英语&amp;rdquo;。没有任何Accept-Language标头字段的请求表示用户代理将接受任何语言作为响应。如果请求中存在标头字段，并且响应的任何可用表示均没有匹配的语言标签，则源服务器可以通过将响应视为未经内容协商的方式来忽略标头字段，或者可以接受标头通过发送406（不可接受）响应来填写字段。但是，不鼓励后者，因为这样做会阻止用户访问他们可能使用的内容（例如，使用翻译软件）。请注意，某些收件人将语言标签的列出顺序视为优先级降序的指示，尤其是对于那些分配了相同质量值（没有值与q = 1相同）的标签。但是，不能依靠此行为。为了保持一致性并最大程度地提高互操作性，许多用户代理为每种语言标签分配了唯一的质量值，同时还按质量递减的顺序列出了它们。有关语言优先级列表的更多讨论，请参见许多用户代理为每种语言标签分配一个唯一的质量值，同时还按质量递减的顺序列出它们。有关语言优先级列表的更多讨论，请参见许多用户代理为每种语言标签分配一个唯一的质量值，同时还按质量递减的顺序列出它们。有关语言优先级列表的更多讨论，请参见&lt;a href=&quot;https://tools.ietf.org/html/rfc4647#section-2.3&quot;&gt;[RFC4647]的2.3节&lt;/a&gt;。为了匹配，&lt;a href=&quot;https://tools.ietf.org/html/rfc4647#section-3&quot;&gt;[RFC4647]的第3节&lt;/a&gt;定义了几种匹配方案。实现可以为其需求提供最合适的匹配方案。 &amp;ldquo;基本过滤&amp;rdquo;方案（&lt;a href=&quot;https://tools.ietf.org/html/rfc4647#section-3.3.1&quot;&gt;[RFC4647]，第3.3.1节&lt;/a&gt;）与先前在&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-14.4&quot;&gt;[RFC2616]的14.4节中&lt;/a&gt;为HTTP定义的匹配方案相同。在每个请求中发送带有用户完整语言偏好的Accept-Language标头字段可能与用户的隐私期望背道而驰（&lt;a href=&quot;#section-9.7&quot;&gt;第9.7节）&lt;/a&gt;）。由于可懂度高度依赖于各个用户，因此用户代理需要允许用户控制语言偏好（通过用户代理本身的配置或默认为用户可控制的系统设置）。不向用户提供此类控制的用户代理不得发送&amp;ldquo;接受语言&amp;rdquo;报头字段。注意：设置首选项时，用户代理应向用户提供指导，因为用户很少熟悉如上所述的语言匹配细节。例如，用户可能会假设选择&amp;ldquo; en-gb&amp;rdquo;时，如果没有英式英语，他们将获得任何种类的英语文档。在这种情况下，用户代理可能建议将&amp;ldquo; en&amp;rdquo;添加到列表中以实现更好的匹配行为。</target>
        </trans-unit>
        <trans-unit id="660e50878abbf252e2213e4a43a8c15147d72e0c" translate="yes" xml:space="preserve">
          <source>The &quot;Accept-Ranges&quot; header field allows a server to indicate that it
   supports range requests for the target resource.

     Accept-Ranges     = acceptable-ranges
     acceptable-ranges = 1#range-unit / &quot;none&quot;

   An origin server that supports byte-range requests for a given target
   resource MAY send

     Accept-Ranges: bytes

   to indicate what range units are supported.  A client MAY generate
   range requests without having received this header field for the
   resource involved.  Range units are defined in &lt;a href=&quot;#section-2&quot;&gt;Section 2&lt;/a&gt;.

   A server that does not support any kind of range request for the
   target resource MAY send

     Accept-Ranges: none

   to advise the client not to attempt a range request.</source>
          <target state="translated">服务器使用&amp;ldquo;接受范围&amp;rdquo;标头字段来指示它支持对目标资源的范围请求。接受范围=可接受范围可接受范围= 1＃range-unit /&amp;ldquo; none&amp;rdquo;支持给定目标资源的字节范围请求的原始服务器可以发送Accept-Ranges：字节来指示支持哪些范围单位。客户端可能会生成范围请求，而没有收到涉及资源的此报头字段。范围单位在&lt;a href=&quot;#section-2&quot;&gt;第2节&lt;/a&gt;中定义。不支持对目标资源的任何类型的范围请求的服务器可以发送Accept-Ranges：none来建议客户端不要尝试范围请求。</target>
        </trans-unit>
        <trans-unit id="07e147c0306bf45017b2c661d092871c17cc475c" translate="yes" xml:space="preserve">
          <source>The &quot;Age&quot; header field conveys the sender's estimate of the amount of
   time since the response was generated or successfully validated at
   the origin server.  Age values are calculated as specified in
   &lt;a href=&quot;#section-4.2.3&quot;&gt;Section 4.2.3&lt;/a&gt;.

     Age = delta-seconds

   The Age field-value is a non-negative integer, representing time in
   seconds (see &lt;a href=&quot;#section-1.2.1&quot;&gt;Section 1.2.1&lt;/a&gt;).

   The presence of an Age header field implies that the response was not
   generated or validated by the origin server for this request.
   However, lack of an Age header field does not imply the origin was
   contacted, since the response might have been received from an
   HTTP/1.0 cache that does not implement Age.</source>
          <target state="translated">&amp;ldquo;年龄&amp;rdquo;标头字段传达了发件人对自从在原始服务器上生成或成功验证响应以来的时间量的估计。年龄值按照&lt;a href=&quot;#section-4.2.3&quot;&gt;第4.2.3节中的&lt;/a&gt;规定计算 。 Age = delta-seconds Age字段值是一个非负整数，以秒为单位表示时间（请参见&lt;a href=&quot;#section-1.2.1&quot;&gt;1.2.1节&lt;/a&gt;）。 Age标头字段的存在意味着响应不是由原始服务器针对此请求生成或验证的。但是，缺少Age标头字段并不表示已联系源，因为可能已从未实现Age的HTTP / 1.0缓存接收到响应。</target>
        </trans-unit>
        <trans-unit id="1338498c252679bf6adfadb0f7074e7b148e3793" translate="yes" xml:space="preserve">
          <source>The &quot;Allow&quot; header field lists the set of methods advertised as
   supported by the target resource.  The purpose of this field is
   strictly to inform the recipient of valid request methods associated
   with the resource.

     Allow = #method

   Example of use:

     Allow: GET, HEAD, PUT

   The actual set of allowed methods is defined by the origin server at
   the time of each request.  An origin server MUST generate an Allow
   field in a 405 (Method Not Allowed) response and MAY do so in any
   other response.  An empty Allow field value indicates that the
   resource allows no methods, which might occur in a 405 response if
   the resource has been temporarily disabled by configuration.

   A proxy MUST NOT modify the Allow header field -- it does not need to
   understand all of the indicated methods in order to handle them
   according to the generic message handling rules.</source>
          <target state="translated">&quot;Allow &quot;头字段列出了目标资源所支持的广告方法集。这个字段的目的是严格地告知接收者与资源相关的有效请求方法。Allow=#method 使用示例。Allow:允许的方法的实际集合是由源服务器在每个请求时定义的。源服务器必须在405(方法不允许)响应中生成一个Allow字段,并且可以在任何其他响应中生成。一个空的Allow字段的值表示资源不允许使用方法,如果资源被配置暂时禁用,那么在405响应中可能会出现这种情况。代理必须不修改Allow头字段--它不需要理解所有指示的方法,以便根据通用消息处理规则来处理它们。</target>
        </trans-unit>
        <trans-unit id="833bc28aae892154d2187dc74fadd75ecc7a7e54" translate="yes" xml:space="preserve">
          <source>The &quot;Authorization&quot; header field allows a user agent to authenticate
   itself with an origin server -- usually, but not necessarily, after
   receiving a 401 (Unauthorized) response.  Its value consists of
   credentials containing the authentication information of the user
   agent for the realm of the resource being requested.

     Authorization = credentials

   If a request is authenticated and a realm specified, the same
   credentials are presumed to be valid for all other requests within
   this realm (assuming that the authentication scheme itself does not
   require otherwise, such as credentials that vary according to a
   challenge value or using synchronized clocks).

   A proxy forwarding a request MUST NOT modify any Authorization fields
   in that request.  See &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-3.2&quot;&gt;Section&amp;nbsp;3.2 of [RFC7234]&lt;/a&gt; for details of and
   requirements pertaining to handling of the Authorization field by
   HTTP caches.</source>
          <target state="translated">&amp;ldquo;授权&amp;rdquo;标头字段允许用户代理通过源服务器对自身进行身份验证-通常但不一定是在收到401（未经授权）响应之后。它的值由凭证组成，凭证包含用于所请求资源领域的用户代理的身份验证信息。授权=凭据如果请求已通过身份验证并指定了领域，则假定该凭据对该领域内的所有其他请求均有效（假设身份验证方案本身不需要其他身份，例如根据质询值而变化的凭据）或使用同步时钟）。转发请求的代理不得修改该请求中的任何&amp;ldquo;授权&amp;rdquo;字段。请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-3.2&quot;&gt;[RFC7234]的3.2节&lt;/a&gt; 有关通过HTTP缓存处理&amp;ldquo;授权&amp;rdquo;字段的详细信息和要求。</target>
        </trans-unit>
        <trans-unit id="7168d04cbf63301e6705540ed2ab42ae32147600" translate="yes" xml:space="preserve">
          <source>The &quot;Basic&quot; HTTP authentication scheme is defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7617&quot;&gt;RFC 7617&lt;/a&gt;, which transmits credentials as user ID/password pairs, encoded using base64.</source>
          <target state="translated">&lt;a href=&quot;https://tools.ietf.org/html/rfc7617&quot;&gt;RFC 7617中&lt;/a&gt;定义了&amp;ldquo;基本&amp;rdquo; HTTP身份验证方案，该方案将凭据作为用户ID /密码对传输，并使用base64进行编码。</target>
        </trans-unit>
        <trans-unit id="e6a4b6da05626e019facf6e5f03b1b90399b48bf" translate="yes" xml:space="preserve">
          <source>The &quot;Cache-Control&quot; header field is used to specify directives for
   caches along the request/response chain.  Such cache directives are
   unidirectional in that the presence of a directive in a request does
   not imply that the same directive is to be given in the response.

   A cache MUST obey the requirements of the Cache-Control directives
   defined in this section.  See &lt;a href=&quot;#section-5.2.3&quot;&gt;Section 5.2.3&lt;/a&gt; for information about how
   Cache-Control directives defined elsewhere are handled.

      Note: Some HTTP/1.0 caches might not implement Cache-Control.

   A proxy, whether or not it implements a cache, MUST pass cache
   directives through in forwarded messages, regardless of their
   significance to that application, since the directives might be
   applicable to all recipients along the request/response chain.  It is
   not possible to target a directive to a specific cache.

   Cache directives are identified by a token, to be compared
   case-insensitively, and have an optional argument, that can use both
   token and quoted-string syntax.  For the directives defined below
   that define arguments, recipients ought to accept both forms, even if
   one is documented to be preferred.  For any directive not defined by
   this specification, a recipient MUST accept both forms. 

     Cache-Control   = 1#cache-directive

     cache-directive = token [ &quot;=&quot; ( token / quoted-string ) ]

   For the cache directives defined below, no argument is defined (nor
   allowed) unless stated otherwise.</source>
          <target state="translated">&amp;ldquo; Cache-Control&amp;rdquo;头字段用于为请求/响应链中的缓存指定指令。这样的高速缓存指令是单向的，因为请求中存在指令并不意味着在响应中将给出相同的指令。缓存必须遵守本节中定义的Cache-Control指令的要求。请参阅&lt;a href=&quot;#section-5.2.3&quot;&gt;第5.2.3节&lt;/a&gt;有关如何处理在其他地方定义的Cache-Control指令的信息。注意：某些HTTP / 1.0缓存可能未实现Cache-Control。代理，无论是否实现缓存，都必须在转发的消息中传递缓存指令，无论它们对该应用程序的意义如何，因为该指令可能适用于请求/响应链中的所有接收者。无法将指令定向到特定的缓存。缓存指令由令牌标识，不区分大小写地进行比较，并具有可选参数，该参数可以同时使用令牌语法和带引号的字符串语法。对于下面定义的定义参数的指令，即使文档证明是首选格式，收件人也应接受两种格式。对于本规范未定义的任何指令，收件人必须接受两种形式。 Cache-Control = 1＃cache-directive缓存指令= token [&amp;ldquo; =&amp;rdquo;（token / quoted-string）]对于以下定义的cache指令，除非另有说明，否则未定义（不允许）自变量。</target>
        </trans-unit>
        <trans-unit id="ead8e33ac22c36beaaccc520e5c8f0383500fa6b" translate="yes" xml:space="preserve">
          <source>The &quot;Connection&quot; header field allows the sender to indicate desired
   control options for the current connection.  In order to avoid
   confusing downstream recipients, a proxy or gateway MUST remove or
   replace any received connection options before forwarding the
   message.

   When a header field aside from Connection is used to supply control
   information for or about the current connection, the sender MUST list
   the corresponding field-name within the Connection header field.  A
   proxy or gateway MUST parse a received Connection header field before
   a message is forwarded and, for each connection-option in this field,
   remove any header field(s) from the message with the same name as the
   connection-option, and then remove the Connection header field itself
   (or replace it with the intermediary's own connection options for the
   forwarded message).

   Hence, the Connection header field provides a declarative way of
   distinguishing header fields that are only intended for the immediate
   recipient (&quot;hop-by-hop&quot;) from those fields that are intended for all
   recipients on the chain (&quot;end-to-end&quot;), enabling the message to be
   self-descriptive and allowing future connection-specific extensions
   to be deployed without fear that they will be blindly forwarded by
   older intermediaries.

   The Connection header field's value has the following grammar:

     Connection        = 1#connection-option
     connection-option = token

   Connection options are case-insensitive.

   A sender MUST NOT send a connection option corresponding to a header
   field that is intended for all recipients of the payload.  For
   example, Cache-Control is never appropriate as a connection option
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2&quot;&gt;Section&amp;nbsp;5.2 of [RFC7234]&lt;/a&gt;). 

   The connection options do not always correspond to a header field
   present in the message, since a connection-specific header field
   might not be needed if there are no parameters associated with a
   connection option.  In contrast, a connection-specific header field
   that is received without a corresponding connection option usually
   indicates that the field has been improperly forwarded by an
   intermediary and ought to be ignored by the recipient.

   When defining new connection options, specification authors ought to
   survey existing header field names and ensure that the new connection
   option does not share the same name as an already deployed header
   field.  Defining a new connection option essentially reserves that
   potential field-name for carrying additional information related to
   the connection option, since it would be unwise for senders to use
   that field-name for anything else.

   The &quot;close&quot; connection option is defined for a sender to signal that
   this connection will be closed after completion of the response.  For
   example,

     Connection: close

   in either the request or the response header fields indicates that
   the sender is going to close the connection after the current
   request/response is complete (&lt;a href=&quot;#section-6.6&quot;&gt;Section 6.6&lt;/a&gt;).

   A client that does not support persistent connections MUST send the
   &quot;close&quot; connection option in every request message.

   A server that does not support persistent connections MUST send the
   &quot;close&quot; connection option in every response message that does not
   have a 1xx (Informational) status code.</source>
          <target state="translated">&amp;ldquo;连接&amp;rdquo;标头字段允许发送方指示当前连接的所需控制选项。为了避免混淆下游接收者，代理或网关必须在转发消息之前删除或替换任何接收到的连接选项。当使用Connection以外的头字段来提供有关当前连接或有关当前连接的控制信息时，发送方必须在Connection头字段内列出相应的字段名称。代理或网关必须在转发消息之前解析接收到的Connection头字段，对于该字段中的每个连接选项，请从消息中删除与连接选项同名的任何头字段，然后删除连接标头字段本身（或将其替换为中间的自己的转发邮件的连接选项）。因此，Connection标头字段提供了一种声明性方式，可将仅用于直接收件人（&amp;ldquo;逐跳&amp;rdquo;）的标头字段与用于链上所有收件人（&amp;ldquo;端到端&amp;rdquo;）的那些标头字段区分开&amp;rdquo;），从而使消息具有自我描述性，并允许将来部署特定于连接的扩展，而不必担心它们会被较旧的中介程序盲目转发。 Connection标头字段的值具有以下语法：Connection = 1＃connection-option connection-option =令牌连接选项不区分大小写。发送方不得发送与有效载荷的所有接收方对应的报头字段相对应的连接选项。例如，Cache-Control永远不适合作为连接选项（&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2&quot;&gt;[RFC7234]的5.2节&lt;/a&gt;）。连接选项并不总是与消息中存在的头字段相对应，因为如果没有参数与连接选项相关联，则可能不需要特定于连接的头字段。相反，在没有相应连接选项的情况下接收到的特定于连接的头字段通常指示该字段已被中介人不正确地转发，并且应该被接收者忽略。在定义新的连接选项时，规范作者应调查现有的标头字段名称，并确保新的连接选项不与已经部署的标头字段共享相同的名称。定义新的连接选项实际上会保留该潜在的字段名称，以携带与连接选项有关的其他信息，因为发送者在其他任何地方都使用该字段名是不明智的。为发送者定义了&amp;ldquo;关闭&amp;rdquo;连接选项，以指示在响应完成后将关闭此连接。例如，在请求或响应标头字段中的Connection：close表示发送方将在当前请求/响应完成后关闭连接（在请求或响应标头字段中的&amp;ldquo;关闭&amp;rdquo;表示发送方将在当前请求/响应完成后关闭连接（在请求或响应标头字段中的&amp;ldquo;关闭&amp;rdquo;表示发送方将在当前请求/响应完成后关闭连接（&lt;a href=&quot;#section-6.6&quot;&gt;6.6节&lt;/a&gt;）。不支持持久连接的客户端必须在每条请求消息中发送&amp;ldquo;关闭&amp;rdquo;连接选项。不支持持久连接的服务器必须在每个没有1xx（信息）状态代码的响应消息中发送&amp;ldquo;关闭&amp;rdquo;连接选项。</target>
        </trans-unit>
        <trans-unit id="f005d7daab665deae0b91cf8d9396978496c7fec" translate="yes" xml:space="preserve">
          <source>The &quot;Content-Encoding&quot; header field indicates what content codings
   have been applied to the representation, beyond those inherent in the
   media type, and thus what decoding mechanisms have to be applied in
   order to obtain data in the media type referenced by the Content-Type
   header field.  Content-Encoding is primarily used to allow a
   representation's data to be compressed without losing the identity of
   its underlying media type.

     Content-Encoding = 1#content-coding

   An example of its use is

     Content-Encoding: gzip

   If one or more encodings have been applied to a representation, the
   sender that applied the encodings MUST generate a Content-Encoding
   header field that lists the content codings in the order in which
   they were applied.  Additional information about the encoding
   parameters can be provided by other header fields not defined by this
   specification.

   Unlike Transfer-Encoding (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.3.1&quot;&gt;Section&amp;nbsp;3.3.1 of [RFC7230]&lt;/a&gt;), the codings
   listed in Content-Encoding are a characteristic of the
   representation; the representation is defined in terms of the coded
   form, and all other metadata about the representation is about the
   coded form unless otherwise noted in the metadata definition.
   Typically, the representation is only decoded just prior to rendering
   or analogous usage.

   If the media type includes an inherent encoding, such as a data
   format that is always compressed, then that encoding would not be
   restated in Content-Encoding even if it happens to be the same
   algorithm as one of the content codings.  Such a content coding would
   only be listed if, for some bizarre reason, it is applied a second
   time to form the representation.  Likewise, an origin server might
   choose to publish the same data as multiple representations that
   differ only in whether the coding is defined as part of Content-Type 

   or Content-Encoding, since some user agents will behave differently
   in their handling of each response (e.g., open a &quot;Save as ...&quot; dialog
   instead of automatic decompression and rendering of content).

   An origin server MAY respond with a status code of 415 (Unsupported
   Media Type) if a representation in the request message has a content
   coding that is not acceptable.</source>
          <target state="translated">&amp;ldquo; Content-Encoding&amp;rdquo;标头字段指示除了媒体类型所固有的内容编码之外，哪些内容编码已应用于表示形式，因此必须应用哪种解码机制才能获得Content-Reference所引用的媒体类型中的数据输入标题字段。内容编码主要用于允许压缩表示的数据，而不会丢失其基础媒体类型的身份。 Content-Encoding = 1＃content-coding它的用法示例是Content-Encoding：gzip如果一种表示形式已应用一种或多种编码，则应用了编码的发送者务必生成一个Content-Encoding头字段，该字段列出内容编码的应用顺序。关于编码参数的其他信息可以由本规范未定义的其他标头字段提供。与传输编码（&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.3.1&quot;&gt;[RFC7230]的3.3.1节&lt;/a&gt;），Content-Encoding中列出的编码是该表示的特征；该表示形式是根据编码形式定义的，并且有关该表示形式的所有其他元数据都是关于编码形式的，除非在元数据定义中另有说明。通常，仅在渲染或类似用法之前对表示进行解码。如果媒体类型包括固有编码，例如始终被压缩的数据格式，则即使碰巧是与内容编码之一相同的算法，该编码也不会在Content-Encoding中重述。仅出于某种奇怪的原因，将仅列出这种内容编码，如果第二次应用该内容编码以形成表示形式。同样原始服务器可能选择发布相同的数据，作为多个表示形式，它们的不同之处仅在于编码是定义为Content-Type还是Content-Encoding的一部分，因为某些用户代理在处理每个响应时的行为会有所不同（例如，打开&amp;ldquo;另存为...&amp;rdquo;对话框，而不是自动解压缩和呈现内容。如果请求消息中的表示具有不可接受的内容编码，则原始服务器可以用状态码415（不支持的媒体类型）进行响应。如果请求消息中的表示具有不可接受的内容编码，则原始服务器可以用状态码415（不支持的媒体类型）进行响应。如果请求消息中的表示具有不可接受的内容编码，则原始服务器可以用状态码415（不支持的媒体类型）进行响应。</target>
        </trans-unit>
        <trans-unit id="164d16f9f8916d272734f22f4029358169a82681" translate="yes" xml:space="preserve">
          <source>The &quot;Content-Language&quot; header field describes the natural language(s)
   of the intended audience for the representation.  Note that this
   might not be equivalent to all the languages used within the
   representation.

     Content-Language = 1#language-tag 

   Language tags are defined in &lt;a href=&quot;#section-3.1.3.1&quot;&gt;Section 3.1.3.1&lt;/a&gt;.  The primary purpose of
   Content-Language is to allow a user to identify and differentiate
   representations according to the users' own preferred language.
   Thus, if the content is intended only for a Danish-literate audience,
   the appropriate field is

     Content-Language: da

   If no Content-Language is specified, the default is that the content
   is intended for all language audiences.  This might mean that the
   sender does not consider it to be specific to any natural language,
   or that the sender does not know for which language it is intended.

   Multiple languages MAY be listed for content that is intended for
   multiple audiences.  For example, a rendition of the &quot;Treaty of
   Waitangi&quot;, presented simultaneously in the original Maori and English
   versions, would call for

     Content-Language: mi, en

   However, just because multiple languages are present within a
   representation does not mean that it is intended for multiple
   linguistic audiences.  An example would be a beginner's language
   primer, such as &quot;A First Lesson in Latin&quot;, which is clearly intended
   to be used by an English-literate audience.  In this case, the
   Content-Language would properly only include &quot;en&quot;.

   Content-Language MAY be applied to any media type -- it is not
   limited to textual documents.</source>
          <target state="translated">&amp;ldquo;内容语言&amp;rdquo;标题字段描述了表示形式的目标受众的自然语言。请注意，这可能并不等同于表示中使用的所有语言。 Content-Language = 1＃language-tag语言标签在&lt;a href=&quot;#section-3.1.3.1&quot;&gt;第3.1.3.1节&lt;/a&gt;中定义。内容语言的主要目的是允许用户根据用户自己喜欢的语言来识别和区分表示形式。因此，如果内容仅面向丹麦语读者，则适当的字段为Content-Language：da如果未指定Content-Language，则默认值为该内容针对所有语言的读者。这可能意味着发件人不认为它是特定于任何自然语言的，或者发件人不知道它打算使用哪种语言。可能会列出针对多种受众的内容使用多种语言。例如，在原始毛利语和英语版本中同时呈现的&amp;ldquo;怀唐伊条约&amp;rdquo;的译本将要求使用Content-Language：mi，zh_cn但是，仅仅因为表示中存在多种语言，并不意味着它打算用于多种语言的受众。一个例子是初学者的语言入门，例如&amp;ldquo;拉丁语入门&amp;rdquo;，显然是供有英语水平的听众使用的。在这种情况下，内容语言将只包含&amp;ldquo; en&amp;rdquo;。内容语言可以应用于任何媒体类型-不限于文本文档。在这种情况下，内容语言将只包含&amp;ldquo; en&amp;rdquo;。内容语言可以应用于任何媒体类型-不限于文本文档。在这种情况下，内容语言将只包含&amp;ldquo; en&amp;rdquo;。内容语言可以应用于任何媒体类型-不限于文本文档。</target>
        </trans-unit>
        <trans-unit id="befc0a5526257450f3dfb30b2d0dfe3ea24c1e2b" translate="yes" xml:space="preserve">
          <source>The &quot;Content-Location&quot; header field references a URI that can be used
   as an identifier for a specific resource corresponding to the
   representation in this message's payload.  In other words, if one
   were to perform a GET request on this URI at the time of this
   message's generation, then a 200 (OK) response would contain the same
   representation that is enclosed as payload in this message.

     Content-Location = absolute-URI / partial-URI

   The Content-Location value is not a replacement for the effective
   Request URI (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.5&quot;&gt;Section&amp;nbsp;5.5 of [RFC7230]&lt;/a&gt;).  It is representation
   metadata.  It has the same syntax and semantics as the header field
   of the same name defined for MIME body parts in &lt;a href=&quot;https://tools.ietf.org/html/rfc2557#section-4&quot;&gt;Section&amp;nbsp;4 of
   [RFC2557]&lt;/a&gt;.  However, its appearance in an HTTP message has some
   special implications for HTTP recipients. 

   If Content-Location is included in a 2xx (Successful) response
   message and its value refers (after conversion to absolute form) to a
   URI that is the same as the effective request URI, then the recipient
   MAY consider the payload to be a current representation of that
   resource at the time indicated by the message origination date.  For
   a GET (&lt;a href=&quot;#section-4.3.1&quot;&gt;Section 4.3.1&lt;/a&gt;) or HEAD (&lt;a href=&quot;#section-4.3.2&quot;&gt;Section 4.3.2&lt;/a&gt;) request, this is the
   same as the default semantics when no Content-Location is provided by
   the server.  For a state-changing request like PUT (&lt;a href=&quot;#section-4.3.4&quot;&gt;Section 4.3.4&lt;/a&gt;) or
   POST (&lt;a href=&quot;#section-4.3.3&quot;&gt;Section 4.3.3&lt;/a&gt;), it implies that the server's response contains
   the new representation of that resource, thereby distinguishing it
   from representations that might only report about the action (e.g.,
   &quot;It worked!&quot;).  This allows authoring applications to update their
   local copies without the need for a subsequent GET request.

   If Content-Location is included in a 2xx (Successful) response
   message and its field-value refers to a URI that differs from the
   effective request URI, then the origin server claims that the URI is
   an identifier for a different resource corresponding to the enclosed
   representation.  Such a claim can only be trusted if both identifiers
   share the same resource owner, which cannot be programmatically
   determined via HTTP.

   o  For a response to a GET or HEAD request, this is an indication
      that the effective request URI refers to a resource that is
      subject to content negotiation and the Content-Location
      field-value is a more specific identifier for the selected
      representation.

   o  For a 201 (Created) response to a state-changing method, a
      Content-Location field-value that is identical to the Location
      field-value indicates that this payload is a current
      representation of the newly created resource.

   o  Otherwise, such a Content-Location indicates that this payload is
      a representation reporting on the requested action's status and
      that the same report is available (for future access with GET) at
      the given URI.  For example, a purchase transaction made via a
      POST request might include a receipt document as the payload of
      the 200 (OK) response; the Content-Location field-value provides
      an identifier for retrieving a copy of that same receipt in the
      future.

   A user agent that sends Content-Location in a request message is
   stating that its value refers to where the user agent originally
   obtained the content of the enclosed representation (prior to any
   modifications made by that user agent).  In other words, the user
   agent is providing a back link to the source of the original
   representation. 

   An origin server that receives a Content-Location field in a request
   message MUST treat the information as transitory request context
   rather than as metadata to be saved verbatim as part of the
   representation.  An origin server MAY use that context to guide in
   processing the request or to save it for other uses, such as within
   source links or versioning metadata.  However, an origin server MUST
   NOT use such context information to alter the request semantics.

   For example, if a client makes a PUT request on a negotiated resource
   and the origin server accepts that PUT (without redirection), then
   the new state of that resource is expected to be consistent with the
   one representation supplied in that PUT; the Content-Location cannot
   be used as a form of reverse content selection identifier to update
   only one of the negotiated representations.  If the user agent had
   wanted the latter semantics, it would have applied the PUT directly
   to the Content-Location URI.</source>
          <target state="translated">&amp;ldquo; Content-Location&amp;rdquo;标头字段引用一个URI，该URI可用作与该消息的有效负载中的表示相对应的特定资源的标识符。换句话说，如果在生成此消息时要对此URI执行GET请求，则200（确定）响应将包含与该消息中包含的有效内容相同的表示形式。 Content-Location =绝对URI /部分URI Content-Location值不能替代有效的Request URI（&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.5&quot;&gt;[RFC7230]的5.5节&lt;/a&gt;）。它是表示元数据。它具有与&lt;a href=&quot;https://tools.ietf.org/html/rfc2557#section-4&quot;&gt;[RFC2557]的第4节中&lt;/a&gt;为MIME正文部分定义的相同名称的标头字段相同的语法和语义。。但是，它在HTTP消息中的出现对HTTP接收者有一些特殊的含义。如果Content-Location包含在2xx（成功）响应消息中，并且其值（转换为绝对格式后）引用与有效请求URI相同的URI，则接收者可以将有效载荷视为当前表示形式在消息始发日期指示的时间使用该资源。对于GET（&lt;a href=&quot;#section-4.3.1&quot;&gt;第4.3.1节&lt;/a&gt;）或HEAD（&lt;a href=&quot;#section-4.3.2&quot;&gt;第4.3.2节&lt;/a&gt;）请求，这与服务器未提供Content-Location时的默认语义相同。对于状态更改请求，例如PUT（&lt;a href=&quot;#section-4.3.4&quot;&gt;第4.3.4节&lt;/a&gt;）或POST（&lt;a href=&quot;#section-4.3.3&quot;&gt;第4.3.3 &lt;/a&gt;节）），则意味着服务器的响应包含该资源的新表示形式，从而将其与可能仅报告该操作的表示形式区分开（例如，&amp;ldquo;它起作用了！&amp;rdquo;）。这允许创作应用程序更新其本地副本，而无需后续的GET请求。如果Content-Location包含在2xx（成功）响应消息中，并且其字段值引用的是与有效请求URI不同的URI，则原始服务器会声明该URI是与所包含内容相对应的其他资源的标识符表示。仅当两个标识符共享相同的资源所有者（不能通过HTTP以编程方式确定）时，才能声明此声明。 o对于GET或HEAD请求的响应，这表明有效请求URI是指要进行内容协商的资源，并且Content-Location字段值是所选表示形式的更具体的标识符。 o对于状态更改方法的201（已创建）响应，与位置字段值相同的Content-Location字段值表示此有效负载是新创建资源的当前表示。 o否则，这样的Content-Location表示此有效负载是报告所请求操作状态的表示形式，并且相同的报告可用于给定URI（以供将来使用GET访问）。例如，通过POST请求进行的购买交易可能包括收据文档，作为200（OK）响应的有效内容； Content-Location字段值提供了一个标识符，用于将来检索同一张收据的副本。在请求消息中发送Content-Location的用户代理指出，其值是指该用户代理最初在何处获得所包含表示的内容（在该用户代理进行的任何修改之前）。换句话说，用户代理正在提供到原始表示源的反向链接。在请求消息中接收到Content-Location字段的源服务器必须将该信息视为临时请求上下文，而不是作为表示形式要逐字保存的元数据。原始服务器可以使用该上下文来指导处理请求或将其保存以用于其他用途，例如在源链接或版本控制元数据中。但是，源服务器不得使用此类上下文信息来更改请求语义。例如，如果客户端在协商的资源上发出PUT请求，并且原始服务器接受该PUT（无重定向），则该资源的新状态应与该PUT中提供的一个表示形式一致； Content-Location不能用作反向内容选择标识符的形式来仅更新协商的表示形式之一。如果用户代理想要后一种语义，它将直接将PUT应用到Content-Location URI。</target>
        </trans-unit>
        <trans-unit id="e94ff61628ee1556f9cb7b6e53cdb420e3640f8b" translate="yes" xml:space="preserve">
          <source>The &quot;Content-Range&quot; header field is sent in a single part 206
   (Partial Content) response to indicate the partial range of the
   selected representation enclosed as the message payload, sent in each
   part of a multipart 206 response to indicate the range enclosed
   within each body part, and sent in 416 (Range Not Satisfiable)
   responses to provide information about the selected representation.

     Content-Range       = byte-content-range
                         / other-content-range

     byte-content-range  = bytes-unit SP
                           ( byte-range-resp / unsatisfied-range )

     byte-range-resp     = byte-range &quot;/&quot; ( complete-length / &quot;*&quot; )
     byte-range          = first-byte-pos &quot;-&quot; last-byte-pos
     unsatisfied-range   = &quot;*/&quot; complete-length

     complete-length     = 1*DIGIT

     other-content-range = other-range-unit SP other-range-resp
     other-range-resp    = *CHAR 

   If a 206 (Partial Content) response contains a Content-Range header
   field with a range unit (&lt;a href=&quot;#section-2&quot;&gt;Section 2&lt;/a&gt;) that the recipient does not
   understand, the recipient MUST NOT attempt to recombine it with a
   stored representation.  A proxy that receives such a message SHOULD
   forward it downstream.

   For byte ranges, a sender SHOULD indicate the complete length of the
   representation from which the range has been extracted, unless the
   complete length is unknown or difficult to determine.  An asterisk
   character (&quot;*&quot;) in place of the complete-length indicates that the
   representation length was unknown when the header field was
   generated.

   The following example illustrates when the complete length of the
   selected representation is known by the sender to be 1234 bytes:

     Content-Range: bytes 42-1233/1234

   and this second example illustrates when the complete length is
   unknown:

     Content-Range: bytes 42-1233/*

   A Content-Range field value is invalid if it contains a
   byte-range-resp that has a last-byte-pos value less than its
   first-byte-pos value, or a complete-length value less than or equal
   to its last-byte-pos value.  The recipient of an invalid
   Content-Range MUST NOT attempt to recombine the received content with
   a stored representation.

   A server generating a 416 (Range Not Satisfiable) response to a
   byte-range request SHOULD send a Content-Range header field with an
   unsatisfied-range value, as in the following example:

     Content-Range: bytes */1234

   The complete-length in a 416 response indicates the current length of
   the selected representation.

   The Content-Range header field has no meaning for status codes that
   do not explicitly describe its semantic.  For this specification,
   only the 206 (Partial Content) and 416 (Range Not Satisfiable) status
   codes describe a meaning for Content-Range. 

   The following are examples of Content-Range values in which the
   selected representation contains a total of 1234 bytes:

   o  The first 500 bytes:

        Content-Range: bytes 0-499/1234

   o  The second 500 bytes:

        Content-Range: bytes 500-999/1234

   o  All except for the first 500 bytes:

        Content-Range: bytes 500-1233/1234

   o  The last 500 bytes:

        Content-Range: bytes 734-1233/1234</source>
          <target state="translated">在单部分206（部分内容）响应中发送&amp;ldquo; Content-Range&amp;rdquo;标头字段，以指示作为消息有效载荷包含的所选表示的部分范围，在多部分206响应的每个部分中发送以指示包含在其中的范围每个身体部位，并在416（无法满足范围）响应中发送，以提供有关所选表示形式的信息。内容范围=字节内容范围/其他内容范围字节内容范围=字节单位SP（字节范围resp /不满意范围）字节范围resp =字节范围&amp;ldquo; /&amp;rdquo;（完整-length /&amp;ldquo; *&amp;rdquo;）字节范围=第一个字节位置&amp;ldquo;-&amp;rdquo;最后一个字节位置未满足范围=&amp;ldquo; * /&amp;rdquo;complete-length complete-length = 1 * DIGIT other-content-range =其他范围单位SP other-range-resp other-range-resp = * CHAR如果206（部分内容）响应包含Content-Range标头字段使用范围单位（&lt;a href=&quot;#section-2&quot;&gt;第二节&lt;/a&gt;）接收者不理解的内容，接收者不得尝试将其与存储的表示形式重新组合。收到这样的消息的代理应该向下游转发它。对于字节范围，发送者应该指出从中提取范围的表示形式的完整长度，除非完整长度未知或难以确定。代替完整长度的星号字符（&amp;ldquo; *&amp;rdquo;）表示生成标题字段时表示长度未知。下面的示例说明发送方已知所选表示形式的完整长度为1234字节：Content-Range：字节42-1233 / 1234，而第二个示例说明何时未知完整长度：Content-Range：字节42-1233 / *如果Content-Range字段值包含的最后一个字节位置值小于其第一个字节位置值或完整长度值小于一个字节范围值，则该内容范围字段值无效或等于其最后一个字节的pos值。无效内容范围的接收者不得尝试将接收到的内容与存储的表示形式重新组合。产生对字节范围请求的416（Range Not Satisfiable）响应的服务器应该发送Content-Range头域，其值的范围不满足要求，如以下示例所示：Content-Range：bytes * / 1234 complete-length 416响应中的表示所选择表示的当前长度。对于未明确描述其语义的状态代码，Content-Range标头字段没有任何意义。对于此规范，仅206（部分内容）和416（范围不可满足）状态码描述了内容范围的含义。以下是Content-Range值的示例，其中所选表示形式总共包含1234个字节：o前500个字节：Content-Range：字节0-499 / 1234 o后500个字节：Content-Range：字节500- 999/1234 o除前500个字节外的所有内容：内容范围：字节500-1233 / 1234 o后500个字节：内容范围：字节734-1233 / 1234字节0-499 / 1234 o后500个字节：内容范围：字节500-999 / 1234 o除前500个字节外的所有内容：内容范围：字节500-1233 / 1234 o后500个字节：内容范围：字节734-1233 / 1234字节0-499 / 1234 o后500个字节：内容范围：字节500-999 / 1234 o除前500个字节外的所有内容：内容范围：字节500-1233 / 1234 o后500个字节：内容范围：字节734-1233 / 1234</target>
        </trans-unit>
        <trans-unit id="3c402cbbcb9ecb9297de91cbbec783939a3ff8f6" translate="yes" xml:space="preserve">
          <source>The &quot;Content-Type&quot; header field indicates the media type of the
   associated representation: either the representation enclosed in the
   message payload or the selected representation, as determined by the
   message semantics.  The indicated media type defines both the data
   format and how that data is intended to be processed by a recipient,
   within the scope of the received message semantics, after any content
   codings indicated by Content-Encoding are decoded.

     Content-Type = media-type 

   Media types are defined in &lt;a href=&quot;#section-3.1.1.1&quot;&gt;Section 3.1.1.1&lt;/a&gt;.  An example of the field
   is

     Content-Type: text/html; charset=ISO-8859-4

   A sender that generates a message containing a payload body SHOULD
   generate a Content-Type header field in that message unless the
   intended media type of the enclosed representation is unknown to the
   sender.  If a Content-Type header field is not present, the recipient
   MAY either assume a media type of &quot;application/octet-stream&quot;
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc2046#section-4.5.1&quot;&gt;[RFC2046], Section&amp;nbsp;4.5.1&lt;/a&gt;) or examine the data to determine its type.

   In practice, resource owners do not always properly configure their
   origin server to provide the correct Content-Type for a given
   representation, with the result that some clients will examine a
   payload's content and override the specified type.  Clients that do
   so risk drawing incorrect conclusions, which might expose additional
   security risks (e.g., &quot;privilege escalation&quot;).  Furthermore, it is
   impossible to determine the sender's intent by examining the data
   format: many data formats match multiple media types that differ only
   in processing semantics.  Implementers are encouraged to provide a
   means of disabling such &quot;content sniffing&quot; when it is used.</source>
          <target state="translated">&amp;ldquo; Content-Type&amp;rdquo;标头字段指示关联表示形式的媒体类型：消息有效负载中包含的表示形式，还是由消息语义确定的所选表示形式。在对由Content-Encoding指示的任何内容编码进行解码之后，所指示的媒体类型既定义了数据格式，又定义了接收者在接收的消息语义范围内打算如何处理该数据。 Content-Type =媒体类型媒体类型在&lt;a href=&quot;#section-3.1.1.1&quot;&gt;第3.1.1.1节&lt;/a&gt;中定义。该字段的一个示例是Content-Type：text / html; charset = ISO-8859-4除非包含的表示形式的预期媒体类型对于发送者是未知的，否则生成包含有效内容主体的消息的发送者应该在该消息中生成Content-Type头字段。如果不存在Content-Type头字段，则接收者可以假定媒体类型为&amp;ldquo; application / octet-stream&amp;rdquo;（&lt;a href=&quot;https://tools.ietf.org/html/rfc2046#section-4.5.1&quot;&gt;[RFC2046]，第4.5.1节）&lt;/a&gt;）或检查数据以确定其类型。实际上，资源所有者并不总是将其原始服务器正确配置为给定表示形式提供正确的Content-Type，结果是某些客户端将检查有效内容的内容并覆盖指定的类型。这样做的客户可能会得出错误的结论，这可能会带来其他安全风险（例如，&amp;ldquo;特权升级&amp;rdquo;）。此外，不可能通过检查数据格式来确定发送者的意图：许多数据格式与仅在处理语义上不同的多种媒体类型匹配。鼓励实现者提供一种在使用时禁用此类&amp;ldquo;内容嗅探&amp;rdquo;的方法。</target>
        </trans-unit>
        <trans-unit id="c0724161072ae90382f70ffbb3410a3dba3f3bf1" translate="yes" xml:space="preserve">
          <source>The &quot;Date&quot; header field represents the date and time at which the
   message was originated, having the same semantics as the Origination
   Date Field (orig-date) defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc5322#section-3.6.1&quot;&gt;Section&amp;nbsp;3.6.1 of [RFC5322]&lt;/a&gt;.  The
   field value is an HTTP-date, as defined in &lt;a href=&quot;#section-7.1.1.1&quot;&gt;Section 7.1.1.1&lt;/a&gt;.

     Date = HTTP-date

   An example is

     Date: Tue, 15 Nov 1994 08:12:31 GMT

   When a Date header field is generated, the sender SHOULD generate its
   field value as the best available approximation of the date and time
   of message generation.  In theory, the date ought to represent the
   moment just before the payload is generated.  In practice, the date
   can be generated at any time during message origination.

   An origin server MUST NOT send a Date header field if it does not
   have a clock capable of providing a reasonable approximation of the
   current instance in Coordinated Universal Time.  An origin server MAY
   send a Date header field if the response is in the 1xx
   (Informational) or 5xx (Server Error) class of status codes.  An
   origin server MUST send a Date header field in all other cases. 

   A recipient with a clock that receives a response message without a
   Date header field MUST record the time it was received and append a
   corresponding Date header field to the message's header section if it
   is cached or forwarded downstream.

   A user agent MAY send a Date header field in a request, though
   generally will not do so unless it is believed to convey useful
   information to the server.  For example, custom applications of HTTP
   might convey a Date if the server is expected to adjust its
   interpretation of the user's request based on differences between the
   user agent and server clocks.</source>
          <target state="translated">&amp;ldquo;日期&amp;rdquo;标头字段表示消息发起的日期和时间，其语义与&lt;a href=&quot;https://tools.ietf.org/html/rfc5322#section-3.6.1&quot;&gt;[RFC5322]的3.6.1节中&lt;/a&gt;定义的&amp;ldquo;起源日期&amp;rdquo;字段（原始日期）相同。字段值是HTTP日期，如&lt;a href=&quot;#section-7.1.1.1&quot;&gt;7.1.1.1节&lt;/a&gt;所定义。 Date = HTTP-date例如：Date：Tue，15 Nov 1994 08:12:31 GMT生成Date头字段时，发送方应生成其字段值，作为消息生成日期和时间的最佳可用近似值。从理论上讲，日期应该代表正好在生成有效负载之前的时刻。实际上，可以在消息发起期间的任何时间生成日期。如果原始服务器没有能够在协调世界时中提供当前实例的合理近似值的时钟，则它不得发送Date标头字段。如果响应在状态代码的1xx（信息）或5xx（服务器错误）类中，则原始服务器可以发送Date头字段。在所有其他情况下，原始服务器必须发送一个Date标头字段。带有时钟的接收方如果接收到没有Date头字段的响应消息，则必须记录接收时间，并且如果消息被缓存或转发到下游，则在消息的头部分附加一个相应的Date头字段。用户代理可以在请求中发送Date头字段，尽管通常不会这样做，除非它被认为可以将有用的信息传达给服务器。例如，如果期望服务器根据用户代理和服务器时钟之间的差异来调整其对用户请求的解释，则HTTP的自定义应用程序可能会传达一个日期。s标头节（如果已缓存或转发到下游）。用户代理可以在请求中发送Date头字段，尽管通常不会这样做，除非它被认为可以将有用的信息传达给服务器。例如，如果期望服务器根据用户代理和服务器时钟之间的差异来调整其对用户请求的解释，则HTTP的自定义应用程序可能会传达一个日期。s标头节（如果已缓存或转发到下游）。用户代理可以在请求中发送Date头字段，尽管通常不会这样做，除非它被认为可以将有用的信息传达给服务器。例如，如果期望服务器根据用户代理和服务器时钟之间的差异来调整其对用户请求的解释，则HTTP的自定义应用程序可能会传达一个日期。</target>
        </trans-unit>
        <trans-unit id="d5a2d6bec4db1f50bd741730e8b916c0b881dd31" translate="yes" xml:space="preserve">
          <source>The &quot;ETag&quot; header field in a response provides the current entity-tag
   for the selected representation, as determined at the conclusion of
   handling the request.  An entity-tag is an opaque validator for
   differentiating between multiple representations of the same
   resource, regardless of whether those multiple representations are
   due to resource state changes over time, content negotiation
   resulting in multiple representations being valid at the same time,
   or both.  An entity-tag consists of an opaque quoted string, possibly
   prefixed by a weakness indicator.

     ETag       = entity-tag

     entity-tag = [ weak ] opaque-tag
     weak       = %x57.2F ; &quot;W/&quot;, case-sensitive
     opaque-tag = DQUOTE *etagc DQUOTE
     etagc      = %x21 / %x23-7E / obs-text
                ; VCHAR except double quotes, plus obs-text

      Note: Previously, opaque-tag was defined to be a quoted-string
      (&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-3.11&quot;&gt;[RFC2616], Section&amp;nbsp;3.11&lt;/a&gt;); thus, some recipients might perform
      backslash unescaping.  Servers therefore ought to avoid backslash
      characters in entity tags.

   An entity-tag can be more reliable for validation than a modification
   date in situations where it is inconvenient to store modification
   dates, where the one-second resolution of HTTP date values is not
   sufficient, or where modification dates are not consistently
   maintained.

   Examples:

     ETag: &quot;xyzzy&quot;
     ETag: W/&quot;xyzzy&quot;
     ETag: &quot;&quot; 

   An entity-tag can be either a weak or strong validator, with strong
   being the default.  If an origin server provides an entity-tag for a
   representation and the generation of that entity-tag does not satisfy
   all of the characteristics of a strong validator (&lt;a href=&quot;#section-2.1&quot;&gt;Section 2.1&lt;/a&gt;), then
   the origin server MUST mark the entity-tag as weak by prefixing its
   opaque value with &quot;W/&quot; (case-sensitive).</source>
          <target state="translated">响应中的&amp;ldquo; ETag&amp;rdquo;标头字段为所选表示形式提供当前实体标签，该实体标签是在处理请求结束时确定的。实体标签是一个不透明的验证器，用于区分同一资源的多个表示形式，而不管这些多个表示形式是由于资源状态随时间而变化，内容协商导致多个表示形式同时有效还是两者兼而有之。实体标签由不透明的带引号的字符串组成，可能以漏洞指示器为前缀。 ETag =实体标签实体标签= [弱]不透明标签弱=％x57.2F; &amp;ldquo; W /&amp;rdquo;，区分大小写的不透明标签= DQUOTE * etagc DQUOTE etagc =％x21 /％x23-7E / obs-text； VCHAR除双引号外，加obs-text注意：以前，opaque-tag被定义为带引号的字符串（&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-3.11&quot;&gt;[RFC2616]，第3.11节&lt;/a&gt;）；因此，某些收件人可能会执行反斜杠转义。因此，服务器应避免在实体标签中使用反斜杠字符。在不方便存储修改日期，HTTP日期值的一秒分辨率不足或修改日期不能始终保持的情况下，实体标签比修改日期更可靠地进行验证。示例：ETag：&amp;ldquo; xyzzy&amp;rdquo; ETag：W /&amp;ldquo; xyzzy&amp;rdquo; ETag：&amp;ldquo;&amp;rdquo;实体标签可以是弱验证者，也可以是强验证者，默认情况下为强。如果原始服务器为表示提供了实体标签，并且该实体标签的生成不满足强验证器的所有特征（ &lt;a href=&quot;#section-2.1&quot;&gt;第2.1节）&lt;/a&gt;），然后原始服务器务必通过在实体标签的不透明值前面加上&amp;ldquo; W /&amp;rdquo;（区分大小写），将实体标签标记为弱标签。</target>
        </trans-unit>
        <trans-unit id="6cbf7e19bfd8298755a091ae5f476f70610c660d" translate="yes" xml:space="preserve">
          <source>The &quot;Expect&quot; header field in a request indicates a certain set of
   behaviors (expectations) that need to be supported by the server in
   order to properly handle this request.  The only such expectation
   defined by this specification is 100-continue.

     Expect  = &quot;100-continue&quot;

   The Expect field-value is case-insensitive.

   A server that receives an Expect field-value other than 100-continue
   MAY respond with a 417 (Expectation Failed) status code to indicate
   that the unexpected expectation cannot be met.

   A 100-continue expectation informs recipients that the client is
   about to send a (presumably large) message body in this request and
   wishes to receive a 100 (Continue) interim response if the
   request-line and header fields are not sufficient to cause an
   immediate success, redirect, or error response.  This allows the
   client to wait for an indication that it is worthwhile to send the
   message body before actually doing so, which can improve efficiency
   when the message body is huge or when the client anticipates that an
   error is likely (e.g., when sending a state-changing method, for the
   first time, without previously verified authentication credentials).

   For example, a request that begins with

     PUT /somewhere/fun HTTP/1.1
     Host: origin.example.com
     Content-Type: video/h264
     Content-Length: 1234567890987
     Expect: 100-continue


   allows the origin server to immediately respond with an error
   message, such as 401 (Unauthorized) or 405 (Method Not Allowed),
   before the client starts filling the pipes with an unnecessary data
   transfer.

   Requirements for clients:

   o  A client MUST NOT generate a 100-continue expectation in a request
      that does not include a message body.

   o  A client that will wait for a 100 (Continue) response before
      sending the request message body MUST send an Expect header field
      containing a 100-continue expectation. 

   o  A client that sends a 100-continue expectation is not required to
      wait for any specific length of time; such a client MAY proceed to
      send the message body even if it has not yet received a response.
      Furthermore, since 100 (Continue) responses cannot be sent through
      an HTTP/1.0 intermediary, such a client SHOULD NOT wait for an
      indefinite period before sending the message body.

   o  A client that receives a 417 (Expectation Failed) status code in
      response to a request containing a 100-continue expectation SHOULD
      repeat that request without a 100-continue expectation, since the
      417 response merely indicates that the response chain does not
      support expectations (e.g., it passes through an HTTP/1.0 server).

   Requirements for servers:

   o  A server that receives a 100-continue expectation in an HTTP/1.0
      request MUST ignore that expectation.

   o  A server MAY omit sending a 100 (Continue) response if it has
      already received some or all of the message body for the
      corresponding request, or if the framing indicates that there is
      no message body.

   o  A server that sends a 100 (Continue) response MUST ultimately send
      a final status code, once the message body is received and
      processed, unless the connection is closed prematurely.

   o  A server that responds with a final status code before reading the
      entire message body SHOULD indicate in that response whether it
      intends to close the connection or continue reading and discarding
      the request message (see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6.6&quot;&gt;Section&amp;nbsp;6.6 of [RFC7230]&lt;/a&gt;).

   An origin server MUST, upon receiving an HTTP/1.1 (or later)
   request-line and a complete header section that contains a
   100-continue expectation and indicates a request message body will
   follow, either send an immediate response with a final status code,
   if that status can be determined by examining just the request-line
   and header fields, or send an immediate 100 (Continue) response to
   encourage the client to send the request's message body.  The origin
   server MUST NOT wait for the message body before sending the 100
   (Continue) response.

   A proxy MUST, upon receiving an HTTP/1.1 (or later) request-line and
   a complete header section that contains a 100-continue expectation
   and indicates a request message body will follow, either send an
   immediate response with a final status code, if that status can be
   determined by examining just the request-line and header fields, or
   begin forwarding the request toward the origin server by sending a 

   corresponding request-line and header section to the next inbound
   server.  If the proxy believes (from configuration or past
   interaction) that the next inbound server only supports HTTP/1.0, the
   proxy MAY generate an immediate 100 (Continue) response to encourage
   the client to begin sending the message body.

      Note: The Expect header field was added after the original
      publication of HTTP/1.1 [&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC2068&lt;/a&gt;] as both the means to request an
      interim 100 (Continue) response and the general mechanism for
      indicating must-understand extensions.  However, the extension
      mechanism has not been used by clients and the must-understand
      requirements have not been implemented by many servers, rendering
      the extension mechanism useless.  This specification has removed
      the extension mechanism in order to simplify the definition and
      processing of 100-continue.</source>
          <target state="translated">请求中的&amp;ldquo;期望&amp;rdquo;标头字段指示服务器需要支持的一组特定行为（期望），以便正确处理此请求。本规范定义的唯一此类期望是100连续。 Expect =&amp;ldquo; 100-continue&amp;rdquo; Expect字段值不区分大小写。接收到非100连续期望字段值的服务器可能会以417（预期失败）状态码响应，以指示无法满足意外期望。 100连续期望值通知接收者该客户端即将在此请求中发送（可能很大）消息正文，并且如果请求行和标头字段不足以导致立即发送，则希望接收100（连续）临时响应成功，重定向，或错误响应。这允许客户端在实际发送之前等待值得发送消息正文的指示，这样可以提高效率，当消息正文很大或客户端预计可能发生错误时（例如，在发送状态时）第一次更改方法，而无需事先验证的身份验证凭据。例如，以PUT / somewhere / fun HTTP / 1.1开头的请求主机：origin.example.com内容类型：video / h264内容长度：1234567890987期望值：100-continue允许源服务器立即以错误进行响应客户端开始使用不必要的数据传输填充管道之前，显示401（未经授权）或405（不允许使用方法）之类的消息。对客户的要求：o客户端不得在不包含消息正文的请求中生成100个连续的期望值。 o在发送请求消息主体之前，将等待100（继续）响应的客户端必须发送包含100-继续期望的Expect头域。 o发送100连续期望值的客户端不需要等待任何特定时间长度；这样的客户端即使没有收到响应也可以继续发送消息体。此外，由于不能通过HTTP / 1.0中介发送100（继续）响应，因此这样的客户端在发送消息正文之前不应等待不确定的时间。o响应包含100连续期望的请求而接收到417（期望失败）状态码的客户端应在没有100继续期望的情况下重复该请求，因为417响应仅表示响应链不支持期望（例如，它通过HTTP / 1.0服务器）。服务器要求：o在HTTP / 1.0请求中接收到100个连续期望的服务器必须忽略该期望。 o如果服务器已经接收到相应请求的部分或全部消息正文，或者如果帧指示没有消息正文，则服务器可以忽略发送100（继续）响应。 o发送100（继续）响应的服务器必须最终发送最终状态码，一旦消息主体被接收和处理，除非连接过早关闭。 o在读取整个消息正文之前，使用最终状态代码响应的服务器应在该响应中指示它是打算关闭连接还是继续读取并丢弃请求消息（请参见&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6.6&quot;&gt;[RFC7230]的6.6节&lt;/a&gt;）。原始服务器务必在收到HTTP / 1.1（或更高版本）请求行和包含100连续期望值并指示将跟随请求消息主体的完整标头部分之后，发送带有最终状态代码的立即响应，是否可以仅通过检查请求行和标头字段确定该状态，还是发送立即100（继续）响应以鼓励客户端发送请求的消息正文。原始服务器在发送100（继续）响应之前，绝对不能等待消息正文。代理必须在收到HTTP / 1.1（或更高版本）请求行和包含100连续期望值并指示将跟随请求消息正文的完整标头部分之后，要么发送带有最终状态代码的立即响应，如果可以仅通过检查请求行和标头字段确定该状态，或者通过将相应的请求行和标头部分发送到下一个入站服务器来开始将请求转发到原始服务器。如果代理认为（通过配置或过去的交互）下一个入站服务器仅支持HTTP / 1.0，则代理可以生成立即100（继续）响应以鼓励客户端开始发送消息正文。注意：Expect标题字段是在原始发布的HTTP / 1.1 [如果代理认为（通过配置或过去的交互）下一个入站服务器仅支持HTTP / 1.0，则代理可以生成立即100（继续）响应以鼓励客户端开始发送消息正文。注意：Expect标题字段是在原始发布的HTTP / 1.1 [如果代理认为（通过配置或过去的交互）下一个入站服务器仅支持HTTP / 1.0，则代理可以生成立即100（继续）响应以鼓励客户端开始发送消息正文。注意：Expect标题字段是在原始发布的HTTP / 1.1 [&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC2068&lt;/a&gt;既是请求临时100（继续）响应的手段，又是指示必须理解的扩展的一般机制。但是，客户端尚未使用扩展机制，许多服务器尚未实现必须理解的要求，从而使扩展机制无用。该规范已删除扩展机制，以简化100连续的定义和处理。</target>
        </trans-unit>
        <trans-unit id="73ec74b4c3de0b0e8320b9c1e9209dc1703d5df1" translate="yes" xml:space="preserve">
          <source>The &quot;Expires&quot; header field gives the date/time after which the
   response is considered stale.  See &lt;a href=&quot;#section-4.2&quot;&gt;Section 4.2&lt;/a&gt; for further discussion
   of the freshness model.

   The presence of an Expires field does not imply that the original
   resource will change or cease to exist at, before, or after that
   time.

   The Expires value is an HTTP-date timestamp, as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.1&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.1&quot;&gt;7.1.1.1 of [RFC7231]&lt;/a&gt;.

     Expires = HTTP-date

   For example

     Expires: Thu, 01 Dec 1994 16:00:00 GMT

   A cache recipient MUST interpret invalid date formats, especially the
   value &quot;0&quot;, as representing a time in the past (i.e., &quot;already
   expired&quot;).

   If a response includes a Cache-Control field with the max-age
   directive (&lt;a href=&quot;#section-5.2.2.8&quot;&gt;Section 5.2.2.8&lt;/a&gt;), a recipient MUST ignore the Expires
   field.  Likewise, if a response includes the s-maxage directive
   (&lt;a href=&quot;#section-5.2.2.9&quot;&gt;Section 5.2.2.9&lt;/a&gt;), a shared cache recipient MUST ignore the Expires
   field.  In both these cases, the value in Expires is only intended
   for recipients that have not yet implemented the Cache-Control field.

   An origin server without a clock MUST NOT generate an Expires field
   unless its value represents a fixed time in the past (always expired)
   or its value has been associated with the resource by a system or
   user with a reliable clock.

   Historically, HTTP required the Expires field-value to be no more
   than a year in the future.  While longer freshness lifetimes are no
   longer prohibited, extremely large values have been demonstrated to
   cause problems (e.g., clock overflows due to use of 32-bit integers
   for time values), and many caches will evict a response far sooner
   than that.</source>
          <target state="translated">&amp;ldquo; Expires&amp;rdquo;标题字段提供日期/时间，在该日期/时间之后，响应被认为是过期的。有关新鲜度模型的进一步讨论，请参见&lt;a href=&quot;#section-4.2&quot;&gt;第4.2节&lt;/a&gt;。 Expires字段的存在并不意味着原始资源将在该时间之前，之后或之后改变或不再存在。 Expires值是HTTP日期时间戳，如&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.1&quot;&gt;[RFC7231]的7.1.1.1 &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.1&quot;&gt;节&lt;/a&gt;所定义。 Expires = HTTP-date例如Expires：Thu，01 Dec 1994 16:00:00 GMT缓存接收者必须将无效的日期格式（尤其是值&amp;ldquo; 0&amp;rdquo;）解释为表示过去的时间（即&amp;ldquo;已经过期&amp;rdquo;） ）。如果响应包含带有max-age指令的Cache-Control字段（&lt;a href=&quot;#section-5.2.2.8&quot;&gt;第5.2.2.8节&lt;/a&gt;），收件人必须忽略&amp;ldquo;过期&amp;rdquo;字段。同样，如果响应包含s-maxage指令（&lt;a href=&quot;#section-5.2.2.9&quot;&gt;第5.2.2.9节&lt;/a&gt;），共享的缓存接收者必须忽略Expires字段。在这两种情况下，Expires中的值仅适用于尚未实现Cache-Control字段的收件人。没有时钟的原始服务器不得生成Expires字段，除非其值表示过去的固定时间（总是过期），或者其值已由具有可靠时钟的系统或用户与资源相关联。从历史上看，HTTP要求Expires字段值在未来不超过一年。尽管不再禁止更长的刷新寿命，但是已经证明，过大的值会引起问题（例如，由于使用32位整数作为时间值而导致时钟溢出），并且许多缓存将比这更早地驱除响应。</target>
        </trans-unit>
        <trans-unit id="435ee716a99e236d6e9d74d1e773dafee502988a" translate="yes" xml:space="preserve">
          <source>The &quot;From&quot; header field contains an Internet email address for a
   human user who controls the requesting user agent.  The address ought
   to be machine-usable, as defined by &quot;mailbox&quot; in &lt;a href=&quot;https://tools.ietf.org/html/rfc5322#section-3.4&quot;&gt;Section&amp;nbsp;3.4 of
   [RFC5322]&lt;/a&gt;:

     From    = mailbox

     mailbox = &amp;lt;mailbox, see &lt;a href=&quot;https://tools.ietf.org/html/rfc5322#section-3.4&quot;&gt;[RFC5322], Section&amp;nbsp;3.4&lt;/a&gt;&amp;gt;

   An example is:

     From: webmaster@example.org

   The From header field is rarely sent by non-robotic user agents.  A
   user agent SHOULD NOT send a From header field without explicit
   configuration by the user, since that might conflict with the user's
   privacy interests or their site's security policy. 

   A robotic user agent SHOULD send a valid From header field so that
   the person responsible for running the robot can be contacted if
   problems occur on servers, such as if the robot is sending excessive,
   unwanted, or invalid requests.

   A server SHOULD NOT use the From header field for access control or
   authentication, since most recipients will assume that the field
   value is public information.</source>
          <target state="translated">&amp;ldquo;发件人&amp;rdquo;标头字段包含控制请求用户代理的人类用户的Internet电子邮件地址。该地址应该是机器可用的，如&lt;a href=&quot;https://tools.ietf.org/html/rfc5322#section-3.4&quot;&gt;[RFC5322]第3.4节中&lt;/a&gt;的&amp;ldquo;邮箱&amp;rdquo;所定义：发件人=邮箱邮箱= &amp;lt;邮箱，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc5322#section-3.4&quot;&gt;[RFC5322]第3.4节&lt;/a&gt;&amp;gt;例如：发件人：webmaster@example.org&amp;ldquo;发件人&amp;rdquo;标头字段很少由非机器人用户代理发送。没有用户的明确配置，用户代理不应该发送From头字段，因为这可能与用户的隐私利益或他们站点的安全策略冲突。机器人用户代理应发送有效的From头字段，以便在服务器上发生问题（例如，机器人发送过多，不需要或无效的请求）时，可以联系负责运行机器人的人员。服务器不应该将From标头字段用于访问控制或身份验证，因为大多数接收者都将假定该字段值为公共信息。</target>
        </trans-unit>
        <trans-unit id="145f68a05a65e51d6c2dc78deb7c678abdc3112c" translate="yes" xml:space="preserve">
          <source>The &quot;HTTP Content Coding Registry&quot; defines the namespace for content
   coding names (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-4.2&quot;&gt;Section&amp;nbsp;4.2 of [RFC7230]&lt;/a&gt;).  The content coding registry
   is maintained at &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/http-parameters&quot;&gt;http://www.iana.org/assignments/http-parameters&lt;/a&gt;&amp;gt;.</source>
          <target state="translated">&amp;ldquo; HTTP内容编码注册表&amp;rdquo;定义了内容编码名称的名称空间（&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-4.2&quot;&gt;[RFC7230]的4.2节&lt;/a&gt;）。内容编码注册表位于&amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/http-parameters&quot;&gt;http://www.iana.org/assignments/http-parameters&lt;/a&gt; &amp;gt;。</target>
        </trans-unit>
        <trans-unit id="096c718821f30fce49e8b7b18bb3a8ea8e6712d1" translate="yes" xml:space="preserve">
          <source>The &quot;HTTP Content Coding Registry&quot; has been updated with the
   registrations below:

   +----------+----------------------------------------+---------------+
   | Name     | Description                            | Reference     |
   +----------+----------------------------------------+---------------+
   | identity | Reserved (synonym for &quot;no encoding&quot; in | &lt;a href=&quot;#section-5.3.4&quot;&gt;Section 5.3.4&lt;/a&gt; |
   |          | Accept-Encoding)                       |               |
   +----------+----------------------------------------+---------------+</source>
          <target state="translated">&amp;ldquo; HTTP内容编码注册表&amp;rdquo;已通过以下注册进行了更新：+ ---------- + ----------------------- ----------------- + --------------- + | 姓名| 描述 参考| + ---------- + -------------------------------------- -+ --------------- + | 身份| 保留（在| &lt;a href=&quot;#section-5.3.4&quot;&gt;第5.3.4节&lt;/a&gt; | | | |&amp;ldquo;接受编码&amp;rdquo;中为&amp;ldquo;无编码&amp;rdquo;的同义词）| | + ---------- + -------------------------------------- -+ --------------- +</target>
        </trans-unit>
        <trans-unit id="a5c1ee951a5c8eed58e62c23efb0f5396f9627c4" translate="yes" xml:space="preserve">
          <source>The &quot;HTTP Range Unit Registry&quot; defines the namespace for the range
   unit names and refers to their corresponding specifications.  The
   registry has been created and is now maintained at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/http-parameters&quot;&gt;http://www.iana.org/assignments/http-parameters&lt;/a&gt;&amp;gt;.</source>
          <target state="translated">&amp;ldquo; HTTP范围单位注册表&amp;rdquo;定义范围单位名称的名称空间，并引用其相应的规范。已经创建了注册表，现在可以在&amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/http-parameters&quot;&gt;http://www.iana.org/assignments/http-parameters&lt;/a&gt; &amp;gt;上维护该注册表。</target>
        </trans-unit>
        <trans-unit id="c05bfcc8f57df61bc6ed194b315d3b4b0050023f" translate="yes" xml:space="preserve">
          <source>The &quot;HTTP Transfer Coding Registry&quot; defines the namespace for
   transfer coding names.  It is maintained at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/http-parameters&quot;&gt;http://www.iana.org/assignments/http-parameters&lt;/a&gt;&amp;gt;.</source>
          <target state="translated">&amp;ldquo; HTTP传输编码注册表&amp;rdquo;定义了传输编码名称的名称空间。它在&amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/http-parameters&quot;&gt;http://www.iana.org/assignments/http-parameters&lt;/a&gt; &amp;gt;上维护。</target>
        </trans-unit>
        <trans-unit id="a0b8c24090cb7e4cccc52c9a6ee16a7c95a28e07" translate="yes" xml:space="preserve">
          <source>The &quot;HTTP Transfer Coding Registry&quot; has been updated with the
   registrations below:

   +------------+--------------------------------------+---------------+
   | Name       | Description                          | Reference     |
   +------------+--------------------------------------+---------------+
   | chunked    | Transfer in a series of chunks       | &lt;a href=&quot;#section-4.1&quot;&gt;Section 4.1&lt;/a&gt;   |
   | compress   | UNIX &quot;compress&quot; data format [&lt;a href=&quot;#ref-Welch&quot;&gt;Welch&lt;/a&gt;]  | &lt;a href=&quot;#section-4.2.1&quot;&gt;Section 4.2.1&lt;/a&gt; |
   | deflate    | &quot;deflate&quot; compressed data            | &lt;a href=&quot;#section-4.2.2&quot;&gt;Section 4.2.2&lt;/a&gt; |
   |            | ([&lt;a href=&quot;https://tools.ietf.org/html/rfc1951&quot;&gt;RFC1951&lt;/a&gt;]) inside the &quot;zlib&quot; data   |               |
   |            | format ([&lt;a href=&quot;https://tools.ietf.org/html/rfc1950&quot;&gt;RFC1950&lt;/a&gt;])                   |               |
   | gzip       | GZIP file format [&lt;a href=&quot;https://tools.ietf.org/html/rfc1952&quot;&gt;RFC1952&lt;/a&gt;]           | &lt;a href=&quot;#section-4.2.3&quot;&gt;Section 4.2.3&lt;/a&gt; |
   | x-compress | Deprecated (alias for compress)      | &lt;a href=&quot;#section-4.2.1&quot;&gt;Section 4.2.1&lt;/a&gt; |
   | x-gzip     | Deprecated (alias for gzip)          | &lt;a href=&quot;#section-4.2.3&quot;&gt;Section 4.2.3&lt;/a&gt; |
   +------------+--------------------------------------+---------------+</source>
          <target state="translated">&amp;ldquo; HTTP传输编码注册表&amp;rdquo;已通过以下注册进行了更新：+ ------------ + --------------------- ----------------- + --------------- + |姓名|描述参考| + ------------ + ------------------------------------ -+ --------------- + |大块|转移一系列的块| &lt;a href=&quot;#section-4.1&quot;&gt;第4.1节&lt;/a&gt; | |压缩| UNIX&amp;ldquo;压缩&amp;rdquo;数据格式[ &lt;a href=&quot;#ref-Welch&quot;&gt;Welch&lt;/a&gt; ] | &lt;a href=&quot;#section-4.2.1&quot;&gt;第4.2.1节&lt;/a&gt; | |放气&amp;ldquo;压缩&amp;rdquo;压缩数据| &lt;a href=&quot;#section-4.2.2&quot;&gt;第4.2.2节&lt;/a&gt; | | | （[ &lt;a href=&quot;https://tools.ietf.org/html/rfc1951&quot;&gt;RFC1951&lt;/a&gt; ]）内的&amp;ldquo; zlib&amp;rdquo;数据| | | |格式（[ &lt;a href=&quot;https://tools.ietf.org/html/rfc1950&quot;&gt;RFC1950&lt;/a&gt;]）| | | gzip | GZIP文件格式[ &lt;a href=&quot;https://tools.ietf.org/html/rfc1952&quot;&gt;RFC1952&lt;/a&gt; ] | &lt;a href=&quot;#section-4.2.3&quot;&gt;第4.2.3节&lt;/a&gt; | | x压缩|不推荐使用（压缩的别名）| &lt;a href=&quot;#section-4.2.1&quot;&gt;第4.2.1节&lt;/a&gt; | | x-gzip |不推荐使用（gzip的别名）| &lt;a href=&quot;#section-4.2.3&quot;&gt;第4.2.3节&lt;/a&gt; | + ------------ + ------------------------------------ -+ --------------- +</target>
        </trans-unit>
        <trans-unit id="49c73e0ff74e54cb4f5a88bc231df89416d0af4b" translate="yes" xml:space="preserve">
          <source>The &quot;HTTP&quot; entry in the upgrade token registry has been updated with
   the registration below:

   +-------+----------------------+----------------------+-------------+
   | Value | Description          | Expected Version     | Reference   |
   |       |                      | Tokens               |             |
   +-------+----------------------+----------------------+-------------+
   | HTTP  | Hypertext Transfer   | any DIGIT.DIGIT      | &lt;a href=&quot;#section-2.6&quot;&gt;Section 2.6&lt;/a&gt; |
   |       | Protocol             | (e.g, &quot;2.0&quot;)         |             |
   +-------+----------------------+----------------------+-------------+

   The responsible party is: &quot;IETF (iesg@ietf.org) - Internet
   Engineering Task Force&quot;.</source>
          <target state="translated">升级令牌注册表中的&amp;ldquo; HTTP&amp;rdquo;条目已通过以下注册进行了更新：+ ------- + ---------------------- + ---------------------- + ------------- + |价值|描述预期版本|参考| | | |代币| | + ------- + ---------------------- + ------------------ ---- + ------------- + | HTTP |超文本传输​​|任何DIGIT.DIGIT | &lt;a href=&quot;#section-2.6&quot;&gt;第2.6节&lt;/a&gt; | | |协议| （例如，&amp;ldquo; 2.0&amp;rdquo;）| | + ------- + ---------------------- + ------------------ ---- + ------------- +负责方是：&amp;ldquo; IETF（iesg@ietf.org）-Internet工程任务组&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="706b09d6ff20df56763add1c7636ec30c154eae9" translate="yes" xml:space="preserve">
          <source>The &quot;Host&quot; header field in a request provides the host and port
   information from the target URI, enabling the origin server to
   distinguish among resources while servicing requests for multiple
   host names on a single IP address.

     Host = uri-host [ &quot;:&quot; port ] ; &lt;a href=&quot;#section-2.7.1&quot;&gt;Section 2.7.1&lt;/a&gt;

   A client MUST send a Host header field in all HTTP/1.1 request
   messages.  If the target URI includes an authority component, then a
   client MUST send a field-value for Host that is identical to that
   authority component, excluding any userinfo subcomponent and its &quot;@&quot;
   delimiter (&lt;a href=&quot;#section-2.7.1&quot;&gt;Section 2.7.1&lt;/a&gt;).  If the authority component is missing or
   undefined for the target URI, then a client MUST send a Host header
   field with an empty field-value.

   Since the Host field-value is critical information for handling a
   request, a user agent SHOULD generate Host as the first header field
   following the request-line.

   For example, a GET request to the origin server for
   &amp;lt;http://www.example.org/pub/WWW/&amp;gt; would begin with:

     GET /pub/WWW/ HTTP/1.1
     Host: www.example.org

   A client MUST send a Host header field in an HTTP/1.1 request even if
   the request-target is in the absolute-form, since this allows the
   Host information to be forwarded through ancient HTTP/1.0 proxies
   that might not have implemented Host.

   When a proxy receives a request with an absolute-form of
   request-target, the proxy MUST ignore the received Host header field
   (if any) and instead replace it with the host information of the
   request-target.  A proxy that forwards such a request MUST generate a
   new Host field-value based on the received request-target rather than
   forward the received Host field-value.

   Since the Host header field acts as an application-level routing
   mechanism, it is a frequent target for malware seeking to poison a
   shared cache or redirect a request to an unintended server.  An
   interception proxy is particularly vulnerable if it relies on the
   Host field-value for redirecting requests to internal servers, or for
   use as a cache key in a shared cache, without first verifying that
   the intercepted connection is targeting a valid IP address for that
   host. 

   A server MUST respond with a 400 (Bad Request) status code to any
   HTTP/1.1 request message that lacks a Host header field and to any
   request message that contains more than one Host header field or a
   Host header field with an invalid field-value.</source>
          <target state="translated">请求中的&amp;ldquo;主机&amp;rdquo;标头字段提供了来自目标URI的主机和端口信息，使源服务器可以区分资源，同时为单个IP地址上的多个主机名的请求提供服务。 Host = uri-host [&amp;ldquo;：&amp;rdquo; port]; &lt;a href=&quot;#section-2.7.1&quot;&gt;2.7.1节&lt;/a&gt; 客户端必须在所有HTTP / 1.1请求消息中发送主机头字段。如果目标URI包含授权组件，则客户端必须发送与该授权组件相同的Host字段值，但不包括任何userinfo子组件及其&amp;ldquo; @&amp;rdquo;定界符（&lt;a href=&quot;#section-2.7.1&quot;&gt;第2.7.1节）&lt;/a&gt;）。如果缺少或未定义目标URI的权限组件，则客户端务必发送带有空字段值的主机标头字段。由于主机字段值是处理请求的关键信息，因此用户代理应在请求行之后生成主机作为第一个标头字段。例如，对&amp;lt;http://www.example.org/pub/WWW/&amp;gt;的原始服务器的GET请求将以：GET / pub / WWW / HTTP / 1.1主机：www.example.org客户端必须即使请求目标采用绝对形式，也要在HTTP / 1.1请求中发送Host标头字段，因为这允许通过可能尚未实现Host的古老HTTP / 1.0代理转发Host信息。当代理接收到具有绝对形式的请求目标的请求时，代理必须忽略接收到的主机头字段（如果有的话），而应将其替换为请求目标的主机信息。转发此类请求的代理必须基于接收到的请求目标生成一个新的Host字段值，而不是转发接收到的Host字段值。由于主机标头字段充当应用程序级路由机制，因此它经常成为恶意软件试图破坏共享缓存或将请求重定向到意外服务器的目标。如果侦听代理依靠Host字段值将请求重定向到内部服务器，或用作共享缓存中的缓存键，而没有先验证被侦听的连接是否针对该主机的有效IP地址，则该侦听代理特别容易受到攻击。对于任何缺少主机头字段的HTTP / 1.1请求消息，以及包含多个主机头字段或具有无效字段值的主机头字段的任何请求消息，服务器必须以400（错误请求）状态码进行响应。</target>
        </trans-unit>
        <trans-unit id="bf76981296c1a614d1d61fab43ab95f1d60e0e35" translate="yes" xml:space="preserve">
          <source>The &quot;Hypertext Transfer Protocol (HTTP) Authentication Scheme
   Registry&quot; defines the namespace for the authentication schemes in
   challenges and credentials.  It has been created and is now
   maintained at &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/http-authschemes&quot;&gt;http://www.iana.org/assignments/http-authschemes&lt;/a&gt;&amp;gt;.</source>
          <target state="translated">&amp;ldquo;超文本传输​​协议（HTTP）身份验证方案注册表&amp;rdquo;在质询和凭据中定义了身份验证方案的名称空间。它已创建，现在可以在&amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/http-authschemes&quot;&gt;http://www.iana.org/assignments/http-authschemes&lt;/a&gt; &amp;gt;中进行维护。</target>
        </trans-unit>
        <trans-unit id="88cc8d3cf97af683587a5f4c1d90c4302b8b701f" translate="yes" xml:space="preserve">
          <source>The &quot;Hypertext Transfer Protocol (HTTP) Cache Directive Registry&quot;
   defines the namespace for the cache directives.  It has been created
   and is now maintained at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/http-cache-directives&quot;&gt;http://www.iana.org/assignments/http-cache-directives&lt;/a&gt;&amp;gt;.</source>
          <target state="translated">&amp;ldquo;超文本传输​​协议（HTTP）缓存指令注册表&amp;rdquo;定义了缓存指令的名称空间。它已创建，现在在&amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/http-cache-directives&quot;&gt;http://www.iana.org/assignments/http-cache-directives&lt;/a&gt; &amp;gt;中进行维护。</target>
        </trans-unit>
        <trans-unit id="b60962bbc448e0c8070e4bc5da2bd79c07e165d8" translate="yes" xml:space="preserve">
          <source>The &quot;Hypertext Transfer Protocol (HTTP) Method Registry&quot; defines the
   namespace for the request method token (&lt;a href=&quot;#section-4&quot;&gt;Section 4&lt;/a&gt;).  The method
   registry has been created and is now maintained at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/http-methods&quot;&gt;http://www.iana.org/assignments/http-methods&lt;/a&gt;&amp;gt;.</source>
          <target state="translated">&amp;ldquo;超文本传输​​协议（HTTP）方法注册表&amp;rdquo;定义了请求方法令牌的名称空间（&lt;a href=&quot;#section-4&quot;&gt;第4节&lt;/a&gt;）。方法注册表已创建，现在在&amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/http-methods&quot;&gt;http://www.iana.org/assignments/http-methods&lt;/a&gt; &amp;gt;上进行维护。</target>
        </trans-unit>
        <trans-unit id="c7c8fd27b56ab4d4e5338d1c107879dea630f834" translate="yes" xml:space="preserve">
          <source>The &quot;Hypertext Transfer Protocol (HTTP) Method Registry&quot; has been
   populated with the registrations below:

   +---------+------+------------+---------------+
   | Method  | Safe | Idempotent | Reference     |
   +---------+------+------------+---------------+
   | CONNECT | no   | no         | &lt;a href=&quot;#section-4.3.6&quot;&gt;Section 4.3.6&lt;/a&gt; |
   | DELETE  | no   | yes        | &lt;a href=&quot;#section-4.3.5&quot;&gt;Section 4.3.5&lt;/a&gt; |
   | GET     | yes  | yes        | &lt;a href=&quot;#section-4.3.1&quot;&gt;Section 4.3.1&lt;/a&gt; |
   | HEAD    | yes  | yes        | &lt;a href=&quot;#section-4.3.2&quot;&gt;Section 4.3.2&lt;/a&gt; |
   | OPTIONS | yes  | yes        | &lt;a href=&quot;#section-4.3.7&quot;&gt;Section 4.3.7&lt;/a&gt; |
   | POST    | no   | no         | &lt;a href=&quot;#section-4.3.3&quot;&gt;Section 4.3.3&lt;/a&gt; |
   | PUT     | no   | yes        | &lt;a href=&quot;#section-4.3.4&quot;&gt;Section 4.3.4&lt;/a&gt; |
   | TRACE   | yes  | yes        | &lt;a href=&quot;#section-4.3.8&quot;&gt;Section 4.3.8&lt;/a&gt; |
   +---------+------+------------+---------------+</source>
          <target state="translated">&amp;ldquo;超文本传输​​协议（HTTP）方法注册表&amp;rdquo;已使用以下注册填充：+ --------- + ------ ++ ------------ + --------------- + |方法安全|等幂|参考| + --------- + ------ + ------------ + --------------- + |连接|没有没有&lt;a href=&quot;#section-4.3.6&quot;&gt;第4.3.6节&lt;/a&gt; | |删除没有是的&lt;a href=&quot;#section-4.3.5&quot;&gt;第4.3.5节&lt;/a&gt; | | GET |是的是的&lt;a href=&quot;#section-4.3.1&quot;&gt;第4.3.1节&lt;/a&gt; | |头|是的是的&lt;a href=&quot;#section-4.3.2&quot;&gt;第4.3.2节&lt;/a&gt; | |选项|是的是的&lt;a href=&quot;#section-4.3.7&quot;&gt;第4.3.7节&lt;/a&gt; | |发布|没有没有&lt;a href=&quot;#section-4.3.3&quot;&gt;第4.3.3节&lt;/a&gt; | |放置|没有是的&lt;a href=&quot;#section-4.3.4&quot;&gt;第4.3.4节&lt;/a&gt; | |追踪|是的是的&lt;a href=&quot;#section-4.3.8&quot;&gt;第4.3.8节&lt;/a&gt; | + --------- + ------ + ------------ + --------------- +</target>
        </trans-unit>
        <trans-unit id="af47de3832189b79659dd3c031cb9fcb9be1aa14" translate="yes" xml:space="preserve">
          <source>The &quot;Hypertext Transfer Protocol (HTTP) Status Code Registry&quot; defines
   the namespace for the response status-code token (&lt;a href=&quot;#section-6&quot;&gt;Section 6&lt;/a&gt;).  The
   status code registry is maintained at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/http-status-codes&quot;&gt;http://www.iana.org/assignments/http-status-codes&lt;/a&gt;&amp;gt;.

   This section replaces the registration procedure for HTTP Status
   Codes previously defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2817#section-7.1&quot;&gt;Section&amp;nbsp;7.1 of [RFC2817]&lt;/a&gt;.</source>
          <target state="translated">&amp;ldquo;超文本传输​​协议（HTTP）状态代码注册表&amp;rdquo;定义了响应状态代码令牌的名称空间（&lt;a href=&quot;#section-6&quot;&gt;第6节&lt;/a&gt;）。状态代码注册表位于&amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/http-status-codes&quot;&gt;http://www.iana.org/assignments/http-status-codes&lt;/a&gt; &amp;gt;。本部分替换了先前在&lt;a href=&quot;https://tools.ietf.org/html/rfc2817#section-7.1&quot;&gt;[RFC2817]的7.1节中&lt;/a&gt;定义的HTTP状态代码的注册过程。</target>
        </trans-unit>
        <trans-unit id="a4249a89b69736470c36f6442d2bdc76c91dde18" translate="yes" xml:space="preserve">
          <source>The &quot;Hypertext Transfer Protocol (HTTP) Status Code Registry&quot; located
   at &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/http-status-codes&quot;&gt;http://www.iana.org/assignments/http-status-codes&lt;/a&gt;&amp;gt; has been
   updated to include the registrations below:

   +-------+-----------------------+-------------+
   | Value | Description           | Reference   |
   +-------+-----------------------+-------------+
   | 206   | Partial Content       | &lt;a href=&quot;#section-4.1&quot;&gt;Section 4.1&lt;/a&gt; |
   | 416   | Range Not Satisfiable | &lt;a href=&quot;#section-4.4&quot;&gt;Section 4.4&lt;/a&gt; |
   +-------+-----------------------+-------------+</source>
          <target state="translated">位于&amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/http-status-codes&quot;&gt;http://www.iana.org/assignments/http-status-codes&lt;/a&gt; &amp;gt; 的&amp;ldquo;超文本传输​​协议（HTTP）状态代码注册表&amp;rdquo; 已更新，其中包括以下注册：+ ------- + ----------------------- + ------------- + |价值|描述参考| + ------- + ----------------------- + ------------- + | 206 |部分内容| &lt;a href=&quot;#section-4.1&quot;&gt;第4.1节&lt;/a&gt; | | 416 |范围无法满足| &lt;a href=&quot;#section-4.4&quot;&gt;第4.4节&lt;/a&gt; | + ------- + ----------------------- + ------------- +</target>
        </trans-unit>
        <trans-unit id="42357d7df40e3a7ed38e6ec9bc128df372e92eb1" translate="yes" xml:space="preserve">
          <source>The &quot;Hypertext Transfer Protocol (HTTP) Status Code Registry&quot; located
   at &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/http-status-codes&quot;&gt;http://www.iana.org/assignments/http-status-codes&lt;/a&gt;&amp;gt; has been
   updated with the registrations below:

   +-------+---------------------+-------------+
   | Value | Description         | Reference   |
   +-------+---------------------+-------------+
   | 304   | Not Modified        | &lt;a href=&quot;#section-4.1&quot;&gt;Section 4.1&lt;/a&gt; |
   | 412   | Precondition Failed | &lt;a href=&quot;#section-4.2&quot;&gt;Section 4.2&lt;/a&gt; |
   +-------+---------------------+-------------+</source>
          <target state="translated">位于&amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/http-status-codes&quot;&gt;http://www.iana.org/assignments/http-status-codes&lt;/a&gt; &amp;gt; 的&amp;ldquo;超文本传输​​协议（HTTP）状态代码注册表&amp;rdquo; 已通过以下注册进行了更新：+ ------- + --------------------- + ------------- + |价值|描述参考| + ------- + --------------------- + ------------- + | 304 |未修改| &lt;a href=&quot;#section-4.1&quot;&gt;第4.1节&lt;/a&gt; | | 412 |前提条件失败| &lt;a href=&quot;#section-4.2&quot;&gt;第4.2节&lt;/a&gt; | + ------- + --------------------- + ------------- +</target>
        </trans-unit>
        <trans-unit id="6373f51fbfb2756123d6ebe8d028d312dde91148" translate="yes" xml:space="preserve">
          <source>The &quot;Hypertext Transfer Protocol (HTTP) Status Code Registry&quot; located
   at &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/http-status-codes&quot;&gt;http://www.iana.org/assignments/http-status-codes&lt;/a&gt;&amp;gt; has been
   updated with the registrations below:

   +-------+-------------------------------+-------------+
   | Value | Description                   | Reference   |
   +-------+-------------------------------+-------------+
   | 401   | Unauthorized                  | &lt;a href=&quot;#section-3.1&quot;&gt;Section 3.1&lt;/a&gt; |
   | 407   | Proxy Authentication Required | &lt;a href=&quot;#section-3.2&quot;&gt;Section 3.2&lt;/a&gt; |
   +-------+-------------------------------+-------------+</source>
          <target state="translated">位于&amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/http-status-codes&quot;&gt;http://www.iana.org/assignments/http-status-codes&lt;/a&gt; &amp;gt; 的&amp;ldquo;超文本传输​​协议（HTTP）状态代码注册表&amp;rdquo; 已通过以下注册进行了更新：+ ------- + ------------------------------- + ------------- + |价值|描述参考| + ------- + ------------------------------- + --------- ---- + | 401 |未经授权| &lt;a href=&quot;#section-3.1&quot;&gt;第3.1节&lt;/a&gt; | | 407 |需要代理身份验证| &lt;a href=&quot;#section-3.2&quot;&gt;第3.2节&lt;/a&gt; | + ------- + ------------------------------- + --------- ---- +</target>
        </trans-unit>
        <trans-unit id="5cad05fd1eebfb52b696d9b41f75945bfa2216cd" translate="yes" xml:space="preserve">
          <source>The &quot;Hypertext Transfer Protocol (HTTP) Upgrade Token Registry&quot;
   defines the namespace for protocol-name tokens used to identify
   protocols in the Upgrade header field.  The registry is maintained at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/http-upgrade-tokens&quot;&gt;http://www.iana.org/assignments/http-upgrade-tokens&lt;/a&gt;&amp;gt;.</source>
          <target state="translated">&amp;ldquo;超文本传输​​协议（HTTP）升级令牌注册表&amp;rdquo;定义了用于在升级头字段中标识协议的协议名称令牌的名称空间。该注册表位于&amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/http-upgrade-tokens&quot;&gt;http://www.iana.org/assignments/http-upgrade-tokens&lt;/a&gt; &amp;gt;。</target>
        </trans-unit>
        <trans-unit id="dff627671b970f06b09a819242fd5432d30d4c1d" translate="yes" xml:space="preserve">
          <source>The &quot;Hypertext Transfer Protocol (HTTP) Warn Codes&quot; registry defines
   the namespace for warn codes.  It has been created and is now
   maintained at &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/http-warn-codes&quot;&gt;http://www.iana.org/assignments/http-warn-codes&lt;/a&gt;&amp;gt;.</source>
          <target state="translated">&amp;ldquo;超文本传输​​协议（HTTP）警告代码&amp;rdquo;注册表定义了警告代码的名称空间。它已经创建，现在可以在&amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/http-warn-codes&quot;&gt;http://www.iana.org/assignments/http-warn-codes&lt;/a&gt; &amp;gt;上进行维护。</target>
        </trans-unit>
        <trans-unit id="ce30eef6a7cd5d843d61361a8fb74fe7770cdcce" translate="yes" xml:space="preserve">
          <source>The &quot;If-Match&quot; header field makes the request method conditional on
   the recipient origin server either having at least one current
   representation of the target resource, when the field-value is &quot;*&quot;,
   or having a current representation of the target resource that has an
   entity-tag matching a member of the list of entity-tags provided in
   the field-value.

   An origin server MUST use the strong comparison function when
   comparing entity-tags for If-Match (&lt;a href=&quot;#section-2.3.2&quot;&gt;Section 2.3.2&lt;/a&gt;), since the client
   intends this precondition to prevent the method from being applied if
   there have been any changes to the representation data.

     If-Match = &quot;*&quot; / 1#entity-tag

   Examples:

     If-Match: &quot;xyzzy&quot;
     If-Match: &quot;xyzzy&quot;, &quot;r2d2xxxx&quot;, &quot;c3piozzzz&quot;
     If-Match: *

   If-Match is most often used with state-changing methods (e.g., POST,
   PUT, DELETE) to prevent accidental overwrites when multiple user
   agents might be acting in parallel on the same resource (i.e., to 

   prevent the &quot;lost update&quot; problem).  It can also be used with safe
   methods to abort a request if the selected representation does not
   match one already stored (or partially stored) from a prior request.

   An origin server that receives an If-Match header field MUST evaluate
   the condition prior to performing the method (&lt;a href=&quot;#section-5&quot;&gt;Section 5&lt;/a&gt;).  If the
   field-value is &quot;*&quot;, the condition is false if the origin server does
   not have a current representation for the target resource.  If the
   field-value is a list of entity-tags, the condition is false if none
   of the listed tags match the entity-tag of the selected
   representation.

   An origin server MUST NOT perform the requested method if a received
   If-Match condition evaluates to false; instead, the origin server
   MUST respond with either a) the 412 (Precondition Failed) status code
   or b) one of the 2xx (Successful) status codes if the origin server
   has verified that a state change is being requested and the final
   state is already reflected in the current state of the target
   resource (i.e., the change requested by the user agent has already
   succeeded, but the user agent might not be aware of it, perhaps
   because the prior response was lost or a compatible change was made
   by some other user agent).  In the latter case, the origin server
   MUST NOT send a validator header field in the response unless it can
   verify that the request is a duplicate of an immediately prior change
   made by the same user agent.

   The If-Match header field can be ignored by caches and intermediaries
   because it is not applicable to a stored response.</source>
          <target state="translated">当字段值是&amp;ldquo; *&amp;rdquo;时，&amp;ldquo; If-Match&amp;rdquo;头域使请求方法的条件为接收方原始服务器具有目标资源的至少一种当前表示形式，或者具有以下形式的目标资源的当前表示形式：具有与字段值中提供的实体标签列表的成员匹配的实体标签。当比较If-Match的实体标签时，原始服务器必须使用强大的比较功能（&lt;a href=&quot;#section-2.3.2&quot;&gt;第2.3.2节&lt;/a&gt;），因为如果表示数据发生任何更改，客户端希望使用此前提条件来防止应用该方法。 If-Match =&amp;ldquo; *&amp;rdquo; / 1＃entity-tag示例：If-Match：&amp;ldquo; xyzzy&amp;rdquo; If-Match：&amp;ldquo; xyzzy&amp;rdquo;，&amp;ldquo; r2d2xxxx&amp;rdquo;，&amp;ldquo; c3piozzzz&amp;rdquo; If-Match：* If-Match最常与状态更改方法（例如POST，PUT，DELETE），以防止多个用户代理在同一资源上并行执行操作时发生意外覆盖（即，防止&amp;ldquo;丢失更新&amp;rdquo;问题）。如果选定的表示与先前请求中已经存储（或部分存储）的表示不匹配，它也可以与安全方法一起用于中止请求。接收到If-Match标头字段的原始服务器必须在执行该方法之前评估条件（&lt;a href=&quot;#section-5&quot;&gt;第5节&lt;/a&gt;）。如果字段值为&amp;ldquo; *&amp;rdquo;，则当源服务器没有目标资源的当前表示形式时，条件为false。如果该字段值是实体标签的列表，则如果列出的标签中没有一个与所选表示形式的实体标签匹配，则条件为false。如果收到的If-Match条件评估为false，则原始服务器不得执行请求的方法；相反，如果原始服务器已验证请求了状态更改并且已经存在最终状态，则原始服务器必须使用以下两种方式之一响应：a）412（失败的前提条件）状态代码或b）2xx（成功）状态代码之一。反映在目标资源的当前状态中（即，用户代理请求的更改已成功完成，但用户代理可能不知道这一点，可能是因为先前的响应丢失了，或者其他用户代理进行了兼容的更改）。在后一种情况下，除非原始服务器可以验证请求是否是同一用户代理所做的先前更改的重复，否则原始服务器不得在响应中发送验证者头字段。缓存和中介可以忽略If-Match标头字段，因为它不适用于存储的响应。缓存和中介可以忽略If-Match标头字段，因为它不适用于存储的响应。缓存和中介可以忽略If-Match标头字段，因为它不适用于存储的响应。</target>
        </trans-unit>
        <trans-unit id="6a8bdb230b0368d774ef7c392fdbc661a6f47bdb" translate="yes" xml:space="preserve">
          <source>The &quot;If-Modified-Since&quot; header field makes a GET or HEAD request
   method conditional on the selected representation's modification date
   being more recent than the date provided in the field-value.
   Transfer of the selected representation's data is avoided if that
   data has not changed.

     If-Modified-Since = HTTP-date

   An example of the field is:

     If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT

   A recipient MUST ignore If-Modified-Since if the request contains an
   If-None-Match header field; the condition in If-None-Match is
   considered to be a more accurate replacement for the condition in
   If-Modified-Since, and the two are only combined for the sake of
   interoperating with older intermediaries that might not implement
   If-None-Match.

   A recipient MUST ignore the If-Modified-Since header field if the
   received field-value is not a valid HTTP-date, or if the request
   method is neither GET nor HEAD.

   A recipient MUST interpret an If-Modified-Since field-value's
   timestamp in terms of the origin server's clock.

   If-Modified-Since is typically used for two distinct purposes: 1) to
   allow efficient updates of a cached representation that does not have
   an entity-tag and 2) to limit the scope of a web traversal to
   resources that have recently changed.

   When used for cache updates, a cache will typically use the value of
   the cached message's Last-Modified field to generate the field value
   of If-Modified-Since.  This behavior is most interoperable for cases
   where clocks are poorly synchronized or when the server has chosen to
   only honor exact timestamp matches (due to a problem with
   Last-Modified dates that appear to go &quot;back in time&quot; when the origin
   server's clock is corrected or a representation is restored from an
   archived backup).  However, caches occasionally generate the field
   value based on other data, such as the Date header field of the
   cached message or the local clock time that the message was received,
   particularly when the cached message does not contain a Last-Modified
   field. 

   When used for limiting the scope of retrieval to a recent time
   window, a user agent will generate an If-Modified-Since field value
   based on either its own local clock or a Date header field received
   from the server in a prior response.  Origin servers that choose an
   exact timestamp match based on the selected representation's
   Last-Modified field will not be able to help the user agent limit its
   data transfers to only those changed during the specified window.

   An origin server that receives an If-Modified-Since header field
   SHOULD evaluate the condition prior to performing the method
   (&lt;a href=&quot;#section-5&quot;&gt;Section 5&lt;/a&gt;).  The origin server SHOULD NOT perform the requested
   method if the selected representation's last modification date is
   earlier than or equal to the date provided in the field-value;
   instead, the origin server SHOULD generate a 304 (Not Modified)
   response, including only those metadata that are useful for
   identifying or updating a previously cached response.

   Requirements on cache handling of a received If-Modified-Since header
   field are defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.3.2&quot;&gt;Section&amp;nbsp;4.3.2 of [RFC7234]&lt;/a&gt;.</source>
          <target state="translated">标题字段&amp;ldquo; If-Modified-Since&amp;rdquo;使GET或HEAD请求方法的条件为所选表示的修改日期比字段值中提供的日期更新。如果所选表示的数据未更改，则避免该数据的传输。 If-Modified-Since = HTTP-date字段的示例是：If-Modified-Since：Sat，29 Oct 1994 19:43:31 GMT如果请求包含If-None，则收件人必须忽略If-Modified-Since。 -匹配头字段； If-None-Match中的条件被认为是If-Modified-Since中的条件的更准确替代，并且仅将两者结合是为了与可能未实现If-None-Match的较旧中介进行互操作。如果接收到的字段值不是有效的HTTP日期，或者请求方法既不是GET也不是HEAD，则接收方必须忽略If-Modified-Since头字段。接收者必须根据源服务器的时钟解释If-Modified-Since字段值的时间戳。 If-Modified-Since通常用于两个不同的目的：1）允许有效更新没有实体标签的缓存表示形式； 2）将Web遍历的范围限制为最近更改的资源。当用于缓存更新时，缓存通常将使用缓存消息的Last-Modified字段的值来生成If-Modified-Since的字段值。对于时钟同步不佳的情况，或者服务器选择仅遵循确切的时间戳匹配的情况，此行为是最可互操作的（由于校正原始服务器的时钟后，Last-Modified日期出现了&amp;ldquo;返回时间&amp;rdquo;的问题）或从存档备份还原制图表达）。但是，缓存有时会根据其他数据（例如，缓存的消息的Date头字段或接收到该消息的本地时钟时间）生成字段值，尤其是当缓存的消息不包含Last-Modified字段时。当用于将检索范围限制为最近的时间窗口时，用户代理将基于自身的本地时钟或在先前响应中从服务器接收到的Date标头字段来生成If-Modified-Since字段值。根据所选表示形式的&amp;ldquo; Last-Modified&amp;rdquo;字段选择确切时间戳匹配的原始服务器将无法帮助用户代理将其数据传输限制为仅在指定窗口内更改的数据传输。收到If-Modified-Since标头字段的原始服务器应在执行该方法之前评估条件（接收到If-Modified-Since头字段的原始服务器应在执行该方法之前评估条件（接收到If-Modified-Since头字段的原始服务器应在执行该方法之前评估条件（&lt;a href=&quot;#section-5&quot;&gt;第5节&lt;/a&gt;）。如果所选表示的最后修改日期早于或等于字段值中提供的日期，则原始服务器不应执行请求的方法；相反，源服务器应该生成304（未修改）响应，仅包括那些对于标识或更新先前缓存的响应有用的元数据。&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.3.2&quot;&gt;[RFC7234]的第4.3.2节&lt;/a&gt;定义了对接收的If-Modified-Since标头字段的缓存处理的要求。</target>
        </trans-unit>
        <trans-unit id="7a0c758120c2ca9721b5496606fe6d4cf8c40d68" translate="yes" xml:space="preserve">
          <source>The &quot;If-None-Match&quot; header field makes the request method conditional
   on a recipient cache or origin server either not having any current
   representation of the target resource, when the field-value is &quot;*&quot;,
   or having a selected representation with an entity-tag that does not
   match any of those listed in the field-value.

   A recipient MUST use the weak comparison function when comparing
   entity-tags for If-None-Match (&lt;a href=&quot;#section-2.3.2&quot;&gt;Section 2.3.2&lt;/a&gt;), since weak entity-tags
   can be used for cache validation even if there have been changes to
   the representation data.

     If-None-Match = &quot;*&quot; / 1#entity-tag 

   Examples:

     If-None-Match: &quot;xyzzy&quot;
     If-None-Match: W/&quot;xyzzy&quot;
     If-None-Match: &quot;xyzzy&quot;, &quot;r2d2xxxx&quot;, &quot;c3piozzzz&quot;
     If-None-Match: W/&quot;xyzzy&quot;, W/&quot;r2d2xxxx&quot;, W/&quot;c3piozzzz&quot;
     If-None-Match: *

   If-None-Match is primarily used in conditional GET requests to enable
   efficient updates of cached information with a minimum amount of
   transaction overhead.  When a client desires to update one or more
   stored responses that have entity-tags, the client SHOULD generate an
   If-None-Match header field containing a list of those entity-tags
   when making a GET request; this allows recipient servers to send a
   304 (Not Modified) response to indicate when one of those stored
   responses matches the selected representation.

   If-None-Match can also be used with a value of &quot;*&quot; to prevent an
   unsafe request method (e.g., PUT) from inadvertently modifying an
   existing representation of the target resource when the client
   believes that the resource does not have a current representation
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.2.1&quot;&gt;Section&amp;nbsp;4.2.1 of [RFC7231]&lt;/a&gt;).  This is a variation on the &quot;lost
   update&quot; problem that might arise if more than one client attempts to
   create an initial representation for the target resource.

   An origin server that receives an If-None-Match header field MUST
   evaluate the condition prior to performing the method (&lt;a href=&quot;#section-5&quot;&gt;Section 5&lt;/a&gt;).
   If the field-value is &quot;*&quot;, the condition is false if the origin
   server has a current representation for the target resource.  If the
   field-value is a list of entity-tags, the condition is false if one
   of the listed tags match the entity-tag of the selected
   representation.

   An origin server MUST NOT perform the requested method if the
   condition evaluates to false; instead, the origin server MUST respond
   with either a) the 304 (Not Modified) status code if the request
   method is GET or HEAD or b) the 412 (Precondition Failed) status code
   for all other request methods.

   Requirements on cache handling of a received If-None-Match header
   field are defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.3.2&quot;&gt;Section&amp;nbsp;4.3.2 of [RFC7234]&lt;/a&gt;.</source>
          <target state="translated">&amp;ldquo; If-None-Match&amp;rdquo;标头字段使请求方法的条件为收件人缓存或原始服务器，当字段值是&amp;ldquo; *&amp;rdquo;时，该对象不具有目标资源的任何当前表示形式，或者具有带有与该字段值中列出的任何实体标签都不匹配的实体标签。接收者在比较实体标签是否为不匹配时必须使用弱比较功能（&lt;a href=&quot;#section-2.3.2&quot;&gt;第2.3.2节）&lt;/a&gt;），因为即使对表示数据进行了更改，也可以使用弱实体标签进行缓存验证。 If-None-Match =&amp;ldquo; *&amp;rdquo; / 1＃entity-tag示例：If-None-Match：&amp;ldquo; xyzzy&amp;rdquo; If-None-Match：W /&amp;ldquo; xyzzy&amp;rdquo; If-None-Match：&amp;ldquo; xyzzy&amp;rdquo;，&amp;ldquo; r2d2xxxx&amp;rdquo; ，&amp;ldquo; c3piozzzz&amp;rdquo; If-None-Match：W /&amp;ldquo; xyzzy&amp;rdquo;，W /&amp;ldquo; r2d2xxxx&amp;rdquo;，W /&amp;ldquo; c3piozzzz&amp;rdquo; If-None-Match：* If-None-Match主要用于条件GET请求中以启用有效更新高速缓存的信息以最小的事务开销。当客户希望更新一个或多个带有实体标签的存储响应时，客户应该在发出GET请求时生成一个If-None-Match标头字段，其中包含这些实体标签的列表；这允许收件人服务器发送304（未修改）响应，以指示这些存储的响应之一何时与所选表示匹配。 If-None-Match也可以与值&amp;ldquo; *&amp;rdquo;一起使用，以防止不安全的请求方法（例如，PUT）在客户端认为资源没有当前表示形式时无意中修改了目标资源的现有表示形式（（PUT）是由于客户端认为资源没有当前表示形式而无意间修改了目标资源的现有表示形式（（PUT）是由于客户端认为资源没有当前表示形式而无意间修改了目标资源的现有表示形式（&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.2.1&quot;&gt;[RFC7231]的第4.2.1节&lt;/a&gt;）。这是&amp;ldquo;丢失更新&amp;rdquo;问题的一种变体，如果多个客户端尝试为目标资源创建初始表示，则可能会出现此问题。接收到If-None-Match标头字段的原始服务器务必在执行该方法之前评估条件（&lt;a href=&quot;#section-5&quot;&gt;第5节&lt;/a&gt;）。如果字段值为&amp;ldquo; *&amp;rdquo;，则当源服务器具有目标资源的当前表示形式时，条件为false。如果该字段值是实体标签列表，则如果列出的标签之一与所选表示形式的实体标签匹配，则条件为false。如果条件评估为假，则原始服务器不得执行请求的方法；相反，如果请求方法是GET或HEAD，则原始服务器必须使用以下两种方式之一响应：a）304（未修改）状态码，或b）所有其他请求方法的412（前提条件失败）状态码。&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.3.2&quot;&gt;[RFC7234]的第4.3.2节&lt;/a&gt;定义了对接收的If-None-Match标头字段的缓存处理的要求。</target>
        </trans-unit>
        <trans-unit id="a9010727bf44de6e918d999396395dcc003b1b98" translate="yes" xml:space="preserve">
          <source>The &quot;If-Range&quot; header field provides a special conditional request
   mechanism that is similar to the If-Match and If-Unmodified-Since
   header fields but that instructs the recipient to ignore the Range
   header field if the validator doesn't match, resulting in transfer of
   the new selected representation instead of a 412 (Precondition
   Failed) response.  If-Range is defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-3.2&quot;&gt;Section&amp;nbsp;3.2 of [RFC7233]&lt;/a&gt;.</source>
          <target state="translated">&amp;ldquo; If-Range&amp;rdquo;头字段提供了一种特殊的条件请求机制，该机制类似于If-Match和If-Unmodified-Since头字段，但指示接收者在验证器不匹配的情况下忽略Range头字段，结果传输新的所选表示形式而不是412（前提失败）响应。 If-Range在&lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-3.2&quot;&gt;[RFC7233]的3.2节中&lt;/a&gt;定义。</target>
        </trans-unit>
        <trans-unit id="8425f95c9971ed97dd968bffd651d8482f2d923d" translate="yes" xml:space="preserve">
          <source>The &quot;If-Unmodified-Since&quot; header field makes the request method
   conditional on the selected representation's last modification date
   being earlier than or equal to the date provided in the field-value.
   This field accomplishes the same purpose as If-Match for cases where
   the user agent does not have an entity-tag for the representation.

     If-Unmodified-Since = HTTP-date

   An example of the field is:

     If-Unmodified-Since: Sat, 29 Oct 1994 19:43:31 GMT

   A recipient MUST ignore If-Unmodified-Since if the request contains
   an If-Match header field; the condition in If-Match is considered to
   be a more accurate replacement for the condition in
   If-Unmodified-Since, and the two are only combined for the sake of
   interoperating with older intermediaries that might not implement
   If-Match.

   A recipient MUST ignore the If-Unmodified-Since header field if the
   received field-value is not a valid HTTP-date.

   A recipient MUST interpret an If-Unmodified-Since field-value's
   timestamp in terms of the origin server's clock. 

   If-Unmodified-Since is most often used with state-changing methods
   (e.g., POST, PUT, DELETE) to prevent accidental overwrites when
   multiple user agents might be acting in parallel on a resource that
   does not supply entity-tags with its representations (i.e., to
   prevent the &quot;lost update&quot; problem).  It can also be used with safe
   methods to abort a request if the selected representation does not
   match one already stored (or partially stored) from a prior request.

   An origin server that receives an If-Unmodified-Since header field
   MUST evaluate the condition prior to performing the method
   (&lt;a href=&quot;#section-5&quot;&gt;Section 5&lt;/a&gt;).  The origin server MUST NOT perform the requested method
   if the selected representation's last modification date is more
   recent than the date provided in the field-value; instead the origin
   server MUST respond with either a) the 412 (Precondition Failed)
   status code or b) one of the 2xx (Successful) status codes if the
   origin server has verified that a state change is being requested and
   the final state is already reflected in the current state of the
   target resource (i.e., the change requested by the user agent has
   already succeeded, but the user agent might not be aware of that
   because the prior response message was lost or a compatible change
   was made by some other user agent).  In the latter case, the origin
   server MUST NOT send a validator header field in the response unless
   it can verify that the request is a duplicate of an immediately prior
   change made by the same user agent.

   The If-Unmodified-Since header field can be ignored by caches and
   intermediaries because it is not applicable to a stored response.</source>
          <target state="translated">&amp;ldquo; If-Unmodified-Since&amp;rdquo;标头字段使请求方法以所选表示形式的最后修改日期早于或等于字段值中提供的日期为条件。对于用户代理没有用于表示的实体标签的情况，此字段实现与If-Match相同的目的。 If-Unmodified-Since = HTTP-date字段的示例是：If-Unmodified-Since：Sat，29 Oct 1994 19:43:31 GMT如果请求包含If-Match，则收件人必须忽略If-Unmodified-Since。标头字段； If-Match中的条件被认为是If-Unmodified-Since中条件的更准确替代，并且仅将两者结合是为了与可能未实现If-Match的较旧中介进行互操作。如果接收到的字段值不是有效的HTTP日期，则接收者必须忽略If-Unmodified-Since标头字段。接收者必须根据源服务器的时钟解释If-Unmodified-Since字段值的时间戳。 If-Unmodified-Since最常与状态更改方法（例如POST，PUT，DELETE）一起使用，以防止当多个用户代理可能并行处理不提供其表示形式的实体标签的资源时发生意外覆盖（即，以防止&amp;ldquo;丢失更新&amp;rdquo;问题）。如果选定的表示与先前请求中已经存储（或部分存储）的表示不匹配，它也可以与安全方法一起使用来中止请求。收到If-Unmodified-Since头字段的原始服务器务必在执行该方法之前评估条件（&lt;a href=&quot;#section-5&quot;&gt;第5节&lt;/a&gt;）。如果所选表示的最后修改日期比字段值中提供的日期更新，则原始服务器不得执行请求的方法。相反，如果原始服务器已验证请求了状态更改并且已经反映了最终状态，则原始服务器必须使用以下两种方式之一响应：a）412（失败的前提条件）状态代码或b）2xx（成功）状态代码之一。在目标资源的当前状态下（即，用户代理请求的更改已经成功，但是用户代理可能不知道这是因为先前的响应消息丢失了，或者其他一些用户代理进行了兼容的更改） ）。在后一种情况下，原始服务器不得在响应中发送验证者头字段，除非它可以验证请求是否与同一用户代理所做的前一次更改重复。高速缓存和中介可以忽略If-Unmodified-Since标头字段，因为它不适用于存储的响应。</target>
        </trans-unit>
        <trans-unit id="3bcbe36b4b07ea53d8dfd522bedc5b18d8069ffd" translate="yes" xml:space="preserve">
          <source>The &quot;Last-Modified&quot; header field in a response provides a timestamp
   indicating the date and time at which the origin server believes the
   selected representation was last modified, as determined at the
   conclusion of handling the request.

     Last-Modified = HTTP-date

   An example of its use is

     Last-Modified: Tue, 15 Nov 1994 12:45:26 GMT</source>
          <target state="translated">响应中的 &quot;Last-Modified &quot;头字段提供了一个时间戳,表示起源服务器认为所选表示最后被修改的日期和时间,这是在处理请求的结论中确定的。Last-Modified=HTTP-date 一个使用它的例子是Last-Modified。Tue,15 Nov 1994 12:45:26 GMT。</target>
        </trans-unit>
        <trans-unit id="a6eb1d27a3336049ef780463edbd186c94593ceb" translate="yes" xml:space="preserve">
          <source>The &quot;Location&quot; header field is used in some responses to refer to a
   specific resource in relation to the response.  The type of
   relationship is defined by the combination of request method and
   status code semantics.

     Location = URI-reference

   The field value consists of a single URI-reference.  When it has the
   form of a relative reference (&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-4.2&quot;&gt;[RFC3986], Section&amp;nbsp;4.2&lt;/a&gt;), the final
   value is computed by resolving it against the effective request URI
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-5&quot;&gt;[RFC3986], Section&amp;nbsp;5&lt;/a&gt;).

   For 201 (Created) responses, the Location value refers to the primary
   resource created by the request.  For 3xx (Redirection) responses,
   the Location value refers to the preferred target resource for
   automatically redirecting the request.

   If the Location value provided in a 3xx (Redirection) response does
   not have a fragment component, a user agent MUST process the
   redirection as if the value inherits the fragment component of the
   URI reference used to generate the request target (i.e., the
   redirection inherits the original reference's fragment, if any).

   For example, a GET request generated for the URI reference
   &quot;http://www.example.org/~tim&quot; might result in a 303 (See Other)
   response containing the header field:

     Location: /People.html#tim

   which suggests that the user agent redirect to
   &quot;http://www.example.org/People.html#tim&quot; 

   Likewise, a GET request generated for the URI reference
   &quot;http://www.example.org/index.html#larry&quot; might result in a 301
   (Moved Permanently) response containing the header field:

     Location: http://www.example.net/index.html

   which suggests that the user agent redirect to
   &quot;http://www.example.net/index.html#larry&quot;, preserving the original
   fragment identifier.

   There are circumstances in which a fragment identifier in a Location
   value would not be appropriate.  For example, the Location header
   field in a 201 (Created) response is supposed to provide a URI that
   is specific to the created resource.

      Note: Some recipients attempt to recover from Location fields that
      are not valid URI references.  This specification does not mandate
      or define such processing, but does allow it for the sake of
      robustness.

      Note: The Content-Location header field (&lt;a href=&quot;#section-3.1.4.2&quot;&gt;Section 3.1.4.2&lt;/a&gt;) differs
      from Location in that the Content-Location refers to the most
      specific resource corresponding to the enclosed representation.
      It is therefore possible for a response to contain both the
      Location and Content-Location header fields.</source>
          <target state="translated">在某些响应中，&amp;ldquo;位置&amp;rdquo;标头字段用于引用与响应有关的特定资源。关系的类型由请求方法和状态代码语义的组合定义。位置= URI引用字段值由单个URI引用组成。当它具有相对引用的形式（&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-4.2&quot;&gt;[RFC3986]，第4.2节&lt;/a&gt;）时，通过将其与有效请求URI进行解析来计算最终值（&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-5&quot;&gt;[RFC3986]，第5节）&lt;/a&gt;）。对于201（已创建）响应，位置值是指请求创建的主要资源。对于3xx（重定向）响应，&amp;ldquo;位置&amp;rdquo;值是指用于自动重定向请求的首选目标资源。如果在3xx（重定向）响应中提供的Location值不包含片段组件，则用户代理必须处理重定向，就好像该值继承了用于生成请求目标的URI参考的片段组件一样（即，重定向继承原始参考文献的片段（如果有）。例如，为URI引用&amp;ldquo; http://www.example.org/~tim&amp;rdquo;生成的GET请求可能会导致303（请参见其他）响应包含标头字段：Location：/ People。html＃tim，建议用户代理重定向到&amp;ldquo; http://www.example.org/People.html#tim&amp;rdquo;。同样，针对URI参考&amp;ldquo; http://www.example.org/index&amp;rdquo;生成的GET请求&amp;ldquo; .html＃larry&amp;rdquo;可能会导致包含标题字段的301（永久移动）响应：位置：http：//www.example.net/index.html，建议用户代理重定向到&amp;ldquo; http：// www。 example.net/index.html#larry&amp;rdquo;，保留原始片段标识符。在某些情况下，位置值中的片段标识符不合适。例如，假定201（已创建）响应中的Location头字段提供特定于所创建资源的URI。注意：一些收件人尝试从无效的URI引用的&amp;ldquo;位置&amp;rdquo;字段中恢复。该规范没有规定或定义这种处理，但是出于鲁棒性的考虑而允许进行这种处理。注意：Content-Location标头字段（&lt;a href=&quot;#section-3.1.4.2&quot;&gt;第3.1.4.2节&lt;/a&gt;）与位置的不同之处在于，内容位置是指与封闭表示相对应的最具体的资源。因此，响应可能同时包含Location和Content-Location标头字段。</target>
        </trans-unit>
        <trans-unit id="74bdc0b34c81dec67352f90c99efe73d9563e534" translate="yes" xml:space="preserve">
          <source>The &quot;Max-Forwards&quot; header field provides a mechanism with the TRACE
   (&lt;a href=&quot;#section-4.3.8&quot;&gt;Section 4.3.8&lt;/a&gt;) and OPTIONS (&lt;a href=&quot;#section-4.3.7&quot;&gt;Section 4.3.7&lt;/a&gt;) request methods to limit
   the number of times that the request is forwarded by proxies.  This
   can be useful when the client is attempting to trace a request that
   appears to be failing or looping mid-chain.

     Max-Forwards = 1*DIGIT

   The Max-Forwards value is a decimal integer indicating the remaining
   number of times this request message can be forwarded.

   Each intermediary that receives a TRACE or OPTIONS request containing
   a Max-Forwards header field MUST check and update its value prior to
   forwarding the request.  If the received value is zero (0), the
   intermediary MUST NOT forward the request; instead, the intermediary
   MUST respond as the final recipient.  If the received Max-Forwards
   value is greater than zero, the intermediary MUST generate an updated
   Max-Forwards field in the forwarded message with a field-value that
   is the lesser of a) the received value decremented by one (1) or b)
   the recipient's maximum supported value for Max-Forwards.

   A recipient MAY ignore a Max-Forwards header field received with any
   other request methods.</source>
          <target state="translated">&amp;ldquo; Max-Forwards&amp;rdquo;标题字段提供了一种具有TRACE（&lt;a href=&quot;#section-4.3.8&quot;&gt;第4.3.8节&lt;/a&gt;）和OPTIONS（&lt;a href=&quot;#section-4.3.7&quot;&gt;第4.3.7 &lt;/a&gt;节）的机制。）请求方法，以限制代理转发请求的次数。当客户端尝试跟踪似乎失败或中链中断的请求时，此功能很有用。 Max-Forwards = 1 * DIGIT Max-Forwards值是一个十进制整数，指示可以转发此请求消息的剩余次数。每个接收到包含Max-Forwards标头字段的TRACE或OPTIONS请求的中介都必须在转发请求之前检查并更新其值。如果接收到的值为零（0），则中介不得转发请求；相反，中介必须作为最终接收者做出响应。如果收到的Max-Forwards值大于零，中介必须在转发的消息中生成一个更新后的Max-Forward字段，其字段值为a）接收值减一（1）或b）收件人对Max-Forwards的最大支持值中的较小者。接收者可以忽略与任何其他请求方法一起接收的Max-Forwards标头字段。</target>
        </trans-unit>
        <trans-unit id="62a3d127d32e2961eab7613512f025a99727d041" translate="yes" xml:space="preserve">
          <source>The &quot;Message Headers&quot; registry has been updated with the following
   permanent registrations:

   +-------------------+----------+----------+-----------------+
   | Header Field Name | Protocol | Status   | Reference       |
   +-------------------+----------+----------+-----------------+
   | Accept            | http     | standard | &lt;a href=&quot;#section-5.3.2&quot;&gt;Section 5.3.2&lt;/a&gt;   |
   | Accept-Charset    | http     | standard | &lt;a href=&quot;#section-5.3.3&quot;&gt;Section 5.3.3&lt;/a&gt;   |
   | Accept-Encoding   | http     | standard | &lt;a href=&quot;#section-5.3.4&quot;&gt;Section 5.3.4&lt;/a&gt;   |
   | Accept-Language   | http     | standard | &lt;a href=&quot;#section-5.3.5&quot;&gt;Section 5.3.5&lt;/a&gt;   |
   | Allow             | http     | standard | &lt;a href=&quot;#section-7.4.1&quot;&gt;Section 7.4.1&lt;/a&gt;   |
   | Content-Encoding  | http     | standard | &lt;a href=&quot;#section-3.1.2.2&quot;&gt;Section 3.1.2.2&lt;/a&gt; |
   | Content-Language  | http     | standard | &lt;a href=&quot;#section-3.1.3.2&quot;&gt;Section 3.1.3.2&lt;/a&gt; |
   | Content-Location  | http     | standard | &lt;a href=&quot;#section-3.1.4.2&quot;&gt;Section 3.1.4.2&lt;/a&gt; |
   | Content-Type      | http     | standard | &lt;a href=&quot;#section-3.1.1.5&quot;&gt;Section 3.1.1.5&lt;/a&gt; |
   | Date              | http     | standard | &lt;a href=&quot;#section-7.1.1.2&quot;&gt;Section 7.1.1.2&lt;/a&gt; |
   | Expect            | http     | standard | &lt;a href=&quot;#section-5.1.1&quot;&gt;Section 5.1.1&lt;/a&gt;   |
   | From              | http     | standard | &lt;a href=&quot;#section-5.5.1&quot;&gt;Section 5.5.1&lt;/a&gt;   |
   | Location          | http     | standard | &lt;a href=&quot;#section-7.1.2&quot;&gt;Section 7.1.2&lt;/a&gt;   |
   | Max-Forwards      | http     | standard | &lt;a href=&quot;#section-5.1.2&quot;&gt;Section 5.1.2&lt;/a&gt;   |
   | MIME-Version      | http     | standard | &lt;a href=&quot;#appendix-A.1&quot;&gt;Appendix A.1&lt;/a&gt;    |
   | Referer           | http     | standard | &lt;a href=&quot;#section-5.5.2&quot;&gt;Section 5.5.2&lt;/a&gt;   |
   | Retry-After       | http     | standard | &lt;a href=&quot;#section-7.1.3&quot;&gt;Section 7.1.3&lt;/a&gt;   |
   | Server            | http     | standard | &lt;a href=&quot;#section-7.4.2&quot;&gt;Section 7.4.2&lt;/a&gt;   |
   | User-Agent        | http     | standard | &lt;a href=&quot;#section-5.5.3&quot;&gt;Section 5.5.3&lt;/a&gt;   |
   | Vary              | http     | standard | &lt;a href=&quot;#section-7.1.4&quot;&gt;Section 7.1.4&lt;/a&gt;   |
   +-------------------+----------+----------+-----------------+

   The change controller for the above registrations is: &quot;IETF
   (iesg@ietf.org) - Internet Engineering Task Force&quot;.</source>
          <target state="translated">&amp;ldquo;消息头&amp;rdquo;注册表已更新，具有以下永久注册：+ ------------------- + ---------- + --- ------- + ----------------- + |标头字段名称|协议|现状参考| + ------------------- + ---------- + ---------- + ------- ---------- + |接受| http |标准| &lt;a href=&quot;#section-5.3.2&quot;&gt;第5.3.2节&lt;/a&gt; | |接受字符集| http |标准| &lt;a href=&quot;#section-5.3.3&quot;&gt;第5.3.3节&lt;/a&gt; | |接受编码| http |标准| &lt;a href=&quot;#section-5.3.4&quot;&gt;第5.3.4节&lt;/a&gt; | |接受语言| http |标准| &lt;a href=&quot;#section-5.3.5&quot;&gt;第5.3.5节&lt;/a&gt; | |允许| http |标准| &lt;a href=&quot;#section-7.4.1&quot;&gt;第7.4.1节&lt;/a&gt; | |内容编码| http |标准| &lt;a href=&quot;#section-3.1.2.2&quot;&gt;第3.1.2.2节&lt;/a&gt;| |内容语言| http |标准| &lt;a href=&quot;#section-3.1.3.2&quot;&gt;第3.1.3.2节&lt;/a&gt; | |内容位置| http |标准| &lt;a href=&quot;#section-3.1.4.2&quot;&gt;第3.1.4.2节&lt;/a&gt; | |内容类型| http |标准| &lt;a href=&quot;#section-3.1.1.5&quot;&gt;第3.1.1.5节&lt;/a&gt; | |日期| http |标准| &lt;a href=&quot;#section-7.1.1.2&quot;&gt;第7.1.1.2节&lt;/a&gt; | |期待| http |标准| &lt;a href=&quot;#section-5.1.1&quot;&gt;第5.1.1节&lt;/a&gt; | |来自| http |标准| &lt;a href=&quot;#section-5.5.1&quot;&gt;第5.5.1节&lt;/a&gt; | |位置| http |标准| &lt;a href=&quot;#section-7.1.2&quot;&gt;第7.1.2节&lt;/a&gt; | | Max-Forwards | http |标准| &lt;a href=&quot;#section-5.1.2&quot;&gt;第5.1.2节&lt;/a&gt; | | MIME版本| http |标准| &lt;a href=&quot;#appendix-A.1&quot;&gt;附录A.1&lt;/a&gt; | |推荐人| http |标准| &lt;a href=&quot;#section-5.5.2&quot;&gt;第5.5.2节&lt;/a&gt; | |重试后| http |标准| &lt;a href=&quot;#section-7.1.3&quot;&gt;第7.1.3节&lt;/a&gt; | |服务器| http |标准| &lt;a href=&quot;#section-7.4.2&quot;&gt;第7.4.2节&lt;/a&gt; | |用户代理| http |标准| &lt;a href=&quot;#section-5.5.3&quot;&gt;第5.5.3节&lt;/a&gt; | |变化| http |标准| &lt;a href=&quot;#section-7.1.4&quot;&gt;第7.1.4节&lt;/a&gt; | + ------------------- + ---------- + ---------- + ------- ---------- +上述注册的更改控制者是：&amp;ldquo; IETF（iesg@ietf.org）-Internet工程任务组&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="17017ddede4b2983af658e0ef12536aeaa0acb5a" translate="yes" xml:space="preserve">
          <source>The &quot;Pragma&quot; header field allows backwards compatibility with
   HTTP/1.0 caches, so that clients can specify a &quot;no-cache&quot; request
   that they will understand (as Cache-Control was not defined until
   HTTP/1.1).  When the Cache-Control header field is also present and
   understood in a request, Pragma is ignored.

   In HTTP/1.0, Pragma was defined as an extensible field for
   implementation-specified directives for recipients.  This
   specification deprecates such extensions to improve interoperability.

     Pragma           = 1#pragma-directive
     pragma-directive = &quot;no-cache&quot; / extension-pragma
     extension-pragma = token [ &quot;=&quot; ( token / quoted-string ) ]

   When the Cache-Control header field is not present in a request,
   caches MUST consider the no-cache request pragma-directive as having
   the same effect as if &quot;Cache-Control: no-cache&quot; were present (see
   &lt;a href=&quot;#section-5.2.1&quot;&gt;Section 5.2.1&lt;/a&gt;).

   When sending a no-cache request, a client ought to include both the
   pragma and cache-control directives, unless Cache-Control: no-cache
   is purposefully omitted to target other Cache-Control response
   directives at HTTP/1.1 caches.  For example:

     GET / HTTP/1.1
     Host: www.example.com
     Cache-Control: max-age=30
     Pragma: no-cache

   will constrain HTTP/1.1 caches to serve a response no older than 30
   seconds, while precluding implementations that do not understand
   Cache-Control from serving a cached response.

      Note: Because the meaning of &quot;Pragma: no-cache&quot; in responses is
      not specified, it does not provide a reliable replacement for
      &quot;Cache-Control: no-cache&quot; in them.</source>
          <target state="translated">&amp;ldquo; Pragma&amp;rdquo;标头字段允许与HTTP / 1.0缓存向后兼容，以便客户端可以指定他们将理解的&amp;ldquo; no-cache&amp;rdquo;请求（因为直到HTTP / 1.1才定义了Cache-Control）。当请求中也存在并理解了Cache-Control标头字段时，将忽略Pragma。在HTTP / 1.0中，将Pragma定义为收件人特定于实现的指令的可扩展字段。本规范不赞成使用此类扩展来提高互操作性。 Pragma = 1＃pragma指令pragma指令=&amp;ldquo; no-cache&amp;rdquo; / extension-pragma extension-pragma = token [&amp;ldquo; =&amp;rdquo;（token / quoted-string）]当请求中不存在Cache-Control标头字段时，缓存必须认为无缓存请求的pragma-directive具有与出现&amp;ldquo; Cache-Control：no-cache&amp;rdquo;相同的效果（请参阅 &lt;a href=&quot;#section-5.2.1&quot;&gt;第5.2.1节&lt;/a&gt;）。发送无缓存请求时，客户端应同时包含编译指示和缓存控制指令，除非有意省略Cache-Control：no-cache以将其他缓存控制响应指令定向到HTTP / 1.1缓存。例如：GET / HTTP / 1.1主机：www.example.com缓存控制：max-age = 30语法：无缓存将限制HTTP / 1.1缓存提供不超过30秒的响应，同时排除执行该操作的实现无法从提供缓存的响应中了解Cache-Control。注意：由于未指定响应中&amp;ldquo; Pragma：no-cache&amp;rdquo;的含义，因此不能在其中可靠地替代&amp;ldquo; Cache-Control：no-cache&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="056fcf2a31c44d11769adceb052cd538bdba3b52" translate="yes" xml:space="preserve">
          <source>The &quot;Proxy-Authenticate&quot; header field consists of at least one
   challenge that indicates the authentication scheme(s) and parameters
   applicable to the proxy for this effective request URI (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.5&quot;&gt;Section&amp;nbsp;5.5
   of [RFC7230]&lt;/a&gt;).  A proxy MUST send at least one Proxy-Authenticate
   header field in each 407 (Proxy Authentication Required) response
   that it generates.

     Proxy-Authenticate = 1#challenge

   Unlike WWW-Authenticate, the Proxy-Authenticate header field applies
   only to the next outbound client on the response chain.  This is
   because only the client that chose a given proxy is likely to have
   the credentials necessary for authentication.  However, when multiple
   proxies are used within the same administrative domain, such as
   office and regional caching proxies within a large corporate network,
   it is common for credentials to be generated by the user agent and
   passed through the hierarchy until consumed.  Hence, in such a
   configuration, it will appear as if Proxy-Authenticate is being
   forwarded because each proxy will send the same challenge set.

   Note that the parsing considerations for WWW-Authenticate apply to
   this header field as well; see &lt;a href=&quot;#section-4.1&quot;&gt;Section 4.1&lt;/a&gt; for details.</source>
          <target state="translated">&amp;ldquo; Proxy-Authenticate&amp;rdquo;标头字段包含至少一个挑战，该挑战指示适用于此有效请求URI的代理的身份验证方案和参数（&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.5&quot;&gt;[RFC7230] 5.5节）&lt;/a&gt;）。代理必须在其生成的每个407（必需的代理身份验证）响应中至少发送一个Proxy-Authenticate标头字段。 Proxy-Authenticate = 1＃挑战与WWW-Authenticate不同，Proxy-Authenticate标头字段仅适用于响应链上的下一个出站客户端。这是因为只有选择给定代理的客户端才可能具有身份验证所需的凭据。但是，当在同一管理域中使用多个代理（例如大型公司网络中的办公室和区域缓存代理）时，凭据通常由用户代理生成并通过层次结构传递，直到被使用为止。因此，在这种配置下，由于每个代理将发送相同的质询集，因此它看起来好像在转发&amp;ldquo;代理身份验证&amp;rdquo;。注意，WWW-Authenticate的解析注意事项也适用于此标头字段。看到&lt;a href=&quot;#section-4.1&quot;&gt;&lt;/a&gt;详细信息请参见第4.1节。</target>
        </trans-unit>
        <trans-unit id="4e55a01408a5bfa971888b6023693ae2d37ad3ee" translate="yes" xml:space="preserve">
          <source>The &quot;Proxy-Authorization&quot; header field allows the client to identify
   itself (or its user) to a proxy that requires authentication.  Its
   value consists of credentials containing the authentication
   information of the client for the proxy and/or realm of the resource
   being requested.

     Proxy-Authorization = credentials

   Unlike Authorization, the Proxy-Authorization header field applies
   only to the next inbound proxy that demanded authentication using the
   Proxy-Authenticate field.  When multiple proxies are used in a chain,
   the Proxy-Authorization header field is consumed by the first inbound
   proxy that was expecting to receive credentials.  A proxy MAY relay
   the credentials from the client request to the next proxy if that is
   the mechanism by which the proxies cooperatively authenticate a given
   request.</source>
          <target state="translated">&quot;Proxy-Authorization &quot;头字段允许客户端向需要认证的代理标识自己(或其用户)。它的值由包含客户端对所请求资源的代理和/或领域的认证信息的凭证组成。Proxy-Authorization=credentials 与Authorization不同,Proxy-Authorization头字段只适用于下一个使用Proxy-Authenticate字段要求认证的入站代理。当在一个链中使用多个代理时,Proxy-Authorization头字段会被第一个期望接收凭证的入站代理消耗。如果代理合作认证一个给定的请求,代理可以将客户端请求的凭证转发到下一个代理。</target>
        </trans-unit>
        <trans-unit id="b718f4bbb4edbfe4ac380e46d4526fcfa5c21c8b" translate="yes" xml:space="preserve">
          <source>The &quot;Range&quot; header field on a GET request modifies the method
   semantics to request transfer of only one or more subranges of the
   selected representation data, rather than the entire selected
   representation data.

     Range = byte-ranges-specifier / other-ranges-specifier
     other-ranges-specifier = other-range-unit &quot;=&quot; other-range-set
     other-range-set = 1*VCHAR

   A server MAY ignore the Range header field.  However, origin servers
   and intermediate caches ought to support byte ranges when possible,
   since Range supports efficient recovery from partially failed
   transfers and partial retrieval of large representations.  A server
   MUST ignore a Range header field received with a request method other
   than GET.

   An origin server MUST ignore a Range header field that contains a
   range unit it does not understand.  A proxy MAY discard a Range
   header field that contains a range unit it does not understand.

   A server that supports range requests MAY ignore or reject a Range
   header field that consists of more than two overlapping ranges, or a
   set of many small ranges that are not listed in ascending order,
   since both are indications of either a broken client or a deliberate
   denial-of-service attack (&lt;a href=&quot;#section-6.1&quot;&gt;Section 6.1&lt;/a&gt;).  A client SHOULD NOT request
   multiple ranges that are inherently less efficient to process and
   transfer than a single range that encompasses the same data.

   A client that is requesting multiple ranges SHOULD list those ranges
   in ascending order (the order in which they would typically be
   received in a complete representation) unless there is a specific
   need to request a later part earlier.  For example, a user agent
   processing a large representation with an internal catalog of parts
   might need to request later parts first, particularly if the
   representation consists of pages stored in reverse order and the user
   agent wishes to transfer one page at a time.

   The Range header field is evaluated after evaluating the precondition
   header fields defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC7232&lt;/a&gt;], and only if the result in absence
   of the Range header field would be a 200 (OK) response.  In other
   words, Range is ignored when a conditional GET would result in a 304
   (Not Modified) response. 

   The If-Range header field (&lt;a href=&quot;#section-3.2&quot;&gt;Section 3.2&lt;/a&gt;) can be used as a precondition
   to applying the Range header field.

   If all of the preconditions are true, the server supports the Range
   header field for the target resource, and the specified range(s) are
   valid and satisfiable (as defined in &lt;a href=&quot;#section-2.1&quot;&gt;Section 2.1&lt;/a&gt;), the server SHOULD
   send a 206 (Partial Content) response with a payload containing one
   or more partial representations that correspond to the satisfiable
   ranges requested, as defined in &lt;a href=&quot;#section-4&quot;&gt;Section 4&lt;/a&gt;.

   If all of the preconditions are true, the server supports the Range
   header field for the target resource, and the specified range(s) are
   invalid or unsatisfiable, the server SHOULD send a 416 (Range Not
   Satisfiable) response.</source>
          <target state="translated">GET请求上的&amp;ldquo; Range&amp;rdquo;标头字段修改了方法语义，以请求仅传输所选表示形式数据的一个或多个子范围，而不是整个所选表示形式数据的传输。范围=字节范围说明符/其他范围说明符其他范围说明符=其他范围单位&amp;ldquo; =&amp;rdquo;其他范围设置其他范围设置= 1 * VCHAR服务器可以忽略范围标头字段。但是，原始服务器和中间缓存应尽可能支持字节范围，因为Range支持从部分失败的传输和大表示的部分检索中进行有效恢复。服务器必须忽略通过GET以外的请求方法收到的Range标头字段。源服务器必须忽略包含其不理解的范围单位的Range标头字段。代理可以丢弃包含它不理解的范围单位的Range标头字段。支持范围请求的服务器可以忽略或拒绝包含两个以上重叠范围或未按升序列出的许多小范围的集合的Range头字段，因为这两者都表明客户端已损坏或故意拒绝服务攻击 （因为两者都表明客户端已损坏或蓄意拒绝服务攻击（因为两者都表明客户端已损坏或蓄意拒绝服务攻击（&lt;a href=&quot;#section-6.1&quot;&gt;第6.1节&lt;/a&gt;）。客户端不应请求多个范围，这些范围本质上比包含相同数据的单个范围在处理和传输方面效率较低。请求多个范围的客户端应该以升序（通常以完整表示形式接收它们的顺序）列出这些范围，除非特别需要更早地请求后续部分。例如，处理具有内部零件目录的大型表示的用户代理可能需要首先请求以后的部分，特别是如果表示由以相反顺序存储的页面组成并且用户代理希望一次转移一个页面时。在评估[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC7232]中&lt;/a&gt;定义的前提条件标头字段之后，评估范围标头字段]，并且仅当缺少Range标头字段的结果为200（OK）响应时。换句话说，当条件GET产生304（未修改）响应时，将忽略Range。 If-Range标头字段（&lt;a href=&quot;#section-3.2&quot;&gt;第3.2节&lt;/a&gt;）可以用作应用Range标头字段的前提。如果所有前提条件都为真，则服务器支持目标资源的Range标头字段，并且指定的范围有效且可满足要求（如&lt;a href=&quot;#section-2.1&quot;&gt;第2.1节中&lt;/a&gt;所定义），服务器应发送206（部分内容）响应有效负载包含&lt;a href=&quot;#section-4&quot;&gt;第4节中&lt;/a&gt;定义的对应于请求的可满足范围的一个或多个局部表示。如果所有先决条件都为真，则服务器支持目标资源的Range标头字段，并且指定的范围无效或不满足，服务器应发送416（Range Not Satisfiable）响应。</target>
        </trans-unit>
        <trans-unit id="1a6f10ce133a2f9215112587238b74cbf177295e" translate="yes" xml:space="preserve">
          <source>The &quot;Referer&quot; [sic] header field allows the user agent to specify a
   URI reference for the resource from which the target URI was obtained
   (i.e., the &quot;referrer&quot;, though the field name is misspelled).  A user
   agent MUST NOT include the fragment and userinfo components of the
   URI reference [&lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt;], if any, when generating the Referer field
   value.

     Referer = absolute-URI / partial-URI

   The Referer header field allows servers to generate back-links to
   other resources for simple analytics, logging, optimized caching,
   etc.  It also allows obsolete or mistyped links to be found for
   maintenance.  Some servers use the Referer header field as a means of
   denying links from other sites (so-called &quot;deep linking&quot;) or
   restricting cross-site request forgery (CSRF), but not all requests
   contain it.

   Example:

     Referer: http://www.example.org/hypertext/Overview.html

   If the target URI was obtained from a source that does not have its
   own URI (e.g., input from the user keyboard, or an entry within the
   user's bookmarks/favorites), the user agent MUST either exclude the
   Referer field or send it with a value of &quot;about:blank&quot;.

   The Referer field has the potential to reveal information about the
   request context or browsing history of the user, which is a privacy
   concern if the referring resource's identifier reveals personal
   information (such as an account name) or a resource that is supposed
   to be confidential (such as behind a firewall or internal to a
   secured service).  Most general-purpose user agents do not send the
   Referer header field when the referring resource is a local &quot;file&quot; or
   &quot;data&quot; URI.  A user agent MUST NOT send a Referer header field in an
   unsecured HTTP request if the referring page was received with a
   secure protocol.  See &lt;a href=&quot;#section-9.4&quot;&gt;Section 9.4&lt;/a&gt; for additional security
   considerations. 

   Some intermediaries have been known to indiscriminately remove
   Referer header fields from outgoing requests.  This has the
   unfortunate side effect of interfering with protection against CSRF
   attacks, which can be far more harmful to their users.
   Intermediaries and user agent extensions that wish to limit
   information disclosure in Referer ought to restrict their changes to
   specific edits, such as replacing internal domain names with
   pseudonyms or truncating the query and/or path components.  An
   intermediary SHOULD NOT modify or delete the Referer header field
   when the field value shares the same scheme and host as the request
   target.</source>
          <target state="translated">&amp;ldquo; Referer&amp;rdquo; [sic]标头字段允许用户代理为从中获取目标URI的资源指定URI引用（即&amp;ldquo;引荐来源网址&amp;rdquo;，尽管字段名称拼写错误）。用户代理&lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;不得&lt;/a&gt;包含URI参考[ RFC3986]（如果有），则在生成Referer字段值时。 Referer =绝对URI /部分URI Referer头字段允许服务器生成指向其他资源的反向链接，以进行简单分析，日志记录，优化的缓存等。它还允许查找过时或类型错误的链接以进行维护。某些服务器使用Referer标头字段作为拒绝来自其他站点的链接（所谓的&amp;ldquo;深层链接&amp;rdquo;）或限制跨站点请求伪造（CSRF）的一种方法，但并非所有请求都包含该伪造。示例：引荐来源网址：http://www.example.org/hypertext/Overview.html如果目标URI是从没有自己的URI的源中获得的（例如，从用户键盘输入的内容，或者是用户输入的内容）书签/收藏夹），用户代理必须排除&amp;ldquo;引荐来源&amp;rdquo;字段或将其发送为&amp;ldquo; about：blank&amp;rdquo;。 Referer字段具有揭示有关用户请求上下文或浏览历史的信息的潜力，如果引用资源的标识符泄露了个人信息（例如帐户名）或被认为是机密的资源（例如，例如防火墙后面或安全服务内部）。当引用资源是本地&amp;ldquo;文件&amp;rdquo;或&amp;ldquo;数据&amp;rdquo; URI时，大多数通用用户代理不会发送&amp;ldquo;引用&amp;rdquo;标头字段。如果使用安全协议接收了引荐页，则用户代理不得在不安全的HTTP请求中发送引荐标头字段。看到Referer字段具有揭示有关用户请求上下文或浏览历史记录的信息的潜力，如果引用资源的标识符泄露了个人信息（例如帐户名）或被认为是机密的资源（例如，例如防火墙后面或安全服务内部）。当引荐资源是本地&amp;ldquo;文件&amp;rdquo;或&amp;ldquo;数据&amp;rdquo; URI时，大多数通用用户代理都不发送引荐标头字段。如果使用安全协议接收了引荐页，则用户代理不得在不安全的HTTP请求中发送引荐标头字段。看到Referer字段具有揭示有关用户请求上下文或浏览历史记录的信息的潜力，如果引用资源的标识符泄露了个人信息（例如帐户名）或被认为是机密的资源（例如，例如防火墙后面或安全服务内部）。当引荐资源是本地&amp;ldquo;文件&amp;rdquo;或&amp;ldquo;数据&amp;rdquo; URI时，大多数通用用户代理都不发送引荐标头字段。如果使用安全协议接收了引荐页，则用户代理不得在不安全的HTTP请求中发送引荐标头字段。看到的标识符显示个人信息（例如帐户名）或应该被视为机密的资源（例如在防火墙后面或受保护的服务内部）。当引荐资源是本地&amp;ldquo;文件&amp;rdquo;或&amp;ldquo;数据&amp;rdquo; URI时，大多数通用用户代理都不发送引荐标头字段。如果使用安全协议接收了引荐页，则用户代理不得在不安全的HTTP请求中发送引荐标头字段。看到的标识符显示个人信息（例如帐户名）或应该被视为机密的资源（例如在防火墙后面或受保护的服务内部）。当引荐资源是本地&amp;ldquo;文件&amp;rdquo;或&amp;ldquo;数据&amp;rdquo; URI时，大多数通用用户代理都不发送引荐标头字段。如果使用安全协议接收了引荐页，则用户代理不得在不安全的HTTP请求中发送引荐标头字段。看到如果使用安全协议接收了引荐页，则用户代理不得在不安全的HTTP请求中发送引荐标头字段。看到如果使用安全协议接收了引荐页，则用户代理不得在不安全的HTTP请求中发送引荐标头字段。看到&lt;a href=&quot;#section-9.4&quot;&gt;&lt;/a&gt;有关其他安全注意事项的第9.4节。已知某些中介会从传出的请求中不加选择地删除Referer标头字段。不幸的是，这种干扰干扰了针对CSRF攻击的保护，这可能对其用户造成更大的危害。希望限制Referer中信息公开的中介程序和用户代理扩展应将其更改限制为特定的编辑，例如用化名替换内部域名或截断查询和/或路径组件。当字段值与请求目标共享相同的方案和主机时，中间人不应修改或删除Referer标头字段。</target>
        </trans-unit>
        <trans-unit id="d19493afa0fd7d7d38b18500fe6b7e410894e8e6" translate="yes" xml:space="preserve">
          <source>The &quot;Server&quot; header field contains information about the software
   used by the origin server to handle the request, which is often used
   by clients to help identify the scope of reported interoperability
   problems, to work around or tailor requests to avoid particular
   server limitations, and for analytics regarding server or operating
   system use.  An origin server MAY generate a Server field in its
   responses.

     Server = product *( RWS ( product / comment ) )

   The Server field-value consists of one or more product identifiers,
   each followed by zero or more comments (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;Section&amp;nbsp;3.2 of [RFC7230]&lt;/a&gt;),
   which together identify the origin server software and its
   significant subproducts.  By convention, the product identifiers are
   listed in decreasing order of their significance for identifying the
   origin server software.  Each product identifier consists of a name
   and optional version, as defined in &lt;a href=&quot;#section-5.5.3&quot;&gt;Section 5.5.3&lt;/a&gt;.

   Example:

     Server: CERN/3.0 libwww/2.17

   An origin server SHOULD NOT generate a Server field containing
   needlessly fine-grained detail and SHOULD limit the addition of
   subproducts by third parties.  Overly long and detailed Server field
   values increase response latency and potentially reveal internal
   implementation details that might make it (slightly) easier for
   attackers to find and exploit known security holes.</source>
          <target state="translated">&amp;ldquo;服务器&amp;rdquo;标头字段包含有关原始服务器用于处理请求的软件的信息，客户端通常使用该信息来帮助识别报告的互操作性问题的范围，解决或调整请求以避免特定的服务器限制，以及有关服务器或操作系统使用情况的分析。原始服务器可以在其响应中生成一个服务器字段。服务器=产品*（RWS（产品/注释））服务器字段值由一个或多个产品标识符组成，每个标识符后跟零个或多个注释（&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;[RFC7230]第3.2节&lt;/a&gt;），一起确定原始服务器软件及其重要的子产品。按照惯例，产品标识符以其重要性的降序排列，以标识原始服务器软件。每个产品标识符都包含一个名称和可选版本，如&lt;a href=&quot;#section-5.5.3&quot;&gt;第5.5.3节中&lt;/a&gt;所定义。示例：服务器：CERN / 3.0 libwww / 2.17原始服务器不应生成包含不必要的细粒度细节的服务器字段，并且应限制第三方添加子产品。太长且过于详细的&amp;ldquo;服务器&amp;rdquo;字段值会增加响应延迟，并可能揭示内部实施细节，这可能使攻击者（略）容易地发现并利用已知的安全漏洞。</target>
        </trans-unit>
        <trans-unit id="bf7a34c8bf8ec710d19c3accad390aa1affece68" translate="yes" xml:space="preserve">
          <source>The &quot;TE&quot; header field in a request indicates what transfer codings,
   besides chunked, the client is willing to accept in response, and
   whether or not the client is willing to accept trailer fields in a
   chunked transfer coding.

   The TE field-value consists of a comma-separated list of transfer
   coding names, each allowing for optional parameters (as described in
   &lt;a href=&quot;#section-4&quot;&gt;Section 4&lt;/a&gt;), and/or the keyword &quot;trailers&quot;.  A client MUST NOT send
   the chunked transfer coding name in TE; chunked is always acceptable
   for HTTP/1.1 recipients.

     TE        = #t-codings
     t-codings = &quot;trailers&quot; / ( transfer-coding [ t-ranking ] )
     t-ranking = OWS &quot;;&quot; OWS &quot;q=&quot; rank
     rank      = ( &quot;0&quot; [ &quot;.&quot; 0*3DIGIT ] )
                / ( &quot;1&quot; [ &quot;.&quot; 0*3(&quot;0&quot;) ] )

   Three examples of TE use are below.

     TE: deflate
     TE:
     TE: trailers, deflate;q=0.5

   The presence of the keyword &quot;trailers&quot; indicates that the client is
   willing to accept trailer fields in a chunked transfer coding, as
   defined in &lt;a href=&quot;#section-4.1.2&quot;&gt;Section 4.1.2&lt;/a&gt;, on behalf of itself and any downstream
   clients.  For requests from an intermediary, this implies that
   either: (a) all downstream clients are willing to accept trailer
   fields in the forwarded response; or, (b) the intermediary will
   attempt to buffer the response on behalf of downstream recipients.
   Note that HTTP/1.1 does not define any means to limit the size of a
   chunked response such that an intermediary can be assured of
   buffering the entire response.

   When multiple transfer codings are acceptable, the client MAY rank
   the codings by preference using a case-insensitive &quot;q&quot; parameter
   (similar to the qvalues used in content negotiation fields, Section 

   5.3.1 of [&lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt;]).  The rank value is a real number in the range 0
   through 1, where 0.001 is the least preferred and 1 is the most
   preferred; a value of 0 means &quot;not acceptable&quot;.

   If the TE field-value is empty or if no TE field is present, the only
   acceptable transfer coding is chunked.  A message with no transfer
   coding is always acceptable.

   Since the TE header field only applies to the immediate connection, a
   sender of TE MUST also send a &quot;TE&quot; connection option within the
   Connection header field (&lt;a href=&quot;#section-6.1&quot;&gt;Section 6.1&lt;/a&gt;) in order to prevent the TE
   field from being forwarded by intermediaries that do not support its
   semantics.</source>
          <target state="translated">请求中的&amp;ldquo; TE&amp;rdquo;标头字段指示除了分块传输之外，客户端还愿意接受哪些传输编码，以及客户端是否愿意接受分块传输编码中的尾部字段。 TE字段值由逗号分隔的传输编码名称列表组成，每个传输编码名称都允许使用可选参数（如&lt;a href=&quot;#section-4&quot;&gt;第4节&lt;/a&gt;所述） ）和/或关键字&amp;ldquo; trailers&amp;rdquo;。客户端不得在TE中发送分块的传输编码名称； HTTP / 1.1收件人始终可以接受分块。 TE =＃t-codings t-codings =&amp;ldquo; trailers&amp;rdquo; /（传输编码[t-ranking]）t-ranking = OWS&amp;ldquo;;&amp;rdquo; OWS&amp;ldquo; q =&amp;rdquo; rank rank =（&amp;ldquo; 0&amp;rdquo; [&amp;ldquo;。&amp;rdquo; 0 * 3DIGIT]）/（&amp;ldquo; 1&amp;rdquo; [&amp;ldquo;。&amp;rdquo; 0 * 3（&amp;ldquo; 0&amp;rdquo;）]）以下是TE使用的三个示例。 TE：deflate TE：TE：拖车，deflate; q = 0.5关键字&amp;ldquo; trailers&amp;rdquo;的存在表示客户端愿意接受分块传输编码中的拖车字段，如&lt;a href=&quot;#section-4.1.2&quot;&gt;第4.1.2节中&lt;/a&gt;所定义，代表自身和任何下游客户。对于来自中介的请求，这意味着：（a）所有下游客户端都愿意在转发的响应中接受尾部字段； （b）中介机构将尝试代表下游接收方缓冲响应。请注意，HTTP / 1.1并未定义任何手段来限制分块响应的大小，从而可以确保中间人可以缓冲整个响应。当可接受多种传输编码时，客户端可以使用不区分大小写的&amp;ldquo; q&amp;rdquo;参数（与内容协商字段中使用的qvalue相似，[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231的&lt;/a&gt; 5.3.1节]）按优先级对编码进行排序。]）。等级值是介于0到1之间的实数，其中0.001是最不优选的，而1是最优选的；值为0表示&amp;ldquo;不可接受&amp;rdquo;。如果TE字段值为空或不存在TE字段，则仅对可接受的传输编码进行分块。没有传输编码的消息总是可以接受的。由于TE标头字段仅适用于直接连接，因此TE发送方还必须在Connection标头字段（&lt;a href=&quot;#section-6.1&quot;&gt;第6.1节&lt;/a&gt;）中发送&amp;ldquo; TE&amp;rdquo;连接选项，以防止不支持该功能的中介转发TE字段它的语义。</target>
        </trans-unit>
        <trans-unit id="642dca3b33f00cb08595b70f704b7b8a5ca96a77" translate="yes" xml:space="preserve">
          <source>The &quot;Upgrade&quot; header field is intended to provide a simple mechanism
   for transitioning from HTTP/1.1 to some other protocol on the same
   connection.  A client MAY send a list of protocols in the Upgrade
   header field of a request to invite the server to switch to one or
   more of those protocols, in order of descending preference, before
   sending the final response.  A server MAY ignore a received Upgrade
   header field if it wishes to continue using the current protocol on
   that connection.  Upgrade cannot be used to insist on a protocol
   change.

     Upgrade          = 1#protocol

     protocol         = protocol-name [&quot;/&quot; protocol-version]
     protocol-name    = token
     protocol-version = token

   A server that sends a 101 (Switching Protocols) response MUST send an
   Upgrade header field to indicate the new protocol(s) to which the
   connection is being switched; if multiple protocol layers are being
   switched, the sender MUST list the protocols in layer-ascending
   order.  A server MUST NOT switch to a protocol that was not indicated
   by the client in the corresponding request's Upgrade header field.  A 

   server MAY choose to ignore the order of preference indicated by the
   client and select the new protocol(s) based on other factors, such as
   the nature of the request or the current load on the server.

   A server that sends a 426 (Upgrade Required) response MUST send an
   Upgrade header field to indicate the acceptable protocols, in order
   of descending preference.

   A server MAY send an Upgrade header field in any other response to
   advertise that it implements support for upgrading to the listed
   protocols, in order of descending preference, when appropriate for a
   future request.

   The following is a hypothetical example sent by a client:

     GET /hello.txt HTTP/1.1
     Host: www.example.com
     Connection: upgrade
     Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11


   The capabilities and nature of the application-level communication
   after the protocol change is entirely dependent upon the new
   protocol(s) chosen.  However, immediately after sending the 101
   (Switching Protocols) response, the server is expected to continue
   responding to the original request as if it had received its
   equivalent within the new protocol (i.e., the server still has an
   outstanding request to satisfy after the protocol has been changed,
   and is expected to do so without requiring the request to be
   repeated).

   For example, if the Upgrade header field is received in a GET request
   and the server decides to switch protocols, it first responds with a
   101 (Switching Protocols) message in HTTP/1.1 and then immediately
   follows that with the new protocol's equivalent of a response to a
   GET on the target resource.  This allows a connection to be upgraded
   to protocols with the same semantics as HTTP without the latency cost
   of an additional round trip.  A server MUST NOT switch protocols
   unless the received message semantics can be honored by the new
   protocol; an OPTIONS request can be honored by any protocol. 

   The following is an example response to the above hypothetical
   request:

     HTTP/1.1 101 Switching Protocols
     Connection: upgrade
     Upgrade: HTTP/2.0

     [... data stream switches to HTTP/2.0 with an appropriate response
     (as defined by new protocol) to the &quot;GET /hello.txt&quot; request ...]

   When Upgrade is sent, the sender MUST also send a Connection header
   field (&lt;a href=&quot;#section-6.1&quot;&gt;Section 6.1&lt;/a&gt;) that contains an &quot;upgrade&quot; connection option, in
   order to prevent Upgrade from being accidentally forwarded by
   intermediaries that might not implement the listed protocols.  A
   server MUST ignore an Upgrade header field that is received in an
   HTTP/1.0 request.

   A client cannot begin using an upgraded protocol on the connection
   until it has completely sent the request message (i.e., the client
   can't change the protocol it is sending in the middle of a message).
   If a server receives both an Upgrade and an Expect header field with
   the &quot;100-continue&quot; expectation (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-5.1.1&quot;&gt;Section&amp;nbsp;5.1.1 of [RFC7231]&lt;/a&gt;), the
   server MUST send a 100 (Continue) response before sending a 101
   (Switching Protocols) response.

   The Upgrade header field only applies to switching protocols on top
   of the existing connection; it cannot be used to switch the
   underlying connection (transport) protocol, nor to switch the
   existing communication to a different connection.  For those
   purposes, it is more appropriate to use a 3xx (Redirection) response
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6.4&quot;&gt;Section&amp;nbsp;6.4 of [RFC7231]&lt;/a&gt;).

   This specification only defines the protocol name &quot;HTTP&quot; for use by
   the family of Hypertext Transfer Protocols, as defined by the HTTP
   version rules of &lt;a href=&quot;#section-2.6&quot;&gt;Section 2.6&lt;/a&gt; and future updates to this
   specification.  Additional tokens ought to be registered with IANA
   using the registration procedure defined in &lt;a href=&quot;#section-8.6&quot;&gt;Section 8.6&lt;/a&gt;.</source>
          <target state="translated">&amp;ldquo;升级&amp;rdquo;标头字段旨在提供一种简单的机制，用于在同一连接上从HTTP / 1.1过渡到其他协议。客户端可以在请求的&amp;ldquo;升级&amp;rdquo;报头字段中发送协议列表，以邀请服务器在发送最终响应之前，按照优先级从高到低的顺序切换到这些协议中的一个或多个。如果服务器希望继续在该连接上使用当前协议，则可以忽略收到的升级头字段。升级不能用于坚持更改协议。升级= 1＃protocol协议=协议名称[&amp;ldquo; /&amp;rdquo;[协议版本]协议名称=令牌协议版本=令牌发送101（交换协议）响应的服务器必须发送升级报头字段，以指示将连接切换到的新协议。如果要交换多个协议层，则发送方务必按层升序列出协议。服务器不得切换到客户端在相应请求的&amp;ldquo;升级&amp;rdquo;标头字段中未指定的协议。服务器可以选择忽略客户端指示的优先顺序，并基于其他因素（例如请求的性质或服务器上的当前负载）选择新协议。发送426（需要升级）响应的服务器务必发送升级标头字段以指示可接受的协议，按降序排列。服务器可以在任何其他响应中发送一个Upgrade标头字段，以通告它实现了对升级到列出的协议的支持，在适合将来的请求时，按降序排列。以下是客户端发送的假设示例：GET /hello.txt HTTP / 1.1主机：www.example.com连接：升级升级：HTTP / 2.0，SHTTP / 1.3，IRC / 6.9，RTA / x11功能和性质协议更改后的应用程序级通信的完全依赖于所选的新协议。但是，发送完101（交换协议）响应后，服务器应立即继续响应原始请求，就好像它已在新协议中收到了它的等效请求一样（即，更改协议后，服务器仍然有未完成的请求可以满足，并且可以做到而无需重复请求。例如，如果在GET请求中收到了Upgrade标头字段，并且服务器决定切换协议，则服务器首先以HTTP / 1.1的101（切换协议）消息进行响应，然后立即以等效于新协议的响应进行响应到目标资源上的GET。这样就可以将连接升级为具有与HTTP相同语义的协议，而无需花费额外的往返时间。除非接收到的消息语义可以被新协议所接受，否则服务器不得切换协议。 OPTIONS请求可以通过任何协议来接受。以下是对上述假设请求的示例响应：HTTP / 1.1 101交换协议连接：升级升级：HTTP / 2.0 [...数据流切换到HTTP / 2.0，同时具有对新协议定义的适当响应（由新协议定义）。 &amp;ldquo; GET /hello.txt&amp;rdquo;请求...]发送升级消息后，发送方还必须发送一个Connection标头字段（&lt;a href=&quot;#section-6.1&quot;&gt;第6.1节&lt;/a&gt;）包含&amp;ldquo;升级&amp;rdquo;连接选项，以防止可能未实现所列协议的中间人意外转发升级。服务器必须忽略在HTTP / 1.0请求中收到的Upgrade标头字段。直到客户端完全发送了请求消息，客户端才能开始在连接上使用升级的协议（即，客户端无法更改在消息中间发送的协议）。如果服务器同时收到带有&amp;ldquo; 100-continue&amp;rdquo;期望的&amp;ldquo; Upgrade&amp;rdquo;和&amp;ldquo; Expect&amp;rdquo;标头字段（&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-5.1.1&quot;&gt;[RFC7231]的5.1.1节）&lt;/a&gt;），服务器必须先发送100（继续）响应，然后再发送101（交换协议）响应。升级标头字段仅适用于现有连接之上的交换协议。它不能用于切换基础连接（传输）协议，也不能用于将现有通信切换到其他连接。为此，使用3xx（重定向）响应（&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6.4&quot;&gt;[RFC7231]的6.4节&lt;/a&gt;）更为合适。本规范仅定义协议名称&amp;ldquo; HTTP&amp;rdquo;，以供超文本传输​​协议系列使用，如&lt;a href=&quot;#section-2.6&quot;&gt;2.6节&lt;/a&gt;的HTTP版本规则以及对该规范的将来更新所定义。其他令牌应使用定义的注册程序向IANA注册&lt;a href=&quot;#section-8.6&quot;&gt;第8.6节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cca24e17d2817ed4fdcf6d3f466ac894c19b3c68" translate="yes" xml:space="preserve">
          <source>The &quot;User-Agent&quot; header field contains information about the user
   agent originating the request, which is often used by servers to help
   identify the scope of reported interoperability problems, to work
   around or tailor responses to avoid particular user agent
   limitations, and for analytics regarding browser or operating system
   use.  A user agent SHOULD send a User-Agent field in each request
   unless specifically configured not to do so.

     User-Agent = product *( RWS ( product / comment ) )

   The User-Agent field-value consists of one or more product
   identifiers, each followed by zero or more comments (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;Section&amp;nbsp;3.2 of
   [RFC7230]&lt;/a&gt;), which together identify the user agent software and its
   significant subproducts.  By convention, the product identifiers are
   listed in decreasing order of their significance for identifying the
   user agent software.  Each product identifier consists of a name and
   optional version.

     product         = token [&quot;/&quot; product-version]
     product-version = token

   A sender SHOULD limit generated product identifiers to what is
   necessary to identify the product; a sender MUST NOT generate
   advertising or other nonessential information within the product
   identifier.  A sender SHOULD NOT generate information in
   product-version that is not a version identifier (i.e., successive
   versions of the same product name ought to differ only in the
   product-version portion of the product identifier).

   Example:

     User-Agent: CERN-LineMode/2.15 libwww/2.17b3 

   A user agent SHOULD NOT generate a User-Agent field containing
   needlessly fine-grained detail and SHOULD limit the addition of
   subproducts by third parties.  Overly long and detailed User-Agent
   field values increase request latency and the risk of a user being
   identified against their wishes (&quot;fingerprinting&quot;).

   Likewise, implementations are encouraged not to use the product
   tokens of other implementations in order to declare compatibility
   with them, as this circumvents the purpose of the field.  If a user
   agent masquerades as a different user agent, recipients can assume
   that the user intentionally desires to see responses tailored for
   that identified user agent, even if they might not work as well for
   the actual user agent being used.</source>
          <target state="translated">&amp;ldquo;用户代理&amp;rdquo;标头字段包含有关发起请求的用户代理的信息，服务器通常使用该信息来帮助识别报告的互操作性问题的范围，解决或调整响应以避免特定的用户代理限制以及进行分析有关浏览器或操作系统的使用。用户代理应该在每个请求中发送一个User-Agent字段，除非特别配置为不这样做。User-Agent =产品*（RWS（product / comment））User-Agent字段值由一个或多个产品标识符组成，每个标识符后跟零或多个注释（&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;[RFC7230]的3.2节&lt;/a&gt;），一起确定用户代理软件及其重要的子产品。按照惯例，产品标识符以其重要性的降序排列，以标识用户代理软件。每个产品标识符都包含一个名称和可选版本。 product =令牌[&amp;ldquo; /&amp;rdquo; product-version] product-version =令牌发件人应将生成的产品标识符限制为识别产品所需的内容；发送者不得在产品标识符内生成广告或其他非必要信息。发送者不应在产品版本中生成不是版本标识符的信息（即，同一产品名称的后续版本应仅在产品标识符的产品版本部分有所不同）。例：用户代理：CERN-LineMode / 2.15 libwww / 2.17b3用户代理不应生成包含不必要的细粒度细节的用户代理字段，并且应限制第三方添加子产品。太长和太详细的User-Agent字段值会增加请求等待时间，并增加违背其意愿（&amp;ldquo;指纹&amp;rdquo;）识别用户的风险。同样，鼓励实现不要为了声明与其他实现的兼容性而使用其他实现的产品令牌，因为这会绕开该领域的目的。如果用户代理伪装成其他用户代理，则收件人可以假定用户有意希望看到针对该标识的用户代理量身定制的响应，即使它们可能不适用于实际使用的用户代理。CERN-LineMode / 2.15 libwww / 2.17b3用户代理不应生成包含不必要的细粒度细节的User-Agent字段，并且应限制第三方添加子产品。太长和太详细的User-Agent字段值会增加请求等待时间，并增加违背其意愿（&amp;ldquo;指纹&amp;rdquo;）识别用户的风险。同样，鼓励实现不要为了声明与其他实现的兼容性而使用其他实现的产品令牌，因为这会绕开该领域的目的。如果用户代理伪装成其他用户代理，则收件人可以假定用户有意希望看到针对该标识的用户代理量身定制的响应，即使这些响应可能不适用于所使用的实际用户代理。CERN-LineMode / 2.15 libwww / 2.17b3用户代理不应生成包含不必要的细粒度细节的User-Agent字段，并且应限制第三方添加子产品。太长和太详细的User-Agent字段值会增加请求等待时间，并增加违背其意愿（&amp;ldquo;指纹&amp;rdquo;）识别用户的风险。同样，鼓励实现不要为了声明与其他实现的兼容性而使用其他实现的产品令牌，因为这会绕开该领域的目的。如果用户代理伪装成其他用户代理，则收件人可以假定用户有意希望看到针对该标识的用户代理量身定制的响应，即使这些响应可能不适用于所使用的实际用户代理。17b3用户代理不应生成包含不必要的细粒度细节的User-Agent字段，并且应限制第三方添加子产品。太长和太详细的User-Agent字段值会增加请求等待时间，并增加违背其意愿（&amp;ldquo;指纹&amp;rdquo;）识别用户的风险。同样，鼓励实现不要为了声明与其他实现的兼容性而使用其他实现的产品令牌，因为这会绕开该领域的目的。如果用户代理伪装成其他用户代理，则收件人可以假定用户有意希望看到针对该标识的用户代理量身定制的响应，即使这些响应可能不适用于所使用的实际用户代理。17b3用户代理不应生成包含不必要的细粒度细节的User-Agent字段，并且应限制第三方添加子产品。太长和太详细的User-Agent字段值会增加请求等待时间，并增加违背其意愿（&amp;ldquo;指纹&amp;rdquo;）识别用户的风险。同样，鼓励实现不要为了声明与其他实现的兼容性而使用其他实现的产品令牌，因为这会绕开该领域的目的。如果用户代理伪装成其他用户代理，则收件人可以假定用户有意希望看到针对该标识的用户代理量身定制的响应，即使这些响应可能不适用于所使用的实际用户代理。</target>
        </trans-unit>
        <trans-unit id="6bcae230b73127da4f18a6ca33ad2072b01f296a" translate="yes" xml:space="preserve">
          <source>The &quot;Vary&quot; header field in a response describes what parts of a
   request message, aside from the method, Host header field, and
   request target, might influence the origin server's process for
   selecting and representing this response.  The value consists of
   either a single asterisk (&quot;*&quot;) or a list of header field names
   (case-insensitive).

     Vary = &quot;*&quot; / 1#field-name

   A Vary field value of &quot;*&quot; signals that anything about the request
   might play a role in selecting the response representation, possibly
   including elements outside the message syntax (e.g., the client's
   network address).  A recipient will not be able to determine whether
   this response is appropriate for a later request without forwarding
   the request to the origin server.  A proxy MUST NOT generate a Vary
   field with a &quot;*&quot; value.

   A Vary field value consisting of a comma-separated list of names
   indicates that the named request header fields, known as the
   selecting header fields, might have a role in selecting the
   representation.  The potential selecting header fields are not
   limited to those defined by this specification.

   For example, a response that contains

     Vary: accept-encoding, accept-language

   indicates that the origin server might have used the request's
   Accept-Encoding and Accept-Language fields (or lack thereof) as
   determining factors while choosing the content for this response.

   An origin server might send Vary with a list of fields for two
   purposes:

   1.  To inform cache recipients that they MUST NOT use this response
       to satisfy a later request unless the later request has the same
       values for the listed fields as the original request (&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.1&quot;&gt;Section&amp;nbsp;4.1
       of [RFC7234]&lt;/a&gt;).  In other words, Vary expands the cache key
       required to match a new request to the stored cache entry. 

   2.  To inform user agent recipients that this response is subject to
       content negotiation (&lt;a href=&quot;#section-5.3&quot;&gt;Section 5.3&lt;/a&gt;) and that a different
       representation might be sent in a subsequent request if
       additional parameters are provided in the listed header fields
       (proactive negotiation).

   An origin server SHOULD send a Vary header field when its algorithm
   for selecting a representation varies based on aspects of the request
   message other than the method and request target, unless the variance
   cannot be crossed or the origin server has been deliberately
   configured to prevent cache transparency.  For example, there is no
   need to send the Authorization field name in Vary because reuse
   across users is constrained by the field definition (&lt;a href=&quot;https://tools.ietf.org/html/rfc7235#section-4.2&quot;&gt;Section&amp;nbsp;4.2 of
   [RFC7235]&lt;/a&gt;).  Likewise, an origin server might use Cache-Control
   directives (&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2&quot;&gt;Section&amp;nbsp;5.2 of [RFC7234]&lt;/a&gt;) to supplant Vary if it
   considers the variance less significant than the performance cost of
   Vary's impact on caching.</source>
          <target state="translated">响应中的&amp;ldquo; Vary&amp;rdquo;标头字段描述了请求消息的哪些部分，除了方法，主机标头字段和请求目标之外，还可能影响源服务器选择和表示此响应的过程。该值由单个星号（&amp;ldquo; *&amp;rdquo;）或标题字段名称列表（不区分大小写）组成。 Vary =&amp;ldquo; *&amp;rdquo; / 1＃field-name Vary字段值&amp;ldquo; *&amp;rdquo;表示与请求有关的任何内容都可能在选择响应表示中起作用，可能包括消息语法之外的元素（例如，客户端的网络地址） 。如果没有将请求转发到原始服务器，接收者将无法确定此响应是否适合以后的请求。代理不得生成带有&amp;ldquo; *&amp;rdquo;值的Vary字段。由逗号分隔的名称列表组成的Vary字段值表示命名的请求标头字段（称为&amp;ldquo;选择标头&amp;rdquo;字段）可能在选择表示形式中起作用。潜在的选择标题字段不限于本规范定义的字段。例如，包含Vary：accept-encoding，accept-language的响应表示原始服务器在选择此响应的内容时可能已经使用了请求的Accept-Encoding和Accept-Language字段（或缺少字段）作为确定因素。原始服务器可能向Vary发送带有字段列表的字段，用于两个目的：1。通知缓存接收者他们不得使用此响应来满足以后的请求，除非后面的请求在列出的字段中具有与原始请求相同的值（&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.1&quot;&gt;[RFC7234]的4.1节&lt;/a&gt;）。换句话说，Vary扩展了将新请求与存储的缓存项匹配所需的缓存键。 2.通知用户代理收件人此响应需要进行内容协商（&lt;a href=&quot;#section-5.3&quot;&gt;第5.3节）&lt;/a&gt;），并且如果在列出的标头字段中提供了其他参数（主动协商），则可能在后续请求中发送其他表示形式。当源服务器选择表示的算法根据请求消息的方法和请求目标以外的其他方面而变化时，源服务器应发送Vary标头字段，除非不能跨越差异或已故意将源服务器配置为防止高速缓存透明。例如，不需要在Vary中发送Authorization字段名称，因为跨用户的重用受到字段定义的限制（&lt;a href=&quot;https://tools.ietf.org/html/rfc7235#section-4.2&quot;&gt;[RFC7235]的4.2节&lt;/a&gt;）。同样，原始服务器可能使用Cache-Control指令（&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2&quot;&gt;[RFC7234]的5.2节&lt;/a&gt;）如果Vari认为差异不如Vary对缓存的影响的性能成本那么重要，则可以代替Vary。</target>
        </trans-unit>
        <trans-unit id="316863bc1d70a96f56b104e2287a2491c7e69bb0" translate="yes" xml:space="preserve">
          <source>The &quot;Via&quot; header field indicates the presence of intermediate
   protocols and recipients between the user agent and the server (on
   requests) or between the origin server and the client (on responses),
   similar to the &quot;Received&quot; header field in email (&lt;a href=&quot;https://tools.ietf.org/html/rfc5322#section-3.6.7&quot;&gt;Section&amp;nbsp;3.6.7 of
   [RFC5322]&lt;/a&gt;).  Via can be used for tracking message forwards, avoiding
   request loops, and identifying the protocol capabilities of senders
   along the request/response chain.

     Via = 1#( received-protocol RWS received-by [ RWS comment ] )

     received-protocol = [ protocol-name &quot;/&quot; ] protocol-version
                         ; see &lt;a href=&quot;#section-6.7&quot;&gt;Section 6.7&lt;/a&gt;
     received-by       = ( uri-host [ &quot;:&quot; port ] ) / pseudonym
     pseudonym         = token

   Multiple Via field values represent each proxy or gateway that has
   forwarded the message.  Each intermediary appends its own information
   about how the message was received, such that the end result is
   ordered according to the sequence of forwarding recipients. 

   A proxy MUST send an appropriate Via header field, as described
   below, in each message that it forwards.  An HTTP-to-HTTP gateway
   MUST send an appropriate Via header field in each inbound request
   message and MAY send a Via header field in forwarded response
   messages.

   For each intermediary, the received-protocol indicates the protocol
   and protocol version used by the upstream sender of the message.
   Hence, the Via field value records the advertised protocol
   capabilities of the request/response chain such that they remain
   visible to downstream recipients; this can be useful for determining
   what backwards-incompatible features might be safe to use in
   response, or within a later request, as described in &lt;a href=&quot;#section-2.6&quot;&gt;Section 2.6&lt;/a&gt;.
   For brevity, the protocol-name is omitted when the received protocol
   is HTTP.

   The received-by portion of the field value is normally the host and
   optional port number of a recipient server or client that
   subsequently forwarded the message.  However, if the real host is
   considered to be sensitive information, a sender MAY replace it with
   a pseudonym.  If a port is not provided, a recipient MAY interpret
   that as meaning it was received on the default TCP port, if any, for
   the received-protocol.

   A sender MAY generate comments in the Via header field to identify
   the software of each recipient, analogous to the User-Agent and
   Server header fields.  However, all comments in the Via field are
   optional, and a recipient MAY remove them prior to forwarding the
   message.

   For example, a request message could be sent from an HTTP/1.0 user
   agent to an internal proxy code-named &quot;fred&quot;, which uses HTTP/1.1 to
   forward the request to a public proxy at p.example.net, which
   completes the request by forwarding it to the origin server at
   www.example.com.  The request received by www.example.com would then
   have the following Via header field:

     Via: 1.0 fred, 1.1 p.example.net

   An intermediary used as a portal through a network firewall SHOULD
   NOT forward the names and ports of hosts within the firewall region
   unless it is explicitly enabled to do so.  If not enabled, such an
   intermediary SHOULD replace each received-by host of any host behind
   the firewall by an appropriate pseudonym for that host. 

   An intermediary MAY combine an ordered subsequence of Via header
   field entries into a single such entry if the entries have identical
   received-protocol values.  For example,

     Via: 1.0 ricky, 1.1 ethel, 1.1 fred, 1.0 lucy

   could be collapsed to

     Via: 1.0 ricky, 1.1 mertz, 1.0 lucy

   A sender SHOULD NOT combine multiple entries unless they are all
   under the same organizational control and the hosts have already been
   replaced by pseudonyms.  A sender MUST NOT combine entries that have
   different received-protocol values.</source>
          <target state="translated">&amp;ldquo;通过&amp;rdquo;标头字段指示在用户代理和服务器之间（按请求）或在原始服务器和客户端之间（按响应）中间协议和收件人的存在，类似于电子邮件中的&amp;ldquo;已接收&amp;rdquo;标头字段（本&lt;a href=&quot;https://tools.ietf.org/html/rfc5322#section-3.6.7&quot;&gt;节[RFC5322]的3.6.7&lt;/a&gt;）。Via可用于跟踪消息转发，避免请求循环以及识别沿请求/响应链的发送者的协议功能。通过= 1＃（（[RWS注释]接收到的RWS接收协议））= [协议名称&amp;ldquo; /&amp;rdquo;]协议版本；见&lt;a href=&quot;#section-6.7&quot;&gt;6.7节&lt;/a&gt; 接收者=（uri-host [&amp;ldquo;：&amp;rdquo;端口]）/假名假名=令牌多个&amp;ldquo;通过&amp;rdquo;字段值表示已转发邮件的每个代理或网关。每个中介都附加其自己的有关如何接收消息的信息，以便根据转发接收者的顺序对最终结果进行排序。代理必须在其转发的每条消息中发送适当的Via标头字段，如下所述。 HTTP到HTTP网关必须在每个入站请求消息中发送适当的Via头字段，并可以在转发的响应消息中发送Via头字段。对于每个中介，received-protocol指示消息的上游发送方使用的协议和协议版本。因此，Via字段值记录了请求/响应链的广告协议功能，以使它们对下游接收者仍然可见；这对于确定哪些向后不兼容的功能在响应中或以后的请求中可以安全使用很有用，如&lt;a href=&quot;#section-2.6&quot;&gt;第2.6节&lt;/a&gt;。为简便起见，当接收的协议为HTTP时，省略协议名称。字段值的&amp;ldquo;接收人&amp;rdquo;部分通常是随后转发邮件的收件人服务器或客户端的主机和可选端口号。但是，如果真实主机被认为是敏感信息，则发送者可以用化名代替它。如果未提供端口，则接收者可以将其解释为意味着已在默认TCP端口（如果有）上接收到该协议。发送者可以在Via头字段中生成注释，以标识每个接收者的软件，类似于User-Agent和Server头字段。但是，&amp;ldquo;通过&amp;rdquo;字段中的所有注释都是可选的，并且收件人可以在转发消息之前将其删除。例如，可以将请求消息从HTTP / 1.0用户代理发送到名为&amp;ldquo; fred&amp;rdquo;的内部代理，该代理使用HTTP / 1.1将请求转发到位于p.example.net的公共代理，该代理通过转发完成请求并将其发送到www.example.com上的原始服务器。这样，www.example.com收到的请求将具有以下Via标头字段：Via：1.0 fred，1.1 p.example.net通过网络防火墙用作门户的中介不应转发该主机中的主机名和端口。防火墙区域，除非已明确启用它。如果未启用，则这种中介应该用该主机的适当假名替换该防火墙后任何主机的每个接收主机。如果条目具有相同的接收协议值，则中间人可以将Via标头字段条目的有序子序列组合成一个这样的条目。例如，&amp;ldquo; Via：1.0 ricky，1.1 ethel，1.1 fred，1.0 lucy&amp;rdquo;可以折叠为&amp;ldquo; Via：1.0 ricky，1.1 mertz，1.0 lucy&amp;rdquo;。发件人不应该合并多个条目，除非它们都处于同一组织控制之下并且主持人具有已被化名代替。发送者不得组合具有不同接收协议值的条目。0 lucy发送者不应该合并多个条目，除非它们都处于同一组织控制之下并且主机已被假名代替。发送者不得组合具有不同接收协议值的条目。0 lucy发送者不应该合并多个条目，除非它们都处于同一组织控制之下并且主机已被假名代替。发送者不得组合具有不同接收协议值的条目。</target>
        </trans-unit>
        <trans-unit id="9867a861577bfb6c81de727cf7f2304bd8cb13b4" translate="yes" xml:space="preserve">
          <source>The &quot;WWW-Authenticate&quot; header field indicates the authentication
   scheme(s) and parameters applicable to the target resource.

     WWW-Authenticate = 1#challenge

   A server generating a 401 (Unauthorized) response MUST send a
   WWW-Authenticate header field containing at least one challenge.  A
   server MAY generate a WWW-Authenticate header field in other response
   messages to indicate that supplying credentials (or different
   credentials) might affect the response.

   A proxy forwarding a response MUST NOT modify any WWW-Authenticate
   fields in that response.

   User agents are advised to take special care in parsing the field
   value, as it might contain more than one challenge, and each
   challenge can contain a comma-separated list of authentication
   parameters.  Furthermore, the header field itself can occur multiple
   times.

   For instance:

     WWW-Authenticate: Newauth realm=&quot;apps&quot;, type=1,
                       title=&quot;Login to \&quot;apps\&quot;&quot;, Basic realm=&quot;simple&quot;

   This header field contains two challenges; one for the &quot;Newauth&quot;
   scheme with a realm value of &quot;apps&quot;, and two additional parameters
   &quot;type&quot; and &quot;title&quot;, and another one for the &quot;Basic&quot; scheme with a
   realm value of &quot;simple&quot;.

      Note: The challenge grammar production uses the list syntax as
      well.  Therefore, a sequence of comma, whitespace, and comma can
      be considered either as applying to the preceding challenge, or to
      be an empty entry in the list of challenges.  In practice, this
      ambiguity does not affect the semantics of the header field value
      and thus is harmless.</source>
          <target state="translated">WWW-Authenticate &quot;头字段表示适用于目标资源的验证方案和参数。WWW-Authenticate=1#challenge 生成401(Unauthorized)响应的服务器必须发送一个包含至少一个挑战的WWW-Authenticate头字段。服务器可以在其他响应消息中生成一个WWW-Authenticate头字段,以表明提供凭证(或不同的凭证)可能会影响响应。转发响应的代理不得修改该响应中的任何WWW-Authenticate字段。建议用户代理在解析该字段值时特别小心,因为它可能包含多个挑战,而每个挑战可能包含一个逗号分隔的认证参数列表。此外,头字段本身可以出现多次。例如 WWW -Authenticate:Newauth realm=&quot;apps&quot;,type=1,title=&quot;Login to \&quot;apps\&quot;&quot;,Basic realm=&quot;simple&quot; 这个头字段包含两个挑战;一个是 &quot;Newauth &quot;方案的挑战,境界值为 &quot;apps&quot;,还有两个附加参数 &quot;type &quot;和 &quot;title&quot;,另一个是 &quot;Basic &quot;方案的挑战,境界值为 &quot;simple&quot;。注:挑战语法制作也使用列表语法。因此,逗号、空格、逗号的序列既可以认为适用于前面的挑战,也可以认为是挑战列表中的空条目。在实践中,这种歧义并不影响头字段值的语义,因此是无害的。</target>
        </trans-unit>
        <trans-unit id="010ba1a9ad73a34753b90adf3c72f63de66025ee" translate="yes" xml:space="preserve">
          <source>The &quot;Warning&quot; header field is used to carry additional information
   about the status or transformation of a message that might not be
   reflected in the status code.  This information is typically used to
   warn about possible incorrectness introduced by caching operations or
   transformations applied to the payload of the message. 

   Warnings can be used for other purposes, both cache-related and
   otherwise.  The use of a warning, rather than an error status code,
   distinguishes these responses from true failures.

   Warning header fields can in general be applied to any message,
   however some warn-codes are specific to caches and can only be
   applied to response messages.

     Warning       = 1#warning-value

     warning-value = warn-code SP warn-agent SP warn-text
                                           [ SP warn-date ]

     warn-code  = 3DIGIT
     warn-agent = ( uri-host [ &quot;:&quot; port ] ) / pseudonym
                     ; the name or pseudonym of the server adding
                     ; the Warning header field, for use in debugging
                     ; a single &quot;-&quot; is recommended when agent unknown
     warn-text  = quoted-string
     warn-date  = DQUOTE HTTP-date DQUOTE

   Multiple warnings can be generated in a response (either by the
   origin server or by a cache), including multiple warnings with the
   same warn-code number that only differ in warn-text.

   A user agent that receives one or more Warning header fields SHOULD
   inform the user of as many of them as possible, in the order that
   they appear in the response.  Senders that generate multiple Warning
   header fields are encouraged to order them with this user agent
   behavior in mind.  A sender that generates new Warning header fields
   MUST append them after any existing Warning header fields.

   Warnings are assigned three digit warn-codes.  The first digit
   indicates whether the Warning is required to be deleted from a stored
   response after validation:

   o  1xx warn-codes describe the freshness or validation status of the
      response, and so they MUST be deleted by a cache after validation.
      They can only be generated by a cache when validating a cached
      entry, and MUST NOT be generated in any other situation.

   o  2xx warn-codes describe some aspect of the representation that is
      not rectified by a validation (for example, a lossy compression of
      the representation) and they MUST NOT be deleted by a cache after
      validation, unless a full response is sent, in which case they
      MUST be. 

   If a sender generates one or more 1xx warn-codes in a message to be
   sent to a recipient known to implement only HTTP/1.0, the sender MUST
   include in each corresponding warning-value a warn-date that matches
   the Date header field in the message.  For example:

     HTTP/1.1 200 OK
     Date: Sat, 25 Aug 2012 23:34:45 GMT
     Warning: 112 - &quot;network down&quot; &quot;Sat, 25 Aug 2012 23:34:45 GMT&quot;


   Warnings have accompanying warn-text that describes the error, e.g.,
   for logging.  It is advisory only, and its content does not affect
   interpretation of the warn-code.

   If a recipient that uses, evaluates, or displays Warning header
   fields receives a warn-date that is different from the Date value in
   the same message, the recipient MUST exclude the warning-value
   containing that warn-date before storing, forwarding, or using the
   message.  This allows recipients to exclude warning-values that were
   improperly retained after a cache validation.  If all of the
   warning-values are excluded, the recipient MUST exclude the Warning
   header field as well.

   The following warn-codes are defined by this specification, each with
   a recommended warn-text in English, and a description of its meaning.
   The procedure for defining additional warn codes is described in
   &lt;a href=&quot;#section-7.2.1&quot;&gt;Section 7.2.1&lt;/a&gt;.</source>
          <target state="translated">&amp;ldquo;警告&amp;rdquo;标头字段用于携带有关消息状态或消息转换的其他信息，这些信息可能不会反映在状态代码中。该信息通常用于警告由缓存操作或应用于消息有效负载的转换所引入的可能的错误。警告可以用于与缓存相关或其他目的的其他目的。使用警告而不是错误状态代码可以将这些响应与真正的故障区分开。警告标头字段通常可以应用于任何消息，但是某些警告代码特定于缓存，并且只能应用于响应消息。警告= 1＃警告值警告值=警告代码SP警告代理SP警告文本[SP警告日期]警告代码= 3DIGIT警告代理=（uri-host [&amp;ldquo;：&amp;rdquo; port]）/化名;服务器添加的名称或别名; Warning标头字段，用于调试；当代理未知warn-text = quoted-string warn-date = DQUOTE HTTP-date DQUOTE时，建议使用单个&amp;ldquo;-&amp;rdquo;。响应中可以生成多个警告（由源服务器或缓存生成），包括带有相同的警告代码号，只是警告文本不同。收到一个或多个警告标头字段的用户代理应将尽可能多的警告标头通知用户，按照它们在响应中出现的顺序。鼓励生成多个Warning标头字段的发件人考虑到此用户代理行为对它们进行排序。产生新警告标题字段的发送者必须将它们附加在任何现有警告标题字段之后。警告被分配了三位数的警告代码。第一位数字表示验证后是否需要从存储的响应中删除警告：o 1xx警告代码描述了响应的新鲜度或验证状态，因此必须在验证后由缓存删除。它们只能在验证缓存的条目时由缓存生成，并且在任何其他情况下都不得生成。o 2xx警告代码描述了表示中未通过验证纠正的某些方面（例如，表示的有损压缩），并且验证之后，除非已发送完整响应，否则它们不得被缓存删除。他们必须如此。如果发件人在要发送给已知仅实现HTTP / 1.0的收件人的消息中生成一个或多个1xx警告代码，则发件人务必在每个相应的警告值中包含与日期中的Date标头字段匹配的警告日期。信息。例如：HTTP / 1.1 200 OK日期：2012年8月25日，星期六，格林尼治标准时间警告：112-&amp;ldquo;网络中断&amp;rdquo;&amp;ldquo; 2012年8月25日，星期六，格林尼治标准时间&amp;rdquo;警告带有伴随的警告文本，描述了错误，例如用于记录。这仅是建议，并且其内容不影响警告代码的解释。如果使用，评估或显示&amp;ldquo;警告&amp;rdquo;标题字段的收件人收到的警告日期与同一封邮件中的&amp;ldquo;日期&amp;rdquo;值不同，则收件人必须在存储，转发或使用前排除包含该警告日期的警告值。消息。这使收件人可以排除在缓存验证后未正确保留的警告值。如果所有警告值都被排除，则接收者也必须排除警告头字段。本规范定义了以下警告代码，每个警告代码均带有建议的英文警告文本以及其含义的描述。定义附加警告代码的过程在如果使用，评估或显示&amp;ldquo;警告&amp;rdquo;标题字段的收件人收到的警告日期与同一封邮件中的&amp;ldquo;日期&amp;rdquo;值不同，则收件人必须在存储，转发或使用前排除包含该警告日期的警告值。消息。这使收件人可以排除在缓存验证后未正确保留的警告值。如果所有警告值都被排除，则接收者也必须排除警告头字段。本规范定义了以下警告代码，每个警告代码均带有建议的英文警告文本以及其含义的描述。定义附加警告代码的过程在如果使用，评估或显示&amp;ldquo;警告&amp;rdquo;标题字段的收件人收到的警告日期与同一封邮件中的&amp;ldquo;日期&amp;rdquo;值不同，则收件人必须在存储，转发或使用前排除包含该警告日期的警告值。消息。这使收件人可以排除在缓存验证后未正确保留的警告值。如果所有警告值都被排除，则接收者也必须排除警告头字段。本规范定义了以下警告代码，每个警告代码均带有建议的英文警告文本以及其含义的描述。定义附加警告代码的过程在或显示警告标头字段接收的警告日期与同一条消息中的&amp;ldquo;日期&amp;rdquo;值不同，接收者必须在存储，转发或使用消息之前排除包含该警告日期的警告值。这使收件人可以排除在缓存验证后未正确保留的警告值。如果所有警告值都被排除，则接收者也必须排除警告头字段。本规范定义了以下警告代码，每个警告代码均带有建议的英文警告文本以及其含义的描述。定义附加警告代码的过程在或显示警告标头字段接收的警告日期与同一条消息中的&amp;ldquo;日期&amp;rdquo;值不同，接收者必须在存储，转发或使用消息之前排除包含该警告日期的警告值。这使收件人可以排除在缓存验证后未正确保留的警告值。如果所有警告值都被排除，则接收者也必须排除警告头字段。本规范定义了以下警告代码，每个警告代码均带有建议的英文警告文本以及其含义的描述。定义附加警告代码的过程在这使收件人可以排除在缓存验证后未正确保留的警告值。如果所有警告值都被排除，则接收者也必须排除警告头字段。本规范定义了以下警告代码，每个警告代码均带有建议的英文警告文本以及其含义的描述。定义附加警告代码的过程在这使收件人可以排除在缓存验证后未正确保留的警告值。如果所有警告值都被排除，则接收者也必须排除警告头字段。本规范定义了以下警告代码，每个警告代码均带有建议的英文警告文本以及其含义的描述。定义附加警告代码的过程在 &lt;a href=&quot;#section-7.2.1&quot;&gt;第7.2.1节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="995d6efd3e0c66344c9a13f1a4baae749a8853bd" translate="yes" xml:space="preserve">
          <source>The &quot;app:categories&quot; element provides a list of the categories that
   can be applied to the members of a Collection.  See &lt;a href=&quot;#section-7.2.1&quot;&gt;Section 7.2.1&lt;/a&gt; for
   the detailed definition of app:categories.

   The server MAY reject attempts to create or store members whose
   categories are not present in its categories list.  A Collection that
   indicates the category set is open SHOULD NOT reject otherwise
   acceptable members whose categories are not in its categories list.
   The absence of an app:categories element means that the category
   handling of the Collection is unspecified.  A &quot;fixed&quot; category list
   that contains zero categories indicates the Collection does not
   accept category data.</source>
          <target state="translated">&amp;ldquo; app：categories&amp;rdquo;元素提供了可以应用于集合成员的类别的列表。有关app：categories的详细定义，请参见&lt;a href=&quot;#section-7.2.1&quot;&gt;第7.2.1节&lt;/a&gt;。服务器可以拒绝创建或存储其类别列表中不存在其类别的成员的尝试。指示类别集已打开的Collection不应拒绝类别不在其类别列表中的其他可接受的成员。没有app：categories元素意味着未指定Collection的类别处理。包含零个类别的&amp;ldquo;固定&amp;rdquo;类别列表表示该集合不接受类别数据。</target>
        </trans-unit>
        <trans-unit id="2862e4bbac71e75234686e57a0b3abd15c18ac9a" translate="yes" xml:space="preserve">
          <source>The &quot;app:collection&quot; element describes a Collection.  The app:
   collection element MUST contain one atom:title element.

   The app:collection element MAY contain any number of app:accept
   elements, indicating the types of representations accepted by the
   Collection.  The order of such elements is not significant.

   The app:collection element MAY contain any number of app:categories
   elements.

   appCollection =
      element app:collection {
         appCommonAttributes,
         attribute href { atomURI  },
         ( atomTitle
           &amp;amp; appAccept*
           &amp;amp; appCategories*
           &amp;amp; extensionSansTitleElement* )
      }</source>
          <target state="translated">&amp;ldquo; app：collection&amp;rdquo;元素描述一个Collection。 app：集合元素必须包含一个atom：title元素。 app：collection元素可以包含任意数量的app：accept元素，指示Collection接受的表示形式。这些元素的顺序并不重要。 app：collection元素可以包含任意数量的app：categories元素。 appCollection =元素app：collection {appCommonAttributes，属性href {atomURI}，（atomTitle和appAccept *＆appCategories *和extensionSansTitleElement *）}</target>
        </trans-unit>
        <trans-unit id="4f92b1bc26a73cb4af47cd72166377ea0b007dfa" translate="yes" xml:space="preserve">
          <source>The &quot;app:edited&quot; element is a Date construct (as defined by
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt;]), whose content indicates the last time an Entry was
   edited.  If the entry has not been edited yet, the content indicates
   the time it was created.  Atom Entry elements in Collection Documents
   SHOULD contain one app:edited element, and MUST NOT contain more than
   one.

   appEdited = element app:edited ( atomDateConstruct )

   The server SHOULD change the value of this element every time an
   Entry Resource or an associated Media Resource has been edited.</source>
          <target state="translated">&amp;ldquo; app：edited&amp;rdquo;元素是Date构造（由[ &lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt; ] 定义），其内容指示上次编辑条目的时间。如果条目尚未被编辑，则内容指示创建时间。收款凭证中的Atom Entry元素应包含一个app：edited元素，并且不得包含多个。appEdited =元素app：edited（atomDateConstruct）每次编辑条目资源或关联的媒体资源时，服务器应更改此元素的值。</target>
        </trans-unit>
        <trans-unit id="68f4c11acf63f6cde7cb7434dea073f5a30ec84b" translate="yes" xml:space="preserve">
          <source>The &quot;atom:title&quot; element is defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt;] and gives a human-
   readable title for the Collection.</source>
          <target state="translated">[atom：title]元素在[ &lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt; ]中定义，并为集合提供了易于阅读的标题。</target>
        </trans-unit>
        <trans-unit id="409b2e89b2d86b6bfc0d29cd3e58e574f2822ac5" translate="yes" xml:space="preserve">
          <source>The &quot;compress&quot; coding is an adaptive Lempel-Ziv-Welch (LZW) coding
   [&lt;a href=&quot;#ref-Welch&quot;&gt;Welch&lt;/a&gt;] that is commonly produced by the UNIX file compression
   program &quot;compress&quot;.  A recipient SHOULD consider &quot;x-compress&quot; to be
   equivalent to &quot;compress&quot;.</source>
          <target state="translated">&amp;ldquo;压缩&amp;rdquo;编码是一种自适应的Lempel-Ziv-Welch（LZW）编码[ &lt;a href=&quot;#ref-Welch&quot;&gt;Welch&lt;/a&gt; ]，通常由UNIX文件压缩程序&amp;ldquo; compress&amp;rdquo;产生。接收者应该认为&amp;ldquo; x-compress&amp;rdquo;等同于&amp;ldquo; compress&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="5450639421b7ec9a5bfb9b3a5351d2c59960ee2f" translate="yes" xml:space="preserve">
          <source>The &quot;data&quot; URL scheme</source>
          <target state="translated">数据 &quot;URL方案</target>
        </trans-unit>
        <trans-unit id="7fec5b6deed76c5c2f6df9fc9a93ea6b5f359e93" translate="yes" xml:space="preserve">
          <source>The &quot;deflate&quot; coding is a &quot;zlib&quot; data format [&lt;a href=&quot;https://tools.ietf.org/html/rfc1950&quot;&gt;RFC1950&lt;/a&gt;] containing a
   &quot;deflate&quot; compressed data stream [&lt;a href=&quot;https://tools.ietf.org/html/rfc1951&quot;&gt;RFC1951&lt;/a&gt;] that uses a combination of
   the Lempel-Ziv (LZ77) compression algorithm and Huffman coding.

      Note: Some non-conformant implementations send the &quot;deflate&quot;
      compressed data without the zlib wrapper.</source>
          <target state="translated">&amp;ldquo;放气&amp;rdquo;编码是一种&amp;ldquo; zlib&amp;rdquo;数据格式[ &lt;a href=&quot;https://tools.ietf.org/html/rfc1950&quot;&gt;RFC1950&lt;/a&gt; ]，其中包含使用了Lempel-Ziv（LZ77）压缩算法和霍夫曼编码的组合的&amp;ldquo;放气&amp;rdquo;压缩数据流[ &lt;a href=&quot;https://tools.ietf.org/html/rfc1951&quot;&gt;RFC1951&lt;/a&gt; ]。注意：一些不一致的实现没有zlib包装器就发送&amp;ldquo;压缩&amp;rdquo;压缩数据。</target>
        </trans-unit>
        <trans-unit id="18f6fc86dc33b8be8746e1979432c3044e14ee93" translate="yes" xml:space="preserve">
          <source>The &quot;gzip&quot; coding is an LZ77 coding with a 32-bit Cyclic Redundancy
   Check (CRC) that is commonly produced by the gzip file compression
   program [&lt;a href=&quot;https://tools.ietf.org/html/rfc1952&quot;&gt;RFC1952&lt;/a&gt;].  A recipient SHOULD consider &quot;x-gzip&quot; to be
   equivalent to &quot;gzip&quot;.</source>
          <target state="translated">&amp;ldquo; gzip&amp;rdquo;编码是带有32位循环冗余校验（CRC）的LZ77编码，通常由gzip文件压缩程序[ &lt;a href=&quot;https://tools.ietf.org/html/rfc1952&quot;&gt;RFC1952&lt;/a&gt; ]产生。接收者应将&amp;ldquo; x-gzip&amp;rdquo;等同于&amp;ldquo; gzip&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="3da79a4d757a4b703e27456e900e76eca528f808" translate="yes" xml:space="preserve">
          <source>The &quot;http&quot; URI scheme is hereby defined for the purpose of minting
   identifiers according to their association with the hierarchical
   namespace governed by a potential HTTP origin server listening for
   TCP ([&lt;a href=&quot;https://tools.ietf.org/html/rfc0793&quot;&gt;RFC0793&lt;/a&gt;]) connections on a given port.

     http-URI = &quot;http:&quot; &quot;//&quot; authority path-abempty [ &quot;?&quot; query ]
                [ &quot;#&quot; fragment ]

   The origin server for an &quot;http&quot; URI is identified by the authority
   component, which includes a host identifier and optional TCP port
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.2.2&quot;&gt;[RFC3986], Section&amp;nbsp;3.2.2&lt;/a&gt;).  The hierarchical path component and
   optional query component serve as an identifier for a potential
   target resource within that origin server's name space.  The optional
   fragment component allows for indirect identification of a secondary
   resource, independent of the URI scheme, as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.5&quot;&gt;Section&amp;nbsp;3.5 of
   [RFC3986]&lt;/a&gt;.

   A sender MUST NOT generate an &quot;http&quot; URI with an empty host
   identifier.  A recipient that processes such a URI reference MUST
   reject it as invalid.

   If the host identifier is provided as an IP address, the origin
   server is the listener (if any) on the indicated TCP port at that IP
   address.  If host is a registered name, the registered name is an
   indirect identifier for use with a name resolution service, such as
   DNS, to find an address for that origin server.  If the port
   subcomponent is empty or not given, TCP port 80 (the reserved port
   for WWW services) is the default.

   Note that the presence of a URI with a given authority component does
   not imply that there is always an HTTP server listening for
   connections on that host and port.  Anyone can mint a URI.  What the
   authority component determines is who has the right to respond
   authoritatively to requests that target the identified resource.  The
   delegated nature of registered names and IP addresses creates a
   federated namespace, based on control over the indicated host and
   port, whether or not an HTTP server is present.  See &lt;a href=&quot;#section-9.1&quot;&gt;Section 9.1&lt;/a&gt; for
   security considerations related to establishing authority.

   When an &quot;http&quot; URI is used within a context that calls for access to
   the indicated resource, a client MAY attempt access by resolving the
   host to an IP address, establishing a TCP connection to that address
   on the indicated port, and sending an HTTP request message
   (&lt;a href=&quot;#section-3&quot;&gt;Section 3&lt;/a&gt;) containing the URI's identifying data (&lt;a href=&quot;#section-5&quot;&gt;Section 5&lt;/a&gt;) to the
   server.  If the server responds to that request with a non-interim 

   HTTP response message, as described in &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6&quot;&gt;Section&amp;nbsp;6 of [RFC7231]&lt;/a&gt;, then
   that response is considered an authoritative answer to the client's
   request.

   Although HTTP is independent of the transport protocol, the &quot;http&quot;
   scheme is specific to TCP-based services because the name delegation
   process depends on TCP for establishing authority.  An HTTP service
   based on some other underlying connection protocol would presumably
   be identified using a different URI scheme, just as the &quot;https&quot;
   scheme (below) is used for resources that require an end-to-end
   secured connection.  Other protocols might also be used to provide
   access to &quot;http&quot; identified resources -- it is only the authoritative
   interface that is specific to TCP.

   The URI generic syntax for authority also includes a deprecated
   userinfo subcomponent (&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.2.1&quot;&gt;[RFC3986], Section&amp;nbsp;3.2.1&lt;/a&gt;) for including user
   authentication information in the URI.  Some implementations make use
   of the userinfo component for internal configuration of
   authentication information, such as within command invocation
   options, configuration files, or bookmark lists, even though such
   usage might expose a user identifier or password.  A sender MUST NOT
   generate the userinfo subcomponent (and its &quot;@&quot; delimiter) when an
   &quot;http&quot; URI reference is generated within a message as a request
   target or header field value.  Before making use of an &quot;http&quot; URI
   reference received from an untrusted source, a recipient SHOULD parse
   for userinfo and treat its presence as an error; it is likely being
   used to obscure the authority for the sake of phishing attacks.</source>
          <target state="translated">在此定义&amp;ldquo; http&amp;rdquo; URI方案的目的是根据标识符与分层名称空间的关联来铸造标识符，该命名空间由潜在的HTTP原始服务器在给定端口上侦听TCP（[ &lt;a href=&quot;https://tools.ietf.org/html/rfc0793&quot;&gt;RFC0793&lt;/a&gt; ]）连接所控制。 http-URI =&amp;ldquo; http：&amp;rdquo;&amp;ldquo; //&amp;rdquo;权限路径为空[&amp;ldquo;？&amp;rdquo; query] [&amp;ldquo;＃&amp;rdquo;片段]&amp;ldquo; http&amp;rdquo; URI的原始服务器由权限组件标识，该组件包括主机标识符和可选的TCP端口（&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.2.2&quot;&gt;[RFC3986]，第3.2.2节&lt;/a&gt;）。分层路径组件和可选查询组件充当该原始服务器名称空间内潜在目标资源的标识符。可选的片段组件允许间接标识辅助资源，而与&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.5&quot;&gt;[URI3986]第3.5节中&lt;/a&gt;定义的URI方案无关。。发送者不得生成带有空主机标识符的&amp;ldquo; http&amp;rdquo; URI。处理此类URI引用的接收者务必将其视为无效。如果将主机标识符作为IP地址提供，则原始服务器是该IP地址上指示的TCP端口上的侦听器（如果有）。如果host是注册名称，则注册名称是用于名称解析服务（例如DNS）的间接标识符，以查找该原始服务器的地址。如果端口子组件为空或未提供，则默认为TCP端口80（WWW服务的保留端口）。请注意，具有给定权限组件的URI的存在并不意味着总是有HTTP服务器在侦听该主机和端口上的连接。任何人都可以创建URI。权限组件确定的是谁有权对以已标识资源为目标的请求进行权威响应。注册名称和IP地址的委托性质基于对指示的主机和端口的控制（无论是否存在HTTP服务器）来创建联合名称空间。看到&lt;a href=&quot;#section-9.1&quot;&gt;&lt;/a&gt;有关建立权限的安全性考虑，请参阅第9.1节。当在要求访问指定资源的上下文中使用&amp;ldquo; http&amp;rdquo; URI时，客户端可以通过以下方式尝试访问：将主机解析为IP地址，在指定端口上建立与该地址的TCP连接，然后发送HTTP向服务器发送包含URI标识数据（&lt;a href=&quot;#section-5&quot;&gt;第5 &lt;/a&gt;&lt;a href=&quot;#section-3&quot;&gt;部分&lt;/a&gt;）的请求消息（第3 部分）。服务器是否使用非临时HTTP响应消息响应该请求，如&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6&quot;&gt;[RFC7231]第6节中&lt;/a&gt;所述，那么该响应将被视为对客户请求的权威答复。尽管HTTP独立于传输协议，但是&amp;ldquo; http&amp;rdquo;方案特定于基于TCP的服务，因为名称委派过程依赖于TCP来建立授权。大概将使用其他URI方案来标识基于某些其他基础连接协议的HTTP服务，就像&amp;ldquo; https&amp;rdquo;方案（以下）用于要求端到端安全连接的资源一样。其他协议也可用于提供对&amp;ldquo; http&amp;rdquo;标识的资源的访问-只是TCP特有的权威接口。授权的URI通用语法还包括不赞成使用的userinfo子组件（&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.2.1&quot;&gt;[RFC3986]，第3.2节。1个&lt;/a&gt;），用于在URI中包含用户身份验证信息。一些实现将userinfo组件用于身份验证信息的内部配置，例如在命令调用选项，配置文件或书签列表中，即使这种用法可能会暴露用户标识符或密码。当在消息中生成&amp;ldquo; http&amp;rdquo; URI引用作为请求目标或标头字段值时，发送方不得生成userinfo子组件（及其&amp;ldquo; @&amp;rdquo;定界符）。在使用从不受信任的来源收到的&amp;ldquo; http&amp;rdquo; URI引用之前，接收者应该解析userinfo并将其存在视为错误；它可能被用来掩盖网络钓鱼攻击的权威。</target>
        </trans-unit>
        <trans-unit id="e8a58311de89d4c408e7b65f13ca2deebb29dec3" translate="yes" xml:space="preserve">
          <source>The &quot;http&quot; scheme is used to locate network resources via the HTTP
   protocol. This section defines the scheme-specific syntax and
   semantics for http URLs.

   http_URL = &quot;http:&quot; &quot;//&quot; host [ &quot;:&quot; port ] [ abs_path [ &quot;?&quot; query ]]

   If the port is empty or not given, port 80 is assumed. The semantics
   are that the identified resource is located at the server listening
   for TCP connections on that port of that host, and the Request-URI
   for the resource is abs_path (&lt;a href=&quot;#section-5.1.2&quot;&gt;section 5.1.2&lt;/a&gt;). The use of IP addresses
   in URLs SHOULD be avoided whenever possible (see &lt;a href=&quot;https://tools.ietf.org/html/rfc1900&quot;&gt;RFC 1900&lt;/a&gt; [&lt;a href=&quot;#ref-24&quot;&gt;24&lt;/a&gt;]). If
   the abs_path is not present in the URL, it MUST be given as &quot;/&quot; when
   used as a Request-URI for a resource (&lt;a href=&quot;#section-5.1.2&quot;&gt;section 5.1.2&lt;/a&gt;). If a proxy
   receives a host name which is not a fully qualified domain name, it
   MAY add its domain to the host name it received. If a proxy receives
   a fully qualified domain name, the proxy MUST NOT change the host
   name.</source>
          <target state="translated">&amp;ldquo; http&amp;rdquo;方案用于通过HTTP协议定位网络资源。本节为http URL定义了特定于方案的语法和语义。 http_URL =&amp;ldquo; http：&amp;rdquo;&amp;ldquo; //&amp;rdquo;主机[&amp;ldquo;：&amp;rdquo;端口] [abs_path [&amp;ldquo;？&amp;rdquo; [查询]]如果端口为空或未提供，则假定端口为80。语义是所标识的资源位于服务器上，用于侦听该主机的该端口上的TCP连接，并且该资源的Request-URI为abs_path（&lt;a href=&quot;#section-5.1.2&quot;&gt;第5.1.2节&lt;/a&gt;）。应尽可能避免在URL中使用IP地址（请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc1900&quot;&gt;RFC 1900&lt;/a&gt; [ &lt;a href=&quot;#ref-24&quot;&gt;24&lt;/a&gt; ]）。如果URL中不存在abs_path，则在用作资源的Request-URI时必须将其指定为&amp;ldquo; /&amp;rdquo;（&lt;a href=&quot;#section-5.1.2&quot;&gt;第5.1节。2&lt;/a&gt;）。如果代理收到的主机名不是完全合格的域名，则可以将其域添加到收到的主机名中。如果代理收到一个完全合格的域名，则该代理不得更改主机名。</target>
        </trans-unit>
        <trans-unit id="73555a35c2933a1c75aa810e673714fa36744ea0" translate="yes" xml:space="preserve">
          <source>The &quot;https&quot; URI scheme is hereby defined for the purpose of minting
   identifiers according to their association with the hierarchical
   namespace governed by a potential HTTP origin server listening to a
   given TCP port for TLS-secured connections ([&lt;a href=&quot;https://tools.ietf.org/html/rfc5246&quot;&gt;RFC5246&lt;/a&gt;]).

   All of the requirements listed above for the &quot;http&quot; scheme are also
   requirements for the &quot;https&quot; scheme, except that TCP port 443 is the
   default if the port subcomponent is empty or not given, and the user
   agent MUST ensure that its connection to the origin server is secured
   through the use of strong encryption, end-to-end, prior to sending
   the first HTTP request.

     https-URI = &quot;https:&quot; &quot;//&quot; authority path-abempty [ &quot;?&quot; query ]
                 [ &quot;#&quot; fragment ]

   Note that the &quot;https&quot; URI scheme depends on both TLS and TCP for
   establishing authority.  Resources made available via the &quot;https&quot;
   scheme have no shared identity with the &quot;http&quot; scheme even if their 

   resource identifiers indicate the same authority (the same host
   listening to the same TCP port).  They are distinct namespaces and
   are considered to be distinct origin servers.  However, an extension
   to HTTP that is defined to apply to entire host domains, such as the
   Cookie protocol [&lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC6265&lt;/a&gt;], can allow information set by one service
   to impact communication with other services within a matching group
   of host domains.

   The process for authoritative access to an &quot;https&quot; identified
   resource is defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2818&quot;&gt;RFC2818&lt;/a&gt;].</source>
          <target state="translated">因此，定义&amp;ldquo; https&amp;rdquo; URI方案的目的是根据标识符与层次名称空间的关联来铸造标识符，该层次名称空间由潜在的HTTP原始服务器管理，该HTTP原始服务器侦听给定的TCP端口以进行TLS保护的连接（[ &lt;a href=&quot;https://tools.ietf.org/html/rfc5246&quot;&gt;RFC5246&lt;/a&gt;]）。上面列出的&amp;ldquo; http&amp;rdquo;方案的所有要求也都是&amp;ldquo; https&amp;rdquo;方案的要求，但如果端口子组件为空或未提供，则默认使用TCP端口443，并且用户代理必须确保其与以下地址的连接：在发送第一个HTTP请求之前，通过使用端到端的强加密来保护源服务器。 https-URI =&amp;ldquo; https：&amp;rdquo;&amp;ldquo; //&amp;rdquo;权限路径为空[&amp;ldquo;？&amp;rdquo;查询] [&amp;ldquo;＃&amp;rdquo;片段]请注意，&amp;ldquo; https&amp;rdquo; URI方案依赖于TLS和TCP来建立授权。通过&amp;ldquo; https&amp;rdquo;方案提供的资源与&amp;ldquo; http&amp;rdquo;没有共享身份即使它们的资源标识符指示相同的权限（侦听同一TCP端口的同一主机），该方案也是如此。它们是不同的名称空间，被认为是不同的原始服务器。但是，HTTP的扩展已定义为适用于整个主机域，例如Cookie协议[&lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC6265&lt;/a&gt; ]可以允许一个服务设置的信息影响与主机域匹配的组中其他服务的通信。在[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2818&quot;&gt;RFC2818&lt;/a&gt; ]中定义了对&amp;ldquo; https&amp;rdquo;标识的资源进行权威访问的过程。</target>
        </trans-unit>
        <trans-unit id="381425c701e0e7786e14ce1ebe204baefd4cf1f3" translate="yes" xml:space="preserve">
          <source>The &quot;must-revalidate&quot; response directive indicates that once it has
   become stale, a cache MUST NOT use the response to satisfy subsequent
   requests without successful validation on the origin server.

   The must-revalidate directive is necessary to support reliable
   operation for certain protocol features.  In all circumstances a
   cache MUST obey the must-revalidate directive; in particular, if a
   cache cannot reach the origin server for any reason, it MUST generate
   a 504 (Gateway Timeout) response.

   The must-revalidate directive ought to be used by servers if and only
   if failure to validate a request on the representation could result
   in incorrect operation, such as a silently unexecuted financial
   transaction.</source>
          <target state="translated">Must-revalidate &quot;响应指令表明,一旦它变得陈旧,在没有在源服务器上成功验证的情况下,缓存不得使用该响应来满足后续请求。Must-revalidate指令对于支持某些协议特性的可靠操作是必要的。在任何情况下,缓存都必须遵守must-revalidate指令;特别是,如果缓存因为任何原因不能到达源服务器,它必须生成504(网关超时)响应。必须重新验证指令应该被服务器使用,如果且仅当未能验证对表示的请求可能会导致不正确的操作,例如一个沉默的未执行的金融交易。</target>
        </trans-unit>
        <trans-unit id="c4b6b9fcb971dd4f353272a2f91db7cf9a5b6db0" translate="yes" xml:space="preserve">
          <source>The &quot;no-cache&quot; request directive indicates that a cache MUST NOT use
   a stored response to satisfy the request without successful
   validation on the origin server.</source>
          <target state="translated">&quot;no-cache &quot;请求指令表示,在源服务器上没有成功验证的情况下,缓存不得使用存储的响应来满足请求。</target>
        </trans-unit>
        <trans-unit id="6e8f6289e5ab1b4d0a53bcb9e1b83dc08f1a97ef" translate="yes" xml:space="preserve">
          <source>The &quot;no-store&quot; request directive indicates that a cache MUST NOT
   store any part of either this request or any response to it.  This
   directive applies to both private and shared caches.  &quot;MUST NOT
   store&quot; in this context means that the cache MUST NOT intentionally
   store the information in non-volatile storage, and MUST make a
   best-effort attempt to remove the information from volatile storage
   as promptly as possible after forwarding it.

   This directive is NOT a reliable or sufficient mechanism for ensuring
   privacy.  In particular, malicious or compromised caches might not
   recognize or obey this directive, and communications networks might
   be vulnerable to eavesdropping.

   Note that if a request containing this directive is satisfied from a
   cache, the no-store request directive does not apply to the already
   stored response.</source>
          <target state="translated">no-store &quot;请求指令表示缓存不得存储该请求的任何部分或任何响应。这个指令适用于私有和共享缓存。&quot;MUST NOT存储 &quot;在此上下文中意味着缓存MUST NOT有意将信息存储在非易失性存储中,并且在转发信息后必须尽最大努力尽快从易失性存储中删除信息。此指令并非确保隐私的可靠或充分机制。特别是,恶意的或被入侵的缓存可能不识别或不遵守此指令,通信网络可能容易被窃听。请注意,如果从缓存中满足了包含此指令的请求,则不存储请求指令不适用于已经存储的响应。</target>
        </trans-unit>
        <trans-unit id="94cb482b3050dacf986c6ae2b51caac0dbd9698e" translate="yes" xml:space="preserve">
          <source>The &quot;no-store&quot; response directive indicates that a cache MUST NOT
   store any part of either the immediate request or response.  This
   directive applies to both private and shared caches.  &quot;MUST NOT
   store&quot; in this context means that the cache MUST NOT intentionally
   store the information in non-volatile storage, and MUST make a
   best-effort attempt to remove the information from volatile storage
   as promptly as possible after forwarding it.

   This directive is NOT a reliable or sufficient mechanism for ensuring
   privacy.  In particular, malicious or compromised caches might not
   recognize or obey this directive, and communications networks might
   be vulnerable to eavesdropping.</source>
          <target state="translated">no-store &quot;响应指令表示缓存不得存储即时请求或响应的任何部分。这个指令适用于私有和共享缓存。&quot;MUST NOT存储 &quot;在此上下文中意味着缓存MUST NOT有意将信息存储在非易失性存储中,并且在转发信息后必须尽最大努力尽快从易失性存储中删除信息。此指令并非确保隐私的可靠或充分机制。特别是,恶意的或被破坏的缓存可能不承认或不遵守这一指令,通信网络可能容易被窃听。</target>
        </trans-unit>
        <trans-unit id="246740c14df98a9984cb7c90b794ca4cbab5f083" translate="yes" xml:space="preserve">
          <source>The &quot;no-transform&quot; request directive indicates that an intermediary
   (whether or not it implements a cache) MUST NOT transform the
   payload, as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.7.2&quot;&gt;Section&amp;nbsp;5.7.2 of [RFC7230]&lt;/a&gt;.</source>
          <target state="translated">&amp;ldquo; no-transform&amp;rdquo;请求指令指示中介（无论是否实现缓存），均&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.7.2&quot;&gt;不得按照[RFC7230]第5.7.2节的&lt;/a&gt;规定转换有效负载。</target>
        </trans-unit>
        <trans-unit id="26ea1a7d280ad4fbc448761f675e1d88af0183a2" translate="yes" xml:space="preserve">
          <source>The &quot;no-transform&quot; response directive indicates that an intermediary
   (regardless of whether it implements a cache) MUST NOT transform the
   payload, as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.7.2&quot;&gt;Section&amp;nbsp;5.7.2 of [RFC7230]&lt;/a&gt;.</source>
          <target state="translated">&amp;ldquo; no-transform&amp;rdquo;响应指令指示中介（无论是否实现高速缓存）必须不转换有效载荷，如&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.7.2&quot;&gt;[RFC7230]的5.7.2节&lt;/a&gt;所定义。</target>
        </trans-unit>
        <trans-unit id="32d0e455b09d675a4810b93c728652a215d3ce1a" translate="yes" xml:space="preserve">
          <source>The &quot;only-if-cached&quot; request directive indicates that the client only
   wishes to obtain a stored response.  If it receives this directive, a
   cache SHOULD either respond using a stored response that is
   consistent with the other constraints of the request, or respond with 

   a 504 (Gateway Timeout) status code.  If a group of caches is being
   operated as a unified system with good internal connectivity, a
   member cache MAY forward such a request within that group of caches.</source>
          <target state="translated">&quot;only-if-cached &quot;请求指令表示客户机只希望获得一个存储的响应,如果收到这个指令,缓存应该使用与请求的其他约束条件一致的存储响应,或者用504(网关超时)状态码响应。如果收到这个指令,缓存应该使用与请求的其他约束一致的存储响应,或者用504(网关超时)状态码响应。如果一组缓存是作为一个统一的系统来运行的,具有良好的内部连接性,则成员缓存可以在该组缓存中转发这样的请求。</target>
        </trans-unit>
        <trans-unit id="b71570fd0465b4f17b5b1cc37961cb5f46e70128" translate="yes" xml:space="preserve">
          <source>The &quot;proxy-revalidate&quot; response directive has the same meaning as the
   must-revalidate response directive, except that it does not apply to
   private caches.</source>
          <target state="translated">&quot;proxy-revalidate &quot;响应指令与 &quot;must-revalidate &quot;响应指令含义相同,只是它不适用于私有缓存。</target>
        </trans-unit>
        <trans-unit id="f75c67cbc215fa2c33b29aa7195f38b3d21101a2" translate="yes" xml:space="preserve">
          <source>The &quot;public&quot; directive indicates that the response may be cached by any cache. This can be useful if pages with HTTP authentication, or response status codes that aren't normally cacheable, should now be cached.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e6876985726810eb54534e7e11d768f44365be0" translate="yes" xml:space="preserve">
          <source>The &quot;public&quot; directive indicates that the response may be cached by any cache. This can be useful, if pages with HTTP authentication or response status codes that aren't normally cacheable, should now be cached.</source>
          <target state="translated">&quot;public &quot;指令表示响应可以被任何缓存所缓存。这可能是有用的,如果有HTTP认证或响应状态码的页面通常不能被缓存,现在应该被缓存。</target>
        </trans-unit>
        <trans-unit id="4971052d2513145d16ddbb98b369e6dbbfe2ae90" translate="yes" xml:space="preserve">
          <source>The &quot;public&quot; response directive indicates that any cache MAY store
   the response, even if the response would normally be non-cacheable or
   cacheable only within a private cache.  (See &lt;a href=&quot;#section-3.2&quot;&gt;Section 3.2&lt;/a&gt; for
   additional details related to the use of public in response to a
   request containing Authorization, and &lt;a href=&quot;#section-3&quot;&gt;Section 3&lt;/a&gt; for details of how
   public affects responses that would normally not be stored, due to
   their status codes not being defined as cacheable by default; see
   &lt;a href=&quot;#section-4.2.2&quot;&gt;Section 4.2.2&lt;/a&gt;.)</source>
          <target state="translated">&amp;ldquo; public&amp;rdquo;响应指令指示任何缓存都可以存储响应，即使该响应通常是不可缓存的或仅可在私有缓存中缓存的。 （有关在响应包含授权的请求中使用public的其他详细信息，请参见&lt;a href=&quot;#section-3.2&quot;&gt;第3.2节&lt;/a&gt;；有关公共如何影响通常不会存储的响应的详细信息，请参见第&lt;a href=&quot;#section-3&quot;&gt;3节&lt;/a&gt;的详细信息，这是因为默认情况下其状态代码未定义为可缓存；请参阅 &lt;a href=&quot;#section-4.2.2&quot;&gt;第4.2.2节&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="3a53d63d810ef97bac3b0a2d1828ead948bae860" translate="yes" xml:space="preserve">
          <source>The &quot;realm&quot; authentication parameter is reserved for use by
   authentication schemes that wish to indicate a scope of protection.

   A protection space is defined by the canonical root URI (the scheme
   and authority components of the effective request URI; see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.5&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.5&quot;&gt;5.5 of [RFC7230]&lt;/a&gt;) of the server being accessed, in combination with
   the realm value if present.  These realms allow the protected
   resources on a server to be partitioned into a set of protection 

   spaces, each with its own authentication scheme and/or authorization
   database.  The realm value is a string, generally assigned by the
   origin server, that can have additional semantics specific to the
   authentication scheme.  Note that a response can have multiple
   challenges with the same auth-scheme but with different realms.

   The protection space determines the domain over which credentials can
   be automatically applied.  If a prior request has been authorized,
   the user agent MAY reuse the same credentials for all other requests
   within that protection space for a period of time determined by the
   authentication scheme, parameters, and/or user preferences (such as a
   configurable inactivity timeout).  Unless specifically allowed by the
   authentication scheme, a single protection space cannot extend
   outside the scope of its server.

   For historical reasons, a sender MUST only generate the quoted-string
   syntax.  Recipients might have to support both token and
   quoted-string syntax for maximum interoperability with existing
   clients that have been accepting both notations for a long time.</source>
          <target state="translated">&amp;ldquo;领域&amp;rdquo;认证参数保留给希望表示保护范围的认证方案使用。保护空间由规范的根URI定义（有效请求URI的方案和权限组件；请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.5&quot;&gt;[RFC7230] &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.5&quot;&gt;第&lt;/a&gt;5.5 节），并结合领域值（如果存在）。这些领域允许将服务器上受保护的资源划分为一组保护空间，每个保护空间都有其自己的身份验证方案和/或授权数据库。域值是一个字符串，通常由原始服务器分配，可以具有特定于身份验证方案的其他语义。请注意，使用相同的身份验证方案但使用不同领域的响应可能会面临多个挑战。保护空间确定可以在其上自动应用凭据的域。如果事先的请求已经被授权，则用户代理可以在相同的时间内对保护区域内的所有其他请求重复使用相同的证书，该时间由认证方案，参数，和/或用户首选项（例如可配置的不活动超时）。除非认证方案明确允许，否则单个保护空间不能扩展到其服务器范围之外。由于历史原因，发送方必须仅生成带引号的字符串语法。收件人可能必须同时支持令牌和引号字符串语法，以与已接受这两种符号很长时间的现有客户端实现最大的互操作性。接收者可能必须同时支持令牌和引号字符串语法，才能与已接受这两种符号很长时间的现有客户端实现最大的互操作性。接收者可能必须同时支持令牌和引号字符串语法，才能与已经接受这两种符号很长时间的现有客户端实现最大的互操作性。</target>
        </trans-unit>
        <trans-unit id="151e607c7a4575c8ca7477aa6824b0c9baed0674" translate="yes" xml:space="preserve">
          <source>The 'Basic' HTTP Authentication Scheme</source>
          <target state="translated">基本 &quot;HTTP认证方案</target>
        </trans-unit>
        <trans-unit id="31b797417bbccba76fa104cff98e9ec776af2bfd" translate="yes" xml:space="preserve">
          <source>The 'opaquelocktoken' URI scheme was defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC2518&lt;/a&gt;] (and
   registered by IANA) in order to create syntactically correct and
   easy-to-generate URIs out of UUIDs, intended to be used as lock
   tokens and to be unique across all resources for all time.

   An opaquelocktoken URI is constructed by concatenating the
   'opaquelocktoken' scheme with a UUID, along with an optional
   extension.  Servers can create new UUIDs for each new lock token.  If
   a server wishes to reuse UUIDs, the server MUST add an extension, and
   the algorithm generating the extension MUST guarantee that the same
   extension will never be used twice with the associated UUID.

     OpaqueLockToken-URI = &quot;opaquelocktoken:&quot; UUID [Extension]
       ; UUID is defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc4122#section-3&quot;&gt;Section&amp;nbsp;3 of [RFC4122]&lt;/a&gt;.  Note that LWS
       ; is not allowed between elements of
       ; this production.

     Extension = path
       ; path is defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.3&quot;&gt;Section&amp;nbsp;3.3 of [RFC3986]&lt;/a&gt;</source>
          <target state="translated">[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;opaquelocktoken&lt;/a&gt; ] URI方案在[ RFC2518 ]中定义（并由IANA注册），目的是从UUID中创建语法正确且易于生成的URI，旨在用作锁定令牌，并且在所有资源上都具有唯一性整天。 opaquelocktoken URI是通过将opaquelocktoken方案与UUID以及可选的扩展名并置而构造的。服务器可以为每个新的锁定令牌创建新的UUID。如果服务器希望重用​​UUID，则服务器必须添加扩展名，并且生成扩展名的算法必须保证同一扩展名不会与关联的UUID一起使用两次。 OpaqueLockToken-URI =&amp;ldquo; opaquelocktoken：&amp;rdquo; UUID [扩展名]； UUID在&lt;a href=&quot;https://tools.ietf.org/html/rfc4122#section-3&quot;&gt;[RFC4122]的第3节中&lt;/a&gt;定义。注意LWS;不允许元素之间；这个生产。扩展=路径;路径在&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.3&quot;&gt;[RFC3986]的3.3节中&lt;/a&gt;定义</target>
        </trans-unit>
        <trans-unit id="40135f19d49dbe171471ff8585f7f6ce0a630cbe" translate="yes" xml:space="preserve">
          <source>The 100 (Continue) status code indicates that the initial part of a
   request has been received and has not yet been rejected by the
   server.  The server intends to send a final response after the
   request has been fully received and acted upon.

   When the request contains an Expect header field that includes a
   100-continue expectation, the 100 response indicates that the server
   wishes to receive the request payload body, as described in
   &lt;a href=&quot;#section-5.1.1&quot;&gt;Section 5.1.1&lt;/a&gt;.  The client ought to continue sending the request and
   discard the 100 response.

   If the request did not contain an Expect header field containing the
   100-continue expectation, the client can simply discard this interim
   response.</source>
          <target state="translated">状态码为100（继续），表示请求的初始部分已收到，但尚未被服务器拒绝。服务器打算在请求被完全接收并执行后发送最终响应。当请求包含包含100个连续期望的Expect标头字段时，该100响应指示服务器希望接收请求有效内容主体，如&lt;a href=&quot;#section-5.1.1&quot;&gt;5.1.1节中&lt;/a&gt;所述 。客户端应继续发送请求，并丢弃100响应。如果请求不包含包含100个连续期望的Expect标头字段，则客户端可以简单地放弃此临时响应。</target>
        </trans-unit>
        <trans-unit id="0d01ba31f4c44842de2b726b8f94536c5aca0981" translate="yes" xml:space="preserve">
          <source>The 101 (Switching Protocols) status code indicates that the server
   understands and is willing to comply with the client's request, via
   the Upgrade header field (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6.7&quot;&gt;Section&amp;nbsp;6.7 of [RFC7230]&lt;/a&gt;), for a change in
   the application protocol being used on this connection.  The server 

   MUST generate an Upgrade header field in the response that indicates
   which protocol(s) will be switched to immediately after the empty
   line that terminates the 101 response.

   It is assumed that the server will only agree to switch protocols
   when it is advantageous to do so.  For example, switching to a newer
   version of HTTP might be advantageous over older versions, and
   switching to a real-time, synchronous protocol might be advantageous
   when delivering resources that use such features.</source>
          <target state="translated">101（交换协议）状态代码表示服务器理解并愿意通过&amp;ldquo;升级标头&amp;rdquo;字段（&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6.7&quot;&gt;[RFC7230]的6.7节&lt;/a&gt;）来更改此连接上使用的应用协议的客户端请求。服务器必须在响应中生成一个升级报头字段，该字段指示在终止101响应的空行之后将立即切换到哪些协议。假定只有在有利的情况下服务器才会同意切换协议。例如，切换到新版本的HTTP可能会比旧版本更有利，而在传递使用此类功能的资源时，切换到实时同步协议可能会更有利。</target>
        </trans-unit>
        <trans-unit id="c844ae29efcb21429730db5f3e66a84ced4ddb52" translate="yes" xml:space="preserve">
          <source>The 101 status code</source>
          <target state="translated">101状态码</target>
        </trans-unit>
        <trans-unit id="3ed3da1546f287aac58cc367f269cb9295233354" translate="yes" xml:space="preserve">
          <source>The 1xx (Informational) class of status code indicates an interim
   response for communicating connection status or request progress
   prior to completing the requested action and sending a final
   response. 1xx responses are terminated by the first empty line after
   the status-line (the empty line signaling the end of the header
   section).  Since HTTP/1.0 did not define any 1xx status codes, a
   server MUST NOT send a 1xx response to an HTTP/1.0 client.

   A client MUST be able to parse one or more 1xx responses received
   prior to a final response, even if the client does not expect one.  A
   user agent MAY ignore unexpected 1xx responses.

   A proxy MUST forward 1xx responses unless the proxy itself requested
   the generation of the 1xx response.  For example, if a proxy adds an
   &quot;Expect: 100-continue&quot; field when it forwards a request, then it need
   not forward the corresponding 100 (Continue) response(s).</source>
          <target state="translated">1xx(Informational)类状态码表示在完成请求动作和发送最终响应之前,用于传达连接状态或请求进度的临时响应。1xx响应由状态行后的第一个空行结束(空行表示头部分的结束)。由于HTTP/1.0没有定义任何1xx状态代码,服务器必须不向HTTP/1.0客户端发送1xx响应。客户端必须能够解析在最终响应之前收到的一个或多个1xx响应,即使客户端不期望有一个响应。用户代理可以忽略意外的1xx响应。代理必须转发1xx响应,除非代理本身要求生成1xx响应。例如,如果代理在转发请求时添加了 &quot;期待:100-continue &quot;字段,那么它就不需要转发相应的100(Continue)响应。</target>
        </trans-unit>
        <trans-unit id="73c66d189cbfbc42b2d25d8e68502411eaf75067" translate="yes" xml:space="preserve">
          <source>The 200 (OK) status code indicates that the request has succeeded.
   The payload sent in a 200 response depends on the request method.
   For the methods defined by this specification, the intended meaning
   of the payload can be summarized as:

   GET  a representation of the target resource;

   HEAD  the same representation as GET, but without the representation
      data;

   POST  a representation of the status of, or results obtained from,
      the action;

   PUT, DELETE  a representation of the status of the action;

   OPTIONS  a representation of the communications options;

   TRACE  a representation of the request message as received by the end
      server.

   Aside from responses to CONNECT, a 200 response always has a payload,
   though an origin server MAY generate a payload body of zero length.
   If no payload is desired, an origin server ought to send 204 (No
   Content) instead.  For CONNECT, no payload is allowed because the
   successful result is a tunnel, which begins immediately after the 200
   response header section.

   A 200 response is cacheable by default; i.e., unless otherwise
   indicated by the method definition or explicit cache controls (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;Section&amp;nbsp;4.2.2 of [RFC7234]&lt;/a&gt;).</source>
          <target state="translated">状态码200（OK）表示请求已成功。 200响应中发送的有效负载取决于请求方法。对于本规范定义的方法，有效载荷的预期含义可以概括为：GET目标资源的表示； HEAD与GET相同，但没有表示数据；张贴动作状态或结果的表示； PUT，DELETE表示动作状态； OPTIONS表示通讯选项；跟踪最终服务器接收到的请求消息的表示形式。除了对CONNECT的响应外，200响应始终具有有效负载，尽管原始服务器可以生成零长度的有效负载主体。如果不需要有效负载，原始服务器应该发送204（无内容）。对于CONNECT，不允许有效负载，因为成功的结果是隧道，该隧道在200响应头部分之后立即开始。默认情况下，可缓存200个响应；即，除非方法定义或显式缓存控件另有说明（请参见 &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;[RFC7234]的第4.2.2节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="fb652482ea97cc2ed5c9e3a8e7d46c55940f8e9f" translate="yes" xml:space="preserve">
          <source>The 201 (Created) status code indicates that the request has been
   fulfilled and has resulted in one or more new resources being
   created.  The primary resource created by the request is identified
   by either a Location header field in the response or, if no Location
   field is received, by the effective request URI.

   The 201 response payload typically describes and links to the
   resource(s) created.  See &lt;a href=&quot;#section-7.2&quot;&gt;Section 7.2&lt;/a&gt; for a discussion of the meaning
   and purpose of validator header fields, such as ETag and
   Last-Modified, in a 201 response.</source>
          <target state="translated">状态码201（已创建）表示请求已得到满足，并导致创建了一个或多个新资源。由请求创建的主要资源由响应中的Location头字段标识，或者，如果未接收到Location字段，则由有效请求URI标识。201响应有效负载通常描述并链接到创建的资源。有关201响应中验证程序头字段（例如ETag和Last-Modified）的含义和目的的讨论，请参见&lt;a href=&quot;#section-7.2&quot;&gt;7.2节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="abf13ad15a9e2fc228718670b40afce5ab72fe28" translate="yes" xml:space="preserve">
          <source>The 202 (Accepted) status code indicates that the request has been
   accepted for processing, but the processing has not been completed.
   The request might or might not eventually be acted upon, as it might
   be disallowed when processing actually takes place.  There is no
   facility in HTTP for re-sending a status code from an asynchronous
   operation.

   The 202 response is intentionally noncommittal.  Its purpose is to
   allow a server to accept a request for some other process (perhaps a
   batch-oriented process that is only run once per day) without
   requiring that the user agent's connection to the server persist
   until the process is completed.  The representation sent with this
   response ought to describe the request's current status and point to
   (or embed) a status monitor that can provide the user with an
   estimate of when the request will be fulfilled.</source>
          <target state="translated">202(接受)状态码表示请求已被接受处理,但处理尚未完成。该请求最终可能会被执行,也可能不会被执行,因为在实际处理时可能会被拒绝。在HTTP中,没有从异步操作中重新发送状态码的功能。202响应是有意的非承诺性的。它的目的是允许服务器接受对其他进程的请求(也许是一个每天只运行一次的面向批次的进程),而不要求用户代理与服务器的连接持续到进程完成。与这个响应一起发送的表示应该描述请求的当前状态,并指向(或嵌入)一个状态监测器,该监测器可以向用户提供请求何时会被满足的估计。</target>
        </trans-unit>
        <trans-unit id="9a4650176c01777123e8dd8f9e1788cc242ba3f7" translate="yes" xml:space="preserve">
          <source>The 203 (Non-Authoritative Information) status code indicates that
   the request was successful but the enclosed payload has been modified
   from that of the origin server's 200 (OK) response by a transforming
   proxy (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.7.2&quot;&gt;Section&amp;nbsp;5.7.2 of [RFC7230]&lt;/a&gt;).  This status code allows the
   proxy to notify recipients when a transformation has been applied,
   since that knowledge might impact later decisions regarding the
   content.  For example, future cache validation requests for the
   content might only be applicable along the same request path (through
   the same proxies).

   The 203 response is similar to the Warning code of 214 Transformation
   Applied (&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.5&quot;&gt;Section&amp;nbsp;5.5 of [RFC7234]&lt;/a&gt;), which has the advantage of being
   applicable to responses with any status code. 

   A 203 response is cacheable by default; i.e., unless otherwise
   indicated by the method definition or explicit cache controls (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;Section&amp;nbsp;4.2.2 of [RFC7234]&lt;/a&gt;).</source>
          <target state="translated">203（非权威信息）状态码表示请求成功，但是封装的有效负载已通过转换代理从源服务器200（正常）响应的有效负载中进行了修改（&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.7.2&quot;&gt;[RFC7230]的5.7.2节&lt;/a&gt;）。此状态代码允许代理在应用转换时通知收件人，因为该知识可能会影响以后有关内容的决定。例如，将来对内容的缓存验证请求可能仅适用于相同的请求路径（通过相同的代理）。 203响应类似于应用了214转换的警告代码（&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.5&quot;&gt;[RFC7234]的5.5节&lt;/a&gt;），其优点是适用于带有任何状态代码的响应。默认情况下，可以缓存203响应；即，除非方法定义或显式缓存控件另有说明（请参阅 &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;[RFC7234]的4.2.2节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="a03bafae0f2da4aa1963199aa2ef89f97a8ce60c" translate="yes" xml:space="preserve">
          <source>The 204 (No Content) status code indicates that the server has
   successfully fulfilled the request and that there is no additional
   content to send in the response payload body.  Metadata in the
   response header fields refer to the target resource and its selected
   representation after the requested action was applied.

   For example, if a 204 status code is received in response to a PUT
   request and the response contains an ETag header field, then the PUT
   was successful and the ETag field-value contains the entity-tag for
   the new representation of that target resource.

   The 204 response allows a server to indicate that the action has been
   successfully applied to the target resource, while implying that the
   user agent does not need to traverse away from its current &quot;document
   view&quot; (if any).  The server assumes that the user agent will provide
   some indication of the success to its user, in accord with its own
   interface, and apply any new or updated metadata in the response to
   its active representation.

   For example, a 204 status code is commonly used with document editing
   interfaces corresponding to a &quot;save&quot; action, such that the document
   being saved remains available to the user for editing.  It is also
   frequently used with interfaces that expect automated data transfers
   to be prevalent, such as within distributed version control systems.

   A 204 response is terminated by the first empty line after the header
   fields because it cannot contain a message body.

   A 204 response is cacheable by default; i.e., unless otherwise
   indicated by the method definition or explicit cache controls (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;Section&amp;nbsp;4.2.2 of [RFC7234]&lt;/a&gt;).</source>
          <target state="translated">状态码为204（无内容）指示服务器已成功满足请求，并且响应有效内容正文中没有其他要发送的内容。应用请求的操作后，响应头字段中的元数据引用目标资源及其选择的表示形式。例如，如果响应于PUT请求而接收到204状态代码，并且该响应包含ETag头字段，则PUT成功，并且ETag字段值包含该目标资源的新表示形式的实体标签。 204响应允许服务器指示该操作已成功应用于目标资源，同时暗示用户代理不需要遍历其当前&amp;ldquo;文档视图&amp;rdquo;（如果有）。服务器假定用户代理将根据其自己的界面向其用户提供成功的指示，并在响应中对其活动表示应用任何新的或更新的元数据。例如，204状态代码通常与与&amp;ldquo;保存&amp;rdquo;动作相对应的文档编辑界面一起使用，从而使得所保存的文档仍然可供用户用于编辑。它还经常与期望自动化数据传输盛行的接口一起使用，例如在分布式版本控制系统中。 204响应由标头字段之后的第一个空行终止，因为它不能包含消息正文。默认情况下，204响应是可缓存的；即除非方法定义或显式缓存控件另有说明（请参见 &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;[RFC7234]的第4.2.2节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="956b428452b332069240075e35ec925980806e62" translate="yes" xml:space="preserve">
          <source>The 205 (Reset Content) status code indicates that the server has
   fulfilled the request and desires that the user agent reset the
   &quot;document view&quot;, which caused the request to be sent, to its original
   state as received from the origin server.

   This response is intended to support a common data entry use case
   where the user receives content that supports data entry (a form,
   notepad, canvas, etc.), enters or manipulates data in that space, 

   causes the entered data to be submitted in a request, and then the
   data entry mechanism is reset for the next entry so that the user can
   easily initiate another input action.

   Since the 205 status code implies that no additional content will be
   provided, a server MUST NOT generate a payload in a 205 response.  In
   other words, a server MUST do one of the following for a 205
   response: a) indicate a zero-length body for the response by
   including a Content-Length header field with a value of 0; b)
   indicate a zero-length payload for the response by including a
   Transfer-Encoding header field with a value of chunked and a message
   body consisting of a single chunk of zero-length; or, c) close the
   connection immediately after sending the blank line terminating the
   header section.</source>
          <target state="translated">205(Reset Content)状态码表示服务器已经满足了该请求,并希望用户代理将导致发送请求的 &quot;文档视图 &quot;重置为从源服务器接收到的原始状态。该响应旨在支持一种常见的数据录入用例,即用户接收到支持数据录入的内容(表单、记事本、画布等),在该空间中输入或操作数据,使输入的数据在请求中提交,然后为下一次输入重置数据录入机制,以便用户可以轻松地发起另一个输入操作。由于205状态码意味着不会提供额外的内容,所以服务器必须不在205响应中生成有效载荷。换句话说,服务器必须对205响应做以下操作之一:a)通过包含一个值为0的Content-Length头字段来指示响应的零长度体;b)通过包含一个值为chunked的Transfer-Encoding头字段和一个由零长度的单一块组成的消息体来指示响应的零长度有效载荷;或者,c)在发送结束头部分的空行后立即关闭连接。</target>
        </trans-unit>
        <trans-unit id="07f77f37a20dc983a618d2c0027e2bd10388099a" translate="yes" xml:space="preserve">
          <source>The 206 (Partial Content) status code indicates that the server is
   successfully fulfilling a range request for the target resource by
   transferring one or more parts of the selected representation that
   correspond to the satisfiable ranges found in the request's Range
   header field (&lt;a href=&quot;#section-3.1&quot;&gt;Section 3.1&lt;/a&gt;).

   If a single part is being transferred, the server generating the 206
   response MUST generate a Content-Range header field, describing what
   range of the selected representation is enclosed, and a payload
   consisting of the range.  For example:

     HTTP/1.1 206 Partial Content
     Date: Wed, 15 Nov 1995 06:25:24 GMT
     Last-Modified: Wed, 15 Nov 1995 04:58:08 GMT
     Content-Range: bytes 21010-47021/47022
     Content-Length: 26012
     Content-Type: image/gif

     ... 26012 bytes of partial image data 

   If multiple parts are being transferred, the server generating the
   206 response MUST generate a &quot;multipart/byteranges&quot; payload, as
   defined in &lt;a href=&quot;#appendix-A&quot;&gt;Appendix A&lt;/a&gt;, and a Content-Type header field containing the
   multipart/byteranges media type and its required boundary parameter.
   To avoid confusion with single-part responses, a server MUST NOT
   generate a Content-Range header field in the HTTP header section of a
   multiple part response (this field will be sent in each part
   instead). 

   Within the header area of each body part in the multipart payload,
   the server MUST generate a Content-Range header field corresponding
   to the range being enclosed in that body part.  If the selected
   representation would have had a Content-Type header field in a 200
   (OK) response, the server SHOULD generate that same Content-Type
   field in the header area of each body part.  For example:

     HTTP/1.1 206 Partial Content
     Date: Wed, 15 Nov 1995 06:25:24 GMT
     Last-Modified: Wed, 15 Nov 1995 04:58:08 GMT
     Content-Length: 1741
     Content-Type: multipart/byteranges; boundary=THIS_STRING_SEPARATES

     --THIS_STRING_SEPARATES
     Content-Type: application/pdf
     Content-Range: bytes 500-999/8000

     ...the first range
     --THIS_STRING_SEPARATES
     Content-Type: application/pdf
     Content-Range: bytes 7000-7999/8000

     ...the second range
     --THIS_STRING_SEPARATES--

   When multiple ranges are requested, a server MAY coalesce any of the
   ranges that overlap, or that are separated by a gap that is smaller
   than the overhead of sending multiple parts, regardless of the order
   in which the corresponding byte-range-spec appeared in the received
   Range header field.  Since the typical overhead between parts of a
   multipart/byteranges payload is around 80 bytes, depending on the
   selected representation's media type and the chosen boundary
   parameter length, it can be less efficient to transfer many small
   disjoint parts than it is to transfer the entire selected
   representation.

   A server MUST NOT generate a multipart response to a request for a
   single range, since a client that does not request multiple parts
   might not support multipart responses.  However, a server MAY
   generate a multipart/byteranges payload with only a single body part
   if multiple ranges were requested and only one range was found to be
   satisfiable or only one range remained after coalescing.  A client
   that cannot process a multipart/byteranges response MUST NOT generate
   a request that asks for multiple ranges.

   When a multipart response payload is generated, the server SHOULD
   send the parts in the same order that the corresponding
   byte-range-spec appeared in the received Range header field, 

   excluding those ranges that were deemed unsatisfiable or that were
   coalesced into other ranges.  A client that receives a multipart
   response MUST inspect the Content-Range header field present in each
   body part in order to determine which range is contained in that body
   part; a client cannot rely on receiving the same ranges that it
   requested, nor the same order that it requested.

   When a 206 response is generated, the server MUST generate the
   following header fields, in addition to those required above, if the
   field would have been sent in a 200 (OK) response to the same
   request: Date, Cache-Control, ETag, Expires, Content-Location, and
   Vary.

   If a 206 is generated in response to a request with an If-Range
   header field, the sender SHOULD NOT generate other representation
   header fields beyond those required above, because the client is
   understood to already have a prior response containing those header
   fields.  Otherwise, the sender MUST generate all of the
   representation header fields that would have been sent in a 200 (OK)
   response to the same request.

   A 206 response is cacheable by default; i.e., unless otherwise
   indicated by explicit cache controls (see &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;Section&amp;nbsp;4.2.2 of
   [RFC7234]&lt;/a&gt;).</source>
          <target state="translated">206（部分内容）状态代码表示该服务器被成功地满足对目标资源的范围内请求通过将所选择的表示对应于满足的范围在请求的范围报头字段发现一个或多个部分（&lt;a href=&quot;#section-3.1&quot;&gt;第3.1节&lt;/a&gt;）。如果正在传送单个部分，则生成206响应的服务器务必生成一个Content-Range头字段，该字段描述所选择表示的范围，以及包含该范围的有效负载。例如：HTTP / 1.1 206部分内容日期：1995年11月15日星期三06:25:24 GMT上次修改时间：1995年11月15日星期三04:58:08 GMT内容范围：字节21010-47021 / 47022内容长度：26012内容类型：image / gif ... 26012字节的部分图像数据如果要传输多个部分，则生成206响应的服务器务必生成&amp;ldquo; multipart / byteranges&amp;rdquo;有效负载，如&lt;a href=&quot;#appendix-A&quot;&gt;附录A&lt;/a&gt;所定义，以及一个Content-Type标头字段，其中包含multipart / byteranges媒体类型及其必需的border参数。为避免与单部分响应混淆，服务器不得在多部分响应的HTTP标头部分中生成Content-Range标头字段（该字段将改为在每个部分中发送）。在多部分有效载荷中每个主体部分的头部区域内，服务器务必生成一个Content-Range头部字段，该字段与该主体部分中包含的范围相对应。如果所选的表示形式在200（确定）响应中将具有Content-Type头字段，则服务器应在每个正文部分的头区域中生成相同的Content-Type字段。例如：HTTP / 1.1 206部分内容日期：1995年11月15日星期三，格林尼治标准时间最后修改时间：星期三，1995年11月15日04:58:08 GMT内容长度：1741内容类型：multipart / byteranges； boundary = THIS_STRING_SEPARATES --THIS_STRING_SEPARATES内容类型：application / pdf内容范围：字节500-999 / 8000 ...第一个范围--THIS_STRING_SEPARATES内容类型：application / pdf内容范围：字节7000-7999 / 8000。 ..第二个范围--THIS_STRING_SEPARATES--当请求多个范围时，服务器可以合并任何重叠的范围，或者由小于发送多个部分的开销的间隙分隔的范围，无论顺序如何相应的字节范围规范出现在接收到的Range标头字段中。由于多部分/字节范围有效负载的各个部分之间的典型开销约为80个字节，取决于所选表示形式的媒体类型和所选边界参数长度，传输许多小的不连续部分的效率可能比传输整个所选表示形式的效率低。服务器不得针对单个范围的请求生成多部分响应，因为不请求多个部分的客户端可能不支持多部分响应。但是，如果请求多个范围并且发现只有一个范围是可满足的，或者合并后仅剩下一个范围，则服务器可以只用一个主体部分生成多部分/字节范围的有效载荷。不能处理多部分/字节范围响应的客户端不得生成请求多个范围的请求。生成多部分响应有效负载时，服务器应按照接收到的Range标头字段中出现的相应字节范围规范的顺序发送各部分，但不包括那些认为不满意或合并为其他范围的范围。收到多部分响应的客户端必须检查每个主体部分中存在的Content-Range标头字段，以确定该主体部分中包含哪个范围；客户不能依赖于接收与请求相同的范围，也不能依赖于请求的相同顺序。生成206响应时，如果上面的字段必须在对同一请求的200（OK）响应中发送，则除上述要求的字段外，服务器还必须生成以下标头字段：Date，Cache-Control，ETag，过期，内容位置和变化。如果响应带有If-Range头字段的请求而生成206，则发件人不应该生成除上面要求的字段之外的其他表示头字段，因为应该理解客户端已经具有包含这些头字段的先前响应。否则，发送者必须生成所有在200（OK）响应中发送给相同请求的表示头域。默认情况下，206响应是可缓存的；即，除非明确的缓存控制另有说明（请参见发送方必须生成所有200个（确定）响应中已发送给同一请求的表示形式标头字段。默认情况下，206响应是可缓存的；即，除非明确的缓存控制另有说明（请参见发送方必须生成所有200个（确定）响应中已发送给同一请求的表示形式标头字段。默认情况下，206响应是可缓存的；即，除非明确的缓存控制另有说明（请参见&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;[RFC7234]的第4.2.2节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="a96c2c15082f71e24cf514861b9f6649cccdc6d7" translate="yes" xml:space="preserve">
          <source>The 207 (Multi-Status) status code provides status for multiple
   independent operations (see &lt;a href=&quot;#section-13&quot;&gt;Section 13&lt;/a&gt; for more information).</source>
          <target state="translated">207（多状态）状态代码提供了多个独立操作的状态（更多信息，请参见&lt;a href=&quot;#section-13&quot;&gt;第13节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="21abf74518ada2943ea07b28d70fb2e06dfc8c14" translate="yes" xml:space="preserve">
          <source>The 2xx (Successful) class of status code indicates that the client's
   request was successfully received, understood, and accepted.</source>
          <target state="translated">2xx(成功)类状态码表示客户的请求被成功接收、理解和接受。</target>
        </trans-unit>
        <trans-unit id="8091edce5c825502d2461f4be1e98fbbf163fbf9" translate="yes" xml:space="preserve">
          <source>The 300 (Multiple Choices) status code indicates that the target
   resource has more than one representation, each with its own more
   specific identifier, and information about the alternatives is being
   provided so that the user (or user agent) can select a preferred
   representation by redirecting its request to one or more of those
   identifiers.  In other words, the server desires that the user agent
   engage in reactive negotiation to select the most appropriate
   representation(s) for its needs (&lt;a href=&quot;#section-3.4&quot;&gt;Section 3.4&lt;/a&gt;).

   If the server has a preferred choice, the server SHOULD generate a
   Location header field containing a preferred choice's URI reference.
   The user agent MAY use the Location field value for automatic
   redirection.

   For request methods other than HEAD, the server SHOULD generate a
   payload in the 300 response containing a list of representation
   metadata and URI reference(s) from which the user or user agent can
   choose the one most preferred.  The user agent MAY make a selection
   from that list automatically if it understands the provided media
   type.  A specific format for automatic selection is not defined by
   this specification because HTTP tries to remain orthogonal to the
   definition of its payloads.  In practice, the representation is
   provided in some easily parsed format believed to be acceptable to
   the user agent, as determined by shared design or content
   negotiation, or in some commonly accepted hypertext format. 

   A 300 response is cacheable by default; i.e., unless otherwise
   indicated by the method definition or explicit cache controls (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;Section&amp;nbsp;4.2.2 of [RFC7234]&lt;/a&gt;).

      Note: The original proposal for the 300 status code defined the
      URI header field as providing a list of alternative
      representations, such that it would be usable for 200, 300, and
      406 responses and be transferred in responses to the HEAD method.
      However, lack of deployment and disagreement over syntax led to
      both URI and Alternates (a subsequent proposal) being dropped from
      this specification.  It is possible to communicate the list using
      a set of Link header fields [&lt;a href=&quot;https://tools.ietf.org/html/rfc5988&quot;&gt;RFC5988&lt;/a&gt;], each with a relationship of
      &quot;alternate&quot;, though deployment is a chicken-and-egg problem.</source>
          <target state="translated">状态码300（多项选择）指示目标资源具有多个表示形式，每个表示形式都有其自己的更具体的标识符，并且正在提供有关替代项的信息，以便用户（或用户代理）可以通过以下方式选择首选表示形式：将其请求重定向到一个或多个这些标识符。换句话说，服务器希望用户代理参与反应式协商，以选择最适合其需求的表示形式（&lt;a href=&quot;#section-3.4&quot;&gt;第3.4节）&lt;/a&gt;）。如果服务器有一个首选选项，则服务器应该生成一个Location头字段，其中包含首选选项的URI参考。用户代理可以使用位置字段值进行自动重定向。对于除HEAD以外的请求方法，服务器应在300响应中生成一个有效载荷，该有效载荷包含表示元数据和URI参考的列表，用户或用户代理可以从中选择最优选的一个。如果用户代理理解提供的媒体类型，可以自动从该列表中进行选择。该规范未定义用于自动选择的特定格式，因为HTTP尝试保持与其有效负载的定义正交。在实践中，该表示以共享设计或内容协商确定的某种易于解析的格式被认为是用户代理可接受的格式提供，或以某种普遍接受的超文本格式提供。默认情况下，300响应是可缓存的；即，除非方法定义或显式缓存控件另有说明（请参见 &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;[RFC7234]的第4.2.2节&lt;/a&gt;）。注意：300状态代码的原始建议将URI标头字段定义为提供其他表示形式的列表，以便它可用于200、300和406响应，并在对HEAD方法的响应中进行传输。但是，由于缺乏部署和语法上的分歧，导致URI和Alternates（后续提案）都从该规范中删除。可以使用一组链接头字段[ &lt;a href=&quot;https://tools.ietf.org/html/rfc5988&quot;&gt;RFC5988&lt;/a&gt; ] 来传达列表，每个字段都具有&amp;ldquo;替代&amp;rdquo;关系，尽管部署是鸡到蛋的问题。</target>
        </trans-unit>
        <trans-unit id="e89e16d2ad3f5f0023fdef413da39c2201b7eab8" translate="yes" xml:space="preserve">
          <source>The 301 (Moved Permanently) status code indicates that the target
   resource has been assigned a new permanent URI and any future
   references to this resource ought to use one of the enclosed URIs.
   Clients with link-editing capabilities ought to automatically re-link
   references to the effective request URI to one or more of the new
   references sent by the server, where possible.

   The server SHOULD generate a Location header field in the response
   containing a preferred URI reference for the new permanent URI.  The
   user agent MAY use the Location field value for automatic
   redirection.  The server's response payload usually contains a short
   hypertext note with a hyperlink to the new URI(s).

      Note: For historical reasons, a user agent MAY change the request
      method from POST to GET for the subsequent request.  If this
      behavior is undesired, the 307 (Temporary Redirect) status code
      can be used instead.

   A 301 response is cacheable by default; i.e., unless otherwise
   indicated by the method definition or explicit cache controls (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;Section&amp;nbsp;4.2.2 of [RFC7234]&lt;/a&gt;).</source>
          <target state="translated">301（永久移动）状态代码表示已为目标资源分配了新的永久URI，并且对该资源的任何将来引用都应使用其中的一个URI。具有链接编辑功能的客户端应在可能的情况下自动将对有效请求URI的引用重新链接到服务器发送的一个或多个新引用。服务器应该在响应中生成一个Location头字段，其中包含新的永久URI的首选URI引用。用户代理可以使用位置字段值进行自动重定向。服务器的响应有效负载通常包含简短的超文本注释，并带有指向新URI的超链接。注意：由于历史原因，用户代理可以为后续请求将请求方法从POST更改为GET。如果不希望出现这种情况，则可以改用307（临时重定向）状态代码。默认情况下，可以缓存301响应；即，除非方法定义或显式缓存控件另有说明（请参见 &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;[RFC7234]的第4.2.2节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="9ef3872d9a97e7902a4418ab95fd36038bea8203" translate="yes" xml:space="preserve">
          <source>The 302 (Found) status code indicates that the target resource
   resides temporarily under a different URI.  Since the redirection
   might be altered on occasion, the client ought to continue to use the
   effective request URI for future requests. 

   The server SHOULD generate a Location header field in the response
   containing a URI reference for the different URI.  The user agent MAY
   use the Location field value for automatic redirection.  The server's
   response payload usually contains a short hypertext note with a
   hyperlink to the different URI(s).

      Note: For historical reasons, a user agent MAY change the request
      method from POST to GET for the subsequent request.  If this
      behavior is undesired, the 307 (Temporary Redirect) status code
      can be used instead.</source>
          <target state="translated">302(Found)状态码表示目标资源暂时驻留在不同的URI下。由于重定向可能偶尔会被改变,客户机应该在未来的请求中继续使用有效的请求URI。服务器应该在响应中生成一个Location头字段,包含不同URI的URI引用。用户代理可以使用Location字段的值进行自动重定向。服务器的响应有效载荷通常包含一个简短的超文本注释,其中有指向不同URI的超链接。注意:由于历史原因,用户代理在后续请求中可以将请求方法从POST改为GET。如果不希望出现这种行为,可以使用307(临时重定向)状态码来代替。</target>
        </trans-unit>
        <trans-unit id="f98486b9c7317cc8a6b18febd1348ba3209011c0" translate="yes" xml:space="preserve">
          <source>The 303 (See Other) status code indicates that the server is
   redirecting the user agent to a different resource, as indicated by a
   URI in the Location header field, which is intended to provide an
   indirect response to the original request.  A user agent can perform
   a retrieval request targeting that URI (a GET or HEAD request if
   using HTTP), which might also be redirected, and present the eventual
   result as an answer to the original request.  Note that the new URI
   in the Location header field is not considered equivalent to the
   effective request URI.

   This status code is applicable to any HTTP method.  It is primarily
   used to allow the output of a POST action to redirect the user agent
   to a selected resource, since doing so provides the information
   corresponding to the POST response in a form that can be separately
   identified, bookmarked, and cached, independent of the original
   request.

   A 303 response to a GET request indicates that the origin server does
   not have a representation of the target resource that can be
   transferred by the server over HTTP.  However, the Location field
   value refers to a resource that is descriptive of the target
   resource, such that making a retrieval request on that other resource
   might result in a representation that is useful to recipients without
   implying that it represents the original target resource.  Note that
   answers to the questions of what can be represented, what
   representations are adequate, and what might be a useful description
   are outside the scope of HTTP.

   Except for responses to a HEAD request, the representation of a 303
   response ought to contain a short hypertext note with a hyperlink to
   the same URI reference provided in the Location header field.</source>
          <target state="translated">303(See Other)状态码表示服务器正在将用户代理重定向到不同的资源,如Location头字段中的URI所示,该URI旨在为原始请求提供间接响应。用户代理可以执行针对该URI的检索请求(如果使用HTTP,则为GET或HEAD请求),该请求也可能被重定向,并将最终的结果作为对原始请求的回答呈现出来。请注意,Location头域中的新URI不被认为等同于有效请求URI。这个状态码适用于任何HTTP方法。它主要用于允许POST操作的输出将用户代理重定向到选定的资源,因为这样做可以以独立于原始请求的形式提供POST响应对应的信息,可以单独识别、书签和缓存。对GET请求的303响应表明原服务器没有可以由服务器通过HTTP传输的目标资源的表示。但是,Location字段的值指的是对目标资源有描述性的资源,这样,在该其他资源上进行检索请求可能会得到一个对接收者有用的表示,而不意味着它代表了原始目标资源。请注意,关于什么可以被表示,什么表示是足够的,以及什么可能是有用的描述等问题的答案不在HTTP的范围之内。除了对HEAD请求的响应外,303响应的表示应该包含一个简短的超文本说明,并带有一个超链接,指向在Location头域中提供的相同URI引用。</target>
        </trans-unit>
        <trans-unit id="1310056b9a11237a35ab8cb0a6c54f0611f4bdbf" translate="yes" xml:space="preserve">
          <source>The 304 (Not Modified) status code indicates that a conditional GET
   or HEAD request has been received and would have resulted in a 200
   (OK) response if it were not for the fact that the condition
   evaluated to false.  In other words, there is no need for the server
   to transfer a representation of the target resource because the
   request indicates that the client, which made the request 

   conditional, already has a valid representation; the server is
   therefore redirecting the client to make use of that stored
   representation as if it were the payload of a 200 (OK) response.

   The server generating a 304 response MUST generate any of the
   following header fields that would have been sent in a 200 (OK)
   response to the same request: Cache-Control, Content-Location, Date,
   ETag, Expires, and Vary.

   Since the goal of a 304 response is to minimize information transfer
   when the recipient already has one or more cached representations, a
   sender SHOULD NOT generate representation metadata other than the
   above listed fields unless said metadata exists for the purpose of
   guiding cache updates (e.g., Last-Modified might be useful if the
   response does not have an ETag field).

   Requirements on a cache that receives a 304 response are defined in
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.3.4&quot;&gt;Section&amp;nbsp;4.3.4 of [RFC7234]&lt;/a&gt;.  If the conditional request originated
   with an outbound client, such as a user agent with its own cache
   sending a conditional GET to a shared proxy, then the proxy SHOULD
   forward the 304 response to that client.

   A 304 response cannot contain a message-body; it is always terminated
   by the first empty line after the header fields.</source>
          <target state="translated">304（未修改）状态码表示已接收到条件GET或HEAD请求，如果不是因为条件评估为假，则将导致200（确定）响应。换句话说，服务器不需要传输目标资源的表示形式，因为该请求表明以请求为条件的客户端已经具有有效的表示形式。因此，服务器正在重定向客户端以利用存储的表示形式，就好像它是200（正常）响应的有效负载一样。生成304响应的服务器必须生成以下任何报头字段，这些字段将在对同一请求的200（OK）响应中发送：Cache-Control，Content-Location，Date，ETag，Expires和Vary。由于304响应的目标是在接收者已经具有一个或多个缓存的表示形式时将信息传递减至最少，因此，除非存在上述元数据用于指导缓存更新（例如，如果响应中没有ETag字段，则Last-Modified可能有用。在304中定义了对接收304响应的缓存的要求在304中定义了对接收304响应的缓存的要求在304中定义了对接收304响应的缓存的要求 &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.3.4&quot;&gt;[RFC7234]的第4.3.4节&lt;/a&gt;。如果条件请求是由出站客户端发起的，例如具有自己的缓存的用户代理将有条件的GET发送到共享代理，则代理应将304响应转发给该客户端。 304响应不能包含消息正文；它总是由标题字段之后的第一个空行终止。</target>
        </trans-unit>
        <trans-unit id="d962e03df1dabcc2ec176a4937563211d6cfd2cc" translate="yes" xml:space="preserve">
          <source>The 305 (Use Proxy) status code was defined in a previous version of
   this specification and is now deprecated (Appendix B).</source>
          <target state="translated">305(Use Proxy)状态码在本规范以前的版本中定义过,现在已经废弃(附录B)。</target>
        </trans-unit>
        <trans-unit id="bbf9b7a6555633242c214ea7db29148fae94dc7d" translate="yes" xml:space="preserve">
          <source>The 306 status code was defined in a previous version of this
   specification, is no longer used, and the code is reserved.</source>
          <target state="translated">306状态码在本规范以前的版本中定义过,现在已经不再使用,该代码被保留。</target>
        </trans-unit>
        <trans-unit id="4404c364ec3064905980ead43e5d3f9ef55ccb2e" translate="yes" xml:space="preserve">
          <source>The 306 status code was used in a previous version of the
   specification, is no longer used, and the code is reserved.</source>
          <target state="translated">306状态码在以前的规范版本中使用过,现在不再使用,该代码为保留代码。</target>
        </trans-unit>
        <trans-unit id="efa8bf4f32294cae0ef47f6deb993b93eec7981d" translate="yes" xml:space="preserve">
          <source>The 307 (Temporary Redirect) status code indicates that the target
   resource resides temporarily under a different URI and the user agent
   MUST NOT change the request method if it performs an automatic
   redirection to that URI.  Since the redirection can change over time,
   the client ought to continue using the original effective request URI
   for future requests.

   The server SHOULD generate a Location header field in the response
   containing a URI reference for the different URI.  The user agent MAY
   use the Location field value for automatic redirection.  The server's
   response payload usually contains a short hypertext note with a
   hyperlink to the different URI(s).

      Note: This status code is similar to 302 (Found), except that it
      does not allow changing the request method from POST to GET.  This
      specification defines no equivalent counterpart for 301 (Moved
      Permanently) ([&lt;a href=&quot;https://tools.ietf.org/html/rfc7238&quot;&gt;RFC7238&lt;/a&gt;], however, defines the status code 308
      (Permanent Redirect) for this purpose).</source>
          <target state="translated">The 307 (Temporary Redirect) status code indicates that the target resource resides temporarily under a different URI and the user agent MUST NOT change the request method if it performs an automatic redirection to that URI. Since the redirection can change over time, the client ought to continue using the original effective request URI for future requests. The server SHOULD generate a Location header field in the response containing a URI reference for the different URI. The user agent MAY use the Location field value for automatic redirection. The server's response payload usually contains a short hypertext note with a hyperlink to the different URI(s). Note: This status code is similar to 302 (Found), except that it does not allow changing the request method from POST to GET. This specification defines no equivalent counterpart for 301 (Moved Permanently) ([&lt;a href=&quot;https://tools.ietf.org/html/rfc7238&quot;&gt;&lt;/a&gt;但是，RFC7238为此定义了状态代码308（永久重定向）。</target>
        </trans-unit>
        <trans-unit id="0b552dedeef68a9fc1c9bedf80fe2f970232311c" translate="yes" xml:space="preserve">
          <source>The 3xx (Redirection) class of status code indicates that further
   action needs to be taken by the user agent in order to fulfill the
   request.  If a Location header field (&lt;a href=&quot;#section-7.1.2&quot;&gt;Section 7.1.2&lt;/a&gt;) is provided, the
   user agent MAY automatically redirect its request to the URI
   referenced by the Location field value, even if the specific status
   code is not understood.  Automatic redirection needs to done with
   care for methods not known to be safe, as defined in &lt;a href=&quot;#section-4.2.1&quot;&gt;Section 4.2.1&lt;/a&gt;,
   since the user might not wish to redirect an unsafe request.

   There are several types of redirects:

   1.  Redirects that indicate the resource might be available at a
       different URI, as provided by the Location field, as in the
       status codes 301 (Moved Permanently), 302 (Found), and 307
       (Temporary Redirect).

   2.  Redirection that offers a choice of matching resources, each
       capable of representing the original request target, as in the
       300 (Multiple Choices) status code.

   3.  Redirection to a different resource, identified by the Location
       field, that can represent an indirect response to the request, as
       in the 303 (See Other) status code.

   4.  Redirection to a previously cached result, as in the 304 (Not
       Modified) status code.

      Note: In HTTP/1.0, the status codes 301 (Moved Permanently) and
      302 (Found) were defined for the first type of redirect
      (&lt;a href=&quot;https://tools.ietf.org/html/rfc1945#section-9.3&quot;&gt;[RFC1945], Section&amp;nbsp;9.3&lt;/a&gt;).  Early user agents split on whether the
      method applied to the redirect target would be the same as the 

      original request or would be rewritten as GET.  Although HTTP
      originally defined the former semantics for 301 and 302 (to match
      its original implementation at CERN), and defined 303 (See Other)
      to match the latter semantics, prevailing practice gradually
      converged on the latter semantics for 301 and 302 as well.  The
      first revision of HTTP/1.1 added 307 (Temporary Redirect) to
      indicate the former semantics without being impacted by divergent
      practice.  Over 10 years later, most user agents still do method
      rewriting for 301 and 302; therefore, this specification makes
      that behavior conformant when the original request is POST.

   A client SHOULD detect and intervene in cyclical redirections (i.e.,
   &quot;infinite&quot; redirection loops).

      Note: An earlier version of this specification recommended a
      maximum of five redirections (&lt;a href=&quot;https://tools.ietf.org/html/rfc2068#section-10.3&quot;&gt;[RFC2068], Section&amp;nbsp;10.3&lt;/a&gt;).  Content
      developers need to be aware that some clients might implement such
      a fixed limitation.</source>
          <target state="translated">状态代码的3xx（重定向）类指示用户代理需要采取进一步的措施才能满足请求。如果提供了位置标头字段（&lt;a href=&quot;#section-7.1.2&quot;&gt;第7.1.2节&lt;/a&gt;），则即使不理解特定的状态代码，用户代理也可以自动将其请求重定向到位置字段值所引用的URI。自动重定向需要谨慎处理&lt;a href=&quot;#section-4.2.1&quot;&gt;4.2.1节中&lt;/a&gt;定义的不安全的方法，因为用户可能不希望重定向不安全的请求。重定向类型有几种：1.重定向，指示资源可能在不同的URI上可用，如位置字段所提供的，如状态码301（永久移动），302（已找到）和307（临时重定向） ）。 2.重定向，它提供了一系列匹配资源，每个资源都可以代表原始请求目标，如300（多项选择）状态码中所示。 3.重定向到&amp;ldquo;位置&amp;rdquo;字段标识的另一个资源，该资源可以表示对请求的间接响应，如303（请参阅其他）状态码中所示。 4.重定向到先前缓存的结果，如304（未修改）状态码中所示。注意：在HTTP / 1.0中，状态代码301（永久移动）和302（已找到）是为第一种重定向类型（&lt;a href=&quot;https://tools.ietf.org/html/rfc1945#section-9.3&quot;&gt;[RFC1945]，第9.3节&lt;/a&gt;）。早期的用户代理在应用于重定向目标的方法与原始请求相同还是将其重写为GET上存在分歧。尽管HTTP最初为301和302定义了前者的语义（以匹配其在CERN的原始实现），并定义了303（请参阅&amp;ldquo;其他&amp;rdquo;）以匹配后者的语义，但流行的做法也逐渐收敛于301和302的后一个语义。 HTTP / 1.1的第一个修订版添加了307（临时重定向），以指示以前的语义，而不受不同实践的影响。在10年后的今天，大多数用户代理仍然为301和302进行方法重写；因此，当原始请求为POST时，此规范使该行为一致。客户端应该检测并干预周期性重定向（即&amp;ldquo;无限&amp;rdquo;重定向循环）。注意：此规范的较早版本建议最多进行五个重定向（&lt;a href=&quot;https://tools.ietf.org/html/rfc2068#section-10.3&quot;&gt;[RFC2068]，第10.3节&lt;/a&gt;）。内容开发人员需要意识到某些客户端可能会实施这样的固定限制。</target>
        </trans-unit>
        <trans-unit id="334ca39a91da7c29dc27f4fe5d1fa671a87b47b0" translate="yes" xml:space="preserve">
          <source>The 400 (Bad Request) status code indicates that the server cannot or
   will not process the request due to something that is perceived to be
   a client error (e.g., malformed request syntax, invalid request
   message framing, or deceptive request routing).</source>
          <target state="translated">400(坏请求)状态码表示服务器不能或不会处理该请求,原因是被认为是客户端错误(例如,错误的请求语法、无效的请求消息框架或欺骗性的请求路由)。</target>
        </trans-unit>
        <trans-unit id="29689450f4d2cb77a3efa906a5294a262a4c2452" translate="yes" xml:space="preserve">
          <source>The 401 (Unauthorized) status code indicates that the request has not
   been applied because it lacks valid authentication credentials for
   the target resource.  The server generating a 401 response MUST send
   a WWW-Authenticate header field (&lt;a href=&quot;#section-4.1&quot;&gt;Section 4.1&lt;/a&gt;) containing at least one
   challenge applicable to the target resource.

   If the request included authentication credentials, then the 401
   response indicates that authorization has been refused for those
   credentials.  The user agent MAY repeat the request with a new or
   replaced Authorization header field (&lt;a href=&quot;#section-4.2&quot;&gt;Section 4.2&lt;/a&gt;).  If the 401
   response contains the same challenge as the prior response, and the
   user agent has already attempted authentication at least once, then
   the user agent SHOULD present the enclosed representation to the
   user, since it usually contains relevant diagnostic information.</source>
          <target state="translated">401（未经授权）状态码表示该请求尚未应用，因为它缺少目标资源的有效身份验证凭据。生成401响应的服务器必须发送WWW-Authenticate头域（&lt;a href=&quot;#section-4.1&quot;&gt;第4.1节&lt;/a&gt;），其中包含至少一个适用于目标资源的质询。如果请求包括身份验证凭据，则401响应指示已拒绝这些凭据的授权。用户代理可以用新的或替换的Authorization标头字段（&lt;a href=&quot;#section-4.2&quot;&gt;第4.2节）&lt;/a&gt;重复请求。）。如果401响应包含与先前响应相同的质询，并且用户代理已经尝试了至少一次身份验证，则用户代理应该向用户呈现随附的表示，因为它通常包含相关的诊断信息。</target>
        </trans-unit>
        <trans-unit id="8a32cd96fa39bd8cea46e432f2bd383665a1ab08" translate="yes" xml:space="preserve">
          <source>The 402 (Payment Required) status code is reserved for future use.</source>
          <target state="translated">402(需要付款)状态码是保留给将来使用的。</target>
        </trans-unit>
        <trans-unit id="79339f2e8ca3d487560bd812a6eea754f58b8f81" translate="yes" xml:space="preserve">
          <source>The 403 (Forbidden) status code indicates that the server understood
   the request but refuses to authorize it.  A server that wishes to
   make public why the request has been forbidden can describe that
   reason in the response payload (if any).

   If authentication credentials were provided in the request, the
   server considers them insufficient to grant access.  The client
   SHOULD NOT automatically repeat the request with the same
   credentials.  The client MAY repeat the request with new or different
   credentials.  However, a request might be forbidden for reasons
   unrelated to the credentials.

   An origin server that wishes to &quot;hide&quot; the current existence of a
   forbidden target resource MAY instead respond with a status code of
   404 (Not Found).</source>
          <target state="translated">403(Forbidden)状态码表示服务器理解了请求,但拒绝授权。服务器如果希望公开请求被禁止的原因,可以在响应有效载荷中描述该原因(如果有的话)。如果在请求中提供了认证凭证,服务器认为这些凭证不足以授予访问。客户端不应该用相同的凭证自动重复请求。客户端可以用新的或不同的凭证重复请求。但是,请求可能会因为与凭证无关的原因而被禁止。希望 &quot;隐藏 &quot;被禁止的目标资源的当前存在的源服务器可以用404(未找到)的状态码来响应。</target>
        </trans-unit>
        <trans-unit id="e3def26038d6d95647ba8eb940680d2af264c867" translate="yes" xml:space="preserve">
          <source>The 404 (Not Found) status code indicates that the origin server did
   not find a current representation for the target resource or is not
   willing to disclose that one exists.  A 404 status code does not
   indicate whether this lack of representation is temporary or
   permanent; the 410 (Gone) status code is preferred over 404 if the
   origin server knows, presumably through some configurable means, that
   the condition is likely to be permanent.

   A 404 response is cacheable by default; i.e., unless otherwise
   indicated by the method definition or explicit cache controls (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;Section&amp;nbsp;4.2.2 of [RFC7234]&lt;/a&gt;).</source>
          <target state="translated">404（未找到）状态代码表示原始服务器未找到目标资源的当前表示，或不愿意透露该资源的存在。 404状态代码并不表示这种缺乏表示是暂时的还是永久的；如果原始服务器大概通过某种可配置的方式得知该条件很可能是永久性的，则与404相比，首选410（已用）状态码。默认情况下，404响应是可缓存的；即，除非方法定义或显式缓存控件另有说明（请参阅 &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;[RFC7234]的4.2.2节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="139fdce0aa53e1ec81629bd1c9fe084f1e273d10" translate="yes" xml:space="preserve">
          <source>The 405 (Method Not Allowed) status code indicates that the method
   received in the request-line is known by the origin server but not
   supported by the target resource.  The origin server MUST generate an
   Allow header field in a 405 response containing a list of the target
   resource's currently supported methods.

   A 405 response is cacheable by default; i.e., unless otherwise
   indicated by the method definition or explicit cache controls (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;Section&amp;nbsp;4.2.2 of [RFC7234]&lt;/a&gt;).</source>
          <target state="translated">状态代码405（不允许使用方法）指示请求行中接收到的方法对于源服务器是已知的，但目标资源不支持。源服务器必须在405响应中生成允许标头字段，其中包含目标资源当前支持的方法的列表。默认情况下，405响应是可缓存的；即，除非方法定义或显式缓存控件另有说明（请参阅 &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;[RFC7234]的4.2.2节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="ee79d34ebbf5f698fa72e9938ee69213ae4643fa" translate="yes" xml:space="preserve">
          <source>The 406 (Not Acceptable) status code indicates that the target
   resource does not have a current representation that would be
   acceptable to the user agent, according to the proactive negotiation
   header fields received in the request (&lt;a href=&quot;#section-5.3&quot;&gt;Section 5.3&lt;/a&gt;), and the server
   is unwilling to supply a default representation.

   The server SHOULD generate a payload containing a list of available
   representation characteristics and corresponding resource identifiers
   from which the user or user agent can choose the one most
   appropriate.  A user agent MAY automatically select the most
   appropriate choice from that list.  However, this specification does
   not define any standard for such automatic selection, as described in
   &lt;a href=&quot;#section-6.4.1&quot;&gt;Section 6.4.1&lt;/a&gt;.</source>
          <target state="translated">406（不可接受）状态码表示，根据请求中收到的主动协商报头字段（&lt;a href=&quot;#section-5.3&quot;&gt;第5.3节&lt;/a&gt;），目标资源不具有用户代理可接受的当前表示，并且服务器不愿意提供默认表示。服务器应该产生一个有效载荷，其中包含一列可用的表示特征和相应的资源标识符，用户或用户代理可以从中选择最合适的一个。用户代理可以自动从该列表中选择最合适的选择。但是，本规范并未为此类自动选择定义任何标准，如&lt;a href=&quot;#section-6.4.1&quot;&gt;6.4.1节&lt;/a&gt;所述 。</target>
        </trans-unit>
        <trans-unit id="ec483ec7612cbc4a7219b208c6205da13b1a5be1" translate="yes" xml:space="preserve">
          <source>The 407 (Proxy Authentication Required) status code is similar to 401
   (Unauthorized), but it indicates that the client needs to
   authenticate itself in order to use a proxy.  The proxy MUST send a
   Proxy-Authenticate header field (&lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;) containing a challenge
   applicable to that proxy for the target resource.  The client MAY
   repeat the request with a new or replaced Proxy-Authorization header
   field (&lt;a href=&quot;#section-4.4&quot;&gt;Section 4.4&lt;/a&gt;).</source>
          <target state="translated">407（需要代理身份验证）状态码与401（未授权）相似​​，但是它指示客户端需要进行身份验证才能使用代理。代理必须发送一个Proxy-Authenticate头域（&lt;a href=&quot;#section-4.3&quot;&gt;第4.3节&lt;/a&gt;），其中包含适用于目标资源的该代理的质询。客户端可以用新的或替换的Proxy-Authorization头字段（&lt;a href=&quot;#section-4.4&quot;&gt;第4.4节&lt;/a&gt;）重复请求。</target>
        </trans-unit>
        <trans-unit id="d63a1397f5112fdbc72a63c104b8b9b743795432" translate="yes" xml:space="preserve">
          <source>The 408 (Request Timeout) status code indicates that the server did
   not receive a complete request message within the time that it was
   prepared to wait.  A server SHOULD send the &quot;close&quot; connection option
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6.1&quot;&gt;Section&amp;nbsp;6.1 of [RFC7230]&lt;/a&gt;) in the response, since 408 implies that
   the server has decided to close the connection rather than continue
   waiting.  If the client has an outstanding request in transit, the
   client MAY repeat that request on a new connection.</source>
          <target state="translated">408（请求超时）状态码表示服务器在准备等待时未收到完整的请求消息。服务器应在响应中发送&amp;ldquo;关闭&amp;rdquo;连接选项（&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6.1&quot;&gt;[RFC7230] 6.1节&lt;/a&gt;），因为408表示服务器已决定关闭连接而不是继续等待。如果客户端在传输过程中有未完成的请求，则客户端可以在新的连接上重复该请求。</target>
        </trans-unit>
        <trans-unit id="710b792af9157df3657d23cffcb2324a8f3a8d23" translate="yes" xml:space="preserve">
          <source>The 409 (Conflict) status code indicates that the request could not
   be completed due to a conflict with the current state of the target
   resource.  This code is used in situations where the user might be
   able to resolve the conflict and resubmit the request.  The server
   SHOULD generate a payload that includes enough information for a user
   to recognize the source of the conflict.

   Conflicts are most likely to occur in response to a PUT request.  For
   example, if versioning were being used and the representation being
   PUT included changes to a resource that conflict with those made by
   an earlier (third-party) request, the origin server might use a 409
   response to indicate that it can't complete the request.  In this
   case, the response representation would likely contain information
   useful for merging the differences based on the revision history.</source>
          <target state="translated">409(冲突)状态代码表示由于与目标资源的当前状态冲突,请求无法完成。该代码用于用户可能能够解决冲突并重新提交请求的情况。服务器应该生成一个包含足够信息的有效载荷,以便用户识别冲突的来源。冲突最可能发生在响应PUT请求时。例如,如果正在使用版本管理,并且被 PUT 的表示包括对资源的更改,而这些更改与早期(第三方)请求所做的更改相冲突,那么源服务器可能会使用 409 响应来表示它不能完成请求。在这种情况下,响应表示可能会包含对根据修订历史合并差异有用的信息。</target>
        </trans-unit>
        <trans-unit id="ed70c66832007f42d2ffeafd2453c5472e4f6db0" translate="yes" xml:space="preserve">
          <source>The 410 (Gone) status code indicates that access to the target
   resource is no longer available at the origin server and that this
   condition is likely to be permanent.  If the origin server does not 

   know, or has no facility to determine, whether or not the condition
   is permanent, the status code 404 (Not Found) ought to be used
   instead.

   The 410 response is primarily intended to assist the task of web
   maintenance by notifying the recipient that the resource is
   intentionally unavailable and that the server owners desire that
   remote links to that resource be removed.  Such an event is common
   for limited-time, promotional services and for resources belonging to
   individuals no longer associated with the origin server's site.  It
   is not necessary to mark all permanently unavailable resources as
   &quot;gone&quot; or to keep the mark for any length of time -- that is left to
   the discretion of the server owner.

   A 410 response is cacheable by default; i.e., unless otherwise
   indicated by the method definition or explicit cache controls (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;Section&amp;nbsp;4.2.2 of [RFC7234]&lt;/a&gt;).</source>
          <target state="translated">410（已消失）状态代码表示在原始服务器上不再可以访问目标资源，并且这种情况很可能是永久的。如果原始服务器不知道该条件是否永久存在，或者无法确定该条件是否永久存在，则应改用状态代码404（未找到）。 410响应主要旨在通过通知接收者资源有意不可用以及服务器所有者希望删除指向该资源的远程链接来辅助Web维护任务。对于限时促销服务和属于不再与原始服务器站点关联的个人的资源而言，此类事件很常见。不必将所有永久不可用的资源标记为&amp;ldquo;消失或保留该标记的任何时间-由服务器所有者自行决定。默认情况下，410响应是可缓存的；即，除非方法定义或显式缓存控件另有说明（请参见 &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;[RFC7234]的第4.2.2节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="1d57fe4e2e7ca23134c38c0ed0018ac65cd3855c" translate="yes" xml:space="preserve">
          <source>The 411 (Length Required) status code indicates that the server
   refuses to accept the request without a defined Content-Length
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.3.2&quot;&gt;Section&amp;nbsp;3.3.2 of [RFC7230]&lt;/a&gt;).  The client MAY repeat the request if
   it adds a valid Content-Length header field containing the length of
   the message body in the request message.</source>
          <target state="translated">411（必需的长度）状态代码指示服务器拒绝接受没有定义的Content-Length（&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.3.2&quot;&gt;[RFC7230]的3.3.2节）&lt;/a&gt;的请求。如果客户端在请求消息中添加了包含消息正文长度的有效Content-Length头字段，则客户端可以重复该请求。</target>
        </trans-unit>
        <trans-unit id="a2b0a5d0ce695f774d281e52c15ee444fd3362b0" translate="yes" xml:space="preserve">
          <source>The 412 (Precondition Failed) status code indicates that one or more
   conditions given in the request header fields evaluated to false when
   tested on the server.  This response code allows the client to place
   preconditions on the current resource state (its current
   representations and metadata) and, thus, prevent the request method
   from being applied if the target resource is in an unexpected state.</source>
          <target state="translated">412(先决条件失败)状态码表示在服务器上测试时,请求头字段中给出的一个或多个条件评价为假。该响应代码允许客户端对当前资源状态(其当前的表示和元数据)设置先决条件,因此,如果目标资源处于意外状态,则防止请求方法被应用。</target>
        </trans-unit>
        <trans-unit id="d068c8261010d8ad8c83770690d1c48285eb7c3d" translate="yes" xml:space="preserve">
          <source>The 413 (Payload Too Large) status code indicates that the server is
   refusing to process a request because the request payload is larger
   than the server is willing or able to process.  The server MAY close
   the connection to prevent the client from continuing the request.

   If the condition is temporary, the server SHOULD generate a
   Retry-After header field to indicate that it is temporary and after
   what time the client MAY try again.</source>
          <target state="translated">413(Payload Too Large)状态码表示服务器拒绝处理请求,因为请求的有效载荷大于服务器愿意或能够处理的范围。服务器可以关闭连接以防止客户端继续请求。如果这种情况是暂时的,服务器应该生成一个Retry-After头域,以表明这是暂时的,以及在什么时间之后客户端可以再次尝试。</target>
        </trans-unit>
        <trans-unit id="2eeffaec19aae81212514c4d922d7dc543cfcc59" translate="yes" xml:space="preserve">
          <source>The 414 (URI Too Long) status code indicates that the server is
   refusing to service the request because the request-target (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.3&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.3&quot;&gt;5.3 of [RFC7230]&lt;/a&gt;) is longer than the server is willing to interpret.
   This rare condition is only likely to occur when a client has
   improperly converted a POST request to a GET request with long query
   information, when the client has descended into a &quot;black hole&quot; of
   redirection (e.g., a redirected URI prefix that points to a suffix of
   itself) or when the server is under attack by a client attempting to
   exploit potential security holes. 

   A 414 response is cacheable by default; i.e., unless otherwise
   indicated by the method definition or explicit cache controls (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;Section&amp;nbsp;4.2.2 of [RFC7234]&lt;/a&gt;).</source>
          <target state="translated">414（URI太长）状态代码表示服务器拒绝服务请求，因为请求目标（&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.3&quot;&gt;[RFC7230]的5.3 &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.3&quot;&gt;节&lt;/a&gt;）长于服务器愿意解释的长度。仅当客户端将不正确的POST请求转换为带有长查询信息的GET请求且客户端下降到重定向的&amp;ldquo;黑洞&amp;rdquo;时（例如，指向一个后缀）或当服务器受到客户端尝试利用潜在安全漏洞的攻击时。默认情况下，414响应是可缓存的；即，除非方法定义或显式缓存控件另有说明（请参阅 &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;[RFC7234]的4.2.2节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="60bd497af3a67e2912392260b738e67280886922" translate="yes" xml:space="preserve">
          <source>The 415 (Unsupported Media Type) status code indicates that the
   origin server is refusing to service the request because the payload
   is in a format not supported by this method on the target resource.
   The format problem might be due to the request's indicated
   Content-Type or Content-Encoding, or as a result of inspecting the
   data directly.</source>
          <target state="translated">415(不支持的媒体类型)状态码表示源服务器拒绝服务该请求,因为有效载荷的格式在目标资源上不受该方法支持。格式问题可能是由于请求中指明的Content-Type或Content-Encoding,或者是直接检查数据的结果。</target>
        </trans-unit>
        <trans-unit id="e7168717c59ebb6678e8095c4f89436d6063047e" translate="yes" xml:space="preserve">
          <source>The 416 (Range Not Satisfiable) status code indicates that none of
   the ranges in the request's Range header field (&lt;a href=&quot;#section-3.1&quot;&gt;Section 3.1&lt;/a&gt;) overlap
   the current extent of the selected resource or that the set of ranges
   requested has been rejected due to invalid ranges or an excessive
   request of small or overlapping ranges.

   For byte ranges, failing to overlap the current extent means that the
   first-byte-pos of all of the byte-range-spec values were greater than
   the current length of the selected representation.  When this status
   code is generated in response to a byte-range request, the sender
   SHOULD generate a Content-Range header field specifying the current
   length of the selected representation (&lt;a href=&quot;#section-4.2&quot;&gt;Section 4.2&lt;/a&gt;).

   For example:

     HTTP/1.1 416 Range Not Satisfiable
     Date: Fri, 20 Jan 2012 15:41:54 GMT
     Content-Range: bytes */47022

      Note: Because servers are free to ignore Range, many
      implementations will simply respond with the entire selected
      representation in a 200 (OK) response.  That is partly because
      most clients are prepared to receive a 200 (OK) to complete the
      task (albeit less efficiently) and partly because clients might
      not stop making an invalid partial request until they have
      received a complete representation.  Thus, clients cannot depend
      on receiving a 416 (Range Not Satisfiable) response even when it
      is most appropriate.</source>
          <target state="translated">416（Range Not Satisfiable）状态代码表示请求的Range标头字段（&lt;a href=&quot;#section-3.1&quot;&gt;第3.1节&lt;/a&gt;）中没有任何范围与所选资源的当前范围重叠，或者由于无效范围或过多的范围而拒绝了所请求的范围集小范围或重叠范围的请求。对于字节范围，如果不与当前范围重叠，则意味着所有字节范围规范值的第一个字节位置大于所选表示形式的当前长度。当响应字节范围请求而生成此状态代码时，发送方应生成一个Content-Range头字段，该字段指定所选表示形式的当前长度（&lt;a href=&quot;#section-4.2&quot;&gt;第4.2节）&lt;/a&gt;）。例如：HTTP / 1.1 416范围不满足日期：2012年1月20日星期五15:41:54 GMT内容范围：字节* / 47022注意：由于服务器可以随意忽略范围，因此许多实现将简单地对整个选定内容进行响应表示为200（OK）。这部分是因为大多数客户端准备好接收200（确定）以完成任务（尽管效率较低），部分原因是客户端在收到完整的表示之前可能不会停止发出无效的部分请求。因此，即使最合适，客户端也不能依赖于接收到416（不满足范围）响应。</target>
        </trans-unit>
        <trans-unit id="74e2689c2b2651176712bcca9c3464c338299fa4" translate="yes" xml:space="preserve">
          <source>The 417 (Expectation Failed) status code indicates that the
   expectation given in the request's Expect header field
   (&lt;a href=&quot;#section-5.1.1&quot;&gt;Section 5.1.1&lt;/a&gt;) could not be met by at least one of the inbound
   servers.</source>
          <target state="translated">状态代码417（预期失败）指示，至少一台入站服务器无法满足请求的Expect标头字段（&lt;a href=&quot;#section-5.1.1&quot;&gt;第5.1.1节&lt;/a&gt;）中给出的预期。</target>
        </trans-unit>
        <trans-unit id="240b1b41518b4e60c5fb369224ec2a4d545cd292" translate="yes" xml:space="preserve">
          <source>The 422 (Unprocessable Entity) status code means the server
   understands the content type of the request entity (hence a
   415(Unsupported Media Type) status code is inappropriate), and the
   syntax of the request entity is correct (thus a 400 (Bad Request)
   status code is inappropriate) but was unable to process the contained
   instructions.  For example, this error condition may occur if an XML
   request body contains well-formed (i.e., syntactically correct), but
   semantically erroneous, XML instructions.</source>
          <target state="translated">422(不可处理实体)状态码意味着服务器理解请求实体的内容类型(因此415(不支持的媒体类型)状态码是不合适的),请求实体的语法是正确的(因此400(坏请求)状态码是不合适的),但无法处理包含的指令。例如,如果一个XML请求体包含格式良好(即语法正确)但语义错误的XML指令,就会出现这种错误条件。</target>
        </trans-unit>
        <trans-unit id="ab7728b25333c3ed3e9c44c0ad08c1c5736966a3" translate="yes" xml:space="preserve">
          <source>The 423 (Locked) status code means the source or destination resource
   of a method is locked.  This response SHOULD contain an appropriate
   precondition or postcondition code, such as 'lock-token-submitted' or
   'no-conflicting-lock'.</source>
          <target state="translated">423 (Locked)状态码意味着方法的源或目标资源被锁定。这个响应应该包含一个适当的先决条件或后决条件代码,比如 &quot;lock-token-submitted &quot;或 &quot;no-conflicting-lock&quot;。</target>
        </trans-unit>
        <trans-unit id="7bea7308e120efd626a2dea25e346d82459c7846" translate="yes" xml:space="preserve">
          <source>The 424 (Failed Dependency) status code means that the method could
   not be performed on the resource because the requested action
   depended on another action and that action failed.  For example, if a
   command in a PROPPATCH method fails, then, at minimum, the rest of
   the commands will also fail with 424 (Failed Dependency).</source>
          <target state="translated">424(Failed Dependency)状态码意味着该方法无法在资源上执行,因为请求的操作依赖于另一个操作,而该操作失败了。例如,如果PROPPATCH方法中的一条命令失败了,那么,其余命令至少也会以424(Failed Dependency)失败。</target>
        </trans-unit>
        <trans-unit id="bbb046d45cb07e647735e9643ff8b2d8aa6d1cf5" translate="yes" xml:space="preserve">
          <source>The 426 (Upgrade Required) status code indicates that the server
   refuses to perform the request using the current protocol but might
   be willing to do so after the client upgrades to a different
   protocol.  The server MUST send an Upgrade header field in a 426
   response to indicate the required protocol(s) (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6.7&quot;&gt;Section&amp;nbsp;6.7 of
   [RFC7230]&lt;/a&gt;).

   Example:

     HTTP/1.1 426 Upgrade Required
     Upgrade: HTTP/3.0
     Connection: Upgrade
     Content-Length: 53
     Content-Type: text/plain

     This service requires use of the HTTP/3.0 protocol.</source>
          <target state="translated">426（需要升级）状态代码表示服务器拒绝使用当前协议执行请求，但在客户端升级到其他协议后可能愿意这样做。服务器必须在426响应中发送一个Upgrade头域，以指示所需的协议（&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6.7&quot;&gt;[RFC7230]的6.7节&lt;/a&gt;）。示例：HTTP / 1.1 426需要升级升级：HTTP / 3.0连接：升级内容长度：53内容类型：文本/纯文本此服务需要使用HTTP / 3.0协议。</target>
        </trans-unit>
        <trans-unit id="ff18add20b8f554c457e49bc2e7ce8d714901464" translate="yes" xml:space="preserve">
          <source>The 4xx (Client Error) class of status code indicates that the client
   seems to have erred.  Except when responding to a HEAD request, the
   server SHOULD send a representation containing an explanation of the
   error situation, and whether it is a temporary or permanent
   condition.  These status codes are applicable to any request method.
   User agents SHOULD display any included representation to the user.</source>
          <target state="translated">4xx(客户端错误)类状态码表示客户端似乎出错了。除了响应HEAD请求的时候,服务器应该发送一个包含错误情况解释的表示,以及它是暂时的还是永久的情况。这些状态码适用于任何请求方法。用户代理SHOULD将任何包含的表示显示给用户。</target>
        </trans-unit>
        <trans-unit id="0c2a74d9f06b0a77075195702a5230a67673de95" translate="yes" xml:space="preserve">
          <source>The 4xx class of status code is intended for cases in which the
   client seems to have erred. Except when responding to a HEAD request,
   the server SHOULD include an entity containing an explanation of the
   error situation, and whether it is a temporary or permanent
   condition. These status codes are applicable to any request method.
   User agents SHOULD display any included entity to the user.

   If the client is sending data, a server implementation using TCP
   SHOULD be careful to ensure that the client acknowledges receipt of
   the packet(s) containing the response, before the server closes the
   input connection. If the client continues sending data to the server
   after the close, the server's TCP stack will send a reset packet to
   the client, which may erase the client's unacknowledged input buffers
   before they can be read and interpreted by the HTTP application.</source>
          <target state="translated">4xx类状态码是针对客户端似乎出错的情况。除了响应HEAD请求时,服务器应该包含一个实体,其中包含对错误情况的解释,以及它是暂时的还是永久的条件。这些状态码适用于任何请求方法。用户代理SHOULD向用户显示任何包含的实体。如果客户机正在发送数据,使用TCP的服务器实现应该注意确保客户机在服务器关闭输入连接之前,确认收到包含响应的数据包。如果客户端在关闭后继续向服务器发送数据,服务器的TCP协议栈将向客户端发送一个复位包,这可能会在HTTP应用程序读取和解释客户端未确认的输入缓冲区之前将其清除。</target>
        </trans-unit>
        <trans-unit id="e4172cee002fab51d59cbb6c27d459c5303764c9" translate="yes" xml:space="preserve">
          <source>The 500 (Internal Server Error) status code indicates that the server
   encountered an unexpected condition that prevented it from fulfilling
   the request.</source>
          <target state="translated">500(内部服务器错误)状态码表示服务器遇到了意外情况,使其无法完成请求。</target>
        </trans-unit>
        <trans-unit id="5e788aee762bb64f07dea7e2e3b12cc4a6d5e7c2" translate="yes" xml:space="preserve">
          <source>The 501 (Not Implemented) status code indicates that the server does
   not support the functionality required to fulfill the request.  This
   is the appropriate response when the server does not recognize the
   request method and is not capable of supporting it for any resource.

   A 501 response is cacheable by default; i.e., unless otherwise
   indicated by the method definition or explicit cache controls (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;Section&amp;nbsp;4.2.2 of [RFC7234]&lt;/a&gt;).</source>
          <target state="translated">501（未实现）状态代码表示服务器不支持满足请求所需的功能。当服务器无法识别请求方法并且不支持任何资源时，这是适当的响应。默认情况下，501响应是可缓存的；即，除非方法定义或显式缓存控件另有说明（请参阅 &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;[RFC7234]的4.2.2节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="537a3dde972341b94cbb072093d8857e86b4614a" translate="yes" xml:space="preserve">
          <source>The 502 (Bad Gateway) status code indicates that the server, while
   acting as a gateway or proxy, received an invalid response from an
   inbound server it accessed while attempting to fulfill the request.</source>
          <target state="translated">502(坏网关)状态码表示服务器在作为网关或代理时,在试图完成请求时收到了它访问的入站服务器的无效响应。</target>
        </trans-unit>
        <trans-unit id="6bbdd751ae4429ec4369780a1676c0e2b99f0f2f" translate="yes" xml:space="preserve">
          <source>The 503 (Service Unavailable) status code indicates that the server
   is currently unable to handle the request due to a temporary overload
   or scheduled maintenance, which will likely be alleviated after some
   delay.  The server MAY send a Retry-After header field
   (&lt;a href=&quot;#section-7.1.3&quot;&gt;Section 7.1.3&lt;/a&gt;) to suggest an appropriate amount of time for the
   client to wait before retrying the request.

      Note: The existence of the 503 status code does not imply that a
      server has to use it when becoming overloaded.  Some servers might
      simply refuse the connection.</source>
          <target state="translated">503（服务不可用）状态码表示服务器由于暂时的过载或计划的维护而当前无法处理该请求，这可能会在某些延迟后得到缓解。服务器可以发送一个Retry-After头域（&lt;a href=&quot;#section-7.1.3&quot;&gt;第7.1.3节&lt;/a&gt;）来建议一个适当的时间，以便客户端在重试请求之前等待。注意：503状态代码的存在并不意味着服务器在过载时必须使用它。某些服务器可能只是拒绝连接。</target>
        </trans-unit>
        <trans-unit id="cb5a6e6224a6befed044cf459ac3ad6b9a312b3f" translate="yes" xml:space="preserve">
          <source>The 504 (Gateway Timeout) status code indicates that the server,
   while acting as a gateway or proxy, did not receive a timely response
   from an upstream server it needed to access in order to complete the
   request.</source>
          <target state="translated">504(网关超时)状态码表示服务器在作为网关或代理时,没有收到它需要访问的上游服务器的及时响应以完成请求。</target>
        </trans-unit>
        <trans-unit id="73dde1c42105fdf2e1da6b5ec6f32547fa21c1f6" translate="yes" xml:space="preserve">
          <source>The 505 (HTTP Version Not Supported) status code indicates that the
   server does not support, or refuses to support, the major version of
   HTTP that was used in the request message.  The server is indicating
   that it is unable or unwilling to complete the request using the same
   major version as the client, as described in &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.6&quot;&gt;Section&amp;nbsp;2.6 of
   [RFC7230]&lt;/a&gt;, other than with this error message.  The server SHOULD
   generate a representation for the 505 response that describes why
   that version is not supported and what other protocols are supported
   by that server.</source>
          <target state="translated">505（不支持HTTP版本）状态代码表示服务器不支持或拒绝支持请求消息中使用的HTTP的主要版本。服务器指示它无法或不愿意使用与客户端相同的主要版本来完成请求，如&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.6&quot;&gt;[RFC7230]的2.6节&lt;/a&gt;所述，带有此错误消息除外。服务器应该为505响应生成表示，该响应描述为什么不支持该版本以及该服务器支持哪些其他协议。</target>
        </trans-unit>
        <trans-unit id="6cfe58d6c6aa1b9a0d0a3a747564d201b045f349" translate="yes" xml:space="preserve">
          <source>The 507 (Insufficient Storage) status code means the method could not
   be performed on the resource because the server is unable to store
   the representation needed to successfully complete the request.  This
   condition is considered to be temporary.  If the request that
   received this status code was the result of a user action, the
   request MUST NOT be repeated until it is requested by a separate user
   action.</source>
          <target state="translated">507(存储不足)状态码意味着由于服务器无法存储成功完成请求所需的表示,因此无法对资源执行该方法。这种情况被认为是暂时的。如果收到该状态码的请求是用户操作的结果,那么在被单独的用户操作请求之前,必须不重复该请求。</target>
        </trans-unit>
        <trans-unit id="0e2021f09cffdfd7e8e3c2b6e4af6afc876e3ba4" translate="yes" xml:space="preserve">
          <source>The 511 status code indicates that the client needs to authenticate to gain network access.</source>
          <target state="translated">511状态码表示客户端需要进行认证才能获得网络访问。</target>
        </trans-unit>
        <trans-unit id="6f13f00eed6e2731f85266d4d2b5d1b194f1dc69" translate="yes" xml:space="preserve">
          <source>The 5xx (Server Error) class of status code indicates that the server
   is aware that it has erred or is incapable of performing the
   requested method.  Except when responding to a HEAD request, the
   server SHOULD send a representation containing an explanation of the
   error situation, and whether it is a temporary or permanent 

   condition.  A user agent SHOULD display any included representation
   to the user.  These response codes are applicable to any request
   method.</source>
          <target state="translated">5xx(服务器错误)类状态码表示服务器意识到自己出错了,或者无法执行请求的方法。除了响应HEAD请求时,服务器应该发送一个包含错误情况解释的表示,以及它是暂时的还是永久的条件。用户代理应该向用户显示任何包含的表示。这些响应代码适用于任何请求方法。</target>
        </trans-unit>
        <trans-unit id="eff8921ecde9859824b0aa4a316363853f77725f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../index&quot;&gt;HTTP&lt;/a&gt;&lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&lt;strong&gt;require-sri-for&lt;/strong&gt;&lt;/code&gt; directive instructs the client to require the use of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity&quot;&gt;Subresource Integrity&lt;/a&gt; for scripts or styles on the page.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8981236cb35a3546e80d22d9775227a98e95ef1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../basics_of_http/mime_types&quot;&gt;MIME type&lt;/a&gt; of the resource or the data.</source>
          <target state="translated">资源或数据的&lt;a href=&quot;../basics_of_http/mime_types&quot;&gt;MIME类型&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="476cfd9f7f7d09d394f8e2d140063c4110e761fd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../headers/access-control-request-headers&quot;&gt;&lt;code&gt;Access-Control-Request-Headers&lt;/code&gt;&lt;/a&gt; header tells the server that when the actual request is sent, it will have the &lt;code&gt;X-PINGOTHER&lt;/code&gt; and &lt;code&gt;Content-Type&lt;/code&gt; headers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11aa0c02b1fe58d03a5cb415bbf783776721cd3e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../headers/access-control-request-method&quot;&gt;&lt;code&gt;Access-Control-Request-Method&lt;/code&gt;&lt;/a&gt; header sent in the preflight request tells the server that when the actual request is sent, it will have a &lt;a href=&quot;post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; request method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bee0f2cff0fd1a73153d67243f177de87af10640" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../headers/feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; HTTP header.</source>
          <target state="translated">的&lt;a href=&quot;../headers/feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; HTTP标头。</target>
        </trans-unit>
        <trans-unit id="1495070845bb0ae9175f95e2e4b9163ee31037e8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../headers/referer&quot;&gt;&lt;code&gt;Referer&lt;/code&gt;&lt;/a&gt; URL is too long</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3221539e7878d032dbdd4035adad83f822b0aa1b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../referer&quot;&gt;&lt;code&gt;Referer&lt;/code&gt;&lt;/a&gt; header will be omitted entirely. No referrer information is sent along with requests.</source>
          <target state="translated">所述&lt;a href=&quot;../referer&quot;&gt; &lt;code&gt;Referer&lt;/code&gt; &lt;/a&gt;头将被完全省略。没有引荐来源信息随请求一起发送。</target>
        </trans-unit>
        <trans-unit id="e873c7c4f23e96331a7b10f6fab0e72d0c3815f6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt; header needs to be set to &quot;keep-alive&quot; for this header to have any meaning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="823cc49a67542bdec9a4ef4d6b1e415d7aeb3b04" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt; header needs to be set to &quot;keep-alive&quot; for this header to have any meaning. Also, &lt;a href=&quot;connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;keep-alive&quot;&gt;&lt;code&gt;Keep-Alive&lt;/code&gt;&lt;/a&gt; are ignored in HTTP/2; connection management is handled by other mechanisms there.</source>
          <target state="translated">必须将&lt;a href=&quot;connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt;标头设置为&amp;ldquo;保持活动&amp;rdquo;，此标头才能具有任何含义。另外，在HTTP / 2中，&lt;a href=&quot;connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;keep-alive&quot;&gt; &lt;code&gt;Keep-Alive&lt;/code&gt; &lt;/a&gt;被忽略；连接管理由那里的其他机制处理。</target>
        </trans-unit>
        <trans-unit id="3168c5253229cb7eddd39a17b55204a0719f1ccb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; defining the boundary of the multipart body.</source>
          <target state="translated">定义多部分体边界的&lt;a href=&quot;content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c285a5fb007b2a2d826d7bbfcdc526294f9f38d5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/accept&quot;&gt;&lt;code&gt;Accept&lt;/code&gt;&lt;/a&gt; header is defined by the browser, or any other user-agent, and can vary according to the context, like fetching an HTML page or an image, a video, or a script: It is different when fetching a document entered in the address bar or an element linked via an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img&quot;&gt;&lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt;&lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt;&lt;/a&gt; element. Browsers are free to use the value of the header that they think is the most adequate; an exhaustive list of &lt;a href=&quot;content_negotiation/list_of_default_accept_values&quot;&gt;default values for common browsers&lt;/a&gt; is available.</source>
          <target state="translated">的&lt;a href=&quot;headers/accept&quot;&gt; &lt;code&gt;Accept&lt;/code&gt; &lt;/a&gt;报头是由浏览器，或任何其它用户代理限定，并且可以根据环境而变化，像取HTML页面或图像，视频，或脚本：当取出一个文档中的输入的，不同于地址栏或通过&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img&quot;&gt; &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt; &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt; &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; &lt;/a&gt;元素链接的元素。浏览器可以自由使用他们认为最合适的标头值；提供&lt;a href=&quot;content_negotiation/list_of_default_accept_values&quot;&gt;了常见浏览器&lt;/a&gt;的默认值的详尽列表。</target>
        </trans-unit>
        <trans-unit id="bb614dd01dd7b5c3319f1fa867383facbd91a1a2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/accept&quot;&gt;&lt;code&gt;Accept&lt;/code&gt;&lt;/a&gt; header lists the MIME types of media resources that the agent is willing to process. It is comma-separated lists of MIME types, each combined with a quality factor, a parameter indicating the relative degree of preference between the different MIME types.</source>
          <target state="translated">在&lt;a href=&quot;headers/accept&quot;&gt; &lt;code&gt;Accept&lt;/code&gt; &lt;/a&gt;头列表中的MIME类型的媒体资源代理愿意过程。它是MIME类型的逗号分隔列表，每个列表都与质量因数结合在一起，质量因数是一个参数，指示不同MIME类型之间的相对优先级。</target>
        </trans-unit>
        <trans-unit id="47c1d1550663e7b9840b652f6ba1f6059d00bdc3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/accept-ch-lifetime&quot;&gt;&lt;code&gt;Accept-CH-Lifetime&lt;/code&gt;&lt;/a&gt; header is used with the &lt;code&gt;Device-Memory&lt;/code&gt; value of the &lt;code&gt;Accept-CH&lt;/code&gt; header and indicates the amount of time the device should opt-in to sharing the amount of device memory with the server. The value is given in miliseconds and it's use is optional.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72ac9e88d286f1a089252d01c7518ad33d10efe4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/accept-charset&quot;&gt;&lt;code&gt;Accept-Charset&lt;/code&gt;&lt;/a&gt; header indicates to the server what kinds of character encodings are understood by the user-agent. Traditionally, it was set to a different value for each locale for the browser, like &lt;code&gt;ISO-8859-1,utf-8;q=0.7,*;q=0.7&lt;/code&gt; for a Western European locale.</source>
          <target state="translated">该&lt;a href=&quot;headers/accept-charset&quot;&gt; &lt;code&gt;Accept-Charset&lt;/code&gt; &lt;/a&gt;报头指示什么类型的字符编码通过用户代理理解服务器。传统上，对于浏览器的每个语言环境，它都设置为不同的值，例如 &lt;code&gt;ISO-8859-1,utf-8;q=0.7,*;q=0.7&lt;/code&gt; 对于西欧语言环境，ISO-8859-1，utf-8; q = 0.7，*; q = 0.7。</target>
        </trans-unit>
        <trans-unit id="cac90f4ab93dcb579a645e89e4735bc55952622d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/accept-encoding&quot;&gt;&lt;code&gt;Accept-Encoding&lt;/code&gt;&lt;/a&gt; header defines the acceptable content-encoding (supported compressions). The value is a q-factor list (e.g.: &lt;code&gt;br, gzip;q=0.8&lt;/code&gt;) that indicates the priority of the encoding values. The default value &lt;code&gt;identity&lt;/code&gt; is at the lowest priority (unless otherwise declared).</source>
          <target state="translated">所述&lt;a href=&quot;headers/accept-encoding&quot;&gt; &lt;code&gt;Accept-Encoding&lt;/code&gt; &lt;/a&gt;标头定义内容编码的可接受的（支持的压缩）。该值是一个q因子列表（例如 &lt;code&gt;br, gzip;q=0.8&lt;/code&gt; ），它表示编码值的优先级。默认值 &lt;code&gt;identity&lt;/code&gt; 为最低优先级（除非另行声明）。</target>
        </trans-unit>
        <trans-unit id="1da487f47873fc85841849fa6ec975c0f7e1eb16" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/accept-language&quot;&gt;&lt;code&gt;Accept-Language&lt;/code&gt;&lt;/a&gt; header is used to indicate the language preference of the user. It is a list of values with quality factors (like: &lt;code&gt;&quot;de, en;q=0.7&lt;/code&gt;&quot;). A default value is often set according the language of the graphical interface of the user agent, but most browsers allow to set different language preferences.</source>
          <target state="translated">在&lt;a href=&quot;headers/accept-language&quot;&gt; &lt;code&gt;Accept-Language&lt;/code&gt; &lt;/a&gt;头用于指示用户的语言首选项。它是具有质量因子的值的列表（例如： &lt;code&gt;&quot;de, en;q=0.7&lt;/code&gt; &amp;rdquo;）。通常会根据用户代理的图形界面的语言设置默认值，但是大多数浏览器允许设置不同的语言首选项。</target>
        </trans-unit>
        <trans-unit id="5e7674c7262d6464316098c5b65d3d21f6faacd3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/access-control-allow-credentials&quot;&gt;&lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt;&lt;/a&gt; header Indicates whether or not the response to the request can be exposed when the &lt;code&gt;credentials&lt;/code&gt; flag is true. When used as part of a response to a preflight request, this indicates whether or not the actual request can be made using credentials. Note that simple &lt;code&gt;GET&lt;/code&gt; requests are not preflighted, and so if a request is made for a resource with credentials, if this header is not returned with the resource, the response is ignored by the browser and not returned to web content.</source>
          <target state="translated">的&lt;a href=&quot;headers/access-control-allow-credentials&quot;&gt; &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; &lt;/a&gt;标头指示是否对所述请求的响应可以在被暴露 &lt;code&gt;credentials&lt;/code&gt; 标记为真。当用作对预检请求的响应的一部分时，这指示是否可以使用凭据发出实际请求。请注意，简单的 &lt;code&gt;GET&lt;/code&gt; 请求不会进行预检，因此，如果对具有凭据的资源进行请求，则如果此标头未随资源一起返回，则浏览器将忽略该响应，并且不会将其返回到Web内容。</target>
        </trans-unit>
        <trans-unit id="fb5022c494946ba6c712c71a1fbc929d4a279c00" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/access-control-allow-headers&quot;&gt;&lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt;&lt;/a&gt; header is used in response to a &lt;a href=&quot;#Preflighted_requests&quot;&gt;preflight request&lt;/a&gt; to indicate which HTTP headers can be used when making the actual request.</source>
          <target state="translated">的&lt;a href=&quot;headers/access-control-allow-headers&quot;&gt; &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; &lt;/a&gt;头是响应用于一个&lt;a href=&quot;#Preflighted_requests&quot;&gt;预检请求&lt;/a&gt;，以指示在进行实际请求时HTTP标头都可以使用。</target>
        </trans-unit>
        <trans-unit id="47e57affccad38127a20bce8c3436539e88c6c38" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/access-control-allow-methods&quot;&gt;&lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt;&lt;/a&gt; header specifies the method or methods allowed when accessing the resource. This is used in response to a preflight request. The conditions under which a request is preflighted are discussed above.</source>
          <target state="translated">的&lt;a href=&quot;headers/access-control-allow-methods&quot;&gt; &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; &lt;/a&gt;头指定访问资源时所允许的一种或多种方法。这用于响应预检请求。上面讨论了请求被预检的条件。</target>
        </trans-unit>
        <trans-unit id="4527c593b9686c403ce7ee6942811c00a0260ae5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/access-control-expose-headers&quot;&gt;&lt;code&gt;Access-Control-Expose-Headers&lt;/code&gt;&lt;/a&gt; header lets a server whitelist headers that Javascript (such as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/getResponseHeader&quot;&gt;&lt;code&gt;getResponseHeader()&lt;/code&gt;&lt;/a&gt;) in browsers are allowed to access.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e7542b9c473bf75e6b574a96c6ca9ae6b946296" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/access-control-expose-headers&quot;&gt;&lt;code&gt;Access-Control-Expose-Headers&lt;/code&gt;&lt;/a&gt; header lets a server whitelist headers that browsers are allowed to access. For example:</source>
          <target state="translated">该&lt;a href=&quot;headers/access-control-expose-headers&quot;&gt; &lt;code&gt;Access-Control-Expose-Headers&lt;/code&gt; &lt;/a&gt;标题允许白名单中的标头的浏览器被允许访问的服务器。例如：</target>
        </trans-unit>
        <trans-unit id="0c96e27b026e07ddc3f2931ff6f47daf2922b214" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/access-control-max-age&quot;&gt;&lt;code&gt;Access-Control-Max-Age&lt;/code&gt;&lt;/a&gt; header indicates how long the results of a preflight request can be cached. For an example of a preflight request, see the above examples.</source>
          <target state="translated">的&lt;a href=&quot;headers/access-control-max-age&quot;&gt; &lt;code&gt;Access-Control-Max-Age&lt;/code&gt; &lt;/a&gt;报头指示多久预检请求的结果可以被缓存。有关预检请求的示例，请参见以上示例。</target>
        </trans-unit>
        <trans-unit id="b00b4f03e257f3dbfb1f8d0d5cf818265cd59e8a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/access-control-request-headers&quot;&gt;&lt;code&gt;Access-Control-Request-Headers&lt;/code&gt;&lt;/a&gt; header is used when issuing a preflight request to let the server know what HTTP headers will be used when the actual request is made.</source>
          <target state="translated">该&lt;a href=&quot;headers/access-control-request-headers&quot;&gt; &lt;code&gt;Access-Control-Request-Headers&lt;/code&gt; &lt;/a&gt;发出预检要求，让服务器知道实际的请求时什么HTTP头的时候会用到头使用。</target>
        </trans-unit>
        <trans-unit id="691c99e3378023d77080d83aad7e1e58d0aa3326" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/access-control-request-method&quot;&gt;&lt;code&gt;Access-Control-Request-Method&lt;/code&gt;&lt;/a&gt; header notifies the server as part of a preflight request that when the actual request is sent, it will be sent with a &lt;code&gt;POST&lt;/code&gt; request method. The &lt;a href=&quot;headers/access-control-request-headers&quot;&gt;&lt;code&gt;Access-Control-Request-Headers&lt;/code&gt;&lt;/a&gt; header notifies the server that when the actual request is sent, it will be sent with a &lt;code&gt;X-PINGOTHER&lt;/code&gt; and &lt;code&gt;Content-Type&lt;/code&gt; custom headers. The server now has an opportunity to determine whether it wishes to accept a request under these circumstances.</source>
          <target state="translated">的&lt;a href=&quot;headers/access-control-request-method&quot;&gt; &lt;code&gt;Access-Control-Request-Method&lt;/code&gt; &lt;/a&gt;报头通知的服务器作为预检请求的一部分被发送的实际请求时，它将被与发送 &lt;code&gt;POST&lt;/code&gt; 请求方法。该&lt;a href=&quot;headers/access-control-request-headers&quot;&gt; &lt;code&gt;Access-Control-Request-Headers&lt;/code&gt; &lt;/a&gt;报头通知服务器，发送的实际请求时，它将被发送的 &lt;code&gt;X-PINGOTHER&lt;/code&gt; 和 &lt;code&gt;Content-Type&lt;/code&gt; 的自定义页眉。服务器现在有机会确定在这种情况下是否希望接受请求。</target>
        </trans-unit>
        <trans-unit id="00e93481fc61267674621b1c977f194bc75b6c9a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/access-control-request-method&quot;&gt;&lt;code&gt;Access-Control-Request-Method&lt;/code&gt;&lt;/a&gt; is used when issuing a preflight request to let the server know what HTTP method will be used when the actual request is made.</source>
          <target state="translated">该&lt;a href=&quot;headers/access-control-request-method&quot;&gt; &lt;code&gt;Access-Control-Request-Method&lt;/code&gt; &lt;/a&gt;发出预检要求，让服务器知道实际的请求时什么HTTP方法将被使用时使用。</target>
        </trans-unit>
        <trans-unit id="7fbe0c67984080abcf5fba23225ff8d88603f4f2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/authorization&quot;&gt;&lt;code&gt;Authorization&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;headers/proxy-authorization&quot;&gt;&lt;code&gt;Proxy-Authorization&lt;/code&gt;&lt;/a&gt; request headers contain the credentials to authenticate a user agent with a (proxy) server. Here, the &lt;code&gt;&amp;lt;type&amp;gt;&lt;/code&gt; is needed again followed by the credentials, which can be encoded or encrypted depending on which authentication scheme is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32735ad57de0b36b9cb875eb26ae77710d7487d1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/authorization&quot;&gt;&lt;code&gt;Authorization&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;headers/proxy-authorization&quot;&gt;&lt;code&gt;Proxy-Authorization&lt;/code&gt;&lt;/a&gt; request headers contain the credentials to authenticate a user agent with a (proxy) server. Here, the type is needed again followed by the credentials, which can be encoded or encrypted depending on which authentication scheme is used.</source>
          <target state="translated">的&lt;a href=&quot;headers/authorization&quot;&gt; &lt;code&gt;Authorization&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;headers/proxy-authorization&quot;&gt; &lt;code&gt;Proxy-Authorization&lt;/code&gt; &lt;/a&gt;请求头包含凭证与一个（代理）服务器进行认证的用户代理。在这里，再次需要类型，其后是凭据，取决于使用哪种身份验证方案，可以对凭据进行编码或加密。</target>
        </trans-unit>
        <trans-unit id="53e54b41889fb412304c339ba63b0b1d28f93d5d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/cache-control&quot;&gt;&lt;code&gt;Cache-Control&lt;/code&gt;&lt;/a&gt; HTTP/1.1 general-header field is used to specify directives for caching mechanisms in both requests and responses. Use this header to define your caching policies with the variety of directives it provides.</source>
          <target state="translated">所述&lt;a href=&quot;headers/cache-control&quot;&gt; &lt;code&gt;Cache-Control&lt;/code&gt; &lt;/a&gt; HTTP / 1.1通用头字段被用于为请求和响应缓存机制指定指令。使用此标头可以使用其提供的各种指令来定义缓存策略。</target>
        </trans-unit>
        <trans-unit id="7095083b873f36d44191b5aa9a6bd5c7f44c8102" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/content-length&quot;&gt;&lt;code&gt;Content-Length&lt;/code&gt;&lt;/a&gt; header now indicates the size of the requested range (and not the full size of the image). The &lt;a href=&quot;headers/content-range&quot;&gt;&lt;code&gt;Content-Range&lt;/code&gt;&lt;/a&gt; response header indicates where in the full resource this partial message belongs.</source>
          <target state="translated">的&lt;a href=&quot;headers/content-length&quot;&gt; &lt;code&gt;Content-Length&lt;/code&gt; &lt;/a&gt;报头现在指示所请求的范围（而不是图像的全尺寸）的尺寸。的&lt;a href=&quot;headers/content-range&quot;&gt; &lt;code&gt;Content-Range&lt;/code&gt; &lt;/a&gt;的响应报头指示，其中在全资源此部分消息所属。</target>
        </trans-unit>
        <trans-unit id="373e10b1138008b081311180730e472ee8b5d4d7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; response header fields allows web site administrators to control resources the user agent is allowed to load for a given page. With a few exceptions, policies mostly involve specifying server origins and script endpoints.</source>
          <target state="translated">在&lt;a href=&quot;headers/content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;响应头字段允许网站管理员能够控制资源的用户代理者被允许负载为一个给定的页面。除少数例外，策略主要涉及指定服务器来源和脚本端点。</target>
        </trans-unit>
        <trans-unit id="b9fe6d801fee6375976ebc4e32f720967639b006" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt; response header is an &lt;em&gt;opaque-to-the-useragent&lt;/em&gt; value that can be used as a strong validator. That means that a HTTP user-agent, such as the browser, does not know what this string represents and can't predict what its value would be. If the &lt;code&gt;ETag&lt;/code&gt; header was part of the response for a resource, the client can issue an &lt;a href=&quot;headers/if-none-match&quot;&gt;&lt;code&gt;If-None-Match&lt;/code&gt;&lt;/a&gt; in the header of future requests &amp;ndash; in order to validate the cached resource.</source>
          <target state="translated">的&lt;a href=&quot;headers/etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; 的&lt;/a&gt;响应报头是&lt;em&gt;不透明到所述-用户代理&lt;/em&gt;可以使用作为强验证值。这意味着HTTP用户代理（例如浏览器）不知道该字符串代表什么，也无法预测其值。如果 &lt;code&gt;ETag&lt;/code&gt; 标头是资源响应的一部分，则客户端可以在未来请求的标头中发出&lt;a href=&quot;headers/if-none-match&quot;&gt; &lt;code&gt;If-None-Match&lt;/code&gt; &lt;/a&gt;，以验证缓存的资源。</target>
        </trans-unit>
        <trans-unit id="cc825b2410b4df4739e11c71f412ef7ef377ba8f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; HTTP header.</source>
          <target state="translated">的&lt;a href=&quot;headers/feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; HTTP标头。</target>
        </trans-unit>
        <trans-unit id="02c9a22613e0a52af16dfd3143868970cb39f043" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/if-range&quot;&gt;&lt;code&gt;If-Range&lt;/code&gt;&lt;/a&gt; HTTP request header makes a range request conditional: if the condition is fulfilled, the range request will be issued and the server sends back a &lt;a href=&quot;status/206&quot;&gt;&lt;code&gt;206&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Partial Content&lt;/code&gt; answer with the appropriate body. If the condition is not fulfilled, the full resource is sent back, with a &lt;a href=&quot;status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt;&lt;code&gt;OK&lt;/code&gt; status. This header can be used either with a &lt;a href=&quot;headers/last-modified&quot;&gt;&lt;code&gt;Last-Modified&lt;/code&gt;&lt;/a&gt; validator, or with an &lt;a href=&quot;headers/etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt;, but not with both.</source>
          <target state="translated">在&lt;a href=&quot;headers/if-range&quot;&gt; &lt;code&gt;If-Range&lt;/code&gt; &lt;/a&gt; HTTP请求头生产一系列要求条件：如果条件满足，范围请求将被发出，服务器发回&lt;a href=&quot;status/206&quot;&gt; &lt;code&gt;206&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Partial Content&lt;/code&gt; 用适当的身体答案。如果不满足该条件，则以&lt;a href=&quot;status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt; &lt;code&gt;OK&lt;/code&gt; 状态发送完整资源。此标头可以与&lt;a href=&quot;headers/last-modified&quot;&gt; &lt;code&gt;Last-Modified&lt;/code&gt; &lt;/a&gt;验证器一起使用，也可以与&lt;a href=&quot;headers/etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt;一起使用，但不能同时使用。</target>
        </trans-unit>
        <trans-unit id="590a84433585d18f20730243da1b6a8953716c09" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/last-modified&quot;&gt;&lt;code&gt;Last-Modified&lt;/code&gt;&lt;/a&gt; response header can be used as a weak validator. It is considered weak because it only has 1-second resolution. If the &lt;code&gt;Last-Modified&lt;/code&gt; header is present in a response, then the client can issue an &lt;a href=&quot;headers/if-modified-since&quot;&gt;&lt;code&gt;If-Modified-Since&lt;/code&gt;&lt;/a&gt; request header to validate the cached document.</source>
          <target state="translated">的&lt;a href=&quot;headers/last-modified&quot;&gt; &lt;code&gt;Last-Modified&lt;/code&gt; &lt;/a&gt;响应头可以用作弱验证器。它被认为是弱的，因为它只有1秒的分辨率。如果响应中存在 &lt;code&gt;Last-Modified&lt;/code&gt; 标头，则客户端可以发出&lt;a href=&quot;headers/if-modified-since&quot;&gt; &lt;code&gt;If-Modified-Since&lt;/code&gt; &lt;/a&gt;请求标头来验证缓存的文档。</target>
        </trans-unit>
        <trans-unit id="9a00311ebb7587989dbe59dcf3d642597bd57cd9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/origin&quot;&gt;&lt;code&gt;Origin&lt;/code&gt;&lt;/a&gt; header indicates the origin of the cross-site access request or preflight request.</source>
          <target state="translated">的&lt;a href=&quot;headers/origin&quot;&gt; &lt;code&gt;Origin&lt;/code&gt; &lt;/a&gt;报头指示的跨站接入请求或预检请求的来源。</target>
        </trans-unit>
        <trans-unit id="00410abbfb65785de4501043b5495b885e06221c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; header also allows you to get multiple ranges at once in a multipart document. The ranges are separated by a comma.</source>
          <target state="translated">该&lt;a href=&quot;headers/range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt;头还可以让你在一次多文档中获得多个范围。范围由逗号分隔。</target>
        </trans-unit>
        <trans-unit id="86f95f2219b451868ec50ea455d93d73adebbf1e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/set-cookie&quot;&gt;&lt;code&gt;Set-Cookie&lt;/code&gt;&lt;/a&gt; HTTP response header sends cookies from the server to the user agent. A simple cookie is set like this:</source>
          <target state="translated">所述&lt;a href=&quot;headers/set-cookie&quot;&gt; &lt;code&gt;Set-Cookie&lt;/code&gt; &lt;/a&gt;的HTTP响应报头从服务器向用户代理发送的cookie。一个简单的cookie设置如下：</target>
        </trans-unit>
        <trans-unit id="af75cb2c0da0fe81a5535d484eb290c4bd4d639e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/transfer-encoding&quot;&gt;&lt;code&gt;Transfer-Encoding&lt;/code&gt;&lt;/a&gt; header allows chunked encoding, which is useful when larger amounts of data are sent to the client and the total size of the response is not known until the request has been fully processed. The server sends data to the client straight away without buffering the response or determining the exact length, which leads to improved latency. Range requests and chunking are compatible and can be used with or without each other.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7f353f47a7491fd7a18b5bc1a1b46d2745b86d1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/transfer-encoding&quot;&gt;&lt;code&gt;Transfer-Encoding&lt;/code&gt;&lt;/a&gt; header allows chunked encoding, which useful when larger amounts of data are sent to the client and the total size of the response is not known until the request has been fully processed. The server sends data to the client straight away without buffering the response or determining the exact length, which leads to improved latency. Range requests and chunking are compatible and can be used with or without each other.</source>
          <target state="translated">的&lt;a href=&quot;headers/transfer-encoding&quot;&gt; &lt;code&gt;Transfer-Encoding&lt;/code&gt; &lt;/a&gt;头允许分块编码，这是有用的时候更大量的数据被发送到客户端和响应是未知的，直到请求已被完全处理的总大小。服务器立即将数据发送到客户端，而无需缓冲响应或确定确切的长度，这导致了改进的延迟。范围请求和分块是兼容的，可以相互使用或不相互使用。</target>
        </trans-unit>
        <trans-unit id="427718e5d2f07133480270391026fe30a80122e0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/user-agent&quot;&gt;&lt;code&gt;User-Agent&lt;/code&gt;&lt;/a&gt; header identifies the browser sending the request. This string may contain a space-separated list of &lt;em&gt;product tokens&lt;/em&gt; and &lt;em&gt;comments&lt;/em&gt;.</source>
          <target state="translated">的&lt;a href=&quot;headers/user-agent&quot;&gt; &lt;code&gt;User-Agent&lt;/code&gt; &lt;/a&gt;报头标识浏览器发送请求。该字符串可以包含以空格分隔的&lt;em&gt;产品标记&lt;/em&gt;和&lt;em&gt;注释&lt;/em&gt;列表。</target>
        </trans-unit>
        <trans-unit id="1e0b7713d148829012c4c472ea954c0d5574cc79" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/vary&quot;&gt;&lt;code&gt;Vary&lt;/code&gt;&lt;/a&gt; HTTP response header determines how to match future request headers to decide whether a cached response can be used rather than requesting a fresh one from the origin server.</source>
          <target state="translated">该&lt;a href=&quot;headers/vary&quot;&gt; &lt;code&gt;Vary&lt;/code&gt; &lt;/a&gt; HTTP响应头决定如何满足未来的请求头，以决定一个缓存的响应是否可以使用，而不是请求从源服务器一个新的一个。</target>
        </trans-unit>
        <trans-unit id="b1d4a413436104711d19f9e2f2ce3b22dd6fa9fb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/vary&quot;&gt;&lt;code&gt;Vary&lt;/code&gt;&lt;/a&gt; HTTP response header determines how to match future request headers to decide whether a cached response can be used, or if a fresh one must be requested from the origin server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f8e8fc45b5f4468eb6609ffd5ad8cb0e64e2e51" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/www-authenticate&quot;&gt;&lt;code&gt;WWW-Authenticate&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;headers/proxy-authenticate&quot;&gt;&lt;code&gt;Proxy-Authenticate&lt;/code&gt;&lt;/a&gt; response headers define the authentication method that should be used to gain access to a resource. They must specify which authentication scheme is used, so that the client that wishes to authorize knows how to provide the credentials.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9f41cb2e8943b80c1ccc9757d2185689ead0a50" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/www-authenticate&quot;&gt;&lt;code&gt;WWW-Authenticate&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;headers/proxy-authenticate&quot;&gt;&lt;code&gt;Proxy-Authenticate&lt;/code&gt;&lt;/a&gt; response headers define the authentication method that should be used to gain access to a resource. They need to specify which authentication scheme is used, so that the client that wishes to authorize knows how to provide the credentials. The syntax for these headers is the following:</source>
          <target state="translated">在&lt;a href=&quot;headers/www-authenticate&quot;&gt; &lt;code&gt;WWW-Authenticate&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;headers/proxy-authenticate&quot;&gt; &lt;code&gt;Proxy-Authenticate&lt;/code&gt; &lt;/a&gt;的响应头定义应该被用来访问资源的身份验证方法。他们需要指定使用哪种身份验证方案，以便希望授权的客户端知道如何提供凭据。这些标头的语法如下：</target>
        </trans-unit>
        <trans-unit id="841a5f97046d98851a68c9d87ead02d585e0efda" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;host&quot;&gt;&lt;code&gt;Host&lt;/code&gt;&lt;/a&gt; request header field as received by the proxy.</source>
          <target state="translated">代理收到的&lt;a href=&quot;host&quot;&gt; &lt;code&gt;Host&lt;/code&gt; &lt;/a&gt;请求标头字段。</target>
        </trans-unit>
        <trans-unit id="90ae0d5ac939ab22b89ef22ef6cf0f70a90df9a8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://httpd.apache.org/docs/current/mod/mod_rewrite.html&quot;&gt;mod_rewrite&lt;/a&gt; module can also be used to create redirects. It is more flexible, but a bit more complex to use.</source>
          <target state="translated">该&lt;a href=&quot;http://httpd.apache.org/docs/current/mod/mod_rewrite.html&quot;&gt;mod_rewrite的&lt;/a&gt;模块也可以用来创建重定向。它更灵活，但使用起来有点复杂。</target>
        </trans-unit>
        <trans-unit id="575f2f642c54dbd7133186d28418d1c27eaa5d6f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://www.iana.org/assignments/http-warn-codes/http-warn-codes.xhtml&quot;&gt;HTTP Warn Codes registry at iana.org&lt;/a&gt; defines the namespace for warn codes.</source>
          <target state="translated">&lt;a href=&quot;http://www.iana.org/assignments/http-warn-codes/http-warn-codes.xhtml&quot;&gt;iana.org上&lt;/a&gt;的HTTP警告代码注册表定义了警告代码的名称空间。</target>
        </trans-unit>
        <trans-unit id="8df2d67e805aa2c79e4d6afb765f67e048353741" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://blogs.msdn.microsoft.com/ie/2008/09/02/ie8-security-part-vi-beta-2-update/&quot;&gt;original definition&lt;/a&gt; of X-Content-Type-Options by Microsoft.</source>
          <target state="translated">Microsoft对X-Content-Type-Options 的&lt;a href=&quot;https://blogs.msdn.microsoft.com/ie/2008/09/02/ie8-security-part-vi-beta-2-update/&quot;&gt;原始定义&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b6bb44a38f57a4a24a21a54355c1172f452d3808" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/ALPN&quot;&gt;ALPN&lt;/a&gt; protocol identifier. Examples include h2 for HTTP/2 and h3-25 for draft 25 of the HTTP/3 protocol.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="303a7ca8e087b00d9976db8accc4e29108a04169" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; request requires preflight, preflighting could not be performed. There are a couple of reasons why preflighting might fail:</source>
          <target state="translated">该&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt;请求需要预检，预检无法进行。进行预检失败的原因有两个：</target>
        </trans-unit>
        <trans-unit id="0ac1bdf745446afae63eab40c6dbfdebac045663" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; request requires that the server permit the use of credentials, but the server's &lt;a href=&quot;../../headers/access-control-allow-credentials&quot;&gt;&lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt;&lt;/a&gt; header's value isn't set to &lt;code&gt;true&lt;/code&gt; to enable their use.</source>
          <target state="translated">该&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt;请求，要求服务器允许使用的凭据，但服务器的&lt;a href=&quot;../../headers/access-control-allow-credentials&quot;&gt; &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; &lt;/a&gt;头的值未设置为 &lt;code&gt;true&lt;/code&gt; ，以使它们的使用。</target>
        </trans-unit>
        <trans-unit id="a3fef220d846f02c9cfee24670814beeba7e7355" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; request was attempted with the credentials flag set, but the server is configured using the wildcard (&lt;code&gt;&quot;*&quot;&lt;/code&gt;) as the value of &lt;a href=&quot;../../headers/access-control-allow-origin&quot;&gt;&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;&lt;/a&gt;, which doesn't allow the use of credentials.</source>
          <target state="translated">尝试使用设置了凭据标志的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt;请求，但是使用通配符（ &lt;code&gt;&quot;*&quot;&lt;/code&gt; ）将服务器配置为&lt;a href=&quot;../../headers/access-control-allow-origin&quot;&gt; &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; &lt;/a&gt;的值，该值不允许使用凭据。</target>
        </trans-unit>
        <trans-unit id="94840953c7f31c8c81ed2848ad9300fdfc9d44eb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; request was responded to by the server with an HTTP redirect to a URL on a different origin than the original request, which is not permitted during CORS requests.</source>
          <target state="translated">的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt;请求用HTTP重定向响应由所述服务器向一个URL上的不同来源比原来的请求，其在CORS请求是不允许的。</target>
        </trans-unit>
        <trans-unit id="46ef7b51d18c11a16b9ea7877d2ee5b389add21e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTTP&quot;&gt;HTTP&lt;/a&gt; request which makes use of CORS failed because the HTTP connection failed at either the network or protocol level. The error is not directly related to CORS, but is a fundamental network error of some kind.</source>
          <target state="translated">使用CORS 的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTTP&quot;&gt;HTTP&lt;/a&gt;请求失败，因为在网络或协议级别上HTTP连接均失败。该错误与CORS不直接相关，而是某种基本的网络错误。</target>
        </trans-unit>
        <trans-unit id="8ca3dd995c40f4f12da6eea0a0fb62e8d5df0822" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/simple_header&quot;&gt;simple headers&lt;/a&gt;, &lt;a href=&quot;accept&quot;&gt;&lt;code&gt;Accept&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;accept-language&quot;&gt;&lt;code&gt;Accept-Language&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;content-language&quot;&gt;&lt;code&gt;Content-Language&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; (but only with a MIME type of its parsed value (ignoring parameters) of either &lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt;, &lt;code&gt;multipart/form-data&lt;/code&gt;, or &lt;code&gt;text/plain&lt;/code&gt;), are always available and don't need to be listed by this header.</source>
          <target state="translated">的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/simple_header&quot;&gt;简单标头&lt;/a&gt;，&lt;a href=&quot;accept&quot;&gt; &lt;code&gt;Accept&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;accept-language&quot;&gt; &lt;code&gt;Accept-Language&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;content-language&quot;&gt; &lt;code&gt;Content-Language&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt;之一（但仅与一个MIME类型其解析后的值（忽略参数） &lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt; ， &lt;code&gt;multipart/form-data&lt;/code&gt; ，或 &lt;code&gt;text/plain&lt;/code&gt; ），始终可用，不需要在此标头中列出。</target>
        </trans-unit>
        <trans-unit id="7c8c624b902acbdfb33352d81eeb9f16044ff38e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;user agent&lt;/a&gt; was unable to add the required &lt;a href=&quot;../../headers/origin&quot;&gt;&lt;code&gt;Origin&lt;/code&gt;&lt;/a&gt; header to the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTTP&quot;&gt;HTTP&lt;/a&gt; request. All CORS requests must have an &lt;code&gt;Origin&lt;/code&gt; header.</source>
          <target state="translated">所述&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;用户代理&lt;/a&gt;无法所需添加&lt;a href=&quot;../../headers/origin&quot;&gt; &lt;code&gt;Origin&lt;/code&gt; &lt;/a&gt;标头添加到&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTTP&quot;&gt;HTTP&lt;/a&gt;请求。所有CORS请求都必须具有 &lt;code&gt;Origin&lt;/code&gt; 头。</target>
        </trans-unit>
        <trans-unit id="541849bca8dfcb4810abe650d5548422c6848655" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/FormData&quot;&gt;&lt;code&gt;FormData&lt;/code&gt;&lt;/a&gt; interface used to manipulate form data for use in the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt; API.</source>
          <target state="translated">所述&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/FormData&quot;&gt; &lt;code&gt;FormData&lt;/code&gt; &lt;/a&gt;接口用于操纵形式数据用于在使用中&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; &lt;/a&gt; API。</target>
        </trans-unit>
        <trans-unit id="315a779e6acad1d531dd53b54135b697e3e3e7ed" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/WebSocket&quot;&gt;&lt;code&gt;WebSocket()&lt;/code&gt;&lt;/a&gt; constructor does all the work of creating an initial HTTP/1.1 connection then handling the handshaking and upgrade process for you.</source>
          <target state="translated">该&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/WebSocket&quot;&gt; &lt;code&gt;WebSocket()&lt;/code&gt; &lt;/a&gt;构造函数都创建一个初始的HTTP / 1.1连接，然后处理握手和升级过程中为你的工作。</target>
        </trans-unit>
        <trans-unit id="d45717eba61ad3d5a426950cb644c8f2dd47e3a7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebVR_API&quot;&gt;WebVR API&lt;/a&gt; has been replced with the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebXR_API&quot;&gt;WebXR Device API&lt;/a&gt; and is currently being removed from the web platform. Use the feature identifier &lt;a href=&quot;xr-spatial-tracking&quot;&gt;&lt;code&gt;xr-spatial-tracking&lt;/code&gt;&lt;/a&gt; for WebXR Device API instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3d572fbbc7fb5223d172c4f660df4f67fd67a10" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#Attributes&quot;&gt;&lt;code&gt;allow&lt;/code&gt;&lt;/a&gt; attribute on iframes.</source>
          <target state="translated">iframe上的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#Attributes&quot;&gt; &lt;code&gt;allow&lt;/code&gt; &lt;/a&gt;属性。</target>
        </trans-unit>
        <trans-unit id="41b2d8d87680fc3732f8e6149116b853f67342a3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#Attributes&quot;&gt;allow&lt;/a&gt; attribute on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#Attributes&quot;&gt;allow&lt;/a&gt;属性。</target>
        </trans-unit>
        <trans-unit id="81c151e97bb2fc9016b004646d1163e360980269" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-CH-Lifetime&quot;&gt;&lt;code&gt;Accept-CH-Lifetime&lt;/code&gt;&lt;/a&gt; header is used with the &lt;code&gt;Device-Memory&lt;/code&gt; value of the &lt;code&gt;Accept-CH&lt;/code&gt; header and indicates the amount of time the device should opt-in to sharing the amount of device memory with the server. The value is given in miliseconds and it's use is optional.</source>
          <target state="translated">所述&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-CH-Lifetime&quot;&gt; &lt;code&gt;Accept-CH-Lifetime&lt;/code&gt; &lt;/a&gt;头用于与 &lt;code&gt;Device-Memory&lt;/code&gt; 在的值 &lt;code&gt;Accept-CH&lt;/code&gt; 头和表示时间的设备应该选择加入与服务器共享装置存储器的量的量。该值以毫秒为单位给出，它的使用是可选的。</target>
        </trans-unit>
        <trans-unit id="feae0b21dc6047c955761cda1dd45a586e339677" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt; header field is used by clients to invite the server to switch to one of the listed protocols, in descending preference order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="102f0a3635d954f2ea429dc9612327a656cc4b1f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Media/Formats/Audio_codecs&quot;&gt;audio codec&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Media/Formats/Video_codecs&quot;&gt;video codec&lt;/a&gt; guides list the various codecs that web browsers often support, providing compatibility details along with technical information such as how many audio channels they support, what sort of compression is used, and what bit rates and so forth they're useful at. The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Media/Formats/WebRTC_codecs&quot;&gt;codecs used by WebRTC&lt;/a&gt; guide expands upon this by specifically covering the codecs supported by the major web browsers, so you can choose the codecs that best cover the range of browsers you wish to support.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbd12c73f76eeadd9f5a8a7c267e1d8bb10451c5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en/HTTP&quot;&gt;HTTP protocol&lt;/a&gt; provides a special mechanism allowing an already established connection to upgrade to a new, incompatible, protocol. This guide covers how this works and offers examples of scenarios in which it's used.</source>
          <target state="translated">在&lt;a href=&quot;https://developer.mozilla.org/en/HTTP&quot;&gt;HTTP协议&lt;/a&gt;提供了一个特殊机制，使已建立的连接升级到一个新的，不兼容，协议。本指南介绍了它的工作原理，并提供了使用它的场景示例。</target>
        </trans-unit>
        <trans-unit id="56487f351a83f4ece995635d28e031bb9e971d36" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://fetch.spec.whatwg.org/#cross-origin-resource-policy-header&quot;&gt;Cross-Origin-Resource-Policy&lt;/a&gt; header prevents other domains from loading the resources.</source>
          <target state="translated">所述&lt;a href=&quot;https://fetch.spec.whatwg.org/#cross-origin-resource-policy-header&quot;&gt;跨源资源策略&lt;/a&gt;头阻止加载资源其他领域。</target>
        </trans-unit>
        <trans-unit id="30ff7cff75928c0f981ddbe781c5a37e5b8ec7ad" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://httpd.apache.org/docs/current/mod/mod_alias.html&quot;&gt;mod_alias&lt;/a&gt; module has &lt;code&gt;Redirect&lt;/code&gt; and &lt;code&gt;RedirectMatch&lt;/code&gt; directives that set up a &lt;a href=&quot;status/302&quot;&gt;&lt;code&gt;302&lt;/code&gt;&lt;/a&gt; response (by default):</source>
          <target state="translated">所述&lt;a href=&quot;https://httpd.apache.org/docs/current/mod/mod_alias.html&quot;&gt;mod_alias中&lt;/a&gt;模块具有 &lt;code&gt;Redirect&lt;/code&gt; 和 &lt;code&gt;RedirectMatch&lt;/code&gt; 指令，它们设置一个&lt;a href=&quot;status/302&quot;&gt; &lt;code&gt;302&lt;/code&gt; &lt;/a&gt;响应（默认）：</target>
        </trans-unit>
        <trans-unit id="dfdf1721b0f5a67b62cb197634da7d5057e2041b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://observatory.mozilla.org/&quot;&gt;Mozilla Observatory&lt;/a&gt; tool testing the configuration (including this header) of Web sites for safety and security</source>
          <target state="translated">在&lt;a href=&quot;https://observatory.mozilla.org/&quot;&gt;Mozilla的观测&lt;/a&gt;工具测试网站的配置（包括这头）的安全和安保</target>
        </trans-unit>
        <trans-unit id="b0c2f791ad88a8a7e38ea528eb0f0ccd9df436bb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://tools.ietf.org/html/rfc4648#section-5&quot;&gt;base64url&lt;/a&gt; format is not the same as standard Base64 encoding. This is almost but not quite the same as standard Base64. The only difference: in order to ensure that the resulting string is safe for use in both URLs and filenames, the 62nd and 63rd characters in its alphabet are changed from &lt;code&gt;&quot;+&quot;&lt;/code&gt; and &lt;code&gt;&quot;/&quot;&lt;/code&gt; to &lt;code&gt;&quot;-&quot;&lt;/code&gt; (minus) and &lt;code&gt;&quot;_&quot;&lt;/code&gt; (underscore), respectively.</source>
          <target state="translated">所述&lt;a href=&quot;https://tools.ietf.org/html/rfc4648#section-5&quot;&gt;base64url&lt;/a&gt;格式是不一样的标准Base64编码。这几乎与标准Base64几乎相同，但并不完全相同。唯一的区别：为了确保生成的字符串可以安全地在URL和文件名中使用，将其字母中的第62和63个字符从 &lt;code&gt;&quot;+&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;/&quot;&lt;/code&gt; 更改为 &lt;code&gt;&quot;-&quot;&lt;/code&gt; （减号）和 &lt;code&gt;&quot;_&quot;&lt;/code&gt; （下划线）。</target>
        </trans-unit>
        <trans-unit id="e864176c816370410ca7b511fa51ea0441aec0c3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://www.iana.org/&quot;&gt;Internet Assigned Numbers Authority (IANA)&lt;/a&gt; is responsible for all official MIME types, and you can find the most up-to-date and complete list at their &lt;a href=&quot;https://www.iana.org/assignments/media-types/media-types.xhtml&quot;&gt;Media Types&lt;/a&gt; page.</source>
          <target state="translated">在&lt;a href=&quot;https://www.iana.org/&quot;&gt;互联网编号分配机构（IANA）&lt;/a&gt;负责所有官方和MIME类型，你可以找到他们的最先进的最新和完整列表&lt;a href=&quot;https://www.iana.org/assignments/media-types/media-types.xhtml&quot;&gt;媒体类型&lt;/a&gt;页。</target>
        </trans-unit>
        <trans-unit id="a0ea81494b8105f6717337ab7d95f01a45c084f2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;index&quot;&gt;HTTP/1.1 protocol&lt;/a&gt; provides a special mechanism that can be used to upgrade an already established connection to a different protocol, using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt; header field.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ab5fee31c8ccbebe1e49d2cda4be11eb9064dcd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; method requests a data representation of the specified resource. Requests using &lt;code&gt;GET&lt;/code&gt; should only retrieve data.</source>
          <target state="translated">该&lt;a href=&quot;methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;方法请求指定资源的数据表示。使用 &lt;code&gt;GET&lt;/code&gt; 的请求应仅检索数据。</target>
        </trans-unit>
        <trans-unit id="85676b7109bc7c3348572fe11d463aa4452c7f6e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; method sends data to a server so it may change its state. This is the method often used for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Forms&quot;&gt;HTML Forms&lt;/a&gt;.</source>
          <target state="translated">该&lt;a href=&quot;methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt;方法将数据发送到服务器，以便它可以改变其状态。这是&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Forms&quot;&gt;HTML表单&lt;/a&gt;常用的方法。</target>
        </trans-unit>
        <trans-unit id="759d2232e34b1fccdd6a4688d236906067716e48" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;referer&quot;&gt;&lt;code&gt;Referer&lt;/code&gt;&lt;/a&gt; header will be omitted entirely. No referrer information is sent along with requests.</source>
          <target state="translated">所述&lt;a href=&quot;referer&quot;&gt; &lt;code&gt;Referer&lt;/code&gt; &lt;/a&gt;头将被完全省略。没有引荐来源信息随请求一起发送。</target>
        </trans-unit>
        <trans-unit id="bb80c4be8693337fa70be2fe31fd2c4154708a28" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;status/101&quot;&gt;&lt;code&gt;101&lt;/code&gt;&lt;/a&gt; status code is sent as a response to a request including the &lt;code&gt;&quot;Upgrade&quot;&lt;/code&gt; header to signal that the recipient of the request is willing to upgrade to one of the desired protocols. If the &lt;code&gt;&quot;101 Switching Protocols&quot;&lt;/code&gt; status code is returned, the header must also include the &lt;code&gt;Connection&lt;/code&gt; and &lt;code&gt;Upgrade&lt;/code&gt; headers to describe the chosen protocol. See the examples in &lt;a href=&quot;#Common_uses_for_this_mechanism&quot;&gt;Common uses for this mechanism&lt;/a&gt; to learn more about how this works.</source>
          <target state="translated">在&lt;a href=&quot;status/101&quot;&gt; &lt;code&gt;101&lt;/code&gt; 个&lt;/a&gt;状态代码被发送作为包括该请求的响应 &lt;code&gt;&quot;Upgrade&quot;&lt;/code&gt; 头发信号通知请求的接收方愿意升级到所期望的协议之一。如果返回 &lt;code&gt;&quot;101 Switching Protocols&quot;&lt;/code&gt; 状态代码，则标头还必须包括&amp;ldquo; &lt;code&gt;Connection&lt;/code&gt; 和&amp;ldquo; &lt;code&gt;Upgrade&lt;/code&gt; 标头，以描述所选协议。请参阅&lt;a href=&quot;#Common_uses_for_this_mechanism&quot;&gt;此机制的常用用法中&lt;/a&gt;的示例，以了解有关其工作原理的更多信息。</target>
        </trans-unit>
        <trans-unit id="ba7765f4a93430d93893449738d810f79adab493" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;status/300&quot;&gt;&lt;code&gt;300&lt;/code&gt;&lt;/a&gt; (Multiple Choices) or &lt;a href=&quot;status/406&quot;&gt;&lt;code&gt;406&lt;/code&gt;&lt;/a&gt; (Not Acceptable) &lt;a href=&quot;status&quot;&gt;HTTP response codes&lt;/a&gt; by the server (&lt;em&gt;agent-driven negotiation&lt;/em&gt; or &lt;em&gt;reactive negotiation&lt;/em&gt;), that are used as fallback mechanisms.</source>
          <target state="translated">服务器的&lt;a href=&quot;status/300&quot;&gt; &lt;code&gt;300&lt;/code&gt; &lt;/a&gt;（多项选择）或&lt;a href=&quot;status/406&quot;&gt; &lt;code&gt;406&lt;/code&gt; &lt;/a&gt;（不可接受）&lt;a href=&quot;status&quot;&gt;HTTP响应代码&lt;/a&gt;（&lt;em&gt;代理驱动的协商&lt;/em&gt;或&lt;em&gt;反应式协商&lt;/em&gt;），用作回退机制。</target>
        </trans-unit>
        <trans-unit id="7a2ea4621d5db4a0643b172c60b9729d03740461" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;status/300&quot;&gt;&lt;code&gt;300&lt;/code&gt;&lt;/a&gt; (Multiple Choices) or &lt;a href=&quot;status/406&quot;&gt;&lt;code&gt;406&lt;/code&gt;&lt;/a&gt; (Not Acceptable), &lt;a href=&quot;status/415&quot;&gt;&lt;code&gt;415&lt;/code&gt;&lt;/a&gt; (Unsupported Media Type) &lt;a href=&quot;status&quot;&gt;HTTP response codes&lt;/a&gt; by the server (&lt;em&gt;agent-driven negotiation&lt;/em&gt; or &lt;em&gt;reactive negotiation&lt;/em&gt;), that are used as fallback mechanisms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdc1524f620c113ef489962d737efb33b27f2eac" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;te&quot;&gt;&lt;code&gt;TE&lt;/code&gt;&lt;/a&gt; request header needs to be set to &quot;trailers&quot; to allow trailer fields.</source>
          <target state="translated">需要将&lt;a href=&quot;te&quot;&gt; &lt;code&gt;TE&lt;/code&gt; &lt;/a&gt;请求标头设置为&amp;ldquo;预告片&amp;rdquo;以允许预告片字段。</target>
        </trans-unit>
        <trans-unit id="106d3051b32652488ca1792a9b8e10220f0e7a85" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;upgrade-insecure-requests&quot;&gt;&lt;code&gt;upgrade-insecure-requests&lt;/code&gt;&lt;/a&gt; directive is evaluated before &lt;code&gt;block-all-mixed-content&lt;/code&gt; and If the former is set, the latter is effectively a no-op. It is recommended to set one directive or the other &amp;ndash; not both, unless you want to force HTTPS on older browsers that do not force it after a redirect to HTTP.</source>
          <target state="translated">该&lt;a href=&quot;upgrade-insecure-requests&quot;&gt; &lt;code&gt;upgrade-insecure-requests&lt;/code&gt; &lt;/a&gt;之前指令评估 &lt;code&gt;block-all-mixed-content&lt;/code&gt; 和如果是前者设置，后者实际上是一个无操作。建议设置一个指令或另一个指令，而不要同时设置两个指令，除非您想在较旧的浏览器上强制使用HTTPS，而在重定向到HTTP之后不强制使用该浏览器。</target>
        </trans-unit>
        <trans-unit id="5a51eef50de25b01cedd4928f3f99c9fae3d5200" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;upgrade-insecure-requests&quot;&gt;&lt;code&gt;upgrade-insecure-requests&lt;/code&gt;&lt;/a&gt; directive is evaluated before &lt;code&gt;block-all-mixed-content&lt;/code&gt;. If the former is set, the latter does nothing, so set one directive or the other &amp;ndash; not both, unless you want to force HTTPS on older browsers that do not force it after a redirect to HTTP.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce5a0a42af328d6549a6884a0d4203b5b8180652" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;'src'&lt;/code&gt; origin is used in the iframe &lt;code&gt;allow&lt;/code&gt; attribute only, and is the &lt;em&gt;default&lt;/em&gt;&lt;code&gt;allowlist&lt;/code&gt; value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1e69a4edf06fe574fa80e88285f8fb7d88da970" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;'strict-dynamic'&lt;/code&gt; source expression specifies that the trust explicitly given to a script present in the markup, by accompanying it with a nonce or a hash, shall be propagated to all the scripts loaded by that root script. At the same time, any whitelist or source expressions such as &lt;code&gt;'self'&lt;/code&gt; or &lt;code&gt;'unsafe-inline'&lt;/code&gt; will be ignored. For example, a policy such as &lt;code&gt;script-src 'strict-dynamic' 'nonce-R4nd0m' https://whitelisted.com/&lt;/code&gt; would allow loading of a root script with &lt;code&gt;&amp;lt;script nonce=&quot;R4nd0m&quot; src=&quot;https://example.com/loader.js&quot;&amp;gt;&lt;/code&gt; and propagate that trust to any script loaded by &lt;code&gt;loader.js&lt;/code&gt;, but disallow loading scripts from &lt;code&gt;https://whitelisted.com/&lt;/code&gt; unless accompanied by a nonce or loaded from a trusted script.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b021b3c1d64f7dedfd2f1fd076264572ee155ed2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;'strict-dynamic&lt;/code&gt;' source expression specifies that the trust explicitly given to a script present in the markup, by accompanying it with a nonce or a hash, shall be propagated to all the scripts loaded by that root script. At the same time, any whitelist or source expressions such as &lt;code&gt;'self'&lt;/code&gt; or &lt;code&gt;'unsafe-inline'&lt;/code&gt; will be ignored. For example, a policy such as &lt;code&gt;script-src 'strict-dynamic' 'nonce-R4nd0m' https://whitelisted.com/&lt;/code&gt; would allow loading of a root script with &lt;code&gt;&amp;lt;script nonce=&quot;R4nd0m&quot; src=&quot;https://example.com/loader.js&quot;&amp;gt;&lt;/code&gt; and propagate that trust to any script loaded by &lt;code&gt;loader.js&lt;/code&gt;, but disallow loading scripts from &lt;code&gt;https://whitelisted.com/&lt;/code&gt; unless accompanied by a nonce or loaded from a trusted script.</source>
          <target state="translated">所述 &lt;code&gt;'strict-dynamic&lt;/code&gt; '源表达式指定的信任明确给出与存在于标记的脚本，通过用随机数或散列伴随它，应当被传播到所有由根脚本加载的脚本。同时，所有白名单或源表达式（例如 &lt;code&gt;'self'&lt;/code&gt; 或 &lt;code&gt;'unsafe-inline'&lt;/code&gt; 都将被忽略。例如，诸如 &lt;code&gt;script-src 'strict-dynamic' 'nonce-R4nd0m' https://whitelisted.com/&lt;/code&gt; 将允许使用 &lt;code&gt;&amp;lt;script nonce=&quot;R4nd0m&quot; src=&quot;https://example.com/loader.js&quot;&amp;gt;&lt;/code&gt; 加载根脚本example.com/loader.js&amp;ldquo;&amp;gt;并将信任关系传播到 &lt;code&gt;loader.js&lt;/code&gt; 加载的任何脚本，但不允许从 &lt;code&gt;https://whitelisted.com/&lt;/code&gt; 加载脚本：//whitelisted.com/ 除非伴随有随机数或从受信任的脚本加载。</target>
        </trans-unit>
        <trans-unit id="6382e529a182503f39a7f7388e99ab1653c33241" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;'unsafe-eval'&lt;/code&gt; source expression controls several script execution methods that create code from strings. If &lt;code&gt;'unsafe-eval'&lt;/code&gt; isn't specified with the &lt;code&gt;script-src&lt;/code&gt; directive, the following methods are blocked and won't have any effect:</source>
          <target state="translated">的 &lt;code&gt;'unsafe-eval'&lt;/code&gt; 源表达控件创建从串代码几个脚本执行方法。如果未使用 &lt;code&gt;script-src&lt;/code&gt; 指令指定 &lt;code&gt;'unsafe-eval'&lt;/code&gt; ，则以下方法将被阻止，并且将无效：</target>
        </trans-unit>
        <trans-unit id="7a974fff323538cd623f076264d18fe2300bde8a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;'unsafe-eval'&lt;/code&gt; source expression controls several style methods that create style declarations from strings. If &lt;code&gt;'unsafe-eval'&lt;/code&gt; isn't specified with the &lt;code&gt;style-src&lt;/code&gt; directive, the following methods are blocked and won't have any effect:</source>
          <target state="translated">在 &lt;code&gt;'unsafe-eval'&lt;/code&gt; 源表达控件创建的字符串样式声明几个样式的方法。如果未使用 &lt;code&gt;style-src&lt;/code&gt; 指令指定 &lt;code&gt;'unsafe-eval'&lt;/code&gt; ，则以下方法将被阻止，并且将不起作用：</target>
        </trans-unit>
        <trans-unit id="c3028d259a6399103c9ce4edc7dfac31909edc67" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.htaccess&lt;/code&gt; file references a &lt;code&gt;.htpasswd&lt;/code&gt; file in which each line consists of a username and a password separated by a colon (&lt;code&gt;:&lt;/code&gt;). You cannot see the actual passwords as they are &lt;a href=&quot;https://httpd.apache.org/docs/2.4/misc/password_encryptions.html&quot;&gt;hashed&lt;/a&gt; (using MD5-based hashing, in this case). Note that you can name your &lt;code&gt;.htpasswd&lt;/code&gt; file differently if you like, but keep in mind this file shouldn't be accessible to anyone. (Apache is usually configured to prevent access to &lt;code&gt;.ht*&lt;/code&gt; files).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7d8d01c839e9d424312b47d646a614086c80cdd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.htaccess&lt;/code&gt; file references a &lt;code&gt;.htpasswd&lt;/code&gt; file in which each line contains of a username and a password separated by a colon (&quot;:&quot;). You can not see the actual passwords as they are &lt;a href=&quot;https://httpd.apache.org/docs/2.4/misc/password_encryptions.html&quot;&gt;encrypted&lt;/a&gt; (md5 in this case). Note that you can name your &lt;code&gt;.htpasswd&lt;/code&gt; file differently if you like, but keep in mind this file shouldn't be accessible to anyone. (Apache is usually configured to prevent access to &lt;code&gt;.ht*&lt;/code&gt; files).</source>
          <target state="translated">的 &lt;code&gt;.htaccess&lt;/code&gt; 文件引用一个 &lt;code&gt;.htpasswd&lt;/code&gt; 文件，其中每一行包含一个用户名和密码分离由冒号（&amp;ldquo;：&amp;rdquo;）。您看不到实际的密码，因为它们已&lt;a href=&quot;https://httpd.apache.org/docs/2.4/misc/password_encryptions.html&quot;&gt;加密&lt;/a&gt;（在这种情况下为md5）。请注意，您可以根据需要将 &lt;code&gt;.htpasswd&lt;/code&gt; 文件命名为其他名称，但是请记住，任何人都不能访问该文件。（通常将Apache配置为阻止访问 &lt;code&gt;.ht*&lt;/code&gt; 文件）。</target>
        </trans-unit>
        <trans-unit id="01ea6c155e3bff628716e111f394e3a0636ae28e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.htaccess&lt;/code&gt; file typically looks like this:</source>
          <target state="translated">在 &lt;code&gt;.htaccess&lt;/code&gt; 文件通常是这样的：</target>
        </trans-unit>
        <trans-unit id="4140f45978733db50c0722e19703d0dd8732110c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;203&lt;/code&gt; response is similar to the value &lt;code&gt;&lt;a href=&quot;../headers/warning#Warning_codes&quot;&gt;214&lt;/a&gt;&lt;/code&gt;, meaning &lt;code&gt;Transformation Applied&lt;/code&gt;, of the &lt;a href=&quot;../headers/warning&quot;&gt;&lt;code&gt;Warning&lt;/code&gt;&lt;/a&gt; header code, which has the additional advantage of being applicable to responses with any status code.</source>
          <target state="translated">所述 &lt;code&gt;203&lt;/code&gt; 响应是类似的值 &lt;code&gt;&lt;a href=&quot;../headers/warning#Warning_codes&quot;&gt;214&lt;/a&gt;&lt;/code&gt; ，这意味着 &lt;code&gt;Transformation Applied&lt;/code&gt; ，所述的&lt;a href=&quot;../headers/warning&quot;&gt; &lt;code&gt;Warning&lt;/code&gt; &lt;/a&gt;标题代码，其具有可应用于与任何状态码的响应的附加优点。</target>
        </trans-unit>
        <trans-unit id="fd1e39721a458a8f43a8fa40e465369253ea6854" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;416&lt;/code&gt; response message contains a &lt;a href=&quot;../headers/content-range&quot;&gt;&lt;code&gt;Content-Range&lt;/code&gt;&lt;/a&gt; indicating an unsatisfied range (that is a &lt;code&gt;'*'&lt;/code&gt;) followed by a &lt;code&gt;'/'&lt;/code&gt; and the current length of the resource. E.g. &lt;code&gt;Content-Range: */12777&lt;/code&gt;</source>
          <target state="translated">所述 &lt;code&gt;416&lt;/code&gt; 响应消息包含&lt;a href=&quot;../headers/content-range&quot;&gt; &lt;code&gt;Content-Range&lt;/code&gt; &lt;/a&gt;指示不满意范围（即一个 &lt;code&gt;'*'&lt;/code&gt; ），接着是 &lt;code&gt;'/'&lt;/code&gt; 和资源的当前长度。例如， &lt;code&gt;Content-Range: */12777&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cc6eca35190b0a85bc179efcd6440ff5e420f987" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;416&lt;/code&gt; response message contains a &lt;a href=&quot;../headers/content-range&quot;&gt;&lt;code&gt;Content-Range&lt;/code&gt;&lt;/a&gt; indicating an unsatisfied range (that is a &lt;code&gt;'*'&lt;/code&gt;) followed by a &lt;code&gt;'/'&lt;/code&gt; and the current length of the resource. E.g. &lt;code&gt;Content-Range: bytes */12777&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="000250a8c920d71a596d42e3ba222cb0c276eb98" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;http://httpd.apache.org/docs/current/mod/mod_rewrite.html&quot;&gt;mod_rewrite&lt;/a&gt;&lt;/code&gt; module can also create redirects. It is more flexible, but a bit more complex.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d74ebb54bf35188baf88fab6ddfb03450100af2e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#attr-allow&quot;&gt;allow&lt;/a&gt;&lt;/code&gt; attribute on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="678867190bea86d25ddd4c42f7e5d5945a9962ee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes#attr-content&quot;&gt;content&lt;/a&gt;&lt;/code&gt; attribute should start with a number indicating how many seconds the browser should wait before redirecting to the given URL. Always set it to &lt;code&gt;0&lt;/code&gt; for accessibility compliance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e37ff63edc4a58e58577f391879495cdf22ee684" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes#attr-content&quot;&gt;content&lt;/a&gt;&lt;/code&gt; attribute starts with a number indicating how many seconds the browser should wait before redirecting to the given URL. Always set it to &lt;code&gt;0&lt;/code&gt;, for better accessibility.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes#attr-content&quot;&gt;content&lt;/a&gt;&lt;/code&gt; 与一些属性开始显示多少秒的浏览器重定向到指定的URL之前应该等待。始终将其设置为 &lt;code&gt;0&lt;/code&gt; ，以获得更好的可访问性。</target>
        </trans-unit>
        <trans-unit id="df94992d56f1ec3780068eef1f291a2bd6528445" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;https://developers.google.com/search/reference/robots_meta_tag#xrobotstag&quot;&gt;X-Robots-Tag&lt;/a&gt;&lt;/code&gt; HTTP header is used to indicate how a web page is to be indexed within public search engine results. The header is effectively equivalent to &lt;code&gt;&amp;lt;meta name=&quot;robots&quot; content=&quot;...&quot;&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d9f882bdef0f2fbd9c820397fd3355193604e73" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/previous-versions/windows/internet-explorer/ie-developer/compatibility/jj542450(v=vs.85)?#the-noopen-directive&quot;&gt;X-Download-Options&lt;/a&gt;&lt;/code&gt; HTTP header indicates that the browser (Internet Explorer) should not display the option to &quot;Open&quot; a file that has been downloaded from an application, to prevent phishing attacks as the file otherwise would gain access to execute in the context of the application. (Note: related &lt;a href=&quot;https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/18488178/&quot;&gt;MS Edge bug&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8570429a0850dacdf55e905b24382087aa950397" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;https://httpd.apache.org/docs/current/mod/mod_alias.html&quot;&gt;mod_alias&lt;/a&gt;&lt;/code&gt; module has &lt;code&gt;Redirect&lt;/code&gt; and &lt;code&gt;RedirectMatch&lt;/code&gt; directives that set up &lt;a href=&quot;status/302&quot;&gt;&lt;code&gt;302&lt;/code&gt;&lt;/a&gt; redirects by default:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a33077bdfc87f84fa941dba1652820231ca50a9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc5988#section-5&quot;&gt;Link&lt;/a&gt;&lt;/code&gt; entity-header field provides a means for serialising one or more links in HTTP headers. It is semantically equivalent to the HTML &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link&quot;&gt;&lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt;&lt;/a&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bf90377c54cfb58cf2ddd3a014cf93971e6153b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc5988#section-5&quot;&gt;Link&lt;/a&gt;&lt;/code&gt; entity-header field provides a means for serialising one or more links in HTTP headers. It is semantically equivalent to the HTML &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/docs/Web/HTML/Element/link&quot;&gt;&amp;lt;link&amp;gt;&lt;/a&gt;&lt;/code&gt; element.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc5988#section-5&quot;&gt;Link&lt;/a&gt;&lt;/code&gt; 实体头字段提供了在HTTP头中串行化一个或多个链接的装置。它在语义上等效于HTML &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/docs/Web/HTML/Element/link&quot;&gt;&amp;lt;link&amp;gt;&lt;/a&gt;&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="a78799203cafc041527d32fff46051e530f3f10a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#rfc.section.3.1&quot;&gt;Signature&lt;/a&gt;&lt;/code&gt; header field conveys a list of signatures for an exchange, each one accompanied by information about how to determine the authority of and refresh that signature.</source>
          <target state="translated">&amp;ldquo; &lt;code&gt;&lt;a href=&quot;https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#rfc.section.3.1&quot;&gt;Signature&lt;/a&gt;&lt;/code&gt; 标头字段传达用于交换的签名列表，每个列表都附带有关如何确定该签名的权限和刷新该签名的信息。</target>
        </trans-unit>
        <trans-unit id="ac287448eebb179af2b5fea39da63acb2f0e34a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#rfc.section.5.1.2&quot;&gt;Signed-Headers&lt;/a&gt;&lt;/code&gt; header field identifies an ordered list of response header fields to include in a signature.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#rfc.section.5.1.2&quot;&gt;Signed-Headers&lt;/a&gt;&lt;/code&gt; 报头字段标识响应的报头字段的有序列表中的签名包括。</target>
        </trans-unit>
        <trans-unit id="d982342366479f245d9e1687b6642ae3d345e689" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Accept-Ranges&lt;/strong&gt;&lt;/code&gt; response HTTP header is a marker used by the server to advertise its support of partial requests. The value of this field indicates the unit that can be used to define a range.</source>
          <target state="translated">所述 &lt;code&gt;&lt;strong&gt;Accept-Ranges&lt;/strong&gt;&lt;/code&gt; 响应HTTP标头是由服务器使用以通告其支持部分请求的标志物。该字段的值指示可用于定义范围的单位。</target>
        </trans-unit>
        <trans-unit id="d3c88e931c279d244b193828eb2439579c4ee0ab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Access-Control-Allow-Origin&lt;/strong&gt;&lt;/code&gt; response header indicates whether the response can be shared with requesting code from the given &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/origin&quot;&gt;origin&lt;/a&gt;.</source>
          <target state="translated">的 &lt;code&gt;&lt;strong&gt;Access-Control-Allow-Origin&lt;/strong&gt;&lt;/code&gt; 响应标头指示是否响应可以与来自给定的请求代码共享&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/origin&quot;&gt;原点&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e7e76f11cda78abd0588ec375967af559825d413" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Age&lt;/strong&gt;&lt;/code&gt; header contains the time in seconds the object has been in a proxy cache.</source>
          <target state="translated">该 &lt;code&gt;&lt;strong&gt;Age&lt;/strong&gt;&lt;/code&gt; 头包含以秒计的对象一直在代理缓存的时间。</target>
        </trans-unit>
        <trans-unit id="f9681dd052c79b13127ae3929a731da18e4b72d4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Allow&lt;/strong&gt;&lt;/code&gt; header lists the set of methods support by a resource.</source>
          <target state="translated">在 &lt;code&gt;&lt;strong&gt;Allow&lt;/strong&gt;&lt;/code&gt; 头列出了一套方法由资源支持。</target>
        </trans-unit>
        <trans-unit id="c95653d764bb42232e9cbd3888e86cd3686754bf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Allow&lt;/strong&gt;&lt;/code&gt; header lists the set of methods supported by a resource.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e78b75471626ac2160cc198bfd26d8ad9f80eb0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Early-Data&lt;/strong&gt;&lt;/code&gt; header is set by an intermediary to indicate that the request has been conveyed in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Transport_Layer_Security#TLS_1.3&quot;&gt;TLS early data&lt;/a&gt;, and also indicates that the intermediary understands the &lt;a href=&quot;../status/425&quot;&gt;&lt;code&gt;425 (Too Early)&lt;/code&gt;&lt;/a&gt; status code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d61bb0d627ec7b7f17d0bc47d697b57d00a1bc5f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Early-Data&lt;/strong&gt;&lt;/code&gt; header is set by an intermediate to indicates that the request has been conveyed in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Transport_Layer_Security#TLS_1.3&quot;&gt;TLS early data&lt;/a&gt;, and additionally indicates that an intermediary understands the &lt;a href=&quot;../status/425&quot;&gt;&lt;code&gt;425 (Too Early)&lt;/code&gt;&lt;/a&gt; status code. The &lt;code&gt;&lt;strong&gt;Early-Data&lt;/strong&gt;&lt;/code&gt; header is not set by the originator of the request (i.e., a browser).</source>
          <target state="translated">在 &lt;code&gt;&lt;strong&gt;Early-Data&lt;/strong&gt;&lt;/code&gt; 头通过中间到指示该请求已被输送设定&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Transport_Layer_Security#TLS_1.3&quot;&gt;TLS早期数据&lt;/a&gt;，并且附加地表示中介理解&lt;a href=&quot;../status/425&quot;&gt; &lt;code&gt;425 (Too Early)&lt;/code&gt; &lt;/a&gt;状态代码。在 &lt;code&gt;&lt;strong&gt;Early-Data&lt;/strong&gt;&lt;/code&gt; 报头不被请求的（即，浏览器）的始发者设定。</target>
        </trans-unit>
        <trans-unit id="e737d89463e54c8720f8ad63e418a0bfb0f07f1f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Expires&lt;/strong&gt;&lt;/code&gt; header contains the date/time after which the response is considered stale.</source>
          <target state="translated">的 &lt;code&gt;&lt;strong&gt;Expires&lt;/strong&gt;&lt;/code&gt; 报头包含的日期/时间之后，响应被视为失效。</target>
        </trans-unit>
        <trans-unit id="5be71a78718c793e01b9247dbf20bee8de751846" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;From&lt;/strong&gt;&lt;/code&gt; request header contains an Internet email address for a human user who controls the requesting user agent.</source>
          <target state="translated">在 &lt;code&gt;&lt;strong&gt;From&lt;/strong&gt;&lt;/code&gt; 请求头中包含的Internet电子邮件地址谁控制了请求的用户代理的人类用户。</target>
        </trans-unit>
        <trans-unit id="73a9129a968278840bcb3ecb81312e01ea1c7ad9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Host&lt;/strong&gt;&lt;/code&gt; request header specifies the domain name of the server (for virtual hosting), and (optionally) the TCP port number on which the server is listening.</source>
          <target state="translated">所述 &lt;code&gt;&lt;strong&gt;Host&lt;/strong&gt;&lt;/code&gt; 请求头指定的服务器的域名（虚拟主机），和（可选地）的TCP端口号上的服务器是听音。</target>
        </trans-unit>
        <trans-unit id="1d90ed71aec05b79116744d2cf8473e3277dfbc7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Host&lt;/strong&gt;&lt;/code&gt; request header specifies the host and port number of the server to which the request is being sent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36122c8169aa84d5fb618cc5e704f67fadc13a5e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Keep-Alive&lt;/strong&gt;&lt;/code&gt; general header allows the sender to hint about how the connection and may be used to set a timeout and a maximum amount of requests.</source>
          <target state="translated">的 &lt;code&gt;&lt;strong&gt;Keep-Alive&lt;/strong&gt;&lt;/code&gt; 的一般头允许有关如何连接，并且可以被用于设置超时时间，并且请求的最大数量的发送者提示。</target>
        </trans-unit>
        <trans-unit id="c0b74d9f17da8401496a5b8c7cf402bea1cb5769" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Keep-Alive&lt;/strong&gt;&lt;/code&gt; general header allows the sender to hint about how the connection may be used to set a timeout and a maximum amount of requests.</source>
          <target state="translated">的 &lt;code&gt;&lt;strong&gt;Keep-Alive&lt;/strong&gt;&lt;/code&gt; 的一般头允许有关如何连接可被用来设置一个超时和请求的最大数量的发送者提示。</target>
        </trans-unit>
        <trans-unit id="2fbf23d9b9327582f4f49a7ec76472bba6a6a4fa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Pragma&lt;/strong&gt;&lt;/code&gt; HTTP/1.0 general header is an implementation-specific header that may have various effects along the request-response chain. It is used for backwards compatibility with HTTP/1.0 caches where the &lt;code&gt;Cache-Control&lt;/code&gt; HTTP/1.1 header is not yet present.</source>
          <target state="translated">的 &lt;code&gt;&lt;strong&gt;Pragma&lt;/strong&gt;&lt;/code&gt; HTTP / 1.0一般报头是可以具有沿着所述请求-响应链的各种效果的实现特定的头。它用于与尚不存在 &lt;code&gt;Cache-Control&lt;/code&gt; HTTP / 1.1标头的HTTP / 1.0缓存向后兼容。</target>
        </trans-unit>
        <trans-unit id="df9c97c4ad9d61f0d260427224fcdc949c7f1596" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Referer&lt;/strong&gt;&lt;/code&gt; request header contains the address of the page making the request. When following a link, this would be the url of the page containing the link. When making AJAX requests to another domain, this would be your page's url. The &lt;code&gt;Referer&lt;/code&gt; header allows servers to identify where people are visiting them from and may use that data for analytics, logging, or optimized caching, for example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab3c55e276ce88c71d0f16074fd5ecc0e9f413f9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Referer&lt;/strong&gt;&lt;/code&gt; request header contains the address of the previous web page from which a link to the currently requested page was followed. The &lt;code&gt;Referer&lt;/code&gt; header allows servers to identify where people are visiting them from and may use that data for analytics, logging, or optimized caching, for example.</source>
          <target state="translated">该 &lt;code&gt;&lt;strong&gt;Referer&lt;/strong&gt;&lt;/code&gt; 的请求头中包含以前的web页面，从中当前请求页面的链接，随后的地址。该 &lt;code&gt;Referer&lt;/code&gt; 的头允许服务器，以确定那里的人们探访他们，并可以用来分析，记录，或优化的缓存数据，例如。</target>
        </trans-unit>
        <trans-unit id="f35781aa0d1de163111fee93c0d8d38911b682ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Server&lt;/strong&gt;&lt;/code&gt; header contains information about the software used by the origin server to handle the request.</source>
          <target state="translated">该 &lt;code&gt;&lt;strong&gt;Server&lt;/strong&gt;&lt;/code&gt; 头包含有关用作原始服务器处理请求的软件信息。</target>
        </trans-unit>
        <trans-unit id="d1b3c683e4cd677dc3be26bd03213dd34909bab4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Server&lt;/strong&gt;&lt;/code&gt; header describes the software used by the origin server that handled the request &amp;mdash; that is, the server that generated the response.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f72ba03805654f750e5994c434c6ce48268c191f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;TE&lt;/strong&gt;&lt;/code&gt; request header specifies the transfer encodings the user agent is willing to accept. (you could informally call it &lt;em&gt;&lt;code&gt;Accept-Transfer-Encoding&lt;/code&gt;&lt;/em&gt;, which would be more intuitive).</source>
          <target state="translated">的 &lt;code&gt;&lt;strong&gt;TE&lt;/strong&gt;&lt;/code&gt; 请求头指定的传输编码的用户代理是愿意接受。（您可以非正式地将其称为&lt;em&gt; &lt;code&gt;Accept-Transfer-Encoding&lt;/code&gt; &lt;/em&gt;，这将更加直观）。</target>
        </trans-unit>
        <trans-unit id="5652b37e21feb912010feecdf8d75ae0995d40af" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Timing-Allow-Origin&lt;/strong&gt;&lt;/code&gt; response header specifies origins that are allowed to see values of attributes retrieved via features of the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Resource_Timing_API&quot;&gt;Resource Timing API&lt;/a&gt;, which would otherwise be reported as zero due to cross-origin restrictions.</source>
          <target state="translated">的 &lt;code&gt;&lt;strong&gt;Timing-Allow-Origin&lt;/strong&gt;&lt;/code&gt; 响应标头指定允许看到经由的特征检索的属性的值的起源&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Resource_Timing_API&quot;&gt;资源时序API&lt;/a&gt;，否则会报告为零由于跨来源的限制。</target>
        </trans-unit>
        <trans-unit id="f06db3329ed9ad8dfc09e37ef09b6402d3732e8a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Via&lt;/strong&gt;&lt;/code&gt; general header is added by proxies, both forward and reverse proxies, and can appear in the request headers and the response headers. It is used for tracking message forwards, avoiding request loops, and identifying the protocol capabilities of senders along the request/response chain.</source>
          <target state="translated">在 &lt;code&gt;&lt;strong&gt;Via&lt;/strong&gt;&lt;/code&gt; 一般报头由代理添加，前向和反向代理，并且可以在请求头和响应标头出现。它用于跟踪消息转发，避免请求循环以及识别请求/响应链中发送者的协议功能。</target>
        </trans-unit>
        <trans-unit id="d2a25ab474d784c5f16b25d0aa6fcd7fc6ce7fc3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;X-Content-Type-Options&lt;/strong&gt;&lt;/code&gt; response HTTP header is a marker used by the server to indicate that the &lt;a href=&quot;../basics_of_http/mime_types&quot;&gt;MIME types&lt;/a&gt; advertised in the &lt;a href=&quot;content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; headers should not be changed and be followed. This allows to opt-out of &lt;a href=&quot;../basics_of_http/mime_types#MIME_sniffing&quot;&gt;MIME type sniffing&lt;/a&gt;, or, in other words, it is a way to say that the webmasters knew what they were doing.</source>
          <target state="translated">的 &lt;code&gt;&lt;strong&gt;X-Content-Type-Options&lt;/strong&gt;&lt;/code&gt; 响应HTTP标头是由服务器使用以指示该标记&lt;a href=&quot;../basics_of_http/mime_types&quot;&gt;MIME类型&lt;/a&gt;的广告&lt;a href=&quot;content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt;报头不应当被改变，并且被遵循。这样就可以选择不使用&lt;a href=&quot;../basics_of_http/mime_types#MIME_sniffing&quot;&gt;MIME类型嗅探&lt;/a&gt;，换句话说，这是一种表示网站管理员知道他们在做什么的方式。</target>
        </trans-unit>
        <trans-unit id="cd7aecd4c1fd5dec57a2c138b3e5a8c117d9036d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;X-Content-Type-Options&lt;/strong&gt;&lt;/code&gt; response HTTP header is a marker used by the server to indicate that the &lt;a href=&quot;../basics_of_http/mime_types&quot;&gt;MIME types&lt;/a&gt; advertised in the &lt;a href=&quot;content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; headers should not be changed and be followed. This is a way to opt out of &lt;a href=&quot;../basics_of_http/mime_types#MIME_sniffing&quot;&gt;MIME type sniffing&lt;/a&gt;, or, in other words, to say that the MIME types are deliberately configured.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bceacb1272f77c276df2ceb5f3eec10ddfee111d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;var&gt;platform&lt;/var&gt;&lt;/code&gt; part of the UA string indicates if Firefox is running on a phone-sized or tablet device. When Firefox runs on a device that has the phone form factor, there is a &lt;code&gt;Mobile;&lt;/code&gt; token in the &lt;code&gt;&lt;var&gt;platform&lt;/var&gt;&lt;/code&gt; part of the UA string. When Firefox runs on a tablet device, there is a &lt;code&gt;Tablet;&lt;/code&gt; token in the &lt;code&gt;&lt;var&gt;platform&lt;/var&gt;&lt;/code&gt; part of the UA string instead. For example:</source>
          <target state="translated">UA字符串的 &lt;code&gt;&lt;var&gt;platform&lt;/var&gt;&lt;/code&gt; 部分指示Firefox是否在手机大小或平板设备上运行。当Firefox在具有电话外形尺寸的设备上运行时，将显示 &lt;code&gt;Mobile;&lt;/code&gt; UA字符串的 &lt;code&gt;&lt;var&gt;platform&lt;/var&gt;&lt;/code&gt; 部分中的令牌。当Firefox在平板电脑设备上运行时，有一个 &lt;code&gt;Tablet;&lt;/code&gt; 而是在UA字符串的 &lt;code&gt;&lt;var&gt;platform&lt;/var&gt;&lt;/code&gt; 部分添加令牌。例如：</target>
        </trans-unit>
        <trans-unit id="82e98053eac989383e680a4cf5cc9358923e6dcb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Accept-CH-Lifetime&lt;/code&gt; header</source>
          <target state="translated">所述 &lt;code&gt;Accept-CH-Lifetime&lt;/code&gt; 头</target>
        </trans-unit>
        <trans-unit id="6df4384dcc248042b53e1dc48377a116aa3f10ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Accept-CH&lt;/code&gt; header</source>
          <target state="translated">所述 &lt;code&gt;Accept-CH&lt;/code&gt; 头</target>
        </trans-unit>
        <trans-unit id="c43f0f2a86e0d2275393478d7fdb73db5ffbaada" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Accept-Charset&lt;/code&gt; header</source>
          <target state="translated">该 &lt;code&gt;Accept-Charset&lt;/code&gt; 报头</target>
        </trans-unit>
        <trans-unit id="2cb1ca877d3eb1b0f248f74c9ec40232997e5dc5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Accept-Charset&lt;/code&gt; request HTTP header advertises which &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/character_encoding&quot;&gt;character encodings&lt;/a&gt; the client understands. Using &lt;a href=&quot;../content_negotiation&quot;&gt;content negotiation&lt;/a&gt;, the server selects one of the encodings, uses it, and informs the client of its choice within the &lt;a href=&quot;content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; response header, usually in a &lt;code&gt;charset=&lt;/code&gt; parameter. Browsers usually don't send this header, as the default value for each resource is usually correct and transmitting it would allow &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/Firefox/Privacy/Tracking_Protection&quot;&gt;fingerprinting&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e1a79dc44f6324b9656f0e9b91f70c6b6ee9b87" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Accept-Charset&lt;/code&gt; request HTTP header advertises which character set the client is able to understand. Using &lt;a href=&quot;../content_negotiation&quot;&gt;content negotiation&lt;/a&gt;, the server then selects one of the proposals, uses it and informs the client of its choice within the &lt;a href=&quot;content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; response header. Browsers usually don't set this header as the default value for each content type is usually correct and transmitting it would allow easier fingerprinting.</source>
          <target state="translated">的 &lt;code&gt;Accept-Charset&lt;/code&gt; 请求的HTTP标头通告哪些字符集，客户端是能够理解。然后，使用&lt;a href=&quot;../content_negotiation&quot;&gt;内容协商&lt;/a&gt;，服务器选择建议之一，使用建议，然后在&lt;a href=&quot;content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt;响应标头中将其选择通知客户。浏览器通常不设置此标头，因为每种内容类型的默认值通常是正确的，并且传输它可以使指纹更容易识别。</target>
        </trans-unit>
        <trans-unit id="32e4c478c87a3a2796f89e9931f3a93966bdfdbf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Accept-Encoding&lt;/code&gt; header</source>
          <target state="translated">在 &lt;code&gt;Accept-Encoding&lt;/code&gt; 头</target>
        </trans-unit>
        <trans-unit id="91185be688fa9da1a182310f6df358fd174c46f1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Accept-Encoding&lt;/code&gt; request HTTP header advertises which content encoding, usually a compression algorithm, the client is able to understand. Using &lt;a href=&quot;../content_negotiation&quot;&gt;content negotiation&lt;/a&gt;, the server selects one of the proposals, uses it and informs the client of its choice with the &lt;a href=&quot;content-encoding&quot;&gt;&lt;code&gt;Content-Encoding&lt;/code&gt;&lt;/a&gt; response header.</source>
          <target state="translated">所述 &lt;code&gt;Accept-Encoding&lt;/code&gt; 请求的HTTP标头通告其内容编码，通常是一个压缩算法中，客户端是能够理解的。通过使用&lt;a href=&quot;../content_negotiation&quot;&gt;内容协商&lt;/a&gt;，服务器选择建议之一，使用建议，并通过&lt;a href=&quot;content-encoding&quot;&gt; &lt;code&gt;Content-Encoding&lt;/code&gt; &lt;/a&gt;响应标头将其选择通知客户端。</target>
        </trans-unit>
        <trans-unit id="3ae7d36d36006ff093b2a55d71bd74d51e77b3ef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Accept-Language&lt;/code&gt; header</source>
          <target state="translated">在 &lt;code&gt;Accept-Language&lt;/code&gt; 头</target>
        </trans-unit>
        <trans-unit id="c4a25b290f315f1cab7813fec6b003a441c0d600" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Accept-Language&lt;/code&gt; request HTTP header advertises which languages the client is able to understand, and which locale variant is preferred. (By languages, we mean natural languages, such as English, and not programming languages.) Using &lt;a href=&quot;../content_negotiation&quot;&gt;content negotiation&lt;/a&gt;, the server then selects one of the proposals, uses it and informs the client of its choice with the &lt;a href=&quot;content-language&quot;&gt;&lt;code&gt;Content-Language&lt;/code&gt;&lt;/a&gt; response header. Browsers set adequate values for this header according to their user interface language and even if a user can change it, this happens rarely (and is frowned upon as it leads to fingerprinting).</source>
          <target state="translated">在 &lt;code&gt;Accept-Language&lt;/code&gt; 请求的HTTP标头通告哪些语言客户端是能够理解，并且其区域的变体是优选的。（通过语言，我们指的是自然语言，例如英语，而不是编程语言。）使用&lt;a href=&quot;../content_negotiation&quot;&gt;内容协商&lt;/a&gt;，服务器然后选择一个建议，使用它，并通过&lt;a href=&quot;content-language&quot;&gt; &lt;code&gt;Content-Language&lt;/code&gt; &lt;/a&gt;响应标头将其选择通知客户。浏览器会根据其用户界面语言为该标头设置足够的值，即使用户可以更改它，这种情况也很少发生（并且会导致指纹识别，因此对此不以为然）。</target>
        </trans-unit>
        <trans-unit id="f1004b9f5d3731dda0f9cb684f40a19f9053e7da" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Accept&lt;/code&gt; header</source>
          <target state="translated">在 &lt;code&gt;Accept&lt;/code&gt; 头</target>
        </trans-unit>
        <trans-unit id="826c8958d78002b0f5bee62cfd9d7b4401ff27e1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Accept&lt;/code&gt; request HTTP header advertises which content types, expressed as &lt;a href=&quot;../basics_of_http/mime_types&quot;&gt;MIME types&lt;/a&gt;, the client is able to understand. Using &lt;a href=&quot;../content_negotiation&quot;&gt;content negotiation&lt;/a&gt;, the server then selects one of the proposals, uses it and informs the client of its choice with the &lt;a href=&quot;content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; response header. Browsers set adequate values for this header depending on the context where the request is done: when fetching a CSS stylesheet a different value is set for the request than when fetching an image, video or a script.</source>
          <target state="translated">该 &lt;code&gt;Accept&lt;/code&gt; 请求HTTP头通告哪些内容类型，表示为&lt;a href=&quot;../basics_of_http/mime_types&quot;&gt;MIME类型&lt;/a&gt;，客户端是能够理解的。然后，使用&lt;a href=&quot;../content_negotiation&quot;&gt;内容协商&lt;/a&gt;，服务器选择建议之一，使用建议，并通过&lt;a href=&quot;content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt;响应标头将其选择通知客户端。浏览器会根据完成请求的上下文为此标头设置适当的值：获取CSS样式表时，为请求设置的值与获取图像，视频或脚本时不同。</target>
        </trans-unit>
        <trans-unit id="44e072ab59ddfb74fd5772684f9e86075ecb4b7a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; header works in conjunction with the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials&quot;&gt;&lt;code&gt;XMLHttpRequest.withCredentials&lt;/code&gt;&lt;/a&gt; property or with the &lt;code&gt;credentials&lt;/code&gt; option in the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request/Request&quot;&gt;&lt;code&gt;Request()&lt;/code&gt;&lt;/a&gt; constructor of the Fetch API. For a CORS request with credentials, in order for browsers to expose the response to frontend JavaScript code, both the server (using the &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; header) and the client (by setting the credentials mode for the XHR, Fetch, or Ajax request) must indicate that they&amp;rsquo;re opting in to including credentials.</source>
          <target state="translated">该 &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; 与头部结合工作&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials&quot;&gt; &lt;code&gt;XMLHttpRequest.withCredentials&lt;/code&gt; &lt;/a&gt;财产或与 &lt;code&gt;credentials&lt;/code&gt; 的选项&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request/Request&quot;&gt; &lt;code&gt;Request()&lt;/code&gt; &lt;/a&gt;的提取API的构造。对于具有凭据的CORS请求，为了使浏览器将响应公开给前端JavaScript代码，服务器（使用 &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; 标头）和客户端（通过为XHR设置凭据模式，获取，或Ajax请求）必须表明他们选择加入凭据。</target>
        </trans-unit>
        <trans-unit id="b7dcdecf1d26a57b7f2c288b092d6918cb0c9128" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; response header indicates whether or not the response to the request can be exposed to the page. It can be exposed when the &lt;code&gt;true&lt;/code&gt; value is returned.</source>
          <target state="translated">的 &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; 响应报头指示的请求的响应是否可以暴露于该页面。返回 &lt;code&gt;true&lt;/code&gt; 值时可以将其公开。</target>
        </trans-unit>
        <trans-unit id="3c6671b887bc83cf312809fdd2c8e99c4197d40f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; response header tells browsers whether to expose the response to frontend JavaScript code when the request's credentials mode (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request/credentials&quot;&gt;&lt;code&gt;Request.credentials&lt;/code&gt;&lt;/a&gt;) is &quot;&lt;code&gt;include&lt;/code&gt;&quot;.</source>
          <target state="translated">的 &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; 响应头告诉浏览器是否以暴露响应于前端JavaScript代码当请求的凭证模式（&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request/credentials&quot;&gt; &lt;code&gt;Request.credentials&lt;/code&gt; &lt;/a&gt;）为&amp;ldquo; &lt;code&gt;include&lt;/code&gt; &amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="f12c8be59963d49889bc73472fd35b514c851a07" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; response header tells browsers whether to expose the response to frontend JavaScript code when the request's credentials mode (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request/credentials&quot;&gt;&lt;code&gt;Request.credentials&lt;/code&gt;&lt;/a&gt;) is &lt;code&gt;include&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72353e1b96e08b162b2efe8857a396c5cd57de4d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; header is sent by the server in response to a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/preflight_request&quot;&gt;preflight request&lt;/a&gt;; it lets the client know which &lt;a href=&quot;../../headers&quot;&gt;HTTP headers&lt;/a&gt; are permitted in CORS requests. If the client &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;user agent&lt;/a&gt; finds among the comma-delineated values provided by the header any header name it does not recognize, this error occurs.</source>
          <target state="translated">的 &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; 头是通过响应于所述服务器发送&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/preflight_request&quot;&gt;预检请求&lt;/a&gt; ;它让客户端知道在CORS请求中允许使用哪些&lt;a href=&quot;../../headers&quot;&gt;HTTP标头&lt;/a&gt;。如果客户端&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;用户代理&lt;/a&gt;在标头提供的逗号描述的值中找到它无法识别的任何标头名称，则会发生此错误。</target>
        </trans-unit>
        <trans-unit id="0864906322164b5b88f217b19f6a18996814ca0d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; header is sent by the server to let the client know which headers it supports for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; requests. The value of &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; should be a comma-delineated list of header names, such as &quot;&lt;code&gt;X-Custom-Information&lt;/code&gt;&quot; or any of the standard but non-basic header names (which are always allowed).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd672b7157d867818df2e4b6551047d6d6feb57a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; header is sent by the server to let the client know which headers it supports for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; requests. The value of &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; should be a comma-delineated list of header names, such as &lt;code&gt;&quot;X-Custom-Information&quot;&lt;/code&gt; or any of the standard but non-basic header names (which are always allowed).</source>
          <target state="translated">该 &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; 报头由服务器发送让它支持其头部客户知道&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt;请求。的值 &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; 应该是一个逗号划定标题名称，如列表 &lt;code&gt;&quot;X-Custom-Information&quot;&lt;/code&gt; 或任何标准的但非基本报头的名称（始终允许）的。</target>
        </trans-unit>
        <trans-unit id="7ff32aaa41aa73f3f46503d5b741dbb0efe92ed8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; response header is used in response to a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/preflight_request&quot;&gt;preflight request&lt;/a&gt; which includes the &lt;a href=&quot;access-control-request-headers&quot;&gt;&lt;code&gt;Access-Control-Request-Headers&lt;/code&gt;&lt;/a&gt; to indicate which HTTP headers can be used during the actual request.</source>
          <target state="translated">的 &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; 响应报头在响应用于一个&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/preflight_request&quot;&gt;预检请求&lt;/a&gt;，其中包括所述&lt;a href=&quot;access-control-request-headers&quot;&gt; &lt;code&gt;Access-Control-Request-Headers&lt;/code&gt; &lt;/a&gt;，以指示该HTTP报头可以在实际请求期间使用。</target>
        </trans-unit>
        <trans-unit id="e0316b88b462433d980db8987aaedc7affa9a74d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; header is sent by the server to let the client know what &lt;a href=&quot;../../methods&quot;&gt;HTTP request methods&lt;/a&gt; it supports for CORS requests. The header's value is a comma-delineated string of HTTP method names, such as &lt;a href=&quot;../../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;../../methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt;. If any of the specified values are not recognized by the client &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;user agent&lt;/a&gt;, this error occurs.</source>
          <target state="translated">该 &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; 报头由服务器发送，让客户知道什么是&lt;a href=&quot;../../methods&quot;&gt;HTTP请求方法&lt;/a&gt;它支持CORS请求。标头的值是HTTP方法名称的逗号分隔字符串，例如&lt;a href=&quot;../../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../../methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../../methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; &lt;/a&gt;。如果客户端&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;用户代理&lt;/a&gt;无法识别任何指定的值，则会发生此错误。</target>
        </trans-unit>
        <trans-unit id="77116c8fb41e193fc817da845099a6fb246839d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; response header specifies the method or methods allowed when accessing the resource in response to a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/preflight_request&quot;&gt;preflight request&lt;/a&gt;.</source>
          <target state="translated">的 &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; 响应标头指定响应访问所述资源到一个当该方法或方法允许&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/preflight_request&quot;&gt;预检请求&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="067f39d99ac015284dffa6b70703714ad54ce876" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Access-Control-Expose-Headers&lt;/code&gt; response header indicates which headers can be exposed as part of the response by listing their names.</source>
          <target state="translated">的 &lt;code&gt;Access-Control-Expose-Headers&lt;/code&gt; 响应报头指示哪些报头可以公开为通过列出他们的名字的响应的一部分。</target>
        </trans-unit>
        <trans-unit id="0d0b9369d0f212ed412c895390853280713fe380" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Access-Control-Max-Age&lt;/code&gt; response header indicates how long the results of a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/preflight_request&quot;&gt;preflight request&lt;/a&gt; (that is the information contained in the &lt;a href=&quot;access-control-allow-methods&quot;&gt;&lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;access-control-allow-headers&quot;&gt;&lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt;&lt;/a&gt; headers) can be cached.</source>
          <target state="translated">的 &lt;code&gt;Access-Control-Max-Age&lt;/code&gt; 响应报头指示的结果多久&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/preflight_request&quot;&gt;预检请求&lt;/a&gt;（即包含在信息&lt;a href=&quot;access-control-allow-methods&quot;&gt; &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;access-control-allow-headers&quot;&gt; &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; &lt;/a&gt;头）可以被缓存。</target>
        </trans-unit>
        <trans-unit id="d911724c3b9a4293a98fa691e196743b5241679f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Access-Control-Request-Headers&lt;/code&gt; request header is used by browsers when issuing a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/preflight_request&quot;&gt;preflight request&lt;/a&gt;, to let the server know which &lt;a href=&quot;../headers&quot;&gt;HTTP headers&lt;/a&gt; the client might send when the actual request is made.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dafa896f612431fbab583cf168f3881c2f6b27aa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Access-Control-Request-Headers&lt;/code&gt; request header is used when issuing a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/preflight_request&quot;&gt;preflight request&lt;/a&gt; to let the server know which &lt;a href=&quot;../headers&quot;&gt;HTTP headers&lt;/a&gt; will be used when the actual request is made.</source>
          <target state="translated">的 &lt;code&gt;Access-Control-Request-Headers&lt;/code&gt; 发出请求时报头用于&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/preflight_request&quot;&gt;预检请求&lt;/a&gt;让服务器知道哪些&lt;a href=&quot;../headers&quot;&gt;HTTP头&lt;/a&gt;的实际请求时将被使用。</target>
        </trans-unit>
        <trans-unit id="da80f865ca3264cb02c6582db1c71f9050cac42c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Access-Control-Request-Method&lt;/code&gt; request header is used by browsers when issuing a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/preflight_request&quot;&gt;preflight request&lt;/a&gt;, to let the server know which &lt;a href=&quot;../methods&quot;&gt;HTTP method&lt;/a&gt; will be used when the actual request is made. This header is necessary as the preflight request is always an &lt;a href=&quot;../methods/options&quot;&gt;&lt;code&gt;OPTIONS&lt;/code&gt;&lt;/a&gt; and doesn't use the same method as the actual request.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c04d281d947283fc5e13f4243911531dd1e81ae" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Access-Control-Request-Method&lt;/code&gt; request header is used when issuing a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/preflight_request&quot;&gt;preflight request&lt;/a&gt; to let the server know which &lt;a href=&quot;../methods&quot;&gt;HTTP method&lt;/a&gt; will be used when the actual request is made. This header is necessary as the preflight request is always an &lt;a href=&quot;../methods/options&quot;&gt;&lt;code&gt;OPTIONS&lt;/code&gt;&lt;/a&gt; and doesn't use the same method as the actual request.</source>
          <target state="translated">的 &lt;code&gt;Access-Control-Request-Method&lt;/code&gt; 发出请求时报头用于&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/preflight_request&quot;&gt;预检请求&lt;/a&gt;让服务器知道哪些&lt;a href=&quot;../methods&quot;&gt;HTTP方法&lt;/a&gt;的实际请求时将被使用。此标头是必需的，因为预检请求始终是&lt;a href=&quot;../methods/options&quot;&gt; &lt;code&gt;OPTIONS&lt;/code&gt; &lt;/a&gt;，并且不使用与实际请求相同的方法。</target>
        </trans-unit>
        <trans-unit id="c0cd5616b768c68f7ab87609f718d08faf8821ee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Age&lt;/code&gt; header is usually close to zero. If it is &lt;code&gt;Age: 0&lt;/code&gt;, it was probably just fetched from the origin server; otherwise It is usually calculated as a difference between the proxy's current date and the &lt;a href=&quot;date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; general header included in the HTTP response.</source>
          <target state="translated">该 &lt;code&gt;Age&lt;/code&gt; 头通常接近于零。如果是 &lt;code&gt;Age: 0&lt;/code&gt; ，则可能是从原始服务器获取的；否则，通常将其计算为代理的当前日期与HTTP响应中包含的&lt;a href=&quot;date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;常规标头之间的差。</target>
        </trans-unit>
        <trans-unit id="86a92479e304493df13e1947522f656380ef064d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Alt-Svc&lt;/code&gt; HTTP response header is used to advertise alternative services through which the same resource can be reached. An alternative service is defined by a protocol/host/port combination.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58db6b4226911c9c041223607c76d210c4b75632" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Alt-Svc&lt;/code&gt; header is used to list alternate ways to reach this website.</source>
          <target state="translated">在 &lt;code&gt;Alt-Svc&lt;/code&gt; 头用于列表替代方式达到这个网站。</target>
        </trans-unit>
        <trans-unit id="f8bcd29c16619b65da2808b96987a30c145398a8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CONNECT&lt;/code&gt; method establishes a tunnel to the server identified by the target resource.</source>
          <target state="translated">该 &lt;code&gt;CONNECT&lt;/code&gt; 方法建立隧道，通过目标资源标识的服务器。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
