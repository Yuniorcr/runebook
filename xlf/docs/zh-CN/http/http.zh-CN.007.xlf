<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="http">
    <body>
      <group id="http">
        <trans-unit id="eac57a1de8acde9c46e58fb564a5c63eef8c02df" translate="yes" xml:space="preserve">
          <source>Some of these new methods do not define bodies.  Servers MUST examine
   all requests for a body, even when a body was not expected.  In cases
   where a request body is present but would be ignored by a server, the
   server MUST reject the request with 415 (Unsupported Media Type).
   This informs the client (which may have been attempting to use an
   extension) that the body could not be processed as the client
   intended.</source>
          <target state="translated">其中一些新方法没有定义body。服务器必须检查所有的请求是否有body,即使是在不期望有body的情况下。在请求主体存在但服务器会忽略的情况下,服务器必须用415(Unsupported Media Type)拒绝请求。这将通知客户机(它可能一直在尝试使用扩展),主体不能按照客户机的意图进行处理。</target>
        </trans-unit>
        <trans-unit id="4e4cf2038e1894371084626084a37cd3855e9122" translate="yes" xml:space="preserve">
          <source>Some origin server implementations might not have a clock available.
   An origin server without a clock MUST NOT assign Expires or Last-
   Modified values to a response, unless these values were associated
   with the resource by a system or user with a reliable clock. It MAY
   assign an Expires value that is known, at or before server
   configuration time, to be in the past (this allows &quot;pre-expiration&quot;
   of responses without storing separate Expires values for each
   resource).</source>
          <target state="translated">一些原点服务器实现可能没有可用的时钟,没有时钟的原点服务器必须不给响应分配Expires或Last-Modified值,除非这些值是由具有可靠时钟的系统或用户与资源相关联的。没有时钟的原点服务器不得给响应分配过期值或最后修改值,除非这些值是由具有可靠时钟的系统或用户与资源关联的。它可以分配一个在服务器配置时间或之前已知的过期值(这允许响应的 &quot;预过期&quot;,而无需为每个资源存储单独的过期值)。</target>
        </trans-unit>
        <trans-unit id="03c3e50ec8cb12cf3acddc31b3a981323a1ddf6c" translate="yes" xml:space="preserve">
          <source>Some pages may be protected so only specific users can access it. Basic authentication may be provided by HTTP, either using the &lt;a href=&quot;headers/www-authenticate&quot;&gt;&lt;code&gt;WWW-Authenticate&lt;/code&gt;&lt;/a&gt; and similar headers, or by setting a specific session using &lt;a href=&quot;cookies&quot;&gt;HTTP cookies&lt;/a&gt;.</source>
          <target state="translated">某些页面可能受到保护，因此只有特定用户才能访问它。HTTP可以使用&lt;a href=&quot;headers/www-authenticate&quot;&gt; &lt;code&gt;WWW-Authenticate&lt;/code&gt; &lt;/a&gt;和类似的标头，或者通过使用&lt;a href=&quot;cookies&quot;&gt;HTTP cookie&lt;/a&gt;设置特定的会话，来提供基本身份验证。</target>
        </trans-unit>
        <trans-unit id="9d9fd2b2a9f9cc9b203fa68ab92a78cbe025ac65" translate="yes" xml:space="preserve">
          <source>Some pages may be protected so that only specific users can access them. Basic authentication may be provided by HTTP, either using the &lt;a href=&quot;headers/www-authenticate&quot;&gt;&lt;code&gt;WWW-Authenticate&lt;/code&gt;&lt;/a&gt; and similar headers, or by setting a specific session using &lt;a href=&quot;cookies&quot;&gt;HTTP cookies&lt;/a&gt;.</source>
          <target state="translated">某些页面可能受到保护，因此只有特定的用户才能访问它们。HTTP可以使用&lt;a href=&quot;headers/www-authenticate&quot;&gt; &lt;code&gt;WWW-Authenticate&lt;/code&gt; &lt;/a&gt;和类似的标头，或者通过使用&lt;a href=&quot;cookies&quot;&gt;HTTP cookie&lt;/a&gt;设置特定的会话，来提供基本身份验证。</target>
        </trans-unit>
        <trans-unit id="7a7d1f4b13e76bd620feb3c514de20a064d7ef93" translate="yes" xml:space="preserve">
          <source>Some proxy servers might need authority to create a tunnel. See also the &lt;a href=&quot;../headers/proxy-authorization&quot;&gt;&lt;code&gt;Proxy-Authorization&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">某些代理服务器可能需要授权才能创建隧道。另请参见&amp;ldquo; &lt;a href=&quot;../headers/proxy-authorization&quot;&gt; &lt;code&gt;Proxy-Authorization&lt;/code&gt; &lt;/a&gt;标头。</target>
        </trans-unit>
        <trans-unit id="f0fe168232211ebb71557e7e371b951b8fb141f8" translate="yes" xml:space="preserve">
          <source>Some requests don&amp;rsquo;t trigger a &lt;a href=&quot;#Preflighted_requests&quot;&gt;CORS preflight&lt;/a&gt;. Those are called &amp;ldquo;simple requests&amp;rdquo; in this article, though the &lt;a href=&quot;https://fetch.spec.whatwg.org/&quot;&gt;Fetch&lt;/a&gt; spec (which defines CORS) doesn&amp;rsquo;t use that term. A request that doesn&amp;rsquo;t trigger a &lt;a href=&quot;#Preflighted_requests&quot;&gt;CORS preflight&lt;/a&gt;&amp;mdash;a so-called &amp;ldquo;simple request&amp;rdquo; &amp;mdash; is one that &lt;strong&gt;meets all the following conditions&lt;/strong&gt;:</source>
          <target state="translated">有些请求不会触发&lt;a href=&quot;#Preflighted_requests&quot;&gt;CORS的飞行前检查&lt;/a&gt;。尽管&lt;a href=&quot;https://fetch.spec.whatwg.org/&quot;&gt;Fetch&lt;/a&gt;规范（定义了CORS）没有使用该术语，但在本文中将这些称为&amp;ldquo;简单请求&amp;rdquo; 。不会触发&lt;a href=&quot;#Preflighted_requests&quot;&gt;CORS预检的&lt;/a&gt;请求（即所谓的&amp;ldquo;简单请求&amp;rdquo;）是&lt;strong&gt;满足以下所有条件的&lt;/strong&gt;请求：</target>
        </trans-unit>
        <trans-unit id="9dcff009cb4590f1396339dc97ee7e3c2dfd40fa" translate="yes" xml:space="preserve">
          <source>Some requests don&amp;rsquo;t trigger a &lt;a href=&quot;#Preflighted_requests&quot;&gt;CORS preflight&lt;/a&gt;. Those are called &lt;em&gt;&amp;ldquo;simple requests&amp;rdquo;&lt;/em&gt; in this article, though the &lt;a href=&quot;https://fetch.spec.whatwg.org/&quot;&gt;Fetch&lt;/a&gt; spec (which defines CORS) doesn&amp;rsquo;t use that term. A &amp;ldquo;simple request&amp;rdquo; is one that &lt;strong&gt;meets all the following conditions&lt;/strong&gt;:</source>
          <target state="translated">有些请求不会触发&lt;a href=&quot;#Preflighted_requests&quot;&gt;CORS的飞行前检查&lt;/a&gt;。尽管&lt;a href=&quot;https://fetch.spec.whatwg.org/&quot;&gt;Fetch&lt;/a&gt;规范（定义了CORS）未使用该术语，但在本文中将其称为&lt;em&gt;&amp;ldquo;简单请求&amp;rdquo;&lt;/em&gt;。&amp;ldquo;简单请求&amp;rdquo;是&lt;strong&gt;满足以下所有条件的&lt;/strong&gt;请求：&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9b7772fe71270600ccf3a3236874e99cde15c3a7" translate="yes" xml:space="preserve">
          <source>Some requests may need more time on the server like sometimes &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/DELETE&quot;&gt;&lt;code&gt;DELETE&lt;/code&gt;&lt;/a&gt; requests that are scheduled for later processing. In this case, the response is a &lt;a href=&quot;status/303&quot;&gt;&lt;code&gt;303&lt;/code&gt;&lt;/a&gt; (See Other) redirect that links to a page indicating that the action has been scheduled, and eventually informs about the progress, or allows to cancel it.</source>
          <target state="translated">一些请求可能需要在服务器上花费更多的时间，例如有时将&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/DELETE&quot;&gt; &lt;code&gt;DELETE&lt;/code&gt; &lt;/a&gt;请求安排在以后的处理中。在这种情况下，响应是&lt;a href=&quot;status/303&quot;&gt; &lt;code&gt;303&lt;/code&gt; &lt;/a&gt;（请参阅其他）重定向，该链接链接到指示该操作已计划的页面，并最终通知进度或允许取消该进度。</target>
        </trans-unit>
        <trans-unit id="e69ac0ff78ca934a19fc41226c03d69cd112b823" translate="yes" xml:space="preserve">
          <source>Some requests may need more time on the server, like &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/DELETE&quot;&gt;&lt;code&gt;DELETE&lt;/code&gt;&lt;/a&gt; requests that are scheduled for later processing. In this case, the response is a &lt;a href=&quot;status/303&quot;&gt;&lt;code&gt;303&lt;/code&gt;&lt;/a&gt; (See Other) redirect that links to a page indicating that the action has been scheduled, and eventually informs about its progress, or allows to cancel it.</source>
          <target state="translated">某些请求可能需要在服务器上花费更多时间，例如安排用于以后处理的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/DELETE&quot;&gt; &lt;code&gt;DELETE&lt;/code&gt; &lt;/a&gt;请求。在这种情况下，响应是&lt;a href=&quot;status/303&quot;&gt; &lt;code&gt;303&lt;/code&gt; &lt;/a&gt;（请参阅其他）重定向，该链接链接到指示该动作已计划的页面，并最终告知其进度或允许取消该动作。</target>
        </trans-unit>
        <trans-unit id="932d714aa9986fefde686199be3c38ba8d61e288" translate="yes" xml:space="preserve">
          <source>Some sections of this specification are illustrated with fragments of
   a non-normative RELAX NG Compact schema [&lt;a href=&quot;#ref-RNC&quot;&gt;RNC&lt;/a&gt;].  However, the text of
   this specification provides the definition of conformance.  Complete
   schemas appear in &lt;a href=&quot;#appendix-B&quot;&gt;Appendix B&lt;/a&gt;.</source>
          <target state="translated">本规范的某些部分以非规范RELAX NG Compact模式[ &lt;a href=&quot;#ref-RNC&quot;&gt;RNC&lt;/a&gt; ]的片段进行了说明。但是，本规范的文本提供了一致性的定义。完整的模式显示在&lt;a href=&quot;#appendix-B&quot;&gt;附录B中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cbcfbee9d39daa00061999fcaad831841c2ed71a" translate="yes" xml:space="preserve">
          <source>Some websites use this response for requests they do not wish to handle, such as automated queries.</source>
          <target state="translated">一些网站将此响应用于他们不希望处理的请求,如自动查询。</target>
        </trans-unit>
        <trans-unit id="bf1960a9dab8a69c52ce013a2615773d1727df49" translate="yes" xml:space="preserve">
          <source>Sometimes a user agent might want or need to insist that a cache
   revalidate its cache entry with the origin server (and not just with
   the next cache along the path to the origin server), or to reload its
   cache entry from the origin server. End-to-end revalidation might be
   necessary if either the cache or the origin server has overestimated
   the expiration time of the cached response. End-to-end reload may be
   necessary if the cache entry has become corrupted for some reason.

   End-to-end revalidation may be requested either when the client does
   not have its own local cached copy, in which case we call it
   &quot;unspecified end-to-end revalidation&quot;, or when the client does have a
   local cached copy, in which case we call it &quot;specific end-to-end
   revalidation.&quot;

   The client can specify these three kinds of action using Cache-
   Control request directives:

   End-to-end reload
      The request includes a &quot;no-cache&quot; cache-control directive or, for
      compatibility with HTTP/1.0 clients, &quot;Pragma: no-cache&quot;. Field
      names MUST NOT be included with the no-cache directive in a
      request. The server MUST NOT use a cached copy when responding to
      such a request.

   Specific end-to-end revalidation
      The request includes a &quot;max-age=0&quot; cache-control directive, which
      forces each cache along the path to the origin server to
      revalidate its own entry, if any, with the next cache or server.
      The initial request includes a cache-validating conditional with
      the client's current validator.

   Unspecified end-to-end revalidation
      The request includes &quot;max-age=0&quot; cache-control directive, which
      forces each cache along the path to the origin server to
      revalidate its own entry, if any, with the next cache or server.
      The initial request does not include a cache-validating 

      conditional; the first cache along the path (if any) that holds a
      cache entry for this resource includes a cache-validating
      conditional with its current validator.

   max-age
      When an intermediate cache is forced, by means of a max-age=0
      directive, to revalidate its own cache entry, and the client has
      supplied its own validator in the request, the supplied validator
      might differ from the validator currently stored with the cache
      entry. In this case, the cache MAY use either validator in making
      its own request without affecting semantic transparency.

      However, the choice of validator might affect performance. The
      best approach is for the intermediate cache to use its own
      validator when making its request. If the server replies with 304
      (Not Modified), then the cache can return its now validated copy
      to the client with a 200 (OK) response. If the server replies with
      a new entity and cache validator, however, the intermediate cache
      can compare the returned validator with the one provided in the
      client's request, using the strong comparison function. If the
      client's validator is equal to the origin server's, then the
      intermediate cache simply returns 304 (Not Modified). Otherwise,
      it returns the new entity with a 200 (OK) response.

      If a request includes the no-cache directive, it SHOULD NOT
      include min-fresh, max-stale, or max-age.

   only-if-cached
      In some cases, such as times of extremely poor network
      connectivity, a client may want a cache to return only those
      responses that it currently has stored, and not to reload or
      revalidate with the origin server. To do this, the client may
      include the only-if-cached directive in a request. If it receives
      this directive, a cache SHOULD either respond using a cached entry
      that is consistent with the other constraints of the request, or
      respond with a 504 (Gateway Timeout) status. However, if a group
      of caches is being operated as a unified system with good internal
      connectivity, such a request MAY be forwarded within that group of
      caches.

   must-revalidate
      Because a cache MAY be configured to ignore a server's specified
      expiration time, and because a client request MAY include a max-
      stale directive (which has a similar effect), the protocol also
      includes a mechanism for the origin server to require revalidation
      of a cache entry on any subsequent use. When the must-revalidate
      directive is present in a response received by a cache, that cache
      MUST NOT use the entry after it becomes stale to respond to a 

      subsequent request without first revalidating it with the origin
      server. (I.e., the cache MUST do an end-to-end revalidation every
      time, if, based solely on the origin server's Expires or max-age
      value, the cached response is stale.)

      The must-revalidate directive is necessary to support reliable
      operation for certain protocol features. In all circumstances an
      HTTP/1.1 cache MUST obey the must-revalidate directive; in
      particular, if the cache cannot reach the origin server for any
      reason, it MUST generate a 504 (Gateway Timeout) response.

      Servers SHOULD send the must-revalidate directive if and only if
      failure to revalidate a request on the entity could result in
      incorrect operation, such as a silently unexecuted financial
      transaction. Recipients MUST NOT take any automated action that
      violates this directive, and MUST NOT automatically provide an
      unvalidated copy of the entity if revalidation fails.

      Although this is not recommended, user agents operating under
      severe connectivity constraints MAY violate this directive but, if
      so, MUST explicitly warn the user that an unvalidated response has
      been provided. The warning MUST be provided on each unvalidated
      access, and SHOULD require explicit user confirmation.

   proxy-revalidate
      The proxy-revalidate directive has the same meaning as the must-
      revalidate directive, except that it does not apply to non-shared
      user agent caches. It can be used on a response to an
      authenticated request to permit the user's cache to store and
      later return the response without needing to revalidate it (since
      it has already been authenticated once by that user), while still
      requiring proxies that service many users to revalidate each time
      (in order to make sure that each user has been authenticated).
      Note that such authenticated responses also need the public cache
      control directive in order to allow them to be cached at all.</source>
          <target state="translated">有时,用户代理可能希望或需要坚持要求缓存与源服务器一起重新验证它的缓存条目(而不仅仅是与沿路径到源服务器的下一个缓存),或者从源服务器重新加载它的缓存条目。如果缓存或源服务器高估了缓存响应的到期时间,那么端到端重新验证可能是必要的。如果缓存条目因某种原因损坏,可能需要端到端重新加载。当客户端没有自己的本地缓存副本时,可以请求端到端重新验证,在这种情况下,我们称之为 &quot;未指定的端到端重新验证&quot;;当客户端有本地缓存副本时,我们称之为 &quot;特定的端到端重新验证&quot;。客户端可以使用Cache-控制请求指令指定这三种操作。端到端重载 请求中包含一个 &quot;no-cache &quot;缓存控制指令,或者为了与HTTP/1.0客户端兼容,可以使用 &quot;Pragma:no-cache&quot;。在请求中,字段名不得包含在no-cache指令中。当响应这样的请求时,服务器必须不使用缓存副本。特定的端到端重新验证 请求中包含一个 &quot;max-age=0 &quot;的缓存控制指令,该指令强制通往源服务器的路径上的每一个缓存对自己的条目进行重新验证,如果有的话,则与下一个缓存或服务器一起进行。初始请求中包含一个带有客户端当前验证器的缓存验证条件。未指定端到端重新验证 该请求包含 &quot;max-age=0 &quot;缓存控制指令,该指令强制沿路径到源服务器的每个缓存对自己的条目(如果有的话)与下一个缓存或服务器进行重新验证。初始请求不包含缓存验证条件;沿路径的第一个缓存(如果有的话),如果拥有这个资源的缓存条目,则包含一个当前验证器的缓存验证条件。 max-age 当一个中间缓存通过max-age=0指令被强制重新验证它自己的缓存条目,并且客户端在请求中提供了它自己的验证器时,所提供的验证器可能与缓存条目当前存储的验证器不同。在这种情况下,缓存可以在不影响语义透明度的情况下,使用其中一个验证器来进行自己的请求。然而,验证器的选择可能会影响性能。最好的方法是中间缓存在进行请求时使用自己的验证器。如果服务器用304(Not Modified)来回复,那么缓存就可以用200(OK)来回复它现在已经验证的副本给客户端。然而,如果服务器用新的实体和缓存验证器来回复,中间缓存可以使用强比较功能,将返回的验证器与客户端请求中提供的验证器进行比较。如果客户端的验证器与源服务器的验证器相同,那么中间缓存就会简单地返回304(未修改)。否则,它将返回新的实体,并给出200(OK)的响应。如果请求中包含no-cache指令,那么它不应该包含min-fresh、max-stale或max-age。 only-if-cached 在某些情况下,例如网络连接极差的时候,客户端可能希望缓存只返回它当前存储的响应,而不是重新加载或重新验证源服务器。要做到这一点,客户端可能会在请求中包含only-if-cached指令。如果它收到这个指令,缓存应该使用与请求的其他约束一致的缓存条目进行响应,或者用504(网关超时)状态进行响应。然而,如果一组缓存是作为一个统一的系统来操作的,具有良好的内部连接性,那么这样的请求可以在这组缓存中转发。 must-revalidate 因为缓存可以被配置为忽略服务器指定的过期时间,并且因为客户端请求可以包含一个max-stale指令(具有类似的效果),协议还包括一个机制,让源服务器要求在任何后续使用中重新验证缓存条目。当缓存接收到的响应中出现了must-revalidate指令时,缓存在没有与源服务器进行重新验证之前,必须不使用该条目在其变旧后响应后续请求。(也就是说,如果仅仅根据源服务器的Expires或max-age值,缓存的响应是陈旧的,那么缓存必须每次都进行端到端重新验证。)must-revalidate指令对于支持某些协议特性的可靠操作是必要的。在任何情况下,HTTP/1.1缓存都必须服从must-revalidate指令;特别是,如果缓存因为任何原因不能到达源服务器,它必须生成504(网关超时)响应。如果且仅当未能重新验证实体上的请求可能会导致不正确的操作,例如一个沉默的未执行的金融交易时,服务器才应该发送must-revalidate指令。收件人必须不采取任何自动操作。</target>
        </trans-unit>
        <trans-unit id="f28c6b808e20b5e65f433eb5b11613875d49c1a2" translate="yes" xml:space="preserve">
          <source>Sometimes the requested resource can't be accessed from its canonical location, but it can be accessed from another place. In this case, a temporary redirect can be used.</source>
          <target state="translated">有时,所请求的资源无法从其规范位置访问,但可以从其他地方访问。在这种情况下,可以使用临时重定向。</target>
        </trans-unit>
        <trans-unit id="f0f13543920ce2519c90532c2d9391d9d564cd65" translate="yes" xml:space="preserve">
          <source>Sometimes the requested resource cannot be accessed from its canonical location, but it can be accessed from another place. In this case, a temporary redirect can be used. Search engine robots don't memorize the new, temporary link. Temporary redirections are also used when creating, updating and deleting resources to present temporary progress pages.</source>
          <target state="translated">有时,所请求的资源无法从其规范位置访问,但可以从其他地方访问。在这种情况下,可以使用临时重定向。搜索引擎机器人不会记住新的临时链接。在创建、更新和删除资源时,也可以使用临时重定向来呈现临时进度页面。</target>
        </trans-unit>
        <trans-unit id="d332abe855c0a9991ccf162c5e9b1e9be151b36a" translate="yes" xml:space="preserve">
          <source>Sometimes, the server won't detect it: a redirection loop can spread over several servers which each don't have the full picture. In this case, browsers will detect it and display an error message. Firefox displays:</source>
          <target state="translated">有时,服务器不会检测到它:重定向循环可能会蔓延到几个服务器上,而每个服务器都没有完整的情况。在这种情况下,浏览器会检测到它并显示一个错误信息。火狐浏览器会显示。</target>
        </trans-unit>
        <trans-unit id="7f8875e5296a70a5c55485d7837e9b58660f6869" translate="yes" xml:space="preserve">
          <source>Sometimes, the server won't detect it: a redirection loop can spread over several servers which each don't have the full picture. In this case, browsers will detect it and post an error message. Firefox will display:</source>
          <target state="translated">有时,服务器不会检测到它:重定向循环可能会蔓延到几个服务器上,而每个服务器都没有完整的情况。在这种情况下,浏览器会检测到它并发布一个错误信息。Firefox会显示。</target>
        </trans-unit>
        <trans-unit id="d82ff801ae9d70ca71f25b3a35123f191863d17a" translate="yes" xml:space="preserve">
          <source>Sometimes, this code indicates that the request can not be processed until the client makes a payment. Originally it was created to enable digital cash or (micro) payment systems and would indicate that the requested content is not available until the client makes a payment. However, no standard use convention exists and different entities use it in different contexts.</source>
          <target state="translated">有时,该代码表示在客户付款前不能处理该请求。最初,它是为了启用数字现金或(微)支付系统而创建的,并表示在客户付款之前无法获得所请求的内容。然而,没有标准的使用惯例,不同的实体在不同的情况下使用它。</target>
        </trans-unit>
        <trans-unit id="461f6249960b9f5e0adb518e83fe6728e5a1aa14" translate="yes" xml:space="preserve">
          <source>Source Map Revision 3 Proposal</source>
          <target state="translated">源地图修订3提案</target>
        </trans-unit>
        <trans-unit id="48a37d9cb6f83141d7762830d6d9b21396138f77" translate="yes" xml:space="preserve">
          <source>Source code of the resource</source>
          <target state="translated">资源的源代码</target>
        </trans-unit>
        <trans-unit id="eddadabaed64a1c9704679bf2c71541b37a9a200" translate="yes" xml:space="preserve">
          <source>SourceMap</source>
          <target state="translated">SourceMap</target>
        </trans-unit>
        <trans-unit id="2eb56be3c2d93cdab0c52e677e3167dfddb30ac5" translate="yes" xml:space="preserve">
          <source>Sources</source>
          <target state="translated">Sources</target>
        </trans-unit>
        <trans-unit id="7c23b0d99698b57c5cb21fafcb8a8daf127386c6" translate="yes" xml:space="preserve">
          <source>Speaker</source>
          <target state="translated">Speaker</target>
        </trans-unit>
        <trans-unit id="65fa5e6b8d558cde85a3a07a4e444c679377961e" translate="yes" xml:space="preserve">
          <source>Special redirections</source>
          <target state="translated">特别重定向</target>
        </trans-unit>
        <trans-unit id="1432da84229d762b613e72e68e00057a594449c8" translate="yes" xml:space="preserve">
          <source>Specific &lt;a href=&quot;headers&quot;&gt;HTTP headers&lt;/a&gt; by the client (&lt;em&gt;server-driven negotiation&lt;/em&gt; or &lt;em&gt;proactive negotiation&lt;/em&gt;), which is the standard way of negotiating a specific kind of resource.</source>
          <target state="translated">客户端的特定&lt;a href=&quot;headers&quot;&gt;HTTP标头&lt;/a&gt;（&lt;em&gt;服务器驱动协商&lt;/em&gt;或&lt;em&gt;主动协商&lt;/em&gt;），这是协商特定类型资源的标准方法。</target>
        </trans-unit>
        <trans-unit id="1ccf5d25dfedda0749e3abb6685b56a5fed8013a" translate="yes" xml:space="preserve">
          <source>Specification</source>
          <target state="translated">Specification</target>
        </trans-unit>
        <trans-unit id="0c709f9886c34419d95252da6707fd3dc704a220" translate="yes" xml:space="preserve">
          <source>Specifications</source>
          <target state="translated">Specifications</target>
        </trans-unit>
        <trans-unit id="30d32085a077fd1f486b08c98f4d346c5a6b17fc" translate="yes" xml:space="preserve">
          <source>Specifications and RFCs:</source>
          <target state="translated">规格和RFCs。</target>
        </trans-unit>
        <trans-unit id="07b2551feb0b78f2ae3f0674493bd2ba4c495576" translate="yes" xml:space="preserve">
          <source>Specifies GET, HEAD, POST, PUT, DELETE, CONNECT, OPTIONS, TRACE.</source>
          <target state="translated">指定GET、HEAD、POST、PUT、DELETE、CONNECT、OPTIONS、TRACE。</target>
        </trans-unit>
        <trans-unit id="c58c8c11265fc2163fd1c23b0043a730d6d564bd" translate="yes" xml:space="preserve">
          <source>Specifies PATCH.</source>
          <target state="translated">指定PATCH。</target>
        </trans-unit>
        <trans-unit id="99d3f27b2e59be204c52c5c9fc1e3fd32e5425f2" translate="yes" xml:space="preserve">
          <source>Specifies a URI that may see the timing resources. You can specify multiple origins, separated by commas.</source>
          <target state="translated">指定一个可能看到定时资源的URI。您可以指定多个起源,用逗号隔开。</target>
        </trans-unit>
        <trans-unit id="a3dc214da21e1ecdb977da6e15c1694d398e424b" translate="yes" xml:space="preserve">
          <source>Specifies an origin. Only a single origin can be specified.</source>
          <target state="translated">指定一个原点。只能指定一个原点。</target>
        </trans-unit>
        <trans-unit id="0e8dd4aed544a9115516fcba2b2e3d1772b43815" translate="yes" xml:space="preserve">
          <source>Specifies an origin. Only a single origin can be specified. If the server supports clients from multiple origins, it must return the origin for the specific client making the request.</source>
          <target state="translated">指定一个原点。只能指定一个原点。如果服务器支持来自多个原点的客户端,则必须返回发出请求的特定客户端的原点。</target>
        </trans-unit>
        <trans-unit id="08522ebb29d8c09aa8e3393f359476bbe00317a0" translate="yes" xml:space="preserve">
          <source>Specifies directives for caching mechanisms in both requests and responses.</source>
          <target state="translated">指定请求和响应中缓存机制的指令。</target>
        </trans-unit>
        <trans-unit id="149c7938c7e3b3f09b90de06c72ca9aaa91e52c2" translate="yes" xml:space="preserve">
          <source>Specifies if a cross-domain policy file (&lt;code&gt;crossdomain.xml&lt;/code&gt;) is allowed. The file may define a policy to grant clients, such as Adobe's Flash Player (now obsolete), Adobe Acrobat, Microsoft Silverlight (now obsolete), or Apache Flex, permission to handle data across domains that would otherwise be restricted due to the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy&quot;&gt;Same-Origin Policy&lt;/a&gt;. See the &lt;a href=&quot;https://www.adobe.com/devnet/articles/crossdomain_policy_file_spec.html&quot;&gt;Cross-domain Policy File Specification&lt;/a&gt; for more information.</source>
          <target state="translated">指定是否允许跨域策略文件（ &lt;code&gt;crossdomain.xml&lt;/code&gt; ）。该文件可以定义策略授予客户端，如Adobe的Flash播放器（现在已废弃），使用Adobe Acrobat，微软的Silverlight（现已废弃），或Apache Flex的，允许跨域处理数据，否则将因受限&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy&quot;&gt;Same-来源政策&lt;/a&gt;。有关更多信息，请参见&lt;a href=&quot;https://www.adobe.com/devnet/articles/crossdomain_policy_file_spec.html&quot;&gt;跨域策略文件规范&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2ac472e4fe7931170e92aa9f011df74fb8e68f3a" translate="yes" xml:space="preserve">
          <source>Specifies if a cross-domain policy-file (XML) is allowed. The file may define a policy to grant web clients, such as Adobe Flash Player or Adobe Acrobat (e.g. PDF), permission to handle data across domains.</source>
          <target state="translated">指定是否允许跨域策略文件(XML)。该文件可以定义一个策略,以授予Web客户端(如Adobe Flash Player或Adobe Acrobat(如PDF))跨域处理数据的权限。</target>
        </trans-unit>
        <trans-unit id="b9cbaf8eb79c9b8c4855be6b0eca34e758b86401" translate="yes" xml:space="preserve">
          <source>Specifies one or more protocol-level WebSocket extensions to ask the server to use. Using more than one &lt;code&gt;Sec-WebSocket-Extension&lt;/code&gt; header in a request is permitted; the result is the same as if you included all of the listed extensions in one such header.</source>
          <target state="translated">指定一个或多个协议级WebSocket扩展以要求服务器使用。允许在一个请求中使用多个 &lt;code&gt;Sec-WebSocket-Extension&lt;/code&gt; 标头；结果与将所有列出的扩展名包含在一个这样的标头中相同。</target>
        </trans-unit>
        <trans-unit id="e766075910421b2be9ca8f32bfa752ecb587b39f" translate="yes" xml:space="preserve">
          <source>Specifies origins that are allowed to see values of attributes retrieved via features of the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Resource_Timing_API&quot;&gt;Resource Timing API&lt;/a&gt;, which would otherwise be reported as zero due to cross-origin restrictions.</source>
          <target state="translated">指定允许查看通过&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Resource_Timing_API&quot;&gt;Resource Timing API&lt;/a&gt;功能检索的属性值的起源，否则，由于跨域限制，该属性将报告为零。</target>
        </trans-unit>
        <trans-unit id="c2ecb07bbcb3e1be14696f3f86b19336ccf2cfdc" translate="yes" xml:space="preserve">
          <source>Specifies the URI to which the user agent should report Expect-CT failures.</source>
          <target state="translated">指定用户代理应报告Expect-CT失败的URI。</target>
        </trans-unit>
        <trans-unit id="df8493e883fbdc515ef9ca1b5b0866d3e58f3660" translate="yes" xml:space="preserve">
          <source>Specifies the WebSocket protocol version the client wishes to use, so the server can confirm whether or not that version is supported on its end.</source>
          <target state="translated">指定客户端希望使用的 WebSocket 协议版本,以便服务器可以确认其终端是否支持该版本。</target>
        </trans-unit>
        <trans-unit id="6b4be09a1adcb38cab1a0e2686022154d066d8ba" translate="yes" xml:space="preserve">
          <source>Specifies the domain name of the server (for virtual hosting), and (optionally) the TCP port number on which the server is listening.</source>
          <target state="translated">指定服务器的域名(用于虚拟主机),以及(可选)服务器监听的TCP端口号。</target>
        </trans-unit>
        <trans-unit id="efd15c591f12965b47534e1779aff0b7120829dc" translate="yes" xml:space="preserve">
          <source>Specifies the form of encoding used to safely transfer the entity to the user.</source>
          <target state="translated">指定用于安全传输实体给用户的编码形式。</target>
        </trans-unit>
        <trans-unit id="413e001d0b162dbca41b0e7d35c867d5721df5a5" translate="yes" xml:space="preserve">
          <source>Specifies the lifetime of the policy, in seconds (in a similar way to e.g. HSTS policies are time-restricted). The referenced reporting group should have a lifetime at least as long as the NEL policy.</source>
          <target state="translated">指定策略的寿命,以秒为单位(类似于HSTS策略的时间限制)。引用的报告组的寿命至少应与NEL策略一样长。</target>
        </trans-unit>
        <trans-unit id="6d52f387eaf11730a59df918d4e3a112a2d99212" translate="yes" xml:space="preserve">
          <source>Specifies the maximum amount of time a resource will be considered fresh. Contrary to &lt;code&gt;Expires&lt;/code&gt;, this directive is relative to the time of the request.</source>
          <target state="translated">指定将资源视为新鲜的最长时间。与 &lt;code&gt;Expires&lt;/code&gt; 相反，此指令是相对于请求时间的。</target>
        </trans-unit>
        <trans-unit id="6fef4478d76a150d6928212783b2ee9858bcd272" translate="yes" xml:space="preserve">
          <source>Specifies the method or methods allowed when accessing the resource in response to a preflight request.</source>
          <target state="translated">指定响应飞行前请求访问资源时允许使用的一种或多种方法。</target>
        </trans-unit>
        <trans-unit id="495731834481a81b8123951704e2abcb07625db8" translate="yes" xml:space="preserve">
          <source>Specifies the methods allowed when accessing the resource in response to a preflight request.</source>
          <target state="translated">指定在响应飞行前请求访问资源时允许的方法。</target>
        </trans-unit>
        <trans-unit id="fa52c5dd51b37dc7727111c50a8217213608ca08" translate="yes" xml:space="preserve">
          <source>Specifies the number of seconds after reception of the &lt;code&gt;Expect-CT&lt;/code&gt; header field during which the user agent should regard the host from whom the message was received as a known Expect-CT host.</source>
          <target state="translated">指定接收到 &lt;code&gt;Expect-CT&lt;/code&gt; 标头字段后的秒数，在此秒内，用户代理应将接收消息的主机视为已知的Expect-CT主机。</target>
        </trans-unit>
        <trans-unit id="7f43b9fd51101abb87a0368fc81d197d96a63735" translate="yes" xml:space="preserve">
          <source>Specifies the origin &quot;null&quot;.</source>
          <target state="translated">指定原点 &quot;null&quot;。</target>
        </trans-unit>
        <trans-unit id="1ea81d80712300e661852f0c6af12a440f390050" translate="yes" xml:space="preserve">
          <source>Specifies the the form of encoding used to safely transfer the entity to the user.</source>
          <target state="translated">指定用于安全传输实体给用户的编码形式。</target>
        </trans-unit>
        <trans-unit id="835c2397154f468b4c8ef93ba4c3e1aa7f2607eb" translate="yes" xml:space="preserve">
          <source>Specifies the transfer encodings the user agent is willing to accept.</source>
          <target state="translated">指定用户代理愿意接受的传输编码。</target>
        </trans-unit>
        <trans-unit id="f30f059c03d4c3da1b77bd03fc6d7ad013fb12f4" translate="yes" xml:space="preserve">
          <source>Specifies those hosts to which the cookie will be sent. If not specified, defaults to the host portion of the current document location (but not including subdomains). Contrary to earlier specifications, leading dots in domain names are ignored. If a domain is specified, subdomains are always included.</source>
          <target state="translated">指定要发送cookie的主机。如果没有指定,默认为当前文档位置的主机部分(但不包括子域)。与之前的规范相反,域名中的前导点会被忽略。如果指定了域名,则子域总是包括在内。</target>
        </trans-unit>
        <trans-unit id="24167ab34816aa2157df161d6a2bd98aa1704455" translate="yes" xml:space="preserve">
          <source>Specifies valid parents that may embed a page using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt;&lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt;&lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">指定可以使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt; &lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt; &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt; &lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt; &lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt; &lt;/a&gt;嵌入页面的有效父级。</target>
        </trans-unit>
        <trans-unit id="3fa0df1c3795d4cdda9e9d0ae70ecf55400bafbc" translate="yes" xml:space="preserve">
          <source>Specifies valid sources for &lt;a href=&quot;https://developer.mozilla.org/docs/Web/API/WebRTC_API&quot;&gt;WebRTC&lt;/a&gt; connections.</source>
          <target state="translated">指定&lt;a href=&quot;https://developer.mozilla.org/docs/Web/API/WebRTC_API&quot;&gt;WebRTC&lt;/a&gt;连接的有效来源。</target>
        </trans-unit>
        <trans-unit id="2a90c719345e0d3bc78bace4ab1d3f64767f076c" translate="yes" xml:space="preserve">
          <source>Specifies valid sources for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Worker&quot;&gt;&lt;code&gt;Worker&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker&quot;&gt;&lt;code&gt;SharedWorker&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker&quot;&gt;&lt;code&gt;ServiceWorker&lt;/code&gt;&lt;/a&gt; scripts.</source>
          <target state="translated">为&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Worker&quot;&gt; &lt;code&gt;Worker&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker&quot;&gt; &lt;code&gt;SharedWorker&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker&quot;&gt; &lt;code&gt;ServiceWorker&lt;/code&gt; &lt;/a&gt;脚本指定有效的源。</target>
        </trans-unit>
        <trans-unit id="d098bd02b96b2bdcbdaec1bb10a529856955c4ce" translate="yes" xml:space="preserve">
          <source>Specifies valid sources for JavaScript &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt;&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;&lt;/a&gt; elements.</source>
          <target state="translated">指定JavaScript &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt; &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; &lt;/a&gt;元素的有效来源。</target>
        </trans-unit>
        <trans-unit id="3b6311b937bff61b4874ab442d4d9dbb9f3cc22f" translate="yes" xml:space="preserve">
          <source>Specifies valid sources for JavaScript inline event handlers.</source>
          <target state="translated">指定JavaScript内联事件处理程序的有效来源。</target>
        </trans-unit>
        <trans-unit id="cd49e94946949bc3d24a4291eb9f90caffd7e887" translate="yes" xml:space="preserve">
          <source>Specifies valid sources for JavaScript.</source>
          <target state="translated">指定JavaScript的有效来源。</target>
        </trans-unit>
        <trans-unit id="282bf5eae963adccbd6d47d68520fe0a5c79b871" translate="yes" xml:space="preserve">
          <source>Specifies valid sources for fonts loaded using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face&quot;&gt;&lt;code&gt;@font-face&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">指定使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face&quot;&gt; &lt;code&gt;@font-face&lt;/code&gt; &lt;/a&gt;加载的字体的有效来源。</target>
        </trans-unit>
        <trans-unit id="db33d91daba98ebe85d45f79cd3a62539127fa18" translate="yes" xml:space="preserve">
          <source>Specifies valid sources for inline styles applied to individual DOM elements.</source>
          <target state="translated">指定应用于单个DOM元素的内联样式的有效来源。</target>
        </trans-unit>
        <trans-unit id="42f23c7f28c98c835d7c0a52c0e41c358dd15a49" translate="yes" xml:space="preserve">
          <source>Specifies valid sources for loading media using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt;&lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt;&lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/track&quot;&gt;&lt;code&gt;&amp;lt;track&amp;gt;&lt;/code&gt;&lt;/a&gt; elements.</source>
          <target state="translated">使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt; &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt; &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/track&quot;&gt; &lt;code&gt;&amp;lt;track&amp;gt;&lt;/code&gt; &lt;/a&gt;元素指定用于加载媒体的有效源。</target>
        </trans-unit>
        <trans-unit id="9dc2e0e19fce72e5227e4ed05399840422564be0" translate="yes" xml:space="preserve">
          <source>Specifies valid sources for nested browsing contexts loading using elements such as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">指定使用诸如&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt; &lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; 之类的&lt;/a&gt;元素来加载嵌套浏览上下文的有效源。</target>
        </trans-unit>
        <trans-unit id="ae55d19529942a4f7114ca5f6d12086fa3126f81" translate="yes" xml:space="preserve">
          <source>Specifies valid sources for stylesheets &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/style&quot;&gt;&lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt;&lt;/a&gt; elements and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link&quot;&gt;&lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt;&lt;/a&gt; elements with &lt;code&gt;rel=&quot;stylesheet&quot;&lt;/code&gt;.</source>
          <target state="translated">为样式表&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/style&quot;&gt; &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; &lt;/a&gt;元素和带有 &lt;code&gt;rel=&quot;stylesheet&quot;&lt;/code&gt; &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link&quot;&gt; &lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt; &lt;/a&gt;元素指定有效的源。</target>
        </trans-unit>
        <trans-unit id="a04b49e22cf0a5230eea588841a8a2b455c0bc3e" translate="yes" xml:space="preserve">
          <source>Specifies valid sources for stylesheets.</source>
          <target state="translated">指定样式表的有效来源。</target>
        </trans-unit>
        <trans-unit id="c02deee0c3b25ce48a3b98b60fb3aad61652b709" translate="yes" xml:space="preserve">
          <source>Specifies valid sources for the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt;&lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt;&lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt;&lt;/a&gt; elements.</source>
          <target state="translated">指定&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt; &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt; &lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt; &lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt; &lt;/a&gt;元素的有效源。</target>
        </trans-unit>
        <trans-unit id="fb673b2f31b191ea53966ff7ae48df6affc89e62" translate="yes" xml:space="preserve">
          <source>Specifies valid sources of application manifest files.</source>
          <target state="translated">指定应用程序清单文件的有效来源。</target>
        </trans-unit>
        <trans-unit id="2eb2af79b8a1a437680d977178946925ebbf2f7f" translate="yes" xml:space="preserve">
          <source>Specifies valid sources of images and favicons.</source>
          <target state="translated">指定图像和图标的有效来源。</target>
        </trans-unit>
        <trans-unit id="70ea0caeb914719c42a473dfe61a551bfbb951e5" translate="yes" xml:space="preserve">
          <source>Specifies valid sources to be prefetched or prerendered.</source>
          <target state="translated">指定要预取或预投的有效来源。</target>
        </trans-unit>
        <trans-unit id="951baad47e3b7bd99fb8056c2485c87379c7b510" translate="yes" xml:space="preserve">
          <source>Specifying &lt;code&gt;no-cache&lt;/code&gt; or &lt;code&gt;max-age=0&lt;/code&gt; indicates that clients can cache a resource and must revalidate each time before using it. This means HTTP request occurs each time, but it can skip downloading HTTP body if the content is valid.</source>
          <target state="translated">指定 &lt;code&gt;no-cache&lt;/code&gt; 或 &lt;code&gt;max-age=0&lt;/code&gt; 表示客户端可以缓存资源，并且每次使用前都必须重新验证。这意味着每次都会发生HTTP请求，但是如果内容有效，它可以跳过下载HTTP正文。</target>
        </trans-unit>
        <trans-unit id="9e61777977f07fdafd61735735d76ae50997e152" translate="yes" xml:space="preserve">
          <source>Specifying a fallback policy</source>
          <target state="translated">指定后备策略</target>
        </trans-unit>
        <trans-unit id="3835c694b3a6ee97cfe71fb0cd1c9d794f4e48c3" translate="yes" xml:space="preserve">
          <source>Specifying legacy document modes*</source>
          <target state="translated">指定遗留文件模式*</target>
        </trans-unit>
        <trans-unit id="85f30ba6e5f19f51628bda67d9500dab94232f9a" translate="yes" xml:space="preserve">
          <source>Specifying multiple links</source>
          <target state="translated">指定多个链接</target>
        </trans-unit>
        <trans-unit id="f65d134dfe7e03e4b9a14898c4ef7cc4877bc321" translate="yes" xml:space="preserve">
          <source>Specifying multiple values is only supported in the &lt;code&gt;Referrer-Policy&lt;/code&gt; HTTP header, and not in the &lt;code&gt;referrerpolicy&lt;/code&gt; attribute.</source>
          <target state="translated">指定多个值仅支持在 &lt;code&gt;Referrer-Policy&lt;/code&gt; HTTP头，而不是在 &lt;code&gt;referrerpolicy&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="b2bf4478d33594d8d9be5cf924dffa2d49ead910" translate="yes" xml:space="preserve">
          <source>Specifying your policy</source>
          <target state="translated">指定您的政策</target>
        </trans-unit>
        <trans-unit id="f8a58e6474d46ef9548c5cf3e20d0bdc3d838946" translate="yes" xml:space="preserve">
          <source>Standard &lt;code&gt;Cache-Control&lt;/code&gt; directives that can be used by the client in an HTTP request.</source>
          <target state="translated">客户端可以在HTTP请求中使用的标准 &lt;code&gt;Cache-Control&lt;/code&gt; 指令。</target>
        </trans-unit>
        <trans-unit id="fc62e8bea8948c4f2c38c80d531e6ec6bc0f979f" translate="yes" xml:space="preserve">
          <source>Standard &lt;code&gt;Cache-Control&lt;/code&gt; directives that can be used by the server in an HTTP response.</source>
          <target state="translated">服务器可以在HTTP响应中使用的标准 &lt;code&gt;Cache-Control&lt;/code&gt; 指令。</target>
        </trans-unit>
        <trans-unit id="7e4f48b87246ae2a22b36e2b02bbe847fa77f9da" translate="yes" xml:space="preserve">
          <source>Standardized methods are generic; that is, they are potentially
   applicable to any resource, not just one particular media type, kind
   of resource, or application.  As such, it is preferred that new
   methods be registered in a document that isn't specific to a single
   application or data format, since orthogonal technologies deserve
   orthogonal specification.

   Since message parsing (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.3&quot;&gt;Section&amp;nbsp;3.3 of [RFC7230]&lt;/a&gt;) needs to be
   independent of method semantics (aside from responses to HEAD),
   definitions of new methods cannot change the parsing algorithm or
   prohibit the presence of a message body on either the request or the
   response message.  Definitions of new methods can specify that only a
   zero-length message body is allowed by requiring a Content-Length
   header field with a value of &quot;0&quot;.

   A new method definition needs to indicate whether it is safe
   (&lt;a href=&quot;#section-4.2.1&quot;&gt;Section 4.2.1&lt;/a&gt;), idempotent (&lt;a href=&quot;#section-4.2.2&quot;&gt;Section 4.2.2&lt;/a&gt;), cacheable
   (&lt;a href=&quot;#section-4.2.3&quot;&gt;Section 4.2.3&lt;/a&gt;), what semantics are to be associated with the payload
   body if any is present in the request and what refinements the method
   makes to header field or status code semantics.  If the new method is
   cacheable, its definition ought to describe how, and under what
   conditions, a cache can store a response and use it to satisfy a
   subsequent request.  The new method ought to describe whether it can
   be made conditional (&lt;a href=&quot;#section-5.2&quot;&gt;Section 5.2&lt;/a&gt;) and, if so, how a server responds
   when the condition is false.  Likewise, if the new method might have
   some use for partial response semantics ([&lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC7233&lt;/a&gt;]), it ought to
   document this, too.

      Note: Avoid defining a method name that starts with &quot;M-&quot;, since
      that prefix might be misinterpreted as having the semantics
      assigned to it by [&lt;a href=&quot;https://tools.ietf.org/html/rfc2774&quot;&gt;RFC2774&lt;/a&gt;].</source>
          <target state="translated">标准化方法是通用的。也就是说，它们可能适用于任何资源，而不仅仅是一种特定的媒体类型，资源类型或应用程序。因此，最好将新方法注册到非特定于单个应用程序或数据格式的文档中，因为正交技术应遵循正交规范。自消息解析以来（&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.3&quot;&gt;[RFC7230]的3.3节&lt;/a&gt;）需要与方法语义无关（除了对HEAD的响应之外），新方法的定义不能更改解析算法或禁止在请求或响应消息上存在消息正文。新方法的定义可以通过要求Content-Length标头字段的值为&amp;ldquo; 0&amp;rdquo;来指定仅允许零长度的消息正文。一个新的方法定义需要指出它是否安全（&lt;a href=&quot;#section-4.2.1&quot;&gt;第4.2.1节&lt;/a&gt;），幂等（&lt;a href=&quot;#section-4.2.2&quot;&gt;第4.2.2节&lt;/a&gt;），可缓存（&lt;a href=&quot;#section-4.2.3&quot;&gt;第4.2.3 &lt;/a&gt;节）），如果请求中存在有效内容主体，则将与哪些语义相关联，以及该方法对标头字段或状态码语义进行哪些改进。如果新方法是可缓存的，则其定义应描述缓存如何以及在何种条件下存储响应并使用它来满足后续请求。新方法应该描述是否可以使其成为有条件的（&lt;a href=&quot;#section-5.2&quot;&gt;第5.2节&lt;/a&gt;），如果可以，则说明条件为假时服务器如何响应。同样，如果新方法可能对部分响应语义有一定作用（[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC7233&lt;/a&gt;]），它也应该记录下来。注意：避免定义以&amp;ldquo; M-&amp;rdquo;开头的方法名称，因为该前缀可能被误解为[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2774&quot;&gt;RFC2774&lt;/a&gt; ] 为其分配的语义。</target>
        </trans-unit>
        <trans-unit id="ec725f8ba620a293e9d02360be092dd295c3b54d" translate="yes" xml:space="preserve">
          <source>Start line</source>
          <target state="translated">起跑线</target>
        </trans-unit>
        <trans-unit id="e030402b999a37d4c6eb9f51e15b86c192ade5a6" translate="yes" xml:space="preserve">
          <source>Starting in Chrome 61, this applies to all of a frame's ancestors.</source>
          <target state="translated">从 Chrome 61 中开始,这适用于框架的所有祖先。</target>
        </trans-unit>
        <trans-unit id="47374f68a6da45b7e6165e2b0f9740a82e30b4ff" translate="yes" xml:space="preserve">
          <source>Starting in Firefox 59, this applies to all of a frame's ancestors.</source>
          <target state="translated">从Firefox 59开始,这适用于一个框架的所有祖先。</target>
        </trans-unit>
        <trans-unit id="6cbdee7a264558eb88d25ed8d267e476fca05cb7" translate="yes" xml:space="preserve">
          <source>Starting in Opera 48, this applies to all of a frame's ancestors.</source>
          <target state="translated">从Opera 48开始,这适用于一个框架的所有祖先。</target>
        </trans-unit>
        <trans-unit id="b6deb6ef9aab80647d8c2b91f6b9f8ab6cffc3c1" translate="yes" xml:space="preserve">
          <source>Starting in Version 6, users can opt into using a GeckoView-based Focus for Android with a hidden preference: it uses a GeckoView UA string to advertise Gecko compatibility.</source>
          <target state="translated">从第6版开始,用户可以选择使用基于GeckoView的Focus for Android,并有一个隐藏的偏好:它使用GeckoView UA字符串来宣传Gecko兼容性。</target>
        </trans-unit>
        <trans-unit id="2767241100a2bb66d29b7ccd151257fc78abe38a" translate="yes" xml:space="preserve">
          <source>Starting with Chrome 52 and Firefox 52, insecure sites (&lt;code&gt;http:&lt;/code&gt;) can't set cookies with the &quot;secure&quot; directive anymore.</source>
          <target state="translated">从Chrome 52和Firefox 52开始，不安全的网站（ &lt;code&gt;http:&lt;/code&gt; ：）不再可以使用&amp;ldquo;安全&amp;rdquo;指令设置cookie。</target>
        </trans-unit>
        <trans-unit id="2777fe7b39631e05febcca00592a28a86bb5182f" translate="yes" xml:space="preserve">
          <source>Starting with Chrome 52 and Firefox 52, insecure sites (&lt;code&gt;http:&lt;/code&gt;) can't set cookies with the &lt;code&gt;Secure&lt;/code&gt; attribute anymore.</source>
          <target state="translated">从Chrome 52和Firefox 52开始，不安全的网站（ &lt;code&gt;http:&lt;/code&gt; ：）不再可以使用 &lt;code&gt;Secure&lt;/code&gt; 属性设置Cookie 。</target>
        </trans-unit>
        <trans-unit id="bb7d21aec22143da2cc4da25c435e7bb29874f8d" translate="yes" xml:space="preserve">
          <source>Starting with Firefox 72, the opting out of MIME sniffing is also applied to top-level documents if a &lt;a href=&quot;content-type&quot;&gt;&lt;code&gt;Content-type&lt;/code&gt;&lt;/a&gt; is provided. This can cause HTML web pages to be downloaded instead of being rendered when they are served with a MIME type other than &lt;code&gt;text/html&lt;/code&gt;. Make sure to set both headers correctly.</source>
          <target state="translated">从Firefox 72开始，如果提供了&lt;a href=&quot;content-type&quot;&gt; &lt;code&gt;Content-type&lt;/code&gt; &lt;/a&gt;，则退出MIME嗅探也将应用于顶级文档。当HTML网页使用不是 &lt;code&gt;text/html&lt;/code&gt; 的MIME类型提供服务时，这可能会导致HTML网页被下载而不是呈现。确保正确设置两个标题。</target>
        </trans-unit>
        <trans-unit id="bae7d5be70820ed56467bd9a63744e23b47bd711" translate="yes" xml:space="preserve">
          <source>Status</source>
          <target state="translated">Status</target>
        </trans-unit>
        <trans-unit id="f7b7abf0e2e9d417ae8391f4a4fe7d726ce87d19" translate="yes" xml:space="preserve">
          <source>Status Code Definitions (RFC 2616)</source>
          <target state="translated">状态码定义(RFC 2616)</target>
        </trans-unit>
        <trans-unit id="79f8bb09cc70b71ab1e11fda8d1499287de0d9e4" translate="yes" xml:space="preserve">
          <source>Status line</source>
          <target state="translated">状态线</target>
        </trans-unit>
        <trans-unit id="8f42525bc1bf257516b4843747d743c365504980" translate="yes" xml:space="preserve">
          <source>Status of This Memo

   This document specifies an Internet standards track protocol for the
   Internet community, and requests discussion and suggestions for
   improvements.  Please refer to the current edition of the &quot;Internet
   Official Protocol Standards&quot; (STD 1) for the standardization state
   and status of this protocol.  Distribution of this memo is unlimited.

Abstract

   The Atom Publishing Protocol (AtomPub) is an application-level
   protocol for publishing and editing Web resources.  The protocol is
   based on HTTP transfer of Atom-formatted representations.  The Atom
   format is documented in the Atom Syndication Format. 

Table of Contents

   &lt;a href=&quot;#section-1&quot;&gt;1&lt;/a&gt;. Introduction 
   &lt;a href=&quot;#section-2&quot;&gt;2&lt;/a&gt;. Notational Conventions 
      &lt;a href=&quot;#section-2.1&quot;&gt;2.1&lt;/a&gt;. XML-Related Conventions 
           &lt;a href=&quot;#section-2.1.1&quot;&gt;2.1.1&lt;/a&gt;. Referring to Information Items 
           &lt;a href=&quot;#section-2.1.2&quot;&gt;2.1.2&lt;/a&gt;. RELAX NG Schema 
           &lt;a href=&quot;#section-2.1.3&quot;&gt;2.1.3&lt;/a&gt;. Use of &quot;xml:base&quot; and &quot;xml:lang&quot; 
   &lt;a href=&quot;#section-3&quot;&gt;3&lt;/a&gt;. Terminology 
   &lt;a href=&quot;#section-4&quot;&gt;4&lt;/a&gt;. Protocol Model 
      &lt;a href=&quot;#section-4.1&quot;&gt;4.1&lt;/a&gt;. Identity and Naming 
      &lt;a href=&quot;#section-4.2&quot;&gt;4.2&lt;/a&gt;. Documents and Resource Classification 
      &lt;a href=&quot;#section-4.3&quot;&gt;4.3&lt;/a&gt;. Control and Publishing 
      &lt;a href=&quot;#section-4.4&quot;&gt;4.4&lt;/a&gt;. Client Implementation Considerations 
   &lt;a href=&quot;#section-5&quot;&gt;5&lt;/a&gt;. Protocol Operations 
      &lt;a href=&quot;#section-5.1&quot;&gt;5.1&lt;/a&gt;. Retrieving a Service Document 
      &lt;a href=&quot;#section-5.2&quot;&gt;5.2&lt;/a&gt;. Listing Collection Members 
      &lt;a href=&quot;#section-5.3&quot;&gt;5.3&lt;/a&gt;. Creating a Resource 
      &lt;a href=&quot;#section-5.4&quot;&gt;5.4&lt;/a&gt;. Editing a Resource 
           &lt;a href=&quot;#section-5.4.1&quot;&gt;5.4.1&lt;/a&gt;. Retrieving a Resource 
           &lt;a href=&quot;#section-5.4.2&quot;&gt;5.4.2&lt;/a&gt;. Editing a Resource 
           &lt;a href=&quot;#section-5.4.3&quot;&gt;5.4.3&lt;/a&gt;. Deleting a Resource 
      &lt;a href=&quot;#section-5.5&quot;&gt;5.5&lt;/a&gt;. Use of HTTP Response Codes 
   &lt;a href=&quot;#section-6&quot;&gt;6&lt;/a&gt;. Protocol Documents 
      &lt;a href=&quot;#section-6.1&quot;&gt;6.1&lt;/a&gt;. Document Types 
      &lt;a href=&quot;#section-6.2&quot;&gt;6.2&lt;/a&gt;. Document Extensibility 
   &lt;a href=&quot;#section-7&quot;&gt;7&lt;/a&gt;. Category Documents 
      &lt;a href=&quot;#section-7.1&quot;&gt;7.1&lt;/a&gt;. Example 
      &lt;a href=&quot;#section-7.2&quot;&gt;7.2&lt;/a&gt;. Element Definitions 
           &lt;a href=&quot;#section-7.2.1&quot;&gt;7.2.1&lt;/a&gt;. The &quot;app:categories&quot; Element 
   &lt;a href=&quot;#section-8&quot;&gt;8&lt;/a&gt;. Service Documents 
      &lt;a href=&quot;#section-8.1&quot;&gt;8.1&lt;/a&gt;. Workspaces 
      &lt;a href=&quot;#section-8.2&quot;&gt;8.2&lt;/a&gt;. Example 
      &lt;a href=&quot;#section-8.3&quot;&gt;8.3&lt;/a&gt;. Element Definitions 
           &lt;a href=&quot;#section-8.3.1&quot;&gt;8.3.1&lt;/a&gt;. The &quot;app:service&quot; Element 
           &lt;a href=&quot;#section-8.3.2&quot;&gt;8.3.2&lt;/a&gt;. The &quot;app:workspace&quot; Element 
           &lt;a href=&quot;#section-8.3.3&quot;&gt;8.3.3&lt;/a&gt;. The &quot;app:collection&quot; Element 
           &lt;a href=&quot;#section-8.3.4&quot;&gt;8.3.4&lt;/a&gt;. The &quot;app:accept&quot; Element 
           &lt;a href=&quot;#section-8.3.5&quot;&gt;8.3.5&lt;/a&gt;. Usage in Atom Feed Documents 
           &lt;a href=&quot;#section-8.3.6&quot;&gt;8.3.6&lt;/a&gt;. The &quot;app:categories&quot; Element 
   &lt;a href=&quot;#section-9&quot;&gt;9&lt;/a&gt;. Creating and Editing Resources 
      &lt;a href=&quot;#section-9.1&quot;&gt;9.1&lt;/a&gt;. Member URIs 
      &lt;a href=&quot;#section-9.2&quot;&gt;9.2&lt;/a&gt;. Creating Resources with POST 
           &lt;a href=&quot;#section-9.2.1&quot;&gt;9.2.1&lt;/a&gt;. Example 
      &lt;a href=&quot;#section-9.3&quot;&gt;9.3&lt;/a&gt;. Editing Resources with PUT 
      &lt;a href=&quot;#section-9.4&quot;&gt;9.4&lt;/a&gt;. Deleting Resources with DELETE 
      &lt;a href=&quot;#section-9.5&quot;&gt;9.5&lt;/a&gt;. Caching and Entity Tags 
           &lt;a href=&quot;#section-9.5.1&quot;&gt;9.5.1&lt;/a&gt;. Example ............................................ 

      &lt;a href=&quot;#section-9.6&quot;&gt;9.6&lt;/a&gt;. Media Resources and Media Link Entries 
           &lt;a href=&quot;#section-9.6.1&quot;&gt;9.6.1&lt;/a&gt;. Examples 
      &lt;a href=&quot;#section-9.7&quot;&gt;9.7&lt;/a&gt;. The Slug Header 
           &lt;a href=&quot;#section-9.7.1&quot;&gt;9.7.1&lt;/a&gt;. Slug Header Syntax 
           &lt;a href=&quot;#section-9.7.2&quot;&gt;9.7.2&lt;/a&gt;. Example 
   &lt;a href=&quot;#section-10&quot;&gt;10&lt;/a&gt;. Listing Collections 
      &lt;a href=&quot;#section-10.1&quot;&gt;10.1&lt;/a&gt;. Collection Partial Lists 
      &lt;a href=&quot;#section-10.2&quot;&gt;10.2&lt;/a&gt;. The &quot;app:edited&quot; Element 
   &lt;a href=&quot;#section-11&quot;&gt;11&lt;/a&gt;. Atom Format Link Relation Extensions 
      &lt;a href=&quot;#section-11.1&quot;&gt;11.1&lt;/a&gt;. The &quot;edit&quot; Link Relation 
      &lt;a href=&quot;#section-11.2&quot;&gt;11.2&lt;/a&gt;. The &quot;edit-media&quot; Link Relation 
   &lt;a href=&quot;#section-12&quot;&gt;12&lt;/a&gt;. The Atom Format Type Parameter 
      &lt;a href=&quot;#section-12.1&quot;&gt;12.1&lt;/a&gt;. The &quot;type&quot; parameter 
           &lt;a href=&quot;#section-12.1.1&quot;&gt;12.1.1&lt;/a&gt;. Conformance 
   &lt;a href=&quot;#section-13&quot;&gt;13&lt;/a&gt;. Atom Publishing Controls 
      &lt;a href=&quot;#section-13.1&quot;&gt;13.1&lt;/a&gt;. The &quot;app:control&quot; Element 
           &lt;a href=&quot;#section-13.1.1&quot;&gt;13.1.1&lt;/a&gt;. The &quot;app:draft&quot; Element 
   &lt;a href=&quot;#section-14&quot;&gt;14&lt;/a&gt;. Securing the Atom Publishing Protocol 
   &lt;a href=&quot;#section-15&quot;&gt;15&lt;/a&gt;. Security Considerations 
      &lt;a href=&quot;#section-15.1&quot;&gt;15.1&lt;/a&gt;. Denial of Service 
      &lt;a href=&quot;#section-15.2&quot;&gt;15.2&lt;/a&gt;. Replay Attacks 
      &lt;a href=&quot;#section-15.3&quot;&gt;15.3&lt;/a&gt;. Spoofing Attacks 
      &lt;a href=&quot;#section-15.4&quot;&gt;15.4&lt;/a&gt;. Linked Resources 
      &lt;a href=&quot;#section-15.5&quot;&gt;15.5&lt;/a&gt;. Digital Signatures and Encryption 
      &lt;a href=&quot;#section-15.6&quot;&gt;15.6&lt;/a&gt;. URIs and IRIs 
      &lt;a href=&quot;#section-15.7&quot;&gt;15.7&lt;/a&gt;. Code Injection and Cross Site Scripting 
   &lt;a href=&quot;#section-16&quot;&gt;16&lt;/a&gt;. IANA Considerations 
      &lt;a href=&quot;#section-16.1&quot;&gt;16.1&lt;/a&gt;. Content-Type Registration for 'application/atomcat+xml' ..39
      &lt;a href=&quot;#section-16.2&quot;&gt;16.2&lt;/a&gt;. Content-Type Registration for 'application/atomsvc+xml' ..40
      &lt;a href=&quot;#section-16.3&quot;&gt;16.3&lt;/a&gt;. Header Field Registration for 'SLUG' 
      &lt;a href=&quot;#section-16.4&quot;&gt;16.4&lt;/a&gt;. The Link Relation Registration &quot;edit&quot; 
      &lt;a href=&quot;#section-16.5&quot;&gt;16.5&lt;/a&gt;. The Link Relation Registration &quot;edit-media&quot; 
      &lt;a href=&quot;#section-16.6&quot;&gt;16.6&lt;/a&gt;. The Atom Format Media Type Parameter 
   &lt;a href=&quot;#section-17&quot;&gt;17&lt;/a&gt;. References 
      &lt;a href=&quot;#section-17.1&quot;&gt;17.1&lt;/a&gt;. Normative References 
      &lt;a href=&quot;#section-17.2&quot;&gt;17.2&lt;/a&gt;. Informative References 
   &lt;a href=&quot;#appendix-A&quot;&gt;Appendix A&lt;/a&gt;. Contributors 
   &lt;a href=&quot;#appendix-B&quot;&gt;Appendix B&lt;/a&gt;. RELAX NG Compact Schema ...............................</source>
          <target state="translated">本备忘录的状态本文档指定了Internet社区的Internet标准跟踪协议，并要求讨论和提出改进建议。请参阅当前版本的&amp;ldquo; Internet官方协议标准&amp;rdquo;（STD 1）了解此协议的标准化状态。该备忘录的分发是无限的。摘要Atom发布协议（AtomPub）是用于发布和编辑Web资源的应用程序级协议。该协议基于Atom格式表示形式的HTTP传输。 Atom格式以Atom联合格式记录。目录 &lt;a href=&quot;#section-1&quot;&gt;1&lt;/a&gt;。介绍 &lt;a href=&quot;#section-2&quot;&gt;2&lt;/a&gt;。符号约定 &lt;a href=&quot;#section-2.1&quot;&gt;2.1&lt;/a&gt;。与XML相关的约定 &lt;a href=&quot;#section-2.1.1&quot;&gt;2.1.1&lt;/a&gt;。参考信息项目 &lt;a href=&quot;#section-2.1.2&quot;&gt;2.1.2&lt;/a&gt;。放松NG模式 &lt;a href=&quot;#section-2.1.3&quot;&gt;2.1.3&lt;/a&gt;。使用&amp;ldquo; xml：base&amp;rdquo;和&amp;ldquo; xml：lang&amp;rdquo; &lt;a href=&quot;#section-3&quot;&gt;3&lt;/a&gt;。术语 &lt;a href=&quot;#section-4&quot;&gt;4&lt;/a&gt;。协议模型 &lt;a href=&quot;#section-4.1&quot;&gt;4.1&lt;/a&gt;。身份和命名 &lt;a href=&quot;#section-4.2&quot;&gt;4.2&lt;/a&gt;。文件和资源分类 &lt;a href=&quot;#section-4.3&quot;&gt;4.3&lt;/a&gt;。控制和发布 &lt;a href=&quot;#section-4.4&quot;&gt;4.4&lt;/a&gt;。客户实施注意事项 &lt;a href=&quot;#section-5&quot;&gt;5&lt;/a&gt;。协议操作 &lt;a href=&quot;#section-5.1&quot;&gt;5.1&lt;/a&gt;。检索服务文件 &lt;a href=&quot;#section-5.2&quot;&gt;5.2&lt;/a&gt;。列表集合成员 &lt;a href=&quot;#section-5.3&quot;&gt;5.3&lt;/a&gt;。创建资源 &lt;a href=&quot;#section-5.4&quot;&gt;5.4&lt;/a&gt;。编辑资源 &lt;a href=&quot;#section-5.4.1&quot;&gt;5.4.1&lt;/a&gt;。检索资源 &lt;a href=&quot;#section-5.4.2&quot;&gt;5.4.2&lt;/a&gt;。编辑资源 &lt;a href=&quot;#section-5.4.3&quot;&gt;5.4.3&lt;/a&gt;。删除资源 &lt;a href=&quot;#section-5.5&quot;&gt;5.5&lt;/a&gt;。 HTTP响应代码的使用 &lt;a href=&quot;#section-6&quot;&gt;6&lt;/a&gt;。议定书文件 &lt;a href=&quot;#section-6.1&quot;&gt;6.1&lt;/a&gt;。文件类型 &lt;a href=&quot;#section-6.2&quot;&gt;6.2&lt;/a&gt;。文件扩展性 &lt;a href=&quot;#section-7&quot;&gt;7&lt;/a&gt;。类别文件 &lt;a href=&quot;#section-7.1&quot;&gt;7.1&lt;/a&gt;。例子 &lt;a href=&quot;#section-7.2&quot;&gt;7.2&lt;/a&gt;。元素定义 &lt;a href=&quot;#section-7.2.1&quot;&gt;7.2.1&lt;/a&gt;。 &amp;ldquo; app：categories&amp;rdquo;元素 &lt;a href=&quot;#section-8&quot;&gt;8&lt;/a&gt;。服务文件 &lt;a href=&quot;#section-8.1&quot;&gt;8.1&lt;/a&gt;。工作区 &lt;a href=&quot;#section-8.2&quot;&gt;8.2&lt;/a&gt;。示例 &lt;a href=&quot;#section-8.3&quot;&gt;8.3&lt;/a&gt;。元素定义 &lt;a href=&quot;#section-8.3.1&quot;&gt;8.3.1&lt;/a&gt;。 &amp;ldquo; app：service&amp;rdquo;元素 &lt;a href=&quot;#section-8.3.2&quot;&gt;8.3.2&lt;/a&gt;。 &amp;ldquo; app：workspace&amp;rdquo;元素 &lt;a href=&quot;#section-8.3.3&quot;&gt;8.3.3&lt;/a&gt;。 &amp;ldquo; app：collection&amp;rdquo;元素 &lt;a href=&quot;#section-8.3.4&quot;&gt;8.3.4&lt;/a&gt;。 &amp;ldquo; app：accept&amp;rdquo;元素 &lt;a href=&quot;#section-8.3.5&quot;&gt;8.3.5&lt;/a&gt;。在Atom Feed文档中使用 &lt;a href=&quot;#section-8.3.6&quot;&gt;8.3.6&lt;/a&gt;。 &amp;ldquo; app：categories&amp;rdquo;元素 &lt;a href=&quot;#section-9&quot;&gt;9&lt;/a&gt;。创建和编辑资源 &lt;a href=&quot;#section-9.1&quot;&gt;9.1&lt;/a&gt;。成员URI &lt;a href=&quot;#section-9.2&quot;&gt;9.2&lt;/a&gt;。使用POST &lt;a href=&quot;#section-9.2.1&quot;&gt;9.2.1&lt;/a&gt;创建资源 。例子 &lt;a href=&quot;#section-9.3&quot;&gt;9.3&lt;/a&gt;。使用PUT &lt;a href=&quot;#section-9.4&quot;&gt;9.4&lt;/a&gt;编辑资源 。 使用DELETE删除资源&lt;a href=&quot;#section-9.5&quot;&gt;9.5&lt;/a&gt;。缓存和实体标签 &lt;a href=&quot;#section-9.5.1&quot;&gt;9.5.1&lt;/a&gt;。例如............................................ &lt;a href=&quot;#section-9.6&quot;&gt;9.6&lt;/a&gt;。媒体资源和媒体链接条目 &lt;a href=&quot;#section-9.6.1&quot;&gt;9.6.1&lt;/a&gt;。例子 &lt;a href=&quot;#section-9.7&quot;&gt;9.7&lt;/a&gt;。子弹头 &lt;a href=&quot;#section-9.7.1&quot;&gt;9.7.1&lt;/a&gt;。 Slug标头语法 &lt;a href=&quot;#section-9.7.2&quot;&gt;9.7.2&lt;/a&gt;。例子 &lt;a href=&quot;#section-10&quot;&gt;10&lt;/a&gt;。列表集合 &lt;a href=&quot;#section-10.1&quot;&gt;10.1&lt;/a&gt;。收集部分清单 &lt;a href=&quot;#section-10.2&quot;&gt;10.2&lt;/a&gt;。 &amp;ldquo; app：edited&amp;rdquo;元素 &lt;a href=&quot;#section-11&quot;&gt;11&lt;/a&gt;。原子格式链接关系扩展 &lt;a href=&quot;#section-11.1&quot;&gt;11.1&lt;/a&gt;。 &amp;ldquo;编辑&amp;rdquo;链接关系 &lt;a href=&quot;#section-11.2&quot;&gt;11.2&lt;/a&gt;。 &amp;ldquo;编辑媒体&amp;rdquo;链接关系 &lt;a href=&quot;#section-12&quot;&gt;12&lt;/a&gt;。 Atom格式类型参数 &lt;a href=&quot;#section-12.1&quot;&gt;12.1&lt;/a&gt;。 &amp;ldquo;类型&amp;rdquo;参数 &lt;a href=&quot;#section-12.1.1&quot;&gt;12.1.1&lt;/a&gt;。符合 &lt;a href=&quot;#section-13&quot;&gt;13&lt;/a&gt;。 Atom发布控件 &lt;a href=&quot;#section-13.1&quot;&gt;13.1&lt;/a&gt;。 &amp;ldquo; app：control&amp;rdquo;元素 &lt;a href=&quot;#section-13.1.1&quot;&gt;13.1.1&lt;/a&gt;。 &amp;ldquo; app：draft&amp;rdquo;元素 &lt;a href=&quot;#section-14&quot;&gt;14&lt;/a&gt;。保护Atom发布协议 &lt;a href=&quot;#section-15&quot;&gt;15&lt;/a&gt;。安全考虑因素 &lt;a href=&quot;#section-15.1&quot;&gt;15.1&lt;/a&gt;。拒绝服务 &lt;a href=&quot;#section-15.2&quot;&gt;15.2&lt;/a&gt;。重播攻击 &lt;a href=&quot;#section-15.3&quot;&gt;15.3&lt;/a&gt;。欺骗攻击 &lt;a href=&quot;#section-15.4&quot;&gt;15.4&lt;/a&gt;。链接资源 &lt;a href=&quot;#section-15.5&quot;&gt;15.5&lt;/a&gt;。数字签名和加密 &lt;a href=&quot;#section-15.6&quot;&gt;15.6&lt;/a&gt;。 URI和IRI &lt;a href=&quot;#section-15.7&quot;&gt;15.7&lt;/a&gt;。代码注入和跨站点脚本编写 &lt;a href=&quot;#section-16&quot;&gt;16&lt;/a&gt;。 IANA考虑因素 &lt;a href=&quot;#section-16.1&quot;&gt;16.1&lt;/a&gt;。 &amp;ldquo; application / atomcat + xml&amp;rdquo;的内容类型注册..39 &lt;a href=&quot;#section-16.2&quot;&gt;16.2&lt;/a&gt;。 &amp;ldquo; application / atomsvc​​ + xml&amp;rdquo;的内容类型注册..40 &lt;a href=&quot;#section-16.3&quot;&gt;16.3&lt;/a&gt;。 &amp;ldquo; SLUG&amp;rdquo;的报头字段注册 &lt;a href=&quot;#section-16.4&quot;&gt;16.4&lt;/a&gt;。链接关系注册&amp;ldquo;编辑&amp;rdquo; &lt;a href=&quot;#section-16.5&quot;&gt;16.5&lt;/a&gt;。链接关系注册&amp;ldquo;编辑媒体&amp;rdquo; &lt;a href=&quot;#section-16.6&quot;&gt;16.6&lt;/a&gt;。 Atom格式媒体类型参数 &lt;a href=&quot;#section-17&quot;&gt;17&lt;/a&gt;。参考文献 &lt;a href=&quot;#section-17.1&quot;&gt;17.1&lt;/a&gt;。规范性引用文件 &lt;a href=&quot;#section-17.2&quot;&gt;17.2&lt;/a&gt;。参考文献 &lt;a href=&quot;#appendix-A&quot;&gt;附录A&lt;/a&gt;。贡献者 &lt;a href=&quot;#appendix-B&quot;&gt;附录B&lt;/a&gt;。 RELAX NG Compact Schema ...............................</target>
        </trans-unit>
        <trans-unit id="bba4ada33d7f6d8a86341c33e255f61ec01eb34d" translate="yes" xml:space="preserve">
          <source>Status of This Memo

   This document specifies an Internet standards track protocol for the
   Internet community, and requests discussion and suggestions for
   improvements.  Please refer to the current edition of the &quot;Internet
   Official Protocol Standards&quot; (STD 1) for the standardization state
   and status of this protocol.  Distribution of this memo is unlimited.

Copyright Notice

   Copyright (C) The IETF Trust (2007).

Abstract

   Web Distributed Authoring and Versioning (WebDAV) consists of a set
   of methods, headers, and content-types ancillary to HTTP/1.1 for the
   management of resource properties, creation and management of
   resource collections, URL namespace manipulation, and resource
   locking (collision avoidance).

   &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518&lt;/a&gt; was published in February 1999, and this specification
   obsoletes &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518&lt;/a&gt; with minor revisions mostly due to
   interoperability experience. 

Table of Contents

   &lt;a href=&quot;#section-1&quot;&gt;1&lt;/a&gt;. Introduction 
   &lt;a href=&quot;#section-2&quot;&gt;2&lt;/a&gt;. Notational Conventions 
   &lt;a href=&quot;#section-3&quot;&gt;3&lt;/a&gt;. Terminology 
   &lt;a href=&quot;#section-4&quot;&gt;4&lt;/a&gt;. Data Model for Resource Properties 
      &lt;a href=&quot;#section-4.1&quot;&gt;4.1&lt;/a&gt;. The Resource Property Model 
      &lt;a href=&quot;#section-4.2&quot;&gt;4.2&lt;/a&gt;. Properties and HTTP Headers 
      &lt;a href=&quot;#section-4.3&quot;&gt;4.3&lt;/a&gt;. Property Values 
           &lt;a href=&quot;#section-4.3.1&quot;&gt;4.3.1&lt;/a&gt;. Example - Property with Mixed Content 
      &lt;a href=&quot;#section-4.4&quot;&gt;4.4&lt;/a&gt;. Property Names 
      &lt;a href=&quot;#section-4.5&quot;&gt;4.5&lt;/a&gt;. Source Resources and Output Resources 
   &lt;a href=&quot;#section-5&quot;&gt;5&lt;/a&gt;. Collections of Web Resources 
      &lt;a href=&quot;#section-5.1&quot;&gt;5.1&lt;/a&gt;. HTTP URL Namespace Model 
      &lt;a href=&quot;#section-5.2&quot;&gt;5.2&lt;/a&gt;. Collection Resources 
   &lt;a href=&quot;#section-6&quot;&gt;6&lt;/a&gt;. Locking 
      &lt;a href=&quot;#section-6.1&quot;&gt;6.1&lt;/a&gt;. Lock Model 
      &lt;a href=&quot;#section-6.2&quot;&gt;6.2&lt;/a&gt;. Exclusive vs. Shared Locks 
      &lt;a href=&quot;#section-6.3&quot;&gt;6.3&lt;/a&gt;. Required Support 
      &lt;a href=&quot;#section-6.4&quot;&gt;6.4&lt;/a&gt;. Lock Creator and Privileges 
      &lt;a href=&quot;#section-6.5&quot;&gt;6.5&lt;/a&gt;. Lock Tokens 
      &lt;a href=&quot;#section-6.6&quot;&gt;6.6&lt;/a&gt;. Lock Timeout 
      &lt;a href=&quot;#section-6.7&quot;&gt;6.7&lt;/a&gt;. Lock Capability Discovery 
      &lt;a href=&quot;#section-6.8&quot;&gt;6.8&lt;/a&gt;. Active Lock Discovery 
   &lt;a href=&quot;#section-7&quot;&gt;7&lt;/a&gt;. Write Lock 
      &lt;a href=&quot;#section-7.1&quot;&gt;7.1&lt;/a&gt;. Write Locks and Properties 
      &lt;a href=&quot;#section-7.2&quot;&gt;7.2&lt;/a&gt;. Avoiding Lost Updates 
      &lt;a href=&quot;#section-7.3&quot;&gt;7.3&lt;/a&gt;. Write Locks and Unmapped URLs 
      &lt;a href=&quot;#section-7.4&quot;&gt;7.4&lt;/a&gt;. Write Locks and Collections 
      &lt;a href=&quot;#section-7.5&quot;&gt;7.5&lt;/a&gt;. Write Locks and the If Request Header 
           &lt;a href=&quot;#section-7.5.1&quot;&gt;7.5.1&lt;/a&gt;. Example - Write Lock and COPY 
           7.5.2. Example - Deleting a Member of a Locked
                  Collection 
      &lt;a href=&quot;#section-7.6&quot;&gt;7.6&lt;/a&gt;. Write Locks and COPY/MOVE 
      &lt;a href=&quot;#section-7.7&quot;&gt;7.7&lt;/a&gt;. Refreshing Write Locks 
   &lt;a href=&quot;#section-8&quot;&gt;8&lt;/a&gt;. General Request and Response Handling 
      &lt;a href=&quot;#section-8.1&quot;&gt;8.1&lt;/a&gt;. Precedence in Error Handling 
      &lt;a href=&quot;#section-8.2&quot;&gt;8.2&lt;/a&gt;. Use of XML 
      &lt;a href=&quot;#section-8.3&quot;&gt;8.3&lt;/a&gt;. URL Handling 
           &lt;a href=&quot;#section-8.3.1&quot;&gt;8.3.1&lt;/a&gt;. Example - Correct URL Handling 
      &lt;a href=&quot;#section-8.4&quot;&gt;8.4&lt;/a&gt;. Required Bodies in Requests 
      &lt;a href=&quot;#section-8.5&quot;&gt;8.5&lt;/a&gt;. HTTP Headers for Use in WebDAV 
      &lt;a href=&quot;#section-8.6&quot;&gt;8.6&lt;/a&gt;. ETag 
      &lt;a href=&quot;#section-8.7&quot;&gt;8.7&lt;/a&gt;. Including Error Response Bodies 
      &lt;a href=&quot;#section-8.8&quot;&gt;8.8&lt;/a&gt;. Impact of Namespace Operations on Cache Validators 
   &lt;a href=&quot;#section-9&quot;&gt;9&lt;/a&gt;. HTTP Methods for Distributed Authoring 
      &lt;a href=&quot;#section-9.1&quot;&gt;9.1&lt;/a&gt;. PROPFIND Method 
           &lt;a href=&quot;#section-9.1.1&quot;&gt;9.1.1&lt;/a&gt;. PROPFIND Status Codes .............................. 

           &lt;a href=&quot;#section-9.1.2&quot;&gt;9.1.2&lt;/a&gt;. Status Codes for Use in 'propstat' Element 
           &lt;a href=&quot;#section-9.1.3&quot;&gt;9.1.3&lt;/a&gt;. Example - Retrieving Named Properties 
           9.1.4. Example - Using 'propname' to Retrieve All
                  Property Names 
           &lt;a href=&quot;#section-9.1.5&quot;&gt;9.1.5&lt;/a&gt;. Example - Using So-called 'allprop' 
           &lt;a href=&quot;#section-9.1.6&quot;&gt;9.1.6&lt;/a&gt;. Example - Using 'allprop' with 'include' 
      &lt;a href=&quot;#section-9.2&quot;&gt;9.2&lt;/a&gt;. PROPPATCH Method 
           &lt;a href=&quot;#section-9.2.1&quot;&gt;9.2.1&lt;/a&gt;. Status Codes for Use in 'propstat' Element 
           &lt;a href=&quot;#section-9.2.2&quot;&gt;9.2.2&lt;/a&gt;. Example - PROPPATCH 
      &lt;a href=&quot;#section-9.3&quot;&gt;9.3&lt;/a&gt;. MKCOL Method 
           &lt;a href=&quot;#section-9.3.1&quot;&gt;9.3.1&lt;/a&gt;. MKCOL Status Codes 
           &lt;a href=&quot;#section-9.3.2&quot;&gt;9.3.2&lt;/a&gt;. Example - MKCOL 
      &lt;a href=&quot;#section-9.4&quot;&gt;9.4&lt;/a&gt;. GET, HEAD for Collections 
      &lt;a href=&quot;#section-9.5&quot;&gt;9.5&lt;/a&gt;. POST for Collections 
      &lt;a href=&quot;#section-9.6&quot;&gt;9.6&lt;/a&gt;. DELETE Requirements 
           &lt;a href=&quot;#section-9.6.1&quot;&gt;9.6.1&lt;/a&gt;. DELETE for Collections 
           &lt;a href=&quot;#section-9.6.2&quot;&gt;9.6.2&lt;/a&gt;. Example - DELETE 
      &lt;a href=&quot;#section-9.7&quot;&gt;9.7&lt;/a&gt;. PUT Requirements 
           &lt;a href=&quot;#section-9.7.1&quot;&gt;9.7.1&lt;/a&gt;. PUT for Non-Collection Resources 
           &lt;a href=&quot;#section-9.7.2&quot;&gt;9.7.2&lt;/a&gt;. PUT for Collections 
      &lt;a href=&quot;#section-9.8&quot;&gt;9.8&lt;/a&gt;. COPY Method 
           &lt;a href=&quot;#section-9.8.1&quot;&gt;9.8.1&lt;/a&gt;. COPY for Non-collection Resources 
           &lt;a href=&quot;#section-9.8.2&quot;&gt;9.8.2&lt;/a&gt;. COPY for Properties 
           &lt;a href=&quot;#section-9.8.3&quot;&gt;9.8.3&lt;/a&gt;. COPY for Collections 
           &lt;a href=&quot;#section-9.8.4&quot;&gt;9.8.4&lt;/a&gt;. COPY and Overwriting Destination Resources 
           &lt;a href=&quot;#section-9.8.5&quot;&gt;9.8.5&lt;/a&gt;. Status Codes 
           &lt;a href=&quot;#section-9.8.6&quot;&gt;9.8.6&lt;/a&gt;. Example - COPY with Overwrite 
           &lt;a href=&quot;#section-9.8.7&quot;&gt;9.8.7&lt;/a&gt;. Example - COPY with No Overwrite 
           &lt;a href=&quot;#section-9.8.8&quot;&gt;9.8.8&lt;/a&gt;. Example - COPY of a Collection 
      &lt;a href=&quot;#section-9.9&quot;&gt;9.9&lt;/a&gt;. MOVE Method 
           &lt;a href=&quot;#section-9.9.1&quot;&gt;9.9.1&lt;/a&gt;. MOVE for Properties 
           &lt;a href=&quot;#section-9.9.2&quot;&gt;9.9.2&lt;/a&gt;. MOVE for Collections 
           &lt;a href=&quot;#section-9.9.3&quot;&gt;9.9.3&lt;/a&gt;. MOVE and the Overwrite Header 
           &lt;a href=&quot;#section-9.9.4&quot;&gt;9.9.4&lt;/a&gt;. Status Codes 
           &lt;a href=&quot;#section-9.9.5&quot;&gt;9.9.5&lt;/a&gt;. Example - MOVE of a Non-Collection 
           &lt;a href=&quot;#section-9.9.6&quot;&gt;9.9.6&lt;/a&gt;. Example - MOVE of a Collection 
      &lt;a href=&quot;#section-9.10&quot;&gt;9.10&lt;/a&gt;. LOCK Method 
           &lt;a href=&quot;#section-9.10.1&quot;&gt;9.10.1&lt;/a&gt;. Creating a Lock on an Existing Resource 
           &lt;a href=&quot;#section-9.10.2&quot;&gt;9.10.2&lt;/a&gt;. Refreshing Locks 
           &lt;a href=&quot;#section-9.10.3&quot;&gt;9.10.3&lt;/a&gt;. Depth and Locking 
           &lt;a href=&quot;#section-9.10.4&quot;&gt;9.10.4&lt;/a&gt;. Locking Unmapped URLs 
           &lt;a href=&quot;#section-9.10.5&quot;&gt;9.10.5&lt;/a&gt;. Lock Compatibility Table 
           &lt;a href=&quot;#section-9.10.6&quot;&gt;9.10.6&lt;/a&gt;. LOCK Responses 
           &lt;a href=&quot;#section-9.10.7&quot;&gt;9.10.7&lt;/a&gt;. Example - Simple Lock Request 
           &lt;a href=&quot;#section-9.10.8&quot;&gt;9.10.8&lt;/a&gt;. Example - Refreshing a Write Lock 
           &lt;a href=&quot;#section-9.10.9&quot;&gt;9.10.9&lt;/a&gt;. Example - Multi-Resource Lock Request 
      &lt;a href=&quot;#section-9.11&quot;&gt;9.11&lt;/a&gt;. UNLOCK Method 
           &lt;a href=&quot;#section-9.11.1&quot;&gt;9.11.1&lt;/a&gt;. Status Codes ...................................... 

           &lt;a href=&quot;#section-9.11.2&quot;&gt;9.11.2&lt;/a&gt;. Example - UNLOCK 
   &lt;a href=&quot;#section-10&quot;&gt;10&lt;/a&gt;. HTTP Headers for Distributed Authoring 
      &lt;a href=&quot;#section-10.1&quot;&gt;10.1&lt;/a&gt;. DAV Header 
      &lt;a href=&quot;#section-10.2&quot;&gt;10.2&lt;/a&gt;. Depth Header 
      &lt;a href=&quot;#section-10.3&quot;&gt;10.3&lt;/a&gt;. Destination Header 
      &lt;a href=&quot;#section-10.4&quot;&gt;10.4&lt;/a&gt;. If Header 
           &lt;a href=&quot;#section-10.4.1&quot;&gt;10.4.1&lt;/a&gt;. Purpose 
           &lt;a href=&quot;#section-10.4.2&quot;&gt;10.4.2&lt;/a&gt;. Syntax 
           &lt;a href=&quot;#section-10.4.3&quot;&gt;10.4.3&lt;/a&gt;. List Evaluation 
           &lt;a href=&quot;#section-10.4.4&quot;&gt;10.4.4&lt;/a&gt;. Matching State Tokens and ETags 
           &lt;a href=&quot;#section-10.4.5&quot;&gt;10.4.5&lt;/a&gt;. If Header and Non-DAV-Aware Proxies 
           &lt;a href=&quot;#section-10.4.6&quot;&gt;10.4.6&lt;/a&gt;. Example - No-tag Production 
           &lt;a href=&quot;#section-10.4.7&quot;&gt;10.4.7&lt;/a&gt;. Example - Using &quot;Not&quot; with No-tag Production 
           10.4.8. Example - Causing a Condition to Always
                   Evaluate to True 
           &lt;a href=&quot;#section-10.4.9&quot;&gt;10.4.9&lt;/a&gt;. Example - Tagged List If Header in COPY 
           10.4.10. Example - Matching Lock Tokens with
                    Collection Locks 
           &lt;a href=&quot;#section-10.4.11&quot;&gt;10.4.11&lt;/a&gt;. Example - Matching ETags on Unmapped URLs 
      &lt;a href=&quot;#section-10.5&quot;&gt;10.5&lt;/a&gt;. Lock-Token Header 
      &lt;a href=&quot;#section-10.6&quot;&gt;10.6&lt;/a&gt;. Overwrite Header 
      &lt;a href=&quot;#section-10.7&quot;&gt;10.7&lt;/a&gt;. Timeout Request Header 
   &lt;a href=&quot;#section-11&quot;&gt;11&lt;/a&gt;. Status Code Extensions to HTTP/1.1 
      &lt;a href=&quot;#section-11.1&quot;&gt;11.1&lt;/a&gt;. 207 Multi-Status 
      &lt;a href=&quot;#section-11.2&quot;&gt;11.2&lt;/a&gt;. 422 Unprocessable Entity 
      &lt;a href=&quot;#section-11.3&quot;&gt;11.3&lt;/a&gt;. 423 Locked 
      &lt;a href=&quot;#section-11.4&quot;&gt;11.4&lt;/a&gt;. 424 Failed Dependency 
      &lt;a href=&quot;#section-11.5&quot;&gt;11.5&lt;/a&gt;. 507 Insufficient Storage 
   &lt;a href=&quot;#section-12&quot;&gt;12&lt;/a&gt;. Use of HTTP Status Codes 
      &lt;a href=&quot;#section-12.1&quot;&gt;12.1&lt;/a&gt;. 412 Precondition Failed 
      &lt;a href=&quot;#section-12.2&quot;&gt;12.2&lt;/a&gt;. 414 Request-URI Too Long 
   &lt;a href=&quot;#section-13&quot;&gt;13&lt;/a&gt;. Multi-Status Response 
      &lt;a href=&quot;#section-13.1&quot;&gt;13.1&lt;/a&gt;. Response Headers 
      &lt;a href=&quot;#section-13.2&quot;&gt;13.2&lt;/a&gt;. Handling Redirected Child Resources 
      &lt;a href=&quot;#section-13.3&quot;&gt;13.3&lt;/a&gt;. Internal Status Codes 
   &lt;a href=&quot;#section-14&quot;&gt;14&lt;/a&gt;. XML Element Definitions 
      &lt;a href=&quot;#section-14.1&quot;&gt;14.1&lt;/a&gt;. activelock XML Element 
      &lt;a href=&quot;#section-14.2&quot;&gt;14.2&lt;/a&gt;. allprop XML Element 
      &lt;a href=&quot;#section-14.3&quot;&gt;14.3&lt;/a&gt;. collection XML Element 
      &lt;a href=&quot;#section-14.4&quot;&gt;14.4&lt;/a&gt;. depth XML Element 
      &lt;a href=&quot;#section-14.5&quot;&gt;14.5&lt;/a&gt;. error XML Element 
      &lt;a href=&quot;#section-14.6&quot;&gt;14.6&lt;/a&gt;. exclusive XML Element 
      &lt;a href=&quot;#section-14.7&quot;&gt;14.7&lt;/a&gt;. href XML Element 
      &lt;a href=&quot;#section-14.8&quot;&gt;14.8&lt;/a&gt;. include XML Element 
      &lt;a href=&quot;#section-14.9&quot;&gt;14.9&lt;/a&gt;. location XML Element 
      &lt;a href=&quot;#section-14.10&quot;&gt;14.10&lt;/a&gt;. lockentry XML Element 
      &lt;a href=&quot;#section-14.11&quot;&gt;14.11&lt;/a&gt;. lockinfo XML Element 
      &lt;a href=&quot;#section-14.12&quot;&gt;14.12&lt;/a&gt;. lockroot XML Element .................................... 

      &lt;a href=&quot;#section-14.13&quot;&gt;14.13&lt;/a&gt;. lockscope XML Element 
      &lt;a href=&quot;#section-14.14&quot;&gt;14.14&lt;/a&gt;. locktoken XML Element 
      &lt;a href=&quot;#section-14.15&quot;&gt;14.15&lt;/a&gt;. locktype XML Element 
      &lt;a href=&quot;#section-14.16&quot;&gt;14.16&lt;/a&gt;. multistatus XML Element 
      &lt;a href=&quot;#section-14.17&quot;&gt;14.17&lt;/a&gt;. owner XML Element 
      &lt;a href=&quot;#section-14.18&quot;&gt;14.18&lt;/a&gt;. prop XML Element 
      &lt;a href=&quot;#section-14.19&quot;&gt;14.19&lt;/a&gt;. propertyupdate XML Element 
      &lt;a href=&quot;#section-14.20&quot;&gt;14.20&lt;/a&gt;. propfind XML Element 
      &lt;a href=&quot;#section-14.21&quot;&gt;14.21&lt;/a&gt;. propname XML Element 
      &lt;a href=&quot;#section-14.22&quot;&gt;14.22&lt;/a&gt;. propstat XML Element 
      &lt;a href=&quot;#section-14.23&quot;&gt;14.23&lt;/a&gt;. remove XML Element 
      &lt;a href=&quot;#section-14.24&quot;&gt;14.24&lt;/a&gt;. response XML Element 
      &lt;a href=&quot;#section-14.25&quot;&gt;14.25&lt;/a&gt;. responsedescription XML Element 
      &lt;a href=&quot;#section-14.26&quot;&gt;14.26&lt;/a&gt;. set XML Element 
      &lt;a href=&quot;#section-14.27&quot;&gt;14.27&lt;/a&gt;. shared XML Element 
      &lt;a href=&quot;#section-14.28&quot;&gt;14.28&lt;/a&gt;. status XML Element 
      &lt;a href=&quot;#section-14.29&quot;&gt;14.29&lt;/a&gt;. timeout XML Element 
      &lt;a href=&quot;#section-14.30&quot;&gt;14.30&lt;/a&gt;. write XML Element 
   &lt;a href=&quot;#section-15&quot;&gt;15&lt;/a&gt;. DAV Properties 
   &lt;a href=&quot;#section-16&quot;&gt;16&lt;/a&gt;. Precondition/Postcondition XML Elements 
   &lt;a href=&quot;#section-17&quot;&gt;17&lt;/a&gt;. XML Extensibility in DAV 
   &lt;a href=&quot;#section-18&quot;&gt;18&lt;/a&gt;. DAV Compliance Classes 
      &lt;a href=&quot;#section-18.1&quot;&gt;18.1&lt;/a&gt;. Class 1 
      &lt;a href=&quot;#section-18.2&quot;&gt;18.2&lt;/a&gt;. Class 2 
      &lt;a href=&quot;#section-18.3&quot;&gt;18.3&lt;/a&gt;. Class 3 
   &lt;a href=&quot;#section-19&quot;&gt;19&lt;/a&gt;. Internationalization Considerations 
   &lt;a href=&quot;#section-20&quot;&gt;20&lt;/a&gt;. Security Considerations 
      &lt;a href=&quot;#section-20.1&quot;&gt;20.1&lt;/a&gt;. Authentication of Clients 
      &lt;a href=&quot;#section-20.2&quot;&gt;20.2&lt;/a&gt;. Denial of Service 
      &lt;a href=&quot;#section-20.3&quot;&gt;20.3&lt;/a&gt;. Security through Obscurity 
      &lt;a href=&quot;#section-20.4&quot;&gt;20.4&lt;/a&gt;. Privacy Issues Connected to Locks 
      &lt;a href=&quot;#section-20.5&quot;&gt;20.5&lt;/a&gt;. Privacy Issues Connected to Properties 
      &lt;a href=&quot;#section-20.6&quot;&gt;20.6&lt;/a&gt;. Implications of XML Entities 
      &lt;a href=&quot;#section-20.7&quot;&gt;20.7&lt;/a&gt;. Risks Connected with Lock Tokens 
      &lt;a href=&quot;#section-20.8&quot;&gt;20.8&lt;/a&gt;. Hosting Malicious Content 
   &lt;a href=&quot;#section-21&quot;&gt;21&lt;/a&gt;. IANA Considerations 
      &lt;a href=&quot;#section-21.1&quot;&gt;21.1&lt;/a&gt;. New URI Schemes 
      &lt;a href=&quot;#section-21.2&quot;&gt;21.2&lt;/a&gt;. XML Namespaces 
      &lt;a href=&quot;#section-21.3&quot;&gt;21.3&lt;/a&gt;. Message Header Fields 
           &lt;a href=&quot;#section-21.3.1&quot;&gt;21.3.1&lt;/a&gt;. DAV 
           &lt;a href=&quot;#section-21.3.2&quot;&gt;21.3.2&lt;/a&gt;. Depth 
           &lt;a href=&quot;#section-21.3.3&quot;&gt;21.3.3&lt;/a&gt;. Destination 
           &lt;a href=&quot;#section-21.3.4&quot;&gt;21.3.4&lt;/a&gt;. If 
           &lt;a href=&quot;#section-21.3.5&quot;&gt;21.3.5&lt;/a&gt;. Lock-Token 
           &lt;a href=&quot;#section-21.3.6&quot;&gt;21.3.6&lt;/a&gt;. Overwrite 
           &lt;a href=&quot;#section-21.3.7&quot;&gt;21.3.7&lt;/a&gt;. Timeout 
      &lt;a href=&quot;#section-21.4&quot;&gt;21.4&lt;/a&gt;. HTTP Status Codes 
   &lt;a href=&quot;#section-22&quot;&gt;22&lt;/a&gt;. Acknowledgements ............................................. 

   &lt;a href=&quot;#section-23&quot;&gt;23&lt;/a&gt;. Contributors to This Specification 
   &lt;a href=&quot;#section-24&quot;&gt;24&lt;/a&gt;. Authors of &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518&lt;/a&gt;&lt;a href=&quot;#section-25&quot;&gt;25&lt;/a&gt;. References 
      &lt;a href=&quot;#section-25.1&quot;&gt;25.1&lt;/a&gt;. Normative References
      &lt;a href=&quot;#section-25.2&quot;&gt;25.2&lt;/a&gt;. Informative References 
   &lt;a href=&quot;#appendix-A&quot;&gt;Appendix A&lt;/a&gt;.  Notes on Processing XML Elements 
      &lt;a href=&quot;#appendix-A.1&quot;&gt;A.1&lt;/a&gt;. Notes on Empty XML Elements 
      &lt;a href=&quot;#appendix-A.2&quot;&gt;A.2&lt;/a&gt;. Notes on Illegal XML Processing 
      &lt;a href=&quot;#appendix-A.3&quot;&gt;A.3&lt;/a&gt;. Example - XML Syntax Error 
      &lt;a href=&quot;#appendix-A.4&quot;&gt;A.4&lt;/a&gt;. Example - Unexpected XML Element 
   &lt;a href=&quot;#appendix-B&quot;&gt;Appendix B&lt;/a&gt;. Notes on HTTP Client Compatibility 
   &lt;a href=&quot;#appendix-C&quot;&gt;Appendix C&lt;/a&gt;. The 'opaquelocktoken' Scheme and URIs 
   &lt;a href=&quot;#appendix-D&quot;&gt;Appendix D&lt;/a&gt;. Lock-null Resources 
      &lt;a href=&quot;#appendix-D.1&quot;&gt;D.1&lt;/a&gt;. Guidance for Clients Using LOCK to Create Resources 
   &lt;a href=&quot;#appendix-E&quot;&gt;Appendix E&lt;/a&gt;. Guidance for Clients Desiring to Authenticate 
   &lt;a href=&quot;#appendix-F&quot;&gt;Appendix F&lt;/a&gt;. Summary of Changes from &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518&lt;/a&gt;&lt;a href=&quot;#appendix-F.1&quot;&gt;F.1&lt;/a&gt;. Changes for Both Client and Server Implementations 
      &lt;a href=&quot;#appendix-F.2&quot;&gt;F.2&lt;/a&gt;. Changes for Server Implementations 
      &lt;a href=&quot;#appendix-F.3&quot;&gt;F.3&lt;/a&gt;. Other Changes ............................................</source>
          <target state="translated">本备忘录的状态本文档指定了Internet社区的Internet标准跟踪协议，并要求讨论和提出改进建议。请参阅当前版本的&amp;ldquo; Internet官方协议标准&amp;rdquo;（STD 1）了解此协议的标准化状态。该备忘录的分发是无限的。版权声明版权所有（C）IETF信托（2007）。抽象Web分布式创作和版本控制（WebDAV）由HTTP / 1.1附带的一组方法，标头和内容类型组成，用于管理资源属性，创建和管理资源集合，URL名称空间操纵以及资源锁定（冲突）避免）。 &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518&lt;/a&gt;该规范于1999年2月发布，并且由于互操作性方面的经验，该规范使&lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518&lt;/a&gt;稍作修订就过时了。目录 &lt;a href=&quot;#section-1&quot;&gt;1&lt;/a&gt;。介绍 &lt;a href=&quot;#section-2&quot;&gt;2&lt;/a&gt;。符号约定 &lt;a href=&quot;#section-3&quot;&gt;3&lt;/a&gt;。术语 &lt;a href=&quot;#section-4&quot;&gt;4&lt;/a&gt;。资源属性的数据模型 &lt;a href=&quot;#section-4.1&quot;&gt;4.1&lt;/a&gt;。资源属性模型 &lt;a href=&quot;#section-4.2&quot;&gt;4.2&lt;/a&gt;。属性和HTTP标头 &lt;a href=&quot;#section-4.3&quot;&gt;4.3&lt;/a&gt;。属性值 &lt;a href=&quot;#section-4.3.1&quot;&gt;4.3.1&lt;/a&gt;。示例-具有混合内容的属性 &lt;a href=&quot;#section-4.4&quot;&gt;4.4&lt;/a&gt;。财产名称 &lt;a href=&quot;#section-4.5&quot;&gt;4.5&lt;/a&gt;。源资源和输出资源 &lt;a href=&quot;#section-5&quot;&gt;5&lt;/a&gt;。 Web资源的收集 &lt;a href=&quot;#section-5.1&quot;&gt;5.1&lt;/a&gt;。 HTTP URL命名空间模型 &lt;a href=&quot;#section-5.2&quot;&gt;5.2&lt;/a&gt;。收藏资源 &lt;a href=&quot;#section-6&quot;&gt;6&lt;/a&gt;。锁定 &lt;a href=&quot;#section-6.1&quot;&gt;6.1&lt;/a&gt;。锁模型 &lt;a href=&quot;#section-6.2&quot;&gt;6.2&lt;/a&gt;。排他锁与共享锁 &lt;a href=&quot;#section-6.3&quot;&gt;6.3&lt;/a&gt;。所需的支持 &lt;a href=&quot;#section-6.4&quot;&gt;6.4&lt;/a&gt;。锁定创建者和特权 &lt;a href=&quot;#section-6.5&quot;&gt;6.5&lt;/a&gt;。锁令牌 &lt;a href=&quot;#section-6.6&quot;&gt;6.6&lt;/a&gt;。锁定超时 &lt;a href=&quot;#section-6.7&quot;&gt;6.7&lt;/a&gt;。锁定功能发现 &lt;a href=&quot;#section-6.8&quot;&gt;6.8&lt;/a&gt;。主动锁发现 &lt;a href=&quot;#section-7&quot;&gt;7&lt;/a&gt;。写锁 &lt;a href=&quot;#section-7.1&quot;&gt;7.1&lt;/a&gt;。写锁和属性 &lt;a href=&quot;#section-7.2&quot;&gt;7.2&lt;/a&gt;。避免丢失的更新 &lt;a href=&quot;#section-7.3&quot;&gt;7.3&lt;/a&gt;。写锁和未映射的URL &lt;a href=&quot;#section-7.4&quot;&gt;7.4&lt;/a&gt;。写锁和收藏 &lt;a href=&quot;#section-7.5&quot;&gt;7.5&lt;/a&gt;。写锁和If Request标头 &lt;a href=&quot;#section-7.5.1&quot;&gt;7.5.1&lt;/a&gt;。示例-写锁和复制7.5.2。示例-删除锁定集合的成员 &lt;a href=&quot;#section-7.6&quot;&gt;7.6&lt;/a&gt;。写锁和COPY / MOVE &lt;a href=&quot;#section-7.7&quot;&gt;7.7&lt;/a&gt;。刷新写锁 &lt;a href=&quot;#section-8&quot;&gt;8&lt;/a&gt;。一般请求和响应处理 &lt;a href=&quot;#section-8.1&quot;&gt;8.1&lt;/a&gt;。错误处理的优先 &lt;a href=&quot;#section-8.2&quot;&gt;8.2&lt;/a&gt;。使用XML &lt;a href=&quot;#section-8.3&quot;&gt;8.3&lt;/a&gt;。 URL处理 &lt;a href=&quot;#section-8.3.1&quot;&gt;8.3.1&lt;/a&gt;。示例-正确的URL处理 &lt;a href=&quot;#section-8.4&quot;&gt;8.4&lt;/a&gt;。要求的机构 &lt;a href=&quot;#section-8.5&quot;&gt;8.5&lt;/a&gt;。 WebDAV &lt;a href=&quot;#section-8.6&quot;&gt;8.6中&lt;/a&gt;使用的HTTP标头 。 ETag &lt;a href=&quot;#section-8.7&quot;&gt;8.7&lt;/a&gt;。包括错误响应机构 &lt;a href=&quot;#section-8.8&quot;&gt;8.8&lt;/a&gt;。命名空间操作对缓存验证器的影响 &lt;a href=&quot;#section-9&quot;&gt;9&lt;/a&gt;。分布式创作的HTTP方法 &lt;a href=&quot;#section-9.1&quot;&gt;9.1&lt;/a&gt;。 PROPFIND方法 &lt;a href=&quot;#section-9.1.1&quot;&gt;9.1.1&lt;/a&gt;。 PROPFIND状态码.................................... &lt;a href=&quot;#section-9.1.2&quot;&gt;9.1.2&lt;/a&gt;。在&amp;ldquo; propstat&amp;rdquo;元素&lt;a href=&quot;#section-9.1.3&quot;&gt;9.1.3中&lt;/a&gt;使用的状态代码 。示例-检索命名属性9.1.4。示例-使用&amp;ldquo; propname&amp;rdquo;检索所有属性名称 &lt;a href=&quot;#section-9.1.5&quot;&gt;9.1.5&lt;/a&gt;。示例-使用所谓的&amp;ldquo;allprop&amp;rdquo; &lt;a href=&quot;#section-9.1.6&quot;&gt;9.1.6&lt;/a&gt;。示例-使用与&amp;ldquo;allprop&amp;rdquo;&amp;ldquo;包括&amp;rdquo; &lt;a href=&quot;#section-9.2&quot;&gt;9.2&lt;/a&gt;。 PROPPATCH方法 &lt;a href=&quot;#section-9.2.1&quot;&gt;9.2.1&lt;/a&gt;。在&amp;ldquo; propstat&amp;rdquo;元素&lt;a href=&quot;#section-9.2.2&quot;&gt;9.2.2中&lt;/a&gt;使用的状态代码 。示例-PROPPATCH &lt;a href=&quot;#section-9.3&quot;&gt;9.3&lt;/a&gt;。 MKCOL方法 &lt;a href=&quot;#section-9.3.1&quot;&gt;9.3.1&lt;/a&gt;。 MKCOL状态代码 &lt;a href=&quot;#section-9.3.2&quot;&gt;9.3.2&lt;/a&gt;。示例-MKCOL &lt;a href=&quot;#section-9.4&quot;&gt;9.4&lt;/a&gt;。 GET，HEAD到集合 &lt;a href=&quot;#section-9.5&quot;&gt;9.5&lt;/a&gt;。集合的POST &lt;a href=&quot;#section-9.6&quot;&gt;9.6&lt;/a&gt;。删除要求 &lt;a href=&quot;#section-9.6.1&quot;&gt;9.6.1&lt;/a&gt;。删除集合 &lt;a href=&quot;#section-9.6.2&quot;&gt;9.6.2&lt;/a&gt;。示例-删除 &lt;a href=&quot;#section-9.7&quot;&gt;9.7&lt;/a&gt;。 PUT要求 &lt;a href=&quot;#section-9.7.1&quot;&gt;9.7.1&lt;/a&gt;。非收集资源的PUT &lt;a href=&quot;#section-9.7.2&quot;&gt;9.7.2&lt;/a&gt;。收集 &lt;a href=&quot;#section-9.8&quot;&gt;9.8&lt;/a&gt;。 COPY方法 &lt;a href=&quot;#section-9.8.1&quot;&gt;9.8.1&lt;/a&gt;。 COPY非收集资源 &lt;a href=&quot;#section-9.8.2&quot;&gt;9.8.2&lt;/a&gt;。&lt;a href=&quot;#section-9.8.3&quot;&gt;9.8.3&lt;/a&gt;复制属性 。副本的收藏 &lt;a href=&quot;#section-9.8.4&quot;&gt;9.8.4&lt;/a&gt;。复制和覆盖目标资源 &lt;a href=&quot;#section-9.8.5&quot;&gt;9.8.5&lt;/a&gt;。状态码 &lt;a href=&quot;#section-9.8.6&quot;&gt;9.8.6&lt;/a&gt;。示例-覆盖&lt;a href=&quot;#section-9.8.7&quot;&gt;9.8.7的&lt;/a&gt; COPY 。示例&lt;a href=&quot;#section-9.8.8&quot;&gt;-COPY&lt;/a&gt;不覆盖 9.8.8。示例-复制 &lt;a href=&quot;#section-9.9&quot;&gt;9.9&lt;/a&gt;。移动方法 &lt;a href=&quot;#section-9.9.1&quot;&gt;9.9.1&lt;/a&gt;。移动属性 &lt;a href=&quot;#section-9.9.2&quot;&gt;9.9.2&lt;/a&gt;。移动集合 &lt;a href=&quot;#section-9.9.3&quot;&gt;9.9.3&lt;/a&gt;。 MOVE和覆盖标头 &lt;a href=&quot;#section-9.9.4&quot;&gt;9.9.4&lt;/a&gt;。状态码 &lt;a href=&quot;#section-9.9.5&quot;&gt;9.9.5&lt;/a&gt;。示例-非收藏&lt;a href=&quot;#section-9.9.6&quot;&gt;夹的&lt;/a&gt; MOVE 9.9.6。示例-集合的移动 &lt;a href=&quot;#section-9.10&quot;&gt;9.10&lt;/a&gt;。锁定方法 &lt;a href=&quot;#section-9.10.1&quot;&gt;9.10.1&lt;/a&gt;。在现有资源&lt;a href=&quot;#section-9.10.2&quot;&gt;9.10.2&lt;/a&gt;上创建锁 。刷新锁 &lt;a href=&quot;#section-9.10.3&quot;&gt;9.10.3&lt;/a&gt;。深度和锁定 &lt;a href=&quot;#section-9.10.4&quot;&gt;9.10.4&lt;/a&gt;。锁定未映射的URL &lt;a href=&quot;#section-9.10.5&quot;&gt;9.10.5&lt;/a&gt;。锁兼容性表 &lt;a href=&quot;#section-9.10.6&quot;&gt;9.10.6&lt;/a&gt;。锁响应 &lt;a href=&quot;#section-9.10.7&quot;&gt;9.10.7&lt;/a&gt;。示例-简单锁定请求 &lt;a href=&quot;#section-9.10.8&quot;&gt;9.10.8&lt;/a&gt;。示例-刷新写锁定 &lt;a href=&quot;#section-9.10.9&quot;&gt;9.10.9&lt;/a&gt;。示例-多资源锁定请求 &lt;a href=&quot;#section-9.11&quot;&gt;9.11&lt;/a&gt;。解锁方法 &lt;a href=&quot;#section-9.11.1&quot;&gt;9.11.1&lt;/a&gt;。状态码.......................................... &lt;a href=&quot;#section-9.11.2&quot;&gt;9.11.2&lt;/a&gt;。示例-解锁 &lt;a href=&quot;#section-10&quot;&gt;10&lt;/a&gt;。分布式创作的HTTP标头 &lt;a href=&quot;#section-10.1&quot;&gt;10.1&lt;/a&gt;。 DAV标头 &lt;a href=&quot;#section-10.2&quot;&gt;10.2&lt;/a&gt;。深度标题 &lt;a href=&quot;#section-10.3&quot;&gt;10.3&lt;/a&gt;。目标标题 &lt;a href=&quot;#section-10.4&quot;&gt;10.4&lt;/a&gt;。如果标题 &lt;a href=&quot;#section-10.4.1&quot;&gt;10.4.1&lt;/a&gt;。目的 &lt;a href=&quot;#section-10.4.2&quot;&gt;10.4.2&lt;/a&gt;。语法 &lt;a href=&quot;#section-10.4.3&quot;&gt;10.4.3&lt;/a&gt;。清单评估 &lt;a href=&quot;#section-10.4.4&quot;&gt;10.4.4&lt;/a&gt;。匹配状态令牌和ETag &lt;a href=&quot;#section-10.4.5&quot;&gt;10.4.5&lt;/a&gt;。如果标题和非DAV感知代理 &lt;a href=&quot;#section-10.4.6&quot;&gt;10.4.6&lt;/a&gt;。示例-无标签生产 &lt;a href=&quot;#section-10.4.7&quot;&gt;10.4.7&lt;/a&gt;。示例-在无标签生产中使用&amp;ldquo;不&amp;rdquo; 10.4.8。示例-使条件始终评估为True &lt;a href=&quot;#section-10.4.9&quot;&gt;10.4.9&lt;/a&gt;。示例-COPY 10.4.10中带标题的标记列表。示例-将锁令牌与集合锁匹配 &lt;a href=&quot;#section-10.4.11&quot;&gt;10.4.11&lt;/a&gt;。示例-在未映射的URL上匹配ETag &lt;a href=&quot;#section-10.5&quot;&gt;10.5&lt;/a&gt;。锁令牌头 &lt;a href=&quot;#section-10.6&quot;&gt;10.6&lt;/a&gt;。覆盖标题 &lt;a href=&quot;#section-10.7&quot;&gt;10.7&lt;/a&gt;。超时请求标头 &lt;a href=&quot;#section-11&quot;&gt;11&lt;/a&gt;。 HTTP / 1.1 &lt;a href=&quot;#section-11.1&quot;&gt;11.1的&lt;/a&gt;状态代码扩展 。 207多状态 &lt;a href=&quot;#section-11.2&quot;&gt;11.2&lt;/a&gt;。 422不可处理实体 &lt;a href=&quot;#section-11.3&quot;&gt;11.3&lt;/a&gt;。 423锁定 &lt;a href=&quot;#section-11.4&quot;&gt;11.4&lt;/a&gt;。 424依赖失败 &lt;a href=&quot;#section-11.5&quot;&gt;11.5&lt;/a&gt;。 507存储空间不足 &lt;a href=&quot;#section-12&quot;&gt;12&lt;/a&gt;。 HTTP状态代码的使用 &lt;a href=&quot;#section-12.1&quot;&gt;12.1&lt;/a&gt;。 412前提条件失败 &lt;a href=&quot;#section-12.2&quot;&gt;12.2&lt;/a&gt;。 414请求URI太长 &lt;a href=&quot;#section-13&quot;&gt;13&lt;/a&gt;。多状态响应 &lt;a href=&quot;#section-13.1&quot;&gt;13.1&lt;/a&gt;。响应标题 &lt;a href=&quot;#section-13.2&quot;&gt;13.2&lt;/a&gt;。处理重定向的子资源 &lt;a href=&quot;#section-13.3&quot;&gt;13.3&lt;/a&gt;。内部状态代码 &lt;a href=&quot;#section-14&quot;&gt;14&lt;/a&gt;。 XML元素定义 &lt;a href=&quot;#section-14.1&quot;&gt;14.1&lt;/a&gt;。 activelock XML元素 &lt;a href=&quot;#section-14.2&quot;&gt;14.2&lt;/a&gt;。 allprop XML元素 &lt;a href=&quot;#section-14.3&quot;&gt;14.3&lt;/a&gt;。集合XML元素 &lt;a href=&quot;#section-14.4&quot;&gt;14.4&lt;/a&gt;。深度XML元素 &lt;a href=&quot;#section-14.5&quot;&gt;14.5&lt;/a&gt;。错误XML元素 &lt;a href=&quot;#section-14.6&quot;&gt;14.6&lt;/a&gt;。独家XML元素 &lt;a href=&quot;#section-14.7&quot;&gt;14.7&lt;/a&gt;。 href XML元素 &lt;a href=&quot;#section-14.8&quot;&gt;14.8&lt;/a&gt;。包括XML元素 &lt;a href=&quot;#section-14.9&quot;&gt;14.9&lt;/a&gt;。位置XML元素 &lt;a href=&quot;#section-14.10&quot;&gt;14.10&lt;/a&gt;。 lockentry XML元素 &lt;a href=&quot;#section-14.11&quot;&gt;14.11&lt;/a&gt;。 lockinfo XML元素 &lt;a href=&quot;#section-14.12&quot;&gt;14.12&lt;/a&gt;。 lockroot XML元素.................................... &lt;a href=&quot;#section-14.13&quot;&gt;14.13&lt;/a&gt;。 lockscope XML元素 &lt;a href=&quot;#section-14.14&quot;&gt;14.14&lt;/a&gt;。锁令牌XML元素 &lt;a href=&quot;#section-14.15&quot;&gt;14.15&lt;/a&gt;。锁定类型XML元素 &lt;a href=&quot;#section-14.16&quot;&gt;14.16&lt;/a&gt;。多状态XML元素 &lt;a href=&quot;#section-14.17&quot;&gt;14.17&lt;/a&gt;。所有者XML元素 &lt;a href=&quot;#section-14.18&quot;&gt;14.18&lt;/a&gt;。道具XML元素 &lt;a href=&quot;#section-14.19&quot;&gt;14.19&lt;/a&gt;。 propertyupdate XML元素 &lt;a href=&quot;#section-14.20&quot;&gt;14.20&lt;/a&gt;。支持XML元素 &lt;a href=&quot;#section-14.21&quot;&gt;14.21&lt;/a&gt;。 propname XML元素 &lt;a href=&quot;#section-14.22&quot;&gt;14.22&lt;/a&gt;。 propstat XML元素 &lt;a href=&quot;#section-14.23&quot;&gt;14.23&lt;/a&gt;。删除XML元素 &lt;a href=&quot;#section-14.24&quot;&gt;14.24&lt;/a&gt;。响应XML元素 &lt;a href=&quot;#section-14.25&quot;&gt;14.25&lt;/a&gt;。 responsedescription XML元素 &lt;a href=&quot;#section-14.26&quot;&gt;14.26&lt;/a&gt;。设置XML元素 &lt;a href=&quot;#section-14.27&quot;&gt;14.27&lt;/a&gt;。共享XML元素 &lt;a href=&quot;#section-14.28&quot;&gt;14.28&lt;/a&gt;。状态XML元素 &lt;a href=&quot;#section-14.29&quot;&gt;14.29&lt;/a&gt;。超时XML元素 &lt;a href=&quot;#section-14.30&quot;&gt;14.30&lt;/a&gt;。编写XML元素 &lt;a href=&quot;#section-15&quot;&gt;15&lt;/a&gt;。 DAV属性 &lt;a href=&quot;#section-16&quot;&gt;16&lt;/a&gt;。前置条件/​​后置条件XML元素 &lt;a href=&quot;#section-17&quot;&gt;17&lt;/a&gt;。 DAV中的XML可扩展性 &lt;a href=&quot;#section-18&quot;&gt;18&lt;/a&gt;。 DAV符合性等级 &lt;a href=&quot;#section-18.1&quot;&gt;18.1&lt;/a&gt;。 1级 &lt;a href=&quot;#section-18.2&quot;&gt;18.2&lt;/a&gt;。 2级 &lt;a href=&quot;#section-18.3&quot;&gt;18.3&lt;/a&gt;。第3类 &lt;a href=&quot;#section-19&quot;&gt;19&lt;/a&gt;。国际化注意事项 &lt;a href=&quot;#section-20&quot;&gt;20&lt;/a&gt;。安全注意事项 &lt;a href=&quot;#section-20.1&quot;&gt;20.1&lt;/a&gt;。客户认证 &lt;a href=&quot;#section-20.2&quot;&gt;20.2&lt;/a&gt;。拒绝服务 &lt;a href=&quot;#section-20.3&quot;&gt;20.3&lt;/a&gt;。通过隐蔽性获得安全性 &lt;a href=&quot;#section-20.4&quot;&gt;20.4&lt;/a&gt;。与锁&lt;a href=&quot;#section-20.5&quot;&gt;20.5相关的&lt;/a&gt;隐私问题 。连接到属性的隐私问题 &lt;a href=&quot;#section-20.6&quot;&gt;20.6&lt;/a&gt;。 XML实体的含义 &lt;a href=&quot;#section-20.7&quot;&gt;20.7&lt;/a&gt;。与锁令牌相关的风险 &lt;a href=&quot;#section-20.8&quot;&gt;20.8&lt;/a&gt;。托管恶意内容 &lt;a href=&quot;#section-21&quot;&gt;21&lt;/a&gt;。 IANA注意事项 &lt;a href=&quot;#section-21.1&quot;&gt;21.1&lt;/a&gt;。新URI方案 &lt;a href=&quot;#section-21.2&quot;&gt;21.2&lt;/a&gt;。 XML命名空间 &lt;a href=&quot;#section-21.3&quot;&gt;21.3&lt;/a&gt;。消息头字段 &lt;a href=&quot;#section-21.3.1&quot;&gt;21.3.1&lt;/a&gt;。 DAV &lt;a href=&quot;#section-21.3.2&quot;&gt;21.3.2&lt;/a&gt;。深度 &lt;a href=&quot;#section-21.3.3&quot;&gt;21.3.3&lt;/a&gt;。目的地 &lt;a href=&quot;#section-21.3.4&quot;&gt;21.3.4&lt;/a&gt;。如果 &lt;a href=&quot;#section-21.3.5&quot;&gt;21.3.5&lt;/a&gt;。锁令牌 &lt;a href=&quot;#section-21.3.6&quot;&gt;21.3.6&lt;/a&gt;。覆盖 &lt;a href=&quot;#section-21.3.7&quot;&gt;21.3.7&lt;/a&gt;。超时 &lt;a href=&quot;#section-21.4&quot;&gt;21.4&lt;/a&gt;。 HTTP状态代码 &lt;a href=&quot;#section-22&quot;&gt;22&lt;/a&gt;。致谢............................................................ &lt;a href=&quot;#section-23&quot;&gt;23&lt;/a&gt;。本规范的贡献者 &lt;a href=&quot;#section-24&quot;&gt;24&lt;/a&gt;。&lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518的&lt;/a&gt;作者&lt;a href=&quot;#section-25&quot;&gt;25&lt;/a&gt;。参考文献 &lt;a href=&quot;#section-25.1&quot;&gt;25.1&lt;/a&gt;。规范性引用文件 &lt;a href=&quot;#section-25.2&quot;&gt;25.2&lt;/a&gt;。资料性参考 &lt;a href=&quot;#appendix-A&quot;&gt;附录A&lt;/a&gt;。有关处理XML元素 &lt;a href=&quot;#appendix-A.1&quot;&gt;A.1的说明&lt;/a&gt;。关于空XML元素的注释 &lt;a href=&quot;#appendix-A.2&quot;&gt;A.2&lt;/a&gt;。关于非法XML处理的注释 &lt;a href=&quot;#appendix-A.3&quot;&gt;A.3&lt;/a&gt;。示例&lt;a href=&quot;#appendix-A.4&quot;&gt;-XML&lt;/a&gt;语法错误 A.4。实施例-意外的XML元素 &lt;a href=&quot;#appendix-B&quot;&gt;附录B&lt;/a&gt;。在HTTP客户端兼容性说明 &lt;a href=&quot;#appendix-C&quot;&gt;附录C&lt;/a&gt;。该&amp;ldquo;opaquelocktoken&amp;rdquo;计划和URI &lt;a href=&quot;#appendix-D&quot;&gt;附录d&lt;/a&gt;。空锁资源 &lt;a href=&quot;#appendix-D.1&quot;&gt;D.1&lt;/a&gt;。指导客户使用LOCK创建资源 &lt;a href=&quot;#appendix-E&quot;&gt;附录E&lt;/a&gt;。要求认证&lt;a href=&quot;#appendix-F&quot;&gt;附录F的&lt;/a&gt;客户指南 。&lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518 &lt;/a&gt;&lt;a href=&quot;#appendix-F.1&quot;&gt;F.1&lt;/a&gt;的变更摘要。客户端和服务器实现&lt;a href=&quot;#appendix-F.2&quot;&gt;F.2的&lt;/a&gt;更改 。服务器实现的更改 &lt;a href=&quot;#appendix-F.3&quot;&gt;F.3&lt;/a&gt;。其他更改....................................................</target>
        </trans-unit>
        <trans-unit id="5314ebdcf29205bc56fbbcaea0c60b012d05ccf0" translate="yes" xml:space="preserve">
          <source>Status of responses including a &lt;code&gt;Location&lt;/code&gt; header: &lt;a href=&quot;../status/201&quot;&gt;&lt;code&gt;201&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../status/301&quot;&gt;&lt;code&gt;301&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../status/302&quot;&gt;&lt;code&gt;302&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../status/303&quot;&gt;&lt;code&gt;303&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../status/307&quot;&gt;&lt;code&gt;307&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../status/308&quot;&gt;&lt;code&gt;308&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">的反应，包括一个状态 &lt;code&gt;Location&lt;/code&gt; 标头：&lt;a href=&quot;../status/201&quot;&gt; &lt;code&gt;201&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../status/301&quot;&gt; &lt;code&gt;301&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../status/302&quot;&gt; &lt;code&gt;302&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../status/303&quot;&gt; &lt;code&gt;303&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../status/307&quot;&gt; &lt;code&gt;307&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../status/308&quot;&gt; &lt;code&gt;308&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d856fa610b4491baa384c8f7803b6e1e2fc35cdc" translate="yes" xml:space="preserve">
          <source>Status of this Memo

   This document specifies an Internet standards track protocol for the
   Internet community, and requests discussion and suggestions for
   improvements.  Please refer to the current edition of the &quot;Internet
   Official Protocol Standards&quot; (STD 1) for the standardization state
   and status of this protocol.  Distribution of this memo is unlimited.

Copyright Notice

   Copyright (C) The Internet Society (1999).  All Rights Reserved.

Abstract

   The Hypertext Transfer Protocol (HTTP) is an application-level
   protocol for distributed, collaborative, hypermedia information
   systems. It is a generic, stateless, protocol which can be used for
   many tasks beyond its use for hypertext, such as name servers and
   distributed object management systems, through extension of its
   request methods, error codes and headers [&lt;a href=&quot;#ref-47&quot;&gt;47&lt;/a&gt;]. A feature of HTTP is
   the typing and negotiation of data representation, allowing systems
   to be built independently of the data being transferred.

   HTTP has been in use by the World-Wide Web global information
   initiative since 1990. This specification defines the protocol
   referred to as &quot;HTTP/1.1&quot;, and is an update to &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt; [&lt;a href=&quot;#ref-33&quot;&gt;33&lt;/a&gt;]. 

Table of Contents

   &lt;a href=&quot;#section-1&quot;&gt;1&lt;/a&gt;   Introduction 
   &lt;a href=&quot;#section-1.1&quot;&gt;1.1&lt;/a&gt;    Purpose
   &lt;a href=&quot;#section-1.2&quot;&gt;1.2&lt;/a&gt;   Requirements 
   &lt;a href=&quot;#section-1.3&quot;&gt;1.3&lt;/a&gt;   Terminology 
   &lt;a href=&quot;#section-1.4&quot;&gt;1.4&lt;/a&gt;   Overall Operation 
   &lt;a href=&quot;#section-2&quot;&gt;2&lt;/a&gt;   Notational Conventions and Generic Grammar 
   &lt;a href=&quot;#section-2.1&quot;&gt;2.1&lt;/a&gt;   Augmented BNF 
   &lt;a href=&quot;#section-2.2&quot;&gt;2.2&lt;/a&gt;   Basic Rules 
   &lt;a href=&quot;#section-3&quot;&gt;3&lt;/a&gt;   Protocol Parameters 
   &lt;a href=&quot;#section-3.1&quot;&gt;3.1&lt;/a&gt;   HTTP Version 
   &lt;a href=&quot;#section-3.2&quot;&gt;3.2&lt;/a&gt;   Uniform Resource Identifiers 
   &lt;a href=&quot;#section-3.2.1&quot;&gt;3.2.1&lt;/a&gt;    General Syntax 
   &lt;a href=&quot;#section-3.2.2&quot;&gt;3.2.2&lt;/a&gt;    http URL 
   &lt;a href=&quot;#section-3.2.3&quot;&gt;3.2.3&lt;/a&gt;    URI Comparison 
   &lt;a href=&quot;#section-3.3&quot;&gt;3.3&lt;/a&gt;   Date/Time Formats 
   &lt;a href=&quot;#section-3.3.1&quot;&gt;3.3.1&lt;/a&gt;    Full Date 
   &lt;a href=&quot;#section-3.3.2&quot;&gt;3.3.2&lt;/a&gt;    Delta Seconds 
   &lt;a href=&quot;#section-3.4&quot;&gt;3.4&lt;/a&gt;   Character Sets 
   &lt;a href=&quot;#section-3.4.1&quot;&gt;3.4.1&lt;/a&gt;    Missing Charset 
   &lt;a href=&quot;#section-3.5&quot;&gt;3.5&lt;/a&gt;   Content Codings 
   &lt;a href=&quot;#section-3.6&quot;&gt;3.6&lt;/a&gt;   Transfer Codings 
   &lt;a href=&quot;#section-3.6.1&quot;&gt;3.6.1&lt;/a&gt;    Chunked Transfer Coding 
   &lt;a href=&quot;#section-3.7&quot;&gt;3.7&lt;/a&gt;   Media Types 
   &lt;a href=&quot;#section-3.7.1&quot;&gt;3.7.1&lt;/a&gt;    Canonicalization and Text Defaults 
   &lt;a href=&quot;#section-3.7.2&quot;&gt;3.7.2&lt;/a&gt;    Multipart Types 
   &lt;a href=&quot;#section-3.8&quot;&gt;3.8&lt;/a&gt;   Product Tokens 
   &lt;a href=&quot;#section-3.9&quot;&gt;3.9&lt;/a&gt;   Quality Values 
   &lt;a href=&quot;#section-3.10&quot;&gt;3.10&lt;/a&gt;  Language Tags 
   &lt;a href=&quot;#section-3.11&quot;&gt;3.11&lt;/a&gt;  Entity Tags 
   &lt;a href=&quot;#section-3.12&quot;&gt;3.12&lt;/a&gt;  Range Units 
   &lt;a href=&quot;#section-4&quot;&gt;4&lt;/a&gt;   HTTP Message 
   &lt;a href=&quot;#section-4.1&quot;&gt;4.1&lt;/a&gt;   Message Types 
   &lt;a href=&quot;#section-4.2&quot;&gt;4.2&lt;/a&gt;   Message Headers 
   &lt;a href=&quot;#section-4.3&quot;&gt;4.3&lt;/a&gt;   Message Body 
   &lt;a href=&quot;#section-4.4&quot;&gt;4.4&lt;/a&gt;   Message Length 
   &lt;a href=&quot;#section-4.5&quot;&gt;4.5&lt;/a&gt;   General Header Fields 
   &lt;a href=&quot;#section-5&quot;&gt;5&lt;/a&gt;   Request 
   &lt;a href=&quot;#section-5.1&quot;&gt;5.1&lt;/a&gt;   Request-Line 
   &lt;a href=&quot;#section-5.1.1&quot;&gt;5.1.1&lt;/a&gt;    Method 
   &lt;a href=&quot;#section-5.1.2&quot;&gt;5.1.2&lt;/a&gt;    Request-URI 
   &lt;a href=&quot;#section-5.2&quot;&gt;5.2&lt;/a&gt;   The Resource Identified by a Request 
   &lt;a href=&quot;#section-5.3&quot;&gt;5.3&lt;/a&gt;   Request Header Fields 
   &lt;a href=&quot;#section-6&quot;&gt;6&lt;/a&gt;   Response 
   &lt;a href=&quot;#section-6.1&quot;&gt;6.1&lt;/a&gt;   Status-Line 
   &lt;a href=&quot;#section-6.1.1&quot;&gt;6.1.1&lt;/a&gt;    Status Code and Reason Phrase 
   &lt;a href=&quot;#section-6.2&quot;&gt;6.2&lt;/a&gt;   Response Header Fields ...................................... 

   &lt;a href=&quot;#section-7&quot;&gt;7&lt;/a&gt;   Entity 
   &lt;a href=&quot;#section-7.1&quot;&gt;7.1&lt;/a&gt;   Entity Header Fields 
   &lt;a href=&quot;#section-7.2&quot;&gt;7.2&lt;/a&gt;   Entity Body 
   &lt;a href=&quot;#section-7.2.1&quot;&gt;7.2.1&lt;/a&gt;    Type 
   &lt;a href=&quot;#section-7.2.2&quot;&gt;7.2.2&lt;/a&gt;    Entity Length 
   &lt;a href=&quot;#section-8&quot;&gt;8&lt;/a&gt;   Connections 
   &lt;a href=&quot;#section-8.1&quot;&gt;8.1&lt;/a&gt;   Persistent Connections 
   &lt;a href=&quot;#section-8.1.1&quot;&gt;8.1.1&lt;/a&gt;    Purpose 
   &lt;a href=&quot;#section-8.1.2&quot;&gt;8.1.2&lt;/a&gt;    Overall Operation 
   &lt;a href=&quot;#section-8.1.3&quot;&gt;8.1.3&lt;/a&gt;    Proxy Servers 
   &lt;a href=&quot;#section-8.1.4&quot;&gt;8.1.4&lt;/a&gt;    Practical Considerations 
   &lt;a href=&quot;#section-8.2&quot;&gt;8.2&lt;/a&gt;   Message Transmission Requirements 
   &lt;a href=&quot;#section-8.2.1&quot;&gt;8.2.1&lt;/a&gt;    Persistent Connections and Flow Control 
   &lt;a href=&quot;#section-8.2.2&quot;&gt;8.2.2&lt;/a&gt;    Monitoring Connections for Error Status Messages 
   &lt;a href=&quot;#section-8.2.3&quot;&gt;8.2.3&lt;/a&gt;    Use of the 100 (Continue) Status 
   &lt;a href=&quot;#section-8.2.4&quot;&gt;8.2.4&lt;/a&gt;    Client Behavior if Server Prematurely Closes Connection ..50
   &lt;a href=&quot;#section-9&quot;&gt;9&lt;/a&gt;   Method Definitions 
   &lt;a href=&quot;#section-9.1&quot;&gt;9.1&lt;/a&gt;   Safe and Idempotent Methods 
   &lt;a href=&quot;#section-9.1.1&quot;&gt;9.1.1&lt;/a&gt;    Safe Methods 
   &lt;a href=&quot;#section-9.1.2&quot;&gt;9.1.2&lt;/a&gt;    Idempotent Methods 
   &lt;a href=&quot;#section-9.2&quot;&gt;9.2&lt;/a&gt;   OPTIONS 
   &lt;a href=&quot;#section-9.3&quot;&gt;9.3&lt;/a&gt;   GET 
   &lt;a href=&quot;#section-9.4&quot;&gt;9.4&lt;/a&gt;   HEAD 
   &lt;a href=&quot;#section-9.5&quot;&gt;9.5&lt;/a&gt;   POST 
   &lt;a href=&quot;#section-9.6&quot;&gt;9.6&lt;/a&gt;   PUT 
   &lt;a href=&quot;#section-9.7&quot;&gt;9.7&lt;/a&gt;   DELETE 
   &lt;a href=&quot;#section-9.8&quot;&gt;9.8&lt;/a&gt;   TRACE 
   &lt;a href=&quot;#section-9.9&quot;&gt;9.9&lt;/a&gt;   CONNECT 
   &lt;a href=&quot;#section-10&quot;&gt;10&lt;/a&gt;   Status Code Definitions 
   &lt;a href=&quot;#section-10.1&quot;&gt;10.1&lt;/a&gt;  Informational 1xx 
   &lt;a href=&quot;#section-10.1.1&quot;&gt;10.1.1&lt;/a&gt;   100 Continue 
   &lt;a href=&quot;#section-10.1.2&quot;&gt;10.1.2&lt;/a&gt;   101 Switching Protocols 
   &lt;a href=&quot;#section-10.2&quot;&gt;10.2&lt;/a&gt;  Successful 2xx 
   &lt;a href=&quot;#section-10.2.1&quot;&gt;10.2.1&lt;/a&gt;   200 OK 
   &lt;a href=&quot;#section-10.2.2&quot;&gt;10.2.2&lt;/a&gt;   201 Created 
   &lt;a href=&quot;#section-10.2.3&quot;&gt;10.2.3&lt;/a&gt;   202 Accepted 
   &lt;a href=&quot;#section-10.2.4&quot;&gt;10.2.4&lt;/a&gt;   203 Non-Authoritative Information 
   &lt;a href=&quot;#section-10.2.5&quot;&gt;10.2.5&lt;/a&gt;   204 No Content 
   &lt;a href=&quot;#section-10.2.6&quot;&gt;10.2.6&lt;/a&gt;   205 Reset Content 
   &lt;a href=&quot;#section-10.2.7&quot;&gt;10.2.7&lt;/a&gt;   206 Partial Content 
   &lt;a href=&quot;#section-10.3&quot;&gt;10.3&lt;/a&gt;  Redirection 3xx 
   &lt;a href=&quot;#section-10.3.1&quot;&gt;10.3.1&lt;/a&gt;   300 Multiple Choices 
   &lt;a href=&quot;#section-10.3.2&quot;&gt;10.3.2&lt;/a&gt;   301 Moved Permanently 
   &lt;a href=&quot;#section-10.3.3&quot;&gt;10.3.3&lt;/a&gt;   302 Found 
   &lt;a href=&quot;#section-10.3.4&quot;&gt;10.3.4&lt;/a&gt;   303 See Other 
   &lt;a href=&quot;#section-10.3.5&quot;&gt;10.3.5&lt;/a&gt;   304 Not Modified 
   &lt;a href=&quot;#section-10.3.6&quot;&gt;10.3.6&lt;/a&gt;   305 Use Proxy 
   &lt;a href=&quot;#section-10.3.7&quot;&gt;10.3.7&lt;/a&gt;   306 (Unused) ............................................. 

   &lt;a href=&quot;#section-10.3.8&quot;&gt;10.3.8&lt;/a&gt;   307 Temporary Redirect 
   &lt;a href=&quot;#section-10.4&quot;&gt;10.4&lt;/a&gt;  Client Error 4xx 
   &lt;a href=&quot;#section-10.4.1&quot;&gt;10.4.1&lt;/a&gt;    400 Bad Request 
   &lt;a href=&quot;#section-10.4.2&quot;&gt;10.4.2&lt;/a&gt;    401 Unauthorized 
   &lt;a href=&quot;#section-10.4.3&quot;&gt;10.4.3&lt;/a&gt;    402 Payment Required 
   &lt;a href=&quot;#section-10.4.4&quot;&gt;10.4.4&lt;/a&gt;    403 Forbidden 
   &lt;a href=&quot;#section-10.4.5&quot;&gt;10.4.5&lt;/a&gt;    404 Not Found 
   &lt;a href=&quot;#section-10.4.6&quot;&gt;10.4.6&lt;/a&gt;    405 Method Not Allowed 
   &lt;a href=&quot;#section-10.4.7&quot;&gt;10.4.7&lt;/a&gt;    406 Not Acceptable 
   &lt;a href=&quot;#section-10.4.8&quot;&gt;10.4.8&lt;/a&gt;    407 Proxy Authentication Required 
   &lt;a href=&quot;#section-10.4.9&quot;&gt;10.4.9&lt;/a&gt;    408 Request Timeout 
   &lt;a href=&quot;#section-10.4.10&quot;&gt;10.4.10&lt;/a&gt;   409 Conflict 
   &lt;a href=&quot;#section-10.4.11&quot;&gt;10.4.11&lt;/a&gt;   410 Gone 
   &lt;a href=&quot;#section-10.4.12&quot;&gt;10.4.12&lt;/a&gt;   411 Length Required 
   &lt;a href=&quot;#section-10.4.13&quot;&gt;10.4.13&lt;/a&gt;   412 Precondition Failed 
   &lt;a href=&quot;#section-10.4.14&quot;&gt;10.4.14&lt;/a&gt;   413 Request Entity Too Large 
   &lt;a href=&quot;#section-10.4.15&quot;&gt;10.4.15&lt;/a&gt;   414 Request-URI Too Long 
   &lt;a href=&quot;#section-10.4.16&quot;&gt;10.4.16&lt;/a&gt;   415 Unsupported Media Type 
   &lt;a href=&quot;#section-10.4.17&quot;&gt;10.4.17&lt;/a&gt;   416 Requested Range Not Satisfiable 
   &lt;a href=&quot;#section-10.4.18&quot;&gt;10.4.18&lt;/a&gt;   417 Expectation Failed 
   &lt;a href=&quot;#section-10.5&quot;&gt;10.5&lt;/a&gt;  Server Error 5xx 
   &lt;a href=&quot;#section-10.5.1&quot;&gt;10.5.1&lt;/a&gt;   500 Internal Server Error 
   &lt;a href=&quot;#section-10.5.2&quot;&gt;10.5.2&lt;/a&gt;   501 Not Implemented 
   &lt;a href=&quot;#section-10.5.3&quot;&gt;10.5.3&lt;/a&gt;   502 Bad Gateway 
   &lt;a href=&quot;#section-10.5.4&quot;&gt;10.5.4&lt;/a&gt;   503 Service Unavailable 
   &lt;a href=&quot;#section-10.5.5&quot;&gt;10.5.5&lt;/a&gt;   504 Gateway Timeout 
   &lt;a href=&quot;#section-10.5.6&quot;&gt;10.5.6&lt;/a&gt;   505 HTTP Version Not Supported 
   &lt;a href=&quot;#section-11&quot;&gt;11&lt;/a&gt;   Access Authentication 
   &lt;a href=&quot;#section-12&quot;&gt;12&lt;/a&gt;   Content Negotiation 
   &lt;a href=&quot;#section-12.1&quot;&gt;12.1&lt;/a&gt;  Server-driven Negotiation 
   &lt;a href=&quot;#section-12.2&quot;&gt;12.2&lt;/a&gt;  Agent-driven Negotiation 
   &lt;a href=&quot;#section-12.3&quot;&gt;12.3&lt;/a&gt;  Transparent Negotiation 
   &lt;a href=&quot;#section-13&quot;&gt;13&lt;/a&gt;   Caching in HTTP 
   &lt;a href=&quot;#section-13.1.1&quot;&gt;13.1.1&lt;/a&gt;   Cache Correctness 
   &lt;a href=&quot;#section-13.1.2&quot;&gt;13.1.2&lt;/a&gt;   Warnings 
   &lt;a href=&quot;#section-13.1.3&quot;&gt;13.1.3&lt;/a&gt;   Cache-control Mechanisms 
   &lt;a href=&quot;#section-13.1.4&quot;&gt;13.1.4&lt;/a&gt;   Explicit User Agent Warnings 
   &lt;a href=&quot;#section-13.1.5&quot;&gt;13.1.5&lt;/a&gt;   Exceptions to the Rules and Warnings 
   &lt;a href=&quot;#section-13.1.6&quot;&gt;13.1.6&lt;/a&gt;   Client-controlled Behavior 
   &lt;a href=&quot;#section-13.2&quot;&gt;13.2&lt;/a&gt;  Expiration Model 
   &lt;a href=&quot;#section-13.2.1&quot;&gt;13.2.1&lt;/a&gt;   Server-Specified Expiration 
   &lt;a href=&quot;#section-13.2.2&quot;&gt;13.2.2&lt;/a&gt;   Heuristic Expiration 
   &lt;a href=&quot;#section-13.2.3&quot;&gt;13.2.3&lt;/a&gt;   Age Calculations 
   &lt;a href=&quot;#section-13.2.4&quot;&gt;13.2.4&lt;/a&gt;   Expiration Calculations 
   &lt;a href=&quot;#section-13.2.5&quot;&gt;13.2.5&lt;/a&gt;   Disambiguating Expiration Values 
   &lt;a href=&quot;#section-13.2.6&quot;&gt;13.2.6&lt;/a&gt;   Disambiguating Multiple Responses 
   &lt;a href=&quot;#section-13.3&quot;&gt;13.3&lt;/a&gt;  Validation Model 
   &lt;a href=&quot;#section-13.3.1&quot;&gt;13.3.1&lt;/a&gt;   Last-Modified Dates ...................................... 

   &lt;a href=&quot;#section-13.3.2&quot;&gt;13.3.2&lt;/a&gt;   Entity Tag Cache Validators 
   &lt;a href=&quot;#section-13.3.3&quot;&gt;13.3.3&lt;/a&gt;   Weak and Strong Validators 
   13.3.4   Rules for When to Use Entity Tags and Last-Modified Dates.89
   &lt;a href=&quot;#section-13.3.5&quot;&gt;13.3.5&lt;/a&gt;   Non-validating Conditionals 
   &lt;a href=&quot;#section-13.4&quot;&gt;13.4&lt;/a&gt;  Response Cacheability 
   &lt;a href=&quot;#section-13.5&quot;&gt;13.5&lt;/a&gt;  Constructing Responses From Caches 
   &lt;a href=&quot;#section-13.5.1&quot;&gt;13.5.1&lt;/a&gt;   End-to-end and Hop-by-hop Headers 
   &lt;a href=&quot;#section-13.5.2&quot;&gt;13.5.2&lt;/a&gt;   Non-modifiable Headers 
   &lt;a href=&quot;#section-13.5.3&quot;&gt;13.5.3&lt;/a&gt;   Combining Headers 
   &lt;a href=&quot;#section-13.5.4&quot;&gt;13.5.4&lt;/a&gt;   Combining Byte Ranges 
   &lt;a href=&quot;#section-13.6&quot;&gt;13.6&lt;/a&gt;  Caching Negotiated Responses 
   &lt;a href=&quot;#section-13.7&quot;&gt;13.7&lt;/a&gt;  Shared and Non-Shared Caches 
   &lt;a href=&quot;#section-13.8&quot;&gt;13.8&lt;/a&gt;  Errors or Incomplete Response Cache Behavior 
   &lt;a href=&quot;#section-13.9&quot;&gt;13.9&lt;/a&gt;  Side Effects of GET and HEAD 
   &lt;a href=&quot;#section-13.10&quot;&gt;13.10&lt;/a&gt;   Invalidation After Updates or Deletions 
   &lt;a href=&quot;#section-13.11&quot;&gt;13.11&lt;/a&gt;   Write-Through Mandatory 
   &lt;a href=&quot;#section-13.12&quot;&gt;13.12&lt;/a&gt;   Cache Replacement 
   &lt;a href=&quot;#section-13.13&quot;&gt;13.13&lt;/a&gt;   History Lists 
   &lt;a href=&quot;#section-14&quot;&gt;14&lt;/a&gt;   Header Field Definitions 
   &lt;a href=&quot;#section-14.1&quot;&gt;14.1&lt;/a&gt;  Accept 
   &lt;a href=&quot;#section-14.2&quot;&gt;14.2&lt;/a&gt;  Accept-Charset 
   &lt;a href=&quot;#section-14.3&quot;&gt;14.3&lt;/a&gt;  Accept-Encoding 
   &lt;a href=&quot;#section-14.4&quot;&gt;14.4&lt;/a&gt;  Accept-Language 
   &lt;a href=&quot;#section-14.5&quot;&gt;14.5&lt;/a&gt;  Accept-Ranges 
   &lt;a href=&quot;#section-14.6&quot;&gt;14.6&lt;/a&gt;  Age 
   &lt;a href=&quot;#section-14.7&quot;&gt;14.7&lt;/a&gt;  Allow 
   &lt;a href=&quot;#section-14.8&quot;&gt;14.8&lt;/a&gt;  Authorization 
   &lt;a href=&quot;#section-14.9&quot;&gt;14.9&lt;/a&gt;  Cache-Control 
   &lt;a href=&quot;#section-14.9.1&quot;&gt;14.9.1&lt;/a&gt;   What is Cacheable 
   &lt;a href=&quot;#section-14.9.2&quot;&gt;14.9.2&lt;/a&gt;   What May be Stored by Caches 
   &lt;a href=&quot;#section-14.9.3&quot;&gt;14.9.3&lt;/a&gt;   Modifications of the Basic Expiration Mechanism 
   &lt;a href=&quot;#section-14.9.4&quot;&gt;14.9.4&lt;/a&gt;   Cache Revalidation and Reload Controls 
   &lt;a href=&quot;#section-14.9.5&quot;&gt;14.9.5&lt;/a&gt;   No-Transform Directive 
   &lt;a href=&quot;#section-14.9.6&quot;&gt;14.9.6&lt;/a&gt;   Cache Control Extensions 
   &lt;a href=&quot;#section-14.10&quot;&gt;14.10&lt;/a&gt;   Connection 
   &lt;a href=&quot;#section-14.11&quot;&gt;14.11&lt;/a&gt;   Content-Encoding 
   &lt;a href=&quot;#section-14.12&quot;&gt;14.12&lt;/a&gt;   Content-Language 
   &lt;a href=&quot;#section-14.13&quot;&gt;14.13&lt;/a&gt;   Content-Length 
   &lt;a href=&quot;#section-14.14&quot;&gt;14.14&lt;/a&gt;   Content-Location 
   &lt;a href=&quot;#section-14.15&quot;&gt;14.15&lt;/a&gt;   Content-MD5 
   &lt;a href=&quot;#section-14.16&quot;&gt;14.16&lt;/a&gt;   Content-Range 
   &lt;a href=&quot;#section-14.17&quot;&gt;14.17&lt;/a&gt;   Content-Type 
   &lt;a href=&quot;#section-14.18&quot;&gt;14.18&lt;/a&gt;   Date 
   &lt;a href=&quot;#section-14.18.1&quot;&gt;14.18.1&lt;/a&gt;   Clockless Origin Server Operation 
   &lt;a href=&quot;#section-14.19&quot;&gt;14.19&lt;/a&gt;   ETag 
   &lt;a href=&quot;#section-14.20&quot;&gt;14.20&lt;/a&gt;   Expect 
   &lt;a href=&quot;#section-14.21&quot;&gt;14.21&lt;/a&gt;   Expires 
   &lt;a href=&quot;#section-14.22&quot;&gt;14.22&lt;/a&gt;   From ..................................................... 

   &lt;a href=&quot;#section-14.23&quot;&gt;14.23&lt;/a&gt;   Host 
   &lt;a href=&quot;#section-14.24&quot;&gt;14.24&lt;/a&gt;   If-Match 
   &lt;a href=&quot;#section-14.25&quot;&gt;14.25&lt;/a&gt;   If-Modified-Since 
   &lt;a href=&quot;#section-14.26&quot;&gt;14.26&lt;/a&gt;   If-None-Match 
   &lt;a href=&quot;#section-14.27&quot;&gt;14.27&lt;/a&gt;   If-Range 
   &lt;a href=&quot;#section-14.28&quot;&gt;14.28&lt;/a&gt;   If-Unmodified-Since 
   &lt;a href=&quot;#section-14.29&quot;&gt;14.29&lt;/a&gt;   Last-Modified 
   &lt;a href=&quot;#section-14.30&quot;&gt;14.30&lt;/a&gt;   Location 
   &lt;a href=&quot;#section-14.31&quot;&gt;14.31&lt;/a&gt;   Max-Forwards 
   &lt;a href=&quot;#section-14.32&quot;&gt;14.32&lt;/a&gt;   Pragma 
   &lt;a href=&quot;#section-14.33&quot;&gt;14.33&lt;/a&gt;   Proxy-Authenticate 
   &lt;a href=&quot;#section-14.34&quot;&gt;14.34&lt;/a&gt;   Proxy-Authorization 
   &lt;a href=&quot;#section-14.35&quot;&gt;14.35&lt;/a&gt;   Range 
   &lt;a href=&quot;#section-14.35.1&quot;&gt;14.35.1&lt;/a&gt;    Byte Ranges 
   &lt;a href=&quot;#section-14.35.2&quot;&gt;14.35.2&lt;/a&gt;    Range Retrieval Requests 
   &lt;a href=&quot;#section-14.36&quot;&gt;14.36&lt;/a&gt;   Referer 
   &lt;a href=&quot;#section-14.37&quot;&gt;14.37&lt;/a&gt;   Retry-After 
   &lt;a href=&quot;#section-14.38&quot;&gt;14.38&lt;/a&gt;   Server 
   &lt;a href=&quot;#section-14.39&quot;&gt;14.39&lt;/a&gt;   TE 
   &lt;a href=&quot;#section-14.40&quot;&gt;14.40&lt;/a&gt;   Trailer 
   &lt;a href=&quot;#section-14.41&quot;&gt;14.41&lt;/a&gt;  Transfer-Encoding
   &lt;a href=&quot;#section-14.42&quot;&gt;14.42&lt;/a&gt;   Upgrade 
   &lt;a href=&quot;#section-14.43&quot;&gt;14.43&lt;/a&gt;   User-Agent 
   &lt;a href=&quot;#section-14.44&quot;&gt;14.44&lt;/a&gt;   Vary 
   &lt;a href=&quot;#section-14.45&quot;&gt;14.45&lt;/a&gt;   Via 
   &lt;a href=&quot;#section-14.46&quot;&gt;14.46&lt;/a&gt;   Warning 
   &lt;a href=&quot;#section-14.47&quot;&gt;14.47&lt;/a&gt;   WWW-Authenticate 
   &lt;a href=&quot;#section-15&quot;&gt;15&lt;/a&gt; Security Considerations 
   &lt;a href=&quot;#section-15.1&quot;&gt;15.1&lt;/a&gt;      Personal Information
   &lt;a href=&quot;#section-15.1.1&quot;&gt;15.1.1&lt;/a&gt;   Abuse of Server Log Information 
   &lt;a href=&quot;#section-15.1.2&quot;&gt;15.1.2&lt;/a&gt;   Transfer of Sensitive Information 
   &lt;a href=&quot;#section-15.1.3&quot;&gt;15.1.3&lt;/a&gt;   Encoding Sensitive Information in URI's 
   &lt;a href=&quot;#section-15.1.4&quot;&gt;15.1.4&lt;/a&gt;   Privacy Issues Connected to Accept Headers 
   &lt;a href=&quot;#section-15.2&quot;&gt;15.2&lt;/a&gt;  Attacks Based On File and Path Names 
   &lt;a href=&quot;#section-15.3&quot;&gt;15.3&lt;/a&gt;  DNS Spoofing 
   &lt;a href=&quot;#section-15.4&quot;&gt;15.4&lt;/a&gt;  Location Headers and Spoofing 
   &lt;a href=&quot;#section-15.5&quot;&gt;15.5&lt;/a&gt;  Content-Disposition Issues 
   &lt;a href=&quot;#section-15.6&quot;&gt;15.6&lt;/a&gt;  Authentication Credentials and Idle Clients 
   &lt;a href=&quot;#section-15.7&quot;&gt;15.7&lt;/a&gt;  Proxies and Caching 
   &lt;a href=&quot;#section-15.7.1&quot;&gt;15.7.1&lt;/a&gt;    Denial of Service Attacks on Proxies
   &lt;a href=&quot;#section-16&quot;&gt;16&lt;/a&gt;   Acknowledgments 
   &lt;a href=&quot;#section-17&quot;&gt;17&lt;/a&gt;   References 
   &lt;a href=&quot;#section-18&quot;&gt;18&lt;/a&gt;   Authors' Addresses 
   &lt;a href=&quot;#section-19&quot;&gt;19&lt;/a&gt;   Appendices 
   &lt;a href=&quot;#section-19.1&quot;&gt;19.1&lt;/a&gt;  Internet Media Type message/http and application/http 
   &lt;a href=&quot;#section-19.2&quot;&gt;19.2&lt;/a&gt;  Internet Media Type multipart/byteranges 
   &lt;a href=&quot;#section-19.3&quot;&gt;19.3&lt;/a&gt;  Tolerant Applications 
   &lt;a href=&quot;#section-19.4&quot;&gt;19.4&lt;/a&gt;  Differences Between HTTP Entities and &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC 2045&lt;/a&gt; Entities .... 

   &lt;a href=&quot;#section-19.4.1&quot;&gt;19.4.1&lt;/a&gt;   MIME-Version 
   &lt;a href=&quot;#section-19.4.2&quot;&gt;19.4.2&lt;/a&gt;   Conversion to Canonical Form 
   &lt;a href=&quot;#section-19.4.3&quot;&gt;19.4.3&lt;/a&gt;   Conversion of Date Formats 
   &lt;a href=&quot;#section-19.4.4&quot;&gt;19.4.4&lt;/a&gt;   Introduction of Content-Encoding 
   &lt;a href=&quot;#section-19.4.5&quot;&gt;19.4.5&lt;/a&gt;   No Content-Transfer-Encoding 
   &lt;a href=&quot;#section-19.4.6&quot;&gt;19.4.6&lt;/a&gt;   Introduction of Transfer-Encoding 
   &lt;a href=&quot;#section-19.4.7&quot;&gt;19.4.7&lt;/a&gt;   MHTML and Line Length Limitations 
   &lt;a href=&quot;#section-19.5&quot;&gt;19.5&lt;/a&gt;  Additional Features 
   &lt;a href=&quot;#section-19.5.1&quot;&gt;19.5.1&lt;/a&gt;   Content-Disposition 
   &lt;a href=&quot;#section-19.6&quot;&gt;19.6&lt;/a&gt;  Compatibility with Previous Versions 
   &lt;a href=&quot;#section-19.6.1&quot;&gt;19.6.1&lt;/a&gt;   Changes from HTTP/1.0 
   &lt;a href=&quot;#section-19.6.2&quot;&gt;19.6.2&lt;/a&gt;   Compatibility with HTTP/1.0 Persistent Connections 
   &lt;a href=&quot;#section-19.6.3&quot;&gt;19.6.3&lt;/a&gt;   Changes from &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt;&lt;a href=&quot;#section-20&quot;&gt;20&lt;/a&gt;   Index 
   &lt;a href=&quot;#section-21&quot;&gt;21&lt;/a&gt;   Full Copyright Statement</source>
          <target state="translated">本备忘录的状态本文档指定了Internet社区的Internet标准跟踪协议，并要求讨论和提出改进建议。请参阅当前版本的&amp;ldquo; Internet官方协议标准&amp;rdquo;（STD 1）了解此协议的标准化状态。该备忘录的分发是无限的。版权声明版权所有（C）互联网协会（1999）。版权所有。摘要超文本传输​​协议（HTTP）是分布式，协作，超媒体信息系统的应用程序级协议。它是一种通用的无状态协议，通过扩展其请求方法，它可以用于超文本之外的许多任务，例如名称服务器和分布式对象管理系统。错误代码和标头[&lt;a href=&quot;#ref-47&quot;&gt;47&lt;/a&gt; ]。 HTTP的一个功能是数据表示的键入和协商，允许独立于要传输的数据来构建系统。自1990年以来，HTTP已由全球Web全球信息倡议使用。此规范定义了称为&amp;ldquo; HTTP / 1.1&amp;rdquo;的协议，并且是&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt; [ &lt;a href=&quot;#ref-33&quot;&gt;33&lt;/a&gt; ] 的更新。目录 &lt;a href=&quot;#section-1&quot;&gt;1&lt;/a&gt; 简介 &lt;a href=&quot;#section-1.1&quot;&gt;1.1&lt;/a&gt; 目的 &lt;a href=&quot;#section-1.2&quot;&gt;1.2&lt;/a&gt; 要求 &lt;a href=&quot;#section-1.3&quot;&gt;1.3&lt;/a&gt; 术语 &lt;a href=&quot;#section-1.4&quot;&gt;1.4&lt;/a&gt; 总体操作 &lt;a href=&quot;#section-2&quot;&gt;2&lt;/a&gt; 符号约定和通用语法 &lt;a href=&quot;#section-2.1&quot;&gt;2.1&lt;/a&gt; 增强的BNF &lt;a href=&quot;#section-2.2&quot;&gt;2.2&lt;/a&gt; 基本规则 &lt;a href=&quot;#section-3&quot;&gt;3&lt;/a&gt; 协议参数 &lt;a href=&quot;#section-3.1&quot;&gt;3.1&lt;/a&gt; HTTP版本 &lt;a href=&quot;#section-3.2&quot;&gt;3.2&lt;/a&gt; 统一资源标识符 &lt;a href=&quot;#section-3.2.1&quot;&gt;3.2.1&lt;/a&gt; 常规语法 &lt;a href=&quot;#section-3.2.2&quot;&gt;3.2.2&lt;/a&gt; HTTP URL &lt;a href=&quot;#section-3.2.3&quot;&gt;3.2.3&lt;/a&gt; URI比较 &lt;a href=&quot;#section-3.3&quot;&gt;3.3&lt;/a&gt; 日期/时间格式 &lt;a href=&quot;#section-3.3.1&quot;&gt;3.3.1&lt;/a&gt; 完整日期 &lt;a href=&quot;#section-3.3.2&quot;&gt;3.3.2&lt;/a&gt; 三角洲秒 &lt;a href=&quot;#section-3.4&quot;&gt;3.4&lt;/a&gt; 字符集 &lt;a href=&quot;#section-3.4.1&quot;&gt;3.4.1&lt;/a&gt; 缺少字符集 &lt;a href=&quot;#section-3.5&quot;&gt;3.5&lt;/a&gt; 内容 编码&lt;a href=&quot;#section-3.6&quot;&gt;3.6&lt;/a&gt; 传输 编码&lt;a href=&quot;#section-3.6.1&quot;&gt;3.6.1分&lt;/a&gt;块传输编码 &lt;a href=&quot;#section-3.7&quot;&gt;3.7&lt;/a&gt; 媒体类型 &lt;a href=&quot;#section-3.7.1&quot;&gt;3.7.1&lt;/a&gt; 规范化和文本默认值 &lt;a href=&quot;#section-3.7.2&quot;&gt;3.7.2&lt;/a&gt; 多部分类型 &lt;a href=&quot;#section-3.8&quot;&gt;3.8&lt;/a&gt; 产品令牌 &lt;a href=&quot;#section-3.9&quot;&gt;3.9&lt;/a&gt; 质量值 &lt;a href=&quot;#section-3.10&quot;&gt;3.10&lt;/a&gt; 语言标签 &lt;a href=&quot;#section-3.11&quot;&gt;3.11&lt;/a&gt; 实体标签 &lt;a href=&quot;#section-3.12&quot;&gt;3.12&lt;/a&gt; 范围单位 &lt;a href=&quot;#section-4&quot;&gt;4&lt;/a&gt; HTTP消息 &lt;a href=&quot;#section-4.1&quot;&gt;4.1&lt;/a&gt; 消息类型 &lt;a href=&quot;#section-4.2&quot;&gt;4.2&lt;/a&gt; 消息标题 &lt;a href=&quot;#section-4.3&quot;&gt;4.3&lt;/a&gt; 消息正文 &lt;a href=&quot;#section-4.4&quot;&gt;4.4&lt;/a&gt; 消息长度 &lt;a href=&quot;#section-4.5&quot;&gt;4.5&lt;/a&gt; 常规标题字段 &lt;a href=&quot;#section-5&quot;&gt;5&lt;/a&gt; 请求 &lt;a href=&quot;#section-5.1&quot;&gt;5.1&lt;/a&gt; 请求行 &lt;a href=&quot;#section-5.1.1&quot;&gt;5.1 .1&lt;/a&gt; 方法 &lt;a href=&quot;#section-5.1.2&quot;&gt;5.1.2&lt;/a&gt; Request-URI &lt;a href=&quot;#section-5.2&quot;&gt;5.2&lt;/a&gt; 请求标识的资源 &lt;a href=&quot;#section-5.3&quot;&gt;5.3&lt;/a&gt; 请求标题字段 &lt;a href=&quot;#section-6&quot;&gt;6&lt;/a&gt; 响应 &lt;a href=&quot;#section-6.1&quot;&gt;6.1&lt;/a&gt; 状态行 &lt;a href=&quot;#section-6.1.1&quot;&gt;6.1.1&lt;/a&gt; 状态代码和原因短语 &lt;a href=&quot;#section-6.2&quot;&gt;6.2&lt;/a&gt; 响应标题字段..................... ................. &lt;a href=&quot;#section-7&quot;&gt;7&lt;/a&gt; 实体 &lt;a href=&quot;#section-7.1&quot;&gt;7.1&lt;/a&gt; 实体头字段 &lt;a href=&quot;#section-7.2&quot;&gt;7.2&lt;/a&gt; 实体主体 &lt;a href=&quot;#section-7.2.1&quot;&gt;7.2.1&lt;/a&gt; 类型 &lt;a href=&quot;#section-7.2.2&quot;&gt;7.2.2&lt;/a&gt; 实体长度 &lt;a href=&quot;#section-8&quot;&gt;8&lt;/a&gt; 连接 &lt;a href=&quot;#section-8.1&quot;&gt;8.1&lt;/a&gt; 持久连接 &lt;a href=&quot;#section-8.1.1&quot;&gt;8.1.1&lt;/a&gt; 目的 &lt;a href=&quot;#section-8.1.2&quot;&gt;8.1.2&lt;/a&gt; 总体操作 &lt;a href=&quot;#section-8.1.3&quot;&gt;8.1 .3&lt;/a&gt; 代理服务器 &lt;a href=&quot;#section-8.1.4&quot;&gt;8.1.4&lt;/a&gt; 实际考虑因素 &lt;a href=&quot;#section-8.2&quot;&gt;8.2&lt;/a&gt; 消息传输要求 &lt;a href=&quot;#section-8.2.1&quot;&gt;8.2.1&lt;/a&gt; 持久连接和流控制 &lt;a href=&quot;#section-8.2.2&quot;&gt;8.2.2&lt;/a&gt; 监视错误状态消息的连接 &lt;a href=&quot;#section-8.2.3&quot;&gt;8.2.3&lt;/a&gt; 使用100（继续）状态 &lt;a href=&quot;#section-8.2.4&quot;&gt;8.2.4&lt;/a&gt; 如果服务器过早关闭连接，则客户端行为。 .50 &lt;a href=&quot;#section-9&quot;&gt;9&lt;/a&gt; 方法定义 &lt;a href=&quot;#section-9.1&quot;&gt;9.1&lt;/a&gt; 安全和幂等方法 &lt;a href=&quot;#section-9.1.1&quot;&gt;9.1.1&lt;/a&gt; 安全方法 &lt;a href=&quot;#section-9.1.2&quot;&gt;9.1.2&lt;/a&gt; 幂等方法 &lt;a href=&quot;#section-9.2&quot;&gt;9.2&lt;/a&gt; 选项 &lt;a href=&quot;#section-9.3&quot;&gt;9.3&lt;/a&gt; 获取 &lt;a href=&quot;#section-9.4&quot;&gt;9.4&lt;/a&gt; HEAD &lt;a href=&quot;#section-9.5&quot;&gt;9.5&lt;/a&gt; POST &lt;a href=&quot;#section-9.6&quot;&gt;9.6&lt;/a&gt; PUT &lt;a href=&quot;#section-9.7&quot;&gt;9.7&lt;/a&gt; DELETE &lt;a href=&quot;#section-9.8&quot;&gt;9.8&lt;/a&gt; TRACE &lt;a href=&quot;#section-9.9&quot;&gt;9.9&lt;/a&gt; CONNECT &lt;a href=&quot;#section-10&quot;&gt;10个&lt;/a&gt; 状态代码定义 &lt;a href=&quot;#section-10.1&quot;&gt;10.1&lt;/a&gt; 信息化1XX &lt;a href=&quot;#section-10.1.1&quot;&gt;10.1.1&lt;/a&gt; 100继续 &lt;a href=&quot;#section-10.1.2&quot;&gt;10.1.2&lt;/a&gt; 101切换协议 &lt;a href=&quot;#section-10.2&quot;&gt;10.2&lt;/a&gt; 成功的2xx &lt;a href=&quot;#section-10.2.1&quot;&gt;10.2.1&lt;/a&gt; 200 OK &lt;a href=&quot;#section-10.2.2&quot;&gt;10.2.2&lt;/a&gt; 201创建 &lt;a href=&quot;#section-10.2.3&quot;&gt;10.2.3&lt;/a&gt; 202接受 &lt;a href=&quot;#section-10.2.4&quot;&gt;10.2.4&lt;/a&gt; 203非权威信息 &lt;a href=&quot;#section-10.2.5&quot;&gt;10.2.5&lt;/a&gt; 204无内容 &lt;a href=&quot;#section-10.2.6&quot;&gt;10.2.6&lt;/a&gt; 205重置内容 &lt;a href=&quot;#section-10.2.7&quot;&gt;10.2.7&lt;/a&gt; 206部分内容 &lt;a href=&quot;#section-10.3&quot;&gt;10.3&lt;/a&gt; 重定向3xx &lt;a href=&quot;#section-10.3.1&quot;&gt;10.3.1&lt;/a&gt; 300多个选择 &lt;a href=&quot;#section-10.3.2&quot;&gt;10.3.2&lt;/a&gt; 301永久移动 &lt;a href=&quot;#section-10.3.3&quot;&gt;10.3.3&lt;/a&gt; 302找到 &lt;a href=&quot;#section-10.3.4&quot;&gt;10.3.4&lt;/a&gt; 303请参阅其他 &lt;a href=&quot;#section-10.3.5&quot;&gt;10.3.5&lt;/a&gt; 304未修改 &lt;a href=&quot;#section-10.3.6&quot;&gt;10.3.6&lt;/a&gt; 305使用代理 &lt;a href=&quot;#section-10.3.7&quot;&gt;10.3.7&lt;/a&gt; 306（未使用）.. .................................................... &lt;a href=&quot;#section-10.3.8&quot;&gt;10.3.8&lt;/a&gt; 307临时重定向 &lt;a href=&quot;#section-10.4&quot;&gt;10.4&lt;/a&gt; 客户端错误4xx &lt;a href=&quot;#section-10.4.1&quot;&gt;10.4.1&lt;/a&gt; 400错误的请求 &lt;a href=&quot;#section-10.4.2&quot;&gt;10.4.2&lt;/a&gt; 401未经授权的 &lt;a href=&quot;#section-10.4.3&quot;&gt;10.4.3&lt;/a&gt; 402需要付款 &lt;a href=&quot;#section-10.4.4&quot;&gt;10.4.4&lt;/a&gt; 403禁止 &lt;a href=&quot;#section-10.4.5&quot;&gt;10.4.5&lt;/a&gt; 404未找到 &lt;a href=&quot;#section-10.4.6&quot;&gt;10.4.6&lt;/a&gt; 405方法不允许 &lt;a href=&quot;#section-10.4.7&quot;&gt;10.4.7&lt;/a&gt; 406不可接受 &lt;a href=&quot;#section-10.4.8&quot;&gt;10.4.8&lt;/a&gt; 407需要代理身份验证 &lt;a href=&quot;#section-10.4.9&quot;&gt;10.4.9&lt;/a&gt; 408请求超时 &lt;a href=&quot;#section-10.4.10&quot;&gt;10.4.10&lt;/a&gt; 409冲突 &lt;a href=&quot;#section-10.4.11&quot;&gt;10.4.11&lt;/a&gt; 410已消失 &lt;a href=&quot;#section-10.4.12&quot;&gt;10.4.12&lt;/a&gt; 411所需长度 &lt;a href=&quot;#section-10.4.13&quot;&gt;10.4.13&lt;/a&gt; 412前提条件失败 &lt;a href=&quot;#section-10.4.14&quot;&gt;10.4.14&lt;/a&gt; 413请求实体太大 &lt;a href=&quot;#section-10.4.15&quot;&gt;10.4.15&lt;/a&gt; 414请求URI太长 &lt;a href=&quot;#section-10.4.16&quot;&gt;10.4.16&lt;/a&gt; 415不支持的媒体类型 &lt;a href=&quot;#section-10.4.17&quot;&gt;10.4.17&lt;/a&gt; 416请求的范围 不满足&lt;a href=&quot;#section-10.4.18&quot;&gt;10.4.18&lt;/a&gt; 417预期失败 &lt;a href=&quot;#section-10.5&quot;&gt;10.5&lt;/a&gt; 服务器错误5xx &lt;a href=&quot;#section-10.5.1&quot;&gt;10.5.1&lt;/a&gt; 500内部服务器错误 &lt;a href=&quot;#section-10.5.2&quot;&gt;10.5.2&lt;/a&gt; 501未实现 &lt;a href=&quot;#section-10.5.3&quot;&gt;10.5.3&lt;/a&gt; 502网关错误 &lt;a href=&quot;#section-10.5.4&quot;&gt;10.5.4&lt;/a&gt; 503服务不可用 &lt;a href=&quot;#section-10.5.5&quot;&gt;10.5.5&lt;/a&gt; 504网关超时 &lt;a href=&quot;#section-10.5.6&quot;&gt;10.5.6&lt;/a&gt; 505 HTTP版本不受支持 &lt;a href=&quot;#section-11&quot;&gt;11&lt;/a&gt; 访问验证 &lt;a href=&quot;#section-12&quot;&gt;12&lt;/a&gt; 内容协商 &lt;a href=&quot;#section-12.1&quot;&gt;12.1&lt;/a&gt; 服务器驱动的协商 &lt;a href=&quot;#section-12.2&quot;&gt;12.2&lt;/a&gt; 代理驱动的协商 &lt;a href=&quot;#section-12.3&quot;&gt;12.3&lt;/a&gt; 透明协商 &lt;a href=&quot;#section-13&quot;&gt;13&lt;/a&gt; HTTP &lt;a href=&quot;#section-13.1.1&quot;&gt;13.1.1中的&lt;/a&gt;缓存 缓存正确性 &lt;a href=&quot;#section-13.1.2&quot;&gt;13.1.2&lt;/a&gt; 警告 &lt;a href=&quot;#section-13.1.3&quot;&gt;13.1.3&lt;/a&gt; 缓存控制机制 &lt;a href=&quot;#section-13.1.4&quot;&gt;13.1.4&lt;/a&gt; 明确的用户代理警告 &lt;a href=&quot;#section-13.1.5&quot;&gt;13.1.5&lt;/a&gt; 的例外规则和警告 &lt;a href=&quot;#section-13.1.6&quot;&gt;13.1.6&lt;/a&gt; 客户控制的行为 &lt;a href=&quot;#section-13.2&quot;&gt;13.2&lt;/a&gt; 过期模型在 &lt;a href=&quot;#section-13.2.1&quot;&gt;13.2.1&lt;/a&gt; 服务器指定过期 &lt;a href=&quot;#section-13.2.2&quot;&gt;13.2.2&lt;/a&gt; 启发式到期时间 &lt;a href=&quot;#section-13.2.3&quot;&gt;13.2.3&lt;/a&gt; 年龄计算 &lt;a href=&quot;#section-13.2.4&quot;&gt;13.2.4&lt;/a&gt; 到期时间计算 &lt;a href=&quot;#section-13.2.5&quot;&gt;13.2.5&lt;/a&gt; 消除到期值的 歧义&lt;a href=&quot;#section-13.2.6&quot;&gt;13.2.6&lt;/a&gt;消除多重响应的歧义 &lt;a href=&quot;#section-13.3&quot;&gt;13.3&lt;/a&gt; 验证模型 &lt;a href=&quot;#section-13.3.1&quot;&gt;13.3.1&lt;/a&gt; 上次修改日期............................................... &lt;a href=&quot;#section-13.3.2&quot;&gt;13.3.2&lt;/a&gt; 实体标签缓存验证器 &lt;a href=&quot;#section-13.3.3&quot;&gt;13.3.3&lt;/a&gt; 弱验证器13.3.4何时使用实体标签和最后修改日期的规则89 &lt;a href=&quot;#section-13.3.5&quot;&gt;13.3.5&lt;/a&gt; 非验证条件 &lt;a href=&quot;#section-13.4&quot;&gt;13.4&lt;/a&gt; 响应可缓存性 &lt;a href=&quot;#section-13.5&quot;&gt;13.5&lt;/a&gt; 从缓存构造响应 &lt;a href=&quot;#section-13.5.1&quot;&gt;13.5.1&lt;/a&gt; 端到端和逐跳标头 &lt;a href=&quot;#section-13.5.2&quot;&gt;13.5.2&lt;/a&gt; 不可修改标头 &lt;a href=&quot;#section-13.5.3&quot;&gt;13.5.3&lt;/a&gt; 组合标头 &lt;a href=&quot;#section-13.5.4&quot;&gt;13.5.4&lt;/a&gt; 组合字节范围 &lt;a href=&quot;#section-13.6&quot;&gt;13.6&lt;/a&gt; 缓存协商的响应 &lt;a href=&quot;#section-13.7&quot;&gt;13.7&lt;/a&gt; 共享和非共享缓存 &lt;a href=&quot;#section-13.8&quot;&gt;13.8&lt;/a&gt; 错误或响应缓存行为不完整 &lt;a href=&quot;#section-13.9&quot;&gt;13.9&lt;/a&gt; GET和HEAD的副作用 &lt;a href=&quot;#section-13.10&quot;&gt;13.10&lt;/a&gt; 更新或删除后失效 &lt;a href=&quot;#section-13.11&quot;&gt;13.11&lt;/a&gt; 直写式强制性 &lt;a href=&quot;#section-13.12&quot;&gt;13.12&lt;/a&gt; 缓存替换 &lt;a href=&quot;#section-13.13&quot;&gt;13.13&lt;/a&gt; 历史记录列表 &lt;a href=&quot;#section-14&quot;&gt;14&lt;/a&gt; 标头字段定义 &lt;a href=&quot;#section-14.1&quot;&gt;14.1&lt;/a&gt; 接受 &lt;a href=&quot;#section-14.2&quot;&gt;14.2&lt;/a&gt; 接受字符集 &lt;a href=&quot;#section-14.3&quot;&gt;14.3&lt;/a&gt; 接受编码 &lt;a href=&quot;#section-14.4&quot;&gt;14.4&lt;/a&gt; 接受语言 &lt;a href=&quot;#section-14.5&quot;&gt;14.5&lt;/a&gt; 接受范围， &lt;a href=&quot;#section-14.6&quot;&gt;14.6&lt;/a&gt; 年龄 &lt;a href=&quot;#section-14.7&quot;&gt;14.7&lt;/a&gt; 允许 &lt;a href=&quot;#section-14.8&quot;&gt;14.8&lt;/a&gt; 授权 &lt;a href=&quot;#section-14.9&quot;&gt;14.9&lt;/a&gt; 缓存控制 &lt;a href=&quot;#section-14.9.1&quot;&gt;14.9.1&lt;/a&gt; 什么是可缓存&lt;a href=&quot;#section-14.9.2&quot;&gt;14.9.2&lt;/a&gt;缓存 可以存储的内容 &lt;a href=&quot;#section-14.9.3&quot;&gt;14.9.3&lt;/a&gt; 基本过期机制的修改 &lt;a href=&quot;#section-14.9.4&quot;&gt;14.9.4&lt;/a&gt; 缓存重新验证和重载控件 &lt;a href=&quot;#section-14.9.5&quot;&gt;14.9.5&lt;/a&gt; 无变换指令 &lt;a href=&quot;#section-14.9.6&quot;&gt;14.9.6&lt;/a&gt; 缓存控制扩展 &lt;a href=&quot;#section-14.10&quot;&gt;14.10&lt;/a&gt; 连接 &lt;a href=&quot;#section-14.11&quot;&gt;14.11&lt;/a&gt; 内容编码 &lt;a href=&quot;#section-14.12&quot;&gt;14.12&lt;/a&gt; 内容语言 &lt;a href=&quot;#section-14.13&quot;&gt;14.13&lt;/a&gt; 内容长度 &lt;a href=&quot;#section-14.14&quot;&gt;14.14&lt;/a&gt; 内容位置 &lt;a href=&quot;#section-14.15&quot;&gt;14.15&lt;/a&gt; 内容MD5 &lt;a href=&quot;#section-14.16&quot;&gt;14.16&lt;/a&gt; 内容范围 &lt;a href=&quot;#section-14.17&quot;&gt;14.17&lt;/a&gt; Content-Type的 &lt;a href=&quot;#section-14.18&quot;&gt;14.18&lt;/a&gt; 日期 &lt;a href=&quot;#section-14.18.1&quot;&gt;14.18.1&lt;/a&gt; 无时钟源服务器运行 &lt;a href=&quot;#section-14.19&quot;&gt;14.19&lt;/a&gt; ETag的 &lt;a href=&quot;#section-14.20&quot;&gt;14.20&lt;/a&gt; 预计 &lt;a href=&quot;#section-14.21&quot;&gt;14.21&lt;/a&gt; 过期 &lt;a href=&quot;#section-14.22&quot;&gt;14.22&lt;/a&gt; 从.......................... .................................... &lt;a href=&quot;#section-14.23&quot;&gt;14.23&lt;/a&gt; 主机 &lt;a href=&quot;#section-14.24&quot;&gt;14.24&lt;/a&gt; If-Match &lt;a href=&quot;#section-14.25&quot;&gt;14.25&lt;/a&gt; If-Modified-Since &lt;a href=&quot;#section-14.26&quot;&gt;14.26&lt;/a&gt; If- &lt;a href=&quot;#section-14.27&quot;&gt;Non&lt;/a&gt; -Match 14.27 If-Range &lt;a href=&quot;#section-14.28&quot;&gt;14.28&lt;/a&gt; 如果未修改，自 &lt;a href=&quot;#section-14.29&quot;&gt;14.29开始&lt;/a&gt; 最后修改的 &lt;a href=&quot;#section-14.30&quot;&gt;14.30&lt;/a&gt; 位置 &lt;a href=&quot;#section-14.31&quot;&gt;14.31&lt;/a&gt; 最大转发 &lt;a href=&quot;#section-14.32&quot;&gt;14.32&lt;/a&gt; 语法 &lt;a href=&quot;#section-14.33&quot;&gt;14.33&lt;/a&gt; 代理身份验证 &lt;a href=&quot;#section-14.34&quot;&gt;14.34&lt;/a&gt; 代理授权 &lt;a href=&quot;#section-14.35&quot;&gt;14.35&lt;/a&gt; 范围 &lt;a href=&quot;#section-14.35.1&quot;&gt;14.35.1&lt;/a&gt; 字节范围 &lt;a href=&quot;#section-14.35.2&quot;&gt;14.35.2&lt;/a&gt; 范围检索请求 &lt;a href=&quot;#section-14.36&quot;&gt;14.36&lt;/a&gt; 引用程序 &lt;a href=&quot;#section-14.37&quot;&gt;14.37&lt;/a&gt; 重试 &lt;a href=&quot;#section-14.38&quot;&gt;14.38&lt;/a&gt; 服务器 &lt;a href=&quot;#section-14.39&quot;&gt;14.39&lt;/a&gt; TE &lt;a href=&quot;#section-14.40&quot;&gt;14.40&lt;/a&gt; 尾部 &lt;a href=&quot;#section-14.41&quot;&gt;14.41&lt;/a&gt; 传输编码 &lt;a href=&quot;#section-14.42&quot;&gt;14.42&lt;/a&gt; 升级 &lt;a href=&quot;#section-14.43&quot;&gt;14.43&lt;/a&gt; 用户代理 &lt;a href=&quot;#section-14.44&quot;&gt;14.44&lt;/a&gt; 可变 &lt;a href=&quot;#section-14.45&quot;&gt;14.45&lt;/a&gt; 通过 &lt;a href=&quot;#section-14.46&quot;&gt;14.46&lt;/a&gt; 警告 &lt;a href=&quot;#section-14.47&quot;&gt;14.47&lt;/a&gt; WWW-Authenticate &lt;a href=&quot;#section-15&quot;&gt;15&lt;/a&gt;安全注意事项 &lt;a href=&quot;#section-15.1&quot;&gt;15.1&lt;/a&gt; 个人信息 &lt;a href=&quot;#section-15.1.1&quot;&gt;15.1.1&lt;/a&gt; 服务器日志信息的滥用 &lt;a href=&quot;#section-15.1.2&quot;&gt;15.1.2&lt;/a&gt; 敏感信息的传输 &lt;a href=&quot;#section-15.1.3&quot;&gt;15.1.3&lt;/a&gt; 在URI的&lt;a href=&quot;#section-15.1.4&quot;&gt;15.1.4&lt;/a&gt; 隐私问题中编码以 连接到接受标头的隐私问题 &lt;a href=&quot;#section-15.2&quot;&gt;15.2&lt;/a&gt; 基于文件和路径的攻击名称 &lt;a href=&quot;#section-15.3&quot;&gt;15.3&lt;/a&gt; DNS欺骗 &lt;a href=&quot;#section-15.4&quot;&gt;15.4&lt;/a&gt; 位置标头和欺骗 &lt;a href=&quot;#section-15.5&quot;&gt;15.5&lt;/a&gt; 内容处置问题 &lt;a href=&quot;#section-15.6&quot;&gt;15.6&lt;/a&gt; 身份验证凭据和空闲客户端 &lt;a href=&quot;#section-15.7&quot;&gt;15.7&lt;/a&gt; 代理和缓存 &lt;a href=&quot;#section-15.7.1&quot;&gt;15.7.1&lt;/a&gt; 对代理的拒绝服务攻击 &lt;a href=&quot;#section-16&quot;&gt;16&lt;/a&gt; 致谢 &lt;a href=&quot;#section-17&quot;&gt;17&lt;/a&gt; 参考文献 &lt;a href=&quot;#section-18&quot;&gt;18&lt;/a&gt; 作者的地址 &lt;a href=&quot;#section-19&quot;&gt;19&lt;/a&gt; 附录 &lt;a href=&quot;#section-19.1&quot;&gt;19.1&lt;/a&gt; Internet媒体类型message / http和application / http &lt;a href=&quot;#section-19.2&quot;&gt;19.2&lt;/a&gt; Internet媒体类型multipart / byteranges &lt;a href=&quot;#section-19.3&quot;&gt;19.3&lt;/a&gt; 宽容的应用程序 &lt;a href=&quot;#section-19.4&quot;&gt;19.4&lt;/a&gt; HTTP实体和&lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC&lt;/a&gt;之间的差异2045实体.... &lt;a href=&quot;#section-19.4.1&quot;&gt;19.4.1&lt;/a&gt; MIME版本 &lt;a href=&quot;#section-19.4.2&quot;&gt;19.4.2&lt;/a&gt; 转换为规范形式 &lt;a href=&quot;#section-19.4.3&quot;&gt;19&lt;/a&gt; .4.3日期格式的转换 &lt;a href=&quot;#section-19.4.4&quot;&gt;19.4.4&lt;/a&gt; 内容编码的介绍 &lt;a href=&quot;#section-19.4.5&quot;&gt;19.4.5&lt;/a&gt; 无内容传输的编码&lt;a href=&quot;#section-19.4.6&quot;&gt;19.4.6&lt;/a&gt;传输编码的 介绍 &lt;a href=&quot;#section-19.4.7&quot;&gt;19.4.7&lt;/a&gt; MHTML和行长限制 &lt;a href=&quot;#section-19.5&quot;&gt;19.5&lt;/a&gt; 附加功能 &lt;a href=&quot;#section-19.5.1&quot;&gt;19.5.1&lt;/a&gt; 内容处置 &lt;a href=&quot;#section-19.6&quot;&gt;19.6&lt;/a&gt; 与先前版本的兼容性 &lt;a href=&quot;#section-19.6.1&quot;&gt;19.6.1&lt;/a&gt; 从HTTP / 1.0的变化 &lt;a href=&quot;#section-19.6.2&quot;&gt;19.6.2&lt;/a&gt; 兼容性与HTTP / 1.0持久连接 &lt;a href=&quot;#section-19.6.3&quot;&gt;19.6.3&lt;/a&gt; 变化从&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068 &lt;/a&gt;&lt;a href=&quot;#section-20&quot;&gt;20&lt;/a&gt; 指数 &lt;a href=&quot;#section-21&quot;&gt;21&lt;/a&gt; 完全版权声明</target>
        </trans-unit>
        <trans-unit id="d08c83f00b0f35b12328f45a668424f28ef4c379" translate="yes" xml:space="preserve">
          <source>Storing Responses in Caches (RFC 7234)</source>
          <target state="translated">在缓存中存储响应(RFC 7234)</target>
        </trans-unit>
        <trans-unit id="7ff86787ade1bf61ad2e59270f3c9e57589ff5d5" translate="yes" xml:space="preserve">
          <source>Stream priorities are changed using the PRIORITY frame.  Setting a
   dependency causes a stream to become dependent on the identified
   parent stream.

   Dependent streams move with their parent stream if the parent is
   reprioritized.  Setting a dependency with the exclusive flag for a
   reprioritized stream causes all the dependencies of the new parent
   stream to become dependent on the reprioritized stream.

   If a stream is made dependent on one of its own dependencies, the
   formerly dependent stream is first moved to be dependent on the
   reprioritized stream's previous parent.  The moved dependency retains
   its weight.

   For example, consider an original dependency tree where B and C
   depend on A, D and E depend on C, and F depends on D.  If A is made
   dependent on D, then D takes the place of A.  All other dependency
   relationships stay the same, except for F, which becomes dependent on
   A if the reprioritization is exclusive. 

       x                x                x                 x
       |               / \               |                 |
       A              D   A              D                 D
      / \            /   / \            / \                |
     B   C     ==&amp;gt;  F   B   C   ==&amp;gt;    F   A       OR      A
        / \                 |             / \             /|\
       D   E                E            B   C           B C F
       |                                     |             |
       F                                     E             E
                  (intermediate)   (non-exclusive)    (exclusive)

                Figure 5: Example of Dependency Reordering</source>
          <target state="translated">使用PRIORITY框架更改流优先级。设置依赖关系会导致流变得依赖于已标识的父流。如果重新确定父级的优先级，则从属流将与其父级流一起移动。为重定优先级的流设置具有独占标志的依赖关系会导致新父流的所有依赖关系都变得依赖于重定优先级的流。如果使流依赖于其自身的依赖关系之一，则首先将先前依赖的流移为依赖于重新排序优先级的流的先前父对象。移动的依赖项保持其权重。例如，考虑一个原始的依赖关系树，其中B和C依赖于A，D和E依赖于C，F依赖于D。如果使A依赖于D，则D代替A。所有其他依赖关系保持不变一样，除了F如果重新优先级排他，则依赖于A。 xxxx | / \ | | ADADD / \ / / \ / \ | | BC ==&amp;gt; FBC ==&amp;gt; FA OR A / \ | / \ / | \ DEEBCBCF | | | FEE（中级）（非排他性）（排他性）图5：依赖关系重排示例</target>
        </trans-unit>
        <trans-unit id="bce8f34f0a23969364026999a31bec5f7b65b0ae" translate="yes" xml:space="preserve">
          <source>Streams are identified with an unsigned 31-bit integer.  Streams
   initiated by a client MUST use odd-numbered stream identifiers; those
   initiated by the server MUST use even-numbered stream identifiers.  A
   stream identifier of zero (0x0) is used for connection control
   messages; the stream identifier of zero cannot be used to establish a
   new stream.

   HTTP/1.1 requests that are upgraded to HTTP/2 (see &lt;a href=&quot;#section-3.2&quot;&gt;Section 3.2&lt;/a&gt;) are
   responded to with a stream identifier of one (0x1).  After the
   upgrade completes, stream 0x1 is &quot;half-closed (local)&quot; to the client.
   Therefore, stream 0x1 cannot be selected as a new stream identifier
   by a client that upgrades from HTTP/1.1.

   The identifier of a newly established stream MUST be numerically
   greater than all streams that the initiating endpoint has opened or
   reserved.  This governs streams that are opened using a HEADERS frame
   and streams that are reserved using PUSH_PROMISE.  An endpoint that
   receives an unexpected stream identifier MUST respond with a
   connection error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type PROTOCOL_ERROR.

   The first use of a new stream identifier implicitly closes all
   streams in the &quot;idle&quot; state that might have been initiated by that
   peer with a lower-valued stream identifier.  For example, if a client
   sends a HEADERS frame on stream 7 without ever sending a frame on
   stream 5, then stream 5 transitions to the &quot;closed&quot; state when the
   first frame for stream 7 is sent or received.

   Stream identifiers cannot be reused.  Long-lived connections can
   result in an endpoint exhausting the available range of stream
   identifiers.  A client that is unable to establish a new stream
   identifier can establish a new connection for new streams.  A server
   that is unable to establish a new stream identifier can send a GOAWAY
   frame so that the client is forced to open a new connection for new
   streams.</source>
          <target state="translated">流是用无符号的31位整数标识的。由客户端发起的流必须使用奇数流标识符。由服务器启动的那些务必使用偶数流标识符。流标识符零（0x0）用于连接控制消息。流标识符零不能用于建立新流。升级到HTTP / 2的HTTP / 1.1请求（请参阅&lt;a href=&quot;#section-3.2&quot;&gt;第3.2节&lt;/a&gt;）将以流标识符1（0x1）进行响应。升级完成后，流0x1被&amp;ldquo;半关闭（本地）&amp;rdquo;到客户端。因此，从HTTP / 1.1升级的客户端无法将流0x1选择为新的流标识符。新建立的流的标识符必须在数值上大于发起端点已打开或保留的所有流。这控制使用HEADERS帧打开的流和使用PUSH_PROMISE保留的流。收到意外流标识符的端点务必以连接错误响应（&lt;a href=&quot;#section-5.4.1&quot;&gt;5.4.1节）&lt;/a&gt;），类型为PROTOCOL_ERROR。首次使用新的流标识符会隐式关闭处于&amp;ldquo;空闲&amp;rdquo;状态的所有流，这些流可能已由该对等方使用值较低的流标识符启动。例如，如果客户端在流7上发送HEADERS帧而没有在流5上发送帧，则当发送或接收流7的第一个帧时，流5转换为&amp;ldquo;关闭&amp;rdquo;状态。流标识符不能重复使用。长期存在的连接可能导致端点耗尽可用范围的流标识符。无法建立新的流标识符的客户端可以为新的流建立新的连接。无法建立新流标识符的服务器可以发送GOAWAY帧，以便客户端被迫为新流打开新连接。</target>
        </trans-unit>
        <trans-unit id="a1c0b3831b3706354655bc626dc41410ec27c9ee" translate="yes" xml:space="preserve">
          <source>Strict Transport Security resolves this problem; as long as you've accessed your bank's web site once using HTTPS, and the bank's web site uses Strict Transport Security, your browser will know to automatically use only HTTPS, which prevents hackers from performing this sort of man-in-the-middle attack.</source>
          <target state="translated">Strict Transport Security解决了这个问题,只要你使用HTTPS访问过一次银行的网站,而且银行的网站使用了Strict Transport Security,你的浏览器就会知道自动只使用HTTPS,这样就可以防止黑客进行这种中间人攻击。</target>
        </trans-unit>
        <trans-unit id="fc587e4b5dd9c8f2dabaee348836f36fc9073981" translate="yes" xml:space="preserve">
          <source>Strict-Transport-Security</source>
          <target state="translated">Strict-Transport-Security</target>
        </trans-unit>
        <trans-unit id="b47d9bc682e1c7c17d99058428f34fc877b82f8a" translate="yes" xml:space="preserve">
          <source>Strong validation</source>
          <target state="translated">强大的验证</target>
        </trans-unit>
        <trans-unit id="bce009dcd1fa74e08bb9b002217d1633ae7d181e" translate="yes" xml:space="preserve">
          <source>Strong validation consists of guaranteeing that the resource is, byte to byte, identical to the one it is compared too. This is mandatory for some conditional headers, and the default for the others. Strong validation is very strict and may be difficult to guarantee at the server level, but it does guarantee no data loss at any time, sometimes at the expense of performance.</source>
          <target state="translated">强验证包括保证资源与被比较的资源在字节上是相同的。这对于一些条件头来说是强制性的,而对于其他条件头来说是默认的。强验证是非常严格的,可能很难在服务器级别上保证,但它确实保证了在任何时候都不会丢失数据,有时是以牺牲性能为代价的。</target>
        </trans-unit>
        <trans-unit id="546f797f485e1c93debf33798738f22e2e2c71a9" translate="yes" xml:space="preserve">
          <source>Structure of a MIME type</source>
          <target state="translated">MIME类型的结构</target>
        </trans-unit>
        <trans-unit id="2a9b0645b4584767c896ce8933cbb6a249c16aa0" translate="yes" xml:space="preserve">
          <source>Structure of a server response</source>
          <target state="translated">服务器响应的结构</target>
        </trans-unit>
        <trans-unit id="87e09f53c79b7b9952020efdce6fce234ef5dd58" translate="yes" xml:space="preserve">
          <source>Subnet based decisions</source>
          <target state="translated">基于子网的决定</target>
        </trans-unit>
        <trans-unit id="d0b8ad91fc39a9beb48e35304c9f430f0a69862b" translate="yes" xml:space="preserve">
          <source>Subresource Integrity</source>
          <target state="translated">子资源完整性</target>
        </trans-unit>
        <trans-unit id="983f9ac400958792e64abc2d44401492ed778563" translate="yes" xml:space="preserve">
          <source>Subresource Integrity&lt;br/&gt;&lt;small&gt;The definition of 'require-sri-for' in that specification.&lt;/small&gt;</source>
          <target state="translated">子资源完整性&lt;small&gt;该&lt;/small&gt;规范&lt;br/&gt;&lt;small&gt;中&amp;ldquo; require-sri-for&amp;rdquo;的定义。&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="522495833932f57c0df7141327df306caf0e6ac3" translate="yes" xml:space="preserve">
          <source>Subsequent lines represent an HTTP header, giving the server information about what type of data is appropriate (e.g., what language, what MIME types), or other data altering its behavior (e.g., not sending an answer if it is already cached). These HTTP headers form a block which ends with an empty line.</source>
          <target state="translated">后面的行代表一个HTTP头,给服务器提供关于什么类型的数据是合适的(例如,什么语言,什么MIME类型),或者其他改变其行为的数据(例如,如果已经被缓存,就不发送应答)。这些HTTP头形成一个块,以空行结束。</target>
        </trans-unit>
        <trans-unit id="8d055925604926e85c70a546b297fe94724c7c5d" translate="yes" xml:space="preserve">
          <source>Subsequent lines represent specific HTTP headers, giving the client information about the data sent (e.g. type, data size, compression algorithm used, hints about caching). Similarly to the block of HTTP headers for a client request, these HTTP headers form a block ending with an empty line.</source>
          <target state="translated">后面的行代表特定的HTTP头信息,给客户端提供发送数据的信息(如类型、数据大小、使用的压缩算法、关于缓存的提示)。类似于客户端请求的HTTP头信息块,这些HTTP头信息形成一个以空行结束的块。</target>
        </trans-unit>
        <trans-unit id="56befc0f91be9db5dc24b49f4e5533e7ea0072f5" translate="yes" xml:space="preserve">
          <source>Subsequent sections discuss scenarios, as well as provide a breakdown of the HTTP headers used.</source>
          <target state="translated">随后的章节讨论了场景,并提供了所使用的HTTP头文件的分解。</target>
        </trans-unit>
        <trans-unit id="ff5c588e9523269ce3c84f63e9bd3897ebe63eec" translate="yes" xml:space="preserve">
          <source>Succeeds if the &lt;a href=&quot;headers/etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt; of the distant resource is different to each listed in this header. By default, unless the etag is prefixed with &lt;code&gt;'W/'&lt;/code&gt;, it performs a strong validation.</source>
          <target state="translated">如果远程资源的&lt;a href=&quot;headers/etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt;与此标头中列出的每个ETag不同，则成功。默认情况下，除非etag带有 &lt;code&gt;'W/'&lt;/code&gt; 前缀，否则它将执行严格的验证。</target>
        </trans-unit>
        <trans-unit id="aeef7e868363979461d6ea2ad7bf8c6358e365a2" translate="yes" xml:space="preserve">
          <source>Succeeds if the &lt;a href=&quot;headers/etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt; of the distant resource is equal to one listed in this header. By default, unless the etag is prefixed with &lt;code&gt;'W/'&lt;/code&gt;, it performs a strong validation.</source>
          <target state="translated">如果远程资源的&lt;a href=&quot;headers/etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt;等于此标头中列出的ETag，则成功。默认情况下，除非etag带有 &lt;code&gt;'W/'&lt;/code&gt; 前缀，否则它将执行严格的验证。</target>
        </trans-unit>
        <trans-unit id="2c3bd70cb1b0ac4e3f147078e58e04d441ea7e0e" translate="yes" xml:space="preserve">
          <source>Succeeds if the &lt;a href=&quot;headers/last-modified&quot;&gt;&lt;code&gt;Last-Modified&lt;/code&gt;&lt;/a&gt; date of the distant resource is more recent than the one given in this header.</source>
          <target state="translated">如果远程资源的&lt;a href=&quot;headers/last-modified&quot;&gt; &lt;code&gt;Last-Modified&lt;/code&gt; &lt;/a&gt;日期比此标头中指定的日期更新，则成功。</target>
        </trans-unit>
        <trans-unit id="54dce543ac7122114b0f1b25a6c18db4700a57c7" translate="yes" xml:space="preserve">
          <source>Succeeds if the &lt;a href=&quot;headers/last-modified&quot;&gt;&lt;code&gt;Last-Modified&lt;/code&gt;&lt;/a&gt; date of the distant resource is older or the same than the one given in this header.</source>
          <target state="translated">如果远程资源的&lt;a href=&quot;headers/last-modified&quot;&gt; &lt;code&gt;Last-Modified&lt;/code&gt; &lt;/a&gt;日期早于此标头中指定的日期或与该标头中指定的日期相同，则成功。</target>
        </trans-unit>
        <trans-unit id="1290a72cee06cf30f2b9582a53c05c695119f17b" translate="yes" xml:space="preserve">
          <source>Successful response has body</source>
          <target state="translated">成功的反应有机构</target>
        </trans-unit>
        <trans-unit id="d702cfd3f57a8cfe18b4f37a36bf15bc2c548094" translate="yes" xml:space="preserve">
          <source>Successful responses</source>
          <target state="translated">成功的答复</target>
        </trans-unit>
        <trans-unit id="47bd58ec264925cf6d2934f949144bd5b42d3e5b" translate="yes" xml:space="preserve">
          <source>Successful responses (&lt;code&gt;200&lt;/code&gt;&amp;ndash;&lt;code&gt;299&lt;/code&gt;)</source>
          <target state="translated">成功的回应（ &lt;code&gt;200&lt;/code&gt; &amp;ndash; &lt;code&gt;299&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="7e16e36ee4dff516de670a1cd0a9ef3f413ae5fb" translate="yes" xml:space="preserve">
          <source>Successful results of a retrieval request: a &lt;a href=&quot;status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt; (OK) response to a &lt;a href=&quot;methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; request containing a resource like HTML documents, images or files.</source>
          <target state="translated">检索请求的成功结果：对&lt;a href=&quot;methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;请求的&lt;a href=&quot;status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt;（确定）响应，其中包含HTML文档，图像或文件之类的资源。</target>
        </trans-unit>
        <trans-unit id="7cf7d910e383411b293ea5c44eeeb1c0a4a4a122" translate="yes" xml:space="preserve">
          <source>Successful web page response:</source>
          <target state="translated">网页回复成功。</target>
        </trans-unit>
        <trans-unit id="201d1d5e3d5c9d5de591a119116dd6b9386319e3" translate="yes" xml:space="preserve">
          <source>Supplants the &lt;code&gt;Origin&lt;/code&gt; header as defined in RFC6454.</source>
          <target state="translated">替换RFC6454 中定义的 &lt;code&gt;Origin&lt;/code&gt; 标头。</target>
        </trans-unit>
        <trans-unit id="216a84fbd27cb3b4473b824b61cc5de56085403b" translate="yes" xml:space="preserve">
          <source>Support for the &lt;code&gt;Retry-After&lt;/code&gt; header on both clients and servers is still inconsistent. However, some crawlers and spiders, like the Googlebot, honor the &lt;code&gt;Retry-After&lt;/code&gt; header. It is useful to send it along with a &lt;a href=&quot;../status/503&quot;&gt;&lt;code&gt;503&lt;/code&gt;&lt;/a&gt; (Service Unavailable) response, so that search engines will keep indexing your site when the downtime is over.</source>
          <target state="translated">客户端和服务器上对 &lt;code&gt;Retry-After&lt;/code&gt; 标头的支持仍然不一致。但是，某些爬虫和蜘蛛（例如Googlebot）会使用 &lt;code&gt;Retry-After&lt;/code&gt; 标头。将其与&lt;a href=&quot;../status/503&quot;&gt; &lt;code&gt;503&lt;/code&gt; &lt;/a&gt;（服务不可用）响应一起发送很有用，这样当停机时间结束时，搜索引擎将继续为您的站点编制索引。</target>
        </trans-unit>
        <trans-unit id="4c6167e7995d17c7bc37724de85e632d49fe0fd7" translate="yes" xml:space="preserve">
          <source>Support of &lt;a href=&quot;../headers/alt-svc&quot;&gt;&lt;code&gt;Alt-Svc&lt;/code&gt;&lt;/a&gt; allows the dissociation of the identification and the location of a given resource, allowing for a smarter &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CDN&quot;&gt;CDN&lt;/a&gt; caching mechanism.</source>
          <target state="translated">对&lt;a href=&quot;../headers/alt-svc&quot;&gt; &lt;code&gt;Alt-Svc&lt;/code&gt; 的&lt;/a&gt;支持允许分离标识和给定资源的位置，从而实现更智能的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CDN&quot;&gt;CDN&lt;/a&gt;缓存机制。</target>
        </trans-unit>
        <trans-unit id="5557d57c74c062096ddfe6fcacebab65584a47fd" translate="yes" xml:space="preserve">
          <source>Supported digest algorithms are defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc3230&quot;&gt;RFC 3230&lt;/a&gt; and &lt;a href=&quot;https://tools.ietf.org/html/rfc5843&quot;&gt;RFC 5843&lt;/a&gt;, and include &lt;code&gt;SHA-256&lt;/code&gt; and &lt;code&gt;SHA-512&lt;/code&gt;. Some of the supported algorithms, including &lt;code&gt;unixsum&lt;/code&gt; and &lt;code&gt;MD5&lt;/code&gt; are subject to collisions and are thus not suitable for applications in which collision-resistance is important.</source>
          <target state="translated">受支持的摘要算法在&lt;a href=&quot;https://tools.ietf.org/html/rfc3230&quot;&gt;RFC 3230&lt;/a&gt;和&lt;a href=&quot;https://tools.ietf.org/html/rfc5843&quot;&gt;RFC 5843&lt;/a&gt;中定义，包括 &lt;code&gt;SHA-256&lt;/code&gt; 和 &lt;code&gt;SHA-512&lt;/code&gt; 。某些受支持的算法（包括 &lt;code&gt;unixsum&lt;/code&gt; 和 &lt;code&gt;MD5&lt;/code&gt; )会发生冲突，因此不适合于其中抗冲突性很重要的应用程序。</target>
        </trans-unit>
        <trans-unit id="9cf8d0d7c981d663797eeaca7523e977bed4ab51" translate="yes" xml:space="preserve">
          <source>Supporting OCSP stapling (that is, the &lt;code&gt;status_request&lt;/code&gt; TLS extension) and providing a &lt;code&gt;SignedCertificateTimestampList&lt;/code&gt;</source>
          <target state="translated">支持OCSP装订（即 &lt;code&gt;status_request&lt;/code&gt; TLS扩展）并提供一个 &lt;code&gt;SignedCertificateTimestampList&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d1d598d97e68fd3cf7ac8ec2441b332f10d641fc" translate="yes" xml:space="preserve">
          <source>Switch to a blacklist model for restricted Accept headers in simple CORS requests</source>
          <target state="translated">在简单的CORS请求中,将受限的Accept头切换到黑名单模式。</target>
        </trans-unit>
        <trans-unit id="57ebc7fe25f3af6b8e76fe3b492c6dd20ec4df27" translate="yes" xml:space="preserve">
          <source>Switching protocols might be used with &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API&quot;&gt;WebSockets&lt;/a&gt;.</source>
          <target state="translated">切换协议可能与&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API&quot;&gt;WebSockets&lt;/a&gt;一起使用。</target>
        </trans-unit>
        <trans-unit id="00d7e2af1a23453b6e8dc5b63832fd4a645bc527" translate="yes" xml:space="preserve">
          <source>Synchronous XMLHTTPRequest</source>
          <target state="translated">同步的XMLHTTPRequest</target>
        </trans-unit>
        <trans-unit id="4103f0b31624fefeee3cf5f8642cc1c83ff9a978" translate="yes" xml:space="preserve">
          <source>Synchronous XMLHttpRequest</source>
          <target state="translated">同步的XMLHttpRequest</target>
        </trans-unit>
        <trans-unit id="be9208425b9c861fee1e1a67180b55dad01dafe7" translate="yes" xml:space="preserve">
          <source>Synchronous scripts</source>
          <target state="translated">同步脚本</target>
        </trans-unit>
        <trans-unit id="17c7ba7676ad1ad6dd1c4e6b997adcae910262c9" translate="yes" xml:space="preserve">
          <source>Syntax</source>
          <target state="translated">Syntax</target>
        </trans-unit>
        <trans-unit id="791a9bf2077653138c6b3912f9bf31ac1b906662" translate="yes" xml:space="preserve">
          <source>Syntax of Uniform Resource Identifiers (URIs)</source>
          <target state="translated">统一资源标识符(URI)的语法</target>
        </trans-unit>
        <trans-unit id="c2c53d66948214258a26ca9ca845d7ac0c17f8e7" translate="yes" xml:space="preserve">
          <source>T</source>
          <target state="translated">T</target>
        </trans-unit>
        <trans-unit id="b10d92078103e058dd32c50f84517f2c9bcce935" translate="yes" xml:space="preserve">
          <source>TCP connection to the server timed out</source>
          <target state="translated">与服务器的TCP连接超时</target>
        </trans-unit>
        <trans-unit id="5a056389515bd999bc97e7793f7c147c0b47eac3" translate="yes" xml:space="preserve">
          <source>TCP port number on which the server is listening.</source>
          <target state="translated">服务器正在监听的TCP端口号。</target>
        </trans-unit>
        <trans-unit id="49a198744d47717f2dedc61eda3abad936b310a2" translate="yes" xml:space="preserve">
          <source>TCP port number on which the server is listening. If no port is given, the default port for the service requested (e.g., &quot;80&quot; for an HTTP URL) is implied.</source>
          <target state="translated">服务器正在监听的TCP端口号,如果没有给定端口,则默认为请求服务的端口(例如,HTTP URL的 &quot;80&quot;)。如果没有给定端口,则暗示了请求服务的默认端口(例如,HTTP URL的 &quot;80&quot;)。</target>
        </trans-unit>
        <trans-unit id="1945ca5513cf77b8240e53495ba7a26e86acaca7" translate="yes" xml:space="preserve">
          <source>TE</source>
          <target state="translated">TE</target>
        </trans-unit>
        <trans-unit id="2dd200ebd9f2359780d12717e9c2166303c7a6d3" translate="yes" xml:space="preserve">
          <source>TE (RFC 2616)</source>
          <target state="translated">TE(RFC 2616)</target>
        </trans-unit>
        <trans-unit id="a775b64f2cd6a88a198986d46d44e0a021785125" translate="yes" xml:space="preserve">
          <source>TIFF</source>
          <target state="translated">TIFF</target>
        </trans-unit>
        <trans-unit id="b698c11e84460ed5999bfeb5cbf25b865c238f3c" translate="yes" xml:space="preserve">
          <source>TODO</source>
          <target state="translated">TODO</target>
        </trans-unit>
        <trans-unit id="ddf8a55c683ee58c6268b4264acb1d703195d588" translate="yes" xml:space="preserve">
          <source>TRACE</source>
          <target state="translated">TRACE</target>
        </trans-unit>
        <trans-unit id="0d5266ebda7b5b7ca016e3ecbf8bfe060fe9dd53" translate="yes" xml:space="preserve">
          <source>TRACE (RFC 7231)</source>
          <target state="translated">TRACE (RFC 7231)</target>
        </trans-unit>
        <trans-unit id="1223c0da5965757fa8d93336605832a0144596b6" translate="yes" xml:space="preserve">
          <source>TRACE: The message body contains the request message as received by the server</source>
          <target state="translated">TRACE:消息主体包含服务器收到的请求消息。</target>
        </trans-unit>
        <trans-unit id="56ab49a5c68f11cc45c651da6a3f339eff2853f8" translate="yes" xml:space="preserve">
          <source>TV</source>
          <target state="translated">TV</target>
        </trans-unit>
        <trans-unit id="fabcacd2a76a1a809975d60d7982c2a1035ab1c0" translate="yes" xml:space="preserve">
          <source>Tablet</source>
          <target state="translated">Tablet</target>
        </trans-unit>
        <trans-unit id="7193b142ed8cd6bae9bcd7f28df4d59bf30c7919" translate="yes" xml:space="preserve">
          <source>Tablet versions on WebView mirror mobile, but do not contain a &lt;code&gt;Mobile&lt;/code&gt; token.</source>
          <target state="translated">WebView上的平板电脑版本可镜像移动设备，但不包含 &lt;code&gt;Mobile&lt;/code&gt; 令牌。</target>
        </trans-unit>
        <trans-unit id="e63d48cf86b47f4a2e41a4c2480abd63617e07ff" translate="yes" xml:space="preserve">
          <source>Tagged Image File Format</source>
          <target state="translated">标签图像文件格式</target>
        </trans-unit>
        <trans-unit id="6c352e4dbdd3d9d5e6127303b4e65a452119231a" translate="yes" xml:space="preserve">
          <source>Tagged Image File Format (TIFF)</source>
          <target state="translated">标签图像文件格式(TIFF)</target>
        </trans-unit>
        <trans-unit id="5c1a98fc42374c0534b21a7c408be88b0b460645" translate="yes" xml:space="preserve">
          <source>Tags and summary</source>
          <target state="translated">标签和摘要</target>
        </trans-unit>
        <trans-unit id="03b91e28fed7956fe56ed8f65fc65fd882bbb491" translate="yes" xml:space="preserve">
          <source>Tags for the Identification of Language</source>
          <target state="translated">语言鉴定的标签</target>
        </trans-unit>
        <trans-unit id="40a1df0d175828bc0ac87d97cb74122c8c8d4d00" translate="yes" xml:space="preserve">
          <source>Takes precedence over &lt;code&gt;max-age&lt;/code&gt; or the &lt;code&gt;Expires&lt;/code&gt; header, but it only applies to shared caches (e.g., proxies) and is ignored by a private cache.</source>
          <target state="translated">优先于 &lt;code&gt;max-age&lt;/code&gt; 或 &lt;code&gt;Expires&lt;/code&gt; 标头，但它仅适用于共享缓存（例如代理），并且被私有缓存忽略。</target>
        </trans-unit>
        <trans-unit id="c149ac475d4a9b7fd2b15c7870c52269b0872366" translate="yes" xml:space="preserve">
          <source>Tape Archive (TAR)</source>
          <target state="translated">磁带档案 (TAR)</target>
        </trans-unit>
        <trans-unit id="a9bdde16c71950f9f0a80cbf4ce3915950ed2150" translate="yes" xml:space="preserve">
          <source>Targets of caching operations</source>
          <target state="translated">缓存操作的目标</target>
        </trans-unit>
        <trans-unit id="d9c7795d9a943127c5b4d89543f3db9a1ffaae49" translate="yes" xml:space="preserve">
          <source>Technically a part of Device Memory API, this header represents an approximate amount of RAM client has.</source>
          <target state="translated">从技术上讲,这个头是Device Memory API的一部分,它代表了客户端拥有的RAM的大概数量。</target>
        </trans-unit>
        <trans-unit id="2313e8c800252c9ae07b4e97927a6d9cf9ac1b33" translate="yes" xml:space="preserve">
          <source>Techniques for canonical URLs</source>
          <target state="translated">规范URL的技术</target>
        </trans-unit>
        <trans-unit id="04e57122701fa97f61a068ec7bd222827a269a62" translate="yes" xml:space="preserve">
          <source>Tells the browser that the page being loaded is going to want to perform a large allocation.</source>
          <target state="translated">告诉浏览器,正在加载的页面要想进行大分配。</target>
        </trans-unit>
        <trans-unit id="c8c8d2a564da5b504842208aff51d3ccfc991895" translate="yes" xml:space="preserve">
          <source>Tells the client the server's prefered encoding scheme when submiting a username and password. The only allowed value is the case insensitive string &quot;UTF-8&quot;. This does not relate to the encoding of the realm string.</source>
          <target state="translated">当提交用户名和密码时,告诉客户端服务器的首选编码方案。唯一允许的值是不区分大小写的字符串 &quot;UTF-8&quot;。这与领域字符串的编码无关。</target>
        </trans-unit>
        <trans-unit id="3e310a9a1efd6f1548ce06a7ac2dc4748669f825" translate="yes" xml:space="preserve">
          <source>Tells the client the server's prefered encoding scheme when submitting a username and password. The only allowed value is the case insensitive string &quot;UTF-8&quot;. This does not relate to the encoding of the realm string.</source>
          <target state="translated">当提交用户名和密码时,告诉客户端服务器的首选编码方案。唯一允许的值是不区分大小写的字符串 &quot;UTF-8&quot;。这与领域字符串的编码无关。</target>
        </trans-unit>
        <trans-unit id="e58df9f49057b700376e3c8d719874a09fcdc736" translate="yes" xml:space="preserve">
          <source>Tells the user-agent to reset the document which sent this request.</source>
          <target state="translated">告诉用户代理重设发送该请求的文档。</target>
        </trans-unit>
        <trans-unit id="86f4edbe4b69402bc32c890fe46456f6b42c2ad1" translate="yes" xml:space="preserve">
          <source>Temporary redirections</source>
          <target state="translated">临时改道</target>
        </trans-unit>
        <trans-unit id="7aefd5b2f288adc48ce6a117e81f357d1eed0b40" translate="yes" xml:space="preserve">
          <source>Temporary redirects during site maintenance or downtime</source>
          <target state="translated">在网站维护或停机期间临时重定向。</target>
        </trans-unit>
        <trans-unit id="6b029c546a5b81b886574d6c63becc55db5c5c32" translate="yes" xml:space="preserve">
          <source>Temporary responses to long requests</source>
          <target state="translated">对长期请求的临时答复</target>
        </trans-unit>
        <trans-unit id="44729f34632c3c8c496e4f38b8037aa7c3dfb175" translate="yes" xml:space="preserve">
          <source>Temporary responses to unsafe requests</source>
          <target state="translated">对不安全请求的临时反应</target>
        </trans-unit>
        <trans-unit id="66ad9b49478e00d9521f776ed94bddcd7f501cea" translate="yes" xml:space="preserve">
          <source>Testing your policy</source>
          <target state="translated">测试您的政策</target>
        </trans-unit>
        <trans-unit id="c3328c39b0e29f78e9ff45db674248b1d245887d" translate="yes" xml:space="preserve">
          <source>Text</source>
          <target state="translated">Text</target>
        </trans-unit>
        <trans-unit id="9845ab8961b7e4a2e464fba53a5a9a896b568e17" translate="yes" xml:space="preserve">
          <source>Text, (generally ASCII or ISO 8859-&lt;em&gt;n&lt;/em&gt;)</source>
          <target state="translated">文本（通常为ASCII或ISO 8859- &lt;em&gt;n&lt;/em&gt;）</target>
        </trans-unit>
        <trans-unit id="dd0fe1624d9684bcb52e0cccdb484d7e2001e225" translate="yes" xml:space="preserve">
          <source>Text-only data including any human-readable content, source code, or textual data such as comma-separated value (CSV) formatted data. Examples include &lt;code&gt;text/plain&lt;/code&gt;, &lt;code&gt;text/csv&lt;/code&gt;, and &lt;code&gt;text/html&lt;/code&gt;.</source>
          <target state="translated">纯文本数据，包括任何人类可读的内容，源代码或文本数据，例如逗号分隔值（CSV）格式的数据。示例包括 &lt;code&gt;text/plain&lt;/code&gt; ， &lt;code&gt;text/csv&lt;/code&gt; 和 &lt;code&gt;text/html&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="41e7a7ed719d0daa7e0a2e3d48d3aa52fa318aae" translate="yes" xml:space="preserve">
          <source>Thanks to its extensibility &amp;ndash; creating new headers or methods is easy &amp;ndash; and even if the HTTP/1.1 protocol was refined over two revisions, &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt; published in June 1999 and the series of &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC 7230&lt;/a&gt;-&lt;a href=&quot;https://tools.ietf.org/html/rfc7235&quot;&gt;RFC 7235&lt;/a&gt; published in June 2014 in prevision of the release of HTTP/2, this protocol has been extremely stable over more than 15 years.</source>
          <target state="translated">由于其可扩展性-创建新的标头或方法很容易-即使HTTP / 1.1协议在两个修订版中进行了改进，1999年6月发布的&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt;和2014年6月发布的&lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC 7230&lt;/a&gt; - &lt;a href=&quot;https://tools.ietf.org/html/rfc7235&quot;&gt;RFC 7235&lt;/a&gt;系列，在发布HTTP / 2以来，该协议在15年多的时间内一直非常稳定。</target>
        </trans-unit>
        <trans-unit id="cd15a270847553d0286663fce338c3186c3904d8" translate="yes" xml:space="preserve">
          <source>Thanks to the &lt;a href=&quot;../headers/host&quot;&gt;&lt;code&gt;Host&lt;/code&gt;&lt;/a&gt; header, the ability to host different domains at the same IP address now allows server collocation.</source>
          <target state="translated">多亏了&lt;a href=&quot;../headers/host&quot;&gt; &lt;code&gt;Host&lt;/code&gt; &lt;/a&gt;标头，现在可以在同一IP地址上托管不同域的功能允许服务器并置。</target>
        </trans-unit>
        <trans-unit id="24cf3eddb29388191b3cd3ec808e71bc6c5fd48a" translate="yes" xml:space="preserve">
          <source>Thanks to the &lt;a href=&quot;../headers/host&quot;&gt;&lt;code&gt;Host&lt;/code&gt;&lt;/a&gt; header, the ability to host different domains at the same IP address now allows server colocation.</source>
          <target state="translated">多亏了&lt;a href=&quot;../headers/host&quot;&gt; &lt;code&gt;Host&lt;/code&gt; &lt;/a&gt;标头，现在可以在同一IP地址上托管不同域的功能允许服务器托管。</target>
        </trans-unit>
        <trans-unit id="0c0b92cdd8e1ab117b52ae806f278493aef32784" translate="yes" xml:space="preserve">
          <source>That way, you still upgrade insecure requests on your secure site, but the only monitoring policy is violated and reports insecure resources to your endpoint.</source>
          <target state="translated">这样一来,你仍然会在安全网站上升级不安全的请求,但唯一的监控策略被违反,并向你的终端报告不安全的资源。</target>
        </trans-unit>
        <trans-unit id="93ef0dd827103681fcee453b78be2ff14e1a261d" translate="yes" xml:space="preserve">
          <source>The</source>
          <target state="translated">The</target>
        </trans-unit>
        <trans-unit id="30bedea71a5adc4d8f862982f2915b1068fb6576" translate="yes" xml:space="preserve">
          <source>The &quot;Accept&quot; header field can be used by user agents to specify
   response media types that are acceptable.  Accept header fields can
   be used to indicate that the request is specifically limited to a
   small set of desired types, as in the case of a request for an
   in-line image.

     Accept = #( media-range [ accept-params ] )

     media-range    = ( &quot;*/*&quot;
                      / ( type &quot;/&quot; &quot;*&quot; )
                      / ( type &quot;/&quot; subtype )
                      ) *( OWS &quot;;&quot; OWS parameter )
     accept-params  = weight *( accept-ext )
     accept-ext = OWS &quot;;&quot; OWS token [ &quot;=&quot; ( token / quoted-string ) ]

   The asterisk &quot;*&quot; character is used to group media types into ranges,
   with &quot;*/*&quot; indicating all media types and &quot;type/*&quot; indicating all
   subtypes of that type.  The media-range can include media type
   parameters that are applicable to that range.

   Each media-range might be followed by zero or more applicable media
   type parameters (e.g., charset), an optional &quot;q&quot; parameter for
   indicating a relative weight (&lt;a href=&quot;#section-5.3.1&quot;&gt;Section 5.3.1&lt;/a&gt;), and then zero or more
   extension parameters.  The &quot;q&quot; parameter is necessary if any
   extensions (accept-ext) are present, since it acts as a separator
   between the two parameter sets.

      Note: Use of the &quot;q&quot; parameter name to separate media type
      parameters from Accept extension parameters is due to historical
      practice.  Although this prevents any media type parameter named
      &quot;q&quot; from being used with a media range, such an event is believed
      to be unlikely given the lack of any &quot;q&quot; parameters in the IANA 

      media type registry and the rare usage of any media type
      parameters in Accept.  Future media types are discouraged from
      registering any parameter named &quot;q&quot;.

   The example

     Accept: audio/*; q=0.2, audio/basic

   is interpreted as &quot;I prefer audio/basic, but send me any audio type
   if it is the best available after an 80% markdown in quality&quot;.

   A request without any Accept header field implies that the user agent
   will accept any media type in response.  If the header field is
   present in a request and none of the available representations for
   the response have a media type that is listed as acceptable, the
   origin server can either honor the header field by sending a 406 (Not
   Acceptable) response or disregard the header field by treating the
   response as if it is not subject to content negotiation.

   A more elaborate example is

     Accept: text/plain; q=0.5, text/html,
             text/x-dvi; q=0.8, text/x-c

   Verbally, this would be interpreted as &quot;text/html and text/x-c are
   the equally preferred media types, but if they do not exist, then
   send the text/x-dvi representation, and if that does not exist, send
   the text/plain representation&quot;.

   Media ranges can be overridden by more specific media ranges or
   specific media types.  If more than one media range applies to a
   given type, the most specific reference has precedence.  For example,

     Accept: text/*, text/plain, text/plain;format=flowed, */*

   have the following precedence:

   1.  text/plain;format=flowed

   2.  text/plain

   3.  text/*

   4.  */*

   The media type quality factor associated with a given type is
   determined by finding the media range with the highest precedence
   that matches the type.  For example, 

     Accept: text/*;q=0.3, text/html;q=0.7, text/html;level=1,
             text/html;level=2;q=0.4, */*;q=0.5

   would cause the following values to be associated:

   +-------------------+---------------+
   | Media Type        | Quality Value |
   +-------------------+---------------+
   | text/html;level=1 | 1             |
   | text/html         | 0.7           |
   | text/plain        | 0.3           |
   | image/jpeg        | 0.5           |
   | text/html;level=2 | 0.4           |
   | text/html;level=3 | 0.7           |
   +-------------------+---------------+

   Note: A user agent might be provided with a default set of quality
   values for certain media ranges.  However, unless the user agent is a
   closed system that cannot interact with other rendering agents, this
   default set ought to be configurable by the user.</source>
          <target state="translated">用户代理可以使用&amp;ldquo;接受&amp;rdquo;标头字段来指定可接受的响应媒体类型。接受标头字段可用于指示该请求被特定地限制为一小组所需类型，例如在请求嵌入式图像的情况下。接受=＃（media-range [接受参数]）media-range =（&amp;ldquo; * / *&amp;rdquo; /（类型&amp;ldquo; /&amp;rdquo;&amp;ldquo; *&amp;rdquo;）/（类型&amp;ldquo; /&amp;rdquo;子类型））*（OWS&amp;ldquo;;&amp;rdquo; OWS参数）accept-params = weight *（accept-ext）accept-ext = OWS&amp;ldquo;;&amp;rdquo; OWS令牌[&amp;ldquo; =&amp;rdquo;（令牌/带引号的字符串）]星号&amp;ldquo; *&amp;rdquo;字符用于将媒体类型分组为范围，其中&amp;ldquo; * / *&amp;rdquo;表示所有媒体类型，&amp;ldquo; * / *&amp;rdquo;表示所有媒体类型指示该类型的所有子类型。媒体范围可以包括适用于该范围的媒体类型参数。每个媒体范围后面都可以跟随零个或更多个适用的媒体类型参数（例如，字符集），用于指示相对权重的可选&amp;ldquo; q&amp;rdquo;参数（&lt;a href=&quot;#section-5.3.1&quot;&gt;第5.3.1节&lt;/a&gt;），然后添加零个或多个扩展参数。如果存在任何扩展名（accept-ext），则&amp;ldquo; q&amp;rdquo;参数是必需的，因为它充当两个参数集之间的分隔符。注意：由于历史上的惯例，使用&amp;ldquo; q&amp;rdquo;参数名称将媒体类型参数与&amp;ldquo;接受&amp;rdquo;扩展参数分开。尽管这可以阻止任何名为&amp;ldquo; q&amp;rdquo;的媒体类型参数与媒体范围一起使用，但考虑到IANA媒体类型注册表中缺少任何&amp;ldquo; q&amp;rdquo;参数并且很少使用任何媒体类型，因此认为这种事件不太可能发生接受中的参数。不鼓励将来的媒体类型注册任何名为&amp;ldquo; q&amp;rdquo;的参数。该示例接受：audio / *; q = 0.2，音频/基本解释为&amp;ldquo;我更喜欢音频/基本音频，但如果质量下降80％之后，如果音频音频是最可用的，请向我发送任何音频类型。&amp;rdquo;没有任何&amp;ldquo;接受&amp;rdquo;标头字段的请求表示用户代理将接受任何媒体类型作为响应。字段存在于请求中，并且没有可用的响应表示形式具有被列为可接受的媒体类型，原始服务器可以通过发送406（不可接受）响应来遵守标头字段，也可以通过处理忽略标头字段更详细的示例是&amp;ldquo;接受&amp;rdquo;：文本/纯文本； q = 0.5，文本/ html，文本/x-dvi；q=0.8，文本/ xc从字面上看，这将被解释因为&amp;ldquo; text / html和text / xc是同等首选的媒体类型，但如果它们不存在，然后发送text / x-dvi表示形式，如果不存在，则发送text / plain表示形式。&amp;rdquo;媒体范围可以被更特定的媒体范围或特定的媒体类型覆盖。如果一个给定的媒体范围不止一个类型，最具体的引用优先。例如，Accept：text / *，text / plain，text / plain; format = flowed，* / *具有以下优先级：1. text / plain; format = flowed 2. text / plain 3. text / * 4. * / *与给定类型关联的媒体类型质量因子是通过查找与该类型相匹配的最高优先级的媒体范围来确定的，例如，Accept：text / *; q = 0.3 ，text / html; q = 0.7，text / html; level = 1，text / html; level = 2; q = 0.4，* / *; q = 0.5将导致关联以下值：+ ------------------- + --------------- + |媒体类型|质量价值| + ------------------- + --------------- + | text / html; level = 1 | 1 | |文字/ HTML | 0.7 | |文字/纯文字| 0.3 | |图片/ jpeg | 0.5 | | text / html; level = 2 | 0.4 | | text / html; level = 3 | 0.7 | + ------------------- + --------------- +注意：可能为用户代理提供了一组默认值：某些媒体范围的质量值。但是，除非用户代理是无法与其他呈现代理进行交互的封闭系统，否则此默认设置应可由用户配置。7 | |文字/纯文字| 0.3 | |图片/ jpeg | 0.5 | | text / html; level = 2 | 0.4 | | text / html; level = 3 | 0.7 | + ------------------- + --------------- +注意：可能为用户代理提供了一组默认值：某些媒体范围的质量值。但是，除非用户代理是不能与其他呈现代理进行交互的封闭系统，否则此默认设置应可由用户配置。7 | |文字/纯文字| 0.3 | |图片/ jpeg | 0.5 | | text / html; level = 2 | 0.4 | | text / html; level = 3 | 0.7 | + ------------------- + --------------- +注意：可能为用户代理提供了一组默认值：某些媒体范围的质量值。但是，除非用户代理是不能与其他呈现代理进行交互的封闭系统，否则此默认设置应可由用户配置。除非用户代理是不能与其他呈现代理交互的封闭系统，否则此默认设置应由用户配置。除非用户代理是不能与其他呈现代理交互的封闭系统，否则此默认设置应由用户配置。</target>
        </trans-unit>
        <trans-unit id="e190709d5dcd5319bdd81105d4e02470d1c77a57" translate="yes" xml:space="preserve">
          <source>The &quot;Accept-Charset&quot; header field can be sent by a user agent to
   indicate what charsets are acceptable in textual response content.
   This field allows user agents capable of understanding more
   comprehensive or special-purpose charsets to signal that capability
   to an origin server that is capable of representing information in
   those charsets.

     Accept-Charset = 1#( ( charset / &quot;*&quot; ) [ weight ] )

   Charset names are defined in &lt;a href=&quot;#section-3.1.1.2&quot;&gt;Section 3.1.1.2&lt;/a&gt;.  A user agent MAY
   associate a quality value with each charset to indicate the user's
   relative preference for that charset, as defined in &lt;a href=&quot;#section-5.3.1&quot;&gt;Section 5.3.1&lt;/a&gt;.
   An example is

     Accept-Charset: iso-8859-5, unicode-1-1;q=0.8

   The special value &quot;*&quot;, if present in the Accept-Charset field,
   matches every charset that is not mentioned elsewhere in the
   Accept-Charset field.  If no &quot;*&quot; is present in an Accept-Charset
   field, then any charsets not explicitly mentioned in the field are
   considered &quot;not acceptable&quot; to the client.

   A request without any Accept-Charset header field implies that the
   user agent will accept any charset in response.  Most general-purpose
   user agents do not send Accept-Charset, unless specifically 

   configured to do so, because a detailed list of supported charsets
   makes it easier for a server to identify an individual by virtue of
   the user agent's request characteristics (&lt;a href=&quot;#section-9.7&quot;&gt;Section 9.7&lt;/a&gt;).

   If an Accept-Charset header field is present in a request and none of
   the available representations for the response has a charset that is
   listed as acceptable, the origin server can either honor the header
   field, by sending a 406 (Not Acceptable) response, or disregard the
   header field by treating the resource as if it is not subject to
   content negotiation.</source>
          <target state="translated">用户代理可以发送&amp;ldquo; Accept-Charset&amp;rdquo;标头字段，以指示文本响应内容中可接受的字符集。该字段允许能够理解更全面或特殊用途的字符集的用户代理将这一功能发送给能够在那些字符集中表示信息的原始服务器。 Accept-Charset = 1＃（（charset /&amp;ldquo; *&amp;rdquo;）[weight]）字符集名称在&lt;a href=&quot;#section-3.1.1.2&quot;&gt;第3.1.1.2节&lt;/a&gt;中定义。用户代理可以将质量值与每个字符集相关联，以指示用户对该字符集的相对偏好，如&lt;a href=&quot;#section-5.3.1&quot;&gt;第5.3.1节中&lt;/a&gt;所定义。。例如：Accept-Charset：iso-8859-5，unicode-1-1; q = 0.8特殊值&amp;ldquo; *&amp;rdquo;（如果存在于Accept-Charset字段中）则与Accept-Charset字段中未提及的所有字符集匹配。字符集字段。如果Accept-Charset字段中不存在&amp;ldquo; *&amp;rdquo;，则该字段中未明确提及的任何字符集都将被客户端视为&amp;ldquo;不可接受&amp;rdquo;。没有任何Accept-Charset标头字段的请求表示用户代理将接受任何字符集作为响应。除非经过特殊配置，否则大多数通用用户代理都不会发送Accept-Charset，因为受支持的字符集的详细列表使服务器更容易根据用户代理的请求特征来识别个人（&lt;a href=&quot;#section-9.7&quot;&gt;第9.7节）&lt;/a&gt;）。如果请求中存在一个Accept-Charset标头字段，并且响应的任何可用表示形式都没有列出可接受的字符集，则原始服务器可以通过发送406（不可接受）响应来遵守标头字段，或通过将资源视为未经内容协商的方式来忽略标头字段。</target>
        </trans-unit>
        <trans-unit id="94c1a4ee49201e6addf548dc16982d985feb45ac" translate="yes" xml:space="preserve">
          <source>The &quot;Accept-Encoding&quot; header field can be used by user agents to
   indicate what response content-codings (&lt;a href=&quot;#section-3.1.2.1&quot;&gt;Section 3.1.2.1&lt;/a&gt;) are
   acceptable in the response.  An &quot;identity&quot; token is used as a synonym
   for &quot;no encoding&quot; in order to communicate when no encoding is
   preferred.

     Accept-Encoding  = #( codings [ weight ] )
     codings          = content-coding / &quot;identity&quot; / &quot;*&quot;

   Each codings value MAY be given an associated quality value
   representing the preference for that encoding, as defined in
   &lt;a href=&quot;#section-5.3.1&quot;&gt;Section 5.3.1&lt;/a&gt;.  The asterisk &quot;*&quot; symbol in an Accept-Encoding field
   matches any available content-coding not explicitly listed in the
   header field.

   For example,

     Accept-Encoding: compress, gzip
     Accept-Encoding:
     Accept-Encoding: *
     Accept-Encoding: compress;q=0.5, gzip;q=1.0
     Accept-Encoding: gzip;q=1.0, identity; q=0.5, *;q=0

   A request without an Accept-Encoding header field implies that the
   user agent has no preferences regarding content-codings.  Although
   this allows the server to use any content-coding in a response, it
   does not imply that the user agent will be able to correctly process
   all encodings.

   A server tests whether a content-coding for a given representation is
   acceptable using these rules:

   1.  If no Accept-Encoding field is in the request, any content-coding
       is considered acceptable by the user agent. 

   2.  If the representation has no content-coding, then it is
       acceptable by default unless specifically excluded by the
       Accept-Encoding field stating either &quot;identity;q=0&quot; or &quot;*;q=0&quot;
       without a more specific entry for &quot;identity&quot;.

   3.  If the representation's content-coding is one of the
       content-codings listed in the Accept-Encoding field, then it is
       acceptable unless it is accompanied by a qvalue of 0.  (As
       defined in &lt;a href=&quot;#section-5.3.1&quot;&gt;Section 5.3.1&lt;/a&gt;, a qvalue of 0 means &quot;not acceptable&quot;.)

   4.  If multiple content-codings are acceptable, then the acceptable
       content-coding with the highest non-zero qvalue is preferred.

   An Accept-Encoding header field with a combined field-value that is
   empty implies that the user agent does not want any content-coding in
   response.  If an Accept-Encoding header field is present in a request
   and none of the available representations for the response have a
   content-coding that is listed as acceptable, the origin server SHOULD
   send a response without any content-coding.

      Note: Most HTTP/1.0 applications do not recognize or obey qvalues
      associated with content-codings.  This means that qvalues might
      not work and are not permitted with x-gzip or x-compress.</source>
          <target state="translated">用户代理可以使用&amp;ldquo; Accept-Encoding&amp;rdquo;头域来指示响应中可接受的响应内容编码（&lt;a href=&quot;#section-3.1.2.1&quot;&gt;第3.1.2.1节&lt;/a&gt;）。 &amp;ldquo;身份&amp;rdquo;令牌用作&amp;ldquo;不编码&amp;rdquo;的同义词，以便在不希望编码时进行通信。接受编码=＃（编码[权重]）编码=内容编码/&amp;ldquo;身份&amp;rdquo; /&amp;ldquo; *&amp;rdquo;可以给每个编码值一个相关联的质量值，该质量值表示该编码的偏好，如&lt;a href=&quot;#section-5.3.1&quot;&gt;第5.3.1节中&lt;/a&gt;所定义 。接受编码字段中的星号&amp;ldquo; *&amp;rdquo;符号与标头字段中未明确列出的任何可用内容编码匹配。例如，Accept-Encoding：compress，gzip Accept-Encoding：Accept-Encoding：* Accept-Encoding：compress; q = 0.5，gzip; q = 1.0 Accept-Encoding：gzip; q = 1.0，identity; q = 0.5，*; q = 0没有请求Accept-Encoding头字段的请求意味着用户代理对内容编码没有任何偏好。尽管这允许服务器在响应中使用任何内容编码，但这并不意味着用户代理将能够正确处理所有编码。服务器使用以下规则测试给定表示形式的内容编码是否可接受：1.如果请求中没有&amp;ldquo;接受编码&amp;rdquo;字段，用户代理认为任何内容编码都是可接受的。 2.如果表示形式没有内容编码，则默认情况下可接受，除非&amp;ldquo;接受编码&amp;rdquo;字段明确指出&amp;ldquo; identity; q = 0&amp;rdquo;或&amp;ldquo; *; q = 0&amp;rdquo;，而没有为&amp;ldquo;身份&amp;rdquo;。 3.如果表示的内容编码是&amp;ldquo;接受编码&amp;rdquo;字段中列出的内容编码之一，则可以接受，除非它带有q值0。（如没有&amp;ldquo;身份&amp;rdquo;的更具体条目。 3.如果表示的内容编码是&amp;ldquo;接受编码&amp;rdquo;字段中列出的内容编码之一，则可以接受，除非它带有q值0。（如没有&amp;ldquo;身份&amp;rdquo;的更具体条目。 3.如果表示的内容编码是&amp;ldquo;接受编码&amp;rdquo;字段中列出的内容编码之一，则可以接受，除非它带有q值0。（如&lt;a href=&quot;#section-5.3.1&quot;&gt;在5.3.1节中&lt;/a&gt;，q值为0表示&amp;ldquo;不可接受&amp;rdquo;。）4.如果可以接受多个内容编码，则首选具有最高非零q值的可接受内容编码。组合字段值为空的Accept-Encoding标头字段表示用户代理不希望任何内容编码作为响应。如果请求中存在一个Accept-Encoding头域，并且响应的任何可用表示都没有列出可接受的内容编码，则源服务器应该发送没有任何内容编码的响应。注意：大多数HTTP / 1.0应用程序不识别或遵循与内容编码关联的q值。这意味着qvalue可能不起作用，并且x-gzip或x-compress不允许使用。</target>
        </trans-unit>
        <trans-unit id="e583c40d3f3281ace1211bd3a8c4c5127953cb55" translate="yes" xml:space="preserve">
          <source>The &quot;Accept-Language&quot; header field can be used by user agents to
   indicate the set of natural languages that are preferred in the
   response.  Language tags are defined in &lt;a href=&quot;#section-3.1.3.1&quot;&gt;Section 3.1.3.1&lt;/a&gt;.

     Accept-Language = 1#( language-range [ weight ] )
     language-range  =
               &amp;lt;language-range, see &lt;a href=&quot;https://tools.ietf.org/html/rfc4647#section-2.1&quot;&gt;[RFC4647], Section&amp;nbsp;2.1&lt;/a&gt;&amp;gt;

   Each language-range can be given an associated quality value
   representing an estimate of the user's preference for the languages
   specified by that range, as defined in &lt;a href=&quot;#section-5.3.1&quot;&gt;Section 5.3.1&lt;/a&gt;.  For example,

     Accept-Language: da, en-gb;q=0.8, en;q=0.7

   would mean: &quot;I prefer Danish, but will accept British English and
   other types of English&quot;.

   A request without any Accept-Language header field implies that the
   user agent will accept any language in response.  If the header field
   is present in a request and none of the available representations for
   the response have a matching language tag, the origin server can
   either disregard the header field by treating the response as if it 

   is not subject to content negotiation or honor the header field by
   sending a 406 (Not Acceptable) response.  However, the latter is not
   encouraged, as doing so can prevent users from accessing content that
   they might be able to use (with translation software, for example).

   Note that some recipients treat the order in which language tags are
   listed as an indication of descending priority, particularly for tags
   that are assigned equal quality values (no value is the same as q=1).
   However, this behavior cannot be relied upon.  For consistency and to
   maximize interoperability, many user agents assign each language tag
   a unique quality value while also listing them in order of decreasing
   quality.  Additional discussion of language priority lists can be
   found in &lt;a href=&quot;https://tools.ietf.org/html/rfc4647#section-2.3&quot;&gt;Section&amp;nbsp;2.3 of [RFC4647]&lt;/a&gt;.

   For matching, &lt;a href=&quot;https://tools.ietf.org/html/rfc4647#section-3&quot;&gt;Section&amp;nbsp;3 of [RFC4647]&lt;/a&gt; defines several matching
   schemes.  Implementations can offer the most appropriate matching
   scheme for their requirements.  The &quot;Basic Filtering&quot; scheme
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc4647#section-3.3.1&quot;&gt;[RFC4647], Section&amp;nbsp;3.3.1&lt;/a&gt;) is identical to the matching scheme that
   was previously defined for HTTP in &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-14.4&quot;&gt;Section&amp;nbsp;14.4 of [RFC2616]&lt;/a&gt;.

   It might be contrary to the privacy expectations of the user to send
   an Accept-Language header field with the complete linguistic
   preferences of the user in every request (&lt;a href=&quot;#section-9.7&quot;&gt;Section 9.7&lt;/a&gt;).

   Since intelligibility is highly dependent on the individual user,
   user agents need to allow user control over the linguistic preference
   (either through configuration of the user agent itself or by
   defaulting to a user controllable system setting).  A user agent that
   does not provide such control to the user MUST NOT send an
   Accept-Language header field.

      Note: User agents ought to provide guidance to users when setting
      a preference, since users are rarely familiar with the details of
      language matching as described above.  For example, users might
      assume that on selecting &quot;en-gb&quot;, they will be served any kind of
      English document if British English is not available.  A user
      agent might suggest, in such a case, to add &quot;en&quot; to the list for
      better matching behavior.</source>
          <target state="translated">用户代理可以使用&amp;ldquo; Accept-Language&amp;rdquo;标头字段指示响应中首选的自然语言集。语言标签在&lt;a href=&quot;#section-3.1.3.1&quot;&gt;第3.1.3.1节&lt;/a&gt;中定义。 Accept-Language = 1＃（language-range [weight]）language-range = &amp;lt;language-range，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc4647#section-2.1&quot;&gt;[RFC4647]，第2.1节&lt;/a&gt; &amp;gt;可以为每个语言范围分配一个相关的质量值，该值表示用户对... ...的偏爱估计根据&lt;a href=&quot;#section-5.3.1&quot;&gt;第5.3.1节的&lt;/a&gt;定义，由该范围指定的语言。例如，Accept-Language：da，en-gb; q = 0.8，en; q = 0.7表示：&amp;ldquo;我更喜欢丹麦语，但会接受英式英语和其他类型的英语&amp;rdquo;。没有任何Accept-Language标头字段的请求表示用户代理将接受任何语言作为响应。如果请求中存在标头字段，并且响应的任何可用表示均没有匹配的语言标签，则源服务器可以通过将响应视为未经内容协商的方式来忽略标头字段，或者可以接受标头通过发送406（不可接受）响应来填写字段。但是，不鼓励后者，因为这样做会阻止用户访问他们可能使用的内容（例如，使用翻译软件）。请注意，某些收件人将语言标签的列出顺序视为优先级降序的指示，尤其是对于那些分配了相同质量值（没有值与q = 1相同）的标签。但是，不能依靠此行为。为了保持一致性并最大程度地提高互操作性，许多用户代理为每种语言标签分配了唯一的质量值，同时还按质量递减的顺序列出了它们。有关语言优先级列表的更多讨论，请参见许多用户代理为每种语言标签分配一个唯一的质量值，同时还按质量递减的顺序列出它们。有关语言优先级列表的更多讨论，请参见许多用户代理为每种语言标签分配一个唯一的质量值，同时还按质量递减的顺序列出它们。有关语言优先级列表的更多讨论，请参见&lt;a href=&quot;https://tools.ietf.org/html/rfc4647#section-2.3&quot;&gt;[RFC4647]的2.3节&lt;/a&gt;。为了匹配，&lt;a href=&quot;https://tools.ietf.org/html/rfc4647#section-3&quot;&gt;[RFC4647]的第3节&lt;/a&gt;定义了几种匹配方案。实现可以为其需求提供最合适的匹配方案。 &amp;ldquo;基本过滤&amp;rdquo;方案（&lt;a href=&quot;https://tools.ietf.org/html/rfc4647#section-3.3.1&quot;&gt;[RFC4647]，第3.3.1节&lt;/a&gt;）与先前在&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-14.4&quot;&gt;[RFC2616]的14.4节中&lt;/a&gt;为HTTP定义的匹配方案相同。在每个请求中发送带有用户完整语言偏好的Accept-Language标头字段可能与用户的隐私期望背道而驰（&lt;a href=&quot;#section-9.7&quot;&gt;第9.7节）&lt;/a&gt;）。由于可懂度高度依赖于各个用户，因此用户代理需要允许用户控制语言偏好（通过用户代理本身的配置或默认为用户可控制的系统设置）。不向用户提供此类控制的用户代理不得发送&amp;ldquo;接受语言&amp;rdquo;报头字段。注意：设置首选项时，用户代理应向用户提供指导，因为用户很少熟悉如上所述的语言匹配细节。例如，用户可能会假设选择&amp;ldquo; en-gb&amp;rdquo;时，如果没有英式英语，他们将获得任何种类的英语文档。在这种情况下，用户代理可能建议将&amp;ldquo; en&amp;rdquo;添加到列表中以实现更好的匹配行为。</target>
        </trans-unit>
        <trans-unit id="660e50878abbf252e2213e4a43a8c15147d72e0c" translate="yes" xml:space="preserve">
          <source>The &quot;Accept-Ranges&quot; header field allows a server to indicate that it
   supports range requests for the target resource.

     Accept-Ranges     = acceptable-ranges
     acceptable-ranges = 1#range-unit / &quot;none&quot;

   An origin server that supports byte-range requests for a given target
   resource MAY send

     Accept-Ranges: bytes

   to indicate what range units are supported.  A client MAY generate
   range requests without having received this header field for the
   resource involved.  Range units are defined in &lt;a href=&quot;#section-2&quot;&gt;Section 2&lt;/a&gt;.

   A server that does not support any kind of range request for the
   target resource MAY send

     Accept-Ranges: none

   to advise the client not to attempt a range request.</source>
          <target state="translated">服务器使用&amp;ldquo;接受范围&amp;rdquo;标头字段来指示它支持对目标资源的范围请求。接受范围=可接受范围可接受范围= 1＃range-unit /&amp;ldquo; none&amp;rdquo;支持给定目标资源的字节范围请求的原始服务器可以发送Accept-Ranges：字节来指示支持哪些范围单位。客户端可能会生成范围请求，而没有收到涉及资源的此报头字段。范围单位在&lt;a href=&quot;#section-2&quot;&gt;第2节&lt;/a&gt;中定义。不支持对目标资源的任何类型的范围请求的服务器可以发送Accept-Ranges：none来建议客户端不要尝试范围请求。</target>
        </trans-unit>
        <trans-unit id="07e147c0306bf45017b2c661d092871c17cc475c" translate="yes" xml:space="preserve">
          <source>The &quot;Age&quot; header field conveys the sender's estimate of the amount of
   time since the response was generated or successfully validated at
   the origin server.  Age values are calculated as specified in
   &lt;a href=&quot;#section-4.2.3&quot;&gt;Section 4.2.3&lt;/a&gt;.

     Age = delta-seconds

   The Age field-value is a non-negative integer, representing time in
   seconds (see &lt;a href=&quot;#section-1.2.1&quot;&gt;Section 1.2.1&lt;/a&gt;).

   The presence of an Age header field implies that the response was not
   generated or validated by the origin server for this request.
   However, lack of an Age header field does not imply the origin was
   contacted, since the response might have been received from an
   HTTP/1.0 cache that does not implement Age.</source>
          <target state="translated">&amp;ldquo;年龄&amp;rdquo;标头字段传达了发件人对自从在原始服务器上生成或成功验证响应以来的时间量的估计。年龄值按照&lt;a href=&quot;#section-4.2.3&quot;&gt;第4.2.3节中的&lt;/a&gt;规定计算 。 Age = delta-seconds Age字段值是一个非负整数，以秒为单位表示时间（请参见&lt;a href=&quot;#section-1.2.1&quot;&gt;1.2.1节&lt;/a&gt;）。 Age标头字段的存在意味着响应不是由原始服务器针对此请求生成或验证的。但是，缺少Age标头字段并不表示已联系源，因为可能已从未实现Age的HTTP / 1.0缓存接收到响应。</target>
        </trans-unit>
        <trans-unit id="1338498c252679bf6adfadb0f7074e7b148e3793" translate="yes" xml:space="preserve">
          <source>The &quot;Allow&quot; header field lists the set of methods advertised as
   supported by the target resource.  The purpose of this field is
   strictly to inform the recipient of valid request methods associated
   with the resource.

     Allow = #method

   Example of use:

     Allow: GET, HEAD, PUT

   The actual set of allowed methods is defined by the origin server at
   the time of each request.  An origin server MUST generate an Allow
   field in a 405 (Method Not Allowed) response and MAY do so in any
   other response.  An empty Allow field value indicates that the
   resource allows no methods, which might occur in a 405 response if
   the resource has been temporarily disabled by configuration.

   A proxy MUST NOT modify the Allow header field -- it does not need to
   understand all of the indicated methods in order to handle them
   according to the generic message handling rules.</source>
          <target state="translated">&quot;Allow &quot;头字段列出了目标资源所支持的广告方法集。这个字段的目的是严格地告知接收者与资源相关的有效请求方法。Allow=#method 使用示例。Allow:允许的方法的实际集合是由源服务器在每个请求时定义的。源服务器必须在405(方法不允许)响应中生成一个Allow字段,并且可以在任何其他响应中生成。一个空的Allow字段的值表示资源不允许使用方法,如果资源被配置暂时禁用,那么在405响应中可能会出现这种情况。代理必须不修改Allow头字段--它不需要理解所有指示的方法,以便根据通用消息处理规则来处理它们。</target>
        </trans-unit>
        <trans-unit id="833bc28aae892154d2187dc74fadd75ecc7a7e54" translate="yes" xml:space="preserve">
          <source>The &quot;Authorization&quot; header field allows a user agent to authenticate
   itself with an origin server -- usually, but not necessarily, after
   receiving a 401 (Unauthorized) response.  Its value consists of
   credentials containing the authentication information of the user
   agent for the realm of the resource being requested.

     Authorization = credentials

   If a request is authenticated and a realm specified, the same
   credentials are presumed to be valid for all other requests within
   this realm (assuming that the authentication scheme itself does not
   require otherwise, such as credentials that vary according to a
   challenge value or using synchronized clocks).

   A proxy forwarding a request MUST NOT modify any Authorization fields
   in that request.  See &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-3.2&quot;&gt;Section&amp;nbsp;3.2 of [RFC7234]&lt;/a&gt; for details of and
   requirements pertaining to handling of the Authorization field by
   HTTP caches.</source>
          <target state="translated">&amp;ldquo;授权&amp;rdquo;标头字段允许用户代理通过源服务器对自身进行身份验证-通常但不一定是在收到401（未经授权）响应之后。它的值由凭证组成，凭证包含用于所请求资源领域的用户代理的身份验证信息。授权=凭据如果请求已通过身份验证并指定了领域，则假定该凭据对该领域内的所有其他请求均有效（假设身份验证方案本身不需要其他身份，例如根据质询值而变化的凭据）或使用同步时钟）。转发请求的代理不得修改该请求中的任何&amp;ldquo;授权&amp;rdquo;字段。请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-3.2&quot;&gt;[RFC7234]的3.2节&lt;/a&gt; 有关通过HTTP缓存处理&amp;ldquo;授权&amp;rdquo;字段的详细信息和要求。</target>
        </trans-unit>
        <trans-unit id="7168d04cbf63301e6705540ed2ab42ae32147600" translate="yes" xml:space="preserve">
          <source>The &quot;Basic&quot; HTTP authentication scheme is defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7617&quot;&gt;RFC 7617&lt;/a&gt;, which transmits credentials as user ID/password pairs, encoded using base64.</source>
          <target state="translated">&lt;a href=&quot;https://tools.ietf.org/html/rfc7617&quot;&gt;RFC 7617中&lt;/a&gt;定义了&amp;ldquo;基本&amp;rdquo; HTTP身份验证方案，该方案将凭据作为用户ID /密码对传输，并使用base64进行编码。</target>
        </trans-unit>
        <trans-unit id="e6a4b6da05626e019facf6e5f03b1b90399b48bf" translate="yes" xml:space="preserve">
          <source>The &quot;Cache-Control&quot; header field is used to specify directives for
   caches along the request/response chain.  Such cache directives are
   unidirectional in that the presence of a directive in a request does
   not imply that the same directive is to be given in the response.

   A cache MUST obey the requirements of the Cache-Control directives
   defined in this section.  See &lt;a href=&quot;#section-5.2.3&quot;&gt;Section 5.2.3&lt;/a&gt; for information about how
   Cache-Control directives defined elsewhere are handled.

      Note: Some HTTP/1.0 caches might not implement Cache-Control.

   A proxy, whether or not it implements a cache, MUST pass cache
   directives through in forwarded messages, regardless of their
   significance to that application, since the directives might be
   applicable to all recipients along the request/response chain.  It is
   not possible to target a directive to a specific cache.

   Cache directives are identified by a token, to be compared
   case-insensitively, and have an optional argument, that can use both
   token and quoted-string syntax.  For the directives defined below
   that define arguments, recipients ought to accept both forms, even if
   one is documented to be preferred.  For any directive not defined by
   this specification, a recipient MUST accept both forms. 

     Cache-Control   = 1#cache-directive

     cache-directive = token [ &quot;=&quot; ( token / quoted-string ) ]

   For the cache directives defined below, no argument is defined (nor
   allowed) unless stated otherwise.</source>
          <target state="translated">&amp;ldquo; Cache-Control&amp;rdquo;头字段用于为请求/响应链中的缓存指定指令。这样的高速缓存指令是单向的，因为请求中存在指令并不意味着在响应中将给出相同的指令。缓存必须遵守本节中定义的Cache-Control指令的要求。请参阅&lt;a href=&quot;#section-5.2.3&quot;&gt;第5.2.3节&lt;/a&gt;有关如何处理在其他地方定义的Cache-Control指令的信息。注意：某些HTTP / 1.0缓存可能未实现Cache-Control。代理，无论是否实现缓存，都必须在转发的消息中传递缓存指令，无论它们对该应用程序的意义如何，因为该指令可能适用于请求/响应链中的所有接收者。无法将指令定向到特定的缓存。缓存指令由令牌标识，不区分大小写地进行比较，并具有可选参数，该参数可以同时使用令牌语法和带引号的字符串语法。对于下面定义的定义参数的指令，即使文档证明是首选格式，收件人也应接受两种格式。对于本规范未定义的任何指令，收件人必须接受两种形式。 Cache-Control = 1＃cache-directive缓存指令= token [&amp;ldquo; =&amp;rdquo;（token / quoted-string）]对于以下定义的cache指令，除非另有说明，否则未定义（不允许）自变量。</target>
        </trans-unit>
        <trans-unit id="ead8e33ac22c36beaaccc520e5c8f0383500fa6b" translate="yes" xml:space="preserve">
          <source>The &quot;Connection&quot; header field allows the sender to indicate desired
   control options for the current connection.  In order to avoid
   confusing downstream recipients, a proxy or gateway MUST remove or
   replace any received connection options before forwarding the
   message.

   When a header field aside from Connection is used to supply control
   information for or about the current connection, the sender MUST list
   the corresponding field-name within the Connection header field.  A
   proxy or gateway MUST parse a received Connection header field before
   a message is forwarded and, for each connection-option in this field,
   remove any header field(s) from the message with the same name as the
   connection-option, and then remove the Connection header field itself
   (or replace it with the intermediary's own connection options for the
   forwarded message).

   Hence, the Connection header field provides a declarative way of
   distinguishing header fields that are only intended for the immediate
   recipient (&quot;hop-by-hop&quot;) from those fields that are intended for all
   recipients on the chain (&quot;end-to-end&quot;), enabling the message to be
   self-descriptive and allowing future connection-specific extensions
   to be deployed without fear that they will be blindly forwarded by
   older intermediaries.

   The Connection header field's value has the following grammar:

     Connection        = 1#connection-option
     connection-option = token

   Connection options are case-insensitive.

   A sender MUST NOT send a connection option corresponding to a header
   field that is intended for all recipients of the payload.  For
   example, Cache-Control is never appropriate as a connection option
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2&quot;&gt;Section&amp;nbsp;5.2 of [RFC7234]&lt;/a&gt;). 

   The connection options do not always correspond to a header field
   present in the message, since a connection-specific header field
   might not be needed if there are no parameters associated with a
   connection option.  In contrast, a connection-specific header field
   that is received without a corresponding connection option usually
   indicates that the field has been improperly forwarded by an
   intermediary and ought to be ignored by the recipient.

   When defining new connection options, specification authors ought to
   survey existing header field names and ensure that the new connection
   option does not share the same name as an already deployed header
   field.  Defining a new connection option essentially reserves that
   potential field-name for carrying additional information related to
   the connection option, since it would be unwise for senders to use
   that field-name for anything else.

   The &quot;close&quot; connection option is defined for a sender to signal that
   this connection will be closed after completion of the response.  For
   example,

     Connection: close

   in either the request or the response header fields indicates that
   the sender is going to close the connection after the current
   request/response is complete (&lt;a href=&quot;#section-6.6&quot;&gt;Section 6.6&lt;/a&gt;).

   A client that does not support persistent connections MUST send the
   &quot;close&quot; connection option in every request message.

   A server that does not support persistent connections MUST send the
   &quot;close&quot; connection option in every response message that does not
   have a 1xx (Informational) status code.</source>
          <target state="translated">&amp;ldquo;连接&amp;rdquo;标头字段允许发送方指示当前连接的所需控制选项。为了避免混淆下游接收者，代理或网关必须在转发消息之前删除或替换任何接收到的连接选项。当使用Connection以外的头字段来提供有关当前连接或有关当前连接的控制信息时，发送方必须在Connection头字段内列出相应的字段名称。代理或网关必须在转发消息之前解析接收到的Connection头字段，对于该字段中的每个连接选项，请从消息中删除与连接选项同名的任何头字段，然后删除连接标头字段本身（或将其替换为中间的自己的转发邮件的连接选项）。因此，Connection标头字段提供了一种声明性方式，可将仅用于直接收件人（&amp;ldquo;逐跳&amp;rdquo;）的标头字段与用于链上所有收件人（&amp;ldquo;端到端&amp;rdquo;）的那些标头字段区分开&amp;rdquo;），从而使消息具有自我描述性，并允许将来部署特定于连接的扩展，而不必担心它们会被较旧的中介程序盲目转发。 Connection标头字段的值具有以下语法：Connection = 1＃connection-option connection-option =令牌连接选项不区分大小写。发送方不得发送与有效载荷的所有接收方对应的报头字段相对应的连接选项。例如，Cache-Control永远不适合作为连接选项（&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2&quot;&gt;[RFC7234]的5.2节&lt;/a&gt;）。连接选项并不总是与消息中存在的头字段相对应，因为如果没有参数与连接选项相关联，则可能不需要特定于连接的头字段。相反，在没有相应连接选项的情况下接收到的特定于连接的头字段通常指示该字段已被中介人不正确地转发，并且应该被接收者忽略。在定义新的连接选项时，规范作者应调查现有的标头字段名称，并确保新的连接选项不与已经部署的标头字段共享相同的名称。定义新的连接选项实际上会保留该潜在的字段名称，以携带与连接选项有关的其他信息，因为发送者在其他任何地方都使用该字段名是不明智的。为发送者定义了&amp;ldquo;关闭&amp;rdquo;连接选项，以指示在响应完成后将关闭此连接。例如，在请求或响应标头字段中的Connection：close表示发送方将在当前请求/响应完成后关闭连接（在请求或响应标头字段中的&amp;ldquo;关闭&amp;rdquo;表示发送方将在当前请求/响应完成后关闭连接（在请求或响应标头字段中的&amp;ldquo;关闭&amp;rdquo;表示发送方将在当前请求/响应完成后关闭连接（&lt;a href=&quot;#section-6.6&quot;&gt;6.6节&lt;/a&gt;）。不支持持久连接的客户端必须在每条请求消息中发送&amp;ldquo;关闭&amp;rdquo;连接选项。不支持持久连接的服务器必须在每个没有1xx（信息）状态代码的响应消息中发送&amp;ldquo;关闭&amp;rdquo;连接选项。</target>
        </trans-unit>
        <trans-unit id="f005d7daab665deae0b91cf8d9396978496c7fec" translate="yes" xml:space="preserve">
          <source>The &quot;Content-Encoding&quot; header field indicates what content codings
   have been applied to the representation, beyond those inherent in the
   media type, and thus what decoding mechanisms have to be applied in
   order to obtain data in the media type referenced by the Content-Type
   header field.  Content-Encoding is primarily used to allow a
   representation's data to be compressed without losing the identity of
   its underlying media type.

     Content-Encoding = 1#content-coding

   An example of its use is

     Content-Encoding: gzip

   If one or more encodings have been applied to a representation, the
   sender that applied the encodings MUST generate a Content-Encoding
   header field that lists the content codings in the order in which
   they were applied.  Additional information about the encoding
   parameters can be provided by other header fields not defined by this
   specification.

   Unlike Transfer-Encoding (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.3.1&quot;&gt;Section&amp;nbsp;3.3.1 of [RFC7230]&lt;/a&gt;), the codings
   listed in Content-Encoding are a characteristic of the
   representation; the representation is defined in terms of the coded
   form, and all other metadata about the representation is about the
   coded form unless otherwise noted in the metadata definition.
   Typically, the representation is only decoded just prior to rendering
   or analogous usage.

   If the media type includes an inherent encoding, such as a data
   format that is always compressed, then that encoding would not be
   restated in Content-Encoding even if it happens to be the same
   algorithm as one of the content codings.  Such a content coding would
   only be listed if, for some bizarre reason, it is applied a second
   time to form the representation.  Likewise, an origin server might
   choose to publish the same data as multiple representations that
   differ only in whether the coding is defined as part of Content-Type 

   or Content-Encoding, since some user agents will behave differently
   in their handling of each response (e.g., open a &quot;Save as ...&quot; dialog
   instead of automatic decompression and rendering of content).

   An origin server MAY respond with a status code of 415 (Unsupported
   Media Type) if a representation in the request message has a content
   coding that is not acceptable.</source>
          <target state="translated">&amp;ldquo; Content-Encoding&amp;rdquo;标头字段指示除了媒体类型所固有的内容编码之外，哪些内容编码已应用于表示形式，因此必须应用哪种解码机制才能获得Content-Reference所引用的媒体类型中的数据输入标题字段。内容编码主要用于允许压缩表示的数据，而不会丢失其基础媒体类型的身份。 Content-Encoding = 1＃content-coding它的用法示例是Content-Encoding：gzip如果一种表示形式已应用一种或多种编码，则应用了编码的发送者务必生成一个Content-Encoding头字段，该字段列出内容编码的应用顺序。关于编码参数的其他信息可以由本规范未定义的其他标头字段提供。与传输编码（&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.3.1&quot;&gt;[RFC7230]的3.3.1节&lt;/a&gt;），Content-Encoding中列出的编码是该表示的特征；该表示形式是根据编码形式定义的，并且有关该表示形式的所有其他元数据都是关于编码形式的，除非在元数据定义中另有说明。通常，仅在渲染或类似用法之前对表示进行解码。如果媒体类型包括固有编码，例如始终被压缩的数据格式，则即使碰巧是与内容编码之一相同的算法，该编码也不会在Content-Encoding中重述。仅出于某种奇怪的原因，将仅列出这种内容编码，如果第二次应用该内容编码以形成表示形式。同样原始服务器可能选择发布相同的数据，作为多个表示形式，它们的不同之处仅在于编码是定义为Content-Type还是Content-Encoding的一部分，因为某些用户代理在处理每个响应时的行为会有所不同（例如，打开&amp;ldquo;另存为...&amp;rdquo;对话框，而不是自动解压缩和呈现内容。如果请求消息中的表示具有不可接受的内容编码，则原始服务器可以用状态码415（不支持的媒体类型）进行响应。如果请求消息中的表示具有不可接受的内容编码，则原始服务器可以用状态码415（不支持的媒体类型）进行响应。如果请求消息中的表示具有不可接受的内容编码，则原始服务器可以用状态码415（不支持的媒体类型）进行响应。</target>
        </trans-unit>
        <trans-unit id="164d16f9f8916d272734f22f4029358169a82681" translate="yes" xml:space="preserve">
          <source>The &quot;Content-Language&quot; header field describes the natural language(s)
   of the intended audience for the representation.  Note that this
   might not be equivalent to all the languages used within the
   representation.

     Content-Language = 1#language-tag 

   Language tags are defined in &lt;a href=&quot;#section-3.1.3.1&quot;&gt;Section 3.1.3.1&lt;/a&gt;.  The primary purpose of
   Content-Language is to allow a user to identify and differentiate
   representations according to the users' own preferred language.
   Thus, if the content is intended only for a Danish-literate audience,
   the appropriate field is

     Content-Language: da

   If no Content-Language is specified, the default is that the content
   is intended for all language audiences.  This might mean that the
   sender does not consider it to be specific to any natural language,
   or that the sender does not know for which language it is intended.

   Multiple languages MAY be listed for content that is intended for
   multiple audiences.  For example, a rendition of the &quot;Treaty of
   Waitangi&quot;, presented simultaneously in the original Maori and English
   versions, would call for

     Content-Language: mi, en

   However, just because multiple languages are present within a
   representation does not mean that it is intended for multiple
   linguistic audiences.  An example would be a beginner's language
   primer, such as &quot;A First Lesson in Latin&quot;, which is clearly intended
   to be used by an English-literate audience.  In this case, the
   Content-Language would properly only include &quot;en&quot;.

   Content-Language MAY be applied to any media type -- it is not
   limited to textual documents.</source>
          <target state="translated">&amp;ldquo;内容语言&amp;rdquo;标题字段描述了表示形式的目标受众的自然语言。请注意，这可能并不等同于表示中使用的所有语言。 Content-Language = 1＃language-tag语言标签在&lt;a href=&quot;#section-3.1.3.1&quot;&gt;第3.1.3.1节&lt;/a&gt;中定义。内容语言的主要目的是允许用户根据用户自己喜欢的语言来识别和区分表示形式。因此，如果内容仅面向丹麦语读者，则适当的字段为Content-Language：da如果未指定Content-Language，则默认值为该内容针对所有语言的读者。这可能意味着发件人不认为它是特定于任何自然语言的，或者发件人不知道它打算使用哪种语言。可能会列出针对多种受众的内容使用多种语言。例如，在原始毛利语和英语版本中同时呈现的&amp;ldquo;怀唐伊条约&amp;rdquo;的译本将要求使用Content-Language：mi，zh_cn但是，仅仅因为表示中存在多种语言，并不意味着它打算用于多种语言的受众。一个例子是初学者的语言入门，例如&amp;ldquo;拉丁语入门&amp;rdquo;，显然是供有英语水平的听众使用的。在这种情况下，内容语言将只包含&amp;ldquo; en&amp;rdquo;。内容语言可以应用于任何媒体类型-不限于文本文档。在这种情况下，内容语言将只包含&amp;ldquo; en&amp;rdquo;。内容语言可以应用于任何媒体类型-不限于文本文档。在这种情况下，内容语言将只包含&amp;ldquo; en&amp;rdquo;。内容语言可以应用于任何媒体类型-不限于文本文档。</target>
        </trans-unit>
        <trans-unit id="befc0a5526257450f3dfb30b2d0dfe3ea24c1e2b" translate="yes" xml:space="preserve">
          <source>The &quot;Content-Location&quot; header field references a URI that can be used
   as an identifier for a specific resource corresponding to the
   representation in this message's payload.  In other words, if one
   were to perform a GET request on this URI at the time of this
   message's generation, then a 200 (OK) response would contain the same
   representation that is enclosed as payload in this message.

     Content-Location = absolute-URI / partial-URI

   The Content-Location value is not a replacement for the effective
   Request URI (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.5&quot;&gt;Section&amp;nbsp;5.5 of [RFC7230]&lt;/a&gt;).  It is representation
   metadata.  It has the same syntax and semantics as the header field
   of the same name defined for MIME body parts in &lt;a href=&quot;https://tools.ietf.org/html/rfc2557#section-4&quot;&gt;Section&amp;nbsp;4 of
   [RFC2557]&lt;/a&gt;.  However, its appearance in an HTTP message has some
   special implications for HTTP recipients. 

   If Content-Location is included in a 2xx (Successful) response
   message and its value refers (after conversion to absolute form) to a
   URI that is the same as the effective request URI, then the recipient
   MAY consider the payload to be a current representation of that
   resource at the time indicated by the message origination date.  For
   a GET (&lt;a href=&quot;#section-4.3.1&quot;&gt;Section 4.3.1&lt;/a&gt;) or HEAD (&lt;a href=&quot;#section-4.3.2&quot;&gt;Section 4.3.2&lt;/a&gt;) request, this is the
   same as the default semantics when no Content-Location is provided by
   the server.  For a state-changing request like PUT (&lt;a href=&quot;#section-4.3.4&quot;&gt;Section 4.3.4&lt;/a&gt;) or
   POST (&lt;a href=&quot;#section-4.3.3&quot;&gt;Section 4.3.3&lt;/a&gt;), it implies that the server's response contains
   the new representation of that resource, thereby distinguishing it
   from representations that might only report about the action (e.g.,
   &quot;It worked!&quot;).  This allows authoring applications to update their
   local copies without the need for a subsequent GET request.

   If Content-Location is included in a 2xx (Successful) response
   message and its field-value refers to a URI that differs from the
   effective request URI, then the origin server claims that the URI is
   an identifier for a different resource corresponding to the enclosed
   representation.  Such a claim can only be trusted if both identifiers
   share the same resource owner, which cannot be programmatically
   determined via HTTP.

   o  For a response to a GET or HEAD request, this is an indication
      that the effective request URI refers to a resource that is
      subject to content negotiation and the Content-Location
      field-value is a more specific identifier for the selected
      representation.

   o  For a 201 (Created) response to a state-changing method, a
      Content-Location field-value that is identical to the Location
      field-value indicates that this payload is a current
      representation of the newly created resource.

   o  Otherwise, such a Content-Location indicates that this payload is
      a representation reporting on the requested action's status and
      that the same report is available (for future access with GET) at
      the given URI.  For example, a purchase transaction made via a
      POST request might include a receipt document as the payload of
      the 200 (OK) response; the Content-Location field-value provides
      an identifier for retrieving a copy of that same receipt in the
      future.

   A user agent that sends Content-Location in a request message is
   stating that its value refers to where the user agent originally
   obtained the content of the enclosed representation (prior to any
   modifications made by that user agent).  In other words, the user
   agent is providing a back link to the source of the original
   representation. 

   An origin server that receives a Content-Location field in a request
   message MUST treat the information as transitory request context
   rather than as metadata to be saved verbatim as part of the
   representation.  An origin server MAY use that context to guide in
   processing the request or to save it for other uses, such as within
   source links or versioning metadata.  However, an origin server MUST
   NOT use such context information to alter the request semantics.

   For example, if a client makes a PUT request on a negotiated resource
   and the origin server accepts that PUT (without redirection), then
   the new state of that resource is expected to be consistent with the
   one representation supplied in that PUT; the Content-Location cannot
   be used as a form of reverse content selection identifier to update
   only one of the negotiated representations.  If the user agent had
   wanted the latter semantics, it would have applied the PUT directly
   to the Content-Location URI.</source>
          <target state="translated">&amp;ldquo; Content-Location&amp;rdquo;标头字段引用一个URI，该URI可用作与该消息的有效负载中的表示相对应的特定资源的标识符。换句话说，如果在生成此消息时要对此URI执行GET请求，则200（确定）响应将包含与该消息中包含的有效内容相同的表示形式。 Content-Location =绝对URI /部分URI Content-Location值不能替代有效的Request URI（&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.5&quot;&gt;[RFC7230]的5.5节&lt;/a&gt;）。它是表示元数据。它具有与&lt;a href=&quot;https://tools.ietf.org/html/rfc2557#section-4&quot;&gt;[RFC2557]的第4节中&lt;/a&gt;为MIME正文部分定义的相同名称的标头字段相同的语法和语义。。但是，它在HTTP消息中的出现对HTTP接收者有一些特殊的含义。如果Content-Location包含在2xx（成功）响应消息中，并且其值（转换为绝对格式后）引用与有效请求URI相同的URI，则接收者可以将有效载荷视为当前表示形式在消息始发日期指示的时间使用该资源。对于GET（&lt;a href=&quot;#section-4.3.1&quot;&gt;第4.3.1节&lt;/a&gt;）或HEAD（&lt;a href=&quot;#section-4.3.2&quot;&gt;第4.3.2节&lt;/a&gt;）请求，这与服务器未提供Content-Location时的默认语义相同。对于状态更改请求，例如PUT（&lt;a href=&quot;#section-4.3.4&quot;&gt;第4.3.4节&lt;/a&gt;）或POST（&lt;a href=&quot;#section-4.3.3&quot;&gt;第4.3.3 &lt;/a&gt;节）），则意味着服务器的响应包含该资源的新表示形式，从而将其与可能仅报告该操作的表示形式区分开（例如，&amp;ldquo;它起作用了！&amp;rdquo;）。这允许创作应用程序更新其本地副本，而无需后续的GET请求。如果Content-Location包含在2xx（成功）响应消息中，并且其字段值引用的是与有效请求URI不同的URI，则原始服务器会声明该URI是与所包含内容相对应的其他资源的标识符表示。仅当两个标识符共享相同的资源所有者（不能通过HTTP以编程方式确定）时，才能声明此声明。 o对于GET或HEAD请求的响应，这表明有效请求URI是指要进行内容协商的资源，并且Content-Location字段值是所选表示形式的更具体的标识符。 o对于状态更改方法的201（已创建）响应，与位置字段值相同的Content-Location字段值表示此有效负载是新创建资源的当前表示。 o否则，这样的Content-Location表示此有效负载是报告所请求操作状态的表示形式，并且相同的报告可用于给定URI（以供将来使用GET访问）。例如，通过POST请求进行的购买交易可能包括收据文档，作为200（OK）响应的有效内容； Content-Location字段值提供了一个标识符，用于将来检索同一张收据的副本。在请求消息中发送Content-Location的用户代理指出，其值是指该用户代理最初在何处获得所包含表示的内容（在该用户代理进行的任何修改之前）。换句话说，用户代理正在提供到原始表示源的反向链接。在请求消息中接收到Content-Location字段的源服务器必须将该信息视为临时请求上下文，而不是作为表示形式要逐字保存的元数据。原始服务器可以使用该上下文来指导处理请求或将其保存以用于其他用途，例如在源链接或版本控制元数据中。但是，源服务器不得使用此类上下文信息来更改请求语义。例如，如果客户端在协商的资源上发出PUT请求，并且原始服务器接受该PUT（无重定向），则该资源的新状态应与该PUT中提供的一个表示形式一致； Content-Location不能用作反向内容选择标识符的形式来仅更新协商的表示形式之一。如果用户代理想要后一种语义，它将直接将PUT应用到Content-Location URI。</target>
        </trans-unit>
        <trans-unit id="e94ff61628ee1556f9cb7b6e53cdb420e3640f8b" translate="yes" xml:space="preserve">
          <source>The &quot;Content-Range&quot; header field is sent in a single part 206
   (Partial Content) response to indicate the partial range of the
   selected representation enclosed as the message payload, sent in each
   part of a multipart 206 response to indicate the range enclosed
   within each body part, and sent in 416 (Range Not Satisfiable)
   responses to provide information about the selected representation.

     Content-Range       = byte-content-range
                         / other-content-range

     byte-content-range  = bytes-unit SP
                           ( byte-range-resp / unsatisfied-range )

     byte-range-resp     = byte-range &quot;/&quot; ( complete-length / &quot;*&quot; )
     byte-range          = first-byte-pos &quot;-&quot; last-byte-pos
     unsatisfied-range   = &quot;*/&quot; complete-length

     complete-length     = 1*DIGIT

     other-content-range = other-range-unit SP other-range-resp
     other-range-resp    = *CHAR 

   If a 206 (Partial Content) response contains a Content-Range header
   field with a range unit (&lt;a href=&quot;#section-2&quot;&gt;Section 2&lt;/a&gt;) that the recipient does not
   understand, the recipient MUST NOT attempt to recombine it with a
   stored representation.  A proxy that receives such a message SHOULD
   forward it downstream.

   For byte ranges, a sender SHOULD indicate the complete length of the
   representation from which the range has been extracted, unless the
   complete length is unknown or difficult to determine.  An asterisk
   character (&quot;*&quot;) in place of the complete-length indicates that the
   representation length was unknown when the header field was
   generated.

   The following example illustrates when the complete length of the
   selected representation is known by the sender to be 1234 bytes:

     Content-Range: bytes 42-1233/1234

   and this second example illustrates when the complete length is
   unknown:

     Content-Range: bytes 42-1233/*

   A Content-Range field value is invalid if it contains a
   byte-range-resp that has a last-byte-pos value less than its
   first-byte-pos value, or a complete-length value less than or equal
   to its last-byte-pos value.  The recipient of an invalid
   Content-Range MUST NOT attempt to recombine the received content with
   a stored representation.

   A server generating a 416 (Range Not Satisfiable) response to a
   byte-range request SHOULD send a Content-Range header field with an
   unsatisfied-range value, as in the following example:

     Content-Range: bytes */1234

   The complete-length in a 416 response indicates the current length of
   the selected representation.

   The Content-Range header field has no meaning for status codes that
   do not explicitly describe its semantic.  For this specification,
   only the 206 (Partial Content) and 416 (Range Not Satisfiable) status
   codes describe a meaning for Content-Range. 

   The following are examples of Content-Range values in which the
   selected representation contains a total of 1234 bytes:

   o  The first 500 bytes:

        Content-Range: bytes 0-499/1234

   o  The second 500 bytes:

        Content-Range: bytes 500-999/1234

   o  All except for the first 500 bytes:

        Content-Range: bytes 500-1233/1234

   o  The last 500 bytes:

        Content-Range: bytes 734-1233/1234</source>
          <target state="translated">在单部分206（部分内容）响应中发送&amp;ldquo; Content-Range&amp;rdquo;标头字段，以指示作为消息有效载荷包含的所选表示的部分范围，在多部分206响应的每个部分中发送以指示包含在其中的范围每个身体部位，并在416（无法满足范围）响应中发送，以提供有关所选表示形式的信息。内容范围=字节内容范围/其他内容范围字节内容范围=字节单位SP（字节范围resp /不满意范围）字节范围resp =字节范围&amp;ldquo; /&amp;rdquo;（完整-length /&amp;ldquo; *&amp;rdquo;）字节范围=第一个字节位置&amp;ldquo;-&amp;rdquo;最后一个字节位置未满足范围=&amp;ldquo; * /&amp;rdquo;complete-length complete-length = 1 * DIGIT other-content-range =其他范围单位SP other-range-resp other-range-resp = * CHAR如果206（部分内容）响应包含Content-Range标头字段使用范围单位（&lt;a href=&quot;#section-2&quot;&gt;第二节&lt;/a&gt;）接收者不理解的内容，接收者不得尝试将其与存储的表示形式重新组合。收到这样的消息的代理应该向下游转发它。对于字节范围，发送者应该指出从中提取范围的表示形式的完整长度，除非完整长度未知或难以确定。代替完整长度的星号字符（&amp;ldquo; *&amp;rdquo;）表示生成标题字段时表示长度未知。下面的示例说明发送方已知所选表示形式的完整长度为1234字节：Content-Range：字节42-1233 / 1234，而第二个示例说明何时未知完整长度：Content-Range：字节42-1233 / *如果Content-Range字段值包含的最后一个字节位置值小于其第一个字节位置值或完整长度值小于一个字节范围值，则该内容范围字段值无效或等于其最后一个字节的pos值。无效内容范围的接收者不得尝试将接收到的内容与存储的表示形式重新组合。产生对字节范围请求的416（Range Not Satisfiable）响应的服务器应该发送Content-Range头域，其值的范围不满足要求，如以下示例所示：Content-Range：bytes * / 1234 complete-length 416响应中的表示所选择表示的当前长度。对于未明确描述其语义的状态代码，Content-Range标头字段没有任何意义。对于此规范，仅206（部分内容）和416（范围不可满足）状态码描述了内容范围的含义。以下是Content-Range值的示例，其中所选表示形式总共包含1234个字节：o前500个字节：Content-Range：字节0-499 / 1234 o后500个字节：Content-Range：字节500- 999/1234 o除前500个字节外的所有内容：内容范围：字节500-1233 / 1234 o后500个字节：内容范围：字节734-1233 / 1234字节0-499 / 1234 o后500个字节：内容范围：字节500-999 / 1234 o除前500个字节外的所有内容：内容范围：字节500-1233 / 1234 o后500个字节：内容范围：字节734-1233 / 1234字节0-499 / 1234 o后500个字节：内容范围：字节500-999 / 1234 o除前500个字节外的所有内容：内容范围：字节500-1233 / 1234 o后500个字节：内容范围：字节734-1233 / 1234</target>
        </trans-unit>
        <trans-unit id="3c402cbbcb9ecb9297de91cbbec783939a3ff8f6" translate="yes" xml:space="preserve">
          <source>The &quot;Content-Type&quot; header field indicates the media type of the
   associated representation: either the representation enclosed in the
   message payload or the selected representation, as determined by the
   message semantics.  The indicated media type defines both the data
   format and how that data is intended to be processed by a recipient,
   within the scope of the received message semantics, after any content
   codings indicated by Content-Encoding are decoded.

     Content-Type = media-type 

   Media types are defined in &lt;a href=&quot;#section-3.1.1.1&quot;&gt;Section 3.1.1.1&lt;/a&gt;.  An example of the field
   is

     Content-Type: text/html; charset=ISO-8859-4

   A sender that generates a message containing a payload body SHOULD
   generate a Content-Type header field in that message unless the
   intended media type of the enclosed representation is unknown to the
   sender.  If a Content-Type header field is not present, the recipient
   MAY either assume a media type of &quot;application/octet-stream&quot;
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc2046#section-4.5.1&quot;&gt;[RFC2046], Section&amp;nbsp;4.5.1&lt;/a&gt;) or examine the data to determine its type.

   In practice, resource owners do not always properly configure their
   origin server to provide the correct Content-Type for a given
   representation, with the result that some clients will examine a
   payload's content and override the specified type.  Clients that do
   so risk drawing incorrect conclusions, which might expose additional
   security risks (e.g., &quot;privilege escalation&quot;).  Furthermore, it is
   impossible to determine the sender's intent by examining the data
   format: many data formats match multiple media types that differ only
   in processing semantics.  Implementers are encouraged to provide a
   means of disabling such &quot;content sniffing&quot; when it is used.</source>
          <target state="translated">&amp;ldquo; Content-Type&amp;rdquo;标头字段指示关联表示形式的媒体类型：消息有效负载中包含的表示形式，还是由消息语义确定的所选表示形式。在对由Content-Encoding指示的任何内容编码进行解码之后，所指示的媒体类型既定义了数据格式，又定义了接收者在接收的消息语义范围内打算如何处理该数据。 Content-Type =媒体类型媒体类型在&lt;a href=&quot;#section-3.1.1.1&quot;&gt;第3.1.1.1节&lt;/a&gt;中定义。该字段的一个示例是Content-Type：text / html; charset = ISO-8859-4除非包含的表示形式的预期媒体类型对于发送者是未知的，否则生成包含有效内容主体的消息的发送者应该在该消息中生成Content-Type头字段。如果不存在Content-Type头字段，则接收者可以假定媒体类型为&amp;ldquo; application / octet-stream&amp;rdquo;（&lt;a href=&quot;https://tools.ietf.org/html/rfc2046#section-4.5.1&quot;&gt;[RFC2046]，第4.5.1节）&lt;/a&gt;）或检查数据以确定其类型。实际上，资源所有者并不总是将其原始服务器正确配置为给定表示形式提供正确的Content-Type，结果是某些客户端将检查有效内容的内容并覆盖指定的类型。这样做的客户可能会得出错误的结论，这可能会带来其他安全风险（例如，&amp;ldquo;特权升级&amp;rdquo;）。此外，不可能通过检查数据格式来确定发送者的意图：许多数据格式与仅在处理语义上不同的多种媒体类型匹配。鼓励实现者提供一种在使用时禁用此类&amp;ldquo;内容嗅探&amp;rdquo;的方法。</target>
        </trans-unit>
        <trans-unit id="c0724161072ae90382f70ffbb3410a3dba3f3bf1" translate="yes" xml:space="preserve">
          <source>The &quot;Date&quot; header field represents the date and time at which the
   message was originated, having the same semantics as the Origination
   Date Field (orig-date) defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc5322#section-3.6.1&quot;&gt;Section&amp;nbsp;3.6.1 of [RFC5322]&lt;/a&gt;.  The
   field value is an HTTP-date, as defined in &lt;a href=&quot;#section-7.1.1.1&quot;&gt;Section 7.1.1.1&lt;/a&gt;.

     Date = HTTP-date

   An example is

     Date: Tue, 15 Nov 1994 08:12:31 GMT

   When a Date header field is generated, the sender SHOULD generate its
   field value as the best available approximation of the date and time
   of message generation.  In theory, the date ought to represent the
   moment just before the payload is generated.  In practice, the date
   can be generated at any time during message origination.

   An origin server MUST NOT send a Date header field if it does not
   have a clock capable of providing a reasonable approximation of the
   current instance in Coordinated Universal Time.  An origin server MAY
   send a Date header field if the response is in the 1xx
   (Informational) or 5xx (Server Error) class of status codes.  An
   origin server MUST send a Date header field in all other cases. 

   A recipient with a clock that receives a response message without a
   Date header field MUST record the time it was received and append a
   corresponding Date header field to the message's header section if it
   is cached or forwarded downstream.

   A user agent MAY send a Date header field in a request, though
   generally will not do so unless it is believed to convey useful
   information to the server.  For example, custom applications of HTTP
   might convey a Date if the server is expected to adjust its
   interpretation of the user's request based on differences between the
   user agent and server clocks.</source>
          <target state="translated">&amp;ldquo;日期&amp;rdquo;标头字段表示消息发起的日期和时间，其语义与&lt;a href=&quot;https://tools.ietf.org/html/rfc5322#section-3.6.1&quot;&gt;[RFC5322]的3.6.1节中&lt;/a&gt;定义的&amp;ldquo;起源日期&amp;rdquo;字段（原始日期）相同。字段值是HTTP日期，如&lt;a href=&quot;#section-7.1.1.1&quot;&gt;7.1.1.1节&lt;/a&gt;所定义。 Date = HTTP-date例如：Date：Tue，15 Nov 1994 08:12:31 GMT生成Date头字段时，发送方应生成其字段值，作为消息生成日期和时间的最佳可用近似值。从理论上讲，日期应该代表正好在生成有效负载之前的时刻。实际上，可以在消息发起期间的任何时间生成日期。如果原始服务器没有能够在协调世界时中提供当前实例的合理近似值的时钟，则它不得发送Date标头字段。如果响应在状态代码的1xx（信息）或5xx（服务器错误）类中，则原始服务器可以发送Date头字段。在所有其他情况下，原始服务器必须发送一个Date标头字段。带有时钟的接收方如果接收到没有Date头字段的响应消息，则必须记录接收时间，并且如果消息被缓存或转发到下游，则在消息的头部分附加一个相应的Date头字段。用户代理可以在请求中发送Date头字段，尽管通常不会这样做，除非它被认为可以将有用的信息传达给服务器。例如，如果期望服务器根据用户代理和服务器时钟之间的差异来调整其对用户请求的解释，则HTTP的自定义应用程序可能会传达一个日期。s标头节（如果已缓存或转发到下游）。用户代理可以在请求中发送Date头字段，尽管通常不会这样做，除非它被认为可以将有用的信息传达给服务器。例如，如果期望服务器根据用户代理和服务器时钟之间的差异来调整其对用户请求的解释，则HTTP的自定义应用程序可能会传达一个日期。s标头节（如果已缓存或转发到下游）。用户代理可以在请求中发送Date头字段，尽管通常不会这样做，除非它被认为可以将有用的信息传达给服务器。例如，如果期望服务器根据用户代理和服务器时钟之间的差异来调整其对用户请求的解释，则HTTP的自定义应用程序可能会传达一个日期。</target>
        </trans-unit>
        <trans-unit id="d5a2d6bec4db1f50bd741730e8b916c0b881dd31" translate="yes" xml:space="preserve">
          <source>The &quot;ETag&quot; header field in a response provides the current entity-tag
   for the selected representation, as determined at the conclusion of
   handling the request.  An entity-tag is an opaque validator for
   differentiating between multiple representations of the same
   resource, regardless of whether those multiple representations are
   due to resource state changes over time, content negotiation
   resulting in multiple representations being valid at the same time,
   or both.  An entity-tag consists of an opaque quoted string, possibly
   prefixed by a weakness indicator.

     ETag       = entity-tag

     entity-tag = [ weak ] opaque-tag
     weak       = %x57.2F ; &quot;W/&quot;, case-sensitive
     opaque-tag = DQUOTE *etagc DQUOTE
     etagc      = %x21 / %x23-7E / obs-text
                ; VCHAR except double quotes, plus obs-text

      Note: Previously, opaque-tag was defined to be a quoted-string
      (&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-3.11&quot;&gt;[RFC2616], Section&amp;nbsp;3.11&lt;/a&gt;); thus, some recipients might perform
      backslash unescaping.  Servers therefore ought to avoid backslash
      characters in entity tags.

   An entity-tag can be more reliable for validation than a modification
   date in situations where it is inconvenient to store modification
   dates, where the one-second resolution of HTTP date values is not
   sufficient, or where modification dates are not consistently
   maintained.

   Examples:

     ETag: &quot;xyzzy&quot;
     ETag: W/&quot;xyzzy&quot;
     ETag: &quot;&quot; 

   An entity-tag can be either a weak or strong validator, with strong
   being the default.  If an origin server provides an entity-tag for a
   representation and the generation of that entity-tag does not satisfy
   all of the characteristics of a strong validator (&lt;a href=&quot;#section-2.1&quot;&gt;Section 2.1&lt;/a&gt;), then
   the origin server MUST mark the entity-tag as weak by prefixing its
   opaque value with &quot;W/&quot; (case-sensitive).</source>
          <target state="translated">响应中的&amp;ldquo; ETag&amp;rdquo;标头字段为所选表示形式提供当前实体标签，该实体标签是在处理请求结束时确定的。实体标签是一个不透明的验证器，用于区分同一资源的多个表示形式，而不管这些多个表示形式是由于资源状态随时间而变化，内容协商导致多个表示形式同时有效还是两者兼而有之。实体标签由不透明的带引号的字符串组成，可能以漏洞指示器为前缀。 ETag =实体标签实体标签= [弱]不透明标签弱=％x57.2F; &amp;ldquo; W /&amp;rdquo;，区分大小写的不透明标签= DQUOTE * etagc DQUOTE etagc =％x21 /％x23-7E / obs-text； VCHAR除双引号外，加obs-text注意：以前，opaque-tag被定义为带引号的字符串（&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-3.11&quot;&gt;[RFC2616]，第3.11节&lt;/a&gt;）；因此，某些收件人可能会执行反斜杠转义。因此，服务器应避免在实体标签中使用反斜杠字符。在不方便存储修改日期，HTTP日期值的一秒分辨率不足或修改日期不能始终保持的情况下，实体标签比修改日期更可靠地进行验证。示例：ETag：&amp;ldquo; xyzzy&amp;rdquo; ETag：W /&amp;ldquo; xyzzy&amp;rdquo; ETag：&amp;ldquo;&amp;rdquo;实体标签可以是弱验证者，也可以是强验证者，默认情况下为强。如果原始服务器为表示提供了实体标签，并且该实体标签的生成不满足强验证器的所有特征（ &lt;a href=&quot;#section-2.1&quot;&gt;第2.1节）&lt;/a&gt;），然后原始服务器务必通过在实体标签的不透明值前面加上&amp;ldquo; W /&amp;rdquo;（区分大小写），将实体标签标记为弱标签。</target>
        </trans-unit>
        <trans-unit id="6cbf7e19bfd8298755a091ae5f476f70610c660d" translate="yes" xml:space="preserve">
          <source>The &quot;Expect&quot; header field in a request indicates a certain set of
   behaviors (expectations) that need to be supported by the server in
   order to properly handle this request.  The only such expectation
   defined by this specification is 100-continue.

     Expect  = &quot;100-continue&quot;

   The Expect field-value is case-insensitive.

   A server that receives an Expect field-value other than 100-continue
   MAY respond with a 417 (Expectation Failed) status code to indicate
   that the unexpected expectation cannot be met.

   A 100-continue expectation informs recipients that the client is
   about to send a (presumably large) message body in this request and
   wishes to receive a 100 (Continue) interim response if the
   request-line and header fields are not sufficient to cause an
   immediate success, redirect, or error response.  This allows the
   client to wait for an indication that it is worthwhile to send the
   message body before actually doing so, which can improve efficiency
   when the message body is huge or when the client anticipates that an
   error is likely (e.g., when sending a state-changing method, for the
   first time, without previously verified authentication credentials).

   For example, a request that begins with

     PUT /somewhere/fun HTTP/1.1
     Host: origin.example.com
     Content-Type: video/h264
     Content-Length: 1234567890987
     Expect: 100-continue


   allows the origin server to immediately respond with an error
   message, such as 401 (Unauthorized) or 405 (Method Not Allowed),
   before the client starts filling the pipes with an unnecessary data
   transfer.

   Requirements for clients:

   o  A client MUST NOT generate a 100-continue expectation in a request
      that does not include a message body.

   o  A client that will wait for a 100 (Continue) response before
      sending the request message body MUST send an Expect header field
      containing a 100-continue expectation. 

   o  A client that sends a 100-continue expectation is not required to
      wait for any specific length of time; such a client MAY proceed to
      send the message body even if it has not yet received a response.
      Furthermore, since 100 (Continue) responses cannot be sent through
      an HTTP/1.0 intermediary, such a client SHOULD NOT wait for an
      indefinite period before sending the message body.

   o  A client that receives a 417 (Expectation Failed) status code in
      response to a request containing a 100-continue expectation SHOULD
      repeat that request without a 100-continue expectation, since the
      417 response merely indicates that the response chain does not
      support expectations (e.g., it passes through an HTTP/1.0 server).

   Requirements for servers:

   o  A server that receives a 100-continue expectation in an HTTP/1.0
      request MUST ignore that expectation.

   o  A server MAY omit sending a 100 (Continue) response if it has
      already received some or all of the message body for the
      corresponding request, or if the framing indicates that there is
      no message body.

   o  A server that sends a 100 (Continue) response MUST ultimately send
      a final status code, once the message body is received and
      processed, unless the connection is closed prematurely.

   o  A server that responds with a final status code before reading the
      entire message body SHOULD indicate in that response whether it
      intends to close the connection or continue reading and discarding
      the request message (see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6.6&quot;&gt;Section&amp;nbsp;6.6 of [RFC7230]&lt;/a&gt;).

   An origin server MUST, upon receiving an HTTP/1.1 (or later)
   request-line and a complete header section that contains a
   100-continue expectation and indicates a request message body will
   follow, either send an immediate response with a final status code,
   if that status can be determined by examining just the request-line
   and header fields, or send an immediate 100 (Continue) response to
   encourage the client to send the request's message body.  The origin
   server MUST NOT wait for the message body before sending the 100
   (Continue) response.

   A proxy MUST, upon receiving an HTTP/1.1 (or later) request-line and
   a complete header section that contains a 100-continue expectation
   and indicates a request message body will follow, either send an
   immediate response with a final status code, if that status can be
   determined by examining just the request-line and header fields, or
   begin forwarding the request toward the origin server by sending a 

   corresponding request-line and header section to the next inbound
   server.  If the proxy believes (from configuration or past
   interaction) that the next inbound server only supports HTTP/1.0, the
   proxy MAY generate an immediate 100 (Continue) response to encourage
   the client to begin sending the message body.

      Note: The Expect header field was added after the original
      publication of HTTP/1.1 [&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC2068&lt;/a&gt;] as both the means to request an
      interim 100 (Continue) response and the general mechanism for
      indicating must-understand extensions.  However, the extension
      mechanism has not been used by clients and the must-understand
      requirements have not been implemented by many servers, rendering
      the extension mechanism useless.  This specification has removed
      the extension mechanism in order to simplify the definition and
      processing of 100-continue.</source>
          <target state="translated">请求中的&amp;ldquo;期望&amp;rdquo;标头字段指示服务器需要支持的一组特定行为（期望），以便正确处理此请求。本规范定义的唯一此类期望是100连续。 Expect =&amp;ldquo; 100-continue&amp;rdquo; Expect字段值不区分大小写。接收到非100连续期望字段值的服务器可能会以417（预期失败）状态码响应，以指示无法满足意外期望。 100连续期望值通知接收者该客户端即将在此请求中发送（可能很大）消息正文，并且如果请求行和标头字段不足以导致立即发送，则希望接收100（连续）临时响应成功，重定向，或错误响应。这允许客户端在实际发送之前等待值得发送消息正文的指示，这样可以提高效率，当消息正文很大或客户端预计可能发生错误时（例如，在发送状态时）第一次更改方法，而无需事先验证的身份验证凭据。例如，以PUT / somewhere / fun HTTP / 1.1开头的请求主机：origin.example.com内容类型：video / h264内容长度：1234567890987期望值：100-continue允许源服务器立即以错误进行响应客户端开始使用不必要的数据传输填充管道之前，显示401（未经授权）或405（不允许使用方法）之类的消息。对客户的要求：o客户端不得在不包含消息正文的请求中生成100个连续的期望值。 o在发送请求消息主体之前，将等待100（继续）响应的客户端必须发送包含100-继续期望的Expect头域。 o发送100连续期望值的客户端不需要等待任何特定时间长度；这样的客户端即使没有收到响应也可以继续发送消息体。此外，由于不能通过HTTP / 1.0中介发送100（继续）响应，因此这样的客户端在发送消息正文之前不应等待不确定的时间。o响应包含100连续期望的请求而接收到417（期望失败）状态码的客户端应在没有100继续期望的情况下重复该请求，因为417响应仅表示响应链不支持期望（例如，它通过HTTP / 1.0服务器）。服务器要求：o在HTTP / 1.0请求中接收到100个连续期望的服务器必须忽略该期望。 o如果服务器已经接收到相应请求的部分或全部消息正文，或者如果帧指示没有消息正文，则服务器可以忽略发送100（继续）响应。 o发送100（继续）响应的服务器必须最终发送最终状态码，一旦消息主体被接收和处理，除非连接过早关闭。 o在读取整个消息正文之前，使用最终状态代码响应的服务器应在该响应中指示它是打算关闭连接还是继续读取并丢弃请求消息（请参见&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6.6&quot;&gt;[RFC7230]的6.6节&lt;/a&gt;）。原始服务器务必在收到HTTP / 1.1（或更高版本）请求行和包含100连续期望值并指示将跟随请求消息主体的完整标头部分之后，发送带有最终状态代码的立即响应，是否可以仅通过检查请求行和标头字段确定该状态，还是发送立即100（继续）响应以鼓励客户端发送请求的消息正文。原始服务器在发送100（继续）响应之前，绝对不能等待消息正文。代理必须在收到HTTP / 1.1（或更高版本）请求行和包含100连续期望值并指示将跟随请求消息正文的完整标头部分之后，要么发送带有最终状态代码的立即响应，如果可以仅通过检查请求行和标头字段确定该状态，或者通过将相应的请求行和标头部分发送到下一个入站服务器来开始将请求转发到原始服务器。如果代理认为（通过配置或过去的交互）下一个入站服务器仅支持HTTP / 1.0，则代理可以生成立即100（继续）响应以鼓励客户端开始发送消息正文。注意：Expect标题字段是在原始发布的HTTP / 1.1 [如果代理认为（通过配置或过去的交互）下一个入站服务器仅支持HTTP / 1.0，则代理可以生成立即100（继续）响应以鼓励客户端开始发送消息正文。注意：Expect标题字段是在原始发布的HTTP / 1.1 [如果代理认为（通过配置或过去的交互）下一个入站服务器仅支持HTTP / 1.0，则代理可以生成立即100（继续）响应以鼓励客户端开始发送消息正文。注意：Expect标题字段是在原始发布的HTTP / 1.1 [&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC2068&lt;/a&gt;既是请求临时100（继续）响应的手段，又是指示必须理解的扩展的一般机制。但是，客户端尚未使用扩展机制，许多服务器尚未实现必须理解的要求，从而使扩展机制无用。该规范已删除扩展机制，以简化100连续的定义和处理。</target>
        </trans-unit>
        <trans-unit id="73ec74b4c3de0b0e8320b9c1e9209dc1703d5df1" translate="yes" xml:space="preserve">
          <source>The &quot;Expires&quot; header field gives the date/time after which the
   response is considered stale.  See &lt;a href=&quot;#section-4.2&quot;&gt;Section 4.2&lt;/a&gt; for further discussion
   of the freshness model.

   The presence of an Expires field does not imply that the original
   resource will change or cease to exist at, before, or after that
   time.

   The Expires value is an HTTP-date timestamp, as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.1&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.1&quot;&gt;7.1.1.1 of [RFC7231]&lt;/a&gt;.

     Expires = HTTP-date

   For example

     Expires: Thu, 01 Dec 1994 16:00:00 GMT

   A cache recipient MUST interpret invalid date formats, especially the
   value &quot;0&quot;, as representing a time in the past (i.e., &quot;already
   expired&quot;).

   If a response includes a Cache-Control field with the max-age
   directive (&lt;a href=&quot;#section-5.2.2.8&quot;&gt;Section 5.2.2.8&lt;/a&gt;), a recipient MUST ignore the Expires
   field.  Likewise, if a response includes the s-maxage directive
   (&lt;a href=&quot;#section-5.2.2.9&quot;&gt;Section 5.2.2.9&lt;/a&gt;), a shared cache recipient MUST ignore the Expires
   field.  In both these cases, the value in Expires is only intended
   for recipients that have not yet implemented the Cache-Control field.

   An origin server without a clock MUST NOT generate an Expires field
   unless its value represents a fixed time in the past (always expired)
   or its value has been associated with the resource by a system or
   user with a reliable clock.

   Historically, HTTP required the Expires field-value to be no more
   than a year in the future.  While longer freshness lifetimes are no
   longer prohibited, extremely large values have been demonstrated to
   cause problems (e.g., clock overflows due to use of 32-bit integers
   for time values), and many caches will evict a response far sooner
   than that.</source>
          <target state="translated">&amp;ldquo; Expires&amp;rdquo;标题字段提供日期/时间，在该日期/时间之后，响应被认为是过期的。有关新鲜度模型的进一步讨论，请参见&lt;a href=&quot;#section-4.2&quot;&gt;第4.2节&lt;/a&gt;。 Expires字段的存在并不意味着原始资源将在该时间之前，之后或之后改变或不再存在。 Expires值是HTTP日期时间戳，如&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.1&quot;&gt;[RFC7231]的7.1.1.1 &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.1&quot;&gt;节&lt;/a&gt;所定义。 Expires = HTTP-date例如Expires：Thu，01 Dec 1994 16:00:00 GMT缓存接收者必须将无效的日期格式（尤其是值&amp;ldquo; 0&amp;rdquo;）解释为表示过去的时间（即&amp;ldquo;已经过期&amp;rdquo;） ）。如果响应包含带有max-age指令的Cache-Control字段（&lt;a href=&quot;#section-5.2.2.8&quot;&gt;第5.2.2.8节&lt;/a&gt;），收件人必须忽略&amp;ldquo;过期&amp;rdquo;字段。同样，如果响应包含s-maxage指令（&lt;a href=&quot;#section-5.2.2.9&quot;&gt;第5.2.2.9节&lt;/a&gt;），共享的缓存接收者必须忽略Expires字段。在这两种情况下，Expires中的值仅适用于尚未实现Cache-Control字段的收件人。没有时钟的原始服务器不得生成Expires字段，除非其值表示过去的固定时间（总是过期），或者其值已由具有可靠时钟的系统或用户与资源相关联。从历史上看，HTTP要求Expires字段值在未来不超过一年。尽管不再禁止更长的刷新寿命，但是已经证明，过大的值会引起问题（例如，由于使用32位整数作为时间值而导致时钟溢出），并且许多缓存将比这更早地驱除响应。</target>
        </trans-unit>
        <trans-unit id="435ee716a99e236d6e9d74d1e773dafee502988a" translate="yes" xml:space="preserve">
          <source>The &quot;From&quot; header field contains an Internet email address for a
   human user who controls the requesting user agent.  The address ought
   to be machine-usable, as defined by &quot;mailbox&quot; in &lt;a href=&quot;https://tools.ietf.org/html/rfc5322#section-3.4&quot;&gt;Section&amp;nbsp;3.4 of
   [RFC5322]&lt;/a&gt;:

     From    = mailbox

     mailbox = &amp;lt;mailbox, see &lt;a href=&quot;https://tools.ietf.org/html/rfc5322#section-3.4&quot;&gt;[RFC5322], Section&amp;nbsp;3.4&lt;/a&gt;&amp;gt;

   An example is:

     From: webmaster@example.org

   The From header field is rarely sent by non-robotic user agents.  A
   user agent SHOULD NOT send a From header field without explicit
   configuration by the user, since that might conflict with the user's
   privacy interests or their site's security policy. 

   A robotic user agent SHOULD send a valid From header field so that
   the person responsible for running the robot can be contacted if
   problems occur on servers, such as if the robot is sending excessive,
   unwanted, or invalid requests.

   A server SHOULD NOT use the From header field for access control or
   authentication, since most recipients will assume that the field
   value is public information.</source>
          <target state="translated">&amp;ldquo;发件人&amp;rdquo;标头字段包含控制请求用户代理的人类用户的Internet电子邮件地址。该地址应该是机器可用的，如&lt;a href=&quot;https://tools.ietf.org/html/rfc5322#section-3.4&quot;&gt;[RFC5322]第3.4节中&lt;/a&gt;的&amp;ldquo;邮箱&amp;rdquo;所定义：发件人=邮箱邮箱= &amp;lt;邮箱，请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc5322#section-3.4&quot;&gt;[RFC5322]第3.4节&lt;/a&gt;&amp;gt;例如：发件人：webmaster@example.org&amp;ldquo;发件人&amp;rdquo;标头字段很少由非机器人用户代理发送。没有用户的明确配置，用户代理不应该发送From头字段，因为这可能与用户的隐私利益或他们站点的安全策略冲突。机器人用户代理应发送有效的From头字段，以便在服务器上发生问题（例如，机器人发送过多，不需要或无效的请求）时，可以联系负责运行机器人的人员。服务器不应该将From标头字段用于访问控制或身份验证，因为大多数接收者都将假定该字段值为公共信息。</target>
        </trans-unit>
        <trans-unit id="145f68a05a65e51d6c2dc78deb7c678abdc3112c" translate="yes" xml:space="preserve">
          <source>The &quot;HTTP Content Coding Registry&quot; defines the namespace for content
   coding names (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-4.2&quot;&gt;Section&amp;nbsp;4.2 of [RFC7230]&lt;/a&gt;).  The content coding registry
   is maintained at &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/http-parameters&quot;&gt;http://www.iana.org/assignments/http-parameters&lt;/a&gt;&amp;gt;.</source>
          <target state="translated">&amp;ldquo; HTTP内容编码注册表&amp;rdquo;定义了内容编码名称的名称空间（&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-4.2&quot;&gt;[RFC7230]的4.2节&lt;/a&gt;）。内容编码注册表位于&amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/http-parameters&quot;&gt;http://www.iana.org/assignments/http-parameters&lt;/a&gt; &amp;gt;。</target>
        </trans-unit>
        <trans-unit id="1a7b21f0cdc6fe3b27a7e8f318212ccc9bbfe4e2" translate="yes" xml:space="preserve">
          <source>The &quot;HTTP Content Coding Registry&quot; defines the namespace for content
   coding names (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-4.2&quot;&gt;Section&amp;nbsp;4.2 of [RFC7230]&lt;/a&gt;).  The content coding registry
   is maintained at &amp;lt;&lt;a href=&quot;https://www.iana.org/assignments/http-parameters&quot;&gt;http://www.iana.org/assignments/http-parameters&lt;/a&gt;&amp;gt;.</source>
          <target state="translated">&amp;ldquo; HTTP内容编码注册表&amp;rdquo;定义了内容编码名称的名称空间（&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-4.2&quot;&gt;[RFC7230]的4.2节&lt;/a&gt;）。内容编码注册表在&amp;lt; &lt;a href=&quot;https://www.iana.org/assignments/http-parameters&quot;&gt;http://www.iana.org/assignments/http-parameters&lt;/a&gt; &amp;gt;上维护。</target>
        </trans-unit>
        <trans-unit id="096c718821f30fce49e8b7b18bb3a8ea8e6712d1" translate="yes" xml:space="preserve">
          <source>The &quot;HTTP Content Coding Registry&quot; has been updated with the
   registrations below:

   +----------+----------------------------------------+---------------+
   | Name     | Description                            | Reference     |
   +----------+----------------------------------------+---------------+
   | identity | Reserved (synonym for &quot;no encoding&quot; in | &lt;a href=&quot;#section-5.3.4&quot;&gt;Section 5.3.4&lt;/a&gt; |
   |          | Accept-Encoding)                       |               |
   +----------+----------------------------------------+---------------+</source>
          <target state="translated">&amp;ldquo; HTTP内容编码注册表&amp;rdquo;已通过以下注册进行了更新：+ ---------- + ----------------------- ----------------- + --------------- + | 姓名| 描述 参考| + ---------- + -------------------------------------- -+ --------------- + | 身份| 保留（在| &lt;a href=&quot;#section-5.3.4&quot;&gt;第5.3.4节&lt;/a&gt; | | | |&amp;ldquo;接受编码&amp;rdquo;中为&amp;ldquo;无编码&amp;rdquo;的同义词）| | + ---------- + -------------------------------------- -+ --------------- +</target>
        </trans-unit>
        <trans-unit id="a5c1ee951a5c8eed58e62c23efb0f5396f9627c4" translate="yes" xml:space="preserve">
          <source>The &quot;HTTP Range Unit Registry&quot; defines the namespace for the range
   unit names and refers to their corresponding specifications.  The
   registry has been created and is now maintained at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/http-parameters&quot;&gt;http://www.iana.org/assignments/http-parameters&lt;/a&gt;&amp;gt;.</source>
          <target state="translated">&amp;ldquo; HTTP范围单位注册表&amp;rdquo;定义范围单位名称的名称空间，并引用其相应的规范。已经创建了注册表，现在可以在&amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/http-parameters&quot;&gt;http://www.iana.org/assignments/http-parameters&lt;/a&gt; &amp;gt;上维护该注册表。</target>
        </trans-unit>
        <trans-unit id="75f1995c2e9e10c3b1c547ec7aef2ed12aaf759a" translate="yes" xml:space="preserve">
          <source>The &quot;HTTP Range Unit Registry&quot; defines the namespace for the range
   unit names and refers to their corresponding specifications.  The
   registry has been created and is now maintained at
   &amp;lt;&lt;a href=&quot;https://www.iana.org/assignments/http-parameters&quot;&gt;http://www.iana.org/assignments/http-parameters&lt;/a&gt;&amp;gt;.</source>
          <target state="translated">&amp;ldquo; HTTP范围单元注册表&amp;rdquo;定义了范围单元名称的名称空间，并引用了它们的相应规范。已经创建了注册表，现在可以在&amp;lt; &lt;a href=&quot;https://www.iana.org/assignments/http-parameters&quot;&gt;http://www.iana.org/assignments/http-parameters&lt;/a&gt; &amp;gt;上维护该注册表。</target>
        </trans-unit>
        <trans-unit id="c05bfcc8f57df61bc6ed194b315d3b4b0050023f" translate="yes" xml:space="preserve">
          <source>The &quot;HTTP Transfer Coding Registry&quot; defines the namespace for
   transfer coding names.  It is maintained at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/http-parameters&quot;&gt;http://www.iana.org/assignments/http-parameters&lt;/a&gt;&amp;gt;.</source>
          <target state="translated">&amp;ldquo; HTTP传输编码注册表&amp;rdquo;定义了传输编码名称的名称空间。它在&amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/http-parameters&quot;&gt;http://www.iana.org/assignments/http-parameters&lt;/a&gt; &amp;gt;上维护。</target>
        </trans-unit>
        <trans-unit id="edbeb56a986b02337b75fd6710823d9b5e86a66f" translate="yes" xml:space="preserve">
          <source>The &quot;HTTP Transfer Coding Registry&quot; defines the namespace for
   transfer coding names.  It is maintained at
   &amp;lt;&lt;a href=&quot;https://www.iana.org/assignments/http-parameters&quot;&gt;http://www.iana.org/assignments/http-parameters&lt;/a&gt;&amp;gt;.</source>
          <target state="translated">&amp;ldquo; HTTP传输编码注册表&amp;rdquo;定义了传输编码名称的名称空间。它在&amp;lt; &lt;a href=&quot;https://www.iana.org/assignments/http-parameters&quot;&gt;http://www.iana.org/assignments/http-parameters&lt;/a&gt; &amp;gt;上维护。</target>
        </trans-unit>
        <trans-unit id="a0b8c24090cb7e4cccc52c9a6ee16a7c95a28e07" translate="yes" xml:space="preserve">
          <source>The &quot;HTTP Transfer Coding Registry&quot; has been updated with the
   registrations below:

   +------------+--------------------------------------+---------------+
   | Name       | Description                          | Reference     |
   +------------+--------------------------------------+---------------+
   | chunked    | Transfer in a series of chunks       | &lt;a href=&quot;#section-4.1&quot;&gt;Section 4.1&lt;/a&gt;   |
   | compress   | UNIX &quot;compress&quot; data format [&lt;a href=&quot;#ref-Welch&quot;&gt;Welch&lt;/a&gt;]  | &lt;a href=&quot;#section-4.2.1&quot;&gt;Section 4.2.1&lt;/a&gt; |
   | deflate    | &quot;deflate&quot; compressed data            | &lt;a href=&quot;#section-4.2.2&quot;&gt;Section 4.2.2&lt;/a&gt; |
   |            | ([&lt;a href=&quot;https://tools.ietf.org/html/rfc1951&quot;&gt;RFC1951&lt;/a&gt;]) inside the &quot;zlib&quot; data   |               |
   |            | format ([&lt;a href=&quot;https://tools.ietf.org/html/rfc1950&quot;&gt;RFC1950&lt;/a&gt;])                   |               |
   | gzip       | GZIP file format [&lt;a href=&quot;https://tools.ietf.org/html/rfc1952&quot;&gt;RFC1952&lt;/a&gt;]           | &lt;a href=&quot;#section-4.2.3&quot;&gt;Section 4.2.3&lt;/a&gt; |
   | x-compress | Deprecated (alias for compress)      | &lt;a href=&quot;#section-4.2.1&quot;&gt;Section 4.2.1&lt;/a&gt; |
   | x-gzip     | Deprecated (alias for gzip)          | &lt;a href=&quot;#section-4.2.3&quot;&gt;Section 4.2.3&lt;/a&gt; |
   +------------+--------------------------------------+---------------+</source>
          <target state="translated">&amp;ldquo; HTTP传输编码注册表&amp;rdquo;已通过以下注册进行了更新：+ ------------ + --------------------- ----------------- + --------------- + |姓名|描述参考| + ------------ + ------------------------------------ -+ --------------- + |大块|转移一系列的块| &lt;a href=&quot;#section-4.1&quot;&gt;第4.1节&lt;/a&gt; | |压缩| UNIX&amp;ldquo;压缩&amp;rdquo;数据格式[ &lt;a href=&quot;#ref-Welch&quot;&gt;Welch&lt;/a&gt; ] | &lt;a href=&quot;#section-4.2.1&quot;&gt;第4.2.1节&lt;/a&gt; | |放气&amp;ldquo;压缩&amp;rdquo;压缩数据| &lt;a href=&quot;#section-4.2.2&quot;&gt;第4.2.2节&lt;/a&gt; | | | （[ &lt;a href=&quot;https://tools.ietf.org/html/rfc1951&quot;&gt;RFC1951&lt;/a&gt; ]）内的&amp;ldquo; zlib&amp;rdquo;数据| | | |格式（[ &lt;a href=&quot;https://tools.ietf.org/html/rfc1950&quot;&gt;RFC1950&lt;/a&gt;]）| | | gzip | GZIP文件格式[ &lt;a href=&quot;https://tools.ietf.org/html/rfc1952&quot;&gt;RFC1952&lt;/a&gt; ] | &lt;a href=&quot;#section-4.2.3&quot;&gt;第4.2.3节&lt;/a&gt; | | x压缩|不推荐使用（压缩的别名）| &lt;a href=&quot;#section-4.2.1&quot;&gt;第4.2.1节&lt;/a&gt; | | x-gzip |不推荐使用（gzip的别名）| &lt;a href=&quot;#section-4.2.3&quot;&gt;第4.2.3节&lt;/a&gt; | + ------------ + ------------------------------------ -+ --------------- +</target>
        </trans-unit>
        <trans-unit id="49c73e0ff74e54cb4f5a88bc231df89416d0af4b" translate="yes" xml:space="preserve">
          <source>The &quot;HTTP&quot; entry in the upgrade token registry has been updated with
   the registration below:

   +-------+----------------------+----------------------+-------------+
   | Value | Description          | Expected Version     | Reference   |
   |       |                      | Tokens               |             |
   +-------+----------------------+----------------------+-------------+
   | HTTP  | Hypertext Transfer   | any DIGIT.DIGIT      | &lt;a href=&quot;#section-2.6&quot;&gt;Section 2.6&lt;/a&gt; |
   |       | Protocol             | (e.g, &quot;2.0&quot;)         |             |
   +-------+----------------------+----------------------+-------------+

   The responsible party is: &quot;IETF (iesg@ietf.org) - Internet
   Engineering Task Force&quot;.</source>
          <target state="translated">升级令牌注册表中的&amp;ldquo; HTTP&amp;rdquo;条目已通过以下注册进行了更新：+ ------- + ---------------------- + ---------------------- + ------------- + |价值|描述预期版本|参考| | | |代币| | + ------- + ---------------------- + ------------------ ---- + ------------- + | HTTP |超文本传输​​|任何DIGIT.DIGIT | &lt;a href=&quot;#section-2.6&quot;&gt;第2.6节&lt;/a&gt; | | |协议| （例如，&amp;ldquo; 2.0&amp;rdquo;）| | + ------- + ---------------------- + ------------------ ---- + ------------- +负责方是：&amp;ldquo; IETF（iesg@ietf.org）-Internet工程任务组&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="706b09d6ff20df56763add1c7636ec30c154eae9" translate="yes" xml:space="preserve">
          <source>The &quot;Host&quot; header field in a request provides the host and port
   information from the target URI, enabling the origin server to
   distinguish among resources while servicing requests for multiple
   host names on a single IP address.

     Host = uri-host [ &quot;:&quot; port ] ; &lt;a href=&quot;#section-2.7.1&quot;&gt;Section 2.7.1&lt;/a&gt;

   A client MUST send a Host header field in all HTTP/1.1 request
   messages.  If the target URI includes an authority component, then a
   client MUST send a field-value for Host that is identical to that
   authority component, excluding any userinfo subcomponent and its &quot;@&quot;
   delimiter (&lt;a href=&quot;#section-2.7.1&quot;&gt;Section 2.7.1&lt;/a&gt;).  If the authority component is missing or
   undefined for the target URI, then a client MUST send a Host header
   field with an empty field-value.

   Since the Host field-value is critical information for handling a
   request, a user agent SHOULD generate Host as the first header field
   following the request-line.

   For example, a GET request to the origin server for
   &amp;lt;http://www.example.org/pub/WWW/&amp;gt; would begin with:

     GET /pub/WWW/ HTTP/1.1
     Host: www.example.org

   A client MUST send a Host header field in an HTTP/1.1 request even if
   the request-target is in the absolute-form, since this allows the
   Host information to be forwarded through ancient HTTP/1.0 proxies
   that might not have implemented Host.

   When a proxy receives a request with an absolute-form of
   request-target, the proxy MUST ignore the received Host header field
   (if any) and instead replace it with the host information of the
   request-target.  A proxy that forwards such a request MUST generate a
   new Host field-value based on the received request-target rather than
   forward the received Host field-value.

   Since the Host header field acts as an application-level routing
   mechanism, it is a frequent target for malware seeking to poison a
   shared cache or redirect a request to an unintended server.  An
   interception proxy is particularly vulnerable if it relies on the
   Host field-value for redirecting requests to internal servers, or for
   use as a cache key in a shared cache, without first verifying that
   the intercepted connection is targeting a valid IP address for that
   host. 

   A server MUST respond with a 400 (Bad Request) status code to any
   HTTP/1.1 request message that lacks a Host header field and to any
   request message that contains more than one Host header field or a
   Host header field with an invalid field-value.</source>
          <target state="translated">请求中的&amp;ldquo;主机&amp;rdquo;标头字段提供了来自目标URI的主机和端口信息，使源服务器可以区分资源，同时为单个IP地址上的多个主机名的请求提供服务。 Host = uri-host [&amp;ldquo;：&amp;rdquo; port]; &lt;a href=&quot;#section-2.7.1&quot;&gt;2.7.1节&lt;/a&gt; 客户端必须在所有HTTP / 1.1请求消息中发送主机头字段。如果目标URI包含授权组件，则客户端必须发送与该授权组件相同的Host字段值，但不包括任何userinfo子组件及其&amp;ldquo; @&amp;rdquo;定界符（&lt;a href=&quot;#section-2.7.1&quot;&gt;第2.7.1节）&lt;/a&gt;）。如果缺少或未定义目标URI的权限组件，则客户端务必发送带有空字段值的主机标头字段。由于主机字段值是处理请求的关键信息，因此用户代理应在请求行之后生成主机作为第一个标头字段。例如，对&amp;lt;http://www.example.org/pub/WWW/&amp;gt;的原始服务器的GET请求将以：GET / pub / WWW / HTTP / 1.1主机：www.example.org客户端必须即使请求目标采用绝对形式，也要在HTTP / 1.1请求中发送Host标头字段，因为这允许通过可能尚未实现Host的古老HTTP / 1.0代理转发Host信息。当代理接收到具有绝对形式的请求目标的请求时，代理必须忽略接收到的主机头字段（如果有的话），而应将其替换为请求目标的主机信息。转发此类请求的代理必须基于接收到的请求目标生成一个新的Host字段值，而不是转发接收到的Host字段值。由于主机标头字段充当应用程序级路由机制，因此它经常成为恶意软件试图破坏共享缓存或将请求重定向到意外服务器的目标。如果侦听代理依靠Host字段值将请求重定向到内部服务器，或用作共享缓存中的缓存键，而没有先验证被侦听的连接是否针对该主机的有效IP地址，则该侦听代理特别容易受到攻击。对于任何缺少主机头字段的HTTP / 1.1请求消息，以及包含多个主机头字段或具有无效字段值的主机头字段的任何请求消息，服务器必须以400（错误请求）状态码进行响应。</target>
        </trans-unit>
        <trans-unit id="bf76981296c1a614d1d61fab43ab95f1d60e0e35" translate="yes" xml:space="preserve">
          <source>The &quot;Hypertext Transfer Protocol (HTTP) Authentication Scheme
   Registry&quot; defines the namespace for the authentication schemes in
   challenges and credentials.  It has been created and is now
   maintained at &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/http-authschemes&quot;&gt;http://www.iana.org/assignments/http-authschemes&lt;/a&gt;&amp;gt;.</source>
          <target state="translated">&amp;ldquo;超文本传输​​协议（HTTP）身份验证方案注册表&amp;rdquo;在质询和凭据中定义了身份验证方案的名称空间。它已创建，现在可以在&amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/http-authschemes&quot;&gt;http://www.iana.org/assignments/http-authschemes&lt;/a&gt; &amp;gt;中进行维护。</target>
        </trans-unit>
        <trans-unit id="002b5bb59e4ccc5e549506e4e0d88baf5e0fc60c" translate="yes" xml:space="preserve">
          <source>The &quot;Hypertext Transfer Protocol (HTTP) Authentication Scheme
   Registry&quot; defines the namespace for the authentication schemes in
   challenges and credentials.  It has been created and is now
   maintained at &amp;lt;&lt;a href=&quot;https://www.iana.org/assignments/http-authschemes&quot;&gt;http://www.iana.org/assignments/http-authschemes&lt;/a&gt;&amp;gt;.</source>
          <target state="translated">&amp;ldquo;超文本传输​​协议（HTTP）身份验证方案注册表&amp;rdquo;在质询和凭据中定义了身份验证方案的名称空间。它已创建，现在可以在&amp;lt; &lt;a href=&quot;https://www.iana.org/assignments/http-authschemes&quot;&gt;http://www.iana.org/assignments/http-authschemes&lt;/a&gt; &amp;gt;上进行维护。</target>
        </trans-unit>
        <trans-unit id="88cc8d3cf97af683587a5f4c1d90c4302b8b701f" translate="yes" xml:space="preserve">
          <source>The &quot;Hypertext Transfer Protocol (HTTP) Cache Directive Registry&quot;
   defines the namespace for the cache directives.  It has been created
   and is now maintained at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/http-cache-directives&quot;&gt;http://www.iana.org/assignments/http-cache-directives&lt;/a&gt;&amp;gt;.</source>
          <target state="translated">&amp;ldquo;超文本传输​​协议（HTTP）缓存指令注册表&amp;rdquo;定义了缓存指令的名称空间。它已创建，现在在&amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/http-cache-directives&quot;&gt;http://www.iana.org/assignments/http-cache-directives&lt;/a&gt; &amp;gt;中进行维护。</target>
        </trans-unit>
        <trans-unit id="bc8c370c2974e750cf997b37c57dc05857094eb4" translate="yes" xml:space="preserve">
          <source>The &quot;Hypertext Transfer Protocol (HTTP) Cache Directive Registry&quot;
   defines the namespace for the cache directives.  It has been created
   and is now maintained at
   &amp;lt;&lt;a href=&quot;https://www.iana.org/assignments/http-cache-directives&quot;&gt;http://www.iana.org/assignments/http-cache-directives&lt;/a&gt;&amp;gt;.</source>
          <target state="translated">&amp;ldquo;超文本传输​​协议（HTTP）缓存指令注册表&amp;rdquo;定义了缓存指令的名称空间。它已创建，现在可以在&amp;lt; &lt;a href=&quot;https://www.iana.org/assignments/http-cache-directives&quot;&gt;http://www.iana.org/assignments/http-cache-directives&lt;/a&gt; &amp;gt;上进行维护。</target>
        </trans-unit>
        <trans-unit id="b60962bbc448e0c8070e4bc5da2bd79c07e165d8" translate="yes" xml:space="preserve">
          <source>The &quot;Hypertext Transfer Protocol (HTTP) Method Registry&quot; defines the
   namespace for the request method token (&lt;a href=&quot;#section-4&quot;&gt;Section 4&lt;/a&gt;).  The method
   registry has been created and is now maintained at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/http-methods&quot;&gt;http://www.iana.org/assignments/http-methods&lt;/a&gt;&amp;gt;.</source>
          <target state="translated">&amp;ldquo;超文本传输​​协议（HTTP）方法注册表&amp;rdquo;定义了请求方法令牌的名称空间（&lt;a href=&quot;#section-4&quot;&gt;第4节&lt;/a&gt;）。方法注册表已创建，现在在&amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/http-methods&quot;&gt;http://www.iana.org/assignments/http-methods&lt;/a&gt; &amp;gt;上进行维护。</target>
        </trans-unit>
        <trans-unit id="9cd3990fda532be7bd6bbc9bf3f5b65d7f9043a9" translate="yes" xml:space="preserve">
          <source>The &quot;Hypertext Transfer Protocol (HTTP) Method Registry&quot; defines the
   namespace for the request method token (&lt;a href=&quot;#section-4&quot;&gt;Section 4&lt;/a&gt;).  The method
   registry has been created and is now maintained at
   &amp;lt;&lt;a href=&quot;https://www.iana.org/assignments/http-methods&quot;&gt;http://www.iana.org/assignments/http-methods&lt;/a&gt;&amp;gt;.</source>
          <target state="translated">&amp;ldquo;超文本传输​​协议（HTTP）方法注册表&amp;rdquo;定义了请求方法令牌的名称空间（&lt;a href=&quot;#section-4&quot;&gt;第4节&lt;/a&gt;）。方法注册表已创建，现在在&amp;lt; &lt;a href=&quot;https://www.iana.org/assignments/http-methods&quot;&gt;http://www.iana.org/assignments/http-methods&lt;/a&gt; &amp;gt;上进行维护。</target>
        </trans-unit>
        <trans-unit id="c7c8fd27b56ab4d4e5338d1c107879dea630f834" translate="yes" xml:space="preserve">
          <source>The &quot;Hypertext Transfer Protocol (HTTP) Method Registry&quot; has been
   populated with the registrations below:

   +---------+------+------------+---------------+
   | Method  | Safe | Idempotent | Reference     |
   +---------+------+------------+---------------+
   | CONNECT | no   | no         | &lt;a href=&quot;#section-4.3.6&quot;&gt;Section 4.3.6&lt;/a&gt; |
   | DELETE  | no   | yes        | &lt;a href=&quot;#section-4.3.5&quot;&gt;Section 4.3.5&lt;/a&gt; |
   | GET     | yes  | yes        | &lt;a href=&quot;#section-4.3.1&quot;&gt;Section 4.3.1&lt;/a&gt; |
   | HEAD    | yes  | yes        | &lt;a href=&quot;#section-4.3.2&quot;&gt;Section 4.3.2&lt;/a&gt; |
   | OPTIONS | yes  | yes        | &lt;a href=&quot;#section-4.3.7&quot;&gt;Section 4.3.7&lt;/a&gt; |
   | POST    | no   | no         | &lt;a href=&quot;#section-4.3.3&quot;&gt;Section 4.3.3&lt;/a&gt; |
   | PUT     | no   | yes        | &lt;a href=&quot;#section-4.3.4&quot;&gt;Section 4.3.4&lt;/a&gt; |
   | TRACE   | yes  | yes        | &lt;a href=&quot;#section-4.3.8&quot;&gt;Section 4.3.8&lt;/a&gt; |
   +---------+------+------------+---------------+</source>
          <target state="translated">&amp;ldquo;超文本传输​​协议（HTTP）方法注册表&amp;rdquo;已使用以下注册填充：+ --------- + ------ ++ ------------ + --------------- + |方法安全|等幂|参考| + --------- + ------ + ------------ + --------------- + |连接|没有没有&lt;a href=&quot;#section-4.3.6&quot;&gt;第4.3.6节&lt;/a&gt; | |删除没有是的&lt;a href=&quot;#section-4.3.5&quot;&gt;第4.3.5节&lt;/a&gt; | | GET |是的是的&lt;a href=&quot;#section-4.3.1&quot;&gt;第4.3.1节&lt;/a&gt; | |头|是的是的&lt;a href=&quot;#section-4.3.2&quot;&gt;第4.3.2节&lt;/a&gt; | |选项|是的是的&lt;a href=&quot;#section-4.3.7&quot;&gt;第4.3.7节&lt;/a&gt; | |发布|没有没有&lt;a href=&quot;#section-4.3.3&quot;&gt;第4.3.3节&lt;/a&gt; | |放置|没有是的&lt;a href=&quot;#section-4.3.4&quot;&gt;第4.3.4节&lt;/a&gt; | |追踪|是的是的&lt;a href=&quot;#section-4.3.8&quot;&gt;第4.3.8节&lt;/a&gt; | + --------- + ------ + ------------ + --------------- +</target>
        </trans-unit>
        <trans-unit id="af47de3832189b79659dd3c031cb9fcb9be1aa14" translate="yes" xml:space="preserve">
          <source>The &quot;Hypertext Transfer Protocol (HTTP) Status Code Registry&quot; defines
   the namespace for the response status-code token (&lt;a href=&quot;#section-6&quot;&gt;Section 6&lt;/a&gt;).  The
   status code registry is maintained at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/http-status-codes&quot;&gt;http://www.iana.org/assignments/http-status-codes&lt;/a&gt;&amp;gt;.

   This section replaces the registration procedure for HTTP Status
   Codes previously defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2817#section-7.1&quot;&gt;Section&amp;nbsp;7.1 of [RFC2817]&lt;/a&gt;.</source>
          <target state="translated">&amp;ldquo;超文本传输​​协议（HTTP）状态代码注册表&amp;rdquo;定义了响应状态代码令牌的名称空间（&lt;a href=&quot;#section-6&quot;&gt;第6节&lt;/a&gt;）。状态代码注册表位于&amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/http-status-codes&quot;&gt;http://www.iana.org/assignments/http-status-codes&lt;/a&gt; &amp;gt;。本部分替换了先前在&lt;a href=&quot;https://tools.ietf.org/html/rfc2817#section-7.1&quot;&gt;[RFC2817]的7.1节中&lt;/a&gt;定义的HTTP状态代码的注册过程。</target>
        </trans-unit>
        <trans-unit id="a45ba9e45b71e336091c29201d1b51a6f2a6fcc9" translate="yes" xml:space="preserve">
          <source>The &quot;Hypertext Transfer Protocol (HTTP) Status Code Registry&quot; defines
   the namespace for the response status-code token (&lt;a href=&quot;#section-6&quot;&gt;Section 6&lt;/a&gt;).  The
   status code registry is maintained at
   &amp;lt;&lt;a href=&quot;https://www.iana.org/assignments/http-status-codes&quot;&gt;http://www.iana.org/assignments/http-status-codes&lt;/a&gt;&amp;gt;.

   This section replaces the registration procedure for HTTP Status
   Codes previously defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2817#section-7.1&quot;&gt;Section&amp;nbsp;7.1 of [RFC2817]&lt;/a&gt;.</source>
          <target state="translated">&amp;ldquo;超文本传输​​协议（HTTP）状态代码注册表&amp;rdquo;定义了响应状态代码令牌的名称空间（&lt;a href=&quot;#section-6&quot;&gt;第6节&lt;/a&gt;）。状态代码注册表位于&amp;lt; &lt;a href=&quot;https://www.iana.org/assignments/http-status-codes&quot;&gt;http://www.iana.org/assignments/http-status-codes&lt;/a&gt; &amp;gt;。本部分替换了先前在&lt;a href=&quot;https://tools.ietf.org/html/rfc2817#section-7.1&quot;&gt;[RFC2817]的7.1节中&lt;/a&gt;定义的HTTP状态代码的注册过程。</target>
        </trans-unit>
        <trans-unit id="a4249a89b69736470c36f6442d2bdc76c91dde18" translate="yes" xml:space="preserve">
          <source>The &quot;Hypertext Transfer Protocol (HTTP) Status Code Registry&quot; located
   at &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/http-status-codes&quot;&gt;http://www.iana.org/assignments/http-status-codes&lt;/a&gt;&amp;gt; has been
   updated to include the registrations below:

   +-------+-----------------------+-------------+
   | Value | Description           | Reference   |
   +-------+-----------------------+-------------+
   | 206   | Partial Content       | &lt;a href=&quot;#section-4.1&quot;&gt;Section 4.1&lt;/a&gt; |
   | 416   | Range Not Satisfiable | &lt;a href=&quot;#section-4.4&quot;&gt;Section 4.4&lt;/a&gt; |
   +-------+-----------------------+-------------+</source>
          <target state="translated">位于&amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/http-status-codes&quot;&gt;http://www.iana.org/assignments/http-status-codes&lt;/a&gt; &amp;gt; 的&amp;ldquo;超文本传输​​协议（HTTP）状态代码注册表&amp;rdquo; 已更新，其中包括以下注册：+ ------- + ----------------------- + ------------- + |价值|描述参考| + ------- + ----------------------- + ------------- + | 206 |部分内容| &lt;a href=&quot;#section-4.1&quot;&gt;第4.1节&lt;/a&gt; | | 416 |范围无法满足| &lt;a href=&quot;#section-4.4&quot;&gt;第4.4节&lt;/a&gt; | + ------- + ----------------------- + ------------- +</target>
        </trans-unit>
        <trans-unit id="42357d7df40e3a7ed38e6ec9bc128df372e92eb1" translate="yes" xml:space="preserve">
          <source>The &quot;Hypertext Transfer Protocol (HTTP) Status Code Registry&quot; located
   at &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/http-status-codes&quot;&gt;http://www.iana.org/assignments/http-status-codes&lt;/a&gt;&amp;gt; has been
   updated with the registrations below:

   +-------+---------------------+-------------+
   | Value | Description         | Reference   |
   +-------+---------------------+-------------+
   | 304   | Not Modified        | &lt;a href=&quot;#section-4.1&quot;&gt;Section 4.1&lt;/a&gt; |
   | 412   | Precondition Failed | &lt;a href=&quot;#section-4.2&quot;&gt;Section 4.2&lt;/a&gt; |
   +-------+---------------------+-------------+</source>
          <target state="translated">位于&amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/http-status-codes&quot;&gt;http://www.iana.org/assignments/http-status-codes&lt;/a&gt; &amp;gt; 的&amp;ldquo;超文本传输​​协议（HTTP）状态代码注册表&amp;rdquo; 已通过以下注册进行了更新：+ ------- + --------------------- + ------------- + |价值|描述参考| + ------- + --------------------- + ------------- + | 304 |未修改| &lt;a href=&quot;#section-4.1&quot;&gt;第4.1节&lt;/a&gt; | | 412 |前提条件失败| &lt;a href=&quot;#section-4.2&quot;&gt;第4.2节&lt;/a&gt; | + ------- + --------------------- + ------------- +</target>
        </trans-unit>
        <trans-unit id="6373f51fbfb2756123d6ebe8d028d312dde91148" translate="yes" xml:space="preserve">
          <source>The &quot;Hypertext Transfer Protocol (HTTP) Status Code Registry&quot; located
   at &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/http-status-codes&quot;&gt;http://www.iana.org/assignments/http-status-codes&lt;/a&gt;&amp;gt; has been
   updated with the registrations below:

   +-------+-------------------------------+-------------+
   | Value | Description                   | Reference   |
   +-------+-------------------------------+-------------+
   | 401   | Unauthorized                  | &lt;a href=&quot;#section-3.1&quot;&gt;Section 3.1&lt;/a&gt; |
   | 407   | Proxy Authentication Required | &lt;a href=&quot;#section-3.2&quot;&gt;Section 3.2&lt;/a&gt; |
   +-------+-------------------------------+-------------+</source>
          <target state="translated">位于&amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/http-status-codes&quot;&gt;http://www.iana.org/assignments/http-status-codes&lt;/a&gt; &amp;gt; 的&amp;ldquo;超文本传输​​协议（HTTP）状态代码注册表&amp;rdquo; 已通过以下注册进行了更新：+ ------- + ------------------------------- + ------------- + |价值|描述参考| + ------- + ------------------------------- + --------- ---- + | 401 |未经授权| &lt;a href=&quot;#section-3.1&quot;&gt;第3.1节&lt;/a&gt; | | 407 |需要代理身份验证| &lt;a href=&quot;#section-3.2&quot;&gt;第3.2节&lt;/a&gt; | + ------- + ------------------------------- + --------- ---- +</target>
        </trans-unit>
        <trans-unit id="0d233463e7c00bea493b97cf8c9268be036e2061" translate="yes" xml:space="preserve">
          <source>The &quot;Hypertext Transfer Protocol (HTTP) Status Code Registry&quot; located
   at &amp;lt;&lt;a href=&quot;https://www.iana.org/assignments/http-status-codes&quot;&gt;http://www.iana.org/assignments/http-status-codes&lt;/a&gt;&amp;gt; has been
   updated to include the registrations below:

   +-------+-----------------------+-------------+
   | Value | Description           | Reference   |
   +-------+-----------------------+-------------+
   | 206   | Partial Content       | &lt;a href=&quot;#section-4.1&quot;&gt;Section 4.1&lt;/a&gt; |
   | 416   | Range Not Satisfiable | &lt;a href=&quot;#section-4.4&quot;&gt;Section 4.4&lt;/a&gt; |
   +-------+-----------------------+-------------+</source>
          <target state="translated">位于&amp;lt; &lt;a href=&quot;https://www.iana.org/assignments/http-status-codes&quot;&gt;http://www.iana.org/assignments/http-status-codes&lt;/a&gt; &amp;gt;的&amp;ldquo;超文本传输​​协议（HTTP）状态代码注册表&amp;rdquo;已更新为包括以下注册：+ ------- + ----------------------- + ------------- + |价值|描述参考| + ------- + ----------------------- + ------------- + | 206 |部分内容|&lt;a href=&quot;#section-4.1&quot;&gt;第4.1节&lt;/a&gt;| | 416 |范围无法满足|&lt;a href=&quot;#section-4.4&quot;&gt;第4.4节&lt;/a&gt;| + ------- + ----------------------- + ------------- +</target>
        </trans-unit>
        <trans-unit id="34f1f814c2cf44d9372988a246bfd9ac2b6e5b07" translate="yes" xml:space="preserve">
          <source>The &quot;Hypertext Transfer Protocol (HTTP) Status Code Registry&quot; located
   at &amp;lt;&lt;a href=&quot;https://www.iana.org/assignments/http-status-codes&quot;&gt;http://www.iana.org/assignments/http-status-codes&lt;/a&gt;&amp;gt; has been
   updated with the registrations below:

   +-------+---------------------+-------------+
   | Value | Description         | Reference   |
   +-------+---------------------+-------------+
   | 304   | Not Modified        | &lt;a href=&quot;#section-4.1&quot;&gt;Section 4.1&lt;/a&gt; |
   | 412   | Precondition Failed | &lt;a href=&quot;#section-4.2&quot;&gt;Section 4.2&lt;/a&gt; |
   +-------+---------------------+-------------+</source>
          <target state="translated">位于&amp;lt; &lt;a href=&quot;https://www.iana.org/assignments/http-status-codes&quot;&gt;http://www.iana.org/assignments/http-status-codes&lt;/a&gt; &amp;gt;的&amp;ldquo;超文本传输​​协议（HTTP）状态代码注册表&amp;rdquo;已通过以下注册进行了更新：+ ------- + --------------------- + ------------- + |价值|描述参考| + ------- + --------------------- + ------------- + | 304 |未修改|&lt;a href=&quot;#section-4.1&quot;&gt;第4.1节&lt;/a&gt;| | 412 |前提条件失败|&lt;a href=&quot;#section-4.2&quot;&gt;第4.2节&lt;/a&gt;| + ------- + --------------------- + ------------- +</target>
        </trans-unit>
        <trans-unit id="d11128a3063d582f33a0c37f1b802fe903c747b9" translate="yes" xml:space="preserve">
          <source>The &quot;Hypertext Transfer Protocol (HTTP) Status Code Registry&quot; located
   at &amp;lt;&lt;a href=&quot;https://www.iana.org/assignments/http-status-codes&quot;&gt;http://www.iana.org/assignments/http-status-codes&lt;/a&gt;&amp;gt; has been
   updated with the registrations below:

   +-------+-------------------------------+-------------+
   | Value | Description                   | Reference   |
   +-------+-------------------------------+-------------+
   | 401   | Unauthorized                  | &lt;a href=&quot;#section-3.1&quot;&gt;Section 3.1&lt;/a&gt; |
   | 407   | Proxy Authentication Required | &lt;a href=&quot;#section-3.2&quot;&gt;Section 3.2&lt;/a&gt; |
   +-------+-------------------------------+-------------+</source>
          <target state="translated">位于&amp;lt; &lt;a href=&quot;https://www.iana.org/assignments/http-status-codes&quot;&gt;http://www.iana.org/assignments/http-status-codes&lt;/a&gt; &amp;gt;的&amp;ldquo;超文本传输​​协议（HTTP）状态代码注册表&amp;rdquo;已通过以下注册进行了更新：+ ------- + ------------------------------- + ------------- + | 价值| 描述 参考| + ------- + ------------------------------- + --------- ---- + | 401 | 未经授权| &lt;a href=&quot;#section-3.1&quot;&gt;第3.1节&lt;/a&gt;| | 407 | 需要代理身份验证| &lt;a href=&quot;#section-3.2&quot;&gt;第3.2节&lt;/a&gt;| + ------- + ------------------------------- + --------- ---- +</target>
        </trans-unit>
        <trans-unit id="5cad05fd1eebfb52b696d9b41f75945bfa2216cd" translate="yes" xml:space="preserve">
          <source>The &quot;Hypertext Transfer Protocol (HTTP) Upgrade Token Registry&quot;
   defines the namespace for protocol-name tokens used to identify
   protocols in the Upgrade header field.  The registry is maintained at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/http-upgrade-tokens&quot;&gt;http://www.iana.org/assignments/http-upgrade-tokens&lt;/a&gt;&amp;gt;.</source>
          <target state="translated">&amp;ldquo;超文本传输​​协议（HTTP）升级令牌注册表&amp;rdquo;定义了用于在升级头字段中标识协议的协议名称令牌的名称空间。该注册表位于&amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/http-upgrade-tokens&quot;&gt;http://www.iana.org/assignments/http-upgrade-tokens&lt;/a&gt; &amp;gt;。</target>
        </trans-unit>
        <trans-unit id="19825e8c6c98e1d92761bcca24b5b2209be12407" translate="yes" xml:space="preserve">
          <source>The &quot;Hypertext Transfer Protocol (HTTP) Upgrade Token Registry&quot;
   defines the namespace for protocol-name tokens used to identify
   protocols in the Upgrade header field.  The registry is maintained at
   &amp;lt;&lt;a href=&quot;https://www.iana.org/assignments/http-upgrade-tokens&quot;&gt;http://www.iana.org/assignments/http-upgrade-tokens&lt;/a&gt;&amp;gt;.</source>
          <target state="translated">&amp;ldquo;超文本传输​​协议（HTTP）升级令牌注册表&amp;rdquo;定义了用于在升级头字段中标识协议的协议名称令牌的名称空间。该注册表位于&amp;lt; &lt;a href=&quot;https://www.iana.org/assignments/http-upgrade-tokens&quot;&gt;http://www.iana.org/assignments/http-upgrade-tokens&lt;/a&gt; &amp;gt;。</target>
        </trans-unit>
        <trans-unit id="dff627671b970f06b09a819242fd5432d30d4c1d" translate="yes" xml:space="preserve">
          <source>The &quot;Hypertext Transfer Protocol (HTTP) Warn Codes&quot; registry defines
   the namespace for warn codes.  It has been created and is now
   maintained at &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/http-warn-codes&quot;&gt;http://www.iana.org/assignments/http-warn-codes&lt;/a&gt;&amp;gt;.</source>
          <target state="translated">&amp;ldquo;超文本传输​​协议（HTTP）警告代码&amp;rdquo;注册表定义了警告代码的名称空间。它已经创建，现在可以在&amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/http-warn-codes&quot;&gt;http://www.iana.org/assignments/http-warn-codes&lt;/a&gt; &amp;gt;上进行维护。</target>
        </trans-unit>
        <trans-unit id="a01f619197e218b37486439c5f8bed7947d36e60" translate="yes" xml:space="preserve">
          <source>The &quot;Hypertext Transfer Protocol (HTTP) Warn Codes&quot; registry defines
   the namespace for warn codes.  It has been created and is now
   maintained at &amp;lt;&lt;a href=&quot;https://www.iana.org/assignments/http-warn-codes&quot;&gt;http://www.iana.org/assignments/http-warn-codes&lt;/a&gt;&amp;gt;.</source>
          <target state="translated">&amp;ldquo;超文本传输​​协议（HTTP）警告代码&amp;rdquo;注册表定义了警告代码的名称空间。它已经创建，现在可以在&amp;lt; &lt;a href=&quot;https://www.iana.org/assignments/http-warn-codes&quot;&gt;http://www.iana.org/assignments/http-warn-codes&lt;/a&gt; &amp;gt;上进行维护。</target>
        </trans-unit>
        <trans-unit id="ce30eef6a7cd5d843d61361a8fb74fe7770cdcce" translate="yes" xml:space="preserve">
          <source>The &quot;If-Match&quot; header field makes the request method conditional on
   the recipient origin server either having at least one current
   representation of the target resource, when the field-value is &quot;*&quot;,
   or having a current representation of the target resource that has an
   entity-tag matching a member of the list of entity-tags provided in
   the field-value.

   An origin server MUST use the strong comparison function when
   comparing entity-tags for If-Match (&lt;a href=&quot;#section-2.3.2&quot;&gt;Section 2.3.2&lt;/a&gt;), since the client
   intends this precondition to prevent the method from being applied if
   there have been any changes to the representation data.

     If-Match = &quot;*&quot; / 1#entity-tag

   Examples:

     If-Match: &quot;xyzzy&quot;
     If-Match: &quot;xyzzy&quot;, &quot;r2d2xxxx&quot;, &quot;c3piozzzz&quot;
     If-Match: *

   If-Match is most often used with state-changing methods (e.g., POST,
   PUT, DELETE) to prevent accidental overwrites when multiple user
   agents might be acting in parallel on the same resource (i.e., to 

   prevent the &quot;lost update&quot; problem).  It can also be used with safe
   methods to abort a request if the selected representation does not
   match one already stored (or partially stored) from a prior request.

   An origin server that receives an If-Match header field MUST evaluate
   the condition prior to performing the method (&lt;a href=&quot;#section-5&quot;&gt;Section 5&lt;/a&gt;).  If the
   field-value is &quot;*&quot;, the condition is false if the origin server does
   not have a current representation for the target resource.  If the
   field-value is a list of entity-tags, the condition is false if none
   of the listed tags match the entity-tag of the selected
   representation.

   An origin server MUST NOT perform the requested method if a received
   If-Match condition evaluates to false; instead, the origin server
   MUST respond with either a) the 412 (Precondition Failed) status code
   or b) one of the 2xx (Successful) status codes if the origin server
   has verified that a state change is being requested and the final
   state is already reflected in the current state of the target
   resource (i.e., the change requested by the user agent has already
   succeeded, but the user agent might not be aware of it, perhaps
   because the prior response was lost or a compatible change was made
   by some other user agent).  In the latter case, the origin server
   MUST NOT send a validator header field in the response unless it can
   verify that the request is a duplicate of an immediately prior change
   made by the same user agent.

   The If-Match header field can be ignored by caches and intermediaries
   because it is not applicable to a stored response.</source>
          <target state="translated">当字段值是&amp;ldquo; *&amp;rdquo;时，&amp;ldquo; If-Match&amp;rdquo;头域使请求方法的条件为接收方原始服务器具有目标资源的至少一种当前表示形式，或者具有以下形式的目标资源的当前表示形式：具有与字段值中提供的实体标签列表的成员匹配的实体标签。当比较If-Match的实体标签时，原始服务器必须使用强大的比较功能（&lt;a href=&quot;#section-2.3.2&quot;&gt;第2.3.2节&lt;/a&gt;），因为如果表示数据发生任何更改，客户端希望使用此前提条件来防止应用该方法。 If-Match =&amp;ldquo; *&amp;rdquo; / 1＃entity-tag示例：If-Match：&amp;ldquo; xyzzy&amp;rdquo; If-Match：&amp;ldquo; xyzzy&amp;rdquo;，&amp;ldquo; r2d2xxxx&amp;rdquo;，&amp;ldquo; c3piozzzz&amp;rdquo; If-Match：* If-Match最常与状态更改方法（例如POST，PUT，DELETE），以防止多个用户代理在同一资源上并行执行操作时发生意外覆盖（即，防止&amp;ldquo;丢失更新&amp;rdquo;问题）。如果选定的表示与先前请求中已经存储（或部分存储）的表示不匹配，它也可以与安全方法一起用于中止请求。接收到If-Match标头字段的原始服务器必须在执行该方法之前评估条件（&lt;a href=&quot;#section-5&quot;&gt;第5节&lt;/a&gt;）。如果字段值为&amp;ldquo; *&amp;rdquo;，则当源服务器没有目标资源的当前表示形式时，条件为false。如果该字段值是实体标签的列表，则如果列出的标签中没有一个与所选表示形式的实体标签匹配，则条件为false。如果收到的If-Match条件评估为false，则原始服务器不得执行请求的方法；相反，如果原始服务器已验证请求了状态更改并且已经存在最终状态，则原始服务器必须使用以下两种方式之一响应：a）412（失败的前提条件）状态代码或b）2xx（成功）状态代码之一。反映在目标资源的当前状态中（即，用户代理请求的更改已成功完成，但用户代理可能不知道这一点，可能是因为先前的响应丢失了，或者其他用户代理进行了兼容的更改）。在后一种情况下，除非原始服务器可以验证请求是否是同一用户代理所做的先前更改的重复，否则原始服务器不得在响应中发送验证者头字段。缓存和中介可以忽略If-Match标头字段，因为它不适用于存储的响应。缓存和中介可以忽略If-Match标头字段，因为它不适用于存储的响应。缓存和中介可以忽略If-Match标头字段，因为它不适用于存储的响应。</target>
        </trans-unit>
        <trans-unit id="6a8bdb230b0368d774ef7c392fdbc661a6f47bdb" translate="yes" xml:space="preserve">
          <source>The &quot;If-Modified-Since&quot; header field makes a GET or HEAD request
   method conditional on the selected representation's modification date
   being more recent than the date provided in the field-value.
   Transfer of the selected representation's data is avoided if that
   data has not changed.

     If-Modified-Since = HTTP-date

   An example of the field is:

     If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT

   A recipient MUST ignore If-Modified-Since if the request contains an
   If-None-Match header field; the condition in If-None-Match is
   considered to be a more accurate replacement for the condition in
   If-Modified-Since, and the two are only combined for the sake of
   interoperating with older intermediaries that might not implement
   If-None-Match.

   A recipient MUST ignore the If-Modified-Since header field if the
   received field-value is not a valid HTTP-date, or if the request
   method is neither GET nor HEAD.

   A recipient MUST interpret an If-Modified-Since field-value's
   timestamp in terms of the origin server's clock.

   If-Modified-Since is typically used for two distinct purposes: 1) to
   allow efficient updates of a cached representation that does not have
   an entity-tag and 2) to limit the scope of a web traversal to
   resources that have recently changed.

   When used for cache updates, a cache will typically use the value of
   the cached message's Last-Modified field to generate the field value
   of If-Modified-Since.  This behavior is most interoperable for cases
   where clocks are poorly synchronized or when the server has chosen to
   only honor exact timestamp matches (due to a problem with
   Last-Modified dates that appear to go &quot;back in time&quot; when the origin
   server's clock is corrected or a representation is restored from an
   archived backup).  However, caches occasionally generate the field
   value based on other data, such as the Date header field of the
   cached message or the local clock time that the message was received,
   particularly when the cached message does not contain a Last-Modified
   field. 

   When used for limiting the scope of retrieval to a recent time
   window, a user agent will generate an If-Modified-Since field value
   based on either its own local clock or a Date header field received
   from the server in a prior response.  Origin servers that choose an
   exact timestamp match based on the selected representation's
   Last-Modified field will not be able to help the user agent limit its
   data transfers to only those changed during the specified window.

   An origin server that receives an If-Modified-Since header field
   SHOULD evaluate the condition prior to performing the method
   (&lt;a href=&quot;#section-5&quot;&gt;Section 5&lt;/a&gt;).  The origin server SHOULD NOT perform the requested
   method if the selected representation's last modification date is
   earlier than or equal to the date provided in the field-value;
   instead, the origin server SHOULD generate a 304 (Not Modified)
   response, including only those metadata that are useful for
   identifying or updating a previously cached response.

   Requirements on cache handling of a received If-Modified-Since header
   field are defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.3.2&quot;&gt;Section&amp;nbsp;4.3.2 of [RFC7234]&lt;/a&gt;.</source>
          <target state="translated">标题字段&amp;ldquo; If-Modified-Since&amp;rdquo;使GET或HEAD请求方法的条件为所选表示的修改日期比字段值中提供的日期更新。如果所选表示的数据未更改，则避免该数据的传输。 If-Modified-Since = HTTP-date字段的示例是：If-Modified-Since：Sat，29 Oct 1994 19:43:31 GMT如果请求包含If-None，则收件人必须忽略If-Modified-Since。 -匹配头字段； If-None-Match中的条件被认为是If-Modified-Since中的条件的更准确替代，并且仅将两者结合是为了与可能未实现If-None-Match的较旧中介进行互操作。如果接收到的字段值不是有效的HTTP日期，或者请求方法既不是GET也不是HEAD，则接收方必须忽略If-Modified-Since头字段。接收者必须根据源服务器的时钟解释If-Modified-Since字段值的时间戳。 If-Modified-Since通常用于两个不同的目的：1）允许有效更新没有实体标签的缓存表示形式； 2）将Web遍历的范围限制为最近更改的资源。当用于缓存更新时，缓存通常将使用缓存消息的Last-Modified字段的值来生成If-Modified-Since的字段值。对于时钟同步不佳的情况，或者服务器选择仅遵循确切的时间戳匹配的情况，此行为是最可互操作的（由于校正原始服务器的时钟后，Last-Modified日期出现了&amp;ldquo;返回时间&amp;rdquo;的问题）或从存档备份还原制图表达）。但是，缓存有时会根据其他数据（例如，缓存的消息的Date头字段或接收到该消息的本地时钟时间）生成字段值，尤其是当缓存的消息不包含Last-Modified字段时。当用于将检索范围限制为最近的时间窗口时，用户代理将基于自身的本地时钟或在先前响应中从服务器接收到的Date标头字段来生成If-Modified-Since字段值。根据所选表示形式的&amp;ldquo; Last-Modified&amp;rdquo;字段选择确切时间戳匹配的原始服务器将无法帮助用户代理将其数据传输限制为仅在指定窗口内更改的数据传输。收到If-Modified-Since标头字段的原始服务器应在执行该方法之前评估条件（接收到If-Modified-Since头字段的原始服务器应在执行该方法之前评估条件（接收到If-Modified-Since头字段的原始服务器应在执行该方法之前评估条件（&lt;a href=&quot;#section-5&quot;&gt;第5节&lt;/a&gt;）。如果所选表示的最后修改日期早于或等于字段值中提供的日期，则原始服务器不应执行请求的方法；相反，源服务器应该生成304（未修改）响应，仅包括那些对于标识或更新先前缓存的响应有用的元数据。&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.3.2&quot;&gt;[RFC7234]的第4.3.2节&lt;/a&gt;定义了对接收的If-Modified-Since标头字段的缓存处理的要求。</target>
        </trans-unit>
        <trans-unit id="7a0c758120c2ca9721b5496606fe6d4cf8c40d68" translate="yes" xml:space="preserve">
          <source>The &quot;If-None-Match&quot; header field makes the request method conditional
   on a recipient cache or origin server either not having any current
   representation of the target resource, when the field-value is &quot;*&quot;,
   or having a selected representation with an entity-tag that does not
   match any of those listed in the field-value.

   A recipient MUST use the weak comparison function when comparing
   entity-tags for If-None-Match (&lt;a href=&quot;#section-2.3.2&quot;&gt;Section 2.3.2&lt;/a&gt;), since weak entity-tags
   can be used for cache validation even if there have been changes to
   the representation data.

     If-None-Match = &quot;*&quot; / 1#entity-tag 

   Examples:

     If-None-Match: &quot;xyzzy&quot;
     If-None-Match: W/&quot;xyzzy&quot;
     If-None-Match: &quot;xyzzy&quot;, &quot;r2d2xxxx&quot;, &quot;c3piozzzz&quot;
     If-None-Match: W/&quot;xyzzy&quot;, W/&quot;r2d2xxxx&quot;, W/&quot;c3piozzzz&quot;
     If-None-Match: *

   If-None-Match is primarily used in conditional GET requests to enable
   efficient updates of cached information with a minimum amount of
   transaction overhead.  When a client desires to update one or more
   stored responses that have entity-tags, the client SHOULD generate an
   If-None-Match header field containing a list of those entity-tags
   when making a GET request; this allows recipient servers to send a
   304 (Not Modified) response to indicate when one of those stored
   responses matches the selected representation.

   If-None-Match can also be used with a value of &quot;*&quot; to prevent an
   unsafe request method (e.g., PUT) from inadvertently modifying an
   existing representation of the target resource when the client
   believes that the resource does not have a current representation
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.2.1&quot;&gt;Section&amp;nbsp;4.2.1 of [RFC7231]&lt;/a&gt;).  This is a variation on the &quot;lost
   update&quot; problem that might arise if more than one client attempts to
   create an initial representation for the target resource.

   An origin server that receives an If-None-Match header field MUST
   evaluate the condition prior to performing the method (&lt;a href=&quot;#section-5&quot;&gt;Section 5&lt;/a&gt;).
   If the field-value is &quot;*&quot;, the condition is false if the origin
   server has a current representation for the target resource.  If the
   field-value is a list of entity-tags, the condition is false if one
   of the listed tags match the entity-tag of the selected
   representation.

   An origin server MUST NOT perform the requested method if the
   condition evaluates to false; instead, the origin server MUST respond
   with either a) the 304 (Not Modified) status code if the request
   method is GET or HEAD or b) the 412 (Precondition Failed) status code
   for all other request methods.

   Requirements on cache handling of a received If-None-Match header
   field are defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.3.2&quot;&gt;Section&amp;nbsp;4.3.2 of [RFC7234]&lt;/a&gt;.</source>
          <target state="translated">&amp;ldquo; If-None-Match&amp;rdquo;标头字段使请求方法的条件为收件人缓存或原始服务器，当字段值是&amp;ldquo; *&amp;rdquo;时，该对象不具有目标资源的任何当前表示形式，或者具有带有与该字段值中列出的任何实体标签都不匹配的实体标签。接收者在比较实体标签是否为不匹配时必须使用弱比较功能（&lt;a href=&quot;#section-2.3.2&quot;&gt;第2.3.2节）&lt;/a&gt;），因为即使对表示数据进行了更改，也可以使用弱实体标签进行缓存验证。 If-None-Match =&amp;ldquo; *&amp;rdquo; / 1＃entity-tag示例：If-None-Match：&amp;ldquo; xyzzy&amp;rdquo; If-None-Match：W /&amp;ldquo; xyzzy&amp;rdquo; If-None-Match：&amp;ldquo; xyzzy&amp;rdquo;，&amp;ldquo; r2d2xxxx&amp;rdquo; ，&amp;ldquo; c3piozzzz&amp;rdquo; If-None-Match：W /&amp;ldquo; xyzzy&amp;rdquo;，W /&amp;ldquo; r2d2xxxx&amp;rdquo;，W /&amp;ldquo; c3piozzzz&amp;rdquo; If-None-Match：* If-None-Match主要用于条件GET请求中以启用有效更新高速缓存的信息以最小的事务开销。当客户希望更新一个或多个带有实体标签的存储响应时，客户应该在发出GET请求时生成一个If-None-Match标头字段，其中包含这些实体标签的列表；这允许收件人服务器发送304（未修改）响应，以指示这些存储的响应之一何时与所选表示匹配。 If-None-Match也可以与值&amp;ldquo; *&amp;rdquo;一起使用，以防止不安全的请求方法（例如，PUT）在客户端认为资源没有当前表示形式时无意中修改了目标资源的现有表示形式（（PUT）是由于客户端认为资源没有当前表示形式而无意间修改了目标资源的现有表示形式（（PUT）是由于客户端认为资源没有当前表示形式而无意间修改了目标资源的现有表示形式（&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.2.1&quot;&gt;[RFC7231]的第4.2.1节&lt;/a&gt;）。这是&amp;ldquo;丢失更新&amp;rdquo;问题的一种变体，如果多个客户端尝试为目标资源创建初始表示，则可能会出现此问题。接收到If-None-Match标头字段的原始服务器务必在执行该方法之前评估条件（&lt;a href=&quot;#section-5&quot;&gt;第5节&lt;/a&gt;）。如果字段值为&amp;ldquo; *&amp;rdquo;，则当源服务器具有目标资源的当前表示形式时，条件为false。如果该字段值是实体标签列表，则如果列出的标签之一与所选表示形式的实体标签匹配，则条件为false。如果条件评估为假，则原始服务器不得执行请求的方法；相反，如果请求方法是GET或HEAD，则原始服务器必须使用以下两种方式之一响应：a）304（未修改）状态码，或b）所有其他请求方法的412（前提条件失败）状态码。&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.3.2&quot;&gt;[RFC7234]的第4.3.2节&lt;/a&gt;定义了对接收的If-None-Match标头字段的缓存处理的要求。</target>
        </trans-unit>
        <trans-unit id="a9010727bf44de6e918d999396395dcc003b1b98" translate="yes" xml:space="preserve">
          <source>The &quot;If-Range&quot; header field provides a special conditional request
   mechanism that is similar to the If-Match and If-Unmodified-Since
   header fields but that instructs the recipient to ignore the Range
   header field if the validator doesn't match, resulting in transfer of
   the new selected representation instead of a 412 (Precondition
   Failed) response.  If-Range is defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-3.2&quot;&gt;Section&amp;nbsp;3.2 of [RFC7233]&lt;/a&gt;.</source>
          <target state="translated">&amp;ldquo; If-Range&amp;rdquo;头字段提供了一种特殊的条件请求机制，该机制类似于If-Match和If-Unmodified-Since头字段，但指示接收者在验证器不匹配的情况下忽略Range头字段，结果传输新的所选表示形式而不是412（前提失败）响应。 If-Range在&lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-3.2&quot;&gt;[RFC7233]的3.2节中&lt;/a&gt;定义。</target>
        </trans-unit>
        <trans-unit id="8425f95c9971ed97dd968bffd651d8482f2d923d" translate="yes" xml:space="preserve">
          <source>The &quot;If-Unmodified-Since&quot; header field makes the request method
   conditional on the selected representation's last modification date
   being earlier than or equal to the date provided in the field-value.
   This field accomplishes the same purpose as If-Match for cases where
   the user agent does not have an entity-tag for the representation.

     If-Unmodified-Since = HTTP-date

   An example of the field is:

     If-Unmodified-Since: Sat, 29 Oct 1994 19:43:31 GMT

   A recipient MUST ignore If-Unmodified-Since if the request contains
   an If-Match header field; the condition in If-Match is considered to
   be a more accurate replacement for the condition in
   If-Unmodified-Since, and the two are only combined for the sake of
   interoperating with older intermediaries that might not implement
   If-Match.

   A recipient MUST ignore the If-Unmodified-Since header field if the
   received field-value is not a valid HTTP-date.

   A recipient MUST interpret an If-Unmodified-Since field-value's
   timestamp in terms of the origin server's clock. 

   If-Unmodified-Since is most often used with state-changing methods
   (e.g., POST, PUT, DELETE) to prevent accidental overwrites when
   multiple user agents might be acting in parallel on a resource that
   does not supply entity-tags with its representations (i.e., to
   prevent the &quot;lost update&quot; problem).  It can also be used with safe
   methods to abort a request if the selected representation does not
   match one already stored (or partially stored) from a prior request.

   An origin server that receives an If-Unmodified-Since header field
   MUST evaluate the condition prior to performing the method
   (&lt;a href=&quot;#section-5&quot;&gt;Section 5&lt;/a&gt;).  The origin server MUST NOT perform the requested method
   if the selected representation's last modification date is more
   recent than the date provided in the field-value; instead the origin
   server MUST respond with either a) the 412 (Precondition Failed)
   status code or b) one of the 2xx (Successful) status codes if the
   origin server has verified that a state change is being requested and
   the final state is already reflected in the current state of the
   target resource (i.e., the change requested by the user agent has
   already succeeded, but the user agent might not be aware of that
   because the prior response message was lost or a compatible change
   was made by some other user agent).  In the latter case, the origin
   server MUST NOT send a validator header field in the response unless
   it can verify that the request is a duplicate of an immediately prior
   change made by the same user agent.

   The If-Unmodified-Since header field can be ignored by caches and
   intermediaries because it is not applicable to a stored response.</source>
          <target state="translated">&amp;ldquo; If-Unmodified-Since&amp;rdquo;标头字段使请求方法以所选表示形式的最后修改日期早于或等于字段值中提供的日期为条件。对于用户代理没有用于表示的实体标签的情况，此字段实现与If-Match相同的目的。 If-Unmodified-Since = HTTP-date字段的示例是：If-Unmodified-Since：Sat，29 Oct 1994 19:43:31 GMT如果请求包含If-Match，则收件人必须忽略If-Unmodified-Since。标头字段； If-Match中的条件被认为是If-Unmodified-Since中条件的更准确替代，并且仅将两者结合是为了与可能未实现If-Match的较旧中介进行互操作。如果接收到的字段值不是有效的HTTP日期，则接收者必须忽略If-Unmodified-Since标头字段。接收者必须根据源服务器的时钟解释If-Unmodified-Since字段值的时间戳。 If-Unmodified-Since最常与状态更改方法（例如POST，PUT，DELETE）一起使用，以防止当多个用户代理可能并行处理不提供其表示形式的实体标签的资源时发生意外覆盖（即，以防止&amp;ldquo;丢失更新&amp;rdquo;问题）。如果选定的表示与先前请求中已经存储（或部分存储）的表示不匹配，它也可以与安全方法一起使用来中止请求。收到If-Unmodified-Since头字段的原始服务器务必在执行该方法之前评估条件（&lt;a href=&quot;#section-5&quot;&gt;第5节&lt;/a&gt;）。如果所选表示的最后修改日期比字段值中提供的日期更新，则原始服务器不得执行请求的方法。相反，如果原始服务器已验证请求了状态更改并且已经反映了最终状态，则原始服务器必须使用以下两种方式之一响应：a）412（失败的前提条件）状态代码或b）2xx（成功）状态代码之一。在目标资源的当前状态下（即，用户代理请求的更改已经成功，但是用户代理可能不知道这是因为先前的响应消息丢失了，或者其他一些用户代理进行了兼容的更改） ）。在后一种情况下，原始服务器不得在响应中发送验证者头字段，除非它可以验证请求是否与同一用户代理所做的前一次更改重复。高速缓存和中介可以忽略If-Unmodified-Since标头字段，因为它不适用于存储的响应。</target>
        </trans-unit>
        <trans-unit id="3bcbe36b4b07ea53d8dfd522bedc5b18d8069ffd" translate="yes" xml:space="preserve">
          <source>The &quot;Last-Modified&quot; header field in a response provides a timestamp
   indicating the date and time at which the origin server believes the
   selected representation was last modified, as determined at the
   conclusion of handling the request.

     Last-Modified = HTTP-date

   An example of its use is

     Last-Modified: Tue, 15 Nov 1994 12:45:26 GMT</source>
          <target state="translated">响应中的 &quot;Last-Modified &quot;头字段提供了一个时间戳,表示起源服务器认为所选表示最后被修改的日期和时间,这是在处理请求的结论中确定的。Last-Modified=HTTP-date 一个使用它的例子是Last-Modified。Tue,15 Nov 1994 12:45:26 GMT。</target>
        </trans-unit>
        <trans-unit id="a6eb1d27a3336049ef780463edbd186c94593ceb" translate="yes" xml:space="preserve">
          <source>The &quot;Location&quot; header field is used in some responses to refer to a
   specific resource in relation to the response.  The type of
   relationship is defined by the combination of request method and
   status code semantics.

     Location = URI-reference

   The field value consists of a single URI-reference.  When it has the
   form of a relative reference (&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-4.2&quot;&gt;[RFC3986], Section&amp;nbsp;4.2&lt;/a&gt;), the final
   value is computed by resolving it against the effective request URI
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-5&quot;&gt;[RFC3986], Section&amp;nbsp;5&lt;/a&gt;).

   For 201 (Created) responses, the Location value refers to the primary
   resource created by the request.  For 3xx (Redirection) responses,
   the Location value refers to the preferred target resource for
   automatically redirecting the request.

   If the Location value provided in a 3xx (Redirection) response does
   not have a fragment component, a user agent MUST process the
   redirection as if the value inherits the fragment component of the
   URI reference used to generate the request target (i.e., the
   redirection inherits the original reference's fragment, if any).

   For example, a GET request generated for the URI reference
   &quot;http://www.example.org/~tim&quot; might result in a 303 (See Other)
   response containing the header field:

     Location: /People.html#tim

   which suggests that the user agent redirect to
   &quot;http://www.example.org/People.html#tim&quot; 

   Likewise, a GET request generated for the URI reference
   &quot;http://www.example.org/index.html#larry&quot; might result in a 301
   (Moved Permanently) response containing the header field:

     Location: http://www.example.net/index.html

   which suggests that the user agent redirect to
   &quot;http://www.example.net/index.html#larry&quot;, preserving the original
   fragment identifier.

   There are circumstances in which a fragment identifier in a Location
   value would not be appropriate.  For example, the Location header
   field in a 201 (Created) response is supposed to provide a URI that
   is specific to the created resource.

      Note: Some recipients attempt to recover from Location fields that
      are not valid URI references.  This specification does not mandate
      or define such processing, but does allow it for the sake of
      robustness.

      Note: The Content-Location header field (&lt;a href=&quot;#section-3.1.4.2&quot;&gt;Section 3.1.4.2&lt;/a&gt;) differs
      from Location in that the Content-Location refers to the most
      specific resource corresponding to the enclosed representation.
      It is therefore possible for a response to contain both the
      Location and Content-Location header fields.</source>
          <target state="translated">在某些响应中，&amp;ldquo;位置&amp;rdquo;标头字段用于引用与响应有关的特定资源。关系的类型由请求方法和状态代码语义的组合定义。位置= URI引用字段值由单个URI引用组成。当它具有相对引用的形式（&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-4.2&quot;&gt;[RFC3986]，第4.2节&lt;/a&gt;）时，通过将其与有效请求URI进行解析来计算最终值（&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-5&quot;&gt;[RFC3986]，第5节）&lt;/a&gt;）。对于201（已创建）响应，位置值是指请求创建的主要资源。对于3xx（重定向）响应，&amp;ldquo;位置&amp;rdquo;值是指用于自动重定向请求的首选目标资源。如果在3xx（重定向）响应中提供的Location值不包含片段组件，则用户代理必须处理重定向，就好像该值继承了用于生成请求目标的URI参考的片段组件一样（即，重定向继承原始参考文献的片段（如果有）。例如，为URI引用&amp;ldquo; http://www.example.org/~tim&amp;rdquo;生成的GET请求可能会导致303（请参见其他）响应包含标头字段：Location：/ People。html＃tim，建议用户代理重定向到&amp;ldquo; http://www.example.org/People.html#tim&amp;rdquo;。同样，针对URI参考&amp;ldquo; http://www.example.org/index&amp;rdquo;生成的GET请求&amp;ldquo; .html＃larry&amp;rdquo;可能会导致包含标题字段的301（永久移动）响应：位置：http：//www.example.net/index.html，建议用户代理重定向到&amp;ldquo; http：// www。 example.net/index.html#larry&amp;rdquo;，保留原始片段标识符。在某些情况下，位置值中的片段标识符不合适。例如，假定201（已创建）响应中的Location头字段提供特定于所创建资源的URI。注意：一些收件人尝试从无效的URI引用的&amp;ldquo;位置&amp;rdquo;字段中恢复。该规范没有规定或定义这种处理，但是出于鲁棒性的考虑而允许进行这种处理。注意：Content-Location标头字段（&lt;a href=&quot;#section-3.1.4.2&quot;&gt;第3.1.4.2节&lt;/a&gt;）与位置的不同之处在于，内容位置是指与封闭表示相对应的最具体的资源。因此，响应可能同时包含Location和Content-Location标头字段。</target>
        </trans-unit>
        <trans-unit id="74bdc0b34c81dec67352f90c99efe73d9563e534" translate="yes" xml:space="preserve">
          <source>The &quot;Max-Forwards&quot; header field provides a mechanism with the TRACE
   (&lt;a href=&quot;#section-4.3.8&quot;&gt;Section 4.3.8&lt;/a&gt;) and OPTIONS (&lt;a href=&quot;#section-4.3.7&quot;&gt;Section 4.3.7&lt;/a&gt;) request methods to limit
   the number of times that the request is forwarded by proxies.  This
   can be useful when the client is attempting to trace a request that
   appears to be failing or looping mid-chain.

     Max-Forwards = 1*DIGIT

   The Max-Forwards value is a decimal integer indicating the remaining
   number of times this request message can be forwarded.

   Each intermediary that receives a TRACE or OPTIONS request containing
   a Max-Forwards header field MUST check and update its value prior to
   forwarding the request.  If the received value is zero (0), the
   intermediary MUST NOT forward the request; instead, the intermediary
   MUST respond as the final recipient.  If the received Max-Forwards
   value is greater than zero, the intermediary MUST generate an updated
   Max-Forwards field in the forwarded message with a field-value that
   is the lesser of a) the received value decremented by one (1) or b)
   the recipient's maximum supported value for Max-Forwards.

   A recipient MAY ignore a Max-Forwards header field received with any
   other request methods.</source>
          <target state="translated">&amp;ldquo; Max-Forwards&amp;rdquo;标题字段提供了一种具有TRACE（&lt;a href=&quot;#section-4.3.8&quot;&gt;第4.3.8节&lt;/a&gt;）和OPTIONS（&lt;a href=&quot;#section-4.3.7&quot;&gt;第4.3.7 &lt;/a&gt;节）的机制。）请求方法，以限制代理转发请求的次数。当客户端尝试跟踪似乎失败或中链中断的请求时，此功能很有用。 Max-Forwards = 1 * DIGIT Max-Forwards值是一个十进制整数，指示可以转发此请求消息的剩余次数。每个接收到包含Max-Forwards标头字段的TRACE或OPTIONS请求的中介都必须在转发请求之前检查并更新其值。如果接收到的值为零（0），则中介不得转发请求；相反，中介必须作为最终接收者做出响应。如果收到的Max-Forwards值大于零，中介必须在转发的消息中生成一个更新后的Max-Forward字段，其字段值为a）接收值减一（1）或b）收件人对Max-Forwards的最大支持值中的较小者。接收者可以忽略与任何其他请求方法一起接收的Max-Forwards标头字段。</target>
        </trans-unit>
        <trans-unit id="62a3d127d32e2961eab7613512f025a99727d041" translate="yes" xml:space="preserve">
          <source>The &quot;Message Headers&quot; registry has been updated with the following
   permanent registrations:

   +-------------------+----------+----------+-----------------+
   | Header Field Name | Protocol | Status   | Reference       |
   +-------------------+----------+----------+-----------------+
   | Accept            | http     | standard | &lt;a href=&quot;#section-5.3.2&quot;&gt;Section 5.3.2&lt;/a&gt;   |
   | Accept-Charset    | http     | standard | &lt;a href=&quot;#section-5.3.3&quot;&gt;Section 5.3.3&lt;/a&gt;   |
   | Accept-Encoding   | http     | standard | &lt;a href=&quot;#section-5.3.4&quot;&gt;Section 5.3.4&lt;/a&gt;   |
   | Accept-Language   | http     | standard | &lt;a href=&quot;#section-5.3.5&quot;&gt;Section 5.3.5&lt;/a&gt;   |
   | Allow             | http     | standard | &lt;a href=&quot;#section-7.4.1&quot;&gt;Section 7.4.1&lt;/a&gt;   |
   | Content-Encoding  | http     | standard | &lt;a href=&quot;#section-3.1.2.2&quot;&gt;Section 3.1.2.2&lt;/a&gt; |
   | Content-Language  | http     | standard | &lt;a href=&quot;#section-3.1.3.2&quot;&gt;Section 3.1.3.2&lt;/a&gt; |
   | Content-Location  | http     | standard | &lt;a href=&quot;#section-3.1.4.2&quot;&gt;Section 3.1.4.2&lt;/a&gt; |
   | Content-Type      | http     | standard | &lt;a href=&quot;#section-3.1.1.5&quot;&gt;Section 3.1.1.5&lt;/a&gt; |
   | Date              | http     | standard | &lt;a href=&quot;#section-7.1.1.2&quot;&gt;Section 7.1.1.2&lt;/a&gt; |
   | Expect            | http     | standard | &lt;a href=&quot;#section-5.1.1&quot;&gt;Section 5.1.1&lt;/a&gt;   |
   | From              | http     | standard | &lt;a href=&quot;#section-5.5.1&quot;&gt;Section 5.5.1&lt;/a&gt;   |
   | Location          | http     | standard | &lt;a href=&quot;#section-7.1.2&quot;&gt;Section 7.1.2&lt;/a&gt;   |
   | Max-Forwards      | http     | standard | &lt;a href=&quot;#section-5.1.2&quot;&gt;Section 5.1.2&lt;/a&gt;   |
   | MIME-Version      | http     | standard | &lt;a href=&quot;#appendix-A.1&quot;&gt;Appendix A.1&lt;/a&gt;    |
   | Referer           | http     | standard | &lt;a href=&quot;#section-5.5.2&quot;&gt;Section 5.5.2&lt;/a&gt;   |
   | Retry-After       | http     | standard | &lt;a href=&quot;#section-7.1.3&quot;&gt;Section 7.1.3&lt;/a&gt;   |
   | Server            | http     | standard | &lt;a href=&quot;#section-7.4.2&quot;&gt;Section 7.4.2&lt;/a&gt;   |
   | User-Agent        | http     | standard | &lt;a href=&quot;#section-5.5.3&quot;&gt;Section 5.5.3&lt;/a&gt;   |
   | Vary              | http     | standard | &lt;a href=&quot;#section-7.1.4&quot;&gt;Section 7.1.4&lt;/a&gt;   |
   +-------------------+----------+----------+-----------------+

   The change controller for the above registrations is: &quot;IETF
   (iesg@ietf.org) - Internet Engineering Task Force&quot;.</source>
          <target state="translated">&amp;ldquo;消息头&amp;rdquo;注册表已更新，具有以下永久注册：+ ------------------- + ---------- + --- ------- + ----------------- + |标头字段名称|协议|现状参考| + ------------------- + ---------- + ---------- + ------- ---------- + |接受| http |标准| &lt;a href=&quot;#section-5.3.2&quot;&gt;第5.3.2节&lt;/a&gt; | |接受字符集| http |标准| &lt;a href=&quot;#section-5.3.3&quot;&gt;第5.3.3节&lt;/a&gt; | |接受编码| http |标准| &lt;a href=&quot;#section-5.3.4&quot;&gt;第5.3.4节&lt;/a&gt; | |接受语言| http |标准| &lt;a href=&quot;#section-5.3.5&quot;&gt;第5.3.5节&lt;/a&gt; | |允许| http |标准| &lt;a href=&quot;#section-7.4.1&quot;&gt;第7.4.1节&lt;/a&gt; | |内容编码| http |标准| &lt;a href=&quot;#section-3.1.2.2&quot;&gt;第3.1.2.2节&lt;/a&gt;| |内容语言| http |标准| &lt;a href=&quot;#section-3.1.3.2&quot;&gt;第3.1.3.2节&lt;/a&gt; | |内容位置| http |标准| &lt;a href=&quot;#section-3.1.4.2&quot;&gt;第3.1.4.2节&lt;/a&gt; | |内容类型| http |标准| &lt;a href=&quot;#section-3.1.1.5&quot;&gt;第3.1.1.5节&lt;/a&gt; | |日期| http |标准| &lt;a href=&quot;#section-7.1.1.2&quot;&gt;第7.1.1.2节&lt;/a&gt; | |期待| http |标准| &lt;a href=&quot;#section-5.1.1&quot;&gt;第5.1.1节&lt;/a&gt; | |来自| http |标准| &lt;a href=&quot;#section-5.5.1&quot;&gt;第5.5.1节&lt;/a&gt; | |位置| http |标准| &lt;a href=&quot;#section-7.1.2&quot;&gt;第7.1.2节&lt;/a&gt; | | Max-Forwards | http |标准| &lt;a href=&quot;#section-5.1.2&quot;&gt;第5.1.2节&lt;/a&gt; | | MIME版本| http |标准| &lt;a href=&quot;#appendix-A.1&quot;&gt;附录A.1&lt;/a&gt; | |推荐人| http |标准| &lt;a href=&quot;#section-5.5.2&quot;&gt;第5.5.2节&lt;/a&gt; | |重试后| http |标准| &lt;a href=&quot;#section-7.1.3&quot;&gt;第7.1.3节&lt;/a&gt; | |服务器| http |标准| &lt;a href=&quot;#section-7.4.2&quot;&gt;第7.4.2节&lt;/a&gt; | |用户代理| http |标准| &lt;a href=&quot;#section-5.5.3&quot;&gt;第5.5.3节&lt;/a&gt; | |变化| http |标准| &lt;a href=&quot;#section-7.1.4&quot;&gt;第7.1.4节&lt;/a&gt; | + ------------------- + ---------- + ---------- + ------- ---------- +上述注册的更改控制者是：&amp;ldquo; IETF（iesg@ietf.org）-Internet工程任务组&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="17017ddede4b2983af658e0ef12536aeaa0acb5a" translate="yes" xml:space="preserve">
          <source>The &quot;Pragma&quot; header field allows backwards compatibility with
   HTTP/1.0 caches, so that clients can specify a &quot;no-cache&quot; request
   that they will understand (as Cache-Control was not defined until
   HTTP/1.1).  When the Cache-Control header field is also present and
   understood in a request, Pragma is ignored.

   In HTTP/1.0, Pragma was defined as an extensible field for
   implementation-specified directives for recipients.  This
   specification deprecates such extensions to improve interoperability.

     Pragma           = 1#pragma-directive
     pragma-directive = &quot;no-cache&quot; / extension-pragma
     extension-pragma = token [ &quot;=&quot; ( token / quoted-string ) ]

   When the Cache-Control header field is not present in a request,
   caches MUST consider the no-cache request pragma-directive as having
   the same effect as if &quot;Cache-Control: no-cache&quot; were present (see
   &lt;a href=&quot;#section-5.2.1&quot;&gt;Section 5.2.1&lt;/a&gt;).

   When sending a no-cache request, a client ought to include both the
   pragma and cache-control directives, unless Cache-Control: no-cache
   is purposefully omitted to target other Cache-Control response
   directives at HTTP/1.1 caches.  For example:

     GET / HTTP/1.1
     Host: www.example.com
     Cache-Control: max-age=30
     Pragma: no-cache

   will constrain HTTP/1.1 caches to serve a response no older than 30
   seconds, while precluding implementations that do not understand
   Cache-Control from serving a cached response.

      Note: Because the meaning of &quot;Pragma: no-cache&quot; in responses is
      not specified, it does not provide a reliable replacement for
      &quot;Cache-Control: no-cache&quot; in them.</source>
          <target state="translated">&amp;ldquo; Pragma&amp;rdquo;标头字段允许与HTTP / 1.0缓存向后兼容，以便客户端可以指定他们将理解的&amp;ldquo; no-cache&amp;rdquo;请求（因为直到HTTP / 1.1才定义了Cache-Control）。当请求中也存在并理解了Cache-Control标头字段时，将忽略Pragma。在HTTP / 1.0中，将Pragma定义为收件人特定于实现的指令的可扩展字段。本规范不赞成使用此类扩展来提高互操作性。 Pragma = 1＃pragma指令pragma指令=&amp;ldquo; no-cache&amp;rdquo; / extension-pragma extension-pragma = token [&amp;ldquo; =&amp;rdquo;（token / quoted-string）]当请求中不存在Cache-Control标头字段时，缓存必须认为无缓存请求的pragma-directive具有与出现&amp;ldquo; Cache-Control：no-cache&amp;rdquo;相同的效果（请参阅 &lt;a href=&quot;#section-5.2.1&quot;&gt;第5.2.1节&lt;/a&gt;）。发送无缓存请求时，客户端应同时包含编译指示和缓存控制指令，除非有意省略Cache-Control：no-cache以将其他缓存控制响应指令定向到HTTP / 1.1缓存。例如：GET / HTTP / 1.1主机：www.example.com缓存控制：max-age = 30语法：无缓存将限制HTTP / 1.1缓存提供不超过30秒的响应，同时排除执行该操作的实现无法从提供缓存的响应中了解Cache-Control。注意：由于未指定响应中&amp;ldquo; Pragma：no-cache&amp;rdquo;的含义，因此不能在其中可靠地替代&amp;ldquo; Cache-Control：no-cache&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="056fcf2a31c44d11769adceb052cd538bdba3b52" translate="yes" xml:space="preserve">
          <source>The &quot;Proxy-Authenticate&quot; header field consists of at least one
   challenge that indicates the authentication scheme(s) and parameters
   applicable to the proxy for this effective request URI (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.5&quot;&gt;Section&amp;nbsp;5.5
   of [RFC7230]&lt;/a&gt;).  A proxy MUST send at least one Proxy-Authenticate
   header field in each 407 (Proxy Authentication Required) response
   that it generates.

     Proxy-Authenticate = 1#challenge

   Unlike WWW-Authenticate, the Proxy-Authenticate header field applies
   only to the next outbound client on the response chain.  This is
   because only the client that chose a given proxy is likely to have
   the credentials necessary for authentication.  However, when multiple
   proxies are used within the same administrative domain, such as
   office and regional caching proxies within a large corporate network,
   it is common for credentials to be generated by the user agent and
   passed through the hierarchy until consumed.  Hence, in such a
   configuration, it will appear as if Proxy-Authenticate is being
   forwarded because each proxy will send the same challenge set.

   Note that the parsing considerations for WWW-Authenticate apply to
   this header field as well; see &lt;a href=&quot;#section-4.1&quot;&gt;Section 4.1&lt;/a&gt; for details.</source>
          <target state="translated">&amp;ldquo; Proxy-Authenticate&amp;rdquo;标头字段包含至少一个挑战，该挑战指示适用于此有效请求URI的代理的身份验证方案和参数（&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.5&quot;&gt;[RFC7230] 5.5节）&lt;/a&gt;）。代理必须在其生成的每个407（必需的代理身份验证）响应中至少发送一个Proxy-Authenticate标头字段。 Proxy-Authenticate = 1＃挑战与WWW-Authenticate不同，Proxy-Authenticate标头字段仅适用于响应链上的下一个出站客户端。这是因为只有选择给定代理的客户端才可能具有身份验证所需的凭据。但是，当在同一管理域中使用多个代理（例如大型公司网络中的办公室和区域缓存代理）时，凭据通常由用户代理生成并通过层次结构传递，直到被使用为止。因此，在这种配置下，由于每个代理将发送相同的质询集，因此它看起来好像在转发&amp;ldquo;代理身份验证&amp;rdquo;。注意，WWW-Authenticate的解析注意事项也适用于此标头字段。看到&lt;a href=&quot;#section-4.1&quot;&gt;&lt;/a&gt;详细信息请参见第4.1节。</target>
        </trans-unit>
        <trans-unit id="4e55a01408a5bfa971888b6023693ae2d37ad3ee" translate="yes" xml:space="preserve">
          <source>The &quot;Proxy-Authorization&quot; header field allows the client to identify
   itself (or its user) to a proxy that requires authentication.  Its
   value consists of credentials containing the authentication
   information of the client for the proxy and/or realm of the resource
   being requested.

     Proxy-Authorization = credentials

   Unlike Authorization, the Proxy-Authorization header field applies
   only to the next inbound proxy that demanded authentication using the
   Proxy-Authenticate field.  When multiple proxies are used in a chain,
   the Proxy-Authorization header field is consumed by the first inbound
   proxy that was expecting to receive credentials.  A proxy MAY relay
   the credentials from the client request to the next proxy if that is
   the mechanism by which the proxies cooperatively authenticate a given
   request.</source>
          <target state="translated">&quot;Proxy-Authorization &quot;头字段允许客户端向需要认证的代理标识自己(或其用户)。它的值由包含客户端对所请求资源的代理和/或领域的认证信息的凭证组成。Proxy-Authorization=credentials 与Authorization不同,Proxy-Authorization头字段只适用于下一个使用Proxy-Authenticate字段要求认证的入站代理。当在一个链中使用多个代理时,Proxy-Authorization头字段会被第一个期望接收凭证的入站代理消耗。如果代理合作认证一个给定的请求,代理可以将客户端请求的凭证转发到下一个代理。</target>
        </trans-unit>
        <trans-unit id="b718f4bbb4edbfe4ac380e46d4526fcfa5c21c8b" translate="yes" xml:space="preserve">
          <source>The &quot;Range&quot; header field on a GET request modifies the method
   semantics to request transfer of only one or more subranges of the
   selected representation data, rather than the entire selected
   representation data.

     Range = byte-ranges-specifier / other-ranges-specifier
     other-ranges-specifier = other-range-unit &quot;=&quot; other-range-set
     other-range-set = 1*VCHAR

   A server MAY ignore the Range header field.  However, origin servers
   and intermediate caches ought to support byte ranges when possible,
   since Range supports efficient recovery from partially failed
   transfers and partial retrieval of large representations.  A server
   MUST ignore a Range header field received with a request method other
   than GET.

   An origin server MUST ignore a Range header field that contains a
   range unit it does not understand.  A proxy MAY discard a Range
   header field that contains a range unit it does not understand.

   A server that supports range requests MAY ignore or reject a Range
   header field that consists of more than two overlapping ranges, or a
   set of many small ranges that are not listed in ascending order,
   since both are indications of either a broken client or a deliberate
   denial-of-service attack (&lt;a href=&quot;#section-6.1&quot;&gt;Section 6.1&lt;/a&gt;).  A client SHOULD NOT request
   multiple ranges that are inherently less efficient to process and
   transfer than a single range that encompasses the same data.

   A client that is requesting multiple ranges SHOULD list those ranges
   in ascending order (the order in which they would typically be
   received in a complete representation) unless there is a specific
   need to request a later part earlier.  For example, a user agent
   processing a large representation with an internal catalog of parts
   might need to request later parts first, particularly if the
   representation consists of pages stored in reverse order and the user
   agent wishes to transfer one page at a time.

   The Range header field is evaluated after evaluating the precondition
   header fields defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC7232&lt;/a&gt;], and only if the result in absence
   of the Range header field would be a 200 (OK) response.  In other
   words, Range is ignored when a conditional GET would result in a 304
   (Not Modified) response. 

   The If-Range header field (&lt;a href=&quot;#section-3.2&quot;&gt;Section 3.2&lt;/a&gt;) can be used as a precondition
   to applying the Range header field.

   If all of the preconditions are true, the server supports the Range
   header field for the target resource, and the specified range(s) are
   valid and satisfiable (as defined in &lt;a href=&quot;#section-2.1&quot;&gt;Section 2.1&lt;/a&gt;), the server SHOULD
   send a 206 (Partial Content) response with a payload containing one
   or more partial representations that correspond to the satisfiable
   ranges requested, as defined in &lt;a href=&quot;#section-4&quot;&gt;Section 4&lt;/a&gt;.

   If all of the preconditions are true, the server supports the Range
   header field for the target resource, and the specified range(s) are
   invalid or unsatisfiable, the server SHOULD send a 416 (Range Not
   Satisfiable) response.</source>
          <target state="translated">GET请求上的&amp;ldquo; Range&amp;rdquo;标头字段修改了方法语义，以请求仅传输所选表示形式数据的一个或多个子范围，而不是整个所选表示形式数据的传输。范围=字节范围说明符/其他范围说明符其他范围说明符=其他范围单位&amp;ldquo; =&amp;rdquo;其他范围设置其他范围设置= 1 * VCHAR服务器可以忽略范围标头字段。但是，原始服务器和中间缓存应尽可能支持字节范围，因为Range支持从部分失败的传输和大表示的部分检索中进行有效恢复。服务器必须忽略通过GET以外的请求方法收到的Range标头字段。源服务器必须忽略包含其不理解的范围单位的Range标头字段。代理可以丢弃包含它不理解的范围单位的Range标头字段。支持范围请求的服务器可以忽略或拒绝包含两个以上重叠范围或未按升序列出的许多小范围的集合的Range头字段，因为这两者都表明客户端已损坏或故意拒绝服务攻击 （因为两者都表明客户端已损坏或蓄意拒绝服务攻击（因为两者都表明客户端已损坏或蓄意拒绝服务攻击（&lt;a href=&quot;#section-6.1&quot;&gt;第6.1节&lt;/a&gt;）。客户端不应请求多个范围，这些范围本质上比包含相同数据的单个范围在处理和传输方面效率较低。请求多个范围的客户端应该以升序（通常以完整表示形式接收它们的顺序）列出这些范围，除非特别需要更早地请求后续部分。例如，处理具有内部零件目录的大型表示的用户代理可能需要首先请求以后的部分，特别是如果表示由以相反顺序存储的页面组成并且用户代理希望一次转移一个页面时。在评估[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC7232]中&lt;/a&gt;定义的前提条件标头字段之后，评估范围标头字段]，并且仅当缺少Range标头字段的结果为200（OK）响应时。换句话说，当条件GET产生304（未修改）响应时，将忽略Range。 If-Range标头字段（&lt;a href=&quot;#section-3.2&quot;&gt;第3.2节&lt;/a&gt;）可以用作应用Range标头字段的前提。如果所有前提条件都为真，则服务器支持目标资源的Range标头字段，并且指定的范围有效且可满足要求（如&lt;a href=&quot;#section-2.1&quot;&gt;第2.1节中&lt;/a&gt;所定义），服务器应发送206（部分内容）响应有效负载包含&lt;a href=&quot;#section-4&quot;&gt;第4节中&lt;/a&gt;定义的对应于请求的可满足范围的一个或多个局部表示。如果所有先决条件都为真，则服务器支持目标资源的Range标头字段，并且指定的范围无效或不满足，服务器应发送416（Range Not Satisfiable）响应。</target>
        </trans-unit>
        <trans-unit id="1a6f10ce133a2f9215112587238b74cbf177295e" translate="yes" xml:space="preserve">
          <source>The &quot;Referer&quot; [sic] header field allows the user agent to specify a
   URI reference for the resource from which the target URI was obtained
   (i.e., the &quot;referrer&quot;, though the field name is misspelled).  A user
   agent MUST NOT include the fragment and userinfo components of the
   URI reference [&lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt;], if any, when generating the Referer field
   value.

     Referer = absolute-URI / partial-URI

   The Referer header field allows servers to generate back-links to
   other resources for simple analytics, logging, optimized caching,
   etc.  It also allows obsolete or mistyped links to be found for
   maintenance.  Some servers use the Referer header field as a means of
   denying links from other sites (so-called &quot;deep linking&quot;) or
   restricting cross-site request forgery (CSRF), but not all requests
   contain it.

   Example:

     Referer: http://www.example.org/hypertext/Overview.html

   If the target URI was obtained from a source that does not have its
   own URI (e.g., input from the user keyboard, or an entry within the
   user's bookmarks/favorites), the user agent MUST either exclude the
   Referer field or send it with a value of &quot;about:blank&quot;.

   The Referer field has the potential to reveal information about the
   request context or browsing history of the user, which is a privacy
   concern if the referring resource's identifier reveals personal
   information (such as an account name) or a resource that is supposed
   to be confidential (such as behind a firewall or internal to a
   secured service).  Most general-purpose user agents do not send the
   Referer header field when the referring resource is a local &quot;file&quot; or
   &quot;data&quot; URI.  A user agent MUST NOT send a Referer header field in an
   unsecured HTTP request if the referring page was received with a
   secure protocol.  See &lt;a href=&quot;#section-9.4&quot;&gt;Section 9.4&lt;/a&gt; for additional security
   considerations. 

   Some intermediaries have been known to indiscriminately remove
   Referer header fields from outgoing requests.  This has the
   unfortunate side effect of interfering with protection against CSRF
   attacks, which can be far more harmful to their users.
   Intermediaries and user agent extensions that wish to limit
   information disclosure in Referer ought to restrict their changes to
   specific edits, such as replacing internal domain names with
   pseudonyms or truncating the query and/or path components.  An
   intermediary SHOULD NOT modify or delete the Referer header field
   when the field value shares the same scheme and host as the request
   target.</source>
          <target state="translated">&amp;ldquo; Referer&amp;rdquo; [sic]标头字段允许用户代理为从中获取目标URI的资源指定URI引用（即&amp;ldquo;引荐来源网址&amp;rdquo;，尽管字段名称拼写错误）。用户代理&lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;不得&lt;/a&gt;包含URI参考[ RFC3986]（如果有），则在生成Referer字段值时。 Referer =绝对URI /部分URI Referer头字段允许服务器生成指向其他资源的反向链接，以进行简单分析，日志记录，优化的缓存等。它还允许查找过时或类型错误的链接以进行维护。某些服务器使用Referer标头字段作为拒绝来自其他站点的链接（所谓的&amp;ldquo;深层链接&amp;rdquo;）或限制跨站点请求伪造（CSRF）的一种方法，但并非所有请求都包含该伪造。示例：引荐来源网址：http://www.example.org/hypertext/Overview.html如果目标URI是从没有自己的URI的源中获得的（例如，从用户键盘输入的内容，或者是用户输入的内容）书签/收藏夹），用户代理必须排除&amp;ldquo;引荐来源&amp;rdquo;字段或将其发送为&amp;ldquo; about：blank&amp;rdquo;。 Referer字段具有揭示有关用户请求上下文或浏览历史的信息的潜力，如果引用资源的标识符泄露了个人信息（例如帐户名）或被认为是机密的资源（例如，例如防火墙后面或安全服务内部）。当引用资源是本地&amp;ldquo;文件&amp;rdquo;或&amp;ldquo;数据&amp;rdquo; URI时，大多数通用用户代理不会发送&amp;ldquo;引用&amp;rdquo;标头字段。如果使用安全协议接收了引荐页，则用户代理不得在不安全的HTTP请求中发送引荐标头字段。看到Referer字段具有揭示有关用户请求上下文或浏览历史记录的信息的潜力，如果引用资源的标识符泄露了个人信息（例如帐户名）或被认为是机密的资源（例如，例如防火墙后面或安全服务内部）。当引荐资源是本地&amp;ldquo;文件&amp;rdquo;或&amp;ldquo;数据&amp;rdquo; URI时，大多数通用用户代理都不发送引荐标头字段。如果使用安全协议接收了引荐页，则用户代理不得在不安全的HTTP请求中发送引荐标头字段。看到Referer字段具有揭示有关用户请求上下文或浏览历史记录的信息的潜力，如果引用资源的标识符泄露了个人信息（例如帐户名）或被认为是机密的资源（例如，例如防火墙后面或安全服务内部）。当引荐资源是本地&amp;ldquo;文件&amp;rdquo;或&amp;ldquo;数据&amp;rdquo; URI时，大多数通用用户代理都不发送引荐标头字段。如果使用安全协议接收了引荐页，则用户代理不得在不安全的HTTP请求中发送引荐标头字段。看到的标识符显示个人信息（例如帐户名）或应该被视为机密的资源（例如在防火墙后面或受保护的服务内部）。当引荐资源是本地&amp;ldquo;文件&amp;rdquo;或&amp;ldquo;数据&amp;rdquo; URI时，大多数通用用户代理都不发送引荐标头字段。如果使用安全协议接收了引荐页，则用户代理不得在不安全的HTTP请求中发送引荐标头字段。看到的标识符显示个人信息（例如帐户名）或应该被视为机密的资源（例如在防火墙后面或受保护的服务内部）。当引荐资源是本地&amp;ldquo;文件&amp;rdquo;或&amp;ldquo;数据&amp;rdquo; URI时，大多数通用用户代理都不发送引荐标头字段。如果使用安全协议接收了引荐页，则用户代理不得在不安全的HTTP请求中发送引荐标头字段。看到如果使用安全协议接收了引荐页，则用户代理不得在不安全的HTTP请求中发送引荐标头字段。看到如果使用安全协议接收了引荐页，则用户代理不得在不安全的HTTP请求中发送引荐标头字段。看到&lt;a href=&quot;#section-9.4&quot;&gt;&lt;/a&gt;有关其他安全注意事项的第9.4节。已知某些中介会从传出的请求中不加选择地删除Referer标头字段。不幸的是，这种干扰干扰了针对CSRF攻击的保护，这可能对其用户造成更大的危害。希望限制Referer中信息公开的中介程序和用户代理扩展应将其更改限制为特定的编辑，例如用化名替换内部域名或截断查询和/或路径组件。当字段值与请求目标共享相同的方案和主机时，中间人不应修改或删除Referer标头字段。</target>
        </trans-unit>
        <trans-unit id="d19493afa0fd7d7d38b18500fe6b7e410894e8e6" translate="yes" xml:space="preserve">
          <source>The &quot;Server&quot; header field contains information about the software
   used by the origin server to handle the request, which is often used
   by clients to help identify the scope of reported interoperability
   problems, to work around or tailor requests to avoid particular
   server limitations, and for analytics regarding server or operating
   system use.  An origin server MAY generate a Server field in its
   responses.

     Server = product *( RWS ( product / comment ) )

   The Server field-value consists of one or more product identifiers,
   each followed by zero or more comments (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;Section&amp;nbsp;3.2 of [RFC7230]&lt;/a&gt;),
   which together identify the origin server software and its
   significant subproducts.  By convention, the product identifiers are
   listed in decreasing order of their significance for identifying the
   origin server software.  Each product identifier consists of a name
   and optional version, as defined in &lt;a href=&quot;#section-5.5.3&quot;&gt;Section 5.5.3&lt;/a&gt;.

   Example:

     Server: CERN/3.0 libwww/2.17

   An origin server SHOULD NOT generate a Server field containing
   needlessly fine-grained detail and SHOULD limit the addition of
   subproducts by third parties.  Overly long and detailed Server field
   values increase response latency and potentially reveal internal
   implementation details that might make it (slightly) easier for
   attackers to find and exploit known security holes.</source>
          <target state="translated">&amp;ldquo;服务器&amp;rdquo;标头字段包含有关原始服务器用于处理请求的软件的信息，客户端通常使用该信息来帮助识别报告的互操作性问题的范围，解决或调整请求以避免特定的服务器限制，以及有关服务器或操作系统使用情况的分析。原始服务器可以在其响应中生成一个服务器字段。服务器=产品*（RWS（产品/注释））服务器字段值由一个或多个产品标识符组成，每个标识符后跟零个或多个注释（&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;[RFC7230]第3.2节&lt;/a&gt;），一起确定原始服务器软件及其重要的子产品。按照惯例，产品标识符以其重要性的降序排列，以标识原始服务器软件。每个产品标识符都包含一个名称和可选版本，如&lt;a href=&quot;#section-5.5.3&quot;&gt;第5.5.3节中&lt;/a&gt;所定义。示例：服务器：CERN / 3.0 libwww / 2.17原始服务器不应生成包含不必要的细粒度细节的服务器字段，并且应限制第三方添加子产品。太长且过于详细的&amp;ldquo;服务器&amp;rdquo;字段值会增加响应延迟，并可能揭示内部实施细节，这可能使攻击者（略）容易地发现并利用已知的安全漏洞。</target>
        </trans-unit>
        <trans-unit id="bf7a34c8bf8ec710d19c3accad390aa1affece68" translate="yes" xml:space="preserve">
          <source>The &quot;TE&quot; header field in a request indicates what transfer codings,
   besides chunked, the client is willing to accept in response, and
   whether or not the client is willing to accept trailer fields in a
   chunked transfer coding.

   The TE field-value consists of a comma-separated list of transfer
   coding names, each allowing for optional parameters (as described in
   &lt;a href=&quot;#section-4&quot;&gt;Section 4&lt;/a&gt;), and/or the keyword &quot;trailers&quot;.  A client MUST NOT send
   the chunked transfer coding name in TE; chunked is always acceptable
   for HTTP/1.1 recipients.

     TE        = #t-codings
     t-codings = &quot;trailers&quot; / ( transfer-coding [ t-ranking ] )
     t-ranking = OWS &quot;;&quot; OWS &quot;q=&quot; rank
     rank      = ( &quot;0&quot; [ &quot;.&quot; 0*3DIGIT ] )
                / ( &quot;1&quot; [ &quot;.&quot; 0*3(&quot;0&quot;) ] )

   Three examples of TE use are below.

     TE: deflate
     TE:
     TE: trailers, deflate;q=0.5

   The presence of the keyword &quot;trailers&quot; indicates that the client is
   willing to accept trailer fields in a chunked transfer coding, as
   defined in &lt;a href=&quot;#section-4.1.2&quot;&gt;Section 4.1.2&lt;/a&gt;, on behalf of itself and any downstream
   clients.  For requests from an intermediary, this implies that
   either: (a) all downstream clients are willing to accept trailer
   fields in the forwarded response; or, (b) the intermediary will
   attempt to buffer the response on behalf of downstream recipients.
   Note that HTTP/1.1 does not define any means to limit the size of a
   chunked response such that an intermediary can be assured of
   buffering the entire response.

   When multiple transfer codings are acceptable, the client MAY rank
   the codings by preference using a case-insensitive &quot;q&quot; parameter
   (similar to the qvalues used in content negotiation fields, Section 

   5.3.1 of [&lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt;]).  The rank value is a real number in the range 0
   through 1, where 0.001 is the least preferred and 1 is the most
   preferred; a value of 0 means &quot;not acceptable&quot;.

   If the TE field-value is empty or if no TE field is present, the only
   acceptable transfer coding is chunked.  A message with no transfer
   coding is always acceptable.

   Since the TE header field only applies to the immediate connection, a
   sender of TE MUST also send a &quot;TE&quot; connection option within the
   Connection header field (&lt;a href=&quot;#section-6.1&quot;&gt;Section 6.1&lt;/a&gt;) in order to prevent the TE
   field from being forwarded by intermediaries that do not support its
   semantics.</source>
          <target state="translated">请求中的&amp;ldquo; TE&amp;rdquo;标头字段指示除了分块传输之外，客户端还愿意接受哪些传输编码，以及客户端是否愿意接受分块传输编码中的尾部字段。 TE字段值由逗号分隔的传输编码名称列表组成，每个传输编码名称都允许使用可选参数（如&lt;a href=&quot;#section-4&quot;&gt;第4节&lt;/a&gt;所述） ）和/或关键字&amp;ldquo; trailers&amp;rdquo;。客户端不得在TE中发送分块的传输编码名称； HTTP / 1.1收件人始终可以接受分块。 TE =＃t-codings t-codings =&amp;ldquo; trailers&amp;rdquo; /（传输编码[t-ranking]）t-ranking = OWS&amp;ldquo;;&amp;rdquo; OWS&amp;ldquo; q =&amp;rdquo; rank rank =（&amp;ldquo; 0&amp;rdquo; [&amp;ldquo;。&amp;rdquo; 0 * 3DIGIT]）/（&amp;ldquo; 1&amp;rdquo; [&amp;ldquo;。&amp;rdquo; 0 * 3（&amp;ldquo; 0&amp;rdquo;）]）以下是TE使用的三个示例。 TE：deflate TE：TE：拖车，deflate; q = 0.5关键字&amp;ldquo; trailers&amp;rdquo;的存在表示客户端愿意接受分块传输编码中的拖车字段，如&lt;a href=&quot;#section-4.1.2&quot;&gt;第4.1.2节中&lt;/a&gt;所定义，代表自身和任何下游客户。对于来自中介的请求，这意味着：（a）所有下游客户端都愿意在转发的响应中接受尾部字段； （b）中介机构将尝试代表下游接收方缓冲响应。请注意，HTTP / 1.1并未定义任何手段来限制分块响应的大小，从而可以确保中间人可以缓冲整个响应。当可接受多种传输编码时，客户端可以使用不区分大小写的&amp;ldquo; q&amp;rdquo;参数（与内容协商字段中使用的qvalue相似，[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231的&lt;/a&gt; 5.3.1节]）按优先级对编码进行排序。]）。等级值是介于0到1之间的实数，其中0.001是最不优选的，而1是最优选的；值为0表示&amp;ldquo;不可接受&amp;rdquo;。如果TE字段值为空或不存在TE字段，则仅对可接受的传输编码进行分块。没有传输编码的消息总是可以接受的。由于TE标头字段仅适用于直接连接，因此TE发送方还必须在Connection标头字段（&lt;a href=&quot;#section-6.1&quot;&gt;第6.1节&lt;/a&gt;）中发送&amp;ldquo; TE&amp;rdquo;连接选项，以防止不支持该功能的中介转发TE字段它的语义。</target>
        </trans-unit>
        <trans-unit id="642dca3b33f00cb08595b70f704b7b8a5ca96a77" translate="yes" xml:space="preserve">
          <source>The &quot;Upgrade&quot; header field is intended to provide a simple mechanism
   for transitioning from HTTP/1.1 to some other protocol on the same
   connection.  A client MAY send a list of protocols in the Upgrade
   header field of a request to invite the server to switch to one or
   more of those protocols, in order of descending preference, before
   sending the final response.  A server MAY ignore a received Upgrade
   header field if it wishes to continue using the current protocol on
   that connection.  Upgrade cannot be used to insist on a protocol
   change.

     Upgrade          = 1#protocol

     protocol         = protocol-name [&quot;/&quot; protocol-version]
     protocol-name    = token
     protocol-version = token

   A server that sends a 101 (Switching Protocols) response MUST send an
   Upgrade header field to indicate the new protocol(s) to which the
   connection is being switched; if multiple protocol layers are being
   switched, the sender MUST list the protocols in layer-ascending
   order.  A server MUST NOT switch to a protocol that was not indicated
   by the client in the corresponding request's Upgrade header field.  A 

   server MAY choose to ignore the order of preference indicated by the
   client and select the new protocol(s) based on other factors, such as
   the nature of the request or the current load on the server.

   A server that sends a 426 (Upgrade Required) response MUST send an
   Upgrade header field to indicate the acceptable protocols, in order
   of descending preference.

   A server MAY send an Upgrade header field in any other response to
   advertise that it implements support for upgrading to the listed
   protocols, in order of descending preference, when appropriate for a
   future request.

   The following is a hypothetical example sent by a client:

     GET /hello.txt HTTP/1.1
     Host: www.example.com
     Connection: upgrade
     Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11


   The capabilities and nature of the application-level communication
   after the protocol change is entirely dependent upon the new
   protocol(s) chosen.  However, immediately after sending the 101
   (Switching Protocols) response, the server is expected to continue
   responding to the original request as if it had received its
   equivalent within the new protocol (i.e., the server still has an
   outstanding request to satisfy after the protocol has been changed,
   and is expected to do so without requiring the request to be
   repeated).

   For example, if the Upgrade header field is received in a GET request
   and the server decides to switch protocols, it first responds with a
   101 (Switching Protocols) message in HTTP/1.1 and then immediately
   follows that with the new protocol's equivalent of a response to a
   GET on the target resource.  This allows a connection to be upgraded
   to protocols with the same semantics as HTTP without the latency cost
   of an additional round trip.  A server MUST NOT switch protocols
   unless the received message semantics can be honored by the new
   protocol; an OPTIONS request can be honored by any protocol. 

   The following is an example response to the above hypothetical
   request:

     HTTP/1.1 101 Switching Protocols
     Connection: upgrade
     Upgrade: HTTP/2.0

     [... data stream switches to HTTP/2.0 with an appropriate response
     (as defined by new protocol) to the &quot;GET /hello.txt&quot; request ...]

   When Upgrade is sent, the sender MUST also send a Connection header
   field (&lt;a href=&quot;#section-6.1&quot;&gt;Section 6.1&lt;/a&gt;) that contains an &quot;upgrade&quot; connection option, in
   order to prevent Upgrade from being accidentally forwarded by
   intermediaries that might not implement the listed protocols.  A
   server MUST ignore an Upgrade header field that is received in an
   HTTP/1.0 request.

   A client cannot begin using an upgraded protocol on the connection
   until it has completely sent the request message (i.e., the client
   can't change the protocol it is sending in the middle of a message).
   If a server receives both an Upgrade and an Expect header field with
   the &quot;100-continue&quot; expectation (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-5.1.1&quot;&gt;Section&amp;nbsp;5.1.1 of [RFC7231]&lt;/a&gt;), the
   server MUST send a 100 (Continue) response before sending a 101
   (Switching Protocols) response.

   The Upgrade header field only applies to switching protocols on top
   of the existing connection; it cannot be used to switch the
   underlying connection (transport) protocol, nor to switch the
   existing communication to a different connection.  For those
   purposes, it is more appropriate to use a 3xx (Redirection) response
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6.4&quot;&gt;Section&amp;nbsp;6.4 of [RFC7231]&lt;/a&gt;).

   This specification only defines the protocol name &quot;HTTP&quot; for use by
   the family of Hypertext Transfer Protocols, as defined by the HTTP
   version rules of &lt;a href=&quot;#section-2.6&quot;&gt;Section 2.6&lt;/a&gt; and future updates to this
   specification.  Additional tokens ought to be registered with IANA
   using the registration procedure defined in &lt;a href=&quot;#section-8.6&quot;&gt;Section 8.6&lt;/a&gt;.</source>
          <target state="translated">&amp;ldquo;升级&amp;rdquo;标头字段旨在提供一种简单的机制，用于在同一连接上从HTTP / 1.1过渡到其他协议。客户端可以在请求的&amp;ldquo;升级&amp;rdquo;报头字段中发送协议列表，以邀请服务器在发送最终响应之前，按照优先级从高到低的顺序切换到这些协议中的一个或多个。如果服务器希望继续在该连接上使用当前协议，则可以忽略收到的升级头字段。升级不能用于坚持更改协议。升级= 1＃protocol协议=协议名称[&amp;ldquo; /&amp;rdquo;[协议版本]协议名称=令牌协议版本=令牌发送101（交换协议）响应的服务器必须发送升级报头字段，以指示将连接切换到的新协议。如果要交换多个协议层，则发送方务必按层升序列出协议。服务器不得切换到客户端在相应请求的&amp;ldquo;升级&amp;rdquo;标头字段中未指定的协议。服务器可以选择忽略客户端指示的优先顺序，并基于其他因素（例如请求的性质或服务器上的当前负载）选择新协议。发送426（需要升级）响应的服务器务必发送升级标头字段以指示可接受的协议，按降序排列。服务器可以在任何其他响应中发送一个Upgrade标头字段，以通告它实现了对升级到列出的协议的支持，在适合将来的请求时，按降序排列。以下是客户端发送的假设示例：GET /hello.txt HTTP / 1.1主机：www.example.com连接：升级升级：HTTP / 2.0，SHTTP / 1.3，IRC / 6.9，RTA / x11功能和性质协议更改后的应用程序级通信的完全依赖于所选的新协议。但是，发送完101（交换协议）响应后，服务器应立即继续响应原始请求，就好像它已在新协议中收到了它的等效请求一样（即，更改协议后，服务器仍然有未完成的请求可以满足，并且可以做到而无需重复请求。例如，如果在GET请求中收到了Upgrade标头字段，并且服务器决定切换协议，则服务器首先以HTTP / 1.1的101（切换协议）消息进行响应，然后立即以等效于新协议的响应进行响应到目标资源上的GET。这样就可以将连接升级为具有与HTTP相同语义的协议，而无需花费额外的往返时间。除非接收到的消息语义可以被新协议所接受，否则服务器不得切换协议。 OPTIONS请求可以通过任何协议来接受。以下是对上述假设请求的示例响应：HTTP / 1.1 101交换协议连接：升级升级：HTTP / 2.0 [...数据流切换到HTTP / 2.0，同时具有对新协议定义的适当响应（由新协议定义）。 &amp;ldquo; GET /hello.txt&amp;rdquo;请求...]发送升级消息后，发送方还必须发送一个Connection标头字段（&lt;a href=&quot;#section-6.1&quot;&gt;第6.1节&lt;/a&gt;）包含&amp;ldquo;升级&amp;rdquo;连接选项，以防止可能未实现所列协议的中间人意外转发升级。服务器必须忽略在HTTP / 1.0请求中收到的Upgrade标头字段。直到客户端完全发送了请求消息，客户端才能开始在连接上使用升级的协议（即，客户端无法更改在消息中间发送的协议）。如果服务器同时收到带有&amp;ldquo; 100-continue&amp;rdquo;期望的&amp;ldquo; Upgrade&amp;rdquo;和&amp;ldquo; Expect&amp;rdquo;标头字段（&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-5.1.1&quot;&gt;[RFC7231]的5.1.1节）&lt;/a&gt;），服务器必须先发送100（继续）响应，然后再发送101（交换协议）响应。升级标头字段仅适用于现有连接之上的交换协议。它不能用于切换基础连接（传输）协议，也不能用于将现有通信切换到其他连接。为此，使用3xx（重定向）响应（&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6.4&quot;&gt;[RFC7231]的6.4节&lt;/a&gt;）更为合适。本规范仅定义协议名称&amp;ldquo; HTTP&amp;rdquo;，以供超文本传输​​协议系列使用，如&lt;a href=&quot;#section-2.6&quot;&gt;2.6节&lt;/a&gt;的HTTP版本规则以及对该规范的将来更新所定义。其他令牌应使用定义的注册程序向IANA注册&lt;a href=&quot;#section-8.6&quot;&gt;第8.6节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cca24e17d2817ed4fdcf6d3f466ac894c19b3c68" translate="yes" xml:space="preserve">
          <source>The &quot;User-Agent&quot; header field contains information about the user
   agent originating the request, which is often used by servers to help
   identify the scope of reported interoperability problems, to work
   around or tailor responses to avoid particular user agent
   limitations, and for analytics regarding browser or operating system
   use.  A user agent SHOULD send a User-Agent field in each request
   unless specifically configured not to do so.

     User-Agent = product *( RWS ( product / comment ) )

   The User-Agent field-value consists of one or more product
   identifiers, each followed by zero or more comments (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;Section&amp;nbsp;3.2 of
   [RFC7230]&lt;/a&gt;), which together identify the user agent software and its
   significant subproducts.  By convention, the product identifiers are
   listed in decreasing order of their significance for identifying the
   user agent software.  Each product identifier consists of a name and
   optional version.

     product         = token [&quot;/&quot; product-version]
     product-version = token

   A sender SHOULD limit generated product identifiers to what is
   necessary to identify the product; a sender MUST NOT generate
   advertising or other nonessential information within the product
   identifier.  A sender SHOULD NOT generate information in
   product-version that is not a version identifier (i.e., successive
   versions of the same product name ought to differ only in the
   product-version portion of the product identifier).

   Example:

     User-Agent: CERN-LineMode/2.15 libwww/2.17b3 

   A user agent SHOULD NOT generate a User-Agent field containing
   needlessly fine-grained detail and SHOULD limit the addition of
   subproducts by third parties.  Overly long and detailed User-Agent
   field values increase request latency and the risk of a user being
   identified against their wishes (&quot;fingerprinting&quot;).

   Likewise, implementations are encouraged not to use the product
   tokens of other implementations in order to declare compatibility
   with them, as this circumvents the purpose of the field.  If a user
   agent masquerades as a different user agent, recipients can assume
   that the user intentionally desires to see responses tailored for
   that identified user agent, even if they might not work as well for
   the actual user agent being used.</source>
          <target state="translated">&amp;ldquo;用户代理&amp;rdquo;标头字段包含有关发起请求的用户代理的信息，服务器通常使用该信息来帮助识别报告的互操作性问题的范围，解决或调整响应以避免特定的用户代理限制以及进行分析有关浏览器或操作系统的使用。用户代理应该在每个请求中发送一个User-Agent字段，除非特别配置为不这样做。User-Agent =产品*（RWS（product / comment））User-Agent字段值由一个或多个产品标识符组成，每个标识符后跟零或多个注释（&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;[RFC7230]的3.2节&lt;/a&gt;），一起确定用户代理软件及其重要的子产品。按照惯例，产品标识符以其重要性的降序排列，以标识用户代理软件。每个产品标识符都包含一个名称和可选版本。 product =令牌[&amp;ldquo; /&amp;rdquo; product-version] product-version =令牌发件人应将生成的产品标识符限制为识别产品所需的内容；发送者不得在产品标识符内生成广告或其他非必要信息。发送者不应在产品版本中生成不是版本标识符的信息（即，同一产品名称的后续版本应仅在产品标识符的产品版本部分有所不同）。例：用户代理：CERN-LineMode / 2.15 libwww / 2.17b3用户代理不应生成包含不必要的细粒度细节的用户代理字段，并且应限制第三方添加子产品。太长和太详细的User-Agent字段值会增加请求等待时间，并增加违背其意愿（&amp;ldquo;指纹&amp;rdquo;）识别用户的风险。同样，鼓励实现不要为了声明与其他实现的兼容性而使用其他实现的产品令牌，因为这会绕开该领域的目的。如果用户代理伪装成其他用户代理，则收件人可以假定用户有意希望看到针对该标识的用户代理量身定制的响应，即使它们可能不适用于实际使用的用户代理。CERN-LineMode / 2.15 libwww / 2.17b3用户代理不应生成包含不必要的细粒度细节的User-Agent字段，并且应限制第三方添加子产品。太长和太详细的User-Agent字段值会增加请求等待时间，并增加违背其意愿（&amp;ldquo;指纹&amp;rdquo;）识别用户的风险。同样，鼓励实现不要为了声明与其他实现的兼容性而使用其他实现的产品令牌，因为这会绕开该领域的目的。如果用户代理伪装成其他用户代理，则收件人可以假定用户有意希望看到针对该标识的用户代理量身定制的响应，即使这些响应可能不适用于所使用的实际用户代理。CERN-LineMode / 2.15 libwww / 2.17b3用户代理不应生成包含不必要的细粒度细节的User-Agent字段，并且应限制第三方添加子产品。太长和太详细的User-Agent字段值会增加请求等待时间，并增加违背其意愿（&amp;ldquo;指纹&amp;rdquo;）识别用户的风险。同样，鼓励实现不要为了声明与其他实现的兼容性而使用其他实现的产品令牌，因为这会绕开该领域的目的。如果用户代理伪装成其他用户代理，则收件人可以假定用户有意希望看到针对该标识的用户代理量身定制的响应，即使这些响应可能不适用于所使用的实际用户代理。17b3用户代理不应生成包含不必要的细粒度细节的User-Agent字段，并且应限制第三方添加子产品。太长和太详细的User-Agent字段值会增加请求等待时间，并增加违背其意愿（&amp;ldquo;指纹&amp;rdquo;）识别用户的风险。同样，鼓励实现不要为了声明与其他实现的兼容性而使用其他实现的产品令牌，因为这会绕开该领域的目的。如果用户代理伪装成其他用户代理，则收件人可以假定用户有意希望看到针对该标识的用户代理量身定制的响应，即使这些响应可能不适用于所使用的实际用户代理。17b3用户代理不应生成包含不必要的细粒度细节的User-Agent字段，并且应限制第三方添加子产品。太长和太详细的User-Agent字段值会增加请求等待时间，并增加违背其意愿（&amp;ldquo;指纹&amp;rdquo;）识别用户的风险。同样，鼓励实现不要为了声明与其他实现的兼容性而使用其他实现的产品令牌，因为这会绕开该领域的目的。如果用户代理伪装成其他用户代理，则收件人可以假定用户有意希望看到针对该标识的用户代理量身定制的响应，即使这些响应可能不适用于所使用的实际用户代理。</target>
        </trans-unit>
        <trans-unit id="6bcae230b73127da4f18a6ca33ad2072b01f296a" translate="yes" xml:space="preserve">
          <source>The &quot;Vary&quot; header field in a response describes what parts of a
   request message, aside from the method, Host header field, and
   request target, might influence the origin server's process for
   selecting and representing this response.  The value consists of
   either a single asterisk (&quot;*&quot;) or a list of header field names
   (case-insensitive).

     Vary = &quot;*&quot; / 1#field-name

   A Vary field value of &quot;*&quot; signals that anything about the request
   might play a role in selecting the response representation, possibly
   including elements outside the message syntax (e.g., the client's
   network address).  A recipient will not be able to determine whether
   this response is appropriate for a later request without forwarding
   the request to the origin server.  A proxy MUST NOT generate a Vary
   field with a &quot;*&quot; value.

   A Vary field value consisting of a comma-separated list of names
   indicates that the named request header fields, known as the
   selecting header fields, might have a role in selecting the
   representation.  The potential selecting header fields are not
   limited to those defined by this specification.

   For example, a response that contains

     Vary: accept-encoding, accept-language

   indicates that the origin server might have used the request's
   Accept-Encoding and Accept-Language fields (or lack thereof) as
   determining factors while choosing the content for this response.

   An origin server might send Vary with a list of fields for two
   purposes:

   1.  To inform cache recipients that they MUST NOT use this response
       to satisfy a later request unless the later request has the same
       values for the listed fields as the original request (&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.1&quot;&gt;Section&amp;nbsp;4.1
       of [RFC7234]&lt;/a&gt;).  In other words, Vary expands the cache key
       required to match a new request to the stored cache entry. 

   2.  To inform user agent recipients that this response is subject to
       content negotiation (&lt;a href=&quot;#section-5.3&quot;&gt;Section 5.3&lt;/a&gt;) and that a different
       representation might be sent in a subsequent request if
       additional parameters are provided in the listed header fields
       (proactive negotiation).

   An origin server SHOULD send a Vary header field when its algorithm
   for selecting a representation varies based on aspects of the request
   message other than the method and request target, unless the variance
   cannot be crossed or the origin server has been deliberately
   configured to prevent cache transparency.  For example, there is no
   need to send the Authorization field name in Vary because reuse
   across users is constrained by the field definition (&lt;a href=&quot;https://tools.ietf.org/html/rfc7235#section-4.2&quot;&gt;Section&amp;nbsp;4.2 of
   [RFC7235]&lt;/a&gt;).  Likewise, an origin server might use Cache-Control
   directives (&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2&quot;&gt;Section&amp;nbsp;5.2 of [RFC7234]&lt;/a&gt;) to supplant Vary if it
   considers the variance less significant than the performance cost of
   Vary's impact on caching.</source>
          <target state="translated">响应中的&amp;ldquo; Vary&amp;rdquo;标头字段描述了请求消息的哪些部分，除了方法，主机标头字段和请求目标之外，还可能影响源服务器选择和表示此响应的过程。该值由单个星号（&amp;ldquo; *&amp;rdquo;）或标题字段名称列表（不区分大小写）组成。 Vary =&amp;ldquo; *&amp;rdquo; / 1＃field-name Vary字段值&amp;ldquo; *&amp;rdquo;表示与请求有关的任何内容都可能在选择响应表示中起作用，可能包括消息语法之外的元素（例如，客户端的网络地址） 。如果没有将请求转发到原始服务器，接收者将无法确定此响应是否适合以后的请求。代理不得生成带有&amp;ldquo; *&amp;rdquo;值的Vary字段。由逗号分隔的名称列表组成的Vary字段值表示命名的请求标头字段（称为&amp;ldquo;选择标头&amp;rdquo;字段）可能在选择表示形式中起作用。潜在的选择标题字段不限于本规范定义的字段。例如，包含Vary：accept-encoding，accept-language的响应表示原始服务器在选择此响应的内容时可能已经使用了请求的Accept-Encoding和Accept-Language字段（或缺少字段）作为确定因素。原始服务器可能向Vary发送带有字段列表的字段，用于两个目的：1。通知缓存接收者他们不得使用此响应来满足以后的请求，除非后面的请求在列出的字段中具有与原始请求相同的值（&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.1&quot;&gt;[RFC7234]的4.1节&lt;/a&gt;）。换句话说，Vary扩展了将新请求与存储的缓存项匹配所需的缓存键。 2.通知用户代理收件人此响应需要进行内容协商（&lt;a href=&quot;#section-5.3&quot;&gt;第5.3节）&lt;/a&gt;），并且如果在列出的标头字段中提供了其他参数（主动协商），则可能在后续请求中发送其他表示形式。当源服务器选择表示的算法根据请求消息的方法和请求目标以外的其他方面而变化时，源服务器应发送Vary标头字段，除非不能跨越差异或已故意将源服务器配置为防止高速缓存透明。例如，不需要在Vary中发送Authorization字段名称，因为跨用户的重用受到字段定义的限制（&lt;a href=&quot;https://tools.ietf.org/html/rfc7235#section-4.2&quot;&gt;[RFC7235]的4.2节&lt;/a&gt;）。同样，原始服务器可能使用Cache-Control指令（&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2&quot;&gt;[RFC7234]的5.2节&lt;/a&gt;）如果Vari认为差异不如Vary对缓存的影响的性能成本那么重要，则可以代替Vary。</target>
        </trans-unit>
        <trans-unit id="316863bc1d70a96f56b104e2287a2491c7e69bb0" translate="yes" xml:space="preserve">
          <source>The &quot;Via&quot; header field indicates the presence of intermediate
   protocols and recipients between the user agent and the server (on
   requests) or between the origin server and the client (on responses),
   similar to the &quot;Received&quot; header field in email (&lt;a href=&quot;https://tools.ietf.org/html/rfc5322#section-3.6.7&quot;&gt;Section&amp;nbsp;3.6.7 of
   [RFC5322]&lt;/a&gt;).  Via can be used for tracking message forwards, avoiding
   request loops, and identifying the protocol capabilities of senders
   along the request/response chain.

     Via = 1#( received-protocol RWS received-by [ RWS comment ] )

     received-protocol = [ protocol-name &quot;/&quot; ] protocol-version
                         ; see &lt;a href=&quot;#section-6.7&quot;&gt;Section 6.7&lt;/a&gt;
     received-by       = ( uri-host [ &quot;:&quot; port ] ) / pseudonym
     pseudonym         = token

   Multiple Via field values represent each proxy or gateway that has
   forwarded the message.  Each intermediary appends its own information
   about how the message was received, such that the end result is
   ordered according to the sequence of forwarding recipients. 

   A proxy MUST send an appropriate Via header field, as described
   below, in each message that it forwards.  An HTTP-to-HTTP gateway
   MUST send an appropriate Via header field in each inbound request
   message and MAY send a Via header field in forwarded response
   messages.

   For each intermediary, the received-protocol indicates the protocol
   and protocol version used by the upstream sender of the message.
   Hence, the Via field value records the advertised protocol
   capabilities of the request/response chain such that they remain
   visible to downstream recipients; this can be useful for determining
   what backwards-incompatible features might be safe to use in
   response, or within a later request, as described in &lt;a href=&quot;#section-2.6&quot;&gt;Section 2.6&lt;/a&gt;.
   For brevity, the protocol-name is omitted when the received protocol
   is HTTP.

   The received-by portion of the field value is normally the host and
   optional port number of a recipient server or client that
   subsequently forwarded the message.  However, if the real host is
   considered to be sensitive information, a sender MAY replace it with
   a pseudonym.  If a port is not provided, a recipient MAY interpret
   that as meaning it was received on the default TCP port, if any, for
   the received-protocol.

   A sender MAY generate comments in the Via header field to identify
   the software of each recipient, analogous to the User-Agent and
   Server header fields.  However, all comments in the Via field are
   optional, and a recipient MAY remove them prior to forwarding the
   message.

   For example, a request message could be sent from an HTTP/1.0 user
   agent to an internal proxy code-named &quot;fred&quot;, which uses HTTP/1.1 to
   forward the request to a public proxy at p.example.net, which
   completes the request by forwarding it to the origin server at
   www.example.com.  The request received by www.example.com would then
   have the following Via header field:

     Via: 1.0 fred, 1.1 p.example.net

   An intermediary used as a portal through a network firewall SHOULD
   NOT forward the names and ports of hosts within the firewall region
   unless it is explicitly enabled to do so.  If not enabled, such an
   intermediary SHOULD replace each received-by host of any host behind
   the firewall by an appropriate pseudonym for that host. 

   An intermediary MAY combine an ordered subsequence of Via header
   field entries into a single such entry if the entries have identical
   received-protocol values.  For example,

     Via: 1.0 ricky, 1.1 ethel, 1.1 fred, 1.0 lucy

   could be collapsed to

     Via: 1.0 ricky, 1.1 mertz, 1.0 lucy

   A sender SHOULD NOT combine multiple entries unless they are all
   under the same organizational control and the hosts have already been
   replaced by pseudonyms.  A sender MUST NOT combine entries that have
   different received-protocol values.</source>
          <target state="translated">&amp;ldquo;通过&amp;rdquo;标头字段指示在用户代理和服务器之间（按请求）或在原始服务器和客户端之间（按响应）中间协议和收件人的存在，类似于电子邮件中的&amp;ldquo;已接收&amp;rdquo;标头字段（本&lt;a href=&quot;https://tools.ietf.org/html/rfc5322#section-3.6.7&quot;&gt;节[RFC5322]的3.6.7&lt;/a&gt;）。Via可用于跟踪消息转发，避免请求循环以及识别沿请求/响应链的发送者的协议功能。通过= 1＃（（[RWS注释]接收到的RWS接收协议））= [协议名称&amp;ldquo; /&amp;rdquo;]协议版本；见&lt;a href=&quot;#section-6.7&quot;&gt;6.7节&lt;/a&gt; 接收者=（uri-host [&amp;ldquo;：&amp;rdquo;端口]）/假名假名=令牌多个&amp;ldquo;通过&amp;rdquo;字段值表示已转发邮件的每个代理或网关。每个中介都附加其自己的有关如何接收消息的信息，以便根据转发接收者的顺序对最终结果进行排序。代理必须在其转发的每条消息中发送适当的Via标头字段，如下所述。 HTTP到HTTP网关必须在每个入站请求消息中发送适当的Via头字段，并可以在转发的响应消息中发送Via头字段。对于每个中介，received-protocol指示消息的上游发送方使用的协议和协议版本。因此，Via字段值记录了请求/响应链的广告协议功能，以使它们对下游接收者仍然可见；这对于确定哪些向后不兼容的功能在响应中或以后的请求中可以安全使用很有用，如&lt;a href=&quot;#section-2.6&quot;&gt;第2.6节&lt;/a&gt;。为简便起见，当接收的协议为HTTP时，省略协议名称。字段值的&amp;ldquo;接收人&amp;rdquo;部分通常是随后转发邮件的收件人服务器或客户端的主机和可选端口号。但是，如果真实主机被认为是敏感信息，则发送者可以用化名代替它。如果未提供端口，则接收者可以将其解释为意味着已在默认TCP端口（如果有）上接收到该协议。发送者可以在Via头字段中生成注释，以标识每个接收者的软件，类似于User-Agent和Server头字段。但是，&amp;ldquo;通过&amp;rdquo;字段中的所有注释都是可选的，并且收件人可以在转发消息之前将其删除。例如，可以将请求消息从HTTP / 1.0用户代理发送到名为&amp;ldquo; fred&amp;rdquo;的内部代理，该代理使用HTTP / 1.1将请求转发到位于p.example.net的公共代理，该代理通过转发完成请求并将其发送到www.example.com上的原始服务器。这样，www.example.com收到的请求将具有以下Via标头字段：Via：1.0 fred，1.1 p.example.net通过网络防火墙用作门户的中介不应转发该主机中的主机名和端口。防火墙区域，除非已明确启用它。如果未启用，则这种中介应该用该主机的适当假名替换该防火墙后任何主机的每个接收主机。如果条目具有相同的接收协议值，则中间人可以将Via标头字段条目的有序子序列组合成一个这样的条目。例如，&amp;ldquo; Via：1.0 ricky，1.1 ethel，1.1 fred，1.0 lucy&amp;rdquo;可以折叠为&amp;ldquo; Via：1.0 ricky，1.1 mertz，1.0 lucy&amp;rdquo;。发件人不应该合并多个条目，除非它们都处于同一组织控制之下并且主持人具有已被化名代替。发送者不得组合具有不同接收协议值的条目。0 lucy发送者不应该合并多个条目，除非它们都处于同一组织控制之下并且主机已被假名代替。发送者不得组合具有不同接收协议值的条目。0 lucy发送者不应该合并多个条目，除非它们都处于同一组织控制之下并且主机已被假名代替。发送者不得组合具有不同接收协议值的条目。</target>
        </trans-unit>
        <trans-unit id="9867a861577bfb6c81de727cf7f2304bd8cb13b4" translate="yes" xml:space="preserve">
          <source>The &quot;WWW-Authenticate&quot; header field indicates the authentication
   scheme(s) and parameters applicable to the target resource.

     WWW-Authenticate = 1#challenge

   A server generating a 401 (Unauthorized) response MUST send a
   WWW-Authenticate header field containing at least one challenge.  A
   server MAY generate a WWW-Authenticate header field in other response
   messages to indicate that supplying credentials (or different
   credentials) might affect the response.

   A proxy forwarding a response MUST NOT modify any WWW-Authenticate
   fields in that response.

   User agents are advised to take special care in parsing the field
   value, as it might contain more than one challenge, and each
   challenge can contain a comma-separated list of authentication
   parameters.  Furthermore, the header field itself can occur multiple
   times.

   For instance:

     WWW-Authenticate: Newauth realm=&quot;apps&quot;, type=1,
                       title=&quot;Login to \&quot;apps\&quot;&quot;, Basic realm=&quot;simple&quot;

   This header field contains two challenges; one for the &quot;Newauth&quot;
   scheme with a realm value of &quot;apps&quot;, and two additional parameters
   &quot;type&quot; and &quot;title&quot;, and another one for the &quot;Basic&quot; scheme with a
   realm value of &quot;simple&quot;.

      Note: The challenge grammar production uses the list syntax as
      well.  Therefore, a sequence of comma, whitespace, and comma can
      be considered either as applying to the preceding challenge, or to
      be an empty entry in the list of challenges.  In practice, this
      ambiguity does not affect the semantics of the header field value
      and thus is harmless.</source>
          <target state="translated">WWW-Authenticate &quot;头字段表示适用于目标资源的验证方案和参数。WWW-Authenticate=1#challenge 生成401(Unauthorized)响应的服务器必须发送一个包含至少一个挑战的WWW-Authenticate头字段。服务器可以在其他响应消息中生成一个WWW-Authenticate头字段,以表明提供凭证(或不同的凭证)可能会影响响应。转发响应的代理不得修改该响应中的任何WWW-Authenticate字段。建议用户代理在解析该字段值时特别小心,因为它可能包含多个挑战,而每个挑战可能包含一个逗号分隔的认证参数列表。此外,头字段本身可以出现多次。例如 WWW -Authenticate:Newauth realm=&quot;apps&quot;,type=1,title=&quot;Login to \&quot;apps\&quot;&quot;,Basic realm=&quot;simple&quot; 这个头字段包含两个挑战;一个是 &quot;Newauth &quot;方案的挑战,境界值为 &quot;apps&quot;,还有两个附加参数 &quot;type &quot;和 &quot;title&quot;,另一个是 &quot;Basic &quot;方案的挑战,境界值为 &quot;simple&quot;。注:挑战语法制作也使用列表语法。因此,逗号、空格、逗号的序列既可以认为适用于前面的挑战,也可以认为是挑战列表中的空条目。在实践中,这种歧义并不影响头字段值的语义,因此是无害的。</target>
        </trans-unit>
        <trans-unit id="010ba1a9ad73a34753b90adf3c72f63de66025ee" translate="yes" xml:space="preserve">
          <source>The &quot;Warning&quot; header field is used to carry additional information
   about the status or transformation of a message that might not be
   reflected in the status code.  This information is typically used to
   warn about possible incorrectness introduced by caching operations or
   transformations applied to the payload of the message. 

   Warnings can be used for other purposes, both cache-related and
   otherwise.  The use of a warning, rather than an error status code,
   distinguishes these responses from true failures.

   Warning header fields can in general be applied to any message,
   however some warn-codes are specific to caches and can only be
   applied to response messages.

     Warning       = 1#warning-value

     warning-value = warn-code SP warn-agent SP warn-text
                                           [ SP warn-date ]

     warn-code  = 3DIGIT
     warn-agent = ( uri-host [ &quot;:&quot; port ] ) / pseudonym
                     ; the name or pseudonym of the server adding
                     ; the Warning header field, for use in debugging
                     ; a single &quot;-&quot; is recommended when agent unknown
     warn-text  = quoted-string
     warn-date  = DQUOTE HTTP-date DQUOTE

   Multiple warnings can be generated in a response (either by the
   origin server or by a cache), including multiple warnings with the
   same warn-code number that only differ in warn-text.

   A user agent that receives one or more Warning header fields SHOULD
   inform the user of as many of them as possible, in the order that
   they appear in the response.  Senders that generate multiple Warning
   header fields are encouraged to order them with this user agent
   behavior in mind.  A sender that generates new Warning header fields
   MUST append them after any existing Warning header fields.

   Warnings are assigned three digit warn-codes.  The first digit
   indicates whether the Warning is required to be deleted from a stored
   response after validation:

   o  1xx warn-codes describe the freshness or validation status of the
      response, and so they MUST be deleted by a cache after validation.
      They can only be generated by a cache when validating a cached
      entry, and MUST NOT be generated in any other situation.

   o  2xx warn-codes describe some aspect of the representation that is
      not rectified by a validation (for example, a lossy compression of
      the representation) and they MUST NOT be deleted by a cache after
      validation, unless a full response is sent, in which case they
      MUST be. 

   If a sender generates one or more 1xx warn-codes in a message to be
   sent to a recipient known to implement only HTTP/1.0, the sender MUST
   include in each corresponding warning-value a warn-date that matches
   the Date header field in the message.  For example:

     HTTP/1.1 200 OK
     Date: Sat, 25 Aug 2012 23:34:45 GMT
     Warning: 112 - &quot;network down&quot; &quot;Sat, 25 Aug 2012 23:34:45 GMT&quot;


   Warnings have accompanying warn-text that describes the error, e.g.,
   for logging.  It is advisory only, and its content does not affect
   interpretation of the warn-code.

   If a recipient that uses, evaluates, or displays Warning header
   fields receives a warn-date that is different from the Date value in
   the same message, the recipient MUST exclude the warning-value
   containing that warn-date before storing, forwarding, or using the
   message.  This allows recipients to exclude warning-values that were
   improperly retained after a cache validation.  If all of the
   warning-values are excluded, the recipient MUST exclude the Warning
   header field as well.

   The following warn-codes are defined by this specification, each with
   a recommended warn-text in English, and a description of its meaning.
   The procedure for defining additional warn codes is described in
   &lt;a href=&quot;#section-7.2.1&quot;&gt;Section 7.2.1&lt;/a&gt;.</source>
          <target state="translated">&amp;ldquo;警告&amp;rdquo;标头字段用于携带有关消息状态或消息转换的其他信息，这些信息可能不会反映在状态代码中。该信息通常用于警告由缓存操作或应用于消息有效负载的转换所引入的可能的错误。警告可以用于与缓存相关或其他目的的其他目的。使用警告而不是错误状态代码可以将这些响应与真正的故障区分开。警告标头字段通常可以应用于任何消息，但是某些警告代码特定于缓存，并且只能应用于响应消息。警告= 1＃警告值警告值=警告代码SP警告代理SP警告文本[SP警告日期]警告代码= 3DIGIT警告代理=（uri-host [&amp;ldquo;：&amp;rdquo; port]）/化名;服务器添加的名称或别名; Warning标头字段，用于调试；当代理未知warn-text = quoted-string warn-date = DQUOTE HTTP-date DQUOTE时，建议使用单个&amp;ldquo;-&amp;rdquo;。响应中可以生成多个警告（由源服务器或缓存生成），包括带有相同的警告代码号，只是警告文本不同。收到一个或多个警告标头字段的用户代理应将尽可能多的警告标头通知用户，按照它们在响应中出现的顺序。鼓励生成多个Warning标头字段的发件人考虑到此用户代理行为对它们进行排序。产生新警告标题字段的发送者必须将它们附加在任何现有警告标题字段之后。警告被分配了三位数的警告代码。第一位数字表示验证后是否需要从存储的响应中删除警告：o 1xx警告代码描述了响应的新鲜度或验证状态，因此必须在验证后由缓存删除。它们只能在验证缓存的条目时由缓存生成，并且在任何其他情况下都不得生成。o 2xx警告代码描述了表示中未通过验证纠正的某些方面（例如，表示的有损压缩），并且验证之后，除非已发送完整响应，否则它们不得被缓存删除。他们必须如此。如果发件人在要发送给已知仅实现HTTP / 1.0的收件人的消息中生成一个或多个1xx警告代码，则发件人务必在每个相应的警告值中包含与日期中的Date标头字段匹配的警告日期。信息。例如：HTTP / 1.1 200 OK日期：2012年8月25日，星期六，格林尼治标准时间警告：112-&amp;ldquo;网络中断&amp;rdquo;&amp;ldquo; 2012年8月25日，星期六，格林尼治标准时间&amp;rdquo;警告带有伴随的警告文本，描述了错误，例如用于记录。这仅是建议，并且其内容不影响警告代码的解释。如果使用，评估或显示&amp;ldquo;警告&amp;rdquo;标题字段的收件人收到的警告日期与同一封邮件中的&amp;ldquo;日期&amp;rdquo;值不同，则收件人必须在存储，转发或使用前排除包含该警告日期的警告值。消息。这使收件人可以排除在缓存验证后未正确保留的警告值。如果所有警告值都被排除，则接收者也必须排除警告头字段。本规范定义了以下警告代码，每个警告代码均带有建议的英文警告文本以及其含义的描述。定义附加警告代码的过程在如果使用，评估或显示&amp;ldquo;警告&amp;rdquo;标题字段的收件人收到的警告日期与同一封邮件中的&amp;ldquo;日期&amp;rdquo;值不同，则收件人必须在存储，转发或使用前排除包含该警告日期的警告值。消息。这使收件人可以排除在缓存验证后未正确保留的警告值。如果所有警告值都被排除，则接收者也必须排除警告头字段。本规范定义了以下警告代码，每个警告代码均带有建议的英文警告文本以及其含义的描述。定义附加警告代码的过程在如果使用，评估或显示&amp;ldquo;警告&amp;rdquo;标题字段的收件人收到的警告日期与同一封邮件中的&amp;ldquo;日期&amp;rdquo;值不同，则收件人必须在存储，转发或使用前排除包含该警告日期的警告值。消息。这使收件人可以排除在缓存验证后未正确保留的警告值。如果所有警告值都被排除，则接收者也必须排除警告头字段。本规范定义了以下警告代码，每个警告代码均带有建议的英文警告文本以及其含义的描述。定义附加警告代码的过程在或显示警告标头字段接收的警告日期与同一条消息中的&amp;ldquo;日期&amp;rdquo;值不同，接收者必须在存储，转发或使用消息之前排除包含该警告日期的警告值。这使收件人可以排除在缓存验证后未正确保留的警告值。如果所有警告值都被排除，则接收者也必须排除警告头字段。本规范定义了以下警告代码，每个警告代码均带有建议的英文警告文本以及其含义的描述。定义附加警告代码的过程在或显示警告标头字段接收的警告日期与同一条消息中的&amp;ldquo;日期&amp;rdquo;值不同，接收者必须在存储，转发或使用消息之前排除包含该警告日期的警告值。这使收件人可以排除在缓存验证后未正确保留的警告值。如果所有警告值都被排除，则接收者也必须排除警告头字段。本规范定义了以下警告代码，每个警告代码均带有建议的英文警告文本以及其含义的描述。定义附加警告代码的过程在这使收件人可以排除在缓存验证后未正确保留的警告值。如果所有警告值都被排除，则接收者也必须排除警告头字段。本规范定义了以下警告代码，每个警告代码均带有建议的英文警告文本以及其含义的描述。定义附加警告代码的过程在这使收件人可以排除在缓存验证后未正确保留的警告值。如果所有警告值都被排除，则接收者也必须排除警告头字段。本规范定义了以下警告代码，每个警告代码均带有建议的英文警告文本以及其含义的描述。定义附加警告代码的过程在 &lt;a href=&quot;#section-7.2.1&quot;&gt;第7.2.1节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="995d6efd3e0c66344c9a13f1a4baae749a8853bd" translate="yes" xml:space="preserve">
          <source>The &quot;app:categories&quot; element provides a list of the categories that
   can be applied to the members of a Collection.  See &lt;a href=&quot;#section-7.2.1&quot;&gt;Section 7.2.1&lt;/a&gt; for
   the detailed definition of app:categories.

   The server MAY reject attempts to create or store members whose
   categories are not present in its categories list.  A Collection that
   indicates the category set is open SHOULD NOT reject otherwise
   acceptable members whose categories are not in its categories list.
   The absence of an app:categories element means that the category
   handling of the Collection is unspecified.  A &quot;fixed&quot; category list
   that contains zero categories indicates the Collection does not
   accept category data.</source>
          <target state="translated">&amp;ldquo; app：categories&amp;rdquo;元素提供了可以应用于集合成员的类别的列表。有关app：categories的详细定义，请参见&lt;a href=&quot;#section-7.2.1&quot;&gt;第7.2.1节&lt;/a&gt;。服务器可以拒绝创建或存储其类别列表中不存在其类别的成员的尝试。指示类别集已打开的Collection不应拒绝类别不在其类别列表中的其他可接受的成员。没有app：categories元素意味着未指定Collection的类别处理。包含零个类别的&amp;ldquo;固定&amp;rdquo;类别列表表示该集合不接受类别数据。</target>
        </trans-unit>
        <trans-unit id="2862e4bbac71e75234686e57a0b3abd15c18ac9a" translate="yes" xml:space="preserve">
          <source>The &quot;app:collection&quot; element describes a Collection.  The app:
   collection element MUST contain one atom:title element.

   The app:collection element MAY contain any number of app:accept
   elements, indicating the types of representations accepted by the
   Collection.  The order of such elements is not significant.

   The app:collection element MAY contain any number of app:categories
   elements.

   appCollection =
      element app:collection {
         appCommonAttributes,
         attribute href { atomURI  },
         ( atomTitle
           &amp;amp; appAccept*
           &amp;amp; appCategories*
           &amp;amp; extensionSansTitleElement* )
      }</source>
          <target state="translated">&amp;ldquo; app：collection&amp;rdquo;元素描述一个Collection。 app：集合元素必须包含一个atom：title元素。 app：collection元素可以包含任意数量的app：accept元素，指示Collection接受的表示形式。这些元素的顺序并不重要。 app：collection元素可以包含任意数量的app：categories元素。 appCollection =元素app：collection {appCommonAttributes，属性href {atomURI}，（atomTitle和appAccept *＆appCategories *和extensionSansTitleElement *）}</target>
        </trans-unit>
        <trans-unit id="4f92b1bc26a73cb4af47cd72166377ea0b007dfa" translate="yes" xml:space="preserve">
          <source>The &quot;app:edited&quot; element is a Date construct (as defined by
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt;]), whose content indicates the last time an Entry was
   edited.  If the entry has not been edited yet, the content indicates
   the time it was created.  Atom Entry elements in Collection Documents
   SHOULD contain one app:edited element, and MUST NOT contain more than
   one.

   appEdited = element app:edited ( atomDateConstruct )

   The server SHOULD change the value of this element every time an
   Entry Resource or an associated Media Resource has been edited.</source>
          <target state="translated">&amp;ldquo; app：edited&amp;rdquo;元素是Date构造（由[ &lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt; ] 定义），其内容指示上次编辑条目的时间。如果条目尚未被编辑，则内容指示创建时间。收款凭证中的Atom Entry元素应包含一个app：edited元素，并且不得包含多个。appEdited =元素app：edited（atomDateConstruct）每次编辑条目资源或关联的媒体资源时，服务器应更改此元素的值。</target>
        </trans-unit>
        <trans-unit id="68f4c11acf63f6cde7cb7434dea073f5a30ec84b" translate="yes" xml:space="preserve">
          <source>The &quot;atom:title&quot; element is defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt;] and gives a human-
   readable title for the Collection.</source>
          <target state="translated">[atom：title]元素在[ &lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt; ]中定义，并为集合提供了易于阅读的标题。</target>
        </trans-unit>
        <trans-unit id="409b2e89b2d86b6bfc0d29cd3e58e574f2822ac5" translate="yes" xml:space="preserve">
          <source>The &quot;compress&quot; coding is an adaptive Lempel-Ziv-Welch (LZW) coding
   [&lt;a href=&quot;#ref-Welch&quot;&gt;Welch&lt;/a&gt;] that is commonly produced by the UNIX file compression
   program &quot;compress&quot;.  A recipient SHOULD consider &quot;x-compress&quot; to be
   equivalent to &quot;compress&quot;.</source>
          <target state="translated">&amp;ldquo;压缩&amp;rdquo;编码是一种自适应的Lempel-Ziv-Welch（LZW）编码[ &lt;a href=&quot;#ref-Welch&quot;&gt;Welch&lt;/a&gt; ]，通常由UNIX文件压缩程序&amp;ldquo; compress&amp;rdquo;产生。接收者应该认为&amp;ldquo; x-compress&amp;rdquo;等同于&amp;ldquo; compress&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="5450639421b7ec9a5bfb9b3a5351d2c59960ee2f" translate="yes" xml:space="preserve">
          <source>The &quot;data&quot; URL scheme</source>
          <target state="translated">数据 &quot;URL方案</target>
        </trans-unit>
        <trans-unit id="7fec5b6deed76c5c2f6df9fc9a93ea6b5f359e93" translate="yes" xml:space="preserve">
          <source>The &quot;deflate&quot; coding is a &quot;zlib&quot; data format [&lt;a href=&quot;https://tools.ietf.org/html/rfc1950&quot;&gt;RFC1950&lt;/a&gt;] containing a
   &quot;deflate&quot; compressed data stream [&lt;a href=&quot;https://tools.ietf.org/html/rfc1951&quot;&gt;RFC1951&lt;/a&gt;] that uses a combination of
   the Lempel-Ziv (LZ77) compression algorithm and Huffman coding.

      Note: Some non-conformant implementations send the &quot;deflate&quot;
      compressed data without the zlib wrapper.</source>
          <target state="translated">&amp;ldquo;放气&amp;rdquo;编码是一种&amp;ldquo; zlib&amp;rdquo;数据格式[ &lt;a href=&quot;https://tools.ietf.org/html/rfc1950&quot;&gt;RFC1950&lt;/a&gt; ]，其中包含使用了Lempel-Ziv（LZ77）压缩算法和霍夫曼编码的组合的&amp;ldquo;放气&amp;rdquo;压缩数据流[ &lt;a href=&quot;https://tools.ietf.org/html/rfc1951&quot;&gt;RFC1951&lt;/a&gt; ]。注意：一些不一致的实现没有zlib包装器就发送&amp;ldquo;压缩&amp;rdquo;压缩数据。</target>
        </trans-unit>
        <trans-unit id="18f6fc86dc33b8be8746e1979432c3044e14ee93" translate="yes" xml:space="preserve">
          <source>The &quot;gzip&quot; coding is an LZ77 coding with a 32-bit Cyclic Redundancy
   Check (CRC) that is commonly produced by the gzip file compression
   program [&lt;a href=&quot;https://tools.ietf.org/html/rfc1952&quot;&gt;RFC1952&lt;/a&gt;].  A recipient SHOULD consider &quot;x-gzip&quot; to be
   equivalent to &quot;gzip&quot;.</source>
          <target state="translated">&amp;ldquo; gzip&amp;rdquo;编码是带有32位循环冗余校验（CRC）的LZ77编码，通常由gzip文件压缩程序[ &lt;a href=&quot;https://tools.ietf.org/html/rfc1952&quot;&gt;RFC1952&lt;/a&gt; ]产生。接收者应将&amp;ldquo; x-gzip&amp;rdquo;等同于&amp;ldquo; gzip&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="3da79a4d757a4b703e27456e900e76eca528f808" translate="yes" xml:space="preserve">
          <source>The &quot;http&quot; URI scheme is hereby defined for the purpose of minting
   identifiers according to their association with the hierarchical
   namespace governed by a potential HTTP origin server listening for
   TCP ([&lt;a href=&quot;https://tools.ietf.org/html/rfc0793&quot;&gt;RFC0793&lt;/a&gt;]) connections on a given port.

     http-URI = &quot;http:&quot; &quot;//&quot; authority path-abempty [ &quot;?&quot; query ]
                [ &quot;#&quot; fragment ]

   The origin server for an &quot;http&quot; URI is identified by the authority
   component, which includes a host identifier and optional TCP port
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.2.2&quot;&gt;[RFC3986], Section&amp;nbsp;3.2.2&lt;/a&gt;).  The hierarchical path component and
   optional query component serve as an identifier for a potential
   target resource within that origin server's name space.  The optional
   fragment component allows for indirect identification of a secondary
   resource, independent of the URI scheme, as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.5&quot;&gt;Section&amp;nbsp;3.5 of
   [RFC3986]&lt;/a&gt;.

   A sender MUST NOT generate an &quot;http&quot; URI with an empty host
   identifier.  A recipient that processes such a URI reference MUST
   reject it as invalid.

   If the host identifier is provided as an IP address, the origin
   server is the listener (if any) on the indicated TCP port at that IP
   address.  If host is a registered name, the registered name is an
   indirect identifier for use with a name resolution service, such as
   DNS, to find an address for that origin server.  If the port
   subcomponent is empty or not given, TCP port 80 (the reserved port
   for WWW services) is the default.

   Note that the presence of a URI with a given authority component does
   not imply that there is always an HTTP server listening for
   connections on that host and port.  Anyone can mint a URI.  What the
   authority component determines is who has the right to respond
   authoritatively to requests that target the identified resource.  The
   delegated nature of registered names and IP addresses creates a
   federated namespace, based on control over the indicated host and
   port, whether or not an HTTP server is present.  See &lt;a href=&quot;#section-9.1&quot;&gt;Section 9.1&lt;/a&gt; for
   security considerations related to establishing authority.

   When an &quot;http&quot; URI is used within a context that calls for access to
   the indicated resource, a client MAY attempt access by resolving the
   host to an IP address, establishing a TCP connection to that address
   on the indicated port, and sending an HTTP request message
   (&lt;a href=&quot;#section-3&quot;&gt;Section 3&lt;/a&gt;) containing the URI's identifying data (&lt;a href=&quot;#section-5&quot;&gt;Section 5&lt;/a&gt;) to the
   server.  If the server responds to that request with a non-interim 

   HTTP response message, as described in &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6&quot;&gt;Section&amp;nbsp;6 of [RFC7231]&lt;/a&gt;, then
   that response is considered an authoritative answer to the client's
   request.

   Although HTTP is independent of the transport protocol, the &quot;http&quot;
   scheme is specific to TCP-based services because the name delegation
   process depends on TCP for establishing authority.  An HTTP service
   based on some other underlying connection protocol would presumably
   be identified using a different URI scheme, just as the &quot;https&quot;
   scheme (below) is used for resources that require an end-to-end
   secured connection.  Other protocols might also be used to provide
   access to &quot;http&quot; identified resources -- it is only the authoritative
   interface that is specific to TCP.

   The URI generic syntax for authority also includes a deprecated
   userinfo subcomponent (&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.2.1&quot;&gt;[RFC3986], Section&amp;nbsp;3.2.1&lt;/a&gt;) for including user
   authentication information in the URI.  Some implementations make use
   of the userinfo component for internal configuration of
   authentication information, such as within command invocation
   options, configuration files, or bookmark lists, even though such
   usage might expose a user identifier or password.  A sender MUST NOT
   generate the userinfo subcomponent (and its &quot;@&quot; delimiter) when an
   &quot;http&quot; URI reference is generated within a message as a request
   target or header field value.  Before making use of an &quot;http&quot; URI
   reference received from an untrusted source, a recipient SHOULD parse
   for userinfo and treat its presence as an error; it is likely being
   used to obscure the authority for the sake of phishing attacks.</source>
          <target state="translated">在此定义&amp;ldquo; http&amp;rdquo; URI方案的目的是根据标识符与分层名称空间的关联来铸造标识符，该命名空间由潜在的HTTP原始服务器在给定端口上侦听TCP（[ &lt;a href=&quot;https://tools.ietf.org/html/rfc0793&quot;&gt;RFC0793&lt;/a&gt; ]）连接所控制。 http-URI =&amp;ldquo; http：&amp;rdquo;&amp;ldquo; //&amp;rdquo;权限路径为空[&amp;ldquo;？&amp;rdquo; query] [&amp;ldquo;＃&amp;rdquo;片段]&amp;ldquo; http&amp;rdquo; URI的原始服务器由权限组件标识，该组件包括主机标识符和可选的TCP端口（&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.2.2&quot;&gt;[RFC3986]，第3.2.2节&lt;/a&gt;）。分层路径组件和可选查询组件充当该原始服务器名称空间内潜在目标资源的标识符。可选的片段组件允许间接标识辅助资源，而与&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.5&quot;&gt;[URI3986]第3.5节中&lt;/a&gt;定义的URI方案无关。。发送者不得生成带有空主机标识符的&amp;ldquo; http&amp;rdquo; URI。处理此类URI引用的接收者务必将其视为无效。如果将主机标识符作为IP地址提供，则原始服务器是该IP地址上指示的TCP端口上的侦听器（如果有）。如果host是注册名称，则注册名称是用于名称解析服务（例如DNS）的间接标识符，以查找该原始服务器的地址。如果端口子组件为空或未提供，则默认为TCP端口80（WWW服务的保留端口）。请注意，具有给定权限组件的URI的存在并不意味着总是有HTTP服务器在侦听该主机和端口上的连接。任何人都可以创建URI。权限组件确定的是谁有权对以已标识资源为目标的请求进行权威响应。注册名称和IP地址的委托性质基于对指示的主机和端口的控制（无论是否存在HTTP服务器）来创建联合名称空间。看到&lt;a href=&quot;#section-9.1&quot;&gt;&lt;/a&gt;有关建立权限的安全性考虑，请参阅第9.1节。当在要求访问指定资源的上下文中使用&amp;ldquo; http&amp;rdquo; URI时，客户端可以通过以下方式尝试访问：将主机解析为IP地址，在指定端口上建立与该地址的TCP连接，然后发送HTTP向服务器发送包含URI标识数据（&lt;a href=&quot;#section-5&quot;&gt;第5 &lt;/a&gt;&lt;a href=&quot;#section-3&quot;&gt;部分&lt;/a&gt;）的请求消息（第3 部分）。服务器是否使用非临时HTTP响应消息响应该请求，如&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6&quot;&gt;[RFC7231]第6节中&lt;/a&gt;所述，那么该响应将被视为对客户请求的权威答复。尽管HTTP独立于传输协议，但是&amp;ldquo; http&amp;rdquo;方案特定于基于TCP的服务，因为名称委派过程依赖于TCP来建立授权。大概将使用其他URI方案来标识基于某些其他基础连接协议的HTTP服务，就像&amp;ldquo; https&amp;rdquo;方案（以下）用于要求端到端安全连接的资源一样。其他协议也可用于提供对&amp;ldquo; http&amp;rdquo;标识的资源的访问-只是TCP特有的权威接口。授权的URI通用语法还包括不赞成使用的userinfo子组件（&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.2.1&quot;&gt;[RFC3986]，第3.2节。1个&lt;/a&gt;），用于在URI中包含用户身份验证信息。一些实现将userinfo组件用于身份验证信息的内部配置，例如在命令调用选项，配置文件或书签列表中，即使这种用法可能会暴露用户标识符或密码。当在消息中生成&amp;ldquo; http&amp;rdquo; URI引用作为请求目标或标头字段值时，发送方不得生成userinfo子组件（及其&amp;ldquo; @&amp;rdquo;定界符）。在使用从不受信任的来源收到的&amp;ldquo; http&amp;rdquo; URI引用之前，接收者应该解析userinfo并将其存在视为错误；它可能被用来掩盖网络钓鱼攻击的权威。</target>
        </trans-unit>
        <trans-unit id="e8a58311de89d4c408e7b65f13ca2deebb29dec3" translate="yes" xml:space="preserve">
          <source>The &quot;http&quot; scheme is used to locate network resources via the HTTP
   protocol. This section defines the scheme-specific syntax and
   semantics for http URLs.

   http_URL = &quot;http:&quot; &quot;//&quot; host [ &quot;:&quot; port ] [ abs_path [ &quot;?&quot; query ]]

   If the port is empty or not given, port 80 is assumed. The semantics
   are that the identified resource is located at the server listening
   for TCP connections on that port of that host, and the Request-URI
   for the resource is abs_path (&lt;a href=&quot;#section-5.1.2&quot;&gt;section 5.1.2&lt;/a&gt;). The use of IP addresses
   in URLs SHOULD be avoided whenever possible (see &lt;a href=&quot;https://tools.ietf.org/html/rfc1900&quot;&gt;RFC 1900&lt;/a&gt; [&lt;a href=&quot;#ref-24&quot;&gt;24&lt;/a&gt;]). If
   the abs_path is not present in the URL, it MUST be given as &quot;/&quot; when
   used as a Request-URI for a resource (&lt;a href=&quot;#section-5.1.2&quot;&gt;section 5.1.2&lt;/a&gt;). If a proxy
   receives a host name which is not a fully qualified domain name, it
   MAY add its domain to the host name it received. If a proxy receives
   a fully qualified domain name, the proxy MUST NOT change the host
   name.</source>
          <target state="translated">&amp;ldquo; http&amp;rdquo;方案用于通过HTTP协议定位网络资源。本节为http URL定义了特定于方案的语法和语义。 http_URL =&amp;ldquo; http：&amp;rdquo;&amp;ldquo; //&amp;rdquo;主机[&amp;ldquo;：&amp;rdquo;端口] [abs_path [&amp;ldquo;？&amp;rdquo; [查询]]如果端口为空或未提供，则假定端口为80。语义是所标识的资源位于服务器上，用于侦听该主机的该端口上的TCP连接，并且该资源的Request-URI为abs_path（&lt;a href=&quot;#section-5.1.2&quot;&gt;第5.1.2节&lt;/a&gt;）。应尽可能避免在URL中使用IP地址（请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc1900&quot;&gt;RFC 1900&lt;/a&gt; [ &lt;a href=&quot;#ref-24&quot;&gt;24&lt;/a&gt; ]）。如果URL中不存在abs_path，则在用作资源的Request-URI时必须将其指定为&amp;ldquo; /&amp;rdquo;（&lt;a href=&quot;#section-5.1.2&quot;&gt;第5.1节。2&lt;/a&gt;）。如果代理收到的主机名不是完全合格的域名，则可以将其域添加到收到的主机名中。如果代理收到一个完全合格的域名，则该代理不得更改主机名。</target>
        </trans-unit>
        <trans-unit id="73555a35c2933a1c75aa810e673714fa36744ea0" translate="yes" xml:space="preserve">
          <source>The &quot;https&quot; URI scheme is hereby defined for the purpose of minting
   identifiers according to their association with the hierarchical
   namespace governed by a potential HTTP origin server listening to a
   given TCP port for TLS-secured connections ([&lt;a href=&quot;https://tools.ietf.org/html/rfc5246&quot;&gt;RFC5246&lt;/a&gt;]).

   All of the requirements listed above for the &quot;http&quot; scheme are also
   requirements for the &quot;https&quot; scheme, except that TCP port 443 is the
   default if the port subcomponent is empty or not given, and the user
   agent MUST ensure that its connection to the origin server is secured
   through the use of strong encryption, end-to-end, prior to sending
   the first HTTP request.

     https-URI = &quot;https:&quot; &quot;//&quot; authority path-abempty [ &quot;?&quot; query ]
                 [ &quot;#&quot; fragment ]

   Note that the &quot;https&quot; URI scheme depends on both TLS and TCP for
   establishing authority.  Resources made available via the &quot;https&quot;
   scheme have no shared identity with the &quot;http&quot; scheme even if their 

   resource identifiers indicate the same authority (the same host
   listening to the same TCP port).  They are distinct namespaces and
   are considered to be distinct origin servers.  However, an extension
   to HTTP that is defined to apply to entire host domains, such as the
   Cookie protocol [&lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC6265&lt;/a&gt;], can allow information set by one service
   to impact communication with other services within a matching group
   of host domains.

   The process for authoritative access to an &quot;https&quot; identified
   resource is defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2818&quot;&gt;RFC2818&lt;/a&gt;].</source>
          <target state="translated">因此，定义&amp;ldquo; https&amp;rdquo; URI方案的目的是根据标识符与层次名称空间的关联来铸造标识符，该层次名称空间由潜在的HTTP原始服务器管理，该HTTP原始服务器侦听给定的TCP端口以进行TLS保护的连接（[ &lt;a href=&quot;https://tools.ietf.org/html/rfc5246&quot;&gt;RFC5246&lt;/a&gt;]）。上面列出的&amp;ldquo; http&amp;rdquo;方案的所有要求也都是&amp;ldquo; https&amp;rdquo;方案的要求，但如果端口子组件为空或未提供，则默认使用TCP端口443，并且用户代理必须确保其与以下地址的连接：在发送第一个HTTP请求之前，通过使用端到端的强加密来保护源服务器。 https-URI =&amp;ldquo; https：&amp;rdquo;&amp;ldquo; //&amp;rdquo;权限路径为空[&amp;ldquo;？&amp;rdquo;查询] [&amp;ldquo;＃&amp;rdquo;片段]请注意，&amp;ldquo; https&amp;rdquo; URI方案依赖于TLS和TCP来建立授权。通过&amp;ldquo; https&amp;rdquo;方案提供的资源与&amp;ldquo; http&amp;rdquo;没有共享身份即使它们的资源标识符指示相同的权限（侦听同一TCP端口的同一主机），该方案也是如此。它们是不同的名称空间，被认为是不同的原始服务器。但是，HTTP的扩展已定义为适用于整个主机域，例如Cookie协议[&lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC6265&lt;/a&gt; ]可以允许一个服务设置的信息影响与主机域匹配的组中其他服务的通信。在[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2818&quot;&gt;RFC2818&lt;/a&gt; ]中定义了对&amp;ldquo; https&amp;rdquo;标识的资源进行权威访问的过程。</target>
        </trans-unit>
        <trans-unit id="381425c701e0e7786e14ce1ebe204baefd4cf1f3" translate="yes" xml:space="preserve">
          <source>The &quot;must-revalidate&quot; response directive indicates that once it has
   become stale, a cache MUST NOT use the response to satisfy subsequent
   requests without successful validation on the origin server.

   The must-revalidate directive is necessary to support reliable
   operation for certain protocol features.  In all circumstances a
   cache MUST obey the must-revalidate directive; in particular, if a
   cache cannot reach the origin server for any reason, it MUST generate
   a 504 (Gateway Timeout) response.

   The must-revalidate directive ought to be used by servers if and only
   if failure to validate a request on the representation could result
   in incorrect operation, such as a silently unexecuted financial
   transaction.</source>
          <target state="translated">Must-revalidate &quot;响应指令表明,一旦它变得陈旧,在没有在源服务器上成功验证的情况下,缓存不得使用该响应来满足后续请求。Must-revalidate指令对于支持某些协议特性的可靠操作是必要的。在任何情况下,缓存都必须遵守must-revalidate指令;特别是,如果缓存因为任何原因不能到达源服务器,它必须生成504(网关超时)响应。必须重新验证指令应该被服务器使用,如果且仅当未能验证对表示的请求可能会导致不正确的操作,例如一个沉默的未执行的金融交易。</target>
        </trans-unit>
        <trans-unit id="c4b6b9fcb971dd4f353272a2f91db7cf9a5b6db0" translate="yes" xml:space="preserve">
          <source>The &quot;no-cache&quot; request directive indicates that a cache MUST NOT use
   a stored response to satisfy the request without successful
   validation on the origin server.</source>
          <target state="translated">&quot;no-cache &quot;请求指令表示,在源服务器上没有成功验证的情况下,缓存不得使用存储的响应来满足请求。</target>
        </trans-unit>
        <trans-unit id="6e8f6289e5ab1b4d0a53bcb9e1b83dc08f1a97ef" translate="yes" xml:space="preserve">
          <source>The &quot;no-store&quot; request directive indicates that a cache MUST NOT
   store any part of either this request or any response to it.  This
   directive applies to both private and shared caches.  &quot;MUST NOT
   store&quot; in this context means that the cache MUST NOT intentionally
   store the information in non-volatile storage, and MUST make a
   best-effort attempt to remove the information from volatile storage
   as promptly as possible after forwarding it.

   This directive is NOT a reliable or sufficient mechanism for ensuring
   privacy.  In particular, malicious or compromised caches might not
   recognize or obey this directive, and communications networks might
   be vulnerable to eavesdropping.

   Note that if a request containing this directive is satisfied from a
   cache, the no-store request directive does not apply to the already
   stored response.</source>
          <target state="translated">no-store &quot;请求指令表示缓存不得存储该请求的任何部分或任何响应。这个指令适用于私有和共享缓存。&quot;MUST NOT存储 &quot;在此上下文中意味着缓存MUST NOT有意将信息存储在非易失性存储中,并且在转发信息后必须尽最大努力尽快从易失性存储中删除信息。此指令并非确保隐私的可靠或充分机制。特别是,恶意的或被入侵的缓存可能不识别或不遵守此指令,通信网络可能容易被窃听。请注意,如果从缓存中满足了包含此指令的请求,则不存储请求指令不适用于已经存储的响应。</target>
        </trans-unit>
        <trans-unit id="94cb482b3050dacf986c6ae2b51caac0dbd9698e" translate="yes" xml:space="preserve">
          <source>The &quot;no-store&quot; response directive indicates that a cache MUST NOT
   store any part of either the immediate request or response.  This
   directive applies to both private and shared caches.  &quot;MUST NOT
   store&quot; in this context means that the cache MUST NOT intentionally
   store the information in non-volatile storage, and MUST make a
   best-effort attempt to remove the information from volatile storage
   as promptly as possible after forwarding it.

   This directive is NOT a reliable or sufficient mechanism for ensuring
   privacy.  In particular, malicious or compromised caches might not
   recognize or obey this directive, and communications networks might
   be vulnerable to eavesdropping.</source>
          <target state="translated">no-store &quot;响应指令表示缓存不得存储即时请求或响应的任何部分。这个指令适用于私有和共享缓存。&quot;MUST NOT存储 &quot;在此上下文中意味着缓存MUST NOT有意将信息存储在非易失性存储中,并且在转发信息后必须尽最大努力尽快从易失性存储中删除信息。此指令并非确保隐私的可靠或充分机制。特别是,恶意的或被破坏的缓存可能不承认或不遵守这一指令,通信网络可能容易被窃听。</target>
        </trans-unit>
        <trans-unit id="246740c14df98a9984cb7c90b794ca4cbab5f083" translate="yes" xml:space="preserve">
          <source>The &quot;no-transform&quot; request directive indicates that an intermediary
   (whether or not it implements a cache) MUST NOT transform the
   payload, as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.7.2&quot;&gt;Section&amp;nbsp;5.7.2 of [RFC7230]&lt;/a&gt;.</source>
          <target state="translated">&amp;ldquo; no-transform&amp;rdquo;请求指令指示中介（无论是否实现缓存），均&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.7.2&quot;&gt;不得按照[RFC7230]第5.7.2节的&lt;/a&gt;规定转换有效负载。</target>
        </trans-unit>
        <trans-unit id="26ea1a7d280ad4fbc448761f675e1d88af0183a2" translate="yes" xml:space="preserve">
          <source>The &quot;no-transform&quot; response directive indicates that an intermediary
   (regardless of whether it implements a cache) MUST NOT transform the
   payload, as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.7.2&quot;&gt;Section&amp;nbsp;5.7.2 of [RFC7230]&lt;/a&gt;.</source>
          <target state="translated">&amp;ldquo; no-transform&amp;rdquo;响应指令指示中介（无论是否实现高速缓存）必须不转换有效载荷，如&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.7.2&quot;&gt;[RFC7230]的5.7.2节&lt;/a&gt;所定义。</target>
        </trans-unit>
        <trans-unit id="32d0e455b09d675a4810b93c728652a215d3ce1a" translate="yes" xml:space="preserve">
          <source>The &quot;only-if-cached&quot; request directive indicates that the client only
   wishes to obtain a stored response.  If it receives this directive, a
   cache SHOULD either respond using a stored response that is
   consistent with the other constraints of the request, or respond with 

   a 504 (Gateway Timeout) status code.  If a group of caches is being
   operated as a unified system with good internal connectivity, a
   member cache MAY forward such a request within that group of caches.</source>
          <target state="translated">&quot;only-if-cached &quot;请求指令表示客户机只希望获得一个存储的响应,如果收到这个指令,缓存应该使用与请求的其他约束条件一致的存储响应,或者用504(网关超时)状态码响应。如果收到这个指令,缓存应该使用与请求的其他约束一致的存储响应,或者用504(网关超时)状态码响应。如果一组缓存是作为一个统一的系统来运行的,具有良好的内部连接性,则成员缓存可以在该组缓存中转发这样的请求。</target>
        </trans-unit>
        <trans-unit id="b71570fd0465b4f17b5b1cc37961cb5f46e70128" translate="yes" xml:space="preserve">
          <source>The &quot;proxy-revalidate&quot; response directive has the same meaning as the
   must-revalidate response directive, except that it does not apply to
   private caches.</source>
          <target state="translated">&quot;proxy-revalidate &quot;响应指令与 &quot;must-revalidate &quot;响应指令含义相同,只是它不适用于私有缓存。</target>
        </trans-unit>
        <trans-unit id="f75c67cbc215fa2c33b29aa7195f38b3d21101a2" translate="yes" xml:space="preserve">
          <source>The &quot;public&quot; directive indicates that the response may be cached by any cache. This can be useful if pages with HTTP authentication, or response status codes that aren't normally cacheable, should now be cached.</source>
          <target state="translated">&quot;public &quot;指令表示响应可以被任何缓存所缓存。如果有HTTP认证的页面,或者通常不可缓存的响应状态码,现在应该被缓存,这就很有用。</target>
        </trans-unit>
        <trans-unit id="8e6876985726810eb54534e7e11d768f44365be0" translate="yes" xml:space="preserve">
          <source>The &quot;public&quot; directive indicates that the response may be cached by any cache. This can be useful, if pages with HTTP authentication or response status codes that aren't normally cacheable, should now be cached.</source>
          <target state="translated">&quot;public &quot;指令表示响应可以被任何缓存所缓存。这可能是有用的,如果有HTTP认证或响应状态码的页面通常不能被缓存,现在应该被缓存。</target>
        </trans-unit>
        <trans-unit id="4971052d2513145d16ddbb98b369e6dbbfe2ae90" translate="yes" xml:space="preserve">
          <source>The &quot;public&quot; response directive indicates that any cache MAY store
   the response, even if the response would normally be non-cacheable or
   cacheable only within a private cache.  (See &lt;a href=&quot;#section-3.2&quot;&gt;Section 3.2&lt;/a&gt; for
   additional details related to the use of public in response to a
   request containing Authorization, and &lt;a href=&quot;#section-3&quot;&gt;Section 3&lt;/a&gt; for details of how
   public affects responses that would normally not be stored, due to
   their status codes not being defined as cacheable by default; see
   &lt;a href=&quot;#section-4.2.2&quot;&gt;Section 4.2.2&lt;/a&gt;.)</source>
          <target state="translated">&amp;ldquo; public&amp;rdquo;响应指令指示任何缓存都可以存储响应，即使该响应通常是不可缓存的或仅可在私有缓存中缓存的。 （有关在响应包含授权的请求中使用public的其他详细信息，请参见&lt;a href=&quot;#section-3.2&quot;&gt;第3.2节&lt;/a&gt;；有关公共如何影响通常不会存储的响应的详细信息，请参见第&lt;a href=&quot;#section-3&quot;&gt;3节&lt;/a&gt;的详细信息，这是因为默认情况下其状态代码未定义为可缓存；请参阅 &lt;a href=&quot;#section-4.2.2&quot;&gt;第4.2.2节&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="3a53d63d810ef97bac3b0a2d1828ead948bae860" translate="yes" xml:space="preserve">
          <source>The &quot;realm&quot; authentication parameter is reserved for use by
   authentication schemes that wish to indicate a scope of protection.

   A protection space is defined by the canonical root URI (the scheme
   and authority components of the effective request URI; see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.5&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.5&quot;&gt;5.5 of [RFC7230]&lt;/a&gt;) of the server being accessed, in combination with
   the realm value if present.  These realms allow the protected
   resources on a server to be partitioned into a set of protection 

   spaces, each with its own authentication scheme and/or authorization
   database.  The realm value is a string, generally assigned by the
   origin server, that can have additional semantics specific to the
   authentication scheme.  Note that a response can have multiple
   challenges with the same auth-scheme but with different realms.

   The protection space determines the domain over which credentials can
   be automatically applied.  If a prior request has been authorized,
   the user agent MAY reuse the same credentials for all other requests
   within that protection space for a period of time determined by the
   authentication scheme, parameters, and/or user preferences (such as a
   configurable inactivity timeout).  Unless specifically allowed by the
   authentication scheme, a single protection space cannot extend
   outside the scope of its server.

   For historical reasons, a sender MUST only generate the quoted-string
   syntax.  Recipients might have to support both token and
   quoted-string syntax for maximum interoperability with existing
   clients that have been accepting both notations for a long time.</source>
          <target state="translated">&amp;ldquo;领域&amp;rdquo;认证参数保留给希望表示保护范围的认证方案使用。保护空间由规范的根URI定义（有效请求URI的方案和权限组件；请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.5&quot;&gt;[RFC7230] &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.5&quot;&gt;第&lt;/a&gt;5.5 节），并结合领域值（如果存在）。这些领域允许将服务器上受保护的资源划分为一组保护空间，每个保护空间都有其自己的身份验证方案和/或授权数据库。域值是一个字符串，通常由原始服务器分配，可以具有特定于身份验证方案的其他语义。请注意，使用相同的身份验证方案但使用不同领域的响应可能会面临多个挑战。保护空间确定可以在其上自动应用凭据的域。如果事先的请求已经被授权，则用户代理可以在相同的时间内对保护区域内的所有其他请求重复使用相同的证书，该时间由认证方案，参数，和/或用户首选项（例如可配置的不活动超时）。除非认证方案明确允许，否则单个保护空间不能扩展到其服务器范围之外。由于历史原因，发送方必须仅生成带引号的字符串语法。收件人可能必须同时支持令牌和引号字符串语法，以与已接受这两种符号很长时间的现有客户端实现最大的互操作性。接收者可能必须同时支持令牌和引号字符串语法，才能与已接受这两种符号很长时间的现有客户端实现最大的互操作性。接收者可能必须同时支持令牌和引号字符串语法，才能与已经接受这两种符号很长时间的现有客户端实现最大的互操作性。</target>
        </trans-unit>
        <trans-unit id="151e607c7a4575c8ca7477aa6824b0c9baed0674" translate="yes" xml:space="preserve">
          <source>The 'Basic' HTTP Authentication Scheme</source>
          <target state="translated">基本 &quot;HTTP认证方案</target>
        </trans-unit>
        <trans-unit id="31b797417bbccba76fa104cff98e9ec776af2bfd" translate="yes" xml:space="preserve">
          <source>The 'opaquelocktoken' URI scheme was defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC2518&lt;/a&gt;] (and
   registered by IANA) in order to create syntactically correct and
   easy-to-generate URIs out of UUIDs, intended to be used as lock
   tokens and to be unique across all resources for all time.

   An opaquelocktoken URI is constructed by concatenating the
   'opaquelocktoken' scheme with a UUID, along with an optional
   extension.  Servers can create new UUIDs for each new lock token.  If
   a server wishes to reuse UUIDs, the server MUST add an extension, and
   the algorithm generating the extension MUST guarantee that the same
   extension will never be used twice with the associated UUID.

     OpaqueLockToken-URI = &quot;opaquelocktoken:&quot; UUID [Extension]
       ; UUID is defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc4122#section-3&quot;&gt;Section&amp;nbsp;3 of [RFC4122]&lt;/a&gt;.  Note that LWS
       ; is not allowed between elements of
       ; this production.

     Extension = path
       ; path is defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.3&quot;&gt;Section&amp;nbsp;3.3 of [RFC3986]&lt;/a&gt;</source>
          <target state="translated">[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;opaquelocktoken&lt;/a&gt; ] URI方案在[ RFC2518 ]中定义（并由IANA注册），目的是从UUID中创建语法正确且易于生成的URI，旨在用作锁定令牌，并且在所有资源上都具有唯一性整天。 opaquelocktoken URI是通过将opaquelocktoken方案与UUID以及可选的扩展名并置而构造的。服务器可以为每个新的锁定令牌创建新的UUID。如果服务器希望重用​​UUID，则服务器必须添加扩展名，并且生成扩展名的算法必须保证同一扩展名不会与关联的UUID一起使用两次。 OpaqueLockToken-URI =&amp;ldquo; opaquelocktoken：&amp;rdquo; UUID [扩展名]； UUID在&lt;a href=&quot;https://tools.ietf.org/html/rfc4122#section-3&quot;&gt;[RFC4122]的第3节中&lt;/a&gt;定义。注意LWS;不允许元素之间；这个生产。扩展=路径;路径在&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.3&quot;&gt;[RFC3986]的3.3节中&lt;/a&gt;定义</target>
        </trans-unit>
        <trans-unit id="40135f19d49dbe171471ff8585f7f6ce0a630cbe" translate="yes" xml:space="preserve">
          <source>The 100 (Continue) status code indicates that the initial part of a
   request has been received and has not yet been rejected by the
   server.  The server intends to send a final response after the
   request has been fully received and acted upon.

   When the request contains an Expect header field that includes a
   100-continue expectation, the 100 response indicates that the server
   wishes to receive the request payload body, as described in
   &lt;a href=&quot;#section-5.1.1&quot;&gt;Section 5.1.1&lt;/a&gt;.  The client ought to continue sending the request and
   discard the 100 response.

   If the request did not contain an Expect header field containing the
   100-continue expectation, the client can simply discard this interim
   response.</source>
          <target state="translated">状态码为100（继续），表示请求的初始部分已收到，但尚未被服务器拒绝。服务器打算在请求被完全接收并执行后发送最终响应。当请求包含包含100个连续期望的Expect标头字段时，该100响应指示服务器希望接收请求有效内容主体，如&lt;a href=&quot;#section-5.1.1&quot;&gt;5.1.1节中&lt;/a&gt;所述 。客户端应继续发送请求，并丢弃100响应。如果请求不包含包含100个连续期望的Expect标头字段，则客户端可以简单地放弃此临时响应。</target>
        </trans-unit>
        <trans-unit id="0d01ba31f4c44842de2b726b8f94536c5aca0981" translate="yes" xml:space="preserve">
          <source>The 101 (Switching Protocols) status code indicates that the server
   understands and is willing to comply with the client's request, via
   the Upgrade header field (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6.7&quot;&gt;Section&amp;nbsp;6.7 of [RFC7230]&lt;/a&gt;), for a change in
   the application protocol being used on this connection.  The server 

   MUST generate an Upgrade header field in the response that indicates
   which protocol(s) will be switched to immediately after the empty
   line that terminates the 101 response.

   It is assumed that the server will only agree to switch protocols
   when it is advantageous to do so.  For example, switching to a newer
   version of HTTP might be advantageous over older versions, and
   switching to a real-time, synchronous protocol might be advantageous
   when delivering resources that use such features.</source>
          <target state="translated">101（交换协议）状态代码表示服务器理解并愿意通过&amp;ldquo;升级标头&amp;rdquo;字段（&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6.7&quot;&gt;[RFC7230]的6.7节&lt;/a&gt;）来更改此连接上使用的应用协议的客户端请求。服务器必须在响应中生成一个升级报头字段，该字段指示在终止101响应的空行之后将立即切换到哪些协议。假定只有在有利的情况下服务器才会同意切换协议。例如，切换到新版本的HTTP可能会比旧版本更有利，而在传递使用此类功能的资源时，切换到实时同步协议可能会更有利。</target>
        </trans-unit>
        <trans-unit id="c844ae29efcb21429730db5f3e66a84ced4ddb52" translate="yes" xml:space="preserve">
          <source>The 101 status code</source>
          <target state="translated">101状态码</target>
        </trans-unit>
        <trans-unit id="3ed3da1546f287aac58cc367f269cb9295233354" translate="yes" xml:space="preserve">
          <source>The 1xx (Informational) class of status code indicates an interim
   response for communicating connection status or request progress
   prior to completing the requested action and sending a final
   response. 1xx responses are terminated by the first empty line after
   the status-line (the empty line signaling the end of the header
   section).  Since HTTP/1.0 did not define any 1xx status codes, a
   server MUST NOT send a 1xx response to an HTTP/1.0 client.

   A client MUST be able to parse one or more 1xx responses received
   prior to a final response, even if the client does not expect one.  A
   user agent MAY ignore unexpected 1xx responses.

   A proxy MUST forward 1xx responses unless the proxy itself requested
   the generation of the 1xx response.  For example, if a proxy adds an
   &quot;Expect: 100-continue&quot; field when it forwards a request, then it need
   not forward the corresponding 100 (Continue) response(s).</source>
          <target state="translated">1xx(Informational)类状态码表示在完成请求动作和发送最终响应之前,用于传达连接状态或请求进度的临时响应。1xx响应由状态行后的第一个空行结束(空行表示头部分的结束)。由于HTTP/1.0没有定义任何1xx状态代码,服务器必须不向HTTP/1.0客户端发送1xx响应。客户端必须能够解析在最终响应之前收到的一个或多个1xx响应,即使客户端不期望有一个响应。用户代理可以忽略意外的1xx响应。代理必须转发1xx响应,除非代理本身要求生成1xx响应。例如,如果代理在转发请求时添加了 &quot;期待:100-continue &quot;字段,那么它就不需要转发相应的100(Continue)响应。</target>
        </trans-unit>
        <trans-unit id="73c66d189cbfbc42b2d25d8e68502411eaf75067" translate="yes" xml:space="preserve">
          <source>The 200 (OK) status code indicates that the request has succeeded.
   The payload sent in a 200 response depends on the request method.
   For the methods defined by this specification, the intended meaning
   of the payload can be summarized as:

   GET  a representation of the target resource;

   HEAD  the same representation as GET, but without the representation
      data;

   POST  a representation of the status of, or results obtained from,
      the action;

   PUT, DELETE  a representation of the status of the action;

   OPTIONS  a representation of the communications options;

   TRACE  a representation of the request message as received by the end
      server.

   Aside from responses to CONNECT, a 200 response always has a payload,
   though an origin server MAY generate a payload body of zero length.
   If no payload is desired, an origin server ought to send 204 (No
   Content) instead.  For CONNECT, no payload is allowed because the
   successful result is a tunnel, which begins immediately after the 200
   response header section.

   A 200 response is cacheable by default; i.e., unless otherwise
   indicated by the method definition or explicit cache controls (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;Section&amp;nbsp;4.2.2 of [RFC7234]&lt;/a&gt;).</source>
          <target state="translated">状态码200（OK）表示请求已成功。 200响应中发送的有效负载取决于请求方法。对于本规范定义的方法，有效载荷的预期含义可以概括为：GET目标资源的表示； HEAD与GET相同，但没有表示数据；张贴动作状态或结果的表示； PUT，DELETE表示动作状态； OPTIONS表示通讯选项；跟踪最终服务器接收到的请求消息的表示形式。除了对CONNECT的响应外，200响应始终具有有效负载，尽管原始服务器可以生成零长度的有效负载主体。如果不需要有效负载，原始服务器应该发送204（无内容）。对于CONNECT，不允许有效负载，因为成功的结果是隧道，该隧道在200响应头部分之后立即开始。默认情况下，可缓存200个响应；即，除非方法定义或显式缓存控件另有说明（请参见 &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;[RFC7234]的第4.2.2节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="fb652482ea97cc2ed5c9e3a8e7d46c55940f8e9f" translate="yes" xml:space="preserve">
          <source>The 201 (Created) status code indicates that the request has been
   fulfilled and has resulted in one or more new resources being
   created.  The primary resource created by the request is identified
   by either a Location header field in the response or, if no Location
   field is received, by the effective request URI.

   The 201 response payload typically describes and links to the
   resource(s) created.  See &lt;a href=&quot;#section-7.2&quot;&gt;Section 7.2&lt;/a&gt; for a discussion of the meaning
   and purpose of validator header fields, such as ETag and
   Last-Modified, in a 201 response.</source>
          <target state="translated">状态码201（已创建）表示请求已得到满足，并导致创建了一个或多个新资源。由请求创建的主要资源由响应中的Location头字段标识，或者，如果未接收到Location字段，则由有效请求URI标识。201响应有效负载通常描述并链接到创建的资源。有关201响应中验证程序头字段（例如ETag和Last-Modified）的含义和目的的讨论，请参见&lt;a href=&quot;#section-7.2&quot;&gt;7.2节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="abf13ad15a9e2fc228718670b40afce5ab72fe28" translate="yes" xml:space="preserve">
          <source>The 202 (Accepted) status code indicates that the request has been
   accepted for processing, but the processing has not been completed.
   The request might or might not eventually be acted upon, as it might
   be disallowed when processing actually takes place.  There is no
   facility in HTTP for re-sending a status code from an asynchronous
   operation.

   The 202 response is intentionally noncommittal.  Its purpose is to
   allow a server to accept a request for some other process (perhaps a
   batch-oriented process that is only run once per day) without
   requiring that the user agent's connection to the server persist
   until the process is completed.  The representation sent with this
   response ought to describe the request's current status and point to
   (or embed) a status monitor that can provide the user with an
   estimate of when the request will be fulfilled.</source>
          <target state="translated">202(接受)状态码表示请求已被接受处理,但处理尚未完成。该请求最终可能会被执行,也可能不会被执行,因为在实际处理时可能会被拒绝。在HTTP中,没有从异步操作中重新发送状态码的功能。202响应是有意的非承诺性的。它的目的是允许服务器接受对其他进程的请求(也许是一个每天只运行一次的面向批次的进程),而不要求用户代理与服务器的连接持续到进程完成。与这个响应一起发送的表示应该描述请求的当前状态,并指向(或嵌入)一个状态监测器,该监测器可以向用户提供请求何时会被满足的估计。</target>
        </trans-unit>
        <trans-unit id="9a4650176c01777123e8dd8f9e1788cc242ba3f7" translate="yes" xml:space="preserve">
          <source>The 203 (Non-Authoritative Information) status code indicates that
   the request was successful but the enclosed payload has been modified
   from that of the origin server's 200 (OK) response by a transforming
   proxy (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.7.2&quot;&gt;Section&amp;nbsp;5.7.2 of [RFC7230]&lt;/a&gt;).  This status code allows the
   proxy to notify recipients when a transformation has been applied,
   since that knowledge might impact later decisions regarding the
   content.  For example, future cache validation requests for the
   content might only be applicable along the same request path (through
   the same proxies).

   The 203 response is similar to the Warning code of 214 Transformation
   Applied (&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.5&quot;&gt;Section&amp;nbsp;5.5 of [RFC7234]&lt;/a&gt;), which has the advantage of being
   applicable to responses with any status code. 

   A 203 response is cacheable by default; i.e., unless otherwise
   indicated by the method definition or explicit cache controls (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;Section&amp;nbsp;4.2.2 of [RFC7234]&lt;/a&gt;).</source>
          <target state="translated">203（非权威信息）状态码表示请求成功，但是封装的有效负载已通过转换代理从源服务器200（正常）响应的有效负载中进行了修改（&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.7.2&quot;&gt;[RFC7230]的5.7.2节&lt;/a&gt;）。此状态代码允许代理在应用转换时通知收件人，因为该知识可能会影响以后有关内容的决定。例如，将来对内容的缓存验证请求可能仅适用于相同的请求路径（通过相同的代理）。 203响应类似于应用了214转换的警告代码（&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.5&quot;&gt;[RFC7234]的5.5节&lt;/a&gt;），其优点是适用于带有任何状态代码的响应。默认情况下，可以缓存203响应；即，除非方法定义或显式缓存控件另有说明（请参阅 &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;[RFC7234]的4.2.2节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="a03bafae0f2da4aa1963199aa2ef89f97a8ce60c" translate="yes" xml:space="preserve">
          <source>The 204 (No Content) status code indicates that the server has
   successfully fulfilled the request and that there is no additional
   content to send in the response payload body.  Metadata in the
   response header fields refer to the target resource and its selected
   representation after the requested action was applied.

   For example, if a 204 status code is received in response to a PUT
   request and the response contains an ETag header field, then the PUT
   was successful and the ETag field-value contains the entity-tag for
   the new representation of that target resource.

   The 204 response allows a server to indicate that the action has been
   successfully applied to the target resource, while implying that the
   user agent does not need to traverse away from its current &quot;document
   view&quot; (if any).  The server assumes that the user agent will provide
   some indication of the success to its user, in accord with its own
   interface, and apply any new or updated metadata in the response to
   its active representation.

   For example, a 204 status code is commonly used with document editing
   interfaces corresponding to a &quot;save&quot; action, such that the document
   being saved remains available to the user for editing.  It is also
   frequently used with interfaces that expect automated data transfers
   to be prevalent, such as within distributed version control systems.

   A 204 response is terminated by the first empty line after the header
   fields because it cannot contain a message body.

   A 204 response is cacheable by default; i.e., unless otherwise
   indicated by the method definition or explicit cache controls (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;Section&amp;nbsp;4.2.2 of [RFC7234]&lt;/a&gt;).</source>
          <target state="translated">状态码为204（无内容）指示服务器已成功满足请求，并且响应有效内容正文中没有其他要发送的内容。应用请求的操作后，响应头字段中的元数据引用目标资源及其选择的表示形式。例如，如果响应于PUT请求而接收到204状态代码，并且该响应包含ETag头字段，则PUT成功，并且ETag字段值包含该目标资源的新表示形式的实体标签。 204响应允许服务器指示该操作已成功应用于目标资源，同时暗示用户代理不需要遍历其当前&amp;ldquo;文档视图&amp;rdquo;（如果有）。服务器假定用户代理将根据其自己的界面向其用户提供成功的指示，并在响应中对其活动表示应用任何新的或更新的元数据。例如，204状态代码通常与与&amp;ldquo;保存&amp;rdquo;动作相对应的文档编辑界面一起使用，从而使得所保存的文档仍然可供用户用于编辑。它还经常与期望自动化数据传输盛行的接口一起使用，例如在分布式版本控制系统中。 204响应由标头字段之后的第一个空行终止，因为它不能包含消息正文。默认情况下，204响应是可缓存的；即除非方法定义或显式缓存控件另有说明（请参见 &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;[RFC7234]的第4.2.2节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="956b428452b332069240075e35ec925980806e62" translate="yes" xml:space="preserve">
          <source>The 205 (Reset Content) status code indicates that the server has
   fulfilled the request and desires that the user agent reset the
   &quot;document view&quot;, which caused the request to be sent, to its original
   state as received from the origin server.

   This response is intended to support a common data entry use case
   where the user receives content that supports data entry (a form,
   notepad, canvas, etc.), enters or manipulates data in that space, 

   causes the entered data to be submitted in a request, and then the
   data entry mechanism is reset for the next entry so that the user can
   easily initiate another input action.

   Since the 205 status code implies that no additional content will be
   provided, a server MUST NOT generate a payload in a 205 response.  In
   other words, a server MUST do one of the following for a 205
   response: a) indicate a zero-length body for the response by
   including a Content-Length header field with a value of 0; b)
   indicate a zero-length payload for the response by including a
   Transfer-Encoding header field with a value of chunked and a message
   body consisting of a single chunk of zero-length; or, c) close the
   connection immediately after sending the blank line terminating the
   header section.</source>
          <target state="translated">205(Reset Content)状态码表示服务器已经满足了该请求,并希望用户代理将导致发送请求的 &quot;文档视图 &quot;重置为从源服务器接收到的原始状态。该响应旨在支持一种常见的数据录入用例,即用户接收到支持数据录入的内容(表单、记事本、画布等),在该空间中输入或操作数据,使输入的数据在请求中提交,然后为下一次输入重置数据录入机制,以便用户可以轻松地发起另一个输入操作。由于205状态码意味着不会提供额外的内容,所以服务器必须不在205响应中生成有效载荷。换句话说,服务器必须对205响应做以下操作之一:a)通过包含一个值为0的Content-Length头字段来指示响应的零长度体;b)通过包含一个值为chunked的Transfer-Encoding头字段和一个由零长度的单一块组成的消息体来指示响应的零长度有效载荷;或者,c)在发送结束头部分的空行后立即关闭连接。</target>
        </trans-unit>
        <trans-unit id="07f77f37a20dc983a618d2c0027e2bd10388099a" translate="yes" xml:space="preserve">
          <source>The 206 (Partial Content) status code indicates that the server is
   successfully fulfilling a range request for the target resource by
   transferring one or more parts of the selected representation that
   correspond to the satisfiable ranges found in the request's Range
   header field (&lt;a href=&quot;#section-3.1&quot;&gt;Section 3.1&lt;/a&gt;).

   If a single part is being transferred, the server generating the 206
   response MUST generate a Content-Range header field, describing what
   range of the selected representation is enclosed, and a payload
   consisting of the range.  For example:

     HTTP/1.1 206 Partial Content
     Date: Wed, 15 Nov 1995 06:25:24 GMT
     Last-Modified: Wed, 15 Nov 1995 04:58:08 GMT
     Content-Range: bytes 21010-47021/47022
     Content-Length: 26012
     Content-Type: image/gif

     ... 26012 bytes of partial image data 

   If multiple parts are being transferred, the server generating the
   206 response MUST generate a &quot;multipart/byteranges&quot; payload, as
   defined in &lt;a href=&quot;#appendix-A&quot;&gt;Appendix A&lt;/a&gt;, and a Content-Type header field containing the
   multipart/byteranges media type and its required boundary parameter.
   To avoid confusion with single-part responses, a server MUST NOT
   generate a Content-Range header field in the HTTP header section of a
   multiple part response (this field will be sent in each part
   instead). 

   Within the header area of each body part in the multipart payload,
   the server MUST generate a Content-Range header field corresponding
   to the range being enclosed in that body part.  If the selected
   representation would have had a Content-Type header field in a 200
   (OK) response, the server SHOULD generate that same Content-Type
   field in the header area of each body part.  For example:

     HTTP/1.1 206 Partial Content
     Date: Wed, 15 Nov 1995 06:25:24 GMT
     Last-Modified: Wed, 15 Nov 1995 04:58:08 GMT
     Content-Length: 1741
     Content-Type: multipart/byteranges; boundary=THIS_STRING_SEPARATES

     --THIS_STRING_SEPARATES
     Content-Type: application/pdf
     Content-Range: bytes 500-999/8000

     ...the first range
     --THIS_STRING_SEPARATES
     Content-Type: application/pdf
     Content-Range: bytes 7000-7999/8000

     ...the second range
     --THIS_STRING_SEPARATES--

   When multiple ranges are requested, a server MAY coalesce any of the
   ranges that overlap, or that are separated by a gap that is smaller
   than the overhead of sending multiple parts, regardless of the order
   in which the corresponding byte-range-spec appeared in the received
   Range header field.  Since the typical overhead between parts of a
   multipart/byteranges payload is around 80 bytes, depending on the
   selected representation's media type and the chosen boundary
   parameter length, it can be less efficient to transfer many small
   disjoint parts than it is to transfer the entire selected
   representation.

   A server MUST NOT generate a multipart response to a request for a
   single range, since a client that does not request multiple parts
   might not support multipart responses.  However, a server MAY
   generate a multipart/byteranges payload with only a single body part
   if multiple ranges were requested and only one range was found to be
   satisfiable or only one range remained after coalescing.  A client
   that cannot process a multipart/byteranges response MUST NOT generate
   a request that asks for multiple ranges.

   When a multipart response payload is generated, the server SHOULD
   send the parts in the same order that the corresponding
   byte-range-spec appeared in the received Range header field, 

   excluding those ranges that were deemed unsatisfiable or that were
   coalesced into other ranges.  A client that receives a multipart
   response MUST inspect the Content-Range header field present in each
   body part in order to determine which range is contained in that body
   part; a client cannot rely on receiving the same ranges that it
   requested, nor the same order that it requested.

   When a 206 response is generated, the server MUST generate the
   following header fields, in addition to those required above, if the
   field would have been sent in a 200 (OK) response to the same
   request: Date, Cache-Control, ETag, Expires, Content-Location, and
   Vary.

   If a 206 is generated in response to a request with an If-Range
   header field, the sender SHOULD NOT generate other representation
   header fields beyond those required above, because the client is
   understood to already have a prior response containing those header
   fields.  Otherwise, the sender MUST generate all of the
   representation header fields that would have been sent in a 200 (OK)
   response to the same request.

   A 206 response is cacheable by default; i.e., unless otherwise
   indicated by explicit cache controls (see &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;Section&amp;nbsp;4.2.2 of
   [RFC7234]&lt;/a&gt;).</source>
          <target state="translated">206（部分内容）状态代码表示该服务器被成功地满足对目标资源的范围内请求通过将所选择的表示对应于满足的范围在请求的范围报头字段发现一个或多个部分（&lt;a href=&quot;#section-3.1&quot;&gt;第3.1节&lt;/a&gt;）。如果正在传送单个部分，则生成206响应的服务器务必生成一个Content-Range头字段，该字段描述所选择表示的范围，以及包含该范围的有效负载。例如：HTTP / 1.1 206部分内容日期：1995年11月15日星期三06:25:24 GMT上次修改时间：1995年11月15日星期三04:58:08 GMT内容范围：字节21010-47021 / 47022内容长度：26012内容类型：image / gif ... 26012字节的部分图像数据如果要传输多个部分，则生成206响应的服务器务必生成&amp;ldquo; multipart / byteranges&amp;rdquo;有效负载，如&lt;a href=&quot;#appendix-A&quot;&gt;附录A&lt;/a&gt;所定义，以及一个Content-Type标头字段，其中包含multipart / byteranges媒体类型及其必需的border参数。为避免与单部分响应混淆，服务器不得在多部分响应的HTTP标头部分中生成Content-Range标头字段（该字段将改为在每个部分中发送）。在多部分有效载荷中每个主体部分的头部区域内，服务器务必生成一个Content-Range头部字段，该字段与该主体部分中包含的范围相对应。如果所选的表示形式在200（确定）响应中将具有Content-Type头字段，则服务器应在每个正文部分的头区域中生成相同的Content-Type字段。例如：HTTP / 1.1 206部分内容日期：1995年11月15日星期三，格林尼治标准时间最后修改时间：星期三，1995年11月15日04:58:08 GMT内容长度：1741内容类型：multipart / byteranges； boundary = THIS_STRING_SEPARATES --THIS_STRING_SEPARATES内容类型：application / pdf内容范围：字节500-999 / 8000 ...第一个范围--THIS_STRING_SEPARATES内容类型：application / pdf内容范围：字节7000-7999 / 8000。 ..第二个范围--THIS_STRING_SEPARATES--当请求多个范围时，服务器可以合并任何重叠的范围，或者由小于发送多个部分的开销的间隙分隔的范围，无论顺序如何相应的字节范围规范出现在接收到的Range标头字段中。由于多部分/字节范围有效负载的各个部分之间的典型开销约为80个字节，取决于所选表示形式的媒体类型和所选边界参数长度，传输许多小的不连续部分的效率可能比传输整个所选表示形式的效率低。服务器不得针对单个范围的请求生成多部分响应，因为不请求多个部分的客户端可能不支持多部分响应。但是，如果请求多个范围并且发现只有一个范围是可满足的，或者合并后仅剩下一个范围，则服务器可以只用一个主体部分生成多部分/字节范围的有效载荷。不能处理多部分/字节范围响应的客户端不得生成请求多个范围的请求。生成多部分响应有效负载时，服务器应按照接收到的Range标头字段中出现的相应字节范围规范的顺序发送各部分，但不包括那些认为不满意或合并为其他范围的范围。收到多部分响应的客户端必须检查每个主体部分中存在的Content-Range标头字段，以确定该主体部分中包含哪个范围；客户不能依赖于接收与请求相同的范围，也不能依赖于请求的相同顺序。生成206响应时，如果上面的字段必须在对同一请求的200（OK）响应中发送，则除上述要求的字段外，服务器还必须生成以下标头字段：Date，Cache-Control，ETag，过期，内容位置和变化。如果响应带有If-Range头字段的请求而生成206，则发件人不应该生成除上面要求的字段之外的其他表示头字段，因为应该理解客户端已经具有包含这些头字段的先前响应。否则，发送者必须生成所有在200（OK）响应中发送给相同请求的表示头域。默认情况下，206响应是可缓存的；即，除非明确的缓存控制另有说明（请参见发送方必须生成所有200个（确定）响应中已发送给同一请求的表示形式标头字段。默认情况下，206响应是可缓存的；即，除非明确的缓存控制另有说明（请参见发送方必须生成所有200个（确定）响应中已发送给同一请求的表示形式标头字段。默认情况下，206响应是可缓存的；即，除非明确的缓存控制另有说明（请参见&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;[RFC7234]的第4.2.2节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="a96c2c15082f71e24cf514861b9f6649cccdc6d7" translate="yes" xml:space="preserve">
          <source>The 207 (Multi-Status) status code provides status for multiple
   independent operations (see &lt;a href=&quot;#section-13&quot;&gt;Section 13&lt;/a&gt; for more information).</source>
          <target state="translated">207（多状态）状态代码提供了多个独立操作的状态（更多信息，请参见&lt;a href=&quot;#section-13&quot;&gt;第13节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="21abf74518ada2943ea07b28d70fb2e06dfc8c14" translate="yes" xml:space="preserve">
          <source>The 2xx (Successful) class of status code indicates that the client's
   request was successfully received, understood, and accepted.</source>
          <target state="translated">2xx(成功)类状态码表示客户的请求被成功接收、理解和接受。</target>
        </trans-unit>
        <trans-unit id="8091edce5c825502d2461f4be1e98fbbf163fbf9" translate="yes" xml:space="preserve">
          <source>The 300 (Multiple Choices) status code indicates that the target
   resource has more than one representation, each with its own more
   specific identifier, and information about the alternatives is being
   provided so that the user (or user agent) can select a preferred
   representation by redirecting its request to one or more of those
   identifiers.  In other words, the server desires that the user agent
   engage in reactive negotiation to select the most appropriate
   representation(s) for its needs (&lt;a href=&quot;#section-3.4&quot;&gt;Section 3.4&lt;/a&gt;).

   If the server has a preferred choice, the server SHOULD generate a
   Location header field containing a preferred choice's URI reference.
   The user agent MAY use the Location field value for automatic
   redirection.

   For request methods other than HEAD, the server SHOULD generate a
   payload in the 300 response containing a list of representation
   metadata and URI reference(s) from which the user or user agent can
   choose the one most preferred.  The user agent MAY make a selection
   from that list automatically if it understands the provided media
   type.  A specific format for automatic selection is not defined by
   this specification because HTTP tries to remain orthogonal to the
   definition of its payloads.  In practice, the representation is
   provided in some easily parsed format believed to be acceptable to
   the user agent, as determined by shared design or content
   negotiation, or in some commonly accepted hypertext format. 

   A 300 response is cacheable by default; i.e., unless otherwise
   indicated by the method definition or explicit cache controls (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;Section&amp;nbsp;4.2.2 of [RFC7234]&lt;/a&gt;).

      Note: The original proposal for the 300 status code defined the
      URI header field as providing a list of alternative
      representations, such that it would be usable for 200, 300, and
      406 responses and be transferred in responses to the HEAD method.
      However, lack of deployment and disagreement over syntax led to
      both URI and Alternates (a subsequent proposal) being dropped from
      this specification.  It is possible to communicate the list using
      a set of Link header fields [&lt;a href=&quot;https://tools.ietf.org/html/rfc5988&quot;&gt;RFC5988&lt;/a&gt;], each with a relationship of
      &quot;alternate&quot;, though deployment is a chicken-and-egg problem.</source>
          <target state="translated">状态码300（多项选择）指示目标资源具有多个表示形式，每个表示形式都有其自己的更具体的标识符，并且正在提供有关替代项的信息，以便用户（或用户代理）可以通过以下方式选择首选表示形式：将其请求重定向到一个或多个这些标识符。换句话说，服务器希望用户代理参与反应式协商，以选择最适合其需求的表示形式（&lt;a href=&quot;#section-3.4&quot;&gt;第3.4节）&lt;/a&gt;）。如果服务器有一个首选选项，则服务器应该生成一个Location头字段，其中包含首选选项的URI参考。用户代理可以使用位置字段值进行自动重定向。对于除HEAD以外的请求方法，服务器应在300响应中生成一个有效载荷，该有效载荷包含表示元数据和URI参考的列表，用户或用户代理可以从中选择最优选的一个。如果用户代理理解提供的媒体类型，可以自动从该列表中进行选择。该规范未定义用于自动选择的特定格式，因为HTTP尝试保持与其有效负载的定义正交。在实践中，该表示以共享设计或内容协商确定的某种易于解析的格式被认为是用户代理可接受的格式提供，或以某种普遍接受的超文本格式提供。默认情况下，300响应是可缓存的；即，除非方法定义或显式缓存控件另有说明（请参见 &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;[RFC7234]的第4.2.2节&lt;/a&gt;）。注意：300状态代码的原始建议将URI标头字段定义为提供其他表示形式的列表，以便它可用于200、300和406响应，并在对HEAD方法的响应中进行传输。但是，由于缺乏部署和语法上的分歧，导致URI和Alternates（后续提案）都从该规范中删除。可以使用一组链接头字段[ &lt;a href=&quot;https://tools.ietf.org/html/rfc5988&quot;&gt;RFC5988&lt;/a&gt; ] 来传达列表，每个字段都具有&amp;ldquo;替代&amp;rdquo;关系，尽管部署是鸡到蛋的问题。</target>
        </trans-unit>
        <trans-unit id="e89e16d2ad3f5f0023fdef413da39c2201b7eab8" translate="yes" xml:space="preserve">
          <source>The 301 (Moved Permanently) status code indicates that the target
   resource has been assigned a new permanent URI and any future
   references to this resource ought to use one of the enclosed URIs.
   Clients with link-editing capabilities ought to automatically re-link
   references to the effective request URI to one or more of the new
   references sent by the server, where possible.

   The server SHOULD generate a Location header field in the response
   containing a preferred URI reference for the new permanent URI.  The
   user agent MAY use the Location field value for automatic
   redirection.  The server's response payload usually contains a short
   hypertext note with a hyperlink to the new URI(s).

      Note: For historical reasons, a user agent MAY change the request
      method from POST to GET for the subsequent request.  If this
      behavior is undesired, the 307 (Temporary Redirect) status code
      can be used instead.

   A 301 response is cacheable by default; i.e., unless otherwise
   indicated by the method definition or explicit cache controls (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;Section&amp;nbsp;4.2.2 of [RFC7234]&lt;/a&gt;).</source>
          <target state="translated">301（永久移动）状态代码表示已为目标资源分配了新的永久URI，并且对该资源的任何将来引用都应使用其中的一个URI。具有链接编辑功能的客户端应在可能的情况下自动将对有效请求URI的引用重新链接到服务器发送的一个或多个新引用。服务器应该在响应中生成一个Location头字段，其中包含新的永久URI的首选URI引用。用户代理可以使用位置字段值进行自动重定向。服务器的响应有效负载通常包含简短的超文本注释，并带有指向新URI的超链接。注意：由于历史原因，用户代理可以为后续请求将请求方法从POST更改为GET。如果不希望出现这种情况，则可以改用307（临时重定向）状态代码。默认情况下，可以缓存301响应；即，除非方法定义或显式缓存控件另有说明（请参见 &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;[RFC7234]的第4.2.2节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="9ef3872d9a97e7902a4418ab95fd36038bea8203" translate="yes" xml:space="preserve">
          <source>The 302 (Found) status code indicates that the target resource
   resides temporarily under a different URI.  Since the redirection
   might be altered on occasion, the client ought to continue to use the
   effective request URI for future requests. 

   The server SHOULD generate a Location header field in the response
   containing a URI reference for the different URI.  The user agent MAY
   use the Location field value for automatic redirection.  The server's
   response payload usually contains a short hypertext note with a
   hyperlink to the different URI(s).

      Note: For historical reasons, a user agent MAY change the request
      method from POST to GET for the subsequent request.  If this
      behavior is undesired, the 307 (Temporary Redirect) status code
      can be used instead.</source>
          <target state="translated">302(Found)状态码表示目标资源暂时驻留在不同的URI下。由于重定向可能偶尔会被改变,客户机应该在未来的请求中继续使用有效的请求URI。服务器应该在响应中生成一个Location头字段,包含不同URI的URI引用。用户代理可以使用Location字段的值进行自动重定向。服务器的响应有效载荷通常包含一个简短的超文本注释,其中有指向不同URI的超链接。注意:由于历史原因,用户代理在后续请求中可以将请求方法从POST改为GET。如果不希望出现这种行为,可以使用307(临时重定向)状态码来代替。</target>
        </trans-unit>
        <trans-unit id="f98486b9c7317cc8a6b18febd1348ba3209011c0" translate="yes" xml:space="preserve">
          <source>The 303 (See Other) status code indicates that the server is
   redirecting the user agent to a different resource, as indicated by a
   URI in the Location header field, which is intended to provide an
   indirect response to the original request.  A user agent can perform
   a retrieval request targeting that URI (a GET or HEAD request if
   using HTTP), which might also be redirected, and present the eventual
   result as an answer to the original request.  Note that the new URI
   in the Location header field is not considered equivalent to the
   effective request URI.

   This status code is applicable to any HTTP method.  It is primarily
   used to allow the output of a POST action to redirect the user agent
   to a selected resource, since doing so provides the information
   corresponding to the POST response in a form that can be separately
   identified, bookmarked, and cached, independent of the original
   request.

   A 303 response to a GET request indicates that the origin server does
   not have a representation of the target resource that can be
   transferred by the server over HTTP.  However, the Location field
   value refers to a resource that is descriptive of the target
   resource, such that making a retrieval request on that other resource
   might result in a representation that is useful to recipients without
   implying that it represents the original target resource.  Note that
   answers to the questions of what can be represented, what
   representations are adequate, and what might be a useful description
   are outside the scope of HTTP.

   Except for responses to a HEAD request, the representation of a 303
   response ought to contain a short hypertext note with a hyperlink to
   the same URI reference provided in the Location header field.</source>
          <target state="translated">303(See Other)状态码表示服务器正在将用户代理重定向到不同的资源,如Location头字段中的URI所示,该URI旨在为原始请求提供间接响应。用户代理可以执行针对该URI的检索请求(如果使用HTTP,则为GET或HEAD请求),该请求也可能被重定向,并将最终的结果作为对原始请求的回答呈现出来。请注意,Location头域中的新URI不被认为等同于有效请求URI。这个状态码适用于任何HTTP方法。它主要用于允许POST操作的输出将用户代理重定向到选定的资源,因为这样做可以以独立于原始请求的形式提供POST响应对应的信息,可以单独识别、书签和缓存。对GET请求的303响应表明原服务器没有可以由服务器通过HTTP传输的目标资源的表示。但是,Location字段的值指的是对目标资源有描述性的资源,这样,在该其他资源上进行检索请求可能会得到一个对接收者有用的表示,而不意味着它代表了原始目标资源。请注意,关于什么可以被表示,什么表示是足够的,以及什么可能是有用的描述等问题的答案不在HTTP的范围之内。除了对HEAD请求的响应外,303响应的表示应该包含一个简短的超文本说明,并带有一个超链接,指向在Location头域中提供的相同URI引用。</target>
        </trans-unit>
        <trans-unit id="1310056b9a11237a35ab8cb0a6c54f0611f4bdbf" translate="yes" xml:space="preserve">
          <source>The 304 (Not Modified) status code indicates that a conditional GET
   or HEAD request has been received and would have resulted in a 200
   (OK) response if it were not for the fact that the condition
   evaluated to false.  In other words, there is no need for the server
   to transfer a representation of the target resource because the
   request indicates that the client, which made the request 

   conditional, already has a valid representation; the server is
   therefore redirecting the client to make use of that stored
   representation as if it were the payload of a 200 (OK) response.

   The server generating a 304 response MUST generate any of the
   following header fields that would have been sent in a 200 (OK)
   response to the same request: Cache-Control, Content-Location, Date,
   ETag, Expires, and Vary.

   Since the goal of a 304 response is to minimize information transfer
   when the recipient already has one or more cached representations, a
   sender SHOULD NOT generate representation metadata other than the
   above listed fields unless said metadata exists for the purpose of
   guiding cache updates (e.g., Last-Modified might be useful if the
   response does not have an ETag field).

   Requirements on a cache that receives a 304 response are defined in
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.3.4&quot;&gt;Section&amp;nbsp;4.3.4 of [RFC7234]&lt;/a&gt;.  If the conditional request originated
   with an outbound client, such as a user agent with its own cache
   sending a conditional GET to a shared proxy, then the proxy SHOULD
   forward the 304 response to that client.

   A 304 response cannot contain a message-body; it is always terminated
   by the first empty line after the header fields.</source>
          <target state="translated">304（未修改）状态码表示已接收到条件GET或HEAD请求，如果不是因为条件评估为假，则将导致200（确定）响应。换句话说，服务器不需要传输目标资源的表示形式，因为该请求表明以请求为条件的客户端已经具有有效的表示形式。因此，服务器正在重定向客户端以利用存储的表示形式，就好像它是200（正常）响应的有效负载一样。生成304响应的服务器必须生成以下任何报头字段，这些字段将在对同一请求的200（OK）响应中发送：Cache-Control，Content-Location，Date，ETag，Expires和Vary。由于304响应的目标是在接收者已经具有一个或多个缓存的表示形式时将信息传递减至最少，因此，除非存在上述元数据用于指导缓存更新（例如，如果响应中没有ETag字段，则Last-Modified可能有用。在304中定义了对接收304响应的缓存的要求在304中定义了对接收304响应的缓存的要求在304中定义了对接收304响应的缓存的要求 &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.3.4&quot;&gt;[RFC7234]的第4.3.4节&lt;/a&gt;。如果条件请求是由出站客户端发起的，例如具有自己的缓存的用户代理将有条件的GET发送到共享代理，则代理应将304响应转发给该客户端。 304响应不能包含消息正文；它总是由标题字段之后的第一个空行终止。</target>
        </trans-unit>
        <trans-unit id="d962e03df1dabcc2ec176a4937563211d6cfd2cc" translate="yes" xml:space="preserve">
          <source>The 305 (Use Proxy) status code was defined in a previous version of
   this specification and is now deprecated (Appendix B).</source>
          <target state="translated">305(Use Proxy)状态码在本规范以前的版本中定义过,现在已经废弃(附录B)。</target>
        </trans-unit>
        <trans-unit id="bbf9b7a6555633242c214ea7db29148fae94dc7d" translate="yes" xml:space="preserve">
          <source>The 306 status code was defined in a previous version of this
   specification, is no longer used, and the code is reserved.</source>
          <target state="translated">306状态码在本规范以前的版本中定义过,现在已经不再使用,该代码被保留。</target>
        </trans-unit>
        <trans-unit id="4404c364ec3064905980ead43e5d3f9ef55ccb2e" translate="yes" xml:space="preserve">
          <source>The 306 status code was used in a previous version of the
   specification, is no longer used, and the code is reserved.</source>
          <target state="translated">306状态码在以前的规范版本中使用过,现在不再使用,该代码为保留代码。</target>
        </trans-unit>
        <trans-unit id="efa8bf4f32294cae0ef47f6deb993b93eec7981d" translate="yes" xml:space="preserve">
          <source>The 307 (Temporary Redirect) status code indicates that the target
   resource resides temporarily under a different URI and the user agent
   MUST NOT change the request method if it performs an automatic
   redirection to that URI.  Since the redirection can change over time,
   the client ought to continue using the original effective request URI
   for future requests.

   The server SHOULD generate a Location header field in the response
   containing a URI reference for the different URI.  The user agent MAY
   use the Location field value for automatic redirection.  The server's
   response payload usually contains a short hypertext note with a
   hyperlink to the different URI(s).

      Note: This status code is similar to 302 (Found), except that it
      does not allow changing the request method from POST to GET.  This
      specification defines no equivalent counterpart for 301 (Moved
      Permanently) ([&lt;a href=&quot;https://tools.ietf.org/html/rfc7238&quot;&gt;RFC7238&lt;/a&gt;], however, defines the status code 308
      (Permanent Redirect) for this purpose).</source>
          <target state="translated">The 307 (Temporary Redirect) status code indicates that the target resource resides temporarily under a different URI and the user agent MUST NOT change the request method if it performs an automatic redirection to that URI. Since the redirection can change over time, the client ought to continue using the original effective request URI for future requests. The server SHOULD generate a Location header field in the response containing a URI reference for the different URI. The user agent MAY use the Location field value for automatic redirection. The server's response payload usually contains a short hypertext note with a hyperlink to the different URI(s). Note: This status code is similar to 302 (Found), except that it does not allow changing the request method from POST to GET. This specification defines no equivalent counterpart for 301 (Moved Permanently) ([&lt;a href=&quot;https://tools.ietf.org/html/rfc7238&quot;&gt;&lt;/a&gt;但是，RFC7238为此定义了状态代码308（永久重定向）。</target>
        </trans-unit>
        <trans-unit id="0b552dedeef68a9fc1c9bedf80fe2f970232311c" translate="yes" xml:space="preserve">
          <source>The 3xx (Redirection) class of status code indicates that further
   action needs to be taken by the user agent in order to fulfill the
   request.  If a Location header field (&lt;a href=&quot;#section-7.1.2&quot;&gt;Section 7.1.2&lt;/a&gt;) is provided, the
   user agent MAY automatically redirect its request to the URI
   referenced by the Location field value, even if the specific status
   code is not understood.  Automatic redirection needs to done with
   care for methods not known to be safe, as defined in &lt;a href=&quot;#section-4.2.1&quot;&gt;Section 4.2.1&lt;/a&gt;,
   since the user might not wish to redirect an unsafe request.

   There are several types of redirects:

   1.  Redirects that indicate the resource might be available at a
       different URI, as provided by the Location field, as in the
       status codes 301 (Moved Permanently), 302 (Found), and 307
       (Temporary Redirect).

   2.  Redirection that offers a choice of matching resources, each
       capable of representing the original request target, as in the
       300 (Multiple Choices) status code.

   3.  Redirection to a different resource, identified by the Location
       field, that can represent an indirect response to the request, as
       in the 303 (See Other) status code.

   4.  Redirection to a previously cached result, as in the 304 (Not
       Modified) status code.

      Note: In HTTP/1.0, the status codes 301 (Moved Permanently) and
      302 (Found) were defined for the first type of redirect
      (&lt;a href=&quot;https://tools.ietf.org/html/rfc1945#section-9.3&quot;&gt;[RFC1945], Section&amp;nbsp;9.3&lt;/a&gt;).  Early user agents split on whether the
      method applied to the redirect target would be the same as the 

      original request or would be rewritten as GET.  Although HTTP
      originally defined the former semantics for 301 and 302 (to match
      its original implementation at CERN), and defined 303 (See Other)
      to match the latter semantics, prevailing practice gradually
      converged on the latter semantics for 301 and 302 as well.  The
      first revision of HTTP/1.1 added 307 (Temporary Redirect) to
      indicate the former semantics without being impacted by divergent
      practice.  Over 10 years later, most user agents still do method
      rewriting for 301 and 302; therefore, this specification makes
      that behavior conformant when the original request is POST.

   A client SHOULD detect and intervene in cyclical redirections (i.e.,
   &quot;infinite&quot; redirection loops).

      Note: An earlier version of this specification recommended a
      maximum of five redirections (&lt;a href=&quot;https://tools.ietf.org/html/rfc2068#section-10.3&quot;&gt;[RFC2068], Section&amp;nbsp;10.3&lt;/a&gt;).  Content
      developers need to be aware that some clients might implement such
      a fixed limitation.</source>
          <target state="translated">状态代码的3xx（重定向）类指示用户代理需要采取进一步的措施才能满足请求。如果提供了位置标头字段（&lt;a href=&quot;#section-7.1.2&quot;&gt;第7.1.2节&lt;/a&gt;），则即使不理解特定的状态代码，用户代理也可以自动将其请求重定向到位置字段值所引用的URI。自动重定向需要谨慎处理&lt;a href=&quot;#section-4.2.1&quot;&gt;4.2.1节中&lt;/a&gt;定义的不安全的方法，因为用户可能不希望重定向不安全的请求。重定向类型有几种：1.重定向，指示资源可能在不同的URI上可用，如位置字段所提供的，如状态码301（永久移动），302（已找到）和307（临时重定向） ）。 2.重定向，它提供了一系列匹配资源，每个资源都可以代表原始请求目标，如300（多项选择）状态码中所示。 3.重定向到&amp;ldquo;位置&amp;rdquo;字段标识的另一个资源，该资源可以表示对请求的间接响应，如303（请参阅其他）状态码中所示。 4.重定向到先前缓存的结果，如304（未修改）状态码中所示。注意：在HTTP / 1.0中，状态代码301（永久移动）和302（已找到）是为第一种重定向类型（&lt;a href=&quot;https://tools.ietf.org/html/rfc1945#section-9.3&quot;&gt;[RFC1945]，第9.3节&lt;/a&gt;）。早期的用户代理在应用于重定向目标的方法与原始请求相同还是将其重写为GET上存在分歧。尽管HTTP最初为301和302定义了前者的语义（以匹配其在CERN的原始实现），并定义了303（请参阅&amp;ldquo;其他&amp;rdquo;）以匹配后者的语义，但流行的做法也逐渐收敛于301和302的后一个语义。 HTTP / 1.1的第一个修订版添加了307（临时重定向），以指示以前的语义，而不受不同实践的影响。在10年后的今天，大多数用户代理仍然为301和302进行方法重写；因此，当原始请求为POST时，此规范使该行为一致。客户端应该检测并干预周期性重定向（即&amp;ldquo;无限&amp;rdquo;重定向循环）。注意：此规范的较早版本建议最多进行五个重定向（&lt;a href=&quot;https://tools.ietf.org/html/rfc2068#section-10.3&quot;&gt;[RFC2068]，第10.3节&lt;/a&gt;）。内容开发人员需要意识到某些客户端可能会实施这样的固定限制。</target>
        </trans-unit>
        <trans-unit id="334ca39a91da7c29dc27f4fe5d1fa671a87b47b0" translate="yes" xml:space="preserve">
          <source>The 400 (Bad Request) status code indicates that the server cannot or
   will not process the request due to something that is perceived to be
   a client error (e.g., malformed request syntax, invalid request
   message framing, or deceptive request routing).</source>
          <target state="translated">400(坏请求)状态码表示服务器不能或不会处理该请求,原因是被认为是客户端错误(例如,错误的请求语法、无效的请求消息框架或欺骗性的请求路由)。</target>
        </trans-unit>
        <trans-unit id="29689450f4d2cb77a3efa906a5294a262a4c2452" translate="yes" xml:space="preserve">
          <source>The 401 (Unauthorized) status code indicates that the request has not
   been applied because it lacks valid authentication credentials for
   the target resource.  The server generating a 401 response MUST send
   a WWW-Authenticate header field (&lt;a href=&quot;#section-4.1&quot;&gt;Section 4.1&lt;/a&gt;) containing at least one
   challenge applicable to the target resource.

   If the request included authentication credentials, then the 401
   response indicates that authorization has been refused for those
   credentials.  The user agent MAY repeat the request with a new or
   replaced Authorization header field (&lt;a href=&quot;#section-4.2&quot;&gt;Section 4.2&lt;/a&gt;).  If the 401
   response contains the same challenge as the prior response, and the
   user agent has already attempted authentication at least once, then
   the user agent SHOULD present the enclosed representation to the
   user, since it usually contains relevant diagnostic information.</source>
          <target state="translated">401（未经授权）状态码表示该请求尚未应用，因为它缺少目标资源的有效身份验证凭据。生成401响应的服务器必须发送WWW-Authenticate头域（&lt;a href=&quot;#section-4.1&quot;&gt;第4.1节&lt;/a&gt;），其中包含至少一个适用于目标资源的质询。如果请求包括身份验证凭据，则401响应指示已拒绝这些凭据的授权。用户代理可以用新的或替换的Authorization标头字段（&lt;a href=&quot;#section-4.2&quot;&gt;第4.2节）&lt;/a&gt;重复请求。）。如果401响应包含与先前响应相同的质询，并且用户代理已经尝试了至少一次身份验证，则用户代理应该向用户呈现随附的表示，因为它通常包含相关的诊断信息。</target>
        </trans-unit>
        <trans-unit id="8a32cd96fa39bd8cea46e432f2bd383665a1ab08" translate="yes" xml:space="preserve">
          <source>The 402 (Payment Required) status code is reserved for future use.</source>
          <target state="translated">402(需要付款)状态码是保留给将来使用的。</target>
        </trans-unit>
        <trans-unit id="79339f2e8ca3d487560bd812a6eea754f58b8f81" translate="yes" xml:space="preserve">
          <source>The 403 (Forbidden) status code indicates that the server understood
   the request but refuses to authorize it.  A server that wishes to
   make public why the request has been forbidden can describe that
   reason in the response payload (if any).

   If authentication credentials were provided in the request, the
   server considers them insufficient to grant access.  The client
   SHOULD NOT automatically repeat the request with the same
   credentials.  The client MAY repeat the request with new or different
   credentials.  However, a request might be forbidden for reasons
   unrelated to the credentials.

   An origin server that wishes to &quot;hide&quot; the current existence of a
   forbidden target resource MAY instead respond with a status code of
   404 (Not Found).</source>
          <target state="translated">403(Forbidden)状态码表示服务器理解了请求,但拒绝授权。服务器如果希望公开请求被禁止的原因,可以在响应有效载荷中描述该原因(如果有的话)。如果在请求中提供了认证凭证,服务器认为这些凭证不足以授予访问。客户端不应该用相同的凭证自动重复请求。客户端可以用新的或不同的凭证重复请求。但是,请求可能会因为与凭证无关的原因而被禁止。希望 &quot;隐藏 &quot;被禁止的目标资源的当前存在的源服务器可以用404(未找到)的状态码来响应。</target>
        </trans-unit>
        <trans-unit id="e3def26038d6d95647ba8eb940680d2af264c867" translate="yes" xml:space="preserve">
          <source>The 404 (Not Found) status code indicates that the origin server did
   not find a current representation for the target resource or is not
   willing to disclose that one exists.  A 404 status code does not
   indicate whether this lack of representation is temporary or
   permanent; the 410 (Gone) status code is preferred over 404 if the
   origin server knows, presumably through some configurable means, that
   the condition is likely to be permanent.

   A 404 response is cacheable by default; i.e., unless otherwise
   indicated by the method definition or explicit cache controls (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;Section&amp;nbsp;4.2.2 of [RFC7234]&lt;/a&gt;).</source>
          <target state="translated">404（未找到）状态代码表示原始服务器未找到目标资源的当前表示，或不愿意透露该资源的存在。 404状态代码并不表示这种缺乏表示是暂时的还是永久的；如果原始服务器大概通过某种可配置的方式得知该条件很可能是永久性的，则与404相比，首选410（已用）状态码。默认情况下，404响应是可缓存的；即，除非方法定义或显式缓存控件另有说明（请参阅 &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;[RFC7234]的4.2.2节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="139fdce0aa53e1ec81629bd1c9fe084f1e273d10" translate="yes" xml:space="preserve">
          <source>The 405 (Method Not Allowed) status code indicates that the method
   received in the request-line is known by the origin server but not
   supported by the target resource.  The origin server MUST generate an
   Allow header field in a 405 response containing a list of the target
   resource's currently supported methods.

   A 405 response is cacheable by default; i.e., unless otherwise
   indicated by the method definition or explicit cache controls (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;Section&amp;nbsp;4.2.2 of [RFC7234]&lt;/a&gt;).</source>
          <target state="translated">状态代码405（不允许使用方法）指示请求行中接收到的方法对于源服务器是已知的，但目标资源不支持。源服务器必须在405响应中生成允许标头字段，其中包含目标资源当前支持的方法的列表。默认情况下，405响应是可缓存的；即，除非方法定义或显式缓存控件另有说明（请参阅 &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;[RFC7234]的4.2.2节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="ee79d34ebbf5f698fa72e9938ee69213ae4643fa" translate="yes" xml:space="preserve">
          <source>The 406 (Not Acceptable) status code indicates that the target
   resource does not have a current representation that would be
   acceptable to the user agent, according to the proactive negotiation
   header fields received in the request (&lt;a href=&quot;#section-5.3&quot;&gt;Section 5.3&lt;/a&gt;), and the server
   is unwilling to supply a default representation.

   The server SHOULD generate a payload containing a list of available
   representation characteristics and corresponding resource identifiers
   from which the user or user agent can choose the one most
   appropriate.  A user agent MAY automatically select the most
   appropriate choice from that list.  However, this specification does
   not define any standard for such automatic selection, as described in
   &lt;a href=&quot;#section-6.4.1&quot;&gt;Section 6.4.1&lt;/a&gt;.</source>
          <target state="translated">406（不可接受）状态码表示，根据请求中收到的主动协商报头字段（&lt;a href=&quot;#section-5.3&quot;&gt;第5.3节&lt;/a&gt;），目标资源不具有用户代理可接受的当前表示，并且服务器不愿意提供默认表示。服务器应该产生一个有效载荷，其中包含一列可用的表示特征和相应的资源标识符，用户或用户代理可以从中选择最合适的一个。用户代理可以自动从该列表中选择最合适的选择。但是，本规范并未为此类自动选择定义任何标准，如&lt;a href=&quot;#section-6.4.1&quot;&gt;6.4.1节&lt;/a&gt;所述 。</target>
        </trans-unit>
        <trans-unit id="ec483ec7612cbc4a7219b208c6205da13b1a5be1" translate="yes" xml:space="preserve">
          <source>The 407 (Proxy Authentication Required) status code is similar to 401
   (Unauthorized), but it indicates that the client needs to
   authenticate itself in order to use a proxy.  The proxy MUST send a
   Proxy-Authenticate header field (&lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;) containing a challenge
   applicable to that proxy for the target resource.  The client MAY
   repeat the request with a new or replaced Proxy-Authorization header
   field (&lt;a href=&quot;#section-4.4&quot;&gt;Section 4.4&lt;/a&gt;).</source>
          <target state="translated">407（需要代理身份验证）状态码与401（未授权）相似​​，但是它指示客户端需要进行身份验证才能使用代理。代理必须发送一个Proxy-Authenticate头域（&lt;a href=&quot;#section-4.3&quot;&gt;第4.3节&lt;/a&gt;），其中包含适用于目标资源的该代理的质询。客户端可以用新的或替换的Proxy-Authorization头字段（&lt;a href=&quot;#section-4.4&quot;&gt;第4.4节&lt;/a&gt;）重复请求。</target>
        </trans-unit>
        <trans-unit id="d63a1397f5112fdbc72a63c104b8b9b743795432" translate="yes" xml:space="preserve">
          <source>The 408 (Request Timeout) status code indicates that the server did
   not receive a complete request message within the time that it was
   prepared to wait.  A server SHOULD send the &quot;close&quot; connection option
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6.1&quot;&gt;Section&amp;nbsp;6.1 of [RFC7230]&lt;/a&gt;) in the response, since 408 implies that
   the server has decided to close the connection rather than continue
   waiting.  If the client has an outstanding request in transit, the
   client MAY repeat that request on a new connection.</source>
          <target state="translated">408（请求超时）状态码表示服务器在准备等待时未收到完整的请求消息。服务器应在响应中发送&amp;ldquo;关闭&amp;rdquo;连接选项（&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6.1&quot;&gt;[RFC7230] 6.1节&lt;/a&gt;），因为408表示服务器已决定关闭连接而不是继续等待。如果客户端在传输过程中有未完成的请求，则客户端可以在新的连接上重复该请求。</target>
        </trans-unit>
        <trans-unit id="710b792af9157df3657d23cffcb2324a8f3a8d23" translate="yes" xml:space="preserve">
          <source>The 409 (Conflict) status code indicates that the request could not
   be completed due to a conflict with the current state of the target
   resource.  This code is used in situations where the user might be
   able to resolve the conflict and resubmit the request.  The server
   SHOULD generate a payload that includes enough information for a user
   to recognize the source of the conflict.

   Conflicts are most likely to occur in response to a PUT request.  For
   example, if versioning were being used and the representation being
   PUT included changes to a resource that conflict with those made by
   an earlier (third-party) request, the origin server might use a 409
   response to indicate that it can't complete the request.  In this
   case, the response representation would likely contain information
   useful for merging the differences based on the revision history.</source>
          <target state="translated">409(冲突)状态代码表示由于与目标资源的当前状态冲突,请求无法完成。该代码用于用户可能能够解决冲突并重新提交请求的情况。服务器应该生成一个包含足够信息的有效载荷,以便用户识别冲突的来源。冲突最可能发生在响应PUT请求时。例如,如果正在使用版本管理,并且被 PUT 的表示包括对资源的更改,而这些更改与早期(第三方)请求所做的更改相冲突,那么源服务器可能会使用 409 响应来表示它不能完成请求。在这种情况下,响应表示可能会包含对根据修订历史合并差异有用的信息。</target>
        </trans-unit>
        <trans-unit id="ed70c66832007f42d2ffeafd2453c5472e4f6db0" translate="yes" xml:space="preserve">
          <source>The 410 (Gone) status code indicates that access to the target
   resource is no longer available at the origin server and that this
   condition is likely to be permanent.  If the origin server does not 

   know, or has no facility to determine, whether or not the condition
   is permanent, the status code 404 (Not Found) ought to be used
   instead.

   The 410 response is primarily intended to assist the task of web
   maintenance by notifying the recipient that the resource is
   intentionally unavailable and that the server owners desire that
   remote links to that resource be removed.  Such an event is common
   for limited-time, promotional services and for resources belonging to
   individuals no longer associated with the origin server's site.  It
   is not necessary to mark all permanently unavailable resources as
   &quot;gone&quot; or to keep the mark for any length of time -- that is left to
   the discretion of the server owner.

   A 410 response is cacheable by default; i.e., unless otherwise
   indicated by the method definition or explicit cache controls (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;Section&amp;nbsp;4.2.2 of [RFC7234]&lt;/a&gt;).</source>
          <target state="translated">410（已消失）状态代码表示在原始服务器上不再可以访问目标资源，并且这种情况很可能是永久的。如果原始服务器不知道该条件是否永久存在，或者无法确定该条件是否永久存在，则应改用状态代码404（未找到）。 410响应主要旨在通过通知接收者资源有意不可用以及服务器所有者希望删除指向该资源的远程链接来辅助Web维护任务。对于限时促销服务和属于不再与原始服务器站点关联的个人的资源而言，此类事件很常见。不必将所有永久不可用的资源标记为&amp;ldquo;消失或保留该标记的任何时间-由服务器所有者自行决定。默认情况下，410响应是可缓存的；即，除非方法定义或显式缓存控件另有说明（请参见 &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;[RFC7234]的第4.2.2节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="1d57fe4e2e7ca23134c38c0ed0018ac65cd3855c" translate="yes" xml:space="preserve">
          <source>The 411 (Length Required) status code indicates that the server
   refuses to accept the request without a defined Content-Length
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.3.2&quot;&gt;Section&amp;nbsp;3.3.2 of [RFC7230]&lt;/a&gt;).  The client MAY repeat the request if
   it adds a valid Content-Length header field containing the length of
   the message body in the request message.</source>
          <target state="translated">411（必需的长度）状态代码指示服务器拒绝接受没有定义的Content-Length（&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.3.2&quot;&gt;[RFC7230]的3.3.2节）&lt;/a&gt;的请求。如果客户端在请求消息中添加了包含消息正文长度的有效Content-Length头字段，则客户端可以重复该请求。</target>
        </trans-unit>
        <trans-unit id="a2b0a5d0ce695f774d281e52c15ee444fd3362b0" translate="yes" xml:space="preserve">
          <source>The 412 (Precondition Failed) status code indicates that one or more
   conditions given in the request header fields evaluated to false when
   tested on the server.  This response code allows the client to place
   preconditions on the current resource state (its current
   representations and metadata) and, thus, prevent the request method
   from being applied if the target resource is in an unexpected state.</source>
          <target state="translated">412(先决条件失败)状态码表示在服务器上测试时,请求头字段中给出的一个或多个条件评价为假。该响应代码允许客户端对当前资源状态(其当前的表示和元数据)设置先决条件,因此,如果目标资源处于意外状态,则防止请求方法被应用。</target>
        </trans-unit>
        <trans-unit id="d068c8261010d8ad8c83770690d1c48285eb7c3d" translate="yes" xml:space="preserve">
          <source>The 413 (Payload Too Large) status code indicates that the server is
   refusing to process a request because the request payload is larger
   than the server is willing or able to process.  The server MAY close
   the connection to prevent the client from continuing the request.

   If the condition is temporary, the server SHOULD generate a
   Retry-After header field to indicate that it is temporary and after
   what time the client MAY try again.</source>
          <target state="translated">413(Payload Too Large)状态码表示服务器拒绝处理请求,因为请求的有效载荷大于服务器愿意或能够处理的范围。服务器可以关闭连接以防止客户端继续请求。如果这种情况是暂时的,服务器应该生成一个Retry-After头域,以表明这是暂时的,以及在什么时间之后客户端可以再次尝试。</target>
        </trans-unit>
        <trans-unit id="2eeffaec19aae81212514c4d922d7dc543cfcc59" translate="yes" xml:space="preserve">
          <source>The 414 (URI Too Long) status code indicates that the server is
   refusing to service the request because the request-target (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.3&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.3&quot;&gt;5.3 of [RFC7230]&lt;/a&gt;) is longer than the server is willing to interpret.
   This rare condition is only likely to occur when a client has
   improperly converted a POST request to a GET request with long query
   information, when the client has descended into a &quot;black hole&quot; of
   redirection (e.g., a redirected URI prefix that points to a suffix of
   itself) or when the server is under attack by a client attempting to
   exploit potential security holes. 

   A 414 response is cacheable by default; i.e., unless otherwise
   indicated by the method definition or explicit cache controls (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;Section&amp;nbsp;4.2.2 of [RFC7234]&lt;/a&gt;).</source>
          <target state="translated">414（URI太长）状态代码表示服务器拒绝服务请求，因为请求目标（&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.3&quot;&gt;[RFC7230]的5.3 &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.3&quot;&gt;节&lt;/a&gt;）长于服务器愿意解释的长度。仅当客户端将不正确的POST请求转换为带有长查询信息的GET请求且客户端下降到重定向的&amp;ldquo;黑洞&amp;rdquo;时（例如，指向一个后缀）或当服务器受到客户端尝试利用潜在安全漏洞的攻击时。默认情况下，414响应是可缓存的；即，除非方法定义或显式缓存控件另有说明（请参阅 &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;[RFC7234]的4.2.2节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="60bd497af3a67e2912392260b738e67280886922" translate="yes" xml:space="preserve">
          <source>The 415 (Unsupported Media Type) status code indicates that the
   origin server is refusing to service the request because the payload
   is in a format not supported by this method on the target resource.
   The format problem might be due to the request's indicated
   Content-Type or Content-Encoding, or as a result of inspecting the
   data directly.</source>
          <target state="translated">415(不支持的媒体类型)状态码表示源服务器拒绝服务该请求,因为有效载荷的格式在目标资源上不受该方法支持。格式问题可能是由于请求中指明的Content-Type或Content-Encoding,或者是直接检查数据的结果。</target>
        </trans-unit>
        <trans-unit id="e7168717c59ebb6678e8095c4f89436d6063047e" translate="yes" xml:space="preserve">
          <source>The 416 (Range Not Satisfiable) status code indicates that none of
   the ranges in the request's Range header field (&lt;a href=&quot;#section-3.1&quot;&gt;Section 3.1&lt;/a&gt;) overlap
   the current extent of the selected resource or that the set of ranges
   requested has been rejected due to invalid ranges or an excessive
   request of small or overlapping ranges.

   For byte ranges, failing to overlap the current extent means that the
   first-byte-pos of all of the byte-range-spec values were greater than
   the current length of the selected representation.  When this status
   code is generated in response to a byte-range request, the sender
   SHOULD generate a Content-Range header field specifying the current
   length of the selected representation (&lt;a href=&quot;#section-4.2&quot;&gt;Section 4.2&lt;/a&gt;).

   For example:

     HTTP/1.1 416 Range Not Satisfiable
     Date: Fri, 20 Jan 2012 15:41:54 GMT
     Content-Range: bytes */47022

      Note: Because servers are free to ignore Range, many
      implementations will simply respond with the entire selected
      representation in a 200 (OK) response.  That is partly because
      most clients are prepared to receive a 200 (OK) to complete the
      task (albeit less efficiently) and partly because clients might
      not stop making an invalid partial request until they have
      received a complete representation.  Thus, clients cannot depend
      on receiving a 416 (Range Not Satisfiable) response even when it
      is most appropriate.</source>
          <target state="translated">416（Range Not Satisfiable）状态代码表示请求的Range标头字段（&lt;a href=&quot;#section-3.1&quot;&gt;第3.1节&lt;/a&gt;）中没有任何范围与所选资源的当前范围重叠，或者由于无效范围或过多的范围而拒绝了所请求的范围集小范围或重叠范围的请求。对于字节范围，如果不与当前范围重叠，则意味着所有字节范围规范值的第一个字节位置大于所选表示形式的当前长度。当响应字节范围请求而生成此状态代码时，发送方应生成一个Content-Range头字段，该字段指定所选表示形式的当前长度（&lt;a href=&quot;#section-4.2&quot;&gt;第4.2节）&lt;/a&gt;）。例如：HTTP / 1.1 416范围不满足日期：2012年1月20日星期五15:41:54 GMT内容范围：字节* / 47022注意：由于服务器可以随意忽略范围，因此许多实现将简单地对整个选定内容进行响应表示为200（OK）。这部分是因为大多数客户端准备好接收200（确定）以完成任务（尽管效率较低），部分原因是客户端在收到完整的表示之前可能不会停止发出无效的部分请求。因此，即使最合适，客户端也不能依赖于接收到416（不满足范围）响应。</target>
        </trans-unit>
        <trans-unit id="74e2689c2b2651176712bcca9c3464c338299fa4" translate="yes" xml:space="preserve">
          <source>The 417 (Expectation Failed) status code indicates that the
   expectation given in the request's Expect header field
   (&lt;a href=&quot;#section-5.1.1&quot;&gt;Section 5.1.1&lt;/a&gt;) could not be met by at least one of the inbound
   servers.</source>
          <target state="translated">状态代码417（预期失败）指示，至少一台入站服务器无法满足请求的Expect标头字段（&lt;a href=&quot;#section-5.1.1&quot;&gt;第5.1.1节&lt;/a&gt;）中给出的预期。</target>
        </trans-unit>
        <trans-unit id="3e7e0d5b09bdf010782a5ab49b88e3ef27b80255" translate="yes" xml:space="preserve">
          <source>The 421 (Misdirected Request) status code indicates that the request
   was directed at a server that is not able to produce a response.
   This can be sent by a server that is not configured to produce
   responses for the combination of scheme and authority that are
   included in the request URI. 

   Clients receiving a 421 (Misdirected Request) response from a server
   MAY retry the request -- whether the request method is idempotent or
   not -- over a different connection.  This is possible if a connection
   is reused (&lt;a href=&quot;#section-9.1.1&quot;&gt;Section 9.1.1&lt;/a&gt;) or if an alternative service is selected
   [&lt;a href=&quot;#ref-ALT-SVC&quot;&gt;ALT-SVC&lt;/a&gt;].

   This status code MUST NOT be generated by proxies.

   A 421 response is cacheable by default, i.e., unless otherwise
   indicated by the method definition or explicit cache controls (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;Section&amp;nbsp;4.2.2 of [RFC7234]&lt;/a&gt;).</source>
          <target state="translated">状态代码421（错误定向的请求）指示该请求已定向到无法产生响应的服务器。这可以由未配置为对请求URI中包含的方案和权限的组合产生响应的服务器发送。从服务器接收到421（错误请求）响应的客户端可以通过不同的连接重试该请求（无论请求方法是否幂等）。如果重新使用连接（&lt;a href=&quot;#section-9.1.1&quot;&gt;第9.1.1节&lt;/a&gt;）或选择了备用服务[ &lt;a href=&quot;#ref-ALT-SVC&quot;&gt;ALT-SVC&lt;/a&gt; ]，则有可能。此状态代码不得由代理生成。默认情况下，421响应是可缓存的，即，除非方法定义或显式缓存控件另有指示（请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;[RFC7234]的4.2.2节）&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="240b1b41518b4e60c5fb369224ec2a4d545cd292" translate="yes" xml:space="preserve">
          <source>The 422 (Unprocessable Entity) status code means the server
   understands the content type of the request entity (hence a
   415(Unsupported Media Type) status code is inappropriate), and the
   syntax of the request entity is correct (thus a 400 (Bad Request)
   status code is inappropriate) but was unable to process the contained
   instructions.  For example, this error condition may occur if an XML
   request body contains well-formed (i.e., syntactically correct), but
   semantically erroneous, XML instructions.</source>
          <target state="translated">422(不可处理实体)状态码意味着服务器理解请求实体的内容类型(因此415(不支持的媒体类型)状态码是不合适的),请求实体的语法是正确的(因此400(坏请求)状态码是不合适的),但无法处理包含的指令。例如,如果一个XML请求体包含格式良好(即语法正确)但语义错误的XML指令,就会出现这种错误条件。</target>
        </trans-unit>
        <trans-unit id="ab7728b25333c3ed3e9c44c0ad08c1c5736966a3" translate="yes" xml:space="preserve">
          <source>The 423 (Locked) status code means the source or destination resource
   of a method is locked.  This response SHOULD contain an appropriate
   precondition or postcondition code, such as 'lock-token-submitted' or
   'no-conflicting-lock'.</source>
          <target state="translated">423 (Locked)状态码意味着方法的源或目标资源被锁定。这个响应应该包含一个适当的先决条件或后决条件代码,比如 &quot;lock-token-submitted &quot;或 &quot;no-conflicting-lock&quot;。</target>
        </trans-unit>
        <trans-unit id="7bea7308e120efd626a2dea25e346d82459c7846" translate="yes" xml:space="preserve">
          <source>The 424 (Failed Dependency) status code means that the method could
   not be performed on the resource because the requested action
   depended on another action and that action failed.  For example, if a
   command in a PROPPATCH method fails, then, at minimum, the rest of
   the commands will also fail with 424 (Failed Dependency).</source>
          <target state="translated">424(Failed Dependency)状态码意味着该方法无法在资源上执行,因为请求的操作依赖于另一个操作,而该操作失败了。例如,如果PROPPATCH方法中的一条命令失败了,那么,其余命令至少也会以424(Failed Dependency)失败。</target>
        </trans-unit>
        <trans-unit id="bbb046d45cb07e647735e9643ff8b2d8aa6d1cf5" translate="yes" xml:space="preserve">
          <source>The 426 (Upgrade Required) status code indicates that the server
   refuses to perform the request using the current protocol but might
   be willing to do so after the client upgrades to a different
   protocol.  The server MUST send an Upgrade header field in a 426
   response to indicate the required protocol(s) (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6.7&quot;&gt;Section&amp;nbsp;6.7 of
   [RFC7230]&lt;/a&gt;).

   Example:

     HTTP/1.1 426 Upgrade Required
     Upgrade: HTTP/3.0
     Connection: Upgrade
     Content-Length: 53
     Content-Type: text/plain

     This service requires use of the HTTP/3.0 protocol.</source>
          <target state="translated">426（需要升级）状态代码表示服务器拒绝使用当前协议执行请求，但在客户端升级到其他协议后可能愿意这样做。服务器必须在426响应中发送一个Upgrade头域，以指示所需的协议（&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6.7&quot;&gt;[RFC7230]的6.7节&lt;/a&gt;）。示例：HTTP / 1.1 426需要升级升级：HTTP / 3.0连接：升级内容长度：53内容类型：文本/纯文本此服务需要使用HTTP / 3.0协议。</target>
        </trans-unit>
        <trans-unit id="ff18add20b8f554c457e49bc2e7ce8d714901464" translate="yes" xml:space="preserve">
          <source>The 4xx (Client Error) class of status code indicates that the client
   seems to have erred.  Except when responding to a HEAD request, the
   server SHOULD send a representation containing an explanation of the
   error situation, and whether it is a temporary or permanent
   condition.  These status codes are applicable to any request method.
   User agents SHOULD display any included representation to the user.</source>
          <target state="translated">4xx(客户端错误)类状态码表示客户端似乎出错了。除了响应HEAD请求的时候,服务器应该发送一个包含错误情况解释的表示,以及它是暂时的还是永久的情况。这些状态码适用于任何请求方法。用户代理SHOULD将任何包含的表示显示给用户。</target>
        </trans-unit>
        <trans-unit id="0c2a74d9f06b0a77075195702a5230a67673de95" translate="yes" xml:space="preserve">
          <source>The 4xx class of status code is intended for cases in which the
   client seems to have erred. Except when responding to a HEAD request,
   the server SHOULD include an entity containing an explanation of the
   error situation, and whether it is a temporary or permanent
   condition. These status codes are applicable to any request method.
   User agents SHOULD display any included entity to the user.

   If the client is sending data, a server implementation using TCP
   SHOULD be careful to ensure that the client acknowledges receipt of
   the packet(s) containing the response, before the server closes the
   input connection. If the client continues sending data to the server
   after the close, the server's TCP stack will send a reset packet to
   the client, which may erase the client's unacknowledged input buffers
   before they can be read and interpreted by the HTTP application.</source>
          <target state="translated">4xx类状态码是针对客户端似乎出错的情况。除了响应HEAD请求时,服务器应该包含一个实体,其中包含对错误情况的解释,以及它是暂时的还是永久的条件。这些状态码适用于任何请求方法。用户代理SHOULD向用户显示任何包含的实体。如果客户机正在发送数据,使用TCP的服务器实现应该注意确保客户机在服务器关闭输入连接之前,确认收到包含响应的数据包。如果客户端在关闭后继续向服务器发送数据,服务器的TCP协议栈将向客户端发送一个复位包,这可能会在HTTP应用程序读取和解释客户端未确认的输入缓冲区之前将其清除。</target>
        </trans-unit>
        <trans-unit id="e4172cee002fab51d59cbb6c27d459c5303764c9" translate="yes" xml:space="preserve">
          <source>The 500 (Internal Server Error) status code indicates that the server
   encountered an unexpected condition that prevented it from fulfilling
   the request.</source>
          <target state="translated">500(内部服务器错误)状态码表示服务器遇到了意外情况,使其无法完成请求。</target>
        </trans-unit>
        <trans-unit id="5e788aee762bb64f07dea7e2e3b12cc4a6d5e7c2" translate="yes" xml:space="preserve">
          <source>The 501 (Not Implemented) status code indicates that the server does
   not support the functionality required to fulfill the request.  This
   is the appropriate response when the server does not recognize the
   request method and is not capable of supporting it for any resource.

   A 501 response is cacheable by default; i.e., unless otherwise
   indicated by the method definition or explicit cache controls (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;Section&amp;nbsp;4.2.2 of [RFC7234]&lt;/a&gt;).</source>
          <target state="translated">501（未实现）状态代码表示服务器不支持满足请求所需的功能。当服务器无法识别请求方法并且不支持任何资源时，这是适当的响应。默认情况下，501响应是可缓存的；即，除非方法定义或显式缓存控件另有说明（请参阅 &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;[RFC7234]的4.2.2节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="537a3dde972341b94cbb072093d8857e86b4614a" translate="yes" xml:space="preserve">
          <source>The 502 (Bad Gateway) status code indicates that the server, while
   acting as a gateway or proxy, received an invalid response from an
   inbound server it accessed while attempting to fulfill the request.</source>
          <target state="translated">502(坏网关)状态码表示服务器在作为网关或代理时,在试图完成请求时收到了它访问的入站服务器的无效响应。</target>
        </trans-unit>
        <trans-unit id="6bbdd751ae4429ec4369780a1676c0e2b99f0f2f" translate="yes" xml:space="preserve">
          <source>The 503 (Service Unavailable) status code indicates that the server
   is currently unable to handle the request due to a temporary overload
   or scheduled maintenance, which will likely be alleviated after some
   delay.  The server MAY send a Retry-After header field
   (&lt;a href=&quot;#section-7.1.3&quot;&gt;Section 7.1.3&lt;/a&gt;) to suggest an appropriate amount of time for the
   client to wait before retrying the request.

      Note: The existence of the 503 status code does not imply that a
      server has to use it when becoming overloaded.  Some servers might
      simply refuse the connection.</source>
          <target state="translated">503（服务不可用）状态码表示服务器由于暂时的过载或计划的维护而当前无法处理该请求，这可能会在某些延迟后得到缓解。服务器可以发送一个Retry-After头域（&lt;a href=&quot;#section-7.1.3&quot;&gt;第7.1.3节&lt;/a&gt;）来建议一个适当的时间，以便客户端在重试请求之前等待。注意：503状态代码的存在并不意味着服务器在过载时必须使用它。某些服务器可能只是拒绝连接。</target>
        </trans-unit>
        <trans-unit id="cb5a6e6224a6befed044cf459ac3ad6b9a312b3f" translate="yes" xml:space="preserve">
          <source>The 504 (Gateway Timeout) status code indicates that the server,
   while acting as a gateway or proxy, did not receive a timely response
   from an upstream server it needed to access in order to complete the
   request.</source>
          <target state="translated">504(网关超时)状态码表示服务器在作为网关或代理时,没有收到它需要访问的上游服务器的及时响应以完成请求。</target>
        </trans-unit>
        <trans-unit id="73dde1c42105fdf2e1da6b5ec6f32547fa21c1f6" translate="yes" xml:space="preserve">
          <source>The 505 (HTTP Version Not Supported) status code indicates that the
   server does not support, or refuses to support, the major version of
   HTTP that was used in the request message.  The server is indicating
   that it is unable or unwilling to complete the request using the same
   major version as the client, as described in &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.6&quot;&gt;Section&amp;nbsp;2.6 of
   [RFC7230]&lt;/a&gt;, other than with this error message.  The server SHOULD
   generate a representation for the 505 response that describes why
   that version is not supported and what other protocols are supported
   by that server.</source>
          <target state="translated">505（不支持HTTP版本）状态代码表示服务器不支持或拒绝支持请求消息中使用的HTTP的主要版本。服务器指示它无法或不愿意使用与客户端相同的主要版本来完成请求，如&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.6&quot;&gt;[RFC7230]的2.6节&lt;/a&gt;所述，带有此错误消息除外。服务器应该为505响应生成表示，该响应描述为什么不支持该版本以及该服务器支持哪些其他协议。</target>
        </trans-unit>
        <trans-unit id="6cfe58d6c6aa1b9a0d0a3a747564d201b045f349" translate="yes" xml:space="preserve">
          <source>The 507 (Insufficient Storage) status code means the method could not
   be performed on the resource because the server is unable to store
   the representation needed to successfully complete the request.  This
   condition is considered to be temporary.  If the request that
   received this status code was the result of a user action, the
   request MUST NOT be repeated until it is requested by a separate user
   action.</source>
          <target state="translated">507(存储不足)状态码意味着由于服务器无法存储成功完成请求所需的表示,因此无法对资源执行该方法。这种情况被认为是暂时的。如果收到该状态码的请求是用户操作的结果,那么在被单独的用户操作请求之前,必须不重复该请求。</target>
        </trans-unit>
        <trans-unit id="0e2021f09cffdfd7e8e3c2b6e4af6afc876e3ba4" translate="yes" xml:space="preserve">
          <source>The 511 status code indicates that the client needs to authenticate to gain network access.</source>
          <target state="translated">511状态码表示客户端需要进行认证才能获得网络访问。</target>
        </trans-unit>
        <trans-unit id="6f13f00eed6e2731f85266d4d2b5d1b194f1dc69" translate="yes" xml:space="preserve">
          <source>The 5xx (Server Error) class of status code indicates that the server
   is aware that it has erred or is incapable of performing the
   requested method.  Except when responding to a HEAD request, the
   server SHOULD send a representation containing an explanation of the
   error situation, and whether it is a temporary or permanent 

   condition.  A user agent SHOULD display any included representation
   to the user.  These response codes are applicable to any request
   method.</source>
          <target state="translated">5xx(服务器错误)类状态码表示服务器意识到自己出错了,或者无法执行请求的方法。除了响应HEAD请求时,服务器应该发送一个包含错误情况解释的表示,以及它是暂时的还是永久的条件。用户代理应该向用户显示任何包含的表示。这些响应代码适用于任何请求方法。</target>
        </trans-unit>
        <trans-unit id="eff8921ecde9859824b0aa4a316363853f77725f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../index&quot;&gt;HTTP&lt;/a&gt;&lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&lt;strong&gt;require-sri-for&lt;/strong&gt;&lt;/code&gt; directive instructs the client to require the use of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity&quot;&gt;Subresource Integrity&lt;/a&gt; for scripts or styles on the page.</source>
          <target state="translated">在&lt;a href=&quot;../../index&quot;&gt;HTTP&lt;/a&gt;&lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&lt;strong&gt;require-sri-for&lt;/strong&gt;&lt;/code&gt; 指令指示客户端需要使用的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity&quot;&gt;子资源完整性&lt;/a&gt;网页上的脚本或样式。</target>
        </trans-unit>
        <trans-unit id="f8981236cb35a3546e80d22d9775227a98e95ef1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../basics_of_http/mime_types&quot;&gt;MIME type&lt;/a&gt; of the resource or the data.</source>
          <target state="translated">资源或数据的&lt;a href=&quot;../basics_of_http/mime_types&quot;&gt;MIME类型&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="476cfd9f7f7d09d394f8e2d140063c4110e761fd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../headers/access-control-request-headers&quot;&gt;&lt;code&gt;Access-Control-Request-Headers&lt;/code&gt;&lt;/a&gt; header tells the server that when the actual request is sent, it will have the &lt;code&gt;X-PINGOTHER&lt;/code&gt; and &lt;code&gt;Content-Type&lt;/code&gt; headers.</source>
          <target state="translated">该&lt;a href=&quot;../headers/access-control-request-headers&quot;&gt; &lt;code&gt;Access-Control-Request-Headers&lt;/code&gt; &lt;/a&gt;报头告诉服务器在发送实际的请求时，将有 &lt;code&gt;X-PINGOTHER&lt;/code&gt; 和 &lt;code&gt;Content-Type&lt;/code&gt; 头。</target>
        </trans-unit>
        <trans-unit id="11aa0c02b1fe58d03a5cb415bbf783776721cd3e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../headers/access-control-request-method&quot;&gt;&lt;code&gt;Access-Control-Request-Method&lt;/code&gt;&lt;/a&gt; header sent in the preflight request tells the server that when the actual request is sent, it will have a &lt;a href=&quot;post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; request method.</source>
          <target state="translated">预检请求中发送的&lt;a href=&quot;../headers/access-control-request-method&quot;&gt; &lt;code&gt;Access-Control-Request-Method&lt;/code&gt; &lt;/a&gt;标头告诉服务器，当实际请求发送时，它将具有&lt;a href=&quot;post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt;请求方法。</target>
        </trans-unit>
        <trans-unit id="bee0f2cff0fd1a73153d67243f177de87af10640" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../headers/feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; HTTP header.</source>
          <target state="translated">的&lt;a href=&quot;../headers/feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; HTTP标头。</target>
        </trans-unit>
        <trans-unit id="1495070845bb0ae9175f95e2e4b9163ee31037e8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../headers/referer&quot;&gt;&lt;code&gt;Referer&lt;/code&gt;&lt;/a&gt; URL is too long</source>
          <target state="translated">该&lt;a href=&quot;../headers/referer&quot;&gt; &lt;code&gt;Referer&lt;/code&gt; 的&lt;/a&gt;网址太长</target>
        </trans-unit>
        <trans-unit id="3221539e7878d032dbdd4035adad83f822b0aa1b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../referer&quot;&gt;&lt;code&gt;Referer&lt;/code&gt;&lt;/a&gt; header will be omitted entirely. No referrer information is sent along with requests.</source>
          <target state="translated">所述&lt;a href=&quot;../referer&quot;&gt; &lt;code&gt;Referer&lt;/code&gt; &lt;/a&gt;头将被完全省略。没有引荐来源信息随请求一起发送。</target>
        </trans-unit>
        <trans-unit id="e873c7c4f23e96331a7b10f6fab0e72d0c3815f6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt; header needs to be set to &quot;keep-alive&quot; for this header to have any meaning.</source>
          <target state="translated">必须将&lt;a href=&quot;connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt;标头设置为&amp;ldquo;保持活动&amp;rdquo;，此标头才能具有任何含义。</target>
        </trans-unit>
        <trans-unit id="823cc49a67542bdec9a4ef4d6b1e415d7aeb3b04" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt; header needs to be set to &quot;keep-alive&quot; for this header to have any meaning. Also, &lt;a href=&quot;connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;keep-alive&quot;&gt;&lt;code&gt;Keep-Alive&lt;/code&gt;&lt;/a&gt; are ignored in HTTP/2; connection management is handled by other mechanisms there.</source>
          <target state="translated">必须将&lt;a href=&quot;connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt;标头设置为&amp;ldquo;保持活动&amp;rdquo;，此标头才能具有任何含义。另外，在HTTP / 2中，&lt;a href=&quot;connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;keep-alive&quot;&gt; &lt;code&gt;Keep-Alive&lt;/code&gt; &lt;/a&gt;被忽略；连接管理由那里的其他机制处理。</target>
        </trans-unit>
        <trans-unit id="28e20ae8f53246c900d9de361122fb549b4a54cc" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt; header with type &lt;code&gt;upgrade&lt;/code&gt; must &lt;em&gt;always&lt;/em&gt; be sent with the &lt;code&gt;Upgrade&lt;/code&gt; header (as shown above).</source>
          <target state="translated">类型为 &lt;code&gt;upgrade&lt;/code&gt; 的&lt;a href=&quot;connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt;标头必须&lt;em&gt;始终&lt;/em&gt;与 &lt;code&gt;Upgrade&lt;/code&gt; 标头一起发送（如上所示）。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3168c5253229cb7eddd39a17b55204a0719f1ccb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; defining the boundary of the multipart body.</source>
          <target state="translated">定义多部分体边界的&lt;a href=&quot;content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c285a5fb007b2a2d826d7bbfcdc526294f9f38d5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/accept&quot;&gt;&lt;code&gt;Accept&lt;/code&gt;&lt;/a&gt; header is defined by the browser, or any other user-agent, and can vary according to the context, like fetching an HTML page or an image, a video, or a script: It is different when fetching a document entered in the address bar or an element linked via an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img&quot;&gt;&lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt;&lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt;&lt;/a&gt; element. Browsers are free to use the value of the header that they think is the most adequate; an exhaustive list of &lt;a href=&quot;content_negotiation/list_of_default_accept_values&quot;&gt;default values for common browsers&lt;/a&gt; is available.</source>
          <target state="translated">的&lt;a href=&quot;headers/accept&quot;&gt; &lt;code&gt;Accept&lt;/code&gt; &lt;/a&gt;报头是由浏览器，或任何其它用户代理限定，并且可以根据环境而变化，像取HTML页面或图像，视频，或脚本：当取出一个文档中的输入的，不同于地址栏或通过&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img&quot;&gt; &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt; &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt; &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; &lt;/a&gt;元素链接的元素。浏览器可以自由使用他们认为最合适的标头值；提供&lt;a href=&quot;content_negotiation/list_of_default_accept_values&quot;&gt;了常见浏览器&lt;/a&gt;的默认值的详尽列表。</target>
        </trans-unit>
        <trans-unit id="bb614dd01dd7b5c3319f1fa867383facbd91a1a2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/accept&quot;&gt;&lt;code&gt;Accept&lt;/code&gt;&lt;/a&gt; header lists the MIME types of media resources that the agent is willing to process. It is comma-separated lists of MIME types, each combined with a quality factor, a parameter indicating the relative degree of preference between the different MIME types.</source>
          <target state="translated">在&lt;a href=&quot;headers/accept&quot;&gt; &lt;code&gt;Accept&lt;/code&gt; &lt;/a&gt;头列表中的MIME类型的媒体资源代理愿意过程。它是MIME类型的逗号分隔列表，每个列表都与质量因数结合在一起，质量因数是一个参数，指示不同MIME类型之间的相对优先级。</target>
        </trans-unit>
        <trans-unit id="47c1d1550663e7b9840b652f6ba1f6059d00bdc3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/accept-ch-lifetime&quot;&gt;&lt;code&gt;Accept-CH-Lifetime&lt;/code&gt;&lt;/a&gt; header is used with the &lt;code&gt;Device-Memory&lt;/code&gt; value of the &lt;code&gt;Accept-CH&lt;/code&gt; header and indicates the amount of time the device should opt-in to sharing the amount of device memory with the server. The value is given in miliseconds and it's use is optional.</source>
          <target state="translated">所述&lt;a href=&quot;headers/accept-ch-lifetime&quot;&gt; &lt;code&gt;Accept-CH-Lifetime&lt;/code&gt; &lt;/a&gt;头用于与 &lt;code&gt;Device-Memory&lt;/code&gt; 在的值 &lt;code&gt;Accept-CH&lt;/code&gt; 头和表示时间的设备应该选择加入与服务器共享装置存储器的量的量。该值以毫秒为单位给出，它的使用是可选的。</target>
        </trans-unit>
        <trans-unit id="72ac9e88d286f1a089252d01c7518ad33d10efe4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/accept-charset&quot;&gt;&lt;code&gt;Accept-Charset&lt;/code&gt;&lt;/a&gt; header indicates to the server what kinds of character encodings are understood by the user-agent. Traditionally, it was set to a different value for each locale for the browser, like &lt;code&gt;ISO-8859-1,utf-8;q=0.7,*;q=0.7&lt;/code&gt; for a Western European locale.</source>
          <target state="translated">该&lt;a href=&quot;headers/accept-charset&quot;&gt; &lt;code&gt;Accept-Charset&lt;/code&gt; &lt;/a&gt;报头指示什么类型的字符编码通过用户代理理解服务器。传统上，对于浏览器的每个语言环境，它都设置为不同的值，例如 &lt;code&gt;ISO-8859-1,utf-8;q=0.7,*;q=0.7&lt;/code&gt; 对于西欧语言环境，ISO-8859-1，utf-8; q = 0.7，*; q = 0.7。</target>
        </trans-unit>
        <trans-unit id="cac90f4ab93dcb579a645e89e4735bc55952622d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/accept-encoding&quot;&gt;&lt;code&gt;Accept-Encoding&lt;/code&gt;&lt;/a&gt; header defines the acceptable content-encoding (supported compressions). The value is a q-factor list (e.g.: &lt;code&gt;br, gzip;q=0.8&lt;/code&gt;) that indicates the priority of the encoding values. The default value &lt;code&gt;identity&lt;/code&gt; is at the lowest priority (unless otherwise declared).</source>
          <target state="translated">所述&lt;a href=&quot;headers/accept-encoding&quot;&gt; &lt;code&gt;Accept-Encoding&lt;/code&gt; &lt;/a&gt;标头定义内容编码的可接受的（支持的压缩）。该值是一个q因子列表（例如 &lt;code&gt;br, gzip;q=0.8&lt;/code&gt; ），它表示编码值的优先级。默认值 &lt;code&gt;identity&lt;/code&gt; 为最低优先级（除非另行声明）。</target>
        </trans-unit>
        <trans-unit id="1da487f47873fc85841849fa6ec975c0f7e1eb16" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/accept-language&quot;&gt;&lt;code&gt;Accept-Language&lt;/code&gt;&lt;/a&gt; header is used to indicate the language preference of the user. It is a list of values with quality factors (like: &lt;code&gt;&quot;de, en;q=0.7&lt;/code&gt;&quot;). A default value is often set according the language of the graphical interface of the user agent, but most browsers allow to set different language preferences.</source>
          <target state="translated">在&lt;a href=&quot;headers/accept-language&quot;&gt; &lt;code&gt;Accept-Language&lt;/code&gt; &lt;/a&gt;头用于指示用户的语言首选项。它是具有质量因子的值的列表（例如： &lt;code&gt;&quot;de, en;q=0.7&lt;/code&gt; &amp;rdquo;）。通常会根据用户代理的图形界面的语言设置默认值，但是大多数浏览器允许设置不同的语言首选项。</target>
        </trans-unit>
        <trans-unit id="5e7674c7262d6464316098c5b65d3d21f6faacd3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/access-control-allow-credentials&quot;&gt;&lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt;&lt;/a&gt; header Indicates whether or not the response to the request can be exposed when the &lt;code&gt;credentials&lt;/code&gt; flag is true. When used as part of a response to a preflight request, this indicates whether or not the actual request can be made using credentials. Note that simple &lt;code&gt;GET&lt;/code&gt; requests are not preflighted, and so if a request is made for a resource with credentials, if this header is not returned with the resource, the response is ignored by the browser and not returned to web content.</source>
          <target state="translated">的&lt;a href=&quot;headers/access-control-allow-credentials&quot;&gt; &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; &lt;/a&gt;标头指示是否对所述请求的响应可以在被暴露 &lt;code&gt;credentials&lt;/code&gt; 标记为真。当用作对预检请求的响应的一部分时，这指示是否可以使用凭据发出实际请求。请注意，简单的 &lt;code&gt;GET&lt;/code&gt; 请求不会进行预检，因此，如果对具有凭据的资源进行请求，则如果此标头未随资源一起返回，则浏览器将忽略该响应，并且不会将其返回到Web内容。</target>
        </trans-unit>
        <trans-unit id="fb5022c494946ba6c712c71a1fbc929d4a279c00" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/access-control-allow-headers&quot;&gt;&lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt;&lt;/a&gt; header is used in response to a &lt;a href=&quot;#Preflighted_requests&quot;&gt;preflight request&lt;/a&gt; to indicate which HTTP headers can be used when making the actual request.</source>
          <target state="translated">的&lt;a href=&quot;headers/access-control-allow-headers&quot;&gt; &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; &lt;/a&gt;头是响应用于一个&lt;a href=&quot;#Preflighted_requests&quot;&gt;预检请求&lt;/a&gt;，以指示在进行实际请求时HTTP标头都可以使用。</target>
        </trans-unit>
        <trans-unit id="47e57affccad38127a20bce8c3436539e88c6c38" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/access-control-allow-methods&quot;&gt;&lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt;&lt;/a&gt; header specifies the method or methods allowed when accessing the resource. This is used in response to a preflight request. The conditions under which a request is preflighted are discussed above.</source>
          <target state="translated">的&lt;a href=&quot;headers/access-control-allow-methods&quot;&gt; &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; &lt;/a&gt;头指定访问资源时所允许的一种或多种方法。这用于响应预检请求。上面讨论了请求被预检的条件。</target>
        </trans-unit>
        <trans-unit id="4527c593b9686c403ce7ee6942811c00a0260ae5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/access-control-expose-headers&quot;&gt;&lt;code&gt;Access-Control-Expose-Headers&lt;/code&gt;&lt;/a&gt; header lets a server whitelist headers that Javascript (such as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/getResponseHeader&quot;&gt;&lt;code&gt;getResponseHeader()&lt;/code&gt;&lt;/a&gt;) in browsers are allowed to access.</source>
          <target state="translated">的&lt;a href=&quot;headers/access-control-expose-headers&quot;&gt; &lt;code&gt;Access-Control-Expose-Headers&lt;/code&gt; &lt;/a&gt;头让服务器白名单的标头的Javascript（例如&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/getResponseHeader&quot;&gt; &lt;code&gt;getResponseHeader()&lt;/code&gt; &lt;/a&gt;）在浏览器中被允许访问。</target>
        </trans-unit>
        <trans-unit id="1e7542b9c473bf75e6b574a96c6ca9ae6b946296" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/access-control-expose-headers&quot;&gt;&lt;code&gt;Access-Control-Expose-Headers&lt;/code&gt;&lt;/a&gt; header lets a server whitelist headers that browsers are allowed to access. For example:</source>
          <target state="translated">该&lt;a href=&quot;headers/access-control-expose-headers&quot;&gt; &lt;code&gt;Access-Control-Expose-Headers&lt;/code&gt; &lt;/a&gt;标题允许白名单中的标头的浏览器被允许访问的服务器。例如：</target>
        </trans-unit>
        <trans-unit id="0c96e27b026e07ddc3f2931ff6f47daf2922b214" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/access-control-max-age&quot;&gt;&lt;code&gt;Access-Control-Max-Age&lt;/code&gt;&lt;/a&gt; header indicates how long the results of a preflight request can be cached. For an example of a preflight request, see the above examples.</source>
          <target state="translated">的&lt;a href=&quot;headers/access-control-max-age&quot;&gt; &lt;code&gt;Access-Control-Max-Age&lt;/code&gt; &lt;/a&gt;报头指示多久预检请求的结果可以被缓存。有关预检请求的示例，请参见以上示例。</target>
        </trans-unit>
        <trans-unit id="b00b4f03e257f3dbfb1f8d0d5cf818265cd59e8a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/access-control-request-headers&quot;&gt;&lt;code&gt;Access-Control-Request-Headers&lt;/code&gt;&lt;/a&gt; header is used when issuing a preflight request to let the server know what HTTP headers will be used when the actual request is made.</source>
          <target state="translated">该&lt;a href=&quot;headers/access-control-request-headers&quot;&gt; &lt;code&gt;Access-Control-Request-Headers&lt;/code&gt; &lt;/a&gt;发出预检要求，让服务器知道实际的请求时什么HTTP头的时候会用到头使用。</target>
        </trans-unit>
        <trans-unit id="691c99e3378023d77080d83aad7e1e58d0aa3326" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/access-control-request-method&quot;&gt;&lt;code&gt;Access-Control-Request-Method&lt;/code&gt;&lt;/a&gt; header notifies the server as part of a preflight request that when the actual request is sent, it will be sent with a &lt;code&gt;POST&lt;/code&gt; request method. The &lt;a href=&quot;headers/access-control-request-headers&quot;&gt;&lt;code&gt;Access-Control-Request-Headers&lt;/code&gt;&lt;/a&gt; header notifies the server that when the actual request is sent, it will be sent with a &lt;code&gt;X-PINGOTHER&lt;/code&gt; and &lt;code&gt;Content-Type&lt;/code&gt; custom headers. The server now has an opportunity to determine whether it wishes to accept a request under these circumstances.</source>
          <target state="translated">的&lt;a href=&quot;headers/access-control-request-method&quot;&gt; &lt;code&gt;Access-Control-Request-Method&lt;/code&gt; &lt;/a&gt;报头通知的服务器作为预检请求的一部分被发送的实际请求时，它将被与发送 &lt;code&gt;POST&lt;/code&gt; 请求方法。该&lt;a href=&quot;headers/access-control-request-headers&quot;&gt; &lt;code&gt;Access-Control-Request-Headers&lt;/code&gt; &lt;/a&gt;报头通知服务器，发送的实际请求时，它将被发送的 &lt;code&gt;X-PINGOTHER&lt;/code&gt; 和 &lt;code&gt;Content-Type&lt;/code&gt; 的自定义页眉。服务器现在有机会确定在这种情况下是否希望接受请求。</target>
        </trans-unit>
        <trans-unit id="00e93481fc61267674621b1c977f194bc75b6c9a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/access-control-request-method&quot;&gt;&lt;code&gt;Access-Control-Request-Method&lt;/code&gt;&lt;/a&gt; is used when issuing a preflight request to let the server know what HTTP method will be used when the actual request is made.</source>
          <target state="translated">该&lt;a href=&quot;headers/access-control-request-method&quot;&gt; &lt;code&gt;Access-Control-Request-Method&lt;/code&gt; &lt;/a&gt;发出预检要求，让服务器知道实际的请求时什么HTTP方法将被使用时使用。</target>
        </trans-unit>
        <trans-unit id="7fbe0c67984080abcf5fba23225ff8d88603f4f2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/authorization&quot;&gt;&lt;code&gt;Authorization&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;headers/proxy-authorization&quot;&gt;&lt;code&gt;Proxy-Authorization&lt;/code&gt;&lt;/a&gt; request headers contain the credentials to authenticate a user agent with a (proxy) server. Here, the &lt;code&gt;&amp;lt;type&amp;gt;&lt;/code&gt; is needed again followed by the credentials, which can be encoded or encrypted depending on which authentication scheme is used.</source>
          <target state="translated">的&lt;a href=&quot;headers/authorization&quot;&gt; &lt;code&gt;Authorization&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;headers/proxy-authorization&quot;&gt; &lt;code&gt;Proxy-Authorization&lt;/code&gt; &lt;/a&gt;请求头包含凭证与一个（代理）服务器进行认证的用户代理。在此，再次需要 &lt;code&gt;&amp;lt;type&amp;gt;&lt;/code&gt; 后跟凭据，根据使用的身份验证方案，可以对凭据进行编码或加密。</target>
        </trans-unit>
        <trans-unit id="32735ad57de0b36b9cb875eb26ae77710d7487d1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/authorization&quot;&gt;&lt;code&gt;Authorization&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;headers/proxy-authorization&quot;&gt;&lt;code&gt;Proxy-Authorization&lt;/code&gt;&lt;/a&gt; request headers contain the credentials to authenticate a user agent with a (proxy) server. Here, the type is needed again followed by the credentials, which can be encoded or encrypted depending on which authentication scheme is used.</source>
          <target state="translated">的&lt;a href=&quot;headers/authorization&quot;&gt; &lt;code&gt;Authorization&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;headers/proxy-authorization&quot;&gt; &lt;code&gt;Proxy-Authorization&lt;/code&gt; &lt;/a&gt;请求头包含凭证与一个（代理）服务器进行认证的用户代理。在这里，再次需要类型，其后是凭据，取决于使用哪种身份验证方案，可以对凭据进行编码或加密。</target>
        </trans-unit>
        <trans-unit id="53e54b41889fb412304c339ba63b0b1d28f93d5d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/cache-control&quot;&gt;&lt;code&gt;Cache-Control&lt;/code&gt;&lt;/a&gt; HTTP/1.1 general-header field is used to specify directives for caching mechanisms in both requests and responses. Use this header to define your caching policies with the variety of directives it provides.</source>
          <target state="translated">所述&lt;a href=&quot;headers/cache-control&quot;&gt; &lt;code&gt;Cache-Control&lt;/code&gt; &lt;/a&gt; HTTP / 1.1通用头字段被用于为请求和响应缓存机制指定指令。使用此标头可以使用其提供的各种指令来定义缓存策略。</target>
        </trans-unit>
        <trans-unit id="7095083b873f36d44191b5aa9a6bd5c7f44c8102" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/content-length&quot;&gt;&lt;code&gt;Content-Length&lt;/code&gt;&lt;/a&gt; header now indicates the size of the requested range (and not the full size of the image). The &lt;a href=&quot;headers/content-range&quot;&gt;&lt;code&gt;Content-Range&lt;/code&gt;&lt;/a&gt; response header indicates where in the full resource this partial message belongs.</source>
          <target state="translated">的&lt;a href=&quot;headers/content-length&quot;&gt; &lt;code&gt;Content-Length&lt;/code&gt; &lt;/a&gt;报头现在指示所请求的范围（而不是图像的全尺寸）的尺寸。的&lt;a href=&quot;headers/content-range&quot;&gt; &lt;code&gt;Content-Range&lt;/code&gt; &lt;/a&gt;的响应报头指示，其中在全资源此部分消息所属。</target>
        </trans-unit>
        <trans-unit id="373e10b1138008b081311180730e472ee8b5d4d7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; response header fields allows web site administrators to control resources the user agent is allowed to load for a given page. With a few exceptions, policies mostly involve specifying server origins and script endpoints.</source>
          <target state="translated">在&lt;a href=&quot;headers/content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;响应头字段允许网站管理员能够控制资源的用户代理者被允许负载为一个给定的页面。除少数例外，策略主要涉及指定服务器来源和脚本端点。</target>
        </trans-unit>
        <trans-unit id="b9fe6d801fee6375976ebc4e32f720967639b006" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt; response header is an &lt;em&gt;opaque-to-the-useragent&lt;/em&gt; value that can be used as a strong validator. That means that a HTTP user-agent, such as the browser, does not know what this string represents and can't predict what its value would be. If the &lt;code&gt;ETag&lt;/code&gt; header was part of the response for a resource, the client can issue an &lt;a href=&quot;headers/if-none-match&quot;&gt;&lt;code&gt;If-None-Match&lt;/code&gt;&lt;/a&gt; in the header of future requests &amp;ndash; in order to validate the cached resource.</source>
          <target state="translated">的&lt;a href=&quot;headers/etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; 的&lt;/a&gt;响应报头是&lt;em&gt;不透明到所述-用户代理&lt;/em&gt;可以使用作为强验证值。这意味着HTTP用户代理（例如浏览器）不知道该字符串代表什么，也无法预测其值。如果 &lt;code&gt;ETag&lt;/code&gt; 标头是资源响应的一部分，则客户端可以在未来请求的标头中发出&lt;a href=&quot;headers/if-none-match&quot;&gt; &lt;code&gt;If-None-Match&lt;/code&gt; &lt;/a&gt;，以验证缓存的资源。</target>
        </trans-unit>
        <trans-unit id="cc825b2410b4df4739e11c71f412ef7ef377ba8f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; HTTP header.</source>
          <target state="translated">的&lt;a href=&quot;headers/feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; HTTP标头。</target>
        </trans-unit>
        <trans-unit id="02c9a22613e0a52af16dfd3143868970cb39f043" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/if-range&quot;&gt;&lt;code&gt;If-Range&lt;/code&gt;&lt;/a&gt; HTTP request header makes a range request conditional: if the condition is fulfilled, the range request will be issued and the server sends back a &lt;a href=&quot;status/206&quot;&gt;&lt;code&gt;206&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Partial Content&lt;/code&gt; answer with the appropriate body. If the condition is not fulfilled, the full resource is sent back, with a &lt;a href=&quot;status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt;&lt;code&gt;OK&lt;/code&gt; status. This header can be used either with a &lt;a href=&quot;headers/last-modified&quot;&gt;&lt;code&gt;Last-Modified&lt;/code&gt;&lt;/a&gt; validator, or with an &lt;a href=&quot;headers/etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt;, but not with both.</source>
          <target state="translated">在&lt;a href=&quot;headers/if-range&quot;&gt; &lt;code&gt;If-Range&lt;/code&gt; &lt;/a&gt; HTTP请求头生产一系列要求条件：如果条件满足，范围请求将被发出，服务器发回&lt;a href=&quot;status/206&quot;&gt; &lt;code&gt;206&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Partial Content&lt;/code&gt; 用适当的身体答案。如果不满足该条件，则以&lt;a href=&quot;status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt; &lt;code&gt;OK&lt;/code&gt; 状态发送完整资源。此标头可以与&lt;a href=&quot;headers/last-modified&quot;&gt; &lt;code&gt;Last-Modified&lt;/code&gt; &lt;/a&gt;验证器一起使用，也可以与&lt;a href=&quot;headers/etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt;一起使用，但不能同时使用。</target>
        </trans-unit>
        <trans-unit id="590a84433585d18f20730243da1b6a8953716c09" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/last-modified&quot;&gt;&lt;code&gt;Last-Modified&lt;/code&gt;&lt;/a&gt; response header can be used as a weak validator. It is considered weak because it only has 1-second resolution. If the &lt;code&gt;Last-Modified&lt;/code&gt; header is present in a response, then the client can issue an &lt;a href=&quot;headers/if-modified-since&quot;&gt;&lt;code&gt;If-Modified-Since&lt;/code&gt;&lt;/a&gt; request header to validate the cached document.</source>
          <target state="translated">的&lt;a href=&quot;headers/last-modified&quot;&gt; &lt;code&gt;Last-Modified&lt;/code&gt; &lt;/a&gt;响应头可以用作弱验证器。它被认为是弱的，因为它只有1秒的分辨率。如果响应中存在 &lt;code&gt;Last-Modified&lt;/code&gt; 标头，则客户端可以发出&lt;a href=&quot;headers/if-modified-since&quot;&gt; &lt;code&gt;If-Modified-Since&lt;/code&gt; &lt;/a&gt;请求标头来验证缓存的文档。</target>
        </trans-unit>
        <trans-unit id="9a00311ebb7587989dbe59dcf3d642597bd57cd9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/origin&quot;&gt;&lt;code&gt;Origin&lt;/code&gt;&lt;/a&gt; header indicates the origin of the cross-site access request or preflight request.</source>
          <target state="translated">的&lt;a href=&quot;headers/origin&quot;&gt; &lt;code&gt;Origin&lt;/code&gt; &lt;/a&gt;报头指示的跨站接入请求或预检请求的来源。</target>
        </trans-unit>
        <trans-unit id="00410abbfb65785de4501043b5495b885e06221c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; header also allows you to get multiple ranges at once in a multipart document. The ranges are separated by a comma.</source>
          <target state="translated">该&lt;a href=&quot;headers/range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt;头还可以让你在一次多文档中获得多个范围。范围由逗号分隔。</target>
        </trans-unit>
        <trans-unit id="86f95f2219b451868ec50ea455d93d73adebbf1e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/set-cookie&quot;&gt;&lt;code&gt;Set-Cookie&lt;/code&gt;&lt;/a&gt; HTTP response header sends cookies from the server to the user agent. A simple cookie is set like this:</source>
          <target state="translated">所述&lt;a href=&quot;headers/set-cookie&quot;&gt; &lt;code&gt;Set-Cookie&lt;/code&gt; &lt;/a&gt;的HTTP响应报头从服务器向用户代理发送的cookie。一个简单的cookie设置如下：</target>
        </trans-unit>
        <trans-unit id="af75cb2c0da0fe81a5535d484eb290c4bd4d639e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/transfer-encoding&quot;&gt;&lt;code&gt;Transfer-Encoding&lt;/code&gt;&lt;/a&gt; header allows chunked encoding, which is useful when larger amounts of data are sent to the client and the total size of the response is not known until the request has been fully processed. The server sends data to the client straight away without buffering the response or determining the exact length, which leads to improved latency. Range requests and chunking are compatible and can be used with or without each other.</source>
          <target state="translated">的&lt;a href=&quot;headers/transfer-encoding&quot;&gt; &lt;code&gt;Transfer-Encoding&lt;/code&gt; &lt;/a&gt;头允许分块编码，当大量数据被发送到客户端和响应的总大小是未知的，直到请求已被完全处理，其是有用的。服务器直接将数据发送到客户端，而没有缓冲响应或确定确切的长度，这导致了改进的延迟。范围请求和分块是兼容的，可以相互使用或不相互使用。</target>
        </trans-unit>
        <trans-unit id="b7f353f47a7491fd7a18b5bc1a1b46d2745b86d1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/transfer-encoding&quot;&gt;&lt;code&gt;Transfer-Encoding&lt;/code&gt;&lt;/a&gt; header allows chunked encoding, which useful when larger amounts of data are sent to the client and the total size of the response is not known until the request has been fully processed. The server sends data to the client straight away without buffering the response or determining the exact length, which leads to improved latency. Range requests and chunking are compatible and can be used with or without each other.</source>
          <target state="translated">的&lt;a href=&quot;headers/transfer-encoding&quot;&gt; &lt;code&gt;Transfer-Encoding&lt;/code&gt; &lt;/a&gt;头允许分块编码，这是有用的时候更大量的数据被发送到客户端和响应是未知的，直到请求已被完全处理的总大小。服务器立即将数据发送到客户端，而无需缓冲响应或确定确切的长度，这导致了改进的延迟。范围请求和分块是兼容的，可以相互使用或不相互使用。</target>
        </trans-unit>
        <trans-unit id="427718e5d2f07133480270391026fe30a80122e0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/user-agent&quot;&gt;&lt;code&gt;User-Agent&lt;/code&gt;&lt;/a&gt; header identifies the browser sending the request. This string may contain a space-separated list of &lt;em&gt;product tokens&lt;/em&gt; and &lt;em&gt;comments&lt;/em&gt;.</source>
          <target state="translated">的&lt;a href=&quot;headers/user-agent&quot;&gt; &lt;code&gt;User-Agent&lt;/code&gt; &lt;/a&gt;报头标识浏览器发送请求。该字符串可以包含以空格分隔的&lt;em&gt;产品标记&lt;/em&gt;和&lt;em&gt;注释&lt;/em&gt;列表。</target>
        </trans-unit>
        <trans-unit id="1e0b7713d148829012c4c472ea954c0d5574cc79" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/vary&quot;&gt;&lt;code&gt;Vary&lt;/code&gt;&lt;/a&gt; HTTP response header determines how to match future request headers to decide whether a cached response can be used rather than requesting a fresh one from the origin server.</source>
          <target state="translated">该&lt;a href=&quot;headers/vary&quot;&gt; &lt;code&gt;Vary&lt;/code&gt; &lt;/a&gt; HTTP响应头决定如何满足未来的请求头，以决定一个缓存的响应是否可以使用，而不是请求从源服务器一个新的一个。</target>
        </trans-unit>
        <trans-unit id="b1d4a413436104711d19f9e2f2ce3b22dd6fa9fb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/vary&quot;&gt;&lt;code&gt;Vary&lt;/code&gt;&lt;/a&gt; HTTP response header determines how to match future request headers to decide whether a cached response can be used, or if a fresh one must be requested from the origin server.</source>
          <target state="translated">所述&lt;a href=&quot;headers/vary&quot;&gt; &lt;code&gt;Vary&lt;/code&gt; &lt;/a&gt;HTTP响应报头确定如何匹配未来请求头，以决定一个缓存的响应是否可以使用，或者，如果一个新的一个必须从源服务器来请求。</target>
        </trans-unit>
        <trans-unit id="8f8e8fc45b5f4468eb6609ffd5ad8cb0e64e2e51" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/www-authenticate&quot;&gt;&lt;code&gt;WWW-Authenticate&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;headers/proxy-authenticate&quot;&gt;&lt;code&gt;Proxy-Authenticate&lt;/code&gt;&lt;/a&gt; response headers define the authentication method that should be used to gain access to a resource. They must specify which authentication scheme is used, so that the client that wishes to authorize knows how to provide the credentials.</source>
          <target state="translated">在&lt;a href=&quot;headers/www-authenticate&quot;&gt; &lt;code&gt;WWW-Authenticate&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;headers/proxy-authenticate&quot;&gt; &lt;code&gt;Proxy-Authenticate&lt;/code&gt; &lt;/a&gt;的响应头定义应该被用来访问资源的身份验证方法。他们必须指定使用哪种身份验证方案，以便希望授权的客户端知道如何提供凭据。</target>
        </trans-unit>
        <trans-unit id="a9f41cb2e8943b80c1ccc9757d2185689ead0a50" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/www-authenticate&quot;&gt;&lt;code&gt;WWW-Authenticate&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;headers/proxy-authenticate&quot;&gt;&lt;code&gt;Proxy-Authenticate&lt;/code&gt;&lt;/a&gt; response headers define the authentication method that should be used to gain access to a resource. They need to specify which authentication scheme is used, so that the client that wishes to authorize knows how to provide the credentials. The syntax for these headers is the following:</source>
          <target state="translated">在&lt;a href=&quot;headers/www-authenticate&quot;&gt; &lt;code&gt;WWW-Authenticate&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;headers/proxy-authenticate&quot;&gt; &lt;code&gt;Proxy-Authenticate&lt;/code&gt; &lt;/a&gt;的响应头定义应该被用来访问资源的身份验证方法。他们需要指定使用哪种身份验证方案，以便希望授权的客户端知道如何提供凭据。这些标头的语法如下：</target>
        </trans-unit>
        <trans-unit id="841a5f97046d98851a68c9d87ead02d585e0efda" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;host&quot;&gt;&lt;code&gt;Host&lt;/code&gt;&lt;/a&gt; request header field as received by the proxy.</source>
          <target state="translated">代理收到的&lt;a href=&quot;host&quot;&gt; &lt;code&gt;Host&lt;/code&gt; &lt;/a&gt;请求标头字段。</target>
        </trans-unit>
        <trans-unit id="90ae0d5ac939ab22b89ef22ef6cf0f70a90df9a8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://httpd.apache.org/docs/current/mod/mod_rewrite.html&quot;&gt;mod_rewrite&lt;/a&gt; module can also be used to create redirects. It is more flexible, but a bit more complex to use.</source>
          <target state="translated">该&lt;a href=&quot;http://httpd.apache.org/docs/current/mod/mod_rewrite.html&quot;&gt;mod_rewrite的&lt;/a&gt;模块也可以用来创建重定向。它更灵活，但使用起来有点复杂。</target>
        </trans-unit>
        <trans-unit id="575f2f642c54dbd7133186d28418d1c27eaa5d6f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://www.iana.org/assignments/http-warn-codes/http-warn-codes.xhtml&quot;&gt;HTTP Warn Codes registry at iana.org&lt;/a&gt; defines the namespace for warn codes.</source>
          <target state="translated">&lt;a href=&quot;http://www.iana.org/assignments/http-warn-codes/http-warn-codes.xhtml&quot;&gt;iana.org上&lt;/a&gt;的HTTP警告代码注册表定义了警告代码的名称空间。</target>
        </trans-unit>
        <trans-unit id="8df2d67e805aa2c79e4d6afb765f67e048353741" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://blogs.msdn.microsoft.com/ie/2008/09/02/ie8-security-part-vi-beta-2-update/&quot;&gt;original definition&lt;/a&gt; of X-Content-Type-Options by Microsoft.</source>
          <target state="translated">Microsoft对X-Content-Type-Options 的&lt;a href=&quot;https://blogs.msdn.microsoft.com/ie/2008/09/02/ie8-security-part-vi-beta-2-update/&quot;&gt;原始定义&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b6bb44a38f57a4a24a21a54355c1172f452d3808" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/ALPN&quot;&gt;ALPN&lt;/a&gt; protocol identifier. Examples include h2 for HTTP/2 and h3-25 for draft 25 of the HTTP/3 protocol.</source>
          <target state="translated">所述&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/ALPN&quot;&gt;ALPN&lt;/a&gt;协议标识符。示例包括用于HTTP / 2的h2和用于HTTP / 3协议草案25的h3-25。</target>
        </trans-unit>
        <trans-unit id="303a7ca8e087b00d9976db8accc4e29108a04169" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; request requires preflight, preflighting could not be performed. There are a couple of reasons why preflighting might fail:</source>
          <target state="translated">该&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt;请求需要预检，预检无法进行。进行预检失败的原因有两个：</target>
        </trans-unit>
        <trans-unit id="0ac1bdf745446afae63eab40c6dbfdebac045663" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; request requires that the server permit the use of credentials, but the server's &lt;a href=&quot;../../headers/access-control-allow-credentials&quot;&gt;&lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt;&lt;/a&gt; header's value isn't set to &lt;code&gt;true&lt;/code&gt; to enable their use.</source>
          <target state="translated">该&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt;请求，要求服务器允许使用的凭据，但服务器的&lt;a href=&quot;../../headers/access-control-allow-credentials&quot;&gt; &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; &lt;/a&gt;头的值未设置为 &lt;code&gt;true&lt;/code&gt; ，以使它们的使用。</target>
        </trans-unit>
        <trans-unit id="a3fef220d846f02c9cfee24670814beeba7e7355" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; request was attempted with the credentials flag set, but the server is configured using the wildcard (&lt;code&gt;&quot;*&quot;&lt;/code&gt;) as the value of &lt;a href=&quot;../../headers/access-control-allow-origin&quot;&gt;&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;&lt;/a&gt;, which doesn't allow the use of credentials.</source>
          <target state="translated">尝试使用设置了凭据标志的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt;请求，但是使用通配符（ &lt;code&gt;&quot;*&quot;&lt;/code&gt; ）将服务器配置为&lt;a href=&quot;../../headers/access-control-allow-origin&quot;&gt; &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; &lt;/a&gt;的值，该值不允许使用凭据。</target>
        </trans-unit>
        <trans-unit id="94840953c7f31c8c81ed2848ad9300fdfc9d44eb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; request was responded to by the server with an HTTP redirect to a URL on a different origin than the original request, which is not permitted during CORS requests.</source>
          <target state="translated">的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt;请求用HTTP重定向响应由所述服务器向一个URL上的不同来源比原来的请求，其在CORS请求是不允许的。</target>
        </trans-unit>
        <trans-unit id="46ef7b51d18c11a16b9ea7877d2ee5b389add21e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTTP&quot;&gt;HTTP&lt;/a&gt; request which makes use of CORS failed because the HTTP connection failed at either the network or protocol level. The error is not directly related to CORS, but is a fundamental network error of some kind.</source>
          <target state="translated">使用CORS 的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTTP&quot;&gt;HTTP&lt;/a&gt;请求失败，因为在网络或协议级别上HTTP连接均失败。该错误与CORS不直接相关，而是某种基本的网络错误。</target>
        </trans-unit>
        <trans-unit id="77ebeb340729beee4023ffdb21e08feae0d716a2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Quality_values&quot;&gt;quality value&lt;/a&gt; to apply to that option.</source>
          <target state="translated">适用于该选项的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Quality_values&quot;&gt;质量值&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8ca3dd995c40f4f12da6eea0a0fb62e8d5df0822" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/simple_header&quot;&gt;simple headers&lt;/a&gt;, &lt;a href=&quot;accept&quot;&gt;&lt;code&gt;Accept&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;accept-language&quot;&gt;&lt;code&gt;Accept-Language&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;content-language&quot;&gt;&lt;code&gt;Content-Language&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; (but only with a MIME type of its parsed value (ignoring parameters) of either &lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt;, &lt;code&gt;multipart/form-data&lt;/code&gt;, or &lt;code&gt;text/plain&lt;/code&gt;), are always available and don't need to be listed by this header.</source>
          <target state="translated">的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/simple_header&quot;&gt;简单标头&lt;/a&gt;，&lt;a href=&quot;accept&quot;&gt; &lt;code&gt;Accept&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;accept-language&quot;&gt; &lt;code&gt;Accept-Language&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;content-language&quot;&gt; &lt;code&gt;Content-Language&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt;之一（但仅与一个MIME类型其解析后的值（忽略参数） &lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt; ， &lt;code&gt;multipart/form-data&lt;/code&gt; ，或 &lt;code&gt;text/plain&lt;/code&gt; ），始终可用，不需要在此标头中列出。</target>
        </trans-unit>
        <trans-unit id="7c8c624b902acbdfb33352d81eeb9f16044ff38e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;user agent&lt;/a&gt; was unable to add the required &lt;a href=&quot;../../headers/origin&quot;&gt;&lt;code&gt;Origin&lt;/code&gt;&lt;/a&gt; header to the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTTP&quot;&gt;HTTP&lt;/a&gt; request. All CORS requests must have an &lt;code&gt;Origin&lt;/code&gt; header.</source>
          <target state="translated">所述&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;用户代理&lt;/a&gt;无法所需添加&lt;a href=&quot;../../headers/origin&quot;&gt; &lt;code&gt;Origin&lt;/code&gt; &lt;/a&gt;标头添加到&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTTP&quot;&gt;HTTP&lt;/a&gt;请求。所有CORS请求都必须具有 &lt;code&gt;Origin&lt;/code&gt; 头。</target>
        </trans-unit>
        <trans-unit id="541849bca8dfcb4810abe650d5548422c6848655" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/FormData&quot;&gt;&lt;code&gt;FormData&lt;/code&gt;&lt;/a&gt; interface used to manipulate form data for use in the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt; API.</source>
          <target state="translated">所述&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/FormData&quot;&gt; &lt;code&gt;FormData&lt;/code&gt; &lt;/a&gt;接口用于操纵形式数据用于在使用中&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; &lt;/a&gt; API。</target>
        </trans-unit>
        <trans-unit id="7537c29a754763b348491b7f0dbd96e605a4a484" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Reporting_API&quot;&gt;reporting API&lt;/a&gt; group to send network error reports to (see below).</source>
          <target state="translated">该&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Reporting_API&quot;&gt;报告API&lt;/a&gt;群发网络错误报告（见下文）。</target>
        </trans-unit>
        <trans-unit id="315a779e6acad1d531dd53b54135b697e3e3e7ed" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/WebSocket&quot;&gt;&lt;code&gt;WebSocket()&lt;/code&gt;&lt;/a&gt; constructor does all the work of creating an initial HTTP/1.1 connection then handling the handshaking and upgrade process for you.</source>
          <target state="translated">该&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/WebSocket&quot;&gt; &lt;code&gt;WebSocket()&lt;/code&gt; &lt;/a&gt;构造函数都创建一个初始的HTTP / 1.1连接，然后处理握手和升级过程中为你的工作。</target>
        </trans-unit>
        <trans-unit id="d45717eba61ad3d5a426950cb644c8f2dd47e3a7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebVR_API&quot;&gt;WebVR API&lt;/a&gt; has been replced with the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebXR_API&quot;&gt;WebXR Device API&lt;/a&gt; and is currently being removed from the web platform. Use the feature identifier &lt;a href=&quot;xr-spatial-tracking&quot;&gt;&lt;code&gt;xr-spatial-tracking&lt;/code&gt;&lt;/a&gt; for WebXR Device API instead.</source>
          <target state="translated">该&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebVR_API&quot;&gt;WebVR API&lt;/a&gt;已经replced与&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebXR_API&quot;&gt;WebXR设备API&lt;/a&gt;，目前正在从网络平台中删除。请改用WebXR设备API的功能标识符&lt;a href=&quot;xr-spatial-tracking&quot;&gt; &lt;code&gt;xr-spatial-tracking&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b3d572fbbc7fb5223d172c4f660df4f67fd67a10" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#Attributes&quot;&gt;&lt;code&gt;allow&lt;/code&gt;&lt;/a&gt; attribute on iframes.</source>
          <target state="translated">iframe上的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#Attributes&quot;&gt; &lt;code&gt;allow&lt;/code&gt; &lt;/a&gt;属性。</target>
        </trans-unit>
        <trans-unit id="41b2d8d87680fc3732f8e6149116b853f67342a3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#Attributes&quot;&gt;allow&lt;/a&gt; attribute on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt;上的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#Attributes&quot;&gt;allow&lt;/a&gt;属性。</target>
        </trans-unit>
        <trans-unit id="81c151e97bb2fc9016b004646d1163e360980269" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-CH-Lifetime&quot;&gt;&lt;code&gt;Accept-CH-Lifetime&lt;/code&gt;&lt;/a&gt; header is used with the &lt;code&gt;Device-Memory&lt;/code&gt; value of the &lt;code&gt;Accept-CH&lt;/code&gt; header and indicates the amount of time the device should opt-in to sharing the amount of device memory with the server. The value is given in miliseconds and it's use is optional.</source>
          <target state="translated">所述&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-CH-Lifetime&quot;&gt; &lt;code&gt;Accept-CH-Lifetime&lt;/code&gt; &lt;/a&gt;头用于与 &lt;code&gt;Device-Memory&lt;/code&gt; 在的值 &lt;code&gt;Accept-CH&lt;/code&gt; 头和表示时间的设备应该选择加入与服务器共享装置存储器的量的量。该值以毫秒为单位给出，它的使用是可选的。</target>
        </trans-unit>
        <trans-unit id="feae0b21dc6047c955761cda1dd45a586e339677" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt; header field is used by clients to invite the server to switch to one of the listed protocols, in descending preference order.</source>
          <target state="translated">客户端使用&amp;ldquo;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt; &lt;code&gt;Upgrade&lt;/code&gt; &lt;/a&gt;头&amp;rdquo;字段邀请服务器以优先级降序顺序切换到所列协议之一。</target>
        </trans-unit>
        <trans-unit id="102f0a3635d954f2ea429dc9612327a656cc4b1f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Media/Formats/Audio_codecs&quot;&gt;audio codec&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Media/Formats/Video_codecs&quot;&gt;video codec&lt;/a&gt; guides list the various codecs that web browsers often support, providing compatibility details along with technical information such as how many audio channels they support, what sort of compression is used, and what bit rates and so forth they're useful at. The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Media/Formats/WebRTC_codecs&quot;&gt;codecs used by WebRTC&lt;/a&gt; guide expands upon this by specifically covering the codecs supported by the major web browsers, so you can choose the codecs that best cover the range of browsers you wish to support.</source>
          <target state="translated">该&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Media/Formats/Audio_codecs&quot;&gt;音频编解码器&lt;/a&gt;和&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Media/Formats/Video_codecs&quot;&gt;视频编解码器&lt;/a&gt;指南列出了各种编解码器，网页浏览器通常支持，技术资料以及提供兼容性的详细信息，如他们支持多少个音频通道，什么样的压缩的使用，以及什么比特率等他们有用的。&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Media/Formats/WebRTC_codecs&quot;&gt;WebRTC&lt;/a&gt;指南使用的编解码器在此基础上进行了扩展，专门涵盖了主要Web浏览器支持的编解码器，因此您可以选择最能覆盖您希望支持的浏览器范围的编解码器。</target>
        </trans-unit>
        <trans-unit id="bbd12c73f76eeadd9f5a8a7c267e1d8bb10451c5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en/HTTP&quot;&gt;HTTP protocol&lt;/a&gt; provides a special mechanism allowing an already established connection to upgrade to a new, incompatible, protocol. This guide covers how this works and offers examples of scenarios in which it's used.</source>
          <target state="translated">在&lt;a href=&quot;https://developer.mozilla.org/en/HTTP&quot;&gt;HTTP协议&lt;/a&gt;提供了一个特殊机制，使已建立的连接升级到一个新的，不兼容，协议。本指南介绍了它的工作原理，并提供了使用它的场景示例。</target>
        </trans-unit>
        <trans-unit id="56487f351a83f4ece995635d28e031bb9e971d36" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://fetch.spec.whatwg.org/#cross-origin-resource-policy-header&quot;&gt;Cross-Origin-Resource-Policy&lt;/a&gt; header prevents other domains from loading the resources.</source>
          <target state="translated">所述&lt;a href=&quot;https://fetch.spec.whatwg.org/#cross-origin-resource-policy-header&quot;&gt;跨源资源策略&lt;/a&gt;头阻止加载资源其他领域。</target>
        </trans-unit>
        <trans-unit id="30ff7cff75928c0f981ddbe781c5a37e5b8ec7ad" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://httpd.apache.org/docs/current/mod/mod_alias.html&quot;&gt;mod_alias&lt;/a&gt; module has &lt;code&gt;Redirect&lt;/code&gt; and &lt;code&gt;RedirectMatch&lt;/code&gt; directives that set up a &lt;a href=&quot;status/302&quot;&gt;&lt;code&gt;302&lt;/code&gt;&lt;/a&gt; response (by default):</source>
          <target state="translated">所述&lt;a href=&quot;https://httpd.apache.org/docs/current/mod/mod_alias.html&quot;&gt;mod_alias中&lt;/a&gt;模块具有 &lt;code&gt;Redirect&lt;/code&gt; 和 &lt;code&gt;RedirectMatch&lt;/code&gt; 指令，它们设置一个&lt;a href=&quot;status/302&quot;&gt; &lt;code&gt;302&lt;/code&gt; &lt;/a&gt;响应（默认）：</target>
        </trans-unit>
        <trans-unit id="dfdf1721b0f5a67b62cb197634da7d5057e2041b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://observatory.mozilla.org/&quot;&gt;Mozilla Observatory&lt;/a&gt; tool testing the configuration (including this header) of Web sites for safety and security</source>
          <target state="translated">在&lt;a href=&quot;https://observatory.mozilla.org/&quot;&gt;Mozilla的观测&lt;/a&gt;工具测试网站的配置（包括这头）的安全和安保</target>
        </trans-unit>
        <trans-unit id="b0c2f791ad88a8a7e38ea528eb0f0ccd9df436bb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://tools.ietf.org/html/rfc4648#section-5&quot;&gt;base64url&lt;/a&gt; format is not the same as standard Base64 encoding. This is almost but not quite the same as standard Base64. The only difference: in order to ensure that the resulting string is safe for use in both URLs and filenames, the 62nd and 63rd characters in its alphabet are changed from &lt;code&gt;&quot;+&quot;&lt;/code&gt; and &lt;code&gt;&quot;/&quot;&lt;/code&gt; to &lt;code&gt;&quot;-&quot;&lt;/code&gt; (minus) and &lt;code&gt;&quot;_&quot;&lt;/code&gt; (underscore), respectively.</source>
          <target state="translated">所述&lt;a href=&quot;https://tools.ietf.org/html/rfc4648#section-5&quot;&gt;base64url&lt;/a&gt;格式是不一样的标准Base64编码。这几乎与标准Base64几乎相同，但并不完全相同。唯一的区别：为了确保生成的字符串可以安全地在URL和文件名中使用，将其字母中的第62和63个字符从 &lt;code&gt;&quot;+&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;/&quot;&lt;/code&gt; 更改为 &lt;code&gt;&quot;-&quot;&lt;/code&gt; （减号）和 &lt;code&gt;&quot;_&quot;&lt;/code&gt; （下划线）。</target>
        </trans-unit>
        <trans-unit id="e864176c816370410ca7b511fa51ea0441aec0c3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://www.iana.org/&quot;&gt;Internet Assigned Numbers Authority (IANA)&lt;/a&gt; is responsible for all official MIME types, and you can find the most up-to-date and complete list at their &lt;a href=&quot;https://www.iana.org/assignments/media-types/media-types.xhtml&quot;&gt;Media Types&lt;/a&gt; page.</source>
          <target state="translated">在&lt;a href=&quot;https://www.iana.org/&quot;&gt;互联网编号分配机构（IANA）&lt;/a&gt;负责所有官方和MIME类型，你可以找到他们的最先进的最新和完整列表&lt;a href=&quot;https://www.iana.org/assignments/media-types/media-types.xhtml&quot;&gt;媒体类型&lt;/a&gt;页。</target>
        </trans-unit>
        <trans-unit id="7e5161e796ede3d041d86dc6f2b70145c4f74bc4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://www.iana.org/assignments/http-warn-codes/http-warn-codes.xhtml&quot;&gt;HTTP Warn Codes registry at iana.org&lt;/a&gt; defines the namespace for warn codes.</source>
          <target state="translated">&lt;a href=&quot;https://www.iana.org/assignments/http-warn-codes/http-warn-codes.xhtml&quot;&gt;iana.org上&lt;/a&gt;的HTTP警告代码注册表定义了警告代码的名称空间。</target>
        </trans-unit>
        <trans-unit id="a0ea81494b8105f6717337ab7d95f01a45c084f2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;index&quot;&gt;HTTP/1.1 protocol&lt;/a&gt; provides a special mechanism that can be used to upgrade an already established connection to a different protocol, using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt; header field.</source>
          <target state="translated">的&lt;a href=&quot;index&quot;&gt;HTTP / 1.1协议&lt;/a&gt;提供了可用于升级到一个不同的协议的已建立的连接，采用一种特殊的机制&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt; &lt;code&gt;Upgrade&lt;/code&gt; &lt;/a&gt;头字段。</target>
        </trans-unit>
        <trans-unit id="8ab5fee31c8ccbebe1e49d2cda4be11eb9064dcd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; method requests a data representation of the specified resource. Requests using &lt;code&gt;GET&lt;/code&gt; should only retrieve data.</source>
          <target state="translated">该&lt;a href=&quot;methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;方法请求指定资源的数据表示。使用 &lt;code&gt;GET&lt;/code&gt; 的请求应仅检索数据。</target>
        </trans-unit>
        <trans-unit id="85676b7109bc7c3348572fe11d463aa4452c7f6e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; method sends data to a server so it may change its state. This is the method often used for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Forms&quot;&gt;HTML Forms&lt;/a&gt;.</source>
          <target state="translated">该&lt;a href=&quot;methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt;方法将数据发送到服务器，以便它可以改变其状态。这是&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Forms&quot;&gt;HTML表单&lt;/a&gt;常用的方法。</target>
        </trans-unit>
        <trans-unit id="759d2232e34b1fccdd6a4688d236906067716e48" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;referer&quot;&gt;&lt;code&gt;Referer&lt;/code&gt;&lt;/a&gt; header will be omitted entirely. No referrer information is sent along with requests.</source>
          <target state="translated">所述&lt;a href=&quot;referer&quot;&gt; &lt;code&gt;Referer&lt;/code&gt; &lt;/a&gt;头将被完全省略。没有引荐来源信息随请求一起发送。</target>
        </trans-unit>
        <trans-unit id="bb80c4be8693337fa70be2fe31fd2c4154708a28" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;status/101&quot;&gt;&lt;code&gt;101&lt;/code&gt;&lt;/a&gt; status code is sent as a response to a request including the &lt;code&gt;&quot;Upgrade&quot;&lt;/code&gt; header to signal that the recipient of the request is willing to upgrade to one of the desired protocols. If the &lt;code&gt;&quot;101 Switching Protocols&quot;&lt;/code&gt; status code is returned, the header must also include the &lt;code&gt;Connection&lt;/code&gt; and &lt;code&gt;Upgrade&lt;/code&gt; headers to describe the chosen protocol. See the examples in &lt;a href=&quot;#Common_uses_for_this_mechanism&quot;&gt;Common uses for this mechanism&lt;/a&gt; to learn more about how this works.</source>
          <target state="translated">在&lt;a href=&quot;status/101&quot;&gt; &lt;code&gt;101&lt;/code&gt; 个&lt;/a&gt;状态代码被发送作为包括该请求的响应 &lt;code&gt;&quot;Upgrade&quot;&lt;/code&gt; 头发信号通知请求的接收方愿意升级到所期望的协议之一。如果返回 &lt;code&gt;&quot;101 Switching Protocols&quot;&lt;/code&gt; 状态代码，则标头还必须包括&amp;ldquo; &lt;code&gt;Connection&lt;/code&gt; 和&amp;ldquo; &lt;code&gt;Upgrade&lt;/code&gt; 标头，以描述所选协议。请参阅&lt;a href=&quot;#Common_uses_for_this_mechanism&quot;&gt;此机制的常用用法中&lt;/a&gt;的示例，以了解有关其工作原理的更多信息。</target>
        </trans-unit>
        <trans-unit id="ba7765f4a93430d93893449738d810f79adab493" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;status/300&quot;&gt;&lt;code&gt;300&lt;/code&gt;&lt;/a&gt; (Multiple Choices) or &lt;a href=&quot;status/406&quot;&gt;&lt;code&gt;406&lt;/code&gt;&lt;/a&gt; (Not Acceptable) &lt;a href=&quot;status&quot;&gt;HTTP response codes&lt;/a&gt; by the server (&lt;em&gt;agent-driven negotiation&lt;/em&gt; or &lt;em&gt;reactive negotiation&lt;/em&gt;), that are used as fallback mechanisms.</source>
          <target state="translated">服务器的&lt;a href=&quot;status/300&quot;&gt; &lt;code&gt;300&lt;/code&gt; &lt;/a&gt;（多项选择）或&lt;a href=&quot;status/406&quot;&gt; &lt;code&gt;406&lt;/code&gt; &lt;/a&gt;（不可接受）&lt;a href=&quot;status&quot;&gt;HTTP响应代码&lt;/a&gt;（&lt;em&gt;代理驱动的协商&lt;/em&gt;或&lt;em&gt;反应式协商&lt;/em&gt;），用作回退机制。</target>
        </trans-unit>
        <trans-unit id="7a2ea4621d5db4a0643b172c60b9729d03740461" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;status/300&quot;&gt;&lt;code&gt;300&lt;/code&gt;&lt;/a&gt; (Multiple Choices) or &lt;a href=&quot;status/406&quot;&gt;&lt;code&gt;406&lt;/code&gt;&lt;/a&gt; (Not Acceptable), &lt;a href=&quot;status/415&quot;&gt;&lt;code&gt;415&lt;/code&gt;&lt;/a&gt; (Unsupported Media Type) &lt;a href=&quot;status&quot;&gt;HTTP response codes&lt;/a&gt; by the server (&lt;em&gt;agent-driven negotiation&lt;/em&gt; or &lt;em&gt;reactive negotiation&lt;/em&gt;), that are used as fallback mechanisms.</source>
          <target state="translated">服务器的&lt;a href=&quot;status/300&quot;&gt; &lt;code&gt;300&lt;/code&gt; &lt;/a&gt;（多项选择）或&lt;a href=&quot;status/406&quot;&gt; &lt;code&gt;406&lt;/code&gt; &lt;/a&gt;（不可接受），&lt;a href=&quot;status/415&quot;&gt; &lt;code&gt;415&lt;/code&gt; &lt;/a&gt;（不受支持的媒体类型）&lt;a href=&quot;status&quot;&gt;HTTP响应代码&lt;/a&gt;（&lt;em&gt;代理驱动的协商&lt;/em&gt;或&lt;em&gt;反应性协商&lt;/em&gt;），用作回退机制。</target>
        </trans-unit>
        <trans-unit id="fdc1524f620c113ef489962d737efb33b27f2eac" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;te&quot;&gt;&lt;code&gt;TE&lt;/code&gt;&lt;/a&gt; request header needs to be set to &quot;trailers&quot; to allow trailer fields.</source>
          <target state="translated">需要将&lt;a href=&quot;te&quot;&gt; &lt;code&gt;TE&lt;/code&gt; &lt;/a&gt;请求标头设置为&amp;ldquo;预告片&amp;rdquo;以允许预告片字段。</target>
        </trans-unit>
        <trans-unit id="106d3051b32652488ca1792a9b8e10220f0e7a85" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;upgrade-insecure-requests&quot;&gt;&lt;code&gt;upgrade-insecure-requests&lt;/code&gt;&lt;/a&gt; directive is evaluated before &lt;code&gt;block-all-mixed-content&lt;/code&gt; and If the former is set, the latter is effectively a no-op. It is recommended to set one directive or the other &amp;ndash; not both, unless you want to force HTTPS on older browsers that do not force it after a redirect to HTTP.</source>
          <target state="translated">该&lt;a href=&quot;upgrade-insecure-requests&quot;&gt; &lt;code&gt;upgrade-insecure-requests&lt;/code&gt; &lt;/a&gt;之前指令评估 &lt;code&gt;block-all-mixed-content&lt;/code&gt; 和如果是前者设置，后者实际上是一个无操作。建议设置一个指令或另一个指令，而不要同时设置两个指令，除非您想在较旧的浏览器上强制使用HTTPS，而在重定向到HTTP之后不强制使用该浏览器。</target>
        </trans-unit>
        <trans-unit id="5a51eef50de25b01cedd4928f3f99c9fae3d5200" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;upgrade-insecure-requests&quot;&gt;&lt;code&gt;upgrade-insecure-requests&lt;/code&gt;&lt;/a&gt; directive is evaluated before &lt;code&gt;block-all-mixed-content&lt;/code&gt;. If the former is set, the latter does nothing, so set one directive or the other &amp;ndash; not both, unless you want to force HTTPS on older browsers that do not force it after a redirect to HTTP.</source>
          <target state="translated">该&lt;a href=&quot;upgrade-insecure-requests&quot;&gt; &lt;code&gt;upgrade-insecure-requests&lt;/code&gt; &lt;/a&gt;之前指令评估 &lt;code&gt;block-all-mixed-content&lt;/code&gt; 。如果设置了前者，则后者不执行任何操作，因此，请设置一个指令或另一个指令，而不要同时设置两个指令，除非您希望在较旧的浏览器上强制使用HTTPS，而在重定向到HTTP之后不强制使用它。</target>
        </trans-unit>
        <trans-unit id="0f16849e96b723097d3105369f7d2ec73a2c9b25" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;vary&quot;&gt;&lt;code&gt;Vary&lt;/code&gt;&lt;/a&gt; header ensures that the content is cached properly (for instance ensuring that the user is not served a lower-quality image from the cache when &lt;code&gt;Save-Data&lt;/code&gt; header is no longer present [&lt;em&gt;e.g.&lt;/em&gt; after having switched from cellular to Wi-Fi]).</source>
          <target state="translated">所述&lt;a href=&quot;vary&quot;&gt; &lt;code&gt;Vary&lt;/code&gt; &lt;/a&gt;头确保内容被适当地高速缓存（例如确保当用户没有提供从高速缓存低质量的图像 &lt;code&gt;Save-Data&lt;/code&gt; 报头不再存在[&lt;em&gt;例如&lt;/em&gt;来自蜂窝具有切换到Wi-Fi之后]） 。</target>
        </trans-unit>
        <trans-unit id="ce5a0a42af328d6549a6884a0d4203b5b8180652" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;'src'&lt;/code&gt; origin is used in the iframe &lt;code&gt;allow&lt;/code&gt; attribute only, and is the &lt;em&gt;default&lt;/em&gt;&lt;code&gt;allowlist&lt;/code&gt; value.</source>
          <target state="translated">该 &lt;code&gt;'src'&lt;/code&gt; 原点在iframe使用 &lt;code&gt;allow&lt;/code&gt; 唯一属性，并且是&lt;em&gt;默认&lt;/em&gt; &lt;code&gt;allowlist&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="a1e69a4edf06fe574fa80e88285f8fb7d88da970" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;'strict-dynamic'&lt;/code&gt; source expression specifies that the trust explicitly given to a script present in the markup, by accompanying it with a nonce or a hash, shall be propagated to all the scripts loaded by that root script. At the same time, any whitelist or source expressions such as &lt;code&gt;'self'&lt;/code&gt; or &lt;code&gt;'unsafe-inline'&lt;/code&gt; will be ignored. For example, a policy such as &lt;code&gt;script-src 'strict-dynamic' 'nonce-R4nd0m' https://whitelisted.com/&lt;/code&gt; would allow loading of a root script with &lt;code&gt;&amp;lt;script nonce=&quot;R4nd0m&quot; src=&quot;https://example.com/loader.js&quot;&amp;gt;&lt;/code&gt; and propagate that trust to any script loaded by &lt;code&gt;loader.js&lt;/code&gt;, but disallow loading scripts from &lt;code&gt;https://whitelisted.com/&lt;/code&gt; unless accompanied by a nonce or loaded from a trusted script.</source>
          <target state="translated">所述 &lt;code&gt;'strict-dynamic'&lt;/code&gt; 源表达式指定的信任明确给出与存在于标记的脚本，通过用随机数或散列伴随它，应当被传播到所有由根脚本加载的脚本。同时，所有白名单或源表达式（例如 &lt;code&gt;'self'&lt;/code&gt; 或 &lt;code&gt;'unsafe-inline'&lt;/code&gt; 都将被忽略。例如，诸如 &lt;code&gt;script-src 'strict-dynamic' 'nonce-R4nd0m' https://whitelisted.com/&lt;/code&gt; 将允许使用 &lt;code&gt;&amp;lt;script nonce=&quot;R4nd0m&quot; src=&quot;https://example.com/loader.js&quot;&amp;gt;&lt;/code&gt; 加载根脚本example.com/loader.js&amp;ldquo;&amp;gt;并将信任关系传播到 &lt;code&gt;loader.js&lt;/code&gt; 加载的任何脚本，但不允许从 &lt;code&gt;https://whitelisted.com/&lt;/code&gt; 加载脚本：//whitelisted.com/除非伴随有随机数或从受信任的脚本加载。</target>
        </trans-unit>
        <trans-unit id="b021b3c1d64f7dedfd2f1fd076264572ee155ed2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;'strict-dynamic&lt;/code&gt;' source expression specifies that the trust explicitly given to a script present in the markup, by accompanying it with a nonce or a hash, shall be propagated to all the scripts loaded by that root script. At the same time, any whitelist or source expressions such as &lt;code&gt;'self'&lt;/code&gt; or &lt;code&gt;'unsafe-inline'&lt;/code&gt; will be ignored. For example, a policy such as &lt;code&gt;script-src 'strict-dynamic' 'nonce-R4nd0m' https://whitelisted.com/&lt;/code&gt; would allow loading of a root script with &lt;code&gt;&amp;lt;script nonce=&quot;R4nd0m&quot; src=&quot;https://example.com/loader.js&quot;&amp;gt;&lt;/code&gt; and propagate that trust to any script loaded by &lt;code&gt;loader.js&lt;/code&gt;, but disallow loading scripts from &lt;code&gt;https://whitelisted.com/&lt;/code&gt; unless accompanied by a nonce or loaded from a trusted script.</source>
          <target state="translated">所述 &lt;code&gt;'strict-dynamic&lt;/code&gt; '源表达式指定的信任明确给出与存在于标记的脚本，通过用随机数或散列伴随它，应当被传播到所有由根脚本加载的脚本。同时，所有白名单或源表达式（例如 &lt;code&gt;'self'&lt;/code&gt; 或 &lt;code&gt;'unsafe-inline'&lt;/code&gt; 都将被忽略。例如，诸如 &lt;code&gt;script-src 'strict-dynamic' 'nonce-R4nd0m' https://whitelisted.com/&lt;/code&gt; 将允许使用 &lt;code&gt;&amp;lt;script nonce=&quot;R4nd0m&quot; src=&quot;https://example.com/loader.js&quot;&amp;gt;&lt;/code&gt; 加载根脚本example.com/loader.js&amp;ldquo;&amp;gt;并将信任关系传播到 &lt;code&gt;loader.js&lt;/code&gt; 加载的任何脚本，但不允许从 &lt;code&gt;https://whitelisted.com/&lt;/code&gt; 加载脚本：//whitelisted.com/ 除非伴随有随机数或从受信任的脚本加载。</target>
        </trans-unit>
        <trans-unit id="6382e529a182503f39a7f7388e99ab1653c33241" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;'unsafe-eval'&lt;/code&gt; source expression controls several script execution methods that create code from strings. If &lt;code&gt;'unsafe-eval'&lt;/code&gt; isn't specified with the &lt;code&gt;script-src&lt;/code&gt; directive, the following methods are blocked and won't have any effect:</source>
          <target state="translated">的 &lt;code&gt;'unsafe-eval'&lt;/code&gt; 源表达控件创建从串代码几个脚本执行方法。如果未使用 &lt;code&gt;script-src&lt;/code&gt; 指令指定 &lt;code&gt;'unsafe-eval'&lt;/code&gt; ，则以下方法将被阻止，并且将无效：</target>
        </trans-unit>
        <trans-unit id="7a974fff323538cd623f076264d18fe2300bde8a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;'unsafe-eval'&lt;/code&gt; source expression controls several style methods that create style declarations from strings. If &lt;code&gt;'unsafe-eval'&lt;/code&gt; isn't specified with the &lt;code&gt;style-src&lt;/code&gt; directive, the following methods are blocked and won't have any effect:</source>
          <target state="translated">在 &lt;code&gt;'unsafe-eval'&lt;/code&gt; 源表达控件创建的字符串样式声明几个样式的方法。如果未使用 &lt;code&gt;style-src&lt;/code&gt; 指令指定 &lt;code&gt;'unsafe-eval'&lt;/code&gt; ，则以下方法将被阻止，并且将不起作用：</target>
        </trans-unit>
        <trans-unit id="c3028d259a6399103c9ce4edc7dfac31909edc67" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.htaccess&lt;/code&gt; file references a &lt;code&gt;.htpasswd&lt;/code&gt; file in which each line consists of a username and a password separated by a colon (&lt;code&gt;:&lt;/code&gt;). You cannot see the actual passwords as they are &lt;a href=&quot;https://httpd.apache.org/docs/2.4/misc/password_encryptions.html&quot;&gt;hashed&lt;/a&gt; (using MD5-based hashing, in this case). Note that you can name your &lt;code&gt;.htpasswd&lt;/code&gt; file differently if you like, but keep in mind this file shouldn't be accessible to anyone. (Apache is usually configured to prevent access to &lt;code&gt;.ht*&lt;/code&gt; files).</source>
          <target state="translated">的 &lt;code&gt;.htaccess&lt;/code&gt; 文件引用一个 &lt;code&gt;.htpasswd&lt;/code&gt; 文件，其中的每一行由一个用户名和由冒号分隔口令（ &lt;code&gt;:&lt;/code&gt; ）。您无法看到实际的密码，因为它们是经过&lt;a href=&quot;https://httpd.apache.org/docs/2.4/misc/password_encryptions.html&quot;&gt;哈希处理的&lt;/a&gt;（在这种情况下，使用基于MD5的哈希）。请注意，您可以根据需要将 &lt;code&gt;.htpasswd&lt;/code&gt; 文件命名为其他名称，但请记住，任何人都不能访问该文件。 （通常将Apache配置为阻止访问 &lt;code&gt;.ht*&lt;/code&gt; 文件）。</target>
        </trans-unit>
        <trans-unit id="f7d8d01c839e9d424312b47d646a614086c80cdd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.htaccess&lt;/code&gt; file references a &lt;code&gt;.htpasswd&lt;/code&gt; file in which each line contains of a username and a password separated by a colon (&quot;:&quot;). You can not see the actual passwords as they are &lt;a href=&quot;https://httpd.apache.org/docs/2.4/misc/password_encryptions.html&quot;&gt;encrypted&lt;/a&gt; (md5 in this case). Note that you can name your &lt;code&gt;.htpasswd&lt;/code&gt; file differently if you like, but keep in mind this file shouldn't be accessible to anyone. (Apache is usually configured to prevent access to &lt;code&gt;.ht*&lt;/code&gt; files).</source>
          <target state="translated">的 &lt;code&gt;.htaccess&lt;/code&gt; 文件引用一个 &lt;code&gt;.htpasswd&lt;/code&gt; 文件，其中每一行包含一个用户名和密码分离由冒号（&amp;ldquo;：&amp;rdquo;）。您看不到实际的密码，因为它们已&lt;a href=&quot;https://httpd.apache.org/docs/2.4/misc/password_encryptions.html&quot;&gt;加密&lt;/a&gt;（在这种情况下为md5）。请注意，您可以根据需要将 &lt;code&gt;.htpasswd&lt;/code&gt; 文件命名为其他名称，但是请记住，任何人都不能访问该文件。（通常将Apache配置为阻止访问 &lt;code&gt;.ht*&lt;/code&gt; 文件）。</target>
        </trans-unit>
        <trans-unit id="01ea6c155e3bff628716e111f394e3a0636ae28e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.htaccess&lt;/code&gt; file typically looks like this:</source>
          <target state="translated">在 &lt;code&gt;.htaccess&lt;/code&gt; 文件通常是这样的：</target>
        </trans-unit>
        <trans-unit id="4140f45978733db50c0722e19703d0dd8732110c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;203&lt;/code&gt; response is similar to the value &lt;code&gt;&lt;a href=&quot;../headers/warning#Warning_codes&quot;&gt;214&lt;/a&gt;&lt;/code&gt;, meaning &lt;code&gt;Transformation Applied&lt;/code&gt;, of the &lt;a href=&quot;../headers/warning&quot;&gt;&lt;code&gt;Warning&lt;/code&gt;&lt;/a&gt; header code, which has the additional advantage of being applicable to responses with any status code.</source>
          <target state="translated">所述 &lt;code&gt;203&lt;/code&gt; 响应是类似的值 &lt;code&gt;&lt;a href=&quot;../headers/warning#Warning_codes&quot;&gt;214&lt;/a&gt;&lt;/code&gt; ，这意味着 &lt;code&gt;Transformation Applied&lt;/code&gt; ，所述的&lt;a href=&quot;../headers/warning&quot;&gt; &lt;code&gt;Warning&lt;/code&gt; &lt;/a&gt;标题代码，其具有可应用于与任何状态码的响应的附加优点。</target>
        </trans-unit>
        <trans-unit id="fd1e39721a458a8f43a8fa40e465369253ea6854" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;416&lt;/code&gt; response message contains a &lt;a href=&quot;../headers/content-range&quot;&gt;&lt;code&gt;Content-Range&lt;/code&gt;&lt;/a&gt; indicating an unsatisfied range (that is a &lt;code&gt;'*'&lt;/code&gt;) followed by a &lt;code&gt;'/'&lt;/code&gt; and the current length of the resource. E.g. &lt;code&gt;Content-Range: */12777&lt;/code&gt;</source>
          <target state="translated">所述 &lt;code&gt;416&lt;/code&gt; 响应消息包含&lt;a href=&quot;../headers/content-range&quot;&gt; &lt;code&gt;Content-Range&lt;/code&gt; &lt;/a&gt;指示不满意范围（即一个 &lt;code&gt;'*'&lt;/code&gt; ），接着是 &lt;code&gt;'/'&lt;/code&gt; 和资源的当前长度。例如， &lt;code&gt;Content-Range: */12777&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cc6eca35190b0a85bc179efcd6440ff5e420f987" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;416&lt;/code&gt; response message contains a &lt;a href=&quot;../headers/content-range&quot;&gt;&lt;code&gt;Content-Range&lt;/code&gt;&lt;/a&gt; indicating an unsatisfied range (that is a &lt;code&gt;'*'&lt;/code&gt;) followed by a &lt;code&gt;'/'&lt;/code&gt; and the current length of the resource. E.g. &lt;code&gt;Content-Range: bytes */12777&lt;/code&gt;</source>
          <target state="translated">所述 &lt;code&gt;416&lt;/code&gt; 响应消息包含&lt;a href=&quot;../headers/content-range&quot;&gt; &lt;code&gt;Content-Range&lt;/code&gt; &lt;/a&gt;指示不满意范围（即一个 &lt;code&gt;'*'&lt;/code&gt; ），接着是 &lt;code&gt;'/'&lt;/code&gt; 和资源的当前长度。例如， &lt;code&gt;Content-Range: bytes */12777&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="000250a8c920d71a596d42e3ba222cb0c276eb98" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;http://httpd.apache.org/docs/current/mod/mod_rewrite.html&quot;&gt;mod_rewrite&lt;/a&gt;&lt;/code&gt; module can also create redirects. It is more flexible, but a bit more complex.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;http://httpd.apache.org/docs/current/mod/mod_rewrite.html&quot;&gt;mod_rewrite&lt;/a&gt;&lt;/code&gt; 的模块还可以创建重定向。它更灵活，但有点复杂。</target>
        </trans-unit>
        <trans-unit id="d74ebb54bf35188baf88fab6ddfb03450100af2e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#attr-allow&quot;&gt;allow&lt;/a&gt;&lt;/code&gt; attribute on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt;上的 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#attr-allow&quot;&gt;allow&lt;/a&gt;&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="678867190bea86d25ddd4c42f7e5d5945a9962ee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes#attr-content&quot;&gt;content&lt;/a&gt;&lt;/code&gt; attribute should start with a number indicating how many seconds the browser should wait before redirecting to the given URL. Always set it to &lt;code&gt;0&lt;/code&gt; for accessibility compliance.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes#attr-content&quot;&gt;content&lt;/a&gt;&lt;/code&gt; 属性应该有一个数字，表示浏览器应该在多少秒重定向到指定的URL之前等待启动。始终将其设置为 &lt;code&gt;0&lt;/code&gt; ，以实现可访问性。</target>
        </trans-unit>
        <trans-unit id="e37ff63edc4a58e58577f391879495cdf22ee684" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes#attr-content&quot;&gt;content&lt;/a&gt;&lt;/code&gt; attribute starts with a number indicating how many seconds the browser should wait before redirecting to the given URL. Always set it to &lt;code&gt;0&lt;/code&gt;, for better accessibility.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes#attr-content&quot;&gt;content&lt;/a&gt;&lt;/code&gt; 与一些属性开始显示多少秒的浏览器重定向到指定的URL之前应该等待。始终将其设置为 &lt;code&gt;0&lt;/code&gt; ，以获得更好的可访问性。</target>
        </trans-unit>
        <trans-unit id="df94992d56f1ec3780068eef1f291a2bd6528445" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;https://developers.google.com/search/reference/robots_meta_tag#xrobotstag&quot;&gt;X-Robots-Tag&lt;/a&gt;&lt;/code&gt; HTTP header is used to indicate how a web page is to be indexed within public search engine results. The header is effectively equivalent to &lt;code&gt;&amp;lt;meta name=&quot;robots&quot; content=&quot;...&quot;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;https://developers.google.com/search/reference/robots_meta_tag#xrobotstag&quot;&gt;X-Robots-Tag&lt;/a&gt;&lt;/code&gt; 中的HTTP标头是用来表示Web页面是如何被大众内部搜索引擎结果索引。标题实际上等效于 &lt;code&gt;&amp;lt;meta name=&quot;robots&quot; content=&quot;...&quot;&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7d9f882bdef0f2fbd9c820397fd3355193604e73" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/previous-versions/windows/internet-explorer/ie-developer/compatibility/jj542450(v=vs.85)?#the-noopen-directive&quot;&gt;X-Download-Options&lt;/a&gt;&lt;/code&gt; HTTP header indicates that the browser (Internet Explorer) should not display the option to &quot;Open&quot; a file that has been downloaded from an application, to prevent phishing attacks as the file otherwise would gain access to execute in the context of the application. (Note: related &lt;a href=&quot;https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/18488178/&quot;&gt;MS Edge bug&lt;/a&gt;).</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/previous-versions/windows/internet-explorer/ie-developer/compatibility/jj542450(v=vs.85)?#the-noopen-directive&quot;&gt;X-Download-Options&lt;/a&gt;&lt;/code&gt; HTTP标头指示浏览器（Internet Explorer）中不应该显示选项&amp;ldquo;打开&amp;rdquo;已经从应用程序下载的文件，以防止网络钓鱼攻击的文件，否则将获得的执行应用程序的上下文。（注意：相关的&lt;a href=&quot;https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/18488178/&quot;&gt;MS Edge错误&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="8570429a0850dacdf55e905b24382087aa950397" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;https://httpd.apache.org/docs/current/mod/mod_alias.html&quot;&gt;mod_alias&lt;/a&gt;&lt;/code&gt; module has &lt;code&gt;Redirect&lt;/code&gt; and &lt;code&gt;RedirectMatch&lt;/code&gt; directives that set up &lt;a href=&quot;status/302&quot;&gt;&lt;code&gt;302&lt;/code&gt;&lt;/a&gt; redirects by default:</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;https://httpd.apache.org/docs/current/mod/mod_alias.html&quot;&gt;mod_alias&lt;/a&gt;&lt;/code&gt; 中模块具有 &lt;code&gt;Redirect&lt;/code&gt; 和 &lt;code&gt;RedirectMatch&lt;/code&gt; 指令，它们设立&lt;a href=&quot;status/302&quot;&gt; &lt;code&gt;302&lt;/code&gt; 个&lt;/a&gt;重定向默认情况下：</target>
        </trans-unit>
        <trans-unit id="f6ceb6b99bc589e7f4ef4cc475222c90b7cc3bbe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;https://httpd.apache.org/docs/current/mod/mod_rewrite.html&quot;&gt;mod_rewrite&lt;/a&gt;&lt;/code&gt; module can also create redirects. It is more flexible, but a bit more complex.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;https://httpd.apache.org/docs/current/mod/mod_rewrite.html&quot;&gt;mod_rewrite&lt;/a&gt;&lt;/code&gt; 的模块还可以创建重定向。它更灵活，但有点复杂。</target>
        </trans-unit>
        <trans-unit id="1a33077bdfc87f84fa941dba1652820231ca50a9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc5988#section-5&quot;&gt;Link&lt;/a&gt;&lt;/code&gt; entity-header field provides a means for serialising one or more links in HTTP headers. It is semantically equivalent to the HTML &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link&quot;&gt;&lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt;&lt;/a&gt; element.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc5988#section-5&quot;&gt;Link&lt;/a&gt;&lt;/code&gt; 实体头字段提供了在HTTP头中串行化一个或多个链接的装置。它在语义上等效于HTML &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link&quot;&gt; &lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt; &lt;/a&gt;元素。</target>
        </trans-unit>
        <trans-unit id="0bf90377c54cfb58cf2ddd3a014cf93971e6153b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc5988#section-5&quot;&gt;Link&lt;/a&gt;&lt;/code&gt; entity-header field provides a means for serialising one or more links in HTTP headers. It is semantically equivalent to the HTML &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/docs/Web/HTML/Element/link&quot;&gt;&amp;lt;link&amp;gt;&lt;/a&gt;&lt;/code&gt; element.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc5988#section-5&quot;&gt;Link&lt;/a&gt;&lt;/code&gt; 实体头字段提供了在HTTP头中串行化一个或多个链接的装置。它在语义上等效于HTML &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/docs/Web/HTML/Element/link&quot;&gt;&amp;lt;link&amp;gt;&lt;/a&gt;&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="a78799203cafc041527d32fff46051e530f3f10a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#rfc.section.3.1&quot;&gt;Signature&lt;/a&gt;&lt;/code&gt; header field conveys a list of signatures for an exchange, each one accompanied by information about how to determine the authority of and refresh that signature.</source>
          <target state="translated">&amp;ldquo; &lt;code&gt;&lt;a href=&quot;https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#rfc.section.3.1&quot;&gt;Signature&lt;/a&gt;&lt;/code&gt; 标头字段传达用于交换的签名列表，每个列表都附带有关如何确定该签名的权限和刷新该签名的信息。</target>
        </trans-unit>
        <trans-unit id="ac287448eebb179af2b5fea39da63acb2f0e34a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#rfc.section.5.1.2&quot;&gt;Signed-Headers&lt;/a&gt;&lt;/code&gt; header field identifies an ordered list of response header fields to include in a signature.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#rfc.section.5.1.2&quot;&gt;Signed-Headers&lt;/a&gt;&lt;/code&gt; 报头字段标识响应的报头字段的有序列表中的签名包括。</target>
        </trans-unit>
        <trans-unit id="f3c5f0394e6c797409337c3ba59ac4660eea6b49" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Accept-CH-Lifetime&lt;/strong&gt;&lt;/code&gt; header is set by the server to specify the persistence of &lt;a href=&quot;accept-ch&quot;&gt;&lt;code&gt;Accept-CH&lt;/code&gt;&lt;/a&gt; header value that specifies for which &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Client_hints&quot;&gt;Client Hints&lt;/a&gt; headers client should include in subsequent requests.</source>
          <target state="translated">所述 &lt;code&gt;&lt;strong&gt;Accept-CH-Lifetime&lt;/strong&gt;&lt;/code&gt; 头是由服务器设置为指定的持续&lt;a href=&quot;accept-ch&quot;&gt; &lt;code&gt;Accept-CH&lt;/code&gt; &lt;/a&gt;标头值，用于指定该&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Client_hints&quot;&gt;客户机提示&lt;/a&gt;头客户机应该包括在后续请求中。</target>
        </trans-unit>
        <trans-unit id="1fc84160c5460da89ca680071c3cd21f91aa02e3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Accept-CH&lt;/strong&gt;&lt;/code&gt; header is set by the server to specify which &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Client_hints&quot;&gt;Client Hints&lt;/a&gt; headers a client should include in subsequent requests.</source>
          <target state="translated">所述 &lt;code&gt;&lt;strong&gt;Accept-CH&lt;/strong&gt;&lt;/code&gt; 头是由服务器设置为指定&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Client_hints&quot;&gt;客户机提示&lt;/a&gt;头客户机应该包括在后续请求中。</target>
        </trans-unit>
        <trans-unit id="d982342366479f245d9e1687b6642ae3d345e689" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Accept-Ranges&lt;/strong&gt;&lt;/code&gt; response HTTP header is a marker used by the server to advertise its support of partial requests. The value of this field indicates the unit that can be used to define a range.</source>
          <target state="translated">所述 &lt;code&gt;&lt;strong&gt;Accept-Ranges&lt;/strong&gt;&lt;/code&gt; 响应HTTP标头是由服务器使用以通告其支持部分请求的标志物。该字段的值指示可用于定义范围的单位。</target>
        </trans-unit>
        <trans-unit id="d3c88e931c279d244b193828eb2439579c4ee0ab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Access-Control-Allow-Origin&lt;/strong&gt;&lt;/code&gt; response header indicates whether the response can be shared with requesting code from the given &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/origin&quot;&gt;origin&lt;/a&gt;.</source>
          <target state="translated">的 &lt;code&gt;&lt;strong&gt;Access-Control-Allow-Origin&lt;/strong&gt;&lt;/code&gt; 响应标头指示是否响应可以与来自给定的请求代码共享&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/origin&quot;&gt;原点&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e7e76f11cda78abd0588ec375967af559825d413" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Age&lt;/strong&gt;&lt;/code&gt; header contains the time in seconds the object has been in a proxy cache.</source>
          <target state="translated">该 &lt;code&gt;&lt;strong&gt;Age&lt;/strong&gt;&lt;/code&gt; 头包含以秒计的对象一直在代理缓存的时间。</target>
        </trans-unit>
        <trans-unit id="f9681dd052c79b13127ae3929a731da18e4b72d4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Allow&lt;/strong&gt;&lt;/code&gt; header lists the set of methods support by a resource.</source>
          <target state="translated">在 &lt;code&gt;&lt;strong&gt;Allow&lt;/strong&gt;&lt;/code&gt; 头列出了一套方法由资源支持。</target>
        </trans-unit>
        <trans-unit id="c95653d764bb42232e9cbd3888e86cd3686754bf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Allow&lt;/strong&gt;&lt;/code&gt; header lists the set of methods supported by a resource.</source>
          <target state="translated">在 &lt;code&gt;&lt;strong&gt;Allow&lt;/strong&gt;&lt;/code&gt; 头列出了一套由资源支持的方法。</target>
        </trans-unit>
        <trans-unit id="acc0cc776eb12ee2c880638b893d5b55050e39bf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Digest&lt;/strong&gt;&lt;/code&gt; response HTTP header provides a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/digest&quot;&gt;digest&lt;/a&gt; of the requested resource.</source>
          <target state="translated">的 &lt;code&gt;&lt;strong&gt;Digest&lt;/strong&gt;&lt;/code&gt; 响应的HTTP报头提供了一个&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/digest&quot;&gt;摘要&lt;/a&gt;所请求的资源的。</target>
        </trans-unit>
        <trans-unit id="2e78b75471626ac2160cc198bfd26d8ad9f80eb0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Early-Data&lt;/strong&gt;&lt;/code&gt; header is set by an intermediary to indicate that the request has been conveyed in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Transport_Layer_Security#TLS_1.3&quot;&gt;TLS early data&lt;/a&gt;, and also indicates that the intermediary understands the &lt;a href=&quot;../status/425&quot;&gt;&lt;code&gt;425 (Too Early)&lt;/code&gt;&lt;/a&gt; status code.</source>
          <target state="translated">在 &lt;code&gt;&lt;strong&gt;Early-Data&lt;/strong&gt;&lt;/code&gt; 报头由中间设置为指示该请求已被输送&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Transport_Layer_Security#TLS_1.3&quot;&gt;TLS早期数据&lt;/a&gt;，并且还指示该中介理解&lt;a href=&quot;../status/425&quot;&gt; &lt;code&gt;425 (Too Early)&lt;/code&gt; &lt;/a&gt;状态代码。</target>
        </trans-unit>
        <trans-unit id="d61bb0d627ec7b7f17d0bc47d697b57d00a1bc5f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Early-Data&lt;/strong&gt;&lt;/code&gt; header is set by an intermediate to indicates that the request has been conveyed in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Transport_Layer_Security#TLS_1.3&quot;&gt;TLS early data&lt;/a&gt;, and additionally indicates that an intermediary understands the &lt;a href=&quot;../status/425&quot;&gt;&lt;code&gt;425 (Too Early)&lt;/code&gt;&lt;/a&gt; status code. The &lt;code&gt;&lt;strong&gt;Early-Data&lt;/strong&gt;&lt;/code&gt; header is not set by the originator of the request (i.e., a browser).</source>
          <target state="translated">在 &lt;code&gt;&lt;strong&gt;Early-Data&lt;/strong&gt;&lt;/code&gt; 头通过中间到指示该请求已被输送设定&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Transport_Layer_Security#TLS_1.3&quot;&gt;TLS早期数据&lt;/a&gt;，并且附加地表示中介理解&lt;a href=&quot;../status/425&quot;&gt; &lt;code&gt;425 (Too Early)&lt;/code&gt; &lt;/a&gt;状态代码。在 &lt;code&gt;&lt;strong&gt;Early-Data&lt;/strong&gt;&lt;/code&gt; 报头不被请求的（即，浏览器）的始发者设定。</target>
        </trans-unit>
        <trans-unit id="e737d89463e54c8720f8ad63e418a0bfb0f07f1f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Expires&lt;/strong&gt;&lt;/code&gt; header contains the date/time after which the response is considered stale.</source>
          <target state="translated">的 &lt;code&gt;&lt;strong&gt;Expires&lt;/strong&gt;&lt;/code&gt; 报头包含的日期/时间之后，响应被视为失效。</target>
        </trans-unit>
        <trans-unit id="5be71a78718c793e01b9247dbf20bee8de751846" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;From&lt;/strong&gt;&lt;/code&gt; request header contains an Internet email address for a human user who controls the requesting user agent.</source>
          <target state="translated">在 &lt;code&gt;&lt;strong&gt;From&lt;/strong&gt;&lt;/code&gt; 请求头中包含的Internet电子邮件地址谁控制了请求的用户代理的人类用户。</target>
        </trans-unit>
        <trans-unit id="73a9129a968278840bcb3ecb81312e01ea1c7ad9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Host&lt;/strong&gt;&lt;/code&gt; request header specifies the domain name of the server (for virtual hosting), and (optionally) the TCP port number on which the server is listening.</source>
          <target state="translated">所述 &lt;code&gt;&lt;strong&gt;Host&lt;/strong&gt;&lt;/code&gt; 请求头指定的服务器的域名（虚拟主机），和（可选地）的TCP端口号上的服务器是听音。</target>
        </trans-unit>
        <trans-unit id="1d90ed71aec05b79116744d2cf8473e3277dfbc7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Host&lt;/strong&gt;&lt;/code&gt; request header specifies the host and port number of the server to which the request is being sent.</source>
          <target state="translated">所述 &lt;code&gt;&lt;strong&gt;Host&lt;/strong&gt;&lt;/code&gt; 请求标头指定要在其中发送请求的服务器的主机和端口号。</target>
        </trans-unit>
        <trans-unit id="36122c8169aa84d5fb618cc5e704f67fadc13a5e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Keep-Alive&lt;/strong&gt;&lt;/code&gt; general header allows the sender to hint about how the connection and may be used to set a timeout and a maximum amount of requests.</source>
          <target state="translated">的 &lt;code&gt;&lt;strong&gt;Keep-Alive&lt;/strong&gt;&lt;/code&gt; 的一般头允许有关如何连接，并且可以被用于设置超时时间，并且请求的最大数量的发送者提示。</target>
        </trans-unit>
        <trans-unit id="c0b74d9f17da8401496a5b8c7cf402bea1cb5769" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Keep-Alive&lt;/strong&gt;&lt;/code&gt; general header allows the sender to hint about how the connection may be used to set a timeout and a maximum amount of requests.</source>
          <target state="translated">的 &lt;code&gt;&lt;strong&gt;Keep-Alive&lt;/strong&gt;&lt;/code&gt; 的一般头允许有关如何连接可被用来设置一个超时和请求的最大数量的发送者提示。</target>
        </trans-unit>
        <trans-unit id="2fbf23d9b9327582f4f49a7ec76472bba6a6a4fa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Pragma&lt;/strong&gt;&lt;/code&gt; HTTP/1.0 general header is an implementation-specific header that may have various effects along the request-response chain. It is used for backwards compatibility with HTTP/1.0 caches where the &lt;code&gt;Cache-Control&lt;/code&gt; HTTP/1.1 header is not yet present.</source>
          <target state="translated">的 &lt;code&gt;&lt;strong&gt;Pragma&lt;/strong&gt;&lt;/code&gt; HTTP / 1.0一般报头是可以具有沿着所述请求-响应链的各种效果的实现特定的头。它用于与尚不存在 &lt;code&gt;Cache-Control&lt;/code&gt; HTTP / 1.1标头的HTTP / 1.0缓存向后兼容。</target>
        </trans-unit>
        <trans-unit id="df9c97c4ad9d61f0d260427224fcdc949c7f1596" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Referer&lt;/strong&gt;&lt;/code&gt; request header contains the address of the page making the request. When following a link, this would be the url of the page containing the link. When making AJAX requests to another domain, this would be your page's url. The &lt;code&gt;Referer&lt;/code&gt; header allows servers to identify where people are visiting them from and may use that data for analytics, logging, or optimized caching, for example.</source>
          <target state="translated">该 &lt;code&gt;&lt;strong&gt;Referer&lt;/strong&gt;&lt;/code&gt; 的请求头中包含发出请求的页面的地址。当跟随链接时，这将是包含链接的页面的URL。向其他域发出AJAX请求时，这就是您页面的网址。该 &lt;code&gt;Referer&lt;/code&gt; 的头允许服务器，以确定那里的人们探访他们，并可以用来分析，记录，或优化的缓存数据，例如。</target>
        </trans-unit>
        <trans-unit id="ab3c55e276ce88c71d0f16074fd5ecc0e9f413f9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Referer&lt;/strong&gt;&lt;/code&gt; request header contains the address of the previous web page from which a link to the currently requested page was followed. The &lt;code&gt;Referer&lt;/code&gt; header allows servers to identify where people are visiting them from and may use that data for analytics, logging, or optimized caching, for example.</source>
          <target state="translated">该 &lt;code&gt;&lt;strong&gt;Referer&lt;/strong&gt;&lt;/code&gt; 的请求头中包含以前的web页面，从中当前请求页面的链接，随后的地址。该 &lt;code&gt;Referer&lt;/code&gt; 的头允许服务器，以确定那里的人们探访他们，并可以用来分析，记录，或优化的缓存数据，例如。</target>
        </trans-unit>
        <trans-unit id="f35781aa0d1de163111fee93c0d8d38911b682ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Server&lt;/strong&gt;&lt;/code&gt; header contains information about the software used by the origin server to handle the request.</source>
          <target state="translated">该 &lt;code&gt;&lt;strong&gt;Server&lt;/strong&gt;&lt;/code&gt; 头包含有关用作原始服务器处理请求的软件信息。</target>
        </trans-unit>
        <trans-unit id="d1b3c683e4cd677dc3be26bd03213dd34909bab4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Server&lt;/strong&gt;&lt;/code&gt; header describes the software used by the origin server that handled the request &amp;mdash; that is, the server that generated the response.</source>
          <target state="translated">的 &lt;code&gt;&lt;strong&gt;Server&lt;/strong&gt;&lt;/code&gt; 报头描述了通过处理请求源服务器所使用的软件-即，所产生的响应的服务器。</target>
        </trans-unit>
        <trans-unit id="f72ba03805654f750e5994c434c6ce48268c191f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;TE&lt;/strong&gt;&lt;/code&gt; request header specifies the transfer encodings the user agent is willing to accept. (you could informally call it &lt;em&gt;&lt;code&gt;Accept-Transfer-Encoding&lt;/code&gt;&lt;/em&gt;, which would be more intuitive).</source>
          <target state="translated">的 &lt;code&gt;&lt;strong&gt;TE&lt;/strong&gt;&lt;/code&gt; 请求头指定的传输编码的用户代理是愿意接受。（您可以非正式地将其称为&lt;em&gt; &lt;code&gt;Accept-Transfer-Encoding&lt;/code&gt; &lt;/em&gt;，这将更加直观）。</target>
        </trans-unit>
        <trans-unit id="5652b37e21feb912010feecdf8d75ae0995d40af" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Timing-Allow-Origin&lt;/strong&gt;&lt;/code&gt; response header specifies origins that are allowed to see values of attributes retrieved via features of the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Resource_Timing_API&quot;&gt;Resource Timing API&lt;/a&gt;, which would otherwise be reported as zero due to cross-origin restrictions.</source>
          <target state="translated">的 &lt;code&gt;&lt;strong&gt;Timing-Allow-Origin&lt;/strong&gt;&lt;/code&gt; 响应标头指定允许看到经由的特征检索的属性的值的起源&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Resource_Timing_API&quot;&gt;资源时序API&lt;/a&gt;，否则会报告为零由于跨来源的限制。</target>
        </trans-unit>
        <trans-unit id="459b5cbc88f2c6244c84b2b7cf57687d4fed7e90" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Variant Also Negotiates&lt;/strong&gt;&lt;/code&gt; status code indicates an internal server configuration error in which the chosen variant is itself configured to engage in content negotiation, so is not a proper negotiation endpoint.</source>
          <target state="translated">所述 &lt;code&gt;&lt;strong&gt;Variant Also Negotiates&lt;/strong&gt;&lt;/code&gt; 的状态代码指示其中所选择的变体本身被构造成接合在内容协商一个内部服务器配置错误，所以是不正确的协商端点。</target>
        </trans-unit>
        <trans-unit id="f06db3329ed9ad8dfc09e37ef09b6402d3732e8a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Via&lt;/strong&gt;&lt;/code&gt; general header is added by proxies, both forward and reverse proxies, and can appear in the request headers and the response headers. It is used for tracking message forwards, avoiding request loops, and identifying the protocol capabilities of senders along the request/response chain.</source>
          <target state="translated">在 &lt;code&gt;&lt;strong&gt;Via&lt;/strong&gt;&lt;/code&gt; 一般报头由代理添加，前向和反向代理，并且可以在请求头和响应标头出现。它用于跟踪消息转发，避免请求循环以及识别请求/响应链中发送者的协议功能。</target>
        </trans-unit>
        <trans-unit id="519d7e47665e940480525b25780c7db7b6681325" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Want-Digest&lt;/strong&gt;&lt;/code&gt; HTTP header is primarily used in a HTTP request, to ask the responder to provide a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/digest&quot;&gt;digest&lt;/a&gt; of the requested resource using the &lt;code&gt;&lt;a href=&quot;digest&quot;&gt;Digest&lt;/a&gt;&lt;/code&gt; response header.</source>
          <target state="translated">在 &lt;code&gt;&lt;strong&gt;Want-Digest&lt;/strong&gt;&lt;/code&gt; HTTP标头在一个HTTP请求主要用于，询问响应，以提供一个&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/digest&quot;&gt;消化&lt;/a&gt;使用所请求的资源的 &lt;code&gt;&lt;a href=&quot;digest&quot;&gt;Digest&lt;/a&gt;&lt;/code&gt; 响应头。</target>
        </trans-unit>
        <trans-unit id="d2a25ab474d784c5f16b25d0aa6fcd7fc6ce7fc3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;X-Content-Type-Options&lt;/strong&gt;&lt;/code&gt; response HTTP header is a marker used by the server to indicate that the &lt;a href=&quot;../basics_of_http/mime_types&quot;&gt;MIME types&lt;/a&gt; advertised in the &lt;a href=&quot;content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; headers should not be changed and be followed. This allows to opt-out of &lt;a href=&quot;../basics_of_http/mime_types#MIME_sniffing&quot;&gt;MIME type sniffing&lt;/a&gt;, or, in other words, it is a way to say that the webmasters knew what they were doing.</source>
          <target state="translated">的 &lt;code&gt;&lt;strong&gt;X-Content-Type-Options&lt;/strong&gt;&lt;/code&gt; 响应HTTP标头是由服务器使用以指示该标记&lt;a href=&quot;../basics_of_http/mime_types&quot;&gt;MIME类型&lt;/a&gt;的广告&lt;a href=&quot;content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt;报头不应当被改变，并且被遵循。这样就可以选择不使用&lt;a href=&quot;../basics_of_http/mime_types#MIME_sniffing&quot;&gt;MIME类型嗅探&lt;/a&gt;，换句话说，这是一种表示网站管理员知道他们在做什么的方式。</target>
        </trans-unit>
        <trans-unit id="cd7aecd4c1fd5dec57a2c138b3e5a8c117d9036d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;X-Content-Type-Options&lt;/strong&gt;&lt;/code&gt; response HTTP header is a marker used by the server to indicate that the &lt;a href=&quot;../basics_of_http/mime_types&quot;&gt;MIME types&lt;/a&gt; advertised in the &lt;a href=&quot;content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; headers should not be changed and be followed. This is a way to opt out of &lt;a href=&quot;../basics_of_http/mime_types#MIME_sniffing&quot;&gt;MIME type sniffing&lt;/a&gt;, or, in other words, to say that the MIME types are deliberately configured.</source>
          <target state="translated">的 &lt;code&gt;&lt;strong&gt;X-Content-Type-Options&lt;/strong&gt;&lt;/code&gt; 响应HTTP标头是由服务器使用以指示该标记&lt;a href=&quot;../basics_of_http/mime_types&quot;&gt;MIME类型&lt;/a&gt;的广告&lt;a href=&quot;content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt;报头不应当被改变，并且被遵循。这是一种选择退出&lt;a href=&quot;../basics_of_http/mime_types#MIME_sniffing&quot;&gt;MIME类型嗅探的方法&lt;/a&gt;，或者换句话说，是故意配置MIME类型。</target>
        </trans-unit>
        <trans-unit id="bceacb1272f77c276df2ceb5f3eec10ddfee111d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;var&gt;platform&lt;/var&gt;&lt;/code&gt; part of the UA string indicates if Firefox is running on a phone-sized or tablet device. When Firefox runs on a device that has the phone form factor, there is a &lt;code&gt;Mobile;&lt;/code&gt; token in the &lt;code&gt;&lt;var&gt;platform&lt;/var&gt;&lt;/code&gt; part of the UA string. When Firefox runs on a tablet device, there is a &lt;code&gt;Tablet;&lt;/code&gt; token in the &lt;code&gt;&lt;var&gt;platform&lt;/var&gt;&lt;/code&gt; part of the UA string instead. For example:</source>
          <target state="translated">UA字符串的 &lt;code&gt;&lt;var&gt;platform&lt;/var&gt;&lt;/code&gt; 部分指示Firefox是否在手机大小或平板设备上运行。当Firefox在具有电话外形尺寸的设备上运行时，将显示 &lt;code&gt;Mobile;&lt;/code&gt; UA字符串的 &lt;code&gt;&lt;var&gt;platform&lt;/var&gt;&lt;/code&gt; 部分中的令牌。当Firefox在平板电脑设备上运行时，有一个 &lt;code&gt;Tablet;&lt;/code&gt; 而是在UA字符串的 &lt;code&gt;&lt;var&gt;platform&lt;/var&gt;&lt;/code&gt; 部分添加令牌。例如：</target>
        </trans-unit>
        <trans-unit id="82e98053eac989383e680a4cf5cc9358923e6dcb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Accept-CH-Lifetime&lt;/code&gt; header</source>
          <target state="translated">所述 &lt;code&gt;Accept-CH-Lifetime&lt;/code&gt; 头</target>
        </trans-unit>
        <trans-unit id="6df4384dcc248042b53e1dc48377a116aa3f10ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Accept-CH&lt;/code&gt; header</source>
          <target state="translated">所述 &lt;code&gt;Accept-CH&lt;/code&gt; 头</target>
        </trans-unit>
        <trans-unit id="c43f0f2a86e0d2275393478d7fdb73db5ffbaada" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Accept-Charset&lt;/code&gt; header</source>
          <target state="translated">该 &lt;code&gt;Accept-Charset&lt;/code&gt; 报头</target>
        </trans-unit>
        <trans-unit id="2cb1ca877d3eb1b0f248f74c9ec40232997e5dc5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Accept-Charset&lt;/code&gt; request HTTP header advertises which &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/character_encoding&quot;&gt;character encodings&lt;/a&gt; the client understands. Using &lt;a href=&quot;../content_negotiation&quot;&gt;content negotiation&lt;/a&gt;, the server selects one of the encodings, uses it, and informs the client of its choice within the &lt;a href=&quot;content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; response header, usually in a &lt;code&gt;charset=&lt;/code&gt; parameter. Browsers usually don't send this header, as the default value for each resource is usually correct and transmitting it would allow &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/Firefox/Privacy/Tracking_Protection&quot;&gt;fingerprinting&lt;/a&gt;.</source>
          <target state="translated">的 &lt;code&gt;Accept-Charset&lt;/code&gt; 请求的HTTP标头通告哪个&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/character_encoding&quot;&gt;字符编码&lt;/a&gt;客户端理解。服务器使用&lt;a href=&quot;../content_negotiation&quot;&gt;内容协商&lt;/a&gt;，选择一种编码，使用它，然后在&lt;a href=&quot;content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt;响应标头中通常通过 &lt;code&gt;charset=&lt;/code&gt; 参数将其选择通知客户端。浏览器通常不发送此标头，因为每种资源的默认值通常是正确的，并且传输它会允许使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/Firefox/Privacy/Tracking_Protection&quot;&gt;指纹&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1e1a79dc44f6324b9656f0e9b91f70c6b6ee9b87" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Accept-Charset&lt;/code&gt; request HTTP header advertises which character set the client is able to understand. Using &lt;a href=&quot;../content_negotiation&quot;&gt;content negotiation&lt;/a&gt;, the server then selects one of the proposals, uses it and informs the client of its choice within the &lt;a href=&quot;content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; response header. Browsers usually don't set this header as the default value for each content type is usually correct and transmitting it would allow easier fingerprinting.</source>
          <target state="translated">的 &lt;code&gt;Accept-Charset&lt;/code&gt; 请求的HTTP标头通告哪些字符集，客户端是能够理解。然后，使用&lt;a href=&quot;../content_negotiation&quot;&gt;内容协商&lt;/a&gt;，服务器选择建议之一，使用建议，然后在&lt;a href=&quot;content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt;响应标头中将其选择通知客户。浏览器通常不设置此标头，因为每种内容类型的默认值通常是正确的，并且传输它可以使指纹更容易识别。</target>
        </trans-unit>
        <trans-unit id="32e4c478c87a3a2796f89e9931f3a93966bdfdbf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Accept-Encoding&lt;/code&gt; header</source>
          <target state="translated">在 &lt;code&gt;Accept-Encoding&lt;/code&gt; 头</target>
        </trans-unit>
        <trans-unit id="91185be688fa9da1a182310f6df358fd174c46f1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Accept-Encoding&lt;/code&gt; request HTTP header advertises which content encoding, usually a compression algorithm, the client is able to understand. Using &lt;a href=&quot;../content_negotiation&quot;&gt;content negotiation&lt;/a&gt;, the server selects one of the proposals, uses it and informs the client of its choice with the &lt;a href=&quot;content-encoding&quot;&gt;&lt;code&gt;Content-Encoding&lt;/code&gt;&lt;/a&gt; response header.</source>
          <target state="translated">所述 &lt;code&gt;Accept-Encoding&lt;/code&gt; 请求的HTTP标头通告其内容编码，通常是一个压缩算法中，客户端是能够理解的。通过使用&lt;a href=&quot;../content_negotiation&quot;&gt;内容协商&lt;/a&gt;，服务器选择建议之一，使用建议，并通过&lt;a href=&quot;content-encoding&quot;&gt; &lt;code&gt;Content-Encoding&lt;/code&gt; &lt;/a&gt;响应标头将其选择通知客户端。</target>
        </trans-unit>
        <trans-unit id="3ae7d36d36006ff093b2a55d71bd74d51e77b3ef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Accept-Language&lt;/code&gt; header</source>
          <target state="translated">在 &lt;code&gt;Accept-Language&lt;/code&gt; 头</target>
        </trans-unit>
        <trans-unit id="c4a25b290f315f1cab7813fec6b003a441c0d600" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Accept-Language&lt;/code&gt; request HTTP header advertises which languages the client is able to understand, and which locale variant is preferred. (By languages, we mean natural languages, such as English, and not programming languages.) Using &lt;a href=&quot;../content_negotiation&quot;&gt;content negotiation&lt;/a&gt;, the server then selects one of the proposals, uses it and informs the client of its choice with the &lt;a href=&quot;content-language&quot;&gt;&lt;code&gt;Content-Language&lt;/code&gt;&lt;/a&gt; response header. Browsers set adequate values for this header according to their user interface language and even if a user can change it, this happens rarely (and is frowned upon as it leads to fingerprinting).</source>
          <target state="translated">在 &lt;code&gt;Accept-Language&lt;/code&gt; 请求的HTTP标头通告哪些语言客户端是能够理解，并且其区域的变体是优选的。（通过语言，我们指的是自然语言，例如英语，而不是编程语言。）使用&lt;a href=&quot;../content_negotiation&quot;&gt;内容协商&lt;/a&gt;，服务器然后选择一个建议，使用它，并通过&lt;a href=&quot;content-language&quot;&gt; &lt;code&gt;Content-Language&lt;/code&gt; &lt;/a&gt;响应标头将其选择通知客户。浏览器会根据其用户界面语言为该标头设置足够的值，即使用户可以更改它，这种情况也很少发生（并且会导致指纹识别，因此对此不以为然）。</target>
        </trans-unit>
        <trans-unit id="f1d16f67263a6c86cf3fcdfef1e4b190e49a0296" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Accept-Patch&lt;/code&gt; response HTTP header advertises which media-type the server is able to understand in a PATCH request.</source>
          <target state="translated">所述 &lt;code&gt;Accept-Patch&lt;/code&gt; 哪些媒体类型的服务器响应的HTTP标头通告能够以PATCH请求理解。</target>
        </trans-unit>
        <trans-unit id="6003efca5251790ce42906144c5dccf2f87ad99b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Accept-Post&lt;/code&gt; response HTTP header advertises which &lt;a href=&quot;../basics_of_http/mime_types&quot;&gt;media types&lt;/a&gt; are accepted by the server for HTTP post requests.</source>
          <target state="translated">在 &lt;code&gt;Accept-Post&lt;/code&gt; 其响应HTTP头通告&lt;a href=&quot;../basics_of_http/mime_types&quot;&gt;媒体类型&lt;/a&gt;是由服务器的HTTP POST请求被接受。</target>
        </trans-unit>
        <trans-unit id="f1004b9f5d3731dda0f9cb684f40a19f9053e7da" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Accept&lt;/code&gt; header</source>
          <target state="translated">在 &lt;code&gt;Accept&lt;/code&gt; 头</target>
        </trans-unit>
        <trans-unit id="826c8958d78002b0f5bee62cfd9d7b4401ff27e1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Accept&lt;/code&gt; request HTTP header advertises which content types, expressed as &lt;a href=&quot;../basics_of_http/mime_types&quot;&gt;MIME types&lt;/a&gt;, the client is able to understand. Using &lt;a href=&quot;../content_negotiation&quot;&gt;content negotiation&lt;/a&gt;, the server then selects one of the proposals, uses it and informs the client of its choice with the &lt;a href=&quot;content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; response header. Browsers set adequate values for this header depending on the context where the request is done: when fetching a CSS stylesheet a different value is set for the request than when fetching an image, video or a script.</source>
          <target state="translated">该 &lt;code&gt;Accept&lt;/code&gt; 请求HTTP头通告哪些内容类型，表示为&lt;a href=&quot;../basics_of_http/mime_types&quot;&gt;MIME类型&lt;/a&gt;，客户端是能够理解的。然后，使用&lt;a href=&quot;../content_negotiation&quot;&gt;内容协商&lt;/a&gt;，服务器选择建议之一，使用建议，并通过&lt;a href=&quot;content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt;响应标头将其选择通知客户端。浏览器会根据完成请求的上下文为此标头设置适当的值：获取CSS样式表时，为请求设置的值与获取图像，视频或脚本时不同。</target>
        </trans-unit>
        <trans-unit id="44e072ab59ddfb74fd5772684f9e86075ecb4b7a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; header works in conjunction with the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials&quot;&gt;&lt;code&gt;XMLHttpRequest.withCredentials&lt;/code&gt;&lt;/a&gt; property or with the &lt;code&gt;credentials&lt;/code&gt; option in the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request/Request&quot;&gt;&lt;code&gt;Request()&lt;/code&gt;&lt;/a&gt; constructor of the Fetch API. For a CORS request with credentials, in order for browsers to expose the response to frontend JavaScript code, both the server (using the &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; header) and the client (by setting the credentials mode for the XHR, Fetch, or Ajax request) must indicate that they&amp;rsquo;re opting in to including credentials.</source>
          <target state="translated">该 &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; 与头部结合工作&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials&quot;&gt; &lt;code&gt;XMLHttpRequest.withCredentials&lt;/code&gt; &lt;/a&gt;财产或与 &lt;code&gt;credentials&lt;/code&gt; 的选项&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request/Request&quot;&gt; &lt;code&gt;Request()&lt;/code&gt; &lt;/a&gt;的提取API的构造。对于具有凭据的CORS请求，为了使浏览器将响应公开给前端JavaScript代码，服务器（使用 &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; 标头）和客户端（通过为XHR设置凭据模式，获取，或Ajax请求）必须表明他们选择加入凭据。</target>
        </trans-unit>
        <trans-unit id="b7dcdecf1d26a57b7f2c288b092d6918cb0c9128" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; response header indicates whether or not the response to the request can be exposed to the page. It can be exposed when the &lt;code&gt;true&lt;/code&gt; value is returned.</source>
          <target state="translated">的 &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; 响应报头指示的请求的响应是否可以暴露于该页面。返回 &lt;code&gt;true&lt;/code&gt; 值时可以将其公开。</target>
        </trans-unit>
        <trans-unit id="3c6671b887bc83cf312809fdd2c8e99c4197d40f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; response header tells browsers whether to expose the response to frontend JavaScript code when the request's credentials mode (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request/credentials&quot;&gt;&lt;code&gt;Request.credentials&lt;/code&gt;&lt;/a&gt;) is &quot;&lt;code&gt;include&lt;/code&gt;&quot;.</source>
          <target state="translated">的 &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; 响应头告诉浏览器是否以暴露响应于前端JavaScript代码当请求的凭证模式（&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request/credentials&quot;&gt; &lt;code&gt;Request.credentials&lt;/code&gt; &lt;/a&gt;）为&amp;ldquo; &lt;code&gt;include&lt;/code&gt; &amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="f12c8be59963d49889bc73472fd35b514c851a07" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; response header tells browsers whether to expose the response to frontend JavaScript code when the request's credentials mode (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request/credentials&quot;&gt;&lt;code&gt;Request.credentials&lt;/code&gt;&lt;/a&gt;) is &lt;code&gt;include&lt;/code&gt;.</source>
          <target state="translated">的 &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; 响应头告诉浏览器是否以暴露响应于前端JavaScript代码当请求的凭证模式（&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request/credentials&quot;&gt; &lt;code&gt;Request.credentials&lt;/code&gt; &lt;/a&gt;）是 &lt;code&gt;include&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="72353e1b96e08b162b2efe8857a396c5cd57de4d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; header is sent by the server in response to a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/preflight_request&quot;&gt;preflight request&lt;/a&gt;; it lets the client know which &lt;a href=&quot;../../headers&quot;&gt;HTTP headers&lt;/a&gt; are permitted in CORS requests. If the client &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;user agent&lt;/a&gt; finds among the comma-delineated values provided by the header any header name it does not recognize, this error occurs.</source>
          <target state="translated">的 &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; 头是通过响应于所述服务器发送&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/preflight_request&quot;&gt;预检请求&lt;/a&gt; ;它让客户端知道在CORS请求中允许使用哪些&lt;a href=&quot;../../headers&quot;&gt;HTTP标头&lt;/a&gt;。如果客户端&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;用户代理&lt;/a&gt;在标头提供的逗号描述的值中找到它无法识别的任何标头名称，则会发生此错误。</target>
        </trans-unit>
        <trans-unit id="0864906322164b5b88f217b19f6a18996814ca0d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; header is sent by the server to let the client know which headers it supports for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; requests. The value of &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; should be a comma-delineated list of header names, such as &quot;&lt;code&gt;X-Custom-Information&lt;/code&gt;&quot; or any of the standard but non-basic header names (which are always allowed).</source>
          <target state="translated">该 &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; 报头由服务器发送让它支持其头部客户知道&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt;请求。的值 &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; 应该是一个逗号划定标题名称，如&amp;ldquo;的列表中 &lt;code&gt;X-Custom-Information&lt;/code&gt; &amp;rdquo;或任何标准的但非基本报头的名称（始终允许）的。</target>
        </trans-unit>
        <trans-unit id="dd672b7157d867818df2e4b6551047d6d6feb57a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; header is sent by the server to let the client know which headers it supports for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; requests. The value of &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; should be a comma-delineated list of header names, such as &lt;code&gt;&quot;X-Custom-Information&quot;&lt;/code&gt; or any of the standard but non-basic header names (which are always allowed).</source>
          <target state="translated">该 &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; 报头由服务器发送让它支持其头部客户知道&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt;请求。的值 &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; 应该是一个逗号划定标题名称，如列表 &lt;code&gt;&quot;X-Custom-Information&quot;&lt;/code&gt; 或任何标准的但非基本报头的名称（始终允许）的。</target>
        </trans-unit>
        <trans-unit id="7ff32aaa41aa73f3f46503d5b741dbb0efe92ed8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; response header is used in response to a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/preflight_request&quot;&gt;preflight request&lt;/a&gt; which includes the &lt;a href=&quot;access-control-request-headers&quot;&gt;&lt;code&gt;Access-Control-Request-Headers&lt;/code&gt;&lt;/a&gt; to indicate which HTTP headers can be used during the actual request.</source>
          <target state="translated">的 &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; 响应报头在响应用于一个&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/preflight_request&quot;&gt;预检请求&lt;/a&gt;，其中包括所述&lt;a href=&quot;access-control-request-headers&quot;&gt; &lt;code&gt;Access-Control-Request-Headers&lt;/code&gt; &lt;/a&gt;，以指示该HTTP报头可以在实际请求期间使用。</target>
        </trans-unit>
        <trans-unit id="e0316b88b462433d980db8987aaedc7affa9a74d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; header is sent by the server to let the client know what &lt;a href=&quot;../../methods&quot;&gt;HTTP request methods&lt;/a&gt; it supports for CORS requests. The header's value is a comma-delineated string of HTTP method names, such as &lt;a href=&quot;../../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;../../methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt;. If any of the specified values are not recognized by the client &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;user agent&lt;/a&gt;, this error occurs.</source>
          <target state="translated">该 &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; 报头由服务器发送，让客户知道什么是&lt;a href=&quot;../../methods&quot;&gt;HTTP请求方法&lt;/a&gt;它支持CORS请求。标头的值是HTTP方法名称的逗号分隔字符串，例如&lt;a href=&quot;../../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../../methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../../methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; &lt;/a&gt;。如果客户端&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;用户代理&lt;/a&gt;无法识别任何指定的值，则会发生此错误。</target>
        </trans-unit>
        <trans-unit id="77116c8fb41e193fc817da845099a6fb246839d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; response header specifies the method or methods allowed when accessing the resource in response to a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/preflight_request&quot;&gt;preflight request&lt;/a&gt;.</source>
          <target state="translated">的 &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; 响应标头指定响应访问所述资源到一个当该方法或方法允许&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/preflight_request&quot;&gt;预检请求&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="067f39d99ac015284dffa6b70703714ad54ce876" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Access-Control-Expose-Headers&lt;/code&gt; response header indicates which headers can be exposed as part of the response by listing their names.</source>
          <target state="translated">的 &lt;code&gt;Access-Control-Expose-Headers&lt;/code&gt; 响应报头指示哪些报头可以公开为通过列出他们的名字的响应的一部分。</target>
        </trans-unit>
        <trans-unit id="0d0b9369d0f212ed412c895390853280713fe380" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Access-Control-Max-Age&lt;/code&gt; response header indicates how long the results of a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/preflight_request&quot;&gt;preflight request&lt;/a&gt; (that is the information contained in the &lt;a href=&quot;access-control-allow-methods&quot;&gt;&lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;access-control-allow-headers&quot;&gt;&lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt;&lt;/a&gt; headers) can be cached.</source>
          <target state="translated">的 &lt;code&gt;Access-Control-Max-Age&lt;/code&gt; 响应报头指示的结果多久&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/preflight_request&quot;&gt;预检请求&lt;/a&gt;（即包含在信息&lt;a href=&quot;access-control-allow-methods&quot;&gt; &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;access-control-allow-headers&quot;&gt; &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; &lt;/a&gt;头）可以被缓存。</target>
        </trans-unit>
        <trans-unit id="d911724c3b9a4293a98fa691e196743b5241679f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Access-Control-Request-Headers&lt;/code&gt; request header is used by browsers when issuing a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/preflight_request&quot;&gt;preflight request&lt;/a&gt;, to let the server know which &lt;a href=&quot;../headers&quot;&gt;HTTP headers&lt;/a&gt; the client might send when the actual request is made.</source>
          <target state="translated">该 &lt;code&gt;Access-Control-Request-Headers&lt;/code&gt; 发出时，请求头使用的浏览器&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/preflight_request&quot;&gt;预检要求&lt;/a&gt;，让服务器知道哪些&lt;a href=&quot;../headers&quot;&gt;HTTP头&lt;/a&gt;实际的请求时，客户端可能会发送。</target>
        </trans-unit>
        <trans-unit id="dafa896f612431fbab583cf168f3881c2f6b27aa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Access-Control-Request-Headers&lt;/code&gt; request header is used when issuing a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/preflight_request&quot;&gt;preflight request&lt;/a&gt; to let the server know which &lt;a href=&quot;../headers&quot;&gt;HTTP headers&lt;/a&gt; will be used when the actual request is made.</source>
          <target state="translated">的 &lt;code&gt;Access-Control-Request-Headers&lt;/code&gt; 发出请求时报头用于&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/preflight_request&quot;&gt;预检请求&lt;/a&gt;让服务器知道哪些&lt;a href=&quot;../headers&quot;&gt;HTTP头&lt;/a&gt;的实际请求时将被使用。</target>
        </trans-unit>
        <trans-unit id="da80f865ca3264cb02c6582db1c71f9050cac42c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Access-Control-Request-Method&lt;/code&gt; request header is used by browsers when issuing a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/preflight_request&quot;&gt;preflight request&lt;/a&gt;, to let the server know which &lt;a href=&quot;../methods&quot;&gt;HTTP method&lt;/a&gt; will be used when the actual request is made. This header is necessary as the preflight request is always an &lt;a href=&quot;../methods/options&quot;&gt;&lt;code&gt;OPTIONS&lt;/code&gt;&lt;/a&gt; and doesn't use the same method as the actual request.</source>
          <target state="translated">的 &lt;code&gt;Access-Control-Request-Method&lt;/code&gt; 发出请求时报头用于通过浏览器&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/preflight_request&quot;&gt;预检请求&lt;/a&gt;，让服务器知道哪些&lt;a href=&quot;../methods&quot;&gt;HTTP方法&lt;/a&gt;的实际请求时将被使用。此标头是必需的，因为预检请求始终是&lt;a href=&quot;../methods/options&quot;&gt; &lt;code&gt;OPTIONS&lt;/code&gt; &lt;/a&gt;，并且使用的方法与实际请求不同。</target>
        </trans-unit>
        <trans-unit id="9c04d281d947283fc5e13f4243911531dd1e81ae" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Access-Control-Request-Method&lt;/code&gt; request header is used when issuing a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/preflight_request&quot;&gt;preflight request&lt;/a&gt; to let the server know which &lt;a href=&quot;../methods&quot;&gt;HTTP method&lt;/a&gt; will be used when the actual request is made. This header is necessary as the preflight request is always an &lt;a href=&quot;../methods/options&quot;&gt;&lt;code&gt;OPTIONS&lt;/code&gt;&lt;/a&gt; and doesn't use the same method as the actual request.</source>
          <target state="translated">的 &lt;code&gt;Access-Control-Request-Method&lt;/code&gt; 发出请求时报头用于&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/preflight_request&quot;&gt;预检请求&lt;/a&gt;让服务器知道哪些&lt;a href=&quot;../methods&quot;&gt;HTTP方法&lt;/a&gt;的实际请求时将被使用。此标头是必需的，因为预检请求始终是&lt;a href=&quot;../methods/options&quot;&gt; &lt;code&gt;OPTIONS&lt;/code&gt; &lt;/a&gt;，并且不使用与实际请求相同的方法。</target>
        </trans-unit>
        <trans-unit id="c0cd5616b768c68f7ab87609f718d08faf8821ee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Age&lt;/code&gt; header is usually close to zero. If it is &lt;code&gt;Age: 0&lt;/code&gt;, it was probably just fetched from the origin server; otherwise It is usually calculated as a difference between the proxy's current date and the &lt;a href=&quot;date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; general header included in the HTTP response.</source>
          <target state="translated">该 &lt;code&gt;Age&lt;/code&gt; 头通常接近于零。如果是 &lt;code&gt;Age: 0&lt;/code&gt; ，则可能是从原始服务器获取的；否则，通常将其计算为代理的当前日期与HTTP响应中包含的&lt;a href=&quot;date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;常规标头之间的差。</target>
        </trans-unit>
        <trans-unit id="86a92479e304493df13e1947522f656380ef064d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Alt-Svc&lt;/code&gt; HTTP response header is used to advertise alternative services through which the same resource can be reached. An alternative service is defined by a protocol/host/port combination.</source>
          <target state="translated">所述 &lt;code&gt;Alt-Svc&lt;/code&gt; HTTP响应报头被用来通告替代服务，通过该相同的资源可以到达。替代服务由协议/主机/端口组合定义。</target>
        </trans-unit>
        <trans-unit id="58db6b4226911c9c041223607c76d210c4b75632" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Alt-Svc&lt;/code&gt; header is used to list alternate ways to reach this website.</source>
          <target state="translated">在 &lt;code&gt;Alt-Svc&lt;/code&gt; 头用于列表替代方式达到这个网站。</target>
        </trans-unit>
        <trans-unit id="f8bcd29c16619b65da2808b96987a30c145398a8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CONNECT&lt;/code&gt; method establishes a tunnel to the server identified by the target resource.</source>
          <target state="translated">该 &lt;code&gt;CONNECT&lt;/code&gt; 方法建立隧道，通过目标资源标识的服务器。</target>
        </trans-unit>
        <trans-unit id="d62340e78d8072dcadbb02101963582d73906639" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CONNECT&lt;/code&gt; method starts two-way communications with the requested resource. It can be used to open a tunnel.</source>
          <target state="translated">该 &lt;code&gt;CONNECT&lt;/code&gt; 方法开始与所请求的资源双向通信。它可以用来打开隧道。</target>
        </trans-unit>
        <trans-unit id="d8e201387bc9b6658a40f0cd1fa9bd028389520f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CONNECT&lt;/code&gt; starts two-way communications with the requested resource. It can be used to open a tunnel.</source>
          <target state="translated">该 &lt;code&gt;CONNECT&lt;/code&gt; 开始与所请求的资源双向通信。它可以用来打开隧道。</target>
        </trans-unit>
        <trans-unit id="6df08e573a851328603ffe071d7221d02feef0bf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Cache-Control&lt;/code&gt; HTTP header holds &lt;em&gt;directives&lt;/em&gt; (instructions) for &lt;a href=&quot;../caching&quot;&gt;caching&lt;/a&gt; in both requests and responses. A given directive in a request does not mean the same directive should be in the response.</source>
          <target state="translated">所述 &lt;code&gt;Cache-Control&lt;/code&gt; HTTP头保持&lt;em&gt;指示&lt;/em&gt;为（指令）&lt;a href=&quot;../caching&quot;&gt;高速缓存&lt;/a&gt;在两个请求和响应。请求中的给定指令并不意味着响应中应包含相同的指令。</target>
        </trans-unit>
        <trans-unit id="dcb3aeaa30daf04257b5de4b9c07c7b9084e9851" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Cache-Control&lt;/code&gt; general-header field is used to specify directives for caching mechanisms in both requests and responses. Caching directives are unidirectional, meaning that a given directive in a request is not implying that the same directive is to be given in the response.</source>
          <target state="translated">所述 &lt;code&gt;Cache-Control&lt;/code&gt; 通用头字段被用于为请求和响应缓存机制指定指令。高速缓存伪指令是单向的，这意味着请求中的给定伪指令并不意味着在响应中将给出相同的伪指令。</target>
        </trans-unit>
        <trans-unit id="06a62b505dd9b8d1a88549c8be79a0204c13ff7e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Cache-Control&lt;/code&gt; header</source>
          <target state="translated">所述 &lt;code&gt;Cache-Control&lt;/code&gt; 头</target>
        </trans-unit>
        <trans-unit id="61c781f98a9ab9c12f19392e18737aa478f857a2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Cache-control&lt;/code&gt; header</source>
          <target state="translated">所述 &lt;code&gt;Cache-control&lt;/code&gt; 头</target>
        </trans-unit>
        <trans-unit id="c446d7df905a8656f6c8ae1eb3467db307c496ea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Clear-Site-Data&lt;/code&gt; header accepts one or more directives. If all types of data should be cleared, the wildcard directive (&lt;code&gt;&quot;*&quot;&lt;/code&gt;) can be used.</source>
          <target state="translated">的 &lt;code&gt;Clear-Site-Data&lt;/code&gt; 报头接受一个或多个指令。如果应清除所有类型的数据，则可以使用通配符指令（ &lt;code&gt;&quot;*&quot;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="aaa643bf0a85cb5496af99271031c5e3d158467e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Clear-Site-Data&lt;/code&gt; header clears browsing data (cookies, storage, cache) associated with the requesting website. It allows web developers to have more control over the data stored locally by a browser for their origins.</source>
          <target state="translated">在 &lt;code&gt;Clear-Site-Data&lt;/code&gt; 头清除浏览与请求网站相关的数据（饼干，存储，高速缓存）。它使Web开发人员可以更好地控制浏览器在本地存储的数据来源。</target>
        </trans-unit>
        <trans-unit id="f577eabd139f31271f00d10bbba8aad8ea919cc1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Connection&lt;/code&gt; general header controls whether or not the network connection stays open after the current transaction finishes. If the value sent is &lt;code&gt;keep-alive&lt;/code&gt;, the connection is persistent and not closed, allowing for subsequent requests to the same server to be done.</source>
          <target state="translated">该 &lt;code&gt;Connection&lt;/code&gt; 一般报头控制是否该网络连接保持在当前事务结束后打开。如果发送的值是 &lt;code&gt;keep-alive&lt;/code&gt; ，则连接是持久的并且不会关闭，从而允许对同一服务器的后续请求得以完成。</target>
        </trans-unit>
        <trans-unit id="d537fcd6c95a2057cfd4527c292424b94b1ea111" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Connection&lt;/code&gt; header is set to &lt;code&gt;&quot;Upgrade&quot;&lt;/code&gt; to indicate that an upgrade is requested.</source>
          <target state="translated">该 &lt;code&gt;Connection&lt;/code&gt; 头被设置为 &lt;code&gt;&quot;Upgrade&quot;&lt;/code&gt; ，以表明升级请求。</target>
        </trans-unit>
        <trans-unit id="2861dc12e30d4470a55eeb695e751b55e5e6a33a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Content-Disposition&lt;/code&gt; header is defined in the larger context of MIME messages for e-mail, but only a subset of the possible parameters apply to HTTP forms and &lt;a href=&quot;../methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; requests. Only the value &lt;code&gt;form-data&lt;/code&gt;, as well as the optional directive &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;filename&lt;/code&gt;, can be used in the HTTP context.</source>
          <target state="translated">的 &lt;code&gt;Content-Disposition&lt;/code&gt; 报头在MIME消息的电子邮件的更大的范围内定义的，但仅可能的参数的子集应用于HTTP形式和&lt;a href=&quot;../methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt;请求。HTTP上下文中只能使用值 &lt;code&gt;form-data&lt;/code&gt; 以及可选的伪指令 &lt;code&gt;name&lt;/code&gt; 和 &lt;code&gt;filename&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="488c45ed82b63009ef20ba093e068984681301a1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Content-Encoding&lt;/code&gt; entity header is used to compress the media-type. When present, its value indicates which encodings were applied to the entity-body. It lets the client know how to decode in order to obtain the media-type referenced by the &lt;code&gt;Content-Type&lt;/code&gt; header.</source>
          <target state="translated">所述 &lt;code&gt;Content-Encoding&lt;/code&gt; 实体报头被用于压缩媒体类型。如果存在，则其值指示将哪些编码应用于实体。它让客户端知道如何解码以获得由 &lt;code&gt;Content-Type&lt;/code&gt; 标头引用的媒体类型。</target>
        </trans-unit>
        <trans-unit id="43905a4350aba1098e2a710d64c8e9ee9088db8a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Content-Language&lt;/code&gt; header is used to specify the &lt;strong&gt; intended audience of the page&lt;/strong&gt;, and can indicate that this is more than one language.</source>
          <target state="translated">在 &lt;code&gt;Content-Language&lt;/code&gt; 头用于指定&lt;strong&gt;页面的目标受众&lt;/strong&gt;，并能表明这是一种以上的语言。</target>
        </trans-unit>
        <trans-unit id="76fdb5d41ede9d4b6ff14e156b9fc840583f22aa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Content-Language&lt;/code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/entity_header&quot;&gt;entity header&lt;/a&gt; is used to &lt;strong&gt;describe the language(s) intended for the audience&lt;/strong&gt;, so that it allows a user to differentiate according to the users' own preferred language.</source>
          <target state="translated">的 &lt;code&gt;Content-Language&lt;/code&gt; &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/entity_header&quot;&gt;实体头&lt;/a&gt;用于&lt;strong&gt;描述语言（多个）用于观众&lt;/strong&gt;，使得其允许用户根据用户自己的优选语言区分。</target>
        </trans-unit>
        <trans-unit id="a7cdf9f8259b0b027b83c7eabaf300c7bb40cfcd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Content-Language&lt;/code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/entity_header&quot;&gt;entity header&lt;/a&gt; is used to describe the language(s) intended for the audience, so that it allows a user to differentiate according to the users' own preferred language.</source>
          <target state="translated">的 &lt;code&gt;Content-Language&lt;/code&gt; &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/entity_header&quot;&gt;实体头&lt;/a&gt;用于描述语言（一个或多个），用于对于观众来说，使得其允许用户根据用户自己的优选语言区分。</target>
        </trans-unit>
        <trans-unit id="9ceb94b4b8102114799b44b32b66d5292b6f1285" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Content-Length&lt;/code&gt; entity header indicates the size of the entity-body, in bytes, sent to the recipient.</source>
          <target state="translated">在 &lt;code&gt;Content-Length&lt;/code&gt; 的实体报头指示实体主体的大小，以字节为单位，发送到接收方。</target>
        </trans-unit>
        <trans-unit id="5d90bdb5582a8fea93b884b09c9eb8e68632eacc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Content-Location&lt;/code&gt; header indicates an alternate location for the returned data. The principal use is to indicate the URL of a resource transmitted as the result of &lt;a href=&quot;../content_negotiation&quot;&gt;content negotiation&lt;/a&gt;.</source>
          <target state="translated">所述 &lt;code&gt;Content-Location&lt;/code&gt; 报头指示为返回的数据的备用位置。主要用途是指示作为&lt;a href=&quot;../content_negotiation&quot;&gt;内容协商&lt;/a&gt;结果传输的资源的URL 。</target>
        </trans-unit>
        <trans-unit id="23071b7ae3831b0ab8df674533efac8686372e32" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Content-Range&lt;/code&gt; response HTTP header indicates where in a full body message a partial message belongs.</source>
          <target state="translated">的 &lt;code&gt;Content-Range&lt;/code&gt; 响应HTTP报头指示其中一个完整的身体信息的部分消息所属。</target>
        </trans-unit>
        <trans-unit id="7a62e0c2806ef55661c99afdb86b1f8e171c816e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;strong&gt;&lt;dfn&gt;&lt;code&gt;Report-To&lt;/code&gt;&lt;/dfn&gt;&lt;/strong&gt; HTTP response header field instructs the user agent to store reporting endpoints for an origin.</source>
          <target state="translated">在 &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;strong&gt;&lt;dfn&gt; &lt;code&gt;Report-To&lt;/code&gt; &lt;/dfn&gt;&lt;/strong&gt;HTTP响应报头字段指示用户代理存储报告端点原点。</target>
        </trans-unit>
        <trans-unit id="eda7fd480680111156c0cfd188e09b05c5966f8f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Content-Type&lt;/code&gt; entity header is used to indicate the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/MIME_type&quot;&gt;media type&lt;/a&gt; of the resource.</source>
          <target state="translated">的 &lt;code&gt;Content-Type&lt;/code&gt; 实体报头用于指示所述&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/MIME_type&quot;&gt;媒体类型&lt;/a&gt;的资源的。</target>
        </trans-unit>
        <trans-unit id="426d10d47e9cd0040a6dc32d3445f661ae1dd5ab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Cookie&lt;/code&gt; HTTP request header contains stored &lt;a href=&quot;../cookies&quot;&gt;HTTP cookies&lt;/a&gt; previously sent by the server with the &lt;a href=&quot;set-cookie&quot;&gt;&lt;code&gt;Set-Cookie&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">所述 &lt;code&gt;Cookie&lt;/code&gt; 的HTTP请求报头包含存储&lt;a href=&quot;../cookies&quot;&gt;的HTTP cookies&lt;/a&gt;先前通过与所述服务器发送&lt;a href=&quot;set-cookie&quot;&gt; &lt;code&gt;Set-Cookie&lt;/code&gt; &lt;/a&gt;报头。</target>
        </trans-unit>
        <trans-unit id="55cd10bb3eab56fcb3aaa9ed9e419b3b3cdd6947" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Cookie&lt;/code&gt; header is optional and may be omitted if, for example, the browser's privacy settings block cookies.</source>
          <target state="translated">所述 &lt;code&gt;Cookie&lt;/code&gt; 头是可选的，并且如果例如，在浏览器的隐私设置阻止Cookie可以被省略。</target>
        </trans-unit>
        <trans-unit id="906194f2cbb1fc47870cf91c47d3fd010f4ebd31" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DELETE&lt;/code&gt; deletes the specified resource.</source>
          <target state="translated">该 &lt;code&gt;DELETE&lt;/code&gt; 删除指定的资源。</target>
        </trans-unit>
        <trans-unit id="82dc9f4d351ce501d0f5c9cfab64763375d85ec2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DELETE&lt;/code&gt; method deletes the specified resource.</source>
          <target state="translated">该 &lt;code&gt;DELETE&lt;/code&gt; 方法删除指定的资源。</target>
        </trans-unit>
        <trans-unit id="52d55ecc480b283f141b3b6f98cde8cb0145d572" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DNT&lt;/code&gt; (&lt;strong&gt;D&lt;/strong&gt;o &lt;strong&gt;N&lt;/strong&gt;ot &lt;strong&gt;T&lt;/strong&gt;rack) request header indicates the user's tracking preference. It lets users indicate whether they would prefer privacy rather than personalized content.</source>
          <target state="translated">该 &lt;code&gt;DNT&lt;/code&gt; （&lt;strong&gt;d&lt;/strong&gt; &amp;oslash; &lt;strong&gt;&amp;Ntilde;&lt;/strong&gt; OT &lt;strong&gt;Ť&lt;/strong&gt;机架）请求报头指示该用户的跟踪的偏好。它可以让用户指出他们是否更喜欢隐私而不是个性化内容。</target>
        </trans-unit>
        <trans-unit id="1cd717754d93b6be80da07e08c9fb1185b7e6942" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DPR&lt;/code&gt; header is a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Client_hints&quot;&gt;Client Hints&lt;/a&gt; headers which represents the client device pixel ratio (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/DPR&quot;&gt;DPR&lt;/a&gt;), which is the the number of physical device pixels corresponding to every CSS pixel.</source>
          <target state="translated">所述 &lt;code&gt;DPR&lt;/code&gt; 报头是&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Client_hints&quot;&gt;客户机提示&lt;/a&gt;标头表示客户机装置的像素比（&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/DPR&quot;&gt;DPR&lt;/a&gt;），其是对应于每一个像素的CSS物理设备的像素的数目。</target>
        </trans-unit>
        <trans-unit id="71ac6b7e2c0b37cbc89c1ece6a483f1521bccee2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Date&lt;/code&gt; general HTTP header contains the date and time at which the message was originated.</source>
          <target state="translated">的 &lt;code&gt;Date&lt;/code&gt; 一般HTTP报头包含在该消息起源的日期和时间。</target>
        </trans-unit>
        <trans-unit id="2eebea2d9e6a6d288555a242f73a9f9b00abe276" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Device-Memory&lt;/code&gt; header is a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Device_Memory_API&quot;&gt;Device Memory API&lt;/a&gt; header that works like &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Client_hints&quot;&gt;Client Hints&lt;/a&gt; header which represents the approximate amount of RAM client device has.</source>
          <target state="translated">该 &lt;code&gt;Device-Memory&lt;/code&gt; 报头是&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Device_Memory_API&quot;&gt;设备内存API&lt;/a&gt;标头类工程&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Client_hints&quot;&gt;客户提示&lt;/a&gt;首部表示RAM客户端设备的近似量了。</target>
        </trans-unit>
        <trans-unit id="fca5c6f26004ba8e513493500c35759b7d8670d7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Domain&lt;/code&gt; and &lt;code&gt;Path&lt;/code&gt; attributes define the &lt;em&gt;scope&lt;/em&gt; of the cookie: what URLs the cookies should be sent to.</source>
          <target state="translated">该 &lt;code&gt;Domain&lt;/code&gt; 和 &lt;code&gt;Path&lt;/code&gt; 属性定义&lt;em&gt;范围&lt;/em&gt;的cookie：什么网址，饼干应送。</target>
        </trans-unit>
        <trans-unit id="a3b1269bf21dd422aa77c2c9c23ee0803a5f37a5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Domain&lt;/code&gt; and &lt;code&gt;Path&lt;/code&gt; directives define the &lt;em&gt;scope&lt;/em&gt; of the cookie: what URLs the cookies should be sent to.</source>
          <target state="translated">该 &lt;code&gt;Domain&lt;/code&gt; 和 &lt;code&gt;Path&lt;/code&gt; 指示定义&lt;em&gt;范围&lt;/em&gt;的cookie：什么网址，饼干应送。</target>
        </trans-unit>
        <trans-unit id="bae089f0efeafa75b1ab5dc8946d17d6e70ec21e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Domain&lt;/code&gt; attribute specifies which hosts are allowed to receive the cookie. If unspecified, it defaults to the same &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/origin&quot;&gt;origin&lt;/a&gt; that set the cookie, &lt;em&gt;excluding subdomains&lt;/em&gt;. If &lt;code&gt;Domain&lt;/code&gt;&lt;em&gt;is&lt;/em&gt; specified, then subdomains are always included. Therefore, specifying &lt;code&gt;Domain&lt;/code&gt; is less restrictive than omitting it. However, it can be helpful when subdomains need to share information about a user.</source>
          <target state="translated">该 &lt;code&gt;Domain&lt;/code&gt; 属性指定允许哪些主机接收的cookie。如果未指定，则默认为设置Cookie的相同&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/origin&quot;&gt;来源&lt;/a&gt;（&lt;em&gt;不包括subdomains）&lt;/em&gt;。如果 &lt;code&gt;Domain&lt;/code&gt; &lt;em&gt;被&lt;/em&gt;指定，那么子域总是被包括在内。因此，指定 &lt;code&gt;Domain&lt;/code&gt; 比省略它的限制要少。但是，当子域需要共享有关用户的信息时，这可能会有所帮助。</target>
        </trans-unit>
        <trans-unit id="c9c5ea9e0e528b35e54f97738194b2df17917c31" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ETag&lt;/code&gt; HTTP response header is an identifier for a specific version of a resource. It allows caches to be more efficient, and saves bandwidth, as a web server does not need to send a full response if the content has not changed. On the other side, if the content has changed, etags are useful to help prevent simultaneous updates of a resource from overwriting each other (&quot;mid-air collisions&quot;).</source>
          <target state="translated">的 &lt;code&gt;ETag&lt;/code&gt; 的 HTTP响应报头为资源的特定版本的标识符。它可以使缓存更高效，并节省带宽，因为如果内容未更改，Web服务器不需要发送完整的响应。另一方面，如果内容已更改，则etag有助于防止资源的同时更新相互覆盖（&amp;ldquo;空中冲突&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="08646657870bfe9fc25378ffe7f57b55887a674a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ETag&lt;/code&gt; HTTP response header is an identifier for a specific version of a resource. It lets caches be more efficient and save bandwidth, as a web server does not need to resend a full response if the content has not changed. Additionally, etags help prevent simultaneous updates of a resource from overwriting each other (&lt;a href=&quot;#Caching_of_unchanged_resources&quot;&gt;&quot;mid-air collisions&quot;&lt;/a&gt;).</source>
          <target state="translated">的 &lt;code&gt;ETag&lt;/code&gt; 的HTTP响应报头为资源的特定版本的标识符。它使缓存更高效并节省了带宽，因为如果内容未更改，Web服务器不需要重新发送完整的响应。另外，etag有助于防止资源的同时更新互相覆盖（&lt;a href=&quot;#Caching_of_unchanged_resources&quot;&gt;&amp;ldquo;空中冲突&amp;rdquo;&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="3b330412716d107192b6533fb30bf1581cd40ed2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Early-Data&lt;/code&gt; header is &lt;strong&gt;not&lt;/strong&gt; set by the originator of the request (i.e., a browser).</source>
          <target state="translated">在 &lt;code&gt;Early-Data&lt;/code&gt; 报头&lt;strong&gt;不&lt;/strong&gt;被请求的（即，浏览器）的始发者设定。</target>
        </trans-unit>
        <trans-unit id="26733480324535c0741d6a6528e1941641f5ce19" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Expect-CT&lt;/code&gt; header allows sites to opt in to reporting and/or enforcement of Certificate Transparency requirements, which prevents the use of misissued certificates for that site from going unnoticed.</source>
          <target state="translated">在 &lt;code&gt;Expect-CT&lt;/code&gt; 头部允许以报告和/或证书透明度的要求执行，这将阻止使用misissued证书进行的忽视该网站站点选择。</target>
        </trans-unit>
        <trans-unit id="d45aa61794fa19b9937294984a26564b7a2b70b9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Expect-CT&lt;/code&gt; header allows sites to opt in to reporting and/or enforcement of Certificate Transparency requirements, which prevents the use of misissued certificates for that site from going unnoticed. When a site enables the &lt;code&gt;Expect-CT&lt;/code&gt; header, they are requesting that the browser check that any certificate for that site appears in public CT logs.</source>
          <target state="translated">在 &lt;code&gt;Expect-CT&lt;/code&gt; 头部允许以报告和/或证书透明度的要求执行，这将阻止使用misissued证书进行的忽视该网站站点选择。当站点启用 &lt;code&gt;Expect-CT&lt;/code&gt; 标头时，他们正在请求浏览器检查该站点的任何证书是否出现在公共CT日志中。</target>
        </trans-unit>
        <trans-unit id="5a38756d00a5a11b921674c4de083e3755d47807" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Expect-CT&lt;/code&gt; header lets sites opt in to reporting and/or enforcement of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Certificate_Transparency&quot;&gt;Certificate Transparency&lt;/a&gt; requirements, to prevent the use of misissued certificates for that site from going unnoticed.</source>
          <target state="translated">在 &lt;code&gt;Expect-CT&lt;/code&gt; 头让网站选择在报告和/或执行&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Certificate_Transparency&quot;&gt;证书透明度&lt;/a&gt;的要求，以防止该网站使用misissued证书的忽视。</target>
        </trans-unit>
        <trans-unit id="3c5d41eb6b835eb5ad3b6e94b607f55e721d9fdd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Expect-CT&lt;/code&gt; will likely become obsolete in June 2021. Since May 2018 new certificates are expected to support SCTs by default. Certificates before March 2018 were allowed to have a lifetime of 39 months, those will all be expired in June 2021.</source>
          <target state="translated">该 &lt;code&gt;Expect-CT&lt;/code&gt; 可能会在2021年六月成为过时自2018年5月新的证书，预计在默认情况下，支持糖衣片。2018年3月之前的证书的有效期为39个月，这些证书都将在2021年6月过期。</target>
        </trans-unit>
        <trans-unit id="39f567c805d3b14ec3ccf5444b3918351ca629ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Expect&lt;/code&gt; HTTP request header indicates expectations that need to be fulfilled by the server in order to properly handle the request.</source>
          <target state="translated">该 &lt;code&gt;Expect&lt;/code&gt; HTTP请求头表示期望，需要通过服务器才能满足妥善处理该请求。</target>
        </trans-unit>
        <trans-unit id="ea971246a330c3fd5b0ad3d128ebdbac36f3fb88" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Feature-Policy&lt;/code&gt; header has now been renamed to &lt;code&gt;Permissions-Policy&lt;/code&gt; in the spec, and this article will eventually be updated to reflect that change.</source>
          <target state="translated">该 &lt;code&gt;Feature-Policy&lt;/code&gt; 头现已更名为 &lt;code&gt;Permissions-Policy&lt;/code&gt; 的规范，而本文将最终被更新，以反映这种变化。</target>
        </trans-unit>
        <trans-unit id="9092e5df3d3c5b1e6e4085ebcd0973332a4819a2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Forwarded&lt;/code&gt; header contains information from the &lt;a href=&quot;../proxy_servers_and_tunneling&quot;&gt;reverse proxy servers&lt;/a&gt; that is altered or lost when a proxy is involved in the path of the request.</source>
          <target state="translated">的 &lt;code&gt;Forwarded&lt;/code&gt; 报头包含从信息&lt;a href=&quot;../proxy_servers_and_tunneling&quot;&gt;反向代理服务器&lt;/a&gt;被改变或丢失时代理参与请求的路径。</target>
        </trans-unit>
        <trans-unit id="c43b4a38f617b0e601765fc7fa48f903467c8a77" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Forwarded&lt;/code&gt; header contains information from the client-facing side of proxy servers that is altered or lost when a proxy is involved in the path of the request.</source>
          <target state="translated">的 &lt;code&gt;Forwarded&lt;/code&gt; 报头包含来自被改变或丢失时代理参与请求的路径代理服务器的面向客户端的信息。</target>
        </trans-unit>
        <trans-unit id="e7acf99131e3b502a504dfc606eb81c2fa8a3438" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GET&lt;/code&gt; method requests a representation of the specified resource. Requests using &lt;code&gt;GET&lt;/code&gt; should only retrieve data.</source>
          <target state="translated">该 &lt;code&gt;GET&lt;/code&gt; 方法请求指定资源的表示。使用 &lt;code&gt;GET&lt;/code&gt; 的请求应仅检索数据。</target>
        </trans-unit>
        <trans-unit id="f4a622f1f455f51e4324f29b7983e11b4aa63399" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GET&lt;/code&gt; requests a representation of the specified resource. Requests using &lt;code&gt;GET&lt;/code&gt; should only retrieve data.</source>
          <target state="translated">该 &lt;code&gt;GET&lt;/code&gt; 请求指定资源的表示。使用 &lt;code&gt;GET&lt;/code&gt; 的请求应仅检索数据。</target>
        </trans-unit>
        <trans-unit id="fe2a61ce5f6f874b6cccf46f639263ba9a7751c2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;HEAD&lt;/code&gt; method asks for a response identical to that of a &lt;code&gt;GET&lt;/code&gt; request, but without the response body.</source>
          <target state="translated">的 &lt;code&gt;HEAD&lt;/code&gt; 方法请求等同于一个的响应 &lt;code&gt;GET&lt;/code&gt; 请求，但是没有响应体。</target>
        </trans-unit>
        <trans-unit id="8ab0b6ae10182c291f380700fbca30952dcca777" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;HEAD&lt;/code&gt; requests the &lt;a href=&quot;../headers&quot;&gt;headers&lt;/a&gt; that would be returned if the &lt;code&gt;HEAD&lt;/code&gt; request's URL was instead requested with the HTTP &lt;a href=&quot;get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; method. For example, if a URL might produce a large download, a &lt;code&gt;HEAD&lt;/code&gt; request could read its &lt;a href=&quot;../headers/content-length&quot;&gt;&lt;code&gt;Content-Length&lt;/code&gt;&lt;/a&gt; header to check the filesize without actually downloading the file.</source>
          <target state="translated">该 &lt;code&gt;HEAD&lt;/code&gt; 请求&lt;a href=&quot;../headers&quot;&gt;头&lt;/a&gt;，如果是将返回 &lt;code&gt;HEAD&lt;/code&gt; 请求的URL是不是与HTTP请求的&lt;a href=&quot;get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;方法。例如，如果URL可能产生大量下载，则 &lt;code&gt;HEAD&lt;/code&gt; 请求可以读取其&lt;a href=&quot;../headers/content-length&quot;&gt; &lt;code&gt;Content-Length&lt;/code&gt; &lt;/a&gt;标头以检查文件大小，而无需实际下载文件。</target>
        </trans-unit>
        <trans-unit id="bcdb3000e143a76a0cbe83303746d3c1a0deba82" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;HEAD&lt;/code&gt; requests the headers that are returned if the specified resource would be requested with an HTTP &lt;a href=&quot;get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; method. Such a request can be done before deciding to download a large resource to save bandwidth, for example.</source>
          <target state="translated">该 &lt;code&gt;HEAD&lt;/code&gt; 请求如果指定的资源将通过一个HTTP请求所返回的头&lt;a href=&quot;get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;方法。例如，可以在决定下载大量资源以节省带宽之前完成此请求。</target>
        </trans-unit>
        <trans-unit id="25050b6d25bf48e5e860b9e13a504c685ed5f20b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;HttpOnly&lt;/code&gt; cookie attribute can help to mitigate this attack by preventing access to cookie value through JavaScript.</source>
          <target state="translated">在 &lt;code&gt;HttpOnly&lt;/code&gt; cookie的属性可以帮助缓解防止通过JavaScript访问cookie值这种攻击。</target>
        </trans-unit>
        <trans-unit id="4db136fae95161e355b0319d6e24b7eb8dde4690" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;If-Match&lt;/code&gt; HTTP request header makes the request conditional. For &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt; methods, the server will send back the requested resource only if it matches one of the listed &lt;code&gt;ETags&lt;/code&gt;. For &lt;a href=&quot;../methods/put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt; and other non-safe methods, it will only upload the resource in this case.</source>
          <target state="translated">的 &lt;code&gt;If-Match&lt;/code&gt; 的HTTP请求报头使得所述请求为条件。对于&lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; &lt;/a&gt;方法，服务器仅在与列出的 &lt;code&gt;ETags&lt;/code&gt; 之一匹配时才发送回所请求的资源。对于&lt;a href=&quot;../methods/put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/a&gt;和其他非安全方法，在这种情况下，它将仅上载资源。</target>
        </trans-unit>
        <trans-unit id="89b34bc5ae9734af9081d0e5ea57512f4460ba59" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;If-Modified-Since&lt;/code&gt; request HTTP header makes the request conditional: the server will send back the requested resource, with a &lt;a href=&quot;../status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt; status, only if it has been last modified after the given date. If the request has not been modified since, the response will be a &lt;a href=&quot;../status/304&quot;&gt;&lt;code&gt;304&lt;/code&gt;&lt;/a&gt; without any body; the &lt;a href=&quot;last-modified&quot;&gt;&lt;code&gt;Last-Modified&lt;/code&gt;&lt;/a&gt; response header of a previous request will contain the date of last modification. Unlike &lt;a href=&quot;if-unmodified-since&quot;&gt;&lt;code&gt;If-Unmodified-Since&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;If-Modified-Since&lt;/code&gt; can only be used with a &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在 &lt;code&gt;If-Modified-Since&lt;/code&gt; 请求HTTP标头发出请求的条件：服务器会发送回所请求的资源，具有&lt;a href=&quot;../status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; 种&lt;/a&gt;状态，只有当它已经给定的日期之后被最后修改。如果此后未修改请求，则响应为&lt;a href=&quot;../status/304&quot;&gt; &lt;code&gt;304&lt;/code&gt; ,&lt;/a&gt;没有任何正文；&lt;a href=&quot;last-modified&quot;&gt; &lt;code&gt;Last-Modified&lt;/code&gt; &lt;/a&gt;一个请求的Last-Modified响应标头将包含上次修改的日期。与&lt;a href=&quot;if-unmodified-since&quot;&gt; &lt;code&gt;If-Unmodified-Since&lt;/code&gt; 不同&lt;/a&gt;， &lt;code&gt;If-Modified-Since&lt;/code&gt; 只能与&lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; 一起使用&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5986b8f11ba0994d8a72e97fe21f90cc137ceae5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;If-None-Match&lt;/code&gt; HTTP request header makes the request conditional. For &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt; methods, the server will send back the requested resource, with a &lt;a href=&quot;../status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt; status, only if it doesn't have an &lt;a href=&quot;etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt; matching the given ones. For other methods, the request will be processed only if the eventually existing resource's &lt;a href=&quot;etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt; doesn't match any of the values listed.</source>
          <target state="translated">所述 &lt;code&gt;If-None-Match&lt;/code&gt; 的HTTP请求报头使得所述请求为条件。对于&lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; &lt;/a&gt;方法，仅当服务器没有与给定资源匹配的&lt;a href=&quot;etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; 时&lt;/a&gt;，服务器才会以&lt;a href=&quot;../status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt;状态发送回请求的资源。对于其他方法，仅当最终现有资源的&lt;a href=&quot;etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt;与列出的任何值都不匹配时，才会处理请求。</target>
        </trans-unit>
        <trans-unit id="2724d0a408c5f3bcd5c0014c571f5f10868e51ea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;If-Range&lt;/code&gt; HTTP request header makes a range request conditional: if the condition is fulfilled, the range request will be issued and the server sends back a &lt;a href=&quot;../status/206&quot;&gt;&lt;code&gt;206&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Partial Content&lt;/code&gt; answer with the appropriate body. If the condition is not fulfilled, the full resource is sent back, with a &lt;a href=&quot;../status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt;&lt;code&gt;OK&lt;/code&gt; status.</source>
          <target state="translated">在 &lt;code&gt;If-Range&lt;/code&gt; HTTP请求头生产一系列要求条件：如果条件满足，范围请求将被发出，服务器发回&lt;a href=&quot;../status/206&quot;&gt; &lt;code&gt;206&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Partial Content&lt;/code&gt; 用适当的身体答案。如果不满足该条件，则以&lt;a href=&quot;../status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt; &lt;code&gt;OK&lt;/code&gt; 状态发送完整资源。</target>
        </trans-unit>
        <trans-unit id="22163b61a8a59a375d09bff2ee1f49eb81aa2552" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;If-Unmodified-Since&lt;/code&gt; request HTTP header makes the request conditional: the server will send back the requested resource, or accept it in the case of a &lt;a href=&quot;../methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; or another non-&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/safe&quot;&gt;safe&lt;/a&gt; method, only if it has not been last modified after the given date. If the request has been modified after the given date, the response will be a &lt;a href=&quot;../status/412&quot;&gt;&lt;code&gt;412&lt;/code&gt;&lt;/a&gt; (Precondition Failed) error.</source>
          <target state="translated">在 &lt;code&gt;If-Unmodified-Since&lt;/code&gt; 请求的HTTP标头，使有条件的请求：服务器会发送回所请求的资源，或者接受它的情况下&lt;a href=&quot;../methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt;或其他非&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/safe&quot;&gt;安全的&lt;/a&gt;方法，只有当它尚未最后给出修改后日期。如果在给定日期之后修改了请求，则响应将是&lt;a href=&quot;../status/412&quot;&gt; &lt;code&gt;412&lt;/code&gt; &lt;/a&gt;（失败的前提条件）错误。</target>
        </trans-unit>
        <trans-unit id="33d2652dcdd336882d1ff7dcd4aab424143119d0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;If-Unmodified-Since&lt;/code&gt; request HTTP header makes the request conditional: the server will send back the requested resource, or accept it in the case of a &lt;a href=&quot;../methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; or another non-&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/safe&quot;&gt;safe&lt;/a&gt; method, only if it has not been last modified after the given date. If the resource has been modified after the given date, the response will be a &lt;a href=&quot;../status/412&quot;&gt;&lt;code&gt;412&lt;/code&gt;&lt;/a&gt; (Precondition Failed) error.</source>
          <target state="translated">在 &lt;code&gt;If-Unmodified-Since&lt;/code&gt; 请求的HTTP标头，使有条件的请求：服务器会发送回所请求的资源，或者接受它的情况下&lt;a href=&quot;../methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt;或其他非&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/safe&quot;&gt;安全的&lt;/a&gt;方法，只有当它尚未最后给出修改后日期。如果资源已在指定日期之后被修改，响应将是&lt;a href=&quot;../status/412&quot;&gt; &lt;code&gt;412&lt;/code&gt; &lt;/a&gt;（预处理失败）错误。</target>
        </trans-unit>
        <trans-unit id="c6e9dbc2bd4ee3beeb7dae2fbab0d0ed4f0f0c7e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Large-Allocation&lt;/code&gt; header throws warnings or error messages when used incorrectly. You'll encounter them in the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Tools/Web_Console&quot;&gt;web console&lt;/a&gt;.</source>
          <target state="translated">如果使用不正确， &lt;code&gt;Large-Allocation&lt;/code&gt; 标头将引发警告或错误消息。您将在&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Tools/Web_Console&quot;&gt;网络控制台中&lt;/a&gt;遇到它们。</target>
        </trans-unit>
        <trans-unit id="1f7bbba0c2fe1da5cfd40ee4dbb5a457286f63d9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Last-Modified&lt;/code&gt; response HTTP header contains the date and time at which the origin server believes the resource was last modified. It is used as a validator to determine if a resource received or stored is the same. Less accurate than an &lt;a href=&quot;etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt; header, it is a fallback mechanism. Conditional requests containing &lt;a href=&quot;if-modified-since&quot;&gt;&lt;code&gt;If-Modified-Since&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;if-unmodified-since&quot;&gt;&lt;code&gt;If-Unmodified-Since&lt;/code&gt;&lt;/a&gt; headers make use of this field.</source>
          <target state="translated">在 &lt;code&gt;Last-Modified&lt;/code&gt; 响应HTTP报头包含在其原始服务器认为该资源的最后修改的日期和时间。它用作验证器来确定接收或存储的资源是否相同。不如&lt;a href=&quot;etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt;标头准确，它是一种后备机制。包含&lt;a href=&quot;if-modified-since&quot;&gt; &lt;code&gt;If-Modified-Since&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;if-unmodified-since&quot;&gt; &lt;code&gt;If-Unmodified-Since&lt;/code&gt; &lt;/a&gt;标头的条件请求将使用此字段。</target>
        </trans-unit>
        <trans-unit id="408faa70ae199f0916e25f0545a45cf1159c3a15" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Location&lt;/code&gt; response header indicates the URL to redirect a page to. It only provides a meaning when served with a &lt;code&gt;3xx&lt;/code&gt; (redirection) or &lt;code&gt;201&lt;/code&gt; (created) status response.</source>
          <target state="translated">该 &lt;code&gt;Location&lt;/code&gt; 响应头表示URL的页面重定向到。它仅在提供 &lt;code&gt;3xx&lt;/code&gt; （重定向）或 &lt;code&gt;201&lt;/code&gt; （已创建）状态响应时提供含义。</target>
        </trans-unit>
        <trans-unit id="7d4bbe1245321cac039158aa76ac84b747faeeee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;OPTIONS&lt;/code&gt; is used to describe the communication options for the target resource. The client can specify a URL for the OPTIONS method, or an asterisk (*) to refer to the entire server.</source>
          <target state="translated">该 &lt;code&gt;OPTIONS&lt;/code&gt; 是用来描述目标资源的通讯选择。客户端可以为OPTIONS方法指定URL，也可以为星号（*）指定整个服务器。</target>
        </trans-unit>
        <trans-unit id="87018d773f4ad1701e531629a9f995260745c1b0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;OPTIONS&lt;/code&gt; method is used to describe the communication options for the target resource.</source>
          <target state="translated">的 &lt;code&gt;OPTIONS&lt;/code&gt; 方法被用来描述用于目标资源的通信选项。</target>
        </trans-unit>
        <trans-unit id="a6e38b6b645f385912507ae1ea58453222ae125b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;OPTIONS&lt;/code&gt; requests permitted communication options for a given URL or server. A client can specify a URL with this method, or an asterisk (&lt;code&gt;*&lt;/code&gt;) to refer to the entire server.</source>
          <target state="translated">在 &lt;code&gt;OPTIONS&lt;/code&gt; 请求允许给定的URL或服务器的通信选项。客户端可以使用此方法指定URL，也可以指定星号（ &lt;code&gt;*&lt;/code&gt; ）来引用整个服务器。</target>
        </trans-unit>
        <trans-unit id="1a07a0f8f183e5dac76997068b2e3c2b7238732b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Origin&lt;/code&gt; request header indicates where a fetch originates from. It doesn't include any path information, but only the server name. It is sent with &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; requests, as well as with &lt;a href=&quot;../methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; requests. It is similar to the &lt;a href=&quot;referer&quot;&gt;&lt;code&gt;Referer&lt;/code&gt;&lt;/a&gt; header, but, unlike this header, it doesn't disclose the whole path.</source>
          <target state="translated">的 &lt;code&gt;Origin&lt;/code&gt; 请求报头指示其中一个取从起源。它不包含任何路径信息，而仅包含服务器名称。它与&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt;请求以及&lt;a href=&quot;../methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt;请求一起发送。它与&lt;a href=&quot;referer&quot;&gt; &lt;code&gt;Referer&lt;/code&gt; &lt;/a&gt;标头类似，但是与标头不同，它没有公开整个路径。</target>
        </trans-unit>
        <trans-unit id="fbfda01971457a54151941075f2b100b82e48523" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PATCH&lt;/code&gt; applies partial modifications to a resource.</source>
          <target state="translated">该 &lt;code&gt;PATCH&lt;/code&gt; 适用于部分修改的资源。</target>
        </trans-unit>
        <trans-unit id="f9159e5596093f157b377894f822a924c1cb222b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PATCH&lt;/code&gt; method is used to apply partial modifications to a resource.</source>
          <target state="translated">该 &lt;code&gt;PATCH&lt;/code&gt; 方法用于局部修改应用到的资源。</target>
        </trans-unit>
        <trans-unit id="1f5331c568d957daee441f1fc46cb653dfa3c711" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;POST&lt;/code&gt; method is used to submit an entity to the specified resource, often causing a change in state or side effects on the server.</source>
          <target state="translated">该 &lt;code&gt;POST&lt;/code&gt; 方法用于提交一个实体到指定的资源，往往造成在服务器上的状态或副作用的变化。</target>
        </trans-unit>
        <trans-unit id="3be3fad872235976dca00e40191bbd8a2412e11e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;POST&lt;/code&gt; sends data to the server. The type of the body of the request is indicated by the &lt;a href=&quot;../headers/content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">该 &lt;code&gt;POST&lt;/code&gt; 将数据发送到服务器。请求主体的&lt;a href=&quot;../headers/content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt;由Content-Type标头指示。</target>
        </trans-unit>
        <trans-unit id="fa5fa4af532ebd69d21f151a379cfa743406c0e6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PUT&lt;/code&gt; creates a new resource or replaces a representation of the target resource with the request payload.</source>
          <target state="translated">该 &lt;code&gt;PUT&lt;/code&gt; 创建一个新的资源或替换请求负载目标资源的表示。</target>
        </trans-unit>
        <trans-unit id="c05eb025eb7c8b4be7ac86b298f646c06fa3ba3d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PUT&lt;/code&gt; method replaces all current representations of the target resource with the request payload.</source>
          <target state="translated">该 &lt;code&gt;PUT&lt;/code&gt; 方法替换请求负载目标资源的所有当前表示。</target>
        </trans-unit>
        <trans-unit id="6881c728a58c81e16c491c3900a0cb662b6f7797" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Path&lt;/code&gt; attribute indicates a URL path that must exist in the requested URL in order to send the &lt;code&gt;Cookie&lt;/code&gt; header. The &lt;code&gt;%x2F&lt;/code&gt; (&quot;/&quot;) character is considered a directory separator, and subdirectories match as well.</source>
          <target state="translated">该 &lt;code&gt;Path&lt;/code&gt; 属性表示必须存在请求的URL，以发送一个URL路径 &lt;code&gt;Cookie&lt;/code&gt; 头。所述 &lt;code&gt;%x2F&lt;/code&gt; （&amp;ldquo;/&amp;rdquo;）字符被认为是一个目录分隔符，和子目录匹配也是如此。</target>
        </trans-unit>
        <trans-unit id="0c89f21cbe09b59b1b9abe85e9acdd8ee45935d9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Pragma&lt;/code&gt; header</source>
          <target state="translated">该 &lt;code&gt;Pragma&lt;/code&gt; 头</target>
        </trans-unit>
        <trans-unit id="d99324cd748dcc4ddf7bf1ab613ab29af0de9abc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Proxy-Authenticate&lt;/code&gt; header is sent along with a &lt;a href=&quot;../status/407&quot;&gt;&lt;code&gt;407&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Proxy Authentication Required&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;Proxy-Authenticate&lt;/code&gt; 报头与一个发送沿&lt;a href=&quot;../status/407&quot;&gt; &lt;code&gt;407&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Proxy Authentication Required&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="38b88eeb5a1167fff3d87ac75a5f9789ffbc4ed1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Range&lt;/code&gt; HTTP request header indicates the part of a document that the server should return. Several parts can be requested with one &lt;code&gt;Range&lt;/code&gt; header at once, and the server may send back these ranges in a multipart document. If the server sends back ranges, it uses the &lt;a href=&quot;../status/206&quot;&gt;&lt;code&gt;206&lt;/code&gt;&lt;/a&gt;&lt;code&gt; Partial Content&lt;/code&gt; for the response. If the ranges are invalid, the server returns the &lt;a href=&quot;../status/416&quot;&gt;&lt;code&gt;416&lt;/code&gt;&lt;/a&gt;&lt;code&gt; Range Not Satisfiable&lt;/code&gt; error. The server can also ignore the &lt;code&gt;Range&lt;/code&gt; header and return the whole document with a &lt;a href=&quot;../status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt; status code.</source>
          <target state="translated">的 &lt;code&gt;Range&lt;/code&gt; 的HTTP请求报头指示一个文件，该服务器应返回的一部分。可以一次请求一个 &lt;code&gt;Range&lt;/code&gt; 标头来请求多个部分，服务器可以将这些范围发送回多部分文档中。如果服务器发回范围，则它将&lt;a href=&quot;../status/206&quot;&gt; &lt;code&gt;206&lt;/code&gt; &lt;/a&gt; &lt;code&gt; Partial Content&lt;/code&gt; 用于响应。如果范围无效，则服务器将返回&lt;a href=&quot;../status/416&quot;&gt; &lt;code&gt;416&lt;/code&gt; &lt;/a&gt; &lt;code&gt; Range Not Satisfiable&lt;/code&gt; 错误。服务器还可以忽略 &lt;code&gt;Range&lt;/code&gt; 标头，并以&lt;a href=&quot;../status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt;状态代码返回整个文档。</target>
        </trans-unit>
        <trans-unit id="31b15d048b735cd58d12cb36f1c04b433a92d0de" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Range&lt;/code&gt; HTTP request header indicates the part of a document that the server should return. Several parts can be requested with one &lt;code&gt;Range&lt;/code&gt; header at once, and the server may send back these ranges in a multipart document. If the server sends back ranges, it uses the &lt;a href=&quot;../status/206&quot;&gt;&lt;code&gt;206&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Partial Content&lt;/code&gt; for the response. If the ranges are invalid, the server returns the &lt;a href=&quot;../status/416&quot;&gt;&lt;code&gt;416&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Range Not Satisfiable&lt;/code&gt; error. The server can also ignore the &lt;code&gt;Range&lt;/code&gt; header and return the whole document with a &lt;a href=&quot;../status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt; status code.</source>
          <target state="translated">的 &lt;code&gt;Range&lt;/code&gt; 的HTTP请求报头指示一个文件，该服务器应返回的一部分。可以一次请求一个 &lt;code&gt;Range&lt;/code&gt; 标头来请求多个部分，服务器可以将这些范围发送回多部分文档中。如果服务器发回范围，则它将&lt;a href=&quot;../status/206&quot;&gt; &lt;code&gt;206&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Partial Content&lt;/code&gt; 用于响应。如果范围无效，则服务器返回&lt;a href=&quot;../status/416&quot;&gt; &lt;code&gt;416&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Range Not Satisfiable&lt;/code&gt; 错误。服务器还可以忽略 &lt;code&gt;Range&lt;/code&gt; 标头，并以&lt;a href=&quot;../status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt;状态代码返回整个文档。</target>
        </trans-unit>
        <trans-unit id="5d730336d5f314e4ffb348e65cc342c819634ceb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Referrer-Policy&lt;/code&gt; HTTP header governs which referrer information, sent in the &lt;a href=&quot;referer&quot;&gt;&lt;code&gt;Referer&lt;/code&gt;&lt;/a&gt; header, should be included with requests made.</source>
          <target state="translated">所述 &lt;code&gt;Referrer-Policy&lt;/code&gt; HTTP头共治其中引荐信息，在所发送&lt;a href=&quot;referer&quot;&gt; &lt;code&gt;Referer&lt;/code&gt; &lt;/a&gt;报头，应包含的请求。</target>
        </trans-unit>
        <trans-unit id="76239ca8ee1c72f207bd371031df7511a9737ea4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Referrer-Policy&lt;/code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTTP_header&quot;&gt;HTTP header&lt;/a&gt; controls how much &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Referer_header:_privacy_and_security_concerns&quot;&gt;referrer information&lt;/a&gt; (sent via the &lt;a href=&quot;referer&quot;&gt;&lt;code&gt;Referer&lt;/code&gt;&lt;/a&gt; header) should be included with requests.</source>
          <target state="translated">所述 &lt;code&gt;Referrer-Policy&lt;/code&gt; &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTTP_header&quot;&gt;HTTP标头&lt;/a&gt;控制多少&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Referer_header:_privacy_and_security_concerns&quot;&gt;引荐信息&lt;/a&gt;（通过发送&lt;a href=&quot;referer&quot;&gt; &lt;code&gt;Referer&lt;/code&gt; &lt;/a&gt;报头）应包含的请求。</target>
        </trans-unit>
        <trans-unit id="471a084b48fd4c8723f09a90baa8df53c1cd93e2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Retry-After&lt;/code&gt; response HTTP header indicates how long the user agent should wait before making a follow-up request. There are three main cases this header is used:</source>
          <target state="translated">的 &lt;code&gt;Retry-After&lt;/code&gt; 响应HTTP报头指示所述用户代理应该多长时间使一个后续请求之前等待。使用此标头的主要情况有三种：</target>
        </trans-unit>
        <trans-unit id="cd701418d7c6bf62926c6ad09e3776653cf803d5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SameSite&lt;/code&gt; attribute accepts three values:</source>
          <target state="translated">该 &lt;code&gt;SameSite&lt;/code&gt; 属性接受三个值：</target>
        </trans-unit>
        <trans-unit id="12bf22b5dbc2a8c45c1d6d8c1615396a45809438" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SameSite&lt;/code&gt; attribute lets servers require that a cookie shouldn't be sent with cross-origin requests (where &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Site&quot;&gt;Site&lt;/a&gt; is defined by the registrable domain), which provides some protection against cross-site request forgery attacks (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CSRF&quot;&gt;CSRF&lt;/a&gt;).</source>
          <target state="translated">该 &lt;code&gt;SameSite&lt;/code&gt; 属性让服务器需要一个cookie不应与跨域请求（其中发送&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Site&quot;&gt;站点&lt;/a&gt;被注册的域名所定义的），它提供了对跨站请求伪造攻击的一些保护（&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CSRF&quot;&gt;CSRF&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="c183288b7bfb9b7d64e4bb9f606b605293a750ad" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SameSite&lt;/code&gt; attribute of the &lt;a href=&quot;../set-cookie&quot;&gt;&lt;code&gt;Set-Cookie&lt;/code&gt;&lt;/a&gt; HTTP response header allows you to declare if your cookie should be restricted to a first-party or same-site context.</source>
          <target state="translated">&lt;a href=&quot;../set-cookie&quot;&gt; &lt;code&gt;Set-Cookie&lt;/code&gt; &lt;/a&gt; HTTP响应标头的 &lt;code&gt;SameSite&lt;/code&gt; 属性允许您声明cookie是否应限制在第一方或同一站点上下文中。</target>
        </trans-unit>
        <trans-unit id="ff9a7daddb986f8f3e9947219b02e125a02e07a1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Save-Data&lt;/code&gt; header field is a boolean which, in requests, indicates the client's preference for reduced data usage. This could be for reasons such as high transfer costs, slow connection speeds, etc.</source>
          <target state="translated">的 &lt;code&gt;Save-Data&lt;/code&gt; 报头字段是一个布尔值，其在请求中，指示客户端对降低的数据使用的偏好。这可能是由于诸如较高的传输成本，较慢的连接速度等原因造成的。</target>
        </trans-unit>
        <trans-unit id="c5c50e0dbd49e9be339d0014ff98de27f5af6b7c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Sec-Fetch-Dest&lt;/code&gt; fetch metadata header indicates the request's destination, that is how the fetched data will be used.</source>
          <target state="translated">所述 &lt;code&gt;Sec-Fetch-Dest&lt;/code&gt; 取的元数据报头指示该请求的目的地，即所获取的数据将如何使用。</target>
        </trans-unit>
        <trans-unit id="31f9900ebfdde4aa1830afd97db024c6b3f830be" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Sec-Fetch-Mode&lt;/code&gt; fetch metadata header indicates the request's mode.</source>
          <target state="translated">所述 &lt;code&gt;Sec-Fetch-Mode&lt;/code&gt; 取的元数据报头指示该请求的模式。</target>
        </trans-unit>
        <trans-unit id="25babdcd9266b9b2ebf26be60ebc0d7bfea878a2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Sec-Fetch-Site&lt;/code&gt; fetch metadata header indicates the relationship between a request initiator's origin and the origin of the resource.</source>
          <target state="translated">所述 &lt;code&gt;Sec-Fetch-Site&lt;/code&gt; 获取的元数据报头指示的请求发起者的原点和该资源的原点之间的关系。</target>
        </trans-unit>
        <trans-unit id="ea3db281f732bb94a4a366b08b7f44ee831dbefd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Sec-Fetch-User&lt;/code&gt; fetch metadata header indicates whether or not a navigation request was triggered by a user activation.</source>
          <target state="translated">该 &lt;code&gt;Sec-Fetch-User&lt;/code&gt; 获取的元数据报头指示的导航请求是否是由用户激活触发。</target>
        </trans-unit>
        <trans-unit id="6374aa4b75562bedbe4aa399825eadf45d2253c3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Sec-WebSocket-Protocol&lt;/code&gt; header specifies one or more WebSocket protocols that you wish to use, in order of preference. The first one that is supported by the server will be selected and returned by the server in a &lt;code&gt;Sec-WebSocket-Protocol&lt;/code&gt; header included in the response. You can use this more than once in the header, as well; the result is the same as if you used a comma-delineated list of subprotocol identifiers in a single header.</source>
          <target state="translated">该 &lt;code&gt;Sec-WebSocket-Protocol&lt;/code&gt; 头指定的一个或多个的WebSocket协议，您要使用，按优先顺序。服务器支持的第一个服务器将在响应中包含的 &lt;code&gt;Sec-WebSocket-Protocol&lt;/code&gt; 标头中选择并返回。您也可以在标题中多次使用它；结果与在单个标头中使用逗号分隔的子协议标识符列表相同。</target>
        </trans-unit>
        <trans-unit id="bcaa9b003cfb51a580c36805f7e5708f883883c8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Server-Timing&lt;/code&gt; header communicates one or more metrics and descriptions for a given request-response cycle. It is used to surface any backend server timing metrics (e.g. database read/write, CPU time, file system access, etc.) in the developer tools in the user's browser or in the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PerformanceServerTiming&quot;&gt;&lt;code&gt;PerformanceServerTiming&lt;/code&gt;&lt;/a&gt; interface.</source>
          <target state="translated">所述 &lt;code&gt;Server-Timing&lt;/code&gt; 头连通的一个或多个度量和说明对于给定的请求响应周期。它用于在用户浏览器或&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PerformanceServerTiming&quot;&gt; &lt;code&gt;PerformanceServerTiming&lt;/code&gt; &lt;/a&gt;界面中的开发人员工具中显示任何后端服务器计时指标（例如，数据库读/写，CPU时间，文件系统访问等）。</target>
        </trans-unit>
        <trans-unit id="58ba7a6637e80a2b7ed529a9998dc728401d3c92" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Server-Timing&lt;/code&gt; header may expose potentially sensitive application and infrastructure information. Consider to control which metrics are returned when and to whom on the server side. For example, you could only show metrics to authenticated users and nothing to the public.</source>
          <target state="translated">该 &lt;code&gt;Server-Timing&lt;/code&gt; 头可能会暴露潜在的敏感应用和基础设施的信息。考虑控制哪些度量标准在服务器端何时以及向谁返回。例如，您只能向经过身份验证的用户显示指标，而不会向公众显示任何指标。</target>
        </trans-unit>
        <trans-unit id="55f111f3d740121c0376e9d447632d82acbbd389" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Set-Cookie&lt;/code&gt; HTTP response header is used to send a cookie from the server to the user agent, so the user agent can send it back to the server later. To send multiple cookies, multiple &lt;code&gt;Set-Cookie&lt;/code&gt; headers should be sent in the same response.</source>
          <target state="translated">所述 &lt;code&gt;Set-Cookie&lt;/code&gt; 的HTTP响应报头用于从服务器向用户代理发送一个cookie，所以用户代理可以稍后发送回服务器。要发送多个Cookie，应在同一响应中发送多个 &lt;code&gt;Set-Cookie&lt;/code&gt; 标头。</target>
        </trans-unit>
        <trans-unit id="1e616d6c13d2c598274b6aa0d7cf7d1cc7921936" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Set-Cookie&lt;/code&gt; HTTP response header is used to send cookies from the server to the user agent.</source>
          <target state="translated">所述 &lt;code&gt;Set-Cookie&lt;/code&gt; 的HTTP响应报头用于从服务器向用户代理发送cookie。</target>
        </trans-unit>
        <trans-unit id="d633495cdc7990d58394c50c8d640450b06b2d19" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Set-Cookie&lt;/code&gt; and &lt;code&gt;Cookie&lt;/code&gt; headers</source>
          <target state="translated">该 &lt;code&gt;Set-Cookie&lt;/code&gt; 和 &lt;code&gt;Cookie&lt;/code&gt; 头</target>
        </trans-unit>
        <trans-unit id="4ee3227d824b48a69ef6dfb672317e9a7fe813f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SourceMap&lt;/code&gt;&lt;a href=&quot;../index&quot;&gt;HTTP&lt;/a&gt; response header links generated code to a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Tools/Debugger/How_to/Use_a_source_map&quot;&gt;source map&lt;/a&gt;, enabling the browser to reconstruct the original source and present the reconstructed original in the debugger.</source>
          <target state="translated">所述 &lt;code&gt;SourceMap&lt;/code&gt; &lt;a href=&quot;../index&quot;&gt;HTTP&lt;/a&gt;生成的代码的响应报头链接&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Tools/Debugger/How_to/Use_a_source_map&quot;&gt;源图&lt;/a&gt;，从而使得浏览器来重构原始源并在调试器呈现重构原始。</target>
        </trans-unit>
        <trans-unit id="cc48476ae000e635700cbc6cc0b3e1b52a2ba404" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Strict-Transport-Security&lt;/code&gt; response header (often abbreviated as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HSTS&quot;&gt;HSTS&lt;/a&gt;) lets a web site tell browsers that it should only be accessed using HTTPS, instead of using HTTP.</source>
          <target state="translated">在 &lt;code&gt;Strict-Transport-Security&lt;/code&gt; 响应报头（通常缩写为&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HSTS&quot;&gt;HSTS&lt;/a&gt;）让网站告诉浏览器中使用HTTPS，而不是使用HTTP，它应该只被访问。</target>
        </trans-unit>
        <trans-unit id="a54300d397ddd96a89ed7e4299d868f45d6d3b45" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;TRACE&lt;/code&gt; method performs a message loop-back test along the path to the target resource.</source>
          <target state="translated">的 &lt;code&gt;TRACE&lt;/code&gt; 方法进行沿着路径到目标资源的消息环回测试。</target>
        </trans-unit>
        <trans-unit id="f4e482563cca8b6b536cb03f419ca214a60b04b7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;TRACE&lt;/code&gt; performs a message loop-back test along the path to the target resource, providing a useful debugging mechanism.</source>
          <target state="translated">的 &lt;code&gt;TRACE&lt;/code&gt; 进行沿着路径到目标资源的消息环回测试，提供了一个有用的调试机制。</target>
        </trans-unit>
        <trans-unit id="24a6cebd134cf5267f57018cea1581d2a79160d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Tk&lt;/code&gt; response header indicates the tracking status that applied to the corresponding request.</source>
          <target state="translated">的 &lt;code&gt;Tk&lt;/code&gt; 的响应报头指示施加到相应的请求的跟踪状态。</target>
        </trans-unit>
        <trans-unit id="661d8abe462ff964e30520abb6a9490ee2f57e77" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Transfer-Encoding&lt;/code&gt; header specifies the form of encoding used to safely transfer the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Entity_header&quot;&gt;entity&lt;/a&gt; to the user.</source>
          <target state="translated">的 &lt;code&gt;Transfer-Encoding&lt;/code&gt; 标头指定编码时使用的安全传送的形式&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Entity_header&quot;&gt;的实体&lt;/a&gt;提供给用户。</target>
        </trans-unit>
        <trans-unit id="e80b8cf0899b9de1fbc8c3b7fc1f7628157f4015" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Transfer-Encoding&lt;/code&gt; header specifies the form of encoding used to safely transfer the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Payload_body&quot;&gt;payload body&lt;/a&gt; to the user.</source>
          <target state="translated">的 &lt;code&gt;Transfer-Encoding&lt;/code&gt; 标头指定编码时使用的安全传输的形式&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Payload_body&quot;&gt;有效载荷体&lt;/a&gt;给用户。</target>
        </trans-unit>
        <trans-unit id="4e4d1816f1bb2e8b52d94106ccb83a944a14eca8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Upgrade&lt;/code&gt; header field may be used by clients to invite a server to switch to one (or more) of the listed protocols, in descending preference order.</source>
          <target state="translated">客户端可以使用&amp;ldquo; &lt;code&gt;Upgrade&lt;/code&gt; 标头&amp;rdquo;字段邀请服务器以优先级降序切换到所列协议中的一个（或多个）。</target>
        </trans-unit>
        <trans-unit id="48fd812100e724a16068b0d9d88fea979cbef78f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Upgrade&lt;/code&gt; header specifies one or more comma-separated protocol names, in order of preference.</source>
          <target state="translated">所述 &lt;code&gt;Upgrade&lt;/code&gt; 头指定的一个或多个以逗号分隔的协议名称，首选项的顺序。</target>
        </trans-unit>
        <trans-unit id="ba632e686f1f5e8841818ed95374f3d49208c686" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;User-Agent&lt;/code&gt; header</source>
          <target state="translated">的 &lt;code&gt;User-Agent&lt;/code&gt; 报头</target>
        </trans-unit>
        <trans-unit id="d7a5f551ef4f873a95fa7564b99b777f320ff383" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Vary&lt;/code&gt; HTTP response header determines how to match future request headers to decide whether a cached response can be used rather than requesting a fresh one from the origin server. It is used by the server to indicate which headers it used when selecting a representation of a resource in a &lt;a href=&quot;../content_negotiation&quot;&gt;content negotiation&lt;/a&gt; algorithm.</source>
          <target state="translated">该 &lt;code&gt;Vary&lt;/code&gt; HTTP响应头决定如何满足未来的请求头，以决定一个缓存的响应是否可以使用，而不是请求从源服务器一个新的一个。服务器使用它来指示在&lt;a href=&quot;../content_negotiation&quot;&gt;内容协商&lt;/a&gt;算法中选择资源表示形式时使用了哪些标头。</target>
        </trans-unit>
        <trans-unit id="b41f5b9f20c1124889bea2cf3b58e60fc1e6c962" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Vary&lt;/code&gt; header can also be useful for serving different content to desktop and mobile users, or to allow search engines to discover the mobile version of a page (and perhaps also tell them that no &lt;a href=&quot;https://en.wikipedia.org/wiki/Cloaking&quot;&gt;Cloaking&lt;/a&gt; is intended). This is usually achieved with the &lt;code&gt;Vary: User-Agent&lt;/code&gt; header, and works because the &lt;a href=&quot;headers/user-agent&quot;&gt;&lt;code&gt;User-Agent&lt;/code&gt;&lt;/a&gt; header value is different for mobile and desktop clients.</source>
          <target state="translated">该 &lt;code&gt;Vary&lt;/code&gt; 头也可以为不同内容提供服务到桌面和移动用户非常有用，或者让搜索引擎发现一个页面的移动版本（也许还告诉他们，没有任何&lt;a href=&quot;https://en.wikipedia.org/wiki/Cloaking&quot;&gt;伪装&lt;/a&gt;的目的）。通常，这可以通过 &lt;code&gt;Vary: User-Agent&lt;/code&gt; 标头实现，并且可以工作，因为移动客户端和桌面客户端的&lt;a href=&quot;headers/user-agent&quot;&gt; &lt;code&gt;User-Agent&lt;/code&gt; &lt;/a&gt;标头值不同。</target>
        </trans-unit>
        <trans-unit id="194b4e9dbe38f2da963d88dc0f228c708df4f3f9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Vary&lt;/code&gt; header should be set on a &lt;a href=&quot;../status/304&quot;&gt;&lt;code&gt;304&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Not Modified&lt;/code&gt; response exactly like it would have been set on an equivalent &lt;a href=&quot;../status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt;&lt;code&gt;OK&lt;/code&gt; response.</source>
          <target state="translated">所述 &lt;code&gt;Vary&lt;/code&gt; 头应在设置&lt;a href=&quot;../status/304&quot;&gt; &lt;code&gt;304&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Not Modified&lt;/code&gt; 响应酷似它会一直集上的等效&lt;a href=&quot;../status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt; &lt;code&gt;OK&lt;/code&gt; 响应。</target>
        </trans-unit>
        <trans-unit id="320c93529dc0245d276d67069f44ba338d5af1d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Vary&lt;/code&gt; header was added in the version 1.1 of HTTP and is necessary in order to allow caches to work appropriately. A cache, in order to work with server-driven content negotiation, needs to know which criteria was used by the server to select the transmitted content. That way, the cache can replay the algorithm and will be able to serve acceptable content directly, without more request to the server. Obviously, the wildcard '&lt;code&gt;*&lt;/code&gt;' prevents caching from occurring, as the cache cannot know what element is behind it.</source>
          <target state="translated">所述 &lt;code&gt;Vary&lt;/code&gt; 头在HTTP的1.1版本，并将是必要的，以便允许高速缓存以适当地工作。为了与服务器驱动的内容协商一起使用，缓存需要知道服务器使用了哪些标准来选择传输的内容。这样，缓存可以重播算法，并且能够直接提供可接受的内容，而无需向服务器发出更多请求。显然，通配符' &lt;code&gt;*&lt;/code&gt; '阻止了缓存的发生，因为缓存无法知道其背后的元素。</target>
        </trans-unit>
        <trans-unit id="76641ba7095f2c68f90780c9306f63f6bf04e9de" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Vary&lt;/code&gt; header was added in the version 1.1 of HTTP and is necessary in order to allow caches to work appropriately. A cache, in order to work with server-driven content negotiation, needs to know which criteria was used by the server to select the transmitted content. That way, the cache can replay the algorithm and will be able to serve acceptable content directly, without more request to the server. Obviously, the wildcard '&lt;code&gt;*&lt;/code&gt;' prevents caching from occurring, as the cache cannot know what element is behind it. For more information &lt;a href=&quot;caching#Varying_responses&quot;&gt;HTTP caching &amp;gt; Varying responses&lt;/a&gt;.</source>
          <target state="translated">所述 &lt;code&gt;Vary&lt;/code&gt; 头在HTTP的1.1版本，并将是必要的，以便允许高速缓存以适当地工作。为了与服务器驱动的内容协商一起使用，缓存需要知道服务器使用了哪些标准来选择传输的内容。这样，缓存可以重播算法，并且能够直接提供可接受的内容，而无需向服务器发出更多请求。显然，通配符' &lt;code&gt;*&lt;/code&gt; '阻止了缓存的发生，因为缓存无法知道其背后的元素。有关更多信息，请参见&lt;a href=&quot;caching#Varying_responses&quot;&gt;HTTP缓存&amp;gt;可变响应&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7b4bde9aa68e310507cb43566d5d20223a7c4d89" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Vary&lt;/code&gt; response header</source>
          <target state="translated">所述 &lt;code&gt;Vary&lt;/code&gt; 响应头</target>
        </trans-unit>
        <trans-unit id="405a63b6723f58e2ec7f579da6d22e1185e2ba24" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;WWW-Authenticate&lt;/code&gt; header is sent along with a &lt;a href=&quot;../status/401&quot;&gt;&lt;code&gt;401&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Unauthorized&lt;/code&gt; response.</source>
          <target state="translated">的 &lt;code&gt;WWW-Authenticate&lt;/code&gt; 报头与一个一起发送&lt;a href=&quot;../status/401&quot;&gt; &lt;code&gt;401&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Unauthorized&lt;/code&gt; 响应。</target>
        </trans-unit>
        <trans-unit id="4c2052dca6314ec4744d6670a2fcfde4364c3176" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Warning&lt;/code&gt; general HTTP header contains information about possible problems with the status of the message. More than one &lt;code&gt;Warning&lt;/code&gt; header may appear in a response.</source>
          <target state="translated">该 &lt;code&gt;Warning&lt;/code&gt; 一般HTTP标头包含有关该消息的状态可能出现的问题的信息。响应中可能会出现多个&amp;ldquo; &lt;code&gt;Warning&lt;/code&gt; 标题。</target>
        </trans-unit>
        <trans-unit id="efe0fdb5e1f6f144e9e814a9d19ed38077ab4d3c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Width&lt;/code&gt; request header field is a number that indicates the desired resource width in physical pixels (i.e. intrinsic size of an image). The provided pixel value is a number rounded to the smallest following integer (i.e. ceiling value).</source>
          <target state="translated">的 &lt;code&gt;Width&lt;/code&gt; 请求报头字段是一个数字，表示在物理像素所需的资源宽度（即图像的固有尺寸）。提供的像素值是四舍五入到最小的后续整数（即上限值）的数字。</target>
        </trans-unit>
        <trans-unit id="e9e5b0e1f18626b41321a488aa80a25f985f1deb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;X-DNS-Prefetch-Control&lt;/code&gt; HTTP response header controls DNS prefetching, a feature by which browsers proactively perform domain name resolution on both links that the user may choose to follow as well as URLs for items referenced by the document, including images, CSS, JavaScript, and so forth.</source>
          <target state="translated">的 &lt;code&gt;X-DNS-Prefetch-Control&lt;/code&gt; HTTP响应报头控制DNS预取，通过该浏览器主动地在两个链路上执行域名解析，用户可以选择遵循以及用于由文档引用的项目，包括图像，CSS URL的特征，JavaScript等。</target>
        </trans-unit>
        <trans-unit id="ff3dc3f28097222bbf317e1c8c99177c20310367" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;X-Forwarded-For&lt;/code&gt; (XFF) header is a de-facto standard header for identifying the originating IP address of a client connecting to a web server through an HTTP proxy or a load balancer. When traffic is intercepted between clients and servers, server access logs contain the IP address of the proxy or load balancer only. To see the original IP address of the client, the &lt;code&gt;X-Forwarded-For&lt;/code&gt; request header is used.</source>
          <target state="translated">该 &lt;code&gt;X-Forwarded-For&lt;/code&gt; （XFF）报头是用于通过HTTP代理或负载平衡器识别连接到web服务器的客户端的原始IP地址的事实上的标准报头。当客户端和服务器之间的流量被拦截时，服务器访问日志仅包含代理或负载平衡器的IP地址。要查看客户端的原始IP地址，请使用 &lt;code&gt;X-Forwarded-For&lt;/code&gt; 请求标头。</target>
        </trans-unit>
        <trans-unit id="482fcec20c0b4ec16aa7ff0f4a40cd4a8e96efd2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;X-Forwarded-Host&lt;/code&gt; (XFH) header is a de-facto standard header for identifying the original host requested by the client in the &lt;a href=&quot;host&quot;&gt;&lt;code&gt;Host&lt;/code&gt;&lt;/a&gt; HTTP request header.</source>
          <target state="translated">该 &lt;code&gt;X-Forwarded-Host&lt;/code&gt; （XFH）报头是用于识别由客户机在所要求的原始主机一个事实上的标准报头&lt;a href=&quot;host&quot;&gt; &lt;code&gt;Host&lt;/code&gt; &lt;/a&gt; HTTP请求报头。</target>
        </trans-unit>
        <trans-unit id="ac80a173a5330f7e0e915503af16d57814a7f24e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;X-Forwarded-Proto&lt;/code&gt; (XFP) header is a de-facto standard header for identifying the protocol (HTTP or HTTPS) that a client used to connect to your proxy or load balancer. Your server access logs contain the protocol used between the server and the load balancer, but not the protocol used between the client and the load balancer. To determine the protocol used between the client and the load balancer, the &lt;code&gt;X-Forwarded-Proto&lt;/code&gt; request header can be used.</source>
          <target state="translated">该 &lt;code&gt;X-Forwarded-Proto&lt;/code&gt; （XFP）报头是用于识别协议（HTTP或HTTPS），其中使用的客户端连接到代理或负载平衡器一个事实上的标准报头。您的服务器访问日志包含服务器和负载平衡器之间使用的协议，但不包含客户端和负载平衡器之间使用的协议。要确定客户端与负载均衡器之间使用的协议，可以使用 &lt;code&gt;X-Forwarded-Proto&lt;/code&gt; 请求标头。</target>
        </trans-unit>
        <trans-unit id="7641932b013d9ddf2ffa745ed9e59704ae3a5eaa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;X-Frame-Options&lt;/code&gt;&lt;a href=&quot;../index&quot;&gt;HTTP&lt;/a&gt; response header can be used to indicate whether or not a browser should be allowed to render a page in a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;&lt;/a&gt; . Sites can use this to avoid &lt;a href=&quot;https://en.wikipedia.org/wiki/clickjacking&quot;&gt;clickjacking&lt;/a&gt; attacks, by ensuring that their content is not embedded into other sites.</source>
          <target state="translated">该 &lt;code&gt;X-Frame-Options&lt;/code&gt; &lt;a href=&quot;../index&quot;&gt;HTTP&lt;/a&gt;响应报头可以被用来指示一个浏览器是否应该被允许在一个以呈现页面&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt; &lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt; &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; &lt;/a&gt;。网站可以通过确保其内容未嵌入其他网站来避免&lt;a href=&quot;https://en.wikipedia.org/wiki/clickjacking&quot;&gt;点击劫持&lt;/a&gt;攻击。</target>
        </trans-unit>
        <trans-unit id="f8fc0e13a5bd95f55b983508d376db1ef57d9475" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;X-Frame-Options&lt;/code&gt;&lt;a href=&quot;../index&quot;&gt;HTTP&lt;/a&gt; response header can be used to indicate whether or not a browser should be allowed to render a page in a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt;&lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;&lt;/a&gt; . Sites can use this to avoid &lt;a href=&quot;https://en.wikipedia.org/wiki/clickjacking&quot;&gt;clickjacking&lt;/a&gt; attacks, by ensuring that their content is not embedded into other sites.</source>
          <target state="translated">该 &lt;code&gt;X-Frame-Options&lt;/code&gt; &lt;a href=&quot;../index&quot;&gt;HTTP&lt;/a&gt;响应报头可以被用来指示一个浏览器是否应该被允许在一个以呈现页面&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt; &lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt; &lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt; &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; &lt;/a&gt;。网站可以通过确保其内容未嵌入其他网站来避免&lt;a href=&quot;https://en.wikipedia.org/wiki/clickjacking&quot;&gt;点击劫持&lt;/a&gt;攻击。</target>
        </trans-unit>
        <trans-unit id="7c716845b63ad60de10c5d0721c333cc0a7789d3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;X-Frame-Options&lt;/code&gt;&lt;a href=&quot;../index&quot;&gt;HTTP&lt;/a&gt; response header can be used to indicate whether or not a browser should be allowed to render a page in a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt;&lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;&lt;/a&gt;. Sites can use this to avoid &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Types_of_attacks#Click-jacking&quot;&gt;click-jacking&lt;/a&gt; attacks, by ensuring that their content is not embedded into other sites.</source>
          <target state="translated">该 &lt;code&gt;X-Frame-Options&lt;/code&gt; &lt;a href=&quot;../index&quot;&gt;HTTP&lt;/a&gt;响应报头可以被用来指示一个浏览器是否应该被允许在一个以呈现页面&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt; &lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt; &lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt; &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; &lt;/a&gt;。网站可以通过确保其内容未嵌入其他网站来避免&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Types_of_attacks#Click-jacking&quot;&gt;点击劫持&lt;/a&gt;攻击。</target>
        </trans-unit>
        <trans-unit id="691c4a3bae3f1a7c0be3c3aed1c8e618e4fcd9e7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;delta-seconds&lt;/code&gt; parameter indicates the number of seconds the results can be cached.</source>
          <target state="translated">该 &lt;code&gt;delta-seconds&lt;/code&gt; 参数表示的秒的结果可以被高速缓存的数量。</target>
        </trans-unit>
        <trans-unit id="b2e68877049d392fb0d9efdba7e61a35e4736a2f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;frame-ancestors&lt;/code&gt; directive&amp;rsquo;s syntax is similar to a source list of other directives (e.g. &lt;a href=&quot;default-src&quot;&gt;&lt;code&gt;default-src&lt;/code&gt;&lt;/a&gt;), but doesn't allow &lt;code&gt;'unsafe-eval'&lt;/code&gt; or &lt;code&gt;'unsafe-inline'&lt;/code&gt; for example. It will also not fall back to a &lt;code&gt;default-src&lt;/code&gt; setting. Only the sources listed below are allowed:</source>
          <target state="translated">该 &lt;code&gt;frame-ancestors&lt;/code&gt; 指令的语法是类似于其它指令（例如源列表&lt;a href=&quot;default-src&quot;&gt; &lt;code&gt;default-src&lt;/code&gt; &lt;/a&gt;），但不允许 &lt;code&gt;'unsafe-eval'&lt;/code&gt; 或 &lt;code&gt;'unsafe-inline'&lt;/code&gt; 例如。它也不会退回到 &lt;code&gt;default-src&lt;/code&gt; 设置。仅允许以下来源：</target>
        </trans-unit>
        <trans-unit id="8325de55392dc75d103db2ad034803012b8edc93" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;frame-ancestors&lt;/code&gt; directive&amp;rsquo;s syntax is similar to a source list of other directives (e.g. &lt;a href=&quot;default-src&quot;&gt;&lt;code&gt;default-src&lt;/code&gt;&lt;/a&gt;, but doesn't allow &lt;code&gt;'unsafe-eval'&lt;/code&gt; or &lt;code&gt;'unsafe-inline'&lt;/code&gt; for example. It will also not fall back to a &lt;code&gt;default-src&lt;/code&gt; setting. Only the sources listed below are allowed:</source>
          <target state="translated">该 &lt;code&gt;frame-ancestors&lt;/code&gt; 指令的语法类似于其它指令的源列表（例如&lt;a href=&quot;default-src&quot;&gt; &lt;code&gt;default-src&lt;/code&gt; &lt;/a&gt;，但不允许 &lt;code&gt;'unsafe-eval'&lt;/code&gt; 或 &lt;code&gt;'unsafe-inline'&lt;/code&gt; 例如，它也不会回落到 &lt;code&gt;default-src&lt;/code&gt; 设置，仅允许以下来源：</target>
        </trans-unit>
        <trans-unit id="e84f1d948281d5568220728b9d276abf0bdd4199" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;https://foo.example&lt;/code&gt; origin is permitted to request the &lt;code&gt;bar.example/resources/post-here/&lt;/code&gt; URL via the following:</source>
          <target state="translated">该 &lt;code&gt;https://foo.example&lt;/code&gt; 起源被允许请求 &lt;code&gt;bar.example/resources/post-here/&lt;/code&gt; URL通过如下：</target>
        </trans-unit>
        <trans-unit id="d731b7e80edba53bed02fe84939621f3420c12d7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;i&lt;/code&gt; makes it case-insensitive, and &lt;code&gt;mobi&lt;/code&gt; matches all mobile browsers.</source>
          <target state="translated">在 &lt;code&gt;i&lt;/code&gt; 使其不区分大小写，并且 &lt;code&gt;mobi&lt;/code&gt; 所有移动浏览器相匹配。</target>
        </trans-unit>
        <trans-unit id="6ff2a01caeced20b51683f18c74fcf809d0a629a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;infile&lt;/code&gt; parameter is the name of the file you wish to encode into base64 format, and &lt;code&gt;remotename&lt;/code&gt; is the remote name for the file, which isn't actually used in &lt;code&gt;data&lt;/code&gt; URLs.</source>
          <target state="translated">该 &lt;code&gt;infile&lt;/code&gt; 参数是要编码的文件转换成Base64格式的名称， &lt;code&gt;remotename&lt;/code&gt; 是文件，这是不实际使用的远程名称 &lt;code&gt;data&lt;/code&gt; 的URL。</target>
        </trans-unit>
        <trans-unit id="604f09cfd89d091aa486d6636b750613f4f96b4d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mediatype&lt;/code&gt; is a &lt;a href=&quot;mime_types&quot;&gt;MIME type&lt;/a&gt; string, such as &lt;code&gt;'image/jpeg'&lt;/code&gt; for a JPEG image file. If omitted, defaults to &lt;code&gt;text/plain;charset=US-ASCII&lt;/code&gt;</source>
          <target state="translated">所述 &lt;code&gt;mediatype&lt;/code&gt; 是一个&lt;a href=&quot;mime_types&quot;&gt;MIME类型&lt;/a&gt;的字符串，如 &lt;code&gt;'image/jpeg'&lt;/code&gt; 为JPEG图像文件。如果省略，则默认为 &lt;code&gt;text/plain;charset=US-ASCII&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8e539bd2196b041a5032c2ef5a8994c7b7bde4dd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mediatype&lt;/code&gt; is a MIME type string, such as &lt;code&gt;'image/jpeg'&lt;/code&gt; for a JPEG image file. If omitted, defaults to &lt;code&gt;text/plain;charset=US-ASCII&lt;/code&gt;</source>
          <target state="translated">所述 &lt;code&gt;mediatype&lt;/code&gt; 是一个MIME类型的字符串，如 &lt;code&gt;'image/jpeg'&lt;/code&gt; 为JPEG图像文件。如果省略，则默认为 &lt;code&gt;text/plain;charset=US-ASCII&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="da52d7b321f788536d3829326d49c595d809fbf1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;multipart/byteranges&lt;/code&gt; MIME type is used to send partial responses to the browser.</source>
          <target state="translated">的 &lt;code&gt;multipart/byteranges&lt;/code&gt; MIME类型被用来发送部分响应给浏览器。</target>
        </trans-unit>
        <trans-unit id="13ff0ccca95ad2dd6f5550002a8ef74789370c1c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;multipart/form-data&lt;/code&gt; type can be used when sending the values of a completed &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Forms&quot;&gt;HTML Form&lt;/a&gt; from browser to server.</source>
          <target state="translated">的 &lt;code&gt;multipart/form-data&lt;/code&gt; 类型可以发送一个完成的值时，可以使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Forms&quot;&gt;HTML表格&lt;/a&gt;从浏览器到服务器。</target>
        </trans-unit>
        <trans-unit id="6d4a04b22f0b8d9d9056086ed2761a4ce7474e18" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;multipart/form-data&lt;/code&gt;type can be used when sending the values of a completed &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Forms&quot;&gt;HTML Form&lt;/a&gt; from browser to server.</source>
          <target state="translated">的 &lt;code&gt;multipart/form-data&lt;/code&gt; 类型可以发送一个完成的值时，可以使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Forms&quot;&gt;HTML表格&lt;/a&gt;从浏览器到服务器。</target>
        </trans-unit>
        <trans-unit id="5ed16b201bb930d269ec462a17331c9fe9b5c948" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no-store&lt;/code&gt; directive will prevent a new resource being cached, but it will not prevent the cache from responding with a non-stale resource that was cached as the result of an earlier request. Setting &lt;code&gt;max-age=0&lt;/code&gt; as well forces the cache to revalidate (clears the cache).</source>
          <target state="translated">在 &lt;code&gt;no-store&lt;/code&gt; 指令将阻止新的资源被缓存，但它不会防止缓存与被缓存作为较早请求的结果非过时资源响应。设置 &lt;code&gt;max-age=0&lt;/code&gt; 也会强制高速缓存重新验证（清除高速缓存）。</target>
        </trans-unit>
        <trans-unit id="2d35dc77974d9a90114bab977a8eb5559894a4d9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;payment&lt;/code&gt; feature's default allowlist value is &lt;code&gt;'self'&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;payment&lt;/code&gt; 功能的默认允许列表值是 &lt;code&gt;'self'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7fa620fbdcb9cf9072c11203ebc2680fadd85c4c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;strict-dynamic&lt;/code&gt; source expression specifies that the trust explicitly given to a script present in the markup, by accompanying it with a nonce or a hash, shall be propagated to all the scripts loaded by that root script. At the same time, any allow-list or source expressions such as &lt;code&gt;'self'&lt;/code&gt; or &lt;code&gt;'unsafe-inline'&lt;/code&gt; are ignored. See &lt;a href=&quot;script-src#strict-dynamic&quot;&gt;script-src&lt;/a&gt; for an example.</source>
          <target state="translated">在 &lt;code&gt;strict-dynamic&lt;/code&gt; 源表达式指定的信任明确给出与存在于标记的脚本，通过用随机数或散列伴随它，应当被传播到所有由根脚本加载的脚本。同时，任何允许列表或源表达式（例如 &lt;code&gt;'self'&lt;/code&gt; 或 &lt;code&gt;'unsafe-inline'&lt;/code&gt; 都将被忽略。有关示例，请参见&lt;a href=&quot;script-src#strict-dynamic&quot;&gt;script-src&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b82adb286ff040efc04b5588e84c42dc13b4b83e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;strict-dynamic&lt;/code&gt; source expression specifies that the trust explicitly given to a script present in the markup, by accompanying it with a nonce or a hash, shall be propagated to all the scripts loaded by that root script. At the same time, any whitelist or source expressions such as &lt;code&gt;'self'&lt;/code&gt; or &lt;code&gt;'unsafe-inline'&lt;/code&gt; will be ignored. See &lt;a href=&quot;script-src#strict-dynamic&quot;&gt;script-src&lt;/a&gt; for an example.</source>
          <target state="translated">在 &lt;code&gt;strict-dynamic&lt;/code&gt; 源表达式指定的信任明确给出与存在于标记的脚本，通过用随机数或散列伴随它，应当被传播到所有由根脚本加载的脚本。同时，所有白名单或源表达式（例如 &lt;code&gt;'self'&lt;/code&gt; 或 &lt;code&gt;'unsafe-inline'&lt;/code&gt; 都将被忽略。有关示例，请参见&lt;a href=&quot;script-src#strict-dynamic&quot;&gt;script-src&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3dc0a625918a10bc3cf47e685dbed66f751c4502" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;upgrade-insecure-requests&lt;/code&gt; directive is evaluated before &lt;a href=&quot;block-all-mixed-content&quot;&gt;&lt;code&gt;block-all-mixed-content&lt;/code&gt;&lt;/a&gt; and if it is set, the latter is effectively a no-op. It is recommended to set either directive, but not both, unless you want to force HTTPS on older browsers that do not force it after a redirect to HTTP.</source>
          <target state="translated">该 &lt;code&gt;upgrade-insecure-requests&lt;/code&gt; 之前指令评估&lt;a href=&quot;block-all-mixed-content&quot;&gt; &lt;code&gt;block-all-mixed-content&lt;/code&gt; &lt;/a&gt;，如果它被设置，后者实际上是一个无操作。建议设置其中一个指令，但不要同时设置两个指令，除非您希望在较旧的浏览器上强制使用HTTPS，而在重定向到HTTP之后不强制使用该浏览器。</target>
        </trans-unit>
        <trans-unit id="67a6354b055d21e0ec5e6eda7647d60f1e916b1c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;upgrade-insecure-requests&lt;/code&gt; directive will not ensure that users visiting your site via links on third-party sites will be upgraded to HTTPS for the top-level navigation and thus does not replace the &lt;a href=&quot;../strict-transport-security&quot;&gt;&lt;code&gt;Strict-Transport-Security&lt;/code&gt;&lt;/a&gt; (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HSTS&quot;&gt;HSTS&lt;/a&gt;) header, which should still be set with an appropriate &lt;code&gt;max-age&lt;/code&gt; to ensure that users are not subject to SSL stripping attacks.</source>
          <target state="translated">该 &lt;code&gt;upgrade-insecure-requests&lt;/code&gt; 指令将不能保证用户通过第三方网站的链接访问您的网站将升级为HTTPS为顶级导航，因此不更换&lt;a href=&quot;../strict-transport-security&quot;&gt; &lt;code&gt;Strict-Transport-Security&lt;/code&gt; &lt;/a&gt;（&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HSTS&quot;&gt;HSTS&lt;/a&gt;）头，其仍应设置适当的 &lt;code&gt;max-age&lt;/code&gt; 以确保用户不受SSL剥离攻击。</target>
        </trans-unit>
        <trans-unit id="6a8d44d29e56bc0c55ce499b78519e2f545a58b8" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;HTTP version&lt;/em&gt;, which defines the structure of the remaining message, acting as an indicator of the expected version to use for the response.</source>
          <target state="translated">的&lt;em&gt;HTTP版本&lt;/em&gt;，它定义了剩余的消息的结构，充当的预期版本的指示符以用于响应。</target>
        </trans-unit>
        <trans-unit id="534c7de6c70ce30d5cc7ac84f7a1d413ddee5f41" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;asterisk form&lt;/em&gt;, a simple asterisk (&lt;code&gt;'*'&lt;/code&gt;) is used with &lt;code&gt;OPTIONS&lt;/code&gt;, representing the server as a whole.</source>
          <target state="translated">的&lt;em&gt;星号形式&lt;/em&gt;，一个简单的星号（ &lt;code&gt;'*'&lt;/code&gt; ）用于 &lt;code&gt;OPTIONS&lt;/code&gt; ，代表服务器作为一个整体。</target>
        </trans-unit>
        <trans-unit id="e9fb04fb929e15b710da1fe284b86de9e6922e23" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;protocol version&lt;/em&gt;, usually &lt;code&gt;HTTP/1.1&lt;/code&gt;.</source>
          <target state="translated">的&lt;em&gt;协议版本&lt;/em&gt;，通常是 &lt;code&gt;HTTP/1.1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="57141383ea92e8d11fc4aae1bb6ea799c9f809f6" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;request target&lt;/em&gt;, usually a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/URL&quot;&gt;URL&lt;/a&gt;, or the absolute path of the protocol, port, and domain are usually characterized by the request context. The format of this request target varies between different HTTP methods. It can be</source>
          <target state="translated">所述&lt;em&gt;请求对象&lt;/em&gt;，通常是一个&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/URL&quot;&gt;URL&lt;/a&gt;，或协议，端口和域的绝对路径通常特征在于请求上下文。此请求目标的格式在不同的HTTP方法之间有所不同。有可能</target>
        </trans-unit>
        <trans-unit id="f9cc4edb4b5b40b8f3c061c79a6b4c632e4c730a" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;user-agent&lt;/em&gt; is any tool that acts on the behalf of the user. This role is primarily performed by the Web browser; a few exceptions being programs used by engineers, and Web developers to debug their applications.</source>
          <target state="translated">所述&lt;em&gt;用户代理&lt;/em&gt;是作用于用户的代表任何工具。该角色主要由Web浏览器执行。工程师和Web开发人员用来调试其应用程序的程序是少数例外。</target>
        </trans-unit>
        <trans-unit id="094e3c74b2c1d28d2f1a69f2c5868e7adb3602cc" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;user-agent&lt;/em&gt; is any tool that acts on the behalf of the user. This role is primarily performed by the Web browser; other possibilities are programs used by engineers and Web developers to debug their applications.</source>
          <target state="translated">所述&lt;em&gt;用户代理&lt;/em&gt;是作用于用户的代表任何工具。该角色主要由Web浏览器执行。其他可能性是工程师和Web开发人员用来调试其应用程序的程序。</target>
        </trans-unit>
        <trans-unit id="88ff728fce867d59850505a9f213412ce8cd201b" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;&lt;var&gt;type&lt;/var&gt;&lt;/strong&gt; represents the general category into which the data type falls, such as &lt;code&gt;video&lt;/code&gt; or &lt;code&gt;text&lt;/code&gt;. The &lt;strong&gt;&lt;var&gt;subtype&lt;/var&gt;&lt;/strong&gt; identifies the exact kind of data of the specified type the MIME type represents. For example, for the MIME type &lt;code&gt;text&lt;/code&gt;, the subtype might be &lt;code&gt;plain&lt;/code&gt; (plain text), &lt;code&gt;html&lt;/code&gt; (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTML&quot;&gt;HTML&lt;/a&gt; source code), or &lt;code&gt;calendar&lt;/code&gt; (for iCalendar/&lt;code&gt;.ics&lt;/code&gt;) files.</source>
          <target state="translated">该&lt;strong&gt; &lt;var&gt;type&lt;/var&gt; &lt;/strong&gt;表示到其中的数据类型下降时，如一般类别 &lt;code&gt;video&lt;/code&gt; 或 &lt;code&gt;text&lt;/code&gt; 。该&lt;strong&gt; &lt;var&gt;subtype&lt;/var&gt; &lt;/strong&gt;识别确切种指定类型的MIME类型表示的数据。例如，对于MIME类型的 &lt;code&gt;text&lt;/code&gt; ，子类型可以是 &lt;code&gt;plain&lt;/code&gt; （纯文本）， &lt;code&gt;html&lt;/code&gt; （&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTML&quot;&gt;HTML&lt;/a&gt;源代码）或 &lt;code&gt;calendar&lt;/code&gt; （对于iCalendar / &lt;code&gt;.ics&lt;/code&gt; ）文件。</target>
        </trans-unit>
        <trans-unit id="8b83df44d3d37a4c410b129685134339244574f5" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Alt-Svc&lt;/strong&gt; header is used to list alternate ways to reach this website.</source>
          <target state="translated">在&lt;strong&gt;按住Alt键SVC&lt;/strong&gt;头用于列表替代方式达到这个网站。</target>
        </trans-unit>
        <trans-unit id="8c3c79f7301c1c8d0fa9e587ad3fa734394dfbe4" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;HTTP DELETE request method&lt;/strong&gt; deletes the specified resource.</source>
          <target state="translated">的&lt;strong&gt;HTTP DELETE请求方法&lt;/strong&gt;删除指定的资源。</target>
        </trans-unit>
        <trans-unit id="8f98d07b9e286fdee4af0bfd151e3fef8b4e1fdf" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;HTTP PATCH request method&lt;/strong&gt; applies partial modifications to a resource.</source>
          <target state="translated">的&lt;strong&gt;HTTP请求PATCH方法&lt;/strong&gt;应用于局部修改的资源。</target>
        </trans-unit>
        <trans-unit id="2f72c255d4cd8cf0faaa3dfd5ef732d3c26ae02b" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;HTTP PUT request method&lt;/strong&gt; creates a new resource or replaces a representation of the target resource with the request payload.</source>
          <target state="translated">的&lt;strong&gt;HTTP PUT请求方法&lt;/strong&gt;创建新的资源或替换请求负载目标资源的表示。</target>
        </trans-unit>
        <trans-unit id="617a279a7f85aa11b7e9119c0549c65940ed8bdb" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Sec-WebSocket-Accept&lt;/strong&gt; header is used in the websocket opening handshake. It would appear in the response headers. That is, this is header is sent from server to client to inform that server is willing to initiate a websocket connection.</source>
          <target state="translated">所述&lt;strong&gt;仲丁基的WebSocket -接受&lt;/strong&gt;报头在网页套接字开口握手使用。它会出现在响应标题中。也就是说，此标头是从服务器发送到客户端的，以通知服务器愿意启动Websocket连接。</target>
        </trans-unit>
        <trans-unit id="fec1b2ea30a4b23ec6ed613fb4a58917ff6f2e5d" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Trailer&lt;/strong&gt; response header allows the sender to include additional fields at the end of chunked messages in order to supply metadata that might be dynamically generated while the message body is sent, such as a message integrity check, digital signature, or post-processing status.</source>
          <target state="translated">所述&lt;strong&gt;拖车&lt;/strong&gt;响应头允许发送方包括为了供给元数据可能同时消息体被发送，诸如消息完整性检查，数字签名，或后处理状态动态地生成在分块消息的末尾附加字段。</target>
        </trans-unit>
        <trans-unit id="72b737b3f7ebb245858f1a5344bbb6bcfd1d296b" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;User-Agent&lt;/strong&gt; request header contains a characteristic string that allows the network protocol peers to identify the application type, operating system, software vendor or software version of the requesting software user agent.</source>
          <target state="translated">的&lt;strong&gt;用户代理&lt;/strong&gt;请求头包含一个特征串，其允许网络协议对等体，以确定应用程序的类型，操作系统，软件供应商或请求软件的用户代理的软件版本。</target>
        </trans-unit>
        <trans-unit id="2288013069b97e56ffbc4768d5888642c23e6913" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;User-Agent&lt;/strong&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/request_header&quot;&gt;request header&lt;/a&gt; is a characteristic string that lets servers and network peers identify the application, operating system, vendor, and/or version of the requesting &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;user agent&lt;/a&gt;.</source>
          <target state="translated">的&lt;strong&gt;用户代理&lt;/strong&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/request_header&quot;&gt;请求头&lt;/a&gt;是一个特性串，让服务器和网络对等体标识请求的应用程序，操作系统，供应商和/或版本&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;的用户代理&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="808b80dac820b6a1614956c81b08b2381235cc1b" translate="yes" xml:space="preserve">
          <source>The Accept header</source>
          <target state="translated">接受头</target>
        </trans-unit>
        <trans-unit id="ab7fb45a1dfda8bd680e10b36530ac6598af98b2" translate="yes" xml:space="preserve">
          <source>The Accept request-header field can be used to specify certain media
   types which are acceptable for the response. Accept headers can be
   used to indicate that the request is specifically limited to a small
   set of desired types, as in the case of a request for an in-line
   image.

       Accept         = &quot;Accept&quot; &quot;:&quot;
                        #( media-range [ accept-params ] )

       media-range    = ( &quot;*/*&quot;
                        | ( type &quot;/&quot; &quot;*&quot; )
                        | ( type &quot;/&quot; subtype )
                        ) *( &quot;;&quot; parameter )
       accept-params  = &quot;;&quot; &quot;q&quot; &quot;=&quot; qvalue *( accept-extension )
       accept-extension = &quot;;&quot; token [ &quot;=&quot; ( token | quoted-string ) ]

   The asterisk &quot;*&quot; character is used to group media types into ranges,
   with &quot;*/*&quot; indicating all media types and &quot;type/*&quot; indicating all
   subtypes of that type. The media-range MAY include media type
   parameters that are applicable to that range.

   Each media-range MAY be followed by one or more accept-params,
   beginning with the &quot;q&quot; parameter for indicating a relative quality
   factor. The first &quot;q&quot; parameter (if any) separates the media-range
   parameter(s) from the accept-params. Quality factors allow the user
   or user agent to indicate the relative degree of preference for that
   media-range, using the qvalue scale from 0 to 1 (&lt;a href=&quot;#section-3.9&quot;&gt;section 3.9&lt;/a&gt;). The
   default value is q=1.

      Note: Use of the &quot;q&quot; parameter name to separate media type
      parameters from Accept extension parameters is due to historical
      practice. Although this prevents any media type parameter named
      &quot;q&quot; from being used with a media range, such an event is believed
      to be unlikely given the lack of any &quot;q&quot; parameters in the IANA
      media type registry and the rare usage of any media type
      parameters in Accept. Future media types are discouraged from
      registering any parameter named &quot;q&quot;. 

   The example

       Accept: audio/*; q=0.2, audio/basic

   SHOULD be interpreted as &quot;I prefer audio/basic, but send me any audio
   type if it is the best available after an 80% mark-down in quality.&quot;

   If no Accept header field is present, then it is assumed that the
   client accepts all media types. If an Accept header field is present,
   and if the server cannot send a response which is acceptable
   according to the combined Accept field value, then the server SHOULD
   send a 406 (not acceptable) response.

   A more elaborate example is

       Accept: text/plain; q=0.5, text/html,
               text/x-dvi; q=0.8, text/x-c

   Verbally, this would be interpreted as &quot;text/html and text/x-c are
   the preferred media types, but if they do not exist, then send the
   text/x-dvi entity, and if that does not exist, send the text/plain
   entity.&quot;

   Media ranges can be overridden by more specific media ranges or
   specific media types. If more than one media range applies to a given
   type, the most specific reference has precedence. For example,

       Accept: text/*, text/html, text/html;level=1, */*

   have the following precedence:

       1) text/html;level=1
       2) text/html
       3) text/*
       4) */*

   The media type quality factor associated with a given type is
   determined by finding the media range with the highest precedence
   which matches that type. For example,

       Accept: text/*;q=0.3, text/html;q=0.7, text/html;level=1,
               text/html;level=2;q=0.4, */*;q=0.5

   would cause the following values to be associated:

       text/html;level=1         = 1
       text/html                 = 0.7
       text/plain                = 0.3 

       image/jpeg                = 0.5
       text/html;level=2         = 0.4
       text/html;level=3         = 0.7

      Note: A user agent might be provided with a default set of quality
      values for certain media ranges. However, unless the user agent is
      a closed system which cannot interact with other rendering agents,
      this default set ought to be configurable by the user.</source>
          <target state="translated">接受请求标头字段可用于指定响应可接受的某些媒体类型。接受标头可用于指示该请求特别限于一小部分所需类型，例如在请求嵌入式图像的情况下。接受=&amp;ldquo;接受&amp;rdquo;&amp;ldquo;：&amp;rdquo;＃（media-range [accept-params]）media-range =（&amp;ldquo; * / *&amp;rdquo; |（type&amp;ldquo; /&amp;rdquo;&amp;ldquo; *&amp;rdquo;）|（type&amp;ldquo; /&amp;rdquo;子类型）））*（ &amp;ldquo;;&amp;rdquo;参数）accept-params =&amp;ldquo;;&amp;rdquo; &amp;ldquo; q&amp;rdquo;&amp;ldquo; =&amp;rdquo; qvalue *（accept-extension）accept-extension =&amp;ldquo;;&amp;rdquo; token [&amp;ldquo; =&amp;rdquo;（token | quoted-string）]星号&amp;ldquo; *&amp;rdquo;字符用于将媒体类型分组到范围内，其中&amp;ldquo; * / *&amp;rdquo;表示所有媒体类型，&amp;ldquo; type / *&amp;rdquo;表示该类型的所有子类型。媒体范围可以包括适用于该范围的媒体类型参数。每个媒体范围都可以跟随一个或多个接受参数，以&amp;ldquo; q&amp;rdquo;参数开头，以指示相对质量因数。第一个&amp;ldquo; q&amp;rdquo;参数（如果有）将媒体范围参数与accept-params分开。品质因数允许用户或用户代理使用从0到1的q值刻度来指示该媒体范围的相对偏好程度（媒体范围可以包括适用于该范围的媒体类型参数。每个媒体范围都可以跟随一个或多个接受参数，以&amp;ldquo; q&amp;rdquo;参数开头，以指示相对质量因数。第一个&amp;ldquo; q&amp;rdquo;参数（如果有）将媒体范围参数与accept-params分开。品质因数允许用户或用户代理使用从0到1的q值刻度来指示该媒体范围的相对偏好程度（媒体范围可以包括适用于该范围的媒体类型参数。每个媒体范围都可以跟随一个或多个接受参数，以&amp;ldquo; q&amp;rdquo;参数开头，以指示相对质量因数。第一个&amp;ldquo; q&amp;rdquo;参数（如果有）将媒体范围参数与accept-params分开。品质因数允许用户或用户代理使用从0到1的q值刻度来指示该媒体范围的相对偏好程度（品质因数允许用户或用户代理使用从0到1的q值刻度来指示该媒体范围的相对偏好程度（品质因数允许用户或用户代理使用从0到1的q值刻度来指示该媒体范围的相对偏好程度（&lt;a href=&quot;#section-3.9&quot;&gt;第3.9节&lt;/a&gt;）。默认值为q = 1。注意：由于历史上的惯例，使用&amp;ldquo; q&amp;rdquo;参数名称将媒体类型参数与&amp;ldquo;接受&amp;rdquo;扩展参数分开。尽管这可以阻止任何名为&amp;ldquo; q&amp;rdquo;的媒体类型参数与媒体范围一起使用，但考虑到IANA媒体类型注册表中缺少任何&amp;ldquo; q&amp;rdquo;参数并且很少使用任何媒体类型的情况，因此认为这种事件不太可能发生接受中的参数。不鼓励将来的媒体类型注册任何名为&amp;ldquo; q&amp;rdquo;的参数。该示例接受：audio / *; q = 0.2，音频/基本应该解释为&amp;ldquo;我更喜欢音频/基本，但是如果质量降低80％之后，如果音频类型是最好的，请向我发送任何音频类型。&amp;rdquo;如果不存在&amp;ldquo;接受&amp;rdquo;标头字段，则假定客户端接受所有媒体类型。如果存在一个Accept头字段，并且如果服务器不能根据组合的Accept字段值发送可接受的响应，则服务器应该发送406（不可接受）响应。一个更详细的示例是Accept：text / plain; q = 0.5，text / html，text / x-dvi; q = 0.8，text / xc从字面上看，这将被解释为&amp;ldquo; text / html和text / xc是首选的媒体类型，但是如果它们不存在，则发送text / x-dvi实体，如果不存在存在，请发送文本/纯文本实体。&amp;rdquo;媒体范围可以被更特定的媒体范围或特定的媒体类型覆盖。如果给定类型适用多个介质范围，则最具体的参考优先。例如，接受：text / *，text / html，text / html; level = 1，* / *具有以下优先级：1）text / html; level = 1 2）text / html 3）text / * 4）* / *媒体与给定类型关联的类型质量因子是通过找到与该类型匹配的具有最高优先级的媒体范围来确定的。例如，接受：text / *; q = 0.3，text / html; q = 0.7，text / html; level = 1，text / html; level = 2; q = 0.4，* / *; q = 0.5要关联的以下值：text / html; level = 1 = 1 text / html = 0.7 text / plain = 0.3 image / jpeg = 0.5 text / html; level = 2 = 0.4 text / html; level = 3 = 0.7注意：可能为用户代理提供了某些媒体范围的默认质量值集。但是，除非用户代理是无法与其他呈现代理进行交互的封闭系统，否则此默认设置应可由用户配置。</target>
        </trans-unit>
        <trans-unit id="e7b4f26fbb0e2bce3365129a80d0fb7728e75c9b" translate="yes" xml:space="preserve">
          <source>The Accept-CH header</source>
          <target state="translated">接受-CH头</target>
        </trans-unit>
        <trans-unit id="d63aae7229caefbd97fe24c548f9020512978ccc" translate="yes" xml:space="preserve">
          <source>The Accept-CH-Lifetime header</source>
          <target state="translated">Accept-CH-Lifetime标头</target>
        </trans-unit>
        <trans-unit id="4769fb0951abad4aa7016b3134653949993c77de" translate="yes" xml:space="preserve">
          <source>The Accept-Charset header</source>
          <target state="translated">Accept-Charset头</target>
        </trans-unit>
        <trans-unit id="234dfa2f1729dd01886001e7daa88ee0bafe27f6" translate="yes" xml:space="preserve">
          <source>The Accept-Charset request-header field can be used to indicate what
   character sets are acceptable for the response. This field allows
   clients capable of understanding more comprehensive or special-
   purpose character sets to signal that capability to a server which is
   capable of representing documents in those character sets.

      Accept-Charset = &quot;Accept-Charset&quot; &quot;:&quot;
              1#( ( charset | &quot;*&quot; )[ &quot;;&quot; &quot;q&quot; &quot;=&quot; qvalue ] )


   Character set values are described in &lt;a href=&quot;#section-3.4&quot;&gt;section 3.4&lt;/a&gt;. Each charset MAY
   be given an associated quality value which represents the user's
   preference for that charset. The default value is q=1. An example is

      Accept-Charset: iso-8859-5, unicode-1-1;q=0.8

   The special value &quot;*&quot;, if present in the Accept-Charset field,
   matches every character set (including ISO-8859-1) which is not
   mentioned elsewhere in the Accept-Charset field. If no &quot;*&quot; is present
   in an Accept-Charset field, then all character sets not explicitly
   mentioned get a quality value of 0, except for ISO-8859-1, which gets
   a quality value of 1 if not explicitly mentioned.

   If no Accept-Charset header is present, the default is that any
   character set is acceptable. If an Accept-Charset header is present,
   and if the server cannot send a response which is acceptable
   according to the Accept-Charset header, then the server SHOULD send
   an error response with the 406 (not acceptable) status code, though
   the sending of an unacceptable response is also allowed.</source>
          <target state="translated">Accept-Charset请求标头字段可用于指示响应可接受的字符集。该字段允许客户机能够理解更全面或专用的字符集，以将这种能力发送给能够在那些字符集中表示文档的服务器。 Accept-Charset =&amp;ldquo; Accept-Charset&amp;rdquo;&amp;ldquo;：&amp;rdquo; 1＃（（charset |&amp;ldquo; *&amp;rdquo;）[&amp;ldquo;;&amp;rdquo;&amp;ldquo; q&amp;rdquo;&amp;ldquo; =&amp;rdquo; qvalue]）字符集的值在&lt;a href=&quot;#section-3.4&quot;&gt;3.4节&lt;/a&gt;中介绍。可以给每个字符集一个相关联的质量值，该质量值表示用户对该字符集的偏好。默认值为q = 1。一个示例是Accept-Charset：iso-8859-5，unicode-1-1; q = 0.8特殊值&amp;ldquo; *&amp;rdquo;（如果出现在Accept-Charset字段中）则匹配每个字符集（包括ISO-8859-1）在&amp;ldquo;接受字符集&amp;rdquo;字段的其他地方未提及。如果Accept-Charset字段中不存在&amp;ldquo; *&amp;rdquo;，则所有未明确提及的字符集的质量值均为0，ISO-8859-1除外，如果未明确提及，则其质量值为1。如果不存在Accept-Charset标头，则默认值为任何字符集都是可接受的。如果存在Accept-Charset标头，并且如果服务器不能根据Accept-Charset头发送可接受的响应，则服务器应该发送带有406（不可接受）状态码的错误响应，尽管也允许发送不可接受的响应。</target>
        </trans-unit>
        <trans-unit id="4cd92c762aa78d137a23b8b73482ba75b9995048" translate="yes" xml:space="preserve">
          <source>The Accept-Encoding header</source>
          <target state="translated">接受-编码头</target>
        </trans-unit>
        <trans-unit id="2e57729d1ed38c6ddc068a85cca9d470a3c1d181" translate="yes" xml:space="preserve">
          <source>The Accept-Encoding request-header field is similar to Accept, but
   restricts the content-codings (&lt;a href=&quot;#section-3.5&quot;&gt;section 3.5&lt;/a&gt;) that are acceptable in
   the response.

       Accept-Encoding  = &quot;Accept-Encoding&quot; &quot;:&quot; 

                          1#( codings [ &quot;;&quot; &quot;q&quot; &quot;=&quot; qvalue ] )
       codings          = ( content-coding | &quot;*&quot; )

   Examples of its use are:

       Accept-Encoding: compress, gzip
       Accept-Encoding:
       Accept-Encoding: *
       Accept-Encoding: compress;q=0.5, gzip;q=1.0
       Accept-Encoding: gzip;q=1.0, identity; q=0.5, *;q=0

   A server tests whether a content-coding is acceptable, according to
   an Accept-Encoding field, using these rules:

      1. If the content-coding is one of the content-codings listed in
         the Accept-Encoding field, then it is acceptable, unless it is
         accompanied by a qvalue of 0. (As defined in &lt;a href=&quot;#section-3.9&quot;&gt;section 3.9&lt;/a&gt;, a
         qvalue of 0 means &quot;not acceptable.&quot;)

      2. The special &quot;*&quot; symbol in an Accept-Encoding field matches any
         available content-coding not explicitly listed in the header
         field.

      3. If multiple content-codings are acceptable, then the acceptable
         content-coding with the highest non-zero qvalue is preferred.

      4. The &quot;identity&quot; content-coding is always acceptable, unless
         specifically refused because the Accept-Encoding field includes
         &quot;identity;q=0&quot;, or because the field includes &quot;*;q=0&quot; and does
         not explicitly include the &quot;identity&quot; content-coding. If the
         Accept-Encoding field-value is empty, then only the &quot;identity&quot;
         encoding is acceptable.

   If an Accept-Encoding field is present in a request, and if the
   server cannot send a response which is acceptable according to the
   Accept-Encoding header, then the server SHOULD send an error response
   with the 406 (Not Acceptable) status code.

   If no Accept-Encoding field is present in a request, the server MAY
   assume that the client will accept any content coding. In this case,
   if &quot;identity&quot; is one of the available content-codings, then the
   server SHOULD use the &quot;identity&quot; content-coding, unless it has
   additional information that a different content-coding is meaningful
   to the client.

      Note: If the request does not include an Accept-Encoding field,
      and if the &quot;identity&quot; content-coding is unavailable, then
      content-codings commonly understood by HTTP/1.0 clients (i.e., 

      &quot;gzip&quot; and &quot;compress&quot;) are preferred; some older clients
      improperly display messages sent with other content-codings.  The
      server might also make this decision based on information about
      the particular user-agent or client.

      Note: Most HTTP/1.0 applications do not recognize or obey qvalues
      associated with content-codings. This means that qvalues will not
      work and are not permitted with x-gzip or x-compress.</source>
          <target state="translated">Accept-Encoding请求标头字段与Accept相似，但是限制了内容编码（&lt;a href=&quot;#section-3.5&quot;&gt;第3.5节&lt;/a&gt;）在响应中可以接受。 Accept-Encoding =&amp;ldquo; Accept-Encoding&amp;rdquo;&amp;ldquo;：&amp;rdquo; 1＃（编码[&amp;ldquo;;&amp;rdquo;&amp;ldquo; q&amp;rdquo;&amp;ldquo; =&amp;rdquo; qvalue]）编码=（content-coding |&amp;ldquo; *&amp;rdquo;）其用法示例如下：Accept-Encoding：压缩，gzip接受编码：接受编码：*接受编码：压缩; q = 0.5，gzip; q = 1.0接受编码：gzip; q = 1.0，身份; q = 0.5，*; q = 0服务器使用以下规则根据&amp;ldquo;接受编码&amp;rdquo;字段测试内容编码是否可接受：1.如果内容编码是&amp;ldquo;接受&amp;rdquo;中列出的内容编码之一-Encoding字段，那么它是可以接受的，除非它带有qvalue0。（如&lt;a href=&quot;#section-3.9&quot;&gt;3.9节中&lt;/a&gt;所定义），q值为0表示&amp;ldquo;不可接受&amp;rdquo;。）2. Accept-Encoding字段中的特殊&amp;ldquo; *&amp;rdquo;符号与标头字段中未明确列出的任何可用内容编码匹配。 3.如果可接受多个内容编码，则首选具有最高非零q值的可接受内容编码。 4.&amp;ldquo;身份&amp;rdquo;内容编码始终是可以接受的，除非由于Accept-Encoding字段包含&amp;ldquo; identity; q = 0&amp;rdquo;或由于该字段包含&amp;ldquo; *; q = 0&amp;rdquo;且未明确包含&amp;ldquo;身份&amp;rdquo;内容编码。如果Accept-Encoding字段值为空，则仅&amp;ldquo;身份&amp;rdquo;编码是可接受的。如果请求中存在一个Accept-Encoding字段，并且如果服务器无法根据Accept-Encoding标头发送可接受的响应，则服务器应该发送一个错误响应，并带有406（不可接受）状态码。如果请求中不存在Accept-Encoding字段，则服务器可以假定客户端将接受任何内容编码。在这种情况下，如果&amp;ldquo;身份&amp;rdquo;是可用的内容编码之一，则服务器应该使用&amp;ldquo;身份&amp;rdquo;内容编码，除非它具有其他信息，即不同的内容编码对客户端有意义。注意：如果请求中不包含&amp;ldquo;接受编码&amp;rdquo;字段，并且&amp;ldquo;身份&amp;rdquo;内容编码不可用，则HTTP / 1.0客户端通常会理解的内容编码（即，&amp;ldquo; gzip&amp;rdquo;和&amp;ldquo; compress&amp;rdquo;）是首选；一些较旧的客户端不正确地显示与其他内容编码一起发送的消息。服务器可能还会基于有关特定用户代理或客户端的信息来做出此决定。注意：大多数HTTP / 1.0应用程序都不识别或遵循与内容编码关联的q值。这意味着qvalue不能使用，并且x-gzip或x-compress不允许使用。这意味着qvalues将不起作用，并且x-gzip或x-compress不允许使用。这意味着qvalue不能使用，并且x-gzip或x-compress不允许使用。</target>
        </trans-unit>
        <trans-unit id="007df01155d25e755642903868beaa64cb7fcbdf" translate="yes" xml:space="preserve">
          <source>The Accept-Language header</source>
          <target state="translated">接受语言头</target>
        </trans-unit>
        <trans-unit id="2ba115d77d254ca318ebb9337409d39d8d2c75fa" translate="yes" xml:space="preserve">
          <source>The Accept-Language request-header field is similar to Accept, but
   restricts the set of natural languages that are preferred as a
   response to the request. Language tags are defined in &lt;a href=&quot;#section-3.10&quot;&gt;section 3.10&lt;/a&gt;.

       Accept-Language = &quot;Accept-Language&quot; &quot;:&quot;
                         1#( language-range [ &quot;;&quot; &quot;q&quot; &quot;=&quot; qvalue ] )
       language-range  = ( ( 1*8ALPHA *( &quot;-&quot; 1*8ALPHA ) ) | &quot;*&quot; )

   Each language-range MAY be given an associated quality value which
   represents an estimate of the user's preference for the languages
   specified by that range. The quality value defaults to &quot;q=1&quot;. For
   example,

       Accept-Language: da, en-gb;q=0.8, en;q=0.7

   would mean: &quot;I prefer Danish, but will accept British English and
   other types of English.&quot; A language-range matches a language-tag if
   it exactly equals the tag, or if it exactly equals a prefix of the
   tag such that the first tag character following the prefix is &quot;-&quot;.
   The special range &quot;*&quot;, if present in the Accept-Language field,
   matches every tag not matched by any other range present in the
   Accept-Language field.

      Note: This use of a prefix matching rule does not imply that
      language tags are assigned to languages in such a way that it is
      always true that if a user understands a language with a certain
      tag, then this user will also understand all languages with tags
      for which this tag is a prefix. The prefix rule simply allows the
      use of prefix tags if this is the case.

   The language quality factor assigned to a language-tag by the
   Accept-Language field is the quality value of the longest language-
   range in the field that matches the language-tag. If no language-
   range in the field matches the tag, the language quality factor
   assigned is 0. If no Accept-Language header is present in the
   request, the server 

   SHOULD assume that all languages are equally acceptable. If an
   Accept-Language header is present, then all languages which are
   assigned a quality factor greater than 0 are acceptable.

   It might be contrary to the privacy expectations of the user to send
   an Accept-Language header with the complete linguistic preferences of
   the user in every request. For a discussion of this issue, see
   &lt;a href=&quot;#section-15.1.4&quot;&gt;section 15.1.4&lt;/a&gt;.

   As intelligibility is highly dependent on the individual user, it is
   recommended that client applications make the choice of linguistic
   preference available to the user. If the choice is not made
   available, then the Accept-Language header field MUST NOT be given in
   the request.

      Note: When making the choice of linguistic preference available to
      the user, we remind implementors of  the fact that users are not
      familiar with the details of language matching as described above,
      and should provide appropriate guidance. As an example, users
      might assume that on selecting &quot;en-gb&quot;, they will be served any
      kind of English document if British English is not available. A
      user agent might suggest in such a case to add &quot;en&quot; to get the
      best matching behavior.</source>
          <target state="translated">Accept-Language请求标头字段类似于Accept，但是限制了首选自然语言集作为对请求的响应。语言标签在&lt;a href=&quot;#section-3.10&quot;&gt;3.10节&lt;/a&gt;中定义。 Accept-Language =&amp;ldquo; Accept-Language&amp;rdquo;&amp;ldquo;：&amp;rdquo; 1＃（语言范围[&amp;ldquo;;&amp;rdquo;&amp;ldquo; q&amp;rdquo;&amp;ldquo; =&amp;rdquo; qvalue]）语言范围=（（1 * 8ALPHA *（&amp;ldquo;-&amp;rdquo; 1 * 8ALPHA）） |&amp;ldquo; *&amp;rdquo;）可以给每个语言范围一个相关的质量值，该质量值表示用户对该范围指定的语言的偏爱估计。质量值默认为&amp;ldquo; q = 1&amp;rdquo;。例如，Accept-Language：da，en-gb; q = 0.8，en; q = 0.7表示：&amp;ldquo;我更喜欢丹麦语，但会接受英式英语和其他类型的英语。&amp;rdquo;如果语言范围与语言标签完全相同，或者与语言标签完全相同，或者与标签的前缀完全相同，则前缀后面的第一个标签字符为&amp;ldquo;-&amp;rdquo;。特殊范围&amp;ldquo; *&amp;rdquo;（如果出现在&amp;ldquo;接受语言&amp;rdquo;字段中）将与&amp;ldquo;接受语言&amp;rdquo;字段中存在的任何其他范围未匹配的每个标签进行匹配。注意：前缀匹配规则的使用并不意味着将语言标签分配给语言，以确保用户理解带有特定标签的语言始终是正确的，那么该用户也将理解带有标签的所有语言。为此标签作为前缀。如果是这种情况，则前缀规则仅允许使用前缀标签。通过&amp;ldquo;接受语言&amp;rdquo;字段分配给语言标签的语言质量因子是该字段中与语言标签匹配的最长语言范围的质量值。如果字段中没有语言范围与标签匹配，则分配的语言质量因子为0。如果请求中不存在Accept-Language标头，则服务器应假定所有语言均可接受。如果存在Accept-Language标头，则所有被分配了大于0的质量因子的语言都是可以接受的。在每个请求中发送带有用户完整语言偏好的Accept-Language标头可能与用户的隐私期望背道而驰。有关此问题的讨论，请参见在每个请求中发送带有用户完整语言偏好的Accept-Language标头可能与用户的隐私期望背道而驰。有关此问题的讨论，请参见在每个请求中发送带有用户完整语言偏好的Accept-Language标头可能与用户的隐私期望背道而驰。有关此问题的讨论，请参见 &lt;a href=&quot;#section-15.1.4&quot;&gt;第15.1.4节&lt;/a&gt;。由于可懂度高度依赖于单个用户，因此建议客户端应用程序使用户可以选择语言偏好。如果选择不可用，则在请求中不得给出Accept-Language标头字段。注意：在向用户提供语言偏好选择时，我们提醒实施者以下事实：用户不熟悉上述语言匹配的详细信息，并应提供适当的指导。例如，用户可能会假设选择&amp;ldquo; en-gb&amp;rdquo;时，如果没有英式英语，则将向他们提供任何种类的英语文档。在这种情况下，用户代理可能建议添加&amp;ldquo; en&amp;rdquo;以获得最佳匹配行为。</target>
        </trans-unit>
        <trans-unit id="dceeccc14ca79697274f5080fd10fd4f709e2583" translate="yes" xml:space="preserve">
          <source>The Accept-Ranges response-header field allows the server to
      indicate its acceptance of range requests for a resource:

          Accept-Ranges     = &quot;Accept-Ranges&quot; &quot;:&quot; acceptable-ranges
          acceptable-ranges = 1#range-unit | &quot;none&quot;

      Origin servers that accept byte-range requests MAY send

          Accept-Ranges: bytes

      but are not required to do so. Clients MAY generate byte-range
      requests without having received this header for the resource
      involved. Range units are defined in &lt;a href=&quot;#section-3.12&quot;&gt;section 3.12&lt;/a&gt;.

      Servers that do not accept any kind of range request for a
      resource MAY send

          Accept-Ranges: none

      to advise the client not to attempt a range request.</source>
          <target state="translated">Accept-Ranges响应标头字段允许服务器指示其接受资源的范围请求：Accept-Ranges =&amp;ldquo; Accept-Ranges&amp;rdquo;&amp;ldquo;：&amp;rdquo; accept-ranges accept-ranges = 1＃range-unit |接受字节范围请求的&amp;ldquo;无&amp;rdquo;原始服务器可以发送Accept-Ranges：字节，但不是必须的。客户端可以生成字节范围的请求，而没有收到所涉及资源的此头。范围单位在&lt;a href=&quot;#section-3.12&quot;&gt;第3.12节&lt;/a&gt;中定义。不接受任何类型的资源范围请求的服务器可以发送Accept-Ranges：无，建议客户端不要尝试范围请求。</target>
        </trans-unit>
        <trans-unit id="20fe0a78765b42653f8af73cd9564f1524ef0e69" translate="yes" xml:space="preserve">
          <source>The Age header field is used to convey an estimated age of the
   response message when obtained from a cache.  The Age field value is
   the cache's estimate of the number of seconds since the response was
   generated or validated by the origin server.  In essence, the Age 

   value is the sum of the time that the response has been resident in
   each of the caches along the path from the origin server, plus the
   amount of time it has been in transit along network paths.

   The following data is used for the age calculation:

   age_value

      The term &quot;age_value&quot; denotes the value of the Age header field
      (&lt;a href=&quot;#section-5.1&quot;&gt;Section 5.1&lt;/a&gt;), in a form appropriate for arithmetic operation; or
      0, if not available.

   date_value

      The term &quot;date_value&quot; denotes the value of the Date header field,
      in a form appropriate for arithmetic operations.  See &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.2&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.2&quot;&gt;7.1.1.2 of [RFC7231]&lt;/a&gt; for the definition of the Date header field,
      and for requirements regarding responses without it.

   now

      The term &quot;now&quot; means &quot;the current value of the clock at the host
      performing the calculation&quot;.  A host ought to use NTP ([&lt;a href=&quot;https://tools.ietf.org/html/rfc5905&quot;&gt;RFC5905&lt;/a&gt;])
      or some similar protocol to synchronize its clocks to Coordinated
      Universal Time.

   request_time

      The current value of the clock at the host at the time the request
      resulting in the stored response was made.

   response_time

      The current value of the clock at the host at the time the
      response was received.

   A response's age can be calculated in two entirely independent ways:

   1.  the &quot;apparent_age&quot;: response_time minus date_value, if the local
       clock is reasonably well synchronized to the origin server's
       clock.  If the result is negative, the result is replaced by
       zero.

   2.  the &quot;corrected_age_value&quot;, if all of the caches along the
       response path implement HTTP/1.1.  A cache MUST interpret this
       value relative to the time the request was initiated, not the
       time that the response was received. 

     apparent_age = max(0, response_time - date_value);

     response_delay = response_time - request_time;
     corrected_age_value = age_value + response_delay;

   These are combined as

     corrected_initial_age = max(apparent_age, corrected_age_value);

   unless the cache is confident in the value of the Age header field
   (e.g., because there are no HTTP/1.0 hops in the Via header field),
   in which case the corrected_age_value MAY be used as the
   corrected_initial_age.

   The current_age of a stored response can then be calculated by adding
   the amount of time (in seconds) since the stored response was last
   validated by the origin server to the corrected_initial_age.

     resident_time = now - response_time;
     current_age = corrected_initial_age + resident_time;</source>
          <target state="translated">当从高速缓存中获得时，&amp;ldquo;年龄&amp;rdquo;标头字段用于传达响应消息的估计年龄。 &amp;ldquo;年龄&amp;rdquo;字段的值是自原始服务器生成或验证响应以来，缓存对秒数的估计。本质上，Age值是响应从源服务器沿路径驻留在每个缓存中的时间加上沿网络路径传输的时间之和。以下数据用于年龄计算：age_value术语&amp;ldquo; age_value&amp;rdquo;表示&amp;ldquo;年龄&amp;rdquo;标头字段的值（&lt;a href=&quot;#section-5.1&quot;&gt;第5.1节）&lt;/a&gt;），采用适合算术运算的形式；或0（如果不可用）。 date_value术语&amp;ldquo; date_value&amp;rdquo;以适合算术运算的形式表示Date标头字段的值。请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.2&quot;&gt;[RFC7231]的7.1.1.2 &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.2&quot;&gt;节&lt;/a&gt;，了解Date标头字段的定义，以及有关没有此标头的响应的要求。 now术语&amp;ldquo; now&amp;rdquo;表示&amp;ldquo;执行计算的主机上时钟的当前值&amp;rdquo;。主机应使用NTP（[ &lt;a href=&quot;https://tools.ietf.org/html/rfc5905&quot;&gt;RFC5905&lt;/a&gt;]）或一些类似的协议，以将其时钟同步到协调世界时。 request_time发出导致存储的响应的请求时主机上时钟的当前值。 response_time接收响应时主机上时钟的当前值。可以使用两种完全独立的方法来计算响应的时间：1.&amp;ldquo; apparent_age&amp;rdquo;：response_time减去date_value（如果本地时钟与原始服务器的时钟合理地同步）。如果结果为负，则结果将替换为零。 2.如果响应路径上的所有缓存均实现HTTP / 1.1，则为&amp;ldquo; corrected_age_value&amp;rdquo;。缓存必须相对于发起请求的时间而不是接收响应的时间来解释该值。 parent_age = max（0，response_time-date_value）; response_delay = response_time-request_time; corrected_age_value = age_value + response_delay;这些被合并为corrected_initial_age = max（表观年龄，corrected_age_value）;除非高速缓存对Age标头字段的值有信心（例如，因为Via标头字段中没有HTTP / 1.0跳），在这种情况下，corrected_age_value可以用作corrected_initial_age。然后，可以通过将自存储服务器上次验证存储的响应以来的时间量（以秒为单位）添加到corrected_initial_age中，来计算存储的响应的current_age。resident_time = now-response_time; current_age =校正后的初始年龄+ resident_time;</target>
        </trans-unit>
        <trans-unit id="fdef55523947f477881a984ce9c7d78915e916d7" translate="yes" xml:space="preserve">
          <source>The Age response-header field conveys the sender's estimate of the
      amount of time since the response (or its revalidation) was
      generated at the origin server. A cached response is &quot;fresh&quot; if
      its age does not exceed its freshness lifetime. Age values are
      calculated as specified in &lt;a href=&quot;#section-13.2.3&quot;&gt;section 13.2.3&lt;/a&gt;.

           Age = &quot;Age&quot; &quot;:&quot; age-value
           age-value = delta-seconds

      Age values are non-negative decimal integers, representing time in
      seconds.

      If a cache receives a value larger than the largest positive
      integer it can represent, or if any of its age calculations
      overflows, it MUST transmit an Age header with a value of
      2147483648 (2^31). An HTTP/1.1 server that includes a cache MUST
      include an Age header field in every response generated from its
      own cache. Caches SHOULD use an arithmetic type of at least 31
      bits of range.</source>
          <target state="translated">年龄响应标头字段传达了发件人对自从在原始服务器上生成响应（或其重新验证）以来的时间量的估计。如果缓存的响应时间不超过其新鲜度生命周期，则它是&amp;ldquo;新鲜的&amp;rdquo;。年龄值是按照&lt;a href=&quot;#section-13.2.3&quot;&gt;第13.2.3节中的&lt;/a&gt;规定计算的。 Age =&amp;ldquo; Age&amp;rdquo;&amp;ldquo; ::&amp;rdquo; age-value age-value = delta-seconds年龄值是非负十进制整数，以秒为单位表示时间。如果缓存收到的值大于它可以表示的最大正整数，或者如果任何年龄计算溢出，则它必须发送一个2147483648（2 ^ 31）值的Age标头。包含缓存的HTTP / 1.1服务器必须在其自身的缓存生成的每个响应中都包含Age标头字段。缓存应该使用至少31位范围的算术类型。</target>
        </trans-unit>
        <trans-unit id="d37b3ed1a7bd53de7b0c73a5ae6518e139d2ed9d" translate="yes" xml:space="preserve">
          <source>The Allow entity-header field lists the set of methods supported
      by the resource identified by the Request-URI. The purpose of this
      field is strictly to inform the recipient of valid methods
      associated with the resource. An Allow header field MUST be
      present in a 405 (Method Not Allowed) response.

          Allow   = &quot;Allow&quot; &quot;:&quot; #Method

      Example of use:

          Allow: GET, HEAD, PUT

      This field cannot prevent a client from trying other methods.
      However, the indications given by the Allow header field value
      SHOULD be followed. The actual set of allowed methods is defined
      by the origin server at the time of each request.

      The Allow header field MAY be provided with a PUT request to
      recommend the methods to be supported by the new or modified
      resource. The server is not required to support these methods and
      SHOULD include an Allow header in the response giving the actual
      supported methods. 

      A proxy MUST NOT modify the Allow header field even if it does not
      understand all the methods specified, since the user agent might
      have other means of communicating with the origin server.</source>
          <target state="translated">Allow实体头字段列出了由Request-URI标识的资源所支持的方法集。这个字段的目的是严格地通知接收者与资源相关的有效方法。允许头字段必须存在于405(方法不允许)响应中。Allow=&quot;Allow&quot; &quot;:&quot; #方法 使用示例。使用示例:Allow.GET,HEAD,PUT GET,HEAD,PUT 这个字段不能阻止客户端尝试其他方法。但是,应该遵循Allow头字段值给出的指示。实际的允许方法集是由源服务器在每个请求时定义的。允许头字段可以和PUT请求一起提供,以推荐新的或修改后的资源所支持的方法。服务器不需要支持这些方法,应该在响应中包含一个Allow头,给出实际支持的方法。即使代理不理解所有指定的方法,也不能修改Allow头字段,因为用户代理可能有其他方法与源服务器通信。</target>
        </trans-unit>
        <trans-unit id="13a4fef575d5af4e237a81912fe641b20dff803a" translate="yes" xml:space="preserve">
          <source>The Atom Protocol imposes few restrictions on the actions of servers.
   Unless a constraint is specified here, servers can be expected to
   vary in behavior, in particular around the manipulation of Atom
   Entries sent by clients.  For example, although this specification
   only defines the expected behavior of Collections with respect to GET
   and POST, this does not imply that PUT, DELETE, PROPPATCH, and others
   are forbidden on Collection Resources -- only that this specification
   does not define what the server's response would be to those methods.
   Similarly, while some HTTP status codes are mentioned explicitly,
   clients ought to be prepared to handle any status code from a server.
   Servers can choose to accept, reject, delay, moderate, censor,
   reformat, translate, relocate, or re-categorize the content submitted
   to them.  Only some of these choices are immediately relayed back to
   the client in responses to client requests; other choices may only
   become apparent later, in the feed or published entries.  The same
   series of requests to two different publishing sites can result in a
   different series of HTTP responses, different resulting feeds, or
   different entry contents.

   As a result, client software has to be written flexibly to accept
   what the server decides are the results of its submissions.  Any
   server response or server content modification not explicitly
   forbidden by this specification or HTTP [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;] is therefore
   allowed.</source>
          <target state="translated">Atom协议对服务器的行为几乎没有限制。除非在此未指定约束，否则服务器的行为可能会有所不同，尤其是围绕客户端发送的Atom条目的操作。例如，尽管此规范仅定义了关于GET和POST的Collections的预期行为，但这并不意味着Collection资源上禁止PUT，DELETE，PROPPATCH和其他功能-只是此规范未定义服务器的资源应对将是那些方法。同样，尽管明确提到了一些HTTP状态代码，但客户端应准备好处理服务器中的任何状态代码。服务器可以选择接受，拒绝，延迟，适度，检查器，重新格式化，翻译，重新定位，或重新分类提交给他们的内容。这些选择中只有一部分会立即响应客户请求而中继回客户。其他选择可能仅稍后在提要或已发布的条目中变得明显。对两个不同发布站点的相同系列请求可能导致不同系列的HTTP响应，不同结果的提要或不同条目内容。结果，必须灵活地编写客户端软件，以接受服务器决定其提交结果的内容。本规范或HTTP未明确禁止的任何服务器响应或服务器内容修改[在Feed或已发布的条目中。对两个不同发布站点的相同系列请求可能导致不同系列的HTTP响应，不同结果的提要或不同条目内容。结果，必须灵活地编写客户端软件，以接受服务器决定其提交结果的内容。本规范或HTTP未明确禁止的任何服务器响应或服务器内容修改[在Feed或已发布的条目中。对两个不同发布站点的相同系列请求可能导致不同系列的HTTP响应，不同结果的提要或不同条目内容。结果，必须灵活地编写客户端软件，以接受服务器决定其提交结果的内容。本规范或HTTP未明确禁止的任何服务器响应或服务器内容修改[本规范或HTTP未明确禁止的任何服务器响应或服务器内容修改[本规范或HTTP未明确禁止的任何服务器响应或服务器内容修改[&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;&lt;/a&gt;因此，允许使用RFC2616 ]。</target>
        </trans-unit>
        <trans-unit id="3007c47f9b138e0499c5f1a7d9a65013178447c8" translate="yes" xml:space="preserve">
          <source>The Atom Protocol specifies operations for publishing and editing
   Resources using HTTP.  It uses Atom-formatted representations to
   describe the state and metadata of those Resources.  It defines how
   Collections of Resources can be organized, and it specifies formats
   to support their discovery, grouping and categorization.</source>
          <target state="translated">Atom协议规定了使用HTTP发布和编辑资源的操作,它使用Atom格式化的表示来描述这些资源的状态和元数据。它使用Atom格式化的表示来描述这些资源的状态和元数据。它定义了如何组织资源集合,并指定了支持其发现、分组和分类的格式。</target>
        </trans-unit>
        <trans-unit id="3a69850b360c5d4d12134d47ffb0f4087be9cb1a" translate="yes" xml:space="preserve">
          <source>The Atom Protocol uses the response status codes defined in HTTP to
   indicate the success or failure of an operation.  Consult the HTTP
   specification [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;] for detailed definitions of each status code.

   Implementers are asked to note that according to the HTTP
   specification, HTTP 4xx and 5xx response entities SHOULD include a
   human-readable explanation of the error.</source>
          <target state="translated">Atom协议使用HTTP中定义的响应状态代码来指示操作的成功或失败。有关每个状态代码的详细定义，请参考HTTP规范[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ]。要求实现者注意，根据HTTP规范，HTTP 4xx和5xx响应实体应该包括该错误的易于理解的解释。</target>
        </trans-unit>
        <trans-unit id="169d7cc9960872ff8dd439fd04a8242bd3b29ed5" translate="yes" xml:space="preserve">
          <source>The Atom Publishing Protocol</source>
          <target state="translated">Atom出版协议</target>
        </trans-unit>
        <trans-unit id="aa8edeb1773be5498439f67a0412dde5980a08ac" translate="yes" xml:space="preserve">
          <source>The Atom Publishing Protocol is an application-level protocol for
   publishing and editing Web Resources using HTTP [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;] and XML 1.0
   [&lt;a href=&quot;#ref-REC-xml&quot;&gt;REC-xml&lt;/a&gt;].  The protocol supports the creation of Web Resources and
   provides facilities for:

   o  Collections: Sets of Resources, which can be retrieved in whole or
      in part.

   o  Services: Discovery and description of Collections.

   o  Editing: Creating, editing, and deleting Resources.

   The Atom Publishing Protocol is different from many contemporary
   protocols in that the server is given wide latitude in processing
   requests from clients.  See &lt;a href=&quot;#section-4.4&quot;&gt;Section 4.4&lt;/a&gt; for more details.</source>
          <target state="translated">Atom发布协议是用于使用HTTP [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ]和XML 1.0 [ &lt;a href=&quot;#ref-REC-xml&quot;&gt;REC-xml&lt;/a&gt; ] 发布和编辑Web资源的应用程序级协议。该协议支持Web资源的创建，并提供以下功能：o集合：资源集，可以全部或部分检索。服务：发现和描述集合。 o编辑：创建，编辑和删除资源。 Atom发布协议与许多现代协议的不同之处在于，服务器在处理来自客户端的请求方面具有很大的自由度。有关更多详细信息，请参见&lt;a href=&quot;#section-4.4&quot;&gt;第4.4节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="091cad87f70ba141ab92f1e05e1c2c4c7b6a0753" translate="yes" xml:space="preserve">
          <source>The Atom Publishing Protocol is based on HTTP and thus subject to the
   security considerations found in &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-15&quot;&gt;Section&amp;nbsp;15 of [RFC2616]&lt;/a&gt;.

   The threats listed in this section apply to many protocols that run
   under HTTP.  The Atompub Working Group decided that the protection
   afforded by running authenticated HTTP under TLS (as described in
   &lt;a href=&quot;#section-14&quot;&gt;Section 14&lt;/a&gt;) was sufficient to mitigate many of the problems presented
   by the attacks listed in this section.</source>
          <target state="translated">Atom发布协议基于HTTP，因此需要遵守&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-15&quot;&gt;[RFC2616]第15节中&lt;/a&gt;的安全性考虑。本节中列出的威胁适用于在HTTP下运行的许多协议。 Atompub工作组认为，通过在TLS下运行经过身份验证的HTTP（如&lt;a href=&quot;#section-14&quot;&gt;第14节&lt;/a&gt;所述）所提供的保护 足以缓解本节中列出的攻击所带来的许多问题。</target>
        </trans-unit>
        <trans-unit id="5d125ad81e218339dcf924271a55cccc89e9d5f5" translate="yes" xml:space="preserve">
          <source>The Atom Publishing Protocol is based on HTTP.  Authentication
   requirements for HTTP are covered in &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-11&quot;&gt;Section&amp;nbsp;11 of [RFC2616]&lt;/a&gt;.

   The use of authentication mechanisms to prevent POSTing or editing by
   unknown or unauthorized clients is RECOMMENDED but not required.
   When authentication is not used, clients and servers are vulnerable
   to trivial spoofing, denial-of-service, and defacement attacks.
   However, in some contexts, this is an acceptable risk.

   The type of authentication deployed is a local decision made by the
   server operator.  Clients are likely to face authentication schemes
   that vary across server deployments.  At a minimum, client and server
   implementations MUST be capable of being configured to use HTTP Basic
   Authentication [&lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC2617&lt;/a&gt;] in conjunction with a connection made with
   TLS 1.0 [&lt;a href=&quot;https://tools.ietf.org/html/rfc2246&quot;&gt;RFC2246&lt;/a&gt;] or a subsequent standards-track version of TLS
   (such as [&lt;a href=&quot;https://tools.ietf.org/html/rfc4346&quot;&gt;RFC4346&lt;/a&gt;]), supporting the conventions for using HTTP over
   TLS described in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2818&quot;&gt;RFC2818&lt;/a&gt;]. 

   The choice of authentication mechanism will impact interoperability.
   The minimum level of security referenced above (Basic Authentication
   with TLS) is considered good practice for Internet applications at
   the time of publication of this specification and sufficient for
   establishing a baseline for interoperability.  Implementers are
   encouraged to investigate and use alternative mechanisms regarded as
   equivalently good or better at the time of deployment.  It is
   RECOMMENDED that clients be implemented in such a way that new
   authentication schemes can be deployed.

   Because this protocol uses HTTP response status codes as the primary
   means of reporting the result of a request, servers are advised to
   respond to unauthorized or unauthenticated requests using an
   appropriate 4xx HTTP response code (e.g., 401 &quot;Unauthorized&quot; or 403
   &quot;Forbidden&quot;) in accordance with [&lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC2617&lt;/a&gt;].</source>
          <target state="translated">Atom发布协议基于HTTP。 HTTP的身份验证要求在&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-11&quot;&gt;[RFC2616]的第11节&lt;/a&gt;中介绍。建议但不要求使用身份验证机制来防止未知或未经授权的客户端进行POST或编辑。不使用身份验证时，客户端和服务器容易受到小规模的欺骗，拒绝服务和破坏攻击。但是，在某些情况下，这是可以接受的风险。部署的身份验证类型是服务器操作员的本地决定。客户端可能会遇到随服务器部署而异的身份验证方案。至少，客户端和服务器实现必须能够配置为使用HTTP基本认证[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC2617&lt;/a&gt;]与TLS 1.0 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2246&quot;&gt;RFC2246&lt;/a&gt; ]或后续标准跟踪版本的TLS（例如[ &lt;a href=&quot;https://tools.ietf.org/html/rfc4346&quot;&gt;RFC4346&lt;/a&gt; ]）建立的连接结合在一起，支持[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2818&quot;&gt;RFC2818]中&lt;/a&gt;所述的在TLS上使用HTTP的约定]。认证机制的选择将影响互操作性。在本规范发布之时，以上提到的最低安全级别（使用TLS的基本身份验证）被认为是Internet应用程序的良好做法，足以为互操作性建立基线。鼓励实施人员在部署时研究并使用被认为等效或较好的替代机制。建议以可以部署新身份验证方案的方式实施客户端。由于此协议使用HTTP响应状态代码作为报告请求结果的主要方式，因此建议服务器使用适当的4xx HTTP响应代码（例如，401&amp;ldquo;未经授权&amp;rdquo;或403&amp;ldquo;禁止&amp;rdquo;）&lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC2617&lt;/a&gt; ]。</target>
        </trans-unit>
        <trans-unit id="b27e5a48d6a66251fa9d4883723e1c6d86c30969" translate="yes" xml:space="preserve">
          <source>The Atom Publishing Protocol uses HTTP methods to author Member
   Resources as follows:

   o  GET is used to retrieve a representation of a known Resource.

   o  POST is used to create a new, dynamically named, Resource.  When
      the client submits non-Atom-Entry representations to a Collection
      for creation, two Resources are always created -- a Media Entry
      for the requested Resource, and a Media Link Entry for metadata
      about the Resource that will appear in the Collection.

   o  PUT is used to edit a known Resource.  It is not used for Resource
      creation.

   o  DELETE is used to remove a known Resource.

   The Atom Protocol only covers the creating, editing, and deleting of
   Entry and Media Resources.  Other Resources could be created, edited,
   and deleted as the result of manipulating a Collection, but the
   number of those Resources, their media types, and effects of Atom
   Protocol operations on them are outside the scope of this
   specification. 

   Since all aspects of client-server interaction are defined in terms
   of HTTP, [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;] should be consulted for any areas not covered in
   this specification.</source>
          <target state="translated">Atom发布协议使用HTTP方法来创作成员资源，如下所示：o GET用于检索已知资源的表示形式。 o POST用于创建新的动态命名资源。当客户端将非原子条目表示形式提交给集合以进行创建时，将始终创建两个资源-所请求资源的媒体条目，以及将出现在集合中的有关资源元数据的媒体链接条目。 o PUT用于编辑已知资源。它不用于资源创建。 o DELETE用于删除已知资源。 Atom协议仅涵盖条目，媒体资源的创建，编辑和删除。通过操纵集合，可以创建，编辑和删除其他资源，但是这些资源的数量，它们的媒体类型以及Atom协议操作对其的影响不在本规范的范围之内。由于客户端-服务器交互的所有方面都是根据HTTP定义的，因此[&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;&lt;/a&gt;对于本规范未涵盖的任何领域，请查阅RFC2616。</target>
        </trans-unit>
        <trans-unit id="42d277116045b96cf12bbfe45ba81c76ae3ef5f2" translate="yes" xml:space="preserve">
          <source>The Atom Syndication Format [&lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt;] defines the &quot;application/
   atom+xml&quot; media type to identify both Atom Feed and Atom Entry
   Documents.  Implementation experience has demonstrated that Atom Feed
   and Entry Documents can have different processing models and that
   there are situations where they need to be differentiated.  This
   specification defines a &quot;type&quot; parameter used to differentiate the
   two types of Atom documents.</source>
          <target state="translated">Atom联合格式[ &lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt; ]定义了&amp;ldquo; application / atom + xml&amp;rdquo;媒体类型，以同时标识Atom Feed和Atom Entry文档。实施经验表明，Atom Feed和Entry Documents可以具有不同的处理模型，并且在某些情况下需要对其进行区分。该规范定义了一个&amp;ldquo;类型&amp;rdquo;参数，用于区分两种类型的Atom文档。</target>
        </trans-unit>
        <trans-unit id="d54dec6d4ad6caa6017041a8dbe37766ea30ecca" translate="yes" xml:space="preserve">
          <source>The CONNECT method can be used to create disproportionate load on an
   proxy, since stream creation is relatively inexpensive when compared
   to the creation and maintenance of a TCP connection.  A proxy might
   also maintain some resources for a TCP connection beyond the closing
   of the stream that carries the CONNECT request, since the outgoing
   TCP connection remains in the TIME_WAIT state.  Therefore, a proxy
   cannot rely on SETTINGS_MAX_CONCURRENT_STREAMS alone to limit the
   resources consumed by CONNECT requests.</source>
          <target state="translated">CONNECT方法可能会对代理造成不成比例的负载,因为与TCP连接的创建和维护相比,流的创建相对便宜。在关闭承载CONNECT请求的流之后,代理还可能为TCP连接维护一些资源,因为流出的TCP连接仍然处于TIME_WAIT状态。因此,代理不能仅仅依靠SETTINGS_MAX_CONCURRENT_STREAMS来限制CONNECT请求所消耗的资源。</target>
        </trans-unit>
        <trans-unit id="6a14656993634aa0a74177de15aa55441d492abb" translate="yes" xml:space="preserve">
          <source>The CONNECT method requests that the recipient establish a tunnel to
   the destination origin server identified by the request-target and,
   if successful, thereafter restrict its behavior to blind forwarding
   of packets, in both directions, until the tunnel is closed.  Tunnels
   are commonly used to create an end-to-end virtual connection, through
   one or more proxies, which can then be secured using TLS (Transport
   Layer Security, [&lt;a href=&quot;https://tools.ietf.org/html/rfc5246&quot;&gt;RFC5246&lt;/a&gt;]).

   CONNECT is intended only for use in requests to a proxy.  An origin
   server that receives a CONNECT request for itself MAY respond with a
   2xx (Successful) status code to indicate that a connection is
   established.  However, most origin servers do not implement CONNECT.

   A client sending a CONNECT request MUST send the authority form of
   request-target (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.3&quot;&gt;Section&amp;nbsp;5.3 of [RFC7230]&lt;/a&gt;); i.e., the request-target
   consists of only the host name and port number of the tunnel
   destination, separated by a colon.  For example,

     CONNECT server.example.com:80 HTTP/1.1
     Host: server.example.com:80

   The recipient proxy can establish a tunnel either by directly
   connecting to the request-target or, if configured to use another
   proxy, by forwarding the CONNECT request to the next inbound proxy.
   Any 2xx (Successful) response indicates that the sender (and all 

   inbound proxies) will switch to tunnel mode immediately after the
   blank line that concludes the successful response's header section;
   data received after that blank line is from the server identified by
   the request-target.  Any response other than a successful response
   indicates that the tunnel has not yet been formed and that the
   connection remains governed by HTTP.

   A tunnel is closed when a tunnel intermediary detects that either
   side has closed its connection: the intermediary MUST attempt to send
   any outstanding data that came from the closed side to the other
   side, close both connections, and then discard any remaining data
   left undelivered.

   Proxy authentication might be used to establish the authority to
   create a tunnel.  For example,

     CONNECT server.example.com:80 HTTP/1.1
     Host: server.example.com:80
     Proxy-Authorization: basic aGVsbG86d29ybGQ=

   There are significant risks in establishing a tunnel to arbitrary
   servers, particularly when the destination is a well-known or
   reserved TCP port that is not intended for Web traffic.  For example,
   a CONNECT to a request-target of &quot;example.com:25&quot; would suggest that
   the proxy connect to the reserved port for SMTP traffic; if allowed,
   that could trick the proxy into relaying spam email.  Proxies that
   support CONNECT SHOULD restrict its use to a limited set of known
   ports or a configurable whitelist of safe request targets.

   A server MUST NOT send any Transfer-Encoding or Content-Length header
   fields in a 2xx (Successful) response to CONNECT.  A client MUST
   ignore any Content-Length or Transfer-Encoding header fields received
   in a successful response to CONNECT.

   A payload within a CONNECT request message has no defined semantics;
   sending a payload body on a CONNECT request might cause some existing
   implementations to reject the request.

   Responses to the CONNECT method are not cacheable.</source>
          <target state="translated">CONNECT方法请求接收者建立到由请求目标标识的目的地原始服务器的隧道，如果成功，则此后将其行为限制为双向盲目转发数据包，直到关闭隧道为止。隧道通常用于通过一个或多个代理创建端到端虚拟连接，然后可以使用TLS（传输层安全性[ &lt;a href=&quot;https://tools.ietf.org/html/rfc5246&quot;&gt;RFC5246&lt;/a&gt;]）。 CONNECT仅用于对代理的请求中。接收到自己的CONNECT请求的源服务器可以使用2xx（成功）状态码进行响应，以指示已建立连接。但是，大多数原始服务器不实现CONNECT。发送CONNECT请求的客户端必须发送请求目标的授权形式（&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.3&quot;&gt;[RFC7230] 5.3节）&lt;/a&gt;）;也就是说，请求目标仅包含隧道目标的主机名和端口号，并用冒号分隔。例如，CONNECT server.example.com:80 HTTP / 1.1主机：server.example.com：80收件人代理可以通过直接连接到请求目标，或者（如果配置为使用另一个代理）通过转发来建立隧道。 CONNECT请求到下一个入站代理。任何2xx（成功）响应都表示发件人（和所有入站代理）将在结束成功响应的标头部分的空白行之后立即切换到隧道模式；空行之后收到的数据来自请求目标所标识的服务器。除成功响应外，任何其他响应都表明尚未建立隧道，并且该连接仍受HTTP控制。当隧道中间人检测到任一方已关闭其连接时，该隧道即被关闭：中间人务必尝试将来自封闭方的任何未完成的数据发送到另一方，同时关闭两个连接，然后丢弃所有未交付的剩余数据。代理身份验证可用于建立创建隧道的权限。例如，CONNECT server.example.com:80 HTTP / 1.1主机：server.example.com：80代理授权：基本aGVsbG86d29ybGQ =建立通往任意服务器的隧道存在很大的风险，特别是当目标是不用于Web流量的众所周知的或保留的TCP端口时。例如，连接到&amp;ldquo; example.com:25&amp;rdquo;的请求目标将建议代理连接到用于SMTP流量的保留端口。如果允许，这可能会诱使代理中继垃圾邮件。支持CONNECT的代理应该将它的使用限制为一组有限的已知端口或安全请求目标的可配置白名单。服务器不得在2xx（成功）响应中向CONNECT发送任何Transfer-Encoding或Content-Length头字段。客户端必须忽略在成功响应CONNECT时收到的任何Content-Length或Transfer-Encoding头字段。 CONNECT请求消息中的有效负载没有定义的语义。在CONNECT请求上发送有效内容主体可能会导致某些现有实现拒绝该请求。对CONNECT方法的响应不可缓存。</target>
        </trans-unit>
        <trans-unit id="44e2ab9943f4c0dd2becd2a23e49a2cb8c91d927" translate="yes" xml:space="preserve">
          <source>The CONTINUATION frame (type=0x9) is used to continue a sequence of
   header block fragments (&lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;).  Any number of CONTINUATION
   frames can be sent, as long as the preceding frame is on the same
   stream and is a HEADERS, PUSH_PROMISE, or CONTINUATION frame without
   the END_HEADERS flag set.

    +---------------------------------------------------------------+
    |                   Header Block Fragment (*)                 
    +---------------------------------------------------------------+

                   Figure 15: CONTINUATION Frame Payload

   The CONTINUATION frame payload contains a header block fragment
   (&lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;). 

   The CONTINUATION frame defines the following flag:

   END_HEADERS (0x4):  When set, bit 2 indicates that this frame ends a
      header block (&lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;).

      If the END_HEADERS bit is not set, this frame MUST be followed by
      another CONTINUATION frame.  A receiver MUST treat the receipt of
      any other type of frame or a frame on a different stream as a
      connection error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type PROTOCOL_ERROR.

   The CONTINUATION frame changes the connection state as defined in
   &lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;.

   CONTINUATION frames MUST be associated with a stream.  If a
   CONTINUATION frame is received whose stream identifier field is 0x0,
   the recipient MUST respond with a connection error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of
   type PROTOCOL_ERROR.

   A CONTINUATION frame MUST be preceded by a HEADERS, PUSH_PROMISE or
   CONTINUATION frame without the END_HEADERS flag set.  A recipient
   that observes violation of this rule MUST respond with a connection
   error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type PROTOCOL_ERROR.</source>
          <target state="translated">CONTINUATION帧（类型= 0x9）用于继续一系列头块片段（&lt;a href=&quot;#section-4.3&quot;&gt;第4.3节&lt;/a&gt;）。只要前一帧在同一流上并且是没有设置END_HEADERS标志的HEADERS，PUSH_PROMISE或CONTINUATION帧，就可以发送任意数量的CONTINUATION帧。 + ------------------------------------------------- -------------- + |标题块片段（*）+ ------------------------------------------- -------------------- +图15：CONTINUATION帧有效载荷CONTINUATION帧有效载荷包含一个头块片段（&lt;a href=&quot;#section-4.3&quot;&gt;第4.3节&lt;/a&gt;）。 CONTINUATION帧定义了以下标志：END_HEADERS（0x4）：置位时，位2指示该帧结束了标头块（&lt;a href=&quot;#section-4.3&quot;&gt;第4.3节）&lt;/a&gt;）。如果未设置END_HEADERS位，则此帧之后必须紧跟另一个CONTINUATION帧。接收者必须将任何其他类型的帧或不同流上的帧的接收视为PROTOCOL_ERROR类型的连接错误（&lt;a href=&quot;#section-5.4.1&quot;&gt;第5.4.1节&lt;/a&gt;）。 CONTINUATION框架按照&lt;a href=&quot;#section-4.3&quot;&gt;第4.3节中的&lt;/a&gt;定义更改连接状态。连续帧必须与流关联。如果接收到流标识符字段为0x0的CONTINUATION帧，则接收者务必以PROTOCOL_ERROR类型的连接错误（&lt;a href=&quot;#section-5.4.1&quot;&gt;第5.4.1节&lt;/a&gt;）做出响应。没有设置END_HEADERS标志的HEADERS，PUSH_PROMISE或CONTINUATION帧必须在CONTINUATION帧之前。观察到违反此规则的收件人必须以连接错误响应（&lt;a href=&quot;#section-5.4.1&quot;&gt;&lt;/a&gt;类型PROTOCOL_ERROR的第5.4.1节）。</target>
        </trans-unit>
        <trans-unit id="5cc173ef45538302331fa209f0189866cab3850f" translate="yes" xml:space="preserve">
          <source>The COPY method creates a duplicate of the source resource identified
   by the Request-URI, in the destination resource identified by the URI
   in the Destination header.  The Destination header MUST be present.
   The exact behavior of the COPY method depends on the type of the
   source resource.

   All WebDAV-compliant resources MUST support the COPY method.
   However, support for the COPY method does not guarantee the ability
   to copy a resource.  For example, separate programs may control
   resources on the same server.  As a result, it may not be possible to
   copy a resource to a location that appears to be on the same server.

   This method is idempotent, but not safe (see &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;Section&amp;nbsp;9.1 of
   [RFC2616]&lt;/a&gt;).  Responses to this method MUST NOT be cached.</source>
          <target state="translated">COPY方法在Destination标头中的URI标识的目标资源中，创建由Request-URI标识的源资源的副本。目标报头必须存在。 COPY方法的确切行为取决于源资源的类型。所有符合WebDAV的资源都必须支持COPY方法。但是，对COPY方法的支持不能保证复制资源的能力。例如，单独的程序可以控制同一服务器上的资源。结果，可能无法将资源复制到似乎在同一服务器上的位置。此方法是幂等的，但并不安全（请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;[RFC2616]的9.1节&lt;/a&gt;）。对此方法的响应绝不能被缓存。</target>
        </trans-unit>
        <trans-unit id="14111f3c8a7b4d6556d104b92402303159cbab91" translate="yes" xml:space="preserve">
          <source>The COPY method on a collection without a Depth header MUST act as if
   a Depth header with value &quot;infinity&quot; was included.  A client may
   submit a Depth header on a COPY on a collection with a value of &quot;0&quot;
   or &quot;infinity&quot;.  Servers MUST support the &quot;0&quot; and &quot;infinity&quot; Depth
   header behaviors on WebDAV-compliant resources.

   An infinite-depth COPY instructs that the collection resource
   identified by the Request-URI is to be copied to the location
   identified by the URI in the Destination header, and all its internal
   member resources are to be copied to a location relative to it,
   recursively through all levels of the collection hierarchy.  Note
   that an infinite-depth COPY of /A/ into /A/B/ could lead to infinite
   recursion if not handled correctly.

   A COPY of &quot;Depth: 0&quot; only instructs that the collection and its
   properties, but not resources identified by its internal member URLs,
   are to be copied.

   Any headers included with a COPY MUST be applied in processing every
   resource to be copied with the exception of the Destination header.

   The Destination header only specifies the destination URI for the
   Request-URI.  When applied to members of the collection identified by
   the Request-URI, the value of Destination is to be modified to
   reflect the current location in the hierarchy.  So, if the Request-
   URI is /a/ with Host header value http://example.com/ and the 

   Destination is http://example.com/b/, then when
   http://example.com/a/c/d is processed, it must use a Destination of
   http://example.com/b/c/d.

   When the COPY method has completed processing, it MUST have created a
   consistent URL namespace at the destination (see &lt;a href=&quot;#section-5.1&quot;&gt;Section 5.1&lt;/a&gt; for the
   definition of namespace consistency).  However, if an error occurs
   while copying an internal collection, the server MUST NOT copy any
   resources identified by members of this collection (i.e., the server
   must skip this subtree), as this would create an inconsistent
   namespace.  After detecting an error, the COPY operation SHOULD try
   to finish as much of the original copy operation as possible (i.e.,
   the server should still attempt to copy other subtrees and their
   members that are not descendants of an error-causing collection).

   So, for example, if an infinite-depth copy operation is performed on
   collection /a/, which contains collections /a/b/ and /a/c/, and an
   error occurs copying /a/b/, an attempt should still be made to copy
   /a/c/.  Similarly, after encountering an error copying a non-
   collection resource as part of an infinite-depth copy, the server
   SHOULD try to finish as much of the original copy operation as
   possible.

   If an error in executing the COPY method occurs with a resource other
   than the resource identified in the Request-URI, then the response
   MUST be a 207 (Multi-Status), and the URL of the resource causing the
   failure MUST appear with the specific error.

   The 424 (Failed Dependency) status code SHOULD NOT be returned in the
   207 (Multi-Status) response from a COPY method.  These responses can
   be safely omitted because the client will know that the progeny of a
   resource could not be copied when the client receives an error for
   the parent.  Additionally, 201 (Created)/204 (No Content) status
   codes SHOULD NOT be returned as values in 207 (Multi-Status)
   responses from COPY methods.  They, too, can be safely omitted
   because they are the default success codes.</source>
          <target state="translated">没有深度标头的集合上的COPY方法必须像包含值&amp;ldquo;无穷大&amp;rdquo;的深度标头一样工作。客户可以在值为&amp;ldquo; 0&amp;rdquo;或&amp;ldquo; infinity&amp;rdquo;的集合的COPY上提交Depth标头。服务器必须在符合WebDAV的资源上支持&amp;ldquo; 0&amp;rdquo;和&amp;ldquo;无限&amp;rdquo;深度标头行为。无限深度COPY指示将Request-URI标识的收集资源复制到Destination标头中URI标识的位置，并将其所有内部成员资源递归复制到相对于其的位置收集层次结构的所有级别。请注意，如果处理不正确，则/ A /到/ A / B /的无限深度COPY可能导致无限递归。 &amp;ldquo;深度：0&amp;rdquo;仅指示要复制集合及其属性，而不复制其内部成员URL所标识的资源。COPY附带的任何标头都必须用于处理要复制的每个资源，但目的地标头除外。 Destination标头仅指定Request-URI的目标URI，当应用于Request-URI标识的集合的成员时，将修改Destination的值以反映层次结构中的当前位置。 -URI为/ a /，主机标头值为http://example.com/，目标为http://example.com/b/，然后在处理http://example.com/a/c/d时，它必须使用http://example.com/b/c/d的目标。COPY方法完成处理后，它必须在目标位置创建了一致的URL名称空间（请参见&lt;a href=&quot;#section-5.1&quot;&gt;第5.1节&lt;/a&gt;（用于命名空间一致性的定义）。但是，如果在复制内部集合时发生错误，则服务器不得复制该集合成员标识的任何资源（即服务器必须跳过此子树），因为这将导致名称空间不一致。在检测到错误之后，COPY操作应尝试完成尽可能多的原始复制操作（即，服务器仍应尝试复制不是引起错误的集合的后代的其他子树及其成员）。因此，例如，如果对包含集合/ a / b /和/ a / c /的集合/ a /执行无限深度复制操作，并且在复制/ a / b /时发生错误，则仍应尝试复制/ a / c /。同样，在将非收集资源作为无限深度副本的一部分复制时遇到错误后，服务器应尝试完成尽可能多的原始副本操作。如果在请求URI中标识的资源以外的资源发生执行COPY方法的错误，则响应必须为207（多状态），并且导致失败的资源的URL必须与特定内容一起出现错误。 COPY方法不应在207（多状态）响应中返回424（依赖关系失败）状态码。可以安全地省略这些响应，因为当客户端收到父级的错误时，客户端将知道无法复制资源的后代。另外，COPY方法的207（多状态）响应中的值不应返回201（已创建）/ 204（无内容）状态码。由于它们是默认的成功代码，因此也可以安全地省略它们。</target>
        </trans-unit>
        <trans-unit id="4ccb4eecacf9e00ad51b2aefeb841f59a202bd7d" translate="yes" xml:space="preserve">
          <source>The CORS mechanism supports secure cross-origin requests and data transfers between browsers and servers. Modern browsers use CORS in APIs such as &lt;code&gt;XMLHttpRequest&lt;/code&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch&lt;/a&gt; to mitigate the risks of cross-origin HTTP requests.</source>
          <target state="translated">CORS机制支持安全的跨域请求以及浏览器和服务器之间的数据传输。现代浏览器在 &lt;code&gt;XMLHttpRequest&lt;/code&gt; 或&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch之类的&lt;/a&gt;API中使用CORS来减轻跨源HTTP请求的风险。</target>
        </trans-unit>
        <trans-unit id="fbbf23077eb5623c9faba43d84ac7826f9fbf870" translate="yes" xml:space="preserve">
          <source>The CORS mechanism supports secure cross-origin requests and data transfers between browsers and web servers. Modern browsers use CORS in an API container such as &lt;code&gt;XMLHttpRequest&lt;/code&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch&lt;/a&gt; to help mitigate the risks of cross-origin HTTP requests.</source>
          <target state="translated">CORS机制支持安全的跨域请求和浏览器与Web服务器之间的数据传输。现代浏览器在 &lt;code&gt;XMLHttpRequest&lt;/code&gt; 或&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch之&lt;/a&gt;类的API容器中使用CORS，以帮助减轻跨源HTTP请求的风险。</target>
        </trans-unit>
        <trans-unit id="96ee35d668c5e43e29f1dd8cb8ffc05ffe8f756d" translate="yes" xml:space="preserve">
          <source>The CORS protocol originally required that behavior but &lt;a href=&quot;https://github.com/whatwg/fetch/commit/0d9a4db8bc02251cc9e391543bb3c1322fb882f2&quot;&gt;was subsequently changed to no longer require it&lt;/a&gt;. However, not all browsers have implemented the change, and so still exhibit the behavior that was originally required.</source>
          <target state="translated">CORS协议最初要求该行为，但&lt;a href=&quot;https://github.com/whatwg/fetch/commit/0d9a4db8bc02251cc9e391543bb3c1322fb882f2&quot;&gt;后来更改为不再需要它&lt;/a&gt;。但是，并非所有的浏览器都实现了此更改，因此仍然表现出最初所需的行为。</target>
        </trans-unit>
        <trans-unit id="90251c7853324d5188765c4d4396bb48f7d83e13" translate="yes" xml:space="preserve">
          <source>The CSP &lt;a href=&quot;content-security-policy/report-uri&quot;&gt;&lt;code&gt;report-uri&lt;/code&gt;&lt;/a&gt; directive should be used with this header, otherwise this header will be an expensive no-op machine.</source>
          <target state="translated">CSP &lt;a href=&quot;content-security-policy/report-uri&quot;&gt; &lt;code&gt;report-uri&lt;/code&gt; &lt;/a&gt;指令应与此头一起使用，否则此头将是昂贵的无操作机器。</target>
        </trans-unit>
        <trans-unit id="bb80a0a4cc2668fea5fc69f81138adf60314c6bd" translate="yes" xml:space="preserve">
          <source>The CSP mechanism allows multiple policies being specified for a resource, including via the &lt;code&gt;Content-Security-Policy&lt;/code&gt; header, the &lt;a href=&quot;content-security-policy-report-only&quot;&gt;&lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt;&lt;/a&gt; header and a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt;&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;&lt;/a&gt; element.</source>
          <target state="translated">CSP机制允许为资源指定多个策略，包括通过 &lt;code&gt;Content-Security-Policy&lt;/code&gt; 标头，&lt;a href=&quot;content-security-policy-report-only&quot;&gt; &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; &lt;/a&gt;标头和&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt; &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; &lt;/a&gt;元素。</target>
        </trans-unit>
        <trans-unit id="3a1440f01ca2c2191b9c319acb6ec56e362606ce" translate="yes" xml:space="preserve">
          <source>The Cache-Control general-header field is used to specify directives
   that MUST be obeyed by all caching mechanisms along the
   request/response chain. The directives specify behavior intended to
   prevent caches from adversely interfering with the request or
   response. These directives typically override the default caching
   algorithms. Cache directives are unidirectional in that the presence
   of a directive in a request does not imply that the same directive is
   to be given in the response.

      Note that HTTP/1.0 caches might not implement Cache-Control and
      might only implement Pragma: no-cache (see &lt;a href=&quot;#section-14.32&quot;&gt;section 14.32&lt;/a&gt;).

   Cache directives MUST be passed through by a proxy or gateway
   application, regardless of their significance to that application,
   since the directives might be applicable to all recipients along the
   request/response chain. It is not possible to specify a cache-
   directive for a specific cache.

    Cache-Control   = &quot;Cache-Control&quot; &quot;:&quot; 1#cache-directive

    cache-directive = cache-request-directive
         | cache-response-directive

    cache-request-directive =
           &quot;no-cache&quot;                          ; &lt;a href=&quot;#section-14.9.1&quot;&gt;Section 14.9.1&lt;/a&gt;
         | &quot;no-store&quot;                          ; &lt;a href=&quot;#section-14.9.2&quot;&gt;Section 14.9.2&lt;/a&gt;
         | &quot;max-age&quot; &quot;=&quot; delta-seconds         ; &lt;a href=&quot;#section-14.9.3&quot;&gt;Section 14.9.3&lt;/a&gt;, 14.9.4
         | &quot;max-stale&quot; [ &quot;=&quot; delta-seconds ]   ; &lt;a href=&quot;#section-14.9.3&quot;&gt;Section 14.9.3&lt;/a&gt;
         | &quot;min-fresh&quot; &quot;=&quot; delta-seconds       ; &lt;a href=&quot;#section-14.9.3&quot;&gt;Section 14.9.3&lt;/a&gt;
         | &quot;no-transform&quot;                      ; &lt;a href=&quot;#section-14.9.5&quot;&gt;Section 14.9.5&lt;/a&gt;
         | &quot;only-if-cached&quot;                    ; &lt;a href=&quot;#section-14.9.4&quot;&gt;Section 14.9.4&lt;/a&gt;
         | cache-extension                     ; &lt;a href=&quot;#section-14.9.6&quot;&gt;Section 14.9.6&lt;/a&gt;

     cache-response-directive =
           &quot;public&quot;                               ; &lt;a href=&quot;#section-14.9.1&quot;&gt;Section 14.9.1&lt;/a&gt;
         | &quot;private&quot; [ &quot;=&quot; &amp;lt;&quot;&amp;gt; 1#field-name &amp;lt;&quot;&amp;gt; ] ; &lt;a href=&quot;#section-14.9.1&quot;&gt;Section 14.9.1&lt;/a&gt;
         | &quot;no-cache&quot; [ &quot;=&quot; &amp;lt;&quot;&amp;gt; 1#field-name &amp;lt;&quot;&amp;gt; ]; &lt;a href=&quot;#section-14.9.1&quot;&gt;Section 14.9.1&lt;/a&gt;
         | &quot;no-store&quot;                             ; &lt;a href=&quot;#section-14.9.2&quot;&gt;Section 14.9.2&lt;/a&gt;
         | &quot;no-transform&quot;                         ; &lt;a href=&quot;#section-14.9.5&quot;&gt;Section 14.9.5&lt;/a&gt;
         | &quot;must-revalidate&quot;                      ; &lt;a href=&quot;#section-14.9.4&quot;&gt;Section 14.9.4&lt;/a&gt;
         | &quot;proxy-revalidate&quot;                     ; &lt;a href=&quot;#section-14.9.4&quot;&gt;Section 14.9.4&lt;/a&gt;
         | &quot;max-age&quot; &quot;=&quot; delta-seconds            ; &lt;a href=&quot;#section-14.9.3&quot;&gt;Section 14.9.3&lt;/a&gt;
         | &quot;s-maxage&quot; &quot;=&quot; delta-seconds           ; &lt;a href=&quot;#section-14.9.3&quot;&gt;Section 14.9.3&lt;/a&gt;
         | cache-extension                        ; &lt;a href=&quot;#section-14.9.6&quot;&gt;Section 14.9.6&lt;/a&gt;

    cache-extension = token [ &quot;=&quot; ( token | quoted-string ) ] 

   When a directive appears without any 1#field-name parameter, the
   directive applies to the entire request or response. When such a
   directive appears with a 1#field-name parameter, it applies only to
   the named field or fields, and not to the rest of the request or
   response. This mechanism supports extensibility; implementations of
   future versions of the HTTP protocol might apply these directives to
   header fields not defined in HTTP/1.1.

   The cache-control directives can be broken down into these general
   categories:

      - Restrictions on what are cacheable; these may only be imposed by
        the origin server.

      - Restrictions on what may be stored by a cache; these may be
        imposed by either the origin server or the user agent.

      - Modifications of the basic expiration mechanism; these may be
        imposed by either the origin server or the user agent.

      - Controls over cache revalidation and reload; these may only be
        imposed by a user agent.

      - Control over transformation of entities.

      - Extensions to the caching system.</source>
          <target state="translated">Cache-Control general-header字段用于指定指令，请求/响应链中的所有缓存机制都必须遵守这些指令。指令指定了旨在防止缓存不利地影响请求或响应的行为。这些指令通常会覆盖默认的缓存算法。高速缓存伪指令是单向的，因为在请求中存在伪指令并不意味着在响应中将给出相同的伪指令。请注意，HTTP / 1.0缓存可能未实现Cache-Control，而可能仅实现了Pragma：no-cache（请参阅&lt;a href=&quot;#section-14.32&quot;&gt;第14.32节）&lt;/a&gt;）。缓存指令必须由代理或网关应用程序传递，无论它们对该应用程序的意义如何，因为这些指令可能适用于请求/响应链上的所有接收者。无法为特定的高速缓存指定高速缓存指令。 Cache-Control =&amp;ldquo; Cache-Control&amp;rdquo;&amp;ldquo;：&amp;rdquo; 1＃cache-directive缓存指令=缓存请求指令|缓存响应指令缓存请求指令=&amp;ldquo; no-cache&amp;rdquo;; &lt;a href=&quot;#section-14.9.1&quot;&gt;第14.9.1节&lt;/a&gt; | &amp;ldquo;无商店&amp;rdquo;；&lt;a href=&quot;#section-14.9.2&quot;&gt;第14.9.2节&lt;/a&gt; | &amp;ldquo; max-age&amp;rdquo;&amp;ldquo; =&amp;rdquo;增量秒；&lt;a href=&quot;#section-14.9.3&quot;&gt;第14.9.3节&lt;/a&gt;，14.9.4 节 | &amp;ldquo;最大陈旧&amp;rdquo;[&amp;ldquo; =&amp;rdquo; delta-seconds]; &lt;a href=&quot;#section-14.9.3&quot;&gt;第14.9.3节&lt;/a&gt; | &amp;ldquo; min-fresh&amp;rdquo;&amp;ldquo; =&amp;rdquo;增量秒；&lt;a href=&quot;#section-14.9.3&quot;&gt;第14.9.3节&lt;/a&gt; | &amp;ldquo;不变换&amp;rdquo;；&lt;a href=&quot;#section-14.9.5&quot;&gt;第14.9.5节&lt;/a&gt; | &amp;ldquo;仅当缓存&amp;rdquo;；&lt;a href=&quot;#section-14.9.4&quot;&gt;第14.9.4节&lt;/a&gt; |缓存扩展&lt;a href=&quot;#section-14.9.6&quot;&gt;14.9.6节&lt;/a&gt; cache-response-directive =&amp;ldquo; public&amp;rdquo;; &lt;a href=&quot;#section-14.9.1&quot;&gt;第14.9.1节&lt;/a&gt; | &amp;ldquo; private&amp;rdquo; [&amp;ldquo; =&amp;rdquo; &amp;lt;&amp;ldquo;&amp;gt; 1＃field-name &amp;lt;&amp;rdquo;&amp;gt;]; &lt;a href=&quot;#section-14.9.1&quot;&gt;第14.9.1节&lt;/a&gt; | &amp;ldquo; no-cache&amp;rdquo; [&amp;ldquo; =&amp;rdquo; &amp;lt;&amp;ldquo;&amp;gt; 1＃field-name &amp;lt;&amp;rdquo;&amp;gt;]; &lt;a href=&quot;#section-14.9.1&quot;&gt;第14.9.1节&lt;/a&gt; | &amp;ldquo;无商店&amp;rdquo;；&lt;a href=&quot;#section-14.9.2&quot;&gt;第14.9.2节&lt;/a&gt; | &amp;ldquo;不变换&amp;rdquo;；&lt;a href=&quot;#section-14.9.5&quot;&gt;第14.9.5节&lt;/a&gt; | &amp;ldquo;必须重新验证&amp;rdquo;；&lt;a href=&quot;#section-14.9.4&quot;&gt;第14.9.4节&lt;/a&gt; | &amp;ldquo;代理重新验证&amp;rdquo;；&lt;a href=&quot;#section-14.9.4&quot;&gt;第14.9.4节&lt;/a&gt; | &amp;ldquo; max-age&amp;rdquo;&amp;ldquo; =&amp;rdquo;增量秒；&lt;a href=&quot;#section-14.9.3&quot;&gt;第14.9.3节&lt;/a&gt; | &amp;ldquo; s-maxage&amp;rdquo;&amp;ldquo; =&amp;rdquo;增量秒；&lt;a href=&quot;#section-14.9.3&quot;&gt;第14.9.3节&lt;/a&gt; |缓存扩展&lt;a href=&quot;#section-14.9.6&quot;&gt;第14.9.6节&lt;/a&gt; cache-extension =令牌[&amp;ldquo; =&amp;rdquo;（令牌| quoted-string）]出现没有任何1＃field-name参数的指令时，该指令适用于整个请求或响应。当这样的指令与1＃field-name参数一起出现时，它仅适用于一个或多个命名字段，而不适用于请求或响应的其余部分。该机制支持可扩展性。 HTTP协议的未来版本的实现可能会将这些指令应用于HTTP / 1.1中未定义的标头字段。缓存控制指令可以分为以下几类：-对可缓存内容的限制；这些只能由原始服务器强加。 -对缓存可能存储的内容的限制；这些可以由原始服务器或用户代理强加。-修改基本到期机制；这些可以由原始服务器或用户代理强加。 -控制缓存重新验证和重新加载；这些只能由用户代理强加。 -控制实体的转换。 -扩展缓存系统。</target>
        </trans-unit>
        <trans-unit id="9324bfa18c0087b8561a3281ae4b9944c65be9ca" translate="yes" xml:space="preserve">
          <source>The Cache-Control header field can be extended through the use of one
   or more cache-extension tokens, each with an optional assigned value.
   Informational extensions (those which do not require a change in
   cache behavior) MAY be added without changing the semantics of other
   directives. Behavioral extensions are designed to work by acting as
   modifiers to the existing base of cache directives. Both the new
   directive and the standard directive are supplied, such that
   applications which do not understand the new directive will default
   to the behavior specified by the standard directive, and those that
   understand the new directive will recognize it as modifying the
   requirements associated with the standard directive. In this way,
   extensions to the cache-control directives can be made without
   requiring changes to the base protocol.

   This extension mechanism depends on an HTTP cache obeying all of the
   cache-control directives defined for its native HTTP-version, obeying
   certain extensions, and ignoring all directives that it does not
   understand.

   For example, consider a hypothetical new response directive called
   community which acts as a modifier to the private directive. We
   define this new directive to mean that, in addition to any non-shared
   cache, any cache which is shared only by members of the community
   named within its value may cache the response. An origin server
   wishing to allow the UCI community to use an otherwise private
   response in their shared cache(s) could do so by including

       Cache-Control: private, community=&quot;UCI&quot;

   A cache seeing this header field will act correctly even if the cache
   does not understand the community cache-extension, since it will also
   see and understand the private directive and thus default to the safe
   behavior. 

   Unrecognized cache-directives MUST be ignored; it is assumed that any
   cache-directive likely to be unrecognized by an HTTP/1.1 cache will
   be combined with standard directives (or the response's default
   cacheability) such that the cache behavior will remain minimally
   correct even if the cache does not understand the extension(s).</source>
          <target state="translated">Cache-Control头域可以通过使用一个或多个cache-extension标记来扩展,每个标记都有一个可选的赋值。信息性扩展(那些不需要改变缓存行为的扩展)可以在不改变其他指令语义的情况下被添加。行为性扩展是作为现有缓存指令基础的修改器而设计的。新指令和标准指令都被提供了,这样,不理解新指令的应用程序将默认为标准指令所指定的行为,而理解新指令的应用程序将承认它修改了与标准指令相关的要求。通过这种方式,可以在不需要修改基础协议的情况下对缓存控制指令进行扩展。这种扩展机制依赖于HTTP缓存服从所有为其原生HTTP-版本定义的缓存控制指令,服从某些扩展,并忽略所有它不理解的指令。例如,考虑一个名为community的假设性新响应指令,它作为私有指令的修饰符。我们将这个新指令定义为,除了任何非共享的缓存外,任何仅由其值中命名的community成员共享的缓存都可以缓存响应。一个希望允许UCI社区在他们的共享缓存中使用原本私有的响应的起源服务器可以通过包含Cache-Control:private,community=&quot;UCI&quot; 看到这个头字段的缓存将正确地行动,即使缓存不理解社区缓存扩展,因为它也会看到并理解私有指令,从而默认为安全行为。未识别的缓存指令必须被忽略;我们假设任何可能未被HTTP/1.1缓存识别的缓存指令将与标准指令(或响应的默认缓存性)相结合,这样即使缓存不理解扩展,缓存行为也会保持最低限度的正确性。</target>
        </trans-unit>
        <trans-unit id="f33f8e03ed1edc160f54d39609d6b7e8bfc2a2f7" translate="yes" xml:space="preserve">
          <source>The Cache-Control header field can be extended through the use of one
   or more cache-extension tokens, each with an optional value.  A cache
   MUST ignore unrecognized cache directives.

   Informational extensions (those that do not require a change in cache
   behavior) can be added without changing the semantics of other
   directives.

   Behavioral extensions are designed to work by acting as modifiers to
   the existing base of cache directives.  Both the new directive and
   the old directive are supplied, such that applications that do not
   understand the new directive will default to the behavior specified
   by the old directive, and those that understand the new directive
   will recognize it as modifying the requirements associated with the
   old directive.  In this way, extensions to the existing cache-control
   directives can be made without breaking deployed caches.

   For example, consider a hypothetical new response directive called
   &quot;community&quot; that acts as a modifier to the private directive: in
   addition to private caches, any cache that is shared only by members
   of the named community is allowed to cache the response.  An origin
   server wishing to allow the UCI community to use an otherwise private
   response in their shared cache(s) could do so by including

     Cache-Control: private, community=&quot;UCI&quot;

   A cache that recognizes such a community cache-extension could
   broaden its behavior in accordance with that extension.  A cache that
   does not recognize the community cache-extension would ignore it and
   adhere to the private directive.</source>
          <target state="translated">Cache-Control头字段可以通过使用一个或多个cache-extension标记来扩展,每个标记都有一个可选的值。缓存必须忽略未识别的缓存指令。信息性扩展(那些不需要改变缓存行为的扩展)可以在不改变其他指令语义的情况下被添加。行为性扩展是通过作为现有缓存指令基础的修改器来工作的。同时提供新指令和旧指令,这样,不理解新指令的应用程序将默认为旧指令指定的行为,而理解新指令的应用程序将承认它修改了与旧指令相关的要求。通过这种方式,可以在不破坏部署的缓存的情况下对现有的缓存控制指令进行扩展。例如,考虑一个名为 &quot;community &quot;的假设性新响应指令,它作为私有指令的修改器:除了私有缓存外,任何仅由命名的community成员共享的缓存都允许缓存响应。希望允许UCI社区在他们的共享缓存中使用私有响应的起源服务器可以通过包含Cache-Control:private,community=&quot;UCI&quot; 识别这样一个社区缓存扩展的缓存可以根据该扩展扩展其行为。不承认社区缓存扩展的缓存将忽略它,并遵守私有指令。</target>
        </trans-unit>
        <trans-unit id="b85b1bbcc9141ccc627797dbf9d5406273b17461" translate="yes" xml:space="preserve">
          <source>The California Consumer Privacy Act</source>
          <target state="translated">加州消费者隐私法</target>
        </trans-unit>
        <trans-unit id="c50007c31e7e40ed5eaa0ff3024c3f4a7f1a8be9" translate="yes" xml:space="preserve">
          <source>The Chrome (or Chromium/Blink-based engines) user agent string is similar to Firefox&amp;rsquo;s. For compatibility, it adds strings like &lt;code&gt;KHTML, like Gecko&lt;/code&gt; and &lt;code&gt;Safari&lt;/code&gt;.</source>
          <target state="translated">Chrome（或基于Chromium / Blink的引擎）用户代理字符串与Firefox相似。为了兼容，它添加了诸如 &lt;code&gt;KHTML, like Gecko&lt;/code&gt; 字符串，如Gecko和 &lt;code&gt;Safari&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e4526b0c406ce54b0f40282cbe0ea0db53127d37" translate="yes" xml:space="preserve">
          <source>The Chrome (or Chromium/blink-based engines) user agent string is similar to the Firefox format. For compatibility, it adds strings like &quot;KHTML, like Gecko&quot; and &quot;Safari&quot;.</source>
          <target state="translated">Chrome(或基于Chromium/blink的引擎)用户代理字符串与Firefox格式类似。为了兼容性,它增加了 &quot;KHTML,像Gecko &quot;和 &quot;Safari &quot;等字符串。</target>
        </trans-unit>
        <trans-unit id="4e445db7bcb2d5d8898885e114adb8cb0619ec53" translate="yes" xml:space="preserve">
          <source>The Connection general-header field allows the sender to specify
   options that are desired for that particular connection and MUST NOT
   be communicated by proxies over further connections.

   The Connection header has the following grammar:

       Connection = &quot;Connection&quot; &quot;:&quot; 1#(connection-token)
       connection-token  = token

   HTTP/1.1 proxies MUST parse the Connection header field before a
   message is forwarded and, for each connection-token in this field,
   remove any header field(s) from the message with the same name as the
   connection-token. Connection options are signaled by the presence of
   a connection-token in the Connection header field, not by any
   corresponding additional header field(s), since the additional header
   field may not be sent if there are no parameters associated with that
   connection option.

   Message headers listed in the Connection header MUST NOT include
   end-to-end headers, such as Cache-Control.

   HTTP/1.1 defines the &quot;close&quot; connection option for the sender to
   signal that the connection will be closed after completion of the
   response. For example,

       Connection: close

   in either the request or the response header fields indicates that
   the connection SHOULD NOT be considered `persistent' (&lt;a href=&quot;#section-8.1&quot;&gt;section 8.1&lt;/a&gt;)
   after the current request/response is complete.

   HTTP/1.1 applications that do not support persistent connections MUST
   include the &quot;close&quot; connection option in every message.

   A system receiving an HTTP/1.0 (or lower-version) message that
   includes a Connection header MUST, for each connection-token in this
   field, remove and ignore any header field(s) from the message with
   the same name as the connection-token. This protects against mistaken
   forwarding of such header fields by pre-HTTP/1.1 proxies. See &lt;a href=&quot;#section-19.6.2&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-19.6.2&quot;&gt;19.6.2&lt;/a&gt;.</source>
          <target state="translated">连接通用头字段允许发送方指定该特定连接所需的选项，并且代理不得在其他连接上进行通信。 Connection标头具有以下语法：Connection =&amp;ldquo; Connection&amp;rdquo;&amp;ldquo; ::&amp;rdquo; 1＃（connection-token）connection-token =令牌HTTP / 1.1代理必须在转发消息之前对Connection标头字段进行解析，并针对每个连接令牌在此字段中，从消息中删除与连接令牌同名的所有标头字段。连接选项是通过Connection标头字段中存在连接令牌而不是任何相应的其他标头字段来表示的，因为如果没有与该连接选项关联的参数，则可能不会发送附加头字段。连接头中列出的消息头不得包含端对端头，例如Cache-Control。 HTTP / 1.1为发送方定义了&amp;ldquo;关闭&amp;rdquo;连接选项，以指示响应完成后将关闭连接。例如，在请求或响应标头字段中的Connection：close指示不应将连接视为&amp;ldquo;持久&amp;rdquo;（发送者的连接选项，用于指示响应完成后将关闭连接。例如，在请求或响应标头字段中的Connection：close指示不应将连接视为&amp;ldquo;持久&amp;rdquo;（发送者的连接选项，用于指示响应完成后将关闭连接。例如，在请求或响应标头字段中的Connection：close指示不应将连接视为&amp;ldquo;持久&amp;rdquo;（&lt;a href=&quot;#section-8.1&quot;&gt;第8.1节&lt;/a&gt;）在当前请求/响应完成之后。不支持持久连接的HTTP / 1.1应用程序必须在每条消息中都包含&amp;ldquo;关闭&amp;rdquo;连接选项。接收包含连接标头的HTTP / 1.0（或更低版本）消息的系统，对于此字段中的每个连接令牌，必须从消息中删除并忽略与该标头同名的任何标头字段，令牌。这样可以防止HTTP / 1.1之前的代理错误转发此类标头字段。参见&lt;a href=&quot;#section-19.6.2&quot;&gt;第&lt;/a&gt;&lt;a href=&quot;#section-19.6.2&quot;&gt;19.6.2 &lt;/a&gt;节。</target>
        </trans-unit>
        <trans-unit id="400f4aed66b4ae488aed6a9f1d0ba0a1d48e0bf5" translate="yes" xml:space="preserve">
          <source>The Connection header field (&lt;a href=&quot;#section-6.1&quot;&gt;Section 6.1&lt;/a&gt;) provides a &quot;close&quot;
   connection option that a sender SHOULD send when it wishes to close
   the connection after the current request/response pair.

   A client that sends a &quot;close&quot; connection option MUST NOT send further
   requests on that connection (after the one containing &quot;close&quot;) and
   MUST close the connection after reading the final response message
   corresponding to this request.

   A server that receives a &quot;close&quot; connection option MUST initiate a
   close of the connection (see below) after it sends the final response
   to the request that contained &quot;close&quot;.  The server SHOULD send a
   &quot;close&quot; connection option in its final response on that connection.
   The server MUST NOT process any further requests received on that
   connection.

   A server that sends a &quot;close&quot; connection option MUST initiate a close
   of the connection (see below) after it sends the response containing
   &quot;close&quot;.  The server MUST NOT process any further requests received
   on that connection.

   A client that receives a &quot;close&quot; connection option MUST cease sending
   requests on that connection and close the connection after reading
   the response message containing the &quot;close&quot;; if additional pipelined
   requests had been sent on the connection, the client SHOULD NOT
   assume that they will be processed by the server. 

   If a server performs an immediate close of a TCP connection, there is
   a significant risk that the client will not be able to read the last
   HTTP response.  If the server receives additional data from the
   client on a fully closed connection, such as another request that was
   sent by the client before receiving the server's response, the
   server's TCP stack will send a reset packet to the client;
   unfortunately, the reset packet might erase the client's
   unacknowledged input buffers before they can be read and interpreted
   by the client's HTTP parser.

   To avoid the TCP reset problem, servers typically close a connection
   in stages.  First, the server performs a half-close by closing only
   the write side of the read/write connection.  The server then
   continues to read from the connection until it receives a
   corresponding close by the client, or until the server is reasonably
   certain that its own TCP stack has received the client's
   acknowledgement of the packet(s) containing the server's last
   response.  Finally, the server fully closes the connection.

   It is unknown whether the reset problem is exclusive to TCP or might
   also be found in other transport connection protocols.</source>
          <target state="translated">连接头字段（&lt;a href=&quot;#section-6.1&quot;&gt;第6.1节&lt;/a&gt;）提供了&amp;ldquo;关闭&amp;rdquo;连接选项，当发送方希望在当前请求/响应对之后关闭连接时，发送方应该发送该连接选项。发送&amp;ldquo;关闭&amp;rdquo;连接选项的客户端不得在该连接上发送进一步的请求（在包含&amp;ldquo;关闭&amp;rdquo;的连接之后），并且必须在读取与该请求相对应的最终响应消息后关闭该连接。收到&amp;ldquo;关闭&amp;rdquo;连接选项的服务器在发送对包含&amp;ldquo;关闭&amp;rdquo;的请求的最终响应后，必须启动连接的关闭（请参见下文）。服务器应该在对该连接的最终响应中发送&amp;ldquo;关闭&amp;rdquo;连接选项。服务器不得处理在该连接上收到的任何其他请求。发送&amp;ldquo;&amp;ldquo;关闭&amp;rdquo;连接选项必须在发送包含&amp;ldquo;关闭&amp;rdquo;的响应后启动连接的关闭（请参见下文）。服务器不得处理该连接上收到的任何其他请求。收到&amp;ldquo;关闭&amp;rdquo;连接选项的客户端必须停止在读取包含&amp;ldquo;关闭&amp;rdquo;的响应消息后，在该连接上发送请求并关闭该连接；如果在该连接上发送了其他流水线请求，则客户端不应假定服务器将处理它们。立即关闭TCP连接，则存在很大的风险，即客户端将无法读取最后的HTTP响应。如果服务器在完全关闭的连接上从客户端接收到其他数据，例如，客户端在收到服务器响应之前发送的另一个请求，服务器的TCP堆栈将向客户端发送重置数据包；不幸的是，在客户端的HTTP解析器可以读取和解释它们之前，复位数据包可能会擦除客户端的未确认输入缓冲区。为了避免TCP重置问题，服务器通常分阶段关闭连接。首先，服务器通过仅关闭读/写连接的写侧来执行半关闭。然后，服务器继续从连接中读取数据，直到服务器接收到客户端的相应关闭，或者直到服务器合理地确定其自己的TCP堆栈已收到客户端对包含服务器最后响应的数据包的确认为止。最后，服务器完全关闭连接。重置问题是TCP独占的还是其他传输连接协议中也可能存在，这是未知的。</target>
        </trans-unit>
        <trans-unit id="e4269110c11e8492bcb4464320596b28df93a15f" translate="yes" xml:space="preserve">
          <source>The Content-Disposition response-header field has been proposed as a
   means for the origin server to suggest a default filename if the user
   requests that the content is saved to a file. This usage is derived
   from the definition of Content-Disposition in &lt;a href=&quot;https://tools.ietf.org/html/rfc1806&quot;&gt;RFC 1806&lt;/a&gt; [&lt;a href=&quot;#ref-35&quot;&gt;35&lt;/a&gt;].

        content-disposition = &quot;Content-Disposition&quot; &quot;:&quot;
                              disposition-type *( &quot;;&quot; disposition-parm )
        disposition-type = &quot;attachment&quot; | disp-extension-token
        disposition-parm = filename-parm | disp-extension-parm
        filename-parm = &quot;filename&quot; &quot;=&quot; quoted-string
        disp-extension-token = token
        disp-extension-parm = token &quot;=&quot; ( token | quoted-string )

   An example is

        Content-Disposition: attachment; filename=&quot;fname.ext&quot;

   The receiving user agent SHOULD NOT respect any directory path
   information present in the filename-parm parameter, which is the only
   parameter believed to apply to HTTP implementations at this time. The
   filename SHOULD be treated as a terminal component only.

   If this header is used in a response with the application/octet-
   stream content-type, the implied suggestion is that the user agent
   should not display the response, but directly enter a `save response
   as...' dialog.

   See &lt;a href=&quot;#section-15.5&quot;&gt;section 15.5&lt;/a&gt; for Content-Disposition security issues.</source>
          <target state="translated">已经提出了Content-Disposition响应标头字段，作为原始服务器在用户请求将内容保存到文件时建议默认文件名的一种方式。这种用法是从&lt;a href=&quot;https://tools.ietf.org/html/rfc1806&quot;&gt;RFC 1806&lt;/a&gt; [ &lt;a href=&quot;#ref-35&quot;&gt;35&lt;/a&gt;]。 content-disposition =&amp;ldquo; Content-Disposition&amp;rdquo;&amp;ldquo;：&amp;rdquo;处置类型*（&amp;ldquo;;&amp;rdquo; disposition-parm）处置类型=&amp;ldquo; attachment&amp;rdquo; | disp-extension-token处置参数=文件名-参数| disp-extension-parm filename-parm =&amp;ldquo; filename&amp;rdquo;&amp;ldquo; =&amp;rdquo;带引号的字符串disp-extension-token =令牌disp-extension-parm =令牌&amp;ldquo; =&amp;rdquo;（token | quoted-string）一个示例是Content-Disposition：附件; filename =&amp;ldquo; fname.ext&amp;rdquo;接收方用户代理不应遵守filename-parm参数中存在的任何目录路径信息，该参数是目前被认为适用于HTTP实现的唯一参数。文件名应仅被视为终端组件。如果此标头用于应用程序/八位流内容类型的响应中，则暗示建议用户代理不应显示该响应，而应直接输入&amp;ldquo;将响应另存为...&amp;rdquo;对话框。看到&lt;a href=&quot;#section-15.5&quot;&gt;&lt;/a&gt;关于内容处置安全性问题的15.5节。</target>
        </trans-unit>
        <trans-unit id="22177303e5c541de4c1a2fb13e69fc833be5a044" translate="yes" xml:space="preserve">
          <source>The Content-Encoding entity-header field is used as a modifier to the
   media-type. When present, its value indicates what additional content
   codings have been applied to the entity-body, and thus what decoding
   mechanisms must be applied in order to obtain the media-type
   referenced by the Content-Type header field. Content-Encoding is
   primarily used to allow a document to be compressed without losing
   the identity of its underlying media type.

       Content-Encoding  = &quot;Content-Encoding&quot; &quot;:&quot; 1#content-coding

   Content codings are defined in &lt;a href=&quot;#section-3.5&quot;&gt;section 3.5&lt;/a&gt;. An example of its use is

       Content-Encoding: gzip

   The content-coding is a characteristic of the entity identified by
   the Request-URI. Typically, the entity-body is stored with this
   encoding and is only decoded before rendering or analogous usage.
   However, a non-transparent proxy MAY modify the content-coding if the
   new coding is known to be acceptable to the recipient, unless the
   &quot;no-transform&quot; cache-control directive is present in the message.

   If the content-coding of an entity is not &quot;identity&quot;, then the
   response MUST include a Content-Encoding entity-header (&lt;a href=&quot;#section-14.11&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-14.11&quot;&gt;14.11&lt;/a&gt;) that lists the non-identity content-coding(s) used.

   If the content-coding of an entity in a request message is not
   acceptable to the origin server, the server SHOULD respond with a
   status code of 415 (Unsupported Media Type).

   If multiple encodings have been applied to an entity, the content
   codings MUST be listed in the order in which they were applied.
   Additional information about the encoding parameters MAY be provided
   by other entity-header fields not defined by this specification.</source>
          <target state="translated">&amp;ldquo;内容编码实体标题&amp;rdquo;字段用作媒体类型的修饰符。当存在时，其值指示已将哪些其他内容编码应用于实体，因此必须应用哪种解码机制才能获得Content-Type标头字段引用的媒体类型。内容编码主要用于允许压缩文档而不会丢失其基础媒体类型的标识。Content-Encoding =&amp;ldquo; Content-Encoding&amp;rdquo;&amp;ldquo;：&amp;rdquo; 1＃content-coding内容编码在&lt;a href=&quot;#section-3.5&quot;&gt;3.5节&lt;/a&gt;中定义。其用法的一个示例是Content-Encoding：gzip content-coding是由Request-URI标识的实体的特征。通常，实体-主体使用此编码存储，并且仅在渲染或类似用法之前进行解码。但是，如果已知新的编码是接收者可以接受的，则非透明代理可以修改内容编码，除非消息中存在&amp;ldquo; no-transform&amp;rdquo;缓存控制指令。如果实体的内容编码不是&amp;ldquo; identity&amp;rdquo;，则响应必须包含一个Content-Encoding实体头（&lt;a href=&quot;#section-14.11&quot;&gt;第&lt;/a&gt;&lt;a href=&quot;#section-14.11&quot;&gt;14.11 &lt;/a&gt;节）），其中列出了使用的非身份内容编码。如果请求消息中实体的内容编码对原始服务器不可接受，则服务器应以状态代码415（不支持的媒体类型）进行响应。如果对实体应用了多种编码，则内容编码必须按其应用顺序列出。关于编码参数的附加信息可以由本规范未定义的其他实体报头字段提供。</target>
        </trans-unit>
        <trans-unit id="78e0f66604a34d6350aaee50ec1aed948b641dff" translate="yes" xml:space="preserve">
          <source>The Content-Language entity-header field describes the natural
   language(s) of the intended audience for the enclosed entity. Note
   that this might not be equivalent to all the languages used within
   the entity-body.

       Content-Language  = &quot;Content-Language&quot; &quot;:&quot; 1#language-tag 

   Language tags are defined in &lt;a href=&quot;#section-3.10&quot;&gt;section 3.10&lt;/a&gt;. The primary purpose of
   Content-Language is to allow a user to identify and differentiate
   entities according to the user's own preferred language. Thus, if the
   body content is intended only for a Danish-literate audience, the
   appropriate field is

       Content-Language: da

   If no Content-Language is specified, the default is that the content
   is intended for all language audiences. This might mean that the
   sender does not consider it to be specific to any natural language,
   or that the sender does not know for which language it is intended.

   Multiple languages MAY be listed for content that is intended for
   multiple audiences. For example, a rendition of the &quot;Treaty of
   Waitangi,&quot; presented simultaneously in the original Maori and English
   versions, would call for

       Content-Language: mi, en

   However, just because multiple languages are present within an entity
   does not mean that it is intended for multiple linguistic audiences.
   An example would be a beginner's language primer, such as &quot;A First
   Lesson in Latin,&quot; which is clearly intended to be used by an
   English-literate audience. In this case, the Content-Language would
   properly only include &quot;en&quot;.

   Content-Language MAY be applied to any media type -- it is not
   limited to textual documents.</source>
          <target state="translated">Content-Language实体标题字段描述了封闭实体的预期受众的自然语言。请注意，这可能并不等同于实体主体中使用的所有语言。 Content-Language =&amp;ldquo; Content-Language&amp;rdquo;&amp;ldquo; ::&amp;rdquo; 1＃language-tag语言标签在&lt;a href=&quot;#section-3.10&quot;&gt;3.10节&lt;/a&gt;中定义。内容语言的主要目的是允许用户根据用户自己喜欢的语言来识别和区分实体。因此，如果正文内容仅适用于丹麦语读者，则适当的字段为Content-Language：da如果未指定Content-Language，则默认值为该内容适用于所有语言的读者。这可能意味着发件人不认为它是特定于任何自然语言的，或者发件人不知道它打算使用哪种语言。可能会列出针对多种受众的内容使用多种语言。例如，在原始毛利语和英语版本中同时呈现的&amp;ldquo;怀唐伊条约&amp;rdquo;的译本将要求使用Content-Language：mi，zh_cn但是，仅仅因为一个实体中存在多种语言，并不意味着它旨在用于多种语言的受众。一个例子是初学者的语言入门，例如&amp;ldquo;拉丁文的第一课&amp;rdquo;，显然是供有英语水平的听众使用的。在这种情况下，内容语言将只包含&amp;ldquo; en&amp;rdquo;。内容语言可以应用于任何媒体类型-不限于文本文档。内容语言将只包含&amp;ldquo; en&amp;rdquo;。内容语言可以应用于任何媒体类型-不限于文本文档。内容语言将只包含&amp;ldquo; en&amp;rdquo;。内容语言可以应用于任何媒体类型-不限于文本文档。</target>
        </trans-unit>
        <trans-unit id="a1abd3b0ff945fb9c54be7f36c23b898d0262eca" translate="yes" xml:space="preserve">
          <source>The Content-Length entity-header field indicates the size of the
   entity-body, in decimal number of OCTETs, sent to the recipient or,
   in the case of the HEAD method, the size of the entity-body that
   would have been sent had the request been a GET.

       Content-Length    = &quot;Content-Length&quot; &quot;:&quot; 1*DIGIT

   An example is

       Content-Length: 3495

   Applications SHOULD use this field to indicate the transfer-length of
   the message-body, unless this is prohibited by the rules in &lt;a href=&quot;#section-4.4&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-4.4&quot;&gt;4.4&lt;/a&gt;. 

   Any Content-Length greater than or equal to zero is a valid value.
   &lt;a href=&quot;#section-4.4&quot;&gt;Section 4.4&lt;/a&gt; describes how to determine the length of a message-body
   if a Content-Length is not given.

   Note that the meaning of this field is significantly different from
   the corresponding definition in MIME, where it is an optional field
   used within the &quot;message/external-body&quot; content-type. In HTTP, it
   SHOULD be sent whenever the message's length can be determined prior
   to being transferred, unless this is prohibited by the rules in
   &lt;a href=&quot;#section-4.4&quot;&gt;section 4.4&lt;/a&gt;.</source>
          <target state="translated">Content-Length实体标头字段指示发送给接收方的实体的大小（以OCTET的十进制数为单位），如果使用HEAD方法，则表示已发送的实体的大小。该请求是GET。 Content-Length =&amp;ldquo; Content-Length&amp;rdquo;&amp;ldquo;：&amp;rdquo; 1 * DIGIT例如Content-Length：3495应用程序应使用此字段指示消息正文的传输长度，除非&lt;a href=&quot;#section-4.4&quot;&gt;第&lt;/a&gt;&lt;a href=&quot;#section-4.4&quot;&gt;4.4 &lt;/a&gt;节中的规则禁止。任何大于或等于零的Content-Length都是有效值。 &lt;a href=&quot;#section-4.4&quot;&gt;第4.4节&lt;/a&gt;描述了如果未指定Content-Length时如何确定消息正文的长度。请注意，此字段的含义与MIME中的相应定义明显不同，MIME是MIME中相应的定义，它是&amp;ldquo;消息/外部主体&amp;rdquo;内容类型中使用的可选字段。在HTTP中，只要在传输之前可以确定消息的长度，就应该发送该消息，除非&lt;a href=&quot;#section-4.4&quot;&gt;4.4节中&lt;/a&gt;的规则禁止这样做 。</target>
        </trans-unit>
        <trans-unit id="f5000316ac8e17d070fa4e93bb14ed2071d4d60f" translate="yes" xml:space="preserve">
          <source>The Content-Location entity-header field MAY be used to supply the
   resource location for the entity enclosed in the message when that
   entity is accessible from a location separate from the requested
   resource's URI. A server SHOULD provide a Content-Location for the
   variant corresponding to the response entity; especially in the case
   where a resource has multiple entities associated with it, and those
   entities actually have separate locations by which they might be
   individually accessed, the server SHOULD provide a Content-Location
   for the particular variant which is returned.

       Content-Location = &quot;Content-Location&quot; &quot;:&quot;
                         ( absoluteURI | relativeURI )

   The value of Content-Location also defines the base URI for the
   entity.

   The Content-Location value is not a replacement for the original
   requested URI; it is only a statement of the location of the resource
   corresponding to this particular entity at the time of the request.
   Future requests MAY specify the Content-Location URI as the request-
   URI if the desire is to identify the source of that particular
   entity.

   A cache cannot assume that an entity with a Content-Location
   different from the URI used to retrieve it can be used to respond to
   later requests on that Content-Location URI. However, the Content-
   Location can be used to differentiate between multiple entities
   retrieved from a single requested resource, as described in &lt;a href=&quot;#section-13.6&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-13.6&quot;&gt;13.6&lt;/a&gt;.

   If the Content-Location is a relative URI, the relative URI is
   interpreted relative to the Request-URI.

   The meaning of the Content-Location header in PUT or POST requests is
   undefined; servers are free to ignore it in those cases.</source>
          <target state="translated">当可以从与请求资源的URI不同的位置访问该实体时，可以使用Content-Location实体头字段为消息中包含的实体提供资源位置。服务器应为对应于响应实体的变量提供Content-Location；特别是在一个资源有多个与之相关联的实体，并且这些实体实际上具有可以单独访问它们的单独位置的情况下，服务器应该为返回的特定变体提供一个Content-Location。 Content-Location =&amp;ldquo; Content-Location&amp;rdquo;&amp;ldquo;：&amp;rdquo;（absoluteURI | relativeURI）Content-Location的值还定义了实体的基本URI。Content-Location值不能替代原始请求的URI。它仅是请求时与该特定实体相对应的资源位置的声明。如果希望识别特定实体的来源，将来的请求可以将Content-Location URI指定为request-URI。缓存不能假定Content-Location不同于用于检索它的URI的实体可用于响应对该Content-Location URI的后续请求。但是，内容位置可用于区分从单个请求的资源检索到的多个实体，如它仅是请求时与该特定实体相对应的资源位置的声明。如果希望识别特定实体的来源，以后的请求可以将Content-Location URI指定为请求URI。缓存不能假定Content-Location与用于检索它的URI不同的实体可以用于响应对该Content-Location URI的后续请求。但是，内容位置可用于区分从单个请求的资源检索到的多个实体，如它仅是请求时与该特定实体相对应的资源位置的声明。如果希望识别特定实体的来源，以后的请求可以将Content-Location URI指定为请求URI。缓存不能假定Content-Location与用于检索它的URI不同的实体可以用于响应对该Content-Location URI的后续请求。但是，内容位置可用于区分从单个请求的资源检索到的多个实体，如缓存不能假定Content-Location与用于检索它的URI不同的实体可以用于响应对该Content-Location URI的后续请求。但是，内容位置可用于区分从单个请求的资源中检索到的多个实体，如缓存不能假定Content-Location与用于检索它的URI不同的实体可以用于响应对该Content-Location URI的后续请求。但是，内容位置可用于区分从单个请求的资源检索到的多个实体，如&lt;a href=&quot;#section-13.6&quot;&gt;第&lt;/a&gt;&lt;a href=&quot;#section-13.6&quot;&gt;13.6 &lt;/a&gt;节。如果Content-Location是相对URI，则相对URI是相对于请求URI解释的。PUT或POST请求中Content-Location标头的含义未定义；在这种情况下，服务器可以随意忽略它。</target>
        </trans-unit>
        <trans-unit id="6782e7664ef97f5aa5c3c489b023d738a78d068c" translate="yes" xml:space="preserve">
          <source>The Content-MD5 entity-header field, as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc1864&quot;&gt;RFC 1864&lt;/a&gt; [&lt;a href=&quot;#ref-23&quot;&gt;23&lt;/a&gt;], is
   an MD5 digest of the entity-body for the purpose of providing an
   end-to-end message integrity check (MIC) of the entity-body. (Note: a
   MIC is good for detecting accidental modification of the entity-body
   in transit, but is not proof against malicious attacks.)

        Content-MD5   = &quot;Content-MD5&quot; &quot;:&quot; md5-digest
        md5-digest   = &amp;lt;base64 of 128 bit MD5 digest as per &lt;a href=&quot;https://tools.ietf.org/html/rfc1864&quot;&gt;RFC 1864&lt;/a&gt;&amp;gt;

   The Content-MD5 header field MAY be generated by an origin server or
   client to function as an integrity check of the entity-body. Only
   origin servers or clients MAY generate the Content-MD5 header field;
   proxies and gateways MUST NOT generate it, as this would defeat its
   value as an end-to-end integrity check. Any recipient of the entity-
   body, including gateways and proxies, MAY check that the digest value
   in this header field matches that of the entity-body as received.

   The MD5 digest is computed based on the content of the entity-body,
   including any content-coding that has been applied, but not including
   any transfer-encoding applied to the message-body. If the message is
   received with a transfer-encoding, that encoding MUST be removed
   prior to checking the Content-MD5 value against the received entity.

   This has the result that the digest is computed on the octets of the
   entity-body exactly as, and in the order that, they would be sent if
   no transfer-encoding were being applied.

   HTTP extends &lt;a href=&quot;https://tools.ietf.org/html/rfc1864&quot;&gt;RFC 1864&lt;/a&gt; to permit the digest to be computed for MIME
   composite media-types (e.g., multipart/* and message/rfc822), but
   this does not change how the digest is computed as defined in the
   preceding paragraph.

   There are several consequences of this. The entity-body for composite
   types MAY contain many body-parts, each with its own MIME and HTTP
   headers (including Content-MD5, Content-Transfer-Encoding, and
   Content-Encoding headers). If a body-part has a Content-Transfer-
   Encoding or Content-Encoding header, it is assumed that the content
   of the body-part has had the encoding applied, and the body-part is
   included in the Content-MD5 digest as is -- i.e., after the
   application. The Transfer-Encoding header field is not allowed within
   body-parts.

   Conversion of all line breaks to CRLF MUST NOT be done before
   computing or checking the digest: the line break convention used in
   the text actually transmitted MUST be left unaltered when computing
   the digest. 

      Note: while the definition of Content-MD5 is exactly the same for
      HTTP as in &lt;a href=&quot;https://tools.ietf.org/html/rfc1864&quot;&gt;RFC 1864&lt;/a&gt; for MIME entity-bodies, there are several ways
      in which the application of Content-MD5 to HTTP entity-bodies
      differs from its application to MIME entity-bodies. One is that
      HTTP, unlike MIME, does not use Content-Transfer-Encoding, and
      does use Transfer-Encoding and Content-Encoding. Another is that
      HTTP more frequently uses binary content types than MIME, so it is
      worth noting that, in such cases, the byte order used to compute
      the digest is the transmission byte order defined for the type.
      Lastly, HTTP allows transmission of text types with any of several
      line break conventions and not just the canonical form using CRLF.</source>
          <target state="translated">&lt;a href=&quot;https://tools.ietf.org/html/rfc1864&quot;&gt;RFC 1864&lt;/a&gt; [ &lt;a href=&quot;#ref-23&quot;&gt;23&lt;/a&gt; ]中定义的Content-MD5实体报头字段是实体主体的MD5摘要，目的是提供实体主体的端到端消息完整性检查（MIC）。（注意：MIC可以很好地检测出运输过程中实体的意外修改，但不能证明没有遭到恶意攻击。）Content-MD5 =&amp;ldquo; Content-MD5&amp;rdquo;&amp;ldquo;：&amp;rdquo; md5-digest md5-digest = &amp;lt;base64 of根据&lt;a href=&quot;https://tools.ietf.org/html/rfc1864&quot;&gt;RFC 1864的&lt;/a&gt; 128位MD5摘要&amp;gt; Content-MD5标头字段可以由源服务器或客户端生成，以用作实体主体的完整性检查。只有原始服务器或客户端可以生成Content-MD5标头字段；代理和网关绝不能生成它，因为这会破坏其作为端到端完整性检查的价值。实体主体的任何接收者，包括网关和代理，都可以检查该头字段中的摘要值是否与接收到的实体主体的摘要值匹配。基于实体主体的内容（包括已应用的任何内容编码，但不包括应用于消息主体的任何传输编码）来计算MD5摘要。如果接收到的消息带有传输编码，则必须在根据接收到的实体检查Content-MD5值之前删除该编码。这样的结果是，摘要在实体主体的八位位组上的计算完全相同，并且如果不应用传输编码，则将按顺序发送。 HTTP扩展&lt;a href=&quot;https://tools.ietf.org/html/rfc1864&quot;&gt;RFC 1864&lt;/a&gt;允许针对MIME复合媒体类型（例如multipart / *和message / rfc822）计算摘要，但这不会更改上段中定义的摘要的计算方式。这有几个后果。复合类型的实体主体可以包含许多主体部分，每个主体部分都有自己的MIME和HTTP标头（包括Content-MD5，Content-Transfer-Encoding和Content-Encoding标头）。如果主体部分具有Content-Transfer-Encoding或Content-Encoding标头，则假定主体部分的内容已应用编码，并且主体部分按原样包含在Content-MD5摘要中-即申请后。身体部位不允许使用Transfer-Encoding标头字段。在计算或检查摘要之前，绝不能将所有换行符转换为CRLF：在实际中传输摘要时，在文本中实际使用的换行惯例必须保持不变。注意：虽然Content-MD5的HTTP定义与&lt;a href=&quot;https://tools.ietf.org/html/rfc1864&quot;&gt;&lt;/a&gt;针对MIME实体的RFC 1864，Content-MD5在HTTP实体上的应用与在MIME实体上的应用有几种不同的方式。一个是HTTP与MIME不同，它不使用Content-Transfer-Encoding，而是使用Transfer-Encoding和Content-Encoding。另一个是HTTP比MIME更频繁地使用二进制内容类型，因此值得注意的是，在这种情况下，用于计算摘要的字节顺序是为该类型定义的传输字节顺序。最后，HTTP允许使用几种换行约定中的任何一种来传输文本类型，而不仅仅是使用CRLF的规范形式。</target>
        </trans-unit>
        <trans-unit id="ff07970e216340fa2fb8373a79c1c42c82bcf1ba" translate="yes" xml:space="preserve">
          <source>The Content-Range entity-header is sent with a partial entity-body to
   specify where in the full entity-body the partial body should be
   applied. Range units are defined in &lt;a href=&quot;#section-3.12&quot;&gt;section 3.12&lt;/a&gt;.

       Content-Range = &quot;Content-Range&quot; &quot;:&quot; content-range-spec

       content-range-spec      = byte-content-range-spec
       byte-content-range-spec = bytes-unit SP
                                 byte-range-resp-spec &quot;/&quot;
                                 ( instance-length | &quot;*&quot; )

       byte-range-resp-spec = (first-byte-pos &quot;-&quot; last-byte-pos)
                                      | &quot;*&quot;
       instance-length           = 1*DIGIT

   The header SHOULD indicate the total length of the full entity-body,
   unless this length is unknown or difficult to determine. The asterisk
   &quot;*&quot; character means that the instance-length is unknown at the time
   when the response was generated.

   Unlike byte-ranges-specifier values (see &lt;a href=&quot;#section-14.35.1&quot;&gt;section 14.35.1&lt;/a&gt;), a byte-
   range-resp-spec MUST only specify one range, and MUST contain
   absolute byte positions for both the first and last byte of the
   range.

   A byte-content-range-spec with a byte-range-resp-spec whose last-
   byte-pos value is less than its first-byte-pos value, or whose
   instance-length value is less than or equal to its last-byte-pos
   value, is invalid. The recipient of an invalid byte-content-range-
   spec MUST ignore it and any content transferred along with it.

   A server sending a response with status code 416 (Requested range not
   satisfiable) SHOULD include a Content-Range field with a byte-range-
   resp-spec of &quot;*&quot;. The instance-length specifies the current length of 

   the selected resource. A response with status code 206 (Partial
   Content) MUST NOT include a Content-Range field with a byte-range-
   resp-spec of &quot;*&quot;.

   Examples of byte-content-range-spec values, assuming that the entity
   contains a total of 1234 bytes:

      . The first 500 bytes:
       bytes 0-499/1234

      . The second 500 bytes:
       bytes 500-999/1234

      . All except for the first 500 bytes:
       bytes 500-1233/1234

      . The last 500 bytes:
       bytes 734-1233/1234

   When an HTTP message includes the content of a single range (for
   example, a response to a request for a single range, or to a request
   for a set of ranges that overlap without any holes), this content is
   transmitted with a Content-Range header, and a Content-Length header
   showing the number of bytes actually transferred. For example,

       HTTP/1.1 206 Partial content
       Date: Wed, 15 Nov 1995 06:25:24 GMT
       Last-Modified: Wed, 15 Nov 1995 04:58:08 GMT
       Content-Range: bytes 21010-47021/47022
       Content-Length: 26012
       Content-Type: image/gif

   When an HTTP message includes the content of multiple ranges (for
   example, a response to a request for multiple non-overlapping
   ranges), these are transmitted as a multipart message. The multipart
   media type used for this purpose is &quot;multipart/byteranges&quot; as defined
   in appendix 19.2. See appendix 19.6.3 for a compatibility issue.

   A response to a request for a single range MUST NOT be sent using the
   multipart/byteranges media type.  A response to a request for
   multiple ranges, whose result is a single range, MAY be sent as a
   multipart/byteranges media type with one part. A client that cannot
   decode a multipart/byteranges message MUST NOT ask for multiple
   byte-ranges in a single request.

   When a client requests multiple byte-ranges in one request, the
   server SHOULD return them in the order that they appeared in the
   request. 

   If the server ignores a byte-range-spec because it is syntactically
   invalid, the server SHOULD treat the request as if the invalid Range
   header field did not exist. (Normally, this means return a 200
   response containing the full entity).

   If the server receives a request (other than one including an If-
   Range request-header field) with an unsatisfiable Range request-
   header field (that is, all of whose byte-range-spec values have a
   first-byte-pos value greater than the current length of the selected
   resource), it SHOULD return a response code of 416 (Requested range
   not satisfiable) (&lt;a href=&quot;#section-10.4.17&quot;&gt;section 10.4.17&lt;/a&gt;).

      Note: clients cannot depend on servers to send a 416 (Requested
      range not satisfiable) response instead of a 200 (OK) response for
      an unsatisfiable Range request-header, since not all servers
      implement this request-header.</source>
          <target state="translated">Content-Range实体标头与部分实体主体一起发送，以指定应在整个实体主体中的何处应用部分主体。范围单位在&lt;a href=&quot;#section-3.12&quot;&gt;第3.12节&lt;/a&gt;中定义。 Content-Range =&amp;ldquo; Content-Range&amp;rdquo;&amp;ldquo;：&amp;rdquo;&amp;ldquo;内容范围规范content-range-spec =字节内容范围规范byte-content-range-spec =字节单位SP byte-range-resp-spec&amp;rdquo; /&amp;ldquo;（instance-length |&amp;rdquo; *&amp;ldquo;）byte-range-resp-spec =（第一个字节pos&amp;rdquo;-&amp;ldquo;最后一个字节pos）| &amp;ldquo; *&amp;rdquo; instance-length = 1 * DIGIT标头应指示整个实体的总长度，除非该长度未知或难以确定。星号&amp;ldquo; *&amp;rdquo;表示在生成响应时实例长度未知。与字节范围指定符值不同（请参见&lt;a href=&quot;#section-14.35.1&quot;&gt;第14.35.1节）&lt;/a&gt;），字节范围-resp-spec必须仅指定一个范围，并且必须包含该范围的第一个和最后一个字节的绝对字节位置。字节范围-resp-spec的字节内容范围规范，其最后一个字节pos值小于其第一个字节pos值，或者其实例长度值小于或等于其最后一个byte-pos值byte-pos值，无效。无效字节内容范围规范的接收者必须忽略它以及与之一起传输的任何内容。发送状态代码为416（请求范围不能满足）的响应的服务器应该包括一个Content-Range字段，其字节范围响应规范为&amp;ldquo; *&amp;rdquo;。 instance-length指定所选资源的当前长度。状态码为206（部分内容）的响应不得包含&amp;ldquo;字节数范围说明&amp;rdquo;为&amp;ldquo; *&amp;rdquo;的&amp;ldquo;内容范围&amp;rdquo;字段。假设实体总共包含1234个字节，则为byte-content-range-spec值的示例：前500个字节：字节0-499 / 1234。后500个字节：字节500-999 / 1234。除前500个字节外，全部：字节500-1233 / 1234。最后500个字节：字节734-1233 / 1234当HTTP消息包含单个范围的内容时（例如，对单个范围的请求的响应或对一组重叠但没有任何漏洞的请求的响应） ），则使用Content-Range标头和显示实际传输的字节数的Content-Length标头发送此内容。例如，HTTP / 1。1206部分内容日期：1995年11月15日星期三06:25:24 GMT上次修改时间：1995年11月15日星期三04:58:08 GMT内容范围：字节21010-47021 / 47022内容长度：26012内容类型：image / gif当HTTP消息包含多个范围的内容（例如，对多个非重叠范​​围的请求的响应）时，这些内容将作为多部分消息进行传输。如附录19.2所定义，用于此目的的multipart媒体类型是&amp;ldquo; multipart / byteranges&amp;rdquo;。有关兼容性问题，请参见附录19.6.3。不得使用multipart / byteranges媒体类型发送对单个范围的请求的响应。对多个范围（其结果是单个范围）的请求的响应，可以作为多部分/字节范围媒体类型（包含一部分）发送。不能解码multipart / byteranges消息的客户端不得在单个请求中要求多个字节范围。当客户端在一个请求中请求多个字节范围时，服务器应按它们在请求中出现的顺序返回它们。如果服务器由于语法无效而忽略了字节范围规范，则服务器应将请求视为无效的Range标头字段不存在。 （通常，这意味着返回包含完整实体的200响应）。如果服务器接收到一个请求（除了包含If-Range请求头域的请求），但请求的头域不满足要求（即所有字节范围指定值的first-byte-pos值都更大）比所选资源的当前长度），它应返回响应代码416（请求的范围无法满足）（&lt;a href=&quot;#section-10.4.17&quot;&gt;10.4.17节&lt;/a&gt;）。注意：对于不满意的Range请求标头，客户端不能依赖服务器发送416（请求范围无法满足）响应而不是200（OK）响应，因为并非所有服务器都实现此请求标头。</target>
        </trans-unit>
        <trans-unit id="e283ef83ad0c98c2f0776bde603c318284d66f81" translate="yes" xml:space="preserve">
          <source>The Content-Type entity-header field indicates the media type of the
   entity-body sent to the recipient or, in the case of the HEAD method,
   the media type that would have been sent had the request been a GET.

       Content-Type   = &quot;Content-Type&quot; &quot;:&quot; media-type

   Media types are defined in &lt;a href=&quot;#section-3.7&quot;&gt;section 3.7&lt;/a&gt;. An example of the field is

       Content-Type: text/html; charset=ISO-8859-4

   Further discussion of methods for identifying the media type of an
   entity is provided in &lt;a href=&quot;#section-7.2.1&quot;&gt;section 7.2.1&lt;/a&gt;.</source>
          <target state="translated">Content-Type实体标头字段指示发送给接收者的实体主体的媒体类型，或者在HEAD方法的情况下，指示如果请求是GET则应发送的媒体类型。 Content-Type =&amp;ldquo; Content-Type&amp;rdquo;&amp;ldquo;：&amp;rdquo;媒体类型媒体类型在&lt;a href=&quot;#section-3.7&quot;&gt;3.7节&lt;/a&gt;中定义。该字段的一个示例是Content-Type：text / html; charset = ISO-8859-4在&lt;a href=&quot;#section-7.2.1&quot;&gt;7.2.1节中&lt;/a&gt;提供了有关标识实体媒体类型的方法的进一步讨论。</target>
        </trans-unit>
        <trans-unit id="d09adc4e47017807bd60018491b4e8efd7bba713" translate="yes" xml:space="preserve">
          <source>The Cookie header field [&lt;a href=&quot;#ref-COOKIE&quot;&gt;COOKIE&lt;/a&gt;] uses a semi-colon (&quot;;&quot;) to delimit
   cookie-pairs (or &quot;crumbs&quot;).  This header field doesn't follow the
   list construction rules in HTTP (see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.2&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.2&lt;/a&gt;), which
   prevents cookie-pairs from being separated into different name-value
   pairs.  This can significantly reduce compression efficiency as
   individual cookie-pairs are updated.

   To allow for better compression efficiency, the Cookie header field
   MAY be split into separate header fields, each with one or more
   cookie-pairs.  If there are multiple Cookie header fields after
   decompression, these MUST be concatenated into a single octet string
   using the two-octet delimiter of 0x3B, 0x20 (the ASCII string &quot;; &quot;)
   before being passed into a non-HTTP/2 context, such as an HTTP/1.1
   connection, or a generic HTTP server application.

   Therefore, the following two lists of Cookie header fields are
   semantically equivalent.

     cookie: a=b; c=d; e=f

     cookie: a=b
     cookie: c=d
     cookie: e=f</source>
          <target state="translated">Cookie标头字段[ &lt;a href=&quot;#ref-COOKIE&quot;&gt;COOKIE&lt;/a&gt; ]使用分号（&amp;ldquo;;&amp;rdquo;）来分隔cookie对（或&amp;ldquo;小块&amp;rdquo;）。此标头字段不遵循HTTP中的列表构造规则（请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.2&quot;&gt;[RFC7230]，第3.2.2节&lt;/a&gt;），以防止将Cookie对分离为不同的名称/值对。随着各个Cookie对的更新，这可能会大大降低压缩效率。为了获得更好的压缩效率，Cookie头字段可以分成单独的头字段，每个头字段具有一个或多个cookie对。如果解压缩后有多个Cookie标头字段，则必须在将它们传递到非HTTP / 2上下文之前，使用0x3B，0x20（ASCII字符串&amp;ldquo;;&amp;rdquo;）的两个八位字节定界符将它们串联为单个八位字节字符串。作为HTTP / 1.1连接或通用HTTP服务器应用程序。因此，以下两个Cookie头字段列表在语义上是等效的。 Cookie：a = b; c = d; e = f cookie：a = b cookie：c = d cookie：e = f</target>
        </trans-unit>
        <trans-unit id="037f56850e2d9507141cb0bfad334028f9b60f2f" translate="yes" xml:space="preserve">
          <source>The Cross-Origin Resource Sharing standard works by adding new &lt;a href=&quot;headers&quot;&gt;HTTP headers&lt;/a&gt; that allow servers to describe the set of origins that are permitted to read that information using a web browser. Additionally, for HTTP request methods that can cause side-effects on server's data (in particular, for HTTP methods other than &lt;a href=&quot;methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt;, or for &lt;a href=&quot;methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; usage with certain &lt;a href=&quot;basics_of_http/mime_types&quot;&gt;MIME types&lt;/a&gt;), the specification mandates that browsers &quot;preflight&quot; the request, soliciting supported methods from the server with an HTTP &lt;a href=&quot;methods/options&quot;&gt;&lt;code&gt;OPTIONS&lt;/code&gt;&lt;/a&gt; request method, and then, upon &quot;approval&quot; from the server, sending the actual request with the actual HTTP request method. Servers can also notify clients whether &quot;credentials&quot; (including &lt;a href=&quot;cookies&quot;&gt;Cookies&lt;/a&gt; and HTTP Authentication data) should be sent with requests.</source>
          <target state="translated">跨域资源共享标准通过添加新的&lt;a href=&quot;headers&quot;&gt;HTTP标头来工作&lt;/a&gt;，这些标头允许服务器描述允许使用Web浏览器读取该信息的一组来源。此外，对于可能导致服务器数据产生副作用的HTTP请求方法（特别是对于&lt;a href=&quot;methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;以外的HTTP方法或某些&lt;a href=&quot;basics_of_http/mime_types&quot;&gt;MIME类型的&lt;/a&gt;&lt;a href=&quot;methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt;使用），该规范要求浏览器&amp;ldquo;预检&amp;rdquo;请求，并请求支持的方法从服务器使用HTTP &lt;a href=&quot;methods/options&quot;&gt; &lt;code&gt;OPTIONS&lt;/code&gt; &lt;/a&gt;请求方法，然后在服务器&amp;ldquo;批准&amp;rdquo;后，使用实际的HTTP请求方法发送实际的请求。服务器还可以通知客户端&amp;ldquo;凭据&amp;rdquo;（包括&lt;a href=&quot;cookies&quot;&gt;Cookie&lt;/a&gt;和HTTP身份验证数据）应与请求一起发送。</target>
        </trans-unit>
        <trans-unit id="a3df3b7b4551cce965a08ca5b788db7477ac35eb" translate="yes" xml:space="preserve">
          <source>The Cross-Origin Resource Sharing standard works by adding new &lt;a href=&quot;headers&quot;&gt;HTTP headers&lt;/a&gt; that let servers describe which origins are permitted to read that information from a web browser. Additionally, for HTTP request methods that can cause side-effects on server data (in particular, HTTP methods other than &lt;a href=&quot;methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; with certain &lt;a href=&quot;basics_of_http/mime_types&quot;&gt;MIME types&lt;/a&gt;), the specification mandates that browsers &quot;preflight&quot; the request, soliciting supported methods from the server with the HTTP &lt;a href=&quot;methods/options&quot;&gt;&lt;code&gt;OPTIONS&lt;/code&gt;&lt;/a&gt; request method, and then, upon &quot;approval&quot; from the server, sending the actual request. Servers can also inform clients whether &quot;credentials&quot; (such as &lt;a href=&quot;cookies&quot;&gt;Cookies&lt;/a&gt; and &lt;a href=&quot;authentication&quot;&gt;HTTP Authentication&lt;/a&gt;) should be sent with requests.</source>
          <target state="translated">跨域资源共享标准通过添加新的&lt;a href=&quot;headers&quot;&gt;HTTP标头来工作&lt;/a&gt;，这些标头允许服务器描述允许哪些来源从Web浏览器读取该信息。此外，对于可能对服务器数据产生副作用的HTTP请求方法（尤其是&lt;a href=&quot;methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;或具有某些&lt;a href=&quot;basics_of_http/mime_types&quot;&gt;MIME类型的&lt;/a&gt;&lt;a href=&quot;methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt;以外的HTTP方法），该规范要求浏览器&amp;ldquo;预检&amp;rdquo;请求，并从服务器请求受支持的方法。使用HTTP &lt;a href=&quot;methods/options&quot;&gt; &lt;code&gt;OPTIONS&lt;/code&gt; &lt;/a&gt;请求方法，然后在服务器&amp;ldquo;批准&amp;rdquo;后发送实际请求。服务器还可以通知客户端是否有&amp;ldquo;凭据&amp;rdquo;（例如&lt;a href=&quot;cookies&quot;&gt;Cookies&lt;/a&gt;和&lt;a href=&quot;authentication&quot;&gt;HTTP身份验证）&lt;/a&gt;）应随请求一起发送。</target>
        </trans-unit>
        <trans-unit id="858dfd56015c8a42c014f2e88a9adef69bbf8f6d" translate="yes" xml:space="preserve">
          <source>The DELETE method on a collection MUST act as if a &quot;Depth: infinity&quot;
   header was used on it.  A client MUST NOT submit a Depth header with
   a DELETE on a collection with any value but infinity.

   DELETE instructs that the collection specified in the Request-URI and
   all resources identified by its internal member URLs are to be
   deleted.

   If any resource identified by a member URL cannot be deleted, then
   all of the member's ancestors MUST NOT be deleted, so as to maintain
   URL namespace consistency.

   Any headers included with DELETE MUST be applied in processing every
   resource to be deleted.

   When the DELETE method has completed processing, it MUST result in a
   consistent URL namespace.

   If an error occurs deleting a member resource (a resource other than
   the resource identified in the Request-URI), then the response can be
   a 207 (Multi-Status).  Multi-Status is used here to indicate which
   internal resources could NOT be deleted, including an error code,
   which should help the client understand which resources caused the
   failure.  For example, the Multi-Status body could include a response
   with status 423 (Locked) if an internal resource was locked.

   The server MAY return a 4xx status response, rather than a 207, if
   the request failed completely.

   424 (Failed Dependency) status codes SHOULD NOT be in the 207 (Multi-
   Status) response for DELETE.  They can be safely left out because the
   client will know that the ancestors of a resource could not be
   deleted when the client receives an error for the ancestor's progeny.
   Additionally, 204 (No Content) errors SHOULD NOT be returned in the
   207 (Multi-Status).  The reason for this prohibition is that 204 (No
   Content) is the default success code.</source>
          <target state="translated">集合上的DELETE方法必须像使用了 &quot;Depth:infinity &quot;头一样。客户端决不能在一个集合上提交带有DELETE的Depth头,该集合的值只有infinity。DELETE指示将删除Request-URI中指定的集合以及由其内部成员URL标识的所有资源。如果不能删除成员URL所标识的任何资源,那么该成员的所有祖先必须不被删除,以保持URL命名空间的一致性。在处理每个要删除的资源时,必须应用DELETE包含的任何头信息。当DELETE方法完成处理后,它必须产生一个一致的URL命名空间。如果在删除一个成员资源(Request-URI中标识的资源以外的资源)时发生错误,那么响应可以是207(Multi-Status)。这里使用Multi-Status来指示哪些内部资源不能被删除,包括错误代码,这应该有助于客户机了解是哪些资源导致了失败。例如,如果一个内部资源被锁定,Multi-Status主体可以包含一个状态423(Locked)的响应。如果请求完全失败,服务器可以返回4xx状态响应,而不是207。424(Failed Dependency)状态码不应该出现在DELETE的207(Multi-Status)响应中。它们可以安全地被排除在外,因为当客户端收到祖先的后代的错误时,客户端将知道资源的祖先不能被删除。此外,204(无内容)错误不应该在207(多状态)中返回。之所以这样禁止,是因为204(无内容)是默认的成功代码。</target>
        </trans-unit>
        <trans-unit id="e71c2610a983fa8562e2bcbd279e311806bf6084" translate="yes" xml:space="preserve">
          <source>The DELETE method requests that the origin server delete the resource
   identified by the Request-URI. This method MAY be overridden by human
   intervention (or other means) on the origin server. The client cannot
   be guaranteed that the operation has been carried out, even if the
   status code returned from the origin server indicates that the action
   has been completed successfully. However, the server SHOULD NOT
   indicate success unless, at the time the response is given, it
   intends to delete the resource or move it to an inaccessible
   location.

   A successful response SHOULD be 200 (OK) if the response includes an
   entity describing the status, 202 (Accepted) if the action has not
   yet been enacted, or 204 (No Content) if the action has been enacted
   but the response does not include an entity.

   If the request passes through a cache and the Request-URI identifies
   one or more currently cached entities, those entries SHOULD be
   treated as stale. Responses to this method are not cacheable.</source>
          <target state="translated">DELETE方法要求源服务器删除由Request-URI标识的资源。这个方法可以被源服务器上的人为干预(或其他手段)所覆盖。即使源服务器返回的状态码表明操作已经成功完成,客户端也不能保证操作已经完成。但是,服务器不应表示成功,除非在给出响应时,它打算删除资源或将其移动到一个不可访问的位置。如果响应包括描述状态的实体,则成功的响应应该是200(OK);如果操作尚未执行,则应该是202(Accepted);如果操作已经执行但响应不包括实体,则应该是204(No Content)。如果请求通过缓存,并且 Request-URI 识别了一个或多个当前缓存的实体,则这些条目应被视为陈旧。此方法的响应是不可缓存的。</target>
        </trans-unit>
        <trans-unit id="c974be9fc532fcdd84db91fdeb0ba6b9b0cfa15b" translate="yes" xml:space="preserve">
          <source>The DELETE method requests that the origin server remove the
   association between the target resource and its current
   functionality.  In effect, this method is similar to the rm command
   in UNIX: it expresses a deletion operation on the URI mapping of the
   origin server rather than an expectation that the previously
   associated information be deleted.

   If the target resource has one or more current representations, they
   might or might not be destroyed by the origin server, and the
   associated storage might or might not be reclaimed, depending
   entirely on the nature of the resource and its implementation by the
   origin server (which are beyond the scope of this specification).
   Likewise, other implementation aspects of a resource might need to be
   deactivated or archived as a result of a DELETE, such as database or
   gateway connections.  In general, it is assumed that the origin
   server will only allow DELETE on resources for which it has a
   prescribed mechanism for accomplishing the deletion.

   Relatively few resources allow the DELETE method -- its primary use
   is for remote authoring environments, where the user has some
   direction regarding its effect.  For example, a resource that was
   previously created using a PUT request, or identified via the
   Location header field after a 201 (Created) response to a POST
   request, might allow a corresponding DELETE request to undo those
   actions.  Similarly, custom user agent implementations that implement 

   an authoring function, such as revision control clients using HTTP
   for remote operations, might use DELETE based on an assumption that
   the server's URI space has been crafted to correspond to a version
   repository.

   If a DELETE method is successfully applied, the origin server SHOULD
   send a 202 (Accepted) status code if the action will likely succeed
   but has not yet been enacted, a 204 (No Content) status code if the
   action has been enacted and no further information is to be supplied,
   or a 200 (OK) status code if the action has been enacted and the
   response message includes a representation describing the status.

   A payload within a DELETE request message has no defined semantics;
   sending a payload body on a DELETE request might cause some existing
   implementations to reject the request.

   Responses to the DELETE method are not cacheable.  If a DELETE
   request passes through a cache that has one or more stored responses
   for the effective request URI, those stored responses will be
   invalidated (see &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.4&quot;&gt;Section&amp;nbsp;4.4 of [RFC7234]&lt;/a&gt;).</source>
          <target state="translated">DELETE方法请求原始服务器删除目标资源与其当前功能之间的关联。实际上，此方法类似于UNIX中的rm命令：它在源服务器的URI映射上表示删除操作，而不是期望删除先前关联的信息。如果目标资源具有一个或多个当前表示，则它们可能会或可能不会被原始服务器销毁，并且相关的存储可能会或可能不会被回收，这完全取决于资源的性质及其由原始服务器的实现（超出了本规范的范围）。同样，由于DELETE，可能需要停用或归档资源的其他实现方面，例如数据库或网关连接。通常，假定原始服务器仅对具有预定机制以完成删除的资源允许DELETE。相对而言，很少有资源允许使用DELETE方法-它的主要用途是用于远程创作环境，在该环境中，用户对其效果有所了解。例如，先前使用PUT请求创建的资源，或在对POST请求进行201（已创建）响应后通过位置标头字段标识的资源，可能允许相应的DELETE请求撤消那些操作。同样，实现创作功能的自定义用户代理实现（例如使用HTTP进行远程操作的版本控制客户端）可能会基于服务器的假设使用DELETEURI空间经过精心设计，以与版本库相对应。如果成功应用了DELETE方法，则源服务器应在操作可能成功但尚未执行之前发送202（接受）状态代码，如果操作已经执行且不再进行进一步操作，则发送204（无内容）状态代码。要提供信息，或者如果已执行操作且响应消息包括描述状态的表示，则提供200（确定）状态码。 DELETE请求消息中的有效负载没有定义的语义；在DELETE请求上发送有效内容正文可能会导致某些现有实现拒绝该请求。对DELETE方法的响应不可缓存。如果DELETE请求通过一个缓存，该缓存具有一个或多个存储的有效请求URI的响应，这些存储的响应将无效（请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.4&quot;&gt;[RFC7234]的4.4节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="dd290a0d44bd1aedc43b87181e19c3e8fd871af9" translate="yes" xml:space="preserve">
          <source>The Date general-header field represents the date and time at which
   the message was originated, having the same semantics as orig-date in
   &lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt;. The field value is an HTTP-date, as described in &lt;a href=&quot;#section-3.3.1&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-3.3.1&quot;&gt;3.3.1&lt;/a&gt;; it MUST be sent in &lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;RFC 1123&lt;/a&gt; [&lt;a href=&quot;#ref-8&quot;&gt;8&lt;/a&gt;]-date format.

       Date  = &quot;Date&quot; &quot;:&quot; HTTP-date

   An example is

       Date: Tue, 15 Nov 1994 08:12:31 GMT

   Origin servers MUST include a Date header field in all responses,
   except in these cases: 

      1. If the response status code is 100 (Continue) or 101 (Switching
         Protocols), the response MAY include a Date header field, at
         the server's option.

      2. If the response status code conveys a server error, e.g. 500
         (Internal Server Error) or 503 (Service Unavailable), and it is
         inconvenient or impossible to generate a valid Date.

      3. If the server does not have a clock that can provide a
         reasonable approximation of the current time, its responses
         MUST NOT include a Date header field. In this case, the rules
         in &lt;a href=&quot;#section-14.18.1&quot;&gt;section 14.18.1&lt;/a&gt; MUST be followed.

   A received message that does not have a Date header field MUST be
   assigned one by the recipient if the message will be cached by that
   recipient or gatewayed via a protocol which requires a Date. An HTTP
   implementation without a clock MUST NOT cache responses without
   revalidating them on every use. An HTTP cache, especially a shared
   cache, SHOULD use a mechanism, such as NTP [&lt;a href=&quot;#ref-28&quot;&gt;28&lt;/a&gt;], to synchronize its
   clock with a reliable external standard.

   Clients SHOULD only send a Date header field in messages that include
   an entity-body, as in the case of the PUT and POST requests, and even
   then it is optional. A client without a clock MUST NOT send a Date
   header field in a request.

   The HTTP-date sent in a Date header SHOULD NOT represent a date and
   time subsequent to the generation of the message. It SHOULD represent
   the best available approximation of the date and time of message
   generation, unless the implementation has no means of generating a
   reasonably accurate date and time. In theory, the date ought to
   represent the moment just before the entity is generated. In
   practice, the date can be generated at any time during the message
   origination without affecting its semantic value.</source>
          <target state="translated">&amp;ldquo;日期&amp;rdquo;一般标题字段表示消息发出的日期和时间，其语义与&lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822中的&lt;/a&gt; orig-date相同 。字段值是HTTP日期，如&lt;a href=&quot;#section-3.3.1&quot;&gt;第&lt;/a&gt;&lt;a href=&quot;#section-3.3.1&quot;&gt;3.3.1 &lt;/a&gt;节所述；必须在&lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;RFC 1123&lt;/a&gt; [ &lt;a href=&quot;#ref-8&quot;&gt;8中&lt;/a&gt;发送]-日期格式。 Date =&amp;ldquo; Date&amp;rdquo;&amp;ldquo;：&amp;rdquo; HTTP-date例如：Date：Tue，15 Nov 1994 08:12:31 GMT原始服务器必须在所有响应中包括Date标头字段，以下情况除外：1.如果响应状态如果代码是100（继续）或101（交换协议），则响应可以包括Date头字段，由服务器选择。 2.如果响应状态代码传达服务器错误，例如500（内部服务器错误）或503（服务不可用），则不方便或无法生成有效的日期。 3.如果服务器没有可以提供当前时间的合理近似值的时钟，则其响应必须不包括Date标头字段。在这种情况下，&lt;a href=&quot;#section-14.18.1&quot;&gt;14.18.1节中的规则&lt;/a&gt;必须遵循。如果消息将由该收件人缓存或通过需要日期的协议进行网关传送，则接收方必须为接收到的没有日期标题字段的消息分配一个消息。没有时钟的HTTP实现绝不能缓存响应，而不必在每次使用时都重新验证它们。 HTTP缓存，尤其是共享缓存，应使用NTP等机制[ &lt;a href=&quot;#ref-28&quot;&gt;28&lt;/a&gt;]，以使其时钟与可靠的外部标准同步。客户端应该只在包含实体主体的消息中发送Date头字段，例如在PUT和POST请求的情况下，即使这样它也是可选的。没有时钟的客户端不得在请求中发送Date标头字段。在Date标头中发送的HTTP-date不应代表消息生成后的日期和时间。它应该代表消息生成日期和时间的最佳可用近似值，除非实现没有办法生成合理准确的日期和时间。从理论上讲，日期应代表实体生成之前的时刻。实际上，可以在消息发起期间的任何时间生成日期，而不会影响其语义值。</target>
        </trans-unit>
        <trans-unit id="6903ec22652fb8e7c29947078193d2ba673e0d45" translate="yes" xml:space="preserve">
          <source>The Depth header may be used with the LOCK method.  Values other than
   0 or infinity MUST NOT be used with the Depth header on a LOCK
   method.  All resources that support the LOCK method MUST support the
   Depth header.

   A Depth header of value 0 means to just lock the resource specified
   by the Request-URI.

   If the Depth header is set to infinity, then the resource specified
   in the Request-URI along with all its members, all the way down the
   hierarchy, are to be locked.  A successful result MUST return a
   single lock token.  Similarly, if an UNLOCK is successfully executed
   on this token, all associated resources are unlocked.  Hence, partial
   success is not an option for LOCK or UNLOCK.  Either the entire
   hierarchy is locked or no resources are locked.

   If the lock cannot be granted to all resources, the server MUST
   return a Multi-Status response with a 'response' element for at least
   one resource that prevented the lock from being granted, along with a
   suitable status code for that failure (e.g., 403 (Forbidden) or 423
   (Locked)).  Additionally, if the resource causing the failure was not
   the resource requested, then the server SHOULD include a 'response'
   element for the Request-URI as well, with a 'status' element
   containing 424 Failed Dependency.

   If no Depth header is submitted on a LOCK request, then the request
   MUST act as if a &quot;Depth:infinity&quot; had been submitted.</source>
          <target state="translated">深度头可以和LOCK方法一起使用。LOCK 方法的深度标头不得使用 0 或无穷大以外的值。所有支持 LOCK 方法的资源都必须支持深度头。值为0的深度头意味着只锁定Request-URI指定的资源。如果深度头被设置为无穷大,那么Request-URI中指定的资源及其所有成员,一直到层次结构,都将被锁定。一个成功的结果必须返回一个单一的锁定令牌。同样,如果在这个标记上成功执行了UNLOCK,所有相关的资源都会被解锁。因此,部分成功不是LOCK或UNLOCK的选项。要么整个层次结构被锁定,要么没有资源被锁定。如果不能向所有资源授予锁,服务器必须返回一个多状态响应,其中包含至少一个阻止授予锁的资源的 &quot;响应 &quot;元素,以及该失败的适当状态代码(例如,403(禁止)或423(锁定))。此外,如果导致失败的资源不是被请求的资源,那么服务器也应该为Request-URI包含一个 &quot;响应 &quot;元素,并包含一个包含424 Failed Dependency的 &quot;状态 &quot;元素。如果在LOCK请求上没有提交Depth头,那么该请求必须像提交了 &quot;Depth:infinity &quot;一样。</target>
        </trans-unit>
        <trans-unit id="35342d84dcd43dba8096f5d5b39874e99cb4604b" translate="yes" xml:space="preserve">
          <source>The Destination request header specifies the URI that identifies a
   destination resource for methods such as COPY and MOVE, which take
   two URIs as parameters.

      Destination = &quot;Destination&quot; &quot;:&quot; Simple-ref


   If the Destination value is an absolute-URI (&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-4.3&quot;&gt;Section&amp;nbsp;4.3 of
   [RFC3986]&lt;/a&gt;), it may name a different server (or different port or
   scheme).  If the source server cannot attempt a copy to the remote
   server, it MUST fail the request.  Note that copying and moving
   resources to remote servers is not fully defined in this
   specification (e.g., specific error conditions). 

   If the Destination value is too long or otherwise unacceptable, the
   server SHOULD return 400 (Bad Request), ideally with helpful
   information in an error body.</source>
          <target state="translated">Destination请求标头指定URI，该URI标识诸如COPY和MOVE之类的方法的目标资源，这些方法将两个URI作为参数。 Destination =&amp;ldquo; Destination&amp;rdquo;&amp;ldquo; ::&amp;rdquo;简单引用如果Destination值为绝对URI（&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-4.3&quot;&gt;[RFC3986]的4.3节&lt;/a&gt;），则它可以命名其他服务器（或其他端口或方案）。如果源服务器无法尝试复制到远程服务器，则它必须使请求失败。请注意，在本规范中并未完全定义将资源复制和移动到远程服务器（例如，特定的错误条件）。如果目标值太长或不可接受，则服务器应返回400（错误请求），最好在错误正文中包含有用的信息。</target>
        </trans-unit>
        <trans-unit id="5ec562967c3ab4eb672c7b7fd0765b0c9a09d6b8" translate="yes" xml:space="preserve">
          <source>The ETag response-header field provides the current value of the
   entity tag for the requested variant. The headers used with entity
   tags are described in sections &lt;a href=&quot;#section-14.24&quot;&gt;14.24&lt;/a&gt;, &lt;a href=&quot;#section-14.26&quot;&gt;14.26&lt;/a&gt; and &lt;a href=&quot;#section-14.44&quot;&gt;14.44&lt;/a&gt;. The entity tag
   MAY be used for comparison with other entities from the same resource
   (see &lt;a href=&quot;#section-13.3.3&quot;&gt;section 13.3.3&lt;/a&gt;).

      ETag = &quot;ETag&quot; &quot;:&quot; entity-tag

   Examples:

      ETag: &quot;xyzzy&quot;
      ETag: W/&quot;xyzzy&quot;
      ETag: &quot;&quot;</source>
          <target state="translated">ETag响应标头字段提供所请求变体的实体标签的当前值。与实体标签使用的头中各节中描述&lt;a href=&quot;#section-14.24&quot;&gt;14.24&lt;/a&gt;，&lt;a href=&quot;#section-14.26&quot;&gt;14.26&lt;/a&gt;和&lt;a href=&quot;#section-14.44&quot;&gt;14.44&lt;/a&gt;。实体标签可以用于与同一资源中的其他实体进行比较（参见&lt;a href=&quot;#section-13.3.3&quot;&gt;第13.3.3节&lt;/a&gt;）。 ETag =&amp;ldquo; ETag&amp;rdquo;&amp;ldquo;：&amp;rdquo;实体标签示例：ETag：&amp;ldquo; xyzzy&amp;rdquo; ETag：W /&amp;ldquo; xyzzy&amp;rdquo; ETag：&amp;ldquo;&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="4712a2d0dd6a27be4029656072d6f063c6808073" translate="yes" xml:space="preserve">
          <source>The ETag response-header field value, an entity tag, provides for an
   &quot;opaque&quot; cache validator. This might allow more reliable validation
   in situations where it is inconvenient to store modification dates,
   where the one-second resolution of HTTP date values is not
   sufficient, or where the origin server wishes to avoid certain
   paradoxes that might arise from the use of modification dates.

   Entity Tags are described in &lt;a href=&quot;#section-3.11&quot;&gt;section 3.11&lt;/a&gt;. The headers used with
   entity tags are described in sections &lt;a href=&quot;#section-14.19&quot;&gt;14.19&lt;/a&gt;, &lt;a href=&quot;#section-14.24&quot;&gt;14.24&lt;/a&gt;, &lt;a href=&quot;#section-14.26&quot;&gt;14.26&lt;/a&gt; and &lt;a href=&quot;#section-14.44&quot;&gt;14.44&lt;/a&gt;.</source>
          <target state="translated">ETag响应标头字段值（一个实体标签）提供了一个&amp;ldquo;不透明&amp;rdquo;的缓存验证器。在不方便存储修改日期，HTTP日期值的一秒分辨率不足或原始服务器希望避免使用修改日期而引起的某些悖论的情况下，这可能允许更可靠的验证。 。实体标签在&lt;a href=&quot;#section-3.11&quot;&gt;3.11节&lt;/a&gt;中描述。与实体标签使用的头中各节中描述&lt;a href=&quot;#section-14.19&quot;&gt;14.19&lt;/a&gt;，&lt;a href=&quot;#section-14.24&quot;&gt;14.24&lt;/a&gt;，&lt;a href=&quot;#section-14.26&quot;&gt;14.26&lt;/a&gt;和&lt;a href=&quot;#section-14.44&quot;&gt;14.44&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6e574d1947b2d7656ccf38b993e2056ebdd1b0a0" translate="yes" xml:space="preserve">
          <source>The Expect request-header field is used to indicate that particular
   server behaviors are required by the client.

      Expect       =  &quot;Expect&quot; &quot;:&quot; 1#expectation

      expectation  =  &quot;100-continue&quot; | expectation-extension
      expectation-extension =  token [ &quot;=&quot; ( token | quoted-string )
                               *expect-params ]
      expect-params =  &quot;;&quot; token [ &quot;=&quot; ( token | quoted-string ) ]


   A server that does not understand or is unable to comply with any of
   the expectation values in the Expect field of a request MUST respond
   with appropriate error status. The server MUST respond with a 417
   (Expectation Failed) status if any of the expectations cannot be met
   or, if there are other problems with the request, some other 4xx
   status.

   This header field is defined with extensible syntax to allow for
   future extensions. If a server receives a request containing an
   Expect field that includes an expectation-extension that it does not
   support, it MUST respond with a 417 (Expectation Failed) status.

   Comparison of expectation values is case-insensitive for unquoted
   tokens (including the 100-continue token), and is case-sensitive for
   quoted-string expectation-extensions. 

   The Expect mechanism is hop-by-hop: that is, an HTTP/1.1 proxy MUST
   return a 417 (Expectation Failed) status if it receives a request
   with an expectation that it cannot meet. However, the Expect
   request-header itself is end-to-end; it MUST be forwarded if the
   request is forwarded.

   Many older HTTP/1.0 and HTTP/1.1 applications do not understand the
   Expect header.

   See &lt;a href=&quot;#section-8.2.3&quot;&gt;section 8.2.3&lt;/a&gt; for the use of the 100 (continue) status.</source>
          <target state="translated">Expect请求标头字段用于指示客户端要求特定的服务器行为。期望=&amp;ldquo;期望&amp;rdquo;&amp;ldquo;：&amp;rdquo;&amp;ldquo; 1＃期望期望=&amp;rdquo; 100-继续&amp;ldquo; |期望扩展期望扩展=标记[&amp;ldquo; =&amp;rdquo;（标记|带引号的字符串）*期望参数]期望参数=&amp;ldquo;;&amp;rdquo; token [&amp;ldquo; =&amp;rdquo;（token | quoted-string）]不理解或无法遵守请求的Expect字段中的任何期望值的服务器必须以适当的错误状态进行响应。如果不能满足任何期望，或者如果请求有其他问题，则服务器必须以417（期望失败）状态做出响应，或者其他4xx状态。此标头字段使用可扩展语法定义，以允许将来扩展。如果服务器收到一个包含Expect字段的请求，该请求包含一个不支持的Expectation-Extension，则它必须以417（Expectation Failed）状态响应。期望值的比较对于未加引号的标记（包括100个继续标记）不区分大小写，对于带引号的字符串期望扩展则区分大小写。 Expect机制是逐跳的：也就是说，如果HTTP / 1.1代理收到期望无法满足的请求，则它必须返回417（期望失败）状态。但是，期望请求标头本身是端到端的；如果请求已转发，则必须转发。许多较旧的HTTP / 1.0和HTTP / 1.1应用程序不了解Expect标头。看到看到看到看到看到看到看到如果服务器收到一个包含Expect字段的请求，该请求包含一个不支持的Expectation-Extension，则它必须以417（Expectation Failed）状态响应。期望值的比较对于未加引号的标记（包括100个继续标记）不区分大小写，对于带引号的字符串期望扩展则区分大小写。 Expect机制是逐跳的：也就是说，如果HTTP / 1.1代理收到预期无法满足的请求，则它必须返回417（预期失败）状态。但是，期望请求标头本身是端到端的；如果请求已转发，则必须转发。许多较旧的HTTP / 1.0和HTTP / 1.1应用程序不了解Expect标头。看到如果服务器收到一个包含Expect字段的请求，该请求包含一个不支持的Expectation-Extension，则它必须以417（Expectation Failed）状态响应。期望值的比较对于未加引号的标记（包括100个继续标记）不区分大小写，对于带引号的字符串期望扩展则区分大小写。 Expect机制是逐跳的：也就是说，如果HTTP / 1.1代理收到期望无法满足的请求，则它必须返回417（期望失败）状态。但是，期望请求标头本身是端到端的；如果请求已转发，则必须转发。许多较旧的HTTP / 1.0和HTTP / 1.1应用程序不了解Expect标头。看到看到看到期望值的比较对于未加引号的标记（包括100个继续标记）不区分大小写，对于带引号的字符串期望扩展则区分大小写。 Expect机制是逐跳的：也就是说，如果HTTP / 1.1代理收到预期无法满足的请求，则它必须返回417（预期失败）状态。但是，期望请求标头本身是端到端的；如果请求已转发，则必须转发。许多较旧的HTTP / 1.0和HTTP / 1.1应用程序不了解Expect标头。看到期望值的比较对于未加引号的标记（包括100个继续标记）不区分大小写，对于带引号的字符串期望扩展则区分大小写。 Expect机制是逐跳的：也就是说，如果HTTP / 1.1代理收到期望无法满足的请求，则它必须返回417（期望失败）状态。但是，期望请求标头本身是端到端的；如果请求已转发，则必须转发。许多较旧的HTTP / 1.0和HTTP / 1.1应用程序不了解Expect标头。看到如果1个代理收到预期无法满足的请求，则必须返回417（预期失败）状态。但是，期望请求标头本身是端到端的；如果请求已转发，则必须转发。许多较旧的HTTP / 1.0和HTTP / 1.1应用程序不了解Expect标头。看到如果1个代理收到预期无法满足的请求，则必须返回417（预期失败）状态。但是，期望请求标头本身是端到端的；如果请求已转发，则必须转发。许多较旧的HTTP / 1.0和HTTP / 1.1应用程序不了解Expect标头。看到&lt;a href=&quot;#section-8.2.3&quot;&gt;第8.2.3节&lt;/a&gt;使用100（继续）状态。</target>
        </trans-unit>
        <trans-unit id="99ea10caeb88c8a848354c782365979235f3abbc" translate="yes" xml:space="preserve">
          <source>The Expires entity-header field gives the date/time after which the
   response is considered stale. A stale cache entry may not normally be
   returned by a cache (either a proxy cache or a user agent cache)
   unless it is first validated with the origin server (or with an
   intermediate cache that has a fresh copy of the entity). See &lt;a href=&quot;#section-13.2&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-13.2&quot;&gt;13.2&lt;/a&gt; for further discussion of the expiration model.

   The presence of an Expires field does not imply that the original
   resource will change or cease to exist at, before, or after that
   time.

   The format is an absolute date and time as defined by HTTP-date in
   &lt;a href=&quot;#section-3.3.1&quot;&gt;section 3.3.1&lt;/a&gt;; it MUST be in &lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;RFC 1123&lt;/a&gt; date format:

      Expires = &quot;Expires&quot; &quot;:&quot; HTTP-date

   An example of its use is

      Expires: Thu, 01 Dec 1994 16:00:00 GMT

      Note: if a response includes a Cache-Control field with the max-
      age directive (see &lt;a href=&quot;#section-14.9.3&quot;&gt;section 14.9.3&lt;/a&gt;), that directive overrides the
      Expires field.

   HTTP/1.1 clients and caches MUST treat other invalid date formats,
   especially including the value &quot;0&quot;, as in the past (i.e., &quot;already
   expired&quot;).

   To mark a response as &quot;already expired,&quot; an origin server sends an
   Expires date that is equal to the Date header value. (See the rules
   for expiration calculations in &lt;a href=&quot;#section-13.2.4&quot;&gt;section 13.2.4&lt;/a&gt;.) 

   To mark a response as &quot;never expires,&quot; an origin server sends an
   Expires date approximately one year from the time the response is
   sent. HTTP/1.1 servers SHOULD NOT send Expires dates more than one
   year in the future.

   The presence of an Expires header field with a date value of some
   time in the future on a response that otherwise would by default be
   non-cacheable indicates that the response is cacheable, unless
   indicated otherwise by a Cache-Control header field (&lt;a href=&quot;#section-14.9&quot;&gt;section 14.9&lt;/a&gt;).</source>
          <target state="translated">Expires实体标题字段提供了将日期/时间视为过期的日期/时间。缓存（代理缓存或用户代理缓存）通常不会返回陈旧的缓存条目，除非首先使用源服务器（或使用具有实体的新副本的中间缓存）对其进行验证。有关到期模型的进一步讨论，请参见&lt;a href=&quot;#section-13.2&quot;&gt;第&lt;/a&gt;&lt;a href=&quot;#section-13.2&quot;&gt;13.2 &lt;/a&gt;节。Expires字段的存在并不意味着原始资源将在该时间之前，之后或之后改变或不再存在。格式是绝对日期和时间，如&lt;a href=&quot;#section-3.3.1&quot;&gt;第3.3.1节中的&lt;/a&gt; HTTP-date所定义 ；它必须在&lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;RFC 1123中&lt;/a&gt;日期格式：Expires =&amp;ldquo; Expires&amp;rdquo;&amp;ldquo;：&amp;rdquo; HTTP-date它的使用示例是Expires：Thu，01 Dec 1994 16:00:00 GMT注意：如果响应包含带有maxage指令的Cache-Control字段（请参见&lt;a href=&quot;#section-14.9.3&quot;&gt;14.9.3节&lt;/a&gt;），该指令将覆盖Expires字段。 HTTP / 1.1客户端和缓存必须像过去一样对待其他无效的日期格式，尤其是包括值&amp;ldquo; 0&amp;rdquo;（即&amp;ldquo;已经过期&amp;rdquo;）。要将响应标记为&amp;ldquo;已过期&amp;rdquo;，原始服务器将发送一个等于Date标头值的Expires日期。 （请参阅&lt;a href=&quot;#section-13.2.4&quot;&gt;第13.2.4节中的&lt;/a&gt;到期时间计算规则。）要将响应标记为&amp;ldquo;永不过期&amp;rdquo;，则源服务器会从发送响应之日起大约一年后发送一个Expires日期。 HTTP / 1.1服务器不应发送超过一年的过期日期。响应上存在将来某个日期的日期值的Expires标头字段，否则默认情况下将是不可缓存的，这表明该响应是可缓存的，除非由Cache-Control标头字段另行指示（&lt;a href=&quot;#section-14.9&quot;&gt;第14.9节&lt;/a&gt;） 。</target>
        </trans-unit>
        <trans-unit id="074a25a70f6f59d4456b693beabbab06efa52e09" translate="yes" xml:space="preserve">
          <source>The Feature Policy directive to apply the &lt;code&gt;allowlist&lt;/code&gt; to. See &lt;a href=&quot;#Directives&quot;&gt;Directives&lt;/a&gt; below for a list of the permitted directive names.</source>
          <target state="translated">要应用 &lt;code&gt;allowlist&lt;/code&gt; 的功能策略指令。见&lt;a href=&quot;#Directives&quot;&gt;指令&lt;/a&gt;下面的许可指令名称的列表。</target>
        </trans-unit>
        <trans-unit id="802828c9e44a9d19272a3ae660a11b2bb9d689e1" translate="yes" xml:space="preserve">
          <source>The Feature-Policy HTTP header</source>
          <target state="translated">特征-政策HTTP头</target>
        </trans-unit>
        <trans-unit id="8b610252bef915d12d88c567e1882bdb3b137742" translate="yes" xml:space="preserve">
          <source>The From request-header field, if given, SHOULD contain an Internet
   e-mail address for the human user who controls the requesting user
   agent. The address SHOULD be machine-usable, as defined by &quot;mailbox&quot;
   in &lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt; [&lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt;] as updated by &lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;RFC 1123&lt;/a&gt; [&lt;a href=&quot;#ref-8&quot;&gt;8&lt;/a&gt;]:

       From   = &quot;From&quot; &quot;:&quot; mailbox

   An example is:

       From: webmaster@w3.org

   This header field MAY be used for logging purposes and as a means for
   identifying the source of invalid or unwanted requests. It SHOULD NOT
   be used as an insecure form of access protection. The interpretation
   of this field is that the request is being performed on behalf of the
   person given, who accepts responsibility for the method performed. In
   particular, robot agents SHOULD include this header so that the
   person responsible for running the robot can be contacted if problems
   occur on the receiving end.

   The Internet e-mail address in this field MAY be separate from the
   Internet host which issued the request. For example, when a request
   is passed through a proxy the original issuer's address SHOULD be
   used.

   The client SHOULD NOT send the From header field without the user's
   approval, as it might conflict with the user's privacy interests or
   their site's security policy. It is strongly recommended that the
   user be able to disable, enable, and modify the value of this field
   at any time prior to a request.</source>
          <target state="translated">发件人请求头字段（如果提供）应该包含控制请求用户代理的人类用户的Internet电子邮件地址。地址应为机器可用，如通过&amp;ldquo;邮箱&amp;rdquo;中定义&lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt; [ &lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt; ]如通过更新&lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;RFC 1123&lt;/a&gt; [ &lt;a href=&quot;#ref-8&quot;&gt;8&lt;/a&gt;]：发件人=&amp;ldquo;发件人&amp;rdquo;&amp;ldquo;：&amp;rdquo;邮箱例如：发件人：webmaster@w3.org此标头字段可用于记录目的，并用作标识无效或不需要的请求的来源。不应将其用作访问保护的不安全形式。该字段的解释是，请求是代表给定的人执行的，该人对执行的方法承担责任。特别是，机器人代理应包含此标头，以便在接收端发生问题时可以联系负责运行机器人的人员。此字段中的Internet电子邮件地址可以与发出请求的Internet主机分开。例如，当请求通过代理传递时，原始发行者的的地址应使用。在未经用户批准的情况下，客户端不应该发送From头字段，因为它可能与用户的隐私权或他们站点的安全策略冲突。强烈建议用户在请求之前的任何时候都可以禁用，启用和修改此字段的值。</target>
        </trans-unit>
        <trans-unit id="8a3df35a0d664c78b3c3b6d7181ee8d7a2e5448f" translate="yes" xml:space="preserve">
          <source>The GET method means retrieve whatever information (in the form of an
   entity) is identified by the Request-URI. If the Request-URI refers
   to a data-producing process, it is the produced data which shall be
   returned as the entity in the response and not the source text of the
   process, unless that text happens to be the output of the process.

   The semantics of the GET method change to a &quot;conditional GET&quot; if the
   request message includes an If-Modified-Since, If-Unmodified-Since,
   If-Match, If-None-Match, or If-Range header field. A conditional GET
   method requests that the entity be transferred only under the
   circumstances described by the conditional header field(s). The
   conditional GET method is intended to reduce unnecessary network
   usage by allowing cached entities to be refreshed without requiring
   multiple requests or transferring data already held by the client.

   The semantics of the GET method change to a &quot;partial GET&quot; if the
   request message includes a Range header field. A partial GET requests
   that only part of the entity be transferred, as described in &lt;a href=&quot;#section-14.35&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-14.35&quot;&gt;14.35&lt;/a&gt;. The partial GET method is intended to reduce unnecessary
   network usage by allowing partially-retrieved entities to be
   completed without transferring data already held by the client.

   The response to a GET request is cacheable if and only if it meets
   the requirements for HTTP caching described in &lt;a href=&quot;#section-13&quot;&gt;section 13&lt;/a&gt;.

   See &lt;a href=&quot;#section-15.1.3&quot;&gt;section 15.1.3&lt;/a&gt; for security considerations when used for forms.</source>
          <target state="translated">GET方法意味着检索由Request-URI标识的任何信息（以实体的形式）。如果Request-URI涉及数据产生过程，则应将产生的数据作为响应中的实体返回，而不是过程的源文本，除非该文本恰好是过程的输出。如果请求消息包含If-Modified-Since，If-Unmodified-Since，If-Match，If-None-Match或If-Range标头字段，则GET方法的语义将变为&amp;ldquo;条件GET&amp;rdquo;。条件GET方法仅在条件标头字段描述的情况下才请求转移实体。有条件的GET方法旨在通过允许刷新缓存的实体而无需多个请求或传输客户端已经拥有的数据来减少不必要的网络使用。如果请求消息包含Range标头字段，则GET方法的语义将更改为&amp;ldquo;部分GET&amp;rdquo;。部分GET请求仅转移实体的一部分，如&lt;a href=&quot;#section-14.35&quot;&gt;第&lt;/a&gt;&lt;a href=&quot;#section-14.35&quot;&gt;14.35条&lt;/a&gt;。部分GET方法旨在通过允许部分取回的实体完成而无需传输客户端已经拥有的数据来减少不必要的网络使用。对GET请求的响应只有在满足&lt;a href=&quot;#section-13&quot;&gt;第13节中&lt;/a&gt;描述的HTTP缓存要求时才可以缓存。有关用于表单的安全性注意事项，请参见&lt;a href=&quot;#section-15.1.3&quot;&gt;15.1.3节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7fe6f3c8c21eb606abd80993ecfb90185941dd2b" translate="yes" xml:space="preserve">
          <source>The GET method requests transfer of a current selected representation
   for the target resource.  GET is the primary mechanism of information
   retrieval and the focus of almost all performance optimizations.
   Hence, when people speak of retrieving some identifiable information
   via HTTP, they are generally referring to making a GET request.

   It is tempting to think of resource identifiers as remote file system
   pathnames and of representations as being a copy of the contents of
   such files.  In fact, that is how many resources are implemented (see
   &lt;a href=&quot;#section-9.1&quot;&gt;Section 9.1&lt;/a&gt; for related security considerations).  However, there are
   no such limitations in practice.  The HTTP interface for a resource
   is just as likely to be implemented as a tree of content objects, a
   programmatic view on various database records, or a gateway to other
   information systems.  Even when the URI mapping mechanism is tied to
   a file system, an origin server might be configured to execute the
   files with the request as input and send the output as the
   representation rather than transfer the files directly.  Regardless,
   only the origin server needs to know how each of its resource 

   identifiers corresponds to an implementation and how each
   implementation manages to select and send a current representation of
   the target resource in a response to GET.

   A client can alter the semantics of GET to be a &quot;range request&quot;,
   requesting transfer of only some part(s) of the selected
   representation, by sending a Range header field in the request
   ([&lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC7233&lt;/a&gt;]).

   A payload within a GET request message has no defined semantics;
   sending a payload body on a GET request might cause some existing
   implementations to reject the request.

   The response to a GET request is cacheable; a cache MAY use it to
   satisfy subsequent GET and HEAD requests unless otherwise indicated
   by the Cache-Control header field (&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2&quot;&gt;Section&amp;nbsp;5.2 of [RFC7234]&lt;/a&gt;).</source>
          <target state="translated">GET方法请求传输目标资源的当前选定表示形式。 GET是信息检索的主要机制，也是几乎所有性能优化的重点。因此，当人们谈论通过HTTP检索某些可识别的信息时，他们通常指的是发出GET请求。极有可能将资源标识符视为远程文件系统路径名，并将表示形式视为此类文件内容的副本。实际上，这就是实施了多少资源（请参阅 &lt;a href=&quot;#section-9.1&quot;&gt;第9.1节）&lt;/a&gt;出于相关的安全考虑）。但是，实际上没有这种限制。资源的HTTP接口很可能实现为内容对象树，各种数据库记录上的编程视图或其他信息系统的网关。即使将URI映射机制绑定到文件系统，也可以将原始服务器配置为以请求作为输入执行文件，并以表示形式发送输出，而不是直接传输文件。无论如何，仅原始服务器需要知道其每个资源标识符如何对应于一个实现，以及每个实现如何设法选择并发送对GET的响应的目标资源的当前表示。客户可以将GET的语义更改为&amp;ldquo;范围请求&amp;rdquo;，通过在请求中发送范围标头字段来请求仅传输所选表示形式的某些部分（[&lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC7233&lt;/a&gt; ]）。GET请求消息中的有效负载没有定义的语义。在GET请求上发送有效内容正文可能会导致某些现有实现拒绝该请求。对GET请求的响应是可缓存的；缓存可以使用它来满足后续的GET和HEAD请求，除非Cache-Control头字段（&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2&quot;&gt;[RFC7234]的5.2节）&lt;/a&gt;另有说明。</target>
        </trans-unit>
        <trans-unit id="7d2462324b684ba6bb0e708d0480d884f24bd586" translate="yes" xml:space="preserve">
          <source>The GOAWAY frame (type=0x7) is used to initiate shutdown of a
   connection or to signal serious error conditions.  GOAWAY allows an
   endpoint to gracefully stop accepting new streams while still
   finishing processing of previously established streams.  This enables
   administrative actions, like server maintenance.

   There is an inherent race condition between an endpoint starting new
   streams and the remote sending a GOAWAY frame.  To deal with this
   case, the GOAWAY contains the stream identifier of the last peer-
   initiated stream that was or might be processed on the sending
   endpoint in this connection.  For instance, if the server sends a
   GOAWAY frame, the identified stream is the highest-numbered stream
   initiated by the client.

   Once sent, the sender will ignore frames sent on streams initiated by
   the receiver if the stream has an identifier higher than the included
   last stream identifier.  Receivers of a GOAWAY frame MUST NOT open
   additional streams on the connection, although a new connection can
   be established for new streams.

   If the receiver of the GOAWAY has sent data on streams with a higher
   stream identifier than what is indicated in the GOAWAY frame, those
   streams are not or will not be processed.  The receiver of the GOAWAY
   frame can treat the streams as though they had never been created at
   all, thereby allowing those streams to be retried later on a new
   connection.

   Endpoints SHOULD always send a GOAWAY frame before closing a
   connection so that the remote peer can know whether a stream has been
   partially processed or not.  For example, if an HTTP client sends a
   POST at the same time that a server closes a connection, the client
   cannot know if the server started to process that POST request if the
   server does not send a GOAWAY frame to indicate what streams it might
   have acted on.

   An endpoint might choose to close a connection without sending a
   GOAWAY for misbehaving peers. 

   A GOAWAY frame might not immediately precede closing of the
   connection; a receiver of a GOAWAY that has no more use for the
   connection SHOULD still send a GOAWAY frame before terminating the
   connection.

    +-+-------------------------------------------------------------+
    |R|                  Last-Stream-ID (31)                        |
    +-+-------------------------------------------------------------+
    |                      Error Code (32)                          |
    +---------------------------------------------------------------+
    |                  Additional Debug Data (*)                    |
    +---------------------------------------------------------------+

                     Figure 13: GOAWAY Payload Format

   The GOAWAY frame does not define any flags.

   The GOAWAY frame applies to the connection, not a specific stream.
   An endpoint MUST treat a GOAWAY frame with a stream identifier other
   than 0x0 as a connection error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type
   PROTOCOL_ERROR.

   The last stream identifier in the GOAWAY frame contains the highest-
   numbered stream identifier for which the sender of the GOAWAY frame
   might have taken some action on or might yet take action on.  All
   streams up to and including the identified stream might have been
   processed in some way.  The last stream identifier can be set to 0 if
   no streams were processed.

      Note: In this context, &quot;processed&quot; means that some data from the
      stream was passed to some higher layer of software that might have
      taken some action as a result.

   If a connection terminates without a GOAWAY frame, the last stream
   identifier is effectively the highest possible stream identifier.

   On streams with lower- or equal-numbered identifiers that were not
   closed completely prior to the connection being closed, reattempting
   requests, transactions, or any protocol activity is not possible,
   with the exception of idempotent actions like HTTP GET, PUT, or
   DELETE.  Any protocol activity that uses higher-numbered streams can
   be safely retried using a new connection.

   Activity on streams numbered lower or equal to the last stream
   identifier might still complete successfully.  The sender of a GOAWAY
   frame might gracefully shut down a connection by sending a GOAWAY
   frame, maintaining the connection in an &quot;open&quot; state until all in-
   progress streams complete. 

   An endpoint MAY send multiple GOAWAY frames if circumstances change.
   For instance, an endpoint that sends GOAWAY with NO_ERROR during
   graceful shutdown could subsequently encounter a condition that
   requires immediate termination of the connection.  The last stream
   identifier from the last GOAWAY frame received indicates which
   streams could have been acted upon.  Endpoints MUST NOT increase the
   value they send in the last stream identifier, since the peers might
   already have retried unprocessed requests on another connection.

   A client that is unable to retry requests loses all requests that are
   in flight when the server closes the connection.  This is especially
   true for intermediaries that might not be serving clients using
   HTTP/2.  A server that is attempting to gracefully shut down a
   connection SHOULD send an initial GOAWAY frame with the last stream
   identifier set to 2^31-1 and a NO_ERROR code.  This signals to the
   client that a shutdown is imminent and that initiating further
   requests is prohibited.  After allowing time for any in-flight stream
   creation (at least one round-trip time), the server can send another
   GOAWAY frame with an updated last stream identifier.  This ensures
   that a connection can be cleanly shut down without losing requests.

   After sending a GOAWAY frame, the sender can discard frames for
   streams initiated by the receiver with identifiers higher than the
   identified last stream.  However, any frames that alter connection
   state cannot be completely ignored.  For instance, HEADERS,
   PUSH_PROMISE, and CONTINUATION frames MUST be minimally processed to
   ensure the state maintained for header compression is consistent (see
   &lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;); similarly, DATA frames MUST be counted toward the
   connection flow-control window.  Failure to process these frames can
   cause flow control or header compression state to become
   unsynchronized.

   The GOAWAY frame also contains a 32-bit error code (&lt;a href=&quot;#section-7&quot;&gt;Section 7&lt;/a&gt;) that
   contains the reason for closing the connection.

   Endpoints MAY append opaque data to the payload of any GOAWAY frame.
   Additional debug data is intended for diagnostic purposes only and
   carries no semantic value.  Debug information could contain security-
   or privacy-sensitive data.  Logged or otherwise persistently stored
   debug data MUST have adequate safeguards to prevent unauthorized
   access.</source>
          <target state="translated">GOAWAY帧（类型= 0x7）用于启动连接关闭或发出严重错误情况信号。 GOAWAY允许端点优雅地停止接受新流，同时仍然完成对先前建立的流的处理。这将启用管理操作，例如服务器维护。在端点开始新流和远程发送GOAWAY帧之间存在固有的竞争条件。为了处理这种情况，GOAWAY包含该连接的发送端点上已处理或可能已处理的最后一个对等方发起的流的流标识符。例如，如果服务器发送GOAWAY帧，则标识的流是客户端启动的编号最高的流。寄出后如果流的标识符高于所包含的最后一个流标识符，则发送方将忽略在接收方发起的流上发送的帧。尽管可以为新的流建立新的连接，但GOAWAY帧的接收者不得在连接上打开其他流。如果GOAWAY的接收器已在具有比GOAWAY帧中指示的流标识符更高的流标识符的流上发送数据，则这些流将不会或将不会被处理。 GOAWAY帧的接收器可以将这些流视为从未创建过，因此可以稍后在新连接上重试这些流。端点应始终在关闭连接之前发送GOAWAY帧，以便远程对等端可以知道流是否已被部分处理。例如，如果HTTP客户端在服务器关闭连接的同时发送POST，则如果服务器未发送GOAWAY帧来指示其可能作用于哪些流，则客户端将无法知道服务器是否开始处理该POST请求。端点可能选择关闭连接，而不发送对等端行为不正常的GOAWAY。 GOAWAY框架可能不会在连接关闭之前立即出现。不再用于连接的GOAWAY的接收方应该在终止连接之前仍然发送GOAWAY帧。+-+ ----------------------------------------------- -------------- + | R |最后流ID（31）| +-+ ----------------------------------------------- -------------- + |错误代码（32）| + ------------------------------------------------- -------------- + |其他调试数据（*）| + ------------------------------------------------- -------------- +图13：GOAWAY有效载荷格式GOAWAY框架未定义任何标志。 GOAWAY帧适用于连接，而不适用于特定的流。端点必须将流标识符不是0x0的GOAWAY帧视为连接错误（&lt;a href=&quot;#section-5.4.1&quot;&gt;第5.4.1节&lt;/a&gt;），类型为PROTOCOL_ERROR。 GOAWAY帧中的最后一个流标识符包含编号最高的流标识符，对于该标识符，GOAWAY帧的发送者可能已对其采取了某些措施，或者可能已对其采取了措施。直至并包括所标识的流的所有流都可能已通过某种方式进行了处理。如果未处理任何流，则最后一个流标识符可以设置为0。注意：在这种情况下，&amp;ldquo;已处理&amp;rdquo;是指流中的某些数据已传递到可能已采取某些措施的较高软件层。如果连接在没有GOAWAY帧的情况下终止，则最后一个流标识符实际上是可能的最高流标识符。在标识符数量较少或相等的流在关闭连接之前没有完全关闭的情况下，重新尝试请求，事务，或任何协议活动都是不可能的，除了幂等操作（如HTTP GET，PUT或DELETE）。可以使用新连接安全地重试使用编号更高的流的任何协议活动。编号小于或等于最后一个流标识符的流上的活动仍可能成功完成。 GOAWAY帧的发送方可以通过发送GOAWAY帧来正常关闭连接，将连接保持在&amp;ldquo;打开&amp;rdquo;状态，直到所有进行中的流完成为止。如果情况改变，端点可以发送多个GOAWAY帧。例如，在正常关闭期间发送NO_ERROR的GOAWAY的端点随后可能会遇到需要立即终止连接的情况。来自接收到的最后一个GOAWAY帧的最后一个流标识符指示可能已经作用了哪些流。端点不得增加它们在最后一个流标识符中发送的值，因为对等点可能已经在另一个连接上重试了未处理的请求。当服务器关闭连接时，无法重试请求的客户端将丢失所有正在处理的请求。对于可能不使用HTTP / 2为客户端提供服务的中介而言，尤其如此。试图正常关闭连接的服务器应发送初始GOAWAY帧，其最后一个流标识符设置为2 ^ 31-1，并提供NO_ERROR代码。这向客户端发出信号，即将关闭，并且禁止发起进一步的请求。在为所有进行中的流创建时间（至少一个往返时间）之后，服务器可以发送具有更新的最后一个流标识符的另一个GOAWAY帧。这确保可以干净地关闭连接而不会丢失请求。发送GOAWAY帧后，发送方可以丢弃接收方发起的流的帧，这些流的标识符要比所标识的最后一个流高。但是，任何更改连接状态的帧都不能完全忽略。例如，必须最少处理HEADERS，PUSH_PROMISE和CONTINUATION帧，以确保为报头压缩保持的状态是一致的（请参阅发送方可以丢弃接收方发起的流的帧，这些流的标识符要比所标识的最后一个流高。但是，任何更改连接状态的帧都不能完全忽略。例如，必须最少处理HEADERS，PUSH_PROMISE和CONTINUATION帧，以确保为报头压缩保持的状态是一致的（请参阅发送方可以丢弃接收方发起的流的帧，这些流的标识符要比所标识的最后一个流高。但是，任何更改连接状态的帧都不能完全忽略。例如，必须最少处理HEADERS，PUSH_PROMISE和CONTINUATION帧，以确保为报头压缩保持的状态是一致的（请参阅&lt;a href=&quot;#section-4.3&quot;&gt;第4.3节&lt;/a&gt;）;同样，DATA帧必须计入连接流控制窗口。无法处理这些帧会导致流控制或头压缩状态变得不同步。 GOAWAY框架还包含一个32位错误代码（&lt;a href=&quot;#section-7&quot;&gt;第7节&lt;/a&gt;），其中包含关闭连接的原因。端点可以将不透明数据附加到任何GOAWAY帧的有效载荷上。其他调试数据仅用于诊断目的，不包含语义值。调试信息可能包含对安全性或隐私敏感的数据。记录的或以其他方式持久存储的调试数据必须具有足够的防护措施，以防止未经授权的访问。</target>
        </trans-unit>
        <trans-unit id="5094fc44298eab7b1db803d184d5d22fe3243b4b" translate="yes" xml:space="preserve">
          <source>The General Data Privacy Regulation (GDPR) in the European Union</source>
          <target state="translated">欧洲联盟的《一般数据隐私条例》(GDPR)。</target>
        </trans-unit>
        <trans-unit id="7df79dab20c7e00cfdc0198d8b7108bafe0b904f" translate="yes" xml:space="preserve">
          <source>The HEAD method is identical to GET except that the server MUST NOT
   return a message-body in the response. The metainformation contained
   in the HTTP headers in response to a HEAD request SHOULD be identical
   to the information sent in response to a GET request. This method can
   be used for obtaining metainformation about the entity implied by the
   request without transferring the entity-body itself. This method is
   often used for testing hypertext links for validity, accessibility,
   and recent modification.

   The response to a HEAD request MAY be cacheable in the sense that the
   information contained in the response MAY be used to update a
   previously cached entity from that resource. If the new field values
   indicate that the cached entity differs from the current entity (as
   would be indicated by a change in Content-Length, Content-MD5, ETag
   or Last-Modified), then the cache MUST treat the cache entry as
   stale.</source>
          <target state="translated">HEAD方法与GET方法相同,除了服务器必须不在响应中返回一个消息体。响应HEAD请求的HTTP头中包含的元信息应该与响应GET请求时发送的信息相同。这种方法可以用来获取请求中所隐含的实体的元信息,而不需要传输实体体本身。这种方法通常用于测试超文本链接的有效性、可访问性和最近的修改。对HEAD请求的响应可以是可缓存的,因为响应中包含的信息可以用来更新该资源中先前缓存的实体。如果新的字段值表明缓存的实体与当前实体不同(如Content-Length、Content-MD5、ETag或Last-Modified的变化),那么缓存必须将缓存条目视为陈旧。</target>
        </trans-unit>
        <trans-unit id="af87f0a9948cd0c865e17fe40c999f5f6559a626" translate="yes" xml:space="preserve">
          <source>The HEAD method is identical to GET except that the server MUST NOT
   send a message body in the response (i.e., the response terminates at
   the end of the header section).  The server SHOULD send the same
   header fields in response to a HEAD request as it would have sent if
   the request had been a GET, except that the payload header fields
   (&lt;a href=&quot;#section-3.3&quot;&gt;Section 3.3&lt;/a&gt;) MAY be omitted.  This method can be used for obtaining
   metadata about the selected representation without transferring the
   representation data and is often used for testing hypertext links for
   validity, accessibility, and recent modification.

   A payload within a HEAD request message has no defined semantics;
   sending a payload body on a HEAD request might cause some existing
   implementations to reject the request.

   The response to a HEAD request is cacheable; a cache MAY use it to
   satisfy subsequent HEAD requests unless otherwise indicated by the
   Cache-Control header field (&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2&quot;&gt;Section&amp;nbsp;5.2 of [RFC7234]&lt;/a&gt;).  A HEAD
   response might also have an effect on previously cached responses to
   GET; see &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.3.5&quot;&gt;Section&amp;nbsp;4.3.5 of [RFC7234]&lt;/a&gt;.</source>
          <target state="translated">HEAD方法与GET相同，不同之处在于服务器在响应中不得发送消息正文（即，响应在标头部分的结尾处终止）。服务器应发送与HEAD请求相同的头字段，以响应HEAD请求，但有效载荷头字段除外（&lt;a href=&quot;#section-3.3&quot;&gt;第3.3节）&lt;/a&gt;）可以省略。此方法可用于获取有关所选表示形式的元数据而无需传输表示形式数据，并且通常用于测试超文本链接的有效性，可访问性和最新修改。 HEAD请求消息中的有效载荷没有定义的语义。在HEAD请求上发送有效内容主体可能会导致某些现有实现拒绝该请求。对HEAD请求的响应是可缓存的；高速缓存可以使用它来满足后续的HEAD请求，除非Cache-Control头字段另有指示（&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2&quot;&gt;[RFC7234]的5.2节&lt;/a&gt;）。 HEAD响应也可能会影响先前缓存的GET响应；参见&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.3.5&quot;&gt;[RFC7234]的4.3.5节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9b66172e68b0534fed4eb909af19fada53af1789" translate="yes" xml:space="preserve">
          <source>The HEADERS frame (type=0x1) is used to open a stream (&lt;a href=&quot;#section-5.1&quot;&gt;Section 5.1&lt;/a&gt;),
   and additionally carries a header block fragment.  HEADERS frames can
   be sent on a stream in the &quot;idle&quot;, &quot;reserved (local)&quot;, &quot;open&quot;, or
   &quot;half-closed (remote)&quot; state. 

    +---------------+
    |Pad Length? (8)|
    +-+-------------+-----------------------------------------------+
    |E|                 Stream Dependency? (31)                     |
    +-+-------------+-----------------------------------------------+
    |  Weight? (8)  |
    +-+-------------+-----------------------------------------------+
    |                   Header Block Fragment (*)                 
    +---------------------------------------------------------------+
    |                           Padding (*)                       
    +---------------------------------------------------------------+

                      Figure 7: HEADERS Frame Payload

   The HEADERS frame payload has the following fields:

   Pad Length:  An 8-bit field containing the length of the frame
      padding in units of octets.  This field is only present if the
      PADDED flag is set.

   E: A single-bit flag indicating that the stream dependency is
      exclusive (see &lt;a href=&quot;#section-5.3&quot;&gt;Section 5.3&lt;/a&gt;).  This field is only present if the
      PRIORITY flag is set.

   Stream Dependency:  A 31-bit stream identifier for the stream that
      this stream depends on (see &lt;a href=&quot;#section-5.3&quot;&gt;Section 5.3&lt;/a&gt;).  This field is only
      present if the PRIORITY flag is set.

   Weight:  An unsigned 8-bit integer representing a priority weight for
      the stream (see &lt;a href=&quot;#section-5.3&quot;&gt;Section 5.3&lt;/a&gt;).  Add one to the value to obtain a
      weight between 1 and 256.  This field is only present if the
      PRIORITY flag is set.

   Header Block Fragment:  A header block fragment (&lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;).

   Padding:  Padding octets.

   The HEADERS frame defines the following flags:

   END_STREAM (0x1):  When set, bit 0 indicates that the header block
      (&lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;) is the last that the endpoint will send for the
      identified stream.

      A HEADERS frame carries the END_STREAM flag that signals the end
      of a stream.  However, a HEADERS frame with the END_STREAM flag
      set can be followed by CONTINUATION frames on the same stream.
      Logically, the CONTINUATION frames are part of the HEADERS frame. 

   END_HEADERS (0x4):  When set, bit 2 indicates that this frame
      contains an entire header block (&lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;) and is not followed
      by any CONTINUATION frames.

      A HEADERS frame without the END_HEADERS flag set MUST be followed
      by a CONTINUATION frame for the same stream.  A receiver MUST
      treat the receipt of any other type of frame or a frame on a
      different stream as a connection error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type
      PROTOCOL_ERROR.

   PADDED (0x8):  When set, bit 3 indicates that the Pad Length field
      and any padding that it describes are present.

   PRIORITY (0x20):  When set, bit 5 indicates that the Exclusive Flag
      (E), Stream Dependency, and Weight fields are present; see
      &lt;a href=&quot;#section-5.3&quot;&gt;Section 5.3&lt;/a&gt;.

   The payload of a HEADERS frame contains a header block fragment
   (&lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;).  A header block that does not fit within a HEADERS
   frame is continued in a CONTINUATION frame (&lt;a href=&quot;#section-6.10&quot;&gt;Section 6.10&lt;/a&gt;).

   HEADERS frames MUST be associated with a stream.  If a HEADERS frame
   is received whose stream identifier field is 0x0, the recipient MUST
   respond with a connection error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type
   PROTOCOL_ERROR.

   The HEADERS frame changes the connection state as described in
   &lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;.

   The HEADERS frame can include padding.  Padding fields and flags are
   identical to those defined for DATA frames (&lt;a href=&quot;#section-6.1&quot;&gt;Section 6.1&lt;/a&gt;).  Padding
   that exceeds the size remaining for the header block fragment MUST be
   treated as a PROTOCOL_ERROR.

   Prioritization information in a HEADERS frame is logically equivalent
   to a separate PRIORITY frame, but inclusion in HEADERS avoids the
   potential for churn in stream prioritization when new streams are
   created.  Prioritization fields in HEADERS frames subsequent to the
   first on a stream reprioritize the stream (&lt;a href=&quot;#section-5.3.3&quot;&gt;Section 5.3.3&lt;/a&gt;).</source>
          <target state="translated">HEADERS帧（类型= 0x1）用于打开流（&lt;a href=&quot;#section-5.1&quot;&gt;第5.1节）&lt;/a&gt;），并另外包含一个标头块片段。 HEADERS帧可以在&amp;ldquo;空闲&amp;rdquo;，&amp;ldquo;保留（本地）&amp;rdquo;，&amp;ldquo;打开&amp;rdquo;或&amp;ldquo;半关闭（远程）&amp;rdquo;状态下在流上发送。 + --------------- + |垫长？ （8）| +-+ ------------- + --------------------------------- -------------- + | E |流依赖？ （31）| +-+ ------------- + --------------------------------- -------------- + |重量？ （8）| +-+ ------------- + --------------------------------- -------------- + |标题块片段（*）+ ------------------------------------------- -------------------- + |填充（*）+ --------------------------------------------- ------------------ +图7：HEADERS帧有效载荷HEADERS帧有效载荷具有以下字段：Pad Length：8位字段，其中包含帧填充的长度。八位位组的单位。仅当设置了PADDED标志时，此字段才存在。 E：一位标志，指示流依赖项是互斥的（请参阅&lt;a href=&quot;#section-5.3&quot;&gt;第5.3节&lt;/a&gt;）。仅当设置了PRIORITY标志时，此字段才存在。流相关性：此流所依赖的流的31位流标识符（请参阅&lt;a href=&quot;#section-5.3&quot;&gt;第5.3节&lt;/a&gt;）。仅当设置了PRIORITY标志时，此字段才存在。权重：表示流优先级权重的无符号8位整数（请参见&lt;a href=&quot;#section-5.3&quot;&gt;5.3节&lt;/a&gt;）。将值加1以获得介于1和256之间的权重。仅当设置了PRIORITY标志时，才显示此字段。标头块片段：标头块片段（&lt;a href=&quot;#section-4.3&quot;&gt;第4.3节&lt;/a&gt;）。填充：填充八位字节。 HEADERS帧定义以下标志：END_STREAM（0x1）：设置后，位0指示标题块（&lt;a href=&quot;#section-4.3&quot;&gt;第4.3节）&lt;/a&gt;）是端点将为标识的流发送的最后一个。 HEADERS帧带有END_STREAM标志，该标志指示流的结尾。但是，设置了END_STREAM标志的HEADERS帧之后可以是同一流上的CONTINUATION帧。逻辑上，CONTINUATION框架是HEADERS框架的一部分。 END_HEADERS（0x4）：设置后，位2指示该帧包含整个头块（&lt;a href=&quot;#section-4.3&quot;&gt;第4.3节&lt;/a&gt;），并且之后没有任何CONTINUATION帧。没有设置END_HEADERS标志的HEADERS帧之后必须是同一流的CONTINUATION帧。接收方必须将接收到的任何其他类型的帧或不同流上的帧视为连接错误（&lt;a href=&quot;#section-5.4.1&quot;&gt;5.4.1节）&lt;/a&gt;），类型为PROTOCOL_ERROR。 PADDED（0x8）：设置时，位3指示存在&amp;ldquo;填充长度&amp;rdquo;字段及其描述的任何填充。优先级（0x20）：设置为5时，位5表示存在独占标志（E），流依赖项和权重字段；否则为0。参见&lt;a href=&quot;#section-5.3&quot;&gt;第5.3节&lt;/a&gt;。 HEADERS帧的有效载荷包含一个报头块片段（&lt;a href=&quot;#section-4.3&quot;&gt;第4.3节&lt;/a&gt;）。不适合HEADERS框架的标题块在CONTINUATION框架中继续（&lt;a href=&quot;#section-6.10&quot;&gt;第6.10节&lt;/a&gt;）。 HEADERS帧必须与流关联。如果接收到流标识符字段为0x0的HEADERS帧，则接收者务必以PROTOCOL_ERROR类型的连接错误（&lt;a href=&quot;#section-5.4.1&quot;&gt;第5.4.1节&lt;/a&gt;）做出响应。 HEADERS框架按如下所述更改连接状态&lt;a href=&quot;#section-4.3&quot;&gt;第4.3节&lt;/a&gt;。 HEADERS框架可以包含填充。填充字段和标志与为DATA帧定义的填充字段和标志相同（&lt;a href=&quot;#section-6.1&quot;&gt;第6.1节&lt;/a&gt;）。超出标题块片段剩余大小的填充必须被视为PROTOCOL_ERROR。 HEADERS帧中的优先级信息在逻辑上等效于单独的PRIORITY帧，但包含在HEADERS中避免了在创建新流时流优先级流失的可能性。在第一个流之后的HEADERS帧中的优先级字段将对流进行优先级排序（&lt;a href=&quot;#section-5.3.3&quot;&gt;第5.3.3节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="5fa0cc40bb9e4667e351329947478703648e5a09" translate="yes" xml:space="preserve">
          <source>The HTML of &lt;code&gt;signup.html&lt;/code&gt; looks like this:</source>
          <target state="translated">&lt;code&gt;signup.html&lt;/code&gt; 的HTML 如下所示：</target>
        </trans-unit>
        <trans-unit id="7de3d21abd96bd4beb67ffb6ec818595df38d03d" translate="yes" xml:space="preserve">
          <source>The HTTP 1.1 (only) &lt;code&gt;Upgrade&lt;/code&gt; header can be used to upgrade an already established client/server connection to a different protocol (over the same transport protocol). For example, it can be used by a client to upgrade a connection from HTTP 1.1 to HTTP 2.0, or an HTTP or HTTPS connection into a WebSocket.</source>
          <target state="translated">HTTP 1.1（仅） &lt;code&gt;Upgrade&lt;/code&gt; 头可用于将已经建立的客户端/服务器连接升级到其他协议（通过相同的传输协议）。例如，客户端可以使用它来将连接从HTTP 1.1升级到HTTP 2.0，或者将HTTP或HTTPS连接升级到WebSocket。</target>
        </trans-unit>
        <trans-unit id="9e4ed100d87a6355dfbd6e285bdb4feb98fdc0d9" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;block-all-mixed-content&lt;/strong&gt;&lt;/code&gt; directive prevents loading any assets over HTTP when the page uses HTTPS.</source>
          <target state="translated">当页面使用HTTPS时，HTTP&lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;block-all-mixed-content&lt;/strong&gt;&lt;/code&gt; 指令可防止通过HTTP加载任何资产。</target>
        </trans-unit>
        <trans-unit id="f9ee255be05b605cffc50bf531b8bbc6cd52f1c8" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;block-all-mixed-content&lt;/strong&gt;&lt;/code&gt; directive prevents loading any assets using HTTP when the page is loaded using HTTPS.</source>
          <target state="translated">当使用HTTPS加载页面时，HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;block-all-mixed-content&lt;/strong&gt;&lt;/code&gt; 指令可防止使用HTTP加载任何资产。</target>
        </trans-unit>
        <trans-unit id="9387c952373df9470c27016caf452ee055a0a173" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;connect-src&lt;/strong&gt;&lt;/code&gt; directive restricts the URLs which can be loaded using script interfaces. The APIs that are restricted are:</source>
          <target state="translated">HTTP&lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;connect-src&lt;/strong&gt;&lt;/code&gt; 伪指令限制可以使用脚本接口加载的URL。受限制的API是：</target>
        </trans-unit>
        <trans-unit id="a4307301fcd6bb5ccdab9143ff3528885084251b" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;connect&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive restricts the URLs which can be loaded using script interfaces. The APIs that are restricted are:</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;connect&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; 伪指令限制可以使用脚本接口加载的URL。受限制的API是：</target>
        </trans-unit>
        <trans-unit id="182931c21e0e507ac442ba7fad6c85f7022aa1b1" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;default&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive serves as a fallback for the other CSP &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/fetch_directive&quot;&gt;fetch directives&lt;/a&gt;. For each of the following directives that are absent, the user agent will look for the &lt;code&gt;default-src&lt;/code&gt; directive and will use this value for it:</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;default&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; 指令用作其他CSP &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/fetch_directive&quot;&gt;fetch指令&lt;/a&gt;的后备。对于以下每个缺少的指令，用户代理将查找 &lt;code&gt;default-src&lt;/code&gt; 指令并将其使用此值：</target>
        </trans-unit>
        <trans-unit id="df6b0aa2488b0f60a06ea64f5f84252e16a5ba40" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;font&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies valid sources for fonts loaded using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face&quot;&gt;&lt;code&gt;@font-face&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;font&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; 指令为使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face&quot;&gt; &lt;code&gt;@font-face&lt;/code&gt; &lt;/a&gt;加载的字体指定有效来源。</target>
        </trans-unit>
        <trans-unit id="b26fdbf4c8f95b8df3d8b6830742e1c693873add" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;form&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-action&lt;/code&gt; directive restricts the URLs which can be used as the target of a form submissions from a given context.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;form&lt;/strong&gt;&lt;/code&gt; - &lt;code&gt;-action&lt;/code&gt; 指令限制了URL，这些URL可以用作给定上下文中表单提交的目标。</target>
        </trans-unit>
        <trans-unit id="e3702b120d46e550d906d2d9a8d47f7b89a394a2" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;frame-ancestors&lt;/strong&gt;&lt;/code&gt; directive specifies valid parents that may embed a page using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt;&lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt;&lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;frame-ancestors&lt;/strong&gt;&lt;/code&gt; 指令指定了有效的父代，可以使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt; &lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt; &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt; &lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt; &lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt; &lt;/a&gt;嵌入页面。</target>
        </trans-unit>
        <trans-unit id="e7a99a281dc2a7e2980a9a7cde577543fea1d6f5" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;frame-src&lt;/strong&gt;&lt;/code&gt; directive specifies valid sources for nested browsing contexts loading using elements such as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;frame-src&lt;/strong&gt;&lt;/code&gt; 指令使用诸如&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt; &lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; 之类的&lt;/a&gt;元素为嵌套浏览上下文加载指定有效的源。</target>
        </trans-unit>
        <trans-unit id="f35361ac952ed5107a00ab5b6446fbed51185da5" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;media-src&lt;/strong&gt;&lt;/code&gt; directive specifies valid sources for loading media using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt;&lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/a&gt; elements.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;media-src&lt;/strong&gt;&lt;/code&gt; 指令使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt; &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt; &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; &lt;/a&gt;元素指定用于加载媒体的有效源。</target>
        </trans-unit>
        <trans-unit id="39e405945a5f6f3e5caa215c10fb1ba16c926f41" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;media&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies valid sources for loading media using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt;&lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/a&gt; elements.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;media&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; 指令使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt; &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt; &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; &lt;/a&gt;元素指定用于加载媒体的有效源。</target>
        </trans-unit>
        <trans-unit id="a5cc0adb408b4a8f77493eae319c581cf4526353" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;navigate&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-to&lt;/code&gt; directive restricts the URLs to which a document can initiate navigations by any means including &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form&quot;&gt;&lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt;&lt;/a&gt; (if &lt;a href=&quot;form-action&quot;&gt;&lt;code&gt;form-action&lt;/code&gt;&lt;/a&gt; is not specified), &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a&quot;&gt;&lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/location&quot;&gt;&lt;code&gt;window.location&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/open&quot;&gt;&lt;code&gt;window.open&lt;/code&gt;&lt;/a&gt;, etc. This is an enforcement on what navigations this document initiates &lt;strong&gt;not&lt;/strong&gt; on what this document is allowed to navigate to.</source>
          <target state="translated">在HTTP&lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;navigate&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-to&lt;/code&gt; 指令限制到其中一个文件可以发起通过任何方式的导航包括网址&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form&quot;&gt; &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; &lt;/a&gt;（如果&lt;a href=&quot;form-action&quot;&gt; &lt;code&gt;form-action&lt;/code&gt; &lt;/a&gt;未指定），&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a&quot;&gt; &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/location&quot;&gt; &lt;code&gt;window.location&lt;/code&gt; 的&lt;/a&gt;，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/open&quot;&gt; &lt;code&gt;window.open&lt;/code&gt; &lt;/a&gt;等。这是对本文档启动的导航的强制，&lt;strong&gt;而不是&lt;/strong&gt;对本文档允许浏览的内容的强制。</target>
        </trans-unit>
        <trans-unit id="8d107e0a38faf65b9362f0868294c5f1f868d7aa" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;plugin-types&lt;/strong&gt;&lt;/code&gt; directive restricts the set of plugins that can be embedded into a document by limiting the types of resources which can be loaded.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;plugin-types&lt;/strong&gt;&lt;/code&gt; 指令通过限制可以加载的资源类型来限制可以嵌入到文档中的插件集。</target>
        </trans-unit>
        <trans-unit id="f6e050006d74c56b081d711041cc2a29932e1bfd" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;prefetch-src&lt;/strong&gt;&lt;/code&gt; directive specifies valid resources that may be prefetched or prerendered.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;prefetch-src&lt;/strong&gt;&lt;/code&gt; 指令指定可以预取或预呈现的有效资源。</target>
        </trans-unit>
        <trans-unit id="6ad6e328ff3b4fb09016b0d4cd3b23b2ef304500" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;referrer&lt;/strong&gt;&lt;/code&gt; directive used to specify information in the &lt;a href=&quot;../referer&quot;&gt;&lt;code&gt;Referer&lt;/code&gt;&lt;/a&gt; header (with a single &lt;code&gt;r&lt;/code&gt; as this was a typo in the original spec) for links away from a page. This API is deprecated and removed from browsers.</source>
          <target state="translated">在HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;referrer&lt;/strong&gt;&lt;/code&gt; 指令用于指定信息&lt;a href=&quot;../referer&quot;&gt; &lt;code&gt;Referer&lt;/code&gt; 的&lt;/a&gt;头部（单 &lt;code&gt;r&lt;/code&gt; 中的链接，因为这是在原有规范中的一个错字）从页面了。该API已弃用，并已从浏览器中删除。</target>
        </trans-unit>
        <trans-unit id="871ccac3ab2ff9b3690d358a4ea40b08884840e9" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;require-trusted-types-for&lt;/strong&gt;&lt;/code&gt;  directive instructs user agents to control the data passed to DOM XSS sink functions, like &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML&quot;&gt;Element.innerHTML&lt;/a&gt; setter.</source>
          <target state="translated">HTTP&lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;require-trusted-types-for&lt;/strong&gt;&lt;/code&gt; 指令指示用户代理控制传递到DOM XSS接收器功能（例如&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML&quot;&gt;Element.innerHTML&lt;/a&gt; setter）的数据。</target>
        </trans-unit>
        <trans-unit id="8f8670f822879a6c1f70bb6696d4385c9e028089" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;sandbox&lt;/strong&gt;&lt;/code&gt; directive enables a sandbox for the requested resource similar to the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#attr-sandbox&quot;&gt;sandbox&lt;/a&gt;&lt;/code&gt; attribute. It applies restrictions to a page's actions including preventing popups, preventing the execution of plugins and scripts, and enforcing a same-origin policy.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;sandbox&lt;/strong&gt;&lt;/code&gt; 指令可为请求的资源启用沙箱，类似于&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#attr-sandbox&quot;&gt;sandbox&lt;/a&gt;&lt;/code&gt; 属性。它将限制应用于页面的操作，包括阻止弹出窗口，阻止插件和脚本的执行以及执行同源策略。</target>
        </trans-unit>
        <trans-unit id="a54e3f9dc9e10d181fcc5b9d14de91d2158ed49a" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;script-src-attr&lt;/strong&gt;&lt;/code&gt; directive specifies valid sources for JavaScript inline event handlers. This includes only inline script event handlers like &lt;code&gt;onclick&lt;/code&gt;, but not URLs loaded directly into &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt;&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;&lt;/a&gt; elements.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;script-src-attr&lt;/strong&gt;&lt;/code&gt; 指令为JavaScript内联事件处理程序指定了有效的源。这仅包括内联脚本事件处理程序，如 &lt;code&gt;onclick&lt;/code&gt; ，但不包括直接加载到&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt; &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; &lt;/a&gt;元素中的URL 。</target>
        </trans-unit>
        <trans-unit id="63d32345b8cf84239a5bf4892731d98708512218" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;script-src&lt;/strong&gt;&lt;/code&gt; directive specifies valid sources for JavaScript. This includes not only URLs loaded directly into &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt;&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;&lt;/a&gt; elements, but also things like inline script event handlers (&lt;code&gt;onclick&lt;/code&gt;) and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/XSLT&quot;&gt;XSLT stylesheets&lt;/a&gt; which can trigger script execution.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;script-src&lt;/strong&gt;&lt;/code&gt; 指令指定了JavaScript的有效来源。这不仅包括直接加载到&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt; &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; &lt;/a&gt;元素中的URL ，还包括内联脚本事件处理程序（ &lt;code&gt;onclick&lt;/code&gt; ）和可以触发脚本执行的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/XSLT&quot;&gt;XSLT样式表之&lt;/a&gt;类的东西。</target>
        </trans-unit>
        <trans-unit id="ae949c0f5a7694445f0b27c386a8832b1c5e94b2" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;style&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src-attr&lt;/code&gt; directive specifies valid sources for inline styles applied to individual DOM elements.</source>
          <target state="translated">HTTP&lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;style&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src-attr&lt;/code&gt; 指令为应用于单个DOM元素的内联样式指定有效的源。</target>
        </trans-unit>
        <trans-unit id="4e52836f01982774b986b243c0c4f29e000b612f" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;style&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src-elem&lt;/code&gt; directive specifies valid sources for stylesheets &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/style&quot;&gt;&lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt;&lt;/a&gt; elements and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link&quot;&gt;&lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt;&lt;/a&gt; elements with &lt;code&gt;rel=&quot;stylesheet&quot;&lt;/code&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;style&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src-elem&lt;/code&gt; 指令为样式表&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/style&quot;&gt; &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; &lt;/a&gt;元素和具有 &lt;code&gt;rel=&quot;stylesheet&quot;&lt;/code&gt; &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link&quot;&gt; &lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt; &lt;/a&gt;元素指定有效来源。</target>
        </trans-unit>
        <trans-unit id="e2a780dcd99b14cfc49a43bc74102f1ed0b2e3e6" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;style&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies valid sources for stylesheets.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;style&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; 指令指定样式表的有效源。</target>
        </trans-unit>
        <trans-unit id="7b3e13bcd5d8d9f7bcf64acc3459db7ca20c7578" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;trusted-types&lt;/strong&gt;&lt;/code&gt;  directive instructs user agents to restrict the creation of Trusted Types policies - functions that build non-spoofable, typed values intended to be passed to DOM XSS sinks in place of strings.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;trusted-types&lt;/strong&gt;&lt;/code&gt; 指令可指示用户代理限制可信任类型策略的创建-可构建不可欺骗的，类型化的值的功能旨在将其传递给DOM XSS接收器，以代替字符串。</target>
        </trans-unit>
        <trans-unit id="591de896ab33256052ca0797fb955116eff15e90" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;upgrade-insecure-requests&lt;/strong&gt;&lt;/code&gt; directive instructs user agents to treat all of a site's insecure URLs (those served over HTTP) as though they have been replaced with secure URLs (those served over HTTPS). This directive is intended for web sites with large numbers of insecure legacy URLs that need to be rewritten.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;upgrade-insecure-requests&lt;/strong&gt;&lt;/code&gt; 指令指示用户代理将站点的所有不安全URL（通过HTTP服务的URL）视为已被安全URL（通过HTTPS服务的URL）代替。该指令适用于具有大量不安全的旧版URL且需要重写的网站。</target>
        </trans-unit>
        <trans-unit id="32ff6a8bc2363d0ff4f3086755b7248183c5b34b" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;worker-src&lt;/strong&gt;&lt;/code&gt; directive specifies valid sources for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Worker&quot;&gt;&lt;code&gt;Worker&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker&quot;&gt;&lt;code&gt;SharedWorker&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker&quot;&gt;&lt;code&gt;ServiceWorker&lt;/code&gt;&lt;/a&gt; scripts.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;worker-src&lt;/strong&gt;&lt;/code&gt; 指令为&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Worker&quot;&gt; &lt;code&gt;Worker&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker&quot;&gt; &lt;code&gt;SharedWorker&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker&quot;&gt; &lt;code&gt;ServiceWorker&lt;/code&gt; &lt;/a&gt;脚本指定有效的源。</target>
        </trans-unit>
        <trans-unit id="3acbb37620b5c60ffd911d6cef85fd1eada27d24" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;child-src&lt;/code&gt; directive defines the valid sources for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API&quot;&gt;web workers&lt;/a&gt; and nested browsing contexts loaded using elements such as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;. For workers, non-compliant requests are treated as fatal network errors by the user agent.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;child-src&lt;/code&gt; 指令定义了&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API&quot;&gt;Web Worker&lt;/a&gt;的有效源以及使用诸如&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt; &lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; 之类的&lt;/a&gt;元素加载的嵌套浏览上下文。对于工作人员，用户代理将不符合要求的请求视为致命的网络错误。</target>
        </trans-unit>
        <trans-unit id="7f5b4e1965627b7bb6308888f53e91d8ff996658" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;default-src&lt;/code&gt; directive serves as a fallback for the other CSP &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/fetch_directive&quot;&gt;fetch directives&lt;/a&gt;. For each of the following directives that are absent, the user agent looks for the &lt;code&gt;default-src&lt;/code&gt; directive and uses this value for it:</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;default-src&lt;/code&gt; 指令用作其他CSP &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/fetch_directive&quot;&gt;fetch指令&lt;/a&gt;的后备。对于以下缺少的每个伪指令，用户代理将查找 &lt;code&gt;default-src&lt;/code&gt; 伪指令并为其使用该值：</target>
        </trans-unit>
        <trans-unit id="9204eef966021c11aedbb0e9fb96b1228c1de8f2" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;script-src-elem&lt;/code&gt; directive specifies valid sources for JavaScript &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt;&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;&lt;/a&gt; elements, but not inline script event handlers like &lt;code&gt;onclick&lt;/code&gt;.</source>
          <target state="translated">在HTTP&lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;script-src-elem&lt;/code&gt; 为JavaScript指令指定的有效来源&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt; &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; &lt;/a&gt;元素，而不是联脚本事件处理喜欢 &lt;code&gt;onclick&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2aa9970523d0f2da18a413ddfa67a54c01337b6d" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;style-src&lt;/code&gt; directive specifies valid sources for stylesheets.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;style-src&lt;/code&gt; 指令指定样式表的有效来源。</target>
        </trans-unit>
        <trans-unit id="275423427a5662144b985c69ef01612f4d51c0a4" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;: &lt;strong&gt;manifest-src&lt;/strong&gt;&lt;/code&gt; directive specifies which &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Manifest&quot;&gt;manifest&lt;/a&gt; can be applied to the resource.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;: &lt;strong&gt;manifest-src&lt;/strong&gt;&lt;/code&gt; 指令指定可以将哪些&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Manifest&quot;&gt;清单&lt;/a&gt;应用于资源。</target>
        </trans-unit>
        <trans-unit id="5a8c324b7db31bcba8cef085e4b98f52d8cd17a3" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;:&lt;/code&gt;&lt;code&gt;&lt;strong&gt;manifest&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies which &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Manifest&quot;&gt;manifest&lt;/a&gt; can be applied to the resource.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;:&lt;/code&gt; &lt;code&gt;&lt;strong&gt;manifest&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; 指令指定可以将哪些&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Manifest&quot;&gt;清单&lt;/a&gt;应用于资源。</target>
        </trans-unit>
        <trans-unit id="8d10806c81e23539dc0cc263131762383ee75c31" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&lt;strong&gt;img-src&lt;/strong&gt;&lt;/code&gt; directive specifies valid sources of images and favicons.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&lt;strong&gt;img-src&lt;/strong&gt;&lt;/code&gt; 指令指定图像和图标的有效来源。</target>
        </trans-unit>
        <trans-unit id="b239689551cd0c9430aba9321c015f59f5b7ee6a" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&lt;strong&gt;img&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies valid sources of images and favicons.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&lt;strong&gt;img&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; 指令指定图像和图标的有效来源。</target>
        </trans-unit>
        <trans-unit id="f43d22faa65da48c48f2987c23a1ac5f2d7480b1" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&lt;strong&gt;object-src&lt;/strong&gt;&lt;/code&gt; directive specifies valid sources for the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt;&lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt;&lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt;&lt;/a&gt; elements.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&lt;strong&gt;object-src&lt;/strong&gt;&lt;/code&gt; 指令为&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt; &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt; &lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt; &lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt; &lt;/a&gt;元素指定有效的源。</target>
        </trans-unit>
        <trans-unit id="4db12171daec1cecdac720828f51ca0a57d2ce24" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&lt;strong&gt;object&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies valid sources for the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt;&lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt;&lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt;&lt;/a&gt; elements.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&lt;strong&gt;object&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; 指令为&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt; &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt; &lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt; &lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt; &lt;/a&gt;元素指定有效的源。</target>
        </trans-unit>
        <trans-unit id="a75713e06f850d30f3c1d3897dfbb65c817d0a9c" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&lt;strong&gt;require-sri-for&lt;/strong&gt;&lt;/code&gt; directive instructs the client to require the use of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity&quot;&gt;Subresource Integrity&lt;/a&gt; for scripts or styles on the page.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&lt;strong&gt;require-sri-for&lt;/strong&gt;&lt;/code&gt; 指令指示客户端要求对页面上的脚本或样式使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity&quot;&gt;Subresource Integrity&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a32f782eaaf1368e46240e1ae4c440922d0f70d0" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;base-uri&lt;/code&gt; directive restricts the URLs which can be used in a document's &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base&quot;&gt;&lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt;&lt;/a&gt; element. If this value is absent, then any URI is allowed. If this directive is absent, the user agent will use the value in the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base&quot;&gt;&lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt;&lt;/a&gt; element.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;base-uri&lt;/code&gt; 指令限制可以在文档的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base&quot;&gt; &lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt; &lt;/a&gt;元素中使用的URL 。如果不存在此值，则允许任何URI。如果不存在此伪指令，则用户代理将使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base&quot;&gt; &lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt; &lt;/a&gt;元素中的值。</target>
        </trans-unit>
        <trans-unit id="e0361bbd3e19dd4db920260e46f1803df2efaa1a" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;accelerometer&lt;/code&gt; directive controls whether the current document is allowed to gather information about the acceleration of the device through the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Accelerometer&quot;&gt;&lt;code&gt;Accelerometer&lt;/code&gt;&lt;/a&gt; interface.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;标头 &lt;code&gt;accelerometer&lt;/code&gt; 指令控制是否允许当前文档通过&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Accelerometer&quot;&gt; &lt;code&gt;Accelerometer&lt;/code&gt; &lt;/a&gt;接口收集有关设备加速的信息。</target>
        </trans-unit>
        <trans-unit id="92c66228b38d0470e96db98a40225a18c2d3231a" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;ambient-light-sensor&lt;/code&gt; directive controls whether the current document is allowed to gather information about the amount of light in the environment around the device through the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/AmbientLightSensor&quot;&gt;&lt;code&gt;AmbientLightSensor&lt;/code&gt;&lt;/a&gt; interface.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;标头environment &lt;code&gt;ambient-light-sensor&lt;/code&gt; 指令控制是否允许当前文档通过&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/AmbientLightSensor&quot;&gt; &lt;code&gt;AmbientLightSensor&lt;/code&gt; &lt;/a&gt;接口收集有关设备周围环境中的光量的信息。</target>
        </trans-unit>
        <trans-unit id="358c131c1d5a8c89c254e16cfb1b9e90fee71186" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;autoplay&lt;/code&gt; directive controls whether the current document is allowed to autoplay media requested through the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement&quot;&gt;&lt;code&gt;HTMLMediaElement&lt;/code&gt;&lt;/a&gt; interface. When this policy is enabled and there were no user gestures, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/play&quot;&gt;&lt;code&gt;HTMLMediaElement.play()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/DOMException&quot;&gt;&lt;code&gt;DOMException&lt;/code&gt;&lt;/a&gt;. The &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio#attr-autoplay&quot;&gt;autoplay&lt;/a&gt;&lt;/code&gt; attribute on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt;&lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/a&gt; elements will be ignored.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;标头的 &lt;code&gt;autoplay&lt;/code&gt; 指令控制是否允许当前文档自动播放通过&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement&quot;&gt; &lt;code&gt;HTMLMediaElement&lt;/code&gt; &lt;/a&gt;接口请求的媒体。启用此策略并且没有用户手势时，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/play&quot;&gt; &lt;code&gt;HTMLMediaElement.play()&lt;/code&gt; &lt;/a&gt;返回的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt;将拒绝，并带有&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/DOMException&quot;&gt; &lt;code&gt;DOMException&lt;/code&gt; &lt;/a&gt;。&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt; &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt; &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; &lt;/a&gt;元素上的 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio#attr-autoplay&quot;&gt;autoplay&lt;/a&gt;&lt;/code&gt; 属性将被忽略。</target>
        </trans-unit>
        <trans-unit id="01c9ca551ef322fcef92f79b3a236ae1ba63f558" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;autoplay&lt;/code&gt; directive controls whether the current document is allowed to autoplay media requested through the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement&quot;&gt;&lt;code&gt;HTMLMediaElement&lt;/code&gt;&lt;/a&gt; interface. When this policy is enabled and there were no user gestures, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/play&quot;&gt;&lt;code&gt;HTMLMediaElement.play()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;code&gt;DOMException&lt;/code&gt;. The &lt;code&gt;autoplay&lt;/code&gt; attribute on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt;&lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/a&gt; elements will be ignored.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;标头的 &lt;code&gt;autoplay&lt;/code&gt; 指令控制是否允许当前文档自动播放通过&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement&quot;&gt; &lt;code&gt;HTMLMediaElement&lt;/code&gt; &lt;/a&gt;接口请求的媒体。启用此策略并且没有用户手势时，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/play&quot;&gt; &lt;code&gt;HTMLMediaElement.play()&lt;/code&gt; &lt;/a&gt;返回的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt;将拒绝，并带有 &lt;code&gt;DOMException&lt;/code&gt; 。&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt; &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt; &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; &lt;/a&gt;元素上的 &lt;code&gt;autoplay&lt;/code&gt; 属性将被忽略。</target>
        </trans-unit>
        <trans-unit id="9bd2e515d62f7d6ede21b6f102d6e75bcfdc2806" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;battery&lt;/code&gt; directive controls whether the current document is allowed to gather information about the battery of the device through the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/BatteryManager&quot;&gt;&lt;code&gt;BatteryManager&lt;/code&gt;&lt;/a&gt; interface obtained via &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/getBattery&quot;&gt;&lt;code&gt;Navigator.getBattery()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;标头 &lt;code&gt;battery&lt;/code&gt; 指令控制是否允许当前文档通过通过&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/getBattery&quot;&gt; &lt;code&gt;Navigator.getBattery()&lt;/code&gt; &lt;/a&gt;获得的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/BatteryManager&quot;&gt; &lt;code&gt;BatteryManager&lt;/code&gt; &lt;/a&gt;接口收集有关设备电池的信息。</target>
        </trans-unit>
        <trans-unit id="7087babf47c5844e7ac3510edec835b831437673" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;camera&lt;/code&gt; directive controls whether the current document is allowed to use video input devices. When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia&quot;&gt;&lt;code&gt;MediaDevices.getUserMedia()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/NotAllowedError&quot;&gt;&lt;code&gt;NotAllowedError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;标头 &lt;code&gt;camera&lt;/code&gt; 指令控制是否允许当前文档使用视频输入设备。启用此策略后，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia&quot;&gt; &lt;code&gt;MediaDevices.getUserMedia()&lt;/code&gt; &lt;/a&gt;返回的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt;将拒绝，并带有&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/NotAllowedError&quot;&gt; &lt;code&gt;NotAllowedError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="89ab43068a1ce03c2c700695396807b764653f4c" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;camera&lt;/code&gt; directive controls whether the current document is allowed to use video input devices. When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia&quot;&gt;&lt;code&gt;MediaDevices.getUserMedia()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;code&gt;NotAllowedError&lt;/code&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;标头 &lt;code&gt;camera&lt;/code&gt; 指令控制是否允许当前文档使用视频输入设备。启用此策略后，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia&quot;&gt; &lt;code&gt;MediaDevices.getUserMedia()&lt;/code&gt; &lt;/a&gt;返回的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt;将拒绝，并带有 &lt;code&gt;NotAllowedError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a38d3aba5839b81049ae1c111db31f4dd2359f9e" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;display-capture&lt;/code&gt; directive controls whether or not the document is permitted to use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Screen_Capture_API&quot;&gt;Screen Capture API&lt;/a&gt;, i.e.,&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getDisplayMedia&quot;&gt;&lt;code&gt;getDisplayMedia()&lt;/code&gt;&lt;/a&gt; to capture the screen's contents.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;标头 &lt;code&gt;display-capture&lt;/code&gt; 指令控制是否允许文档使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Screen_Capture_API&quot;&gt;Screen Capture API&lt;/a&gt;，即&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getDisplayMedia&quot;&gt; &lt;code&gt;getDisplayMedia()&lt;/code&gt; &lt;/a&gt;来捕获屏幕内容。</target>
        </trans-unit>
        <trans-unit id="0509b709eb9c12fa1d36b479d880843a32939bb2" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;document-domain&lt;/code&gt; directive controls whether the current document is allowed to set &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/domain&quot;&gt;&lt;code&gt;document.domain&lt;/code&gt;&lt;/a&gt;. When this policy is enabled, attempting to set &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/domain&quot;&gt;&lt;code&gt;document.domain&lt;/code&gt;&lt;/a&gt; will fail and cause a &lt;code&gt;SecurityError&lt;/code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/DOMException&quot;&gt;&lt;code&gt;DOMException&lt;/code&gt;&lt;/a&gt; to be be thrown.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;标头 &lt;code&gt;document-domain&lt;/code&gt; 指令控制是否允许当前文档设置&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/domain&quot;&gt; &lt;code&gt;document.domain&lt;/code&gt; &lt;/a&gt;。启用此策略后，尝试设置&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/domain&quot;&gt; &lt;code&gt;document.domain&lt;/code&gt; &lt;/a&gt;将会失败并导致引发 &lt;code&gt;SecurityError&lt;/code&gt; &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/DOMException&quot;&gt; &lt;code&gt;DOMException&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="db2a12cedfc96871f58d6b87b88cf7641d46244e" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;encrypted-media&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Encrypted_Media_Extensions_API&quot;&gt;Encrypted Media Extensions&lt;/a&gt; API (EME). When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/requestMediaKeySystemAccess&quot;&gt;&lt;code&gt;Navigator.requestMediaKeySystemAccess()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/DOMException&quot;&gt;&lt;code&gt;DOMException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;标头 &lt;code&gt;encrypted-media&lt;/code&gt; 伪指令控制是否允许当前文档使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Encrypted_Media_Extensions_API&quot;&gt;Encrypted Media Extensions&lt;/a&gt; API（EME）。启用此策略后，由&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/requestMediaKeySystemAccess&quot;&gt; &lt;code&gt;Navigator.requestMediaKeySystemAccess()&lt;/code&gt; &lt;/a&gt;返回的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt;将拒绝，并带有&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/DOMException&quot;&gt; &lt;code&gt;DOMException&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c66dd6d4d4a75699b185decdfad8e45e19e0002d" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;encrypted-media&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Encrypted_Media_Extensions_API&quot;&gt;Encrypted Media Extensions&lt;/a&gt; API (EME). When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/requestMediaKeySystemAccess&quot;&gt;&lt;code&gt;Navigator.requestMediaKeySystemAccess()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;code&gt;DOMException&lt;/code&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;标头 &lt;code&gt;encrypted-media&lt;/code&gt; 指令控制是否允许当前文档使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Encrypted_Media_Extensions_API&quot;&gt;Encrypted Media Extensions&lt;/a&gt; API（EME）。启用此策略后，由&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/requestMediaKeySystemAccess&quot;&gt; &lt;code&gt;Navigator.requestMediaKeySystemAccess()&lt;/code&gt; &lt;/a&gt;返回的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt;将拒绝，并带有 &lt;code&gt;DOMException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4e8d5d79df5028bcf829983040e4f5d620f67f63" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;fullscreen&lt;/code&gt; directive controls whether the current document is allowed to use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Element/requestFullScreen&quot;&gt;&lt;code&gt;Element.requestFullScreen()&lt;/code&gt;&lt;/a&gt;. When this policy is enabled, the returned &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; rejects with a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;标头 &lt;code&gt;fullscreen&lt;/code&gt; 指令控制是否允许当前文档使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Element/requestFullScreen&quot;&gt; &lt;code&gt;Element.requestFullScreen()&lt;/code&gt; &lt;/a&gt;。启用此策略后，返回的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; 会&lt;/a&gt;拒绝并带有&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cb70b85868a9918e7c850de1c73663ec03ac5340" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;geolocation&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation&quot;&gt;&lt;code&gt;Geolocation&lt;/code&gt;&lt;/a&gt; Interface. When this policy is enabled, calls to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/getCurrentPosition&quot;&gt;&lt;code&gt;getCurrentPosition()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/watchPosition&quot;&gt;&lt;code&gt;watchPosition()&lt;/code&gt;&lt;/a&gt; will cause those functions' callbacks to be invoked with a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PositionError&quot;&gt;&lt;code&gt;PositionError&lt;/code&gt;&lt;/a&gt; code of &lt;code&gt;PERMISSION_DENIED&lt;/code&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;标头 &lt;code&gt;geolocation&lt;/code&gt; 指令控制是否允许当前文档使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation&quot;&gt; &lt;code&gt;Geolocation&lt;/code&gt; &lt;/a&gt;接口。启用此策略后，对&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/getCurrentPosition&quot;&gt; &lt;code&gt;getCurrentPosition()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/watchPosition&quot;&gt; &lt;code&gt;watchPosition()&lt;/code&gt; 的&lt;/a&gt;调用将使这些函数的回调以 &lt;code&gt;PERMISSION_DENIED&lt;/code&gt; 的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PositionError&quot;&gt; &lt;code&gt;PositionError&lt;/code&gt; &lt;/a&gt;代码进行调用。</target>
        </trans-unit>
        <trans-unit id="d1aa24dbbd3715af81f21828a56fabf5ec110953" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;gyroscope&lt;/code&gt; directive controls whether the current document is allowed to gather information about the orientation of the device through the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Gyroscope&quot;&gt;&lt;code&gt;Gyroscope&lt;/code&gt;&lt;/a&gt; interface.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;标头 &lt;code&gt;gyroscope&lt;/code&gt; 指令控制是否允许当前文档通过&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Gyroscope&quot;&gt; &lt;code&gt;Gyroscope&lt;/code&gt; &lt;/a&gt;界面收集有关设备方向的信息。</target>
        </trans-unit>
        <trans-unit id="85ff5966dce2b9c7b7600a4d4c06b6e4b170f277" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;layout-animations&lt;/code&gt; directive controls whether the current document is allowed to show layout animations.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;标头 &lt;code&gt;layout-animations&lt;/code&gt; 指令控制是否允许当前文档显示布局动画。</target>
        </trans-unit>
        <trans-unit id="79581f7e39deb619df4e34954f818f674b43f16f" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;legacy-image-formats&lt;/code&gt; directive controls whether the current document is allowed to display images in legacy formats.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;标头 &lt;code&gt;legacy-image-formats&lt;/code&gt; 指令控制是否允许当前文档以旧格式显示图像。</target>
        </trans-unit>
        <trans-unit id="dcb5ebff50a1c299f3cfff78c80e0f15d5569925" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;magnetometer&lt;/code&gt; directive controls whether the current document is allowed to gather information about the orientation of the device through the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Magnetometer&quot;&gt;&lt;code&gt;Magnetometer&lt;/code&gt;&lt;/a&gt; interface.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;标头 &lt;code&gt;magnetometer&lt;/code&gt; 指令控制是否允许当前文档通过&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Magnetometer&quot;&gt; &lt;code&gt;Magnetometer&lt;/code&gt; &lt;/a&gt;界面收集有关设备方向的信息。</target>
        </trans-unit>
        <trans-unit id="d88583ce1eab6212205a0ce4ec5269a6f045f6b3" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;microphone&lt;/code&gt; directive controls whether the current document is allowed to use audio input devices. When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia&quot;&gt;&lt;code&gt;MediaDevices.getUserMedia()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;code&gt;NotAllowedError&lt;/code&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;标头 &lt;code&gt;microphone&lt;/code&gt; 指令控制是否允许当前文档使用音频输入设备。启用此策略后，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia&quot;&gt; &lt;code&gt;MediaDevices.getUserMedia()&lt;/code&gt; &lt;/a&gt;返回的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt;将拒绝，并带有 &lt;code&gt;NotAllowedError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f61a9280d76cca41de0c10b1bb571562297d206c" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;midi&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_MIDI_API&quot;&gt;Web MIDI API&lt;/a&gt;. When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/requestMIDIAccess&quot;&gt;&lt;code&gt;Navigator.requestMIDIAccess()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;code&gt;DOMException&lt;/code&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;标头 &lt;code&gt;midi&lt;/code&gt; 指令控制是否允许当前文档使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_MIDI_API&quot;&gt;Web MIDI API&lt;/a&gt;。启用此策略后，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/requestMIDIAccess&quot;&gt; &lt;code&gt;Navigator.requestMIDIAccess()&lt;/code&gt; &lt;/a&gt;返回的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt;将以 &lt;code&gt;DOMException&lt;/code&gt; 拒绝。</target>
        </trans-unit>
        <trans-unit id="7143f5b43341ab71af365409875146a8699bd3ea" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;oversized-images&lt;/code&gt; directive controls whether the current document is allowed to download and display large images.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;标头 &lt;code&gt;oversized-images&lt;/code&gt; 指令控制是否允许当前文档下载和显示大图像。</target>
        </trans-unit>
        <trans-unit id="ad49b71ef86ec5410e8de76cba85903aa7fec02d" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;payment&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Payment_Request_API&quot;&gt;Payment Request API&lt;/a&gt;. When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PaymentRequest&quot;&gt;&lt;code&gt;PaymentRequest()&lt;/code&gt;&lt;/a&gt; constructor will throw a &lt;code&gt;SecurityError&lt;/code&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;标头 &lt;code&gt;payment&lt;/code&gt; 指令控制是否允许当前文档使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Payment_Request_API&quot;&gt;Payment Request API&lt;/a&gt;。启用此策略后，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PaymentRequest&quot;&gt; &lt;code&gt;PaymentRequest()&lt;/code&gt; &lt;/a&gt;构造函数将抛出 &lt;code&gt;SecurityError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1bf49ec28a205e1ed0b001dfbdb9aa642280ff0c" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;picture-in-picture&lt;/code&gt; directive controls whether the current document is allowed to play a video in a Picture-in-Picture mode via the corresponding API.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;标头&amp;ldquo; &lt;code&gt;picture-in-picture&lt;/code&gt; 指令控制是否允许当前文档通过相应的API以&amp;ldquo;画中画&amp;rdquo;模式播放视频。</target>
        </trans-unit>
        <trans-unit id="2ebcad6e4fbff3f317a76c00d82e77cbe034d342" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;publickey-credentials-get&lt;/code&gt; directive controls whether the current document is allowed to access &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Authentication_API&quot;&gt;Web Authentcation API&lt;/a&gt; to create new public-key credentials, i.e, via &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/CredentialsContainer/get&quot;&gt;&lt;code&gt;navigator.credentials.get({publicKey: ..., ...})&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;标头 &lt;code&gt;publickey-credentials-get&lt;/code&gt; 指令控制是否允许当前文档访问&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Authentication_API&quot;&gt;Web身份验证API&lt;/a&gt;来创建新的公共密钥凭据，即通过&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/CredentialsContainer/get&quot;&gt; &lt;code&gt;navigator.credentials.get({publicKey: ..., ...})&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6f5bf4e9f3fed1765343fd59a9718f4cd6d7d27d" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;screen-wake-lock&lt;/code&gt; directive controls whether the current document is allowed to use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Screen_Wake_Lock_API&quot;&gt;Screen Wake Lock API&lt;/a&gt; to indicate that device should not dim or turn off the screen.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;标头 &lt;code&gt;screen-wake-lock&lt;/code&gt; 指令控制是否允许当前文档使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Screen_Wake_Lock_API&quot;&gt;Screen Wake Lock API&lt;/a&gt;来指示设备不应变暗或关闭屏幕。</target>
        </trans-unit>
        <trans-unit id="d480f24830d984d0930580ca8ddada9de45700d1" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;sync-xhr&lt;/code&gt; directive controls whether the current document is allowed to make synchronous &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt; requests.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;标头 &lt;code&gt;sync-xhr&lt;/code&gt; 指令控制是否允许当前文档进行同步&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; &lt;/a&gt;请求。</target>
        </trans-unit>
        <trans-unit id="2a58ad5a409b3b1c3a41e1e839795597dc6204dc" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;unoptimized-images&lt;/code&gt; directive controls whether the current document is allowed to download and display unoptimized images.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;标头 &lt;code&gt;unoptimized-images&lt;/code&gt; 指令控制是否允许当前文档下载和显示未优化的图像。</target>
        </trans-unit>
        <trans-unit id="d80682ef1147e80bdbff00f43c45c04f77992134" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;unsized-media&lt;/code&gt; directive controls whether the current document is allowed to change the size of media elements after the initial layout is complete.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;标头 &lt;code&gt;unsized-media&lt;/code&gt; 指令控制在初始布局完成后是否允许当前文档更改媒体元素的大小。</target>
        </trans-unit>
        <trans-unit id="3ad639cf0153cfd80980b0affb3cc2e1e990de76" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;vibrate&lt;/code&gt;  directive controls whether the current document is allowed to trigger device vibrations via &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/vibrate&quot;&gt;&lt;code&gt;Navigator.vibrate()&lt;/code&gt;&lt;/a&gt; method of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Vibration_API&quot;&gt;Vibration API&lt;/a&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;标头 &lt;code&gt;vibrate&lt;/code&gt; 指令控制是否允许当前文档通过&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Vibration_API&quot;&gt;Vibration API的&lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/vibrate&quot;&gt; &lt;code&gt;Navigator.vibrate()&lt;/code&gt; &lt;/a&gt;方法触发设备振动。</target>
        </trans-unit>
        <trans-unit id="596ebd10a4b879fc3f494e6c070eefbc8b1b78da" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;vr&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebVR_API&quot;&gt;WebVR API&lt;/a&gt;. When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/getVRDisplays&quot;&gt;&lt;code&gt;Navigator.getVRDisplays()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/DOMException&quot;&gt;&lt;code&gt;DOMException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;标头 &lt;code&gt;vr&lt;/code&gt; 指令控制是否允许当前文档使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebVR_API&quot;&gt;WebVR API&lt;/a&gt;。启用此策略后，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/getVRDisplays&quot;&gt; &lt;code&gt;Navigator.getVRDisplays()&lt;/code&gt; &lt;/a&gt;返回的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt;将以&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/DOMException&quot;&gt; &lt;code&gt;DOMException&lt;/code&gt; &lt;/a&gt;拒绝。</target>
        </trans-unit>
        <trans-unit id="cf81d231c67dd1b00b85de64c8fcc4e2241cad31" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;vr&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebVR_API&quot;&gt;WebVR API&lt;/a&gt;. When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/getVRDisplays&quot;&gt;&lt;code&gt;Navigator.getVRDisplays()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;code&gt;DOMException&lt;/code&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;标头 &lt;code&gt;vr&lt;/code&gt; 指令控制是否允许当前文档使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebVR_API&quot;&gt;WebVR API&lt;/a&gt;。启用此策略后，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/getVRDisplays&quot;&gt; &lt;code&gt;Navigator.getVRDisplays()&lt;/code&gt; &lt;/a&gt;返回的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt;将以 &lt;code&gt;DOMException&lt;/code&gt; 拒绝。</target>
        </trans-unit>
        <trans-unit id="15c0f9c5a8e9e08ad03923f24381554ed8b9ab1c" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;wake-lock&lt;/code&gt; directive controls whether the current document is allowed to use Wake Lock API to indicate that device should not enter power-saving mode.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;标头 &lt;code&gt;wake-lock&lt;/code&gt; 指令控制是否允许当前文档使用唤醒锁定API来指示设备不应进入节能模式。</target>
        </trans-unit>
        <trans-unit id="269d13c10993281fbc573c770f836b44bc5f308a" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;web-share&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/share&quot;&gt;&lt;code&gt;Navigator.share()&lt;/code&gt;&lt;/a&gt; method of the Web Share API to share text, links, images, and other content to arbitrary destinations of the user's choice.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;标头 &lt;code&gt;web-share&lt;/code&gt; 指令控制是否允许当前文档使用Web Share API的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/share&quot;&gt; &lt;code&gt;Navigator.share()&lt;/code&gt; &lt;/a&gt;方法将文本，链接，图像和其他内容共享到用户选择的任意目的地。</target>
        </trans-unit>
        <trans-unit id="62dced3e4a986bc5373d1a7961ad28c776d2c977" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;xr-spatial-tracking&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebXR_Device_API&quot;&gt;WebXR Device API&lt;/a&gt;. This policy controls whether &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XR/requestSession&quot;&gt;&lt;code&gt;navigator.xr.requestSession()&lt;/code&gt;&lt;/a&gt; can return &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XRSession&quot;&gt;&lt;code&gt;XRSession&lt;/code&gt;&lt;/a&gt; that requires spatial tracking and whether user agent can indicate support for sessions supporting spatial tracking via &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XR/isSessionSupported&quot;&gt;&lt;code&gt;navigator.xr.isSessionSupported()&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/devicechange&quot;&gt;devicechange&lt;/a&gt;&lt;/code&gt; event on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/xr&quot;&gt;&lt;code&gt;navigator.xr&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;标头 &lt;code&gt;xr-spatial-tracking&lt;/code&gt; 指令控制是否允许当前文档使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebXR_Device_API&quot;&gt;WebXR Device API&lt;/a&gt;。此策略控制&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XR/requestSession&quot;&gt; &lt;code&gt;navigator.xr.requestSession()&lt;/code&gt; &lt;/a&gt;是否可以返回需要空间跟踪的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XRSession&quot;&gt; &lt;code&gt;XRSession&lt;/code&gt; &lt;/a&gt;，以及用户代理是否可以通过&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XR/isSessionSupported&quot;&gt; &lt;code&gt;navigator.xr.isSessionSupported()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/xr&quot;&gt; &lt;code&gt;navigator.xr&lt;/code&gt; &lt;/a&gt;对象上的 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/devicechange&quot;&gt;devicechange&lt;/a&gt;&lt;/code&gt; 事件指示对支持空间跟踪的会话的支持。</target>
        </trans-unit>
        <trans-unit id="a4136ce714258747e9ae7bb826711d2f7370051e" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header field's &lt;code&gt;payment&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Payment_Request_API&quot;&gt;Payment Request API&lt;/a&gt;. When this policy is disabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PaymentRequest&quot;&gt;&lt;code&gt;PaymentRequest()&lt;/code&gt;&lt;/a&gt; constructor will throw a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/DOMException#exception-SyntaxError&quot;&gt;&lt;code&gt;SyntaxError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在HTTP&lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;报头字段的 &lt;code&gt;payment&lt;/code&gt; 指令控制是否将当前文档被允许使用的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Payment_Request_API&quot;&gt;付款申请API&lt;/a&gt;。禁用此策略后，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PaymentRequest&quot;&gt; &lt;code&gt;PaymentRequest()&lt;/code&gt; &lt;/a&gt;构造函数将抛出&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/DOMException#exception-SyntaxError&quot;&gt; &lt;code&gt;SyntaxError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="085032760c08ad9b9fdf7e3304ad0c84d9aeabf7" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header usb directive controls whether the current document is allowed to use the WebUSB API.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;标头usb指令控制是否允许当前文档使用WebUSB API。</target>
        </trans-unit>
        <trans-unit id="90bd59abf141ac2acd0d6eb93603dfbb20ca13bb" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;block-all-mixed-content&lt;/strong&gt;&lt;/code&gt; directive prevents loading any assets using HTTP when the page is loaded using HTTPS.</source>
          <target state="translated">当使用HTTPS加载页面时，HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;block-all-mixed-content&lt;/strong&gt;&lt;/code&gt; 指令可防止使用HTTP加载任何资产。</target>
        </trans-unit>
        <trans-unit id="2c130ba07e36557d606dab5e0daeea1174e0f829" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;connect&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive restricts the URLs which can be loaded using script interfaces. The APIs that are restricted are:</source>
          <target state="translated">HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;connect&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; 伪指令限制可以使用脚本接口加载的URL。受限制的API是：</target>
        </trans-unit>
        <trans-unit id="f9e44e9310d4af0da6d15e0f9e8b89d123612c88" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;default&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive serves as a fallback for the other CSP &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/fetch_directive&quot;&gt;fetch directives&lt;/a&gt;. For each of the following directives that are absent, the user agent will look for the &lt;code&gt;default-src&lt;/code&gt; directive and will use this value for it:</source>
          <target state="translated">HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;default&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; 指令用作其他CSP &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/fetch_directive&quot;&gt;fetch指令&lt;/a&gt;的后备。对于以下每个缺少的指令，用户代理将查找 &lt;code&gt;default-src&lt;/code&gt; 指令并将其使用此值：</target>
        </trans-unit>
        <trans-unit id="872a0ce0f866c4f403e5c4fdabdba2ac75e64283" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;font&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies valid sources for fonts loaded using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face&quot;&gt;&lt;code&gt;@font-face&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;font&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; 指令为使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face&quot;&gt; &lt;code&gt;@font-face&lt;/code&gt; &lt;/a&gt;加载的字体指定有效来源。</target>
        </trans-unit>
        <trans-unit id="89db1b08f92d8384d90536ecc2f476ece38912e3" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;form&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-action&lt;/code&gt; directive restricts the URLs which can be used as the target of a form submissions from a given context.</source>
          <target state="translated">HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;form&lt;/strong&gt;&lt;/code&gt; - &lt;code&gt;-action&lt;/code&gt; 指令限制了URL，这些URL可以用作给定上下文中表单提交的目标。</target>
        </trans-unit>
        <trans-unit id="53e746d6be4fd9b5eb3832de56d4365f491df6d6" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;frame-ancestors&lt;/strong&gt;&lt;/code&gt; directive specifies valid parents that may embed a page using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt;&lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt;&lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;frame-ancestors&lt;/strong&gt;&lt;/code&gt; 指令指定了有效的父代，可以使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt; &lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt; &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt; &lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt; &lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt; &lt;/a&gt;嵌入页面。</target>
        </trans-unit>
        <trans-unit id="60434b7f567fe8e897910e8b6a67bd2318a07eda" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;frame-src&lt;/strong&gt;&lt;/code&gt; directive specifies valid sources for nested browsing contexts loading using elements such as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;frame-src&lt;/strong&gt;&lt;/code&gt; 指令使用诸如&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt; &lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; 之类的&lt;/a&gt;元素为嵌套浏览上下文加载指定有效的源。</target>
        </trans-unit>
        <trans-unit id="af2c302ddc10d3d222e0a67e09b8d5d05e052366" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;media&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies valid sources for loading media using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt;&lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/a&gt; elements.</source>
          <target state="translated">HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;media&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; 指令使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt; &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt; &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; &lt;/a&gt;元素指定用于加载媒体的有效源。</target>
        </trans-unit>
        <trans-unit id="3d40cffb60b43134b32f0810a5ed2a290fe665f6" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;plugin-types&lt;/strong&gt;&lt;/code&gt; directive restricts the set of plugins that can be embedded into a document by limiting the types of resources which can be loaded.</source>
          <target state="translated">HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;plugin-types&lt;/strong&gt;&lt;/code&gt; 指令通过限制可以加载的资源类型来限制可以嵌入到文档中的插件集。</target>
        </trans-unit>
        <trans-unit id="bdd0798eaf4df1ffabbf8a0c8d7aa4c0dbd9e69b" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;referrer&lt;/strong&gt;&lt;/code&gt; directive used to specify information in the &lt;a href=&quot;referer&quot;&gt;&lt;code&gt;Referer&lt;/code&gt;&lt;/a&gt; header (with a single &lt;code&gt;r&lt;/code&gt; as this was a typo in the original spec) for links away from a page. This API is deprecated and removed from browsers.</source>
          <target state="translated">HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;referrer&lt;/strong&gt;&lt;/code&gt; 指令，用于指定&lt;a href=&quot;referer&quot;&gt; &lt;code&gt;Referer&lt;/code&gt; &lt;/a&gt;标头中的信息（在原始规范中使用单个 &lt;code&gt;r&lt;/code&gt; 表示错字），以指定远离页面的链接。该API已弃用，并已从浏览器中删除。</target>
        </trans-unit>
        <trans-unit id="befd663ba9deb24fd4ec2918a5d6109d2636a2d4" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;sandbox&lt;/strong&gt;&lt;/code&gt; directive enables a sandbox for the requested resource similar to the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#attr-sandbox&quot;&gt;sandbox&lt;/a&gt;&lt;/code&gt; attribute. It applies restrictions to a page's actions including preventing popups, preventing the execution of plugins and scripts, and enforcing a same-origin policy.</source>
          <target state="translated">HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;sandbox&lt;/strong&gt;&lt;/code&gt; 指令可为请求的资源启用沙箱，类似于&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#attr-sandbox&quot;&gt;sandbox&lt;/a&gt;&lt;/code&gt; 属性。它对页面的操作施加了限制，包括防止弹出窗口，阻止插件和脚本的执行以及执行同源策略。</target>
        </trans-unit>
        <trans-unit id="5b8d334a3bce170c8993d25e4d184932264ac72f" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;script-src&lt;/strong&gt;&lt;/code&gt; directive specifies valid sources for JavaScript. This includes not only URLs loaded directly into &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt;&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;&lt;/a&gt; elements, but also things like inline script event handlers (&lt;code&gt;onclick&lt;/code&gt;) and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/XSLT&quot;&gt;XSLT stylesheets&lt;/a&gt; which can trigger script execution.</source>
          <target state="translated">HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;script-src&lt;/strong&gt;&lt;/code&gt; 指令指定了JavaScript的有效来源。这不仅包括直接加载到&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt; &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; &lt;/a&gt;元素中的URL ，还包括内联脚本事件处理程序（ &lt;code&gt;onclick&lt;/code&gt; ）和可以触发脚本执行的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/XSLT&quot;&gt;XSLT样式表之&lt;/a&gt;类的东西。</target>
        </trans-unit>
        <trans-unit id="8cef37884cea47d641cdd47c4c37fa6b8ac6254c" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;style&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies valid sources for sources for stylesheets.</source>
          <target state="translated">HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;style&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; 指令为样式表的来源指定有效来源。</target>
        </trans-unit>
        <trans-unit id="27cf15a50bbcd9352999ad2ec374352073190e0d" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;style&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies valid sources for stylesheets.</source>
          <target state="translated">HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;style&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; 指令指定样式表的有效来源。</target>
        </trans-unit>
        <trans-unit id="8a7e1c437a2a4b57d25b681153a76fdfe0cd58a0" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;upgrade-insecure-requests&lt;/strong&gt;&lt;/code&gt; directive instructs user agents to treat all of a site's insecure URLs (those served over HTTP) as though they have been replaced with secure URLs (those served over HTTPS). This directive is intended for web sites with large numbers of insecure legacy URLs that need to be rewritten.</source>
          <target state="translated">HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;upgrade-insecure-requests&lt;/strong&gt;&lt;/code&gt; 指令指示用户代理将站点的所有不安全URL（通过HTTP服务的URL）视为已被安全URL（通过HTTPS服务的URL）代替。该指令适用于具有大量不安全的旧版URL且需要重写的网站。</target>
        </trans-unit>
        <trans-unit id="c6470e7d04b8abe1f65b75c4d51906723a206d5d" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;worker-src&lt;/strong&gt;&lt;/code&gt; directive specifies valid sources for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Worker&quot;&gt;&lt;code&gt;Worker&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker&quot;&gt;&lt;code&gt;SharedWorker&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker&quot;&gt;&lt;code&gt;ServiceWorker&lt;/code&gt;&lt;/a&gt; scripts.</source>
          <target state="translated">HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;（CSP） &lt;code&gt;&lt;strong&gt;worker-src&lt;/strong&gt;&lt;/code&gt; 指令为&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Worker&quot;&gt; &lt;code&gt;Worker&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker&quot;&gt; &lt;code&gt;SharedWorker&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker&quot;&gt; &lt;code&gt;ServiceWorker&lt;/code&gt; &lt;/a&gt;脚本指定有效的源。</target>
        </trans-unit>
        <trans-unit id="65fa53659e196a5f364ee4db69fef14fde746c4b" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;:&lt;/code&gt;&lt;code&gt;&lt;strong&gt;manifest&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies which &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Manifest&quot;&gt;manifest&lt;/a&gt; can be applied to the resource.</source>
          <target state="translated">HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;:&lt;/code&gt; &lt;code&gt;&lt;strong&gt;manifest&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; 指令指定可以将哪些&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Manifest&quot;&gt;清单&lt;/a&gt;应用于资源。</target>
        </trans-unit>
        <trans-unit id="e5534bb581250f2eb94ed31caf65205d9ee368e1" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&lt;strong&gt;img&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies valid sources of images and favicons.</source>
          <target state="translated">HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&lt;strong&gt;img&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; 指令指定图像和图标的有效来源。</target>
        </trans-unit>
        <trans-unit id="dc76ac8291a24a25cb87200add3759c6483c6ea1" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&lt;strong&gt;object&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies valid sources for the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt;&lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt;&lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt;&lt;/a&gt; elements.</source>
          <target state="translated">HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&lt;strong&gt;object&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; 指令为&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt; &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt; &lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt; &lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt; &lt;/a&gt;元素指定有效的源。</target>
        </trans-unit>
        <trans-unit id="1d78f21670ba26d46502f42156fd74dce6127ca2" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&lt;strong&gt;require-sri-for&lt;/strong&gt;&lt;/code&gt; directive instructs the client to require the use of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity&quot;&gt;Subresource Integrity&lt;/a&gt; for scripts or styles on the page.</source>
          <target state="translated">HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&lt;strong&gt;require-sri-for&lt;/strong&gt;&lt;/code&gt; 指令指示客户端要求对页面上的脚本或样式使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity&quot;&gt;Subresource Integrity&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c04dd8d66fd1dfd03e0cb89fd2b86f5466e7e9c8" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;base-uri&lt;/code&gt; directive restricts the URLs which can be used in a document's &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base&quot;&gt;&lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt;&lt;/a&gt; element. If this value is absent, then any URI is allowed. If this directive is absent, the user agent will use the value in the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base&quot;&gt;&lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt;&lt;/a&gt; element.</source>
          <target state="translated">HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;base-uri&lt;/code&gt; 指令限制可以在文档的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base&quot;&gt; &lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt; &lt;/a&gt;元素中使用的URL 。如果不存在此值，则允许任何URI。如果不存在此伪指令，则用户代理将使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base&quot;&gt; &lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt; &lt;/a&gt;元素中的值。</target>
        </trans-unit>
        <trans-unit id="434bd95977151980be645e25d889ee96d08c9496" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;autoplay&lt;/code&gt; directive controls whether the current document is allowed to autoplay media requested through the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement&quot;&gt;&lt;code&gt;HTMLMediaElement&lt;/code&gt;&lt;/a&gt; interface. When this policy is enabled and there were no user gestures, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/play&quot;&gt;&lt;code&gt;HTMLMediaElement.play()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;code&gt;DOMException&lt;/code&gt;. The &lt;code&gt;autoplay&lt;/code&gt; attribute on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt;&lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/a&gt; elements will be ignored.</source>
          <target state="translated">HTTP &lt;a href=&quot;feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;标头的 &lt;code&gt;autoplay&lt;/code&gt; 指令控制是否允许当前文档自动播放通过&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement&quot;&gt; &lt;code&gt;HTMLMediaElement&lt;/code&gt; &lt;/a&gt;接口请求的媒体。启用此策略并且没有用户手势时，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/play&quot;&gt; &lt;code&gt;HTMLMediaElement.play()&lt;/code&gt; &lt;/a&gt;返回的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt;将拒绝，并带有 &lt;code&gt;DOMException&lt;/code&gt; 。&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt; &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt; &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; &lt;/a&gt;元素上的 &lt;code&gt;autoplay&lt;/code&gt; 属性将被忽略。</target>
        </trans-unit>
        <trans-unit id="7f42da0f7bda5731910d6ec6cb2dc9b13ff87de9" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;camera&lt;/code&gt; directive controls whether the current document is allowed to use video input devices. When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia&quot;&gt;&lt;code&gt;MediaDevices.getUserMedia()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;code&gt;NotAllowedError&lt;/code&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;标头 &lt;code&gt;camera&lt;/code&gt; 指令控制是否允许当前文档使用视频输入设备。启用此策略后，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia&quot;&gt; &lt;code&gt;MediaDevices.getUserMedia()&lt;/code&gt; &lt;/a&gt;返回的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt;将拒绝，并带有 &lt;code&gt;NotAllowedError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4b38e64dd4aafe5fbe1b9af5c13faa83b6a43ced" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;document-domain&lt;/code&gt; directive controls whether the current document is allowed to set &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/domain&quot;&gt;&lt;code&gt;document.domain&lt;/code&gt;&lt;/a&gt;. When this policy is enabled, attempting to set &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/domain&quot;&gt;&lt;code&gt;document.domain&lt;/code&gt;&lt;/a&gt; will fail and cause a &lt;code&gt;SecurityError&lt;/code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/DOMException&quot;&gt;&lt;code&gt;DOMException&lt;/code&gt;&lt;/a&gt; to be be thrown.</source>
          <target state="translated">HTTP &lt;a href=&quot;feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;标头 &lt;code&gt;document-domain&lt;/code&gt; 指令控制是否允许当前文档设置&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/domain&quot;&gt; &lt;code&gt;document.domain&lt;/code&gt; &lt;/a&gt;。启用此策略后，尝试设置&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/domain&quot;&gt; &lt;code&gt;document.domain&lt;/code&gt; &lt;/a&gt;将失败并导致引发 &lt;code&gt;SecurityError&lt;/code&gt; &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/DOMException&quot;&gt; &lt;code&gt;DOMException&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="52529e863205e105281cb3b1e67c42491db93580" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;encrypted-media&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Encrypted_Media_Extensions_API&quot;&gt;Encrypted Media Extensions&lt;/a&gt; API (EME). When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/requestMediaKeySystemAccess&quot;&gt;&lt;code&gt;Navigator.requestMediaKeySystemAccess()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;code&gt;DOMException&lt;/code&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;标头 &lt;code&gt;encrypted-media&lt;/code&gt; 伪指令控制是否允许当前文档使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Encrypted_Media_Extensions_API&quot;&gt;Encrypted Media Extensions&lt;/a&gt; API（EME）。启用此策略后，由&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/requestMediaKeySystemAccess&quot;&gt; &lt;code&gt;Navigator.requestMediaKeySystemAccess()&lt;/code&gt; &lt;/a&gt;返回的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt;将拒绝，并带有 &lt;code&gt;DOMException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2c026bd77cc15606268a474526426c47ed406dd3" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;fullscreen&lt;/code&gt; directive controls whether the current document is allowed to use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Element/requestFullScreen&quot;&gt;&lt;code&gt;Element.requestFullScreen()&lt;/code&gt;&lt;/a&gt;. When this policy is enabled, the returned &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; rejects with a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;标头 &lt;code&gt;fullscreen&lt;/code&gt; 指令控制是否允许当前文档使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Element/requestFullScreen&quot;&gt; &lt;code&gt;Element.requestFullScreen()&lt;/code&gt; &lt;/a&gt;。启用此策略后，返回的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; 会&lt;/a&gt;拒绝并带有&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="279945c05ed4e9f8612677a6cb5333c055c3347c" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;geolocation&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation&quot;&gt;&lt;code&gt;Geolocation&lt;/code&gt;&lt;/a&gt; Interface. When this policy is enabled, calls to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/getCurrentPosition&quot;&gt;&lt;code&gt;getCurrentPosition()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/watchPosition&quot;&gt;&lt;code&gt;watchPosition()&lt;/code&gt;&lt;/a&gt; will cause those functions' callbacks to be invoked with a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PositionError&quot;&gt;&lt;code&gt;PositionError&lt;/code&gt;&lt;/a&gt; code of &lt;code&gt;PERMISSION_DENIED&lt;/code&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;标头 &lt;code&gt;geolocation&lt;/code&gt; 指令控制是否允许当前文档使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation&quot;&gt; &lt;code&gt;Geolocation&lt;/code&gt; &lt;/a&gt;接口。启用此策略后，对&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/getCurrentPosition&quot;&gt; &lt;code&gt;getCurrentPosition()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/watchPosition&quot;&gt; &lt;code&gt;watchPosition()&lt;/code&gt; 的&lt;/a&gt;调用将使这些函数的回调以 &lt;code&gt;PERMISSION_DENIED&lt;/code&gt; 的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PositionError&quot;&gt; &lt;code&gt;PositionError&lt;/code&gt; &lt;/a&gt;代码进行调用。</target>
        </trans-unit>
        <trans-unit id="b86b8ff6f832650a49ab241aa391e1a80cf0e208" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;microphone&lt;/code&gt; directive controls whether the current document is allowed to use audio input devices. When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia&quot;&gt;&lt;code&gt;MediaDevices.getUserMedia()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;code&gt;NotAllowedError&lt;/code&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;标头 &lt;code&gt;microphone&lt;/code&gt; 指令控制是否允许当前文档使用音频输入设备。启用此策略后，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia&quot;&gt; &lt;code&gt;MediaDevices.getUserMedia()&lt;/code&gt; &lt;/a&gt;返回的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt;将拒绝，并带有 &lt;code&gt;NotAllowedError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0ee0bf2b06d49cf8e3886496858e4c50b79dbf27" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;midi&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_MIDI_API&quot;&gt;Web MIDI API&lt;/a&gt;. When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/requestMIDIAccess&quot;&gt;&lt;code&gt;Navigator.requestMIDIAccess()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;code&gt;DOMException&lt;/code&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;标头 &lt;code&gt;midi&lt;/code&gt; 指令控制是否允许当前文档使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_MIDI_API&quot;&gt;Web MIDI API&lt;/a&gt;。启用此策略后，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/requestMIDIAccess&quot;&gt; &lt;code&gt;Navigator.requestMIDIAccess()&lt;/code&gt; &lt;/a&gt;返回的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt;将以 &lt;code&gt;DOMException&lt;/code&gt; 拒绝。</target>
        </trans-unit>
        <trans-unit id="92e1c9da52aa492cca410e5baad4c4d7dda1aa4f" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;payment&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Payment_Request_API&quot;&gt;Payment Request API&lt;/a&gt;. When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PaymentRequest&quot;&gt;&lt;code&gt;PaymentRequest()&lt;/code&gt;&lt;/a&gt; constructor will throw a &lt;code&gt;SecurityError&lt;/code&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;标头 &lt;code&gt;payment&lt;/code&gt; 指令控制是否允许当前文档使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Payment_Request_API&quot;&gt;Payment Request API&lt;/a&gt;。启用此策略后，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PaymentRequest&quot;&gt; &lt;code&gt;PaymentRequest()&lt;/code&gt; &lt;/a&gt;构造函数将抛出 &lt;code&gt;SecurityError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cc9aec9b3d7ed8d0d68045c2927ccdfecf55159b" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;vr&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebVR_API&quot;&gt;WebVR API&lt;/a&gt;. When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/getVRDisplays&quot;&gt;&lt;code&gt;Navigator.getVRDisplays()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;code&gt;DOMException&lt;/code&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt;标头 &lt;code&gt;vr&lt;/code&gt; 指令控制是否允许当前文档使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebVR_API&quot;&gt;WebVR API&lt;/a&gt;。启用此策略后，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/getVRDisplays&quot;&gt; &lt;code&gt;Navigator.getVRDisplays()&lt;/code&gt; &lt;/a&gt;返回的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt;将以 &lt;code&gt;DOMException&lt;/code&gt; 拒绝。</target>
        </trans-unit>
        <trans-unit id="4a01790dc40b1842141c794cdff77d6c8665d41c" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt; method only allows complete replacement of a document. Unlike &lt;code&gt;PUT&lt;/code&gt;, &lt;code&gt;PATCH&lt;/code&gt; is not idempotent, meaning successive identical patch requests &lt;em&gt;may &lt;/em&gt;have different effects. However, it is possible to issue &lt;code&gt;PATCH&lt;/code&gt; requests in such a way as to be idempotent.</source>
          <target state="translated">HTTP &lt;a href=&quot;put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/a&gt;方法仅允许完全替换文档。与 &lt;code&gt;PUT&lt;/code&gt; 不同， &lt;code&gt;PATCH&lt;/code&gt; 不是幂等的，这意味着连续的相同补丁请求&lt;em&gt;可能会&lt;/em&gt;产生不同的影响。但是，可以以等幂的方式发出 &lt;code&gt;PATCH&lt;/code&gt; 请求。</target>
        </trans-unit>
        <trans-unit id="7f334e7627368fd785cf9c286367893a77c43e45" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;100 Continue&lt;/code&gt; informational status response code indicates that everything so far is OK and that the client should continue with the request or ignore it if it is already finished.</source>
          <target state="translated">HTTP &lt;code&gt;100 Continue&lt;/code&gt; 信息状态响应代码表示到目前为止一切正常，客户端应继续请求，或者如果请求已完成，则将其忽略。</target>
        </trans-unit>
        <trans-unit id="7fbaadcda1376e28783b5f635687be50467a1933" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;103 Early Hints&lt;/code&gt; information response status code is primarily intended to be used with the &lt;a href=&quot;../headers/link&quot;&gt;&lt;code&gt;Link&lt;/code&gt;&lt;/a&gt; header to allow the user agent to start preloading resources while the server is still preparing a response.</source>
          <target state="translated">HTTP &lt;code&gt;103 Early Hints&lt;/code&gt; 信息响应状态代码主要用于与&lt;a href=&quot;../headers/link&quot;&gt; &lt;code&gt;Link&lt;/code&gt; &lt;/a&gt;头一起使用，以允许用户代理在服务器仍在准备响应时开始预加载资源。</target>
        </trans-unit>
        <trans-unit id="278c46bdc85af7c390f125d693bcbfb316c79076" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;200 OK&lt;/code&gt; success status response code indicates that the request has succeeded. A 200 response is cacheable by default.</source>
          <target state="translated">HTTP &lt;code&gt;200 OK&lt;/code&gt; 成功状态响应代码指示请求已成功。默认情况下，200响应是可缓存的。</target>
        </trans-unit>
        <trans-unit id="c0eb27679053d5143a43ddd8d3a3431a539fa9ad" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;201 Created&lt;/code&gt; success status response code indicates that the request has succeeded and has led to the creation of a resource. The new resource is effectively created before this response is sent back and the new resource is returned in the body of the message, its location being either the URL of the request, or the content of the &lt;a href=&quot;../headers/location&quot;&gt;&lt;code&gt;Location&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">HTTP &lt;code&gt;201 Created&lt;/code&gt; 成功状态响应代码指示请求已成功并导致资源的创建。在发送此响应并将新资源返回到邮件正文之前，将有效地创建新资源，该新资源的位置可以是请求的URL或&lt;a href=&quot;../headers/location&quot;&gt; &lt;code&gt;Location&lt;/code&gt; &lt;/a&gt;标头的内容。</target>
        </trans-unit>
        <trans-unit id="f20649a3f0fe7c56e61071fa1174a4b08047b9bd" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;203 Non-Authoritative Information&lt;/code&gt; response status indicates that the request was successful but the enclosed payload has been modified by a transforming &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Proxy_server&quot;&gt;proxy&lt;/a&gt; from that of the origin server's &lt;a href=&quot;200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;OK&lt;/code&gt;) response .</source>
          <target state="translated">HTTP &lt;code&gt;203 Non-Authoritative Information&lt;/code&gt; 响应状态指示该请求已成功，但是封闭的有效负载已由转换&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Proxy_server&quot;&gt;代理&lt;/a&gt;从原始服务器&lt;a href=&quot;200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt;（ &lt;code&gt;OK&lt;/code&gt; ）的响应中进行了转换。</target>
        </trans-unit>
        <trans-unit id="e4d3953aeb6b99914993168434167c7b602ed71d" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;203 Non-Authoritative Information&lt;/code&gt; response status indicates that the request was successful but the enclosed payload has been modified from that of the origin server's &lt;a href=&quot;200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;OK&lt;/code&gt;) response by a transforming &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Proxy_server&quot;&gt;proxy&lt;/a&gt;.</source>
          <target state="translated">HTTP &lt;code&gt;203 Non-Authoritative Information&lt;/code&gt; 响应状态指示请求已成功，但是已封装的有效负载已由转换&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Proxy_server&quot;&gt;代理&lt;/a&gt;从源服务器&lt;a href=&quot;200&quot;&gt; &lt;code&gt;200&lt;/code&gt; 的&lt;/a&gt;响应（ &lt;code&gt;OK&lt;/code&gt; ）进行了修改。</target>
        </trans-unit>
        <trans-unit id="c8b0b238f5e41f13b1e7f817deb60c88d7d3bc20" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;204 No Content&lt;/code&gt; success status response code indicates that the request has succeeded, but that the client doesn't need to go away from its current page. A 204 response is cacheable by default. An &lt;a href=&quot;../headers/etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt; header is included in such a response.</source>
          <target state="translated">HTTP &lt;code&gt;204 No Content&lt;/code&gt; 成功状态响应代码指示请求已成功，但是客户端不需要离开其当前页面。默认情况下，204响应是可缓存的。一个&lt;a href=&quot;../headers/etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; 的&lt;/a&gt;报头被包括在这样的响应。</target>
        </trans-unit>
        <trans-unit id="80288ab170aee829f4cf209605eb49eadc086eef" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;205 Reset Content&lt;/code&gt; response status tells the client to reset the document view, so for example to clear the content of a form, reset a canvas state, or to refresh the UI.</source>
          <target state="translated">HTTP &lt;code&gt;205 Reset Content&lt;/code&gt; 响应状态告诉客户端重置文档视图，例如清除表单内容，重置画布状态或刷新UI。</target>
        </trans-unit>
        <trans-unit id="0c81546d9f0eee981bd016b4cb4e7eaa4833eb13" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;206 Partial Content&lt;/code&gt; success status response code indicates that the request has succeeded and has the body contains the requested ranges of data, as described in the &lt;a href=&quot;../headers/range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; header of the request.</source>
          <target state="translated">HTTP &lt;code&gt;206 Partial Content&lt;/code&gt; 成功状态响应代码表示请求已成功完成，并且主体包含请求的数据范围，如请求的&lt;a href=&quot;../headers/range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt;标头中所述。</target>
        </trans-unit>
        <trans-unit id="3b3b5e099cd9381b1fd70b5113573795b1907f7d" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;401 Unauthorized&lt;/code&gt; client error status response code indicates that the request has not been applied because it lacks valid authentication credentials for the target resource.</source>
          <target state="translated">HTTP &lt;code&gt;401 Unauthorized&lt;/code&gt; 客户端错误状态响应代码表示该请求尚未应用，因为它缺少针对目标资源的有效身份验证凭据。</target>
        </trans-unit>
        <trans-unit id="29e296a48560f66dbcc3ec52c233f4fdb267b76e" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;402 Payment Required&lt;/code&gt; is a nonstandard client error status response code that is reserved for future use.</source>
          <target state="translated">需要的HTTP &lt;code&gt;402 Payment Required&lt;/code&gt; 是非标准的客户错误状态响应代码，保留给以后使用。</target>
        </trans-unit>
        <trans-unit id="979b22f333764accadf3c7a12f9ce50117ebb170" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;403 Forbidden&lt;/code&gt; client error status response code indicates that the server understood the request but refuses to authorize it.</source>
          <target state="translated">HTTP &lt;code&gt;403 Forbidden&lt;/code&gt; 客户端错误状态响应代码指示服务器理解了该请求但拒绝对其进行授权。</target>
        </trans-unit>
        <trans-unit id="17d3fa05f1dcd2e00101e33637b74e845046dbb5" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;407 Proxy Authentication Required &lt;/code&gt; client error status response code indicates that the request has not been applied because it lacks valid authentication credentials for a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/proxy_server&quot;&gt;proxy server&lt;/a&gt; that is between the browser and the server that can access the requested resource.</source>
          <target state="translated">HTTP &lt;code&gt;407 Proxy Authentication Required &lt;/code&gt; 客户端错误状态响应代码表示该请求尚未应用，因为它缺少&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/proxy_server&quot;&gt;代理服务器的&lt;/a&gt;有效身份验证凭据，该代理服务器位于浏览器和可以访问所请求资源的服务器之间。</target>
        </trans-unit>
        <trans-unit id="bbb5886db0baaa39aa591bfbfac7d405f377c2ab" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;417 Expectation Failed&lt;/code&gt; client error response code indicates that the expectation given in the request's &lt;a href=&quot;../headers/expect&quot;&gt;&lt;code&gt;Expect&lt;/code&gt;&lt;/a&gt; header could not be met.</source>
          <target state="translated">HTTP &lt;code&gt;417 Expectation Failed&lt;/code&gt; 客户端错误响应代码指示无法满足请求的&lt;a href=&quot;../headers/expect&quot;&gt; &lt;code&gt;Expect&lt;/code&gt; &lt;/a&gt;标头中给出的期望。</target>
        </trans-unit>
        <trans-unit id="0fd8eba95386e5a941324f20f703ccd45af95a3a" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;418 I'm a teapot&lt;/code&gt; client error response code indicates that the server refuses to brew coffee because it is a teapot. This error is a reference of Hyper Text Coffee Pot Control Protocol which was an April Fools' joke in 1998.</source>
          <target state="translated">HTTP &lt;code&gt;418 I'm a teapot&lt;/code&gt; 客户端错误响应代码，指示服务器拒绝冲泡咖啡，因为它是茶壶。此错误是超文本咖啡壶控制协议的参考，该协议是1998年愚人节的笑话。</target>
        </trans-unit>
        <trans-unit id="654a84748c864e6e1a07b612586a854316f7aeb8" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;418 I'm a teapot&lt;/code&gt; client error response code indicates that the server refuses to brew coffee because it is, permanently, a teapot. A combined coffee/tea pot that is temporarily out of coffee should instead return 503. This error is a reference to Hyper Text Coffee Pot Control Protocol defined in April Fools' jokes in 1998 and 2014.</source>
          <target state="translated">HTTP &lt;code&gt;418 I'm a teapot&lt;/code&gt; 客户端错误响应代码，指示服务器拒绝冲泡咖啡，因为它永久是茶壶。暂时没有咖啡的组合式咖啡/茶壶应返回503。此错误是对1998年和2014年愚人节笑话中定义的&amp;ldquo;超文本咖啡壶控制协议&amp;rdquo;的引用。</target>
        </trans-unit>
        <trans-unit id="c11a396d84c2b4361354f28621db5450bb7872a5" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;101 Switching Protocols&lt;/strong&gt;&lt;/code&gt; response code indicates the protocol the server is switching to as requested by a client which sent the message including the &lt;a href=&quot;../headers/upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt; request header.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;101 Switching Protocols&lt;/strong&gt;&lt;/code&gt; 响应代码指示服务器根据客户端的请求切换到该协议，客户端发送了包含&lt;a href=&quot;../headers/upgrade&quot;&gt; &lt;code&gt;Upgrade&lt;/code&gt; &lt;/a&gt;请求标头的消息。</target>
        </trans-unit>
        <trans-unit id="b73eb36719efddb2bf307089114ca5c1ff83bc1f" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;101 Switching Protocols&lt;/strong&gt;&lt;/code&gt; response code indicates the protocol the server is switching to as requested by a client which sent the message including the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt; request header.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;101 Switching Protocols&lt;/strong&gt;&lt;/code&gt; 响应代码指示服务器根据客户端的请求切换到该协议，客户端发送了包含&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt; &lt;code&gt;Upgrade&lt;/code&gt; &lt;/a&gt;请求标头的消息。</target>
        </trans-unit>
        <trans-unit id="d7eb48272f72778b0b684676d2f608817e02eb9f" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;300 Multiple Choices&lt;/strong&gt;&lt;/code&gt; redirect status response code indicates that the request has more than one possible responses. The user-agent or the user should choose one of them. As there is no standardized way of choosing one of the responses, this response code is very rarely used.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;300 Multiple Choices&lt;/strong&gt;&lt;/code&gt; 重定向状态响应代码表示该请求具有多个可能的响应。用户代理或用户应选择其中之一。由于没有选择任何一种响应的标准化方法，因此很少使用此响应代码。</target>
        </trans-unit>
        <trans-unit id="de334adf5ffab7d89b3c6e50513373cd0cee8cfc" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;304 Not Modified&lt;/strong&gt;&lt;/code&gt; client redirection response code indicates that there is no need to retransmit the requested resources. It is an implicit redirection to a cached resource. This happens when the request method is &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/safe&quot;&gt;safe&lt;/a&gt;, like a &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; or a &lt;a href=&quot;../methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt; request, or when the request is conditional and uses a &lt;a href=&quot;../headers/if-none-match&quot;&gt;&lt;code&gt;If-None-Match&lt;/code&gt;&lt;/a&gt; or a &lt;a href=&quot;../headers/if-modified-since&quot;&gt;&lt;code&gt;If-Modified-Since&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;304 Not Modified&lt;/strong&gt;&lt;/code&gt; 客户端重定向响应代码指示不需要重新传输请求的资源。这是对缓存资源的隐式重定向。当请求方法是&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/safe&quot;&gt;安全的&lt;/a&gt;（例如&lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; &lt;/a&gt;请求），或者请求是有条件的并且使用&lt;a href=&quot;../headers/if-none-match&quot;&gt; &lt;code&gt;If-None-Match&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../headers/if-modified-since&quot;&gt; &lt;code&gt;If-Modified-Since&lt;/code&gt; &lt;/a&gt;标头时，就会发生这种情况。</target>
        </trans-unit>
        <trans-unit id="709d37d1b0cf9c49b3de2408fbf6ef4e0002c27a" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;404 Not Found&lt;/strong&gt;&lt;/code&gt; client error response code indicates that the server can't find the requested resource. Links that lead to a 404 page are often called broken or dead links and can be subject to &lt;a href=&quot;https://en.wikipedia.org/wiki/Link_rot&quot;&gt;link rot&lt;/a&gt;.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;404 Not Found&lt;/strong&gt;&lt;/code&gt; 客户端错误响应代码表示服务器找不到请求的资源。指向404页的链接通常称为断开或无效链接，并且可能会受到&lt;a href=&quot;https://en.wikipedia.org/wiki/Link_rot&quot;&gt;链接腐烂的影响&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="341bb159a2216d99ce107781a967531062a1c137" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;404 Not Found&lt;/strong&gt;&lt;/code&gt; client error response code indicates that the server can't find the requested resource. Links which lead to a 404 page are often called broken or dead links, and can be subject to &lt;a href=&quot;https://en.wikipedia.org/wiki/Link_rot&quot;&gt;link rot&lt;/a&gt;.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;404 Not Found&lt;/strong&gt;&lt;/code&gt; 客户端错误响应代码表示服务器找不到请求的资源。指向404页的链接通常称为断开或无效链接，并且可能会受到&lt;a href=&quot;https://en.wikipedia.org/wiki/Link_rot&quot;&gt;rot的影响&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="963eb81b613d14e6431a53b19e1087de4815c917" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;409 Conflict&lt;/strong&gt;&lt;/code&gt; response status code indicates a request conflict with current state of the server.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;409 Conflict&lt;/strong&gt;&lt;/code&gt; 响应状态代码指示请求与服务器的当前状态发生冲突。</target>
        </trans-unit>
        <trans-unit id="4a775e572f006026758ef524b8a9cc133b9ccc99" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;409 Conflict&lt;/strong&gt;&lt;/code&gt; response status code indicates a request conflict with current state of the target resource.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;409 Conflict&lt;/strong&gt;&lt;/code&gt; 响应状态代码指示请求与目标资源的当前状态发生冲突。</target>
        </trans-unit>
        <trans-unit id="1e620c227a6a0b266557df35d3c5635f4241af7c" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;413 Payload Too Large&lt;/strong&gt;&lt;/code&gt; response status code indicates that the request entity is larger than limits defined by server; the server might close the connection or return a &lt;a href=&quot;../headers/retry-after&quot;&gt;&lt;code&gt;Retry-After&lt;/code&gt;&lt;/a&gt; header field.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;413 Payload Too Large&lt;/strong&gt;&lt;/code&gt; 响应状态代码表示请求实体大于服务器定义的限制；服务器可能会关闭连接或返回&lt;a href=&quot;../headers/retry-after&quot;&gt; &lt;code&gt;Retry-After&lt;/code&gt; &lt;/a&gt;标头字段。</target>
        </trans-unit>
        <trans-unit id="84e2079297e778196c8c9ae50616e31cf6eb1ce4" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;414 URI Too Long&lt;/strong&gt;&lt;/code&gt; response status code indicates that the URI requested by the client is longer than the server is willing to interpret.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;414 URI Too Long&lt;/strong&gt;&lt;/code&gt; 响应状态代码表示客户端请求的URI比服务器愿意解释的更长。</target>
        </trans-unit>
        <trans-unit id="fd260910ed4759c1378089671fbb6c0fbbb60660" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;415 Unsupported Media Type&lt;/strong&gt;&lt;/code&gt; client error response code indicates that the server refuses to accept the request because the payload format is in an unsupported format.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;415 Unsupported Media Type&lt;/strong&gt;&lt;/code&gt; 客户端错误响应代码指示服务器拒绝接受请求，因为有效负载格式为不受支持的格式。</target>
        </trans-unit>
        <trans-unit id="fa970ac1d28b371bc4205e842d1c6d26ad5a73c4" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;426 Upgrade Required&lt;/strong&gt;&lt;/code&gt; client error response code indicates that the server refuses to perform the request using the current protocol but might be willing to do so after the client upgrades to a different protocol.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;426 Upgrade Required&lt;/strong&gt;&lt;/code&gt; 客户端错误响应代码指示服务器拒绝使用当前协议执行请求，但是在客户端升级到其他协议后可能愿意这样做。</target>
        </trans-unit>
        <trans-unit id="75aa3c74acfab1e106209fd4dd08b06e3054f27c" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;428 Precondition Required&lt;/strong&gt;&lt;/code&gt; response status code indicates that the server requires the request to be &lt;a href=&quot;../conditional_requests&quot;&gt;conditional&lt;/a&gt;.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;428 Precondition Required&lt;/strong&gt;&lt;/code&gt; 响应状态代码指示服务器要求请求是&lt;a href=&quot;../conditional_requests&quot;&gt;有条件的&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="caa3bb3b92f0cfe33012b47986779e7f954a74b6" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;429 Too Many Requests&lt;/strong&gt;&lt;/code&gt; response status code indicates the user has sent too many requests in a given amount of time (&quot;rate limiting&quot;).</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;429 Too Many Requests&lt;/strong&gt;&lt;/code&gt; 响应状态代码指示用户在给定的时间内发送了太多请求（&amp;ldquo;速率限制&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="04093cec2709dfaadbfa7527dc5c2ce1cd0b0646" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;431 Request Header Fields Too Large&lt;/strong&gt;&lt;/code&gt; response status code indicates that the server is unwilling to process the request because its header fields are too large. The request may be resubmitted after reducing the size of the request header fields.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;431 Request Header Fields Too Large&lt;/strong&gt;&lt;/code&gt; 响应状态代码表示服务器不愿意处理该请求，因为其标头字段太大。在减小请求头字段的大小之后，可以重新提交请求。</target>
        </trans-unit>
        <trans-unit id="aa944fee90f822e5d898a487cb81942f7a56be65" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;431 Request Header Fields Too Large&lt;/strong&gt;&lt;/code&gt; response status code indicates that the server refuses to process the request because the request&amp;rsquo;s &lt;a href=&quot;../headers&quot;&gt;HTTP headers&lt;/a&gt; are too long. The request &lt;em&gt;may&lt;/em&gt; be resubmitted after reducing the size of the request headers.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;431 Request Header Fields Too Large&lt;/strong&gt;&lt;/code&gt; 响应状态代码表示服务器拒绝处理请求，因为请求的&lt;a href=&quot;../headers&quot;&gt;HTTP标头&lt;/a&gt;太长。该请求&lt;em&gt;可以&lt;/em&gt;减少请求报头的大小后重新提交。</target>
        </trans-unit>
        <trans-unit id="a9ddb3645327183c13becf845f54f56cdc4fdb5b" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;511 Network Authentication Required&lt;/strong&gt;&lt;/code&gt; response status code indicates that the client needs to authenticate to gain network access.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;511 Network Authentication Required&lt;/strong&gt;&lt;/code&gt; 响应状态码指示客户端需要进行身份验证才能获得网络访问权限。</target>
        </trans-unit>
        <trans-unit id="61ba4c1907f9a2e1f56de138ea9bcbb425c864e8" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;Public-Key-Pins-Report-Only&lt;/strong&gt;&lt;/code&gt; response header sends reports of pinning violation to the &lt;code&gt;report-uri&lt;/code&gt; specified in the header but, unlike &lt;a href=&quot;public-key-pins&quot;&gt;&lt;code&gt;Public-Key-Pins&lt;/code&gt;&lt;/a&gt; still allows browsers to connect to the server if the pinning is violated.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;Public-Key-Pins-Report-Only&lt;/strong&gt;&lt;/code&gt; 响应标头将违反固定的 &lt;code&gt;report-uri&lt;/code&gt; 发送到标头中指定的report-uri，但与&lt;a href=&quot;public-key-pins&quot;&gt; &lt;code&gt;Public-Key-Pins&lt;/code&gt; &lt;/a&gt;不同，如果违反了固定，仍然允许浏览器连接到服务器。</target>
        </trans-unit>
        <trans-unit id="1d86ddf68a31dc8a760b8d60344a39004ec85b2f" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;Public-Key-Pins-Report-Only&lt;/strong&gt;&lt;/code&gt; response header was used to send reports of pinning violation to the &lt;code&gt;report-uri&lt;/code&gt; specified in the header but, unlike &lt;a href=&quot;public-key-pins&quot;&gt;&lt;code&gt;Public-Key-Pins&lt;/code&gt;&lt;/a&gt; still allows browsers to connect to the server if the pinning is violated. The header is silently ignored in modern browsers as support for HPKP has been removed. Use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Certificate_Transparency&quot;&gt;Certificate Transparency&lt;/a&gt; and the &lt;a href=&quot;expect-ct&quot;&gt;&lt;code&gt;Expect-CT&lt;/code&gt;&lt;/a&gt; header instead.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;Public-Key-Pins-Report-Only&lt;/strong&gt;&lt;/code&gt; 响应标头用于将违反固定的 &lt;code&gt;report-uri&lt;/code&gt; 发送到标头中指定的report-uri，但与&lt;a href=&quot;public-key-pins&quot;&gt; &lt;code&gt;Public-Key-Pins&lt;/code&gt; &lt;/a&gt;不同，如果固定是违反了。在现代浏览器中，标头被静默忽略，因为已删除了对HPKP的支持。请改用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Certificate_Transparency&quot;&gt;证书透明性&lt;/a&gt;和&lt;a href=&quot;expect-ct&quot;&gt; &lt;code&gt;Expect-CT&lt;/code&gt; &lt;/a&gt;标头。</target>
        </trans-unit>
        <trans-unit id="2f1aca0b8602a1b4269702669b5705705488252e" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;Public-Key-Pins&lt;/strong&gt;&lt;/code&gt; response header associates a specific cryptographic public &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/key&quot;&gt;key&lt;/a&gt; with a certain web server to decrease the risk of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/MITM&quot;&gt;MITM&lt;/a&gt; attacks with forged certificates. If one or several keys are pinned and none of them are used by the server, the browser will not accept the response as legitimate, and will not display it.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;Public-Key-Pins&lt;/strong&gt;&lt;/code&gt; 响应标头将特定的加密公共&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/key&quot;&gt;密钥&lt;/a&gt;与某个Web服务器相关联，以降低使用伪造证书进行&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/MITM&quot;&gt;MITM&lt;/a&gt;攻击的风险。如果固定了一个或多个键，并且服务器均未使用任何键，则浏览器将不会接受该响应为合法响应，也不会显示该响应。</target>
        </trans-unit>
        <trans-unit id="5426b643c79f95f69aab37cfedbccbbaa4236ca6" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;Public-Key-Pins&lt;/strong&gt;&lt;/code&gt; response header used to associate a specific cryptographic public &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/key&quot;&gt;key&lt;/a&gt; with a certain web server to decrease the risk of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/MITM&quot;&gt;MITM&lt;/a&gt; attacks with forged certificates, however, it has been removed from modern browsers and is no longer supported. Use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Certificate_Transparency&quot;&gt;Certificate Transparency&lt;/a&gt; and &lt;a href=&quot;expect-ct&quot;&gt;&lt;code&gt;Expect-CT&lt;/code&gt;&lt;/a&gt; header instead.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;Public-Key-Pins&lt;/strong&gt;&lt;/code&gt; 响应标头用于将特定的加密公共&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/key&quot;&gt;密钥&lt;/a&gt;与某个Web服务器相关联，以降低使用伪造证书的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/MITM&quot;&gt;MITM&lt;/a&gt;攻击的风险，但是，它已从现代浏览器中删除，不再受支持。请改用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Certificate_Transparency&quot;&gt;证书透明度&lt;/a&gt;和&lt;a href=&quot;expect-ct&quot;&gt; &lt;code&gt;Expect-CT&lt;/code&gt; &lt;/a&gt;标头。</target>
        </trans-unit>
        <trans-unit id="cc17523ceced42a997fa4ec405b48542dc6da961" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;Authorization&lt;/code&gt; request header contains the credentials to authenticate a user agent with a server, usually after the server has responded with a &lt;a href=&quot;../status/401&quot;&gt;&lt;code&gt;401&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Unauthorized&lt;/code&gt; status and the &lt;a href=&quot;www-authenticate&quot;&gt;&lt;code&gt;WWW-Authenticate&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">HTTP &lt;code&gt;Authorization&lt;/code&gt; 请求标头包含用于向服务器认证用户代理的凭据，通常在服务器以&lt;a href=&quot;../status/401&quot;&gt; &lt;code&gt;401&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Unauthorized&lt;/code&gt; 状态和&lt;a href=&quot;www-authenticate&quot;&gt; &lt;code&gt;WWW-Authenticate&lt;/code&gt; &lt;/a&gt;标头响应之后。</target>
        </trans-unit>
        <trans-unit id="91c7c3a40bace5e7298eaff1c25e12df9e924d3d" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;Authorization&lt;/code&gt; request header contains the credentials to authenticate a user agent with a server, usually, but not necessarily, after the server has responded with a &lt;a href=&quot;../status/401&quot;&gt;&lt;code&gt;401&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Unauthorized&lt;/code&gt; status and the &lt;a href=&quot;www-authenticate&quot;&gt;&lt;code&gt;WWW-Authenticate&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">HTTP &lt;code&gt;Authorization&lt;/code&gt; 请求标头包含用于在服务器以&lt;a href=&quot;../status/401&quot;&gt; &lt;code&gt;401&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Unauthorized&lt;/code&gt; 状态和&lt;a href=&quot;www-authenticate&quot;&gt; &lt;code&gt;WWW-Authenticate&lt;/code&gt; &lt;/a&gt;标头响应后（通常但不是必须）向服务器认证用户代理的凭据。</target>
        </trans-unit>
        <trans-unit id="eefae1a810c845c3fa68fd46660a1ab4ceaacda0" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; response header allows web developers to experiment with policies by monitoring (but not enforcing) their effects. These violation reports consist of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/JSON&quot;&gt;JSON&lt;/a&gt; documents sent via an HTTP &lt;code&gt;POST&lt;/code&gt; request to the specified URI.</source>
          <target state="translated">HTTP &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; 响应标头允许Web开发人员通过监视（但不强制执行）效果来试验策略。这些违规报告包含通过HTTP &lt;code&gt;POST&lt;/code&gt; 请求发送到指定URI 的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/JSON&quot;&gt;JSON&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="1cedc9503c55c7df39812e0c200c391cb9852c4a" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;Content-Security-Policy&lt;/code&gt; response header allows web site administrators to control resources the user agent is allowed to load for a given page. With a few exceptions, policies mostly involve specifying server origins and script endpoints. This helps guard against cross-site scripting attacks (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/XSS&quot;&gt;XSS&lt;/a&gt;).</source>
          <target state="translated">HTTP &lt;code&gt;Content-Security-Policy&lt;/code&gt; 响应标头允许网站管理员控制允许用户代理为给定页面加载的资源。除少数例外，策略主要涉及指定服务器来源和脚本端点。这有助于防止跨站点脚本攻击（&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/XSS&quot;&gt;XSS&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="e9a358c2e37bd97387c345bc97d49f2b9964bebc" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;Cross-Origin-Embedder-Policy&lt;/code&gt; (COEP) response header prevents a document from loading any cross-origin resources that don't explicitly grant the document permission (using &lt;a href=&quot;../cross-origin_resource_policy_(corp)&quot;&gt;CORP&lt;/a&gt; or &lt;a href=&quot;../cors&quot;&gt;CORS&lt;/a&gt;).</source>
          <target state="translated">HTTP &lt;code&gt;Cross-Origin-Embedder-Policy&lt;/code&gt; （COEP）响应标头可防止文档加载任何未明确授予文档许可权的跨域资源（使用&lt;a href=&quot;../cross-origin_resource_policy_(corp)&quot;&gt;CORP&lt;/a&gt;或&lt;a href=&quot;../cors&quot;&gt;CORS&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="bd12a715eb3e020beaec19eacef98180f3c03eb5" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;Cross-Origin-Opener-Policy&lt;/code&gt; (COOP) response header allows you to ensure a top-level document does not share a browsing context group with cross-origin documents.</source>
          <target state="translated">HTTP &lt;code&gt;Cross-Origin-Opener-Policy&lt;/code&gt; （COOP）响应标头使您可以确保顶级文档不会与跨源文档共享浏览上下文组。</target>
        </trans-unit>
        <trans-unit id="532f81dfa15429527706f99b56516bbbb7103920" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;Cross-Origin-Resource-Policy&lt;/code&gt; response header conveys a desire that the browser blocks no-cors cross-origin/cross-site requests to the given resource.</source>
          <target state="translated">HTTP &lt;code&gt;Cross-Origin-Resource-Policy&lt;/code&gt; 响应标头传达了一种希望，即浏览器阻止对给定资源的无芯跨域/跨站点请求。</target>
        </trans-unit>
        <trans-unit id="1606c56903114379a30109e67a8a9703c7538a88" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;Feature-Policy&lt;/code&gt; header provides a mechanism to allow and deny the use of browser features in its own frame, and in content within any &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt; elements in the document.</source>
          <target state="translated">HTTP &lt;code&gt;Feature-Policy&lt;/code&gt; 标头提供了一种机制，该机制允许和拒绝在其自己的框架以及文档中任何&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt;元素内的内容中使用浏览器功能。</target>
        </trans-unit>
        <trans-unit id="1f93db0c2b1cae96ab8007915ebdc3aee6ae9b29" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;Feature-Policy&lt;/code&gt; header provides a mechanism to allow and deny the use of browser features in its own frame, and in iframes that it embeds.</source>
          <target state="translated">HTTP &lt;code&gt;Feature-Policy&lt;/code&gt; 标头提供了一种机制，该机制允许和拒绝在其自己的框架以及嵌入的iframe中使用浏览器功能。</target>
        </trans-unit>
        <trans-unit id="ffce3b68f1b8be8fa0ab126f01ab7dcd1167232b" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;Link&lt;/code&gt; entity-header field provides a means for serialising one or more links in HTTP headers. It is semantically equivalent to the HTML &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link&quot;&gt;&lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt;&lt;/a&gt; element.</source>
          <target state="translated">HTTP &lt;code&gt;Link&lt;/code&gt; 实体标头字段提供了一种对HTTP标头中的一个或多个链接进行序列化的方法。它在语义上等效于HTML &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link&quot;&gt; &lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt; &lt;/a&gt;元素。</target>
        </trans-unit>
        <trans-unit id="15bba15c0e7df46ed2a8a40b2e760da5664fad96" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;NEL&lt;/code&gt; response header is used to configure network request logging.</source>
          <target state="translated">HTTP &lt;code&gt;NEL&lt;/code&gt; 响应标头用于配置网络请求日志记录。</target>
        </trans-unit>
        <trans-unit id="1ee6fbdaf32a73c5d2da4ea87e0ad9941527d763" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;Proxy-Authenticate&lt;/code&gt; response header defines the authentication method that should be used to gain access to a resource behind a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/proxy_server&quot;&gt;proxy server&lt;/a&gt;. It authenticates the request to the proxy server, allowing it to transmit the request further.</source>
          <target state="translated">HTTP &lt;code&gt;Proxy-Authenticate&lt;/code&gt; 响应标头定义了身份验证方法，应使用该身份验证方法来访问&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/proxy_server&quot;&gt;代理服务器&lt;/a&gt;后面的资源。它将请求认证到代理服务器，从而允许它进一步发送请求。</target>
        </trans-unit>
        <trans-unit id="d342efd1df2902182c9b47d04c0940ea25837a75" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;Proxy-Authorization&lt;/code&gt; request header contains the credentials to authenticate a user agent to a proxy server, usually after the server has responded with a &lt;a href=&quot;../status/407&quot;&gt;&lt;code&gt;407&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Proxy Authentication Required&lt;/code&gt; status and the &lt;a href=&quot;proxy-authenticate&quot;&gt;&lt;code&gt;Proxy-Authenticate&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">HTTP &lt;code&gt;Proxy-Authorization&lt;/code&gt; 请求标头包含用于对代理服务器认证用户代理的凭据，通常是在服务器以&lt;a href=&quot;../status/407&quot;&gt; &lt;code&gt;407&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Proxy Authentication Required&lt;/code&gt; 状态和&lt;a href=&quot;proxy-authenticate&quot;&gt; &lt;code&gt;Proxy-Authenticate&lt;/code&gt; &lt;/a&gt;标头响应之后。</target>
        </trans-unit>
        <trans-unit id="06706a733035595c3ca09ed579f53668680fa83e" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;Upgrade-Insecure-Requests&lt;/code&gt; request header sends a signal to the server expressing the client&amp;rsquo;s preference for an encrypted and authenticated response, and that it can successfully handle the &lt;a href=&quot;content-security-policy/upgrade-insecure-requests&quot;&gt;&lt;code&gt;upgrade-insecure-requests&lt;/code&gt;&lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/CSP&quot;&gt;CSP&lt;/a&gt; directive.</source>
          <target state="translated">HTTP &lt;code&gt;Upgrade-Insecure-Requests&lt;/code&gt; 请求标头将信号发送到服务器，以表示客户端对加密和认证响应的偏好，并且可以成功处理&lt;a href=&quot;content-security-policy/upgrade-insecure-requests&quot;&gt; &lt;code&gt;upgrade-insecure-requests&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/CSP&quot;&gt; CSP&lt;/a&gt;指令。</target>
        </trans-unit>
        <trans-unit id="5f27fddd57d61b2e03f1c5514e09709028f9f0a9" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;WWW-Authenticate&lt;/code&gt; response header defines the authentication method that should be used to gain access to a resource.</source>
          <target state="translated">HTTP &lt;code&gt;WWW-Authenticate&lt;/code&gt; 响应标头定义了应用于获得对资源访问权限的身份验证方法。</target>
        </trans-unit>
        <trans-unit id="aeb81534f8cc6e53ddfa06e7cb5d6c8eaf9dba55" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;X-XSS-Protection&lt;/code&gt; response header is a feature of Internet Explorer, Chrome and Safari that stops pages from loading when they detect reflected cross-site scripting (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/XSS&quot;&gt;XSS&lt;/a&gt;) attacks. Although these protections are largely unnecessary in modern browsers when sites implement a strong &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; that disables the use of inline JavaScript (&lt;code&gt;'unsafe-inline'&lt;/code&gt;), they can still provide protections for users of older web browsers that don't yet support &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CSP&quot;&gt;CSP&lt;/a&gt;.</source>
          <target state="translated">HTTP &lt;code&gt;X-XSS-Protection&lt;/code&gt; 响应标头是Internet Explorer，Chrome和Safari的一项功能，当页面检测到反射的跨站点脚本（&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/XSS&quot;&gt;XSS&lt;/a&gt;）攻击时，该页面将阻止加载页面。尽管当站点实施强大的&lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt;禁止使用内联JavaScript（ &lt;code&gt;'unsafe-inline'&lt;/code&gt; ）时，在现代浏览器中这些保护在很大程度上是不必要的，但它们仍可以为尚未使用旧版Web浏览器的用户提供保护支持&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CSP&quot;&gt;CSP&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2a09546225cff6400570e0443b16e0c6e86472fe" translate="yes" xml:space="preserve">
          <source>The HTTP Strict Transport Security header informs the browser that it should never load a site using HTTP and should automatically convert all attempts to access the site using HTTP to HTTPS requests instead.</source>
          <target state="translated">HTTP严格传输安全头告知浏览器,它不应该使用HTTP加载网站,而应该自动将所有使用HTTP访问网站的尝试转换为HTTPS请求。</target>
        </trans-unit>
        <trans-unit id="be8b00e9c8d5d272b2e1f90c102d59e067b32a0b" translate="yes" xml:space="preserve">
          <source>The HTTP URL namespace is a hierarchical namespace where the
   hierarchy is delimited with the &quot;/&quot; character.

   An HTTP URL namespace is said to be consistent if it meets the
   following conditions: for every URL in the HTTP hierarchy there
   exists a collection that contains that URL as an internal member URL.
   The root, or top-level collection of the namespace under
   consideration, is exempt from the previous rule.  The top-level
   collection of the namespace under consideration is not necessarily
   the collection identified by the absolute path '/' -- it may be
   identified by one or more path segments (e.g., /servlets/webdav/...)

   Neither HTTP/1.1 nor WebDAV requires that the entire HTTP URL
   namespace be consistent -- a WebDAV-compatible resource may not have
   a parent collection.  However, certain WebDAV methods are prohibited
   from producing results that cause namespace inconsistencies.

   As is implicit in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;] and [&lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt;], any resource, including
   collection resources, MAY be identified by more than one URI.  For
   example, a resource could be identified by multiple HTTP URLs.</source>
          <target state="translated">HTTP URL名称空间是层次结构名称空间，其中层次结构用&amp;ldquo; /&amp;rdquo;字符分隔。如果HTTP URL名称空间满足以下条件，则称该名称空间是一致的：对于HTTP层次结构中的每个URL，都存在一个包含该URL作为内部成员URL的集合。所考虑的名称空间的根或顶级集合免于先前的规则。所考虑的名称空间的顶级集合不一定是由绝对路径&amp;ldquo; /&amp;rdquo;标识的集合，它可以由一个或多个路径段（例如，/ servlets / webdav / ...）标识，而HTTP / 1.1或WebDAV都不要求整个HTTP URL名称空间保持一致-兼容WebDAV的资源可能没有父集合。然而，某些WebDAV方法被禁止产生导致名称空间不一致的结果。如[&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;和[ &lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt; ]，包括集合资源在内的任何资源都可以由多个URI标识。例如，资源可以由多个HTTP URL标识。</target>
        </trans-unit>
        <trans-unit id="4fce77c17c83cf3b9166ab68262d46c09171eb1b" translate="yes" xml:space="preserve">
          <source>The HTTP authentication framework does not define a single mechanism
   for maintaining the confidentiality of credentials; instead, each
   authentication scheme defines how the credentials are encoded prior
   to transmission.  While this provides flexibility for the development
   of future authentication schemes, it is inadequate for the protection
   of existing schemes that provide no confidentiality on their own, or
   that do not sufficiently protect against replay attacks.
   Furthermore, if the server expects credentials that are specific to
   each individual user, the exchange of those credentials will have the
   effect of identifying that user even if the content within
   credentials remains confidential.

   HTTP depends on the security properties of the underlying transport-
   or session-level connection to provide confidential transmission of
   header fields.  In other words, if a server limits access to
   authenticated users using this framework, the server needs to ensure
   that the connection is properly secured in accordance with the nature
   of the authentication scheme used.  For example, services that depend
   on individual user authentication often require a connection to be
   secured with TLS (&quot;Transport Layer Security&quot;, [&lt;a href=&quot;https://tools.ietf.org/html/rfc5246&quot;&gt;RFC5246&lt;/a&gt;]) prior to
   exchanging any credentials.</source>
          <target state="translated">HTTP身份验证框架没有定义用于维护凭据机密性的单一机制；相反，每个身份验证方案都定义了凭据在传输之前如何进行编码。尽管这为将来的身份验证方案的开发提供了灵活性，但不足以保护现有的方案，这些方案本身不提供任何机密性，或者不足以防止重放攻击。此外，如果服务器期望特定于每个单独用户的凭据，则即使凭据内的内容保持机密，这些凭据的交换也具有标识该用户的效果。HTTP依赖于基础传输或会话级连接的安全属性来提供头字段的机密传输。换句话说，如果服务器使用此框架将访问权限限制在经过身份验证的用户，则服务器需要确保根据所使用的身份验证方案的性质来正确保护连接。例如，依赖于个人用户身份验证的服务通常要求使用TLS（&amp;ldquo;传输层安全性&amp;rdquo;，&amp;ldquo; [依赖个人用户身份验证的服务通常需要使用TLS（&amp;ldquo;传输层安全性&amp;rdquo;，&amp;ldquo; [依赖个人用户身份验证的服务通常需要使用TLS（&amp;ldquo;传输层安全性&amp;rdquo;，&amp;ldquo; [&lt;a href=&quot;https://tools.ietf.org/html/rfc5246&quot;&gt;RFC5246&lt;/a&gt; ]）之前交换任何凭据。</target>
        </trans-unit>
        <trans-unit id="d8d09b5015d287016b84da909b78b11d8d4463c3" translate="yes" xml:space="preserve">
          <source>The HTTP conditional request header fields [&lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC7232&lt;/a&gt;] allow a client
   to place a precondition on the state of the target resource, so that
   the action corresponding to the method semantics will not be applied
   if the precondition evaluates to false.  Each precondition defined by 

   this specification consists of a comparison between a set of
   validators obtained from prior representations of the target resource
   to the current state of validators for the selected representation
   (&lt;a href=&quot;#section-7.2&quot;&gt;Section 7.2&lt;/a&gt;).  Hence, these preconditions evaluate whether the state
   of the target resource has changed since a given state known by the
   client.  The effect of such an evaluation depends on the method
   semantics and choice of conditional, as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-5&quot;&gt;Section&amp;nbsp;5 of
   [RFC7232]&lt;/a&gt;.

   +---------------------+--------------------------+
   | Header Field Name   | Defined in...            |
   +---------------------+--------------------------+
   | If-Match            | &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.1&quot;&gt;Section&amp;nbsp;3.1 of [RFC7232]&lt;/a&gt; |
   | If-None-Match       | &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.2&quot;&gt;Section&amp;nbsp;3.2 of [RFC7232]&lt;/a&gt; |
   | If-Modified-Since   | &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.3&quot;&gt;Section&amp;nbsp;3.3 of [RFC7232]&lt;/a&gt; |
   | If-Unmodified-Since | &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.4&quot;&gt;Section&amp;nbsp;3.4 of [RFC7232]&lt;/a&gt; |
   | If-Range            | &lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-3.2&quot;&gt;Section&amp;nbsp;3.2 of [RFC7233]&lt;/a&gt; |
   +---------------------+--------------------------+</source>
          <target state="translated">HTTP条件请求标头字段[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC7232&lt;/a&gt; ]允许客户端在目标资源的状态上放置前提条件，以便如果前提条件评估为false，则将不应用与方法语义相对应的操作。本规范定义的每个前提条件包括从目标资源的先前表示获得的一组验证器与所选表示形式的验证器当前状态之间的比较（&lt;a href=&quot;#section-7.2&quot;&gt;第7.2节&lt;/a&gt;）。因此，这些前提条件评估自客户端已知给定状态以来目标资源的状态是否已更改。这种评估的效果取决于方法的语义和条件的选择，如&lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-5&quot;&gt;[RFC7232]的第5节&lt;/a&gt;。 + --------------------- + -------------------------- + |标头字段名称|定义于... | + --------------------- + -------------------------- + |如果匹配| &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.1&quot;&gt;[RFC7232]的第3.1节&lt;/a&gt; | |如果不匹配| &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.2&quot;&gt;[RFC7232]的3.2节&lt;/a&gt; | | If-Modified-Since | &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.3&quot;&gt;[RFC7232]的3.3节&lt;/a&gt; | | If-Unmodified-Since | &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.4&quot;&gt;[RFC7232]的3.4节&lt;/a&gt; | |如果范围| &lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-3.2&quot;&gt;[RFC7233]的3.2节&lt;/a&gt; | + --------------------- + -------------------------- +</target>
        </trans-unit>
        <trans-unit id="db5702e7098e5089b43ae75747b9b4a1f88a17e6" translate="yes" xml:space="preserve">
          <source>The HTTP method being used by the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; request is not included in the list of methods specified by the response's &lt;a href=&quot;../../headers/access-control-allow-methods&quot;&gt;&lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt;&lt;/a&gt; header. This header specifies a comma-delineated list of the HTTP methods which may be used when using CORS to access the URL specified in the request; if the request is using any other method, this error occurs.</source>
          <target state="translated">由&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt;请求使用的HTTP方法未包含在响应的&lt;a href=&quot;../../headers/access-control-allow-methods&quot;&gt; &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; &lt;/a&gt;标头指定的方法列表中。此标头指定HTTP方法的逗号分隔列表，当使用CORS访问请求中指定的URL时可以使用该HTTP方法。如果请求使用任何其他方法，则会发生此错误。</target>
        </trans-unit>
        <trans-unit id="9a5f8b591cdf4b19c28a4fbbf2ef71bf29cedf58" translate="yes" xml:space="preserve">
          <source>The HTTP protocol is a request/response protocol. A client sends a
   request to the server in the form of a request method, URI, and
   protocol version, followed by a MIME-like message containing request
   modifiers, client information, and possible body content over a
   connection with a server. The server responds with a status line,
   including the message's protocol version and a success or error code,
   followed by a MIME-like message containing server information, entity
   metainformation, and possible entity-body content. The relationship
   between HTTP and MIME is described in appendix 19.4.

   Most HTTP communication is initiated by a user agent and consists of
   a request to be applied to a resource on some origin server. In the
   simplest case, this may be accomplished via a single connection (v)
   between the user agent (UA) and the origin server (O).

          request chain ------------------------&amp;gt;
       UA -------------------v------------------- O
          &amp;lt;----------------------- response chain

   A more complicated situation occurs when one or more intermediaries
   are present in the request/response chain. There are three common
   forms of intermediary: proxy, gateway, and tunnel. A proxy is a
   forwarding agent, receiving requests for a URI in its absolute form,
   rewriting all or part of the message, and forwarding the reformatted
   request toward the server identified by the URI. A gateway is a
   receiving agent, acting as a layer above some other server(s) and, if
   necessary, translating the requests to the underlying server's
   protocol. A tunnel acts as a relay point between two connections
   without changing the messages; tunnels are used when the
   communication needs to pass through an intermediary (such as a
   firewall) even when the intermediary cannot understand the contents
   of the messages.

          request chain --------------------------------------&amp;gt;
       UA -----v----- A -----v----- B -----v----- C -----v----- O
          &amp;lt;------------------------------------- response chain

   The figure above shows three intermediaries (A, B, and C) between the
   user agent and origin server. A request or response message that
   travels the whole chain will pass through four separate connections.
   This distinction is important because some HTTP communication options 

   may apply only to the connection with the nearest, non-tunnel
   neighbor, only to the end-points of the chain, or to all connections
   along the chain. Although the diagram is linear, each participant may
   be engaged in multiple, simultaneous communications. For example, B
   may be receiving requests from many clients other than A, and/or
   forwarding requests to servers other than C, at the same time that it
   is handling A's request.

   Any party to the communication which is not acting as a tunnel may
   employ an internal cache for handling requests. The effect of a cache
   is that the request/response chain is shortened if one of the
   participants along the chain has a cached response applicable to that
   request. The following illustrates the resulting chain if B has a
   cached copy of an earlier response from O (via C) for a request which
   has not been cached by UA or A.

          request chain ----------&amp;gt;
       UA -----v----- A -----v----- B - - - - - - C - - - - - - O
          &amp;lt;--------- response chain

   Not all responses are usefully cacheable, and some requests may
   contain modifiers which place special requirements on cache behavior.
   HTTP requirements for cache behavior and cacheable responses are
   defined in &lt;a href=&quot;#section-13&quot;&gt;section 13&lt;/a&gt;.

   In fact, there are a wide variety of architectures and configurations
   of caches and proxies currently being experimented with or deployed
   across the World Wide Web. These systems include national hierarchies
   of proxy caches to save transoceanic bandwidth, systems that
   broadcast or multicast cache entries, organizations that distribute
   subsets of cached data via CD-ROM, and so on. HTTP systems are used
   in corporate intranets over high-bandwidth links, and for access via
   PDAs with low-power radio links and intermittent connectivity. The
   goal of HTTP/1.1 is to support the wide diversity of configurations
   already deployed while introducing protocol constructs that meet the
   needs of those who build web applications that require high
   reliability and, failing that, at least reliable indications of
   failure.

   HTTP communication usually takes place over TCP/IP connections. The
   default port is TCP 80 [&lt;a href=&quot;#ref-19&quot;&gt;19&lt;/a&gt;], but other ports can be used. This does
   not preclude HTTP from being implemented on top of any other protocol
   on the Internet, or on other networks. HTTP only presumes a reliable
   transport; any protocol that provides such guarantees can be used;
   the mapping of the HTTP/1.1 request and response structures onto the
   transport data units of the protocol in question is outside the scope
   of this specification. 

   In HTTP/1.0, most implementations used a new connection for each
   request/response exchange. In HTTP/1.1, a connection may be used for
   one or more request/response exchanges, although connections may be
   closed for a variety of reasons (see &lt;a href=&quot;#section-8.1&quot;&gt;section 8.1&lt;/a&gt;).</source>
          <target state="translated">HTTP协议是请求/响应协议。客户端以请求方法，URI和协议版本的形式向服务器发送请求，然后通过与服务器的连接发送类似MIME的消息，其中包含请求修饰符，客户端信息以及可能的主体内容。服务器以状态行作为响应，包括消息的协议版本和成功或错误代码，后跟类似MIME的消息，其中包含服务器信息，实体元信息以及可能的实体主体内容。 HTTP和MIME之间的关系在附录19.4中描述。大多数HTTP通信都是由用户代理发起的，由要应用于某个原始服务器上的资源的请求组成。在最简单的情况下，这可以通过用户代理（UA）与原始服务器（O）之间的单个连接（v）来完成。请求链------------------------&amp;gt; UA ------------------- v-- ----------------- O &amp;lt;-----------------------响应链当请求/响应链中存在一个或多个中介。有三种常见的中介形式：代理，网关和隧道。代理是转发代理，它以绝对形式接收对URI的请求，重写消息的全部或部分，然后将重新格式化的请求转发给URI标识的服务器。网关是接收代理，充当其他一些服务器之上的一层，并在必要时将请求转换为基础服务器的协议。隧道充当两个连接之间的中继点，而不会更改消息。当通信需要通过中间设备（例如防火墙）时，即使中间设备无法理解消息的内容，也可以使用隧道。请求链--------------------------------------&amp;gt; UA ----- v-- --- A ----- v ----- B ----- v ----- C ----- v ----- O &amp;lt;--------- ----------------------------响应链上图显示了用户代理和源之间的三个中介（A，B和C）服务器。遍及整个链的请求或响应消息将通过四个单独的连接。这种区别很重要，因为某些HTTP通信选项可能仅适用于与最近的非隧道邻居的连接，仅到链的端点，或链的所有连接。尽管该图是线性的，但是每个参与者都可以参与多个同时的通信。例如，B在处理A的请求的同时，可能正在从A以外的许多客户端接收请求，和/或将请求转发到C以外的服务器。不充当隧道的通信的任何一方都可以使用内部缓存来处理请求。缓存的效果是，如果链中的参与者之一具有适用于该请求的缓存响应，则请求/响应链会缩短。下图说明了如果B拥有来自O（通过C）对O的较早响应的缓存副本的结果链，而该响应尚未由UA或A缓存。请求链----------&amp;gt; UA ----- v ----- A ----- v ----- B------C----- -O &amp;lt;---------响应链并非所有响应都可以有效地缓存，并且某些请求可能包含对缓存行为有特殊要求的修饰符。缓存行为和可缓存响应的HTTP要求在&lt;a href=&quot;#section-13&quot;&gt;第13条&lt;/a&gt;。实际上，目前有各种各样的缓存和代理的体系结构和配置正在试验或部署在万维网上。这些系统包括用于节省跨洋带宽的代理缓存的国家层次结构，广播或多播缓存条目的系统，通过CD-ROM分发缓存数据的子集的组织等等。 HTTP系统用于企业内联网中的高带宽链接，并通过具有低功率无线电链接和间歇性连接的PDA进行访问。 HTTP / 1.1的目标是支持已经部署的多种配置，同时引入协议构造，以满足那些构建Web应用程序的需求，这些应用程序需要高可靠性，如果失败，至少要提供可靠的故障指示。HTTP通信通常通过TCP / IP连接进行。默认端口为TCP 80 [&lt;a href=&quot;#ref-19&quot;&gt;19&lt;/a&gt; ]，但可以使用其他端口。这并不排除HTTP可以在Internet或其他网络上的任何其他协议之上实现。 HTTP仅假定可靠的传输。可以使用提供此类保证的任何协议； HTTP / 1.1请求和响应结构到所讨论协议的传输数据单元上的映射超出了本规范的范围。在HTTP / 1.0中，大多数实现都为每个请求/响应交换使用新的连接。在HTTP / 1.1中，尽管出于各种原因连接可能会关闭，但连接可用于一个或多个请求/响应交换（请参阅&lt;a href=&quot;#section-8.1&quot;&gt;第8.1节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="711fba1dbcca7b38687dec5dcf6d2cbe1d22690a" translate="yes" xml:space="preserve">
          <source>The HTTP protocol specifies a request method called &lt;a href=&quot;methods/connect&quot;&gt;&lt;code&gt;CONNECT&lt;/code&gt;&lt;/a&gt;. It starts two-way communications with the requested resource and can be used to open a tunnel. This is how a client behind an HTTP proxy can access websites using SSL (i.e. HTTPS, port 443). Note, however, that not all proxy servers support the &lt;code&gt;CONNECT&lt;/code&gt; method or limit it to port 443 only.</source>
          <target state="translated">HTTP协议指定了一种称为&lt;a href=&quot;methods/connect&quot;&gt; &lt;code&gt;CONNECT&lt;/code&gt; &lt;/a&gt;的请求方法。它开始与请求的资源进行双向通信，并可用于打开隧道。这就是HTTP代理后面的客户端可以使用SSL（即HTTPS，端口443）访问网站的方式。但是请注意，并非所有代理服务器都支持 &lt;code&gt;CONNECT&lt;/code&gt; 方法或将其限制为仅端口443。</target>
        </trans-unit>
        <trans-unit id="a45670933a882d376a78839281d063695249e118" translate="yes" xml:space="preserve">
          <source>The HTTP protocol used in those early phases was very simple, later dubbed HTTP/0.9, and sometimes as the one-line protocol.</source>
          <target state="translated">早期阶段使用的HTTP协议非常简单,后来被称为HTTP/0.9,有时也被称为单行协议。</target>
        </trans-unit>
        <trans-unit id="8b8c615279d732a85c03cf31a496dadc0ee7a1e0" translate="yes" xml:space="preserve">
          <source>The HTTP request headers</source>
          <target state="translated">HTTP请求头</target>
        </trans-unit>
        <trans-unit id="dc91001bcd5977c42287ce1ec14f986765b8a528" translate="yes" xml:space="preserve">
          <source>The HTTP response headers</source>
          <target state="translated">HTTP响应头</target>
        </trans-unit>
        <trans-unit id="eb8587eac722cc07a0cd8556b058eb4e29c05d63" translate="yes" xml:space="preserve">
          <source>The HTTP status code of the resource on which the global object was instantiated.</source>
          <target state="translated">实例化全局对象的资源的HTTP状态码。</target>
        </trans-unit>
        <trans-unit id="7642977e6ce54243574090f3f5103dcd8214c71f" translate="yes" xml:space="preserve">
          <source>The HTTP version used in the request is not supported by the server.</source>
          <target state="translated">请求中使用的HTTP版本不被服务器支持。</target>
        </trans-unit>
        <trans-unit id="0cf1515c8e62f4e6628b5f0c81397855080991ba" translate="yes" xml:space="preserve">
          <source>The HTTP/1.1 standard defines list of the standard headers that start server-driven negotiation (&lt;a href=&quot;headers/accept&quot;&gt;&lt;code&gt;Accept&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;headers/accept-charset&quot;&gt;&lt;code&gt;Accept-Charset&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;headers/accept-encoding&quot;&gt;&lt;code&gt;Accept-Encoding&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;headers/accept-language&quot;&gt;&lt;code&gt;Accept-Language&lt;/code&gt;&lt;/a&gt;). Though strictly speaking &lt;a href=&quot;headers/user-agent&quot;&gt;&lt;code&gt;User-Agent&lt;/code&gt;&lt;/a&gt; is not in this list, it is sometimes also used to send a specific representation of the requested resource, though this is not considered as a good practice. The server uses the &lt;a href=&quot;headers/vary&quot;&gt;&lt;code&gt;Vary&lt;/code&gt;&lt;/a&gt; header to indicate which headers it actually used for content negotiation (or more precisely the associated response headers), so that &lt;a href=&quot;caching&quot;&gt;caches&lt;/a&gt; can work optimally.</source>
          <target state="translated">HTTP / 1.1标准定义了启动服务器驱动的协商的标准标头的列表（&lt;a href=&quot;headers/accept&quot;&gt; &lt;code&gt;Accept&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;headers/accept-charset&quot;&gt; &lt;code&gt;Accept-Charset&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;headers/accept-encoding&quot;&gt; &lt;code&gt;Accept-Encoding&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;headers/accept-language&quot;&gt; &lt;code&gt;Accept-Language&lt;/code&gt; &lt;/a&gt;）。尽管严格说来，&lt;a href=&quot;headers/user-agent&quot;&gt; &lt;code&gt;User-Agent&lt;/code&gt; &lt;/a&gt;不在此列表中，但有时也用于发送所请求资源的特定表示形式，尽管这不是一种好的做法。服务器使用&lt;a href=&quot;headers/vary&quot;&gt; &lt;code&gt;Vary&lt;/code&gt; &lt;/a&gt;标头来指示其实际用于内容协商的标头（或更确切地说是相关联的响应标头），以便&lt;a href=&quot;caching&quot;&gt;缓存&lt;/a&gt;可以最佳地工作。</target>
        </trans-unit>
        <trans-unit id="ed9884f0209355d73677c39f7ea1c603c1d343ae" translate="yes" xml:space="preserve">
          <source>The HTTP/2 binary framing mechanism has been designed to not require any alteration of the APIs or config files applied: it is broadly transparent to the user.</source>
          <target state="translated">HTTP/2二进制框架机制被设计成不需要改变任何应用的API或配置文件:它对用户广泛透明。</target>
        </trans-unit>
        <trans-unit id="eab0e3a9f6070e36846c5fd400fcb4bef4e35044" translate="yes" xml:space="preserve">
          <source>The HTTP/2 header field encoding allows the expression of names that
   are not valid field names in the Internet Message Syntax used by
   HTTP/1.1.  Requests or responses containing invalid header field
   names MUST be treated as malformed (&lt;a href=&quot;#section-8.1.2.6&quot;&gt;Section 8.1.2.6&lt;/a&gt;).  An
   intermediary therefore cannot translate an HTTP/2 request or response
   containing an invalid field name into an HTTP/1.1 message.

   Similarly, HTTP/2 allows header field values that are not valid.
   While most of the values that can be encoded will not alter header
   field parsing, carriage return (CR, ASCII 0xd), line feed (LF, ASCII
   0xa), and the zero character (NUL, ASCII 0x0) might be exploited by
   an attacker if they are translated verbatim.  Any request or response
   that contains a character not permitted in a header field value MUST
   be treated as malformed (&lt;a href=&quot;#section-8.1.2.6&quot;&gt;Section 8.1.2.6&lt;/a&gt;).  Valid characters are
   defined by the &quot;field-content&quot; ABNF rule in &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;Section&amp;nbsp;3.2 of [RFC7230]&lt;/a&gt;.</source>
          <target state="translated">HTTP / 2标头字段编码允许在HTTP / 1.1使用的Internet消息语法中表达不是有效字段名称的名称。包含无效头域名称的请求或响应必须被视为格式错误（&lt;a href=&quot;#section-8.1.2.6&quot;&gt;第8.1.2.6节&lt;/a&gt;）。因此，中介程序不能将包含无效字段名称的HTTP / 2请求或响应转换为HTTP / 1.1消息。同样，HTTP / 2允许无效的标头字段值。尽管大多数可以编码的值都不会更改标头字段的解析，但是攻击者可能会利用回车符（CR，ASCII 0xd），换行符（LF，ASCII 0xa）和零字符（NUL，ASCII 0x0）如果将它们逐字翻译。包含标头字段值中不允许的字符的任何请求或响应都必须被视为格式错误（&lt;a href=&quot;#section-8.1.2.6&quot;&gt;第8.1.2.6节&lt;/a&gt;）。有效字符由&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;[RFC7230]的3.2节中&lt;/a&gt;的&amp;ldquo;字段内容&amp;rdquo; ABNF规则定义。</target>
        </trans-unit>
        <trans-unit id="dc2a35fa99cfd317dd5558de4b34fa07535768f1" translate="yes" xml:space="preserve">
          <source>The HTTP/2 protocol has several prime differences from the HTTP/1.1 version:</source>
          <target state="translated">HTTP/2协议与HTTP/1.1版本有几个首要区别。</target>
        </trans-unit>
        <trans-unit id="5ab1960130a01b920907a6e30a6c6e0c01c3afed" translate="yes" xml:space="preserve">
          <source>The HTTP/2 specification is split into four parts:

   o  Starting HTTP/2 (&lt;a href=&quot;#section-3&quot;&gt;Section 3&lt;/a&gt;) covers how an HTTP/2 connection is
      initiated.

   o  The frame (&lt;a href=&quot;#section-4&quot;&gt;Section 4&lt;/a&gt;) and stream (&lt;a href=&quot;#section-5&quot;&gt;Section 5&lt;/a&gt;) layers describe the
      way HTTP/2 frames are structured and formed into multiplexed
      streams.

   o  Frame (&lt;a href=&quot;#section-6&quot;&gt;Section 6&lt;/a&gt;) and error (&lt;a href=&quot;#section-7&quot;&gt;Section 7&lt;/a&gt;) definitions include
      details of the frame and error types used in HTTP/2.

   o  HTTP mappings (&lt;a href=&quot;#section-8&quot;&gt;Section 8&lt;/a&gt;) and additional requirements (&lt;a href=&quot;#section-9&quot;&gt;Section 9&lt;/a&gt;)
      describe how HTTP semantics are expressed using frames and
      streams.

   While some of the frame and stream layer concepts are isolated from
   HTTP, this specification does not define a completely generic frame
   layer.  The frame and stream layers are tailored to the needs of the
   HTTP protocol and server push.</source>
          <target state="translated">HTTP / 2规范分为四个部分：o启动HTTP / 2（&lt;a href=&quot;#section-3&quot;&gt;第3节&lt;/a&gt;）介绍如何初始化HTTP / 2连接。o帧（&lt;a href=&quot;#section-4&quot;&gt;第4节&lt;/a&gt;）和流（&lt;a href=&quot;#section-5&quot;&gt;第5节&lt;/a&gt;）层描述了HTTP / 2帧的结构并将其形成为复用流的方式。o框架（&lt;a href=&quot;#section-6&quot;&gt;第6节&lt;/a&gt;）和错误（&lt;a href=&quot;#section-7&quot;&gt;第7节&lt;/a&gt;）定义包括HTTP / 2中使用的框架和错误类型的详细信息。o HTTP映射（&lt;a href=&quot;#section-8&quot;&gt;第8节&lt;/a&gt;）和其他要求（&lt;a href=&quot;#section-9&quot;&gt;第9节）&lt;/a&gt;）描述了如何使用框架和流来表达HTTP语义。尽管某些框架和流层概念与HTTP隔离，但此规范并未定义完全通用的框架层。帧和流层是根据HTTP协议和服务器推送的需求量身定制的。</target>
        </trans-unit>
        <trans-unit id="99fbf8dd0978f7db7e2a91bcbd770cc0ec6b4bcd" translate="yes" xml:space="preserve">
          <source>The Host request-header field specifies the Internet host and port
   number of the resource being requested, as obtained from the original
   URI given by the user or referring resource (generally an HTTP URL, 

   as described in &lt;a href=&quot;#section-3.2.2&quot;&gt;section 3.2.2&lt;/a&gt;). The Host field value MUST represent
   the naming authority of the origin server or gateway given by the
   original URL. This allows the origin server or gateway to
   differentiate between internally-ambiguous URLs, such as the root &quot;/&quot;
   URL of a server for multiple host names on a single IP address.

       Host = &quot;Host&quot; &quot;:&quot; host [ &quot;:&quot; port ] ; &lt;a href=&quot;#section-3.2.2&quot;&gt;Section 3.2.2&lt;/a&gt;

   A &quot;host&quot; without any trailing port information implies the default
   port for the service requested (e.g., &quot;80&quot; for an HTTP URL). For
   example, a request on the origin server for
   &amp;lt;&lt;a href=&quot;http://www.w3.org/pub/WWW/&quot;&gt;http://www.w3.org/pub/WWW/&lt;/a&gt;&amp;gt; would properly include:

       GET /pub/WWW/ HTTP/1.1
       Host: www.w3.org

   A client MUST include a Host header field in all HTTP/1.1 request
   messages . If the requested URI does not include an Internet host
   name for the service being requested, then the Host header field MUST
   be given with an empty value. An HTTP/1.1 proxy MUST ensure that any
   request message it forwards does contain an appropriate Host header
   field that identifies the service being requested by the proxy. All
   Internet-based HTTP/1.1 servers MUST respond with a 400 (Bad Request)
   status code to any HTTP/1.1 request message which lacks a Host header
   field.

   See sections &lt;a href=&quot;#section-5.2&quot;&gt;5.2&lt;/a&gt; and &lt;a href=&quot;#section-19.6.1.1&quot;&gt;19.6.1.1&lt;/a&gt; for other requirements relating to
   Host.</source>
          <target state="translated">主机请求标头字段指定从用户给定的原始URI或引用资源（通常为HTTP URL，如&lt;a href=&quot;#section-3.2.2&quot;&gt;第3.2.2节中&lt;/a&gt;所述）获得的所请求资源的Internet主机和端口号。主机字段值必须表示原始URL所指定的原始服务器或网关的命名权限。这允许源服务器或网关在内部模棱两可的URL之间进行区分，例如单个IP地址上多个主机名的服务器的根&amp;ldquo; /&amp;rdquo; URL。 Host =&amp;ldquo;主机&amp;rdquo;&amp;ldquo;：&amp;rdquo;主机[&amp;ldquo;：&amp;rdquo;端口]; &lt;a href=&quot;#section-3.2.2&quot;&gt;第3.2.2节&lt;/a&gt; 没有任何尾随端口信息的&amp;ldquo;主机&amp;rdquo;表示所请求服务的默认端口（例如，HTTP URL为&amp;ldquo; 80&amp;rdquo;）。例如，原始服务器上的&amp;lt; &lt;a href=&quot;http://www.w3.org/pub/WWW/&quot;&gt;http://www.w3.org/pub/WWW/&lt;/a&gt;&amp;gt;将正确包含：GET /pub/WWW/HTTP/1.1主机：www.w3.org客户端必须在所有HTTP / 1.1请求消息中包含主机标头字段。如果所请求的URI不包含所请求服务的Internet主机名，则&amp;ldquo;主机头&amp;rdquo;字段必须给出一个空值。 HTTP / 1.1代理必须确保其转发的任何请求消息均包含适当的Host标头字段，该字段标识代理所请求的服务。所有基于Internet的HTTP / 1.1服务器必须对任何缺少主机头字段的HTTP / 1.1请求消息以400（错误请求）状态码进行响应。有关主机的其他要求，请参见&lt;a href=&quot;#section-5.2&quot;&gt;5.2&lt;/a&gt;和&lt;a href=&quot;#section-19.6.1.1&quot;&gt;19.6.1.1&lt;/a&gt;节。</target>
        </trans-unit>
        <trans-unit id="c397d086f53828c604451e8255fdaa21db19ac88" translate="yes" xml:space="preserve">
          <source>The Host request-header field specifies the Internet host and port
   number of the resource being requested, as obtained from the original
   URI given by the user or referring resource (generally an HTTP URL, 

   as described in &lt;a href=&quot;#section-3.2.2&quot;&gt;section 3.2.2&lt;/a&gt;). The Host field value MUST represent
   the naming authority of the origin server or gateway given by the
   original URL. This allows the origin server or gateway to
   differentiate between internally-ambiguous URLs, such as the root &quot;/&quot;
   URL of a server for multiple host names on a single IP address.

       Host = &quot;Host&quot; &quot;:&quot; host [ &quot;:&quot; port ] ; &lt;a href=&quot;#section-3.2.2&quot;&gt;Section 3.2.2&lt;/a&gt;

   A &quot;host&quot; without any trailing port information implies the default
   port for the service requested (e.g., &quot;80&quot; for an HTTP URL). For
   example, a request on the origin server for
   &amp;lt;&lt;a href=&quot;https://www.w3.org/pub/WWW/&quot;&gt;http://www.w3.org/pub/WWW/&lt;/a&gt;&amp;gt; would properly include:

       GET /pub/WWW/ HTTP/1.1
       Host: www.w3.org

   A client MUST include a Host header field in all HTTP/1.1 request
   messages . If the requested URI does not include an Internet host
   name for the service being requested, then the Host header field MUST
   be given with an empty value. An HTTP/1.1 proxy MUST ensure that any
   request message it forwards does contain an appropriate Host header
   field that identifies the service being requested by the proxy. All
   Internet-based HTTP/1.1 servers MUST respond with a 400 (Bad Request)
   status code to any HTTP/1.1 request message which lacks a Host header
   field.

   See sections &lt;a href=&quot;#section-5.2&quot;&gt;5.2&lt;/a&gt; and &lt;a href=&quot;#section-19.6.1.1&quot;&gt;19.6.1.1&lt;/a&gt; for other requirements relating to
   Host.</source>
          <target state="translated">主机请求标头字段指定从用户给定的原始URI或引用资源（通常为HTTP URL，如&lt;a href=&quot;#section-3.2.2&quot;&gt;第3.2.2节中&lt;/a&gt;所述）获得的所请求资源的Internet主机和端口号。主机字段值必须表示原始URL所指定的原始服务器或网关的命名权限。这允许源服务器或网关在内部模棱两可的URL之间进行区分，例如单个IP地址上多个主机名的服务器的根&amp;ldquo; /&amp;rdquo; URL。 Host =&amp;ldquo;主机&amp;rdquo;&amp;ldquo;：&amp;rdquo;主机[&amp;ldquo;：&amp;rdquo;端口]; &lt;a href=&quot;#section-3.2.2&quot;&gt;3.2.2节中&lt;/a&gt;没有任何尾随端口信息的&amp;ldquo;主机&amp;rdquo;意味着所请求服务的默认端口（例如，HTTP URL为&amp;ldquo; 80&amp;rdquo;）。例如，源服务器上对&amp;lt;&lt;a href=&quot;https://www.w3.org/pub/WWW/&quot;&gt;http://www.w3.org/pub/WWW/&lt;/a&gt; &amp;gt;将正确包含：GET / pub / WWW / HTTP / 1.1主机：www.w3.org客户端必须在所有HTTP / 1.1请求消息中包含主机标头字段。如果所请求的URI不包含所请求服务的Internet主机名，则&amp;ldquo;主机头&amp;rdquo;字段必须给出一个空值。 HTTP / 1.1代理务必确保其转发的任何请求消息均包含适当的Host标头字段，该字段标识由代理请求的服务。所有基于Internet的HTTP / 1.1服务器必须对任何缺少主机头字段的HTTP / 1.1请求消息以400（错误请求）状态码进行响应。有关主机的其他要求，请参见第&lt;a href=&quot;#section-5.2&quot;&gt;5.2&lt;/a&gt;和&lt;a href=&quot;#section-19.6.1.1&quot;&gt;19.6.1.1&lt;/a&gt;节。</target>
        </trans-unit>
        <trans-unit id="3b1aa4a92939a94846182a9752d0647f06200784" translate="yes" xml:space="preserve">
          <source>The Hyper Text Coffee Pot Control Protocol for Tea Efflux Appliances (HTCPCP-TEA)</source>
          <target state="translated">超文本咖啡壶控制协议的茶叶流出设备(HTCPCP-TEA)。</target>
        </trans-unit>
        <trans-unit id="2fbdae656d9bef10ff135384ea52e37645e6d50f" translate="yes" xml:space="preserve">
          <source>The Hyper Text Coffee Pot Control Protocol for Tea Efflux Appliances (HTCPCP-TEA): Response Codes</source>
          <target state="translated">超文本咖啡壶控制协议的茶水流出设备(HTCPCP-TEA)。响应代码</target>
        </trans-unit>
        <trans-unit id="1867896c3b2397819388475788a0bf4abcbf5ed6" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;202 Accepted&lt;/strong&gt;&lt;/code&gt; response status code indicates that the request has been accepted for processing, but the processing has not been completed; in fact, processing may not have started yet. The request might or might not eventually be acted upon, as it might be disallowed when processing actually takes place.</source>
          <target state="translated">超文本传输​​协议（HTTP） &lt;code&gt;&lt;strong&gt;202 Accepted&lt;/strong&gt;&lt;/code&gt; 响应状态代码表示请求已被接受进行处理，但处理尚未完成；实际上，处理可能尚未开始。该请求最终可能会执行，也可能不会最终执行，因为在实际进行处理时可能会不允许该请求。</target>
        </trans-unit>
        <trans-unit id="6fa10aaa19ccd9183c515b022dab356e9181ff7f" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;202 Accepted&lt;/strong&gt;&lt;/code&gt; response status code indicates that the request has been received but not yet acted upon. It is non-committal, meaning that there is no way for the HTTP to later send an asynchronous response indicating the outcome of processing the request. It is intended for cases where another process or server handles the request, or for batch processing.</source>
          <target state="translated">超文本传输​​协议（HTTP） &lt;code&gt;&lt;strong&gt;202 Accepted&lt;/strong&gt;&lt;/code&gt; 响应状态代码指示已接收到请求但尚未执行该请求。这是非承诺性的，这意味着HTTP无法稍后发送指示响应请求结果的异步响应。它用于其他进程或服务器处理请求的情况，或用于批处理。</target>
        </trans-unit>
        <trans-unit id="8da2e56e0326733411c384ee9df3d066f1be28c3" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;301 Moved Permanently&lt;/strong&gt;&lt;/code&gt; redirect status response code indicates that the resource requested has been definitively moved to the URL given by the &lt;a href=&quot;../headers/location&quot;&gt;&lt;code&gt;Location&lt;/code&gt;&lt;/a&gt; headers. A browser redirects to this page and search engines update their links to the resource (in 'SEO-speak', it is said that the 'link-juice' is sent to the new URL).</source>
          <target state="translated">&lt;code&gt;&lt;strong&gt;301 Moved Permanently&lt;/strong&gt;&lt;/code&gt; 的超文本传输​​协议（HTTP）&lt;strong&gt;301&lt;/strong&gt;重定向状态响应代码指示所请求的资源已确定地移动到&lt;a href=&quot;../headers/location&quot;&gt; &lt;code&gt;Location&lt;/code&gt; &lt;/a&gt;头给出的URL 。浏览器重定向到此页面，搜索引擎更新其到资源的链接（在&amp;ldquo; SEO说&amp;rdquo;中，据说&amp;ldquo; link-juice&amp;rdquo;被发送到新的URL）。</target>
        </trans-unit>
        <trans-unit id="bca235dd87a759f1a9dd3bfa9203b6546d063663" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;302 Found&lt;/strong&gt;&lt;/code&gt; redirect status response code indicates that the resource requested has been temporarily moved to the URL given by the &lt;a href=&quot;../headers/location&quot;&gt;&lt;code&gt;Location&lt;/code&gt;&lt;/a&gt; header. A browser redirects to this page but search engines don't update their links to the resource (in 'SEO-speak', it is said that the 'link-juice' is not sent to the new URL).</source>
          <target state="translated">找到的超文本传输​​协议（HTTP） &lt;code&gt;&lt;strong&gt;302 Found&lt;/strong&gt;&lt;/code&gt; 重定向状态响应代码指示所请求的资源已被临时移动到&lt;a href=&quot;../headers/location&quot;&gt; &lt;code&gt;Location&lt;/code&gt; &lt;/a&gt;标头提供的URL 。浏览器重定向到此页面，但是搜索引擎不会更新其到资源的链接（在&amp;ldquo; SEO说&amp;rdquo;中，据说&amp;ldquo; link-juice&amp;rdquo;没有发送到新的URL）。</target>
        </trans-unit>
        <trans-unit id="a0dc42b9614cba52b23ba38ea15b1e9d7488ecb2" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;303 See Other&lt;/strong&gt;&lt;/code&gt; redirect status response code indicates that the redirects don't link to the newly uploaded resources but to another page, like a confirmation page or an upload progress page. This response code is usually sent back as a result of &lt;a href=&quot;../methods/put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt;. The method used to display this redirected page is always &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">超文本传输​​协议（HTTP） &lt;code&gt;&lt;strong&gt;303 See Other&lt;/strong&gt;&lt;/code&gt; 重定向状态响应代码，指示重定向不链接到新上传的资源，而是链接到另一个页面，如确认页面或上传进度页面。此响应代码通常作为&lt;a href=&quot;../methods/put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt;的结果发送回去。用于显示此重定向页面的方法始终是&lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6d5990b78312268a2a1237e68fb338dd4e8d416f" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;303 See Other&lt;/strong&gt;&lt;/code&gt; redirect status response code indicates that the redirects don't link to the newly uploaded resources, but to another page (such as a confirmation page or an upload progress page). This response code is usually sent back as a result of &lt;a href=&quot;../methods/put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt;. The method used to display this redirected page is always &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">超文本传输​​协议（HTTP） &lt;code&gt;&lt;strong&gt;303 See Other&lt;/strong&gt;&lt;/code&gt; 重定向状态响应代码，指示重定向不链接到新上传的资源，而是链接到另一个页面（例如，确认页面或上传进度页面）。此响应代码通常作为&lt;a href=&quot;../methods/put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt;的结果发送回去。用于显示此重定向页面的方法始终是&lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3108347112af1e3d29e6704655c39459a5034ad0" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;308 Permanent Redirect&lt;/strong&gt;&lt;/code&gt; redirect status response code indicates that the resource requested has been definitively moved to the URL given by the &lt;a href=&quot;../headers/location&quot;&gt;&lt;code&gt;Location&lt;/code&gt;&lt;/a&gt; headers. A browser redirects to this page and search engines update their links to the resource (in 'SEO-speak', it is said that the 'link-juice' is sent to the new URL).</source>
          <target state="translated">超文本传输​​协议（HTTP） &lt;code&gt;&lt;strong&gt;308 Permanent Redirect&lt;/strong&gt;&lt;/code&gt; 重定向状态响应代码指示所请求的资源已确定地移动到&lt;a href=&quot;../headers/location&quot;&gt; &lt;code&gt;Location&lt;/code&gt; &lt;/a&gt;标头提供的URL 。浏览器重定向到此页面，搜索引擎更新其到资源的链接（在&amp;ldquo; SEO说&amp;rdquo;中，据说&amp;ldquo; link-juice&amp;rdquo;被发送到新的URL）。</target>
        </trans-unit>
        <trans-unit id="cbd8493e7cce398f69ed55cb6bb5f24186092644" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;400 Bad Request&lt;/strong&gt;&lt;/code&gt; response status code indicates that the server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing).</source>
          <target state="translated">超文本传输​​协议（HTTP） &lt;code&gt;&lt;strong&gt;400 Bad Request&lt;/strong&gt;&lt;/code&gt; 响应状态代码表示服务器由于某些被视为客户端错误（例如格式错误的请求语法，无效的请求消息框架或欺骗性请求）而无法或将不会处理请求路由）。</target>
        </trans-unit>
        <trans-unit id="2055230dbe836c1aaf7bd92cbe0fa85f1440c7fc" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;400 Bad Request&lt;/strong&gt;&lt;/code&gt; response status code indicates that the server could not understand the request due to invalid syntax.</source>
          <target state="translated">超文本传输​​协议（HTTP） &lt;code&gt;&lt;strong&gt;400 Bad Request&lt;/strong&gt;&lt;/code&gt; 响应状态代码表示服务器由于语法无效而无法理解该请求。</target>
        </trans-unit>
        <trans-unit id="15ac14cd04fa900b118bba5f014d31ab3bbfe121" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;405 Method Not Allowed&lt;/strong&gt;&lt;/code&gt; response status code indicates that the request method is known by the server but is not supported by the target resource.</source>
          <target state="translated">超文本传输​​协议（HTTP） &lt;code&gt;&lt;strong&gt;405 Method Not Allowed&lt;/strong&gt;&lt;/code&gt; 响应状态代码指示请求方法是服务器已知的，但目标资源不支持该方法。</target>
        </trans-unit>
        <trans-unit id="60871008192002b75675780fc635a2b570a2bf8c" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;406 Not Acceptable&lt;/strong&gt;&lt;/code&gt; client error response code indicates that the server cannot produce a response matching the list of acceptable values defined in the request's proactive &lt;a href=&quot;../content_negotiation&quot;&gt;content negotiation&lt;/a&gt; headers, and that the server is unwilling to supply a default representation.</source>
          <target state="translated">超文本传输​​协议（HTTP） &lt;code&gt;&lt;strong&gt;406 Not Acceptable&lt;/strong&gt;&lt;/code&gt; 客户端错误响应代码表示服务器无法生成与请求的主动&lt;a href=&quot;../content_negotiation&quot;&gt;内容协&lt;/a&gt;商标头中定义的可接受值列表相匹配的响应，并且服务器不愿提供默认表示。</target>
        </trans-unit>
        <trans-unit id="6d70feb7e34e129ebc5526b0c592e1fdbf1c816e" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;408 Request Timeout&lt;/strong&gt;&lt;/code&gt; response status code means that the server would like to shut down this unused connection. It is sent on an idle connection by some servers, &lt;em&gt;even without any previous request by the client&lt;/em&gt;.</source>
          <target state="translated">超文本传输​​协议（HTTP） &lt;code&gt;&lt;strong&gt;408 Request Timeout&lt;/strong&gt;&lt;/code&gt; 响应状态代码表示服务器希望关闭此未使用的连接。&lt;em&gt;即使没有客户端的任何先前请求，&lt;/em&gt;某些服务器&lt;em&gt;也会&lt;/em&gt;通过空闲连接发送它。</target>
        </trans-unit>
        <trans-unit id="a66fb4f3fae8e6c063276dcb5237ee845eeca4ed" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;410 Gone&lt;/strong&gt;&lt;/code&gt; client error response code indicates that access to the target resource is no longer available at the origin server and that this condition is likely to be permanent.</source>
          <target state="translated">超文本传输​​协议（HTTP） &lt;code&gt;&lt;strong&gt;410 Gone&lt;/strong&gt;&lt;/code&gt; 客户端错误响应代码指示在源服务器上不再可以访问目标资源，并且这种情况很可能是永久的。</target>
        </trans-unit>
        <trans-unit id="4b9a35e682079b0a683f989a76db71ce57aae81d" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;411 Length Required&lt;/strong&gt;&lt;/code&gt; client error response code indicates that the server refuses to accept the request without a defined &lt;a href=&quot;../headers/content-length&quot;&gt;&lt;code&gt;Content-Length&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">超文本传输​​协议（HTTP） &lt;code&gt;&lt;strong&gt;411 Length Required&lt;/strong&gt;&lt;/code&gt; 客户端错误响应代码指示服务器拒绝接受没有定义的&lt;a href=&quot;../headers/content-length&quot;&gt; &lt;code&gt;Content-Length&lt;/code&gt; &lt;/a&gt;标头的请求。</target>
        </trans-unit>
        <trans-unit id="731510b854954129731e069eb6b3d2e9019b2fdc" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;412 Precondition Failed&lt;/strong&gt;&lt;/code&gt; client error response code indicates that access to the target resource has been denied. This happens with conditional requests on methods other than &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt; when the condition defined by the &lt;a href=&quot;../headers/if-unmodified-since&quot;&gt;&lt;code&gt;If-Unmodified-Since&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../headers/if-none-match&quot;&gt;&lt;code&gt;If-None-Match&lt;/code&gt;&lt;/a&gt; headers is not fulfilled. In that case, the request, usually an upload or a modification of a resource, cannot be made and this error response is sent back.</source>
          <target state="translated">超文本传输​​协议（HTTP） &lt;code&gt;&lt;strong&gt;412 Precondition Failed&lt;/strong&gt;&lt;/code&gt; 客户端错误响应代码表示对目标资源的访问已被拒绝。&lt;a href=&quot;../headers/if-none-match&quot;&gt; &lt;code&gt;If-None-Match&lt;/code&gt; &lt;/a&gt;不满足&lt;a href=&quot;../headers/if-unmodified-since&quot;&gt; &lt;code&gt;If-Unmodified-Since&lt;/code&gt; &lt;/a&gt;或If-None-Match标头定义的条件，则对&lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; &lt;/a&gt;以外的方法的条件请求会发生这种情况。在这种情况下，通常无法进行请求（通常是资源的上载或修改），并将此错误响应发送回去。</target>
        </trans-unit>
        <trans-unit id="95dad23f3e8d87cfe4b0b1791422ccff7fdb0ec9" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;416 Range Not Satisfiable&lt;/strong&gt;&lt;/code&gt; error response code indicates that a server cannot serve the requested ranges. The most likely reason is that the document doesn't contain such ranges, or that the &lt;a href=&quot;../headers/range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; header value, though syntactically correct, doesn't make sense.</source>
          <target state="translated">超文本传输​​协议（HTTP） &lt;code&gt;&lt;strong&gt;416 Range Not Satisfiable&lt;/strong&gt;&lt;/code&gt; 无法&lt;strong&gt;满足&lt;/strong&gt;错误响应代码指示服务器无法满足请求的范围。最可能的原因是文档不包含此类范围，或者&lt;a href=&quot;../headers/range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt;头值（尽管从语法上来说是正确的）没有意义。</target>
        </trans-unit>
        <trans-unit id="99f1059b5dc6332a65c7949a31d1b45cbce33ed7" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;422 Unprocessable Entity&lt;/strong&gt;&lt;/code&gt; response status code indicates that the server understands the content type of the request entity, and the syntax of the request entity is correct, but it was unable to process the contained instructions.</source>
          <target state="translated">超文本传输​​协议（HTTP） &lt;code&gt;&lt;strong&gt;422 Unprocessable Entity&lt;/strong&gt;&lt;/code&gt; 响应状态代码指示服务器理解请求实体的内容类型，并且请求实体的语法正确，但是无法处理所包含的指令。</target>
        </trans-unit>
        <trans-unit id="630618c062b0adb0b4e53d21c6ec93a1ffc8709b" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;425 Too Early&lt;/strong&gt;&lt;/code&gt; response status code indicates that the server is unwilling to risk processing a request that might be replayed, which creates the potential for a replay attack.</source>
          <target state="translated">超文本传输​​协议（HTTP） &lt;code&gt;&lt;strong&gt;425 Too Early&lt;/strong&gt;&lt;/code&gt; 响应状态代码表示服务器不愿意冒可能处理可能被重播的请求的风险，这可能会导致重播攻击。</target>
        </trans-unit>
        <trans-unit id="2ba79c25bd016d25902460c531a9af1832ad5084" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;451 Unavailable For Legal Reasons&lt;/strong&gt;&lt;/code&gt; client error response code indicates that the user requested a resource that is not available due to legal reasons, such as a web page for which a legal action has been issued.</source>
          <target state="translated">由于法律原因而无法使用的超文本传输​​协议（HTTP） &lt;code&gt;&lt;strong&gt;451 Unavailable For Legal Reasons&lt;/strong&gt;&lt;/code&gt; 客户端错误响应代码指示用户请求了由于法律原因而无法使用的资源，例如已对其采取法律行动的网页。</target>
        </trans-unit>
        <trans-unit id="b137e360e4b5274b152a6bc5424bdda215ece645" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;500 Internal Server Error&lt;/strong&gt;&lt;/code&gt; server error response code indicates that the server encountered an unexpected condition that prevented it from fulfilling the request.</source>
          <target state="translated">超文本传输​​协议（HTTP） &lt;code&gt;&lt;strong&gt;500 Internal Server Error&lt;/strong&gt;&lt;/code&gt; 服务器错误响应代码表明服务器遇到意外状况，阻止其满足请求。</target>
        </trans-unit>
        <trans-unit id="9c744578cdc0d9bb57ba2e4e4ab0fa07c99379e2" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;501 Not Implemented&lt;/strong&gt;&lt;/code&gt; server error response code indicates that the request method is not supported by the server and cannot be handled. The only methods that servers are required to support (and therefore that must not return this code) are &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">超文本传输​​协议（HTTP） &lt;code&gt;&lt;strong&gt;501 Not Implemented&lt;/strong&gt;&lt;/code&gt; 服务器错误响应代码表示该请求方法不受服务器支持，无法处理。要求服务器支持的唯一方法（因此不能返回此代码）是&lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1db14053efdc5b849d20c165c505ccbdce0af60c" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;501 Not Implemented&lt;/strong&gt;&lt;/code&gt; server error response code means that &lt;strong&gt;the server does not support the functionality required to fulfill the request&lt;/strong&gt;.</source>
          <target state="translated">超文本传输​​协议（HTTP） &lt;code&gt;&lt;strong&gt;501 Not Implemented&lt;/strong&gt;&lt;/code&gt; 服务器错误响应代码表示&lt;strong&gt;服务器不支持满足请求所需的功能&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="c56e521d7943d1bf8ac9d8be1e1d2c5a9c11ad29" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;502 Bad Gateway&lt;/strong&gt;&lt;/code&gt; server error response code indicates that the server, while acting as a gateway or proxy, received an invalid response from the upstream server.</source>
          <target state="translated">超文本传输​​协议（HTTP） &lt;code&gt;&lt;strong&gt;502 Bad Gateway&lt;/strong&gt;&lt;/code&gt; 服务器错误响应代码指示该服务器在充当网关或代理的同时，从上游服务器接收到无效响应。</target>
        </trans-unit>
        <trans-unit id="d97095b9bce2f7dabb2319cf5e31ce5cd055c7fe" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;503 Service Unavailable&lt;/strong&gt;&lt;/code&gt; server error response code indicates that the server is not ready to handle the request.</source>
          <target state="translated">超文本传输​​协议（HTTP） &lt;code&gt;&lt;strong&gt;503 Service Unavailable&lt;/strong&gt;&lt;/code&gt; 服务器错误响应代码指示服务器尚未准备好处理请求。</target>
        </trans-unit>
        <trans-unit id="ed70120131ebb0a274691c4d30386f6dc8fc669c" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;504 Gateway Timeout&lt;/strong&gt;&lt;/code&gt; server error response code indicates that the server, while acting as a gateway or proxy, cannot get a response in time.</source>
          <target state="translated">超文本传输​​协议（HTTP） &lt;code&gt;&lt;strong&gt;504 Gateway Timeout&lt;/strong&gt;&lt;/code&gt; 服务器错误响应代码指示服务器充当网关或代理时，无法及时获得响应。</target>
        </trans-unit>
        <trans-unit id="a75a514de375190ba5cb2f8574ec6665fc8a648c" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;504 Gateway Timeout&lt;/strong&gt;&lt;/code&gt; server error response code indicates that the server, while acting as a gateway or proxy, did not get a response in time from the upstream server that it needed in order to complete the request.</source>
          <target state="translated">超文本传输​​协议（HTTP） &lt;code&gt;&lt;strong&gt;504 Gateway Timeout&lt;/strong&gt;&lt;/code&gt; 服务器错误响应代码表明，充当网关或代理的服务器未及时从上游服务器获得其为完成请求所需的响应。</target>
        </trans-unit>
        <trans-unit id="5206e7fbe439a4fe0558730cbd561b9d56ad71ad" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;505 HTTP Version Not Supported&lt;/strong&gt;&lt;/code&gt; response status code indicates that the HTTP version used in the request is not supported by the server.</source>
          <target state="translated">超文本传输​​协议（HTTP） &lt;code&gt;&lt;strong&gt;505 HTTP Version Not Supported&lt;/strong&gt;&lt;/code&gt; 的HTTP版本响应状态代码表示服务器不支持请求中使用的HTTP版本。</target>
        </trans-unit>
        <trans-unit id="49ce1d6f6a8be4676edf766aee4540297f25f76a" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;506 Variant Also Negotiates&lt;/strong&gt;&lt;/code&gt; response status code may be given in the context of Transparent Content Negotiation (see &lt;a href=&quot;https://tools.ietf.org/html/rfc2295&quot;&gt;RFC 2295&lt;/a&gt;). This protocol enables a client to retrieve the best variant of a given resource, where the server supports multiple variants.</source>
          <target state="translated">超文本传输​​协议（HTTP） &lt;code&gt;&lt;strong&gt;506 Variant Also Negotiates&lt;/strong&gt;&lt;/code&gt; 可以在透明内容协商的上下文中给出响应状态代码（请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc2295&quot;&gt;RFC 2295&lt;/a&gt;）。该协议使客户端能够检索给定资源的最佳变体，其中服务器支持多个变体。</target>
        </trans-unit>
        <trans-unit id="820e5cef7a998998b0849eeb24e0fff1b6649bae" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;507 Insufficient Storage&lt;/strong&gt;&lt;/code&gt; response status code may be given in the context of the Web Distributed Authoring and Versioning (WebDAV) protocol (see &lt;a href=&quot;https://tools.ietf.org/html/rfc4918&quot;&gt;RFC 4918&lt;/a&gt;).</source>
          <target state="translated">可以在Web分布式创作和版本控制（WebDAV）协议（请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc4918&quot;&gt;RFC 4918&lt;/a&gt;）的上下文中给出超文本传输​​协议（HTTP） &lt;code&gt;&lt;strong&gt;507 Insufficient Storage&lt;/strong&gt;&lt;/code&gt; 响应状态代码。</target>
        </trans-unit>
        <trans-unit id="76d88c87ab8a315a60aa9543690290ffbfbdb653" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;508 Loop Detected&lt;/strong&gt;&lt;/code&gt; response status code may be given in the context of the Web Distributed Authoring and Versioning (WebDAV) protocol.</source>
          <target state="translated">超文本传输​​协议（HTTP） &lt;code&gt;&lt;strong&gt;508 Loop Detected&lt;/strong&gt;&lt;/code&gt; 响应状态代码可以在Web分布式创作和版本控制（WebDAV）协议的上下文中给出。</target>
        </trans-unit>
        <trans-unit id="81aa286d5750f499d27f8f17321bc45f7f2ca1f1" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;510 Not Extended&lt;/strong&gt;&lt;/code&gt; response status code is sent in the context of the HTTP Extension Framework, defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2774&quot;&gt;RFC 2774&lt;/a&gt;.</source>
          <target state="translated">在&lt;a href=&quot;https://tools.ietf.org/html/rfc2774&quot;&gt;RFC 2774中&lt;/a&gt;定义的HTTP扩展框架的上下文中发送超文本传输​​协议（HTTP） &lt;code&gt;&lt;strong&gt;510 Not Extended&lt;/strong&gt;&lt;/code&gt; 响应状态代码。</target>
        </trans-unit>
        <trans-unit id="2e3eb482b38eeaa5e40d4ddbab8b13b92a13f7fd" translate="yes" xml:space="preserve">
          <source>The Hypertext Transfer Protocol (HTTP) is a stateless application-
   level request/response protocol that uses extensible semantics and
   self-descriptive message payloads for flexible interaction with
   network-based hypertext information systems.  This document is the
   first in a series of documents that collectively form the HTTP/1.1
   specification:

   1.  &quot;Message Syntax and Routing&quot; (this document)

   2.  &quot;Semantics and Content&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt;]

   3.  &quot;Conditional Requests&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC7232&lt;/a&gt;]

   4.  &quot;Range Requests&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC7233&lt;/a&gt;]

   5.  &quot;Caching&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC7234&lt;/a&gt;]

   6.  &quot;Authentication&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc7235&quot;&gt;RFC7235&lt;/a&gt;]

   This HTTP/1.1 specification obsoletes &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt; and &lt;a href=&quot;https://tools.ietf.org/html/rfc2145&quot;&gt;RFC 2145&lt;/a&gt; (on HTTP
   versioning).  This specification also updates the use of CONNECT to
   establish a tunnel, previously defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2817&quot;&gt;RFC 2817&lt;/a&gt;, and defines the
   &quot;https&quot; URI scheme that was described informally in &lt;a href=&quot;https://tools.ietf.org/html/rfc2818&quot;&gt;RFC 2818&lt;/a&gt;.

   HTTP is a generic interface protocol for information systems.  It is
   designed to hide the details of how a service is implemented by
   presenting a uniform interface to clients that is independent of the
   types of resources provided.  Likewise, servers do not need to be
   aware of each client's purpose: an HTTP request can be considered in
   isolation rather than being associated with a specific type of client
   or a predetermined sequence of application steps.  The result is a
   protocol that can be used effectively in many different contexts and
   for which implementations can evolve independently over time.

   HTTP is also designed for use as an intermediation protocol for
   translating communication to and from non-HTTP information systems.
   HTTP proxies and gateways can provide access to alternative
   information services by translating their diverse protocols into a
   hypertext format that can be viewed and manipulated by clients in the
   same way as HTTP services.

   One consequence of this flexibility is that the protocol cannot be
   defined in terms of what occurs behind the interface.  Instead, we
   are limited to defining the syntax of communication, the intent of
   received communication, and the expected behavior of recipients.  If
   the communication is considered in isolation, then successful actions 

   ought to be reflected in corresponding changes to the observable
   interface provided by servers.  However, since multiple clients might
   act in parallel and perhaps at cross-purposes, we cannot require that
   such changes be observable beyond the scope of a single response.

   This document describes the architectural elements that are used or
   referred to in HTTP, defines the &quot;http&quot; and &quot;https&quot; URI schemes,
   describes overall network operation and connection management, and
   defines HTTP message framing and forwarding requirements.  Our goal
   is to define all of the mechanisms necessary for HTTP message
   handling that are independent of message semantics, thereby defining
   the complete set of requirements for message parsers and message-
   forwarding intermediaries.</source>
          <target state="translated">超文本传输​​协议（HTTP）是一种无状态的应用程序级请求/响应协议，它使用可扩展的语义和自描述消息有效负载来与基于网络的超文本信息系统进行灵活的交互。本文档是共同构成HTTP / 1.1规范的一系列文档中的第一篇：1.&amp;ldquo;消息语法和路由&amp;rdquo;（本文档）2.&amp;ldquo;语义和内容&amp;rdquo; [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt; ] 3.&amp;ldquo;条件请求&amp;rdquo; [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC7232&lt;/a&gt; ] 4.&amp;ldquo;范围请求&amp;rdquo; [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC7233&lt;/a&gt; ] 5.&amp;ldquo;缓存&amp;rdquo; [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC7234&lt;/a&gt; ] 6.&amp;ldquo;身份验证&amp;rdquo; [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7235&quot;&gt;RFC7235&lt;/a&gt; ]此HTTP / 1。1规范淘汰了&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt;和&lt;a href=&quot;https://tools.ietf.org/html/rfc2145&quot;&gt;RFC 2145&lt;/a&gt;（基于HTTP版本控制）。该规范还更新了CONNECT的使用，以建立先前在&lt;a href=&quot;https://tools.ietf.org/html/rfc2817&quot;&gt;RFC 2817中&lt;/a&gt;定义的隧道，并定义了在&lt;a href=&quot;https://tools.ietf.org/html/rfc2818&quot;&gt;RFC 2818&lt;/a&gt;中非正式描述的&amp;ldquo; https&amp;rdquo; URI方案。。 HTTP是信息系统的通用接口协议。它旨在通过向客户端呈现与提供的资源类型无关的统一接口来隐藏服务实现方式的详细信息。同样，服务器不需要知道每个客户端的目的：可以将HTTP请求视为孤立的请求，而不是与特定类型的客户端或应用程序的预定顺序相关联。结果是可以在许多不同的上下文中有效使用的协议，其实现可以随时间独立发展。 HTTP还被设计为用作中介协议，用于与非HTTP信息系统之间来回通信。HTTP代理和网关可以通过将其各种协议转换为超文本格式来提供对替代信息服务的访问权限，这些超文本格式可以由客户端以与HTTP服务相同的方式进行查看和操作。这种灵活性的结果是，无法根据接口后面发生的事情来定义协议。相反，我们仅限于定义通信的语法，接收到的通信的意图以及接收者的预期行为。如果孤立地考虑通信，那么成功的动作应该反映在对服务器提供的可观察接口的相应更改中。但是，由于多个客户可能会并行运行，甚至可能互为目的，我们不能要求这种变化超出单个响应的范围即可观察到。本文档描述了HTTP中使用或引用的体系结构元素，定义了&amp;ldquo; http&amp;rdquo;和&amp;ldquo; https&amp;rdquo; URI方案，描述了整个网络操作和连接管理，并定义了HTTP消息成帧和转发要求。我们的目标是定义与消息语义无关的HTTP消息处理所必需的所有机制，从而定义消息解析器和消息转发中介的完整要求集。描述整体网络操作和连接管理，并定义HTTP消息成帧和转发要求。我们的目标是定义与消息语义无关的HTTP消息处理所必需的所有机制，从而定义消息解析器和消息转发中介的完整要求集。描述整体网络操作和连接管理，并定义HTTP消息成帧和转发要求。我们的目标是定义与消息语义无关的HTTP消息处理所必需的所有机制，从而定义消息解析器和消息转发中介的完整要求集。</target>
        </trans-unit>
        <trans-unit id="265e7d56ba5f2b7320f23766ef7d78d6049d252e" translate="yes" xml:space="preserve">
          <source>The Hypertext Transfer Protocol (HTTP) is a wildly successful
   protocol.  However, the way HTTP/1.1 uses the underlying transport
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6&quot;&gt;[RFC7230], Section&amp;nbsp;6&lt;/a&gt;) has several characteristics that have a
   negative overall effect on application performance today.

   In particular, HTTP/1.0 allowed only one request to be outstanding at
   a time on a given TCP connection.  HTTP/1.1 added request pipelining,
   but this only partially addressed request concurrency and still
   suffers from head-of-line blocking.  Therefore, HTTP/1.0 and HTTP/1.1
   clients that need to make many requests use multiple connections to a
   server in order to achieve concurrency and thereby reduce latency.

   Furthermore, HTTP header fields are often repetitive and verbose,
   causing unnecessary network traffic as well as causing the initial
   TCP [&lt;a href=&quot;#ref-TCP&quot;&gt;TCP&lt;/a&gt;] congestion window to quickly fill.  This can result in
   excessive latency when multiple requests are made on a new TCP
   connection.

   HTTP/2 addresses these issues by defining an optimized mapping of
   HTTP's semantics to an underlying connection.  Specifically, it
   allows interleaving of request and response messages on the same
   connection and uses an efficient coding for HTTP header fields.  It
   also allows prioritization of requests, letting more important
   requests complete more quickly, further improving performance. 

   The resulting protocol is more friendly to the network because fewer
   TCP connections can be used in comparison to HTTP/1.x.  This means
   less competition with other flows and longer-lived connections, which
   in turn lead to better utilization of available network capacity.

   Finally, HTTP/2 also enables more efficient processing of messages
   through use of binary message framing.</source>
          <target state="translated">超文本传输​​协议（HTTP）是一种非常成功的协议。但是，HTTP / 1.1使用基础传输的方式（&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6&quot;&gt;[RFC7230]，第6节&lt;/a&gt;）具有多个特征，这些特征对当今的应用程序性能产生负面影响。特别是，HTTP / 1.0在给定的TCP连接上一次仅允许一个未完成的请求。 HTTP / 1.1添加了请求流水线处理，但这仅部分解决了请求并发问题，并且仍然受到行头阻塞的困扰。因此，需要发出许多请求的HTTP / 1.0和HTTP / 1.1客户端使用到服务器的多个连接以实现并发性，从而减少延迟。此外，HTTP标头字段通常是重复且冗长的，从而导致不必要的网络流量以及初始的TCP [ &lt;a href=&quot;#ref-TCP&quot;&gt;TCP&lt;/a&gt;]拥塞窗口可以快速填充。当在一个新的TCP连接上进行多个请求时，这可能导致过多的延迟。 HTTP / 2通过定义HTTP语义到基础连接的优化映射来解决这些问题。具体来说，它允许在同一连接上对请求消息和响应消息进行交织，并对HTTP标头字段使用有效的编码。它还允许对请求进行优先级排序，使更重要的请求更快地完成，从而进一步提高性能。生成的协议对网络更友好，因为与HTTP / 1.x相比，可以使用更少的TCP连接。这意味着与其他流量的竞争减少，连接寿命更长，从而可以更好地利用可用网络容量。最后，HTTP / 2还可以通过使用二进制消息框架来更有效地处理消息。</target>
        </trans-unit>
        <trans-unit id="bfba6f949d10bf9871b3c465a4b0c721c894d894" translate="yes" xml:space="preserve">
          <source>The Hypertext Transfer Protocol (HTTP) is an application-level
   protocol for distributed, collaborative, hypermedia information
   systems. HTTP has been in use by the World-Wide Web global
   information initiative since 1990. The first version of HTTP,
   referred to as HTTP/0.9, was a simple protocol for raw data transfer
   across the Internet. HTTP/1.0, as defined by &lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC 1945&lt;/a&gt; [&lt;a href=&quot;#ref-6&quot;&gt;6&lt;/a&gt;], improved
   the protocol by allowing messages to be in the format of MIME-like
   messages, containing metainformation about the data transferred and
   modifiers on the request/response semantics. However, HTTP/1.0 does
   not sufficiently take into consideration the effects of hierarchical
   proxies, caching, the need for persistent connections, or virtual
   hosts. In addition, the proliferation of incompletely-implemented
   applications calling themselves &quot;HTTP/1.0&quot; has necessitated a
   protocol version change in order for two communicating applications
   to determine each other's true capabilities.

   This specification defines the protocol referred to as &quot;HTTP/1.1&quot;.
   This protocol includes more stringent requirements than HTTP/1.0 in
   order to ensure reliable implementation of its features.

   Practical information systems require more functionality than simple
   retrieval, including search, front-end update, and annotation. HTTP
   allows an open-ended set of methods and headers that indicate the
   purpose of a request [&lt;a href=&quot;#ref-47&quot;&gt;47&lt;/a&gt;]. It builds on the discipline of reference
   provided by the Uniform Resource Identifier (URI) [&lt;a href=&quot;#ref-3&quot;&gt;3&lt;/a&gt;], as a location
   (URL) [&lt;a href=&quot;#ref-4&quot;&gt;4&lt;/a&gt;] or name (URN) [&lt;a href=&quot;#ref-20&quot;&gt;20&lt;/a&gt;], for indicating the resource to which a 

   method is to be applied. Messages are passed in a format similar to
   that used by Internet mail [&lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt;] as defined by the Multipurpose
   Internet Mail Extensions (MIME) [&lt;a href=&quot;#ref-7&quot;&gt;7&lt;/a&gt;].

   HTTP is also used as a generic protocol for communication between
   user agents and proxies/gateways to other Internet systems, including
   those supported by the SMTP [&lt;a href=&quot;#ref-16&quot;&gt;16&lt;/a&gt;], NNTP [&lt;a href=&quot;#ref-13&quot;&gt;13&lt;/a&gt;], FTP [&lt;a href=&quot;#ref-18&quot;&gt;18&lt;/a&gt;], Gopher [&lt;a href=&quot;#ref-2&quot;&gt;2&lt;/a&gt;],
   and WAIS [&lt;a href=&quot;#ref-10&quot;&gt;10&lt;/a&gt;] protocols. In this way, HTTP allows basic hypermedia
   access to resources available from diverse applications.</source>
          <target state="translated">超文本传输​​协议（HTTP）是分布式，协作式超媒体信息系统的应用程序级协议。自1990年以来，HTTP已由万维网全球信息倡议使用。HTTP的第一个版本称为HTTP / 0.9，是用于通过Internet传输原始数据的简单协议。 HTTP / 1.0，由&lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC 1945&lt;/a&gt; [ &lt;a href=&quot;#ref-6&quot;&gt;6&lt;/a&gt;]通过允许消息采用类似于MIME的消息格式来改进协议，其中包含有关所传输数据的元信息以及请求/响应语义上的修饰符。但是，HTTP / 1.0没有充分考虑分层代理，缓存，对持久连接的需求或虚拟主机的影响。另外，自称&amp;ldquo; HTTP / 1.0&amp;rdquo;的不完整应用程序的泛滥使协议版本必须更改，以便两个通信的应用程序确定彼此的真实功能。该规范定义了称为&amp;ldquo; HTTP / 1.1&amp;rdquo;的协议。该协议比HTTP / 1.0包含更严格的要求，以确保可靠地实现其功能。实用的信息系统需要比简单检索更多的功能，包括搜索，前端更新和注释。 HTTP允许一组开放式的方法和标头，用于指示请求的目的[&lt;a href=&quot;#ref-47&quot;&gt;47&lt;/a&gt; ]。它建立在统一资源标识符（URI）[ &lt;a href=&quot;#ref-3&quot;&gt;3&lt;/a&gt; ]作为位置（URL）[ &lt;a href=&quot;#ref-4&quot;&gt;4&lt;/a&gt; ]或名称（URN）[ &lt;a href=&quot;#ref-20&quot;&gt;20&lt;/a&gt; ] 提供的参考原则的基础上，用于指示要对其应用方法的资源。邮件以与多用途Internet邮件扩展（MIME）[ &lt;a href=&quot;#ref-7&quot;&gt;7&lt;/a&gt; ] 定义的Internet邮件[ &lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt; ] 相似的格式传递。 HTTP还用作用户代理与代理/网关到其他Internet系统之间通信的通用协议，包括SMTP [ &lt;a href=&quot;#ref-16&quot;&gt;16&lt;/a&gt; ]，NNTP [ &lt;a href=&quot;#ref-13&quot;&gt;13&lt;/a&gt; ]，FTP [ &lt;a href=&quot;#ref-18&quot;&gt;18&lt;/a&gt; ]，Gopher [ &lt;a href=&quot;#ref-2&quot;&gt;2&lt;/a&gt; ]和WAIS [WAS] 支持的那些代理&lt;a href=&quot;#ref-10&quot;&gt;10&lt;/a&gt; ]协议。这样，HTTP允许对各种应用程序可用资源的基本超媒体访问。</target>
        </trans-unit>
        <trans-unit id="1a129c42494254f3f39028a252991104523d52ce" translate="yes" xml:space="preserve">
          <source>The Hypertext Transfer Protocol Status Code 308 (Permanent Redirect)</source>
          <target state="translated">超文本传输协议状态码308(永久重定向)</target>
        </trans-unit>
        <trans-unit id="7c3eef52124b6a04770da43e5780935c839f5a5d" translate="yes" xml:space="preserve">
          <source>The IP address is invalid</source>
          <target state="translated">IP地址无效</target>
        </trans-unit>
        <trans-unit id="6eeb9098fe0eb68f08e0d43612ff763509c93784" translate="yes" xml:space="preserve">
          <source>The IP address is unreachable</source>
          <target state="translated">IP地址无法到达</target>
        </trans-unit>
        <trans-unit id="2f67a1bb61a74c01a68383ec9ae389f39adb9d3d" translate="yes" xml:space="preserve">
          <source>The If header has two distinct purposes:

   o  The first purpose is to make a request conditional by supplying a
      series of state lists with conditions that match tokens and ETags
      to a specific resource.  If this header is evaluated and all state
      lists fail, then the request MUST fail with a 412 (Precondition
      Failed) status.  On the other hand, the request can succeed only
      if one of the described state lists succeeds.  The success
      criteria for state lists and matching functions are defined in
      Sections &lt;a href=&quot;#section-10.4.3&quot;&gt;10.4.3&lt;/a&gt; and &lt;a href=&quot;#section-10.4.4&quot;&gt;10.4.4&lt;/a&gt;.

   o  Additionally, the mere fact that a state token appears in an If
      header means that it has been &quot;submitted&quot; with the request.  In
      general, this is used to indicate that the client has knowledge of
      that state token.  The semantics for submitting a state token
      depend on its type (for lock tokens, please refer to &lt;a href=&quot;#section-6&quot;&gt;Section 6&lt;/a&gt;).

   Note that these two purposes need to be treated distinctly: a state
   token counts as being submitted independently of whether the server
   actually has evaluated the state list it appears in, and also
   independently of whether or not the condition it expressed was found
   to be true.</source>
          <target state="translated">If头有两个不同的目的：o第一个目的是通过提供一系列条件列表来使请求成为条件，条件列表的条件将令牌和ETag匹配到特定资源。如果评估了这个头，并且所有状态列表都失败了，那么请求必须以412（失败的前提条件）状态失败。另一方面，仅当所描述的状态列表之一成功时，请求才能成功。状态列表和匹配功能的成功标准在&lt;a href=&quot;#section-10.4.3&quot;&gt;10.4.3&lt;/a&gt;和&lt;a href=&quot;#section-10.4.4&quot;&gt;10.4.4&lt;/a&gt;节中定义。 o此外，仅在状态标头中出现状态令牌的事实意味着它已与请求&amp;ldquo;一起提交&amp;rdquo;。通常，这用于指示客户端具有该状态令牌的知识。提交状态令牌的语义取决于其类型（关于锁定令牌，请参阅&lt;a href=&quot;#section-6&quot;&gt;第6节&lt;/a&gt;）。请注意，这两个目的需要加以区别对待：状态令牌被视为独立于服务器是否实际评估了其出现在其中的状态列表而提交，并且还独立于是否确定其所表示的条件为真。</target>
        </trans-unit>
        <trans-unit id="ef772a237bb19f58e37ac6262a206108449c06a7" translate="yes" xml:space="preserve">
          <source>The If request header is intended to have similar functionality to
   the If-Match header defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-14.24&quot;&gt;Section&amp;nbsp;14.24 of [RFC2616]&lt;/a&gt;.  However,
   the If header handles any state token as well as ETags.  A typical
   example of a state token is a lock token, and lock tokens are the
   only state tokens defined in this specification.</source>
          <target state="translated">If请求标头旨在具有与&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-14.24&quot;&gt;[RFC2616]的14.24节中&lt;/a&gt;定义的If-Match标头相似的功能。但是，If标头可处理任何状态令牌以及ETag。状态令牌的典型示例是锁定令牌，并且锁定令牌是本规范中定义的唯一状态令牌。</target>
        </trans-unit>
        <trans-unit id="f13702c8c2a26258beb9827d9b24d567b0373ca0" translate="yes" xml:space="preserve">
          <source>The If-Match request-header field is used with a method to make it
   conditional. A client that has one or more entities previously
   obtained from the resource can verify that one of those entities is
   current by including a list of their associated entity tags in the
   If-Match header field. Entity tags are defined in &lt;a href=&quot;#section-3.11&quot;&gt;section 3.11&lt;/a&gt;. The
   purpose of this feature is to allow efficient updates of cached
   information with a minimum amount of transaction overhead. It is also
   used, on updating requests, to prevent inadvertent modification of
   the wrong version of a resource. As a special case, the value &quot;*&quot;
   matches any current entity of the resource.

       If-Match = &quot;If-Match&quot; &quot;:&quot; ( &quot;*&quot; | 1#entity-tag )

   If any of the entity tags match the entity tag of the entity that
   would have been returned in the response to a similar GET request
   (without the If-Match header) on that resource, or if &quot;*&quot; is given 

   and any current entity exists for that resource, then the server MAY
   perform the requested method as if the If-Match header field did not
   exist.

   A server MUST use the strong comparison function (see &lt;a href=&quot;#section-13.3.3&quot;&gt;section 13.3.3&lt;/a&gt;)
   to compare the entity tags in If-Match.

   If none of the entity tags match, or if &quot;*&quot; is given and no current
   entity exists, the server MUST NOT perform the requested method, and
   MUST return a 412 (Precondition Failed) response. This behavior is
   most useful when the client wants to prevent an updating method, such
   as PUT, from modifying a resource that has changed since the client
   last retrieved it.

   If the request would, without the If-Match header field, result in
   anything other than a 2xx or 412 status, then the If-Match header
   MUST be ignored.

   The meaning of &quot;If-Match: *&quot; is that the method SHOULD be performed
   if the representation selected by the origin server (or by a cache,
   possibly using the Vary mechanism, see &lt;a href=&quot;#section-14.44&quot;&gt;section 14.44&lt;/a&gt;) exists, and
   MUST NOT be performed if the representation does not exist.

   A request intended to update a resource (e.g., a PUT) MAY include an
   If-Match header field to signal that the request method MUST NOT be
   applied if the entity corresponding to the If-Match value (a single
   entity tag) is no longer a representation of that resource. This
   allows the user to indicate that they do not wish the request to be
   successful if the resource has been changed without their knowledge.
   Examples:

       If-Match: &quot;xyzzy&quot;
       If-Match: &quot;xyzzy&quot;, &quot;r2d2xxxx&quot;, &quot;c3piozzzz&quot;
       If-Match: *

   The result of a request having both an If-Match header field and
   either an If-None-Match or an If-Modified-Since header fields is
   undefined by this specification.</source>
          <target state="translated">If-Match请求标头字段与使它成为条件的方法一起使用。具有先前从资源获得的一个或多个实体的客户端可以通过在If-Match标头字段中包括其关联的实体标签的列表来验证这些实体之一是当前的。实体标签在&lt;a href=&quot;#section-3.11&quot;&gt;3.11节&lt;/a&gt;中定义。此功能的目的是允许以最少的事务开销有效地更新缓存的信息。在更新请求时，也可以使用它来防止对错误版本的资源进行无意的修改。在特殊情况下，值&amp;ldquo; *&amp;rdquo;与资源的任何当前实体匹配。 If-Match =&amp;ldquo; If-Match&amp;rdquo;&amp;ldquo;：&amp;rdquo;（&amp;ldquo; *&amp;rdquo; | 1＃entity-tag）如果任何实体标签与在响应类似GET请求的响应中已返回的实体的实体标签相匹配（在该资源上没有If-Match标头），或者如果给定了&amp;ldquo; *&amp;rdquo;并且该资源存在任何当前实体，则服务器可以执行请求的方法，就像If-Match标头字段不存在一样。服务器必须使用强比较功能（请参阅&lt;a href=&quot;#section-13.3.3&quot;&gt;第13.3.3节&lt;/a&gt;）以比较If-Match中的实体标签。如果没有任何实体标签匹配，或者给出了&amp;ldquo; *&amp;rdquo;，并且当前实体不存在，则服务器不得执行请求的方法，并且必须返回412（失败的前提条件）响应。当客户端希望阻止诸如PUT之类的更新方法修改自客户端上次检索该资源以来已更改的资源时，此行为最有用。如果该请求在没有If-Match头域的情况下导致2xx或412状态以外的其他任何情况，则必须忽略If-Match头。 &amp;ldquo; If-Match：*&amp;rdquo;的含义是，如果源服务器（或缓存，可能使用Vary机制）选择了表示形式，则应执行该方法，请参见&lt;a href=&quot;#section-14.44&quot;&gt;14.44节&lt;/a&gt;）存在，并且如果该表示不存在，则不得执行。旨在更新资源的请求（例如，PUT）可能包括If-Match头域，以信号通知如果与If-Match值相对应的实体（单个实体标签）不再存在，则必须不应用该请求方法该资源的表示。如果资源在他们不知情的情况下被更改，这允许用户指示他们不希望请求成功。示例：If-Match：&amp;ldquo; xyzzy&amp;rdquo; If-Match：&amp;ldquo; xyzzy&amp;rdquo;，&amp;ldquo; r2d2xxxx&amp;rdquo;，&amp;ldquo; c3piozzzz&amp;rdquo; If-Match：*请求的结果同时具有If-Match头字段和If-None-Match或If-Modified-Since标头字段未由该规范定义。</target>
        </trans-unit>
        <trans-unit id="9436a493b897cd39a84206566701a405b2d51016" translate="yes" xml:space="preserve">
          <source>The If-Modified-Since request-header field is used with a method to
   make it conditional: if the requested variant has not been modified
   since the time specified in this field, an entity will not be
   returned from the server; instead, a 304 (not modified) response will
   be returned without any message-body.

       If-Modified-Since = &quot;If-Modified-Since&quot; &quot;:&quot; HTTP-date 

   An example of the field is:

       If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT

   A GET method with an If-Modified-Since header and no Range header
   requests that the identified entity be transferred only if it has
   been modified since the date given by the If-Modified-Since header.
   The algorithm for determining this includes the following cases:

      a) If the request would normally result in anything other than a
         200 (OK) status, or if the passed If-Modified-Since date is
         invalid, the response is exactly the same as for a normal GET.
         A date which is later than the server's current time is
         invalid.

      b) If the variant has been modified since the If-Modified-Since
         date, the response is exactly the same as for a normal GET.

      c) If the variant has not been modified since a valid If-
         Modified-Since date, the server SHOULD return a 304 (Not
         Modified) response.

   The purpose of this feature is to allow efficient updates of cached
   information with a minimum amount of transaction overhead.

      Note: The Range request-header field modifies the meaning of If-
      Modified-Since; see &lt;a href=&quot;#section-14.35&quot;&gt;section 14.35&lt;/a&gt; for full details.

      Note: If-Modified-Since times are interpreted by the server, whose
      clock might not be synchronized with the client.

      Note: When handling an If-Modified-Since header field, some
      servers will use an exact date comparison function, rather than a
      less-than function, for deciding whether to send a 304 (Not
      Modified) response. To get best results when sending an If-
      Modified-Since header field for cache validation, clients are
      advised to use the exact date string received in a previous Last-
      Modified header field whenever possible.

      Note: If a client uses an arbitrary date in the If-Modified-Since
      header instead of a date taken from the Last-Modified header for
      the same request, the client should be aware of the fact that this
      date is interpreted in the server's understanding of time. The
      client should consider unsynchronized clocks and rounding problems
      due to the different encodings of time between the client and
      server. This includes the possibility of race conditions if the
      document has changed between the time it was first requested and
      the If-Modified-Since date of a subsequent request, and the 

      possibility of clock-skew-related problems if the If-Modified-
      Since date is derived from the client's clock without correction
      to the server's clock. Corrections for different time bases
      between client and server are at best approximate due to network
      latency.

   The result of a request having both an If-Modified-Since header field
   and either an If-Match or an If-Unmodified-Since header fields is
   undefined by this specification.</source>
          <target state="translated">If-Modified-Since请求标头字段与有条件的方法一起使用：如果自此字段中指定的时间以来所请求的变体没有被修改，则不会从服务器返回实体；相反，将返回304（未修改）响应，而没有任何消息正文。 If-Modified-Since =&amp;ldquo; If-Modified-Since&amp;rdquo;&amp;ldquo;：&amp;rdquo; HTTP日期字段的示例为：If-Modified-Since：Sat，1994年10月29日19:43:31 GMT带有If-的GET方法Modified-Since标头和没有Range标头的请求仅当从If-Modified-Since标头给出的日期以来对已标识的实体进行了修改的情况下，才转移所标识的实体。确定这种情况的算法包括以下几种情况：a）如果该请求通常会导致200（OK）状态以外的任何结果，或者所传递的If-Modified-Since日期无效，则响应与正常GET完全相同。迟于服务器当前时间的日期无效。 b）如果自If-Modified-Since日期以来对变体进行了修改，则响应与正常GET完全相同。 c）如果自有效的If-Modified-Since日期以来尚未修改变体，则服务器应返回304（未修改）响应。此功能的目的是允许以最少的事务开销有效地更新缓存的信息。注意：范围请求标头字段修改了If-Modified-Since的含义；看到或者，如果传递的If-Modified-Since日期无效，则响应与正常GET完全相同。迟于服务器当前时间的日期无效。 b）如果自If-Modified-Since日期以来对变体进行了修改，则响应与正常GET完全相同。 c）如果自有效的If-Modified-Since日期以来尚未修改变体，则服务器应返回304（未修改）响应。此功能的目的是允许以最少的事务开销有效地更新缓存的信息。注意：范围请求标头字段修改了If-Modified-Since的含义；看到或如果传递的If-Modified-Since日期无效，则响应与正常GET完全相同。迟于服务器当前时间的日期无效。 b）如果自If-Modified-Since日期以来对变体进行了修改，则响应与正常GET完全相同。 c）如果自有效的If-Modified-Since日期以来尚未修改变体，则服务器应返回304（未修改）响应。此功能的目的是允许以最少的事务开销有效地更新缓存的信息。注意：范围请求标头字段修改了If-Modified-Since的含义；看到迟于服务器当前时间的日期无效。 b）如果自If-Modified-Since日期以来对变体进行了修改，则响应与正常GET完全相同。 c）如果自有效的If-Modified-Since日期以来尚未修改变体，则服务器应返回304（未修改）响应。此功能的目的是允许以最少的事务开销有效地更新缓存的信息。注意：范围请求标头字段修改了If-Modified-Since的含义；看到迟于服务器当前时间的日期无效。 b）如果自If-Modified-Since日期以来对变体进行了修改，则响应与正常GET完全相同。 c）如果自有效的If-Modified-Since日期以来尚未修改变体，则服务器应返回304（未修改）响应。此功能的目的是允许以最少的事务开销有效地更新缓存的信息。注意：范围请求标头字段修改了If-Modified-Since的含义；看到c）如果自有效的If-Modified-Since日期以来尚未修改变体，则服务器应返回304（未修改）响应。此功能的目的是允许以最少的事务开销有效地更新缓存的信息。注意：范围请求标头字段修改了If-Modified-Since的含义；看到c）如果自有效的If-Modified-Since日期以来尚未修改变体，则服务器应返回304（未修改）响应。此功能的目的是允许以最少的事务开销有效地更新缓存的信息。注意：范围请求标头字段修改了If-Modified-Since的含义；看到&lt;a href=&quot;#section-14.35&quot;&gt;第14.35条&lt;/a&gt;有关详细信息。注意：If-Modified-Since时间由服务器解释，其时钟可能未与客户端同步。注意：在处理If-Modified-Since标头字段时，某些服务器将使用精确的日期比较功能（而不是小于功能）来决定是否发送304（未修改）响应。为了在发送If-Modified-Since标头字段进行缓存验证时获得最佳结果，建议客户端尽可能使用在上一个Last-Modified标头字段中收到的确切日期字符串。注意：如果客户在If-Modified-Since标头中使用任意日期，而不是从同一请求的Last-Modified标头中获取日期，客户应意识到服务器在对时间的理解中会解释该日期。由于客户端和服务器之间的时间编码不同，客户端应考虑不同步的时钟和舍入问题。这包括：如果文档在第一次请求的时间与后续请求的If-Modified-Since日期之间发生更改，则可能出现竞争状况；如果If-Modified-Since日期，则可能存在时钟偏斜相关的问题。从客户端的时钟派生而无需校正服务器的时钟。由于网络延迟的缘故，对于客户端和服务器之间不同时基的修正最多是近似的。同时具有If-Modified-Since头字段和If-Match或If-Unmodified-Since头字段的请求结果在本规范中未定义。</target>
        </trans-unit>
        <trans-unit id="39e92741a96fab5452a65a932345457528d34e55" translate="yes" xml:space="preserve">
          <source>The If-None-Match request-header field is used with a method to make
   it conditional. A client that has one or more entities previously
   obtained from the resource can verify that none of those entities is
   current by including a list of their associated entity tags in the
   If-None-Match header field. The purpose of this feature is to allow
   efficient updates of cached information with a minimum amount of
   transaction overhead. It is also used to prevent a method (e.g. PUT)
   from inadvertently modifying an existing resource when the client
   believes that the resource does not exist.

   As a special case, the value &quot;*&quot; matches any current entity of the
   resource.

       If-None-Match = &quot;If-None-Match&quot; &quot;:&quot; ( &quot;*&quot; | 1#entity-tag )

   If any of the entity tags match the entity tag of the entity that
   would have been returned in the response to a similar GET request
   (without the If-None-Match header) on that resource, or if &quot;*&quot; is
   given and any current entity exists for that resource, then the
   server MUST NOT perform the requested method, unless required to do
   so because the resource's modification date fails to match that
   supplied in an If-Modified-Since header field in the request.
   Instead, if the request method was GET or HEAD, the server SHOULD
   respond with a 304 (Not Modified) response, including the cache-
   related header fields (particularly ETag) of one of the entities that
   matched. For all other request methods, the server MUST respond with
   a status of 412 (Precondition Failed).

   See &lt;a href=&quot;#section-13.3.3&quot;&gt;section 13.3.3&lt;/a&gt; for rules on how to determine if two entities tags
   match. The weak comparison function can only be used with GET or HEAD
   requests. 

   If none of the entity tags match, then the server MAY perform the
   requested method as if the If-None-Match header field did not exist,
   but MUST also ignore any If-Modified-Since header field(s) in the
   request. That is, if no entity tags match, then the server MUST NOT
   return a 304 (Not Modified) response.

   If the request would, without the If-None-Match header field, result
   in anything other than a 2xx or 304 status, then the If-None-Match
   header MUST be ignored. (See &lt;a href=&quot;#section-13.3.4&quot;&gt;section 13.3.4&lt;/a&gt; for a discussion of
   server behavior when both If-Modified-Since and If-None-Match appear
   in the same request.)

   The meaning of &quot;If-None-Match: *&quot; is that the method MUST NOT be
   performed if the representation selected by the origin server (or by
   a cache, possibly using the Vary mechanism, see &lt;a href=&quot;#section-14.44&quot;&gt;section 14.44&lt;/a&gt;)
   exists, and SHOULD be performed if the representation does not exist.
   This feature is intended to be useful in preventing races between PUT
   operations.

   Examples:

       If-None-Match: &quot;xyzzy&quot;
       If-None-Match: W/&quot;xyzzy&quot;
       If-None-Match: &quot;xyzzy&quot;, &quot;r2d2xxxx&quot;, &quot;c3piozzzz&quot;
       If-None-Match: W/&quot;xyzzy&quot;, W/&quot;r2d2xxxx&quot;, W/&quot;c3piozzzz&quot;
       If-None-Match: *

   The result of a request having both an If-None-Match header field and
   either an If-Match or an If-Unmodified-Since header fields is
   undefined by this specification.</source>
          <target state="translated">If-None-Match请求标头字段与使它成为条件的方法一起使用。具有先前从资源获得的一个或多个实体的客户端可以通过在If-None-Match标头字段中包括其关联的实体标签的列表来验证这些实体中没有一个是当前的。此功能的目的是允许以最少的事务开销有效地更新缓存的信息。当客户端认为该资源不存在时，它还可用于防止方法（例如PUT）无意中修改现有资源。在特殊情况下，值&amp;ldquo; *&amp;rdquo;与资源的任何当前实体匹配。 If-None-Match =&amp;ldquo; If-None-Match&amp;rdquo;&amp;ldquo;：&amp;rdquo;（&amp;ldquo; *&amp;rdquo;| 1＃entity-tag）是否有任何实体标签与该资源上对类似GET请求（没有If-None-Match标头）的响应中已返回的实体的实体标签匹配，或者&amp;ldquo; *给出&amp;ldquo;&amp;rdquo;，并且该资源存在任何当前实体，则服务器不得执行所请求的方法，除非需要这样做，因为资源的修改日期与请求中If-Modified-Since标头字段中提供的日期不匹配。相反，如果请求方法是GET或HEAD，则服务器应以304（未修改）响应进行响应，包括匹配的实体之一的与缓存相关的标头字段（尤其是ETag）。对于所有其他请求方法，服务器必须以状态412（前提失败）进行响应。看到看到看到看到看到那么服务器必须禁止执行请求的方法，除非需要这样做，因为资源的修改日期与请求中If-Modified-Since标头字段中提供的日期不匹配。相反，如果请求方法是GET或HEAD，则服务器应以304（未修改）响应进行响应，包括匹配的实体之一的与缓存相关的标头字段（尤其是ETag）。对于所有其他请求方法，服务器必须以状态412（前提失败）进行响应。看到那么服务器必须禁止执行请求的方法，除非需要这样做，因为资源的修改日期与请求中If-Modified-Since标头字段中提供的日期不匹配。相反，如果请求方法是GET或HEAD，则服务器应以304（未修改）响应进行响应，包括匹配的实体之一的与缓存相关的标头字段（尤其是ETag）。对于所有其他请求方法，服务器必须以状态412（前提失败）进行响应。看到服务器应该以304（未修改）响应进行响应，包括匹配的实体之一的与缓存相关的头字段（尤其是ETag）。对于所有其他请求方法，服务器必须以状态412（前提失败）进行响应。看到服务器应该以304（未修改）响应进行响应，包括匹配的实体之一的与缓存相关的头字段（尤其是ETag）。对于所有其他请求方法，服务器必须以状态412（前提失败）进行响应。看到&lt;a href=&quot;#section-13.3.3&quot;&gt;&lt;/a&gt;有关如何确定两个实体标签是否匹配的规则，请参见第13.3.3节。弱比较功能只能与GET或HEAD请求一起使用。如果没有一个实体标签匹配，则服务器可以执行请求的方法，就像If-None-Match头字段不存在一样，但是必须也忽略请求中的任何If-Modified-Since头字段。也就是说，如果没有任何实体标签匹配，则服务器务必不得返回304（未修改）响应。如果该请求在没有If-None-Match头字段的情况下导致2xx或304状态以外的任何其他情况，则必须忽略If-None-Match头。 （请参阅&lt;a href=&quot;#section-13.3.4&quot;&gt;第13.3.4节&lt;/a&gt;用于讨论在同一请求中同时出现If-Modified-Since和If-None-Match时的服务器行为。）&amp;ldquo; If-None-Match：*&amp;rdquo;的含义是，如果选择了表示形式，则不得执行该方法由原始服务器（或通过缓存，可能使用Vary机制），请参阅&lt;a href=&quot;#section-14.44&quot;&gt;第14.44节&lt;/a&gt;）存在，如果该表示不存在，则应该执行。此功能旨在防止PUT操作之间的冲突。示例：If-None-Match：&amp;ldquo; xyzzy&amp;rdquo; If-None-Match：W /&amp;ldquo; xyzzy&amp;rdquo; If-None-Match：&amp;ldquo; xyzzy&amp;rdquo;，&amp;ldquo; r2d2xxxx&amp;rdquo;，&amp;ldquo; c3piozzzz&amp;rdquo; If-None-Match：W /&amp;ldquo; xyzzy&amp;rdquo; ，W /&amp;ldquo; r2d2xxxx&amp;rdquo;，W /&amp;ldquo; c3piozzzz&amp;rdquo; If-None-Match：*具有If-None-Match头字段和If-Match或If-Unmodified-Since头字段的请求的结果是本规范未定义。</target>
        </trans-unit>
        <trans-unit id="a77607d9e035711baba5b97bc67fee22711422dd" translate="yes" xml:space="preserve">
          <source>The If-Unmodified-Since request-header field is used with a method to
   make it conditional. If the requested resource has not been modified
   since the time specified in this field, the server SHOULD perform the
   requested operation as if the If-Unmodified-Since header were not
   present.

   If the requested variant has been modified since the specified time,
   the server MUST NOT perform the requested operation, and MUST return
   a 412 (Precondition Failed).

      If-Unmodified-Since = &quot;If-Unmodified-Since&quot; &quot;:&quot; HTTP-date

   An example of the field is:

       If-Unmodified-Since: Sat, 29 Oct 1994 19:43:31 GMT

   If the request normally (i.e., without the If-Unmodified-Since
   header) would result in anything other than a 2xx or 412 status, the
   If-Unmodified-Since header SHOULD be ignored.

   If the specified date is invalid, the header is ignored.

   The result of a request having both an If-Unmodified-Since header
   field and either an If-None-Match or an If-Modified-Since header
   fields is undefined by this specification.</source>
          <target state="translated">If-Unmodified-Since request-header字段与一个方法一起使用,使其成为条件。如果被请求的资源自该字段指定的时间以来没有被修改过,则服务器SHOULD执行请求的操作,就像If-Unmodified-Since头不存在一样。如果请求的变体在指定的时间后被修改,服务器必须不执行请求的操作,并且必须返回一个412(预设条件失败)。If-Unmodified-Since=&quot;If-Unmodified-Since&quot; &quot;:&quot; HTTP-date 该字段的一个例子是:If-Unmodified-Since:Sat,29 Oct 1994 19:43:31 GMT 如果正常情况下(即没有If-Unmodified-Since头)请求的结果不是2xx或412状态,If-Unmodified-Since头应该被忽略。如果指定的日期是无效的,那么该头将被忽略。如果一个请求同时有If-Unmodified-Since头字段和If-None-Match或If-Modified-Since头字段,其结果在本规范中没有定义。</target>
        </trans-unit>
        <trans-unit id="fdfb0dc451f3880ef0d4f67dac2ee95582caadcf" translate="yes" xml:space="preserve">
          <source>The JavaScript function returns a single string</source>
          <target state="translated">该JavaScript函数返回一个字符串</target>
        </trans-unit>
        <trans-unit id="703e778a54d67833e0037322f76c267a64284bbc" translate="yes" xml:space="preserve">
          <source>The JavaScript function should always be saved to a file by itself and not be embedded in HTML.</source>
          <target state="translated">JavaScript函数应该总是被单独保存到一个文件中,而不是嵌入到HTML中。</target>
        </trans-unit>
        <trans-unit id="b34c71697b1823e77b9a782ccdbeeb5fdf757c55" translate="yes" xml:space="preserve">
          <source>The JavaScript function should always be saved to a file by itself but not be embedded in a HTML file or any other file.</source>
          <target state="translated">JavaScript函数应该总是单独保存到一个文件中,而不是嵌入到HTML文件或任何其他文件中。</target>
        </trans-unit>
        <trans-unit id="ae3233de7c368a8e5f19a8ef2604664291230823" translate="yes" xml:space="preserve">
          <source>The JavaScript snippets included in these sections (and running instances of the server-code that correctly handles these cross-site requests) can be found &quot;in action&quot; at &lt;a href=&quot;http://arunranga.com/examples/access-control/&quot;&gt;http://arunranga.com/examples/access-control/&lt;/a&gt;, and will work in browsers that support cross-site &lt;code&gt;XMLHttpRequest&lt;/code&gt;.</source>
          <target state="translated">可以在&lt;a href=&quot;http://arunranga.com/examples/access-control/&quot;&gt;http://arunranga.com/examples/access-control/上&lt;/a&gt;找到&amp;ldquo;实际使用&amp;rdquo;中的这些部分（以及正确处理这些跨站点请求的服务器代码的运行实例）中包含的JavaScript代码段，并且在支持跨站点 &lt;code&gt;XMLHttpRequest&lt;/code&gt; 的浏览器中工作。</target>
        </trans-unit>
        <trans-unit id="925661df194abc683169e90bef883c4c078be359" translate="yes" xml:space="preserve">
          <source>The Keep-Alive Header (Experimental specification)</source>
          <target state="translated">Keep-Alive Header (实验性规格)</target>
        </trans-unit>
        <trans-unit id="db2749cedc967fd4ef7ed7614b130c614deab08c" translate="yes" xml:space="preserve">
          <source>The Last-Modified entity-header field indicates the date and time at
   which the origin server believes the variant was last modified.

       Last-Modified  = &quot;Last-Modified&quot; &quot;:&quot; HTTP-date 

   An example of its use is

       Last-Modified: Tue, 15 Nov 1994 12:45:26 GMT

   The exact meaning of this header field depends on the implementation
   of the origin server and the nature of the original resource. For
   files, it may be just the file system last-modified time. For
   entities with dynamically included parts, it may be the most recent
   of the set of last-modify times for its component parts. For database
   gateways, it may be the last-update time stamp of the record. For
   virtual objects, it may be the last time the internal state changed.

   An origin server MUST NOT send a Last-Modified date which is later
   than the server's time of message origination. In such cases, where
   the resource's last modification would indicate some time in the
   future, the server MUST replace that date with the message
   origination date.

   An origin server SHOULD obtain the Last-Modified value of the entity
   as close as possible to the time that it generates the Date value of
   its response. This allows a recipient to make an accurate assessment
   of the entity's modification time, especially if the entity changes
   near the time that the response is generated.

   HTTP/1.1 servers SHOULD send Last-Modified whenever feasible.</source>
          <target state="translated">Last-Modified实体头字段表示起源服务器认为变体最后被修改的日期和时间。Last-Modified=&quot;Last-Modified&quot; &quot;:&quot; HTTP-date 它的一个使用例子是 Last-Modified:Tue,15 Nov 1994 12:45:26 GMT 这个头域的确切含义取决于源服务器的实现和原始资源的性质。对于文件,它可能只是文件系统的最后修改时间。对于具有动态包含部分的实体,它可能是其组件部分的最近一次修改时间集。对于数据库网关,它可能是记录的最后更新时间戳。对于虚拟对象,它可能是内部状态最后一次改变的时间。源服务器必须不发送比服务器的消息发起时间晚的Last-Modified日期。在这种情况下,如果资源的最后一次修改表明是在未来的某个时间,服务器必须用消息发起日期来替换这个日期。发起服务器should获取实体的Last-Modified值,尽可能地接近它生成响应的Date值的时间。这可以让接收者准确评估实体的修改时间,特别是当实体在生成响应的时间附近发生变化时。HTTP/1.1服务器只要可行,就应该发送Last-Modified。</target>
        </trans-unit>
        <trans-unit id="528a83f631c94edde30298fe82ad4b470dc52fd6" translate="yes" xml:space="preserve">
          <source>The Last-Modified entity-header field value is often used as a cache
   validator. In simple terms, a cache entry is considered to be valid
   if the entity has not been modified since the Last-Modified value.</source>
          <target state="translated">Last-Modified实体头字段值通常被用作缓存验证器。简单来说,如果一个实体在最后修改值之后没有被修改过,那么这个缓存条目就被认为是有效的。</target>
        </trans-unit>
        <trans-unit id="017625ae11b1cf3babbe1d1e9f72538a1d0bcdba" translate="yes" xml:space="preserve">
          <source>The Location response-header field is used to redirect the recipient
   to a location other than the Request-URI for completion of the
   request or identification of a new resource. For 201 (Created)
   responses, the Location is that of the new resource which was created
   by the request. For 3xx responses, the location SHOULD indicate the
   server's preferred URI for automatic redirection to the resource. The
   field value consists of a single absolute URI.

       Location       = &quot;Location&quot; &quot;:&quot; absoluteURI

   An example is:

       Location: &lt;a href=&quot;http://www.w3.org/pub/WWW/People.html&quot;&gt;http://www.w3.org/pub/WWW/People.html&lt;/a&gt;

      Note: The Content-Location header field (&lt;a href=&quot;#section-14.14&quot;&gt;section 14.14&lt;/a&gt;) differs
      from Location in that the Content-Location identifies the original
      location of the entity enclosed in the request. It is therefore
      possible for a response to contain header fields for both Location
      and Content-Location. Also see &lt;a href=&quot;#section-13.10&quot;&gt;section 13.10&lt;/a&gt; for cache
      requirements of some methods.</source>
          <target state="translated">位置响应标头字段用于将收件人重定向到Request-URI以外的其他位置，以完成请求或标识新资源。对于201（已创建）响应，位置是请求创建的新资源的位置。对于3xx响应，位置应该指示服务器的首选URI，用于自动重定向到资源。字段值由单个绝对URI组成。 Location =&amp;ldquo; Location&amp;rdquo;&amp;ldquo;：&amp;rdquo; absoluteURI例如：Location：&lt;a href=&quot;http://www.w3.org/pub/WWW/People.html&quot;&gt;http&lt;/a&gt; : //www.w3.org/pub/WWW/People.html 注意：Content-Location标头字段（&lt;a href=&quot;#section-14.14&quot;&gt;第14.14节）&lt;/a&gt;）与位置的不同之处在于，内容位置标识了请求中包含的实体的原始位置。因此，响应可能包含Location和Content-Location的标头字段。另请参见&lt;a href=&quot;#section-13.10&quot;&gt;13.10节&lt;/a&gt;，了解某些方法的缓存要求。</target>
        </trans-unit>
        <trans-unit id="5ec50ccb1766d60abdfd671b868367af7c968122" translate="yes" xml:space="preserve">
          <source>The Location response-header field is used to redirect the recipient
   to a location other than the Request-URI for completion of the
   request or identification of a new resource. For 201 (Created)
   responses, the Location is that of the new resource which was created
   by the request. For 3xx responses, the location SHOULD indicate the
   server's preferred URI for automatic redirection to the resource. The
   field value consists of a single absolute URI.

       Location       = &quot;Location&quot; &quot;:&quot; absoluteURI

   An example is:

       Location: &lt;a href=&quot;https://www.w3.org/pub/WWW/People.html&quot;&gt;http://www.w3.org/pub/WWW/People.html&lt;/a&gt;

      Note: The Content-Location header field (&lt;a href=&quot;#section-14.14&quot;&gt;section 14.14&lt;/a&gt;) differs
      from Location in that the Content-Location identifies the original
      location of the entity enclosed in the request. It is therefore
      possible for a response to contain header fields for both Location
      and Content-Location. Also see &lt;a href=&quot;#section-13.10&quot;&gt;section 13.10&lt;/a&gt; for cache
      requirements of some methods.</source>
          <target state="translated">位置响应标头字段用于将收件人重定向到Request-URI以外的其他位置，以完成请求或标识新资源。对于201（已创建）响应，位置是请求创建的新资源的位置。对于3xx响应，位置应该指示服务器的首选URI，用于自动重定向到资源。字段值由单个绝对URI组成。 Location =&amp;ldquo; Location&amp;rdquo;&amp;ldquo;：&amp;rdquo; absoluteURI例如：Location：&lt;a href=&quot;https://www.w3.org/pub/WWW/People.html&quot;&gt;http&lt;/a&gt; : //www.w3.org/pub/WWW/People.html注意：Content-Location标头字段（&lt;a href=&quot;#section-14.14&quot;&gt;第14.14节）&lt;/a&gt;）与位置的不同之处在于，内容位置标识了请求中包含的实体的原始位置。因此，响应可能包含Location和Content-Location的标头字段。另请参见&lt;a href=&quot;#section-13.10&quot;&gt;13.10节&lt;/a&gt;，了解某些方法的缓存要求。</target>
        </trans-unit>
        <trans-unit id="5bc7ceee0f881c0002d5d80140938c1e7f80c8e7" translate="yes" xml:space="preserve">
          <source>The MIME type of audiovisual files mostly indicate the container formats. The most common ones on the Web are:</source>
          <target state="translated">视听文件的MIME类型多表示容器格式。网络上最常见的有:</target>
        </trans-unit>
        <trans-unit id="7e997fc9b96d9d0ec4b11746c0834f2c40378a91" translate="yes" xml:space="preserve">
          <source>The MOVE operation on a non-collection resource is the logical
   equivalent of a copy (COPY), followed by consistency maintenance
   processing, followed by a delete of the source, where all three
   actions are performed in a single operation.  The consistency
   maintenance step allows the server to perform updates caused by the
   move, such as updating all URLs, other than the Request-URI that
   identifies the source resource, to point to the new destination
   resource. 

   The Destination header MUST be present on all MOVE methods and MUST
   follow all COPY requirements for the COPY part of the MOVE method.
   All WebDAV-compliant resources MUST support the MOVE method.

   Support for the MOVE method does not guarantee the ability to move a
   resource to a particular destination.  For example, separate programs
   may actually control different sets of resources on the same server.
   Therefore, it may not be possible to move a resource within a
   namespace that appears to belong to the same server.

   If a resource exists at the destination, the destination resource
   will be deleted as a side-effect of the MOVE operation, subject to
   the restrictions of the Overwrite header.

   This method is idempotent, but not safe (see &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;Section&amp;nbsp;9.1 of
   [RFC2616]&lt;/a&gt;).  Responses to this method MUST NOT be cached.</source>
          <target state="translated">在非集合资源上执行MOVE操作在逻辑上等效于副本（COPY），然后执行一致性维护处理，然后删除源，在此操作中，所有三个操作均在单个操作中执行。一致性维护步骤允许服务器执行由移动引起的更新，例如更新所有URL，而不是标识源资源的Request-URI，以指向新的目标资源。 Destination标头必须出现在所有MOVE方法上，并且必须遵循MOVE方法的COPY部分的所有COPY要求。所有符合WebDAV的资源都必须支持MOVE方法。对MOVE方法的支持不能保证将资源移动到特定目标的能力。例如，单独的程序实际上可以控制同一服务器上的不同资源集。因此，可能无法在似乎属于同一服务器的名称空间内移动资源。如果目标上存在资源，则该目标资源将作为MOVE操作的副作用而删除，但要遵守Overwrite标头的限制。此方法是幂等的，但不安全（请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;[RFC2616]的9.1节&lt;/a&gt;）。对此方法的响应绝不能被缓存。</target>
        </trans-unit>
        <trans-unit id="cb1023831cad3159839df21a4251dd372a13a0bc" translate="yes" xml:space="preserve">
          <source>The Max-Forwards request-header field provides a mechanism with the
   TRACE (&lt;a href=&quot;#section-9.8&quot;&gt;section 9.8&lt;/a&gt;) and OPTIONS (&lt;a href=&quot;#section-9.2&quot;&gt;section 9.2&lt;/a&gt;) methods to limit the
   number of proxies or gateways that can forward the request to the
   next inbound server. This can be useful when the client is attempting
   to trace a request chain which appears to be failing or looping in
   mid-chain.

       Max-Forwards   = &quot;Max-Forwards&quot; &quot;:&quot; 1*DIGIT

   The Max-Forwards value is a decimal integer indicating the remaining
   number of times this request message may be forwarded.

   Each proxy or gateway recipient of a TRACE or OPTIONS request
   containing a Max-Forwards header field MUST check and update its
   value prior to forwarding the request. If the received value is zero
   (0), the recipient MUST NOT forward the request; instead, it MUST
   respond as the final recipient. If the received Max-Forwards value is
   greater than zero, then the forwarded message MUST contain an updated
   Max-Forwards field with a value decremented by one (1).

   The Max-Forwards header field MAY be ignored for all other methods
   defined by this specification and for any extension methods for which
   it is not explicitly referred to as part of that method definition.</source>
          <target state="translated">Max-Forwards请求标头字段提供了一种具有TRACE（&lt;a href=&quot;#section-9.8&quot;&gt;第9.8节&lt;/a&gt;）和OPTIONS（&lt;a href=&quot;#section-9.2&quot;&gt;第9.2 &lt;/a&gt;节）的机制。）方法，以限制可以将请求转发到下一个入站服务器的代理或网关的数量。当客户端尝试跟踪似乎在中间链中失败或循环的请求链时，此功能很有用。 Max-Forwards =&amp;ldquo; Max-Forwards&amp;rdquo;&amp;ldquo;：&amp;rdquo; 1 * DIGIT Max-Forwards值是一个十进制整数，指示可以转发此请求消息的剩余次数。包含Max-Forwards标头字段的TRACE或OPTIONS请求的每个代理或网关接收者必须在转发请求之前检查并更新其值。如果接收到的值为零（0），则接收者不得转发该请求；相反，它必须作为最终收件人进行响应。如果收到的Max-Forwards值大于零，那么转发的消息必须包含一个更新的Max-Forward字段，其值减一（1）。对于本规范定义的所有其他方法以及未明确将其定义为该方法定义一部分的所有扩展方法，可以忽略Max-Forwards标头字段。</target>
        </trans-unit>
        <trans-unit id="b9679bb7ec73b85f439581526aa5e2f804e20f5f" translate="yes" xml:space="preserve">
          <source>The Member URI allows clients to retrieve, edit, and delete a Member
   Resource using HTTP's GET, PUT, and DELETE methods.  Entry Resources
   are represented as Atom Entry documents.

   Member URIs appear in two places.  They are returned in a Location
   header after successful Resource creation using POST, as described in
   &lt;a href=&quot;#section-9.2&quot;&gt;Section 9.2&lt;/a&gt; below.  They can also appear in a Collection Feed's
   Entries, as atom:link elements with a link relation of &quot;edit&quot;.

   A Member Entry SHOULD contain such an atom:link element with a link
   relation of &quot;edit&quot;, which indicates the Member URI.</source>
          <target state="translated">成员URI允许客户端使用HTTP的GET，PUT和DELETE方法检索，编辑和删除成员资源。条目资源表示为Atom条目文档。成员URI出现在两个位置。使用POST成功创建资源后，它们将在Location标头中返回，如 以下&lt;a href=&quot;#section-9.2&quot;&gt;9.2节&lt;/a&gt;所述。它们也可以作为具有&amp;ldquo;编辑&amp;rdquo;链接关系的atom：link元素出现在集合提要的条目中。成员条目应包含这样的atom：link元素，其链接关系为&amp;ldquo; edit&amp;rdquo;，指示成员URI。</target>
        </trans-unit>
        <trans-unit id="8bc27eaceea013a32bec84be620f4a677881aac7" translate="yes" xml:space="preserve">
          <source>The Method  token indicates the method to be performed on the
   resource identified by the Request-URI. The method is case-sensitive.

       Method         = &quot;OPTIONS&quot;                ; &lt;a href=&quot;#section-9.2&quot;&gt;Section 9.2&lt;/a&gt;
                      | &quot;GET&quot;                    ; &lt;a href=&quot;#section-9.3&quot;&gt;Section 9.3&lt;/a&gt;
                      | &quot;HEAD&quot;                   ; &lt;a href=&quot;#section-9.4&quot;&gt;Section 9.4&lt;/a&gt;
                      | &quot;POST&quot;                   ; &lt;a href=&quot;#section-9.5&quot;&gt;Section 9.5&lt;/a&gt;
                      | &quot;PUT&quot;                    ; &lt;a href=&quot;#section-9.6&quot;&gt;Section 9.6&lt;/a&gt;
                      | &quot;DELETE&quot;                 ; &lt;a href=&quot;#section-9.7&quot;&gt;Section 9.7&lt;/a&gt;
                      | &quot;TRACE&quot;                  ; &lt;a href=&quot;#section-9.8&quot;&gt;Section 9.8&lt;/a&gt;
                      | &quot;CONNECT&quot;                ; &lt;a href=&quot;#section-9.9&quot;&gt;Section 9.9&lt;/a&gt;
                      | extension-method
       extension-method = token

   The list of methods allowed by a resource can be specified in an
   Allow header field (&lt;a href=&quot;#section-14.7&quot;&gt;section 14.7&lt;/a&gt;). The return code of the response
   always notifies the client whether a method is currently allowed on a
   resource, since the set of allowed methods can change dynamically. An
   origin server SHOULD return the status code 405 (Method Not Allowed)
   if the method is known by the origin server but not allowed for the
   requested resource, and 501 (Not Implemented) if the method is
   unrecognized or not implemented by the origin server. The methods GET
   and HEAD MUST be supported by all general-purpose servers. All other
   methods are OPTIONAL; however, if the above methods are implemented,
   they MUST be implemented with the same semantics as those specified
   in &lt;a href=&quot;#section-9&quot;&gt;section 9&lt;/a&gt;.</source>
          <target state="translated">方法令牌指示要对由请求URI标识的资源执行的方法。该方法区分大小写。方法=&amp;ldquo;选项&amp;rdquo;；&lt;a href=&quot;#section-9.2&quot;&gt;第9.2节&lt;/a&gt; | &amp;ldquo; GET&amp;rdquo;；&lt;a href=&quot;#section-9.3&quot;&gt;第9.3节&lt;/a&gt; | &amp;ldquo;头&amp;rdquo;；&lt;a href=&quot;#section-9.4&quot;&gt;第9.4节&lt;/a&gt; | &amp;ldquo; POST&amp;rdquo;；&lt;a href=&quot;#section-9.5&quot;&gt;第9.5节&lt;/a&gt; | &amp;ldquo;放置&amp;rdquo;；&lt;a href=&quot;#section-9.6&quot;&gt;第9.6节&lt;/a&gt; | &amp;ldquo;删除&amp;rdquo;；&lt;a href=&quot;#section-9.7&quot;&gt;第9.7节&lt;/a&gt; | &amp;ldquo; TRACE&amp;rdquo;；&lt;a href=&quot;#section-9.8&quot;&gt;第9.8节&lt;/a&gt; | &amp;ldquo;连接&amp;rdquo;; &lt;a href=&quot;#section-9.9&quot;&gt;9.9节&lt;/a&gt; | extension-method extension-method =令牌可以在Allow标头字段中指定资源允许的方法列表（&lt;a href=&quot;#section-14.7&quot;&gt;第14.7节）&lt;/a&gt;）。响应的返回代码总是通知客户端资源上当前是否允许某个方法，因为允许的方法集可以动态更改。如果源服务器知道该方法但不允许所请求的资源，则源服务器应返回状态码405（不允许方法），如果源服务器无法识别或未实现该方法，则返回501（未实现）。所有通用服务器都必须支持GET和HEAD方法。所有其他方法都是可选的。但是，如果实现了上述方法，则必须以与&lt;a href=&quot;#section-9&quot;&gt;第9节中&lt;/a&gt;指定的语义相同的语义来实现。</target>
        </trans-unit>
        <trans-unit id="b472ea77a890edf2b85c6971105718fc4fd6fc42" translate="yes" xml:space="preserve">
          <source>The OPTIONS method represents a request for information about the
   communication options available on the request/response chain
   identified by the Request-URI. This method allows the client to
   determine the options and/or requirements associated with a resource,
   or the capabilities of a server, without implying a resource action
   or initiating a resource retrieval.

   Responses to this method are not cacheable.

   If the OPTIONS request includes an entity-body (as indicated by the
   presence of Content-Length or Transfer-Encoding), then the media type
   MUST be indicated by a Content-Type field. Although this
   specification does not define any use for such a body, future
   extensions to HTTP might use the OPTIONS body to make more detailed
   queries on the server. A server that does not support such an
   extension MAY discard the request body.

   If the Request-URI is an asterisk (&quot;*&quot;), the OPTIONS request is
   intended to apply to the server in general rather than to a specific
   resource. Since a server's communication options typically depend on
   the resource, the &quot;*&quot; request is only useful as a &quot;ping&quot; or &quot;no-op&quot;
   type of method; it does nothing beyond allowing the client to test
   the capabilities of the server. For example, this can be used to test
   a proxy for HTTP/1.1 compliance (or lack thereof).

   If the Request-URI is not an asterisk, the OPTIONS request applies
   only to the options that are available when communicating with that
   resource.

   A 200 response SHOULD include any header fields that indicate
   optional features implemented by the server and applicable to that
   resource (e.g., Allow), possibly including extensions not defined by
   this specification. The response body, if any, SHOULD also include
   information about the communication options. The format for such a 

   body is not defined by this specification, but might be defined by
   future extensions to HTTP. Content negotiation MAY be used to select
   the appropriate response format. If no response body is included, the
   response MUST include a Content-Length field with a field-value of
   &quot;0&quot;.

   The Max-Forwards request-header field MAY be used to target a
   specific proxy in the request chain. When a proxy receives an OPTIONS
   request on an absoluteURI for which request forwarding is permitted,
   the proxy MUST check for a Max-Forwards field. If the Max-Forwards
   field-value is zero (&quot;0&quot;), the proxy MUST NOT forward the message;
   instead, the proxy SHOULD respond with its own communication options.
   If the Max-Forwards field-value is an integer greater than zero, the
   proxy MUST decrement the field-value when it forwards the request. If
   no Max-Forwards field is present in the request, then the forwarded
   request MUST NOT include a Max-Forwards field.</source>
          <target state="translated">OPTIONS方法表示请求提供关于由Request-URI确定的请求/响应链上可用的通信选项的信息。该方法允许客户端确定与资源相关联的选项和/或要求,或服务器的能力,而不暗示资源操作或启动资源检索。对该方法的响应是不可缓存的。如果OPTIONS请求包括实体主体(如Content-Length或Transfer-Encoding所示),那么媒体类型必须由Content-Type字段表示。虽然本规范没有定义这种实体体的任何用途,但未来HTTP的扩展可能会使用OPTIONS实体体来对服务器进行更详细的查询。不支持这种扩展的服务器可以丢弃请求体。如果Request-URI是星号(&quot;*&quot;),则OPTIONS请求的目的是适用于一般的服务器而不是特定的资源。由于服务器的通信选项通常取决于资源,所以 &quot;*&quot;请求仅作为 &quot;ping &quot;或 &quot;no-op &quot;类型的方法有用;它除了允许客户端测试服务器的能力外,没有其他作用。例如,这可以用来测试代理服务器是否符合HTTP/1.1的要求(或不符合)。如果Request-URI不是星号,OPTIONS请求只适用于与该资源通信时可用的选项。200响应应该包括任何表示由服务器实现并适用于该资源的可选功能的头字段(例如,Allow),可能包括本规范未定义的扩展。响应体(如果有的话)还应该包括有关通信选项的信息。本规范没有定义这种主体的格式,但可能由HTTP的未来扩展来定义。内容协商可以用来选择合适的响应格式。如果不包含响应体,响应必须包含一个字段值为 &quot;0 &quot;的Content-Length字段。Max-Forwards request-header字段可用于在请求链中锁定特定的代理。当代理收到一个允许请求转发的绝对URI上的OPTIONS请求时,代理必须检查Max-Forwards字段。如果Max-Forwards字段的值为0(&quot;0&quot;),代理必须不转发消息;相反,代理应该用自己的通信选项来响应。如果Max-Forwards字段值是一个大于0的整数,代理在转发请求时必须递减字段值。如果请求中没有Max-Forwards字段,那么转发的请求必须不包含Max-Forwards字段。</target>
        </trans-unit>
        <trans-unit id="49820b72a266a24d241c6570cc10be88c4ce50ca" translate="yes" xml:space="preserve">
          <source>The OPTIONS method requests information about the communication
   options available for the target resource, at either the origin
   server or an intervening intermediary.  This method allows a client
   to determine the options and/or requirements associated with a
   resource, or the capabilities of a server, without implying a
   resource action. 

   An OPTIONS request with an asterisk (&quot;*&quot;) as the request-target
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.3&quot;&gt;Section&amp;nbsp;5.3 of [RFC7230]&lt;/a&gt;) applies to the server in general rather
   than to a specific resource.  Since a server's communication options
   typically depend on the resource, the &quot;*&quot; request is only useful as a
   &quot;ping&quot; or &quot;no-op&quot; type of method; it does nothing beyond allowing the
   client to test the capabilities of the server.  For example, this can
   be used to test a proxy for HTTP/1.1 conformance (or lack thereof).

   If the request-target is not an asterisk, the OPTIONS request applies
   to the options that are available when communicating with the target
   resource.

   A server generating a successful response to OPTIONS SHOULD send any
   header fields that might indicate optional features implemented by
   the server and applicable to the target resource (e.g., Allow),
   including potential extensions not defined by this specification.
   The response payload, if any, might also describe the communication
   options in a machine or human-readable representation.  A standard
   format for such a representation is not defined by this
   specification, but might be defined by future extensions to HTTP.  A
   server MUST generate a Content-Length field with a value of &quot;0&quot; if no
   payload body is to be sent in the response.

   A client MAY send a Max-Forwards header field in an OPTIONS request
   to target a specific recipient in the request chain (see
   &lt;a href=&quot;#section-5.1.2&quot;&gt;Section 5.1.2&lt;/a&gt;).  A proxy MUST NOT generate a Max-Forwards header
   field while forwarding a request unless that request was received
   with a Max-Forwards field.

   A client that generates an OPTIONS request containing a payload body
   MUST send a valid Content-Type header field describing the
   representation media type.  Although this specification does not
   define any use for such a payload, future extensions to HTTP might
   use the OPTIONS body to make more detailed queries about the target
   resource.

   Responses to the OPTIONS method are not cacheable.</source>
          <target state="translated">OPTIONS方法在源服务器或中间中介处请求有关可用于目标资源的通信选项的信息。此方法允许客户端确定与资源相关联的选项和/或要求或服务器的功能，而无需暗示资源操作。以星号（*）为请求目标的OPTIONS请求（&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.3&quot;&gt;[RFC7230]的第5.3节）&lt;/a&gt;）通常适用于服务器，而不适用于特定资源。由于服务器的通信选项通常取决于资源，因此&amp;ldquo; *&amp;rdquo;请求仅用作&amp;ldquo; ping&amp;rdquo;或&amp;ldquo; no-op&amp;rdquo;类型的方法；除了允许客户端测试服务器功能之外，它没有任何作用。例如，这可以用于测试代理是否符合HTTP / 1.1规范（或缺少规范）。如果请求目标不是星号，则OPTIONS请求适用于与目标资源通信时可用的选项。产生对OPTIONS的成功响应的服务器应发送任何标头字段，这些标头字段可能指示该服务器实现并适用于目标资源的可选功能（例如，Allow），包括本规范未定义的潜在扩展。响应有效载荷（如果有）也可能以机器或人类可读的表示形式描述通信选项。此规范的标准格式不是由本规范定义的，但可能由将来对HTTP的扩展来定义。如果在响应中不发送有效载荷主体，则服务器必须生成一个值为&amp;ldquo; 0&amp;rdquo;的Content-Length字段。客户端可以在OPTIONS请求中发送Max-Forwards标头字段以定位请求链中的特定接收者（参见但可能由将来的HTTP扩展定义。如果在响应中不发送有效载荷主体，则服务器必须生成一个值为&amp;ldquo; 0&amp;rdquo;的Content-Length字段。客户端可以在OPTIONS请求中发送Max-Forwards标头字段以定位请求链中的特定接收者（参见但可能由将来的HTTP扩展定义。如果在响应中不发送有效载荷主体，则服务器必须生成一个值为&amp;ldquo; 0&amp;rdquo;的Content-Length字段。客户端可以在OPTIONS请求中发送Max-Forwards标头字段以定位请求链中的特定接收者（参见 &lt;a href=&quot;#section-5.1.2&quot;&gt;5.1.2节&lt;/a&gt;）。代理在转发请求时不得生成Max-Forwards标头字段，除非收到带有Max-Forwards字段的请求。生成包含有效内容主体的OPTIONS请求的客户端务必发送描述表示形式媒体类型的有效Content-Type头字段。尽管此规范未定义对此类有效负载的任何用法，但将来对HTTP的扩展可能会使用OPTIONS主体对目标资源进行更详细的查询。对OPTIONS方法的响应不可缓存。</target>
        </trans-unit>
        <trans-unit id="335a905cdd5cc098f1e6a149fd20a764baed11c1" translate="yes" xml:space="preserve">
          <source>The Opera browser is also based on the Blink engine, which is why it almost looks the same, but adds &lt;code&gt;&quot;OPR/&amp;lt;version&amp;gt;&quot;&lt;/code&gt;.</source>
          <target state="translated">Opera浏览器也基于Blink引擎，这就是为什么它看起来几乎相同，但是添加了 &lt;code&gt;&quot;OPR/&amp;lt;version&amp;gt;&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1d0b5a78c1f599442b880ea6a8403854d20e3ef6" translate="yes" xml:space="preserve">
          <source>The Opera browser is also based on the blink engine, which is why it almost looks the same, but adds &quot;OPR/&amp;lt;version&amp;gt;&quot;.</source>
          <target state="translated">Opera浏览器也基于眨眼引擎，这就是为什么它看上去几乎相同，但是添加了&amp;ldquo; OPR / &amp;lt;version&amp;gt;&amp;rdquo;的原因。</target>
        </trans-unit>
        <trans-unit id="1a9fb731478c28f4fa3740727c3862c0e8280261" translate="yes" xml:space="preserve">
          <source>The Operating System is given in most User Agent strings (although not web-focused platforms like Firefox OS), but the format varies a lot. It is a fixed string between two semi-colons, in the comment part of the User Agent. These strings are specific for each browser. They indicate the OS, but also often its version and information on the relying hardware (32 or 64 bits, or Intel/PPC for Mac).</source>
          <target state="translated">大多数用户代理字符串中都给出了操作系统(尽管不是像Firefox OS这样的网络平台),但格式变化很大。它是一个固定的字符串,在两个分号之间,在用户代理的注释部分。这些字符串对每个浏览器来说都是特定的。它们表明了操作系统,但通常也表明了它的版本和所依赖的硬件信息(32或64位,或Mac的Intel/PPC)。</target>
        </trans-unit>
        <trans-unit id="b865b396cc503b061720f4db16c1a8fdc2531248" translate="yes" xml:space="preserve">
          <source>The PAC file is named &lt;code&gt;proxy.pac&lt;/code&gt;</source>
          <target state="translated">PAC文件名为 &lt;code&gt;proxy.pac&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1f9837bd9139ad48f4cd2dd0906bd1f2401fbe7f" translate="yes" xml:space="preserve">
          <source>The PAC file is named proxy.pac</source>
          <target state="translated">PAC文件命名为proxy.pac</target>
        </trans-unit>
        <trans-unit id="ad2834ac0702672d145d7ca3894c53d5a21fd051" translate="yes" xml:space="preserve">
          <source>The PHP snippets (and the JavaScript invocations to the server) in subsequent sections are taken from &lt;a href=&quot;http://arunranga.com/examples/access-control/&quot;&gt;the working code samples posted here.&lt;/a&gt; These will work in browsers that implement cross-site &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">后续部分中的PHP代码片段（以及服务器的JavaScript调用）摘自&lt;a href=&quot;http://arunranga.com/examples/access-control/&quot;&gt;此处发布的工作代码示例。&lt;/a&gt;这些将在实现跨站点&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; 的&lt;/a&gt;浏览器中工作。</target>
        </trans-unit>
        <trans-unit id="68bd99f90bb560cf24ee3bfb0650ff1043f9b961" translate="yes" xml:space="preserve">
          <source>The PING frame (type=0x6) is a mechanism for measuring a minimal
   round-trip time from the sender, as well as determining whether an
   idle connection is still functional.  PING frames can be sent from
   any endpoint.

    +---------------------------------------------------------------+
    |                                                               |
    |                      Opaque Data (64)                         |
    |                                                               |
    +---------------------------------------------------------------+

                      Figure 12: PING Payload Format

   In addition to the frame header, PING frames MUST contain 8 octets of
   opaque data in the payload.  A sender can include any value it
   chooses and use those octets in any fashion.

   Receivers of a PING frame that does not include an ACK flag MUST send
   a PING frame with the ACK flag set in response, with an identical
   payload.  PING responses SHOULD be given higher priority than any
   other frame.

   The PING frame defines the following flags:

   ACK (0x1):  When set, bit 0 indicates that this PING frame is a PING
      response.  An endpoint MUST set this flag in PING responses.  An
      endpoint MUST NOT respond to PING frames containing this flag. 

   PING frames are not associated with any individual stream.  If a PING
   frame is received with a stream identifier field value other than
   0x0, the recipient MUST respond with a connection error
   (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type PROTOCOL_ERROR.

   Receipt of a PING frame with a length field value other than 8 MUST
   be treated as a connection error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type
   FRAME_SIZE_ERROR.</source>
          <target state="translated">PING帧（类型= 0x6）是一种机制，用于测量来自发送方的最小往返时间，以及确定空闲连接是否仍然起作用。可以从任何端点发送PING帧。 + ------------------------------------------------- -------------- + | | |不透明数据（64）| | | + ------------------------------------------------- -------------- +图12：PING有效载荷格式除帧头外，PING帧还必须在有效载荷中包含8个八位字节的不透明数据。发送者可以包括它选择的任何值，并可以任何方式使用这些八位位组。不包含ACK标志的PING帧的接收者必须发送带有相同有效负载的ACK标志作为响应设置的PING帧。应该给PING响应比任何其他帧更高的优先级。 PING帧定义以下标志：ACK（0x1）：设置后，位0指示此PING帧是PING响应。端点必须在PING响应中设置该标志。端点不得响应包含该标志的PING帧。 PING帧不与任何单独的流相关联。如果收到的PING帧的流标识符字段值不是0x0，则接收方务必以连接错误响应（&lt;a href=&quot;#section-5.4.1&quot;&gt;&lt;/a&gt;类型PROTOCOL_ERROR的第5.4.1节）。收到长度字段值为8以外的PING帧时，必须将其视为FRAME_SIZE_ERROR类型的连接错误（&lt;a href=&quot;#section-5.4.1&quot;&gt;第5.4.1节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="d84539c58092eb061728beac8d3510599c78d9e2" translate="yes" xml:space="preserve">
          <source>The POST method is used to request that the origin server accept the
   entity enclosed in the request as a new subordinate of the resource
   identified by the Request-URI in the Request-Line. POST is designed
   to allow a uniform method to cover the following functions:

      - Annotation of existing resources;

      - Posting a message to a bulletin board, newsgroup, mailing list,
        or similar group of articles;

      - Providing a block of data, such as the result of submitting a
        form, to a data-handling process;

      - Extending a database through an append operation.

   The actual function performed by the POST method is determined by the
   server and is usually dependent on the Request-URI. The posted entity
   is subordinate to that URI in the same way that a file is subordinate
   to a directory containing it, a news article is subordinate to a
   newsgroup to which it is posted, or a record is subordinate to a
   database.

   The action performed by the POST method might not result in a
   resource that can be identified by a URI. In this case, either 200
   (OK) or 204 (No Content) is the appropriate response status,
   depending on whether or not the response includes an entity that
   describes the result. 

   If a resource has been created on the origin server, the response
   SHOULD be 201 (Created) and contain an entity which describes the
   status of the request and refers to the new resource, and a Location
   header (see &lt;a href=&quot;#section-14.30&quot;&gt;section 14.30&lt;/a&gt;).

   Responses to this method are not cacheable, unless the response
   includes appropriate Cache-Control or Expires header fields. However,
   the 303 (See Other) response can be used to direct the user agent to
   retrieve a cacheable resource.

   POST requests MUST obey the message transmission requirements set out
   in &lt;a href=&quot;#section-8.2&quot;&gt;section 8.2&lt;/a&gt;.

   See &lt;a href=&quot;#section-15.1.3&quot;&gt;section 15.1.3&lt;/a&gt; for security considerations.</source>
          <target state="translated">POST方法用于请求源服务器接受请求中包含的实体作为请求行中Request-URI标识的资源的新下属。 POST旨在允许一种统一的方法来覆盖以下功能：-现有资源的注释； -将消息发布到公告板，新闻组，邮件列表或类似的文章组； -向数据处理过程提供数据块，例如提交表单的结果； -通过附加操作扩展数据库。 POST方法执行的实际功能由服务器确定，通常取决于Request-URI。发布的实体从属于该URI，就像文件从属于包含它的目录一样，新闻文章从属于发布的新闻组，或者记录从属于数据库。 POST方法执行的操作可能不会导致可以由URI标识的资源。在这种情况下，适当的响应状态是200（确定）或204（无内容），这取决于响应是否包括描述结果的实体。如果在原始服务器上创建了资源，则响应应为201（已创建），并包含一个描述请求状态并引用新资源的实体以及一个Location标头（请参见在这种情况下，适当的响应状态是200（确定）或204（无内容），这取决于响应是否包括描述结果的实体。如果在原始服务器上创建了资源，则响应应为201（已创建），并包含一个描述请求状态并引用新资源的实体以及一个Location标头（请参见在这种情况下，适当的响应状态是200（确定）或204（无内容），这取决于响应是否包括描述结果的实体。如果在原始服务器上创建了资源，则响应应为201（已创建），并包含一个描述请求状态并引用新资源的实体以及一个Location标头（请参见&lt;a href=&quot;#section-14.30&quot;&gt;第14.30条&lt;/a&gt;）。除非响应包括适当的Cache-Control或Expires标头字段，否则对此方法的响应不可缓存。但是，303（请参阅其他）响应可用于指导用户代理检索可缓存资源。 POST请求必须遵守&lt;a href=&quot;#section-8.2&quot;&gt;8.2节中&lt;/a&gt;规定的消息传输要求。出于安全考虑，请参阅&lt;a href=&quot;#section-15.1.3&quot;&gt;第15.1.3节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a7c4a0540415d773e2957d84d1e4f16f405d585a" translate="yes" xml:space="preserve">
          <source>The POST method requests that the target resource process the
   representation enclosed in the request according to the resource's
   own specific semantics.  For example, POST is used for the following
   functions (among others):

   o  Providing a block of data, such as the fields entered into an HTML
      form, to a data-handling process; 

   o  Posting a message to a bulletin board, newsgroup, mailing list,
      blog, or similar group of articles;

   o  Creating a new resource that has yet to be identified by the
      origin server; and

   o  Appending data to a resource's existing representation(s).

   An origin server indicates response semantics by choosing an
   appropriate status code depending on the result of processing the
   POST request; almost all of the status codes defined by this
   specification might be received in a response to POST (the exceptions
   being 206 (Partial Content), 304 (Not Modified), and 416 (Range Not
   Satisfiable)).

   If one or more resources has been created on the origin server as a
   result of successfully processing a POST request, the origin server
   SHOULD send a 201 (Created) response containing a Location header
   field that provides an identifier for the primary resource created
   (&lt;a href=&quot;#section-7.1.2&quot;&gt;Section 7.1.2&lt;/a&gt;) and a representation that describes the status of the
   request while referring to the new resource(s).

   Responses to POST requests are only cacheable when they include
   explicit freshness information (see &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.1&quot;&gt;Section&amp;nbsp;4.2.1 of [RFC7234]&lt;/a&gt;).
   However, POST caching is not widely implemented.  For cases where an
   origin server wishes the client to be able to cache the result of a
   POST in a way that can be reused by a later GET, the origin server
   MAY send a 200 (OK) response containing the result and a
   Content-Location header field that has the same value as the POST's
   effective request URI (&lt;a href=&quot;#section-3.1.4.2&quot;&gt;Section 3.1.4.2&lt;/a&gt;).

   If the result of processing a POST would be equivalent to a
   representation of an existing resource, an origin server MAY redirect
   the user agent to that resource by sending a 303 (See Other) response
   with the existing resource's identifier in the Location field.  This
   has the benefits of providing the user agent a resource identifier
   and transferring the representation via a method more amenable to
   shared caching, though at the cost of an extra request if the user
   agent does not already have the representation cached.</source>
          <target state="translated">The POST method requests that the target resource process the representation enclosed in the request according to the resource's own specific semantics. For example, POST is used for the following functions (among others): o Providing a block of data, such as the fields entered into an HTML form, to a data-handling process; o Posting a message to a bulletin board, newsgroup, mailing list, blog, or similar group of articles; o Creating a new resource that has yet to be identified by the origin server; and o Appending data to a resource's existing representation(s). An origin server indicates response semantics by choosing an appropriate status code depending on the result of processing the POST request; almost all of the status codes defined by this specification might be received in a response to POST (the exceptions being 206 (Partial Content), 304 (Not Modified), and 416 (Range Not Satisfiable)). If one or more resources has been created on the origin server as a result of successfully processing a POST request, the origin server SHOULD send a 201 (Created) response containing a Location header field that provides an identifier for the primary resource created (&lt;a href=&quot;#section-7.1.2&quot;&gt;7.1.2节&lt;/a&gt;）和描述请求状态的表述，同时引用新资源。对POST请求的响应仅在包含显式的新鲜度信息时才可缓存（请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.1&quot;&gt;[RFC7234]的4.2.1节&lt;/a&gt;）。但是，POST缓存并未广泛实施。对于原始服务器希望客户端能够以一种可以被以后的GET重用的方式缓存POST结果的情况，原始服务器可以发送一个200（OK）响应，其中包含结果和一个Content-Location。标头字段，其值与POST的有效请求URI相同（&lt;a href=&quot;#section-3.1.4.2&quot;&gt;第3.1.4.2节&lt;/a&gt;). If the result of processing a POST would be equivalent to a representation of an existing resource, an origin server MAY redirect the user agent to that resource by sending a 303 (See Other) response with the existing resource's identifier in the Location field. This has the benefits of providing the user agent a resource identifier and transferring the representation via a method more amenable to shared caching, though at the cost of an extra request if the user agent does not already have the representation cached.</target>
        </trans-unit>
        <trans-unit id="009ae6509d491675faf3db2c6925c60d8bb4838c" translate="yes" xml:space="preserve">
          <source>The PRIORITY frame (type=0x2) specifies the sender-advised priority
   of a stream (&lt;a href=&quot;#section-5.3&quot;&gt;Section 5.3&lt;/a&gt;).  It can be sent in any stream state,
   including idle or closed streams. 

    +-+-------------------------------------------------------------+
    |E|                  Stream Dependency (31)                     |
    +-+-------------+-----------------------------------------------+
    |   Weight (8)  |
    +-+-------------+

                     Figure 8: PRIORITY Frame Payload

   The payload of a PRIORITY frame contains the following fields:

   E: A single-bit flag indicating that the stream dependency is
      exclusive (see &lt;a href=&quot;#section-5.3&quot;&gt;Section 5.3&lt;/a&gt;).

   Stream Dependency:  A 31-bit stream identifier for the stream that
      this stream depends on (see &lt;a href=&quot;#section-5.3&quot;&gt;Section 5.3&lt;/a&gt;).

   Weight:  An unsigned 8-bit integer representing a priority weight for
      the stream (see &lt;a href=&quot;#section-5.3&quot;&gt;Section 5.3&lt;/a&gt;).  Add one to the value to obtain a
      weight between 1 and 256.

   The PRIORITY frame does not define any flags.

   The PRIORITY frame always identifies a stream.  If a PRIORITY frame
   is received with a stream identifier of 0x0, the recipient MUST
   respond with a connection error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type
   PROTOCOL_ERROR.

   The PRIORITY frame can be sent on a stream in any state, though it
   cannot be sent between consecutive frames that comprise a single
   header block (&lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;).  Note that this frame could arrive after
   processing or frame sending has completed, which would cause it to
   have no effect on the identified stream.  For a stream that is in the
   &quot;half-closed (remote)&quot; or &quot;closed&quot; state, this frame can only affect
   processing of the identified stream and its dependent streams; it
   does not affect frame transmission on that stream.

   The PRIORITY frame can be sent for a stream in the &quot;idle&quot; or &quot;closed&quot;
   state.  This allows for the reprioritization of a group of dependent
   streams by altering the priority of an unused or closed parent
   stream.

   A PRIORITY frame with a length other than 5 octets MUST be treated as
   a stream error (&lt;a href=&quot;#section-5.4.2&quot;&gt;Section 5.4.2&lt;/a&gt;) of type FRAME_SIZE_ERROR.</source>
          <target state="translated">PRIORITY帧（类型= 0x2）指定流的发送者建议的优先级（&lt;a href=&quot;#section-5.3&quot;&gt;第5.3节&lt;/a&gt;）。它可以以任何流状态发送，包括空闲或关闭的流。 +-+ ----------------------------------------------- -------------- + | E |流依赖性（31）| +-+ ------------- + --------------------------------- -------------- + |重量（8）| +-+ ------------- +图8：PRIORITY帧有效负载PRIORITY帧的有效负载包含以下字段：E：指示流依赖项互斥的单个标志（请参见&lt;a href=&quot;#section-5.3&quot;&gt;第5.3节&lt;/a&gt;）。流相关性：此流所依赖的流的31位流标识符（请参阅&lt;a href=&quot;#section-5.3&quot;&gt;第5.3节&lt;/a&gt;）。权重：代表流优先级权重的无符号8位整数（请参阅&lt;a href=&quot;#section-5.3&quot;&gt;第5.3节）&lt;/a&gt;）。将值加1可获得1到256之间的权重。PRIORITY帧未定义任何标志。 PRIORITY帧始终标识一个流。如果接收到流标识符为0x0的PRIORITY帧，则接收者务必以PROTOCOL_ERROR类型的连接错误（&lt;a href=&quot;#section-5.4.1&quot;&gt;第5.4.1节&lt;/a&gt;）做出响应。 PRIORITY帧可以在任何状态下在流上发送，尽管不能在包含单个标头块的连续帧之间发送（&lt;a href=&quot;#section-4.3&quot;&gt;第4.3节）&lt;/a&gt;）。请注意，该帧可能在处理或帧发送完成后到达，这将导致它对标识的流没有影响。对于处于&amp;ldquo;半关闭（远程）&amp;rdquo;或&amp;ldquo;关闭&amp;rdquo;状态的流，此帧只能影响已识别流及其从属流的处理；它不会影响该流上的帧传输。可以为处于&amp;ldquo;空闲&amp;rdquo;或&amp;ldquo;关闭&amp;rdquo;状态的流发送PRIORITY帧。这允许通过更改未使用或关闭的父流的优先级来重新设置一组从属流的优先级。长度非5个八位位组的PRIORITY帧必须被视为FRAME_SIZE_ERROR类型的流错误（&lt;a href=&quot;#section-5.4.2&quot;&gt;第5.4.2节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="babc13478772ae526be737f6ddcf858ed85d894b" translate="yes" xml:space="preserve">
          <source>The PROPFIND method retrieves properties defined on the resource
   identified by the Request-URI, if the resource does not have any
   internal members, or on the resource identified by the Request-URI
   and potentially its member resources, if the resource is a collection
   that has internal member URLs.  All DAV-compliant resources MUST
   support the PROPFIND method and the propfind XML element
   (&lt;a href=&quot;#section-14.20&quot;&gt;Section 14.20&lt;/a&gt;) along with all XML elements defined for use with that
   element.

   A client MUST submit a Depth header with a value of &quot;0&quot;, &quot;1&quot;, or
   &quot;infinity&quot; with a PROPFIND request.  Servers MUST support &quot;0&quot; and &quot;1&quot;
   depth requests on WebDAV-compliant resources and SHOULD support
   &quot;infinity&quot; requests.  In practice, support for infinite-depth
   requests MAY be disabled, due to the performance and security
   concerns associated with this behavior.  Servers SHOULD treat a
   request without a Depth header as if a &quot;Depth: infinity&quot; header was
   included. 

   A client may submit a 'propfind' XML element in the body of the
   request method describing what information is being requested.  It is
   possible to:

   o  Request particular property values, by naming the properties
      desired within the 'prop' element (the ordering of properties in
      here MAY be ignored by the server),

   o  Request property values for those properties defined in this
      specification (at a minimum) plus dead properties, by using the
      'allprop' element (the 'include' element can be used with
      'allprop' to instruct the server to also include additional live
      properties that may not have been returned otherwise),

   o  Request a list of names of all the properties defined on the
      resource, by using the 'propname' element.

   A client may choose not to submit a request body.  An empty PROPFIND
   request body MUST be treated as if it were an 'allprop' request.

   Note that 'allprop' does not return values for all live properties.
   WebDAV servers increasingly have expensively-calculated or lengthy
   properties (see [&lt;a href=&quot;https://tools.ietf.org/html/rfc3253&quot;&gt;RFC3253&lt;/a&gt;] and [&lt;a href=&quot;https://tools.ietf.org/html/rfc3744&quot;&gt;RFC3744&lt;/a&gt;]) and do not return all
   properties already.  Instead, WebDAV clients can use propname
   requests to discover what live properties exist, and request named
   properties when retrieving values.  For a live property defined
   elsewhere, that definition can specify whether or not that live
   property would be returned in 'allprop' requests.

   All servers MUST support returning a response of content type text/
   xml or application/xml that contains a multistatus XML element that
   describes the results of the attempts to retrieve the various
   properties.

   If there is an error retrieving a property, then a proper error
   result MUST be included in the response.  A request to retrieve the
   value of a property that does not exist is an error and MUST be noted
   with a 'response' XML element that contains a 404 (Not Found) status
   value.

   Consequently, the 'multistatus' XML element for a collection resource
   MUST include a 'response' XML element for each member URL of the
   collection, to whatever depth was requested.  It SHOULD NOT include
   any 'response' elements for resources that are not WebDAV-compliant.
   Each 'response' element MUST contain an 'href' element that contains
   the URL of the resource on which the properties in the prop XML
   element are defined.  Results for a PROPFIND on a collection resource
   are returned as a flat list whose order of entries is not 

   significant.  Note that a resource may have only one value for a
   property of a given name, so the property may only show up once in
   PROPFIND responses.

   Properties may be subject to access control.  In the case of
   'allprop' and 'propname' requests, if a principal does not have the
   right to know whether a particular property exists, then the property
   MAY be silently excluded from the response.

   Some PROPFIND results MAY be cached, with care, as there is no cache
   validation mechanism for most properties.  This method is both safe
   and idempotent (see &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;Section&amp;nbsp;9.1 of [RFC2616]&lt;/a&gt;).</source>
          <target state="translated">如果资源没有任何内部成员，则PROPFIND方法将检索在Request-URI所标识的资源上定义的属性；如果资源是具有以下内容的集合，则该资源将在Request-URI所标识的资源及其可能的成员资源上定义内部成员网址。所有符合DAV的资源都必须支持PROPFIND方法和Profind XML元素（&lt;a href=&quot;#section-14.20&quot;&gt;第14.20节&lt;/a&gt;）以及为该元素定义的所有XML元素。客户端必须通过PROPFIND请求提交深度标头，其值为&amp;ldquo; 0&amp;rdquo;，&amp;ldquo; 1&amp;rdquo;或&amp;ldquo; infinity&amp;rdquo;。服务器必须在符合WebDAV的资源上支持&amp;ldquo; 0&amp;rdquo;和&amp;ldquo; 1&amp;rdquo;深度请求，并且应该支持&amp;ldquo;无限&amp;rdquo;请求。实际上，由于与此行为相关的性能和安全问题，可能会禁用对无限深度请求的支持。服务器应将没有深度标头的请求视为已包含&amp;ldquo;深度：无限&amp;rdquo;标头。客户端可以在请求方法的主体中提交&amp;ldquo; propfind&amp;rdquo; XML元素，以描述正在请求的信息。可以：o请求特定的属性值，通过在'prop'元素内命名所需的属性（服务器可以忽略此处的属性顺序），o通过使用'请求该规范中定义的那些属性的属性值（至少）以及无效属性。 allprop&amp;rdquo;元素（&amp;ldquo; include&amp;rdquo;元素可以与&amp;ldquo; allprop&amp;rdquo;一起使用，以指示服务器还包括其他可能未返回的实时属性），o请求资源上定义的所有属性的名称列表，通过使用&amp;ldquo; propname&amp;rdquo;元素。客户可以选择不提交请求正文。空的PROPFIND请求正文必须被视为&amp;ldquo; allprop&amp;rdquo;请求。请注意，&amp;ldquo; allprop&amp;rdquo;不会返回所有活动属性的值。WebDAV服务器越来越具有昂贵的计算或冗长的属性（请参阅[&lt;a href=&quot;https://tools.ietf.org/html/rfc3253&quot;&gt;RFC3253&lt;/a&gt; ]和[ &lt;a href=&quot;https://tools.ietf.org/html/rfc3744&quot;&gt;RFC3744&lt;/a&gt;]），并且不返回所有属性。相反，WebDAV客户端可以使用propname请求来发现存在的活动属性，并在检索值时请求命名属性。对于在其他位置定义的活动属性，该定义可以指定是否在&amp;ldquo; allprop&amp;rdquo;请求中返回该活动属性。所有服务器必须支持返回内容类型为text / xml或application / xml的响应，该响应包含多状态XML元素，该元素描述了尝试检索各种属性的结果。如果检索属性时发生错误，则必须在响应中包含正确的错误结果。检索不存在的属性值的请求是错误，必须以&amp;ldquo;响应&amp;rdquo;记录包含404（未找到）状态值的XML元素。因此，对于集合资源的&amp;ldquo;多状态&amp;rdquo; XML元素必须包括对集合的每个成员URL的&amp;ldquo;响应&amp;rdquo; XML元素，无论请求的深度如何。对于不符合WebDAV要求的资源，它不应包含任何&amp;ldquo;响应&amp;rdquo;元素。每个&amp;ldquo;响应&amp;rdquo;元素必须包含一个&amp;ldquo; href&amp;rdquo;元素，其中包含在其上定义prop XML元素属性的资源的URL。集合资源上PROPFIND的结果将作为平面列表返回，其条目顺序不重要。请注意，资源对于给定名称的属性可能只有一个值，因此该属性在PROPFIND响应中可能只显示一次。属性可能受访问控制。对于&amp;ldquo; allprop&amp;rdquo;和&amp;ldquo; propname&amp;rdquo;请求，如果委托人无权知道某个特定属性是否存在，则可以将该属性默默地排除在响应之外。某些PROPFIND结果可能要小心缓存，因为大多数属性没有缓存验证机制。此方法既安全又幂等（请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;[RFC2616]的9.1节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="63b7604adf362cf9b58baac42bf0c778df2e71b7" translate="yes" xml:space="preserve">
          <source>The PROPPATCH method processes instructions specified in the request
   body to set and/or remove properties defined on the resource
   identified by the Request-URI.

   All DAV-compliant resources MUST support the PROPPATCH method and
   MUST process instructions that are specified using the
   propertyupdate, set, and remove XML elements.  Execution of the
   directives in this method is, of course, subject to access control
   constraints.  DAV-compliant resources SHOULD support the setting of
   arbitrary dead properties.

   The request message body of a PROPPATCH method MUST contain the
   propertyupdate XML element.

   Servers MUST process PROPPATCH instructions in document order (an
   exception to the normal rule that ordering is irrelevant).
   Instructions MUST either all be executed or none executed.  Thus, if
   any error occurs during processing, all executed instructions MUST be
   undone and a proper error result returned.  Instruction processing
   details can be found in the definition of the set and remove
   instructions in Sections &lt;a href=&quot;#section-14.23&quot;&gt;14.23&lt;/a&gt; and &lt;a href=&quot;#section-14.26&quot;&gt;14.26&lt;/a&gt;.

   If a server attempts to make any of the property changes in a
   PROPPATCH request (i.e., the request is not rejected for high-level
   errors before processing the body), the response MUST be a Multi-
   Status response as described in &lt;a href=&quot;#section-9.2.1&quot;&gt;Section 9.2.1&lt;/a&gt;.

   This method is idempotent, but not safe (see &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;Section&amp;nbsp;9.1 of
   [RFC2616]&lt;/a&gt;).  Responses to this method MUST NOT be cached.</source>
          <target state="translated">PROPPATCH方法处理在请求正文中指定的指令，以设置和/或删除在Request-URI标识的资源上定义的属性。所有符合DAV的资源都必须支持PROPPATCH方法，并且必须处理使用propertyupdate，set和remove XML元素指定的指令。当然，此方法中指令的执行受访问控制约束。符合DAV的资源应支持任意无效属性的设置。 PROPPATCH方法的请求消息主体必须包含propertyupdate XML元素。服务器必须按文档顺序处理PROPPATCH指令（与顺序无关的普通规则是一个例外）。指令必须全部执行或不执行。从而，如果在处理过程中发生任何错误，则必须撤消所有已执行的指令，并返回正确的错误结果。可以在集合的定义中找到指令处理的详细信息，并在部分中删除指令。&lt;a href=&quot;#section-14.23&quot;&gt;14.23&lt;/a&gt;和&lt;a href=&quot;#section-14.26&quot;&gt;14.26&lt;/a&gt;。如果服务器尝试在PROPPATCH请求中进行任何属性更改（即，在处理主体之前，该请求不会因高级错误而被拒绝），则响应必须是&lt;a href=&quot;#section-9.2.1&quot;&gt;9.2.1节中&lt;/a&gt;描述的多状态响应。。此方法是幂等的，但并不安全（请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;[RFC2616]的9.1节&lt;/a&gt;）。对此方法的响应绝不能被缓存。</target>
        </trans-unit>
        <trans-unit id="601421813323ca4f0788af9d830329726cc8945b" translate="yes" xml:space="preserve">
          <source>The PUSH_PROMISE frame (type=0x5) is used to notify the peer endpoint
   in advance of streams the sender intends to initiate.  The
   PUSH_PROMISE frame includes the unsigned 31-bit identifier of the
   stream the endpoint plans to create along with a set of headers that
   provide additional context for the stream.  &lt;a href=&quot;#section-8.2&quot;&gt;Section 8.2&lt;/a&gt; contains a
   thorough description of the use of PUSH_PROMISE frames.

    +---------------+
    |Pad Length? (8)|
    +-+-------------+-----------------------------------------------+
    |R|                  Promised Stream ID (31)                    |
    +-+-----------------------------+-------------------------------+
    |                   Header Block Fragment (*)                 
    +---------------------------------------------------------------+
    |                           Padding (*)                       
    +---------------------------------------------------------------+

                  Figure 11: PUSH_PROMISE Payload Format

   The PUSH_PROMISE frame payload has the following fields:

   Pad Length:  An 8-bit field containing the length of the frame
      padding in units of octets.  This field is only present if the
      PADDED flag is set.

   R: A single reserved bit.

   Promised Stream ID:  An unsigned 31-bit integer that identifies the
      stream that is reserved by the PUSH_PROMISE.  The promised stream
      identifier MUST be a valid choice for the next stream sent by the
      sender (see &quot;new stream identifier&quot; in &lt;a href=&quot;#section-5.1.1&quot;&gt;Section 5.1.1&lt;/a&gt;).

   Header Block Fragment:  A header block fragment (&lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;)
      containing request header fields.

   Padding:  Padding octets. 

   The PUSH_PROMISE frame defines the following flags:

   END_HEADERS (0x4):  When set, bit 2 indicates that this frame
      contains an entire header block (&lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;) and is not followed
      by any CONTINUATION frames.

      A PUSH_PROMISE frame without the END_HEADERS flag set MUST be
      followed by a CONTINUATION frame for the same stream.  A receiver
      MUST treat the receipt of any other type of frame or a frame on a
      different stream as a connection error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type
      PROTOCOL_ERROR.

   PADDED (0x8):  When set, bit 3 indicates that the Pad Length field
      and any padding that it describes are present.

   PUSH_PROMISE frames MUST only be sent on a peer-initiated stream that
   is in either the &quot;open&quot; or &quot;half-closed (remote)&quot; state.  The stream
   identifier of a PUSH_PROMISE frame indicates the stream it is
   associated with.  If the stream identifier field specifies the value
   0x0, a recipient MUST respond with a connection error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;)
   of type PROTOCOL_ERROR.

   Promised streams are not required to be used in the order they are
   promised.  The PUSH_PROMISE only reserves stream identifiers for
   later use.

   PUSH_PROMISE MUST NOT be sent if the SETTINGS_ENABLE_PUSH setting of
   the peer endpoint is set to 0.  An endpoint that has set this setting
   and has received acknowledgement MUST treat the receipt of a
   PUSH_PROMISE frame as a connection error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type
   PROTOCOL_ERROR.

   Recipients of PUSH_PROMISE frames can choose to reject promised
   streams by returning a RST_STREAM referencing the promised stream
   identifier back to the sender of the PUSH_PROMISE.

   A PUSH_PROMISE frame modifies the connection state in two ways.
   First, the inclusion of a header block (&lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;) potentially
   modifies the state maintained for header compression.  Second,
   PUSH_PROMISE also reserves a stream for later use, causing the
   promised stream to enter the &quot;reserved&quot; state.  A sender MUST NOT
   send a PUSH_PROMISE on a stream unless that stream is either &quot;open&quot;
   or &quot;half-closed (remote)&quot;; the sender MUST ensure that the promised
   stream is a valid choice for a new stream identifier (&lt;a href=&quot;#section-5.1.1&quot;&gt;Section 5.1.1&lt;/a&gt;)
   (that is, the promised stream MUST be in the &quot;idle&quot; state). 

   Since PUSH_PROMISE reserves a stream, ignoring a PUSH_PROMISE frame
   causes the stream state to become indeterminate.  A receiver MUST
   treat the receipt of a PUSH_PROMISE on a stream that is neither
   &quot;open&quot; nor &quot;half-closed (local)&quot; as a connection error
   (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type PROTOCOL_ERROR.  However, an endpoint that
   has sent RST_STREAM on the associated stream MUST handle PUSH_PROMISE
   frames that might have been created before the RST_STREAM frame is
   received and processed.

   A receiver MUST treat the receipt of a PUSH_PROMISE that promises an
   illegal stream identifier (&lt;a href=&quot;#section-5.1.1&quot;&gt;Section 5.1.1&lt;/a&gt;) as a connection error
   (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type PROTOCOL_ERROR.  Note that an illegal stream
   identifier is an identifier for a stream that is not currently in the
   &quot;idle&quot; state.

   The PUSH_PROMISE frame can include padding.  Padding fields and flags
   are identical to those defined for DATA frames (&lt;a href=&quot;#section-6.1&quot;&gt;Section 6.1&lt;/a&gt;).</source>
          <target state="translated">PUSH_PROMISE帧（类型= 0x5）用于在发送方打算初始化的流之前通知对等终结点。 PUSH_PROMISE帧包括端点计划创建的流的无符号31位标识符，以及为流提供附加上下文的一组报头。&lt;a href=&quot;#section-8.2&quot;&gt;第8.2节&lt;/a&gt;包含对PUSH_PROMISE帧的使用的详尽描述。 + --------------- + |垫长？ （8）| +-+ ------------- + --------------------------------- -------------- + | R |承诺的流ID（31）| +-+ --------------------------------------------- + ----------------- -------------- + |标题块片段（*）+ ------------------------------------------- -------------------- + |填充（*）+ --------------------------------------------- ------------------ +图11：PUSH_PROMISE有效载荷格式PUSH_PROMISE帧有效载荷具有以下字段：填充长度：8位字段，其中包含帧填充的长度。八位位组的单位。仅当设置了PADDED标志时，此字段才存在。 R：单个保留位。承诺的流ID：一个无符号的31位整数，用于标识PUSH_PROMISE保留的流。承诺的流标识符必须是发送方发送的下一个流的有效选择（请参见&lt;a href=&quot;#section-5.1.1&quot;&gt;5.1.1节&lt;/a&gt;）。标头块片段：包含请求标头字段的标头块片段（&lt;a href=&quot;#section-4.3&quot;&gt;第4.3节&lt;/a&gt;）。填充：填充八位字节。 PUSH_PROMISE帧定义以下标志：END_HEADERS（0x4）：置位时，位2指示该帧包含整个标题块（&lt;a href=&quot;#section-4.3&quot;&gt;第4.3节&lt;/a&gt;），并且之后没有任何CONTINUATION帧。没有设置END_HEADERS标志的PUSH_PROMISE帧之后必须是同一流的CONTINUATION帧。接收方必须将接收到的任何其他类型的帧或不同流上的帧视为连接错误（&lt;a href=&quot;#section-5.4.1&quot;&gt;5.4.1节）&lt;/a&gt;），类型为PROTOCOL_ERROR。 PADDED（0x8）：设置时，位3指示存在&amp;ldquo;填充长度&amp;rdquo;字段及其描述的任何填充。 PUSH_PROMISE帧只能在处于&amp;ldquo;打开&amp;rdquo;或&amp;ldquo;半关闭（远程）&amp;rdquo;状态的对等方发起的流上发送。 PUSH_PROMISE帧的流标识符指示与之关联的流。如果流标识符字段指定值为0x0，则接收者务必以连接错误作为响应（&lt;a href=&quot;#section-5.4.1&quot;&gt;第5.4.1节）&lt;/a&gt;），类型为PROTOCOL_ERROR。不需要按照承诺的顺序使用承诺的流。 PUSH_PROMISE仅保留流标识符供以后使用。如果对等端点的SETTINGS_ENABLE_PUSH设置设为0，则不得发送PUSH_PROMISE。设置了此设置并已收到确认的端点必须将PUSH_PROMISE帧的接收视为PROTOCOL_ERROR类型的连接错误（&lt;a href=&quot;#section-5.4.1&quot;&gt;第5.4.1节&lt;/a&gt;）。 。 PUSH_PROMISE帧的接收者可以选择返回RST_STREAM，将已承诺的流标识符返回给PUSH_PROMISE的发送者，从而拒绝已承诺的流。 PUSH_PROMISE帧以两种方式修改连接状态。首先，包含一个标题块（&lt;a href=&quot;#section-4.3&quot;&gt;第4.3节）&lt;/a&gt;）可能会修改为标头压缩保留的状态。其次，PUSH_PROMISE还保留了一个流供以后使用，从而使承诺的流进入&amp;ldquo;保留&amp;rdquo;状态。发送者不得在该流上发送PUSH_PROMISE，除非该流是&amp;ldquo;开放&amp;rdquo;或&amp;ldquo;半封闭（远程）&amp;rdquo;；发送方必须确保承诺流是新流标识符的有效选择（&lt;a href=&quot;#section-5.1.1&quot;&gt;第5.1.1节&lt;/a&gt;）（也就是说，承诺流必须处于&amp;ldquo;空闲&amp;rdquo;状态）。由于PUSH_PROMISE保留流，因此忽略PUSH_PROMISE帧将导致流状态变得不确定。接收方必须将在既不是&amp;ldquo;开放&amp;rdquo;也不是&amp;ldquo;半封闭（本地）&amp;rdquo;的流上收到PUSH_PROMISE视为连接错误（&lt;a href=&quot;#section-5.4.1&quot;&gt;第5.4.1节）&lt;/a&gt;），类型为PROTOCOL_ERROR。但是，在相关流上发送了RST_STREAM的端点必须处理在接收和处理RST_STREAM帧之前可能已经创建的PUSH_PROMISE帧。接收方必须将收到的PUSH_PROMISE视为一个非法流标识符（&lt;a href=&quot;#section-5.1.1&quot;&gt;第5.1.1节&lt;/a&gt;）作为PROTOCOL_ERROR类型的连接错误（&lt;a href=&quot;#section-5.4.1&quot;&gt;第5.4.1节&lt;/a&gt;）。注意，非法流标识符是当前不处于&amp;ldquo;空闲&amp;rdquo;状态的流的标识符。 PUSH_PROMISE帧可以包含填充。填充字段和标志与为DATA帧定义的填充字段和标志相同（&lt;a href=&quot;#section-6.1&quot;&gt;第6.1节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="1975f22fa255d880d63431b9c6a1e839eaebbdbb" translate="yes" xml:space="preserve">
          <source>The PUT method requests that the enclosed entity be stored under the
   supplied Request-URI. If the Request-URI refers to an already
   existing resource, the enclosed entity SHOULD be considered as a
   modified version of the one residing on the origin server. If the
   Request-URI does not point to an existing resource, and that URI is
   capable of being defined as a new resource by the requesting user
   agent, the origin server can create the resource with that URI. If a
   new resource is created, the origin server MUST inform the user agent
   via the 201 (Created) response. If an existing resource is modified,
   either the 200 (OK) or 204 (No Content) response codes SHOULD be sent
   to indicate successful completion of the request. If the resource
   could not be created or modified with the Request-URI, an appropriate
   error response SHOULD be given that reflects the nature of the
   problem. The recipient of the entity MUST NOT ignore any Content-*
   (e.g. Content-Range) headers that it does not understand or implement
   and MUST return a 501 (Not Implemented) response in such cases.

   If the request passes through a cache and the Request-URI identifies
   one or more currently cached entities, those entries SHOULD be
   treated as stale. Responses to this method are not cacheable.

   The fundamental difference between the POST and PUT requests is
   reflected in the different meaning of the Request-URI. The URI in a
   POST request identifies the resource that will handle the enclosed
   entity. That resource might be a data-accepting process, a gateway to
   some other protocol, or a separate entity that accepts annotations.
   In contrast, the URI in a PUT request identifies the entity enclosed
   with the request -- the user agent knows what URI is intended and the
   server MUST NOT attempt to apply the request to some other resource.
   If the server desires that the request be applied to a different URI, 

   it MUST send a 301 (Moved Permanently) response; the user agent MAY
   then make its own decision regarding whether or not to redirect the
   request.

   A single resource MAY be identified by many different URIs. For
   example, an article might have a URI for identifying &quot;the current
   version&quot; which is separate from the URI identifying each particular
   version. In this case, a PUT request on a general URI might result in
   several other URIs being defined by the origin server.

   HTTP/1.1 does not define how a PUT method affects the state of an
   origin server.

   PUT requests MUST obey the message transmission requirements set out
   in &lt;a href=&quot;#section-8.2&quot;&gt;section 8.2&lt;/a&gt;.

   Unless otherwise specified for a particular entity-header, the
   entity-headers in the PUT request SHOULD be applied to the resource
   created or modified by the PUT.</source>
          <target state="translated">PUT方法请求将封闭的实体存储在提供的Request-URI下。如果Request-URI引用了已经存在的资源，则应将封闭的实体视为驻留在原始服务器上的实体的修改版本。如果Request-URI没有指向现有资源，并且请求用户代理可以将该URI定义为新资源，则原始服务器可以使用该URI创建资源。如果创建了新资源，则原始服务器务必通过201（已创建）响应通知用户代理。如果修改了现有资源，则应发送200（确定）或204（无内容）响应代码以指示请求已成功完成。如果无法使用Request-URI创建或修改资源，应该给出反映问题性质的适当的错误响应。实体的接收者不得忽略其无法理解或实现的任何Content-*（例如Content-Range）头，并且在这种情况下必须返回501（未实现）响应。如果请求通过缓存，并且Request-URI标识一个或多个当前缓存的实体，则应将这些条目视为过期。此方法的响应不可缓存。 POST和PUT请求之间的根本区别体现在Request-URI的不同含义上。 POST请求中的URI标识将处理封闭实体的资源。该资源可能是数据接受过程，某些其他协议的网关，或者是接受注释的单独实体。相比之下，PUT请求中的URI标识请求中包含的实体-用户代理知道URI的意图，并且服务器绝不能尝试将请求应用于其他资源。如果服务器希望将该请求应用于其他URI，则它必须发送301（永久移动）响应；然后，用户代理可以自行决定是否重定向请求。单个资源可以由许多不同的URI标识。例如，文章可能具有用于标识&amp;ldquo;当前版本&amp;rdquo;的URI，该URI与标识每个特定版本的URI分开。在这种情况下，对通用URI的PUT请求可能会导致原始服务器定义了其他几个URI。 HTTP / 1。1没有定义PUT方法如何影响原始服务器的状态。 PUT请求必须遵守消息传输要求&lt;a href=&quot;#section-8.2&quot;&gt;第8.2节&lt;/a&gt;。除非为特定的实体头另有规定，否则PUT请求中的实体头应该应用于由PUT创建或修改的资源。</target>
        </trans-unit>
        <trans-unit id="7beb3539a595c62f6de09ee642f7b3a560d38b59" translate="yes" xml:space="preserve">
          <source>The PUT method requests that the state of the target resource be
   created or replaced with the state defined by the representation
   enclosed in the request message payload.  A successful PUT of a given
   representation would suggest that a subsequent GET on that same
   target resource will result in an equivalent representation being
   sent in a 200 (OK) response.  However, there is no guarantee that 

   such a state change will be observable, since the target resource
   might be acted upon by other user agents in parallel, or might be
   subject to dynamic processing by the origin server, before any
   subsequent GET is received.  A successful response only implies that
   the user agent's intent was achieved at the time of its processing by
   the origin server.

   If the target resource does not have a current representation and the
   PUT successfully creates one, then the origin server MUST inform the
   user agent by sending a 201 (Created) response.  If the target
   resource does have a current representation and that representation
   is successfully modified in accordance with the state of the enclosed
   representation, then the origin server MUST send either a 200 (OK) or
   a 204 (No Content) response to indicate successful completion of the
   request.

   An origin server SHOULD ignore unrecognized header fields received in
   a PUT request (i.e., do not save them as part of the resource state).

   An origin server SHOULD verify that the PUT representation is
   consistent with any constraints the server has for the target
   resource that cannot or will not be changed by the PUT.  This is
   particularly important when the origin server uses internal
   configuration information related to the URI in order to set the
   values for representation metadata on GET responses.  When a PUT
   representation is inconsistent with the target resource, the origin
   server SHOULD either make them consistent, by transforming the
   representation or changing the resource configuration, or respond
   with an appropriate error message containing sufficient information
   to explain why the representation is unsuitable.  The 409 (Conflict)
   or 415 (Unsupported Media Type) status codes are suggested, with the
   latter being specific to constraints on Content-Type values.

   For example, if the target resource is configured to always have a
   Content-Type of &quot;text/html&quot; and the representation being PUT has a
   Content-Type of &quot;image/jpeg&quot;, the origin server ought to do one of:

   a.  reconfigure the target resource to reflect the new media type;

   b.  transform the PUT representation to a format consistent with that
       of the resource before saving it as the new resource state; or,

   c.  reject the request with a 415 (Unsupported Media Type) response
       indicating that the target resource is limited to &quot;text/html&quot;,
       perhaps including a link to a different resource that would be a
       suitable target for the new representation. 

   HTTP does not define exactly how a PUT method affects the state of an
   origin server beyond what can be expressed by the intent of the user
   agent request and the semantics of the origin server response.  It
   does not define what a resource might be, in any sense of that word,
   beyond the interface provided via HTTP.  It does not define how
   resource state is &quot;stored&quot;, nor how such storage might change as a
   result of a change in resource state, nor how the origin server
   translates resource state into representations.  Generally speaking,
   all implementation details behind the resource interface are
   intentionally hidden by the server.

   An origin server MUST NOT send a validator header field
   (&lt;a href=&quot;#section-7.2&quot;&gt;Section 7.2&lt;/a&gt;), such as an ETag or Last-Modified field, in a
   successful response to PUT unless the request's representation data
   was saved without any transformation applied to the body (i.e., the
   resource's new representation data is identical to the representation
   data received in the PUT request) and the validator field value
   reflects the new representation.  This requirement allows a user
   agent to know when the representation body it has in memory remains
   current as a result of the PUT, thus not in need of being retrieved
   again from the origin server, and that the new validator(s) received
   in the response can be used for future conditional requests in order
   to prevent accidental overwrites (&lt;a href=&quot;#section-5.2&quot;&gt;Section 5.2&lt;/a&gt;).

   The fundamental difference between the POST and PUT methods is
   highlighted by the different intent for the enclosed representation.
   The target resource in a POST request is intended to handle the
   enclosed representation according to the resource's own semantics,
   whereas the enclosed representation in a PUT request is defined as
   replacing the state of the target resource.  Hence, the intent of PUT
   is idempotent and visible to intermediaries, even though the exact
   effect is only known by the origin server.

   Proper interpretation of a PUT request presumes that the user agent
   knows which target resource is desired.  A service that selects a
   proper URI on behalf of the client, after receiving a state-changing
   request, SHOULD be implemented using the POST method rather than PUT.
   If the origin server will not make the requested PUT state change to
   the target resource and instead wishes to have it applied to a
   different resource, such as when the resource has been moved to a
   different URI, then the origin server MUST send an appropriate 3xx
   (Redirection) response; the user agent MAY then make its own decision
   regarding whether or not to redirect the request.

   A PUT request applied to the target resource can have side effects on
   other resources.  For example, an article might have a URI for
   identifying &quot;the current version&quot; (a resource) that is separate from
   the URIs identifying each particular version (different resources 

   that at one point shared the same state as the current version
   resource).  A successful PUT request on &quot;the current version&quot; URI
   might therefore create a new version resource in addition to changing
   the state of the target resource, and might also cause links to be
   added between the related resources.

   An origin server that allows PUT on a given target resource MUST send
   a 400 (Bad Request) response to a PUT request that contains a
   Content-Range header field (&lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-4.2&quot;&gt;Section&amp;nbsp;4.2 of [RFC7233]&lt;/a&gt;), since the
   payload is likely to be partial content that has been mistakenly PUT
   as a full representation.  Partial content updates are possible by
   targeting a separately identified resource with state that overlaps a
   portion of the larger resource, or by using a different method that
   has been specifically defined for partial updates (for example, the
   PATCH method defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc5789&quot;&gt;RFC5789&lt;/a&gt;]).

   Responses to the PUT method are not cacheable.  If a successful PUT
   request passes through a cache that has one or more stored responses
   for the effective request URI, those stored responses will be
   invalidated (see &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.4&quot;&gt;Section&amp;nbsp;4.4 of [RFC7234]&lt;/a&gt;).</source>
          <target state="translated">PUT方法请求创建目标资源的状态或将其替换为请求消息有效负载中包含的表示形式所定义的状态。给定表示的成功PUT将表明，在同一目标资源上进行的后续GET将导致在200（OK）响应中发送等效表示。但是，不能保证这样的状态更改是可观察到的，因为在接收到任何后续GET之前，目标资源可能由其他用户代理并行作用，或者可能由源服务器进行动态处理。成功的响应仅表示原始服务器在处理用户代理时已达到其意图。如果目标资源没有当前表示，并且PUT成功创建了一个表示，则原始服务器务必通过发送201（已创建）响应来通知用户代理。如果目标资源确实具有当前表示形式，并且该表示形式已根据封闭表示形式的状态成功进行了修改，则原始服务器务必发送200（确定）或204（无内容）响应，以指示成功完成了请求。源服务器应该忽略在PUT请求中接收到的无法识别的头字段（即，不要将它们保存为资源状态的一部分）。原始服务器应验证PUT表示是否与服务器对目标资源的任何约束一致，该约束不能由PUT更改，也不会由PUT更改。当源服务器使用与URI相关的内部配置信息以便为GET响应设置表示元数据的值时，这尤其重要。当PUT表示与目标资源不一致时，源服务器应通过转换表示或更改资源配置来使其一致，或者使用包含足够信息的适当错误消息进行响应，以解释为什么该表示不合适。建议使用409（冲突）或415（不受支持的媒体类型）状态码，后者专用于对Content-Type值的限制。例如，如果目标资源配置为始终具有&amp;ldquo; text / html&amp;rdquo;的Content-Type并且表示为PUT的Content-Type为&amp;ldquo; image / jpeg&amp;rdquo;，原始服务器应执行以下操作之一：重新配置目标资源以反映新的媒体类型； b。将PUT表示形式转换为与资源一致的格式，然后再将其保存为新的资源状态；或c。使用415（不支持的媒体类型）响应拒绝该请求，该响应指示目标资源仅限于&amp;ldquo; text / html&amp;rdquo;，可能包括指向其他​​资源的链接，该链接将是新表示形式的合适目标。 HTTP并未明确定义PUT方法如何影响原始服务器的状态，超出了用户代理请求的意图和原始服务器响应的语义所能表达的范围。无论从什么意义上讲，它都没有定义通过HTTP提供的接口之外的资源。它没有定义资源状态的&amp;ldquo;存储&amp;rdquo;方式，也没有定义由于资源状态变化而导致的存储方式如何变化，也没有定义原始服务器如何将资源状态转换为表示形式。通常，服务器故意隐藏资源接口后面的所有实现细节。源服务器不得发送验证者头字段（服务器有意隐藏了资源接口后面的所有实现细节。源服务器不得发送验证者头字段（服务器有意隐藏了资源接口后面的所有实现细节。源服务器不得发送验证者头字段（&lt;a href=&quot;#section-7.2&quot;&gt;第7.2节&lt;/a&gt;）（例如ETag或Last-Modified字段）在成功响应PUT之前，除非保存请求的表示形式数据而未对主体应用任何转换（即资源的新表示形式数据与在其中接收到的表示数据相同） PUT请求）和验证者字段的值反映了新的表示形式。此要求允许用户代理知道它在内存中的表示体何时由于PUT而保持最新状态，因此不需要再次从源服务器检索，并且响应中接收到新的验证器。可以用于将来的条件请求，以防止意外覆盖（&lt;a href=&quot;#section-5.2&quot;&gt;第5.2节&lt;/a&gt;）。 POST和PUT方法之间的根本区别通过封闭表示的不同意图得以突出。 POST请求中的目标资源旨在根据资源自身的语义处理封闭的表示形式，而PUT请求中的封闭的表示形式则定义为替换目标资源的状态。因此，即使确切的效果仅由原始服务器知道，PUT的意图也是幂等的，并且对中介者可见。对PUT请求的正确解释假定用户代理知道需要哪个目标资源。在收到状态更改请求后，代表客户选择适当URI的服务应使用POST方法而非PUT实现。如果原始服务器不会将请求的PUT状态更改为目标资源，而是希望将其应用于其他资源（例如，当资源已移至其他URI时），则原始服务器务必发送适当的3xx （重定向）响应；然后，用户代理可以自行决定是否重定向请求。应用于目标资源的PUT请求可能会对其他资源产生副作用。例如，文章可能具有用于标识&amp;ldquo;当前版本&amp;rdquo;（一种资源）的URI，该URI与标识每个特定版本的URI（在某一点与当前版本资源共享相同状态的不同资源）分开。在&amp;ldquo;当前版本&amp;rdquo;上成功的PUT请求因此，除了更改目标资源的状态之外，URI可能还会创建新的版本资源，并且可能还会导致在相关资源之间添加链接。允许在给定目标资源上进行PUT的原始服务器必须向包含内容范围标头字段的PUT请求发送400（错误请求）响应（&lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-4.2&quot;&gt;[RFC7233]的第4.2节&lt;/a&gt;），因为有效负载可能是部分内容，但已误将其作为完整表示进行了PUT。通过以状态与较大资源的一部分重叠的状态单独标识资源为目标，或者通过使用专门为部分更新定义的其他方法（例如，在[ &lt;a href=&quot;https://tools.ietf.org/html/rfc5789&quot;&gt;RFC5789&lt;/a&gt; ]中定义的PATCH方法），可以进行部分内容更新。对PUT方法的响应不可缓存。如果成功的PUT请求通过具有有效请求URI的一个或多个存储响应的缓存，则这些存储的响应将无效（请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.4&quot;&gt;[RFC7234]的4.4节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="6e42dfbab6315a9d1786cb94b26bfc16b764a831" translate="yes" xml:space="preserve">
          <source>The Pragma general-header field is used to include implementation-
   specific directives that might apply to any recipient along the
   request/response chain. All pragma directives specify optional
   behavior from the viewpoint of the protocol; however, some systems
   MAY require that behavior be consistent with the directives.

       Pragma            = &quot;Pragma&quot; &quot;:&quot; 1#pragma-directive
       pragma-directive  = &quot;no-cache&quot; | extension-pragma
       extension-pragma  = token [ &quot;=&quot; ( token | quoted-string ) ]

   When the no-cache directive is present in a request message, an
   application SHOULD forward the request toward the origin server even
   if it has a cached copy of what is being requested. This pragma
   directive has the same semantics as the no-cache cache-directive (see
   &lt;a href=&quot;#section-14.9&quot;&gt;section 14.9&lt;/a&gt;) and is defined here for backward compatibility with
   HTTP/1.0. Clients SHOULD include both header fields when a no-cache
   request is sent to a server not known to be HTTP/1.1 compliant. 

   Pragma directives MUST be passed through by a proxy or gateway
   application, regardless of their significance to that application,
   since the directives might be applicable to all recipients along the
   request/response chain. It is not possible to specify a pragma for a
   specific recipient; however, any pragma directive not relevant to a
   recipient SHOULD be ignored by that recipient.

   HTTP/1.1 caches SHOULD treat &quot;Pragma: no-cache&quot; as if the client had
   sent &quot;Cache-Control: no-cache&quot;. No new Pragma directives will be
   defined in HTTP.

      Note: because the meaning of &quot;Pragma: no-cache as a response
      header field is not actually specified, it does not provide a
      reliable replacement for &quot;Cache-Control: no-cache&quot; in a response</source>
          <target state="translated">Pragma通用标头字段用于包含特定于实现的指令，这些指令可能适用于请求/响应链中的任何接收者。从协议的角度来看，所有编译指示都指定了可选的行为。但是，某些系统可能要求行为与指令保持一致。 Pragma =&amp;ldquo; Pragma&amp;rdquo;&amp;ldquo; ::&amp;rdquo; 1＃pragma指令pragma指令=&amp;ldquo; no-cache&amp;rdquo; | extension-pragma extension-pragma = token [&amp;ldquo; =&amp;rdquo;（token | quoted-string）]当请求消息中存在no-cache指令时，即使应用程序具有缓存副本，应用程序也应将请求转发至原始服务器请求的内容。 该pragma伪指令与no-cache cache-directive具有相同的语义（请参阅&lt;a href=&quot;#section-14.9&quot;&gt;第14.9节）。&lt;/a&gt;），并在此处定义为与HTTP / 1.0向后兼容。当向服务器发送不缓存请求（不符合HTTP / 1.1规范）时，客户端应同时包含两个标头字段。代理程序或网关应用程序必须传递实用指令，而不考虑它们对该应用程序的重要性，因为该指令可能适用于请求/响应链中的所有接收者。无法为特定收件人指定实用程序；但是，任何与接收者无关的编译指示都应被该接收者忽略。 HTTP / 1.1缓存应将&amp;ldquo; Pragma：no-cache&amp;rdquo;视为客户端已发送&amp;ldquo; Cache-Control：no-cache&amp;rdquo;。 HTTP中不会定义新的Pragma指令。注意：因为&amp;ldquo; Pragma：由于没有实际指定响应头字段，因此没有提供no-cache，它不能在响应中可靠地替代&amp;ldquo; Cache-Control：no-cache&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="871bcdf53c1b79539586617d7fc176e073aa2706" translate="yes" xml:space="preserve">
          <source>The Proxy-Authenticate response-header field MUST be included as part
   of a 407 (Proxy Authentication Required) response. The field value
   consists of a challenge that indicates the authentication scheme and
   parameters applicable to the proxy for this Request-URI.

       Proxy-Authenticate  = &quot;Proxy-Authenticate&quot; &quot;:&quot; 1#challenge

   The HTTP access authentication process is described in &quot;HTTP
   Authentication: Basic and Digest Access Authentication&quot; [&lt;a href=&quot;#ref-43&quot;&gt;43&lt;/a&gt;]. Unlike
   WWW-Authenticate, the Proxy-Authenticate header field applies only to
   the current connection and SHOULD NOT be passed on to downstream
   clients. However, an intermediate proxy might need to obtain its own
   credentials by requesting them from the downstream client, which in
   some circumstances will appear as if the proxy is forwarding the
   Proxy-Authenticate header field.</source>
          <target state="translated">必须将Proxy-Authenticate响应标头字段作为407（需要代理认证）响应的一部分包括在内。该字段值包含一个质询，该质询指示适用于此Request-URI的代理的身份验证方案和参数。 Proxy-Authenticate =&amp;ldquo; Proxy-Authenticate&amp;rdquo;&amp;ldquo; ::&amp;rdquo; 1＃挑战&amp;ldquo; HTTP身份验证：基本和摘要访问身份验证&amp;rdquo;中描述了HTTP访问身份验证过程[ &lt;a href=&quot;#ref-43&quot;&gt;43&lt;/a&gt;]。与WWW-Authenticate不同，Proxy-Authenticate标头字段仅适用于当前连接，不应将其传递给下游客户端。但是，中间代理可能需要通过向下游客户端请求它们来获取其自身的凭据，在某些情况下，中间代理看起来像是在转发Proxy-Authenticate标头字段。</target>
        </trans-unit>
        <trans-unit id="ad6052a85e2e7f8497d8ed5920ca77e487770b52" translate="yes" xml:space="preserve">
          <source>The Proxy-Authorization request-header field allows the client to
   identify itself (or its user) to a proxy which requires
   authentication. The Proxy-Authorization field value consists of
   credentials containing the authentication information of the user
   agent for the proxy and/or realm of the resource being requested.

       Proxy-Authorization     = &quot;Proxy-Authorization&quot; &quot;:&quot; credentials

   The HTTP access authentication process is described in &quot;HTTP
   Authentication: Basic and Digest Access Authentication&quot; [&lt;a href=&quot;#ref-43&quot;&gt;43&lt;/a&gt;] . Unlike
   Authorization, the Proxy-Authorization header field applies only to
   the next outbound proxy that demanded authentication using the Proxy-
   Authenticate field. When multiple proxies are used in a chain, the 

   Proxy-Authorization header field is consumed by the first outbound
   proxy that was expecting to receive credentials. A proxy MAY relay
   the credentials from the client request to the next proxy if that is
   the mechanism by which the proxies cooperatively authenticate a given
   request.</source>
          <target state="translated">Proxy-Authorization请求标头字段允许客户端向需要身份验证的代理标识自己（或其用户）。 Proxy-Authorization字段值由凭据组成，这些凭据包含用于所请求资源的代理和/或领域的用户代理的身份验证信息。 Proxy-Authorization =&amp;ldquo; Proxy-Authorization&amp;rdquo;&amp;ldquo;：&amp;rdquo;凭证HTTP访问认证过程在&amp;ldquo; HTTP认证：基本和摘要访问认证&amp;rdquo; [ &lt;a href=&quot;#ref-43&quot;&gt;43&lt;/a&gt;]。与授权不同，&amp;ldquo;代理授权&amp;rdquo;标头字段仅适用于需要使用&amp;ldquo;代理身份验证&amp;rdquo;字段进行身份验证的下一个出站代理。当一条链中使用多个代理时，第一个要接收凭据的出站代理会使用Proxy-Authorization标头字段。代理可以将证书从客户请求中继到下一个代理，如果这是代理协同认证给定请求的机制。</target>
        </trans-unit>
        <trans-unit id="3fb25443f99d4a6f4c3661e5265360468e08d470" translate="yes" xml:space="preserve">
          <source>The RST_STREAM frame (type=0x3) allows for immediate termination of a
   stream.  RST_STREAM is sent to request cancellation of a stream or to
   indicate that an error condition has occurred.

    +---------------------------------------------------------------+
    |                        Error Code (32)                        |
    +---------------------------------------------------------------+

                    Figure 9: RST_STREAM Frame Payload

   The RST_STREAM frame contains a single unsigned, 32-bit integer
   identifying the error code (&lt;a href=&quot;#section-7&quot;&gt;Section 7&lt;/a&gt;).  The error code indicates why
   the stream is being terminated.

   The RST_STREAM frame does not define any flags.

   The RST_STREAM frame fully terminates the referenced stream and
   causes it to enter the &quot;closed&quot; state.  After receiving a RST_STREAM
   on a stream, the receiver MUST NOT send additional frames for that
   stream, with the exception of PRIORITY.  However, after sending the
   RST_STREAM, the sending endpoint MUST be prepared to receive and
   process additional frames sent on the stream that might have been
   sent by the peer prior to the arrival of the RST_STREAM.

   RST_STREAM frames MUST be associated with a stream.  If a RST_STREAM
   frame is received with a stream identifier of 0x0, the recipient MUST
   treat this as a connection error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type
   PROTOCOL_ERROR.

   RST_STREAM frames MUST NOT be sent for a stream in the &quot;idle&quot; state.
   If a RST_STREAM frame identifying an idle stream is received, the
   recipient MUST treat this as a connection error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of
   type PROTOCOL_ERROR.

   A RST_STREAM frame with a length other than 4 octets MUST be treated
   as a connection error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type FRAME_SIZE_ERROR.</source>
          <target state="translated">RST_STREAM帧（类型= 0x3）允许立即终止流。发送RST_STREAM以请求取消流或指示发生了错误情况。 + ------------------------------------------------- -------------- + |错误代码（32）| + ------------------------------------------------- -------------- +图9：RST_STREAM帧有效载荷RST_STREAM帧包含一个唯一的无符号32位整数，用于标识错误代码（&lt;a href=&quot;#section-7&quot;&gt;第7节）&lt;/a&gt;）。错误代码指示为什么终止流。 RST_STREAM帧未定义任何标志。 RST_STREAM帧完全终止引用的流，并使它进入&amp;ldquo;关闭&amp;rdquo;状态。在接收到流上的RST_STREAM之后，接收者必须不发送该流的其他帧，优先级除外。但是，在发送了RST_STREAM之后，发送端点必须准备好接收和处理在流上发送的其他帧，这些帧可能是在RST_STREAM到达之前由对等方发送的。 RST_STREAM帧必须与流关联。如果收到流标识符为0x0的RST_STREAM帧，则接收者务必将此视为连接错误（&lt;a href=&quot;#section-5.4.1&quot;&gt;第5.4.1节）&lt;/a&gt;），类型为PROTOCOL_ERROR。 RST_STREAM帧不得以&amp;ldquo;空闲&amp;rdquo;状态发送给流。如果接收到标识空闲流的RST_STREAM帧，则接收者必须将此视为PROTOCOL_ERROR类型的连接错误（&lt;a href=&quot;#section-5.4.1&quot;&gt;第5.4.1节&lt;/a&gt;）。长度非4个八位位组的RST_STREAM帧必须被视为FRAME_SIZE_ERROR类型的连接错误（&lt;a href=&quot;#section-5.4.1&quot;&gt;第5.4.1节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="a2e20c61425846c0564c678e617e3a0e40ac8e14" translate="yes" xml:space="preserve">
          <source>The Referer[sic] request-header field allows the client to specify,
   for the server's benefit, the address (URI) of the resource from
   which the Request-URI was obtained (the &quot;referrer&quot;, although the
   header field is misspelled.) The Referer request-header allows a
   server to generate lists of back-links to resources for interest,
   logging, optimized caching, etc. It also allows obsolete or mistyped
   links to be traced for maintenance. The Referer field MUST NOT be
   sent if the Request-URI was obtained from a source that does not have
   its own URI, such as input from the user keyboard.

       Referer        = &quot;Referer&quot; &quot;:&quot; ( absoluteURI | relativeURI )

   Example:

       Referer: &lt;a href=&quot;http://www.w3.org/hypertext/DataSources/Overview.html&quot;&gt;http://www.w3.org/hypertext/DataSources/Overview.html&lt;/a&gt; 

   If the field value is a relative URI, it SHOULD be interpreted
   relative to the Request-URI. The URI MUST NOT include a fragment. See
   &lt;a href=&quot;#section-15.1.3&quot;&gt;section 15.1.3&lt;/a&gt; for security considerations.</source>
          <target state="translated">Referer [sic] request-header字段允许客户端为服务器的利益指定从中获取Request-URI的资源的地址（URI）（&amp;ldquo; referrer&amp;rdquo;，尽管标头字段拼写错误）。 Referer请求标头允许服务器生成指向资源的反向链接列表，以进行关注，日志记录，优化的缓存等。它还允许跟踪过时或类型错误的链接以进行维护。如果Request-URI是从没有自己的URI的源（例如来自用户键盘的输入）获得的，则不得发送Referer字段。 Referer =&amp;ldquo; Referer&amp;rdquo;&amp;ldquo;：&amp;rdquo;（absoluteURI | relativeURI）示例：引用者：&lt;a href=&quot;http://www.w3.org/hypertext/DataSources/Overview.html&quot;&gt;http&lt;/a&gt; : //www.w3.org/hypertext/DataSources/Overview.html 如果该字段值是相对URI，则应相对于Request-URI进行解释。URI不得包含片段。出于安全考虑，请参阅 &lt;a href=&quot;#section-15.1.3&quot;&gt;第15.1.3节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c0091308c0468b84ee0f64008295744c23a2f601" translate="yes" xml:space="preserve">
          <source>The Referer[sic] request-header field allows the client to specify,
   for the server's benefit, the address (URI) of the resource from
   which the Request-URI was obtained (the &quot;referrer&quot;, although the
   header field is misspelled.) The Referer request-header allows a
   server to generate lists of back-links to resources for interest,
   logging, optimized caching, etc. It also allows obsolete or mistyped
   links to be traced for maintenance. The Referer field MUST NOT be
   sent if the Request-URI was obtained from a source that does not have
   its own URI, such as input from the user keyboard.

       Referer        = &quot;Referer&quot; &quot;:&quot; ( absoluteURI | relativeURI )

   Example:

       Referer: &lt;a href=&quot;https://www.w3.org/hypertext/DataSources/Overview.html&quot;&gt;http://www.w3.org/hypertext/DataSources/Overview.html&lt;/a&gt; 

   If the field value is a relative URI, it SHOULD be interpreted
   relative to the Request-URI. The URI MUST NOT include a fragment. See
   &lt;a href=&quot;#section-15.1.3&quot;&gt;section 15.1.3&lt;/a&gt; for security considerations.</source>
          <target state="translated">Referer [sic] request-header字段允许客户端为服务器的利益指定从中获取Request-URI的资源的地址（URI）（&amp;ldquo; referrer&amp;rdquo;，尽管标头字段拼写错误）。 Referer请求标头允许服务器生成指向资源的反向链接列表，以进行关注，日志记录，优化的缓存等。它还允许跟踪过时或类型错误的链接以进行维护。如果Request-URI是从没有自己的URI的源（例如来自用户键盘的输入）获得的，则不得发送Referer字段。 Referer =&amp;ldquo; Referer&amp;rdquo;&amp;ldquo;：&amp;rdquo;（absoluteURI | relativeURI）示例：引用者：&lt;a href=&quot;https://www.w3.org/hypertext/DataSources/Overview.html&quot;&gt;http&lt;/a&gt; : //www.w3.org/hypertext/DataSources/Overview.html如果该字段值是相对URI，则应相对于Request-URI进行解释。URI不得包含片段。出于安全考虑，请参阅&lt;a href=&quot;#section-15.1.3&quot;&gt;第15.1.3节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ada285615064adfa5d8e8460b22e8d2e1a9f7a60" translate="yes" xml:space="preserve">
          <source>The Request-Line begins with a method token, followed by the
   Request-URI and the protocol version, and ending with CRLF. The
   elements are separated by SP characters. No CR or LF is allowed
   except in the final CRLF sequence.

        Request-Line   = Method SP Request-URI SP HTTP-Version CRLF</source>
          <target state="translated">请求行以方法标记开始,后面是请求URI和协议版本,最后是CRLF。这些元素由SP字符分隔。除最后的CRLF序列外,不允许有CR或LF。Request-Line=Method SP Request-URI SP HTTP-Version CRLF。</target>
        </trans-unit>
        <trans-unit id="8314c65661bfa76aafcdfccc2a0cabd4c8b07f40" translate="yes" xml:space="preserve">
          <source>The Request-URI is a Uniform Resource Identifier (&lt;a href=&quot;#section-3.2&quot;&gt;section 3.2&lt;/a&gt;) and
   identifies the resource upon which to apply the request.

       Request-URI    = &quot;*&quot; | absoluteURI | abs_path | authority

   The four options for Request-URI are dependent on the nature of the
   request. The asterisk &quot;*&quot; means that the request does not apply to a
   particular resource, but to the server itself, and is only allowed
   when the method used does not necessarily apply to a resource. One
   example would be

       OPTIONS * HTTP/1.1

   The absoluteURI form is REQUIRED when the request is being made to a
   proxy. The proxy is requested to forward the request or service it
   from a valid cache, and return the response. Note that the proxy MAY
   forward the request on to another proxy or directly to the server 

   specified by the absoluteURI. In order to avoid request loops, a
   proxy MUST be able to recognize all of its server names, including
   any aliases, local variations, and the numeric IP address. An example
   Request-Line would be:

       GET &lt;a href=&quot;http://www.w3.org/pub/WWW/TheProject.html&quot;&gt;http://www.w3.org/pub/WWW/TheProject.html&lt;/a&gt; HTTP/1.1

   To allow for transition to absoluteURIs in all requests in future
   versions of HTTP, all HTTP/1.1 servers MUST accept the absoluteURI
   form in requests, even though HTTP/1.1 clients will only generate
   them in requests to proxies.

   The authority form is only used by the CONNECT method (&lt;a href=&quot;#section-9.9&quot;&gt;section 9.9&lt;/a&gt;).

   The most common form of Request-URI is that used to identify a
   resource on an origin server or gateway. In this case the absolute
   path of the URI MUST be transmitted (see &lt;a href=&quot;#section-3.2.1&quot;&gt;section 3.2.1&lt;/a&gt;, abs_path) as
   the Request-URI, and the network location of the URI (authority) MUST
   be transmitted in a Host header field. For example, a client wishing
   to retrieve the resource above directly from the origin server would
   create a TCP connection to port 80 of the host &quot;www.w3.org&quot; and send
   the lines:

       GET /pub/WWW/TheProject.html HTTP/1.1
       Host: www.w3.org

   followed by the remainder of the Request. Note that the absolute path
   cannot be empty; if none is present in the original URI, it MUST be
   given as &quot;/&quot; (the server root).

   The Request-URI is transmitted in the format specified in &lt;a href=&quot;#section-3.2.1&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-3.2.1&quot;&gt;3.2.1&lt;/a&gt;. If the Request-URI is encoded using the &quot;% HEX HEX&quot; encoding
   [&lt;a href=&quot;#ref-42&quot;&gt;42&lt;/a&gt;], the origin server MUST decode the Request-URI in order to
   properly interpret the request. Servers SHOULD respond to invalid
   Request-URIs with an appropriate status code.

   A transparent proxy MUST NOT rewrite the &quot;abs_path&quot; part of the
   received Request-URI when forwarding it to the next inbound server,
   except as noted above to replace a null abs_path with &quot;/&quot;.

      Note: The &quot;no rewrite&quot; rule prevents the proxy from changing the
      meaning of the request when the origin server is improperly using
      a non-reserved URI character for a reserved purpose.  Implementors
      should be aware that some pre-HTTP/1.1 proxies have been known to
      rewrite the Request-URI.</source>
          <target state="translated">Request-URI是统一资源标识符（&lt;a href=&quot;#section-3.2&quot;&gt;第3.2节&lt;/a&gt;），并标识在其上应用请求的资源。 Request-URI =&amp;ldquo; *&amp;rdquo; | absoluteURI | abs_path |权限Request-URI的四个选项取决于请求的性质。星号&amp;ldquo; *&amp;rdquo;表示请求不适用于特定资源，而是适用于服务器本身，并且仅在所使用的方法不一定适用于资源时才允许。一个示例是OPTIONS * HTTP / 1.1向代理发出请求时，需要absoluteURI形式。请求代理转发请求或从有效缓存中为其提供服务，并返回响应。注意，代理可以将请求转发到另一个代理，或者直接转发到absoluteURI指定的服务器。为了避免请求循环，代理必须能够识别其所有服务器名称，包括任何别名，本地变体和数字IP地址。请求行示例为：GET&lt;a href=&quot;http://www.w3.org/pub/WWW/TheProject.html&quot;&gt;http://www.w3.org/pub/WWW/TheProject.html&lt;/a&gt; HTTP / 1.1为了在将来的HTTP版本中允许在所有请求中转换为absoluteURI，即使所有HTTP / 1.1服务器也必须在请求中接受absoluteURI形式，即使HTTP / 1.1客户端只会在对代理的请求中生成它们。授权表仅由CONNECT方法使用（&lt;a href=&quot;#section-9.9&quot;&gt;第9.9节&lt;/a&gt;）。 Request-URI的最常见形式是用于标识源服务器或网关上的资源的形式。在这种情况下，必须发送URI的绝对路径（参见&lt;a href=&quot;#section-3.2.1&quot;&gt;3.2.1节）。&lt;/a&gt;（例如abs_path）作为请求URI，并且URI（授权）的网络位置必须在主机标头字段中传输。例如，希望直接从源服务器检索以上资源的客户端将创建到主机&amp;ldquo; www.w3.org&amp;rdquo;的端口80的TCP连接，并发送以下行：GET /pub/WWW/TheProject.html HTTP / 1.1主机：www.w3.org，后跟请求的其余部分。注意绝对路径不能为空；如果原始URI中没有任何内容，则必须将其指定为&amp;ldquo; /&amp;rdquo;（服务器根目录）。 Request-URI以&lt;a href=&quot;#section-3.2.1&quot;&gt;3.2.1 &lt;/a&gt;&lt;a href=&quot;#section-3.2.1&quot;&gt;节中&lt;/a&gt;指定的格式发送。如果请求URI是使用&amp;ldquo;％HEX HEX&amp;rdquo;编码[ &lt;a href=&quot;#ref-42&quot;&gt;42&lt;/a&gt;]，原始服务器必须解码Request-URI，以正确解释请求。服务器应使用适当的状态码响应无效的Request-URI。当透明的代理转发到下一个入站服务器时，绝不能重写接收到的Request-URI的&amp;ldquo; abs_path&amp;rdquo;部分，除非如上所述，否则用&amp;ldquo; /&amp;rdquo;替换空的abs_path。注意：当原始服务器为保留的目的不正确地使用非保留的URI字符时，&amp;ldquo;不重写&amp;rdquo;规则可防止代理更改请求的含义。实现者应注意，已知一些HTTP / 1.1之前的代理可以重写Request-URI。</target>
        </trans-unit>
        <trans-unit id="1b7981c08ac4de37a8ea2b93d3e5c2168d3aee17" translate="yes" xml:space="preserve">
          <source>The Request-URI is a Uniform Resource Identifier (&lt;a href=&quot;#section-3.2&quot;&gt;section 3.2&lt;/a&gt;) and
   identifies the resource upon which to apply the request.

       Request-URI    = &quot;*&quot; | absoluteURI | abs_path | authority

   The four options for Request-URI are dependent on the nature of the
   request. The asterisk &quot;*&quot; means that the request does not apply to a
   particular resource, but to the server itself, and is only allowed
   when the method used does not necessarily apply to a resource. One
   example would be

       OPTIONS * HTTP/1.1

   The absoluteURI form is REQUIRED when the request is being made to a
   proxy. The proxy is requested to forward the request or service it
   from a valid cache, and return the response. Note that the proxy MAY
   forward the request on to another proxy or directly to the server 

   specified by the absoluteURI. In order to avoid request loops, a
   proxy MUST be able to recognize all of its server names, including
   any aliases, local variations, and the numeric IP address. An example
   Request-Line would be:

       GET &lt;a href=&quot;https://www.w3.org/pub/WWW/TheProject.html&quot;&gt;http://www.w3.org/pub/WWW/TheProject.html&lt;/a&gt; HTTP/1.1

   To allow for transition to absoluteURIs in all requests in future
   versions of HTTP, all HTTP/1.1 servers MUST accept the absoluteURI
   form in requests, even though HTTP/1.1 clients will only generate
   them in requests to proxies.

   The authority form is only used by the CONNECT method (&lt;a href=&quot;#section-9.9&quot;&gt;section 9.9&lt;/a&gt;).

   The most common form of Request-URI is that used to identify a
   resource on an origin server or gateway. In this case the absolute
   path of the URI MUST be transmitted (see &lt;a href=&quot;#section-3.2.1&quot;&gt;section 3.2.1&lt;/a&gt;, abs_path) as
   the Request-URI, and the network location of the URI (authority) MUST
   be transmitted in a Host header field. For example, a client wishing
   to retrieve the resource above directly from the origin server would
   create a TCP connection to port 80 of the host &quot;www.w3.org&quot; and send
   the lines:

       GET /pub/WWW/TheProject.html HTTP/1.1
       Host: www.w3.org

   followed by the remainder of the Request. Note that the absolute path
   cannot be empty; if none is present in the original URI, it MUST be
   given as &quot;/&quot; (the server root).

   The Request-URI is transmitted in the format specified in &lt;a href=&quot;#section-3.2.1&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-3.2.1&quot;&gt;3.2.1&lt;/a&gt;. If the Request-URI is encoded using the &quot;% HEX HEX&quot; encoding
   [&lt;a href=&quot;#ref-42&quot;&gt;42&lt;/a&gt;], the origin server MUST decode the Request-URI in order to
   properly interpret the request. Servers SHOULD respond to invalid
   Request-URIs with an appropriate status code.

   A transparent proxy MUST NOT rewrite the &quot;abs_path&quot; part of the
   received Request-URI when forwarding it to the next inbound server,
   except as noted above to replace a null abs_path with &quot;/&quot;.

      Note: The &quot;no rewrite&quot; rule prevents the proxy from changing the
      meaning of the request when the origin server is improperly using
      a non-reserved URI character for a reserved purpose.  Implementors
      should be aware that some pre-HTTP/1.1 proxies have been known to
      rewrite the Request-URI.</source>
          <target state="translated">Request-URI是统一资源标识符（&lt;a href=&quot;#section-3.2&quot;&gt;第3.2节&lt;/a&gt;），并标识在其上应用请求的资源。 Request-URI =&amp;ldquo; *&amp;rdquo; | absoluteURI | abs_path |权限Request-URI的四个选项取决于请求的性质。星号&amp;ldquo; *&amp;rdquo;表示该请求不适用于特定资源，而是适用于服务器本身，并且仅在所使用的方法不一定适用于资源时才被允许。一个示例是OPTIONS * HTTP / 1.1向代理发出请求时，需要absoluteURI形式。请求代理转发请求或从有效缓存中为其提供服务，并返回响应。注意，代理可以将请求转发到另一个代理，或者直接转发到由absoluteURI指定的服务器。为了避免请求循环，代理必须能够识别其所有服务器名称，包括任何别名，本地版本和数字IP地址。请求行示例为：GET&lt;a href=&quot;https://www.w3.org/pub/WWW/TheProject.html&quot;&gt;http://www.w3.org/pub/WWW/TheProject.html&lt;/a&gt; HTTP / 1.1为了在将来的HTTP版本中允许在所有请求中转换为absoluteURI，即使所有HTTP / 1.1服务器也必须在请求中接受absoluteURI形式，即使HTTP / 1.1客户端只会在对代理的请求中生成它们。授权表仅由CONNECT方法使用（&lt;a href=&quot;#section-9.9&quot;&gt;第9.9节&lt;/a&gt;）。 Request-URI的最常见形式是用于标识源服务器或网关上的资源的形式。在这种情况下，必须发送URI的绝对路径（请参阅&lt;a href=&quot;#section-3.2.1&quot;&gt;第3.2.1节）。&lt;/a&gt;（例如abs_path）作为请求URI，并且URI（授权）的网络位置必须在主机标头字段中传输。例如，希望直接从源服务器检索以上资源的客户端将创建到主机&amp;ldquo; www.w3.org&amp;rdquo;的端口80的TCP连接，并发送以下行：GET /pub/WWW/TheProject.html HTTP / 1.1主机：www.w3.org，后跟请求的其余部分。请注意，绝对路径不能为空；如果原始URI中没有任何内容，则必须将其指定为&amp;ldquo; /&amp;rdquo;（服务器根目录）。 Request-URI以&lt;a href=&quot;#section-3.2.1&quot;&gt;3.2.1&lt;/a&gt;&lt;a href=&quot;#section-3.2.1&quot;&gt;节中&lt;/a&gt;指定的格式发送。如果请求URI是使用&amp;ldquo;％HEX HEX&amp;rdquo;编码[ &lt;a href=&quot;#ref-42&quot;&gt;42&lt;/a&gt;]，原始服务器必须解码Request-URI，以正确解释请求。服务器应使用适当的状态码响应无效的Request-URI。当透明的代理转发到下一个入站服务器时，绝不能重写接收到的Request-URI的&amp;ldquo; abs_path&amp;rdquo;部分，除非如上所述，否则用&amp;ldquo; /&amp;rdquo;替换空的abs_path。注意：当原始服务器为保留的目的不正确地使用非保留的URI字符时，&amp;ldquo;不重写&amp;rdquo;规则可防止代理更改请求的含义。实现者应该意识到，已知一些HTTP / 1.1之前的代理可以重写Request-URI。</target>
        </trans-unit>
        <trans-unit id="27df10f6e52fad72f86af47082d4aed616c53e54" translate="yes" xml:space="preserve">
          <source>The Retry-After response-header field can be used with a 503 (Service
   Unavailable) response to indicate how long the service is expected to
   be unavailable to the requesting client. This field MAY also be used
   with any 3xx (Redirection) response to indicate the minimum time the
   user-agent is asked wait before issuing the redirected request. The
   value of this field can be either an HTTP-date or an integer number
   of seconds (in decimal) after the time of the response.

       Retry-After  = &quot;Retry-After&quot; &quot;:&quot; ( HTTP-date | delta-seconds )

   Two examples of its use are

       Retry-After: Fri, 31 Dec 1999 23:59:59 GMT
       Retry-After: 120

   In the latter example, the delay is 2 minutes.</source>
          <target state="translated">Retry-After 响应头字段可与 503(服务不可用)响应一起使用,以指示请求客户机预计将有多长时间的服务不可用。此字段也可与任何 3xx(重定向)响应一起使用,以指示用户代理在发出重定向请求之前被要求等待的最短时间。这个字段的值可以是HTTP-date,也可以是响应时间后的整数秒(十进制)。Retry-After=&quot;Retry-After&quot; &quot;:&quot;(HTTP-date | delta-seconds)其使用的两个例子是Retry-After。Fri,31 Dec 1999 23:59:59 GMT Retry-After:120 在后一个例子中,延迟是2分钟。</target>
        </trans-unit>
        <trans-unit id="818c17cd76fd87b90da17d6a18fd82be94517b9c" translate="yes" xml:space="preserve">
          <source>The SETTINGS frame (type=0x4) conveys configuration parameters that
   affect how endpoints communicate, such as preferences and constraints
   on peer behavior.  The SETTINGS frame is also used to acknowledge the
   receipt of those parameters.  Individually, a SETTINGS parameter can
   also be referred to as a &quot;setting&quot;. 

   SETTINGS parameters are not negotiated; they describe characteristics
   of the sending peer, which are used by the receiving peer.  Different
   values for the same parameter can be advertised by each peer.  For
   example, a client might set a high initial flow-control window,
   whereas a server might set a lower value to conserve resources.

   A SETTINGS frame MUST be sent by both endpoints at the start of a
   connection and MAY be sent at any other time by either endpoint over
   the lifetime of the connection.  Implementations MUST support all of
   the parameters defined by this specification.

   Each parameter in a SETTINGS frame replaces any existing value for
   that parameter.  Parameters are processed in the order in which they
   appear, and a receiver of a SETTINGS frame does not need to maintain
   any state other than the current value of its parameters.  Therefore,
   the value of a SETTINGS parameter is the last value that is seen by a
   receiver.

   SETTINGS parameters are acknowledged by the receiving peer.  To
   enable this, the SETTINGS frame defines the following flag:

   ACK (0x1):  When set, bit 0 indicates that this frame acknowledges
      receipt and application of the peer's SETTINGS frame.  When this
      bit is set, the payload of the SETTINGS frame MUST be empty.
      Receipt of a SETTINGS frame with the ACK flag set and a length
      field value other than 0 MUST be treated as a connection error
      (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type FRAME_SIZE_ERROR.  For more information,
      see &lt;a href=&quot;#section-6.5.3&quot;&gt;Section 6.5.3&lt;/a&gt; (&quot;Settings Synchronization&quot;).

   SETTINGS frames always apply to a connection, never a single stream.
   The stream identifier for a SETTINGS frame MUST be zero (0x0).  If an
   endpoint receives a SETTINGS frame whose stream identifier field is
   anything other than 0x0, the endpoint MUST respond with a connection
   error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type PROTOCOL_ERROR.

   The SETTINGS frame affects connection state.  A badly formed or
   incomplete SETTINGS frame MUST be treated as a connection error
   (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type PROTOCOL_ERROR.

   A SETTINGS frame with a length other than a multiple of 6 octets MUST
   be treated as a connection error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type
   FRAME_SIZE_ERROR.</source>
          <target state="translated">SETTINGS帧（类型= 0x4）传达影响端点通信方式的配置参数，例如，对等方行为的首选项和约束。 SETTINGS框架也用于确认那些参数的接收。单独地，SETTINGS参数也可以称为&amp;ldquo;设置&amp;rdquo;。未协商SETTINGS参数；它们描述了发送对等方的特性，接收方使用这些特性。每个对等体可以通告相同参数的不同值。例如，客户端可能会设置较高的初始流控制窗口，而服务器可能会设置较低的值以节省资源。 SETTINGS帧必须在连接开始时由两个端点发送，并且在连接的生存期内必须由任一端点在任何其他时间发送。实现必须支持本规范定义的所有参数。 SETTINGS框架中的每个参数都会替换该参数的任何现有值。参数按照它们出现的顺序进行处理，并且SETTINGS帧的接收者不需要维护其参数当前值以外的任何状态。因此，SETTINGS参数的值是接收机看到的最后一个值。 SETTINGS参数由接收对等方确认。为此，SETTINGS帧定义了以下标志：ACK（0x1）：设置后，位0指示该帧确认对等方SETTINGS帧的接收和应用。当该位置1时，&amp;ldquo;设置&amp;rdquo;帧的有效载荷必须为空。接收到设置了ACK标志且长度字段值不为0的SETTINGS帧时，必须将其视为连接错误（&lt;a href=&quot;#section-5.4.1&quot;&gt;&lt;/a&gt;FRAME_SIZE_ERROR类型的第5.4.1节）。有关更多信息，请参见&lt;a href=&quot;#section-6.5.3&quot;&gt;第6.5.3节&lt;/a&gt;（&amp;ldquo;设置同步&amp;rdquo;）。SETTINGS帧始终应用于连接，而不是单个流。SETTINGS帧的流标识符必须为零（0x0）。如果端点接收到流标识符字段不是0x0的SETTINGS帧，则端点必须以PROTOCOL_ERROR类型的连接错误（&lt;a href=&quot;#section-5.4.1&quot;&gt;第5.4.1节&lt;/a&gt;）进行响应。SETTINGS框架会影响连接状态。格式错误或不完整的SETTINGS框架必须视为PROTOCOL_ERROR类型的连接错误（&lt;a href=&quot;#section-5.4.1&quot;&gt;第5.4.1节&lt;/a&gt;）。长度非6个八位字节倍数的SETTINGS帧必须视为连接错误（&lt;a href=&quot;#section-5.4.1&quot;&gt;第5.4.1节）&lt;/a&gt;），类型为FRAME_SIZE_ERROR。</target>
        </trans-unit>
        <trans-unit id="9f8174334dfb42409bd14d344357a61e0522761d" translate="yes" xml:space="preserve">
          <source>The Sec-Fetch-Dest HTTP Request Header</source>
          <target state="translated">Sec-Fetch-Dest HTTP请求头。</target>
        </trans-unit>
        <trans-unit id="089fba56f3ba935817b0ee0ba0d50c6c7250a452" translate="yes" xml:space="preserve">
          <source>The Sec-Fetch-Mode HTTP Request Header</source>
          <target state="translated">Sec-Fetch模式的HTTP请求头。</target>
        </trans-unit>
        <trans-unit id="0922dedc70e7039f73de5afb1791c6af1cadc728" translate="yes" xml:space="preserve">
          <source>The Sec-Fetch-Site HTTP Request Header</source>
          <target state="translated">Sec-Fetch-Site的HTTP请求头。</target>
        </trans-unit>
        <trans-unit id="8e9ebb888b481c6982054f06f45605ddc268b5db" translate="yes" xml:space="preserve">
          <source>The Sec-Fetch-User HTTP Request Header</source>
          <target state="translated">Sec-Fetch-User HTTP请求头。</target>
        </trans-unit>
        <trans-unit id="f351e70802256078de6c82adb6c9f8135e4ad1a4" translate="yes" xml:space="preserve">
          <source>The Server response-header field contains information about the
   software used by the origin server to handle the request. The field
   can contain multiple product tokens (&lt;a href=&quot;#section-3.8&quot;&gt;section 3.8&lt;/a&gt;) and comments
   identifying the server and any significant subproducts. The product
   tokens are listed in order of their significance for identifying the
   application.

       Server         = &quot;Server&quot; &quot;:&quot; 1*( product | comment )

   Example:

       Server: CERN/3.0 libwww/2.17

   If the response is being forwarded through a proxy, the proxy
   application MUST NOT modify the Server response-header. Instead, it
   SHOULD include a Via field (as described in &lt;a href=&quot;#section-14.45&quot;&gt;section 14.45&lt;/a&gt;).

      Note: Revealing the specific software version of the server might
      allow the server machine to become more vulnerable to attacks
      against software that is known to contain security holes. Server
      implementors are encouraged to make this field a configurable
      option.</source>
          <target state="translated">服务器响应标头字段包含有关原始服务器用来处理请求的软件的信息。该字段可以包含多个产品令牌（&lt;a href=&quot;#section-3.8&quot;&gt;第3.8节&lt;/a&gt;）和标识服务器以及任何重要子产品的注释。产品令牌按其对识别应用程序的重要性顺序列出。服务器=&amp;ldquo;服务器&amp;rdquo;&amp;ldquo;：&amp;rdquo; 1 *（产品|注释）示例：服务器：CERN / 3.0 libwww / 2.17如果响应是通过代理转发的，则代理应用程序一定不能修改服务器响应头。相反，它应该包含Via字段（如&lt;a href=&quot;#section-14.45&quot;&gt;第14.45节中&lt;/a&gt;所述））。注意：显示服务器的特定软件版本可能使服务器计算机更容易受到针对已知包含安全漏洞的软件的攻击。鼓励服务器实现者将此字段设置为可配置选项。</target>
        </trans-unit>
        <trans-unit id="87ed514ae2ccfa3b72514fa6a84c466f301be7c1" translate="yes" xml:space="preserve">
          <source>The Status-Code element is a 3-digit integer result code of the
   attempt to understand and satisfy the request. These codes are fully
   defined in &lt;a href=&quot;#section-10&quot;&gt;section 10&lt;/a&gt;. The Reason-Phrase is intended to give a short
   textual description of the Status-Code. The Status-Code is intended
   for use by automata and the Reason-Phrase is intended for the human
   user. The client is not required to examine or display the Reason-
   Phrase. 

   The first digit of the Status-Code defines the class of response. The
   last two digits do not have any categorization role. There are 5
   values for the first digit:

      - 1xx: Informational - Request received, continuing process

      - 2xx: Success - The action was successfully received,
        understood, and accepted

      - 3xx: Redirection - Further action must be taken in order to
        complete the request

      - 4xx: Client Error - The request contains bad syntax or cannot
        be fulfilled

      - 5xx: Server Error - The server failed to fulfill an apparently
        valid request

   The individual values of the numeric status codes defined for
   HTTP/1.1, and an example set of corresponding Reason-Phrase's, are
   presented below. The reason phrases listed here are only
   recommendations -- they MAY be replaced by local equivalents without
   affecting the protocol.

      Status-Code    =
            &quot;100&quot;  ; &lt;a href=&quot;#section-10.1.1&quot;&gt;Section 10.1.1&lt;/a&gt;: Continue
          | &quot;101&quot;  ; &lt;a href=&quot;#section-10.1.2&quot;&gt;Section 10.1.2&lt;/a&gt;: Switching Protocols
          | &quot;200&quot;  ; &lt;a href=&quot;#section-10.2.1&quot;&gt;Section 10.2.1&lt;/a&gt;: OK
          | &quot;201&quot;  ; &lt;a href=&quot;#section-10.2.2&quot;&gt;Section 10.2.2&lt;/a&gt;: Created
          | &quot;202&quot;  ; &lt;a href=&quot;#section-10.2.3&quot;&gt;Section 10.2.3&lt;/a&gt;: Accepted
          | &quot;203&quot;  ; &lt;a href=&quot;#section-10.2.4&quot;&gt;Section 10.2.4&lt;/a&gt;: Non-Authoritative Information
          | &quot;204&quot;  ; &lt;a href=&quot;#section-10.2.5&quot;&gt;Section 10.2.5&lt;/a&gt;: No Content
          | &quot;205&quot;  ; &lt;a href=&quot;#section-10.2.6&quot;&gt;Section 10.2.6&lt;/a&gt;: Reset Content
          | &quot;206&quot;  ; &lt;a href=&quot;#section-10.2.7&quot;&gt;Section 10.2.7&lt;/a&gt;: Partial Content
          | &quot;300&quot;  ; &lt;a href=&quot;#section-10.3.1&quot;&gt;Section 10.3.1&lt;/a&gt;: Multiple Choices
          | &quot;301&quot;  ; &lt;a href=&quot;#section-10.3.2&quot;&gt;Section 10.3.2&lt;/a&gt;: Moved Permanently
          | &quot;302&quot;  ; &lt;a href=&quot;#section-10.3.3&quot;&gt;Section 10.3.3&lt;/a&gt;: Found
          | &quot;303&quot;  ; &lt;a href=&quot;#section-10.3.4&quot;&gt;Section 10.3.4&lt;/a&gt;: See Other
          | &quot;304&quot;  ; &lt;a href=&quot;#section-10.3.5&quot;&gt;Section 10.3.5&lt;/a&gt;: Not Modified
          | &quot;305&quot;  ; &lt;a href=&quot;#section-10.3.6&quot;&gt;Section 10.3.6&lt;/a&gt;: Use Proxy
          | &quot;307&quot;  ; &lt;a href=&quot;#section-10.3.8&quot;&gt;Section 10.3.8&lt;/a&gt;: Temporary Redirect
          | &quot;400&quot;  ; &lt;a href=&quot;#section-10.4.1&quot;&gt;Section 10.4.1&lt;/a&gt;: Bad Request
          | &quot;401&quot;  ; &lt;a href=&quot;#section-10.4.2&quot;&gt;Section 10.4.2&lt;/a&gt;: Unauthorized
          | &quot;402&quot;  ; &lt;a href=&quot;#section-10.4.3&quot;&gt;Section 10.4.3&lt;/a&gt;: Payment Required
          | &quot;403&quot;  ; &lt;a href=&quot;#section-10.4.4&quot;&gt;Section 10.4.4&lt;/a&gt;: Forbidden
          | &quot;404&quot;  ; &lt;a href=&quot;#section-10.4.5&quot;&gt;Section 10.4.5&lt;/a&gt;: Not Found
          | &quot;405&quot;  ; &lt;a href=&quot;#section-10.4.6&quot;&gt;Section 10.4.6&lt;/a&gt;: Method Not Allowed
          | &quot;406&quot;  ; &lt;a href=&quot;#section-10.4.7&quot;&gt;Section 10.4.7&lt;/a&gt;: Not Acceptable 

          | &quot;407&quot;  ; &lt;a href=&quot;#section-10.4.8&quot;&gt;Section 10.4.8&lt;/a&gt;: Proxy Authentication Required
          | &quot;408&quot;  ; &lt;a href=&quot;#section-10.4.9&quot;&gt;Section 10.4.9&lt;/a&gt;: Request Time-out
          | &quot;409&quot;  ; &lt;a href=&quot;#section-10.4.10&quot;&gt;Section 10.4.10&lt;/a&gt;: Conflict
          | &quot;410&quot;  ; &lt;a href=&quot;#section-10.4.11&quot;&gt;Section 10.4.11&lt;/a&gt;: Gone
          | &quot;411&quot;  ; &lt;a href=&quot;#section-10.4.12&quot;&gt;Section 10.4.12&lt;/a&gt;: Length Required
          | &quot;412&quot;  ; &lt;a href=&quot;#section-10.4.13&quot;&gt;Section 10.4.13&lt;/a&gt;: Precondition Failed
          | &quot;413&quot;  ; &lt;a href=&quot;#section-10.4.14&quot;&gt;Section 10.4.14&lt;/a&gt;: Request Entity Too Large
          | &quot;414&quot;  ; &lt;a href=&quot;#section-10.4.15&quot;&gt;Section 10.4.15&lt;/a&gt;: Request-URI Too Large
          | &quot;415&quot;  ; &lt;a href=&quot;#section-10.4.16&quot;&gt;Section 10.4.16&lt;/a&gt;: Unsupported Media Type
          | &quot;416&quot;  ; &lt;a href=&quot;#section-10.4.17&quot;&gt;Section 10.4.17&lt;/a&gt;: Requested range not satisfiable
          | &quot;417&quot;  ; &lt;a href=&quot;#section-10.4.18&quot;&gt;Section 10.4.18&lt;/a&gt;: Expectation Failed
          | &quot;500&quot;  ; &lt;a href=&quot;#section-10.5.1&quot;&gt;Section 10.5.1&lt;/a&gt;: Internal Server Error
          | &quot;501&quot;  ; &lt;a href=&quot;#section-10.5.2&quot;&gt;Section 10.5.2&lt;/a&gt;: Not Implemented
          | &quot;502&quot;  ; &lt;a href=&quot;#section-10.5.3&quot;&gt;Section 10.5.3&lt;/a&gt;: Bad Gateway
          | &quot;503&quot;  ; &lt;a href=&quot;#section-10.5.4&quot;&gt;Section 10.5.4&lt;/a&gt;: Service Unavailable
          | &quot;504&quot;  ; &lt;a href=&quot;#section-10.5.5&quot;&gt;Section 10.5.5&lt;/a&gt;: Gateway Time-out
          | &quot;505&quot;  ; &lt;a href=&quot;#section-10.5.6&quot;&gt;Section 10.5.6&lt;/a&gt;: HTTP Version not supported
          | extension-code

      extension-code = 3DIGIT
      Reason-Phrase  = *&amp;lt;TEXT, excluding CR, LF&amp;gt;

   HTTP status codes are extensible. HTTP applications are not required
   to understand the meaning of all registered status codes, though such
   understanding is obviously desirable. However, applications MUST
   understand the class of any status code, as indicated by the first
   digit, and treat any unrecognized response as being equivalent to the
   x00 status code of that class, with the exception that an
   unrecognized response MUST NOT be cached. For example, if an
   unrecognized status code of 431 is received by the client, it can
   safely assume that there was something wrong with its request and
   treat the response as if it had received a 400 status code. In such
   cases, user agents SHOULD present to the user the entity returned
   with the response, since that entity is likely to include human-
   readable information which will explain the unusual status.</source>
          <target state="translated">Status-Code元素是3位数的整数结果代码，用于尝试理解和满足请求。这些代码已在&lt;a href=&quot;#section-10&quot;&gt;第10节&lt;/a&gt;中完全定义。原因短语旨在简要说明状态代码。状态代码供自动机使用，原因短语供人类用户使用。不需要客户检查或显示原因短语。状态码的第一位数字定义响应的类别。后两位数字没有任何分类作用。第一位数字有5个值：-1xx：信息性-已接收到请求，继续处理-2xx：成功-已成功接收，理解并接受了该操作-3xx：重定向-必须采取进一步的操作才能完成请求-4xx：客户端错误-请求包含错误的语法或无法实现-5xx：服务器错误-服务器无法满足看似有效的请求。下面显示了为HTTP / 1.1定义的数字状态代码的各个值以及一组相应的原因短语示例。此处列出的原因短语仅是建议-在不影响协议的情况下，它们可以被本地等效项替换。状态码=&amp;ldquo; 100&amp;rdquo;；&lt;a href=&quot;#section-10.1.1&quot;&gt;10.1.1节&lt;/a&gt;：继续| &amp;ldquo; 101&amp;rdquo;；&lt;a href=&quot;#section-10.1.2&quot;&gt;第10.1.2节&lt;/a&gt;：交换协议| &amp;ldquo; 200&amp;rdquo;；&lt;a href=&quot;#section-10.2.1&quot;&gt;10.2.1节&lt;/a&gt;：确定| &amp;ldquo; 201&amp;rdquo;；&lt;a href=&quot;#section-10.2.2&quot;&gt;第10.2.2节&lt;/a&gt;：创建| &amp;ldquo; 202&amp;rdquo;；&lt;a href=&quot;#section-10.2.3&quot;&gt;第10.2.3节&lt;/a&gt;：已接受| &amp;ldquo; 203&amp;rdquo;；&lt;a href=&quot;#section-10.2.4&quot;&gt;第10.2.4节&lt;/a&gt;：非权威信息| &amp;ldquo; 204&amp;rdquo;; &lt;a href=&quot;#section-10.2.5&quot;&gt;10.2.5节&lt;/a&gt;：无内容| &amp;ldquo; 205&amp;rdquo;；&lt;a href=&quot;#section-10.2.6&quot;&gt;第10.2.6节&lt;/a&gt;：重置内容| &amp;ldquo; 206&amp;rdquo;；&lt;a href=&quot;#section-10.2.7&quot;&gt;第10.2.7节&lt;/a&gt;：部分内容| &amp;ldquo; 300&amp;rdquo;；&lt;a href=&quot;#section-10.3.1&quot;&gt;10.3.1节&lt;/a&gt;：多项选择&amp;ldquo; 301&amp;rdquo;；&lt;a href=&quot;#section-10.3.2&quot;&gt;10.3节&lt;/a&gt;2 ：永久移动| &amp;ldquo; 302&amp;rdquo;；&lt;a href=&quot;#section-10.3.3&quot;&gt;第10.3.3节&lt;/a&gt;：找到| &amp;ldquo; 303&amp;rdquo;；&lt;a href=&quot;#section-10.3.4&quot;&gt;第10.3.4节&lt;/a&gt;：查看其他| &amp;ldquo; 304&amp;rdquo;; &lt;a href=&quot;#section-10.3.5&quot;&gt;第10.3.5节&lt;/a&gt;：未修改| &amp;ldquo; 305&amp;rdquo;；&lt;a href=&quot;#section-10.3.6&quot;&gt;第10.3.6节&lt;/a&gt;：使用代理| &amp;ldquo; 307&amp;rdquo;；&lt;a href=&quot;#section-10.3.8&quot;&gt;第10.3.8节&lt;/a&gt;：临时重定向| &amp;ldquo; 400&amp;rdquo;；&lt;a href=&quot;#section-10.4.1&quot;&gt;10.4.1节&lt;/a&gt;：错误的请求| &amp;ldquo; 401&amp;rdquo;；&lt;a href=&quot;#section-10.4.2&quot;&gt;第10.4.2节&lt;/a&gt;：未经授权| &amp;ldquo; 402&amp;rdquo;；&lt;a href=&quot;#section-10.4.3&quot;&gt;第10.4.3节&lt;/a&gt;：需要付款| &amp;ldquo; 403&amp;rdquo;；&lt;a href=&quot;#section-10.4.4&quot;&gt;第10.4.4节&lt;/a&gt;：禁止| &amp;ldquo; 404&amp;rdquo;；&lt;a href=&quot;#section-10.4.5&quot;&gt;第10.4.5节&lt;/a&gt;：找不到| &amp;ldquo; 405&amp;rdquo;；&lt;a href=&quot;#section-10.4.6&quot;&gt;第10.4.6节&lt;/a&gt;：不允许的方法&amp;ldquo; 406&amp;rdquo;； &lt;a href=&quot;#section-10.4.7&quot;&gt;第10.4.7节&lt;/a&gt;：不可接受| &amp;ldquo; 407&amp;rdquo;；&lt;a href=&quot;#section-10.4.8&quot;&gt;第10.4.8节&lt;/a&gt;：需要代理身份验证| &amp;ldquo; 408&amp;rdquo;；&lt;a href=&quot;#section-10.4.9&quot;&gt;10.4.9节&lt;/a&gt;：请求超时| &amp;ldquo; 409&amp;rdquo;；&lt;a href=&quot;#section-10.4.10&quot;&gt;第10.4.10节&lt;/a&gt;：冲突| &amp;ldquo; 410&amp;rdquo;；&lt;a href=&quot;#section-10.4.11&quot;&gt;第10.4.11节&lt;/a&gt;：消失| &amp;ldquo; 411&amp;rdquo;；&lt;a href=&quot;#section-10.4.12&quot;&gt;10.4.12节&lt;/a&gt;：所需长度| &amp;ldquo; 412&amp;rdquo;；&lt;a href=&quot;#section-10.4.13&quot;&gt;10.4.13节&lt;/a&gt;：前提条件失败| &amp;ldquo; 413&amp;rdquo;；&lt;a href=&quot;#section-10.4.14&quot;&gt;10.4.14节&lt;/a&gt;：请求实体太大| &amp;ldquo; 414&amp;rdquo;；&lt;a href=&quot;#section-10.4.15&quot;&gt;10.4.15节&lt;/a&gt;：请求URI太大| &amp;ldquo; 415&amp;rdquo;；&lt;a href=&quot;#section-10.4.16&quot;&gt;第10.4.16节&lt;/a&gt;：不支持的媒体类型| &amp;ldquo; 416&amp;rdquo;；&lt;a href=&quot;#section-10.4.17&quot;&gt;第10.4.17节&lt;/a&gt;：无法满足要求的范围| &amp;ldquo; 417&amp;rdquo;；&lt;a href=&quot;#section-10.4.18&quot;&gt;10.4.18节&lt;/a&gt;：期望失败| &amp;ldquo; 500&amp;rdquo;；&lt;a href=&quot;#section-10.5.1&quot;&gt;10.5.1节&lt;/a&gt;：内部服务器错误| &amp;ldquo; 501&amp;rdquo;；&lt;a href=&quot;#section-10.5.2&quot;&gt;第10.5.2节&lt;/a&gt;：未实施| &amp;ldquo; 502&amp;rdquo;；&lt;a href=&quot;#section-10.5.3&quot;&gt;第10.5.3节&lt;/a&gt;：错误的网关| &amp;ldquo; 503&amp;rdquo;；&lt;a href=&quot;#section-10.5.4&quot;&gt;第10.5.4节&lt;/a&gt;：服务不可用| &amp;ldquo; 504&amp;rdquo;；&lt;a href=&quot;#section-10.5.5&quot;&gt;第10.5.5节&lt;/a&gt;：网关超时| &amp;ldquo; 505&amp;rdquo;；&lt;a href=&quot;#section-10.5.6&quot;&gt;第10.5.6节&lt;/a&gt;：不支持HTTP版本| extension-code extension-code = 3DIGIT原因短语= * &amp;lt;TEXT，不包括CR，LF&amp;gt; HTTP状态代码是可扩展的。不需要HTTP应用程序理解所有已注册状态代码的含义，尽管显然希望这样。但是，应用程序务必如第一位数字所示理解任何状态码的类别，并将任何无法识别的响应视为等同于该类的x00状态码，但不可识别的响应必须被缓存。例如，如果客户端接收到无法识别的状态码431，则它可以安全地假定其请求有问题，并将响应视为已接收到400状态码。在这种情况下用户代理应该向用户呈现随响应一起返回的实体，因为该实体可能会包含人类可读的信息，这些信息将解释异常状态。</target>
        </trans-unit>
        <trans-unit id="b8418e17a41aec97d3c590fcc65fedf33be9a1c2" translate="yes" xml:space="preserve">
          <source>The TCP connection failed due to reasons not covered by previous errors</source>
          <target state="translated">由于之前的错误没有涉及的原因,TCP连接失败。</target>
        </trans-unit>
        <trans-unit id="a63d3da83f08f3589783fd322c14eb384668776f" translate="yes" xml:space="preserve">
          <source>The TCP connection was aborted</source>
          <target state="translated">TCP连接被中止</target>
        </trans-unit>
        <trans-unit id="ece1a07cee60e2c0d379acd1235868c7480c2fcb" translate="yes" xml:space="preserve">
          <source>The TCP connection was closed by the server</source>
          <target state="translated">TCP连接被服务器关闭</target>
        </trans-unit>
        <trans-unit id="796733a0ab45ac90906d6f198849475b13814e44" translate="yes" xml:space="preserve">
          <source>The TCP connection was refused by the server</source>
          <target state="translated">TCP连接被服务器拒绝</target>
        </trans-unit>
        <trans-unit id="44cef75a8f9ea523ffedd880063709751f6702f3" translate="yes" xml:space="preserve">
          <source>The TCP connection was reset</source>
          <target state="translated">TCP连接被重置</target>
        </trans-unit>
        <trans-unit id="a033c5a9ee721261b9ef910b0f68478ac7363993" translate="yes" xml:space="preserve">
          <source>The TCP handshake itself is time-consuming, but a TCP connection adapts to its load, becoming more efficient with more sustained (or warm) connections. Short-lived connections do not make use of this efficiency feature of TCP, and performance degrades from optimum by persisting to transmit over a new, cold connection.</source>
          <target state="translated">TCP握手本身是很耗时的,但TCP连接会适应它的负载,通过更多的持续(或热)连接变得更有效率。短暂的连接并没有利用TCP的这种效率特征,通过持续在新的冷连接上传输,性能会从最佳状态下降。</target>
        </trans-unit>
        <trans-unit id="a9a108e88ad08677b3a7b101ee6720f85b6d8f49" translate="yes" xml:space="preserve">
          <source>The TE request-header field indicates what extension transfer-codings
   it is willing to accept in the response and whether or not it is
   willing to accept trailer fields in a chunked transfer-coding. Its
   value may consist of the keyword &quot;trailers&quot; and/or a comma-separated
   list of extension transfer-coding names with optional accept
   parameters (as described in &lt;a href=&quot;#section-3.6&quot;&gt;section 3.6&lt;/a&gt;).

       TE        = &quot;TE&quot; &quot;:&quot; #( t-codings )
       t-codings = &quot;trailers&quot; | ( transfer-extension [ accept-params ] )

   The presence of the keyword &quot;trailers&quot; indicates that the client is
   willing to accept trailer fields in a chunked transfer-coding, as
   defined in &lt;a href=&quot;#section-3.6.1&quot;&gt;section 3.6.1&lt;/a&gt;. This keyword is reserved for use with
   transfer-coding values even though it does not itself represent a
   transfer-coding.

   Examples of its use are:

       TE: deflate
       TE:
       TE: trailers, deflate;q=0.5

   The TE header field only applies to the immediate connection.
   Therefore, the keyword MUST be supplied within a Connection header
   field (&lt;a href=&quot;#section-14.10&quot;&gt;section 14.10&lt;/a&gt;) whenever TE is present in an HTTP/1.1 message.

   A server tests whether a transfer-coding is acceptable, according to
   a TE field, using these rules:

      1. The &quot;chunked&quot; transfer-coding is always acceptable. If the
         keyword &quot;trailers&quot; is listed, the client indicates that it is
         willing to accept trailer fields in the chunked response on
         behalf of itself and any downstream clients. The implication is
         that, if given, the client is stating that either all
         downstream clients are willing to accept trailer fields in the
         forwarded response, or that it will attempt to buffer the
         response on behalf of downstream recipients.

         Note: HTTP/1.1 does not define any means to limit the size of a
         chunked response such that a client can be assured of buffering
         the entire response.

      2. If the transfer-coding being tested is one of the transfer-
         codings listed in the TE field, then it is acceptable unless it
         is accompanied by a qvalue of 0. (As defined in &lt;a href=&quot;#section-3.9&quot;&gt;section 3.9&lt;/a&gt;, a
         qvalue of 0 means &quot;not acceptable.&quot;) 

      3. If multiple transfer-codings are acceptable, then the
         acceptable transfer-coding with the highest non-zero qvalue is
         preferred.  The &quot;chunked&quot; transfer-coding always has a qvalue
         of 1.

   If the TE field-value is empty or if no TE field is present, the only
   transfer-coding  is &quot;chunked&quot;. A message with no transfer-coding is
   always acceptable.</source>
          <target state="translated">TE request-header字段指示它愿意在响应中接受哪些扩展传输编码，以及是否愿意以分块传输编码的形式接受尾部字段。它的值可以包含关键字&amp;ldquo; trailers&amp;rdquo;和/或带有可选接受参数的扩展名传输编码名称的逗号分隔列表（如&lt;a href=&quot;#section-3.6&quot;&gt;第3.6节中&lt;/a&gt;所述）。 TE =&amp;ldquo; TE&amp;rdquo;&amp;ldquo;：&amp;rdquo;＃（t-codings）t-codings =&amp;ldquo; trailers&amp;rdquo; | （transfer-extension [accept-params]）关键字&amp;ldquo; trailers&amp;rdquo;的存在指示客户端愿意接受分块传输编码中的尾部字段，如&lt;a href=&quot;#section-3.6.1&quot;&gt;3.6.1节中&lt;/a&gt;所定义。。即使此关键字本身并不表示传输编码，也保留将其与传输编码值一起使用。其用法示例如下：TE：deflate TE：TE：尾随，deflate; q = 0.5 TE头字段仅适用于直接连接。因此，必须在Connection标头字段中提供关键字（&lt;a href=&quot;#section-14.10&quot;&gt;第14.10节&lt;/a&gt;），只要HTTP / 1.1消息中包含TE。服务器使用以下规则根据TE字段测试传输编码是否可接受：1.&amp;ldquo;分块&amp;rdquo;传输编码始终是可接受的。如果列出了关键字&amp;ldquo; trailers&amp;rdquo;，则客户端表明它愿意代表自己和任何下游客户端在分块响应中接受尾部字段。暗示是，如果给出的话，客户端将说明所有下游客户端都愿意在转发的响应中接受尾部字段，或者它将尝试代表下游接收方缓冲响应。注意：HTTP / 1。图1中没有定义任何方法来限制分块响应的大小，从而可以确保客户端缓冲整个响应。 2.如果要测试的传输编码是TE字段中列出的传输编码之一，则可以接受，除非它带有q值0。&lt;a href=&quot;#section-3.9&quot;&gt;在第3.9节中&lt;/a&gt;，q值为0表示&amp;ldquo;不可接受&amp;rdquo;。）3.如果可以接受多个传输编码，则首选具有最高非零q值的可接受传输编码。 &amp;ldquo;块式&amp;rdquo;传输编码始终具有1的q值。如果TE字段值为空或不存在TE字段，则唯一的传输编码为&amp;ldquo;块式&amp;rdquo;。没有传输编码的消息总是可以接受的。</target>
        </trans-unit>
        <trans-unit id="028b36d5d9b3506526bee546184ec9c68b1e3650" translate="yes" xml:space="preserve">
          <source>The TRACE method is used to invoke a remote, application-layer loop-
   back of the request message. The final recipient of the request
   SHOULD reflect the message received back to the client as the
   entity-body of a 200 (OK) response. The final recipient is either the 

   origin server or the first proxy or gateway to receive a Max-Forwards
   value of zero (0) in the request (see &lt;a href=&quot;#section-14.31&quot;&gt;section 14.31&lt;/a&gt;). A TRACE request
   MUST NOT include an entity.

   TRACE allows the client to see what is being received at the other
   end of the request chain and use that data for testing or diagnostic
   information. The value of the Via header field (&lt;a href=&quot;#section-14.45&quot;&gt;section 14.45&lt;/a&gt;) is of
   particular interest, since it acts as a trace of the request chain.
   Use of the Max-Forwards header field allows the client to limit the
   length of the request chain, which is useful for testing a chain of
   proxies forwarding messages in an infinite loop.

   If the request is valid, the response SHOULD contain the entire
   request message in the entity-body, with a Content-Type of
   &quot;message/http&quot;. Responses to this method MUST NOT be cached.</source>
          <target state="translated">TRACE方法用于调用请求消息的远程应用程序层回送。请求的最终接收者应该将收到的消息作为200（OK）响应的实体主体反映回客户端。最终的接收者是原始服务器或第一个代理或网关，以在请求中接收零（0）的最大转发值（请参阅&lt;a href=&quot;#section-14.31&quot;&gt;14.31节&lt;/a&gt;）。 TRACE请求不得包含实体。 TRACE允许客户端查看请求链另一端收到的内容，并将该数据用于测试或诊断信息。 Via标头字段的值（&lt;a href=&quot;#section-14.45&quot;&gt;第14.45节&lt;/a&gt;）特别有趣，因为它充当了请求链的痕迹。使用Max-Forwards标头字段允许客户端限制请求链的长度，这对于测试无限循环中转发消息的代理链很有用。如果请求有效，则响应应在实体正文中包含整个请求消息，其Content-Type为&amp;ldquo; message / http&amp;rdquo;。对此方法的响应绝不能被缓存。</target>
        </trans-unit>
        <trans-unit id="6e96e28d353c4ec4abe9e9bc4e5f7f7754ad5448" translate="yes" xml:space="preserve">
          <source>The TRACE method requests a remote, application-level loop-back of
   the request message.  The final recipient of the request SHOULD
   reflect the message received, excluding some fields described below,
   back to the client as the message body of a 200 (OK) response with a
   Content-Type of &quot;message/http&quot; (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-8.3.1&quot;&gt;Section&amp;nbsp;8.3.1 of [RFC7230]&lt;/a&gt;).  The
   final recipient is either the origin server or the first server to
   receive a Max-Forwards value of zero (0) in the request
   (&lt;a href=&quot;#section-5.1.2&quot;&gt;Section 5.1.2&lt;/a&gt;). 

   A client MUST NOT generate header fields in a TRACE request
   containing sensitive data that might be disclosed by the response.
   For example, it would be foolish for a user agent to send stored user
   credentials [&lt;a href=&quot;https://tools.ietf.org/html/rfc7235&quot;&gt;RFC7235&lt;/a&gt;] or cookies [&lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC6265&lt;/a&gt;] in a TRACE request.  The
   final recipient of the request SHOULD exclude any request header
   fields that are likely to contain sensitive data when that recipient
   generates the response body.

   TRACE allows the client to see what is being received at the other
   end of the request chain and use that data for testing or diagnostic
   information.  The value of the Via header field (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.7.1&quot;&gt;Section&amp;nbsp;5.7.1 of
   [RFC7230]&lt;/a&gt;) is of particular interest, since it acts as a trace of the
   request chain.  Use of the Max-Forwards header field allows the
   client to limit the length of the request chain, which is useful for
   testing a chain of proxies forwarding messages in an infinite loop.

   A client MUST NOT send a message body in a TRACE request.

   Responses to the TRACE method are not cacheable.</source>
          <target state="translated">TRACE方法请求对请求消息进行远程的应用程序级回送。请求的最终接收者应该将收到的消息（不包括下面描述的某些字段）反映回客户端，作为内容类型为&amp;ldquo; message / http&amp;rdquo;的200（OK）响应的消息主体（&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-8.3.1&quot;&gt;第8.3.1节） [RFC7230]&lt;/a&gt;）。最终的接收者是原始服务器，或者是第一个在请求中接收最大转发值为零（0）的服务器（&lt;a href=&quot;#section-5.1.2&quot;&gt;第5.1.2节&lt;/a&gt;）。客户端不得在TRACE请求中生成标头字段，该标头字段包含响应可能会泄露的敏感数据。例如，用户代理发送存储的用户凭证[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7235&quot;&gt;RFC7235&lt;/a&gt; ]或cookie [ &lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC6265&lt;/a&gt; ] 是愚蠢的]在TRACE请求中。请求的最终接收者应排除该接收者生成响应正文时可能包含敏感数据的任何请求标头字段。 TRACE允许客户端查看请求链另一端收到的内容，并将该数据用于测试或诊断信息。 Via标头字段的值（&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.7.1&quot;&gt;[RFC7230]的5.7.1节&lt;/a&gt;）特别受关注，因为它充当请求链的跟踪。使用Max-Forwards标头字段允许客户端限制请求链的长度，这对于测试无限循环中转发消息的代理链很有用。客户端不得在TRACE请求中发送消息正文。对TRACE方法的响应不可缓存。</target>
        </trans-unit>
        <trans-unit id="03897f64a14a74fe7d2358b82a3a5d08dc5e4c2f" translate="yes" xml:space="preserve">
          <source>The Trailer general field value indicates that the given set of
   header fields is present in the trailer of a message encoded with
   chunked transfer-coding.

       Trailer  = &quot;Trailer&quot; &quot;:&quot; 1#field-name

   An HTTP/1.1 message SHOULD include a Trailer header field in a
   message using chunked transfer-coding with a non-empty trailer. Doing
   so allows the recipient to know which header fields to expect in the
   trailer.

   If no Trailer header field is present, the trailer SHOULD NOT include
   any header fields. See &lt;a href=&quot;#section-3.6.1&quot;&gt;section 3.6.1&lt;/a&gt; for restrictions on the use of
   trailer fields in a &quot;chunked&quot; transfer-coding.

   Message header fields listed in the Trailer header field MUST NOT
   include the following header fields:

      . Transfer-Encoding

      . Content-Length

      . Trailer</source>
          <target state="translated">Trailer常规字段值指示给定的报头字段集出现在以分块传输编码编码的消息的尾部中。 Trailer =&amp;ldquo; Trailer&amp;rdquo;&amp;ldquo; ::&amp;rdquo; 1＃field-name HTTP / 1.1消息应在消息中使用带非空尾部的分块传输编码，在消息中包含Trailer头字段。这样做可以使收件人知道预告片中应包含哪些标题字段。如果不存在Trailer标头字段，则预告片不应包含任何标头字段。有关在&amp;ldquo;块状&amp;rdquo;传输编码中使用尾部字段的限制，请参见&lt;a href=&quot;#section-3.6.1&quot;&gt;第3.6.1节&lt;/a&gt;。尾部标头字段中列出的消息标头字段不得包含以下标头字段：。传输编码。内容长度。预告片</target>
        </trans-unit>
        <trans-unit id="5a0c272967d0d482ca0381c6f18703875d017457" translate="yes" xml:space="preserve">
          <source>The Transfer-Encoding general-header field indicates what (if any)
   type of transformation has been applied to the message body in order
   to safely transfer it between the sender and the recipient. This
   differs from the content-coding in that the transfer-coding is a
   property of the message, not of the entity.

     Transfer-Encoding       = &quot;Transfer-Encoding&quot; &quot;:&quot; 1#transfer-coding

   Transfer-codings are defined in &lt;a href=&quot;#section-3.6&quot;&gt;section 3.6&lt;/a&gt;. An example is:

     Transfer-Encoding: chunked 

   If multiple encodings have been applied to an entity, the transfer-
   codings MUST be listed in the order in which they were applied.
   Additional information about the encoding parameters MAY be provided
   by other entity-header fields not defined by this specification.

   Many older HTTP/1.0 applications do not understand the Transfer-
   Encoding header.</source>
          <target state="translated">Transfer-Encoding的一般标头字段指示已将什么类型的转换（如果有）应用于邮件正文，以便在发送方和接收方之间安全地进行转换。这与内容编码不同，因为传输编码是消息的属性，而不是实体的属性。 Transfer-Encoding =&amp;ldquo; Transfer-Encoding&amp;rdquo;&amp;ldquo;：&amp;rdquo; 1＃transfer-coding传输代码在&lt;a href=&quot;#section-3.6&quot;&gt;3.6节&lt;/a&gt;中定义。一个示例是：传输编码：分块如果对一个实体应用了多种编码，则必须按其应用顺序列出传输编码。关于编码参数的附加信息可以由本规范未定义的其他实体报头字段提供。许多较旧的HTTP / 1.0应用程序不了解Transfer-Encoding标头。</target>
        </trans-unit>
        <trans-unit id="2b9c17fcff0e77e15eb4e1a1d785371389cb348c" translate="yes" xml:space="preserve">
          <source>The Transfer-Encoding header field lists the transfer coding names
   corresponding to the sequence of transfer codings that have been (or
   will be) applied to the payload body in order to form the message
   body.  Transfer codings are defined in &lt;a href=&quot;#section-4&quot;&gt;Section 4&lt;/a&gt;.

     Transfer-Encoding = 1#transfer-coding

   Transfer-Encoding is analogous to the Content-Transfer-Encoding field
   of MIME, which was designed to enable safe transport of binary data
   over a 7-bit transport service (&lt;a href=&quot;https://tools.ietf.org/html/rfc2045#section-6&quot;&gt;[RFC2045], Section&amp;nbsp;6&lt;/a&gt;).  However, safe
   transport has a different focus for an 8bit-clean transfer protocol.
   In HTTP's case, Transfer-Encoding is primarily intended to accurately
   delimit a dynamically generated payload and to distinguish payload
   encodings that are only applied for transport efficiency or security
   from those that are characteristics of the selected resource. 

   A recipient MUST be able to parse the chunked transfer coding
   (&lt;a href=&quot;#section-4.1&quot;&gt;Section 4.1&lt;/a&gt;) because it plays a crucial role in framing messages
   when the payload body size is not known in advance.  A sender MUST
   NOT apply chunked more than once to a message body (i.e., chunking an
   already chunked message is not allowed).  If any transfer coding
   other than chunked is applied to a request payload body, the sender
   MUST apply chunked as the final transfer coding to ensure that the
   message is properly framed.  If any transfer coding other than
   chunked is applied to a response payload body, the sender MUST either
   apply chunked as the final transfer coding or terminate the message
   by closing the connection.

   For example,

     Transfer-Encoding: gzip, chunked

   indicates that the payload body has been compressed using the gzip
   coding and then chunked using the chunked coding while forming the
   message body.

   Unlike Content-Encoding (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-3.1.2.1&quot;&gt;Section&amp;nbsp;3.1.2.1 of [RFC7231]&lt;/a&gt;),
   Transfer-Encoding is a property of the message, not of the
   representation, and any recipient along the request/response chain
   MAY decode the received transfer coding(s) or apply additional
   transfer coding(s) to the message body, assuming that corresponding
   changes are made to the Transfer-Encoding field-value.  Additional
   information about the encoding parameters can be provided by other
   header fields not defined by this specification.

   Transfer-Encoding MAY be sent in a response to a HEAD request or in a
   304 (Not Modified) response (&lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-4.1&quot;&gt;Section&amp;nbsp;4.1 of [RFC7232]&lt;/a&gt;) to a GET
   request, neither of which includes a message body, to indicate that
   the origin server would have applied a transfer coding to the message
   body if the request had been an unconditional GET.  This indication
   is not required, however, because any recipient on the response chain
   (including the origin server) can remove transfer codings when they
   are not needed.

   A server MUST NOT send a Transfer-Encoding header field in any
   response with a status code of 1xx (Informational) or 204 (No
   Content).  A server MUST NOT send a Transfer-Encoding header field in
   any 2xx (Successful) response to a CONNECT request (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.6&quot;&gt;Section&amp;nbsp;4.3.6 of
   [RFC7231]&lt;/a&gt;).

   Transfer-Encoding was added in HTTP/1.1.  It is generally assumed
   that implementations advertising only HTTP/1.0 support will not
   understand how to process a transfer-encoded payload.  A client MUST
   NOT send a request containing Transfer-Encoding unless it knows the 

   server will handle HTTP/1.1 (or later) requests; such knowledge might
   be in the form of specific user configuration or by remembering the
   version of a prior received response.  A server MUST NOT send a
   response containing Transfer-Encoding unless the corresponding
   request indicates HTTP/1.1 (or later).

   A server that receives a request message with a transfer coding it
   does not understand SHOULD respond with 501 (Not Implemented).</source>
          <target state="translated">Transfer-Encoding标头字段列出了与已（或将要）应用于有效负载主体以形成消息主体的传输编码序列相对应的传输编码名称。传输编码在&lt;a href=&quot;#section-4&quot;&gt;第4节&lt;/a&gt;中定义。 Transfer-Encoding = 1＃transfer-coding Transfer-Encoding与MIME的Content-Transfer-Encoding字段类似，该字段旨在支持通过7位传输服务安全地传输二进制数据（&lt;a href=&quot;https://tools.ietf.org/html/rfc2045#section-6&quot;&gt;[RFC2045]，第6节&lt;/a&gt;）。但是，安全传输对8bit-clean传输协议的关注点有所不同。在HTTP的情况下，Transfer-Encoding的主要目的是准确界定动态生成的有效负载，并将仅用于传输效率或安全性的有效负载编码与所选资源的特征区分开。接收者必须能够解析分块的传输编码（&lt;a href=&quot;#section-4.1&quot;&gt;第4.1节&lt;/a&gt;），因为它在事先不知道有效载荷主体大小的情况下在成帧消息中起着至关重要的作用。发送者不得对消息主体多次应用分块（即，不允许对已分块的消息进行分块）。如果将除块之外的任何传输编码应用于请求有效载荷主体，则发送方务必将块作为最终传输编码应用，以确保消息被正确地构架。如果将除分块之外的任何传输编码应用于响应有效载荷主体，则发送方务必将分块应用​​为最终传输编码，或者通过关闭连接来终止消息。例如，Transfer-Encoding：gzip，分块表示有效载荷主体已使用gzip编码进行了压缩，然后在形成消息主体时已使用分块编码进行了分块。与内容编码（&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-3.1.2.1&quot;&gt;[RFC7231]的第3.1.2.1节&lt;/a&gt;，传输编码是消息的属性，而不是表示的属性，并且请求/响应链上的任何接收者都可以对接收到的传输编码进行解码或应用其他传输编码。 ），并假定对&amp;ldquo;传输编码&amp;rdquo;字段值进行了相应的更改。关于编码参数的其他信息可以由本规范未定义的其他标头字段提供。可以在对HEAD请求的响应中或在304（未修改）响应中发送Transfer-Encoding（&lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-4.1&quot;&gt;[RFC7232]第4.1节&lt;/a&gt;）发送给GET请求（该请求均不包含消息正文），以指示如果请求是无条件GET，则原始服务器将对消息正文应用传输编码。但是，此指示不是必需的，因为响应链上的任何收件人（包括原始服务器）都可以在不需要时删除传输编码。服务器不得在状态码为1xx（信息性）或204（无内容）的任何响应中发送传输编码标头字段。服务器不得在对CONNECT请求的任何2xx（成功）响应中发送传输编码标头字段（&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.6&quot;&gt;[RFC7231]的第4.3.6节）&lt;/a&gt;）。在HTTP / 1.1中添加了传输编码。通常假定仅宣传HTTP / 1.0支持的实现将不了解如何处理传输编码的有效负载。除非客户端知道服务器将处理HTTP / 1.1（或更高版本）请求，否则客户端不得发送包含传输编码的请求。这样的知识可以采用特定用户配置的形式，也可以通过记住先前收到的响应的版本来实现。除非相应的请求指示HTTP / 1.1（或更高版本），否则服务器不得发送包含传输编码的响应。接收到带有传输编码的请求消息的服务器，它不理解应该以501（未实现）响应。</target>
        </trans-unit>
        <trans-unit id="1c8b20b0d07b7680a3c0f95ac8ec3b25b3de332b" translate="yes" xml:space="preserve">
          <source>The Transport Layer Security (TLS) Protocol Version 1.2</source>
          <target state="translated">传输层安全(TLS)协议1.2版。</target>
        </trans-unit>
        <trans-unit id="12fd383ebe402c54f473646772c58d3e6163c837" translate="yes" xml:space="preserve">
          <source>The Transport Layer Security (TLS) Protocol Version 1.3</source>
          <target state="translated">传输层安全(TLS)协议1.3版。</target>
        </trans-unit>
        <trans-unit id="8a56da9b77b531c4fafce5d057fc066caa86cf4f" translate="yes" xml:space="preserve">
          <source>The UA string of Firefox itself is broken down into four components:</source>
          <target state="translated">火狐浏览器的UA字符串本身被分解成四个部分。</target>
        </trans-unit>
        <trans-unit id="f72374d140af175240e14a12a7f961729a13b2d2" translate="yes" xml:space="preserve">
          <source>The UNLOCK method removes the lock identified by the lock token in
   the Lock-Token request header.  The Request-URI MUST identify a
   resource within the scope of the lock.

   Note that use of the Lock-Token header to provide the lock token is
   not consistent with other state-changing methods, which all require
   an If header with the lock token.  Thus, the If header is not needed
   to provide the lock token.  Naturally, when the If header is present,
   it has its normal meaning as a conditional header.

   For a successful response to this method, the server MUST delete the
   lock entirely.

   If all resources that have been locked under the submitted lock token
   cannot be unlocked, then the UNLOCK request MUST fail.

   A successful response to an UNLOCK method does not mean that the
   resource is necessarily unlocked.  It means that the specific lock
   corresponding to the specified token no longer exists.

   Any DAV-compliant resource that supports the LOCK method MUST support
   the UNLOCK method.

   This method is idempotent, but not safe (see &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;Section&amp;nbsp;9.1 of
   [RFC2616]&lt;/a&gt;).  Responses to this method MUST NOT be cached.</source>
          <target state="translated">UNLOCK方法删除由Lock-Token请求标头中的锁令牌标识的锁。请求URI必须标识锁范围内的资源。请注意，使用Lock-Token标头提供锁令牌与其他状态更改方法不一致，其他方法都需要带有锁令牌的If标头。因此，不需要If标头来提供锁定令牌。自然，当If标头存在时，它具有条件标头的正常含义。为了成功响应此方法，服务器必须完全删除该锁。如果所有在提交的锁定令牌下锁定的资源都无法解锁，则UNLOCK请求务必失败。对UNLOCK方法的成功响应并不意味着必须解锁资源。这意味着对应于指定令牌的特定锁不再存在。任何支持LOCK方法的兼容DAV的资源都必须支持UNLOCK方法。此方法是幂等的，但不安全（请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;[RFC2616]的9.1节&lt;/a&gt;）。对此方法的响应绝不能被缓存。</target>
        </trans-unit>
        <trans-unit id="b0025b4b69a4ce00bf003d08c44025493d147db8" translate="yes" xml:space="preserve">
          <source>The URI (absolute or relative) must be enclosed between &lt;code&gt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">URI（绝对或相对）必须包含在 &lt;code&gt;&amp;lt;&lt;/code&gt; 和 &lt;code&gt;&amp;gt;&lt;/code&gt; 之间：</target>
        </trans-unit>
        <trans-unit id="7dc195e95f3f78e1ec1e89ef97a6a85b571c15d4" translate="yes" xml:space="preserve">
          <source>The URI of the document in which the violation occurred.</source>
          <target state="translated">发生违规行为的文件的URI。</target>
        </trans-unit>
        <trans-unit id="a00094afe4ee340f38859ca45715a9f8d4fda91e" translate="yes" xml:space="preserve">
          <source>The URI of the resource that was blocked from loading by the Content Security Policy. If the blocked URI is from a different origin than the &lt;code&gt;document-uri&lt;/code&gt;, then the blocked URI is truncated to contain just the scheme, host, and port.</source>
          <target state="translated">内容安全策略阻止加载的资源的URI。如果被阻止的URI与 &lt;code&gt;document-uri&lt;/code&gt; 的来源不同，则被阻止的URI将被截断以仅包含方案，主机和端口。</target>
        </trans-unit>
        <trans-unit id="ceb66755626c081ee38ccbccf8e082e6464687a3" translate="yes" xml:space="preserve">
          <source>The URI of the resource that was blocked from loading by the Content Security Policy. If the blocked URI is from a different origin than the document-uri, then the blocked URI is truncated to contain just the scheme, host, and port.</source>
          <target state="translated">被内容安全策略阻止加载的资源的URI。如果被阻止的URI与文档的URI来源不同,那么被阻止的URI将被截断,只包含方案、主机和端口。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
